head	1.114;
access;
symbols
	drow_intercu-20040221-branch:1.112.0.6
	drow_intercu-20040221-branchpoint:1.112
	cagney_bfdfile-20040213-branch:1.112.0.4
	cagney_bfdfile-20040213-branchpoint:1.112
	drow-cplus-merge-20040208:1.112
	carlton_dictionary-20040126-merge:1.112
	cagney_bigcore-20040122-branch:1.112.0.2
	cagney_bigcore-20040122-branchpoint:1.112
	drow-cplus-merge-20040113:1.111
	drow-cplus-merge-20031224:1.106
	drow-cplus-merge-20031220:1.105
	carlton_dictionary-20031215-merge:1.105
	drow-cplus-merge-20031214:1.105
	carlton-dictionary-20031111-merge:1.101
	gdb_6_0-2003-10-04-release:1.79.2.8
	kettenis_sparc-20030918-branch:1.91.0.4
	kettenis_sparc-20030918-branchpoint:1.91
	carlton_dictionary-20030917-merge:1.91
	ezannoni_pie-20030916-branchpoint:1.91
	ezannoni_pie-20030916-branch:1.91.0.2
	cagney_x86i386-20030821-branch:1.89.0.2
	cagney_x86i386-20030821-branchpoint:1.89
	carlton_dictionary-20030805-merge:1.85
	carlton_dictionary-20030627-merge:1.80
	gdb_6_0-branch:1.79.0.2
	gdb_6_0-2003-06-23-branchpoint:1.79
	jimb-ppc64-linux-20030613-branch:1.78.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.78
	cagney_convert-20030606-branch:1.77.0.2
	cagney_convert-20030606-branchpoint:1.77
	cagney_writestrings-20030508-branch:1.69.0.4
	cagney_writestrings-20030508-branchpoint:1.69
	jimb-ppc64-linux-20030528-branch:1.71.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.71
	carlton_dictionary-20030523-merge:1.71
	cagney_fileio-20030521-branch:1.71.0.2
	cagney_fileio-20030521-branchpoint:1.71
	kettenis_i386newframe-20030517-mergepoint:1.70
	jimb-ppc64-linux-20030509-branch:1.69.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.69
	kettenis_i386newframe-20030504-mergepoint:1.68
	carlton_dictionary-20030430-merge:1.68
	kettenis_i386newframe-20030419-branch:1.67.0.2
	kettenis_i386newframe-20030419-branchpoint:1.67
	carlton_dictionary-20030416-merge:1.67
	cagney_frameaddr-20030409-mergepoint:1.63
	kettenis_i386newframe-20030406-branch:1.62.0.2
	kettenis_i386newframe-20030406-branchpoint:1.62
	cagney_frameaddr-20030403-branchpoint:1.60
	cagney_frameaddr-20030403-branch:1.60.0.2
	cagney_framebase-20030330-mergepoint:1.60
	cagney_framebase-20030326-branch:1.58.0.2
	cagney_framebase-20030326-branchpoint:1.58
	cagney_lazyid-20030317-branch:1.56.0.2
	cagney_lazyid-20030317-branchpoint:1.56
	kettenis-i386newframe-20030316-mergepoint:1.56
	offbyone-20030313-branch:1.54.0.2
	offbyone-20030313-branchpoint:1.54
	kettenis-i386newframe-20030308-branch:1.53.0.2
	kettenis-i386newframe-20030308-branchpoint:1.53
	carlton_dictionary-20030305-merge:1.51
	cagney_offbyone-20030303-branch:1.51.0.2
	cagney_offbyone-20030303-branchpoint:1.51
	carlton_dictionary-20030207-merge:1.47
	interps-20030203-mergepoint:1.46
	interps-20030202-branch:1.46.0.4
	interps-20030202-branchpoint:1.46
	cagney-unwind-20030108-branch:1.46.0.2
	cagney-unwind-20030108-branchpoint:1.46
	carlton_dictionary-20021223-merge:1.44
	gdb_5_3-2002-12-12-release:1.26
	carlton_dictionary-20021115-merge:1.38
	kseitz_interps-20021105-merge:1.36
	kseitz_interps-20021103-merge:1.36
	drow-cplus-merge-20021020:1.27
	drow-cplus-merge-20021025:1.30
	carlton_dictionary-20021025-merge:1.30
	carlton_dictionary-20021011-merge:1.27
	drow-cplus-branch:1.27.0.4
	drow-cplus-branchpoint:1.27
	kseitz_interps-20020930-merge:1.27
	carlton_dictionary-20020927-merge:1.27
	carlton_dictionary-branch:1.27.0.2
	carlton_dictionary-20020920-branchpoint:1.27
	gdb_5_3-branch:1.26.0.6
	gdb_5_3-2002-09-04-branchpoint:1.26
	kseitz_interps-20020829-merge:1.26
	cagney_sysregs-20020825-branch:1.26.0.4
	cagney_sysregs-20020825-branchpoint:1.26
	readline_4_3-import-branch:1.26.0.2
	readline_4_3-import-branchpoint:1.26
	gdb_5_2_1-2002-07-23-release:1.9.2.7
	kseitz_interps-20020528-branch:1.20.0.2
	kseitz_interps-20020528-branchpoint:1.20
	cagney_regbuf-20020515-branch:1.19.0.2
	cagney_regbuf-20020515-branchpoint:1.19
	jimb-macro-020506-branch:1.16.0.2
	jimb-macro-020506-branchpoint:1.16
	gdb_5_2-2002-04-29-release:1.9.2.4
	gdb_5_2-branch:1.9.0.2
	gdb_5_2-2002-03-03-branchpoint:1.9
	cygnus_cvs_20020108_pre:1.6;
locks; strict;
comment	@ * @;


1.114
date	2004.02.25.20.45.30;	author kettenis;	state dead;
branches;
next	1.113;

1.113
date	2004.02.23.21.37.52;	author kettenis;	state Exp;
branches;
next	1.112;

1.112
date	2004.01.17.22.45.44;	author cagney;	state Exp;
branches
	1.112.6.1;
next	1.111;

1.111
date	2004.01.10.17.58.30;	author kettenis;	state Exp;
branches;
next	1.110;

1.110
date	2004.01.10.17.48.15;	author kettenis;	state Exp;
branches;
next	1.109;

1.109
date	2004.01.10.13.21.06;	author kettenis;	state Exp;
branches;
next	1.108;

1.108
date	2004.01.10.12.52.41;	author kettenis;	state Exp;
branches;
next	1.107;

1.107
date	2004.01.04.19.07.02;	author kettenis;	state Exp;
branches;
next	1.106;

1.106
date	2003.12.20.13.36.00;	author kettenis;	state Exp;
branches;
next	1.105;

1.105
date	2003.11.29.00.54.41;	author kettenis;	state Exp;
branches;
next	1.104;

1.104
date	2003.11.27.23.33.07;	author kettenis;	state Exp;
branches;
next	1.103;

1.103
date	2003.11.27.20.35.38;	author kettenis;	state Exp;
branches;
next	1.102;

1.102
date	2003.11.20.22.37.50;	author kettenis;	state Exp;
branches;
next	1.101;

1.101
date	2003.10.26.14.47.26;	author kettenis;	state Exp;
branches;
next	1.100;

1.100
date	2003.10.11.14.19.11;	author kettenis;	state Exp;
branches;
next	1.99;

1.99
date	2003.10.05.22.54.10;	author kettenis;	state Exp;
branches;
next	1.98;

1.98
date	2003.10.05.22.13.24;	author kettenis;	state Exp;
branches;
next	1.97;

1.97
date	2003.10.05.22.02.49;	author kettenis;	state Exp;
branches;
next	1.96;

1.96
date	2003.10.05.21.31.33;	author kettenis;	state Exp;
branches;
next	1.95;

1.95
date	2003.10.02.20.28.30;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2003.09.28.13.35.44;	author kettenis;	state Exp;
branches;
next	1.93;

1.93
date	2003.09.27.21.57.56;	author kettenis;	state Exp;
branches;
next	1.92;

1.92
date	2003.09.27.18.11.58;	author kettenis;	state Exp;
branches;
next	1.91;

1.91
date	2003.08.23.13.58.18;	author kettenis;	state Exp;
branches;
next	1.90;

1.90
date	2003.08.23.12.21.14;	author aj;	state Exp;
branches;
next	1.89;

1.89
date	2003.08.18.20.04.55;	author cagney;	state Exp;
branches;
next	1.88;

1.88
date	2003.08.18.17.33.26;	author kettenis;	state Exp;
branches;
next	1.87;

1.87
date	2003.08.07.11.26.42;	author mludvig;	state Exp;
branches;
next	1.86;

1.86
date	2003.08.07.07.51.14;	author mludvig;	state Exp;
branches;
next	1.85;

1.85
date	2003.07.16.22.29.13;	author cagney;	state Exp;
branches;
next	1.84;

1.84
date	2003.07.13.16.38.04;	author kettenis;	state Exp;
branches;
next	1.83;

1.83
date	2003.07.13.16.31.43;	author kettenis;	state Exp;
branches;
next	1.82;

1.82
date	2003.07.09.22.10.58;	author kettenis;	state Exp;
branches;
next	1.81;

1.81
date	2003.07.02.07.45.57;	author aj;	state Exp;
branches;
next	1.80;

1.80
date	2003.06.26.17.08.10;	author aj;	state Exp;
branches;
next	1.79;

1.79
date	2003.06.15.11.01.46;	author kettenis;	state Exp;
branches
	1.79.2.1;
next	1.78;

1.78
date	2003.06.13.20.37.28;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2003.06.06.10.04.20;	author mludvig;	state Exp;
branches;
next	1.76;

1.76
date	2003.06.05.18.54.34;	author mludvig;	state Exp;
branches;
next	1.75;

1.75
date	2003.05.31.16.54.18;	author kettenis;	state Exp;
branches;
next	1.74;

1.74
date	2003.05.31.16.49.18;	author kettenis;	state Exp;
branches;
next	1.73;

1.73
date	2003.05.31.16.11.47;	author kettenis;	state Exp;
branches;
next	1.72;

1.72
date	2003.05.31.08.15.38;	author kettenis;	state Exp;
branches;
next	1.71;

1.71
date	2003.05.19.06.28.44;	author mludvig;	state Exp;
branches;
next	1.70;

1.70
date	2003.05.17.05.59.59;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2003.05.05.17.56.56;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2003.04.29.01.49.48;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2003.04.13.14.51.20;	author kettenis;	state Exp;
branches
	1.67.2.1;
next	1.66;

1.66
date	2003.04.13.13.33.49;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2003.04.13.12.32.02;	author kettenis;	state Exp;
branches;
next	1.64;

1.64
date	2003.04.11.18.15.39;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2003.04.09.15.08.27;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2003.04.04.21.04.33;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2003.04.04.19.30.49;	author ezannoni;	state Exp;
branches;
next	1.60;

1.60
date	2003.03.30.14.32.09;	author cagney;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2003.03.26.22.39.52;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2003.03.25.20.38.47;	author cagney;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2003.03.24.03.54.50;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2003.03.14.16.05.36;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2003.03.13.21.45.42;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2003.03.12.16.50.45;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2003.03.07.15.07.51;	author mludvig;	state Exp;
branches
	1.53.2.1;
next	1.52;

1.52
date	2003.03.07.10.43.00;	author mludvig;	state Exp;
branches;
next	1.51;

1.51
date	2003.03.02.04.02.25;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2003.03.02.00.11.43;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2003.02.20.00.01.07;	author carlton;	state Exp;
branches;
next	1.48;

1.48
date	2003.02.11.23.09.59;	author mludvig;	state Exp;
branches;
next	1.47;

1.47
date	2003.02.06.23.20.52;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2003.01.05.14.07.03;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2003.01.05.01.39.55;	author drow;	state Exp;
branches;
next	1.44;

1.44
date	2002.12.21.21.09.58;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2002.12.11.02.26.36;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2002.12.01.19.07.15;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2002.11.28.18.15.59;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.26.19.01.29;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.23.01.39.25;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2002.11.14.00.25.03;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.11.16.00.57;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2002.10.26.17.04.37;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2002.10.26.16.56.34;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2002.10.26.10.37.45;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2002.10.26.09.36.34;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2002.10.25.21.53.08;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2002.10.24.01.37.40;	author mludvig;	state Exp;
branches;
next	1.29;

1.29
date	2002.10.24.01.27.43;	author mludvig;	state Exp;
branches;
next	1.28;

1.28
date	2002.10.23.23.37.33;	author carlton;	state Exp;
branches;
next	1.27;

1.27
date	2002.09.12.08.39.26;	author amodra;	state Exp;
branches
	1.27.2.1
	1.27.4.1;
next	1.26;

1.26
date	2002.08.24.00.21.35;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.19.18.22.14;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.20.13.08.11;	author mludvig;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.14.22.55.41;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.11.06.11.31;	author mludvig;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.07.16.11.09;	author mludvig;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.27.13.37.38;	author mludvig;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2002.05.13.14.00.36;	author drow;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2002.05.12.02.16.04;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.07.11.22.54;	author mludvig;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.03.10.52.00;	author mludvig;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.29.18.27.31;	author mludvig;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.27.00.12.54;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.06.00.02.50;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.27.10.21.26;	author mludvig;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.25.07.59.16;	author mludvig;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.04.11.08.28;	author mludvig;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.27.02.55.13;	author cagney;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2002.02.27.02.47.21;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.20.18.05.51;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.27.15.22.27;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.11.22.16.48;	author msnyder;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.07.12.10.15;	author smid;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.01.01.21.35;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.21.17.19.37;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.21.12.19.15;	author smid;	state Exp;
branches;
next	;

1.9.2.1
date	2002.03.27.17.19.37;	author mludvig;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.04.27.00.11.18;	author cagney;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2002.04.27.22.57.23;	author mludvig;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2002.04.29.23.18.52;	author cagney;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2002.06.07.12.33.56;	author mludvig;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2002.07.03.06.00.26;	author mludvig;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2002.07.19.18.22.06;	author cagney;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.15.16.42.55;	author cagney;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.06.21.16.46.53;	author cagney;	state Exp;
branches;
next	;

1.20.2.1
date	2002.06.20.01.33.21;	author kseitz;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2002.07.22.21.47.04;	author kseitz;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2002.08.30.22.52.46;	author kseitz;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2002.10.01.00.46.15;	author kseitz;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.27.2.1
date	2002.10.22.00.17.28;	author carlton;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2002.10.25.23.49.55;	author carlton;	state Exp;
branches;
next	1.27.2.3;

1.27.2.3
date	2002.11.15.19.19.01;	author carlton;	state Exp;
branches;
next	1.27.2.4;

1.27.2.4
date	2002.12.23.19.38.50;	author carlton;	state Exp;
branches;
next	1.27.2.5;

1.27.2.5
date	2003.02.07.19.17.54;	author carlton;	state Exp;
branches;
next	1.27.2.6;

1.27.2.6
date	2003.03.06.00.56.33;	author carlton;	state Exp;
branches;
next	1.27.2.7;

1.27.2.7
date	2003.04.16.19.56.57;	author carlton;	state Exp;
branches;
next	1.27.2.8;

1.27.2.8
date	2003.05.01.00.46.53;	author carlton;	state Exp;
branches;
next	1.27.2.9;

1.27.2.9
date	2003.05.23.18.40.46;	author carlton;	state Exp;
branches;
next	1.27.2.10;

1.27.2.10
date	2003.06.27.21.50.13;	author carlton;	state Exp;
branches;
next	1.27.2.11;

1.27.2.11
date	2003.08.05.17.13.16;	author carlton;	state Exp;
branches;
next	1.27.2.12;

1.27.2.12
date	2003.09.17.21.28.36;	author carlton;	state Exp;
branches;
next	1.27.2.13;

1.27.2.13
date	2003.11.11.23.51.00;	author carlton;	state Exp;
branches;
next	1.27.2.14;

1.27.2.14
date	2003.12.16.00.00.52;	author carlton;	state Exp;
branches;
next	1.27.2.15;

1.27.2.15
date	2004.01.26.19.11.35;	author carlton;	state Exp;
branches;
next	;

1.27.4.1
date	2002.10.26.17.12.10;	author drow;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2003.12.14.20.27.34;	author drow;	state Exp;
branches;
next	1.27.4.3;

1.27.4.3
date	2003.12.24.22.08.39;	author drow;	state Exp;
branches;
next	1.27.4.4;

1.27.4.4
date	2004.01.13.16.12.03;	author drow;	state Exp;
branches;
next	1.27.4.5;

1.27.4.5
date	2004.02.09.19.43.49;	author drow;	state Exp;
branches;
next	;

1.53.2.1
date	2003.03.16.14.01.52;	author kettenis;	state Exp;
branches;
next	;

1.58.2.1
date	2003.03.30.16.35.23;	author cagney;	state Exp;
branches;
next	;

1.60.2.1
date	2003.04.10.21.33.50;	author cagney;	state Exp;
branches;
next	;

1.67.2.1
date	2003.05.04.11.37.46;	author kettenis;	state Exp;
branches;
next	1.67.2.2;

1.67.2.2
date	2003.05.17.15.09.15;	author kettenis;	state Exp;
branches;
next	1.67.2.3;

1.67.2.3
date	2003.05.18.09.44.26;	author kettenis;	state Exp;
branches;
next	1.67.2.4;

1.67.2.4
date	2003.05.18.17.57.00;	author kettenis;	state Exp;
branches;
next	1.67.2.5;

1.67.2.5
date	2003.05.19.16.58.19;	author kettenis;	state Exp;
branches;
next	1.67.2.6;

1.67.2.6
date	2003.05.29.13.39.48;	author kettenis;	state Exp;
branches;
next	;

1.79.2.1
date	2003.06.26.17.09.54;	author aj;	state Exp;
branches;
next	1.79.2.2;

1.79.2.2
date	2003.07.02.07.46.40;	author aj;	state Exp;
branches;
next	1.79.2.3;

1.79.2.3
date	2003.07.13.22.04.19;	author kettenis;	state Exp;
branches;
next	1.79.2.4;

1.79.2.4
date	2003.08.07.07.49.52;	author mludvig;	state Exp;
branches;
next	1.79.2.5;

1.79.2.5
date	2003.08.07.08.09.22;	author mludvig;	state Exp;
branches;
next	1.79.2.6;

1.79.2.6
date	2003.08.07.11.21.58;	author mludvig;	state Exp;
branches;
next	1.79.2.7;

1.79.2.7
date	2003.08.18.18.10.53;	author kettenis;	state Exp;
branches;
next	1.79.2.8;

1.79.2.8
date	2003.08.18.20.12.31;	author cagney;	state Exp;
branches;
next	;

1.112.6.1
date	2004.03.27.17.37.55;	author drow;	state dead;
branches;
next	;


desc
@@


1.114
log
@* amd64-tdep.h: Renamed from x86-64-tdep.h.
* amd64-tdep.c: Renamed from x86-64-tdep.c.  Include
"amd64-tdep.h" instead of "x86-64-tdep.h".
* amd64-nat.c: Include "amd64-tdep.h" instead of "x86-64-tdep.h".
* amd64-linux-tdep.h: Renamed from x86-64-linux.h.
* amd64-linux-tdep.c: Renamed from x86-64-linux-tdep.c.  Include
"amd64-tdep.h" and "amd64-linux-tdep.h" instead of "x86-64-tdep.h"
and "x86-64-tdep.c".
* amd64-linux-nat.c: Renamed from x86-64-linux-nat.c.  Include
"amd64-tdep.h" and "amd64-linux-tdep.h" instead of "x86-64-tdep.h"
and "x86-64-tdep.c".
* amd64bsd-nat.c: Update copyright year.
Include "amd64-tdep.h" instead of "x86-64-tdep.h".
* amd64fbsd-tdep.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64fbsd-nat.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64nbsd-tdep.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64nbsd-nat.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64obsd-tdep.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64obsd-nat.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* configure.host: (x86_64-*-linux*): Set gdb_target to linux64.
* configure.tgt (x86_64-*-linux*): Set gdb_target to linux64.
* Makefile.in (amd64_linux_tdep_h): Renamed from
x86_64_linux_tdep_h.
(amd64_tdep_h): Renamed from x86_64_tdep_h.
(amd64bsd-nat.o, amd64fbsd-nat.o, amd64fbsd-tdep.o, amd64-nat.o)
(amd64nbsd-nat.o, amd64nbsd-tdep.o, amd64obsd-nat.o)
(amd64obsd-tdep.o): Update dependencies.
(amd64-tdep.o, amd64-linux-nat.o, amd64-linux-tdep.o): New
dependencies.
(x86-64-linux-nat.o, x86-64-linux-tdep.o, x86-64-tdep.o): Remove
dependencies.
(ALLDEPFILES): Add amd64-tdep.c, amd64obsd-nat.c, amd64obsd-nat.c,
amd64-linux-nat.c amd64-linux-tdep.c.
* config/i386/tm-linux64.h: Renamed from tm-x86-64linux.h
* config/i386/nm-linux64.h: Renamed from nm-x86-64linux.h.
* config/i386/linux64.mt: Renamed from x86-64linux.mt.
(TDEPFILES): Replace x86-64-tdep.o and x86-64-linux-tdep.o with
amd64-tdep.o and amd64-linux-tdep.o.
(TM_FILE): Set to tm-linux64.h.
* config/i386/linux64.mh: Renamed from x86-64linux.mh.
(NAT_FILE): Set to nm-linux64.h.
(NATDEPFILES): Replace x86-64-linux-nat.o with amd64-linux-nat.o.
* config/i386/fbsd64.mt (TDEPFILES): Replace x86-64-tdep.o with
amd64-tdep.o.
* config/i386/nbsd64.mt (TDEPFILES): Replace x86-64-tdep.o with
amd64-tdep.o.
* config/i386/obsd64.mt (TDEPFILES): Replace x86-64-tdep.o with
amd64-tdep.o.
@
text
@/* Target-dependent code for AMD64.

   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
   Contributed by Jiri Smid, SuSE Labs.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "arch-utils.h"
#include "block.h"
#include "dummy-frame.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
#include "inferior.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "objfiles.h"
#include "regcache.h"
#include "regset.h"
#include "symfile.h"

#include "gdb_assert.h"

#include "x86-64-tdep.h"
#include "i387-tdep.h"

/* Note that the AMD64 architecture was previously known as x86-64.
   The latter is (forever) engraved into the canonical system name as
   returned by config.guess, and used as the name for the AMD64 port
   of GNU/Linux.  The BSD's have renamed their ports to amd64; they
   don't like to shout.  For GDB we prefer the amd64_-prefix over the
   x86_64_-prefix since it's so much easier to type.  */

/* Register information.  */

struct amd64_register_info
{
  char *name;
  struct type **type;
};

static struct amd64_register_info amd64_register_info[] =
{
  { "rax", &builtin_type_int64 },
  { "rbx", &builtin_type_int64 },
  { "rcx", &builtin_type_int64 },
  { "rdx", &builtin_type_int64 },
  { "rsi", &builtin_type_int64 },
  { "rdi", &builtin_type_int64 },
  { "rbp", &builtin_type_void_data_ptr },
  { "rsp", &builtin_type_void_data_ptr },

  /* %r8 is indeed register number 8.  */
  { "r8", &builtin_type_int64 },
  { "r9", &builtin_type_int64 },
  { "r10", &builtin_type_int64 },
  { "r11", &builtin_type_int64 },
  { "r12", &builtin_type_int64 },
  { "r13", &builtin_type_int64 },
  { "r14", &builtin_type_int64 },
  { "r15", &builtin_type_int64 },
  { "rip", &builtin_type_void_func_ptr },
  { "eflags", &builtin_type_int32 },
  { "cs", &builtin_type_int32 },
  { "ss", &builtin_type_int32 },
  { "ds", &builtin_type_int32 },
  { "es", &builtin_type_int32 },
  { "fs", &builtin_type_int32 },
  { "gs", &builtin_type_int32 },

  /* %st0 is register number 24.  */
  { "st0", &builtin_type_i387_ext },
  { "st1", &builtin_type_i387_ext },
  { "st2", &builtin_type_i387_ext },
  { "st3", &builtin_type_i387_ext },
  { "st4", &builtin_type_i387_ext },
  { "st5", &builtin_type_i387_ext },
  { "st6", &builtin_type_i387_ext },
  { "st7", &builtin_type_i387_ext },
  { "fctrl", &builtin_type_int32 },
  { "fstat", &builtin_type_int32 },
  { "ftag", &builtin_type_int32 },
  { "fiseg", &builtin_type_int32 },
  { "fioff", &builtin_type_int32 },
  { "foseg", &builtin_type_int32 },
  { "fooff", &builtin_type_int32 },
  { "fop", &builtin_type_int32 },

  /* %xmm0 is register number 40.  */
  { "xmm0", &builtin_type_v4sf },
  { "xmm1", &builtin_type_v4sf },
  { "xmm2", &builtin_type_v4sf },
  { "xmm3", &builtin_type_v4sf },
  { "xmm4", &builtin_type_v4sf },
  { "xmm5", &builtin_type_v4sf },
  { "xmm6", &builtin_type_v4sf },
  { "xmm7", &builtin_type_v4sf },
  { "xmm8", &builtin_type_v4sf },
  { "xmm9", &builtin_type_v4sf },
  { "xmm10", &builtin_type_v4sf },
  { "xmm11", &builtin_type_v4sf },
  { "xmm12", &builtin_type_v4sf },
  { "xmm13", &builtin_type_v4sf },
  { "xmm14", &builtin_type_v4sf },
  { "xmm15", &builtin_type_v4sf },
  { "mxcsr", &builtin_type_int32 }
};

/* Total number of registers.  */
#define AMD64_NUM_REGS \
  (sizeof (amd64_register_info) / sizeof (amd64_register_info[0]))

/* Return the name of register REGNUM.  */

static const char *
amd64_register_name (int regnum)
{
  if (regnum >= 0 && regnum < AMD64_NUM_REGS)
    return amd64_register_info[regnum].name;

  return NULL;
}

/* Return the GDB type object for the "standard" data type of data in
   register REGNUM. */

static struct type *
amd64_register_type (struct gdbarch *gdbarch, int regnum)
{
  gdb_assert (regnum >= 0 && regnum < AMD64_NUM_REGS);

  return *amd64_register_info[regnum].type;
}

/* DWARF Register Number Mapping as defined in the System V psABI,
   section 3.6.  */

static int amd64_dwarf_regmap[] =
{
  /* General Purpose Registers RAX, RDX, RCX, RBX, RSI, RDI.  */
  AMD64_RAX_REGNUM, AMD64_RDX_REGNUM,
  AMD64_RCX_REGNUM, AMD64_RBX_REGNUM,
  AMD64_RSI_REGNUM, AMD64_RDI_REGNUM,

  /* Frame Pointer Register RBP.  */
  AMD64_RBP_REGNUM,

  /* Stack Pointer Register RSP.  */
  AMD64_RSP_REGNUM,

  /* Extended Integer Registers 8 - 15.  */
  8, 9, 10, 11, 12, 13, 14, 15,

  /* Return Address RA.  Mapped to RIP.  */
  AMD64_RIP_REGNUM,

  /* SSE Registers 0 - 7.  */
  AMD64_XMM0_REGNUM + 0, AMD64_XMM1_REGNUM,
  AMD64_XMM0_REGNUM + 2, AMD64_XMM0_REGNUM + 3,
  AMD64_XMM0_REGNUM + 4, AMD64_XMM0_REGNUM + 5,
  AMD64_XMM0_REGNUM + 6, AMD64_XMM0_REGNUM + 7,

  /* Extended SSE Registers 8 - 15.  */
  AMD64_XMM0_REGNUM + 8, AMD64_XMM0_REGNUM + 9,
  AMD64_XMM0_REGNUM + 10, AMD64_XMM0_REGNUM + 11,
  AMD64_XMM0_REGNUM + 12, AMD64_XMM0_REGNUM + 13,
  AMD64_XMM0_REGNUM + 14, AMD64_XMM0_REGNUM + 15,

  /* Floating Point Registers 0-7.  */
  AMD64_ST0_REGNUM + 0, AMD64_ST0_REGNUM + 1,
  AMD64_ST0_REGNUM + 2, AMD64_ST0_REGNUM + 3,
  AMD64_ST0_REGNUM + 4, AMD64_ST0_REGNUM + 5,
  AMD64_ST0_REGNUM + 6, AMD64_ST0_REGNUM + 7
};

static const int amd64_dwarf_regmap_len =
  (sizeof (amd64_dwarf_regmap) / sizeof (amd64_dwarf_regmap[0]));

/* Convert DWARF register number REG to the appropriate register
   number used by GDB.  */

static int
amd64_dwarf_reg_to_regnum (int reg)
{
  int regnum = -1;

  if (reg >= 0 || reg < amd64_dwarf_regmap_len)
    regnum = amd64_dwarf_regmap[reg];

  if (regnum == -1)
    warning ("Unmapped DWARF Register #%d encountered\n", reg);

  return regnum;
}

/* Return nonzero if a value of type TYPE stored in register REGNUM
   needs any special handling.  */

static int
amd64_convert_register_p (int regnum, struct type *type)
{
  return i386_fp_regnum_p (regnum);
}


/* Register classes as defined in the psABI.  */

enum amd64_reg_class
{
  AMD64_INTEGER,
  AMD64_SSE,
  AMD64_SSEUP,
  AMD64_X87,
  AMD64_X87UP,
  AMD64_COMPLEX_X87,
  AMD64_NO_CLASS,
  AMD64_MEMORY
};

/* Return the union class of CLASS1 and CLASS2.  See the psABI for
   details.  */

static enum amd64_reg_class
amd64_merge_classes (enum amd64_reg_class class1, enum amd64_reg_class class2)
{
  /* Rule (a): If both classes are equal, this is the resulting class.  */
  if (class1 == class2)
    return class1;

  /* Rule (b): If one of the classes is NO_CLASS, the resulting class
     is the other class.  */
  if (class1 == AMD64_NO_CLASS)
    return class2;
  if (class2 == AMD64_NO_CLASS)
    return class1;

  /* Rule (c): If one of the classes is MEMORY, the result is MEMORY.  */
  if (class1 == AMD64_MEMORY || class2 == AMD64_MEMORY)
    return AMD64_MEMORY;

  /* Rule (d): If one of the classes is INTEGER, the result is INTEGER.  */
  if (class1 == AMD64_INTEGER || class2 == AMD64_INTEGER)
    return AMD64_INTEGER;

  /* Rule (e): If one of the classes is X87, X87UP, COMPLEX_X87 class,
     MEMORY is used as class.  */
  if (class1 == AMD64_X87 || class1 == AMD64_X87UP
      || class1 == AMD64_COMPLEX_X87 || class2 == AMD64_X87
      || class2 == AMD64_X87UP || class2 == AMD64_COMPLEX_X87)
    return AMD64_MEMORY;

  /* Rule (f): Otherwise class SSE is used.  */
  return AMD64_SSE;
}

static void amd64_classify (struct type *type, enum amd64_reg_class class[2]);

/* Return non-zero if TYPE is a non-POD structure or union type.  */

static int
amd64_non_pod_p (struct type *type)
{
  /* ??? A class with a base class certainly isn't POD, but does this
     catch all non-POD structure types?  */
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT && TYPE_N_BASECLASSES (type) > 0)
    return 1;

  return 0;
}

/* Classify TYPE according to the rules for aggregate (structures and
   arrays) and union types, and store the result in CLASS.  */

static void
amd64_classify_aggregate (struct type *type, enum amd64_reg_class class[2])
{
  int len = TYPE_LENGTH (type);

  /* 1. If the size of an object is larger than two eightbytes, or in
        C++, is a non-POD structure or union type, or contains
        unaligned fields, it has class memory.  */
  if (len > 16 || amd64_non_pod_p (type))
    {
      class[0] = class[1] = AMD64_MEMORY;
      return;
    }

  /* 2. Both eightbytes get initialized to class NO_CLASS.  */
  class[0] = class[1] = AMD64_NO_CLASS;

  /* 3. Each field of an object is classified recursively so that
        always two fields are considered. The resulting class is
        calculated according to the classes of the fields in the
        eightbyte: */

  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      struct type *subtype = check_typedef (TYPE_TARGET_TYPE (type));

      /* All fields in an array have the same type.  */
      amd64_classify (subtype, class);
      if (len > 8 && class[1] == AMD64_NO_CLASS)
	class[1] = class[0];
    }
  else
    {
      int i;

      /* Structure or union.  */
      gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT
		  || TYPE_CODE (type) == TYPE_CODE_UNION);

      for (i = 0; i < TYPE_NFIELDS (type); i++)
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));
	  int pos = TYPE_FIELD_BITPOS (type, i) / 64;
	  enum amd64_reg_class subclass[2];

	  /* Ignore static fields.  */
	  if (TYPE_FIELD_STATIC (type, i))
	    continue;

	  gdb_assert (pos == 0 || pos == 1);

	  amd64_classify (subtype, subclass);
	  class[pos] = amd64_merge_classes (class[pos], subclass[0]);
	  if (pos == 0)
	    class[1] = amd64_merge_classes (class[1], subclass[1]);
	}
    }

  /* 4. Then a post merger cleanup is done:  */

  /* Rule (a): If one of the classes is MEMORY, the whole argument is
     passed in memory.  */
  if (class[0] == AMD64_MEMORY || class[1] == AMD64_MEMORY)
    class[0] = class[1] = AMD64_MEMORY;

  /* Rule (b): If SSEUP is not preceeded by SSE, it is converted to
     SSE.  */
  if (class[0] == AMD64_SSEUP)
    class[0] = AMD64_SSE;
  if (class[1] == AMD64_SSEUP && class[0] != AMD64_SSE)
    class[1] = AMD64_SSE;
}

/* Classify TYPE, and store the result in CLASS.  */

static void
amd64_classify (struct type *type, enum amd64_reg_class class[2])
{
  enum type_code code = TYPE_CODE (type);
  int len = TYPE_LENGTH (type);

  class[0] = class[1] = AMD64_NO_CLASS;

  /* Arguments of types (signed and unsigned) _Bool, char, short, int,
     long, long long, and pointers are in the INTEGER class.  */
  if ((code == TYPE_CODE_INT || code == TYPE_CODE_ENUM
       || code == TYPE_CODE_PTR || code == TYPE_CODE_REF)
      && (len == 1 || len == 2 || len == 4 || len == 8))
    class[0] = AMD64_INTEGER;

  /* Arguments of types float, double and __m64 are in class SSE.  */
  else if (code == TYPE_CODE_FLT && (len == 4 || len == 8))
    /* FIXME: __m64 .  */
    class[0] = AMD64_SSE;

  /* Arguments of types __float128 and __m128 are split into two
     halves.  The least significant ones belong to class SSE, the most
     significant one to class SSEUP.  */
  /* FIXME: __float128, __m128.  */

  /* The 64-bit mantissa of arguments of type long double belongs to
     class X87, the 16-bit exponent plus 6 bytes of padding belongs to
     class X87UP.  */
  else if (code == TYPE_CODE_FLT && len == 16)
    /* Class X87 and X87UP.  */
    class[0] = AMD64_X87, class[1] = AMD64_X87UP;

  /* Aggregates.  */
  else if (code == TYPE_CODE_ARRAY || code == TYPE_CODE_STRUCT
	   || code == TYPE_CODE_UNION)
    amd64_classify_aggregate (type, class);
}

static enum return_value_convention
amd64_return_value (struct gdbarch *gdbarch, struct type *type,
		    struct regcache *regcache,
		    void *readbuf, const void *writebuf)
{
  enum amd64_reg_class class[2];
  int len = TYPE_LENGTH (type);
  static int integer_regnum[] = { AMD64_RAX_REGNUM, AMD64_RDX_REGNUM };
  static int sse_regnum[] = { AMD64_XMM0_REGNUM, AMD64_XMM1_REGNUM };
  int integer_reg = 0;
  int sse_reg = 0;
  int i;

  gdb_assert (!(readbuf && writebuf));

  /* 1. Classify the return type with the classification algorithm.  */
  amd64_classify (type, class);

  /* 2. If the type has class MEMORY, then the caller provides space
        for the return value and passes the address of this storage in
        %rdi as if it were the first argument to the function. In
        effect, this address becomes a hidden first argument.  */
  if (class[0] == AMD64_MEMORY)
    return RETURN_VALUE_STRUCT_CONVENTION;

  gdb_assert (class[1] != AMD64_MEMORY);
  gdb_assert (len <= 16);

  for (i = 0; len > 0; i++, len -= 8)
    {
      int regnum = -1;
      int offset = 0;

      switch (class[i])
	{
	case AMD64_INTEGER:
	  /* 3. If the class is INTEGER, the next available register
	     of the sequence %rax, %rdx is used.  */
	  regnum = integer_regnum[integer_reg++];
	  break;

	case AMD64_SSE:
	  /* 4. If the class is SSE, the next available SSE register
             of the sequence %xmm0, %xmm1 is used.  */
	  regnum = sse_regnum[sse_reg++];
	  break;

	case AMD64_SSEUP:
	  /* 5. If the class is SSEUP, the eightbyte is passed in the
	     upper half of the last used SSE register.  */
	  gdb_assert (sse_reg > 0);
	  regnum = sse_regnum[sse_reg - 1];
	  offset = 8;
	  break;

	case AMD64_X87:
	  /* 6. If the class is X87, the value is returned on the X87
             stack in %st0 as 80-bit x87 number.  */
	  regnum = AMD64_ST0_REGNUM;
	  if (writebuf)
	    i387_return_value (gdbarch, regcache);
	  break;

	case AMD64_X87UP:
	  /* 7. If the class is X87UP, the value is returned together
             with the previous X87 value in %st0.  */
	  gdb_assert (i > 0 && class[0] == AMD64_X87);
	  regnum = AMD64_ST0_REGNUM;
	  offset = 8;
	  len = 2;
	  break;

	case AMD64_NO_CLASS:
	  continue;

	default:
	  gdb_assert (!"Unexpected register class.");
	}

      gdb_assert (regnum != -1);

      if (readbuf)
	regcache_raw_read_part (regcache, regnum, offset, min (len, 8),
				(char *) readbuf + i * 8);
      if (writebuf)
	regcache_raw_write_part (regcache, regnum, offset, min (len, 8),
				 (const char *) writebuf + i * 8);
    }

  return RETURN_VALUE_REGISTER_CONVENTION;
}


static CORE_ADDR
amd64_push_arguments (struct regcache *regcache, int nargs,
		      struct value **args, CORE_ADDR sp, int struct_return)
{
  static int integer_regnum[] =
  {
    AMD64_RDI_REGNUM,		/* %rdi */
    AMD64_RSI_REGNUM,		/* %rsi */
    AMD64_RDX_REGNUM,		/* %rdx */
    AMD64_RCX_REGNUM,		/* %rcx */
    8,				/* %r8 */
    9				/* %r9 */
  };
  static int sse_regnum[] =
  {
    /* %xmm0 ... %xmm7 */
    AMD64_XMM0_REGNUM + 0, AMD64_XMM1_REGNUM,
    AMD64_XMM0_REGNUM + 2, AMD64_XMM0_REGNUM + 3,
    AMD64_XMM0_REGNUM + 4, AMD64_XMM0_REGNUM + 5,
    AMD64_XMM0_REGNUM + 6, AMD64_XMM0_REGNUM + 7,
  };
  struct value **stack_args = alloca (nargs * sizeof (struct value *));
  int num_stack_args = 0;
  int num_elements = 0;
  int element = 0;
  int integer_reg = 0;
  int sse_reg = 0;
  int i;

  /* Reserve a register for the "hidden" argument.  */
  if (struct_return)
    integer_reg++;

  for (i = 0; i < nargs; i++)
    {
      struct type *type = VALUE_TYPE (args[i]);
      int len = TYPE_LENGTH (type);
      enum amd64_reg_class class[2];
      int needed_integer_regs = 0;
      int needed_sse_regs = 0;
      int j;

      /* Classify argument.  */
      amd64_classify (type, class);

      /* Calculate the number of integer and SSE registers needed for
         this argument.  */
      for (j = 0; j < 2; j++)
	{
	  if (class[j] == AMD64_INTEGER)
	    needed_integer_regs++;
	  else if (class[j] == AMD64_SSE)
	    needed_sse_regs++;
	}

      /* Check whether enough registers are available, and if the
         argument should be passed in registers at all.  */
      if (integer_reg + needed_integer_regs > ARRAY_SIZE (integer_regnum)
	  || sse_reg + needed_sse_regs > ARRAY_SIZE (sse_regnum)
	  || (needed_integer_regs == 0 && needed_sse_regs == 0))
	{
	  /* The argument will be passed on the stack.  */
	  num_elements += ((len + 7) / 8);
	  stack_args[num_stack_args++] = args[i];
	}
      else
	{
	  /* The argument will be passed in registers.  */
	  char *valbuf = VALUE_CONTENTS (args[i]);
	  char buf[8];

	  gdb_assert (len <= 16);

	  for (j = 0; len > 0; j++, len -= 8)
	    {
	      int regnum = -1;
	      int offset = 0;

	      switch (class[j])
		{
		case AMD64_INTEGER:
		  regnum = integer_regnum[integer_reg++];
		  break;

		case AMD64_SSE:
		  regnum = sse_regnum[sse_reg++];
		  break;

		case AMD64_SSEUP:
		  gdb_assert (sse_reg > 0);
		  regnum = sse_regnum[sse_reg - 1];
		  offset = 8;
		  break;

		default:
		  gdb_assert (!"Unexpected register class.");
		}

	      gdb_assert (regnum != -1);
	      memset (buf, 0, sizeof buf);
	      memcpy (buf, valbuf + j * 8, min (len, 8));
	      regcache_raw_write_part (regcache, regnum, offset, 8, buf);
	    }
	}
    }

  /* Allocate space for the arguments on the stack.  */
  sp -= num_elements * 8;

  /* The psABI says that "The end of the input argument area shall be
     aligned on a 16 byte boundary."  */
  sp &= ~0xf;

  /* Write out the arguments to the stack.  */
  for (i = 0; i < num_stack_args; i++)
    {
      struct type *type = VALUE_TYPE (stack_args[i]);
      char *valbuf = VALUE_CONTENTS (stack_args[i]);
      int len = TYPE_LENGTH (type);

      write_memory (sp + element * 8, valbuf, len);
      element += ((len + 7) / 8);
    }

  /* The psABI says that "For calls that may call functions that use
     varargs or stdargs (prototype-less calls or calls to functions
     containing ellipsis (...) in the declaration) %al is used as
     hidden argument to specify the number of SSE registers used.  */
  regcache_raw_write_unsigned (regcache, AMD64_RAX_REGNUM, sse_reg);
  return sp; 
}

static CORE_ADDR
amd64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		       struct regcache *regcache, CORE_ADDR bp_addr,
		       int nargs, struct value **args,	CORE_ADDR sp,
		       int struct_return, CORE_ADDR struct_addr)
{
  char buf[8];

  /* Pass arguments.  */
  sp = amd64_push_arguments (regcache, nargs, args, sp, struct_return);

  /* Pass "hidden" argument".  */
  if (struct_return)
    {
      store_unsigned_integer (buf, 8, struct_addr);
      regcache_cooked_write (regcache, AMD64_RDI_REGNUM, buf);
    }

  /* Store return address.  */
  sp -= 8;
  store_unsigned_integer (buf, 8, bp_addr);
  write_memory (sp, buf, 8);

  /* Finally, update the stack pointer...  */
  store_unsigned_integer (buf, 8, sp);
  regcache_cooked_write (regcache, AMD64_RSP_REGNUM, buf);

  /* ...and fake a frame pointer.  */
  regcache_cooked_write (regcache, AMD64_RBP_REGNUM, buf);

  return sp + 16;
}


/* The maximum number of saved registers.  This should include %rip.  */
#define AMD64_NUM_SAVED_REGS	AMD64_NUM_GREGS

struct amd64_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  CORE_ADDR sp_offset;
  CORE_ADDR pc;

  /* Saved registers.  */
  CORE_ADDR saved_regs[AMD64_NUM_SAVED_REGS];
  CORE_ADDR saved_sp;

  /* Do we have a frame?  */
  int frameless_p;
};

/* Allocate and initialize a frame cache.  */

static struct amd64_frame_cache *
amd64_alloc_frame_cache (void)
{
  struct amd64_frame_cache *cache;
  int i;

  cache = FRAME_OBSTACK_ZALLOC (struct amd64_frame_cache);

  /* Base address.  */
  cache->base = 0;
  cache->sp_offset = -8;
  cache->pc = 0;

  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where %rbp is supposed to be stored).  */
  for (i = 0; i < AMD64_NUM_SAVED_REGS; i++)
    cache->saved_regs[i] = -1;
  cache->saved_sp = 0;

  /* Frameless until proven otherwise.  */
  cache->frameless_p = 1;

  return cache;
}

/* Do a limited analysis of the prologue at PC and update CACHE
   accordingly.  Bail out early if CURRENT_PC is reached.  Return the
   address where the analysis stopped.

   We will handle only functions beginning with:

      pushq %rbp        0x55
      movq %rsp, %rbp   0x48 0x89 0xe5

   Any function that doesn't start with this sequence will be assumed
   to have no prologue and thus no valid frame pointer in %rbp.  */

static CORE_ADDR
amd64_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
			struct amd64_frame_cache *cache)
{
  static unsigned char proto[3] = { 0x48, 0x89, 0xe5 };
  unsigned char buf[3];
  unsigned char op;

  if (current_pc <= pc)
    return current_pc;

  op = read_memory_unsigned_integer (pc, 1);

  if (op == 0x55)		/* pushq %rbp */
    {
      /* Take into account that we've executed the `pushq %rbp' that
         starts this instruction sequence.  */
      cache->saved_regs[AMD64_RBP_REGNUM] = 0;
      cache->sp_offset += 8;

      /* If that's all, return now.  */
      if (current_pc <= pc + 1)
        return current_pc;

      /* Check for `movq %rsp, %rbp'.  */
      read_memory (pc + 1, buf, 3);
      if (memcmp (buf, proto, 3) != 0)
	return pc + 1;

      /* OK, we actually have a frame.  */
      cache->frameless_p = 0;
      return pc + 4;
    }

  return pc;
}

/* Return PC of first real instruction.  */

static CORE_ADDR
amd64_skip_prologue (CORE_ADDR start_pc)
{
  struct amd64_frame_cache cache;
  CORE_ADDR pc;

  pc = amd64_analyze_prologue (start_pc, 0xffffffffffffffff, &cache);
  if (cache.frameless_p)
    return start_pc;

  return pc;
}


/* Normal frames.  */

static struct amd64_frame_cache *
amd64_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct amd64_frame_cache *cache;
  char buf[8];
  int i;

  if (*this_cache)
    return *this_cache;

  cache = amd64_alloc_frame_cache ();
  *this_cache = cache;

  cache->pc = frame_func_unwind (next_frame);
  if (cache->pc != 0)
    amd64_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);

  if (cache->frameless_p)
    {
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  If
	 we're at the start of a function, or somewhere half-way its
	 prologue, the function's frame probably hasn't been fully
	 setup yet.  Try to reconstruct the base address for the stack
	 frame by looking at the stack pointer.  For truly "frameless"
	 functions this might work too.  */

      frame_unwind_register (next_frame, AMD64_RSP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 8) + cache->sp_offset;
    }
  else
    {
      frame_unwind_register (next_frame, AMD64_RBP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 8);
    }

  /* Now that we have the base address for the stack frame we can
     calculate the value of %rsp in the calling frame.  */
  cache->saved_sp = cache->base + 16;

  /* For normal frames, %rip is stored at 8(%rbp).  If we don't have a
     frame we find it at the same offset from the reconstructed base
     address.  */
  cache->saved_regs[AMD64_RIP_REGNUM] = 8;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < AMD64_NUM_SAVED_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] += cache->base;

  return cache;
}

static void
amd64_frame_this_id (struct frame_info *next_frame, void **this_cache,
		     struct frame_id *this_id)
{
  struct amd64_frame_cache *cache =
    amd64_frame_cache (next_frame, this_cache);

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;

  (*this_id) = frame_id_build (cache->base + 16, cache->pc);
}

static void
amd64_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			   int regnum, int *optimizedp,
			   enum lval_type *lvalp, CORE_ADDR *addrp,
			   int *realnump, void *valuep)
{
  struct amd64_frame_cache *cache =
    amd64_frame_cache (next_frame, this_cache);

  gdb_assert (regnum >= 0);

  if (regnum == SP_REGNUM && cache->saved_sp)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* Store the value.  */
	  store_unsigned_integer (valuep, 8, cache->saved_sp);
	}
      return;
    }

  if (regnum < AMD64_NUM_SAVED_REGS && cache->saved_regs[regnum] != -1)
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
	}
      return;
    }

  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind amd64_frame_unwind =
{
  NORMAL_FRAME,
  amd64_frame_this_id,
  amd64_frame_prev_register
};

static const struct frame_unwind *
amd64_frame_sniffer (struct frame_info *next_frame)
{
  return &amd64_frame_unwind;
}


/* Signal trampolines.  */

/* FIXME: kettenis/20030419: Perhaps, we can unify the 32-bit and
   64-bit variants.  This would require using identical frame caches
   on both platforms.  */

static struct amd64_frame_cache *
amd64_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct amd64_frame_cache *cache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  CORE_ADDR addr;
  char buf[8];
  int i;

  if (*this_cache)
    return *this_cache;

  cache = amd64_alloc_frame_cache ();

  frame_unwind_register (next_frame, AMD64_RSP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 8) - 8;

  addr = tdep->sigcontext_addr (next_frame);
  gdb_assert (tdep->sc_reg_offset);
  gdb_assert (tdep->sc_num_regs <= AMD64_NUM_SAVED_REGS);
  for (i = 0; i < tdep->sc_num_regs; i++)
    if (tdep->sc_reg_offset[i] != -1)
      cache->saved_regs[i] = addr + tdep->sc_reg_offset[i];

  *this_cache = cache;
  return cache;
}

static void
amd64_sigtramp_frame_this_id (struct frame_info *next_frame,
			      void **this_cache, struct frame_id *this_id)
{
  struct amd64_frame_cache *cache =
    amd64_sigtramp_frame_cache (next_frame, this_cache);

  (*this_id) = frame_id_build (cache->base + 16, frame_pc_unwind (next_frame));
}

static void
amd64_sigtramp_frame_prev_register (struct frame_info *next_frame,
				    void **this_cache,
				    int regnum, int *optimizedp,
				    enum lval_type *lvalp, CORE_ADDR *addrp,
				    int *realnump, void *valuep)
{
  /* Make sure we've initialized the cache.  */
  amd64_sigtramp_frame_cache (next_frame, this_cache);

  amd64_frame_prev_register (next_frame, this_cache, regnum,
			     optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind amd64_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  amd64_sigtramp_frame_this_id,
  amd64_sigtramp_frame_prev_register
};

static const struct frame_unwind *
amd64_sigtramp_frame_sniffer (struct frame_info *next_frame)
{
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  char *name;

  find_pc_partial_function (pc, &name, NULL, NULL);
  if (PC_IN_SIGTRAMP (pc, name))
    {
      gdb_assert (gdbarch_tdep (current_gdbarch)->sigcontext_addr);

      return &amd64_sigtramp_frame_unwind;
    }

  return NULL;
}


static CORE_ADDR
amd64_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct amd64_frame_cache *cache =
    amd64_frame_cache (next_frame, this_cache);

  return cache->base;
}

static const struct frame_base amd64_frame_base =
{
  &amd64_frame_unwind,
  amd64_frame_base_address,
  amd64_frame_base_address,
  amd64_frame_base_address
};

static struct frame_id
amd64_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  char buf[8];
  CORE_ADDR fp;

  frame_unwind_register (next_frame, AMD64_RBP_REGNUM, buf);
  fp = extract_unsigned_integer (buf, 8);

  return frame_id_build (fp + 16, frame_pc_unwind (next_frame));
}

/* 16 byte align the SP per frame requirements.  */

static CORE_ADDR
amd64_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  return sp & -(CORE_ADDR)16;
}


/* Supply register REGNUM from the floating-point register set REGSET
   to register cache REGCACHE.  If REGNUM is -1, do this for all
   registers in REGSET.  */

static void
amd64_supply_fpregset (const struct regset *regset, struct regcache *regcache,
		       int regnum, const void *fpregs, size_t len)
{
  const struct gdbarch_tdep *tdep = regset->descr;

  gdb_assert (len == tdep->sizeof_fpregset);
  amd64_supply_fxsave (regcache, regnum, fpregs);
}

/* Return the appropriate register set for the core section identified
   by SECT_NAME and SECT_SIZE.  */

static const struct regset *
amd64_regset_from_core_section (struct gdbarch *gdbarch,
				const char *sect_name, size_t sect_size)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (strcmp (sect_name, ".reg2") == 0 && sect_size == tdep->sizeof_fpregset)
    {
      if (tdep->fpregset == NULL)
	{
	  tdep->fpregset = XMALLOC (struct regset);
	  tdep->fpregset->descr = tdep;
	  tdep->fpregset->supply_regset = amd64_supply_fpregset;
	}

      return tdep->fpregset;
    }

  return i386_regset_from_core_section (gdbarch, sect_name, sect_size);
}


void
amd64_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* AMD64 generally uses `fxsave' instead of `fsave' for saving its
     floating-point registers.  */
  tdep->sizeof_fpregset = I387_SIZEOF_FXSAVE;

  /* AMD64 has an FPU and 16 SSE registers.  */
  tdep->st0_regnum = AMD64_ST0_REGNUM;
  tdep->num_xmm_regs = 16;

  /* This is what all the fuss is about.  */
  set_gdbarch_long_bit (gdbarch, 64);
  set_gdbarch_long_long_bit (gdbarch, 64);
  set_gdbarch_ptr_bit (gdbarch, 64);

  /* In contrast to the i386, on AMD64 a `long double' actually takes
     up 128 bits, even though it's still based on the i387 extended
     floating-point format which has only 80 significant bits.  */
  set_gdbarch_long_double_bit (gdbarch, 128);

  set_gdbarch_num_regs (gdbarch, AMD64_NUM_REGS);
  set_gdbarch_register_name (gdbarch, amd64_register_name);
  set_gdbarch_register_type (gdbarch, amd64_register_type);

  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, AMD64_RSP_REGNUM); /* %rsp */
  set_gdbarch_pc_regnum (gdbarch, AMD64_RIP_REGNUM); /* %rip */
  set_gdbarch_ps_regnum (gdbarch, AMD64_EFLAGS_REGNUM); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, AMD64_ST0_REGNUM); /* %st(0) */

  /* The "default" register numbering scheme for AMD64 is referred to
     as the "DWARF Register Number Mapping" in the System V psABI.
     The preferred debugging format for all known AMD64 targets is
     actually DWARF2, and GCC doesn't seem to support DWARF (that is
     DWARF-1), but we provide the same mapping just in case.  This
     mapping is also used for stabs, which GCC does support.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, amd64_dwarf_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, amd64_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, amd64_dwarf_reg_to_regnum);

  /* We don't override SDB_REG_RO_REGNUM, since COFF doesn't seem to
     be in use on any of the supported AMD64 targets.  */

  /* Call dummy code.  */
  set_gdbarch_push_dummy_call (gdbarch, amd64_push_dummy_call);
  set_gdbarch_frame_align (gdbarch, amd64_frame_align);
  set_gdbarch_frame_red_zone_size (gdbarch, 128);

  set_gdbarch_convert_register_p (gdbarch, amd64_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, i387_register_to_value);
  set_gdbarch_value_to_register (gdbarch, i387_value_to_register);

  set_gdbarch_return_value (gdbarch, amd64_return_value);

  set_gdbarch_skip_prologue (gdbarch, amd64_skip_prologue);

  /* Avoid wiring in the MMX registers for now.  */
  set_gdbarch_num_pseudo_regs (gdbarch, 0);
  tdep->mm0_regnum = -1;

  set_gdbarch_unwind_dummy_id (gdbarch, amd64_unwind_dummy_id);

  /* FIXME: kettenis/20021026: This is ELF-specific.  Fine for now,
     since all supported AMD64 targets are ELF, but that might change
     in the future.  */
  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);

  frame_unwind_append_sniffer (gdbarch, amd64_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, amd64_frame_sniffer);
  frame_base_set_default (gdbarch, &amd64_frame_base);

  /* If we have a register mapping, enable the generic core file support.  */
  if (tdep->gregset_reg_offset)
    set_gdbarch_regset_from_core_section (gdbarch,
					  amd64_regset_from_core_section);
}


#define I387_ST0_REGNUM AMD64_ST0_REGNUM

/* The 64-bit FXSAVE format differs from the 32-bit format in the
   sense that the instruction pointer and data pointer are simply
   64-bit offsets into the code segment and the data segment instead
   of a selector offset pair.  The functions below store the upper 32
   bits of these pointers (instead of just the 16-bits of the segment
   selector).  */

/* Fill register REGNUM in REGCACHE with the appropriate
   floating-point or SSE register value from *FXSAVE.  If REGNUM is
   -1, do this for all registers.  This function masks off any of the
   reserved bits in *FXSAVE.  */

void
amd64_supply_fxsave (struct regcache *regcache, int regnum,
		      const void *fxsave)
{
  i387_supply_fxsave (regcache, regnum, fxsave);

  if (fxsave)
    {
      const char *regs = fxsave;

      if (regnum == -1 || regnum == I387_FISEG_REGNUM)
	regcache_raw_supply (regcache, I387_FISEG_REGNUM, regs + 12);
      if (regnum == -1 || regnum == I387_FOSEG_REGNUM)
	regcache_raw_supply (regcache, I387_FOSEG_REGNUM, regs + 20);
    }
}

/* Fill register REGNUM (if it is a floating-point or SSE register) in
   *FXSAVE with the value in GDB's register cache.  If REGNUM is -1, do
   this for all registers.  This function doesn't touch any of the
   reserved bits in *FXSAVE.  */

void
amd64_fill_fxsave (char *fxsave, int regnum)
{
  i387_fill_fxsave (fxsave, regnum);

  if (regnum == -1 || regnum == I387_FISEG_REGNUM)
    regcache_collect (I387_FISEG_REGNUM, fxsave + 12);
  if (regnum == -1 || regnum == I387_FOSEG_REGNUM)
    regcache_collect (I387_FOSEG_REGNUM, fxsave + 20);
}
@


1.113
log
@* x86-64-tdep.h: Tewak comment.
(enum amd64_regnum): New.
(X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, X86_64_RDI_REGNUM)
(X86_64_RBP_REGNUM, X86_64_RSP_REGNUM, X86_64_RIP_REGNUM)
(X86_64_EFLAGS_REGNUM, X86_64_ST0_REGNUM, X86_64_XMM0_REGNUM)
(X86_64_XMM1_REGNUM): Removed.
(AMD64_NUM_GREGS): Renamed from X86_64_NUM_GREGS.
(amd64_init_abi, amd64_supply_fxsave, amd64_fill_fxsave): Adjust
prototypes for renamed functions.
* x86-64-tdep.c: Fix typo.
(amd64_dwarf_regmap): Use constants from `enum amd64_regnum' for
register numbers.
(amd64_return_value, amd64_push_arguments, amd64_push_dummy_call):
Use constants from `enum amd64_regnum' for register numbers.
(AMD64_NUM_SAVED_REGS): Adjust for renamed macros.
(amd64_analyze_prologue, amd64_frame_cache,
amd64_sigtramp_frame_cache): Use constants from `enum
amd64_regnum' for register numbers.
(amd64_supply_fpregset): Adjust for renamed functions.
(amd64_init_abi): Rename from x86_64_init_abi.  Use constants from
`enum amd64_regnum' for register numbers.
(I387_ST0_REGNUM): Use constant from `enum amd64_regnum'.
(amd64_supply_fxsave): Rename from x86_64_supply_fxsave.
(amd64_fill_fxsave): Rename fro x86_64_fill_fxsave.
* x86-64-linux-tdep.c (amd64_linux_supply_gregset)
(amd64_linux_fill_gregset): Adjust for renamed macros.
(fetch_core_registers): Adjust for renamed functions.
(amd64_linux_init_abi): Adjust for renamed functions.
* x86-64-linux-nat.c (supply_gregset, fill_gregset): Adjust for
renamed functions.
* amd64-nat.c: Adjust for renamed macros.
* amd64bsd-nat.c (fetch_inferior_registers)
(store_inferior_registers): Use constants from `enum amd64_regnum'
for register numbers.  Adjust for renamed variables.
* amd64fbsd-nat.c (supply_gregset, fill_gregset): Adjust for
renamed variables.
(_initialize_amd64fbsd_nat): Use constants from `enum
amd64_regnum' for register numbers.
* amd64fbsd-tdep.c (amd64fbsd_sigcontext_addr): Use constants from
`enum amd64_regnum' for register numbers.
(amd64fbsd_init_abi): Adjust for renamed functions.
* amd64nbsd-tdep.c (amd64nbsd_sigcontext_addr): Use constants from
`enum amd64_regnum' for register numbers.
(amd64nbsd_init_abi): Adjust for renamed functions.
(_initialize_amd64nbsd_ndep): Adjust for renamed macros.
* amd64obsd-tdep.c (amd64obsd_sigcontext_addr): Use constants from
`enum amd64_regnum' for register numbers.
(amd64obsd_init_abi): Adjust for renamed functions.
(_initialize_amd64obsd_ndep): Adjust for renamed macros.
@
text
@@


1.112
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* x86-64-tdep.c (x86_64_init_abi): No need to clear
	extract_struct_value_address, i386 does not set it.
	* sparc64-tdep.c (sparc64_init_abi): Do not set
	extract_struct_value_address, never called.
	(sparc64_extract_struct_value_address): Delete function.
	* m68hc11-tdep.c: Update copyright.
	(m68hc11_gdbarch_init): Delete redundant assignment of
	extract_struct_value_address.
	* i386-tdep.c: Update copyright.
	(i386_gdbarch_init): Do not set extract_struct_value_address,
	never called.
	(i386_extract_struct_value_address): Delete function.
	* sparc-tdep.c (sparc32_gdbarch_init): Do not set
	extract_struct_value_address, never called.
	(sparc32_extract_struct_value_address): #if 0 function.
@
text
@d45 1
a45 1
   returned bu config.guess, and used as the name for the AMD64 port
d157 3
a159 2
  X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, 2, 1,
  4, X86_64_RDI_REGNUM,
d162 1
a162 1
  X86_64_RBP_REGNUM,
d165 1
a165 1
  X86_64_RSP_REGNUM,
d171 1
a171 1
  X86_64_RIP_REGNUM,
d174 4
a177 4
  X86_64_XMM0_REGNUM + 0, X86_64_XMM1_REGNUM,
  X86_64_XMM0_REGNUM + 2, X86_64_XMM0_REGNUM + 3,
  X86_64_XMM0_REGNUM + 4, X86_64_XMM0_REGNUM + 5,
  X86_64_XMM0_REGNUM + 6, X86_64_XMM0_REGNUM + 7,
d180 4
a183 4
  X86_64_XMM0_REGNUM + 8, X86_64_XMM0_REGNUM + 9,
  X86_64_XMM0_REGNUM + 10, X86_64_XMM0_REGNUM + 11,
  X86_64_XMM0_REGNUM + 12, X86_64_XMM0_REGNUM + 13,
  X86_64_XMM0_REGNUM + 14, X86_64_XMM0_REGNUM + 15,
d186 4
a189 4
  X86_64_ST0_REGNUM + 0, X86_64_ST0_REGNUM + 1,
  X86_64_ST0_REGNUM + 2, X86_64_ST0_REGNUM + 3,
  X86_64_ST0_REGNUM + 4, X86_64_ST0_REGNUM + 5,
  X86_64_ST0_REGNUM + 6, X86_64_ST0_REGNUM + 7
d410 2
a411 2
  static int integer_regnum[] = { X86_64_RAX_REGNUM, X86_64_RDX_REGNUM };
  static int sse_regnum[] = { X86_64_XMM0_REGNUM, X86_64_XMM1_REGNUM };
d461 1
a461 1
	  regnum = X86_64_ST0_REGNUM;
d470 1
a470 1
	  regnum = X86_64_ST0_REGNUM;
d502 6
a507 3
    X86_64_RDI_REGNUM, 4,	/* %rdi, %rsi */
    X86_64_RDX_REGNUM, 2,	/* %rdx, %rcx */
    8, 9			/* %r8, %r9 */
d512 4
a515 4
    X86_64_XMM0_REGNUM + 0, X86_64_XMM1_REGNUM,
    X86_64_XMM0_REGNUM + 2, X86_64_XMM0_REGNUM + 3,
    X86_64_XMM0_REGNUM + 4, X86_64_XMM0_REGNUM + 5,
    X86_64_XMM0_REGNUM + 6, X86_64_XMM0_REGNUM + 7,
d624 1
a624 1
  regcache_raw_write_unsigned (regcache, X86_64_RAX_REGNUM, sse_reg);
d643 1
a643 1
      regcache_cooked_write (regcache, X86_64_RDI_REGNUM, buf);
d653 1
a653 1
  regcache_cooked_write (regcache, X86_64_RSP_REGNUM, buf);
d656 1
a656 1
  regcache_cooked_write (regcache, X86_64_RBP_REGNUM, buf);
d663 1
a663 1
#define AMD64_NUM_SAVED_REGS	X86_64_NUM_GREGS
d736 1
a736 1
      cache->saved_regs[X86_64_RBP_REGNUM] = 0;
d801 1
a801 1
      frame_unwind_register (next_frame, X86_64_RSP_REGNUM, buf);
d806 1
a806 1
      frame_unwind_register (next_frame, X86_64_RBP_REGNUM, buf);
d817 1
a817 1
  cache->saved_regs[X86_64_RIP_REGNUM] = 8;
d920 1
a920 1
  frame_unwind_register (next_frame, X86_64_RSP_REGNUM, buf);
d1006 1
a1006 1
  frame_unwind_register (next_frame, X86_64_RBP_REGNUM, buf);
d1032 1
a1032 1
  x86_64_supply_fxsave (regcache, regnum, fpregs);
d1061 1
a1061 1
x86_64_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
d1070 1
a1070 1
  tdep->st0_regnum = X86_64_ST0_REGNUM;
d1088 4
a1091 4
  set_gdbarch_sp_regnum (gdbarch, X86_64_RSP_REGNUM); /* %rsp */
  set_gdbarch_pc_regnum (gdbarch, X86_64_RIP_REGNUM); /* %rip */
  set_gdbarch_ps_regnum (gdbarch, X86_64_EFLAGS_REGNUM); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, X86_64_ST0_REGNUM); /* %st(0) */
d1141 1
a1141 1
#define I387_ST0_REGNUM X86_64_ST0_REGNUM
d1156 1
a1156 1
x86_64_supply_fxsave (struct regcache *regcache, int regnum,
d1178 1
a1178 1
x86_64_fill_fxsave (char *fxsave, int regnum)
@


1.112.6.1
log
@Merge mainline to intercu branch.
@
text
@@


1.111
log
@* x86-64-tdep.c (amd64_non_pod_p): New function.
(amd64_classify_aggregate): Return class memory for non-POD
C++ structure types.
@
text
@a1111 2
  /* Override, since this is handled by amd64_extract_return_value.  */
  set_gdbarch_extract_struct_value_address (gdbarch, NULL);
@


1.110
log
@* x86-64-tdep.c (amd64_push_arguments): Add struct_return
argument.  Use it to reserve a register if necessary.
(amd64_push_dummy_call): Pass STRUCT_RETURN in call to
amd64_push_arguments.
@
text
@d273 13
d297 1
a297 1
  if (len > 16)
@


1.109
log
@* x86-64-tdep.c (amd64_classify_aggregate): Ignore static fields.
@
text
@d484 1
a484 1
		      struct value **args, CORE_ADDR sp)
d508 4
d620 1
a620 1
  sp = amd64_push_arguments (regcache, nargs, args, sp);
@


1.108
log
@* x86-64-tdep.c (amd64_register_info): Add %cs and %ss.  Adjust
register numbers in comments.
* x86-64-tdep.h: Update copyright year.
(X86_64_ST0_REGNUM, X86_64_XMM0_REGNUM, X86_64_XMM1_REGNUM):
Adjust for addition of %cs and %ss.
* amd64fbsd-nat.c: Update copyright year.
(reg_offset): Add register offsets for %cs and %ss.
* amd64fbsd-tdep.c: Update copyright year.
(amd64fbsd_r_reg_offset): Add register offsets for %cs and %ss.
(amd64fbsd_sc_reg_offset): Likewise.
* x86-64-linux-nat.c: Update copyright year.
(x86_64_linux_gregset64_reg_offset): Add register offsets for %cs
and %ss.
* amd64nbsd-nat.c: Update copyright year.
(amd64nbsd32_r_reg_offset): Add register offsets for %cs and %ss.
* amd64nbsd-tdep.c: Update copyright year.
(amd64nbsd_r_reg_offset): Add register offsets for %cs and %ss.
* x86-64-linux-tdep.c: Update copyright year.
(user_to_gdb_regmap): Add mapping for %cs and %ss.
(x86_64_linux_sc_reg_offset): Adjust for addition of %cs and %ss.
* regformats/reg-x86-64.dat: Add %cs and %ss.
@
text
@d321 4
@


1.107
log
@* x86-64-tdep.c: Update copyright year.
(struct amd64_register_info): Rename from x86_64_register_info.
(amd64_register_info): Rename from x86_64_register_info.
(AMD64_NUM_REGS): Rename from X86_64_NUM_REGS.
(amd64_register_name): Rename from x86_64_register_name.
(amd64_register_type): Rename from x86_64_register_type.
(amd64_dwarf_regmap): Rename from x86_64_dwarf_regmap.
(amd64_dwarf_regmap_len): Rename from x86_64_dwarf_regmap_len.
(amd64_dwarf_reg_to_regnum): Rename from
x86_64_dwarf_reg_to_regnum.
(amd64_convert_register_p): Rename from x86_64_convert_register_p.
(amd64_push_dummy_call): Rename from x86_64_push_dummy_call.
(AMD64_NUM_SAVED_REGS): Rename from X86_64_NUM_SAVED_REGS.
(struct amd64_frame_cache): Renamed from x86_64_frame_cache.
(amd64_alloc_frame_cache): Renamed from x86_64_alloc_frame_cache.
(amd64_analyze_prologue): Rename from x86_64_analyze_prologue.
(amd64_skip_prologue): Rename from x86_64_skip_prologue.
(amd64_frame_cache): Rename from x86_64_frame_cache.
(amd64_frame_this_id): Rename from x86_64_frame_this_id.
(amd64_frame_prev_register): Rename from
x86_64_frame_prev_register.
(amd64_frame_unwind): Rename from x86_64_frame_unwind.
(amd64_frame_sniffer): Rename from x86_64_frame_sniffer.
(amd64_sigtramp_frame_cache): Rename from
x86_64_sigtramp_frame_cache.
(amd64_sigtramp_frame_prev_register): Rename from
x86_64_sigtramp_frame_prev_register.
(amd64_sigtramp_frame_unwind): Rename from
x86_64_sigtramp_frame_unwind.
(amd64_sigtramp_frame_sniffer): Rename from
x86_64_sigtramp_frame_sniffer.
(amd64_frame_base_address): Rename from x86_64_frame_base_address.
(amd64_frame_base): Rename from x86_64_frame_base.
(amd64_unwind_dummy_id): Rename from x86_64_unwind_dummy_id.
(amd64_frame_align): Rename from x86_64_frame_align.
(amd64_supply_fpregset): Rename from x86_64_supply_fpregset.
(amd64_regset_from_core_section): Rename from
x86_64_regset_from_core_section.
(x86_64_init_abi): Update comments.
@
text
@d80 2
d87 1
a87 1
  /* %st0 is register number 22.  */
d105 1
a105 1
  /* %xmm0 is register number 38.  */
@


1.106
log
@* x86-64-tdep.c (x86_64_dwarf_regmap): Map the Return Address to
RIP.
@
text
@d1 1
a1 1
/* Target-dependent code for the x86-64 for GDB, the GNU debugger.
d3 1
a3 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d43 7
d52 1
a52 1
struct x86_64_register_info
d58 1
a58 1
static struct x86_64_register_info x86_64_register_info[] =
d124 2
a125 2
#define X86_64_NUM_REGS \
  (sizeof (x86_64_register_info) / sizeof (x86_64_register_info[0]))
d130 1
a130 1
x86_64_register_name (int regnum)
d132 2
a133 2
  if (regnum >= 0 && regnum < X86_64_NUM_REGS)
    return x86_64_register_info[regnum].name;
d142 1
a142 1
x86_64_register_type (struct gdbarch *gdbarch, int regnum)
d144 1
a144 1
  gdb_assert (regnum >= 0 && regnum < X86_64_NUM_REGS);
d146 1
a146 1
  return *x86_64_register_info[regnum].type;
d152 1
a152 1
static int x86_64_dwarf_regmap[] =
d189 2
a190 2
static const int x86_64_dwarf_regmap_len =
  (sizeof (x86_64_dwarf_regmap) / sizeof (x86_64_dwarf_regmap[0]));
d196 1
a196 1
x86_64_dwarf_reg_to_regnum (int reg)
d200 2
a201 2
  if (reg >= 0 || reg < x86_64_dwarf_regmap_len)
    regnum = x86_64_dwarf_regmap[reg];
d213 1
a213 1
x86_64_convert_register_p (int regnum, struct type *type)
d602 4
a605 4
x86_64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			struct regcache *regcache, CORE_ADDR bp_addr,
			int nargs, struct value **args,	CORE_ADDR sp,
			int struct_return, CORE_ADDR struct_addr)
d636 1
a636 1
#define X86_64_NUM_SAVED_REGS	X86_64_NUM_GREGS
d638 1
a638 1
struct x86_64_frame_cache
d646 1
a646 1
  CORE_ADDR saved_regs[X86_64_NUM_SAVED_REGS];
d655 2
a656 2
static struct x86_64_frame_cache *
x86_64_alloc_frame_cache (void)
d658 1
a658 1
  struct x86_64_frame_cache *cache;
d661 1
a661 1
  cache = FRAME_OBSTACK_ZALLOC (struct x86_64_frame_cache);
d670 1
a670 1
  for (i = 0; i < X86_64_NUM_SAVED_REGS; i++)
d693 2
a694 2
x86_64_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
			 struct x86_64_frame_cache *cache)
d732 1
a732 1
x86_64_skip_prologue (CORE_ADDR start_pc)
d734 1
a734 1
  struct x86_64_frame_cache cache;
d737 1
a737 1
  pc = x86_64_analyze_prologue (start_pc, 0xffffffffffffffff, &cache);
d747 2
a748 2
static struct x86_64_frame_cache *
x86_64_frame_cache (struct frame_info *next_frame, void **this_cache)
d750 1
a750 1
  struct x86_64_frame_cache *cache;
d757 1
a757 1
  cache = x86_64_alloc_frame_cache ();
d762 1
a762 1
    x86_64_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);
d794 1
a794 1
  for (i = 0; i < X86_64_NUM_SAVED_REGS; i++)
d802 2
a803 2
x86_64_frame_this_id (struct frame_info *next_frame, void **this_cache,
		      struct frame_id *this_id)
d805 2
a806 2
  struct x86_64_frame_cache *cache =
    x86_64_frame_cache (next_frame, this_cache);
d816 4
a819 4
x86_64_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			    int regnum, int *optimizedp,
			    enum lval_type *lvalp, CORE_ADDR *addrp,
			    int *realnump, void *valuep)
d821 2
a822 2
  struct x86_64_frame_cache *cache =
    x86_64_frame_cache (next_frame, this_cache);
d840 1
a840 1
  if (regnum < X86_64_NUM_SAVED_REGS && cache->saved_regs[regnum] != -1)
d859 1
a859 1
static const struct frame_unwind x86_64_frame_unwind =
d862 2
a863 2
  x86_64_frame_this_id,
  x86_64_frame_prev_register
d867 1
a867 1
x86_64_frame_sniffer (struct frame_info *next_frame)
d869 1
a869 1
  return &x86_64_frame_unwind;
d879 2
a880 2
static struct x86_64_frame_cache *
x86_64_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
d882 1
a882 1
  struct x86_64_frame_cache *cache;
d891 1
a891 1
  cache = x86_64_alloc_frame_cache ();
d898 1
a898 1
  gdb_assert (tdep->sc_num_regs <= X86_64_NUM_SAVED_REGS);
d908 2
a909 2
x86_64_sigtramp_frame_this_id (struct frame_info *next_frame,
			       void **this_cache, struct frame_id *this_id)
d911 2
a912 2
  struct x86_64_frame_cache *cache =
    x86_64_sigtramp_frame_cache (next_frame, this_cache);
d918 5
a922 5
x86_64_sigtramp_frame_prev_register (struct frame_info *next_frame,
				     void **this_cache,
				     int regnum, int *optimizedp,
				     enum lval_type *lvalp, CORE_ADDR *addrp,
				     int *realnump, void *valuep)
d925 1
a925 1
  x86_64_sigtramp_frame_cache (next_frame, this_cache);
d927 2
a928 2
  x86_64_frame_prev_register (next_frame, this_cache, regnum,
			      optimizedp, lvalp, addrp, realnump, valuep);
d931 1
a931 1
static const struct frame_unwind x86_64_sigtramp_frame_unwind =
d934 2
a935 2
  x86_64_sigtramp_frame_this_id,
  x86_64_sigtramp_frame_prev_register
d939 1
a939 1
x86_64_sigtramp_frame_sniffer (struct frame_info *next_frame)
d949 1
a949 1
      return &x86_64_sigtramp_frame_unwind;
d957 1
a957 1
x86_64_frame_base_address (struct frame_info *next_frame, void **this_cache)
d959 2
a960 2
  struct x86_64_frame_cache *cache =
    x86_64_frame_cache (next_frame, this_cache);
d965 1
a965 1
static const struct frame_base x86_64_frame_base =
d967 4
a970 4
  &x86_64_frame_unwind,
  x86_64_frame_base_address,
  x86_64_frame_base_address,
  x86_64_frame_base_address
d974 1
a974 1
x86_64_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d988 1
a988 1
x86_64_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
d999 2
a1000 2
x86_64_supply_fpregset (const struct regset *regset, struct regcache *regcache,
			int regnum, const void *fpregs, size_t len)
d1012 2
a1013 2
x86_64_regset_from_core_section (struct gdbarch *gdbarch,
				 const char *sect_name, size_t sect_size)
d1023 1
a1023 1
	  tdep->fpregset->supply_regset = x86_64_supply_fpregset;
d1051 3
a1053 3
  /* In contrast to the i386, on the x86-64 a `long double' actually
     takes up 128 bits, even though it's still based on the i387
     extended floating-point format which has only 80 significant bits.  */
d1056 3
a1058 3
  set_gdbarch_num_regs (gdbarch, X86_64_NUM_REGS);
  set_gdbarch_register_name (gdbarch, x86_64_register_name);
  set_gdbarch_register_type (gdbarch, x86_64_register_type);
d1066 9
a1074 9
  /* The "default" register numbering scheme for the x86-64 is
     referred to as the "DWARF Register Number Mapping" in the System
     V psABI.  The preferred debugging format for all known x86-64
     targets is actually DWARF2, and GCC doesn't seem to support DWARF
     (that is DWARF-1), but we provide the same mapping just in case.
     This mapping is also used for stabs, which GCC does support.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, x86_64_dwarf_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, x86_64_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, x86_64_dwarf_reg_to_regnum);
d1077 1
a1077 1
     be in use on any of the supported x86-64 targets.  */
d1080 2
a1081 2
  set_gdbarch_push_dummy_call (gdbarch, x86_64_push_dummy_call);
  set_gdbarch_frame_align (gdbarch, x86_64_frame_align);
d1084 1
a1084 1
  set_gdbarch_convert_register_p (gdbarch, x86_64_convert_register_p);
d1089 1
a1089 1
  /* Override, since this is handled by x86_64_extract_return_value.  */
d1092 1
a1092 1
  set_gdbarch_skip_prologue (gdbarch, x86_64_skip_prologue);
d1098 1
a1098 1
  set_gdbarch_unwind_dummy_id (gdbarch, x86_64_unwind_dummy_id);
d1101 1
a1101 1
     since all supported x86-64 targets are ELF, but that might change
d1105 3
a1107 3
  frame_unwind_append_sniffer (gdbarch, x86_64_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, x86_64_frame_sniffer);
  frame_base_set_default (gdbarch, &x86_64_frame_base);
d1112 1
a1112 1
					  x86_64_regset_from_core_section);
@


1.105
log
@* x86-64-tdep.c (MAX_CLASSES): Remove macro.
(x86_64_reg_class): Remove enum.
(merge_classes, classify_argument, examine_argument): Remove
functions.
(INT_REGS, SSE_REGS): Remove macros.
(x86_64_push_arguments): Remove function.
(amd64_push_arguments): New function.
(x86_64_push_dummy_call): Call amd64_push_arguments instead of
x86_64_push_arguments.
@
text
@d160 2
a161 2
  /* Return Address RA.  Not mapped.  */
  -1,
@


1.104
log
@* x86-64-tdep.c (x86_64_frame_cache): Don't bail out if %rbp is
zero.  Reorganize code a bit.
@
text
@a211 436
/* The returning of values is done according to the special algorithm.
   Some types are returned in registers an some (big structures) in
   memory.  See the System V psABI for details.  */

#define MAX_CLASSES 4

enum x86_64_reg_class
{
  X86_64_NO_CLASS,
  X86_64_INTEGER_CLASS,
  X86_64_INTEGERSI_CLASS,
  X86_64_SSE_CLASS,
  X86_64_SSESF_CLASS,
  X86_64_SSEDF_CLASS,
  X86_64_SSEUP_CLASS,
  X86_64_X87_CLASS,
  X86_64_X87UP_CLASS,
  X86_64_MEMORY_CLASS
};

/* Return the union class of CLASS1 and CLASS2.
   See the System V psABI for details.  */

static enum x86_64_reg_class
merge_classes (enum x86_64_reg_class class1, enum x86_64_reg_class class2)
{
  /* Rule (a): If both classes are equal, this is the resulting class.  */
  if (class1 == class2)
    return class1;

  /* Rule (b): If one of the classes is NO_CLASS, the resulting class
     is the other class.  */
  if (class1 == X86_64_NO_CLASS)
    return class2;
  if (class2 == X86_64_NO_CLASS)
    return class1;

  /* Rule (c): If one of the classes is MEMORY, the result is MEMORY.  */
  if (class1 == X86_64_MEMORY_CLASS || class2 == X86_64_MEMORY_CLASS)
    return X86_64_MEMORY_CLASS;

  /* Rule (d): If one of the classes is INTEGER, the result is INTEGER.  */
  if ((class1 == X86_64_INTEGERSI_CLASS && class2 == X86_64_SSESF_CLASS)
      || (class2 == X86_64_INTEGERSI_CLASS && class1 == X86_64_SSESF_CLASS))
    return X86_64_INTEGERSI_CLASS;
  if (class1 == X86_64_INTEGER_CLASS || class1 == X86_64_INTEGERSI_CLASS
      || class2 == X86_64_INTEGER_CLASS || class2 == X86_64_INTEGERSI_CLASS)
    return X86_64_INTEGER_CLASS;

  /* Rule (e): If one of the classes is X87 or X87UP class, MEMORY is
     used as class.  */
  if (class1 == X86_64_X87_CLASS || class1 == X86_64_X87UP_CLASS
      || class2 == X86_64_X87_CLASS || class2 == X86_64_X87UP_CLASS)
    return X86_64_MEMORY_CLASS;

  /* Rule (f): Otherwise class SSE is used.  */
  return X86_64_SSE_CLASS;
}

/* Classify the argument type.  CLASSES will be filled by the register
   class used to pass each word of the operand.  The number of words
   is returned.  In case the parameter should be passed in memory, 0
   is returned.  As a special case for zero sized containers,
   classes[0] will be NO_CLASS and 1 is returned.

   See the System V psABI for details.  */

static int
classify_argument (struct type *type,
		   enum x86_64_reg_class classes[MAX_CLASSES], int bit_offset)
{
  int bytes = TYPE_LENGTH (type);
  int words = (bytes + 8 - 1) / 8;

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_ARRAY:
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      {
	int i;
	enum x86_64_reg_class subclasses[MAX_CLASSES];

	/* On x86-64 we pass structures larger than 16 bytes on the stack.  */
	if (bytes > 16)
	  return 0;

	for (i = 0; i < words; i++)
	  classes[i] = X86_64_NO_CLASS;

	/* Zero sized arrays or structures are NO_CLASS.  We return 0
	   to signalize memory class, so handle it as special case.  */
	if (!words)
	  {
	    classes[0] = X86_64_NO_CLASS;
	    return 1;
	  }
	switch (TYPE_CODE (type))
	  {
	  case TYPE_CODE_STRUCT:
	    {
	      int j;
	      for (j = 0; j < TYPE_NFIELDS (type); ++j)
		{
		  int num = classify_argument (TYPE_FIELDS (type)[j].type,
					       subclasses,
					       (TYPE_FIELDS (type)[j].loc.
						bitpos + bit_offset) % 256);
		  if (!num)
		    return 0;
		  for (i = 0; i < num; i++)
		    {
		      int pos =
			(TYPE_FIELDS (type)[j].loc.bitpos +
			 bit_offset) / 8 / 8;
		      classes[i + pos] =
			merge_classes (subclasses[i], classes[i + pos]);
		    }
		}
	    }
	    break;
	  case TYPE_CODE_ARRAY:
	    {
	      int num;

	      num = classify_argument (TYPE_TARGET_TYPE (type),
				       subclasses, bit_offset);
	      if (!num)
		return 0;

	      /* The partial classes are now full classes.  */
	      if (subclasses[0] == X86_64_SSESF_CLASS && bytes != 4)
		subclasses[0] = X86_64_SSE_CLASS;
	      if (subclasses[0] == X86_64_INTEGERSI_CLASS && bytes != 4)
		subclasses[0] = X86_64_INTEGER_CLASS;

	      for (i = 0; i < words; i++)
		classes[i] = subclasses[i % num];
	    }
	    break;
	  case TYPE_CODE_UNION:
	    {
	      int j;
	      {
		for (j = 0; j < TYPE_NFIELDS (type); ++j)
		  {
		    int num;
		    num = classify_argument (TYPE_FIELDS (type)[j].type,
					     subclasses, bit_offset);
		    if (!num)
		      return 0;
		    for (i = 0; i < num; i++)
		      classes[i] = merge_classes (subclasses[i], classes[i]);
		  }
	      }
	    }
	    break;
	  default:
	    break;
	  }
	/* Final merger cleanup.  */
	for (i = 0; i < words; i++)
	  {
	    /* If one class is MEMORY, everything should be passed in
	       memory.  */
	    if (classes[i] == X86_64_MEMORY_CLASS)
	      return 0;

	    /* The X86_64_SSEUP_CLASS should be always preceeded by
	       X86_64_SSE_CLASS.  */
	    if (classes[i] == X86_64_SSEUP_CLASS
		&& (i == 0 || classes[i - 1] != X86_64_SSE_CLASS))
	      classes[i] = X86_64_SSE_CLASS;

	    /* X86_64_X87UP_CLASS should be preceeded by X86_64_X87_CLASS.  */
	    if (classes[i] == X86_64_X87UP_CLASS
		&& (i == 0 || classes[i - 1] != X86_64_X87_CLASS))
	      classes[i] = X86_64_SSE_CLASS;
	  }
	return words;
      }
      break;
    case TYPE_CODE_FLT:
      switch (bytes)
	{
	case 4:
	  if (!(bit_offset % 64))
	    classes[0] = X86_64_SSESF_CLASS;
	  else
	    classes[0] = X86_64_SSE_CLASS;
	  return 1;
	case 8:
	  classes[0] = X86_64_SSEDF_CLASS;
	  return 1;
	case 16:
	  classes[0] = X86_64_X87_CLASS;
	  classes[1] = X86_64_X87UP_CLASS;
	  return 2;
	}
      break;
    case TYPE_CODE_ENUM:
    case TYPE_CODE_REF:
    case TYPE_CODE_INT:
    case TYPE_CODE_PTR:
      switch (bytes)
	{
	case 1:
	case 2:
	case 4:
	case 8:
	  if (bytes * 8 + bit_offset <= 32)
	    classes[0] = X86_64_INTEGERSI_CLASS;
	  else
	    classes[0] = X86_64_INTEGER_CLASS;
	  return 1;
	case 16:
	  classes[0] = classes[1] = X86_64_INTEGER_CLASS;
	  return 2;
	default:
	  break;
	}
    case TYPE_CODE_VOID:
      return 0;
    default:			/* Avoid warning.  */
      break;
    }
  internal_error (__FILE__, __LINE__,
		  "classify_argument: unknown argument type");
}

/* Examine the argument and set *INT_NREGS and *SSE_NREGS to the
   number of registers required based on the information passed in
   CLASSES.  Return 0 if parameter should be passed in memory.  */

static int
examine_argument (enum x86_64_reg_class classes[MAX_CLASSES],
		  int n, int *int_nregs, int *sse_nregs)
{
  *int_nregs = 0;
  *sse_nregs = 0;
  if (!n)
    return 0;
  for (n--; n >= 0; n--)
    switch (classes[n])
      {
      case X86_64_INTEGER_CLASS:
      case X86_64_INTEGERSI_CLASS:
	(*int_nregs)++;
	break;
      case X86_64_SSE_CLASS:
      case X86_64_SSESF_CLASS:
      case X86_64_SSEDF_CLASS:
	(*sse_nregs)++;
	break;
      case X86_64_NO_CLASS:
      case X86_64_SSEUP_CLASS:
      case X86_64_X87_CLASS:
      case X86_64_X87UP_CLASS:
	break;
      case X86_64_MEMORY_CLASS:
	internal_error (__FILE__, __LINE__,
			"examine_argument: unexpected memory class");
      }
  return 1;
}

#define INT_REGS 6
#define SSE_REGS 8

static CORE_ADDR
x86_64_push_arguments (struct regcache *regcache, int nargs,
		       struct value **args, CORE_ADDR sp)
{
  int intreg = 0;
  int ssereg = 0;
  /* For varargs functions we have to pass the total number of SSE
     registers used in %rax.  So, let's count this number.  */
  int total_sse_args = 0;
  /* Once an SSE/int argument is passed on the stack, all subsequent
     arguments are passed there.  */
  int sse_stack = 0;
  int int_stack = 0;
  unsigned total_sp;
  int i;
  char buf[8];
  static int int_parameter_registers[INT_REGS] =
  {
    X86_64_RDI_REGNUM, 4,	/* %rdi, %rsi */
    X86_64_RDX_REGNUM, 2,	/* %rdx, %rcx */
    8, 9			/* %r8, %r9 */
  };
  /* %xmm0 - %xmm7 */
  static int sse_parameter_registers[SSE_REGS] =
  {
    X86_64_XMM0_REGNUM + 0, X86_64_XMM1_REGNUM,
    X86_64_XMM0_REGNUM + 2, X86_64_XMM0_REGNUM + 3,
    X86_64_XMM0_REGNUM + 4, X86_64_XMM0_REGNUM + 5,
    X86_64_XMM0_REGNUM + 6, X86_64_XMM0_REGNUM + 7,
  };
  int stack_values_count = 0;
  int *stack_values;
  stack_values = alloca (nargs * sizeof (int));

  for (i = 0; i < nargs; i++)
    {
      enum x86_64_reg_class class[MAX_CLASSES];
      int n = classify_argument (args[i]->type, class, 0);
      int needed_intregs;
      int needed_sseregs;

      if (!n ||
	  !examine_argument (class, n, &needed_intregs, &needed_sseregs))
	{			/* memory class */
	  stack_values[stack_values_count++] = i;
	}
      else
	{
	  int j;
	  int offset = 0;

	  if (intreg / 2 + needed_intregs > INT_REGS)
	    int_stack = 1;
	  if (ssereg / 2 + needed_sseregs > SSE_REGS)
	    sse_stack = 1;
	  if (!sse_stack)
	    total_sse_args += needed_sseregs;

	  for (j = 0; j < n; j++)
	    {
	      switch (class[j])
		{
		case X86_64_NO_CLASS:
		  break;
		case X86_64_INTEGER_CLASS:
		  if (int_stack)
		    stack_values[stack_values_count++] = i;
		  else
		    {
		      regcache_cooked_write
			(regcache, int_parameter_registers[(intreg + 1) / 2],
			 VALUE_CONTENTS_ALL (args[i]) + offset);
		      offset += 8;
		      intreg += 2;
		    }
		  break;
		case X86_64_INTEGERSI_CLASS:
		  if (int_stack)
		    stack_values[stack_values_count++] = i;
		  else
		    {
		      LONGEST val = extract_signed_integer
			(VALUE_CONTENTS_ALL (args[i]) + offset, 4);
		      regcache_cooked_write_signed
			(regcache, int_parameter_registers[intreg / 2], val);
		      
		      offset += 8;
		      intreg++;
		    }
		  break;
		case X86_64_SSEDF_CLASS:
		case X86_64_SSESF_CLASS:
		case X86_64_SSE_CLASS:
		  if (sse_stack)
		    stack_values[stack_values_count++] = i;
		  else
		    {
		      regcache_cooked_write
			(regcache, sse_parameter_registers[(ssereg + 1) / 2],
			 VALUE_CONTENTS_ALL (args[i]) + offset);
		      offset += 8;
		      ssereg += 2;
		    }
		  break;
		case X86_64_SSEUP_CLASS:
		  if (sse_stack)
		    stack_values[stack_values_count++] = i;
		  else
		    {
		      regcache_cooked_write
			(regcache, sse_parameter_registers[ssereg / 2],
			 VALUE_CONTENTS_ALL (args[i]) + offset);
		      offset += 8;
		      ssereg++;
		    }
		  break;
		case X86_64_X87_CLASS:
		case X86_64_MEMORY_CLASS:
		  stack_values[stack_values_count++] = i;
		  break;
		case X86_64_X87UP_CLASS:
		  break;
		default:
		  internal_error (__FILE__, __LINE__,
				  "Unexpected argument class");
		}
	      intreg += intreg % 2;
	      ssereg += ssereg % 2;
	    }
	}
    }

  /* We have to make sure that the stack is 16-byte aligned after the
     setup.  Let's calculate size of arguments first, align stack and
     then fill in the arguments.  */
  total_sp = 0;
  for (i = 0; i < stack_values_count; i++)
    {
      struct value *arg = args[stack_values[i]];
      int len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (arg));
      total_sp += (len + 7) & ~7;
    }
  /* total_sp is now a multiple of 8, if it is not a multiple of 16,
     change the stack pointer so that it will be afterwards correctly
     aligned.  */
  if (total_sp & 15)
    sp -= 8;
    
  /* Push any remaining arguments onto the stack.  */
  while (--stack_values_count >= 0)
    {
      struct value *arg = args[stack_values[stack_values_count]];
      int len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (arg));

      /* Make sure the stack is 8-byte-aligned.  */
      sp -= (len + 7) & ~7;
      write_memory (sp, VALUE_CONTENTS_ALL (arg), len);
    }

  /* Write number of SSE type arguments to RAX to take care of varargs
     functions.  */
  store_unsigned_integer (buf, 8, total_sse_args);
  regcache_cooked_write (regcache, X86_64_RAX_REGNUM, buf);

  return sp;
}

d470 125
d603 1
a603 1
  sp = x86_64_push_arguments (regcache, nargs, args, sp);
@


1.103
log
@* x86-64-tdep.c (RET_INT_REGS, RET_SSE_REGS): Remove defines.
(x86_64_use_struct_convention, x86_64_extract_return_value,
x86_64_store_return_value): Remove.
(amd64_reg_class): New enum.
(amd64_merge_classes, amd64_classify_aggregate, amd64_classify,
amd64_return_value): New functions.
(x86_64_init_abi): Don't set extract_return_value,
store_return_value and use_struct_convention.  Set return_value to
amd64_return_value.
* i387-tdep.h (i387_return_value): New prototype.
* i387-tdep.c (i387_return_value): New function.
@
text
@a1063 8
  frame_unwind_register (next_frame, X86_64_RBP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 8);
  if (cache->base == 0)
    return cache;

  /* For normal frames, %rip is stored at 8(%rbp).  */
  cache->saved_regs[X86_64_RIP_REGNUM] = 8;

d1081 5
d1090 5
@


1.102
log
@* i386-tdep.c (i386_extract_return_value,
i386_store_return_value): Add gdbarch argument.  Use it instead of
determining it from REGCACHE.  Remove recursive call for
structures with a single member.
(i386_use_struct_convention): Remove.
(i386_reg_struct_return_p): New function.
(i386_return_value): New function.
(i386_gdbarch_init): Set return_value, don't set
extract_return_value, store_return_value and
use_struct_convention.
* x86-64-tdep.c (x86_64_init_abi): Set return_value to NULL.
@
text
@a477 103
#define RET_INT_REGS 2
#define RET_SSE_REGS 2

/* Check if the structure in value_type is returned in registers or in
   memory. If this function returns 1, GDB will call
   STORE_STRUCT_RETURN and EXTRACT_STRUCT_VALUE_ADDRESS else
   STORE_RETURN_VALUE and EXTRACT_RETURN_VALUE will be used.  */

static int
x86_64_use_struct_convention (int gcc_p, struct type *value_type)
{
  enum x86_64_reg_class class[MAX_CLASSES];
  int n = classify_argument (value_type, class, 0);
  int needed_intregs;
  int needed_sseregs;

  return (!n ||
	  !examine_argument (class, n, &needed_intregs, &needed_sseregs) ||
	  needed_intregs > RET_INT_REGS || needed_sseregs > RET_SSE_REGS);
}

/* Extract from an array REGBUF containing the (raw) register state, a
   function return value of TYPE, and copy that, in virtual format,
   into VALBUF.  */

static void
x86_64_extract_return_value (struct type *type, struct regcache *regcache,
			     void *valbuf)
{
  enum x86_64_reg_class class[MAX_CLASSES];
  int n = classify_argument (type, class, 0);
  int needed_intregs;
  int needed_sseregs;
  int intreg = 0;
  int ssereg = 0;
  int offset = 0;
  int ret_int_r[RET_INT_REGS] = { X86_64_RAX_REGNUM, X86_64_RDX_REGNUM };
  int ret_sse_r[RET_SSE_REGS] = { X86_64_XMM0_REGNUM, X86_64_XMM1_REGNUM };

  if (!n ||
      !examine_argument (class, n, &needed_intregs, &needed_sseregs) ||
      needed_intregs > RET_INT_REGS || needed_sseregs > RET_SSE_REGS)
    {				/* memory class */
      CORE_ADDR addr;
      regcache_cooked_read (regcache, X86_64_RAX_REGNUM, &addr);
      read_memory (addr, valbuf, TYPE_LENGTH (type));
      return;
    }
  else
    {
      int i;
      for (i = 0; i < n; i++)
	{
	  switch (class[i])
	    {
	    case X86_64_NO_CLASS:
	      break;
	    case X86_64_INTEGER_CLASS:
	      regcache_cooked_read (regcache, ret_int_r[(intreg + 1) / 2],
				    (char *) valbuf + offset);
	      offset += 8;
	      intreg += 2;
	      break;
	    case X86_64_INTEGERSI_CLASS:
	      regcache_cooked_read_part (regcache, ret_int_r[intreg / 2],
					 0, 4, (char *) valbuf + offset);
	      offset += 8;
	      intreg++;
	      break;
	    case X86_64_SSEDF_CLASS:
	    case X86_64_SSESF_CLASS:
	    case X86_64_SSE_CLASS:
	      regcache_cooked_read_part (regcache,
					 ret_sse_r[(ssereg + 1) / 2], 0, 8,
					 (char *) valbuf + offset);
	      offset += 8;
	      ssereg += 2;
	      break;
	    case X86_64_SSEUP_CLASS:
	      regcache_cooked_read_part (regcache, ret_sse_r[ssereg / 2],
					 0, 8, (char *) valbuf + offset);
	      offset += 8;
	      ssereg++;
	      break;
	    case X86_64_X87_CLASS:
	      regcache_cooked_read_part (regcache, X86_64_ST0_REGNUM,
					 0, 8, (char *) valbuf + offset);
	      offset += 8;
	      break;
	    case X86_64_X87UP_CLASS:
	      regcache_cooked_read_part (regcache, X86_64_ST0_REGNUM,
					 8, 2, (char *) valbuf + offset);
	      offset += 8;
	      break;
	    case X86_64_MEMORY_CLASS:
	    default:
	      internal_error (__FILE__, __LINE__,
			      "Unexpected argument class");
	    }
	}
    }
}

d648 54
a701 2
/* Write into the appropriate registers a function return value stored
   in VALBUF of type TYPE, given in virtual format.  */
d704 1
a704 2
x86_64_store_return_value (struct type *type, struct regcache *regcache,
			   const void *valbuf)
d708 4
a711 2
  /* First handle long doubles.  */
  if (TYPE_CODE_FLT == TYPE_CODE (type) && len == 16)
d713 6
a718 2
      ULONGEST fstat;
      char buf[I386_MAX_REGISTER_SIZE];
d720 13
a732 29
      /* Returning floating-point values is a bit tricky.  Apart from
         storing the return value in %st(0), we have to simulate the
         state of the FPU at function return point.  */

      /* Convert the value found in VALBUF to the extended
	 floating-point format used by the FPU.  This is probably
	 not exactly how it would happen on the target itself, but
	 it is the best we can do.  */
      convert_typed_floating (valbuf, type, buf, builtin_type_i387_ext);
      regcache_raw_write (regcache, X86_64_ST0_REGNUM, buf);

      /* Set the top of the floating-point register stack to 7.  The
         actual value doesn't really matter, but 7 is what a normal
         function return would end up with if the program started out
         with a freshly initialized FPU.  */
      regcache_raw_read_unsigned (regcache, FSTAT_REGNUM, &fstat);
      fstat |= (7 << 11);
      regcache_raw_write_unsigned (regcache, FSTAT_REGNUM, fstat);

      /* Mark %st(1) through %st(7) as empty.  Since we set the top of
         the floating-point register stack to 7, the appropriate value
         for the tag word is 0x3fff.  */
      regcache_raw_write_unsigned (regcache, FTAG_REGNUM, 0x3fff);
    }
  else if (TYPE_CODE_FLT == TYPE_CODE (type))
    {
      /* Handle double and float variables.  */
      regcache_cooked_write_part (regcache, X86_64_XMM0_REGNUM,
				  0, len, valbuf);
a733 1
  /* XXX: What about complex floating point types?  */
d736 5
a740 2
      int low_size = register_size (current_gdbarch, X86_64_RAX_REGNUM);
      int high_size = register_size (current_gdbarch, X86_64_RDX_REGNUM);
d742 1
a742 3
      if (len <= low_size)
        regcache_cooked_write_part (regcache, 0, 0, len, valbuf);
      else if (len <= (low_size + high_size))
d744 10
a753 4
 	  regcache_cooked_write_part (regcache, 0, 0, low_size, valbuf);
 	  regcache_cooked_write_part (regcache, 1, 0,
 				      len - low_size,
 				      (const char *) valbuf + low_size);
a754 3
      else
	internal_error (__FILE__, __LINE__,
			"Cannot store return value of %d bytes long.", len);
d756 146
d1390 1
a1390 3
  set_gdbarch_return_value (gdbarch, NULL);
  set_gdbarch_extract_return_value (gdbarch, x86_64_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, x86_64_store_return_value);
a1392 1
  set_gdbarch_use_struct_convention (gdbarch, x86_64_use_struct_convention);
@


1.101
log
@* i386-tdep.h (FPU_REG_RAW_SIZE): Remove define.
* x86-64-tdep.c (x86_64_store_return_value): Use
I386_MAX_REGISTER_SIZE instead of FPU_REG_RAW_SIZE.
@
text
@d1303 1
@


1.100
log
@* x86-64-tdep.c (x86_64_regset_from_core_section): New function.
(x86_64_init_abi): Initialize regset_from_core_section if
appropriate.
@
text
@d764 1
a764 1
      char buf[FPU_REG_RAW_SIZE];
@


1.99
log
@* x86-64-tdep.c: Remove duplicate comment.
@
text
@d1223 25
d1325 5
@


1.98
log
@* x86-64-tdep.c (x86_64_store_return_value): Don't use
DEPRECATED_REGISTER_RAW_SIZE.  Use symbolic names for register
names for return values.  This fixes a bug since we looked at %rbx
instead of %rdx.
@
text
@a1311 7
/* The 64-bit FXSAVE format differs from the 32-bit format in the
   sense that the instruction pointer and data pointer are simply
   64-bit offsets into the code segment and the data segment instead
   of a selector offset pair.  The functions below store the upper 32
   bits of these pointers (instead of just the 16-bits of the segment
   selector).  */

@


1.97
log
@* x86-64-tdep.c: Include "regset.h".
@
text
@d799 2
a800 2
      int low_size = DEPRECATED_REGISTER_RAW_SIZE (0);
      int high_size = DEPRECATED_REGISTER_RAW_SIZE (1);
@


1.96
log
@* i386-tdep.h (struct gdbarch_tdep): Add members gregset,
gregset_reg_offset, gregset_num_regs, sizeof_gregset, fpregset,
sizeof_fpregset.
* i386-tdep.c: Include "regset.h".
(i386_supply_gregset): New function.
(i386_supply_fpregset): New function.
(i386_gdbarch_init): Initialze register set-related members of
TDEP.
* x86-64-tdep.c (x86_64_supply_fpregset): New function.
(x86_64_init_abi): Initialize TDEP->sizeof_fpregset.
@
text
@d35 1
@


1.95
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d1206 15
d1226 4
@


1.94
log
@* i387-tdep.c (i387_supply_fsave, i387_supply_fxsave): Add
regcache argument and reverse the order of the other two
arguments.  Remove local regcache variable.  Determine
architecture from REGCACHE.  Update comments.
* x86-64-tdep.c (x86_64_supply_fxsave): Add regcache argument and
reverse the order of the other two arguments.  Remove local
regcache variable.  Determine architecture from REGCACHE.  Update
comments.
* i387-tdep.h (i387_supply_fsave, i387_supply_fxsave): Adjust
prototypes.  Update comments.
* x86-64-tdep.c (x86_64_supply_fxsave): Adjust prototype.  Adjust
comment.
* amd64fbsd-nat.c (supply_fpregset, fetch_inferior_registers):
Update.
* go32-nat.c (fetch_register, go32_fetch_registers): Update.
* i386-interix-nat.c (supply_fpregset): Update.
* i386-linux-nat.c (supply_fpregset, supply_fpxregset): Update.
* i386-nto-tdep.c (i386nto_supply_fpregset): Update.
* i386gnu-nat.c (fetch_fpregs, supply_fpregset): Update.
* i386bsd-nat.c (supply_fpregset, fetch_inferior_registers): Update.
* i386nbsd-tdep.c (fetch_core_registers, fetch_elfcore_registers):
Update.
* i386obsd-tdep.c (fetch_core_registers): Update.
* i386v4-nat.c (supply_fpregset): Update.
* x86-64-linux-nat.c (supply_fpregset): Update.
* x86-64-linux-tdep.c (fetch_core_registers): Update.
@
text
@d798 2
a799 2
      int low_size = REGISTER_RAW_SIZE (0);
      int high_size = REGISTER_RAW_SIZE (1);
@


1.93
log
@* i386-tdep.h: Put opaque declarations in alphabetical
order.  Remove spurious whitespace.
(struct gdbarch_tdep): add st0_regnum and mm0_regnum members.
(i386_sse_regnum_p, i386_mxcsr_regnum_p): Remove prototypes.
* i386-tdep.c (MM0_REGNUM): Remove define.
(i386_mmx_regnum_p): Add gdbarch argument.
(i386_sse_regnum_p, i386_mxcsr_regnum_p): Add gdbarch argument.
Rewrite using new macro definitions for FPU/SSE registers.
(i386_fp_regnum_p, i386_fpc_regnum_p): Rewrite using new macro
definitions from i387-tdep.h.
(i386_register_name): Update.
(i386_stab_reg_to_regnum, i386_dwarf_reg_to_regnum): Update to use
new macro definitions for FPU/SSE registers.
(i386_extract_return_value): Determine whether floating-point
registers are present by examining REGCACHE's architecture.
(i386_store_return_value): Likewise.  Use I386_MAX_REGISTER_SIZE
instead of FPU_REG_RAW_SIZE.  Use new macro definitions for
FPU/SSE registers.
(i386_register_type): Update.
(i386_mmx_regnum_to_fp_regnum): Rewrite using new macro
definitions for FPU registers.  Use REGCACHE's architecture to
determine the appropriate register numbers.
(i386_pseudo_register_read, i386_pseudo_register_write,
i386_register_reggroup_p): Update.
(i386_gdbarch_init): Initialize TDEP->st0_regnum and
TDEP->mm0_regnum.
* i387-tdep.h (I387_FCTRL_REGNUM, I387_FSTAT_REGNUM,
I387_FTAG_REGNUM, I387_FISEG_REGNUM, I387_FIOFF_REGNUM,
I387_FOSEG_REGNUM, I387_FOOFF_REGNUM, I387_FOP_REGNUM,
I387_XMM0_REGNUM, I387_MXCSR_REGNUM): New defines.
(i387_supply_fsave, i387_fill_fsave, i387_supply_fxsave,
i387_fill_fxsave): Change type of fsave/fxsave argument from `char
*' to `void *'.
* i387-tdep.c (i387_print_float_info, fsave_offset, FSAVE_ADDR,
i387_supply_fsave, i387_fill_fsave, fxsave_offset, FXSAVE_ADDR,
i387_supply_fxsave, i387_fill_fxsave): Update to use new macro
definitions for FPU/SSE registers.
(FXSAVE_MXCSR_ADDR): New define.
* x86-64-tdep.c (x86_64_init_abi): Override TDEP->st0_regnum and
TDEP->mm0_regnum.
(I387_FISEG_REGNUM, I387_FOSEG_REGNUM): Remove defines.
(I387_ST0_REGNUM): Define.
@
text
@d1292 8
a1299 1
/* Fill register REGNUM in GDB's register cache with the appropriate
d1305 2
a1306 1
x86_64_supply_fxsave (const char *fxsave, int regnum)
d1308 1
a1308 1
  i387_supply_fxsave (fxsave, regnum);
d1312 2
d1315 1
a1315 1
	supply_register (I387_FISEG_REGNUM, fxsave + 12);
d1317 1
a1317 1
      supply_register (I387_FOSEG_REGNUM, fxsave + 20);
@


1.92
log
@* x86-64-tdep.c (x86_64_store_return_value): Remove spurious
whitespace.
@
text
@d1212 2
a1213 1
  /* The x86-64 has 16 SSE registers.  */
d1268 1
d1283 1
a1283 2
#define I387_FISEG_REGNUM FISEG_REGNUM
#define I387_FOSEG_REGNUM FOSEG_REGNUM
@


1.91
log
@* x86-64-tdep.c (x86_64_supply_fxsave): Add `regnum' argument.
Update comments.
* x86-64-tdep.h (x86_64_supply_fxsave): Adjust prototype.  Update
comments.
* x86-64-linux-tdep.c (fetch_core_registers): Adjust call to
x86_64_supply_fxsave.
* x86-64-linux-nat.c (supply_fpregset): Adjust call to
x86_64_supply_fxsave.
* amd64fbsd-nat.c (supply_fpregset): Adjust call to
x86_64_supply_fxsave.
@
text
@d760 1
a760 1
  if (TYPE_CODE_FLT == TYPE_CODE (type)  && len == 16)
@


1.90
log
@2003-08-23  Andreas Jaeger  <aj@@suse.de>

        * x86-64-tdep.c (x86_64_supply_fxsave): Adjust call to
        i387_supply_fxsave.
@
text
@d1291 4
a1294 3
/* Fill GDB's register array with the floating-point and SSE register
   values in *FXSAVE.  This function masks off any of the reserved
   bits in *FXSAVE.  */
d1297 1
a1297 1
x86_64_supply_fxsave (char *fxsave)
d1299 1
a1299 1
  i387_supply_fxsave (fxsave, -1);
d1303 3
a1305 1
      supply_register (I387_FISEG_REGNUM, fxsave + 12);
d1311 1
a1311 1
   *FXSAVE with the value in GDB's register array.  If REGNUM is -1, do
@


1.89
log
@Index: ChangeLog
2003-08-18  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_RED_ZONE_SIZE): New architecture method.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Adjust the SP by
	frame_red_zone_size before allocating any stack space.
	* rs6000-tdep.c (rs6000_gdbarch_init): Set "frame_red_zone_size".
	* x86-64-tdep.c (x86_64_frame_align): New function.
	(x86_64_init_abi): Set "frame_red_zone_size" and "frame_align".

	* x86-64-tdep.c (x86_64_push_arguments): Revert 2003-08-07 change.
	Remove code adjusting SP so that it skips over the Red Zone.

Index: doc/ChangeLog
2003-08-18  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Document
	"frame_red_zone_size".
@
text
@d1298 1
a1298 1
  i387_supply_fxsave (fxsave);
@


1.88
log
@* x86-64-tdep.c (x86_64_dwarf_regmap): Remove trailing whitespace.
@
text
@a616 7
  /* Before storing anything to the stack we must skip
     the "Red zone" (see the "Function calling sequence" section
     of AMD64 ABI).
     It could have already been skipped in the function's
     prologue, but we don't care and will easily skip it once again.  */
  sp -= 128;

d1199 8
d1250 2
@


1.87
log
@2003-08-07  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-tdep.c (x86_64_push_arguments): Skip the red zone.
@
text
@d147 1
a147 1
  X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, 2, 1, 
d175 1
a175 1
  X86_64_ST0_REGNUM + 0, X86_64_ST0_REGNUM + 1,	
@


1.86
log
@2003-08-07  Michal Ludvig  <mludvig@@suse.cz>
	* x86-64-tdep.c (x86_64_dwarf_regmap): Correct register numbers.
@
text
@d616 8
@


1.85
log
@2003-07-16  Andrew Cagney  <cagney@@redhat.com>

	* frame-base.h (frame_base_p_ftype): Delete definition.
	(frame_base_append_predicate): Delete declaration.
	* frame-unwind.h (frame_unwind_p_ftype): Delete definition.
	(frame_unwind_append_predicate): Delete declaration.
	* frame-unwind.c (struct frame_unwind_table): Delete field "p".
	(append_predicate): Delete parameter "p".
	(frame_unwind_append_predicate): Delete function.
	(frame_unwind_append_sniffer): Update call to append_predicate.
	(frame_unwind_free): Delete function.
	(_initialize_frame_unwind): Pass NULL as "free" to
	register_gdbarch_data.
	(frame_unwind_init): Append the dummy_frame_sniffer.
	(frame_unwind_find_by_frame): Simplify.
	* frame-base.c (struct frame_base_table): Delete field "p".
	(append_predicate): Delete parameter "p".
	(frame_base_append_predicate): Delete function.
	(frame_base_append_sniffer): Update call to append_predicate.
	(frame_base_free): Delete function.
	(frame_base_find_by_frame): Simplify.
	(_initialize_frame_base): Pass NULL as "free" to
	register_gdbarch_data.
	* x86-64-tdep.c (x86_64_frame_sniffer): Replace "x86_64_frame_p".
	(x86_64_sigtramp_frame_sniffer): Replace
	"x86_64_sigtramp_frame_p".
	(x86_64_init_abi): Set the frame unwind sniffers.
	* m68k-tdep.c (m68k_frame_sniffer): Replace "m68k_frame_p".
	(m68k_sigtramp_frame_sniffer): Replace "m68k_sigtramp_frame_p"
	(m68k_gdbarch_init): Set the frame unwind sniffers.
	* i386-tdep.c (i386_sigtramp_frame_sniffer): Replace
	"i386_sigtramp_frame_p".
	(i386_frame_sniffer): Replace "i386_frame_p".
	(i386_gdbarch_init): Set the frame unwind sniffers.
	* avr-tdep.c (avr_frame_sniffer): Replace "avr_frame_sniffer".
	(avr_gdbarch_init): Set the frame unwind sniffers.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Replace
	"alpha_sigtramp_frame_p"
	(alpha_heuristic_frame_sniffer): Replace
	"alpha_heuristic_frame_p".
	(alpha_gdbarch_init): Set the frame unwind sniffers.
	(alpha_dwarf2_init_abi): Ditto.
	* alpha-mdebug-tdep.c (alpha_mdebug_frame_sniffer): Replace
	"alpha_debug_frame_p".
	(alpha_mdebug_frame_base_sniffer): Replace
	"alpha_mdebug_frame_base_p".
	(alpha_mdebug_init_abi): Set the frame unwind sniffers.
	* d10v-tdep.c (d10v_frame_sniffer): Replace "d10v_frame_p".
	(d10v_gdbarch_init): Set the frame unwind sniffer.
	* dwarf2-frame.c (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	(dwarf2_frame_base_sniffer): Replace "dwarf2_frame_base_p".
	* dwarf2-frame.h (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	(dwarf2_frame_base_sniffer): Replace "dwarf2_frame_base_p".
	* dummy-frame.c (dummy_frame_sniffer): Replace "dummy_frame_p".
	* dummy-frame.h (dummy_frame_sniffer): Replace "dummy_frame_p".
@
text
@d147 1
a147 1
  X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, 3, 2, 
@


1.84
log
@*** empty log message ***
@
text
@d1080 1
a1080 1
x86_64_frame_p (CORE_ADDR pc)
d1152 1
a1152 1
x86_64_sigtramp_frame_p (CORE_ADDR pc)
d1154 1
d1264 2
a1265 2
  frame_unwind_append_predicate (gdbarch, x86_64_sigtramp_frame_p);
  frame_unwind_append_predicate (gdbarch, x86_64_frame_p);
@


1.83
log
@* x86-64-tdep.c (x86_64_store_return_value): Use an intermediate
buffer when storing double and float varibles into %xmm0.
@
text
@d791 2
a792 1
      regcache_cooked_write_part (regcache, X86_64_XMM0_REGNUM, 0, len, buf);
@


1.82
log
@* x86-64-tdep.h (X86_64_RAX_REGNUM, X86_64_RDX_REGNUM,
X86_64_RDI_REGNUM, X86_64_RBP_REGNUM, X86_64_RSP_REGNUM,
X86_64_RIP_REGNUM, X86_64_EFLAGS_REGNUM, X86_64_ST0_REGNUM,
X86_64_XMM0_REGNUM, X86_64_XMM1_REGNUM): Moved here ...
* x86-64-tdep.c: ... from here.
@
text
@d791 1
a791 1
      regcache_cooked_write (regcache,  X86_64_XMM0_REGNUM, valbuf);
@


1.81
log
@	* x86-64-tdep.c (x86_64_push_arguments): Align stack to 16-byte
	before the call.
	Set %rax only to number of SSE registers used.
@
text
@d42 1
a42 12
/* Register numbers of various important registers.  */

#define X86_64_RAX_REGNUM	0 /* %rax */
#define X86_64_RDX_REGNUM	3 /* %rdx */
#define X86_64_RDI_REGNUM	5 /* %rdi */
#define X86_64_RBP_REGNUM	6 /* %rbp */
#define X86_64_RSP_REGNUM	7 /* %rsp */
#define X86_64_RIP_REGNUM	16 /* %rip */
#define X86_64_EFLAGS_REGNUM	17 /* %eflags */
#define X86_64_ST0_REGNUM	22 /* %st0 */
#define X86_64_XMM0_REGNUM	38 /* %xmm0 */
#define X86_64_XMM1_REGNUM	39 /* %xmm1 */
@


1.80
log
@
	* x86-64-tdep.c (x86_64_push_arguments): Always set %rax to number
	of SSE registers so that varargs functions work.  Rework handling
	of passing arguments on the stack.
	(x86_64_store_return_value): Return double and float values in SSE
	register.
@
text
@d600 2
a601 2
  /* For varargs functions we have to pass the total number of SSE arguments
     in %rax.  So, let's count this number.  */
d607 1
d648 2
a649 1
	  total_sse_args += needed_sseregs;
d725 16
d747 1
a747 1
      /* Make sure the stack stays eightbyte-aligned.  */
@


1.79
log
@* i386-tdep.c (i386_register_to_value, i386_value_to_register):
Move floating-point code to new function in i387-tdep.c.
* i387-tdep.c (i387_register_to_value, i387_value_to_register):
New functions containing code moved here from i386-tdep.c.
* i387-tdep.h: Add opaque declaration for `struct type'.
(i387_register_to_value, i387_value_to_register): New prototypes.
* x86-64-tdep.c (x86_64_convert_register_p): New function.
(x86_64_init_abi): Set convert_register_p, register_to_value and
value_to_register here.
@
text
@d600 7
d608 1
d634 1
a634 3
	  !examine_argument (class, n, &needed_intregs, &needed_sseregs)
	  || intreg / 2 + needed_intregs > INT_REGS
	  || ssereg / 2 + needed_sseregs > SSE_REGS)
d642 7
d656 10
a665 5
		  regcache_cooked_write
		    (regcache, int_parameter_registers[(intreg + 1) / 2],
		     VALUE_CONTENTS_ALL (args[i]) + offset);
		  offset += 8;
		  intreg += 2;
d668 13
a680 10
		  {
		    LONGEST val = extract_signed_integer
		      (VALUE_CONTENTS_ALL (args[i]) + offset, 4);
		    regcache_cooked_write_signed
		      (regcache, int_parameter_registers[intreg / 2], val);

		    offset += 8;
		    intreg++;
		    break;
		  }
d684 10
a693 5
		  regcache_cooked_write
		    (regcache, sse_parameter_registers[(ssereg + 1) / 2],
		     VALUE_CONTENTS_ALL (args[i]) + offset);
		  offset += 8;
		  ssereg += 2;
d696 10
a705 5
		  regcache_cooked_write
		    (regcache, sse_parameter_registers[ssereg / 2],
		     VALUE_CONTENTS_ALL (args[i]) + offset);
		  offset += 8;
		  ssereg++;
d734 5
d751 2
a752 1
  if (TYPE_CODE_FLT == TYPE_CODE (type))
d781 6
@


1.79.2.1
log
@
	* x86-64-tdep.c (x86_64_push_arguments): Always set %rax to number
	of SSE registers so that varargs functions work.  Rework handling
	of passing arguments on the stack.
	(x86_64_store_return_value): Return double and float values in SSE
	register.
@
text
@a599 7
  /* For varargs functions we have to pass the total number of SSE arguments
     in %rax.  So, let's count this number.  */
  int total_sse_args = 0;
  /* Once an SSE/int argument is passed on the stack, all subsequent
     arguments are passed there.  */
  int sse_stack = 0;
  int int_stack = 0;
a600 1
  char buf[8];
d626 3
a628 1
	  !examine_argument (class, n, &needed_intregs, &needed_sseregs))
a635 7

	  if (intreg / 2 + needed_intregs > INT_REGS)
	    int_stack = 1;
	  if (ssereg / 2 + needed_sseregs > SSE_REGS)
	    sse_stack = 1;
	  total_sse_args += needed_sseregs;

d643 5
a647 10
		  if (int_stack)
		    stack_values[stack_values_count++] = i;
		  else
		    {
		      regcache_cooked_write
			(regcache, int_parameter_registers[(intreg + 1) / 2],
			 VALUE_CONTENTS_ALL (args[i]) + offset);
		      offset += 8;
		      intreg += 2;
		    }
d650 10
a659 13
		  if (int_stack)
		    stack_values[stack_values_count++] = i;
		  else
		    {
		      LONGEST val = extract_signed_integer
			(VALUE_CONTENTS_ALL (args[i]) + offset, 4);
		      regcache_cooked_write_signed
			(regcache, int_parameter_registers[intreg / 2], val);
		      
		      offset += 8;
		      intreg++;
		    }
		  break;
d663 5
a667 10
		  if (sse_stack)
		    stack_values[stack_values_count++] = i;
		  else
		    {
		      regcache_cooked_write
			(regcache, sse_parameter_registers[(ssereg + 1) / 2],
			 VALUE_CONTENTS_ALL (args[i]) + offset);
		      offset += 8;
		      ssereg += 2;
		    }
d670 5
a674 10
		  if (sse_stack)
		    stack_values[stack_values_count++] = i;
		  else
		    {
		      regcache_cooked_write
			(regcache, sse_parameter_registers[ssereg / 2],
			 VALUE_CONTENTS_ALL (args[i]) + offset);
		      offset += 8;
		      ssereg++;
		    }
a702 5
  /* Write number of SSE type arguments to RAX to take care of varargs
     functions.  */
  store_unsigned_integer (buf, 8, total_sse_args);
  regcache_cooked_write (regcache, X86_64_RAX_REGNUM, buf);

d715 1
a715 2
  /* First handle long doubles.  */
  if (TYPE_CODE_FLT == TYPE_CODE (type)  && len == 16)
a743 6
  else if (TYPE_CODE_FLT == TYPE_CODE (type))
    {
      /* Handle double and float variables.  */
      regcache_cooked_write (regcache,  X86_64_XMM0_REGNUM, valbuf);
    }
  /* XXX: What about complex floating point types?  */
@


1.79.2.2
log
@	* x86-64-tdep.c (x86_64_push_arguments): Align stack to 16-byte
	before the call.
	Set %rax only to number of SSE registers used.
@
text
@d600 2
a601 2
  /* For varargs functions we have to pass the total number of SSE
     registers used in %rax.  So, let's count this number.  */
a606 1
  unsigned total_sp;
d647 1
a647 2
	  if (!sse_stack)
	    total_sse_args += needed_sseregs;
a722 16
  /* We have to make sure that the stack is 16-byte aligned after the
     setup.  Let's calculate size of arguments first, align stack and
     then fill in the arguments.  */
  total_sp = 0;
  for (i = 0; i < stack_values_count; i++)
    {
      struct value *arg = args[stack_values[i]];
      int len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (arg));
      total_sp += (len + 7) & ~7;
    }
  /* total_sp is now a multiple of 8, if it is not a multiple of 16,
     change the stack pointer so that it will be afterwards correctly
     aligned.  */
  if (total_sp & 15)
    sp -= 8;
    
d729 1
a729 1
      /* Make sure the stack is 8-byte-aligned.  */
@


1.79.2.3
log
@* x86-64-tdep.c (x86_64_store_return_value): Use
regcache_cooked_write_part instead of regcache_cooked_write.
@
text
@d802 1
a802 2
      regcache_cooked_write_part (regcache, X86_64_XMM0_REGNUM,
				  0, len, valbuf);
@


1.79.2.4
log
@2003-08-07  Michal Ludvig  <mludvig@@suse.cz>
	* x86-64-tdep.c (x86_64_dwarf_regmap): Correct register numbers.
@
text
@d158 1
a158 1
  X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, 3, 2,
@


1.79.2.5
log
@(Oops, now the correct version :-)
2003-08-07  Michal Ludvig  <mludvig@@suse.cz>
	* x86-64-tdep.c (x86_64_dwarf_regmap): Correct register numbers.
@
text
@d158 1
a158 1
  X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, 2, 1,
@


1.79.2.6
log
@2003-08-07  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-tdep.c (x86_64_push_arguments): Skip the red zone.
@
text
@a626 8

  /* Before storing anything to the stack we must skip
     the "Red zone" (see the "Function calling sequence" section
     of AMD64 ABI).
     It could have already been skipped in the function's
     prologue, but we don't care and will easily skip it once again.  */
  sp -= 128;

@


1.79.2.7
log
@* configure.host: Add x86_64-*-freebsd*.
* configure.tgt: Add x86_64-*-freebsd*.
* Makefile.in (amd64fbsd-nat.o, amd64fbsd-tdep.o): New targets.
* x86-64-tdep.h (amd64fbsd_sigtramp_start, amd64fbsd_sigtramp_end,
amd64fbsd_sc_reg_offset): Add extern declarations.
(X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, X86_64_RDI_REGNUM,
X86_64_RBP_REGNUM, X86_64_RSP_REGNUM, X86_64_RIP_REGNUM,
X86_64_EFLAGS_REGNUM, X86_64_ST0_REGNUM, X86_64_XMM0_REGNUM,
X86_64_XMM1_REGNUM): Moved here ...
* x86-64-tdep.c: ... from here.
* amd64fbsd-nat.c: New file.
* amd64fbsd-tdep.c: New file.
* config/i386/nm-fbsd64.h: New file.
* config/i386/fbsd64.mh: New file.
* config/i386/fbsd64.mt: New file.
@
text
@d42 12
a53 1
/* Register information.  */
@


1.79.2.8
log
@Index: ChangeLog
2003-08-18  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_RED_ZONE_SIZE): New architecture method.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Adjust the SP by
	frame_red_zone_size before allocating any stack space.
	* rs6000-tdep.c (rs6000_gdbarch_init): Set "frame_red_zone_size".
	* x86-64-tdep.c (x86_64_frame_align): New function.
	(x86_64_init_abi): Set "frame_red_zone_size" and "frame_align".

	* x86-64-tdep.c (x86_64_push_arguments): Revert 2003-08-07 change.
	Remove code adjusting SP so that it skips over the Red Zone.

Index: doc/ChangeLog
2003-08-18  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Document
	"frame_red_zone_size".
@
text
@d617 7
a1204 8
/* 16 byte align the SP per frame requirements.  */

static CORE_ADDR
x86_64_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  return sp & -(CORE_ADDR)16;
}

a1247 2
  set_gdbarch_frame_align (gdbarch, x86_64_frame_align);
  set_gdbarch_frame_red_zone_size (gdbarch, 128);
@


1.78
log
@2003-06-13  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c (call_function_by_hand): When UNWIND_DUMMY_ID is
	available, do not use the FP register, and always save the TOS.
	* dummy-frame.c (dummy_frame_this_id): Do not assert
	SAVE_DUMMY_FRAME_TOS.
	* i386-tdep.c (i386_save_dummy_frame_tos): Delete function.
	(i386_gdbarch_init): Do not set save_dummy_frame_tos.
	(i386_push_dummy_call): Add 8 to the returned SP.
	* frame.c (legacy_frame_p): Do not require SAVE_DUMMY_FRAME_TOS.
	* d10v-tdep.c (d10v_unwind_dummy_id): Use d10v_unwind_sp.
	(d10v_gdbarch_init): Do not set save_dummy_frame_tos.
	* x86-64-tdep.c (x86_64_save_dummy_frame_tos): Delete function.
	(x86_64_push_dummy_call): Return "sp + 16".
	(x86_64_init_abi): Do not set save_dummy_frame_tos.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set
	save_dummy_frame_tos.
@
text
@d211 9
d1189 4
@


1.77
log
@2003-06-06  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-tdep.c (x86_64_fill_fxsave): Pass correct regnums
	to regcache_collect().
@
text
@d786 1
a786 1
  return sp;
a1124 6
static void
x86_64_save_dummy_frame_tos (CORE_ADDR sp)
{
  generic_save_dummy_frame_tos (sp + 16);
}

a1192 1
  set_gdbarch_save_dummy_frame_tos (gdbarch, x86_64_save_dummy_frame_tos);
@


1.76
log
@2003-06-05  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-tdep.c (x86_64_push_arguments): Don't clear offset
	in each pass.
@
text
@d1249 1
a1249 1
    regcache_collect (regnum, fxsave + 12);
d1251 1
a1251 1
    regcache_collect (regnum, fxsave + 20);
@


1.75
log
@* x86-64-tdep.c (x86_64_push_dummy_call): Adjust for changed
function signature.
@
text
@d626 1
a628 1
	      int offset = 0;
@


1.74
log
@* i386-tdep.c (i386_sigtramp_frame_p): Only handle frames if we
have a sigcontext_addr handler.
* x86-64-tdep.c (x86_64_sigtramp_frame_p): Assert that we have a
sigcontext_addr handler.
@
text
@d757 4
a760 3
x86_64_push_dummy_call (struct gdbarch *gdbarch, struct regcache *regcache,
			CORE_ADDR dummy_addr, int nargs, struct value **args,
			CORE_ADDR sp, int struct_return, CORE_ADDR struct_addr)
d776 1
a776 1
  store_unsigned_integer (buf, 8, dummy_addr);
@


1.73
log
@* x86-64-tdep.c (X86_64_NUM_SAVED_REGS): Set to X86_64_NUM_GREGS.
(x86_64_sigtramp_frame_cache): Use `sc_reg_offset' to find saved
registers.

* x86-64-linux-tdep.c (x86_64_linux_sc_reg_offset): New variable.
(x86_64_linux_init_abi): Initialize TDEP->sc_reg_offset and
TDEP->sc_num_regs instead of TDEP->sc_pc_offset and
TDEP->sc_sp_offset.
@
text
@d1097 5
a1101 1
    return &x86_64_sigtramp_frame_unwind;
@


1.72
log
@* x86-64-tdep.h (x86_64_num_regs, x86_64_num_gregs): Remove
variable declarations.
(x86_64_register_number, x86_64_register_name): Remove prototypes.
(x86_64_linux_frame_saved_pc, x86_64_linux+saved_pc_after_call,
x86_64_linux_in_sigtramp, x86_64_linux_frame_chain,
x86_64_init_frame_pc, x86_64_init_frame_pc,
x86_64_function_has_prologue): Remove prototypes.
(X86_64_NUM_GREGS): New define.
(x86_64_supply_fxsave, x86_64_fill_fxsave): New prototypes.
* x86-64-tdep.c: Don't include "dwarf2cfi.h".  Include
"dummy_frame.h", "frame.h", "frame-base.h", "frame-unwind.h".
(RAX_REGNUM, RDX_REGNUM, RDI_REGNUM, EFLAGS_REGNUM, ST0_REGNUM,
XMM1_REGNUM): Remove defines.
(X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, X86_64_RDI_REGNUM,
X86_64_RBP_REGNUM, X86_64_RSP_REGNUM, X86_64_RIP_REGNUM,
X86_64_EFLAGS_REGNUM, X86_64_ST0_REGNUM, X86_64_XMM0_REGNUM,
X86_64_XMM1_REGNUM): New defines.
(struct x86_64_register_info): Renamed from `struct
register_info'.  Remove `size' member.
(x86_64_register_info_table): Remove variable.
(x86_64_register_info): New variable.
(X86_64_NUM_REGS): New define.
(X86_64_NUM_GREGS): Remove define.
(x86_64_num_regs, x86_64_num_gregs): Remove variables.
(x86_64_dwarf2gdb_regno_map, x86_64_dwarf2gdb_regno_map_length):
Remove variables.
(x86_54_dwarf2_reg_to_regnum): Remove function.
(x86_64_dwarf_regmap, x86_64_dwarf_regmap_len): New variables.
(x86_64_dwarf_reg_to_regnum): New function.
(x86_64_register_name): Rewrite.
(x86_64_register_raw_size): Remove function.
(x86_64_register_byte_table): Remove variable.
(x86_64_register_byte): Remove function.
(x86_64_register_virtual_type): Remove function.
(x86_64_register_type): New function.
(x86_64_register_convertible, x86_64_register_convert_to_virtual,
x86_64_register_convert_to_raw): Remove functions.
(x86_64_push_return_address, x86_64_pop_frame): Remove functon.
(x86_64_use_struct_convention): Make static.  Adjust for renamed
defines.
(x86_64_frame_init_saved_regs): Remove function.
(x86_64_push_arguments): Make static.  Change to accept a regcache
as argument.
(x86_64_store_return_value, x86_64_extract_return_value): Make
static.  Rewrite based on i386 counterparts.
(x86_64_push_dummy_call): New function.
(X86_64_NUM_SAVED_REGS): New define.
(x86_64_register_number): Remove function.
(x86_64_store_struct_return): Remove function.
(x86_64_frameless_function_invocation,
x86_64_function_has_prologue): Remove functions.
(PROLOG_BUFSIZE): Remove define.
(struct x86_64_frame_cache): New structure.
(x86_64_alloc_frame_cache, x86_64_analyze_prologue,
x86_64_frame_cache, x86_64_frame_this_id,
x86_64_frame_prev_register, x86_64_frame_p,
x86_64_sigtramp_frame_cache, x86_64_sigtramp_frame_this_id,
x86_64_sigtramp_frame_prev_register, x86_sigtramp_frame_p): New
functions.
(x86_64_frame_unwind, x86_64_sigtramp_frame_unwind): New
variables.
(x86_64_skip_prologue): Rewrite in terms of
x86_64_analyze_prologue.
(x86_64_frame_base_address): New function.
(x86_64_frame_base): New variable.
(x86_64_save_dummy_frame_tos, x86_64_unwind_dummy_id): Rewrite.
(x86_64_init_abi): Set register_type and push_dummy_call.  Don't
set deprecated_fp_regnum, deprecated_register_size,
deprecated_register_bytes, register_raw_size, register_byte,
register_virtual_type, register_convertiable,
register_convert_to_virtual, convert_to_raw,
deprecated_get_saved_register, deprecated_target_read_fp,
deprecated_push_arguments, deprecated_push_return_address,
deprecated_pop_frame, deprecated_store_struct_return,
deprecated_frame_init_saved_regs, deprecated_frame_chain,
frameless_function_invocation, deprecated_frame_saved_pc,
deprecated_saved_pc_after_call, frame_num_args, pc_in_sigtramp,
dwarf2_build_frame_info, deprecated_init_extra_frame_info,
deprecated_init_frame_pc and virtual_frame_pointer.  Call
frame_unwind_append_predicate to register x86_64_sigtramp_frame_p
and x86_64_frame_p.  Call frame_base_set_default to register
x86_64_frame_base.
(I387_FISEG_REGNUM, I387_FOSEG_REGNUM): New defines.
(x86_64_supply_fxsave, x86_64_fill_fxsave): New functions.
(_initialize_x86_64_tdep): Remove function.
* x86-64-linux-tdep.c: Don't include "dwarf2cfi.h".
(LINUX_SIGINFO_SIZE, LINUX_UCONTEXT_SIGCONTEXT_OFFSET,
LINUX_SIGCONTEXT_PC_OFFSET, LINUX_SIGCONTEXT_FP_OFFSET): Don't
define.
(X86_64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET): Define.
(x86_64_linux_sigcontext_addr): Rewrite.
(x86_64_linux_sigtramp_saved_pc, x86_64_linux_saved_pc_after_call,
x86_64_linux_frame_saved_pc): Remove functions.
(x86_64_linux_pc_in_sigtramp): Renamed from
x86_64_linux_in_sigtramp.  Try harder to recognize a signal
trampoline.
(x86_64_linux_frame_chain, x86_64_init_frame_pc):
Remove_functions.
(x86_64_linux_init_abi): Set pc_in_sigtramp.  Initialize
TDEP->sigcontext_addr, TDEP->sc_pc_offset and TDEP->sc_sp_offset.
* x86-64-linux-nat.c: Sync with i386-linux-tdep.c.
(x86_64_regmap): Rename to regmap.
(GETREGS_SUPPLIES): Use X86_64_NUM_GREGS instead of
x86_64_num_gregs.
(supply_gregset, fill_gregset): Likewise.  Use regmap instead of
x86_64_regmap.
(x86_64_fxsave_offset): Remove function.
(supply_fpregset): Simply call x86_64_supply_fxsave.
(fill_fpregset): Simply call x86_64_fill_fxsave.
(fetch_inferior_registers, store_inferior_registers): Avoid
asignment in if-statement.
(LINUX_SYSCALL_LEN, LINUX_SYSCALL_REGNUM, SYS_Sigreturn,
SYS_rt_sigreturn, LINUX_SIGCONTEXT_EFLAGS_OFFSET,
LINUX_UCONTEXT_SIGCONTEXT_OFFSET): Remove defines.
(fetch_core_registers): Remove function.
(linux_elf_core_fns): Remove.
(offsetoff): Don't define.
(_initialize_x86_64_linux_nat, kernel_u_size): Remove functions.
* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
* config/i386/x86-64linux.mh (NATDEPFILES): Remove core-aout.o,
add core-regset.o.
* config/i386/nm-x86-64linux.h: Use NM_X86_64_LINUX_H for
protection against multiple includes instead of NM_X86_64_h.  Add
various comments.  Include "config/nm-linux.h".  Don't include
<signal.h>.
(REGISTER_U_ADDR, KERNEL_U_SIZE, U_REGS_OFFSET, KERN_U_ADDR,
GET_THREAD_SIGNALS): Remove defines.
(x86_64_register_u_addr, kernel_u_size,
lin_thread_get_thread_signals): Remove prototypes.
(PTRACE_ARG3_TYPE, PTRACE_XFER_TYPE): Define to `long'.
[HAVE_LINK_H]: Don't include "solib.h".
[HAVE_LINK_H] (SVR4_SHARED_LIBS): Remove define.
* config/i386/tm-x86-64linux.h: Fix comments.
* Makefile.in (x86-64-linux-nat.o, x86_64-linux-tdep.o,
x86-64-tdep.o): Update dependencies.
@
text
@d790 1
a790 1
#define X86_64_NUM_SAVED_REGS	17
d1038 1
d1049 5
a1053 2
  cache->saved_regs[X86_64_RIP_REGNUM] = addr + tdep->sc_pc_offset;
  cache->saved_regs[X86_64_RSP_REGNUM] = addr + tdep->sc_sp_offset;
@


1.71
log
@2003-05-19  Michal Ludvig  <mludvig@@suse.cz>
	* x86-64-tdep.c (x86_64_dwarf2gdb_regno_map): Fix
	register numbers mapping.
@
text
@d24 6
d31 1
d33 1
a33 2
#include "gdbcmd.h"
#include "arch-utils.h"
d36 3
a38 1
#include "objfiles.h"
d40 1
a40 3
#include "dwarf2cfi.h"
#include "gdb_assert.h"
#include "block.h"
a42 6
#define RAX_REGNUM 0
#define RDX_REGNUM 3
#define RDI_REGNUM 5
#define EFLAGS_REGNUM 17
#define ST0_REGNUM 22
#define XMM1_REGNUM  39
d44 12
a55 1
struct register_info
a56 1
  int size;
d61 63
a123 58
/* x86_64_register_raw_size_table[i] is the number of bytes of storage in
   GDB's register array occupied by register i.  */
static struct register_info x86_64_register_info_table[] = {
  /*  0 */ {8, "rax", &builtin_type_int64},
  /*  1 */ {8, "rbx", &builtin_type_int64},
  /*  2 */ {8, "rcx", &builtin_type_int64},
  /*  3 */ {8, "rdx", &builtin_type_int64},
  /*  4 */ {8, "rsi", &builtin_type_int64},
  /*  5 */ {8, "rdi", &builtin_type_int64},
  /*  6 */ {8, "rbp", &builtin_type_void_func_ptr},
  /*  7 */ {8, "rsp", &builtin_type_void_func_ptr},
  /*  8 */ {8, "r8", &builtin_type_int64},
  /*  9 */ {8, "r9", &builtin_type_int64},
  /* 10 */ {8, "r10", &builtin_type_int64},
  /* 11 */ {8, "r11", &builtin_type_int64},
  /* 12 */ {8, "r12", &builtin_type_int64},
  /* 13 */ {8, "r13", &builtin_type_int64},
  /* 14 */ {8, "r14", &builtin_type_int64},
  /* 15 */ {8, "r15", &builtin_type_int64},
  /* 16 */ {8, "rip", &builtin_type_void_func_ptr},
  /* 17 */ {4, "eflags", &builtin_type_int32},
  /* 18 */ {4, "ds", &builtin_type_int32},
  /* 19 */ {4, "es", &builtin_type_int32},
  /* 20 */ {4, "fs", &builtin_type_int32},
  /* 21 */ {4, "gs", &builtin_type_int32},
  /* 22 */ {10, "st0", &builtin_type_i387_ext},
  /* 23 */ {10, "st1", &builtin_type_i387_ext},
  /* 24 */ {10, "st2", &builtin_type_i387_ext},
  /* 25 */ {10, "st3", &builtin_type_i387_ext},
  /* 26 */ {10, "st4", &builtin_type_i387_ext},
  /* 27 */ {10, "st5", &builtin_type_i387_ext},
  /* 28 */ {10, "st6", &builtin_type_i387_ext},
  /* 29 */ {10, "st7", &builtin_type_i387_ext},
  /* 30 */ {4, "fctrl", &builtin_type_int32},
  /* 31 */ {4, "fstat", &builtin_type_int32},
  /* 32 */ {4, "ftag", &builtin_type_int32},
  /* 33 */ {4, "fiseg", &builtin_type_int32},
  /* 34 */ {4, "fioff", &builtin_type_int32},
  /* 35 */ {4, "foseg", &builtin_type_int32},
  /* 36 */ {4, "fooff", &builtin_type_int32},
  /* 37 */ {4, "fop", &builtin_type_int32},
  /* 38 */ {16, "xmm0", &builtin_type_v4sf},
  /* 39 */ {16, "xmm1", &builtin_type_v4sf},
  /* 40 */ {16, "xmm2", &builtin_type_v4sf},
  /* 41 */ {16, "xmm3", &builtin_type_v4sf},
  /* 42 */ {16, "xmm4", &builtin_type_v4sf},
  /* 43 */ {16, "xmm5", &builtin_type_v4sf},
  /* 44 */ {16, "xmm6", &builtin_type_v4sf},
  /* 45 */ {16, "xmm7", &builtin_type_v4sf},
  /* 46 */ {16, "xmm8", &builtin_type_v4sf},
  /* 47 */ {16, "xmm9", &builtin_type_v4sf},
  /* 48 */ {16, "xmm10", &builtin_type_v4sf},
  /* 49 */ {16, "xmm11", &builtin_type_v4sf},
  /* 50 */ {16, "xmm12", &builtin_type_v4sf},
  /* 51 */ {16, "xmm13", &builtin_type_v4sf},
  /* 52 */ {16, "xmm14", &builtin_type_v4sf},
  /* 53 */ {16, "xmm15", &builtin_type_v4sf},
  /* 54 */ {4, "mxcsr", &builtin_type_int32}
d126 3
a128 22
/* This array is a mapping from Dwarf-2 register 
   numbering to GDB's one. Dwarf-2 numbering is 
   defined in x86-64 ABI, section 3.6.  */
static int x86_64_dwarf2gdb_regno_map[] = {
  0, 3, 2, 1,			/* RAX, RDX, RCX, RBX */
  4, 5, 6, 7,			/* RSI, RDI, RBP, RSP */
  8, 9, 10, 11,			/* R8 - R11 */
  12, 13, 14, 15,		/* R12 - R15 */
  -1,				/* RA - not mapped */
  XMM1_REGNUM - 1, XMM1_REGNUM,	/* XMM0 ... */
  XMM1_REGNUM + 1, XMM1_REGNUM + 2,
  XMM1_REGNUM + 3, XMM1_REGNUM + 4,
  XMM1_REGNUM + 5, XMM1_REGNUM + 6,
  XMM1_REGNUM + 7, XMM1_REGNUM + 8,
  XMM1_REGNUM + 9, XMM1_REGNUM + 10,
  XMM1_REGNUM + 11, XMM1_REGNUM + 12,
  XMM1_REGNUM + 13, XMM1_REGNUM + 14,	/* ... XMM15 */
  ST0_REGNUM + 0, ST0_REGNUM + 1,	/* ST0 ... */
  ST0_REGNUM + 2, ST0_REGNUM + 3,
  ST0_REGNUM + 4, ST0_REGNUM + 5,
  ST0_REGNUM + 6, ST0_REGNUM + 7	/* ... ST7 */
};
d130 1
a130 3
static int x86_64_dwarf2gdb_regno_map_length =
  sizeof (x86_64_dwarf2gdb_regno_map) /
  sizeof (x86_64_dwarf2gdb_regno_map[0]);
d132 5
a136 3
/* Number of all registers */
#define X86_64_NUM_REGS (sizeof (x86_64_register_info_table) / \
  sizeof (x86_64_register_info_table[0]))
d138 2
a139 2
/* Number of general registers.  */
#define X86_64_NUM_GREGS (22)
d141 2
a142 2
int x86_64_num_regs = X86_64_NUM_REGS;
int x86_64_num_gregs = X86_64_NUM_GREGS;
d144 4
a147 2
/* Did we already print a note about frame pointer?  */
int omit_fp_note_printed = 0;
d149 1
a149 6
/* Number of bytes of storage in the actual machine representation for
   register REGNO.  */
int
x86_64_register_raw_size (int regno)
{
  return x86_64_register_info_table[regno].size;
d152 2
a153 4
/* x86_64_register_byte_table[i] is the offset into the register file of the
   start of register number i.  We initialize this from
   x86_64_register_info_table.  */
int x86_64_register_byte_table[X86_64_NUM_REGS];
d155 1
a155 3
/* Index within `registers' of the first byte of the space for register REGNO.  */
int
x86_64_register_byte (int regno)
d157 3
a159 2
  return x86_64_register_byte_table[regno];
}
d161 2
a162 7
/* Return the GDB type object for the "standard" data type of data in
   register N. */
static struct type *
x86_64_register_virtual_type (int regno)
{
  return *x86_64_register_info_table[regno].type;
}
d164 2
a165 10
/* x86_64_register_convertible is true if register N's virtual format is
   different from its raw format.  Note that this definition assumes
   that the host supports IEEE 32-bit floats, since it doesn't say
   that SSE registers need conversion.  Even if we can't find a
   counterexample, this is still sloppy.  */
int
x86_64_register_convertible (int regno)
{
  return IS_FP_REGNUM (regno);
}
d167 2
a168 9
/* Convert data from raw format for register REGNUM in buffer FROM to
   virtual format with type TYPE in buffer TO.  In principle both
   formats are identical except that the virtual format has two extra
   bytes appended that aren't used.  We set these to zero.  */
void
x86_64_register_convert_to_virtual (int regnum, struct type *type,
				    char *from, char *to)
{
  char buf[12];
d170 2
a171 16
  /* We only support floating-point values.  */
  if (TYPE_CODE (type) != TYPE_CODE_FLT)
    {
      warning ("Cannot convert floating-point register value "
	       "to non-floating-point type.");
      memset (to, 0, TYPE_LENGTH (type));
      return;
    }
  /* First add the necessary padding.  */
  memcpy (buf, from, FPU_REG_RAW_SIZE);
  memset (buf + FPU_REG_RAW_SIZE, 0, sizeof buf - FPU_REG_RAW_SIZE);
  /* Convert to TYPE.  This should be a no-op, if TYPE is equivalent
     to the extended floating-point format used by the FPU.  */
  convert_typed_floating (to, type, buf,
			  x86_64_register_virtual_type (regnum));
}
d173 5
a177 3
/* Convert data from virtual format with type TYPE in buffer FROM to
   raw format for register REGNUM in buffer TO.  Simply omit the two
   unused bytes.  */
d179 5
a183 8
void
x86_64_register_convert_to_raw (struct type *type, int regnum,
				char *from, char *to)
{
  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FLT && TYPE_LENGTH (type) == 12);
  /* Simply omit the two unused bytes.  */
  memcpy (to, from, FPU_REG_RAW_SIZE);
}
d185 6
a190 9
/* Dwarf-2 <-> GDB register numbers mapping.  */
int
x86_64_dwarf2_reg_to_regnum (int dw_reg)
{
  if (dw_reg < 0 || dw_reg > x86_64_dwarf2gdb_regno_map_length)
    {
      warning ("Dwarf-2 uses unmapped register #%d\n", dw_reg);
      return dw_reg;
    }
d192 2
a193 2
  return x86_64_dwarf2gdb_regno_map[dw_reg];
}
d195 2
a196 2
/* Push the return address (pointing to the call dummy) onto the stack
   and return the new value for the stack pointer.  */
d198 2
a199 2
static CORE_ADDR
x86_64_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
d201 4
a204 1
  char buf[8];
d206 2
a207 4
  store_unsigned_integer (buf, 8, CALL_DUMMY_ADDRESS ());
  write_memory (sp - 8, buf, 8);
  return sp - 8;
}
d209 1
a209 4
static void
x86_64_pop_frame (void)
{
  generic_pop_current_frame (cfi_pop_frame);
d214 2
a215 3
   Some types are returned in registers an some (big structures) in memory.
   See ABI for details.
 */
d234 1
a234 1
   See the x86-64 ABI for details.  */
d239 1
a239 1
  /* Rule #1: If both classes are equal, this is the resulting class.  */
d243 1
a243 1
  /* Rule #2: If one of the classes is NO_CLASS, the resulting class
d250 1
a250 1
  /* Rule #3: If one of the classes is MEMORY, the result is MEMORY.  */
d254 1
a254 1
  /* Rule #4: If one of the classes is INTEGER, the result is INTEGER.  */
d262 2
a263 1
  /* Rule #5: If one of the classes is X87 or X87UP class, MEMORY is used.  */
d268 1
a268 1
  /* Rule #6: Otherwise class SSE is used.  */
d278 1
a278 1
   See the x86-64 psABI for details.  */
d486 2
a487 1
int
d504 1
a504 1
void
d515 2
a516 2
  int ret_int_r[RET_INT_REGS] = { RAX_REGNUM, RDX_REGNUM };
  int ret_sse_r[RET_SSE_REGS] = { XMM0_REGNUM, XMM1_REGNUM };
d523 1
a523 1
      regcache_cooked_read (regcache, RAX_REGNUM, &addr);
d564 1
a564 1
	      regcache_cooked_read_part (regcache, FP0_REGNUM,
d569 1
a569 1
	      regcache_cooked_read_part (regcache, FP0_REGNUM,
a581 6
static void
x86_64_frame_init_saved_regs (struct frame_info *fi)
{
  /* Do nothing.  Everything is handled by the stack unwinding code.  */
}

d583 1
a583 1
#define SSE_REGS 16
d585 3
a587 3
CORE_ADDR
x86_64_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		       int struct_return, CORE_ADDR struct_addr)
d592 5
a596 4
  static int int_parameter_registers[INT_REGS] = {
    5 /* RDI */ , 4 /* RSI */ ,
    3 /* RDX */ , 2 /* RCX */ ,
    8 /* R8  */ , 9		/* R9  */
d598 7
a604 6
  /* XMM0 - XMM15  */
  static int sse_parameter_registers[SSE_REGS] = {
    XMM1_REGNUM - 1, XMM1_REGNUM, XMM1_REGNUM + 1, XMM1_REGNUM + 2,
    XMM1_REGNUM + 3, XMM1_REGNUM + 4, XMM1_REGNUM + 5, XMM1_REGNUM + 6,
    XMM1_REGNUM + 7, XMM1_REGNUM + 8, XMM1_REGNUM + 9, XMM1_REGNUM + 10,
    XMM1_REGNUM + 11, XMM1_REGNUM + 12, XMM1_REGNUM + 13, XMM1_REGNUM + 14
d634 3
a636 3
		  deprecated_write_register_gen (int_parameter_registers
						 [(intreg + 1) / 2],
						 VALUE_CONTENTS_ALL (args[i]) + offset);
d642 4
a645 5
		    LONGEST num
		      = extract_signed_integer (VALUE_CONTENTS_ALL (args[i])
						+ offset, 4);
		    regcache_raw_write_signed (current_regcache,
					       int_parameter_registers[intreg / 2],                                           num);
d654 3
a656 3
		  deprecated_write_register_gen (sse_parameter_registers
						 [(ssereg + 1) / 2],
						 VALUE_CONTENTS_ALL (args[i]) + offset);
d661 3
a663 2
		  deprecated_write_register_gen (sse_parameter_registers[ssereg / 2],
						 VALUE_CONTENTS_ALL (args[i]) + offset);
d682 2
d688 3
a690 3
      len += 7;
      len -= len % 8;
      sp -= len;
d693 1
d699 2
a700 1
void
d708 2
a709 11
      /* Floating-point return values can be found in %st(0).  */
      if (len == TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT
	  && TARGET_LONG_DOUBLE_FORMAT == &floatformat_i387_ext)
	{
	  /* Copy straight over.  */
	  regcache_cooked_write (regcache, FP0_REGNUM, valbuf);
	}
      else
	{
	  char buf[FPU_REG_RAW_SIZE];
	  DOUBLEST val;
d711 23
a733 9
	  /* Convert the value found in VALBUF to the extended
	     floating point format used by the FPU.  This is probably
	     not exactly how it would happen on the target itself, but
	     it is the best we can do.  */
	  val = deprecated_extract_floating (valbuf, TYPE_LENGTH (type));
	  floatformat_from_doublest (&floatformat_i387_ext, &val, buf);
	  regcache_cooked_write_part (regcache, FP0_REGNUM,
			  	      0, FPU_REG_RAW_SIZE, buf);
	}
d756 37
a792 2
const char *
x86_64_register_name (int reg_nr)
d794 87
a880 3
  if (reg_nr < 0 || reg_nr >= X86_64_NUM_REGS)
    return NULL;
  return x86_64_register_info_table[reg_nr].name;
d883 4
a886 2
int
x86_64_register_number (const char *name)
d888 2
a889 1
  int reg_nr;
d891 5
a895 4
  for (reg_nr = 0; reg_nr < X86_64_NUM_REGS; reg_nr++)
    if (strcmp (name, x86_64_register_info_table[reg_nr].name) == 0)
      return reg_nr;
  return -1;
d899 4
a902 4
/* Store the address of the place in which to copy the structure the
   subroutine will return.  This is called from call_function. */
void
x86_64_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
d904 47
a950 1
  write_register (RDI_REGNUM, addr);
d953 3
a955 2
int
x86_64_frameless_function_invocation (struct frame_info *frame)
d957 8
a964 1
  return 0;
d967 91
a1057 9
/* We will handle only functions beginning with:
   55          pushq %rbp
   48 89 e5    movq %rsp,%rbp
   Any function that doesn't start with this sequence
   will be assumed to have no prologue and thus no valid
   frame pointer in %rbp.  */
#define PROLOG_BUFSIZE 4
int
x86_64_function_has_prologue (CORE_ADDR pc)
d1059 5
a1063 3
  int i;
  unsigned char prolog_expect[PROLOG_BUFSIZE] = { 0x55, 0x48, 0x89, 0xe5 },
    prolog_buf[PROLOG_BUFSIZE];
d1065 9
a1073 1
  read_memory (pc, (char *) prolog_buf, PROLOG_BUFSIZE);
d1075 2
a1076 6
  /* First check, whether pc points to pushq %rbp, movq %rsp,%rbp.  */
  for (i = 0; i < PROLOG_BUFSIZE; i++)
    if (prolog_expect[i] != prolog_buf[i])
      return 0;		/* ... no, it doesn't. Nothing to skip.  */
  
  return 1;
d1079 6
a1084 3
/* If a function with debugging information and known beginning
   is detected, we will return pc of the next line in the source 
   code. With this approach we effectively skip the prolog.  */
d1086 2
a1087 2
CORE_ADDR
x86_64_skip_prologue (CORE_ADDR pc)
d1089 15
a1103 29
  int i;
  struct symtab_and_line v_sal;
  struct symbol *v_function;
  CORE_ADDR endaddr;

  if (! x86_64_function_has_prologue (pc))
    return pc;

  /* OK, we have found the prologue and want PC of the first
     non-prologue instruction.  */
  pc += PROLOG_BUFSIZE;

  v_function = find_pc_function (pc);
  v_sal = find_pc_line (pc, 0);

  /* If pc doesn't point to a function with debuginfo, some of the
     following may be NULL.  */
  if (!v_function || !v_function->ginfo.value.block || !v_sal.symtab)
    return pc;

  endaddr = BLOCK_END (SYMBOL_BLOCK_VALUE (v_function));

  for (i = 0; i < v_sal.symtab->linetable->nitems; i++)
    if (v_sal.symtab->linetable->item[i].pc >= pc
	&& v_sal.symtab->linetable->item[i].pc < endaddr)
      {
	pc = v_sal.symtab->linetable->item[i].pc;
	break;
      }
d1105 1
a1105 1
  return pc;
d1108 8
d1119 1
a1119 4
  /* We must add the size of the return address that is already 
     put on the stack.  */
  generic_save_dummy_frame_tos (sp + 
				TYPE_LENGTH (builtin_type_void_func_ptr));
d1123 1
a1123 1
x86_64_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *frame)
d1125 7
a1131 3
  CORE_ADDR base;
  frame_unwind_unsigned_register (frame, SP_REGNUM, &base);
  return frame_id_build (base, frame_pc_unwind (frame));
a1137 1
  int i, sum;
d1153 2
d1157 4
a1160 5
  set_gdbarch_sp_regnum (gdbarch, 7); /* %rsp */
  set_gdbarch_deprecated_fp_regnum (gdbarch, 6); /* %rbp */
  set_gdbarch_pc_regnum (gdbarch, 16); /* %rip */
  set_gdbarch_ps_regnum (gdbarch, 17); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, X86_64_NUM_GREGS); /* %st(0) */
d1163 8
a1170 8
     referred to as the "DWARF register number mapping" in the psABI.
     The preferred debugging format for all known x86-64 targets is
     actually DWARF2, and GCC doesn't seem to support DWARF (that is
     DWARF-1), but we provide the same mapping just in case.  This
     mapping is also used for stabs, which GCC does support.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, x86_64_dwarf2_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, x86_64_dwarf2_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, x86_64_dwarf2_reg_to_regnum);
d1172 2
a1173 2
  /* We don't override SDB_REG_RO_REGNUM, sice COFF doesn't seem to be
     in use on any of the supported x86-64 targets.  */
d1175 2
a1176 25
  set_gdbarch_register_name (gdbarch, x86_64_register_name);
  set_gdbarch_deprecated_register_size (gdbarch, 8);

  /* Total amount of space needed to store our copies of the machine's
     register (SIZEOF_GREGS + SIZEOF_FPU_REGS + SIZEOF_FPU_CTRL_REGS +
     SIZEOF_SSE_REGS) */
  for (i = 0, sum = 0; i < X86_64_NUM_REGS; i++)
    sum += x86_64_register_info_table[i].size;
  set_gdbarch_deprecated_register_bytes (gdbarch, sum);

  set_gdbarch_register_raw_size (gdbarch, x86_64_register_raw_size);
  set_gdbarch_register_byte (gdbarch, x86_64_register_byte);
  set_gdbarch_register_virtual_type (gdbarch, x86_64_register_virtual_type);

  set_gdbarch_register_convertible (gdbarch, x86_64_register_convertible);
  set_gdbarch_register_convert_to_virtual (gdbarch,
					   x86_64_register_convert_to_virtual);
  set_gdbarch_register_convert_to_raw (gdbarch,
				       x86_64_register_convert_to_raw);

  /* Getting saved registers is handled by unwind information.  */
  set_gdbarch_deprecated_get_saved_register (gdbarch, cfi_get_saved_register);

  /* FIXME: kettenis/20021026: Should we set parm_boundary to 64 here?  */
  set_gdbarch_deprecated_target_read_fp (gdbarch, cfi_read_fp);
a1178 5

  set_gdbarch_deprecated_push_arguments (gdbarch, x86_64_push_arguments);
  set_gdbarch_deprecated_push_return_address (gdbarch, x86_64_push_return_address);
  set_gdbarch_deprecated_pop_frame (gdbarch, x86_64_pop_frame);
  set_gdbarch_deprecated_store_struct_return (gdbarch, x86_64_store_struct_return);
a1183 1
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, x86_64_frame_init_saved_regs);
d1186 1
a1186 11
  set_gdbarch_deprecated_frame_chain (gdbarch, x86_64_linux_frame_chain);
  set_gdbarch_frameless_function_invocation (gdbarch,
					 x86_64_frameless_function_invocation);
  /* FIXME: kettenis/20021026: These two are GNU/Linux-specific and
     should be moved elsewhere.  */
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, x86_64_linux_frame_saved_pc);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, x86_64_linux_saved_pc_after_call);
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
  /* FIXME: kettenis/20021026: This one is GNU/Linux-specific too.  */
  set_gdbarch_pc_in_sigtramp (gdbarch, x86_64_linux_in_sigtramp);

d1189 2
a1190 11
  /* Build call frame information (CFI) from DWARF2 frame debug info.  */
  set_gdbarch_dwarf2_build_frame_info (gdbarch, dwarf2_build_frame_info);

  /* Initialization of per-frame CFI.  */
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, cfi_init_extra_frame_info);

  /* Frame PC initialization is handled by using CFI.  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, x86_64_init_frame_pc);

  /* Cons up virtual frame pointer for trace.  */
  set_gdbarch_virtual_frame_pointer (gdbarch, cfi_virtual_frame_pointer);
d1196 31
a1226 4
  
  /* Dummy frame helper functions.  */
  set_gdbarch_save_dummy_frame_tos (gdbarch, x86_64_save_dummy_frame_tos);
  set_gdbarch_unwind_dummy_id (gdbarch, x86_64_unwind_dummy_id);
d1229 5
d1235 1
a1235 1
_initialize_x86_64_tdep (void)
d1237 1
a1237 4
  /* Initialize the table saying where each register starts in the
     register file.  */
  {
    int i, offset;
d1239 4
a1242 7
    offset = 0;
    for (i = 0; i < X86_64_NUM_REGS; i++)
      {
	x86_64_register_byte_table[i] = offset;
	offset += x86_64_register_info_table[i].size;
      }
  }
@


1.70
log
@2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTES): Rename REGISTER_BYTES.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_extract_return_value): Delete reference.
	* TODO (REGISTER_BYTES): Delete reference.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	(ns32k_gdbarch_init_32382): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* sparc-tdep.c (sparc_pop_frame): Update.
	* rs6000-tdep.c (rs6000_pop_frame): Update.
	* remote.c (init_remote_state): Update.
	(remote_prepare_to_store): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	(sds_prepare_to_store): Update.
	* remote-array.c: Update.
	* regcache.c (init_legacy_regcache_descr): Update.
	(init_regcache_descr): Update.
	* mips-tdep.c (mips_eabi_extract_return_value): Update.
	(mips_o64_extract_return_value): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* irix4-nat.c (fetch_core_registers): Update.
	* i386-tdep.h: Update.
	* hppa-tdep.c (pa_do_registers_info): Update.
	(pa_do_strcat_registers_info): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/sparc/nm-sun4sol2.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-sun4os4.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-nbsd.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/s390/tm-s390.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-mips.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/m68k/tm-sun3.h (DEPRECATED_REGISTER_BYTES): Update.
	(REGISTER_BYTES_OK): Update.
	* config/m68k/nm-sun3.h (CHILD_PREPARE_TO_STORE): Update.
	* config/ia64/tm-ia64.h (DEPRECATED_REGISTER_BYTES): Update.

Index: doc/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	REGISTER_BYTES with DEPRECATED_REGISTER_BYTES.  Fix typo,
	DEPRECATED_REGISTER_SIZE instead of REGISTER_BYTE.

Index: mi/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_setup_architecture_data):
@
text
@d115 1
a115 1
  0, 1, 2, 3,			/* RAX - RDX */
@


1.69
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_SIZE): Rename REGISTER_SIZE.
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Rename
	SIZEOF_CALL_DUMMY_WORDS.
	(DEPRECATED_CALL_DUMMY_WORDS): Rename CALL_DUMMY_WORDS.
	(DEPRECATED_FIX_CALL_DUMMY): Rename FIX_CALL_DUMMY.
	(DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET): Rename
	CALL_DUMMY_BREAKPOINT_OFFSET.
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Rename
	CALL_DUMMY_START_OFFSET.
	(DEPRECATED_CALL_DUMMY_LENGTH): Rename CALL_DUMMY_LENGTH.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-tdep.c, alphafbsd-tdep.c, arm-linux-tdep.c: Update.
	* arm-tdep.c, avr-tdep.c, breakpoint.c, cris-tdep.c: Update.
	* dummy-frame.c, dummy-frame.h, frv-tdep.c, gdbarch.c: Update.
	* gdbarch.h, gdbarch.sh, h8300-tdep.c, hppa-tdep.c: Update.
	* i386-tdep.c, ia64-tdep.c, infcall.c, inferior.h: Update.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Update.
	* mips-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* rs6000-tdep.c, s390-tdep.c, sh-tdep.c, sol-thread.c: Update.
	* sparc-tdep.c, target.c, v850-tdep.c, valops.c: Update.
	* vax-tdep.c, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/ia64/tm-ia64.h, config/m68k/tm-vx68.h: Update.
	* config/mips/tm-mips.h, config/pa/nm-hppah.h: Update.
	* config/pa/tm-hppa.h, config/pa/tm-hppa64.h: Update.
	* config/s390/tm-s390.h, config/sparc/tm-sp64.h: Update.
	* config/sparc/tm-sparc.h: Update.

Index: doc/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Make
	CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_LENGTH,
	FIX_CALL_DUMMY, CALL_DUMMY_BREAKPOINT_OFFSET and
	CALL_DUMMY_BREAKPOINT_OFFSET deprecated.

Index: mi/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Replace
	REGISTER_SIZE with DEPRECATED_REGISTER_SIZE.

Index: testsuite/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/watchpoint.exp: Rename CALL_DUMMY_BREAKPOINT_OFFSET to
	DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET in comments.
@
text
@d964 1
a964 1
  set_gdbarch_register_bytes (gdbarch, sum);
@


1.68
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d957 1
a957 1
  set_gdbarch_register_size (gdbarch, 8);
@


1.67
log
@* x86-64-tdep.c (att_flavour, intel_flavour, valid_flavours,
disassmbly_flavour): Removed.
@
text
@d938 1
a938 1
  set_gdbarch_fp_regnum (gdbarch, 6); /* %rbp */
d980 1
a980 1
  set_gdbarch_read_fp (gdbarch, cfi_read_fp);
@


1.67.2.1
log
@Merge from mainline.
@
text
@d938 1
a938 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, 6); /* %rbp */
d980 1
a980 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, cfi_read_fp);
@


1.67.2.2
log
@Revise the x86_64 (sub)taget.
* x86-64-tdep.c, x86-64-linux-tdep.c, x86-64-linux-nat.c,
config/i386/tm-x86-64linux.h, config/i386/nm-x86-64linux.h,
config/i386/x86-64-linux.mt, config/i386/x86-64linux.mh: Extensive
changes.
@
text
@a23 7
#include "arch-utils.h"
#include "block.h"
#include "dummy-frame.h"
#include "dwarf-frame.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
d25 1
d27 1
a27 2
#include "gdbcore.h"
#include "objfiles.h"
d30 3
a32 1

d34 1
a34 3

#include "x86-64-tdep.h"
#include "i387-tdep.h"
d37 6
d44 1
a44 12
#define X86_64_RAX_REGNUM	0 /* %rax */
#define X86_64_RDX_REGNUM	3 /* %rdx */
#define X86_64_RDI_REGNUM	5 /* %rdi */
#define X86_64_RBP_REGNUM	6 /* %rbp */
#define X86_64_RSP_REGNUM	7 /* %rsp */
#define X86_64_RIP_REGNUM	16 /* %rip */
#define X86_64_EFLAGS_REGNUM	17 /* %eflags */
#define X86_64_ST0_REGNUM	22 /* %st0 */
#define X86_64_XMM0_REGNUM	38 /* %xmm0 */
#define X86_64_XMM1_REGNUM	39 /* %xmm1 */

struct x86_64_register_info
d46 1
d51 81
a131 63
static struct x86_64_register_info x86_64_register_info[] =
{
  { "rax", &builtin_type_int64 },
  { "rbx", &builtin_type_int64 },
  { "rcx", &builtin_type_int64 },
  { "rdx", &builtin_type_int64 },
  { "rsi", &builtin_type_int64 },
  { "rdi", &builtin_type_int64 },
  { "rbp", &builtin_type_void_data_ptr },
  { "rsp", &builtin_type_void_data_ptr },

  /* %r8 is indeed register number 8.  */
  { "r8", &builtin_type_int64 },
  { "r9", &builtin_type_int64 },
  { "r10", &builtin_type_int64 },
  { "r11", &builtin_type_int64 },
  { "r12", &builtin_type_int64 },
  { "r13", &builtin_type_int64 },
  { "r14", &builtin_type_int64 },
  { "r15", &builtin_type_int64 },
  { "rip", &builtin_type_void_func_ptr },
  { "eflags", &builtin_type_int32 },
  { "ds", &builtin_type_int32 },
  { "es", &builtin_type_int32 },
  { "fs", &builtin_type_int32 },
  { "gs", &builtin_type_int32 },

  /* %st0 is register number 22.  */
  { "st0", &builtin_type_i387_ext },
  { "st1", &builtin_type_i387_ext },
  { "st2", &builtin_type_i387_ext },
  { "st3", &builtin_type_i387_ext },
  { "st4", &builtin_type_i387_ext },
  { "st5", &builtin_type_i387_ext },
  { "st6", &builtin_type_i387_ext },
  { "st7", &builtin_type_i387_ext },
  { "fctrl", &builtin_type_int32 },
  { "fstat", &builtin_type_int32 },
  { "ftag", &builtin_type_int32 },
  { "fiseg", &builtin_type_int32 },
  { "fioff", &builtin_type_int32 },
  { "foseg", &builtin_type_int32 },
  { "fooff", &builtin_type_int32 },
  { "fop", &builtin_type_int32 },

  /* %xmm0 is register number 38.  */
  { "xmm0", &builtin_type_v4sf },
  { "xmm1", &builtin_type_v4sf },
  { "xmm2", &builtin_type_v4sf },
  { "xmm3", &builtin_type_v4sf },
  { "xmm4", &builtin_type_v4sf },
  { "xmm5", &builtin_type_v4sf },
  { "xmm6", &builtin_type_v4sf },
  { "xmm7", &builtin_type_v4sf },
  { "xmm8", &builtin_type_v4sf },
  { "xmm9", &builtin_type_v4sf },
  { "xmm10", &builtin_type_v4sf },
  { "xmm11", &builtin_type_v4sf },
  { "xmm12", &builtin_type_v4sf },
  { "xmm13", &builtin_type_v4sf },
  { "xmm14", &builtin_type_v4sf },
  { "xmm15", &builtin_type_v4sf },
  { "mxcsr", &builtin_type_int32 }
d134 7
a140 3
/* Total number of registers.  */
#define X86_64_NUM_REGS \
  (sizeof (x86_64_register_info) / sizeof (x86_64_register_info[0]))
d142 2
a143 2
/* Size of the register buffer.  */
static int x86_64_register_bytes;
d145 2
a146 1
/* Return the name of register REGNUM.  */
d148 7
a154 2
static const char *
x86_64_register_name (int regnum)
d156 2
a157 2
  if (regnum >= 0 && regnum < X86_64_NUM_REGS)
    return x86_64_register_info[regnum].name;
d159 10
a168 1
  return NULL;
d172 1
a172 2
   register REGNUM. */

d174 1
a174 1
x86_64_register_type (struct gdbarch *gdbarch, int regnum)
d176 2
a177 1
  gdb_assert (regnum >= 0 && regnum < X86_64_NUM_REGS);
d179 9
a187 1
  return *x86_64_register_info[regnum].type;
d190 7
a196 4
/* DWARF Register Number Mapping as defined in the System V psABI,
   section 3.6.  */

static int x86_64_dwarf_regmap[] =
d198 1
a198 3
  /* General Purpose Registers RAX, RDX, RCX, RBX, RSI, RDI.  */
  X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, 3, 2, 
  4, X86_64_RDI_REGNUM,
d200 16
a215 2
  /* Frame Pointer Register RBP.  */
  X86_64_RBP_REGNUM,
d217 3
a219 2
  /* Stack Pointer Register RSP.  */
  X86_64_RSP_REGNUM,
d221 8
a228 2
  /* Extended Integer Registers 8 - 15.  */
  8, 9, 10, 11, 12, 13, 14, 15,
d230 9
a238 2
  /* Return Address RA.  Not mapped.  */
  -1,
d240 2
a241 5
  /* SSE Registers 0 - 7.  */
  X86_64_XMM0_REGNUM + 0, X86_64_XMM1_REGNUM,
  X86_64_XMM0_REGNUM + 2, X86_64_XMM0_REGNUM + 3,
  X86_64_XMM0_REGNUM + 4, X86_64_XMM0_REGNUM + 5,
  X86_64_XMM0_REGNUM + 6, X86_64_XMM0_REGNUM + 7,
d243 2
a244 5
  /* Extended SSE Registers 8 - 15.  */
  X86_64_XMM0_REGNUM + 8, X86_64_XMM0_REGNUM + 9,
  X86_64_XMM0_REGNUM + 10, X86_64_XMM0_REGNUM + 11,
  X86_64_XMM0_REGNUM + 12, X86_64_XMM0_REGNUM + 13,
  X86_64_XMM0_REGNUM + 14, X86_64_XMM0_REGNUM + 15,
d246 4
a249 6
  /* Floating Point Registers 0-7.  */
  X86_64_ST0_REGNUM + 0, X86_64_ST0_REGNUM + 1,	
  X86_64_ST0_REGNUM + 2, X86_64_ST0_REGNUM + 3,
  X86_64_ST0_REGNUM + 4, X86_64_ST0_REGNUM + 5,
  X86_64_ST0_REGNUM + 6, X86_64_ST0_REGNUM + 7
};
d251 4
a254 2
static const int x86_64_dwarf_regmap_len =
  (sizeof (x86_64_dwarf_regmap) / sizeof (x86_64_dwarf_regmap[0]));
d256 2
a257 5
/* Convert DWARF register number REG to the appropriate register
   number used by GDB.  */

static int
x86_64_dwarf_reg_to_regnum (int reg)
d259 1
a259 9
  int regnum = -1;

  if (reg >= 0 || reg < x86_64_dwarf_regmap_len)
    regnum = x86_64_dwarf_regmap[reg];

  if (regnum == -1)
    warning ("Unmapped DWARF Register #%d encountered\n", reg);

  return regnum;
d264 3
a266 2
   Some types are returned in registers an some (big structures) in
   memory.  See the System V psABI for details.  */
d285 1
a285 1
   See the System V psABI for details.  */
d290 1
a290 1
  /* Rule (a): If both classes are equal, this is the resulting class.  */
d294 1
a294 1
  /* Rule (b): If one of the classes is NO_CLASS, the resulting class
d301 1
a301 1
  /* Rule (c): If one of the classes is MEMORY, the result is MEMORY.  */
d305 1
a305 1
  /* Rule (d): If one of the classes is INTEGER, the result is INTEGER.  */
d313 1
a313 2
  /* Rule (e): If one of the classes is X87 or X87UP class, MEMORY is
     used as class.  */
d318 1
a318 1
  /* Rule (f): Otherwise class SSE is used.  */
d328 1
a328 1
   See the System V psABI for details.  */
d536 1
a536 2

static int
d553 1
a553 1
static void
d564 2
a565 2
  int ret_int_r[RET_INT_REGS] = { X86_64_RAX_REGNUM, X86_64_RDX_REGNUM };
  int ret_sse_r[RET_SSE_REGS] = { X86_64_XMM0_REGNUM, X86_64_XMM1_REGNUM };
d572 1
a572 1
      regcache_cooked_read (regcache, X86_64_RAX_REGNUM, &addr);
d613 1
a613 1
	      regcache_cooked_read_part (regcache, X86_64_ST0_REGNUM,
d618 1
a618 1
	      regcache_cooked_read_part (regcache, X86_64_ST0_REGNUM,
d631 6
d638 1
a638 1
#define SSE_REGS 8
d640 3
a642 3
static CORE_ADDR
x86_64_push_arguments (struct regcache *regcache, int nargs,
		       struct value **args, CORE_ADDR sp)
d647 4
a650 5
  static int int_parameter_registers[INT_REGS] =
  {
    X86_64_RDI_REGNUM, 4,	/* %rdi, %rsi */
    X86_64_RDX_REGNUM, 2,	/* %rdx, %rcx */
    8, 9			/* %r8, %r9 */
d652 6
a657 7
  /* %xmm0 - %xmm7 */
  static int sse_parameter_registers[SSE_REGS] =
  {
    X86_64_XMM0_REGNUM + 0, X86_64_XMM1_REGNUM,
    X86_64_XMM0_REGNUM + 2, X86_64_XMM0_REGNUM + 3,
    X86_64_XMM0_REGNUM + 4, X86_64_XMM0_REGNUM + 5,
    X86_64_XMM0_REGNUM + 6, X86_64_XMM0_REGNUM + 7,
d687 3
a689 3
		  regcache_cooked_write
		    (regcache, int_parameter_registers[(intreg + 1) / 2],
		     VALUE_CONTENTS_ALL (args[i]) + offset);
d695 5
a699 4
		    LONGEST val = extract_signed_integer
		      (VALUE_CONTENTS_ALL (args[i]) + offset, 4);
		    regcache_cooked_write_signed
		      (regcache, int_parameter_registers[intreg / 2], val);
d708 3
a710 3
		  regcache_cooked_write
		    (regcache, sse_parameter_registers[(ssereg + 1) / 2],
		     VALUE_CONTENTS_ALL (args[i]) + offset);
d715 2
a716 3
		  regcache_cooked_write
		    (regcache, sse_parameter_registers[ssereg / 2],
		     VALUE_CONTENTS_ALL (args[i]) + offset);
a734 2

  /* Push any remaining arguments onto the stack.  */
d739 3
a741 3

      /* Make sure the stack stays eightbyte-aligned.  */
      sp -= (len + 7) & ~7;
a743 1

d749 1
a749 2

static void
d757 11
a767 2
      ULONGEST fstat;
      char buf[FPU_REG_RAW_SIZE];
d769 9
a777 23
      /* Returning floating-point values is a bit tricky.  Apart from
         storing the return value in %st(0), we have to simulate the
         state of the FPU at function return point.  */

      /* Convert the value found in VALBUF to the extended
	 floating-point format used by the FPU.  This is probably
	 not exactly how it would happen on the target itself, but
	 it is the best we can do.  */
      convert_typed_floating (valbuf, type, buf, builtin_type_i387_ext);
      regcache_raw_write (regcache, X86_64_ST0_REGNUM, buf);

      /* Set the top of the floating-point register stack to 7.  The
         actual value doesn't really matter, but 7 is what a normal
         function return would end up with if the program started out
         with a freshly initialized FPU.  */
      regcache_raw_read_unsigned (regcache, FSTAT_REGNUM, &fstat);
      fstat |= (7 << 11);
      regcache_raw_write_unsigned (regcache, FSTAT_REGNUM, fstat);

      /* Mark %st(1) through %st(7) as empty.  Since we set the top of
         the floating-point register stack to 7, the appropriate value
         for the tag word is 0x3fff.  */
      regcache_raw_write_unsigned (regcache, FTAG_REGNUM, 0x3fff);
d800 2
a801 4
static CORE_ADDR
x86_64_push_dummy_call (struct gdbarch *gdbarch, struct regcache *regcache,
			CORE_ADDR dummy_addr, int nargs, struct value **args,
			CORE_ADDR sp, int struct_return, CORE_ADDR struct_addr)
d803 3
a805 25
  char buf[8];

  /* Pass arguments.  */
  sp = x86_64_push_arguments (regcache, nargs, args, sp);

  /* Pass "hidden" argument".  */
  if (struct_return)
    {
      store_address (buf, 8, struct_addr);
      regcache_cooked_write (regcache, X86_64_RDI_REGNUM, buf);
    }

  /* Store return address.  */
  sp -= 8;
  store_address (buf, 8, dummy_addr);
  write_memory (sp, buf, 8);

  /* Finally, update the stack pointer...  */
  store_address (buf, 8, sp);
  regcache_cooked_write (regcache, X86_64_RSP_REGNUM, buf);

  /* ...and fake a frame pointer.  */
  regcache_cooked_write (regcache, X86_64_RBP_REGNUM, buf);

  return sp;
a806 1

d808 2
a809 4
/* The maximum number of saved registers.  This should include %rip.  */
#define X86_64_NUM_SAVED_REGS	17

struct x86_64_frame_cache
d811 1
a811 20
  /* Base address.  */
  CORE_ADDR base;
  CORE_ADDR sp_offset;
  CORE_ADDR pc;

  /* Saved registers.  */
  CORE_ADDR saved_regs[X86_64_NUM_SAVED_REGS];
  CORE_ADDR saved_sp;

  /* Do we have a frame?  */
  int frameless_p;
};

/* Allocate and initialize a frame cache.  */

static struct x86_64_frame_cache *
x86_64_alloc_frame_cache (void)
{
  struct x86_64_frame_cache *cache;
  int i;
d813 4
a816 17
  cache = FRAME_OBSTACK_ZALLOC (struct x86_64_frame_cache);

  /* Base address.  */
  cache->base = 0;
  cache->sp_offset = -8;
  cache->pc = 0;

  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where %rbp is supposed to be stored).  */
  for (i = 0; i < X86_64_NUM_SAVED_REGS; i++)
    cache->saved_regs[i] = -1;
  cache->saved_sp = 0;

  /* Frameless until proven otherwise.  */
  cache->frameless_p = 1;

  return cache;
d818 1
d820 4
a823 15
/* Do a limited analysis of the prologue at PC and update CACHE
   accordingly.  Bail out early if CURRENT_PC is reached.  Return the
   address where the analysis stopped.

   We will handle only functions beginning with:

      pushq %rbp        0x55
      movq %rsp, %rbp   0x48 0x89 0xe5

   Any function that doesn't start with this sequence will be assumed
   to have no prologue and thus no valid frame pointer in %rbp.  */

static CORE_ADDR
x86_64_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
			 struct x86_64_frame_cache *cache)
d825 1
a825 31
  static unsigned char proto[3] = { 0x48, 0x89, 0xe5 };
  unsigned char buf[3];
  unsigned char op;

  if (current_pc <= pc)
    return current_pc;

  op = read_memory_unsigned_integer (pc, 1);

  if (op == 0x55)		/* pushq %rbp */
    {
      /* Take into account that we've executed the `pushq %rbp' that
         starts this instruction sequence.  */
      cache->saved_regs[X86_64_RBP_REGNUM] = 0;
      cache->sp_offset += 8;

      /* If that's all, return now.  */
      if (current_pc <= pc + 1)
        return current_pc;

      /* Check for `movq %rsp, %rbp'.  */
      read_memory (pc + 1, buf, 3);
      if (memcmp (buf, proto, 3) != 0)
	return pc + 1;

      /* OK, we actually have a frame.  */
      cache->frameless_p = 0;
      return pc + 4;
    }

  return pc;
d828 2
a829 4
/* Return PC of first real instruction.  */

static CORE_ADDR
x86_64_skip_prologue (CORE_ADDR start_pc)
d831 1
a831 8
  struct x86_64_frame_cache cache;
  CORE_ADDR pc;

  pc = x86_64_analyze_prologue (start_pc, 0xffffffffffffffff, &cache);
  if (cache.frameless_p)
    return start_pc;

  return pc;
a832 1

d834 9
a842 4
/* Normal frames.  */

static struct x86_64_frame_cache *
x86_64_frame_cache (struct frame_info *next_frame, void **this_cache)
a843 2
  struct x86_64_frame_cache *cache;
  char buf[8];
d845 2
d848 1
a848 2
  if (*this_cache)
    return *this_cache;
d850 6
a855 39
  cache = x86_64_alloc_frame_cache ();

  frame_unwind_register (next_frame, X86_64_RBP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 8);
  if (cache->base == 0)
    return cache;

  /* For normal frames, %rip is stored at 8(%rbp).  */
  cache->saved_regs[X86_64_RIP_REGNUM] = 8;

  cache->pc = frame_func_unwind (next_frame);
  if (cache->pc != 0)
    x86_64_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);

  if (cache->frameless_p)
    {
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  If
	 we're at the start of a function, or somewhere half-way its
	 prologue, the function's frame probably hasn't been fully
	 setup yet.  Try to reconstruct the base address for the stack
	 frame by looking at the stack pointer.  For truly "frameless"
	 functions this might work too.  */

      frame_unwind_register (next_frame, X86_64_RSP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 8) + cache->sp_offset;
    }

  /* Now that we have the base address for the stack frame we can
     calculate the value of %rsp in the calling frame.  */
  cache->saved_sp = cache->base + 16;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < X86_64_NUM_SAVED_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] += cache->base;

  return cache;
d858 3
a860 10
static void
x86_64_frame_this_id (struct frame_info *next_frame, void **this_cache,
		      struct frame_id *this_id)
{
  struct x86_64_frame_cache *cache =
    x86_64_frame_cache (next_frame, this_cache);

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;
d862 2
a863 12
  /* This is meant to halt the backtrace at "_start".  */
  if (inside_entry_file (cache->pc))
    return;

  (*this_id) = frame_id_build (cache->base, cache->pc);
}

static void
x86_64_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			    int regnum, int *optimizedp,
			    enum lval_type *lvalp, CORE_ADDR *addrp,
			    int *realnump, void *valuep)
d865 29
a893 2
  struct x86_64_frame_cache *cache =
    x86_64_frame_cache (next_frame, this_cache);
d895 1
a895 87
  gdb_assert (regnum >= 0);

  if (regnum == SP_REGNUM && cache->saved_sp)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* Store the value.  */
	  store_address (valuep, 8, cache->saved_sp);
	}
      return;
    }

  if (regnum < X86_64_NUM_SAVED_REGS && cache->saved_regs[regnum] != -1)
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
	}
      return;
    }

  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind x86_64_frame_unwind =
{
  NORMAL_FRAME,
  x86_64_frame_this_id,
  x86_64_frame_prev_register
};

static const struct frame_unwind *
x86_64_frame_p (CORE_ADDR pc)
{
  return &x86_64_frame_unwind;
}


/* Signal trampolines.  */

/* FIXME: kettenis/20030419: Perhaps, we can unify the 32-bit and
   64-bit variants.  This would require using identical frame caches
   on both platforms.  */

static struct x86_64_frame_cache *
x86_64_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct x86_64_frame_cache *cache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  CORE_ADDR addr;
  char buf[8];

  if (*this_cache)
    return *this_cache;

  cache = x86_64_alloc_frame_cache ();

  frame_unwind_register (next_frame, X86_64_RSP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 8) - 8;

  addr = tdep->sigcontext_addr (next_frame);
  cache->saved_regs[X86_64_RIP_REGNUM] = addr + tdep->sc_pc_offset;
  cache->saved_regs[X86_64_RSP_REGNUM] = addr + tdep->sc_sp_offset;

  *this_cache = cache;
  return cache;
}

static void
x86_64_sigtramp_frame_this_id (struct frame_info *next_frame,
			       void **this_cache, struct frame_id *this_id)
{
  struct x86_64_frame_cache *cache =
    x86_64_sigtramp_frame_cache (next_frame, this_cache);

  (*this_id) = frame_id_build (cache->base, frame_pc_unwind (next_frame));
a898 51
x86_64_sigtramp_frame_prev_register (struct frame_info *next_frame,
				     void **this_cache,
				     int regnum, int *optimizedp,
				     enum lval_type *lvalp, CORE_ADDR *addrp,
				     int *realnump, void *valuep)
{
  /* Make sure we've initialized the cache.  */
  x86_64_sigtramp_frame_cache (next_frame, this_cache);

  x86_64_frame_prev_register (next_frame, this_cache, regnum,
			      optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind x86_64_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  x86_64_sigtramp_frame_this_id,
  x86_64_sigtramp_frame_prev_register
};

static const struct frame_unwind *
x86_64_sigtramp_frame_p (CORE_ADDR pc)
{
  char *name;

  find_pc_partial_function (pc, &name, NULL, NULL);
  if (PC_IN_SIGTRAMP (pc, name))
    return &x86_64_sigtramp_frame_unwind;

  return NULL;
}


static CORE_ADDR
x86_64_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct x86_64_frame_cache *cache =
    x86_64_frame_cache (next_frame, this_cache);

  return cache->base;
}

static const struct frame_base x86_64_frame_base =
{
  &x86_64_frame_unwind,
  x86_64_frame_base_address,
  x86_64_frame_base_address,
  x86_64_frame_base_address
};

static void
d901 4
a904 1
  generic_save_dummy_frame_tos (sp + 16);
d908 1
a908 1
x86_64_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d910 3
a912 7
  char buf[8];
  CORE_ADDR fp;

  frame_unwind_register (next_frame, X86_64_RBP_REGNUM, buf);
  fp = extract_unsigned_integer (buf, 8);

  return frame_id_build (fp, frame_pc_unwind (next_frame));
a934 4
  set_gdbarch_register_bytes (gdbarch, x86_64_register_bytes);
  set_gdbarch_register_name (gdbarch, x86_64_register_name);
  set_gdbarch_register_size (gdbarch, 8);
  set_gdbarch_register_type (gdbarch, x86_64_register_type);
d937 5
a941 4
  set_gdbarch_sp_regnum (gdbarch, X86_64_RSP_REGNUM); /* %rsp */
  set_gdbarch_pc_regnum (gdbarch, X86_64_RIP_REGNUM); /* %rip */
  set_gdbarch_ps_regnum (gdbarch, X86_64_EFLAGS_REGNUM); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, X86_64_ST0_REGNUM); /* %st(0) */
d944 8
a951 8
     referred to as the "DWARF Register Number Mapping" in the System
     V psABI.  The preferred debugging format for all known x86-64
     targets is actually DWARF2, and GCC doesn't seem to support DWARF
     (that is DWARF-1), but we provide the same mapping just in case.
     This mapping is also used for stabs, which GCC does support.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, x86_64_dwarf_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, x86_64_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, x86_64_dwarf_reg_to_regnum);
d953 2
a954 2
  /* We don't override SDB_REG_RO_REGNUM, since COFF doesn't seem to
     be in use on any of the supported x86-64 targets.  */
d956 25
a980 2
  /* Call dummy code.  */
  set_gdbarch_push_dummy_call (gdbarch, x86_64_push_dummy_call);
d983 5
d993 1
d996 11
a1006 1
  /* Avoid wiring in the MMX registers for now.  */
d1009 11
a1019 2
  set_gdbarch_unwind_dummy_id (gdbarch, x86_64_unwind_dummy_id);
  set_gdbarch_save_dummy_frame_tos (gdbarch, x86_64_save_dummy_frame_tos);
d1025 4
a1028 4

  frame_unwind_append_predicate (gdbarch, x86_64_sigtramp_frame_p);
  frame_unwind_append_predicate (gdbarch, x86_64_frame_p);
  frame_base_set_default (gdbarch, &x86_64_frame_base);
d1034 4
a1037 1
  int i;
d1039 7
a1045 47
  /* Total amount of space needed to store our copies of the machine's
     registers.  */
  for (i = 0; i < X86_64_NUM_REGS; i++)
    x86_64_register_bytes += TYPE_LENGTH (*x86_64_register_info[i].type);
}


#define I387_FISEG_REGNUM FISEG_REGNUM
#define I387_FOSEG_REGNUM FOSEG_REGNUM

/* The 64-bit FXSAVE format differs from the 32-bit format in the
   sense that the instruction pointer and data pointer are simply
   64-bit offsets into the code segment and the data segment instead
   of a selector offset pair.  The functions below store the upper 32
   bits of these pointers (instead of just the 16-bits of the segment
   selector).  */

/* Fill GDB's register array with the floating-point and SSE register
   values in *FXSAVE.  This function masks off any of the reserved
   bits in *FXSAVE.  */

void
x86_64_supply_fxsave (char *fxsave)
{
  i387_supply_fxsave (fxsave);

  if (fxsave)
    {
      supply_register (I387_FISEG_REGNUM, fxsave + 12);
      supply_register (I387_FOSEG_REGNUM, fxsave + 20);
    }
}

/* Fill register REGNUM (if it is a floating-point or SSE register) in
   *FXSAVE with the value in GDB's register array.  If REGNUM is -1, do
   this for all registers.  This function doesn't touch any of the
   reserved bits in *FXSAVE.  */

void
x86_64_fill_fxsave (char *fxsave, int regnum)
{
  i387_fill_fxsave (fxsave, regnum);

  if (regnum == -1 || regnum == I387_FISEG_REGNUM)
    regcache_collect (regnum, fxsave + 12);
  if (regnum == -1 || regnum == I387_FOSEG_REGNUM)
    regcache_collect (regnum, fxsave + 20);
@


1.67.2.3
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d131 3
d773 1
a773 1
      store_unsigned_integer (buf, 8, struct_addr);
d779 1
a779 1
  store_unsigned_integer (buf, 8, dummy_addr);
d783 1
a783 1
  store_unsigned_integer (buf, 8, sp);
d994 1
a994 1
	  store_unsigned_integer (valuep, 8, cache->saved_sp);
d1161 1
d1163 1
d1210 11
@


1.67.2.4
log
@* x86-64-tdep.c (x86_64_frame_cache): Don't throw away the newly
created cache.
@
text
@a912 1
  *this_cache = cache;
@


1.67.2.5
log
@* x86-64-tdep.c (x86_64_frame_this_id,
x86_64_sigtramp_frame_this_id, x86_64_unwind_dummy_id): Add offset
to the frame base such that we use the same defenition for the top
of stack as DWARF CFI does.
@
text
@d969 1
a969 1
  (*this_id) = frame_id_build (cache->base + 16, cache->pc);
d1067 1
a1067 1
  (*this_id) = frame_id_build (cache->base + 16, frame_pc_unwind (next_frame));
d1136 1
a1136 1
  return frame_id_build (fp + 16, frame_pc_unwind (next_frame));
@


1.67.2.6
log
@* i386-tdep.c (i386_frame_this_id): Remove inside_entry_file
check.  The majority of i386 targets shouldn't need this, and it
hurts Cygwin.
* x86-64-tdep.c (x86_64_frame_this_id): Likewise.
@
text
@d965 4
@


1.66
log
@* x86-64-tdep.c (gdb_print_insn_x86_64): Removed.
@
text
@a242 11
/* This is the variable that is set with "set disassembly-flavour", and
   its legitimate values.  */
static const char att_flavour[] = "att";
static const char intel_flavour[] = "intel";
static const char *valid_flavours[] = {
  att_flavour,
  intel_flavour,
  NULL
};
static const char *disassembly_flavour = att_flavour;

@


1.65
log
@* x86-64-tdep.c (x86_64_breakpoint_from_pc): Removed.
@
text
@a830 17

/* We have two flavours of disassembly.  The machinery on this page
   deals with switching between those.  */

static int
gdb_print_insn_x86_64 (bfd_vma memaddr, disassemble_info * info)
{
  if (disassembly_flavour == att_flavour)
    return print_insn_i386_att (memaddr, info);
  else if (disassembly_flavour == intel_flavour)
    return print_insn_i386_intel (memaddr, info);
  /* Never reached -- disassembly_flavour is always either att_flavour
     or intel_flavour.  */
  internal_error (__FILE__, __LINE__, "failed internal consistency check");
}


@


1.64
log
@2003-04-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_SAVED_PC_AFTER_CALL): Deprecate
	SAVED_PC_AFTER_CALL.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_saved_pc_after_call): Update declaration.
	* i386ly-tdep.c (i386lynx_init_abi): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	* infrun.c (step_over_function): Update.
	* i386-linux-tdep.c (skip_hurd_resolver): Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	* arm-linux-tdep.c (skip_hurd_resolver): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	* x86-64-tdep.h (x86_64_linux_saved_pc_after_call): Update
	declaration.
@
text
@a925 9
/* Sequence of bytes for breakpoint instruction.  */
static const unsigned char *
x86_64_breakpoint_from_pc (CORE_ADDR *pc, int *lenptr)
{
  static unsigned char breakpoint[] = { 0xcc };
  *lenptr = 1;
  return breakpoint;
}

@


1.63
log
@2003-04-09  Andrew Cagney  <cagney@@redhat.com>

	* doublest.h: Update copyright.
	(deprecated_store_floating, deprecated_extract_floating): Rename
	store_floating and extract_floating.  Update comments.
	* doublest.c: Update copyright.
	(extract_floating_by_length): Replace extract_floating.
	(store_floating_by_length): Replace store_floating.
	(deprecated_extract_floating): New function.
	(deprecated_store_floating): New function.
	(extract_typed_floating): Call extract_floating_by_length.
	(store_typed_floating): Call store_floating_by_length.
	* x86-64-tdep.c (x86_64_store_return_value): Update.
	* sh-tdep.c (sh3e_sh4_extract_return_value): Update.
	(sh64_extract_return_value): Update.
	(sh_sh4_register_convert_to_virtual): Update.
	(sh_sh64_register_convert_to_virtual): Update.
	(sh_sh4_register_convert_to_raw): Update.
	(sh_sh64_register_convert_to_raw): Update.
	* rs6000-tdep.c (rs6000_register_convert_to_virtual): Update.
	(rs6000_register_convert_to_raw): Update.
	* ia64-tdep.c (ia64_register_convert_to_virtual): Update.
	(ia64_register_convert_to_raw): Update.
	* config/i386/tm-symmetry.h (REGISTER_CONVERT_TO_RAW): Update.
	(REGISTER_CONVERT_TO_VIRTUAL): Update.
	* arm-linux-tdep.c (arm_linux_push_arguments): Update.
	* alpha-tdep.c (alpha_register_convert_to_virtual): Update.
	(alpha_register_convert_to_raw): Update.
@
text
@d1039 1
a1039 1
  set_gdbarch_saved_pc_after_call (gdbarch, x86_64_linux_saved_pc_after_call);
@


1.62
log
@2003-04-04  Andrew Cagney  <cagney@@redhat.com>

	* x86-64-tdep.c (x86_64_unwind_dummy_id): Use frame_id_build.
	* dummy-frame.c (dummy_frame_this_id): Use frame_id_build.
	* d10v-tdep.c (d10v_frame_this_id): Use get_frame_pc and
	get_frame_base.
	(d10v_unwind_dummy_id): Use frame_id_build.
	* frame.c (find_frame_sal): Use get_frame_pc.
	(create_new_frame): Use deprecated_update_frame_pc_hack and
	deprecated_update_frame_base_hack.
	(create_sentinel_frame): Add comment about ->pc going away.
	(get_prev_frame): Add comment about ->pc going away.
	(legacy_get_prev_frame): Use get_frame_base, get_frame_pc,
	frame_id_build, deprecated_update_frame_pc_hack and
	deprecated_update_frame_base_hack.
	(select_frame): Use get_frame_pc.
	(legacy_saved_regs_this_id): Use frame_id_build.
@
text
@d784 1
a784 1
	  val = extract_floating (valbuf, TYPE_LENGTH (type));
@


1.61
log
@2003-04-04  Elena Zannoni  <ezannoni@@redhat.com>

        * x86-64-tdep.c (x86_64_push_arguments): Handle correctly the
        signed integer case.
        (classify_argument): Handle enumerations and references.
@
text
@d947 3
a949 6
  struct frame_id id;
  
  id.pc = frame_pc_unwind (frame);
  frame_unwind_unsigned_register (frame, SP_REGNUM, &id.base);

  return id;
@


1.60
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_RETURN_ADDRESS): Replace
	PUSH_RETURN_ADDRESS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* valops.c (hand_function_call): Update.
@
text
@d474 2
d705 11
a715 5
		  deprecated_write_register_gen (int_parameter_registers[intreg / 2],
						 VALUE_CONTENTS_ALL (args[i]) + offset);
		  offset += 8;
		  intreg++;
		  break;
@


1.60.2.1
log
@Merge with mainline.
@
text
@a473 2
    case TYPE_CODE_ENUM:
    case TYPE_CODE_REF:
d703 5
a707 11
		  {
		    LONGEST num
		      = extract_signed_integer (VALUE_CONTENTS_ALL (args[i])
						+ offset, 4);
		    regcache_raw_write_signed (current_regcache,
					       int_parameter_registers[intreg / 2],                                           num);

		    offset += 8;
		    intreg++;
		    break;
		  }
d776 1
a776 1
	  val = deprecated_extract_floating (valbuf, TYPE_LENGTH (type));
d939 6
a944 3
  CORE_ADDR base;
  frame_unwind_unsigned_register (frame, SP_REGNUM, &base);
  return frame_id_build (base, frame_pc_unwind (frame));
@


1.59
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_ARGUMENTS): Rename PUSH_ARGUMENTS.
	(push_dummy_call): New pure multi-arch replacement with gdbarch,
	regcache and dummy_addr parameters.
	* gdbarch.h, gdbarch.c: Re-generate.
	* valops.c (hand_function_call): Use gdbarch_push_dummy_call when
	available; assume it will handle stack alignment and return
	address issues.  Fall back to DEPRECATED_PUSH_ARGUMENTS and
	legacy_push_arguments.
	(legacy_push_arguments): Rename default_push_arguments.
	* value.h (legacy_push_arguments): Rename default_push_arguments.
	* i386-tdep.c (i386_push_arguments): Call legacy_push_arguments.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/i386/tm-symmetry.h: Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* arm-linux-tdep.c (arm_linux_init_abi): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	PUSH_ARGUMENTS with push_dummy_call, add gdbarch, regcache and
	dummy_addr parameters.
@
text
@d1017 1
a1017 1
  set_gdbarch_push_return_address (gdbarch, x86_64_push_return_address);
@


1.58
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STORE_STRUCT_RETURN): Replace
	STORE_STRUCT_RETURN.
	* gdbarch.h, gdbarch.c: Regenerate.
	* d10v-tdep.c (d10v_store_struct_return): Delete function.
	(d10v_push_arguments): Set the struct return register.
	(d10v_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d1016 1
a1016 1
  set_gdbarch_push_arguments (gdbarch, x86_64_push_arguments);
@


1.58.2.1
log
@Merge with mainline.
@
text
@d1016 2
a1017 2
  set_gdbarch_deprecated_push_arguments (gdbarch, x86_64_push_arguments);
  set_gdbarch_deprecated_push_return_address (gdbarch, x86_64_push_return_address);
@


1.57
log
@Index: ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_CHAIN): Replace FRAME_CHAIN.
	(DEPRECATED_FRAME_CHAIN_VALID): Replace FRAME_CHAIN_VALID.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update.
	* objfiles.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame, get_prev_frame, legacy_frame_p): Update.
	* dummy-frame.h: Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* config/m68k/tm-vx68.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-os68k.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-sun3.h: Update.
	* blockframe.c (inside_main_func, frame_chain_valid): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_frame_chain, sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	(rs6000_gdbarch_init, rs6000_frame_saved_pc): Update.
	(frame_get_saved_regs): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_frame_num_args, i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	(i386_interix_back_one_frame): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	(hppa_init_extra_frame_info): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Algorithms, Target Architecture Definition):
	Deprecate FRAME_CHAIN and FRAME_CHAIN_VALID.
@
text
@d1019 1
a1019 1
  set_gdbarch_store_struct_return (gdbarch, x86_64_store_struct_return);
@


1.56
log
@2003-03-14  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_GET_SAVED_REGISTER): Replace
	GET_SAVED_REGISTER.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.h: Update comments.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frame.c (frame_register): Update.
	(get_saved_register): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_GET_SAVED_REGISTER): Update.
@
text
@d1028 1
a1028 1
  set_gdbarch_frame_chain (gdbarch, x86_64_linux_frame_chain);
@


1.55
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_POP_FRAME): Replace POP_FRAME.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update comment.
	* stack.c (return_command): Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_POP_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_POP_FRAME): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	POP_FRAME with DEPRECATED_POP_FRAME.  Update description.
@
text
@d1009 1
a1009 1
  set_gdbarch_get_saved_register (gdbarch, cfi_get_saved_register);
@


1.54
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_SAVED_PC): Replace FRAME_SAVED_PC.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.h: Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* sh-tdep.c (sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Update.
	* xstormy16-tdep.c (xstormy16_pop_frame): Update.
	(xstormy16_frame_chain_valid): Update.
	* vax-tdep.c (vax_saved_pc_after_call): Update.
	* v850-tdep.c (v850_frame_chain): Update.
	(v850_pop_frame): Update.
	(v850_init_extra_frame_info): Update.
	* sparc-tdep.c (setup_arbitrary_frame): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* s390-tdep.c (s390_pop_frame_regular): Update.
	* mn10300-tdep.c (mn10300_frame_chain): Update.
	(mn10300_pop_frame_regular): Update.
	(mn10300_init_extra_frame_info): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	(mips_frame_chain): Update.
	(mips_pop_frame): Update.
	* mcore-tdep.c (mcore_frame_chain): Update.
	(mcore_pop_frame): Update.
	(mcore_init_extra_frame_info): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* m68k-tdep.c (isi_frame_num_args): Update.
	(delta68_frame_num_args): Update.
	(news_frame_num_args): Update.
	* ia64-tdep.c (ia64_pop_frame_regular): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	(alpha_frame_chain): Update.
	(alpha_pop_frame): Update.
	* hppa-tdep.c (hppa_saved_pc_after_call): Update.
	(hppa_init_extra_frame_info): Update.
	(hppa_frame_chain): Update.
	(hppa_frame_chain_valid): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_init_extra_frame_info): Update.
	* arm-tdep.c (arm_frame_chain_valid): Update.
	(arm_init_extra_frame_info): Update.
	(arm_pop_frame): Update.
	* frame.c (frame_pc_unwind): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_SAVED_PC): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-linux.h (DEPRECATED_FRAME_SAVED_PC): Update.

2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_SAVED_PC to DEPRECATED_FRAME_SAVED_PC.
@
text
@d1018 1
a1018 1
  set_gdbarch_pop_frame (gdbarch, x86_64_pop_frame);
@


1.53
log
@2002-03-07  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-tdep.c (x86_64_save_dummy_frame_tos)
	(x86_64_unwind_dummy_id): New functions.
	(x86_64_init_abi): Register these two new functions.
@
text
@d1033 1
a1033 1
  set_gdbarch_frame_saved_pc (gdbarch, x86_64_linux_frame_saved_pc);
@


1.53.2.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d1009 1
a1009 1
  set_gdbarch_deprecated_get_saved_register (gdbarch, cfi_get_saved_register);
d1018 1
a1018 1
  set_gdbarch_deprecated_pop_frame (gdbarch, x86_64_pop_frame);
d1033 1
a1033 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, x86_64_linux_frame_saved_pc);
@


1.52
log
@2003-03-07  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-tdep.c (x86_64_function_has_prologue): New function.
	(x86_64_skip_prologue): Move prologue detection to
	separate function.
	* x86-64-tdep.h (x86_64_function_has_prologue): New prototype.
@
text
@d927 20
d1057 4
@


1.51
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_INIT_SAVED_REGS): Rename
	FRAME_INIT_SAVED_REGS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* stack.c (frame_info): Update.
	* sh-tdep.c (sh_find_callers_reg, sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info, sh64_init_extra_frame_info): Update.
	(sh64_get_saved_register, sh_pop_frame, sh64_pop_frame): Update.
	* ns32k-tdep.c (ns32k_pop_frame): Update.
	* mips-tdep.c (mips_pop_frame): Update.
	* m68hc11-tdep.c (m68hc11_pop_frame): Update.
	* ia64-tdep.c (ia64_frame_chain): Update.
	(ia64_frame_saved_pc, ia64_get_saved_register): Update.
	(ia64_frameless_function_invocation): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_pop_frame_regular): Update.
	* frame.h (struct frame_info): Update comment.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Rename macro.
	* frame.c (frame_saved_regs_register_unwind): Update.
	(frame_saved_regs_register_unwind): Update.
	(deprecated_generic_get_saved_register): Update.
	* cris-tdep.c: Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_INIT_SAVED_REGS):
	Rename macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_INIT_SAVED_REGS to DEPRECATED_FRAME_INIT_SAVED_REGS.
@
text
@d854 24
a881 1
#define PROLOG_BUFSIZE 4
a888 1
  unsigned char prolog_buf[PROLOG_BUFSIZE];
d890 2
a891 13
  /* We will handle only functions starting with: */
  static unsigned char prolog_expect[PROLOG_BUFSIZE] =
  {
    0x55,			/* pushq %rbp */
    0x48, 0x89, 0xe5		/* movq %rsp, %rbp */
  };

  read_memory (pc, (char *) prolog_buf, PROLOG_BUFSIZE);

  /* First check, whether pc points to pushq %rbp, movq %rsp, %rbp.  */
  for (i = 0; i < PROLOG_BUFSIZE; i++)
    if (prolog_expect[i] != prolog_buf[i])
      return pc;		/* ... no, it doesn't.  Nothing to skip.  */
@


1.50
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename
	INIT_EXTRA_FRAME_INFO.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-tdep.c: Update comments.
	* sh-tdep.c, mcore-tdep.c, m68hc11-tdep.c: Ditto.
	* i386-interix-tdep.c, hppa-tdep.c, h8300-tdep.c: Ditto.
	* frame.h, avr-tdep.c: Ditto.
	* frame.c (get_prev_frame): DEPRECATED_INIT_EXTRA_FRAME_INFO.
	(create_new_frame, legacy_get_prev_frame): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* config/pa/tm-hppa.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Initialize
	deprecated_init_extra_frame_info instead of init_extra_frame_info.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.

Index: doc/ChangeLog
2003-02-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo: Rename INIT_EXTRA_FRAME_INFO to
	DEPRECATED_INIT_EXTRA_FRAME_INFO.
@
text
@d994 1
a994 1
  set_gdbarch_frame_init_saved_regs (gdbarch, x86_64_frame_init_saved_regs);
@


1.49
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d1014 1
a1014 1
  set_gdbarch_init_extra_frame_info (gdbarch, cfi_init_extra_frame_info);
@


1.48
log
@2003-02-12  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-tdep.c (x86_64_extract_return_value)
	(x86_64_store_return_value): Use regcache instead of regbuf.
	(x86_64_gdbarch_init): Change related set_gdbarch_* functions.
	* x86-64-linux-nat.c (fill_gregset): Use regcache.
@
text
@d34 1
@


1.47
log
@* x86-64-tdep.c (x86_64_init_abi): Set extract_return_value to
legacy_extract_return_value and store_return_value to
legacy_return_value.
@
text
@d562 2
a563 1
x86_64_extract_return_value (struct type *type, char *regbuf, char *valbuf)
d580 1
a580 1
      memcpy (&addr, regbuf, REGISTER_RAW_SIZE (RAX_REGNUM));
d594 2
a595 3
	      memcpy (valbuf + offset,
		      regbuf + REGISTER_BYTE (ret_int_r[(intreg + 1) / 2]),
		      8);
d600 2
a601 2
	      memcpy (valbuf + offset,
		      regbuf + REGISTER_BYTE (ret_int_r[intreg / 2]), 4);
d608 3
a610 3
	      memcpy (valbuf + offset,
		      regbuf + REGISTER_BYTE (ret_sse_r[(ssereg + 1) / 2]),
		      8);
d615 2
a616 2
	      memcpy (valbuf + offset + 8,
		      regbuf + REGISTER_BYTE (ret_sse_r[ssereg / 2]), 8);
d621 2
a622 2
	      memcpy (valbuf + offset, regbuf + REGISTER_BYTE (FP0_REGNUM),
		      8);
d626 2
a627 2
	      memcpy (valbuf + offset,
		      regbuf + REGISTER_BYTE (FP0_REGNUM) + 8, 8);
d752 2
a753 1
x86_64_store_return_value (struct type *type, char *valbuf)
d764 1
a764 2
	  deprecated_write_register_bytes (REGISTER_BYTE (FP0_REGNUM), valbuf,
					   FPU_REG_RAW_SIZE);
d777 2
a778 2
	  deprecated_write_register_bytes (REGISTER_BYTE (FP0_REGNUM), buf,
					   FPU_REG_RAW_SIZE);
d787 1
a787 1
	deprecated_write_register_bytes (REGISTER_BYTE (0), valbuf, len);
d790 4
a793 4
	  deprecated_write_register_bytes (REGISTER_BYTE (0), valbuf,
					   low_size);
	  deprecated_write_register_bytes (REGISTER_BYTE (1),
					   valbuf + low_size, len - low_size);
d982 2
a983 4
  /* FIXME: kettenis/20021026: Should be undeprecated.  */
  set_gdbarch_extract_return_value (gdbarch, legacy_extract_return_value);
  set_gdbarch_deprecated_extract_return_value (gdbarch,
					       x86_64_extract_return_value);
d988 1
a988 4
  /* FIXME: kettenis/20021026: Should be undeprecated.  */
  set_gdbarch_store_return_value (gdbarch, legacy_store_return_value);
  set_gdbarch_deprecated_store_return_value (gdbarch,
					     x86_64_store_return_value);
@


1.46
log
@* i386-tdep.c (i386_get_longjmp_target): Make usable on x86-64.
* x86-64-tdep.c (x86_64_init_abi): Remove FIXME about
i386_get_longjmp_target.
@
text
@d983 1
a983 1
  set_gdbarch_extract_return_value (gdbarch, NULL);
d991 1
a991 1
  set_gdbarch_store_return_value (gdbarch, NULL);
@


1.45
log
@	* arm-tdep.c (arm_frame_chain_valid):  Remove unnecessary test.
	* d10v-tdep.c (d10v_frame_chain_valid): Remove unnecessary tests.
	* hppa-tdep.c (hppa_frame_chain_valid): Remove unnecessary test.

	* blockframe.c: Include "gdbcmd.h" and "command.h".
	(backtrace_below_main): New variable.
	(file_frame_chain_valid, func_frame_chain_valid)
	(nonnull_frame_chain_valid, generic_file_frame_chain_valid)
	(generic_func_frame_chain_valid): Remove functions.
	(frame_chain_valid, do_flush_frames_sfunc): New functions.
	(_initialize_blockframe): New function.
	* Makefile.in (blockframe.o): Update dependencies.
	* frame.c (frame_saved_regs_id_unwind, get_prev_frame): Remove FIXME
	comment.  Call frame_chain_valid ().
	* frame.h: Remove old prototypes.  Add prototype for
	frame_chain_valid and update comments to match.
	* gdbarch.sh: Change FRAME_CHAIN_VALID into a predicated function.
	Remove old comment.
	* gdbarch.h: Regenerated.
	* gdbarch.c: Regenerated.

Plus updates to all other targets not to provide a FRAME_CHAIN_VALID.
@
text
@a969 4
  /* FIXME: kettenis/20021026: As long as we don't support longjmp,
     that is, as long as we have `tdep->jb_pc_offset == -1', using
     i386_get_longjmp_target is fine.  */

@


1.44
log
@* x86-64-tdep.h (x86_64_init_abi): New prototype.
* x86-64-tdep.c (i386_fp_regnum_p): Remove function.
(x86_64_init_abi): Make non-static.  Set number of pseudo
registers to 0.
(x86_64_gdbarch_init): Remove function.
(_initialize_x86_64_tdep): Renove register_gdbarch_init call.
Remove code dealing with dissambly.
* x86-64-linux-tdep.c (x86_64_linux_init_abi): New function.
(_initialize_x86_64_linux_tdep): New function.
* config/i386/x86-64linux.mt (TDEPFILES): Add i386-tdep.o and
i386-tdep.o.
@
text
@d3 1
a3 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
a1007 3
  /* FIXME: kettenis/20021025: Shouldn't this be set to
     generic_file_frame_chain_valid?  */
  set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
@


1.43
log
@2002-12-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
	Change to a function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Update.  Test
	DEPRECATED_INIT_FRAME_PC_P.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/mn10200/tm-mn10200.h (DEPRECATED_INIT_FRAME_PC): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* arm-tdep.c: Update comments.
	* h8300-tdep.c (h8300_gdbarch_init): Explicitly set init_frame_pc.
	* config/m32r/tm-m32r.h (DEPRECATED_INIT_FRAME_PC): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC_FIRST): Delete macro.
	(DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
@
text
@a177 9
/* FIXME: cagney/2002-11-11: Once the i386 and x86-64 targets are
   merged, this function can go away.  */
int
i386_fp_regnum_p (int regnum)
{
  return (regnum < NUM_REGS
	  && (FP0_REGNUM && FP0_REGNUM <= (regnum) && (regnum) < FPC_REGNUM));
}

d915 1
a915 1
static void
d1019 2
a1038 70
static struct gdbarch *
x86_64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;

  /* Try to determine the OS ABI of the object we're loading.  */
  if (info.abfd != NULL)
    osabi = gdbarch_lookup_osabi (info.abfd);

  /* Find a candidate among extant architectures.  */
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      /* Make sure the OS ABI selection matches.  */
      tdep = gdbarch_tdep (arches->gdbarch);
      if (tdep && tdep->osabi == osabi)
        return arches->gdbarch;
    }

  /* Allocate space for the new architecture.  */
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  tdep->osabi = osabi;

  /* FIXME: kettenis/20021025: The following calls are going to
     disappear when we integrate the x86_64 target into the i386
     target.  */

  set_gdbarch_long_double_format (gdbarch, &floatformat_i387_ext);

  set_gdbarch_max_register_raw_size (gdbarch, 16);
  set_gdbarch_max_register_virtual_size (gdbarch, 16);

  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);

  set_gdbarch_breakpoint_from_pc (gdbarch, x86_64_breakpoint_from_pc);
  set_gdbarch_decr_pc_after_break (gdbarch, 1);
  set_gdbarch_function_start_offset (gdbarch, 0);

  set_gdbarch_frame_args_skip (gdbarch, 8);

  set_gdbarch_call_dummy_address (gdbarch, entry_point_address);
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
  set_gdbarch_call_dummy_length (gdbarch, 0);
  set_gdbarch_call_dummy_p (gdbarch, 1);
  set_gdbarch_call_dummy_words (gdbarch, NULL);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, 0);
  set_gdbarch_fix_call_dummy (gdbarch, generic_fix_call_dummy);
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);

  set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);

  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);

  /* FIXME: kettenis/20021025: These already are the default.  */

  set_gdbarch_register_virtual_size (gdbarch, generic_register_size);
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, 0);

  x86_64_init_abi (info, gdbarch);

  return gdbarch;
}

a1041 2
  register_gdbarch_init (bfd_arch_i386, x86_64_gdbarch_init);

a1052 14
  }

  tm_print_insn = gdb_print_insn_x86_64;
  tm_print_insn_info.mach = bfd_mach_x86_64;

  /* Add the variable that controls the disassembly flavour.  */
  {
    struct cmd_list_element *new_cmd;

    new_cmd = add_set_enum_cmd ("disassembly-flavour", no_class,
				valid_flavours, &disassembly_flavour, "\
Set the disassembly flavour, the valid values are \"att\" and \"intel\", \
and the default value is \"att\".", &setlist);
    add_show_from_set (new_cmd, &showlist);
@


1.42
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d1035 1
a1035 1
  set_gdbarch_init_frame_pc (gdbarch, x86_64_init_frame_pc);
@


1.41
log
@2002-11-27  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_LOCATION): Default to AT_ENTRY_POINT.
	(USE_GENERIC_DUMMY_FRAMES): Default to true.
	(PC_IN_CALL_DUMMY): Default to generic_pc_in_call_dummy.
	* gdbarch.c, gdbarch.h: Re-generate.
	* inferior.h (USE_GENERIC_DUMMY_FRAMES): Delete macro definition.
	(CALL_DUMMY_LOCATION): Delete macro definition.
	(PC_IN_CALL_DUMMY): Delete macro definitions.

	* arm-tdep.c (arm_gdbarch_init): Do not set pc_in_call_dummy,
	default is already generic_pc_in_call_dummy.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* arm-tdep.c (arm_gdbarch_init): Do not set
	use_generic_dummy_frames, default is already 1.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_location, default is already AT_ENTRY_POINT.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d1102 1
a1102 1
  set_gdbarch_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);
@


1.40
log
@2002-11-26  Andrew Cagney  <ac131313@@redhat.com>

	* inferior.h (deprecated_pc_in_call_dummy_before_text_end): Rename
	pc_in_call_dummy_before_text_end
	(deprecated_pc_in_call_dummy_after_text_end): Rename
	pc_in_call_dummy_after_text_end.
	(deprecated_pc_in_call_dummy_on_stack): Rename
	pc_in_call_dummy_on_stack.
	(deprecated_pc_in_call_dummy_at_entry_point): Rename
	pc_in_call_dummy_at_entry_point.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (PC_IN_CALL_DUMMY): Update.
	* blockframe.c (deprecated_pc_in_call_dummy_before_text_end)
	(deprecated_pc_in_call_dummy_after_text_end)
	(deprecated_pc_in_call_dummy_on_stack)
	(deprecated_pc_in_call_dummy_at_entry_point): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@a1090 3
  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);

  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
@


1.39
log
@2002-11-22  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_ADDRESS, FRAME_LOCALS_ADDRESS): Default
	to default_frame_address.
	* gdbarch.h, gdbarch.c: Re-generate.

	* d10v-tdep.c (d10v_gdbarch_init): Do not set frame_args_address
	or frame_locals_address to default_frame_address.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.

	* cris-tdep.c (cris_frame_args_address): Delete function.
	(cris_frame_locals_address): Delete function.
	(cris_gdbarch_init): Do not set frame_args_address or
	frame_locals_address.
@
text
@d1105 1
a1105 1
  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_at_entry_point);
@


1.38
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@a1089 2
  set_gdbarch_frame_args_address (gdbarch, default_frame_address);
  set_gdbarch_frame_locals_address (gdbarch, default_frame_address);
@


1.37
log
@2002-11-11  Andrew Cagney  <ac131313@@redhat.com>

	* x86-64-tdep.c (i386_fp_regnum_p): Copy i386-tdep.c's
	i386_fp_regnum_p.
@
text
@d772 2
a773 2
	  write_register_bytes (REGISTER_BYTE (FP0_REGNUM), valbuf,
				FPU_REG_RAW_SIZE);
d786 2
a787 2
	  write_register_bytes (REGISTER_BYTE (FP0_REGNUM), buf,
				FPU_REG_RAW_SIZE);
d796 1
a796 1
	write_register_bytes (REGISTER_BYTE (0), valbuf, len);
d799 4
a802 3
	  write_register_bytes (REGISTER_BYTE (0), valbuf, low_size);
	  write_register_bytes (REGISTER_BYTE (1),
				valbuf + low_size, len - low_size);
@


1.36
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@d178 9
@


1.35
log
@* x86-64-tdep.c (x86_64_init_abi): Set init_extra_frame_info to
cfi_init_extra_frame_info.
* x86-64-tdep.h (x86_64_init_extra_frame_info): Remove prototype.
* x86-64-linux-tdep.c (x86_64_init_extra_frame_info): Remove function.
@
text
@d695 3
a697 3
		  write_register_gen (int_parameter_registers
				      [(intreg + 1) / 2],
				      VALUE_CONTENTS_ALL (args[i]) + offset);
d702 2
a703 2
		  write_register_gen (int_parameter_registers[intreg / 2],
				      VALUE_CONTENTS_ALL (args[i]) + offset);
d710 3
a712 3
		  write_register_gen (sse_parameter_registers
				      [(ssereg + 1) / 2],
				      VALUE_CONTENTS_ALL (args[i]) + offset);
d717 2
a718 2
		  write_register_gen (sse_parameter_registers[ssereg / 2],
				      VALUE_CONTENTS_ALL (args[i]) + offset);
@


1.34
log
@* x86-64-tdep.c (x86_64_init_abi): Add calls to override the i386
target where necessary.  Add more comments and remove the ones
that don't provide any useful information.
@
text
@d1022 1
a1022 1
  set_gdbarch_init_extra_frame_info (gdbarch, x86_64_init_extra_frame_info);
@


1.33
log
@* x86-64-tdep.c: Fix some formatting problems, mostly in comments.
(x86_64_push_return_address): Add comment.
(x86_64_pop_frame): Make static.
(examine_argument): Clarify comment.
(x86_64_skip_prologue): Make prolog_expact variable static.
@
text
@d920 1
a920 1
  /* The x86_64 has 16 SSE registers.  */
d928 5
d934 21
a956 2
  set_gdbarch_register_raw_size (gdbarch, x86_64_register_raw_size);
  set_gdbarch_register_byte (gdbarch, x86_64_register_byte);
d965 2
d969 4
d979 2
a980 5
  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, 7); /* %rsp */
  set_gdbarch_fp_regnum (gdbarch, 6); /* %rbp */
  set_gdbarch_pc_regnum (gdbarch, 16); /* %rip */
  set_gdbarch_fp0_regnum (gdbarch, X86_64_NUM_GREGS); /* %st(0) */
d982 1
d985 6
a990 1
  /* Discard from the stack the innermost frame, restoring all registers.  */
d992 11
a1003 2
  /* FRAME_CHAIN takes a frame's nominal address and produces the
     frame's chain-pointer.  */
a1004 1

d1006 1
a1006 19
				        x86_64_frameless_function_invocation);
  set_gdbarch_frame_saved_pc (gdbarch, x86_64_linux_frame_saved_pc);

  set_gdbarch_frame_init_saved_regs (gdbarch, x86_64_frame_init_saved_regs);

  /* Frame pc initialization is handled by unwind informations.  */
  set_gdbarch_init_frame_pc (gdbarch, x86_64_init_frame_pc);

  /* Initialization of unwind informations.  */
  set_gdbarch_init_extra_frame_info (gdbarch, x86_64_init_extra_frame_info);

  /* Getting saved registers is handled by unwind informations.  */
  set_gdbarch_get_saved_register (gdbarch, cfi_get_saved_register);

  set_gdbarch_frame_init_saved_regs (gdbarch, x86_64_frame_init_saved_regs);

  /* Cons up virtual frame pointer for trace */
  set_gdbarch_virtual_frame_pointer (gdbarch, cfi_virtual_frame_pointer);

d1010 4
a1013 5

  set_gdbarch_push_return_address (gdbarch, x86_64_push_return_address);
  set_gdbarch_push_arguments (gdbarch, x86_64_push_arguments);

  /* Return number of args passed to a frame, no way to tell.  */
d1015 2
d1018 2
a1019 5
  /* If USE_STRUCT_CONVENTION retruns 0, then gdb uses
     STORE_RETURN_VALUE and EXTRACT_RETURN_VALUE to store/fetch the
     functions return value.  It is the case when structure is
     returned in registers.  */
  set_gdbarch_use_struct_convention (gdbarch, x86_64_use_struct_convention);
d1021 2
a1022 3
  /* Store the address of the place in which to copy the structure the
     subroutine will return.  This is called from call_function.  */
  set_gdbarch_store_struct_return (gdbarch, x86_64_store_struct_return);
d1024 2
a1025 5
  /* Extract from an array REGBUF containing the (raw) register state
     a function return value of type TYPE, and copy that, in virtual
     format, into VALBUF.  */
  set_gdbarch_deprecated_extract_return_value (gdbarch,
					       x86_64_extract_return_value);
d1027 2
d1030 3
a1032 9
  /* Write into the appropriate registers a function return value
     stored in VALBUF of type TYPE, given in virtual format.  */
  set_gdbarch_deprecated_store_return_value (gdbarch,
					     x86_64_store_return_value);

  set_gdbarch_skip_prologue (gdbarch, x86_64_skip_prologue);

  set_gdbarch_saved_pc_after_call (gdbarch, x86_64_linux_saved_pc_after_call);

a1033 6

  /* Use dwarf2 debug frame informations.  */
  set_gdbarch_dwarf2_build_frame_info (gdbarch, dwarf2_build_frame_info);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, x86_64_dwarf2_reg_to_regnum);

  set_gdbarch_pc_in_sigtramp (gdbarch, x86_64_linux_in_sigtramp);
@


1.32
log
@* x86-64-tdep.c (x86_64_breakpoint_from_pc): Constify.
(x86_64_init_abi): Move set_gdbarch_* calls that overlap with the
i386 target back into x86_64_gdbarch_init.  Add some comments and
remove meaningless ones.
@
text
@a3 1

d253 3
a261 1

d266 1
a266 1
void
d304 2
a305 2
  /* Rule #2: If one of the classes is NO_CLASS, the resulting class is
     the other class.  */
d332 5
d338 1
a338 8
/* Classify the argument type.
   CLASSES will be filled by the register class used to pass each word
   of the operand.  The number of words is returned.  In case the parameter
   should be passed in memory, 0 is returned. As a special case for zero
   sized containers, classes[0] will be NO_CLASS and 1 is returned.

   See the x86-64 PS ABI for details.
*/
d363 2
a364 2
	/* Zero sized arrays or structures are NO_CLASS.  We return 0 to
	   signalize memory class, so handle it as special case.  */
d447 1
a447 1
	    /*  X86_64_X87UP_CLASS should be preceeded by X86_64_X87_CLASS.  */
d501 3
a503 2
/* Examine the argument and return set number of register required in each
   class.  Return 0 ifif parameter should be passed in memory.  */
d541 3
a543 3
   memory. If this function returns 1, gdb will call STORE_STRUCT_RETURN and
   EXTRACT_STRUCT_VALUE_ADDRESS else STORE_RETURN_VALUE and EXTRACT_RETURN_VALUE
   will be used.  */
a556 1

a638 1
/* Handled by unwind informations.  */
d642 1
d864 1
d866 6
a871 6
  /* We will handle only functions beginning with:
     55          pushq %rbp
     48 89 e5    movq %rsp,%rbp 
   */
  unsigned char prolog_expect[PROLOG_BUFSIZE] = { 0x55, 0x48, 0x89, 0xe5 },
    prolog_buf[PROLOG_BUFSIZE];
d875 1
a875 1
  /* First check, whether pc points to pushq %rbp, movq %rsp,%rbp.  */
d878 1
a878 1
      return pc;		/* ... no, it doesn't. Nothing to skip.  */
d880 1
a880 1
  /* OK, we have found the prologue and want PC of the first 
d887 2
a888 2
  /* If pc doesn't point to a function with debuginfo, 
     some of the following may be NULL.  */
@


1.31
log
@* x86-64-tdep.c (x86_64_gdbarch_init): Make a bit more similar to
the version in i386-tdep.c.  Move set_gdbarch_* calls out into...
(x86_64_init_abi): ...new function.
@
text
@d906 1
a906 1
static unsigned char *
a927 2
  set_gdbarch_long_double_format (gdbarch, &floatformat_i387_ext);

a931 1
  set_gdbarch_max_register_raw_size (gdbarch, 16);
a939 2
  set_gdbarch_register_virtual_size (gdbarch, generic_register_size);
  set_gdbarch_max_register_virtual_size (gdbarch, 16);
a967 6
  set_gdbarch_frame_args_address (gdbarch, default_frame_address);
  set_gdbarch_frame_locals_address (gdbarch, default_frame_address);

  /* Return number of bytes at start of arglist that are not really args.  */
  set_gdbarch_frame_args_skip (gdbarch, 8);

d984 2
a987 14
  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
  set_gdbarch_call_dummy_address (gdbarch, entry_point_address);
  set_gdbarch_call_dummy_length (gdbarch, 0);
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_at_entry_point);
  set_gdbarch_call_dummy_words (gdbarch, 0);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, 0);
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
  set_gdbarch_call_dummy_p (gdbarch, 1);
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);
  set_gdbarch_fix_call_dummy (gdbarch, generic_fix_call_dummy);
a992 2
  /* Don't use default structure extract routine */
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, 0);
a1015 3
  /* Offset from address of function to start of its code.  */
  set_gdbarch_function_start_offset (gdbarch, 0);

a1019 6
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);

  set_gdbarch_breakpoint_from_pc (gdbarch,
				  (gdbarch_breakpoint_from_pc_ftype *)
				  x86_64_breakpoint_from_pc);

a1021 4
  /* Amount PC must be decremented by after a breakpoint.  This is
     often the number of bytes in BREAKPOINT but not always.  */
  set_gdbarch_decr_pc_after_break (gdbarch, 1);

d1056 42
@


1.30
log
@Reindented.
@
text
@d914 2
a915 2
static struct gdbarch *
x86_64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
d917 1
a917 2
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;
d920 2
a921 64
  /* Find a candidate among the list of pre-declared architectures. */
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      switch (info.bfd_arch_info->mach)
	{
	case bfd_mach_x86_64:
	case bfd_mach_x86_64_intel_syntax:
	  switch (gdbarch_bfd_arch_info (arches->gdbarch)->mach)
	    {
	    case bfd_mach_x86_64:
	    case bfd_mach_x86_64_intel_syntax:
	      return arches->gdbarch;
	    case bfd_mach_i386_i386:
	    case bfd_mach_i386_i8086:
	    case bfd_mach_i386_i386_intel_syntax:
	      break;
	    default:
	      internal_error (__FILE__, __LINE__,
			      "x86_64_gdbarch_init: unknown machine type");
	    }
	  break;
	case bfd_mach_i386_i386:
	case bfd_mach_i386_i8086:
	case bfd_mach_i386_i386_intel_syntax:
	  switch (gdbarch_bfd_arch_info (arches->gdbarch)->mach)
	    {
	    case bfd_mach_x86_64:
	    case bfd_mach_x86_64_intel_syntax:
	      break;
	    case bfd_mach_i386_i386:
	    case bfd_mach_i386_i8086:
	    case bfd_mach_i386_i386_intel_syntax:
	      return arches->gdbarch;
	    default:
	      internal_error (__FILE__, __LINE__,
			      "x86_64_gdbarch_init: unknown machine type");
	    }
	  break;
	default:
	  internal_error (__FILE__, __LINE__,
			  "x86_64_gdbarch_init: unknown machine type");
	}
    }

  tdep = (struct gdbarch_tdep *) xmalloc (sizeof (struct gdbarch_tdep));
  gdbarch = gdbarch_alloc (&info, tdep);

  switch (info.bfd_arch_info->mach)
    {
    case bfd_mach_x86_64:
    case bfd_mach_x86_64_intel_syntax:
      tdep->num_xmm_regs = 16;
      break;
    case bfd_mach_i386_i386:
    case bfd_mach_i386_i8086:
    case bfd_mach_i386_i386_intel_syntax:
      /* This is place for definition of i386 target vector.  */
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      "x86_64_gdbarch_init: unknown machine type");
    }
d923 1
d937 3
a939 2
  /* Total amount of space needed to store our copies of the machine's register
     (SIZEOF_GREGS + SIZEOF_FPU_REGS + SIZEOF_FPU_CTRL_REGS + SIZEOF_SSE_REGS) */
d954 5
a958 6
/* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, 7);	/* (rsp) Contains address of top of stack.  */
  set_gdbarch_fp_regnum (gdbarch, 6);	/* (rbp) */
  set_gdbarch_pc_regnum (gdbarch, 16);	/* (rip) Contains program counter.  */

  set_gdbarch_fp0_regnum (gdbarch, X86_64_NUM_GREGS);	/* First FPU floating-point register.  */
d962 1
a962 1
/* Discard from the stack the innermost frame, restoring all registers.  */
d965 2
a966 2
  /* FRAME_CHAIN takes a frame's nominal address and produces the frame's
     chain-pointer.  */
d970 1
a970 1
					     x86_64_frameless_function_invocation);
d976 1
a976 1
/* Return number of bytes at start of arglist that are not really args.  */
d981 1
a981 1
/* Frame pc initialization is handled by unwind informations.  */
d984 1
a984 1
/* Initialization of unwind informations.  */
d987 1
a987 1
/* Getting saved registers is handled by unwind informations.  */
d992 1
a992 1
/* Cons up virtual frame pointer for trace */
d1014 1
a1014 1
/* Return number of args passed to a frame, no way to tell.  */
d1016 1
a1016 1
/* Don't use default structure extract routine */
d1019 4
a1022 3
/* If USE_STRUCT_CONVENTION retruns 0, then gdb uses STORE_RETURN_VALUE
   and EXTRACT_RETURN_VALUE to store/fetch the functions return value.  It is
   the case when structure is returned in registers.  */
d1025 2
a1026 2
/* Store the address of the place in which to copy the structure the
   subroutine will return.  This is called from call_function. */
d1029 3
a1031 3
/* Extract from an array REGBUF containing the (raw) register state
   a function return value of type TYPE, and copy that, in virtual format,
   into VALBUF.  */
d1036 2
a1037 2
/* Write into the appropriate registers a function return value stored
   in VALBUF of type TYPE, given in virtual format.  */
a1039 1

d1041 1
a1041 1
/* Offset from address of function to start of its code.  */
d1056 2
a1057 2
/* Amount PC must be decremented by after a breakpoint.  This is often the
   number of bytes in BREAKPOINT but not always.  */
d1060 1
a1060 1
/* Use dwarf2 debug frame informations.  */
d1065 31
@


1.29
log
@2002-10-24  Michal Ludvig  <mludvig@@suse.cz>

	* dwarf2cfi.c (struct context)
	(struct context_reg): Moved to dwarf2cfi.h
	(context_alloc, frame_state_alloc, context_cpy):
	Made extern instead of static, removed prototypes.
	* dwarf2cfi.h (struct context)
	(struct context_reg): New, moved from dwarf2cfi.c
	(context_alloc, frame_state_alloc, context_cpy):
	New prototypes.
	* x86-64-linux-tdep.c (x86_64_linux_sigtramp_saved_pc):
	Changed from static to extern.
	(LINUX_SIGINFO_SIZE, LINUX_SIGCONTEXT_PC_OFFSET)
	(LINUX_SIGCONTEXT_FP_OFFSET)
	(LINUX_UCONTEXT_SIGCONTEXT_OFFSET): Adjusted.
	(x86_64_linux_in_sigtramp, x86_64_linux_frame_chain)
	(x86_64_init_frame_pc, x86_64_init_extra_frame_info): New.
	* x86-64-tdep.c (x86_64_gdbarch_init): Several
	set_gdbarch_*() calls now use x86-64 specific functions
	instead of DWARF2 CFI ones.
	* x86-64-tdep.h (x86_64_linux_in_sigtramp)
	(x86_64_linux_frame_chain, x86_64_init_frame_pc)
	(x86_64_init_extra_frame_info): New prototypes.
@
text
@d907 1
a907 1
x86_64_breakpoint_from_pc (CORE_ADDR * pc, int *lenptr)
d1093 2
a1094 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, x86_64_extract_return_value);
d1099 2
a1100 1
  set_gdbarch_deprecated_store_return_value (gdbarch, x86_64_store_return_value);
@


1.28
log
@2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* parse.c (parse_exp_1): Use BLOCK_START.
	* x86-64-tdep.c (x86_64_skip_prologue): Use BLOCK_END,
	SYMBOL_BLOCK_VALUE.
	* objc-lang.c (find_methods): Use BLOCK_START, BLOCK_END.
@
text
@d1029 1
a1029 1
  set_gdbarch_frame_chain (gdbarch, cfi_frame_chain);
d1044 1
a1044 1
  set_gdbarch_init_frame_pc (gdbarch, cfi_init_frame_pc);
d1047 1
a1047 1
  set_gdbarch_init_extra_frame_info (gdbarch, cfi_init_extra_frame_info);
d1057 1
a1057 2

  set_gdbarch_frame_chain_valid (gdbarch, generic_file_frame_chain_valid);
d1123 2
@


1.27
log
@	* x86-64-tdep.c (_initialize_x86_64_tdep): Don't use hard-coded
	mach constants.
	* MAINTAINERS: Add myself to write after approval list.
@
text
@d892 1
a892 1
  endaddr = v_function->ginfo.value.block->endaddr;
@


1.27.4.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d892 1
a892 1
  endaddr = BLOCK_END (SYMBOL_BLOCK_VALUE (v_function));
d907 1
a907 1
x86_64_breakpoint_from_pc (CORE_ADDR *pc, int *lenptr)
d1029 1
a1029 1
  set_gdbarch_frame_chain (gdbarch, x86_64_linux_frame_chain);
d1044 1
a1044 1
  set_gdbarch_init_frame_pc (gdbarch, x86_64_init_frame_pc);
d1047 1
a1047 1
  set_gdbarch_init_extra_frame_info (gdbarch, x86_64_init_extra_frame_info);
d1057 2
a1058 1
  set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
d1094 1
a1094 2
  set_gdbarch_deprecated_extract_return_value (gdbarch,
					       x86_64_extract_return_value);
d1099 1
a1099 2
  set_gdbarch_deprecated_store_return_value (gdbarch,
					     x86_64_store_return_value);
a1123 2

  set_gdbarch_pc_in_sigtramp (gdbarch, x86_64_linux_in_sigtramp);
@


1.27.4.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 2
a4 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
a24 6
#include "arch-utils.h"
#include "block.h"
#include "dummy-frame.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
d26 1
d28 1
a28 2
#include "gdbcore.h"
#include "objfiles.h"
a29 1
#include "regset.h"
d31 3
a33 1

d36 7
a42 4
#include "x86-64-tdep.h"
#include "i387-tdep.h"

/* Register information.  */
d44 1
a44 1
struct x86_64_register_info
d46 1
d51 81
a131 63
static struct x86_64_register_info x86_64_register_info[] =
{
  { "rax", &builtin_type_int64 },
  { "rbx", &builtin_type_int64 },
  { "rcx", &builtin_type_int64 },
  { "rdx", &builtin_type_int64 },
  { "rsi", &builtin_type_int64 },
  { "rdi", &builtin_type_int64 },
  { "rbp", &builtin_type_void_data_ptr },
  { "rsp", &builtin_type_void_data_ptr },

  /* %r8 is indeed register number 8.  */
  { "r8", &builtin_type_int64 },
  { "r9", &builtin_type_int64 },
  { "r10", &builtin_type_int64 },
  { "r11", &builtin_type_int64 },
  { "r12", &builtin_type_int64 },
  { "r13", &builtin_type_int64 },
  { "r14", &builtin_type_int64 },
  { "r15", &builtin_type_int64 },
  { "rip", &builtin_type_void_func_ptr },
  { "eflags", &builtin_type_int32 },
  { "ds", &builtin_type_int32 },
  { "es", &builtin_type_int32 },
  { "fs", &builtin_type_int32 },
  { "gs", &builtin_type_int32 },

  /* %st0 is register number 22.  */
  { "st0", &builtin_type_i387_ext },
  { "st1", &builtin_type_i387_ext },
  { "st2", &builtin_type_i387_ext },
  { "st3", &builtin_type_i387_ext },
  { "st4", &builtin_type_i387_ext },
  { "st5", &builtin_type_i387_ext },
  { "st6", &builtin_type_i387_ext },
  { "st7", &builtin_type_i387_ext },
  { "fctrl", &builtin_type_int32 },
  { "fstat", &builtin_type_int32 },
  { "ftag", &builtin_type_int32 },
  { "fiseg", &builtin_type_int32 },
  { "fioff", &builtin_type_int32 },
  { "foseg", &builtin_type_int32 },
  { "fooff", &builtin_type_int32 },
  { "fop", &builtin_type_int32 },

  /* %xmm0 is register number 38.  */
  { "xmm0", &builtin_type_v4sf },
  { "xmm1", &builtin_type_v4sf },
  { "xmm2", &builtin_type_v4sf },
  { "xmm3", &builtin_type_v4sf },
  { "xmm4", &builtin_type_v4sf },
  { "xmm5", &builtin_type_v4sf },
  { "xmm6", &builtin_type_v4sf },
  { "xmm7", &builtin_type_v4sf },
  { "xmm8", &builtin_type_v4sf },
  { "xmm9", &builtin_type_v4sf },
  { "xmm10", &builtin_type_v4sf },
  { "xmm11", &builtin_type_v4sf },
  { "xmm12", &builtin_type_v4sf },
  { "xmm13", &builtin_type_v4sf },
  { "xmm14", &builtin_type_v4sf },
  { "xmm15", &builtin_type_v4sf },
  { "mxcsr", &builtin_type_int32 }
d134 7
a140 3
/* Total number of registers.  */
#define X86_64_NUM_REGS \
  (sizeof (x86_64_register_info) / sizeof (x86_64_register_info[0]))
d142 2
a143 1
/* Return the name of register REGNUM.  */
d145 10
a154 2
static const char *
x86_64_register_name (int regnum)
d156 2
a157 2
  if (regnum >= 0 && regnum < X86_64_NUM_REGS)
    return x86_64_register_info[regnum].name;
d159 10
a168 1
  return NULL;
d172 1
a172 2
   register REGNUM. */

d174 1
a174 1
x86_64_register_type (struct gdbarch *gdbarch, int regnum)
d176 2
a177 1
  gdb_assert (regnum >= 0 && regnum < X86_64_NUM_REGS);
d179 9
a187 1
  return *x86_64_register_info[regnum].type;
d190 7
a196 4
/* DWARF Register Number Mapping as defined in the System V psABI,
   section 3.6.  */

static int x86_64_dwarf_regmap[] =
d198 1
a198 3
  /* General Purpose Registers RAX, RDX, RCX, RBX, RSI, RDI.  */
  X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, 2, 1,
  4, X86_64_RDI_REGNUM,
d200 16
a215 2
  /* Frame Pointer Register RBP.  */
  X86_64_RBP_REGNUM,
d217 3
a219 2
  /* Stack Pointer Register RSP.  */
  X86_64_RSP_REGNUM,
d221 8
a228 2
  /* Extended Integer Registers 8 - 15.  */
  8, 9, 10, 11, 12, 13, 14, 15,
d230 9
a238 2
  /* Return Address RA.  Not mapped.  */
  -1,
d240 2
a241 11
  /* SSE Registers 0 - 7.  */
  X86_64_XMM0_REGNUM + 0, X86_64_XMM1_REGNUM,
  X86_64_XMM0_REGNUM + 2, X86_64_XMM0_REGNUM + 3,
  X86_64_XMM0_REGNUM + 4, X86_64_XMM0_REGNUM + 5,
  X86_64_XMM0_REGNUM + 6, X86_64_XMM0_REGNUM + 7,

  /* Extended SSE Registers 8 - 15.  */
  X86_64_XMM0_REGNUM + 8, X86_64_XMM0_REGNUM + 9,
  X86_64_XMM0_REGNUM + 10, X86_64_XMM0_REGNUM + 11,
  X86_64_XMM0_REGNUM + 12, X86_64_XMM0_REGNUM + 13,
  X86_64_XMM0_REGNUM + 14, X86_64_XMM0_REGNUM + 15,
d243 8
a250 5
  /* Floating Point Registers 0-7.  */
  X86_64_ST0_REGNUM + 0, X86_64_ST0_REGNUM + 1,
  X86_64_ST0_REGNUM + 2, X86_64_ST0_REGNUM + 3,
  X86_64_ST0_REGNUM + 4, X86_64_ST0_REGNUM + 5,
  X86_64_ST0_REGNUM + 6, X86_64_ST0_REGNUM + 7
d252 1
d254 2
a255 8
static const int x86_64_dwarf_regmap_len =
  (sizeof (x86_64_dwarf_regmap) / sizeof (x86_64_dwarf_regmap[0]));

/* Convert DWARF register number REG to the appropriate register
   number used by GDB.  */

static int
x86_64_dwarf_reg_to_regnum (int reg)
d257 1
a257 4
  int regnum = -1;

  if (reg >= 0 || reg < x86_64_dwarf_regmap_len)
    regnum = x86_64_dwarf_regmap[reg];
d259 1
a259 2
  if (regnum == -1)
    warning ("Unmapped DWARF Register #%d encountered\n", reg);
d261 2
a262 1
  return regnum;
d265 2
a266 5
/* Return nonzero if a value of type TYPE stored in register REGNUM
   needs any special handling.  */

static int
x86_64_convert_register_p (int regnum, struct type *type)
d268 1
a268 1
  return i386_fp_regnum_p (regnum);
d272 19
a290 12
/* Register classes as defined in the psABI.  */

enum amd64_reg_class
{
  AMD64_INTEGER,
  AMD64_SSE,
  AMD64_SSEUP,
  AMD64_X87,
  AMD64_X87UP,
  AMD64_COMPLEX_X87,
  AMD64_NO_CLASS,
  AMD64_MEMORY
d293 2
a294 2
/* Return the union class of CLASS1 and CLASS2.  See the psABI for
   details.  */
d296 2
a297 2
static enum amd64_reg_class
amd64_merge_classes (enum amd64_reg_class class1, enum amd64_reg_class class2)
d299 1
a299 1
  /* Rule (a): If both classes are equal, this is the resulting class.  */
d303 3
a305 3
  /* Rule (b): If one of the classes is NO_CLASS, the resulting class
     is the other class.  */
  if (class1 == AMD64_NO_CLASS)
d307 1
a307 1
  if (class2 == AMD64_NO_CLASS)
d310 20
a329 3
  /* Rule (c): If one of the classes is MEMORY, the result is MEMORY.  */
  if (class1 == AMD64_MEMORY || class2 == AMD64_MEMORY)
    return AMD64_MEMORY;
a330 3
  /* Rule (d): If one of the classes is INTEGER, the result is INTEGER.  */
  if (class1 == AMD64_INTEGER || class2 == AMD64_INTEGER)
    return AMD64_INTEGER;
d332 5
a336 6
  /* Rule (e): If one of the classes is X87, X87UP, COMPLEX_X87 class,
     MEMORY is used as class.  */
  if (class1 == AMD64_X87 || class1 == AMD64_X87UP
      || class1 == AMD64_COMPLEX_X87 || class2 == AMD64_X87
      || class2 == AMD64_X87UP || class2 == AMD64_COMPLEX_X87)
    return AMD64_MEMORY;
d338 2
a339 3
  /* Rule (f): Otherwise class SSE is used.  */
  return AMD64_SSE;
}
d341 6
a346 1
static void amd64_classify (struct type *type, enum amd64_reg_class class[2]);
d348 50
a397 2
/* Classify TYPE according to the rules for aggregate (structures and
   arrays) and union types, and store the result in CLASS.  */
d399 10
a408 4
static void
amd64_classify_aggregate (struct type *type, enum amd64_reg_class class[2])
{
  int len = TYPE_LENGTH (type);
d410 87
a496 7
  /* 1. If the size of an object is larger than two eightbytes, or in
        C++, is a non-POD structure or union type, or contains
        unaligned fields, it has class memory.  */
  if (len > 16)
    {
      class[0] = class[1] = AMD64_MEMORY;
      return;
d498 3
d502 54
a555 2
  /* 2. Both eightbytes get initialized to class NO_CLASS.  */
  class[0] = class[1] = AMD64_NO_CLASS;
a556 4
  /* 3. Each field of an object is classified recursively so that
        always two fields are considered. The resulting class is
        calculated according to the classes of the fields in the
        eightbyte: */
d558 3
a560 3
  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      struct type *subtype = check_typedef (TYPE_TARGET_TYPE (type));
d562 21
a582 4
      /* All fields in an array have the same type.  */
      amd64_classify (subtype, class);
      if (len > 8 && class[1] == AMD64_NO_CLASS)
	class[1] = class[0];
d587 1
a587 6

      /* Structure or union.  */
      gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT
		  || TYPE_CODE (type) == TYPE_CODE_UNION);

      for (i = 0; i < TYPE_NFIELDS (type); i++)
d589 47
a635 10
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));
	  int pos = TYPE_FIELD_BITPOS (type, i) / 64;
	  enum amd64_reg_class subclass[2];

	  gdb_assert (pos == 0 || pos == 1);

	  amd64_classify (subtype, subclass);
	  class[pos] = amd64_merge_classes (class[pos], subclass[0]);
	  if (pos == 0)
	    class[1] = amd64_merge_classes (class[1], subclass[1]);
a637 14

  /* 4. Then a post merger cleanup is done:  */

  /* Rule (a): If one of the classes is MEMORY, the whole argument is
     passed in memory.  */
  if (class[0] == AMD64_MEMORY || class[1] == AMD64_MEMORY)
    class[0] = class[1] = AMD64_MEMORY;

  /* Rule (b): If SSEUP is not preceeded by SSE, it is converted to
     SSE.  */
  if (class[0] == AMD64_SSEUP)
    class[0] = AMD64_SSE;
  if (class[1] == AMD64_SSEUP && class[0] != AMD64_SSE)
    class[1] = AMD64_SSE;
d640 1
a640 2
/* Classify TYPE, and store the result in CLASS.  */

d642 1
a642 1
amd64_classify (struct type *type, enum amd64_reg_class class[2])
d644 1
a644 2
  enum type_code code = TYPE_CODE (type);
  int len = TYPE_LENGTH (type);
d646 2
a647 1
  class[0] = class[1] = AMD64_NO_CLASS;
d649 3
a651 34
  /* Arguments of types (signed and unsigned) _Bool, char, short, int,
     long, long long, and pointers are in the INTEGER class.  */
  if ((code == TYPE_CODE_INT || code == TYPE_CODE_ENUM
       || code == TYPE_CODE_PTR || code == TYPE_CODE_REF)
      && (len == 1 || len == 2 || len == 4 || len == 8))
    class[0] = AMD64_INTEGER;

  /* Arguments of types float, double and __m64 are in class SSE.  */
  else if (code == TYPE_CODE_FLT && (len == 4 || len == 8))
    /* FIXME: __m64 .  */
    class[0] = AMD64_SSE;

  /* Arguments of types __float128 and __m128 are split into two
     halves.  The least significant ones belong to class SSE, the most
     significant one to class SSEUP.  */
  /* FIXME: __float128, __m128.  */

  /* The 64-bit mantissa of arguments of type long double belongs to
     class X87, the 16-bit exponent plus 6 bytes of padding belongs to
     class X87UP.  */
  else if (code == TYPE_CODE_FLT && len == 16)
    /* Class X87 and X87UP.  */
    class[0] = AMD64_X87, class[1] = AMD64_X87UP;

  /* Aggregates.  */
  else if (code == TYPE_CODE_ARRAY || code == TYPE_CODE_STRUCT
	   || code == TYPE_CODE_UNION)
    amd64_classify_aggregate (type, class);
}

static enum return_value_convention
amd64_return_value (struct gdbarch *gdbarch, struct type *type,
		    struct regcache *regcache,
		    void *readbuf, const void *writebuf)
d653 2
a654 6
  enum amd64_reg_class class[2];
  int len = TYPE_LENGTH (type);
  static int integer_regnum[] = { X86_64_RAX_REGNUM, X86_64_RDX_REGNUM };
  static int sse_regnum[] = { X86_64_XMM0_REGNUM, X86_64_XMM1_REGNUM };
  int integer_reg = 0;
  int sse_reg = 0;
d656 4
a659 90

  gdb_assert (!(readbuf && writebuf));

  /* 1. Classify the return type with the classification algorithm.  */
  amd64_classify (type, class);

  /* 2. If the type has class MEMORY, then the caller provides space
        for the return value and passes the address of this storage in
        %rdi as if it were the first argument to the function. In
        effect, this address becomes a hidden first argument.  */
  if (class[0] == AMD64_MEMORY)
    return RETURN_VALUE_STRUCT_CONVENTION;

  gdb_assert (class[1] != AMD64_MEMORY);
  gdb_assert (len <= 16);

  for (i = 0; len > 0; i++, len -= 8)
    {
      int regnum = -1;
      int offset = 0;

      switch (class[i])
	{
	case AMD64_INTEGER:
	  /* 3. If the class is INTEGER, the next available register
	     of the sequence %rax, %rdx is used.  */
	  regnum = integer_regnum[integer_reg++];
	  break;

	case AMD64_SSE:
	  /* 4. If the class is SSE, the next available SSE register
             of the sequence %xmm0, %xmm1 is used.  */
	  regnum = sse_regnum[sse_reg++];
	  break;

	case AMD64_SSEUP:
	  /* 5. If the class is SSEUP, the eightbyte is passed in the
	     upper half of the last used SSE register.  */
	  gdb_assert (sse_reg > 0);
	  regnum = sse_regnum[sse_reg - 1];
	  offset = 8;
	  break;

	case AMD64_X87:
	  /* 6. If the class is X87, the value is returned on the X87
             stack in %st0 as 80-bit x87 number.  */
	  regnum = X86_64_ST0_REGNUM;
	  if (writebuf)
	    i387_return_value (gdbarch, regcache);
	  break;

	case AMD64_X87UP:
	  /* 7. If the class is X87UP, the value is returned together
             with the previous X87 value in %st0.  */
	  gdb_assert (i > 0 && class[0] == AMD64_X87);
	  regnum = X86_64_ST0_REGNUM;
	  offset = 8;
	  len = 2;
	  break;

	case AMD64_NO_CLASS:
	  continue;

	default:
	  gdb_assert (!"Unexpected register class.");
	}

      gdb_assert (regnum != -1);

      if (readbuf)
	regcache_raw_read_part (regcache, regnum, offset, min (len, 8),
				(char *) readbuf + i * 8);
      if (writebuf)
	regcache_raw_write_part (regcache, regnum, offset, min (len, 8),
				 (const char *) writebuf + i * 8);
    }

  return RETURN_VALUE_REGISTER_CONVENTION;
}


static CORE_ADDR
amd64_push_arguments (struct regcache *regcache, int nargs,
		      struct value **args, CORE_ADDR sp)
{
  static int integer_regnum[] =
  {
    X86_64_RDI_REGNUM, 4,	/* %rdi, %rsi */
    X86_64_RDX_REGNUM, 2,	/* %rdx, %rcx */
    8, 9			/* %r8, %r9 */
d661 6
a666 7
  static int sse_regnum[] =
  {
    /* %xmm0 ... %xmm7 */
    X86_64_XMM0_REGNUM + 0, X86_64_XMM1_REGNUM,
    X86_64_XMM0_REGNUM + 2, X86_64_XMM0_REGNUM + 3,
    X86_64_XMM0_REGNUM + 4, X86_64_XMM0_REGNUM + 5,
    X86_64_XMM0_REGNUM + 6, X86_64_XMM0_REGNUM + 7,
d668 3
a670 8
  struct value **stack_args = alloca (nargs * sizeof (struct value *));
  int num_stack_args = 0;
  int num_elements = 0;
  int element = 0;
  int integer_reg = 0;
  int sse_reg = 0;
  int i;

d673 11
a683 29
      struct type *type = VALUE_TYPE (args[i]);
      int len = TYPE_LENGTH (type);
      enum amd64_reg_class class[2];
      int needed_integer_regs = 0;
      int needed_sse_regs = 0;
      int j;

      /* Classify argument.  */
      amd64_classify (type, class);

      /* Calculate the number of integer and SSE registers needed for
         this argument.  */
      for (j = 0; j < 2; j++)
	{
	  if (class[j] == AMD64_INTEGER)
	    needed_integer_regs++;
	  else if (class[j] == AMD64_SSE)
	    needed_sse_regs++;
	}

      /* Check whether enough registers are available, and if the
         argument should be passed in registers at all.  */
      if (integer_reg + needed_integer_regs > ARRAY_SIZE (integer_regnum)
	  || sse_reg + needed_sse_regs > ARRAY_SIZE (sse_regnum)
	  || (needed_integer_regs == 0 && needed_sse_regs == 0))
	{
	  /* The argument will be passed on the stack.  */
	  num_elements += ((len + 7) / 8);
	  stack_args[num_stack_args++] = args[i];
d687 2
a688 7
	  /* The argument will be passed in registers.  */
	  char *valbuf = VALUE_CONTENTS (args[i]);
	  char buf[8];

	  gdb_assert (len <= 16);

	  for (j = 0; len > 0; j++, len -= 8)
a689 1
	      int regnum = -1;
a690 1

d693 14
a706 2
		case AMD64_INTEGER:
		  regnum = integer_regnum[integer_reg++];
d708 18
a725 3

		case AMD64_SSE:
		  regnum = sse_regnum[sse_reg++];
d727 1
a727 5

		case AMD64_SSEUP:
		  gdb_assert (sse_reg > 0);
		  regnum = sse_regnum[sse_reg - 1];
		  offset = 8;
a728 1

d730 2
a731 1
		  gdb_assert (!"Unexpected register class.");
d733 2
a734 5

	      gdb_assert (regnum != -1);
	      memset (buf, 0, sizeof buf);
	      memcpy (buf, valbuf + j * 8, min (len, 8));
	      regcache_raw_write_part (regcache, regnum, offset, 8, buf);
d738 1
a738 10

  /* Allocate space for the arguments on the stack.  */
  sp -= num_elements * 8;

  /* The psABI says that "The end of the input argument area shall be
     aligned on a 16 byte boundary."  */
  sp &= ~0xf;

  /* Write out the arguments to the stack.  */
  for (i = 0; i < num_stack_args; i++)
d740 6
a745 6
      struct type *type = VALUE_TYPE (stack_args[i]);
      char *valbuf = VALUE_CONTENTS (stack_args[i]);
      int len = TYPE_LENGTH (type);

      write_memory (sp + element * 8, valbuf, len);
      element += ((len + 7) / 8);
d747 1
a747 7

  /* The psABI says that "For calls that may call functions that use
     varargs or stdargs (prototype-less calls or calls to functions
     containing ellipsis (...) in the declaration) %al is used as
     hidden argument to specify the number of SSE registers used.  */
  regcache_raw_write_unsigned (regcache, X86_64_RAX_REGNUM, sse_reg);
  return sp; 
d750 4
a753 5
static CORE_ADDR
x86_64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			struct regcache *regcache, CORE_ADDR bp_addr,
			int nargs, struct value **args,	CORE_ADDR sp,
			int struct_return, CORE_ADDR struct_addr)
d755 1
a755 1
  char buf[8];
d757 1
a757 5
  /* Pass arguments.  */
  sp = amd64_push_arguments (regcache, nargs, args, sp);

  /* Pass "hidden" argument".  */
  if (struct_return)
d759 12
a770 3
      store_unsigned_integer (buf, 8, struct_addr);
      regcache_cooked_write (regcache, X86_64_RDI_REGNUM, buf);
    }
d772 9
a780 157
  /* Store return address.  */
  sp -= 8;
  store_unsigned_integer (buf, 8, bp_addr);
  write_memory (sp, buf, 8);

  /* Finally, update the stack pointer...  */
  store_unsigned_integer (buf, 8, sp);
  regcache_cooked_write (regcache, X86_64_RSP_REGNUM, buf);

  /* ...and fake a frame pointer.  */
  regcache_cooked_write (regcache, X86_64_RBP_REGNUM, buf);

  return sp + 16;
}


/* The maximum number of saved registers.  This should include %rip.  */
#define X86_64_NUM_SAVED_REGS	X86_64_NUM_GREGS

struct x86_64_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  CORE_ADDR sp_offset;
  CORE_ADDR pc;

  /* Saved registers.  */
  CORE_ADDR saved_regs[X86_64_NUM_SAVED_REGS];
  CORE_ADDR saved_sp;

  /* Do we have a frame?  */
  int frameless_p;
};

/* Allocate and initialize a frame cache.  */

static struct x86_64_frame_cache *
x86_64_alloc_frame_cache (void)
{
  struct x86_64_frame_cache *cache;
  int i;

  cache = FRAME_OBSTACK_ZALLOC (struct x86_64_frame_cache);

  /* Base address.  */
  cache->base = 0;
  cache->sp_offset = -8;
  cache->pc = 0;

  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where %rbp is supposed to be stored).  */
  for (i = 0; i < X86_64_NUM_SAVED_REGS; i++)
    cache->saved_regs[i] = -1;
  cache->saved_sp = 0;

  /* Frameless until proven otherwise.  */
  cache->frameless_p = 1;

  return cache;
}

/* Do a limited analysis of the prologue at PC and update CACHE
   accordingly.  Bail out early if CURRENT_PC is reached.  Return the
   address where the analysis stopped.

   We will handle only functions beginning with:

      pushq %rbp        0x55
      movq %rsp, %rbp   0x48 0x89 0xe5

   Any function that doesn't start with this sequence will be assumed
   to have no prologue and thus no valid frame pointer in %rbp.  */

static CORE_ADDR
x86_64_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
			 struct x86_64_frame_cache *cache)
{
  static unsigned char proto[3] = { 0x48, 0x89, 0xe5 };
  unsigned char buf[3];
  unsigned char op;

  if (current_pc <= pc)
    return current_pc;

  op = read_memory_unsigned_integer (pc, 1);

  if (op == 0x55)		/* pushq %rbp */
    {
      /* Take into account that we've executed the `pushq %rbp' that
         starts this instruction sequence.  */
      cache->saved_regs[X86_64_RBP_REGNUM] = 0;
      cache->sp_offset += 8;

      /* If that's all, return now.  */
      if (current_pc <= pc + 1)
        return current_pc;

      /* Check for `movq %rsp, %rbp'.  */
      read_memory (pc + 1, buf, 3);
      if (memcmp (buf, proto, 3) != 0)
	return pc + 1;

      /* OK, we actually have a frame.  */
      cache->frameless_p = 0;
      return pc + 4;
    }

  return pc;
}

/* Return PC of first real instruction.  */

static CORE_ADDR
x86_64_skip_prologue (CORE_ADDR start_pc)
{
  struct x86_64_frame_cache cache;
  CORE_ADDR pc;

  pc = x86_64_analyze_prologue (start_pc, 0xffffffffffffffff, &cache);
  if (cache.frameless_p)
    return start_pc;

  return pc;
}


/* Normal frames.  */

static struct x86_64_frame_cache *
x86_64_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct x86_64_frame_cache *cache;
  char buf[8];
  int i;

  if (*this_cache)
    return *this_cache;

  cache = x86_64_alloc_frame_cache ();
  *this_cache = cache;

  cache->pc = frame_func_unwind (next_frame);
  if (cache->pc != 0)
    x86_64_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);

  if (cache->frameless_p)
    {
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  If
	 we're at the start of a function, or somewhere half-way its
	 prologue, the function's frame probably hasn't been fully
	 setup yet.  Try to reconstruct the base address for the stack
	 frame by looking at the stack pointer.  For truly "frameless"
	 functions this might work too.  */

      frame_unwind_register (next_frame, X86_64_RSP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 8) + cache->sp_offset;
d784 2
a785 32
      frame_unwind_register (next_frame, X86_64_RBP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 8);
    }

  /* Now that we have the base address for the stack frame we can
     calculate the value of %rsp in the calling frame.  */
  cache->saved_sp = cache->base + 16;

  /* For normal frames, %rip is stored at 8(%rbp).  If we don't have a
     frame we find it at the same offset from the reconstructed base
     address.  */
  cache->saved_regs[X86_64_RIP_REGNUM] = 8;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < X86_64_NUM_SAVED_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] += cache->base;

  return cache;
}

static void
x86_64_frame_this_id (struct frame_info *next_frame, void **this_cache,
		      struct frame_id *this_id)
{
  struct x86_64_frame_cache *cache =
    x86_64_frame_cache (next_frame, this_cache);

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;
d787 3
a789 21
  (*this_id) = frame_id_build (cache->base + 16, cache->pc);
}

static void
x86_64_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			    int regnum, int *optimizedp,
			    enum lval_type *lvalp, CORE_ADDR *addrp,
			    int *realnump, void *valuep)
{
  struct x86_64_frame_cache *cache =
    x86_64_frame_cache (next_frame, this_cache);

  gdb_assert (regnum >= 0);

  if (regnum == SP_REGNUM && cache->saved_sp)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
d791 3
a793 2
	  /* Store the value.  */
	  store_unsigned_integer (valuep, 8, cache->saved_sp);
d795 3
a797 1
      return;
a798 18

  if (regnum < X86_64_NUM_SAVED_REGS && cache->saved_regs[regnum] != -1)
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
	}
      return;
    }

  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
d800 1
d802 2
a803 9
static const struct frame_unwind x86_64_frame_unwind =
{
  NORMAL_FRAME,
  x86_64_frame_this_id,
  x86_64_frame_prev_register
};

static const struct frame_unwind *
x86_64_frame_sniffer (struct frame_info *next_frame)
d805 3
a807 36
  return &x86_64_frame_unwind;
}


/* Signal trampolines.  */

/* FIXME: kettenis/20030419: Perhaps, we can unify the 32-bit and
   64-bit variants.  This would require using identical frame caches
   on both platforms.  */

static struct x86_64_frame_cache *
x86_64_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct x86_64_frame_cache *cache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  CORE_ADDR addr;
  char buf[8];
  int i;

  if (*this_cache)
    return *this_cache;

  cache = x86_64_alloc_frame_cache ();

  frame_unwind_register (next_frame, X86_64_RSP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 8) - 8;

  addr = tdep->sigcontext_addr (next_frame);
  gdb_assert (tdep->sc_reg_offset);
  gdb_assert (tdep->sc_num_regs <= X86_64_NUM_SAVED_REGS);
  for (i = 0; i < tdep->sc_num_regs; i++)
    if (tdep->sc_reg_offset[i] != -1)
      cache->saved_regs[i] = addr + tdep->sc_reg_offset[i];

  *this_cache = cache;
  return cache;
d810 2
a811 3
static void
x86_64_sigtramp_frame_this_id (struct frame_info *next_frame,
			       void **this_cache, struct frame_id *this_id)
d813 1
a813 2
  struct x86_64_frame_cache *cache =
    x86_64_sigtramp_frame_cache (next_frame, this_cache);
d815 4
a818 1
  (*this_id) = frame_id_build (cache->base + 16, frame_pc_unwind (next_frame));
d820 1
a821 9
static void
x86_64_sigtramp_frame_prev_register (struct frame_info *next_frame,
				     void **this_cache,
				     int regnum, int *optimizedp,
				     enum lval_type *lvalp, CORE_ADDR *addrp,
				     int *realnump, void *valuep)
{
  /* Make sure we've initialized the cache.  */
  x86_64_sigtramp_frame_cache (next_frame, this_cache);
d823 2
a824 3
  x86_64_frame_prev_register (next_frame, this_cache, regnum,
			      optimizedp, lvalp, addrp, realnump, valuep);
}
d826 2
a827 9
static const struct frame_unwind x86_64_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  x86_64_sigtramp_frame_this_id,
  x86_64_sigtramp_frame_prev_register
};

static const struct frame_unwind *
x86_64_sigtramp_frame_sniffer (struct frame_info *next_frame)
d829 7
a835 12
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  char *name;

  find_pc_partial_function (pc, &name, NULL, NULL);
  if (PC_IN_SIGTRAMP (pc, name))
    {
      gdb_assert (gdbarch_tdep (current_gdbarch)->sigcontext_addr);

      return &x86_64_sigtramp_frame_unwind;
    }

  return NULL;
d839 4
a842 2
static CORE_ADDR
x86_64_frame_base_address (struct frame_info *next_frame, void **this_cache)
d844 1
a844 4
  struct x86_64_frame_cache *cache =
    x86_64_frame_cache (next_frame, this_cache);

  return cache->base;
d847 2
a848 1
static const struct frame_base x86_64_frame_base =
d850 1
a850 16
  &x86_64_frame_unwind,
  x86_64_frame_base_address,
  x86_64_frame_base_address,
  x86_64_frame_base_address
};

static struct frame_id
x86_64_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  char buf[8];
  CORE_ADDR fp;

  frame_unwind_register (next_frame, X86_64_RBP_REGNUM, buf);
  fp = extract_unsigned_integer (buf, 8);

  return frame_id_build (fp + 16, frame_pc_unwind (next_frame));
d853 3
a855 1
/* 16 byte align the SP per frame requirements.  */
d857 3
a859 2
static CORE_ADDR
x86_64_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
d861 40
a900 3
  return sp & -(CORE_ADDR)16;
}

d902 1
a902 12
/* Supply register REGNUM from the floating-point register set REGSET
   to register cache REGCACHE.  If REGNUM is -1, do this for all
   registers in REGSET.  */

static void
x86_64_supply_fpregset (const struct regset *regset, struct regcache *regcache,
			int regnum, const void *fpregs, size_t len)
{
  const struct gdbarch_tdep *tdep = regset->descr;

  gdb_assert (len == tdep->sizeof_fpregset);
  x86_64_supply_fxsave (regcache, regnum, fpregs);
d905 20
a924 10
/* Return the appropriate register set for the core section identified
   by SECT_NAME and SECT_SIZE.  */

static const struct regset *
x86_64_regset_from_core_section (struct gdbarch *gdbarch,
				 const char *sect_name, size_t sect_size)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (strcmp (sect_name, ".reg2") == 0 && sect_size == tdep->sizeof_fpregset)
d926 1
a926 1
      if (tdep->fpregset == NULL)
d928 36
a963 3
	  tdep->fpregset = XMALLOC (struct regset);
	  tdep->fpregset->descr = tdep;
	  tdep->fpregset->supply_regset = x86_64_supply_fpregset;
a964 2

      return tdep->fpregset;
d967 2
a968 3
  return i386_regset_from_core_section (gdbarch, sect_name, sect_size);
}

d970 15
a984 8
void
x86_64_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* AMD64 generally uses `fxsave' instead of `fsave' for saving its
     floating-point registers.  */
  tdep->sizeof_fpregset = I387_SIZEOF_FXSAVE;
a985 5
  /* AMD64 has an FPU and 16 SSE registers.  */
  tdep->st0_regnum = X86_64_ST0_REGNUM;
  tdep->num_xmm_regs = 16;

  /* This is what all the fuss is about.  */
d990 1
a990 4
  /* In contrast to the i386, on the x86-64 a `long double' actually
     takes up 128 bits, even though it's still based on the i387
     extended floating-point format which has only 80 significant bits.  */
  set_gdbarch_long_double_bit (gdbarch, 128);
d994 108
a1101 1
  set_gdbarch_register_type (gdbarch, x86_64_register_type);
d1103 2
a1104 31
  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, X86_64_RSP_REGNUM); /* %rsp */
  set_gdbarch_pc_regnum (gdbarch, X86_64_RIP_REGNUM); /* %rip */
  set_gdbarch_ps_regnum (gdbarch, X86_64_EFLAGS_REGNUM); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, X86_64_ST0_REGNUM); /* %st(0) */

  /* The "default" register numbering scheme for the x86-64 is
     referred to as the "DWARF Register Number Mapping" in the System
     V psABI.  The preferred debugging format for all known x86-64
     targets is actually DWARF2, and GCC doesn't seem to support DWARF
     (that is DWARF-1), but we provide the same mapping just in case.
     This mapping is also used for stabs, which GCC does support.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, x86_64_dwarf_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, x86_64_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, x86_64_dwarf_reg_to_regnum);

  /* We don't override SDB_REG_RO_REGNUM, since COFF doesn't seem to
     be in use on any of the supported x86-64 targets.  */

  /* Call dummy code.  */
  set_gdbarch_push_dummy_call (gdbarch, x86_64_push_dummy_call);
  set_gdbarch_frame_align (gdbarch, x86_64_frame_align);
  set_gdbarch_frame_red_zone_size (gdbarch, 128);

  set_gdbarch_convert_register_p (gdbarch, x86_64_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, i387_register_to_value);
  set_gdbarch_value_to_register (gdbarch, i387_value_to_register);

  set_gdbarch_return_value (gdbarch, amd64_return_value);
  /* Override, since this is handled by x86_64_extract_return_value.  */
  set_gdbarch_extract_struct_value_address (gdbarch, NULL);
d1108 8
a1115 9
  /* Avoid wiring in the MMX registers for now.  */
  set_gdbarch_num_pseudo_regs (gdbarch, 0);
  tdep->mm0_regnum = -1;

  set_gdbarch_unwind_dummy_id (gdbarch, x86_64_unwind_dummy_id);

  /* FIXME: kettenis/20021026: This is ELF-specific.  Fine for now,
     since all supported x86-64 targets are ELF, but that might change
     in the future.  */
d1118 7
a1124 10
  frame_unwind_append_sniffer (gdbarch, x86_64_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, x86_64_frame_sniffer);
  frame_base_set_default (gdbarch, &x86_64_frame_base);

  /* If we have a register mapping, enable the generic core file support.  */
  if (tdep->gregset_reg_offset)
    set_gdbarch_regset_from_core_section (gdbarch,
					  x86_64_regset_from_core_section);
}

d1126 1
a1126 1
#define I387_ST0_REGNUM X86_64_ST0_REGNUM
d1128 2
a1129 11
/* The 64-bit FXSAVE format differs from the 32-bit format in the
   sense that the instruction pointer and data pointer are simply
   64-bit offsets into the code segment and the data segment instead
   of a selector offset pair.  The functions below store the upper 32
   bits of these pointers (instead of just the 16-bits of the segment
   selector).  */

/* Fill register REGNUM in REGCACHE with the appropriate
   floating-point or SSE register value from *FXSAVE.  If REGNUM is
   -1, do this for all registers.  This function masks off any of the
   reserved bits in *FXSAVE.  */
d1132 1
a1132 2
x86_64_supply_fxsave (struct regcache *regcache, int regnum,
		      const void *fxsave)
d1134 1
a1134 1
  i387_supply_fxsave (regcache, regnum, fxsave);
d1136 4
a1139 3
  if (fxsave)
    {
      const char *regs = fxsave;
d1141 7
a1147 6
      if (regnum == -1 || regnum == I387_FISEG_REGNUM)
	regcache_raw_supply (regcache, I387_FISEG_REGNUM, regs + 12);
      if (regnum == -1 || regnum == I387_FOSEG_REGNUM)
	regcache_raw_supply (regcache, I387_FOSEG_REGNUM, regs + 20);
    }
}
d1149 2
a1150 4
/* Fill register REGNUM (if it is a floating-point or SSE register) in
   *FXSAVE with the value in GDB's register cache.  If REGNUM is -1, do
   this for all registers.  This function doesn't touch any of the
   reserved bits in *FXSAVE.  */
d1152 3
a1154 4
void
x86_64_fill_fxsave (char *fxsave, int regnum)
{
  i387_fill_fxsave (fxsave, regnum);
d1156 6
a1161 4
  if (regnum == -1 || regnum == I387_FISEG_REGNUM)
    regcache_collect (I387_FISEG_REGNUM, fxsave + 12);
  if (regnum == -1 || regnum == I387_FOSEG_REGNUM)
    regcache_collect (I387_FOSEG_REGNUM, fxsave + 20);
@


1.27.4.3
log
@Merge from mainline.
@
text
@d160 2
a161 2
  /* Return Address RA.  Mapped to RIP.  */
  X86_64_RIP_REGNUM,
@


1.27.4.4
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d1 1
a1 1
/* Target-dependent code for AMD64.
d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a42 7
/* Note that the AMD64 architecture was previously known as x86-64.
   The latter is (forever) engraved into the canonical system name as
   returned bu config.guess, and used as the name for the AMD64 port
   of GNU/Linux.  The BSD's have renamed their ports to amd64; they
   don't like to shout.  For GDB we prefer the amd64_-prefix over the
   x86_64_-prefix since it's so much easier to type.  */

d45 1
a45 1
struct amd64_register_info
d51 1
a51 1
static struct amd64_register_info amd64_register_info[] =
a72 2
  { "cs", &builtin_type_int32 },
  { "ss", &builtin_type_int32 },
d78 1
a78 1
  /* %st0 is register number 24.  */
d96 1
a96 1
  /* %xmm0 is register number 40.  */
d117 2
a118 2
#define AMD64_NUM_REGS \
  (sizeof (amd64_register_info) / sizeof (amd64_register_info[0]))
d123 1
a123 1
amd64_register_name (int regnum)
d125 2
a126 2
  if (regnum >= 0 && regnum < AMD64_NUM_REGS)
    return amd64_register_info[regnum].name;
d135 1
a135 1
amd64_register_type (struct gdbarch *gdbarch, int regnum)
d137 1
a137 1
  gdb_assert (regnum >= 0 && regnum < AMD64_NUM_REGS);
d139 1
a139 1
  return *amd64_register_info[regnum].type;
d145 1
a145 1
static int amd64_dwarf_regmap[] =
d182 2
a183 2
static const int amd64_dwarf_regmap_len =
  (sizeof (amd64_dwarf_regmap) / sizeof (amd64_dwarf_regmap[0]));
d189 1
a189 1
amd64_dwarf_reg_to_regnum (int reg)
d193 2
a194 2
  if (reg >= 0 || reg < amd64_dwarf_regmap_len)
    regnum = amd64_dwarf_regmap[reg];
d206 1
a206 1
amd64_convert_register_p (int regnum, struct type *type)
a263 13
/* Return non-zero if TYPE is a non-POD structure or union type.  */

static int
amd64_non_pod_p (struct type *type)
{
  /* ??? A class with a base class certainly isn't POD, but does this
     catch all non-POD structure types?  */
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT && TYPE_N_BASECLASSES (type) > 0)
    return 1;

  return 0;
}

d275 1
a275 1
  if (len > 16 || amd64_non_pod_p (type))
a311 4
	  /* Ignore static fields.  */
	  if (TYPE_FIELD_STATIC (type, i))
	    continue;

d471 1
a471 1
		      struct value **args, CORE_ADDR sp, int struct_return)
a494 4
  /* Reserve a register for the "hidden" argument.  */
  if (struct_return)
    integer_reg++;

d595 4
a598 4
amd64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		       struct regcache *regcache, CORE_ADDR bp_addr,
		       int nargs, struct value **args,	CORE_ADDR sp,
		       int struct_return, CORE_ADDR struct_addr)
d603 1
a603 1
  sp = amd64_push_arguments (regcache, nargs, args, sp, struct_return);
d629 1
a629 1
#define AMD64_NUM_SAVED_REGS	X86_64_NUM_GREGS
d631 1
a631 1
struct amd64_frame_cache
d639 1
a639 1
  CORE_ADDR saved_regs[AMD64_NUM_SAVED_REGS];
d648 2
a649 2
static struct amd64_frame_cache *
amd64_alloc_frame_cache (void)
d651 1
a651 1
  struct amd64_frame_cache *cache;
d654 1
a654 1
  cache = FRAME_OBSTACK_ZALLOC (struct amd64_frame_cache);
d663 1
a663 1
  for (i = 0; i < AMD64_NUM_SAVED_REGS; i++)
d686 2
a687 2
amd64_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
			struct amd64_frame_cache *cache)
d725 1
a725 1
amd64_skip_prologue (CORE_ADDR start_pc)
d727 1
a727 1
  struct amd64_frame_cache cache;
d730 1
a730 1
  pc = amd64_analyze_prologue (start_pc, 0xffffffffffffffff, &cache);
d740 2
a741 2
static struct amd64_frame_cache *
amd64_frame_cache (struct frame_info *next_frame, void **this_cache)
d743 1
a743 1
  struct amd64_frame_cache *cache;
d750 1
a750 1
  cache = amd64_alloc_frame_cache ();
d755 1
a755 1
    amd64_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);
d787 1
a787 1
  for (i = 0; i < AMD64_NUM_SAVED_REGS; i++)
d795 2
a796 2
amd64_frame_this_id (struct frame_info *next_frame, void **this_cache,
		     struct frame_id *this_id)
d798 2
a799 2
  struct amd64_frame_cache *cache =
    amd64_frame_cache (next_frame, this_cache);
d809 4
a812 4
amd64_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			   int regnum, int *optimizedp,
			   enum lval_type *lvalp, CORE_ADDR *addrp,
			   int *realnump, void *valuep)
d814 2
a815 2
  struct amd64_frame_cache *cache =
    amd64_frame_cache (next_frame, this_cache);
d833 1
a833 1
  if (regnum < AMD64_NUM_SAVED_REGS && cache->saved_regs[regnum] != -1)
d852 1
a852 1
static const struct frame_unwind amd64_frame_unwind =
d855 2
a856 2
  amd64_frame_this_id,
  amd64_frame_prev_register
d860 1
a860 1
amd64_frame_sniffer (struct frame_info *next_frame)
d862 1
a862 1
  return &amd64_frame_unwind;
d872 2
a873 2
static struct amd64_frame_cache *
amd64_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
d875 1
a875 1
  struct amd64_frame_cache *cache;
d884 1
a884 1
  cache = amd64_alloc_frame_cache ();
d891 1
a891 1
  gdb_assert (tdep->sc_num_regs <= AMD64_NUM_SAVED_REGS);
d901 2
a902 2
amd64_sigtramp_frame_this_id (struct frame_info *next_frame,
			      void **this_cache, struct frame_id *this_id)
d904 2
a905 2
  struct amd64_frame_cache *cache =
    amd64_sigtramp_frame_cache (next_frame, this_cache);
d911 5
a915 5
amd64_sigtramp_frame_prev_register (struct frame_info *next_frame,
				    void **this_cache,
				    int regnum, int *optimizedp,
				    enum lval_type *lvalp, CORE_ADDR *addrp,
				    int *realnump, void *valuep)
d918 1
a918 1
  amd64_sigtramp_frame_cache (next_frame, this_cache);
d920 2
a921 2
  amd64_frame_prev_register (next_frame, this_cache, regnum,
			     optimizedp, lvalp, addrp, realnump, valuep);
d924 1
a924 1
static const struct frame_unwind amd64_sigtramp_frame_unwind =
d927 2
a928 2
  amd64_sigtramp_frame_this_id,
  amd64_sigtramp_frame_prev_register
d932 1
a932 1
amd64_sigtramp_frame_sniffer (struct frame_info *next_frame)
d942 1
a942 1
      return &amd64_sigtramp_frame_unwind;
d950 1
a950 1
amd64_frame_base_address (struct frame_info *next_frame, void **this_cache)
d952 2
a953 2
  struct amd64_frame_cache *cache =
    amd64_frame_cache (next_frame, this_cache);
d958 1
a958 1
static const struct frame_base amd64_frame_base =
d960 4
a963 4
  &amd64_frame_unwind,
  amd64_frame_base_address,
  amd64_frame_base_address,
  amd64_frame_base_address
d967 1
a967 1
amd64_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d981 1
a981 1
amd64_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
d992 2
a993 2
amd64_supply_fpregset (const struct regset *regset, struct regcache *regcache,
		       int regnum, const void *fpregs, size_t len)
d1005 2
a1006 2
amd64_regset_from_core_section (struct gdbarch *gdbarch,
				const char *sect_name, size_t sect_size)
d1016 1
a1016 1
	  tdep->fpregset->supply_regset = amd64_supply_fpregset;
d1044 3
a1046 3
  /* In contrast to the i386, on AMD64 a `long double' actually takes
     up 128 bits, even though it's still based on the i387 extended
     floating-point format which has only 80 significant bits.  */
d1049 3
a1051 3
  set_gdbarch_num_regs (gdbarch, AMD64_NUM_REGS);
  set_gdbarch_register_name (gdbarch, amd64_register_name);
  set_gdbarch_register_type (gdbarch, amd64_register_type);
d1059 9
a1067 9
  /* The "default" register numbering scheme for AMD64 is referred to
     as the "DWARF Register Number Mapping" in the System V psABI.
     The preferred debugging format for all known AMD64 targets is
     actually DWARF2, and GCC doesn't seem to support DWARF (that is
     DWARF-1), but we provide the same mapping just in case.  This
     mapping is also used for stabs, which GCC does support.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, amd64_dwarf_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, amd64_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, amd64_dwarf_reg_to_regnum);
d1070 1
a1070 1
     be in use on any of the supported AMD64 targets.  */
d1073 2
a1074 2
  set_gdbarch_push_dummy_call (gdbarch, amd64_push_dummy_call);
  set_gdbarch_frame_align (gdbarch, amd64_frame_align);
d1077 1
a1077 1
  set_gdbarch_convert_register_p (gdbarch, amd64_convert_register_p);
d1082 1
a1082 1
  /* Override, since this is handled by amd64_extract_return_value.  */
d1085 1
a1085 1
  set_gdbarch_skip_prologue (gdbarch, amd64_skip_prologue);
d1091 1
a1091 1
  set_gdbarch_unwind_dummy_id (gdbarch, amd64_unwind_dummy_id);
d1094 1
a1094 1
     since all supported AMD64 targets are ELF, but that might change
d1098 3
a1100 3
  frame_unwind_append_sniffer (gdbarch, amd64_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, amd64_frame_sniffer);
  frame_base_set_default (gdbarch, &amd64_frame_base);
d1105 1
a1105 1
					  amd64_regset_from_core_section);
@


1.27.4.5
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d1112 2
@


1.27.2.1
log
@2002-10-21  David Carlton  <carlton@@math.stanford.edu>

	* buildsym.c (add_symbol_to_list): Expand comment.
	* objc-lang.c (find_methods): Use BLOCK_START, BLOCK_END.
	* Makefile.in (x86-64-tdep.o): Depend on block_h.
	* x86-64-tdep.c (x86_64_skip_prologue): Use BLOCK_END and
	SYMBOL_BLOCK_VALUE.
@
text
@a34 1
#include "block.h"
d892 1
a892 1
  endaddr = BLOCK_END (SYMBOL_BLOCK_VALUE (v_function));
@


1.27.2.2
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d908 1
a908 1
x86_64_breakpoint_from_pc (CORE_ADDR *pc, int *lenptr)
d1030 1
a1030 1
  set_gdbarch_frame_chain (gdbarch, x86_64_linux_frame_chain);
d1045 1
a1045 1
  set_gdbarch_init_frame_pc (gdbarch, x86_64_init_frame_pc);
d1048 1
a1048 1
  set_gdbarch_init_extra_frame_info (gdbarch, x86_64_init_extra_frame_info);
d1058 2
a1059 1
  set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
d1095 1
a1095 2
  set_gdbarch_deprecated_extract_return_value (gdbarch,
					       x86_64_extract_return_value);
d1100 1
a1100 2
  set_gdbarch_deprecated_store_return_value (gdbarch,
					     x86_64_store_return_value);
a1124 2

  set_gdbarch_pc_in_sigtramp (gdbarch, x86_64_linux_in_sigtramp);
@


1.27.2.3
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d4 1
a179 9
/* FIXME: cagney/2002-11-11: Once the i386 and x86-64 targets are
   merged, this function can go away.  */
int
i386_fp_regnum_p (int regnum)
{
  return (regnum < NUM_REGS
	  && (FP0_REGNUM && FP0_REGNUM <= (regnum) && (regnum) < FPC_REGNUM));
}

a254 3
/* Push the return address (pointing to the call dummy) onto the stack
   and return the new value for the stack pointer.  */

d261 1
d266 1
a266 1
static void
d304 2
a305 2
  /* Rule #2: If one of the classes is NO_CLASS, the resulting class
     is the other class.  */
a331 5
/* Classify the argument type.  CLASSES will be filled by the register
   class used to pass each word of the operand.  The number of words
   is returned.  In case the parameter should be passed in memory, 0
   is returned.  As a special case for zero sized containers,
   classes[0] will be NO_CLASS and 1 is returned.
d333 8
a340 1
   See the x86-64 psABI for details.  */
d365 2
a366 2
	/* Zero sized arrays or structures are NO_CLASS.  We return 0
	   to signalize memory class, so handle it as special case.  */
d449 1
a449 1
	    /* X86_64_X87UP_CLASS should be preceeded by X86_64_X87_CLASS.  */
d503 2
a504 3
/* Examine the argument and set *INT_NREGS and *SSE_NREGS to the
   number of registers required based on the information passed in
   CLASSES.  Return 0 if parameter should be passed in memory.  */
d542 3
a544 3
   memory. If this function returns 1, GDB will call
   STORE_STRUCT_RETURN and EXTRACT_STRUCT_VALUE_ADDRESS else
   STORE_RETURN_VALUE and EXTRACT_RETURN_VALUE will be used.  */
d558 1
d641 1
a644 1
  /* Do nothing.  Everything is handled by the stack unwinding code.  */
d697 3
a699 3
		  deprecated_write_register_gen (int_parameter_registers
						 [(intreg + 1) / 2],
						 VALUE_CONTENTS_ALL (args[i]) + offset);
d704 2
a705 2
		  deprecated_write_register_gen (int_parameter_registers[intreg / 2],
						 VALUE_CONTENTS_ALL (args[i]) + offset);
d712 3
a714 3
		  deprecated_write_register_gen (sse_parameter_registers
						 [(ssereg + 1) / 2],
						 VALUE_CONTENTS_ALL (args[i]) + offset);
d719 2
a720 2
		  deprecated_write_register_gen (sse_parameter_registers[ssereg / 2],
						 VALUE_CONTENTS_ALL (args[i]) + offset);
d765 2
a766 2
	  deprecated_write_register_bytes (REGISTER_BYTE (FP0_REGNUM), valbuf,
					   FPU_REG_RAW_SIZE);
d779 2
a780 2
	  deprecated_write_register_bytes (REGISTER_BYTE (FP0_REGNUM), buf,
					   FPU_REG_RAW_SIZE);
d789 1
a789 1
	deprecated_write_register_bytes (REGISTER_BYTE (0), valbuf, len);
d792 3
a794 4
	  deprecated_write_register_bytes (REGISTER_BYTE (0), valbuf,
					   low_size);
	  deprecated_write_register_bytes (REGISTER_BYTE (1),
					   valbuf + low_size, len - low_size);
a865 1
  unsigned char prolog_buf[PROLOG_BUFSIZE];
d867 6
a872 6
  /* We will handle only functions starting with: */
  static unsigned char prolog_expect[PROLOG_BUFSIZE] =
  {
    0x55,			/* pushq %rbp */
    0x48, 0x89, 0xe5		/* movq %rsp, %rbp */
  };
d876 1
a876 1
  /* First check, whether pc points to pushq %rbp, movq %rsp, %rbp.  */
d879 1
a879 1
      return pc;		/* ... no, it doesn't.  Nothing to skip.  */
d881 1
a881 1
  /* OK, we have found the prologue and want PC of the first
d888 2
a889 2
  /* If pc doesn't point to a function with debuginfo, some of the
     following may be NULL.  */
d907 1
a907 1
static const unsigned char *
d915 2
a916 2
static void
x86_64_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
d918 2
a919 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d922 64
a985 2
  /* The x86-64 has 16 SSE registers.  */
  tdep->num_xmm_regs = 16;
a986 1
  /* This is what all the fuss is about.  */
d991 1
a991 4
  /* In contrast to the i386, on the x86-64 a `long double' actually
     takes up 128 bits, even though it's still based on the i387
     extended floating-point format which has only 80 significant bits.  */
  set_gdbarch_long_double_bit (gdbarch, 128);
a993 21

  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, 7); /* %rsp */
  set_gdbarch_fp_regnum (gdbarch, 6); /* %rbp */
  set_gdbarch_pc_regnum (gdbarch, 16); /* %rip */
  set_gdbarch_ps_regnum (gdbarch, 17); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, X86_64_NUM_GREGS); /* %st(0) */

  /* The "default" register numbering scheme for the x86-64 is
     referred to as the "DWARF register number mapping" in the psABI.
     The preferred debugging format for all known x86-64 targets is
     actually DWARF2, and GCC doesn't seem to support DWARF (that is
     DWARF-1), but we provide the same mapping just in case.  This
     mapping is also used for stabs, which GCC does support.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, x86_64_dwarf2_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, x86_64_dwarf2_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, x86_64_dwarf2_reg_to_regnum);

  /* We don't override SDB_REG_RO_REGNUM, sice COFF doesn't seem to be
     in use on any of the supported x86-64 targets.  */

d996 3
d1000 2
a1001 3
  /* Total amount of space needed to store our copies of the machine's
     register (SIZEOF_GREGS + SIZEOF_FPU_REGS + SIZEOF_FPU_CTRL_REGS +
     SIZEOF_SSE_REGS) */
d1005 2
a1007 2
  set_gdbarch_register_raw_size (gdbarch, x86_64_register_raw_size);
  set_gdbarch_register_byte (gdbarch, x86_64_register_byte);
a1009 4
  /* FIXME: kettenis/20021026: As long as we don't support longjmp,
     that is, as long as we have `tdep->jb_pc_offset == -1', using
     i386_get_longjmp_target is fine.  */

d1016 6
a1021 2
  /* Getting saved registers is handled by unwind information.  */
  set_gdbarch_get_saved_register (gdbarch, cfi_get_saved_register);
a1022 1
  /* FIXME: kettenis/20021026: Should we set parm_boundary to 64 here?  */
d1025 1
a1025 6
  /* FIXME: kettenis/20021026: Should be undeprecated.  */
  set_gdbarch_extract_return_value (gdbarch, NULL);
  set_gdbarch_deprecated_extract_return_value (gdbarch,
					       x86_64_extract_return_value);
  set_gdbarch_push_arguments (gdbarch, x86_64_push_arguments);
  set_gdbarch_push_return_address (gdbarch, x86_64_push_return_address);
a1026 8
  set_gdbarch_store_struct_return (gdbarch, x86_64_store_struct_return);
  /* FIXME: kettenis/20021026: Should be undeprecated.  */
  set_gdbarch_store_return_value (gdbarch, NULL);
  set_gdbarch_deprecated_store_return_value (gdbarch,
					     x86_64_store_return_value);
  /* Override, since this is handled by x86_64_extract_return_value.  */
  set_gdbarch_extract_struct_value_address (gdbarch, NULL);
  set_gdbarch_use_struct_convention (gdbarch, x86_64_use_struct_convention);
d1028 3
a1030 2
  set_gdbarch_frame_init_saved_regs (gdbarch, x86_64_frame_init_saved_regs);
  set_gdbarch_skip_prologue (gdbarch, x86_64_skip_prologue);
a1031 1
  set_gdbarch_frame_chain (gdbarch, x86_64_linux_frame_chain);
d1033 1
a1033 6
					 x86_64_frameless_function_invocation);
  /* FIXME: kettenis/20021025: Shouldn't this be set to
     generic_file_frame_chain_valid?  */
  set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
  /* FIXME: kettenis/20021026: These two are GNU/Linux-specific and
     should be moved elsewhere.  */
a1034 4
  set_gdbarch_saved_pc_after_call (gdbarch, x86_64_linux_saved_pc_after_call);
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
  /* FIXME: kettenis/20021026: This one is GNU/Linux-specific too.  */
  set_gdbarch_pc_in_sigtramp (gdbarch, x86_64_linux_in_sigtramp);
d1036 2
a1037 2
  /* Build call frame information (CFI) from DWARF2 frame debug info.  */
  set_gdbarch_dwarf2_build_frame_info (gdbarch, dwarf2_build_frame_info);
d1039 2
a1040 2
  /* Initialization of per-frame CFI.  */
  set_gdbarch_init_extra_frame_info (gdbarch, cfi_init_extra_frame_info);
d1042 3
a1044 1
  /* Frame PC initialization is handled by using CFI.  */
d1047 5
a1051 2
  /* Cons up virtual frame pointer for trace.  */
  set_gdbarch_virtual_frame_pointer (gdbarch, cfi_virtual_frame_pointer);
d1053 1
a1053 5
  /* FIXME: kettenis/20021026: This is ELF-specific.  Fine for now,
     since all supported x86-64 targets are ELF, but that might change
     in the future.  */
  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
}
d1055 2
a1056 6
static struct gdbarch *
x86_64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
d1058 1
a1058 3
  /* Try to determine the OS ABI of the object we're loading.  */
  if (info.abfd != NULL)
    osabi = gdbarch_lookup_osabi (info.abfd);
d1060 16
a1075 10
  /* Find a candidate among extant architectures.  */
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      /* Make sure the OS ABI selection matches.  */
      tdep = gdbarch_tdep (arches->gdbarch);
      if (tdep && tdep->osabi == osabi)
        return arches->gdbarch;
    }
d1077 4
a1080 3
  /* Allocate space for the new architecture.  */
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);
d1082 4
a1085 1
  tdep->osabi = osabi;
d1087 3
a1089 3
  /* FIXME: kettenis/20021025: The following calls are going to
     disappear when we integrate the x86_64 target into the i386
     target.  */
d1091 5
a1095 1
  set_gdbarch_long_double_format (gdbarch, &floatformat_i387_ext);
a1096 2
  set_gdbarch_max_register_raw_size (gdbarch, 16);
  set_gdbarch_max_register_virtual_size (gdbarch, 16);
d1098 5
a1102 1
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
d1104 1
a1104 2
  set_gdbarch_breakpoint_from_pc (gdbarch, x86_64_breakpoint_from_pc);
  set_gdbarch_decr_pc_after_break (gdbarch, 1);
d1107 1
a1107 3
  set_gdbarch_frame_args_skip (gdbarch, 8);
  set_gdbarch_frame_args_address (gdbarch, default_frame_address);
  set_gdbarch_frame_locals_address (gdbarch, default_frame_address);
d1109 1
a1109 1
  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);
d1111 1
a1111 11
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
  set_gdbarch_call_dummy_address (gdbarch, entry_point_address);
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
  set_gdbarch_call_dummy_length (gdbarch, 0);
  set_gdbarch_call_dummy_p (gdbarch, 1);
  set_gdbarch_call_dummy_words (gdbarch, NULL);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, 0);
  set_gdbarch_fix_call_dummy (gdbarch, generic_fix_call_dummy);
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
d1113 3
a1115 1
  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_at_entry_point);
d1117 1
a1117 1
  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);
d1119 3
a1121 1
  /* FIXME: kettenis/20021025: These already are the default.  */
d1123 3
a1125 2
  set_gdbarch_register_virtual_size (gdbarch, generic_register_size);
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, 0);
d1127 1
a1127 1
  x86_64_init_abi (info, gdbarch);
@


1.27.2.4
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d179 9
d925 1
a925 1
void
a1028 2
  set_gdbarch_num_pseudo_regs (gdbarch, 0);

d1036 1
a1036 1
  set_gdbarch_deprecated_init_frame_pc (gdbarch, x86_64_init_frame_pc);
d1047 75
d1125 2
d1138 14
@


1.27.2.5
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d971 4
d988 1
a988 1
  set_gdbarch_extract_return_value (gdbarch, legacy_extract_return_value);
d996 1
a996 1
  set_gdbarch_store_return_value (gdbarch, legacy_store_return_value);
d1009 3
@


1.27.2.6
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d563 1
a563 2
x86_64_extract_return_value (struct type *type, struct regcache *regcache,
			     void *valbuf)
d580 1
a580 1
      regcache_cooked_read (regcache, RAX_REGNUM, &addr);
d594 3
a596 2
	      regcache_cooked_read (regcache, ret_int_r[(intreg + 1) / 2],
				    (char *) valbuf + offset);
d601 2
a602 2
	      regcache_cooked_read_part (regcache, ret_int_r[intreg / 2],
					 0, 4, (char *) valbuf + offset);
d609 3
a611 3
	      regcache_cooked_read_part (regcache,
					 ret_sse_r[(ssereg + 1) / 2], 0, 8,
					 (char *) valbuf + offset);
d616 2
a617 2
	      regcache_cooked_read_part (regcache, ret_sse_r[ssereg / 2],
					 0, 8, (char *) valbuf + offset);
d622 2
a623 2
	      regcache_cooked_read_part (regcache, FP0_REGNUM,
					 0, 8, (char *) valbuf + offset);
d627 2
a628 2
	      regcache_cooked_read_part (regcache, FP0_REGNUM,
					 8, 2, (char *) valbuf + offset);
d753 1
a753 2
x86_64_store_return_value (struct type *type, struct regcache *regcache,
			   const void *valbuf)
d764 2
a765 1
	  regcache_cooked_write (regcache, FP0_REGNUM, valbuf);
d778 2
a779 2
	  regcache_cooked_write_part (regcache, FP0_REGNUM,
			  	      0, FPU_REG_RAW_SIZE, buf);
d788 1
a788 1
        regcache_cooked_write_part (regcache, 0, 0, len, valbuf);
d791 4
a794 4
 	  regcache_cooked_write_part (regcache, 0, 0, low_size, valbuf);
 	  regcache_cooked_write_part (regcache, 1, 0,
 				      len - low_size,
 				      (const char *) valbuf + low_size);
d983 4
a986 2
  set_gdbarch_extract_return_value (gdbarch, x86_64_extract_return_value);

d991 4
a994 1
  set_gdbarch_store_return_value (gdbarch, x86_64_store_return_value);
d999 1
a999 1
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, x86_64_frame_init_saved_regs);
d1019 1
a1019 1
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, cfi_init_extra_frame_info);
@


1.27.2.7
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d243 11
a473 2
    case TYPE_CODE_ENUM:
    case TYPE_CODE_REF:
d703 5
a707 11
		  {
		    LONGEST num
		      = extract_signed_integer (VALUE_CONTENTS_ALL (args[i])
						+ offset, 4);
		    regcache_raw_write_signed (current_regcache,
					       int_parameter_registers[intreg / 2],                                           num);

		    offset += 8;
		    intreg++;
		    break;
		  }
d776 1
a776 1
	  val = deprecated_extract_floating (valbuf, TYPE_LENGTH (type));
d823 17
a853 24
/* We will handle only functions beginning with:
   55          pushq %rbp
   48 89 e5    movq %rsp,%rbp
   Any function that doesn't start with this sequence
   will be assumed to have no prologue and thus no valid
   frame pointer in %rbp.  */
#define PROLOG_BUFSIZE 4
int
x86_64_function_has_prologue (CORE_ADDR pc)
{
  int i;
  unsigned char prolog_expect[PROLOG_BUFSIZE] = { 0x55, 0x48, 0x89, 0xe5 },
    prolog_buf[PROLOG_BUFSIZE];

  read_memory (pc, (char *) prolog_buf, PROLOG_BUFSIZE);

  /* First check, whether pc points to pushq %rbp, movq %rsp,%rbp.  */
  for (i = 0; i < PROLOG_BUFSIZE; i++)
    if (prolog_expect[i] != prolog_buf[i])
      return 0;		/* ... no, it doesn't. Nothing to skip.  */
  
  return 1;
}

d858 1
d866 1
d868 13
a880 2
  if (! x86_64_function_has_prologue (pc))
    return pc;
d907 7
a913 15
static void
x86_64_save_dummy_frame_tos (CORE_ADDR sp)
{
  /* We must add the size of the return address that is already 
     put on the stack.  */
  generic_save_dummy_frame_tos (sp + 
				TYPE_LENGTH (builtin_type_void_func_ptr));
}

static struct frame_id
x86_64_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *frame)
{
  CORE_ADDR base;
  frame_unwind_unsigned_register (frame, SP_REGNUM, &base);
  return frame_id_build (base, frame_pc_unwind (frame));
d978 1
a978 1
  set_gdbarch_deprecated_get_saved_register (gdbarch, cfi_get_saved_register);
d985 4
a988 4
  set_gdbarch_deprecated_push_arguments (gdbarch, x86_64_push_arguments);
  set_gdbarch_deprecated_push_return_address (gdbarch, x86_64_push_return_address);
  set_gdbarch_deprecated_pop_frame (gdbarch, x86_64_pop_frame);
  set_gdbarch_deprecated_store_struct_return (gdbarch, x86_64_store_struct_return);
d997 1
a997 1
  set_gdbarch_deprecated_frame_chain (gdbarch, x86_64_linux_frame_chain);
d1002 2
a1003 2
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, x86_64_linux_frame_saved_pc);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, x86_64_linux_saved_pc_after_call);
a1025 4
  
  /* Dummy frame helper functions.  */
  set_gdbarch_save_dummy_frame_tos (gdbarch, x86_64_save_dummy_frame_tos);
  set_gdbarch_unwind_dummy_id (gdbarch, x86_64_unwind_dummy_id);
@


1.27.2.8
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d938 1
a938 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, 6); /* %rbp */
d980 1
a980 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, cfi_read_fp);
@


1.27.2.9
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d115 1
a115 1
  0, 3, 2, 1,			/* RAX, RDX, RCX, RBX */
d957 1
a957 1
  set_gdbarch_deprecated_register_size (gdbarch, 8);
d964 1
a964 1
  set_gdbarch_deprecated_register_bytes (gdbarch, sum);
@


1.27.2.10
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a23 6
#include "arch-utils.h"
#include "block.h"
#include "dummy-frame.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
d25 1
d27 1
a27 2
#include "gdbcore.h"
#include "objfiles.h"
d30 3
a32 1

d34 1
a34 3

#include "x86-64-tdep.h"
#include "i387-tdep.h"
d37 6
d44 1
a44 12
#define X86_64_RAX_REGNUM	0 /* %rax */
#define X86_64_RDX_REGNUM	3 /* %rdx */
#define X86_64_RDI_REGNUM	5 /* %rdi */
#define X86_64_RBP_REGNUM	6 /* %rbp */
#define X86_64_RSP_REGNUM	7 /* %rsp */
#define X86_64_RIP_REGNUM	16 /* %rip */
#define X86_64_EFLAGS_REGNUM	17 /* %eflags */
#define X86_64_ST0_REGNUM	22 /* %st0 */
#define X86_64_XMM0_REGNUM	38 /* %xmm0 */
#define X86_64_XMM1_REGNUM	39 /* %xmm1 */

struct x86_64_register_info
d46 1
d51 81
a131 63
static struct x86_64_register_info x86_64_register_info[] =
{
  { "rax", &builtin_type_int64 },
  { "rbx", &builtin_type_int64 },
  { "rcx", &builtin_type_int64 },
  { "rdx", &builtin_type_int64 },
  { "rsi", &builtin_type_int64 },
  { "rdi", &builtin_type_int64 },
  { "rbp", &builtin_type_void_data_ptr },
  { "rsp", &builtin_type_void_data_ptr },

  /* %r8 is indeed register number 8.  */
  { "r8", &builtin_type_int64 },
  { "r9", &builtin_type_int64 },
  { "r10", &builtin_type_int64 },
  { "r11", &builtin_type_int64 },
  { "r12", &builtin_type_int64 },
  { "r13", &builtin_type_int64 },
  { "r14", &builtin_type_int64 },
  { "r15", &builtin_type_int64 },
  { "rip", &builtin_type_void_func_ptr },
  { "eflags", &builtin_type_int32 },
  { "ds", &builtin_type_int32 },
  { "es", &builtin_type_int32 },
  { "fs", &builtin_type_int32 },
  { "gs", &builtin_type_int32 },

  /* %st0 is register number 22.  */
  { "st0", &builtin_type_i387_ext },
  { "st1", &builtin_type_i387_ext },
  { "st2", &builtin_type_i387_ext },
  { "st3", &builtin_type_i387_ext },
  { "st4", &builtin_type_i387_ext },
  { "st5", &builtin_type_i387_ext },
  { "st6", &builtin_type_i387_ext },
  { "st7", &builtin_type_i387_ext },
  { "fctrl", &builtin_type_int32 },
  { "fstat", &builtin_type_int32 },
  { "ftag", &builtin_type_int32 },
  { "fiseg", &builtin_type_int32 },
  { "fioff", &builtin_type_int32 },
  { "foseg", &builtin_type_int32 },
  { "fooff", &builtin_type_int32 },
  { "fop", &builtin_type_int32 },

  /* %xmm0 is register number 38.  */
  { "xmm0", &builtin_type_v4sf },
  { "xmm1", &builtin_type_v4sf },
  { "xmm2", &builtin_type_v4sf },
  { "xmm3", &builtin_type_v4sf },
  { "xmm4", &builtin_type_v4sf },
  { "xmm5", &builtin_type_v4sf },
  { "xmm6", &builtin_type_v4sf },
  { "xmm7", &builtin_type_v4sf },
  { "xmm8", &builtin_type_v4sf },
  { "xmm9", &builtin_type_v4sf },
  { "xmm10", &builtin_type_v4sf },
  { "xmm11", &builtin_type_v4sf },
  { "xmm12", &builtin_type_v4sf },
  { "xmm13", &builtin_type_v4sf },
  { "xmm14", &builtin_type_v4sf },
  { "xmm15", &builtin_type_v4sf },
  { "mxcsr", &builtin_type_int32 }
d134 3
a136 3
/* Total number of registers.  */
#define X86_64_NUM_REGS \
  (sizeof (x86_64_register_info) / sizeof (x86_64_register_info[0]))
d138 3
a140 1
/* Return the name of register REGNUM.  */
d142 13
a154 2
static const char *
x86_64_register_name (int regnum)
d156 2
a157 2
  if (regnum >= 0 && regnum < X86_64_NUM_REGS)
    return x86_64_register_info[regnum].name;
d159 10
a168 1
  return NULL;
d172 1
a172 2
   register REGNUM. */

d174 1
a174 1
x86_64_register_type (struct gdbarch *gdbarch, int regnum)
d176 2
a177 1
  gdb_assert (regnum >= 0 && regnum < X86_64_NUM_REGS);
d179 9
a187 1
  return *x86_64_register_info[regnum].type;
d190 7
a196 4
/* DWARF Register Number Mapping as defined in the System V psABI,
   section 3.6.  */

static int x86_64_dwarf_regmap[] =
d198 1
a198 3
  /* General Purpose Registers RAX, RDX, RCX, RBX, RSI, RDI.  */
  X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, 3, 2, 
  4, X86_64_RDI_REGNUM,
d200 16
a215 2
  /* Frame Pointer Register RBP.  */
  X86_64_RBP_REGNUM,
d217 3
a219 2
  /* Stack Pointer Register RSP.  */
  X86_64_RSP_REGNUM,
d221 8
a228 2
  /* Extended Integer Registers 8 - 15.  */
  8, 9, 10, 11, 12, 13, 14, 15,
d230 9
a238 2
  /* Return Address RA.  Not mapped.  */
  -1,
d240 2
a241 5
  /* SSE Registers 0 - 7.  */
  X86_64_XMM0_REGNUM + 0, X86_64_XMM1_REGNUM,
  X86_64_XMM0_REGNUM + 2, X86_64_XMM0_REGNUM + 3,
  X86_64_XMM0_REGNUM + 4, X86_64_XMM0_REGNUM + 5,
  X86_64_XMM0_REGNUM + 6, X86_64_XMM0_REGNUM + 7,
d243 2
a244 5
  /* Extended SSE Registers 8 - 15.  */
  X86_64_XMM0_REGNUM + 8, X86_64_XMM0_REGNUM + 9,
  X86_64_XMM0_REGNUM + 10, X86_64_XMM0_REGNUM + 11,
  X86_64_XMM0_REGNUM + 12, X86_64_XMM0_REGNUM + 13,
  X86_64_XMM0_REGNUM + 14, X86_64_XMM0_REGNUM + 15,
d246 2
a247 15
  /* Floating Point Registers 0-7.  */
  X86_64_ST0_REGNUM + 0, X86_64_ST0_REGNUM + 1,	
  X86_64_ST0_REGNUM + 2, X86_64_ST0_REGNUM + 3,
  X86_64_ST0_REGNUM + 4, X86_64_ST0_REGNUM + 5,
  X86_64_ST0_REGNUM + 6, X86_64_ST0_REGNUM + 7
};

static const int x86_64_dwarf_regmap_len =
  (sizeof (x86_64_dwarf_regmap) / sizeof (x86_64_dwarf_regmap[0]));

/* Convert DWARF register number REG to the appropriate register
   number used by GDB.  */

static int
x86_64_dwarf_reg_to_regnum (int reg)
d249 1
a249 4
  int regnum = -1;

  if (reg >= 0 || reg < x86_64_dwarf_regmap_len)
    regnum = x86_64_dwarf_regmap[reg];
d251 3
a253 4
  if (regnum == -1)
    warning ("Unmapped DWARF Register #%d encountered\n", reg);

  return regnum;
d256 2
a257 5
/* Return nonzero if a value of type TYPE stored in register REGNUM
   needs any special handling.  */

static int
x86_64_convert_register_p (int regnum, struct type *type)
d259 1
a259 1
  return i386_fp_regnum_p (regnum);
d264 3
a266 2
   Some types are returned in registers an some (big structures) in
   memory.  See the System V psABI for details.  */
d285 1
a285 1
   See the System V psABI for details.  */
d290 1
a290 1
  /* Rule (a): If both classes are equal, this is the resulting class.  */
d294 1
a294 1
  /* Rule (b): If one of the classes is NO_CLASS, the resulting class
d301 1
a301 1
  /* Rule (c): If one of the classes is MEMORY, the result is MEMORY.  */
d305 1
a305 1
  /* Rule (d): If one of the classes is INTEGER, the result is INTEGER.  */
d313 1
a313 2
  /* Rule (e): If one of the classes is X87 or X87UP class, MEMORY is
     used as class.  */
d318 1
a318 1
  /* Rule (f): Otherwise class SSE is used.  */
d328 1
a328 1
   See the System V psABI for details.  */
d536 1
a536 2

static int
d553 1
a553 1
static void
d564 2
a565 2
  int ret_int_r[RET_INT_REGS] = { X86_64_RAX_REGNUM, X86_64_RDX_REGNUM };
  int ret_sse_r[RET_SSE_REGS] = { X86_64_XMM0_REGNUM, X86_64_XMM1_REGNUM };
d572 1
a572 1
      regcache_cooked_read (regcache, X86_64_RAX_REGNUM, &addr);
d613 1
a613 1
	      regcache_cooked_read_part (regcache, X86_64_ST0_REGNUM,
d618 1
a618 1
	      regcache_cooked_read_part (regcache, X86_64_ST0_REGNUM,
d631 6
d638 1
a638 1
#define SSE_REGS 8
d640 3
a642 3
static CORE_ADDR
x86_64_push_arguments (struct regcache *regcache, int nargs,
		       struct value **args, CORE_ADDR sp)
a645 7
  /* For varargs functions we have to pass the total number of SSE arguments
     in %rax.  So, let's count this number.  */
  int total_sse_args = 0;
  /* Once an SSE/int argument is passed on the stack, all subsequent
     arguments are passed there.  */
  int sse_stack = 0;
  int int_stack = 0;
d647 4
a650 6
  char buf[8];
  static int int_parameter_registers[INT_REGS] =
  {
    X86_64_RDI_REGNUM, 4,	/* %rdi, %rsi */
    X86_64_RDX_REGNUM, 2,	/* %rdx, %rcx */
    8, 9			/* %r8, %r9 */
d652 6
a657 7
  /* %xmm0 - %xmm7 */
  static int sse_parameter_registers[SSE_REGS] =
  {
    X86_64_XMM0_REGNUM + 0, X86_64_XMM1_REGNUM,
    X86_64_XMM0_REGNUM + 2, X86_64_XMM0_REGNUM + 3,
    X86_64_XMM0_REGNUM + 4, X86_64_XMM0_REGNUM + 5,
    X86_64_XMM0_REGNUM + 6, X86_64_XMM0_REGNUM + 7,
d670 3
a672 1
	  !examine_argument (class, n, &needed_intregs, &needed_sseregs))
a678 8
	  int offset = 0;

	  if (intreg / 2 + needed_intregs > INT_REGS)
	    int_stack = 1;
	  if (ssereg / 2 + needed_sseregs > SSE_REGS)
	    sse_stack = 1;
	  total_sse_args += needed_sseregs;

d681 1
d687 5
a691 10
		  if (int_stack)
		    stack_values[stack_values_count++] = i;
		  else
		    {
		      regcache_cooked_write
			(regcache, int_parameter_registers[(intreg + 1) / 2],
			 VALUE_CONTENTS_ALL (args[i]) + offset);
		      offset += 8;
		      intreg += 2;
		    }
d694 11
a704 13
		  if (int_stack)
		    stack_values[stack_values_count++] = i;
		  else
		    {
		      LONGEST val = extract_signed_integer
			(VALUE_CONTENTS_ALL (args[i]) + offset, 4);
		      regcache_cooked_write_signed
			(regcache, int_parameter_registers[intreg / 2], val);
		      
		      offset += 8;
		      intreg++;
		    }
		  break;
d708 5
a712 10
		  if (sse_stack)
		    stack_values[stack_values_count++] = i;
		  else
		    {
		      regcache_cooked_write
			(regcache, sse_parameter_registers[(ssereg + 1) / 2],
			 VALUE_CONTENTS_ALL (args[i]) + offset);
		      offset += 8;
		      ssereg += 2;
		    }
d715 4
a718 10
		  if (sse_stack)
		    stack_values[stack_values_count++] = i;
		  else
		    {
		      regcache_cooked_write
			(regcache, sse_parameter_registers[ssereg / 2],
			 VALUE_CONTENTS_ALL (args[i]) + offset);
		      offset += 8;
		      ssereg++;
		    }
a734 2

  /* Push any remaining arguments onto the stack.  */
d739 3
a741 3

      /* Make sure the stack stays eightbyte-aligned.  */
      sp -= (len + 7) & ~7;
a743 6

  /* Write number of SSE type arguments to RAX to take care of varargs
     functions.  */
  store_unsigned_integer (buf, 8, total_sse_args);
  regcache_cooked_write (regcache, X86_64_RAX_REGNUM, buf);

d749 1
a749 2

static void
d755 1
a755 2
  /* First handle long doubles.  */
  if (TYPE_CODE_FLT == TYPE_CODE (type)  && len == 16)
d757 11
a767 2
      ULONGEST fstat;
      char buf[FPU_REG_RAW_SIZE];
d769 9
a777 28
      /* Returning floating-point values is a bit tricky.  Apart from
         storing the return value in %st(0), we have to simulate the
         state of the FPU at function return point.  */

      /* Convert the value found in VALBUF to the extended
	 floating-point format used by the FPU.  This is probably
	 not exactly how it would happen on the target itself, but
	 it is the best we can do.  */
      convert_typed_floating (valbuf, type, buf, builtin_type_i387_ext);
      regcache_raw_write (regcache, X86_64_ST0_REGNUM, buf);

      /* Set the top of the floating-point register stack to 7.  The
         actual value doesn't really matter, but 7 is what a normal
         function return would end up with if the program started out
         with a freshly initialized FPU.  */
      regcache_raw_read_unsigned (regcache, FSTAT_REGNUM, &fstat);
      fstat |= (7 << 11);
      regcache_raw_write_unsigned (regcache, FSTAT_REGNUM, fstat);

      /* Mark %st(1) through %st(7) as empty.  Since we set the top of
         the floating-point register stack to 7, the appropriate value
         for the tag word is 0x3fff.  */
      regcache_raw_write_unsigned (regcache, FTAG_REGNUM, 0x3fff);
    }
  else if (TYPE_CODE_FLT == TYPE_CODE (type))
    {
      /* Handle double and float variables.  */
      regcache_cooked_write (regcache,  X86_64_XMM0_REGNUM, valbuf);
a778 1
  /* XXX: What about complex floating point types?  */
d800 2
a801 5
static CORE_ADDR
x86_64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			struct regcache *regcache, CORE_ADDR bp_addr,
			int nargs, struct value **args,	CORE_ADDR sp,
			int struct_return, CORE_ADDR struct_addr)
d803 3
a805 25
  char buf[8];

  /* Pass arguments.  */
  sp = x86_64_push_arguments (regcache, nargs, args, sp);

  /* Pass "hidden" argument".  */
  if (struct_return)
    {
      store_unsigned_integer (buf, 8, struct_addr);
      regcache_cooked_write (regcache, X86_64_RDI_REGNUM, buf);
    }

  /* Store return address.  */
  sp -= 8;
  store_unsigned_integer (buf, 8, bp_addr);
  write_memory (sp, buf, 8);

  /* Finally, update the stack pointer...  */
  store_unsigned_integer (buf, 8, sp);
  regcache_cooked_write (regcache, X86_64_RSP_REGNUM, buf);

  /* ...and fake a frame pointer.  */
  regcache_cooked_write (regcache, X86_64_RBP_REGNUM, buf);

  return sp + 16;
a806 21


/* The maximum number of saved registers.  This should include %rip.  */
#define X86_64_NUM_SAVED_REGS	X86_64_NUM_GREGS

struct x86_64_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  CORE_ADDR sp_offset;
  CORE_ADDR pc;

  /* Saved registers.  */
  CORE_ADDR saved_regs[X86_64_NUM_SAVED_REGS];
  CORE_ADDR saved_sp;

  /* Do we have a frame?  */
  int frameless_p;
};

/* Allocate and initialize a frame cache.  */
d808 2
a809 2
static struct x86_64_frame_cache *
x86_64_alloc_frame_cache (void)
d811 1
a811 15
  struct x86_64_frame_cache *cache;
  int i;

  cache = FRAME_OBSTACK_ZALLOC (struct x86_64_frame_cache);

  /* Base address.  */
  cache->base = 0;
  cache->sp_offset = -8;
  cache->pc = 0;

  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where %rbp is supposed to be stored).  */
  for (i = 0; i < X86_64_NUM_SAVED_REGS; i++)
    cache->saved_regs[i] = -1;
  cache->saved_sp = 0;
d813 4
a816 4
  /* Frameless until proven otherwise.  */
  cache->frameless_p = 1;

  return cache;
d818 1
d820 4
a823 15
/* Do a limited analysis of the prologue at PC and update CACHE
   accordingly.  Bail out early if CURRENT_PC is reached.  Return the
   address where the analysis stopped.

   We will handle only functions beginning with:

      pushq %rbp        0x55
      movq %rsp, %rbp   0x48 0x89 0xe5

   Any function that doesn't start with this sequence will be assumed
   to have no prologue and thus no valid frame pointer in %rbp.  */

static CORE_ADDR
x86_64_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
			 struct x86_64_frame_cache *cache)
d825 1
a825 31
  static unsigned char proto[3] = { 0x48, 0x89, 0xe5 };
  unsigned char buf[3];
  unsigned char op;

  if (current_pc <= pc)
    return current_pc;

  op = read_memory_unsigned_integer (pc, 1);

  if (op == 0x55)		/* pushq %rbp */
    {
      /* Take into account that we've executed the `pushq %rbp' that
         starts this instruction sequence.  */
      cache->saved_regs[X86_64_RBP_REGNUM] = 0;
      cache->sp_offset += 8;

      /* If that's all, return now.  */
      if (current_pc <= pc + 1)
        return current_pc;

      /* Check for `movq %rsp, %rbp'.  */
      read_memory (pc + 1, buf, 3);
      if (memcmp (buf, proto, 3) != 0)
	return pc + 1;

      /* OK, we actually have a frame.  */
      cache->frameless_p = 0;
      return pc + 4;
    }

  return pc;
d828 2
a829 4
/* Return PC of first real instruction.  */

static CORE_ADDR
x86_64_skip_prologue (CORE_ADDR start_pc)
d831 1
a831 8
  struct x86_64_frame_cache cache;
  CORE_ADDR pc;

  pc = x86_64_analyze_prologue (start_pc, 0xffffffffffffffff, &cache);
  if (cache.frameless_p)
    return start_pc;

  return pc;
a832 1

d834 9
a842 4
/* Normal frames.  */

static struct x86_64_frame_cache *
x86_64_frame_cache (struct frame_info *next_frame, void **this_cache)
a843 2
  struct x86_64_frame_cache *cache;
  char buf[8];
d845 2
d848 1
a848 2
  if (*this_cache)
    return *this_cache;
d850 6
a855 40
  cache = x86_64_alloc_frame_cache ();
  *this_cache = cache;

  frame_unwind_register (next_frame, X86_64_RBP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 8);
  if (cache->base == 0)
    return cache;

  /* For normal frames, %rip is stored at 8(%rbp).  */
  cache->saved_regs[X86_64_RIP_REGNUM] = 8;

  cache->pc = frame_func_unwind (next_frame);
  if (cache->pc != 0)
    x86_64_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);

  if (cache->frameless_p)
    {
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  If
	 we're at the start of a function, or somewhere half-way its
	 prologue, the function's frame probably hasn't been fully
	 setup yet.  Try to reconstruct the base address for the stack
	 frame by looking at the stack pointer.  For truly "frameless"
	 functions this might work too.  */

      frame_unwind_register (next_frame, X86_64_RSP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 8) + cache->sp_offset;
    }

  /* Now that we have the base address for the stack frame we can
     calculate the value of %rsp in the calling frame.  */
  cache->saved_sp = cache->base + 16;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < X86_64_NUM_SAVED_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] += cache->base;

  return cache;
d858 3
a860 6
static void
x86_64_frame_this_id (struct frame_info *next_frame, void **this_cache,
		      struct frame_id *this_id)
{
  struct x86_64_frame_cache *cache =
    x86_64_frame_cache (next_frame, this_cache);
d862 2
a863 12
  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;

  (*this_id) = frame_id_build (cache->base + 16, cache->pc);
}

static void
x86_64_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			    int regnum, int *optimizedp,
			    enum lval_type *lvalp, CORE_ADDR *addrp,
			    int *realnump, void *valuep)
a864 65
  struct x86_64_frame_cache *cache =
    x86_64_frame_cache (next_frame, this_cache);

  gdb_assert (regnum >= 0);

  if (regnum == SP_REGNUM && cache->saved_sp)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* Store the value.  */
	  store_unsigned_integer (valuep, 8, cache->saved_sp);
	}
      return;
    }

  if (regnum < X86_64_NUM_SAVED_REGS && cache->saved_regs[regnum] != -1)
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
	}
      return;
    }

  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind x86_64_frame_unwind =
{
  NORMAL_FRAME,
  x86_64_frame_this_id,
  x86_64_frame_prev_register
};

static const struct frame_unwind *
x86_64_frame_p (CORE_ADDR pc)
{
  return &x86_64_frame_unwind;
}


/* Signal trampolines.  */

/* FIXME: kettenis/20030419: Perhaps, we can unify the 32-bit and
   64-bit variants.  This would require using identical frame caches
   on both platforms.  */

static struct x86_64_frame_cache *
x86_64_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct x86_64_frame_cache *cache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  CORE_ADDR addr;
  char buf[8];
d866 28
d895 1
a895 17
  if (*this_cache)
    return *this_cache;

  cache = x86_64_alloc_frame_cache ();

  frame_unwind_register (next_frame, X86_64_RSP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 8) - 8;

  addr = tdep->sigcontext_addr (next_frame);
  gdb_assert (tdep->sc_reg_offset);
  gdb_assert (tdep->sc_num_regs <= X86_64_NUM_SAVED_REGS);
  for (i = 0; i < tdep->sc_num_regs; i++)
    if (tdep->sc_reg_offset[i] != -1)
      cache->saved_regs[i] = addr + tdep->sc_reg_offset[i];

  *this_cache = cache;
  return cache;
d899 1
a899 2
x86_64_sigtramp_frame_this_id (struct frame_info *next_frame,
			       void **this_cache, struct frame_id *this_id)
d901 4
a904 41
  struct x86_64_frame_cache *cache =
    x86_64_sigtramp_frame_cache (next_frame, this_cache);

  (*this_id) = frame_id_build (cache->base + 16, frame_pc_unwind (next_frame));
}

static void
x86_64_sigtramp_frame_prev_register (struct frame_info *next_frame,
				     void **this_cache,
				     int regnum, int *optimizedp,
				     enum lval_type *lvalp, CORE_ADDR *addrp,
				     int *realnump, void *valuep)
{
  /* Make sure we've initialized the cache.  */
  x86_64_sigtramp_frame_cache (next_frame, this_cache);

  x86_64_frame_prev_register (next_frame, this_cache, regnum,
			      optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind x86_64_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  x86_64_sigtramp_frame_this_id,
  x86_64_sigtramp_frame_prev_register
};

static const struct frame_unwind *
x86_64_sigtramp_frame_p (CORE_ADDR pc)
{
  char *name;

  find_pc_partial_function (pc, &name, NULL, NULL);
  if (PC_IN_SIGTRAMP (pc, name))
    {
      gdb_assert (gdbarch_tdep (current_gdbarch)->sigcontext_addr);

      return &x86_64_sigtramp_frame_unwind;
    }

  return NULL;
a905 18


static CORE_ADDR
x86_64_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct x86_64_frame_cache *cache =
    x86_64_frame_cache (next_frame, this_cache);

  return cache->base;
}

static const struct frame_base x86_64_frame_base =
{
  &x86_64_frame_unwind,
  x86_64_frame_base_address,
  x86_64_frame_base_address,
  x86_64_frame_base_address
};
d908 1
a908 1
x86_64_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d910 3
a912 7
  char buf[8];
  CORE_ADDR fp;

  frame_unwind_register (next_frame, X86_64_RBP_REGNUM, buf);
  fp = extract_unsigned_integer (buf, 8);

  return frame_id_build (fp + 16, frame_pc_unwind (next_frame));
d919 1
a934 2
  set_gdbarch_register_name (gdbarch, x86_64_register_name);
  set_gdbarch_register_type (gdbarch, x86_64_register_type);
d937 5
a941 4
  set_gdbarch_sp_regnum (gdbarch, X86_64_RSP_REGNUM); /* %rsp */
  set_gdbarch_pc_regnum (gdbarch, X86_64_RIP_REGNUM); /* %rip */
  set_gdbarch_ps_regnum (gdbarch, X86_64_EFLAGS_REGNUM); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, X86_64_ST0_REGNUM); /* %st(0) */
d944 37
a980 18
     referred to as the "DWARF Register Number Mapping" in the System
     V psABI.  The preferred debugging format for all known x86-64
     targets is actually DWARF2, and GCC doesn't seem to support DWARF
     (that is DWARF-1), but we provide the same mapping just in case.
     This mapping is also used for stabs, which GCC does support.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, x86_64_dwarf_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, x86_64_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, x86_64_dwarf_reg_to_regnum);

  /* We don't override SDB_REG_RO_REGNUM, since COFF doesn't seem to
     be in use on any of the supported x86-64 targets.  */

  /* Call dummy code.  */
  set_gdbarch_push_dummy_call (gdbarch, x86_64_push_dummy_call);

  set_gdbarch_convert_register_p (gdbarch, x86_64_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, i387_register_to_value);
  set_gdbarch_value_to_register (gdbarch, i387_value_to_register);
d983 5
d993 1
d996 11
a1006 1
  /* Avoid wiring in the MMX registers for now.  */
d1009 11
a1019 1
  set_gdbarch_unwind_dummy_id (gdbarch, x86_64_unwind_dummy_id);
d1025 4
a1028 4

  frame_unwind_append_predicate (gdbarch, x86_64_sigtramp_frame_p);
  frame_unwind_append_predicate (gdbarch, x86_64_frame_p);
  frame_base_set_default (gdbarch, &x86_64_frame_base);
a1029 15


#define I387_FISEG_REGNUM FISEG_REGNUM
#define I387_FOSEG_REGNUM FOSEG_REGNUM

/* The 64-bit FXSAVE format differs from the 32-bit format in the
   sense that the instruction pointer and data pointer are simply
   64-bit offsets into the code segment and the data segment instead
   of a selector offset pair.  The functions below store the upper 32
   bits of these pointers (instead of just the 16-bits of the segment
   selector).  */

/* Fill GDB's register array with the floating-point and SSE register
   values in *FXSAVE.  This function masks off any of the reserved
   bits in *FXSAVE.  */
d1032 1
a1032 1
x86_64_supply_fxsave (char *fxsave)
d1034 4
a1037 1
  i387_supply_fxsave (fxsave);
d1039 7
a1045 21
  if (fxsave)
    {
      supply_register (I387_FISEG_REGNUM, fxsave + 12);
      supply_register (I387_FOSEG_REGNUM, fxsave + 20);
    }
}

/* Fill register REGNUM (if it is a floating-point or SSE register) in
   *FXSAVE with the value in GDB's register array.  If REGNUM is -1, do
   this for all registers.  This function doesn't touch any of the
   reserved bits in *FXSAVE.  */

void
x86_64_fill_fxsave (char *fxsave, int regnum)
{
  i387_fill_fxsave (fxsave, regnum);

  if (regnum == -1 || regnum == I387_FISEG_REGNUM)
    regcache_collect (I387_FISEG_REGNUM, fxsave + 12);
  if (regnum == -1 || regnum == I387_FOSEG_REGNUM)
    regcache_collect (I387_FOSEG_REGNUM, fxsave + 20);
@


1.27.2.11
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d42 12
a53 1
/* Register information.  */
d600 2
a601 2
  /* For varargs functions we have to pass the total number of SSE
     registers used in %rax.  So, let's count this number.  */
a606 1
  unsigned total_sp;
d647 1
a647 2
	  if (!sse_stack)
	    total_sse_args += needed_sseregs;
a722 16
  /* We have to make sure that the stack is 16-byte aligned after the
     setup.  Let's calculate size of arguments first, align stack and
     then fill in the arguments.  */
  total_sp = 0;
  for (i = 0; i < stack_values_count; i++)
    {
      struct value *arg = args[stack_values[i]];
      int len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (arg));
      total_sp += (len + 7) & ~7;
    }
  /* total_sp is now a multiple of 8, if it is not a multiple of 16,
     change the stack pointer so that it will be afterwards correctly
     aligned.  */
  if (total_sp & 15)
    sp -= 8;
    
d729 1
a729 1
      /* Make sure the stack is 8-byte-aligned.  */
d784 1
a784 2
      regcache_cooked_write_part (regcache, X86_64_XMM0_REGNUM,
				  0, len, valbuf);
d1072 1
a1072 1
x86_64_frame_sniffer (struct frame_info *next_frame)
d1144 1
a1144 1
x86_64_sigtramp_frame_sniffer (struct frame_info *next_frame)
a1145 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
d1255 2
a1256 2
  frame_unwind_append_sniffer (gdbarch, x86_64_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, x86_64_frame_sniffer);
@


1.27.2.12
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d147 1
a147 1
  X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, 2, 1,
d175 1
a175 1
  X86_64_ST0_REGNUM + 0, X86_64_ST0_REGNUM + 1,
a615 1

a1197 8
/* 16 byte align the SP per frame requirements.  */

static CORE_ADDR
x86_64_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  return sp & -(CORE_ADDR)16;
}

a1240 2
  set_gdbarch_frame_align (gdbarch, x86_64_frame_align);
  set_gdbarch_frame_red_zone_size (gdbarch, 128);
d1280 3
a1282 4
/* Fill register REGNUM in GDB's register cache with the appropriate
   floating-point or SSE register value from *FXSAVE.  If REGNUM is
   -1, do this for all registers.  This function masks off any of the
   reserved bits in *FXSAVE.  */
d1285 1
a1285 1
x86_64_supply_fxsave (const char *fxsave, int regnum)
d1287 1
a1287 1
  i387_supply_fxsave (fxsave, regnum);
d1291 1
a1291 3
      if (regnum == -1 || regnum == I387_FISEG_REGNUM)
	supply_register (I387_FISEG_REGNUM, fxsave + 12);
      if (regnum == -1 || regnum == I387_FOSEG_REGNUM)
d1297 1
a1297 1
   *FXSAVE with the value in GDB's register cache.  If REGNUM is -1, do
@


1.27.2.13
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a34 1
#include "regset.h"
d760 1
a760 1
  if (TYPE_CODE_FLT == TYPE_CODE (type) && len == 16)
d763 1
a763 1
      char buf[I386_MAX_REGISTER_SIZE];
d798 2
a799 2
      int low_size = register_size (current_gdbarch, X86_64_RAX_REGNUM);
      int high_size = register_size (current_gdbarch, X86_64_RDX_REGNUM);
a1205 40


/* Supply register REGNUM from the floating-point register set REGSET
   to register cache REGCACHE.  If REGNUM is -1, do this for all
   registers in REGSET.  */

static void
x86_64_supply_fpregset (const struct regset *regset, struct regcache *regcache,
			int regnum, const void *fpregs, size_t len)
{
  const struct gdbarch_tdep *tdep = regset->descr;

  gdb_assert (len == tdep->sizeof_fpregset);
  x86_64_supply_fxsave (regcache, regnum, fpregs);
}

/* Return the appropriate register set for the core section identified
   by SECT_NAME and SECT_SIZE.  */

static const struct regset *
x86_64_regset_from_core_section (struct gdbarch *gdbarch,
				 const char *sect_name, size_t sect_size)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (strcmp (sect_name, ".reg2") == 0 && sect_size == tdep->sizeof_fpregset)
    {
      if (tdep->fpregset == NULL)
	{
	  tdep->fpregset = XMALLOC (struct regset);
	  tdep->fpregset->descr = tdep;
	  tdep->fpregset->supply_regset = x86_64_supply_fpregset;
	}

      return tdep->fpregset;
    }

  return i386_regset_from_core_section (gdbarch, sect_name, sect_size);
}

d1212 1
a1212 6
  /* AMD64 generally uses `fxsave' instead of `fsave' for saving its
     floating-point registers.  */
  tdep->sizeof_fpregset = I387_SIZEOF_FXSAVE;

  /* AMD64 has an FPU and 16 SSE registers.  */
  tdep->st0_regnum = X86_64_ST0_REGNUM;
a1266 1
  tdep->mm0_regnum = -1;
a1277 5

  /* If we have a register mapping, enable the generic core file support.  */
  if (tdep->gregset_reg_offset)
    set_gdbarch_regset_from_core_section (gdbarch,
					  x86_64_regset_from_core_section);
d1281 2
a1282 1
#define I387_ST0_REGNUM X86_64_ST0_REGNUM
d1291 1
a1291 1
/* Fill register REGNUM in REGCACHE with the appropriate
d1297 1
a1297 2
x86_64_supply_fxsave (struct regcache *regcache, int regnum,
		      const void *fxsave)
d1299 1
a1299 1
  i387_supply_fxsave (regcache, regnum, fxsave);
a1302 2
      const char *regs = fxsave;

d1304 1
a1304 1
	regcache_raw_supply (regcache, I387_FISEG_REGNUM, regs + 12);
d1306 1
a1306 1
	regcache_raw_supply (regcache, I387_FOSEG_REGNUM, regs + 20);
@


1.27.2.14
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d212 18
a229 12
/* Register classes as defined in the psABI.  */

enum amd64_reg_class
{
  AMD64_INTEGER,
  AMD64_SSE,
  AMD64_SSEUP,
  AMD64_X87,
  AMD64_X87UP,
  AMD64_COMPLEX_X87,
  AMD64_NO_CLASS,
  AMD64_MEMORY
d232 2
a233 2
/* Return the union class of CLASS1 and CLASS2.  See the psABI for
   details.  */
d235 2
a236 2
static enum amd64_reg_class
amd64_merge_classes (enum amd64_reg_class class1, enum amd64_reg_class class2)
d244 1
a244 1
  if (class1 == AMD64_NO_CLASS)
d246 1
a246 1
  if (class2 == AMD64_NO_CLASS)
d250 2
a251 2
  if (class1 == AMD64_MEMORY || class2 == AMD64_MEMORY)
    return AMD64_MEMORY;
d254 12
a265 9
  if (class1 == AMD64_INTEGER || class2 == AMD64_INTEGER)
    return AMD64_INTEGER;

  /* Rule (e): If one of the classes is X87, X87UP, COMPLEX_X87 class,
     MEMORY is used as class.  */
  if (class1 == AMD64_X87 || class1 == AMD64_X87UP
      || class1 == AMD64_COMPLEX_X87 || class2 == AMD64_X87
      || class2 == AMD64_X87UP || class2 == AMD64_COMPLEX_X87)
    return AMD64_MEMORY;
d268 1
a268 1
  return AMD64_SSE;
d271 5
a275 1
static void amd64_classify (struct type *type, enum amd64_reg_class class[2]);
d277 1
a277 2
/* Classify TYPE according to the rules for aggregate (structures and
   arrays) and union types, and store the result in CLASS.  */
d279 3
a281 2
static void
amd64_classify_aggregate (struct type *type, enum amd64_reg_class class[2])
d283 2
a284 1
  int len = TYPE_LENGTH (type);
d286 1
a286 4
  /* 1. If the size of an object is larger than two eightbytes, or in
        C++, is a non-POD structure or union type, or contains
        unaligned fields, it has class memory.  */
  if (len > 16)
d288 48
a335 3
      class[0] = class[1] = AMD64_MEMORY;
      return;
    }
d337 10
a346 2
  /* 2. Both eightbytes get initialized to class NO_CLASS.  */
  class[0] = class[1] = AMD64_NO_CLASS;
d348 69
a416 23
  /* 3. Each field of an object is classified recursively so that
        always two fields are considered. The resulting class is
        calculated according to the classes of the fields in the
        eightbyte: */

  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      struct type *subtype = check_typedef (TYPE_TARGET_TYPE (type));

      /* All fields in an array have the same type.  */
      amd64_classify (subtype, class);
      if (len > 8 && class[1] == AMD64_NO_CLASS)
	class[1] = class[0];
    }
  else
    {
      int i;

      /* Structure or union.  */
      gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT
		  || TYPE_CODE (type) == TYPE_CODE_UNION);

      for (i = 0; i < TYPE_NFIELDS (type); i++)
d418 14
a431 10
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));
	  int pos = TYPE_FIELD_BITPOS (type, i) / 64;
	  enum amd64_reg_class subclass[2];

	  gdb_assert (pos == 0 || pos == 1);

	  amd64_classify (subtype, subclass);
	  class[pos] = amd64_merge_classes (class[pos], subclass[0]);
	  if (pos == 0)
	    class[1] = amd64_merge_classes (class[1], subclass[1]);
d433 4
d438 2
a439 14

  /* 4. Then a post merger cleanup is done:  */

  /* Rule (a): If one of the classes is MEMORY, the whole argument is
     passed in memory.  */
  if (class[0] == AMD64_MEMORY || class[1] == AMD64_MEMORY)
    class[0] = class[1] = AMD64_MEMORY;

  /* Rule (b): If SSEUP is not preceeded by SSE, it is converted to
     SSE.  */
  if (class[0] == AMD64_SSEUP)
    class[0] = AMD64_SSE;
  if (class[1] == AMD64_SSEUP && class[0] != AMD64_SSE)
    class[1] = AMD64_SSE;
d442 60
a501 1
/* Classify TYPE, and store the result in CLASS.  */
d504 2
a505 1
amd64_classify (struct type *type, enum amd64_reg_class class[2])
d507 20
a526 64
  enum type_code code = TYPE_CODE (type);
  int len = TYPE_LENGTH (type);

  class[0] = class[1] = AMD64_NO_CLASS;

  /* Arguments of types (signed and unsigned) _Bool, char, short, int,
     long, long long, and pointers are in the INTEGER class.  */
  if ((code == TYPE_CODE_INT || code == TYPE_CODE_ENUM
       || code == TYPE_CODE_PTR || code == TYPE_CODE_REF)
      && (len == 1 || len == 2 || len == 4 || len == 8))
    class[0] = AMD64_INTEGER;

  /* Arguments of types float, double and __m64 are in class SSE.  */
  else if (code == TYPE_CODE_FLT && (len == 4 || len == 8))
    /* FIXME: __m64 .  */
    class[0] = AMD64_SSE;

  /* Arguments of types __float128 and __m128 are split into two
     halves.  The least significant ones belong to class SSE, the most
     significant one to class SSEUP.  */
  /* FIXME: __float128, __m128.  */

  /* The 64-bit mantissa of arguments of type long double belongs to
     class X87, the 16-bit exponent plus 6 bytes of padding belongs to
     class X87UP.  */
  else if (code == TYPE_CODE_FLT && len == 16)
    /* Class X87 and X87UP.  */
    class[0] = AMD64_X87, class[1] = AMD64_X87UP;

  /* Aggregates.  */
  else if (code == TYPE_CODE_ARRAY || code == TYPE_CODE_STRUCT
	   || code == TYPE_CODE_UNION)
    amd64_classify_aggregate (type, class);
}

static enum return_value_convention
amd64_return_value (struct gdbarch *gdbarch, struct type *type,
		    struct regcache *regcache,
		    void *readbuf, const void *writebuf)
{
  enum amd64_reg_class class[2];
  int len = TYPE_LENGTH (type);
  static int integer_regnum[] = { X86_64_RAX_REGNUM, X86_64_RDX_REGNUM };
  static int sse_regnum[] = { X86_64_XMM0_REGNUM, X86_64_XMM1_REGNUM };
  int integer_reg = 0;
  int sse_reg = 0;
  int i;

  gdb_assert (!(readbuf && writebuf));

  /* 1. Classify the return type with the classification algorithm.  */
  amd64_classify (type, class);

  /* 2. If the type has class MEMORY, then the caller provides space
        for the return value and passes the address of this storage in
        %rdi as if it were the first argument to the function. In
        effect, this address becomes a hidden first argument.  */
  if (class[0] == AMD64_MEMORY)
    return RETURN_VALUE_STRUCT_CONVENTION;

  gdb_assert (class[1] != AMD64_MEMORY);
  gdb_assert (len <= 16);

  for (i = 0; len > 0; i++, len -= 8)
d528 2
a529 4
      int regnum = -1;
      int offset = 0;

      switch (class[i])
d531 46
a576 42
	case AMD64_INTEGER:
	  /* 3. If the class is INTEGER, the next available register
	     of the sequence %rax, %rdx is used.  */
	  regnum = integer_regnum[integer_reg++];
	  break;

	case AMD64_SSE:
	  /* 4. If the class is SSE, the next available SSE register
             of the sequence %xmm0, %xmm1 is used.  */
	  regnum = sse_regnum[sse_reg++];
	  break;

	case AMD64_SSEUP:
	  /* 5. If the class is SSEUP, the eightbyte is passed in the
	     upper half of the last used SSE register.  */
	  gdb_assert (sse_reg > 0);
	  regnum = sse_regnum[sse_reg - 1];
	  offset = 8;
	  break;

	case AMD64_X87:
	  /* 6. If the class is X87, the value is returned on the X87
             stack in %st0 as 80-bit x87 number.  */
	  regnum = X86_64_ST0_REGNUM;
	  if (writebuf)
	    i387_return_value (gdbarch, regcache);
	  break;

	case AMD64_X87UP:
	  /* 7. If the class is X87UP, the value is returned together
             with the previous X87 value in %st0.  */
	  gdb_assert (i > 0 && class[0] == AMD64_X87);
	  regnum = X86_64_ST0_REGNUM;
	  offset = 8;
	  len = 2;
	  break;

	case AMD64_NO_CLASS:
	  continue;

	default:
	  gdb_assert (!"Unexpected register class.");
a577 9

      gdb_assert (regnum != -1);

      if (readbuf)
	regcache_raw_read_part (regcache, regnum, offset, min (len, 8),
				(char *) readbuf + i * 8);
      if (writebuf)
	regcache_raw_write_part (regcache, regnum, offset, min (len, 8),
				 (const char *) writebuf + i * 8);
d579 1
d581 2
a582 3
  return RETURN_VALUE_REGISTER_CONVENTION;
}

d585 2
a586 2
amd64_push_arguments (struct regcache *regcache, int nargs,
		      struct value **args, CORE_ADDR sp)
d588 13
a600 1
  static int integer_regnum[] =
d606 2
a607 1
  static int sse_regnum[] =
a608 1
    /* %xmm0 ... %xmm7 */
d614 3
a616 7
  struct value **stack_args = alloca (nargs * sizeof (struct value *));
  int num_stack_args = 0;
  int num_elements = 0;
  int element = 0;
  int integer_reg = 0;
  int sse_reg = 0;
  int i;
d620 9
a628 29
      struct type *type = VALUE_TYPE (args[i]);
      int len = TYPE_LENGTH (type);
      enum amd64_reg_class class[2];
      int needed_integer_regs = 0;
      int needed_sse_regs = 0;
      int j;

      /* Classify argument.  */
      amd64_classify (type, class);

      /* Calculate the number of integer and SSE registers needed for
         this argument.  */
      for (j = 0; j < 2; j++)
	{
	  if (class[j] == AMD64_INTEGER)
	    needed_integer_regs++;
	  else if (class[j] == AMD64_SSE)
	    needed_sse_regs++;
	}

      /* Check whether enough registers are available, and if the
         argument should be passed in registers at all.  */
      if (integer_reg + needed_integer_regs > ARRAY_SIZE (integer_regnum)
	  || sse_reg + needed_sse_regs > ARRAY_SIZE (sse_regnum)
	  || (needed_integer_regs == 0 && needed_sse_regs == 0))
	{
	  /* The argument will be passed on the stack.  */
	  num_elements += ((len + 7) / 8);
	  stack_args[num_stack_args++] = args[i];
d632 2
a633 3
	  /* The argument will be passed in registers.  */
	  char *valbuf = VALUE_CONTENTS (args[i]);
	  char buf[8];
d635 6
a640 1
	  gdb_assert (len <= 16);
d642 1
a642 1
	  for (j = 0; len > 0; j++, len -= 8)
a643 3
	      int regnum = -1;
	      int offset = 0;

d646 27
a672 2
		case AMD64_INTEGER:
		  regnum = integer_regnum[integer_reg++];
d674 29
a702 3

		case AMD64_SSE:
		  regnum = sse_regnum[sse_reg++];
d704 1
a704 5

		case AMD64_SSEUP:
		  gdb_assert (sse_reg > 0);
		  regnum = sse_regnum[sse_reg - 1];
		  offset = 8;
a705 1

d707 2
a708 1
		  gdb_assert (!"Unexpected register class.");
d710 2
a711 5

	      gdb_assert (regnum != -1);
	      memset (buf, 0, sizeof buf);
	      memcpy (buf, valbuf + j * 8, min (len, 8));
	      regcache_raw_write_part (regcache, regnum, offset, 8, buf);
d716 26
a741 2
  /* Allocate space for the arguments on the stack.  */
  sp -= num_elements * 8;
d743 6
a748 21
  /* The psABI says that "The end of the input argument area shall be
     aligned on a 16 byte boundary."  */
  sp &= ~0xf;

  /* Write out the arguments to the stack.  */
  for (i = 0; i < num_stack_args; i++)
    {
      struct type *type = VALUE_TYPE (stack_args[i]);
      char *valbuf = VALUE_CONTENTS (stack_args[i]);
      int len = TYPE_LENGTH (type);

      write_memory (sp + element * 8, valbuf, len);
      element += ((len + 7) / 8);
    }

  /* The psABI says that "For calls that may call functions that use
     varargs or stdargs (prototype-less calls or calls to functions
     containing ellipsis (...) in the declaration) %al is used as
     hidden argument to specify the number of SSE registers used.  */
  regcache_raw_write_unsigned (regcache, X86_64_RAX_REGNUM, sse_reg);
  return sp; 
d751 67
d827 1
a827 1
  sp = amd64_push_arguments (regcache, nargs, args, sp);
d977 8
a1001 5
  else
    {
      frame_unwind_register (next_frame, X86_64_RBP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 8);
    }
a1006 5
  /* For normal frames, %rip is stored at 8(%rbp).  If we don't have a
     frame we find it at the same offset from the reconstructed base
     address.  */
  cache->saved_regs[X86_64_RIP_REGNUM] = 8;

d1303 2
a1304 1
  set_gdbarch_return_value (gdbarch, amd64_return_value);
d1307 1
@


1.27.2.15
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d1 1
a1 1
/* Target-dependent code for AMD64.
d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a42 7
/* Note that the AMD64 architecture was previously known as x86-64.
   The latter is (forever) engraved into the canonical system name as
   returned bu config.guess, and used as the name for the AMD64 port
   of GNU/Linux.  The BSD's have renamed their ports to amd64; they
   don't like to shout.  For GDB we prefer the amd64_-prefix over the
   x86_64_-prefix since it's so much easier to type.  */

d45 1
a45 1
struct amd64_register_info
d51 1
a51 1
static struct amd64_register_info amd64_register_info[] =
a72 2
  { "cs", &builtin_type_int32 },
  { "ss", &builtin_type_int32 },
d78 1
a78 1
  /* %st0 is register number 24.  */
d96 1
a96 1
  /* %xmm0 is register number 40.  */
d117 2
a118 2
#define AMD64_NUM_REGS \
  (sizeof (amd64_register_info) / sizeof (amd64_register_info[0]))
d123 1
a123 1
amd64_register_name (int regnum)
d125 2
a126 2
  if (regnum >= 0 && regnum < AMD64_NUM_REGS)
    return amd64_register_info[regnum].name;
d135 1
a135 1
amd64_register_type (struct gdbarch *gdbarch, int regnum)
d137 1
a137 1
  gdb_assert (regnum >= 0 && regnum < AMD64_NUM_REGS);
d139 1
a139 1
  return *amd64_register_info[regnum].type;
d145 1
a145 1
static int amd64_dwarf_regmap[] =
d160 2
a161 2
  /* Return Address RA.  Mapped to RIP.  */
  X86_64_RIP_REGNUM,
d182 2
a183 2
static const int amd64_dwarf_regmap_len =
  (sizeof (amd64_dwarf_regmap) / sizeof (amd64_dwarf_regmap[0]));
d189 1
a189 1
amd64_dwarf_reg_to_regnum (int reg)
d193 2
a194 2
  if (reg >= 0 || reg < amd64_dwarf_regmap_len)
    regnum = amd64_dwarf_regmap[reg];
d206 1
a206 1
amd64_convert_register_p (int regnum, struct type *type)
a263 13
/* Return non-zero if TYPE is a non-POD structure or union type.  */

static int
amd64_non_pod_p (struct type *type)
{
  /* ??? A class with a base class certainly isn't POD, but does this
     catch all non-POD structure types?  */
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT && TYPE_N_BASECLASSES (type) > 0)
    return 1;

  return 0;
}

d275 1
a275 1
  if (len > 16 || amd64_non_pod_p (type))
a311 4
	  /* Ignore static fields.  */
	  if (TYPE_FIELD_STATIC (type, i))
	    continue;

d471 1
a471 1
		      struct value **args, CORE_ADDR sp, int struct_return)
a494 4
  /* Reserve a register for the "hidden" argument.  */
  if (struct_return)
    integer_reg++;

d595 4
a598 4
amd64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		       struct regcache *regcache, CORE_ADDR bp_addr,
		       int nargs, struct value **args,	CORE_ADDR sp,
		       int struct_return, CORE_ADDR struct_addr)
d603 1
a603 1
  sp = amd64_push_arguments (regcache, nargs, args, sp, struct_return);
d629 1
a629 1
#define AMD64_NUM_SAVED_REGS	X86_64_NUM_GREGS
d631 1
a631 1
struct amd64_frame_cache
d639 1
a639 1
  CORE_ADDR saved_regs[AMD64_NUM_SAVED_REGS];
d648 2
a649 2
static struct amd64_frame_cache *
amd64_alloc_frame_cache (void)
d651 1
a651 1
  struct amd64_frame_cache *cache;
d654 1
a654 1
  cache = FRAME_OBSTACK_ZALLOC (struct amd64_frame_cache);
d663 1
a663 1
  for (i = 0; i < AMD64_NUM_SAVED_REGS; i++)
d686 2
a687 2
amd64_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
			struct amd64_frame_cache *cache)
d725 1
a725 1
amd64_skip_prologue (CORE_ADDR start_pc)
d727 1
a727 1
  struct amd64_frame_cache cache;
d730 1
a730 1
  pc = amd64_analyze_prologue (start_pc, 0xffffffffffffffff, &cache);
d740 2
a741 2
static struct amd64_frame_cache *
amd64_frame_cache (struct frame_info *next_frame, void **this_cache)
d743 1
a743 1
  struct amd64_frame_cache *cache;
d750 1
a750 1
  cache = amd64_alloc_frame_cache ();
d755 1
a755 1
    amd64_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);
d787 1
a787 1
  for (i = 0; i < AMD64_NUM_SAVED_REGS; i++)
d795 2
a796 2
amd64_frame_this_id (struct frame_info *next_frame, void **this_cache,
		     struct frame_id *this_id)
d798 2
a799 2
  struct amd64_frame_cache *cache =
    amd64_frame_cache (next_frame, this_cache);
d809 4
a812 4
amd64_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			   int regnum, int *optimizedp,
			   enum lval_type *lvalp, CORE_ADDR *addrp,
			   int *realnump, void *valuep)
d814 2
a815 2
  struct amd64_frame_cache *cache =
    amd64_frame_cache (next_frame, this_cache);
d833 1
a833 1
  if (regnum < AMD64_NUM_SAVED_REGS && cache->saved_regs[regnum] != -1)
d852 1
a852 1
static const struct frame_unwind amd64_frame_unwind =
d855 2
a856 2
  amd64_frame_this_id,
  amd64_frame_prev_register
d860 1
a860 1
amd64_frame_sniffer (struct frame_info *next_frame)
d862 1
a862 1
  return &amd64_frame_unwind;
d872 2
a873 2
static struct amd64_frame_cache *
amd64_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
d875 1
a875 1
  struct amd64_frame_cache *cache;
d884 1
a884 1
  cache = amd64_alloc_frame_cache ();
d891 1
a891 1
  gdb_assert (tdep->sc_num_regs <= AMD64_NUM_SAVED_REGS);
d901 2
a902 2
amd64_sigtramp_frame_this_id (struct frame_info *next_frame,
			      void **this_cache, struct frame_id *this_id)
d904 2
a905 2
  struct amd64_frame_cache *cache =
    amd64_sigtramp_frame_cache (next_frame, this_cache);
d911 5
a915 5
amd64_sigtramp_frame_prev_register (struct frame_info *next_frame,
				    void **this_cache,
				    int regnum, int *optimizedp,
				    enum lval_type *lvalp, CORE_ADDR *addrp,
				    int *realnump, void *valuep)
d918 1
a918 1
  amd64_sigtramp_frame_cache (next_frame, this_cache);
d920 2
a921 2
  amd64_frame_prev_register (next_frame, this_cache, regnum,
			     optimizedp, lvalp, addrp, realnump, valuep);
d924 1
a924 1
static const struct frame_unwind amd64_sigtramp_frame_unwind =
d927 2
a928 2
  amd64_sigtramp_frame_this_id,
  amd64_sigtramp_frame_prev_register
d932 1
a932 1
amd64_sigtramp_frame_sniffer (struct frame_info *next_frame)
d942 1
a942 1
      return &amd64_sigtramp_frame_unwind;
d950 1
a950 1
amd64_frame_base_address (struct frame_info *next_frame, void **this_cache)
d952 2
a953 2
  struct amd64_frame_cache *cache =
    amd64_frame_cache (next_frame, this_cache);
d958 1
a958 1
static const struct frame_base amd64_frame_base =
d960 4
a963 4
  &amd64_frame_unwind,
  amd64_frame_base_address,
  amd64_frame_base_address,
  amd64_frame_base_address
d967 1
a967 1
amd64_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d981 1
a981 1
amd64_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
d992 2
a993 2
amd64_supply_fpregset (const struct regset *regset, struct regcache *regcache,
		       int regnum, const void *fpregs, size_t len)
d1005 2
a1006 2
amd64_regset_from_core_section (struct gdbarch *gdbarch,
				const char *sect_name, size_t sect_size)
d1016 1
a1016 1
	  tdep->fpregset->supply_regset = amd64_supply_fpregset;
d1044 3
a1046 3
  /* In contrast to the i386, on AMD64 a `long double' actually takes
     up 128 bits, even though it's still based on the i387 extended
     floating-point format which has only 80 significant bits.  */
d1049 3
a1051 3
  set_gdbarch_num_regs (gdbarch, AMD64_NUM_REGS);
  set_gdbarch_register_name (gdbarch, amd64_register_name);
  set_gdbarch_register_type (gdbarch, amd64_register_type);
d1059 9
a1067 9
  /* The "default" register numbering scheme for AMD64 is referred to
     as the "DWARF Register Number Mapping" in the System V psABI.
     The preferred debugging format for all known AMD64 targets is
     actually DWARF2, and GCC doesn't seem to support DWARF (that is
     DWARF-1), but we provide the same mapping just in case.  This
     mapping is also used for stabs, which GCC does support.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, amd64_dwarf_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, amd64_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, amd64_dwarf_reg_to_regnum);
d1070 1
a1070 1
     be in use on any of the supported AMD64 targets.  */
d1073 2
a1074 2
  set_gdbarch_push_dummy_call (gdbarch, amd64_push_dummy_call);
  set_gdbarch_frame_align (gdbarch, amd64_frame_align);
d1077 1
a1077 1
  set_gdbarch_convert_register_p (gdbarch, amd64_convert_register_p);
d1082 2
d1085 1
a1085 1
  set_gdbarch_skip_prologue (gdbarch, amd64_skip_prologue);
d1091 1
a1091 1
  set_gdbarch_unwind_dummy_id (gdbarch, amd64_unwind_dummy_id);
d1094 1
a1094 1
     since all supported AMD64 targets are ELF, but that might change
d1098 3
a1100 3
  frame_unwind_append_sniffer (gdbarch, amd64_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, amd64_frame_sniffer);
  frame_base_set_default (gdbarch, &amd64_frame_base);
d1105 1
a1105 1
					  amd64_regset_from_core_section);
@


1.26
log
@Index: ChangeLog
===================================================================
RCS file: /cvs/src/src/gdb/ChangeLog,v
retrieving revision 1.3144
diff -u -r1.3144 ChangeLog
--- ChangeLog	23 Aug 2002 23:05:38 -0000	1.3144
+++ ChangeLog	23 Aug 2002 23:14:45 -0000
@@@@ -1,3 +1,53 @@@@
2002-08-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (STORE_RETURN_VALUE): Add regcache parameter.
	(DEPRECATED_STORE_RETURN_VALUE): New method.
	(EXTRACT_RETURN_VALUE): Make buffer parameter a void pointer.
	* gdbarch.h, gdbarch.c: Re-generate.

	* values.c (set_return_value): Pass current_regcache to
	STORE_RETURN_VALUE.
	* arch-utils.h (legacy_store_return_value): Declare.
	* arch-utils.c (legacy_store_return_value): New function.
	(legacy_extract_return_value): Update parameters.

	* config/pa/tm-hppa.h (DEPRECATED_STORE_RETURN_VALUE): Rename
	STORE_RETURN_VALUE.
	* config/pa/tm-hppa64.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/z8k/tm-z8k.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparclet.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/mn10200/tm-mn10200.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-linux.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m32r/tm-m32r.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8500/tm-h8500.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8300/tm-h8300.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.

	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* i386-tdep.c (i386_extract_return_value): Update.
	* arch-utils.c (legacy_extract_return_value): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.

Index: doc/ChangeLog
2002-08-21  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Update
	STORE_RETURN_VALUE, mention regcache.
@
text
@d1147 1
a1147 1
  tm_print_insn_info.mach = bfd_lookup_arch (bfd_arch_i386, 3)->mach;
@


1.25
log
@* Makefile.in (x86-64-tdep.o): Add $(objfiles_h).
* x86-64-tdep.c: Include "objfiles.h".
(x86_64_gdbarch_init): Set in_solib_call_trampoline to
in_plt_section.  From 2002-07-18 Michal Ludvig <mludvig@@suse.cz>.
@
text
@d1099 1
a1099 1
  set_gdbarch_store_return_value (gdbarch, x86_64_store_return_value);
@


1.24
log
@2002-06-20  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-tdep.c (x86_64_register_nr2name): Rename to
	x86_64_register_name. Return type changed to 'const char *'.
	(x86_64_register_name2nr): Rename to x86_64_register_number.
	(x86_64_gdbarch_init): Update to reflect the change.
	* x86-64-tdep.h: Ditto.
	* x86-64-linux-nat.c (x86_64_fxsave_offset)
	(supply_fpregset): Ditto.
@
text
@d31 1
d1115 1
@


1.23
log
@+	* gdbarch.sh (DEPRECATED_EXTRACT_RETURN_VALUE): Rename
+	EXTRACT_RETURN_VALUE.
+	(DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Rename
+	EXTRACT_STRUCT_VALUE_ADDRESS.
+	* gdbarch.h, gdbarch.c: Regenerate.
+
+	* values.c (value_being_returned): Handle
+	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
+	(EXTRACT_RETURN_VALUE): Define as DEPRECATED_EXTRACT_RETURN_VALUE.
+
+	* arm-linux-tdep.c (arm_linux_init_abi): Update.
+	* arm-tdep.c (arm_gdbarch_init): Update.
+	* avr-tdep.c (avr_gdbarch_init): Update.
+	* cris-tdep.c (cris_gdbarch_init): Update.
+	* d10v-tdep.c (d10v_gdbarch_init): Update.
+	* ia64-tdep.c (ia64_gdbarch_init): Update.
+	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
+	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sh-tdep.c (sh_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sparc-tdep.c (sparc_gdbarch_init): Update.
+	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
+	* v850-tdep.c (v850_gdbarch_init): Update.
+	* vax-tdep.c (vax_gdbarch_init): Update.
+	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
+	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
+
+	* config/arc/tm-arc.h: Update.
+	* config/d30v/tm-d30v.h: Update.
+	* config/fr30/tm-fr30.h: Update.
+	* config/h8300/tm-h8300.h: Update.
* config/h8500/tm-h8500.h: Update.
* config/i386/tm-i386.h: Update.
* config/i386/tm-ptx.h: Update.
* config/i386/tm-symmetry.h: Update.
* config/i960/tm-i960.h: Update.
* config/m32r/tm-m32r.h: Update.
* config/m68k/tm-delta68.h: Update.
* config/m68k/tm-linux.h: Update.
* config/m68k/tm-m68k.h: Update.
* config/m88k/tm-m88k.h: Update.
* config/mcore/tm-mcore.h: Update.
* config/mips/tm-mips.h: Update.
* config/mn10200/tm-mn10200.h: Update.
* config/pa/tm-hppa.h: Update.
* config/pa/tm-hppa64.h: Update.
* config/sparc/tm-sp64.h: Update.
* config/sparc/tm-sparc.h: Update.
* config/sparc/tm-sparclet.h: Update.
* config/z8k/tm-z8k.h: Update.
@
text
@d801 2
a802 2
char *
x86_64_register_nr2name (int reg_nr)
d810 1
a810 1
x86_64_register_name2nr (const char *name)
d992 1
a992 1
  set_gdbarch_register_name (gdbarch, x86_64_register_nr2name);
@


1.22
log
@2002-06-11  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-tdep.c (x86_64_skip_prologue): Fix to work on functions
	without debug information too.
@
text
@d1079 1
a1079 1
  set_gdbarch_extract_struct_value_address (gdbarch, 0);
d1093 1
a1093 1
  set_gdbarch_extract_return_value (gdbarch, x86_64_extract_return_value);
@


1.21
log
@2002-06-07  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-linux-nat.c (x86_64_fxsave_offset): New.
	(supply_fpregset, fill_fpregset): Don't call i387_*_fxsave,
	better do the things actually here.
	* x86-64-tdep.c (x86_64_register_name2nr): New.
	(x86_64_register_name): Renamed to x86_64_register_nr2name.
	(x86_64_gdbarch_init): Respect the above change.
	* x86-64-tdep.h (x86_64_register_name2nr)
	(x86_64_register_nr2name): Add prototypes.
	* config/i386/x86-64linux.mt (TDEPFILES): Remove i387-tdep.o.
@
text
@d860 1
a860 1
  int i, firstline, currline;
d863 1
a863 1
  CORE_ADDR salendaddr = 0, endaddr = 0;
a890 3
  firstline = v_sal.line;
  currline = firstline;
  salendaddr = v_sal.end;
d894 1
a894 2
    if (v_sal.symtab->linetable->item[i].line > firstline
	&& v_sal.symtab->linetable->item[i].pc >= salendaddr
a897 1
	currline = v_sal.symtab->linetable->item[i].line;
@


1.20
log
@2002-05-24  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-tdep.c (x86_64_skip_prologue): Remove obsolete note.
	Let PC point right after the prologue before looking up symbols.
@
text
@d379 2
a380 2
					       (TYPE_FIELDS (type)[j].loc.bitpos
						+ bit_offset) % 256);
d386 2
a387 1
			(TYPE_FIELDS (type)[j].loc.bitpos + bit_offset) / 8 / 8;
d494 1
a494 1
    default: /* Avoid warning.  */
d801 2
a802 2
static char *
x86_64_register_name (int reg_nr)
d808 11
d877 1
a877 1
      return pc;	/* ... no, it doesn't. Nothing to skip.  */
d997 1
a997 1
  set_gdbarch_register_name (gdbarch, x86_64_register_name);
@


1.20.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d379 2
a380 2
					       (TYPE_FIELDS (type)[j].loc.
						bitpos + bit_offset) % 256);
d386 1
a386 2
			(TYPE_FIELDS (type)[j].loc.bitpos +
			 bit_offset) / 8 / 8;
d493 1
a493 1
    default:			/* Avoid warning.  */
d800 2
a801 2
char *
x86_64_register_nr2name (int reg_nr)
a806 11

int
x86_64_register_name2nr (const char *name)
{
  int reg_nr;

  for (reg_nr = 0; reg_nr < X86_64_NUM_REGS; reg_nr++)
    if (strcmp (name, x86_64_register_info_table[reg_nr].name) == 0)
      return reg_nr;
  return -1;
}
d848 1
a848 1
  int i;
d851 1
a851 1
  CORE_ADDR endaddr;
d865 1
a865 1
      return pc;		/* ... no, it doesn't. Nothing to skip.  */
d879 3
d885 2
a886 1
    if (v_sal.symtab->linetable->item[i].pc >= pc
d890 1
d985 1
a985 1
  set_gdbarch_register_name (gdbarch, x86_64_register_nr2name);
d1072 1
a1072 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, 0);
d1086 1
a1086 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, x86_64_extract_return_value);
@


1.20.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a30 1
#include "objfiles.h"
d801 2
a802 2
const char *
x86_64_register_name (int reg_nr)
d810 1
a810 1
x86_64_register_number (const char *name)
d992 1
a992 1
  set_gdbarch_register_name (gdbarch, x86_64_register_name);
a1113 1
  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
@


1.20.2.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d1099 1
a1099 1
  set_gdbarch_deprecated_store_return_value (gdbarch, x86_64_store_return_value);
@


1.20.2.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d1147 1
a1147 1
  tm_print_insn_info.mach = bfd_mach_x86_64;
@


1.20.2.5
log
@merge from mainline
@
text
@d4 1
a253 3
/* Push the return address (pointing to the call dummy) onto the stack
   and return the new value for the stack pointer.  */

d260 1
d265 1
a265 1
static void
d303 2
a304 2
  /* Rule #2: If one of the classes is NO_CLASS, the resulting class
     is the other class.  */
a330 5
/* Classify the argument type.  CLASSES will be filled by the register
   class used to pass each word of the operand.  The number of words
   is returned.  In case the parameter should be passed in memory, 0
   is returned.  As a special case for zero sized containers,
   classes[0] will be NO_CLASS and 1 is returned.
d332 8
a339 1
   See the x86-64 psABI for details.  */
d364 2
a365 2
	/* Zero sized arrays or structures are NO_CLASS.  We return 0
	   to signalize memory class, so handle it as special case.  */
d448 1
a448 1
	    /* X86_64_X87UP_CLASS should be preceeded by X86_64_X87_CLASS.  */
d502 2
a503 3
/* Examine the argument and set *INT_NREGS and *SSE_NREGS to the
   number of registers required based on the information passed in
   CLASSES.  Return 0 if parameter should be passed in memory.  */
d541 3
a543 3
   memory. If this function returns 1, GDB will call
   STORE_STRUCT_RETURN and EXTRACT_STRUCT_VALUE_ADDRESS else
   STORE_RETURN_VALUE and EXTRACT_RETURN_VALUE will be used.  */
d557 1
d640 1
a643 1
  /* Do nothing.  Everything is handled by the stack unwinding code.  */
d696 3
a698 3
		  deprecated_write_register_gen (int_parameter_registers
						 [(intreg + 1) / 2],
						 VALUE_CONTENTS_ALL (args[i]) + offset);
d703 2
a704 2
		  deprecated_write_register_gen (int_parameter_registers[intreg / 2],
						 VALUE_CONTENTS_ALL (args[i]) + offset);
d711 3
a713 3
		  deprecated_write_register_gen (sse_parameter_registers
						 [(ssereg + 1) / 2],
						 VALUE_CONTENTS_ALL (args[i]) + offset);
d718 2
a719 2
		  deprecated_write_register_gen (sse_parameter_registers[ssereg / 2],
						 VALUE_CONTENTS_ALL (args[i]) + offset);
a864 1
  unsigned char prolog_buf[PROLOG_BUFSIZE];
d866 6
a871 6
  /* We will handle only functions starting with: */
  static unsigned char prolog_expect[PROLOG_BUFSIZE] =
  {
    0x55,			/* pushq %rbp */
    0x48, 0x89, 0xe5		/* movq %rsp, %rbp */
  };
d875 1
a875 1
  /* First check, whether pc points to pushq %rbp, movq %rsp, %rbp.  */
d878 1
a878 1
      return pc;		/* ... no, it doesn't.  Nothing to skip.  */
d880 1
a880 1
  /* OK, we have found the prologue and want PC of the first
d887 2
a888 2
  /* If pc doesn't point to a function with debuginfo, some of the
     following may be NULL.  */
d892 1
a892 1
  endaddr = BLOCK_END (SYMBOL_BLOCK_VALUE (v_function));
d906 2
a907 2
static const unsigned char *
x86_64_breakpoint_from_pc (CORE_ADDR *pc, int *lenptr)
d914 2
a915 2
static void
x86_64_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
d917 2
a918 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d921 64
a984 2
  /* The x86-64 has 16 SSE registers.  */
  tdep->num_xmm_regs = 16;
a985 1
  /* This is what all the fuss is about.  */
d990 1
a990 4
  /* In contrast to the i386, on the x86-64 a `long double' actually
     takes up 128 bits, even though it's still based on the i387
     extended floating-point format which has only 80 significant bits.  */
  set_gdbarch_long_double_bit (gdbarch, 128);
a992 21

  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, 7); /* %rsp */
  set_gdbarch_fp_regnum (gdbarch, 6); /* %rbp */
  set_gdbarch_pc_regnum (gdbarch, 16); /* %rip */
  set_gdbarch_ps_regnum (gdbarch, 17); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, X86_64_NUM_GREGS); /* %st(0) */

  /* The "default" register numbering scheme for the x86-64 is
     referred to as the "DWARF register number mapping" in the psABI.
     The preferred debugging format for all known x86-64 targets is
     actually DWARF2, and GCC doesn't seem to support DWARF (that is
     DWARF-1), but we provide the same mapping just in case.  This
     mapping is also used for stabs, which GCC does support.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, x86_64_dwarf2_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, x86_64_dwarf2_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, x86_64_dwarf2_reg_to_regnum);

  /* We don't override SDB_REG_RO_REGNUM, sice COFF doesn't seem to be
     in use on any of the supported x86-64 targets.  */

d995 3
d999 2
a1000 3
  /* Total amount of space needed to store our copies of the machine's
     register (SIZEOF_GREGS + SIZEOF_FPU_REGS + SIZEOF_FPU_CTRL_REGS +
     SIZEOF_SSE_REGS) */
d1004 2
a1006 2
  set_gdbarch_register_raw_size (gdbarch, x86_64_register_raw_size);
  set_gdbarch_register_byte (gdbarch, x86_64_register_byte);
a1008 4
  /* FIXME: kettenis/20021026: As long as we don't support longjmp,
     that is, as long as we have `tdep->jb_pc_offset == -1', using
     i386_get_longjmp_target is fine.  */

d1015 6
a1020 2
  /* Getting saved registers is handled by unwind information.  */
  set_gdbarch_get_saved_register (gdbarch, cfi_get_saved_register);
a1021 1
  /* FIXME: kettenis/20021026: Should we set parm_boundary to 64 here?  */
d1024 1
a1024 6
  /* FIXME: kettenis/20021026: Should be undeprecated.  */
  set_gdbarch_extract_return_value (gdbarch, NULL);
  set_gdbarch_deprecated_extract_return_value (gdbarch,
					       x86_64_extract_return_value);
  set_gdbarch_push_arguments (gdbarch, x86_64_push_arguments);
  set_gdbarch_push_return_address (gdbarch, x86_64_push_return_address);
a1025 8
  set_gdbarch_store_struct_return (gdbarch, x86_64_store_struct_return);
  /* FIXME: kettenis/20021026: Should be undeprecated.  */
  set_gdbarch_store_return_value (gdbarch, NULL);
  set_gdbarch_deprecated_store_return_value (gdbarch,
					     x86_64_store_return_value);
  /* Override, since this is handled by x86_64_extract_return_value.  */
  set_gdbarch_extract_struct_value_address (gdbarch, NULL);
  set_gdbarch_use_struct_convention (gdbarch, x86_64_use_struct_convention);
d1027 3
a1029 2
  set_gdbarch_frame_init_saved_regs (gdbarch, x86_64_frame_init_saved_regs);
  set_gdbarch_skip_prologue (gdbarch, x86_64_skip_prologue);
a1030 1
  set_gdbarch_frame_chain (gdbarch, x86_64_linux_frame_chain);
d1032 1
a1032 6
					 x86_64_frameless_function_invocation);
  /* FIXME: kettenis/20021025: Shouldn't this be set to
     generic_file_frame_chain_valid?  */
  set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
  /* FIXME: kettenis/20021026: These two are GNU/Linux-specific and
     should be moved elsewhere.  */
a1033 4
  set_gdbarch_saved_pc_after_call (gdbarch, x86_64_linux_saved_pc_after_call);
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
  /* FIXME: kettenis/20021026: This one is GNU/Linux-specific too.  */
  set_gdbarch_pc_in_sigtramp (gdbarch, x86_64_linux_in_sigtramp);
d1035 10
a1044 2
  /* Build call frame information (CFI) from DWARF2 frame debug info.  */
  set_gdbarch_dwarf2_build_frame_info (gdbarch, dwarf2_build_frame_info);
d1046 1
a1046 1
  /* Initialization of per-frame CFI.  */
d1049 2
a1050 2
  /* Frame PC initialization is handled by using CFI.  */
  set_gdbarch_init_frame_pc (gdbarch, x86_64_init_frame_pc);
d1052 3
a1054 1
  /* Cons up virtual frame pointer for trace.  */
a1056 5
  /* FIXME: kettenis/20021026: This is ELF-specific.  Fine for now,
     since all supported x86-64 targets are ELF, but that might change
     in the future.  */
  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
}
d1058 1
a1058 6
static struct gdbarch *
x86_64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch_tdep *tdep;
  struct gdbarch *gdbarch;
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
d1060 16
a1075 3
  /* Try to determine the OS ABI of the object we're loading.  */
  if (info.abfd != NULL)
    osabi = gdbarch_lookup_osabi (info.abfd);
d1077 4
a1080 10
  /* Find a candidate among extant architectures.  */
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      /* Make sure the OS ABI selection matches.  */
      tdep = gdbarch_tdep (arches->gdbarch);
      if (tdep && tdep->osabi == osabi)
        return arches->gdbarch;
    }
d1082 4
a1085 3
  /* Allocate space for the new architecture.  */
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);
d1087 3
a1089 1
  tdep->osabi = osabi;
d1091 4
a1094 3
  /* FIXME: kettenis/20021025: The following calls are going to
     disappear when we integrate the x86_64 target into the i386
     target.  */
a1095 1
  set_gdbarch_long_double_format (gdbarch, &floatformat_i387_ext);
d1097 4
a1100 4
  set_gdbarch_max_register_raw_size (gdbarch, 16);
  set_gdbarch_max_register_virtual_size (gdbarch, 16);

  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
d1102 1
a1102 2
  set_gdbarch_breakpoint_from_pc (gdbarch, x86_64_breakpoint_from_pc);
  set_gdbarch_decr_pc_after_break (gdbarch, 1);
d1105 1
a1105 3
  set_gdbarch_frame_args_skip (gdbarch, 8);
  set_gdbarch_frame_args_address (gdbarch, default_frame_address);
  set_gdbarch_frame_locals_address (gdbarch, default_frame_address);
d1107 1
a1107 1
  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);
d1109 1
a1109 11
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
  set_gdbarch_call_dummy_address (gdbarch, entry_point_address);
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
  set_gdbarch_call_dummy_length (gdbarch, 0);
  set_gdbarch_call_dummy_p (gdbarch, 1);
  set_gdbarch_call_dummy_words (gdbarch, NULL);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, 0);
  set_gdbarch_fix_call_dummy (gdbarch, generic_fix_call_dummy);
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
d1111 3
a1113 1
  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_at_entry_point);
d1115 1
a1115 1
  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);
d1117 3
a1119 1
  /* FIXME: kettenis/20021025: These already are the default.  */
d1121 3
a1123 4
  set_gdbarch_register_virtual_size (gdbarch, generic_register_size);
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, 0);

  x86_64_init_abi (info, gdbarch);
@


1.19
log
@2002-05-13  Daniel Jacobowitz  <drow@@mvista.com>

        * ax-gdb.c (gen_sign_extend, gen_fetch, gen_usual_unary)
        (gen_cast, gen_scale, gen_add, gen_sub, gen_binop, gen_deref)
        (gen_address_of, gen_struct_ref, gen_repeat): Use type
        access macros.
        * c-typeprint.c (cp_type_print_method_args): Likewise.
        (c_type_print_args): Likewise.
        * d10v-tdep.c (d10v_push_arguments): Likewise.
        (d10v_extract_return_value): Likewise.
        * expprint.c (print_subexp): Likewise.
        * gdbtypes.c (lookup_primitive_typename): Likewise.
        (lookup_template_type, add_mangled_type, print_arg_types): Likewise.
        * gdbtypes.h (TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB)
        (TYPE_TARGET_STUB, TYPE_STATIC, TYPE_CONST, TYPE_VOLATILE)
        (TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_CODE_SPACE, TYPE_VARARGS)
        (TYPE_VECTOR): Likewise.
        * hpread.c (hpread_read_struct_type)
        (fix_static_member_physnames, fixup_class_method_type)
        (hpread_type_lookup): Likewise.
        * mdebugread.c (parse_symbol, parse_type): Likewise.
        * p-lang.c (is_pascal_string_type): Likewise.
        * valops.c (hand_function_call): Likewise.
        * x86-64-tdep.c (classify_argument): Likewise.

        * hpread.c (hpread_read_function_type)
        (hpread_read_doc_function_type): Call replace_type.
        * dstread.c (create_new_type): Delete.
        (decode_dst_structure, process_dst_function): Call alloc_type.
        Use type access macros.
@
text
@d862 2
a863 15
  /* First check, whether pc points to pushq %rbp. If not, 
   * print a recommendation to enable frame pointer.  */
  if (prolog_expect[0] != prolog_buf[0])
    {
      if (!omit_fp_note_printed)
	{
	  printf_filtered
	    ("NOTE: This function doesn't seem to have a valid prologue.\n"
	     "      Consider adding -fno-omit-frame-pointer to your gcc's CFLAGS.\n");
	  omit_fp_note_printed++;
	}
      return pc;
    }
  /* Valid prolog continues with movq %rsp,%rbp.  */
  for (i = 1; i < PROLOG_BUFSIZE; i++)
d865 5
a869 1
      return pc + 1;		/* First instruction after pushq %rbp.  */
@


1.19.2.1
log
@merge from trunk
@
text
@d379 2
a380 2
					       (TYPE_FIELDS (type)[j].loc.
						bitpos + bit_offset) % 256);
d386 1
a386 2
			(TYPE_FIELDS (type)[j].loc.bitpos +
			 bit_offset) / 8 / 8;
d493 1
a493 1
    default:			/* Avoid warning.  */
d800 2
a801 2
char *
x86_64_register_nr2name (int reg_nr)
a806 11

int
x86_64_register_name2nr (const char *name)
{
  int reg_nr;

  for (reg_nr = 0; reg_nr < X86_64_NUM_REGS; reg_nr++)
    if (strcmp (name, x86_64_register_info_table[reg_nr].name) == 0)
      return reg_nr;
  return -1;
}
d848 1
a848 1
  int i;
d851 1
a851 1
  CORE_ADDR endaddr;
d862 15
a876 2
  /* First check, whether pc points to pushq %rbp, movq %rsp,%rbp.  */
  for (i = 0; i < PROLOG_BUFSIZE; i++)
d878 1
a878 5
      return pc;		/* ... no, it doesn't. Nothing to skip.  */

  /* OK, we have found the prologue and want PC of the first 
     non-prologue instruction.  */
  pc += PROLOG_BUFSIZE;
d888 3
d894 2
a895 1
    if (v_sal.symtab->linetable->item[i].pc >= pc
d899 1
d994 1
a994 1
  set_gdbarch_register_name (gdbarch, x86_64_register_nr2name);
d1081 1
a1081 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, 0);
d1095 1
a1095 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, x86_64_extract_return_value);
@


1.19.2.2
log
@More merging.
@
text
@d801 2
a802 2
const char *
x86_64_register_name (int reg_nr)
d810 1
a810 1
x86_64_register_number (const char *name)
d992 1
a992 1
  set_gdbarch_register_name (gdbarch, x86_64_register_name);
@


1.18
log
@* arch-utils.h (generic_register_size): Declare.
(generic_register_raw_size, generic_register_virtual_size): Delete
declarations.
* arch-utils.c (generic_register_raw_size): Delete.
(generic_register_size): New function.
(generic_register_virtual_size): Delete.

* gdbarch.sh (REGISTER_RAW_SIZE, REGISTER_VIRTUAL_SIZE): Make
default generic_register_size.
* gdbarch.h, gdbarch.c: Re-generate.

* d10v-tdep.c (d10v_gdbarch_init): Use generic_register_size for
register_virtual_size.
* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.

* gdbint.texinfo (Target Architecture Definition): Mention
defaults for REGISTER_VIRTUAL_SIZE and REGISTER_RAW_SIZE.
(Target Architecture Definition): Mention same.  Add references to
web pages.
@
text
@d375 1
a375 1
	      for (j = 0; j < type->nfields; ++j)
d377 1
a377 1
		  int num = classify_argument (type->fields[j].type,
d379 1
a379 1
					       (type->fields[j].loc.bitpos
d386 1
a386 1
			(type->fields[j].loc.bitpos + bit_offset) / 8 / 8;
d397 1
a397 1
	      num = classify_argument (type->target_type,
d416 1
a416 1
		for (j = 0; j < type->nfields; ++j)
d419 1
a419 1
		    num = classify_argument (type->fields[j].type,
@


1.17
log
@2002-05-07  Michal Ludvig  <mludvig@@suse.cz>
	* dwarf2cfi.c: Code cleanup, removed unused variables,
	added default labels to switch {} statements.
	* x86-64-tdep.c: Ditto.
	* x86-64-linux-nat.c: Ditto.
@
text
@d1005 1
a1005 1
  set_gdbarch_register_virtual_size (gdbarch, generic_register_virtual_size);
@


1.16
log
@2002-05-03  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-tdep.c (x86_64_dwarf2gdb_regno_map),
	(x86_64_dwarf2gdb_regno_map_length),
	(x86_64_dwarf2_reg_to_regnum): Added.
	(x86_64_gdbarch_init): Added registration of x86_64_dwarf2_reg_to_regnum.
	(x86_64_gdbarch_init): Renamed from i386_gdbarch_init.
	(_initialize_x86_64_tdep): Synced with the change above.
	(x86_64_skip_prologue): Reformulated message.
@
text
@d198 1
a198 1
  DOUBLEST d;
d429 2
d493 2
@


1.15
log
@2002-04-29  Michal Ludvig  <mludvig@@suse.cz>
	* x86-64-linux-nat.c (fill_gregset): Explicit cast to avoid warning.
	* x86-64-tdep.c (i386_gdbarch_init): Ditto.
	(x86_64_register_info_table): Added comments with register numbers.
@
text
@d40 1
d110 27
d229 13
d866 1
a866 1
	     "      Try to add -fno-omit-frame-pointer tou your gcc's CFLAGS.\n");
d912 1
a912 1
i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
d938 1
a938 1
			      "i386_gdbarch_init: unknown machine type");
d955 1
a955 1
			      "i386_gdbarch_init: unknown machine type");
d960 1
a960 1
			  "i386_gdbarch_init: unknown machine type");
d980 1
a980 1
		      "i386_gdbarch_init: unknown machine type");
d1119 2
d1127 1
a1127 1
  register_gdbarch_init (bfd_arch_i386, i386_gdbarch_init);
@


1.14
log
@* x86-64-tdep.c (x86_64_skip_prologue): Print note when debugging
code without frame pointers.
@
text
@d52 55
a106 55
  {8, "rax", &builtin_type_int64},
  {8, "rbx", &builtin_type_int64},
  {8, "rcx", &builtin_type_int64},
  {8, "rdx", &builtin_type_int64},
  {8, "rsi", &builtin_type_int64},
  {8, "rdi", &builtin_type_int64},
  {8, "rbp", &builtin_type_void_func_ptr},
  {8, "rsp", &builtin_type_void_func_ptr},
  {8, "r8", &builtin_type_int64},
  {8, "r9", &builtin_type_int64},
  {8, "r10", &builtin_type_int64},
  {8, "r11", &builtin_type_int64},
  {8, "r12", &builtin_type_int64},
  {8, "r13", &builtin_type_int64},
  {8, "r14", &builtin_type_int64},
  {8, "r15", &builtin_type_int64},
  {8, "rip", &builtin_type_void_func_ptr},
  {4, "eflags", &builtin_type_int32},
  {4, "ds", &builtin_type_int32},
  {4, "es", &builtin_type_int32},
  {4, "fs", &builtin_type_int32},
  {4, "gs", &builtin_type_int32},
  {10, "st0", &builtin_type_i387_ext},
  {10, "st1", &builtin_type_i387_ext},
  {10, "st2", &builtin_type_i387_ext},
  {10, "st3", &builtin_type_i387_ext},
  {10, "st4", &builtin_type_i387_ext},
  {10, "st5", &builtin_type_i387_ext},
  {10, "st6", &builtin_type_i387_ext},
  {10, "st7", &builtin_type_i387_ext},
  {4, "fctrl", &builtin_type_int32},
  {4, "fstat", &builtin_type_int32},
  {4, "ftag", &builtin_type_int32},
  {4, "fiseg", &builtin_type_int32},
  {4, "fioff", &builtin_type_int32},
  {4, "foseg", &builtin_type_int32},
  {4, "fooff", &builtin_type_int32},
  {4, "fop", &builtin_type_int32},
  {16, "xmm0", &builtin_type_v4sf},
  {16, "xmm1", &builtin_type_v4sf},
  {16, "xmm2", &builtin_type_v4sf},
  {16, "xmm3", &builtin_type_v4sf},
  {16, "xmm4", &builtin_type_v4sf},
  {16, "xmm5", &builtin_type_v4sf},
  {16, "xmm6", &builtin_type_v4sf},
  {16, "xmm7", &builtin_type_v4sf},
  {16, "xmm8", &builtin_type_v4sf},
  {16, "xmm9", &builtin_type_v4sf},
  {16, "xmm10", &builtin_type_v4sf},
  {16, "xmm11", &builtin_type_v4sf},
  {16, "xmm12", &builtin_type_v4sf},
  {16, "xmm13", &builtin_type_v4sf},
  {16, "xmm14", &builtin_type_v4sf},
  {16, "xmm15", &builtin_type_v4sf},
  {4, "mxcsr", &builtin_type_int32}
d612 1
a612 1
    8 /* R8  */ , 9 /* R9  */
d1067 3
a1069 1
  set_gdbarch_breakpoint_from_pc (gdbarch, x86_64_breakpoint_from_pc);
@


1.13
log
@* h8500-tdep.c (h8500_write_fp): Delete function.
* dwarf2cfi.c (cfi_write_fp): Document as not used.
* mips-tdep.c (mips_gdbarch_init): Do not set write_fp.
* ia64-tdep.c (ia64_gdbarch_init): Do not set write_fp.
* m68hc11-tdep.c (m68hc11_gdbarch_init): Do not set write_fp.
* rs6000-tdep.c (rs6000_gdbarch_init): Do not set write_fp.
* s390-tdep.c (s390_gdbarch_init): Do not set write_fp.
(s390_write_fp):
* sh-tdep.c (sh_gdbarch_init): Do not set write_fp.
* x86-64-tdep.c (i386_gdbarch_init): Do not set write_fp.
* d10v-tdep.c (d10v_gdbarch_init): Do not set write_fp.
(d10v_write_fp): Delete function.
* inferior.h (write_fp, generic_target_write_fp): Delete
declarations.
* regcache.c (generic_target_write_fp): Delete function.
(write_fp): Delete function.
* gdbarch.sh (TARGET_WRITE_FP): Delete.
* gdbarch.h, gdbarch.c: Regenerate.
* config/v850/tm-v850.h (TARGET_WRITE_FP): Delete macro.
* config/sparc/tm-sp64.h (TARGET_WRITE_FP): Delete macro.
(sparc64_write_fp): Delete declaration.
* config/h8500/tm-h8500.h (TARGET_WRITE_FP): Delete macro.
(h8500_write_fp): Delete declaration.
@
text
@d119 3
d817 15
a831 2
  /* First check, whether pc points to pushq %rbp, movq %rsp,%rbp.  */
  for (i = 0; i < PROLOG_BUFSIZE; i++)
d833 1
a833 1
      return pc;
@


1.12
log
@	* x86-64-tdep.h (X86_64_NUM_REGS, X86_64_NUM_GREGS): Delete #defines.
	(x86_64_num_regs, x86_64_num_gregs): Added extern variables.
	* x86-64-linux-nat.c (x86_64_regmap): Swapped RBX <> RDX, added DS, ES, FS, GS.
	(x86_64_linux_dr_get_status, supply_gregset),
	(fill_gregset): Changed X86_64_NUM_GREGS to x86_64_num_gregs.
	* x86-64-tdep.c (x86_64_register_raw_size_table): Delete.
	(x86_64_register_info_table): Add.
	(X86_64_NUM_REGS, X86_64_NUM_GREGS): Add.
	(x86_64_register_raw_size, x86_64_register_virtual_type),
	(x86_64_register_name, _initialize_x86_64_tdep): Changed to reflect new
	general x86_64_register_info_table.
	(i386_gdbarch_init): gdbarch_register_bytes is now set
	dynamicaly during initialization.
	* regformats/reg-x86-64.dat: Synced with changes to registers above.
	* gdbserver/linux-x86-64-low.c: Ditto.
@
text
@a962 1
  set_gdbarch_write_fp (gdbarch, cfi_write_fp);
@


1.11
log
@	* x86-64-tdep.c (x86_64_skip_prologue): Rewritten from scratch.
@
text
@a34 1

d37 1
a37 1
#define RDX_REGNUM 1
d40 8
a47 1
#define XMM1_REGNUM  35
d51 56
a106 15
int x86_64_register_raw_size_table[X86_64_NUM_REGS] = {
  8, 8, 8, 8,
  8, 8, 8, 8,
  8, 8, 8, 8,
  8, 8, 8, 8,
  8, 4,
  10, 10, 10, 10,
  10, 10, 10, 10,
  4, 4, 4, 4,
  4, 4, 4, 4,
  16, 16, 16, 16,
  16, 16, 16, 16,
  16, 16, 16, 16,
  16, 16, 16, 16,
  4
d109 10
d124 1
a124 1
  return x86_64_register_raw_size_table[regno];
d129 1
a129 1
   x86_64_register_raw_size_table.  */
d144 1
a144 10
  if (regno == PC_REGNUM || regno == SP_REGNUM)
    return builtin_type_void_func_ptr;
  if (IS_FP_REGNUM (regno))
    return builtin_type_i387_ext;
  if (IS_SSE_REGNUM (regno))
    return builtin_type_v4sf;
  if (IS_FPU_CTRL_REGNUM (regno) || regno == MXCSR_REGNUM
      || regno == EFLAGS_REGNUM)
    return builtin_type_int32;
  return builtin_type_int64;
d607 3
a609 3
    5 /*RDI*/, 4 /*RSI*/,
    1 /*RDX*/, 2 /*RCX*/,
    8 /*R8 */ , 9		/*R9 */
d613 4
a616 4
    34, 35, 36, 37,
    38, 39, 40, 41,
    42, 43, 44, 45,
    46, 47, 48, 49
d755 1
a755 17
  static char *register_names[] = {
    "rax", "rdx", "rcx", "rbx",
    "rsi", "rdi", "rbp", "rsp",
    "r8", "r9", "r10", "r11",
    "r12", "r13", "r14", "r15",
    "rip", "eflags",
    "st0", "st1", "st2", "st3",
    "st4", "st5", "st6", "st7",
    "fctrl", "fstat", "ftag", "fiseg",
    "fioff", "foseg", "fooff", "fop",
    "xmm0", "xmm1", "xmm2", "xmm3",
    "xmm4", "xmm5", "xmm6", "xmm7",
    "xmm8", "xmm9", "xmm10", "xmm11",
    "xmm12", "xmm13", "xmm14", "xmm15",
    "mxcsr"
  };
  if (reg_nr < 0)
d757 1
a757 3
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
d847 1
a847 1
x86_64_breakpoint_from_pc (CORE_ADDR *pc, int *lenptr)
d859 1
d938 1
d941 3
a943 2
  set_gdbarch_register_bytes (gdbarch,
			      (18 * 8) + (8 * 10) + (8 * 4) + (16 * 16 + 4));
d960 1
a960 1
  set_gdbarch_fp0_regnum (gdbarch, 18);	/* First FPU floating-point register.  */
d1078 1
a1078 1
	offset += x86_64_register_raw_size_table[i];
@


1.10
log
@* MAINTAINERS (x86-64): Add myself
* x86-64-tdep.c (x86_64_push_arguments): Fixed typo naregs->nregs,
changed value_ptr -> struct value *
@
text
@d762 5
a766 1
/* On x86_64 there are no reasonable prologs.  */
d770 42
@


1.9
log
@Update copyright.  re-indent.
@
text
@d572 1
a572 1
  stack_values = alloca (naregs * sizeof (int));
d642 1
a642 1
      value_ptr arg = args[stack_values[stack_values_count]];
@


1.9.2.1
log
@	* x86-64-tdep.c (x86_64_skip_prologue): Rewritten from scratch.
	* x86-64-tdep.h (X86_64_NUM_REGS, X86_64_NUM_GREGS): Delete #defines.
	(x86_64_num_regs, x86_64_num_gregs): Added extern variables.
	* x86-64-linux-nat.c (x86_64_regmap): Swapped RBX <> RDX, added DS, ES, FS, GS.
	(x86_64_linux_dr_get_status, supply_gregset),
	(fill_gregset): Changed X86_64_NUM_GREGS to x86_64_num_gregs.
	* x86-64-tdep.c (x86_64_register_raw_size_table): Delete.
	(x86_64_register_info_table): Add.
	(X86_64_NUM_REGS, X86_64_NUM_GREGS): Add.
	(x86_64_register_raw_size, x86_64_register_virtual_type),
	(x86_64_register_name, _initialize_x86_64_tdep): Changed to reflect new
	general x86_64_register_info_table.
	(i386_gdbarch_init): gdbarch_register_bytes is now set
	dynamicaly during initialization.
	* regformats/reg-x86-64.dat: Synced with changes to registers above.
	* gdbserver/linux-x86-64-low.c: Ditto.
@
text
@d35 1
d38 1
a38 1
#define RDX_REGNUM 3
d41 1
a41 8
#define XMM1_REGNUM  39

struct register_info
{
  int size;
  char *name;
  struct type **type;
};
d45 15
a59 56
static struct register_info x86_64_register_info_table[] = {
  {8, "rax", &builtin_type_int64},
  {8, "rbx", &builtin_type_int64},
  {8, "rcx", &builtin_type_int64},
  {8, "rdx", &builtin_type_int64},
  {8, "rsi", &builtin_type_int64},
  {8, "rdi", &builtin_type_int64},
  {8, "rbp", &builtin_type_void_func_ptr},
  {8, "rsp", &builtin_type_void_func_ptr},
  {8, "r8", &builtin_type_int64},
  {8, "r9", &builtin_type_int64},
  {8, "r10", &builtin_type_int64},
  {8, "r11", &builtin_type_int64},
  {8, "r12", &builtin_type_int64},
  {8, "r13", &builtin_type_int64},
  {8, "r14", &builtin_type_int64},
  {8, "r15", &builtin_type_int64},
  {8, "rip", &builtin_type_void_func_ptr},
  {4, "eflags", &builtin_type_int32},
  {4, "ds", &builtin_type_int32},
  {4, "es", &builtin_type_int32},
  {4, "fs", &builtin_type_int32},
  {4, "gs", &builtin_type_int32},
  {10, "st0", &builtin_type_i387_ext},
  {10, "st1", &builtin_type_i387_ext},
  {10, "st2", &builtin_type_i387_ext},
  {10, "st3", &builtin_type_i387_ext},
  {10, "st4", &builtin_type_i387_ext},
  {10, "st5", &builtin_type_i387_ext},
  {10, "st6", &builtin_type_i387_ext},
  {10, "st7", &builtin_type_i387_ext},
  {4, "fctrl", &builtin_type_int32},
  {4, "fstat", &builtin_type_int32},
  {4, "ftag", &builtin_type_int32},
  {4, "fiseg", &builtin_type_int32},
  {4, "fioff", &builtin_type_int32},
  {4, "foseg", &builtin_type_int32},
  {4, "fooff", &builtin_type_int32},
  {4, "fop", &builtin_type_int32},
  {16, "xmm0", &builtin_type_v4sf},
  {16, "xmm1", &builtin_type_v4sf},
  {16, "xmm2", &builtin_type_v4sf},
  {16, "xmm3", &builtin_type_v4sf},
  {16, "xmm4", &builtin_type_v4sf},
  {16, "xmm5", &builtin_type_v4sf},
  {16, "xmm6", &builtin_type_v4sf},
  {16, "xmm7", &builtin_type_v4sf},
  {16, "xmm8", &builtin_type_v4sf},
  {16, "xmm9", &builtin_type_v4sf},
  {16, "xmm10", &builtin_type_v4sf},
  {16, "xmm11", &builtin_type_v4sf},
  {16, "xmm12", &builtin_type_v4sf},
  {16, "xmm13", &builtin_type_v4sf},
  {16, "xmm14", &builtin_type_v4sf},
  {16, "xmm15", &builtin_type_v4sf},
  {4, "mxcsr", &builtin_type_int32}
a61 10
/* Number of all registers */
#define X86_64_NUM_REGS (sizeof (x86_64_register_info_table) / \
  sizeof (x86_64_register_info_table[0]))

/* Number of general registers.  */
#define X86_64_NUM_GREGS (22)

int x86_64_num_regs = X86_64_NUM_REGS;
int x86_64_num_gregs = X86_64_NUM_GREGS;

d67 1
a67 1
  return x86_64_register_info_table[regno].size;
d72 1
a72 1
   x86_64_register_info_table.  */
d87 10
a96 1
  return *x86_64_register_info_table[regno].type;
d559 3
a561 3
    5 /* RDI */ , 4 /* RSI */ ,
    3 /* RDX */ , 2 /* RCX */ ,
    8 /* R8  */ , 9 /* R9  */
d565 4
a568 4
    XMM1_REGNUM - 1, XMM1_REGNUM, XMM1_REGNUM + 1, XMM1_REGNUM + 2,
    XMM1_REGNUM + 3, XMM1_REGNUM + 4, XMM1_REGNUM + 5, XMM1_REGNUM + 6,
    XMM1_REGNUM + 7, XMM1_REGNUM + 8, XMM1_REGNUM + 9, XMM1_REGNUM + 10,
    XMM1_REGNUM + 11, XMM1_REGNUM + 12, XMM1_REGNUM + 13, XMM1_REGNUM + 14
d572 1
a572 1
  stack_values = alloca (nargs * sizeof (int));
d642 1
a642 1
      struct value *arg = args[stack_values[stack_values_count]];
d707 17
a723 1
  if (reg_nr < 0 || reg_nr >= X86_64_NUM_REGS)
d725 3
a727 1
  return x86_64_register_info_table[reg_nr].name;
d762 1
a762 5
/* If a function with debugging information and known beginning
   is detected, we will return pc of the next line in the source 
   code. With this approach we effectively skip the prolog.  */

#define PROLOG_BUFSIZE 4
a765 42
  int i, firstline, currline;
  struct symtab_and_line v_sal;
  struct symbol *v_function;
  CORE_ADDR salendaddr = 0, endaddr = 0;

  /* We will handle only functions beginning with:
     55          pushq %rbp
     48 89 e5    movq %rsp,%rbp 
   */
  unsigned char prolog_expect[PROLOG_BUFSIZE] = { 0x55, 0x48, 0x89, 0xe5 },
    prolog_buf[PROLOG_BUFSIZE];

  read_memory (pc, (char *) prolog_buf, PROLOG_BUFSIZE);

  /* First check, whether pc points to pushq %rbp, movq %rsp,%rbp.  */
  for (i = 0; i < PROLOG_BUFSIZE; i++)
    if (prolog_expect[i] != prolog_buf[i])
      return pc;

  v_function = find_pc_function (pc);
  v_sal = find_pc_line (pc, 0);

  /* If pc doesn't point to a function with debuginfo, 
     some of the following may be NULL.  */
  if (!v_function || !v_function->ginfo.value.block || !v_sal.symtab)
    return pc;

  firstline = v_sal.line;
  currline = firstline;
  salendaddr = v_sal.end;
  endaddr = v_function->ginfo.value.block->endaddr;

  for (i = 0; i < v_sal.symtab->linetable->nitems; i++)
    if (v_sal.symtab->linetable->item[i].line > firstline
	&& v_sal.symtab->linetable->item[i].pc >= salendaddr
	&& v_sal.symtab->linetable->item[i].pc < endaddr)
      {
	pc = v_sal.symtab->linetable->item[i].pc;
	currline = v_sal.symtab->linetable->item[i].line;
	break;
      }

d771 1
a771 1
x86_64_breakpoint_from_pc (CORE_ADDR * pc, int *lenptr)
a782 1
  int i, sum;
a860 1

d863 2
a864 3
  for (i = 0, sum = 0; i < X86_64_NUM_REGS; i++)
    sum += x86_64_register_info_table[i].size;
  set_gdbarch_register_bytes (gdbarch, sum);
d881 1
a881 1
  set_gdbarch_fp0_regnum (gdbarch, X86_64_NUM_GREGS);	/* First FPU floating-point register.  */
d999 1
a999 1
	offset += x86_64_register_info_table[i].size;
@


1.9.2.2
log
@* x86-64-tdep.c (x86_64_skip_prologue): Print note when debugging
code without frame pointers.
@
text
@a118 3
/* Did we already print a note about frame pointer?  */
int omit_fp_note_printed = 0;

d814 3
a816 11
  /* First check, whether pc points to pushq %rbp. If not, 
   * print a recommendation to enable frame pointer.  */
  if (prolog_expect[0] != prolog_buf[0])
    {
      if (!omit_fp_note_printed)
	{
	  printf_filtered
	    ("NOTE: This function doesn't seem to have a valid prologue.\n"
	     "      Try to add -fno-omit-frame-pointer tou your gcc's CFLAGS.\n");
	  omit_fp_note_printed++;
	}
a817 5
    }
  /* Valid prolog continues with movq %rsp,%rbp.  */
  for (i = 1; i < PROLOG_BUFSIZE; i++)
    if (prolog_expect[i] != prolog_buf[i])
      return pc + 1;		/* First instruction after pushq %rbp.  */
@


1.9.2.3
log
@2002-04-28  Michal Ludvig  <mludvig@@suse.cz>
	* x86-64-tdep.c (x86_64_skip_prologue): Reformulated message.
@
text
@d825 1
a825 1
	     "      Consider adding -fno-omit-frame-pointer to your gcc's CFLAGS.\n");
@


1.9.2.4
log
@revert tweak
@
text
@d825 1
a825 1
	     "      Try to add -fno-omit-frame-pointer tou your gcc's CFLAGS.\n");
@


1.9.2.5
log
@2002-06-07  Michal Ludvig  <mludvig@@suse.cz>

	Merge from mainline:

	2002-05-27  Michal Ludvig  <mludvig@@suse.cz>

		* x86-64-tdep.c (x86_64_skip_prologue): Remove obsolete
		note. Let PC point right after the prologue before looking
		up symbols.
@
text
@d817 15
a831 2
  /* First check, whether pc points to pushq %rbp, movq %rsp,%rbp.  */
  for (i = 0; i < PROLOG_BUFSIZE; i++)
d833 1
a833 5
      return pc;	/* ... no, it doesn't. Nothing to skip.  */

  /* OK, we have found the prologue and want PC of the first 
     non-prologue instruction.  */
  pc += PROLOG_BUFSIZE;
@


1.9.2.6
log
@Merge with mainline.
@
text
@a39 1
#define ST0_REGNUM 22
d52 55
a106 55
  /*  0 */ {8, "rax", &builtin_type_int64},
  /*  1 */ {8, "rbx", &builtin_type_int64},
  /*  2 */ {8, "rcx", &builtin_type_int64},
  /*  3 */ {8, "rdx", &builtin_type_int64},
  /*  4 */ {8, "rsi", &builtin_type_int64},
  /*  5 */ {8, "rdi", &builtin_type_int64},
  /*  6 */ {8, "rbp", &builtin_type_void_func_ptr},
  /*  7 */ {8, "rsp", &builtin_type_void_func_ptr},
  /*  8 */ {8, "r8", &builtin_type_int64},
  /*  9 */ {8, "r9", &builtin_type_int64},
  /* 10 */ {8, "r10", &builtin_type_int64},
  /* 11 */ {8, "r11", &builtin_type_int64},
  /* 12 */ {8, "r12", &builtin_type_int64},
  /* 13 */ {8, "r13", &builtin_type_int64},
  /* 14 */ {8, "r14", &builtin_type_int64},
  /* 15 */ {8, "r15", &builtin_type_int64},
  /* 16 */ {8, "rip", &builtin_type_void_func_ptr},
  /* 17 */ {4, "eflags", &builtin_type_int32},
  /* 18 */ {4, "ds", &builtin_type_int32},
  /* 19 */ {4, "es", &builtin_type_int32},
  /* 20 */ {4, "fs", &builtin_type_int32},
  /* 21 */ {4, "gs", &builtin_type_int32},
  /* 22 */ {10, "st0", &builtin_type_i387_ext},
  /* 23 */ {10, "st1", &builtin_type_i387_ext},
  /* 24 */ {10, "st2", &builtin_type_i387_ext},
  /* 25 */ {10, "st3", &builtin_type_i387_ext},
  /* 26 */ {10, "st4", &builtin_type_i387_ext},
  /* 27 */ {10, "st5", &builtin_type_i387_ext},
  /* 28 */ {10, "st6", &builtin_type_i387_ext},
  /* 29 */ {10, "st7", &builtin_type_i387_ext},
  /* 30 */ {4, "fctrl", &builtin_type_int32},
  /* 31 */ {4, "fstat", &builtin_type_int32},
  /* 32 */ {4, "ftag", &builtin_type_int32},
  /* 33 */ {4, "fiseg", &builtin_type_int32},
  /* 34 */ {4, "fioff", &builtin_type_int32},
  /* 35 */ {4, "foseg", &builtin_type_int32},
  /* 36 */ {4, "fooff", &builtin_type_int32},
  /* 37 */ {4, "fop", &builtin_type_int32},
  /* 38 */ {16, "xmm0", &builtin_type_v4sf},
  /* 39 */ {16, "xmm1", &builtin_type_v4sf},
  /* 40 */ {16, "xmm2", &builtin_type_v4sf},
  /* 41 */ {16, "xmm3", &builtin_type_v4sf},
  /* 42 */ {16, "xmm4", &builtin_type_v4sf},
  /* 43 */ {16, "xmm5", &builtin_type_v4sf},
  /* 44 */ {16, "xmm6", &builtin_type_v4sf},
  /* 45 */ {16, "xmm7", &builtin_type_v4sf},
  /* 46 */ {16, "xmm8", &builtin_type_v4sf},
  /* 47 */ {16, "xmm9", &builtin_type_v4sf},
  /* 48 */ {16, "xmm10", &builtin_type_v4sf},
  /* 49 */ {16, "xmm11", &builtin_type_v4sf},
  /* 50 */ {16, "xmm12", &builtin_type_v4sf},
  /* 51 */ {16, "xmm13", &builtin_type_v4sf},
  /* 52 */ {16, "xmm14", &builtin_type_v4sf},
  /* 53 */ {16, "xmm15", &builtin_type_v4sf},
  /* 54 */ {4, "mxcsr", &builtin_type_int32}
a108 27
/* This array is a mapping from Dwarf-2 register 
   numbering to GDB's one. Dwarf-2 numbering is 
   defined in x86-64 ABI, section 3.6.  */
static int x86_64_dwarf2gdb_regno_map[] = {
  0, 1, 2, 3,			/* RAX - RDX */
  4, 5, 6, 7,			/* RSI, RDI, RBP, RSP */
  8, 9, 10, 11,			/* R8 - R11 */
  12, 13, 14, 15,		/* R12 - R15 */
  -1,				/* RA - not mapped */
  XMM1_REGNUM - 1, XMM1_REGNUM,	/* XMM0 ... */
  XMM1_REGNUM + 1, XMM1_REGNUM + 2,
  XMM1_REGNUM + 3, XMM1_REGNUM + 4,
  XMM1_REGNUM + 5, XMM1_REGNUM + 6,
  XMM1_REGNUM + 7, XMM1_REGNUM + 8,
  XMM1_REGNUM + 9, XMM1_REGNUM + 10,
  XMM1_REGNUM + 11, XMM1_REGNUM + 12,
  XMM1_REGNUM + 13, XMM1_REGNUM + 14,	/* ... XMM15 */
  ST0_REGNUM + 0, ST0_REGNUM + 1,	/* ST0 ... */
  ST0_REGNUM + 2, ST0_REGNUM + 3,
  ST0_REGNUM + 4, ST0_REGNUM + 5,
  ST0_REGNUM + 6, ST0_REGNUM + 7	/* ... ST7 */
};

static int x86_64_dwarf2gdb_regno_map_length =
  sizeof (x86_64_dwarf2gdb_regno_map) /
  sizeof (x86_64_dwarf2gdb_regno_map[0]);

d170 1
a170 1

a200 13
/* Dwarf-2 <-> GDB register numbers mapping.  */
int
x86_64_dwarf2_reg_to_regnum (int dw_reg)
{
  if (dw_reg < 0 || dw_reg > x86_64_dwarf2gdb_regno_map_length)
    {
      warning ("Dwarf-2 uses unmapped register #%d\n", dw_reg);
      return dw_reg;
    }

  return x86_64_dwarf2gdb_regno_map[dw_reg];
}

d334 1
a334 1
	      for (j = 0; j < TYPE_NFIELDS (type); ++j)
d336 1
a336 1
		  int num = classify_argument (TYPE_FIELDS (type)[j].type,
d338 2
a339 2
					       (TYPE_FIELDS (type)[j].loc.
						bitpos + bit_offset) % 256);
d345 1
a345 2
			(TYPE_FIELDS (type)[j].loc.bitpos +
			 bit_offset) / 8 / 8;
d356 1
a356 1
	      num = classify_argument (TYPE_TARGET_TYPE (type),
d375 1
a375 1
		for (j = 0; j < TYPE_NFIELDS (type); ++j)
d378 1
a378 1
		    num = classify_argument (TYPE_FIELDS (type)[j].type,
a387 2
	  default:
	    break;
a449 2
    default:			/* Avoid warning.  */
      break;
d612 1
a612 1
    8 /* R8  */ , 9		/* R9  */
d755 1
a755 1
char *
a761 11

int
x86_64_register_number (const char *name)
{
  int reg_nr;

  for (reg_nr = 0; reg_nr < X86_64_NUM_REGS; reg_nr++)
    if (strcmp (name, x86_64_register_info_table[reg_nr].name) == 0)
      return reg_nr;
  return -1;
}
d803 1
a803 1
  int i;
d806 1
a806 1
  CORE_ADDR endaddr;
d820 1
a820 1
      return pc;		/* ... no, it doesn't. Nothing to skip.  */
d834 3
d840 2
a841 1
    if (v_sal.symtab->linetable->item[i].pc >= pc
d845 1
d862 1
a862 1
x86_64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
d888 1
a888 1
			      "x86_64_gdbarch_init: unknown machine type");
d905 1
a905 1
			      "x86_64_gdbarch_init: unknown machine type");
d910 1
a910 1
			  "x86_64_gdbarch_init: unknown machine type");
d930 1
a930 1
		      "x86_64_gdbarch_init: unknown machine type");
d970 1
d1059 1
a1059 3
  set_gdbarch_breakpoint_from_pc (gdbarch,
				  (gdbarch_breakpoint_from_pc_ftype *)
				  x86_64_breakpoint_from_pc);
a1067 2
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, x86_64_dwarf2_reg_to_regnum);

d1074 1
a1074 1
  register_gdbarch_init (bfd_arch_i386, x86_64_gdbarch_init);
@


1.9.2.7
log
@* Makefile.in (x86-64-tdep.o): Add $(objfiles_h).
* x86-64-tdep.c: Include "objfiles.h".
(x86_64_gdbarch_init): Set in_solib_call_trampoline to
in_plt_section.  From 2002-07-18 Michal Ludvig <mludvig@@suse.cz>.
@
text
@a30 1
#include "objfiles.h"
a1113 1
  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
@


1.8
log
@* x86-64-tdep.c (value.h): Delete.
(gdb_assert.h): Include.
(x86_64_register_convert_to_virtual,
x86_64_register_convert_to_raw ): Add check which lets only
floating-point values to be converted.
(value_push): Delete.
(x86_64_push_arguments): Order of arguments pushed on stack fixed.
(i386_gdbarch_init): Number of register_bytes fixed.
@
text
@d2 3
a4 2
   Copyright 2001
   Free Software Foundation, Inc.
d133 2
a134 1
  convert_typed_floating (to, type, buf, x86_64_register_virtual_type (regnum));
d145 1
a145 2
  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FLT
	      && TYPE_LENGTH (type) == 12);
d400 2
a401 1
  internal_error (__FILE__, __LINE__, "classify_argument: unknown argument type");
d433 2
a434 1
	internal_error (__FILE__, __LINE__, "examine_argument: unexpected memory class");
d558 5
a562 3
  static int int_parameter_registers[INT_REGS] = {5 /*RDI*/, 4 /*RSI*/,
						  1 /*RDX*/, 2 /*RCX*/,
						  8 /*R8 */, 9 /*R9 */};
d564 7
a570 5
  static int sse_parameter_registers[SSE_REGS] = {34, 35, 36, 37,
						  38, 39, 40, 41,
						  42, 43, 44, 45,
						  46, 47, 48, 49};
  int stack_values_count=0;
d584 2
a585 2
	{				/* memory class */
	  stack_values[stack_values_count++]=i;
d598 2
a599 1
		  write_register_gen (int_parameter_registers[(intreg + 1) / 2],
d613 2
a614 1
		  write_register_gen (sse_parameter_registers[(ssereg + 1) / 2],
d627 1
a627 1
		  stack_values[stack_values_count++]=i;
@


1.7
log
@Eliminate IEEE_FLOAT.
@
text
@d32 1
a32 1
#include "value.h"
d87 1
a87 1
    return lookup_pointer_type (builtin_type_void);
d89 1
a89 1
    return builtin_type_long_double;
d94 2
a95 2
    return builtin_type_int;
  return builtin_type_long;
d117 16
a132 3
/* Copy straight over, but take care of the padding.  */
  memcpy (to, from, FPU_REG_RAW_SIZE);
  memset (to + FPU_REG_RAW_SIZE, 0, TYPE_LENGTH (type) - FPU_REG_RAW_SIZE);
d143 3
a147 1

a547 20
/* Push onto the stack the specified value VALUE.  Pad it correctly for
   it to be an argument to a function.  */

static CORE_ADDR
value_push (register CORE_ADDR sp, struct value *arg)
{
  register int len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (arg));
  register int container_len = len;

  /* How big is the container we're going to put this value in?  */
  if (PARM_BOUNDARY)
    container_len = ((len + PARM_BOUNDARY / TARGET_CHAR_BIT - 1)
		     & ~(PARM_BOUNDARY / TARGET_CHAR_BIT - 1));

  sp -= container_len;
  write_memory (sp, VALUE_CONTENTS_ALL (arg), len);

  return sp;
}

d563 3
d575 2
a576 2
	  || intreg + needed_intregs > INT_REGS
	  || ssereg + needed_sseregs > SSE_REGS)
d578 1
a578 1
	  sp = value_push (sp, args[i]);
d617 3
a620 2
		case X86_64_MEMORY_CLASS:
		  sp = value_push (sp, args[i]);
d631 9
d855 1
a855 1
			      (18 * 8) + (8 * 10) + (8 * 4) + (8 * 16 + 4));
@


1.6
log
@* config/i386/tm-i386.h (FP7_REGNUM, FIRST_FPU_CTRL_REGNUM,
FCTRL_REGNUM, FPC_REGNUM, FSTAT_REGNUM, FTAG_REGNUM, FCS_REGNUM,
FCOFF_REGNUM, FDS_REGNUM, FDOFF_REGNUM, FOP_REGNUM,
LAST_FPU_CTRL_REGNUM, XMM0_REGNUM, XMM7_REGNUM, MXCSR_REGNUM,
IS_FP_REGNUM, IS_SSE_REGNUM): Removed.
(FP0_REGNUM): Define conditionally depending on HAVE_I387_REGS.
(SIZEOF_FPU_CTRL_REGS): Hardcode value.
* i386-tdep.h (struct gdbarch_tdep): Change such that it contains
a single member `num_xmm_regs'.
(FPC_REGNUM): New macro.
(FIRST_FPU_REGNUM, LAST_FPU_REGNUM, FISRT_XMM_REGNUM,
LAST_XMM_REGNUM, MXCSR_REGNUM, FIRST_FPU_CTRL_REGNUM,
LAST_FPU_CTRL_REGNUM): Removed.
(FCTRL_REGNUM, FSTAT_REGNUM, FTAG_REGNUM, FOP_REGNUM, XMM0_REGNUM,
MXCSR_REGNUM): Define unconditionally.  Change macros to match the
comment describing the register layout.
(FISEG_REGNUM, FIOFF_REGNUM, FOSEG_REGNUM, FOOFF_REGNUM): New macros.
(FP_REGNUM_P, FPC_REGNUM_P, SSE_REGNUM_P): New macros.
(IS_FP_REGNUM, IS_FPU_CTRL_REGNUM, IS_SSE_REGNUM): Make obsolete,
unconditionally define in terms of FP_REGNUM_P, FPC_REGNUM_P and
SSE_REGNUM_P).
(FCS_REGNUM, FCOFF_REGNUM, FDS_REGNUM, FDOFF_REGNUM): Make
obsolete, unconditionally define in terms of FISEG_REGNUM,
FIOFF_REGNUM, FOSEG_REGNUM, FOOFF_REGNUM.
* i386-tdep.c (i386_gdbarch_init): Initialize `num_xmm_regs'
member of `struct gdbarch_tdep'.
* x86-64-tdep.c (i386_gdbarch_init): Change initialization of
`struct gdbarch_tdep'.
* i387-nat.c (FCS_REGNUM, FCOFF_REGNUM, FDS_REGNUM, FDOFF_REGNUM):
Replace with FISEG_REGNUM, FIOFF_REGNUM, FOSEG_REGNUM and
FOOFF_REGNUM.  Use FPC_REGNUM instead of FIRST_FPU_CTRL_REGNUM.
Use XMM0_REGNUM instead of LAST_FPU_CTRL_REGNUM.
@
text
@a836 2
  set_gdbarch_ieee_float (gdbarch, 1);

@


1.5
log
@2001-12-11  Michael Snyder  <msnyder@@redhat.com>

	* d10v-tdep.c (d10v_register_virtual_size): Delete.
	(d10v_gdbarch_init): Use generic_register_virtual_size.
	* rs6000-tdep.c (rs6000_register_virtual_size): Delete.
	(rs6000_gdbarch_init): Use generic_register_virtual_size.
	* x86-64-tdep.c (x86_64_register_virtual_size): Delete.
	(i386_gdbarch_init): Use generic_register_virtual_size.
@
text
@d820 1
a820 5
      tdep->last_fpu_regnum = 25;
      tdep->first_xmm_regnum = 34;
      tdep->last_xmm_regnum = 49;
      tdep->mxcsr_regnum = 50;
      tdep->first_fpu_ctrl_regnum = 26;
@


1.4
log
@* dwarf2cfi.c: New file.
* dwarf2cfi.h: New file.
* dwarf2read.c (dwarf_frame_offset, dwarf_frame_size): New variables.
(dwarf_eh_frame_offset, dwarf_eh_frame_size): New variables.
(dwarf2_read_section): Change to non static.
(dwarf2_locate_sections): Add .debug_frame and .eh_frame section
recognition.
(FRAME_SECTION, EH_FRAME_SECTION): New define.
* elfread.c (elf_symfile_read): Add call of frame informations build.
* frame.h (frame_info): Add pointer to unwind_context.
* symfile.h (dwarf2_build_frame_info): Add declaration.
* gdbarch.sh (DWARF2_BUILD_FRAME_INFO): Add.
* gdbarch.h, gdbarch.c: Regenerate.
* Makefile.in: Add dwarf2cfi_h, dwarf2cfi.o
* x86-64-tdep.c (i386_gdbarch_init): Initialize target vector to
use debug frame info.
@
text
@a97 8
/* Number of bytes of storage in the program's representation
   for register REGNO.  */
int
x86_64_register_virtual_size (int regno)
{
  return (TYPE_LENGTH (x86_64_register_virtual_type (regno)));
}

d854 1
a854 1
  set_gdbarch_register_virtual_size (gdbarch, x86_64_register_virtual_size);
@


1.3
log
@s/value_ptr/struct value */
@
text
@d977 2
@


1.2
log
@Add explicit #include of "value.h".
@
text
@d545 1
a545 1
value_push (register CORE_ADDR sp, value_ptr arg)
d562 1
a562 1
x86_64_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
@


1.1
log
@* config/i386/x86-64linux.mh: New file.
* config/i386/x86-64linux.mt: New file.
* config/i386/nm-x86_64.h: New file.
* x86-64-linux-tdep.c: New file.
* x86-64-linux-nat.c: New file.
* x86-64-tdep.c: New file.
* x86-64-tdep.h: New file.
* config/djgpp/fnchange.lst: Add entries for x86_64-linux-tdep.c
and x86_64-linux-nat.c
* Makefile.in: Add x86_64-linux-tdep.o, x86_64-tdep.o,
x86_64-linux-tdep.o, x86_64-nat.o, update dependencies.
@
text
@d32 1
@

