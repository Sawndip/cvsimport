head	1.21;
access;
symbols
	gdb-post-protoization-2000-07-29:1.16
	gdb-pre-protoization-2000-07-29:1.15
	gdb-premipsmulti-2000-06-06-branch:1.11.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.11
	gdb-post-params-removal-2000-06-04:1.11
	gdb-pre-params-removal-2000-06-04:1.10
	gdb-post-params-removal-2000-05-28:1.10
	gdb-pre-params-removal-2000-05-28:1.9
	gdb_5_0-2000-05-19-release:1.5
	gdb_4_18_2-2000-05-18-release:1.5
	gdb_4_95_1-2000-05-11-snapshot:1.5
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.5
	repo-unification-2000-02-06:1.1.1.12
	insight-2000-02-04:1.1.1.12
	gdb-2000-02-04:1.1.1.12
	gdb-2000-02-02:1.1.1.12
	gdb-2000-02-01:1.1.1.11
	gdb-2000-01-31:1.1.1.10
	gdb-2000-01-26:1.1.1.10
	gdb-2000-01-24:1.1.1.10
	gdb-2000-01-17:1.1.1.10
	gdb-2000-01-10:1.1.1.10
	gdb-2000-01-05:1.1.1.10
	gdb-1999-12-21:1.1.1.10
	gdb-1999-12-13:1.1.1.10
	gdb-1999-12-07:1.1.1.10
	gdb-1999-12-06:1.1.1.10
	gdb-1999-11-16:1.1.1.10
	gdb-1999-11-08:1.1.1.10
	gdb-1999-11-01:1.1.1.10
	gdb-1999-10-25:1.1.1.10
	gdb-1999-10-18:1.1.1.10
	gdb-1999-10-11:1.1.1.10
	gdb-1999-10-04:1.1.1.10
	gdb-1999-09-28:1.1.1.9
	gdb-1999-09-21:1.1.1.9
	gdb-1999-09-13:1.1.1.9
	gdb-1999-09-08:1.1.1.9
	gdb-1999-08-30:1.1.1.8
	gdb-1999-08-23:1.1.1.7
	gdb-1999-08-16:1.1.1.6
	gdb-1999-08-09:1.1.1.6
	gdb-1999-08-02:1.1.1.5
	gdb-1999-07-26:1.1.1.5
	gdb-1999-07-19:1.1.1.5
	gdb-1999-07-12:1.1.1.5
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.21
date	2000.12.01.18.01.38;	author fnasser;	state dead;
branches;
next	1.20;

1.20
date	2000.11.06.22.44.34;	author fnasser;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.30.15.32.51;	author taylor;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.23.22.49.28;	author davea;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.08.00.17.39;	author kevinb;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.30.01.48.24;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.11.14.00.42;	author scottb;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.23.08.12.27;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.08.00.52.56;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.06.12.13.53;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.28.01.12.26;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.16.03.03.13;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.15.03.16.15;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.21.05.21.55;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.20.23.51.01;	author glen;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.23.23.43.19;	author fnasser;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.23.23.21.27;	author dberlin;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.20.09.19.45;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.45;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.05.19.19.51.55;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.25.18.01.18;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.04.57;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.12.11.05.53;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.09.21.33.20;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.08.23.22.34.49;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.08.31.01.04.38;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.09.08.23.59.04;	author shebs;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.10.05.23.08.03;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2000.02.02.00.21.04;	author jsm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2000.02.03.04.14.27;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.21
log
@2000-12-01  Fernando Nasser  <fnasser@@redhat.com>

        * cli/cli-decode.c: New file. Handle lists of commands, their decoding
        and documentation.
        (add_cmd, deprecate_cmd, add_abbrev_cmd, add_alias_cmd, add_prefix_cmd,
        add_abbrev_prefix_cmd, not_just_help_class_command, empty_sfunc,
        add_set_cmd, add_set_enum_cmd, add_set_auto_boolean_cmd,
        add_show_from_set, delete_cmd, apropos_cmd, help_cmd, help_list,
        help_all, print_doc_line, help_cmd_list, find_cmd, lookup_cmd_1,
        undef_cmd_error, lookup_cmd, deprecated_cmd_warning,
        lookup_cmd_composition, complete_on_cmdlist, complete_on_enum):
        Moved here from command.c.
        (add_info, add_info_alias, add_com, add_com_alias): Moved here from
        top.c.
        * cli/cli-decode.h: Definitions/declarations for the above.
        * cli/cli-cmds.c: New file.  GDB CLI commands.
        (error_no_arg, info_command, show_command, help_command, show_version,
        quit_command, pwd_command, cd_command, echo_command, shell_escape,
        make_command, show_user, set_debug, show_debug, init_cmd_lists):
        Moved here from top.c.
        (apropos_command): Moved here from command.c.
        (complete_command, source_command): Moved here (part) from top.c.
        (is_complete_command): New function. Checks if a command is the
        "complete" command.
        (init_cli_cmds): New function. Add commands to the CLI (from code
        previously in top.c.
        * cli/cli-cmds.h: Definitions/declarations for the above.
        * cli/cli-script.c: New file. GDB CLI command scripting.
        (build_command_line, get_command_line, print_command_lines,
        print_command_line, execute_user_command, execute_control_command,
        while_command, if_command, arg_cleanup, setup_user_args, locate_arg,
        insert_args, realloc_body_list, read_next_line,
        recurse_read_control_structure, read_command_lines, free_command_lines,
        do_free_command_lines_cleanup, make_cleanup_free_command_lines,
        validate_comname, user_defined_command, define_command,
        document_command, source_cleanup_lines, do_fclose_cleanup,
        show_user_1): Moved here from top.c.
        (script_from_file): New function. Implements execution of a script
        contained in a file (part of code for the source_command() that used
        to exist in top.c).
        * cli/cli-script.h: Definitions/declarations for the above.
        * cli/cli-setshow.c: New file. Handle set and show GDB CLI commands.
        (parse_auto_binary_operation, parse_binary_operation,
        do_setshow_command, cmd_show_list): Moved here from command.c.
        * cli/cli-setshow.h: Definitions/declarations for the above.
        * top.c: Remove all CLI code, except the command loop.
        (gdb_init): Call init_cli_cmds().
        * command.c: Remove obsolete file.
        * command.h: Mark as DEPRECATED.
        * gdbcmd.h: Ditto.
        * call-cmds.h: Ditto.
        * Makefile.in (SFILES): Remove command.c.
        (COMMON_OBS): Remove command.o.
        (command.o): Remove obsolete target.
        (cli_decode_h, cli_cmds_h, cli_script_h, cli_setshow_h): New macros.
        Refer to CLI header files.
        (cli-decode.o, cli-cmds.o, cli-setshow.o, cli-script.o): New targets.
        (SUBDIR_CLI_OBS, SUBDIR_CLI_SRCS, SUBDIR_CLI_DEPS, SUBDIR_CLI_INITS,
        SUBDIR_CLI_LDFLAGS, SUBDIR_CLI_CFLAGS, SUBDIR_CLI_ALL, SUBDIR_CLI_CLEAN,
        SUBDIR_CLI_INSTALL, SUBDIR_CLI_UNINSTALL): New macros for new cli
        subdirectory.
        * configure.in (enable_gdbcli): New option. Include the CLI in the
        executable (cannot be disabled yet).
        (CONFIG_OBS, CONFIG_DEPS, CONFIG_SRCS, CONFIG_INITS, ENABLE_CFLAGS,
        CONFIG_ALL, CONFIG_CLEAN, CONFIG_INSTALL, CONFIG_UNINSTALL): Add
        the corresponding SUBDIR_CLI_* macros if CLI requested.
        * configure: Regenerate.
@
text
@/* Handle lists of commands, their decoding and documentation, for GDB.
   Copyright 1986, 1989, 1990, 1991, 1998, 2000 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "gdbcmd.h"
#include "symtab.h"
#include "value.h"
#include <ctype.h>
#include "gdb_string.h"
#ifdef UI_OUT
#include "ui-out.h"
#endif

#include "gdb_wait.h"
#include "gnu-regex.h"
/* FIXME: this should be auto-configured!  */
#ifdef __MSDOS__
# define CANT_FORK
#endif

/* Prototypes for local functions */

static void undef_cmd_error (char *, char *);

static void show_user (char *, int);

static void show_user_1 (struct cmd_list_element *, struct ui_file *);

static void make_command (char *, int);

static void shell_escape (char *, int);

static int parse_binary_operation (char *);

static void print_doc_line (struct ui_file *, char *);

static struct cmd_list_element *find_cmd (char *command,
					  int len,
					  struct cmd_list_element *clist,
					  int ignore_help_classes,
					  int *nfound);
static void apropos_cmd_helper (struct ui_file *, struct cmd_list_element *, 
		    		struct re_pattern_buffer *, char *);

static void help_all (struct ui_file *stream);

void apropos_command (char *, int);

void _initialize_command (void);

/* Add element named NAME.
   CLASS is the top level category into which commands are broken down
   for "help" purposes.
   FUN should be the function to execute the command;
   it will get a character string as argument, with leading
   and trailing blanks already eliminated.

   DOC is a documentation string for the command.
   Its first line should be a complete sentence.
   It should start with ? for a command that is an abbreviation
   or with * for a command that most users don't need to know about.

   Add this command to command list *LIST.  

   Returns a pointer to the added command (not necessarily the head 
   of *LIST). */

struct cmd_list_element *
add_cmd (char *name, enum command_class class, void (*fun) (char *, int),
	 char *doc, struct cmd_list_element **list)
{
  register struct cmd_list_element *c
  = (struct cmd_list_element *) xmalloc (sizeof (struct cmd_list_element));
  struct cmd_list_element *p;

  delete_cmd (name, list);

  if (*list == NULL || STRCMP ((*list)->name, name) >= 0)
    {
      c->next = *list;
      *list = c;
    }
  else
    {
      p = *list;
      while (p->next && STRCMP (p->next->name, name) <= 0)
	{
	  p = p->next;
	}
      c->next = p->next;
      p->next = c;
    }

  c->name = name;
  c->class = class;
  c->function.cfunc = fun;
  c->doc = doc;
  c->flags = 0;
  c->replacement = NULL;
  c->hook_pre  = NULL;
  c->hook_post = NULL;
  c->hook_in = 0;
  c->prefixlist = NULL;
  c->prefixname = NULL;
  c->allow_unknown = 0;
  c->abbrev_flag = 0;
  c->completer = make_symbol_completion_list;
  c->type = not_set_cmd;
  c->var = NULL;
  c->var_type = var_boolean;
  c->enums = NULL;
  c->user_commands = NULL;
  c->hookee_pre = NULL;
  c->hookee_post = NULL;
  c->cmd_pointer = NULL;

  return c;
}


/* Deprecates a command CMD.
   REPLACEMENT is the name of the command which should be used in place
   of this command, or NULL if no such command exists.

   This function does not check to see if command REPLACEMENT exists
   since gdb may not have gotten around to adding REPLACEMENT when this
   function is called.

   Returns a pointer to the deprecated command.  */

struct cmd_list_element *
deprecate_cmd (struct cmd_list_element *cmd, char *replacement)
{
  cmd->flags |= (CMD_DEPRECATED | DEPRECATED_WARN_USER);

  if (replacement != NULL)
    cmd->replacement = replacement;
  else
    cmd->replacement = NULL;

  return cmd;
}


/* Same as above, except that the abbrev_flag is set. */

#if 0				/* Currently unused */

struct cmd_list_element *
add_abbrev_cmd (char *name, enum command_class class, void (*fun) (char *, int),
		char *doc, struct cmd_list_element **list)
{
  register struct cmd_list_element *c
  = add_cmd (name, class, fun, doc, list);

  c->abbrev_flag = 1;
  return c;
}

#endif

struct cmd_list_element *
add_alias_cmd (char *name, char *oldname, enum command_class class,
	       int abbrev_flag, struct cmd_list_element **list)
{
  /* Must do this since lookup_cmd tries to side-effect its first arg */
  char *copied_name;
  register struct cmd_list_element *old;
  register struct cmd_list_element *c;
  copied_name = (char *) alloca (strlen (oldname) + 1);
  strcpy (copied_name, oldname);
  old = lookup_cmd (&copied_name, *list, "", 1, 1);

  if (old == 0)
    {
      delete_cmd (name, list);
      return 0;
    }

  c = add_cmd (name, class, old->function.cfunc, old->doc, list);
  c->prefixlist = old->prefixlist;
  c->prefixname = old->prefixname;
  c->allow_unknown = old->allow_unknown;
  c->abbrev_flag = abbrev_flag;
  c->cmd_pointer = old;
  return c;
}

/* Like add_cmd but adds an element for a command prefix:
   a name that should be followed by a subcommand to be looked up
   in another command list.  PREFIXLIST should be the address
   of the variable containing that list.  */

struct cmd_list_element *
add_prefix_cmd (char *name, enum command_class class, void (*fun) (char *, int),
		char *doc, struct cmd_list_element **prefixlist,
		char *prefixname, int allow_unknown,
		struct cmd_list_element **list)
{
  register struct cmd_list_element *c = add_cmd (name, class, fun, doc, list);
  c->prefixlist = prefixlist;
  c->prefixname = prefixname;
  c->allow_unknown = allow_unknown;
  return c;
}

/* Like add_prefix_cmd but sets the abbrev_flag on the new command. */

struct cmd_list_element *
add_abbrev_prefix_cmd (char *name, enum command_class class,
		       void (*fun) (char *, int), char *doc,
		       struct cmd_list_element **prefixlist, char *prefixname,
		       int allow_unknown, struct cmd_list_element **list)
{
  register struct cmd_list_element *c = add_cmd (name, class, fun, doc, list);
  c->prefixlist = prefixlist;
  c->prefixname = prefixname;
  c->allow_unknown = allow_unknown;
  c->abbrev_flag = 1;
  return c;
}

/* This is an empty "cfunc".  */
void
not_just_help_class_command (char *args, int from_tty)
{
}

/* This is an empty "sfunc".  */
static void empty_sfunc (char *, int, struct cmd_list_element *);

static void
empty_sfunc (char *args, int from_tty, struct cmd_list_element *c)
{
}

/* Add element named NAME to command list LIST (the list for set
   or some sublist thereof).
   CLASS is as in add_cmd.
   VAR_TYPE is the kind of thing we are setting.
   VAR is address of the variable being controlled by this command.
   DOC is the documentation string.  */

struct cmd_list_element *
add_set_cmd (char *name,
	     enum command_class class,
	     var_types var_type,
	     void *var,
	     char *doc,
	     struct cmd_list_element **list)
{
  struct cmd_list_element *c
  = add_cmd (name, class, NO_FUNCTION, doc, list);

  c->type = set_cmd;
  c->var_type = var_type;
  c->var = var;
  /* This needs to be something besides NO_FUNCTION so that this isn't
     treated as a help class.  */
  c->function.sfunc = empty_sfunc;
  return c;
}

/* Add element named NAME to command list LIST (the list for set
   or some sublist thereof).
   CLASS is as in add_cmd.
   ENUMLIST is a list of strings which may follow NAME.
   VAR is address of the variable which will contain the matching string
   (from ENUMLIST).
   DOC is the documentation string.  */

struct cmd_list_element *
add_set_enum_cmd (char *name,
		  enum command_class class,
		  const char *enumlist[],
		  const char **var,
		  char *doc,
		  struct cmd_list_element **list)
{
  struct cmd_list_element *c
  = add_set_cmd (name, class, var_enum, var, doc, list);
  c->enums = enumlist;

  return c;
}

/* Add element named NAME to command list LIST (the list for set
   or some sublist thereof).
   CLASS is as in add_cmd.
   VAR is address of the variable which will contain the value.
   DOC is the documentation string.  */
struct cmd_list_element *
add_set_auto_boolean_cmd (char *name,
			  enum command_class class,
			  enum cmd_auto_boolean *var,
			  char *doc,
			  struct cmd_list_element **list)
{
  static const char *auto_boolean_enums[] = { "on", "off", "auto", NULL };
  struct cmd_list_element *c;
  c = add_set_cmd (name, class, var_auto_boolean, var, doc, list);
  c->enums = auto_boolean_enums;
  return c;
}

/* Where SETCMD has already been added, add the corresponding show
   command to LIST and return a pointer to the added command (not 
   necessarily the head of LIST).  */
struct cmd_list_element *
add_show_from_set (struct cmd_list_element *setcmd,
		   struct cmd_list_element **list)
{
  struct cmd_list_element *showcmd =
  (struct cmd_list_element *) xmalloc (sizeof (struct cmd_list_element));
  struct cmd_list_element *p;

  memcpy (showcmd, setcmd, sizeof (struct cmd_list_element));
  delete_cmd (showcmd->name, list);
  showcmd->type = show_cmd;

  /* Replace "set " at start of docstring with "show ".  */
  if (setcmd->doc[0] == 'S' && setcmd->doc[1] == 'e'
      && setcmd->doc[2] == 't' && setcmd->doc[3] == ' ')
    showcmd->doc = concat ("Show ", setcmd->doc + 4, NULL);
  else
    fprintf_unfiltered (gdb_stderr, "GDB internal error: Bad docstring for set command\n");

  if (*list == NULL || STRCMP ((*list)->name, showcmd->name) >= 0)
    {
      showcmd->next = *list;
      *list = showcmd;
    }
  else
    {
      p = *list;
      while (p->next && STRCMP (p->next->name, showcmd->name) <= 0)
	{
	  p = p->next;
	}
      showcmd->next = p->next;
      p->next = showcmd;
    }

  return showcmd;
}

/* Remove the command named NAME from the command list.  */

void
delete_cmd (char *name, struct cmd_list_element **list)
{
  register struct cmd_list_element *c;
  struct cmd_list_element *p;

  while (*list && STREQ ((*list)->name, name))
    {
      if ((*list)->hookee_pre)
      (*list)->hookee_pre->hook_pre = 0;   /* Hook slips out of its mouth */
      if ((*list)->hookee_post)
      (*list)->hookee_post->hook_post = 0; /* Hook slips out of its bottom  */
      p = (*list)->next;
      free ((PTR) * list);
      *list = p;
    }

  if (*list)
    for (c = *list; c->next;)
      {
	if (STREQ (c->next->name, name))
	  {
          if (c->next->hookee_pre)
            c->next->hookee_pre->hook_pre = 0; /* hooked cmd gets away.  */
          if (c->next->hookee_post)
            c->next->hookee_post->hook_post = 0; /* remove post hook */
                                               /* :( no fishing metaphore */
	    p = c->next->next;
	    free ((PTR) c->next);
	    c->next = p;
	  }
	else
	  c = c->next;
      }
}
/* Recursively walk the commandlist structures, and print out the
   documentation of commands that match our regex in either their
   name, or their documentation.
*/
static void 
apropos_cmd_helper (struct ui_file *stream, struct cmd_list_element *commandlist,
			 struct re_pattern_buffer *regex, char *prefix)
{
  register struct cmd_list_element *c;
  int returnvalue=1; /*Needed to avoid double printing*/
  /* Walk through the commands */
  for (c=commandlist;c;c=c->next)
    {
      if (c->name != NULL)
	{
	  /* Try to match against the name*/
	  returnvalue=re_search(regex,c->name,strlen(c->name),0,strlen(c->name),NULL);
	  if (returnvalue >= 0)
	    {
	      /* Stolen from help_cmd_list. We don't directly use
	       * help_cmd_list because it doesn't let us print out
	       * single commands
	       */
	      fprintf_filtered (stream, "%s%s -- ", prefix, c->name);
	      print_doc_line (stream, c->doc);
	      fputs_filtered ("\n", stream);
	      returnvalue=0; /*Set this so we don't print it again.*/
	    }
	}
      if (c->doc != NULL && returnvalue != 0)
	{
	  /* Try to match against documentation */
	  if (re_search(regex,c->doc,strlen(c->doc),0,strlen(c->doc),NULL) >=0)
	    {
	      /* Stolen from help_cmd_list. We don't directly use
	       * help_cmd_list because it doesn't let us print out
	       * single commands
	       */
	      fprintf_filtered (stream, "%s%s -- ", prefix, c->name);
	      print_doc_line (stream, c->doc);
	      fputs_filtered ("\n", stream);
	    }
	}
      /* Check if this command has subcommands */
      if (c->prefixlist != NULL)
	{
	  /* Recursively call ourselves on the subcommand list,
	     passing the right prefix in.
	  */
	  apropos_cmd_helper(stream,*c->prefixlist,regex,c->prefixname);
	}
    }
}
/* Search through names of commands and documentations for a certain
   regular expression.
*/
void 
apropos_command (char *searchstr, int from_tty)
{
  extern struct cmd_list_element *cmdlist; /*This is the main command list*/
  regex_t pattern;
  char *pattern_fastmap;
  char errorbuffer[512];
  pattern_fastmap=calloc(256,sizeof(char));
  if (searchstr == NULL)
      error("REGEXP string is empty");

  if (regcomp(&pattern,searchstr,REG_ICASE) == 0)
    {
      pattern.fastmap=pattern_fastmap;
      re_compile_fastmap(&pattern);
      apropos_cmd_helper(gdb_stdout,cmdlist,&pattern,"");
    }
  else
    {
      regerror(regcomp(&pattern,searchstr,REG_ICASE),NULL,errorbuffer,512);
      error("Error in regular expression:%s",errorbuffer);
    }
  free(pattern_fastmap);
}


/* This command really has to deal with two things:
 *     1) I want documentation on *this string* (usually called by
 * "help commandname").
 *     2) I want documentation on *this list* (usually called by
 * giving a command that requires subcommands.  Also called by saying
 * just "help".)
 *
 *   I am going to split this into two seperate comamnds, help_cmd and
 * help_list. 
 */

void
help_cmd (char *command, struct ui_file *stream)
{
  struct cmd_list_element *c;
  extern struct cmd_list_element *cmdlist;

  if (!command)
    {
      help_list (cmdlist, "", all_classes, stream);
      return;
    }

  if (strcmp (command, "all") == 0)
    {
      help_all (stream);
      return;
    }

  c = lookup_cmd (&command, cmdlist, "", 0, 0);

  if (c == 0)
    return;

  /* There are three cases here.
     If c->prefixlist is nonzero, we have a prefix command.
     Print its documentation, then list its subcommands.

     If c->function is nonzero, we really have a command.
     Print its documentation and return.

     If c->function is zero, we have a class name.
     Print its documentation (as if it were a command)
     and then set class to the number of this class
     so that the commands in the class will be listed.  */

  fputs_filtered (c->doc, stream);
  fputs_filtered ("\n", stream);

  if (c->prefixlist == 0 && c->function.cfunc != NULL)
    return;
  fprintf_filtered (stream, "\n");

  /* If this is a prefix command, print it's subcommands */
  if (c->prefixlist)
    help_list (*c->prefixlist, c->prefixname, all_commands, stream);

  /* If this is a class name, print all of the commands in the class */
  if (c->function.cfunc == NULL)
    help_list (cmdlist, "", c->class, stream);

  if (c->hook_pre || c->hook_post)
    fprintf_filtered (stream,
                      "\nThis command has a hook (or hooks) defined:\n");

  if (c->hook_pre)
    fprintf_filtered (stream, 
                      "\tThis command is run after  : %s (pre hook)\n",
                    c->hook_pre->name);
  if (c->hook_post)
    fprintf_filtered (stream, 
                      "\tThis command is run before : %s (post hook)\n",
                    c->hook_post->name);
}

/*
 * Get a specific kind of help on a command list.
 *
 * LIST is the list.
 * CMDTYPE is the prefix to use in the title string.
 * CLASS is the class with which to list the nodes of this list (see
 * documentation for help_cmd_list below),  As usual, ALL_COMMANDS for
 * everything, ALL_CLASSES for just classes, and non-negative for only things
 * in a specific class.
 * and STREAM is the output stream on which to print things.
 * If you call this routine with a class >= 0, it recurses.
 */
void
help_list (struct cmd_list_element *list, char *cmdtype,
	   enum command_class class, struct ui_file *stream)
{
  int len;
  char *cmdtype1, *cmdtype2;

  /* If CMDTYPE is "foo ", CMDTYPE1 gets " foo" and CMDTYPE2 gets "foo sub"  */
  len = strlen (cmdtype);
  cmdtype1 = (char *) alloca (len + 1);
  cmdtype1[0] = 0;
  cmdtype2 = (char *) alloca (len + 4);
  cmdtype2[0] = 0;
  if (len)
    {
      cmdtype1[0] = ' ';
      strncpy (cmdtype1 + 1, cmdtype, len - 1);
      cmdtype1[len] = 0;
      strncpy (cmdtype2, cmdtype, len - 1);
      strcpy (cmdtype2 + len - 1, " sub");
    }

  if (class == all_classes)
    fprintf_filtered (stream, "List of classes of %scommands:\n\n", cmdtype2);
  else
    fprintf_filtered (stream, "List of %scommands:\n\n", cmdtype2);

  help_cmd_list (list, class, cmdtype, (int) class >= 0, stream);

  if (class == all_classes)
    fprintf_filtered (stream, "\n\
Type \"help%s\" followed by a class name for a list of commands in that class.",
		      cmdtype1);

  fprintf_filtered (stream, "\n\
Type \"help%s\" followed by %scommand name for full documentation.\n\
Command name abbreviations are allowed if unambiguous.\n",
		    cmdtype1, cmdtype2);
}

static void
help_all (struct ui_file *stream)
{
  struct cmd_list_element *c;
  extern struct cmd_list_element *cmdlist;

  for (c = cmdlist; c; c = c->next)
    {
      if (c->abbrev_flag)
        continue;
      /* If this is a prefix command, print it's subcommands */
      if (c->prefixlist)
        help_cmd_list (*c->prefixlist, all_commands, c->prefixname, 0, stream);
    
      /* If this is a class name, print all of the commands in the class */
      else if (c->function.cfunc == NULL)
        help_cmd_list (cmdlist, c->class, "", 0, stream);
    }
}

/* Print only the first line of STR on STREAM.  */
static void
print_doc_line (struct ui_file *stream, char *str)
{
  static char *line_buffer = 0;
  static int line_size;
  register char *p;

  if (!line_buffer)
    {
      line_size = 80;
      line_buffer = (char *) xmalloc (line_size);
    }

  p = str;
  while (*p && *p != '\n' && *p != '.' && *p != ',')
    p++;
  if (p - str > line_size - 1)
    {
      line_size = p - str + 1;
      free ((PTR) line_buffer);
      line_buffer = (char *) xmalloc (line_size);
    }
  strncpy (line_buffer, str, p - str);
  line_buffer[p - str] = '\0';
  if (islower (line_buffer[0]))
    line_buffer[0] = toupper (line_buffer[0]);
#ifdef UI_OUT
  ui_out_text (uiout, line_buffer);
#else
  fputs_filtered (line_buffer, stream);
#endif
}

/*
 * Implement a help command on command list LIST.
 * RECURSE should be non-zero if this should be done recursively on
 * all sublists of LIST.
 * PREFIX is the prefix to print before each command name.
 * STREAM is the stream upon which the output should be written.
 * CLASS should be:
 *      A non-negative class number to list only commands in that
 * class.
 *      ALL_COMMANDS to list all commands in list.
 *      ALL_CLASSES  to list all classes in list.
 *
 *   Note that RECURSE will be active on *all* sublists, not just the
 * ones selected by the criteria above (ie. the selection mechanism
 * is at the low level, not the high-level).
 */
void
help_cmd_list (struct cmd_list_element *list, enum command_class class,
	       char *prefix, int recurse, struct ui_file *stream)
{
  register struct cmd_list_element *c;

  for (c = list; c; c = c->next)
    {
      if (c->abbrev_flag == 0 &&
	  (class == all_commands
	   || (class == all_classes && c->function.cfunc == NULL)
	   || (class == c->class && c->function.cfunc != NULL)))
	{
	  fprintf_filtered (stream, "%s%s -- ", prefix, c->name);
	  print_doc_line (stream, c->doc);
	  fputs_filtered ("\n", stream);
	}
      if (recurse
	  && c->prefixlist != 0
	  && c->abbrev_flag == 0)
	help_cmd_list (*c->prefixlist, class, c->prefixname, 1, stream);
    }
}


/* Search the input clist for 'command'.  Return the command if
   found (or NULL if not), and return the number of commands
   found in nfound */

static struct cmd_list_element *
find_cmd (char *command, int len, struct cmd_list_element *clist,
	  int ignore_help_classes, int *nfound)
{
  struct cmd_list_element *found, *c;

  found = (struct cmd_list_element *) NULL;
  *nfound = 0;
  for (c = clist; c; c = c->next)
    if (!strncmp (command, c->name, len)
	&& (!ignore_help_classes || c->function.cfunc))
      {
	found = c;
	(*nfound)++;
	if (c->name[len] == '\0')
	  {
	    *nfound = 1;
	    break;
	  }
      }
  return found;
}

/* This routine takes a line of TEXT and a CLIST in which to start the
   lookup.  When it returns it will have incremented the text pointer past
   the section of text it matched, set *RESULT_LIST to point to the list in
   which the last word was matched, and will return a pointer to the cmd
   list element which the text matches.  It will return NULL if no match at
   all was possible.  It will return -1 (cast appropriately, ick) if ambigous
   matches are possible; in this case *RESULT_LIST will be set to point to
   the list in which there are ambiguous choices (and *TEXT will be set to
   the ambiguous text string).

   If the located command was an abbreviation, this routine returns the base
   command of the abbreviation.

   It does no error reporting whatsoever; control will always return
   to the superior routine.

   In the case of an ambiguous return (-1), *RESULT_LIST will be set to point
   at the prefix_command (ie. the best match) *or* (special case) will be NULL
   if no prefix command was ever found.  For example, in the case of "info a",
   "info" matches without ambiguity, but "a" could be "args" or "address", so
   *RESULT_LIST is set to the cmd_list_element for "info".  So in this case
   RESULT_LIST should not be interpeted as a pointer to the beginning of a
   list; it simply points to a specific command.  In the case of an ambiguous
   return *TEXT is advanced past the last non-ambiguous prefix (e.g.
   "info t" can be "info types" or "info target"; upon return *TEXT has been
   advanced past "info ").

   If RESULT_LIST is NULL, don't set *RESULT_LIST (but don't otherwise
   affect the operation).

   This routine does *not* modify the text pointed to by TEXT.

   If IGNORE_HELP_CLASSES is nonzero, ignore any command list elements which
   are actually help classes rather than commands (i.e. the function field of
   the struct cmd_list_element is NULL).  */

struct cmd_list_element *
lookup_cmd_1 (char **text, struct cmd_list_element *clist,
	      struct cmd_list_element **result_list, int ignore_help_classes)
{
  char *p, *command;
  int len, tmp, nfound;
  struct cmd_list_element *found, *c;
  char *line = *text;

  while (**text == ' ' || **text == '\t')
    (*text)++;

  /* Treating underscores as part of command words is important
     so that "set args_foo()" doesn't get interpreted as
     "set args _foo()".  */
  for (p = *text;
       *p && (isalnum (*p) || *p == '-' || *p == '_' ||
	      (tui_version &&
	       (*p == '+' || *p == '<' || *p == '>' || *p == '$')) ||
	      (xdb_commands && (*p == '!' || *p == '/' || *p == '?')));
       p++)
    ;

  /* If nothing but whitespace, return 0.  */
  if (p == *text)
    return 0;

  len = p - *text;

  /* *text and p now bracket the first command word to lookup (and
     it's length is len).  We copy this into a local temporary */


  command = (char *) alloca (len + 1);
  for (tmp = 0; tmp < len; tmp++)
    {
      char x = (*text)[tmp];
      command[tmp] = x;
    }
  command[len] = '\0';

  /* Look it up.  */
  found = 0;
  nfound = 0;
  found = find_cmd (command, len, clist, ignore_help_classes, &nfound);

  /* 
     ** We didn't find the command in the entered case, so lower case it
     ** and search again.
   */
  if (!found || nfound == 0)
    {
      for (tmp = 0; tmp < len; tmp++)
	{
	  char x = command[tmp];
	  command[tmp] = isupper (x) ? tolower (x) : x;
	}
      found = find_cmd (command, len, clist, ignore_help_classes, &nfound);
    }

  /* If nothing matches, we have a simple failure.  */
  if (nfound == 0)
    return 0;

  if (nfound > 1)
    {
      if (result_list != NULL)
	/* Will be modified in calling routine
	   if we know what the prefix command is.  */
	*result_list = 0;
      return (struct cmd_list_element *) -1;	/* Ambiguous.  */
    }

  /* We've matched something on this list.  Move text pointer forward. */

  *text = p;

  if (found->cmd_pointer)
    {
      /* We drop the alias (abbreviation) in favor of the command it is
       pointing to.  If the alias is deprecated, though, we need to
       warn the user about it before we drop it.  Note that while we
       are warning about the alias, we may also warn about the command
       itself and we will adjust the appropriate DEPRECATED_WARN_USER
       flags */
      
      if (found->flags & DEPRECATED_WARN_USER)
      deprecated_cmd_warning (&line);
      found = found->cmd_pointer;
    }
  /* If we found a prefix command, keep looking.  */

  if (found->prefixlist)
    {
      c = lookup_cmd_1 (text, *found->prefixlist, result_list,
			ignore_help_classes);
      if (!c)
	{
	  /* Didn't find anything; this is as far as we got.  */
	  if (result_list != NULL)
	    *result_list = clist;
	  return found;
	}
      else if (c == (struct cmd_list_element *) -1)
	{
	  /* We've gotten this far properly, but the next step
	     is ambiguous.  We need to set the result list to the best
	     we've found (if an inferior hasn't already set it).  */
	  if (result_list != NULL)
	    if (!*result_list)
	      /* This used to say *result_list = *found->prefixlist
	         If that was correct, need to modify the documentation
	         at the top of this function to clarify what is supposed
	         to be going on.  */
	      *result_list = found;
	  return c;
	}
      else
	{
	  /* We matched!  */
	  return c;
	}
    }
  else
    {
      if (result_list != NULL)
	*result_list = clist;
      return found;
    }
}

/* All this hair to move the space to the front of cmdtype */

static void
undef_cmd_error (char *cmdtype, char *q)
{
  error ("Undefined %scommand: \"%s\".  Try \"help%s%.*s\".",
	 cmdtype,
	 q,
	 *cmdtype ? " " : "",
	 strlen (cmdtype) - 1,
	 cmdtype);
}

/* Look up the contents of *LINE as a command in the command list LIST.
   LIST is a chain of struct cmd_list_element's.
   If it is found, return the struct cmd_list_element for that command
   and update *LINE to point after the command name, at the first argument.
   If not found, call error if ALLOW_UNKNOWN is zero
   otherwise (or if error returns) return zero.
   Call error if specified command is ambiguous,
   unless ALLOW_UNKNOWN is negative.
   CMDTYPE precedes the word "command" in the error message.

   If INGNORE_HELP_CLASSES is nonzero, ignore any command list
   elements which are actually help classes rather than commands (i.e.
   the function field of the struct cmd_list_element is 0).  */

struct cmd_list_element *
lookup_cmd (char **line, struct cmd_list_element *list, char *cmdtype,
	    int allow_unknown, int ignore_help_classes)
{
  struct cmd_list_element *last_list = 0;
  struct cmd_list_element *c =
  lookup_cmd_1 (line, list, &last_list, ignore_help_classes);
#if 0
  /* This is wrong for complete_command.  */
  char *ptr = (*line) + strlen (*line) - 1;

  /* Clear off trailing whitespace.  */
  while (ptr >= *line && (*ptr == ' ' || *ptr == '\t'))
    ptr--;
  *(ptr + 1) = '\0';
#endif

  if (!c)
    {
      if (!allow_unknown)
	{
	  if (!*line)
	    error ("Lack of needed %scommand", cmdtype);
	  else
	    {
	      char *p = *line, *q;

	      while (isalnum (*p) || *p == '-')
		p++;

	      q = (char *) alloca (p - *line + 1);
	      strncpy (q, *line, p - *line);
	      q[p - *line] = '\0';
	      undef_cmd_error (cmdtype, q);
	    }
	}
      else
	return 0;
    }
  else if (c == (struct cmd_list_element *) -1)
    {
      /* Ambigous.  Local values should be off prefixlist or called
         values.  */
      int local_allow_unknown = (last_list ? last_list->allow_unknown :
				 allow_unknown);
      char *local_cmdtype = last_list ? last_list->prefixname : cmdtype;
      struct cmd_list_element *local_list =
      (last_list ? *(last_list->prefixlist) : list);

      if (local_allow_unknown < 0)
	{
	  if (last_list)
	    return last_list;	/* Found something.  */
	  else
	    return 0;		/* Found nothing.  */
	}
      else
	{
	  /* Report as error.  */
	  int amb_len;
	  char ambbuf[100];

	  for (amb_len = 0;
	       ((*line)[amb_len] && (*line)[amb_len] != ' '
		&& (*line)[amb_len] != '\t');
	       amb_len++)
	    ;

	  ambbuf[0] = 0;
	  for (c = local_list; c; c = c->next)
	    if (!strncmp (*line, c->name, amb_len))
	      {
		if (strlen (ambbuf) + strlen (c->name) + 6 < (int) sizeof ambbuf)
		  {
		    if (strlen (ambbuf))
		      strcat (ambbuf, ", ");
		    strcat (ambbuf, c->name);
		  }
		else
		  {
		    strcat (ambbuf, "..");
		    break;
		  }
	      }
	  error ("Ambiguous %scommand \"%s\": %s.", local_cmdtype,
		 *line, ambbuf);
	  return 0;		/* lint */
	}
    }
  else
    {
      /* We've got something.  It may still not be what the caller
         wants (if this command *needs* a subcommand).  */
      while (**line == ' ' || **line == '\t')
	(*line)++;

      if (c->prefixlist && **line && !c->allow_unknown)
	undef_cmd_error (c->prefixname, *line);

      /* Seems to be what he wants.  Return it.  */
      return c;
    }
  return 0;
}

/* We are here presumably because an alias or command in *TEXT is 
   deprecated and a warning message should be generated.  This function
   decodes *TEXT and potentially generates a warning message as outlined
   below.
   
   Example for 'set endian big' which has a fictitious alias 'seb'.
   
   If alias wasn't used in *TEXT, and the command is deprecated:
   "warning: 'set endian big' is deprecated." 
   
   If alias was used, and only the alias is deprecated:
   "warning: 'seb' an alias for the command 'set endian big' is deprecated."
   
   If alias was used and command is deprecated (regardless of whether the
   alias itself is deprecated:
   
   "warning: 'set endian big' (seb) is deprecated."

   After the message has been sent, clear the appropriate flags in the
   command and/or the alias so the user is no longer bothered.
   
*/
void
deprecated_cmd_warning (char **text)
{
  struct cmd_list_element *alias = NULL;
  struct cmd_list_element *prefix_cmd = NULL;
  struct cmd_list_element *cmd = NULL;
  struct cmd_list_element *c;
  char *type;
 
  if (!lookup_cmd_composition (*text, &alias, &prefix_cmd, &cmd))
    /* return if text doesn't evaluate to a command */
    return;

  if (!((alias ? (alias->flags & DEPRECATED_WARN_USER) : 0)
      || (cmd->flags & DEPRECATED_WARN_USER) ) ) 
    /* return if nothing is deprecated */
    return;
  
  printf_filtered ("Warning:");
  
  if (alias && !(cmd->flags & CMD_DEPRECATED))
    printf_filtered (" '%s', an alias for the", alias->name);
    
  printf_filtered (" command '");
  
  if (prefix_cmd)
    printf_filtered ("%s", prefix_cmd->prefixname);
  
  printf_filtered ("%s", cmd->name);

  if (alias && (cmd->flags & CMD_DEPRECATED))
    printf_filtered ("' (%s) is deprecated.\n", alias->name);
  else
    printf_filtered ("' is deprecated.\n"); 
  

  /* if it is only the alias that is deprecated, we want to indicate the
     new alias, otherwise we'll indicate the new command */

  if (alias && !(cmd->flags & CMD_DEPRECATED))
    {
      if (alias->replacement)
      printf_filtered ("Use '%s'.\n\n", alias->replacement);
      else
      printf_filtered ("No alternative known.\n\n");
     }  
  else
    {
      if (cmd->replacement)
      printf_filtered ("Use '%s'.\n\n", cmd->replacement);
      else
      printf_filtered ("No alternative known.\n\n");
    }

  /* We've warned you, now we'll keep quiet */
  if (alias)
    alias->flags &= ~DEPRECATED_WARN_USER;
  
  cmd->flags &= ~DEPRECATED_WARN_USER;
}



/* Look up the contents of LINE as a command in the command list 'cmdlist'. 
   Return 1 on success, 0 on failure.
   
   If LINE refers to an alias, *alias will point to that alias.
   
   If LINE is a postfix command (i.e. one that is preceeded by a prefix
   command) set *prefix_cmd.
   
   Set *cmd to point to the command LINE indicates.
   
   If any of *alias, *prefix_cmd, or *cmd cannot be determined or do not 
   exist, they are NULL when we return.
   
*/
int
lookup_cmd_composition (char *text,
                      struct cmd_list_element **alias,
                      struct cmd_list_element **prefix_cmd, 
                      struct cmd_list_element **cmd)
{
  char *p, *command;
  int len, tmp, nfound;
  struct cmd_list_element *cur_list;
  struct cmd_list_element *prev_cmd;
  *alias = NULL;
  *prefix_cmd = NULL;
  *cmd = NULL;
  
  cur_list = cmdlist;
  
  while (1)
    { 
      /* Go through as many command lists as we need to 
       to find the command TEXT refers to. */
      
      prev_cmd = *cmd;
      
      while (*text == ' ' || *text == '\t')
      (text)++;
      
      /* Treating underscores as part of command words is important
       so that "set args_foo()" doesn't get interpreted as
       "set args _foo()".  */
      for (p = text;
         *p && (isalnum (*p) || *p == '-' || *p == '_' ||
                (tui_version &&
                 (*p == '+' || *p == '<' || *p == '>' || *p == '$')) ||
                (xdb_commands && (*p == '!' || *p == '/' || *p == '?')));
         p++)
      ;
      
      /* If nothing but whitespace, return.  */
      if (p == text)
      return 0;
      
      len = p - text;
      
      /* text and p now bracket the first command word to lookup (and
       it's length is len).  We copy this into a local temporary */
      
      command = (char *) alloca (len + 1);
      for (tmp = 0; tmp < len; tmp++)
      {
        char x = text[tmp];
        command[tmp] = x;
      }
      command[len] = '\0';
      
      /* Look it up.  */
      *cmd = 0;
      nfound = 0;
      *cmd = find_cmd (command, len, cur_list, 1, &nfound);
      
      /* We didn't find the command in the entered case, so lower case it
       and search again.
      */
      if (!*cmd || nfound == 0)
      {
        for (tmp = 0; tmp < len; tmp++)
          {
            char x = command[tmp];
            command[tmp] = isupper (x) ? tolower (x) : x;
          }
        *cmd = find_cmd (command, len, cur_list, 1, &nfound);
      }
      
      if (*cmd == (struct cmd_list_element *) -1)
      {
        return 0;              /* ambiguous */
      }
      
      if (*cmd == NULL)
      return 0;                /* nothing found */
      else
      {
        if ((*cmd)->cmd_pointer)
          {
            /* cmd was actually an alias, we note that an alias was used 
               (by assigning *alais) and we set *cmd. 
             */
            *alias = *cmd;
            *cmd = (*cmd)->cmd_pointer;
          }
        *prefix_cmd = prev_cmd;
      }
      if ((*cmd)->prefixlist)
      cur_list = *(*cmd)->prefixlist;
      else
      return 1;
      
      text = p;
    }
}




#if 0
/* Look up the contents of *LINE as a command in the command list LIST.
   LIST is a chain of struct cmd_list_element's.
   If it is found, return the struct cmd_list_element for that command
   and update *LINE to point after the command name, at the first argument.
   If not found, call error if ALLOW_UNKNOWN is zero
   otherwise (or if error returns) return zero.
   Call error if specified command is ambiguous,
   unless ALLOW_UNKNOWN is negative.
   CMDTYPE precedes the word "command" in the error message.  */

struct cmd_list_element *
lookup_cmd (char **line, struct cmd_list_element *list, char *cmdtype,
	    int allow_unknown)
{
  register char *p;
  register struct cmd_list_element *c, *found;
  int nfound;
  char ambbuf[100];
  char *processed_cmd;
  int i, cmd_len;

  /* Skip leading whitespace.  */

  while (**line == ' ' || **line == '\t')
    (*line)++;

  /* Clear out trailing whitespace.  */

  p = *line + strlen (*line);
  while (p != *line && (p[-1] == ' ' || p[-1] == '\t'))
    p--;
  *p = 0;

  /* Find end of command name.  */

  p = *line;
  while (*p == '-' || isalnum (*p))
    p++;

  /* Look up the command name.
     If exact match, keep that.
     Otherwise, take command abbreviated, if unique.  Note that (in my
     opinion) a null string does *not* indicate ambiguity; simply the
     end of the argument.  */

  if (p == *line)
    {
      if (!allow_unknown)
	error ("Lack of needed %scommand", cmdtype);
      return 0;
    }

  /* Copy over to a local buffer, converting to lowercase on the way.
     This is in case the command being parsed is a subcommand which
     doesn't match anything, and that's ok.  We want the original
     untouched for the routine of the original command.  */

  processed_cmd = (char *) alloca (p - *line + 1);
  for (cmd_len = 0; cmd_len < p - *line; cmd_len++)
    {
      char x = (*line)[cmd_len];
      if (isupper (x))
	processed_cmd[cmd_len] = tolower (x);
      else
	processed_cmd[cmd_len] = x;
    }
  processed_cmd[cmd_len] = '\0';

  /* Check all possibilities in the current command list.  */
  found = 0;
  nfound = 0;
  for (c = list; c; c = c->next)
    {
      if (!strncmp (processed_cmd, c->name, cmd_len))
	{
	  found = c;
	  nfound++;
	  if (c->name[cmd_len] == 0)
	    {
	      nfound = 1;
	      break;
	    }
	}
    }

  /* Report error for undefined command name.  */

  if (nfound != 1)
    {
      if (nfound > 1 && allow_unknown >= 0)
	{
	  ambbuf[0] = 0;
	  for (c = list; c; c = c->next)
	    if (!strncmp (processed_cmd, c->name, cmd_len))
	      {
		if (strlen (ambbuf) + strlen (c->name) + 6 < sizeof ambbuf)
		  {
		    if (strlen (ambbuf))
		      strcat (ambbuf, ", ");
		    strcat (ambbuf, c->name);
		  }
		else
		  {
		    strcat (ambbuf, "..");
		    break;
		  }
	      }
	  error ("Ambiguous %scommand \"%s\": %s.", cmdtype,
		 processed_cmd, ambbuf);
	}
      else if (!allow_unknown)
	error ("Undefined %scommand: \"%s\".", cmdtype, processed_cmd);
      return 0;
    }

  /* Skip whitespace before the argument.  */

  while (*p == ' ' || *p == '\t')
    p++;
  *line = p;

  if (found->prefixlist && *p)
    {
      c = lookup_cmd (line, *found->prefixlist, found->prefixname,
		      found->allow_unknown);
      if (c)
	return c;
    }

  return found;
}
#endif

/* Helper function for SYMBOL_COMPLETION_FUNCTION.  */

/* Return a vector of char pointers which point to the different
   possible completions in LIST of TEXT.  

   WORD points in the same buffer as TEXT, and completions should be
   returned relative to this position.  For example, suppose TEXT is "foo"
   and we want to complete to "foobar".  If WORD is "oo", return
   "oobar"; if WORD is "baz/foo", return "baz/foobar".  */

char **
complete_on_cmdlist (struct cmd_list_element *list, char *text, char *word)
{
  struct cmd_list_element *ptr;
  char **matchlist;
  int sizeof_matchlist;
  int matches;
  int textlen = strlen (text);

  sizeof_matchlist = 10;
  matchlist = (char **) xmalloc (sizeof_matchlist * sizeof (char *));
  matches = 0;

  for (ptr = list; ptr; ptr = ptr->next)
    if (!strncmp (ptr->name, text, textlen)
	&& !ptr->abbrev_flag
	&& (ptr->function.cfunc
	    || ptr->prefixlist))
      {
	if (matches == sizeof_matchlist)
	  {
	    sizeof_matchlist *= 2;
	    matchlist = (char **) xrealloc ((char *) matchlist,
					    (sizeof_matchlist
					     * sizeof (char *)));
	  }

	matchlist[matches] = (char *)
	  xmalloc (strlen (word) + strlen (ptr->name) + 1);
	if (word == text)
	  strcpy (matchlist[matches], ptr->name);
	else if (word > text)
	  {
	    /* Return some portion of ptr->name.  */
	    strcpy (matchlist[matches], ptr->name + (word - text));
	  }
	else
	  {
	    /* Return some of text plus ptr->name.  */
	    strncpy (matchlist[matches], word, text - word);
	    matchlist[matches][text - word] = '\0';
	    strcat (matchlist[matches], ptr->name);
	  }
	++matches;
      }

  if (matches == 0)
    {
      free ((PTR) matchlist);
      matchlist = 0;
    }
  else
    {
      matchlist = (char **) xrealloc ((char *) matchlist, ((matches + 1)
							* sizeof (char *)));
      matchlist[matches] = (char *) 0;
    }

  return matchlist;
}

/* Helper function for SYMBOL_COMPLETION_FUNCTION.  */

/* Return a vector of char pointers which point to the different
   possible completions in CMD of TEXT.  

   WORD points in the same buffer as TEXT, and completions should be
   returned relative to this position.  For example, suppose TEXT is "foo"
   and we want to complete to "foobar".  If WORD is "oo", return
   "oobar"; if WORD is "baz/foo", return "baz/foobar".  */

char **
complete_on_enum (const char *enumlist[],
		  char *text,
		  char *word)
{
  char **matchlist;
  int sizeof_matchlist;
  int matches;
  int textlen = strlen (text);
  int i;
  const char *name;

  sizeof_matchlist = 10;
  matchlist = (char **) xmalloc (sizeof_matchlist * sizeof (char *));
  matches = 0;

  for (i = 0; (name = enumlist[i]) != NULL; i++)
    if (strncmp (name, text, textlen) == 0)
      {
	if (matches == sizeof_matchlist)
	  {
	    sizeof_matchlist *= 2;
	    matchlist = (char **) xrealloc ((char *) matchlist,
					    (sizeof_matchlist
					     * sizeof (char *)));
	  }

	matchlist[matches] = (char *)
	  xmalloc (strlen (word) + strlen (name) + 1);
	if (word == text)
	  strcpy (matchlist[matches], name);
	else if (word > text)
	  {
	    /* Return some portion of name.  */
	    strcpy (matchlist[matches], name + (word - text));
	  }
	else
	  {
	    /* Return some of text plus name.  */
	    strncpy (matchlist[matches], word, text - word);
	    matchlist[matches][text - word] = '\0';
	    strcat (matchlist[matches], name);
	  }
	++matches;
      }

  if (matches == 0)
    {
      free ((PTR) matchlist);
      matchlist = 0;
    }
  else
    {
      matchlist = (char **) xrealloc ((char *) matchlist, ((matches + 1)
							* sizeof (char *)));
      matchlist[matches] = (char *) 0;
    }

  return matchlist;
}

static enum cmd_auto_boolean
parse_auto_binary_operation (const char *arg)
{
  if (arg != NULL && *arg != '\0')
    {
      int length = strlen (arg);
      while (isspace (arg[length - 1]) && length > 0)
	length--;
      if (strncmp (arg, "on", length) == 0
	  || strncmp (arg, "1", length) == 0
	  || strncmp (arg, "yes", length) == 0
	  || strncmp (arg, "enable", length) == 0)
	return CMD_AUTO_BOOLEAN_TRUE;
      else if (strncmp (arg, "off", length) == 0
	       || strncmp (arg, "0", length) == 0
	       || strncmp (arg, "no", length) == 0
	       || strncmp (arg, "disable", length) == 0)
	return CMD_AUTO_BOOLEAN_FALSE;
      else if (strncmp (arg, "auto", length) == 0
	       || (strncmp (arg, "-1", length) == 0 && length > 1))
	return CMD_AUTO_BOOLEAN_AUTO;
    }
  error ("\"on\", \"off\" or \"auto\" expected.");
  return CMD_AUTO_BOOLEAN_AUTO; /* pacify GCC */
}

static int
parse_binary_operation (char *arg)
{
  int length;

  if (!arg || !*arg)
    return 1;

  length = strlen (arg);

  while (arg[length - 1] == ' ' || arg[length - 1] == '\t')
    length--;

  if (strncmp (arg, "on", length) == 0
      || strncmp (arg, "1", length) == 0
      || strncmp (arg, "yes", length) == 0
      || strncmp (arg, "enable", length) == 0)
    return 1;
  else if (strncmp (arg, "off", length) == 0
	   || strncmp (arg, "0", length) == 0
	   || strncmp (arg, "no", length) == 0
	   || strncmp (arg, "disable", length) == 0)
    return 0;
  else
    {
      error ("\"on\" or \"off\" expected.");
      return 0;
    }
}

/* Do a "set" or "show" command.  ARG is NULL if no argument, or the text
   of the argument, and FROM_TTY is nonzero if this command is being entered
   directly by the user (i.e. these are just like any other
   command).  C is the command list element for the command.  */
void
do_setshow_command (char *arg, int from_tty, struct cmd_list_element *c)
{
  if (c->type == set_cmd)
    {
      switch (c->var_type)
	{
	case var_string:
	  {
	    char *new;
	    char *p;
	    char *q;
	    int ch;

	    if (arg == NULL)
	      arg = "";
	    new = (char *) xmalloc (strlen (arg) + 2);
	    p = arg;
	    q = new;
	    while ((ch = *p++) != '\000')
	      {
		if (ch == '\\')
		  {
		    /* \ at end of argument is used after spaces
		       so they won't be lost.  */
		    /* This is obsolete now that we no longer strip
		       trailing whitespace and actually, the backslash
		       didn't get here in my test, readline or
		       something did something funky with a backslash
		       right before a newline.  */
		    if (*p == 0)
		      break;
		    ch = parse_escape (&p);
		    if (ch == 0)
		      break;	/* C loses */
		    else if (ch > 0)
		      *q++ = ch;
		  }
		else
		  *q++ = ch;
	      }
#if 0
	    if (*(p - 1) != '\\')
	      *q++ = ' ';
#endif
	    *q++ = '\0';
	    new = (char *) xrealloc (new, q - new);
	    if (*(char **) c->var != NULL)
	      free (*(char **) c->var);
	    *(char **) c->var = new;
	  }
	  break;
	case var_string_noescape:
	  if (arg == NULL)
	    arg = "";
	  if (*(char **) c->var != NULL)
	    free (*(char **) c->var);
	  *(char **) c->var = savestring (arg, strlen (arg));
	  break;
	case var_filename:
	  if (arg == NULL)
	    error_no_arg ("filename to set it to.");
	  if (*(char **) c->var != NULL)
	    free (*(char **) c->var);
	  *(char **) c->var = tilde_expand (arg);
	  break;
	case var_boolean:
	  *(int *) c->var = parse_binary_operation (arg);
	  break;
	case var_auto_boolean:
	  *(enum cmd_auto_boolean *) c->var = parse_auto_binary_operation (arg);
	  break;
	case var_uinteger:
	  if (arg == NULL)
	    error_no_arg ("integer to set it to.");
	  *(unsigned int *) c->var = parse_and_eval_long (arg);
	  if (*(unsigned int *) c->var == 0)
	    *(unsigned int *) c->var = UINT_MAX;
	  break;
	case var_integer:
	  {
	    unsigned int val;
	    if (arg == NULL)
	      error_no_arg ("integer to set it to.");
	    val = parse_and_eval_long (arg);
	    if (val == 0)
	      *(int *) c->var = INT_MAX;
	    else if (val >= INT_MAX)
	      error ("integer %u out of range", val);
	    else
	      *(int *) c->var = val;
	    break;
	  }
	case var_zinteger:
	  if (arg == NULL)
	    error_no_arg ("integer to set it to.");
	  *(int *) c->var = parse_and_eval_long (arg);
	  break;
	case var_enum:
	  {
	    int i;
	    int len;
	    int nmatches;
	    const char *match = NULL;
	    char *p;

	    /* if no argument was supplied, print an informative error message */
	    if (arg == NULL)
	      {
		char msg[1024];
		strcpy (msg, "Requires an argument. Valid arguments are ");
		for (i = 0; c->enums[i]; i++)
		  {
		    if (i != 0)
		      strcat (msg, ", ");
		    strcat (msg, c->enums[i]);
		  }
		strcat (msg, ".");
		error (msg);
	      }

	    p = strchr (arg, ' ');

	    if (p)
	      len = p - arg;
	    else
	      len = strlen (arg);

	    nmatches = 0;
	    for (i = 0; c->enums[i]; i++)
	      if (strncmp (arg, c->enums[i], len) == 0)
		{
		  if (c->enums[i][len] == '\0')
		    {
		      match = c->enums[i];
		      nmatches = 1;
		      break; /* exact match. */
		    }
		  else
		    {
		      match = c->enums[i];
		      nmatches++;
		    }
		}

	    if (nmatches <= 0)
	      error ("Undefined item: \"%s\".", arg);

	    if (nmatches > 1)
	      error ("Ambiguous item \"%s\".", arg);

	    *(const char **) c->var = match;
	  }
	  break;
	default:
	  error ("gdb internal error: bad var_type in do_setshow_command");
	}
    }
  else if (c->type == show_cmd)
    {
#ifdef UI_OUT
      struct cleanup *old_chain;
      struct ui_stream *stb;
      int quote;

      stb = ui_out_stream_new (uiout);
      old_chain = make_cleanup_ui_out_stream_delete (stb);
#endif /* UI_OUT */

      /* Print doc minus "show" at start.  */
      print_doc_line (gdb_stdout, c->doc + 5);

#ifdef UI_OUT
      ui_out_text (uiout, " is ");
      ui_out_wrap_hint (uiout, "    ");
      quote = 0;
      switch (c->var_type)
	{
	case var_string:
	  {
	    unsigned char *p;

	    if (*(unsigned char **) c->var)
	      fputstr_filtered (*(unsigned char **) c->var, '"', stb->stream);
	    quote = 1;
	  }
	  break;
	case var_string_noescape:
	case var_filename:
	case var_enum:
	  if (*(char **) c->var)
	    fputs_filtered (*(char **) c->var, stb->stream);
	  quote = 1;
	  break;
	case var_boolean:
	  fputs_filtered (*(int *) c->var ? "on" : "off", stb->stream);
	  break;
	case var_auto_boolean:
	  switch (*(enum cmd_auto_boolean*) c->var)
	    {
	    case CMD_AUTO_BOOLEAN_TRUE:
	      fputs_filtered ("on", stb->stream);
	      break;
	    case CMD_AUTO_BOOLEAN_FALSE:
	      fputs_filtered ("off", stb->stream);
	      break;
	    case CMD_AUTO_BOOLEAN_AUTO:
	      fputs_filtered ("auto", stb->stream);
	      break;
	    default:
	      internal_error ("do_setshow_command: invalid var_auto_boolean");
	      break;
	    }
	  break;
	case var_uinteger:
	  if (*(unsigned int *) c->var == UINT_MAX)
	    {
	      fputs_filtered ("unlimited", stb->stream);
	      break;
	    }
	  /* else fall through */
	case var_zinteger:
	  fprintf_filtered (stb->stream, "%u", *(unsigned int *) c->var);
	  break;
	case var_integer:
	  if (*(int *) c->var == INT_MAX)
	    {
	      fputs_filtered ("unlimited", stb->stream);
	    }
	  else
	    fprintf_filtered (stb->stream, "%d", *(int *) c->var);
	  break;

	default:
	  error ("gdb internal error: bad var_type in do_setshow_command");
	}
      if (quote)
	ui_out_text (uiout, "\"");
      ui_out_field_stream (uiout, "value", stb);
      if (quote)
	ui_out_text (uiout, "\"");
      ui_out_text (uiout, ".\n");
      do_cleanups (old_chain);
#else
      fputs_filtered (" is ", gdb_stdout);
      wrap_here ("    ");
      switch (c->var_type)
	{
	case var_string:
	  {
	    fputs_filtered ("\"", gdb_stdout);
	    if (*(unsigned char **) c->var)
	      fputstr_filtered (*(unsigned char **) c->var, '"', gdb_stdout);
	    fputs_filtered ("\"", gdb_stdout);
	  }
	  break;
	case var_string_noescape:
	case var_filename:
	case var_enum:
	  fputs_filtered ("\"", gdb_stdout);
	  if (*(char **) c->var)
	    fputs_filtered (*(char **) c->var, gdb_stdout);
	  fputs_filtered ("\"", gdb_stdout);
	  break;
	case var_boolean:
	  fputs_filtered (*(int *) c->var ? "on" : "off", gdb_stdout);
	  break;
	case var_auto_boolean:
	  switch (*(enum cmd_auto_boolean*) c->var)
	    {
	    case CMD_AUTO_BOOLEAN_TRUE:
	      fputs_filtered ("on", gdb_stdout);
	      break;
	    case CMD_AUTO_BOOLEAN_FALSE:
	      fputs_filtered ("off", gdb_stdout);
	      break;
	    case CMD_AUTO_BOOLEAN_AUTO:
	      fputs_filtered ("auto", gdb_stdout);
	      break;
	    default:
	      internal_error ("do_setshow_command: invalid var_auto_boolean");
	      break;
	    }
	  break;
	case var_uinteger:
	  if (*(unsigned int *) c->var == UINT_MAX)
	    {
	      fputs_filtered ("unlimited", gdb_stdout);
	      break;
	    }
	  /* else fall through */
	case var_zinteger:
	  fprintf_filtered (gdb_stdout, "%u", *(unsigned int *) c->var);
	  break;
	case var_integer:
	  if (*(int *) c->var == INT_MAX)
	    {
	      fputs_filtered ("unlimited", gdb_stdout);
	    }
	  else
	    fprintf_filtered (gdb_stdout, "%d", *(int *) c->var);
	  break;

	default:
	  error ("gdb internal error: bad var_type in do_setshow_command");
	}
      fputs_filtered (".\n", gdb_stdout);
#endif
    }
  else
    error ("gdb internal error: bad cmd_type in do_setshow_command");
  (*c->function.sfunc) (NULL, from_tty, c);
  if (c->type == set_cmd && set_hook)
    set_hook (c);
}

/* Show all the settings in a list of show commands.  */

void
cmd_show_list (struct cmd_list_element *list, int from_tty, char *prefix)
{
#ifdef UI_OUT
  ui_out_list_begin (uiout, "showlist");
#endif
  for (; list != NULL; list = list->next)
    {
      /* If we find a prefix, run its list, prefixing our output by its
         prefix (with "show " skipped).  */
#ifdef UI_OUT
      if (list->prefixlist && !list->abbrev_flag)
	{
	  ui_out_list_begin (uiout, "optionlist");
	  ui_out_field_string (uiout, "prefix", list->prefixname + 5);
	  cmd_show_list (*list->prefixlist, from_tty, list->prefixname + 5);
	  ui_out_list_end (uiout);
	}
      if (list->type == show_cmd)
	{
	  ui_out_list_begin (uiout, "option");
	  ui_out_text (uiout, prefix);
	  ui_out_field_string (uiout, "name", list->name);
	  ui_out_text (uiout, ":  ");
	  do_setshow_command ((char *) NULL, from_tty, list);
	  ui_out_list_end (uiout);
	}
#else
      if (list->prefixlist && !list->abbrev_flag)
	cmd_show_list (*list->prefixlist, from_tty, list->prefixname + 5);
      if (list->type == show_cmd)
	{
	  fputs_filtered (prefix, gdb_stdout);
	  fputs_filtered (list->name, gdb_stdout);
	  fputs_filtered (":  ", gdb_stdout);
	  do_setshow_command ((char *) NULL, from_tty, list);
	}
#endif
    }
#ifdef UI_OUT
  ui_out_list_end (uiout);
#endif
}

/* ARGSUSED */
static void
shell_escape (char *arg, int from_tty)
{
#ifdef CANT_FORK
  /* If ARG is NULL, they want an inferior shell, but `system' just
     reports if the shell is available when passed a NULL arg.  */
  int rc = system (arg ? arg : "");

  if (!arg)
    arg = "inferior shell";

  if (rc == -1)
    {
      fprintf_unfiltered (gdb_stderr, "Cannot execute %s: %s\n", arg,
			  safe_strerror (errno));
      gdb_flush (gdb_stderr);
    }
  else if (rc)
    {
      fprintf_unfiltered (gdb_stderr, "%s exited with status %d\n", arg, rc);
      gdb_flush (gdb_stderr);
    }
#ifdef __DJGPP__
  /* Make sure to return to the directory GDB thinks it is, in case the
     shell command we just ran changed it.  */
  chdir (current_directory);
#endif
#else /* Can fork.  */
  int rc, status, pid;
  char *p, *user_shell;

  if ((user_shell = (char *) getenv ("SHELL")) == NULL)
    user_shell = "/bin/sh";

  /* Get the name of the shell for arg0 */
  if ((p = strrchr (user_shell, '/')) == NULL)
    p = user_shell;
  else
    p++;			/* Get past '/' */

  if ((pid = fork ()) == 0)
    {
      if (!arg)
	execl (user_shell, p, 0);
      else
	execl (user_shell, p, "-c", arg, 0);

      fprintf_unfiltered (gdb_stderr, "Cannot execute %s: %s\n", user_shell,
			  safe_strerror (errno));
      gdb_flush (gdb_stderr);
      _exit (0177);
    }

  if (pid != -1)
    while ((rc = wait (&status)) != pid && rc != -1)
      ;
  else
    error ("Fork failed");
#endif /* Can fork.  */
}

static void
make_command (char *arg, int from_tty)
{
  char *p;

  if (arg == 0)
    p = "make";
  else
    {
      p = xmalloc (sizeof ("make ") + strlen (arg));
      strcpy (p, "make ");
      strcpy (p + sizeof ("make ") - 1, arg);
    }

  shell_escape (p, from_tty);
}

static void
show_user_1 (struct cmd_list_element *c, struct ui_file *stream)
{
  register struct command_line *cmdlines;

  cmdlines = c->user_commands;
  if (!cmdlines)
    return;
  fputs_filtered ("User command ", stream);
  fputs_filtered (c->name, stream);
  fputs_filtered (":\n", stream);

#ifdef UI_OUT
  print_command_lines (uiout, cmdlines, 1);
  fputs_filtered ("\n", stream);
#else
  while (cmdlines)
    {
      print_command_line (cmdlines, 4, stream);
      cmdlines = cmdlines->next;
    }
  fputs_filtered ("\n", stream);
#endif
}

/* ARGSUSED */
static void
show_user (char *args, int from_tty)
{
  struct cmd_list_element *c;
  extern struct cmd_list_element *cmdlist;

  if (args)
    {
      c = lookup_cmd (&args, cmdlist, "", 0, 1);
      if (c->class != class_user)
	error ("Not a user command.");
      show_user_1 (c, gdb_stdout);
    }
  else
    {
      for (c = cmdlist; c; c = c->next)
	{
	  if (c->class == class_user)
	    show_user_1 (c, gdb_stdout);
	}
    }
}

void
_initialize_command (void)
{
  add_com ("shell", class_support, shell_escape,
	   "Execute the rest of the line as a shell command.  \n\
With no arguments, run an inferior shell.");

  /* NOTE: cagney/2000-03-20: Being able to enter ``(gdb) !ls'' would
     be a really useful feature.  Unfortunately, the below wont do
     this.  Instead it adds support for the form ``(gdb) ! ls''
     (i.e. the space is required).  If the ``!'' command below is
     added the complains about no ``!'' command would be replaced by
     complains about how the ``!'' command is broken :-) */
  if (xdb_commands)
    add_com_alias ("!", "shell", class_support, 0);

  add_com ("make", class_support, make_command,
       "Run the ``make'' program using the rest of the line as arguments.");
  add_cmd ("user", no_class, show_user,
	   "Show definitions of user defined commands.\n\
Argument is the name of the user defined command.\n\
With no argument, show definitions of all user defined commands.", &showlist);
  add_com ("apropos", class_support, apropos_command, "Search for commands matching a REGEXP");
}
@


1.20
log
@2000-11-06  Fernando Nasser  <fnasser@@cygnus.com>

        From  Steven Johnson  <sbjohnson@@ozemail.com.au>:

        This set of changes add "hookpost-" as an expansion on the original
        hooking of commands to GDB. A Hook may now be run "AFTER" execution of
        a command as well as before.

        * command.h (struct cmd_list_element): Changed elements hook and hookee
        to hook_pre and hookee_pre respectively. Added hook_post and hookee_post
        for the post hook command operation. Added hook_in so that an executing
        hook can be flagged to prevent recursion.
        * command.c (add_cmd): Changed initilization of cmd_list_element to
        reflect above changes.
        (delete_cmd): Remove both pre and post hooks.
        (help_cmd): Notify that the command has pre and/or post hooks.
        * infrun.c (normal_stop): Change references to hook_pre from hook.
        * top.c (execute_command): Run both pre and post hooks.
        (define_command): Allow definition of both pre and post hooks.
        The definition of pre-hooks is done as before, with the "hook-"
        prefix for backward compatibility.
@
text
@@


1.19
log
@	* eval.c (parse_and_eval_long): New function.
	* value.h: Declare it.

	* breakpoint.c (breakpoints_info, maintenance_info_breakpoints):
	Call parse_and_eval_long, not parse_and_eval_address.
	* command.c (do_setshow_command): Ditto.
	* infcmd.c (step_1, signal_command, continue_command): Ditto.
	* infrun.c (signals_info): Ditto.
	* stack.c (set_backtrace_limit_command, backtrace_command_1,
	up_silently_base, down_silently_base): Ditto.
	* tracepoints.c (tracepoints_info, trace_find_command,
 	trace_find_tracepoint_command): Ditto.
	* valprint.c (set_radix): Ditto.
	* values.c (show_values): Ditto.
@
text
@d115 3
a117 1
  c->hook = NULL;
d128 2
a129 1
  c->hookee = NULL;
d372 4
a375 2
      if ((*list)->hookee)
	(*list)->hookee->hook = 0;	/* Hook slips out of its mouth */
d386 5
a390 2
	    if (c->next->hookee)
	      c->next->hookee->hook = 0;	/* hooked cmd gets away.  */
d542 12
a553 3
  if (c->hook)
    fprintf_filtered (stream, "\nThis command has a hook defined: %s\n",
		      c->hook->name);
@


1.18
log
@
Corrected spelling errors in comments
@
text
@d1625 1
a1625 1
	  *(unsigned int *) c->var = parse_and_eval_address (arg);
d1634 1
a1634 1
	    val = parse_and_eval_address (arg);
d1646 1
a1646 1
	  *(int *) c->var = parse_and_eval_address (arg);
@


1.17
log
@Protoize.
@
text
@d2048 1
a2048 1
     be a really useful feature.  Unfortunatly, the below wont do
@


1.16
log
@Protoization.
@
text
@d84 2
a85 6
add_cmd (name, class, fun, doc, list)
     char *name;
     enum command_class class;
     void (*fun) (char *, int);
     char *doc;
     struct cmd_list_element **list;
d162 2
a163 6
add_abbrev_cmd (name, class, fun, doc, list)
     char *name;
     enum command_class class;
     void (*fun) (char *, int);
     char *doc;
     struct cmd_list_element **list;
d207 4
a210 10
add_prefix_cmd (name, class, fun, doc, prefixlist, prefixname,
		allow_unknown, list)
     char *name;
     enum command_class class;
     void (*fun) (char *, int);
     char *doc;
     struct cmd_list_element **prefixlist;
     char *prefixname;
     int allow_unknown;
     struct cmd_list_element **list;
d222 4
a225 10
add_abbrev_prefix_cmd (name, class, fun, doc, prefixlist, prefixname,
		       allow_unknown, list)
     char *name;
     enum command_class class;
     void (*fun) (char *, int);
     char *doc;
     struct cmd_list_element **prefixlist;
     char *prefixname;
     int allow_unknown;
     struct cmd_list_element **list;
@


1.15
log
@2000-07-11  Scott Bambrough <scottb@@netwinder.org>

	* command.c (do_setshow_command): Fix typo in var_auto_boolean
	case.
@
text
@d148 1
a148 3
deprecate_cmd (cmd, replacement)
     struct cmd_list_element *cmd;
     char *replacement;
d183 2
a184 6
add_alias_cmd (name, oldname, class, abbrev_flag, list)
     char *name;
     char *oldname;
     enum command_class class;
     int abbrev_flag;
     struct cmd_list_element **list;
d257 1
a257 3
not_just_help_class_command (args, from_tty)
     char *args;
     int from_tty;
d265 1
a265 4
empty_sfunc (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
d342 2
a343 3
add_show_from_set (setcmd, list)
     struct cmd_list_element *setcmd;
     struct cmd_list_element **list;
d382 1
a382 3
delete_cmd (name, list)
     char *name;
     struct cmd_list_element **list;
d505 1
a505 3
help_cmd (command, stream)
     char *command;
     struct ui_file *stream;
d572 2
a573 5
help_list (list, cmdtype, class, stream)
     struct cmd_list_element *list;
     char *cmdtype;
     enum command_class class;
     struct ui_file *stream;
d633 1
a633 3
print_doc_line (stream, str)
     struct ui_file *stream;
     char *str;
d682 2
a683 6
help_cmd_list (list, class, prefix, recurse, stream)
     struct cmd_list_element *list;
     enum command_class class;
     char *prefix;
     int recurse;
     struct ui_file *stream;
d711 2
a712 6
find_cmd (command, len, clist, ignore_help_classes, nfound)
     char *command;
     int len;
     struct cmd_list_element *clist;
     int ignore_help_classes;
     int *nfound;
d770 2
a771 4
lookup_cmd_1 (text, clist, result_list, ignore_help_classes)
     char **text;
     struct cmd_list_element *clist, **result_list;
     int ignore_help_classes;
d903 1
a903 2
undef_cmd_error (cmdtype, q)
     char *cmdtype, *q;
d928 2
a929 6
lookup_cmd (line, list, cmdtype, allow_unknown, ignore_help_classes)
     char **line;
     struct cmd_list_element *list;
     char *cmdtype;
     int allow_unknown;
     int ignore_help_classes;
d1246 2
a1247 5
lookup_cmd (line, list, cmdtype, allow_unknown)
     char **line;
     struct cmd_list_element *list;
     char *cmdtype;
     int allow_unknown;
d1379 1
a1379 4
complete_on_cmdlist (list, text, word)
     struct cmd_list_element *list;
     char *text;
     char *word;
d1537 1
a1537 2
parse_binary_operation (arg)
     char *arg;
d1571 1
a1571 4
do_setshow_command (arg, from_tty, c)
     char *arg;
     int from_tty;
     struct cmd_list_element *c;
d1889 1
a1889 4
cmd_show_list (list, from_tty, prefix)
     struct cmd_list_element *list;
     int from_tty;
     char *prefix;
d1934 1
a1934 3
shell_escape (arg, from_tty)
     char *arg;
     int from_tty;
d1995 1
a1995 3
make_command (arg, from_tty)
     char *arg;
     int from_tty;
d2012 1
a2012 3
show_user_1 (c, stream)
     struct cmd_list_element *c;
     struct ui_file *stream;
d2038 1
a2038 3
show_user (args, from_tty)
     char *args;
     int from_tty;
d2061 1
a2061 1
_initialize_command ()
@


1.14
log
@Add support for auto_boolean (true, false or auto).
@
text
@d1814 1
a1814 1
	  switch (*(enum auto_boolean*) c->var)
@


1.13
log
@Change signature of function add_set_enum_cmd() so that it uses
constant character pointers.  Update everything.
As a consequence fix infrun's follow-fork plugging a small memory leak.
@
text
@d330 19
d1552 26
d1592 4
a1595 3
  if (!strncmp (arg, "on", length)
      || !strncmp (arg, "1", length)
      || !strncmp (arg, "yes", length))
d1597 4
a1600 3
  else if (!strncmp (arg, "off", length)
	   || !strncmp (arg, "0", length)
	   || !strncmp (arg, "no", length))
d1685 3
d1813 17
d1882 17
@


1.12
log
@Accept an enum immediately when it is an exact match - wouldn't accept
``d10v'' when the choice was d10v{,:ts2,:ts3}.
@
text
@d318 2
a319 2
		  char *enumlist[],
		  char **var,
d1473 3
a1475 4
complete_on_enum (enumlist, text, word)
     char **enumlist;
     char *text;
     char *word;
d1482 1
a1482 1
  char *name;
d1669 1
a1669 1
	    char *match = NULL;
d1717 1
a1717 1
	    *(char **) c->var = match;
@


1.11
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d1699 11
a1709 2
		  match = c->enums[i];
		  nmatches++;
@


1.10
log
@PARAMS removal.
@
text
@d87 1
a87 1
     void (*fun) PARAMS ((char *, int));
d171 1
a171 1
     void (*fun) PARAMS ((char *, int));
d225 1
a225 1
     void (*fun) PARAMS ((char *, int));
d246 1
a246 1
     void (*fun) PARAMS ((char *, int));
@


1.9
log
@Fix signature of add_set_enum_cmd.  Change VAR parameter to char**.
Cleanup signature of add_set_cmd.  Change VAR parameter to void*.
@
text
@d38 1
a38 1
static void undef_cmd_error PARAMS ((char *, char *));
d40 1
a40 1
static void show_user PARAMS ((char *, int));
d44 1
a44 1
static void make_command PARAMS ((char *, int));
d46 1
a46 1
static void shell_escape PARAMS ((char *, int));
d48 1
a48 1
static int parse_binary_operation PARAMS ((char *));
d52 5
a56 5
static struct cmd_list_element *find_cmd PARAMS ((char *command,
						  int len,
					    struct cmd_list_element * clist,
						  int ignore_help_classes,
						  int *nfound));
d64 1
a64 1
void _initialize_command PARAMS ((void));
d270 1
a270 1
static void empty_sfunc PARAMS ((char *, int, struct cmd_list_element *));
@


1.8
log
@Use make_cleanup_ui_out_stream_delete().
@
text
@d288 6
a293 7
add_set_cmd (name, class, var_type, var, doc, list)
     char *name;
     enum command_class class;
     var_types var_type;
     char *var;
     char *doc;
     struct cmd_list_element **list;
d316 6
a321 7
add_set_enum_cmd (name, class, enumlist, var, doc, list)
     char *name;
     enum command_class class;
     char *enumlist[];
     char *var;
     char *doc;
     struct cmd_list_element **list;
@


1.7
log
@Make help_all static.
@
text
@d1726 1
a1726 1
      old_chain = make_cleanup ((make_cleanup_func) ui_out_stream_delete, stb);
@


1.6
log
@Fri Mar 24 12:10:38 2000  glen mccready  <gkm@@pobox.com>

        * command.c, command.h (help_all): Add functionality to display
        a complete listing of available commands.
@
text
@d60 2
d614 1
a614 2
help_all (stream)
     struct ui_file *stream;
@


1.5
log
@2000-03-23  Fernando Nasser  <fnasser@@cygnus.com>

	From David Whedon <dwhedon@@gordian.com>

	* top.c (execute_command): Checks all commands beore executing
	to see if the user needs to be warned that the command is
	deprecated, warns user if appropriate.
	(add_info), (add_info_alias), (add_com) , (add_com_alias): Changed
	return values from void to struct cmd_list_element *.
	* command.c (lookup_cmd_1): Check aliases before following link
	in case user needs to be warned about a deprecated alias.
	(deprecate_cmd): new exported function for command deprecation,
	sets flags and posibly a replacement string.
	(deprecated_cmd_warning): New exported funciton to warn user about
	a deprecated command.
	(lookup_cmd_composition): New exported function that determines
	alias, prefix_command, and cmd based on a string.  This is useful
	is we want to full name of a command.
	* command.h : Added prototypes for deprecate_cmd,
	deprecated_warn_user and lookup_cmd_composition, added flags to
	the cmd_list_element structure, changed return values for
	add_com_* and add_info_* from void to cmd_list_element.
	* maint.c : (maintenance_deprecate): New function to deprecate a
	command.  This exists only so that the testsuite can deprecate
	commands at runtime and check the warning behavior.
	(maintenance_undeprecate) : New function, drops deprecated flags.
	(maintenance_do_deprecate): Actually does the (un)deprecation.
	(initialize_maint_cmds): Added the above new deprecate commands.
@
text
@d513 6
d609 21
@


1.4
log
@Added the apropos command
@
text
@d115 2
d134 27
d762 1
a831 2
  /* If this was an abbreviation, use the base command instead.  */

d833 12
a844 2
    found = found->cmd_pointer;

d1022 202
@


1.3
log
@Document requirements on adding a ``!'' command.
@
text
@d30 1
a30 1

d57 4
d377 81
d1781 1
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d1681 6
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1986, 1989, 1990, 1991, 1998 Free Software Foundation, Inc.
d4 14
a17 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d25 2
a26 2
#ifdef HAVE_UNISTD_H
#include <unistd.h>
d29 5
a33 6
#ifdef HAVE_WAIT_H
# include <wait.h>
#else
# ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
# endif
a35 2
#include "wait.h"

d42 1
a42 1
static void show_user_1 PARAMS ((struct cmd_list_element *, GDB_FILE *));
d50 7
a56 1
static void print_doc_line PARAMS ((GDB_FILE *, char *));
d86 1
a86 1
    = (struct cmd_list_element *) xmalloc (sizeof (struct cmd_list_element));
d100 3
a102 3
        {
          p = p->next;
        }
d130 1
a130 1
#if 0	/* Currently unused */
d141 1
a141 1
    = add_cmd (name, class, fun, doc, list);
d163 1
a163 1
  old  = lookup_cmd (&copied_name, *list, "", 1, 1);
d205 1
a205 1
   
d262 1
a262 1
    = add_cmd (name, class, NO_FUNCTION, doc, list);
d278 1
a278 1
     (from ENUMLIST).
d291 1
a291 1
    = add_set_cmd (name, class, var_enum, var, doc, list);
d306 1
a306 1
    (struct cmd_list_element *) xmalloc (sizeof (struct cmd_list_element));
d312 1
a312 1
  
d319 2
a320 2
  
    if (*list == NULL || STRCMP ((*list)->name, showcmd->name) >= 0)
d329 3
a331 3
        {
          p = p->next;
        }
d354 1
a354 1
      free ((PTR)*list);
d364 1
a364 1
	      c->next->hookee->hook = 0;  /* hooked cmd gets away.  */
d366 1
a366 1
	    free ((PTR)c->next);
d388 1
a388 1
     GDB_FILE *stream;
d407 1
a407 1
     
d410 1
a410 1
     
d453 1
a453 1
     GDB_FILE *stream;
d457 1
a457 1
  
d478 1
a478 1
  help_cmd_list (list, class, cmdtype, (int)class >= 0, stream);
d483 1
a483 1
	     cmdtype1);
d488 1
a488 1
	   cmdtype1, cmdtype2);
d490 1
a490 1
     
d494 1
a494 1
     GDB_FILE *stream;
d513 1
a513 1
      free ((PTR)line_buffer);
d520 3
d524 1
d534 1
a534 1
 *	A non-negative class number to list only commands in that
d536 2
a537 2
 *	ALL_COMMANDS to list all commands in list.
 *	ALL_CLASSES  to list all classes in list.
d549 1
a549 1
     GDB_FILE *stream;
d557 2
a558 2
	  || (class == all_classes && c->function.cfunc == NULL)
	  || (class == c->class && c->function.cfunc != NULL)))
d570 1
a571 1

d577 1
a577 1
find_cmd(command, len, clist, ignore_help_classes, nfound)
d579 1
d586 1
a586 1
  found = (struct cmd_list_element *)NULL;
d590 1
a590 1
        && (!ignore_help_classes || c->function.cfunc))
d592 7
a598 7
        found = c;
        (*nfound)++;
        if (c->name[len] == '\0')
          {
            *nfound = 1;
            break;
          }
d634 1
a634 1
   
d656 1
a656 1
       *p && (isalnum(*p) || *p == '-' || *p == '_' ||
d666 1
a666 1
  
d684 1
a684 1
  found = find_cmd(command, len, clist, ignore_help_classes, &nfound);
d687 3
a689 3
  ** We didn't find the command in the entered case, so lower case it
  ** and search again.
  */
d693 5
a697 5
        {
          char x = command[tmp];
          command[tmp] = isupper(x) ? tolower(x) : x;
        }
      found = find_cmd(command, len, clist, ignore_help_classes, &nfound);
d709 2
a710 2
	*result_list = 0;		
      return (struct cmd_list_element *) -1; /* Ambiguous.  */
d743 3
a745 3
		 If that was correct, need to modify the documentation
		 at the top of this function to clarify what is supposed
		 to be going on.  */
d770 5
a774 5
    cmdtype,
    q,
    *cmdtype? " ": "",
    strlen(cmdtype)-1,
    cmdtype);
d801 1
a801 1
    lookup_cmd_1 (line, list, &last_list, ignore_help_classes);
d811 1
a811 1
  
d822 1
a822 1
	      while (isalnum(*p) || *p == '-')
d837 1
a837 1
	 values.  */
d842 2
a843 2
	(last_list ? *(last_list->prefixlist) : list);
      
d862 1
a862 1
	  
d867 1
a867 1
		if (strlen (ambbuf) + strlen (c->name) + 6 < (int)sizeof ambbuf)
d899 1
a899 1
	
d940 1
a940 1
  while (*p == '-' || isalnum(*p))
d955 1
a955 1
  
d960 1
a960 1
  
d965 2
a966 2
      if (isupper(x))
	processed_cmd[cmd_len] = tolower(x);
d1021 2
a1022 1
  while (*p == ' ' || *p == '\t') p++;
d1072 1
a1072 1
	    matchlist = (char **) xrealloc ((char *)matchlist,
d1077 1
a1077 1
	matchlist[matches] = (char *) 
d1098 1
a1098 1
      free ((PTR)matchlist);
d1103 2
a1104 2
      matchlist = (char **) xrealloc ((char *)matchlist, ((matches + 1)
						* sizeof (char *)));
d1144 1
a1144 1
	    matchlist = (char **) xrealloc ((char *)matchlist,
d1149 1
a1149 1
	matchlist[matches] = (char *) 
d1170 1
a1170 1
      free ((PTR)matchlist);
d1175 2
a1176 2
      matchlist = (char **) xrealloc ((char *)matchlist, ((matches + 1)
						* sizeof (char *)));
d1201 4
d1206 2
a1207 3
    if (!strncmp (arg, "off", length)
	|| !strncmp (arg, "0", length)
	|| !strncmp (arg, "no", length))
d1209 1
a1209 5
    else 
      {
	error ("\"on\" or \"off\" expected.");
	return 0;
      }
d1232 1
a1232 1
	    
d1236 2
a1237 1
	    p = arg; q = new;
d1253 1
a1253 1
		      break; /* C loses */
d1266 2
a1267 2
	    if (*(char **)c->var != NULL)
	      free (*(char **)c->var);
d1274 2
a1275 2
	  if (*(char **)c->var != NULL)
	    free (*(char **)c->var);
d1281 3
a1283 3
	  if (*(char **)c->var != NULL)
	    free (*(char **)c->var);
	  *(char **)c->var = tilde_expand (arg);
d1338 1
a1338 1
	    
d1358 1
a1358 1
	    *(char **)c->var = match;
d1367 9
d1378 56
a1433 1
      
d1438 11
a1448 4
      case var_string:
	{
	  unsigned char *p;

d1450 2
a1451 3
	  if (*(unsigned char **)c->var)
	    for (p = *(unsigned char **) c->var; *p != '\0'; p++)
	      gdb_printchar (*p, gdb_stdout, '"');
a1452 16
	}
	break;
      case var_string_noescape:
      case var_filename:
      case var_enum:
	fputs_filtered ("\"", gdb_stdout);
	if (*(char **)c->var)
	  fputs_filtered (*(char **) c->var, gdb_stdout);
	fputs_filtered ("\"", gdb_stdout);
	break;
      case var_boolean:
	fputs_filtered (*(int *) c->var ? "on" : "off", gdb_stdout);
	break;
      case var_uinteger:
	if (*(unsigned int *) c->var == UINT_MAX) {
	  fputs_filtered ("unlimited", gdb_stdout);
d1454 24
a1478 16
	/* else fall through */
      case var_zinteger:
	fprintf_filtered (gdb_stdout, "%u", *(unsigned int *) c->var);
	break;
      case var_integer:
	if (*(int *) c->var == INT_MAX)
	  {
	    fputs_filtered ("unlimited", gdb_stdout);
	  }
	else
	  fprintf_filtered (gdb_stdout, "%d", *(int *) c->var);
	break;
	    
      default:
	error ("gdb internal error: bad var_type in do_setshow_command");
      }
d1480 1
d1485 2
d1497 39
a1535 13
  for (; list != NULL; list = list->next) {
    /* If we find a prefix, run its list, prefixing our output by its
       prefix (with "show " skipped).  */
    if (list->prefixlist && !list->abbrev_flag)
      cmd_show_list (*list->prefixlist, from_tty, list->prefixname + 5);
    if (list->type == show_cmd)
      {
	fputs_filtered (prefix, gdb_stdout);
	fputs_filtered (list->name, gdb_stdout);
	fputs_filtered (":  ", gdb_stdout);
	do_setshow_command ((char *)NULL, from_tty, list);
      }
  }
d1545 23
a1567 3
  /* FIXME: what about errors (I don't know how GO32 system() handles
     them)?  */
  system (arg);
d1581 1
a1581 1
  if ((pid = fork()) == 0)
d1613 1
a1613 1
      p = xmalloc (sizeof("make ") + strlen(arg));
d1615 1
a1615 1
      strcpy (p + sizeof("make ")-1, arg);
d1617 1
a1617 1
  
d1624 1
a1624 1
     GDB_FILE *stream;
d1635 4
d1641 1
a1641 1
      print_command_line (cmdlines, 4);
d1645 1
d1682 1
a1682 1
    add_com_alias("!", "shell", class_support, 0);
d1685 2
a1686 2
	   "Run the ``make'' program using the rest of the line as arguments.");
  add_cmd ("user", no_class, show_user, 
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-0519
@
text
@d1516 1
a1516 1
      print_command_line (cmdlines, 4, stream);
@


1.1.1.3
log
@import gdb-1999-05-25 snapshot
@
text
@a53 6
static struct cmd_list_element *find_cmd PARAMS ((char *command,
						  int len,
						  struct cmd_list_element *clist,
						  int ignore_help_classes,
						  int *nfound));

a570 1
     int len;
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d4 13
a16 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d29 1
a29 1
#include <wait.h>
d31 3
a33 3
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif
d56 1
a56 1
					    struct cmd_list_element * clist,
d88 1
a88 1
  = (struct cmd_list_element *) xmalloc (sizeof (struct cmd_list_element));
d102 3
a104 3
	{
	  p = p->next;
	}
d132 1
a132 1
#if 0				/* Currently unused */
d143 1
a143 1
  = add_cmd (name, class, fun, doc, list);
d165 1
a165 1
  old = lookup_cmd (&copied_name, *list, "", 1, 1);
d207 1
a207 1

d264 1
a264 1
  = add_cmd (name, class, NO_FUNCTION, doc, list);
d280 1
a280 1
   (from ENUMLIST).
d293 1
a293 1
  = add_set_cmd (name, class, var_enum, var, doc, list);
d308 1
a308 1
  (struct cmd_list_element *) xmalloc (sizeof (struct cmd_list_element));
d314 1
a314 1

d321 2
a322 2

  if (*list == NULL || STRCMP ((*list)->name, showcmd->name) >= 0)
d331 3
a333 3
	{
	  p = p->next;
	}
d356 1
a356 1
      free ((PTR) * list);
d366 1
a366 1
	      c->next->hookee->hook = 0;	/* hooked cmd gets away.  */
d368 1
a368 1
	    free ((PTR) c->next);
d409 1
a409 1

d412 1
a412 1

d459 1
a459 1

d480 1
a480 1
  help_cmd_list (list, class, cmdtype, (int) class >= 0, stream);
d485 1
a485 1
		      cmdtype1);
d490 1
a490 1
		    cmdtype1, cmdtype2);
d492 1
a492 1

d515 1
a515 1
      free ((PTR) line_buffer);
d532 1
a532 1
 *      A non-negative class number to list only commands in that
d534 2
a535 2
 *      ALL_COMMANDS to list all commands in list.
 *      ALL_CLASSES  to list all classes in list.
d555 2
a556 2
	   || (class == all_classes && c->function.cfunc == NULL)
	   || (class == c->class && c->function.cfunc != NULL)))
d568 1
a569 1

d575 1
a575 1
find_cmd (command, len, clist, ignore_help_classes, nfound)
d584 1
a584 1
  found = (struct cmd_list_element *) NULL;
d588 1
a588 1
	&& (!ignore_help_classes || c->function.cfunc))
d590 7
a596 7
	found = c;
	(*nfound)++;
	if (c->name[len] == '\0')
	  {
	    *nfound = 1;
	    break;
	  }
d632 1
a632 1

d654 1
a654 1
       *p && (isalnum (*p) || *p == '-' || *p == '_' ||
d664 1
a664 1

d682 1
a682 1
  found = find_cmd (command, len, clist, ignore_help_classes, &nfound);
d685 3
a687 3
     ** We didn't find the command in the entered case, so lower case it
     ** and search again.
   */
d691 5
a695 5
	{
	  char x = command[tmp];
	  command[tmp] = isupper (x) ? tolower (x) : x;
	}
      found = find_cmd (command, len, clist, ignore_help_classes, &nfound);
d707 2
a708 2
	*result_list = 0;
      return (struct cmd_list_element *) -1;	/* Ambiguous.  */
d741 3
a743 3
	         If that was correct, need to modify the documentation
	         at the top of this function to clarify what is supposed
	         to be going on.  */
d768 5
a772 5
	 cmdtype,
	 q,
	 *cmdtype ? " " : "",
	 strlen (cmdtype) - 1,
	 cmdtype);
d799 1
a799 1
  lookup_cmd_1 (line, list, &last_list, ignore_help_classes);
d809 1
a809 1

d820 1
a820 1
	      while (isalnum (*p) || *p == '-')
d835 1
a835 1
         values.  */
d840 2
a841 2
      (last_list ? *(last_list->prefixlist) : list);

d860 1
a860 1

d865 1
a865 1
		if (strlen (ambbuf) + strlen (c->name) + 6 < (int) sizeof ambbuf)
d897 1
a897 1

d938 1
a938 1
  while (*p == '-' || isalnum (*p))
d953 1
a953 1

d958 1
a958 1

d963 2
a964 2
      if (isupper (x))
	processed_cmd[cmd_len] = tolower (x);
d1019 1
a1019 2
  while (*p == ' ' || *p == '\t')
    p++;
d1069 1
a1069 1
	    matchlist = (char **) xrealloc ((char *) matchlist,
d1074 1
a1074 1
	matchlist[matches] = (char *)
d1095 1
a1095 1
      free ((PTR) matchlist);
d1100 2
a1101 2
      matchlist = (char **) xrealloc ((char *) matchlist, ((matches + 1)
							* sizeof (char *)));
d1141 1
a1141 1
	    matchlist = (char **) xrealloc ((char *) matchlist,
d1146 1
a1146 1
	matchlist[matches] = (char *)
d1167 1
a1167 1
      free ((PTR) matchlist);
d1172 2
a1173 2
      matchlist = (char **) xrealloc ((char *) matchlist, ((matches + 1)
							* sizeof (char *)));
a1197 4
  else if (!strncmp (arg, "off", length)
	   || !strncmp (arg, "0", length)
	   || !strncmp (arg, "no", length))
    return 0;
d1199 3
a1201 2
    {
      error ("\"on\" or \"off\" expected.");
d1203 5
a1207 1
    }
d1230 1
a1230 1

d1234 1
a1234 2
	    p = arg;
	    q = new;
d1250 1
a1250 1
		      break;	/* C loses */
d1263 2
a1264 2
	    if (*(char **) c->var != NULL)
	      free (*(char **) c->var);
d1271 2
a1272 2
	  if (*(char **) c->var != NULL)
	    free (*(char **) c->var);
d1278 3
a1280 3
	  if (*(char **) c->var != NULL)
	    free (*(char **) c->var);
	  *(char **) c->var = tilde_expand (arg);
d1335 1
a1335 1

d1355 1
a1355 1
	    *(char **) c->var = match;
d1366 1
a1366 1

d1371 3
a1373 3
	case var_string:
	  {
	    unsigned char *p;
a1374 10
	    fputs_filtered ("\"", gdb_stdout);
	    if (*(unsigned char **) c->var)
	      for (p = *(unsigned char **) c->var; *p != '\0'; p++)
		gdb_printchar (*p, gdb_stdout, '"');
	    fputs_filtered ("\"", gdb_stdout);
	  }
	  break;
	case var_string_noescape:
	case var_filename:
	case var_enum:
d1376 3
a1378 2
	  if (*(char **) c->var)
	    fputs_filtered (*(char **) c->var, gdb_stdout);
d1380 16
a1396 24
	case var_boolean:
	  fputs_filtered (*(int *) c->var ? "on" : "off", gdb_stdout);
	  break;
	case var_uinteger:
	  if (*(unsigned int *) c->var == UINT_MAX)
	    {
	      fputs_filtered ("unlimited", gdb_stdout);
	      break;
	    }
	  /* else fall through */
	case var_zinteger:
	  fprintf_filtered (gdb_stdout, "%u", *(unsigned int *) c->var);
	  break;
	case var_integer:
	  if (*(int *) c->var == INT_MAX)
	    {
	      fputs_filtered ("unlimited", gdb_stdout);
	    }
	  else
	    fprintf_filtered (gdb_stdout, "%d", *(int *) c->var);
	  break;

	default:
	  error ("gdb internal error: bad var_type in do_setshow_command");
d1398 16
d1429 13
a1441 14
  for (; list != NULL; list = list->next)
    {
      /* If we find a prefix, run its list, prefixing our output by its
         prefix (with "show " skipped).  */
      if (list->prefixlist && !list->abbrev_flag)
	cmd_show_list (*list->prefixlist, from_tty, list->prefixname + 5);
      if (list->type == show_cmd)
	{
	  fputs_filtered (prefix, gdb_stdout);
	  fputs_filtered (list->name, gdb_stdout);
	  fputs_filtered (":  ", gdb_stdout);
	  do_setshow_command ((char *) NULL, from_tty, list);
	}
    }
d1467 1
a1467 1
  if ((pid = fork ()) == 0)
d1499 1
a1499 1
      p = xmalloc (sizeof ("make ") + strlen (arg));
d1501 1
a1501 1
      strcpy (p + sizeof ("make ") - 1, arg);
d1503 1
a1503 1

d1563 1
a1563 1
    add_com_alias ("!", "shell", class_support, 0);
d1566 2
a1567 2
       "Run the ``make'' program using the rest of the line as arguments.");
  add_cmd ("user", no_class, show_user,
@


1.1.1.5
log
@import gdb-1999-07-12 snapshot
@
text
@d1379 2
a1380 1
	      fputstr_filtered (*(unsigned char **) c->var, '"', gdb_stdout);
@


1.1.1.6
log
@import gdb-1999-08-09 snapshot
@
text
@a1420 2
  if (c->type == set_cmd && set_hook)
    set_hook (c);
@


1.1.1.7
log
@import gdb-1999-08-23 snapshot
@
text
@a38 5
/* FIXME: this should be auto-configured!  */
#ifdef __MSDOS__
# define CANT_FORK
#endif

d1456 3
a1458 23
  /* If ARG is NULL, they want an inferior shell, but `system' just
     reports if the shell is available when passed a NULL arg.  */
  int rc = system (arg ? arg : "");

  if (!arg)
    arg = "inferior shell";

  if (rc == -1)
    {
      fprintf_unfiltered (gdb_stderr, "Cannot execute %s: %s\n", arg,
			  safe_strerror (errno));
      gdb_flush (gdb_stderr);
    }
  else if (rc)
    {
      fprintf_unfiltered (gdb_stderr, "%s exited with status %d\n", arg, rc);
      gdb_flush (gdb_stderr);
    }
#ifdef __DJGPP__
  /* Make sure to return to the directory GDB thinks it is, in case the
     shell command we just ran changed it.  */
  chdir (current_directory);
#endif
@


1.1.1.8
log
@import gdb-1999-08-30 snapshot
@
text
@d25 3
@


1.1.1.9
log
@import gdb-1999-09-08 snapshot
@
text
@d1377 2
@


1.1.1.10
log
@import gdb-1999-10-04 snapshot
@
text
@d26 4
a29 1
#if HAVE_SYS_WAIT_H
d31 1
a31 2
#elif HAVE_WAIT_H
#include <wait.h>
@


1.1.1.11
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright 1986, 1989, 1990, 1991, 1998, 2000 Free Software Foundation, Inc.
d45 1
a45 1
static void show_user_1 (struct cmd_list_element *, struct ui_file *);
d53 1
a53 1
static void print_doc_line (struct ui_file *, char *);
d391 1
a391 1
     struct ui_file *stream;
d456 1
a456 1
     struct ui_file *stream;
d497 1
a497 1
     struct ui_file *stream;
d548 1
a548 1
     struct ui_file *stream;
d1533 1
a1533 1
     struct ui_file *stream;
@


1.1.1.12
log
@import gdb-2000-02-02 snapshot
@
text
@a24 3
#ifdef UI_OUT
#include "ui-out.h"
#endif
a522 3
#ifdef UI_OUT
  ui_out_text (uiout, line_buffer);
#else
a523 1
#endif
a1365 9
#ifdef UI_OUT
      struct cleanup *old_chain;
      struct ui_stream *stb;
      int quote;

      stb = ui_out_stream_new (uiout);
      old_chain = make_cleanup ((make_cleanup_func) ui_out_stream_delete, stb);
#endif /* UI_OUT */

a1368 55
#ifdef UI_OUT
      ui_out_text (uiout, " is ");
      ui_out_wrap_hint (uiout, "    ");
      quote = 0;
      switch (c->var_type)
	{
	case var_string:
	  {
	    unsigned char *p;

	    if (*(unsigned char **) c->var)
	      fputstr_filtered (*(unsigned char **) c->var, '"', stb->stream);
	    quote = 1;
	  }
	  break;
	case var_string_noescape:
	case var_filename:
	case var_enum:
	  if (*(char **) c->var)
	    fputs_filtered (*(char **) c->var, stb->stream);
	  quote = 1;
	  break;
	case var_boolean:
	  fputs_filtered (*(int *) c->var ? "on" : "off", stb->stream);
	  break;
	case var_uinteger:
	  if (*(unsigned int *) c->var == UINT_MAX)
	    {
	      fputs_filtered ("unlimited", stb->stream);
	      break;
	    }
	  /* else fall through */
	case var_zinteger:
	  fprintf_filtered (stb->stream, "%u", *(unsigned int *) c->var);
	  break;
	case var_integer:
	  if (*(int *) c->var == INT_MAX)
	    {
	      fputs_filtered ("unlimited", stb->stream);
	    }
	  else
	    fprintf_filtered (stb->stream, "%d", *(int *) c->var);
	  break;

	default:
	  error ("gdb internal error: bad var_type in do_setshow_command");
	}
      if (quote)
	ui_out_text (uiout, "\"");
      ui_out_field_stream (uiout, "value", stb);
      if (quote)
	ui_out_text (uiout, "\"");
      ui_out_text (uiout, ".\n");
      do_cleanups (old_chain);
#else
a1414 1
#endif
a1430 3
#ifdef UI_OUT
  ui_out_list_begin (uiout, "showlist");
#endif
a1434 18
#ifdef UI_OUT
      if (list->prefixlist && !list->abbrev_flag)
	{
	  ui_out_list_begin (uiout, "optionlist");
	  ui_out_field_string (uiout, "prefix", list->prefixname + 5);
	  cmd_show_list (*list->prefixlist, from_tty, list->prefixname + 5);
	  ui_out_list_end (uiout);
	}
      if (list->type == show_cmd)
	{
	  ui_out_list_begin (uiout, "option");
	  ui_out_text (uiout, prefix);
	  ui_out_field_string (uiout, "name", list->name);
	  ui_out_text (uiout, ":  ");
	  do_setshow_command ((char *) NULL, from_tty, list);
	  ui_out_list_end (uiout);
	}
#else
a1443 1
#endif
a1444 3
#ifdef UI_OUT
  ui_out_list_end (uiout);
#endif
a1543 4
#ifdef UI_OUT
  print_command_lines (uiout, cmdlines, 1);
  fputs_filtered ("\n", stream);
#else
a1549 1
#endif
@


