head	1.24;
access;
symbols
	gdb_6_3-20041109-release:1.23
	gdb_6_3-branch:1.23.0.2
	gdb_6_3-20041019-branchpoint:1.23
	drow_intercu-merge-20040921:1.22
	drow_intercu-merge-20040915:1.22
	jimb-gdb_6_2-e500-branch:1.20.0.6
	jimb-gdb_6_2-e500-branchpoint:1.20
	gdb_6_2-20040730-release:1.20
	gdb_6_2-branch:1.20.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.20
	gdb_6_1_1-20040616-release:1.18
	gdb_6_1-2004-04-05-release:1.18
	drow_intercu-merge-20040402:1.18
	drow_intercu-merge-20040327:1.18
	ezannoni_pie-20040323-branch:1.18.0.12
	ezannoni_pie-20040323-branchpoint:1.18
	cagney_tramp-20040321-mergepoint:1.18
	cagney_tramp-20040309-branch:1.18.0.10
	cagney_tramp-20040309-branchpoint:1.18
	gdb_6_1-branch:1.18.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.18
	drow_intercu-20040221-branch:1.18.0.6
	drow_intercu-20040221-branchpoint:1.18
	cagney_bfdfile-20040213-branch:1.18.0.4
	cagney_bfdfile-20040213-branchpoint:1.18
	drow-cplus-merge-20040208:1.18
	carlton_dictionary-20040126-merge:1.18
	cagney_bigcore-20040122-branch:1.18.0.2
	cagney_bigcore-20040122-branchpoint:1.18
	drow-cplus-merge-20040113:1.18
	drow-cplus-merge-20031224:1.18
	drow-cplus-merge-20031220:1.18
	carlton_dictionary-20031215-merge:1.18
	drow-cplus-merge-20031214:1.18
	carlton-dictionary-20031111-merge:1.18
	gdb_6_0-2003-10-04-release:1.15
	kettenis_sparc-20030918-branch:1.16.0.2
	kettenis_sparc-20030918-branchpoint:1.16
	carlton_dictionary-20030917-merge:1.16
	ezannoni_pie-20030916-branchpoint:1.15
	ezannoni_pie-20030916-branch:1.15.0.36
	cagney_x86i386-20030821-branch:1.15.0.34
	cagney_x86i386-20030821-branchpoint:1.15
	carlton_dictionary-20030805-merge:1.15
	carlton_dictionary-20030627-merge:1.15
	gdb_6_0-branch:1.15.0.32
	gdb_6_0-2003-06-23-branchpoint:1.15
	jimb-ppc64-linux-20030613-branch:1.15.0.30
	jimb-ppc64-linux-20030613-branchpoint:1.15
	cagney_convert-20030606-branch:1.15.0.28
	cagney_convert-20030606-branchpoint:1.15
	cagney_writestrings-20030508-branch:1.15.0.26
	cagney_writestrings-20030508-branchpoint:1.15
	jimb-ppc64-linux-20030528-branch:1.15.0.24
	jimb-ppc64-linux-20030528-branchpoint:1.15
	carlton_dictionary-20030523-merge:1.15
	cagney_fileio-20030521-branch:1.15.0.22
	cagney_fileio-20030521-branchpoint:1.15
	kettenis_i386newframe-20030517-mergepoint:1.15
	jimb-ppc64-linux-20030509-branch:1.15.0.20
	jimb-ppc64-linux-20030509-branchpoint:1.15
	kettenis_i386newframe-20030504-mergepoint:1.15
	carlton_dictionary-20030430-merge:1.15
	kettenis_i386newframe-20030419-branch:1.15.0.18
	kettenis_i386newframe-20030419-branchpoint:1.15
	carlton_dictionary-20030416-merge:1.15
	cagney_frameaddr-20030409-mergepoint:1.15
	kettenis_i386newframe-20030406-branch:1.15.0.16
	kettenis_i386newframe-20030406-branchpoint:1.15
	cagney_frameaddr-20030403-branchpoint:1.15
	cagney_frameaddr-20030403-branch:1.15.0.14
	cagney_framebase-20030330-mergepoint:1.15
	cagney_framebase-20030326-branch:1.15.0.12
	cagney_framebase-20030326-branchpoint:1.15
	cagney_lazyid-20030317-branch:1.15.0.10
	cagney_lazyid-20030317-branchpoint:1.15
	kettenis-i386newframe-20030316-mergepoint:1.15
	offbyone-20030313-branch:1.15.0.8
	offbyone-20030313-branchpoint:1.15
	kettenis-i386newframe-20030308-branch:1.15.0.6
	kettenis-i386newframe-20030308-branchpoint:1.15
	carlton_dictionary-20030305-merge:1.15
	cagney_offbyone-20030303-branch:1.15.0.4
	cagney_offbyone-20030303-branchpoint:1.15
	carlton_dictionary-20030207-merge:1.15
	interps-20030203-mergepoint:1.15
	interps-20030202-branch:1.15.0.2
	interps-20030202-branchpoint:1.15
	cagney-unwind-20030108-branch:1.14.0.2
	cagney-unwind-20030108-branchpoint:1.14
	carlton_dictionary-20021223-merge:1.14
	gdb_5_3-2002-12-12-release:1.11
	carlton_dictionary-20021115-merge:1.14
	kseitz_interps-20021105-merge:1.12
	kseitz_interps-20021103-merge:1.12
	drow-cplus-merge-20021020:1.12
	drow-cplus-merge-20021025:1.12
	carlton_dictionary-20021025-merge:1.12
	carlton_dictionary-20021011-merge:1.12
	drow-cplus-branch:1.12.0.2
	drow-cplus-branchpoint:1.12
	kseitz_interps-20020930-merge:1.11
	carlton_dictionary-20020927-merge:1.11
	carlton_dictionary-branch:1.11.0.24
	carlton_dictionary-20020920-branchpoint:1.11
	gdb_5_3-branch:1.11.0.22
	gdb_5_3-2002-09-04-branchpoint:1.11
	kseitz_interps-20020829-merge:1.11
	cagney_sysregs-20020825-branch:1.11.0.20
	cagney_sysregs-20020825-branchpoint:1.11
	readline_4_3-import-branch:1.11.0.18
	readline_4_3-import-branchpoint:1.11
	gdb_5_2_1-2002-07-23-release:1.11
	kseitz_interps-20020528-branch:1.11.0.16
	kseitz_interps-20020528-branchpoint:1.11
	cagney_regbuf-20020515-branch:1.11.0.14
	cagney_regbuf-20020515-branchpoint:1.11
	jimb-macro-020506-branch:1.11.0.12
	jimb-macro-020506-branchpoint:1.11
	gdb_5_2-2002-04-29-release:1.11
	gdb_5_2-branch:1.11.0.10
	gdb_5_2-2002-03-03-branchpoint:1.11
	gdb_5_1_1-2002-01-24-release:1.11
	gdb_5_1_0_1-2002-01-03-release:1.11
	cygnus_cvs_20020108_pre:1.11
	gdb_5_1_0_1-2002-01-03-branchpoint:1.11
	gdb_5_1_0_1-2002-01-03-branch:1.11.0.8
	gdb_5_1-2001-11-21-release:1.11
	gdb_s390-2001-09-26-branch:1.11.0.6
	gdb_s390-2001-09-26-branchpoint:1.11
	gdb_5_1-2001-07-29-branch:1.11.0.4
	gdb_5_1-2001-07-29-branchpoint:1.11
	dberlin-typesystem-branch:1.11.0.2
	dberlin-typesystem-branchpoint:1.11
	gdb-post-ptid_t-2001-05-03:1.11
	gdb-pre-ptid_t-2001-05-03:1.10
	insight-precleanup-2001-01-01:1.6
	gdb-post-protoization-2000-07-29:1.5
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.24
date	2004.11.14.00.10.53;	author cagney;	state dead;
branches;
next	1.23;

1.23
date	2004.10.08.20.29.56;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2004.08.03.00.57.27;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.22.01.31.49;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.25.19.46.08;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.24.21.51.49;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.02.20.28.30;	author cagney;	state Exp;
branches
	1.18.6.1;
next	1.17;

1.17
date	2003.09.21.01.26.45;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.17.14.24.31;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.18.15.55.53;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.14.20.37.29;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.12.21.43.55;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2002.10.02.21.33.58;	author ezannoni;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.05.04.04.15.28;	author kevinb;	state Exp;
branches
	1.11.16.1
	1.11.24.1;
next	1.10;

1.10
date	2001.04.14.19.23.02;	author jtc;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.06.08.21.18;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.01.01.39.22;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.27.00.43.26;	author fnasser;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.06.04.53.14;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.16.02.11.36;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.33;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.06.08.02.17.59;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.06.08.02.17.59;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.11.00;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.02.00.21.07;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.02.07.00.19.35;	author jsm;	state Exp;
branches;
next	;

1.11.16.1
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.11.24.1
date	2002.10.11.22.22.56;	author carlton;	state Exp;
branches;
next	1.11.24.2;

1.11.24.2
date	2002.11.15.19.19.00;	author carlton;	state Exp;
branches;
next	1.11.24.3;

1.11.24.3
date	2003.02.07.19.17.54;	author carlton;	state Exp;
branches;
next	1.11.24.4;

1.11.24.4
date	2003.09.17.21.28.35;	author carlton;	state Exp;
branches;
next	1.11.24.5;

1.11.24.5
date	2003.11.11.23.50.58;	author carlton;	state Exp;
branches;
next	;

1.12.2.1
date	2003.12.14.20.27.33;	author drow;	state Exp;
branches;
next	;

1.18.6.1
date	2004.09.16.17.01.26;	author drow;	state Exp;
branches;
next	;


desc
@@


1.24
log
@2004-11-13  Andrew Cagney  <cagney@@gnu.org>

	* NEWS: List h8300*-*-*, mcore-*-*, mn10300-*-*, ns32k-*-*, and
	v850-*-* under removed.
	* configure.host: Delete ns32k-*-netbsd*.
	* configure.tgt: Delete h8300-*-*, mcore*-*-*, mn10300-*-*,
	ns32k-*-netbsd*, and v850*-*-*.
	* MAINTAINERS: Mark h8300, mcore, mn10300, ns32k, v850 as
	"Deleted"
	* config/h8300/tm-h8300.h, config/h8300/h8300.mt: Delete.
	* h8300-tdep.c, config/mcore/mcore.mt, mcore-rom.c: Delete.
	* mcore-tdep.c, config/mn10300/mn10300.mt: Delete.
	* mn10300-tdep.c, config/ns32k/nbsdaout.mh: Delete.
	* config/ns32k/nbsdaout.mt, config/ns32k/nm-nbsd.h: Delete.
	* config/ns32k/nm-nbsdaout.h, config/ns32k/tm-ns32k.h: Delete.
	* ns32knbsd-nat.c, ns32knbsd-tdep.c, ns32k-tdep.c: Delete.
	* ns32k-tdep.h, config/v850/v850.mt, v850ice.c: Delete.
	* v850-tdep.c: Delete.
@
text
@/* ICE interface for the NEC V850 for GDB, the GNU debugger.
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "gdb_string.h"
#include "frame.h"
#include "symtab.h"
#include "inferior.h"
#include "breakpoint.h"
#include "symfile.h"
#include "target.h"
#include "objfiles.h"
#include "gdbcore.h"
#include "value.h"
#include "command.h"
#include "regcache.h"

#include <tcl.h>
#include <windows.h>
#include <winuser.h>		/* for WM_USER */

extern unsigned long int strtoul (const char *nptr, char **endptr,
				  int base);

/* Local data definitions */
struct MessageIO
  {
    int size;			/* length of input or output in bytes         */
    char *buf;			/* buffer having the input/output information */
  };

/* Prototypes for functions located in other files */
extern void break_command (char *, int);

/* Prototypes for local functions */
static int init_hidden_window (void);

static LRESULT CALLBACK v850ice_wndproc (HWND, UINT, WPARAM, LPARAM);

static void v850ice_files_info (struct target_ops *ignore);

static int v850ice_xfer_memory (CORE_ADDR memaddr, char *myaddr,
				int len, int should_write,
				struct target_ops *target);

static void v850ice_prepare_to_store (void);

static void v850ice_fetch_registers (int regno);

static void v850ice_resume (ptid_t ptid, int step,
                            enum target_signal siggnal);

static void v850ice_open (char *name, int from_tty);

static void v850ice_close (int quitting);

static void v850ice_stop (void);

static void v850ice_store_registers (int regno);

static void v850ice_mourn (void);

static ptid_t v850ice_wait (ptid_t ptid,
                                  struct target_waitstatus *status);

static void v850ice_kill (void);

static void v850ice_detach (char *args, int from_tty);

static int v850ice_insert_breakpoint (CORE_ADDR, char *);

static int v850ice_remove_breakpoint (CORE_ADDR, char *);

static void v850ice_command (char *, int);

static int ice_disassemble (unsigned long, int, char *);

static int ice_lookup_addr (unsigned long *, char *, char *);

static int ice_lookup_symbol (unsigned long, char *);

static void ice_SimulateDisassemble (char *, int);

static void ice_SimulateAddrLookup (char *, int);

static void ice_Simulate_SymLookup (char *, int);

static void ice_fputs (const char *, struct ui_file *);

static int ice_file (char *);

static int ice_cont (char *);

static int ice_stepi (char *);

static int ice_nexti (char *);

static void togdb_force_update (void);

static void view_source (CORE_ADDR);

static void do_gdb (char *, char *, void (*func) (char *, int), int);


/* Globals */
static HWND hidden_hwnd;	/* HWND for messages */

long (__stdcall * ExeAppReq) (char *, long, char *, struct MessageIO *);

long (__stdcall * RegisterClient) (HWND);

long (__stdcall * UnregisterClient) (void);

extern Tcl_Interp *gdbtk_interp;

/* Globals local to this file only */
static int ice_open = 0;	/* Is ICE open? */

static char *v850_CB_Result;	/* special char array for saving 'callback' results */

static int SimulateCallback;	/* simulate a callback event */

#define MAX_BLOCK_SIZE    64*1024	/* Cannot transfer memory in blocks bigger
					   than this */
/* MDI/ICE Message IDs */
#define GSINGLESTEP     0x200	/* single-step target          */
#define GRESUME         0x201	/* resume target               */
#define GREADREG        0x202	/* read a register             */
#define GWRITEREG       0x203	/* write a register            */
#define GWRITEBLOCK     0x204	/* write a block of memory     */
#define GREADBLOCK      0x205	/* read a block of memory      */
#define GSETBREAK       0x206	/* set a breakpoint            */
#define GREMOVEBREAK    0x207	/* remove a breakpoint         */
#define GHALT           0x208	/* ??? */
#define GCHECKSTATUS    0x209	/* check status of ICE         */
#define GMDIREPLY       0x210	/* Reply for previous query - NOT USED */
#define GDOWNLOAD       0x211	/* something for MDI           */
#define GCOMMAND        0x212	/* execute command in ice      */
#define GLOADFILENAME   0x213	/* retrieve load filename      */
#define GWRITEMEM       0x214	/* write word, half-word, or byte */

/* GCHECKSTATUS return codes: */
#define ICE_Idle        0x00
#define ICE_Breakpoint  0x01	/* hit a breakpoint */
#define ICE_Stepped     0x02	/* have stepped     */
#define ICE_Exception   0x03	/* have exception   */
#define ICE_Halted      0x04	/* hit a user halt  */
#define ICE_Exited      0x05	/* called exit      */
#define ICE_Terminated  0x06	/* user terminated  */
#define ICE_Running     0x07
#define ICE_Unknown     0x99

/* Windows messages */
#define WM_STATE_CHANGE WM_USER+101
#define WM_SYM_TO_ADDR  WM_USER+102
#define WM_ADDR_TO_SYM  WM_USER+103
#define WM_DISASSEMBLY  WM_USER+104
#define WM_SOURCE       WM_USER+105

/* STATE_CHANGE codes */
#define STATE_CHANGE_REGS   1	/* Register(s) changed */
#define STATE_CHANGE_LOAD   2	/* HW reset            */
#define STATE_CHANGE_RESET  3	/* Load new file       */
#define STATE_CHANGE_CONT   4	/* Run target          */
#define STATE_CHANGE_STOP   5	/* Stop target         */
#define STATE_CHANGE_STEPI  6	/* Stepi target        */
#define STATE_CHANGE_NEXTI  7	/* Nexti target        */

static struct target_ops v850ice_ops;	/* Forward decl */

/* This function creates a hidden window */
static int
init_hidden_window (void)
{
  WNDCLASS class;

  if (hidden_hwnd != NULL)
    return 1;

  class.style = 0;
  class.cbClsExtra = 0;
  class.cbWndExtra = 0;
  class.hInstance = GetModuleHandle (0);
  class.hbrBackground = NULL;
  class.lpszMenuName = NULL;
  class.lpszClassName = "gdb_v850ice";
  class.lpfnWndProc = v850ice_wndproc;
  class.hIcon = NULL;
  class.hCursor = NULL;

  if (!RegisterClass (&class))
    return 0;

  hidden_hwnd = CreateWindow ("gdb_v850ice", "gdb_v850ice", WS_TILED,
			      0, 0, 0, 0, NULL, NULL, class.hInstance,
			      NULL);
  if (hidden_hwnd == NULL)
    {
      char buf[200];
      DWORD err;

      err = GetLastError ();
      FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM, NULL, err,
		     0, buf, 200, NULL);
      printf_unfiltered ("Could not create window: %s", buf);
      return 0;
    }

  return 1;
}

/* 
   This function is installed as the message handler for the hidden window
   which QBox will use to communicate with gdb. It recognize and acts
   on the following messages:

   WM_SYM_TO_ADDR  \
   WM_ADDR_TO_SYM   | Not implemented at NEC's request
   WM_DISASSEMBLY  /
   WM_STATE_CHANGE - tells us that a state change has occured in the ICE
 */
static LRESULT CALLBACK
v850ice_wndproc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  LRESULT result = FALSE;

  switch (message)
    {
    case WM_SYM_TO_ADDR:
      MessageBox (0, "Symbol resolution\nNot implemented", "GDB", MB_OK);
      break;
    case WM_ADDR_TO_SYM:
      MessageBox (0, "Address resolution\nNot implemented", "GDB", MB_OK);
      break;
    case WM_SOURCE:
      view_source ((CORE_ADDR) lParam);
      break;
    case WM_STATE_CHANGE:
      switch (wParam)
	{
	case STATE_CHANGE_LOAD:
	  {
	    struct MessageIO iob;
	    char buf[128];

	    iob.buf = buf;
	    iob.size = 128;

	    /* Load in a new file... Need filename */
	    ExeAppReq ("GDB", GLOADFILENAME, NULL, &iob);
	    if (!catch_errors ((catch_errors_ftype *) ice_file, iob.buf, "", RETURN_MASK_ALL))
	      printf_unfiltered ("load errored\n");
	  }
	  break;
	case STATE_CHANGE_RESET:
	  registers_changed ();
	  flush_cached_frames ();
	  togdb_force_update ();
	  result = TRUE;
	  break;
	case STATE_CHANGE_REGS:
	  registers_changed ();
	  togdb_force_update ();
	  result = TRUE;
	  break;
	case STATE_CHANGE_CONT:
	  if (!catch_errors ((catch_errors_ftype *) ice_cont, NULL, "", RETURN_MASK_ALL))
	    printf_unfiltered ("continue errored\n");
	  result = TRUE;
	  break;
	case STATE_CHANGE_STEPI:
	  if (!catch_errors ((catch_errors_ftype *) ice_stepi, (int) lParam, "",
			     RETURN_MASK_ALL))
	    printf_unfiltered ("stepi errored\n");
	  result = TRUE;
	  break;
	case STATE_CHANGE_NEXTI:
	  if (!catch_errors ((catch_errors_ftype *) ice_nexti, (int) lParam, "",
			     RETURN_MASK_ALL))
	    printf_unfiltered ("nexti errored\n");
	  result = TRUE;
	  break;
	}
    }

  if (result == FALSE)
    return DefWindowProc (hwnd, message, wParam, lParam);

  return FALSE;
}

/* Code for opening a connection to the ICE.  */

static void
v850ice_open (char *name, int from_tty)
{
  HINSTANCE handle;

  if (name)
    error ("Too many arguments.");

  target_preopen (from_tty);

  unpush_target (&v850ice_ops);

  if (from_tty)
    puts_filtered ("V850ice debugging\n");

  push_target (&v850ice_ops);	/* Switch to using v850ice target now */

  target_terminal_init ();

  /* Initialize everything necessary to facilitate communication
     between QBox, gdb, and the DLLs which control the ICE */
  if (ExeAppReq == NULL)
    {
      handle = LoadLibrary ("necmsg.dll");
      if (handle == NULL)
	error ("Cannot load necmsg.dll");

      ExeAppReq = (long (*) (char *, long, char *, struct MessageIO *))
	GetProcAddress (handle, "ExeAppReq");
      RegisterClient = (long (*) (HWND))
	GetProcAddress (handle, "RegisterClient");
      UnregisterClient = (long (*) (void))
	GetProcAddress (handle, "UnregisterClient");

      if (ExeAppReq == NULL || RegisterClient == NULL || UnregisterClient == NULL)
	error ("Could not find requisite functions in necmsg.dll.");

      if (!init_hidden_window ())
	error ("could not initialize message handling");
    }

  /* Tell the DLL we are here */
  RegisterClient (hidden_hwnd);

  ice_open = 1;

  /* Without this, some commands which require an active target (such as kill)
     won't work.  This variable serves (at least) double duty as both the pid
     of the target process (if it has such), and as a flag indicating that a
     target is active.  These functions should be split out into seperate
     variables, especially since GDB will someday have a notion of debugging
     several processes.  */
  inferior_ptid = pid_to_ptid (42000);

  start_remote ();
  return;
}

/* Clean up connection to a remote debugger.  */

static void
v850ice_close (int quitting)
{
  if (ice_open)
    {
      UnregisterClient ();
      ice_open = 0;
      inferior_ptid = null_ptid;
    }
}

/* Stop the process on the ice. */
static void
v850ice_stop (void)
{
  /* This is silly, but it works... */
  v850ice_command ("stop", 0);
}

static void
v850ice_detach (char *args, int from_tty)
{
  if (args)
    error ("Argument given to \"detach\" when remotely debugging.");

  pop_target ();
  if (from_tty)
    puts_filtered ("Ending v850ice debugging.\n");
}

/* Tell the remote machine to resume.  */

static void
v850ice_resume (ptid_t ptid, int step, enum target_signal siggnal)
{
  long retval;
  char buf[256];
  struct MessageIO iob;

  iob.size = 0;
  iob.buf = buf;

  if (step)
    retval = ExeAppReq ("GDB", GSINGLESTEP, "step", &iob);
  else
    retval = ExeAppReq ("GDB", GRESUME, "run", &iob);

  if (retval)
    error ("ExeAppReq (step = %d) returned %d", step, retval);
}

/* Wait until the remote machine stops, then return,
   storing status in STATUS just as `wait' would.
   Returns "pid" (though it's not clear what, if anything, that
   means in the case of this target).  */

static ptid_t
v850ice_wait (ptid_t ptid, struct target_waitstatus *status)
{
  long v850_status;
  char buf[256];
  struct MessageIO iob;
  int done = 0;
  int count = 0;

  iob.size = 0;
  iob.buf = buf;

  do
    {
      if (count++ % 100000)
	{
	  deprecated_ui_loop_hook (0);
	  count = 0;
	}

      v850_status = ExeAppReq ("GDB", GCHECKSTATUS, NULL, &iob);

      switch (v850_status)
	{
	case ICE_Idle:
	case ICE_Breakpoint:
	case ICE_Stepped:
	case ICE_Halted:
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_TRAP;
	  done = 1;
	  break;
	case ICE_Exception:
	  status->kind = TARGET_WAITKIND_SIGNALLED;
	  status->value.sig = TARGET_SIGNAL_SEGV;
	  done = 1;
	  break;
	case ICE_Exited:
	  status->kind = TARGET_WAITKIND_EXITED;
	  status->value.integer = 0;
	  done = 1;
	  break;
	case ICE_Terminated:
	  status->kind = TARGET_WAITKIND_SIGNALLED;
	  status->value.sig = TARGET_SIGNAL_KILL;
	  done = 1;
	  break;
	default:
	  break;
	}
    }
  while (!done);

  return inferior_ptid;
}

static int
convert_register (int regno, char *buf)
{
  if (regno <= 31)
    sprintf (buf, "r%d", regno);
  else if (REGISTER_NAME (regno)[0] == 's'
	   && REGISTER_NAME (regno)[1] == 'r')
    return 0;
  else
    sprintf (buf, "%s", REGISTER_NAME (regno));

  return 1;
}

/* Read the remote registers into the block REGS.  */
/* Note that the ICE returns register contents as ascii hex strings.  We have
   to convert that to an unsigned long, and then call store_unsigned_integer to
   convert it to target byte-order if necessary.  */

static void
v850ice_fetch_registers (int regno)
{
  long retval;
  char cmd[100];
  char val[100];
  struct MessageIO iob;
  unsigned long regval;
  char *p;

  if (regno == -1)
    {
      for (regno = 0; regno < NUM_REGS; regno++)
	v850ice_fetch_registers (regno);
      return;
    }

  strcpy (cmd, "reg ");
  if (!convert_register (regno, &cmd[4]))
    return;

  iob.size = sizeof val;
  iob.buf = val;
  retval = ExeAppReq ("GDB", GREADREG, cmd, &iob);
  if (retval)
    error ("1: ExeAppReq returned %d: cmd = %s", retval, cmd);

  regval = strtoul (val, NULL, 16);
  if (regval == 0 && p == val)
    error ("v850ice_fetch_registers (%d):  bad value from ICE: %s.",
	   regno, val);

  store_unsigned_integer (val, register_size (current_gdbarch, regno), regval);
  regcache_raw_supply (current_regcache, regno, val);
}

/* Store register REGNO, or all registers if REGNO == -1, from the contents
   of REGISTERS.  */

static void
v850ice_store_registers (int regno)
{
  long retval;
  char cmd[100];
  unsigned long regval;
  char buf[256];
  struct MessageIO iob;
  iob.size = 0;
  iob.buf = buf;

  if (regno == -1)
    {
      for (regno = 0; regno < NUM_REGS; regno++)
	v850ice_store_registers (regno);
      return;
    }

  regval = extract_unsigned_integer (&deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],
				     register_size (current_gdbarch, regno));
  strcpy (cmd, "reg ");
  if (!convert_register (regno, &cmd[4]))
    return;
  sprintf (cmd + strlen (cmd), "=0x%x", regval);

  retval = ExeAppReq ("GDB", GWRITEREG, cmd, &iob);
  if (retval)
    error ("2: ExeAppReq returned %d: cmd = %s", retval, cmd);
}

/* Prepare to store registers.  Nothing to do here, since the ICE can write one
   register at a time.  */

static void
v850ice_prepare_to_store (void)
{
}

/* Read or write LEN bytes from inferior memory at MEMADDR, transferring
   to or from debugger address MYADDR.  Write to inferior if SHOULD_WRITE is
   nonzero.  TARGET is unused.  Returns length of data written or read;
   0 for error.

   We can only read/write MAX_BLOCK_SIZE bytes at a time, though, or the DLL
   dies.  */
static int
v850ice_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
		     int should_write, struct target_ops *target)
{
  long retval;
  char cmd[100];
  struct MessageIO iob;
  int sent;

  if (should_write)
    {
      if (len == 4 || len == 2 || len == 1)
	{
	  long value = 0;
	  char buf[256];
	  char c;

	  iob.size = 0;
	  iob.buf = buf;

	  sent = 0;
	  switch (len)
	    {
	    case 4:
	      c = 'w';
	      value |= (long) ((myaddr[3] << 24) & 0xff000000);
	      value |= (long) ((myaddr[2] << 16) & 0x00ff0000);
	      value |= (long) ((myaddr[1] << 8) & 0x0000ff00);
	      value |= (long) (myaddr[0] & 0x000000ff);
	      break;
	    case 2:
	      c = 'h';
	      value |= (long) ((myaddr[1] << 8) & 0xff00);
	      value |= (long) (myaddr[0] & 0x00ff);
	      break;
	    case 1:
	      c = 'b';
	      value |= (long) (myaddr[0] & 0xff);
	      break;
	    }

	  sprintf (cmd, "memory %c c 0x%x=0x%x", c, (int) memaddr, value);
	  retval = ExeAppReq ("GDB", GWRITEMEM, cmd, &iob);
	  if (retval == 0)
	    sent = len;
	}
      else
	{
	  sent = 0;
	  do
	    {
	      iob.size = len > MAX_BLOCK_SIZE ? MAX_BLOCK_SIZE : len;
	      iob.buf = myaddr;
	      sprintf (cmd, "memory b c 0x%x=0x00 l=%d", (int) memaddr, iob.size);
	      retval = ExeAppReq ("GDB", GWRITEBLOCK, cmd, &iob);
	      if (retval != 0)
		break;
	      len -= iob.size;
	      memaddr += iob.size;
	      myaddr += iob.size;
	      sent += iob.size;
	    }
	  while (len > 0);
	}
    }
  else
    {
      unsigned char *tmp;
      unsigned char *t;
      int i;

      tmp = alloca (len + 100);
      t = tmp;
      memset (tmp + len, 0xff, 100);

      sent = 0;
      do
	{
	  iob.size = len > MAX_BLOCK_SIZE ? MAX_BLOCK_SIZE : len;
	  iob.buf = tmp;
	  sprintf (cmd, "memory b 0x%x l=%d", (int) memaddr, iob.size);
	  retval = ExeAppReq ("GDB", GREADBLOCK, cmd, &iob);
	  if (retval != 0)
	    break;
	  len -= iob.size;
	  memaddr += iob.size;
	  sent += iob.size;
	  tmp += iob.size;
	}
      while (len > 0);

      if (retval == 0)
	{
	  for (i = 0; i < 100; i++)
	    {
	      if (t[sent + i] != 0xff)
		{
		  warning ("GREADBLOCK trashed bytes after transfer area.");
		  break;
		}
	    }
	  memcpy (myaddr, t, sent);
	}
    }

  if (retval != 0)
    error ("3: ExeAppReq returned %d: cmd = %s", retval, cmd);

  return sent;
}

static void
v850ice_files_info (struct target_ops *ignore)
{
  puts_filtered ("Debugging a target via the NEC V850 ICE.\n");
}

static int
v850ice_insert_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  long retval;
  char cmd[100];
  char buf[256];
  struct MessageIO iob;

  iob.size = 0;
  iob.buf = buf;
  sprintf (cmd, "%d, ", addr);

  retval = ExeAppReq ("GDB", GSETBREAK, cmd, &iob);
  if (retval)
    error ("ExeAppReq (GSETBREAK) returned %d: cmd = %s", retval, cmd);

  return 0;
}

static int
v850ice_remove_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  long retval;
  char cmd[100];
  char buf[256];
  struct MessageIO iob;

  iob.size = 0;
  iob.buf = buf;

  sprintf (cmd, "%d, ", addr);

  retval = ExeAppReq ("GDB", GREMOVEBREAK, cmd, &iob);
  if (retval)
    error ("ExeAppReq (GREMOVEBREAK) returned %d: cmd = %s", retval, cmd);

  return 0;
}

static void
v850ice_kill (void)
{
  target_mourn_inferior ();
  inferior_ptid = null_ptid;
}

static void
v850ice_mourn (void)
{
}

static void
v850ice_load (char *filename, int from_tty)
{
  struct MessageIO iob;
  char buf[256];

  iob.size = 0;
  iob.buf = buf;
  generic_load (filename, from_tty);
  ExeAppReq ("GDB", GDOWNLOAD, filename, &iob);
}

static int
ice_file (char *arg)
{
  char *s;

  target_detach (NULL, 0);
  pop_target ();

  printf_unfiltered ("\n");

  s = arg;
  while (*s != '\0')
    {
      if (*s == '\\')
	*s = '/';
      s++;
    }

  /* Safegaurd against confusing the breakpoint routines... */
  delete_command (NULL, 0);

  /* Must supress from_tty, otherwise we could start asking if the
     user really wants to load a new symbol table, etc... */
  printf_unfiltered ("Reading symbols from %s...", arg);
  exec_open (arg, 0);
  symbol_file_add_main (arg, 0);
  printf_unfiltered ("done\n");

  /* exec_open will kill our target, so reinstall the ICE as
     the target. */
  v850ice_open (NULL, 0);

  togdb_force_update ();
  return 1;
}

static int
ice_cont (char *c)
{
  printf_filtered ("continue (ice)\n");
  ReplyMessage ((LRESULT) 1);

  if (gdbtk_interp == NULL)
    {
      continue_command (NULL, 1);
    }
  else
    Tcl_Eval (gdbtk_interp, "gdb_immediate continue");

  return 1;
}

static void
do_gdb (char *cmd, char *str, void (*func) (char *, int), int count)
{
  ReplyMessage ((LRESULT) 1);

  while (count--)
    {
      printf_unfiltered (str);

      if (gdbtk_interp == NULL)
	{
	  func (NULL, 0);
	}
      else
	Tcl_Eval (gdbtk_interp, cmd);
    }
}


static int
ice_stepi (char *c)
{
  int count = (int) c;

  do_gdb ("gdb_immediate stepi", "stepi (ice)\n", stepi_command, count);
  return 1;
}

static int
ice_nexti (char *c)
{
  int count = (int) c;

  do_gdb ("gdb_immediate nexti", "nexti (ice)\n", nexti_command, count);
  return 1;
}

static void
v850ice_command (char *arg, int from_tty)
{
  struct MessageIO iob;
  char buf[256];

  iob.buf = buf;
  iob.size = 0;
  ExeAppReq ("GDB", GCOMMAND, arg, &iob);
}

static void
togdb_force_update (void)
{
  if (gdbtk_interp != NULL)
    Tcl_Eval (gdbtk_interp, "gdbtk_update");
}

static void
view_source (CORE_ADDR addr)
{
  char c[256];

  if (gdbtk_interp != NULL)
    {
      sprintf (c, "catch {set src [lindex [ManagedWin::find SrcWin] 0]\n$src location BROWSE [gdb_loc *0x%x]}", addr);
      Tcl_Eval (gdbtk_interp, c);
    }
}

/* Define the target subroutine names */

static void
init_850ice_ops (void)
{
  v850ice_ops.to_shortname = "ice";
  v850ice_ops.to_longname = "NEC V850 ICE interface";
  v850ice_ops.to_doc = "Debug a system controlled by a NEC 850 ICE.";
  v850ice_ops.to_open = v850ice_open;
  v850ice_ops.to_close = v850ice_close;
  v850ice_ops.to_detach = v850ice_detach;
  v850ice_ops.to_resume = v850ice_resume;
  v850ice_ops.to_wait = v850ice_wait;
  v850ice_ops.to_fetch_registers = v850ice_fetch_registers;
  v850ice_ops.to_store_registers = v850ice_store_registers;
  v850ice_ops.to_prepare_to_store = v850ice_prepare_to_store;
  v850ice_ops.deprecated_xfer_memory = v850ice_xfer_memory;
  v850ice_ops.to_files_info = v850ice_files_info;
  v850ice_ops.to_insert_breakpoint = v850ice_insert_breakpoint;
  v850ice_ops.to_remove_breakpoint = v850ice_remove_breakpoint;
  v850ice_ops.to_kill = v850ice_kill;
  v850ice_ops.to_load = v850ice_load;
  v850ice_ops.to_mourn_inferior = v850ice_mourn;
  v850ice_ops.to_stop = v850ice_stop;
  v850ice_ops.to_stratum = process_stratum;
  v850ice_ops.to_has_all_memory = 1;
  v850ice_ops.to_has_memory = 1;
  v850ice_ops.to_has_stack = 1;
  v850ice_ops.to_has_registers = 1;
  v850ice_ops.to_has_execution = 1;
  v850ice_ops.to_magic = OPS_MAGIC;
}

void
_initialize_v850ice (void)
{
  init_850ice_ops ();
  add_target (&v850ice_ops);

  add_com ("ice", class_obscure, v850ice_command,
	   "Send command to ICE");
}
@


1.23
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@@


1.22
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d902 1
a902 1
  v850ice_ops.to_xfer_memory = v850ice_xfer_memory;
@


1.21
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d535 1
a535 1
  store_unsigned_integer (val, DEPRECATED_REGISTER_RAW_SIZE (regno), regval);
d561 1
a561 1
				     DEPRECATED_REGISTER_RAW_SIZE (regno));
@


1.20
log
@2004-06-25  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (deprecated_ui_loop_hook): Deprecated.
	* wince.c (child_wait): Update.
	* win32-nat.c (child_wait): Update.
	* v850ice.c (v850ice_wait): Update.
	* top.c (deprecated_ui_loop_hook): Update.
	* serial.h: Update.
	* ser-unix.c (do_hardwire_readchar, do_hardwire_readchar)
	(do_unix_readchar): Update.
	* ser-tcp.c (net_open): Update.
	* remote-sim.c (gdb_os_poll_quit): Update.
	* rdi-share/ardi.c (angel_RDI_ExecuteOrStep): Update.
@
text
@d536 1
a536 1
  supply_register (regno, val);
@


1.19
log
@2004-06-24  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (post_add_symbol_hook, pre_add_symbol_hook)
	(ui_loop_hook, selected_frame_level_changed_hook): Declare.
	* wince.c (ui_loop_hook): Delete extern declaration.
	* win32-nat.c (ui_loop_hook): Delete extern declaration..
	* v850ice.c (ui_loop_hook): Delete extern declaration..
	* ser-unix.c (ui_loop_hook): Delete extern declaration..
	* ser-tcp.c (ui_loop_hook): Delete extern declaration..
	* remote-sim.c (ui_loop_hook): Delete extern declaration..
	* rdi-share/ardi.c (angel_RDI_ExecuteOrStep): Delete extern.
	ui_loop_hook declaration.
@
text
@d444 1
a444 1
	  ui_loop_hook (0);
@


1.18
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@a52 2
extern int (*ui_loop_hook) (int);

@


1.18.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d53 2
d446 1
a446 1
	  deprecated_ui_loop_hook (0);
d537 2
a538 2
  store_unsigned_integer (val, register_size (current_gdbarch, regno), regval);
  regcache_raw_supply (current_regcache, regno, val);
d563 1
a563 1
				     register_size (current_gdbarch, regno));
@


1.17
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d537 1
a537 1
  store_unsigned_integer (val, REGISTER_RAW_SIZE (regno), regval);
d563 1
a563 1
				     REGISTER_RAW_SIZE (regno));
@


1.16
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTE): Rename REGISTER_BYTE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-linux-tdep.c, core-sol2.c, cris-tdep.c: Update.
	* d10v-tdep.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, irix5-nat.c, lynx-nat.c, m68knbsd-nat.c: Update.
	* mcore-tdep.c, mips-linux-tdep.c, mips-tdep.c: Update.
	* mipsv4-nat.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* ns32knbsd-nat.c, ppc-bdm.c, regcache.c, remote-sds.c: Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh64-tdep.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, v850-tdep.c: Update.
	* v850ice.c, vax-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-cisco.h, config/m68k/tm-delta68.h: Update.
	* config/pa/nm-hppah.h: Update.

2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* mi/mi-main.c: Rename REGISTER_BYTE to DEPRECATED_REGISTER_BYTE.
@
text
@a373 1
/* ARGSUSED */
a588 1
/* ARGSUSED */
@


1.15
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d563 1
a563 1
  regval = extract_unsigned_integer (&deprecated_registers[REGISTER_BYTE (regno)],
@


1.14
log
@2002-11-14  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_registers): Rename registers.
	* a68v-nat.c, alpha-nat.c, arch-utils.c, core-sol2.c: Update.
	* hp300ux-nat.c, hppab-nat.c, hppah-nat.c: Update.
	* hppam3-nat.c, hpux-thread.c, i386gnu-nat.c: Update.
	* ia64-aix-nat.c, ia64-linux-nat.c, ia64-tdep.c: Update.
	* irix4-nat.c, irix5-nat.c, lynx-nat.c, m68k-tdep.c: Update.
	* m68knbsd-nat.c, mips-linux-tdep.c, mipsm3-nat.c: Update.
	* mipsv4-nat.c, ns32knbsd-nat.c, ppc-bdm.c: Update.
	* ppc-sysv-tdep.c, ptx4-nat.c, regcache.c, remote-es.c: Update.
	* remote-sds.c, remote-vx68.c, remote-vxmips.c: Update.
	* remote-vxsparc.c, rs6000-tdep.c, sol-thread.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, symm-nat.c: Update.
	* v850ice.c: Update.
@
text
@d292 1
a292 1
	  if (!catch_errors ((catch_errors_ftype *) ice_stepi, (PTR) (int) lParam, "",
d298 1
a298 1
	  if (!catch_errors ((catch_errors_ftype *) ice_nexti, (PTR) (int) lParam, "",
@


1.13
log
@	* gnu-nat.c (init_gnu_ops): Remove NULL initializations.
	* monitor.c (init_base_monitor_ops): Likewise.
	* ppc-bdm.c (init_bdm_ppc_ops): Likewise.
	* remote-array.c (init_array_ops): Likewise.
	* remote-e7000.c (init_e7000_ops): Likewise.
	* remote-es.c (init_es1800_ops): Likewise.
	(init_es1800_child_ops): Likewise.
	* remote-rdp.c (init_remote_rdp_ops): Likewise.
	* remote-sim.c (init_gdbsim_ops): Likewise.
	* remote-st.c (init_st2000_ops): Likewise.
	* sol-thread.c (init_sol_core_ops): Likewise.
	(init_sol_thread_ops): Likewise.
	* v850ice.c (init_850ice_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
@
text
@d563 1
a563 1
  regval = extract_unsigned_integer (&registers[REGISTER_BYTE (regno)],
@


1.12
log
@2002-10-02  Elena Zannoni  <ezannoni@@redhat.com>

        * inferior.h (registers_info, stepi_command, nexti_command,
        continue_command, interrupt_target_command): Export from infcmd.c.
        * frame.h (args_info, selected_frame_level_changed_hook,
        return_command): Export from stack.c.
        * v850ice.c (stepi_command, nexti_command, continue_command): use
        prototypes from inferior.h.
        * tracepoint.c (registers_info, args_info, locals_info): Use
        prototypes from frame.h and inferior.h.
        * Makefile.in (mi-main.o): Add dependency on frame.h.

2002-10-02  Elena Zannoni  <ezannoni@@redhat.com>

        * mi-main.c (mi_cmd_exec_return): Don't use
        return_command_wrapper, use return_command instead.
        (mi_cmd_exec_interrupt): Don't use
        interrupt_target_command_wrapper, use interrupt_target_command
        instead.
        (return_command_wrapper, interrupt_target_command_wrapper):
        Delete.
        Include frame.h.

2002-10-02  Elena Zannoni  <ezannoni@@redhat.com>

        * tui-hooks.c (selected_frame_level_changed_hook): Use the one
        exported from frame.h.
@
text
@a899 3
  v850ice_ops.to_attach = NULL;
  v850ice_ops.to_post_attach = NULL;
  v850ice_ops.to_require_attach = NULL;
a900 1
  v850ice_ops.to_require_detach = NULL;
a902 1
  v850ice_ops.to_post_wait = NULL;
a909 5
  v850ice_ops.to_terminal_init = NULL;
  v850ice_ops.to_terminal_inferior = NULL;
  v850ice_ops.to_terminal_ours_for_output = NULL;
  v850ice_ops.to_terminal_ours = NULL;
  v850ice_ops.to_terminal_info = NULL;
a911 2
  v850ice_ops.to_lookup_symbol = NULL;
  v850ice_ops.to_create_inferior = NULL;
a912 3
  v850ice_ops.to_can_run = 0;
  v850ice_ops.to_notice_signals = 0;
  v850ice_ops.to_thread_alive = NULL;
a913 1
  v850ice_ops.to_pid_to_exec_file = NULL;
a914 1
  v850ice_ops.DONT_USE = NULL;
a919 2
  v850ice_ops.to_sections = NULL;
  v850ice_ops.to_sections_end = NULL;
@


1.12.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d292 1
a292 1
	  if (!catch_errors ((catch_errors_ftype *) ice_stepi, (int) lParam, "",
d298 1
a298 1
	  if (!catch_errors ((catch_errors_ftype *) ice_nexti, (int) lParam, "",
d374 1
d538 1
a538 1
  store_unsigned_integer (val, DEPRECATED_REGISTER_RAW_SIZE (regno), regval);
d563 2
a564 2
  regval = extract_unsigned_integer (&deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],
				     DEPRECATED_REGISTER_RAW_SIZE (regno));
d590 1
d900 3
d904 1
d907 1
d915 5
d922 2
d925 3
d929 1
d931 1
d937 2
@


1.11
log
@Phase 1 of the ptid_t changes.
@
text
@a52 6
extern void stepi_command (char *, int);

extern void nexti_command (char *, int);

extern void continue_command (char *, int);

@


1.11.16.1
log
@merge from mainline
@
text
@d53 6
@


1.11.24.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d53 6
@


1.11.24.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d563 1
a563 1
  regval = extract_unsigned_integer (&deprecated_registers[REGISTER_BYTE (regno)],
d900 3
d904 1
d907 1
d915 5
d922 2
d925 3
d929 1
d931 1
d937 2
@


1.11.24.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d292 1
a292 1
	  if (!catch_errors ((catch_errors_ftype *) ice_stepi, (int) lParam, "",
d298 1
a298 1
	  if (!catch_errors ((catch_errors_ftype *) ice_nexti, (int) lParam, "",
@


1.11.24.4
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d563 1
a563 1
  regval = extract_unsigned_integer (&deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],
@


1.11.24.5
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d374 1
d538 1
a538 1
  store_unsigned_integer (val, DEPRECATED_REGISTER_RAW_SIZE (regno), regval);
d564 1
a564 1
				     DEPRECATED_REGISTER_RAW_SIZE (regno));
d590 1
@


1.10
log
@* target.h (target_ops): Removed to_core_file_to_sym_file vector
function.
* corelow.c (core_ops): Updated for above change.
* gnu-nat.c (core_ops): Likewise.
* inftarg.c (child_ops): Likewise.
* monitor.c (monitor_ops): Likewise.
* ppc-bdm.c (bdm_ppc_ops): Likewise.
* remote-adapt.c (adapt_ops): Likewise.
* remote-bug.c (bug_ops): Likewise.
* remote-e7000.c (e7000_ops): Likewise.
* remote-eb.c (eb_ops): Likewise.
* remote-es.c (es1800_ops, es1800_child_ops): Likewise.
* remote-mm.c (mm_ops): Likewise.
* remote-nindy.c (nindy_ops): Likewise.
* remote-nrom.c (nrom_ops): Likewise.
* remote-os9k.c (rombug_ops): Likewise.
* remote-rdp.c (remote_rdp_ops): Likewise.
* remote-sim.c (gdbsim_ops): Likewise.
* remote-st.c (st2000_ops): Likewise.
* v850ice.c (v850ice_ops): Likewise.
* target.c (cleanup_target): Likewise
(update_current_target): Likewise.
(setup_target_debug): Likewise
(debug_to_core_file_to_sym_file): Removed.

* corefile.c (core_file_command) [HPUXHPPA]: Removed code that
sets symbol file from information obtained from the core file.
* corelow.c (core_file_to_sym_file): Removed.
@
text
@d76 2
a77 1
static void v850ice_resume (int pid, int step, enum target_signal siggnal);
d89 2
a90 1
static int v850ice_wait (int pid, struct target_waitstatus *status);
d372 1
a372 1
  inferior_pid = 42000;
d388 1
a388 1
      inferior_pid = 0;
d414 1
a414 1
v850ice_resume (int pid, int step, enum target_signal siggnal)
d437 2
a438 2
static int
v850ice_wait (int pid, struct target_waitstatus *status)
d490 1
a490 1
  return inferior_pid;
d757 1
a757 1
  inferior_pid = 0;
@


1.9
log
@Update/correct copyright notices.
@
text
@a933 1
  v850ice_ops.to_core_file_to_sym_file = NULL;
@


1.8
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1996, 2000, 2001 Free Software Foundation, Inc.
@


1.7
log
@2001-01-26  Fernando Nasser  <fnasser@@redhat.com>

        Fix double parsing of filenames passed as command line arguments
        to GDB (causes weird handling of escape characters).
        Also, remove dependencies on the CLI from libgdb.
        * call-cmds.h: Remove declaration of exec_file_command().
        * gdbcore.h: Remove declaration of exec_file_command().
        Add declarations for exec_open() and exec_file_clear().
        * symfile.h: Add declarations for symbol_file_add_main() and
        symbol_file_clear().
        * exec.c (exec_open): New function. Implements to_open for exec
        targets.
        (exec_file_clear): New function. Makes GDB forget about a previously
        specified executable file.
        (exec_file_attach): Move parsing of arguments from here ...
        (exec_file_command): ... to here.
        (init_exec_ops): Use exec_open(), not exec_file_command() to
        implement to_open for exec targets.
        * symfile.c (symbol_file_add_main): New function. Call symbol_file_add()        with default values.  Used when the file name has already been parsed.
        (symbol_file_clear): New function. Makes GDB forget about previously
        read symbols.
        (symbol_file_command): Call the above function instead of inline code.
        * main.c: Include "symfile.h" and "gdbcore.h" instead of the deprecated
        "call-cmds.h".
        (captured_main): Call exec_file_attach() and symbol_file_add_main()
        instead of exec_file_command() and symbol_file_command().
        (captured_main): Add comment.
        * corefile.c: Include "symfile.h".
        (core_file_command): Call symbol_file_add_main() instead of
        symbol_file_command().
        (reopen_exec_file): Call exec_open() instead of exec_file_command().
        * infcmd.c: Include "symfile.h".
        (attach_command): Call symbol_file_add_main() instead of
        symbol_file_command().
        * infrun.c: Remove comment about the inclusion of "symfile.h",
        not any longer appropriate.
        (follow_exec): Call symbol_file_add_main() instead of
        symbol_file_command().
        * remote-es.c: Include "symfile.h".
        (es1800_load): Call symbol_file_add_main() instead of
        symbol_file_command().
        * remote-vx.c: Remove comment about the inclusion of "symfile.h",
        not any longer appropriate.
        (vx-wait): Call symbol_file_add_main() instead of
        symbol_file_command().
        * solib-svr4.c (open_symbol_file_object): Call symbol_file_add_main()
        instead of symbol_file_command().
        * v850ice.c (ice_file): Call exec_open(), exec_file_attach() and
        symbol_file_add_main() instead of exec_file_command() and
        symbol_file_command().
        * Makefile.in: Update dependencies.
@
text
@d2 1
a2 1
   Copyright 1996, 2000 Free Software Foundation, Inc.
d33 1
@


1.6
log
@Protoization.
@
text
@d797 2
a798 2
  exec_file_command (arg, 0);
  symbol_file_command (arg, 0);
d801 1
a801 1
  /* exec_file_command will kill our target, so reinstall the ICE as
@


1.5
log
@Protoization.
@
text
@d587 2
a588 1
   nonzero.  Returns length of data written or read; 0 for error.
d591 1
a591 1
   dies */
d594 2
a595 6
v850ice_xfer_memory (memaddr, myaddr, len, should_write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int should_write;
     struct target_ops *target;	/* ignored */
d826 1
a826 5
do_gdb (cmd, str, func, count)
     char *cmd;
     char *str;
     void (*func) (char *, int);
     int count;
@


1.4
log
@PARAMS elimination.
@
text
@d195 1
a195 1
init_hidden_window ()
d245 1
a245 5
v850ice_wndproc (hwnd, message, wParam, lParam)
     HWND hwnd;
     UINT message;
     WPARAM wParam;
     LPARAM lParam;
d317 1
a317 3
v850ice_open (name, from_tty)
     char *name;
     int from_tty;
d378 1
a378 2
v850ice_close (quitting)
     int quitting;
d390 1
a390 1
v850ice_stop ()
d397 1
a397 3
v850ice_detach (args, from_tty)
     char *args;
     int from_tty;
d410 1
a410 3
v850ice_resume (pid, step, siggnal)
     int pid, step;
     enum target_signal siggnal;
d434 1
a434 3
v850ice_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d490 1
a490 3
convert_register (regno, buf)
     int regno;
     char *buf;
d509 1
a509 2
v850ice_fetch_registers (regno)
     int regno;
d548 1
a548 2
v850ice_store_registers (regno)
     int regno;
d581 1
a581 1
v850ice_prepare_to_store ()
d708 1
a708 2
v850ice_files_info (ignore)
     struct target_ops *ignore;
d714 1
a714 3
v850ice_insert_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d733 1
a733 3
v850ice_remove_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d753 1
a753 1
v850ice_kill ()
d760 1
a760 1
v850ice_mourn ()
d765 1
a765 3
v850ice_load (filename, from_tty)
     char *filename;
     int from_tty;
d777 1
a777 2
ice_file (arg)
     char *arg;
d813 1
a813 2
ice_cont (c)
     char *c;
d852 1
a852 2
ice_stepi (c)
     char *c;
d861 1
a861 2
ice_nexti (c)
     char *c;
d870 1
a870 3
v850ice_command (arg, from_tty)
     char *arg;
     int from_tty;
d888 1
a888 2
view_source (addr)
     CORE_ADDR addr;
d953 1
a953 1
_initialize_v850ice ()
@


1.3
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d124 1
a124 1
static void do_gdb (char *, char *, void (*func) PARAMS ((char *, int)), int);
d130 1
a130 1
long (__stdcall * ExeAppReq) PARAMS ((char *, long, char *, struct MessageIO *));
d132 1
a132 1
long (__stdcall * RegisterClient) PARAMS ((HWND));
d134 1
a134 1
long (__stdcall * UnregisterClient) PARAMS ((void));
d349 1
a349 1
      ExeAppReq = (long (*)PARAMS ((char *, long, char *, struct MessageIO *)))
d351 1
a351 1
      RegisterClient = (long (*)PARAMS ((HWND)))
d353 1
a353 1
      UnregisterClient = (long (*)PARAMS ((void)))
@


1.2
log
@PARAMS removal.
@
text
@d57 1
a57 1
extern int (*ui_loop_hook) PARAMS ((int));
d858 1
a858 1
     void (*func) PARAMS ((char *, int));
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1996, Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d34 1
d36 4
a39 1
#include <winuser.h> /* for WM_USER */
a40 3
extern unsigned long int strtoul(const char *nptr, char **endptr,
                                 int base);
 
d43 4
a46 4
{
  int    size;   /* length of input or output in bytes         */
  char * buf;    /* buffer having the input/output information */
};
d49 1
a49 1
extern void break_command PARAMS ((char *, int));
d51 1
a51 1
extern void stepi_command PARAMS ((char *, int));
d53 1
a53 1
extern void nexti_command PARAMS ((char *, int));
d55 1
a55 1
extern void continue_command PARAMS ((char *, int));
d60 3
a62 1
static int init_hidden_window PARAMS ((void));
d64 1
a64 1
static LRESULT CALLBACK v850ice_wndproc PARAMS ((HWND, UINT, WPARAM, LPARAM));
d66 3
a68 1
static void v850ice_files_info PARAMS ((struct target_ops *ignore));
d70 1
a70 3
static int v850ice_xfer_memory PARAMS ((CORE_ADDR memaddr, char *myaddr,
					int len, int should_write,
					struct target_ops *target));
d72 1
a72 1
static void v850ice_prepare_to_store PARAMS ((void));
d74 1
a74 1
static void v850ice_fetch_registers PARAMS ((int regno));
d76 1
a76 2
static void v850ice_resume PARAMS ((int pid, int step,
				   enum target_signal siggnal));
d78 1
a78 1
static void v850ice_open PARAMS ((char *name, int from_tty));
d80 1
a80 1
static void v850ice_close PARAMS ((int quitting));
d82 1
a82 1
static void v850ice_stop PARAMS ((void));
d84 1
a84 1
static void v850ice_store_registers PARAMS ((int regno));
d86 1
a86 1
static void v850ice_mourn PARAMS ((void));
d88 1
a88 1
static int v850ice_wait PARAMS ((int pid, struct target_waitstatus *status));
d90 1
a90 1
static void v850ice_kill PARAMS ((void));
d92 1
a92 1
static void v850ice_detach PARAMS ((char *args, int from_tty));
d94 1
a94 1
static int v850ice_insert_breakpoint PARAMS ((CORE_ADDR, char *));
d96 1
a96 1
static int v850ice_remove_breakpoint PARAMS ((CORE_ADDR, char *));
d98 1
a98 1
static void v850ice_command PARAMS ((char *, int));
d100 1
a100 1
static int ice_disassemble PARAMS ((unsigned long, int, char *));
d102 1
a102 1
static int ice_lookup_addr PARAMS ((unsigned long *, char *, char *));
d104 1
a104 1
static int ice_lookup_symbol PARAMS ((unsigned long, char *));
d106 1
a106 1
static void ice_SimulateDisassemble PARAMS ((char *, int));
d108 1
a108 1
static void ice_SimulateAddrLookup PARAMS ((char *, int));
d110 1
a110 1
static void ice_Simulate_SymLookup PARAMS ((char *, int));
d112 1
a112 1
static void ice_fputs PARAMS ((const char *, GDB_FILE *));
d114 1
a114 1
static int ice_file PARAMS ((char *));
d116 1
a116 1
static int ice_cont PARAMS ((char *));
d118 1
a118 1
static int ice_stepi PARAMS ((char *));
d120 1
a120 1
static int ice_nexti PARAMS ((char *));
d122 1
a122 1
static void togdb_force_update PARAMS ((void));
d128 1
a128 1
static HWND hidden_hwnd;                 /* HWND for messages */
d130 1
a130 1
long (__stdcall *ExeAppReq) PARAMS ((char *, long, char *, struct MessageIO *));
d132 1
a132 1
long (__stdcall *RegisterClient) PARAMS ((HWND));
d134 1
a134 1
long (__stdcall *UnregisterClient) PARAMS ((void));
d136 1
d139 1
a139 1
static int ice_open = 0;        /* Is ICE open? */
d141 1
a141 1
static char * v850_CB_Result;   /* special char array for saving 'callback' results */
d143 1
a143 1
static int SimulateCallback;    /* simulate a callback event */
d145 2
a146 2
#define MAX_BLOCK_SIZE    64*1024   /* Cannot transfer memory in blocks bigger
                                       than this */
d148 15
a162 15
#define GSINGLESTEP     0x200   /* single-step target          */
#define GRESUME         0x201   /* resume target               */
#define GREADREG        0x202   /* read a register             */
#define GWRITEREG       0x203   /* write a register            */
#define GWRITEBLOCK     0x204   /* write a block of memory     */
#define GREADBLOCK      0x205   /* read a block of memory      */
#define GSETBREAK       0x206   /* set a breakpoint            */
#define GREMOVEBREAK    0x207   /* remove a breakpoint         */
#define GHALT           0x208   /* ??? */
#define GCHECKSTATUS    0x209   /* check status of ICE         */
#define GMDIREPLY       0x210   /* Reply for previous query - NOT USED */
#define GDOWNLOAD       0x211   /* something for MDI           */
#define GCOMMAND        0x212   /* execute command in ice      */
#define GLOADFILENAME   0x213   /* retrieve load filename      */
#define GWRITEMEM       0x214   /* write word, half-word, or byte */
d166 6
a171 6
#define ICE_Breakpoint  0x01    /* hit a breakpoint */
#define ICE_Stepped     0x02    /* have stepped     */
#define ICE_Exception   0x03    /* have exception   */
#define ICE_Halted      0x04    /* hit a user halt  */
#define ICE_Exited      0x05    /* called exit      */
#define ICE_Terminated  0x06    /* user terminated  */
d183 7
a189 7
#define STATE_CHANGE_REGS   1   /* Register(s) changed */
#define STATE_CHANGE_LOAD   2   /* HW reset            */
#define STATE_CHANGE_RESET  3   /* Load new file       */
#define STATE_CHANGE_CONT   4   /* Run target          */
#define STATE_CHANGE_STOP   5   /* Stop target         */
#define STATE_CHANGE_STEPI  6   /* Stepi target        */
#define STATE_CHANGE_NEXTI  7   /* Nexti target        */
d213 1
a213 1
  if (! RegisterClass (&class))
d217 2
a218 2
                              0, 0, 0, 0, NULL, NULL, class.hInstance,
                              NULL);
d226 1
a226 1
                     0, buf, 200, NULL);
d243 1
a243 1
*/
d262 1
d266 44
a309 44
        {
        case STATE_CHANGE_LOAD:
          {
            struct MessageIO iob;
            char buf[128];

            iob.buf  = buf;
            iob.size = 128;

            /* Load in a new file... Need filename */
            ExeAppReq ("GDB", GLOADFILENAME, NULL, &iob);
            if (!catch_errors ((catch_errors_ftype *) ice_file, iob.buf, "", RETURN_MASK_ALL))
              printf_unfiltered ("load errored\n");
          }
          break;
        case STATE_CHANGE_RESET:
          registers_changed ();
          flush_cached_frames ();
          togdb_force_update ();
          result = TRUE;
          break;
        case STATE_CHANGE_REGS:
          registers_changed ();
          togdb_force_update ();
          result = TRUE;
          break;
        case STATE_CHANGE_CONT:
          if (!catch_errors ((catch_errors_ftype *)ice_cont, NULL, "", RETURN_MASK_ALL))
            printf_unfiltered ("continue errored\n");
          result = TRUE;
          break;
        case STATE_CHANGE_STEPI:
          if (!catch_errors ((catch_errors_ftype *)ice_stepi, (PTR)(int) lParam, "",
                             RETURN_MASK_ALL))
            printf_unfiltered ("stepi errored\n");
          result = TRUE;
          break;
        case STATE_CHANGE_NEXTI:
          if (!catch_errors ((catch_errors_ftype *)ice_nexti, (PTR)(int) lParam, "",
                             RETURN_MASK_ALL))
            printf_unfiltered ("nexti errored\n");
          result = TRUE;
          break;
        }
d347 1
a347 1
        error ("Cannot load necmsg.dll");
d349 6
a354 6
      ExeAppReq = (long (*) PARAMS ((char *, long, char *, struct MessageIO *)))
        GetProcAddress (handle, "ExeAppReq");
      RegisterClient = (long (*) PARAMS ((HWND)))
        GetProcAddress (handle, "RegisterClient");
      UnregisterClient = (long (*) PARAMS ((void)))
        GetProcAddress (handle, "UnregisterClient");
d357 1
a357 1
        error ("Could not find requisite functions in necmsg.dll.");
d360 1
a360 1
        error ("could not initialize message handling");
d423 3
a425 3
  long              retval;
  char              buf[256];
  struct MessageIO  iob;
d428 1
a428 1
  iob.buf  = buf;
d451 1
a451 1
  struct MessageIO  iob;
d456 2
a457 2
  iob.buf  = buf;
  
d461 2
a462 2
        {
          ui_loop_hook (0);
d464 1
a464 1
        }
d469 27
a495 27
        {
        case ICE_Idle:
        case ICE_Breakpoint:
        case ICE_Stepped:
        case ICE_Halted:
          status->kind = TARGET_WAITKIND_STOPPED;
          status->value.sig = TARGET_SIGNAL_TRAP;
          done = 1;
          break;
        case ICE_Exception:
          status->kind = TARGET_WAITKIND_SIGNALLED;
          status->value.sig = TARGET_SIGNAL_SEGV;
          done = 1;
          break;
        case ICE_Exited:
          status->kind = TARGET_WAITKIND_EXITED;
          status->value.integer = 0;
          done = 1;
          break;
        case ICE_Terminated:
          status->kind = TARGET_WAITKIND_SIGNALLED;
          status->value.sig = TARGET_SIGNAL_KILL;
          done = 1;
          break;
        default:
          break;
        }
d498 1
a498 1
      
d537 1
a537 1
        v850ice_fetch_registers (regno);
d554 1
a554 1
           regno, val);
d583 1
a583 1
                                     REGISTER_RAW_SIZE (regno));
d597 1
a597 1
static void 
d615 1
a615 1
     struct target_ops *target;			/* ignored */
d625 26
a650 17
        {
          long value = 0;
          char buf[256];
          char c;

          iob.size = 0;
          iob.buf  = buf;

          sent = 0;
          switch (len)
            {
            case 4:
              c = 'w';
              value |= (long) ((myaddr[3] << 24) & 0xff000000);
              value |= (long) ((myaddr[2] << 16) & 0x00ff0000);
              value |= (long) ((myaddr[1] << 8)  & 0x0000ff00);
              value |= (long) (myaddr[0] & 0x000000ff);
d652 25
a676 34
            case 2:
              c = 'h';
              value |= (long) ((myaddr[1] << 8) & 0xff00);
              value |= (long) (myaddr[0] & 0x00ff);
              break;
            case 1:
              c = 'b';
              value |= (long) (myaddr[0] & 0xff);
              break;
            }

          sprintf (cmd, "memory %c c 0x%x=0x%x", c, (int) memaddr, value);
          retval = ExeAppReq ("GDB", GWRITEMEM, cmd, &iob);
          if (retval == 0)
            sent = len;
        }
      else 
        {
          sent = 0;
          do 
            {
              iob.size  = len > MAX_BLOCK_SIZE ? MAX_BLOCK_SIZE : len;
              iob.buf   = myaddr;
              sprintf (cmd, "memory b c 0x%x=0x00 l=%d", (int) memaddr, iob.size);
              retval = ExeAppReq ("GDB", GWRITEBLOCK, cmd, &iob);
              if (retval != 0)
                break;
              len      -= iob.size;
              memaddr  += iob.size;
              myaddr   += iob.size;
              sent     += iob.size;
            }
          while (len > 0);
        }
d683 1
a683 1
      
d690 12
a701 12
        {
          iob.size = len > MAX_BLOCK_SIZE ? MAX_BLOCK_SIZE : len;
          iob.buf  = tmp;
          sprintf (cmd, "memory b 0x%x l=%d", (int)memaddr, iob.size);
          retval = ExeAppReq ("GDB", GREADBLOCK, cmd, &iob);
          if (retval != 0)
            break;
          len     -= iob.size;
          memaddr += iob.size;
          sent    += iob.size;
          tmp     += iob.size;
        }
d705 11
a715 11
        {
          for (i = 0; i <  100; i++)
            {
              if (t[sent + i] != 0xff)
                {
                  warning ("GREADBLOCK trashed bytes after transfer area.");
                  break;
                }
            }
          memcpy (myaddr, t, sent);
        }
d717 1
a717 1
 
d720 1
a720 1
  
d742 1
a742 1
  iob.buf  = buf;
d763 1
a763 1
  iob.buf  = buf;
d788 2
a789 2
  char * filename; 
  int from_tty;
d795 2
a796 2
  iob.buf  = buf;
  generic_load(filename, from_tty);
d805 1
a805 1
  
d815 1
a815 1
        *s = '/';
d820 1
a820 1
  delete_command(NULL, 0);
d839 1
a839 1
  char *c;
d844 2
d847 3
d867 2
d870 3
d879 1
a879 1
  char *c;
d889 1
a889 1
  char *c;
d899 2
a900 2
  char *arg;
  int   from_tty;
d913 2
d917 12
d932 2
a933 2
static void 
init_850ice_ops(void)
d935 34
a968 34
  v850ice_ops.to_shortname   =   "ice";		
  v850ice_ops.to_longname    =   "NEC V850 ICE interface";
  v850ice_ops.to_doc         =   "Debug a system controlled by a NEC 850 ICE.";
  v850ice_ops.to_open        =   v850ice_open;		
  v850ice_ops.to_close       =   v850ice_close;	
  v850ice_ops.to_attach      =   NULL;
  v850ice_ops.to_post_attach =   NULL;
  v850ice_ops.to_require_attach = NULL;		
  v850ice_ops.to_detach      =   v850ice_detach;
  v850ice_ops.to_require_detach = NULL;	
  v850ice_ops.to_resume      =   v850ice_resume;	
  v850ice_ops.to_wait        =   v850ice_wait;
  v850ice_ops.to_post_wait = NULL;	
  v850ice_ops.to_fetch_registers  =   v850ice_fetch_registers;
  v850ice_ops.to_store_registers  =   v850ice_store_registers;
  v850ice_ops.to_prepare_to_store =   v850ice_prepare_to_store;
  v850ice_ops.to_xfer_memory =   v850ice_xfer_memory;	
  v850ice_ops.to_files_info  =   v850ice_files_info;	
  v850ice_ops.to_insert_breakpoint =   v850ice_insert_breakpoint;
  v850ice_ops.to_remove_breakpoint =   v850ice_remove_breakpoint;
  v850ice_ops.to_terminal_init    =   NULL;		
  v850ice_ops.to_terminal_inferior =   NULL;		
  v850ice_ops.to_terminal_ours_for_output =   NULL;	
  v850ice_ops.to_terminal_ours   =   NULL;		
  v850ice_ops.to_terminal_info   =   NULL;		
  v850ice_ops.to_kill            =   v850ice_kill;		
  v850ice_ops.to_load            =   v850ice_load;		
  v850ice_ops.to_lookup_symbol   =   NULL;		
  v850ice_ops.to_create_inferior =   NULL;
  v850ice_ops.to_mourn_inferior  =   v850ice_mourn;
  v850ice_ops.to_can_run         =   0;		
  v850ice_ops.to_notice_signals  =   0;		
  v850ice_ops.to_thread_alive    =    NULL;	
  v850ice_ops.to_stop            =   v850ice_stop;
d970 11
a980 11
  v850ice_ops.to_core_file_to_sym_file = NULL;			
  v850ice_ops.to_stratum         =   process_stratum;	
  v850ice_ops.DONT_USE           =   NULL;		
  v850ice_ops.to_has_all_memory  =   1;		
  v850ice_ops.to_has_memory      =   1;		
  v850ice_ops.to_has_stack       =   1;		
  v850ice_ops.to_has_registers   =   1;		
  v850ice_ops.to_has_execution   =   1;		
  v850ice_ops.to_sections        =   NULL;		
  v850ice_ops.to_sections_end    =   NULL;		
  v850ice_ops.to_magic           =   OPS_MAGIC	;
d990 1
a990 1
           "Send command to ICE");
@


1.1.1.1
log
@import gdb-1999-06-07 snapshot
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d34 1
a34 4
#include <winuser.h>		/* for WM_USER */

extern unsigned long int strtoul (const char *nptr, char **endptr,
				  int base);
d36 3
d41 4
a44 4
  {
    int size;			/* length of input or output in bytes         */
    char *buf;			/* buffer having the input/output information */
  };
d62 1
a62 1
static void v850ice_files_info PARAMS ((struct target_ops * ignore));
d66 1
a66 1
					struct target_ops * target));
d73 1
a73 1
				    enum target_signal siggnal));
d85 1
a85 1
static int v850ice_wait PARAMS ((int pid, struct target_waitstatus * status));
d125 1
a125 1
static HWND hidden_hwnd;	/* HWND for messages */
d127 1
a127 1
long (__stdcall * ExeAppReq) PARAMS ((char *, long, char *, struct MessageIO *));
d129 1
a129 1
long (__stdcall * RegisterClient) PARAMS ((HWND));
d131 1
a131 1
long (__stdcall * UnregisterClient) PARAMS ((void));
d135 1
a135 1
static int ice_open = 0;	/* Is ICE open? */
d137 1
a137 1
static char *v850_CB_Result;	/* special char array for saving 'callback' results */
d139 1
a139 1
static int SimulateCallback;	/* simulate a callback event */
d141 2
a142 2
#define MAX_BLOCK_SIZE    64*1024	/* Cannot transfer memory in blocks bigger
					   than this */
d144 15
a158 15
#define GSINGLESTEP     0x200	/* single-step target          */
#define GRESUME         0x201	/* resume target               */
#define GREADREG        0x202	/* read a register             */
#define GWRITEREG       0x203	/* write a register            */
#define GWRITEBLOCK     0x204	/* write a block of memory     */
#define GREADBLOCK      0x205	/* read a block of memory      */
#define GSETBREAK       0x206	/* set a breakpoint            */
#define GREMOVEBREAK    0x207	/* remove a breakpoint         */
#define GHALT           0x208	/* ??? */
#define GCHECKSTATUS    0x209	/* check status of ICE         */
#define GMDIREPLY       0x210	/* Reply for previous query - NOT USED */
#define GDOWNLOAD       0x211	/* something for MDI           */
#define GCOMMAND        0x212	/* execute command in ice      */
#define GLOADFILENAME   0x213	/* retrieve load filename      */
#define GWRITEMEM       0x214	/* write word, half-word, or byte */
d162 6
a167 6
#define ICE_Breakpoint  0x01	/* hit a breakpoint */
#define ICE_Stepped     0x02	/* have stepped     */
#define ICE_Exception   0x03	/* have exception   */
#define ICE_Halted      0x04	/* hit a user halt  */
#define ICE_Exited      0x05	/* called exit      */
#define ICE_Terminated  0x06	/* user terminated  */
d179 7
a185 7
#define STATE_CHANGE_REGS   1	/* Register(s) changed */
#define STATE_CHANGE_LOAD   2	/* HW reset            */
#define STATE_CHANGE_RESET  3	/* Load new file       */
#define STATE_CHANGE_CONT   4	/* Run target          */
#define STATE_CHANGE_STOP   5	/* Stop target         */
#define STATE_CHANGE_STEPI  6	/* Stepi target        */
#define STATE_CHANGE_NEXTI  7	/* Nexti target        */
d209 1
a209 1
  if (!RegisterClass (&class))
d213 2
a214 2
			      0, 0, 0, 0, NULL, NULL, class.hInstance,
			      NULL);
d222 1
a222 1
		     0, buf, 200, NULL);
d239 1
a239 1
 */
d261 44
a304 44
	{
	case STATE_CHANGE_LOAD:
	  {
	    struct MessageIO iob;
	    char buf[128];

	    iob.buf = buf;
	    iob.size = 128;

	    /* Load in a new file... Need filename */
	    ExeAppReq ("GDB", GLOADFILENAME, NULL, &iob);
	    if (!catch_errors ((catch_errors_ftype *) ice_file, iob.buf, "", RETURN_MASK_ALL))
	      printf_unfiltered ("load errored\n");
	  }
	  break;
	case STATE_CHANGE_RESET:
	  registers_changed ();
	  flush_cached_frames ();
	  togdb_force_update ();
	  result = TRUE;
	  break;
	case STATE_CHANGE_REGS:
	  registers_changed ();
	  togdb_force_update ();
	  result = TRUE;
	  break;
	case STATE_CHANGE_CONT:
	  if (!catch_errors ((catch_errors_ftype *) ice_cont, NULL, "", RETURN_MASK_ALL))
	    printf_unfiltered ("continue errored\n");
	  result = TRUE;
	  break;
	case STATE_CHANGE_STEPI:
	  if (!catch_errors ((catch_errors_ftype *) ice_stepi, (PTR) (int) lParam, "",
			     RETURN_MASK_ALL))
	    printf_unfiltered ("stepi errored\n");
	  result = TRUE;
	  break;
	case STATE_CHANGE_NEXTI:
	  if (!catch_errors ((catch_errors_ftype *) ice_nexti, (PTR) (int) lParam, "",
			     RETURN_MASK_ALL))
	    printf_unfiltered ("nexti errored\n");
	  result = TRUE;
	  break;
	}
d342 1
a342 1
	error ("Cannot load necmsg.dll");
d344 6
a349 6
      ExeAppReq = (long (*)PARAMS ((char *, long, char *, struct MessageIO *)))
	GetProcAddress (handle, "ExeAppReq");
      RegisterClient = (long (*)PARAMS ((HWND)))
	GetProcAddress (handle, "RegisterClient");
      UnregisterClient = (long (*)PARAMS ((void)))
	GetProcAddress (handle, "UnregisterClient");
d352 1
a352 1
	error ("Could not find requisite functions in necmsg.dll.");
d355 1
a355 1
	error ("could not initialize message handling");
d418 3
a420 3
  long retval;
  char buf[256];
  struct MessageIO iob;
d423 1
a423 1
  iob.buf = buf;
d446 1
a446 1
  struct MessageIO iob;
d451 2
a452 2
  iob.buf = buf;

d456 2
a457 2
	{
	  ui_loop_hook (0);
d459 1
a459 1
	}
d464 27
a490 27
	{
	case ICE_Idle:
	case ICE_Breakpoint:
	case ICE_Stepped:
	case ICE_Halted:
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_TRAP;
	  done = 1;
	  break;
	case ICE_Exception:
	  status->kind = TARGET_WAITKIND_SIGNALLED;
	  status->value.sig = TARGET_SIGNAL_SEGV;
	  done = 1;
	  break;
	case ICE_Exited:
	  status->kind = TARGET_WAITKIND_EXITED;
	  status->value.integer = 0;
	  done = 1;
	  break;
	case ICE_Terminated:
	  status->kind = TARGET_WAITKIND_SIGNALLED;
	  status->value.sig = TARGET_SIGNAL_KILL;
	  done = 1;
	  break;
	default:
	  break;
	}
d493 1
a493 1

d532 1
a532 1
	v850ice_fetch_registers (regno);
d549 1
a549 1
	   regno, val);
d578 1
a578 1
				     REGISTER_RAW_SIZE (regno));
d592 1
a592 1
static void
d610 1
a610 1
     struct target_ops *target;	/* ignored */
d620 17
a636 26
	{
	  long value = 0;
	  char buf[256];
	  char c;

	  iob.size = 0;
	  iob.buf = buf;

	  sent = 0;
	  switch (len)
	    {
	    case 4:
	      c = 'w';
	      value |= (long) ((myaddr[3] << 24) & 0xff000000);
	      value |= (long) ((myaddr[2] << 16) & 0x00ff0000);
	      value |= (long) ((myaddr[1] << 8) & 0x0000ff00);
	      value |= (long) (myaddr[0] & 0x000000ff);
	      break;
	    case 2:
	      c = 'h';
	      value |= (long) ((myaddr[1] << 8) & 0xff00);
	      value |= (long) (myaddr[0] & 0x00ff);
	      break;
	    case 1:
	      c = 'b';
	      value |= (long) (myaddr[0] & 0xff);
d638 34
a671 25
	    }

	  sprintf (cmd, "memory %c c 0x%x=0x%x", c, (int) memaddr, value);
	  retval = ExeAppReq ("GDB", GWRITEMEM, cmd, &iob);
	  if (retval == 0)
	    sent = len;
	}
      else
	{
	  sent = 0;
	  do
	    {
	      iob.size = len > MAX_BLOCK_SIZE ? MAX_BLOCK_SIZE : len;
	      iob.buf = myaddr;
	      sprintf (cmd, "memory b c 0x%x=0x00 l=%d", (int) memaddr, iob.size);
	      retval = ExeAppReq ("GDB", GWRITEBLOCK, cmd, &iob);
	      if (retval != 0)
		break;
	      len -= iob.size;
	      memaddr += iob.size;
	      myaddr += iob.size;
	      sent += iob.size;
	    }
	  while (len > 0);
	}
d678 1
a678 1

d685 12
a696 12
	{
	  iob.size = len > MAX_BLOCK_SIZE ? MAX_BLOCK_SIZE : len;
	  iob.buf = tmp;
	  sprintf (cmd, "memory b 0x%x l=%d", (int) memaddr, iob.size);
	  retval = ExeAppReq ("GDB", GREADBLOCK, cmd, &iob);
	  if (retval != 0)
	    break;
	  len -= iob.size;
	  memaddr += iob.size;
	  sent += iob.size;
	  tmp += iob.size;
	}
d700 11
a710 11
	{
	  for (i = 0; i < 100; i++)
	    {
	      if (t[sent + i] != 0xff)
		{
		  warning ("GREADBLOCK trashed bytes after transfer area.");
		  break;
		}
	    }
	  memcpy (myaddr, t, sent);
	}
d712 1
a712 1

d715 1
a715 1

d737 1
a737 1
  iob.buf = buf;
d758 1
a758 1
  iob.buf = buf;
d783 2
a784 2
     char *filename;
     int from_tty;
d790 2
a791 2
  iob.buf = buf;
  generic_load (filename, from_tty);
d800 1
a800 1

d810 1
a810 1
	*s = '/';
d815 1
a815 1
  delete_command (NULL, 0);
d834 1
a834 1
     char *c;
d864 1
a864 1
     char *c;
d874 1
a874 1
     char *c;
d884 2
a885 2
     char *arg;
     int from_tty;
d903 2
a904 2
static void
init_850ice_ops (void)
d906 34
a939 34
  v850ice_ops.to_shortname = "ice";
  v850ice_ops.to_longname = "NEC V850 ICE interface";
  v850ice_ops.to_doc = "Debug a system controlled by a NEC 850 ICE.";
  v850ice_ops.to_open = v850ice_open;
  v850ice_ops.to_close = v850ice_close;
  v850ice_ops.to_attach = NULL;
  v850ice_ops.to_post_attach = NULL;
  v850ice_ops.to_require_attach = NULL;
  v850ice_ops.to_detach = v850ice_detach;
  v850ice_ops.to_require_detach = NULL;
  v850ice_ops.to_resume = v850ice_resume;
  v850ice_ops.to_wait = v850ice_wait;
  v850ice_ops.to_post_wait = NULL;
  v850ice_ops.to_fetch_registers = v850ice_fetch_registers;
  v850ice_ops.to_store_registers = v850ice_store_registers;
  v850ice_ops.to_prepare_to_store = v850ice_prepare_to_store;
  v850ice_ops.to_xfer_memory = v850ice_xfer_memory;
  v850ice_ops.to_files_info = v850ice_files_info;
  v850ice_ops.to_insert_breakpoint = v850ice_insert_breakpoint;
  v850ice_ops.to_remove_breakpoint = v850ice_remove_breakpoint;
  v850ice_ops.to_terminal_init = NULL;
  v850ice_ops.to_terminal_inferior = NULL;
  v850ice_ops.to_terminal_ours_for_output = NULL;
  v850ice_ops.to_terminal_ours = NULL;
  v850ice_ops.to_terminal_info = NULL;
  v850ice_ops.to_kill = v850ice_kill;
  v850ice_ops.to_load = v850ice_load;
  v850ice_ops.to_lookup_symbol = NULL;
  v850ice_ops.to_create_inferior = NULL;
  v850ice_ops.to_mourn_inferior = v850ice_mourn;
  v850ice_ops.to_can_run = 0;
  v850ice_ops.to_notice_signals = 0;
  v850ice_ops.to_thread_alive = NULL;
  v850ice_ops.to_stop = v850ice_stop;
d941 11
a951 11
  v850ice_ops.to_core_file_to_sym_file = NULL;
  v850ice_ops.to_stratum = process_stratum;
  v850ice_ops.DONT_USE = NULL;
  v850ice_ops.to_has_all_memory = 1;
  v850ice_ops.to_has_memory = 1;
  v850ice_ops.to_has_stack = 1;
  v850ice_ops.to_has_registers = 1;
  v850ice_ops.to_has_execution = 1;
  v850ice_ops.to_sections = NULL;
  v850ice_ops.to_sections_end = NULL;
  v850ice_ops.to_magic = OPS_MAGIC;
d961 1
a961 1
	   "Send command to ICE");
@


1.1.1.3
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright 1996, 2000 Free Software Foundation, Inc.
d110 1
a110 1
static void ice_fputs (const char *, struct ui_file *);
@


1.1.1.4
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@a33 1
#include <tcl.h>
a121 2
static void view_source PARAMS ((CORE_ADDR));

a133 1
extern Tcl_Interp *gdbtk_interp;
a258 1
      view_source ((CORE_ADDR) lParam);
a839 2
  if (gdbtk_interp == NULL)
    {
a840 3
    }
  else
    Tcl_Eval (gdbtk_interp, "gdb_immediate continue");
a857 2
      if (gdbtk_interp == NULL)
	{
a858 3
	}
      else
	Tcl_Eval (gdbtk_interp, cmd);
a898 2
  if (gdbtk_interp != NULL)
    Tcl_Eval (gdbtk_interp, "gdbtk_update");
a900 12
static void
view_source (addr)
     CORE_ADDR addr;
{
  char c[256];

  if (gdbtk_interp != NULL)
    {
      sprintf (c, "catch {set src [lindex [ManagedWin::find SrcWin] 0]\n$src location BROWSE [gdb_loc *0x%x]}", addr);
      Tcl_Eval (gdbtk_interp, c);
    }
}
@


