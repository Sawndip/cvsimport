head	1.3;
access;
symbols
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.1.1.4
	gdb-pre-protoization-2000-07-29:1.1.1.4
	gdb-premipsmulti-2000-06-06-branch:1.1.1.4.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.4
	gdb-post-params-removal-2000-06-04:1.1.1.4
	gdb-pre-params-removal-2000-06-04:1.1.1.4
	gdb-post-params-removal-2000-05-28:1.1.1.4
	gdb-pre-params-removal-2000-05-28:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.4
	gdb-1999-10-25:1.1.1.4
	gdb-1999-10-18:1.1.1.4
	gdb-1999-10-11:1.1.1.4
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.4
	gdb-1999-09-13:1.1.1.4
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.3
date	2001.02.08.06.30.24;	author cagney;	state dead;
branches;
next	1.2;

1.2
date	2000.12.15.01.01.48;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.00;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.17.22.38;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.08.51;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Remove configurations marked as obsolete in 5.0.
@
text
@/* OBSOLETE /* Low level Pyramid interface to ptrace, for GDB when running under Unix. */
/* OBSOLETE    Copyright (C) 1988, 1989, 1991 Free Software Foundation, Inc. */
/* OBSOLETE  */
/* OBSOLETE This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE This program is free software; you can redistribute it and/or modify */
/* OBSOLETE it under the terms of the GNU General Public License as published by */
/* OBSOLETE the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE This program is distributed in the hope that it will be useful, */
/* OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE You should have received a copy of the GNU General Public License */
/* OBSOLETE along with this program; if not, write to the Free Software */
/* OBSOLETE Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "frame.h" */
/* OBSOLETE #include "inferior.h" */
/* OBSOLETE  */
/* OBSOLETE #include <sys/param.h> */
/* OBSOLETE #include <sys/dir.h> */
/* OBSOLETE #include <signal.h> */
/* OBSOLETE #include <sys/ioctl.h> */
/* OBSOLETE /* #include <fcntl.h>  Can we live without this?  *x/ */
/* OBSOLETE  */
/* OBSOLETE #include "gdbcore.h" */
/* OBSOLETE #include <sys/user.h>               /* After a.out.h  *x/ */
/* OBSOLETE #include <sys/file.h> */
/* OBSOLETE #include "gdb_stat.h" */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE fetch_inferior_registers (regno) */
/* OBSOLETE      int regno; */
/* OBSOLETE { */
/* OBSOLETE   register int datum; */
/* OBSOLETE   register unsigned int regaddr; */
/* OBSOLETE   int reg_buf[NUM_REGS+1]; */
/* OBSOLETE   struct user u; */
/* OBSOLETE   register int skipped_frames = 0; */
/* OBSOLETE  */
/* OBSOLETE   registers_fetched (); */
/* OBSOLETE    */
/* OBSOLETE   for (regno = 0; regno < 64; regno++) { */
/* OBSOLETE     reg_buf[regno] = ptrace (3, inferior_pid, (PTRACE_ARG3_TYPE) regno, 0); */
/* OBSOLETE      */
/* OBSOLETE #if defined(PYRAMID_CONTROL_FRAME_DEBUGGING) */
/* OBSOLETE     printf_unfiltered ("Fetching register %s, got %0x\n", */
/* OBSOLETE         REGISTER_NAME (regno), */
/* OBSOLETE         reg_buf[regno]); */
/* OBSOLETE #endif /* PYRAMID_CONTROL_FRAME_DEBUGGING *x/ */
/* OBSOLETE      */
/* OBSOLETE     if (reg_buf[regno] == -1 && errno == EIO) { */
/* OBSOLETE       printf_unfiltered("fetch_interior_registers: fetching register %s\n", */
/* OBSOLETE          REGISTER_NAME (regno)); */
/* OBSOLETE       errno = 0; */
/* OBSOLETE     } */
/* OBSOLETE     supply_register (regno, reg_buf+regno); */
/* OBSOLETE   } */
/* OBSOLETE   /* that leaves regs 64, 65, and 66 *x/ */
/* OBSOLETE   datum = ptrace (3, inferior_pid, */
/* OBSOLETE               (PTRACE_ARG3_TYPE) (((char *)&u.u_pcb.pcb_csp) - */
/* OBSOLETE               ((char *)&u)), 0); */
/* OBSOLETE    */
/* OBSOLETE    */
/* OBSOLETE    */
/* OBSOLETE   /* FIXME: Find the Current Frame Pointer (CFP). CFP is a global */
/* OBSOLETE      register (ie, NOT windowed), that gets saved in a frame iff */
/* OBSOLETE      the code for that frame has a prologue (ie, "adsf N").  If */
/* OBSOLETE      there is a prologue, the adsf insn saves the old cfp in */
/* OBSOLETE      pr13, cfp is set to sp, and N bytes of locals are allocated */
/* OBSOLETE      (sp is decremented by n). */
/* OBSOLETE      This makes finding CFP hard. I guess the right way to do it */
/* OBSOLETE      is:  */
/* OBSOLETE      - If this is the innermost frame, believe ptrace() or */
/* OBSOLETE      the core area. */
/* OBSOLETE      - Otherwise: */
/* OBSOLETE      Find the first insn of the current frame. */
/* OBSOLETE      - find the saved pc; */
/* OBSOLETE      - find the call insn that saved it; */
/* OBSOLETE      - figure out where the call is to; */
/* OBSOLETE      - if the first insn is an adsf, we got a frame */
/* OBSOLETE      pointer. *x/ */
/* OBSOLETE    */
/* OBSOLETE    */
/* OBSOLETE   /* Normal processors have separate stack pointers for user and */
/* OBSOLETE      kernel mode. Getting the last user mode frame on such */
/* OBSOLETE      machines is easy: the kernel context of the ptrace()'d */
/* OBSOLETE      process is on the kernel stack, and the USP points to what */
/* OBSOLETE      we want. But Pyramids only have a single cfp for both user and */
/* OBSOLETE      kernel mode.  And processes being ptrace()'d have some */
/* OBSOLETE      kernel-context control frames on their stack. */
/* OBSOLETE      To avoid tracing back into the kernel context of an inferior, */
/* OBSOLETE      we skip 0 or more contiguous control frames where the pc is */
/* OBSOLETE      in the kernel. *x/  */
/* OBSOLETE    */
/* OBSOLETE   while (1) { */
/* OBSOLETE     register int inferior_saved_pc; */
/* OBSOLETE     inferior_saved_pc = ptrace (1, inferior_pid, */
/* OBSOLETE                             (PTRACE_ARG3_TYPE) (datum+((32+15)*4)), 0); */
/* OBSOLETE     if (inferior_saved_pc > 0) break; */
/* OBSOLETE #if defined(PYRAMID_CONTROL_FRAME_DEBUGGING) */
/* OBSOLETE     printf_unfiltered("skipping kernel frame %08x, pc=%08x\n", datum, */
/* OBSOLETE        inferior_saved_pc); */
/* OBSOLETE #endif /* PYRAMID_CONTROL_FRAME_DEBUGGING *x/ */
/* OBSOLETE     skipped_frames++; */
/* OBSOLETE     datum -= CONTROL_STACK_FRAME_SIZE; */
/* OBSOLETE   } */
/* OBSOLETE    */
/* OBSOLETE   reg_buf[CSP_REGNUM] = datum; */
/* OBSOLETE   supply_register(CSP_REGNUM, reg_buf+CSP_REGNUM); */
/* OBSOLETE #ifdef  PYRAMID_CONTROL_FRAME_DEBUGGING */
/* OBSOLETE   if (skipped_frames) { */
/* OBSOLETE     fprintf_unfiltered (gdb_stderr, */
/* OBSOLETE          "skipped %d frames from %x to %x; cfp was %x, now %x\n", */
/* OBSOLETE          skipped_frames, reg_buf[CSP_REGNUM]); */
/* OBSOLETE   } */
/* OBSOLETE #endif /* PYRAMID_CONTROL_FRAME_DEBUGGING *x/ */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Store our register values back into the inferior. */
/* OBSOLETE    If REGNO is -1, do this for all registers. */
/* OBSOLETE    Otherwise, REGNO specifies which register (so we can save time).  *x/ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE store_inferior_registers (regno) */
/* OBSOLETE      int regno; */
/* OBSOLETE { */
/* OBSOLETE   register unsigned int regaddr; */
/* OBSOLETE   char buf[80]; */
/* OBSOLETE  */
/* OBSOLETE   if (regno >= 0) */
/* OBSOLETE     { */
/* OBSOLETE       if ((0 <= regno) && (regno < 64)) { */
/* OBSOLETE     /*regaddr = register_addr (regno, offset);*x/ */
/* OBSOLETE     regaddr = regno; */
/* OBSOLETE     errno = 0; */
/* OBSOLETE     ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, */
/* OBSOLETE             read_register (regno)); */
/* OBSOLETE     if (errno != 0) */
/* OBSOLETE       { */
/* OBSOLETE         sprintf (buf, "writing register number %d", regno); */
/* OBSOLETE         perror_with_name (buf); */
/* OBSOLETE       } */
/* OBSOLETE       } */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       for (regno = 0; regno < NUM_REGS; regno++) */
/* OBSOLETE     { */
/* OBSOLETE       /*regaddr = register_addr (regno, offset);*x/ */
/* OBSOLETE       regaddr = regno; */
/* OBSOLETE       errno = 0; */
/* OBSOLETE       ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, */
/* OBSOLETE               read_register (regno)); */
/* OBSOLETE       if (errno != 0) */
/* OBSOLETE         { */
/* OBSOLETE           sprintf (buf, "writing all regs, number %d", regno); */
/* OBSOLETE           perror_with_name (buf); */
/* OBSOLETE         } */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /*** Extensions to  core and dump files, for GDB. *x/ */
/* OBSOLETE  */
/* OBSOLETE extern unsigned int last_frame_offset; */
/* OBSOLETE  */
/* OBSOLETE #ifdef PYRAMID_CORE */
/* OBSOLETE  */
/* OBSOLETE /* Can't make definitions here static, since corefile.c needs them */
/* OBSOLETE    to do bounds checking on the core-file areas. O well. *x/ */
/* OBSOLETE  */
/* OBSOLETE /* have two stacks: one for data, one for register windows. *x/ */
/* OBSOLETE extern CORE_ADDR reg_stack_start; */
/* OBSOLETE extern CORE_ADDR reg_stack_end; */
/* OBSOLETE  */
/* OBSOLETE /* need this so we can find the global registers: they never get saved. *x/ */
/* OBSOLETE CORE_ADDR global_reg_offset; */
/* OBSOLETE static CORE_ADDR last_frame_address; */
/* OBSOLETE CORE_ADDR last_frame_offset; */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Address in core file of start of register window stack area. */
/* OBSOLETE    Don't know if is this any of meaningful, useful or necessary.   *x/ */
/* OBSOLETE extern int reg_stack_offset; */
/* OBSOLETE  */
/* OBSOLETE #endif /* PYRAMID_CORE *x/   */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Work with core dump and executable files, for GDB.  */
/* OBSOLETE    This code would be in corefile.c if it weren't machine-dependent. *x/ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE core_file_command (filename, from_tty) */
/* OBSOLETE      char *filename; */
/* OBSOLETE      int from_tty; */
/* OBSOLETE { */
/* OBSOLETE   int val; */
/* OBSOLETE  */
/* OBSOLETE   /* Discard all vestiges of any previous core file */
/* OBSOLETE      and mark data and stack spaces as empty.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (corefile) */
/* OBSOLETE     xfree (corefile); */
/* OBSOLETE   corefile = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (corechan >= 0) */
/* OBSOLETE     close (corechan); */
/* OBSOLETE   corechan = -1; */
/* OBSOLETE  */
/* OBSOLETE   data_start = 0; */
/* OBSOLETE   data_end = 0; */
/* OBSOLETE   stack_start = STACK_END_ADDR; */
/* OBSOLETE   stack_end = STACK_END_ADDR; */
/* OBSOLETE  */
/* OBSOLETE #ifdef PYRAMID_CORE */
/* OBSOLETE   reg_stack_start = CONTROL_STACK_ADDR; */
/* OBSOLETE   reg_stack_end = CONTROL_STACK_ADDR;       /* this isn't strictly true...*x/ */
/* OBSOLETE #endif /* PYRAMID_CORE *x/ */
/* OBSOLETE  */
/* OBSOLETE   /* Now, if a new core file was specified, open it and digest it.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (filename) */
/* OBSOLETE     { */
/* OBSOLETE       filename = tilde_expand (filename); */
/* OBSOLETE       make_cleanup (xfree, filename); */
/* OBSOLETE        */
/* OBSOLETE       if (have_inferior_p ()) */
/* OBSOLETE     error ("To look at a core file, you must kill the program with \"kill\"."); */
/* OBSOLETE       corechan = open (filename, O_RDONLY, 0); */
/* OBSOLETE       if (corechan < 0) */
/* OBSOLETE     perror_with_name (filename); */
/* OBSOLETE       /* 4.2-style (and perhaps also sysV-style) core dump file.  *x/ */
/* OBSOLETE       { */
/* OBSOLETE     struct user u; */
/* OBSOLETE  */
/* OBSOLETE     unsigned int reg_offset; */
/* OBSOLETE  */
/* OBSOLETE     val = myread (corechan, &u, sizeof u); */
/* OBSOLETE     if (val < 0) */
/* OBSOLETE       perror_with_name ("Not a core file: reading upage"); */
/* OBSOLETE     if (val != sizeof u) */
/* OBSOLETE       error ("Not a core file: could only read %d bytes", val); */
/* OBSOLETE     data_start = exec_data_start; */
/* OBSOLETE  */
/* OBSOLETE     data_end = data_start + NBPG * u.u_dsize; */
/* OBSOLETE     data_offset = NBPG * UPAGES; */
/* OBSOLETE     stack_offset = NBPG * (UPAGES + u.u_dsize); */
/* OBSOLETE  */
/* OBSOLETE     /* find registers in core file *x/ */
/* OBSOLETE #ifdef PYRAMID_PTRACE */
/* OBSOLETE     stack_start = stack_end - NBPG * u.u_ussize; */
/* OBSOLETE     reg_stack_offset = stack_offset + (NBPG *u.u_ussize); */
/* OBSOLETE     reg_stack_end = reg_stack_start + NBPG * u.u_cssize; */
/* OBSOLETE  */
/* OBSOLETE     last_frame_address = ((int) u.u_pcb.pcb_csp); */
/* OBSOLETE     last_frame_offset = reg_stack_offset + last_frame_address */
/* OBSOLETE             - CONTROL_STACK_ADDR ; */
/* OBSOLETE     global_reg_offset = (char *)&u - (char *)&u.u_pcb.pcb_gr0 ; */
/* OBSOLETE  */
/* OBSOLETE     /* skip any control-stack frames that were executed in the */
/* OBSOLETE        kernel. *x/ */
/* OBSOLETE  */
/* OBSOLETE     while (1) { */
/* OBSOLETE         char buf[4]; */
/* OBSOLETE         val = lseek (corechan, last_frame_offset+(47*4), 0); */
/* OBSOLETE         if (val < 0) */
/* OBSOLETE                 perror_with_name (filename); */
/* OBSOLETE         val = myread (corechan, buf, sizeof buf); */
/* OBSOLETE         if (val < 0) */
/* OBSOLETE                 perror_with_name (filename); */
/* OBSOLETE  */
/* OBSOLETE         if (*(int *)buf >= 0) */
/* OBSOLETE                 break; */
/* OBSOLETE         printf_unfiltered ("skipping frame %s\n", local_hex_string (last_frame_address)); */
/* OBSOLETE         last_frame_offset -= CONTROL_STACK_FRAME_SIZE; */
/* OBSOLETE         last_frame_address -= CONTROL_STACK_FRAME_SIZE; */
/* OBSOLETE     } */
/* OBSOLETE     reg_offset = last_frame_offset; */
/* OBSOLETE  */
/* OBSOLETE #if 1 || defined(PYRAMID_CONTROL_FRAME_DEBUGGING) */
/* OBSOLETE     printf_unfiltered ("Control stack pointer = %s\n", */
/* OBSOLETE             local_hex_string (u.u_pcb.pcb_csp)); */
/* OBSOLETE     printf_unfiltered ("offset to control stack %d outermost frame %d (%s)\n", */
/* OBSOLETE           reg_stack_offset, reg_offset, local_hex_string (last_frame_address)); */
/* OBSOLETE #endif /* PYRAMID_CONTROL_FRAME_DEBUGGING *x/ */
/* OBSOLETE  */
/* OBSOLETE #else /* not PYRAMID_CORE *x/ */
/* OBSOLETE     stack_start = stack_end - NBPG * u.u_ssize; */
/* OBSOLETE         reg_offset = (int) u.u_ar0 - KERNEL_U_ADDR; */
/* OBSOLETE #endif /* not PYRAMID_CORE *x/ */
/* OBSOLETE  */
/* OBSOLETE #ifdef __not_on_pyr_yet */
/* OBSOLETE     /* Some machines put an absolute address in here and some put */
/* OBSOLETE        the offset in the upage of the regs.  *x/ */
/* OBSOLETE     reg_offset = (int) u.u_ar0; */
/* OBSOLETE     if (reg_offset > NBPG * UPAGES) */
/* OBSOLETE       reg_offset -= KERNEL_U_ADDR; */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE     /* I don't know where to find this info. */
/* OBSOLETE        So, for now, mark it as not available.  *x/ */
/* OBSOLETE     N_SET_MAGIC (core_aouthdr, 0); */
/* OBSOLETE  */
/* OBSOLETE     /* Read the register values out of the core file and store */
/* OBSOLETE        them where `read_register' will find them.  *x/ */
/* OBSOLETE  */
/* OBSOLETE     { */
/* OBSOLETE       register int regno; */
/* OBSOLETE  */
/* OBSOLETE       for (regno = 0; regno < 64; regno++) */
/* OBSOLETE         { */
/* OBSOLETE           char buf[MAX_REGISTER_RAW_SIZE]; */
/* OBSOLETE  */
/* OBSOLETE           val = lseek (corechan, register_addr (regno, reg_offset), 0); */
/* OBSOLETE           if (val < 0 */
/* OBSOLETE               || (val = myread (corechan, buf, sizeof buf)) < 0) */
/* OBSOLETE             { */
/* OBSOLETE               char * buffer = (char *) alloca (strlen (REGISTER_NAME (regno)) */
/* OBSOLETE                                                + 30); */
/* OBSOLETE               strcpy (buffer, "Reading register "); */
/* OBSOLETE               strcat (buffer, REGISTER_NAME (regno)); */
/* OBSOLETE                                                 */
/* OBSOLETE               perror_with_name (buffer); */
/* OBSOLETE             } */
/* OBSOLETE  */
/* OBSOLETE           if (val < 0) */
/* OBSOLETE             perror_with_name (filename); */
/* OBSOLETE #ifdef PYRAMID_CONTROL_FRAME_DEBUGGING */
/* OBSOLETE       printf_unfiltered ("[reg %s(%d), offset in file %s=0x%0x, addr =0x%0x, =%0x]\n", */
/* OBSOLETE           REGISTER_NAME (regno), regno, filename, */
/* OBSOLETE           register_addr(regno, reg_offset), */
/* OBSOLETE           regno * 4 + last_frame_address, */
/* OBSOLETE           *((int *)buf)); */
/* OBSOLETE #endif /* PYRAMID_CONTROL_FRAME_DEBUGGING *x/ */
/* OBSOLETE           supply_register (regno, buf); */
/* OBSOLETE         } */
/* OBSOLETE     } */
/* OBSOLETE       } */
/* OBSOLETE       if (filename[0] == '/') */
/* OBSOLETE     corefile = savestring (filename, strlen (filename)); */
/* OBSOLETE       else */
/* OBSOLETE     { */
/* OBSOLETE       corefile = concat (current_directory, "/", filename, NULL); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE #if 1 || defined(PYRAMID_CONTROL_FRAME_DEBUGGING) */
/* OBSOLETE       printf_unfiltered ("Providing CSP (%s) as nominal address of current frame.\n", */
/* OBSOLETE           local_hex_string(last_frame_address)); */
/* OBSOLETE #endif PYRAMID_CONTROL_FRAME_DEBUGGING */
/* OBSOLETE       /* FIXME: Which of the following is correct? *x/ */
/* OBSOLETE #if 0 */
/* OBSOLETE       set_current_frame ( create_new_frame (read_register (FP_REGNUM), */
/* OBSOLETE                                         read_pc ())); */
/* OBSOLETE #else */
/* OBSOLETE       set_current_frame ( create_new_frame (last_frame_address, */
/* OBSOLETE                                         read_pc ())); */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE       select_frame (get_current_frame (), 0); */
/* OBSOLETE       validate_files (); */
/* OBSOLETE     } */
/* OBSOLETE   else if (from_tty) */
/* OBSOLETE     printf_unfiltered ("No core file now.\n"); */
/* OBSOLETE } */
@


1.2
log
@Replace free() with xfree().
@
text
@@


1.1
log
@Initial revision
@
text
@d1 369
a369 370
/* Low level Pyramid interface to ptrace, for GDB when running under Unix.
   Copyright (C) 1988, 1989, 1991 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"
#include "inferior.h"

#include <sys/param.h>
#include <sys/dir.h>
#include <signal.h>
#include <sys/ioctl.h>
/* #include <fcntl.h>  Can we live without this?  */

#include "gdbcore.h"
#include <sys/user.h>		/* After a.out.h  */
#include <sys/file.h>
#include "gdb_stat.h"


void
fetch_inferior_registers (regno)
     int regno;
{
  register int datum;
  register unsigned int regaddr;
  int reg_buf[NUM_REGS+1];
  struct user u;
  register int skipped_frames = 0;

  registers_fetched ();
  
  for (regno = 0; regno < 64; regno++) {
    reg_buf[regno] = ptrace (3, inferior_pid, (PTRACE_ARG3_TYPE) regno, 0);
    
#if defined(PYRAMID_CONTROL_FRAME_DEBUGGING)
    printf_unfiltered ("Fetching register %s, got %0x\n",
	    REGISTER_NAME (regno),
	    reg_buf[regno]);
#endif /* PYRAMID_CONTROL_FRAME_DEBUGGING */
    
    if (reg_buf[regno] == -1 && errno == EIO) {
      printf_unfiltered("fetch_interior_registers: fetching register %s\n",
	     REGISTER_NAME (regno));
      errno = 0;
    }
    supply_register (regno, reg_buf+regno);
  }
  /* that leaves regs 64, 65, and 66 */
  datum = ptrace (3, inferior_pid,
		  (PTRACE_ARG3_TYPE) (((char *)&u.u_pcb.pcb_csp) -
		  ((char *)&u)), 0);
  
  
  
  /* FIXME: Find the Current Frame Pointer (CFP). CFP is a global
     register (ie, NOT windowed), that gets saved in a frame iff
     the code for that frame has a prologue (ie, "adsf N").  If
     there is a prologue, the adsf insn saves the old cfp in
     pr13, cfp is set to sp, and N bytes of locals are allocated
     (sp is decremented by n).
     This makes finding CFP hard. I guess the right way to do it
     is: 
     - If this is the innermost frame, believe ptrace() or
     the core area.
     - Otherwise:
     Find the first insn of the current frame.
     - find the saved pc;
     - find the call insn that saved it;
     - figure out where the call is to;
     - if the first insn is an adsf, we got a frame
     pointer. */
  
  
  /* Normal processors have separate stack pointers for user and
     kernel mode. Getting the last user mode frame on such
     machines is easy: the kernel context of the ptrace()'d
     process is on the kernel stack, and the USP points to what
     we want. But Pyramids only have a single cfp for both user and
     kernel mode.  And processes being ptrace()'d have some
     kernel-context control frames on their stack.
     To avoid tracing back into the kernel context of an inferior,
     we skip 0 or more contiguous control frames where the pc is
     in the kernel. */ 
  
  while (1) {
    register int inferior_saved_pc;
    inferior_saved_pc = ptrace (1, inferior_pid,
				(PTRACE_ARG3_TYPE) (datum+((32+15)*4)), 0);
    if (inferior_saved_pc > 0) break;
#if defined(PYRAMID_CONTROL_FRAME_DEBUGGING)
    printf_unfiltered("skipping kernel frame %08x, pc=%08x\n", datum,
	   inferior_saved_pc);
#endif /* PYRAMID_CONTROL_FRAME_DEBUGGING */
    skipped_frames++;
    datum -= CONTROL_STACK_FRAME_SIZE;
  }
  
  reg_buf[CSP_REGNUM] = datum;
  supply_register(CSP_REGNUM, reg_buf+CSP_REGNUM);
#ifdef  PYRAMID_CONTROL_FRAME_DEBUGGING
  if (skipped_frames) {
    fprintf_unfiltered (gdb_stderr,
	     "skipped %d frames from %x to %x; cfp was %x, now %x\n",
	     skipped_frames, reg_buf[CSP_REGNUM]);
  }
#endif /* PYRAMID_CONTROL_FRAME_DEBUGGING */
}

/* Store our register values back into the inferior.
   If REGNO is -1, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time).  */

void
store_inferior_registers (regno)
     int regno;
{
  register unsigned int regaddr;
  char buf[80];

  if (regno >= 0)
    {
      if ((0 <= regno) && (regno < 64)) {
	/*regaddr = register_addr (regno, offset);*/
	regaddr = regno;
	errno = 0;
	ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
		read_register (regno));
	if (errno != 0)
	  {
	    sprintf (buf, "writing register number %d", regno);
	    perror_with_name (buf);
	  }
      }
    }
  else
    {
      for (regno = 0; regno < NUM_REGS; regno++)
	{
	  /*regaddr = register_addr (regno, offset);*/
	  regaddr = regno;
	  errno = 0;
	  ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
		  read_register (regno));
	  if (errno != 0)
	    {
	      sprintf (buf, "writing all regs, number %d", regno);
	      perror_with_name (buf);
	    }
	}
}

/*** Extensions to  core and dump files, for GDB. */

extern unsigned int last_frame_offset;

#ifdef PYRAMID_CORE

/* Can't make definitions here static, since corefile.c needs them
   to do bounds checking on the core-file areas. O well. */

/* have two stacks: one for data, one for register windows. */
extern CORE_ADDR reg_stack_start;
extern CORE_ADDR reg_stack_end;

/* need this so we can find the global registers: they never get saved. */
CORE_ADDR global_reg_offset;
static CORE_ADDR last_frame_address;
CORE_ADDR last_frame_offset;


/* Address in core file of start of register window stack area.
   Don't know if is this any of meaningful, useful or necessary.   */
extern int reg_stack_offset;

#endif /* PYRAMID_CORE */  


/* Work with core dump and executable files, for GDB. 
   This code would be in corefile.c if it weren't machine-dependent. */

void
core_file_command (filename, from_tty)
     char *filename;
     int from_tty;
{
  int val;
  extern char registers[];

  /* Discard all vestiges of any previous core file
     and mark data and stack spaces as empty.  */

  if (corefile)
    free (corefile);
  corefile = 0;

  if (corechan >= 0)
    close (corechan);
  corechan = -1;

  data_start = 0;
  data_end = 0;
  stack_start = STACK_END_ADDR;
  stack_end = STACK_END_ADDR;

#ifdef PYRAMID_CORE
  reg_stack_start = CONTROL_STACK_ADDR;
  reg_stack_end = CONTROL_STACK_ADDR;	/* this isn't strictly true...*/
#endif /* PYRAMID_CORE */

  /* Now, if a new core file was specified, open it and digest it.  */

  if (filename)
    {
      filename = tilde_expand (filename);
      make_cleanup (free, filename);
      
      if (have_inferior_p ())
	error ("To look at a core file, you must kill the program with \"kill\".");
      corechan = open (filename, O_RDONLY, 0);
      if (corechan < 0)
	perror_with_name (filename);
      /* 4.2-style (and perhaps also sysV-style) core dump file.  */
      {
	struct user u;

	unsigned int reg_offset;

	val = myread (corechan, &u, sizeof u);
	if (val < 0)
	  perror_with_name ("Not a core file: reading upage");
	if (val != sizeof u)
	  error ("Not a core file: could only read %d bytes", val);
	data_start = exec_data_start;

	data_end = data_start + NBPG * u.u_dsize;
	data_offset = NBPG * UPAGES;
	stack_offset = NBPG * (UPAGES + u.u_dsize);

	/* find registers in core file */
#ifdef PYRAMID_PTRACE
	stack_start = stack_end - NBPG * u.u_ussize;
	reg_stack_offset = stack_offset + (NBPG *u.u_ussize);
	reg_stack_end = reg_stack_start + NBPG * u.u_cssize;

	last_frame_address = ((int) u.u_pcb.pcb_csp);
	last_frame_offset = reg_stack_offset + last_frame_address
		- CONTROL_STACK_ADDR ;
	global_reg_offset = (char *)&u - (char *)&u.u_pcb.pcb_gr0 ;

	/* skip any control-stack frames that were executed in the
	   kernel. */

	while (1) {
	    char buf[4];
	    val = lseek (corechan, last_frame_offset+(47*4), 0);
	    if (val < 0)
		    perror_with_name (filename);
	    val = myread (corechan, buf, sizeof buf);
	    if (val < 0)
		    perror_with_name (filename);

	    if (*(int *)buf >= 0)
		    break;
	    printf_unfiltered ("skipping frame %s\n", local_hex_string (last_frame_address));
	    last_frame_offset -= CONTROL_STACK_FRAME_SIZE;
	    last_frame_address -= CONTROL_STACK_FRAME_SIZE;
	}
	reg_offset = last_frame_offset;

#if 1 || defined(PYRAMID_CONTROL_FRAME_DEBUGGING)
	printf_unfiltered ("Control stack pointer = %s\n",
		local_hex_string (u.u_pcb.pcb_csp));
	printf_unfiltered ("offset to control stack %d outermost frame %d (%s)\n",
	      reg_stack_offset, reg_offset, local_hex_string (last_frame_address));
#endif /* PYRAMID_CONTROL_FRAME_DEBUGGING */

#else /* not PYRAMID_CORE */
	stack_start = stack_end - NBPG * u.u_ssize;
        reg_offset = (int) u.u_ar0 - KERNEL_U_ADDR;
#endif /* not PYRAMID_CORE */

#ifdef __not_on_pyr_yet
	/* Some machines put an absolute address in here and some put
	   the offset in the upage of the regs.  */
	reg_offset = (int) u.u_ar0;
	if (reg_offset > NBPG * UPAGES)
	  reg_offset -= KERNEL_U_ADDR;
#endif

	/* I don't know where to find this info.
	   So, for now, mark it as not available.  */
	N_SET_MAGIC (core_aouthdr, 0);

	/* Read the register values out of the core file and store
	   them where `read_register' will find them.  */

	{
	  register int regno;

	  for (regno = 0; regno < 64; regno++)
	    {
	      char buf[MAX_REGISTER_RAW_SIZE];

	      val = lseek (corechan, register_addr (regno, reg_offset), 0);
	      if (val < 0
		  || (val = myread (corechan, buf, sizeof buf)) < 0)
		{
		  char * buffer = (char *) alloca (strlen (REGISTER_NAME (regno))
						   + 30);
		  strcpy (buffer, "Reading register ");
		  strcat (buffer, REGISTER_NAME (regno));
						   
		  perror_with_name (buffer);
		}

	      if (val < 0)
		perror_with_name (filename);
#ifdef PYRAMID_CONTROL_FRAME_DEBUGGING
      printf_unfiltered ("[reg %s(%d), offset in file %s=0x%0x, addr =0x%0x, =%0x]\n",
	      REGISTER_NAME (regno), regno, filename,
	      register_addr(regno, reg_offset),
	      regno * 4 + last_frame_address,
	      *((int *)buf));
#endif /* PYRAMID_CONTROL_FRAME_DEBUGGING */
	      supply_register (regno, buf);
	    }
	}
      }
      if (filename[0] == '/')
	corefile = savestring (filename, strlen (filename));
      else
	{
	  corefile = concat (current_directory, "/", filename, NULL);
	}

#if 1 || defined(PYRAMID_CONTROL_FRAME_DEBUGGING)
      printf_unfiltered ("Providing CSP (%s) as nominal address of current frame.\n",
	      local_hex_string(last_frame_address));
#endif PYRAMID_CONTROL_FRAME_DEBUGGING
      /* FIXME: Which of the following is correct? */
#if 0
      set_current_frame ( create_new_frame (read_register (FP_REGNUM),
					    read_pc ()));
#else
      set_current_frame ( create_new_frame (last_frame_address,
					    read_pc ()));
#endif

      select_frame (get_current_frame (), 0);
      validate_files ();
    }
  else if (from_tty)
    printf_unfiltered ("No core file now.\n");
}
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d203 1
@


1.1.1.3
log
@import gdb-1999-07-07 pre reformat
@
text
@d1 369
a369 369
/* OBSOLETE /* Low level Pyramid interface to ptrace, for GDB when running under Unix. */
/* OBSOLETE    Copyright (C) 1988, 1989, 1991 Free Software Foundation, Inc. */
/* OBSOLETE  */
/* OBSOLETE This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE This program is free software; you can redistribute it and/or modify */
/* OBSOLETE it under the terms of the GNU General Public License as published by */
/* OBSOLETE the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE This program is distributed in the hope that it will be useful, */
/* OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE You should have received a copy of the GNU General Public License */
/* OBSOLETE along with this program; if not, write to the Free Software */
/* OBSOLETE Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "frame.h" */
/* OBSOLETE #include "inferior.h" */
/* OBSOLETE  */
/* OBSOLETE #include <sys/param.h> */
/* OBSOLETE #include <sys/dir.h> */
/* OBSOLETE #include <signal.h> */
/* OBSOLETE #include <sys/ioctl.h> */
/* OBSOLETE /* #include <fcntl.h>  Can we live without this?  *x/ */
/* OBSOLETE  */
/* OBSOLETE #include "gdbcore.h" */
/* OBSOLETE #include <sys/user.h>		/* After a.out.h  *x/ */
/* OBSOLETE #include <sys/file.h> */
/* OBSOLETE #include "gdb_stat.h" */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE fetch_inferior_registers (regno) */
/* OBSOLETE      int regno; */
/* OBSOLETE { */
/* OBSOLETE   register int datum; */
/* OBSOLETE   register unsigned int regaddr; */
/* OBSOLETE   int reg_buf[NUM_REGS+1]; */
/* OBSOLETE   struct user u; */
/* OBSOLETE   register int skipped_frames = 0; */
/* OBSOLETE  */
/* OBSOLETE   registers_fetched (); */
/* OBSOLETE    */
/* OBSOLETE   for (regno = 0; regno < 64; regno++) { */
/* OBSOLETE     reg_buf[regno] = ptrace (3, inferior_pid, (PTRACE_ARG3_TYPE) regno, 0); */
/* OBSOLETE      */
/* OBSOLETE #if defined(PYRAMID_CONTROL_FRAME_DEBUGGING) */
/* OBSOLETE     printf_unfiltered ("Fetching register %s, got %0x\n", */
/* OBSOLETE 	    REGISTER_NAME (regno), */
/* OBSOLETE 	    reg_buf[regno]); */
/* OBSOLETE #endif /* PYRAMID_CONTROL_FRAME_DEBUGGING *x/ */
/* OBSOLETE      */
/* OBSOLETE     if (reg_buf[regno] == -1 && errno == EIO) { */
/* OBSOLETE       printf_unfiltered("fetch_interior_registers: fetching register %s\n", */
/* OBSOLETE 	     REGISTER_NAME (regno)); */
/* OBSOLETE       errno = 0; */
/* OBSOLETE     } */
/* OBSOLETE     supply_register (regno, reg_buf+regno); */
/* OBSOLETE   } */
/* OBSOLETE   /* that leaves regs 64, 65, and 66 *x/ */
/* OBSOLETE   datum = ptrace (3, inferior_pid, */
/* OBSOLETE 		  (PTRACE_ARG3_TYPE) (((char *)&u.u_pcb.pcb_csp) - */
/* OBSOLETE 		  ((char *)&u)), 0); */
/* OBSOLETE    */
/* OBSOLETE    */
/* OBSOLETE    */
/* OBSOLETE   /* FIXME: Find the Current Frame Pointer (CFP). CFP is a global */
/* OBSOLETE      register (ie, NOT windowed), that gets saved in a frame iff */
/* OBSOLETE      the code for that frame has a prologue (ie, "adsf N").  If */
/* OBSOLETE      there is a prologue, the adsf insn saves the old cfp in */
/* OBSOLETE      pr13, cfp is set to sp, and N bytes of locals are allocated */
/* OBSOLETE      (sp is decremented by n). */
/* OBSOLETE      This makes finding CFP hard. I guess the right way to do it */
/* OBSOLETE      is:  */
/* OBSOLETE      - If this is the innermost frame, believe ptrace() or */
/* OBSOLETE      the core area. */
/* OBSOLETE      - Otherwise: */
/* OBSOLETE      Find the first insn of the current frame. */
/* OBSOLETE      - find the saved pc; */
/* OBSOLETE      - find the call insn that saved it; */
/* OBSOLETE      - figure out where the call is to; */
/* OBSOLETE      - if the first insn is an adsf, we got a frame */
/* OBSOLETE      pointer. *x/ */
/* OBSOLETE    */
/* OBSOLETE    */
/* OBSOLETE   /* Normal processors have separate stack pointers for user and */
/* OBSOLETE      kernel mode. Getting the last user mode frame on such */
/* OBSOLETE      machines is easy: the kernel context of the ptrace()'d */
/* OBSOLETE      process is on the kernel stack, and the USP points to what */
/* OBSOLETE      we want. But Pyramids only have a single cfp for both user and */
/* OBSOLETE      kernel mode.  And processes being ptrace()'d have some */
/* OBSOLETE      kernel-context control frames on their stack. */
/* OBSOLETE      To avoid tracing back into the kernel context of an inferior, */
/* OBSOLETE      we skip 0 or more contiguous control frames where the pc is */
/* OBSOLETE      in the kernel. *x/  */
/* OBSOLETE    */
/* OBSOLETE   while (1) { */
/* OBSOLETE     register int inferior_saved_pc; */
/* OBSOLETE     inferior_saved_pc = ptrace (1, inferior_pid, */
/* OBSOLETE 				(PTRACE_ARG3_TYPE) (datum+((32+15)*4)), 0); */
/* OBSOLETE     if (inferior_saved_pc > 0) break; */
/* OBSOLETE #if defined(PYRAMID_CONTROL_FRAME_DEBUGGING) */
/* OBSOLETE     printf_unfiltered("skipping kernel frame %08x, pc=%08x\n", datum, */
/* OBSOLETE 	   inferior_saved_pc); */
/* OBSOLETE #endif /* PYRAMID_CONTROL_FRAME_DEBUGGING *x/ */
/* OBSOLETE     skipped_frames++; */
/* OBSOLETE     datum -= CONTROL_STACK_FRAME_SIZE; */
/* OBSOLETE   } */
/* OBSOLETE    */
/* OBSOLETE   reg_buf[CSP_REGNUM] = datum; */
/* OBSOLETE   supply_register(CSP_REGNUM, reg_buf+CSP_REGNUM); */
/* OBSOLETE #ifdef  PYRAMID_CONTROL_FRAME_DEBUGGING */
/* OBSOLETE   if (skipped_frames) { */
/* OBSOLETE     fprintf_unfiltered (gdb_stderr, */
/* OBSOLETE 	     "skipped %d frames from %x to %x; cfp was %x, now %x\n", */
/* OBSOLETE 	     skipped_frames, reg_buf[CSP_REGNUM]); */
/* OBSOLETE   } */
/* OBSOLETE #endif /* PYRAMID_CONTROL_FRAME_DEBUGGING *x/ */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Store our register values back into the inferior. */
/* OBSOLETE    If REGNO is -1, do this for all registers. */
/* OBSOLETE    Otherwise, REGNO specifies which register (so we can save time).  *x/ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE store_inferior_registers (regno) */
/* OBSOLETE      int regno; */
/* OBSOLETE { */
/* OBSOLETE   register unsigned int regaddr; */
/* OBSOLETE   char buf[80]; */
/* OBSOLETE  */
/* OBSOLETE   if (regno >= 0) */
/* OBSOLETE     { */
/* OBSOLETE       if ((0 <= regno) && (regno < 64)) { */
/* OBSOLETE 	/*regaddr = register_addr (regno, offset);*x/ */
/* OBSOLETE 	regaddr = regno; */
/* OBSOLETE 	errno = 0; */
/* OBSOLETE 	ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, */
/* OBSOLETE 		read_register (regno)); */
/* OBSOLETE 	if (errno != 0) */
/* OBSOLETE 	  { */
/* OBSOLETE 	    sprintf (buf, "writing register number %d", regno); */
/* OBSOLETE 	    perror_with_name (buf); */
/* OBSOLETE 	  } */
/* OBSOLETE       } */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       for (regno = 0; regno < NUM_REGS; regno++) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /*regaddr = register_addr (regno, offset);*x/ */
/* OBSOLETE 	  regaddr = regno; */
/* OBSOLETE 	  errno = 0; */
/* OBSOLETE 	  ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, */
/* OBSOLETE 		  read_register (regno)); */
/* OBSOLETE 	  if (errno != 0) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      sprintf (buf, "writing all regs, number %d", regno); */
/* OBSOLETE 	      perror_with_name (buf); */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /*** Extensions to  core and dump files, for GDB. *x/ */
/* OBSOLETE  */
/* OBSOLETE extern unsigned int last_frame_offset; */
/* OBSOLETE  */
/* OBSOLETE #ifdef PYRAMID_CORE */
/* OBSOLETE  */
/* OBSOLETE /* Can't make definitions here static, since corefile.c needs them */
/* OBSOLETE    to do bounds checking on the core-file areas. O well. *x/ */
/* OBSOLETE  */
/* OBSOLETE /* have two stacks: one for data, one for register windows. *x/ */
/* OBSOLETE extern CORE_ADDR reg_stack_start; */
/* OBSOLETE extern CORE_ADDR reg_stack_end; */
/* OBSOLETE  */
/* OBSOLETE /* need this so we can find the global registers: they never get saved. *x/ */
/* OBSOLETE CORE_ADDR global_reg_offset; */
/* OBSOLETE static CORE_ADDR last_frame_address; */
/* OBSOLETE CORE_ADDR last_frame_offset; */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Address in core file of start of register window stack area. */
/* OBSOLETE    Don't know if is this any of meaningful, useful or necessary.   *x/ */
/* OBSOLETE extern int reg_stack_offset; */
/* OBSOLETE  */
/* OBSOLETE #endif /* PYRAMID_CORE *x/   */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Work with core dump and executable files, for GDB.  */
/* OBSOLETE    This code would be in corefile.c if it weren't machine-dependent. *x/ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE core_file_command (filename, from_tty) */
/* OBSOLETE      char *filename; */
/* OBSOLETE      int from_tty; */
/* OBSOLETE { */
/* OBSOLETE   int val; */
/* OBSOLETE  */
/* OBSOLETE   /* Discard all vestiges of any previous core file */
/* OBSOLETE      and mark data and stack spaces as empty.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (corefile) */
/* OBSOLETE     free (corefile); */
/* OBSOLETE   corefile = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (corechan >= 0) */
/* OBSOLETE     close (corechan); */
/* OBSOLETE   corechan = -1; */
/* OBSOLETE  */
/* OBSOLETE   data_start = 0; */
/* OBSOLETE   data_end = 0; */
/* OBSOLETE   stack_start = STACK_END_ADDR; */
/* OBSOLETE   stack_end = STACK_END_ADDR; */
/* OBSOLETE  */
/* OBSOLETE #ifdef PYRAMID_CORE */
/* OBSOLETE   reg_stack_start = CONTROL_STACK_ADDR; */
/* OBSOLETE   reg_stack_end = CONTROL_STACK_ADDR;	/* this isn't strictly true...*x/ */
/* OBSOLETE #endif /* PYRAMID_CORE *x/ */
/* OBSOLETE  */
/* OBSOLETE   /* Now, if a new core file was specified, open it and digest it.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (filename) */
/* OBSOLETE     { */
/* OBSOLETE       filename = tilde_expand (filename); */
/* OBSOLETE       make_cleanup (free, filename); */
/* OBSOLETE        */
/* OBSOLETE       if (have_inferior_p ()) */
/* OBSOLETE 	error ("To look at a core file, you must kill the program with \"kill\"."); */
/* OBSOLETE       corechan = open (filename, O_RDONLY, 0); */
/* OBSOLETE       if (corechan < 0) */
/* OBSOLETE 	perror_with_name (filename); */
/* OBSOLETE       /* 4.2-style (and perhaps also sysV-style) core dump file.  *x/ */
/* OBSOLETE       { */
/* OBSOLETE 	struct user u; */
/* OBSOLETE  */
/* OBSOLETE 	unsigned int reg_offset; */
/* OBSOLETE  */
/* OBSOLETE 	val = myread (corechan, &u, sizeof u); */
/* OBSOLETE 	if (val < 0) */
/* OBSOLETE 	  perror_with_name ("Not a core file: reading upage"); */
/* OBSOLETE 	if (val != sizeof u) */
/* OBSOLETE 	  error ("Not a core file: could only read %d bytes", val); */
/* OBSOLETE 	data_start = exec_data_start; */
/* OBSOLETE  */
/* OBSOLETE 	data_end = data_start + NBPG * u.u_dsize; */
/* OBSOLETE 	data_offset = NBPG * UPAGES; */
/* OBSOLETE 	stack_offset = NBPG * (UPAGES + u.u_dsize); */
/* OBSOLETE  */
/* OBSOLETE 	/* find registers in core file *x/ */
/* OBSOLETE #ifdef PYRAMID_PTRACE */
/* OBSOLETE 	stack_start = stack_end - NBPG * u.u_ussize; */
/* OBSOLETE 	reg_stack_offset = stack_offset + (NBPG *u.u_ussize); */
/* OBSOLETE 	reg_stack_end = reg_stack_start + NBPG * u.u_cssize; */
/* OBSOLETE  */
/* OBSOLETE 	last_frame_address = ((int) u.u_pcb.pcb_csp); */
/* OBSOLETE 	last_frame_offset = reg_stack_offset + last_frame_address */
/* OBSOLETE 		- CONTROL_STACK_ADDR ; */
/* OBSOLETE 	global_reg_offset = (char *)&u - (char *)&u.u_pcb.pcb_gr0 ; */
/* OBSOLETE  */
/* OBSOLETE 	/* skip any control-stack frames that were executed in the */
/* OBSOLETE 	   kernel. *x/ */
/* OBSOLETE  */
/* OBSOLETE 	while (1) { */
/* OBSOLETE 	    char buf[4]; */
/* OBSOLETE 	    val = lseek (corechan, last_frame_offset+(47*4), 0); */
/* OBSOLETE 	    if (val < 0) */
/* OBSOLETE 		    perror_with_name (filename); */
/* OBSOLETE 	    val = myread (corechan, buf, sizeof buf); */
/* OBSOLETE 	    if (val < 0) */
/* OBSOLETE 		    perror_with_name (filename); */
/* OBSOLETE  */
/* OBSOLETE 	    if (*(int *)buf >= 0) */
/* OBSOLETE 		    break; */
/* OBSOLETE 	    printf_unfiltered ("skipping frame %s\n", local_hex_string (last_frame_address)); */
/* OBSOLETE 	    last_frame_offset -= CONTROL_STACK_FRAME_SIZE; */
/* OBSOLETE 	    last_frame_address -= CONTROL_STACK_FRAME_SIZE; */
/* OBSOLETE 	} */
/* OBSOLETE 	reg_offset = last_frame_offset; */
/* OBSOLETE  */
/* OBSOLETE #if 1 || defined(PYRAMID_CONTROL_FRAME_DEBUGGING) */
/* OBSOLETE 	printf_unfiltered ("Control stack pointer = %s\n", */
/* OBSOLETE 		local_hex_string (u.u_pcb.pcb_csp)); */
/* OBSOLETE 	printf_unfiltered ("offset to control stack %d outermost frame %d (%s)\n", */
/* OBSOLETE 	      reg_stack_offset, reg_offset, local_hex_string (last_frame_address)); */
/* OBSOLETE #endif /* PYRAMID_CONTROL_FRAME_DEBUGGING *x/ */
/* OBSOLETE  */
/* OBSOLETE #else /* not PYRAMID_CORE *x/ */
/* OBSOLETE 	stack_start = stack_end - NBPG * u.u_ssize; */
/* OBSOLETE         reg_offset = (int) u.u_ar0 - KERNEL_U_ADDR; */
/* OBSOLETE #endif /* not PYRAMID_CORE *x/ */
/* OBSOLETE  */
/* OBSOLETE #ifdef __not_on_pyr_yet */
/* OBSOLETE 	/* Some machines put an absolute address in here and some put */
/* OBSOLETE 	   the offset in the upage of the regs.  *x/ */
/* OBSOLETE 	reg_offset = (int) u.u_ar0; */
/* OBSOLETE 	if (reg_offset > NBPG * UPAGES) */
/* OBSOLETE 	  reg_offset -= KERNEL_U_ADDR; */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE 	/* I don't know where to find this info. */
/* OBSOLETE 	   So, for now, mark it as not available.  *x/ */
/* OBSOLETE 	N_SET_MAGIC (core_aouthdr, 0); */
/* OBSOLETE  */
/* OBSOLETE 	/* Read the register values out of the core file and store */
/* OBSOLETE 	   them where `read_register' will find them.  *x/ */
/* OBSOLETE  */
/* OBSOLETE 	{ */
/* OBSOLETE 	  register int regno; */
/* OBSOLETE  */
/* OBSOLETE 	  for (regno = 0; regno < 64; regno++) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      char buf[MAX_REGISTER_RAW_SIZE]; */
/* OBSOLETE  */
/* OBSOLETE 	      val = lseek (corechan, register_addr (regno, reg_offset), 0); */
/* OBSOLETE 	      if (val < 0 */
/* OBSOLETE 		  || (val = myread (corechan, buf, sizeof buf)) < 0) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  char * buffer = (char *) alloca (strlen (REGISTER_NAME (regno)) */
/* OBSOLETE 						   + 30); */
/* OBSOLETE 		  strcpy (buffer, "Reading register "); */
/* OBSOLETE 		  strcat (buffer, REGISTER_NAME (regno)); */
/* OBSOLETE 						    */
/* OBSOLETE 		  perror_with_name (buffer); */
/* OBSOLETE 		} */
/* OBSOLETE  */
/* OBSOLETE 	      if (val < 0) */
/* OBSOLETE 		perror_with_name (filename); */
/* OBSOLETE #ifdef PYRAMID_CONTROL_FRAME_DEBUGGING */
/* OBSOLETE       printf_unfiltered ("[reg %s(%d), offset in file %s=0x%0x, addr =0x%0x, =%0x]\n", */
/* OBSOLETE 	      REGISTER_NAME (regno), regno, filename, */
/* OBSOLETE 	      register_addr(regno, reg_offset), */
/* OBSOLETE 	      regno * 4 + last_frame_address, */
/* OBSOLETE 	      *((int *)buf)); */
/* OBSOLETE #endif /* PYRAMID_CONTROL_FRAME_DEBUGGING *x/ */
/* OBSOLETE 	      supply_register (regno, buf); */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE       } */
/* OBSOLETE       if (filename[0] == '/') */
/* OBSOLETE 	corefile = savestring (filename, strlen (filename)); */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  corefile = concat (current_directory, "/", filename, NULL); */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE #if 1 || defined(PYRAMID_CONTROL_FRAME_DEBUGGING) */
/* OBSOLETE       printf_unfiltered ("Providing CSP (%s) as nominal address of current frame.\n", */
/* OBSOLETE 	      local_hex_string(last_frame_address)); */
/* OBSOLETE #endif PYRAMID_CONTROL_FRAME_DEBUGGING */
/* OBSOLETE       /* FIXME: Which of the following is correct? *x/ */
/* OBSOLETE #if 0 */
/* OBSOLETE       set_current_frame ( create_new_frame (read_register (FP_REGNUM), */
/* OBSOLETE 					    read_pc ())); */
/* OBSOLETE #else */
/* OBSOLETE       set_current_frame ( create_new_frame (last_frame_address, */
/* OBSOLETE 					    read_pc ())); */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE       select_frame (get_current_frame (), 0); */
/* OBSOLETE       validate_files (); */
/* OBSOLETE     } */
/* OBSOLETE   else if (from_tty) */
/* OBSOLETE     printf_unfiltered ("No core file now.\n"); */
/* OBSOLETE } */
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d31 1
a31 1
/* OBSOLETE #include <sys/user.h>               /* After a.out.h  *x/ */
d53 2
a54 2
/* OBSOLETE         REGISTER_NAME (regno), */
/* OBSOLETE         reg_buf[regno]); */
d59 1
a59 1
/* OBSOLETE          REGISTER_NAME (regno)); */
d66 2
a67 2
/* OBSOLETE               (PTRACE_ARG3_TYPE) (((char *)&u.u_pcb.pcb_csp) - */
/* OBSOLETE               ((char *)&u)), 0); */
d104 1
a104 1
/* OBSOLETE                             (PTRACE_ARG3_TYPE) (datum+((32+15)*4)), 0); */
d108 1
a108 1
/* OBSOLETE        inferior_saved_pc); */
d119 2
a120 2
/* OBSOLETE          "skipped %d frames from %x to %x; cfp was %x, now %x\n", */
/* OBSOLETE          skipped_frames, reg_buf[CSP_REGNUM]); */
d139 10
a148 10
/* OBSOLETE     /*regaddr = register_addr (regno, offset);*x/ */
/* OBSOLETE     regaddr = regno; */
/* OBSOLETE     errno = 0; */
/* OBSOLETE     ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, */
/* OBSOLETE             read_register (regno)); */
/* OBSOLETE     if (errno != 0) */
/* OBSOLETE       { */
/* OBSOLETE         sprintf (buf, "writing register number %d", regno); */
/* OBSOLETE         perror_with_name (buf); */
/* OBSOLETE       } */
d154 12
a165 12
/* OBSOLETE     { */
/* OBSOLETE       /*regaddr = register_addr (regno, offset);*x/ */
/* OBSOLETE       regaddr = regno; */
/* OBSOLETE       errno = 0; */
/* OBSOLETE       ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, */
/* OBSOLETE               read_register (regno)); */
/* OBSOLETE       if (errno != 0) */
/* OBSOLETE         { */
/* OBSOLETE           sprintf (buf, "writing all regs, number %d", regno); */
/* OBSOLETE           perror_with_name (buf); */
/* OBSOLETE         } */
/* OBSOLETE     } */
d222 1
a222 1
/* OBSOLETE   reg_stack_end = CONTROL_STACK_ADDR;       /* this isn't strictly true...*x/ */
d233 1
a233 1
/* OBSOLETE     error ("To look at a core file, you must kill the program with \"kill\"."); */
d236 1
a236 1
/* OBSOLETE     perror_with_name (filename); */
d239 1
a239 1
/* OBSOLETE     struct user u; */
d241 1
a241 1
/* OBSOLETE     unsigned int reg_offset; */
d243 10
a252 10
/* OBSOLETE     val = myread (corechan, &u, sizeof u); */
/* OBSOLETE     if (val < 0) */
/* OBSOLETE       perror_with_name ("Not a core file: reading upage"); */
/* OBSOLETE     if (val != sizeof u) */
/* OBSOLETE       error ("Not a core file: could only read %d bytes", val); */
/* OBSOLETE     data_start = exec_data_start; */
/* OBSOLETE  */
/* OBSOLETE     data_end = data_start + NBPG * u.u_dsize; */
/* OBSOLETE     data_offset = NBPG * UPAGES; */
/* OBSOLETE     stack_offset = NBPG * (UPAGES + u.u_dsize); */
d254 1
a254 1
/* OBSOLETE     /* find registers in core file *x/ */
d256 28
a283 28
/* OBSOLETE     stack_start = stack_end - NBPG * u.u_ussize; */
/* OBSOLETE     reg_stack_offset = stack_offset + (NBPG *u.u_ussize); */
/* OBSOLETE     reg_stack_end = reg_stack_start + NBPG * u.u_cssize; */
/* OBSOLETE  */
/* OBSOLETE     last_frame_address = ((int) u.u_pcb.pcb_csp); */
/* OBSOLETE     last_frame_offset = reg_stack_offset + last_frame_address */
/* OBSOLETE             - CONTROL_STACK_ADDR ; */
/* OBSOLETE     global_reg_offset = (char *)&u - (char *)&u.u_pcb.pcb_gr0 ; */
/* OBSOLETE  */
/* OBSOLETE     /* skip any control-stack frames that were executed in the */
/* OBSOLETE        kernel. *x/ */
/* OBSOLETE  */
/* OBSOLETE     while (1) { */
/* OBSOLETE         char buf[4]; */
/* OBSOLETE         val = lseek (corechan, last_frame_offset+(47*4), 0); */
/* OBSOLETE         if (val < 0) */
/* OBSOLETE                 perror_with_name (filename); */
/* OBSOLETE         val = myread (corechan, buf, sizeof buf); */
/* OBSOLETE         if (val < 0) */
/* OBSOLETE                 perror_with_name (filename); */
/* OBSOLETE  */
/* OBSOLETE         if (*(int *)buf >= 0) */
/* OBSOLETE                 break; */
/* OBSOLETE         printf_unfiltered ("skipping frame %s\n", local_hex_string (last_frame_address)); */
/* OBSOLETE         last_frame_offset -= CONTROL_STACK_FRAME_SIZE; */
/* OBSOLETE         last_frame_address -= CONTROL_STACK_FRAME_SIZE; */
/* OBSOLETE     } */
/* OBSOLETE     reg_offset = last_frame_offset; */
d286 4
a289 4
/* OBSOLETE     printf_unfiltered ("Control stack pointer = %s\n", */
/* OBSOLETE             local_hex_string (u.u_pcb.pcb_csp)); */
/* OBSOLETE     printf_unfiltered ("offset to control stack %d outermost frame %d (%s)\n", */
/* OBSOLETE           reg_stack_offset, reg_offset, local_hex_string (last_frame_address)); */
d293 1
a293 1
/* OBSOLETE     stack_start = stack_end - NBPG * u.u_ssize; */
d298 5
a302 5
/* OBSOLETE     /* Some machines put an absolute address in here and some put */
/* OBSOLETE        the offset in the upage of the regs.  *x/ */
/* OBSOLETE     reg_offset = (int) u.u_ar0; */
/* OBSOLETE     if (reg_offset > NBPG * UPAGES) */
/* OBSOLETE       reg_offset -= KERNEL_U_ADDR; */
d305 25
a329 6
/* OBSOLETE     /* I don't know where to find this info. */
/* OBSOLETE        So, for now, mark it as not available.  *x/ */
/* OBSOLETE     N_SET_MAGIC (core_aouthdr, 0); */
/* OBSOLETE  */
/* OBSOLETE     /* Read the register values out of the core file and store */
/* OBSOLETE        them where `read_register' will find them.  *x/ */
d331 2
a332 21
/* OBSOLETE     { */
/* OBSOLETE       register int regno; */
/* OBSOLETE  */
/* OBSOLETE       for (regno = 0; regno < 64; regno++) */
/* OBSOLETE         { */
/* OBSOLETE           char buf[MAX_REGISTER_RAW_SIZE]; */
/* OBSOLETE  */
/* OBSOLETE           val = lseek (corechan, register_addr (regno, reg_offset), 0); */
/* OBSOLETE           if (val < 0 */
/* OBSOLETE               || (val = myread (corechan, buf, sizeof buf)) < 0) */
/* OBSOLETE             { */
/* OBSOLETE               char * buffer = (char *) alloca (strlen (REGISTER_NAME (regno)) */
/* OBSOLETE                                                + 30); */
/* OBSOLETE               strcpy (buffer, "Reading register "); */
/* OBSOLETE               strcat (buffer, REGISTER_NAME (regno)); */
/* OBSOLETE                                                 */
/* OBSOLETE               perror_with_name (buffer); */
/* OBSOLETE             } */
/* OBSOLETE  */
/* OBSOLETE           if (val < 0) */
/* OBSOLETE             perror_with_name (filename); */
d335 4
a338 4
/* OBSOLETE           REGISTER_NAME (regno), regno, filename, */
/* OBSOLETE           register_addr(regno, reg_offset), */
/* OBSOLETE           regno * 4 + last_frame_address, */
/* OBSOLETE           *((int *)buf)); */
d340 3
a342 3
/* OBSOLETE           supply_register (regno, buf); */
/* OBSOLETE         } */
/* OBSOLETE     } */
d345 1
a345 1
/* OBSOLETE     corefile = savestring (filename, strlen (filename)); */
d347 3
a349 3
/* OBSOLETE     { */
/* OBSOLETE       corefile = concat (current_directory, "/", filename, NULL); */
/* OBSOLETE     } */
d353 1
a353 1
/* OBSOLETE           local_hex_string(last_frame_address)); */
d358 1
a358 1
/* OBSOLETE                                         read_pc ())); */
d361 1
a361 1
/* OBSOLETE                                         read_pc ())); */
@

