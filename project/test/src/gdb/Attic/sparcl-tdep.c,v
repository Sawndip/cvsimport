head	1.18;
access;
symbols
	gdb_6_0-2003-10-04-release:1.17
	kettenis_sparc-20030918-branch:1.17.0.22
	kettenis_sparc-20030918-branchpoint:1.17
	carlton_dictionary-20030917-merge:1.17
	ezannoni_pie-20030916-branchpoint:1.17
	ezannoni_pie-20030916-branch:1.17.0.20
	cagney_x86i386-20030821-branch:1.17.0.18
	cagney_x86i386-20030821-branchpoint:1.17
	carlton_dictionary-20030805-merge:1.17
	carlton_dictionary-20030627-merge:1.17
	gdb_6_0-branch:1.17.0.16
	gdb_6_0-2003-06-23-branchpoint:1.17
	jimb-ppc64-linux-20030613-branch:1.17.0.14
	jimb-ppc64-linux-20030613-branchpoint:1.17
	cagney_convert-20030606-branch:1.17.0.12
	cagney_convert-20030606-branchpoint:1.17
	cagney_writestrings-20030508-branch:1.17.0.10
	cagney_writestrings-20030508-branchpoint:1.17
	jimb-ppc64-linux-20030528-branch:1.17.0.8
	jimb-ppc64-linux-20030528-branchpoint:1.17
	carlton_dictionary-20030523-merge:1.17
	cagney_fileio-20030521-branch:1.17.0.6
	cagney_fileio-20030521-branchpoint:1.17
	kettenis_i386newframe-20030517-mergepoint:1.17
	jimb-ppc64-linux-20030509-branch:1.17.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.17
	kettenis_i386newframe-20030504-mergepoint:1.17
	carlton_dictionary-20030430-merge:1.17
	kettenis_i386newframe-20030419-branch:1.17.0.2
	kettenis_i386newframe-20030419-branchpoint:1.17
	carlton_dictionary-20030416-merge:1.17
	cagney_frameaddr-20030409-mergepoint:1.16
	kettenis_i386newframe-20030406-branch:1.16.0.28
	kettenis_i386newframe-20030406-branchpoint:1.16
	cagney_frameaddr-20030403-branchpoint:1.16
	cagney_frameaddr-20030403-branch:1.16.0.26
	cagney_framebase-20030330-mergepoint:1.16
	cagney_framebase-20030326-branch:1.16.0.24
	cagney_framebase-20030326-branchpoint:1.16
	cagney_lazyid-20030317-branch:1.16.0.22
	cagney_lazyid-20030317-branchpoint:1.16
	kettenis-i386newframe-20030316-mergepoint:1.16
	offbyone-20030313-branch:1.16.0.20
	offbyone-20030313-branchpoint:1.16
	kettenis-i386newframe-20030308-branch:1.16.0.18
	kettenis-i386newframe-20030308-branchpoint:1.16
	carlton_dictionary-20030305-merge:1.16
	cagney_offbyone-20030303-branch:1.16.0.16
	cagney_offbyone-20030303-branchpoint:1.16
	carlton_dictionary-20030207-merge:1.16
	interps-20030203-mergepoint:1.16
	interps-20030202-branch:1.16.0.14
	interps-20030202-branchpoint:1.16
	cagney-unwind-20030108-branch:1.16.0.12
	cagney-unwind-20030108-branchpoint:1.16
	carlton_dictionary-20021223-merge:1.16
	gdb_5_3-2002-12-12-release:1.16
	carlton_dictionary-20021115-merge:1.16
	kseitz_interps-20021105-merge:1.16
	kseitz_interps-20021103-merge:1.16
	drow-cplus-merge-20021020:1.16
	drow-cplus-merge-20021025:1.16
	carlton_dictionary-20021025-merge:1.16
	carlton_dictionary-20021011-merge:1.16
	drow-cplus-branch:1.16.0.10
	drow-cplus-branchpoint:1.16
	kseitz_interps-20020930-merge:1.16
	carlton_dictionary-20020927-merge:1.16
	carlton_dictionary-branch:1.16.0.8
	carlton_dictionary-20020920-branchpoint:1.16
	gdb_5_3-branch:1.16.0.6
	gdb_5_3-2002-09-04-branchpoint:1.16
	kseitz_interps-20020829-merge:1.16
	cagney_sysregs-20020825-branch:1.16.0.4
	cagney_sysregs-20020825-branchpoint:1.16
	readline_4_3-import-branch:1.16.0.2
	readline_4_3-import-branchpoint:1.16
	gdb_5_2_1-2002-07-23-release:1.15
	kseitz_interps-20020528-branch:1.15.0.8
	kseitz_interps-20020528-branchpoint:1.15
	cagney_regbuf-20020515-branch:1.15.0.6
	cagney_regbuf-20020515-branchpoint:1.15
	jimb-macro-020506-branch:1.15.0.4
	jimb-macro-020506-branchpoint:1.15
	gdb_5_2-2002-04-29-release:1.15
	gdb_5_2-branch:1.15.0.2
	gdb_5_2-2002-03-03-branchpoint:1.15
	gdb_5_1_1-2002-01-24-release:1.14
	gdb_5_1_0_1-2002-01-03-release:1.14
	cygnus_cvs_20020108_pre:1.15
	gdb_5_1_0_1-2002-01-03-branchpoint:1.14
	gdb_5_1_0_1-2002-01-03-branch:1.14.0.6
	gdb_5_1-2001-11-21-release:1.14
	gdb_s390-2001-09-26-branch:1.14.0.4
	gdb_s390-2001-09-26-branchpoint:1.14
	gdb_5_1-2001-07-29-branch:1.14.0.2
	gdb_5_1-2001-07-29-branchpoint:1.14
	dberlin-typesystem-branch:1.12.0.2
	dberlin-typesystem-branchpoint:1.12
	gdb-post-ptid_t-2001-05-03:1.12
	gdb-pre-ptid_t-2001-05-03:1.12
	insight-precleanup-2001-01-01:1.8
	gdb-post-protoization-2000-07-29:1.6
	gdb-pre-protoization-2000-07-29:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb-post-params-removal-2000-06-04:1.5
	gdb-pre-params-removal-2000-06-04:1.4
	gdb-post-params-removal-2000-05-28:1.4
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.1.1.6
	gdb_4_18_2-2000-05-18-release:1.1.1.6
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.6
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.6
	gdb_5_0-2000-04-10-branch:1.1.1.6.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.6
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.6
	gdb-1999-11-16:1.1.1.6
	gdb-1999-11-08:1.1.1.6
	gdb-1999-11-01:1.1.1.6
	gdb-1999-10-25:1.1.1.6
	gdb-1999-10-18:1.1.1.6
	gdb-1999-10-11:1.1.1.6
	gdb-1999-10-04:1.1.1.6
	gdb-1999-09-28:1.1.1.6
	gdb-1999-09-21:1.1.1.6
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.6
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.5
	gdb-1999-08-02:1.1.1.5
	gdb-1999-07-26:1.1.1.5
	gdb-1999-07-19:1.1.1.5
	gdb-1999-07-12:1.1.1.5
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.18
date	2003.10.06.19.10.44;	author cagney;	state dead;
branches;
next	1.17;

1.17
date	2003.04.16.14.32.21;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.08.20.34.40;	author cagney;	state Exp;
branches
	1.16.8.1
	1.16.10.1;
next	1.15;

1.15
date	2002.01.05.04.30.19;	author cagney;	state Exp;
branches
	1.15.6.1
	1.15.8.1;
next	1.14;

1.14
date	2001.07.15.20.34.14;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.11.17.52.32;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.06.08.21.17;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.31.01.24.02;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.15.01.01.49;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.23.03.21.06;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.22.09.02.23;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.16.02.43.39;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.05;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.05;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.05.17.54.00;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.17.23.14;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.10.11;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.12.11.07.01;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.31.01.06.04;	author jsm;	state Exp;
branches;
next	;

1.15.6.1
date	2002.06.15.16.42.55;	author cagney;	state Exp;
branches;
next	;

1.15.8.1
date	2002.06.20.01.33.06;	author kseitz;	state Exp;
branches;
next	;

1.16.8.1
date	2003.04.16.19.56.54;	author carlton;	state Exp;
branches;
next	1.16.8.2;

1.16.8.2
date	2003.11.11.23.50.57;	author carlton;	state dead;
branches;
next	;

1.16.10.1
date	2003.12.14.20.27.30;	author drow;	state dead;
branches;
next	;


desc
@@


1.18
log
@2003-10-06  Andrew Cagney  <cagney@@redhat.com>

	* z8k-tdep.c, symm-tdep.c, symm-nat.c: Delete obsolete file.
	* sparclet-stub.c, sparclet-rom.c: Delete obsolete file.
	* sparcl-tdep.c, sparcl-stub.c, h8500-tdep.c: Delete obsolete file.
	* m3-nat.c, mipsm3-nat.c, mn10200-tdep.c: Delete obsolete file.
@
text
@// OBSOLETE /* Target dependent code for the Fujitsu SPARClite for GDB, the GNU debugger.
// OBSOLETE    Copyright 1994, 1995, 1996, 1998, 1999, 2000, 2001
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "breakpoint.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "serial.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE #include <sys/types.h>
// OBSOLETE 
// OBSOLETE #if (!defined(__GO32__) && !defined(_WIN32)) || defined(__CYGWIN__)
// OBSOLETE #define HAVE_SOCKETS
// OBSOLETE #include <sys/time.h>
// OBSOLETE #include <sys/socket.h>
// OBSOLETE #include <netinet/in.h>
// OBSOLETE #include <netdb.h>
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE static struct target_ops sparclite_ops;
// OBSOLETE 
// OBSOLETE static char *remote_target_name = NULL;
// OBSOLETE static struct serial *remote_desc = NULL;
// OBSOLETE static int serial_flag;
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE static int udp_fd = -1;
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE static struct serial *open_tty (char *name);
// OBSOLETE static int send_resp (struct serial *desc, char c);
// OBSOLETE static void close_tty (void * ignore);
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE static int recv_udp_buf (int fd, unsigned char *buf, int len, int timeout);
// OBSOLETE static int send_udp_buf (int fd, unsigned char *buf, int len);
// OBSOLETE #endif
// OBSOLETE static void sparclite_open (char *name, int from_tty);
// OBSOLETE static void sparclite_close (int quitting);
// OBSOLETE static void download (char *target_name, char *args, int from_tty,
// OBSOLETE 		      void (*write_routine) (bfd * from_bfd,
// OBSOLETE 					     asection * from_sec,
// OBSOLETE 					     file_ptr from_addr,
// OBSOLETE 					     bfd_vma to_addr, int len),
// OBSOLETE 		      void (*start_routine) (bfd_vma entry));
// OBSOLETE static void sparclite_serial_start (bfd_vma entry);
// OBSOLETE static void sparclite_serial_write (bfd * from_bfd, asection * from_sec,
// OBSOLETE 				    file_ptr from_addr,
// OBSOLETE 				    bfd_vma to_addr, int len);
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE static unsigned short calc_checksum (unsigned char *buffer, int count);
// OBSOLETE static void sparclite_udp_start (bfd_vma entry);
// OBSOLETE static void sparclite_udp_write (bfd * from_bfd, asection * from_sec,
// OBSOLETE 				 file_ptr from_addr, bfd_vma to_addr,
// OBSOLETE 				 int len);
// OBSOLETE #endif
// OBSOLETE static void sparclite_download (char *filename, int from_tty);
// OBSOLETE 
// OBSOLETE #define DDA2_SUP_ASI		0xb000000
// OBSOLETE #define DDA1_SUP_ASI		0xb0000
// OBSOLETE 
// OBSOLETE #define DDA2_ASI_MASK 		0xff000000
// OBSOLETE #define DDA1_ASI_MASK 		0xff0000
// OBSOLETE #define DIA2_SUP_MODE 		0x8000
// OBSOLETE #define DIA1_SUP_MODE 		0x4000
// OBSOLETE #define DDA2_ENABLE 		0x100
// OBSOLETE #define DDA1_ENABLE 		0x80
// OBSOLETE #define DIA2_ENABLE 		0x40
// OBSOLETE #define DIA1_ENABLE 		0x20
// OBSOLETE #define DSINGLE_STEP 		0x10	/* not used */
// OBSOLETE #define DDV_TYPE_MASK 		0xc
// OBSOLETE #define DDV_TYPE_LOAD 		0x0
// OBSOLETE #define DDV_TYPE_STORE 		0x4
// OBSOLETE #define DDV_TYPE_ACCESS 	0x8
// OBSOLETE #define DDV_TYPE_ALWAYS		0xc
// OBSOLETE #define DDV_COND		0x2
// OBSOLETE #define DDV_MASK		0x1
// OBSOLETE 
// OBSOLETE int
// OBSOLETE sparclite_insert_watchpoint (CORE_ADDR addr, int len, int type)
// OBSOLETE {
// OBSOLETE   CORE_ADDR dcr;
// OBSOLETE 
// OBSOLETE   dcr = read_register (DCR_REGNUM);
// OBSOLETE 
// OBSOLETE   if (!(dcr & DDA1_ENABLE))
// OBSOLETE     {
// OBSOLETE       write_register (DDA1_REGNUM, addr);
// OBSOLETE       dcr &= ~(DDA1_ASI_MASK | DDV_TYPE_MASK);
// OBSOLETE       dcr |= (DDA1_SUP_ASI | DDA1_ENABLE);
// OBSOLETE       if (type == 1)
// OBSOLETE 	{
// OBSOLETE 	  write_register (DDV1_REGNUM, 0);
// OBSOLETE 	  write_register (DDV2_REGNUM, 0xffffffff);
// OBSOLETE 	  dcr |= (DDV_TYPE_LOAD & (~DDV_COND & ~DDV_MASK));
// OBSOLETE 	}
// OBSOLETE       else if (type == 0)
// OBSOLETE 	{
// OBSOLETE 	  write_register (DDV1_REGNUM, 0);
// OBSOLETE 	  write_register (DDV2_REGNUM, 0xffffffff);
// OBSOLETE 	  dcr |= (DDV_TYPE_STORE & (~DDV_COND & ~DDV_MASK));
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  write_register (DDV1_REGNUM, 0);
// OBSOLETE 	  write_register (DDV2_REGNUM, 0xffffffff);
// OBSOLETE 	  dcr |= (DDV_TYPE_ACCESS);
// OBSOLETE 	}
// OBSOLETE       write_register (DCR_REGNUM, dcr);
// OBSOLETE     }
// OBSOLETE   else if (!(dcr & DDA2_ENABLE))
// OBSOLETE     {
// OBSOLETE       write_register (DDA2_REGNUM, addr);
// OBSOLETE       dcr &= ~(DDA2_ASI_MASK & DDV_TYPE_MASK);
// OBSOLETE       dcr |= (DDA2_SUP_ASI | DDA2_ENABLE);
// OBSOLETE       if (type == 1)
// OBSOLETE 	{
// OBSOLETE 	  write_register (DDV1_REGNUM, 0);
// OBSOLETE 	  write_register (DDV2_REGNUM, 0xffffffff);
// OBSOLETE 	  dcr |= (DDV_TYPE_LOAD & ~DDV_COND & ~DDV_MASK);
// OBSOLETE 	}
// OBSOLETE       else if (type == 0)
// OBSOLETE 	{
// OBSOLETE 	  write_register (DDV1_REGNUM, 0);
// OBSOLETE 	  write_register (DDV2_REGNUM, 0xffffffff);
// OBSOLETE 	  dcr |= (DDV_TYPE_STORE & ~DDV_COND & ~DDV_MASK);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  write_register (DDV1_REGNUM, 0);
// OBSOLETE 	  write_register (DDV2_REGNUM, 0xffffffff);
// OBSOLETE 	  dcr |= (DDV_TYPE_ACCESS);
// OBSOLETE 	}
// OBSOLETE       write_register (DCR_REGNUM, dcr);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE sparclite_remove_watchpoint (CORE_ADDR addr, int len, int type)
// OBSOLETE {
// OBSOLETE   CORE_ADDR dcr, dda1, dda2;
// OBSOLETE 
// OBSOLETE   dcr = read_register (DCR_REGNUM);
// OBSOLETE   dda1 = read_register (DDA1_REGNUM);
// OBSOLETE   dda2 = read_register (DDA2_REGNUM);
// OBSOLETE 
// OBSOLETE   if ((dcr & DDA1_ENABLE) && addr == dda1)
// OBSOLETE     write_register (DCR_REGNUM, (dcr & ~DDA1_ENABLE));
// OBSOLETE   else if ((dcr & DDA2_ENABLE) && addr == dda2)
// OBSOLETE     write_register (DCR_REGNUM, (dcr & ~DDA2_ENABLE));
// OBSOLETE   else
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE sparclite_insert_hw_breakpoint (CORE_ADDR addr, int len)
// OBSOLETE {
// OBSOLETE   CORE_ADDR dcr;
// OBSOLETE 
// OBSOLETE   dcr = read_register (DCR_REGNUM);
// OBSOLETE 
// OBSOLETE   if (!(dcr & DIA1_ENABLE))
// OBSOLETE     {
// OBSOLETE       write_register (DIA1_REGNUM, addr);
// OBSOLETE       write_register (DCR_REGNUM, (dcr | DIA1_ENABLE | DIA1_SUP_MODE));
// OBSOLETE     }
// OBSOLETE   else if (!(dcr & DIA2_ENABLE))
// OBSOLETE     {
// OBSOLETE       write_register (DIA2_REGNUM, addr);
// OBSOLETE       write_register (DCR_REGNUM, (dcr | DIA2_ENABLE | DIA2_SUP_MODE));
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE sparclite_remove_hw_breakpoint (CORE_ADDR addr, int shadow)
// OBSOLETE {
// OBSOLETE   CORE_ADDR dcr, dia1, dia2;
// OBSOLETE 
// OBSOLETE   dcr = read_register (DCR_REGNUM);
// OBSOLETE   dia1 = read_register (DIA1_REGNUM);
// OBSOLETE   dia2 = read_register (DIA2_REGNUM);
// OBSOLETE 
// OBSOLETE   if ((dcr & DIA1_ENABLE) && addr == dia1)
// OBSOLETE     write_register (DCR_REGNUM, (dcr & ~DIA1_ENABLE));
// OBSOLETE   else if ((dcr & DIA2_ENABLE) && addr == dia2)
// OBSOLETE     write_register (DCR_REGNUM, (dcr & ~DIA2_ENABLE));
// OBSOLETE   else
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE sparclite_check_watch_resources (int type, int cnt, int ot)
// OBSOLETE {
// OBSOLETE   /* Watchpoints not supported on simulator.  */
// OBSOLETE   if (strcmp (target_shortname, "sim") == 0)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   if (type == bp_hardware_breakpoint)
// OBSOLETE     {
// OBSOLETE       if (TARGET_HW_BREAK_LIMIT == 0)
// OBSOLETE 	return 0;
// OBSOLETE       else if (cnt <= TARGET_HW_BREAK_LIMIT)
// OBSOLETE 	return 1;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if (TARGET_HW_WATCH_LIMIT == 0)
// OBSOLETE 	return 0;
// OBSOLETE       else if (ot)
// OBSOLETE 	return -1;
// OBSOLETE       else if (cnt <= TARGET_HW_WATCH_LIMIT)
// OBSOLETE 	return 1;
// OBSOLETE     }
// OBSOLETE   return -1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE sparclite_stopped_data_address (void)
// OBSOLETE {
// OBSOLETE   CORE_ADDR dsr, dda1, dda2;
// OBSOLETE 
// OBSOLETE   dsr = read_register (DSR_REGNUM);
// OBSOLETE   dda1 = read_register (DDA1_REGNUM);
// OBSOLETE   dda2 = read_register (DDA2_REGNUM);
// OBSOLETE 
// OBSOLETE   if (dsr & 0x10)
// OBSOLETE     return dda1;
// OBSOLETE   else if (dsr & 0x20)
// OBSOLETE     return dda2;
// OBSOLETE   else
// OBSOLETE     return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct serial *
// OBSOLETE open_tty (char *name)
// OBSOLETE {
// OBSOLETE   struct serial *desc;
// OBSOLETE 
// OBSOLETE   desc = serial_open (name);
// OBSOLETE   if (!desc)
// OBSOLETE     perror_with_name (name);
// OBSOLETE 
// OBSOLETE   if (baud_rate != -1)
// OBSOLETE     {
// OBSOLETE       if (serial_setbaudrate (desc, baud_rate))
// OBSOLETE 	{
// OBSOLETE 	  serial_close (desc);
// OBSOLETE 	  perror_with_name (name);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   serial_raw (desc);
// OBSOLETE 
// OBSOLETE   serial_flush_input (desc);
// OBSOLETE 
// OBSOLETE   return desc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Read a single character from the remote end, masking it down to 7 bits. */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE readchar (struct serial *desc, int timeout)
// OBSOLETE {
// OBSOLETE   int ch;
// OBSOLETE   char s[10];
// OBSOLETE 
// OBSOLETE   ch = serial_readchar (desc, timeout);
// OBSOLETE 
// OBSOLETE   switch (ch)
// OBSOLETE     {
// OBSOLETE     case SERIAL_EOF:
// OBSOLETE       error ("SPARClite remote connection closed");
// OBSOLETE     case SERIAL_ERROR:
// OBSOLETE       perror_with_name ("SPARClite communication error");
// OBSOLETE     case SERIAL_TIMEOUT:
// OBSOLETE       error ("SPARClite remote timeout");
// OBSOLETE     default:
// OBSOLETE       if (remote_debug > 0)
// OBSOLETE 	{
// OBSOLETE 	  sprintf (s, "[%02x]", ch & 0xff);
// OBSOLETE 	  puts_debug ("read -->", s, "<--");
// OBSOLETE 	}
// OBSOLETE       return ch;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE debug_serial_write (struct serial *desc, char *buf, int len)
// OBSOLETE {
// OBSOLETE   char s[10];
// OBSOLETE 
// OBSOLETE   serial_write (desc, buf, len);
// OBSOLETE   if (remote_debug > 0)
// OBSOLETE     {
// OBSOLETE       while (len-- > 0)
// OBSOLETE 	{
// OBSOLETE 	  sprintf (s, "[%02x]", *buf & 0xff);
// OBSOLETE 	  puts_debug ("Sent -->", s, "<--");
// OBSOLETE 	  buf++;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE send_resp (struct serial *desc, char c)
// OBSOLETE {
// OBSOLETE   debug_serial_write (desc, &c, 1);
// OBSOLETE   return readchar (desc, remote_timeout);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE close_tty (void *ignore)
// OBSOLETE {
// OBSOLETE   if (!remote_desc)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   serial_close (remote_desc);
// OBSOLETE 
// OBSOLETE   remote_desc = NULL;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE static int
// OBSOLETE recv_udp_buf (int fd, unsigned char *buf, int len, int timeout)
// OBSOLETE {
// OBSOLETE   int cc;
// OBSOLETE   fd_set readfds;
// OBSOLETE 
// OBSOLETE   FD_ZERO (&readfds);
// OBSOLETE   FD_SET (fd, &readfds);
// OBSOLETE 
// OBSOLETE   if (timeout >= 0)
// OBSOLETE     {
// OBSOLETE       struct timeval timebuf;
// OBSOLETE 
// OBSOLETE       timebuf.tv_sec = timeout;
// OBSOLETE       timebuf.tv_usec = 0;
// OBSOLETE       cc = select (fd + 1, &readfds, 0, 0, &timebuf);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     cc = select (fd + 1, &readfds, 0, 0, 0);
// OBSOLETE 
// OBSOLETE   if (cc == 0)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   if (cc != 1)
// OBSOLETE     perror_with_name ("recv_udp_buf: Bad return value from select:");
// OBSOLETE 
// OBSOLETE   cc = recv (fd, buf, len, 0);
// OBSOLETE 
// OBSOLETE   if (cc < 0)
// OBSOLETE     perror_with_name ("Got an error from recv: ");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE send_udp_buf (int fd, unsigned char *buf, int len)
// OBSOLETE {
// OBSOLETE   int cc;
// OBSOLETE 
// OBSOLETE   cc = send (fd, buf, len, 0);
// OBSOLETE 
// OBSOLETE   if (cc == len)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   if (cc < 0)
// OBSOLETE     perror_with_name ("Got an error from send: ");
// OBSOLETE 
// OBSOLETE   error ("Short count in send: tried %d, sent %d\n", len, cc);
// OBSOLETE }
// OBSOLETE #endif /* HAVE_SOCKETS */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclite_open (char *name, int from_tty)
// OBSOLETE {
// OBSOLETE   struct cleanup *old_chain;
// OBSOLETE   int c;
// OBSOLETE   char *p;
// OBSOLETE 
// OBSOLETE   if (!name)
// OBSOLETE     error ("You need to specify what device or hostname is associated with the SparcLite board.");
// OBSOLETE 
// OBSOLETE   target_preopen (from_tty);
// OBSOLETE 
// OBSOLETE   unpush_target (&sparclite_ops);
// OBSOLETE 
// OBSOLETE   if (remote_target_name)
// OBSOLETE     xfree (remote_target_name);
// OBSOLETE 
// OBSOLETE   remote_target_name = xstrdup (name);
// OBSOLETE 
// OBSOLETE   /* We need a 'serial' or 'udp' keyword to disambiguate host:port, which can
// OBSOLETE      mean either a serial port on a terminal server, or the IP address of a
// OBSOLETE      SPARClite demo board.  If there's no colon, then it pretty much has to be
// OBSOLETE      a local device (except for DOS... grrmble) */
// OBSOLETE 
// OBSOLETE   p = strchr (name, ' ');
// OBSOLETE 
// OBSOLETE   if (p)
// OBSOLETE     {
// OBSOLETE       *p++ = '\000';
// OBSOLETE       while ((*p != '\000') && isspace (*p))
// OBSOLETE 	p++;
// OBSOLETE 
// OBSOLETE       if (strncmp (name, "serial", strlen (name)) == 0)
// OBSOLETE 	serial_flag = 1;
// OBSOLETE       else if (strncmp (name, "udp", strlen (name)) == 0)
// OBSOLETE 	serial_flag = 0;
// OBSOLETE       else
// OBSOLETE 	error ("Must specify either `serial' or `udp'.");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       p = name;
// OBSOLETE 
// OBSOLETE       if (!strchr (name, ':'))
// OBSOLETE 	serial_flag = 1;	/* No colon is unambiguous (local device) */
// OBSOLETE       else
// OBSOLETE 	error ("Usage: target sparclite serial /dev/ttyb\n\
// OBSOLETE or: target sparclite udp host");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (serial_flag)
// OBSOLETE     {
// OBSOLETE       remote_desc = open_tty (p);
// OBSOLETE 
// OBSOLETE       old_chain = make_cleanup (close_tty, 0 /*ignore*/);
// OBSOLETE 
// OBSOLETE       c = send_resp (remote_desc, 0x00);
// OBSOLETE 
// OBSOLETE       if (c != 0xaa)
// OBSOLETE 	error ("Unknown response (0x%x) from SparcLite.  Try resetting the board.",
// OBSOLETE 	       c);
// OBSOLETE 
// OBSOLETE       c = send_resp (remote_desc, 0x55);
// OBSOLETE 
// OBSOLETE       if (c != 0x55)
// OBSOLETE 	error ("Sparclite appears to be ill.");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE       struct hostent *he;
// OBSOLETE       struct sockaddr_in sockaddr;
// OBSOLETE       unsigned char buffer[100];
// OBSOLETE       int cc;
// OBSOLETE 
// OBSOLETE       /* Setup the socket.  Must be raw UDP. */
// OBSOLETE 
// OBSOLETE       he = gethostbyname (p);
// OBSOLETE 
// OBSOLETE       if (!he)
// OBSOLETE 	error ("No such host %s.", p);
// OBSOLETE 
// OBSOLETE       udp_fd = socket (PF_INET, SOCK_DGRAM, 0);
// OBSOLETE 
// OBSOLETE       old_chain = make_cleanup (close, udp_fd);
// OBSOLETE 
// OBSOLETE       sockaddr.sin_family = PF_INET;
// OBSOLETE       sockaddr.sin_port = htons (7000);
// OBSOLETE       memcpy (&sockaddr.sin_addr.s_addr, he->h_addr, sizeof (struct in_addr));
// OBSOLETE 
// OBSOLETE       if (connect (udp_fd, &sockaddr, sizeof (sockaddr)))
// OBSOLETE 	perror_with_name ("Connect failed");
// OBSOLETE 
// OBSOLETE       buffer[0] = 0x5;
// OBSOLETE       buffer[1] = 0;
// OBSOLETE 
// OBSOLETE       send_udp_buf (udp_fd, buffer, 2);		/* Request version */
// OBSOLETE       cc = recv_udp_buf (udp_fd, buffer, sizeof (buffer), 5);	/* Get response */
// OBSOLETE       if (cc == 0)
// OBSOLETE 	error ("SPARClite isn't responding.");
// OBSOLETE 
// OBSOLETE       if (cc < 3)
// OBSOLETE 	error ("SPARClite appears to be ill.");
// OBSOLETE #else
// OBSOLETE       error ("UDP downloading is not supported for DOS hosts.");
// OBSOLETE #endif /* HAVE_SOCKETS */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   printf_unfiltered ("[SPARClite appears to be alive]\n");
// OBSOLETE 
// OBSOLETE   push_target (&sparclite_ops);
// OBSOLETE 
// OBSOLETE   discard_cleanups (old_chain);
// OBSOLETE 
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclite_close (int quitting)
// OBSOLETE {
// OBSOLETE   if (serial_flag)
// OBSOLETE     close_tty (0);
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE   else if (udp_fd != -1)
// OBSOLETE     close (udp_fd);
// OBSOLETE #endif
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #define LOAD_ADDRESS 0x40000000
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE download (char *target_name, char *args, int from_tty,
// OBSOLETE 	  void (*write_routine) (bfd *from_bfd, asection *from_sec,
// OBSOLETE 				 file_ptr from_addr, bfd_vma to_addr, int len),
// OBSOLETE 	  void (*start_routine) (bfd_vma entry))
// OBSOLETE {
// OBSOLETE   struct cleanup *old_chain;
// OBSOLETE   asection *section;
// OBSOLETE   bfd *pbfd;
// OBSOLETE   bfd_vma entry;
// OBSOLETE   int i;
// OBSOLETE #define WRITESIZE 1024
// OBSOLETE   char *filename;
// OBSOLETE   int quiet;
// OBSOLETE   int nostart;
// OBSOLETE 
// OBSOLETE   quiet = 0;
// OBSOLETE   nostart = 0;
// OBSOLETE   filename = NULL;
// OBSOLETE 
// OBSOLETE   while (*args != '\000')
// OBSOLETE     {
// OBSOLETE       char *arg;
// OBSOLETE 
// OBSOLETE       while (isspace (*args))
// OBSOLETE 	args++;
// OBSOLETE 
// OBSOLETE       arg = args;
// OBSOLETE 
// OBSOLETE       while ((*args != '\000') && !isspace (*args))
// OBSOLETE 	args++;
// OBSOLETE 
// OBSOLETE       if (*args != '\000')
// OBSOLETE 	*args++ = '\000';
// OBSOLETE 
// OBSOLETE       if (*arg != '-')
// OBSOLETE 	filename = arg;
// OBSOLETE       else if (strncmp (arg, "-quiet", strlen (arg)) == 0)
// OBSOLETE 	quiet = 1;
// OBSOLETE       else if (strncmp (arg, "-nostart", strlen (arg)) == 0)
// OBSOLETE 	nostart = 1;
// OBSOLETE       else
// OBSOLETE 	error ("unknown option `%s'", arg);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!filename)
// OBSOLETE     filename = get_exec_file (1);
// OBSOLETE 
// OBSOLETE   pbfd = bfd_openr (filename, gnutarget);
// OBSOLETE   if (pbfd == NULL)
// OBSOLETE     {
// OBSOLETE       perror_with_name (filename);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE   old_chain = make_cleanup_bfd_close (pbfd);
// OBSOLETE 
// OBSOLETE   if (!bfd_check_format (pbfd, bfd_object))
// OBSOLETE     error ("\"%s\" is not an object file: %s", filename,
// OBSOLETE 	   bfd_errmsg (bfd_get_error ()));
// OBSOLETE 
// OBSOLETE   for (section = pbfd->sections; section; section = section->next)
// OBSOLETE     {
// OBSOLETE       if (bfd_get_section_flags (pbfd, section) & SEC_LOAD)
// OBSOLETE 	{
// OBSOLETE 	  bfd_vma section_address;
// OBSOLETE 	  bfd_size_type section_size;
// OBSOLETE 	  file_ptr fptr;
// OBSOLETE 	  const char *section_name;
// OBSOLETE 
// OBSOLETE 	  section_name = bfd_get_section_name (pbfd, section);
// OBSOLETE 
// OBSOLETE 	  section_address = bfd_get_section_vma (pbfd, section);
// OBSOLETE 
// OBSOLETE 	  /* Adjust sections from a.out files, since they don't
// OBSOLETE 	     carry their addresses with.  */
// OBSOLETE 	  if (bfd_get_flavour (pbfd) == bfd_target_aout_flavour)
// OBSOLETE 	    {
// OBSOLETE 	      if (strcmp (section_name, ".text") == 0)
// OBSOLETE 		section_address = bfd_get_start_address (pbfd);
// OBSOLETE 	      else if (strcmp (section_name, ".data") == 0)
// OBSOLETE 		{
// OBSOLETE 		  /* Read the first 8 bytes of the data section.
// OBSOLETE 		     There should be the string 'DaTa' followed by
// OBSOLETE 		     a word containing the actual section address. */
// OBSOLETE 		  struct data_marker
// OBSOLETE 		    {
// OBSOLETE 		      char signature[4];	/* 'DaTa' */
// OBSOLETE 		      unsigned char sdata[4];	/* &sdata */
// OBSOLETE 		    }
// OBSOLETE 		  marker;
// OBSOLETE 		  bfd_get_section_contents (pbfd, section, &marker, 0,
// OBSOLETE 					    sizeof (marker));
// OBSOLETE 		  if (strncmp (marker.signature, "DaTa", 4) == 0)
// OBSOLETE 		    {
// OBSOLETE 		      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
// OBSOLETE 			section_address = bfd_getb32 (marker.sdata);
// OBSOLETE 		      else
// OBSOLETE 			section_address = bfd_getl32 (marker.sdata);
// OBSOLETE 		    }
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  section_size = bfd_get_section_size_before_reloc (section);
// OBSOLETE 
// OBSOLETE 	  if (!quiet)
// OBSOLETE 	    printf_filtered ("[Loading section %s at 0x%x (%d bytes)]\n",
// OBSOLETE 			     bfd_get_section_name (pbfd, section),
// OBSOLETE 			     section_address,
// OBSOLETE 			     section_size);
// OBSOLETE 
// OBSOLETE 	  fptr = 0;
// OBSOLETE 	  while (section_size > 0)
// OBSOLETE 	    {
// OBSOLETE 	      int count;
// OBSOLETE 	      static char inds[] = "|/-\\";
// OBSOLETE 	      static int k = 0;
// OBSOLETE 
// OBSOLETE 	      QUIT;
// OBSOLETE 
// OBSOLETE 	      count = min (section_size, WRITESIZE);
// OBSOLETE 
// OBSOLETE 	      write_routine (pbfd, section, fptr, section_address, count);
// OBSOLETE 
// OBSOLETE 	      if (!quiet)
// OBSOLETE 		{
// OBSOLETE 		  printf_unfiltered ("\r%c", inds[k++ % 4]);
// OBSOLETE 		  gdb_flush (gdb_stdout);
// OBSOLETE 		}
// OBSOLETE 
// OBSOLETE 	      section_address += count;
// OBSOLETE 	      fptr += count;
// OBSOLETE 	      section_size -= count;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!nostart)
// OBSOLETE     {
// OBSOLETE       entry = bfd_get_start_address (pbfd);
// OBSOLETE 
// OBSOLETE       if (!quiet)
// OBSOLETE 	printf_unfiltered ("[Starting %s at 0x%x]\n", filename, entry);
// OBSOLETE 
// OBSOLETE       start_routine (entry);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   do_cleanups (old_chain);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclite_serial_start (bfd_vma entry)
// OBSOLETE {
// OBSOLETE   char buffer[5];
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   buffer[0] = 0x03;
// OBSOLETE   store_unsigned_integer (buffer + 1, 4, entry);
// OBSOLETE 
// OBSOLETE   debug_serial_write (remote_desc, buffer, 1 + 4);
// OBSOLETE   i = readchar (remote_desc, remote_timeout);
// OBSOLETE   if (i != 0x55)
// OBSOLETE     error ("Can't start SparcLite.  Error code %d\n", i);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclite_serial_write (bfd *from_bfd, asection *from_sec, file_ptr from_addr,
// OBSOLETE 			bfd_vma to_addr, int len)
// OBSOLETE {
// OBSOLETE   char buffer[4 + 4 + WRITESIZE];	/* addr + len + data */
// OBSOLETE   unsigned char checksum;
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   store_unsigned_integer (buffer, 4, to_addr);	/* Address */
// OBSOLETE   store_unsigned_integer (buffer + 4, 4, len);	/* Length */
// OBSOLETE 
// OBSOLETE   bfd_get_section_contents (from_bfd, from_sec, buffer + 8, from_addr, len);
// OBSOLETE 
// OBSOLETE   checksum = 0;
// OBSOLETE   for (i = 0; i < len; i++)
// OBSOLETE     checksum += buffer[8 + i];
// OBSOLETE 
// OBSOLETE   i = send_resp (remote_desc, 0x01);
// OBSOLETE 
// OBSOLETE   if (i != 0x5a)
// OBSOLETE     error ("Bad response from load command (0x%x)", i);
// OBSOLETE 
// OBSOLETE   debug_serial_write (remote_desc, buffer, 4 + 4 + len);
// OBSOLETE   i = readchar (remote_desc, remote_timeout);
// OBSOLETE 
// OBSOLETE   if (i != checksum)
// OBSOLETE     error ("Bad checksum from load command (0x%x)", i);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE 
// OBSOLETE static unsigned short
// OBSOLETE calc_checksum (unsigned char *buffer, int count)
// OBSOLETE {
// OBSOLETE   unsigned short checksum;
// OBSOLETE 
// OBSOLETE   checksum = 0;
// OBSOLETE   for (; count > 0; count -= 2, buffer += 2)
// OBSOLETE     checksum += (*buffer << 8) | *(buffer + 1);
// OBSOLETE 
// OBSOLETE   if (count != 0)
// OBSOLETE     checksum += *buffer << 8;
// OBSOLETE 
// OBSOLETE   return checksum;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclite_udp_start (bfd_vma entry)
// OBSOLETE {
// OBSOLETE   unsigned char buffer[6];
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   buffer[0] = 0x3;
// OBSOLETE   buffer[1] = 0;
// OBSOLETE   buffer[2] = entry >> 24;
// OBSOLETE   buffer[3] = entry >> 16;
// OBSOLETE   buffer[4] = entry >> 8;
// OBSOLETE   buffer[5] = entry;
// OBSOLETE 
// OBSOLETE   send_udp_buf (udp_fd, buffer, 6);	/* Send start addr */
// OBSOLETE   i = recv_udp_buf (udp_fd, buffer, sizeof (buffer), -1);	/* Get response */
// OBSOLETE 
// OBSOLETE   if (i < 1 || buffer[0] != 0x55)
// OBSOLETE     error ("Failed to take start address.");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclite_udp_write (bfd *from_bfd, asection *from_sec, file_ptr from_addr,
// OBSOLETE 		     bfd_vma to_addr, int len)
// OBSOLETE {
// OBSOLETE   unsigned char buffer[2000];
// OBSOLETE   unsigned short checksum;
// OBSOLETE   static int pkt_num = 0;
// OBSOLETE   static unsigned long old_addr = -1;
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       if (to_addr != old_addr)
// OBSOLETE 	{
// OBSOLETE 	  buffer[0] = 0x1;	/* Load command */
// OBSOLETE 	  buffer[1] = 0x1;	/* Loading address */
// OBSOLETE 	  buffer[2] = to_addr >> 24;
// OBSOLETE 	  buffer[3] = to_addr >> 16;
// OBSOLETE 	  buffer[4] = to_addr >> 8;
// OBSOLETE 	  buffer[5] = to_addr;
// OBSOLETE 
// OBSOLETE 	  checksum = 0;
// OBSOLETE 	  for (i = 0; i < 6; i++)
// OBSOLETE 	    checksum += buffer[i];
// OBSOLETE 	  checksum &= 0xff;
// OBSOLETE 
// OBSOLETE 	  send_udp_buf (udp_fd, buffer, 6);
// OBSOLETE 	  i = recv_udp_buf (udp_fd, buffer, sizeof buffer, -1);
// OBSOLETE 
// OBSOLETE 	  if (i < 1)
// OBSOLETE 	    error ("Got back short checksum for load addr.");
// OBSOLETE 
// OBSOLETE 	  if (checksum != buffer[0])
// OBSOLETE 	    error ("Got back bad checksum for load addr.");
// OBSOLETE 
// OBSOLETE 	  pkt_num = 0;		/* Load addr resets packet seq # */
// OBSOLETE 	  old_addr = to_addr;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       bfd_get_section_contents (from_bfd, from_sec, buffer + 6, from_addr,
// OBSOLETE 				len);
// OBSOLETE 
// OBSOLETE       checksum = calc_checksum (buffer + 6, len);
// OBSOLETE 
// OBSOLETE       buffer[0] = 0x1;		/* Load command */
// OBSOLETE       buffer[1] = 0x2;		/* Loading data */
// OBSOLETE       buffer[2] = pkt_num >> 8;
// OBSOLETE       buffer[3] = pkt_num;
// OBSOLETE       buffer[4] = checksum >> 8;
// OBSOLETE       buffer[5] = checksum;
// OBSOLETE 
// OBSOLETE       send_udp_buf (udp_fd, buffer, len + 6);
// OBSOLETE       i = recv_udp_buf (udp_fd, buffer, sizeof buffer, 3);
// OBSOLETE 
// OBSOLETE       if (i == 0)
// OBSOLETE 	{
// OBSOLETE 	  fprintf_unfiltered (gdb_stderr, "send_data: timeout sending %d bytes to address 0x%x retrying\n", len, to_addr);
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (buffer[0] != 0xff)
// OBSOLETE 	error ("Got back bad response for load data.");
// OBSOLETE 
// OBSOLETE       old_addr += len;
// OBSOLETE       pkt_num++;
// OBSOLETE 
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* HAVE_SOCKETS */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclite_download (char *filename, int from_tty)
// OBSOLETE {
// OBSOLETE   if (!serial_flag)
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE     download (remote_target_name, filename, from_tty, sparclite_udp_write,
// OBSOLETE 	      sparclite_udp_start);
// OBSOLETE #else
// OBSOLETE     internal_error (__FILE__, __LINE__, "failed internal consistency check");			/* sparclite_open should prevent this! */
// OBSOLETE #endif
// OBSOLETE   else
// OBSOLETE     download (remote_target_name, filename, from_tty, sparclite_serial_write,
// OBSOLETE 	      sparclite_serial_start);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Set up the sparclite target vector.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_sparclite_ops (void)
// OBSOLETE {
// OBSOLETE   sparclite_ops.to_shortname = "sparclite";
// OBSOLETE   sparclite_ops.to_longname = "SPARClite download target";
// OBSOLETE   sparclite_ops.to_doc = "Download to a remote SPARClite target board via serial of UDP.\n\
// OBSOLETE Specify the device it is connected to (e.g. /dev/ttya).";
// OBSOLETE   sparclite_ops.to_open = sparclite_open;
// OBSOLETE   sparclite_ops.to_close = sparclite_close;
// OBSOLETE   sparclite_ops.to_load = sparclite_download;
// OBSOLETE   sparclite_ops.to_stratum = download_stratum;
// OBSOLETE   sparclite_ops.to_magic = OPS_MAGIC;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_sparcl_tdep (void)
// OBSOLETE {
// OBSOLETE   init_sparclite_ops ();
// OBSOLETE   add_target (&sparclite_ops);
// OBSOLETE }
@


1.17
log
@2003-04-16  Andrew Cagney  <cagney@@redhat.com>

	* NEWS: Mention that sparclet-*-* and sparclite-*-* have been made
	obsolete.
	* sparc-tdep.c: Obsolete SPARCLET and SPARCLITE code.
	* sparcl-stub.c: Obsolete file.
	* config/sparc/tm-sparclet.h: Obsolete file.
	* sparclet-stub.c: Obsolete file.
	* sparclet-rom.c: Obsolete file.
	* sparcl-tdep.c: Obsolete file.
	* config/sparc/tm-sparclite.h: Obsolete file.
	* config/sparc/sparclite.mt: Obsolete file.
	* config/sparc/sparclet.mt: Obsolete file.
	* configure.tgt: Make sparclet-*-*, sparclite-*-*, and
	sparc86x-*-* obsolete.
@
text
@@


1.16
log
@* sparcl-tdep.c: Use __CYGWIN__ instead of __CYGWIN32__.
* rdi-share/serpardr.c: Ditto.
* rdi-share/unixcomm.c: Ditto.
* rdi-share/serdrv.c: Ditto.
* rdi-share/hostchan.h: Ditto.
* rdi-share/hostchan.c: Ditto.
* rdi-share/host.h: Ditto.
* rdi-share/devsw.c: Ditto.
@
text
@d1 869
a869 869
/* Target dependent code for the Fujitsu SPARClite for GDB, the GNU debugger.
   Copyright 1994, 1995, 1996, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "gdbcore.h"
#include "breakpoint.h"
#include "target.h"
#include "serial.h"
#include "regcache.h"
#include <sys/types.h>

#if (!defined(__GO32__) && !defined(_WIN32)) || defined(__CYGWIN__)
#define HAVE_SOCKETS
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#endif

static struct target_ops sparclite_ops;

static char *remote_target_name = NULL;
static struct serial *remote_desc = NULL;
static int serial_flag;
#ifdef HAVE_SOCKETS
static int udp_fd = -1;
#endif

static struct serial *open_tty (char *name);
static int send_resp (struct serial *desc, char c);
static void close_tty (void * ignore);
#ifdef HAVE_SOCKETS
static int recv_udp_buf (int fd, unsigned char *buf, int len, int timeout);
static int send_udp_buf (int fd, unsigned char *buf, int len);
#endif
static void sparclite_open (char *name, int from_tty);
static void sparclite_close (int quitting);
static void download (char *target_name, char *args, int from_tty,
		      void (*write_routine) (bfd * from_bfd,
					     asection * from_sec,
					     file_ptr from_addr,
					     bfd_vma to_addr, int len),
		      void (*start_routine) (bfd_vma entry));
static void sparclite_serial_start (bfd_vma entry);
static void sparclite_serial_write (bfd * from_bfd, asection * from_sec,
				    file_ptr from_addr,
				    bfd_vma to_addr, int len);
#ifdef HAVE_SOCKETS
static unsigned short calc_checksum (unsigned char *buffer, int count);
static void sparclite_udp_start (bfd_vma entry);
static void sparclite_udp_write (bfd * from_bfd, asection * from_sec,
				 file_ptr from_addr, bfd_vma to_addr,
				 int len);
#endif
static void sparclite_download (char *filename, int from_tty);

#define DDA2_SUP_ASI		0xb000000
#define DDA1_SUP_ASI		0xb0000

#define DDA2_ASI_MASK 		0xff000000
#define DDA1_ASI_MASK 		0xff0000
#define DIA2_SUP_MODE 		0x8000
#define DIA1_SUP_MODE 		0x4000
#define DDA2_ENABLE 		0x100
#define DDA1_ENABLE 		0x80
#define DIA2_ENABLE 		0x40
#define DIA1_ENABLE 		0x20
#define DSINGLE_STEP 		0x10	/* not used */
#define DDV_TYPE_MASK 		0xc
#define DDV_TYPE_LOAD 		0x0
#define DDV_TYPE_STORE 		0x4
#define DDV_TYPE_ACCESS 	0x8
#define DDV_TYPE_ALWAYS		0xc
#define DDV_COND		0x2
#define DDV_MASK		0x1

int
sparclite_insert_watchpoint (CORE_ADDR addr, int len, int type)
{
  CORE_ADDR dcr;

  dcr = read_register (DCR_REGNUM);

  if (!(dcr & DDA1_ENABLE))
    {
      write_register (DDA1_REGNUM, addr);
      dcr &= ~(DDA1_ASI_MASK | DDV_TYPE_MASK);
      dcr |= (DDA1_SUP_ASI | DDA1_ENABLE);
      if (type == 1)
	{
	  write_register (DDV1_REGNUM, 0);
	  write_register (DDV2_REGNUM, 0xffffffff);
	  dcr |= (DDV_TYPE_LOAD & (~DDV_COND & ~DDV_MASK));
	}
      else if (type == 0)
	{
	  write_register (DDV1_REGNUM, 0);
	  write_register (DDV2_REGNUM, 0xffffffff);
	  dcr |= (DDV_TYPE_STORE & (~DDV_COND & ~DDV_MASK));
	}
      else
	{
	  write_register (DDV1_REGNUM, 0);
	  write_register (DDV2_REGNUM, 0xffffffff);
	  dcr |= (DDV_TYPE_ACCESS);
	}
      write_register (DCR_REGNUM, dcr);
    }
  else if (!(dcr & DDA2_ENABLE))
    {
      write_register (DDA2_REGNUM, addr);
      dcr &= ~(DDA2_ASI_MASK & DDV_TYPE_MASK);
      dcr |= (DDA2_SUP_ASI | DDA2_ENABLE);
      if (type == 1)
	{
	  write_register (DDV1_REGNUM, 0);
	  write_register (DDV2_REGNUM, 0xffffffff);
	  dcr |= (DDV_TYPE_LOAD & ~DDV_COND & ~DDV_MASK);
	}
      else if (type == 0)
	{
	  write_register (DDV1_REGNUM, 0);
	  write_register (DDV2_REGNUM, 0xffffffff);
	  dcr |= (DDV_TYPE_STORE & ~DDV_COND & ~DDV_MASK);
	}
      else
	{
	  write_register (DDV1_REGNUM, 0);
	  write_register (DDV2_REGNUM, 0xffffffff);
	  dcr |= (DDV_TYPE_ACCESS);
	}
      write_register (DCR_REGNUM, dcr);
    }
  else
    return -1;

  return 0;
}

int
sparclite_remove_watchpoint (CORE_ADDR addr, int len, int type)
{
  CORE_ADDR dcr, dda1, dda2;

  dcr = read_register (DCR_REGNUM);
  dda1 = read_register (DDA1_REGNUM);
  dda2 = read_register (DDA2_REGNUM);

  if ((dcr & DDA1_ENABLE) && addr == dda1)
    write_register (DCR_REGNUM, (dcr & ~DDA1_ENABLE));
  else if ((dcr & DDA2_ENABLE) && addr == dda2)
    write_register (DCR_REGNUM, (dcr & ~DDA2_ENABLE));
  else
    return -1;

  return 0;
}

int
sparclite_insert_hw_breakpoint (CORE_ADDR addr, int len)
{
  CORE_ADDR dcr;

  dcr = read_register (DCR_REGNUM);

  if (!(dcr & DIA1_ENABLE))
    {
      write_register (DIA1_REGNUM, addr);
      write_register (DCR_REGNUM, (dcr | DIA1_ENABLE | DIA1_SUP_MODE));
    }
  else if (!(dcr & DIA2_ENABLE))
    {
      write_register (DIA2_REGNUM, addr);
      write_register (DCR_REGNUM, (dcr | DIA2_ENABLE | DIA2_SUP_MODE));
    }
  else
    return -1;

  return 0;
}

int
sparclite_remove_hw_breakpoint (CORE_ADDR addr, int shadow)
{
  CORE_ADDR dcr, dia1, dia2;

  dcr = read_register (DCR_REGNUM);
  dia1 = read_register (DIA1_REGNUM);
  dia2 = read_register (DIA2_REGNUM);

  if ((dcr & DIA1_ENABLE) && addr == dia1)
    write_register (DCR_REGNUM, (dcr & ~DIA1_ENABLE));
  else if ((dcr & DIA2_ENABLE) && addr == dia2)
    write_register (DCR_REGNUM, (dcr & ~DIA2_ENABLE));
  else
    return -1;

  return 0;
}

int
sparclite_check_watch_resources (int type, int cnt, int ot)
{
  /* Watchpoints not supported on simulator.  */
  if (strcmp (target_shortname, "sim") == 0)
    return 0;

  if (type == bp_hardware_breakpoint)
    {
      if (TARGET_HW_BREAK_LIMIT == 0)
	return 0;
      else if (cnt <= TARGET_HW_BREAK_LIMIT)
	return 1;
    }
  else
    {
      if (TARGET_HW_WATCH_LIMIT == 0)
	return 0;
      else if (ot)
	return -1;
      else if (cnt <= TARGET_HW_WATCH_LIMIT)
	return 1;
    }
  return -1;
}

CORE_ADDR
sparclite_stopped_data_address (void)
{
  CORE_ADDR dsr, dda1, dda2;

  dsr = read_register (DSR_REGNUM);
  dda1 = read_register (DDA1_REGNUM);
  dda2 = read_register (DDA2_REGNUM);

  if (dsr & 0x10)
    return dda1;
  else if (dsr & 0x20)
    return dda2;
  else
    return 0;
}

static struct serial *
open_tty (char *name)
{
  struct serial *desc;

  desc = serial_open (name);
  if (!desc)
    perror_with_name (name);

  if (baud_rate != -1)
    {
      if (serial_setbaudrate (desc, baud_rate))
	{
	  serial_close (desc);
	  perror_with_name (name);
	}
    }

  serial_raw (desc);

  serial_flush_input (desc);

  return desc;
}

/* Read a single character from the remote end, masking it down to 7 bits. */

static int
readchar (struct serial *desc, int timeout)
{
  int ch;
  char s[10];

  ch = serial_readchar (desc, timeout);

  switch (ch)
    {
    case SERIAL_EOF:
      error ("SPARClite remote connection closed");
    case SERIAL_ERROR:
      perror_with_name ("SPARClite communication error");
    case SERIAL_TIMEOUT:
      error ("SPARClite remote timeout");
    default:
      if (remote_debug > 0)
	{
	  sprintf (s, "[%02x]", ch & 0xff);
	  puts_debug ("read -->", s, "<--");
	}
      return ch;
    }
}

static void
debug_serial_write (struct serial *desc, char *buf, int len)
{
  char s[10];

  serial_write (desc, buf, len);
  if (remote_debug > 0)
    {
      while (len-- > 0)
	{
	  sprintf (s, "[%02x]", *buf & 0xff);
	  puts_debug ("Sent -->", s, "<--");
	  buf++;
	}
    }
}


static int
send_resp (struct serial *desc, char c)
{
  debug_serial_write (desc, &c, 1);
  return readchar (desc, remote_timeout);
}

static void
close_tty (void *ignore)
{
  if (!remote_desc)
    return;

  serial_close (remote_desc);

  remote_desc = NULL;
}

#ifdef HAVE_SOCKETS
static int
recv_udp_buf (int fd, unsigned char *buf, int len, int timeout)
{
  int cc;
  fd_set readfds;

  FD_ZERO (&readfds);
  FD_SET (fd, &readfds);

  if (timeout >= 0)
    {
      struct timeval timebuf;

      timebuf.tv_sec = timeout;
      timebuf.tv_usec = 0;
      cc = select (fd + 1, &readfds, 0, 0, &timebuf);
    }
  else
    cc = select (fd + 1, &readfds, 0, 0, 0);

  if (cc == 0)
    return 0;

  if (cc != 1)
    perror_with_name ("recv_udp_buf: Bad return value from select:");

  cc = recv (fd, buf, len, 0);

  if (cc < 0)
    perror_with_name ("Got an error from recv: ");
}

static int
send_udp_buf (int fd, unsigned char *buf, int len)
{
  int cc;

  cc = send (fd, buf, len, 0);

  if (cc == len)
    return;

  if (cc < 0)
    perror_with_name ("Got an error from send: ");

  error ("Short count in send: tried %d, sent %d\n", len, cc);
}
#endif /* HAVE_SOCKETS */

static void
sparclite_open (char *name, int from_tty)
{
  struct cleanup *old_chain;
  int c;
  char *p;

  if (!name)
    error ("You need to specify what device or hostname is associated with the SparcLite board.");

  target_preopen (from_tty);

  unpush_target (&sparclite_ops);

  if (remote_target_name)
    xfree (remote_target_name);

  remote_target_name = xstrdup (name);

  /* We need a 'serial' or 'udp' keyword to disambiguate host:port, which can
     mean either a serial port on a terminal server, or the IP address of a
     SPARClite demo board.  If there's no colon, then it pretty much has to be
     a local device (except for DOS... grrmble) */

  p = strchr (name, ' ');

  if (p)
    {
      *p++ = '\000';
      while ((*p != '\000') && isspace (*p))
	p++;

      if (strncmp (name, "serial", strlen (name)) == 0)
	serial_flag = 1;
      else if (strncmp (name, "udp", strlen (name)) == 0)
	serial_flag = 0;
      else
	error ("Must specify either `serial' or `udp'.");
    }
  else
    {
      p = name;

      if (!strchr (name, ':'))
	serial_flag = 1;	/* No colon is unambiguous (local device) */
      else
	error ("Usage: target sparclite serial /dev/ttyb\n\
or: target sparclite udp host");
    }

  if (serial_flag)
    {
      remote_desc = open_tty (p);

      old_chain = make_cleanup (close_tty, 0 /*ignore*/);

      c = send_resp (remote_desc, 0x00);

      if (c != 0xaa)
	error ("Unknown response (0x%x) from SparcLite.  Try resetting the board.",
	       c);

      c = send_resp (remote_desc, 0x55);

      if (c != 0x55)
	error ("Sparclite appears to be ill.");
    }
  else
    {
#ifdef HAVE_SOCKETS
      struct hostent *he;
      struct sockaddr_in sockaddr;
      unsigned char buffer[100];
      int cc;

      /* Setup the socket.  Must be raw UDP. */

      he = gethostbyname (p);

      if (!he)
	error ("No such host %s.", p);

      udp_fd = socket (PF_INET, SOCK_DGRAM, 0);

      old_chain = make_cleanup (close, udp_fd);

      sockaddr.sin_family = PF_INET;
      sockaddr.sin_port = htons (7000);
      memcpy (&sockaddr.sin_addr.s_addr, he->h_addr, sizeof (struct in_addr));

      if (connect (udp_fd, &sockaddr, sizeof (sockaddr)))
	perror_with_name ("Connect failed");

      buffer[0] = 0x5;
      buffer[1] = 0;

      send_udp_buf (udp_fd, buffer, 2);		/* Request version */
      cc = recv_udp_buf (udp_fd, buffer, sizeof (buffer), 5);	/* Get response */
      if (cc == 0)
	error ("SPARClite isn't responding.");

      if (cc < 3)
	error ("SPARClite appears to be ill.");
#else
      error ("UDP downloading is not supported for DOS hosts.");
#endif /* HAVE_SOCKETS */
    }

  printf_unfiltered ("[SPARClite appears to be alive]\n");

  push_target (&sparclite_ops);

  discard_cleanups (old_chain);

  return;
}

static void
sparclite_close (int quitting)
{
  if (serial_flag)
    close_tty (0);
#ifdef HAVE_SOCKETS
  else if (udp_fd != -1)
    close (udp_fd);
#endif
}

#define LOAD_ADDRESS 0x40000000

static void
download (char *target_name, char *args, int from_tty,
	  void (*write_routine) (bfd *from_bfd, asection *from_sec,
				 file_ptr from_addr, bfd_vma to_addr, int len),
	  void (*start_routine) (bfd_vma entry))
{
  struct cleanup *old_chain;
  asection *section;
  bfd *pbfd;
  bfd_vma entry;
  int i;
#define WRITESIZE 1024
  char *filename;
  int quiet;
  int nostart;

  quiet = 0;
  nostart = 0;
  filename = NULL;

  while (*args != '\000')
    {
      char *arg;

      while (isspace (*args))
	args++;

      arg = args;

      while ((*args != '\000') && !isspace (*args))
	args++;

      if (*args != '\000')
	*args++ = '\000';

      if (*arg != '-')
	filename = arg;
      else if (strncmp (arg, "-quiet", strlen (arg)) == 0)
	quiet = 1;
      else if (strncmp (arg, "-nostart", strlen (arg)) == 0)
	nostart = 1;
      else
	error ("unknown option `%s'", arg);
    }

  if (!filename)
    filename = get_exec_file (1);

  pbfd = bfd_openr (filename, gnutarget);
  if (pbfd == NULL)
    {
      perror_with_name (filename);
      return;
    }
  old_chain = make_cleanup_bfd_close (pbfd);

  if (!bfd_check_format (pbfd, bfd_object))
    error ("\"%s\" is not an object file: %s", filename,
	   bfd_errmsg (bfd_get_error ()));

  for (section = pbfd->sections; section; section = section->next)
    {
      if (bfd_get_section_flags (pbfd, section) & SEC_LOAD)
	{
	  bfd_vma section_address;
	  bfd_size_type section_size;
	  file_ptr fptr;
	  const char *section_name;

	  section_name = bfd_get_section_name (pbfd, section);

	  section_address = bfd_get_section_vma (pbfd, section);

	  /* Adjust sections from a.out files, since they don't
	     carry their addresses with.  */
	  if (bfd_get_flavour (pbfd) == bfd_target_aout_flavour)
	    {
	      if (strcmp (section_name, ".text") == 0)
		section_address = bfd_get_start_address (pbfd);
	      else if (strcmp (section_name, ".data") == 0)
		{
		  /* Read the first 8 bytes of the data section.
		     There should be the string 'DaTa' followed by
		     a word containing the actual section address. */
		  struct data_marker
		    {
		      char signature[4];	/* 'DaTa' */
		      unsigned char sdata[4];	/* &sdata */
		    }
		  marker;
		  bfd_get_section_contents (pbfd, section, &marker, 0,
					    sizeof (marker));
		  if (strncmp (marker.signature, "DaTa", 4) == 0)
		    {
		      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
			section_address = bfd_getb32 (marker.sdata);
		      else
			section_address = bfd_getl32 (marker.sdata);
		    }
		}
	    }

	  section_size = bfd_get_section_size_before_reloc (section);

	  if (!quiet)
	    printf_filtered ("[Loading section %s at 0x%x (%d bytes)]\n",
			     bfd_get_section_name (pbfd, section),
			     section_address,
			     section_size);

	  fptr = 0;
	  while (section_size > 0)
	    {
	      int count;
	      static char inds[] = "|/-\\";
	      static int k = 0;

	      QUIT;

	      count = min (section_size, WRITESIZE);

	      write_routine (pbfd, section, fptr, section_address, count);

	      if (!quiet)
		{
		  printf_unfiltered ("\r%c", inds[k++ % 4]);
		  gdb_flush (gdb_stdout);
		}

	      section_address += count;
	      fptr += count;
	      section_size -= count;
	    }
	}
    }

  if (!nostart)
    {
      entry = bfd_get_start_address (pbfd);

      if (!quiet)
	printf_unfiltered ("[Starting %s at 0x%x]\n", filename, entry);

      start_routine (entry);
    }

  do_cleanups (old_chain);
}

static void
sparclite_serial_start (bfd_vma entry)
{
  char buffer[5];
  int i;

  buffer[0] = 0x03;
  store_unsigned_integer (buffer + 1, 4, entry);

  debug_serial_write (remote_desc, buffer, 1 + 4);
  i = readchar (remote_desc, remote_timeout);
  if (i != 0x55)
    error ("Can't start SparcLite.  Error code %d\n", i);
}

static void
sparclite_serial_write (bfd *from_bfd, asection *from_sec, file_ptr from_addr,
			bfd_vma to_addr, int len)
{
  char buffer[4 + 4 + WRITESIZE];	/* addr + len + data */
  unsigned char checksum;
  int i;

  store_unsigned_integer (buffer, 4, to_addr);	/* Address */
  store_unsigned_integer (buffer + 4, 4, len);	/* Length */

  bfd_get_section_contents (from_bfd, from_sec, buffer + 8, from_addr, len);

  checksum = 0;
  for (i = 0; i < len; i++)
    checksum += buffer[8 + i];

  i = send_resp (remote_desc, 0x01);

  if (i != 0x5a)
    error ("Bad response from load command (0x%x)", i);

  debug_serial_write (remote_desc, buffer, 4 + 4 + len);
  i = readchar (remote_desc, remote_timeout);

  if (i != checksum)
    error ("Bad checksum from load command (0x%x)", i);
}

#ifdef HAVE_SOCKETS

static unsigned short
calc_checksum (unsigned char *buffer, int count)
{
  unsigned short checksum;

  checksum = 0;
  for (; count > 0; count -= 2, buffer += 2)
    checksum += (*buffer << 8) | *(buffer + 1);

  if (count != 0)
    checksum += *buffer << 8;

  return checksum;
}

static void
sparclite_udp_start (bfd_vma entry)
{
  unsigned char buffer[6];
  int i;

  buffer[0] = 0x3;
  buffer[1] = 0;
  buffer[2] = entry >> 24;
  buffer[3] = entry >> 16;
  buffer[4] = entry >> 8;
  buffer[5] = entry;

  send_udp_buf (udp_fd, buffer, 6);	/* Send start addr */
  i = recv_udp_buf (udp_fd, buffer, sizeof (buffer), -1);	/* Get response */

  if (i < 1 || buffer[0] != 0x55)
    error ("Failed to take start address.");
}

static void
sparclite_udp_write (bfd *from_bfd, asection *from_sec, file_ptr from_addr,
		     bfd_vma to_addr, int len)
{
  unsigned char buffer[2000];
  unsigned short checksum;
  static int pkt_num = 0;
  static unsigned long old_addr = -1;
  int i;

  while (1)
    {
      if (to_addr != old_addr)
	{
	  buffer[0] = 0x1;	/* Load command */
	  buffer[1] = 0x1;	/* Loading address */
	  buffer[2] = to_addr >> 24;
	  buffer[3] = to_addr >> 16;
	  buffer[4] = to_addr >> 8;
	  buffer[5] = to_addr;

	  checksum = 0;
	  for (i = 0; i < 6; i++)
	    checksum += buffer[i];
	  checksum &= 0xff;

	  send_udp_buf (udp_fd, buffer, 6);
	  i = recv_udp_buf (udp_fd, buffer, sizeof buffer, -1);

	  if (i < 1)
	    error ("Got back short checksum for load addr.");

	  if (checksum != buffer[0])
	    error ("Got back bad checksum for load addr.");

	  pkt_num = 0;		/* Load addr resets packet seq # */
	  old_addr = to_addr;
	}

      bfd_get_section_contents (from_bfd, from_sec, buffer + 6, from_addr,
				len);

      checksum = calc_checksum (buffer + 6, len);

      buffer[0] = 0x1;		/* Load command */
      buffer[1] = 0x2;		/* Loading data */
      buffer[2] = pkt_num >> 8;
      buffer[3] = pkt_num;
      buffer[4] = checksum >> 8;
      buffer[5] = checksum;

      send_udp_buf (udp_fd, buffer, len + 6);
      i = recv_udp_buf (udp_fd, buffer, sizeof buffer, 3);

      if (i == 0)
	{
	  fprintf_unfiltered (gdb_stderr, "send_data: timeout sending %d bytes to address 0x%x retrying\n", len, to_addr);
	  continue;
	}

      if (buffer[0] != 0xff)
	error ("Got back bad response for load data.");

      old_addr += len;
      pkt_num++;

      return;
    }
}

#endif /* HAVE_SOCKETS */

static void
sparclite_download (char *filename, int from_tty)
{
  if (!serial_flag)
#ifdef HAVE_SOCKETS
    download (remote_target_name, filename, from_tty, sparclite_udp_write,
	      sparclite_udp_start);
#else
    internal_error (__FILE__, __LINE__, "failed internal consistency check");			/* sparclite_open should prevent this! */
#endif
  else
    download (remote_target_name, filename, from_tty, sparclite_serial_write,
	      sparclite_serial_start);
}

/* Set up the sparclite target vector.  */

static void
init_sparclite_ops (void)
{
  sparclite_ops.to_shortname = "sparclite";
  sparclite_ops.to_longname = "SPARClite download target";
  sparclite_ops.to_doc = "Download to a remote SPARClite target board via serial of UDP.\n\
Specify the device it is connected to (e.g. /dev/ttya).";
  sparclite_ops.to_open = sparclite_open;
  sparclite_ops.to_close = sparclite_close;
  sparclite_ops.to_load = sparclite_download;
  sparclite_ops.to_stratum = download_stratum;
  sparclite_ops.to_magic = OPS_MAGIC;
}

void
_initialize_sparcl_tdep (void)
{
  init_sparclite_ops ();
  add_target (&sparclite_ops);
}
@


1.16.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.16.8.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d1 869
a869 869
// OBSOLETE /* Target dependent code for the Fujitsu SPARClite for GDB, the GNU debugger.
// OBSOLETE    Copyright 1994, 1995, 1996, 1998, 1999, 2000, 2001
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "breakpoint.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "serial.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE #include <sys/types.h>
// OBSOLETE 
// OBSOLETE #if (!defined(__GO32__) && !defined(_WIN32)) || defined(__CYGWIN__)
// OBSOLETE #define HAVE_SOCKETS
// OBSOLETE #include <sys/time.h>
// OBSOLETE #include <sys/socket.h>
// OBSOLETE #include <netinet/in.h>
// OBSOLETE #include <netdb.h>
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE static struct target_ops sparclite_ops;
// OBSOLETE 
// OBSOLETE static char *remote_target_name = NULL;
// OBSOLETE static struct serial *remote_desc = NULL;
// OBSOLETE static int serial_flag;
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE static int udp_fd = -1;
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE static struct serial *open_tty (char *name);
// OBSOLETE static int send_resp (struct serial *desc, char c);
// OBSOLETE static void close_tty (void * ignore);
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE static int recv_udp_buf (int fd, unsigned char *buf, int len, int timeout);
// OBSOLETE static int send_udp_buf (int fd, unsigned char *buf, int len);
// OBSOLETE #endif
// OBSOLETE static void sparclite_open (char *name, int from_tty);
// OBSOLETE static void sparclite_close (int quitting);
// OBSOLETE static void download (char *target_name, char *args, int from_tty,
// OBSOLETE 		      void (*write_routine) (bfd * from_bfd,
// OBSOLETE 					     asection * from_sec,
// OBSOLETE 					     file_ptr from_addr,
// OBSOLETE 					     bfd_vma to_addr, int len),
// OBSOLETE 		      void (*start_routine) (bfd_vma entry));
// OBSOLETE static void sparclite_serial_start (bfd_vma entry);
// OBSOLETE static void sparclite_serial_write (bfd * from_bfd, asection * from_sec,
// OBSOLETE 				    file_ptr from_addr,
// OBSOLETE 				    bfd_vma to_addr, int len);
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE static unsigned short calc_checksum (unsigned char *buffer, int count);
// OBSOLETE static void sparclite_udp_start (bfd_vma entry);
// OBSOLETE static void sparclite_udp_write (bfd * from_bfd, asection * from_sec,
// OBSOLETE 				 file_ptr from_addr, bfd_vma to_addr,
// OBSOLETE 				 int len);
// OBSOLETE #endif
// OBSOLETE static void sparclite_download (char *filename, int from_tty);
// OBSOLETE 
// OBSOLETE #define DDA2_SUP_ASI		0xb000000
// OBSOLETE #define DDA1_SUP_ASI		0xb0000
// OBSOLETE 
// OBSOLETE #define DDA2_ASI_MASK 		0xff000000
// OBSOLETE #define DDA1_ASI_MASK 		0xff0000
// OBSOLETE #define DIA2_SUP_MODE 		0x8000
// OBSOLETE #define DIA1_SUP_MODE 		0x4000
// OBSOLETE #define DDA2_ENABLE 		0x100
// OBSOLETE #define DDA1_ENABLE 		0x80
// OBSOLETE #define DIA2_ENABLE 		0x40
// OBSOLETE #define DIA1_ENABLE 		0x20
// OBSOLETE #define DSINGLE_STEP 		0x10	/* not used */
// OBSOLETE #define DDV_TYPE_MASK 		0xc
// OBSOLETE #define DDV_TYPE_LOAD 		0x0
// OBSOLETE #define DDV_TYPE_STORE 		0x4
// OBSOLETE #define DDV_TYPE_ACCESS 	0x8
// OBSOLETE #define DDV_TYPE_ALWAYS		0xc
// OBSOLETE #define DDV_COND		0x2
// OBSOLETE #define DDV_MASK		0x1
// OBSOLETE 
// OBSOLETE int
// OBSOLETE sparclite_insert_watchpoint (CORE_ADDR addr, int len, int type)
// OBSOLETE {
// OBSOLETE   CORE_ADDR dcr;
// OBSOLETE 
// OBSOLETE   dcr = read_register (DCR_REGNUM);
// OBSOLETE 
// OBSOLETE   if (!(dcr & DDA1_ENABLE))
// OBSOLETE     {
// OBSOLETE       write_register (DDA1_REGNUM, addr);
// OBSOLETE       dcr &= ~(DDA1_ASI_MASK | DDV_TYPE_MASK);
// OBSOLETE       dcr |= (DDA1_SUP_ASI | DDA1_ENABLE);
// OBSOLETE       if (type == 1)
// OBSOLETE 	{
// OBSOLETE 	  write_register (DDV1_REGNUM, 0);
// OBSOLETE 	  write_register (DDV2_REGNUM, 0xffffffff);
// OBSOLETE 	  dcr |= (DDV_TYPE_LOAD & (~DDV_COND & ~DDV_MASK));
// OBSOLETE 	}
// OBSOLETE       else if (type == 0)
// OBSOLETE 	{
// OBSOLETE 	  write_register (DDV1_REGNUM, 0);
// OBSOLETE 	  write_register (DDV2_REGNUM, 0xffffffff);
// OBSOLETE 	  dcr |= (DDV_TYPE_STORE & (~DDV_COND & ~DDV_MASK));
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  write_register (DDV1_REGNUM, 0);
// OBSOLETE 	  write_register (DDV2_REGNUM, 0xffffffff);
// OBSOLETE 	  dcr |= (DDV_TYPE_ACCESS);
// OBSOLETE 	}
// OBSOLETE       write_register (DCR_REGNUM, dcr);
// OBSOLETE     }
// OBSOLETE   else if (!(dcr & DDA2_ENABLE))
// OBSOLETE     {
// OBSOLETE       write_register (DDA2_REGNUM, addr);
// OBSOLETE       dcr &= ~(DDA2_ASI_MASK & DDV_TYPE_MASK);
// OBSOLETE       dcr |= (DDA2_SUP_ASI | DDA2_ENABLE);
// OBSOLETE       if (type == 1)
// OBSOLETE 	{
// OBSOLETE 	  write_register (DDV1_REGNUM, 0);
// OBSOLETE 	  write_register (DDV2_REGNUM, 0xffffffff);
// OBSOLETE 	  dcr |= (DDV_TYPE_LOAD & ~DDV_COND & ~DDV_MASK);
// OBSOLETE 	}
// OBSOLETE       else if (type == 0)
// OBSOLETE 	{
// OBSOLETE 	  write_register (DDV1_REGNUM, 0);
// OBSOLETE 	  write_register (DDV2_REGNUM, 0xffffffff);
// OBSOLETE 	  dcr |= (DDV_TYPE_STORE & ~DDV_COND & ~DDV_MASK);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  write_register (DDV1_REGNUM, 0);
// OBSOLETE 	  write_register (DDV2_REGNUM, 0xffffffff);
// OBSOLETE 	  dcr |= (DDV_TYPE_ACCESS);
// OBSOLETE 	}
// OBSOLETE       write_register (DCR_REGNUM, dcr);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE sparclite_remove_watchpoint (CORE_ADDR addr, int len, int type)
// OBSOLETE {
// OBSOLETE   CORE_ADDR dcr, dda1, dda2;
// OBSOLETE 
// OBSOLETE   dcr = read_register (DCR_REGNUM);
// OBSOLETE   dda1 = read_register (DDA1_REGNUM);
// OBSOLETE   dda2 = read_register (DDA2_REGNUM);
// OBSOLETE 
// OBSOLETE   if ((dcr & DDA1_ENABLE) && addr == dda1)
// OBSOLETE     write_register (DCR_REGNUM, (dcr & ~DDA1_ENABLE));
// OBSOLETE   else if ((dcr & DDA2_ENABLE) && addr == dda2)
// OBSOLETE     write_register (DCR_REGNUM, (dcr & ~DDA2_ENABLE));
// OBSOLETE   else
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE sparclite_insert_hw_breakpoint (CORE_ADDR addr, int len)
// OBSOLETE {
// OBSOLETE   CORE_ADDR dcr;
// OBSOLETE 
// OBSOLETE   dcr = read_register (DCR_REGNUM);
// OBSOLETE 
// OBSOLETE   if (!(dcr & DIA1_ENABLE))
// OBSOLETE     {
// OBSOLETE       write_register (DIA1_REGNUM, addr);
// OBSOLETE       write_register (DCR_REGNUM, (dcr | DIA1_ENABLE | DIA1_SUP_MODE));
// OBSOLETE     }
// OBSOLETE   else if (!(dcr & DIA2_ENABLE))
// OBSOLETE     {
// OBSOLETE       write_register (DIA2_REGNUM, addr);
// OBSOLETE       write_register (DCR_REGNUM, (dcr | DIA2_ENABLE | DIA2_SUP_MODE));
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE sparclite_remove_hw_breakpoint (CORE_ADDR addr, int shadow)
// OBSOLETE {
// OBSOLETE   CORE_ADDR dcr, dia1, dia2;
// OBSOLETE 
// OBSOLETE   dcr = read_register (DCR_REGNUM);
// OBSOLETE   dia1 = read_register (DIA1_REGNUM);
// OBSOLETE   dia2 = read_register (DIA2_REGNUM);
// OBSOLETE 
// OBSOLETE   if ((dcr & DIA1_ENABLE) && addr == dia1)
// OBSOLETE     write_register (DCR_REGNUM, (dcr & ~DIA1_ENABLE));
// OBSOLETE   else if ((dcr & DIA2_ENABLE) && addr == dia2)
// OBSOLETE     write_register (DCR_REGNUM, (dcr & ~DIA2_ENABLE));
// OBSOLETE   else
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE sparclite_check_watch_resources (int type, int cnt, int ot)
// OBSOLETE {
// OBSOLETE   /* Watchpoints not supported on simulator.  */
// OBSOLETE   if (strcmp (target_shortname, "sim") == 0)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   if (type == bp_hardware_breakpoint)
// OBSOLETE     {
// OBSOLETE       if (TARGET_HW_BREAK_LIMIT == 0)
// OBSOLETE 	return 0;
// OBSOLETE       else if (cnt <= TARGET_HW_BREAK_LIMIT)
// OBSOLETE 	return 1;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if (TARGET_HW_WATCH_LIMIT == 0)
// OBSOLETE 	return 0;
// OBSOLETE       else if (ot)
// OBSOLETE 	return -1;
// OBSOLETE       else if (cnt <= TARGET_HW_WATCH_LIMIT)
// OBSOLETE 	return 1;
// OBSOLETE     }
// OBSOLETE   return -1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE sparclite_stopped_data_address (void)
// OBSOLETE {
// OBSOLETE   CORE_ADDR dsr, dda1, dda2;
// OBSOLETE 
// OBSOLETE   dsr = read_register (DSR_REGNUM);
// OBSOLETE   dda1 = read_register (DDA1_REGNUM);
// OBSOLETE   dda2 = read_register (DDA2_REGNUM);
// OBSOLETE 
// OBSOLETE   if (dsr & 0x10)
// OBSOLETE     return dda1;
// OBSOLETE   else if (dsr & 0x20)
// OBSOLETE     return dda2;
// OBSOLETE   else
// OBSOLETE     return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct serial *
// OBSOLETE open_tty (char *name)
// OBSOLETE {
// OBSOLETE   struct serial *desc;
// OBSOLETE 
// OBSOLETE   desc = serial_open (name);
// OBSOLETE   if (!desc)
// OBSOLETE     perror_with_name (name);
// OBSOLETE 
// OBSOLETE   if (baud_rate != -1)
// OBSOLETE     {
// OBSOLETE       if (serial_setbaudrate (desc, baud_rate))
// OBSOLETE 	{
// OBSOLETE 	  serial_close (desc);
// OBSOLETE 	  perror_with_name (name);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   serial_raw (desc);
// OBSOLETE 
// OBSOLETE   serial_flush_input (desc);
// OBSOLETE 
// OBSOLETE   return desc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Read a single character from the remote end, masking it down to 7 bits. */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE readchar (struct serial *desc, int timeout)
// OBSOLETE {
// OBSOLETE   int ch;
// OBSOLETE   char s[10];
// OBSOLETE 
// OBSOLETE   ch = serial_readchar (desc, timeout);
// OBSOLETE 
// OBSOLETE   switch (ch)
// OBSOLETE     {
// OBSOLETE     case SERIAL_EOF:
// OBSOLETE       error ("SPARClite remote connection closed");
// OBSOLETE     case SERIAL_ERROR:
// OBSOLETE       perror_with_name ("SPARClite communication error");
// OBSOLETE     case SERIAL_TIMEOUT:
// OBSOLETE       error ("SPARClite remote timeout");
// OBSOLETE     default:
// OBSOLETE       if (remote_debug > 0)
// OBSOLETE 	{
// OBSOLETE 	  sprintf (s, "[%02x]", ch & 0xff);
// OBSOLETE 	  puts_debug ("read -->", s, "<--");
// OBSOLETE 	}
// OBSOLETE       return ch;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE debug_serial_write (struct serial *desc, char *buf, int len)
// OBSOLETE {
// OBSOLETE   char s[10];
// OBSOLETE 
// OBSOLETE   serial_write (desc, buf, len);
// OBSOLETE   if (remote_debug > 0)
// OBSOLETE     {
// OBSOLETE       while (len-- > 0)
// OBSOLETE 	{
// OBSOLETE 	  sprintf (s, "[%02x]", *buf & 0xff);
// OBSOLETE 	  puts_debug ("Sent -->", s, "<--");
// OBSOLETE 	  buf++;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE send_resp (struct serial *desc, char c)
// OBSOLETE {
// OBSOLETE   debug_serial_write (desc, &c, 1);
// OBSOLETE   return readchar (desc, remote_timeout);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE close_tty (void *ignore)
// OBSOLETE {
// OBSOLETE   if (!remote_desc)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   serial_close (remote_desc);
// OBSOLETE 
// OBSOLETE   remote_desc = NULL;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE static int
// OBSOLETE recv_udp_buf (int fd, unsigned char *buf, int len, int timeout)
// OBSOLETE {
// OBSOLETE   int cc;
// OBSOLETE   fd_set readfds;
// OBSOLETE 
// OBSOLETE   FD_ZERO (&readfds);
// OBSOLETE   FD_SET (fd, &readfds);
// OBSOLETE 
// OBSOLETE   if (timeout >= 0)
// OBSOLETE     {
// OBSOLETE       struct timeval timebuf;
// OBSOLETE 
// OBSOLETE       timebuf.tv_sec = timeout;
// OBSOLETE       timebuf.tv_usec = 0;
// OBSOLETE       cc = select (fd + 1, &readfds, 0, 0, &timebuf);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     cc = select (fd + 1, &readfds, 0, 0, 0);
// OBSOLETE 
// OBSOLETE   if (cc == 0)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   if (cc != 1)
// OBSOLETE     perror_with_name ("recv_udp_buf: Bad return value from select:");
// OBSOLETE 
// OBSOLETE   cc = recv (fd, buf, len, 0);
// OBSOLETE 
// OBSOLETE   if (cc < 0)
// OBSOLETE     perror_with_name ("Got an error from recv: ");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE send_udp_buf (int fd, unsigned char *buf, int len)
// OBSOLETE {
// OBSOLETE   int cc;
// OBSOLETE 
// OBSOLETE   cc = send (fd, buf, len, 0);
// OBSOLETE 
// OBSOLETE   if (cc == len)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   if (cc < 0)
// OBSOLETE     perror_with_name ("Got an error from send: ");
// OBSOLETE 
// OBSOLETE   error ("Short count in send: tried %d, sent %d\n", len, cc);
// OBSOLETE }
// OBSOLETE #endif /* HAVE_SOCKETS */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclite_open (char *name, int from_tty)
// OBSOLETE {
// OBSOLETE   struct cleanup *old_chain;
// OBSOLETE   int c;
// OBSOLETE   char *p;
// OBSOLETE 
// OBSOLETE   if (!name)
// OBSOLETE     error ("You need to specify what device or hostname is associated with the SparcLite board.");
// OBSOLETE 
// OBSOLETE   target_preopen (from_tty);
// OBSOLETE 
// OBSOLETE   unpush_target (&sparclite_ops);
// OBSOLETE 
// OBSOLETE   if (remote_target_name)
// OBSOLETE     xfree (remote_target_name);
// OBSOLETE 
// OBSOLETE   remote_target_name = xstrdup (name);
// OBSOLETE 
// OBSOLETE   /* We need a 'serial' or 'udp' keyword to disambiguate host:port, which can
// OBSOLETE      mean either a serial port on a terminal server, or the IP address of a
// OBSOLETE      SPARClite demo board.  If there's no colon, then it pretty much has to be
// OBSOLETE      a local device (except for DOS... grrmble) */
// OBSOLETE 
// OBSOLETE   p = strchr (name, ' ');
// OBSOLETE 
// OBSOLETE   if (p)
// OBSOLETE     {
// OBSOLETE       *p++ = '\000';
// OBSOLETE       while ((*p != '\000') && isspace (*p))
// OBSOLETE 	p++;
// OBSOLETE 
// OBSOLETE       if (strncmp (name, "serial", strlen (name)) == 0)
// OBSOLETE 	serial_flag = 1;
// OBSOLETE       else if (strncmp (name, "udp", strlen (name)) == 0)
// OBSOLETE 	serial_flag = 0;
// OBSOLETE       else
// OBSOLETE 	error ("Must specify either `serial' or `udp'.");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       p = name;
// OBSOLETE 
// OBSOLETE       if (!strchr (name, ':'))
// OBSOLETE 	serial_flag = 1;	/* No colon is unambiguous (local device) */
// OBSOLETE       else
// OBSOLETE 	error ("Usage: target sparclite serial /dev/ttyb\n\
// OBSOLETE or: target sparclite udp host");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (serial_flag)
// OBSOLETE     {
// OBSOLETE       remote_desc = open_tty (p);
// OBSOLETE 
// OBSOLETE       old_chain = make_cleanup (close_tty, 0 /*ignore*/);
// OBSOLETE 
// OBSOLETE       c = send_resp (remote_desc, 0x00);
// OBSOLETE 
// OBSOLETE       if (c != 0xaa)
// OBSOLETE 	error ("Unknown response (0x%x) from SparcLite.  Try resetting the board.",
// OBSOLETE 	       c);
// OBSOLETE 
// OBSOLETE       c = send_resp (remote_desc, 0x55);
// OBSOLETE 
// OBSOLETE       if (c != 0x55)
// OBSOLETE 	error ("Sparclite appears to be ill.");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE       struct hostent *he;
// OBSOLETE       struct sockaddr_in sockaddr;
// OBSOLETE       unsigned char buffer[100];
// OBSOLETE       int cc;
// OBSOLETE 
// OBSOLETE       /* Setup the socket.  Must be raw UDP. */
// OBSOLETE 
// OBSOLETE       he = gethostbyname (p);
// OBSOLETE 
// OBSOLETE       if (!he)
// OBSOLETE 	error ("No such host %s.", p);
// OBSOLETE 
// OBSOLETE       udp_fd = socket (PF_INET, SOCK_DGRAM, 0);
// OBSOLETE 
// OBSOLETE       old_chain = make_cleanup (close, udp_fd);
// OBSOLETE 
// OBSOLETE       sockaddr.sin_family = PF_INET;
// OBSOLETE       sockaddr.sin_port = htons (7000);
// OBSOLETE       memcpy (&sockaddr.sin_addr.s_addr, he->h_addr, sizeof (struct in_addr));
// OBSOLETE 
// OBSOLETE       if (connect (udp_fd, &sockaddr, sizeof (sockaddr)))
// OBSOLETE 	perror_with_name ("Connect failed");
// OBSOLETE 
// OBSOLETE       buffer[0] = 0x5;
// OBSOLETE       buffer[1] = 0;
// OBSOLETE 
// OBSOLETE       send_udp_buf (udp_fd, buffer, 2);		/* Request version */
// OBSOLETE       cc = recv_udp_buf (udp_fd, buffer, sizeof (buffer), 5);	/* Get response */
// OBSOLETE       if (cc == 0)
// OBSOLETE 	error ("SPARClite isn't responding.");
// OBSOLETE 
// OBSOLETE       if (cc < 3)
// OBSOLETE 	error ("SPARClite appears to be ill.");
// OBSOLETE #else
// OBSOLETE       error ("UDP downloading is not supported for DOS hosts.");
// OBSOLETE #endif /* HAVE_SOCKETS */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   printf_unfiltered ("[SPARClite appears to be alive]\n");
// OBSOLETE 
// OBSOLETE   push_target (&sparclite_ops);
// OBSOLETE 
// OBSOLETE   discard_cleanups (old_chain);
// OBSOLETE 
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclite_close (int quitting)
// OBSOLETE {
// OBSOLETE   if (serial_flag)
// OBSOLETE     close_tty (0);
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE   else if (udp_fd != -1)
// OBSOLETE     close (udp_fd);
// OBSOLETE #endif
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #define LOAD_ADDRESS 0x40000000
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE download (char *target_name, char *args, int from_tty,
// OBSOLETE 	  void (*write_routine) (bfd *from_bfd, asection *from_sec,
// OBSOLETE 				 file_ptr from_addr, bfd_vma to_addr, int len),
// OBSOLETE 	  void (*start_routine) (bfd_vma entry))
// OBSOLETE {
// OBSOLETE   struct cleanup *old_chain;
// OBSOLETE   asection *section;
// OBSOLETE   bfd *pbfd;
// OBSOLETE   bfd_vma entry;
// OBSOLETE   int i;
// OBSOLETE #define WRITESIZE 1024
// OBSOLETE   char *filename;
// OBSOLETE   int quiet;
// OBSOLETE   int nostart;
// OBSOLETE 
// OBSOLETE   quiet = 0;
// OBSOLETE   nostart = 0;
// OBSOLETE   filename = NULL;
// OBSOLETE 
// OBSOLETE   while (*args != '\000')
// OBSOLETE     {
// OBSOLETE       char *arg;
// OBSOLETE 
// OBSOLETE       while (isspace (*args))
// OBSOLETE 	args++;
// OBSOLETE 
// OBSOLETE       arg = args;
// OBSOLETE 
// OBSOLETE       while ((*args != '\000') && !isspace (*args))
// OBSOLETE 	args++;
// OBSOLETE 
// OBSOLETE       if (*args != '\000')
// OBSOLETE 	*args++ = '\000';
// OBSOLETE 
// OBSOLETE       if (*arg != '-')
// OBSOLETE 	filename = arg;
// OBSOLETE       else if (strncmp (arg, "-quiet", strlen (arg)) == 0)
// OBSOLETE 	quiet = 1;
// OBSOLETE       else if (strncmp (arg, "-nostart", strlen (arg)) == 0)
// OBSOLETE 	nostart = 1;
// OBSOLETE       else
// OBSOLETE 	error ("unknown option `%s'", arg);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!filename)
// OBSOLETE     filename = get_exec_file (1);
// OBSOLETE 
// OBSOLETE   pbfd = bfd_openr (filename, gnutarget);
// OBSOLETE   if (pbfd == NULL)
// OBSOLETE     {
// OBSOLETE       perror_with_name (filename);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE   old_chain = make_cleanup_bfd_close (pbfd);
// OBSOLETE 
// OBSOLETE   if (!bfd_check_format (pbfd, bfd_object))
// OBSOLETE     error ("\"%s\" is not an object file: %s", filename,
// OBSOLETE 	   bfd_errmsg (bfd_get_error ()));
// OBSOLETE 
// OBSOLETE   for (section = pbfd->sections; section; section = section->next)
// OBSOLETE     {
// OBSOLETE       if (bfd_get_section_flags (pbfd, section) & SEC_LOAD)
// OBSOLETE 	{
// OBSOLETE 	  bfd_vma section_address;
// OBSOLETE 	  bfd_size_type section_size;
// OBSOLETE 	  file_ptr fptr;
// OBSOLETE 	  const char *section_name;
// OBSOLETE 
// OBSOLETE 	  section_name = bfd_get_section_name (pbfd, section);
// OBSOLETE 
// OBSOLETE 	  section_address = bfd_get_section_vma (pbfd, section);
// OBSOLETE 
// OBSOLETE 	  /* Adjust sections from a.out files, since they don't
// OBSOLETE 	     carry their addresses with.  */
// OBSOLETE 	  if (bfd_get_flavour (pbfd) == bfd_target_aout_flavour)
// OBSOLETE 	    {
// OBSOLETE 	      if (strcmp (section_name, ".text") == 0)
// OBSOLETE 		section_address = bfd_get_start_address (pbfd);
// OBSOLETE 	      else if (strcmp (section_name, ".data") == 0)
// OBSOLETE 		{
// OBSOLETE 		  /* Read the first 8 bytes of the data section.
// OBSOLETE 		     There should be the string 'DaTa' followed by
// OBSOLETE 		     a word containing the actual section address. */
// OBSOLETE 		  struct data_marker
// OBSOLETE 		    {
// OBSOLETE 		      char signature[4];	/* 'DaTa' */
// OBSOLETE 		      unsigned char sdata[4];	/* &sdata */
// OBSOLETE 		    }
// OBSOLETE 		  marker;
// OBSOLETE 		  bfd_get_section_contents (pbfd, section, &marker, 0,
// OBSOLETE 					    sizeof (marker));
// OBSOLETE 		  if (strncmp (marker.signature, "DaTa", 4) == 0)
// OBSOLETE 		    {
// OBSOLETE 		      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
// OBSOLETE 			section_address = bfd_getb32 (marker.sdata);
// OBSOLETE 		      else
// OBSOLETE 			section_address = bfd_getl32 (marker.sdata);
// OBSOLETE 		    }
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  section_size = bfd_get_section_size_before_reloc (section);
// OBSOLETE 
// OBSOLETE 	  if (!quiet)
// OBSOLETE 	    printf_filtered ("[Loading section %s at 0x%x (%d bytes)]\n",
// OBSOLETE 			     bfd_get_section_name (pbfd, section),
// OBSOLETE 			     section_address,
// OBSOLETE 			     section_size);
// OBSOLETE 
// OBSOLETE 	  fptr = 0;
// OBSOLETE 	  while (section_size > 0)
// OBSOLETE 	    {
// OBSOLETE 	      int count;
// OBSOLETE 	      static char inds[] = "|/-\\";
// OBSOLETE 	      static int k = 0;
// OBSOLETE 
// OBSOLETE 	      QUIT;
// OBSOLETE 
// OBSOLETE 	      count = min (section_size, WRITESIZE);
// OBSOLETE 
// OBSOLETE 	      write_routine (pbfd, section, fptr, section_address, count);
// OBSOLETE 
// OBSOLETE 	      if (!quiet)
// OBSOLETE 		{
// OBSOLETE 		  printf_unfiltered ("\r%c", inds[k++ % 4]);
// OBSOLETE 		  gdb_flush (gdb_stdout);
// OBSOLETE 		}
// OBSOLETE 
// OBSOLETE 	      section_address += count;
// OBSOLETE 	      fptr += count;
// OBSOLETE 	      section_size -= count;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!nostart)
// OBSOLETE     {
// OBSOLETE       entry = bfd_get_start_address (pbfd);
// OBSOLETE 
// OBSOLETE       if (!quiet)
// OBSOLETE 	printf_unfiltered ("[Starting %s at 0x%x]\n", filename, entry);
// OBSOLETE 
// OBSOLETE       start_routine (entry);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   do_cleanups (old_chain);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclite_serial_start (bfd_vma entry)
// OBSOLETE {
// OBSOLETE   char buffer[5];
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   buffer[0] = 0x03;
// OBSOLETE   store_unsigned_integer (buffer + 1, 4, entry);
// OBSOLETE 
// OBSOLETE   debug_serial_write (remote_desc, buffer, 1 + 4);
// OBSOLETE   i = readchar (remote_desc, remote_timeout);
// OBSOLETE   if (i != 0x55)
// OBSOLETE     error ("Can't start SparcLite.  Error code %d\n", i);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclite_serial_write (bfd *from_bfd, asection *from_sec, file_ptr from_addr,
// OBSOLETE 			bfd_vma to_addr, int len)
// OBSOLETE {
// OBSOLETE   char buffer[4 + 4 + WRITESIZE];	/* addr + len + data */
// OBSOLETE   unsigned char checksum;
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   store_unsigned_integer (buffer, 4, to_addr);	/* Address */
// OBSOLETE   store_unsigned_integer (buffer + 4, 4, len);	/* Length */
// OBSOLETE 
// OBSOLETE   bfd_get_section_contents (from_bfd, from_sec, buffer + 8, from_addr, len);
// OBSOLETE 
// OBSOLETE   checksum = 0;
// OBSOLETE   for (i = 0; i < len; i++)
// OBSOLETE     checksum += buffer[8 + i];
// OBSOLETE 
// OBSOLETE   i = send_resp (remote_desc, 0x01);
// OBSOLETE 
// OBSOLETE   if (i != 0x5a)
// OBSOLETE     error ("Bad response from load command (0x%x)", i);
// OBSOLETE 
// OBSOLETE   debug_serial_write (remote_desc, buffer, 4 + 4 + len);
// OBSOLETE   i = readchar (remote_desc, remote_timeout);
// OBSOLETE 
// OBSOLETE   if (i != checksum)
// OBSOLETE     error ("Bad checksum from load command (0x%x)", i);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE 
// OBSOLETE static unsigned short
// OBSOLETE calc_checksum (unsigned char *buffer, int count)
// OBSOLETE {
// OBSOLETE   unsigned short checksum;
// OBSOLETE 
// OBSOLETE   checksum = 0;
// OBSOLETE   for (; count > 0; count -= 2, buffer += 2)
// OBSOLETE     checksum += (*buffer << 8) | *(buffer + 1);
// OBSOLETE 
// OBSOLETE   if (count != 0)
// OBSOLETE     checksum += *buffer << 8;
// OBSOLETE 
// OBSOLETE   return checksum;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclite_udp_start (bfd_vma entry)
// OBSOLETE {
// OBSOLETE   unsigned char buffer[6];
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   buffer[0] = 0x3;
// OBSOLETE   buffer[1] = 0;
// OBSOLETE   buffer[2] = entry >> 24;
// OBSOLETE   buffer[3] = entry >> 16;
// OBSOLETE   buffer[4] = entry >> 8;
// OBSOLETE   buffer[5] = entry;
// OBSOLETE 
// OBSOLETE   send_udp_buf (udp_fd, buffer, 6);	/* Send start addr */
// OBSOLETE   i = recv_udp_buf (udp_fd, buffer, sizeof (buffer), -1);	/* Get response */
// OBSOLETE 
// OBSOLETE   if (i < 1 || buffer[0] != 0x55)
// OBSOLETE     error ("Failed to take start address.");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclite_udp_write (bfd *from_bfd, asection *from_sec, file_ptr from_addr,
// OBSOLETE 		     bfd_vma to_addr, int len)
// OBSOLETE {
// OBSOLETE   unsigned char buffer[2000];
// OBSOLETE   unsigned short checksum;
// OBSOLETE   static int pkt_num = 0;
// OBSOLETE   static unsigned long old_addr = -1;
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       if (to_addr != old_addr)
// OBSOLETE 	{
// OBSOLETE 	  buffer[0] = 0x1;	/* Load command */
// OBSOLETE 	  buffer[1] = 0x1;	/* Loading address */
// OBSOLETE 	  buffer[2] = to_addr >> 24;
// OBSOLETE 	  buffer[3] = to_addr >> 16;
// OBSOLETE 	  buffer[4] = to_addr >> 8;
// OBSOLETE 	  buffer[5] = to_addr;
// OBSOLETE 
// OBSOLETE 	  checksum = 0;
// OBSOLETE 	  for (i = 0; i < 6; i++)
// OBSOLETE 	    checksum += buffer[i];
// OBSOLETE 	  checksum &= 0xff;
// OBSOLETE 
// OBSOLETE 	  send_udp_buf (udp_fd, buffer, 6);
// OBSOLETE 	  i = recv_udp_buf (udp_fd, buffer, sizeof buffer, -1);
// OBSOLETE 
// OBSOLETE 	  if (i < 1)
// OBSOLETE 	    error ("Got back short checksum for load addr.");
// OBSOLETE 
// OBSOLETE 	  if (checksum != buffer[0])
// OBSOLETE 	    error ("Got back bad checksum for load addr.");
// OBSOLETE 
// OBSOLETE 	  pkt_num = 0;		/* Load addr resets packet seq # */
// OBSOLETE 	  old_addr = to_addr;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       bfd_get_section_contents (from_bfd, from_sec, buffer + 6, from_addr,
// OBSOLETE 				len);
// OBSOLETE 
// OBSOLETE       checksum = calc_checksum (buffer + 6, len);
// OBSOLETE 
// OBSOLETE       buffer[0] = 0x1;		/* Load command */
// OBSOLETE       buffer[1] = 0x2;		/* Loading data */
// OBSOLETE       buffer[2] = pkt_num >> 8;
// OBSOLETE       buffer[3] = pkt_num;
// OBSOLETE       buffer[4] = checksum >> 8;
// OBSOLETE       buffer[5] = checksum;
// OBSOLETE 
// OBSOLETE       send_udp_buf (udp_fd, buffer, len + 6);
// OBSOLETE       i = recv_udp_buf (udp_fd, buffer, sizeof buffer, 3);
// OBSOLETE 
// OBSOLETE       if (i == 0)
// OBSOLETE 	{
// OBSOLETE 	  fprintf_unfiltered (gdb_stderr, "send_data: timeout sending %d bytes to address 0x%x retrying\n", len, to_addr);
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (buffer[0] != 0xff)
// OBSOLETE 	error ("Got back bad response for load data.");
// OBSOLETE 
// OBSOLETE       old_addr += len;
// OBSOLETE       pkt_num++;
// OBSOLETE 
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* HAVE_SOCKETS */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclite_download (char *filename, int from_tty)
// OBSOLETE {
// OBSOLETE   if (!serial_flag)
// OBSOLETE #ifdef HAVE_SOCKETS
// OBSOLETE     download (remote_target_name, filename, from_tty, sparclite_udp_write,
// OBSOLETE 	      sparclite_udp_start);
// OBSOLETE #else
// OBSOLETE     internal_error (__FILE__, __LINE__, "failed internal consistency check");			/* sparclite_open should prevent this! */
// OBSOLETE #endif
// OBSOLETE   else
// OBSOLETE     download (remote_target_name, filename, from_tty, sparclite_serial_write,
// OBSOLETE 	      sparclite_serial_start);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Set up the sparclite target vector.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_sparclite_ops (void)
// OBSOLETE {
// OBSOLETE   sparclite_ops.to_shortname = "sparclite";
// OBSOLETE   sparclite_ops.to_longname = "SPARClite download target";
// OBSOLETE   sparclite_ops.to_doc = "Download to a remote SPARClite target board via serial of UDP.\n\
// OBSOLETE Specify the device it is connected to (e.g. /dev/ttya).";
// OBSOLETE   sparclite_ops.to_open = sparclite_open;
// OBSOLETE   sparclite_ops.to_close = sparclite_close;
// OBSOLETE   sparclite_ops.to_load = sparclite_download;
// OBSOLETE   sparclite_ops.to_stratum = download_stratum;
// OBSOLETE   sparclite_ops.to_magic = OPS_MAGIC;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_sparcl_tdep (void)
// OBSOLETE {
// OBSOLETE   init_sparclite_ops ();
// OBSOLETE   add_target (&sparclite_ops);
// OBSOLETE }
@


1.16.8.2
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@@


1.15
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d30 1
a30 1
#if (!defined(__GO32__) && !defined(_WIN32)) || defined(__CYGWIN32__)
@


1.15.8.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d30 1
a30 1
#if (!defined(__GO32__) && !defined(_WIN32)) || defined(__CYGWIN__)
@


1.15.6.1
log
@merge from trunk
@
text
@d30 1
a30 1
#if (!defined(__GO32__) && !defined(_WIN32)) || defined(__CYGWIN__)
@


1.14
log
@* serial.h (SERIAL_ASYNC): Delete.
(DEPRECATED_SERIAL_FD): Delete.
(SERIAL_DEBUG): Delete.
(SERIAL_DEBUG_P): Delete.
(SERIAL_DRAIN_OUTPUT): Delete.
(SERIAL_FLUSH_OUTPUT): Delete.
(SERIAL_FLUSH_INPUT): Delete.
(SERIAL_SEND_BREAK): Delete.
(SERIAL_RAW): Delete.
(SERIAL_GET_TTY_STATE): Delete.
(SERIAL_SET_TTY_STATE): Delete.
(SERIAL_PRINT_TTY_STATE): Delete.
(SERIAL_NOFLUSH_SET_TTY_STATE): Delete.
(SERIAL_SETBAUDRATE): Delete.
(SERIAL_SETSTOPBITS): Delete.
(SERIAL_CAN_ASYNC_P): Delete.
(SERIAL_IS_ASYNC_P): Delete.
(SERIAL_UN_FDOPEN): Delete.
(SERIAL_READCHAR): Delete.
(SERIAL_CLOSE): Delete.
(SERIAL_FDOPEN): Delete.
(SERIAL_OPEN): Delete.
@
text
@d625 1
a625 1
		      if (TARGET_BYTE_ORDER == BIG_ENDIAN)
@


1.13
log
@s/typedef serial_t/struct serial */
@
text
@d267 1
a267 1
  desc = SERIAL_OPEN (name);
d273 1
a273 1
      if (SERIAL_SETBAUDRATE (desc, baud_rate))
d275 1
a275 1
	  SERIAL_CLOSE (desc);
d280 1
a280 1
  SERIAL_RAW (desc);
d282 1
a282 1
  SERIAL_FLUSH_INPUT (desc);
d295 1
a295 1
  ch = SERIAL_READCHAR (desc, timeout);
d320 1
a320 1
  SERIAL_WRITE (desc, buf, len);
d346 1
a346 1
  SERIAL_CLOSE (remote_desc);
@


1.12
log
@Update/correct copyright notices.
@
text
@d41 1
a41 1
static serial_t remote_desc = NULL;
d47 2
a48 2
static serial_t open_tty (char *name);
static int send_resp (serial_t desc, char c);
d262 1
a262 1
static serial_t
d265 1
a265 1
  serial_t desc;
d290 1
a290 1
readchar (serial_t desc, int timeout)
d316 1
a316 1
debug_serial_write (serial_t desc, char *buf, int len)
d334 1
a334 1
send_resp (serial_t desc, char c)
@


1.11
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1994, 1995, 1996, 1999, 2001  Free Software Foundation, Inc.
@


1.10
log
@Replace calls to abort() with calls to internal_error().
@
text
@d26 1
@


1.9
log
@Replace strsave() with xstrdup().
@
text
@d839 1
a839 1
    abort ();			/* sparclite_open should prevent this! */
@


1.8
log
@Replace free() with xfree().
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1999  Free Software Foundation, Inc.
d416 1
a416 1
  remote_target_name = strsave (name);
@


1.7
log
@Protoization.
@
text
@d414 1
a414 1
    free (remote_target_name);
@


1.6
log
@Protoization.
@
text
@d530 4
a533 7
download (target_name, args, from_tty, write_routine, start_routine)
     char *target_name;
     char *args;
     int from_tty;
     void (*write_routine) (bfd * from_bfd, asection * from_sec,
			    file_ptr from_addr, bfd_vma to_addr, int len);
     void (*start_routine) (bfd_vma entry);
@


1.5
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d94 1
a94 4
sparclite_insert_watchpoint (addr, len, type)
     CORE_ADDR addr;
     int len;
     int type;
d157 1
a157 4
sparclite_remove_watchpoint (addr, len, type)
     CORE_ADDR addr;
     int len;
     int type;
d176 1
a176 3
sparclite_insert_hw_breakpoint (addr, len)
     CORE_ADDR addr;
     int len;
d199 1
a199 3
sparclite_remove_hw_breakpoint (addr, shadow)
     CORE_ADDR addr;
     int shadow;
d218 1
a218 4
sparclite_check_watch_resources (type, cnt, ot)
     int type;
     int cnt;
     int ot;
d244 1
a244 1
sparclite_stopped_data_address ()
d261 1
a261 2
open_tty (name)
     char *name;
d288 1
a288 3
readchar (desc, timeout)
     serial_t desc;
     int timeout;
d314 1
a314 4
debug_serial_write (desc, buf, len)
     serial_t desc;
     char *buf;
     int len;
d332 1
a332 3
send_resp (desc, c)
     serial_t desc;
     char c;
d351 1
a351 4
recv_udp_buf (fd, buf, len, timeout)
     int fd, len;
     unsigned char *buf;
     int timeout;
d383 1
a383 3
send_udp_buf (fd, buf, len)
     int fd, len;
     unsigned char *buf;
d400 1
a400 3
sparclite_open (name, from_tty)
     char *name;
     int from_tty;
d517 1
a517 2
sparclite_close (quitting)
     int quitting;
d682 1
a682 2
sparclite_serial_start (entry)
     bfd_vma entry;
d697 2
a698 6
sparclite_serial_write (from_bfd, from_sec, from_addr, to_addr, len)
     bfd *from_bfd;
     asection *from_sec;
     file_ptr from_addr;
     bfd_vma to_addr;
     int len;
d728 1
a728 3
calc_checksum (buffer, count)
     unsigned char *buffer;
     int count;
d743 1
a743 2
sparclite_udp_start (entry)
     bfd_vma entry;
d763 2
a764 6
sparclite_udp_write (from_bfd, from_sec, from_addr, to_addr, len)
     bfd *from_bfd;
     asection *from_sec;
     file_ptr from_addr;
     bfd_vma to_addr;
     int len;
d835 1
a835 3
sparclite_download (filename, from_tty)
     char *filename;
     int from_tty;
d866 1
a866 1
_initialize_sparcl_tdep ()
@


1.4
log
@PARAMS removal.
@
text
@d563 3
a565 3
     void (*write_routine) PARAMS ((bfd * from_bfd, asection * from_sec,
			     file_ptr from_addr, bfd_vma to_addr, int len));
     void (*start_routine) PARAMS ((bfd_vma entry));
@


1.3
log
@Purge (almost) make_cleanup_func.
@
text
@d45 2
a46 2
static serial_t open_tty PARAMS ((char *name));
static int send_resp PARAMS ((serial_t desc, char c));
d49 2
a50 2
static int recv_udp_buf PARAMS ((int fd, unsigned char *buf, int len, int timeout));
static int send_udp_buf PARAMS ((int fd, unsigned char *buf, int len));
d52 12
a63 12
static void sparclite_open PARAMS ((char *name, int from_tty));
static void sparclite_close PARAMS ((int quitting));
static void download PARAMS ((char *target_name, char *args, int from_tty,
			      void (*write_routine) (bfd * from_bfd,
						     asection * from_sec,
						     file_ptr from_addr,
						  bfd_vma to_addr, int len),
			      void (*start_routine) (bfd_vma entry)));
static void sparclite_serial_start PARAMS ((bfd_vma entry));
static void sparclite_serial_write PARAMS ((bfd * from_bfd, asection * from_sec,
					    file_ptr from_addr,
					    bfd_vma to_addr, int len));
d65 5
a69 6
static unsigned short calc_checksum PARAMS ((unsigned char *buffer,
					     int count));
static void sparclite_udp_start PARAMS ((bfd_vma entry));
static void sparclite_udp_write PARAMS ((bfd * from_bfd, asection * from_sec,
					 file_ptr from_addr, bfd_vma to_addr,
					 int len));
d71 1
a71 1
static void sparclite_download PARAMS ((char *filename, int from_tty));
@


1.2
log
@Cleanup bfd_close() cleanups.
@
text
@d47 1
a47 1
static void close_tty PARAMS ((int ignore));
d361 1
a361 2
close_tty (ignore)
     int ignore;
d482 1
a482 1
      old_chain = make_cleanup ((make_cleanup_func) close_tty, 0);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996  Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a30 1
#include <unistd.h>
d36 1
a36 2
extern struct target_ops sparclite_ops;	/* Forward decl */
extern struct target_ops remote_ops;
d55 2
a56 2
			      void (*write_routine) (bfd *from_bfd,
						     asection *from_sec,
d58 1
a58 1
						     bfd_vma to_addr, int len),
d61 1
a61 1
static void sparclite_serial_write PARAMS ((bfd *from_bfd, asection *from_sec,
d68 1
a68 1
static void sparclite_udp_write PARAMS ((bfd *from_bfd, asection *from_sec,
d78 1
a78 1
#define DDA1_ASI_MASK 		0xff0000 
d85 1
a85 1
#define DSINGLE_STEP 		0x10		/* not used */
d114 1
a114 1
	}   
d158 1
a158 1
} 
d190 1
a190 1
  
d217 1
a217 1
  
d458 2
a459 1
      while ((*p != '\000') && isspace (*p)) p++;
d516 1
a516 1
      sockaddr.sin_port = htons(7000);
d519 1
a519 1
      if (connect (udp_fd, &sockaddr, sizeof(sockaddr)))
d525 2
a526 2
      send_udp_buf (udp_fd, buffer, 2);	/* Request version */
      cc = recv_udp_buf (udp_fd, buffer, sizeof(buffer), 5); /* Get response */
d553 2
a554 3
  else
    if (udp_fd != -1)
      close (udp_fd);
d565 2
a566 2
     void (*write_routine) PARAMS ((bfd *from_bfd, asection *from_sec,
				    file_ptr from_addr, bfd_vma to_addr, int len));
d587 2
a588 1
      while (isspace (*args)) args++;
d592 2
a593 1
      while ((*args != '\000') && !isspace (*args)) args++;
d617 1
a617 1
  old_chain = make_cleanup ((make_cleanup_func) bfd_close, pbfd);
d619 1
a619 1
  if (!bfd_check_format (pbfd, bfd_object)) 
d623 1
a623 1
  for (section = pbfd->sections; section; section = section->next) 
d627 1
a627 1
	  bfd_vma	section_address;
d629 2
a630 2
	  file_ptr	fptr;
	  const char   *section_name;
d632 1
a632 1
	  section_name = bfd_get_section_name(pbfd, section);
d648 5
a652 4
		  {
		    char signature[4];	/* 'DaTa' */
		    unsigned char sdata[4];	/* &sdata */
		  } marker;
d736 1
a736 1
  char buffer[4 + 4 + WRITESIZE]; /* addr + len + data */
d740 2
a741 2
  store_unsigned_integer (buffer, 4, to_addr); /* Address */
  store_unsigned_integer (buffer + 4, 4, len); /* Length */
d794 2
a795 2
  send_udp_buf (udp_fd, buffer, 6); /* Send start addr */
  i = recv_udp_buf (udp_fd, buffer, sizeof(buffer), -1); /* Get response */
d894 1
a894 1
/* Define the target subroutine names */
d896 2
a897 4
static struct target_ops sparclite_ops ;

static void 
init_sparclite_ops(void)
d899 10
a908 65
  sparclite_ops.to_shortname =   "sparclite";		
  sparclite_ops.to_longname =   "SPARClite remote target";
  sparclite_ops.to_doc =   "Use a remote SPARClite target board via a serial line; using a gdb-specific protocol.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";  
  sparclite_ops.to_open =   sparclite_open;	
  sparclite_ops.to_close =   sparclite_close;	
  sparclite_ops.to_attach =   0;	
  sparclite_ops.to_post_attach = NULL;
  sparclite_ops.to_require_attach = NULL;
  sparclite_ops.to_detach =   0;
  sparclite_ops.to_require_detach = NULL;	
  sparclite_ops.to_resume =   0;	
  sparclite_ops.to_wait  =   0;
  sparclite_ops.to_post_wait = NULL;		
  sparclite_ops.to_fetch_registers  =   0;
  sparclite_ops.to_store_registers  =   0;
  sparclite_ops.to_prepare_to_store =   0;
  sparclite_ops.to_xfer_memory  =   0;		
  sparclite_ops.to_files_info  =   0;		
  sparclite_ops.to_insert_breakpoint =   0;	
  sparclite_ops.to_remove_breakpoint =   0;	
  sparclite_ops.to_terminal_init  =   0;	
  sparclite_ops.to_terminal_inferior =   0;	
  sparclite_ops.to_terminal_ours_for_output =   0;
  sparclite_ops.to_terminal_ours  =   0;		
  sparclite_ops.to_terminal_info  =   0;		
  sparclite_ops.to_kill  =   0;			
  sparclite_ops.to_load  =   sparclite_download;
  sparclite_ops.to_lookup_symbol =   0;		
  sparclite_ops.to_create_inferior =   0;
  sparclite_ops.to_post_startup_inferior = NULL;
  sparclite_ops.to_acknowledge_created_inferior = NULL;
  sparclite_ops.to_clone_and_follow_inferior = NULL;
  sparclite_ops.to_post_follow_inferior_by_clone = NULL;
  sparclite_ops.to_insert_fork_catchpoint = NULL;
  sparclite_ops.to_remove_fork_catchpoint = NULL;
  sparclite_ops.to_insert_vfork_catchpoint = NULL;
  sparclite_ops.to_remove_vfork_catchpoint = NULL;
  sparclite_ops.to_has_forked = NULL;
  sparclite_ops.to_has_vforked = NULL;
  sparclite_ops.to_can_follow_vfork_prior_to_exec = NULL;
  sparclite_ops.to_post_follow_vfork = NULL;	
  sparclite_ops.to_insert_exec_catchpoint = NULL;
  sparclite_ops.to_remove_exec_catchpoint = NULL;
  sparclite_ops.to_has_execd = NULL;
  sparclite_ops.to_reported_exec_events_per_exec_call = NULL;
  sparclite_ops.to_has_exited = NULL;
  sparclite_ops.to_mourn_inferior =   0;	
  sparclite_ops.to_can_run  =   0;		
  sparclite_ops.to_notice_signals =   0;	
  sparclite_ops.to_thread_alive  =   0;		
  sparclite_ops.to_stop  =   0;
  sparclite_ops.to_pid_to_exec_file = NULL;	
  sparclite_ops.to_core_file_to_sym_file = NULL;		
  sparclite_ops.to_stratum =   download_stratum;
  sparclite_ops.DONT_USE =   0;			
  sparclite_ops.to_has_all_memory =   0;	
  sparclite_ops.to_has_memory =   0;		
  sparclite_ops.to_has_stack =   0;		
  sparclite_ops.to_has_registers =   0;		
  sparclite_ops.to_has_execution =   0;		
  sparclite_ops.to_sections =   0;		
  sparclite_ops.to_sections_end =   0;		
  sparclite_ops.to_magic =   OPS_MAGIC	;	
} /* init_sparclite_ops */
d913 1
a913 1
  init_sparclite_ops() ;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-05 snapshot
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1999  Free Software Foundation, Inc.
a25 4

#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif
@


1.1.1.3
log
@import gdb-1999-07-07 pre reformat
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996  Free Software Foundation, Inc.
d26 4
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d36 1
a36 1
extern struct target_ops sparclite_ops;		/* Forward decl */
d56 2
a57 2
			      void (*write_routine) (bfd * from_bfd,
						     asection * from_sec,
d59 1
a59 1
						  bfd_vma to_addr, int len),
d62 1
a62 1
static void sparclite_serial_write PARAMS ((bfd * from_bfd, asection * from_sec,
d69 1
a69 1
static void sparclite_udp_write PARAMS ((bfd * from_bfd, asection * from_sec,
d79 1
a79 1
#define DDA1_ASI_MASK 		0xff0000
d86 1
a86 1
#define DSINGLE_STEP 		0x10	/* not used */
d115 1
a115 1
	}
d159 1
a159 1
}
d191 1
a191 1

d218 1
a218 1

d459 1
a459 2
      while ((*p != '\000') && isspace (*p))
	p++;
d516 1
a516 1
      sockaddr.sin_port = htons (7000);
d519 1
a519 1
      if (connect (udp_fd, &sockaddr, sizeof (sockaddr)))
d525 2
a526 2
      send_udp_buf (udp_fd, buffer, 2);		/* Request version */
      cc = recv_udp_buf (udp_fd, buffer, sizeof (buffer), 5);	/* Get response */
d553 3
a555 2
  else if (udp_fd != -1)
    close (udp_fd);
d566 2
a567 2
     void (*write_routine) PARAMS ((bfd * from_bfd, asection * from_sec,
			     file_ptr from_addr, bfd_vma to_addr, int len));
d588 1
a588 2
      while (isspace (*args))
	args++;
d592 1
a592 2
      while ((*args != '\000') && !isspace (*args))
	args++;
d618 1
a618 1
  if (!bfd_check_format (pbfd, bfd_object))
d622 1
a622 1
  for (section = pbfd->sections; section; section = section->next)
d626 1
a626 1
	  bfd_vma section_address;
d628 2
a629 2
	  file_ptr fptr;
	  const char *section_name;
d631 1
a631 1
	  section_name = bfd_get_section_name (pbfd, section);
d647 4
a650 5
		    {
		      char signature[4];	/* 'DaTa' */
		      unsigned char sdata[4];	/* &sdata */
		    }
		  marker;
d734 1
a734 1
  char buffer[4 + 4 + WRITESIZE];	/* addr + len + data */
d738 2
a739 2
  store_unsigned_integer (buffer, 4, to_addr);	/* Address */
  store_unsigned_integer (buffer + 4, 4, len);	/* Length */
d792 2
a793 2
  send_udp_buf (udp_fd, buffer, 6);	/* Send start addr */
  i = recv_udp_buf (udp_fd, buffer, sizeof (buffer), -1);	/* Get response */
d894 1
a894 1
static struct target_ops sparclite_ops;
d896 2
a897 2
static void
init_sparclite_ops (void)
d899 7
a905 7
  sparclite_ops.to_shortname = "sparclite";
  sparclite_ops.to_longname = "SPARClite remote target";
  sparclite_ops.to_doc = "Use a remote SPARClite target board via a serial line; using a gdb-specific protocol.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  sparclite_ops.to_open = sparclite_open;
  sparclite_ops.to_close = sparclite_close;
  sparclite_ops.to_attach = 0;
d908 21
a928 21
  sparclite_ops.to_detach = 0;
  sparclite_ops.to_require_detach = NULL;
  sparclite_ops.to_resume = 0;
  sparclite_ops.to_wait = 0;
  sparclite_ops.to_post_wait = NULL;
  sparclite_ops.to_fetch_registers = 0;
  sparclite_ops.to_store_registers = 0;
  sparclite_ops.to_prepare_to_store = 0;
  sparclite_ops.to_xfer_memory = 0;
  sparclite_ops.to_files_info = 0;
  sparclite_ops.to_insert_breakpoint = 0;
  sparclite_ops.to_remove_breakpoint = 0;
  sparclite_ops.to_terminal_init = 0;
  sparclite_ops.to_terminal_inferior = 0;
  sparclite_ops.to_terminal_ours_for_output = 0;
  sparclite_ops.to_terminal_ours = 0;
  sparclite_ops.to_terminal_info = 0;
  sparclite_ops.to_kill = 0;
  sparclite_ops.to_load = sparclite_download;
  sparclite_ops.to_lookup_symbol = 0;
  sparclite_ops.to_create_inferior = 0;
d940 1
a940 1
  sparclite_ops.to_post_follow_vfork = NULL;
d946 18
a963 18
  sparclite_ops.to_mourn_inferior = 0;
  sparclite_ops.to_can_run = 0;
  sparclite_ops.to_notice_signals = 0;
  sparclite_ops.to_thread_alive = 0;
  sparclite_ops.to_stop = 0;
  sparclite_ops.to_pid_to_exec_file = NULL;
  sparclite_ops.to_core_file_to_sym_file = NULL;
  sparclite_ops.to_stratum = download_stratum;
  sparclite_ops.DONT_USE = 0;
  sparclite_ops.to_has_all_memory = 0;
  sparclite_ops.to_has_memory = 0;
  sparclite_ops.to_has_stack = 0;
  sparclite_ops.to_has_registers = 0;
  sparclite_ops.to_has_execution = 0;
  sparclite_ops.to_sections = 0;
  sparclite_ops.to_sections_end = 0;
  sparclite_ops.to_magic = OPS_MAGIC;
}				/* init_sparclite_ops */
d968 1
a968 1
  init_sparclite_ops ();
@


1.1.1.5
log
@import gdb-1999-07-12 snapshot
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1999  Free Software Foundation, Inc.
d37 2
a38 1
static struct target_ops sparclite_ops;
d896 3
a898 1
/* Set up the sparclite target vector.  */
d904 3
a906 3
  sparclite_ops.to_longname = "SPARClite download target";
  sparclite_ops.to_doc = "Download to a remote SPARClite target board via serial of UDP.\n\
Specify the device it is connected to (e.g. /dev/ttya).";
d909 21
d931 26
d958 8
d967 1
a967 1
}
@


1.1.1.6
log
@import gdb-1999-08-30 snapshot
@
text
@d31 1
@


