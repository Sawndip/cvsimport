head	1.20;
access;
symbols
	gdb_6_0-2003-10-04-release:1.19
	kettenis_sparc-20030918-branch:1.19.0.16
	kettenis_sparc-20030918-branchpoint:1.19
	carlton_dictionary-20030917-merge:1.19
	ezannoni_pie-20030916-branchpoint:1.19
	ezannoni_pie-20030916-branch:1.19.0.14
	cagney_x86i386-20030821-branch:1.19.0.12
	cagney_x86i386-20030821-branchpoint:1.19
	carlton_dictionary-20030805-merge:1.19
	carlton_dictionary-20030627-merge:1.19
	gdb_6_0-branch:1.19.0.10
	gdb_6_0-2003-06-23-branchpoint:1.19
	jimb-ppc64-linux-20030613-branch:1.19.0.8
	jimb-ppc64-linux-20030613-branchpoint:1.19
	cagney_convert-20030606-branch:1.19.0.6
	cagney_convert-20030606-branchpoint:1.19
	cagney_writestrings-20030508-branch:1.18.0.6
	cagney_writestrings-20030508-branchpoint:1.18
	jimb-ppc64-linux-20030528-branch:1.19.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.19
	carlton_dictionary-20030523-merge:1.19
	cagney_fileio-20030521-branch:1.19.0.2
	cagney_fileio-20030521-branchpoint:1.19
	kettenis_i386newframe-20030517-mergepoint:1.19
	jimb-ppc64-linux-20030509-branch:1.18.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.18
	kettenis_i386newframe-20030504-mergepoint:1.18
	carlton_dictionary-20030430-merge:1.18
	kettenis_i386newframe-20030419-branch:1.18.0.2
	kettenis_i386newframe-20030419-branchpoint:1.18
	carlton_dictionary-20030416-merge:1.18
	cagney_frameaddr-20030409-mergepoint:1.18
	kettenis_i386newframe-20030406-branch:1.17.0.24
	kettenis_i386newframe-20030406-branchpoint:1.17
	cagney_frameaddr-20030403-branchpoint:1.17
	cagney_frameaddr-20030403-branch:1.17.0.22
	cagney_framebase-20030330-mergepoint:1.17
	cagney_framebase-20030326-branch:1.17.0.20
	cagney_framebase-20030326-branchpoint:1.17
	cagney_lazyid-20030317-branch:1.17.0.18
	cagney_lazyid-20030317-branchpoint:1.17
	kettenis-i386newframe-20030316-mergepoint:1.17
	offbyone-20030313-branch:1.17.0.16
	offbyone-20030313-branchpoint:1.17
	kettenis-i386newframe-20030308-branch:1.17.0.14
	kettenis-i386newframe-20030308-branchpoint:1.17
	carlton_dictionary-20030305-merge:1.17
	cagney_offbyone-20030303-branch:1.17.0.12
	cagney_offbyone-20030303-branchpoint:1.17
	carlton_dictionary-20030207-merge:1.17
	interps-20030203-mergepoint:1.17
	interps-20030202-branch:1.17.0.10
	interps-20030202-branchpoint:1.17
	cagney-unwind-20030108-branch:1.17.0.8
	cagney-unwind-20030108-branchpoint:1.17
	carlton_dictionary-20021223-merge:1.17
	gdb_5_3-2002-12-12-release:1.17
	carlton_dictionary-20021115-merge:1.17
	kseitz_interps-20021105-merge:1.17
	kseitz_interps-20021103-merge:1.17
	drow-cplus-merge-20021020:1.17
	drow-cplus-merge-20021025:1.17
	carlton_dictionary-20021025-merge:1.17
	carlton_dictionary-20021011-merge:1.17
	drow-cplus-branch:1.17.0.6
	drow-cplus-branchpoint:1.17
	kseitz_interps-20020930-merge:1.17
	carlton_dictionary-20020927-merge:1.17
	carlton_dictionary-branch:1.17.0.4
	carlton_dictionary-20020920-branchpoint:1.17
	gdb_5_3-branch:1.17.0.2
	gdb_5_3-2002-09-04-branchpoint:1.17
	kseitz_interps-20020829-merge:1.17
	cagney_sysregs-20020825-branch:1.16.0.10
	cagney_sysregs-20020825-branchpoint:1.16
	readline_4_3-import-branch:1.16.0.8
	readline_4_3-import-branchpoint:1.16
	gdb_5_2_1-2002-07-23-release:1.15
	kseitz_interps-20020528-branch:1.16.0.6
	kseitz_interps-20020528-branchpoint:1.16
	cagney_regbuf-20020515-branch:1.16.0.4
	cagney_regbuf-20020515-branchpoint:1.16
	jimb-macro-020506-branch:1.16.0.2
	jimb-macro-020506-branchpoint:1.16
	gdb_5_2-2002-04-29-release:1.15
	gdb_5_2-branch:1.15.0.2
	gdb_5_2-2002-03-03-branchpoint:1.15
	gdb_5_1_1-2002-01-24-release:1.14
	gdb_5_1_0_1-2002-01-03-release:1.14
	cygnus_cvs_20020108_pre:1.14
	gdb_5_1_0_1-2002-01-03-branchpoint:1.14
	gdb_5_1_0_1-2002-01-03-branch:1.14.0.8
	gdb_5_1-2001-11-21-release:1.14
	gdb_s390-2001-09-26-branch:1.14.0.6
	gdb_s390-2001-09-26-branchpoint:1.14
	gdb_5_1-2001-07-29-branch:1.14.0.4
	gdb_5_1-2001-07-29-branchpoint:1.14
	dberlin-typesystem-branch:1.14.0.2
	dberlin-typesystem-branchpoint:1.14
	gdb-post-ptid_t-2001-05-03:1.13
	gdb-pre-ptid_t-2001-05-03:1.12
	insight-precleanup-2001-01-01:1.6
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.5
	insight-2000-02-04:1.1.1.5
	gdb-2000-02-04:1.1.1.5
	gdb-2000-02-02:1.1.1.5
	gdb-2000-02-01:1.1.1.5
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.4
	gdb-1999-10-25:1.1.1.4
	gdb-1999-10-18:1.1.1.4
	gdb-1999-10-11:1.1.1.4
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.20
date	2003.10.06.19.10.44;	author cagney;	state dead;
branches;
next	1.19;

1.19
date	2003.05.14.17.43.18;	author ezannoni;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.09.16.10.05;	author cagney;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2002.08.26.19.18.33;	author ciceron;	state Exp;
branches
	1.17.4.1
	1.17.6.1
	1.17.22.1;
next	1.16;

1.16
date	2002.05.05.01.15.13;	author cagney;	state Exp;
branches
	1.16.6.1;
next	1.15;

1.15
date	2002.02.10.04.08.41;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.06.16.31.32;	author jlarmour;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.04.04.15.25;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.06.17.53.39;	author dsmith;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.14.16.42.30;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.06.08.21.09;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.30.21.50.57;	author jtc;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.15.07.08.11;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.09.20.09.01;	author msnyder;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.46;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.07.44;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.09.21.33.38;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.10.05.23.08.27;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.02.02.00.21.08;	author jsm;	state Exp;
branches;
next	;

1.16.6.1
date	2002.08.30.22.52.44;	author kseitz;	state Exp;
branches;
next	;

1.17.4.1
date	2003.04.16.19.56.53;	author carlton;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2003.05.23.18.40.41;	author carlton;	state Exp;
branches;
next	1.17.4.3;

1.17.4.3
date	2003.11.11.23.50.48;	author carlton;	state dead;
branches;
next	;

1.17.6.1
date	2003.12.14.20.27.20;	author drow;	state dead;
branches;
next	;

1.17.22.1
date	2003.04.10.21.33.49;	author cagney;	state Exp;
branches;
next	;

1.18.2.1
date	2003.05.18.09.44.15;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.20
log
@2003-10-06  Andrew Cagney  <cagney@@redhat.com>

	* z8k-tdep.c, symm-tdep.c, symm-nat.c: Delete obsolete file.
	* sparclet-stub.c, sparclet-rom.c: Delete obsolete file.
	* sparcl-tdep.c, sparcl-stub.c, h8500-tdep.c: Delete obsolete file.
	* m3-nat.c, mipsm3-nat.c, mn10200-tdep.c: Delete obsolete file.
@
text
@// OBSOLETE /* Interface GDB to Mach 3.0 operating systems.
// OBSOLETE    (Most) Mach 3.0 related routines live in this file.
// OBSOLETE 
// OBSOLETE    Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
// OBSOLETE    2002 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Author: Jukka Virtanen <jtv@@hut.fi>
// OBSOLETE  *         Computing Centre
// OBSOLETE  *         Helsinki University of Technology
// OBSOLETE  *         Finland
// OBSOLETE  *
// OBSOLETE  * Thanks to my friends who helped with ideas and testing:
// OBSOLETE  *
// OBSOLETE  *      Johannes Helander, Antti Louko, Tero Mononen,
// OBSOLETE  *      jvh@@cs.hut.fi      alo@@hut.fi   tmo@@cs.hut.fi
// OBSOLETE  *
// OBSOLETE  *      Tero Kivinen       and          Eamonn McManus
// OBSOLETE  *      kivinen@@cs.hut.fi               emcmanus@@gr.osf.org
// OBSOLETE  *      
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #include <stdio.h>
// OBSOLETE 
// OBSOLETE #include <mach.h>
// OBSOLETE #include <servers/netname.h>
// OBSOLETE #include <servers/machid.h>
// OBSOLETE #include <mach/message.h>
// OBSOLETE #include <mach/notify.h>
// OBSOLETE #include <mach_error.h>
// OBSOLETE #include <mach/exception.h>
// OBSOLETE #include <mach/vm_attributes.h>
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "language.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "gdb_wait.h"
// OBSOLETE #include "gdbcmd.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE #include <servers/machid_lib.h>
// OBSOLETE #else
// OBSOLETE #define	MACH_TYPE_TASK			1
// OBSOLETE #define MACH_TYPE_THREAD		2
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /* Included only for signal names and NSIG
// OBSOLETE 
// OBSOLETE  * note: There are many problems in signal handling with
// OBSOLETE  *       gdb in Mach 3.0 in general.
// OBSOLETE  */
// OBSOLETE #include <signal.h>
// OBSOLETE #define SIG_UNKNOWN 0		/* Exception that has no matching unix signal */
// OBSOLETE 
// OBSOLETE #include <cthreads.h>
// OBSOLETE 
// OBSOLETE /* This is what a cproc looks like.  This is here partly because
// OBSOLETE    cthread_internals.h is not a header we can just #include, partly with
// OBSOLETE    an eye towards perhaps getting this to work with cross-debugging
// OBSOLETE    someday.  Best solution is if CMU publishes a real interface to this
// OBSOLETE    stuff.  */
// OBSOLETE #define CPROC_NEXT_OFFSET 0
// OBSOLETE #define CPROC_NEXT_SIZE (TARGET_PTR_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_INCARNATION_OFFSET (CPROC_NEXT_OFFSET + CPROC_NEXT_SIZE)
// OBSOLETE #define CPROC_INCARNATION_SIZE (sizeof (cthread_t))
// OBSOLETE #define CPROC_LIST_OFFSET (CPROC_INCARNATION_OFFSET + CPROC_INCARNATION_SIZE)
// OBSOLETE #define CPROC_LIST_SIZE (TARGET_PTR_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_WAIT_OFFSET (CPROC_LIST_OFFSET + CPROC_LIST_SIZE)
// OBSOLETE #define CPROC_WAIT_SIZE (TARGET_PTR_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_REPLY_OFFSET (CPROC_WAIT_OFFSET + CPROC_WAIT_SIZE)
// OBSOLETE #define CPROC_REPLY_SIZE (sizeof (mach_port_t))
// OBSOLETE #define CPROC_CONTEXT_OFFSET (CPROC_REPLY_OFFSET + CPROC_REPLY_SIZE)
// OBSOLETE #define CPROC_CONTEXT_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_LOCK_OFFSET (CPROC_CONTEXT_OFFSET + CPROC_CONTEXT_SIZE)
// OBSOLETE #define CPROC_LOCK_SIZE (sizeof (spin_lock_t))
// OBSOLETE #define CPROC_STATE_OFFSET (CPROC_LOCK_OFFSET + CPROC_LOCK_SIZE)
// OBSOLETE #define CPROC_STATE_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_WIRED_OFFSET (CPROC_STATE_OFFSET + CPROC_STATE_SIZE)
// OBSOLETE #define CPROC_WIRED_SIZE (sizeof (mach_port_t))
// OBSOLETE #define CPROC_BUSY_OFFSET (CPROC_WIRED_OFFSET + CPROC_WIRED_SIZE)
// OBSOLETE #define CPROC_BUSY_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_MSG_OFFSET (CPROC_BUSY_OFFSET + CPROC_BUSY_SIZE)
// OBSOLETE #define CPROC_MSG_SIZE (sizeof (mach_msg_header_t))
// OBSOLETE #define CPROC_BASE_OFFSET (CPROC_MSG_OFFSET + CPROC_MSG_SIZE)
// OBSOLETE #define CPROC_BASE_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_SIZE_OFFSET (CPROC_BASE_OFFSET + CPROC_BASE_SIZE)
// OBSOLETE #define CPROC_SIZE_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_SIZE (CPROC_SIZE_OFFSET + CPROC_SIZE_SIZE)
// OBSOLETE 
// OBSOLETE /* Values for the state field in the cproc.  */
// OBSOLETE #define CPROC_RUNNING	0
// OBSOLETE #define CPROC_SWITCHING 1
// OBSOLETE #define CPROC_BLOCKED	2
// OBSOLETE #define CPROC_CONDWAIT	4
// OBSOLETE 
// OBSOLETE /* For cproc and kernel thread mapping */
// OBSOLETE typedef struct gdb_thread
// OBSOLETE   {
// OBSOLETE     mach_port_t name;
// OBSOLETE     CORE_ADDR sp;
// OBSOLETE     CORE_ADDR pc;
// OBSOLETE     CORE_ADDR fp;
// OBSOLETE     boolean_t in_emulator;
// OBSOLETE     int slotid;
// OBSOLETE 
// OBSOLETE     /* This is for the mthreads list.  It points to the cproc list.
// OBSOLETE        Perhaps the two lists should be merged (or perhaps it was a mistake
// OBSOLETE        to make them both use a struct gdb_thread).  */
// OBSOLETE     struct gdb_thread *cproc;
// OBSOLETE 
// OBSOLETE     /* These are for the cproc list, which is linked through the next field
// OBSOLETE        of the struct gdb_thread.  */
// OBSOLETE     char raw_cproc[CPROC_SIZE];
// OBSOLETE     /* The cthread which is pointed to by the incarnation field from the
// OBSOLETE        cproc.  This points to the copy we've read into GDB.  */
// OBSOLETE     cthread_t cthread;
// OBSOLETE     /* Point back to the mthreads list.  */
// OBSOLETE     int reverse_map;
// OBSOLETE     struct gdb_thread *next;
// OBSOLETE   }
// OBSOLETE  *gdb_thread_t;
// OBSOLETE 
// OBSOLETE /* 
// OBSOLETE  * Actions for Mach exceptions.
// OBSOLETE  *
// OBSOLETE  * sigmap field maps the exception to corresponding Unix signal.
// OBSOLETE  *
// OBSOLETE  * I do not know how to map the exception to unix signal
// OBSOLETE  * if SIG_UNKNOWN is specified.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE struct exception_list
// OBSOLETE   {
// OBSOLETE     char *name;
// OBSOLETE     boolean_t forward;
// OBSOLETE     boolean_t print;
// OBSOLETE     int sigmap;
// OBSOLETE   }
// OBSOLETE exception_map[] =
// OBSOLETE {
// OBSOLETE   {
// OBSOLETE     "not_mach3_exception", FALSE, TRUE, SIG_UNKNOWN
// OBSOLETE   }
// OBSOLETE   ,
// OBSOLETE   {
// OBSOLETE     "EXC_BAD_ACCESS", FALSE, TRUE, SIGSEGV
// OBSOLETE   }
// OBSOLETE   ,
// OBSOLETE   {
// OBSOLETE     "EXC_BAD_INSTRUCTION", FALSE, TRUE, SIGILL
// OBSOLETE   }
// OBSOLETE   ,
// OBSOLETE   {
// OBSOLETE     "EXC_ARITHMETIC", FALSE, TRUE, SIGFPE
// OBSOLETE   }
// OBSOLETE   ,
// OBSOLETE   {
// OBSOLETE     "EXC_EMULATION", FALSE, TRUE, SIGEMT
// OBSOLETE   }
// OBSOLETE   ,				/* ??? */
// OBSOLETE   {
// OBSOLETE     "EXC_SOFTWARE", FALSE, TRUE, SIG_UNKNOWN
// OBSOLETE   }
// OBSOLETE   ,
// OBSOLETE   {
// OBSOLETE     "EXC_BREAKPOINT", FALSE, FALSE, SIGTRAP
// OBSOLETE   }
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* Mach exception table size */
// OBSOLETE int max_exception = sizeof (exception_map) / sizeof (struct exception_list) - 1;
// OBSOLETE 
// OBSOLETE #define MAX_EXCEPTION max_exception
// OBSOLETE 
// OBSOLETE WAITTYPE wait_status;
// OBSOLETE 
// OBSOLETE /* If you define this, intercepted bsd server calls will be
// OBSOLETE  * dumped while waiting the inferior to EXEC the correct
// OBSOLETE  * program
// OBSOLETE  */
// OBSOLETE /* #define DUMP_SYSCALL         /* debugging interceptor */
// OBSOLETE 
// OBSOLETE /* xx_debug() outputs messages if this is nonzero.
// OBSOLETE  * If > 1, DUMP_SYSCALL will dump message contents.
// OBSOLETE  */
// OBSOLETE int debug_level = 0;
// OBSOLETE 
// OBSOLETE /* "Temporary" debug stuff */
// OBSOLETE void
// OBSOLETE xx_debug (char *fmt, int a, int b, int c)
// OBSOLETE {
// OBSOLETE   if (debug_level)
// OBSOLETE     warning (fmt, a, b, c);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* This is in libmach.a */
// OBSOLETE extern mach_port_t name_server_port;
// OBSOLETE 
// OBSOLETE /* Set in catch_exception_raise */
// OBSOLETE int stop_exception, stop_code, stop_subcode;
// OBSOLETE int stopped_in_exception;
// OBSOLETE 
// OBSOLETE /* Thread that was the active thread when we stopped */
// OBSOLETE thread_t stop_thread = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE char *hostname = "";
// OBSOLETE 
// OBSOLETE /* Set when task is attached or created */
// OBSOLETE boolean_t emulator_present = FALSE;
// OBSOLETE 
// OBSOLETE task_t inferior_task;
// OBSOLETE thread_t current_thread;
// OBSOLETE 
// OBSOLETE /* Exception ports for inferior task */
// OBSOLETE mach_port_t inferior_exception_port = MACH_PORT_NULL;
// OBSOLETE mach_port_t inferior_old_exception_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* task exceptions and notifications */
// OBSOLETE mach_port_t inferior_wait_port_set = MACH_PORT_NULL;
// OBSOLETE mach_port_t our_notify_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* This is "inferior_wait_port_set" when not single stepping, and
// OBSOLETE  *         "singlestepped_thread_port" when we are single stepping.
// OBSOLETE  * 
// OBSOLETE  * This is protected by a cleanup function: discard_single_step()
// OBSOLETE  */
// OBSOLETE mach_port_t currently_waiting_for = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* A port for external messages to gdb.
// OBSOLETE  * External in the meaning that they do not come
// OBSOLETE  * from the inferior_task, but rather from external
// OBSOLETE  * tasks.
// OBSOLETE  *
// OBSOLETE  * As a debugging feature:
// OBSOLETE  * A debugger debugging another debugger can stop the
// OBSOLETE  * inferior debugger by the following command sequence
// OBSOLETE  * (without running external programs)
// OBSOLETE  *
// OBSOLETE  *    (top-gdb) set stop_inferior_gdb ()
// OBSOLETE  *    (top-gdb) continue
// OBSOLETE  */
// OBSOLETE mach_port_t our_message_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* For single stepping */
// OBSOLETE mach_port_t thread_exception_port = MACH_PORT_NULL;
// OBSOLETE mach_port_t thread_saved_exception_port = MACH_PORT_NULL;
// OBSOLETE mach_port_t singlestepped_thread_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* For machid calls */
// OBSOLETE mach_port_t mid_server = MACH_PORT_NULL;
// OBSOLETE mach_port_t mid_auth = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* If gdb thinks the inferior task is not suspended, it
// OBSOLETE  * must take suspend/abort the threads when it reads the state.
// OBSOLETE  */
// OBSOLETE int must_suspend_thread = 0;
// OBSOLETE 
// OBSOLETE /* When single stepping, we switch the port that mach_really_wait() listens to.
// OBSOLETE  * This cleanup is a guard to prevent the port set from being left to
// OBSOLETE  * the singlestepped_thread_port when error() is called.
// OBSOLETE  *  This is nonzero only when we are single stepping.
// OBSOLETE  */
// OBSOLETE #define NULL_CLEANUP (struct cleanup *)0
// OBSOLETE struct cleanup *cleanup_step = NULL_CLEANUP;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static struct target_ops m3_ops;
// OBSOLETE 
// OBSOLETE static void m3_kill_inferior ();
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE #define MACH_TYPE_EXCEPTION_PORT	-1
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /* Chain of ports to remember requested notifications. */
// OBSOLETE 
// OBSOLETE struct port_chain
// OBSOLETE   {
// OBSOLETE     struct port_chain *next;
// OBSOLETE     mach_port_t port;
// OBSOLETE     int type;
// OBSOLETE     int mid;			/* Now only valid with MACH_TYPE_THREAD and */
// OBSOLETE     /*  MACH_TYPE_THREAD */
// OBSOLETE   };
// OBSOLETE typedef struct port_chain *port_chain_t;
// OBSOLETE 
// OBSOLETE /* Room for chain nodes comes from pchain_obstack */
// OBSOLETE struct obstack pchain_obstack;
// OBSOLETE struct obstack *port_chain_obstack = &pchain_obstack;
// OBSOLETE 
// OBSOLETE /* For thread handling */
// OBSOLETE struct obstack Cproc_obstack;
// OBSOLETE struct obstack *cproc_obstack = &Cproc_obstack;
// OBSOLETE 
// OBSOLETE /* the list of notified ports */
// OBSOLETE port_chain_t notify_chain = (port_chain_t) NULL;
// OBSOLETE 
// OBSOLETE port_chain_t
// OBSOLETE port_chain_insert (port_chain_t list, mach_port_t name, int type)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   port_chain_t new;
// OBSOLETE   int mid;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (name))
// OBSOLETE     return list;
// OBSOLETE 
// OBSOLETE   if (type == MACH_TYPE_TASK || type == MACH_TYPE_THREAD)
// OBSOLETE     {
// OBSOLETE       if (!MACH_PORT_VALID (mid_server))
// OBSOLETE 	{
// OBSOLETE 	  warning ("Machid server port invalid, can not map port 0x%x to MID",
// OBSOLETE 		   name);
// OBSOLETE 	  mid = name;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  ret = machid_mach_register (mid_server, mid_auth, name, type, &mid);
// OBSOLETE 
// OBSOLETE 	  if (ret != KERN_SUCCESS)
// OBSOLETE 	    {
// OBSOLETE 	      warning ("Can not map name (0x%x) to MID with machid", name);
// OBSOLETE 	      mid = name;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE 
// OBSOLETE   new = (port_chain_t) obstack_alloc (port_chain_obstack,
// OBSOLETE 				      sizeof (struct port_chain));
// OBSOLETE   new->next = list;
// OBSOLETE   new->port = name;
// OBSOLETE   new->type = type;
// OBSOLETE   new->mid = mid;
// OBSOLETE 
// OBSOLETE   return new;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE port_chain_t
// OBSOLETE port_chain_delete (port_chain_t list, mach_port_t elem)
// OBSOLETE {
// OBSOLETE   if (list)
// OBSOLETE     if (list->port == elem)
// OBSOLETE       list = list->next;
// OBSOLETE     else
// OBSOLETE       while (list->next)
// OBSOLETE 	{
// OBSOLETE 	  if (list->next->port == elem)
// OBSOLETE 	    list->next = list->next->next;	/* GCd with obstack_free() */
// OBSOLETE 	  else
// OBSOLETE 	    list = list->next;
// OBSOLETE 	}
// OBSOLETE   return list;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE port_chain_destroy (struct obstack *ostack)
// OBSOLETE {
// OBSOLETE   obstack_free (ostack, 0);
// OBSOLETE   obstack_init (ostack);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE port_chain_t
// OBSOLETE port_chain_member (port_chain_t list, mach_port_t elem)
// OBSOLETE {
// OBSOLETE   while (list)
// OBSOLETE     {
// OBSOLETE       if (list->port == elem)
// OBSOLETE 	return list;
// OBSOLETE       list = list->next;
// OBSOLETE     }
// OBSOLETE   return (port_chain_t) NULL;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE map_port_name_to_mid (mach_port_t name, int type)
// OBSOLETE {
// OBSOLETE   port_chain_t elem;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (name))
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   elem = port_chain_member (notify_chain, name);
// OBSOLETE 
// OBSOLETE   if (elem && (elem->type == type))
// OBSOLETE     return elem->mid;
// OBSOLETE 
// OBSOLETE   if (elem)
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (mid_server))
// OBSOLETE     {
// OBSOLETE       warning ("Machid server port invalid, can not map port 0x%x to mid",
// OBSOLETE 	       name);
// OBSOLETE       return -1;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       int mid;
// OBSOLETE       kern_return_t ret;
// OBSOLETE 
// OBSOLETE       ret = machid_mach_register (mid_server, mid_auth, name, type, &mid);
// OBSOLETE 
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	{
// OBSOLETE 	  warning ("Can not map name (0x%x) to mid with machid", name);
// OBSOLETE 	  return -1;
// OBSOLETE 	}
// OBSOLETE       return mid;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Guard for currently_waiting_for and singlestepped_thread_port */
// OBSOLETE static void
// OBSOLETE discard_single_step (thread_t thread)
// OBSOLETE {
// OBSOLETE   currently_waiting_for = inferior_wait_port_set;
// OBSOLETE 
// OBSOLETE   cleanup_step = NULL_CLEANUP;
// OBSOLETE   if (MACH_PORT_VALID (thread) && MACH_PORT_VALID (singlestepped_thread_port))
// OBSOLETE     setup_single_step (thread, FALSE);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE setup_single_step (thread_t thread, boolean_t start_step)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (thread))
// OBSOLETE     error ("Invalid thread supplied to setup_single_step");
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       mach_port_t teport;
// OBSOLETE 
// OBSOLETE       /* Get the current thread exception port */
// OBSOLETE       ret = thread_get_exception_port (thread, &teport);
// OBSOLETE       CHK ("Getting thread's exception port", ret);
// OBSOLETE 
// OBSOLETE       if (start_step)
// OBSOLETE 	{
// OBSOLETE 	  if (MACH_PORT_VALID (singlestepped_thread_port))
// OBSOLETE 	    {
// OBSOLETE 	      warning ("Singlestepped_thread_port (0x%x) is still valid?",
// OBSOLETE 		       singlestepped_thread_port);
// OBSOLETE 	      singlestepped_thread_port = MACH_PORT_NULL;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  /* If we are already stepping this thread */
// OBSOLETE 	  if (MACH_PORT_VALID (teport) && teport == thread_exception_port)
// OBSOLETE 	    {
// OBSOLETE 	      ret = mach_port_deallocate (mach_task_self (), teport);
// OBSOLETE 	      CHK ("Could not deallocate thread exception port", ret);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      ret = thread_set_exception_port (thread, thread_exception_port);
// OBSOLETE 	      CHK ("Setting exception port for thread", ret);
// OBSOLETE #if 0
// OBSOLETE 	      /* Insert thread exception port to wait port set */
// OBSOLETE 	      ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 					   thread_exception_port,
// OBSOLETE 					   inferior_wait_port_set);
// OBSOLETE 	      CHK ("Moving thread exception port to inferior_wait_port_set",
// OBSOLETE 		   ret);
// OBSOLETE #endif
// OBSOLETE 	      thread_saved_exception_port = teport;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  thread_trace (thread, TRUE);
// OBSOLETE 
// OBSOLETE 	  singlestepped_thread_port = thread_exception_port;
// OBSOLETE 	  currently_waiting_for = singlestepped_thread_port;
// OBSOLETE 	  cleanup_step = make_cleanup (discard_single_step, thread);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (!MACH_PORT_VALID (teport))
// OBSOLETE 	    error ("Single stepped thread had an invalid exception port?");
// OBSOLETE 
// OBSOLETE 	  if (teport != thread_exception_port)
// OBSOLETE 	    error ("Single stepped thread had an unknown exception port?");
// OBSOLETE 
// OBSOLETE 	  ret = mach_port_deallocate (mach_task_self (), teport);
// OBSOLETE 	  CHK ("Couldn't deallocate thread exception port", ret);
// OBSOLETE #if 0
// OBSOLETE 	  /* Remove thread exception port from wait port set */
// OBSOLETE 	  ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 				       thread_exception_port,
// OBSOLETE 				       MACH_PORT_NULL);
// OBSOLETE 	  CHK ("Removing thread exception port from inferior_wait_port_set",
// OBSOLETE 	       ret);
// OBSOLETE #endif
// OBSOLETE 	  /* Restore thread's old exception port */
// OBSOLETE 	  ret = thread_set_exception_port (thread,
// OBSOLETE 					   thread_saved_exception_port);
// OBSOLETE 	  CHK ("Restoring stepped thread's exception port", ret);
// OBSOLETE 
// OBSOLETE 	  if (MACH_PORT_VALID (thread_saved_exception_port))
// OBSOLETE 	    (void) mach_port_deallocate (mach_task_self (),
// OBSOLETE 					 thread_saved_exception_port);
// OBSOLETE 
// OBSOLETE 	  thread_trace (thread, FALSE);
// OBSOLETE 
// OBSOLETE 	  singlestepped_thread_port = MACH_PORT_NULL;
// OBSOLETE 	  currently_waiting_for = inferior_wait_port_set;
// OBSOLETE 	  if (cleanup_step)
// OBSOLETE 	    discard_cleanups (cleanup_step);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static
// OBSOLETE request_notify (mach_port_t name, mach_msg_id_t variant, int type)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   mach_port_t previous_port_dummy = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (name))
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   if (port_chain_member (notify_chain, name))
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   ret = mach_port_request_notification (mach_task_self (),
// OBSOLETE 					name,
// OBSOLETE 					variant,
// OBSOLETE 					1,
// OBSOLETE 					our_notify_port,
// OBSOLETE 					MACH_MSG_TYPE_MAKE_SEND_ONCE,
// OBSOLETE 					&previous_port_dummy);
// OBSOLETE   CHK ("Serious: request_notify failed", ret);
// OBSOLETE 
// OBSOLETE   (void) mach_port_deallocate (mach_task_self (),
// OBSOLETE 			       previous_port_dummy);
// OBSOLETE 
// OBSOLETE   notify_chain = port_chain_insert (notify_chain, name, type);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE reverse_msg_bits (mach_msg_header_t *msgp, int type)
// OBSOLETE {
// OBSOLETE   int rbits, lbits;
// OBSOLETE   rbits = MACH_MSGH_BITS_REMOTE (msgp->msgh_bits);
// OBSOLETE   lbits = type;
// OBSOLETE   msgp->msgh_bits =
// OBSOLETE     (msgp->msgh_bits & ~MACH_MSGH_BITS_PORTS_MASK) |
// OBSOLETE     MACH_MSGH_BITS (lbits, rbits);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* On the third day He said:
// OBSOLETE 
// OBSOLETE    Let this be global
// OBSOLETE    and then it was global.
// OBSOLETE 
// OBSOLETE    When creating the inferior fork, the
// OBSOLETE    child code in inflow.c sets the name of the
// OBSOLETE    bootstrap_port in its address space to this
// OBSOLETE    variable.
// OBSOLETE 
// OBSOLETE    The name is transferred to our address space
// OBSOLETE    with mach3_read_inferior().
// OBSOLETE 
// OBSOLETE    Thou shalt not do this with
// OBSOLETE    task_get_bootstrap_port() in this task, since
// OBSOLETE    the name in the inferior task is different than
// OBSOLETE    the one we get.
// OBSOLETE 
// OBSOLETE    For blessed are the meek, as they shall inherit
// OBSOLETE    the address space.
// OBSOLETE  */
// OBSOLETE mach_port_t original_server_port_name = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Called from inferior after FORK but before EXEC */
// OBSOLETE static void
// OBSOLETE m3_trace_me (void)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   /* Get the NAME of the bootstrap port in this task
// OBSOLETE      so that GDB can read it */
// OBSOLETE   ret = task_get_bootstrap_port (mach_task_self (),
// OBSOLETE 				 &original_server_port_name);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE   ret = mach_port_deallocate (mach_task_self (),
// OBSOLETE 			      original_server_port_name);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE 
// OBSOLETE   /* Suspend this task to let the parent change my ports.
// OBSOLETE      Resumed by the debugger */
// OBSOLETE   ret = task_suspend (mach_task_self ());
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Intercept system calls to Unix server.
// OBSOLETE  * After EXEC_COUNTER calls to exec(), return.
// OBSOLETE  *
// OBSOLETE  * Pre-assertion:  Child is suspended. (Not verified)
// OBSOLETE  * Post-condition: Child is suspended after EXEC_COUNTER exec() calls.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE intercept_exec_calls (int exec_counter)
// OBSOLETE {
// OBSOLETE   int terminal_initted = 0;
// OBSOLETE 
// OBSOLETE   struct syscall_msg_t
// OBSOLETE     {
// OBSOLETE       mach_msg_header_t header;
// OBSOLETE       mach_msg_type_t type;
// OBSOLETE       char room[2000];		/* Enuff space */
// OBSOLETE     };
// OBSOLETE 
// OBSOLETE   struct syscall_msg_t syscall_in, syscall_out;
// OBSOLETE 
// OBSOLETE   mach_port_t fake_server;
// OBSOLETE   mach_port_t original_server_send;
// OBSOLETE   mach_port_t original_exec_reply;
// OBSOLETE   mach_port_t exec_reply;
// OBSOLETE   mach_port_t exec_reply_send;
// OBSOLETE   mach_msg_type_name_t acquired;
// OBSOLETE   mach_port_t emulator_server_port_name;
// OBSOLETE   struct task_basic_info info;
// OBSOLETE   mach_msg_type_number_t info_count;
// OBSOLETE 
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (exec_counter <= 0)
// OBSOLETE     return;			/* We are already set up in the correct program */
// OBSOLETE 
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    &fake_server);
// OBSOLETE   CHK ("create inferior_fake_server port failed", ret);
// OBSOLETE 
// OBSOLETE   /* Wait for inferior_task to suspend itself */
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       info_count = sizeof (info);
// OBSOLETE       ret = task_info (inferior_task,
// OBSOLETE 		       TASK_BASIC_INFO,
// OBSOLETE 		       (task_info_t) & info,
// OBSOLETE 		       &info_count);
// OBSOLETE       CHK ("Task info", ret);
// OBSOLETE 
// OBSOLETE       if (info.suspend_count)
// OBSOLETE 	break;
// OBSOLETE 
// OBSOLETE       /* Note that the definition of the parameter was undefined
// OBSOLETE        * at the time of this writing, so I just use an `ad hoc' value.
// OBSOLETE        */
// OBSOLETE       (void) swtch_pri (42);	/* Universal Priority Value */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Read the inferior's bootstrap port name */
// OBSOLETE   if (!mach3_read_inferior (&original_server_port_name,
// OBSOLETE 			    &original_server_port_name,
// OBSOLETE 			    sizeof (original_server_port_name)))
// OBSOLETE     error ("Can't read inferior task bootstrap port name");
// OBSOLETE 
// OBSOLETE   /* @@@@ BUG: If more than 1 send right GDB will FAIL!!! */
// OBSOLETE   /*      Should get refs, and set them back when restoring */
// OBSOLETE   /* Steal the original bsd server send right from inferior */
// OBSOLETE   ret = mach_port_extract_right (inferior_task,
// OBSOLETE 				 original_server_port_name,
// OBSOLETE 				 MACH_MSG_TYPE_MOVE_SEND,
// OBSOLETE 				 &original_server_send,
// OBSOLETE 				 &acquired);
// OBSOLETE   CHK ("mach_port_extract_right (bsd server send)", ret);
// OBSOLETE 
// OBSOLETE   if (acquired != MACH_MSG_TYPE_PORT_SEND)
// OBSOLETE     error ("Incorrect right extracted, send right to bsd server expected");
// OBSOLETE 
// OBSOLETE   ret = mach_port_insert_right (inferior_task,
// OBSOLETE 				original_server_port_name,
// OBSOLETE 				fake_server,
// OBSOLETE 				MACH_MSG_TYPE_MAKE_SEND);
// OBSOLETE   CHK ("mach_port_insert_right (fake server send)", ret);
// OBSOLETE 
// OBSOLETE   xx_debug ("inferior task bsd server ports set up \nfs %x, ospn %x, oss %x\n",
// OBSOLETE 	    fake_server,
// OBSOLETE 	    original_server_port_name, original_server_send);
// OBSOLETE 
// OBSOLETE   /* A receive right to the reply generated by unix server exec() request */
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    &exec_reply);
// OBSOLETE   CHK ("create intercepted_reply_port port failed", ret);
// OBSOLETE 
// OBSOLETE   /* Pass this send right to Unix server so it replies to us after exec() */
// OBSOLETE   ret = mach_port_extract_right (mach_task_self (),
// OBSOLETE 				 exec_reply,
// OBSOLETE 				 MACH_MSG_TYPE_MAKE_SEND_ONCE,
// OBSOLETE 				 &exec_reply_send,
// OBSOLETE 				 &acquired);
// OBSOLETE   CHK ("mach_port_extract_right (exec_reply)", ret);
// OBSOLETE 
// OBSOLETE   if (acquired != MACH_MSG_TYPE_PORT_SEND_ONCE)
// OBSOLETE     error ("Incorrect right extracted, send once expected for exec reply");
// OBSOLETE 
// OBSOLETE   ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 			       fake_server,
// OBSOLETE 			       inferior_wait_port_set);
// OBSOLETE   CHK ("Moving fake syscall port to inferior_wait_port_set", ret);
// OBSOLETE 
// OBSOLETE   xx_debug ("syscall fake server set up, resuming inferior\n");
// OBSOLETE 
// OBSOLETE   ret = task_resume (inferior_task);
// OBSOLETE   CHK ("task_resume (startup)", ret);
// OBSOLETE 
// OBSOLETE   /* Read requests from the inferior.
// OBSOLETE      Pass directly through everything else except exec() calls.
// OBSOLETE    */
// OBSOLETE   while (exec_counter > 0)
// OBSOLETE     {
// OBSOLETE       ret = mach_msg (&syscall_in.header,	/* header */
// OBSOLETE 		      MACH_RCV_MSG,	/* options */
// OBSOLETE 		      0,	/* send size */
// OBSOLETE 		      sizeof (struct syscall_msg_t),	/* receive size */
// OBSOLETE 		      inferior_wait_port_set,	/* receive_name */
// OBSOLETE 		      MACH_MSG_TIMEOUT_NONE,
// OBSOLETE 		      MACH_PORT_NULL);
// OBSOLETE       CHK ("mach_msg (intercepted sycall)", ret);
// OBSOLETE 
// OBSOLETE #ifdef DUMP_SYSCALL
// OBSOLETE       print_msg (&syscall_in.header);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE       /* ASSERT : msgh_local_port == fake_server */
// OBSOLETE 
// OBSOLETE       if (notify_server (&syscall_in.header, &syscall_out.header))
// OBSOLETE 	error ("received a notify while intercepting syscalls");
// OBSOLETE 
// OBSOLETE       if (syscall_in.header.msgh_id == MIG_EXEC_SYSCALL_ID)
// OBSOLETE 	{
// OBSOLETE 	  xx_debug ("Received EXEC SYSCALL, counter = %d\n", exec_counter);
// OBSOLETE 	  if (exec_counter == 1)
// OBSOLETE 	    {
// OBSOLETE 	      original_exec_reply = syscall_in.header.msgh_remote_port;
// OBSOLETE 	      syscall_in.header.msgh_remote_port = exec_reply_send;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  if (!terminal_initted)
// OBSOLETE 	    {
// OBSOLETE 	      /* Now that the child has exec'd we know it has already set its
// OBSOLETE 	         process group.  On POSIX systems, tcsetpgrp will fail with
// OBSOLETE 	         EPERM if we try it before the child's setpgid.  */
// OBSOLETE 
// OBSOLETE 	      /* Set up the "saved terminal modes" of the inferior
// OBSOLETE 	         based on what modes we are starting it with.  */
// OBSOLETE 	      target_terminal_init ();
// OBSOLETE 
// OBSOLETE 	      /* Install inferior's terminal modes.  */
// OBSOLETE 	      target_terminal_inferior ();
// OBSOLETE 
// OBSOLETE 	      terminal_initted = 1;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  exec_counter--;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       syscall_in.header.msgh_local_port = syscall_in.header.msgh_remote_port;
// OBSOLETE       syscall_in.header.msgh_remote_port = original_server_send;
// OBSOLETE 
// OBSOLETE       reverse_msg_bits (&syscall_in.header, MACH_MSG_TYPE_COPY_SEND);
// OBSOLETE 
// OBSOLETE       ret = mach_msg_send (&syscall_in.header);
// OBSOLETE       CHK ("Forwarded syscall", ret);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 			       fake_server,
// OBSOLETE 			       MACH_PORT_NULL);
// OBSOLETE   CHK ("Moving fake syscall out of inferior_wait_port_set", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 			       exec_reply,
// OBSOLETE 			       inferior_wait_port_set);
// OBSOLETE   CHK ("Moving exec_reply to inferior_wait_port_set", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_msg (&syscall_in.header,	/* header */
// OBSOLETE 		  MACH_RCV_MSG,	/* options */
// OBSOLETE 		  0,		/* send size */
// OBSOLETE 		  sizeof (struct syscall_msg_t),	/* receive size */
// OBSOLETE 		  inferior_wait_port_set,	/* receive_name */
// OBSOLETE 		  MACH_MSG_TIMEOUT_NONE,
// OBSOLETE 		  MACH_PORT_NULL);
// OBSOLETE   CHK ("mach_msg (exec reply)", ret);
// OBSOLETE 
// OBSOLETE   ret = task_suspend (inferior_task);
// OBSOLETE   CHK ("Suspending inferior after last exec", ret);
// OBSOLETE 
// OBSOLETE   must_suspend_thread = 0;
// OBSOLETE 
// OBSOLETE   xx_debug ("Received exec reply from bsd server, suspended inferior task\n");
// OBSOLETE 
// OBSOLETE #ifdef DUMP_SYSCALL
// OBSOLETE   print_msg (&syscall_in.header);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   /* Message should appear as if it came from the unix server */
// OBSOLETE   syscall_in.header.msgh_local_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE   /*  and go to the inferior task original reply port */
// OBSOLETE   syscall_in.header.msgh_remote_port = original_exec_reply;
// OBSOLETE 
// OBSOLETE   reverse_msg_bits (&syscall_in.header, MACH_MSG_TYPE_MOVE_SEND_ONCE);
// OBSOLETE 
// OBSOLETE   ret = mach_msg_send (&syscall_in.header);
// OBSOLETE   CHK ("Forwarding exec reply to inferior", ret);
// OBSOLETE 
// OBSOLETE   /* Garbage collect */
// OBSOLETE   ret = mach_port_deallocate (inferior_task,
// OBSOLETE 			      original_server_port_name);
// OBSOLETE   CHK ("deallocating fake server send right", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_insert_right (inferior_task,
// OBSOLETE 				original_server_port_name,
// OBSOLETE 				original_server_send,
// OBSOLETE 				MACH_MSG_TYPE_MOVE_SEND);
// OBSOLETE   CHK ("Restoring the original bsd server send right", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_destroy (mach_task_self (),
// OBSOLETE 			   fake_server);
// OBSOLETE   fake_server = MACH_PORT_DEAD;
// OBSOLETE   CHK ("mach_port_destroy (fake_server)", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_destroy (mach_task_self (),
// OBSOLETE 			   exec_reply);
// OBSOLETE   exec_reply = MACH_PORT_DEAD;
// OBSOLETE   CHK ("mach_port_destroy (exec_reply)", ret);
// OBSOLETE 
// OBSOLETE   xx_debug ("Done with exec call interception\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE consume_send_rights (thread_array_t thread_list, int thread_count)
// OBSOLETE {
// OBSOLETE   int index;
// OBSOLETE 
// OBSOLETE   if (!thread_count)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   for (index = 0; index < thread_count; index++)
// OBSOLETE     {
// OBSOLETE       /* Since thread kill command kills threads, don't check ret */
// OBSOLETE       (void) mach_port_deallocate (mach_task_self (),
// OBSOLETE 				   thread_list[index]);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* suspend/abort/resume a thread. */
// OBSOLETE setup_thread (mach_port_t thread, int what)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (what)
// OBSOLETE     {
// OBSOLETE       ret = thread_suspend (thread);
// OBSOLETE       CHK ("setup_thread thread_suspend", ret);
// OBSOLETE 
// OBSOLETE       ret = thread_abort (thread);
// OBSOLETE       CHK ("setup_thread thread_abort", ret);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       ret = thread_resume (thread);
// OBSOLETE       CHK ("setup_thread thread_resume", ret);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE map_slot_to_mid (int slot, thread_array_t threads, int thread_count)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int deallocate = 0;
// OBSOLETE   int index;
// OBSOLETE   int mid;
// OBSOLETE 
// OBSOLETE   if (!threads)
// OBSOLETE     {
// OBSOLETE       deallocate++;
// OBSOLETE       ret = task_threads (inferior_task, &threads, &thread_count);
// OBSOLETE       CHK ("Can not select a thread from a dead task", ret);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (slot < 0 || slot >= thread_count)
// OBSOLETE     {
// OBSOLETE       if (deallocate)
// OBSOLETE 	{
// OBSOLETE 	  consume_send_rights (threads, thread_count);
// OBSOLETE 	  (void) vm_deallocate (mach_task_self (), (vm_address_t) threads,
// OBSOLETE 				(thread_count * sizeof (mach_port_t)));
// OBSOLETE 	}
// OBSOLETE       if (slot < 0)
// OBSOLETE 	error ("invalid slot number");
// OBSOLETE       else
// OBSOLETE 	return -(slot + 1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   mid = map_port_name_to_mid (threads[slot], MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE   if (deallocate)
// OBSOLETE     {
// OBSOLETE       consume_send_rights (threads, thread_count);
// OBSOLETE       (void) vm_deallocate (mach_task_self (), (vm_address_t) threads,
// OBSOLETE 			    (thread_count * sizeof (mach_port_t)));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return mid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE parse_thread_id (char *arg, int thread_count, int slots)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int mid;
// OBSOLETE   int slot;
// OBSOLETE   int index;
// OBSOLETE 
// OBSOLETE   if (arg == 0)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   while (*arg && (*arg == ' ' || *arg == '\t'))
// OBSOLETE     arg++;
// OBSOLETE 
// OBSOLETE   if (!*arg)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   /* Currently parse MID and @@SLOTNUMBER */
// OBSOLETE   if (*arg != '@@')
// OBSOLETE     {
// OBSOLETE       mid = atoi (arg);
// OBSOLETE       if (mid <= 0)
// OBSOLETE 	error ("valid thread mid expected");
// OBSOLETE       return mid;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   arg++;
// OBSOLETE   slot = atoi (arg);
// OBSOLETE 
// OBSOLETE   if (slot < 0)
// OBSOLETE     error ("invalid slot number");
// OBSOLETE 
// OBSOLETE   /* If you want slot numbers to remain slot numbers, set slots.
// OBSOLETE 
// OBSOLETE    * Well, since 0 is reserved, return the ordinal number
// OBSOLETE    * of the thread rather than the slot number. Awk, this
// OBSOLETE    * counts as a kludge.
// OBSOLETE    */
// OBSOLETE   if (slots)
// OBSOLETE     return -(slot + 1);
// OBSOLETE 
// OBSOLETE   if (thread_count && slot >= thread_count)
// OBSOLETE     return -(slot + 1);
// OBSOLETE 
// OBSOLETE   mid = map_slot_to_mid (slot);
// OBSOLETE 
// OBSOLETE   return mid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* THREAD_ID 0 is special; it selects the first kernel
// OBSOLETE  * thread from the list (i.e. SLOTNUMBER 0)
// OBSOLETE  * This is used when starting the program with 'run' or when attaching.
// OBSOLETE  *
// OBSOLETE  * If FLAG is 0 the context is not changed, and the registers, frame, etc
// OBSOLETE  * will continue to describe the old thread.
// OBSOLETE  *
// OBSOLETE  * If FLAG is nonzero, really select the thread.
// OBSOLETE  * If FLAG is 2, the THREAD_ID is a slotnumber instead of a mid.
// OBSOLETE  * 
// OBSOLETE  */
// OBSOLETE kern_return_t
// OBSOLETE select_thread (mach_port_t task, int thread_id, int flag)
// OBSOLETE {
// OBSOLETE   thread_array_t thread_list;
// OBSOLETE   int thread_count;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int index;
// OBSOLETE   thread_t new_thread = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE   if (thread_id < 0)
// OBSOLETE     error ("Can't select cprocs without kernel thread");
// OBSOLETE 
// OBSOLETE   ret = task_threads (task, &thread_list, &thread_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("Can not select a thread from a dead task");
// OBSOLETE       m3_kill_inferior ();
// OBSOLETE       return KERN_FAILURE;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (thread_count == 0)
// OBSOLETE     {
// OBSOLETE       /* The task can not do anything anymore, but it still
// OBSOLETE        * exists as a container for memory and ports.
// OBSOLETE        */
// OBSOLETE       registers_changed ();
// OBSOLETE       warning ("Task %d has no threads",
// OBSOLETE 	       map_port_name_to_mid (task, MACH_TYPE_TASK));
// OBSOLETE       current_thread = MACH_PORT_NULL;
// OBSOLETE       (void) vm_deallocate (mach_task_self (),
// OBSOLETE 			    (vm_address_t) thread_list,
// OBSOLETE 			    (thread_count * sizeof (mach_port_t)));
// OBSOLETE       return KERN_FAILURE;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!thread_id || flag == 2)
// OBSOLETE     {
// OBSOLETE       /* First thread or a slotnumber */
// OBSOLETE       if (!thread_id)
// OBSOLETE 	new_thread = thread_list[0];
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (thread_id < thread_count)
// OBSOLETE 	    new_thread = thread_list[thread_id];
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      (void) vm_deallocate (mach_task_self (),
// OBSOLETE 				    (vm_address_t) thread_list,
// OBSOLETE 				    (thread_count * sizeof (mach_port_t)));
// OBSOLETE 	      error ("No such thread slot number : %d", thread_id);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       for (index = 0; index < thread_count; index++)
// OBSOLETE 	if (thread_id == map_port_name_to_mid (thread_list[index],
// OBSOLETE 					       MACH_TYPE_THREAD))
// OBSOLETE 	  {
// OBSOLETE 	    new_thread = thread_list[index];
// OBSOLETE 	    index = -1;
// OBSOLETE 	    break;
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE       if (index != -1)
// OBSOLETE 	error ("No thread with mid %d", thread_id);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Notify when the selected thread dies */
// OBSOLETE   request_notify (new_thread, MACH_NOTIFY_DEAD_NAME, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE   ret = vm_deallocate (mach_task_self (),
// OBSOLETE 		       (vm_address_t) thread_list,
// OBSOLETE 		       (thread_count * sizeof (mach_port_t)));
// OBSOLETE   CHK ("vm_deallocate", ret);
// OBSOLETE 
// OBSOLETE   if (!flag)
// OBSOLETE     current_thread = new_thread;
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE #if 0
// OBSOLETE       if (MACH_PORT_VALID (current_thread))
// OBSOLETE 	{
// OBSOLETE 	  /* Store the gdb's view of the thread we are deselecting
// OBSOLETE 
// OBSOLETE 	   * @@@@ I think gdb updates registers immediately when they are
// OBSOLETE 	   * changed, so don't do this.
// OBSOLETE 	   */
// OBSOLETE 	  ret = thread_abort (current_thread);
// OBSOLETE 	  CHK ("Could not abort system calls when saving state of old thread",
// OBSOLETE 	       ret);
// OBSOLETE 	  target_prepare_to_store ();
// OBSOLETE 	  target_store_registers (-1);
// OBSOLETE 	}
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE       registers_changed ();
// OBSOLETE 
// OBSOLETE       current_thread = new_thread;
// OBSOLETE 
// OBSOLETE       ret = thread_abort (current_thread);
// OBSOLETE       CHK ("Could not abort system calls when selecting a thread", ret);
// OBSOLETE 
// OBSOLETE       stop_pc = read_pc ();
// OBSOLETE       flush_cached_frames ();
// OBSOLETE 
// OBSOLETE       select_frame (get_current_frame ());
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Switch to use thread named NEW_THREAD.
// OBSOLETE  * Return it's MID
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE switch_to_thread (thread_t new_thread)
// OBSOLETE {
// OBSOLETE   thread_t saved_thread = current_thread;
// OBSOLETE   int mid;
// OBSOLETE 
// OBSOLETE   mid = map_port_name_to_mid (new_thread,
// OBSOLETE 			      MACH_TYPE_THREAD);
// OBSOLETE   if (mid == -1)
// OBSOLETE     warning ("Can't map thread name 0x%x to mid", new_thread);
// OBSOLETE   else if (select_thread (inferior_task, mid, 1) != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       if (current_thread)
// OBSOLETE 	current_thread = saved_thread;
// OBSOLETE       error ("Could not select thread %d", mid);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return mid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Do this in gdb after doing FORK but before STARTUP_INFERIOR.
// OBSOLETE  * Note that the registers are not yet valid in the inferior task.
// OBSOLETE  */
// OBSOLETE static int
// OBSOLETE m3_trace_him (int pid)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   push_target (&m3_ops);
// OBSOLETE 
// OBSOLETE   inferior_task = task_by_pid (pid);
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (inferior_task))
// OBSOLETE     error ("Can not map Unix pid %d to Mach task", pid);
// OBSOLETE 
// OBSOLETE   /* Clean up previous notifications and create new ones */
// OBSOLETE   setup_notify_port (1);
// OBSOLETE 
// OBSOLETE   /* When notification appears, the inferior task has died */
// OBSOLETE   request_notify (inferior_task, MACH_NOTIFY_DEAD_NAME, MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   emulator_present = have_emulator_p (inferior_task);
// OBSOLETE 
// OBSOLETE   /* By default, select the first thread,
// OBSOLETE    * If task has no threads, gives a warning
// OBSOLETE    * Does not fetch registers, since they are not yet valid.
// OBSOLETE    */
// OBSOLETE   select_thread (inferior_task, 0, 0);
// OBSOLETE 
// OBSOLETE   inferior_exception_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE   setup_exception_port ();
// OBSOLETE 
// OBSOLETE   xx_debug ("Now the debugged task is created\n");
// OBSOLETE 
// OBSOLETE   /* One trap to exec the shell, one to exec the program being debugged.  */
// OBSOLETE   intercept_exec_calls (2);
// OBSOLETE 
// OBSOLETE   return pid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE setup_exception_port (void)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    &inferior_exception_port);
// OBSOLETE   CHK ("mach_port_allocate", ret);
// OBSOLETE 
// OBSOLETE   /* add send right */
// OBSOLETE   ret = mach_port_insert_right (mach_task_self (),
// OBSOLETE 				inferior_exception_port,
// OBSOLETE 				inferior_exception_port,
// OBSOLETE 				MACH_MSG_TYPE_MAKE_SEND);
// OBSOLETE   CHK ("mach_port_insert_right", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 			       inferior_exception_port,
// OBSOLETE 			       inferior_wait_port_set);
// OBSOLETE   CHK ("mach_port_move_member", ret);
// OBSOLETE 
// OBSOLETE   ret = task_get_special_port (inferior_task,
// OBSOLETE 			       TASK_EXCEPTION_PORT,
// OBSOLETE 			       &inferior_old_exception_port);
// OBSOLETE   CHK ("task_get_special_port(old exc)", ret);
// OBSOLETE 
// OBSOLETE   ret = task_set_special_port (inferior_task,
// OBSOLETE 			       TASK_EXCEPTION_PORT,
// OBSOLETE 			       inferior_exception_port);
// OBSOLETE   CHK ("task_set_special_port", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_deallocate (mach_task_self (),
// OBSOLETE 			      inferior_exception_port);
// OBSOLETE   CHK ("mack_port_deallocate", ret);
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE   /* When notify appears, the inferior_task's exception
// OBSOLETE    * port has been destroyed.
// OBSOLETE    *
// OBSOLETE    * Not used, since the dead_name_notification already
// OBSOLETE    * appears when task dies.
// OBSOLETE    *
// OBSOLETE    */
// OBSOLETE   request_notify (inferior_exception_port,
// OBSOLETE 		  MACH_NOTIFY_NO_SENDERS,
// OBSOLETE 		  MACH_TYPE_EXCEPTION_PORT);
// OBSOLETE #endif
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Nonzero if gdb is waiting for a message */
// OBSOLETE int mach_really_waiting;
// OBSOLETE 
// OBSOLETE /* Wait for the inferior to stop for some reason.
// OBSOLETE    - Loop on notifications until inferior_task dies.
// OBSOLETE    - Loop on exceptions until stopped_in_exception comes true.
// OBSOLETE    (e.g. we receive a single step trace trap)
// OBSOLETE    - a message arrives to gdb's message port
// OBSOLETE 
// OBSOLETE    There is no other way to exit this loop.
// OBSOLETE 
// OBSOLETE    Returns the inferior_ptid for rest of gdb.
// OBSOLETE    Side effects: Set *OURSTATUS.  */
// OBSOLETE ptid_t
// OBSOLETE mach_really_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int w;
// OBSOLETE 
// OBSOLETE   struct msg
// OBSOLETE     {
// OBSOLETE       mach_msg_header_t header;
// OBSOLETE       mach_msg_type_t foo;
// OBSOLETE       int data[8000];
// OBSOLETE     }
// OBSOLETE   in_msg, out_msg;
// OBSOLETE 
// OBSOLETE   /* Either notify (death), exception or message can stop the inferior */
// OBSOLETE   stopped_in_exception = FALSE;
// OBSOLETE 
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       QUIT;
// OBSOLETE 
// OBSOLETE       stop_exception = stop_code = stop_subcode = -1;
// OBSOLETE       stop_thread = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE       mach_really_waiting = 1;
// OBSOLETE       ret = mach_msg (&in_msg.header,	/* header */
// OBSOLETE 		      MACH_RCV_MSG,	/* options */
// OBSOLETE 		      0,	/* send size */
// OBSOLETE 		      sizeof (struct msg),	/* receive size */
// OBSOLETE 		      currently_waiting_for,	/* receive name */
// OBSOLETE 		      MACH_MSG_TIMEOUT_NONE,
// OBSOLETE 		      MACH_PORT_NULL);
// OBSOLETE       mach_really_waiting = 0;
// OBSOLETE       CHK ("mach_msg (receive)", ret);
// OBSOLETE 
// OBSOLETE       /* Check if we received a notify of the childs' death */
// OBSOLETE       if (notify_server (&in_msg.header, &out_msg.header))
// OBSOLETE 	{
// OBSOLETE 	  /* If inferior_task is null then the inferior has
// OBSOLETE 	     gone away and we want to return to command level.
// OBSOLETE 	     Otherwise it was just an informative message and we
// OBSOLETE 	     need to look to see if there are any more. */
// OBSOLETE 	  if (inferior_task != MACH_PORT_NULL)
// OBSOLETE 	    continue;
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      /* Collect Unix exit status for gdb */
// OBSOLETE 
// OBSOLETE 	      wait3 (&w, WNOHANG, 0);
// OBSOLETE 
// OBSOLETE 	      /* This mess is here to check that the rest of
// OBSOLETE 	       * gdb knows that the inferior died. It also
// OBSOLETE 	       * tries to hack around the fact that Mach 3.0 (mk69)
// OBSOLETE 	       * unix server (ux28) does not always know what
// OBSOLETE 	       * has happened to it's children when mach-magic
// OBSOLETE 	       * is applied on them.
// OBSOLETE 	       */
// OBSOLETE 	      if ((!WIFEXITED (w) && WIFSTOPPED (w)) ||
// OBSOLETE 		  (WIFEXITED (w) && WEXITSTATUS (w) > 0377))
// OBSOLETE 		{
// OBSOLETE 		  WSETEXIT (w, 0);
// OBSOLETE 		  warning ("Using exit value 0 for terminated task");
// OBSOLETE 		}
// OBSOLETE 	      else if (!WIFEXITED (w))
// OBSOLETE 		{
// OBSOLETE 		  int sig = WTERMSIG (w);
// OBSOLETE 
// OBSOLETE 		  /* Signals cause problems. Warn the user. */
// OBSOLETE 		  if (sig != SIGKILL)	/* Bad luck if garbage matches this */
// OBSOLETE 		    warning ("The terminating signal stuff may be nonsense");
// OBSOLETE 		  else if (sig > NSIG)
// OBSOLETE 		    {
// OBSOLETE 		      WSETEXIT (w, 0);
// OBSOLETE 		      warning ("Using exit value 0 for terminated task");
// OBSOLETE 		    }
// OBSOLETE 		}
// OBSOLETE 	      store_waitstatus (ourstatus, w);
// OBSOLETE 	      return inferior_ptid;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Hmm. Check for exception, as it was not a notification.
// OBSOLETE          exc_server() does an upcall to catch_exception_raise()
// OBSOLETE          if this rpc is an exception. Further actions are decided
// OBSOLETE          there.
// OBSOLETE        */
// OBSOLETE       if (!exc_server (&in_msg.header, &out_msg.header))
// OBSOLETE 	{
// OBSOLETE 
// OBSOLETE 	  /* Not an exception, check for message.
// OBSOLETE 
// OBSOLETE 	   * Messages don't come from the inferior, or if they
// OBSOLETE 	   * do they better be asynchronous or it will hang.
// OBSOLETE 	   */
// OBSOLETE 	  if (gdb_message_server (&in_msg.header))
// OBSOLETE 	    continue;
// OBSOLETE 
// OBSOLETE 	  error ("Unrecognized message received in mach_really_wait");
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Send the reply of the exception rpc to the suspended task */
// OBSOLETE       ret = mach_msg_send (&out_msg.header);
// OBSOLETE       CHK ("mach_msg_send (exc reply)", ret);
// OBSOLETE 
// OBSOLETE       if (stopped_in_exception)
// OBSOLETE 	{
// OBSOLETE 	  /* Get unix state. May be changed in mach3_exception_actions() */
// OBSOLETE 	  wait3 (&w, WNOHANG, 0);
// OBSOLETE 
// OBSOLETE 	  mach3_exception_actions (&w, FALSE, "Task");
// OBSOLETE 
// OBSOLETE 	  store_waitstatus (ourstatus, w);
// OBSOLETE 	  return inferior_ptid;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Called by macro DO_QUIT() in utils.c(quit).
// OBSOLETE  * This is called just before calling error() to return to command level
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE mach3_quit (void)
// OBSOLETE {
// OBSOLETE   int mid;
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (mach_really_waiting)
// OBSOLETE     {
// OBSOLETE       ret = task_suspend (inferior_task);
// OBSOLETE 
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	{
// OBSOLETE 	  warning ("Could not suspend task for interrupt: %s",
// OBSOLETE 		   mach_error_string (ret));
// OBSOLETE 	  mach_really_waiting = 0;
// OBSOLETE 	  return;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   must_suspend_thread = 0;
// OBSOLETE   mach_really_waiting = 0;
// OBSOLETE 
// OBSOLETE   mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
// OBSOLETE   if (mid == -1)
// OBSOLETE     {
// OBSOLETE       warning ("Selecting first existing kernel thread");
// OBSOLETE       mid = 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   current_thread = MACH_PORT_NULL;	/* Force setup */
// OBSOLETE   select_thread (inferior_task, mid, 1);
// OBSOLETE 
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE /* bogus bogus bogus.  It is NOT OK to quit out of target_wait.  */
// OBSOLETE 
// OBSOLETE /* If ^C is typed when we are waiting for a message
// OBSOLETE  * and your Unix server is able to notice that we 
// OBSOLETE  * should quit now.
// OBSOLETE  *
// OBSOLETE  * Called by REQUEST_QUIT() from utils.c(request_quit)
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE mach3_request_quit (void)
// OBSOLETE {
// OBSOLETE   if (mach_really_waiting)
// OBSOLETE     immediate_quit = 1;
// OBSOLETE }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Gdb message server.
// OBSOLETE  * Currently implemented is the STOP message, that causes
// OBSOLETE  * gdb to return to the command level like ^C had been typed from terminal.
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE gdb_message_server (mach_msg_header_t *InP)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int mid;
// OBSOLETE 
// OBSOLETE   if (InP->msgh_local_port == our_message_port)
// OBSOLETE     {
// OBSOLETE       /* A message coming to our_message_port. Check validity */
// OBSOLETE       switch (InP->msgh_id)
// OBSOLETE 	{
// OBSOLETE 
// OBSOLETE 	case GDB_MESSAGE_ID_STOP:
// OBSOLETE 	  ret = task_suspend (inferior_task);
// OBSOLETE 	  if (ret != KERN_SUCCESS)
// OBSOLETE 	    warning ("Could not suspend task for stop message: %s",
// OBSOLETE 		     mach_error_string (ret));
// OBSOLETE 
// OBSOLETE 	  /* QUIT in mach_really_wait() loop. */
// OBSOLETE 	  request_quit (0);
// OBSOLETE 	  break;
// OBSOLETE 
// OBSOLETE 	default:
// OBSOLETE 	  warning ("Invalid message id %d received, ignored.",
// OBSOLETE 		   InP->msgh_id);
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Message not handled by this server */
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* NOTE: This is not an RPC call. It is a simpleroutine.
// OBSOLETE 
// OBSOLETE  * This is not called from this gdb code.
// OBSOLETE  *
// OBSOLETE  * It may be called by another debugger to cause this
// OBSOLETE  * debugger to enter command level:
// OBSOLETE  *
// OBSOLETE  *            (gdb) set stop_inferior_gdb ()
// OBSOLETE  *            (gdb) continue
// OBSOLETE  *
// OBSOLETE  * External program "stop-gdb" implements this also.
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE stop_inferior_gdb (void)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   /* Code generated by mig, with minor cleanups :-)
// OBSOLETE 
// OBSOLETE    * simpleroutine stop_inferior_gdb (our_message_port : mach_port_t);
// OBSOLETE    */
// OBSOLETE 
// OBSOLETE   typedef struct
// OBSOLETE     {
// OBSOLETE       mach_msg_header_t Head;
// OBSOLETE     }
// OBSOLETE   Request;
// OBSOLETE 
// OBSOLETE   Request Mess;
// OBSOLETE 
// OBSOLETE   register Request *InP = &Mess;
// OBSOLETE 
// OBSOLETE   InP->Head.msgh_bits = MACH_MSGH_BITS (MACH_MSG_TYPE_COPY_SEND, 0);
// OBSOLETE 
// OBSOLETE   /* msgh_size passed as argument */
// OBSOLETE   InP->Head.msgh_remote_port = our_message_port;
// OBSOLETE   InP->Head.msgh_local_port = MACH_PORT_NULL;
// OBSOLETE   InP->Head.msgh_seqno = 0;
// OBSOLETE   InP->Head.msgh_id = GDB_MESSAGE_ID_STOP;
// OBSOLETE 
// OBSOLETE   ret = mach_msg (&InP->Head,
// OBSOLETE 		  MACH_SEND_MSG | MACH_MSG_OPTION_NONE,
// OBSOLETE 		  sizeof (Request),
// OBSOLETE 		  0,
// OBSOLETE 		  MACH_PORT_NULL,
// OBSOLETE 		  MACH_MSG_TIMEOUT_NONE,
// OBSOLETE 		  MACH_PORT_NULL);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef THREAD_ALLOWED_TO_BREAK
// OBSOLETE /*
// OBSOLETE  * Return 1 if the MID specifies the thread that caused the
// OBSOLETE  * last exception.
// OBSOLETE  *  Since catch_exception_raise() selects the thread causing
// OBSOLETE  * the last exception to current_thread, we just check that
// OBSOLETE  * it is selected and the last exception was a breakpoint.
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE mach_thread_for_breakpoint (int mid)
// OBSOLETE {
// OBSOLETE   int cmid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE   if (mid < 0)
// OBSOLETE     {
// OBSOLETE       mid = map_slot_to_mid (-(mid + 1), 0, 0);
// OBSOLETE       if (mid < 0)
// OBSOLETE 	return 0;		/* Don't stop, no such slot */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!mid || cmid == -1)
// OBSOLETE     return 1;			/* stop */
// OBSOLETE 
// OBSOLETE   return cmid == mid && stop_exception == EXC_BREAKPOINT;
// OBSOLETE }
// OBSOLETE #endif /* THREAD_ALLOWED_TO_BREAK */
// OBSOLETE 
// OBSOLETE #ifdef THREAD_PARSE_ID
// OBSOLETE /*
// OBSOLETE  * Map a thread id string (MID or a @@SLOTNUMBER)
// OBSOLETE  * to a thread-id.
// OBSOLETE  *
// OBSOLETE  *   0  matches all threads.
// OBSOLETE  *   Otherwise the meaning is defined only in this file.
// OBSOLETE  *   (mach_thread_for_breakpoint uses it)
// OBSOLETE  *
// OBSOLETE  * @@@@ This allows non-existent MIDs to be specified.
// OBSOLETE  *    It now also allows non-existent slots to be
// OBSOLETE  *    specified. (Slot numbers stored are negative,
// OBSOLETE  *    and the magnitude is one greater than the actual
// OBSOLETE  *    slot index. (Since 0 is reserved))
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE mach_thread_parse_id (char *arg)
// OBSOLETE {
// OBSOLETE   int mid;
// OBSOLETE   if (arg == 0)
// OBSOLETE     error ("thread id expected");
// OBSOLETE   mid = parse_thread_id (arg, 0, 1);
// OBSOLETE 
// OBSOLETE   return mid;
// OBSOLETE }
// OBSOLETE #endif /* THREAD_PARSE_ID */
// OBSOLETE 
// OBSOLETE #ifdef THREAD_OUTPUT_ID
// OBSOLETE char *
// OBSOLETE mach_thread_output_id (int mid)
// OBSOLETE {
// OBSOLETE   static char foobar[20];
// OBSOLETE 
// OBSOLETE   if (mid > 0)
// OBSOLETE     sprintf (foobar, "mid %d", mid);
// OBSOLETE   else if (mid < 0)
// OBSOLETE     sprintf (foobar, "@@%d", -(mid + 1));
// OBSOLETE   else
// OBSOLETE     sprintf (foobar, "*any thread*");
// OBSOLETE 
// OBSOLETE   return foobar;
// OBSOLETE }
// OBSOLETE #endif /* THREAD_OUTPUT_ID */
// OBSOLETE 
// OBSOLETE /* Called with hook PREPARE_TO_PROCEED() from infrun.c.
// OBSOLETE 
// OBSOLETE  * If we have switched threads and stopped at breakpoint return 1 otherwise 0.
// OBSOLETE  *
// OBSOLETE  *  if SELECT_IT is nonzero, reselect the thread that was active when
// OBSOLETE  *  we stopped at a breakpoint.
// OBSOLETE  *
// OBSOLETE  * Note that this implementation is potentially redundant now that
// OBSOLETE  * default_prepare_to_proceed() has been added.  
// OBSOLETE  *
// OBSOLETE  * FIXME This may not support switching threads after Ctrl-C
// OBSOLETE  * correctly. The default implementation does support this.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE mach3_prepare_to_proceed (int select_it)
// OBSOLETE {
// OBSOLETE   if (stop_thread &&
// OBSOLETE       stop_thread != current_thread &&
// OBSOLETE       stop_exception == EXC_BREAKPOINT)
// OBSOLETE     {
// OBSOLETE       int mid;
// OBSOLETE 
// OBSOLETE       if (!select_it)
// OBSOLETE 	return 1;
// OBSOLETE 
// OBSOLETE       mid = switch_to_thread (stop_thread);
// OBSOLETE 
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* this stuff here is an upcall via libmach/excServer.c 
// OBSOLETE    and mach_really_wait which does the actual upcall.
// OBSOLETE 
// OBSOLETE    The code will pass the exception to the inferior if:
// OBSOLETE 
// OBSOLETE    - The task that signaled is not the inferior task
// OBSOLETE    (e.g. when debugging another debugger)
// OBSOLETE 
// OBSOLETE    - The user has explicitely requested to pass on the exceptions.
// OBSOLETE    (e.g to the default unix exception handler, which maps
// OBSOLETE    exceptions to signals, or the user has her own exception handler)
// OBSOLETE 
// OBSOLETE    - If the thread that signaled is being single-stepped and it
// OBSOLETE    has set it's own exception port and the exception is not
// OBSOLETE    EXC_BREAKPOINT. (Maybe this is not desirable?)
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE catch_exception_raise (mach_port_t port, thread_t thread, task_t task,
// OBSOLETE 		       int exception, int code, int subcode)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   boolean_t signal_thread;
// OBSOLETE   int mid = map_port_name_to_mid (thread, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (thread))
// OBSOLETE     {
// OBSOLETE       /* If the exception was sent and thread dies before we
// OBSOLETE          receive it, THREAD will be MACH_PORT_DEAD
// OBSOLETE        */
// OBSOLETE 
// OBSOLETE       current_thread = thread = MACH_PORT_NULL;
// OBSOLETE       error ("Received exception from nonexistent thread");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Check if the task died in transit.
// OBSOLETE    * @@@@ Isn't the thread also invalid in such case?
// OBSOLETE    */
// OBSOLETE   if (!MACH_PORT_VALID (task))
// OBSOLETE     {
// OBSOLETE       current_thread = thread = MACH_PORT_NULL;
// OBSOLETE       error ("Received exception from nonexistent task");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (exception < 0 || exception > MAX_EXCEPTION)
// OBSOLETE     internal_error (__FILE__, __LINE__,
// OBSOLETE 		    "catch_exception_raise: unknown exception code %d thread %d",
// OBSOLETE 		    exception,
// OBSOLETE 		    mid);
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (inferior_task))
// OBSOLETE     error ("got an exception, but inferior_task is null or dead");
// OBSOLETE 
// OBSOLETE   stop_exception = exception;
// OBSOLETE   stop_code = code;
// OBSOLETE   stop_subcode = subcode;
// OBSOLETE   stop_thread = thread;
// OBSOLETE 
// OBSOLETE   signal_thread = exception != EXC_BREAKPOINT &&
// OBSOLETE     port == singlestepped_thread_port &&
// OBSOLETE     MACH_PORT_VALID (thread_saved_exception_port);
// OBSOLETE 
// OBSOLETE   /* If it was not our inferior or if we want to forward
// OBSOLETE    * the exception to the inferior's handler, do it here
// OBSOLETE    *
// OBSOLETE    * Note: If you have forwarded EXC_BREAKPOINT I trust you know why.
// OBSOLETE    */
// OBSOLETE   if (task != inferior_task ||
// OBSOLETE       signal_thread ||
// OBSOLETE       exception_map[exception].forward)
// OBSOLETE     {
// OBSOLETE       mach_port_t eport = inferior_old_exception_port;
// OBSOLETE 
// OBSOLETE       if (signal_thread)
// OBSOLETE 	{
// OBSOLETE 	  /*
// OBSOLETE 	     GDB now forwards the exeption to thread's original handler,
// OBSOLETE 	     since the user propably knows what he is doing.
// OBSOLETE 	     Give a message, though.
// OBSOLETE 	   */
// OBSOLETE 
// OBSOLETE 	  mach3_exception_actions ((WAITTYPE *) NULL, TRUE, "Thread");
// OBSOLETE 	  eport = thread_saved_exception_port;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Send the exception to the original handler */
// OBSOLETE       ret = exception_raise (eport,
// OBSOLETE 			     thread,
// OBSOLETE 			     task,
// OBSOLETE 			     exception,
// OBSOLETE 			     code,
// OBSOLETE 			     subcode);
// OBSOLETE 
// OBSOLETE       (void) mach_port_deallocate (mach_task_self (), task);
// OBSOLETE       (void) mach_port_deallocate (mach_task_self (), thread);
// OBSOLETE 
// OBSOLETE       /* If we come here, we don't want to trace any more, since we
// OBSOLETE        * will never stop for tracing anyway.
// OBSOLETE        */
// OBSOLETE       discard_single_step (thread);
// OBSOLETE 
// OBSOLETE       /* Do not stop the inferior */
// OBSOLETE       return ret;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Now gdb handles the exception */
// OBSOLETE   stopped_in_exception = TRUE;
// OBSOLETE 
// OBSOLETE   ret = task_suspend (task);
// OBSOLETE   CHK ("Error suspending inferior after exception", ret);
// OBSOLETE 
// OBSOLETE   must_suspend_thread = 0;
// OBSOLETE 
// OBSOLETE   if (current_thread != thread)
// OBSOLETE     {
// OBSOLETE       if (MACH_PORT_VALID (singlestepped_thread_port))
// OBSOLETE 	/* Cleanup discards single stepping */
// OBSOLETE 	error ("Exception from thread %d while singlestepping thread %d",
// OBSOLETE 	       mid,
// OBSOLETE 	       map_port_name_to_mid (current_thread, MACH_TYPE_THREAD));
// OBSOLETE 
// OBSOLETE       /* Then select the thread that caused the exception */
// OBSOLETE       if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
// OBSOLETE 	error ("Could not select thread %d causing exception", mid);
// OBSOLETE       else
// OBSOLETE 	warning ("Gdb selected thread %d", mid);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* If we receive an exception that is not breakpoint
// OBSOLETE    * exception, we interrupt the single step and return to
// OBSOLETE    * debugger. Trace condition is cleared.
// OBSOLETE    */
// OBSOLETE   if (MACH_PORT_VALID (singlestepped_thread_port))
// OBSOLETE     {
// OBSOLETE       if (stop_exception != EXC_BREAKPOINT)
// OBSOLETE 	warning ("Single step interrupted by exception");
// OBSOLETE       else if (port == singlestepped_thread_port)
// OBSOLETE 	{
// OBSOLETE 	  /* Single step exception occurred, remove trace bit
// OBSOLETE 	   * and return to gdb.
// OBSOLETE 	   */
// OBSOLETE 	  if (!MACH_PORT_VALID (current_thread))
// OBSOLETE 	    error ("Single stepped thread is not valid");
// OBSOLETE 
// OBSOLETE 	  /* Resume threads, but leave the task suspended */
// OBSOLETE 	  resume_all_threads (0);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	warning ("Breakpoint while single stepping?");
// OBSOLETE 
// OBSOLETE       discard_single_step (current_thread);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   (void) mach_port_deallocate (mach_task_self (), task);
// OBSOLETE   (void) mach_port_deallocate (mach_task_self (), thread);
// OBSOLETE 
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE port_valid (mach_port_t port, int mask)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   mach_port_type_t type;
// OBSOLETE 
// OBSOLETE   ret = mach_port_type (mach_task_self (),
// OBSOLETE 			port,
// OBSOLETE 			&type);
// OBSOLETE   if (ret != KERN_SUCCESS || (type & mask) != mask)
// OBSOLETE     return 0;
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* @@@@ No vm read cache implemented yet */
// OBSOLETE boolean_t vm_read_cache_valid = FALSE;
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Read inferior task's LEN bytes from ADDR and copy it to MYADDR
// OBSOLETE  * in gdb's address space.
// OBSOLETE  *
// OBSOLETE  * Return 0 on failure; number of bytes read otherwise.
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE mach3_read_inferior (CORE_ADDR addr, char *myaddr, int length)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   vm_address_t low_address = (vm_address_t) trunc_page (addr);
// OBSOLETE   vm_size_t aligned_length =
// OBSOLETE   (vm_size_t) round_page (addr + length) - low_address;
// OBSOLETE   pointer_t copied_memory;
// OBSOLETE   int copy_count;
// OBSOLETE 
// OBSOLETE   /* Get memory from inferior with page aligned addresses */
// OBSOLETE   ret = vm_read (inferior_task,
// OBSOLETE 		 low_address,
// OBSOLETE 		 aligned_length,
// OBSOLETE 		 &copied_memory,
// OBSOLETE 		 &copy_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       /* the problem is that the inferior might be killed for whatever reason
// OBSOLETE        * before we go to mach_really_wait. This is one place that ought to
// OBSOLETE        * catch many of those errors.
// OBSOLETE        * @@@@ A better fix would be to make all external events to GDB
// OBSOLETE        * to arrive via a SINGLE port set. (Including user input!)
// OBSOLETE        */
// OBSOLETE 
// OBSOLETE       if (!port_valid (inferior_task, MACH_PORT_TYPE_SEND))
// OBSOLETE 	{
// OBSOLETE 	  m3_kill_inferior ();
// OBSOLETE 	  error ("Inferior killed (task port invalid)");
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE #ifdef OSF
// OBSOLETE 	  extern int errno;
// OBSOLETE 	  /* valprint.c gives nicer format if this does not
// OBSOLETE 	     screw it. Eamonn seems to like this, so I enable
// OBSOLETE 	     it if OSF is defined...
// OBSOLETE 	   */
// OBSOLETE 	  warning ("[read inferior %x failed: %s]",
// OBSOLETE 		   addr, mach_error_string (ret));
// OBSOLETE 	  errno = 0;
// OBSOLETE #endif
// OBSOLETE 	  return 0;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   memcpy (myaddr, (char *) addr - low_address + copied_memory, length);
// OBSOLETE 
// OBSOLETE   ret = vm_deallocate (mach_task_self (),
// OBSOLETE 		       copied_memory,
// OBSOLETE 		       copy_count);
// OBSOLETE   CHK ("mach3_read_inferior vm_deallocate failed", ret);
// OBSOLETE 
// OBSOLETE   return length;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #define CHK_GOTO_OUT(str,ret) \
// OBSOLETE   do if (ret != KERN_SUCCESS) { errstr = #str; goto out; } while(0)
// OBSOLETE 
// OBSOLETE struct vm_region_list
// OBSOLETE {
// OBSOLETE   struct vm_region_list *next;
// OBSOLETE   vm_prot_t protection;
// OBSOLETE   vm_address_t start;
// OBSOLETE   vm_size_t length;
// OBSOLETE };
// OBSOLETE 
// OBSOLETE struct obstack region_obstack;
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Write inferior task's LEN bytes from ADDR and copy it to MYADDR
// OBSOLETE  * in gdb's address space.
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE mach3_write_inferior (CORE_ADDR addr, char *myaddr, int length)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   vm_address_t low_address = (vm_address_t) trunc_page (addr);
// OBSOLETE   vm_size_t aligned_length =
// OBSOLETE   (vm_size_t) round_page (addr + length) - low_address;
// OBSOLETE   pointer_t copied_memory;
// OBSOLETE   int copy_count;
// OBSOLETE   int deallocate = 0;
// OBSOLETE 
// OBSOLETE   char *errstr = "Bug in mach3_write_inferior";
// OBSOLETE 
// OBSOLETE   struct vm_region_list *region_element;
// OBSOLETE   struct vm_region_list *region_head = (struct vm_region_list *) NULL;
// OBSOLETE 
// OBSOLETE   /* Get memory from inferior with page aligned addresses */
// OBSOLETE   ret = vm_read (inferior_task,
// OBSOLETE 		 low_address,
// OBSOLETE 		 aligned_length,
// OBSOLETE 		 &copied_memory,
// OBSOLETE 		 &copy_count);
// OBSOLETE   CHK_GOTO_OUT ("mach3_write_inferior vm_read failed", ret);
// OBSOLETE 
// OBSOLETE   deallocate++;
// OBSOLETE 
// OBSOLETE   memcpy ((char *) addr - low_address + copied_memory, myaddr, length);
// OBSOLETE 
// OBSOLETE   obstack_init (&region_obstack);
// OBSOLETE 
// OBSOLETE   /* Do writes atomically.
// OBSOLETE    * First check for holes and unwritable memory.
// OBSOLETE    */
// OBSOLETE   {
// OBSOLETE     vm_size_t remaining_length = aligned_length;
// OBSOLETE     vm_address_t region_address = low_address;
// OBSOLETE 
// OBSOLETE     struct vm_region_list *scan;
// OBSOLETE 
// OBSOLETE     while (region_address < low_address + aligned_length)
// OBSOLETE       {
// OBSOLETE 	vm_prot_t protection;
// OBSOLETE 	vm_prot_t max_protection;
// OBSOLETE 	vm_inherit_t inheritance;
// OBSOLETE 	boolean_t shared;
// OBSOLETE 	mach_port_t object_name;
// OBSOLETE 	vm_offset_t offset;
// OBSOLETE 	vm_size_t region_length = remaining_length;
// OBSOLETE 	vm_address_t old_address = region_address;
// OBSOLETE 
// OBSOLETE 	ret = vm_region (inferior_task,
// OBSOLETE 			 &region_address,
// OBSOLETE 			 &region_length,
// OBSOLETE 			 &protection,
// OBSOLETE 			 &max_protection,
// OBSOLETE 			 &inheritance,
// OBSOLETE 			 &shared,
// OBSOLETE 			 &object_name,
// OBSOLETE 			 &offset);
// OBSOLETE 	CHK_GOTO_OUT ("vm_region failed", ret);
// OBSOLETE 
// OBSOLETE 	/* Check for holes in memory */
// OBSOLETE 	if (old_address != region_address)
// OBSOLETE 	  {
// OBSOLETE 	    warning ("No memory at 0x%x. Nothing written",
// OBSOLETE 		     old_address);
// OBSOLETE 	    ret = KERN_SUCCESS;
// OBSOLETE 	    length = 0;
// OBSOLETE 	    goto out;
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE 	if (!(max_protection & VM_PROT_WRITE))
// OBSOLETE 	  {
// OBSOLETE 	    warning ("Memory at address 0x%x is unwritable. Nothing written",
// OBSOLETE 		     old_address);
// OBSOLETE 	    ret = KERN_SUCCESS;
// OBSOLETE 	    length = 0;
// OBSOLETE 	    goto out;
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE 	/* Chain the regions for later use */
// OBSOLETE 	region_element =
// OBSOLETE 	  (struct vm_region_list *)
// OBSOLETE 	  obstack_alloc (&region_obstack, sizeof (struct vm_region_list));
// OBSOLETE 
// OBSOLETE 	region_element->protection = protection;
// OBSOLETE 	region_element->start = region_address;
// OBSOLETE 	region_element->length = region_length;
// OBSOLETE 
// OBSOLETE 	/* Chain the regions along with protections */
// OBSOLETE 	region_element->next = region_head;
// OBSOLETE 	region_head = region_element;
// OBSOLETE 
// OBSOLETE 	region_address += region_length;
// OBSOLETE 	remaining_length = remaining_length - region_length;
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE     /* If things fail after this, we give up.
// OBSOLETE      * Somebody is messing up inferior_task's mappings.
// OBSOLETE      */
// OBSOLETE 
// OBSOLETE     /* Enable writes to the chained vm regions */
// OBSOLETE     for (scan = region_head; scan; scan = scan->next)
// OBSOLETE       {
// OBSOLETE 	boolean_t protection_changed = FALSE;
// OBSOLETE 
// OBSOLETE 	if (!(scan->protection & VM_PROT_WRITE))
// OBSOLETE 	  {
// OBSOLETE 	    ret = vm_protect (inferior_task,
// OBSOLETE 			      scan->start,
// OBSOLETE 			      scan->length,
// OBSOLETE 			      FALSE,
// OBSOLETE 			      scan->protection | VM_PROT_WRITE);
// OBSOLETE 	    CHK_GOTO_OUT ("vm_protect: enable write failed", ret);
// OBSOLETE 	  }
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE     ret = vm_write (inferior_task,
// OBSOLETE 		    low_address,
// OBSOLETE 		    copied_memory,
// OBSOLETE 		    aligned_length);
// OBSOLETE     CHK_GOTO_OUT ("vm_write failed", ret);
// OBSOLETE 
// OBSOLETE     /* Set up the original region protections, if they were changed */
// OBSOLETE     for (scan = region_head; scan; scan = scan->next)
// OBSOLETE       {
// OBSOLETE 	boolean_t protection_changed = FALSE;
// OBSOLETE 
// OBSOLETE 	if (!(scan->protection & VM_PROT_WRITE))
// OBSOLETE 	  {
// OBSOLETE 	    ret = vm_protect (inferior_task,
// OBSOLETE 			      scan->start,
// OBSOLETE 			      scan->length,
// OBSOLETE 			      FALSE,
// OBSOLETE 			      scan->protection);
// OBSOLETE 	    CHK_GOTO_OUT ("vm_protect: enable write failed", ret);
// OBSOLETE 	  }
// OBSOLETE       }
// OBSOLETE   }
// OBSOLETE 
// OBSOLETE out:
// OBSOLETE   if (deallocate)
// OBSOLETE     {
// OBSOLETE       obstack_free (&region_obstack, 0);
// OBSOLETE 
// OBSOLETE       (void) vm_deallocate (mach_task_self (),
// OBSOLETE 			    copied_memory,
// OBSOLETE 			    copy_count);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("%s %s", errstr, mach_error_string (ret));
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return length;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return 0 on failure, number of bytes handled otherwise.  TARGET is
// OBSOLETE    ignored. */
// OBSOLETE static int
// OBSOLETE m3_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
// OBSOLETE 		struct target_ops *target)
// OBSOLETE {
// OBSOLETE   int result;
// OBSOLETE 
// OBSOLETE   if (write)
// OBSOLETE     result = mach3_write_inferior (memaddr, myaddr, len);
// OBSOLETE   else
// OBSOLETE     result = mach3_read_inferior (memaddr, myaddr, len);
// OBSOLETE 
// OBSOLETE   return result;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE translate_state (int state)
// OBSOLETE {
// OBSOLETE   switch (state)
// OBSOLETE     {
// OBSOLETE     case TH_STATE_RUNNING:
// OBSOLETE       return ("R");
// OBSOLETE     case TH_STATE_STOPPED:
// OBSOLETE       return ("S");
// OBSOLETE     case TH_STATE_WAITING:
// OBSOLETE       return ("W");
// OBSOLETE     case TH_STATE_UNINTERRUPTIBLE:
// OBSOLETE       return ("U");
// OBSOLETE     case TH_STATE_HALTED:
// OBSOLETE       return ("H");
// OBSOLETE     default:
// OBSOLETE       return ("?");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE translate_cstate (int state)
// OBSOLETE {
// OBSOLETE   switch (state)
// OBSOLETE     {
// OBSOLETE     case CPROC_RUNNING:
// OBSOLETE       return "R";
// OBSOLETE     case CPROC_SWITCHING:
// OBSOLETE       return "S";
// OBSOLETE     case CPROC_BLOCKED:
// OBSOLETE       return "B";
// OBSOLETE     case CPROC_CONDWAIT:
// OBSOLETE       return "C";
// OBSOLETE     case CPROC_CONDWAIT | CPROC_SWITCHING:
// OBSOLETE       return "CS";
// OBSOLETE     default:
// OBSOLETE       return "?";
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* type == MACH_MSG_TYPE_COPY_SEND || type == MACH_MSG_TYPE_MAKE_SEND */
// OBSOLETE 
// OBSOLETE mach_port_t			/* no mach_port_name_t found in include files. */
// OBSOLETE map_inferior_port_name (mach_port_t inferior_name, mach_msg_type_name_t type)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   mach_msg_type_name_t acquired;
// OBSOLETE   mach_port_t iport;
// OBSOLETE 
// OBSOLETE   ret = mach_port_extract_right (inferior_task,
// OBSOLETE 				 inferior_name,
// OBSOLETE 				 type,
// OBSOLETE 				 &iport,
// OBSOLETE 				 &acquired);
// OBSOLETE   CHK ("mach_port_extract_right (map_inferior_port_name)", ret);
// OBSOLETE 
// OBSOLETE   if (acquired != MACH_MSG_TYPE_PORT_SEND)
// OBSOLETE     error ("Incorrect right extracted, (map_inferior_port_name)");
// OBSOLETE 
// OBSOLETE   ret = mach_port_deallocate (mach_task_self (),
// OBSOLETE 			      iport);
// OBSOLETE   CHK ("Deallocating mapped port (map_inferior_port_name)", ret);
// OBSOLETE 
// OBSOLETE   return iport;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Naming convention:
// OBSOLETE  *  Always return user defined name if found.
// OBSOLETE  *  _K == A kernel thread with no matching CPROC
// OBSOLETE  *  _C == A cproc with no current cthread
// OBSOLETE  *  _t == A cthread with no user defined name
// OBSOLETE  *
// OBSOLETE  * The digits that follow the _names are the SLOT number of the
// OBSOLETE  * kernel thread if there is such a thing, otherwise just a negation
// OBSOLETE  * of the sequential number of such cprocs.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static char buf[7];
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE get_thread_name (gdb_thread_t one_cproc, int id)
// OBSOLETE {
// OBSOLETE   if (one_cproc)
// OBSOLETE     if (one_cproc->cthread == NULL)
// OBSOLETE       {
// OBSOLETE 	/* cproc not mapped to any cthread */
// OBSOLETE 	sprintf (buf, "_C%d", id);
// OBSOLETE       }
// OBSOLETE     else if (!one_cproc->cthread->name)
// OBSOLETE       {
// OBSOLETE 	/* cproc and cthread, but no name */
// OBSOLETE 	sprintf (buf, "_t%d", id);
// OBSOLETE       }
// OBSOLETE     else
// OBSOLETE       return (char *) (one_cproc->cthread->name);
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if (id < 0)
// OBSOLETE 	warning ("Inconsistency in thread name id %d", id);
// OBSOLETE 
// OBSOLETE       /* Kernel thread without cproc */
// OBSOLETE       sprintf (buf, "_K%d", id);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return buf;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fetch_thread_info (mach_port_t task, gdb_thread_t *mthreads_out)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_array_t th_table;
// OBSOLETE   int th_count;
// OBSOLETE   gdb_thread_t mthreads = NULL;
// OBSOLETE   int index;
// OBSOLETE 
// OBSOLETE   ret = task_threads (task, &th_table, &th_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("Error getting inferior's thread list:%s",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE       m3_kill_inferior ();
// OBSOLETE       return -1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   mthreads = (gdb_thread_t)
// OBSOLETE     obstack_alloc
// OBSOLETE     (cproc_obstack,
// OBSOLETE      th_count * sizeof (struct gdb_thread));
// OBSOLETE 
// OBSOLETE   for (index = 0; index < th_count; index++)
// OBSOLETE     {
// OBSOLETE       thread_t saved_thread = MACH_PORT_NULL;
// OBSOLETE       int mid;
// OBSOLETE 
// OBSOLETE       if (must_suspend_thread)
// OBSOLETE 	setup_thread (th_table[index], 1);
// OBSOLETE 
// OBSOLETE       if (th_table[index] != current_thread)
// OBSOLETE 	{
// OBSOLETE 	  saved_thread = current_thread;
// OBSOLETE 
// OBSOLETE 	  mid = switch_to_thread (th_table[index]);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       mthreads[index].name = th_table[index];
// OBSOLETE       mthreads[index].cproc = NULL;	/* map_cprocs_to_kernel_threads() */
// OBSOLETE       mthreads[index].in_emulator = FALSE;
// OBSOLETE       mthreads[index].slotid = index;
// OBSOLETE 
// OBSOLETE       mthreads[index].sp = read_register (SP_REGNUM);
// OBSOLETE       mthreads[index].fp = read_register (FP_REGNUM);
// OBSOLETE       mthreads[index].pc = read_pc ();
// OBSOLETE 
// OBSOLETE       if (MACH_PORT_VALID (saved_thread))
// OBSOLETE 	mid = switch_to_thread (saved_thread);
// OBSOLETE 
// OBSOLETE       if (must_suspend_thread)
// OBSOLETE 	setup_thread (th_table[index], 0);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   consume_send_rights (th_table, th_count);
// OBSOLETE   ret = vm_deallocate (mach_task_self (), (vm_address_t) th_table,
// OBSOLETE 		       (th_count * sizeof (mach_port_t)));
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("Error trying to deallocate thread list : %s",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   *mthreads_out = mthreads;
// OBSOLETE 
// OBSOLETE   return th_count;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Current emulator always saves the USP on top of
// OBSOLETE  * emulator stack below struct emul_stack_top stuff.
// OBSOLETE  */
// OBSOLETE CORE_ADDR
// OBSOLETE fetch_usp_from_emulator_stack (CORE_ADDR sp)
// OBSOLETE {
// OBSOLETE   CORE_ADDR stack_pointer;
// OBSOLETE 
// OBSOLETE   sp = (sp & ~(EMULATOR_STACK_SIZE - 1)) +
// OBSOLETE     EMULATOR_STACK_SIZE - sizeof (struct emul_stack_top);
// OBSOLETE 
// OBSOLETE   if (mach3_read_inferior (sp,
// OBSOLETE 			   &stack_pointer,
// OBSOLETE 			   sizeof (CORE_ADDR)) != sizeof (CORE_ADDR))
// OBSOLETE     {
// OBSOLETE       warning ("Can't read user sp from emulator stack address 0x%x", sp);
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return stack_pointer;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef MK67
// OBSOLETE 
// OBSOLETE /* get_emulation_vector() interface was changed after mk67 */
// OBSOLETE #define EMUL_VECTOR_COUNT 400	/* Value does not matter too much */
// OBSOLETE 
// OBSOLETE #endif /* MK67 */
// OBSOLETE 
// OBSOLETE /* Check if the emulator exists at task's address space.
// OBSOLETE  */
// OBSOLETE boolean_t
// OBSOLETE have_emulator_p (task_t task)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE #ifndef EMUL_VECTOR_COUNT
// OBSOLETE   vm_offset_t *emulation_vector;
// OBSOLETE   int n;
// OBSOLETE #else
// OBSOLETE   vm_offset_t emulation_vector[EMUL_VECTOR_COUNT];
// OBSOLETE   int n = EMUL_VECTOR_COUNT;
// OBSOLETE #endif
// OBSOLETE   int i;
// OBSOLETE   int vector_start;
// OBSOLETE 
// OBSOLETE   ret = task_get_emulation_vector (task,
// OBSOLETE 				   &vector_start,
// OBSOLETE #ifndef EMUL_VECTOR_COUNT
// OBSOLETE 				   &emulation_vector,
// OBSOLETE #else
// OBSOLETE 				   emulation_vector,
// OBSOLETE #endif
// OBSOLETE 				   &n);
// OBSOLETE   CHK ("task_get_emulation_vector", ret);
// OBSOLETE   xx_debug ("%d vectors from %d at 0x%08x\n",
// OBSOLETE 	    n, vector_start, emulation_vector);
// OBSOLETE 
// OBSOLETE   for (i = 0; i < n; i++)
// OBSOLETE     {
// OBSOLETE       vm_offset_t entry = emulation_vector[i];
// OBSOLETE 
// OBSOLETE       if (EMULATOR_BASE <= entry && entry <= EMULATOR_END)
// OBSOLETE 	return TRUE;
// OBSOLETE       else if (entry)
// OBSOLETE 	{
// OBSOLETE 	  static boolean_t informed = FALSE;
// OBSOLETE 	  if (!informed)
// OBSOLETE 	    {
// OBSOLETE 	      warning ("Emulation vector address 0x08%x outside emulator space",
// OBSOLETE 		       entry);
// OBSOLETE 	      informed = TRUE;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   return FALSE;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Map cprocs to kernel threads and vice versa.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE map_cprocs_to_kernel_threads (gdb_thread_t cprocs, gdb_thread_t mthreads,
// OBSOLETE 			      int thread_count)
// OBSOLETE {
// OBSOLETE   int index;
// OBSOLETE   gdb_thread_t scan;
// OBSOLETE   boolean_t all_mapped = TRUE;
// OBSOLETE   LONGEST stack_base;
// OBSOLETE   LONGEST stack_size;
// OBSOLETE 
// OBSOLETE   for (scan = cprocs; scan; scan = scan->next)
// OBSOLETE     {
// OBSOLETE       /* Default to: no kernel thread for this cproc */
// OBSOLETE       scan->reverse_map = -1;
// OBSOLETE 
// OBSOLETE       /* Check if the cproc is found by its stack */
// OBSOLETE       for (index = 0; index < thread_count; index++)
// OBSOLETE 	{
// OBSOLETE 	  stack_base =
// OBSOLETE 	    extract_signed_integer (scan->raw_cproc + CPROC_BASE_OFFSET,
// OBSOLETE 				    CPROC_BASE_SIZE);
// OBSOLETE 	  stack_size =
// OBSOLETE 	    extract_signed_integer (scan->raw_cproc + CPROC_SIZE_OFFSET,
// OBSOLETE 				    CPROC_SIZE_SIZE);
// OBSOLETE 	  if ((mthreads + index)->sp > stack_base &&
// OBSOLETE 	      (mthreads + index)->sp <= stack_base + stack_size)
// OBSOLETE 	    {
// OBSOLETE 	      (mthreads + index)->cproc = scan;
// OBSOLETE 	      scan->reverse_map = index;
// OBSOLETE 	      break;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       all_mapped &= (scan->reverse_map != -1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Check for threads that are currently in the emulator.
// OBSOLETE    * If so, they have a different stack, and the still unmapped
// OBSOLETE    * cprocs may well get mapped to these threads.
// OBSOLETE    * 
// OBSOLETE    * If:
// OBSOLETE    *  - cproc stack does not match any kernel thread stack pointer
// OBSOLETE    *  - there is at least one extra kernel thread
// OBSOLETE    *    that has no cproc mapped above.
// OBSOLETE    *  - some kernel thread stack pointer points to emulator space
// OBSOLETE    *  then we find the user stack pointer saved in the emulator
// OBSOLETE    *  stack, and try to map that to the cprocs.
// OBSOLETE    *
// OBSOLETE    * Also set in_emulator for kernel threads.
// OBSOLETE    */
// OBSOLETE 
// OBSOLETE   if (emulator_present)
// OBSOLETE     {
// OBSOLETE       for (index = 0; index < thread_count; index++)
// OBSOLETE 	{
// OBSOLETE 	  CORE_ADDR emul_sp;
// OBSOLETE 	  CORE_ADDR usp;
// OBSOLETE 
// OBSOLETE 	  gdb_thread_t mthread = (mthreads + index);
// OBSOLETE 	  emul_sp = mthread->sp;
// OBSOLETE 
// OBSOLETE 	  if (mthread->cproc == NULL &&
// OBSOLETE 	      EMULATOR_BASE <= emul_sp && emul_sp <= EMULATOR_END)
// OBSOLETE 	    {
// OBSOLETE 	      mthread->in_emulator = emulator_present;
// OBSOLETE 
// OBSOLETE 	      if (!all_mapped && cprocs)
// OBSOLETE 		{
// OBSOLETE 		  usp = fetch_usp_from_emulator_stack (emul_sp);
// OBSOLETE 
// OBSOLETE 		  /* @@@@ Could be more accurate */
// OBSOLETE 		  if (!usp)
// OBSOLETE 		    error ("Zero stack pointer read from emulator?");
// OBSOLETE 
// OBSOLETE 		  /* Try to match this stack pointer to the cprocs that
// OBSOLETE 		   * don't yet have a kernel thread.
// OBSOLETE 		   */
// OBSOLETE 		  for (scan = cprocs; scan; scan = scan->next)
// OBSOLETE 		    {
// OBSOLETE 
// OBSOLETE 		      /* Check is this unmapped CPROC stack contains
// OBSOLETE 		       * the user stack pointer saved in the
// OBSOLETE 		       * emulator.
// OBSOLETE 		       */
// OBSOLETE 		      if (scan->reverse_map == -1)
// OBSOLETE 			{
// OBSOLETE 			  stack_base =
// OBSOLETE 			    extract_signed_integer
// OBSOLETE 			    (scan->raw_cproc + CPROC_BASE_OFFSET,
// OBSOLETE 			     CPROC_BASE_SIZE);
// OBSOLETE 			  stack_size =
// OBSOLETE 			    extract_signed_integer
// OBSOLETE 			    (scan->raw_cproc + CPROC_SIZE_OFFSET,
// OBSOLETE 			     CPROC_SIZE_SIZE);
// OBSOLETE 			  if (usp > stack_base &&
// OBSOLETE 			      usp <= stack_base + stack_size)
// OBSOLETE 			    {
// OBSOLETE 			      mthread->cproc = scan;
// OBSOLETE 			      scan->reverse_map = index;
// OBSOLETE 			      break;
// OBSOLETE 			    }
// OBSOLETE 			}
// OBSOLETE 		    }
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Format of the thread_list command
// OBSOLETE  *
// OBSOLETE  *                   slot mid sel   name  emul ks susp  cstate wired   address
// OBSOLETE  */
// OBSOLETE #define TL_FORMAT "%-2.2s %5d%c %-10.10s %1.1s%s%-5.5s %-2.2s %-5.5s "
// OBSOLETE 
// OBSOLETE #define TL_HEADER "\n@@    MID  Name        KState CState   Where\n"
// OBSOLETE 
// OBSOLETE void
// OBSOLETE print_tl_address (struct ui_file *stream, CORE_ADDR pc)
// OBSOLETE {
// OBSOLETE   if (!lookup_minimal_symbol_by_pc (pc))
// OBSOLETE     fprintf_filtered (stream, local_hex_format (), pc);
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       extern int addressprint;
// OBSOLETE       extern int asm_demangle;
// OBSOLETE 
// OBSOLETE       int store = addressprint;
// OBSOLETE       addressprint = 0;
// OBSOLETE       print_address_symbolic (pc, stream, asm_demangle, "");
// OBSOLETE       addressprint = store;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* For thread names, but also for gdb_message_port external name */
// OBSOLETE #define MAX_NAME_LEN 50
// OBSOLETE 
// OBSOLETE /* Returns the address of variable NAME or 0 if not found */
// OBSOLETE CORE_ADDR
// OBSOLETE lookup_address_of_variable (char *name)
// OBSOLETE {
// OBSOLETE   struct symbol *sym;
// OBSOLETE   CORE_ADDR symaddr = 0;
// OBSOLETE   struct minimal_symbol *msymbol;
// OBSOLETE 
// OBSOLETE   sym = lookup_symbol (name,
// OBSOLETE 		       (struct block *) NULL,
// OBSOLETE 		       VAR_DOMAIN,
// OBSOLETE 		       (int *) NULL,
// OBSOLETE 		       (struct symtab **) NULL);
// OBSOLETE 
// OBSOLETE   if (sym)
// OBSOLETE     symaddr = SYMBOL_VALUE (sym);
// OBSOLETE 
// OBSOLETE   if (!symaddr)
// OBSOLETE     {
// OBSOLETE       msymbol = lookup_minimal_symbol (name, NULL, NULL);
// OBSOLETE 
// OBSOLETE       if (msymbol && msymbol->type == mst_data)
// OBSOLETE 	symaddr = SYMBOL_VALUE_ADDRESS (msymbol);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return symaddr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static gdb_thread_t
// OBSOLETE get_cprocs (void)
// OBSOLETE {
// OBSOLETE   gdb_thread_t cproc_head;
// OBSOLETE   gdb_thread_t cproc_copy;
// OBSOLETE   CORE_ADDR their_cprocs;
// OBSOLETE   char *buf;
// OBSOLETE   char *name;
// OBSOLETE   cthread_t cthread;
// OBSOLETE   CORE_ADDR symaddr;
// OBSOLETE 
// OBSOLETE   buf = alloca (TARGET_PTR_BIT / HOST_CHAR_BIT);
// OBSOLETE   symaddr = lookup_address_of_variable ("cproc_list");
// OBSOLETE 
// OBSOLETE   if (!symaddr)
// OBSOLETE     {
// OBSOLETE       /* cproc_list is not in a file compiled with debugging
// OBSOLETE          symbols, but don't give up yet */
// OBSOLETE 
// OBSOLETE       symaddr = lookup_address_of_variable ("cprocs");
// OBSOLETE 
// OBSOLETE       if (symaddr)
// OBSOLETE 	{
// OBSOLETE 	  static int informed = 0;
// OBSOLETE 	  if (!informed)
// OBSOLETE 	    {
// OBSOLETE 	      informed++;
// OBSOLETE 	      warning ("Your program is loaded with an old threads library.");
// OBSOLETE 	      warning ("GDB does not know the old form of threads");
// OBSOLETE 	      warning ("so things may not work.");
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Stripped or no -lthreads loaded or "cproc_list" is in wrong segment. */
// OBSOLETE   if (!symaddr)
// OBSOLETE     return NULL;
// OBSOLETE 
// OBSOLETE   /* Get the address of the first cproc in the task */
// OBSOLETE   if (!mach3_read_inferior (symaddr,
// OBSOLETE 			    buf,
// OBSOLETE 			    TARGET_PTR_BIT / HOST_CHAR_BIT))
// OBSOLETE     error ("Can't read cproc master list at address (0x%x).", symaddr);
// OBSOLETE   their_cprocs = extract_address (buf, TARGET_PTR_BIT / HOST_CHAR_BIT);
// OBSOLETE 
// OBSOLETE   /* Scan the CPROCs in the task.
// OBSOLETE      CPROCs are chained with LIST field, not NEXT field, which
// OBSOLETE      chains mutexes, condition variables and queues */
// OBSOLETE 
// OBSOLETE   cproc_head = NULL;
// OBSOLETE 
// OBSOLETE   while (their_cprocs != (CORE_ADDR) 0)
// OBSOLETE     {
// OBSOLETE       CORE_ADDR cproc_copy_incarnation;
// OBSOLETE       cproc_copy = (gdb_thread_t) obstack_alloc (cproc_obstack,
// OBSOLETE 						 sizeof (struct gdb_thread));
// OBSOLETE 
// OBSOLETE       if (!mach3_read_inferior (their_cprocs,
// OBSOLETE 				&cproc_copy->raw_cproc[0],
// OBSOLETE 				CPROC_SIZE))
// OBSOLETE 	error ("Can't read next cproc at 0x%x.", their_cprocs);
// OBSOLETE 
// OBSOLETE       their_cprocs =
// OBSOLETE 	extract_address (cproc_copy->raw_cproc + CPROC_LIST_OFFSET,
// OBSOLETE 			 CPROC_LIST_SIZE);
// OBSOLETE       cproc_copy_incarnation =
// OBSOLETE 	extract_address (cproc_copy->raw_cproc + CPROC_INCARNATION_OFFSET,
// OBSOLETE 			 CPROC_INCARNATION_SIZE);
// OBSOLETE 
// OBSOLETE       if (cproc_copy_incarnation == (CORE_ADDR) 0)
// OBSOLETE 	cproc_copy->cthread = NULL;
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* This CPROC has an attached CTHREAD. Get its name */
// OBSOLETE 	  cthread = (cthread_t) obstack_alloc (cproc_obstack,
// OBSOLETE 					       sizeof (struct cthread));
// OBSOLETE 
// OBSOLETE 	  if (!mach3_read_inferior (cproc_copy_incarnation,
// OBSOLETE 				    cthread,
// OBSOLETE 				    sizeof (struct cthread)))
// OBSOLETE 	      error ("Can't read next thread at 0x%x.",
// OBSOLETE 		     cproc_copy_incarnation);
// OBSOLETE 
// OBSOLETE 	  cproc_copy->cthread = cthread;
// OBSOLETE 
// OBSOLETE 	  if (cthread->name)
// OBSOLETE 	    {
// OBSOLETE 	      name = (char *) obstack_alloc (cproc_obstack, MAX_NAME_LEN);
// OBSOLETE 
// OBSOLETE 	      if (!mach3_read_inferior (cthread->name, name, MAX_NAME_LEN))
// OBSOLETE 		error ("Can't read next thread's name at 0x%x.", cthread->name);
// OBSOLETE 
// OBSOLETE 	      cthread->name = name;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* insert in front */
// OBSOLETE       cproc_copy->next = cproc_head;
// OBSOLETE       cproc_head = cproc_copy;
// OBSOLETE     }
// OBSOLETE   return cproc_head;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifndef FETCH_CPROC_STATE
// OBSOLETE /*
// OBSOLETE  * Check if your machine does not grok the way this routine
// OBSOLETE  * fetches the FP,PC and SP of a cproc that is not
// OBSOLETE  * currently attached to any kernel thread (e.g. its cproc.context
// OBSOLETE  * field points to the place in stack where the context
// OBSOLETE  * is saved).
// OBSOLETE  *
// OBSOLETE  * If it doesn't, define your own routine.
// OBSOLETE  */
// OBSOLETE #define FETCH_CPROC_STATE(mth) mach3_cproc_state (mth)
// OBSOLETE 
// OBSOLETE int
// OBSOLETE mach3_cproc_state (gdb_thread_t mthread)
// OBSOLETE {
// OBSOLETE   int context;
// OBSOLETE 
// OBSOLETE   if (!mthread || !mthread->cproc)
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   context = extract_signed_integer
// OBSOLETE     (mthread->cproc->raw_cproc + CPROC_CONTEXT_OFFSET,
// OBSOLETE      CPROC_CONTEXT_SIZE);
// OBSOLETE   if (context == 0)
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   mthread->sp = context + MACHINE_CPROC_SP_OFFSET;
// OBSOLETE 
// OBSOLETE   if (mach3_read_inferior (context + MACHINE_CPROC_PC_OFFSET,
// OBSOLETE 			   &mthread->pc,
// OBSOLETE 			   sizeof (CORE_ADDR)) != sizeof (CORE_ADDR))
// OBSOLETE     {
// OBSOLETE       warning ("Can't read cproc pc from inferior");
// OBSOLETE       return -1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (mach3_read_inferior (context + MACHINE_CPROC_FP_OFFSET,
// OBSOLETE 			   &mthread->fp,
// OBSOLETE 			   sizeof (CORE_ADDR)) != sizeof (CORE_ADDR))
// OBSOLETE     {
// OBSOLETE       warning ("Can't read cproc fp from inferior");
// OBSOLETE       return -1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE #endif /* FETCH_CPROC_STATE */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE void
// OBSOLETE thread_list_command (void)
// OBSOLETE {
// OBSOLETE   thread_basic_info_data_t ths;
// OBSOLETE   int thread_count;
// OBSOLETE   gdb_thread_t cprocs;
// OBSOLETE   gdb_thread_t scan;
// OBSOLETE   int index;
// OBSOLETE   char *name;
// OBSOLETE   char selected;
// OBSOLETE   char *wired;
// OBSOLETE   int infoCnt;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   mach_port_t mid_or_port;
// OBSOLETE   gdb_thread_t their_threads;
// OBSOLETE   gdb_thread_t kthread;
// OBSOLETE 
// OBSOLETE   int neworder = 1;
// OBSOLETE 
// OBSOLETE   char *fmt = "There are %d kernel threads in task %d.\n";
// OBSOLETE 
// OBSOLETE   int tmid = map_port_name_to_mid (inferior_task, MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   thread_count = fetch_thread_info (inferior_task,
// OBSOLETE 				    &their_threads);
// OBSOLETE   if (thread_count == -1)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   if (thread_count == 1)
// OBSOLETE     fmt = "There is %d kernel thread in task %d.\n";
// OBSOLETE 
// OBSOLETE   printf_filtered (fmt, thread_count, tmid);
// OBSOLETE 
// OBSOLETE   puts_filtered (TL_HEADER);
// OBSOLETE 
// OBSOLETE   cprocs = get_cprocs ();
// OBSOLETE 
// OBSOLETE   map_cprocs_to_kernel_threads (cprocs, their_threads, thread_count);
// OBSOLETE 
// OBSOLETE   for (scan = cprocs; scan; scan = scan->next)
// OBSOLETE     {
// OBSOLETE       int mid;
// OBSOLETE       char buf[10];
// OBSOLETE       char slot[3];
// OBSOLETE       int cproc_state =
// OBSOLETE       extract_signed_integer
// OBSOLETE       (scan->raw_cproc + CPROC_STATE_OFFSET, CPROC_STATE_SIZE);
// OBSOLETE 
// OBSOLETE       selected = ' ';
// OBSOLETE 
// OBSOLETE       /* a wired cproc? */
// OBSOLETE       wired = (extract_address (scan->raw_cproc + CPROC_WIRED_OFFSET,
// OBSOLETE 				CPROC_WIRED_SIZE)
// OBSOLETE 	       ? "wired" : "");
// OBSOLETE 
// OBSOLETE       if (scan->reverse_map != -1)
// OBSOLETE 	kthread = (their_threads + scan->reverse_map);
// OBSOLETE       else
// OBSOLETE 	kthread = NULL;
// OBSOLETE 
// OBSOLETE       if (kthread)
// OBSOLETE 	{
// OBSOLETE 	  /* These cprocs have a kernel thread */
// OBSOLETE 
// OBSOLETE 	  mid = map_port_name_to_mid (kthread->name, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE 	  infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE 
// OBSOLETE 	  ret = thread_info (kthread->name,
// OBSOLETE 			     THREAD_BASIC_INFO,
// OBSOLETE 			     (thread_info_t) & ths,
// OBSOLETE 			     &infoCnt);
// OBSOLETE 
// OBSOLETE 	  if (ret != KERN_SUCCESS)
// OBSOLETE 	    {
// OBSOLETE 	      warning ("Unable to get basic info on thread %d : %s",
// OBSOLETE 		       mid,
// OBSOLETE 		       mach_error_string (ret));
// OBSOLETE 	      continue;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  /* Who is the first to have more than 100 threads */
// OBSOLETE 	  sprintf (slot, "%d", kthread->slotid % 100);
// OBSOLETE 
// OBSOLETE 	  if (kthread->name == current_thread)
// OBSOLETE 	    selected = '*';
// OBSOLETE 
// OBSOLETE 	  if (ths.suspend_count)
// OBSOLETE 	    sprintf (buf, "%d", ths.suspend_count);
// OBSOLETE 	  else
// OBSOLETE 	    buf[0] = '\000';
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE 	  if (ths.flags & TH_FLAGS_SWAPPED)
// OBSOLETE 	    strcat (buf, "S");
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE 	  if (ths.flags & TH_FLAGS_IDLE)
// OBSOLETE 	    strcat (buf, "I");
// OBSOLETE 
// OBSOLETE 	  printf_filtered (TL_FORMAT,
// OBSOLETE 			   slot,
// OBSOLETE 			   mid,
// OBSOLETE 			   selected,
// OBSOLETE 			   get_thread_name (scan, kthread->slotid),
// OBSOLETE 			   kthread->in_emulator ? "E" : "",
// OBSOLETE 			   translate_state (ths.run_state),
// OBSOLETE 			   buf,
// OBSOLETE 			   translate_cstate (cproc_state),
// OBSOLETE 			   wired);
// OBSOLETE 	  print_tl_address (gdb_stdout, kthread->pc);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* These cprocs don't have a kernel thread.
// OBSOLETE 	   * find out the calling frame with 
// OBSOLETE 	   * FETCH_CPROC_STATE.
// OBSOLETE 	   */
// OBSOLETE 
// OBSOLETE 	  struct gdb_thread state;
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE 	  /* jtv -> emcmanus: why do you want this here? */
// OBSOLETE 	  if (scan->incarnation == NULL)
// OBSOLETE 	    continue;		/* EMcM */
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE 	  printf_filtered (TL_FORMAT,
// OBSOLETE 			   "-",
// OBSOLETE 			   -neworder,	/* Pseudo MID */
// OBSOLETE 			   selected,
// OBSOLETE 			   get_thread_name (scan, -neworder),
// OBSOLETE 			   "",
// OBSOLETE 			   "-",	/* kernel state */
// OBSOLETE 			   "",
// OBSOLETE 			   translate_cstate (cproc_state),
// OBSOLETE 			   "");
// OBSOLETE 	  state.cproc = scan;
// OBSOLETE 
// OBSOLETE 	  if (FETCH_CPROC_STATE (&state) == -1)
// OBSOLETE 	    puts_filtered ("???");
// OBSOLETE 	  else
// OBSOLETE 	    print_tl_address (gdb_stdout, state.pc);
// OBSOLETE 
// OBSOLETE 	  neworder++;
// OBSOLETE 	}
// OBSOLETE       puts_filtered ("\n");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Scan for kernel threads without cprocs */
// OBSOLETE   for (index = 0; index < thread_count; index++)
// OBSOLETE     {
// OBSOLETE       if (!their_threads[index].cproc)
// OBSOLETE 	{
// OBSOLETE 	  int mid;
// OBSOLETE 
// OBSOLETE 	  char buf[10];
// OBSOLETE 	  char slot[3];
// OBSOLETE 
// OBSOLETE 	  mach_port_t name = their_threads[index].name;
// OBSOLETE 
// OBSOLETE 	  mid = map_port_name_to_mid (name, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE 	  infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE 
// OBSOLETE 	  ret = thread_info (name,
// OBSOLETE 			     THREAD_BASIC_INFO,
// OBSOLETE 			     (thread_info_t) & ths,
// OBSOLETE 			     &infoCnt);
// OBSOLETE 
// OBSOLETE 	  if (ret != KERN_SUCCESS)
// OBSOLETE 	    {
// OBSOLETE 	      warning ("Unable to get basic info on thread %d : %s",
// OBSOLETE 		       mid,
// OBSOLETE 		       mach_error_string (ret));
// OBSOLETE 	      continue;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  sprintf (slot, "%d", index % 100);
// OBSOLETE 
// OBSOLETE 	  if (name == current_thread)
// OBSOLETE 	    selected = '*';
// OBSOLETE 	  else
// OBSOLETE 	    selected = ' ';
// OBSOLETE 
// OBSOLETE 	  if (ths.suspend_count)
// OBSOLETE 	    sprintf (buf, "%d", ths.suspend_count);
// OBSOLETE 	  else
// OBSOLETE 	    buf[0] = '\000';
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE 	  if (ths.flags & TH_FLAGS_SWAPPED)
// OBSOLETE 	    strcat (buf, "S");
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE 	  if (ths.flags & TH_FLAGS_IDLE)
// OBSOLETE 	    strcat (buf, "I");
// OBSOLETE 
// OBSOLETE 	  printf_filtered (TL_FORMAT,
// OBSOLETE 			   slot,
// OBSOLETE 			   mid,
// OBSOLETE 			   selected,
// OBSOLETE 			   get_thread_name (NULL, index),
// OBSOLETE 			   their_threads[index].in_emulator ? "E" : "",
// OBSOLETE 			   translate_state (ths.run_state),
// OBSOLETE 			   buf,
// OBSOLETE 			   "",	/* No cproc state */
// OBSOLETE 			   "");	/* Can't be wired */
// OBSOLETE 	  print_tl_address (gdb_stdout, their_threads[index].pc);
// OBSOLETE 	  puts_filtered ("\n");
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   obstack_free (cproc_obstack, 0);
// OBSOLETE   obstack_init (cproc_obstack);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE thread_select_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int mid;
// OBSOLETE   thread_array_t thread_list;
// OBSOLETE   int thread_count;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int is_slot = 0;
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     error_no_arg ("MID or @@SLOTNUMBER to specify a thread to select");
// OBSOLETE 
// OBSOLETE   while (*args == ' ' || *args == '\t')
// OBSOLETE     args++;
// OBSOLETE 
// OBSOLETE   if (*args == '@@')
// OBSOLETE     {
// OBSOLETE       is_slot++;
// OBSOLETE       args++;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   mid = atoi (args);
// OBSOLETE 
// OBSOLETE   if (mid == 0)
// OBSOLETE     if (!is_slot || *args != '0')	/* Rudimentary checks */
// OBSOLETE       error ("You must select threads by MID or @@SLOTNUMBER");
// OBSOLETE 
// OBSOLETE   if (select_thread (inferior_task, mid, is_slot ? 2 : 1) != KERN_SUCCESS)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   if (from_tty)
// OBSOLETE     printf_filtered ("Thread %d selected\n",
// OBSOLETE 		     is_slot ? map_port_name_to_mid (current_thread,
// OBSOLETE 						   MACH_TYPE_THREAD) : mid);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE thread_trace (mach_port_t thread, boolean_t set)
// OBSOLETE {
// OBSOLETE   int flavor = TRACE_FLAVOR;
// OBSOLETE   unsigned int stateCnt = TRACE_FLAVOR_SIZE;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_state_data_t state;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (thread))
// OBSOLETE     {
// OBSOLETE       warning ("thread_trace: invalid thread");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (must_suspend_thread)
// OBSOLETE     setup_thread (thread, 1);
// OBSOLETE 
// OBSOLETE   ret = thread_get_state (thread, flavor, state, &stateCnt);
// OBSOLETE   CHK ("thread_trace: error reading thread state", ret);
// OBSOLETE 
// OBSOLETE   if (set)
// OBSOLETE     {
// OBSOLETE       TRACE_SET (thread, state);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if (!TRACE_CLEAR (thread, state))
// OBSOLETE 	{
// OBSOLETE 	  if (must_suspend_thread)
// OBSOLETE 	    setup_thread (thread, 0);
// OBSOLETE 	  return;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = thread_set_state (thread, flavor, state, stateCnt);
// OBSOLETE   CHK ("thread_trace: error writing thread state", ret);
// OBSOLETE   if (must_suspend_thread)
// OBSOLETE     setup_thread (thread, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef	FLUSH_INFERIOR_CACHE
// OBSOLETE 
// OBSOLETE /* When over-writing code on some machines the I-Cache must be flushed
// OBSOLETE    explicitly, because it is not kept coherent by the lazy hardware.
// OBSOLETE    This definitely includes breakpoints, for instance, or else we
// OBSOLETE    end up looping in mysterious Bpt traps */
// OBSOLETE 
// OBSOLETE flush_inferior_icache (CORE_ADDR pc, int amount)
// OBSOLETE {
// OBSOLETE   vm_machine_attribute_val_t flush = MATTR_VAL_ICACHE_FLUSH;
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   ret = vm_machine_attribute (inferior_task,
// OBSOLETE 			      pc,
// OBSOLETE 			      amount,
// OBSOLETE 			      MATTR_CACHE,
// OBSOLETE 			      &flush);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("Error flushing inferior's cache : %s",
// OBSOLETE 	     mach_error_string (ret));
// OBSOLETE }
// OBSOLETE #endif /* FLUSH_INFERIOR_CACHE */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static
// OBSOLETE suspend_all_threads (int from_tty)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_array_t thread_list;
// OBSOLETE   int thread_count, index;
// OBSOLETE   int infoCnt;
// OBSOLETE   thread_basic_info_data_t th_info;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   ret = task_threads (inferior_task, &thread_list, &thread_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("Could not suspend inferior threads.");
// OBSOLETE       m3_kill_inferior ();
// OBSOLETE       throw_exception (RETURN_ERROR);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   for (index = 0; index < thread_count; index++)
// OBSOLETE     {
// OBSOLETE       int mid;
// OBSOLETE 
// OBSOLETE       mid = map_port_name_to_mid (thread_list[index],
// OBSOLETE 				  MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE       ret = thread_suspend (thread_list[index]);
// OBSOLETE 
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	warning ("Error trying to suspend thread %d : %s",
// OBSOLETE 		 mid, mach_error_string (ret));
// OBSOLETE 
// OBSOLETE       if (from_tty)
// OBSOLETE 	{
// OBSOLETE 	  infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE 	  ret = thread_info (thread_list[index],
// OBSOLETE 			     THREAD_BASIC_INFO,
// OBSOLETE 			     (thread_info_t) & th_info,
// OBSOLETE 			     &infoCnt);
// OBSOLETE 	  CHK ("suspend can't get thread info", ret);
// OBSOLETE 
// OBSOLETE 	  warning ("Thread %d suspend count is %d",
// OBSOLETE 		   mid, th_info.suspend_count);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   consume_send_rights (thread_list, thread_count);
// OBSOLETE   ret = vm_deallocate (mach_task_self (),
// OBSOLETE 		       (vm_address_t) thread_list,
// OBSOLETE 		       (thread_count * sizeof (int)));
// OBSOLETE   CHK ("Error trying to deallocate thread list", ret);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE thread_suspend_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int mid;
// OBSOLETE   mach_port_t saved_thread;
// OBSOLETE   int infoCnt;
// OBSOLETE   thread_basic_info_data_t th_info;
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   if (!strcasecmp (args, "all"))
// OBSOLETE     {
// OBSOLETE       suspend_all_threads (from_tty);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   saved_thread = current_thread;
// OBSOLETE 
// OBSOLETE   mid = parse_thread_id (args, 0, 0);
// OBSOLETE 
// OBSOLETE   if (mid < 0)
// OBSOLETE     error ("You can suspend only existing kernel threads with MID or @@SLOTNUMBER");
// OBSOLETE 
// OBSOLETE   if (mid == 0)
// OBSOLETE     mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
// OBSOLETE   else if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       if (current_thread)
// OBSOLETE 	current_thread = saved_thread;
// OBSOLETE       error ("Could not select thread %d", mid);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = thread_suspend (current_thread);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("thread_suspend failed : %s",
// OBSOLETE 	     mach_error_string (ret));
// OBSOLETE 
// OBSOLETE   infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE   ret = thread_info (current_thread,
// OBSOLETE 		     THREAD_BASIC_INFO,
// OBSOLETE 		     (thread_info_t) & th_info,
// OBSOLETE 		     &infoCnt);
// OBSOLETE   CHK ("suspend can't get thread info", ret);
// OBSOLETE 
// OBSOLETE   warning ("Thread %d suspend count is %d", mid, th_info.suspend_count);
// OBSOLETE 
// OBSOLETE   current_thread = saved_thread;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE resume_all_threads (int from_tty)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_array_t thread_list;
// OBSOLETE   int thread_count, index;
// OBSOLETE   int mid;
// OBSOLETE   int infoCnt;
// OBSOLETE   thread_basic_info_data_t th_info;
// OBSOLETE 
// OBSOLETE   ret = task_threads (inferior_task, &thread_list, &thread_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       m3_kill_inferior ();
// OBSOLETE       error ("task_threads", mach_error_string (ret));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   for (index = 0; index < thread_count; index++)
// OBSOLETE     {
// OBSOLETE       infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE       ret = thread_info (thread_list[index],
// OBSOLETE 			 THREAD_BASIC_INFO,
// OBSOLETE 			 (thread_info_t) & th_info,
// OBSOLETE 			 &infoCnt);
// OBSOLETE       CHK ("resume_all can't get thread info", ret);
// OBSOLETE 
// OBSOLETE       mid = map_port_name_to_mid (thread_list[index],
// OBSOLETE 				  MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE       if (!th_info.suspend_count)
// OBSOLETE 	{
// OBSOLETE 	  if (mid != -1 && from_tty)
// OBSOLETE 	    warning ("Thread %d is not suspended", mid);
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       ret = thread_resume (thread_list[index]);
// OBSOLETE 
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	warning ("Error trying to resume thread %d : %s",
// OBSOLETE 		 mid, mach_error_string (ret));
// OBSOLETE       else if (mid != -1 && from_tty)
// OBSOLETE 	warning ("Thread %d suspend count is %d",
// OBSOLETE 		 mid, --th_info.suspend_count);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   consume_send_rights (thread_list, thread_count);
// OBSOLETE   ret = vm_deallocate (mach_task_self (),
// OBSOLETE 		       (vm_address_t) thread_list,
// OBSOLETE 		       (thread_count * sizeof (int)));
// OBSOLETE   CHK ("Error trying to deallocate thread list", ret);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE thread_resume_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int mid;
// OBSOLETE   mach_port_t saved_thread;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_basic_info_data_t th_info;
// OBSOLETE   int infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   if (!strcasecmp (args, "all"))
// OBSOLETE     {
// OBSOLETE       resume_all_threads (from_tty);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   saved_thread = current_thread;
// OBSOLETE 
// OBSOLETE   mid = parse_thread_id (args, 0, 0);
// OBSOLETE 
// OBSOLETE   if (mid < 0)
// OBSOLETE     error ("You can resume only existing kernel threads with MID or @@SLOTNUMBER");
// OBSOLETE 
// OBSOLETE   if (mid == 0)
// OBSOLETE     mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
// OBSOLETE   else if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       if (current_thread)
// OBSOLETE 	current_thread = saved_thread;
// OBSOLETE       throw_exception (RETURN_ERROR);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = thread_info (current_thread,
// OBSOLETE 		     THREAD_BASIC_INFO,
// OBSOLETE 		     (thread_info_t) & th_info,
// OBSOLETE 		     &infoCnt);
// OBSOLETE   CHK ("resume can't get thread info", ret);
// OBSOLETE 
// OBSOLETE   if (!th_info.suspend_count)
// OBSOLETE     {
// OBSOLETE       warning ("Thread %d is not suspended", mid);
// OBSOLETE       goto out;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = thread_resume (current_thread);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("thread_resume failed : %s",
// OBSOLETE 	     mach_error_string (ret));
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       th_info.suspend_count--;
// OBSOLETE       warning ("Thread %d suspend count is %d", mid, th_info.suspend_count);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE out:
// OBSOLETE   current_thread = saved_thread;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE thread_kill_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int mid;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int thread_count;
// OBSOLETE   thread_array_t thread_table;
// OBSOLETE   int index;
// OBSOLETE   mach_port_t thread_to_kill = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     error_no_arg ("thread mid to kill from the inferior task");
// OBSOLETE 
// OBSOLETE   mid = parse_thread_id (args, 0, 0);
// OBSOLETE 
// OBSOLETE   if (mid < 0)
// OBSOLETE     error ("You can kill only existing kernel threads with MID or @@SLOTNUMBER");
// OBSOLETE 
// OBSOLETE   if (mid)
// OBSOLETE     {
// OBSOLETE       ret = machid_mach_port (mid_server, mid_auth, mid, &thread_to_kill);
// OBSOLETE       CHK ("thread_kill_command: machid_mach_port map failed", ret);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE   /* Don't allow gdb to kill *any* thread in the system. Use mkill program for that */
// OBSOLETE   ret = task_threads (inferior_task, &thread_table, &thread_count);
// OBSOLETE   CHK ("Error getting inferior's thread list", ret);
// OBSOLETE 
// OBSOLETE   if (thread_to_kill == current_thread)
// OBSOLETE     {
// OBSOLETE       ret = thread_terminate (thread_to_kill);
// OBSOLETE       CHK ("Thread could not be terminated", ret);
// OBSOLETE 
// OBSOLETE       if (select_thread (inferior_task, 0, 1) != KERN_SUCCESS)
// OBSOLETE 	warning ("Last thread was killed, use \"kill\" command to kill task");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     for (index = 0; index < thread_count; index++)
// OBSOLETE       if (thread_table[index] == thread_to_kill)
// OBSOLETE 	{
// OBSOLETE 	  ret = thread_terminate (thread_to_kill);
// OBSOLETE 	  CHK ("Thread could not be terminated", ret);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE   if (thread_count > 1)
// OBSOLETE     consume_send_rights (thread_table, thread_count);
// OBSOLETE 
// OBSOLETE   ret = vm_deallocate (mach_task_self (), (vm_address_t) thread_table,
// OBSOLETE 		       (thread_count * sizeof (mach_port_t)));
// OBSOLETE   CHK ("Error trying to deallocate thread list", ret);
// OBSOLETE 
// OBSOLETE   warning ("Thread %d killed", mid);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Task specific commands; add more if you like */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE task_resume_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   task_basic_info_data_t ta_info;
// OBSOLETE   int infoCnt = TASK_BASIC_INFO_COUNT;
// OBSOLETE   int mid = map_port_name_to_mid (inferior_task, MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   /* Would be trivial to change, but is it desirable? */
// OBSOLETE   if (args)
// OBSOLETE     error ("Currently gdb can resume only it's inferior task");
// OBSOLETE 
// OBSOLETE   ret = task_info (inferior_task,
// OBSOLETE 		   TASK_BASIC_INFO,
// OBSOLETE 		   (task_info_t) & ta_info,
// OBSOLETE 		   &infoCnt);
// OBSOLETE   CHK ("task_resume_command: task_info failed", ret);
// OBSOLETE 
// OBSOLETE   if (ta_info.suspend_count == 0)
// OBSOLETE     error ("Inferior task %d is not suspended", mid);
// OBSOLETE   else if (ta_info.suspend_count == 1 &&
// OBSOLETE 	   from_tty &&
// OBSOLETE 	!query ("Suspend count is now 1. Do you know what you are doing? "))
// OBSOLETE     error ("Task not resumed");
// OBSOLETE 
// OBSOLETE   ret = task_resume (inferior_task);
// OBSOLETE   CHK ("task_resume_command: task_resume", ret);
// OBSOLETE 
// OBSOLETE   if (ta_info.suspend_count == 1)
// OBSOLETE     {
// OBSOLETE       warning ("Inferior task %d is no longer suspended", mid);
// OBSOLETE       must_suspend_thread = 1;
// OBSOLETE       /* @@@@ This is not complete: Registers change all the time when not
// OBSOLETE          suspended! */
// OBSOLETE       registers_changed ();
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     warning ("Inferior task %d suspend count is now %d",
// OBSOLETE 	     mid, ta_info.suspend_count - 1);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE void
// OBSOLETE task_suspend_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   task_basic_info_data_t ta_info;
// OBSOLETE   int infoCnt = TASK_BASIC_INFO_COUNT;
// OBSOLETE   int mid = map_port_name_to_mid (inferior_task, MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   /* Would be trivial to change, but is it desirable? */
// OBSOLETE   if (args)
// OBSOLETE     error ("Currently gdb can suspend only it's inferior task");
// OBSOLETE 
// OBSOLETE   ret = task_suspend (inferior_task);
// OBSOLETE   CHK ("task_suspend_command: task_suspend", ret);
// OBSOLETE 
// OBSOLETE   must_suspend_thread = 0;
// OBSOLETE 
// OBSOLETE   ret = task_info (inferior_task,
// OBSOLETE 		   TASK_BASIC_INFO,
// OBSOLETE 		   (task_info_t) & ta_info,
// OBSOLETE 		   &infoCnt);
// OBSOLETE   CHK ("task_suspend_command: task_info failed", ret);
// OBSOLETE 
// OBSOLETE   warning ("Inferior task %d suspend count is now %d",
// OBSOLETE 	   mid, ta_info.suspend_count);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE get_size (int bytes)
// OBSOLETE {
// OBSOLETE   static char size[30];
// OBSOLETE   int zz = bytes / 1024;
// OBSOLETE 
// OBSOLETE   if (zz / 1024)
// OBSOLETE     sprintf (size, "%-2.1f M", ((float) bytes) / (1024.0 * 1024.0));
// OBSOLETE   else
// OBSOLETE     sprintf (size, "%d K", zz);
// OBSOLETE 
// OBSOLETE   return size;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Does this require the target task to be suspended?? I don't think so. */
// OBSOLETE void
// OBSOLETE task_info_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int mid = -5;
// OBSOLETE   mach_port_t task;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   task_basic_info_data_t ta_info;
// OBSOLETE   int infoCnt = TASK_BASIC_INFO_COUNT;
// OBSOLETE   int page_size = round_page (1);
// OBSOLETE   int thread_count = 0;
// OBSOLETE 
// OBSOLETE   if (MACH_PORT_VALID (inferior_task))
// OBSOLETE     mid = map_port_name_to_mid (inferior_task,
// OBSOLETE 				MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   task = inferior_task;
// OBSOLETE 
// OBSOLETE   if (args)
// OBSOLETE     {
// OBSOLETE       int tmid = atoi (args);
// OBSOLETE 
// OBSOLETE       if (tmid <= 0)
// OBSOLETE 	error ("Invalid mid %d for task info", tmid);
// OBSOLETE 
// OBSOLETE       if (tmid != mid)
// OBSOLETE 	{
// OBSOLETE 	  mid = tmid;
// OBSOLETE 	  ret = machid_mach_port (mid_server, mid_auth, tmid, &task);
// OBSOLETE 	  CHK ("task_info_command: machid_mach_port map failed", ret);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (mid < 0)
// OBSOLETE     error ("You have to give the task MID as an argument");
// OBSOLETE 
// OBSOLETE   ret = task_info (task,
// OBSOLETE 		   TASK_BASIC_INFO,
// OBSOLETE 		   (task_info_t) & ta_info,
// OBSOLETE 		   &infoCnt);
// OBSOLETE   CHK ("task_info_command: task_info failed", ret);
// OBSOLETE 
// OBSOLETE   printf_filtered ("\nTask info for task %d:\n\n", mid);
// OBSOLETE   printf_filtered (" Suspend count : %d\n", ta_info.suspend_count);
// OBSOLETE   printf_filtered (" Base priority : %d\n", ta_info.base_priority);
// OBSOLETE   printf_filtered (" Virtual size  : %s\n", get_size (ta_info.virtual_size));
// OBSOLETE   printf_filtered (" Resident size : %s\n", get_size (ta_info.resident_size));
// OBSOLETE 
// OBSOLETE   {
// OBSOLETE     thread_array_t thread_list;
// OBSOLETE 
// OBSOLETE     ret = task_threads (task, &thread_list, &thread_count);
// OBSOLETE     CHK ("task_info_command: task_threads", ret);
// OBSOLETE 
// OBSOLETE     printf_filtered (" Thread count  : %d\n", thread_count);
// OBSOLETE 
// OBSOLETE     consume_send_rights (thread_list, thread_count);
// OBSOLETE     ret = vm_deallocate (mach_task_self (),
// OBSOLETE 			 (vm_address_t) thread_list,
// OBSOLETE 			 (thread_count * sizeof (int)));
// OBSOLETE     CHK ("Error trying to deallocate thread list", ret);
// OBSOLETE   }
// OBSOLETE   if (have_emulator_p (task))
// OBSOLETE     printf_filtered (" Emulator at   : 0x%x..0x%x\n",
// OBSOLETE 		     EMULATOR_BASE, EMULATOR_END);
// OBSOLETE   else
// OBSOLETE     printf_filtered (" No emulator.\n");
// OBSOLETE 
// OBSOLETE   if (thread_count && task == inferior_task)
// OBSOLETE     printf_filtered ("\nUse the \"thread list\" command to see the threads\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* You may either FORWARD the exception to the inferior, or KEEP
// OBSOLETE  * it and return to GDB command level.
// OBSOLETE  *
// OBSOLETE  * exception mid [ forward | keep ]
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE exception_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   char *scan = args;
// OBSOLETE   int exception;
// OBSOLETE   int len;
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     error_no_arg ("exception number action");
// OBSOLETE 
// OBSOLETE   while (*scan == ' ' || *scan == '\t')
// OBSOLETE     scan++;
// OBSOLETE 
// OBSOLETE   if ('0' <= *scan && *scan <= '9')
// OBSOLETE     while ('0' <= *scan && *scan <= '9')
// OBSOLETE       scan++;
// OBSOLETE   else
// OBSOLETE     error ("exception number action");
// OBSOLETE 
// OBSOLETE   exception = atoi (args);
// OBSOLETE   if (exception <= 0 || exception > MAX_EXCEPTION)
// OBSOLETE     error ("Allowed exception numbers are in range 1..%d",
// OBSOLETE 	   MAX_EXCEPTION);
// OBSOLETE 
// OBSOLETE   if (*scan != ' ' && *scan != '\t')
// OBSOLETE     error ("exception number must be followed by a space");
// OBSOLETE   else
// OBSOLETE     while (*scan == ' ' || *scan == '\t')
// OBSOLETE       scan++;
// OBSOLETE 
// OBSOLETE   args = scan;
// OBSOLETE   len = 0;
// OBSOLETE   while (*scan)
// OBSOLETE     {
// OBSOLETE       len++;
// OBSOLETE       scan++;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!len)
// OBSOLETE     error ("exception number action");
// OBSOLETE 
// OBSOLETE   if (!strncasecmp (args, "forward", len))
// OBSOLETE     exception_map[exception].forward = TRUE;
// OBSOLETE   else if (!strncasecmp (args, "keep", len))
// OBSOLETE     exception_map[exception].forward = FALSE;
// OBSOLETE   else
// OBSOLETE     error ("exception action is either \"keep\" or \"forward\"");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE print_exception_info (int exception)
// OBSOLETE {
// OBSOLETE   boolean_t forward = exception_map[exception].forward;
// OBSOLETE 
// OBSOLETE   printf_filtered ("%s\t(%d): ", exception_map[exception].name,
// OBSOLETE 		   exception);
// OBSOLETE   if (!forward)
// OBSOLETE     if (exception_map[exception].sigmap != SIG_UNKNOWN)
// OBSOLETE       printf_filtered ("keep and handle as signal %d\n",
// OBSOLETE 		       exception_map[exception].sigmap);
// OBSOLETE     else
// OBSOLETE       printf_filtered ("keep and handle as unknown signal %d\n",
// OBSOLETE 		       exception_map[exception].sigmap);
// OBSOLETE   else
// OBSOLETE     printf_filtered ("forward exception to inferior\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE exception_info (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int exception;
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     for (exception = 1; exception <= MAX_EXCEPTION; exception++)
// OBSOLETE       print_exception_info (exception);
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       exception = atoi (args);
// OBSOLETE 
// OBSOLETE       if (exception <= 0 || exception > MAX_EXCEPTION)
// OBSOLETE 	error ("Invalid exception number, values from 1 to %d allowed",
// OBSOLETE 	       MAX_EXCEPTION);
// OBSOLETE       print_exception_info (exception);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Check for actions for mach exceptions.
// OBSOLETE  */
// OBSOLETE mach3_exception_actions (WAITTYPE *w, boolean_t force_print_only, char *who)
// OBSOLETE {
// OBSOLETE   boolean_t force_print = FALSE;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   if (force_print_only ||
// OBSOLETE       exception_map[stop_exception].sigmap == SIG_UNKNOWN)
// OBSOLETE     force_print = TRUE;
// OBSOLETE   else
// OBSOLETE     WSETSTOP (*w, exception_map[stop_exception].sigmap);
// OBSOLETE 
// OBSOLETE   if (exception_map[stop_exception].print || force_print)
// OBSOLETE     {
// OBSOLETE       target_terminal_ours ();
// OBSOLETE 
// OBSOLETE       printf_filtered ("\n%s received %s exception : ",
// OBSOLETE 		       who,
// OBSOLETE 		       exception_map[stop_exception].name);
// OBSOLETE 
// OBSOLETE       wrap_here ("   ");
// OBSOLETE 
// OBSOLETE       switch (stop_exception)
// OBSOLETE 	{
// OBSOLETE 	case EXC_BAD_ACCESS:
// OBSOLETE 	  printf_filtered ("referencing address 0x%x : %s\n",
// OBSOLETE 			   stop_subcode,
// OBSOLETE 			   mach_error_string (stop_code));
// OBSOLETE 	  break;
// OBSOLETE 	case EXC_BAD_INSTRUCTION:
// OBSOLETE 	  printf_filtered
// OBSOLETE 	    ("illegal or undefined instruction. code %d subcode %d\n",
// OBSOLETE 	     stop_code, stop_subcode);
// OBSOLETE 	  break;
// OBSOLETE 	case EXC_ARITHMETIC:
// OBSOLETE 	  printf_filtered ("code %d\n", stop_code);
// OBSOLETE 	  break;
// OBSOLETE 	case EXC_EMULATION:
// OBSOLETE 	  printf_filtered ("code %d subcode %d\n", stop_code, stop_subcode);
// OBSOLETE 	  break;
// OBSOLETE 	case EXC_SOFTWARE:
// OBSOLETE 	  printf_filtered ("%s specific, code 0x%x\n",
// OBSOLETE 			   stop_code < 0xffff ? "hardware" : "os emulation",
// OBSOLETE 			   stop_code);
// OBSOLETE 	  break;
// OBSOLETE 	case EXC_BREAKPOINT:
// OBSOLETE 	  printf_filtered ("type %d (machine dependent)\n",
// OBSOLETE 			   stop_code);
// OBSOLETE 	  break;
// OBSOLETE 	default:
// OBSOLETE 	  internal_error (__FILE__, __LINE__,
// OBSOLETE 			  "Unknown exception");
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE setup_notify_port (int create_new)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (MACH_PORT_VALID (our_notify_port))
// OBSOLETE     {
// OBSOLETE       ret = mach_port_destroy (mach_task_self (), our_notify_port);
// OBSOLETE       CHK ("Could not destroy our_notify_port", ret);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   our_notify_port = MACH_PORT_NULL;
// OBSOLETE   notify_chain = (port_chain_t) NULL;
// OBSOLETE   port_chain_destroy (port_chain_obstack);
// OBSOLETE 
// OBSOLETE   if (create_new)
// OBSOLETE     {
// OBSOLETE       ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 				MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 				&our_notify_port);
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	internal_error (__FILE__, __LINE__,
// OBSOLETE 			"Creating notify port %s", mach_error_string (ret));
// OBSOLETE 
// OBSOLETE       ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 				   our_notify_port,
// OBSOLETE 				   inferior_wait_port_set);
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	internal_error (__FILE__, __LINE__,
// OBSOLETE 			"initial move member %s", mach_error_string (ret));
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Register our message port to the net name server
// OBSOLETE  *
// OBSOLETE  * Currently used only by the external stop-gdb program
// OBSOLETE  * since ^C does not work if you would like to enter
// OBSOLETE  * gdb command level while debugging your program.
// OBSOLETE  *
// OBSOLETE  * NOTE: If the message port is sometimes used for other
// OBSOLETE  * purposes also, the NAME must not be a guessable one.
// OBSOLETE  * Then, there should be a way to change it.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE char registered_name[MAX_NAME_LEN];
// OBSOLETE 
// OBSOLETE void
// OBSOLETE message_port_info (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   if (registered_name[0])
// OBSOLETE     printf_filtered ("gdb's message port name: '%s'\n",
// OBSOLETE 		     registered_name);
// OBSOLETE   else
// OBSOLETE     printf_filtered ("gdb's message port is not currently registered\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE gdb_register_port (char *name, mach_port_t port)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   static int already_signed = 0;
// OBSOLETE   int len;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (port) || !name || !*name)
// OBSOLETE     {
// OBSOLETE       warning ("Invalid registration request");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!already_signed)
// OBSOLETE     {
// OBSOLETE       ret = mach_port_insert_right (mach_task_self (),
// OBSOLETE 				    our_message_port,
// OBSOLETE 				    our_message_port,
// OBSOLETE 				    MACH_MSG_TYPE_MAKE_SEND);
// OBSOLETE       CHK ("Failed to create a signature to our_message_port", ret);
// OBSOLETE       already_signed = 1;
// OBSOLETE     }
// OBSOLETE   else if (already_signed > 1)
// OBSOLETE     {
// OBSOLETE       ret = netname_check_out (name_server_port,
// OBSOLETE 			       registered_name,
// OBSOLETE 			       our_message_port);
// OBSOLETE       CHK ("Failed to check out gdb's message port", ret);
// OBSOLETE       registered_name[0] = '\000';
// OBSOLETE       already_signed = 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = netname_check_in (name_server_port,	/* Name server port */
// OBSOLETE 			  name,	/* Name of service */
// OBSOLETE 			  our_message_port,	/* Signature */
// OBSOLETE 			  port);	/* Creates a new send right */
// OBSOLETE   CHK ("Failed to check in the port", ret);
// OBSOLETE 
// OBSOLETE   len = 0;
// OBSOLETE   while (len < MAX_NAME_LEN && *(name + len))
// OBSOLETE     {
// OBSOLETE       registered_name[len] = *(name + len);
// OBSOLETE       len++;
// OBSOLETE     }
// OBSOLETE   registered_name[len] = '\000';
// OBSOLETE   already_signed = 2;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE struct cmd_list_element *cmd_thread_list;
// OBSOLETE struct cmd_list_element *cmd_task_list;
// OBSOLETE 
// OBSOLETE /*ARGSUSED */
// OBSOLETE static void
// OBSOLETE thread_command (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   printf_unfiltered ("\"thread\" must be followed by the name of a thread command.\n");
// OBSOLETE   help_list (cmd_thread_list, "thread ", -1, gdb_stdout);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*ARGSUSED */
// OBSOLETE static void
// OBSOLETE task_command (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   printf_unfiltered ("\"task\" must be followed by the name of a task command.\n");
// OBSOLETE   help_list (cmd_task_list, "task ", -1, gdb_stdout);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE add_mach_specific_commands (void)
// OBSOLETE {
// OBSOLETE   /* Thread handling commands */
// OBSOLETE 
// OBSOLETE   /* FIXME: Move our thread support into the generic thread.c stuff so we
// OBSOLETE      can share that code.  */
// OBSOLETE   add_prefix_cmd ("mthread", class_stack, thread_command,
// OBSOLETE 	  "Generic command for handling Mach threads in the debugged task.",
// OBSOLETE 		  &cmd_thread_list, "thread ", 0, &cmdlist);
// OBSOLETE 
// OBSOLETE   add_com_alias ("th", "mthread", class_stack, 1);
// OBSOLETE 
// OBSOLETE   add_cmd ("select", class_stack, thread_select_command,
// OBSOLETE 	   "Select and print MID of the selected thread",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE   add_cmd ("list", class_stack, thread_list_command,
// OBSOLETE 	   "List info of task's threads. Selected thread is marked with '*'",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE   add_cmd ("suspend", class_run, thread_suspend_command,
// OBSOLETE 	   "Suspend one or all of the threads in the selected task.",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE   add_cmd ("resume", class_run, thread_resume_command,
// OBSOLETE 	   "Resume one or all of the threads in the selected task.",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE   add_cmd ("kill", class_run, thread_kill_command,
// OBSOLETE 	   "Kill the specified thread MID from inferior task.",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE #if 0
// OBSOLETE   /* The rest of this support (condition_thread) was not merged.  It probably
// OBSOLETE      should not be merged in this form, but instead added to the generic GDB
// OBSOLETE      thread support.  */
// OBSOLETE   add_cmd ("break", class_breakpoint, condition_thread,
// OBSOLETE 	   "Breakpoint N will only be effective for thread MID or @@SLOT\n\
// OBSOLETE 	    If MID/@@SLOT is omitted allow all threads to break at breakpoint",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE #endif
// OBSOLETE   /* Thread command shorthands (for backward compatibility) */
// OBSOLETE   add_alias_cmd ("ts", "mthread select", 0, 0, &cmdlist);
// OBSOLETE   add_alias_cmd ("tl", "mthread list", 0, 0, &cmdlist);
// OBSOLETE 
// OBSOLETE   /* task handling commands */
// OBSOLETE 
// OBSOLETE   add_prefix_cmd ("task", class_stack, task_command,
// OBSOLETE 		  "Generic command for handling debugged task.",
// OBSOLETE 		  &cmd_task_list, "task ", 0, &cmdlist);
// OBSOLETE 
// OBSOLETE   add_com_alias ("ta", "task", class_stack, 1);
// OBSOLETE 
// OBSOLETE   add_cmd ("suspend", class_run, task_suspend_command,
// OBSOLETE 	   "Suspend the inferior task.",
// OBSOLETE 	   &cmd_task_list);
// OBSOLETE   add_cmd ("resume", class_run, task_resume_command,
// OBSOLETE 	   "Resume the inferior task.",
// OBSOLETE 	   &cmd_task_list);
// OBSOLETE   add_cmd ("info", no_class, task_info_command,
// OBSOLETE 	   "Print information about the specified task.",
// OBSOLETE 	   &cmd_task_list);
// OBSOLETE 
// OBSOLETE   /* Print my message port name */
// OBSOLETE 
// OBSOLETE   add_info ("message-port", message_port_info,
// OBSOLETE 	    "Returns the name of gdb's message port in the netnameserver");
// OBSOLETE 
// OBSOLETE   /* Exception commands */
// OBSOLETE 
// OBSOLETE   add_info ("exceptions", exception_info,
// OBSOLETE 	    "What debugger does when program gets various exceptions.\n\
// OBSOLETE Specify an exception number as argument to print info on that\n\
// OBSOLETE exception only.");
// OBSOLETE 
// OBSOLETE   add_com ("exception", class_run, exception_command,
// OBSOLETE 	   "Specify how to handle an exception.\n\
// OBSOLETE Args are exception number followed by \"forward\" or \"keep\".\n\
// OBSOLETE `Forward' means forward the exception to the program's normal exception\n\
// OBSOLETE handler.\n\
// OBSOLETE `Keep' means reenter debugger if this exception happens, and GDB maps\n\
// OBSOLETE the exception to some signal (see info exception)\n\
// OBSOLETE Normally \"keep\" is used to return to GDB on exception.");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_dead_name (mach_port_t notify, mach_port_t name)
// OBSOLETE {
// OBSOLETE   kern_return_t kr = KERN_SUCCESS;
// OBSOLETE 
// OBSOLETE   /* Find the thing that notified */
// OBSOLETE   port_chain_t element = port_chain_member (notify_chain, name);
// OBSOLETE 
// OBSOLETE   /* Take name of from unreceived dead name notification list */
// OBSOLETE   notify_chain = port_chain_delete (notify_chain, name);
// OBSOLETE 
// OBSOLETE   if (!element)
// OBSOLETE     error ("Received a dead name notify from unchained port (0x%x)", name);
// OBSOLETE 
// OBSOLETE   switch (element->type)
// OBSOLETE     {
// OBSOLETE 
// OBSOLETE     case MACH_TYPE_THREAD:
// OBSOLETE       target_terminal_ours_for_output ();
// OBSOLETE       if (name == current_thread)
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered ("\nCurrent thread %d died", element->mid);
// OBSOLETE 	  current_thread = MACH_PORT_NULL;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	printf_filtered ("\nThread %d died", element->mid);
// OBSOLETE 
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case MACH_TYPE_TASK:
// OBSOLETE       target_terminal_ours_for_output ();
// OBSOLETE       if (name != inferior_task)
// OBSOLETE 	printf_filtered ("Task %d died, but it was not the selected task",
// OBSOLETE 			 element->mid);
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered ("Current task %d died", element->mid);
// OBSOLETE 
// OBSOLETE 	  mach_port_destroy (mach_task_self (), name);
// OBSOLETE 	  inferior_task = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE 	  if (notify_chain)
// OBSOLETE 	    warning ("There were still unreceived dead_name_notifications???");
// OBSOLETE 
// OBSOLETE 	  /* Destroy the old notifications */
// OBSOLETE 	  setup_notify_port (0);
// OBSOLETE 
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     default:
// OBSOLETE       error ("Unregistered dead_name 0x%x notification received. Type is %d, mid is 0x%x",
// OBSOLETE 	     name, element->type, element->mid);
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_msg_accepted (mach_port_t notify, mach_port_t name)
// OBSOLETE {
// OBSOLETE   warning ("do_mach_notify_msg_accepted : notify %x, name %x",
// OBSOLETE 	   notify, name);
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_no_senders (mach_port_t notify, mach_port_mscount_t mscount)
// OBSOLETE {
// OBSOLETE   warning ("do_mach_notify_no_senders : notify %x, mscount %x",
// OBSOLETE 	   notify, mscount);
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_port_deleted (mach_port_t notify, mach_port_t name)
// OBSOLETE {
// OBSOLETE   warning ("do_mach_notify_port_deleted : notify %x, name %x",
// OBSOLETE 	   notify, name);
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_port_destroyed (mach_port_t notify, mach_port_t rights)
// OBSOLETE {
// OBSOLETE   warning ("do_mach_notify_port_destroyed : notify %x, rights %x",
// OBSOLETE 	   notify, rights);
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_send_once (mach_port_t notify)
// OBSOLETE {
// OBSOLETE #ifdef DUMP_SYSCALL
// OBSOLETE   /* MANY of these are generated. */
// OBSOLETE   warning ("do_mach_notify_send_once : notify %x",
// OBSOLETE 	   notify);
// OBSOLETE #endif
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Kills the inferior. It's gone when you call this */
// OBSOLETE static void
// OBSOLETE kill_inferior_fast (void)
// OBSOLETE {
// OBSOLETE   WAITTYPE w;
// OBSOLETE 
// OBSOLETE   if (PIDGET (inferior_ptid) == 0 || PIDGET (inferior_ptid) == 1)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   /* kill() it, since the Unix server does not otherwise notice when
// OBSOLETE    * killed with task_terminate().
// OBSOLETE    */
// OBSOLETE   if (PIDGET (inferior_ptid) > 0)
// OBSOLETE     kill (PIDGET (inferior_ptid), SIGKILL);
// OBSOLETE 
// OBSOLETE   /* It's propably terminate already */
// OBSOLETE   (void) task_terminate (inferior_task);
// OBSOLETE 
// OBSOLETE   inferior_task = MACH_PORT_NULL;
// OBSOLETE   current_thread = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE   wait3 (&w, WNOHANG, 0);
// OBSOLETE 
// OBSOLETE   setup_notify_port (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_kill_inferior (void)
// OBSOLETE {
// OBSOLETE   kill_inferior_fast ();
// OBSOLETE   target_mourn_inferior ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Clean up after the inferior dies.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_mourn_inferior (void)
// OBSOLETE {
// OBSOLETE   unpush_target (&m3_ops);
// OBSOLETE   generic_mourn_inferior ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Fork an inferior process, and start debugging it.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_create_inferior (char *exec_file, char *allargs, char **env)
// OBSOLETE {
// OBSOLETE   fork_inferior (exec_file, allargs, env, m3_trace_me, m3_trace_him, NULL, NULL);
// OBSOLETE   /* We are at the first instruction we care about.  */
// OBSOLETE   /* Pedal to the metal... */
// OBSOLETE   proceed ((CORE_ADDR) -1, 0, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Mark our target-struct as eligible for stray "run" and "attach"
// OBSOLETE    commands.  */
// OBSOLETE static int
// OBSOLETE m3_can_run (void)
// OBSOLETE {
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Mach 3.0 does not need ptrace for anything
// OBSOLETE  * Make sure nobody uses it on mach.
// OBSOLETE  */
// OBSOLETE ptrace (int a, int b, int c, int d)
// OBSOLETE {
// OBSOLETE   error ("Lose, Lose! Somebody called ptrace\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Resume execution of the inferior process.
// OBSOLETE    If STEP is nonzero, single-step it.
// OBSOLETE    If SIGNAL is nonzero, give it that signal.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m3_resume (ptid_t ptid, int step, enum target_signal signal)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (step)
// OBSOLETE     {
// OBSOLETE       thread_basic_info_data_t th_info;
// OBSOLETE       unsigned int infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE 
// OBSOLETE       /* There is no point in single stepping when current_thread
// OBSOLETE        * is dead.
// OBSOLETE        */
// OBSOLETE       if (!MACH_PORT_VALID (current_thread))
// OBSOLETE 	error ("No thread selected; can not single step");
// OBSOLETE 
// OBSOLETE       /* If current_thread is suspended, tracing it would never return.
// OBSOLETE        */
// OBSOLETE       ret = thread_info (current_thread,
// OBSOLETE 			 THREAD_BASIC_INFO,
// OBSOLETE 			 (thread_info_t) & th_info,
// OBSOLETE 			 &infoCnt);
// OBSOLETE       CHK ("child_resume: can't get thread info", ret);
// OBSOLETE 
// OBSOLETE       if (th_info.suspend_count)
// OBSOLETE 	error ("Can't trace a suspended thread. Use \"thread resume\" command to resume it");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   vm_read_cache_valid = FALSE;
// OBSOLETE 
// OBSOLETE   if (signal && PIDGET (inferior_ptid) > 0)	/* Do not signal, if attached by MID */
// OBSOLETE     kill (PIDGET (inferior_ptid), target_signal_to_host (signal));
// OBSOLETE 
// OBSOLETE   if (step)
// OBSOLETE     {
// OBSOLETE       suspend_all_threads (0);
// OBSOLETE 
// OBSOLETE       setup_single_step (current_thread, TRUE);
// OBSOLETE 
// OBSOLETE       ret = thread_resume (current_thread);
// OBSOLETE       CHK ("thread_resume", ret);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = task_resume (inferior_task);
// OBSOLETE   if (ret == KERN_FAILURE)
// OBSOLETE     warning ("Task was not suspended");
// OBSOLETE   else
// OBSOLETE     CHK ("Resuming task", ret);
// OBSOLETE 
// OBSOLETE   /* HACK HACK This is needed by the multiserver system HACK HACK */
// OBSOLETE   while ((ret = task_resume (inferior_task)) == KERN_SUCCESS)
// OBSOLETE     /* make sure it really runs */ ;
// OBSOLETE   /* HACK HACK This is needed by the multiserver system HACK HACK */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef ATTACH_DETACH
// OBSOLETE 
// OBSOLETE /* Start debugging the process with the given task */
// OBSOLETE void
// OBSOLETE task_attach (task_t tid)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   inferior_task = tid;
// OBSOLETE 
// OBSOLETE   ret = task_suspend (inferior_task);
// OBSOLETE   CHK ("task_attach: task_suspend", ret);
// OBSOLETE 
// OBSOLETE   must_suspend_thread = 0;
// OBSOLETE 
// OBSOLETE   setup_notify_port (1);
// OBSOLETE 
// OBSOLETE   request_notify (inferior_task, MACH_NOTIFY_DEAD_NAME, MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   setup_exception_port ();
// OBSOLETE 
// OBSOLETE   emulator_present = have_emulator_p (inferior_task);
// OBSOLETE 
// OBSOLETE   attach_flag = 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Well, we can call error also here and leave the
// OBSOLETE  * target stack inconsistent. Sigh.
// OBSOLETE  * Fix this sometime (the only way to fail here is that
// OBSOLETE  * the task has no threads at all, which is rare, but
// OBSOLETE  * possible; or if the target task has died, which is also
// OBSOLETE  * possible, but unlikely, since it has been suspended.
// OBSOLETE  * (Someone must have killed it))
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE attach_to_thread (void)
// OBSOLETE {
// OBSOLETE   if (select_thread (inferior_task, 0, 1) != KERN_SUCCESS)
// OBSOLETE     error ("Could not select any threads to attach to");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE mid_attach (int mid)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   ret = machid_mach_port (mid_server, mid_auth, mid, &inferior_task);
// OBSOLETE   CHK ("mid_attach: machid_mach_port", ret);
// OBSOLETE 
// OBSOLETE   task_attach (inferior_task);
// OBSOLETE 
// OBSOLETE   return mid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* 
// OBSOLETE  * Start debugging the process whose unix process-id is PID.
// OBSOLETE  * A negative "pid" value is legal and signifies a mach_id not a unix pid.
// OBSOLETE  *
// OBSOLETE  * Prevent (possible unwanted) dangerous operations by enabled users
// OBSOLETE  * like "atta 0" or "atta foo" (equal to the previous :-) and
// OBSOLETE  * "atta pidself". Anyway, the latter is allowed by specifying a MID.
// OBSOLETE  */
// OBSOLETE static int
// OBSOLETE m3_do_attach (int pid)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (pid == 0)
// OBSOLETE     error ("MID=0, Debugging the master unix server does not compute");
// OBSOLETE 
// OBSOLETE   /* Foo. This assumes gdb has a unix pid */
// OBSOLETE   if (pid == getpid ())
// OBSOLETE     error ("I will debug myself only by mid. (Gdb would suspend itself!)");
// OBSOLETE 
// OBSOLETE   if (pid < 0)
// OBSOLETE     {
// OBSOLETE       mid_attach (-(pid));
// OBSOLETE 
// OBSOLETE       /* inferior_ptid will be NEGATIVE! */
// OBSOLETE       inferior_ptid = pid_to_ptid (pid);
// OBSOLETE 
// OBSOLETE       return PIDGET (inferior_ptid);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   inferior_task = task_by_pid (pid);
// OBSOLETE   if (!MACH_PORT_VALID (inferior_task))
// OBSOLETE     error ("Cannot map Unix pid %d to Mach task port", pid);
// OBSOLETE 
// OBSOLETE   task_attach (inferior_task);
// OBSOLETE 
// OBSOLETE   inferior_ptid = pid_to_ptid (pid);
// OBSOLETE 
// OBSOLETE   return PIDGET (inferior_ptid);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Attach to process PID, then initialize for debugging it
// OBSOLETE    and wait for the trace-trap that results from attaching.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_attach (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   char *exec_file;
// OBSOLETE   int pid;
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     error_no_arg ("process-id to attach");
// OBSOLETE 
// OBSOLETE   pid = atoi (args);
// OBSOLETE 
// OBSOLETE   if (pid == getpid ())		/* Trying to masturbate? */
// OBSOLETE     error ("I refuse to debug myself!");
// OBSOLETE 
// OBSOLETE   if (from_tty)
// OBSOLETE     {
// OBSOLETE       exec_file = (char *) get_exec_file (0);
// OBSOLETE 
// OBSOLETE       if (exec_file)
// OBSOLETE 	printf_unfiltered ("Attaching to program `%s', %s\n", exec_file,
// OBSOLETE 	                   target_pid_to_str (pid_to_ptid (pid)));
// OBSOLETE       else
// OBSOLETE 	printf_unfiltered ("Attaching to %s\n",
// OBSOLETE 	                   target_pid_to_str (pid_to_ptid (pid)));
// OBSOLETE 
// OBSOLETE       gdb_flush (gdb_stdout);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   m3_do_attach (pid_to_ptid (pid));
// OBSOLETE   inferior_ptid = pid_to_ptid (pid);
// OBSOLETE   push_target (&m3_ops);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE deallocate_inferior_ports (void)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_array_t thread_list;
// OBSOLETE   int thread_count, index;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (inferior_task))
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   ret = task_threads (inferior_task, &thread_list, &thread_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("deallocate_inferior_ports: task_threads",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Get rid of send rights to task threads */
// OBSOLETE   for (index = 0; index < thread_count; index++)
// OBSOLETE     {
// OBSOLETE       int rights;
// OBSOLETE       ret = mach_port_get_refs (mach_task_self (),
// OBSOLETE 				thread_list[index],
// OBSOLETE 				MACH_PORT_RIGHT_SEND,
// OBSOLETE 				&rights);
// OBSOLETE       CHK ("deallocate_inferior_ports: get refs", ret);
// OBSOLETE 
// OBSOLETE       if (rights > 0)
// OBSOLETE 	{
// OBSOLETE 	  ret = mach_port_mod_refs (mach_task_self (),
// OBSOLETE 				    thread_list[index],
// OBSOLETE 				    MACH_PORT_RIGHT_SEND,
// OBSOLETE 				    -rights);
// OBSOLETE 	  CHK ("deallocate_inferior_ports: mod refs", ret);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = mach_port_mod_refs (mach_task_self (),
// OBSOLETE 			    inferior_exception_port,
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    -1);
// OBSOLETE   CHK ("deallocate_inferior_ports: cannot get rid of exception port", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_deallocate (mach_task_self (),
// OBSOLETE 			      inferior_task);
// OBSOLETE   CHK ("deallocate_task_port: deallocating inferior_task", ret);
// OBSOLETE 
// OBSOLETE   current_thread = MACH_PORT_NULL;
// OBSOLETE   inferior_task = MACH_PORT_NULL;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Stop debugging the process whose number is PID
// OBSOLETE    and continue it with signal number SIGNAL.
// OBSOLETE    SIGNAL = 0 means just continue it.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_do_detach (int signal)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   if (current_thread != MACH_PORT_NULL)
// OBSOLETE     {
// OBSOLETE       /* Store the gdb's view of the thread we are deselecting
// OBSOLETE        * before we detach.
// OBSOLETE        * @@@@ I am really not sure if this is ever needeed.
// OBSOLETE        */
// OBSOLETE       target_prepare_to_store ();
// OBSOLETE       target_store_registers (-1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = task_set_special_port (inferior_task,
// OBSOLETE 			       TASK_EXCEPTION_PORT,
// OBSOLETE 			       inferior_old_exception_port);
// OBSOLETE   CHK ("task_set_special_port", ret);
// OBSOLETE 
// OBSOLETE   /* Discard all requested notifications */
// OBSOLETE   setup_notify_port (0);
// OBSOLETE 
// OBSOLETE   if (remove_breakpoints ())
// OBSOLETE     warning ("Could not remove breakpoints when detaching");
// OBSOLETE 
// OBSOLETE   if (signal && PIDGET (inferior_ptid) > 0)
// OBSOLETE     kill (PIDGET (inferior_ptid), signal);
// OBSOLETE 
// OBSOLETE   /* the task might be dead by now */
// OBSOLETE   (void) task_resume (inferior_task);
// OBSOLETE 
// OBSOLETE   deallocate_inferior_ports ();
// OBSOLETE 
// OBSOLETE   attach_flag = 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Take a program previously attached to and detaches it.
// OBSOLETE    The program resumes execution and will no longer stop
// OBSOLETE    on signals, etc.  We'd better not have left any breakpoints
// OBSOLETE    in the program or it'll die when it hits one.  For this
// OBSOLETE    to work, it may be necessary for the process to have been
// OBSOLETE    previously attached.  It *might* work if the program was
// OBSOLETE    started via fork.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_detach (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int siggnal = 0;
// OBSOLETE 
// OBSOLETE   if (from_tty)
// OBSOLETE     {
// OBSOLETE       char *exec_file = get_exec_file (0);
// OBSOLETE       if (exec_file == 0)
// OBSOLETE 	exec_file = "";
// OBSOLETE       printf_unfiltered ("Detaching from program: %s %s\n",
// OBSOLETE 			 exec_file, target_pid_to_str (inferior_ptid));
// OBSOLETE       gdb_flush (gdb_stdout);
// OBSOLETE     }
// OBSOLETE   if (args)
// OBSOLETE     siggnal = atoi (args);
// OBSOLETE 
// OBSOLETE   m3_do_detach (siggnal);
// OBSOLETE   inferior_ptid = null_ptid;
// OBSOLETE   unpush_target (&m3_ops);	/* Pop out of handling an inferior */
// OBSOLETE }
// OBSOLETE #endif /* ATTACH_DETACH */
// OBSOLETE 
// OBSOLETE /* Get ready to modify the registers array.  On machines which store
// OBSOLETE    individual registers, this doesn't need to do anything.  On machines
// OBSOLETE    which store all the registers in one fell swoop, this makes sure
// OBSOLETE    that registers contains all the registers from the program being
// OBSOLETE    debugged.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_prepare_to_store (void)
// OBSOLETE {
// OBSOLETE #ifdef CHILD_PREPARE_TO_STORE
// OBSOLETE   CHILD_PREPARE_TO_STORE ();
// OBSOLETE #endif
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Print status information about what we're accessing.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_files_info (struct target_ops *ignore)
// OBSOLETE {
// OBSOLETE   /* FIXME: should print MID and all that crap.  */
// OBSOLETE   printf_unfiltered ("\tUsing the running image of %s %s.\n",
// OBSOLETE       attach_flag ? "attached" : "child", target_pid_to_str (inferior_ptid));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_open (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   error ("Use the \"run\" command to start a Unix child process.");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef DUMP_SYSCALL
// OBSOLETE #define STR(x) #x
// OBSOLETE 
// OBSOLETE char *bsd1_names[] =
// OBSOLETE {
// OBSOLETE   "execve",
// OBSOLETE   "fork",
// OBSOLETE   "take_signal",
// OBSOLETE   "sigreturn",
// OBSOLETE   "getrusage",
// OBSOLETE   "chdir",
// OBSOLETE   "chroot",
// OBSOLETE   "open",
// OBSOLETE   "creat",
// OBSOLETE   "mknod",
// OBSOLETE   "link",
// OBSOLETE   "symlink",
// OBSOLETE   "unlink",
// OBSOLETE   "access",
// OBSOLETE   "stat",
// OBSOLETE   "readlink",
// OBSOLETE   "chmod",
// OBSOLETE   "chown",
// OBSOLETE   "utimes",
// OBSOLETE   "truncate",
// OBSOLETE   "rename",
// OBSOLETE   "mkdir",
// OBSOLETE   "rmdir",
// OBSOLETE   "xutimes",
// OBSOLETE   "mount",
// OBSOLETE   "umount",
// OBSOLETE   "acct",
// OBSOLETE   "setquota",
// OBSOLETE   "write_short",
// OBSOLETE   "write_long",
// OBSOLETE   "send_short",
// OBSOLETE   "send_long",
// OBSOLETE   "sendto_short",
// OBSOLETE   "sendto_long",
// OBSOLETE   "select",
// OBSOLETE   "task_by_pid",
// OBSOLETE   "recvfrom_short",
// OBSOLETE   "recvfrom_long",
// OBSOLETE   "setgroups",
// OBSOLETE   "setrlimit",
// OBSOLETE   "sigvec",
// OBSOLETE   "sigstack",
// OBSOLETE   "settimeofday",
// OBSOLETE   "adjtime",
// OBSOLETE   "setitimer",
// OBSOLETE   "sethostname",
// OBSOLETE   "bind",
// OBSOLETE   "accept",
// OBSOLETE   "connect",
// OBSOLETE   "setsockopt",
// OBSOLETE   "getsockopt",
// OBSOLETE   "getsockname",
// OBSOLETE   "getpeername",
// OBSOLETE   "init_process",
// OBSOLETE   "table_set",
// OBSOLETE   "table_get",
// OBSOLETE   "pioctl",
// OBSOLETE   "emulator_error",
// OBSOLETE   "readwrite",
// OBSOLETE   "share_wakeup",
// OBSOLETE   0,
// OBSOLETE   "maprw_request_it",
// OBSOLETE   "maprw_release_it",
// OBSOLETE   "maprw_remap",
// OBSOLETE   "pid_by_task",
// OBSOLETE };
// OBSOLETE 
// OBSOLETE int bsd1_nnames = sizeof (bsd1_names) / sizeof (bsd1_names[0]);
// OBSOLETE 
// OBSOLETE char *
// OBSOLETE name_str (int name, char *buf)
// OBSOLETE {
// OBSOLETE   switch (name)
// OBSOLETE     {
// OBSOLETE     case MACH_MSG_TYPE_BOOLEAN:
// OBSOLETE       return "boolean";
// OBSOLETE     case MACH_MSG_TYPE_INTEGER_16:
// OBSOLETE       return "short";
// OBSOLETE     case MACH_MSG_TYPE_INTEGER_32:
// OBSOLETE       return "long";
// OBSOLETE     case MACH_MSG_TYPE_CHAR:
// OBSOLETE       return "char";
// OBSOLETE     case MACH_MSG_TYPE_BYTE:
// OBSOLETE       return "byte";
// OBSOLETE     case MACH_MSG_TYPE_REAL:
// OBSOLETE       return "real";
// OBSOLETE     case MACH_MSG_TYPE_STRING:
// OBSOLETE       return "string";
// OBSOLETE     default:
// OBSOLETE       sprintf (buf, "%d", name);
// OBSOLETE       return buf;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE char *
// OBSOLETE id_str (int id, char *buf)
// OBSOLETE {
// OBSOLETE   char *p;
// OBSOLETE   if (id >= 101000 && id < 101000 + bsd1_nnames)
// OBSOLETE     {
// OBSOLETE       if (p = bsd1_names[id - 101000])
// OBSOLETE 	return p;
// OBSOLETE     }
// OBSOLETE   if (id == 102000)
// OBSOLETE     return "psignal_retry";
// OBSOLETE   if (id == 100000)
// OBSOLETE     return "syscall";
// OBSOLETE   sprintf (buf, "%d", id);
// OBSOLETE   return buf;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE print_msg (mach_msg_header_t *mp)
// OBSOLETE {
// OBSOLETE   char *fmt_x = "%20s : 0x%08x\n";
// OBSOLETE   char *fmt_d = "%20s : %10d\n";
// OBSOLETE   char *fmt_s = "%20s : %s\n";
// OBSOLETE   char buf[100];
// OBSOLETE 
// OBSOLETE   puts_filtered ("\n");
// OBSOLETE #define pr(fmt,h,x) printf_filtered(fmt,STR(x),(h).x)
// OBSOLETE   pr (fmt_x, (*mp), msgh_bits);
// OBSOLETE   pr (fmt_d, (*mp), msgh_size);
// OBSOLETE   pr (fmt_x, (*mp), msgh_remote_port);
// OBSOLETE   pr (fmt_x, (*mp), msgh_local_port);
// OBSOLETE   pr (fmt_d, (*mp), msgh_kind);
// OBSOLETE   printf_filtered (fmt_s, STR (msgh_id), id_str (mp->msgh_id, buf));
// OBSOLETE 
// OBSOLETE   if (debug_level > 1)
// OBSOLETE     {
// OBSOLETE       char *p, *ep, *dp;
// OBSOLETE       int plen;
// OBSOLETE       p = (char *) mp;
// OBSOLETE       ep = p + mp->msgh_size;
// OBSOLETE       p += sizeof (*mp);
// OBSOLETE       for (; p < ep; p += plen)
// OBSOLETE 	{
// OBSOLETE 	  mach_msg_type_t *tp;
// OBSOLETE 	  mach_msg_type_long_t *tlp;
// OBSOLETE 	  int name, size, number;
// OBSOLETE 	  tp = (mach_msg_type_t *) p;
// OBSOLETE 	  if (tp->msgt_longform)
// OBSOLETE 	    {
// OBSOLETE 	      tlp = (mach_msg_type_long_t *) tp;
// OBSOLETE 	      name = tlp->msgtl_name;
// OBSOLETE 	      size = tlp->msgtl_size;
// OBSOLETE 	      number = tlp->msgtl_number;
// OBSOLETE 	      plen = sizeof (*tlp);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      name = tp->msgt_name;
// OBSOLETE 	      size = tp->msgt_size;
// OBSOLETE 	      number = tp->msgt_number;
// OBSOLETE 	      plen = sizeof (*tp);
// OBSOLETE 	    }
// OBSOLETE 	  printf_filtered ("name=%-16s size=%2d number=%7d inline=%d long=%d deal=%d\n",
// OBSOLETE 			name_str (name, buf), size, number, tp->msgt_inline,
// OBSOLETE 			   tp->msgt_longform, tp->msgt_deallocate);
// OBSOLETE 	  dp = p + plen;
// OBSOLETE 	  if (tp->msgt_inline)
// OBSOLETE 	    {
// OBSOLETE 	      int l;
// OBSOLETE 	      l = size * number / 8;
// OBSOLETE 	      l = (l + sizeof (long) - 1) & ~((sizeof (long)) - 1);
// OBSOLETE 	      plen += l;
// OBSOLETE 	      print_data (dp, size, number);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      plen += sizeof (int *);
// OBSOLETE 	    }
// OBSOLETE 	  printf_filtered ("plen=%d\n", plen);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE print_data (char *p, int size, int number)
// OBSOLETE {
// OBSOLETE   int *ip;
// OBSOLETE   short *sp;
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   switch (size)
// OBSOLETE     {
// OBSOLETE     case 8:
// OBSOLETE       for (i = 0; i < number; i++)
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered (" %02x", p[i]);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE     case 16:
// OBSOLETE       sp = (short *) p;
// OBSOLETE       for (i = 0; i < number; i++)
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered (" %04x", sp[i]);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE     case 32:
// OBSOLETE       ip = (int *) p;
// OBSOLETE       for (i = 0; i < number; i++)
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered (" %08x", ip[i]);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE   puts_filtered ("\n");
// OBSOLETE }
// OBSOLETE #endif /* DUMP_SYSCALL */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_stop (void)
// OBSOLETE {
// OBSOLETE   error ("to_stop target function not implemented");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE m3_pid_to_exec_file (int pid)
// OBSOLETE {
// OBSOLETE   error ("to_pid_to_exec_file target function not implemented");
// OBSOLETE   return NULL;			/* To keep all compilers happy. */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_m3_ops (void)
// OBSOLETE {
// OBSOLETE   m3_ops.to_shortname = "mach";
// OBSOLETE   m3_ops.to_longname = "Mach child process";
// OBSOLETE   m3_ops.to_doc = "Mach child process (started by the \"run\" command).";
// OBSOLETE   m3_ops.to_open = m3_open;
// OBSOLETE   m3_ops.to_attach = m3_attach;
// OBSOLETE   m3_ops.to_detach = m3_detach;
// OBSOLETE   m3_ops.to_resume = m3_resume;
// OBSOLETE   m3_ops.to_wait = mach_really_wait;
// OBSOLETE   m3_ops.to_fetch_registers = fetch_inferior_registers;
// OBSOLETE   m3_ops.to_store_registers = store_inferior_registers;
// OBSOLETE   m3_ops.to_prepare_to_store = m3_prepare_to_store;
// OBSOLETE   m3_ops.to_xfer_memory = m3_xfer_memory;
// OBSOLETE   m3_ops.to_files_info = m3_files_info;
// OBSOLETE   m3_ops.to_insert_breakpoint = memory_insert_breakpoint;
// OBSOLETE   m3_ops.to_remove_breakpoint = memory_remove_breakpoint;
// OBSOLETE   m3_ops.to_terminal_init = terminal_init_inferior;
// OBSOLETE   m3_ops.to_terminal_inferior = terminal_inferior;
// OBSOLETE   m3_ops.to_terminal_ours_for_output = terminal_ours_for_output;
// OBSOLETE   m3_ops.to_terminal_save_ours = terminal_save_ours;
// OBSOLETE   m3_ops.to_terminal_ours = terminal_ours;
// OBSOLETE   m3_ops.to_terminal_info = child_terminal_info;
// OBSOLETE   m3_ops.to_kill = m3_kill_inferior;
// OBSOLETE   m3_ops.to_create_inferior = m3_create_inferior;
// OBSOLETE   m3_ops.to_mourn_inferior = m3_mourn_inferior;
// OBSOLETE   m3_ops.to_can_run = m3_can_run;
// OBSOLETE   m3_ops.to_stop = m3_stop;
// OBSOLETE   m3_ops.to_pid_to_exec_file = m3_pid_to_exec_file;
// OBSOLETE   m3_ops.to_stratum = process_stratum;
// OBSOLETE   m3_ops.to_has_all_memory = 1;
// OBSOLETE   m3_ops.to_has_memory = 1;
// OBSOLETE   m3_ops.to_has_stack = 1;
// OBSOLETE   m3_ops.to_has_registers = 1;
// OBSOLETE   m3_ops.to_has_execution = 1;
// OBSOLETE   m3_ops.to_magic = OPS_MAGIC;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_m3_nat (void)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   init_m3_ops ();
// OBSOLETE   add_target (&m3_ops);
// OBSOLETE 
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_PORT_SET,
// OBSOLETE 			    &inferior_wait_port_set);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     internal_error (__FILE__, __LINE__,
// OBSOLETE 		    "initial port set %s", mach_error_string (ret));
// OBSOLETE 
// OBSOLETE   /* mach_really_wait now waits for this */
// OBSOLETE   currently_waiting_for = inferior_wait_port_set;
// OBSOLETE 
// OBSOLETE   ret = netname_look_up (name_server_port, hostname, "MachID", &mid_server);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       mid_server = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE       warning ("initialize machid: netname_lookup_up(MachID) : %s",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE       warning ("Some (most?) features disabled...");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   mid_auth = mach_privileged_host_port ();
// OBSOLETE   if (mid_auth == MACH_PORT_NULL)
// OBSOLETE     mid_auth = mach_task_self ();
// OBSOLETE 
// OBSOLETE   obstack_init (port_chain_obstack);
// OBSOLETE 
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    &thread_exception_port);
// OBSOLETE   CHK ("Creating thread_exception_port for single stepping", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_insert_right (mach_task_self (),
// OBSOLETE 				thread_exception_port,
// OBSOLETE 				thread_exception_port,
// OBSOLETE 				MACH_MSG_TYPE_MAKE_SEND);
// OBSOLETE   CHK ("Inserting send right to thread_exception_port", ret);
// OBSOLETE 
// OBSOLETE   /* Allocate message port */
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    &our_message_port);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("Creating message port %s", mach_error_string (ret));
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       char buf[MAX_NAME_LEN];
// OBSOLETE       ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 				   our_message_port,
// OBSOLETE 				   inferior_wait_port_set);
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	warning ("message move member %s", mach_error_string (ret));
// OBSOLETE 
// OBSOLETE 
// OBSOLETE       /* @@@@@@@@ No way to change message port name currently */
// OBSOLETE       /* Foo. This assumes gdb has a unix pid */
// OBSOLETE       sprintf (buf, "gdb-%d", getpid ());
// OBSOLETE       gdb_register_port (buf, our_message_port);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Heap for thread commands */
// OBSOLETE   obstack_init (cproc_obstack);
// OBSOLETE 
// OBSOLETE   add_mach_specific_commands ();
// OBSOLETE }
@


1.19
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@@


1.18
log
@2003-04-09  Andrew Cagney  <cagney@@redhat.com>

	Obsolete mips*-*-mach3*.
	* NEWS: Mention that mips*-*-mach3* is obsolete.
	* m3-nat.c: Obsolete file.
	* config/nm-m3.h: Obsolete file.
	* config/mips/tm-mipsm3.h: Obsolete file.
	* config/mips/mipsm3.mt: Obsolete file.
	* config/mips/mipsm3.mh: Obsolete file.
	* config/mips/xm-mipsm3.h: Obsolete file.
	* mipsm3-nat.c: Obsolete file.
	* configure.host: Obsolete mips-dec-mach3*.
	* configure.tgt: Obsolete mips*-*-mach3*.
@
text
@d2437 1
a2437 1
// OBSOLETE 		       VAR_NAMESPACE,
@


1.18.2.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d2437 1
a2437 1
// OBSOLETE 		       VAR_DOMAIN,
@


1.17
log
@	Fix PR gdb/393:
	* inflow.c (terminal_save_ours): New function to save terminal
	settings.
	* inferior.h (terminal_save_ours): Declare.
	* target.c (debug_to_terminal_save_ours): New function.
	(cleanup_target): Defaults to_terminal_save_ours.
	(update_current_target): Inherit to_terminal_save_ours.
	(setup_target_debug): Set to_terminal_save_ours.
	* target.h (target_terminal_save_ours): New to save terminal settings.
	(target_ops): New member to_terminal_save_ours.
	* gnu-nat.c (init_gnu_ops): Set to_terminal_save_ours.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* inftarg.c (init_child_ops): Likewise.
	* m3-nat.c (init_m3_ops): Likewise.
	* procfs.c (init_procfs_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* sol-thread.c (init_sol_thread_ops): Likewise.
@
text
@d1 4566
a4566 4566
/* Interface GDB to Mach 3.0 operating systems.
   (Most) Mach 3.0 related routines live in this file.

   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
   2002 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/*
 * Author: Jukka Virtanen <jtv@@hut.fi>
 *         Computing Centre
 *         Helsinki University of Technology
 *         Finland
 *
 * Thanks to my friends who helped with ideas and testing:
 *
 *      Johannes Helander, Antti Louko, Tero Mononen,
 *      jvh@@cs.hut.fi      alo@@hut.fi   tmo@@cs.hut.fi
 *
 *      Tero Kivinen       and          Eamonn McManus
 *      kivinen@@cs.hut.fi               emcmanus@@gr.osf.org
 *      
 */

#include <stdio.h>

#include <mach.h>
#include <servers/netname.h>
#include <servers/machid.h>
#include <mach/message.h>
#include <mach/notify.h>
#include <mach_error.h>
#include <mach/exception.h>
#include <mach/vm_attributes.h>

#include "defs.h"
#include "inferior.h"
#include "symtab.h"
#include "value.h"
#include "language.h"
#include "target.h"
#include "gdb_wait.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "regcache.h"

#if 0
#include <servers/machid_lib.h>
#else
#define	MACH_TYPE_TASK			1
#define MACH_TYPE_THREAD		2
#endif

/* Included only for signal names and NSIG

 * note: There are many problems in signal handling with
 *       gdb in Mach 3.0 in general.
 */
#include <signal.h>
#define SIG_UNKNOWN 0		/* Exception that has no matching unix signal */

#include <cthreads.h>

/* This is what a cproc looks like.  This is here partly because
   cthread_internals.h is not a header we can just #include, partly with
   an eye towards perhaps getting this to work with cross-debugging
   someday.  Best solution is if CMU publishes a real interface to this
   stuff.  */
#define CPROC_NEXT_OFFSET 0
#define CPROC_NEXT_SIZE (TARGET_PTR_BIT / HOST_CHAR_BIT)
#define CPROC_INCARNATION_OFFSET (CPROC_NEXT_OFFSET + CPROC_NEXT_SIZE)
#define CPROC_INCARNATION_SIZE (sizeof (cthread_t))
#define CPROC_LIST_OFFSET (CPROC_INCARNATION_OFFSET + CPROC_INCARNATION_SIZE)
#define CPROC_LIST_SIZE (TARGET_PTR_BIT / HOST_CHAR_BIT)
#define CPROC_WAIT_OFFSET (CPROC_LIST_OFFSET + CPROC_LIST_SIZE)
#define CPROC_WAIT_SIZE (TARGET_PTR_BIT / HOST_CHAR_BIT)
#define CPROC_REPLY_OFFSET (CPROC_WAIT_OFFSET + CPROC_WAIT_SIZE)
#define CPROC_REPLY_SIZE (sizeof (mach_port_t))
#define CPROC_CONTEXT_OFFSET (CPROC_REPLY_OFFSET + CPROC_REPLY_SIZE)
#define CPROC_CONTEXT_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
#define CPROC_LOCK_OFFSET (CPROC_CONTEXT_OFFSET + CPROC_CONTEXT_SIZE)
#define CPROC_LOCK_SIZE (sizeof (spin_lock_t))
#define CPROC_STATE_OFFSET (CPROC_LOCK_OFFSET + CPROC_LOCK_SIZE)
#define CPROC_STATE_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
#define CPROC_WIRED_OFFSET (CPROC_STATE_OFFSET + CPROC_STATE_SIZE)
#define CPROC_WIRED_SIZE (sizeof (mach_port_t))
#define CPROC_BUSY_OFFSET (CPROC_WIRED_OFFSET + CPROC_WIRED_SIZE)
#define CPROC_BUSY_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
#define CPROC_MSG_OFFSET (CPROC_BUSY_OFFSET + CPROC_BUSY_SIZE)
#define CPROC_MSG_SIZE (sizeof (mach_msg_header_t))
#define CPROC_BASE_OFFSET (CPROC_MSG_OFFSET + CPROC_MSG_SIZE)
#define CPROC_BASE_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
#define CPROC_SIZE_OFFSET (CPROC_BASE_OFFSET + CPROC_BASE_SIZE)
#define CPROC_SIZE_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
#define CPROC_SIZE (CPROC_SIZE_OFFSET + CPROC_SIZE_SIZE)

/* Values for the state field in the cproc.  */
#define CPROC_RUNNING	0
#define CPROC_SWITCHING 1
#define CPROC_BLOCKED	2
#define CPROC_CONDWAIT	4

/* For cproc and kernel thread mapping */
typedef struct gdb_thread
  {
    mach_port_t name;
    CORE_ADDR sp;
    CORE_ADDR pc;
    CORE_ADDR fp;
    boolean_t in_emulator;
    int slotid;

    /* This is for the mthreads list.  It points to the cproc list.
       Perhaps the two lists should be merged (or perhaps it was a mistake
       to make them both use a struct gdb_thread).  */
    struct gdb_thread *cproc;

    /* These are for the cproc list, which is linked through the next field
       of the struct gdb_thread.  */
    char raw_cproc[CPROC_SIZE];
    /* The cthread which is pointed to by the incarnation field from the
       cproc.  This points to the copy we've read into GDB.  */
    cthread_t cthread;
    /* Point back to the mthreads list.  */
    int reverse_map;
    struct gdb_thread *next;
  }
 *gdb_thread_t;

/* 
 * Actions for Mach exceptions.
 *
 * sigmap field maps the exception to corresponding Unix signal.
 *
 * I do not know how to map the exception to unix signal
 * if SIG_UNKNOWN is specified.
 */

struct exception_list
  {
    char *name;
    boolean_t forward;
    boolean_t print;
    int sigmap;
  }
exception_map[] =
{
  {
    "not_mach3_exception", FALSE, TRUE, SIG_UNKNOWN
  }
  ,
  {
    "EXC_BAD_ACCESS", FALSE, TRUE, SIGSEGV
  }
  ,
  {
    "EXC_BAD_INSTRUCTION", FALSE, TRUE, SIGILL
  }
  ,
  {
    "EXC_ARITHMETIC", FALSE, TRUE, SIGFPE
  }
  ,
  {
    "EXC_EMULATION", FALSE, TRUE, SIGEMT
  }
  ,				/* ??? */
  {
    "EXC_SOFTWARE", FALSE, TRUE, SIG_UNKNOWN
  }
  ,
  {
    "EXC_BREAKPOINT", FALSE, FALSE, SIGTRAP
  }
};

/* Mach exception table size */
int max_exception = sizeof (exception_map) / sizeof (struct exception_list) - 1;

#define MAX_EXCEPTION max_exception

WAITTYPE wait_status;

/* If you define this, intercepted bsd server calls will be
 * dumped while waiting the inferior to EXEC the correct
 * program
 */
/* #define DUMP_SYSCALL         /* debugging interceptor */

/* xx_debug() outputs messages if this is nonzero.
 * If > 1, DUMP_SYSCALL will dump message contents.
 */
int debug_level = 0;

/* "Temporary" debug stuff */
void
xx_debug (char *fmt, int a, int b, int c)
{
  if (debug_level)
    warning (fmt, a, b, c);
}

/* This is in libmach.a */
extern mach_port_t name_server_port;

/* Set in catch_exception_raise */
int stop_exception, stop_code, stop_subcode;
int stopped_in_exception;

/* Thread that was the active thread when we stopped */
thread_t stop_thread = MACH_PORT_NULL;

char *hostname = "";

/* Set when task is attached or created */
boolean_t emulator_present = FALSE;

task_t inferior_task;
thread_t current_thread;

/* Exception ports for inferior task */
mach_port_t inferior_exception_port = MACH_PORT_NULL;
mach_port_t inferior_old_exception_port = MACH_PORT_NULL;

/* task exceptions and notifications */
mach_port_t inferior_wait_port_set = MACH_PORT_NULL;
mach_port_t our_notify_port = MACH_PORT_NULL;

/* This is "inferior_wait_port_set" when not single stepping, and
 *         "singlestepped_thread_port" when we are single stepping.
 * 
 * This is protected by a cleanup function: discard_single_step()
 */
mach_port_t currently_waiting_for = MACH_PORT_NULL;

/* A port for external messages to gdb.
 * External in the meaning that they do not come
 * from the inferior_task, but rather from external
 * tasks.
 *
 * As a debugging feature:
 * A debugger debugging another debugger can stop the
 * inferior debugger by the following command sequence
 * (without running external programs)
 *
 *    (top-gdb) set stop_inferior_gdb ()
 *    (top-gdb) continue
 */
mach_port_t our_message_port = MACH_PORT_NULL;

/* For single stepping */
mach_port_t thread_exception_port = MACH_PORT_NULL;
mach_port_t thread_saved_exception_port = MACH_PORT_NULL;
mach_port_t singlestepped_thread_port = MACH_PORT_NULL;

/* For machid calls */
mach_port_t mid_server = MACH_PORT_NULL;
mach_port_t mid_auth = MACH_PORT_NULL;

/* If gdb thinks the inferior task is not suspended, it
 * must take suspend/abort the threads when it reads the state.
 */
int must_suspend_thread = 0;

/* When single stepping, we switch the port that mach_really_wait() listens to.
 * This cleanup is a guard to prevent the port set from being left to
 * the singlestepped_thread_port when error() is called.
 *  This is nonzero only when we are single stepping.
 */
#define NULL_CLEANUP (struct cleanup *)0
struct cleanup *cleanup_step = NULL_CLEANUP;


static struct target_ops m3_ops;

static void m3_kill_inferior ();

#if 0
#define MACH_TYPE_EXCEPTION_PORT	-1
#endif

/* Chain of ports to remember requested notifications. */

struct port_chain
  {
    struct port_chain *next;
    mach_port_t port;
    int type;
    int mid;			/* Now only valid with MACH_TYPE_THREAD and */
    /*  MACH_TYPE_THREAD */
  };
typedef struct port_chain *port_chain_t;

/* Room for chain nodes comes from pchain_obstack */
struct obstack pchain_obstack;
struct obstack *port_chain_obstack = &pchain_obstack;

/* For thread handling */
struct obstack Cproc_obstack;
struct obstack *cproc_obstack = &Cproc_obstack;

/* the list of notified ports */
port_chain_t notify_chain = (port_chain_t) NULL;

port_chain_t
port_chain_insert (port_chain_t list, mach_port_t name, int type)
{
  kern_return_t ret;
  port_chain_t new;
  int mid;

  if (!MACH_PORT_VALID (name))
    return list;

  if (type == MACH_TYPE_TASK || type == MACH_TYPE_THREAD)
    {
      if (!MACH_PORT_VALID (mid_server))
	{
	  warning ("Machid server port invalid, can not map port 0x%x to MID",
		   name);
	  mid = name;
	}
      else
	{
	  ret = machid_mach_register (mid_server, mid_auth, name, type, &mid);

	  if (ret != KERN_SUCCESS)
	    {
	      warning ("Can not map name (0x%x) to MID with machid", name);
	      mid = name;
	    }
	}
    }
  else
    internal_error (__FILE__, __LINE__, "failed internal consistency check");

  new = (port_chain_t) obstack_alloc (port_chain_obstack,
				      sizeof (struct port_chain));
  new->next = list;
  new->port = name;
  new->type = type;
  new->mid = mid;

  return new;
}

port_chain_t
port_chain_delete (port_chain_t list, mach_port_t elem)
{
  if (list)
    if (list->port == elem)
      list = list->next;
    else
      while (list->next)
	{
	  if (list->next->port == elem)
	    list->next = list->next->next;	/* GCd with obstack_free() */
	  else
	    list = list->next;
	}
  return list;
}

void
port_chain_destroy (struct obstack *ostack)
{
  obstack_free (ostack, 0);
  obstack_init (ostack);
}

port_chain_t
port_chain_member (port_chain_t list, mach_port_t elem)
{
  while (list)
    {
      if (list->port == elem)
	return list;
      list = list->next;
    }
  return (port_chain_t) NULL;
}

int
map_port_name_to_mid (mach_port_t name, int type)
{
  port_chain_t elem;

  if (!MACH_PORT_VALID (name))
    return -1;

  elem = port_chain_member (notify_chain, name);

  if (elem && (elem->type == type))
    return elem->mid;

  if (elem)
    return -1;

  if (!MACH_PORT_VALID (mid_server))
    {
      warning ("Machid server port invalid, can not map port 0x%x to mid",
	       name);
      return -1;
    }
  else
    {
      int mid;
      kern_return_t ret;

      ret = machid_mach_register (mid_server, mid_auth, name, type, &mid);

      if (ret != KERN_SUCCESS)
	{
	  warning ("Can not map name (0x%x) to mid with machid", name);
	  return -1;
	}
      return mid;
    }
}

/* Guard for currently_waiting_for and singlestepped_thread_port */
static void
discard_single_step (thread_t thread)
{
  currently_waiting_for = inferior_wait_port_set;

  cleanup_step = NULL_CLEANUP;
  if (MACH_PORT_VALID (thread) && MACH_PORT_VALID (singlestepped_thread_port))
    setup_single_step (thread, FALSE);
}

setup_single_step (thread_t thread, boolean_t start_step)
{
  kern_return_t ret;

  if (!MACH_PORT_VALID (thread))
    error ("Invalid thread supplied to setup_single_step");
  else
    {
      mach_port_t teport;

      /* Get the current thread exception port */
      ret = thread_get_exception_port (thread, &teport);
      CHK ("Getting thread's exception port", ret);

      if (start_step)
	{
	  if (MACH_PORT_VALID (singlestepped_thread_port))
	    {
	      warning ("Singlestepped_thread_port (0x%x) is still valid?",
		       singlestepped_thread_port);
	      singlestepped_thread_port = MACH_PORT_NULL;
	    }

	  /* If we are already stepping this thread */
	  if (MACH_PORT_VALID (teport) && teport == thread_exception_port)
	    {
	      ret = mach_port_deallocate (mach_task_self (), teport);
	      CHK ("Could not deallocate thread exception port", ret);
	    }
	  else
	    {
	      ret = thread_set_exception_port (thread, thread_exception_port);
	      CHK ("Setting exception port for thread", ret);
#if 0
	      /* Insert thread exception port to wait port set */
	      ret = mach_port_move_member (mach_task_self (),
					   thread_exception_port,
					   inferior_wait_port_set);
	      CHK ("Moving thread exception port to inferior_wait_port_set",
		   ret);
#endif
	      thread_saved_exception_port = teport;
	    }

	  thread_trace (thread, TRUE);

	  singlestepped_thread_port = thread_exception_port;
	  currently_waiting_for = singlestepped_thread_port;
	  cleanup_step = make_cleanup (discard_single_step, thread);
	}
      else
	{
	  if (!MACH_PORT_VALID (teport))
	    error ("Single stepped thread had an invalid exception port?");

	  if (teport != thread_exception_port)
	    error ("Single stepped thread had an unknown exception port?");

	  ret = mach_port_deallocate (mach_task_self (), teport);
	  CHK ("Couldn't deallocate thread exception port", ret);
#if 0
	  /* Remove thread exception port from wait port set */
	  ret = mach_port_move_member (mach_task_self (),
				       thread_exception_port,
				       MACH_PORT_NULL);
	  CHK ("Removing thread exception port from inferior_wait_port_set",
	       ret);
#endif
	  /* Restore thread's old exception port */
	  ret = thread_set_exception_port (thread,
					   thread_saved_exception_port);
	  CHK ("Restoring stepped thread's exception port", ret);

	  if (MACH_PORT_VALID (thread_saved_exception_port))
	    (void) mach_port_deallocate (mach_task_self (),
					 thread_saved_exception_port);

	  thread_trace (thread, FALSE);

	  singlestepped_thread_port = MACH_PORT_NULL;
	  currently_waiting_for = inferior_wait_port_set;
	  if (cleanup_step)
	    discard_cleanups (cleanup_step);
	}
    }
}

static
request_notify (mach_port_t name, mach_msg_id_t variant, int type)
{
  kern_return_t ret;
  mach_port_t previous_port_dummy = MACH_PORT_NULL;

  if (!MACH_PORT_VALID (name))
    return;

  if (port_chain_member (notify_chain, name))
    return;

  ret = mach_port_request_notification (mach_task_self (),
					name,
					variant,
					1,
					our_notify_port,
					MACH_MSG_TYPE_MAKE_SEND_ONCE,
					&previous_port_dummy);
  CHK ("Serious: request_notify failed", ret);

  (void) mach_port_deallocate (mach_task_self (),
			       previous_port_dummy);

  notify_chain = port_chain_insert (notify_chain, name, type);
}

reverse_msg_bits (mach_msg_header_t *msgp, int type)
{
  int rbits, lbits;
  rbits = MACH_MSGH_BITS_REMOTE (msgp->msgh_bits);
  lbits = type;
  msgp->msgh_bits =
    (msgp->msgh_bits & ~MACH_MSGH_BITS_PORTS_MASK) |
    MACH_MSGH_BITS (lbits, rbits);
}

/* On the third day He said:

   Let this be global
   and then it was global.

   When creating the inferior fork, the
   child code in inflow.c sets the name of the
   bootstrap_port in its address space to this
   variable.

   The name is transferred to our address space
   with mach3_read_inferior().

   Thou shalt not do this with
   task_get_bootstrap_port() in this task, since
   the name in the inferior task is different than
   the one we get.

   For blessed are the meek, as they shall inherit
   the address space.
 */
mach_port_t original_server_port_name = MACH_PORT_NULL;


/* Called from inferior after FORK but before EXEC */
static void
m3_trace_me (void)
{
  kern_return_t ret;

  /* Get the NAME of the bootstrap port in this task
     so that GDB can read it */
  ret = task_get_bootstrap_port (mach_task_self (),
				 &original_server_port_name);
  if (ret != KERN_SUCCESS)
    internal_error (__FILE__, __LINE__, "failed internal consistency check");
  ret = mach_port_deallocate (mach_task_self (),
			      original_server_port_name);
  if (ret != KERN_SUCCESS)
    internal_error (__FILE__, __LINE__, "failed internal consistency check");

  /* Suspend this task to let the parent change my ports.
     Resumed by the debugger */
  ret = task_suspend (mach_task_self ());
  if (ret != KERN_SUCCESS)
    internal_error (__FILE__, __LINE__, "failed internal consistency check");
}

/*
 * Intercept system calls to Unix server.
 * After EXEC_COUNTER calls to exec(), return.
 *
 * Pre-assertion:  Child is suspended. (Not verified)
 * Post-condition: Child is suspended after EXEC_COUNTER exec() calls.
 */

void
intercept_exec_calls (int exec_counter)
{
  int terminal_initted = 0;

  struct syscall_msg_t
    {
      mach_msg_header_t header;
      mach_msg_type_t type;
      char room[2000];		/* Enuff space */
    };

  struct syscall_msg_t syscall_in, syscall_out;

  mach_port_t fake_server;
  mach_port_t original_server_send;
  mach_port_t original_exec_reply;
  mach_port_t exec_reply;
  mach_port_t exec_reply_send;
  mach_msg_type_name_t acquired;
  mach_port_t emulator_server_port_name;
  struct task_basic_info info;
  mach_msg_type_number_t info_count;

  kern_return_t ret;

  if (exec_counter <= 0)
    return;			/* We are already set up in the correct program */

  ret = mach_port_allocate (mach_task_self (),
			    MACH_PORT_RIGHT_RECEIVE,
			    &fake_server);
  CHK ("create inferior_fake_server port failed", ret);

  /* Wait for inferior_task to suspend itself */
  while (1)
    {
      info_count = sizeof (info);
      ret = task_info (inferior_task,
		       TASK_BASIC_INFO,
		       (task_info_t) & info,
		       &info_count);
      CHK ("Task info", ret);

      if (info.suspend_count)
	break;

      /* Note that the definition of the parameter was undefined
       * at the time of this writing, so I just use an `ad hoc' value.
       */
      (void) swtch_pri (42);	/* Universal Priority Value */
    }

  /* Read the inferior's bootstrap port name */
  if (!mach3_read_inferior (&original_server_port_name,
			    &original_server_port_name,
			    sizeof (original_server_port_name)))
    error ("Can't read inferior task bootstrap port name");

  /* @@@@ BUG: If more than 1 send right GDB will FAIL!!! */
  /*      Should get refs, and set them back when restoring */
  /* Steal the original bsd server send right from inferior */
  ret = mach_port_extract_right (inferior_task,
				 original_server_port_name,
				 MACH_MSG_TYPE_MOVE_SEND,
				 &original_server_send,
				 &acquired);
  CHK ("mach_port_extract_right (bsd server send)", ret);

  if (acquired != MACH_MSG_TYPE_PORT_SEND)
    error ("Incorrect right extracted, send right to bsd server expected");

  ret = mach_port_insert_right (inferior_task,
				original_server_port_name,
				fake_server,
				MACH_MSG_TYPE_MAKE_SEND);
  CHK ("mach_port_insert_right (fake server send)", ret);

  xx_debug ("inferior task bsd server ports set up \nfs %x, ospn %x, oss %x\n",
	    fake_server,
	    original_server_port_name, original_server_send);

  /* A receive right to the reply generated by unix server exec() request */
  ret = mach_port_allocate (mach_task_self (),
			    MACH_PORT_RIGHT_RECEIVE,
			    &exec_reply);
  CHK ("create intercepted_reply_port port failed", ret);

  /* Pass this send right to Unix server so it replies to us after exec() */
  ret = mach_port_extract_right (mach_task_self (),
				 exec_reply,
				 MACH_MSG_TYPE_MAKE_SEND_ONCE,
				 &exec_reply_send,
				 &acquired);
  CHK ("mach_port_extract_right (exec_reply)", ret);

  if (acquired != MACH_MSG_TYPE_PORT_SEND_ONCE)
    error ("Incorrect right extracted, send once expected for exec reply");

  ret = mach_port_move_member (mach_task_self (),
			       fake_server,
			       inferior_wait_port_set);
  CHK ("Moving fake syscall port to inferior_wait_port_set", ret);

  xx_debug ("syscall fake server set up, resuming inferior\n");

  ret = task_resume (inferior_task);
  CHK ("task_resume (startup)", ret);

  /* Read requests from the inferior.
     Pass directly through everything else except exec() calls.
   */
  while (exec_counter > 0)
    {
      ret = mach_msg (&syscall_in.header,	/* header */
		      MACH_RCV_MSG,	/* options */
		      0,	/* send size */
		      sizeof (struct syscall_msg_t),	/* receive size */
		      inferior_wait_port_set,	/* receive_name */
		      MACH_MSG_TIMEOUT_NONE,
		      MACH_PORT_NULL);
      CHK ("mach_msg (intercepted sycall)", ret);

#ifdef DUMP_SYSCALL
      print_msg (&syscall_in.header);
#endif

      /* ASSERT : msgh_local_port == fake_server */

      if (notify_server (&syscall_in.header, &syscall_out.header))
	error ("received a notify while intercepting syscalls");

      if (syscall_in.header.msgh_id == MIG_EXEC_SYSCALL_ID)
	{
	  xx_debug ("Received EXEC SYSCALL, counter = %d\n", exec_counter);
	  if (exec_counter == 1)
	    {
	      original_exec_reply = syscall_in.header.msgh_remote_port;
	      syscall_in.header.msgh_remote_port = exec_reply_send;
	    }

	  if (!terminal_initted)
	    {
	      /* Now that the child has exec'd we know it has already set its
	         process group.  On POSIX systems, tcsetpgrp will fail with
	         EPERM if we try it before the child's setpgid.  */

	      /* Set up the "saved terminal modes" of the inferior
	         based on what modes we are starting it with.  */
	      target_terminal_init ();

	      /* Install inferior's terminal modes.  */
	      target_terminal_inferior ();

	      terminal_initted = 1;
	    }

	  exec_counter--;
	}

      syscall_in.header.msgh_local_port = syscall_in.header.msgh_remote_port;
      syscall_in.header.msgh_remote_port = original_server_send;

      reverse_msg_bits (&syscall_in.header, MACH_MSG_TYPE_COPY_SEND);

      ret = mach_msg_send (&syscall_in.header);
      CHK ("Forwarded syscall", ret);
    }

  ret = mach_port_move_member (mach_task_self (),
			       fake_server,
			       MACH_PORT_NULL);
  CHK ("Moving fake syscall out of inferior_wait_port_set", ret);

  ret = mach_port_move_member (mach_task_self (),
			       exec_reply,
			       inferior_wait_port_set);
  CHK ("Moving exec_reply to inferior_wait_port_set", ret);

  ret = mach_msg (&syscall_in.header,	/* header */
		  MACH_RCV_MSG,	/* options */
		  0,		/* send size */
		  sizeof (struct syscall_msg_t),	/* receive size */
		  inferior_wait_port_set,	/* receive_name */
		  MACH_MSG_TIMEOUT_NONE,
		  MACH_PORT_NULL);
  CHK ("mach_msg (exec reply)", ret);

  ret = task_suspend (inferior_task);
  CHK ("Suspending inferior after last exec", ret);

  must_suspend_thread = 0;

  xx_debug ("Received exec reply from bsd server, suspended inferior task\n");

#ifdef DUMP_SYSCALL
  print_msg (&syscall_in.header);
#endif

  /* Message should appear as if it came from the unix server */
  syscall_in.header.msgh_local_port = MACH_PORT_NULL;

  /*  and go to the inferior task original reply port */
  syscall_in.header.msgh_remote_port = original_exec_reply;

  reverse_msg_bits (&syscall_in.header, MACH_MSG_TYPE_MOVE_SEND_ONCE);

  ret = mach_msg_send (&syscall_in.header);
  CHK ("Forwarding exec reply to inferior", ret);

  /* Garbage collect */
  ret = mach_port_deallocate (inferior_task,
			      original_server_port_name);
  CHK ("deallocating fake server send right", ret);

  ret = mach_port_insert_right (inferior_task,
				original_server_port_name,
				original_server_send,
				MACH_MSG_TYPE_MOVE_SEND);
  CHK ("Restoring the original bsd server send right", ret);

  ret = mach_port_destroy (mach_task_self (),
			   fake_server);
  fake_server = MACH_PORT_DEAD;
  CHK ("mach_port_destroy (fake_server)", ret);

  ret = mach_port_destroy (mach_task_self (),
			   exec_reply);
  exec_reply = MACH_PORT_DEAD;
  CHK ("mach_port_destroy (exec_reply)", ret);

  xx_debug ("Done with exec call interception\n");
}

void
consume_send_rights (thread_array_t thread_list, int thread_count)
{
  int index;

  if (!thread_count)
    return;

  for (index = 0; index < thread_count; index++)
    {
      /* Since thread kill command kills threads, don't check ret */
      (void) mach_port_deallocate (mach_task_self (),
				   thread_list[index]);
    }
}

/* suspend/abort/resume a thread. */
setup_thread (mach_port_t thread, int what)
{
  kern_return_t ret;

  if (what)
    {
      ret = thread_suspend (thread);
      CHK ("setup_thread thread_suspend", ret);

      ret = thread_abort (thread);
      CHK ("setup_thread thread_abort", ret);
    }
  else
    {
      ret = thread_resume (thread);
      CHK ("setup_thread thread_resume", ret);
    }
}

int
map_slot_to_mid (int slot, thread_array_t threads, int thread_count)
{
  kern_return_t ret;
  int deallocate = 0;
  int index;
  int mid;

  if (!threads)
    {
      deallocate++;
      ret = task_threads (inferior_task, &threads, &thread_count);
      CHK ("Can not select a thread from a dead task", ret);
    }

  if (slot < 0 || slot >= thread_count)
    {
      if (deallocate)
	{
	  consume_send_rights (threads, thread_count);
	  (void) vm_deallocate (mach_task_self (), (vm_address_t) threads,
				(thread_count * sizeof (mach_port_t)));
	}
      if (slot < 0)
	error ("invalid slot number");
      else
	return -(slot + 1);
    }

  mid = map_port_name_to_mid (threads[slot], MACH_TYPE_THREAD);

  if (deallocate)
    {
      consume_send_rights (threads, thread_count);
      (void) vm_deallocate (mach_task_self (), (vm_address_t) threads,
			    (thread_count * sizeof (mach_port_t)));
    }

  return mid;
}

static int
parse_thread_id (char *arg, int thread_count, int slots)
{
  kern_return_t ret;
  int mid;
  int slot;
  int index;

  if (arg == 0)
    return 0;

  while (*arg && (*arg == ' ' || *arg == '\t'))
    arg++;

  if (!*arg)
    return 0;

  /* Currently parse MID and @@SLOTNUMBER */
  if (*arg != '@@')
    {
      mid = atoi (arg);
      if (mid <= 0)
	error ("valid thread mid expected");
      return mid;
    }

  arg++;
  slot = atoi (arg);

  if (slot < 0)
    error ("invalid slot number");

  /* If you want slot numbers to remain slot numbers, set slots.

   * Well, since 0 is reserved, return the ordinal number
   * of the thread rather than the slot number. Awk, this
   * counts as a kludge.
   */
  if (slots)
    return -(slot + 1);

  if (thread_count && slot >= thread_count)
    return -(slot + 1);

  mid = map_slot_to_mid (slot);

  return mid;
}

/* THREAD_ID 0 is special; it selects the first kernel
 * thread from the list (i.e. SLOTNUMBER 0)
 * This is used when starting the program with 'run' or when attaching.
 *
 * If FLAG is 0 the context is not changed, and the registers, frame, etc
 * will continue to describe the old thread.
 *
 * If FLAG is nonzero, really select the thread.
 * If FLAG is 2, the THREAD_ID is a slotnumber instead of a mid.
 * 
 */
kern_return_t
select_thread (mach_port_t task, int thread_id, int flag)
{
  thread_array_t thread_list;
  int thread_count;
  kern_return_t ret;
  int index;
  thread_t new_thread = MACH_PORT_NULL;

  if (thread_id < 0)
    error ("Can't select cprocs without kernel thread");

  ret = task_threads (task, &thread_list, &thread_count);
  if (ret != KERN_SUCCESS)
    {
      warning ("Can not select a thread from a dead task");
      m3_kill_inferior ();
      return KERN_FAILURE;
    }

  if (thread_count == 0)
    {
      /* The task can not do anything anymore, but it still
       * exists as a container for memory and ports.
       */
      registers_changed ();
      warning ("Task %d has no threads",
	       map_port_name_to_mid (task, MACH_TYPE_TASK));
      current_thread = MACH_PORT_NULL;
      (void) vm_deallocate (mach_task_self (),
			    (vm_address_t) thread_list,
			    (thread_count * sizeof (mach_port_t)));
      return KERN_FAILURE;
    }

  if (!thread_id || flag == 2)
    {
      /* First thread or a slotnumber */
      if (!thread_id)
	new_thread = thread_list[0];
      else
	{
	  if (thread_id < thread_count)
	    new_thread = thread_list[thread_id];
	  else
	    {
	      (void) vm_deallocate (mach_task_self (),
				    (vm_address_t) thread_list,
				    (thread_count * sizeof (mach_port_t)));
	      error ("No such thread slot number : %d", thread_id);
	    }
	}
    }
  else
    {
      for (index = 0; index < thread_count; index++)
	if (thread_id == map_port_name_to_mid (thread_list[index],
					       MACH_TYPE_THREAD))
	  {
	    new_thread = thread_list[index];
	    index = -1;
	    break;
	  }

      if (index != -1)
	error ("No thread with mid %d", thread_id);
    }

  /* Notify when the selected thread dies */
  request_notify (new_thread, MACH_NOTIFY_DEAD_NAME, MACH_TYPE_THREAD);

  ret = vm_deallocate (mach_task_self (),
		       (vm_address_t) thread_list,
		       (thread_count * sizeof (mach_port_t)));
  CHK ("vm_deallocate", ret);

  if (!flag)
    current_thread = new_thread;
  else
    {
#if 0
      if (MACH_PORT_VALID (current_thread))
	{
	  /* Store the gdb's view of the thread we are deselecting

	   * @@@@ I think gdb updates registers immediately when they are
	   * changed, so don't do this.
	   */
	  ret = thread_abort (current_thread);
	  CHK ("Could not abort system calls when saving state of old thread",
	       ret);
	  target_prepare_to_store ();
	  target_store_registers (-1);
	}
#endif

      registers_changed ();

      current_thread = new_thread;

      ret = thread_abort (current_thread);
      CHK ("Could not abort system calls when selecting a thread", ret);

      stop_pc = read_pc ();
      flush_cached_frames ();

      select_frame (get_current_frame ());
    }

  return KERN_SUCCESS;
}

/*
 * Switch to use thread named NEW_THREAD.
 * Return it's MID
 */
int
switch_to_thread (thread_t new_thread)
{
  thread_t saved_thread = current_thread;
  int mid;

  mid = map_port_name_to_mid (new_thread,
			      MACH_TYPE_THREAD);
  if (mid == -1)
    warning ("Can't map thread name 0x%x to mid", new_thread);
  else if (select_thread (inferior_task, mid, 1) != KERN_SUCCESS)
    {
      if (current_thread)
	current_thread = saved_thread;
      error ("Could not select thread %d", mid);
    }

  return mid;
}

/* Do this in gdb after doing FORK but before STARTUP_INFERIOR.
 * Note that the registers are not yet valid in the inferior task.
 */
static int
m3_trace_him (int pid)
{
  kern_return_t ret;

  push_target (&m3_ops);

  inferior_task = task_by_pid (pid);

  if (!MACH_PORT_VALID (inferior_task))
    error ("Can not map Unix pid %d to Mach task", pid);

  /* Clean up previous notifications and create new ones */
  setup_notify_port (1);

  /* When notification appears, the inferior task has died */
  request_notify (inferior_task, MACH_NOTIFY_DEAD_NAME, MACH_TYPE_TASK);

  emulator_present = have_emulator_p (inferior_task);

  /* By default, select the first thread,
   * If task has no threads, gives a warning
   * Does not fetch registers, since they are not yet valid.
   */
  select_thread (inferior_task, 0, 0);

  inferior_exception_port = MACH_PORT_NULL;

  setup_exception_port ();

  xx_debug ("Now the debugged task is created\n");

  /* One trap to exec the shell, one to exec the program being debugged.  */
  intercept_exec_calls (2);

  return pid;
}

setup_exception_port (void)
{
  kern_return_t ret;

  ret = mach_port_allocate (mach_task_self (),
			    MACH_PORT_RIGHT_RECEIVE,
			    &inferior_exception_port);
  CHK ("mach_port_allocate", ret);

  /* add send right */
  ret = mach_port_insert_right (mach_task_self (),
				inferior_exception_port,
				inferior_exception_port,
				MACH_MSG_TYPE_MAKE_SEND);
  CHK ("mach_port_insert_right", ret);

  ret = mach_port_move_member (mach_task_self (),
			       inferior_exception_port,
			       inferior_wait_port_set);
  CHK ("mach_port_move_member", ret);

  ret = task_get_special_port (inferior_task,
			       TASK_EXCEPTION_PORT,
			       &inferior_old_exception_port);
  CHK ("task_get_special_port(old exc)", ret);

  ret = task_set_special_port (inferior_task,
			       TASK_EXCEPTION_PORT,
			       inferior_exception_port);
  CHK ("task_set_special_port", ret);

  ret = mach_port_deallocate (mach_task_self (),
			      inferior_exception_port);
  CHK ("mack_port_deallocate", ret);

#if 0
  /* When notify appears, the inferior_task's exception
   * port has been destroyed.
   *
   * Not used, since the dead_name_notification already
   * appears when task dies.
   *
   */
  request_notify (inferior_exception_port,
		  MACH_NOTIFY_NO_SENDERS,
		  MACH_TYPE_EXCEPTION_PORT);
#endif
}

/* Nonzero if gdb is waiting for a message */
int mach_really_waiting;

/* Wait for the inferior to stop for some reason.
   - Loop on notifications until inferior_task dies.
   - Loop on exceptions until stopped_in_exception comes true.
   (e.g. we receive a single step trace trap)
   - a message arrives to gdb's message port

   There is no other way to exit this loop.

   Returns the inferior_ptid for rest of gdb.
   Side effects: Set *OURSTATUS.  */
ptid_t
mach_really_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  kern_return_t ret;
  int w;

  struct msg
    {
      mach_msg_header_t header;
      mach_msg_type_t foo;
      int data[8000];
    }
  in_msg, out_msg;

  /* Either notify (death), exception or message can stop the inferior */
  stopped_in_exception = FALSE;

  while (1)
    {
      QUIT;

      stop_exception = stop_code = stop_subcode = -1;
      stop_thread = MACH_PORT_NULL;

      mach_really_waiting = 1;
      ret = mach_msg (&in_msg.header,	/* header */
		      MACH_RCV_MSG,	/* options */
		      0,	/* send size */
		      sizeof (struct msg),	/* receive size */
		      currently_waiting_for,	/* receive name */
		      MACH_MSG_TIMEOUT_NONE,
		      MACH_PORT_NULL);
      mach_really_waiting = 0;
      CHK ("mach_msg (receive)", ret);

      /* Check if we received a notify of the childs' death */
      if (notify_server (&in_msg.header, &out_msg.header))
	{
	  /* If inferior_task is null then the inferior has
	     gone away and we want to return to command level.
	     Otherwise it was just an informative message and we
	     need to look to see if there are any more. */
	  if (inferior_task != MACH_PORT_NULL)
	    continue;
	  else
	    {
	      /* Collect Unix exit status for gdb */

	      wait3 (&w, WNOHANG, 0);

	      /* This mess is here to check that the rest of
	       * gdb knows that the inferior died. It also
	       * tries to hack around the fact that Mach 3.0 (mk69)
	       * unix server (ux28) does not always know what
	       * has happened to it's children when mach-magic
	       * is applied on them.
	       */
	      if ((!WIFEXITED (w) && WIFSTOPPED (w)) ||
		  (WIFEXITED (w) && WEXITSTATUS (w) > 0377))
		{
		  WSETEXIT (w, 0);
		  warning ("Using exit value 0 for terminated task");
		}
	      else if (!WIFEXITED (w))
		{
		  int sig = WTERMSIG (w);

		  /* Signals cause problems. Warn the user. */
		  if (sig != SIGKILL)	/* Bad luck if garbage matches this */
		    warning ("The terminating signal stuff may be nonsense");
		  else if (sig > NSIG)
		    {
		      WSETEXIT (w, 0);
		      warning ("Using exit value 0 for terminated task");
		    }
		}
	      store_waitstatus (ourstatus, w);
	      return inferior_ptid;
	    }
	}

      /* Hmm. Check for exception, as it was not a notification.
         exc_server() does an upcall to catch_exception_raise()
         if this rpc is an exception. Further actions are decided
         there.
       */
      if (!exc_server (&in_msg.header, &out_msg.header))
	{

	  /* Not an exception, check for message.

	   * Messages don't come from the inferior, or if they
	   * do they better be asynchronous or it will hang.
	   */
	  if (gdb_message_server (&in_msg.header))
	    continue;

	  error ("Unrecognized message received in mach_really_wait");
	}

      /* Send the reply of the exception rpc to the suspended task */
      ret = mach_msg_send (&out_msg.header);
      CHK ("mach_msg_send (exc reply)", ret);

      if (stopped_in_exception)
	{
	  /* Get unix state. May be changed in mach3_exception_actions() */
	  wait3 (&w, WNOHANG, 0);

	  mach3_exception_actions (&w, FALSE, "Task");

	  store_waitstatus (ourstatus, w);
	  return inferior_ptid;
	}
    }
}

/* Called by macro DO_QUIT() in utils.c(quit).
 * This is called just before calling error() to return to command level
 */
void
mach3_quit (void)
{
  int mid;
  kern_return_t ret;

  if (mach_really_waiting)
    {
      ret = task_suspend (inferior_task);

      if (ret != KERN_SUCCESS)
	{
	  warning ("Could not suspend task for interrupt: %s",
		   mach_error_string (ret));
	  mach_really_waiting = 0;
	  return;
	}
    }

  must_suspend_thread = 0;
  mach_really_waiting = 0;

  mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
  if (mid == -1)
    {
      warning ("Selecting first existing kernel thread");
      mid = 0;
    }

  current_thread = MACH_PORT_NULL;	/* Force setup */
  select_thread (inferior_task, mid, 1);

  return;
}

#if 0
/* bogus bogus bogus.  It is NOT OK to quit out of target_wait.  */

/* If ^C is typed when we are waiting for a message
 * and your Unix server is able to notice that we 
 * should quit now.
 *
 * Called by REQUEST_QUIT() from utils.c(request_quit)
 */
void
mach3_request_quit (void)
{
  if (mach_really_waiting)
    immediate_quit = 1;
}
#endif

/*
 * Gdb message server.
 * Currently implemented is the STOP message, that causes
 * gdb to return to the command level like ^C had been typed from terminal.
 */
int
gdb_message_server (mach_msg_header_t *InP)
{
  kern_return_t ret;
  int mid;

  if (InP->msgh_local_port == our_message_port)
    {
      /* A message coming to our_message_port. Check validity */
      switch (InP->msgh_id)
	{

	case GDB_MESSAGE_ID_STOP:
	  ret = task_suspend (inferior_task);
	  if (ret != KERN_SUCCESS)
	    warning ("Could not suspend task for stop message: %s",
		     mach_error_string (ret));

	  /* QUIT in mach_really_wait() loop. */
	  request_quit (0);
	  break;

	default:
	  warning ("Invalid message id %d received, ignored.",
		   InP->msgh_id);
	  break;
	}

      return 1;
    }

  /* Message not handled by this server */
  return 0;
}

/* NOTE: This is not an RPC call. It is a simpleroutine.

 * This is not called from this gdb code.
 *
 * It may be called by another debugger to cause this
 * debugger to enter command level:
 *
 *            (gdb) set stop_inferior_gdb ()
 *            (gdb) continue
 *
 * External program "stop-gdb" implements this also.
 */
void
stop_inferior_gdb (void)
{
  kern_return_t ret;

  /* Code generated by mig, with minor cleanups :-)

   * simpleroutine stop_inferior_gdb (our_message_port : mach_port_t);
   */

  typedef struct
    {
      mach_msg_header_t Head;
    }
  Request;

  Request Mess;

  register Request *InP = &Mess;

  InP->Head.msgh_bits = MACH_MSGH_BITS (MACH_MSG_TYPE_COPY_SEND, 0);

  /* msgh_size passed as argument */
  InP->Head.msgh_remote_port = our_message_port;
  InP->Head.msgh_local_port = MACH_PORT_NULL;
  InP->Head.msgh_seqno = 0;
  InP->Head.msgh_id = GDB_MESSAGE_ID_STOP;

  ret = mach_msg (&InP->Head,
		  MACH_SEND_MSG | MACH_MSG_OPTION_NONE,
		  sizeof (Request),
		  0,
		  MACH_PORT_NULL,
		  MACH_MSG_TIMEOUT_NONE,
		  MACH_PORT_NULL);
}

#ifdef THREAD_ALLOWED_TO_BREAK
/*
 * Return 1 if the MID specifies the thread that caused the
 * last exception.
 *  Since catch_exception_raise() selects the thread causing
 * the last exception to current_thread, we just check that
 * it is selected and the last exception was a breakpoint.
 */
int
mach_thread_for_breakpoint (int mid)
{
  int cmid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);

  if (mid < 0)
    {
      mid = map_slot_to_mid (-(mid + 1), 0, 0);
      if (mid < 0)
	return 0;		/* Don't stop, no such slot */
    }

  if (!mid || cmid == -1)
    return 1;			/* stop */

  return cmid == mid && stop_exception == EXC_BREAKPOINT;
}
#endif /* THREAD_ALLOWED_TO_BREAK */

#ifdef THREAD_PARSE_ID
/*
 * Map a thread id string (MID or a @@SLOTNUMBER)
 * to a thread-id.
 *
 *   0  matches all threads.
 *   Otherwise the meaning is defined only in this file.
 *   (mach_thread_for_breakpoint uses it)
 *
 * @@@@ This allows non-existent MIDs to be specified.
 *    It now also allows non-existent slots to be
 *    specified. (Slot numbers stored are negative,
 *    and the magnitude is one greater than the actual
 *    slot index. (Since 0 is reserved))
 */
int
mach_thread_parse_id (char *arg)
{
  int mid;
  if (arg == 0)
    error ("thread id expected");
  mid = parse_thread_id (arg, 0, 1);

  return mid;
}
#endif /* THREAD_PARSE_ID */

#ifdef THREAD_OUTPUT_ID
char *
mach_thread_output_id (int mid)
{
  static char foobar[20];

  if (mid > 0)
    sprintf (foobar, "mid %d", mid);
  else if (mid < 0)
    sprintf (foobar, "@@%d", -(mid + 1));
  else
    sprintf (foobar, "*any thread*");

  return foobar;
}
#endif /* THREAD_OUTPUT_ID */

/* Called with hook PREPARE_TO_PROCEED() from infrun.c.

 * If we have switched threads and stopped at breakpoint return 1 otherwise 0.
 *
 *  if SELECT_IT is nonzero, reselect the thread that was active when
 *  we stopped at a breakpoint.
 *
 * Note that this implementation is potentially redundant now that
 * default_prepare_to_proceed() has been added.  
 *
 * FIXME This may not support switching threads after Ctrl-C
 * correctly. The default implementation does support this.
 */

mach3_prepare_to_proceed (int select_it)
{
  if (stop_thread &&
      stop_thread != current_thread &&
      stop_exception == EXC_BREAKPOINT)
    {
      int mid;

      if (!select_it)
	return 1;

      mid = switch_to_thread (stop_thread);

      return 1;
    }

  return 0;
}

/* this stuff here is an upcall via libmach/excServer.c 
   and mach_really_wait which does the actual upcall.

   The code will pass the exception to the inferior if:

   - The task that signaled is not the inferior task
   (e.g. when debugging another debugger)

   - The user has explicitely requested to pass on the exceptions.
   (e.g to the default unix exception handler, which maps
   exceptions to signals, or the user has her own exception handler)

   - If the thread that signaled is being single-stepped and it
   has set it's own exception port and the exception is not
   EXC_BREAKPOINT. (Maybe this is not desirable?)
 */

kern_return_t
catch_exception_raise (mach_port_t port, thread_t thread, task_t task,
		       int exception, int code, int subcode)
{
  kern_return_t ret;
  boolean_t signal_thread;
  int mid = map_port_name_to_mid (thread, MACH_TYPE_THREAD);

  if (!MACH_PORT_VALID (thread))
    {
      /* If the exception was sent and thread dies before we
         receive it, THREAD will be MACH_PORT_DEAD
       */

      current_thread = thread = MACH_PORT_NULL;
      error ("Received exception from nonexistent thread");
    }

  /* Check if the task died in transit.
   * @@@@ Isn't the thread also invalid in such case?
   */
  if (!MACH_PORT_VALID (task))
    {
      current_thread = thread = MACH_PORT_NULL;
      error ("Received exception from nonexistent task");
    }

  if (exception < 0 || exception > MAX_EXCEPTION)
    internal_error (__FILE__, __LINE__,
		    "catch_exception_raise: unknown exception code %d thread %d",
		    exception,
		    mid);

  if (!MACH_PORT_VALID (inferior_task))
    error ("got an exception, but inferior_task is null or dead");

  stop_exception = exception;
  stop_code = code;
  stop_subcode = subcode;
  stop_thread = thread;

  signal_thread = exception != EXC_BREAKPOINT &&
    port == singlestepped_thread_port &&
    MACH_PORT_VALID (thread_saved_exception_port);

  /* If it was not our inferior or if we want to forward
   * the exception to the inferior's handler, do it here
   *
   * Note: If you have forwarded EXC_BREAKPOINT I trust you know why.
   */
  if (task != inferior_task ||
      signal_thread ||
      exception_map[exception].forward)
    {
      mach_port_t eport = inferior_old_exception_port;

      if (signal_thread)
	{
	  /*
	     GDB now forwards the exeption to thread's original handler,
	     since the user propably knows what he is doing.
	     Give a message, though.
	   */

	  mach3_exception_actions ((WAITTYPE *) NULL, TRUE, "Thread");
	  eport = thread_saved_exception_port;
	}

      /* Send the exception to the original handler */
      ret = exception_raise (eport,
			     thread,
			     task,
			     exception,
			     code,
			     subcode);

      (void) mach_port_deallocate (mach_task_self (), task);
      (void) mach_port_deallocate (mach_task_self (), thread);

      /* If we come here, we don't want to trace any more, since we
       * will never stop for tracing anyway.
       */
      discard_single_step (thread);

      /* Do not stop the inferior */
      return ret;
    }

  /* Now gdb handles the exception */
  stopped_in_exception = TRUE;

  ret = task_suspend (task);
  CHK ("Error suspending inferior after exception", ret);

  must_suspend_thread = 0;

  if (current_thread != thread)
    {
      if (MACH_PORT_VALID (singlestepped_thread_port))
	/* Cleanup discards single stepping */
	error ("Exception from thread %d while singlestepping thread %d",
	       mid,
	       map_port_name_to_mid (current_thread, MACH_TYPE_THREAD));

      /* Then select the thread that caused the exception */
      if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
	error ("Could not select thread %d causing exception", mid);
      else
	warning ("Gdb selected thread %d", mid);
    }

  /* If we receive an exception that is not breakpoint
   * exception, we interrupt the single step and return to
   * debugger. Trace condition is cleared.
   */
  if (MACH_PORT_VALID (singlestepped_thread_port))
    {
      if (stop_exception != EXC_BREAKPOINT)
	warning ("Single step interrupted by exception");
      else if (port == singlestepped_thread_port)
	{
	  /* Single step exception occurred, remove trace bit
	   * and return to gdb.
	   */
	  if (!MACH_PORT_VALID (current_thread))
	    error ("Single stepped thread is not valid");

	  /* Resume threads, but leave the task suspended */
	  resume_all_threads (0);
	}
      else
	warning ("Breakpoint while single stepping?");

      discard_single_step (current_thread);
    }

  (void) mach_port_deallocate (mach_task_self (), task);
  (void) mach_port_deallocate (mach_task_self (), thread);

  return KERN_SUCCESS;
}

int
port_valid (mach_port_t port, int mask)
{
  kern_return_t ret;
  mach_port_type_t type;

  ret = mach_port_type (mach_task_self (),
			port,
			&type);
  if (ret != KERN_SUCCESS || (type & mask) != mask)
    return 0;
  return 1;
}

/* @@@@ No vm read cache implemented yet */
boolean_t vm_read_cache_valid = FALSE;

/*
 * Read inferior task's LEN bytes from ADDR and copy it to MYADDR
 * in gdb's address space.
 *
 * Return 0 on failure; number of bytes read otherwise.
 */
int
mach3_read_inferior (CORE_ADDR addr, char *myaddr, int length)
{
  kern_return_t ret;
  vm_address_t low_address = (vm_address_t) trunc_page (addr);
  vm_size_t aligned_length =
  (vm_size_t) round_page (addr + length) - low_address;
  pointer_t copied_memory;
  int copy_count;

  /* Get memory from inferior with page aligned addresses */
  ret = vm_read (inferior_task,
		 low_address,
		 aligned_length,
		 &copied_memory,
		 &copy_count);
  if (ret != KERN_SUCCESS)
    {
      /* the problem is that the inferior might be killed for whatever reason
       * before we go to mach_really_wait. This is one place that ought to
       * catch many of those errors.
       * @@@@ A better fix would be to make all external events to GDB
       * to arrive via a SINGLE port set. (Including user input!)
       */

      if (!port_valid (inferior_task, MACH_PORT_TYPE_SEND))
	{
	  m3_kill_inferior ();
	  error ("Inferior killed (task port invalid)");
	}
      else
	{
#ifdef OSF
	  extern int errno;
	  /* valprint.c gives nicer format if this does not
	     screw it. Eamonn seems to like this, so I enable
	     it if OSF is defined...
	   */
	  warning ("[read inferior %x failed: %s]",
		   addr, mach_error_string (ret));
	  errno = 0;
#endif
	  return 0;
	}
    }

  memcpy (myaddr, (char *) addr - low_address + copied_memory, length);

  ret = vm_deallocate (mach_task_self (),
		       copied_memory,
		       copy_count);
  CHK ("mach3_read_inferior vm_deallocate failed", ret);

  return length;
}

#define CHK_GOTO_OUT(str,ret) \
  do if (ret != KERN_SUCCESS) { errstr = #str; goto out; } while(0)

struct vm_region_list
{
  struct vm_region_list *next;
  vm_prot_t protection;
  vm_address_t start;
  vm_size_t length;
};

struct obstack region_obstack;

/*
 * Write inferior task's LEN bytes from ADDR and copy it to MYADDR
 * in gdb's address space.
 */
int
mach3_write_inferior (CORE_ADDR addr, char *myaddr, int length)
{
  kern_return_t ret;
  vm_address_t low_address = (vm_address_t) trunc_page (addr);
  vm_size_t aligned_length =
  (vm_size_t) round_page (addr + length) - low_address;
  pointer_t copied_memory;
  int copy_count;
  int deallocate = 0;

  char *errstr = "Bug in mach3_write_inferior";

  struct vm_region_list *region_element;
  struct vm_region_list *region_head = (struct vm_region_list *) NULL;

  /* Get memory from inferior with page aligned addresses */
  ret = vm_read (inferior_task,
		 low_address,
		 aligned_length,
		 &copied_memory,
		 &copy_count);
  CHK_GOTO_OUT ("mach3_write_inferior vm_read failed", ret);

  deallocate++;

  memcpy ((char *) addr - low_address + copied_memory, myaddr, length);

  obstack_init (&region_obstack);

  /* Do writes atomically.
   * First check for holes and unwritable memory.
   */
  {
    vm_size_t remaining_length = aligned_length;
    vm_address_t region_address = low_address;

    struct vm_region_list *scan;

    while (region_address < low_address + aligned_length)
      {
	vm_prot_t protection;
	vm_prot_t max_protection;
	vm_inherit_t inheritance;
	boolean_t shared;
	mach_port_t object_name;
	vm_offset_t offset;
	vm_size_t region_length = remaining_length;
	vm_address_t old_address = region_address;

	ret = vm_region (inferior_task,
			 &region_address,
			 &region_length,
			 &protection,
			 &max_protection,
			 &inheritance,
			 &shared,
			 &object_name,
			 &offset);
	CHK_GOTO_OUT ("vm_region failed", ret);

	/* Check for holes in memory */
	if (old_address != region_address)
	  {
	    warning ("No memory at 0x%x. Nothing written",
		     old_address);
	    ret = KERN_SUCCESS;
	    length = 0;
	    goto out;
	  }

	if (!(max_protection & VM_PROT_WRITE))
	  {
	    warning ("Memory at address 0x%x is unwritable. Nothing written",
		     old_address);
	    ret = KERN_SUCCESS;
	    length = 0;
	    goto out;
	  }

	/* Chain the regions for later use */
	region_element =
	  (struct vm_region_list *)
	  obstack_alloc (&region_obstack, sizeof (struct vm_region_list));

	region_element->protection = protection;
	region_element->start = region_address;
	region_element->length = region_length;

	/* Chain the regions along with protections */
	region_element->next = region_head;
	region_head = region_element;

	region_address += region_length;
	remaining_length = remaining_length - region_length;
      }

    /* If things fail after this, we give up.
     * Somebody is messing up inferior_task's mappings.
     */

    /* Enable writes to the chained vm regions */
    for (scan = region_head; scan; scan = scan->next)
      {
	boolean_t protection_changed = FALSE;

	if (!(scan->protection & VM_PROT_WRITE))
	  {
	    ret = vm_protect (inferior_task,
			      scan->start,
			      scan->length,
			      FALSE,
			      scan->protection | VM_PROT_WRITE);
	    CHK_GOTO_OUT ("vm_protect: enable write failed", ret);
	  }
      }

    ret = vm_write (inferior_task,
		    low_address,
		    copied_memory,
		    aligned_length);
    CHK_GOTO_OUT ("vm_write failed", ret);

    /* Set up the original region protections, if they were changed */
    for (scan = region_head; scan; scan = scan->next)
      {
	boolean_t protection_changed = FALSE;

	if (!(scan->protection & VM_PROT_WRITE))
	  {
	    ret = vm_protect (inferior_task,
			      scan->start,
			      scan->length,
			      FALSE,
			      scan->protection);
	    CHK_GOTO_OUT ("vm_protect: enable write failed", ret);
	  }
      }
  }

out:
  if (deallocate)
    {
      obstack_free (&region_obstack, 0);

      (void) vm_deallocate (mach_task_self (),
			    copied_memory,
			    copy_count);
    }

  if (ret != KERN_SUCCESS)
    {
      warning ("%s %s", errstr, mach_error_string (ret));
      return 0;
    }

  return length;
}

/* Return 0 on failure, number of bytes handled otherwise.  TARGET is
   ignored. */
static int
m3_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		struct target_ops *target)
{
  int result;

  if (write)
    result = mach3_write_inferior (memaddr, myaddr, len);
  else
    result = mach3_read_inferior (memaddr, myaddr, len);

  return result;
}


static char *
translate_state (int state)
{
  switch (state)
    {
    case TH_STATE_RUNNING:
      return ("R");
    case TH_STATE_STOPPED:
      return ("S");
    case TH_STATE_WAITING:
      return ("W");
    case TH_STATE_UNINTERRUPTIBLE:
      return ("U");
    case TH_STATE_HALTED:
      return ("H");
    default:
      return ("?");
    }
}

static char *
translate_cstate (int state)
{
  switch (state)
    {
    case CPROC_RUNNING:
      return "R";
    case CPROC_SWITCHING:
      return "S";
    case CPROC_BLOCKED:
      return "B";
    case CPROC_CONDWAIT:
      return "C";
    case CPROC_CONDWAIT | CPROC_SWITCHING:
      return "CS";
    default:
      return "?";
    }
}

/* type == MACH_MSG_TYPE_COPY_SEND || type == MACH_MSG_TYPE_MAKE_SEND */

mach_port_t			/* no mach_port_name_t found in include files. */
map_inferior_port_name (mach_port_t inferior_name, mach_msg_type_name_t type)
{
  kern_return_t ret;
  mach_msg_type_name_t acquired;
  mach_port_t iport;

  ret = mach_port_extract_right (inferior_task,
				 inferior_name,
				 type,
				 &iport,
				 &acquired);
  CHK ("mach_port_extract_right (map_inferior_port_name)", ret);

  if (acquired != MACH_MSG_TYPE_PORT_SEND)
    error ("Incorrect right extracted, (map_inferior_port_name)");

  ret = mach_port_deallocate (mach_task_self (),
			      iport);
  CHK ("Deallocating mapped port (map_inferior_port_name)", ret);

  return iport;
}

/*
 * Naming convention:
 *  Always return user defined name if found.
 *  _K == A kernel thread with no matching CPROC
 *  _C == A cproc with no current cthread
 *  _t == A cthread with no user defined name
 *
 * The digits that follow the _names are the SLOT number of the
 * kernel thread if there is such a thing, otherwise just a negation
 * of the sequential number of such cprocs.
 */

static char buf[7];

static char *
get_thread_name (gdb_thread_t one_cproc, int id)
{
  if (one_cproc)
    if (one_cproc->cthread == NULL)
      {
	/* cproc not mapped to any cthread */
	sprintf (buf, "_C%d", id);
      }
    else if (!one_cproc->cthread->name)
      {
	/* cproc and cthread, but no name */
	sprintf (buf, "_t%d", id);
      }
    else
      return (char *) (one_cproc->cthread->name);
  else
    {
      if (id < 0)
	warning ("Inconsistency in thread name id %d", id);

      /* Kernel thread without cproc */
      sprintf (buf, "_K%d", id);
    }

  return buf;
}

int
fetch_thread_info (mach_port_t task, gdb_thread_t *mthreads_out)
{
  kern_return_t ret;
  thread_array_t th_table;
  int th_count;
  gdb_thread_t mthreads = NULL;
  int index;

  ret = task_threads (task, &th_table, &th_count);
  if (ret != KERN_SUCCESS)
    {
      warning ("Error getting inferior's thread list:%s",
	       mach_error_string (ret));
      m3_kill_inferior ();
      return -1;
    }

  mthreads = (gdb_thread_t)
    obstack_alloc
    (cproc_obstack,
     th_count * sizeof (struct gdb_thread));

  for (index = 0; index < th_count; index++)
    {
      thread_t saved_thread = MACH_PORT_NULL;
      int mid;

      if (must_suspend_thread)
	setup_thread (th_table[index], 1);

      if (th_table[index] != current_thread)
	{
	  saved_thread = current_thread;

	  mid = switch_to_thread (th_table[index]);
	}

      mthreads[index].name = th_table[index];
      mthreads[index].cproc = NULL;	/* map_cprocs_to_kernel_threads() */
      mthreads[index].in_emulator = FALSE;
      mthreads[index].slotid = index;

      mthreads[index].sp = read_register (SP_REGNUM);
      mthreads[index].fp = read_register (FP_REGNUM);
      mthreads[index].pc = read_pc ();

      if (MACH_PORT_VALID (saved_thread))
	mid = switch_to_thread (saved_thread);

      if (must_suspend_thread)
	setup_thread (th_table[index], 0);
    }

  consume_send_rights (th_table, th_count);
  ret = vm_deallocate (mach_task_self (), (vm_address_t) th_table,
		       (th_count * sizeof (mach_port_t)));
  if (ret != KERN_SUCCESS)
    {
      warning ("Error trying to deallocate thread list : %s",
	       mach_error_string (ret));
    }

  *mthreads_out = mthreads;

  return th_count;
}


/*
 * Current emulator always saves the USP on top of
 * emulator stack below struct emul_stack_top stuff.
 */
CORE_ADDR
fetch_usp_from_emulator_stack (CORE_ADDR sp)
{
  CORE_ADDR stack_pointer;

  sp = (sp & ~(EMULATOR_STACK_SIZE - 1)) +
    EMULATOR_STACK_SIZE - sizeof (struct emul_stack_top);

  if (mach3_read_inferior (sp,
			   &stack_pointer,
			   sizeof (CORE_ADDR)) != sizeof (CORE_ADDR))
    {
      warning ("Can't read user sp from emulator stack address 0x%x", sp);
      return 0;
    }

  return stack_pointer;
}

#ifdef MK67

/* get_emulation_vector() interface was changed after mk67 */
#define EMUL_VECTOR_COUNT 400	/* Value does not matter too much */

#endif /* MK67 */

/* Check if the emulator exists at task's address space.
 */
boolean_t
have_emulator_p (task_t task)
{
  kern_return_t ret;
#ifndef EMUL_VECTOR_COUNT
  vm_offset_t *emulation_vector;
  int n;
#else
  vm_offset_t emulation_vector[EMUL_VECTOR_COUNT];
  int n = EMUL_VECTOR_COUNT;
#endif
  int i;
  int vector_start;

  ret = task_get_emulation_vector (task,
				   &vector_start,
#ifndef EMUL_VECTOR_COUNT
				   &emulation_vector,
#else
				   emulation_vector,
#endif
				   &n);
  CHK ("task_get_emulation_vector", ret);
  xx_debug ("%d vectors from %d at 0x%08x\n",
	    n, vector_start, emulation_vector);

  for (i = 0; i < n; i++)
    {
      vm_offset_t entry = emulation_vector[i];

      if (EMULATOR_BASE <= entry && entry <= EMULATOR_END)
	return TRUE;
      else if (entry)
	{
	  static boolean_t informed = FALSE;
	  if (!informed)
	    {
	      warning ("Emulation vector address 0x08%x outside emulator space",
		       entry);
	      informed = TRUE;
	    }
	}
    }
  return FALSE;
}

/* Map cprocs to kernel threads and vice versa.  */

void
map_cprocs_to_kernel_threads (gdb_thread_t cprocs, gdb_thread_t mthreads,
			      int thread_count)
{
  int index;
  gdb_thread_t scan;
  boolean_t all_mapped = TRUE;
  LONGEST stack_base;
  LONGEST stack_size;

  for (scan = cprocs; scan; scan = scan->next)
    {
      /* Default to: no kernel thread for this cproc */
      scan->reverse_map = -1;

      /* Check if the cproc is found by its stack */
      for (index = 0; index < thread_count; index++)
	{
	  stack_base =
	    extract_signed_integer (scan->raw_cproc + CPROC_BASE_OFFSET,
				    CPROC_BASE_SIZE);
	  stack_size =
	    extract_signed_integer (scan->raw_cproc + CPROC_SIZE_OFFSET,
				    CPROC_SIZE_SIZE);
	  if ((mthreads + index)->sp > stack_base &&
	      (mthreads + index)->sp <= stack_base + stack_size)
	    {
	      (mthreads + index)->cproc = scan;
	      scan->reverse_map = index;
	      break;
	    }
	}
      all_mapped &= (scan->reverse_map != -1);
    }

  /* Check for threads that are currently in the emulator.
   * If so, they have a different stack, and the still unmapped
   * cprocs may well get mapped to these threads.
   * 
   * If:
   *  - cproc stack does not match any kernel thread stack pointer
   *  - there is at least one extra kernel thread
   *    that has no cproc mapped above.
   *  - some kernel thread stack pointer points to emulator space
   *  then we find the user stack pointer saved in the emulator
   *  stack, and try to map that to the cprocs.
   *
   * Also set in_emulator for kernel threads.
   */

  if (emulator_present)
    {
      for (index = 0; index < thread_count; index++)
	{
	  CORE_ADDR emul_sp;
	  CORE_ADDR usp;

	  gdb_thread_t mthread = (mthreads + index);
	  emul_sp = mthread->sp;

	  if (mthread->cproc == NULL &&
	      EMULATOR_BASE <= emul_sp && emul_sp <= EMULATOR_END)
	    {
	      mthread->in_emulator = emulator_present;

	      if (!all_mapped && cprocs)
		{
		  usp = fetch_usp_from_emulator_stack (emul_sp);

		  /* @@@@ Could be more accurate */
		  if (!usp)
		    error ("Zero stack pointer read from emulator?");

		  /* Try to match this stack pointer to the cprocs that
		   * don't yet have a kernel thread.
		   */
		  for (scan = cprocs; scan; scan = scan->next)
		    {

		      /* Check is this unmapped CPROC stack contains
		       * the user stack pointer saved in the
		       * emulator.
		       */
		      if (scan->reverse_map == -1)
			{
			  stack_base =
			    extract_signed_integer
			    (scan->raw_cproc + CPROC_BASE_OFFSET,
			     CPROC_BASE_SIZE);
			  stack_size =
			    extract_signed_integer
			    (scan->raw_cproc + CPROC_SIZE_OFFSET,
			     CPROC_SIZE_SIZE);
			  if (usp > stack_base &&
			      usp <= stack_base + stack_size)
			    {
			      mthread->cproc = scan;
			      scan->reverse_map = index;
			      break;
			    }
			}
		    }
		}
	    }
	}
    }
}

/*
 * Format of the thread_list command
 *
 *                   slot mid sel   name  emul ks susp  cstate wired   address
 */
#define TL_FORMAT "%-2.2s %5d%c %-10.10s %1.1s%s%-5.5s %-2.2s %-5.5s "

#define TL_HEADER "\n@@    MID  Name        KState CState   Where\n"

void
print_tl_address (struct ui_file *stream, CORE_ADDR pc)
{
  if (!lookup_minimal_symbol_by_pc (pc))
    fprintf_filtered (stream, local_hex_format (), pc);
  else
    {
      extern int addressprint;
      extern int asm_demangle;

      int store = addressprint;
      addressprint = 0;
      print_address_symbolic (pc, stream, asm_demangle, "");
      addressprint = store;
    }
}

/* For thread names, but also for gdb_message_port external name */
#define MAX_NAME_LEN 50

/* Returns the address of variable NAME or 0 if not found */
CORE_ADDR
lookup_address_of_variable (char *name)
{
  struct symbol *sym;
  CORE_ADDR symaddr = 0;
  struct minimal_symbol *msymbol;

  sym = lookup_symbol (name,
		       (struct block *) NULL,
		       VAR_NAMESPACE,
		       (int *) NULL,
		       (struct symtab **) NULL);

  if (sym)
    symaddr = SYMBOL_VALUE (sym);

  if (!symaddr)
    {
      msymbol = lookup_minimal_symbol (name, NULL, NULL);

      if (msymbol && msymbol->type == mst_data)
	symaddr = SYMBOL_VALUE_ADDRESS (msymbol);
    }

  return symaddr;
}

static gdb_thread_t
get_cprocs (void)
{
  gdb_thread_t cproc_head;
  gdb_thread_t cproc_copy;
  CORE_ADDR their_cprocs;
  char *buf;
  char *name;
  cthread_t cthread;
  CORE_ADDR symaddr;

  buf = alloca (TARGET_PTR_BIT / HOST_CHAR_BIT);
  symaddr = lookup_address_of_variable ("cproc_list");

  if (!symaddr)
    {
      /* cproc_list is not in a file compiled with debugging
         symbols, but don't give up yet */

      symaddr = lookup_address_of_variable ("cprocs");

      if (symaddr)
	{
	  static int informed = 0;
	  if (!informed)
	    {
	      informed++;
	      warning ("Your program is loaded with an old threads library.");
	      warning ("GDB does not know the old form of threads");
	      warning ("so things may not work.");
	    }
	}
    }

  /* Stripped or no -lthreads loaded or "cproc_list" is in wrong segment. */
  if (!symaddr)
    return NULL;

  /* Get the address of the first cproc in the task */
  if (!mach3_read_inferior (symaddr,
			    buf,
			    TARGET_PTR_BIT / HOST_CHAR_BIT))
    error ("Can't read cproc master list at address (0x%x).", symaddr);
  their_cprocs = extract_address (buf, TARGET_PTR_BIT / HOST_CHAR_BIT);

  /* Scan the CPROCs in the task.
     CPROCs are chained with LIST field, not NEXT field, which
     chains mutexes, condition variables and queues */

  cproc_head = NULL;

  while (their_cprocs != (CORE_ADDR) 0)
    {
      CORE_ADDR cproc_copy_incarnation;
      cproc_copy = (gdb_thread_t) obstack_alloc (cproc_obstack,
						 sizeof (struct gdb_thread));

      if (!mach3_read_inferior (their_cprocs,
				&cproc_copy->raw_cproc[0],
				CPROC_SIZE))
	error ("Can't read next cproc at 0x%x.", their_cprocs);

      their_cprocs =
	extract_address (cproc_copy->raw_cproc + CPROC_LIST_OFFSET,
			 CPROC_LIST_SIZE);
      cproc_copy_incarnation =
	extract_address (cproc_copy->raw_cproc + CPROC_INCARNATION_OFFSET,
			 CPROC_INCARNATION_SIZE);

      if (cproc_copy_incarnation == (CORE_ADDR) 0)
	cproc_copy->cthread = NULL;
      else
	{
	  /* This CPROC has an attached CTHREAD. Get its name */
	  cthread = (cthread_t) obstack_alloc (cproc_obstack,
					       sizeof (struct cthread));

	  if (!mach3_read_inferior (cproc_copy_incarnation,
				    cthread,
				    sizeof (struct cthread)))
	      error ("Can't read next thread at 0x%x.",
		     cproc_copy_incarnation);

	  cproc_copy->cthread = cthread;

	  if (cthread->name)
	    {
	      name = (char *) obstack_alloc (cproc_obstack, MAX_NAME_LEN);

	      if (!mach3_read_inferior (cthread->name, name, MAX_NAME_LEN))
		error ("Can't read next thread's name at 0x%x.", cthread->name);

	      cthread->name = name;
	    }
	}

      /* insert in front */
      cproc_copy->next = cproc_head;
      cproc_head = cproc_copy;
    }
  return cproc_head;
}

#ifndef FETCH_CPROC_STATE
/*
 * Check if your machine does not grok the way this routine
 * fetches the FP,PC and SP of a cproc that is not
 * currently attached to any kernel thread (e.g. its cproc.context
 * field points to the place in stack where the context
 * is saved).
 *
 * If it doesn't, define your own routine.
 */
#define FETCH_CPROC_STATE(mth) mach3_cproc_state (mth)

int
mach3_cproc_state (gdb_thread_t mthread)
{
  int context;

  if (!mthread || !mthread->cproc)
    return -1;

  context = extract_signed_integer
    (mthread->cproc->raw_cproc + CPROC_CONTEXT_OFFSET,
     CPROC_CONTEXT_SIZE);
  if (context == 0)
    return -1;

  mthread->sp = context + MACHINE_CPROC_SP_OFFSET;

  if (mach3_read_inferior (context + MACHINE_CPROC_PC_OFFSET,
			   &mthread->pc,
			   sizeof (CORE_ADDR)) != sizeof (CORE_ADDR))
    {
      warning ("Can't read cproc pc from inferior");
      return -1;
    }

  if (mach3_read_inferior (context + MACHINE_CPROC_FP_OFFSET,
			   &mthread->fp,
			   sizeof (CORE_ADDR)) != sizeof (CORE_ADDR))
    {
      warning ("Can't read cproc fp from inferior");
      return -1;
    }

  return 0;
}
#endif /* FETCH_CPROC_STATE */


void
thread_list_command (void)
{
  thread_basic_info_data_t ths;
  int thread_count;
  gdb_thread_t cprocs;
  gdb_thread_t scan;
  int index;
  char *name;
  char selected;
  char *wired;
  int infoCnt;
  kern_return_t ret;
  mach_port_t mid_or_port;
  gdb_thread_t their_threads;
  gdb_thread_t kthread;

  int neworder = 1;

  char *fmt = "There are %d kernel threads in task %d.\n";

  int tmid = map_port_name_to_mid (inferior_task, MACH_TYPE_TASK);

  MACH_ERROR_NO_INFERIOR;

  thread_count = fetch_thread_info (inferior_task,
				    &their_threads);
  if (thread_count == -1)
    return;

  if (thread_count == 1)
    fmt = "There is %d kernel thread in task %d.\n";

  printf_filtered (fmt, thread_count, tmid);

  puts_filtered (TL_HEADER);

  cprocs = get_cprocs ();

  map_cprocs_to_kernel_threads (cprocs, their_threads, thread_count);

  for (scan = cprocs; scan; scan = scan->next)
    {
      int mid;
      char buf[10];
      char slot[3];
      int cproc_state =
      extract_signed_integer
      (scan->raw_cproc + CPROC_STATE_OFFSET, CPROC_STATE_SIZE);

      selected = ' ';

      /* a wired cproc? */
      wired = (extract_address (scan->raw_cproc + CPROC_WIRED_OFFSET,
				CPROC_WIRED_SIZE)
	       ? "wired" : "");

      if (scan->reverse_map != -1)
	kthread = (their_threads + scan->reverse_map);
      else
	kthread = NULL;

      if (kthread)
	{
	  /* These cprocs have a kernel thread */

	  mid = map_port_name_to_mid (kthread->name, MACH_TYPE_THREAD);

	  infoCnt = THREAD_BASIC_INFO_COUNT;

	  ret = thread_info (kthread->name,
			     THREAD_BASIC_INFO,
			     (thread_info_t) & ths,
			     &infoCnt);

	  if (ret != KERN_SUCCESS)
	    {
	      warning ("Unable to get basic info on thread %d : %s",
		       mid,
		       mach_error_string (ret));
	      continue;
	    }

	  /* Who is the first to have more than 100 threads */
	  sprintf (slot, "%d", kthread->slotid % 100);

	  if (kthread->name == current_thread)
	    selected = '*';

	  if (ths.suspend_count)
	    sprintf (buf, "%d", ths.suspend_count);
	  else
	    buf[0] = '\000';

#if 0
	  if (ths.flags & TH_FLAGS_SWAPPED)
	    strcat (buf, "S");
#endif

	  if (ths.flags & TH_FLAGS_IDLE)
	    strcat (buf, "I");

	  printf_filtered (TL_FORMAT,
			   slot,
			   mid,
			   selected,
			   get_thread_name (scan, kthread->slotid),
			   kthread->in_emulator ? "E" : "",
			   translate_state (ths.run_state),
			   buf,
			   translate_cstate (cproc_state),
			   wired);
	  print_tl_address (gdb_stdout, kthread->pc);
	}
      else
	{
	  /* These cprocs don't have a kernel thread.
	   * find out the calling frame with 
	   * FETCH_CPROC_STATE.
	   */

	  struct gdb_thread state;

#if 0
	  /* jtv -> emcmanus: why do you want this here? */
	  if (scan->incarnation == NULL)
	    continue;		/* EMcM */
#endif

	  printf_filtered (TL_FORMAT,
			   "-",
			   -neworder,	/* Pseudo MID */
			   selected,
			   get_thread_name (scan, -neworder),
			   "",
			   "-",	/* kernel state */
			   "",
			   translate_cstate (cproc_state),
			   "");
	  state.cproc = scan;

	  if (FETCH_CPROC_STATE (&state) == -1)
	    puts_filtered ("???");
	  else
	    print_tl_address (gdb_stdout, state.pc);

	  neworder++;
	}
      puts_filtered ("\n");
    }

  /* Scan for kernel threads without cprocs */
  for (index = 0; index < thread_count; index++)
    {
      if (!their_threads[index].cproc)
	{
	  int mid;

	  char buf[10];
	  char slot[3];

	  mach_port_t name = their_threads[index].name;

	  mid = map_port_name_to_mid (name, MACH_TYPE_THREAD);

	  infoCnt = THREAD_BASIC_INFO_COUNT;

	  ret = thread_info (name,
			     THREAD_BASIC_INFO,
			     (thread_info_t) & ths,
			     &infoCnt);

	  if (ret != KERN_SUCCESS)
	    {
	      warning ("Unable to get basic info on thread %d : %s",
		       mid,
		       mach_error_string (ret));
	      continue;
	    }

	  sprintf (slot, "%d", index % 100);

	  if (name == current_thread)
	    selected = '*';
	  else
	    selected = ' ';

	  if (ths.suspend_count)
	    sprintf (buf, "%d", ths.suspend_count);
	  else
	    buf[0] = '\000';

#if 0
	  if (ths.flags & TH_FLAGS_SWAPPED)
	    strcat (buf, "S");
#endif

	  if (ths.flags & TH_FLAGS_IDLE)
	    strcat (buf, "I");

	  printf_filtered (TL_FORMAT,
			   slot,
			   mid,
			   selected,
			   get_thread_name (NULL, index),
			   their_threads[index].in_emulator ? "E" : "",
			   translate_state (ths.run_state),
			   buf,
			   "",	/* No cproc state */
			   "");	/* Can't be wired */
	  print_tl_address (gdb_stdout, their_threads[index].pc);
	  puts_filtered ("\n");
	}
    }

  obstack_free (cproc_obstack, 0);
  obstack_init (cproc_obstack);
}

void
thread_select_command (char *args, int from_tty)
{
  int mid;
  thread_array_t thread_list;
  int thread_count;
  kern_return_t ret;
  int is_slot = 0;

  MACH_ERROR_NO_INFERIOR;

  if (!args)
    error_no_arg ("MID or @@SLOTNUMBER to specify a thread to select");

  while (*args == ' ' || *args == '\t')
    args++;

  if (*args == '@@')
    {
      is_slot++;
      args++;
    }

  mid = atoi (args);

  if (mid == 0)
    if (!is_slot || *args != '0')	/* Rudimentary checks */
      error ("You must select threads by MID or @@SLOTNUMBER");

  if (select_thread (inferior_task, mid, is_slot ? 2 : 1) != KERN_SUCCESS)
    return;

  if (from_tty)
    printf_filtered ("Thread %d selected\n",
		     is_slot ? map_port_name_to_mid (current_thread,
						   MACH_TYPE_THREAD) : mid);
}

thread_trace (mach_port_t thread, boolean_t set)
{
  int flavor = TRACE_FLAVOR;
  unsigned int stateCnt = TRACE_FLAVOR_SIZE;
  kern_return_t ret;
  thread_state_data_t state;

  if (!MACH_PORT_VALID (thread))
    {
      warning ("thread_trace: invalid thread");
      return;
    }

  if (must_suspend_thread)
    setup_thread (thread, 1);

  ret = thread_get_state (thread, flavor, state, &stateCnt);
  CHK ("thread_trace: error reading thread state", ret);

  if (set)
    {
      TRACE_SET (thread, state);
    }
  else
    {
      if (!TRACE_CLEAR (thread, state))
	{
	  if (must_suspend_thread)
	    setup_thread (thread, 0);
	  return;
	}
    }

  ret = thread_set_state (thread, flavor, state, stateCnt);
  CHK ("thread_trace: error writing thread state", ret);
  if (must_suspend_thread)
    setup_thread (thread, 0);
}

#ifdef	FLUSH_INFERIOR_CACHE

/* When over-writing code on some machines the I-Cache must be flushed
   explicitly, because it is not kept coherent by the lazy hardware.
   This definitely includes breakpoints, for instance, or else we
   end up looping in mysterious Bpt traps */

flush_inferior_icache (CORE_ADDR pc, int amount)
{
  vm_machine_attribute_val_t flush = MATTR_VAL_ICACHE_FLUSH;
  kern_return_t ret;

  ret = vm_machine_attribute (inferior_task,
			      pc,
			      amount,
			      MATTR_CACHE,
			      &flush);
  if (ret != KERN_SUCCESS)
    warning ("Error flushing inferior's cache : %s",
	     mach_error_string (ret));
}
#endif /* FLUSH_INFERIOR_CACHE */


static
suspend_all_threads (int from_tty)
{
  kern_return_t ret;
  thread_array_t thread_list;
  int thread_count, index;
  int infoCnt;
  thread_basic_info_data_t th_info;


  ret = task_threads (inferior_task, &thread_list, &thread_count);
  if (ret != KERN_SUCCESS)
    {
      warning ("Could not suspend inferior threads.");
      m3_kill_inferior ();
      throw_exception (RETURN_ERROR);
    }

  for (index = 0; index < thread_count; index++)
    {
      int mid;

      mid = map_port_name_to_mid (thread_list[index],
				  MACH_TYPE_THREAD);

      ret = thread_suspend (thread_list[index]);

      if (ret != KERN_SUCCESS)
	warning ("Error trying to suspend thread %d : %s",
		 mid, mach_error_string (ret));

      if (from_tty)
	{
	  infoCnt = THREAD_BASIC_INFO_COUNT;
	  ret = thread_info (thread_list[index],
			     THREAD_BASIC_INFO,
			     (thread_info_t) & th_info,
			     &infoCnt);
	  CHK ("suspend can't get thread info", ret);

	  warning ("Thread %d suspend count is %d",
		   mid, th_info.suspend_count);
	}
    }

  consume_send_rights (thread_list, thread_count);
  ret = vm_deallocate (mach_task_self (),
		       (vm_address_t) thread_list,
		       (thread_count * sizeof (int)));
  CHK ("Error trying to deallocate thread list", ret);
}

void
thread_suspend_command (char *args, int from_tty)
{
  kern_return_t ret;
  int mid;
  mach_port_t saved_thread;
  int infoCnt;
  thread_basic_info_data_t th_info;

  MACH_ERROR_NO_INFERIOR;

  if (!strcasecmp (args, "all"))
    {
      suspend_all_threads (from_tty);
      return;
    }

  saved_thread = current_thread;

  mid = parse_thread_id (args, 0, 0);

  if (mid < 0)
    error ("You can suspend only existing kernel threads with MID or @@SLOTNUMBER");

  if (mid == 0)
    mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
  else if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
    {
      if (current_thread)
	current_thread = saved_thread;
      error ("Could not select thread %d", mid);
    }

  ret = thread_suspend (current_thread);
  if (ret != KERN_SUCCESS)
    warning ("thread_suspend failed : %s",
	     mach_error_string (ret));

  infoCnt = THREAD_BASIC_INFO_COUNT;
  ret = thread_info (current_thread,
		     THREAD_BASIC_INFO,
		     (thread_info_t) & th_info,
		     &infoCnt);
  CHK ("suspend can't get thread info", ret);

  warning ("Thread %d suspend count is %d", mid, th_info.suspend_count);

  current_thread = saved_thread;
}

resume_all_threads (int from_tty)
{
  kern_return_t ret;
  thread_array_t thread_list;
  int thread_count, index;
  int mid;
  int infoCnt;
  thread_basic_info_data_t th_info;

  ret = task_threads (inferior_task, &thread_list, &thread_count);
  if (ret != KERN_SUCCESS)
    {
      m3_kill_inferior ();
      error ("task_threads", mach_error_string (ret));
    }

  for (index = 0; index < thread_count; index++)
    {
      infoCnt = THREAD_BASIC_INFO_COUNT;
      ret = thread_info (thread_list[index],
			 THREAD_BASIC_INFO,
			 (thread_info_t) & th_info,
			 &infoCnt);
      CHK ("resume_all can't get thread info", ret);

      mid = map_port_name_to_mid (thread_list[index],
				  MACH_TYPE_THREAD);

      if (!th_info.suspend_count)
	{
	  if (mid != -1 && from_tty)
	    warning ("Thread %d is not suspended", mid);
	  continue;
	}

      ret = thread_resume (thread_list[index]);

      if (ret != KERN_SUCCESS)
	warning ("Error trying to resume thread %d : %s",
		 mid, mach_error_string (ret));
      else if (mid != -1 && from_tty)
	warning ("Thread %d suspend count is %d",
		 mid, --th_info.suspend_count);
    }

  consume_send_rights (thread_list, thread_count);
  ret = vm_deallocate (mach_task_self (),
		       (vm_address_t) thread_list,
		       (thread_count * sizeof (int)));
  CHK ("Error trying to deallocate thread list", ret);
}

void
thread_resume_command (char *args, int from_tty)
{
  int mid;
  mach_port_t saved_thread;
  kern_return_t ret;
  thread_basic_info_data_t th_info;
  int infoCnt = THREAD_BASIC_INFO_COUNT;

  MACH_ERROR_NO_INFERIOR;

  if (!strcasecmp (args, "all"))
    {
      resume_all_threads (from_tty);
      return;
    }

  saved_thread = current_thread;

  mid = parse_thread_id (args, 0, 0);

  if (mid < 0)
    error ("You can resume only existing kernel threads with MID or @@SLOTNUMBER");

  if (mid == 0)
    mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
  else if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
    {
      if (current_thread)
	current_thread = saved_thread;
      throw_exception (RETURN_ERROR);
    }

  ret = thread_info (current_thread,
		     THREAD_BASIC_INFO,
		     (thread_info_t) & th_info,
		     &infoCnt);
  CHK ("resume can't get thread info", ret);

  if (!th_info.suspend_count)
    {
      warning ("Thread %d is not suspended", mid);
      goto out;
    }

  ret = thread_resume (current_thread);
  if (ret != KERN_SUCCESS)
    warning ("thread_resume failed : %s",
	     mach_error_string (ret));
  else
    {
      th_info.suspend_count--;
      warning ("Thread %d suspend count is %d", mid, th_info.suspend_count);
    }

out:
  current_thread = saved_thread;
}

void
thread_kill_command (char *args, int from_tty)
{
  int mid;
  kern_return_t ret;
  int thread_count;
  thread_array_t thread_table;
  int index;
  mach_port_t thread_to_kill = MACH_PORT_NULL;


  MACH_ERROR_NO_INFERIOR;

  if (!args)
    error_no_arg ("thread mid to kill from the inferior task");

  mid = parse_thread_id (args, 0, 0);

  if (mid < 0)
    error ("You can kill only existing kernel threads with MID or @@SLOTNUMBER");

  if (mid)
    {
      ret = machid_mach_port (mid_server, mid_auth, mid, &thread_to_kill);
      CHK ("thread_kill_command: machid_mach_port map failed", ret);
    }
  else
    mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);

  /* Don't allow gdb to kill *any* thread in the system. Use mkill program for that */
  ret = task_threads (inferior_task, &thread_table, &thread_count);
  CHK ("Error getting inferior's thread list", ret);

  if (thread_to_kill == current_thread)
    {
      ret = thread_terminate (thread_to_kill);
      CHK ("Thread could not be terminated", ret);

      if (select_thread (inferior_task, 0, 1) != KERN_SUCCESS)
	warning ("Last thread was killed, use \"kill\" command to kill task");
    }
  else
    for (index = 0; index < thread_count; index++)
      if (thread_table[index] == thread_to_kill)
	{
	  ret = thread_terminate (thread_to_kill);
	  CHK ("Thread could not be terminated", ret);
	}

  if (thread_count > 1)
    consume_send_rights (thread_table, thread_count);

  ret = vm_deallocate (mach_task_self (), (vm_address_t) thread_table,
		       (thread_count * sizeof (mach_port_t)));
  CHK ("Error trying to deallocate thread list", ret);

  warning ("Thread %d killed", mid);
}


/* Task specific commands; add more if you like */

void
task_resume_command (char *args, int from_tty)
{
  kern_return_t ret;
  task_basic_info_data_t ta_info;
  int infoCnt = TASK_BASIC_INFO_COUNT;
  int mid = map_port_name_to_mid (inferior_task, MACH_TYPE_TASK);

  MACH_ERROR_NO_INFERIOR;

  /* Would be trivial to change, but is it desirable? */
  if (args)
    error ("Currently gdb can resume only it's inferior task");

  ret = task_info (inferior_task,
		   TASK_BASIC_INFO,
		   (task_info_t) & ta_info,
		   &infoCnt);
  CHK ("task_resume_command: task_info failed", ret);

  if (ta_info.suspend_count == 0)
    error ("Inferior task %d is not suspended", mid);
  else if (ta_info.suspend_count == 1 &&
	   from_tty &&
	!query ("Suspend count is now 1. Do you know what you are doing? "))
    error ("Task not resumed");

  ret = task_resume (inferior_task);
  CHK ("task_resume_command: task_resume", ret);

  if (ta_info.suspend_count == 1)
    {
      warning ("Inferior task %d is no longer suspended", mid);
      must_suspend_thread = 1;
      /* @@@@ This is not complete: Registers change all the time when not
         suspended! */
      registers_changed ();
    }
  else
    warning ("Inferior task %d suspend count is now %d",
	     mid, ta_info.suspend_count - 1);
}


void
task_suspend_command (char *args, int from_tty)
{
  kern_return_t ret;
  task_basic_info_data_t ta_info;
  int infoCnt = TASK_BASIC_INFO_COUNT;
  int mid = map_port_name_to_mid (inferior_task, MACH_TYPE_TASK);

  MACH_ERROR_NO_INFERIOR;

  /* Would be trivial to change, but is it desirable? */
  if (args)
    error ("Currently gdb can suspend only it's inferior task");

  ret = task_suspend (inferior_task);
  CHK ("task_suspend_command: task_suspend", ret);

  must_suspend_thread = 0;

  ret = task_info (inferior_task,
		   TASK_BASIC_INFO,
		   (task_info_t) & ta_info,
		   &infoCnt);
  CHK ("task_suspend_command: task_info failed", ret);

  warning ("Inferior task %d suspend count is now %d",
	   mid, ta_info.suspend_count);
}

static char *
get_size (int bytes)
{
  static char size[30];
  int zz = bytes / 1024;

  if (zz / 1024)
    sprintf (size, "%-2.1f M", ((float) bytes) / (1024.0 * 1024.0));
  else
    sprintf (size, "%d K", zz);

  return size;
}

/* Does this require the target task to be suspended?? I don't think so. */
void
task_info_command (char *args, int from_tty)
{
  int mid = -5;
  mach_port_t task;
  kern_return_t ret;
  task_basic_info_data_t ta_info;
  int infoCnt = TASK_BASIC_INFO_COUNT;
  int page_size = round_page (1);
  int thread_count = 0;

  if (MACH_PORT_VALID (inferior_task))
    mid = map_port_name_to_mid (inferior_task,
				MACH_TYPE_TASK);

  task = inferior_task;

  if (args)
    {
      int tmid = atoi (args);

      if (tmid <= 0)
	error ("Invalid mid %d for task info", tmid);

      if (tmid != mid)
	{
	  mid = tmid;
	  ret = machid_mach_port (mid_server, mid_auth, tmid, &task);
	  CHK ("task_info_command: machid_mach_port map failed", ret);
	}
    }

  if (mid < 0)
    error ("You have to give the task MID as an argument");

  ret = task_info (task,
		   TASK_BASIC_INFO,
		   (task_info_t) & ta_info,
		   &infoCnt);
  CHK ("task_info_command: task_info failed", ret);

  printf_filtered ("\nTask info for task %d:\n\n", mid);
  printf_filtered (" Suspend count : %d\n", ta_info.suspend_count);
  printf_filtered (" Base priority : %d\n", ta_info.base_priority);
  printf_filtered (" Virtual size  : %s\n", get_size (ta_info.virtual_size));
  printf_filtered (" Resident size : %s\n", get_size (ta_info.resident_size));

  {
    thread_array_t thread_list;

    ret = task_threads (task, &thread_list, &thread_count);
    CHK ("task_info_command: task_threads", ret);

    printf_filtered (" Thread count  : %d\n", thread_count);

    consume_send_rights (thread_list, thread_count);
    ret = vm_deallocate (mach_task_self (),
			 (vm_address_t) thread_list,
			 (thread_count * sizeof (int)));
    CHK ("Error trying to deallocate thread list", ret);
  }
  if (have_emulator_p (task))
    printf_filtered (" Emulator at   : 0x%x..0x%x\n",
		     EMULATOR_BASE, EMULATOR_END);
  else
    printf_filtered (" No emulator.\n");

  if (thread_count && task == inferior_task)
    printf_filtered ("\nUse the \"thread list\" command to see the threads\n");
}

/* You may either FORWARD the exception to the inferior, or KEEP
 * it and return to GDB command level.
 *
 * exception mid [ forward | keep ]
 */

static void
exception_command (char *args, int from_tty)
{
  char *scan = args;
  int exception;
  int len;

  if (!args)
    error_no_arg ("exception number action");

  while (*scan == ' ' || *scan == '\t')
    scan++;

  if ('0' <= *scan && *scan <= '9')
    while ('0' <= *scan && *scan <= '9')
      scan++;
  else
    error ("exception number action");

  exception = atoi (args);
  if (exception <= 0 || exception > MAX_EXCEPTION)
    error ("Allowed exception numbers are in range 1..%d",
	   MAX_EXCEPTION);

  if (*scan != ' ' && *scan != '\t')
    error ("exception number must be followed by a space");
  else
    while (*scan == ' ' || *scan == '\t')
      scan++;

  args = scan;
  len = 0;
  while (*scan)
    {
      len++;
      scan++;
    }

  if (!len)
    error ("exception number action");

  if (!strncasecmp (args, "forward", len))
    exception_map[exception].forward = TRUE;
  else if (!strncasecmp (args, "keep", len))
    exception_map[exception].forward = FALSE;
  else
    error ("exception action is either \"keep\" or \"forward\"");
}

static void
print_exception_info (int exception)
{
  boolean_t forward = exception_map[exception].forward;

  printf_filtered ("%s\t(%d): ", exception_map[exception].name,
		   exception);
  if (!forward)
    if (exception_map[exception].sigmap != SIG_UNKNOWN)
      printf_filtered ("keep and handle as signal %d\n",
		       exception_map[exception].sigmap);
    else
      printf_filtered ("keep and handle as unknown signal %d\n",
		       exception_map[exception].sigmap);
  else
    printf_filtered ("forward exception to inferior\n");
}

void
exception_info (char *args, int from_tty)
{
  int exception;

  if (!args)
    for (exception = 1; exception <= MAX_EXCEPTION; exception++)
      print_exception_info (exception);
  else
    {
      exception = atoi (args);

      if (exception <= 0 || exception > MAX_EXCEPTION)
	error ("Invalid exception number, values from 1 to %d allowed",
	       MAX_EXCEPTION);
      print_exception_info (exception);
    }
}

/* Check for actions for mach exceptions.
 */
mach3_exception_actions (WAITTYPE *w, boolean_t force_print_only, char *who)
{
  boolean_t force_print = FALSE;


  if (force_print_only ||
      exception_map[stop_exception].sigmap == SIG_UNKNOWN)
    force_print = TRUE;
  else
    WSETSTOP (*w, exception_map[stop_exception].sigmap);

  if (exception_map[stop_exception].print || force_print)
    {
      target_terminal_ours ();

      printf_filtered ("\n%s received %s exception : ",
		       who,
		       exception_map[stop_exception].name);

      wrap_here ("   ");

      switch (stop_exception)
	{
	case EXC_BAD_ACCESS:
	  printf_filtered ("referencing address 0x%x : %s\n",
			   stop_subcode,
			   mach_error_string (stop_code));
	  break;
	case EXC_BAD_INSTRUCTION:
	  printf_filtered
	    ("illegal or undefined instruction. code %d subcode %d\n",
	     stop_code, stop_subcode);
	  break;
	case EXC_ARITHMETIC:
	  printf_filtered ("code %d\n", stop_code);
	  break;
	case EXC_EMULATION:
	  printf_filtered ("code %d subcode %d\n", stop_code, stop_subcode);
	  break;
	case EXC_SOFTWARE:
	  printf_filtered ("%s specific, code 0x%x\n",
			   stop_code < 0xffff ? "hardware" : "os emulation",
			   stop_code);
	  break;
	case EXC_BREAKPOINT:
	  printf_filtered ("type %d (machine dependent)\n",
			   stop_code);
	  break;
	default:
	  internal_error (__FILE__, __LINE__,
			  "Unknown exception");
	}
    }
}

setup_notify_port (int create_new)
{
  kern_return_t ret;

  if (MACH_PORT_VALID (our_notify_port))
    {
      ret = mach_port_destroy (mach_task_self (), our_notify_port);
      CHK ("Could not destroy our_notify_port", ret);
    }

  our_notify_port = MACH_PORT_NULL;
  notify_chain = (port_chain_t) NULL;
  port_chain_destroy (port_chain_obstack);

  if (create_new)
    {
      ret = mach_port_allocate (mach_task_self (),
				MACH_PORT_RIGHT_RECEIVE,
				&our_notify_port);
      if (ret != KERN_SUCCESS)
	internal_error (__FILE__, __LINE__,
			"Creating notify port %s", mach_error_string (ret));

      ret = mach_port_move_member (mach_task_self (),
				   our_notify_port,
				   inferior_wait_port_set);
      if (ret != KERN_SUCCESS)
	internal_error (__FILE__, __LINE__,
			"initial move member %s", mach_error_string (ret));
    }
}

/*
 * Register our message port to the net name server
 *
 * Currently used only by the external stop-gdb program
 * since ^C does not work if you would like to enter
 * gdb command level while debugging your program.
 *
 * NOTE: If the message port is sometimes used for other
 * purposes also, the NAME must not be a guessable one.
 * Then, there should be a way to change it.
 */

char registered_name[MAX_NAME_LEN];

void
message_port_info (char *args, int from_tty)
{
  if (registered_name[0])
    printf_filtered ("gdb's message port name: '%s'\n",
		     registered_name);
  else
    printf_filtered ("gdb's message port is not currently registered\n");
}

void
gdb_register_port (char *name, mach_port_t port)
{
  kern_return_t ret;
  static int already_signed = 0;
  int len;

  if (!MACH_PORT_VALID (port) || !name || !*name)
    {
      warning ("Invalid registration request");
      return;
    }

  if (!already_signed)
    {
      ret = mach_port_insert_right (mach_task_self (),
				    our_message_port,
				    our_message_port,
				    MACH_MSG_TYPE_MAKE_SEND);
      CHK ("Failed to create a signature to our_message_port", ret);
      already_signed = 1;
    }
  else if (already_signed > 1)
    {
      ret = netname_check_out (name_server_port,
			       registered_name,
			       our_message_port);
      CHK ("Failed to check out gdb's message port", ret);
      registered_name[0] = '\000';
      already_signed = 1;
    }

  ret = netname_check_in (name_server_port,	/* Name server port */
			  name,	/* Name of service */
			  our_message_port,	/* Signature */
			  port);	/* Creates a new send right */
  CHK ("Failed to check in the port", ret);

  len = 0;
  while (len < MAX_NAME_LEN && *(name + len))
    {
      registered_name[len] = *(name + len);
      len++;
    }
  registered_name[len] = '\000';
  already_signed = 2;
}

struct cmd_list_element *cmd_thread_list;
struct cmd_list_element *cmd_task_list;

/*ARGSUSED */
static void
thread_command (char *arg, int from_tty)
{
  printf_unfiltered ("\"thread\" must be followed by the name of a thread command.\n");
  help_list (cmd_thread_list, "thread ", -1, gdb_stdout);
}

/*ARGSUSED */
static void
task_command (char *arg, int from_tty)
{
  printf_unfiltered ("\"task\" must be followed by the name of a task command.\n");
  help_list (cmd_task_list, "task ", -1, gdb_stdout);
}

add_mach_specific_commands (void)
{
  /* Thread handling commands */

  /* FIXME: Move our thread support into the generic thread.c stuff so we
     can share that code.  */
  add_prefix_cmd ("mthread", class_stack, thread_command,
	  "Generic command for handling Mach threads in the debugged task.",
		  &cmd_thread_list, "thread ", 0, &cmdlist);

  add_com_alias ("th", "mthread", class_stack, 1);

  add_cmd ("select", class_stack, thread_select_command,
	   "Select and print MID of the selected thread",
	   &cmd_thread_list);
  add_cmd ("list", class_stack, thread_list_command,
	   "List info of task's threads. Selected thread is marked with '*'",
	   &cmd_thread_list);
  add_cmd ("suspend", class_run, thread_suspend_command,
	   "Suspend one or all of the threads in the selected task.",
	   &cmd_thread_list);
  add_cmd ("resume", class_run, thread_resume_command,
	   "Resume one or all of the threads in the selected task.",
	   &cmd_thread_list);
  add_cmd ("kill", class_run, thread_kill_command,
	   "Kill the specified thread MID from inferior task.",
	   &cmd_thread_list);
#if 0
  /* The rest of this support (condition_thread) was not merged.  It probably
     should not be merged in this form, but instead added to the generic GDB
     thread support.  */
  add_cmd ("break", class_breakpoint, condition_thread,
	   "Breakpoint N will only be effective for thread MID or @@SLOT\n\
	    If MID/@@SLOT is omitted allow all threads to break at breakpoint",
	   &cmd_thread_list);
#endif
  /* Thread command shorthands (for backward compatibility) */
  add_alias_cmd ("ts", "mthread select", 0, 0, &cmdlist);
  add_alias_cmd ("tl", "mthread list", 0, 0, &cmdlist);

  /* task handling commands */

  add_prefix_cmd ("task", class_stack, task_command,
		  "Generic command for handling debugged task.",
		  &cmd_task_list, "task ", 0, &cmdlist);

  add_com_alias ("ta", "task", class_stack, 1);

  add_cmd ("suspend", class_run, task_suspend_command,
	   "Suspend the inferior task.",
	   &cmd_task_list);
  add_cmd ("resume", class_run, task_resume_command,
	   "Resume the inferior task.",
	   &cmd_task_list);
  add_cmd ("info", no_class, task_info_command,
	   "Print information about the specified task.",
	   &cmd_task_list);

  /* Print my message port name */

  add_info ("message-port", message_port_info,
	    "Returns the name of gdb's message port in the netnameserver");

  /* Exception commands */

  add_info ("exceptions", exception_info,
	    "What debugger does when program gets various exceptions.\n\
Specify an exception number as argument to print info on that\n\
exception only.");

  add_com ("exception", class_run, exception_command,
	   "Specify how to handle an exception.\n\
Args are exception number followed by \"forward\" or \"keep\".\n\
`Forward' means forward the exception to the program's normal exception\n\
handler.\n\
`Keep' means reenter debugger if this exception happens, and GDB maps\n\
the exception to some signal (see info exception)\n\
Normally \"keep\" is used to return to GDB on exception.");
}

kern_return_t
do_mach_notify_dead_name (mach_port_t notify, mach_port_t name)
{
  kern_return_t kr = KERN_SUCCESS;

  /* Find the thing that notified */
  port_chain_t element = port_chain_member (notify_chain, name);

  /* Take name of from unreceived dead name notification list */
  notify_chain = port_chain_delete (notify_chain, name);

  if (!element)
    error ("Received a dead name notify from unchained port (0x%x)", name);

  switch (element->type)
    {

    case MACH_TYPE_THREAD:
      target_terminal_ours_for_output ();
      if (name == current_thread)
	{
	  printf_filtered ("\nCurrent thread %d died", element->mid);
	  current_thread = MACH_PORT_NULL;
	}
      else
	printf_filtered ("\nThread %d died", element->mid);

      break;

    case MACH_TYPE_TASK:
      target_terminal_ours_for_output ();
      if (name != inferior_task)
	printf_filtered ("Task %d died, but it was not the selected task",
			 element->mid);
      else
	{
	  printf_filtered ("Current task %d died", element->mid);

	  mach_port_destroy (mach_task_self (), name);
	  inferior_task = MACH_PORT_NULL;

	  if (notify_chain)
	    warning ("There were still unreceived dead_name_notifications???");

	  /* Destroy the old notifications */
	  setup_notify_port (0);

	}
      break;

    default:
      error ("Unregistered dead_name 0x%x notification received. Type is %d, mid is 0x%x",
	     name, element->type, element->mid);
      break;
    }

  return KERN_SUCCESS;
}

kern_return_t
do_mach_notify_msg_accepted (mach_port_t notify, mach_port_t name)
{
  warning ("do_mach_notify_msg_accepted : notify %x, name %x",
	   notify, name);
  return KERN_SUCCESS;
}

kern_return_t
do_mach_notify_no_senders (mach_port_t notify, mach_port_mscount_t mscount)
{
  warning ("do_mach_notify_no_senders : notify %x, mscount %x",
	   notify, mscount);
  return KERN_SUCCESS;
}

kern_return_t
do_mach_notify_port_deleted (mach_port_t notify, mach_port_t name)
{
  warning ("do_mach_notify_port_deleted : notify %x, name %x",
	   notify, name);
  return KERN_SUCCESS;
}

kern_return_t
do_mach_notify_port_destroyed (mach_port_t notify, mach_port_t rights)
{
  warning ("do_mach_notify_port_destroyed : notify %x, rights %x",
	   notify, rights);
  return KERN_SUCCESS;
}

kern_return_t
do_mach_notify_send_once (mach_port_t notify)
{
#ifdef DUMP_SYSCALL
  /* MANY of these are generated. */
  warning ("do_mach_notify_send_once : notify %x",
	   notify);
#endif
  return KERN_SUCCESS;
}

/* Kills the inferior. It's gone when you call this */
static void
kill_inferior_fast (void)
{
  WAITTYPE w;

  if (PIDGET (inferior_ptid) == 0 || PIDGET (inferior_ptid) == 1)
    return;

  /* kill() it, since the Unix server does not otherwise notice when
   * killed with task_terminate().
   */
  if (PIDGET (inferior_ptid) > 0)
    kill (PIDGET (inferior_ptid), SIGKILL);

  /* It's propably terminate already */
  (void) task_terminate (inferior_task);

  inferior_task = MACH_PORT_NULL;
  current_thread = MACH_PORT_NULL;

  wait3 (&w, WNOHANG, 0);

  setup_notify_port (0);
}

static void
m3_kill_inferior (void)
{
  kill_inferior_fast ();
  target_mourn_inferior ();
}

/* Clean up after the inferior dies.  */

static void
m3_mourn_inferior (void)
{
  unpush_target (&m3_ops);
  generic_mourn_inferior ();
}


/* Fork an inferior process, and start debugging it.  */

static void
m3_create_inferior (char *exec_file, char *allargs, char **env)
{
  fork_inferior (exec_file, allargs, env, m3_trace_me, m3_trace_him, NULL, NULL);
  /* We are at the first instruction we care about.  */
  /* Pedal to the metal... */
  proceed ((CORE_ADDR) -1, 0, 0);
}

/* Mark our target-struct as eligible for stray "run" and "attach"
   commands.  */
static int
m3_can_run (void)
{
  return 1;
}

/* Mach 3.0 does not need ptrace for anything
 * Make sure nobody uses it on mach.
 */
ptrace (int a, int b, int c, int d)
{
  error ("Lose, Lose! Somebody called ptrace\n");
}

/* Resume execution of the inferior process.
   If STEP is nonzero, single-step it.
   If SIGNAL is nonzero, give it that signal.  */

void
m3_resume (ptid_t ptid, int step, enum target_signal signal)
{
  kern_return_t ret;

  if (step)
    {
      thread_basic_info_data_t th_info;
      unsigned int infoCnt = THREAD_BASIC_INFO_COUNT;

      /* There is no point in single stepping when current_thread
       * is dead.
       */
      if (!MACH_PORT_VALID (current_thread))
	error ("No thread selected; can not single step");

      /* If current_thread is suspended, tracing it would never return.
       */
      ret = thread_info (current_thread,
			 THREAD_BASIC_INFO,
			 (thread_info_t) & th_info,
			 &infoCnt);
      CHK ("child_resume: can't get thread info", ret);

      if (th_info.suspend_count)
	error ("Can't trace a suspended thread. Use \"thread resume\" command to resume it");
    }

  vm_read_cache_valid = FALSE;

  if (signal && PIDGET (inferior_ptid) > 0)	/* Do not signal, if attached by MID */
    kill (PIDGET (inferior_ptid), target_signal_to_host (signal));

  if (step)
    {
      suspend_all_threads (0);

      setup_single_step (current_thread, TRUE);

      ret = thread_resume (current_thread);
      CHK ("thread_resume", ret);
    }

  ret = task_resume (inferior_task);
  if (ret == KERN_FAILURE)
    warning ("Task was not suspended");
  else
    CHK ("Resuming task", ret);

  /* HACK HACK This is needed by the multiserver system HACK HACK */
  while ((ret = task_resume (inferior_task)) == KERN_SUCCESS)
    /* make sure it really runs */ ;
  /* HACK HACK This is needed by the multiserver system HACK HACK */
}

#ifdef ATTACH_DETACH

/* Start debugging the process with the given task */
void
task_attach (task_t tid)
{
  kern_return_t ret;
  inferior_task = tid;

  ret = task_suspend (inferior_task);
  CHK ("task_attach: task_suspend", ret);

  must_suspend_thread = 0;

  setup_notify_port (1);

  request_notify (inferior_task, MACH_NOTIFY_DEAD_NAME, MACH_TYPE_TASK);

  setup_exception_port ();

  emulator_present = have_emulator_p (inferior_task);

  attach_flag = 1;
}

/* Well, we can call error also here and leave the
 * target stack inconsistent. Sigh.
 * Fix this sometime (the only way to fail here is that
 * the task has no threads at all, which is rare, but
 * possible; or if the target task has died, which is also
 * possible, but unlikely, since it has been suspended.
 * (Someone must have killed it))
 */
void
attach_to_thread (void)
{
  if (select_thread (inferior_task, 0, 1) != KERN_SUCCESS)
    error ("Could not select any threads to attach to");
}

mid_attach (int mid)
{
  kern_return_t ret;

  ret = machid_mach_port (mid_server, mid_auth, mid, &inferior_task);
  CHK ("mid_attach: machid_mach_port", ret);

  task_attach (inferior_task);

  return mid;
}

/* 
 * Start debugging the process whose unix process-id is PID.
 * A negative "pid" value is legal and signifies a mach_id not a unix pid.
 *
 * Prevent (possible unwanted) dangerous operations by enabled users
 * like "atta 0" or "atta foo" (equal to the previous :-) and
 * "atta pidself". Anyway, the latter is allowed by specifying a MID.
 */
static int
m3_do_attach (int pid)
{
  kern_return_t ret;

  if (pid == 0)
    error ("MID=0, Debugging the master unix server does not compute");

  /* Foo. This assumes gdb has a unix pid */
  if (pid == getpid ())
    error ("I will debug myself only by mid. (Gdb would suspend itself!)");

  if (pid < 0)
    {
      mid_attach (-(pid));

      /* inferior_ptid will be NEGATIVE! */
      inferior_ptid = pid_to_ptid (pid);

      return PIDGET (inferior_ptid);
    }

  inferior_task = task_by_pid (pid);
  if (!MACH_PORT_VALID (inferior_task))
    error ("Cannot map Unix pid %d to Mach task port", pid);

  task_attach (inferior_task);

  inferior_ptid = pid_to_ptid (pid);

  return PIDGET (inferior_ptid);
}

/* Attach to process PID, then initialize for debugging it
   and wait for the trace-trap that results from attaching.  */

static void
m3_attach (char *args, int from_tty)
{
  char *exec_file;
  int pid;

  if (!args)
    error_no_arg ("process-id to attach");

  pid = atoi (args);

  if (pid == getpid ())		/* Trying to masturbate? */
    error ("I refuse to debug myself!");

  if (from_tty)
    {
      exec_file = (char *) get_exec_file (0);

      if (exec_file)
	printf_unfiltered ("Attaching to program `%s', %s\n", exec_file,
	                   target_pid_to_str (pid_to_ptid (pid)));
      else
	printf_unfiltered ("Attaching to %s\n",
	                   target_pid_to_str (pid_to_ptid (pid)));

      gdb_flush (gdb_stdout);
    }

  m3_do_attach (pid_to_ptid (pid));
  inferior_ptid = pid_to_ptid (pid);
  push_target (&m3_ops);
}

void
deallocate_inferior_ports (void)
{
  kern_return_t ret;
  thread_array_t thread_list;
  int thread_count, index;

  if (!MACH_PORT_VALID (inferior_task))
    return;

  ret = task_threads (inferior_task, &thread_list, &thread_count);
  if (ret != KERN_SUCCESS)
    {
      warning ("deallocate_inferior_ports: task_threads",
	       mach_error_string (ret));
      return;
    }

  /* Get rid of send rights to task threads */
  for (index = 0; index < thread_count; index++)
    {
      int rights;
      ret = mach_port_get_refs (mach_task_self (),
				thread_list[index],
				MACH_PORT_RIGHT_SEND,
				&rights);
      CHK ("deallocate_inferior_ports: get refs", ret);

      if (rights > 0)
	{
	  ret = mach_port_mod_refs (mach_task_self (),
				    thread_list[index],
				    MACH_PORT_RIGHT_SEND,
				    -rights);
	  CHK ("deallocate_inferior_ports: mod refs", ret);
	}
    }

  ret = mach_port_mod_refs (mach_task_self (),
			    inferior_exception_port,
			    MACH_PORT_RIGHT_RECEIVE,
			    -1);
  CHK ("deallocate_inferior_ports: cannot get rid of exception port", ret);

  ret = mach_port_deallocate (mach_task_self (),
			      inferior_task);
  CHK ("deallocate_task_port: deallocating inferior_task", ret);

  current_thread = MACH_PORT_NULL;
  inferior_task = MACH_PORT_NULL;
}

/* Stop debugging the process whose number is PID
   and continue it with signal number SIGNAL.
   SIGNAL = 0 means just continue it.  */

static void
m3_do_detach (int signal)
{
  kern_return_t ret;

  MACH_ERROR_NO_INFERIOR;

  if (current_thread != MACH_PORT_NULL)
    {
      /* Store the gdb's view of the thread we are deselecting
       * before we detach.
       * @@@@ I am really not sure if this is ever needeed.
       */
      target_prepare_to_store ();
      target_store_registers (-1);
    }

  ret = task_set_special_port (inferior_task,
			       TASK_EXCEPTION_PORT,
			       inferior_old_exception_port);
  CHK ("task_set_special_port", ret);

  /* Discard all requested notifications */
  setup_notify_port (0);

  if (remove_breakpoints ())
    warning ("Could not remove breakpoints when detaching");

  if (signal && PIDGET (inferior_ptid) > 0)
    kill (PIDGET (inferior_ptid), signal);

  /* the task might be dead by now */
  (void) task_resume (inferior_task);

  deallocate_inferior_ports ();

  attach_flag = 0;
}

/* Take a program previously attached to and detaches it.
   The program resumes execution and will no longer stop
   on signals, etc.  We'd better not have left any breakpoints
   in the program or it'll die when it hits one.  For this
   to work, it may be necessary for the process to have been
   previously attached.  It *might* work if the program was
   started via fork.  */

static void
m3_detach (char *args, int from_tty)
{
  int siggnal = 0;

  if (from_tty)
    {
      char *exec_file = get_exec_file (0);
      if (exec_file == 0)
	exec_file = "";
      printf_unfiltered ("Detaching from program: %s %s\n",
			 exec_file, target_pid_to_str (inferior_ptid));
      gdb_flush (gdb_stdout);
    }
  if (args)
    siggnal = atoi (args);

  m3_do_detach (siggnal);
  inferior_ptid = null_ptid;
  unpush_target (&m3_ops);	/* Pop out of handling an inferior */
}
#endif /* ATTACH_DETACH */

/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
m3_prepare_to_store (void)
{
#ifdef CHILD_PREPARE_TO_STORE
  CHILD_PREPARE_TO_STORE ();
#endif
}

/* Print status information about what we're accessing.  */

static void
m3_files_info (struct target_ops *ignore)
{
  /* FIXME: should print MID and all that crap.  */
  printf_unfiltered ("\tUsing the running image of %s %s.\n",
      attach_flag ? "attached" : "child", target_pid_to_str (inferior_ptid));
}

static void
m3_open (char *arg, int from_tty)
{
  error ("Use the \"run\" command to start a Unix child process.");
}

#ifdef DUMP_SYSCALL
#define STR(x) #x

char *bsd1_names[] =
{
  "execve",
  "fork",
  "take_signal",
  "sigreturn",
  "getrusage",
  "chdir",
  "chroot",
  "open",
  "creat",
  "mknod",
  "link",
  "symlink",
  "unlink",
  "access",
  "stat",
  "readlink",
  "chmod",
  "chown",
  "utimes",
  "truncate",
  "rename",
  "mkdir",
  "rmdir",
  "xutimes",
  "mount",
  "umount",
  "acct",
  "setquota",
  "write_short",
  "write_long",
  "send_short",
  "send_long",
  "sendto_short",
  "sendto_long",
  "select",
  "task_by_pid",
  "recvfrom_short",
  "recvfrom_long",
  "setgroups",
  "setrlimit",
  "sigvec",
  "sigstack",
  "settimeofday",
  "adjtime",
  "setitimer",
  "sethostname",
  "bind",
  "accept",
  "connect",
  "setsockopt",
  "getsockopt",
  "getsockname",
  "getpeername",
  "init_process",
  "table_set",
  "table_get",
  "pioctl",
  "emulator_error",
  "readwrite",
  "share_wakeup",
  0,
  "maprw_request_it",
  "maprw_release_it",
  "maprw_remap",
  "pid_by_task",
};

int bsd1_nnames = sizeof (bsd1_names) / sizeof (bsd1_names[0]);

char *
name_str (int name, char *buf)
{
  switch (name)
    {
    case MACH_MSG_TYPE_BOOLEAN:
      return "boolean";
    case MACH_MSG_TYPE_INTEGER_16:
      return "short";
    case MACH_MSG_TYPE_INTEGER_32:
      return "long";
    case MACH_MSG_TYPE_CHAR:
      return "char";
    case MACH_MSG_TYPE_BYTE:
      return "byte";
    case MACH_MSG_TYPE_REAL:
      return "real";
    case MACH_MSG_TYPE_STRING:
      return "string";
    default:
      sprintf (buf, "%d", name);
      return buf;
    }
}

char *
id_str (int id, char *buf)
{
  char *p;
  if (id >= 101000 && id < 101000 + bsd1_nnames)
    {
      if (p = bsd1_names[id - 101000])
	return p;
    }
  if (id == 102000)
    return "psignal_retry";
  if (id == 100000)
    return "syscall";
  sprintf (buf, "%d", id);
  return buf;
}

print_msg (mach_msg_header_t *mp)
{
  char *fmt_x = "%20s : 0x%08x\n";
  char *fmt_d = "%20s : %10d\n";
  char *fmt_s = "%20s : %s\n";
  char buf[100];

  puts_filtered ("\n");
#define pr(fmt,h,x) printf_filtered(fmt,STR(x),(h).x)
  pr (fmt_x, (*mp), msgh_bits);
  pr (fmt_d, (*mp), msgh_size);
  pr (fmt_x, (*mp), msgh_remote_port);
  pr (fmt_x, (*mp), msgh_local_port);
  pr (fmt_d, (*mp), msgh_kind);
  printf_filtered (fmt_s, STR (msgh_id), id_str (mp->msgh_id, buf));

  if (debug_level > 1)
    {
      char *p, *ep, *dp;
      int plen;
      p = (char *) mp;
      ep = p + mp->msgh_size;
      p += sizeof (*mp);
      for (; p < ep; p += plen)
	{
	  mach_msg_type_t *tp;
	  mach_msg_type_long_t *tlp;
	  int name, size, number;
	  tp = (mach_msg_type_t *) p;
	  if (tp->msgt_longform)
	    {
	      tlp = (mach_msg_type_long_t *) tp;
	      name = tlp->msgtl_name;
	      size = tlp->msgtl_size;
	      number = tlp->msgtl_number;
	      plen = sizeof (*tlp);
	    }
	  else
	    {
	      name = tp->msgt_name;
	      size = tp->msgt_size;
	      number = tp->msgt_number;
	      plen = sizeof (*tp);
	    }
	  printf_filtered ("name=%-16s size=%2d number=%7d inline=%d long=%d deal=%d\n",
			name_str (name, buf), size, number, tp->msgt_inline,
			   tp->msgt_longform, tp->msgt_deallocate);
	  dp = p + plen;
	  if (tp->msgt_inline)
	    {
	      int l;
	      l = size * number / 8;
	      l = (l + sizeof (long) - 1) & ~((sizeof (long)) - 1);
	      plen += l;
	      print_data (dp, size, number);
	    }
	  else
	    {
	      plen += sizeof (int *);
	    }
	  printf_filtered ("plen=%d\n", plen);
	}
    }
}

print_data (char *p, int size, int number)
{
  int *ip;
  short *sp;
  int i;

  switch (size)
    {
    case 8:
      for (i = 0; i < number; i++)
	{
	  printf_filtered (" %02x", p[i]);
	}
      break;
    case 16:
      sp = (short *) p;
      for (i = 0; i < number; i++)
	{
	  printf_filtered (" %04x", sp[i]);
	}
      break;
    case 32:
      ip = (int *) p;
      for (i = 0; i < number; i++)
	{
	  printf_filtered (" %08x", ip[i]);
	}
      break;
    }
  puts_filtered ("\n");
}
#endif /* DUMP_SYSCALL */

static void
m3_stop (void)
{
  error ("to_stop target function not implemented");
}

static char *
m3_pid_to_exec_file (int pid)
{
  error ("to_pid_to_exec_file target function not implemented");
  return NULL;			/* To keep all compilers happy. */
}

static void
init_m3_ops (void)
{
  m3_ops.to_shortname = "mach";
  m3_ops.to_longname = "Mach child process";
  m3_ops.to_doc = "Mach child process (started by the \"run\" command).";
  m3_ops.to_open = m3_open;
  m3_ops.to_attach = m3_attach;
  m3_ops.to_detach = m3_detach;
  m3_ops.to_resume = m3_resume;
  m3_ops.to_wait = mach_really_wait;
  m3_ops.to_fetch_registers = fetch_inferior_registers;
  m3_ops.to_store_registers = store_inferior_registers;
  m3_ops.to_prepare_to_store = m3_prepare_to_store;
  m3_ops.to_xfer_memory = m3_xfer_memory;
  m3_ops.to_files_info = m3_files_info;
  m3_ops.to_insert_breakpoint = memory_insert_breakpoint;
  m3_ops.to_remove_breakpoint = memory_remove_breakpoint;
  m3_ops.to_terminal_init = terminal_init_inferior;
  m3_ops.to_terminal_inferior = terminal_inferior;
  m3_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  m3_ops.to_terminal_save_ours = terminal_save_ours;
  m3_ops.to_terminal_ours = terminal_ours;
  m3_ops.to_terminal_info = child_terminal_info;
  m3_ops.to_kill = m3_kill_inferior;
  m3_ops.to_create_inferior = m3_create_inferior;
  m3_ops.to_mourn_inferior = m3_mourn_inferior;
  m3_ops.to_can_run = m3_can_run;
  m3_ops.to_stop = m3_stop;
  m3_ops.to_pid_to_exec_file = m3_pid_to_exec_file;
  m3_ops.to_stratum = process_stratum;
  m3_ops.to_has_all_memory = 1;
  m3_ops.to_has_memory = 1;
  m3_ops.to_has_stack = 1;
  m3_ops.to_has_registers = 1;
  m3_ops.to_has_execution = 1;
  m3_ops.to_magic = OPS_MAGIC;
}

void
_initialize_m3_nat (void)
{
  kern_return_t ret;

  init_m3_ops ();
  add_target (&m3_ops);

  ret = mach_port_allocate (mach_task_self (),
			    MACH_PORT_RIGHT_PORT_SET,
			    &inferior_wait_port_set);
  if (ret != KERN_SUCCESS)
    internal_error (__FILE__, __LINE__,
		    "initial port set %s", mach_error_string (ret));

  /* mach_really_wait now waits for this */
  currently_waiting_for = inferior_wait_port_set;

  ret = netname_look_up (name_server_port, hostname, "MachID", &mid_server);
  if (ret != KERN_SUCCESS)
    {
      mid_server = MACH_PORT_NULL;

      warning ("initialize machid: netname_lookup_up(MachID) : %s",
	       mach_error_string (ret));
      warning ("Some (most?) features disabled...");
    }

  mid_auth = mach_privileged_host_port ();
  if (mid_auth == MACH_PORT_NULL)
    mid_auth = mach_task_self ();

  obstack_init (port_chain_obstack);

  ret = mach_port_allocate (mach_task_self (),
			    MACH_PORT_RIGHT_RECEIVE,
			    &thread_exception_port);
  CHK ("Creating thread_exception_port for single stepping", ret);

  ret = mach_port_insert_right (mach_task_self (),
				thread_exception_port,
				thread_exception_port,
				MACH_MSG_TYPE_MAKE_SEND);
  CHK ("Inserting send right to thread_exception_port", ret);

  /* Allocate message port */
  ret = mach_port_allocate (mach_task_self (),
			    MACH_PORT_RIGHT_RECEIVE,
			    &our_message_port);
  if (ret != KERN_SUCCESS)
    warning ("Creating message port %s", mach_error_string (ret));
  else
    {
      char buf[MAX_NAME_LEN];
      ret = mach_port_move_member (mach_task_self (),
				   our_message_port,
				   inferior_wait_port_set);
      if (ret != KERN_SUCCESS)
	warning ("message move member %s", mach_error_string (ret));


      /* @@@@@@@@ No way to change message port name currently */
      /* Foo. This assumes gdb has a unix pid */
      sprintf (buf, "gdb-%d", getpid ());
      gdb_register_port (buf, our_message_port);
    }

  /* Heap for thread commands */
  obstack_init (cproc_obstack);

  add_mach_specific_commands ();
}
@


1.17.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.17.4.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d1 4566
a4566 4566
// OBSOLETE /* Interface GDB to Mach 3.0 operating systems.
// OBSOLETE    (Most) Mach 3.0 related routines live in this file.
// OBSOLETE 
// OBSOLETE    Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
// OBSOLETE    2002 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Author: Jukka Virtanen <jtv@@hut.fi>
// OBSOLETE  *         Computing Centre
// OBSOLETE  *         Helsinki University of Technology
// OBSOLETE  *         Finland
// OBSOLETE  *
// OBSOLETE  * Thanks to my friends who helped with ideas and testing:
// OBSOLETE  *
// OBSOLETE  *      Johannes Helander, Antti Louko, Tero Mononen,
// OBSOLETE  *      jvh@@cs.hut.fi      alo@@hut.fi   tmo@@cs.hut.fi
// OBSOLETE  *
// OBSOLETE  *      Tero Kivinen       and          Eamonn McManus
// OBSOLETE  *      kivinen@@cs.hut.fi               emcmanus@@gr.osf.org
// OBSOLETE  *      
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #include <stdio.h>
// OBSOLETE 
// OBSOLETE #include <mach.h>
// OBSOLETE #include <servers/netname.h>
// OBSOLETE #include <servers/machid.h>
// OBSOLETE #include <mach/message.h>
// OBSOLETE #include <mach/notify.h>
// OBSOLETE #include <mach_error.h>
// OBSOLETE #include <mach/exception.h>
// OBSOLETE #include <mach/vm_attributes.h>
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "language.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "gdb_wait.h"
// OBSOLETE #include "gdbcmd.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE #include <servers/machid_lib.h>
// OBSOLETE #else
// OBSOLETE #define	MACH_TYPE_TASK			1
// OBSOLETE #define MACH_TYPE_THREAD		2
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /* Included only for signal names and NSIG
// OBSOLETE 
// OBSOLETE  * note: There are many problems in signal handling with
// OBSOLETE  *       gdb in Mach 3.0 in general.
// OBSOLETE  */
// OBSOLETE #include <signal.h>
// OBSOLETE #define SIG_UNKNOWN 0		/* Exception that has no matching unix signal */
// OBSOLETE 
// OBSOLETE #include <cthreads.h>
// OBSOLETE 
// OBSOLETE /* This is what a cproc looks like.  This is here partly because
// OBSOLETE    cthread_internals.h is not a header we can just #include, partly with
// OBSOLETE    an eye towards perhaps getting this to work with cross-debugging
// OBSOLETE    someday.  Best solution is if CMU publishes a real interface to this
// OBSOLETE    stuff.  */
// OBSOLETE #define CPROC_NEXT_OFFSET 0
// OBSOLETE #define CPROC_NEXT_SIZE (TARGET_PTR_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_INCARNATION_OFFSET (CPROC_NEXT_OFFSET + CPROC_NEXT_SIZE)
// OBSOLETE #define CPROC_INCARNATION_SIZE (sizeof (cthread_t))
// OBSOLETE #define CPROC_LIST_OFFSET (CPROC_INCARNATION_OFFSET + CPROC_INCARNATION_SIZE)
// OBSOLETE #define CPROC_LIST_SIZE (TARGET_PTR_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_WAIT_OFFSET (CPROC_LIST_OFFSET + CPROC_LIST_SIZE)
// OBSOLETE #define CPROC_WAIT_SIZE (TARGET_PTR_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_REPLY_OFFSET (CPROC_WAIT_OFFSET + CPROC_WAIT_SIZE)
// OBSOLETE #define CPROC_REPLY_SIZE (sizeof (mach_port_t))
// OBSOLETE #define CPROC_CONTEXT_OFFSET (CPROC_REPLY_OFFSET + CPROC_REPLY_SIZE)
// OBSOLETE #define CPROC_CONTEXT_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_LOCK_OFFSET (CPROC_CONTEXT_OFFSET + CPROC_CONTEXT_SIZE)
// OBSOLETE #define CPROC_LOCK_SIZE (sizeof (spin_lock_t))
// OBSOLETE #define CPROC_STATE_OFFSET (CPROC_LOCK_OFFSET + CPROC_LOCK_SIZE)
// OBSOLETE #define CPROC_STATE_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_WIRED_OFFSET (CPROC_STATE_OFFSET + CPROC_STATE_SIZE)
// OBSOLETE #define CPROC_WIRED_SIZE (sizeof (mach_port_t))
// OBSOLETE #define CPROC_BUSY_OFFSET (CPROC_WIRED_OFFSET + CPROC_WIRED_SIZE)
// OBSOLETE #define CPROC_BUSY_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_MSG_OFFSET (CPROC_BUSY_OFFSET + CPROC_BUSY_SIZE)
// OBSOLETE #define CPROC_MSG_SIZE (sizeof (mach_msg_header_t))
// OBSOLETE #define CPROC_BASE_OFFSET (CPROC_MSG_OFFSET + CPROC_MSG_SIZE)
// OBSOLETE #define CPROC_BASE_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_SIZE_OFFSET (CPROC_BASE_OFFSET + CPROC_BASE_SIZE)
// OBSOLETE #define CPROC_SIZE_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_SIZE (CPROC_SIZE_OFFSET + CPROC_SIZE_SIZE)
// OBSOLETE 
// OBSOLETE /* Values for the state field in the cproc.  */
// OBSOLETE #define CPROC_RUNNING	0
// OBSOLETE #define CPROC_SWITCHING 1
// OBSOLETE #define CPROC_BLOCKED	2
// OBSOLETE #define CPROC_CONDWAIT	4
// OBSOLETE 
// OBSOLETE /* For cproc and kernel thread mapping */
// OBSOLETE typedef struct gdb_thread
// OBSOLETE   {
// OBSOLETE     mach_port_t name;
// OBSOLETE     CORE_ADDR sp;
// OBSOLETE     CORE_ADDR pc;
// OBSOLETE     CORE_ADDR fp;
// OBSOLETE     boolean_t in_emulator;
// OBSOLETE     int slotid;
// OBSOLETE 
// OBSOLETE     /* This is for the mthreads list.  It points to the cproc list.
// OBSOLETE        Perhaps the two lists should be merged (or perhaps it was a mistake
// OBSOLETE        to make them both use a struct gdb_thread).  */
// OBSOLETE     struct gdb_thread *cproc;
// OBSOLETE 
// OBSOLETE     /* These are for the cproc list, which is linked through the next field
// OBSOLETE        of the struct gdb_thread.  */
// OBSOLETE     char raw_cproc[CPROC_SIZE];
// OBSOLETE     /* The cthread which is pointed to by the incarnation field from the
// OBSOLETE        cproc.  This points to the copy we've read into GDB.  */
// OBSOLETE     cthread_t cthread;
// OBSOLETE     /* Point back to the mthreads list.  */
// OBSOLETE     int reverse_map;
// OBSOLETE     struct gdb_thread *next;
// OBSOLETE   }
// OBSOLETE  *gdb_thread_t;
// OBSOLETE 
// OBSOLETE /* 
// OBSOLETE  * Actions for Mach exceptions.
// OBSOLETE  *
// OBSOLETE  * sigmap field maps the exception to corresponding Unix signal.
// OBSOLETE  *
// OBSOLETE  * I do not know how to map the exception to unix signal
// OBSOLETE  * if SIG_UNKNOWN is specified.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE struct exception_list
// OBSOLETE   {
// OBSOLETE     char *name;
// OBSOLETE     boolean_t forward;
// OBSOLETE     boolean_t print;
// OBSOLETE     int sigmap;
// OBSOLETE   }
// OBSOLETE exception_map[] =
// OBSOLETE {
// OBSOLETE   {
// OBSOLETE     "not_mach3_exception", FALSE, TRUE, SIG_UNKNOWN
// OBSOLETE   }
// OBSOLETE   ,
// OBSOLETE   {
// OBSOLETE     "EXC_BAD_ACCESS", FALSE, TRUE, SIGSEGV
// OBSOLETE   }
// OBSOLETE   ,
// OBSOLETE   {
// OBSOLETE     "EXC_BAD_INSTRUCTION", FALSE, TRUE, SIGILL
// OBSOLETE   }
// OBSOLETE   ,
// OBSOLETE   {
// OBSOLETE     "EXC_ARITHMETIC", FALSE, TRUE, SIGFPE
// OBSOLETE   }
// OBSOLETE   ,
// OBSOLETE   {
// OBSOLETE     "EXC_EMULATION", FALSE, TRUE, SIGEMT
// OBSOLETE   }
// OBSOLETE   ,				/* ??? */
// OBSOLETE   {
// OBSOLETE     "EXC_SOFTWARE", FALSE, TRUE, SIG_UNKNOWN
// OBSOLETE   }
// OBSOLETE   ,
// OBSOLETE   {
// OBSOLETE     "EXC_BREAKPOINT", FALSE, FALSE, SIGTRAP
// OBSOLETE   }
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* Mach exception table size */
// OBSOLETE int max_exception = sizeof (exception_map) / sizeof (struct exception_list) - 1;
// OBSOLETE 
// OBSOLETE #define MAX_EXCEPTION max_exception
// OBSOLETE 
// OBSOLETE WAITTYPE wait_status;
// OBSOLETE 
// OBSOLETE /* If you define this, intercepted bsd server calls will be
// OBSOLETE  * dumped while waiting the inferior to EXEC the correct
// OBSOLETE  * program
// OBSOLETE  */
// OBSOLETE /* #define DUMP_SYSCALL         /* debugging interceptor */
// OBSOLETE 
// OBSOLETE /* xx_debug() outputs messages if this is nonzero.
// OBSOLETE  * If > 1, DUMP_SYSCALL will dump message contents.
// OBSOLETE  */
// OBSOLETE int debug_level = 0;
// OBSOLETE 
// OBSOLETE /* "Temporary" debug stuff */
// OBSOLETE void
// OBSOLETE xx_debug (char *fmt, int a, int b, int c)
// OBSOLETE {
// OBSOLETE   if (debug_level)
// OBSOLETE     warning (fmt, a, b, c);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* This is in libmach.a */
// OBSOLETE extern mach_port_t name_server_port;
// OBSOLETE 
// OBSOLETE /* Set in catch_exception_raise */
// OBSOLETE int stop_exception, stop_code, stop_subcode;
// OBSOLETE int stopped_in_exception;
// OBSOLETE 
// OBSOLETE /* Thread that was the active thread when we stopped */
// OBSOLETE thread_t stop_thread = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE char *hostname = "";
// OBSOLETE 
// OBSOLETE /* Set when task is attached or created */
// OBSOLETE boolean_t emulator_present = FALSE;
// OBSOLETE 
// OBSOLETE task_t inferior_task;
// OBSOLETE thread_t current_thread;
// OBSOLETE 
// OBSOLETE /* Exception ports for inferior task */
// OBSOLETE mach_port_t inferior_exception_port = MACH_PORT_NULL;
// OBSOLETE mach_port_t inferior_old_exception_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* task exceptions and notifications */
// OBSOLETE mach_port_t inferior_wait_port_set = MACH_PORT_NULL;
// OBSOLETE mach_port_t our_notify_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* This is "inferior_wait_port_set" when not single stepping, and
// OBSOLETE  *         "singlestepped_thread_port" when we are single stepping.
// OBSOLETE  * 
// OBSOLETE  * This is protected by a cleanup function: discard_single_step()
// OBSOLETE  */
// OBSOLETE mach_port_t currently_waiting_for = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* A port for external messages to gdb.
// OBSOLETE  * External in the meaning that they do not come
// OBSOLETE  * from the inferior_task, but rather from external
// OBSOLETE  * tasks.
// OBSOLETE  *
// OBSOLETE  * As a debugging feature:
// OBSOLETE  * A debugger debugging another debugger can stop the
// OBSOLETE  * inferior debugger by the following command sequence
// OBSOLETE  * (without running external programs)
// OBSOLETE  *
// OBSOLETE  *    (top-gdb) set stop_inferior_gdb ()
// OBSOLETE  *    (top-gdb) continue
// OBSOLETE  */
// OBSOLETE mach_port_t our_message_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* For single stepping */
// OBSOLETE mach_port_t thread_exception_port = MACH_PORT_NULL;
// OBSOLETE mach_port_t thread_saved_exception_port = MACH_PORT_NULL;
// OBSOLETE mach_port_t singlestepped_thread_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* For machid calls */
// OBSOLETE mach_port_t mid_server = MACH_PORT_NULL;
// OBSOLETE mach_port_t mid_auth = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* If gdb thinks the inferior task is not suspended, it
// OBSOLETE  * must take suspend/abort the threads when it reads the state.
// OBSOLETE  */
// OBSOLETE int must_suspend_thread = 0;
// OBSOLETE 
// OBSOLETE /* When single stepping, we switch the port that mach_really_wait() listens to.
// OBSOLETE  * This cleanup is a guard to prevent the port set from being left to
// OBSOLETE  * the singlestepped_thread_port when error() is called.
// OBSOLETE  *  This is nonzero only when we are single stepping.
// OBSOLETE  */
// OBSOLETE #define NULL_CLEANUP (struct cleanup *)0
// OBSOLETE struct cleanup *cleanup_step = NULL_CLEANUP;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static struct target_ops m3_ops;
// OBSOLETE 
// OBSOLETE static void m3_kill_inferior ();
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE #define MACH_TYPE_EXCEPTION_PORT	-1
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /* Chain of ports to remember requested notifications. */
// OBSOLETE 
// OBSOLETE struct port_chain
// OBSOLETE   {
// OBSOLETE     struct port_chain *next;
// OBSOLETE     mach_port_t port;
// OBSOLETE     int type;
// OBSOLETE     int mid;			/* Now only valid with MACH_TYPE_THREAD and */
// OBSOLETE     /*  MACH_TYPE_THREAD */
// OBSOLETE   };
// OBSOLETE typedef struct port_chain *port_chain_t;
// OBSOLETE 
// OBSOLETE /* Room for chain nodes comes from pchain_obstack */
// OBSOLETE struct obstack pchain_obstack;
// OBSOLETE struct obstack *port_chain_obstack = &pchain_obstack;
// OBSOLETE 
// OBSOLETE /* For thread handling */
// OBSOLETE struct obstack Cproc_obstack;
// OBSOLETE struct obstack *cproc_obstack = &Cproc_obstack;
// OBSOLETE 
// OBSOLETE /* the list of notified ports */
// OBSOLETE port_chain_t notify_chain = (port_chain_t) NULL;
// OBSOLETE 
// OBSOLETE port_chain_t
// OBSOLETE port_chain_insert (port_chain_t list, mach_port_t name, int type)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   port_chain_t new;
// OBSOLETE   int mid;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (name))
// OBSOLETE     return list;
// OBSOLETE 
// OBSOLETE   if (type == MACH_TYPE_TASK || type == MACH_TYPE_THREAD)
// OBSOLETE     {
// OBSOLETE       if (!MACH_PORT_VALID (mid_server))
// OBSOLETE 	{
// OBSOLETE 	  warning ("Machid server port invalid, can not map port 0x%x to MID",
// OBSOLETE 		   name);
// OBSOLETE 	  mid = name;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  ret = machid_mach_register (mid_server, mid_auth, name, type, &mid);
// OBSOLETE 
// OBSOLETE 	  if (ret != KERN_SUCCESS)
// OBSOLETE 	    {
// OBSOLETE 	      warning ("Can not map name (0x%x) to MID with machid", name);
// OBSOLETE 	      mid = name;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE 
// OBSOLETE   new = (port_chain_t) obstack_alloc (port_chain_obstack,
// OBSOLETE 				      sizeof (struct port_chain));
// OBSOLETE   new->next = list;
// OBSOLETE   new->port = name;
// OBSOLETE   new->type = type;
// OBSOLETE   new->mid = mid;
// OBSOLETE 
// OBSOLETE   return new;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE port_chain_t
// OBSOLETE port_chain_delete (port_chain_t list, mach_port_t elem)
// OBSOLETE {
// OBSOLETE   if (list)
// OBSOLETE     if (list->port == elem)
// OBSOLETE       list = list->next;
// OBSOLETE     else
// OBSOLETE       while (list->next)
// OBSOLETE 	{
// OBSOLETE 	  if (list->next->port == elem)
// OBSOLETE 	    list->next = list->next->next;	/* GCd with obstack_free() */
// OBSOLETE 	  else
// OBSOLETE 	    list = list->next;
// OBSOLETE 	}
// OBSOLETE   return list;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE port_chain_destroy (struct obstack *ostack)
// OBSOLETE {
// OBSOLETE   obstack_free (ostack, 0);
// OBSOLETE   obstack_init (ostack);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE port_chain_t
// OBSOLETE port_chain_member (port_chain_t list, mach_port_t elem)
// OBSOLETE {
// OBSOLETE   while (list)
// OBSOLETE     {
// OBSOLETE       if (list->port == elem)
// OBSOLETE 	return list;
// OBSOLETE       list = list->next;
// OBSOLETE     }
// OBSOLETE   return (port_chain_t) NULL;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE map_port_name_to_mid (mach_port_t name, int type)
// OBSOLETE {
// OBSOLETE   port_chain_t elem;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (name))
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   elem = port_chain_member (notify_chain, name);
// OBSOLETE 
// OBSOLETE   if (elem && (elem->type == type))
// OBSOLETE     return elem->mid;
// OBSOLETE 
// OBSOLETE   if (elem)
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (mid_server))
// OBSOLETE     {
// OBSOLETE       warning ("Machid server port invalid, can not map port 0x%x to mid",
// OBSOLETE 	       name);
// OBSOLETE       return -1;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       int mid;
// OBSOLETE       kern_return_t ret;
// OBSOLETE 
// OBSOLETE       ret = machid_mach_register (mid_server, mid_auth, name, type, &mid);
// OBSOLETE 
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	{
// OBSOLETE 	  warning ("Can not map name (0x%x) to mid with machid", name);
// OBSOLETE 	  return -1;
// OBSOLETE 	}
// OBSOLETE       return mid;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Guard for currently_waiting_for and singlestepped_thread_port */
// OBSOLETE static void
// OBSOLETE discard_single_step (thread_t thread)
// OBSOLETE {
// OBSOLETE   currently_waiting_for = inferior_wait_port_set;
// OBSOLETE 
// OBSOLETE   cleanup_step = NULL_CLEANUP;
// OBSOLETE   if (MACH_PORT_VALID (thread) && MACH_PORT_VALID (singlestepped_thread_port))
// OBSOLETE     setup_single_step (thread, FALSE);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE setup_single_step (thread_t thread, boolean_t start_step)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (thread))
// OBSOLETE     error ("Invalid thread supplied to setup_single_step");
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       mach_port_t teport;
// OBSOLETE 
// OBSOLETE       /* Get the current thread exception port */
// OBSOLETE       ret = thread_get_exception_port (thread, &teport);
// OBSOLETE       CHK ("Getting thread's exception port", ret);
// OBSOLETE 
// OBSOLETE       if (start_step)
// OBSOLETE 	{
// OBSOLETE 	  if (MACH_PORT_VALID (singlestepped_thread_port))
// OBSOLETE 	    {
// OBSOLETE 	      warning ("Singlestepped_thread_port (0x%x) is still valid?",
// OBSOLETE 		       singlestepped_thread_port);
// OBSOLETE 	      singlestepped_thread_port = MACH_PORT_NULL;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  /* If we are already stepping this thread */
// OBSOLETE 	  if (MACH_PORT_VALID (teport) && teport == thread_exception_port)
// OBSOLETE 	    {
// OBSOLETE 	      ret = mach_port_deallocate (mach_task_self (), teport);
// OBSOLETE 	      CHK ("Could not deallocate thread exception port", ret);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      ret = thread_set_exception_port (thread, thread_exception_port);
// OBSOLETE 	      CHK ("Setting exception port for thread", ret);
// OBSOLETE #if 0
// OBSOLETE 	      /* Insert thread exception port to wait port set */
// OBSOLETE 	      ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 					   thread_exception_port,
// OBSOLETE 					   inferior_wait_port_set);
// OBSOLETE 	      CHK ("Moving thread exception port to inferior_wait_port_set",
// OBSOLETE 		   ret);
// OBSOLETE #endif
// OBSOLETE 	      thread_saved_exception_port = teport;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  thread_trace (thread, TRUE);
// OBSOLETE 
// OBSOLETE 	  singlestepped_thread_port = thread_exception_port;
// OBSOLETE 	  currently_waiting_for = singlestepped_thread_port;
// OBSOLETE 	  cleanup_step = make_cleanup (discard_single_step, thread);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (!MACH_PORT_VALID (teport))
// OBSOLETE 	    error ("Single stepped thread had an invalid exception port?");
// OBSOLETE 
// OBSOLETE 	  if (teport != thread_exception_port)
// OBSOLETE 	    error ("Single stepped thread had an unknown exception port?");
// OBSOLETE 
// OBSOLETE 	  ret = mach_port_deallocate (mach_task_self (), teport);
// OBSOLETE 	  CHK ("Couldn't deallocate thread exception port", ret);
// OBSOLETE #if 0
// OBSOLETE 	  /* Remove thread exception port from wait port set */
// OBSOLETE 	  ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 				       thread_exception_port,
// OBSOLETE 				       MACH_PORT_NULL);
// OBSOLETE 	  CHK ("Removing thread exception port from inferior_wait_port_set",
// OBSOLETE 	       ret);
// OBSOLETE #endif
// OBSOLETE 	  /* Restore thread's old exception port */
// OBSOLETE 	  ret = thread_set_exception_port (thread,
// OBSOLETE 					   thread_saved_exception_port);
// OBSOLETE 	  CHK ("Restoring stepped thread's exception port", ret);
// OBSOLETE 
// OBSOLETE 	  if (MACH_PORT_VALID (thread_saved_exception_port))
// OBSOLETE 	    (void) mach_port_deallocate (mach_task_self (),
// OBSOLETE 					 thread_saved_exception_port);
// OBSOLETE 
// OBSOLETE 	  thread_trace (thread, FALSE);
// OBSOLETE 
// OBSOLETE 	  singlestepped_thread_port = MACH_PORT_NULL;
// OBSOLETE 	  currently_waiting_for = inferior_wait_port_set;
// OBSOLETE 	  if (cleanup_step)
// OBSOLETE 	    discard_cleanups (cleanup_step);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static
// OBSOLETE request_notify (mach_port_t name, mach_msg_id_t variant, int type)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   mach_port_t previous_port_dummy = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (name))
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   if (port_chain_member (notify_chain, name))
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   ret = mach_port_request_notification (mach_task_self (),
// OBSOLETE 					name,
// OBSOLETE 					variant,
// OBSOLETE 					1,
// OBSOLETE 					our_notify_port,
// OBSOLETE 					MACH_MSG_TYPE_MAKE_SEND_ONCE,
// OBSOLETE 					&previous_port_dummy);
// OBSOLETE   CHK ("Serious: request_notify failed", ret);
// OBSOLETE 
// OBSOLETE   (void) mach_port_deallocate (mach_task_self (),
// OBSOLETE 			       previous_port_dummy);
// OBSOLETE 
// OBSOLETE   notify_chain = port_chain_insert (notify_chain, name, type);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE reverse_msg_bits (mach_msg_header_t *msgp, int type)
// OBSOLETE {
// OBSOLETE   int rbits, lbits;
// OBSOLETE   rbits = MACH_MSGH_BITS_REMOTE (msgp->msgh_bits);
// OBSOLETE   lbits = type;
// OBSOLETE   msgp->msgh_bits =
// OBSOLETE     (msgp->msgh_bits & ~MACH_MSGH_BITS_PORTS_MASK) |
// OBSOLETE     MACH_MSGH_BITS (lbits, rbits);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* On the third day He said:
// OBSOLETE 
// OBSOLETE    Let this be global
// OBSOLETE    and then it was global.
// OBSOLETE 
// OBSOLETE    When creating the inferior fork, the
// OBSOLETE    child code in inflow.c sets the name of the
// OBSOLETE    bootstrap_port in its address space to this
// OBSOLETE    variable.
// OBSOLETE 
// OBSOLETE    The name is transferred to our address space
// OBSOLETE    with mach3_read_inferior().
// OBSOLETE 
// OBSOLETE    Thou shalt not do this with
// OBSOLETE    task_get_bootstrap_port() in this task, since
// OBSOLETE    the name in the inferior task is different than
// OBSOLETE    the one we get.
// OBSOLETE 
// OBSOLETE    For blessed are the meek, as they shall inherit
// OBSOLETE    the address space.
// OBSOLETE  */
// OBSOLETE mach_port_t original_server_port_name = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Called from inferior after FORK but before EXEC */
// OBSOLETE static void
// OBSOLETE m3_trace_me (void)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   /* Get the NAME of the bootstrap port in this task
// OBSOLETE      so that GDB can read it */
// OBSOLETE   ret = task_get_bootstrap_port (mach_task_self (),
// OBSOLETE 				 &original_server_port_name);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE   ret = mach_port_deallocate (mach_task_self (),
// OBSOLETE 			      original_server_port_name);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE 
// OBSOLETE   /* Suspend this task to let the parent change my ports.
// OBSOLETE      Resumed by the debugger */
// OBSOLETE   ret = task_suspend (mach_task_self ());
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Intercept system calls to Unix server.
// OBSOLETE  * After EXEC_COUNTER calls to exec(), return.
// OBSOLETE  *
// OBSOLETE  * Pre-assertion:  Child is suspended. (Not verified)
// OBSOLETE  * Post-condition: Child is suspended after EXEC_COUNTER exec() calls.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE intercept_exec_calls (int exec_counter)
// OBSOLETE {
// OBSOLETE   int terminal_initted = 0;
// OBSOLETE 
// OBSOLETE   struct syscall_msg_t
// OBSOLETE     {
// OBSOLETE       mach_msg_header_t header;
// OBSOLETE       mach_msg_type_t type;
// OBSOLETE       char room[2000];		/* Enuff space */
// OBSOLETE     };
// OBSOLETE 
// OBSOLETE   struct syscall_msg_t syscall_in, syscall_out;
// OBSOLETE 
// OBSOLETE   mach_port_t fake_server;
// OBSOLETE   mach_port_t original_server_send;
// OBSOLETE   mach_port_t original_exec_reply;
// OBSOLETE   mach_port_t exec_reply;
// OBSOLETE   mach_port_t exec_reply_send;
// OBSOLETE   mach_msg_type_name_t acquired;
// OBSOLETE   mach_port_t emulator_server_port_name;
// OBSOLETE   struct task_basic_info info;
// OBSOLETE   mach_msg_type_number_t info_count;
// OBSOLETE 
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (exec_counter <= 0)
// OBSOLETE     return;			/* We are already set up in the correct program */
// OBSOLETE 
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    &fake_server);
// OBSOLETE   CHK ("create inferior_fake_server port failed", ret);
// OBSOLETE 
// OBSOLETE   /* Wait for inferior_task to suspend itself */
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       info_count = sizeof (info);
// OBSOLETE       ret = task_info (inferior_task,
// OBSOLETE 		       TASK_BASIC_INFO,
// OBSOLETE 		       (task_info_t) & info,
// OBSOLETE 		       &info_count);
// OBSOLETE       CHK ("Task info", ret);
// OBSOLETE 
// OBSOLETE       if (info.suspend_count)
// OBSOLETE 	break;
// OBSOLETE 
// OBSOLETE       /* Note that the definition of the parameter was undefined
// OBSOLETE        * at the time of this writing, so I just use an `ad hoc' value.
// OBSOLETE        */
// OBSOLETE       (void) swtch_pri (42);	/* Universal Priority Value */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Read the inferior's bootstrap port name */
// OBSOLETE   if (!mach3_read_inferior (&original_server_port_name,
// OBSOLETE 			    &original_server_port_name,
// OBSOLETE 			    sizeof (original_server_port_name)))
// OBSOLETE     error ("Can't read inferior task bootstrap port name");
// OBSOLETE 
// OBSOLETE   /* @@@@ BUG: If more than 1 send right GDB will FAIL!!! */
// OBSOLETE   /*      Should get refs, and set them back when restoring */
// OBSOLETE   /* Steal the original bsd server send right from inferior */
// OBSOLETE   ret = mach_port_extract_right (inferior_task,
// OBSOLETE 				 original_server_port_name,
// OBSOLETE 				 MACH_MSG_TYPE_MOVE_SEND,
// OBSOLETE 				 &original_server_send,
// OBSOLETE 				 &acquired);
// OBSOLETE   CHK ("mach_port_extract_right (bsd server send)", ret);
// OBSOLETE 
// OBSOLETE   if (acquired != MACH_MSG_TYPE_PORT_SEND)
// OBSOLETE     error ("Incorrect right extracted, send right to bsd server expected");
// OBSOLETE 
// OBSOLETE   ret = mach_port_insert_right (inferior_task,
// OBSOLETE 				original_server_port_name,
// OBSOLETE 				fake_server,
// OBSOLETE 				MACH_MSG_TYPE_MAKE_SEND);
// OBSOLETE   CHK ("mach_port_insert_right (fake server send)", ret);
// OBSOLETE 
// OBSOLETE   xx_debug ("inferior task bsd server ports set up \nfs %x, ospn %x, oss %x\n",
// OBSOLETE 	    fake_server,
// OBSOLETE 	    original_server_port_name, original_server_send);
// OBSOLETE 
// OBSOLETE   /* A receive right to the reply generated by unix server exec() request */
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    &exec_reply);
// OBSOLETE   CHK ("create intercepted_reply_port port failed", ret);
// OBSOLETE 
// OBSOLETE   /* Pass this send right to Unix server so it replies to us after exec() */
// OBSOLETE   ret = mach_port_extract_right (mach_task_self (),
// OBSOLETE 				 exec_reply,
// OBSOLETE 				 MACH_MSG_TYPE_MAKE_SEND_ONCE,
// OBSOLETE 				 &exec_reply_send,
// OBSOLETE 				 &acquired);
// OBSOLETE   CHK ("mach_port_extract_right (exec_reply)", ret);
// OBSOLETE 
// OBSOLETE   if (acquired != MACH_MSG_TYPE_PORT_SEND_ONCE)
// OBSOLETE     error ("Incorrect right extracted, send once expected for exec reply");
// OBSOLETE 
// OBSOLETE   ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 			       fake_server,
// OBSOLETE 			       inferior_wait_port_set);
// OBSOLETE   CHK ("Moving fake syscall port to inferior_wait_port_set", ret);
// OBSOLETE 
// OBSOLETE   xx_debug ("syscall fake server set up, resuming inferior\n");
// OBSOLETE 
// OBSOLETE   ret = task_resume (inferior_task);
// OBSOLETE   CHK ("task_resume (startup)", ret);
// OBSOLETE 
// OBSOLETE   /* Read requests from the inferior.
// OBSOLETE      Pass directly through everything else except exec() calls.
// OBSOLETE    */
// OBSOLETE   while (exec_counter > 0)
// OBSOLETE     {
// OBSOLETE       ret = mach_msg (&syscall_in.header,	/* header */
// OBSOLETE 		      MACH_RCV_MSG,	/* options */
// OBSOLETE 		      0,	/* send size */
// OBSOLETE 		      sizeof (struct syscall_msg_t),	/* receive size */
// OBSOLETE 		      inferior_wait_port_set,	/* receive_name */
// OBSOLETE 		      MACH_MSG_TIMEOUT_NONE,
// OBSOLETE 		      MACH_PORT_NULL);
// OBSOLETE       CHK ("mach_msg (intercepted sycall)", ret);
// OBSOLETE 
// OBSOLETE #ifdef DUMP_SYSCALL
// OBSOLETE       print_msg (&syscall_in.header);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE       /* ASSERT : msgh_local_port == fake_server */
// OBSOLETE 
// OBSOLETE       if (notify_server (&syscall_in.header, &syscall_out.header))
// OBSOLETE 	error ("received a notify while intercepting syscalls");
// OBSOLETE 
// OBSOLETE       if (syscall_in.header.msgh_id == MIG_EXEC_SYSCALL_ID)
// OBSOLETE 	{
// OBSOLETE 	  xx_debug ("Received EXEC SYSCALL, counter = %d\n", exec_counter);
// OBSOLETE 	  if (exec_counter == 1)
// OBSOLETE 	    {
// OBSOLETE 	      original_exec_reply = syscall_in.header.msgh_remote_port;
// OBSOLETE 	      syscall_in.header.msgh_remote_port = exec_reply_send;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  if (!terminal_initted)
// OBSOLETE 	    {
// OBSOLETE 	      /* Now that the child has exec'd we know it has already set its
// OBSOLETE 	         process group.  On POSIX systems, tcsetpgrp will fail with
// OBSOLETE 	         EPERM if we try it before the child's setpgid.  */
// OBSOLETE 
// OBSOLETE 	      /* Set up the "saved terminal modes" of the inferior
// OBSOLETE 	         based on what modes we are starting it with.  */
// OBSOLETE 	      target_terminal_init ();
// OBSOLETE 
// OBSOLETE 	      /* Install inferior's terminal modes.  */
// OBSOLETE 	      target_terminal_inferior ();
// OBSOLETE 
// OBSOLETE 	      terminal_initted = 1;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  exec_counter--;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       syscall_in.header.msgh_local_port = syscall_in.header.msgh_remote_port;
// OBSOLETE       syscall_in.header.msgh_remote_port = original_server_send;
// OBSOLETE 
// OBSOLETE       reverse_msg_bits (&syscall_in.header, MACH_MSG_TYPE_COPY_SEND);
// OBSOLETE 
// OBSOLETE       ret = mach_msg_send (&syscall_in.header);
// OBSOLETE       CHK ("Forwarded syscall", ret);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 			       fake_server,
// OBSOLETE 			       MACH_PORT_NULL);
// OBSOLETE   CHK ("Moving fake syscall out of inferior_wait_port_set", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 			       exec_reply,
// OBSOLETE 			       inferior_wait_port_set);
// OBSOLETE   CHK ("Moving exec_reply to inferior_wait_port_set", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_msg (&syscall_in.header,	/* header */
// OBSOLETE 		  MACH_RCV_MSG,	/* options */
// OBSOLETE 		  0,		/* send size */
// OBSOLETE 		  sizeof (struct syscall_msg_t),	/* receive size */
// OBSOLETE 		  inferior_wait_port_set,	/* receive_name */
// OBSOLETE 		  MACH_MSG_TIMEOUT_NONE,
// OBSOLETE 		  MACH_PORT_NULL);
// OBSOLETE   CHK ("mach_msg (exec reply)", ret);
// OBSOLETE 
// OBSOLETE   ret = task_suspend (inferior_task);
// OBSOLETE   CHK ("Suspending inferior after last exec", ret);
// OBSOLETE 
// OBSOLETE   must_suspend_thread = 0;
// OBSOLETE 
// OBSOLETE   xx_debug ("Received exec reply from bsd server, suspended inferior task\n");
// OBSOLETE 
// OBSOLETE #ifdef DUMP_SYSCALL
// OBSOLETE   print_msg (&syscall_in.header);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   /* Message should appear as if it came from the unix server */
// OBSOLETE   syscall_in.header.msgh_local_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE   /*  and go to the inferior task original reply port */
// OBSOLETE   syscall_in.header.msgh_remote_port = original_exec_reply;
// OBSOLETE 
// OBSOLETE   reverse_msg_bits (&syscall_in.header, MACH_MSG_TYPE_MOVE_SEND_ONCE);
// OBSOLETE 
// OBSOLETE   ret = mach_msg_send (&syscall_in.header);
// OBSOLETE   CHK ("Forwarding exec reply to inferior", ret);
// OBSOLETE 
// OBSOLETE   /* Garbage collect */
// OBSOLETE   ret = mach_port_deallocate (inferior_task,
// OBSOLETE 			      original_server_port_name);
// OBSOLETE   CHK ("deallocating fake server send right", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_insert_right (inferior_task,
// OBSOLETE 				original_server_port_name,
// OBSOLETE 				original_server_send,
// OBSOLETE 				MACH_MSG_TYPE_MOVE_SEND);
// OBSOLETE   CHK ("Restoring the original bsd server send right", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_destroy (mach_task_self (),
// OBSOLETE 			   fake_server);
// OBSOLETE   fake_server = MACH_PORT_DEAD;
// OBSOLETE   CHK ("mach_port_destroy (fake_server)", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_destroy (mach_task_self (),
// OBSOLETE 			   exec_reply);
// OBSOLETE   exec_reply = MACH_PORT_DEAD;
// OBSOLETE   CHK ("mach_port_destroy (exec_reply)", ret);
// OBSOLETE 
// OBSOLETE   xx_debug ("Done with exec call interception\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE consume_send_rights (thread_array_t thread_list, int thread_count)
// OBSOLETE {
// OBSOLETE   int index;
// OBSOLETE 
// OBSOLETE   if (!thread_count)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   for (index = 0; index < thread_count; index++)
// OBSOLETE     {
// OBSOLETE       /* Since thread kill command kills threads, don't check ret */
// OBSOLETE       (void) mach_port_deallocate (mach_task_self (),
// OBSOLETE 				   thread_list[index]);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* suspend/abort/resume a thread. */
// OBSOLETE setup_thread (mach_port_t thread, int what)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (what)
// OBSOLETE     {
// OBSOLETE       ret = thread_suspend (thread);
// OBSOLETE       CHK ("setup_thread thread_suspend", ret);
// OBSOLETE 
// OBSOLETE       ret = thread_abort (thread);
// OBSOLETE       CHK ("setup_thread thread_abort", ret);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       ret = thread_resume (thread);
// OBSOLETE       CHK ("setup_thread thread_resume", ret);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE map_slot_to_mid (int slot, thread_array_t threads, int thread_count)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int deallocate = 0;
// OBSOLETE   int index;
// OBSOLETE   int mid;
// OBSOLETE 
// OBSOLETE   if (!threads)
// OBSOLETE     {
// OBSOLETE       deallocate++;
// OBSOLETE       ret = task_threads (inferior_task, &threads, &thread_count);
// OBSOLETE       CHK ("Can not select a thread from a dead task", ret);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (slot < 0 || slot >= thread_count)
// OBSOLETE     {
// OBSOLETE       if (deallocate)
// OBSOLETE 	{
// OBSOLETE 	  consume_send_rights (threads, thread_count);
// OBSOLETE 	  (void) vm_deallocate (mach_task_self (), (vm_address_t) threads,
// OBSOLETE 				(thread_count * sizeof (mach_port_t)));
// OBSOLETE 	}
// OBSOLETE       if (slot < 0)
// OBSOLETE 	error ("invalid slot number");
// OBSOLETE       else
// OBSOLETE 	return -(slot + 1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   mid = map_port_name_to_mid (threads[slot], MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE   if (deallocate)
// OBSOLETE     {
// OBSOLETE       consume_send_rights (threads, thread_count);
// OBSOLETE       (void) vm_deallocate (mach_task_self (), (vm_address_t) threads,
// OBSOLETE 			    (thread_count * sizeof (mach_port_t)));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return mid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE parse_thread_id (char *arg, int thread_count, int slots)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int mid;
// OBSOLETE   int slot;
// OBSOLETE   int index;
// OBSOLETE 
// OBSOLETE   if (arg == 0)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   while (*arg && (*arg == ' ' || *arg == '\t'))
// OBSOLETE     arg++;
// OBSOLETE 
// OBSOLETE   if (!*arg)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   /* Currently parse MID and @@SLOTNUMBER */
// OBSOLETE   if (*arg != '@@')
// OBSOLETE     {
// OBSOLETE       mid = atoi (arg);
// OBSOLETE       if (mid <= 0)
// OBSOLETE 	error ("valid thread mid expected");
// OBSOLETE       return mid;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   arg++;
// OBSOLETE   slot = atoi (arg);
// OBSOLETE 
// OBSOLETE   if (slot < 0)
// OBSOLETE     error ("invalid slot number");
// OBSOLETE 
// OBSOLETE   /* If you want slot numbers to remain slot numbers, set slots.
// OBSOLETE 
// OBSOLETE    * Well, since 0 is reserved, return the ordinal number
// OBSOLETE    * of the thread rather than the slot number. Awk, this
// OBSOLETE    * counts as a kludge.
// OBSOLETE    */
// OBSOLETE   if (slots)
// OBSOLETE     return -(slot + 1);
// OBSOLETE 
// OBSOLETE   if (thread_count && slot >= thread_count)
// OBSOLETE     return -(slot + 1);
// OBSOLETE 
// OBSOLETE   mid = map_slot_to_mid (slot);
// OBSOLETE 
// OBSOLETE   return mid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* THREAD_ID 0 is special; it selects the first kernel
// OBSOLETE  * thread from the list (i.e. SLOTNUMBER 0)
// OBSOLETE  * This is used when starting the program with 'run' or when attaching.
// OBSOLETE  *
// OBSOLETE  * If FLAG is 0 the context is not changed, and the registers, frame, etc
// OBSOLETE  * will continue to describe the old thread.
// OBSOLETE  *
// OBSOLETE  * If FLAG is nonzero, really select the thread.
// OBSOLETE  * If FLAG is 2, the THREAD_ID is a slotnumber instead of a mid.
// OBSOLETE  * 
// OBSOLETE  */
// OBSOLETE kern_return_t
// OBSOLETE select_thread (mach_port_t task, int thread_id, int flag)
// OBSOLETE {
// OBSOLETE   thread_array_t thread_list;
// OBSOLETE   int thread_count;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int index;
// OBSOLETE   thread_t new_thread = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE   if (thread_id < 0)
// OBSOLETE     error ("Can't select cprocs without kernel thread");
// OBSOLETE 
// OBSOLETE   ret = task_threads (task, &thread_list, &thread_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("Can not select a thread from a dead task");
// OBSOLETE       m3_kill_inferior ();
// OBSOLETE       return KERN_FAILURE;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (thread_count == 0)
// OBSOLETE     {
// OBSOLETE       /* The task can not do anything anymore, but it still
// OBSOLETE        * exists as a container for memory and ports.
// OBSOLETE        */
// OBSOLETE       registers_changed ();
// OBSOLETE       warning ("Task %d has no threads",
// OBSOLETE 	       map_port_name_to_mid (task, MACH_TYPE_TASK));
// OBSOLETE       current_thread = MACH_PORT_NULL;
// OBSOLETE       (void) vm_deallocate (mach_task_self (),
// OBSOLETE 			    (vm_address_t) thread_list,
// OBSOLETE 			    (thread_count * sizeof (mach_port_t)));
// OBSOLETE       return KERN_FAILURE;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!thread_id || flag == 2)
// OBSOLETE     {
// OBSOLETE       /* First thread or a slotnumber */
// OBSOLETE       if (!thread_id)
// OBSOLETE 	new_thread = thread_list[0];
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (thread_id < thread_count)
// OBSOLETE 	    new_thread = thread_list[thread_id];
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      (void) vm_deallocate (mach_task_self (),
// OBSOLETE 				    (vm_address_t) thread_list,
// OBSOLETE 				    (thread_count * sizeof (mach_port_t)));
// OBSOLETE 	      error ("No such thread slot number : %d", thread_id);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       for (index = 0; index < thread_count; index++)
// OBSOLETE 	if (thread_id == map_port_name_to_mid (thread_list[index],
// OBSOLETE 					       MACH_TYPE_THREAD))
// OBSOLETE 	  {
// OBSOLETE 	    new_thread = thread_list[index];
// OBSOLETE 	    index = -1;
// OBSOLETE 	    break;
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE       if (index != -1)
// OBSOLETE 	error ("No thread with mid %d", thread_id);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Notify when the selected thread dies */
// OBSOLETE   request_notify (new_thread, MACH_NOTIFY_DEAD_NAME, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE   ret = vm_deallocate (mach_task_self (),
// OBSOLETE 		       (vm_address_t) thread_list,
// OBSOLETE 		       (thread_count * sizeof (mach_port_t)));
// OBSOLETE   CHK ("vm_deallocate", ret);
// OBSOLETE 
// OBSOLETE   if (!flag)
// OBSOLETE     current_thread = new_thread;
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE #if 0
// OBSOLETE       if (MACH_PORT_VALID (current_thread))
// OBSOLETE 	{
// OBSOLETE 	  /* Store the gdb's view of the thread we are deselecting
// OBSOLETE 
// OBSOLETE 	   * @@@@ I think gdb updates registers immediately when they are
// OBSOLETE 	   * changed, so don't do this.
// OBSOLETE 	   */
// OBSOLETE 	  ret = thread_abort (current_thread);
// OBSOLETE 	  CHK ("Could not abort system calls when saving state of old thread",
// OBSOLETE 	       ret);
// OBSOLETE 	  target_prepare_to_store ();
// OBSOLETE 	  target_store_registers (-1);
// OBSOLETE 	}
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE       registers_changed ();
// OBSOLETE 
// OBSOLETE       current_thread = new_thread;
// OBSOLETE 
// OBSOLETE       ret = thread_abort (current_thread);
// OBSOLETE       CHK ("Could not abort system calls when selecting a thread", ret);
// OBSOLETE 
// OBSOLETE       stop_pc = read_pc ();
// OBSOLETE       flush_cached_frames ();
// OBSOLETE 
// OBSOLETE       select_frame (get_current_frame ());
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Switch to use thread named NEW_THREAD.
// OBSOLETE  * Return it's MID
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE switch_to_thread (thread_t new_thread)
// OBSOLETE {
// OBSOLETE   thread_t saved_thread = current_thread;
// OBSOLETE   int mid;
// OBSOLETE 
// OBSOLETE   mid = map_port_name_to_mid (new_thread,
// OBSOLETE 			      MACH_TYPE_THREAD);
// OBSOLETE   if (mid == -1)
// OBSOLETE     warning ("Can't map thread name 0x%x to mid", new_thread);
// OBSOLETE   else if (select_thread (inferior_task, mid, 1) != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       if (current_thread)
// OBSOLETE 	current_thread = saved_thread;
// OBSOLETE       error ("Could not select thread %d", mid);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return mid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Do this in gdb after doing FORK but before STARTUP_INFERIOR.
// OBSOLETE  * Note that the registers are not yet valid in the inferior task.
// OBSOLETE  */
// OBSOLETE static int
// OBSOLETE m3_trace_him (int pid)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   push_target (&m3_ops);
// OBSOLETE 
// OBSOLETE   inferior_task = task_by_pid (pid);
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (inferior_task))
// OBSOLETE     error ("Can not map Unix pid %d to Mach task", pid);
// OBSOLETE 
// OBSOLETE   /* Clean up previous notifications and create new ones */
// OBSOLETE   setup_notify_port (1);
// OBSOLETE 
// OBSOLETE   /* When notification appears, the inferior task has died */
// OBSOLETE   request_notify (inferior_task, MACH_NOTIFY_DEAD_NAME, MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   emulator_present = have_emulator_p (inferior_task);
// OBSOLETE 
// OBSOLETE   /* By default, select the first thread,
// OBSOLETE    * If task has no threads, gives a warning
// OBSOLETE    * Does not fetch registers, since they are not yet valid.
// OBSOLETE    */
// OBSOLETE   select_thread (inferior_task, 0, 0);
// OBSOLETE 
// OBSOLETE   inferior_exception_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE   setup_exception_port ();
// OBSOLETE 
// OBSOLETE   xx_debug ("Now the debugged task is created\n");
// OBSOLETE 
// OBSOLETE   /* One trap to exec the shell, one to exec the program being debugged.  */
// OBSOLETE   intercept_exec_calls (2);
// OBSOLETE 
// OBSOLETE   return pid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE setup_exception_port (void)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    &inferior_exception_port);
// OBSOLETE   CHK ("mach_port_allocate", ret);
// OBSOLETE 
// OBSOLETE   /* add send right */
// OBSOLETE   ret = mach_port_insert_right (mach_task_self (),
// OBSOLETE 				inferior_exception_port,
// OBSOLETE 				inferior_exception_port,
// OBSOLETE 				MACH_MSG_TYPE_MAKE_SEND);
// OBSOLETE   CHK ("mach_port_insert_right", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 			       inferior_exception_port,
// OBSOLETE 			       inferior_wait_port_set);
// OBSOLETE   CHK ("mach_port_move_member", ret);
// OBSOLETE 
// OBSOLETE   ret = task_get_special_port (inferior_task,
// OBSOLETE 			       TASK_EXCEPTION_PORT,
// OBSOLETE 			       &inferior_old_exception_port);
// OBSOLETE   CHK ("task_get_special_port(old exc)", ret);
// OBSOLETE 
// OBSOLETE   ret = task_set_special_port (inferior_task,
// OBSOLETE 			       TASK_EXCEPTION_PORT,
// OBSOLETE 			       inferior_exception_port);
// OBSOLETE   CHK ("task_set_special_port", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_deallocate (mach_task_self (),
// OBSOLETE 			      inferior_exception_port);
// OBSOLETE   CHK ("mack_port_deallocate", ret);
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE   /* When notify appears, the inferior_task's exception
// OBSOLETE    * port has been destroyed.
// OBSOLETE    *
// OBSOLETE    * Not used, since the dead_name_notification already
// OBSOLETE    * appears when task dies.
// OBSOLETE    *
// OBSOLETE    */
// OBSOLETE   request_notify (inferior_exception_port,
// OBSOLETE 		  MACH_NOTIFY_NO_SENDERS,
// OBSOLETE 		  MACH_TYPE_EXCEPTION_PORT);
// OBSOLETE #endif
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Nonzero if gdb is waiting for a message */
// OBSOLETE int mach_really_waiting;
// OBSOLETE 
// OBSOLETE /* Wait for the inferior to stop for some reason.
// OBSOLETE    - Loop on notifications until inferior_task dies.
// OBSOLETE    - Loop on exceptions until stopped_in_exception comes true.
// OBSOLETE    (e.g. we receive a single step trace trap)
// OBSOLETE    - a message arrives to gdb's message port
// OBSOLETE 
// OBSOLETE    There is no other way to exit this loop.
// OBSOLETE 
// OBSOLETE    Returns the inferior_ptid for rest of gdb.
// OBSOLETE    Side effects: Set *OURSTATUS.  */
// OBSOLETE ptid_t
// OBSOLETE mach_really_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int w;
// OBSOLETE 
// OBSOLETE   struct msg
// OBSOLETE     {
// OBSOLETE       mach_msg_header_t header;
// OBSOLETE       mach_msg_type_t foo;
// OBSOLETE       int data[8000];
// OBSOLETE     }
// OBSOLETE   in_msg, out_msg;
// OBSOLETE 
// OBSOLETE   /* Either notify (death), exception or message can stop the inferior */
// OBSOLETE   stopped_in_exception = FALSE;
// OBSOLETE 
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       QUIT;
// OBSOLETE 
// OBSOLETE       stop_exception = stop_code = stop_subcode = -1;
// OBSOLETE       stop_thread = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE       mach_really_waiting = 1;
// OBSOLETE       ret = mach_msg (&in_msg.header,	/* header */
// OBSOLETE 		      MACH_RCV_MSG,	/* options */
// OBSOLETE 		      0,	/* send size */
// OBSOLETE 		      sizeof (struct msg),	/* receive size */
// OBSOLETE 		      currently_waiting_for,	/* receive name */
// OBSOLETE 		      MACH_MSG_TIMEOUT_NONE,
// OBSOLETE 		      MACH_PORT_NULL);
// OBSOLETE       mach_really_waiting = 0;
// OBSOLETE       CHK ("mach_msg (receive)", ret);
// OBSOLETE 
// OBSOLETE       /* Check if we received a notify of the childs' death */
// OBSOLETE       if (notify_server (&in_msg.header, &out_msg.header))
// OBSOLETE 	{
// OBSOLETE 	  /* If inferior_task is null then the inferior has
// OBSOLETE 	     gone away and we want to return to command level.
// OBSOLETE 	     Otherwise it was just an informative message and we
// OBSOLETE 	     need to look to see if there are any more. */
// OBSOLETE 	  if (inferior_task != MACH_PORT_NULL)
// OBSOLETE 	    continue;
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      /* Collect Unix exit status for gdb */
// OBSOLETE 
// OBSOLETE 	      wait3 (&w, WNOHANG, 0);
// OBSOLETE 
// OBSOLETE 	      /* This mess is here to check that the rest of
// OBSOLETE 	       * gdb knows that the inferior died. It also
// OBSOLETE 	       * tries to hack around the fact that Mach 3.0 (mk69)
// OBSOLETE 	       * unix server (ux28) does not always know what
// OBSOLETE 	       * has happened to it's children when mach-magic
// OBSOLETE 	       * is applied on them.
// OBSOLETE 	       */
// OBSOLETE 	      if ((!WIFEXITED (w) && WIFSTOPPED (w)) ||
// OBSOLETE 		  (WIFEXITED (w) && WEXITSTATUS (w) > 0377))
// OBSOLETE 		{
// OBSOLETE 		  WSETEXIT (w, 0);
// OBSOLETE 		  warning ("Using exit value 0 for terminated task");
// OBSOLETE 		}
// OBSOLETE 	      else if (!WIFEXITED (w))
// OBSOLETE 		{
// OBSOLETE 		  int sig = WTERMSIG (w);
// OBSOLETE 
// OBSOLETE 		  /* Signals cause problems. Warn the user. */
// OBSOLETE 		  if (sig != SIGKILL)	/* Bad luck if garbage matches this */
// OBSOLETE 		    warning ("The terminating signal stuff may be nonsense");
// OBSOLETE 		  else if (sig > NSIG)
// OBSOLETE 		    {
// OBSOLETE 		      WSETEXIT (w, 0);
// OBSOLETE 		      warning ("Using exit value 0 for terminated task");
// OBSOLETE 		    }
// OBSOLETE 		}
// OBSOLETE 	      store_waitstatus (ourstatus, w);
// OBSOLETE 	      return inferior_ptid;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Hmm. Check for exception, as it was not a notification.
// OBSOLETE          exc_server() does an upcall to catch_exception_raise()
// OBSOLETE          if this rpc is an exception. Further actions are decided
// OBSOLETE          there.
// OBSOLETE        */
// OBSOLETE       if (!exc_server (&in_msg.header, &out_msg.header))
// OBSOLETE 	{
// OBSOLETE 
// OBSOLETE 	  /* Not an exception, check for message.
// OBSOLETE 
// OBSOLETE 	   * Messages don't come from the inferior, or if they
// OBSOLETE 	   * do they better be asynchronous or it will hang.
// OBSOLETE 	   */
// OBSOLETE 	  if (gdb_message_server (&in_msg.header))
// OBSOLETE 	    continue;
// OBSOLETE 
// OBSOLETE 	  error ("Unrecognized message received in mach_really_wait");
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Send the reply of the exception rpc to the suspended task */
// OBSOLETE       ret = mach_msg_send (&out_msg.header);
// OBSOLETE       CHK ("mach_msg_send (exc reply)", ret);
// OBSOLETE 
// OBSOLETE       if (stopped_in_exception)
// OBSOLETE 	{
// OBSOLETE 	  /* Get unix state. May be changed in mach3_exception_actions() */
// OBSOLETE 	  wait3 (&w, WNOHANG, 0);
// OBSOLETE 
// OBSOLETE 	  mach3_exception_actions (&w, FALSE, "Task");
// OBSOLETE 
// OBSOLETE 	  store_waitstatus (ourstatus, w);
// OBSOLETE 	  return inferior_ptid;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Called by macro DO_QUIT() in utils.c(quit).
// OBSOLETE  * This is called just before calling error() to return to command level
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE mach3_quit (void)
// OBSOLETE {
// OBSOLETE   int mid;
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (mach_really_waiting)
// OBSOLETE     {
// OBSOLETE       ret = task_suspend (inferior_task);
// OBSOLETE 
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	{
// OBSOLETE 	  warning ("Could not suspend task for interrupt: %s",
// OBSOLETE 		   mach_error_string (ret));
// OBSOLETE 	  mach_really_waiting = 0;
// OBSOLETE 	  return;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   must_suspend_thread = 0;
// OBSOLETE   mach_really_waiting = 0;
// OBSOLETE 
// OBSOLETE   mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
// OBSOLETE   if (mid == -1)
// OBSOLETE     {
// OBSOLETE       warning ("Selecting first existing kernel thread");
// OBSOLETE       mid = 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   current_thread = MACH_PORT_NULL;	/* Force setup */
// OBSOLETE   select_thread (inferior_task, mid, 1);
// OBSOLETE 
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE /* bogus bogus bogus.  It is NOT OK to quit out of target_wait.  */
// OBSOLETE 
// OBSOLETE /* If ^C is typed when we are waiting for a message
// OBSOLETE  * and your Unix server is able to notice that we 
// OBSOLETE  * should quit now.
// OBSOLETE  *
// OBSOLETE  * Called by REQUEST_QUIT() from utils.c(request_quit)
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE mach3_request_quit (void)
// OBSOLETE {
// OBSOLETE   if (mach_really_waiting)
// OBSOLETE     immediate_quit = 1;
// OBSOLETE }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Gdb message server.
// OBSOLETE  * Currently implemented is the STOP message, that causes
// OBSOLETE  * gdb to return to the command level like ^C had been typed from terminal.
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE gdb_message_server (mach_msg_header_t *InP)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int mid;
// OBSOLETE 
// OBSOLETE   if (InP->msgh_local_port == our_message_port)
// OBSOLETE     {
// OBSOLETE       /* A message coming to our_message_port. Check validity */
// OBSOLETE       switch (InP->msgh_id)
// OBSOLETE 	{
// OBSOLETE 
// OBSOLETE 	case GDB_MESSAGE_ID_STOP:
// OBSOLETE 	  ret = task_suspend (inferior_task);
// OBSOLETE 	  if (ret != KERN_SUCCESS)
// OBSOLETE 	    warning ("Could not suspend task for stop message: %s",
// OBSOLETE 		     mach_error_string (ret));
// OBSOLETE 
// OBSOLETE 	  /* QUIT in mach_really_wait() loop. */
// OBSOLETE 	  request_quit (0);
// OBSOLETE 	  break;
// OBSOLETE 
// OBSOLETE 	default:
// OBSOLETE 	  warning ("Invalid message id %d received, ignored.",
// OBSOLETE 		   InP->msgh_id);
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Message not handled by this server */
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* NOTE: This is not an RPC call. It is a simpleroutine.
// OBSOLETE 
// OBSOLETE  * This is not called from this gdb code.
// OBSOLETE  *
// OBSOLETE  * It may be called by another debugger to cause this
// OBSOLETE  * debugger to enter command level:
// OBSOLETE  *
// OBSOLETE  *            (gdb) set stop_inferior_gdb ()
// OBSOLETE  *            (gdb) continue
// OBSOLETE  *
// OBSOLETE  * External program "stop-gdb" implements this also.
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE stop_inferior_gdb (void)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   /* Code generated by mig, with minor cleanups :-)
// OBSOLETE 
// OBSOLETE    * simpleroutine stop_inferior_gdb (our_message_port : mach_port_t);
// OBSOLETE    */
// OBSOLETE 
// OBSOLETE   typedef struct
// OBSOLETE     {
// OBSOLETE       mach_msg_header_t Head;
// OBSOLETE     }
// OBSOLETE   Request;
// OBSOLETE 
// OBSOLETE   Request Mess;
// OBSOLETE 
// OBSOLETE   register Request *InP = &Mess;
// OBSOLETE 
// OBSOLETE   InP->Head.msgh_bits = MACH_MSGH_BITS (MACH_MSG_TYPE_COPY_SEND, 0);
// OBSOLETE 
// OBSOLETE   /* msgh_size passed as argument */
// OBSOLETE   InP->Head.msgh_remote_port = our_message_port;
// OBSOLETE   InP->Head.msgh_local_port = MACH_PORT_NULL;
// OBSOLETE   InP->Head.msgh_seqno = 0;
// OBSOLETE   InP->Head.msgh_id = GDB_MESSAGE_ID_STOP;
// OBSOLETE 
// OBSOLETE   ret = mach_msg (&InP->Head,
// OBSOLETE 		  MACH_SEND_MSG | MACH_MSG_OPTION_NONE,
// OBSOLETE 		  sizeof (Request),
// OBSOLETE 		  0,
// OBSOLETE 		  MACH_PORT_NULL,
// OBSOLETE 		  MACH_MSG_TIMEOUT_NONE,
// OBSOLETE 		  MACH_PORT_NULL);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef THREAD_ALLOWED_TO_BREAK
// OBSOLETE /*
// OBSOLETE  * Return 1 if the MID specifies the thread that caused the
// OBSOLETE  * last exception.
// OBSOLETE  *  Since catch_exception_raise() selects the thread causing
// OBSOLETE  * the last exception to current_thread, we just check that
// OBSOLETE  * it is selected and the last exception was a breakpoint.
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE mach_thread_for_breakpoint (int mid)
// OBSOLETE {
// OBSOLETE   int cmid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE   if (mid < 0)
// OBSOLETE     {
// OBSOLETE       mid = map_slot_to_mid (-(mid + 1), 0, 0);
// OBSOLETE       if (mid < 0)
// OBSOLETE 	return 0;		/* Don't stop, no such slot */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!mid || cmid == -1)
// OBSOLETE     return 1;			/* stop */
// OBSOLETE 
// OBSOLETE   return cmid == mid && stop_exception == EXC_BREAKPOINT;
// OBSOLETE }
// OBSOLETE #endif /* THREAD_ALLOWED_TO_BREAK */
// OBSOLETE 
// OBSOLETE #ifdef THREAD_PARSE_ID
// OBSOLETE /*
// OBSOLETE  * Map a thread id string (MID or a @@SLOTNUMBER)
// OBSOLETE  * to a thread-id.
// OBSOLETE  *
// OBSOLETE  *   0  matches all threads.
// OBSOLETE  *   Otherwise the meaning is defined only in this file.
// OBSOLETE  *   (mach_thread_for_breakpoint uses it)
// OBSOLETE  *
// OBSOLETE  * @@@@ This allows non-existent MIDs to be specified.
// OBSOLETE  *    It now also allows non-existent slots to be
// OBSOLETE  *    specified. (Slot numbers stored are negative,
// OBSOLETE  *    and the magnitude is one greater than the actual
// OBSOLETE  *    slot index. (Since 0 is reserved))
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE mach_thread_parse_id (char *arg)
// OBSOLETE {
// OBSOLETE   int mid;
// OBSOLETE   if (arg == 0)
// OBSOLETE     error ("thread id expected");
// OBSOLETE   mid = parse_thread_id (arg, 0, 1);
// OBSOLETE 
// OBSOLETE   return mid;
// OBSOLETE }
// OBSOLETE #endif /* THREAD_PARSE_ID */
// OBSOLETE 
// OBSOLETE #ifdef THREAD_OUTPUT_ID
// OBSOLETE char *
// OBSOLETE mach_thread_output_id (int mid)
// OBSOLETE {
// OBSOLETE   static char foobar[20];
// OBSOLETE 
// OBSOLETE   if (mid > 0)
// OBSOLETE     sprintf (foobar, "mid %d", mid);
// OBSOLETE   else if (mid < 0)
// OBSOLETE     sprintf (foobar, "@@%d", -(mid + 1));
// OBSOLETE   else
// OBSOLETE     sprintf (foobar, "*any thread*");
// OBSOLETE 
// OBSOLETE   return foobar;
// OBSOLETE }
// OBSOLETE #endif /* THREAD_OUTPUT_ID */
// OBSOLETE 
// OBSOLETE /* Called with hook PREPARE_TO_PROCEED() from infrun.c.
// OBSOLETE 
// OBSOLETE  * If we have switched threads and stopped at breakpoint return 1 otherwise 0.
// OBSOLETE  *
// OBSOLETE  *  if SELECT_IT is nonzero, reselect the thread that was active when
// OBSOLETE  *  we stopped at a breakpoint.
// OBSOLETE  *
// OBSOLETE  * Note that this implementation is potentially redundant now that
// OBSOLETE  * default_prepare_to_proceed() has been added.  
// OBSOLETE  *
// OBSOLETE  * FIXME This may not support switching threads after Ctrl-C
// OBSOLETE  * correctly. The default implementation does support this.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE mach3_prepare_to_proceed (int select_it)
// OBSOLETE {
// OBSOLETE   if (stop_thread &&
// OBSOLETE       stop_thread != current_thread &&
// OBSOLETE       stop_exception == EXC_BREAKPOINT)
// OBSOLETE     {
// OBSOLETE       int mid;
// OBSOLETE 
// OBSOLETE       if (!select_it)
// OBSOLETE 	return 1;
// OBSOLETE 
// OBSOLETE       mid = switch_to_thread (stop_thread);
// OBSOLETE 
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* this stuff here is an upcall via libmach/excServer.c 
// OBSOLETE    and mach_really_wait which does the actual upcall.
// OBSOLETE 
// OBSOLETE    The code will pass the exception to the inferior if:
// OBSOLETE 
// OBSOLETE    - The task that signaled is not the inferior task
// OBSOLETE    (e.g. when debugging another debugger)
// OBSOLETE 
// OBSOLETE    - The user has explicitely requested to pass on the exceptions.
// OBSOLETE    (e.g to the default unix exception handler, which maps
// OBSOLETE    exceptions to signals, or the user has her own exception handler)
// OBSOLETE 
// OBSOLETE    - If the thread that signaled is being single-stepped and it
// OBSOLETE    has set it's own exception port and the exception is not
// OBSOLETE    EXC_BREAKPOINT. (Maybe this is not desirable?)
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE catch_exception_raise (mach_port_t port, thread_t thread, task_t task,
// OBSOLETE 		       int exception, int code, int subcode)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   boolean_t signal_thread;
// OBSOLETE   int mid = map_port_name_to_mid (thread, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (thread))
// OBSOLETE     {
// OBSOLETE       /* If the exception was sent and thread dies before we
// OBSOLETE          receive it, THREAD will be MACH_PORT_DEAD
// OBSOLETE        */
// OBSOLETE 
// OBSOLETE       current_thread = thread = MACH_PORT_NULL;
// OBSOLETE       error ("Received exception from nonexistent thread");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Check if the task died in transit.
// OBSOLETE    * @@@@ Isn't the thread also invalid in such case?
// OBSOLETE    */
// OBSOLETE   if (!MACH_PORT_VALID (task))
// OBSOLETE     {
// OBSOLETE       current_thread = thread = MACH_PORT_NULL;
// OBSOLETE       error ("Received exception from nonexistent task");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (exception < 0 || exception > MAX_EXCEPTION)
// OBSOLETE     internal_error (__FILE__, __LINE__,
// OBSOLETE 		    "catch_exception_raise: unknown exception code %d thread %d",
// OBSOLETE 		    exception,
// OBSOLETE 		    mid);
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (inferior_task))
// OBSOLETE     error ("got an exception, but inferior_task is null or dead");
// OBSOLETE 
// OBSOLETE   stop_exception = exception;
// OBSOLETE   stop_code = code;
// OBSOLETE   stop_subcode = subcode;
// OBSOLETE   stop_thread = thread;
// OBSOLETE 
// OBSOLETE   signal_thread = exception != EXC_BREAKPOINT &&
// OBSOLETE     port == singlestepped_thread_port &&
// OBSOLETE     MACH_PORT_VALID (thread_saved_exception_port);
// OBSOLETE 
// OBSOLETE   /* If it was not our inferior or if we want to forward
// OBSOLETE    * the exception to the inferior's handler, do it here
// OBSOLETE    *
// OBSOLETE    * Note: If you have forwarded EXC_BREAKPOINT I trust you know why.
// OBSOLETE    */
// OBSOLETE   if (task != inferior_task ||
// OBSOLETE       signal_thread ||
// OBSOLETE       exception_map[exception].forward)
// OBSOLETE     {
// OBSOLETE       mach_port_t eport = inferior_old_exception_port;
// OBSOLETE 
// OBSOLETE       if (signal_thread)
// OBSOLETE 	{
// OBSOLETE 	  /*
// OBSOLETE 	     GDB now forwards the exeption to thread's original handler,
// OBSOLETE 	     since the user propably knows what he is doing.
// OBSOLETE 	     Give a message, though.
// OBSOLETE 	   */
// OBSOLETE 
// OBSOLETE 	  mach3_exception_actions ((WAITTYPE *) NULL, TRUE, "Thread");
// OBSOLETE 	  eport = thread_saved_exception_port;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Send the exception to the original handler */
// OBSOLETE       ret = exception_raise (eport,
// OBSOLETE 			     thread,
// OBSOLETE 			     task,
// OBSOLETE 			     exception,
// OBSOLETE 			     code,
// OBSOLETE 			     subcode);
// OBSOLETE 
// OBSOLETE       (void) mach_port_deallocate (mach_task_self (), task);
// OBSOLETE       (void) mach_port_deallocate (mach_task_self (), thread);
// OBSOLETE 
// OBSOLETE       /* If we come here, we don't want to trace any more, since we
// OBSOLETE        * will never stop for tracing anyway.
// OBSOLETE        */
// OBSOLETE       discard_single_step (thread);
// OBSOLETE 
// OBSOLETE       /* Do not stop the inferior */
// OBSOLETE       return ret;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Now gdb handles the exception */
// OBSOLETE   stopped_in_exception = TRUE;
// OBSOLETE 
// OBSOLETE   ret = task_suspend (task);
// OBSOLETE   CHK ("Error suspending inferior after exception", ret);
// OBSOLETE 
// OBSOLETE   must_suspend_thread = 0;
// OBSOLETE 
// OBSOLETE   if (current_thread != thread)
// OBSOLETE     {
// OBSOLETE       if (MACH_PORT_VALID (singlestepped_thread_port))
// OBSOLETE 	/* Cleanup discards single stepping */
// OBSOLETE 	error ("Exception from thread %d while singlestepping thread %d",
// OBSOLETE 	       mid,
// OBSOLETE 	       map_port_name_to_mid (current_thread, MACH_TYPE_THREAD));
// OBSOLETE 
// OBSOLETE       /* Then select the thread that caused the exception */
// OBSOLETE       if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
// OBSOLETE 	error ("Could not select thread %d causing exception", mid);
// OBSOLETE       else
// OBSOLETE 	warning ("Gdb selected thread %d", mid);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* If we receive an exception that is not breakpoint
// OBSOLETE    * exception, we interrupt the single step and return to
// OBSOLETE    * debugger. Trace condition is cleared.
// OBSOLETE    */
// OBSOLETE   if (MACH_PORT_VALID (singlestepped_thread_port))
// OBSOLETE     {
// OBSOLETE       if (stop_exception != EXC_BREAKPOINT)
// OBSOLETE 	warning ("Single step interrupted by exception");
// OBSOLETE       else if (port == singlestepped_thread_port)
// OBSOLETE 	{
// OBSOLETE 	  /* Single step exception occurred, remove trace bit
// OBSOLETE 	   * and return to gdb.
// OBSOLETE 	   */
// OBSOLETE 	  if (!MACH_PORT_VALID (current_thread))
// OBSOLETE 	    error ("Single stepped thread is not valid");
// OBSOLETE 
// OBSOLETE 	  /* Resume threads, but leave the task suspended */
// OBSOLETE 	  resume_all_threads (0);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	warning ("Breakpoint while single stepping?");
// OBSOLETE 
// OBSOLETE       discard_single_step (current_thread);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   (void) mach_port_deallocate (mach_task_self (), task);
// OBSOLETE   (void) mach_port_deallocate (mach_task_self (), thread);
// OBSOLETE 
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE port_valid (mach_port_t port, int mask)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   mach_port_type_t type;
// OBSOLETE 
// OBSOLETE   ret = mach_port_type (mach_task_self (),
// OBSOLETE 			port,
// OBSOLETE 			&type);
// OBSOLETE   if (ret != KERN_SUCCESS || (type & mask) != mask)
// OBSOLETE     return 0;
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* @@@@ No vm read cache implemented yet */
// OBSOLETE boolean_t vm_read_cache_valid = FALSE;
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Read inferior task's LEN bytes from ADDR and copy it to MYADDR
// OBSOLETE  * in gdb's address space.
// OBSOLETE  *
// OBSOLETE  * Return 0 on failure; number of bytes read otherwise.
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE mach3_read_inferior (CORE_ADDR addr, char *myaddr, int length)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   vm_address_t low_address = (vm_address_t) trunc_page (addr);
// OBSOLETE   vm_size_t aligned_length =
// OBSOLETE   (vm_size_t) round_page (addr + length) - low_address;
// OBSOLETE   pointer_t copied_memory;
// OBSOLETE   int copy_count;
// OBSOLETE 
// OBSOLETE   /* Get memory from inferior with page aligned addresses */
// OBSOLETE   ret = vm_read (inferior_task,
// OBSOLETE 		 low_address,
// OBSOLETE 		 aligned_length,
// OBSOLETE 		 &copied_memory,
// OBSOLETE 		 &copy_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       /* the problem is that the inferior might be killed for whatever reason
// OBSOLETE        * before we go to mach_really_wait. This is one place that ought to
// OBSOLETE        * catch many of those errors.
// OBSOLETE        * @@@@ A better fix would be to make all external events to GDB
// OBSOLETE        * to arrive via a SINGLE port set. (Including user input!)
// OBSOLETE        */
// OBSOLETE 
// OBSOLETE       if (!port_valid (inferior_task, MACH_PORT_TYPE_SEND))
// OBSOLETE 	{
// OBSOLETE 	  m3_kill_inferior ();
// OBSOLETE 	  error ("Inferior killed (task port invalid)");
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE #ifdef OSF
// OBSOLETE 	  extern int errno;
// OBSOLETE 	  /* valprint.c gives nicer format if this does not
// OBSOLETE 	     screw it. Eamonn seems to like this, so I enable
// OBSOLETE 	     it if OSF is defined...
// OBSOLETE 	   */
// OBSOLETE 	  warning ("[read inferior %x failed: %s]",
// OBSOLETE 		   addr, mach_error_string (ret));
// OBSOLETE 	  errno = 0;
// OBSOLETE #endif
// OBSOLETE 	  return 0;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   memcpy (myaddr, (char *) addr - low_address + copied_memory, length);
// OBSOLETE 
// OBSOLETE   ret = vm_deallocate (mach_task_self (),
// OBSOLETE 		       copied_memory,
// OBSOLETE 		       copy_count);
// OBSOLETE   CHK ("mach3_read_inferior vm_deallocate failed", ret);
// OBSOLETE 
// OBSOLETE   return length;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #define CHK_GOTO_OUT(str,ret) \
// OBSOLETE   do if (ret != KERN_SUCCESS) { errstr = #str; goto out; } while(0)
// OBSOLETE 
// OBSOLETE struct vm_region_list
// OBSOLETE {
// OBSOLETE   struct vm_region_list *next;
// OBSOLETE   vm_prot_t protection;
// OBSOLETE   vm_address_t start;
// OBSOLETE   vm_size_t length;
// OBSOLETE };
// OBSOLETE 
// OBSOLETE struct obstack region_obstack;
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Write inferior task's LEN bytes from ADDR and copy it to MYADDR
// OBSOLETE  * in gdb's address space.
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE mach3_write_inferior (CORE_ADDR addr, char *myaddr, int length)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   vm_address_t low_address = (vm_address_t) trunc_page (addr);
// OBSOLETE   vm_size_t aligned_length =
// OBSOLETE   (vm_size_t) round_page (addr + length) - low_address;
// OBSOLETE   pointer_t copied_memory;
// OBSOLETE   int copy_count;
// OBSOLETE   int deallocate = 0;
// OBSOLETE 
// OBSOLETE   char *errstr = "Bug in mach3_write_inferior";
// OBSOLETE 
// OBSOLETE   struct vm_region_list *region_element;
// OBSOLETE   struct vm_region_list *region_head = (struct vm_region_list *) NULL;
// OBSOLETE 
// OBSOLETE   /* Get memory from inferior with page aligned addresses */
// OBSOLETE   ret = vm_read (inferior_task,
// OBSOLETE 		 low_address,
// OBSOLETE 		 aligned_length,
// OBSOLETE 		 &copied_memory,
// OBSOLETE 		 &copy_count);
// OBSOLETE   CHK_GOTO_OUT ("mach3_write_inferior vm_read failed", ret);
// OBSOLETE 
// OBSOLETE   deallocate++;
// OBSOLETE 
// OBSOLETE   memcpy ((char *) addr - low_address + copied_memory, myaddr, length);
// OBSOLETE 
// OBSOLETE   obstack_init (&region_obstack);
// OBSOLETE 
// OBSOLETE   /* Do writes atomically.
// OBSOLETE    * First check for holes and unwritable memory.
// OBSOLETE    */
// OBSOLETE   {
// OBSOLETE     vm_size_t remaining_length = aligned_length;
// OBSOLETE     vm_address_t region_address = low_address;
// OBSOLETE 
// OBSOLETE     struct vm_region_list *scan;
// OBSOLETE 
// OBSOLETE     while (region_address < low_address + aligned_length)
// OBSOLETE       {
// OBSOLETE 	vm_prot_t protection;
// OBSOLETE 	vm_prot_t max_protection;
// OBSOLETE 	vm_inherit_t inheritance;
// OBSOLETE 	boolean_t shared;
// OBSOLETE 	mach_port_t object_name;
// OBSOLETE 	vm_offset_t offset;
// OBSOLETE 	vm_size_t region_length = remaining_length;
// OBSOLETE 	vm_address_t old_address = region_address;
// OBSOLETE 
// OBSOLETE 	ret = vm_region (inferior_task,
// OBSOLETE 			 &region_address,
// OBSOLETE 			 &region_length,
// OBSOLETE 			 &protection,
// OBSOLETE 			 &max_protection,
// OBSOLETE 			 &inheritance,
// OBSOLETE 			 &shared,
// OBSOLETE 			 &object_name,
// OBSOLETE 			 &offset);
// OBSOLETE 	CHK_GOTO_OUT ("vm_region failed", ret);
// OBSOLETE 
// OBSOLETE 	/* Check for holes in memory */
// OBSOLETE 	if (old_address != region_address)
// OBSOLETE 	  {
// OBSOLETE 	    warning ("No memory at 0x%x. Nothing written",
// OBSOLETE 		     old_address);
// OBSOLETE 	    ret = KERN_SUCCESS;
// OBSOLETE 	    length = 0;
// OBSOLETE 	    goto out;
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE 	if (!(max_protection & VM_PROT_WRITE))
// OBSOLETE 	  {
// OBSOLETE 	    warning ("Memory at address 0x%x is unwritable. Nothing written",
// OBSOLETE 		     old_address);
// OBSOLETE 	    ret = KERN_SUCCESS;
// OBSOLETE 	    length = 0;
// OBSOLETE 	    goto out;
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE 	/* Chain the regions for later use */
// OBSOLETE 	region_element =
// OBSOLETE 	  (struct vm_region_list *)
// OBSOLETE 	  obstack_alloc (&region_obstack, sizeof (struct vm_region_list));
// OBSOLETE 
// OBSOLETE 	region_element->protection = protection;
// OBSOLETE 	region_element->start = region_address;
// OBSOLETE 	region_element->length = region_length;
// OBSOLETE 
// OBSOLETE 	/* Chain the regions along with protections */
// OBSOLETE 	region_element->next = region_head;
// OBSOLETE 	region_head = region_element;
// OBSOLETE 
// OBSOLETE 	region_address += region_length;
// OBSOLETE 	remaining_length = remaining_length - region_length;
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE     /* If things fail after this, we give up.
// OBSOLETE      * Somebody is messing up inferior_task's mappings.
// OBSOLETE      */
// OBSOLETE 
// OBSOLETE     /* Enable writes to the chained vm regions */
// OBSOLETE     for (scan = region_head; scan; scan = scan->next)
// OBSOLETE       {
// OBSOLETE 	boolean_t protection_changed = FALSE;
// OBSOLETE 
// OBSOLETE 	if (!(scan->protection & VM_PROT_WRITE))
// OBSOLETE 	  {
// OBSOLETE 	    ret = vm_protect (inferior_task,
// OBSOLETE 			      scan->start,
// OBSOLETE 			      scan->length,
// OBSOLETE 			      FALSE,
// OBSOLETE 			      scan->protection | VM_PROT_WRITE);
// OBSOLETE 	    CHK_GOTO_OUT ("vm_protect: enable write failed", ret);
// OBSOLETE 	  }
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE     ret = vm_write (inferior_task,
// OBSOLETE 		    low_address,
// OBSOLETE 		    copied_memory,
// OBSOLETE 		    aligned_length);
// OBSOLETE     CHK_GOTO_OUT ("vm_write failed", ret);
// OBSOLETE 
// OBSOLETE     /* Set up the original region protections, if they were changed */
// OBSOLETE     for (scan = region_head; scan; scan = scan->next)
// OBSOLETE       {
// OBSOLETE 	boolean_t protection_changed = FALSE;
// OBSOLETE 
// OBSOLETE 	if (!(scan->protection & VM_PROT_WRITE))
// OBSOLETE 	  {
// OBSOLETE 	    ret = vm_protect (inferior_task,
// OBSOLETE 			      scan->start,
// OBSOLETE 			      scan->length,
// OBSOLETE 			      FALSE,
// OBSOLETE 			      scan->protection);
// OBSOLETE 	    CHK_GOTO_OUT ("vm_protect: enable write failed", ret);
// OBSOLETE 	  }
// OBSOLETE       }
// OBSOLETE   }
// OBSOLETE 
// OBSOLETE out:
// OBSOLETE   if (deallocate)
// OBSOLETE     {
// OBSOLETE       obstack_free (&region_obstack, 0);
// OBSOLETE 
// OBSOLETE       (void) vm_deallocate (mach_task_self (),
// OBSOLETE 			    copied_memory,
// OBSOLETE 			    copy_count);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("%s %s", errstr, mach_error_string (ret));
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return length;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return 0 on failure, number of bytes handled otherwise.  TARGET is
// OBSOLETE    ignored. */
// OBSOLETE static int
// OBSOLETE m3_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
// OBSOLETE 		struct target_ops *target)
// OBSOLETE {
// OBSOLETE   int result;
// OBSOLETE 
// OBSOLETE   if (write)
// OBSOLETE     result = mach3_write_inferior (memaddr, myaddr, len);
// OBSOLETE   else
// OBSOLETE     result = mach3_read_inferior (memaddr, myaddr, len);
// OBSOLETE 
// OBSOLETE   return result;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE translate_state (int state)
// OBSOLETE {
// OBSOLETE   switch (state)
// OBSOLETE     {
// OBSOLETE     case TH_STATE_RUNNING:
// OBSOLETE       return ("R");
// OBSOLETE     case TH_STATE_STOPPED:
// OBSOLETE       return ("S");
// OBSOLETE     case TH_STATE_WAITING:
// OBSOLETE       return ("W");
// OBSOLETE     case TH_STATE_UNINTERRUPTIBLE:
// OBSOLETE       return ("U");
// OBSOLETE     case TH_STATE_HALTED:
// OBSOLETE       return ("H");
// OBSOLETE     default:
// OBSOLETE       return ("?");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE translate_cstate (int state)
// OBSOLETE {
// OBSOLETE   switch (state)
// OBSOLETE     {
// OBSOLETE     case CPROC_RUNNING:
// OBSOLETE       return "R";
// OBSOLETE     case CPROC_SWITCHING:
// OBSOLETE       return "S";
// OBSOLETE     case CPROC_BLOCKED:
// OBSOLETE       return "B";
// OBSOLETE     case CPROC_CONDWAIT:
// OBSOLETE       return "C";
// OBSOLETE     case CPROC_CONDWAIT | CPROC_SWITCHING:
// OBSOLETE       return "CS";
// OBSOLETE     default:
// OBSOLETE       return "?";
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* type == MACH_MSG_TYPE_COPY_SEND || type == MACH_MSG_TYPE_MAKE_SEND */
// OBSOLETE 
// OBSOLETE mach_port_t			/* no mach_port_name_t found in include files. */
// OBSOLETE map_inferior_port_name (mach_port_t inferior_name, mach_msg_type_name_t type)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   mach_msg_type_name_t acquired;
// OBSOLETE   mach_port_t iport;
// OBSOLETE 
// OBSOLETE   ret = mach_port_extract_right (inferior_task,
// OBSOLETE 				 inferior_name,
// OBSOLETE 				 type,
// OBSOLETE 				 &iport,
// OBSOLETE 				 &acquired);
// OBSOLETE   CHK ("mach_port_extract_right (map_inferior_port_name)", ret);
// OBSOLETE 
// OBSOLETE   if (acquired != MACH_MSG_TYPE_PORT_SEND)
// OBSOLETE     error ("Incorrect right extracted, (map_inferior_port_name)");
// OBSOLETE 
// OBSOLETE   ret = mach_port_deallocate (mach_task_self (),
// OBSOLETE 			      iport);
// OBSOLETE   CHK ("Deallocating mapped port (map_inferior_port_name)", ret);
// OBSOLETE 
// OBSOLETE   return iport;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Naming convention:
// OBSOLETE  *  Always return user defined name if found.
// OBSOLETE  *  _K == A kernel thread with no matching CPROC
// OBSOLETE  *  _C == A cproc with no current cthread
// OBSOLETE  *  _t == A cthread with no user defined name
// OBSOLETE  *
// OBSOLETE  * The digits that follow the _names are the SLOT number of the
// OBSOLETE  * kernel thread if there is such a thing, otherwise just a negation
// OBSOLETE  * of the sequential number of such cprocs.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static char buf[7];
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE get_thread_name (gdb_thread_t one_cproc, int id)
// OBSOLETE {
// OBSOLETE   if (one_cproc)
// OBSOLETE     if (one_cproc->cthread == NULL)
// OBSOLETE       {
// OBSOLETE 	/* cproc not mapped to any cthread */
// OBSOLETE 	sprintf (buf, "_C%d", id);
// OBSOLETE       }
// OBSOLETE     else if (!one_cproc->cthread->name)
// OBSOLETE       {
// OBSOLETE 	/* cproc and cthread, but no name */
// OBSOLETE 	sprintf (buf, "_t%d", id);
// OBSOLETE       }
// OBSOLETE     else
// OBSOLETE       return (char *) (one_cproc->cthread->name);
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if (id < 0)
// OBSOLETE 	warning ("Inconsistency in thread name id %d", id);
// OBSOLETE 
// OBSOLETE       /* Kernel thread without cproc */
// OBSOLETE       sprintf (buf, "_K%d", id);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return buf;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fetch_thread_info (mach_port_t task, gdb_thread_t *mthreads_out)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_array_t th_table;
// OBSOLETE   int th_count;
// OBSOLETE   gdb_thread_t mthreads = NULL;
// OBSOLETE   int index;
// OBSOLETE 
// OBSOLETE   ret = task_threads (task, &th_table, &th_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("Error getting inferior's thread list:%s",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE       m3_kill_inferior ();
// OBSOLETE       return -1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   mthreads = (gdb_thread_t)
// OBSOLETE     obstack_alloc
// OBSOLETE     (cproc_obstack,
// OBSOLETE      th_count * sizeof (struct gdb_thread));
// OBSOLETE 
// OBSOLETE   for (index = 0; index < th_count; index++)
// OBSOLETE     {
// OBSOLETE       thread_t saved_thread = MACH_PORT_NULL;
// OBSOLETE       int mid;
// OBSOLETE 
// OBSOLETE       if (must_suspend_thread)
// OBSOLETE 	setup_thread (th_table[index], 1);
// OBSOLETE 
// OBSOLETE       if (th_table[index] != current_thread)
// OBSOLETE 	{
// OBSOLETE 	  saved_thread = current_thread;
// OBSOLETE 
// OBSOLETE 	  mid = switch_to_thread (th_table[index]);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       mthreads[index].name = th_table[index];
// OBSOLETE       mthreads[index].cproc = NULL;	/* map_cprocs_to_kernel_threads() */
// OBSOLETE       mthreads[index].in_emulator = FALSE;
// OBSOLETE       mthreads[index].slotid = index;
// OBSOLETE 
// OBSOLETE       mthreads[index].sp = read_register (SP_REGNUM);
// OBSOLETE       mthreads[index].fp = read_register (FP_REGNUM);
// OBSOLETE       mthreads[index].pc = read_pc ();
// OBSOLETE 
// OBSOLETE       if (MACH_PORT_VALID (saved_thread))
// OBSOLETE 	mid = switch_to_thread (saved_thread);
// OBSOLETE 
// OBSOLETE       if (must_suspend_thread)
// OBSOLETE 	setup_thread (th_table[index], 0);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   consume_send_rights (th_table, th_count);
// OBSOLETE   ret = vm_deallocate (mach_task_self (), (vm_address_t) th_table,
// OBSOLETE 		       (th_count * sizeof (mach_port_t)));
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("Error trying to deallocate thread list : %s",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   *mthreads_out = mthreads;
// OBSOLETE 
// OBSOLETE   return th_count;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Current emulator always saves the USP on top of
// OBSOLETE  * emulator stack below struct emul_stack_top stuff.
// OBSOLETE  */
// OBSOLETE CORE_ADDR
// OBSOLETE fetch_usp_from_emulator_stack (CORE_ADDR sp)
// OBSOLETE {
// OBSOLETE   CORE_ADDR stack_pointer;
// OBSOLETE 
// OBSOLETE   sp = (sp & ~(EMULATOR_STACK_SIZE - 1)) +
// OBSOLETE     EMULATOR_STACK_SIZE - sizeof (struct emul_stack_top);
// OBSOLETE 
// OBSOLETE   if (mach3_read_inferior (sp,
// OBSOLETE 			   &stack_pointer,
// OBSOLETE 			   sizeof (CORE_ADDR)) != sizeof (CORE_ADDR))
// OBSOLETE     {
// OBSOLETE       warning ("Can't read user sp from emulator stack address 0x%x", sp);
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return stack_pointer;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef MK67
// OBSOLETE 
// OBSOLETE /* get_emulation_vector() interface was changed after mk67 */
// OBSOLETE #define EMUL_VECTOR_COUNT 400	/* Value does not matter too much */
// OBSOLETE 
// OBSOLETE #endif /* MK67 */
// OBSOLETE 
// OBSOLETE /* Check if the emulator exists at task's address space.
// OBSOLETE  */
// OBSOLETE boolean_t
// OBSOLETE have_emulator_p (task_t task)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE #ifndef EMUL_VECTOR_COUNT
// OBSOLETE   vm_offset_t *emulation_vector;
// OBSOLETE   int n;
// OBSOLETE #else
// OBSOLETE   vm_offset_t emulation_vector[EMUL_VECTOR_COUNT];
// OBSOLETE   int n = EMUL_VECTOR_COUNT;
// OBSOLETE #endif
// OBSOLETE   int i;
// OBSOLETE   int vector_start;
// OBSOLETE 
// OBSOLETE   ret = task_get_emulation_vector (task,
// OBSOLETE 				   &vector_start,
// OBSOLETE #ifndef EMUL_VECTOR_COUNT
// OBSOLETE 				   &emulation_vector,
// OBSOLETE #else
// OBSOLETE 				   emulation_vector,
// OBSOLETE #endif
// OBSOLETE 				   &n);
// OBSOLETE   CHK ("task_get_emulation_vector", ret);
// OBSOLETE   xx_debug ("%d vectors from %d at 0x%08x\n",
// OBSOLETE 	    n, vector_start, emulation_vector);
// OBSOLETE 
// OBSOLETE   for (i = 0; i < n; i++)
// OBSOLETE     {
// OBSOLETE       vm_offset_t entry = emulation_vector[i];
// OBSOLETE 
// OBSOLETE       if (EMULATOR_BASE <= entry && entry <= EMULATOR_END)
// OBSOLETE 	return TRUE;
// OBSOLETE       else if (entry)
// OBSOLETE 	{
// OBSOLETE 	  static boolean_t informed = FALSE;
// OBSOLETE 	  if (!informed)
// OBSOLETE 	    {
// OBSOLETE 	      warning ("Emulation vector address 0x08%x outside emulator space",
// OBSOLETE 		       entry);
// OBSOLETE 	      informed = TRUE;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   return FALSE;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Map cprocs to kernel threads and vice versa.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE map_cprocs_to_kernel_threads (gdb_thread_t cprocs, gdb_thread_t mthreads,
// OBSOLETE 			      int thread_count)
// OBSOLETE {
// OBSOLETE   int index;
// OBSOLETE   gdb_thread_t scan;
// OBSOLETE   boolean_t all_mapped = TRUE;
// OBSOLETE   LONGEST stack_base;
// OBSOLETE   LONGEST stack_size;
// OBSOLETE 
// OBSOLETE   for (scan = cprocs; scan; scan = scan->next)
// OBSOLETE     {
// OBSOLETE       /* Default to: no kernel thread for this cproc */
// OBSOLETE       scan->reverse_map = -1;
// OBSOLETE 
// OBSOLETE       /* Check if the cproc is found by its stack */
// OBSOLETE       for (index = 0; index < thread_count; index++)
// OBSOLETE 	{
// OBSOLETE 	  stack_base =
// OBSOLETE 	    extract_signed_integer (scan->raw_cproc + CPROC_BASE_OFFSET,
// OBSOLETE 				    CPROC_BASE_SIZE);
// OBSOLETE 	  stack_size =
// OBSOLETE 	    extract_signed_integer (scan->raw_cproc + CPROC_SIZE_OFFSET,
// OBSOLETE 				    CPROC_SIZE_SIZE);
// OBSOLETE 	  if ((mthreads + index)->sp > stack_base &&
// OBSOLETE 	      (mthreads + index)->sp <= stack_base + stack_size)
// OBSOLETE 	    {
// OBSOLETE 	      (mthreads + index)->cproc = scan;
// OBSOLETE 	      scan->reverse_map = index;
// OBSOLETE 	      break;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       all_mapped &= (scan->reverse_map != -1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Check for threads that are currently in the emulator.
// OBSOLETE    * If so, they have a different stack, and the still unmapped
// OBSOLETE    * cprocs may well get mapped to these threads.
// OBSOLETE    * 
// OBSOLETE    * If:
// OBSOLETE    *  - cproc stack does not match any kernel thread stack pointer
// OBSOLETE    *  - there is at least one extra kernel thread
// OBSOLETE    *    that has no cproc mapped above.
// OBSOLETE    *  - some kernel thread stack pointer points to emulator space
// OBSOLETE    *  then we find the user stack pointer saved in the emulator
// OBSOLETE    *  stack, and try to map that to the cprocs.
// OBSOLETE    *
// OBSOLETE    * Also set in_emulator for kernel threads.
// OBSOLETE    */
// OBSOLETE 
// OBSOLETE   if (emulator_present)
// OBSOLETE     {
// OBSOLETE       for (index = 0; index < thread_count; index++)
// OBSOLETE 	{
// OBSOLETE 	  CORE_ADDR emul_sp;
// OBSOLETE 	  CORE_ADDR usp;
// OBSOLETE 
// OBSOLETE 	  gdb_thread_t mthread = (mthreads + index);
// OBSOLETE 	  emul_sp = mthread->sp;
// OBSOLETE 
// OBSOLETE 	  if (mthread->cproc == NULL &&
// OBSOLETE 	      EMULATOR_BASE <= emul_sp && emul_sp <= EMULATOR_END)
// OBSOLETE 	    {
// OBSOLETE 	      mthread->in_emulator = emulator_present;
// OBSOLETE 
// OBSOLETE 	      if (!all_mapped && cprocs)
// OBSOLETE 		{
// OBSOLETE 		  usp = fetch_usp_from_emulator_stack (emul_sp);
// OBSOLETE 
// OBSOLETE 		  /* @@@@ Could be more accurate */
// OBSOLETE 		  if (!usp)
// OBSOLETE 		    error ("Zero stack pointer read from emulator?");
// OBSOLETE 
// OBSOLETE 		  /* Try to match this stack pointer to the cprocs that
// OBSOLETE 		   * don't yet have a kernel thread.
// OBSOLETE 		   */
// OBSOLETE 		  for (scan = cprocs; scan; scan = scan->next)
// OBSOLETE 		    {
// OBSOLETE 
// OBSOLETE 		      /* Check is this unmapped CPROC stack contains
// OBSOLETE 		       * the user stack pointer saved in the
// OBSOLETE 		       * emulator.
// OBSOLETE 		       */
// OBSOLETE 		      if (scan->reverse_map == -1)
// OBSOLETE 			{
// OBSOLETE 			  stack_base =
// OBSOLETE 			    extract_signed_integer
// OBSOLETE 			    (scan->raw_cproc + CPROC_BASE_OFFSET,
// OBSOLETE 			     CPROC_BASE_SIZE);
// OBSOLETE 			  stack_size =
// OBSOLETE 			    extract_signed_integer
// OBSOLETE 			    (scan->raw_cproc + CPROC_SIZE_OFFSET,
// OBSOLETE 			     CPROC_SIZE_SIZE);
// OBSOLETE 			  if (usp > stack_base &&
// OBSOLETE 			      usp <= stack_base + stack_size)
// OBSOLETE 			    {
// OBSOLETE 			      mthread->cproc = scan;
// OBSOLETE 			      scan->reverse_map = index;
// OBSOLETE 			      break;
// OBSOLETE 			    }
// OBSOLETE 			}
// OBSOLETE 		    }
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Format of the thread_list command
// OBSOLETE  *
// OBSOLETE  *                   slot mid sel   name  emul ks susp  cstate wired   address
// OBSOLETE  */
// OBSOLETE #define TL_FORMAT "%-2.2s %5d%c %-10.10s %1.1s%s%-5.5s %-2.2s %-5.5s "
// OBSOLETE 
// OBSOLETE #define TL_HEADER "\n@@    MID  Name        KState CState   Where\n"
// OBSOLETE 
// OBSOLETE void
// OBSOLETE print_tl_address (struct ui_file *stream, CORE_ADDR pc)
// OBSOLETE {
// OBSOLETE   if (!lookup_minimal_symbol_by_pc (pc))
// OBSOLETE     fprintf_filtered (stream, local_hex_format (), pc);
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       extern int addressprint;
// OBSOLETE       extern int asm_demangle;
// OBSOLETE 
// OBSOLETE       int store = addressprint;
// OBSOLETE       addressprint = 0;
// OBSOLETE       print_address_symbolic (pc, stream, asm_demangle, "");
// OBSOLETE       addressprint = store;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* For thread names, but also for gdb_message_port external name */
// OBSOLETE #define MAX_NAME_LEN 50
// OBSOLETE 
// OBSOLETE /* Returns the address of variable NAME or 0 if not found */
// OBSOLETE CORE_ADDR
// OBSOLETE lookup_address_of_variable (char *name)
// OBSOLETE {
// OBSOLETE   struct symbol *sym;
// OBSOLETE   CORE_ADDR symaddr = 0;
// OBSOLETE   struct minimal_symbol *msymbol;
// OBSOLETE 
// OBSOLETE   sym = lookup_symbol (name,
// OBSOLETE 		       (struct block *) NULL,
// OBSOLETE 		       VAR_NAMESPACE,
// OBSOLETE 		       (int *) NULL,
// OBSOLETE 		       (struct symtab **) NULL);
// OBSOLETE 
// OBSOLETE   if (sym)
// OBSOLETE     symaddr = SYMBOL_VALUE (sym);
// OBSOLETE 
// OBSOLETE   if (!symaddr)
// OBSOLETE     {
// OBSOLETE       msymbol = lookup_minimal_symbol (name, NULL, NULL);
// OBSOLETE 
// OBSOLETE       if (msymbol && msymbol->type == mst_data)
// OBSOLETE 	symaddr = SYMBOL_VALUE_ADDRESS (msymbol);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return symaddr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static gdb_thread_t
// OBSOLETE get_cprocs (void)
// OBSOLETE {
// OBSOLETE   gdb_thread_t cproc_head;
// OBSOLETE   gdb_thread_t cproc_copy;
// OBSOLETE   CORE_ADDR their_cprocs;
// OBSOLETE   char *buf;
// OBSOLETE   char *name;
// OBSOLETE   cthread_t cthread;
// OBSOLETE   CORE_ADDR symaddr;
// OBSOLETE 
// OBSOLETE   buf = alloca (TARGET_PTR_BIT / HOST_CHAR_BIT);
// OBSOLETE   symaddr = lookup_address_of_variable ("cproc_list");
// OBSOLETE 
// OBSOLETE   if (!symaddr)
// OBSOLETE     {
// OBSOLETE       /* cproc_list is not in a file compiled with debugging
// OBSOLETE          symbols, but don't give up yet */
// OBSOLETE 
// OBSOLETE       symaddr = lookup_address_of_variable ("cprocs");
// OBSOLETE 
// OBSOLETE       if (symaddr)
// OBSOLETE 	{
// OBSOLETE 	  static int informed = 0;
// OBSOLETE 	  if (!informed)
// OBSOLETE 	    {
// OBSOLETE 	      informed++;
// OBSOLETE 	      warning ("Your program is loaded with an old threads library.");
// OBSOLETE 	      warning ("GDB does not know the old form of threads");
// OBSOLETE 	      warning ("so things may not work.");
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Stripped or no -lthreads loaded or "cproc_list" is in wrong segment. */
// OBSOLETE   if (!symaddr)
// OBSOLETE     return NULL;
// OBSOLETE 
// OBSOLETE   /* Get the address of the first cproc in the task */
// OBSOLETE   if (!mach3_read_inferior (symaddr,
// OBSOLETE 			    buf,
// OBSOLETE 			    TARGET_PTR_BIT / HOST_CHAR_BIT))
// OBSOLETE     error ("Can't read cproc master list at address (0x%x).", symaddr);
// OBSOLETE   their_cprocs = extract_address (buf, TARGET_PTR_BIT / HOST_CHAR_BIT);
// OBSOLETE 
// OBSOLETE   /* Scan the CPROCs in the task.
// OBSOLETE      CPROCs are chained with LIST field, not NEXT field, which
// OBSOLETE      chains mutexes, condition variables and queues */
// OBSOLETE 
// OBSOLETE   cproc_head = NULL;
// OBSOLETE 
// OBSOLETE   while (their_cprocs != (CORE_ADDR) 0)
// OBSOLETE     {
// OBSOLETE       CORE_ADDR cproc_copy_incarnation;
// OBSOLETE       cproc_copy = (gdb_thread_t) obstack_alloc (cproc_obstack,
// OBSOLETE 						 sizeof (struct gdb_thread));
// OBSOLETE 
// OBSOLETE       if (!mach3_read_inferior (their_cprocs,
// OBSOLETE 				&cproc_copy->raw_cproc[0],
// OBSOLETE 				CPROC_SIZE))
// OBSOLETE 	error ("Can't read next cproc at 0x%x.", their_cprocs);
// OBSOLETE 
// OBSOLETE       their_cprocs =
// OBSOLETE 	extract_address (cproc_copy->raw_cproc + CPROC_LIST_OFFSET,
// OBSOLETE 			 CPROC_LIST_SIZE);
// OBSOLETE       cproc_copy_incarnation =
// OBSOLETE 	extract_address (cproc_copy->raw_cproc + CPROC_INCARNATION_OFFSET,
// OBSOLETE 			 CPROC_INCARNATION_SIZE);
// OBSOLETE 
// OBSOLETE       if (cproc_copy_incarnation == (CORE_ADDR) 0)
// OBSOLETE 	cproc_copy->cthread = NULL;
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* This CPROC has an attached CTHREAD. Get its name */
// OBSOLETE 	  cthread = (cthread_t) obstack_alloc (cproc_obstack,
// OBSOLETE 					       sizeof (struct cthread));
// OBSOLETE 
// OBSOLETE 	  if (!mach3_read_inferior (cproc_copy_incarnation,
// OBSOLETE 				    cthread,
// OBSOLETE 				    sizeof (struct cthread)))
// OBSOLETE 	      error ("Can't read next thread at 0x%x.",
// OBSOLETE 		     cproc_copy_incarnation);
// OBSOLETE 
// OBSOLETE 	  cproc_copy->cthread = cthread;
// OBSOLETE 
// OBSOLETE 	  if (cthread->name)
// OBSOLETE 	    {
// OBSOLETE 	      name = (char *) obstack_alloc (cproc_obstack, MAX_NAME_LEN);
// OBSOLETE 
// OBSOLETE 	      if (!mach3_read_inferior (cthread->name, name, MAX_NAME_LEN))
// OBSOLETE 		error ("Can't read next thread's name at 0x%x.", cthread->name);
// OBSOLETE 
// OBSOLETE 	      cthread->name = name;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* insert in front */
// OBSOLETE       cproc_copy->next = cproc_head;
// OBSOLETE       cproc_head = cproc_copy;
// OBSOLETE     }
// OBSOLETE   return cproc_head;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifndef FETCH_CPROC_STATE
// OBSOLETE /*
// OBSOLETE  * Check if your machine does not grok the way this routine
// OBSOLETE  * fetches the FP,PC and SP of a cproc that is not
// OBSOLETE  * currently attached to any kernel thread (e.g. its cproc.context
// OBSOLETE  * field points to the place in stack where the context
// OBSOLETE  * is saved).
// OBSOLETE  *
// OBSOLETE  * If it doesn't, define your own routine.
// OBSOLETE  */
// OBSOLETE #define FETCH_CPROC_STATE(mth) mach3_cproc_state (mth)
// OBSOLETE 
// OBSOLETE int
// OBSOLETE mach3_cproc_state (gdb_thread_t mthread)
// OBSOLETE {
// OBSOLETE   int context;
// OBSOLETE 
// OBSOLETE   if (!mthread || !mthread->cproc)
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   context = extract_signed_integer
// OBSOLETE     (mthread->cproc->raw_cproc + CPROC_CONTEXT_OFFSET,
// OBSOLETE      CPROC_CONTEXT_SIZE);
// OBSOLETE   if (context == 0)
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   mthread->sp = context + MACHINE_CPROC_SP_OFFSET;
// OBSOLETE 
// OBSOLETE   if (mach3_read_inferior (context + MACHINE_CPROC_PC_OFFSET,
// OBSOLETE 			   &mthread->pc,
// OBSOLETE 			   sizeof (CORE_ADDR)) != sizeof (CORE_ADDR))
// OBSOLETE     {
// OBSOLETE       warning ("Can't read cproc pc from inferior");
// OBSOLETE       return -1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (mach3_read_inferior (context + MACHINE_CPROC_FP_OFFSET,
// OBSOLETE 			   &mthread->fp,
// OBSOLETE 			   sizeof (CORE_ADDR)) != sizeof (CORE_ADDR))
// OBSOLETE     {
// OBSOLETE       warning ("Can't read cproc fp from inferior");
// OBSOLETE       return -1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE #endif /* FETCH_CPROC_STATE */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE void
// OBSOLETE thread_list_command (void)
// OBSOLETE {
// OBSOLETE   thread_basic_info_data_t ths;
// OBSOLETE   int thread_count;
// OBSOLETE   gdb_thread_t cprocs;
// OBSOLETE   gdb_thread_t scan;
// OBSOLETE   int index;
// OBSOLETE   char *name;
// OBSOLETE   char selected;
// OBSOLETE   char *wired;
// OBSOLETE   int infoCnt;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   mach_port_t mid_or_port;
// OBSOLETE   gdb_thread_t their_threads;
// OBSOLETE   gdb_thread_t kthread;
// OBSOLETE 
// OBSOLETE   int neworder = 1;
// OBSOLETE 
// OBSOLETE   char *fmt = "There are %d kernel threads in task %d.\n";
// OBSOLETE 
// OBSOLETE   int tmid = map_port_name_to_mid (inferior_task, MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   thread_count = fetch_thread_info (inferior_task,
// OBSOLETE 				    &their_threads);
// OBSOLETE   if (thread_count == -1)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   if (thread_count == 1)
// OBSOLETE     fmt = "There is %d kernel thread in task %d.\n";
// OBSOLETE 
// OBSOLETE   printf_filtered (fmt, thread_count, tmid);
// OBSOLETE 
// OBSOLETE   puts_filtered (TL_HEADER);
// OBSOLETE 
// OBSOLETE   cprocs = get_cprocs ();
// OBSOLETE 
// OBSOLETE   map_cprocs_to_kernel_threads (cprocs, their_threads, thread_count);
// OBSOLETE 
// OBSOLETE   for (scan = cprocs; scan; scan = scan->next)
// OBSOLETE     {
// OBSOLETE       int mid;
// OBSOLETE       char buf[10];
// OBSOLETE       char slot[3];
// OBSOLETE       int cproc_state =
// OBSOLETE       extract_signed_integer
// OBSOLETE       (scan->raw_cproc + CPROC_STATE_OFFSET, CPROC_STATE_SIZE);
// OBSOLETE 
// OBSOLETE       selected = ' ';
// OBSOLETE 
// OBSOLETE       /* a wired cproc? */
// OBSOLETE       wired = (extract_address (scan->raw_cproc + CPROC_WIRED_OFFSET,
// OBSOLETE 				CPROC_WIRED_SIZE)
// OBSOLETE 	       ? "wired" : "");
// OBSOLETE 
// OBSOLETE       if (scan->reverse_map != -1)
// OBSOLETE 	kthread = (their_threads + scan->reverse_map);
// OBSOLETE       else
// OBSOLETE 	kthread = NULL;
// OBSOLETE 
// OBSOLETE       if (kthread)
// OBSOLETE 	{
// OBSOLETE 	  /* These cprocs have a kernel thread */
// OBSOLETE 
// OBSOLETE 	  mid = map_port_name_to_mid (kthread->name, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE 	  infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE 
// OBSOLETE 	  ret = thread_info (kthread->name,
// OBSOLETE 			     THREAD_BASIC_INFO,
// OBSOLETE 			     (thread_info_t) & ths,
// OBSOLETE 			     &infoCnt);
// OBSOLETE 
// OBSOLETE 	  if (ret != KERN_SUCCESS)
// OBSOLETE 	    {
// OBSOLETE 	      warning ("Unable to get basic info on thread %d : %s",
// OBSOLETE 		       mid,
// OBSOLETE 		       mach_error_string (ret));
// OBSOLETE 	      continue;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  /* Who is the first to have more than 100 threads */
// OBSOLETE 	  sprintf (slot, "%d", kthread->slotid % 100);
// OBSOLETE 
// OBSOLETE 	  if (kthread->name == current_thread)
// OBSOLETE 	    selected = '*';
// OBSOLETE 
// OBSOLETE 	  if (ths.suspend_count)
// OBSOLETE 	    sprintf (buf, "%d", ths.suspend_count);
// OBSOLETE 	  else
// OBSOLETE 	    buf[0] = '\000';
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE 	  if (ths.flags & TH_FLAGS_SWAPPED)
// OBSOLETE 	    strcat (buf, "S");
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE 	  if (ths.flags & TH_FLAGS_IDLE)
// OBSOLETE 	    strcat (buf, "I");
// OBSOLETE 
// OBSOLETE 	  printf_filtered (TL_FORMAT,
// OBSOLETE 			   slot,
// OBSOLETE 			   mid,
// OBSOLETE 			   selected,
// OBSOLETE 			   get_thread_name (scan, kthread->slotid),
// OBSOLETE 			   kthread->in_emulator ? "E" : "",
// OBSOLETE 			   translate_state (ths.run_state),
// OBSOLETE 			   buf,
// OBSOLETE 			   translate_cstate (cproc_state),
// OBSOLETE 			   wired);
// OBSOLETE 	  print_tl_address (gdb_stdout, kthread->pc);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* These cprocs don't have a kernel thread.
// OBSOLETE 	   * find out the calling frame with 
// OBSOLETE 	   * FETCH_CPROC_STATE.
// OBSOLETE 	   */
// OBSOLETE 
// OBSOLETE 	  struct gdb_thread state;
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE 	  /* jtv -> emcmanus: why do you want this here? */
// OBSOLETE 	  if (scan->incarnation == NULL)
// OBSOLETE 	    continue;		/* EMcM */
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE 	  printf_filtered (TL_FORMAT,
// OBSOLETE 			   "-",
// OBSOLETE 			   -neworder,	/* Pseudo MID */
// OBSOLETE 			   selected,
// OBSOLETE 			   get_thread_name (scan, -neworder),
// OBSOLETE 			   "",
// OBSOLETE 			   "-",	/* kernel state */
// OBSOLETE 			   "",
// OBSOLETE 			   translate_cstate (cproc_state),
// OBSOLETE 			   "");
// OBSOLETE 	  state.cproc = scan;
// OBSOLETE 
// OBSOLETE 	  if (FETCH_CPROC_STATE (&state) == -1)
// OBSOLETE 	    puts_filtered ("???");
// OBSOLETE 	  else
// OBSOLETE 	    print_tl_address (gdb_stdout, state.pc);
// OBSOLETE 
// OBSOLETE 	  neworder++;
// OBSOLETE 	}
// OBSOLETE       puts_filtered ("\n");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Scan for kernel threads without cprocs */
// OBSOLETE   for (index = 0; index < thread_count; index++)
// OBSOLETE     {
// OBSOLETE       if (!their_threads[index].cproc)
// OBSOLETE 	{
// OBSOLETE 	  int mid;
// OBSOLETE 
// OBSOLETE 	  char buf[10];
// OBSOLETE 	  char slot[3];
// OBSOLETE 
// OBSOLETE 	  mach_port_t name = their_threads[index].name;
// OBSOLETE 
// OBSOLETE 	  mid = map_port_name_to_mid (name, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE 	  infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE 
// OBSOLETE 	  ret = thread_info (name,
// OBSOLETE 			     THREAD_BASIC_INFO,
// OBSOLETE 			     (thread_info_t) & ths,
// OBSOLETE 			     &infoCnt);
// OBSOLETE 
// OBSOLETE 	  if (ret != KERN_SUCCESS)
// OBSOLETE 	    {
// OBSOLETE 	      warning ("Unable to get basic info on thread %d : %s",
// OBSOLETE 		       mid,
// OBSOLETE 		       mach_error_string (ret));
// OBSOLETE 	      continue;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  sprintf (slot, "%d", index % 100);
// OBSOLETE 
// OBSOLETE 	  if (name == current_thread)
// OBSOLETE 	    selected = '*';
// OBSOLETE 	  else
// OBSOLETE 	    selected = ' ';
// OBSOLETE 
// OBSOLETE 	  if (ths.suspend_count)
// OBSOLETE 	    sprintf (buf, "%d", ths.suspend_count);
// OBSOLETE 	  else
// OBSOLETE 	    buf[0] = '\000';
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE 	  if (ths.flags & TH_FLAGS_SWAPPED)
// OBSOLETE 	    strcat (buf, "S");
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE 	  if (ths.flags & TH_FLAGS_IDLE)
// OBSOLETE 	    strcat (buf, "I");
// OBSOLETE 
// OBSOLETE 	  printf_filtered (TL_FORMAT,
// OBSOLETE 			   slot,
// OBSOLETE 			   mid,
// OBSOLETE 			   selected,
// OBSOLETE 			   get_thread_name (NULL, index),
// OBSOLETE 			   their_threads[index].in_emulator ? "E" : "",
// OBSOLETE 			   translate_state (ths.run_state),
// OBSOLETE 			   buf,
// OBSOLETE 			   "",	/* No cproc state */
// OBSOLETE 			   "");	/* Can't be wired */
// OBSOLETE 	  print_tl_address (gdb_stdout, their_threads[index].pc);
// OBSOLETE 	  puts_filtered ("\n");
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   obstack_free (cproc_obstack, 0);
// OBSOLETE   obstack_init (cproc_obstack);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE thread_select_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int mid;
// OBSOLETE   thread_array_t thread_list;
// OBSOLETE   int thread_count;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int is_slot = 0;
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     error_no_arg ("MID or @@SLOTNUMBER to specify a thread to select");
// OBSOLETE 
// OBSOLETE   while (*args == ' ' || *args == '\t')
// OBSOLETE     args++;
// OBSOLETE 
// OBSOLETE   if (*args == '@@')
// OBSOLETE     {
// OBSOLETE       is_slot++;
// OBSOLETE       args++;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   mid = atoi (args);
// OBSOLETE 
// OBSOLETE   if (mid == 0)
// OBSOLETE     if (!is_slot || *args != '0')	/* Rudimentary checks */
// OBSOLETE       error ("You must select threads by MID or @@SLOTNUMBER");
// OBSOLETE 
// OBSOLETE   if (select_thread (inferior_task, mid, is_slot ? 2 : 1) != KERN_SUCCESS)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   if (from_tty)
// OBSOLETE     printf_filtered ("Thread %d selected\n",
// OBSOLETE 		     is_slot ? map_port_name_to_mid (current_thread,
// OBSOLETE 						   MACH_TYPE_THREAD) : mid);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE thread_trace (mach_port_t thread, boolean_t set)
// OBSOLETE {
// OBSOLETE   int flavor = TRACE_FLAVOR;
// OBSOLETE   unsigned int stateCnt = TRACE_FLAVOR_SIZE;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_state_data_t state;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (thread))
// OBSOLETE     {
// OBSOLETE       warning ("thread_trace: invalid thread");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (must_suspend_thread)
// OBSOLETE     setup_thread (thread, 1);
// OBSOLETE 
// OBSOLETE   ret = thread_get_state (thread, flavor, state, &stateCnt);
// OBSOLETE   CHK ("thread_trace: error reading thread state", ret);
// OBSOLETE 
// OBSOLETE   if (set)
// OBSOLETE     {
// OBSOLETE       TRACE_SET (thread, state);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if (!TRACE_CLEAR (thread, state))
// OBSOLETE 	{
// OBSOLETE 	  if (must_suspend_thread)
// OBSOLETE 	    setup_thread (thread, 0);
// OBSOLETE 	  return;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = thread_set_state (thread, flavor, state, stateCnt);
// OBSOLETE   CHK ("thread_trace: error writing thread state", ret);
// OBSOLETE   if (must_suspend_thread)
// OBSOLETE     setup_thread (thread, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef	FLUSH_INFERIOR_CACHE
// OBSOLETE 
// OBSOLETE /* When over-writing code on some machines the I-Cache must be flushed
// OBSOLETE    explicitly, because it is not kept coherent by the lazy hardware.
// OBSOLETE    This definitely includes breakpoints, for instance, or else we
// OBSOLETE    end up looping in mysterious Bpt traps */
// OBSOLETE 
// OBSOLETE flush_inferior_icache (CORE_ADDR pc, int amount)
// OBSOLETE {
// OBSOLETE   vm_machine_attribute_val_t flush = MATTR_VAL_ICACHE_FLUSH;
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   ret = vm_machine_attribute (inferior_task,
// OBSOLETE 			      pc,
// OBSOLETE 			      amount,
// OBSOLETE 			      MATTR_CACHE,
// OBSOLETE 			      &flush);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("Error flushing inferior's cache : %s",
// OBSOLETE 	     mach_error_string (ret));
// OBSOLETE }
// OBSOLETE #endif /* FLUSH_INFERIOR_CACHE */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static
// OBSOLETE suspend_all_threads (int from_tty)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_array_t thread_list;
// OBSOLETE   int thread_count, index;
// OBSOLETE   int infoCnt;
// OBSOLETE   thread_basic_info_data_t th_info;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   ret = task_threads (inferior_task, &thread_list, &thread_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("Could not suspend inferior threads.");
// OBSOLETE       m3_kill_inferior ();
// OBSOLETE       throw_exception (RETURN_ERROR);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   for (index = 0; index < thread_count; index++)
// OBSOLETE     {
// OBSOLETE       int mid;
// OBSOLETE 
// OBSOLETE       mid = map_port_name_to_mid (thread_list[index],
// OBSOLETE 				  MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE       ret = thread_suspend (thread_list[index]);
// OBSOLETE 
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	warning ("Error trying to suspend thread %d : %s",
// OBSOLETE 		 mid, mach_error_string (ret));
// OBSOLETE 
// OBSOLETE       if (from_tty)
// OBSOLETE 	{
// OBSOLETE 	  infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE 	  ret = thread_info (thread_list[index],
// OBSOLETE 			     THREAD_BASIC_INFO,
// OBSOLETE 			     (thread_info_t) & th_info,
// OBSOLETE 			     &infoCnt);
// OBSOLETE 	  CHK ("suspend can't get thread info", ret);
// OBSOLETE 
// OBSOLETE 	  warning ("Thread %d suspend count is %d",
// OBSOLETE 		   mid, th_info.suspend_count);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   consume_send_rights (thread_list, thread_count);
// OBSOLETE   ret = vm_deallocate (mach_task_self (),
// OBSOLETE 		       (vm_address_t) thread_list,
// OBSOLETE 		       (thread_count * sizeof (int)));
// OBSOLETE   CHK ("Error trying to deallocate thread list", ret);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE thread_suspend_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int mid;
// OBSOLETE   mach_port_t saved_thread;
// OBSOLETE   int infoCnt;
// OBSOLETE   thread_basic_info_data_t th_info;
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   if (!strcasecmp (args, "all"))
// OBSOLETE     {
// OBSOLETE       suspend_all_threads (from_tty);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   saved_thread = current_thread;
// OBSOLETE 
// OBSOLETE   mid = parse_thread_id (args, 0, 0);
// OBSOLETE 
// OBSOLETE   if (mid < 0)
// OBSOLETE     error ("You can suspend only existing kernel threads with MID or @@SLOTNUMBER");
// OBSOLETE 
// OBSOLETE   if (mid == 0)
// OBSOLETE     mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
// OBSOLETE   else if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       if (current_thread)
// OBSOLETE 	current_thread = saved_thread;
// OBSOLETE       error ("Could not select thread %d", mid);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = thread_suspend (current_thread);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("thread_suspend failed : %s",
// OBSOLETE 	     mach_error_string (ret));
// OBSOLETE 
// OBSOLETE   infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE   ret = thread_info (current_thread,
// OBSOLETE 		     THREAD_BASIC_INFO,
// OBSOLETE 		     (thread_info_t) & th_info,
// OBSOLETE 		     &infoCnt);
// OBSOLETE   CHK ("suspend can't get thread info", ret);
// OBSOLETE 
// OBSOLETE   warning ("Thread %d suspend count is %d", mid, th_info.suspend_count);
// OBSOLETE 
// OBSOLETE   current_thread = saved_thread;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE resume_all_threads (int from_tty)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_array_t thread_list;
// OBSOLETE   int thread_count, index;
// OBSOLETE   int mid;
// OBSOLETE   int infoCnt;
// OBSOLETE   thread_basic_info_data_t th_info;
// OBSOLETE 
// OBSOLETE   ret = task_threads (inferior_task, &thread_list, &thread_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       m3_kill_inferior ();
// OBSOLETE       error ("task_threads", mach_error_string (ret));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   for (index = 0; index < thread_count; index++)
// OBSOLETE     {
// OBSOLETE       infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE       ret = thread_info (thread_list[index],
// OBSOLETE 			 THREAD_BASIC_INFO,
// OBSOLETE 			 (thread_info_t) & th_info,
// OBSOLETE 			 &infoCnt);
// OBSOLETE       CHK ("resume_all can't get thread info", ret);
// OBSOLETE 
// OBSOLETE       mid = map_port_name_to_mid (thread_list[index],
// OBSOLETE 				  MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE       if (!th_info.suspend_count)
// OBSOLETE 	{
// OBSOLETE 	  if (mid != -1 && from_tty)
// OBSOLETE 	    warning ("Thread %d is not suspended", mid);
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       ret = thread_resume (thread_list[index]);
// OBSOLETE 
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	warning ("Error trying to resume thread %d : %s",
// OBSOLETE 		 mid, mach_error_string (ret));
// OBSOLETE       else if (mid != -1 && from_tty)
// OBSOLETE 	warning ("Thread %d suspend count is %d",
// OBSOLETE 		 mid, --th_info.suspend_count);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   consume_send_rights (thread_list, thread_count);
// OBSOLETE   ret = vm_deallocate (mach_task_self (),
// OBSOLETE 		       (vm_address_t) thread_list,
// OBSOLETE 		       (thread_count * sizeof (int)));
// OBSOLETE   CHK ("Error trying to deallocate thread list", ret);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE thread_resume_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int mid;
// OBSOLETE   mach_port_t saved_thread;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_basic_info_data_t th_info;
// OBSOLETE   int infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   if (!strcasecmp (args, "all"))
// OBSOLETE     {
// OBSOLETE       resume_all_threads (from_tty);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   saved_thread = current_thread;
// OBSOLETE 
// OBSOLETE   mid = parse_thread_id (args, 0, 0);
// OBSOLETE 
// OBSOLETE   if (mid < 0)
// OBSOLETE     error ("You can resume only existing kernel threads with MID or @@SLOTNUMBER");
// OBSOLETE 
// OBSOLETE   if (mid == 0)
// OBSOLETE     mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
// OBSOLETE   else if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       if (current_thread)
// OBSOLETE 	current_thread = saved_thread;
// OBSOLETE       throw_exception (RETURN_ERROR);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = thread_info (current_thread,
// OBSOLETE 		     THREAD_BASIC_INFO,
// OBSOLETE 		     (thread_info_t) & th_info,
// OBSOLETE 		     &infoCnt);
// OBSOLETE   CHK ("resume can't get thread info", ret);
// OBSOLETE 
// OBSOLETE   if (!th_info.suspend_count)
// OBSOLETE     {
// OBSOLETE       warning ("Thread %d is not suspended", mid);
// OBSOLETE       goto out;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = thread_resume (current_thread);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("thread_resume failed : %s",
// OBSOLETE 	     mach_error_string (ret));
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       th_info.suspend_count--;
// OBSOLETE       warning ("Thread %d suspend count is %d", mid, th_info.suspend_count);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE out:
// OBSOLETE   current_thread = saved_thread;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE thread_kill_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int mid;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int thread_count;
// OBSOLETE   thread_array_t thread_table;
// OBSOLETE   int index;
// OBSOLETE   mach_port_t thread_to_kill = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     error_no_arg ("thread mid to kill from the inferior task");
// OBSOLETE 
// OBSOLETE   mid = parse_thread_id (args, 0, 0);
// OBSOLETE 
// OBSOLETE   if (mid < 0)
// OBSOLETE     error ("You can kill only existing kernel threads with MID or @@SLOTNUMBER");
// OBSOLETE 
// OBSOLETE   if (mid)
// OBSOLETE     {
// OBSOLETE       ret = machid_mach_port (mid_server, mid_auth, mid, &thread_to_kill);
// OBSOLETE       CHK ("thread_kill_command: machid_mach_port map failed", ret);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE   /* Don't allow gdb to kill *any* thread in the system. Use mkill program for that */
// OBSOLETE   ret = task_threads (inferior_task, &thread_table, &thread_count);
// OBSOLETE   CHK ("Error getting inferior's thread list", ret);
// OBSOLETE 
// OBSOLETE   if (thread_to_kill == current_thread)
// OBSOLETE     {
// OBSOLETE       ret = thread_terminate (thread_to_kill);
// OBSOLETE       CHK ("Thread could not be terminated", ret);
// OBSOLETE 
// OBSOLETE       if (select_thread (inferior_task, 0, 1) != KERN_SUCCESS)
// OBSOLETE 	warning ("Last thread was killed, use \"kill\" command to kill task");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     for (index = 0; index < thread_count; index++)
// OBSOLETE       if (thread_table[index] == thread_to_kill)
// OBSOLETE 	{
// OBSOLETE 	  ret = thread_terminate (thread_to_kill);
// OBSOLETE 	  CHK ("Thread could not be terminated", ret);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE   if (thread_count > 1)
// OBSOLETE     consume_send_rights (thread_table, thread_count);
// OBSOLETE 
// OBSOLETE   ret = vm_deallocate (mach_task_self (), (vm_address_t) thread_table,
// OBSOLETE 		       (thread_count * sizeof (mach_port_t)));
// OBSOLETE   CHK ("Error trying to deallocate thread list", ret);
// OBSOLETE 
// OBSOLETE   warning ("Thread %d killed", mid);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Task specific commands; add more if you like */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE task_resume_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   task_basic_info_data_t ta_info;
// OBSOLETE   int infoCnt = TASK_BASIC_INFO_COUNT;
// OBSOLETE   int mid = map_port_name_to_mid (inferior_task, MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   /* Would be trivial to change, but is it desirable? */
// OBSOLETE   if (args)
// OBSOLETE     error ("Currently gdb can resume only it's inferior task");
// OBSOLETE 
// OBSOLETE   ret = task_info (inferior_task,
// OBSOLETE 		   TASK_BASIC_INFO,
// OBSOLETE 		   (task_info_t) & ta_info,
// OBSOLETE 		   &infoCnt);
// OBSOLETE   CHK ("task_resume_command: task_info failed", ret);
// OBSOLETE 
// OBSOLETE   if (ta_info.suspend_count == 0)
// OBSOLETE     error ("Inferior task %d is not suspended", mid);
// OBSOLETE   else if (ta_info.suspend_count == 1 &&
// OBSOLETE 	   from_tty &&
// OBSOLETE 	!query ("Suspend count is now 1. Do you know what you are doing? "))
// OBSOLETE     error ("Task not resumed");
// OBSOLETE 
// OBSOLETE   ret = task_resume (inferior_task);
// OBSOLETE   CHK ("task_resume_command: task_resume", ret);
// OBSOLETE 
// OBSOLETE   if (ta_info.suspend_count == 1)
// OBSOLETE     {
// OBSOLETE       warning ("Inferior task %d is no longer suspended", mid);
// OBSOLETE       must_suspend_thread = 1;
// OBSOLETE       /* @@@@ This is not complete: Registers change all the time when not
// OBSOLETE          suspended! */
// OBSOLETE       registers_changed ();
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     warning ("Inferior task %d suspend count is now %d",
// OBSOLETE 	     mid, ta_info.suspend_count - 1);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE void
// OBSOLETE task_suspend_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   task_basic_info_data_t ta_info;
// OBSOLETE   int infoCnt = TASK_BASIC_INFO_COUNT;
// OBSOLETE   int mid = map_port_name_to_mid (inferior_task, MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   /* Would be trivial to change, but is it desirable? */
// OBSOLETE   if (args)
// OBSOLETE     error ("Currently gdb can suspend only it's inferior task");
// OBSOLETE 
// OBSOLETE   ret = task_suspend (inferior_task);
// OBSOLETE   CHK ("task_suspend_command: task_suspend", ret);
// OBSOLETE 
// OBSOLETE   must_suspend_thread = 0;
// OBSOLETE 
// OBSOLETE   ret = task_info (inferior_task,
// OBSOLETE 		   TASK_BASIC_INFO,
// OBSOLETE 		   (task_info_t) & ta_info,
// OBSOLETE 		   &infoCnt);
// OBSOLETE   CHK ("task_suspend_command: task_info failed", ret);
// OBSOLETE 
// OBSOLETE   warning ("Inferior task %d suspend count is now %d",
// OBSOLETE 	   mid, ta_info.suspend_count);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE get_size (int bytes)
// OBSOLETE {
// OBSOLETE   static char size[30];
// OBSOLETE   int zz = bytes / 1024;
// OBSOLETE 
// OBSOLETE   if (zz / 1024)
// OBSOLETE     sprintf (size, "%-2.1f M", ((float) bytes) / (1024.0 * 1024.0));
// OBSOLETE   else
// OBSOLETE     sprintf (size, "%d K", zz);
// OBSOLETE 
// OBSOLETE   return size;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Does this require the target task to be suspended?? I don't think so. */
// OBSOLETE void
// OBSOLETE task_info_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int mid = -5;
// OBSOLETE   mach_port_t task;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   task_basic_info_data_t ta_info;
// OBSOLETE   int infoCnt = TASK_BASIC_INFO_COUNT;
// OBSOLETE   int page_size = round_page (1);
// OBSOLETE   int thread_count = 0;
// OBSOLETE 
// OBSOLETE   if (MACH_PORT_VALID (inferior_task))
// OBSOLETE     mid = map_port_name_to_mid (inferior_task,
// OBSOLETE 				MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   task = inferior_task;
// OBSOLETE 
// OBSOLETE   if (args)
// OBSOLETE     {
// OBSOLETE       int tmid = atoi (args);
// OBSOLETE 
// OBSOLETE       if (tmid <= 0)
// OBSOLETE 	error ("Invalid mid %d for task info", tmid);
// OBSOLETE 
// OBSOLETE       if (tmid != mid)
// OBSOLETE 	{
// OBSOLETE 	  mid = tmid;
// OBSOLETE 	  ret = machid_mach_port (mid_server, mid_auth, tmid, &task);
// OBSOLETE 	  CHK ("task_info_command: machid_mach_port map failed", ret);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (mid < 0)
// OBSOLETE     error ("You have to give the task MID as an argument");
// OBSOLETE 
// OBSOLETE   ret = task_info (task,
// OBSOLETE 		   TASK_BASIC_INFO,
// OBSOLETE 		   (task_info_t) & ta_info,
// OBSOLETE 		   &infoCnt);
// OBSOLETE   CHK ("task_info_command: task_info failed", ret);
// OBSOLETE 
// OBSOLETE   printf_filtered ("\nTask info for task %d:\n\n", mid);
// OBSOLETE   printf_filtered (" Suspend count : %d\n", ta_info.suspend_count);
// OBSOLETE   printf_filtered (" Base priority : %d\n", ta_info.base_priority);
// OBSOLETE   printf_filtered (" Virtual size  : %s\n", get_size (ta_info.virtual_size));
// OBSOLETE   printf_filtered (" Resident size : %s\n", get_size (ta_info.resident_size));
// OBSOLETE 
// OBSOLETE   {
// OBSOLETE     thread_array_t thread_list;
// OBSOLETE 
// OBSOLETE     ret = task_threads (task, &thread_list, &thread_count);
// OBSOLETE     CHK ("task_info_command: task_threads", ret);
// OBSOLETE 
// OBSOLETE     printf_filtered (" Thread count  : %d\n", thread_count);
// OBSOLETE 
// OBSOLETE     consume_send_rights (thread_list, thread_count);
// OBSOLETE     ret = vm_deallocate (mach_task_self (),
// OBSOLETE 			 (vm_address_t) thread_list,
// OBSOLETE 			 (thread_count * sizeof (int)));
// OBSOLETE     CHK ("Error trying to deallocate thread list", ret);
// OBSOLETE   }
// OBSOLETE   if (have_emulator_p (task))
// OBSOLETE     printf_filtered (" Emulator at   : 0x%x..0x%x\n",
// OBSOLETE 		     EMULATOR_BASE, EMULATOR_END);
// OBSOLETE   else
// OBSOLETE     printf_filtered (" No emulator.\n");
// OBSOLETE 
// OBSOLETE   if (thread_count && task == inferior_task)
// OBSOLETE     printf_filtered ("\nUse the \"thread list\" command to see the threads\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* You may either FORWARD the exception to the inferior, or KEEP
// OBSOLETE  * it and return to GDB command level.
// OBSOLETE  *
// OBSOLETE  * exception mid [ forward | keep ]
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE exception_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   char *scan = args;
// OBSOLETE   int exception;
// OBSOLETE   int len;
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     error_no_arg ("exception number action");
// OBSOLETE 
// OBSOLETE   while (*scan == ' ' || *scan == '\t')
// OBSOLETE     scan++;
// OBSOLETE 
// OBSOLETE   if ('0' <= *scan && *scan <= '9')
// OBSOLETE     while ('0' <= *scan && *scan <= '9')
// OBSOLETE       scan++;
// OBSOLETE   else
// OBSOLETE     error ("exception number action");
// OBSOLETE 
// OBSOLETE   exception = atoi (args);
// OBSOLETE   if (exception <= 0 || exception > MAX_EXCEPTION)
// OBSOLETE     error ("Allowed exception numbers are in range 1..%d",
// OBSOLETE 	   MAX_EXCEPTION);
// OBSOLETE 
// OBSOLETE   if (*scan != ' ' && *scan != '\t')
// OBSOLETE     error ("exception number must be followed by a space");
// OBSOLETE   else
// OBSOLETE     while (*scan == ' ' || *scan == '\t')
// OBSOLETE       scan++;
// OBSOLETE 
// OBSOLETE   args = scan;
// OBSOLETE   len = 0;
// OBSOLETE   while (*scan)
// OBSOLETE     {
// OBSOLETE       len++;
// OBSOLETE       scan++;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!len)
// OBSOLETE     error ("exception number action");
// OBSOLETE 
// OBSOLETE   if (!strncasecmp (args, "forward", len))
// OBSOLETE     exception_map[exception].forward = TRUE;
// OBSOLETE   else if (!strncasecmp (args, "keep", len))
// OBSOLETE     exception_map[exception].forward = FALSE;
// OBSOLETE   else
// OBSOLETE     error ("exception action is either \"keep\" or \"forward\"");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE print_exception_info (int exception)
// OBSOLETE {
// OBSOLETE   boolean_t forward = exception_map[exception].forward;
// OBSOLETE 
// OBSOLETE   printf_filtered ("%s\t(%d): ", exception_map[exception].name,
// OBSOLETE 		   exception);
// OBSOLETE   if (!forward)
// OBSOLETE     if (exception_map[exception].sigmap != SIG_UNKNOWN)
// OBSOLETE       printf_filtered ("keep and handle as signal %d\n",
// OBSOLETE 		       exception_map[exception].sigmap);
// OBSOLETE     else
// OBSOLETE       printf_filtered ("keep and handle as unknown signal %d\n",
// OBSOLETE 		       exception_map[exception].sigmap);
// OBSOLETE   else
// OBSOLETE     printf_filtered ("forward exception to inferior\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE exception_info (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int exception;
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     for (exception = 1; exception <= MAX_EXCEPTION; exception++)
// OBSOLETE       print_exception_info (exception);
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       exception = atoi (args);
// OBSOLETE 
// OBSOLETE       if (exception <= 0 || exception > MAX_EXCEPTION)
// OBSOLETE 	error ("Invalid exception number, values from 1 to %d allowed",
// OBSOLETE 	       MAX_EXCEPTION);
// OBSOLETE       print_exception_info (exception);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Check for actions for mach exceptions.
// OBSOLETE  */
// OBSOLETE mach3_exception_actions (WAITTYPE *w, boolean_t force_print_only, char *who)
// OBSOLETE {
// OBSOLETE   boolean_t force_print = FALSE;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   if (force_print_only ||
// OBSOLETE       exception_map[stop_exception].sigmap == SIG_UNKNOWN)
// OBSOLETE     force_print = TRUE;
// OBSOLETE   else
// OBSOLETE     WSETSTOP (*w, exception_map[stop_exception].sigmap);
// OBSOLETE 
// OBSOLETE   if (exception_map[stop_exception].print || force_print)
// OBSOLETE     {
// OBSOLETE       target_terminal_ours ();
// OBSOLETE 
// OBSOLETE       printf_filtered ("\n%s received %s exception : ",
// OBSOLETE 		       who,
// OBSOLETE 		       exception_map[stop_exception].name);
// OBSOLETE 
// OBSOLETE       wrap_here ("   ");
// OBSOLETE 
// OBSOLETE       switch (stop_exception)
// OBSOLETE 	{
// OBSOLETE 	case EXC_BAD_ACCESS:
// OBSOLETE 	  printf_filtered ("referencing address 0x%x : %s\n",
// OBSOLETE 			   stop_subcode,
// OBSOLETE 			   mach_error_string (stop_code));
// OBSOLETE 	  break;
// OBSOLETE 	case EXC_BAD_INSTRUCTION:
// OBSOLETE 	  printf_filtered
// OBSOLETE 	    ("illegal or undefined instruction. code %d subcode %d\n",
// OBSOLETE 	     stop_code, stop_subcode);
// OBSOLETE 	  break;
// OBSOLETE 	case EXC_ARITHMETIC:
// OBSOLETE 	  printf_filtered ("code %d\n", stop_code);
// OBSOLETE 	  break;
// OBSOLETE 	case EXC_EMULATION:
// OBSOLETE 	  printf_filtered ("code %d subcode %d\n", stop_code, stop_subcode);
// OBSOLETE 	  break;
// OBSOLETE 	case EXC_SOFTWARE:
// OBSOLETE 	  printf_filtered ("%s specific, code 0x%x\n",
// OBSOLETE 			   stop_code < 0xffff ? "hardware" : "os emulation",
// OBSOLETE 			   stop_code);
// OBSOLETE 	  break;
// OBSOLETE 	case EXC_BREAKPOINT:
// OBSOLETE 	  printf_filtered ("type %d (machine dependent)\n",
// OBSOLETE 			   stop_code);
// OBSOLETE 	  break;
// OBSOLETE 	default:
// OBSOLETE 	  internal_error (__FILE__, __LINE__,
// OBSOLETE 			  "Unknown exception");
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE setup_notify_port (int create_new)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (MACH_PORT_VALID (our_notify_port))
// OBSOLETE     {
// OBSOLETE       ret = mach_port_destroy (mach_task_self (), our_notify_port);
// OBSOLETE       CHK ("Could not destroy our_notify_port", ret);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   our_notify_port = MACH_PORT_NULL;
// OBSOLETE   notify_chain = (port_chain_t) NULL;
// OBSOLETE   port_chain_destroy (port_chain_obstack);
// OBSOLETE 
// OBSOLETE   if (create_new)
// OBSOLETE     {
// OBSOLETE       ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 				MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 				&our_notify_port);
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	internal_error (__FILE__, __LINE__,
// OBSOLETE 			"Creating notify port %s", mach_error_string (ret));
// OBSOLETE 
// OBSOLETE       ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 				   our_notify_port,
// OBSOLETE 				   inferior_wait_port_set);
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	internal_error (__FILE__, __LINE__,
// OBSOLETE 			"initial move member %s", mach_error_string (ret));
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Register our message port to the net name server
// OBSOLETE  *
// OBSOLETE  * Currently used only by the external stop-gdb program
// OBSOLETE  * since ^C does not work if you would like to enter
// OBSOLETE  * gdb command level while debugging your program.
// OBSOLETE  *
// OBSOLETE  * NOTE: If the message port is sometimes used for other
// OBSOLETE  * purposes also, the NAME must not be a guessable one.
// OBSOLETE  * Then, there should be a way to change it.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE char registered_name[MAX_NAME_LEN];
// OBSOLETE 
// OBSOLETE void
// OBSOLETE message_port_info (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   if (registered_name[0])
// OBSOLETE     printf_filtered ("gdb's message port name: '%s'\n",
// OBSOLETE 		     registered_name);
// OBSOLETE   else
// OBSOLETE     printf_filtered ("gdb's message port is not currently registered\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE gdb_register_port (char *name, mach_port_t port)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   static int already_signed = 0;
// OBSOLETE   int len;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (port) || !name || !*name)
// OBSOLETE     {
// OBSOLETE       warning ("Invalid registration request");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!already_signed)
// OBSOLETE     {
// OBSOLETE       ret = mach_port_insert_right (mach_task_self (),
// OBSOLETE 				    our_message_port,
// OBSOLETE 				    our_message_port,
// OBSOLETE 				    MACH_MSG_TYPE_MAKE_SEND);
// OBSOLETE       CHK ("Failed to create a signature to our_message_port", ret);
// OBSOLETE       already_signed = 1;
// OBSOLETE     }
// OBSOLETE   else if (already_signed > 1)
// OBSOLETE     {
// OBSOLETE       ret = netname_check_out (name_server_port,
// OBSOLETE 			       registered_name,
// OBSOLETE 			       our_message_port);
// OBSOLETE       CHK ("Failed to check out gdb's message port", ret);
// OBSOLETE       registered_name[0] = '\000';
// OBSOLETE       already_signed = 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = netname_check_in (name_server_port,	/* Name server port */
// OBSOLETE 			  name,	/* Name of service */
// OBSOLETE 			  our_message_port,	/* Signature */
// OBSOLETE 			  port);	/* Creates a new send right */
// OBSOLETE   CHK ("Failed to check in the port", ret);
// OBSOLETE 
// OBSOLETE   len = 0;
// OBSOLETE   while (len < MAX_NAME_LEN && *(name + len))
// OBSOLETE     {
// OBSOLETE       registered_name[len] = *(name + len);
// OBSOLETE       len++;
// OBSOLETE     }
// OBSOLETE   registered_name[len] = '\000';
// OBSOLETE   already_signed = 2;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE struct cmd_list_element *cmd_thread_list;
// OBSOLETE struct cmd_list_element *cmd_task_list;
// OBSOLETE 
// OBSOLETE /*ARGSUSED */
// OBSOLETE static void
// OBSOLETE thread_command (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   printf_unfiltered ("\"thread\" must be followed by the name of a thread command.\n");
// OBSOLETE   help_list (cmd_thread_list, "thread ", -1, gdb_stdout);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*ARGSUSED */
// OBSOLETE static void
// OBSOLETE task_command (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   printf_unfiltered ("\"task\" must be followed by the name of a task command.\n");
// OBSOLETE   help_list (cmd_task_list, "task ", -1, gdb_stdout);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE add_mach_specific_commands (void)
// OBSOLETE {
// OBSOLETE   /* Thread handling commands */
// OBSOLETE 
// OBSOLETE   /* FIXME: Move our thread support into the generic thread.c stuff so we
// OBSOLETE      can share that code.  */
// OBSOLETE   add_prefix_cmd ("mthread", class_stack, thread_command,
// OBSOLETE 	  "Generic command for handling Mach threads in the debugged task.",
// OBSOLETE 		  &cmd_thread_list, "thread ", 0, &cmdlist);
// OBSOLETE 
// OBSOLETE   add_com_alias ("th", "mthread", class_stack, 1);
// OBSOLETE 
// OBSOLETE   add_cmd ("select", class_stack, thread_select_command,
// OBSOLETE 	   "Select and print MID of the selected thread",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE   add_cmd ("list", class_stack, thread_list_command,
// OBSOLETE 	   "List info of task's threads. Selected thread is marked with '*'",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE   add_cmd ("suspend", class_run, thread_suspend_command,
// OBSOLETE 	   "Suspend one or all of the threads in the selected task.",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE   add_cmd ("resume", class_run, thread_resume_command,
// OBSOLETE 	   "Resume one or all of the threads in the selected task.",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE   add_cmd ("kill", class_run, thread_kill_command,
// OBSOLETE 	   "Kill the specified thread MID from inferior task.",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE #if 0
// OBSOLETE   /* The rest of this support (condition_thread) was not merged.  It probably
// OBSOLETE      should not be merged in this form, but instead added to the generic GDB
// OBSOLETE      thread support.  */
// OBSOLETE   add_cmd ("break", class_breakpoint, condition_thread,
// OBSOLETE 	   "Breakpoint N will only be effective for thread MID or @@SLOT\n\
// OBSOLETE 	    If MID/@@SLOT is omitted allow all threads to break at breakpoint",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE #endif
// OBSOLETE   /* Thread command shorthands (for backward compatibility) */
// OBSOLETE   add_alias_cmd ("ts", "mthread select", 0, 0, &cmdlist);
// OBSOLETE   add_alias_cmd ("tl", "mthread list", 0, 0, &cmdlist);
// OBSOLETE 
// OBSOLETE   /* task handling commands */
// OBSOLETE 
// OBSOLETE   add_prefix_cmd ("task", class_stack, task_command,
// OBSOLETE 		  "Generic command for handling debugged task.",
// OBSOLETE 		  &cmd_task_list, "task ", 0, &cmdlist);
// OBSOLETE 
// OBSOLETE   add_com_alias ("ta", "task", class_stack, 1);
// OBSOLETE 
// OBSOLETE   add_cmd ("suspend", class_run, task_suspend_command,
// OBSOLETE 	   "Suspend the inferior task.",
// OBSOLETE 	   &cmd_task_list);
// OBSOLETE   add_cmd ("resume", class_run, task_resume_command,
// OBSOLETE 	   "Resume the inferior task.",
// OBSOLETE 	   &cmd_task_list);
// OBSOLETE   add_cmd ("info", no_class, task_info_command,
// OBSOLETE 	   "Print information about the specified task.",
// OBSOLETE 	   &cmd_task_list);
// OBSOLETE 
// OBSOLETE   /* Print my message port name */
// OBSOLETE 
// OBSOLETE   add_info ("message-port", message_port_info,
// OBSOLETE 	    "Returns the name of gdb's message port in the netnameserver");
// OBSOLETE 
// OBSOLETE   /* Exception commands */
// OBSOLETE 
// OBSOLETE   add_info ("exceptions", exception_info,
// OBSOLETE 	    "What debugger does when program gets various exceptions.\n\
// OBSOLETE Specify an exception number as argument to print info on that\n\
// OBSOLETE exception only.");
// OBSOLETE 
// OBSOLETE   add_com ("exception", class_run, exception_command,
// OBSOLETE 	   "Specify how to handle an exception.\n\
// OBSOLETE Args are exception number followed by \"forward\" or \"keep\".\n\
// OBSOLETE `Forward' means forward the exception to the program's normal exception\n\
// OBSOLETE handler.\n\
// OBSOLETE `Keep' means reenter debugger if this exception happens, and GDB maps\n\
// OBSOLETE the exception to some signal (see info exception)\n\
// OBSOLETE Normally \"keep\" is used to return to GDB on exception.");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_dead_name (mach_port_t notify, mach_port_t name)
// OBSOLETE {
// OBSOLETE   kern_return_t kr = KERN_SUCCESS;
// OBSOLETE 
// OBSOLETE   /* Find the thing that notified */
// OBSOLETE   port_chain_t element = port_chain_member (notify_chain, name);
// OBSOLETE 
// OBSOLETE   /* Take name of from unreceived dead name notification list */
// OBSOLETE   notify_chain = port_chain_delete (notify_chain, name);
// OBSOLETE 
// OBSOLETE   if (!element)
// OBSOLETE     error ("Received a dead name notify from unchained port (0x%x)", name);
// OBSOLETE 
// OBSOLETE   switch (element->type)
// OBSOLETE     {
// OBSOLETE 
// OBSOLETE     case MACH_TYPE_THREAD:
// OBSOLETE       target_terminal_ours_for_output ();
// OBSOLETE       if (name == current_thread)
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered ("\nCurrent thread %d died", element->mid);
// OBSOLETE 	  current_thread = MACH_PORT_NULL;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	printf_filtered ("\nThread %d died", element->mid);
// OBSOLETE 
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case MACH_TYPE_TASK:
// OBSOLETE       target_terminal_ours_for_output ();
// OBSOLETE       if (name != inferior_task)
// OBSOLETE 	printf_filtered ("Task %d died, but it was not the selected task",
// OBSOLETE 			 element->mid);
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered ("Current task %d died", element->mid);
// OBSOLETE 
// OBSOLETE 	  mach_port_destroy (mach_task_self (), name);
// OBSOLETE 	  inferior_task = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE 	  if (notify_chain)
// OBSOLETE 	    warning ("There were still unreceived dead_name_notifications???");
// OBSOLETE 
// OBSOLETE 	  /* Destroy the old notifications */
// OBSOLETE 	  setup_notify_port (0);
// OBSOLETE 
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     default:
// OBSOLETE       error ("Unregistered dead_name 0x%x notification received. Type is %d, mid is 0x%x",
// OBSOLETE 	     name, element->type, element->mid);
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_msg_accepted (mach_port_t notify, mach_port_t name)
// OBSOLETE {
// OBSOLETE   warning ("do_mach_notify_msg_accepted : notify %x, name %x",
// OBSOLETE 	   notify, name);
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_no_senders (mach_port_t notify, mach_port_mscount_t mscount)
// OBSOLETE {
// OBSOLETE   warning ("do_mach_notify_no_senders : notify %x, mscount %x",
// OBSOLETE 	   notify, mscount);
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_port_deleted (mach_port_t notify, mach_port_t name)
// OBSOLETE {
// OBSOLETE   warning ("do_mach_notify_port_deleted : notify %x, name %x",
// OBSOLETE 	   notify, name);
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_port_destroyed (mach_port_t notify, mach_port_t rights)
// OBSOLETE {
// OBSOLETE   warning ("do_mach_notify_port_destroyed : notify %x, rights %x",
// OBSOLETE 	   notify, rights);
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_send_once (mach_port_t notify)
// OBSOLETE {
// OBSOLETE #ifdef DUMP_SYSCALL
// OBSOLETE   /* MANY of these are generated. */
// OBSOLETE   warning ("do_mach_notify_send_once : notify %x",
// OBSOLETE 	   notify);
// OBSOLETE #endif
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Kills the inferior. It's gone when you call this */
// OBSOLETE static void
// OBSOLETE kill_inferior_fast (void)
// OBSOLETE {
// OBSOLETE   WAITTYPE w;
// OBSOLETE 
// OBSOLETE   if (PIDGET (inferior_ptid) == 0 || PIDGET (inferior_ptid) == 1)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   /* kill() it, since the Unix server does not otherwise notice when
// OBSOLETE    * killed with task_terminate().
// OBSOLETE    */
// OBSOLETE   if (PIDGET (inferior_ptid) > 0)
// OBSOLETE     kill (PIDGET (inferior_ptid), SIGKILL);
// OBSOLETE 
// OBSOLETE   /* It's propably terminate already */
// OBSOLETE   (void) task_terminate (inferior_task);
// OBSOLETE 
// OBSOLETE   inferior_task = MACH_PORT_NULL;
// OBSOLETE   current_thread = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE   wait3 (&w, WNOHANG, 0);
// OBSOLETE 
// OBSOLETE   setup_notify_port (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_kill_inferior (void)
// OBSOLETE {
// OBSOLETE   kill_inferior_fast ();
// OBSOLETE   target_mourn_inferior ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Clean up after the inferior dies.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_mourn_inferior (void)
// OBSOLETE {
// OBSOLETE   unpush_target (&m3_ops);
// OBSOLETE   generic_mourn_inferior ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Fork an inferior process, and start debugging it.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_create_inferior (char *exec_file, char *allargs, char **env)
// OBSOLETE {
// OBSOLETE   fork_inferior (exec_file, allargs, env, m3_trace_me, m3_trace_him, NULL, NULL);
// OBSOLETE   /* We are at the first instruction we care about.  */
// OBSOLETE   /* Pedal to the metal... */
// OBSOLETE   proceed ((CORE_ADDR) -1, 0, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Mark our target-struct as eligible for stray "run" and "attach"
// OBSOLETE    commands.  */
// OBSOLETE static int
// OBSOLETE m3_can_run (void)
// OBSOLETE {
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Mach 3.0 does not need ptrace for anything
// OBSOLETE  * Make sure nobody uses it on mach.
// OBSOLETE  */
// OBSOLETE ptrace (int a, int b, int c, int d)
// OBSOLETE {
// OBSOLETE   error ("Lose, Lose! Somebody called ptrace\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Resume execution of the inferior process.
// OBSOLETE    If STEP is nonzero, single-step it.
// OBSOLETE    If SIGNAL is nonzero, give it that signal.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m3_resume (ptid_t ptid, int step, enum target_signal signal)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (step)
// OBSOLETE     {
// OBSOLETE       thread_basic_info_data_t th_info;
// OBSOLETE       unsigned int infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE 
// OBSOLETE       /* There is no point in single stepping when current_thread
// OBSOLETE        * is dead.
// OBSOLETE        */
// OBSOLETE       if (!MACH_PORT_VALID (current_thread))
// OBSOLETE 	error ("No thread selected; can not single step");
// OBSOLETE 
// OBSOLETE       /* If current_thread is suspended, tracing it would never return.
// OBSOLETE        */
// OBSOLETE       ret = thread_info (current_thread,
// OBSOLETE 			 THREAD_BASIC_INFO,
// OBSOLETE 			 (thread_info_t) & th_info,
// OBSOLETE 			 &infoCnt);
// OBSOLETE       CHK ("child_resume: can't get thread info", ret);
// OBSOLETE 
// OBSOLETE       if (th_info.suspend_count)
// OBSOLETE 	error ("Can't trace a suspended thread. Use \"thread resume\" command to resume it");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   vm_read_cache_valid = FALSE;
// OBSOLETE 
// OBSOLETE   if (signal && PIDGET (inferior_ptid) > 0)	/* Do not signal, if attached by MID */
// OBSOLETE     kill (PIDGET (inferior_ptid), target_signal_to_host (signal));
// OBSOLETE 
// OBSOLETE   if (step)
// OBSOLETE     {
// OBSOLETE       suspend_all_threads (0);
// OBSOLETE 
// OBSOLETE       setup_single_step (current_thread, TRUE);
// OBSOLETE 
// OBSOLETE       ret = thread_resume (current_thread);
// OBSOLETE       CHK ("thread_resume", ret);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = task_resume (inferior_task);
// OBSOLETE   if (ret == KERN_FAILURE)
// OBSOLETE     warning ("Task was not suspended");
// OBSOLETE   else
// OBSOLETE     CHK ("Resuming task", ret);
// OBSOLETE 
// OBSOLETE   /* HACK HACK This is needed by the multiserver system HACK HACK */
// OBSOLETE   while ((ret = task_resume (inferior_task)) == KERN_SUCCESS)
// OBSOLETE     /* make sure it really runs */ ;
// OBSOLETE   /* HACK HACK This is needed by the multiserver system HACK HACK */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef ATTACH_DETACH
// OBSOLETE 
// OBSOLETE /* Start debugging the process with the given task */
// OBSOLETE void
// OBSOLETE task_attach (task_t tid)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   inferior_task = tid;
// OBSOLETE 
// OBSOLETE   ret = task_suspend (inferior_task);
// OBSOLETE   CHK ("task_attach: task_suspend", ret);
// OBSOLETE 
// OBSOLETE   must_suspend_thread = 0;
// OBSOLETE 
// OBSOLETE   setup_notify_port (1);
// OBSOLETE 
// OBSOLETE   request_notify (inferior_task, MACH_NOTIFY_DEAD_NAME, MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   setup_exception_port ();
// OBSOLETE 
// OBSOLETE   emulator_present = have_emulator_p (inferior_task);
// OBSOLETE 
// OBSOLETE   attach_flag = 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Well, we can call error also here and leave the
// OBSOLETE  * target stack inconsistent. Sigh.
// OBSOLETE  * Fix this sometime (the only way to fail here is that
// OBSOLETE  * the task has no threads at all, which is rare, but
// OBSOLETE  * possible; or if the target task has died, which is also
// OBSOLETE  * possible, but unlikely, since it has been suspended.
// OBSOLETE  * (Someone must have killed it))
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE attach_to_thread (void)
// OBSOLETE {
// OBSOLETE   if (select_thread (inferior_task, 0, 1) != KERN_SUCCESS)
// OBSOLETE     error ("Could not select any threads to attach to");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE mid_attach (int mid)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   ret = machid_mach_port (mid_server, mid_auth, mid, &inferior_task);
// OBSOLETE   CHK ("mid_attach: machid_mach_port", ret);
// OBSOLETE 
// OBSOLETE   task_attach (inferior_task);
// OBSOLETE 
// OBSOLETE   return mid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* 
// OBSOLETE  * Start debugging the process whose unix process-id is PID.
// OBSOLETE  * A negative "pid" value is legal and signifies a mach_id not a unix pid.
// OBSOLETE  *
// OBSOLETE  * Prevent (possible unwanted) dangerous operations by enabled users
// OBSOLETE  * like "atta 0" or "atta foo" (equal to the previous :-) and
// OBSOLETE  * "atta pidself". Anyway, the latter is allowed by specifying a MID.
// OBSOLETE  */
// OBSOLETE static int
// OBSOLETE m3_do_attach (int pid)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (pid == 0)
// OBSOLETE     error ("MID=0, Debugging the master unix server does not compute");
// OBSOLETE 
// OBSOLETE   /* Foo. This assumes gdb has a unix pid */
// OBSOLETE   if (pid == getpid ())
// OBSOLETE     error ("I will debug myself only by mid. (Gdb would suspend itself!)");
// OBSOLETE 
// OBSOLETE   if (pid < 0)
// OBSOLETE     {
// OBSOLETE       mid_attach (-(pid));
// OBSOLETE 
// OBSOLETE       /* inferior_ptid will be NEGATIVE! */
// OBSOLETE       inferior_ptid = pid_to_ptid (pid);
// OBSOLETE 
// OBSOLETE       return PIDGET (inferior_ptid);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   inferior_task = task_by_pid (pid);
// OBSOLETE   if (!MACH_PORT_VALID (inferior_task))
// OBSOLETE     error ("Cannot map Unix pid %d to Mach task port", pid);
// OBSOLETE 
// OBSOLETE   task_attach (inferior_task);
// OBSOLETE 
// OBSOLETE   inferior_ptid = pid_to_ptid (pid);
// OBSOLETE 
// OBSOLETE   return PIDGET (inferior_ptid);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Attach to process PID, then initialize for debugging it
// OBSOLETE    and wait for the trace-trap that results from attaching.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_attach (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   char *exec_file;
// OBSOLETE   int pid;
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     error_no_arg ("process-id to attach");
// OBSOLETE 
// OBSOLETE   pid = atoi (args);
// OBSOLETE 
// OBSOLETE   if (pid == getpid ())		/* Trying to masturbate? */
// OBSOLETE     error ("I refuse to debug myself!");
// OBSOLETE 
// OBSOLETE   if (from_tty)
// OBSOLETE     {
// OBSOLETE       exec_file = (char *) get_exec_file (0);
// OBSOLETE 
// OBSOLETE       if (exec_file)
// OBSOLETE 	printf_unfiltered ("Attaching to program `%s', %s\n", exec_file,
// OBSOLETE 	                   target_pid_to_str (pid_to_ptid (pid)));
// OBSOLETE       else
// OBSOLETE 	printf_unfiltered ("Attaching to %s\n",
// OBSOLETE 	                   target_pid_to_str (pid_to_ptid (pid)));
// OBSOLETE 
// OBSOLETE       gdb_flush (gdb_stdout);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   m3_do_attach (pid_to_ptid (pid));
// OBSOLETE   inferior_ptid = pid_to_ptid (pid);
// OBSOLETE   push_target (&m3_ops);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE deallocate_inferior_ports (void)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_array_t thread_list;
// OBSOLETE   int thread_count, index;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (inferior_task))
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   ret = task_threads (inferior_task, &thread_list, &thread_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("deallocate_inferior_ports: task_threads",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Get rid of send rights to task threads */
// OBSOLETE   for (index = 0; index < thread_count; index++)
// OBSOLETE     {
// OBSOLETE       int rights;
// OBSOLETE       ret = mach_port_get_refs (mach_task_self (),
// OBSOLETE 				thread_list[index],
// OBSOLETE 				MACH_PORT_RIGHT_SEND,
// OBSOLETE 				&rights);
// OBSOLETE       CHK ("deallocate_inferior_ports: get refs", ret);
// OBSOLETE 
// OBSOLETE       if (rights > 0)
// OBSOLETE 	{
// OBSOLETE 	  ret = mach_port_mod_refs (mach_task_self (),
// OBSOLETE 				    thread_list[index],
// OBSOLETE 				    MACH_PORT_RIGHT_SEND,
// OBSOLETE 				    -rights);
// OBSOLETE 	  CHK ("deallocate_inferior_ports: mod refs", ret);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = mach_port_mod_refs (mach_task_self (),
// OBSOLETE 			    inferior_exception_port,
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    -1);
// OBSOLETE   CHK ("deallocate_inferior_ports: cannot get rid of exception port", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_deallocate (mach_task_self (),
// OBSOLETE 			      inferior_task);
// OBSOLETE   CHK ("deallocate_task_port: deallocating inferior_task", ret);
// OBSOLETE 
// OBSOLETE   current_thread = MACH_PORT_NULL;
// OBSOLETE   inferior_task = MACH_PORT_NULL;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Stop debugging the process whose number is PID
// OBSOLETE    and continue it with signal number SIGNAL.
// OBSOLETE    SIGNAL = 0 means just continue it.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_do_detach (int signal)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   if (current_thread != MACH_PORT_NULL)
// OBSOLETE     {
// OBSOLETE       /* Store the gdb's view of the thread we are deselecting
// OBSOLETE        * before we detach.
// OBSOLETE        * @@@@ I am really not sure if this is ever needeed.
// OBSOLETE        */
// OBSOLETE       target_prepare_to_store ();
// OBSOLETE       target_store_registers (-1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = task_set_special_port (inferior_task,
// OBSOLETE 			       TASK_EXCEPTION_PORT,
// OBSOLETE 			       inferior_old_exception_port);
// OBSOLETE   CHK ("task_set_special_port", ret);
// OBSOLETE 
// OBSOLETE   /* Discard all requested notifications */
// OBSOLETE   setup_notify_port (0);
// OBSOLETE 
// OBSOLETE   if (remove_breakpoints ())
// OBSOLETE     warning ("Could not remove breakpoints when detaching");
// OBSOLETE 
// OBSOLETE   if (signal && PIDGET (inferior_ptid) > 0)
// OBSOLETE     kill (PIDGET (inferior_ptid), signal);
// OBSOLETE 
// OBSOLETE   /* the task might be dead by now */
// OBSOLETE   (void) task_resume (inferior_task);
// OBSOLETE 
// OBSOLETE   deallocate_inferior_ports ();
// OBSOLETE 
// OBSOLETE   attach_flag = 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Take a program previously attached to and detaches it.
// OBSOLETE    The program resumes execution and will no longer stop
// OBSOLETE    on signals, etc.  We'd better not have left any breakpoints
// OBSOLETE    in the program or it'll die when it hits one.  For this
// OBSOLETE    to work, it may be necessary for the process to have been
// OBSOLETE    previously attached.  It *might* work if the program was
// OBSOLETE    started via fork.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_detach (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int siggnal = 0;
// OBSOLETE 
// OBSOLETE   if (from_tty)
// OBSOLETE     {
// OBSOLETE       char *exec_file = get_exec_file (0);
// OBSOLETE       if (exec_file == 0)
// OBSOLETE 	exec_file = "";
// OBSOLETE       printf_unfiltered ("Detaching from program: %s %s\n",
// OBSOLETE 			 exec_file, target_pid_to_str (inferior_ptid));
// OBSOLETE       gdb_flush (gdb_stdout);
// OBSOLETE     }
// OBSOLETE   if (args)
// OBSOLETE     siggnal = atoi (args);
// OBSOLETE 
// OBSOLETE   m3_do_detach (siggnal);
// OBSOLETE   inferior_ptid = null_ptid;
// OBSOLETE   unpush_target (&m3_ops);	/* Pop out of handling an inferior */
// OBSOLETE }
// OBSOLETE #endif /* ATTACH_DETACH */
// OBSOLETE 
// OBSOLETE /* Get ready to modify the registers array.  On machines which store
// OBSOLETE    individual registers, this doesn't need to do anything.  On machines
// OBSOLETE    which store all the registers in one fell swoop, this makes sure
// OBSOLETE    that registers contains all the registers from the program being
// OBSOLETE    debugged.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_prepare_to_store (void)
// OBSOLETE {
// OBSOLETE #ifdef CHILD_PREPARE_TO_STORE
// OBSOLETE   CHILD_PREPARE_TO_STORE ();
// OBSOLETE #endif
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Print status information about what we're accessing.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_files_info (struct target_ops *ignore)
// OBSOLETE {
// OBSOLETE   /* FIXME: should print MID and all that crap.  */
// OBSOLETE   printf_unfiltered ("\tUsing the running image of %s %s.\n",
// OBSOLETE       attach_flag ? "attached" : "child", target_pid_to_str (inferior_ptid));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_open (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   error ("Use the \"run\" command to start a Unix child process.");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef DUMP_SYSCALL
// OBSOLETE #define STR(x) #x
// OBSOLETE 
// OBSOLETE char *bsd1_names[] =
// OBSOLETE {
// OBSOLETE   "execve",
// OBSOLETE   "fork",
// OBSOLETE   "take_signal",
// OBSOLETE   "sigreturn",
// OBSOLETE   "getrusage",
// OBSOLETE   "chdir",
// OBSOLETE   "chroot",
// OBSOLETE   "open",
// OBSOLETE   "creat",
// OBSOLETE   "mknod",
// OBSOLETE   "link",
// OBSOLETE   "symlink",
// OBSOLETE   "unlink",
// OBSOLETE   "access",
// OBSOLETE   "stat",
// OBSOLETE   "readlink",
// OBSOLETE   "chmod",
// OBSOLETE   "chown",
// OBSOLETE   "utimes",
// OBSOLETE   "truncate",
// OBSOLETE   "rename",
// OBSOLETE   "mkdir",
// OBSOLETE   "rmdir",
// OBSOLETE   "xutimes",
// OBSOLETE   "mount",
// OBSOLETE   "umount",
// OBSOLETE   "acct",
// OBSOLETE   "setquota",
// OBSOLETE   "write_short",
// OBSOLETE   "write_long",
// OBSOLETE   "send_short",
// OBSOLETE   "send_long",
// OBSOLETE   "sendto_short",
// OBSOLETE   "sendto_long",
// OBSOLETE   "select",
// OBSOLETE   "task_by_pid",
// OBSOLETE   "recvfrom_short",
// OBSOLETE   "recvfrom_long",
// OBSOLETE   "setgroups",
// OBSOLETE   "setrlimit",
// OBSOLETE   "sigvec",
// OBSOLETE   "sigstack",
// OBSOLETE   "settimeofday",
// OBSOLETE   "adjtime",
// OBSOLETE   "setitimer",
// OBSOLETE   "sethostname",
// OBSOLETE   "bind",
// OBSOLETE   "accept",
// OBSOLETE   "connect",
// OBSOLETE   "setsockopt",
// OBSOLETE   "getsockopt",
// OBSOLETE   "getsockname",
// OBSOLETE   "getpeername",
// OBSOLETE   "init_process",
// OBSOLETE   "table_set",
// OBSOLETE   "table_get",
// OBSOLETE   "pioctl",
// OBSOLETE   "emulator_error",
// OBSOLETE   "readwrite",
// OBSOLETE   "share_wakeup",
// OBSOLETE   0,
// OBSOLETE   "maprw_request_it",
// OBSOLETE   "maprw_release_it",
// OBSOLETE   "maprw_remap",
// OBSOLETE   "pid_by_task",
// OBSOLETE };
// OBSOLETE 
// OBSOLETE int bsd1_nnames = sizeof (bsd1_names) / sizeof (bsd1_names[0]);
// OBSOLETE 
// OBSOLETE char *
// OBSOLETE name_str (int name, char *buf)
// OBSOLETE {
// OBSOLETE   switch (name)
// OBSOLETE     {
// OBSOLETE     case MACH_MSG_TYPE_BOOLEAN:
// OBSOLETE       return "boolean";
// OBSOLETE     case MACH_MSG_TYPE_INTEGER_16:
// OBSOLETE       return "short";
// OBSOLETE     case MACH_MSG_TYPE_INTEGER_32:
// OBSOLETE       return "long";
// OBSOLETE     case MACH_MSG_TYPE_CHAR:
// OBSOLETE       return "char";
// OBSOLETE     case MACH_MSG_TYPE_BYTE:
// OBSOLETE       return "byte";
// OBSOLETE     case MACH_MSG_TYPE_REAL:
// OBSOLETE       return "real";
// OBSOLETE     case MACH_MSG_TYPE_STRING:
// OBSOLETE       return "string";
// OBSOLETE     default:
// OBSOLETE       sprintf (buf, "%d", name);
// OBSOLETE       return buf;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE char *
// OBSOLETE id_str (int id, char *buf)
// OBSOLETE {
// OBSOLETE   char *p;
// OBSOLETE   if (id >= 101000 && id < 101000 + bsd1_nnames)
// OBSOLETE     {
// OBSOLETE       if (p = bsd1_names[id - 101000])
// OBSOLETE 	return p;
// OBSOLETE     }
// OBSOLETE   if (id == 102000)
// OBSOLETE     return "psignal_retry";
// OBSOLETE   if (id == 100000)
// OBSOLETE     return "syscall";
// OBSOLETE   sprintf (buf, "%d", id);
// OBSOLETE   return buf;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE print_msg (mach_msg_header_t *mp)
// OBSOLETE {
// OBSOLETE   char *fmt_x = "%20s : 0x%08x\n";
// OBSOLETE   char *fmt_d = "%20s : %10d\n";
// OBSOLETE   char *fmt_s = "%20s : %s\n";
// OBSOLETE   char buf[100];
// OBSOLETE 
// OBSOLETE   puts_filtered ("\n");
// OBSOLETE #define pr(fmt,h,x) printf_filtered(fmt,STR(x),(h).x)
// OBSOLETE   pr (fmt_x, (*mp), msgh_bits);
// OBSOLETE   pr (fmt_d, (*mp), msgh_size);
// OBSOLETE   pr (fmt_x, (*mp), msgh_remote_port);
// OBSOLETE   pr (fmt_x, (*mp), msgh_local_port);
// OBSOLETE   pr (fmt_d, (*mp), msgh_kind);
// OBSOLETE   printf_filtered (fmt_s, STR (msgh_id), id_str (mp->msgh_id, buf));
// OBSOLETE 
// OBSOLETE   if (debug_level > 1)
// OBSOLETE     {
// OBSOLETE       char *p, *ep, *dp;
// OBSOLETE       int plen;
// OBSOLETE       p = (char *) mp;
// OBSOLETE       ep = p + mp->msgh_size;
// OBSOLETE       p += sizeof (*mp);
// OBSOLETE       for (; p < ep; p += plen)
// OBSOLETE 	{
// OBSOLETE 	  mach_msg_type_t *tp;
// OBSOLETE 	  mach_msg_type_long_t *tlp;
// OBSOLETE 	  int name, size, number;
// OBSOLETE 	  tp = (mach_msg_type_t *) p;
// OBSOLETE 	  if (tp->msgt_longform)
// OBSOLETE 	    {
// OBSOLETE 	      tlp = (mach_msg_type_long_t *) tp;
// OBSOLETE 	      name = tlp->msgtl_name;
// OBSOLETE 	      size = tlp->msgtl_size;
// OBSOLETE 	      number = tlp->msgtl_number;
// OBSOLETE 	      plen = sizeof (*tlp);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      name = tp->msgt_name;
// OBSOLETE 	      size = tp->msgt_size;
// OBSOLETE 	      number = tp->msgt_number;
// OBSOLETE 	      plen = sizeof (*tp);
// OBSOLETE 	    }
// OBSOLETE 	  printf_filtered ("name=%-16s size=%2d number=%7d inline=%d long=%d deal=%d\n",
// OBSOLETE 			name_str (name, buf), size, number, tp->msgt_inline,
// OBSOLETE 			   tp->msgt_longform, tp->msgt_deallocate);
// OBSOLETE 	  dp = p + plen;
// OBSOLETE 	  if (tp->msgt_inline)
// OBSOLETE 	    {
// OBSOLETE 	      int l;
// OBSOLETE 	      l = size * number / 8;
// OBSOLETE 	      l = (l + sizeof (long) - 1) & ~((sizeof (long)) - 1);
// OBSOLETE 	      plen += l;
// OBSOLETE 	      print_data (dp, size, number);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      plen += sizeof (int *);
// OBSOLETE 	    }
// OBSOLETE 	  printf_filtered ("plen=%d\n", plen);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE print_data (char *p, int size, int number)
// OBSOLETE {
// OBSOLETE   int *ip;
// OBSOLETE   short *sp;
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   switch (size)
// OBSOLETE     {
// OBSOLETE     case 8:
// OBSOLETE       for (i = 0; i < number; i++)
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered (" %02x", p[i]);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE     case 16:
// OBSOLETE       sp = (short *) p;
// OBSOLETE       for (i = 0; i < number; i++)
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered (" %04x", sp[i]);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE     case 32:
// OBSOLETE       ip = (int *) p;
// OBSOLETE       for (i = 0; i < number; i++)
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered (" %08x", ip[i]);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE   puts_filtered ("\n");
// OBSOLETE }
// OBSOLETE #endif /* DUMP_SYSCALL */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_stop (void)
// OBSOLETE {
// OBSOLETE   error ("to_stop target function not implemented");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE m3_pid_to_exec_file (int pid)
// OBSOLETE {
// OBSOLETE   error ("to_pid_to_exec_file target function not implemented");
// OBSOLETE   return NULL;			/* To keep all compilers happy. */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_m3_ops (void)
// OBSOLETE {
// OBSOLETE   m3_ops.to_shortname = "mach";
// OBSOLETE   m3_ops.to_longname = "Mach child process";
// OBSOLETE   m3_ops.to_doc = "Mach child process (started by the \"run\" command).";
// OBSOLETE   m3_ops.to_open = m3_open;
// OBSOLETE   m3_ops.to_attach = m3_attach;
// OBSOLETE   m3_ops.to_detach = m3_detach;
// OBSOLETE   m3_ops.to_resume = m3_resume;
// OBSOLETE   m3_ops.to_wait = mach_really_wait;
// OBSOLETE   m3_ops.to_fetch_registers = fetch_inferior_registers;
// OBSOLETE   m3_ops.to_store_registers = store_inferior_registers;
// OBSOLETE   m3_ops.to_prepare_to_store = m3_prepare_to_store;
// OBSOLETE   m3_ops.to_xfer_memory = m3_xfer_memory;
// OBSOLETE   m3_ops.to_files_info = m3_files_info;
// OBSOLETE   m3_ops.to_insert_breakpoint = memory_insert_breakpoint;
// OBSOLETE   m3_ops.to_remove_breakpoint = memory_remove_breakpoint;
// OBSOLETE   m3_ops.to_terminal_init = terminal_init_inferior;
// OBSOLETE   m3_ops.to_terminal_inferior = terminal_inferior;
// OBSOLETE   m3_ops.to_terminal_ours_for_output = terminal_ours_for_output;
// OBSOLETE   m3_ops.to_terminal_save_ours = terminal_save_ours;
// OBSOLETE   m3_ops.to_terminal_ours = terminal_ours;
// OBSOLETE   m3_ops.to_terminal_info = child_terminal_info;
// OBSOLETE   m3_ops.to_kill = m3_kill_inferior;
// OBSOLETE   m3_ops.to_create_inferior = m3_create_inferior;
// OBSOLETE   m3_ops.to_mourn_inferior = m3_mourn_inferior;
// OBSOLETE   m3_ops.to_can_run = m3_can_run;
// OBSOLETE   m3_ops.to_stop = m3_stop;
// OBSOLETE   m3_ops.to_pid_to_exec_file = m3_pid_to_exec_file;
// OBSOLETE   m3_ops.to_stratum = process_stratum;
// OBSOLETE   m3_ops.to_has_all_memory = 1;
// OBSOLETE   m3_ops.to_has_memory = 1;
// OBSOLETE   m3_ops.to_has_stack = 1;
// OBSOLETE   m3_ops.to_has_registers = 1;
// OBSOLETE   m3_ops.to_has_execution = 1;
// OBSOLETE   m3_ops.to_magic = OPS_MAGIC;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_m3_nat (void)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   init_m3_ops ();
// OBSOLETE   add_target (&m3_ops);
// OBSOLETE 
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_PORT_SET,
// OBSOLETE 			    &inferior_wait_port_set);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     internal_error (__FILE__, __LINE__,
// OBSOLETE 		    "initial port set %s", mach_error_string (ret));
// OBSOLETE 
// OBSOLETE   /* mach_really_wait now waits for this */
// OBSOLETE   currently_waiting_for = inferior_wait_port_set;
// OBSOLETE 
// OBSOLETE   ret = netname_look_up (name_server_port, hostname, "MachID", &mid_server);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       mid_server = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE       warning ("initialize machid: netname_lookup_up(MachID) : %s",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE       warning ("Some (most?) features disabled...");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   mid_auth = mach_privileged_host_port ();
// OBSOLETE   if (mid_auth == MACH_PORT_NULL)
// OBSOLETE     mid_auth = mach_task_self ();
// OBSOLETE 
// OBSOLETE   obstack_init (port_chain_obstack);
// OBSOLETE 
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    &thread_exception_port);
// OBSOLETE   CHK ("Creating thread_exception_port for single stepping", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_insert_right (mach_task_self (),
// OBSOLETE 				thread_exception_port,
// OBSOLETE 				thread_exception_port,
// OBSOLETE 				MACH_MSG_TYPE_MAKE_SEND);
// OBSOLETE   CHK ("Inserting send right to thread_exception_port", ret);
// OBSOLETE 
// OBSOLETE   /* Allocate message port */
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    &our_message_port);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("Creating message port %s", mach_error_string (ret));
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       char buf[MAX_NAME_LEN];
// OBSOLETE       ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 				   our_message_port,
// OBSOLETE 				   inferior_wait_port_set);
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	warning ("message move member %s", mach_error_string (ret));
// OBSOLETE 
// OBSOLETE 
// OBSOLETE       /* @@@@@@@@ No way to change message port name currently */
// OBSOLETE       /* Foo. This assumes gdb has a unix pid */
// OBSOLETE       sprintf (buf, "gdb-%d", getpid ());
// OBSOLETE       gdb_register_port (buf, our_message_port);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Heap for thread commands */
// OBSOLETE   obstack_init (cproc_obstack);
// OBSOLETE 
// OBSOLETE   add_mach_specific_commands ();
// OBSOLETE }
@


1.17.4.2
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d2437 1
a2437 1
// OBSOLETE 		       VAR_DOMAIN,
@


1.17.4.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@@


1.17.22.1
log
@Merge with mainline.
@
text
@d1 4566
a4566 4566
// OBSOLETE /* Interface GDB to Mach 3.0 operating systems.
// OBSOLETE    (Most) Mach 3.0 related routines live in this file.
// OBSOLETE 
// OBSOLETE    Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
// OBSOLETE    2002 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Author: Jukka Virtanen <jtv@@hut.fi>
// OBSOLETE  *         Computing Centre
// OBSOLETE  *         Helsinki University of Technology
// OBSOLETE  *         Finland
// OBSOLETE  *
// OBSOLETE  * Thanks to my friends who helped with ideas and testing:
// OBSOLETE  *
// OBSOLETE  *      Johannes Helander, Antti Louko, Tero Mononen,
// OBSOLETE  *      jvh@@cs.hut.fi      alo@@hut.fi   tmo@@cs.hut.fi
// OBSOLETE  *
// OBSOLETE  *      Tero Kivinen       and          Eamonn McManus
// OBSOLETE  *      kivinen@@cs.hut.fi               emcmanus@@gr.osf.org
// OBSOLETE  *      
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #include <stdio.h>
// OBSOLETE 
// OBSOLETE #include <mach.h>
// OBSOLETE #include <servers/netname.h>
// OBSOLETE #include <servers/machid.h>
// OBSOLETE #include <mach/message.h>
// OBSOLETE #include <mach/notify.h>
// OBSOLETE #include <mach_error.h>
// OBSOLETE #include <mach/exception.h>
// OBSOLETE #include <mach/vm_attributes.h>
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "language.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "gdb_wait.h"
// OBSOLETE #include "gdbcmd.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE #include <servers/machid_lib.h>
// OBSOLETE #else
// OBSOLETE #define	MACH_TYPE_TASK			1
// OBSOLETE #define MACH_TYPE_THREAD		2
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /* Included only for signal names and NSIG
// OBSOLETE 
// OBSOLETE  * note: There are many problems in signal handling with
// OBSOLETE  *       gdb in Mach 3.0 in general.
// OBSOLETE  */
// OBSOLETE #include <signal.h>
// OBSOLETE #define SIG_UNKNOWN 0		/* Exception that has no matching unix signal */
// OBSOLETE 
// OBSOLETE #include <cthreads.h>
// OBSOLETE 
// OBSOLETE /* This is what a cproc looks like.  This is here partly because
// OBSOLETE    cthread_internals.h is not a header we can just #include, partly with
// OBSOLETE    an eye towards perhaps getting this to work with cross-debugging
// OBSOLETE    someday.  Best solution is if CMU publishes a real interface to this
// OBSOLETE    stuff.  */
// OBSOLETE #define CPROC_NEXT_OFFSET 0
// OBSOLETE #define CPROC_NEXT_SIZE (TARGET_PTR_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_INCARNATION_OFFSET (CPROC_NEXT_OFFSET + CPROC_NEXT_SIZE)
// OBSOLETE #define CPROC_INCARNATION_SIZE (sizeof (cthread_t))
// OBSOLETE #define CPROC_LIST_OFFSET (CPROC_INCARNATION_OFFSET + CPROC_INCARNATION_SIZE)
// OBSOLETE #define CPROC_LIST_SIZE (TARGET_PTR_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_WAIT_OFFSET (CPROC_LIST_OFFSET + CPROC_LIST_SIZE)
// OBSOLETE #define CPROC_WAIT_SIZE (TARGET_PTR_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_REPLY_OFFSET (CPROC_WAIT_OFFSET + CPROC_WAIT_SIZE)
// OBSOLETE #define CPROC_REPLY_SIZE (sizeof (mach_port_t))
// OBSOLETE #define CPROC_CONTEXT_OFFSET (CPROC_REPLY_OFFSET + CPROC_REPLY_SIZE)
// OBSOLETE #define CPROC_CONTEXT_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_LOCK_OFFSET (CPROC_CONTEXT_OFFSET + CPROC_CONTEXT_SIZE)
// OBSOLETE #define CPROC_LOCK_SIZE (sizeof (spin_lock_t))
// OBSOLETE #define CPROC_STATE_OFFSET (CPROC_LOCK_OFFSET + CPROC_LOCK_SIZE)
// OBSOLETE #define CPROC_STATE_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_WIRED_OFFSET (CPROC_STATE_OFFSET + CPROC_STATE_SIZE)
// OBSOLETE #define CPROC_WIRED_SIZE (sizeof (mach_port_t))
// OBSOLETE #define CPROC_BUSY_OFFSET (CPROC_WIRED_OFFSET + CPROC_WIRED_SIZE)
// OBSOLETE #define CPROC_BUSY_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_MSG_OFFSET (CPROC_BUSY_OFFSET + CPROC_BUSY_SIZE)
// OBSOLETE #define CPROC_MSG_SIZE (sizeof (mach_msg_header_t))
// OBSOLETE #define CPROC_BASE_OFFSET (CPROC_MSG_OFFSET + CPROC_MSG_SIZE)
// OBSOLETE #define CPROC_BASE_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_SIZE_OFFSET (CPROC_BASE_OFFSET + CPROC_BASE_SIZE)
// OBSOLETE #define CPROC_SIZE_SIZE (TARGET_INT_BIT / HOST_CHAR_BIT)
// OBSOLETE #define CPROC_SIZE (CPROC_SIZE_OFFSET + CPROC_SIZE_SIZE)
// OBSOLETE 
// OBSOLETE /* Values for the state field in the cproc.  */
// OBSOLETE #define CPROC_RUNNING	0
// OBSOLETE #define CPROC_SWITCHING 1
// OBSOLETE #define CPROC_BLOCKED	2
// OBSOLETE #define CPROC_CONDWAIT	4
// OBSOLETE 
// OBSOLETE /* For cproc and kernel thread mapping */
// OBSOLETE typedef struct gdb_thread
// OBSOLETE   {
// OBSOLETE     mach_port_t name;
// OBSOLETE     CORE_ADDR sp;
// OBSOLETE     CORE_ADDR pc;
// OBSOLETE     CORE_ADDR fp;
// OBSOLETE     boolean_t in_emulator;
// OBSOLETE     int slotid;
// OBSOLETE 
// OBSOLETE     /* This is for the mthreads list.  It points to the cproc list.
// OBSOLETE        Perhaps the two lists should be merged (or perhaps it was a mistake
// OBSOLETE        to make them both use a struct gdb_thread).  */
// OBSOLETE     struct gdb_thread *cproc;
// OBSOLETE 
// OBSOLETE     /* These are for the cproc list, which is linked through the next field
// OBSOLETE        of the struct gdb_thread.  */
// OBSOLETE     char raw_cproc[CPROC_SIZE];
// OBSOLETE     /* The cthread which is pointed to by the incarnation field from the
// OBSOLETE        cproc.  This points to the copy we've read into GDB.  */
// OBSOLETE     cthread_t cthread;
// OBSOLETE     /* Point back to the mthreads list.  */
// OBSOLETE     int reverse_map;
// OBSOLETE     struct gdb_thread *next;
// OBSOLETE   }
// OBSOLETE  *gdb_thread_t;
// OBSOLETE 
// OBSOLETE /* 
// OBSOLETE  * Actions for Mach exceptions.
// OBSOLETE  *
// OBSOLETE  * sigmap field maps the exception to corresponding Unix signal.
// OBSOLETE  *
// OBSOLETE  * I do not know how to map the exception to unix signal
// OBSOLETE  * if SIG_UNKNOWN is specified.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE struct exception_list
// OBSOLETE   {
// OBSOLETE     char *name;
// OBSOLETE     boolean_t forward;
// OBSOLETE     boolean_t print;
// OBSOLETE     int sigmap;
// OBSOLETE   }
// OBSOLETE exception_map[] =
// OBSOLETE {
// OBSOLETE   {
// OBSOLETE     "not_mach3_exception", FALSE, TRUE, SIG_UNKNOWN
// OBSOLETE   }
// OBSOLETE   ,
// OBSOLETE   {
// OBSOLETE     "EXC_BAD_ACCESS", FALSE, TRUE, SIGSEGV
// OBSOLETE   }
// OBSOLETE   ,
// OBSOLETE   {
// OBSOLETE     "EXC_BAD_INSTRUCTION", FALSE, TRUE, SIGILL
// OBSOLETE   }
// OBSOLETE   ,
// OBSOLETE   {
// OBSOLETE     "EXC_ARITHMETIC", FALSE, TRUE, SIGFPE
// OBSOLETE   }
// OBSOLETE   ,
// OBSOLETE   {
// OBSOLETE     "EXC_EMULATION", FALSE, TRUE, SIGEMT
// OBSOLETE   }
// OBSOLETE   ,				/* ??? */
// OBSOLETE   {
// OBSOLETE     "EXC_SOFTWARE", FALSE, TRUE, SIG_UNKNOWN
// OBSOLETE   }
// OBSOLETE   ,
// OBSOLETE   {
// OBSOLETE     "EXC_BREAKPOINT", FALSE, FALSE, SIGTRAP
// OBSOLETE   }
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* Mach exception table size */
// OBSOLETE int max_exception = sizeof (exception_map) / sizeof (struct exception_list) - 1;
// OBSOLETE 
// OBSOLETE #define MAX_EXCEPTION max_exception
// OBSOLETE 
// OBSOLETE WAITTYPE wait_status;
// OBSOLETE 
// OBSOLETE /* If you define this, intercepted bsd server calls will be
// OBSOLETE  * dumped while waiting the inferior to EXEC the correct
// OBSOLETE  * program
// OBSOLETE  */
// OBSOLETE /* #define DUMP_SYSCALL         /* debugging interceptor */
// OBSOLETE 
// OBSOLETE /* xx_debug() outputs messages if this is nonzero.
// OBSOLETE  * If > 1, DUMP_SYSCALL will dump message contents.
// OBSOLETE  */
// OBSOLETE int debug_level = 0;
// OBSOLETE 
// OBSOLETE /* "Temporary" debug stuff */
// OBSOLETE void
// OBSOLETE xx_debug (char *fmt, int a, int b, int c)
// OBSOLETE {
// OBSOLETE   if (debug_level)
// OBSOLETE     warning (fmt, a, b, c);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* This is in libmach.a */
// OBSOLETE extern mach_port_t name_server_port;
// OBSOLETE 
// OBSOLETE /* Set in catch_exception_raise */
// OBSOLETE int stop_exception, stop_code, stop_subcode;
// OBSOLETE int stopped_in_exception;
// OBSOLETE 
// OBSOLETE /* Thread that was the active thread when we stopped */
// OBSOLETE thread_t stop_thread = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE char *hostname = "";
// OBSOLETE 
// OBSOLETE /* Set when task is attached or created */
// OBSOLETE boolean_t emulator_present = FALSE;
// OBSOLETE 
// OBSOLETE task_t inferior_task;
// OBSOLETE thread_t current_thread;
// OBSOLETE 
// OBSOLETE /* Exception ports for inferior task */
// OBSOLETE mach_port_t inferior_exception_port = MACH_PORT_NULL;
// OBSOLETE mach_port_t inferior_old_exception_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* task exceptions and notifications */
// OBSOLETE mach_port_t inferior_wait_port_set = MACH_PORT_NULL;
// OBSOLETE mach_port_t our_notify_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* This is "inferior_wait_port_set" when not single stepping, and
// OBSOLETE  *         "singlestepped_thread_port" when we are single stepping.
// OBSOLETE  * 
// OBSOLETE  * This is protected by a cleanup function: discard_single_step()
// OBSOLETE  */
// OBSOLETE mach_port_t currently_waiting_for = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* A port for external messages to gdb.
// OBSOLETE  * External in the meaning that they do not come
// OBSOLETE  * from the inferior_task, but rather from external
// OBSOLETE  * tasks.
// OBSOLETE  *
// OBSOLETE  * As a debugging feature:
// OBSOLETE  * A debugger debugging another debugger can stop the
// OBSOLETE  * inferior debugger by the following command sequence
// OBSOLETE  * (without running external programs)
// OBSOLETE  *
// OBSOLETE  *    (top-gdb) set stop_inferior_gdb ()
// OBSOLETE  *    (top-gdb) continue
// OBSOLETE  */
// OBSOLETE mach_port_t our_message_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* For single stepping */
// OBSOLETE mach_port_t thread_exception_port = MACH_PORT_NULL;
// OBSOLETE mach_port_t thread_saved_exception_port = MACH_PORT_NULL;
// OBSOLETE mach_port_t singlestepped_thread_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* For machid calls */
// OBSOLETE mach_port_t mid_server = MACH_PORT_NULL;
// OBSOLETE mach_port_t mid_auth = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE /* If gdb thinks the inferior task is not suspended, it
// OBSOLETE  * must take suspend/abort the threads when it reads the state.
// OBSOLETE  */
// OBSOLETE int must_suspend_thread = 0;
// OBSOLETE 
// OBSOLETE /* When single stepping, we switch the port that mach_really_wait() listens to.
// OBSOLETE  * This cleanup is a guard to prevent the port set from being left to
// OBSOLETE  * the singlestepped_thread_port when error() is called.
// OBSOLETE  *  This is nonzero only when we are single stepping.
// OBSOLETE  */
// OBSOLETE #define NULL_CLEANUP (struct cleanup *)0
// OBSOLETE struct cleanup *cleanup_step = NULL_CLEANUP;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static struct target_ops m3_ops;
// OBSOLETE 
// OBSOLETE static void m3_kill_inferior ();
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE #define MACH_TYPE_EXCEPTION_PORT	-1
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /* Chain of ports to remember requested notifications. */
// OBSOLETE 
// OBSOLETE struct port_chain
// OBSOLETE   {
// OBSOLETE     struct port_chain *next;
// OBSOLETE     mach_port_t port;
// OBSOLETE     int type;
// OBSOLETE     int mid;			/* Now only valid with MACH_TYPE_THREAD and */
// OBSOLETE     /*  MACH_TYPE_THREAD */
// OBSOLETE   };
// OBSOLETE typedef struct port_chain *port_chain_t;
// OBSOLETE 
// OBSOLETE /* Room for chain nodes comes from pchain_obstack */
// OBSOLETE struct obstack pchain_obstack;
// OBSOLETE struct obstack *port_chain_obstack = &pchain_obstack;
// OBSOLETE 
// OBSOLETE /* For thread handling */
// OBSOLETE struct obstack Cproc_obstack;
// OBSOLETE struct obstack *cproc_obstack = &Cproc_obstack;
// OBSOLETE 
// OBSOLETE /* the list of notified ports */
// OBSOLETE port_chain_t notify_chain = (port_chain_t) NULL;
// OBSOLETE 
// OBSOLETE port_chain_t
// OBSOLETE port_chain_insert (port_chain_t list, mach_port_t name, int type)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   port_chain_t new;
// OBSOLETE   int mid;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (name))
// OBSOLETE     return list;
// OBSOLETE 
// OBSOLETE   if (type == MACH_TYPE_TASK || type == MACH_TYPE_THREAD)
// OBSOLETE     {
// OBSOLETE       if (!MACH_PORT_VALID (mid_server))
// OBSOLETE 	{
// OBSOLETE 	  warning ("Machid server port invalid, can not map port 0x%x to MID",
// OBSOLETE 		   name);
// OBSOLETE 	  mid = name;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  ret = machid_mach_register (mid_server, mid_auth, name, type, &mid);
// OBSOLETE 
// OBSOLETE 	  if (ret != KERN_SUCCESS)
// OBSOLETE 	    {
// OBSOLETE 	      warning ("Can not map name (0x%x) to MID with machid", name);
// OBSOLETE 	      mid = name;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE 
// OBSOLETE   new = (port_chain_t) obstack_alloc (port_chain_obstack,
// OBSOLETE 				      sizeof (struct port_chain));
// OBSOLETE   new->next = list;
// OBSOLETE   new->port = name;
// OBSOLETE   new->type = type;
// OBSOLETE   new->mid = mid;
// OBSOLETE 
// OBSOLETE   return new;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE port_chain_t
// OBSOLETE port_chain_delete (port_chain_t list, mach_port_t elem)
// OBSOLETE {
// OBSOLETE   if (list)
// OBSOLETE     if (list->port == elem)
// OBSOLETE       list = list->next;
// OBSOLETE     else
// OBSOLETE       while (list->next)
// OBSOLETE 	{
// OBSOLETE 	  if (list->next->port == elem)
// OBSOLETE 	    list->next = list->next->next;	/* GCd with obstack_free() */
// OBSOLETE 	  else
// OBSOLETE 	    list = list->next;
// OBSOLETE 	}
// OBSOLETE   return list;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE port_chain_destroy (struct obstack *ostack)
// OBSOLETE {
// OBSOLETE   obstack_free (ostack, 0);
// OBSOLETE   obstack_init (ostack);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE port_chain_t
// OBSOLETE port_chain_member (port_chain_t list, mach_port_t elem)
// OBSOLETE {
// OBSOLETE   while (list)
// OBSOLETE     {
// OBSOLETE       if (list->port == elem)
// OBSOLETE 	return list;
// OBSOLETE       list = list->next;
// OBSOLETE     }
// OBSOLETE   return (port_chain_t) NULL;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE map_port_name_to_mid (mach_port_t name, int type)
// OBSOLETE {
// OBSOLETE   port_chain_t elem;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (name))
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   elem = port_chain_member (notify_chain, name);
// OBSOLETE 
// OBSOLETE   if (elem && (elem->type == type))
// OBSOLETE     return elem->mid;
// OBSOLETE 
// OBSOLETE   if (elem)
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (mid_server))
// OBSOLETE     {
// OBSOLETE       warning ("Machid server port invalid, can not map port 0x%x to mid",
// OBSOLETE 	       name);
// OBSOLETE       return -1;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       int mid;
// OBSOLETE       kern_return_t ret;
// OBSOLETE 
// OBSOLETE       ret = machid_mach_register (mid_server, mid_auth, name, type, &mid);
// OBSOLETE 
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	{
// OBSOLETE 	  warning ("Can not map name (0x%x) to mid with machid", name);
// OBSOLETE 	  return -1;
// OBSOLETE 	}
// OBSOLETE       return mid;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Guard for currently_waiting_for and singlestepped_thread_port */
// OBSOLETE static void
// OBSOLETE discard_single_step (thread_t thread)
// OBSOLETE {
// OBSOLETE   currently_waiting_for = inferior_wait_port_set;
// OBSOLETE 
// OBSOLETE   cleanup_step = NULL_CLEANUP;
// OBSOLETE   if (MACH_PORT_VALID (thread) && MACH_PORT_VALID (singlestepped_thread_port))
// OBSOLETE     setup_single_step (thread, FALSE);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE setup_single_step (thread_t thread, boolean_t start_step)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (thread))
// OBSOLETE     error ("Invalid thread supplied to setup_single_step");
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       mach_port_t teport;
// OBSOLETE 
// OBSOLETE       /* Get the current thread exception port */
// OBSOLETE       ret = thread_get_exception_port (thread, &teport);
// OBSOLETE       CHK ("Getting thread's exception port", ret);
// OBSOLETE 
// OBSOLETE       if (start_step)
// OBSOLETE 	{
// OBSOLETE 	  if (MACH_PORT_VALID (singlestepped_thread_port))
// OBSOLETE 	    {
// OBSOLETE 	      warning ("Singlestepped_thread_port (0x%x) is still valid?",
// OBSOLETE 		       singlestepped_thread_port);
// OBSOLETE 	      singlestepped_thread_port = MACH_PORT_NULL;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  /* If we are already stepping this thread */
// OBSOLETE 	  if (MACH_PORT_VALID (teport) && teport == thread_exception_port)
// OBSOLETE 	    {
// OBSOLETE 	      ret = mach_port_deallocate (mach_task_self (), teport);
// OBSOLETE 	      CHK ("Could not deallocate thread exception port", ret);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      ret = thread_set_exception_port (thread, thread_exception_port);
// OBSOLETE 	      CHK ("Setting exception port for thread", ret);
// OBSOLETE #if 0
// OBSOLETE 	      /* Insert thread exception port to wait port set */
// OBSOLETE 	      ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 					   thread_exception_port,
// OBSOLETE 					   inferior_wait_port_set);
// OBSOLETE 	      CHK ("Moving thread exception port to inferior_wait_port_set",
// OBSOLETE 		   ret);
// OBSOLETE #endif
// OBSOLETE 	      thread_saved_exception_port = teport;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  thread_trace (thread, TRUE);
// OBSOLETE 
// OBSOLETE 	  singlestepped_thread_port = thread_exception_port;
// OBSOLETE 	  currently_waiting_for = singlestepped_thread_port;
// OBSOLETE 	  cleanup_step = make_cleanup (discard_single_step, thread);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (!MACH_PORT_VALID (teport))
// OBSOLETE 	    error ("Single stepped thread had an invalid exception port?");
// OBSOLETE 
// OBSOLETE 	  if (teport != thread_exception_port)
// OBSOLETE 	    error ("Single stepped thread had an unknown exception port?");
// OBSOLETE 
// OBSOLETE 	  ret = mach_port_deallocate (mach_task_self (), teport);
// OBSOLETE 	  CHK ("Couldn't deallocate thread exception port", ret);
// OBSOLETE #if 0
// OBSOLETE 	  /* Remove thread exception port from wait port set */
// OBSOLETE 	  ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 				       thread_exception_port,
// OBSOLETE 				       MACH_PORT_NULL);
// OBSOLETE 	  CHK ("Removing thread exception port from inferior_wait_port_set",
// OBSOLETE 	       ret);
// OBSOLETE #endif
// OBSOLETE 	  /* Restore thread's old exception port */
// OBSOLETE 	  ret = thread_set_exception_port (thread,
// OBSOLETE 					   thread_saved_exception_port);
// OBSOLETE 	  CHK ("Restoring stepped thread's exception port", ret);
// OBSOLETE 
// OBSOLETE 	  if (MACH_PORT_VALID (thread_saved_exception_port))
// OBSOLETE 	    (void) mach_port_deallocate (mach_task_self (),
// OBSOLETE 					 thread_saved_exception_port);
// OBSOLETE 
// OBSOLETE 	  thread_trace (thread, FALSE);
// OBSOLETE 
// OBSOLETE 	  singlestepped_thread_port = MACH_PORT_NULL;
// OBSOLETE 	  currently_waiting_for = inferior_wait_port_set;
// OBSOLETE 	  if (cleanup_step)
// OBSOLETE 	    discard_cleanups (cleanup_step);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static
// OBSOLETE request_notify (mach_port_t name, mach_msg_id_t variant, int type)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   mach_port_t previous_port_dummy = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (name))
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   if (port_chain_member (notify_chain, name))
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   ret = mach_port_request_notification (mach_task_self (),
// OBSOLETE 					name,
// OBSOLETE 					variant,
// OBSOLETE 					1,
// OBSOLETE 					our_notify_port,
// OBSOLETE 					MACH_MSG_TYPE_MAKE_SEND_ONCE,
// OBSOLETE 					&previous_port_dummy);
// OBSOLETE   CHK ("Serious: request_notify failed", ret);
// OBSOLETE 
// OBSOLETE   (void) mach_port_deallocate (mach_task_self (),
// OBSOLETE 			       previous_port_dummy);
// OBSOLETE 
// OBSOLETE   notify_chain = port_chain_insert (notify_chain, name, type);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE reverse_msg_bits (mach_msg_header_t *msgp, int type)
// OBSOLETE {
// OBSOLETE   int rbits, lbits;
// OBSOLETE   rbits = MACH_MSGH_BITS_REMOTE (msgp->msgh_bits);
// OBSOLETE   lbits = type;
// OBSOLETE   msgp->msgh_bits =
// OBSOLETE     (msgp->msgh_bits & ~MACH_MSGH_BITS_PORTS_MASK) |
// OBSOLETE     MACH_MSGH_BITS (lbits, rbits);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* On the third day He said:
// OBSOLETE 
// OBSOLETE    Let this be global
// OBSOLETE    and then it was global.
// OBSOLETE 
// OBSOLETE    When creating the inferior fork, the
// OBSOLETE    child code in inflow.c sets the name of the
// OBSOLETE    bootstrap_port in its address space to this
// OBSOLETE    variable.
// OBSOLETE 
// OBSOLETE    The name is transferred to our address space
// OBSOLETE    with mach3_read_inferior().
// OBSOLETE 
// OBSOLETE    Thou shalt not do this with
// OBSOLETE    task_get_bootstrap_port() in this task, since
// OBSOLETE    the name in the inferior task is different than
// OBSOLETE    the one we get.
// OBSOLETE 
// OBSOLETE    For blessed are the meek, as they shall inherit
// OBSOLETE    the address space.
// OBSOLETE  */
// OBSOLETE mach_port_t original_server_port_name = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Called from inferior after FORK but before EXEC */
// OBSOLETE static void
// OBSOLETE m3_trace_me (void)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   /* Get the NAME of the bootstrap port in this task
// OBSOLETE      so that GDB can read it */
// OBSOLETE   ret = task_get_bootstrap_port (mach_task_self (),
// OBSOLETE 				 &original_server_port_name);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE   ret = mach_port_deallocate (mach_task_self (),
// OBSOLETE 			      original_server_port_name);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE 
// OBSOLETE   /* Suspend this task to let the parent change my ports.
// OBSOLETE      Resumed by the debugger */
// OBSOLETE   ret = task_suspend (mach_task_self ());
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Intercept system calls to Unix server.
// OBSOLETE  * After EXEC_COUNTER calls to exec(), return.
// OBSOLETE  *
// OBSOLETE  * Pre-assertion:  Child is suspended. (Not verified)
// OBSOLETE  * Post-condition: Child is suspended after EXEC_COUNTER exec() calls.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE intercept_exec_calls (int exec_counter)
// OBSOLETE {
// OBSOLETE   int terminal_initted = 0;
// OBSOLETE 
// OBSOLETE   struct syscall_msg_t
// OBSOLETE     {
// OBSOLETE       mach_msg_header_t header;
// OBSOLETE       mach_msg_type_t type;
// OBSOLETE       char room[2000];		/* Enuff space */
// OBSOLETE     };
// OBSOLETE 
// OBSOLETE   struct syscall_msg_t syscall_in, syscall_out;
// OBSOLETE 
// OBSOLETE   mach_port_t fake_server;
// OBSOLETE   mach_port_t original_server_send;
// OBSOLETE   mach_port_t original_exec_reply;
// OBSOLETE   mach_port_t exec_reply;
// OBSOLETE   mach_port_t exec_reply_send;
// OBSOLETE   mach_msg_type_name_t acquired;
// OBSOLETE   mach_port_t emulator_server_port_name;
// OBSOLETE   struct task_basic_info info;
// OBSOLETE   mach_msg_type_number_t info_count;
// OBSOLETE 
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (exec_counter <= 0)
// OBSOLETE     return;			/* We are already set up in the correct program */
// OBSOLETE 
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    &fake_server);
// OBSOLETE   CHK ("create inferior_fake_server port failed", ret);
// OBSOLETE 
// OBSOLETE   /* Wait for inferior_task to suspend itself */
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       info_count = sizeof (info);
// OBSOLETE       ret = task_info (inferior_task,
// OBSOLETE 		       TASK_BASIC_INFO,
// OBSOLETE 		       (task_info_t) & info,
// OBSOLETE 		       &info_count);
// OBSOLETE       CHK ("Task info", ret);
// OBSOLETE 
// OBSOLETE       if (info.suspend_count)
// OBSOLETE 	break;
// OBSOLETE 
// OBSOLETE       /* Note that the definition of the parameter was undefined
// OBSOLETE        * at the time of this writing, so I just use an `ad hoc' value.
// OBSOLETE        */
// OBSOLETE       (void) swtch_pri (42);	/* Universal Priority Value */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Read the inferior's bootstrap port name */
// OBSOLETE   if (!mach3_read_inferior (&original_server_port_name,
// OBSOLETE 			    &original_server_port_name,
// OBSOLETE 			    sizeof (original_server_port_name)))
// OBSOLETE     error ("Can't read inferior task bootstrap port name");
// OBSOLETE 
// OBSOLETE   /* @@@@ BUG: If more than 1 send right GDB will FAIL!!! */
// OBSOLETE   /*      Should get refs, and set them back when restoring */
// OBSOLETE   /* Steal the original bsd server send right from inferior */
// OBSOLETE   ret = mach_port_extract_right (inferior_task,
// OBSOLETE 				 original_server_port_name,
// OBSOLETE 				 MACH_MSG_TYPE_MOVE_SEND,
// OBSOLETE 				 &original_server_send,
// OBSOLETE 				 &acquired);
// OBSOLETE   CHK ("mach_port_extract_right (bsd server send)", ret);
// OBSOLETE 
// OBSOLETE   if (acquired != MACH_MSG_TYPE_PORT_SEND)
// OBSOLETE     error ("Incorrect right extracted, send right to bsd server expected");
// OBSOLETE 
// OBSOLETE   ret = mach_port_insert_right (inferior_task,
// OBSOLETE 				original_server_port_name,
// OBSOLETE 				fake_server,
// OBSOLETE 				MACH_MSG_TYPE_MAKE_SEND);
// OBSOLETE   CHK ("mach_port_insert_right (fake server send)", ret);
// OBSOLETE 
// OBSOLETE   xx_debug ("inferior task bsd server ports set up \nfs %x, ospn %x, oss %x\n",
// OBSOLETE 	    fake_server,
// OBSOLETE 	    original_server_port_name, original_server_send);
// OBSOLETE 
// OBSOLETE   /* A receive right to the reply generated by unix server exec() request */
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    &exec_reply);
// OBSOLETE   CHK ("create intercepted_reply_port port failed", ret);
// OBSOLETE 
// OBSOLETE   /* Pass this send right to Unix server so it replies to us after exec() */
// OBSOLETE   ret = mach_port_extract_right (mach_task_self (),
// OBSOLETE 				 exec_reply,
// OBSOLETE 				 MACH_MSG_TYPE_MAKE_SEND_ONCE,
// OBSOLETE 				 &exec_reply_send,
// OBSOLETE 				 &acquired);
// OBSOLETE   CHK ("mach_port_extract_right (exec_reply)", ret);
// OBSOLETE 
// OBSOLETE   if (acquired != MACH_MSG_TYPE_PORT_SEND_ONCE)
// OBSOLETE     error ("Incorrect right extracted, send once expected for exec reply");
// OBSOLETE 
// OBSOLETE   ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 			       fake_server,
// OBSOLETE 			       inferior_wait_port_set);
// OBSOLETE   CHK ("Moving fake syscall port to inferior_wait_port_set", ret);
// OBSOLETE 
// OBSOLETE   xx_debug ("syscall fake server set up, resuming inferior\n");
// OBSOLETE 
// OBSOLETE   ret = task_resume (inferior_task);
// OBSOLETE   CHK ("task_resume (startup)", ret);
// OBSOLETE 
// OBSOLETE   /* Read requests from the inferior.
// OBSOLETE      Pass directly through everything else except exec() calls.
// OBSOLETE    */
// OBSOLETE   while (exec_counter > 0)
// OBSOLETE     {
// OBSOLETE       ret = mach_msg (&syscall_in.header,	/* header */
// OBSOLETE 		      MACH_RCV_MSG,	/* options */
// OBSOLETE 		      0,	/* send size */
// OBSOLETE 		      sizeof (struct syscall_msg_t),	/* receive size */
// OBSOLETE 		      inferior_wait_port_set,	/* receive_name */
// OBSOLETE 		      MACH_MSG_TIMEOUT_NONE,
// OBSOLETE 		      MACH_PORT_NULL);
// OBSOLETE       CHK ("mach_msg (intercepted sycall)", ret);
// OBSOLETE 
// OBSOLETE #ifdef DUMP_SYSCALL
// OBSOLETE       print_msg (&syscall_in.header);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE       /* ASSERT : msgh_local_port == fake_server */
// OBSOLETE 
// OBSOLETE       if (notify_server (&syscall_in.header, &syscall_out.header))
// OBSOLETE 	error ("received a notify while intercepting syscalls");
// OBSOLETE 
// OBSOLETE       if (syscall_in.header.msgh_id == MIG_EXEC_SYSCALL_ID)
// OBSOLETE 	{
// OBSOLETE 	  xx_debug ("Received EXEC SYSCALL, counter = %d\n", exec_counter);
// OBSOLETE 	  if (exec_counter == 1)
// OBSOLETE 	    {
// OBSOLETE 	      original_exec_reply = syscall_in.header.msgh_remote_port;
// OBSOLETE 	      syscall_in.header.msgh_remote_port = exec_reply_send;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  if (!terminal_initted)
// OBSOLETE 	    {
// OBSOLETE 	      /* Now that the child has exec'd we know it has already set its
// OBSOLETE 	         process group.  On POSIX systems, tcsetpgrp will fail with
// OBSOLETE 	         EPERM if we try it before the child's setpgid.  */
// OBSOLETE 
// OBSOLETE 	      /* Set up the "saved terminal modes" of the inferior
// OBSOLETE 	         based on what modes we are starting it with.  */
// OBSOLETE 	      target_terminal_init ();
// OBSOLETE 
// OBSOLETE 	      /* Install inferior's terminal modes.  */
// OBSOLETE 	      target_terminal_inferior ();
// OBSOLETE 
// OBSOLETE 	      terminal_initted = 1;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  exec_counter--;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       syscall_in.header.msgh_local_port = syscall_in.header.msgh_remote_port;
// OBSOLETE       syscall_in.header.msgh_remote_port = original_server_send;
// OBSOLETE 
// OBSOLETE       reverse_msg_bits (&syscall_in.header, MACH_MSG_TYPE_COPY_SEND);
// OBSOLETE 
// OBSOLETE       ret = mach_msg_send (&syscall_in.header);
// OBSOLETE       CHK ("Forwarded syscall", ret);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 			       fake_server,
// OBSOLETE 			       MACH_PORT_NULL);
// OBSOLETE   CHK ("Moving fake syscall out of inferior_wait_port_set", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 			       exec_reply,
// OBSOLETE 			       inferior_wait_port_set);
// OBSOLETE   CHK ("Moving exec_reply to inferior_wait_port_set", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_msg (&syscall_in.header,	/* header */
// OBSOLETE 		  MACH_RCV_MSG,	/* options */
// OBSOLETE 		  0,		/* send size */
// OBSOLETE 		  sizeof (struct syscall_msg_t),	/* receive size */
// OBSOLETE 		  inferior_wait_port_set,	/* receive_name */
// OBSOLETE 		  MACH_MSG_TIMEOUT_NONE,
// OBSOLETE 		  MACH_PORT_NULL);
// OBSOLETE   CHK ("mach_msg (exec reply)", ret);
// OBSOLETE 
// OBSOLETE   ret = task_suspend (inferior_task);
// OBSOLETE   CHK ("Suspending inferior after last exec", ret);
// OBSOLETE 
// OBSOLETE   must_suspend_thread = 0;
// OBSOLETE 
// OBSOLETE   xx_debug ("Received exec reply from bsd server, suspended inferior task\n");
// OBSOLETE 
// OBSOLETE #ifdef DUMP_SYSCALL
// OBSOLETE   print_msg (&syscall_in.header);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   /* Message should appear as if it came from the unix server */
// OBSOLETE   syscall_in.header.msgh_local_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE   /*  and go to the inferior task original reply port */
// OBSOLETE   syscall_in.header.msgh_remote_port = original_exec_reply;
// OBSOLETE 
// OBSOLETE   reverse_msg_bits (&syscall_in.header, MACH_MSG_TYPE_MOVE_SEND_ONCE);
// OBSOLETE 
// OBSOLETE   ret = mach_msg_send (&syscall_in.header);
// OBSOLETE   CHK ("Forwarding exec reply to inferior", ret);
// OBSOLETE 
// OBSOLETE   /* Garbage collect */
// OBSOLETE   ret = mach_port_deallocate (inferior_task,
// OBSOLETE 			      original_server_port_name);
// OBSOLETE   CHK ("deallocating fake server send right", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_insert_right (inferior_task,
// OBSOLETE 				original_server_port_name,
// OBSOLETE 				original_server_send,
// OBSOLETE 				MACH_MSG_TYPE_MOVE_SEND);
// OBSOLETE   CHK ("Restoring the original bsd server send right", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_destroy (mach_task_self (),
// OBSOLETE 			   fake_server);
// OBSOLETE   fake_server = MACH_PORT_DEAD;
// OBSOLETE   CHK ("mach_port_destroy (fake_server)", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_destroy (mach_task_self (),
// OBSOLETE 			   exec_reply);
// OBSOLETE   exec_reply = MACH_PORT_DEAD;
// OBSOLETE   CHK ("mach_port_destroy (exec_reply)", ret);
// OBSOLETE 
// OBSOLETE   xx_debug ("Done with exec call interception\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE consume_send_rights (thread_array_t thread_list, int thread_count)
// OBSOLETE {
// OBSOLETE   int index;
// OBSOLETE 
// OBSOLETE   if (!thread_count)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   for (index = 0; index < thread_count; index++)
// OBSOLETE     {
// OBSOLETE       /* Since thread kill command kills threads, don't check ret */
// OBSOLETE       (void) mach_port_deallocate (mach_task_self (),
// OBSOLETE 				   thread_list[index]);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* suspend/abort/resume a thread. */
// OBSOLETE setup_thread (mach_port_t thread, int what)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (what)
// OBSOLETE     {
// OBSOLETE       ret = thread_suspend (thread);
// OBSOLETE       CHK ("setup_thread thread_suspend", ret);
// OBSOLETE 
// OBSOLETE       ret = thread_abort (thread);
// OBSOLETE       CHK ("setup_thread thread_abort", ret);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       ret = thread_resume (thread);
// OBSOLETE       CHK ("setup_thread thread_resume", ret);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE map_slot_to_mid (int slot, thread_array_t threads, int thread_count)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int deallocate = 0;
// OBSOLETE   int index;
// OBSOLETE   int mid;
// OBSOLETE 
// OBSOLETE   if (!threads)
// OBSOLETE     {
// OBSOLETE       deallocate++;
// OBSOLETE       ret = task_threads (inferior_task, &threads, &thread_count);
// OBSOLETE       CHK ("Can not select a thread from a dead task", ret);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (slot < 0 || slot >= thread_count)
// OBSOLETE     {
// OBSOLETE       if (deallocate)
// OBSOLETE 	{
// OBSOLETE 	  consume_send_rights (threads, thread_count);
// OBSOLETE 	  (void) vm_deallocate (mach_task_self (), (vm_address_t) threads,
// OBSOLETE 				(thread_count * sizeof (mach_port_t)));
// OBSOLETE 	}
// OBSOLETE       if (slot < 0)
// OBSOLETE 	error ("invalid slot number");
// OBSOLETE       else
// OBSOLETE 	return -(slot + 1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   mid = map_port_name_to_mid (threads[slot], MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE   if (deallocate)
// OBSOLETE     {
// OBSOLETE       consume_send_rights (threads, thread_count);
// OBSOLETE       (void) vm_deallocate (mach_task_self (), (vm_address_t) threads,
// OBSOLETE 			    (thread_count * sizeof (mach_port_t)));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return mid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE parse_thread_id (char *arg, int thread_count, int slots)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int mid;
// OBSOLETE   int slot;
// OBSOLETE   int index;
// OBSOLETE 
// OBSOLETE   if (arg == 0)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   while (*arg && (*arg == ' ' || *arg == '\t'))
// OBSOLETE     arg++;
// OBSOLETE 
// OBSOLETE   if (!*arg)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   /* Currently parse MID and @@SLOTNUMBER */
// OBSOLETE   if (*arg != '@@')
// OBSOLETE     {
// OBSOLETE       mid = atoi (arg);
// OBSOLETE       if (mid <= 0)
// OBSOLETE 	error ("valid thread mid expected");
// OBSOLETE       return mid;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   arg++;
// OBSOLETE   slot = atoi (arg);
// OBSOLETE 
// OBSOLETE   if (slot < 0)
// OBSOLETE     error ("invalid slot number");
// OBSOLETE 
// OBSOLETE   /* If you want slot numbers to remain slot numbers, set slots.
// OBSOLETE 
// OBSOLETE    * Well, since 0 is reserved, return the ordinal number
// OBSOLETE    * of the thread rather than the slot number. Awk, this
// OBSOLETE    * counts as a kludge.
// OBSOLETE    */
// OBSOLETE   if (slots)
// OBSOLETE     return -(slot + 1);
// OBSOLETE 
// OBSOLETE   if (thread_count && slot >= thread_count)
// OBSOLETE     return -(slot + 1);
// OBSOLETE 
// OBSOLETE   mid = map_slot_to_mid (slot);
// OBSOLETE 
// OBSOLETE   return mid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* THREAD_ID 0 is special; it selects the first kernel
// OBSOLETE  * thread from the list (i.e. SLOTNUMBER 0)
// OBSOLETE  * This is used when starting the program with 'run' or when attaching.
// OBSOLETE  *
// OBSOLETE  * If FLAG is 0 the context is not changed, and the registers, frame, etc
// OBSOLETE  * will continue to describe the old thread.
// OBSOLETE  *
// OBSOLETE  * If FLAG is nonzero, really select the thread.
// OBSOLETE  * If FLAG is 2, the THREAD_ID is a slotnumber instead of a mid.
// OBSOLETE  * 
// OBSOLETE  */
// OBSOLETE kern_return_t
// OBSOLETE select_thread (mach_port_t task, int thread_id, int flag)
// OBSOLETE {
// OBSOLETE   thread_array_t thread_list;
// OBSOLETE   int thread_count;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int index;
// OBSOLETE   thread_t new_thread = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE   if (thread_id < 0)
// OBSOLETE     error ("Can't select cprocs without kernel thread");
// OBSOLETE 
// OBSOLETE   ret = task_threads (task, &thread_list, &thread_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("Can not select a thread from a dead task");
// OBSOLETE       m3_kill_inferior ();
// OBSOLETE       return KERN_FAILURE;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (thread_count == 0)
// OBSOLETE     {
// OBSOLETE       /* The task can not do anything anymore, but it still
// OBSOLETE        * exists as a container for memory and ports.
// OBSOLETE        */
// OBSOLETE       registers_changed ();
// OBSOLETE       warning ("Task %d has no threads",
// OBSOLETE 	       map_port_name_to_mid (task, MACH_TYPE_TASK));
// OBSOLETE       current_thread = MACH_PORT_NULL;
// OBSOLETE       (void) vm_deallocate (mach_task_self (),
// OBSOLETE 			    (vm_address_t) thread_list,
// OBSOLETE 			    (thread_count * sizeof (mach_port_t)));
// OBSOLETE       return KERN_FAILURE;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!thread_id || flag == 2)
// OBSOLETE     {
// OBSOLETE       /* First thread or a slotnumber */
// OBSOLETE       if (!thread_id)
// OBSOLETE 	new_thread = thread_list[0];
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (thread_id < thread_count)
// OBSOLETE 	    new_thread = thread_list[thread_id];
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      (void) vm_deallocate (mach_task_self (),
// OBSOLETE 				    (vm_address_t) thread_list,
// OBSOLETE 				    (thread_count * sizeof (mach_port_t)));
// OBSOLETE 	      error ("No such thread slot number : %d", thread_id);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       for (index = 0; index < thread_count; index++)
// OBSOLETE 	if (thread_id == map_port_name_to_mid (thread_list[index],
// OBSOLETE 					       MACH_TYPE_THREAD))
// OBSOLETE 	  {
// OBSOLETE 	    new_thread = thread_list[index];
// OBSOLETE 	    index = -1;
// OBSOLETE 	    break;
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE       if (index != -1)
// OBSOLETE 	error ("No thread with mid %d", thread_id);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Notify when the selected thread dies */
// OBSOLETE   request_notify (new_thread, MACH_NOTIFY_DEAD_NAME, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE   ret = vm_deallocate (mach_task_self (),
// OBSOLETE 		       (vm_address_t) thread_list,
// OBSOLETE 		       (thread_count * sizeof (mach_port_t)));
// OBSOLETE   CHK ("vm_deallocate", ret);
// OBSOLETE 
// OBSOLETE   if (!flag)
// OBSOLETE     current_thread = new_thread;
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE #if 0
// OBSOLETE       if (MACH_PORT_VALID (current_thread))
// OBSOLETE 	{
// OBSOLETE 	  /* Store the gdb's view of the thread we are deselecting
// OBSOLETE 
// OBSOLETE 	   * @@@@ I think gdb updates registers immediately when they are
// OBSOLETE 	   * changed, so don't do this.
// OBSOLETE 	   */
// OBSOLETE 	  ret = thread_abort (current_thread);
// OBSOLETE 	  CHK ("Could not abort system calls when saving state of old thread",
// OBSOLETE 	       ret);
// OBSOLETE 	  target_prepare_to_store ();
// OBSOLETE 	  target_store_registers (-1);
// OBSOLETE 	}
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE       registers_changed ();
// OBSOLETE 
// OBSOLETE       current_thread = new_thread;
// OBSOLETE 
// OBSOLETE       ret = thread_abort (current_thread);
// OBSOLETE       CHK ("Could not abort system calls when selecting a thread", ret);
// OBSOLETE 
// OBSOLETE       stop_pc = read_pc ();
// OBSOLETE       flush_cached_frames ();
// OBSOLETE 
// OBSOLETE       select_frame (get_current_frame ());
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Switch to use thread named NEW_THREAD.
// OBSOLETE  * Return it's MID
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE switch_to_thread (thread_t new_thread)
// OBSOLETE {
// OBSOLETE   thread_t saved_thread = current_thread;
// OBSOLETE   int mid;
// OBSOLETE 
// OBSOLETE   mid = map_port_name_to_mid (new_thread,
// OBSOLETE 			      MACH_TYPE_THREAD);
// OBSOLETE   if (mid == -1)
// OBSOLETE     warning ("Can't map thread name 0x%x to mid", new_thread);
// OBSOLETE   else if (select_thread (inferior_task, mid, 1) != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       if (current_thread)
// OBSOLETE 	current_thread = saved_thread;
// OBSOLETE       error ("Could not select thread %d", mid);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return mid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Do this in gdb after doing FORK but before STARTUP_INFERIOR.
// OBSOLETE  * Note that the registers are not yet valid in the inferior task.
// OBSOLETE  */
// OBSOLETE static int
// OBSOLETE m3_trace_him (int pid)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   push_target (&m3_ops);
// OBSOLETE 
// OBSOLETE   inferior_task = task_by_pid (pid);
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (inferior_task))
// OBSOLETE     error ("Can not map Unix pid %d to Mach task", pid);
// OBSOLETE 
// OBSOLETE   /* Clean up previous notifications and create new ones */
// OBSOLETE   setup_notify_port (1);
// OBSOLETE 
// OBSOLETE   /* When notification appears, the inferior task has died */
// OBSOLETE   request_notify (inferior_task, MACH_NOTIFY_DEAD_NAME, MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   emulator_present = have_emulator_p (inferior_task);
// OBSOLETE 
// OBSOLETE   /* By default, select the first thread,
// OBSOLETE    * If task has no threads, gives a warning
// OBSOLETE    * Does not fetch registers, since they are not yet valid.
// OBSOLETE    */
// OBSOLETE   select_thread (inferior_task, 0, 0);
// OBSOLETE 
// OBSOLETE   inferior_exception_port = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE   setup_exception_port ();
// OBSOLETE 
// OBSOLETE   xx_debug ("Now the debugged task is created\n");
// OBSOLETE 
// OBSOLETE   /* One trap to exec the shell, one to exec the program being debugged.  */
// OBSOLETE   intercept_exec_calls (2);
// OBSOLETE 
// OBSOLETE   return pid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE setup_exception_port (void)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    &inferior_exception_port);
// OBSOLETE   CHK ("mach_port_allocate", ret);
// OBSOLETE 
// OBSOLETE   /* add send right */
// OBSOLETE   ret = mach_port_insert_right (mach_task_self (),
// OBSOLETE 				inferior_exception_port,
// OBSOLETE 				inferior_exception_port,
// OBSOLETE 				MACH_MSG_TYPE_MAKE_SEND);
// OBSOLETE   CHK ("mach_port_insert_right", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 			       inferior_exception_port,
// OBSOLETE 			       inferior_wait_port_set);
// OBSOLETE   CHK ("mach_port_move_member", ret);
// OBSOLETE 
// OBSOLETE   ret = task_get_special_port (inferior_task,
// OBSOLETE 			       TASK_EXCEPTION_PORT,
// OBSOLETE 			       &inferior_old_exception_port);
// OBSOLETE   CHK ("task_get_special_port(old exc)", ret);
// OBSOLETE 
// OBSOLETE   ret = task_set_special_port (inferior_task,
// OBSOLETE 			       TASK_EXCEPTION_PORT,
// OBSOLETE 			       inferior_exception_port);
// OBSOLETE   CHK ("task_set_special_port", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_deallocate (mach_task_self (),
// OBSOLETE 			      inferior_exception_port);
// OBSOLETE   CHK ("mack_port_deallocate", ret);
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE   /* When notify appears, the inferior_task's exception
// OBSOLETE    * port has been destroyed.
// OBSOLETE    *
// OBSOLETE    * Not used, since the dead_name_notification already
// OBSOLETE    * appears when task dies.
// OBSOLETE    *
// OBSOLETE    */
// OBSOLETE   request_notify (inferior_exception_port,
// OBSOLETE 		  MACH_NOTIFY_NO_SENDERS,
// OBSOLETE 		  MACH_TYPE_EXCEPTION_PORT);
// OBSOLETE #endif
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Nonzero if gdb is waiting for a message */
// OBSOLETE int mach_really_waiting;
// OBSOLETE 
// OBSOLETE /* Wait for the inferior to stop for some reason.
// OBSOLETE    - Loop on notifications until inferior_task dies.
// OBSOLETE    - Loop on exceptions until stopped_in_exception comes true.
// OBSOLETE    (e.g. we receive a single step trace trap)
// OBSOLETE    - a message arrives to gdb's message port
// OBSOLETE 
// OBSOLETE    There is no other way to exit this loop.
// OBSOLETE 
// OBSOLETE    Returns the inferior_ptid for rest of gdb.
// OBSOLETE    Side effects: Set *OURSTATUS.  */
// OBSOLETE ptid_t
// OBSOLETE mach_really_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int w;
// OBSOLETE 
// OBSOLETE   struct msg
// OBSOLETE     {
// OBSOLETE       mach_msg_header_t header;
// OBSOLETE       mach_msg_type_t foo;
// OBSOLETE       int data[8000];
// OBSOLETE     }
// OBSOLETE   in_msg, out_msg;
// OBSOLETE 
// OBSOLETE   /* Either notify (death), exception or message can stop the inferior */
// OBSOLETE   stopped_in_exception = FALSE;
// OBSOLETE 
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       QUIT;
// OBSOLETE 
// OBSOLETE       stop_exception = stop_code = stop_subcode = -1;
// OBSOLETE       stop_thread = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE       mach_really_waiting = 1;
// OBSOLETE       ret = mach_msg (&in_msg.header,	/* header */
// OBSOLETE 		      MACH_RCV_MSG,	/* options */
// OBSOLETE 		      0,	/* send size */
// OBSOLETE 		      sizeof (struct msg),	/* receive size */
// OBSOLETE 		      currently_waiting_for,	/* receive name */
// OBSOLETE 		      MACH_MSG_TIMEOUT_NONE,
// OBSOLETE 		      MACH_PORT_NULL);
// OBSOLETE       mach_really_waiting = 0;
// OBSOLETE       CHK ("mach_msg (receive)", ret);
// OBSOLETE 
// OBSOLETE       /* Check if we received a notify of the childs' death */
// OBSOLETE       if (notify_server (&in_msg.header, &out_msg.header))
// OBSOLETE 	{
// OBSOLETE 	  /* If inferior_task is null then the inferior has
// OBSOLETE 	     gone away and we want to return to command level.
// OBSOLETE 	     Otherwise it was just an informative message and we
// OBSOLETE 	     need to look to see if there are any more. */
// OBSOLETE 	  if (inferior_task != MACH_PORT_NULL)
// OBSOLETE 	    continue;
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      /* Collect Unix exit status for gdb */
// OBSOLETE 
// OBSOLETE 	      wait3 (&w, WNOHANG, 0);
// OBSOLETE 
// OBSOLETE 	      /* This mess is here to check that the rest of
// OBSOLETE 	       * gdb knows that the inferior died. It also
// OBSOLETE 	       * tries to hack around the fact that Mach 3.0 (mk69)
// OBSOLETE 	       * unix server (ux28) does not always know what
// OBSOLETE 	       * has happened to it's children when mach-magic
// OBSOLETE 	       * is applied on them.
// OBSOLETE 	       */
// OBSOLETE 	      if ((!WIFEXITED (w) && WIFSTOPPED (w)) ||
// OBSOLETE 		  (WIFEXITED (w) && WEXITSTATUS (w) > 0377))
// OBSOLETE 		{
// OBSOLETE 		  WSETEXIT (w, 0);
// OBSOLETE 		  warning ("Using exit value 0 for terminated task");
// OBSOLETE 		}
// OBSOLETE 	      else if (!WIFEXITED (w))
// OBSOLETE 		{
// OBSOLETE 		  int sig = WTERMSIG (w);
// OBSOLETE 
// OBSOLETE 		  /* Signals cause problems. Warn the user. */
// OBSOLETE 		  if (sig != SIGKILL)	/* Bad luck if garbage matches this */
// OBSOLETE 		    warning ("The terminating signal stuff may be nonsense");
// OBSOLETE 		  else if (sig > NSIG)
// OBSOLETE 		    {
// OBSOLETE 		      WSETEXIT (w, 0);
// OBSOLETE 		      warning ("Using exit value 0 for terminated task");
// OBSOLETE 		    }
// OBSOLETE 		}
// OBSOLETE 	      store_waitstatus (ourstatus, w);
// OBSOLETE 	      return inferior_ptid;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Hmm. Check for exception, as it was not a notification.
// OBSOLETE          exc_server() does an upcall to catch_exception_raise()
// OBSOLETE          if this rpc is an exception. Further actions are decided
// OBSOLETE          there.
// OBSOLETE        */
// OBSOLETE       if (!exc_server (&in_msg.header, &out_msg.header))
// OBSOLETE 	{
// OBSOLETE 
// OBSOLETE 	  /* Not an exception, check for message.
// OBSOLETE 
// OBSOLETE 	   * Messages don't come from the inferior, or if they
// OBSOLETE 	   * do they better be asynchronous or it will hang.
// OBSOLETE 	   */
// OBSOLETE 	  if (gdb_message_server (&in_msg.header))
// OBSOLETE 	    continue;
// OBSOLETE 
// OBSOLETE 	  error ("Unrecognized message received in mach_really_wait");
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Send the reply of the exception rpc to the suspended task */
// OBSOLETE       ret = mach_msg_send (&out_msg.header);
// OBSOLETE       CHK ("mach_msg_send (exc reply)", ret);
// OBSOLETE 
// OBSOLETE       if (stopped_in_exception)
// OBSOLETE 	{
// OBSOLETE 	  /* Get unix state. May be changed in mach3_exception_actions() */
// OBSOLETE 	  wait3 (&w, WNOHANG, 0);
// OBSOLETE 
// OBSOLETE 	  mach3_exception_actions (&w, FALSE, "Task");
// OBSOLETE 
// OBSOLETE 	  store_waitstatus (ourstatus, w);
// OBSOLETE 	  return inferior_ptid;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Called by macro DO_QUIT() in utils.c(quit).
// OBSOLETE  * This is called just before calling error() to return to command level
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE mach3_quit (void)
// OBSOLETE {
// OBSOLETE   int mid;
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (mach_really_waiting)
// OBSOLETE     {
// OBSOLETE       ret = task_suspend (inferior_task);
// OBSOLETE 
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	{
// OBSOLETE 	  warning ("Could not suspend task for interrupt: %s",
// OBSOLETE 		   mach_error_string (ret));
// OBSOLETE 	  mach_really_waiting = 0;
// OBSOLETE 	  return;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   must_suspend_thread = 0;
// OBSOLETE   mach_really_waiting = 0;
// OBSOLETE 
// OBSOLETE   mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
// OBSOLETE   if (mid == -1)
// OBSOLETE     {
// OBSOLETE       warning ("Selecting first existing kernel thread");
// OBSOLETE       mid = 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   current_thread = MACH_PORT_NULL;	/* Force setup */
// OBSOLETE   select_thread (inferior_task, mid, 1);
// OBSOLETE 
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE /* bogus bogus bogus.  It is NOT OK to quit out of target_wait.  */
// OBSOLETE 
// OBSOLETE /* If ^C is typed when we are waiting for a message
// OBSOLETE  * and your Unix server is able to notice that we 
// OBSOLETE  * should quit now.
// OBSOLETE  *
// OBSOLETE  * Called by REQUEST_QUIT() from utils.c(request_quit)
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE mach3_request_quit (void)
// OBSOLETE {
// OBSOLETE   if (mach_really_waiting)
// OBSOLETE     immediate_quit = 1;
// OBSOLETE }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Gdb message server.
// OBSOLETE  * Currently implemented is the STOP message, that causes
// OBSOLETE  * gdb to return to the command level like ^C had been typed from terminal.
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE gdb_message_server (mach_msg_header_t *InP)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int mid;
// OBSOLETE 
// OBSOLETE   if (InP->msgh_local_port == our_message_port)
// OBSOLETE     {
// OBSOLETE       /* A message coming to our_message_port. Check validity */
// OBSOLETE       switch (InP->msgh_id)
// OBSOLETE 	{
// OBSOLETE 
// OBSOLETE 	case GDB_MESSAGE_ID_STOP:
// OBSOLETE 	  ret = task_suspend (inferior_task);
// OBSOLETE 	  if (ret != KERN_SUCCESS)
// OBSOLETE 	    warning ("Could not suspend task for stop message: %s",
// OBSOLETE 		     mach_error_string (ret));
// OBSOLETE 
// OBSOLETE 	  /* QUIT in mach_really_wait() loop. */
// OBSOLETE 	  request_quit (0);
// OBSOLETE 	  break;
// OBSOLETE 
// OBSOLETE 	default:
// OBSOLETE 	  warning ("Invalid message id %d received, ignored.",
// OBSOLETE 		   InP->msgh_id);
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Message not handled by this server */
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* NOTE: This is not an RPC call. It is a simpleroutine.
// OBSOLETE 
// OBSOLETE  * This is not called from this gdb code.
// OBSOLETE  *
// OBSOLETE  * It may be called by another debugger to cause this
// OBSOLETE  * debugger to enter command level:
// OBSOLETE  *
// OBSOLETE  *            (gdb) set stop_inferior_gdb ()
// OBSOLETE  *            (gdb) continue
// OBSOLETE  *
// OBSOLETE  * External program "stop-gdb" implements this also.
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE stop_inferior_gdb (void)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   /* Code generated by mig, with minor cleanups :-)
// OBSOLETE 
// OBSOLETE    * simpleroutine stop_inferior_gdb (our_message_port : mach_port_t);
// OBSOLETE    */
// OBSOLETE 
// OBSOLETE   typedef struct
// OBSOLETE     {
// OBSOLETE       mach_msg_header_t Head;
// OBSOLETE     }
// OBSOLETE   Request;
// OBSOLETE 
// OBSOLETE   Request Mess;
// OBSOLETE 
// OBSOLETE   register Request *InP = &Mess;
// OBSOLETE 
// OBSOLETE   InP->Head.msgh_bits = MACH_MSGH_BITS (MACH_MSG_TYPE_COPY_SEND, 0);
// OBSOLETE 
// OBSOLETE   /* msgh_size passed as argument */
// OBSOLETE   InP->Head.msgh_remote_port = our_message_port;
// OBSOLETE   InP->Head.msgh_local_port = MACH_PORT_NULL;
// OBSOLETE   InP->Head.msgh_seqno = 0;
// OBSOLETE   InP->Head.msgh_id = GDB_MESSAGE_ID_STOP;
// OBSOLETE 
// OBSOLETE   ret = mach_msg (&InP->Head,
// OBSOLETE 		  MACH_SEND_MSG | MACH_MSG_OPTION_NONE,
// OBSOLETE 		  sizeof (Request),
// OBSOLETE 		  0,
// OBSOLETE 		  MACH_PORT_NULL,
// OBSOLETE 		  MACH_MSG_TIMEOUT_NONE,
// OBSOLETE 		  MACH_PORT_NULL);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef THREAD_ALLOWED_TO_BREAK
// OBSOLETE /*
// OBSOLETE  * Return 1 if the MID specifies the thread that caused the
// OBSOLETE  * last exception.
// OBSOLETE  *  Since catch_exception_raise() selects the thread causing
// OBSOLETE  * the last exception to current_thread, we just check that
// OBSOLETE  * it is selected and the last exception was a breakpoint.
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE mach_thread_for_breakpoint (int mid)
// OBSOLETE {
// OBSOLETE   int cmid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE   if (mid < 0)
// OBSOLETE     {
// OBSOLETE       mid = map_slot_to_mid (-(mid + 1), 0, 0);
// OBSOLETE       if (mid < 0)
// OBSOLETE 	return 0;		/* Don't stop, no such slot */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!mid || cmid == -1)
// OBSOLETE     return 1;			/* stop */
// OBSOLETE 
// OBSOLETE   return cmid == mid && stop_exception == EXC_BREAKPOINT;
// OBSOLETE }
// OBSOLETE #endif /* THREAD_ALLOWED_TO_BREAK */
// OBSOLETE 
// OBSOLETE #ifdef THREAD_PARSE_ID
// OBSOLETE /*
// OBSOLETE  * Map a thread id string (MID or a @@SLOTNUMBER)
// OBSOLETE  * to a thread-id.
// OBSOLETE  *
// OBSOLETE  *   0  matches all threads.
// OBSOLETE  *   Otherwise the meaning is defined only in this file.
// OBSOLETE  *   (mach_thread_for_breakpoint uses it)
// OBSOLETE  *
// OBSOLETE  * @@@@ This allows non-existent MIDs to be specified.
// OBSOLETE  *    It now also allows non-existent slots to be
// OBSOLETE  *    specified. (Slot numbers stored are negative,
// OBSOLETE  *    and the magnitude is one greater than the actual
// OBSOLETE  *    slot index. (Since 0 is reserved))
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE mach_thread_parse_id (char *arg)
// OBSOLETE {
// OBSOLETE   int mid;
// OBSOLETE   if (arg == 0)
// OBSOLETE     error ("thread id expected");
// OBSOLETE   mid = parse_thread_id (arg, 0, 1);
// OBSOLETE 
// OBSOLETE   return mid;
// OBSOLETE }
// OBSOLETE #endif /* THREAD_PARSE_ID */
// OBSOLETE 
// OBSOLETE #ifdef THREAD_OUTPUT_ID
// OBSOLETE char *
// OBSOLETE mach_thread_output_id (int mid)
// OBSOLETE {
// OBSOLETE   static char foobar[20];
// OBSOLETE 
// OBSOLETE   if (mid > 0)
// OBSOLETE     sprintf (foobar, "mid %d", mid);
// OBSOLETE   else if (mid < 0)
// OBSOLETE     sprintf (foobar, "@@%d", -(mid + 1));
// OBSOLETE   else
// OBSOLETE     sprintf (foobar, "*any thread*");
// OBSOLETE 
// OBSOLETE   return foobar;
// OBSOLETE }
// OBSOLETE #endif /* THREAD_OUTPUT_ID */
// OBSOLETE 
// OBSOLETE /* Called with hook PREPARE_TO_PROCEED() from infrun.c.
// OBSOLETE 
// OBSOLETE  * If we have switched threads and stopped at breakpoint return 1 otherwise 0.
// OBSOLETE  *
// OBSOLETE  *  if SELECT_IT is nonzero, reselect the thread that was active when
// OBSOLETE  *  we stopped at a breakpoint.
// OBSOLETE  *
// OBSOLETE  * Note that this implementation is potentially redundant now that
// OBSOLETE  * default_prepare_to_proceed() has been added.  
// OBSOLETE  *
// OBSOLETE  * FIXME This may not support switching threads after Ctrl-C
// OBSOLETE  * correctly. The default implementation does support this.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE mach3_prepare_to_proceed (int select_it)
// OBSOLETE {
// OBSOLETE   if (stop_thread &&
// OBSOLETE       stop_thread != current_thread &&
// OBSOLETE       stop_exception == EXC_BREAKPOINT)
// OBSOLETE     {
// OBSOLETE       int mid;
// OBSOLETE 
// OBSOLETE       if (!select_it)
// OBSOLETE 	return 1;
// OBSOLETE 
// OBSOLETE       mid = switch_to_thread (stop_thread);
// OBSOLETE 
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* this stuff here is an upcall via libmach/excServer.c 
// OBSOLETE    and mach_really_wait which does the actual upcall.
// OBSOLETE 
// OBSOLETE    The code will pass the exception to the inferior if:
// OBSOLETE 
// OBSOLETE    - The task that signaled is not the inferior task
// OBSOLETE    (e.g. when debugging another debugger)
// OBSOLETE 
// OBSOLETE    - The user has explicitely requested to pass on the exceptions.
// OBSOLETE    (e.g to the default unix exception handler, which maps
// OBSOLETE    exceptions to signals, or the user has her own exception handler)
// OBSOLETE 
// OBSOLETE    - If the thread that signaled is being single-stepped and it
// OBSOLETE    has set it's own exception port and the exception is not
// OBSOLETE    EXC_BREAKPOINT. (Maybe this is not desirable?)
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE catch_exception_raise (mach_port_t port, thread_t thread, task_t task,
// OBSOLETE 		       int exception, int code, int subcode)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   boolean_t signal_thread;
// OBSOLETE   int mid = map_port_name_to_mid (thread, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (thread))
// OBSOLETE     {
// OBSOLETE       /* If the exception was sent and thread dies before we
// OBSOLETE          receive it, THREAD will be MACH_PORT_DEAD
// OBSOLETE        */
// OBSOLETE 
// OBSOLETE       current_thread = thread = MACH_PORT_NULL;
// OBSOLETE       error ("Received exception from nonexistent thread");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Check if the task died in transit.
// OBSOLETE    * @@@@ Isn't the thread also invalid in such case?
// OBSOLETE    */
// OBSOLETE   if (!MACH_PORT_VALID (task))
// OBSOLETE     {
// OBSOLETE       current_thread = thread = MACH_PORT_NULL;
// OBSOLETE       error ("Received exception from nonexistent task");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (exception < 0 || exception > MAX_EXCEPTION)
// OBSOLETE     internal_error (__FILE__, __LINE__,
// OBSOLETE 		    "catch_exception_raise: unknown exception code %d thread %d",
// OBSOLETE 		    exception,
// OBSOLETE 		    mid);
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (inferior_task))
// OBSOLETE     error ("got an exception, but inferior_task is null or dead");
// OBSOLETE 
// OBSOLETE   stop_exception = exception;
// OBSOLETE   stop_code = code;
// OBSOLETE   stop_subcode = subcode;
// OBSOLETE   stop_thread = thread;
// OBSOLETE 
// OBSOLETE   signal_thread = exception != EXC_BREAKPOINT &&
// OBSOLETE     port == singlestepped_thread_port &&
// OBSOLETE     MACH_PORT_VALID (thread_saved_exception_port);
// OBSOLETE 
// OBSOLETE   /* If it was not our inferior or if we want to forward
// OBSOLETE    * the exception to the inferior's handler, do it here
// OBSOLETE    *
// OBSOLETE    * Note: If you have forwarded EXC_BREAKPOINT I trust you know why.
// OBSOLETE    */
// OBSOLETE   if (task != inferior_task ||
// OBSOLETE       signal_thread ||
// OBSOLETE       exception_map[exception].forward)
// OBSOLETE     {
// OBSOLETE       mach_port_t eport = inferior_old_exception_port;
// OBSOLETE 
// OBSOLETE       if (signal_thread)
// OBSOLETE 	{
// OBSOLETE 	  /*
// OBSOLETE 	     GDB now forwards the exeption to thread's original handler,
// OBSOLETE 	     since the user propably knows what he is doing.
// OBSOLETE 	     Give a message, though.
// OBSOLETE 	   */
// OBSOLETE 
// OBSOLETE 	  mach3_exception_actions ((WAITTYPE *) NULL, TRUE, "Thread");
// OBSOLETE 	  eport = thread_saved_exception_port;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Send the exception to the original handler */
// OBSOLETE       ret = exception_raise (eport,
// OBSOLETE 			     thread,
// OBSOLETE 			     task,
// OBSOLETE 			     exception,
// OBSOLETE 			     code,
// OBSOLETE 			     subcode);
// OBSOLETE 
// OBSOLETE       (void) mach_port_deallocate (mach_task_self (), task);
// OBSOLETE       (void) mach_port_deallocate (mach_task_self (), thread);
// OBSOLETE 
// OBSOLETE       /* If we come here, we don't want to trace any more, since we
// OBSOLETE        * will never stop for tracing anyway.
// OBSOLETE        */
// OBSOLETE       discard_single_step (thread);
// OBSOLETE 
// OBSOLETE       /* Do not stop the inferior */
// OBSOLETE       return ret;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Now gdb handles the exception */
// OBSOLETE   stopped_in_exception = TRUE;
// OBSOLETE 
// OBSOLETE   ret = task_suspend (task);
// OBSOLETE   CHK ("Error suspending inferior after exception", ret);
// OBSOLETE 
// OBSOLETE   must_suspend_thread = 0;
// OBSOLETE 
// OBSOLETE   if (current_thread != thread)
// OBSOLETE     {
// OBSOLETE       if (MACH_PORT_VALID (singlestepped_thread_port))
// OBSOLETE 	/* Cleanup discards single stepping */
// OBSOLETE 	error ("Exception from thread %d while singlestepping thread %d",
// OBSOLETE 	       mid,
// OBSOLETE 	       map_port_name_to_mid (current_thread, MACH_TYPE_THREAD));
// OBSOLETE 
// OBSOLETE       /* Then select the thread that caused the exception */
// OBSOLETE       if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
// OBSOLETE 	error ("Could not select thread %d causing exception", mid);
// OBSOLETE       else
// OBSOLETE 	warning ("Gdb selected thread %d", mid);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* If we receive an exception that is not breakpoint
// OBSOLETE    * exception, we interrupt the single step and return to
// OBSOLETE    * debugger. Trace condition is cleared.
// OBSOLETE    */
// OBSOLETE   if (MACH_PORT_VALID (singlestepped_thread_port))
// OBSOLETE     {
// OBSOLETE       if (stop_exception != EXC_BREAKPOINT)
// OBSOLETE 	warning ("Single step interrupted by exception");
// OBSOLETE       else if (port == singlestepped_thread_port)
// OBSOLETE 	{
// OBSOLETE 	  /* Single step exception occurred, remove trace bit
// OBSOLETE 	   * and return to gdb.
// OBSOLETE 	   */
// OBSOLETE 	  if (!MACH_PORT_VALID (current_thread))
// OBSOLETE 	    error ("Single stepped thread is not valid");
// OBSOLETE 
// OBSOLETE 	  /* Resume threads, but leave the task suspended */
// OBSOLETE 	  resume_all_threads (0);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	warning ("Breakpoint while single stepping?");
// OBSOLETE 
// OBSOLETE       discard_single_step (current_thread);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   (void) mach_port_deallocate (mach_task_self (), task);
// OBSOLETE   (void) mach_port_deallocate (mach_task_self (), thread);
// OBSOLETE 
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE port_valid (mach_port_t port, int mask)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   mach_port_type_t type;
// OBSOLETE 
// OBSOLETE   ret = mach_port_type (mach_task_self (),
// OBSOLETE 			port,
// OBSOLETE 			&type);
// OBSOLETE   if (ret != KERN_SUCCESS || (type & mask) != mask)
// OBSOLETE     return 0;
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* @@@@ No vm read cache implemented yet */
// OBSOLETE boolean_t vm_read_cache_valid = FALSE;
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Read inferior task's LEN bytes from ADDR and copy it to MYADDR
// OBSOLETE  * in gdb's address space.
// OBSOLETE  *
// OBSOLETE  * Return 0 on failure; number of bytes read otherwise.
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE mach3_read_inferior (CORE_ADDR addr, char *myaddr, int length)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   vm_address_t low_address = (vm_address_t) trunc_page (addr);
// OBSOLETE   vm_size_t aligned_length =
// OBSOLETE   (vm_size_t) round_page (addr + length) - low_address;
// OBSOLETE   pointer_t copied_memory;
// OBSOLETE   int copy_count;
// OBSOLETE 
// OBSOLETE   /* Get memory from inferior with page aligned addresses */
// OBSOLETE   ret = vm_read (inferior_task,
// OBSOLETE 		 low_address,
// OBSOLETE 		 aligned_length,
// OBSOLETE 		 &copied_memory,
// OBSOLETE 		 &copy_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       /* the problem is that the inferior might be killed for whatever reason
// OBSOLETE        * before we go to mach_really_wait. This is one place that ought to
// OBSOLETE        * catch many of those errors.
// OBSOLETE        * @@@@ A better fix would be to make all external events to GDB
// OBSOLETE        * to arrive via a SINGLE port set. (Including user input!)
// OBSOLETE        */
// OBSOLETE 
// OBSOLETE       if (!port_valid (inferior_task, MACH_PORT_TYPE_SEND))
// OBSOLETE 	{
// OBSOLETE 	  m3_kill_inferior ();
// OBSOLETE 	  error ("Inferior killed (task port invalid)");
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE #ifdef OSF
// OBSOLETE 	  extern int errno;
// OBSOLETE 	  /* valprint.c gives nicer format if this does not
// OBSOLETE 	     screw it. Eamonn seems to like this, so I enable
// OBSOLETE 	     it if OSF is defined...
// OBSOLETE 	   */
// OBSOLETE 	  warning ("[read inferior %x failed: %s]",
// OBSOLETE 		   addr, mach_error_string (ret));
// OBSOLETE 	  errno = 0;
// OBSOLETE #endif
// OBSOLETE 	  return 0;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   memcpy (myaddr, (char *) addr - low_address + copied_memory, length);
// OBSOLETE 
// OBSOLETE   ret = vm_deallocate (mach_task_self (),
// OBSOLETE 		       copied_memory,
// OBSOLETE 		       copy_count);
// OBSOLETE   CHK ("mach3_read_inferior vm_deallocate failed", ret);
// OBSOLETE 
// OBSOLETE   return length;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #define CHK_GOTO_OUT(str,ret) \
// OBSOLETE   do if (ret != KERN_SUCCESS) { errstr = #str; goto out; } while(0)
// OBSOLETE 
// OBSOLETE struct vm_region_list
// OBSOLETE {
// OBSOLETE   struct vm_region_list *next;
// OBSOLETE   vm_prot_t protection;
// OBSOLETE   vm_address_t start;
// OBSOLETE   vm_size_t length;
// OBSOLETE };
// OBSOLETE 
// OBSOLETE struct obstack region_obstack;
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Write inferior task's LEN bytes from ADDR and copy it to MYADDR
// OBSOLETE  * in gdb's address space.
// OBSOLETE  */
// OBSOLETE int
// OBSOLETE mach3_write_inferior (CORE_ADDR addr, char *myaddr, int length)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   vm_address_t low_address = (vm_address_t) trunc_page (addr);
// OBSOLETE   vm_size_t aligned_length =
// OBSOLETE   (vm_size_t) round_page (addr + length) - low_address;
// OBSOLETE   pointer_t copied_memory;
// OBSOLETE   int copy_count;
// OBSOLETE   int deallocate = 0;
// OBSOLETE 
// OBSOLETE   char *errstr = "Bug in mach3_write_inferior";
// OBSOLETE 
// OBSOLETE   struct vm_region_list *region_element;
// OBSOLETE   struct vm_region_list *region_head = (struct vm_region_list *) NULL;
// OBSOLETE 
// OBSOLETE   /* Get memory from inferior with page aligned addresses */
// OBSOLETE   ret = vm_read (inferior_task,
// OBSOLETE 		 low_address,
// OBSOLETE 		 aligned_length,
// OBSOLETE 		 &copied_memory,
// OBSOLETE 		 &copy_count);
// OBSOLETE   CHK_GOTO_OUT ("mach3_write_inferior vm_read failed", ret);
// OBSOLETE 
// OBSOLETE   deallocate++;
// OBSOLETE 
// OBSOLETE   memcpy ((char *) addr - low_address + copied_memory, myaddr, length);
// OBSOLETE 
// OBSOLETE   obstack_init (&region_obstack);
// OBSOLETE 
// OBSOLETE   /* Do writes atomically.
// OBSOLETE    * First check for holes and unwritable memory.
// OBSOLETE    */
// OBSOLETE   {
// OBSOLETE     vm_size_t remaining_length = aligned_length;
// OBSOLETE     vm_address_t region_address = low_address;
// OBSOLETE 
// OBSOLETE     struct vm_region_list *scan;
// OBSOLETE 
// OBSOLETE     while (region_address < low_address + aligned_length)
// OBSOLETE       {
// OBSOLETE 	vm_prot_t protection;
// OBSOLETE 	vm_prot_t max_protection;
// OBSOLETE 	vm_inherit_t inheritance;
// OBSOLETE 	boolean_t shared;
// OBSOLETE 	mach_port_t object_name;
// OBSOLETE 	vm_offset_t offset;
// OBSOLETE 	vm_size_t region_length = remaining_length;
// OBSOLETE 	vm_address_t old_address = region_address;
// OBSOLETE 
// OBSOLETE 	ret = vm_region (inferior_task,
// OBSOLETE 			 &region_address,
// OBSOLETE 			 &region_length,
// OBSOLETE 			 &protection,
// OBSOLETE 			 &max_protection,
// OBSOLETE 			 &inheritance,
// OBSOLETE 			 &shared,
// OBSOLETE 			 &object_name,
// OBSOLETE 			 &offset);
// OBSOLETE 	CHK_GOTO_OUT ("vm_region failed", ret);
// OBSOLETE 
// OBSOLETE 	/* Check for holes in memory */
// OBSOLETE 	if (old_address != region_address)
// OBSOLETE 	  {
// OBSOLETE 	    warning ("No memory at 0x%x. Nothing written",
// OBSOLETE 		     old_address);
// OBSOLETE 	    ret = KERN_SUCCESS;
// OBSOLETE 	    length = 0;
// OBSOLETE 	    goto out;
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE 	if (!(max_protection & VM_PROT_WRITE))
// OBSOLETE 	  {
// OBSOLETE 	    warning ("Memory at address 0x%x is unwritable. Nothing written",
// OBSOLETE 		     old_address);
// OBSOLETE 	    ret = KERN_SUCCESS;
// OBSOLETE 	    length = 0;
// OBSOLETE 	    goto out;
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE 	/* Chain the regions for later use */
// OBSOLETE 	region_element =
// OBSOLETE 	  (struct vm_region_list *)
// OBSOLETE 	  obstack_alloc (&region_obstack, sizeof (struct vm_region_list));
// OBSOLETE 
// OBSOLETE 	region_element->protection = protection;
// OBSOLETE 	region_element->start = region_address;
// OBSOLETE 	region_element->length = region_length;
// OBSOLETE 
// OBSOLETE 	/* Chain the regions along with protections */
// OBSOLETE 	region_element->next = region_head;
// OBSOLETE 	region_head = region_element;
// OBSOLETE 
// OBSOLETE 	region_address += region_length;
// OBSOLETE 	remaining_length = remaining_length - region_length;
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE     /* If things fail after this, we give up.
// OBSOLETE      * Somebody is messing up inferior_task's mappings.
// OBSOLETE      */
// OBSOLETE 
// OBSOLETE     /* Enable writes to the chained vm regions */
// OBSOLETE     for (scan = region_head; scan; scan = scan->next)
// OBSOLETE       {
// OBSOLETE 	boolean_t protection_changed = FALSE;
// OBSOLETE 
// OBSOLETE 	if (!(scan->protection & VM_PROT_WRITE))
// OBSOLETE 	  {
// OBSOLETE 	    ret = vm_protect (inferior_task,
// OBSOLETE 			      scan->start,
// OBSOLETE 			      scan->length,
// OBSOLETE 			      FALSE,
// OBSOLETE 			      scan->protection | VM_PROT_WRITE);
// OBSOLETE 	    CHK_GOTO_OUT ("vm_protect: enable write failed", ret);
// OBSOLETE 	  }
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE     ret = vm_write (inferior_task,
// OBSOLETE 		    low_address,
// OBSOLETE 		    copied_memory,
// OBSOLETE 		    aligned_length);
// OBSOLETE     CHK_GOTO_OUT ("vm_write failed", ret);
// OBSOLETE 
// OBSOLETE     /* Set up the original region protections, if they were changed */
// OBSOLETE     for (scan = region_head; scan; scan = scan->next)
// OBSOLETE       {
// OBSOLETE 	boolean_t protection_changed = FALSE;
// OBSOLETE 
// OBSOLETE 	if (!(scan->protection & VM_PROT_WRITE))
// OBSOLETE 	  {
// OBSOLETE 	    ret = vm_protect (inferior_task,
// OBSOLETE 			      scan->start,
// OBSOLETE 			      scan->length,
// OBSOLETE 			      FALSE,
// OBSOLETE 			      scan->protection);
// OBSOLETE 	    CHK_GOTO_OUT ("vm_protect: enable write failed", ret);
// OBSOLETE 	  }
// OBSOLETE       }
// OBSOLETE   }
// OBSOLETE 
// OBSOLETE out:
// OBSOLETE   if (deallocate)
// OBSOLETE     {
// OBSOLETE       obstack_free (&region_obstack, 0);
// OBSOLETE 
// OBSOLETE       (void) vm_deallocate (mach_task_self (),
// OBSOLETE 			    copied_memory,
// OBSOLETE 			    copy_count);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("%s %s", errstr, mach_error_string (ret));
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return length;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return 0 on failure, number of bytes handled otherwise.  TARGET is
// OBSOLETE    ignored. */
// OBSOLETE static int
// OBSOLETE m3_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
// OBSOLETE 		struct target_ops *target)
// OBSOLETE {
// OBSOLETE   int result;
// OBSOLETE 
// OBSOLETE   if (write)
// OBSOLETE     result = mach3_write_inferior (memaddr, myaddr, len);
// OBSOLETE   else
// OBSOLETE     result = mach3_read_inferior (memaddr, myaddr, len);
// OBSOLETE 
// OBSOLETE   return result;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE translate_state (int state)
// OBSOLETE {
// OBSOLETE   switch (state)
// OBSOLETE     {
// OBSOLETE     case TH_STATE_RUNNING:
// OBSOLETE       return ("R");
// OBSOLETE     case TH_STATE_STOPPED:
// OBSOLETE       return ("S");
// OBSOLETE     case TH_STATE_WAITING:
// OBSOLETE       return ("W");
// OBSOLETE     case TH_STATE_UNINTERRUPTIBLE:
// OBSOLETE       return ("U");
// OBSOLETE     case TH_STATE_HALTED:
// OBSOLETE       return ("H");
// OBSOLETE     default:
// OBSOLETE       return ("?");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE translate_cstate (int state)
// OBSOLETE {
// OBSOLETE   switch (state)
// OBSOLETE     {
// OBSOLETE     case CPROC_RUNNING:
// OBSOLETE       return "R";
// OBSOLETE     case CPROC_SWITCHING:
// OBSOLETE       return "S";
// OBSOLETE     case CPROC_BLOCKED:
// OBSOLETE       return "B";
// OBSOLETE     case CPROC_CONDWAIT:
// OBSOLETE       return "C";
// OBSOLETE     case CPROC_CONDWAIT | CPROC_SWITCHING:
// OBSOLETE       return "CS";
// OBSOLETE     default:
// OBSOLETE       return "?";
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* type == MACH_MSG_TYPE_COPY_SEND || type == MACH_MSG_TYPE_MAKE_SEND */
// OBSOLETE 
// OBSOLETE mach_port_t			/* no mach_port_name_t found in include files. */
// OBSOLETE map_inferior_port_name (mach_port_t inferior_name, mach_msg_type_name_t type)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   mach_msg_type_name_t acquired;
// OBSOLETE   mach_port_t iport;
// OBSOLETE 
// OBSOLETE   ret = mach_port_extract_right (inferior_task,
// OBSOLETE 				 inferior_name,
// OBSOLETE 				 type,
// OBSOLETE 				 &iport,
// OBSOLETE 				 &acquired);
// OBSOLETE   CHK ("mach_port_extract_right (map_inferior_port_name)", ret);
// OBSOLETE 
// OBSOLETE   if (acquired != MACH_MSG_TYPE_PORT_SEND)
// OBSOLETE     error ("Incorrect right extracted, (map_inferior_port_name)");
// OBSOLETE 
// OBSOLETE   ret = mach_port_deallocate (mach_task_self (),
// OBSOLETE 			      iport);
// OBSOLETE   CHK ("Deallocating mapped port (map_inferior_port_name)", ret);
// OBSOLETE 
// OBSOLETE   return iport;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Naming convention:
// OBSOLETE  *  Always return user defined name if found.
// OBSOLETE  *  _K == A kernel thread with no matching CPROC
// OBSOLETE  *  _C == A cproc with no current cthread
// OBSOLETE  *  _t == A cthread with no user defined name
// OBSOLETE  *
// OBSOLETE  * The digits that follow the _names are the SLOT number of the
// OBSOLETE  * kernel thread if there is such a thing, otherwise just a negation
// OBSOLETE  * of the sequential number of such cprocs.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static char buf[7];
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE get_thread_name (gdb_thread_t one_cproc, int id)
// OBSOLETE {
// OBSOLETE   if (one_cproc)
// OBSOLETE     if (one_cproc->cthread == NULL)
// OBSOLETE       {
// OBSOLETE 	/* cproc not mapped to any cthread */
// OBSOLETE 	sprintf (buf, "_C%d", id);
// OBSOLETE       }
// OBSOLETE     else if (!one_cproc->cthread->name)
// OBSOLETE       {
// OBSOLETE 	/* cproc and cthread, but no name */
// OBSOLETE 	sprintf (buf, "_t%d", id);
// OBSOLETE       }
// OBSOLETE     else
// OBSOLETE       return (char *) (one_cproc->cthread->name);
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if (id < 0)
// OBSOLETE 	warning ("Inconsistency in thread name id %d", id);
// OBSOLETE 
// OBSOLETE       /* Kernel thread without cproc */
// OBSOLETE       sprintf (buf, "_K%d", id);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return buf;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fetch_thread_info (mach_port_t task, gdb_thread_t *mthreads_out)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_array_t th_table;
// OBSOLETE   int th_count;
// OBSOLETE   gdb_thread_t mthreads = NULL;
// OBSOLETE   int index;
// OBSOLETE 
// OBSOLETE   ret = task_threads (task, &th_table, &th_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("Error getting inferior's thread list:%s",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE       m3_kill_inferior ();
// OBSOLETE       return -1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   mthreads = (gdb_thread_t)
// OBSOLETE     obstack_alloc
// OBSOLETE     (cproc_obstack,
// OBSOLETE      th_count * sizeof (struct gdb_thread));
// OBSOLETE 
// OBSOLETE   for (index = 0; index < th_count; index++)
// OBSOLETE     {
// OBSOLETE       thread_t saved_thread = MACH_PORT_NULL;
// OBSOLETE       int mid;
// OBSOLETE 
// OBSOLETE       if (must_suspend_thread)
// OBSOLETE 	setup_thread (th_table[index], 1);
// OBSOLETE 
// OBSOLETE       if (th_table[index] != current_thread)
// OBSOLETE 	{
// OBSOLETE 	  saved_thread = current_thread;
// OBSOLETE 
// OBSOLETE 	  mid = switch_to_thread (th_table[index]);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       mthreads[index].name = th_table[index];
// OBSOLETE       mthreads[index].cproc = NULL;	/* map_cprocs_to_kernel_threads() */
// OBSOLETE       mthreads[index].in_emulator = FALSE;
// OBSOLETE       mthreads[index].slotid = index;
// OBSOLETE 
// OBSOLETE       mthreads[index].sp = read_register (SP_REGNUM);
// OBSOLETE       mthreads[index].fp = read_register (FP_REGNUM);
// OBSOLETE       mthreads[index].pc = read_pc ();
// OBSOLETE 
// OBSOLETE       if (MACH_PORT_VALID (saved_thread))
// OBSOLETE 	mid = switch_to_thread (saved_thread);
// OBSOLETE 
// OBSOLETE       if (must_suspend_thread)
// OBSOLETE 	setup_thread (th_table[index], 0);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   consume_send_rights (th_table, th_count);
// OBSOLETE   ret = vm_deallocate (mach_task_self (), (vm_address_t) th_table,
// OBSOLETE 		       (th_count * sizeof (mach_port_t)));
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("Error trying to deallocate thread list : %s",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   *mthreads_out = mthreads;
// OBSOLETE 
// OBSOLETE   return th_count;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Current emulator always saves the USP on top of
// OBSOLETE  * emulator stack below struct emul_stack_top stuff.
// OBSOLETE  */
// OBSOLETE CORE_ADDR
// OBSOLETE fetch_usp_from_emulator_stack (CORE_ADDR sp)
// OBSOLETE {
// OBSOLETE   CORE_ADDR stack_pointer;
// OBSOLETE 
// OBSOLETE   sp = (sp & ~(EMULATOR_STACK_SIZE - 1)) +
// OBSOLETE     EMULATOR_STACK_SIZE - sizeof (struct emul_stack_top);
// OBSOLETE 
// OBSOLETE   if (mach3_read_inferior (sp,
// OBSOLETE 			   &stack_pointer,
// OBSOLETE 			   sizeof (CORE_ADDR)) != sizeof (CORE_ADDR))
// OBSOLETE     {
// OBSOLETE       warning ("Can't read user sp from emulator stack address 0x%x", sp);
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return stack_pointer;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef MK67
// OBSOLETE 
// OBSOLETE /* get_emulation_vector() interface was changed after mk67 */
// OBSOLETE #define EMUL_VECTOR_COUNT 400	/* Value does not matter too much */
// OBSOLETE 
// OBSOLETE #endif /* MK67 */
// OBSOLETE 
// OBSOLETE /* Check if the emulator exists at task's address space.
// OBSOLETE  */
// OBSOLETE boolean_t
// OBSOLETE have_emulator_p (task_t task)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE #ifndef EMUL_VECTOR_COUNT
// OBSOLETE   vm_offset_t *emulation_vector;
// OBSOLETE   int n;
// OBSOLETE #else
// OBSOLETE   vm_offset_t emulation_vector[EMUL_VECTOR_COUNT];
// OBSOLETE   int n = EMUL_VECTOR_COUNT;
// OBSOLETE #endif
// OBSOLETE   int i;
// OBSOLETE   int vector_start;
// OBSOLETE 
// OBSOLETE   ret = task_get_emulation_vector (task,
// OBSOLETE 				   &vector_start,
// OBSOLETE #ifndef EMUL_VECTOR_COUNT
// OBSOLETE 				   &emulation_vector,
// OBSOLETE #else
// OBSOLETE 				   emulation_vector,
// OBSOLETE #endif
// OBSOLETE 				   &n);
// OBSOLETE   CHK ("task_get_emulation_vector", ret);
// OBSOLETE   xx_debug ("%d vectors from %d at 0x%08x\n",
// OBSOLETE 	    n, vector_start, emulation_vector);
// OBSOLETE 
// OBSOLETE   for (i = 0; i < n; i++)
// OBSOLETE     {
// OBSOLETE       vm_offset_t entry = emulation_vector[i];
// OBSOLETE 
// OBSOLETE       if (EMULATOR_BASE <= entry && entry <= EMULATOR_END)
// OBSOLETE 	return TRUE;
// OBSOLETE       else if (entry)
// OBSOLETE 	{
// OBSOLETE 	  static boolean_t informed = FALSE;
// OBSOLETE 	  if (!informed)
// OBSOLETE 	    {
// OBSOLETE 	      warning ("Emulation vector address 0x08%x outside emulator space",
// OBSOLETE 		       entry);
// OBSOLETE 	      informed = TRUE;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   return FALSE;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Map cprocs to kernel threads and vice versa.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE map_cprocs_to_kernel_threads (gdb_thread_t cprocs, gdb_thread_t mthreads,
// OBSOLETE 			      int thread_count)
// OBSOLETE {
// OBSOLETE   int index;
// OBSOLETE   gdb_thread_t scan;
// OBSOLETE   boolean_t all_mapped = TRUE;
// OBSOLETE   LONGEST stack_base;
// OBSOLETE   LONGEST stack_size;
// OBSOLETE 
// OBSOLETE   for (scan = cprocs; scan; scan = scan->next)
// OBSOLETE     {
// OBSOLETE       /* Default to: no kernel thread for this cproc */
// OBSOLETE       scan->reverse_map = -1;
// OBSOLETE 
// OBSOLETE       /* Check if the cproc is found by its stack */
// OBSOLETE       for (index = 0; index < thread_count; index++)
// OBSOLETE 	{
// OBSOLETE 	  stack_base =
// OBSOLETE 	    extract_signed_integer (scan->raw_cproc + CPROC_BASE_OFFSET,
// OBSOLETE 				    CPROC_BASE_SIZE);
// OBSOLETE 	  stack_size =
// OBSOLETE 	    extract_signed_integer (scan->raw_cproc + CPROC_SIZE_OFFSET,
// OBSOLETE 				    CPROC_SIZE_SIZE);
// OBSOLETE 	  if ((mthreads + index)->sp > stack_base &&
// OBSOLETE 	      (mthreads + index)->sp <= stack_base + stack_size)
// OBSOLETE 	    {
// OBSOLETE 	      (mthreads + index)->cproc = scan;
// OBSOLETE 	      scan->reverse_map = index;
// OBSOLETE 	      break;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       all_mapped &= (scan->reverse_map != -1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Check for threads that are currently in the emulator.
// OBSOLETE    * If so, they have a different stack, and the still unmapped
// OBSOLETE    * cprocs may well get mapped to these threads.
// OBSOLETE    * 
// OBSOLETE    * If:
// OBSOLETE    *  - cproc stack does not match any kernel thread stack pointer
// OBSOLETE    *  - there is at least one extra kernel thread
// OBSOLETE    *    that has no cproc mapped above.
// OBSOLETE    *  - some kernel thread stack pointer points to emulator space
// OBSOLETE    *  then we find the user stack pointer saved in the emulator
// OBSOLETE    *  stack, and try to map that to the cprocs.
// OBSOLETE    *
// OBSOLETE    * Also set in_emulator for kernel threads.
// OBSOLETE    */
// OBSOLETE 
// OBSOLETE   if (emulator_present)
// OBSOLETE     {
// OBSOLETE       for (index = 0; index < thread_count; index++)
// OBSOLETE 	{
// OBSOLETE 	  CORE_ADDR emul_sp;
// OBSOLETE 	  CORE_ADDR usp;
// OBSOLETE 
// OBSOLETE 	  gdb_thread_t mthread = (mthreads + index);
// OBSOLETE 	  emul_sp = mthread->sp;
// OBSOLETE 
// OBSOLETE 	  if (mthread->cproc == NULL &&
// OBSOLETE 	      EMULATOR_BASE <= emul_sp && emul_sp <= EMULATOR_END)
// OBSOLETE 	    {
// OBSOLETE 	      mthread->in_emulator = emulator_present;
// OBSOLETE 
// OBSOLETE 	      if (!all_mapped && cprocs)
// OBSOLETE 		{
// OBSOLETE 		  usp = fetch_usp_from_emulator_stack (emul_sp);
// OBSOLETE 
// OBSOLETE 		  /* @@@@ Could be more accurate */
// OBSOLETE 		  if (!usp)
// OBSOLETE 		    error ("Zero stack pointer read from emulator?");
// OBSOLETE 
// OBSOLETE 		  /* Try to match this stack pointer to the cprocs that
// OBSOLETE 		   * don't yet have a kernel thread.
// OBSOLETE 		   */
// OBSOLETE 		  for (scan = cprocs; scan; scan = scan->next)
// OBSOLETE 		    {
// OBSOLETE 
// OBSOLETE 		      /* Check is this unmapped CPROC stack contains
// OBSOLETE 		       * the user stack pointer saved in the
// OBSOLETE 		       * emulator.
// OBSOLETE 		       */
// OBSOLETE 		      if (scan->reverse_map == -1)
// OBSOLETE 			{
// OBSOLETE 			  stack_base =
// OBSOLETE 			    extract_signed_integer
// OBSOLETE 			    (scan->raw_cproc + CPROC_BASE_OFFSET,
// OBSOLETE 			     CPROC_BASE_SIZE);
// OBSOLETE 			  stack_size =
// OBSOLETE 			    extract_signed_integer
// OBSOLETE 			    (scan->raw_cproc + CPROC_SIZE_OFFSET,
// OBSOLETE 			     CPROC_SIZE_SIZE);
// OBSOLETE 			  if (usp > stack_base &&
// OBSOLETE 			      usp <= stack_base + stack_size)
// OBSOLETE 			    {
// OBSOLETE 			      mthread->cproc = scan;
// OBSOLETE 			      scan->reverse_map = index;
// OBSOLETE 			      break;
// OBSOLETE 			    }
// OBSOLETE 			}
// OBSOLETE 		    }
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Format of the thread_list command
// OBSOLETE  *
// OBSOLETE  *                   slot mid sel   name  emul ks susp  cstate wired   address
// OBSOLETE  */
// OBSOLETE #define TL_FORMAT "%-2.2s %5d%c %-10.10s %1.1s%s%-5.5s %-2.2s %-5.5s "
// OBSOLETE 
// OBSOLETE #define TL_HEADER "\n@@    MID  Name        KState CState   Where\n"
// OBSOLETE 
// OBSOLETE void
// OBSOLETE print_tl_address (struct ui_file *stream, CORE_ADDR pc)
// OBSOLETE {
// OBSOLETE   if (!lookup_minimal_symbol_by_pc (pc))
// OBSOLETE     fprintf_filtered (stream, local_hex_format (), pc);
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       extern int addressprint;
// OBSOLETE       extern int asm_demangle;
// OBSOLETE 
// OBSOLETE       int store = addressprint;
// OBSOLETE       addressprint = 0;
// OBSOLETE       print_address_symbolic (pc, stream, asm_demangle, "");
// OBSOLETE       addressprint = store;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* For thread names, but also for gdb_message_port external name */
// OBSOLETE #define MAX_NAME_LEN 50
// OBSOLETE 
// OBSOLETE /* Returns the address of variable NAME or 0 if not found */
// OBSOLETE CORE_ADDR
// OBSOLETE lookup_address_of_variable (char *name)
// OBSOLETE {
// OBSOLETE   struct symbol *sym;
// OBSOLETE   CORE_ADDR symaddr = 0;
// OBSOLETE   struct minimal_symbol *msymbol;
// OBSOLETE 
// OBSOLETE   sym = lookup_symbol (name,
// OBSOLETE 		       (struct block *) NULL,
// OBSOLETE 		       VAR_NAMESPACE,
// OBSOLETE 		       (int *) NULL,
// OBSOLETE 		       (struct symtab **) NULL);
// OBSOLETE 
// OBSOLETE   if (sym)
// OBSOLETE     symaddr = SYMBOL_VALUE (sym);
// OBSOLETE 
// OBSOLETE   if (!symaddr)
// OBSOLETE     {
// OBSOLETE       msymbol = lookup_minimal_symbol (name, NULL, NULL);
// OBSOLETE 
// OBSOLETE       if (msymbol && msymbol->type == mst_data)
// OBSOLETE 	symaddr = SYMBOL_VALUE_ADDRESS (msymbol);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return symaddr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static gdb_thread_t
// OBSOLETE get_cprocs (void)
// OBSOLETE {
// OBSOLETE   gdb_thread_t cproc_head;
// OBSOLETE   gdb_thread_t cproc_copy;
// OBSOLETE   CORE_ADDR their_cprocs;
// OBSOLETE   char *buf;
// OBSOLETE   char *name;
// OBSOLETE   cthread_t cthread;
// OBSOLETE   CORE_ADDR symaddr;
// OBSOLETE 
// OBSOLETE   buf = alloca (TARGET_PTR_BIT / HOST_CHAR_BIT);
// OBSOLETE   symaddr = lookup_address_of_variable ("cproc_list");
// OBSOLETE 
// OBSOLETE   if (!symaddr)
// OBSOLETE     {
// OBSOLETE       /* cproc_list is not in a file compiled with debugging
// OBSOLETE          symbols, but don't give up yet */
// OBSOLETE 
// OBSOLETE       symaddr = lookup_address_of_variable ("cprocs");
// OBSOLETE 
// OBSOLETE       if (symaddr)
// OBSOLETE 	{
// OBSOLETE 	  static int informed = 0;
// OBSOLETE 	  if (!informed)
// OBSOLETE 	    {
// OBSOLETE 	      informed++;
// OBSOLETE 	      warning ("Your program is loaded with an old threads library.");
// OBSOLETE 	      warning ("GDB does not know the old form of threads");
// OBSOLETE 	      warning ("so things may not work.");
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Stripped or no -lthreads loaded or "cproc_list" is in wrong segment. */
// OBSOLETE   if (!symaddr)
// OBSOLETE     return NULL;
// OBSOLETE 
// OBSOLETE   /* Get the address of the first cproc in the task */
// OBSOLETE   if (!mach3_read_inferior (symaddr,
// OBSOLETE 			    buf,
// OBSOLETE 			    TARGET_PTR_BIT / HOST_CHAR_BIT))
// OBSOLETE     error ("Can't read cproc master list at address (0x%x).", symaddr);
// OBSOLETE   their_cprocs = extract_address (buf, TARGET_PTR_BIT / HOST_CHAR_BIT);
// OBSOLETE 
// OBSOLETE   /* Scan the CPROCs in the task.
// OBSOLETE      CPROCs are chained with LIST field, not NEXT field, which
// OBSOLETE      chains mutexes, condition variables and queues */
// OBSOLETE 
// OBSOLETE   cproc_head = NULL;
// OBSOLETE 
// OBSOLETE   while (their_cprocs != (CORE_ADDR) 0)
// OBSOLETE     {
// OBSOLETE       CORE_ADDR cproc_copy_incarnation;
// OBSOLETE       cproc_copy = (gdb_thread_t) obstack_alloc (cproc_obstack,
// OBSOLETE 						 sizeof (struct gdb_thread));
// OBSOLETE 
// OBSOLETE       if (!mach3_read_inferior (their_cprocs,
// OBSOLETE 				&cproc_copy->raw_cproc[0],
// OBSOLETE 				CPROC_SIZE))
// OBSOLETE 	error ("Can't read next cproc at 0x%x.", their_cprocs);
// OBSOLETE 
// OBSOLETE       their_cprocs =
// OBSOLETE 	extract_address (cproc_copy->raw_cproc + CPROC_LIST_OFFSET,
// OBSOLETE 			 CPROC_LIST_SIZE);
// OBSOLETE       cproc_copy_incarnation =
// OBSOLETE 	extract_address (cproc_copy->raw_cproc + CPROC_INCARNATION_OFFSET,
// OBSOLETE 			 CPROC_INCARNATION_SIZE);
// OBSOLETE 
// OBSOLETE       if (cproc_copy_incarnation == (CORE_ADDR) 0)
// OBSOLETE 	cproc_copy->cthread = NULL;
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* This CPROC has an attached CTHREAD. Get its name */
// OBSOLETE 	  cthread = (cthread_t) obstack_alloc (cproc_obstack,
// OBSOLETE 					       sizeof (struct cthread));
// OBSOLETE 
// OBSOLETE 	  if (!mach3_read_inferior (cproc_copy_incarnation,
// OBSOLETE 				    cthread,
// OBSOLETE 				    sizeof (struct cthread)))
// OBSOLETE 	      error ("Can't read next thread at 0x%x.",
// OBSOLETE 		     cproc_copy_incarnation);
// OBSOLETE 
// OBSOLETE 	  cproc_copy->cthread = cthread;
// OBSOLETE 
// OBSOLETE 	  if (cthread->name)
// OBSOLETE 	    {
// OBSOLETE 	      name = (char *) obstack_alloc (cproc_obstack, MAX_NAME_LEN);
// OBSOLETE 
// OBSOLETE 	      if (!mach3_read_inferior (cthread->name, name, MAX_NAME_LEN))
// OBSOLETE 		error ("Can't read next thread's name at 0x%x.", cthread->name);
// OBSOLETE 
// OBSOLETE 	      cthread->name = name;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* insert in front */
// OBSOLETE       cproc_copy->next = cproc_head;
// OBSOLETE       cproc_head = cproc_copy;
// OBSOLETE     }
// OBSOLETE   return cproc_head;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifndef FETCH_CPROC_STATE
// OBSOLETE /*
// OBSOLETE  * Check if your machine does not grok the way this routine
// OBSOLETE  * fetches the FP,PC and SP of a cproc that is not
// OBSOLETE  * currently attached to any kernel thread (e.g. its cproc.context
// OBSOLETE  * field points to the place in stack where the context
// OBSOLETE  * is saved).
// OBSOLETE  *
// OBSOLETE  * If it doesn't, define your own routine.
// OBSOLETE  */
// OBSOLETE #define FETCH_CPROC_STATE(mth) mach3_cproc_state (mth)
// OBSOLETE 
// OBSOLETE int
// OBSOLETE mach3_cproc_state (gdb_thread_t mthread)
// OBSOLETE {
// OBSOLETE   int context;
// OBSOLETE 
// OBSOLETE   if (!mthread || !mthread->cproc)
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   context = extract_signed_integer
// OBSOLETE     (mthread->cproc->raw_cproc + CPROC_CONTEXT_OFFSET,
// OBSOLETE      CPROC_CONTEXT_SIZE);
// OBSOLETE   if (context == 0)
// OBSOLETE     return -1;
// OBSOLETE 
// OBSOLETE   mthread->sp = context + MACHINE_CPROC_SP_OFFSET;
// OBSOLETE 
// OBSOLETE   if (mach3_read_inferior (context + MACHINE_CPROC_PC_OFFSET,
// OBSOLETE 			   &mthread->pc,
// OBSOLETE 			   sizeof (CORE_ADDR)) != sizeof (CORE_ADDR))
// OBSOLETE     {
// OBSOLETE       warning ("Can't read cproc pc from inferior");
// OBSOLETE       return -1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (mach3_read_inferior (context + MACHINE_CPROC_FP_OFFSET,
// OBSOLETE 			   &mthread->fp,
// OBSOLETE 			   sizeof (CORE_ADDR)) != sizeof (CORE_ADDR))
// OBSOLETE     {
// OBSOLETE       warning ("Can't read cproc fp from inferior");
// OBSOLETE       return -1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE #endif /* FETCH_CPROC_STATE */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE void
// OBSOLETE thread_list_command (void)
// OBSOLETE {
// OBSOLETE   thread_basic_info_data_t ths;
// OBSOLETE   int thread_count;
// OBSOLETE   gdb_thread_t cprocs;
// OBSOLETE   gdb_thread_t scan;
// OBSOLETE   int index;
// OBSOLETE   char *name;
// OBSOLETE   char selected;
// OBSOLETE   char *wired;
// OBSOLETE   int infoCnt;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   mach_port_t mid_or_port;
// OBSOLETE   gdb_thread_t their_threads;
// OBSOLETE   gdb_thread_t kthread;
// OBSOLETE 
// OBSOLETE   int neworder = 1;
// OBSOLETE 
// OBSOLETE   char *fmt = "There are %d kernel threads in task %d.\n";
// OBSOLETE 
// OBSOLETE   int tmid = map_port_name_to_mid (inferior_task, MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   thread_count = fetch_thread_info (inferior_task,
// OBSOLETE 				    &their_threads);
// OBSOLETE   if (thread_count == -1)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   if (thread_count == 1)
// OBSOLETE     fmt = "There is %d kernel thread in task %d.\n";
// OBSOLETE 
// OBSOLETE   printf_filtered (fmt, thread_count, tmid);
// OBSOLETE 
// OBSOLETE   puts_filtered (TL_HEADER);
// OBSOLETE 
// OBSOLETE   cprocs = get_cprocs ();
// OBSOLETE 
// OBSOLETE   map_cprocs_to_kernel_threads (cprocs, their_threads, thread_count);
// OBSOLETE 
// OBSOLETE   for (scan = cprocs; scan; scan = scan->next)
// OBSOLETE     {
// OBSOLETE       int mid;
// OBSOLETE       char buf[10];
// OBSOLETE       char slot[3];
// OBSOLETE       int cproc_state =
// OBSOLETE       extract_signed_integer
// OBSOLETE       (scan->raw_cproc + CPROC_STATE_OFFSET, CPROC_STATE_SIZE);
// OBSOLETE 
// OBSOLETE       selected = ' ';
// OBSOLETE 
// OBSOLETE       /* a wired cproc? */
// OBSOLETE       wired = (extract_address (scan->raw_cproc + CPROC_WIRED_OFFSET,
// OBSOLETE 				CPROC_WIRED_SIZE)
// OBSOLETE 	       ? "wired" : "");
// OBSOLETE 
// OBSOLETE       if (scan->reverse_map != -1)
// OBSOLETE 	kthread = (their_threads + scan->reverse_map);
// OBSOLETE       else
// OBSOLETE 	kthread = NULL;
// OBSOLETE 
// OBSOLETE       if (kthread)
// OBSOLETE 	{
// OBSOLETE 	  /* These cprocs have a kernel thread */
// OBSOLETE 
// OBSOLETE 	  mid = map_port_name_to_mid (kthread->name, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE 	  infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE 
// OBSOLETE 	  ret = thread_info (kthread->name,
// OBSOLETE 			     THREAD_BASIC_INFO,
// OBSOLETE 			     (thread_info_t) & ths,
// OBSOLETE 			     &infoCnt);
// OBSOLETE 
// OBSOLETE 	  if (ret != KERN_SUCCESS)
// OBSOLETE 	    {
// OBSOLETE 	      warning ("Unable to get basic info on thread %d : %s",
// OBSOLETE 		       mid,
// OBSOLETE 		       mach_error_string (ret));
// OBSOLETE 	      continue;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  /* Who is the first to have more than 100 threads */
// OBSOLETE 	  sprintf (slot, "%d", kthread->slotid % 100);
// OBSOLETE 
// OBSOLETE 	  if (kthread->name == current_thread)
// OBSOLETE 	    selected = '*';
// OBSOLETE 
// OBSOLETE 	  if (ths.suspend_count)
// OBSOLETE 	    sprintf (buf, "%d", ths.suspend_count);
// OBSOLETE 	  else
// OBSOLETE 	    buf[0] = '\000';
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE 	  if (ths.flags & TH_FLAGS_SWAPPED)
// OBSOLETE 	    strcat (buf, "S");
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE 	  if (ths.flags & TH_FLAGS_IDLE)
// OBSOLETE 	    strcat (buf, "I");
// OBSOLETE 
// OBSOLETE 	  printf_filtered (TL_FORMAT,
// OBSOLETE 			   slot,
// OBSOLETE 			   mid,
// OBSOLETE 			   selected,
// OBSOLETE 			   get_thread_name (scan, kthread->slotid),
// OBSOLETE 			   kthread->in_emulator ? "E" : "",
// OBSOLETE 			   translate_state (ths.run_state),
// OBSOLETE 			   buf,
// OBSOLETE 			   translate_cstate (cproc_state),
// OBSOLETE 			   wired);
// OBSOLETE 	  print_tl_address (gdb_stdout, kthread->pc);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* These cprocs don't have a kernel thread.
// OBSOLETE 	   * find out the calling frame with 
// OBSOLETE 	   * FETCH_CPROC_STATE.
// OBSOLETE 	   */
// OBSOLETE 
// OBSOLETE 	  struct gdb_thread state;
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE 	  /* jtv -> emcmanus: why do you want this here? */
// OBSOLETE 	  if (scan->incarnation == NULL)
// OBSOLETE 	    continue;		/* EMcM */
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE 	  printf_filtered (TL_FORMAT,
// OBSOLETE 			   "-",
// OBSOLETE 			   -neworder,	/* Pseudo MID */
// OBSOLETE 			   selected,
// OBSOLETE 			   get_thread_name (scan, -neworder),
// OBSOLETE 			   "",
// OBSOLETE 			   "-",	/* kernel state */
// OBSOLETE 			   "",
// OBSOLETE 			   translate_cstate (cproc_state),
// OBSOLETE 			   "");
// OBSOLETE 	  state.cproc = scan;
// OBSOLETE 
// OBSOLETE 	  if (FETCH_CPROC_STATE (&state) == -1)
// OBSOLETE 	    puts_filtered ("???");
// OBSOLETE 	  else
// OBSOLETE 	    print_tl_address (gdb_stdout, state.pc);
// OBSOLETE 
// OBSOLETE 	  neworder++;
// OBSOLETE 	}
// OBSOLETE       puts_filtered ("\n");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Scan for kernel threads without cprocs */
// OBSOLETE   for (index = 0; index < thread_count; index++)
// OBSOLETE     {
// OBSOLETE       if (!their_threads[index].cproc)
// OBSOLETE 	{
// OBSOLETE 	  int mid;
// OBSOLETE 
// OBSOLETE 	  char buf[10];
// OBSOLETE 	  char slot[3];
// OBSOLETE 
// OBSOLETE 	  mach_port_t name = their_threads[index].name;
// OBSOLETE 
// OBSOLETE 	  mid = map_port_name_to_mid (name, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE 	  infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE 
// OBSOLETE 	  ret = thread_info (name,
// OBSOLETE 			     THREAD_BASIC_INFO,
// OBSOLETE 			     (thread_info_t) & ths,
// OBSOLETE 			     &infoCnt);
// OBSOLETE 
// OBSOLETE 	  if (ret != KERN_SUCCESS)
// OBSOLETE 	    {
// OBSOLETE 	      warning ("Unable to get basic info on thread %d : %s",
// OBSOLETE 		       mid,
// OBSOLETE 		       mach_error_string (ret));
// OBSOLETE 	      continue;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  sprintf (slot, "%d", index % 100);
// OBSOLETE 
// OBSOLETE 	  if (name == current_thread)
// OBSOLETE 	    selected = '*';
// OBSOLETE 	  else
// OBSOLETE 	    selected = ' ';
// OBSOLETE 
// OBSOLETE 	  if (ths.suspend_count)
// OBSOLETE 	    sprintf (buf, "%d", ths.suspend_count);
// OBSOLETE 	  else
// OBSOLETE 	    buf[0] = '\000';
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE 	  if (ths.flags & TH_FLAGS_SWAPPED)
// OBSOLETE 	    strcat (buf, "S");
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE 	  if (ths.flags & TH_FLAGS_IDLE)
// OBSOLETE 	    strcat (buf, "I");
// OBSOLETE 
// OBSOLETE 	  printf_filtered (TL_FORMAT,
// OBSOLETE 			   slot,
// OBSOLETE 			   mid,
// OBSOLETE 			   selected,
// OBSOLETE 			   get_thread_name (NULL, index),
// OBSOLETE 			   their_threads[index].in_emulator ? "E" : "",
// OBSOLETE 			   translate_state (ths.run_state),
// OBSOLETE 			   buf,
// OBSOLETE 			   "",	/* No cproc state */
// OBSOLETE 			   "");	/* Can't be wired */
// OBSOLETE 	  print_tl_address (gdb_stdout, their_threads[index].pc);
// OBSOLETE 	  puts_filtered ("\n");
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   obstack_free (cproc_obstack, 0);
// OBSOLETE   obstack_init (cproc_obstack);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE thread_select_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int mid;
// OBSOLETE   thread_array_t thread_list;
// OBSOLETE   int thread_count;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int is_slot = 0;
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     error_no_arg ("MID or @@SLOTNUMBER to specify a thread to select");
// OBSOLETE 
// OBSOLETE   while (*args == ' ' || *args == '\t')
// OBSOLETE     args++;
// OBSOLETE 
// OBSOLETE   if (*args == '@@')
// OBSOLETE     {
// OBSOLETE       is_slot++;
// OBSOLETE       args++;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   mid = atoi (args);
// OBSOLETE 
// OBSOLETE   if (mid == 0)
// OBSOLETE     if (!is_slot || *args != '0')	/* Rudimentary checks */
// OBSOLETE       error ("You must select threads by MID or @@SLOTNUMBER");
// OBSOLETE 
// OBSOLETE   if (select_thread (inferior_task, mid, is_slot ? 2 : 1) != KERN_SUCCESS)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   if (from_tty)
// OBSOLETE     printf_filtered ("Thread %d selected\n",
// OBSOLETE 		     is_slot ? map_port_name_to_mid (current_thread,
// OBSOLETE 						   MACH_TYPE_THREAD) : mid);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE thread_trace (mach_port_t thread, boolean_t set)
// OBSOLETE {
// OBSOLETE   int flavor = TRACE_FLAVOR;
// OBSOLETE   unsigned int stateCnt = TRACE_FLAVOR_SIZE;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_state_data_t state;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (thread))
// OBSOLETE     {
// OBSOLETE       warning ("thread_trace: invalid thread");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (must_suspend_thread)
// OBSOLETE     setup_thread (thread, 1);
// OBSOLETE 
// OBSOLETE   ret = thread_get_state (thread, flavor, state, &stateCnt);
// OBSOLETE   CHK ("thread_trace: error reading thread state", ret);
// OBSOLETE 
// OBSOLETE   if (set)
// OBSOLETE     {
// OBSOLETE       TRACE_SET (thread, state);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if (!TRACE_CLEAR (thread, state))
// OBSOLETE 	{
// OBSOLETE 	  if (must_suspend_thread)
// OBSOLETE 	    setup_thread (thread, 0);
// OBSOLETE 	  return;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = thread_set_state (thread, flavor, state, stateCnt);
// OBSOLETE   CHK ("thread_trace: error writing thread state", ret);
// OBSOLETE   if (must_suspend_thread)
// OBSOLETE     setup_thread (thread, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef	FLUSH_INFERIOR_CACHE
// OBSOLETE 
// OBSOLETE /* When over-writing code on some machines the I-Cache must be flushed
// OBSOLETE    explicitly, because it is not kept coherent by the lazy hardware.
// OBSOLETE    This definitely includes breakpoints, for instance, or else we
// OBSOLETE    end up looping in mysterious Bpt traps */
// OBSOLETE 
// OBSOLETE flush_inferior_icache (CORE_ADDR pc, int amount)
// OBSOLETE {
// OBSOLETE   vm_machine_attribute_val_t flush = MATTR_VAL_ICACHE_FLUSH;
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   ret = vm_machine_attribute (inferior_task,
// OBSOLETE 			      pc,
// OBSOLETE 			      amount,
// OBSOLETE 			      MATTR_CACHE,
// OBSOLETE 			      &flush);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("Error flushing inferior's cache : %s",
// OBSOLETE 	     mach_error_string (ret));
// OBSOLETE }
// OBSOLETE #endif /* FLUSH_INFERIOR_CACHE */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static
// OBSOLETE suspend_all_threads (int from_tty)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_array_t thread_list;
// OBSOLETE   int thread_count, index;
// OBSOLETE   int infoCnt;
// OBSOLETE   thread_basic_info_data_t th_info;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   ret = task_threads (inferior_task, &thread_list, &thread_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("Could not suspend inferior threads.");
// OBSOLETE       m3_kill_inferior ();
// OBSOLETE       throw_exception (RETURN_ERROR);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   for (index = 0; index < thread_count; index++)
// OBSOLETE     {
// OBSOLETE       int mid;
// OBSOLETE 
// OBSOLETE       mid = map_port_name_to_mid (thread_list[index],
// OBSOLETE 				  MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE       ret = thread_suspend (thread_list[index]);
// OBSOLETE 
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	warning ("Error trying to suspend thread %d : %s",
// OBSOLETE 		 mid, mach_error_string (ret));
// OBSOLETE 
// OBSOLETE       if (from_tty)
// OBSOLETE 	{
// OBSOLETE 	  infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE 	  ret = thread_info (thread_list[index],
// OBSOLETE 			     THREAD_BASIC_INFO,
// OBSOLETE 			     (thread_info_t) & th_info,
// OBSOLETE 			     &infoCnt);
// OBSOLETE 	  CHK ("suspend can't get thread info", ret);
// OBSOLETE 
// OBSOLETE 	  warning ("Thread %d suspend count is %d",
// OBSOLETE 		   mid, th_info.suspend_count);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   consume_send_rights (thread_list, thread_count);
// OBSOLETE   ret = vm_deallocate (mach_task_self (),
// OBSOLETE 		       (vm_address_t) thread_list,
// OBSOLETE 		       (thread_count * sizeof (int)));
// OBSOLETE   CHK ("Error trying to deallocate thread list", ret);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE thread_suspend_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int mid;
// OBSOLETE   mach_port_t saved_thread;
// OBSOLETE   int infoCnt;
// OBSOLETE   thread_basic_info_data_t th_info;
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   if (!strcasecmp (args, "all"))
// OBSOLETE     {
// OBSOLETE       suspend_all_threads (from_tty);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   saved_thread = current_thread;
// OBSOLETE 
// OBSOLETE   mid = parse_thread_id (args, 0, 0);
// OBSOLETE 
// OBSOLETE   if (mid < 0)
// OBSOLETE     error ("You can suspend only existing kernel threads with MID or @@SLOTNUMBER");
// OBSOLETE 
// OBSOLETE   if (mid == 0)
// OBSOLETE     mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
// OBSOLETE   else if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       if (current_thread)
// OBSOLETE 	current_thread = saved_thread;
// OBSOLETE       error ("Could not select thread %d", mid);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = thread_suspend (current_thread);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("thread_suspend failed : %s",
// OBSOLETE 	     mach_error_string (ret));
// OBSOLETE 
// OBSOLETE   infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE   ret = thread_info (current_thread,
// OBSOLETE 		     THREAD_BASIC_INFO,
// OBSOLETE 		     (thread_info_t) & th_info,
// OBSOLETE 		     &infoCnt);
// OBSOLETE   CHK ("suspend can't get thread info", ret);
// OBSOLETE 
// OBSOLETE   warning ("Thread %d suspend count is %d", mid, th_info.suspend_count);
// OBSOLETE 
// OBSOLETE   current_thread = saved_thread;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE resume_all_threads (int from_tty)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_array_t thread_list;
// OBSOLETE   int thread_count, index;
// OBSOLETE   int mid;
// OBSOLETE   int infoCnt;
// OBSOLETE   thread_basic_info_data_t th_info;
// OBSOLETE 
// OBSOLETE   ret = task_threads (inferior_task, &thread_list, &thread_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       m3_kill_inferior ();
// OBSOLETE       error ("task_threads", mach_error_string (ret));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   for (index = 0; index < thread_count; index++)
// OBSOLETE     {
// OBSOLETE       infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE       ret = thread_info (thread_list[index],
// OBSOLETE 			 THREAD_BASIC_INFO,
// OBSOLETE 			 (thread_info_t) & th_info,
// OBSOLETE 			 &infoCnt);
// OBSOLETE       CHK ("resume_all can't get thread info", ret);
// OBSOLETE 
// OBSOLETE       mid = map_port_name_to_mid (thread_list[index],
// OBSOLETE 				  MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE       if (!th_info.suspend_count)
// OBSOLETE 	{
// OBSOLETE 	  if (mid != -1 && from_tty)
// OBSOLETE 	    warning ("Thread %d is not suspended", mid);
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       ret = thread_resume (thread_list[index]);
// OBSOLETE 
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	warning ("Error trying to resume thread %d : %s",
// OBSOLETE 		 mid, mach_error_string (ret));
// OBSOLETE       else if (mid != -1 && from_tty)
// OBSOLETE 	warning ("Thread %d suspend count is %d",
// OBSOLETE 		 mid, --th_info.suspend_count);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   consume_send_rights (thread_list, thread_count);
// OBSOLETE   ret = vm_deallocate (mach_task_self (),
// OBSOLETE 		       (vm_address_t) thread_list,
// OBSOLETE 		       (thread_count * sizeof (int)));
// OBSOLETE   CHK ("Error trying to deallocate thread list", ret);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE thread_resume_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int mid;
// OBSOLETE   mach_port_t saved_thread;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_basic_info_data_t th_info;
// OBSOLETE   int infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   if (!strcasecmp (args, "all"))
// OBSOLETE     {
// OBSOLETE       resume_all_threads (from_tty);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   saved_thread = current_thread;
// OBSOLETE 
// OBSOLETE   mid = parse_thread_id (args, 0, 0);
// OBSOLETE 
// OBSOLETE   if (mid < 0)
// OBSOLETE     error ("You can resume only existing kernel threads with MID or @@SLOTNUMBER");
// OBSOLETE 
// OBSOLETE   if (mid == 0)
// OBSOLETE     mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
// OBSOLETE   else if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       if (current_thread)
// OBSOLETE 	current_thread = saved_thread;
// OBSOLETE       throw_exception (RETURN_ERROR);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = thread_info (current_thread,
// OBSOLETE 		     THREAD_BASIC_INFO,
// OBSOLETE 		     (thread_info_t) & th_info,
// OBSOLETE 		     &infoCnt);
// OBSOLETE   CHK ("resume can't get thread info", ret);
// OBSOLETE 
// OBSOLETE   if (!th_info.suspend_count)
// OBSOLETE     {
// OBSOLETE       warning ("Thread %d is not suspended", mid);
// OBSOLETE       goto out;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = thread_resume (current_thread);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("thread_resume failed : %s",
// OBSOLETE 	     mach_error_string (ret));
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       th_info.suspend_count--;
// OBSOLETE       warning ("Thread %d suspend count is %d", mid, th_info.suspend_count);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE out:
// OBSOLETE   current_thread = saved_thread;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE thread_kill_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int mid;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   int thread_count;
// OBSOLETE   thread_array_t thread_table;
// OBSOLETE   int index;
// OBSOLETE   mach_port_t thread_to_kill = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     error_no_arg ("thread mid to kill from the inferior task");
// OBSOLETE 
// OBSOLETE   mid = parse_thread_id (args, 0, 0);
// OBSOLETE 
// OBSOLETE   if (mid < 0)
// OBSOLETE     error ("You can kill only existing kernel threads with MID or @@SLOTNUMBER");
// OBSOLETE 
// OBSOLETE   if (mid)
// OBSOLETE     {
// OBSOLETE       ret = machid_mach_port (mid_server, mid_auth, mid, &thread_to_kill);
// OBSOLETE       CHK ("thread_kill_command: machid_mach_port map failed", ret);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     mid = map_port_name_to_mid (current_thread, MACH_TYPE_THREAD);
// OBSOLETE 
// OBSOLETE   /* Don't allow gdb to kill *any* thread in the system. Use mkill program for that */
// OBSOLETE   ret = task_threads (inferior_task, &thread_table, &thread_count);
// OBSOLETE   CHK ("Error getting inferior's thread list", ret);
// OBSOLETE 
// OBSOLETE   if (thread_to_kill == current_thread)
// OBSOLETE     {
// OBSOLETE       ret = thread_terminate (thread_to_kill);
// OBSOLETE       CHK ("Thread could not be terminated", ret);
// OBSOLETE 
// OBSOLETE       if (select_thread (inferior_task, 0, 1) != KERN_SUCCESS)
// OBSOLETE 	warning ("Last thread was killed, use \"kill\" command to kill task");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     for (index = 0; index < thread_count; index++)
// OBSOLETE       if (thread_table[index] == thread_to_kill)
// OBSOLETE 	{
// OBSOLETE 	  ret = thread_terminate (thread_to_kill);
// OBSOLETE 	  CHK ("Thread could not be terminated", ret);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE   if (thread_count > 1)
// OBSOLETE     consume_send_rights (thread_table, thread_count);
// OBSOLETE 
// OBSOLETE   ret = vm_deallocate (mach_task_self (), (vm_address_t) thread_table,
// OBSOLETE 		       (thread_count * sizeof (mach_port_t)));
// OBSOLETE   CHK ("Error trying to deallocate thread list", ret);
// OBSOLETE 
// OBSOLETE   warning ("Thread %d killed", mid);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Task specific commands; add more if you like */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE task_resume_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   task_basic_info_data_t ta_info;
// OBSOLETE   int infoCnt = TASK_BASIC_INFO_COUNT;
// OBSOLETE   int mid = map_port_name_to_mid (inferior_task, MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   /* Would be trivial to change, but is it desirable? */
// OBSOLETE   if (args)
// OBSOLETE     error ("Currently gdb can resume only it's inferior task");
// OBSOLETE 
// OBSOLETE   ret = task_info (inferior_task,
// OBSOLETE 		   TASK_BASIC_INFO,
// OBSOLETE 		   (task_info_t) & ta_info,
// OBSOLETE 		   &infoCnt);
// OBSOLETE   CHK ("task_resume_command: task_info failed", ret);
// OBSOLETE 
// OBSOLETE   if (ta_info.suspend_count == 0)
// OBSOLETE     error ("Inferior task %d is not suspended", mid);
// OBSOLETE   else if (ta_info.suspend_count == 1 &&
// OBSOLETE 	   from_tty &&
// OBSOLETE 	!query ("Suspend count is now 1. Do you know what you are doing? "))
// OBSOLETE     error ("Task not resumed");
// OBSOLETE 
// OBSOLETE   ret = task_resume (inferior_task);
// OBSOLETE   CHK ("task_resume_command: task_resume", ret);
// OBSOLETE 
// OBSOLETE   if (ta_info.suspend_count == 1)
// OBSOLETE     {
// OBSOLETE       warning ("Inferior task %d is no longer suspended", mid);
// OBSOLETE       must_suspend_thread = 1;
// OBSOLETE       /* @@@@ This is not complete: Registers change all the time when not
// OBSOLETE          suspended! */
// OBSOLETE       registers_changed ();
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     warning ("Inferior task %d suspend count is now %d",
// OBSOLETE 	     mid, ta_info.suspend_count - 1);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE void
// OBSOLETE task_suspend_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   task_basic_info_data_t ta_info;
// OBSOLETE   int infoCnt = TASK_BASIC_INFO_COUNT;
// OBSOLETE   int mid = map_port_name_to_mid (inferior_task, MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   /* Would be trivial to change, but is it desirable? */
// OBSOLETE   if (args)
// OBSOLETE     error ("Currently gdb can suspend only it's inferior task");
// OBSOLETE 
// OBSOLETE   ret = task_suspend (inferior_task);
// OBSOLETE   CHK ("task_suspend_command: task_suspend", ret);
// OBSOLETE 
// OBSOLETE   must_suspend_thread = 0;
// OBSOLETE 
// OBSOLETE   ret = task_info (inferior_task,
// OBSOLETE 		   TASK_BASIC_INFO,
// OBSOLETE 		   (task_info_t) & ta_info,
// OBSOLETE 		   &infoCnt);
// OBSOLETE   CHK ("task_suspend_command: task_info failed", ret);
// OBSOLETE 
// OBSOLETE   warning ("Inferior task %d suspend count is now %d",
// OBSOLETE 	   mid, ta_info.suspend_count);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE get_size (int bytes)
// OBSOLETE {
// OBSOLETE   static char size[30];
// OBSOLETE   int zz = bytes / 1024;
// OBSOLETE 
// OBSOLETE   if (zz / 1024)
// OBSOLETE     sprintf (size, "%-2.1f M", ((float) bytes) / (1024.0 * 1024.0));
// OBSOLETE   else
// OBSOLETE     sprintf (size, "%d K", zz);
// OBSOLETE 
// OBSOLETE   return size;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Does this require the target task to be suspended?? I don't think so. */
// OBSOLETE void
// OBSOLETE task_info_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int mid = -5;
// OBSOLETE   mach_port_t task;
// OBSOLETE   kern_return_t ret;
// OBSOLETE   task_basic_info_data_t ta_info;
// OBSOLETE   int infoCnt = TASK_BASIC_INFO_COUNT;
// OBSOLETE   int page_size = round_page (1);
// OBSOLETE   int thread_count = 0;
// OBSOLETE 
// OBSOLETE   if (MACH_PORT_VALID (inferior_task))
// OBSOLETE     mid = map_port_name_to_mid (inferior_task,
// OBSOLETE 				MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   task = inferior_task;
// OBSOLETE 
// OBSOLETE   if (args)
// OBSOLETE     {
// OBSOLETE       int tmid = atoi (args);
// OBSOLETE 
// OBSOLETE       if (tmid <= 0)
// OBSOLETE 	error ("Invalid mid %d for task info", tmid);
// OBSOLETE 
// OBSOLETE       if (tmid != mid)
// OBSOLETE 	{
// OBSOLETE 	  mid = tmid;
// OBSOLETE 	  ret = machid_mach_port (mid_server, mid_auth, tmid, &task);
// OBSOLETE 	  CHK ("task_info_command: machid_mach_port map failed", ret);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (mid < 0)
// OBSOLETE     error ("You have to give the task MID as an argument");
// OBSOLETE 
// OBSOLETE   ret = task_info (task,
// OBSOLETE 		   TASK_BASIC_INFO,
// OBSOLETE 		   (task_info_t) & ta_info,
// OBSOLETE 		   &infoCnt);
// OBSOLETE   CHK ("task_info_command: task_info failed", ret);
// OBSOLETE 
// OBSOLETE   printf_filtered ("\nTask info for task %d:\n\n", mid);
// OBSOLETE   printf_filtered (" Suspend count : %d\n", ta_info.suspend_count);
// OBSOLETE   printf_filtered (" Base priority : %d\n", ta_info.base_priority);
// OBSOLETE   printf_filtered (" Virtual size  : %s\n", get_size (ta_info.virtual_size));
// OBSOLETE   printf_filtered (" Resident size : %s\n", get_size (ta_info.resident_size));
// OBSOLETE 
// OBSOLETE   {
// OBSOLETE     thread_array_t thread_list;
// OBSOLETE 
// OBSOLETE     ret = task_threads (task, &thread_list, &thread_count);
// OBSOLETE     CHK ("task_info_command: task_threads", ret);
// OBSOLETE 
// OBSOLETE     printf_filtered (" Thread count  : %d\n", thread_count);
// OBSOLETE 
// OBSOLETE     consume_send_rights (thread_list, thread_count);
// OBSOLETE     ret = vm_deallocate (mach_task_self (),
// OBSOLETE 			 (vm_address_t) thread_list,
// OBSOLETE 			 (thread_count * sizeof (int)));
// OBSOLETE     CHK ("Error trying to deallocate thread list", ret);
// OBSOLETE   }
// OBSOLETE   if (have_emulator_p (task))
// OBSOLETE     printf_filtered (" Emulator at   : 0x%x..0x%x\n",
// OBSOLETE 		     EMULATOR_BASE, EMULATOR_END);
// OBSOLETE   else
// OBSOLETE     printf_filtered (" No emulator.\n");
// OBSOLETE 
// OBSOLETE   if (thread_count && task == inferior_task)
// OBSOLETE     printf_filtered ("\nUse the \"thread list\" command to see the threads\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* You may either FORWARD the exception to the inferior, or KEEP
// OBSOLETE  * it and return to GDB command level.
// OBSOLETE  *
// OBSOLETE  * exception mid [ forward | keep ]
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE exception_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   char *scan = args;
// OBSOLETE   int exception;
// OBSOLETE   int len;
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     error_no_arg ("exception number action");
// OBSOLETE 
// OBSOLETE   while (*scan == ' ' || *scan == '\t')
// OBSOLETE     scan++;
// OBSOLETE 
// OBSOLETE   if ('0' <= *scan && *scan <= '9')
// OBSOLETE     while ('0' <= *scan && *scan <= '9')
// OBSOLETE       scan++;
// OBSOLETE   else
// OBSOLETE     error ("exception number action");
// OBSOLETE 
// OBSOLETE   exception = atoi (args);
// OBSOLETE   if (exception <= 0 || exception > MAX_EXCEPTION)
// OBSOLETE     error ("Allowed exception numbers are in range 1..%d",
// OBSOLETE 	   MAX_EXCEPTION);
// OBSOLETE 
// OBSOLETE   if (*scan != ' ' && *scan != '\t')
// OBSOLETE     error ("exception number must be followed by a space");
// OBSOLETE   else
// OBSOLETE     while (*scan == ' ' || *scan == '\t')
// OBSOLETE       scan++;
// OBSOLETE 
// OBSOLETE   args = scan;
// OBSOLETE   len = 0;
// OBSOLETE   while (*scan)
// OBSOLETE     {
// OBSOLETE       len++;
// OBSOLETE       scan++;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!len)
// OBSOLETE     error ("exception number action");
// OBSOLETE 
// OBSOLETE   if (!strncasecmp (args, "forward", len))
// OBSOLETE     exception_map[exception].forward = TRUE;
// OBSOLETE   else if (!strncasecmp (args, "keep", len))
// OBSOLETE     exception_map[exception].forward = FALSE;
// OBSOLETE   else
// OBSOLETE     error ("exception action is either \"keep\" or \"forward\"");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE print_exception_info (int exception)
// OBSOLETE {
// OBSOLETE   boolean_t forward = exception_map[exception].forward;
// OBSOLETE 
// OBSOLETE   printf_filtered ("%s\t(%d): ", exception_map[exception].name,
// OBSOLETE 		   exception);
// OBSOLETE   if (!forward)
// OBSOLETE     if (exception_map[exception].sigmap != SIG_UNKNOWN)
// OBSOLETE       printf_filtered ("keep and handle as signal %d\n",
// OBSOLETE 		       exception_map[exception].sigmap);
// OBSOLETE     else
// OBSOLETE       printf_filtered ("keep and handle as unknown signal %d\n",
// OBSOLETE 		       exception_map[exception].sigmap);
// OBSOLETE   else
// OBSOLETE     printf_filtered ("forward exception to inferior\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE exception_info (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int exception;
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     for (exception = 1; exception <= MAX_EXCEPTION; exception++)
// OBSOLETE       print_exception_info (exception);
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       exception = atoi (args);
// OBSOLETE 
// OBSOLETE       if (exception <= 0 || exception > MAX_EXCEPTION)
// OBSOLETE 	error ("Invalid exception number, values from 1 to %d allowed",
// OBSOLETE 	       MAX_EXCEPTION);
// OBSOLETE       print_exception_info (exception);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Check for actions for mach exceptions.
// OBSOLETE  */
// OBSOLETE mach3_exception_actions (WAITTYPE *w, boolean_t force_print_only, char *who)
// OBSOLETE {
// OBSOLETE   boolean_t force_print = FALSE;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   if (force_print_only ||
// OBSOLETE       exception_map[stop_exception].sigmap == SIG_UNKNOWN)
// OBSOLETE     force_print = TRUE;
// OBSOLETE   else
// OBSOLETE     WSETSTOP (*w, exception_map[stop_exception].sigmap);
// OBSOLETE 
// OBSOLETE   if (exception_map[stop_exception].print || force_print)
// OBSOLETE     {
// OBSOLETE       target_terminal_ours ();
// OBSOLETE 
// OBSOLETE       printf_filtered ("\n%s received %s exception : ",
// OBSOLETE 		       who,
// OBSOLETE 		       exception_map[stop_exception].name);
// OBSOLETE 
// OBSOLETE       wrap_here ("   ");
// OBSOLETE 
// OBSOLETE       switch (stop_exception)
// OBSOLETE 	{
// OBSOLETE 	case EXC_BAD_ACCESS:
// OBSOLETE 	  printf_filtered ("referencing address 0x%x : %s\n",
// OBSOLETE 			   stop_subcode,
// OBSOLETE 			   mach_error_string (stop_code));
// OBSOLETE 	  break;
// OBSOLETE 	case EXC_BAD_INSTRUCTION:
// OBSOLETE 	  printf_filtered
// OBSOLETE 	    ("illegal or undefined instruction. code %d subcode %d\n",
// OBSOLETE 	     stop_code, stop_subcode);
// OBSOLETE 	  break;
// OBSOLETE 	case EXC_ARITHMETIC:
// OBSOLETE 	  printf_filtered ("code %d\n", stop_code);
// OBSOLETE 	  break;
// OBSOLETE 	case EXC_EMULATION:
// OBSOLETE 	  printf_filtered ("code %d subcode %d\n", stop_code, stop_subcode);
// OBSOLETE 	  break;
// OBSOLETE 	case EXC_SOFTWARE:
// OBSOLETE 	  printf_filtered ("%s specific, code 0x%x\n",
// OBSOLETE 			   stop_code < 0xffff ? "hardware" : "os emulation",
// OBSOLETE 			   stop_code);
// OBSOLETE 	  break;
// OBSOLETE 	case EXC_BREAKPOINT:
// OBSOLETE 	  printf_filtered ("type %d (machine dependent)\n",
// OBSOLETE 			   stop_code);
// OBSOLETE 	  break;
// OBSOLETE 	default:
// OBSOLETE 	  internal_error (__FILE__, __LINE__,
// OBSOLETE 			  "Unknown exception");
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE setup_notify_port (int create_new)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (MACH_PORT_VALID (our_notify_port))
// OBSOLETE     {
// OBSOLETE       ret = mach_port_destroy (mach_task_self (), our_notify_port);
// OBSOLETE       CHK ("Could not destroy our_notify_port", ret);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   our_notify_port = MACH_PORT_NULL;
// OBSOLETE   notify_chain = (port_chain_t) NULL;
// OBSOLETE   port_chain_destroy (port_chain_obstack);
// OBSOLETE 
// OBSOLETE   if (create_new)
// OBSOLETE     {
// OBSOLETE       ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 				MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 				&our_notify_port);
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	internal_error (__FILE__, __LINE__,
// OBSOLETE 			"Creating notify port %s", mach_error_string (ret));
// OBSOLETE 
// OBSOLETE       ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 				   our_notify_port,
// OBSOLETE 				   inferior_wait_port_set);
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	internal_error (__FILE__, __LINE__,
// OBSOLETE 			"initial move member %s", mach_error_string (ret));
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Register our message port to the net name server
// OBSOLETE  *
// OBSOLETE  * Currently used only by the external stop-gdb program
// OBSOLETE  * since ^C does not work if you would like to enter
// OBSOLETE  * gdb command level while debugging your program.
// OBSOLETE  *
// OBSOLETE  * NOTE: If the message port is sometimes used for other
// OBSOLETE  * purposes also, the NAME must not be a guessable one.
// OBSOLETE  * Then, there should be a way to change it.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE char registered_name[MAX_NAME_LEN];
// OBSOLETE 
// OBSOLETE void
// OBSOLETE message_port_info (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   if (registered_name[0])
// OBSOLETE     printf_filtered ("gdb's message port name: '%s'\n",
// OBSOLETE 		     registered_name);
// OBSOLETE   else
// OBSOLETE     printf_filtered ("gdb's message port is not currently registered\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE gdb_register_port (char *name, mach_port_t port)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   static int already_signed = 0;
// OBSOLETE   int len;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (port) || !name || !*name)
// OBSOLETE     {
// OBSOLETE       warning ("Invalid registration request");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!already_signed)
// OBSOLETE     {
// OBSOLETE       ret = mach_port_insert_right (mach_task_self (),
// OBSOLETE 				    our_message_port,
// OBSOLETE 				    our_message_port,
// OBSOLETE 				    MACH_MSG_TYPE_MAKE_SEND);
// OBSOLETE       CHK ("Failed to create a signature to our_message_port", ret);
// OBSOLETE       already_signed = 1;
// OBSOLETE     }
// OBSOLETE   else if (already_signed > 1)
// OBSOLETE     {
// OBSOLETE       ret = netname_check_out (name_server_port,
// OBSOLETE 			       registered_name,
// OBSOLETE 			       our_message_port);
// OBSOLETE       CHK ("Failed to check out gdb's message port", ret);
// OBSOLETE       registered_name[0] = '\000';
// OBSOLETE       already_signed = 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = netname_check_in (name_server_port,	/* Name server port */
// OBSOLETE 			  name,	/* Name of service */
// OBSOLETE 			  our_message_port,	/* Signature */
// OBSOLETE 			  port);	/* Creates a new send right */
// OBSOLETE   CHK ("Failed to check in the port", ret);
// OBSOLETE 
// OBSOLETE   len = 0;
// OBSOLETE   while (len < MAX_NAME_LEN && *(name + len))
// OBSOLETE     {
// OBSOLETE       registered_name[len] = *(name + len);
// OBSOLETE       len++;
// OBSOLETE     }
// OBSOLETE   registered_name[len] = '\000';
// OBSOLETE   already_signed = 2;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE struct cmd_list_element *cmd_thread_list;
// OBSOLETE struct cmd_list_element *cmd_task_list;
// OBSOLETE 
// OBSOLETE /*ARGSUSED */
// OBSOLETE static void
// OBSOLETE thread_command (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   printf_unfiltered ("\"thread\" must be followed by the name of a thread command.\n");
// OBSOLETE   help_list (cmd_thread_list, "thread ", -1, gdb_stdout);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*ARGSUSED */
// OBSOLETE static void
// OBSOLETE task_command (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   printf_unfiltered ("\"task\" must be followed by the name of a task command.\n");
// OBSOLETE   help_list (cmd_task_list, "task ", -1, gdb_stdout);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE add_mach_specific_commands (void)
// OBSOLETE {
// OBSOLETE   /* Thread handling commands */
// OBSOLETE 
// OBSOLETE   /* FIXME: Move our thread support into the generic thread.c stuff so we
// OBSOLETE      can share that code.  */
// OBSOLETE   add_prefix_cmd ("mthread", class_stack, thread_command,
// OBSOLETE 	  "Generic command for handling Mach threads in the debugged task.",
// OBSOLETE 		  &cmd_thread_list, "thread ", 0, &cmdlist);
// OBSOLETE 
// OBSOLETE   add_com_alias ("th", "mthread", class_stack, 1);
// OBSOLETE 
// OBSOLETE   add_cmd ("select", class_stack, thread_select_command,
// OBSOLETE 	   "Select and print MID of the selected thread",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE   add_cmd ("list", class_stack, thread_list_command,
// OBSOLETE 	   "List info of task's threads. Selected thread is marked with '*'",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE   add_cmd ("suspend", class_run, thread_suspend_command,
// OBSOLETE 	   "Suspend one or all of the threads in the selected task.",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE   add_cmd ("resume", class_run, thread_resume_command,
// OBSOLETE 	   "Resume one or all of the threads in the selected task.",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE   add_cmd ("kill", class_run, thread_kill_command,
// OBSOLETE 	   "Kill the specified thread MID from inferior task.",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE #if 0
// OBSOLETE   /* The rest of this support (condition_thread) was not merged.  It probably
// OBSOLETE      should not be merged in this form, but instead added to the generic GDB
// OBSOLETE      thread support.  */
// OBSOLETE   add_cmd ("break", class_breakpoint, condition_thread,
// OBSOLETE 	   "Breakpoint N will only be effective for thread MID or @@SLOT\n\
// OBSOLETE 	    If MID/@@SLOT is omitted allow all threads to break at breakpoint",
// OBSOLETE 	   &cmd_thread_list);
// OBSOLETE #endif
// OBSOLETE   /* Thread command shorthands (for backward compatibility) */
// OBSOLETE   add_alias_cmd ("ts", "mthread select", 0, 0, &cmdlist);
// OBSOLETE   add_alias_cmd ("tl", "mthread list", 0, 0, &cmdlist);
// OBSOLETE 
// OBSOLETE   /* task handling commands */
// OBSOLETE 
// OBSOLETE   add_prefix_cmd ("task", class_stack, task_command,
// OBSOLETE 		  "Generic command for handling debugged task.",
// OBSOLETE 		  &cmd_task_list, "task ", 0, &cmdlist);
// OBSOLETE 
// OBSOLETE   add_com_alias ("ta", "task", class_stack, 1);
// OBSOLETE 
// OBSOLETE   add_cmd ("suspend", class_run, task_suspend_command,
// OBSOLETE 	   "Suspend the inferior task.",
// OBSOLETE 	   &cmd_task_list);
// OBSOLETE   add_cmd ("resume", class_run, task_resume_command,
// OBSOLETE 	   "Resume the inferior task.",
// OBSOLETE 	   &cmd_task_list);
// OBSOLETE   add_cmd ("info", no_class, task_info_command,
// OBSOLETE 	   "Print information about the specified task.",
// OBSOLETE 	   &cmd_task_list);
// OBSOLETE 
// OBSOLETE   /* Print my message port name */
// OBSOLETE 
// OBSOLETE   add_info ("message-port", message_port_info,
// OBSOLETE 	    "Returns the name of gdb's message port in the netnameserver");
// OBSOLETE 
// OBSOLETE   /* Exception commands */
// OBSOLETE 
// OBSOLETE   add_info ("exceptions", exception_info,
// OBSOLETE 	    "What debugger does when program gets various exceptions.\n\
// OBSOLETE Specify an exception number as argument to print info on that\n\
// OBSOLETE exception only.");
// OBSOLETE 
// OBSOLETE   add_com ("exception", class_run, exception_command,
// OBSOLETE 	   "Specify how to handle an exception.\n\
// OBSOLETE Args are exception number followed by \"forward\" or \"keep\".\n\
// OBSOLETE `Forward' means forward the exception to the program's normal exception\n\
// OBSOLETE handler.\n\
// OBSOLETE `Keep' means reenter debugger if this exception happens, and GDB maps\n\
// OBSOLETE the exception to some signal (see info exception)\n\
// OBSOLETE Normally \"keep\" is used to return to GDB on exception.");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_dead_name (mach_port_t notify, mach_port_t name)
// OBSOLETE {
// OBSOLETE   kern_return_t kr = KERN_SUCCESS;
// OBSOLETE 
// OBSOLETE   /* Find the thing that notified */
// OBSOLETE   port_chain_t element = port_chain_member (notify_chain, name);
// OBSOLETE 
// OBSOLETE   /* Take name of from unreceived dead name notification list */
// OBSOLETE   notify_chain = port_chain_delete (notify_chain, name);
// OBSOLETE 
// OBSOLETE   if (!element)
// OBSOLETE     error ("Received a dead name notify from unchained port (0x%x)", name);
// OBSOLETE 
// OBSOLETE   switch (element->type)
// OBSOLETE     {
// OBSOLETE 
// OBSOLETE     case MACH_TYPE_THREAD:
// OBSOLETE       target_terminal_ours_for_output ();
// OBSOLETE       if (name == current_thread)
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered ("\nCurrent thread %d died", element->mid);
// OBSOLETE 	  current_thread = MACH_PORT_NULL;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	printf_filtered ("\nThread %d died", element->mid);
// OBSOLETE 
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case MACH_TYPE_TASK:
// OBSOLETE       target_terminal_ours_for_output ();
// OBSOLETE       if (name != inferior_task)
// OBSOLETE 	printf_filtered ("Task %d died, but it was not the selected task",
// OBSOLETE 			 element->mid);
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered ("Current task %d died", element->mid);
// OBSOLETE 
// OBSOLETE 	  mach_port_destroy (mach_task_self (), name);
// OBSOLETE 	  inferior_task = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE 	  if (notify_chain)
// OBSOLETE 	    warning ("There were still unreceived dead_name_notifications???");
// OBSOLETE 
// OBSOLETE 	  /* Destroy the old notifications */
// OBSOLETE 	  setup_notify_port (0);
// OBSOLETE 
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     default:
// OBSOLETE       error ("Unregistered dead_name 0x%x notification received. Type is %d, mid is 0x%x",
// OBSOLETE 	     name, element->type, element->mid);
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_msg_accepted (mach_port_t notify, mach_port_t name)
// OBSOLETE {
// OBSOLETE   warning ("do_mach_notify_msg_accepted : notify %x, name %x",
// OBSOLETE 	   notify, name);
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_no_senders (mach_port_t notify, mach_port_mscount_t mscount)
// OBSOLETE {
// OBSOLETE   warning ("do_mach_notify_no_senders : notify %x, mscount %x",
// OBSOLETE 	   notify, mscount);
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_port_deleted (mach_port_t notify, mach_port_t name)
// OBSOLETE {
// OBSOLETE   warning ("do_mach_notify_port_deleted : notify %x, name %x",
// OBSOLETE 	   notify, name);
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_port_destroyed (mach_port_t notify, mach_port_t rights)
// OBSOLETE {
// OBSOLETE   warning ("do_mach_notify_port_destroyed : notify %x, rights %x",
// OBSOLETE 	   notify, rights);
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE kern_return_t
// OBSOLETE do_mach_notify_send_once (mach_port_t notify)
// OBSOLETE {
// OBSOLETE #ifdef DUMP_SYSCALL
// OBSOLETE   /* MANY of these are generated. */
// OBSOLETE   warning ("do_mach_notify_send_once : notify %x",
// OBSOLETE 	   notify);
// OBSOLETE #endif
// OBSOLETE   return KERN_SUCCESS;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Kills the inferior. It's gone when you call this */
// OBSOLETE static void
// OBSOLETE kill_inferior_fast (void)
// OBSOLETE {
// OBSOLETE   WAITTYPE w;
// OBSOLETE 
// OBSOLETE   if (PIDGET (inferior_ptid) == 0 || PIDGET (inferior_ptid) == 1)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   /* kill() it, since the Unix server does not otherwise notice when
// OBSOLETE    * killed with task_terminate().
// OBSOLETE    */
// OBSOLETE   if (PIDGET (inferior_ptid) > 0)
// OBSOLETE     kill (PIDGET (inferior_ptid), SIGKILL);
// OBSOLETE 
// OBSOLETE   /* It's propably terminate already */
// OBSOLETE   (void) task_terminate (inferior_task);
// OBSOLETE 
// OBSOLETE   inferior_task = MACH_PORT_NULL;
// OBSOLETE   current_thread = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE   wait3 (&w, WNOHANG, 0);
// OBSOLETE 
// OBSOLETE   setup_notify_port (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_kill_inferior (void)
// OBSOLETE {
// OBSOLETE   kill_inferior_fast ();
// OBSOLETE   target_mourn_inferior ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Clean up after the inferior dies.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_mourn_inferior (void)
// OBSOLETE {
// OBSOLETE   unpush_target (&m3_ops);
// OBSOLETE   generic_mourn_inferior ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Fork an inferior process, and start debugging it.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_create_inferior (char *exec_file, char *allargs, char **env)
// OBSOLETE {
// OBSOLETE   fork_inferior (exec_file, allargs, env, m3_trace_me, m3_trace_him, NULL, NULL);
// OBSOLETE   /* We are at the first instruction we care about.  */
// OBSOLETE   /* Pedal to the metal... */
// OBSOLETE   proceed ((CORE_ADDR) -1, 0, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Mark our target-struct as eligible for stray "run" and "attach"
// OBSOLETE    commands.  */
// OBSOLETE static int
// OBSOLETE m3_can_run (void)
// OBSOLETE {
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Mach 3.0 does not need ptrace for anything
// OBSOLETE  * Make sure nobody uses it on mach.
// OBSOLETE  */
// OBSOLETE ptrace (int a, int b, int c, int d)
// OBSOLETE {
// OBSOLETE   error ("Lose, Lose! Somebody called ptrace\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Resume execution of the inferior process.
// OBSOLETE    If STEP is nonzero, single-step it.
// OBSOLETE    If SIGNAL is nonzero, give it that signal.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m3_resume (ptid_t ptid, int step, enum target_signal signal)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (step)
// OBSOLETE     {
// OBSOLETE       thread_basic_info_data_t th_info;
// OBSOLETE       unsigned int infoCnt = THREAD_BASIC_INFO_COUNT;
// OBSOLETE 
// OBSOLETE       /* There is no point in single stepping when current_thread
// OBSOLETE        * is dead.
// OBSOLETE        */
// OBSOLETE       if (!MACH_PORT_VALID (current_thread))
// OBSOLETE 	error ("No thread selected; can not single step");
// OBSOLETE 
// OBSOLETE       /* If current_thread is suspended, tracing it would never return.
// OBSOLETE        */
// OBSOLETE       ret = thread_info (current_thread,
// OBSOLETE 			 THREAD_BASIC_INFO,
// OBSOLETE 			 (thread_info_t) & th_info,
// OBSOLETE 			 &infoCnt);
// OBSOLETE       CHK ("child_resume: can't get thread info", ret);
// OBSOLETE 
// OBSOLETE       if (th_info.suspend_count)
// OBSOLETE 	error ("Can't trace a suspended thread. Use \"thread resume\" command to resume it");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   vm_read_cache_valid = FALSE;
// OBSOLETE 
// OBSOLETE   if (signal && PIDGET (inferior_ptid) > 0)	/* Do not signal, if attached by MID */
// OBSOLETE     kill (PIDGET (inferior_ptid), target_signal_to_host (signal));
// OBSOLETE 
// OBSOLETE   if (step)
// OBSOLETE     {
// OBSOLETE       suspend_all_threads (0);
// OBSOLETE 
// OBSOLETE       setup_single_step (current_thread, TRUE);
// OBSOLETE 
// OBSOLETE       ret = thread_resume (current_thread);
// OBSOLETE       CHK ("thread_resume", ret);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = task_resume (inferior_task);
// OBSOLETE   if (ret == KERN_FAILURE)
// OBSOLETE     warning ("Task was not suspended");
// OBSOLETE   else
// OBSOLETE     CHK ("Resuming task", ret);
// OBSOLETE 
// OBSOLETE   /* HACK HACK This is needed by the multiserver system HACK HACK */
// OBSOLETE   while ((ret = task_resume (inferior_task)) == KERN_SUCCESS)
// OBSOLETE     /* make sure it really runs */ ;
// OBSOLETE   /* HACK HACK This is needed by the multiserver system HACK HACK */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef ATTACH_DETACH
// OBSOLETE 
// OBSOLETE /* Start debugging the process with the given task */
// OBSOLETE void
// OBSOLETE task_attach (task_t tid)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   inferior_task = tid;
// OBSOLETE 
// OBSOLETE   ret = task_suspend (inferior_task);
// OBSOLETE   CHK ("task_attach: task_suspend", ret);
// OBSOLETE 
// OBSOLETE   must_suspend_thread = 0;
// OBSOLETE 
// OBSOLETE   setup_notify_port (1);
// OBSOLETE 
// OBSOLETE   request_notify (inferior_task, MACH_NOTIFY_DEAD_NAME, MACH_TYPE_TASK);
// OBSOLETE 
// OBSOLETE   setup_exception_port ();
// OBSOLETE 
// OBSOLETE   emulator_present = have_emulator_p (inferior_task);
// OBSOLETE 
// OBSOLETE   attach_flag = 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Well, we can call error also here and leave the
// OBSOLETE  * target stack inconsistent. Sigh.
// OBSOLETE  * Fix this sometime (the only way to fail here is that
// OBSOLETE  * the task has no threads at all, which is rare, but
// OBSOLETE  * possible; or if the target task has died, which is also
// OBSOLETE  * possible, but unlikely, since it has been suspended.
// OBSOLETE  * (Someone must have killed it))
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE attach_to_thread (void)
// OBSOLETE {
// OBSOLETE   if (select_thread (inferior_task, 0, 1) != KERN_SUCCESS)
// OBSOLETE     error ("Could not select any threads to attach to");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE mid_attach (int mid)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   ret = machid_mach_port (mid_server, mid_auth, mid, &inferior_task);
// OBSOLETE   CHK ("mid_attach: machid_mach_port", ret);
// OBSOLETE 
// OBSOLETE   task_attach (inferior_task);
// OBSOLETE 
// OBSOLETE   return mid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* 
// OBSOLETE  * Start debugging the process whose unix process-id is PID.
// OBSOLETE  * A negative "pid" value is legal and signifies a mach_id not a unix pid.
// OBSOLETE  *
// OBSOLETE  * Prevent (possible unwanted) dangerous operations by enabled users
// OBSOLETE  * like "atta 0" or "atta foo" (equal to the previous :-) and
// OBSOLETE  * "atta pidself". Anyway, the latter is allowed by specifying a MID.
// OBSOLETE  */
// OBSOLETE static int
// OBSOLETE m3_do_attach (int pid)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (pid == 0)
// OBSOLETE     error ("MID=0, Debugging the master unix server does not compute");
// OBSOLETE 
// OBSOLETE   /* Foo. This assumes gdb has a unix pid */
// OBSOLETE   if (pid == getpid ())
// OBSOLETE     error ("I will debug myself only by mid. (Gdb would suspend itself!)");
// OBSOLETE 
// OBSOLETE   if (pid < 0)
// OBSOLETE     {
// OBSOLETE       mid_attach (-(pid));
// OBSOLETE 
// OBSOLETE       /* inferior_ptid will be NEGATIVE! */
// OBSOLETE       inferior_ptid = pid_to_ptid (pid);
// OBSOLETE 
// OBSOLETE       return PIDGET (inferior_ptid);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   inferior_task = task_by_pid (pid);
// OBSOLETE   if (!MACH_PORT_VALID (inferior_task))
// OBSOLETE     error ("Cannot map Unix pid %d to Mach task port", pid);
// OBSOLETE 
// OBSOLETE   task_attach (inferior_task);
// OBSOLETE 
// OBSOLETE   inferior_ptid = pid_to_ptid (pid);
// OBSOLETE 
// OBSOLETE   return PIDGET (inferior_ptid);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Attach to process PID, then initialize for debugging it
// OBSOLETE    and wait for the trace-trap that results from attaching.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_attach (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   char *exec_file;
// OBSOLETE   int pid;
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     error_no_arg ("process-id to attach");
// OBSOLETE 
// OBSOLETE   pid = atoi (args);
// OBSOLETE 
// OBSOLETE   if (pid == getpid ())		/* Trying to masturbate? */
// OBSOLETE     error ("I refuse to debug myself!");
// OBSOLETE 
// OBSOLETE   if (from_tty)
// OBSOLETE     {
// OBSOLETE       exec_file = (char *) get_exec_file (0);
// OBSOLETE 
// OBSOLETE       if (exec_file)
// OBSOLETE 	printf_unfiltered ("Attaching to program `%s', %s\n", exec_file,
// OBSOLETE 	                   target_pid_to_str (pid_to_ptid (pid)));
// OBSOLETE       else
// OBSOLETE 	printf_unfiltered ("Attaching to %s\n",
// OBSOLETE 	                   target_pid_to_str (pid_to_ptid (pid)));
// OBSOLETE 
// OBSOLETE       gdb_flush (gdb_stdout);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   m3_do_attach (pid_to_ptid (pid));
// OBSOLETE   inferior_ptid = pid_to_ptid (pid);
// OBSOLETE   push_target (&m3_ops);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE deallocate_inferior_ports (void)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_array_t thread_list;
// OBSOLETE   int thread_count, index;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (inferior_task))
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   ret = task_threads (inferior_task, &thread_list, &thread_count);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("deallocate_inferior_ports: task_threads",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Get rid of send rights to task threads */
// OBSOLETE   for (index = 0; index < thread_count; index++)
// OBSOLETE     {
// OBSOLETE       int rights;
// OBSOLETE       ret = mach_port_get_refs (mach_task_self (),
// OBSOLETE 				thread_list[index],
// OBSOLETE 				MACH_PORT_RIGHT_SEND,
// OBSOLETE 				&rights);
// OBSOLETE       CHK ("deallocate_inferior_ports: get refs", ret);
// OBSOLETE 
// OBSOLETE       if (rights > 0)
// OBSOLETE 	{
// OBSOLETE 	  ret = mach_port_mod_refs (mach_task_self (),
// OBSOLETE 				    thread_list[index],
// OBSOLETE 				    MACH_PORT_RIGHT_SEND,
// OBSOLETE 				    -rights);
// OBSOLETE 	  CHK ("deallocate_inferior_ports: mod refs", ret);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = mach_port_mod_refs (mach_task_self (),
// OBSOLETE 			    inferior_exception_port,
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    -1);
// OBSOLETE   CHK ("deallocate_inferior_ports: cannot get rid of exception port", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_deallocate (mach_task_self (),
// OBSOLETE 			      inferior_task);
// OBSOLETE   CHK ("deallocate_task_port: deallocating inferior_task", ret);
// OBSOLETE 
// OBSOLETE   current_thread = MACH_PORT_NULL;
// OBSOLETE   inferior_task = MACH_PORT_NULL;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Stop debugging the process whose number is PID
// OBSOLETE    and continue it with signal number SIGNAL.
// OBSOLETE    SIGNAL = 0 means just continue it.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_do_detach (int signal)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   MACH_ERROR_NO_INFERIOR;
// OBSOLETE 
// OBSOLETE   if (current_thread != MACH_PORT_NULL)
// OBSOLETE     {
// OBSOLETE       /* Store the gdb's view of the thread we are deselecting
// OBSOLETE        * before we detach.
// OBSOLETE        * @@@@ I am really not sure if this is ever needeed.
// OBSOLETE        */
// OBSOLETE       target_prepare_to_store ();
// OBSOLETE       target_store_registers (-1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   ret = task_set_special_port (inferior_task,
// OBSOLETE 			       TASK_EXCEPTION_PORT,
// OBSOLETE 			       inferior_old_exception_port);
// OBSOLETE   CHK ("task_set_special_port", ret);
// OBSOLETE 
// OBSOLETE   /* Discard all requested notifications */
// OBSOLETE   setup_notify_port (0);
// OBSOLETE 
// OBSOLETE   if (remove_breakpoints ())
// OBSOLETE     warning ("Could not remove breakpoints when detaching");
// OBSOLETE 
// OBSOLETE   if (signal && PIDGET (inferior_ptid) > 0)
// OBSOLETE     kill (PIDGET (inferior_ptid), signal);
// OBSOLETE 
// OBSOLETE   /* the task might be dead by now */
// OBSOLETE   (void) task_resume (inferior_task);
// OBSOLETE 
// OBSOLETE   deallocate_inferior_ports ();
// OBSOLETE 
// OBSOLETE   attach_flag = 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Take a program previously attached to and detaches it.
// OBSOLETE    The program resumes execution and will no longer stop
// OBSOLETE    on signals, etc.  We'd better not have left any breakpoints
// OBSOLETE    in the program or it'll die when it hits one.  For this
// OBSOLETE    to work, it may be necessary for the process to have been
// OBSOLETE    previously attached.  It *might* work if the program was
// OBSOLETE    started via fork.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_detach (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int siggnal = 0;
// OBSOLETE 
// OBSOLETE   if (from_tty)
// OBSOLETE     {
// OBSOLETE       char *exec_file = get_exec_file (0);
// OBSOLETE       if (exec_file == 0)
// OBSOLETE 	exec_file = "";
// OBSOLETE       printf_unfiltered ("Detaching from program: %s %s\n",
// OBSOLETE 			 exec_file, target_pid_to_str (inferior_ptid));
// OBSOLETE       gdb_flush (gdb_stdout);
// OBSOLETE     }
// OBSOLETE   if (args)
// OBSOLETE     siggnal = atoi (args);
// OBSOLETE 
// OBSOLETE   m3_do_detach (siggnal);
// OBSOLETE   inferior_ptid = null_ptid;
// OBSOLETE   unpush_target (&m3_ops);	/* Pop out of handling an inferior */
// OBSOLETE }
// OBSOLETE #endif /* ATTACH_DETACH */
// OBSOLETE 
// OBSOLETE /* Get ready to modify the registers array.  On machines which store
// OBSOLETE    individual registers, this doesn't need to do anything.  On machines
// OBSOLETE    which store all the registers in one fell swoop, this makes sure
// OBSOLETE    that registers contains all the registers from the program being
// OBSOLETE    debugged.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_prepare_to_store (void)
// OBSOLETE {
// OBSOLETE #ifdef CHILD_PREPARE_TO_STORE
// OBSOLETE   CHILD_PREPARE_TO_STORE ();
// OBSOLETE #endif
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Print status information about what we're accessing.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_files_info (struct target_ops *ignore)
// OBSOLETE {
// OBSOLETE   /* FIXME: should print MID and all that crap.  */
// OBSOLETE   printf_unfiltered ("\tUsing the running image of %s %s.\n",
// OBSOLETE       attach_flag ? "attached" : "child", target_pid_to_str (inferior_ptid));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_open (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   error ("Use the \"run\" command to start a Unix child process.");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef DUMP_SYSCALL
// OBSOLETE #define STR(x) #x
// OBSOLETE 
// OBSOLETE char *bsd1_names[] =
// OBSOLETE {
// OBSOLETE   "execve",
// OBSOLETE   "fork",
// OBSOLETE   "take_signal",
// OBSOLETE   "sigreturn",
// OBSOLETE   "getrusage",
// OBSOLETE   "chdir",
// OBSOLETE   "chroot",
// OBSOLETE   "open",
// OBSOLETE   "creat",
// OBSOLETE   "mknod",
// OBSOLETE   "link",
// OBSOLETE   "symlink",
// OBSOLETE   "unlink",
// OBSOLETE   "access",
// OBSOLETE   "stat",
// OBSOLETE   "readlink",
// OBSOLETE   "chmod",
// OBSOLETE   "chown",
// OBSOLETE   "utimes",
// OBSOLETE   "truncate",
// OBSOLETE   "rename",
// OBSOLETE   "mkdir",
// OBSOLETE   "rmdir",
// OBSOLETE   "xutimes",
// OBSOLETE   "mount",
// OBSOLETE   "umount",
// OBSOLETE   "acct",
// OBSOLETE   "setquota",
// OBSOLETE   "write_short",
// OBSOLETE   "write_long",
// OBSOLETE   "send_short",
// OBSOLETE   "send_long",
// OBSOLETE   "sendto_short",
// OBSOLETE   "sendto_long",
// OBSOLETE   "select",
// OBSOLETE   "task_by_pid",
// OBSOLETE   "recvfrom_short",
// OBSOLETE   "recvfrom_long",
// OBSOLETE   "setgroups",
// OBSOLETE   "setrlimit",
// OBSOLETE   "sigvec",
// OBSOLETE   "sigstack",
// OBSOLETE   "settimeofday",
// OBSOLETE   "adjtime",
// OBSOLETE   "setitimer",
// OBSOLETE   "sethostname",
// OBSOLETE   "bind",
// OBSOLETE   "accept",
// OBSOLETE   "connect",
// OBSOLETE   "setsockopt",
// OBSOLETE   "getsockopt",
// OBSOLETE   "getsockname",
// OBSOLETE   "getpeername",
// OBSOLETE   "init_process",
// OBSOLETE   "table_set",
// OBSOLETE   "table_get",
// OBSOLETE   "pioctl",
// OBSOLETE   "emulator_error",
// OBSOLETE   "readwrite",
// OBSOLETE   "share_wakeup",
// OBSOLETE   0,
// OBSOLETE   "maprw_request_it",
// OBSOLETE   "maprw_release_it",
// OBSOLETE   "maprw_remap",
// OBSOLETE   "pid_by_task",
// OBSOLETE };
// OBSOLETE 
// OBSOLETE int bsd1_nnames = sizeof (bsd1_names) / sizeof (bsd1_names[0]);
// OBSOLETE 
// OBSOLETE char *
// OBSOLETE name_str (int name, char *buf)
// OBSOLETE {
// OBSOLETE   switch (name)
// OBSOLETE     {
// OBSOLETE     case MACH_MSG_TYPE_BOOLEAN:
// OBSOLETE       return "boolean";
// OBSOLETE     case MACH_MSG_TYPE_INTEGER_16:
// OBSOLETE       return "short";
// OBSOLETE     case MACH_MSG_TYPE_INTEGER_32:
// OBSOLETE       return "long";
// OBSOLETE     case MACH_MSG_TYPE_CHAR:
// OBSOLETE       return "char";
// OBSOLETE     case MACH_MSG_TYPE_BYTE:
// OBSOLETE       return "byte";
// OBSOLETE     case MACH_MSG_TYPE_REAL:
// OBSOLETE       return "real";
// OBSOLETE     case MACH_MSG_TYPE_STRING:
// OBSOLETE       return "string";
// OBSOLETE     default:
// OBSOLETE       sprintf (buf, "%d", name);
// OBSOLETE       return buf;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE char *
// OBSOLETE id_str (int id, char *buf)
// OBSOLETE {
// OBSOLETE   char *p;
// OBSOLETE   if (id >= 101000 && id < 101000 + bsd1_nnames)
// OBSOLETE     {
// OBSOLETE       if (p = bsd1_names[id - 101000])
// OBSOLETE 	return p;
// OBSOLETE     }
// OBSOLETE   if (id == 102000)
// OBSOLETE     return "psignal_retry";
// OBSOLETE   if (id == 100000)
// OBSOLETE     return "syscall";
// OBSOLETE   sprintf (buf, "%d", id);
// OBSOLETE   return buf;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE print_msg (mach_msg_header_t *mp)
// OBSOLETE {
// OBSOLETE   char *fmt_x = "%20s : 0x%08x\n";
// OBSOLETE   char *fmt_d = "%20s : %10d\n";
// OBSOLETE   char *fmt_s = "%20s : %s\n";
// OBSOLETE   char buf[100];
// OBSOLETE 
// OBSOLETE   puts_filtered ("\n");
// OBSOLETE #define pr(fmt,h,x) printf_filtered(fmt,STR(x),(h).x)
// OBSOLETE   pr (fmt_x, (*mp), msgh_bits);
// OBSOLETE   pr (fmt_d, (*mp), msgh_size);
// OBSOLETE   pr (fmt_x, (*mp), msgh_remote_port);
// OBSOLETE   pr (fmt_x, (*mp), msgh_local_port);
// OBSOLETE   pr (fmt_d, (*mp), msgh_kind);
// OBSOLETE   printf_filtered (fmt_s, STR (msgh_id), id_str (mp->msgh_id, buf));
// OBSOLETE 
// OBSOLETE   if (debug_level > 1)
// OBSOLETE     {
// OBSOLETE       char *p, *ep, *dp;
// OBSOLETE       int plen;
// OBSOLETE       p = (char *) mp;
// OBSOLETE       ep = p + mp->msgh_size;
// OBSOLETE       p += sizeof (*mp);
// OBSOLETE       for (; p < ep; p += plen)
// OBSOLETE 	{
// OBSOLETE 	  mach_msg_type_t *tp;
// OBSOLETE 	  mach_msg_type_long_t *tlp;
// OBSOLETE 	  int name, size, number;
// OBSOLETE 	  tp = (mach_msg_type_t *) p;
// OBSOLETE 	  if (tp->msgt_longform)
// OBSOLETE 	    {
// OBSOLETE 	      tlp = (mach_msg_type_long_t *) tp;
// OBSOLETE 	      name = tlp->msgtl_name;
// OBSOLETE 	      size = tlp->msgtl_size;
// OBSOLETE 	      number = tlp->msgtl_number;
// OBSOLETE 	      plen = sizeof (*tlp);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      name = tp->msgt_name;
// OBSOLETE 	      size = tp->msgt_size;
// OBSOLETE 	      number = tp->msgt_number;
// OBSOLETE 	      plen = sizeof (*tp);
// OBSOLETE 	    }
// OBSOLETE 	  printf_filtered ("name=%-16s size=%2d number=%7d inline=%d long=%d deal=%d\n",
// OBSOLETE 			name_str (name, buf), size, number, tp->msgt_inline,
// OBSOLETE 			   tp->msgt_longform, tp->msgt_deallocate);
// OBSOLETE 	  dp = p + plen;
// OBSOLETE 	  if (tp->msgt_inline)
// OBSOLETE 	    {
// OBSOLETE 	      int l;
// OBSOLETE 	      l = size * number / 8;
// OBSOLETE 	      l = (l + sizeof (long) - 1) & ~((sizeof (long)) - 1);
// OBSOLETE 	      plen += l;
// OBSOLETE 	      print_data (dp, size, number);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      plen += sizeof (int *);
// OBSOLETE 	    }
// OBSOLETE 	  printf_filtered ("plen=%d\n", plen);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE print_data (char *p, int size, int number)
// OBSOLETE {
// OBSOLETE   int *ip;
// OBSOLETE   short *sp;
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   switch (size)
// OBSOLETE     {
// OBSOLETE     case 8:
// OBSOLETE       for (i = 0; i < number; i++)
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered (" %02x", p[i]);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE     case 16:
// OBSOLETE       sp = (short *) p;
// OBSOLETE       for (i = 0; i < number; i++)
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered (" %04x", sp[i]);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE     case 32:
// OBSOLETE       ip = (int *) p;
// OBSOLETE       for (i = 0; i < number; i++)
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered (" %08x", ip[i]);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE   puts_filtered ("\n");
// OBSOLETE }
// OBSOLETE #endif /* DUMP_SYSCALL */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m3_stop (void)
// OBSOLETE {
// OBSOLETE   error ("to_stop target function not implemented");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE m3_pid_to_exec_file (int pid)
// OBSOLETE {
// OBSOLETE   error ("to_pid_to_exec_file target function not implemented");
// OBSOLETE   return NULL;			/* To keep all compilers happy. */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_m3_ops (void)
// OBSOLETE {
// OBSOLETE   m3_ops.to_shortname = "mach";
// OBSOLETE   m3_ops.to_longname = "Mach child process";
// OBSOLETE   m3_ops.to_doc = "Mach child process (started by the \"run\" command).";
// OBSOLETE   m3_ops.to_open = m3_open;
// OBSOLETE   m3_ops.to_attach = m3_attach;
// OBSOLETE   m3_ops.to_detach = m3_detach;
// OBSOLETE   m3_ops.to_resume = m3_resume;
// OBSOLETE   m3_ops.to_wait = mach_really_wait;
// OBSOLETE   m3_ops.to_fetch_registers = fetch_inferior_registers;
// OBSOLETE   m3_ops.to_store_registers = store_inferior_registers;
// OBSOLETE   m3_ops.to_prepare_to_store = m3_prepare_to_store;
// OBSOLETE   m3_ops.to_xfer_memory = m3_xfer_memory;
// OBSOLETE   m3_ops.to_files_info = m3_files_info;
// OBSOLETE   m3_ops.to_insert_breakpoint = memory_insert_breakpoint;
// OBSOLETE   m3_ops.to_remove_breakpoint = memory_remove_breakpoint;
// OBSOLETE   m3_ops.to_terminal_init = terminal_init_inferior;
// OBSOLETE   m3_ops.to_terminal_inferior = terminal_inferior;
// OBSOLETE   m3_ops.to_terminal_ours_for_output = terminal_ours_for_output;
// OBSOLETE   m3_ops.to_terminal_save_ours = terminal_save_ours;
// OBSOLETE   m3_ops.to_terminal_ours = terminal_ours;
// OBSOLETE   m3_ops.to_terminal_info = child_terminal_info;
// OBSOLETE   m3_ops.to_kill = m3_kill_inferior;
// OBSOLETE   m3_ops.to_create_inferior = m3_create_inferior;
// OBSOLETE   m3_ops.to_mourn_inferior = m3_mourn_inferior;
// OBSOLETE   m3_ops.to_can_run = m3_can_run;
// OBSOLETE   m3_ops.to_stop = m3_stop;
// OBSOLETE   m3_ops.to_pid_to_exec_file = m3_pid_to_exec_file;
// OBSOLETE   m3_ops.to_stratum = process_stratum;
// OBSOLETE   m3_ops.to_has_all_memory = 1;
// OBSOLETE   m3_ops.to_has_memory = 1;
// OBSOLETE   m3_ops.to_has_stack = 1;
// OBSOLETE   m3_ops.to_has_registers = 1;
// OBSOLETE   m3_ops.to_has_execution = 1;
// OBSOLETE   m3_ops.to_magic = OPS_MAGIC;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_m3_nat (void)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   init_m3_ops ();
// OBSOLETE   add_target (&m3_ops);
// OBSOLETE 
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_PORT_SET,
// OBSOLETE 			    &inferior_wait_port_set);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     internal_error (__FILE__, __LINE__,
// OBSOLETE 		    "initial port set %s", mach_error_string (ret));
// OBSOLETE 
// OBSOLETE   /* mach_really_wait now waits for this */
// OBSOLETE   currently_waiting_for = inferior_wait_port_set;
// OBSOLETE 
// OBSOLETE   ret = netname_look_up (name_server_port, hostname, "MachID", &mid_server);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       mid_server = MACH_PORT_NULL;
// OBSOLETE 
// OBSOLETE       warning ("initialize machid: netname_lookup_up(MachID) : %s",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE       warning ("Some (most?) features disabled...");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   mid_auth = mach_privileged_host_port ();
// OBSOLETE   if (mid_auth == MACH_PORT_NULL)
// OBSOLETE     mid_auth = mach_task_self ();
// OBSOLETE 
// OBSOLETE   obstack_init (port_chain_obstack);
// OBSOLETE 
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    &thread_exception_port);
// OBSOLETE   CHK ("Creating thread_exception_port for single stepping", ret);
// OBSOLETE 
// OBSOLETE   ret = mach_port_insert_right (mach_task_self (),
// OBSOLETE 				thread_exception_port,
// OBSOLETE 				thread_exception_port,
// OBSOLETE 				MACH_MSG_TYPE_MAKE_SEND);
// OBSOLETE   CHK ("Inserting send right to thread_exception_port", ret);
// OBSOLETE 
// OBSOLETE   /* Allocate message port */
// OBSOLETE   ret = mach_port_allocate (mach_task_self (),
// OBSOLETE 			    MACH_PORT_RIGHT_RECEIVE,
// OBSOLETE 			    &our_message_port);
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("Creating message port %s", mach_error_string (ret));
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       char buf[MAX_NAME_LEN];
// OBSOLETE       ret = mach_port_move_member (mach_task_self (),
// OBSOLETE 				   our_message_port,
// OBSOLETE 				   inferior_wait_port_set);
// OBSOLETE       if (ret != KERN_SUCCESS)
// OBSOLETE 	warning ("message move member %s", mach_error_string (ret));
// OBSOLETE 
// OBSOLETE 
// OBSOLETE       /* @@@@@@@@ No way to change message port name currently */
// OBSOLETE       /* Foo. This assumes gdb has a unix pid */
// OBSOLETE       sprintf (buf, "gdb-%d", getpid ());
// OBSOLETE       gdb_register_port (buf, our_message_port);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Heap for thread commands */
// OBSOLETE   obstack_init (cproc_obstack);
// OBSOLETE 
// OBSOLETE   add_mach_specific_commands ();
// OBSOLETE }
@


1.16
log
@* frame.h (select_frame): Delete level parameter.
* stack.c (select_frame): Update.  Use frame_relative_level to
obtain the frame's level.
(select_and_print_frame): Update call.
(select_frame_command): Ditto.
(up_silently_base): Ditto.
(down_silently_base): Ditto.
* ocd.c (ocd_start_remote): Ditto.
* remote-rdp.c (remote_rdp_open): Ditto.
* remote-mips.c (mips_initialize): Ditto.
(common_open): Ditto.
* remote-e7000.c (e7000_start_remote): Ditto.
* m3-nat.c (select_thread): Ditto.
* hppa-tdep.c (child_get_current_exception_event): Ditto.
(child_get_current_exception_event): Ditto.
* varobj.c (varobj_create): Ditto.
(varobj_update): Ditto.
(c_value_of_root): Ditto.
* tracepoint.c (finish_tfind_command): Ditto.
* corelow.c (core_open): Ditto.
* arch-utils.c (generic_prepare_to_proceed): Ditto.
* thread.c (info_threads_command): Ditto.
(switch_to_thread): Ditto.
* infrun.c (normal_stop): Ditto.
(restore_selected_frame): Ditto.
(restore_inferior_status): Ditto.
* breakpoint.c (insert_breakpoints): Ditto.
(watchpoint_check): Ditto.
(bpstat_stop_status): Ditto.
(do_enable_breakpoint): Ditto.
* blockframe.c (flush_cached_frames): Ditto.
(reinit_frame_cache): Ditto.
@
text
@d4477 1
@


1.16.6.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a4476 1
  m3_ops.to_terminal_save_ours = terminal_save_ours;
@


1.15
log
@* defs.h (throw_exception): Rename return_to_top_level.  Update
comments.
* utils.c (error_stream, internal_verror, quit): Ditto.
* top.c (throw_exception, catcher): Ditto.
* sparclet-rom.c (sparclet_load): Ditto.
* remote.c (interrupt_query, minitelnet): Ditto.
* remote-sds.c (interrupt_query): Ditto.
* remote-mips.c (mips_error, mips_kill): Ditto.
* ocd.c (interrupt_query): Ditto.
* monitor.c (monitor_interrupt_query): Ditto.
* m3-nat.c (suspend_all_threads, thread_resume_command): Ditto.
* target.h: Update comment.

* m3-nat.c, ocd.c, sparclet-rom.c: Update copyright.
@
text
@d1104 1
a1104 1
      select_frame (get_current_frame (), 0);
@


1.14
log
@
* arch-utils.c (generic_prepare_to_proceed): Allow for having
stopped due to a Ctrl-C as well as breakpoints.

* hppa-tdep.c (hppa_prepare_to_proceed): Add FIXME as this may not
support thread switches after Ctrl-C.
* lin-lwp.c (lin_lwp_prepare_to_proceed): Ditto.
* linux-thread.c (linuxthreads_prepare_to_proceed): Ditto.
* m3-nat.c (mach3_prepare_to_proceed): Ditto.
@
text
@d4 2
a5 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d2942 1
a2942 1
      return_to_top_level (RETURN_ERROR);
d3111 1
a3111 1
      return_to_top_level (RETURN_ERROR);
@


1.13
log
@Phase 1 of the ptid_t changes.
@
text
@d1578 3
@


1.12
log
@2001-04-06  David Smith  <dsmith@@redhat.com>

	* arch-utils.c (default_prepare_to_proceed)
	(generic_prepare_to_proceed): Added new functions.
	* arch-utils.h: New function declarations for
	default_prepare_to_proceed() and generic_prepare_to_proceed().
	* gdbarch.sh: Added PREPARE_TO_PROCEED.
	* gdbarch.c: Regenerated.
	* gdbarch.h: Regenerated.
	* inferior.h: Added get_last_target_status() declaration.
	* infrun.c (get_last_target_status): Added new function.
	(handle_inferior_event): Saves last pid and waitstatus, which will
	get returned by get_last_target_status().

	* hppa-tdep.c (prepare_to_proceed):  Added comment stating that
	prepare_to_proceed() is potentially redundant since
	default_prepare_to_proceed() has been added.
	* linux-thread.c (prepare_to_proceed): Ditto.
	* lin-lwp.c (prepare_to_proceed): Ditto.
	* m3-nat.c (prepare_to_proceed): Ditto.
@
text
@d1235 1
a1235 1
   Returns the inferior_pid for rest of gdb.
d1237 2
a1238 2
int
mach_really_wait (int pid, struct target_waitstatus *ourstatus)
d1314 1
a1314 1
	      return inferior_pid;
d1349 1
a1349 1
	  return inferior_pid;
d3818 1
a3818 1
  if (inferior_pid == 0 || inferior_pid == 1)
d3824 2
a3825 2
  if (inferior_pid > 0)
    kill (inferior_pid, SIGKILL);
d3887 1
a3887 1
m3_resume (int pid, int step, enum target_signal signal)
d3916 2
a3917 2
  if (signal && inferior_pid > 0)	/* Do not signal, if attached by MID */
    kill (inferior_pid, target_signal_to_host (signal));
d4017 2
a4018 2
      /* inferior_pid will be NEGATIVE! */
      inferior_pid = pid;
d4020 1
a4020 1
      return inferior_pid;
d4029 1
a4029 1
  inferior_pid = pid;
d4031 1
a4031 1
  return inferior_pid;
d4056 2
a4057 1
	printf_unfiltered ("Attaching to program `%s', %s\n", exec_file, target_pid_to_str (pid));
d4059 2
a4060 1
	printf_unfiltered ("Attaching to %s\n", target_pid_to_str (pid));
d4065 2
a4066 2
  m3_do_attach (pid);
  inferior_pid = pid;
d4154 2
a4155 2
  if (signal && inferior_pid > 0)
    kill (inferior_pid, signal);
d4184 1
a4184 1
			 exec_file, target_pid_to_str (inferior_pid));
d4191 1
a4191 1
  inferior_pid = 0;
d4217 1
a4217 1
      attach_flag ? "attached" : "child", target_pid_to_str (inferior_pid));
d4463 1
a4463 1
  m3_ops.to_wait = mach_really__wait;
@


1.11
log
@Eliminate some uses of __STDC__.
@
text
@d1576 2
@


1.10
log
@Update/correct copyright notices.
@
text
@a1834 1
#ifdef __STDC__
a1836 4
#else
#define CHK_GOTO_OUT(str,ret) \
  do if (ret != KERN_SUCCESS) { errstr = str; goto out; } while(0)
#endif
a4222 1
#ifdef __STDC__
a4223 3
#else
#define STR(x) "x"
#endif
@


1.9
log
@Create new file regcache.h.  Update all uses.
@
text
@d4 1
a4 1
   Copyright (C) 1992, 1996, 1999, 2000, 2001
@


1.8
log
@Replace calls to abort() with calls to internal_error().
@
text
@d60 1
@


1.7
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d349 1
a349 1
    abort ();
d605 1
a605 1
    abort ();
d609 1
a609 1
    abort ();
d615 1
a615 1
    abort ();
@


1.6
log
@* gdbarch.sh, hp-psymtab-read.c, hpread.c, m3-nat.c, mcore-tdep.c,
mips-tdep.c, monitor.c, regcache.c, remote-es.c, ser-unix.c,
somread.c, tracepoint.c: Fix spelling errors in comments.
* gdbarch.c: Regenerate.

* gnu-nat.c (S_exception_raise_request): Fix typos and spelling
errors in strings.
* m3-nat.c (intercept_exec_calls, mach_thread_parse_id): Likewise.
* mcore-tdep.c (mcore_analyze_prologue): Likewise.
* mips-tdep.c (mips16_next_pc, _initialize_mips_tdep): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-rdp.c (handle_swi): Likewise.
* remote-vx.c (vx_load_command): Likewise.
* sh-tdep.c (sh_do_pseudo_register): Likewise.
* sol-thread.c (td_err_string): Likewise.
* symtab.c (decode_line_2): Likewise.
-------------------------------------------------------------------
@
text
@d4 2
a5 1
   Copyright (C) 1992, 1996, 1999-2000 Free Software Foundation, Inc.
d1641 2
a1642 1
    internal_error ("catch_exception_raise: unknown exception code %d thread %d",
d3503 2
a3504 1
	  internal_error ("Unknown exception");
d3529 2
a3530 1
	internal_error ("Creating notify port %s", mach_error_string (ret));
d3536 2
a3537 1
	internal_error ("initial move member %s", mach_error_string (ret));
d4507 2
a4508 1
    internal_error ("initial port set %s", mach_error_string (ret));
@


1.5
log
@Protoization.
@
text
@d695 1
a695 1
    error ("Incorrect right extracted, send right to bsd server excpected");
d722 1
a722 1
    error ("Incorrect right extracted, send once excpected for exec reply");
d1543 1
a1543 1
    error ("thread id excpected");
@


1.4
log
@2000-08-09  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * blockframe.c (sigtramp_saved_pc): Use dynamic allocation,
        since TARGET_PTR_BIT is no longer a constant (MULTI_ARCH).
        * irix4-nat.c (get_longjmp_target): Ditto.
        * irix5-nat.c (get_longjmp_target): Ditto.
        * jv-valprint.c (java_value_print): Ditto.
        * m3-nat.c (get_cprocs):            Ditto.
        * m68k-tdep.c (get_longjmp_target): Ditto.
        * mips-nat.c  (get_longjmp_target): Ditto.
        * mipsv4-nat.c(get_longjmp_target): Ditto.
        * pa64solib.c (read_dynamic_info):  Ditto.
        * solib.c (elf_locate_base):        Ditto.
@
text
@d2013 2
a2014 1
/* Return 0 on failure, number of bytes handled otherwise.  */
d2016 2
a2017 6
m3_xfer_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *target;	/* IGNORED */
d2139 1
a2139 3
fetch_thread_info (task, mthreads_out)
     mach_port_t task;
     gdb_thread_t *mthreads_out;	/* out */
@


1.3
log
@Protoization.
@
text
@d2463 1
a2463 1
  char *buf[TARGET_PTR_BIT / HOST_CHAR_BIT];
d2468 1
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d210 1
a210 3
xx_debug (fmt, a, b, c)
     char *fmt;
     int a, b, c;
d319 1
a319 4
port_chain_insert (list, name, type)
     port_chain_t list;
     mach_port_t name;
     int type;
d361 1
a361 3
port_chain_delete (list, elem)
     port_chain_t list;
     mach_port_t elem;
d378 1
a378 2
port_chain_destroy (ostack)
     struct obstack *ostack;
d385 1
a385 3
port_chain_member (list, elem)
     port_chain_t list;
     mach_port_t elem;
d397 1
a397 3
map_port_name_to_mid (name, type)
     mach_port_t name;
     int type;
d436 1
a436 2
discard_single_step (thread)
     thread_t thread;
d445 1
a445 3
setup_single_step (thread, start_step)
     thread_t thread;
     boolean_t start_step;
d533 1
a533 4
request_notify (name, variant, type)
     mach_port_t name;
     mach_msg_id_t variant;
     int type;
d559 1
a559 3
reverse_msg_bits (msgp, type)
     mach_msg_header_t *msgp;
     int type;
d595 1
a595 1
m3_trace_me ()
d626 1
a626 2
intercept_exec_calls (exec_counter)
     int exec_counter;
d860 1
a860 3
consume_send_rights (thread_list, thread_count)
     thread_array_t thread_list;
     int thread_count;
d876 1
a876 3
setup_thread (thread, what)
     mach_port_t thread;
     int what;
d896 1
a896 4
map_slot_to_mid (slot, threads, thread_count)
     int slot;
     thread_array_t threads;
     int thread_count;
d937 1
a937 4
parse_thread_id (arg, thread_count, slots)
     char *arg;
     int thread_count;
     int slots;
d997 1
a997 4
select_thread (task, thread_id, flag)
     mach_port_t task;
     int thread_id;
     int flag;
d1113 1
a1113 2
switch_to_thread (new_thread)
     thread_t new_thread;
d1136 1
a1136 2
m3_trace_him (pid)
     int pid;
d1173 1
a1173 1
setup_exception_port ()
d1236 1
a1236 3
mach_really_wait (pid, ourstatus)
     int pid;
     struct target_waitstatus *ourstatus;
d1356 1
a1356 1
mach3_quit ()
d1400 1
a1400 1
mach3_request_quit ()
d1413 1
a1413 2
gdb_message_server (InP)
     mach_msg_header_t *InP;
d1460 1
a1460 1
stop_inferior_gdb ()
d1505 1
a1505 2
mach_thread_for_breakpoint (mid)
     int mid;
d1539 1
a1539 2
mach_thread_parse_id (arg)
     char *arg;
d1552 1
a1552 2
mach_thread_output_id (mid)
     int mid;
d1576 1
a1576 2
mach3_prepare_to_proceed (select_it)
     int select_it;
d1613 2
a1614 5
catch_exception_raise (port, thread, task, exception, code, subcode)
     mach_port_t port;
     thread_t thread;
     task_t task;
     int exception, code, subcode;
d1754 1
a1754 3
port_valid (port, mask)
     mach_port_t port;
     int mask;
d1777 1
a1777 4
mach3_read_inferior (addr, myaddr, length)
     CORE_ADDR addr;
     char *myaddr;
     int length;
d1855 1
a1855 4
mach3_write_inferior (addr, myaddr, length)
     CORE_ADDR addr;
     char *myaddr;
     int length;
d2034 1
a2034 2
translate_state (state)
     int state;
d2054 1
a2054 2
translate_cstate (state)
     int state;
d2076 1
a2076 3
map_inferior_port_name (inferior_name, type)
     mach_port_t inferior_name;
     mach_msg_type_name_t type;
d2114 1
a2114 3
get_thread_name (one_cproc, id)
     gdb_thread_t one_cproc;
     int id;
d2217 1
a2217 2
fetch_usp_from_emulator_stack (sp)
     CORE_ADDR sp;
d2245 1
a2245 2
have_emulator_p (task)
     task_t task;
d2293 2
a2294 4
map_cprocs_to_kernel_threads (cprocs, mthreads, thread_count)
     gdb_thread_t cprocs;
     gdb_thread_t mthreads;
     int thread_count;
d2410 1
a2410 3
print_tl_address (stream, pc)
     struct ui_file *stream;
     CORE_ADDR pc;
d2431 1
a2431 2
lookup_address_of_variable (name)
     char *name;
d2458 1
a2458 1
get_cprocs ()
d2572 1
a2572 2
mach3_cproc_state (mthread)
     gdb_thread_t mthread;
d2609 1
a2609 1
thread_list_command ()
d2828 1
a2828 3
thread_select_command (args, from_tty)
     char *args;
     int from_tty;
d2865 1
a2865 3
thread_trace (thread, set)
     mach_port_t thread;
     boolean_t set;
d2911 1
a2911 2
flush_inferior_icache (pc, amount)
     CORE_ADDR pc;
d2929 1
a2929 2
suspend_all_threads (from_tty)
     int from_tty;
d2981 1
a2981 3
thread_suspend_command (args, from_tty)
     char *args;
     int from_tty;
d3030 1
a3030 2
resume_all_threads (from_tty)
     int from_tty;
d3083 1
a3083 3
thread_resume_command (args, from_tty)
     char *args;
     int from_tty;
d3142 1
a3142 3
thread_kill_command (args, from_tty)
     char *args;
     int from_tty;
d3204 1
a3204 3
task_resume_command (args, from_tty)
     char *args;
     int from_tty;
d3248 1
a3248 3
task_suspend_command (args, from_tty)
     char *args;
     int from_tty;
d3277 1
a3277 2
get_size (bytes)
     int bytes;
d3292 1
a3292 3
task_info_command (args, from_tty)
     char *args;
     int from_tty;
d3369 1
a3369 3
exception_command (args, from_tty)
     char *args;
     int from_tty;
d3418 1
a3418 2
print_exception_info (exception)
     int exception;
d3436 1
a3436 3
exception_info (args, from_tty)
     char *args;
     int from_tty;
d3456 1
a3456 4
mach3_exception_actions (w, force_print_only, who)
     WAITTYPE *w;
     boolean_t force_print_only;
     char *who;
d3510 1
a3510 2
setup_notify_port (create_new)
     int create_new;
d3555 1
a3555 3
message_port_info (args, from_tty)
     char *args;
     int from_tty;
d3565 1
a3565 3
gdb_register_port (name, port)
     char *name;
     mach_port_t port;
d3617 1
a3617 3
thread_command (arg, from_tty)
     char *arg;
     int from_tty;
d3625 1
a3625 3
task_command (arg, from_tty)
     char *arg;
     int from_tty;
d3631 1
a3631 1
add_mach_specific_commands ()
d3712 1
a3712 3
do_mach_notify_dead_name (notify, name)
     mach_port_t notify;
     mach_port_t name;
d3771 1
a3771 3
do_mach_notify_msg_accepted (notify, name)
     mach_port_t notify;
     mach_port_t name;
d3779 1
a3779 3
do_mach_notify_no_senders (notify, mscount)
     mach_port_t notify;
     mach_port_mscount_t mscount;
d3787 1
a3787 3
do_mach_notify_port_deleted (notify, name)
     mach_port_t notify;
     mach_port_t name;
d3795 1
a3795 3
do_mach_notify_port_destroyed (notify, rights)
     mach_port_t notify;
     mach_port_t rights;
d3803 1
a3803 2
do_mach_notify_send_once (notify)
     mach_port_t notify;
d3815 1
a3815 1
kill_inferior_fast ()
d3840 1
a3840 1
m3_kill_inferior ()
d3849 1
a3849 1
m3_mourn_inferior ()
d3859 1
a3859 4
m3_create_inferior (exec_file, allargs, env)
     char *exec_file;
     char *allargs;
     char **env;
d3870 1
a3870 1
m3_can_run ()
d3878 1
a3878 2
ptrace (a, b, c, d)
     int a, b, c, d;
d3888 1
a3888 4
m3_resume (pid, step, signal)
     int pid;
     int step;
     enum target_signal signal;
d3946 1
a3946 2
task_attach (tid)
     task_t tid;
d3976 1
a3976 1
attach_to_thread ()
d3982 1
a3982 2
mid_attach (mid)
     int mid;
d4003 1
a4003 2
m3_do_attach (pid)
     int pid;
d4039 1
a4039 3
m3_attach (args, from_tty)
     char *args;
     int from_tty;
d4070 1
a4070 1
deallocate_inferior_ports ()
d4126 1
a4126 2
m3_do_detach (signal)
     int signal;
d4173 1
a4173 3
m3_detach (args, from_tty)
     char *args;
     int from_tty;
d4202 1
a4202 1
m3_prepare_to_store ()
d4212 1
a4212 2
m3_files_info (ignore)
     struct target_ops *ignore;
d4220 1
a4220 3
m3_open (arg, from_tty)
     char *arg;
     int from_tty;
d4304 1
a4304 5
name_str (name, buf)

     int name;
     char *buf;

d4329 1
a4329 5
id_str (id, buf)

     int id;
     char *buf;

d4345 1
a4345 2
print_msg (mp)
     mach_msg_header_t *mp;
d4410 1
a4410 4
print_data (p, size, number)

     char *p;

d4444 1
a4444 1
m3_stop ()
d4450 1
a4450 2
m3_pid_to_exec_file (pid)
     int pid;
d4457 1
a4457 1
init_m3_ops ()
d4495 1
a4495 1
_initialize_m3_nat ()
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
   Copyright (C) 1992, 1996, 1999 Free Software Foundation, Inc.
d6 1
a6 1
This file is part of GDB.
d8 14
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d25 1
a25 1
 *	   Computing Centre
d31 2
a32 2
 *	Johannes Helander, Antti Louko, Tero Mononen,
 *	jvh@@cs.hut.fi	   alo@@hut.fi   tmo@@cs.hut.fi
d35 2
a36 2
 *	kivinen@@cs.hut.fi               emcmanus@@gr.osf.org
 *	
d56 1
a56 1
#include "wait.h"
d68 1
a68 1
 *
d73 1
a73 1
#define SIG_UNKNOWN 0	/* Exception that has no matching unix signal */
d117 25
a141 23
typedef struct gdb_thread {
  mach_port_t	name;
  CORE_ADDR	sp;
  CORE_ADDR	pc;
  CORE_ADDR	fp;
  boolean_t     in_emulator;
  int		slotid;

  /* This is for the mthreads list.  It points to the cproc list.
     Perhaps the two lists should be merged (or perhaps it was a mistake
     to make them both use a struct gdb_thread).  */
  struct gdb_thread *cproc;

  /* These are for the cproc list, which is linked through the next field
     of the struct gdb_thread.  */
  char raw_cproc[CPROC_SIZE];
  /* The cthread which is pointed to by the incarnation field from the
     cproc.  This points to the copy we've read into GDB.  */
  cthread_t cthread;
  /* Point back to the mthreads list.  */
  int reverse_map;
  struct gdb_thread *next;
} *gdb_thread_t;
d152 36
a187 13
struct exception_list {
  char *name;
  boolean_t forward;
  boolean_t print;
  int       sigmap;
} exception_map[] = {
  {"not_mach3_exception",	FALSE, TRUE,  SIG_UNKNOWN},
  {"EXC_BAD_ACCESS",		FALSE, TRUE,  SIGSEGV},
  {"EXC_BAD_INSTRUCTION",	FALSE, TRUE,  SIGILL},
  {"EXC_ARITHMETIC",		FALSE, TRUE,  SIGFPE},
  {"EXC_EMULATION",		FALSE, TRUE,  SIGEMT},	/* ??? */
  {"EXC_SOFTWARE",		FALSE, TRUE,  SIG_UNKNOWN},
  {"EXC_BREAKPOINT",		FALSE, FALSE, SIGTRAP}
d191 1
a191 1
int max_exception = sizeof(exception_map)/sizeof(struct exception_list) - 1;
d201 1
a201 1
/* #define DUMP_SYSCALL		/* debugging interceptor */
d210 3
a212 3
xx_debug (fmt, a,b,c)
char *fmt;
int a,b,c;
d219 1
a219 1
extern  mach_port_t  name_server_port;
d233 1
a233 1
task_t   inferior_task;
d237 1
a237 1
mach_port_t inferior_exception_port     = MACH_PORT_NULL;
d241 2
a242 2
mach_port_t inferior_wait_port_set	= MACH_PORT_NULL;
mach_port_t our_notify_port       	= MACH_PORT_NULL;
d249 1
a249 1
mach_port_t currently_waiting_for	= MACH_PORT_NULL;
d264 1
a264 1
mach_port_t our_message_port       	= MACH_PORT_NULL;
d267 1
a267 1
mach_port_t thread_exception_port 	= MACH_PORT_NULL;
d269 1
a269 1
mach_port_t singlestepped_thread_port   = MACH_PORT_NULL;
d273 1
a273 1
mach_port_t mid_auth   = MACH_PORT_NULL;
d287 1
a288 1

d299 8
a306 7
struct port_chain {
  struct port_chain *next;
  mach_port_t	     port;
  int		     type;
  int		     mid;  /* Now only valid with MACH_TYPE_THREAD and */
  			   /*  MACH_TYPE_THREAD */
};
d324 1
a324 1
     int	 type;
d330 1
a330 1
  if (! MACH_PORT_VALID (name))
d332 1
a332 1
  
d335 1
a335 1
      if (! MACH_PORT_VALID (mid_server))
d344 1
a344 1
	  
d357 4
a360 4
  new->next  = list;
  new->port  = name;
  new->type  = type;
  new->mid   = mid;
d377 1
a377 1
	    list->next = list->next->next; /* GCd with obstack_free() */
d408 2
a409 2
mach_port_t name;
int         type;
d420 1
a420 1
  
d423 2
a424 2
  
  if (! MACH_PORT_VALID (mid_server))
d436 1
a436 1
      
d459 1
a459 1
     thread_t  thread;
d464 1
a464 1
  if (! MACH_PORT_VALID (thread))
d473 1
a473 1
	  
d482 1
a482 1
      
d495 1
a495 1
	      ret = mach_port_move_member (mach_task_self(), 
d503 1
a503 1
	  
d505 3
a507 3
	  
	  singlestepped_thread_port   = thread_exception_port;
	  currently_waiting_for       = singlestepped_thread_port;
d512 1
a512 1
	  if (! MACH_PORT_VALID (teport))
d517 1
a517 1
	  
d522 1
a522 1
	  ret = mach_port_move_member (mach_task_self(), 
d527 1
a527 1
#endif	  
d532 1
a532 1
	  
d536 1
a536 1
	  
d538 1
a538 1
	  
d549 3
a551 3
     mach_port_t	name;
     mach_msg_id_t	variant;
     int	        type;
d554 3
a556 3
  mach_port_t	previous_port_dummy = MACH_PORT_NULL;
  
  if (! MACH_PORT_VALID (name))
d558 1
a558 1
  
d562 1
a562 1
  ret = mach_port_request_notification (mach_task_self(),
d577 2
a578 2
reverse_msg_bits(msgp, type)
     mach_msg_header_t	*msgp;
d581 2
a582 2
  int		rbits,lbits;
  rbits = MACH_MSGH_BITS_REMOTE(msgp->msgh_bits);
d586 1
a586 1
      MACH_MSGH_BITS(lbits,rbits);
d591 2
a592 2
   	Let this be global
	and then it was global.
d618 1
a618 1
  
d629 1
a629 1
  
d651 6
a656 5
  struct syscall_msg_t {
    mach_msg_header_t	header;
    mach_msg_type_t 	type;
    char room[ 2000 ];	/* Enuff space */
  };
d673 6
a678 1
    return;		/* We are already set up in the correct program */
a679 5
  ret = mach_port_allocate(mach_task_self(), 
			   MACH_PORT_RIGHT_RECEIVE,
			   &fake_server);
  CHK("create inferior_fake_server port failed", ret);
  
d681 1
a681 1
  while(1)
d686 1
a686 1
		       (task_info_t)&info,
d696 1
a696 1
      (void) swtch_pri (42); /* Universal Priority Value */
d713 2
a714 2
  CHK("mach_port_extract_right (bsd server send)",ret);
  
d716 1
a716 1
    error("Incorrect right extracted, send right to bsd server excpected");
d722 1
a722 1
  CHK("mach_port_insert_right (fake server send)",ret);
d729 5
a733 5
  ret = mach_port_allocate(mach_task_self(), 
			   MACH_PORT_RIGHT_RECEIVE,
			   &exec_reply);
  CHK("create intercepted_reply_port port failed", ret);
    
d740 1
a740 1
  CHK("mach_port_extract_right (exec_reply)",ret);
d743 1
a743 1
    error("Incorrect right extracted, send once excpected for exec reply");
d745 3
a747 3
  ret = mach_port_move_member(mach_task_self(), 
			      fake_server,
			      inferior_wait_port_set);
d751 1
a751 1
  
d753 2
a754 2
  CHK("task_resume (startup)", ret);
	
d758 1
a758 1
  while(exec_counter > 0)
d761 4
a764 4
		      MACH_RCV_MSG,		/* options */
		      0,			/* send size */
		      sizeof (struct syscall_msg_t), /* receive size */
		      inferior_wait_port_set,        /* receive_name */
d767 2
a768 2
      CHK("mach_msg (intercepted sycall)", ret);
	    
d790 2
a791 2
		 process group.  On POSIX systems, tcsetpgrp will fail with
		 EPERM if we try it before the child's setpgid.  */
d794 1
a794 1
		 based on what modes we are starting it with.  */
d805 2
a806 2
	    
      syscall_in.header.msgh_local_port  = syscall_in.header.msgh_remote_port;
d809 1
a809 1
      reverse_msg_bits(&syscall_in.header, MACH_MSG_TYPE_COPY_SEND);
d814 4
a817 4
	
  ret = mach_port_move_member(mach_task_self(), 
			      fake_server,
			      MACH_PORT_NULL);
d820 3
a822 3
  ret = mach_port_move_member(mach_task_self(), 
			      exec_reply,
			      inferior_wait_port_set);
d826 2
a827 2
		  MACH_RCV_MSG,		/* options */
		  0,			/* send size */
d829 1
a829 1
		  inferior_wait_port_set,		/* receive_name */
d832 1
a832 1
  CHK("mach_msg (exec reply)", ret);
d842 1
a842 1
      print_msg (&syscall_in.header);
d851 1
a851 1
  reverse_msg_bits(&syscall_in.header, MACH_MSG_TYPE_MOVE_SEND_ONCE);
d870 1
a870 1
  CHK("mach_port_destroy (fake_server)", ret);
d875 1
a875 1
  CHK("mach_port_destroy (exec_reply)", ret);
d883 1
a883 1
     int            thread_count;
d894 1
a894 1
				   thread_list [ index ]);
d909 1
a909 1
      
d931 1
a931 1
  if (! threads)
d937 1
a937 1
  
d943 2
a944 2
	  (void) vm_deallocate (mach_task_self(), (vm_address_t)threads, 
				(thread_count * sizeof(mach_port_t)));
d949 1
a949 1
	return -(slot+1);
d952 1
a952 1
  mid = map_port_name_to_mid (threads [slot], MACH_TYPE_THREAD);
d957 2
a958 2
      (void) vm_deallocate (mach_task_self(), (vm_address_t)threads, 
			    (thread_count * sizeof(mach_port_t)));
d974 1
a974 1
  
d977 1
a977 1
  
d980 2
a981 2
  
  if (! *arg)
d983 1
a983 1
  
d992 1
a992 1
  
d1000 1
a1000 1
   *
d1006 1
a1006 1
    return -(slot+1);
d1009 1
a1009 1
    return -(slot+1);
d1012 1
a1012 1
  
d1059 3
a1061 3
      (void) vm_deallocate(mach_task_self(),
			   (vm_address_t) thread_list,
			   (thread_count * sizeof(mach_port_t)));
d1065 1
a1065 1
  if (! thread_id || flag == 2)
d1068 1
a1068 1
      if (! thread_id)
d1073 1
a1073 1
	    new_thread = thread_list[ thread_id ];
d1076 3
a1078 3
	      (void) vm_deallocate(mach_task_self(),
				   (vm_address_t) thread_list,
				   (thread_count * sizeof(mach_port_t)));
d1086 1
a1086 1
	if (thread_id == map_port_name_to_mid (thread_list [index],
d1089 1
a1089 1
	    new_thread = thread_list [index];
d1093 1
a1093 1
      
d1097 1
a1097 1
  
d1100 4
a1103 4
  
  ret = vm_deallocate(mach_task_self(),
		      (vm_address_t) thread_list,
		      (thread_count * sizeof(mach_port_t)));
d1105 2
a1106 2
  
  if (! flag)
d1114 1
a1114 1
	   *
d1133 1
a1133 1
      stop_pc = read_pc();
d1163 1
a1163 1
	
d1180 1
a1180 1
  if (! MACH_PORT_VALID (inferior_task))
d1213 1
a1213 1
  ret = mach_port_allocate (mach_task_self(), 
d1216 1
a1216 1
  CHK("mach_port_allocate",ret);
d1223 1
a1223 1
  CHK("mach_port_insert_right",ret);
d1225 1
a1225 1
  ret = mach_port_move_member (mach_task_self(), 
d1228 1
a1228 1
  CHK("mach_port_move_member",ret);
d1230 1
a1230 1
  ret = task_get_special_port (inferior_task, 
d1233 1
a1233 1
  CHK ("task_get_special_port(old exc)",ret);
d1236 1
a1236 1
			       TASK_EXCEPTION_PORT, 
d1238 1
a1238 1
  CHK("task_set_special_port",ret);
d1242 1
a1242 1
  CHK("mack_port_deallocate",ret);
d1264 1
a1264 1
     (e.g. we receive a single step trace trap)
d1279 7
a1285 5
  struct msg {
    mach_msg_header_t    header;
    mach_msg_type_t foo;
    int             data[8000];
  } in_msg, out_msg;
d1298 3
a1300 3
      ret = mach_msg (&in_msg.header,		/* header */
		      MACH_RCV_MSG,		/* options */
		      0,			/* send size */
d1306 1
a1306 1
      CHK("mach_msg (receive)", ret);
d1321 1
a1321 1
	      wait3(&w, WNOHANG, 0);
d1330 2
a1331 2
	      if ((!WIFEXITED(w) && WIFSTOPPED(w))         ||
		  (WIFEXITED(w)  && WEXITSTATUS(w) > 0377))
d1333 1
a1333 1
		  WSETEXIT(w, 0);
d1336 1
a1336 1
	      else if (!WIFEXITED(w))
d1338 1
a1338 1
		  int sig = WTERMSIG(w);
d1341 1
a1341 1
		  if (sig != SIGKILL) /* Bad luck if garbage matches this */
d1345 1
a1345 1
		      WSETEXIT(w, 0);
d1355 3
a1357 3
	 exc_server() does an upcall to catch_exception_raise()
	 if this rpc is an exception. Further actions are decided
	 there.
d1359 1
a1359 1
      if (! exc_server (&in_msg.header, &out_msg.header))
d1363 1
a1363 1
	   *
d1376 1
a1376 1
      
d1380 1
a1380 1
	  wait3(&w, WNOHANG, 0);
d1398 1
a1398 1
  
d1402 1
a1402 1
      
d1422 1
a1422 1
  current_thread = MACH_PORT_NULL; /* Force setup */
d1442 1
a1442 1
}      
d1460 2
a1461 1
      switch (InP->msgh_id) {
d1463 5
a1467 5
      case GDB_MESSAGE_ID_STOP:
	ret = task_suspend (inferior_task);
	if (ret != KERN_SUCCESS)
	  warning ("Could not suspend task for stop message: %s",
		   mach_error_string (ret));
d1469 9
a1477 9
	/* QUIT in mach_really_wait() loop. */
	request_quit (0);
	break;

      default:
	warning ("Invalid message id %d received, ignored.",
		 InP->msgh_id);
	break;
      }
d1487 1
a1487 1
 *
d1504 1
a1504 1
   *
d1508 5
a1512 3
  typedef struct {
    mach_msg_header_t Head;
  } Request;
d1518 1
a1518 1
  InP->Head.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0);
d1522 3
a1524 3
  InP->Head.msgh_local_port  = MACH_PORT_NULL;
  InP->Head.msgh_seqno       = 0;
  InP->Head.msgh_id          = GDB_MESSAGE_ID_STOP;
d1527 2
a1528 2
		  MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
		  sizeof(Request),
d1551 1
a1551 1
      mid = map_slot_to_mid (-(mid+1), 0, 0);
d1556 2
a1557 2
  if (! mid || cmid == -1)
    return 1;	/* stop */
d1596 1
a1596 1
  static char foobar [20];
d1601 1
a1601 1
    sprintf (foobar, "@@%d", -(mid+1));
d1610 1
a1610 1
 *
d1627 1
a1627 1
      if (! select_it)
d1643 2
a1644 2
     - The task that signaled is not the inferior task
       (e.g. when debugging another debugger)
d1646 7
a1652 7
     - The user has explicitely requested to pass on the exceptions.
       (e.g to the default unix exception handler, which maps
	exceptions to signals, or the user has her own exception handler)

     - If the thread that signaled is being single-stepped and it
       has set it's own exception port and the exception is not
       EXC_BREAKPOINT. (Maybe this is not desirable?)
d1666 1
a1666 1
  if (! MACH_PORT_VALID (thread))
d1669 1
a1669 1
	 receive it, THREAD will be MACH_PORT_DEAD
d1679 1
a1679 1
  if (! MACH_PORT_VALID (task))
d1686 3
a1688 3
    fatal ("catch_exception_raise: unknown exception code %d thread %d",
	   exception,
	   mid);
d1690 1
a1690 1
  if (! MACH_PORT_VALID (inferior_task))
d1692 1
a1692 1
  
d1694 7
a1700 7
  stop_code      = code;
  stop_subcode   = subcode;  
  stop_thread    = thread;
  
  signal_thread = exception != EXC_BREAKPOINT       &&
    		  port == singlestepped_thread_port &&
		  MACH_PORT_VALID (thread_saved_exception_port);
d1708 2
a1709 2
      signal_thread         ||
      exception_map [exception].forward)
d1716 3
a1718 3
	    GDB now forwards the exeption to thread's original handler,
	    since the user propably knows what he is doing.
	    Give a message, though.
d1721 1
a1721 1
	  mach3_exception_actions ((WAITTYPE *)NULL, TRUE, "Thread");
d1727 1
a1727 1
			     thread, 
d1744 1
a1744 1
  
d1760 1
a1760 1
      
d1781 1
a1781 1
	  if (! MACH_PORT_VALID (current_thread))
d1783 1
a1783 1
	
d1792 1
a1792 1
  
d1801 2
a1802 2
  mach_port_t port;
  int         mask;
d1831 5
a1835 5
  vm_address_t low_address       = (vm_address_t) trunc_page (addr);
  vm_size_t    aligned_length = 
    			(vm_size_t) round_page (addr+length) - low_address;
  pointer_t    copied_memory;
  int	       copy_count;
d1852 1
a1852 1
      if (! port_valid (inferior_task, MACH_PORT_TYPE_SEND))
d1873 1
a1873 1
  memcpy (myaddr, (char *)addr - low_address + copied_memory, length);
d1878 1
a1878 1
  CHK("mach3_read_inferior vm_deallocate failed", ret);
d1891 2
a1892 1
struct vm_region_list {
d1894 3
a1896 3
  vm_prot_t	protection;
  vm_address_t  start;
  vm_size_t	length;
d1899 1
a1899 1
struct obstack  region_obstack;
d1912 6
a1917 6
  vm_address_t low_address       = (vm_address_t) trunc_page (addr);
  vm_size_t    aligned_length = 
    			(vm_size_t) round_page (addr+length) - low_address;
  pointer_t    copied_memory;
  int	       copy_count;
  int	       deallocate = 0;
d1919 1
a1919 1
  char         *errstr = "Bug in mach3_write_inferior";
d1922 1
a1922 1
  struct vm_region_list *region_head = (struct vm_region_list *)NULL;
d1934 1
a1934 1
  memcpy ((char *)addr - low_address + copied_memory, myaddr, length);
d1942 2
a1943 2
    vm_size_t    remaining_length  = aligned_length;
    vm_address_t region_address    = low_address;
d1947 1
a1947 1
    while(region_address < low_address + aligned_length)
d1955 3
a1957 3
	vm_size_t   region_length = remaining_length;
	vm_address_t old_address  = region_address;
    
d1989 1
a1989 1
	region_element = 
d1991 2
a1992 2
	    obstack_alloc (&region_obstack, sizeof (struct vm_region_list));
    
d1994 2
a1995 2
	region_element->start      = region_address;
	region_element->length     = region_length;
d1999 2
a2000 2
	region_head          = region_element;
	
d2008 1
a2008 1
    
d2013 1
a2013 1
	
d2030 1
a2030 1
	
d2035 1
a2035 1
	
d2048 1
a2048 1
 out:
d2052 1
a2052 1
      
d2081 1
a2081 1
    result = mach3_read_inferior  (memaddr, myaddr, len);
d2085 1
a2086 1

d2088 2
a2089 2
translate_state(state)
int	state;
d2091 15
a2105 8
  switch (state) {
  case TH_STATE_RUNNING:	return("R");
  case TH_STATE_STOPPED:	return("S");
  case TH_STATE_WAITING:	return("W");
  case TH_STATE_UNINTERRUPTIBLE: return("U");
  case TH_STATE_HALTED:		return("H");
  default:			return("?");
  }
d2114 12
a2125 6
    case CPROC_RUNNING:	return "R";
    case CPROC_SWITCHING: return "S";
    case CPROC_BLOCKED: return "B";
    case CPROC_CONDWAIT: return "C";
    case CPROC_CONDWAIT|CPROC_SWITCHING: return "CS";
    default: return "?";
d2131 1
a2131 1
mach_port_t           /* no mach_port_name_t found in include files. */
d2136 1
a2136 1
  kern_return_t        ret;
d2138 2
a2139 2
  mach_port_t          iport;
  
d2145 1
a2145 1
  CHK("mach_port_extract_right (map_inferior_port_name)", ret);
d2148 1
a2148 1
    error("Incorrect right extracted, (map_inferior_port_name)");
d2180 1
a2180 1
	sprintf(buf, "_C%d", id);
d2182 1
a2182 1
    else if (! one_cproc->cthread->name)
d2185 1
a2185 1
	sprintf(buf, "_t%d", id);
d2188 1
a2188 1
      return (char *)(one_cproc->cthread->name);
d2195 1
a2195 1
      sprintf(buf, "_K%d", id);
d2203 2
a2204 2
     mach_port_t	task;
     gdb_thread_t	*mthreads_out;	/* out */
d2206 1
a2206 1
  kern_return_t  ret;
d2208 1
a2208 1
  int		 th_count;
d2210 1
a2210 1
  int 		 index;
d2216 1
a2216 1
	       mach_error_string(ret));
d2220 1
a2220 1
  
d2222 3
a2224 3
    		obstack_alloc
		  (cproc_obstack,
		   th_count * sizeof (struct gdb_thread));
d2232 1
a2232 1
	setup_thread (th_table[ index ], 1);
d2237 2
a2238 2
	  
	  mid = switch_to_thread (th_table[ index ]);
d2241 1
a2241 1
      mthreads[index].name  = th_table[index];
d2245 1
a2245 1
      
d2254 1
a2254 1
	setup_thread (th_table[ index ], 0);
d2256 1
a2256 1
  
d2258 2
a2259 2
  ret = vm_deallocate (mach_task_self(), (vm_address_t)th_table, 
		       (th_count * sizeof(mach_port_t)));
d2282 3
a2284 3
  sp = (sp & ~(EMULATOR_STACK_SIZE-1)) +
    	EMULATOR_STACK_SIZE - sizeof (struct emul_stack_top);
  
d2309 1
a2309 1
  kern_return_t	ret;
d2311 2
a2312 2
  vm_offset_t	*emulation_vector;
  int		n;
d2314 2
a2315 2
  vm_offset_t	emulation_vector[ EMUL_VECTOR_COUNT ];
  int		n = EMUL_VECTOR_COUNT;
d2317 3
a2319 3
  int		i;
  int		vector_start;
  
d2328 1
a2328 1
  CHK("task_get_emulation_vector", ret);
d2331 2
a2332 2
  
  for(i = 0; i < n; i++)
d2334 1
a2334 1
      vm_offset_t entry = emulation_vector [i];
d2343 2
a2344 2
	      warning("Emulation vector address 0x08%x outside emulator space",
		      entry);
d2377 1
a2377 1
	  stack_size = 
d2404 1
a2404 1
   */ 
d2413 1
a2413 1
	  gdb_thread_t mthread = (mthreads+index);
d2420 1
a2420 1
	      
d2424 1
a2424 1
		  
d2426 1
a2426 1
		  if (! usp)
d2428 1
a2428 1
		  
d2434 1
a2434 1
		      
d2443 3
a2445 3
			      (scan->raw_cproc + CPROC_BASE_OFFSET,
			       CPROC_BASE_SIZE);
			  stack_size = 
d2447 2
a2448 2
			      (scan->raw_cproc + CPROC_SIZE_OFFSET,
			       CPROC_SIZE_SIZE);
d2467 1
a2467 1
 * 	             slot mid sel   name  emul ks susp  cstate wired   address
d2475 1
a2475 1
     GDB_FILE *stream;
d2478 2
a2479 2
  if (! lookup_minimal_symbol_by_pc (pc))
    fprintf_filtered (stream, local_hex_format(), pc);
d2485 1
a2485 1
      int store    = addressprint;
d2505 1
a2505 1
		       (struct block *)NULL,
d2507 2
a2508 2
		       (int *)NULL,
		       (struct symtab **)NULL);
d2513 1
a2513 1
  if (! symaddr)
d2525 1
a2525 1
get_cprocs()
d2534 1
a2534 1
  
d2537 1
a2537 1
  if (! symaddr)
d2540 1
a2540 1
	 symbols, but don't give up yet */
d2558 1
a2558 1
  if (! symaddr)
d2574 1
a2574 1
  while (their_cprocs != (CORE_ADDR)0)
d2583 1
a2583 1
	error("Can't read next cproc at 0x%x.", their_cprocs);
d2592 1
a2592 1
      if (cproc_copy_incarnation == (CORE_ADDR)0)
d2597 2
a2598 2
	  cthread = (cthread_t)obstack_alloc (cproc_obstack,
					      sizeof(struct cthread));
d2602 3
a2604 3
				    sizeof(struct cthread)))
	    error("Can't read next thread at 0x%x.",
		  cproc_copy_incarnation);
d2612 2
a2613 2
	      if (!mach3_read_inferior(cthread->name, name, MAX_NAME_LEN))
		error("Can't read next thread's name at 0x%x.", cthread->name);
d2644 1
a2644 1
  if (! mthread || !mthread->cproc)
d2674 1
a2675 1

d2677 1
a2677 1
thread_list_command()
d2680 1
a2680 1
  int     thread_count;
d2683 9
a2691 9
  int     index;
  char   *name;
  char    selected;
  char   *wired;
  int     infoCnt;
  kern_return_t ret;
  mach_port_t   mid_or_port;
  gdb_thread_t  their_threads;
  gdb_thread_t  kthread;
d2696 1
a2696 1
  
d2698 1
a2698 1
  
d2700 1
a2700 1
  
d2705 1
a2705 1
  
d2708 1
a2708 1
  
d2710 1
a2710 1
  
d2712 3
a2714 3
  
  cprocs = get_cprocs();
  
d2716 1
a2716 1
  
d2723 3
a2725 3
	extract_signed_integer
	  (scan->raw_cproc + CPROC_STATE_OFFSET, CPROC_STATE_SIZE);
      
d2727 1
a2727 1
      
d2734 1
a2734 1
	kthread  = (their_threads + scan->reverse_map);
d2736 1
a2736 1
	kthread  = NULL;
d2741 1
a2741 1
	  
d2743 1
a2743 1
	  
d2745 1
a2745 1
	  
d2748 1
a2748 1
			     (thread_info_t)&ths,
d2750 1
a2750 1
	  
d2760 1
a2760 1
	  sprintf (slot, "%d", kthread->slotid%100);
d2764 1
a2764 1
	  
d2802 1
a2802 1
	    continue; /* EMcM */
d2826 1
a2826 1
  
d2830 1
a2830 1
      if (! their_threads[index].cproc)
d2833 1
a2833 1
	  
d2838 1
a2838 1
	  
d2840 1
a2840 1
	  
d2842 6
a2847 6
	  
	  ret = thread_info(name,
			    THREAD_BASIC_INFO,
			    (thread_info_t)&ths,
			    &infoCnt);
	    
d2856 1
a2856 1
	  sprintf (slot, "%d", index%100);
d2884 1
a2884 1
			   "",   /* No cproc state */
d2890 1
a2890 1
  
d2896 1
a2896 1
thread_select_command(args, from_tty)
d2920 1
a2920 1
  mid = atoi(args);
d2923 1
a2923 1
    if (!is_slot || *args != '0') /* Rudimentary checks */
d2926 1
a2926 1
  if (select_thread (inferior_task, mid, is_slot?2:1) != KERN_SUCCESS)
d2932 1
a2932 1
						     MACH_TYPE_THREAD) : mid);
d2936 2
a2937 2
mach_port_t thread;
boolean_t   set;
d2939 4
a2942 4
  int			flavor   = TRACE_FLAVOR;
  unsigned int		stateCnt = TRACE_FLAVOR_SIZE;
  kern_return_t		ret;
  thread_state_data_t	state;
d2944 1
a2944 1
  if (! MACH_PORT_VALID (thread))
d2953 1
a2953 1
  ret = thread_get_state(thread, flavor, state, &stateCnt);
d2955 1
a2955 1
  
d2962 1
a2962 1
      if (! TRACE_CLEAR (thread, state))
d2970 1
a2970 1
  ret = thread_set_state(thread, flavor, state, stateCnt);
d2974 1
a2974 1
}  
d2983 1
a2983 1
flush_inferior_icache(pc, amount)
d2987 2
a2988 2
  kern_return_t   ret;
  
d2998 2
a2999 1
#endif	FLUSH_INFERIOR_CACHE
a3000 1

d3005 4
a3008 4
  kern_return_t	   ret;
  thread_array_t   thread_list;
  int		   thread_count, index;
  int		   infoCnt;
d3011 1
a3011 1
  
d3019 1
a3019 1
  
d3024 1
a3024 1
      mid = map_port_name_to_mid (thread_list[ index ],
d3026 2
a3027 2
	  
      ret = thread_suspend(thread_list[ index ]);
d3036 1
a3036 1
	  ret = thread_info (thread_list[ index ],
d3038 1
a3038 1
			     (thread_info_t) &th_info,
d3041 1
a3041 1
	  
d3048 3
a3050 3
  ret = vm_deallocate(mach_task_self(),
		      (vm_address_t)thread_list, 
		      (thread_count * sizeof(int)));
d3060 3
a3062 3
  int           mid;
  mach_port_t   saved_thread;
  int           infoCnt;
d3064 1
a3064 1
  
d3067 5
a3071 4
  if (!strcasecmp (args, "all")) {
    suspend_all_threads (from_tty);
    return;
  }
d3082 6
a3087 7
  else
    if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
      {
	if (current_thread)
	  current_thread = saved_thread;
	error ("Could not select thread %d", mid);
      }
d3097 1
a3097 1
		     (thread_info_t) &th_info,
d3100 1
a3100 1
  
d3102 1
a3102 1
  
d3109 22
a3130 6
    kern_return_t  ret;
    thread_array_t thread_list;
    int		   thread_count, index;
    int            mid;
    int		   infoCnt;
    thread_basic_info_data_t th_info;
d3132 2
a3133 6
    ret = task_threads (inferior_task, &thread_list, &thread_count);
    if (ret != KERN_SUCCESS)
      {
	m3_kill_inferior ();
	error("task_threads", mach_error_string( ret));
      }
d3135 6
a3140 18
    for (index = 0; index < thread_count; index++)
      {
	infoCnt = THREAD_BASIC_INFO_COUNT;
	ret = thread_info (thread_list [ index ],
			   THREAD_BASIC_INFO,
			   (thread_info_t) &th_info,
			   &infoCnt);
	CHK ("resume_all can't get thread info", ret);
	
	mid = map_port_name_to_mid (thread_list[ index ],
				    MACH_TYPE_THREAD);
	
	if (! th_info.suspend_count)
	  {
	    if (mid != -1 && from_tty)
	      warning ("Thread %d is not suspended", mid);
	    continue;
	  }
d3142 1
a3142 1
	ret = thread_resume (thread_list[ index ]);
d3144 7
a3150 7
	if (ret != KERN_SUCCESS)
	  warning ("Error trying to resume thread %d : %s",
		   mid, mach_error_string (ret));
	else if (mid != -1 && from_tty)
	  warning ("Thread %d suspend count is %d",
		   mid, --th_info.suspend_count);
      }
d3152 5
a3156 5
    consume_send_rights (thread_list, thread_count);
    ret = vm_deallocate(mach_task_self(),
			(vm_address_t)thread_list, 
			(thread_count * sizeof(int)));
    CHK("Error trying to deallocate thread list", ret);
d3169 1
a3169 1
  
d3172 5
a3176 4
  if (!strcasecmp (args, "all")) {
    resume_all_threads (from_tty);
    return;
  }
d3187 6
a3192 7
  else
    if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
      {
	if (current_thread)
	  current_thread = saved_thread;
	return_to_top_level (RETURN_ERROR);
      }
d3196 1
a3196 1
		     (thread_info_t) &th_info,
d3199 2
a3200 2
  
  if (! th_info.suspend_count)
d3215 2
a3216 2
      
 out:
d3229 1
a3229 1
  int   index;
d3231 2
a3232 2
  
  
d3250 1
a3250 1
      
d3254 1
a3254 1
  
d3265 1
a3265 1
      if (thread_table [ index ] == thread_to_kill)
d3273 3
a3275 3
  
  ret = vm_deallocate (mach_task_self(), (vm_address_t)thread_table, 
		       (thread_count * sizeof(mach_port_t)));
d3277 1
a3277 1
  
d3280 1
a3281 1

d3293 1
a3293 1
  
d3302 1
a3302 1
		   (task_info_t) &ta_info,
d3305 1
a3305 1
  
d3310 1
a3310 1
	   !query ("Suspend count is now 1. Do you know what you are doing? "))
d3321 1
a3321 1
	 suspended! */
d3326 1
a3326 1
	     mid, ta_info.suspend_count-1);
d3339 1
a3339 1
  
d3353 1
a3353 1
		   (task_info_t) &ta_info,
d3356 1
a3356 1
  
d3365 2
a3366 2
  static char size [ 30 ];
  int zz = bytes/1024;
d3369 1
a3369 1
    sprintf (size, "%-2.1f M", ((float)bytes)/(1024.0*1024.0));
d3387 1
a3387 1
  int page_size = round_page(1);
d3389 1
a3389 1
  
d3416 1
a3416 1
		   (task_info_t) &ta_info,
d3428 1
a3428 1
    
d3431 1
a3431 1
    
d3435 4
a3438 4
    ret = vm_deallocate(mach_task_self(),
			(vm_address_t)thread_list, 
			(thread_count * sizeof(int)));
    CHK("Error trying to deallocate thread list", ret);
d3468 3
a3470 2
  while (*scan == ' ' || *scan == '\t') scan++;
  
d3485 2
a3486 1
    while (*scan == ' ' || *scan == '\t') scan++;
d3497 1
a3497 1
    error("exception number action");
d3500 1
a3500 1
    exception_map[ exception ].forward = TRUE;
d3502 1
a3502 1
    exception_map[ exception ].forward = FALSE;
d3511 1
a3511 1
  boolean_t forward = exception_map[ exception ].forward;
d3513 1
a3513 1
  printf_filtered ("%s\t(%d): ", exception_map[ exception ].name,
d3516 1
a3516 1
    if (exception_map[ exception ].sigmap != SIG_UNKNOWN)
d3518 1
a3518 1
		       exception_map[ exception ].sigmap);
d3521 1
a3521 1
		       exception_map[ exception ].sigmap);
d3556 1
a3556 1
  
d3566 1
a3566 1
      
d3570 1
a3570 1
      
d3573 30
a3602 29
      switch(stop_exception) {
      case EXC_BAD_ACCESS:
	printf_filtered ("referencing address 0x%x : %s\n",
			 stop_subcode,
			 mach_error_string (stop_code));
	break;
      case EXC_BAD_INSTRUCTION:
	printf_filtered
	  ("illegal or undefined instruction. code %d subcode %d\n",
	   stop_code, stop_subcode);
	break;
      case EXC_ARITHMETIC:
	printf_filtered ("code %d\n", stop_code);
	break;
      case EXC_EMULATION:
	printf_filtered ("code %d subcode %d\n", stop_code, stop_subcode);
	break;
      case EXC_SOFTWARE:
	printf_filtered ("%s specific, code 0x%x\n",
			 stop_code < 0xffff ? "hardware" : "os emulation",
			 stop_code);
	break;
      case EXC_BREAKPOINT:
	printf_filtered ("type %d (machine dependent)\n",
			 stop_code);
	break;
      default:
	fatal ("Unknown exception");
      }
d3618 1
a3618 1
  notify_chain    = (port_chain_t) NULL;
d3623 1
a3623 1
      ret = mach_port_allocate (mach_task_self(),
d3627 5
a3631 5
	fatal("Creating notify port %s", mach_error_string(ret));
      
      ret = mach_port_move_member(mach_task_self(), 
				  our_notify_port,
				  inferior_wait_port_set);
d3633 1
a3633 1
	fatal("initial move member %s",mach_error_string(ret));
d3649 1
a3649 1
char registered_name[ MAX_NAME_LEN ];
d3672 1
a3672 1
  if (! MACH_PORT_VALID (port) || !name || !*name)
d3678 1
a3678 1
  if (! already_signed)
d3698 1
a3698 1
			  name,			/* Name of service */
d3700 3
a3702 3
			  port); 		/* Creates a new send right */
  CHK("Failed to check in the port", ret);
  
d3704 1
a3704 1
  while(len < MAX_NAME_LEN && *(name+len))
d3706 1
a3706 1
      registered_name[len] = *(name+len);
d3711 1
a3711 1
}  
d3716 1
a3716 1
/*ARGSUSED*/
d3726 1
a3726 1
/*ARGSUSED*/
d3743 2
a3744 2
      "Generic command for handling Mach threads in the debugged task.",
      &cmd_thread_list, "thread ", 0, &cmdlist);
d3748 1
a3748 1
  add_cmd ("select", class_stack, thread_select_command, 
d3751 1
a3751 1
  add_cmd ("list",   class_stack, thread_list_command,
d3774 1
a3774 1
  add_alias_cmd ("tl", "mthread list",   0, 0, &cmdlist);
d3779 2
a3780 2
      "Generic command for handling debugged task.",
      &cmd_task_list, "task ", 0, &cmdlist);
d3829 1
a3829 1
  if (! element)
a3830 2
  
  switch (element->type) {
d3832 26
a3857 9
  case MACH_TYPE_THREAD:
    target_terminal_ours_for_output ();
    if (name == current_thread)
      {
	printf_filtered ("\nCurrent thread %d died", element->mid);
	current_thread = MACH_PORT_NULL;
      }
    else
      printf_filtered ("\nThread %d died", element->mid);
d3859 2
a3860 1
    break;
d3862 2
a3863 17
  case MACH_TYPE_TASK:
    target_terminal_ours_for_output ();
    if (name != inferior_task)
      printf_filtered ("Task %d died, but it was not the selected task",
	       element->mid);
    else	       
      {
	printf_filtered ("Current task %d died", element->mid);
	
	mach_port_destroy (mach_task_self(), name);
	inferior_task = MACH_PORT_NULL;
	
	if (notify_chain)
	  warning ("There were still unreceived dead_name_notifications???");
	
	/* Destroy the old notifications */
	setup_notify_port (0);
d3865 2
a3866 2
      }
    break;
d3868 5
a3872 5
  default:
    error ("Unregistered dead_name 0x%x notification received. Type is %d, mid is 0x%x",
	   name, element->type, element->mid);
    break;
  }
d3947 1
a3947 1
  inferior_task  = MACH_PORT_NULL;
d3970 1
a3971 1

d3997 2
a3998 2
ptrace (a,b,c,d)
int a,b,c,d;
d4013 1
a4013 1
  kern_return_t	ret;
d4018 2
a4019 2
      unsigned int	       infoCnt = THREAD_BASIC_INFO_COUNT;
      
d4023 1
a4023 1
      if (! MACH_PORT_VALID (current_thread))
d4025 1
a4025 1
      
d4030 1
a4030 1
			 (thread_info_t) &th_info,
d4033 1
a4033 1
      
d4040 1
a4040 1
  if (signal && inferior_pid > 0) /* Do not signal, if attached by MID */
d4048 1
a4048 1
      
d4052 1
a4052 1
  
d4058 1
a4058 1
  
d4060 2
a4061 2
  while ((ret = task_resume(inferior_task)) == KERN_SUCCESS)
    /* make sure it really runs */;
d4070 1
a4070 1
  task_t tid;
d4076 1
a4076 1
  CHK("task_attach: task_suspend", ret);
d4085 1
a4085 1
  
d4107 1
a4107 1
    int	mid;
d4109 1
a4109 1
    kern_return_t ret;
d4111 2
a4112 2
    ret = machid_mach_port (mid_server, mid_auth, mid, &inferior_task);
    CHK("mid_attach: machid_mach_port", ret);
d4114 1
a4114 1
    task_attach (inferior_task);
d4116 1
a4116 1
    return mid;
d4134 1
a4134 1
    error("MID=0, Debugging the master unix server does not compute");
d4137 1
a4137 1
  if (pid == getpid())
d4151 2
a4152 2
  if (! MACH_PORT_VALID (inferior_task))
    error("Cannot map Unix pid %d to Mach task port", pid);
d4177 1
a4177 1
  if (pid == getpid())		/* Trying to masturbate? */
d4200 1
a4200 1
  kern_return_t  ret;
d4202 1
a4202 1
  int		 thread_count, index;
d4211 1
a4211 1
	       mach_error_string(ret));
d4223 1
a4223 1
      CHK("deallocate_inferior_ports: get refs", ret);
d4231 1
a4231 1
	  CHK("deallocate_inferior_ports: mod refs", ret);
d4246 1
a4246 1
  inferior_task  = MACH_PORT_NULL;
d4272 1
a4272 1
			       TASK_EXCEPTION_PORT, 
d4281 1
a4281 1
  
d4284 1
a4284 1
  
d4287 1
a4287 1
  
d4289 1
a4289 1
  
d4314 1
a4314 1
	      exec_file, target_pid_to_str (inferior_pid));
d4319 1
a4319 1
  
d4322 1
a4322 1
  unpush_target (&m3_ops);		/* Pop out of handling an inferior */
d4348 1
a4348 1
		       attach_flag? "attached": "child", target_pid_to_str (inferior_pid));
d4366 2
a4367 1
char	*bsd1_names[] = {
d4435 1
a4435 1
int	bsd1_nnames = sizeof(bsd1_names)/sizeof(bsd1_names[0]);
d4437 2
a4438 2
char*
name_str(name,buf)
d4440 2
a4441 2
int	name;
char	*buf;
d4444 20
a4463 19
  switch (name) {
  case MACH_MSG_TYPE_BOOLEAN:
    return "boolean";
  case MACH_MSG_TYPE_INTEGER_16:
    return "short";
  case MACH_MSG_TYPE_INTEGER_32:
    return "long";
  case MACH_MSG_TYPE_CHAR:
    return "char";
  case MACH_MSG_TYPE_BYTE:
    return "byte";
  case MACH_MSG_TYPE_REAL:
    return "real";
  case MACH_MSG_TYPE_STRING:
    return "string";
  default:
    sprintf(buf,"%d",name);
    return buf;
  }
d4467 1
a4467 1
id_str(id,buf)
d4469 2
a4470 2
int	id;
char	*buf;
d4473 6
a4478 5
  char	*p;
  if (id >= 101000 && id < 101000+bsd1_nnames) {
    if (p = bsd1_names[id-101000])
      return p;
  }
d4483 1
a4483 1
  sprintf(buf,"%d",id);
d4487 2
a4488 2
print_msg(mp)
mach_msg_header_t	*mp;
d4490 4
a4493 4
  char	*fmt_x = "%20s : 0x%08x\n";
  char	*fmt_d = "%20s : %10d\n";
  char	*fmt_s = "%20s : %s\n";
  char	buf[100];
d4497 7
a4503 7
  pr(fmt_x,(*mp),msgh_bits);
  pr(fmt_d,(*mp),msgh_size);
  pr(fmt_x,(*mp),msgh_remote_port);
  pr(fmt_x,(*mp),msgh_local_port);
  pr(fmt_d,(*mp),msgh_kind);
  printf_filtered(fmt_s,STR(msgh_id),id_str(mp->msgh_id,buf));
  
d4505 45
a4549 37
  {
    char	*p,*ep,*dp;
    int		plen;
    p = (char*)mp;
    ep = p+mp->msgh_size;
    p += sizeof(*mp);
    for(; p < ep; p += plen) {
      mach_msg_type_t	*tp;
      mach_msg_type_long_t	*tlp;
      int	name,size,number;
      tp = (mach_msg_type_t*)p;
      if (tp->msgt_longform) {
	tlp = (mach_msg_type_long_t*)tp;
	name = tlp->msgtl_name;
	size = tlp->msgtl_size;
	number = tlp->msgtl_number;
	plen = sizeof(*tlp);
      } else {
	name = tp->msgt_name;
	size = tp->msgt_size;
	number = tp->msgt_number;
	plen = sizeof(*tp);
      }
      printf_filtered("name=%-16s size=%2d number=%7d inline=%d long=%d deal=%d\n",
		      name_str(name,buf),size,number,tp->msgt_inline,
		      tp->msgt_longform, tp->msgt_deallocate);
      dp = p+plen;
      if (tp->msgt_inline) {
	int	l;
	l = size*number/8;
	l = (l+sizeof(long)-1)&~((sizeof(long))-1);
	plen += l;
	print_data(dp,size,number);
      } else {
	plen += sizeof(int*);
      }
      printf_filtered("plen=%d\n",plen);
a4550 1
  }
d4553 1
a4553 1
print_data(p,size,number)
d4555 1
a4555 1
char	*p;
d4558 3
a4560 3
  int	*ip;
  short	*sp;
  int	i;
d4562 22
a4583 4
  switch (size) {
  case 8:
    for(i = 0; i < number; i++) {
      printf_filtered(" %02x",p[i]);
d4585 1
a4585 15
    break;
  case 16:
    sp = (short*)p;
    for(i = 0; i < number; i++) {
      printf_filtered(" %04x",sp[i]);
    }
    break;
  case 32:
    ip = (int*)p;
    for(i = 0; i < number; i++) {
      printf_filtered(" %08x",ip[i]);
    }
    break;
  }
  puts_filtered("\n");
d4587 1
a4587 1
#endif  DUMP_SYSCALL
d4597 1
a4597 1
int  pid;
d4600 1
a4600 1
  return NULL;  /* To keep all compilers happy. */
d4649 3
a4651 3
  ret = mach_port_allocate(mach_task_self(), 
			   MACH_PORT_RIGHT_PORT_SET,
			   &inferior_wait_port_set);
d4653 1
a4653 1
    fatal("initial port set %s",mach_error_string(ret));
d4658 1
a4658 1
  ret = netname_look_up(name_server_port, hostname, "MachID", &mid_server);
d4662 1
a4662 1
      
d4664 1
a4664 1
	       mach_error_string(ret));
d4667 2
a4668 2
  
  mid_auth = mach_privileged_host_port();
d4670 2
a4671 2
    mid_auth = mach_task_self();
  
d4674 1
a4674 1
  ret = mach_port_allocate (mach_task_self (), 
d4678 1
a4678 1
  
d4693 4
a4696 4
      char buf[ MAX_NAME_LEN ];
      ret = mach_port_move_member(mach_task_self (),
				  our_message_port,
				  inferior_wait_port_set);
d4706 1
a4706 1
  
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d6 1
a6 1
   This file is part of GDB.
d8 13
a20 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d24 1
a24 1
 *         Computing Centre
d30 2
a31 2
 *      Johannes Helander, Antti Louko, Tero Mononen,
 *      jvh@@cs.hut.fi      alo@@hut.fi   tmo@@cs.hut.fi
d34 2
a35 2
 *      kivinen@@cs.hut.fi               emcmanus@@gr.osf.org
 *      
d67 1
a67 1

d72 1
a72 1
#define SIG_UNKNOWN 0		/* Exception that has no matching unix signal */
d116 23
a138 25
typedef struct gdb_thread
  {
    mach_port_t name;
    CORE_ADDR sp;
    CORE_ADDR pc;
    CORE_ADDR fp;
    boolean_t in_emulator;
    int slotid;

    /* This is for the mthreads list.  It points to the cproc list.
       Perhaps the two lists should be merged (or perhaps it was a mistake
       to make them both use a struct gdb_thread).  */
    struct gdb_thread *cproc;

    /* These are for the cproc list, which is linked through the next field
       of the struct gdb_thread.  */
    char raw_cproc[CPROC_SIZE];
    /* The cthread which is pointed to by the incarnation field from the
       cproc.  This points to the copy we've read into GDB.  */
    cthread_t cthread;
    /* Point back to the mthreads list.  */
    int reverse_map;
    struct gdb_thread *next;
  }
 *gdb_thread_t;
d149 13
a161 36
struct exception_list
  {
    char *name;
    boolean_t forward;
    boolean_t print;
    int sigmap;
  }
exception_map[] =
{
  {
    "not_mach3_exception", FALSE, TRUE, SIG_UNKNOWN
  }
  ,
  {
    "EXC_BAD_ACCESS", FALSE, TRUE, SIGSEGV
  }
  ,
  {
    "EXC_BAD_INSTRUCTION", FALSE, TRUE, SIGILL
  }
  ,
  {
    "EXC_ARITHMETIC", FALSE, TRUE, SIGFPE
  }
  ,
  {
    "EXC_EMULATION", FALSE, TRUE, SIGEMT
  }
  ,				/* ??? */
  {
    "EXC_SOFTWARE", FALSE, TRUE, SIG_UNKNOWN
  }
  ,
  {
    "EXC_BREAKPOINT", FALSE, FALSE, SIGTRAP
  }
d165 1
a165 1
int max_exception = sizeof (exception_map) / sizeof (struct exception_list) - 1;
d175 1
a175 1
/* #define DUMP_SYSCALL         /* debugging interceptor */
d184 3
a186 3
xx_debug (fmt, a, b, c)
     char *fmt;
     int a, b, c;
d193 1
a193 1
extern mach_port_t name_server_port;
d207 1
a207 1
task_t inferior_task;
d211 1
a211 1
mach_port_t inferior_exception_port = MACH_PORT_NULL;
d215 2
a216 2
mach_port_t inferior_wait_port_set = MACH_PORT_NULL;
mach_port_t our_notify_port = MACH_PORT_NULL;
d223 1
a223 1
mach_port_t currently_waiting_for = MACH_PORT_NULL;
d238 1
a238 1
mach_port_t our_message_port = MACH_PORT_NULL;
d241 1
a241 1
mach_port_t thread_exception_port = MACH_PORT_NULL;
d243 1
a243 1
mach_port_t singlestepped_thread_port = MACH_PORT_NULL;
d247 1
a247 1
mach_port_t mid_auth = MACH_PORT_NULL;
d261 1
a262 1

d273 7
a279 8
struct port_chain
  {
    struct port_chain *next;
    mach_port_t port;
    int type;
    int mid;			/* Now only valid with MACH_TYPE_THREAD and */
    /*  MACH_TYPE_THREAD */
  };
d297 1
a297 1
     int type;
d303 1
a303 1
  if (!MACH_PORT_VALID (name))
d305 1
a305 1

d308 1
a308 1
      if (!MACH_PORT_VALID (mid_server))
d317 1
a317 1

d330 4
a333 4
  new->next = list;
  new->port = name;
  new->type = type;
  new->mid = mid;
d350 1
a350 1
	    list->next = list->next->next;	/* GCd with obstack_free() */
d381 2
a382 2
     mach_port_t name;
     int type;
d393 1
a393 1

d396 2
a397 2

  if (!MACH_PORT_VALID (mid_server))
d409 1
a409 1

d432 1
a432 1
     thread_t thread;
d437 1
a437 1
  if (!MACH_PORT_VALID (thread))
d446 1
a446 1

d455 1
a455 1

d468 1
a468 1
	      ret = mach_port_move_member (mach_task_self (),
d476 1
a476 1

d478 3
a480 3

	  singlestepped_thread_port = thread_exception_port;
	  currently_waiting_for = singlestepped_thread_port;
d485 1
a485 1
	  if (!MACH_PORT_VALID (teport))
d490 1
a490 1

d495 1
a495 1
	  ret = mach_port_move_member (mach_task_self (),
d500 1
a500 1
#endif
d505 1
a505 1

d509 1
a509 1

d511 1
a511 1

d522 3
a524 3
     mach_port_t name;
     mach_msg_id_t variant;
     int type;
d527 3
a529 3
  mach_port_t previous_port_dummy = MACH_PORT_NULL;

  if (!MACH_PORT_VALID (name))
d531 1
a531 1

d535 1
a535 1
  ret = mach_port_request_notification (mach_task_self (),
d550 2
a551 2
reverse_msg_bits (msgp, type)
     mach_msg_header_t *msgp;
d554 2
a555 2
  int rbits, lbits;
  rbits = MACH_MSGH_BITS_REMOTE (msgp->msgh_bits);
d559 1
a559 1
    MACH_MSGH_BITS (lbits, rbits);
d564 2
a565 2
   Let this be global
   and then it was global.
d591 1
a591 1

d602 1
a602 1

d624 5
a628 6
  struct syscall_msg_t
    {
      mach_msg_header_t header;
      mach_msg_type_t type;
      char room[2000];		/* Enuff space */
    };
d645 1
a645 6
    return;			/* We are already set up in the correct program */

  ret = mach_port_allocate (mach_task_self (),
			    MACH_PORT_RIGHT_RECEIVE,
			    &fake_server);
  CHK ("create inferior_fake_server port failed", ret);
d647 5
d653 1
a653 1
  while (1)
d658 1
a658 1
		       (task_info_t) & info,
d668 1
a668 1
      (void) swtch_pri (42);	/* Universal Priority Value */
d685 2
a686 2
  CHK ("mach_port_extract_right (bsd server send)", ret);

d688 1
a688 1
    error ("Incorrect right extracted, send right to bsd server excpected");
d694 1
a694 1
  CHK ("mach_port_insert_right (fake server send)", ret);
d701 5
a705 5
  ret = mach_port_allocate (mach_task_self (),
			    MACH_PORT_RIGHT_RECEIVE,
			    &exec_reply);
  CHK ("create intercepted_reply_port port failed", ret);

d712 1
a712 1
  CHK ("mach_port_extract_right (exec_reply)", ret);
d715 1
a715 1
    error ("Incorrect right extracted, send once excpected for exec reply");
d717 3
a719 3
  ret = mach_port_move_member (mach_task_self (),
			       fake_server,
			       inferior_wait_port_set);
d723 1
a723 1

d725 2
a726 2
  CHK ("task_resume (startup)", ret);

d730 1
a730 1
  while (exec_counter > 0)
d733 4
a736 4
		      MACH_RCV_MSG,	/* options */
		      0,	/* send size */
		      sizeof (struct syscall_msg_t),	/* receive size */
		      inferior_wait_port_set,	/* receive_name */
d739 2
a740 2
      CHK ("mach_msg (intercepted sycall)", ret);

d762 2
a763 2
	         process group.  On POSIX systems, tcsetpgrp will fail with
	         EPERM if we try it before the child's setpgid.  */
d766 1
a766 1
	         based on what modes we are starting it with.  */
d777 2
a778 2

      syscall_in.header.msgh_local_port = syscall_in.header.msgh_remote_port;
d781 1
a781 1
      reverse_msg_bits (&syscall_in.header, MACH_MSG_TYPE_COPY_SEND);
d786 4
a789 4

  ret = mach_port_move_member (mach_task_self (),
			       fake_server,
			       MACH_PORT_NULL);
d792 3
a794 3
  ret = mach_port_move_member (mach_task_self (),
			       exec_reply,
			       inferior_wait_port_set);
d798 2
a799 2
		  MACH_RCV_MSG,	/* options */
		  0,		/* send size */
d801 1
a801 1
		  inferior_wait_port_set,	/* receive_name */
d804 1
a804 1
  CHK ("mach_msg (exec reply)", ret);
d814 1
a814 1
  print_msg (&syscall_in.header);
d823 1
a823 1
  reverse_msg_bits (&syscall_in.header, MACH_MSG_TYPE_MOVE_SEND_ONCE);
d842 1
a842 1
  CHK ("mach_port_destroy (fake_server)", ret);
d847 1
a847 1
  CHK ("mach_port_destroy (exec_reply)", ret);
d855 1
a855 1
     int thread_count;
d866 1
a866 1
				   thread_list[index]);
d881 1
a881 1

d903 1
a903 1
  if (!threads)
d909 1
a909 1

d915 2
a916 2
	  (void) vm_deallocate (mach_task_self (), (vm_address_t) threads,
				(thread_count * sizeof (mach_port_t)));
d921 1
a921 1
	return -(slot + 1);
d924 1
a924 1
  mid = map_port_name_to_mid (threads[slot], MACH_TYPE_THREAD);
d929 2
a930 2
      (void) vm_deallocate (mach_task_self (), (vm_address_t) threads,
			    (thread_count * sizeof (mach_port_t)));
d946 1
a946 1

d949 1
a949 1

d952 2
a953 2

  if (!*arg)
d955 1
a955 1

d964 1
a964 1

d972 1
a972 1

d978 1
a978 1
    return -(slot + 1);
d981 1
a981 1
    return -(slot + 1);
d984 1
a984 1

d1031 3
a1033 3
      (void) vm_deallocate (mach_task_self (),
			    (vm_address_t) thread_list,
			    (thread_count * sizeof (mach_port_t)));
d1037 1
a1037 1
  if (!thread_id || flag == 2)
d1040 1
a1040 1
      if (!thread_id)
d1045 1
a1045 1
	    new_thread = thread_list[thread_id];
d1048 3
a1050 3
	      (void) vm_deallocate (mach_task_self (),
				    (vm_address_t) thread_list,
				    (thread_count * sizeof (mach_port_t)));
d1058 1
a1058 1
	if (thread_id == map_port_name_to_mid (thread_list[index],
d1061 1
a1061 1
	    new_thread = thread_list[index];
d1065 1
a1065 1

d1069 1
a1069 1

d1072 4
a1075 4

  ret = vm_deallocate (mach_task_self (),
		       (vm_address_t) thread_list,
		       (thread_count * sizeof (mach_port_t)));
d1077 2
a1078 2

  if (!flag)
d1086 1
a1086 1

d1105 1
a1105 1
      stop_pc = read_pc ();
d1135 1
a1135 1

d1152 1
a1152 1
  if (!MACH_PORT_VALID (inferior_task))
d1185 1
a1185 1
  ret = mach_port_allocate (mach_task_self (),
d1188 1
a1188 1
  CHK ("mach_port_allocate", ret);
d1195 1
a1195 1
  CHK ("mach_port_insert_right", ret);
d1197 1
a1197 1
  ret = mach_port_move_member (mach_task_self (),
d1200 1
a1200 1
  CHK ("mach_port_move_member", ret);
d1202 1
a1202 1
  ret = task_get_special_port (inferior_task,
d1205 1
a1205 1
  CHK ("task_get_special_port(old exc)", ret);
d1208 1
a1208 1
			       TASK_EXCEPTION_PORT,
d1210 1
a1210 1
  CHK ("task_set_special_port", ret);
d1214 1
a1214 1
  CHK ("mack_port_deallocate", ret);
d1236 1
a1236 1
   (e.g. we receive a single step trace trap)
d1251 5
a1255 7
  struct msg
    {
      mach_msg_header_t header;
      mach_msg_type_t foo;
      int data[8000];
    }
  in_msg, out_msg;
d1268 3
a1270 3
      ret = mach_msg (&in_msg.header,	/* header */
		      MACH_RCV_MSG,	/* options */
		      0,	/* send size */
d1276 1
a1276 1
      CHK ("mach_msg (receive)", ret);
d1291 1
a1291 1
	      wait3 (&w, WNOHANG, 0);
d1300 2
a1301 2
	      if ((!WIFEXITED (w) && WIFSTOPPED (w)) ||
		  (WIFEXITED (w) && WEXITSTATUS (w) > 0377))
d1303 1
a1303 1
		  WSETEXIT (w, 0);
d1306 1
a1306 1
	      else if (!WIFEXITED (w))
d1308 1
a1308 1
		  int sig = WTERMSIG (w);
d1311 1
a1311 1
		  if (sig != SIGKILL)	/* Bad luck if garbage matches this */
d1315 1
a1315 1
		      WSETEXIT (w, 0);
d1325 3
a1327 3
         exc_server() does an upcall to catch_exception_raise()
         if this rpc is an exception. Further actions are decided
         there.
d1329 1
a1329 1
      if (!exc_server (&in_msg.header, &out_msg.header))
d1333 1
a1333 1

d1346 1
a1346 1

d1350 1
a1350 1
	  wait3 (&w, WNOHANG, 0);
d1368 1
a1368 1

d1372 1
a1372 1

d1392 1
a1392 1
  current_thread = MACH_PORT_NULL;	/* Force setup */
d1412 1
a1412 1
}
d1430 7
a1436 2
      switch (InP->msgh_id)
	{
d1438 3
a1440 5
	case GDB_MESSAGE_ID_STOP:
	  ret = task_suspend (inferior_task);
	  if (ret != KERN_SUCCESS)
	    warning ("Could not suspend task for stop message: %s",
		     mach_error_string (ret));
d1442 5
a1446 9
	  /* QUIT in mach_really_wait() loop. */
	  request_quit (0);
	  break;

	default:
	  warning ("Invalid message id %d received, ignored.",
		   InP->msgh_id);
	  break;
	}
d1456 1
a1456 1

d1473 1
a1473 1

d1477 3
a1479 5
  typedef struct
    {
      mach_msg_header_t Head;
    }
  Request;
d1485 1
a1485 1
  InP->Head.msgh_bits = MACH_MSGH_BITS (MACH_MSG_TYPE_COPY_SEND, 0);
d1489 3
a1491 3
  InP->Head.msgh_local_port = MACH_PORT_NULL;
  InP->Head.msgh_seqno = 0;
  InP->Head.msgh_id = GDB_MESSAGE_ID_STOP;
d1494 2
a1495 2
		  MACH_SEND_MSG | MACH_MSG_OPTION_NONE,
		  sizeof (Request),
d1518 1
a1518 1
      mid = map_slot_to_mid (-(mid + 1), 0, 0);
d1523 2
a1524 2
  if (!mid || cmid == -1)
    return 1;			/* stop */
d1563 1
a1563 1
  static char foobar[20];
d1568 1
a1568 1
    sprintf (foobar, "@@%d", -(mid + 1));
d1577 1
a1577 1

d1594 1
a1594 1
      if (!select_it)
d1610 2
a1611 2
   - The task that signaled is not the inferior task
   (e.g. when debugging another debugger)
d1613 7
a1619 7
   - The user has explicitely requested to pass on the exceptions.
   (e.g to the default unix exception handler, which maps
   exceptions to signals, or the user has her own exception handler)

   - If the thread that signaled is being single-stepped and it
   has set it's own exception port and the exception is not
   EXC_BREAKPOINT. (Maybe this is not desirable?)
d1633 1
a1633 1
  if (!MACH_PORT_VALID (thread))
d1636 1
a1636 1
         receive it, THREAD will be MACH_PORT_DEAD
d1646 1
a1646 1
  if (!MACH_PORT_VALID (task))
d1657 1
a1657 1
  if (!MACH_PORT_VALID (inferior_task))
d1659 1
a1659 1

d1661 7
a1667 7
  stop_code = code;
  stop_subcode = subcode;
  stop_thread = thread;

  signal_thread = exception != EXC_BREAKPOINT &&
    port == singlestepped_thread_port &&
    MACH_PORT_VALID (thread_saved_exception_port);
d1675 2
a1676 2
      signal_thread ||
      exception_map[exception].forward)
d1683 3
a1685 3
	     GDB now forwards the exeption to thread's original handler,
	     since the user propably knows what he is doing.
	     Give a message, though.
d1688 1
a1688 1
	  mach3_exception_actions ((WAITTYPE *) NULL, TRUE, "Thread");
d1694 1
a1694 1
			     thread,
d1711 1
a1711 1

d1727 1
a1727 1

d1748 1
a1748 1
	  if (!MACH_PORT_VALID (current_thread))
d1750 1
a1750 1

d1759 1
a1759 1

d1768 2
a1769 2
     mach_port_t port;
     int mask;
d1798 5
a1802 5
  vm_address_t low_address = (vm_address_t) trunc_page (addr);
  vm_size_t aligned_length =
  (vm_size_t) round_page (addr + length) - low_address;
  pointer_t copied_memory;
  int copy_count;
d1819 1
a1819 1
      if (!port_valid (inferior_task, MACH_PORT_TYPE_SEND))
d1840 1
a1840 1
  memcpy (myaddr, (char *) addr - low_address + copied_memory, length);
d1845 1
a1845 1
  CHK ("mach3_read_inferior vm_deallocate failed", ret);
d1858 1
a1858 2
struct vm_region_list
{
d1860 3
a1862 3
  vm_prot_t protection;
  vm_address_t start;
  vm_size_t length;
d1865 1
a1865 1
struct obstack region_obstack;
d1878 6
a1883 6
  vm_address_t low_address = (vm_address_t) trunc_page (addr);
  vm_size_t aligned_length =
  (vm_size_t) round_page (addr + length) - low_address;
  pointer_t copied_memory;
  int copy_count;
  int deallocate = 0;
d1885 1
a1885 1
  char *errstr = "Bug in mach3_write_inferior";
d1888 1
a1888 1
  struct vm_region_list *region_head = (struct vm_region_list *) NULL;
d1900 1
a1900 1
  memcpy ((char *) addr - low_address + copied_memory, myaddr, length);
d1908 2
a1909 2
    vm_size_t remaining_length = aligned_length;
    vm_address_t region_address = low_address;
d1913 1
a1913 1
    while (region_address < low_address + aligned_length)
d1921 3
a1923 3
	vm_size_t region_length = remaining_length;
	vm_address_t old_address = region_address;

d1955 1
a1955 1
	region_element =
d1957 2
a1958 2
	  obstack_alloc (&region_obstack, sizeof (struct vm_region_list));

d1960 2
a1961 2
	region_element->start = region_address;
	region_element->length = region_length;
d1965 2
a1966 2
	region_head = region_element;

d1974 1
a1974 1

d1979 1
a1979 1

d1996 1
a1996 1

d2001 1
a2001 1

d2014 1
a2014 1
out:
d2018 1
a2018 1

d2047 1
a2047 1
    result = mach3_read_inferior (memaddr, myaddr, len);
d2051 1
a2052 1

d2054 2
a2055 2
translate_state (state)
     int state;
d2057 8
a2064 15
  switch (state)
    {
    case TH_STATE_RUNNING:
      return ("R");
    case TH_STATE_STOPPED:
      return ("S");
    case TH_STATE_WAITING:
      return ("W");
    case TH_STATE_UNINTERRUPTIBLE:
      return ("U");
    case TH_STATE_HALTED:
      return ("H");
    default:
      return ("?");
    }
d2073 6
a2078 12
    case CPROC_RUNNING:
      return "R";
    case CPROC_SWITCHING:
      return "S";
    case CPROC_BLOCKED:
      return "B";
    case CPROC_CONDWAIT:
      return "C";
    case CPROC_CONDWAIT | CPROC_SWITCHING:
      return "CS";
    default:
      return "?";
d2084 1
a2084 1
mach_port_t			/* no mach_port_name_t found in include files. */
d2089 1
a2089 1
  kern_return_t ret;
d2091 2
a2092 2
  mach_port_t iport;

d2098 1
a2098 1
  CHK ("mach_port_extract_right (map_inferior_port_name)", ret);
d2101 1
a2101 1
    error ("Incorrect right extracted, (map_inferior_port_name)");
d2133 1
a2133 1
	sprintf (buf, "_C%d", id);
d2135 1
a2135 1
    else if (!one_cproc->cthread->name)
d2138 1
a2138 1
	sprintf (buf, "_t%d", id);
d2141 1
a2141 1
      return (char *) (one_cproc->cthread->name);
d2148 1
a2148 1
      sprintf (buf, "_K%d", id);
d2156 2
a2157 2
     mach_port_t task;
     gdb_thread_t *mthreads_out;	/* out */
d2159 1
a2159 1
  kern_return_t ret;
d2161 1
a2161 1
  int th_count;
d2163 1
a2163 1
  int index;
d2169 1
a2169 1
	       mach_error_string (ret));
d2173 1
a2173 1

d2175 3
a2177 3
    obstack_alloc
    (cproc_obstack,
     th_count * sizeof (struct gdb_thread));
d2185 1
a2185 1
	setup_thread (th_table[index], 1);
d2190 2
a2191 2

	  mid = switch_to_thread (th_table[index]);
d2194 1
a2194 1
      mthreads[index].name = th_table[index];
d2198 1
a2198 1

d2207 1
a2207 1
	setup_thread (th_table[index], 0);
d2209 1
a2209 1

d2211 2
a2212 2
  ret = vm_deallocate (mach_task_self (), (vm_address_t) th_table,
		       (th_count * sizeof (mach_port_t)));
d2235 3
a2237 3
  sp = (sp & ~(EMULATOR_STACK_SIZE - 1)) +
    EMULATOR_STACK_SIZE - sizeof (struct emul_stack_top);

d2262 1
a2262 1
  kern_return_t ret;
d2264 2
a2265 2
  vm_offset_t *emulation_vector;
  int n;
d2267 2
a2268 2
  vm_offset_t emulation_vector[EMUL_VECTOR_COUNT];
  int n = EMUL_VECTOR_COUNT;
d2270 3
a2272 3
  int i;
  int vector_start;

d2281 1
a2281 1
  CHK ("task_get_emulation_vector", ret);
d2284 2
a2285 2

  for (i = 0; i < n; i++)
d2287 1
a2287 1
      vm_offset_t entry = emulation_vector[i];
d2296 2
a2297 2
	      warning ("Emulation vector address 0x08%x outside emulator space",
		       entry);
d2330 1
a2330 1
	  stack_size =
d2357 1
a2357 1
   */
d2366 1
a2366 1
	  gdb_thread_t mthread = (mthreads + index);
d2373 1
a2373 1

d2377 1
a2377 1

d2379 1
a2379 1
		  if (!usp)
d2381 1
a2381 1

d2387 1
a2387 1

d2396 3
a2398 3
			    (scan->raw_cproc + CPROC_BASE_OFFSET,
			     CPROC_BASE_SIZE);
			  stack_size =
d2400 2
a2401 2
			    (scan->raw_cproc + CPROC_SIZE_OFFSET,
			     CPROC_SIZE_SIZE);
d2420 1
a2420 1
 *                   slot mid sel   name  emul ks susp  cstate wired   address
d2431 2
a2432 2
  if (!lookup_minimal_symbol_by_pc (pc))
    fprintf_filtered (stream, local_hex_format (), pc);
d2438 1
a2438 1
      int store = addressprint;
d2458 1
a2458 1
		       (struct block *) NULL,
d2460 2
a2461 2
		       (int *) NULL,
		       (struct symtab **) NULL);
d2466 1
a2466 1
  if (!symaddr)
d2478 1
a2478 1
get_cprocs ()
d2487 1
a2487 1

d2490 1
a2490 1
  if (!symaddr)
d2493 1
a2493 1
         symbols, but don't give up yet */
d2511 1
a2511 1
  if (!symaddr)
d2527 1
a2527 1
  while (their_cprocs != (CORE_ADDR) 0)
d2536 1
a2536 1
	error ("Can't read next cproc at 0x%x.", their_cprocs);
d2545 1
a2545 1
      if (cproc_copy_incarnation == (CORE_ADDR) 0)
d2550 2
a2551 2
	  cthread = (cthread_t) obstack_alloc (cproc_obstack,
					       sizeof (struct cthread));
d2555 3
a2557 3
				    sizeof (struct cthread)))
	      error ("Can't read next thread at 0x%x.",
		     cproc_copy_incarnation);
d2565 2
a2566 2
	      if (!mach3_read_inferior (cthread->name, name, MAX_NAME_LEN))
		error ("Can't read next thread's name at 0x%x.", cthread->name);
d2597 1
a2597 1
  if (!mthread || !mthread->cproc)
d2627 1
a2628 1

d2630 1
a2630 1
thread_list_command ()
d2633 1
a2633 1
  int thread_count;
d2636 9
a2644 9
  int index;
  char *name;
  char selected;
  char *wired;
  int infoCnt;
  kern_return_t ret;
  mach_port_t mid_or_port;
  gdb_thread_t their_threads;
  gdb_thread_t kthread;
d2649 1
a2649 1

d2651 1
a2651 1

d2653 1
a2653 1

d2658 1
a2658 1

d2661 1
a2661 1

d2663 1
a2663 1

d2665 3
a2667 3

  cprocs = get_cprocs ();

d2669 1
a2669 1

d2676 3
a2678 3
      extract_signed_integer
      (scan->raw_cproc + CPROC_STATE_OFFSET, CPROC_STATE_SIZE);

d2680 1
a2680 1

d2687 1
a2687 1
	kthread = (their_threads + scan->reverse_map);
d2689 1
a2689 1
	kthread = NULL;
d2694 1
a2694 1

d2696 1
a2696 1

d2698 1
a2698 1

d2701 1
a2701 1
			     (thread_info_t) & ths,
d2703 1
a2703 1

d2713 1
a2713 1
	  sprintf (slot, "%d", kthread->slotid % 100);
d2717 1
a2717 1

d2755 1
a2755 1
	    continue;		/* EMcM */
d2779 1
a2779 1

d2783 1
a2783 1
      if (!their_threads[index].cproc)
d2786 1
a2786 1

d2791 1
a2791 1

d2793 1
a2793 1

d2795 6
a2800 6

	  ret = thread_info (name,
			     THREAD_BASIC_INFO,
			     (thread_info_t) & ths,
			     &infoCnt);

d2809 1
a2809 1
	  sprintf (slot, "%d", index % 100);
d2837 1
a2837 1
			   "",	/* No cproc state */
d2843 1
a2843 1

d2849 1
a2849 1
thread_select_command (args, from_tty)
d2873 1
a2873 1
  mid = atoi (args);
d2876 1
a2876 1
    if (!is_slot || *args != '0')	/* Rudimentary checks */
d2879 1
a2879 1
  if (select_thread (inferior_task, mid, is_slot ? 2 : 1) != KERN_SUCCESS)
d2885 1
a2885 1
						   MACH_TYPE_THREAD) : mid);
d2889 2
a2890 2
     mach_port_t thread;
     boolean_t set;
d2892 4
a2895 4
  int flavor = TRACE_FLAVOR;
  unsigned int stateCnt = TRACE_FLAVOR_SIZE;
  kern_return_t ret;
  thread_state_data_t state;
d2897 1
a2897 1
  if (!MACH_PORT_VALID (thread))
d2906 1
a2906 1
  ret = thread_get_state (thread, flavor, state, &stateCnt);
d2908 1
a2908 1

d2915 1
a2915 1
      if (!TRACE_CLEAR (thread, state))
d2923 1
a2923 1
  ret = thread_set_state (thread, flavor, state, stateCnt);
d2927 1
a2927 1
}
d2936 1
a2936 1
flush_inferior_icache (pc, amount)
d2940 2
a2941 2
  kern_return_t ret;

d2951 2
a2952 1
#endif /* FLUSH_INFERIOR_CACHE */
a2953 1

d2958 4
a2961 4
  kern_return_t ret;
  thread_array_t thread_list;
  int thread_count, index;
  int infoCnt;
d2964 1
a2964 1

d2972 1
a2972 1

d2977 1
a2977 1
      mid = map_port_name_to_mid (thread_list[index],
d2979 2
a2980 2

      ret = thread_suspend (thread_list[index]);
d2989 1
a2989 1
	  ret = thread_info (thread_list[index],
d2991 1
a2991 1
			     (thread_info_t) & th_info,
d2994 1
a2994 1

d3001 3
a3003 3
  ret = vm_deallocate (mach_task_self (),
		       (vm_address_t) thread_list,
		       (thread_count * sizeof (int)));
d3013 3
a3015 3
  int mid;
  mach_port_t saved_thread;
  int infoCnt;
d3017 1
a3017 1

d3020 4
a3023 5
  if (!strcasecmp (args, "all"))
    {
      suspend_all_threads (from_tty);
      return;
    }
d3034 7
a3040 6
  else if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
    {
      if (current_thread)
	current_thread = saved_thread;
      error ("Could not select thread %d", mid);
    }
d3050 1
a3050 1
		     (thread_info_t) & th_info,
d3053 1
a3053 1

d3055 1
a3055 1

d3062 6
a3067 6
  kern_return_t ret;
  thread_array_t thread_list;
  int thread_count, index;
  int mid;
  int infoCnt;
  thread_basic_info_data_t th_info;
d3069 6
a3074 6
  ret = task_threads (inferior_task, &thread_list, &thread_count);
  if (ret != KERN_SUCCESS)
    {
      m3_kill_inferior ();
      error ("task_threads", mach_error_string (ret));
    }
d3076 18
a3093 8
  for (index = 0; index < thread_count; index++)
    {
      infoCnt = THREAD_BASIC_INFO_COUNT;
      ret = thread_info (thread_list[index],
			 THREAD_BASIC_INFO,
			 (thread_info_t) & th_info,
			 &infoCnt);
      CHK ("resume_all can't get thread info", ret);
d3095 1
a3095 2
      mid = map_port_name_to_mid (thread_list[index],
				  MACH_TYPE_THREAD);
d3097 7
a3103 6
      if (!th_info.suspend_count)
	{
	  if (mid != -1 && from_tty)
	    warning ("Thread %d is not suspended", mid);
	  continue;
	}
d3105 5
a3109 15
      ret = thread_resume (thread_list[index]);

      if (ret != KERN_SUCCESS)
	warning ("Error trying to resume thread %d : %s",
		 mid, mach_error_string (ret));
      else if (mid != -1 && from_tty)
	warning ("Thread %d suspend count is %d",
		 mid, --th_info.suspend_count);
    }

  consume_send_rights (thread_list, thread_count);
  ret = vm_deallocate (mach_task_self (),
		       (vm_address_t) thread_list,
		       (thread_count * sizeof (int)));
  CHK ("Error trying to deallocate thread list", ret);
d3122 1
a3122 1

d3125 4
a3128 5
  if (!strcasecmp (args, "all"))
    {
      resume_all_threads (from_tty);
      return;
    }
d3139 7
a3145 6
  else if (select_thread (inferior_task, mid, 0) != KERN_SUCCESS)
    {
      if (current_thread)
	current_thread = saved_thread;
      return_to_top_level (RETURN_ERROR);
    }
d3149 1
a3149 1
		     (thread_info_t) & th_info,
d3152 2
a3153 2

  if (!th_info.suspend_count)
d3168 2
a3169 2

out:
d3182 1
a3182 1
  int index;
d3184 2
a3185 2


d3203 1
a3203 1

d3207 1
a3207 1

d3218 1
a3218 1
      if (thread_table[index] == thread_to_kill)
d3226 3
a3228 3

  ret = vm_deallocate (mach_task_self (), (vm_address_t) thread_table,
		       (thread_count * sizeof (mach_port_t)));
d3230 1
a3230 1

d3233 1
a3234 1

d3246 1
a3246 1

d3255 1
a3255 1
		   (task_info_t) & ta_info,
d3258 1
a3258 1

d3263 1
a3263 1
	!query ("Suspend count is now 1. Do you know what you are doing? "))
d3274 1
a3274 1
         suspended! */
d3279 1
a3279 1
	     mid, ta_info.suspend_count - 1);
d3292 1
a3292 1

d3306 1
a3306 1
		   (task_info_t) & ta_info,
d3309 1
a3309 1

d3318 2
a3319 2
  static char size[30];
  int zz = bytes / 1024;
d3322 1
a3322 1
    sprintf (size, "%-2.1f M", ((float) bytes) / (1024.0 * 1024.0));
d3340 1
a3340 1
  int page_size = round_page (1);
d3342 1
a3342 1

d3369 1
a3369 1
		   (task_info_t) & ta_info,
d3381 1
a3381 1

d3384 1
a3384 1

d3388 4
a3391 4
    ret = vm_deallocate (mach_task_self (),
			 (vm_address_t) thread_list,
			 (thread_count * sizeof (int)));
    CHK ("Error trying to deallocate thread list", ret);
d3421 2
a3422 3
  while (*scan == ' ' || *scan == '\t')
    scan++;

d3437 1
a3437 2
    while (*scan == ' ' || *scan == '\t')
      scan++;
d3448 1
a3448 1
    error ("exception number action");
d3451 1
a3451 1
    exception_map[exception].forward = TRUE;
d3453 1
a3453 1
    exception_map[exception].forward = FALSE;
d3462 1
a3462 1
  boolean_t forward = exception_map[exception].forward;
d3464 1
a3464 1
  printf_filtered ("%s\t(%d): ", exception_map[exception].name,
d3467 1
a3467 1
    if (exception_map[exception].sigmap != SIG_UNKNOWN)
d3469 1
a3469 1
		       exception_map[exception].sigmap);
d3472 1
a3472 1
		       exception_map[exception].sigmap);
d3507 1
a3507 1

d3517 1
a3517 1

d3521 1
a3521 1

d3524 29
a3552 30
      switch (stop_exception)
	{
	case EXC_BAD_ACCESS:
	  printf_filtered ("referencing address 0x%x : %s\n",
			   stop_subcode,
			   mach_error_string (stop_code));
	  break;
	case EXC_BAD_INSTRUCTION:
	  printf_filtered
	    ("illegal or undefined instruction. code %d subcode %d\n",
	     stop_code, stop_subcode);
	  break;
	case EXC_ARITHMETIC:
	  printf_filtered ("code %d\n", stop_code);
	  break;
	case EXC_EMULATION:
	  printf_filtered ("code %d subcode %d\n", stop_code, stop_subcode);
	  break;
	case EXC_SOFTWARE:
	  printf_filtered ("%s specific, code 0x%x\n",
			   stop_code < 0xffff ? "hardware" : "os emulation",
			   stop_code);
	  break;
	case EXC_BREAKPOINT:
	  printf_filtered ("type %d (machine dependent)\n",
			   stop_code);
	  break;
	default:
	  fatal ("Unknown exception");
	}
d3568 1
a3568 1
  notify_chain = (port_chain_t) NULL;
d3573 1
a3573 1
      ret = mach_port_allocate (mach_task_self (),
d3577 5
a3581 5
	fatal ("Creating notify port %s", mach_error_string (ret));

      ret = mach_port_move_member (mach_task_self (),
				   our_notify_port,
				   inferior_wait_port_set);
d3583 1
a3583 1
	fatal ("initial move member %s", mach_error_string (ret));
d3599 1
a3599 1
char registered_name[MAX_NAME_LEN];
d3622 1
a3622 1
  if (!MACH_PORT_VALID (port) || !name || !*name)
d3628 1
a3628 1
  if (!already_signed)
d3648 1
a3648 1
			  name,	/* Name of service */
d3650 3
a3652 3
			  port);	/* Creates a new send right */
  CHK ("Failed to check in the port", ret);

d3654 1
a3654 1
  while (len < MAX_NAME_LEN && *(name + len))
d3656 1
a3656 1
      registered_name[len] = *(name + len);
d3661 1
a3661 1
}
d3666 1
a3666 1
/*ARGSUSED */
d3676 1
a3676 1
/*ARGSUSED */
d3693 2
a3694 2
	  "Generic command for handling Mach threads in the debugged task.",
		  &cmd_thread_list, "thread ", 0, &cmdlist);
d3698 1
a3698 1
  add_cmd ("select", class_stack, thread_select_command,
d3701 1
a3701 1
  add_cmd ("list", class_stack, thread_list_command,
d3724 1
a3724 1
  add_alias_cmd ("tl", "mthread list", 0, 0, &cmdlist);
d3729 2
a3730 2
		  "Generic command for handling debugged task.",
		  &cmd_task_list, "task ", 0, &cmdlist);
d3779 1
a3779 1
  if (!element)
d3781 2
d3784 9
a3792 2
  switch (element->type)
    {
d3794 1
a3794 9
    case MACH_TYPE_THREAD:
      target_terminal_ours_for_output ();
      if (name == current_thread)
	{
	  printf_filtered ("\nCurrent thread %d died", element->mid);
	  current_thread = MACH_PORT_NULL;
	}
      else
	printf_filtered ("\nThread %d died", element->mid);
d3796 17
a3812 1
      break;
d3814 2
a3815 8
    case MACH_TYPE_TASK:
      target_terminal_ours_for_output ();
      if (name != inferior_task)
	printf_filtered ("Task %d died, but it was not the selected task",
			 element->mid);
      else
	{
	  printf_filtered ("Current task %d died", element->mid);
d3817 5
a3821 17
	  mach_port_destroy (mach_task_self (), name);
	  inferior_task = MACH_PORT_NULL;

	  if (notify_chain)
	    warning ("There were still unreceived dead_name_notifications???");

	  /* Destroy the old notifications */
	  setup_notify_port (0);

	}
      break;

    default:
      error ("Unregistered dead_name 0x%x notification received. Type is %d, mid is 0x%x",
	     name, element->type, element->mid);
      break;
    }
d3896 1
a3896 1
  inferior_task = MACH_PORT_NULL;
d3919 1
a3920 1

d3932 1
a3932 1
  proceed ((CORE_ADDR) - 1, 0, 0);
d3946 2
a3947 2
ptrace (a, b, c, d)
     int a, b, c, d;
d3962 1
a3962 1
  kern_return_t ret;
d3967 2
a3968 2
      unsigned int infoCnt = THREAD_BASIC_INFO_COUNT;

d3972 1
a3972 1
      if (!MACH_PORT_VALID (current_thread))
d3974 1
a3974 1

d3979 1
a3979 1
			 (thread_info_t) & th_info,
d3982 1
a3982 1

d3989 1
a3989 1
  if (signal && inferior_pid > 0)	/* Do not signal, if attached by MID */
d3997 1
a3997 1

d4001 1
a4001 1

d4007 1
a4007 1

d4009 2
a4010 2
  while ((ret = task_resume (inferior_task)) == KERN_SUCCESS)
    /* make sure it really runs */ ;
d4019 1
a4019 1
     task_t tid;
d4025 1
a4025 1
  CHK ("task_attach: task_suspend", ret);
d4034 1
a4034 1

d4056 1
a4056 1
     int mid;
d4058 1
a4058 1
  kern_return_t ret;
d4060 2
a4061 2
  ret = machid_mach_port (mid_server, mid_auth, mid, &inferior_task);
  CHK ("mid_attach: machid_mach_port", ret);
d4063 1
a4063 1
  task_attach (inferior_task);
d4065 1
a4065 1
  return mid;
d4083 1
a4083 1
    error ("MID=0, Debugging the master unix server does not compute");
d4086 1
a4086 1
  if (pid == getpid ())
d4100 2
a4101 2
  if (!MACH_PORT_VALID (inferior_task))
    error ("Cannot map Unix pid %d to Mach task port", pid);
d4126 1
a4126 1
  if (pid == getpid ())		/* Trying to masturbate? */
d4149 1
a4149 1
  kern_return_t ret;
d4151 1
a4151 1
  int thread_count, index;
d4160 1
a4160 1
	       mach_error_string (ret));
d4172 1
a4172 1
      CHK ("deallocate_inferior_ports: get refs", ret);
d4180 1
a4180 1
	  CHK ("deallocate_inferior_ports: mod refs", ret);
d4195 1
a4195 1
  inferior_task = MACH_PORT_NULL;
d4221 1
a4221 1
			       TASK_EXCEPTION_PORT,
d4230 1
a4230 1

d4233 1
a4233 1

d4236 1
a4236 1

d4238 1
a4238 1

d4263 1
a4263 1
			 exec_file, target_pid_to_str (inferior_pid));
d4268 1
a4268 1

d4271 1
a4271 1
  unpush_target (&m3_ops);	/* Pop out of handling an inferior */
d4297 1
a4297 1
      attach_flag ? "attached" : "child", target_pid_to_str (inferior_pid));
d4315 1
a4315 2
char *bsd1_names[] =
{
d4383 1
a4383 1
int bsd1_nnames = sizeof (bsd1_names) / sizeof (bsd1_names[0]);
d4385 2
a4386 2
char *
name_str (name, buf)
d4388 2
a4389 2
     int name;
     char *buf;
d4392 19
a4410 20
  switch (name)
    {
    case MACH_MSG_TYPE_BOOLEAN:
      return "boolean";
    case MACH_MSG_TYPE_INTEGER_16:
      return "short";
    case MACH_MSG_TYPE_INTEGER_32:
      return "long";
    case MACH_MSG_TYPE_CHAR:
      return "char";
    case MACH_MSG_TYPE_BYTE:
      return "byte";
    case MACH_MSG_TYPE_REAL:
      return "real";
    case MACH_MSG_TYPE_STRING:
      return "string";
    default:
      sprintf (buf, "%d", name);
      return buf;
    }
d4414 1
a4414 1
id_str (id, buf)
d4416 2
a4417 2
     int id;
     char *buf;
d4420 5
a4424 6
  char *p;
  if (id >= 101000 && id < 101000 + bsd1_nnames)
    {
      if (p = bsd1_names[id - 101000])
	return p;
    }
d4429 1
a4429 1
  sprintf (buf, "%d", id);
d4433 2
a4434 2
print_msg (mp)
     mach_msg_header_t *mp;
d4436 4
a4439 4
  char *fmt_x = "%20s : 0x%08x\n";
  char *fmt_d = "%20s : %10d\n";
  char *fmt_s = "%20s : %s\n";
  char buf[100];
d4443 7
a4449 7
  pr (fmt_x, (*mp), msgh_bits);
  pr (fmt_d, (*mp), msgh_size);
  pr (fmt_x, (*mp), msgh_remote_port);
  pr (fmt_x, (*mp), msgh_local_port);
  pr (fmt_d, (*mp), msgh_kind);
  printf_filtered (fmt_s, STR (msgh_id), id_str (mp->msgh_id, buf));

d4451 37
a4487 45
    {
      char *p, *ep, *dp;
      int plen;
      p = (char *) mp;
      ep = p + mp->msgh_size;
      p += sizeof (*mp);
      for (; p < ep; p += plen)
	{
	  mach_msg_type_t *tp;
	  mach_msg_type_long_t *tlp;
	  int name, size, number;
	  tp = (mach_msg_type_t *) p;
	  if (tp->msgt_longform)
	    {
	      tlp = (mach_msg_type_long_t *) tp;
	      name = tlp->msgtl_name;
	      size = tlp->msgtl_size;
	      number = tlp->msgtl_number;
	      plen = sizeof (*tlp);
	    }
	  else
	    {
	      name = tp->msgt_name;
	      size = tp->msgt_size;
	      number = tp->msgt_number;
	      plen = sizeof (*tp);
	    }
	  printf_filtered ("name=%-16s size=%2d number=%7d inline=%d long=%d deal=%d\n",
			name_str (name, buf), size, number, tp->msgt_inline,
			   tp->msgt_longform, tp->msgt_deallocate);
	  dp = p + plen;
	  if (tp->msgt_inline)
	    {
	      int l;
	      l = size * number / 8;
	      l = (l + sizeof (long) - 1) & ~((sizeof (long)) - 1);
	      plen += l;
	      print_data (dp, size, number);
	    }
	  else
	    {
	      plen += sizeof (int *);
	    }
	  printf_filtered ("plen=%d\n", plen);
	}
d4489 1
d4492 1
a4492 1
print_data (p, size, number)
d4494 1
a4494 1
     char *p;
d4497 3
a4499 3
  int *ip;
  short *sp;
  int i;
d4501 16
a4516 22
  switch (size)
    {
    case 8:
      for (i = 0; i < number; i++)
	{
	  printf_filtered (" %02x", p[i]);
	}
      break;
    case 16:
      sp = (short *) p;
      for (i = 0; i < number; i++)
	{
	  printf_filtered (" %04x", sp[i]);
	}
      break;
    case 32:
      ip = (int *) p;
      for (i = 0; i < number; i++)
	{
	  printf_filtered (" %08x", ip[i]);
	}
      break;
d4518 3
a4520 1
  puts_filtered ("\n");
d4522 1
a4522 1
#endif /* DUMP_SYSCALL */
d4532 1
a4532 1
     int pid;
d4535 1
a4535 1
  return NULL;			/* To keep all compilers happy. */
d4584 3
a4586 3
  ret = mach_port_allocate (mach_task_self (),
			    MACH_PORT_RIGHT_PORT_SET,
			    &inferior_wait_port_set);
d4588 1
a4588 1
    fatal ("initial port set %s", mach_error_string (ret));
d4593 1
a4593 1
  ret = netname_look_up (name_server_port, hostname, "MachID", &mid_server);
d4597 1
a4597 1

d4599 1
a4599 1
	       mach_error_string (ret));
d4602 2
a4603 2

  mid_auth = mach_privileged_host_port ();
d4605 2
a4606 2
    mid_auth = mach_task_self ();

d4609 1
a4609 1
  ret = mach_port_allocate (mach_task_self (),
d4613 1
a4613 1

d4628 4
a4631 4
      char buf[MAX_NAME_LEN];
      ret = mach_port_move_member (mach_task_self (),
				   our_message_port,
				   inferior_wait_port_set);
d4641 1
a4641 1

@


1.1.1.3
log
@import gdb-1999-08-09 snapshot
@
text
@d1686 3
a1688 3
    internal_error ("catch_exception_raise: unknown exception code %d thread %d",
		    exception,
		    mid);
d3601 1
a3601 1
	  internal_error ("Unknown exception");
d3627 1
a3627 1
	internal_error ("Creating notify port %s", mach_error_string (ret));
d3633 1
a3633 1
	internal_error ("initial move member %s", mach_error_string (ret));
d4653 1
a4653 1
    internal_error ("initial port set %s", mach_error_string (ret));
@


1.1.1.4
log
@import gdb-1999-10-04 snapshot
@
text
@d3983 1
a3983 1
  proceed ((CORE_ADDR) -1, 0, 0);
@


1.1.1.5
log
@import gdb-2000-02-01 snapshot
@
text
@d4 1
a4 1
   Copyright (C) 1992, 1996, 1999-2000 Free Software Foundation, Inc.
d2475 1
a2475 1
     struct ui_file *stream;
@


