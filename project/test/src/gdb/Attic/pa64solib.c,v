head	1.33;
access;
symbols
	gdb-csl-arm-20050325-2005-q1b:1.32
	gdb-csl-arm-20050325-2005-q1a:1.32
	csl-arm-20050325-branch:1.32.0.2
	csl-arm-20050325-branchpoint:1.32
	gdb-post-i18n-errorwarning-20050211:1.29
	gdb-pre-i18n-errorwarning-20050211:1.28
	gdb_6_3-20041109-release:1.26
	gdb_6_3-branch:1.26.0.2
	gdb_6_3-20041019-branchpoint:1.26
	drow_intercu-merge-20040921:1.26
	drow_intercu-merge-20040915:1.26
	jimb-gdb_6_2-e500-branch:1.23.0.6
	jimb-gdb_6_2-e500-branchpoint:1.23
	gdb_6_2-20040730-release:1.23
	gdb_6_2-branch:1.23.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.23
	gdb_6_1_1-20040616-release:1.21
	gdb_6_1-2004-04-05-release:1.21
	drow_intercu-merge-20040402:1.21
	drow_intercu-merge-20040327:1.21
	ezannoni_pie-20040323-branch:1.21.0.10
	ezannoni_pie-20040323-branchpoint:1.21
	cagney_tramp-20040321-mergepoint:1.21
	cagney_tramp-20040309-branch:1.21.0.8
	cagney_tramp-20040309-branchpoint:1.21
	gdb_6_1-branch:1.21.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.21
	drow_intercu-20040221-branch:1.21.0.4
	drow_intercu-20040221-branchpoint:1.21
	cagney_bfdfile-20040213-branch:1.21.0.2
	cagney_bfdfile-20040213-branchpoint:1.21
	drow-cplus-merge-20040208:1.21
	carlton_dictionary-20040126-merge:1.19
	cagney_bigcore-20040122-branch:1.19.0.2
	cagney_bigcore-20040122-branchpoint:1.19
	drow-cplus-merge-20040113:1.19
	drow-cplus-merge-20031224:1.19
	drow-cplus-merge-20031220:1.19
	carlton_dictionary-20031215-merge:1.19
	drow-cplus-merge-20031214:1.19
	carlton-dictionary-20031111-merge:1.19
	gdb_6_0-2003-10-04-release:1.17
	kettenis_sparc-20030918-branch:1.17.0.10
	kettenis_sparc-20030918-branchpoint:1.17
	carlton_dictionary-20030917-merge:1.17
	ezannoni_pie-20030916-branchpoint:1.17
	ezannoni_pie-20030916-branch:1.17.0.8
	cagney_x86i386-20030821-branch:1.17.0.6
	cagney_x86i386-20030821-branchpoint:1.17
	carlton_dictionary-20030805-merge:1.17
	carlton_dictionary-20030627-merge:1.17
	gdb_6_0-branch:1.17.0.4
	gdb_6_0-2003-06-23-branchpoint:1.17
	jimb-ppc64-linux-20030613-branch:1.17.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.17
	cagney_convert-20030606-branch:1.16.0.30
	cagney_convert-20030606-branchpoint:1.16
	cagney_writestrings-20030508-branch:1.16.0.28
	cagney_writestrings-20030508-branchpoint:1.16
	jimb-ppc64-linux-20030528-branch:1.16.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.16
	carlton_dictionary-20030523-merge:1.16
	cagney_fileio-20030521-branch:1.16.0.24
	cagney_fileio-20030521-branchpoint:1.16
	kettenis_i386newframe-20030517-mergepoint:1.16
	jimb-ppc64-linux-20030509-branch:1.16.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.16
	kettenis_i386newframe-20030504-mergepoint:1.16
	carlton_dictionary-20030430-merge:1.16
	kettenis_i386newframe-20030419-branch:1.16.0.20
	kettenis_i386newframe-20030419-branchpoint:1.16
	carlton_dictionary-20030416-merge:1.16
	cagney_frameaddr-20030409-mergepoint:1.16
	kettenis_i386newframe-20030406-branch:1.16.0.18
	kettenis_i386newframe-20030406-branchpoint:1.16
	cagney_frameaddr-20030403-branchpoint:1.16
	cagney_frameaddr-20030403-branch:1.16.0.16
	cagney_framebase-20030330-mergepoint:1.16
	cagney_framebase-20030326-branch:1.16.0.14
	cagney_framebase-20030326-branchpoint:1.16
	cagney_lazyid-20030317-branch:1.16.0.12
	cagney_lazyid-20030317-branchpoint:1.16
	kettenis-i386newframe-20030316-mergepoint:1.16
	offbyone-20030313-branch:1.16.0.10
	offbyone-20030313-branchpoint:1.16
	kettenis-i386newframe-20030308-branch:1.16.0.8
	kettenis-i386newframe-20030308-branchpoint:1.16
	carlton_dictionary-20030305-merge:1.16
	cagney_offbyone-20030303-branch:1.16.0.6
	cagney_offbyone-20030303-branchpoint:1.16
	carlton_dictionary-20030207-merge:1.16
	interps-20030203-mergepoint:1.16
	interps-20030202-branch:1.16.0.4
	interps-20030202-branchpoint:1.16
	cagney-unwind-20030108-branch:1.16.0.2
	cagney-unwind-20030108-branchpoint:1.16
	carlton_dictionary-20021223-merge:1.16
	gdb_5_3-2002-12-12-release:1.15
	carlton_dictionary-20021115-merge:1.15
	kseitz_interps-20021105-merge:1.15
	kseitz_interps-20021103-merge:1.15
	drow-cplus-merge-20021020:1.15
	drow-cplus-merge-20021025:1.15
	carlton_dictionary-20021025-merge:1.15
	carlton_dictionary-20021011-merge:1.15
	drow-cplus-branch:1.15.0.10
	drow-cplus-branchpoint:1.15
	kseitz_interps-20020930-merge:1.15
	carlton_dictionary-20020927-merge:1.15
	carlton_dictionary-branch:1.15.0.8
	carlton_dictionary-20020920-branchpoint:1.15
	gdb_5_3-branch:1.15.0.6
	gdb_5_3-2002-09-04-branchpoint:1.15
	kseitz_interps-20020829-merge:1.15
	cagney_sysregs-20020825-branch:1.15.0.4
	cagney_sysregs-20020825-branchpoint:1.15
	readline_4_3-import-branch:1.15.0.2
	readline_4_3-import-branchpoint:1.15
	gdb_5_2_1-2002-07-23-release:1.14
	kseitz_interps-20020528-branch:1.14.0.8
	kseitz_interps-20020528-branchpoint:1.14
	cagney_regbuf-20020515-branch:1.14.0.6
	cagney_regbuf-20020515-branchpoint:1.14
	jimb-macro-020506-branch:1.14.0.4
	jimb-macro-020506-branchpoint:1.14
	gdb_5_2-2002-04-29-release:1.14
	gdb_5_2-branch:1.14.0.2
	gdb_5_2-2002-03-03-branchpoint:1.14
	gdb_5_1_1-2002-01-24-release:1.11
	gdb_5_1_0_1-2002-01-03-release:1.11
	cygnus_cvs_20020108_pre:1.14
	gdb_5_1_0_1-2002-01-03-branchpoint:1.11
	gdb_5_1_0_1-2002-01-03-branch:1.11.0.8
	gdb_5_1-2001-11-21-release:1.11
	gdb_s390-2001-09-26-branch:1.11.0.6
	gdb_s390-2001-09-26-branchpoint:1.11
	gdb_5_1-2001-07-29-branch:1.11.0.4
	gdb_5_1-2001-07-29-branchpoint:1.11
	dberlin-typesystem-branch:1.11.0.2
	dberlin-typesystem-branchpoint:1.11
	gdb-post-ptid_t-2001-05-03:1.11
	gdb-pre-ptid_t-2001-05-03:1.11
	insight-precleanup-2001-01-01:1.9
	gdb-post-protoization-2000-07-29:1.5
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb-post-params-removal-2000-06-04:1.4
	gdb-pre-params-removal-2000-06-04:1.4
	gdb-post-params-removal-2000-05-28:1.4
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.1.1.6
	gdb_4_18_2-2000-05-18-release:1.1.1.6
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.6
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.6
	gdb_5_0-2000-04-10-branch:1.1.1.6.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.6
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.6
	gdb-1999-11-16:1.1.1.6
	gdb-1999-11-08:1.1.1.5
	gdb-1999-11-01:1.1.1.5
	gdb-1999-10-25:1.1.1.5
	gdb-1999-10-18:1.1.1.5
	gdb-1999-10-11:1.1.1.5
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.33
date	2005.04.17.10.24.15;	author kettenis;	state dead;
branches;
next	1.32;

1.32
date	2005.02.18.18.58.56;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2005.02.18.15.25.26;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2005.02.15.15.49.14;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2005.02.11.04.06.01;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2005.01.14.01.01.33;	author msnyder;	state Exp;
branches;
next	1.27;

1.27
date	2004.11.13.02.24.34;	author tausq;	state Exp;
branches;
next	1.26;

1.26
date	2004.09.11.10.24.50;	author hilfingr;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.30.19.17.19;	author eliz;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.26.14.53.04;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.07.05.48.49;	author tausq;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.17.17.19.28;	author tausq;	state Exp;
branches;
next	1.21;

1.21
date	2004.02.07.23.13.47;	author ezannoni;	state Exp;
branches
	1.21.4.1;
next	1.20;

1.20
date	2004.02.07.18.29.54;	author ezannoni;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.06.02.52.27;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.23.03.01.55;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.06.23.32.59;	author mmitchel;	state Exp;
branches;
next	1.16;

1.16
date	2002.12.04.17.53.26;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.08.20.02.50;	author cagney;	state Exp;
branches
	1.15.8.1
	1.15.10.1;
next	1.14;

1.14
date	2001.11.01.16.17.08;	author fnf;	state Exp;
branches
	1.14.6.1
	1.14.8.1;
next	1.13;

1.13
date	2001.10.30.17.34.30;	author fnf;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.30.04.05.34;	author fnf;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.06.08.21.11;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.15.01.01.48;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.20.17.44.07;	author law;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.27.22.30.29;	author ezannoni;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.09.20.09.01;	author msnyder;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.28.01.12.28;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.04.16.52.33;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.27.15.11.13;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.08.23.22.35.40;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.08.23.22.35.40;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.09.22.03.24.51;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.09.28.21.52.23;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.10.05.23.08.35;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.10.12.04.37.23;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.11.17.02.30.27;	author jsm;	state Exp;
branches;
next	;

1.14.6.1
date	2002.06.15.16.42.54;	author cagney;	state Exp;
branches;
next	;

1.14.8.1
date	2002.06.20.01.32.49;	author kseitz;	state Exp;
branches;
next	;

1.15.8.1
date	2002.12.23.19.38.38;	author carlton;	state Exp;
branches;
next	1.15.8.2;

1.15.8.2
date	2003.06.27.21.50.07;	author carlton;	state Exp;
branches;
next	1.15.8.3;

1.15.8.3
date	2003.11.11.23.50.52;	author carlton;	state Exp;
branches;
next	;

1.15.10.1
date	2003.12.14.20.27.27;	author drow;	state Exp;
branches;
next	1.15.10.2;

1.15.10.2
date	2004.02.09.19.43.46;	author drow;	state Exp;
branches;
next	;

1.21.4.1
date	2004.09.16.17.01.16;	author drow;	state Exp;
branches;
next	;


desc
@@


1.33
log
@* pa64solib.c, pa64solib.h: Remove files.
* Makefile.in (pa64solib_h): Remove variable
(pa64solib.o): Remove dependency.
@
text
@/* Handle HP ELF shared libraries for GDB, the GNU Debugger.

   Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation,
   Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.

   HP in their infinite stupidity choose not to use standard ELF dynamic
   linker interfaces.  They also choose not to make their ELF dymamic
   linker interfaces compatible with the SOM dynamic linker.  The
   net result is we can not use either of the existing somsolib.c or
   solib.c.  What a crock.

   Even more disgusting.  This file depends on functions provided only
   in certain PA64 libraries.  Thus this file is supposed to only be
   used native.  When will HP ever learn that they need to provide the
   same functionality in all their libraries!  */

#include <dlfcn.h>
#include <elf.h>
#include <elf_hp.h>

#include "defs.h"

#include "frame.h"
#include "bfd.h"
#include "libhppa.h"
#include "gdbcore.h"
#include "symtab.h"
#include "breakpoint.h"
#include "symfile.h"
#include "objfiles.h"
#include "inferior.h"
#include "gdb-stabs.h"
#include "gdb_stat.h"
#include "gdbcmd.h"
#include "language.h"
#include "regcache.h"
#include "exec.h"
#include "hppa-tdep.h"

#include <fcntl.h>

#ifndef O_BINARY
#define O_BINARY 0
#endif

static CORE_ADDR bfd_lookup_symbol (bfd *, char *);
/* This lives in hppa-tdep.c. */
extern struct unwind_table_entry *find_unwind_entry (CORE_ADDR pc);

/* These ought to be defined in some public interface, but aren't.  They
   identify dynamic linker events.  */
#define DLD_CB_LOAD     1
#define DLD_CB_UNLOAD   0

/* A structure to keep track of all the known shared objects.  */
struct so_list
  {
    bfd *abfd;
    char *name;
    struct so_list *next;
    struct objfile *objfile;
    CORE_ADDR pa64_solib_desc_addr;
    struct load_module_desc pa64_solib_desc;
    struct section_table *sections;
    struct section_table *sections_end;
    int loaded;
  };

static struct so_list *so_list_head;

/* This is the cumulative size in bytes of the symbol tables of all
   shared objects on the so_list_head list.  (When we say size, here
   we mean of the information before it is brought into memory and
   potentially expanded by GDB.)  When adding a new shlib, this value
   is compared against a threshold size, held by auto_solib_limit (in
   megabytes).  If adding symbols for the new shlib would cause the
   total size to exceed the threshold, then the new shlib's symbols
   are not loaded. */
static LONGEST pa64_solib_total_st_size;

/* When the threshold is reached for any shlib, we refuse to add
   symbols for subsequent shlibs, even if those shlibs' symbols would
   be small enough to fit under the threshold.  Although this may
   result in one, early large shlib preventing the loading of later,
   smaller shlibs' symbols, it allows us to issue one informational
   message.  The alternative, to issue a message for each shlib whose
   symbols aren't loaded, could be a big annoyance where the threshold
   is exceeded due to a very large number of shlibs. */
static int pa64_solib_st_size_threshold_exceeded;

/* When adding fields, be sure to clear them in _initialize_pa64_solib. */
typedef struct
  {
    CORE_ADDR dld_flags_addr;
    LONGEST dld_flags;
    struct bfd_section *dyninfo_sect;
    int have_read_dld_descriptor;
    int is_valid;
    CORE_ADDR load_map;
    CORE_ADDR load_map_addr;
    struct load_module_desc dld_desc;
  }
dld_cache_t;

static dld_cache_t dld_cache;

static void pa64_sharedlibrary_info_command (char *, int);

static void pa64_solib_sharedlibrary_command (char *, int);

static void *pa64_target_read_memory (void *, CORE_ADDR, size_t, int);

static int read_dld_descriptor (struct target_ops *, int readsyms);

static int read_dynamic_info (asection *, dld_cache_t *);

static void add_to_solist (int, char *, int, struct load_module_desc *,
			   CORE_ADDR, struct target_ops *);

/* When examining the shared library for debugging information we have to
   look for HP debug symbols, stabs and dwarf2 debug symbols.  */
static char *pa64_debug_section_names[] = {
  ".debug_header", ".debug_gntt", ".debug_lntt", ".debug_slt", ".debug_vt",
  ".stabs", ".stabstr", ".debug_info", ".debug_abbrev", ".debug_aranges",
  ".debug_macinfo", ".debug_line", ".debug_loc", ".debug_pubnames",
  ".debug_str", NULL
};

/* Return a ballbark figure for the amount of memory GDB will need to
   allocate to read in the debug symbols from FILENAME.  */
static LONGEST
pa64_solib_sizeof_symbol_table (char *filename)
{
  bfd *abfd;
  int i;
  int desc;
  char *absolute_name;
  LONGEST st_size = (LONGEST) 0;
  asection *sect;

  /* We believe that filename was handed to us by the dynamic linker, and
     is therefore always an absolute path.  */
  desc = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, filename,
		O_RDONLY | O_BINARY, 0, &absolute_name);
  if (desc < 0)
    {
      perror_with_name (filename);
    }
  filename = absolute_name;

  abfd = bfd_fdopenr (filename, gnutarget, desc);
  if (!abfd)
    {
      close (desc);
      make_cleanup (xfree, filename);
      error (_("\"%s\": can't open to read symbols: %s."), filename,
	     bfd_errmsg (bfd_get_error ()));
    }

  if (!bfd_check_format (abfd, bfd_object))
    {
      bfd_close (abfd);
      make_cleanup (xfree, filename);
      error (_("\"%s\": can't read symbols: %s."), filename,
	     bfd_errmsg (bfd_get_error ()));
    }

  /* Sum the sizes of the various sections that compose debug info. */
  for (i = 0; pa64_debug_section_names[i] != NULL; i++)
    {
      asection *sect;

      sect = bfd_get_section_by_name (abfd, pa64_debug_section_names[i]);
      if (sect)
	st_size += (LONGEST)bfd_section_size (abfd, sect);
    }

  bfd_close (abfd);
  xfree (filename);

  /* Unfortunately, just summing the sizes of various debug info
     sections isn't a very accurate measurement of how much heap
     space the debugger will need to hold them.  It also doesn't
     account for space needed by linker (aka "minimal") symbols.

     Anecdotal evidence suggests that just summing the sizes of
     debug-info-related sections understates the heap space needed
     to represent it internally by about an order of magnitude.

     Since it's not exactly brain surgery we're doing here, rather
     than attempt to more accurately measure the size of a shlib's
     symbol table in GDB's heap, we'll just apply a 10x fudge-
     factor to the debug info sections' size-sum.  No, this doesn't
     account for minimal symbols in non-debuggable shlibs.  But it
     all roughly washes out in the end.  */
  return st_size * (LONGEST) 10;
}

/* Add a shared library to the objfile list and load its symbols into
   GDB's symbol table.  */
static void
pa64_solib_add_solib_objfile (struct so_list *so, char *name, int from_tty,
			      CORE_ADDR text_addr)
{
  bfd *tmp_bfd;
  asection *sec;
  struct hppa_objfile_private *obj_private;
  struct section_addr_info *section_addrs;
  struct cleanup *my_cleanups;

  /* We need the BFD so that we can look at its sections.  We open up the
     file temporarily, then close it when we are done.  */
  tmp_bfd = bfd_openr (name, gnutarget);
  if (tmp_bfd == NULL)
    {
      perror_with_name (name);
      return;
    }

  if (!bfd_check_format (tmp_bfd, bfd_object))
    {
      bfd_close (tmp_bfd);
      error (_("\"%s\" is not an object file: %s"), name,
	     bfd_errmsg (bfd_get_error ()));
    }


  /* Undo some braindamage from symfile.c.

     First, symfile.c will subtract the VMA of the first .text section
     in the shared library that it finds.  Undo that.  */
  sec = bfd_get_section_by_name (tmp_bfd, ".text");
  text_addr += bfd_section_vma (tmp_bfd, sec);

  /* Now find the true lowest section in the shared library.  */
  sec = NULL;
  bfd_map_over_sections (tmp_bfd, find_lowest_section, &sec);

  if (sec)
    {
      /* Subtract out the VMA of the lowest section.  */
      text_addr -= bfd_section_vma (tmp_bfd, sec);

      /* ??? Add back in the filepos of that lowest section. */
      text_addr += sec->filepos;
    }

  section_addrs = alloc_section_addr_info (bfd_count_sections (tmp_bfd));
  my_cleanups = make_cleanup (xfree, section_addrs);

  /* We are done with the temporary bfd.  Get rid of it and make sure
     nobody else can us it.  */
  bfd_close (tmp_bfd);
  tmp_bfd = NULL;

  /* Now let the generic code load up symbols for this library.  */
  section_addrs->other[0].addr = text_addr;
  section_addrs->other[0].name = ".text";
  so->objfile = symbol_file_add (name, from_tty, section_addrs, 0, OBJF_SHARED);
  so->abfd = so->objfile->obfd;

  /* Mark this as a shared library and save private data.  */
  so->objfile->flags |= OBJF_SHARED;

  obj_private = (struct hppa_objfile_private *)
	        objfile_data (so->objfile, hppa_objfile_priv_data);
  if (obj_private == NULL)
    {
      obj_private = (struct hppa_objfile_private *)
	obstack_alloc (&so->objfile->objfile_obstack,
		       sizeof (struct hppa_objfile_private));
      set_objfile_data (so->objfile, hppa_objfile_priv_data, obj_private);
      obj_private->unwind_info = NULL;
      obj_private->so_info = NULL;
    }

  obj_private->so_info = so;
  obj_private->dp = so->pa64_solib_desc.linkage_ptr;
  do_cleanups (my_cleanups);
}

/* Load debugging information for a shared library.  TARGET may be
   NULL if we are not attaching to a process or reading a core file.  */

static void
pa64_solib_load_symbols (struct so_list *so, char *name, int from_tty,
			 CORE_ADDR text_addr, struct target_ops *target)
{
  struct section_table *p;
  asection *sec;
  int status;
  char buf[4];
  CORE_ADDR presumed_data_start;

  if (text_addr == 0)
    text_addr = so->pa64_solib_desc.text_base;

  pa64_solib_add_solib_objfile (so, name, from_tty, text_addr);

  /* Now we need to build a section table for this library since
     we might be debugging a core file from a dynamically linked
     executable in which the libraries were not privately mapped.  */
  if (build_section_table (so->abfd,
			   &so->sections,
			   &so->sections_end))
    {
      error (_("Unable to build section table for shared library\n."));
      return;
    }

  (so->objfile->section_offsets)->offsets[SECT_OFF_TEXT (so->objfile)]
    = so->pa64_solib_desc.text_base;
  (so->objfile->section_offsets)->offsets[SECT_OFF_DATA (so->objfile)]
    = so->pa64_solib_desc.data_base;

  /* Relocate all the sections based on where they got loaded.  */
  for (p = so->sections; p < so->sections_end; p++)
    {
      if (p->the_bfd_section->flags & SEC_CODE)
	{
	  p->addr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_TEXT (so->objfile));
	  p->endaddr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_TEXT (so->objfile));
	}
      else if (p->the_bfd_section->flags & SEC_DATA)
	{
	  p->addr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_DATA (so->objfile));
	  p->endaddr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_DATA (so->objfile));
	}
    }

  /* Now see if we need to map in the text and data for this shared
     library (for example debugging a core file which does not use
     private shared libraries.). 

     Carefully peek at the first text address in the library.  If the
     read succeeds, then the libraries were privately mapped and were
     included in the core dump file.

     If the peek failed, then the libraries were not privately mapped
     and are not in the core file, we'll have to read them in ourselves.  */
  status = target_read_memory (text_addr, buf, 4);
  if (status != 0)
    {
      int new, old;
      
      new = so->sections_end - so->sections;

      old = target_resize_to_sections (target, new);
      
      /* Copy over the old data before it gets clobbered.  */
      memcpy ((char *) (target->to_sections + old),
	      so->sections,
	      ((sizeof (struct section_table)) * new));
    }
}


/* Add symbols from shared libraries into the symtab list, unless the
   size threshold specified by auto_solib_limit (in megabytes) would
   be exceeded.  */

void
pa64_solib_add (char *arg_string, int from_tty, struct target_ops *target, int readsyms)
{
  struct minimal_symbol *msymbol;
  CORE_ADDR addr;
  asection *shlib_info;
  int status;
  unsigned int dld_flags;
  char buf[4], *re_err;
  int threshold_warning_given = 0;
  int dll_index;
  struct load_module_desc dll_desc;
  char *dll_path;

  /* First validate our arguments.  */
  if ((re_err = re_comp (arg_string ? arg_string : ".")) != NULL)
    {
      error (_("Invalid regexp: %s"), re_err);
    }

  /* If we're debugging a core file, or have attached to a running
     process, then pa64_solib_create_inferior_hook will not have been
     called.

     We need to first determine if we're dealing with a dynamically
     linked executable.  If not, then return without an error or warning.

     We also need to examine __dld_flags to determine if the shared
     library list is valid and to determine if the libraries have been
     privately mapped.  */
  if (symfile_objfile == NULL)
    return;

  /* First see if the objfile was dynamically linked.  */
  shlib_info = bfd_get_section_by_name (symfile_objfile->obfd, ".dynamic");
  if (!shlib_info)
    return;

  /* It's got a .dynamic section, make sure it's not empty.  */
  if (bfd_section_size (symfile_objfile->obfd, shlib_info) == 0)
    return;

  /* Read in the load map pointer if we have not done so already.  */
  if (! dld_cache.have_read_dld_descriptor)
    if (! read_dld_descriptor (target, readsyms))
      return;

  /* If the libraries were not mapped private, warn the user.  */
  if ((dld_cache.dld_flags & DT_HP_DEBUG_PRIVATE) == 0)
    warning (_("\
The shared libraries were not privately mapped; setting a\n\
breakpoint in a shared library will not work until you rerun the program."));

  /* For each shaerd library, add it to the shared library list.  */
  for (dll_index = 1; ; dll_index++)
    {
      /* Read in the load module descriptor.  */
      if (dlgetmodinfo (dll_index, &dll_desc, sizeof (dll_desc),
			pa64_target_read_memory, 0, dld_cache.load_map)
	  == 0)
	return;

      /* Get the name of the shared library.  */
      dll_path = (char *)dlgetname (&dll_desc, sizeof (dll_desc),
			    pa64_target_read_memory,
			    0, dld_cache.load_map);

      if (!dll_path)
	error (_("pa64_solib_add, unable to read shared library path."));

      add_to_solist (from_tty, dll_path, readsyms, &dll_desc, 0, target);
    }
}


/* This hook gets called just before the first instruction in the
   inferior process is executed.

   This is our opportunity to set magic flags in the inferior so
   that GDB can be notified when a shared library is mapped in and
   to tell the dynamic linker that a private copy of the library is
   needed (so GDB can set breakpoints in the library).

   We need to set two flag bits in this routine.

     DT_HP_DEBUG_PRIVATE to indicate that shared libraries should be
     mapped private.

     DT_HP_DEBUG_CALLBACK to indicate that we want the dynamic linker
     to call the breakpoint routine for significant events.  */

void
pa64_solib_create_inferior_hook (void)
{
  struct minimal_symbol *msymbol;
  unsigned int dld_flags, status;
  asection *shlib_info, *interp_sect;
  char buf[4];
  struct objfile *objfile;
  CORE_ADDR anaddr;

  /* First, remove all the solib event breakpoints.  Their addresses
     may have changed since the last time we ran the program.  */
  remove_solib_event_breakpoints ();

  if (symfile_objfile == NULL)
    return;

  /* First see if the objfile was dynamically linked.  */
  shlib_info = bfd_get_section_by_name (symfile_objfile->obfd, ".dynamic");
  if (!shlib_info)
    return;

  /* It's got a .dynamic section, make sure it's not empty.  */
  if (bfd_section_size (symfile_objfile->obfd, shlib_info) == 0)
    return;

  /* Read in the .dynamic section.  */
  if (! read_dynamic_info (shlib_info, &dld_cache))
    error (_("Unable to read the .dynamic section."));

  /* Turn on the flags we care about.  */
  dld_cache.dld_flags |= DT_HP_DEBUG_PRIVATE;
  dld_cache.dld_flags |= DT_HP_DEBUG_CALLBACK;
  status = target_write_memory (dld_cache.dld_flags_addr,
				(char *) &dld_cache.dld_flags,
				sizeof (dld_cache.dld_flags));
  if (status != 0)
    error (_("Unable to modify dynamic linker flags."));

  /* Now we have to create a shared library breakpoint in the dynamic
     linker.  This can be somewhat tricky since the symbol is inside
     the dynamic linker (for which we do not have symbols or a base
     load address!   Luckily I wrote this code for solib.c years ago.  */
  interp_sect = bfd_get_section_by_name (exec_bfd, ".interp");
  if (interp_sect)
    {
      unsigned int interp_sect_size;
      char *buf;
      CORE_ADDR load_addr;
      bfd *tmp_bfd;
      CORE_ADDR sym_addr = 0;

      /* Read the contents of the .interp section into a local buffer;
	 the contents specify the dynamic linker this program uses.  */
      interp_sect_size = bfd_section_size (exec_bfd, interp_sect);
      buf = alloca (interp_sect_size);
      bfd_get_section_contents (exec_bfd, interp_sect,
				buf, 0, interp_sect_size);

      /* Now we need to figure out where the dynamic linker was
	 loaded so that we can load its symbols and place a breakpoint
	 in the dynamic linker itself.

	 This address is stored on the stack.  However, I've been unable
	 to find any magic formula to find it for Solaris (appears to
	 be trivial on GNU/Linux).  Therefore, we have to try an alternate
	 mechanism to find the dynamic linker's base address.  */
      tmp_bfd = bfd_openr (buf, gnutarget);
      if (tmp_bfd == NULL)
	goto get_out;

      /* Make sure the dynamic linker's really a useful object.  */
      if (!bfd_check_format (tmp_bfd, bfd_object))
	{
	  warning (_("Unable to grok dynamic linker %s as an object file"), buf);
	  bfd_close (tmp_bfd);
	  goto get_out;
	}

      /* We find the dynamic linker's base address by examining the
	 current pc (which point at the entry point for the dynamic
	 linker) and subtracting the offset of the entry point. 

	 Also note the breakpoint is the second instruction in the
	 routine.  */
      load_addr = read_pc () - tmp_bfd->start_address;
      sym_addr = bfd_lookup_symbol (tmp_bfd, "__dld_break");
      sym_addr = load_addr + sym_addr + 4;
      
      /* Create the shared library breakpoint.  */
      {
	struct breakpoint *b
	  = create_solib_event_breakpoint (sym_addr);

	/* The breakpoint is actually hard-coded into the dynamic linker,
	   so we don't need to actually insert a breakpoint instruction
	   there.  In fact, the dynamic linker's code is immutable, even to
	   ttrace, so we shouldn't even try to do that.  For cases like
	   this, we have "permanent" breakpoints.  */
	make_breakpoint_permanent (b);
      }

      /* We're done with the temporary bfd.  */
      bfd_close (tmp_bfd);
    }

get_out:
  /* Wipe out all knowledge of old shared libraries since their
     mapping can change from one exec to another!  */
  while (so_list_head)
    {
      struct so_list *temp;

      temp = so_list_head;
      xfree (so_list_head);
      so_list_head = temp->next;
    }
  clear_symtab_users ();
}

/* This operation removes the "hook" between GDB and the dynamic linker,
   which causes the dld to notify GDB of shared library events.

   After this operation completes, the dld will no longer notify GDB of
   shared library events.  To resume notifications, GDB must call
   pa64_solib_create_inferior_hook.

   This operation does not remove any knowledge of shared libraries
   of which GDB may already have been notified.  */

void
pa64_solib_remove_inferior_hook (int pid)
{
  /* Turn off the DT_HP_DEBUG_CALLBACK bit in the dynamic linker flags.  */
  dld_cache.dld_flags &= ~DT_HP_DEBUG_CALLBACK;
  target_write_memory (dld_cache.dld_flags_addr,
		       (char *)&dld_cache.dld_flags,
		       sizeof (dld_cache.dld_flags));
}

/* This function creates a breakpoint on the dynamic linker hook, which
   is called when e.g., a shl_load or shl_unload call is made.  This
   breakpoint will only trigger when a shl_load call is made.

   If filename is NULL, then loads of any dll will be caught.  Else,
   only loads of the file whose pathname is the string contained by
   filename will be caught.

   Undefined behaviour is guaranteed if this function is called before
   pa64_solib_create_inferior_hook.  */

void
pa64_solib_create_catch_load_hook (int pid, int tempflag, char *filename,
				   char *cond_string)
{
  create_solib_load_event_breakpoint ("", tempflag, filename, cond_string);
}

/* This function creates a breakpoint on the dynamic linker hook, which
   is called when e.g., a shl_load or shl_unload call is made.  This
   breakpoint will only trigger when a shl_unload call is made.

   If filename is NULL, then unloads of any dll will be caught.  Else,
   only unloads of the file whose pathname is the string contained by
   filename will be caught.

   Undefined behaviour is guaranteed if this function is called before
   pa64_solib_create_inferior_hook.  */

void
pa64_solib_create_catch_unload_hook (int pid, int tempflag, char *filename,
				     char *cond_string)
{
  create_solib_unload_event_breakpoint ("", tempflag, filename, cond_string);
}

/* Return nonzero if the dynamic linker has reproted that a library
   has been loaded.  */

int
pa64_solib_have_load_event (int pid)
{
  CORE_ADDR event_kind;

  event_kind = read_register (HPPA_ARG0_REGNUM);
  return (event_kind == DLD_CB_LOAD);
}

/* Return nonzero if the dynamic linker has reproted that a library
   has been unloaded.  */
int
pa64_solib_have_unload_event (int pid)
{
  CORE_ADDR event_kind;

  event_kind = read_register (HPPA_ARG0_REGNUM);
  return (event_kind == DLD_CB_UNLOAD);
}

/* Return a pointer to a string indicating the pathname of the most
   recently loaded library.

   The caller is reposible for copying the string before the inferior is
   restarted.  */

char *
pa64_solib_loaded_library_pathname (int pid)
{
  static char dll_path[MAXPATHLEN];
  CORE_ADDR  dll_path_addr = read_register (HPPA_ARG3_REGNUM);
  read_memory_string (dll_path_addr, dll_path, MAXPATHLEN);
  return dll_path;
}

/* Return a pointer to a string indicating the pathname of the most
   recently unloaded library.

   The caller is reposible for copying the string before the inferior is
   restarted.  */

char *
pa64_solib_unloaded_library_pathname (int pid)
{
  static char dll_path[MAXPATHLEN];
  CORE_ADDR dll_path_addr = read_register (HPPA_ARG3_REGNUM);
  read_memory_string (dll_path_addr, dll_path, MAXPATHLEN);
  return dll_path;
}

/* Return nonzero if PC is an address inside the dynamic linker.  */

int
pa64_solib_in_dynamic_linker (int pid, CORE_ADDR pc)
{
  asection *shlib_info;

  if (symfile_objfile == NULL)
    return 0;

  if (!dld_cache.have_read_dld_descriptor)
    if (!read_dld_descriptor (&current_target, auto_solib_add))
      return 0;

  return (pc >= dld_cache.dld_desc.text_base
	  && pc < dld_cache.dld_desc.text_base + dld_cache.dld_desc.text_size);
}


/* Return the GOT value for the shared library in which ADDR belongs.  If
   ADDR isn't in any known shared library, return zero.  */

CORE_ADDR
pa64_solib_get_got_by_pc (CORE_ADDR addr)
{
  struct so_list *so_list = so_list_head;
  CORE_ADDR got_value = 0;

  while (so_list)
    {
      if (so_list->pa64_solib_desc.text_base <= addr
	  && ((so_list->pa64_solib_desc.text_base
	       + so_list->pa64_solib_desc.text_size)
	      > addr))
	{
	  got_value = so_list->pa64_solib_desc.linkage_ptr;
	  break;
	}
      so_list = so_list->next;
    }
  return got_value;
}

/* Return the address of the handle of the shared library in which ADDR
   belongs.  If ADDR isn't in any known shared library, return zero. 

   This function is used in hppa_fix_call_dummy in hppa-tdep.c.  */

CORE_ADDR
pa64_solib_get_solib_by_pc (CORE_ADDR addr)
{
  struct so_list *so_list = so_list_head;
  CORE_ADDR retval = 0;

  while (so_list)
    {
      if (so_list->pa64_solib_desc.text_base <= addr
	  && ((so_list->pa64_solib_desc.text_base
	       + so_list->pa64_solib_desc.text_size)
	      > addr))
	{
	  retval = so_list->pa64_solib_desc_addr;
	  break;
	}
      so_list = so_list->next;
    }
  return retval;
}

/* Dump information about all the currently loaded shared libraries.  */

static void
pa64_sharedlibrary_info_command (char *ignore, int from_tty)
{
  struct so_list *so_list = so_list_head;

  if (exec_bfd == NULL)
    {
      printf_unfiltered ("No executable file.\n");
      return;
    }

  if (so_list == NULL)
    {
      printf_unfiltered ("No shared libraries loaded at this time.\n");
      return;
    }

  printf_unfiltered ("Shared Object Libraries\n");
  printf_unfiltered ("   %-19s%-19s%-19s%-19s\n",
		     "  text start", "   text end",
		     "  data start", "   data end");
  while (so_list)
    {
      unsigned int flags;

      printf_unfiltered ("%s", so_list->name);
      if (so_list->objfile == NULL)
	printf_unfiltered ("  (symbols not loaded)");
      if (so_list->loaded == 0)
	printf_unfiltered ("  (shared library unloaded)");
      printf_unfiltered ("  %-18s",
	hex_string_custom (so_list->pa64_solib_desc.linkage_ptr, 16));
      printf_unfiltered ("\n");
      printf_unfiltered ("%-18s",
	hex_string_custom (so_list->pa64_solib_desc.text_base, 16));
      printf_unfiltered (" %-18s",
	hex_string_custom ((so_list->pa64_solib_desc.text_base
			    + so_list->pa64_solib_desc.text_size), 16));
      printf_unfiltered (" %-18s",
	hex_string_custom (so_list->pa64_solib_desc.data_base, 16));
      printf_unfiltered (" %-18s\n",
	hex_string_custom ((so_list->pa64_solib_desc.data_base
			    + so_list->pa64_solib_desc.data_size), 16));
      so_list = so_list->next;
    }
}

/* Load up one or more shared libraries as directed by the user.  */

static void
pa64_solib_sharedlibrary_command (char *args, int from_tty)
{
  dont_repeat ();
  pa64_solib_add (args, from_tty, (struct target_ops *) 0, 1);
}

/* Return the name of the shared library containing ADDR or NULL if ADDR
   is not contained in any known shared library.  */

char *
pa64_solib_address (CORE_ADDR addr)
{
  struct so_list *so = so_list_head;

  while (so)
    {
      /* Is this address within this shlib's text range?  If so,
	 return the shlib's name.  */
      if (addr >= so->pa64_solib_desc.text_base
	  && addr < (so->pa64_solib_desc.text_base
		     | so->pa64_solib_desc.text_size))
	return so->name;

      /* Nope, keep looking... */
      so = so->next;
    }

  /* No, we couldn't prove that the address is within a shlib. */
  return NULL;
}

/* We are killing the inferior and restarting the program.  */

void
pa64_solib_restart (void)
{
  struct so_list *sl = so_list_head;

  /* Before the shlib info vanishes, use it to disable any breakpoints
     that may still be active in those shlibs.  */
  disable_breakpoints_in_shlibs (0);

  /* Discard all the shlib descriptors.  */
  while (sl)
    {
      struct so_list *next_sl = sl->next;
      xfree (sl);
      sl = next_sl;
    }
  so_list_head = NULL;

  pa64_solib_total_st_size = (LONGEST) 0;
  pa64_solib_st_size_threshold_exceeded = 0;

  dld_cache.is_valid = 0;
  dld_cache.have_read_dld_descriptor = 0;
  dld_cache.dld_flags_addr = 0;
  dld_cache.load_map = 0;
  dld_cache.load_map_addr = 0;
  dld_cache.dld_desc.data_base = 0;
  dld_cache.dld_flags = 0;
  dld_cache.dyninfo_sect = 0;
}

void
_initialize_pa64_solib (void)
{
  add_com ("sharedlibrary", class_files, pa64_solib_sharedlibrary_command,
	   _("Load shared object library symbols for files matching REGEXP."));
  add_info ("sharedlibrary", pa64_sharedlibrary_info_command,
	    _("Status of loaded shared object libraries."));

  add_setshow_boolean_cmd ("auto-solib-add", class_support,
			   &auto_solib_add, _("\
Set autoloading of shared library symbols."), _("\
Show autoloading of shared library symbols."), _("\
If \"on\", symbols from all shared object libraries will be loaded\n\
automatically when the inferior begins execution, when the dynamic linker\n\
informs gdb that a new library has been loaded, or when attaching to the\n\
inferior.  Otherwise, symbols must be loaded manually, using `sharedlibrary'."),
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_zinteger_cmd ("auto-solib-limit", class_support,
			    &auto_solib_limit, _("\
Set threshold (in Mb) for autoloading shared library symbols."), _("\
Show threshold (in Mb) for autoloading shared library symbols."), _("\
When shared library autoloading is enabled, new libraries will be loaded\n\
only until the total size of shared library symbols exceeds this\n\
threshold in megabytes.  Is ignored when using `sharedlibrary'."),
			    NULL,
			    NULL, /* FIXME: i18n: */
			    &setlist, &showlist);

  /* ??rehrauer: On HP-UX, the kernel parameter MAXDSIZ limits how
     much data space a process can use.  We ought to be reading
     MAXDSIZ and setting auto_solib_limit to some large fraction of
     that value.  If not that, we maybe ought to be setting it smaller
     than the default for MAXDSIZ (that being 64Mb, I believe).
     However, [1] this threshold is only crudely approximated rather
     than actually measured, and [2] 50 Mbytes is too small for
     debugging gdb itself.  Thus, the arbitrary 100 figure.  */
  auto_solib_limit = 100;	/* Megabytes */

  pa64_solib_restart ();
}

/* Get some HPUX-specific data from a shared lib.  */
CORE_ADDR
pa64_solib_thread_start_addr (struct so_list *so)
{
  return so->pa64_solib_desc.tls_start_addr;
}

/* Read the dynamic linker's internal shared library descriptor.

   This must happen after dld starts running, so we can't do it in
   read_dynamic_info.  Record the fact that we have loaded the
   descriptor.  If the library is archive bound, then return zero, else
   return nonzero.  */

static int
read_dld_descriptor (struct target_ops *target, int readsyms)
{
  char *dll_path;
  asection *dyninfo_sect;

  /* If necessary call read_dynamic_info to extract the contents of the
     .dynamic section from the shared library.  */
  if (!dld_cache.is_valid) 
    {
      if (symfile_objfile == NULL)
	error (_("No object file symbols."));

      dyninfo_sect = bfd_get_section_by_name (symfile_objfile->obfd, 
					      ".dynamic");
      if (!dyninfo_sect) 
	{
	  return 0;
	}

      if (!read_dynamic_info (dyninfo_sect, &dld_cache))
	error (_("Unable to read in .dynamic section information."));
    }

  /* Read the load map pointer.  */
  if (target_read_memory (dld_cache.load_map_addr,
			  (char*) &dld_cache.load_map,
			  sizeof(dld_cache.load_map))
      != 0)
    {
      error (_("Error while reading in load map pointer."));
    }

  /* Read in the dld load module descriptor */
  if (dlgetmodinfo (-1, 
		    &dld_cache.dld_desc,
		    sizeof(dld_cache.dld_desc), 
		    pa64_target_read_memory, 
		    0, 
		    dld_cache.load_map)
      == 0)
    {
      error (_("Error trying to get information about dynamic linker."));
    }

  /* Indicate that we have loaded the dld descriptor.  */
  dld_cache.have_read_dld_descriptor = 1;

  /* Add dld.sl to the list of known shared libraries so that we can
     do unwind, etc. 

     ?!? This may not be correct.  Consider of dld.sl contains symbols
     which are also referenced/defined by the user program or some user
     shared library.  We need to make absolutely sure that we do not
     pollute the namespace from GDB's point of view.  */
  dll_path = dlgetname (&dld_cache.dld_desc, 
			sizeof(dld_cache.dld_desc), 
			pa64_target_read_memory, 
			0, 
			dld_cache.load_map);
  add_to_solist(0, dll_path, readsyms, &dld_cache.dld_desc, 0, target);
  
  return 1;
}

/* Read the .dynamic section and extract the information of interest,
   which is stored in dld_cache.  The routine elf_locate_base in solib.c 
   was used as a model for this.  */

static int
read_dynamic_info (asection *dyninfo_sect, dld_cache_t *dld_cache_p)
{
  char *buf;
  char *bufend;
  CORE_ADDR dyninfo_addr;
  int dyninfo_sect_size;
  CORE_ADDR entry_addr;

  /* Read in .dynamic section, silently ignore errors.  */
  dyninfo_addr = bfd_section_vma (symfile_objfile->obfd, dyninfo_sect);
  dyninfo_sect_size = bfd_section_size (exec_bfd, dyninfo_sect);
  buf = alloca (dyninfo_sect_size);
  if (target_read_memory (dyninfo_addr, buf, dyninfo_sect_size))
    return 0;

  /* Scan the .dynamic section and record the items of interest. 
     In particular, DT_HP_DLD_FLAGS */
  for (bufend = buf + dyninfo_sect_size, entry_addr = dyninfo_addr;
       buf < bufend;
       buf += sizeof (Elf64_Dyn), entry_addr += sizeof (Elf64_Dyn))
    {
      Elf64_Dyn *x_dynp = (Elf64_Dyn*)buf;
      Elf64_Sxword dyn_tag;
      CORE_ADDR	dyn_ptr;
      char *pbuf;

      pbuf = alloca (TARGET_PTR_BIT / HOST_CHAR_BIT);
      dyn_tag = bfd_h_get_64 (symfile_objfile->obfd, 
			      (bfd_byte*) &x_dynp->d_tag);

      /* We can't use a switch here because dyn_tag is 64 bits and HP's
	 lame comiler does not handle 64bit items in switch statements.  */
      if (dyn_tag == DT_NULL)
	break;
      else if (dyn_tag == DT_HP_DLD_FLAGS)
	{
	  /* Set dld_flags_addr and dld_flags in *dld_cache_p */
	  dld_cache_p->dld_flags_addr = entry_addr + offsetof(Elf64_Dyn, d_un);
	  if (target_read_memory (dld_cache_p->dld_flags_addr,
	  			  (char*) &dld_cache_p->dld_flags, 
				  sizeof(dld_cache_p->dld_flags))
	      != 0)
	    {
	      error (_("Error while reading in .dynamic section of the program."));
	    }
	}
      else if (dyn_tag == DT_HP_LOAD_MAP)
	{
	  /* Dld will place the address of the load map at load_map_addr
	     after it starts running.  */
	  if (target_read_memory (entry_addr + offsetof(Elf64_Dyn, 
							d_un.d_ptr),
				  (char*) &dld_cache_p->load_map_addr,
				  sizeof(dld_cache_p->load_map_addr))
	      != 0)
	    {
	      error (_("Error while reading in .dynamic section of the program."));
	    }
	}
      else 
	{
	  /* tag is not of interest */
	}
    }

  /* Record other information and set is_valid to 1. */
  dld_cache_p->dyninfo_sect = dyninfo_sect;

  /* Verify that we read in required info.  These fields are re-set to zero
     in pa64_solib_restart.  */

  if (dld_cache_p->dld_flags_addr != 0 && dld_cache_p->load_map_addr != 0) 
    dld_cache_p->is_valid = 1;
  else 
    return 0;

  return 1;
}

/* Wrapper for target_read_memory to make dlgetmodinfo happy.  */

static void *
pa64_target_read_memory (void *buffer, CORE_ADDR ptr, size_t bufsiz, int ident)
{
  if (target_read_memory (ptr, buffer, bufsiz) != 0)
    return 0;
  return buffer;
}

/* Called from handle_dynlink_load_event and pa64_solib_add to add
   a shared library to so_list_head list and possibly to read in the
   debug information for the library.  

   If load_module_desc_p is NULL, then the load module descriptor must
   be read from the inferior process at the address load_module_desc_addr.  */

static void
add_to_solist (int from_tty, char *dll_path, int readsyms,
	       struct load_module_desc *load_module_desc_p,
	       CORE_ADDR load_module_desc_addr, struct target_ops *target)
{
  struct so_list *new_so, *so_list_tail;
  int pa64_solib_st_size_threshhold_exceeded;
  LONGEST st_size;

  if (symfile_objfile == NULL)
    return;

  so_list_tail = so_list_head;
  /* Find the end of the list of shared objects.  */
  while (so_list_tail && so_list_tail->next)
    {
      if (strcmp (so_list_tail->name, dll_path) == 0)
	return;
      so_list_tail = so_list_tail->next;
    }

  if (so_list_tail && strcmp (so_list_tail->name, dll_path) == 0)
    return;

  /* Add the shared library to the so_list_head list */
  new_so = (struct so_list *) xmalloc (sizeof (struct so_list));
  memset ((char *)new_so, 0, sizeof (struct so_list));
  if (so_list_head == NULL)
    {
      so_list_head = new_so;
      so_list_tail = new_so;
    }
  else
    {
      so_list_tail->next = new_so;
      so_list_tail = new_so;
    }

  /* Initialize the new_so */
  if (load_module_desc_p)
    {
      new_so->pa64_solib_desc = *load_module_desc_p;
    }
  else
    {
      if (target_read_memory (load_module_desc_addr, 
			      (char*) &new_so->pa64_solib_desc,
			      sizeof(struct load_module_desc))
	  != 0)
      {
	error (_("Error while reading in dynamic library %s"), dll_path);
      }
    }
  
  new_so->pa64_solib_desc_addr = load_module_desc_addr;
  new_so->loaded = 1;
  new_so->name = obsavestring (dll_path, strlen(dll_path),
			       &symfile_objfile->objfile_obstack);

  /* If we are not going to load the library, tell the user if we
     haven't already and return.  */

  st_size = pa64_solib_sizeof_symbol_table (dll_path);
  pa64_solib_st_size_threshhold_exceeded =
       !from_tty 
    && readsyms
    && (  (st_size + pa64_solib_total_st_size) 
	> (auto_solib_limit * (LONGEST) (1024 * 1024)));
  if (pa64_solib_st_size_threshhold_exceeded)
    {
      pa64_solib_add_solib_objfile (new_so, dll_path, from_tty, 1);
      return;
    } 

  /* Now read in debug info. */
  pa64_solib_total_st_size += st_size;

  /* This fills in new_so->objfile, among others. */
  pa64_solib_load_symbols (new_so, 
			   dll_path,
			   from_tty, 
			   0,
			   target);
  return;
}


/*
   LOCAL FUNCTION

   bfd_lookup_symbol -- lookup the value for a specific symbol

   SYNOPSIS

   CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname)

   DESCRIPTION

   An expensive way to lookup the value of a single symbol for
   bfd's that are only temporary anyway.  This is used by the
   shared library support to find the address of the debugger
   interface structures in the shared library.

   Note that 0 is specifically allowed as an error return (no
   such symbol).
 */

static CORE_ADDR
bfd_lookup_symbol (bfd *abfd, char *symname)
{
  unsigned int storage_needed;
  asymbol *sym;
  asymbol **symbol_table;
  unsigned int number_of_symbols;
  unsigned int i;
  struct cleanup *back_to;
  CORE_ADDR symaddr = 0;

  storage_needed = bfd_get_symtab_upper_bound (abfd);

  if (storage_needed > 0)
    {
      symbol_table = (asymbol **) xmalloc (storage_needed);
      back_to = make_cleanup (xfree, symbol_table);
      number_of_symbols = bfd_canonicalize_symtab (abfd, symbol_table);

      for (i = 0; i < number_of_symbols; i++)
	{
	  sym = *symbol_table++;
	  if (strcmp (sym->name, symname) == 0)
	    {
	      /* Bfd symbols are section relative. */
	      symaddr = sym->value + sym->section->vma;
	      break;
	    }
	}
      do_cleanups (back_to);
    }
  return (symaddr);
}

@


1.32
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_zinteger_cmd through out.  Re-sync gdbarch.sh
	and gdbarch.c.
	* breakpoint.c, frame.c, gdb-events.sh, gdbarch.sh: Update.
	* gdbtypes.c, infrun.c, linux-nat.c, maint.c, monitor.c: Update.
	* pa64solib.c, parse.c, remote-mips.c, ser-go32.c: Update.
	* serial.c, solib-frv.c, somsolib.c, target.c, top.c: Update.
	* varobj.c, cli/cli-cmds.c: Update.
	* gdbarch.c, gdb-events.c: Regenerate.
@
text
@@


1.31
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_boolean_command through out.  Delete #ifdef 0'ed
	code adding set/show boolean commands.
	* cp-valprint.c, dcache.c, exec.c, gdbtypes.c, infrun.c: Update.
	* monitor.c, p-valprint.c, pa64solib.c, printcmd.c: Update.
	* proc-api.c, remote-mips.c, remote.c, solib.c: Update.
	* somsolib.c, symfile.c, top.c, utils.c, valops.c: Update.
	* valprint.c, win32-nat.c, wince.c, xcoffsolib.c: Update.
	* cli/cli-cmds.c: Update.
@
text
@d904 4
a907 4
  deprecated_add_show_from_set
    (add_set_cmd ("auto-solib-limit", class_support, var_zinteger,
		  (char *) &auto_solib_limit,
		  "Set threshold (in Mb) for autoloading shared library symbols.\n\
d910 4
a913 3
threshold in megabytes.  Is ignored when using `sharedlibrary'.",
		  &setlist),
     &showlist);
@


1.30
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d892 4
a895 4
  deprecated_add_show_from_set
    (add_set_cmd ("auto-solib-add", class_support, var_boolean,
		  (char *) &auto_solib_add,
		  "Set autoloading of shared library symbols.\n\
d899 4
a902 3
inferior.  Otherwise, symbols must be loaded manually, using `sharedlibrary'.",
		  &setlist),
     &showlist);
@


1.29
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d888 1
a888 1
	   "Load shared object library symbols for files matching REGEXP.");
d890 1
a890 1
	    "Status of loaded shared object libraries.");
@


1.28
log
@2005-01-13  Michael Snyder  <msnyder@@redhat.com>

	* pa64solib.[ch]: Whitespace tweaks.
@
text
@d173 1
a173 1
      error ("\"%s\": can't open to read symbols: %s.", filename,
d181 1
a181 1
      error ("\"%s\": can't read symbols: %s.", filename,
d240 1
a240 1
      error ("\"%s\" is not an object file: %s", name,
d324 1
a324 1
      error ("Unable to build section table for shared library\n.");
d396 1
a396 1
      error ("Invalid regexp: %s", re_err);
d428 3
a430 1
    warning ("The shared libraries were not privately mapped; setting a\nbreakpoint in a shared library will not work until you rerun the program.\n");
d447 1
a447 1
	error ("pa64_solib_add, unable to read shared library path.");
d498 1
a498 1
    error ("Unable to read the .dynamic section.");
d507 1
a507 1
    error ("Unable to modify dynamic linker flags.");
d544 1
a544 1
	  warning ("Unable to grok dynamic linker %s as an object file", buf);
d951 1
a951 1
	error ("No object file symbols.");
d961 1
a961 1
	error ("Unable to read in .dynamic section information.");
d970 1
a970 1
      error ("Error while reading in load map pointer.");
d982 1
a982 1
      error ("Error trying to get information about dynamic linker.");
d1053 1
a1053 1
	      error ("Error while reading in .dynamic section of the program.");
d1066 1
a1066 1
	      error ("Error while reading in .dynamic section of the program.");
d1156 1
a1156 1
	error ("Error while reading in dynamic library %s", dll_path);
@


1.27
log
@2004-11-12  Randolph Chung  <tausq@@debian.org>

	* pa64solib.c (pa64_solib_thread_start_addr): Rename from
	so_lib_thread_start_addr.
	* pa64solib.h (so_list): Forward declare.
	(pa64_solib_thread_start_addr): Prototype.
	* somsolib.c (SHL_LOAD, SHL_UNLOAD): Define if not already defined.
	(no_shared_libraries): Remove.
	(som_solib_thread_start_addr): Rename from so_lib_thread_start_addr.
	* somsolib.h (som_solib_thread_start_addr): Likewise; prototype.
	* hpread.c (hpread_process_one_debug_symbol): Use either the som or
	the elf solib handler to find the start address.

	* config/pa/hppahpux.mh (NATDEPFILES): Move target-specific support
	files to the target makefile.
	* config/pa/hpux1020.mh (NATDEPFILES):  Likewise.
	* config/pa/hpux11.mh (NATDEPFILES): Likewise.
	* config/pa/hpux11w.mh (NATDEPFILES): Likewise.

	* config/pa/hppa64.mt (TDEPFILES): Put target-specific support
	files for symbol reading and shared library handling here.
	* config/pa/hppahpux.mt (TDEPFILES): Likewise.
	(PA_SOM_ONLY): Define so we can build a 32-bit SOM only target
	without bringing in 64-bit support.
@
text
@d406 3
a408 3
     We also need to examine __dld_flags to determine if the shared library
     list is valid and to determine if the libraries have been privately
     mapped.  */
d465 2
a466 2
     DT_HP_DEBUG_CALLBACK to indicate that we want the dynamic linker to
     call the breakpoint routine for significant events.  */
d595 2
a596 2
   This operation does not remove any knowledge of shared libraries which
   GDB may already have been notified of.  */
@


1.26
log
@* language.c (local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string, use C format, and move to
utils.c
(local_hex_string_custom): Rename to hex_string_custom and change
interface.  Now uses C format.  Move to utils.c
(local_octal_format_custom): Remove.
(local_decimal_format_custom): Remove.
(unknown_language_defn): Remove language-specific number
formatting entries.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* language.h (struct language_format_info): Delete declaration.
(struct language_defn): Remove language_format_info fields
la_binary_format, la_octal_format, la_decimal_format, la_hex_format.
(local_binary_format): Remove macro.
(local_binary_format_prefix): Remove macro.
(local_binary_format_specifier): Remove macro.
(local_binary_format_suffix): Remove macro.
(local_octal_format): Remove macro.
(local_octal_format_prefix): Remove macro.
(local_octal_format_specifier): Remove macro.
(local_octal_format_suffix): Remove macro.
(local_decimal_format): Remove macro.
(local_decimal_format_prefix): Remove macro.
(local_decimal_format_specifier): Remove macro.
(local_decimal_format_suffix): Remove macro.
(local_hex_format): Remove macro.
(local_hex_format_prefix): Remove macro.
(local_hex_format_specifier): Remove macro.
(local_hex_format_suffix): Remove macro.
(local_decimal_format_custom): Remove.
(local_octal_format_custom): Remove.
(local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string and move to defs.h.
(local_hex_string_custom): Rename to hex_string_custom, change
interface, and move to defs.h.
* utils.c: (int_string): New function.
(hex_string): New function (from language.c).
(hex_string_custom): New function (from language.c).
(octal2str): New function.
(decimal2str): Add width parameter.
(paddr_u): Use new decimal2str interface.
(paddr_d): Ditto.
* defs.h (hex_string): Declare.
(hex_string_custom): Declare.
(int_string): Declare.
* printcmd.c (print_scalar_formatted): Remove localized binary
formatting.
* valprint.c (print_longest): Use int_string.
(print_floating): Use C hex format.
(print_hex_chars): Ditto.
(print_binary_chars): Remove language-specific formatting.
(print_octal_chars): Use C octal format.
(print_decimal_chars): Delocalize format.
(print_decimal): Remove.
* ada-lang.c (ada_language_defn): Remove language-specific number
formatting entries.
* p-lang.c (pascal_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.
* memattr.c (mem_info_command): Use renamed hex_string_custom with
new interface.
* pa64solib.c (pa64_sharedlibrary_info_command): Ditto.
* ui-out.c (ui_out_field_core_addr): Ditto.
* breakpoint.c (breakpoint_adjustment_warning): Ditto.
* exec.c (print_section_info): Ditto.
* i387-tdep.c (print_i387_status_word): Ditto.
(print_i387_control_word): Ditto.
(i387_print_float_info): Ditto.
* maint.c (maint_print_section_info): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* somsolib.c (som_sharedlibrary_info_command): Ditto.
* symtab.c (print_msymbol_info): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* solib-frv.c (lm_base): Ditto.
(frv_current_sos): Ditto.
(enable_break2): Ditto.
(enable_break): Ditto.
* dbxread.c (read_dbx_symtab): Use renamed hex_string.
(process_one_symbol): Ditto.
* infcmd.c (program_info): Ditto.
* mdebugread.c (parse_partial_symbols): Ditto.
* symfile.c (add_symbol_file_command): Ditto.
* cli/cli-cmds.c (edit_command): Ditto.
(list_command): Ditto.
* infcall.c (call_function_by_hand): Ditto.
* remote-vx.c (vx_run_files_info): Ditto.
(vx_wait): Ditto.
(vx_attach): Ditto.
(vx_detach): Ditto.
(vx_kill): Ditto.
* aix-thread.c (pdc_symbol_addrs): Ditto.
(pdc_read_regs): Ditto.
(pdc_write_regs): Ditto.
(pdc_read_data): Ditto.
(pdc_write_data): Ditto.
* d10v-tdep.c (display_trace): Ditto.
* rs6000-nat.c (find_toc_address): Ditto.
* aix-thread.c: Don't include language.h.
* buildsym.c: Ditto.
* dbxread.c: Ditto.
* mdebugread.c: Ditto.
* rs6000-nat.c: Ditto.
* buildsym.c (make_blockvector): Use renamed hex_string.
@
text
@d926 1
a926 1
so_lib_thread_start_addr (struct so_list *so)
@


1.25
log
@	* defs.h (OPF_TRY_CWD_FIRST, OPF_SEARCH_IN_PATH): New macros.

	* exec.c (exec_file_attach):
	* nto-tdep.c (nto_find_and_open_solib):
	* pa64solib.c (pa64_solib_sizeof_symbol_table):
	* solib.c (solib_open):
	* somsolib.c (som_solib_sizeof_symbol_table):
	* source.c (is_regular_file, openp, open_source_file):
	* symfile.c (symfile_bfd_open):
	* wince.c (upload_to_device): Differentiate between the search for
	binary and source files.
@
text
@d799 1
a799 2
	local_hex_string_custom (so_list->pa64_solib_desc.linkage_ptr,
				 "016l"));
d802 1
a802 2
	local_hex_string_custom (so_list->pa64_solib_desc.text_base,
				 "016l"));
d804 2
a805 3
	local_hex_string_custom ((so_list->pa64_solib_desc.text_base
				  + so_list->pa64_solib_desc.text_size),
				 "016l"));
d807 1
a807 2
	local_hex_string_custom (so_list->pa64_solib_desc.data_base,
				 "016l"));
d809 2
a810 3
	local_hex_string_custom ((so_list->pa64_solib_desc.data_base
				  + so_list->pa64_solib_desc.data_size),
				 "016l"));
@


1.24
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d160 2
a161 2
  desc = openp (getenv ("PATH"), 1, filename, O_RDONLY | O_BINARY,
		0, &absolute_name);
@


1.23
log
@2004-05-06  Randolph Chung  <tausq@@debian.org>

	* config/pa/tm-hppa.h (RO_REGNUM, FLAGS_REGNUM, RP_REGNUM)
	(HPPA_FP_REGNUM, HPPA_SP_REGNUM, SAR_REGNUM, IPSW_REGNUM)
	(PCOQ_HEAD_REGNUM, PCSQ_HEAD_REGNUM, PCOQ_TAIL_REGNUM, PCSQ_TAIL_REGNUM)
	(EIEM_REGNUM, IIR_REGNUM, ISR_REGNUM, IOR_REGNUM, SR4_REGNUM)
	(RCR_REGNUM, PID0_REGNUM, PID1_REGNUM, PID2_REGNUM, PID3_REGNUM)
	(CCR_REGNUM, TR0_REGNUM, CR27_REGNUM, HPPA_FP0_REGNUM, FP4_REGNUM)
	(ARG0_REGNUM, ARG1_REGNUM, ARG2_REGNUM, ARG3_REGNUM): Move *_REGNUM
	definitions ...
	* hppa-tdep.h: ... to here, with HPPA_ prefix.
	* Makefile.in (hppah-nat.o): Add $(hppa_tdep_h)
	* hppa-hpux-tdep.c (hppa32_hpux_frame_find_saved_regs_in_sig)
	(hppa64_hpux_frame_find_saved_regs_in_sig)
	(child_get_current_exception_event): Add HPPA_ prefix to *_REGNUM usage.
	* hppa-linux-nat.c (GR_REGNUM, TR_REGNUM, greg_map): Likewise.
	* hppa-linux-tdep.c (hppa_dwarf_reg_to_regnum)
	(hppa_linux_target_write_pc, hppa_linux_sigtramp_frame_unwind_cache)
	(hppa_linux_sigtramp_frame_prev_register): Likewise.
	* hppa-tdep.c (hppa32_return_value, hppa64_return_value)
	(hppa32_push_dummy_call, hppa64_push_dummy_call, hppa64_frame_align)
	(hppa_target_read_pc, hppa_target_write_pc, hppa_frame_cache)
	(hppa_frame_prev_register, hppa_stub_frame_unwind_cache)
	(hppa_stub_frame_prev_register, hppa_unwind_dummy_id)
	(hppa_skip_permanent_breakpoint, hppa_instruction_nullified)
	(hppa32_register_type, hppa_cannot_store_register)
	(hppa_fetch_pointer_argument, hppa_pseudo_register_read): Likewise.
	* hppah-nat.c (store_inferior_registers, fetch_register): Likewise.
	* hpread.c (hpread_process_one_debug_symbol): Likewise.
	* pa64solib.c (pa64_solib_have_load_event)
	(pa64_solib_have_unload_event, pa64_solib_loaded_library_pathname)
	(pa64_solib_unloaded_library_pathname): Likewise.
	* somsolib.c (som_solib_have_load_event, som_solib_have_unload_event)
	(som_solib_library_pathname): Likewise.
@
text
@d895 1
a895 1
  add_show_from_set
d906 1
a906 1
  add_show_from_set
@


1.22
log
@2004-04-17  Randolph Chung  <tausq@@debian.org>

	* Makefile.in (hpread.o, pa64solib.o, somsolib.o): Add $(hppa_tdep_h)
	* hppa-tdep.c (hppa_objfile_priv_data): New.
	(SR4EXPORT_LDIL_OFFSET, SR4EXPORT_LDO_OFFSET): Use
	HPPA_INSTRUCTION_SIZE.
	(read_unwind_info): Use objfile_data to reference unwind info.
	(find_unwind_entry): Likewise.
	(hpread_adjust_stack_address): Move to hpread.c.
	(_initialize_hppa_tdep): Register hppa objfile data.
	* hppa-tdep.h (HPPA_INSTRUCTION_SIZE): Define.
	(unwind_table_entry, unwind_stub_types): Move from tm-hppa.h.
	(obj_unwind_info, obj_private_struct): Move from tm-hppa.h, and rename
	with hppa_ prefix.
	* hpread.c (hppa-tdep.h): Include.
	(hpread_adjust_stack_address): Move from hppa-tdep.c.
	(hpread_read_function_type, hpread_read_doc_function_type)
	(hpread_process_one_debug_symbol): Call hpread_adjust_stack_address
	directly. Use objfile_data to access solib data.
	* pa64solib.c (hppa-tdep.h): Include.
	(pa64_solib_add_solib_objfile): Use objfile_data to access solib data.
	* somsolib.c (hppa-tdep.h): Include.
	(som_solib_add_solib_objfile): Use objfile_data to access solib data.
	* config/pa/tm-hppa.h (frame_info, frame_saved_regs, value, type)
	(inferior_status): Remove unused forward declarations.
	(INSTRUCTION_SIZE): Move to hppa-tdep.c.
	(unwind_table_entry, unwind_stub_types, obj_unwind_info)
	(obj_private_struct): Move to hppa-tdep.h.
	(HPREAD_ADJUST_STACK_ADDRESS): Remove.
@
text
@d652 1
a652 1
  event_kind = read_register (ARG0_REGNUM);
d663 1
a663 1
  event_kind = read_register (ARG0_REGNUM);
d677 1
a677 1
  CORE_ADDR  dll_path_addr = read_register (ARG3_REGNUM);
d692 1
a692 1
  CORE_ADDR dll_path_addr = read_register (ARG3_REGNUM);
@


1.21
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* buildsym.c (free_pending_blocks, finish_block)
	(record_pending_block, make_blockvector, end_symtab): Replace
	symbol_obstack with objfile_obstack.
	* coffread.c (process_coff_symbol, coff_read_struct_type)
	(coff_read_enum_type): Ditto.
	* cp-namespace.c (initialize_namespace_symtab)
	(check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol, dwarf2_const_value, macro_start_file)
	(dwarf2_symbol_mark_computed): Ditto.
	* dwarfread.c (enum_type, new_symbol, synthesize_typedef): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* hpread.c (hpread_symfile_init, hpread_symfile_init)
	(hpread_read_enum_type, hpread_read_function_type)
	(hpread_read_doc_function_type, hpread_process_one_debug_symbol):
	Ditto.
	* jv-lang.c (get_java_class_symtab, add_class_symbol)
	(java_link_class_type): Ditto.
	* mdebugread.c (parse_symbol, psymtab_to_symtab_1, new_symtab)
	(new_symbol): Ditto.
	* minsyms.c (install_minimal_symbols): Ditto.
	* objfiles.c (allocate_objfile): Remove init of symbol_obstack.
	(terminate_minimal_symbol_table): Replace symbol_obstack with
	objfile_obstack.
	(free_objfile): Remove freeing of symbol_obstack.
	* objfiles.h: Remove symbol_obstack field.
	* pa64solib.c (add_to_solist): Replace symbol_obstack with
	objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
	symbol_obstack.
	(solib_add_common_symbols): Replace symbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add): Ditto.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_start, common_block_end): Ditto.
	* symfile.c (reread_symbols): Remove freeing and init of
	symbol_obstack.
	(allocate_symtab): Rename symbol_obstack to objfile_obstack.
	* symfile.h: Update comment.
	* symmisc.c (print_objfile_statistics): Remove symbol_obstack
	stats printing.
	* symtab.c (symbol_set_names): Replace symbol_obstack with
	objfile_obstack.
	* symtab.h (struct general_symbol_info, struct minimal_symbol):
	Update comments.
	* xcoffread.c (read_xcoff_symtab, SYMBOL_DUP, SYMNAME_ALLOC)
	(init_stringtab, xcoff_initial_scan): Replace symbol_obstack with
	objfile_obstack.
@
text
@d55 1
d224 1
a224 1
  obj_private_data_t *obj_private;
d282 3
a284 1
  if (so->objfile->obj_private == NULL)
d286 1
a286 1
      obj_private = (obj_private_data_t *)
d288 2
a289 1
		       sizeof (obj_private_data_t));
a291 1
      so->objfile->obj_private = obj_private;
a293 1
  obj_private = (obj_private_data_t *) so->objfile->obj_private;
@


1.21.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a54 1
#include "hppa-tdep.h"
d159 2
a160 2
  desc = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, filename,
		O_RDONLY | O_BINARY, 0, &absolute_name);
d223 1
a223 1
  struct hppa_objfile_private *obj_private;
d281 1
a281 3
  obj_private = (struct hppa_objfile_private *)
	        objfile_data (so->objfile, hppa_objfile_priv_data);
  if (obj_private == NULL)
d283 1
a283 1
      obj_private = (struct hppa_objfile_private *)
d285 1
a285 2
		       sizeof (struct hppa_objfile_private));
      set_objfile_data (so->objfile, hppa_objfile_priv_data, obj_private);
d288 1
d291 1
d650 1
a650 1
  event_kind = read_register (HPPA_ARG0_REGNUM);
d661 1
a661 1
  event_kind = read_register (HPPA_ARG0_REGNUM);
d675 1
a675 1
  CORE_ADDR  dll_path_addr = read_register (HPPA_ARG3_REGNUM);
d690 1
a690 1
  CORE_ADDR dll_path_addr = read_register (HPPA_ARG3_REGNUM);
d797 2
a798 1
	hex_string_custom (so_list->pa64_solib_desc.linkage_ptr, 16));
d801 2
a802 1
	hex_string_custom (so_list->pa64_solib_desc.text_base, 16));
d804 3
a806 2
	hex_string_custom ((so_list->pa64_solib_desc.text_base
			    + so_list->pa64_solib_desc.text_size), 16));
d808 2
a809 1
	hex_string_custom (so_list->pa64_solib_desc.data_base, 16));
d811 3
a813 2
	hex_string_custom ((so_list->pa64_solib_desc.data_base
			    + so_list->pa64_solib_desc.data_size), 16));
d893 1
a893 1
  deprecated_add_show_from_set
d904 1
a904 1
  deprecated_add_show_from_set
@


1.20
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* dbxread.c (dbx_symfile_init, start_psymtab, end_psymtab,
	coffstab_build_psymtabs, elfstab_build_psymtabs)
	(stabsect_build_psymtabs): Replace psymbol_obstack with
	objfile_obstack.
	* dwarf2-frame.c (decode_frame_entry_1): Ditto.
	* dwarf2read.c (dwarf2_build_psymtabs_hard, dwarf2_read_section):
	Ditto.
	* dwarfread.c (scan_compilation_units): Ditto.
	* elfread.c (elfstab_offset_sections): Ditto.
	* hppa-tdep.c (read_unwind_info): Ditto.
	* hpread.c (hpread_build_psymtabs, hpread_start_psymtab)
	(hpread_end_psymtab): Ditto.
	* mdebugread.c (mdebug_build_psymtabs, add_pending)
	(parse_partial_symbols, new_psymtab, elfmdebug_build_psymtabs):
	Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* objfiles.c (add_to_objfile_sections)
	(build_objfile_section_table): Ditto.
	(allocate_objfile): Remove init of psymbol_obstack.
	(free_objfile): Remove freeing of psymbol_obstack.
	* objfiles.h (struct objfile): Remove field
	psymbol_obstack. Update comments.
	* pa64solib.c (pa64_solib_add_solib_objfile): Replace
	psymbol_obstack with objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
        psymbol_obstack.
	* somread.c (som_symfile_offsets, init_import_symbols)
	(init_export_symbols): Replace psymbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
	* symfile.c (default_symfile_offsets, syms_from_objfile)
	(reread_symbols): Remove freeing and init of psymbol_obstack.
	(cashier_psymtab): Update comment.
	* symmisc.c (print_objfile_statistics): Don't report stats for
	psymbol obstack.
	* symtab.h (struct general_symbol_info, struct partial_symtab):
	Update comments.
	* xcoffread.c (xcoff_start_psymtab, xcoff_end_psymtab, swap_sym)
	(xcoff_symfile_offsets): Replace psymbol_obstack with
	objfile_obstack.
@
text
@d1164 1
a1164 1
			       &symfile_objfile->symbol_obstack);
@


1.19
log
@2003-11-05  Andrew Cagney  <cagney@@redhat.com>

	* xcoffread.c (find_linenos): Replace "sec_ptr" and "bfd" with
	"struct bfd_section" and "struct bfd".
	* target.h (struct section_table): Ditto.
	* rs6000-nat.c (xcoff_relocate_core): Ditto.
	* solib-svr4.c (elf_locate_base): Ditto.
	* pa64solib.c (dld_cache_t): Ditto.
	* objfiles.h (struct obj_section): Ditto.
	* objfiles.c (add_to_objfile_sections): Ditto.
	* exec.c (bfdsec_to_vmap): Ditto.
	(add_to_section_table): Ditto.
	(build_section_table): Ditto.
	* corelow.c (get_core_register_section): Ditto.
	* coffread.c (find_linenos): Ditto.
	* elfread.c (elf_interpreter): Delete #if0'd function.

	* mips-tdep.c (mips_dump_tdep): Delete code prinint VX_NUM_REGS.
	* config/sparc/tm-vxsparc.h (VX_NUM_REGS): Delete macro.
	* config/mips/tm-vxmips.h (VX_NUM_REGS): Delete macro.
	* config/m68k/tm-vx68.h (VX_NUM_REGS): Delete macro.

	* arch-utils.h (generic_cannot_extract_struct_value_address):
	Delete declaration.
	* wince.c (_initialize_wince): Fix multi-line string.
	* ia64-tdep.c (floatformat_valid): Convert to ISO C.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d284 1
a284 1
	obstack_alloc (&so->objfile->psymbol_obstack,
@


1.18
log
@2003-10-22  Andrew Cagney  <cagney@@redhat.com>

	* exec.h: New file.
	* win32-nat.c: Include "exec.h".
	* solib.c: Include "exec.h".
	* target.h (build_section_table): Delete declaration.
	* somsolib.c: Include "exec.h".
	(exec_ops): Delete extern declaration.
	* rs6000-nat.c: Update copyright.  Include "exec.h".
	(exec_ops): Delete extern declaration.
	* pa64solib.c: Update copyright.  Include "exec.h".
	(exec_ops): Delete extern declaration.
	* exec.c: Update copyright.  Include "exec.h".
	* corelow.c: Update dependencies.  Include "exec.h".
	* Makefile.in (exec_h): Define.
	(exec.o, somsolib.o): Update dependencies.
	(pa64solib.o, corelow.o): Update dependencies.
@
text
@d112 1
a112 1
    sec_ptr dyninfo_sect;
@


1.17
log
@	* elfread.c (elf_symtab_read): Avoid use of SECT_OFF_MAX.
	(elfstab_offset_sections): Likewise.
	* gdb-stabs.h (stab_section_info): Likewise.
	* i386-interix-tdep.c (pei_adjust_objfile_offsets): Likewise.
	* objfiles.c (objfile_relocate): Likewise.
	* pa64solib.c (pa64_solib_add_solib_objfile): Likewise.
	* remote.c (get_offsets): Likewise.
	(remote_cisco_objfile_relocate): Likewise.
	* somread.c (som_symfile_offsets): Likewise.
	* symfile.c (alloc_section_addr_info): New function.
	(build_section_addr_info_from_section_tab): Use it.
	(free_section_addr_info): Adjust.
	(default_symfile_offsets): Avoid use of SECT_OFF_MAX.
	(syms_from_objfile): Allocate local_addr dynamically.
	(symbol_file_add_with_addrs_or_offsets): Allocate orig_addrs
	dynamically.
	(add_symbol_file_command): Allocate sect_opts dynamically.
	(reread_symbols): Avoid use of SECT_OFF_MAX.
	* symfile.h (section_addr_info): Do not use MAX_SECTIONS.
	(alloc_section_addr_info): Declare it.
	* symtab.h (SIZEOF_SECTION_OFFSETS): Remove.
	* win32-nat.c (solib_symbols_add): Allocate section_addrs
	dynamically.
	* xcoffread.c (xcoff_symfile_offsets): Avoid use of SECT_OFF_MAX.
@
text
@d3 2
a4 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d54 1
a60 3

/* Defined in exec.c; used to prevent dangling pointer bug.  */
extern struct target_ops exec_ops;
@


1.16
log
@       * pa64solib.c: s/boolean/int/. Fixes a build failure on hppa64-hpux.
@
text
@d225 2
a226 1
  struct section_addr_info section_addrs;
a227 1
  memset (&section_addrs, 0, sizeof (section_addrs));
d265 3
d274 3
a276 3
  section_addrs.other[0].addr = text_addr;
  section_addrs.other[0].name = ".text";
  so->objfile = symbol_file_add (name, from_tty, &section_addrs, 0, OBJF_SHARED);
d295 1
@


1.15
log
@* objfiles.h: Change type of obj_private to void pointer.
* pa64solib.c: Update copyright.  Don't include "assert.h", use
strcmp instead of STREQ, use LONGEST, do not use PTR
* somsolib.c: Ditto.
@
text
@d83 1
a83 1
    boolean loaded;
d114 2
a115 2
    boolean have_read_dld_descriptor;
    boolean is_valid;
d130 1
a130 1
static boolean read_dld_descriptor (struct target_ops *, int readsyms);
d132 1
a132 1
static boolean read_dynamic_info (asection *, dld_cache_t *);
d134 1
a134 1
static void add_to_solist (boolean, char *, int, struct load_module_desc *,
d938 1
a938 1
static boolean
d1007 1
a1007 1
static boolean
d1105 1
a1105 1
add_to_solist (boolean from_tty, char *dll_path, int readsyms,
@


1.15.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 2
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.
a52 1
#include "exec.h"
d60 3
d83 1
a83 1
    int loaded;
d113 3
a115 3
    struct bfd_section *dyninfo_sect;
    int have_read_dld_descriptor;
    int is_valid;
d130 1
a130 1
static int read_dld_descriptor (struct target_ops *, int readsyms);
d132 1
a132 1
static int read_dynamic_info (asection *, dld_cache_t *);
d134 1
a134 1
static void add_to_solist (int, char *, int, struct load_module_desc *,
d225 1
a225 2
  struct section_addr_info *section_addrs;
  struct cleanup *my_cleanups;
d227 1
a264 3
  section_addrs = alloc_section_addr_info (bfd_count_sections (tmp_bfd));
  my_cleanups = make_cleanup (xfree, section_addrs);

d271 3
a273 3
  section_addrs->other[0].addr = text_addr;
  section_addrs->other[0].name = ".text";
  so->objfile = symbol_file_add (name, from_tty, section_addrs, 0, OBJF_SHARED);
a291 1
  do_cleanups (my_cleanups);
d938 1
a938 1
static int
d1007 1
a1007 1
static int
d1105 1
a1105 1
add_to_solist (int from_tty, char *dll_path, int readsyms,
@


1.15.10.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation,
d284 1
a284 1
	obstack_alloc (&so->objfile->objfile_obstack,
d1164 1
a1164 1
			       &symfile_objfile->objfile_obstack);
@


1.15.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d83 1
a83 1
    int loaded;
d114 2
a115 2
    int have_read_dld_descriptor;
    int is_valid;
d130 1
a130 1
static int read_dld_descriptor (struct target_ops *, int readsyms);
d132 1
a132 1
static int read_dynamic_info (asection *, dld_cache_t *);
d134 1
a134 1
static void add_to_solist (int, char *, int, struct load_module_desc *,
d938 1
a938 1
static int
d1007 1
a1007 1
static int
d1105 1
a1105 1
add_to_solist (int from_tty, char *dll_path, int readsyms,
@


1.15.8.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d225 1
a225 2
  struct section_addr_info *section_addrs;
  struct cleanup *my_cleanups;
d227 1
a264 3
  section_addrs = alloc_section_addr_info (bfd_count_sections (tmp_bfd));
  my_cleanups = make_cleanup (xfree, section_addrs);

d271 3
a273 3
  section_addrs->other[0].addr = text_addr;
  section_addrs->other[0].name = ".text";
  so->objfile = symbol_file_add (name, from_tty, section_addrs, 0, OBJF_SHARED);
a291 1
  do_cleanups (my_cleanups);
@


1.15.8.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d3 1
a3 2
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.
a52 1
#include "exec.h"
d60 3
d113 1
a113 1
    struct bfd_section *dyninfo_sect;
@


1.14
log
@Approved by kev@@cygnus.com
ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* coff-solib.c (coff_solib_add): Add new readsyms arg.
	* irix5-nat.c (solib_add): Ditto.
	* osfsolib.c (solib_add): Ditto.
	* pa64solib.c (pa64_solib_add): Ditto.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* solib.c (solib_add): Ditto.
	* somsolib.c (som_solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* coff-solib.h (coff_solib_add): Add new readsyms arg to prototype.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* pa64solib.h (pa64_solib_add): Ditto.
	* solib.h (solib_add): Ditto.
	* somsolib.h (som_solib_add): Ditto.
	* config/i386/tm-cygwin.h (child_solib_add): Ditto.

	* coff-solib.c (coff_solib_add):  If readsyms is zero don't read
	symbols but do any other needed work for shared libs.
	* irix5-nat.c: Ditto.
	* osfsolib.c (solib_add): Ditto.
	* solib.c (solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* irix5-nat.c (sharedlibrary_command): Pass 1 as readsyms to
	solib_add to force reading of shared library symbols.
	* osfsolib.c (sharedlibrary_command;): Ditto.
	* pa64solib.c (pa64_solib_sharedlibrary_command): Ditto.
	* solib.c (sharedlibrary_command): Ditto.
	* somsolib.c (som_solib_sharedlibrary_command): Ditto.
	* xcoffsolib.c (sharedlibrary_command): Ditto.

	* coff-solib.c (coff_solib_create_inferior_hook): Call solib_add
	unconditionally with auto_solib_add.
	* irix5-nat.c (solib_create_inferior_hook): Ditto.
	* osfsolib.c (solib_create_inferior_hook): Ditto.
	* solib.c (solib_create_inferior_hook): Ditto.
	* solib-osf.c (osf_solib_create_inferior_hook): Ditto.
	* solib-svr4.c (enable_break): Ditto.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Ditto.

	* corelow.c (solib_add_stub): Add auto_solib_add to args passed
	via SOLIB_ADD.
	* sol-thread.c (sol_thread_attach): Ditto.
	* config/rs6000/nm-rs6000.h (SOLIB_ADD): Ditto.

	* infcmd.c (attach_command): Remove auto_solib_add decl.
	Call SOLIB_ADD directly with auto_solib_add.
	* infrun.c (handle_inferior_event): Ditto.

	* coff-solib.h (SOLIB_ADD): Add readsyms arg.
	* pa64solib.h (SOLIB_ADD): Ditto.
	* solib.h (SOLIB_ADD): Ditto.
	* somsolib.h (SOLIB_ADD): Ditto.
	* config/i386/tm-cygwin.h (SOLIB_ADD): Ditto.

	* fork-child.c (clone_and_follow_inferior): Remove unused
	auto_solib_add decl.

	* pa64solib.c (pa64_solib_add): Call add_to_solist with readsyms.
	(read_dld_descriptor): Ditto.
	(pa64_solib_add): Call read_dld_descriptor with	readsyms.
	(pa64_solib_in_dynamic_linker): Ditto.

	* corelow.c (symfile.h): Need this for auto_solib_add declaration.
	* sol-thread.c (symfile.h): Ditto.

Approved by eliz@@is.elta.co.il
doc/ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* gdbint.texinfo (SOLIB_ADD): Document additional new
	"readsyms" arg.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
a50 1
#include "assert.h"
d112 1
a112 1
    long long dld_flags;
d254 1
a254 1
  bfd_map_over_sections (tmp_bfd, find_lowest_section, (PTR) &sec);
d286 1
a286 1
      so->objfile->obj_private = (PTR) obj_private;
d1227 1
a1227 1
      back_to = make_cleanup (xfree, (PTR) symbol_table);
d1233 1
a1233 1
	  if (STREQ (sym->name, symname))
@


1.14.8.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d2 1
a2 2

   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d50 1
d112 1
a112 1
    LONGEST dld_flags;
d254 1
a254 1
  bfd_map_over_sections (tmp_bfd, find_lowest_section, &sec);
d286 1
a286 1
      so->objfile->obj_private = obj_private;
d1227 1
a1227 1
      back_to = make_cleanup (xfree, symbol_table);
d1233 1
a1233 1
	  if (strcmp (sym->name, symname) == 0)
@


1.14.6.1
log
@merge from trunk
@
text
@d2 1
a2 2

   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d50 1
d112 1
a112 1
    LONGEST dld_flags;
d254 1
a254 1
  bfd_map_over_sections (tmp_bfd, find_lowest_section, &sec);
d286 1
a286 1
      so->objfile->obj_private = obj_private;
d1227 1
a1227 1
      back_to = make_cleanup (xfree, symbol_table);
d1233 1
a1233 1
	  if (strcmp (sym->name, symname) == 0)
@


1.13
log
@	2001-10-30  Fred Fish  <fnf@@redhat.com>
	* somsolib.c (som_solib_add): A megabyte is 1024*1024 bytes.
	* pa64solib.c (add_to_solist): Ditto.
	* win32-nat.c (_initialize_inftarg): Remove unnecessary
	initialization of auto_solib_add, it defaults to 1.
@
text
@d130 1
a130 1
static boolean read_dld_descriptor (struct target_ops *);
d134 1
a134 1
static void add_to_solist (boolean, char *, struct load_module_desc *,
d375 1
a375 1
pa64_solib_add (char *arg_string, int from_tty, struct target_ops *target)
d418 1
a418 1
    if (! read_dld_descriptor (target))
d442 1
a442 1
      add_to_solist (from_tty, dll_path, &dll_desc, 0, target);
d703 1
a703 1
    if (!read_dld_descriptor (&current_target))
d821 1
a821 1
  pa64_solib_add (args, from_tty, (struct target_ops *) 0);
d939 1
a939 1
read_dld_descriptor (struct target_ops *target)
d998 1
a998 1
  add_to_solist(0, dll_path,  &dld_cache.dld_desc, 0, target);
d1105 1
a1105 1
add_to_solist (boolean from_tty, char *dll_path,
d1169 1
a1169 1
    && auto_solib_add
@


1.12
log
@Changes approved by kev@@cygnus.com, ezannoni@@cygnus.com, eliz@@is.elta.co.il.

  Changelog:

	2001-10-27  Fred Fish  <fnf@@redhat.com>

	* symfile.c (auto_solib_add): Update comment to note that
	this variable is now just used as a boolean to control shlib
	autoloading, and clarify when it is used.
	* symfile.h (auto_solib_add): Ditto.

	* symfile.c (auto_solib_limit): New variable that holds the
	autoloading threshold instead of overloading auto_solib_add.
	* symfile.h (auto_solib_limit): Ditto.

	* irix5-nat.c (_initialize_solib): Change auto-solib-add
	variable from var_zinteger to var_boolean and update help.
	* osfsolib.c (_initialize_solib): Ditto.
	* pa64solib.c (_initialize_pa64_solib): Ditto.
	* solib.c (_initialize_solib): Ditto.
	* somsolib.c (_initialize_som_solib): Ditto.
	* xcoffsolib.c (_initialize_solib): Ditto.

	* pa64solib.c (pa64_solib_total_st_size): Update comment to
	note that the new auto_solib_limit variable is used instead
	of overloading auto_solib_add variable.
	(_initialize_pa64_solib): Ditto.
	* somsolib.c (som_solib_total_st_size): Ditto.
	(_initialize_som_solib): Ditto.

	* pa64solib.c (_initialize_pa64_solib): Add new set/show
	commands for auto-solib-limit variable.
	* somsolib.c (_initialize_som_solib): Ditto

	* pa64solib.c (add_to_solist): Check that auto_solib_add is
	set and use auto_solib_limit as the threshold size instead
	of auto_solib_add.
	* somsolib.c (som_solib_add): Ditto, and also change warning
	text about size threshold exceeded.

  doc/ChangeLog:

	2001-10-28  Fred Fish  <fnf@@redhat.com>

	* gdb.texinfo (auto-solib-add): Change docs to match
	implementation change.
	(auto-solib-limit): Add docs for new variable.
@
text
@d1171 1
a1171 1
	> (auto_solib_limit * (LONGEST)1000000));
@


1.11
log
@Update/correct copyright notices.
@
text
@d92 4
a95 4
   is compared against the threshold size, held by auto_solib_add
   (in megabytes).  If adding symbols for the new shlib would cause
   the total size to exceed the threshold, then the new shlib's symbols
   are not loaded.  */
d100 1
a100 1
   be small enough to fit under the threshold.  (Although this may
d102 1
a102 1
   smalller shlibs' symbols, it allows us to issue one informational
d105 1
a105 1
   is exceeded due to a very large number of shlibs.) */
d371 1
a371 1
   size threshold (specified by auto_solib_add, in megabytes) would
d889 1
d891 1
a891 1
    (add_set_cmd ("auto-solib-add", class_support, var_zinteger,
d893 15
a907 6
		  "Set autoloading size threshold (in megabytes) of shared library symbols.\n\
If nonzero, symbols from all shared object libraries will be loaded\n\
automatically when the inferior begins execution or when the dynamic linker\n\
informs gdb that a new library has been loaded, until the symbol table\n\
of the program and libraries exceeds this threshold.\n\
Otherwise, symbols must be loaded manually, using `sharedlibrary'.",
d911 9
a919 10
  /* ??rehrauer: On HP-UX, the kernel parameter MAXDSIZ limits how much
     data space a process can use.  We ought to be reading MAXDSIZ and
     setting auto_solib_add to some large fraction of that value.  If
     not that, we maybe ought to be setting it smaller than the default
     for MAXDSIZ (that being 64Mb, I believe).  However, [1] this threshold
     is only crudely approximated rather than actually measured, and [2]
     50 Mbytes is too small for debugging gdb itself.  Thus, the arbitrary
     100 figure.
   */
  auto_solib_add = 100;		/* Megabytes */
d1169 1
d1171 1
a1171 1
	> (auto_solib_add * (LONGEST)1000000));
@


1.10
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 1
a2 1
   Copyright 1999, 2001 Free Software Foundation, Inc.
@


1.9
log
@Replace free() with xfree().
@
text
@d2 1
a2 1
   Copyright 1999 Free Software Foundation, Inc.
d52 1
@


1.8
log
@
        * pa64solib.c (add_to_solib): Pass TARGET to pa64_solib_load_symbols.
@
text
@d171 1
a171 1
      make_cleanup (free, filename);
d179 1
a179 1
      make_cleanup (free, filename);
d195 1
a195 1
  free (filename);
d576 1
a576 1
      free (so_list_head);
d863 1
a863 1
      free (sl);
d1216 1
a1216 1
      back_to = make_cleanup (free, (PTR) symbol_table);
@


1.7
log
@2000-08-27  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* pa64solib.c (pa64_solib_load_symbols): Don't use ANOFFSET as an
 	lvalue.
	* xcoffread.c (xcoff_symfile_offsets): Ditto
	* somsolib.c (som_solib_section_offsets): Ditto.
	* somread.c (som_symfile_offsets): Ditto.
	* rs6000-nat.c (vmap_symtab): Ditto.
	* remote-vx.c (vx_add_symbols): Ditto.
	* remote-os9k.c (rombug_wait): Ditto.
@
text
@d1174 2
a1175 1
			   0);
@


1.6
log
@2000-08-09  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * blockframe.c (sigtramp_saved_pc): Use dynamic allocation,
        since TARGET_PTR_BIT is no longer a constant (MULTI_ARCH).
        * irix4-nat.c (get_longjmp_target): Ditto.
        * irix5-nat.c (get_longjmp_target): Ditto.
        * jv-valprint.c (java_value_print): Ditto.
        * m3-nat.c (get_cprocs):            Ditto.
        * m68k-tdep.c (get_longjmp_target): Ditto.
        * mips-nat.c  (get_longjmp_target): Ditto.
        * mipsv4-nat.c(get_longjmp_target): Ditto.
        * pa64solib.c (read_dynamic_info):  Ditto.
        * solib.c (elf_locate_base):        Ditto.
@
text
@d322 1
a322 1
  ANOFFSET (so->objfile->section_offsets, SECT_OFF_TEXT (so->objfile))
d324 1
a324 1
  ANOFFSET (so->objfile->section_offsets, SECT_OFF_DATA (so->objfile))
@


1.5
log
@Protoization.
@
text
@d1022 1
a1022 1
      char pbuf[TARGET_PTR_BIT / HOST_CHAR_BIT];
d1024 1
@


1.4
log
@PARAMS removal.
@
text
@d148 1
a148 2
pa64_solib_sizeof_symbol_table (filename)
     char *filename;
d218 2
a219 5
pa64_solib_add_solib_objfile (so, name, from_tty, text_addr)
     struct so_list *so;
     char *name;
     int from_tty;
     CORE_ADDR text_addr;
d297 2
a298 6
pa64_solib_load_symbols (so, name, from_tty, text_addr, target)
     struct so_list *so;
     char *name;
     int from_tty;
     CORE_ADDR text_addr;
     struct target_ops *target;
d374 1
a374 4
pa64_solib_add (arg_string, from_tty, target)
     char *arg_string;
     int from_tty;
     struct target_ops *target;
d463 1
a463 1
pa64_solib_create_inferior_hook ()
d593 1
a593 2
pa64_solib_remove_inferior_hook (pid)
     int pid;
d614 2
a615 5
pa64_solib_create_catch_load_hook (pid, tempflag, filename, cond_string)
     int pid;
     int tempflag;
     char *filename;
     char *cond_string;
d632 2
a633 5
pa64_solib_create_catch_unload_hook (pid, tempflag, filename, cond_string)
     int pid;
     int tempflag;
     char *filename;
     char *cond_string;
d642 1
a642 2
pa64_solib_have_load_event (pid)
     int pid;
d653 1
a653 2
pa64_solib_have_unload_event (pid)
     int pid;
d668 1
a668 2
pa64_solib_loaded_library_pathname (pid)
     int pid;
d683 1
a683 2
pa64_solib_unloaded_library_pathname (pid)
     int pid;
d694 1
a694 3
pa64_solib_in_dynamic_linker (pid, pc)
     int pid;
     CORE_ADDR pc;
d714 1
a714 2
pa64_solib_get_got_by_pc (addr)
     CORE_ADDR addr;
d740 1
a740 2
pa64_solib_get_solib_by_pc (addr)
     CORE_ADDR addr;
d763 1
a763 3
pa64_sharedlibrary_info_command (ignore, from_tty)
     char *ignore;
     int from_tty;
d817 1
a817 3
pa64_solib_sharedlibrary_command (args, from_tty)
     char *args;
     int from_tty;
d827 1
a827 2
pa64_solib_address (addr)
     CORE_ADDR addr;
d851 1
a851 1
pa64_solib_restart ()
d882 1
a882 1
_initialize_pa64_solib ()
d916 1
a916 2
so_lib_thread_start_addr (so)
     struct so_list *so;
d929 1
a929 2
read_dld_descriptor (target)
     struct target_ops *target;
d998 1
a998 3
read_dynamic_info (dyninfo_sect, dld_cache_p)
     asection *dyninfo_sect;
     dld_cache_t *dld_cache_p;
d1079 1
a1079 5
pa64_target_read_memory (buffer, ptr, bufsiz, ident)
     void *buffer;
     CORE_ADDR ptr;
     size_t bufsiz;
     int ident;
d1094 3
a1096 7
add_to_solist (from_tty, dll_path, load_module_desc_p,
	       load_module_desc_addr, target)
     boolean from_tty; 
     char *dll_path; 
     struct load_module_desc *load_module_desc_p;
     CORE_ADDR load_module_desc_addr;
     struct target_ops *target;
d1199 1
a1199 3
bfd_lookup_symbol (abfd, symname)
     bfd *abfd;
     char *symname;
@


1.3
log
@Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * objfiles.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Define as functions of OBJFILE.  Add
        sect_index_text, sect_index_data, sect_index_rodata,
        sect_index_bss to objfile structure.
        * gdb-stabs.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Remove.
        * objfiles.c (allocate_objfile): Initialize
        sect_index_{text,data,bss,rodata} to -1, for error detection.

        * symfile.c (default_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata} from bfd information.
        * xcoffread.c (xcoff_symfile_offsets): Ditto.
        * somread.c (som_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata}.

        * coffread.c, dbxread.c, elfread.c, hp-psymtab-read.c,
        hp-symtab-read.c, hpread.c, mdebugread.c, minsyms.c,
        mipsread.c, objfiles.c, os9kread.c, pa64solib.c, partial-stab.h,
        remote-os9k.c, remote-vx.c, remote.c, rs6000-nat.c, somsolib.c,
        stabsread.c, symfile.c, xcoffread.c:
        Update use of SECT_OFF_{TEXT,DATA,BSS,RODATA} to depend on the
        current objfile.

        * xcoffread.c: Add new field objfile to find_targ_sec_arg.
@
text
@d62 1
a62 2
static CORE_ADDR
  bfd_lookup_symbol PARAMS ((bfd *, char *));
d64 1
a64 1
extern struct unwind_table_entry *find_unwind_entry PARAMS ((CORE_ADDR pc));
d123 1
a123 1
static void pa64_sharedlibrary_info_command PARAMS ((char *, int));
d125 1
a125 1
static void pa64_solib_sharedlibrary_command PARAMS ((char *, int));
d127 1
a127 1
static void * pa64_target_read_memory PARAMS ((void *, CORE_ADDR, size_t, int));
d129 1
a129 1
static boolean read_dld_descriptor PARAMS ((struct target_ops *));
d131 1
a131 1
static boolean read_dynamic_info PARAMS ((asection *, dld_cache_t *));
d133 2
a134 2
static void add_to_solist PARAMS ((boolean, char *, struct load_module_desc *,
				   CORE_ADDR, struct target_ops *));
@


1.2
log
@2000-04-27  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* cxux-nat.c (add_shared_symbol_files): Don't treat .text section
 	as special in the section_addr_info structure.
	* pa64solib.c (pa64_solib_add_solib_objfile): Ditto.
	* osfsolib.c (symbol_add_stub): Ditto.
	* irix5-nat.c (symbol_add_stub): Ditto.
@
text
@d331 1
a331 1
  ANOFFSET (so->objfile->section_offsets, SECT_OFF_TEXT)
d333 1
a333 1
  ANOFFSET (so->objfile->section_offsets, SECT_OFF_DATA)
d341 2
a342 2
	  p->addr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_TEXT);
	  p->endaddr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_TEXT);
d346 2
a347 2
	  p->addr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_DATA);
	  p->endaddr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_DATA);
@


1.1
log
@Initial revision
@
text
@d229 1
d231 1
d275 3
a277 1
  so->objfile = symbol_file_add (name, from_tty, text_addr, 0, 0, 0, 0, 1);
d364 2
a365 12
      int old, new;
      int update_coreops;
      int update_execops;

      /* We must update the to_sections field in the core_ops structure
	 here, otherwise we dereference a potential dangling pointer
	 for each call to target_read/write_memory within this routine.  */
      update_coreops = core_ops.to_sections == target->to_sections;

      /* Ditto exec_ops (this was a bug).  */
      update_execops = exec_ops.to_sections == target->to_sections;

a366 29
      /* Add sections from the shared library to the core target.  */
      if (target->to_sections)
	{
	  old = target->to_sections_end - target->to_sections;
	  target->to_sections = (struct section_table *)
	    xrealloc ((char *) target->to_sections,
		      ((sizeof (struct section_table)) * (old + new)));
	}
      else
	{
	  old = 0;
	  target->to_sections = (struct section_table *)
	    xmalloc ((sizeof (struct section_table)) * new);
	}
      target->to_sections_end = (target->to_sections + old + new);

      /* Update the to_sections field in the core_ops structure
	 if needed, ditto exec_ops.  */
      if (update_coreops)
	{
	  core_ops.to_sections = target->to_sections;
	  core_ops.to_sections_end = target->to_sections_end;
	}

      if (update_execops)
	{
	  exec_ops.to_sections = target->to_sections;
	  exec_ops.to_sections_end = target->to_sections_end;
	}
d368 2
a499 23
  /* Slam the pid of the process into __d_pid; failing is only a warning!  */
  msymbol = lookup_minimal_symbol ("__d_pid", NULL, symfile_objfile);
  if (msymbol == NULL)
    {
      warning ("Unable to find __d_pid symbol in object file.");
      warning ("Suggest linking with /opt/langtools/lib/end.o.");
      warning ("GDB will be unable to track explicit library load/unload calls");
      goto keep_going;
    }

  anaddr = SYMBOL_VALUE_ADDRESS (msymbol);
  store_unsigned_integer (buf, 4, inferior_pid);
  status = target_write_memory (anaddr, buf, 4);
  if (status != 0)
    {
      warning ("Unable to write __d_pid");
      warning ("Suggest linking with /opt/langtools/lib/end.o.");
      warning ("GDB will be unable to track explicit library load/unload calls");
      goto keep_going;
    }

keep_going:

a505 3
  /* ?!? Right now GDB is not recognizing hitting the callback breakpoint
     as a shared library event.  Fix that and remove the #if0 code.  */
#if 0
a506 1
#endif
d564 11
a574 1
      create_solib_event_breakpoint (sym_addr);
d798 1
a798 1
      printf_unfiltered ("no exec file.\n");
d809 3
a811 3
  printf_unfiltered ("    %-19s%-19s%-19s%-19s\n",
		     "    tstart", "     tend",
		     "    dstart", "     dend");
d829 1
a829 1
	local_hex_string_custom ((so_list->pa64_solib_desc.text_base,
d836 1
a836 1
	local_hex_string_custom ((so_list->pa64_solib_desc.data_base,
@


1.1.1.1
log
@import gdb-1999-08-23 snapshot
@
text
@@


1.1.1.2
log
@import gdb-1999-09-21
@
text
@d533 23
d562 3
d566 1
d624 1
a624 11
      {
	struct breakpoint *b
	  = create_solib_event_breakpoint (sym_addr);

	/* The breakpoint is actually hard-coded into the dynamic linker,
	   so we don't need to actually insert a breakpoint instruction
	   there.  In fact, the dynamic linker's code is immutable, even to
	   ttrace, so we shouldn't even try to do that.  For cases like
	   this, we have "permanent" breakpoints.  */
	make_breakpoint_permanent (b);
      }
d859 3
a861 3
  printf_unfiltered ("   %-19s%-19s%-19s%-19s\n",
		     "  text start", "   text end",
		     "  data start", "   data end");
d879 1
a879 1
	local_hex_string_custom ((so_list->pa64_solib_desc.text_base
d886 1
a886 1
	local_hex_string_custom ((so_list->pa64_solib_desc.data_base
@


1.1.1.3
log
@import gdb-1999-09-28 snapshot
@
text
@d360 12
a371 2
      int new, old;
      
d373 29
a402 2
      old = target_resize_to_sections (target, new);
      
@


1.1.1.4
log
@import gdb-1999-10-04 snapshot
@
text
@a228 1
  struct section_addr_info section_addrs;
a229 1
  memset (&section_addrs, 0, sizeof (section_addrs));
d273 1
a273 2
  section_addrs.text_addr = text_addr;
  so->objfile = symbol_file_add (name, from_tty, &section_addrs, 0, 0, 0, 1);
@


1.1.1.5
log
@import gdb-1999-10-11 snapshot
@
text
@d276 1
a276 1
  so->objfile = symbol_file_add (name, from_tty, &section_addrs, 0, OBJF_SHARED);
@


1.1.1.6
log
@import gdb-1999-11-16 snapshot
@
text
@d797 1
a797 1
      printf_unfiltered ("No executable file.\n");
@


