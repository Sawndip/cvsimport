head	1.47;
access;
symbols
	gdb_6_3-20041109-release:1.46
	gdb_6_3-branch:1.46.0.2
	gdb_6_3-20041019-branchpoint:1.46
	drow_intercu-merge-20040921:1.45
	drow_intercu-merge-20040915:1.45
	jimb-gdb_6_2-e500-branch:1.42.4.1.0.2
	jimb-gdb_6_2-e500-branchpoint:1.42
	gdb_6_2-20040730-release:1.42
	gdb_6_2-branch:1.42.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.42
	gdb_6_1_1-20040616-release:1.37
	gdb_6_1-2004-04-05-release:1.37
	drow_intercu-merge-20040402:1.38
	drow_intercu-merge-20040327:1.37
	ezannoni_pie-20040323-branch:1.37.0.6
	ezannoni_pie-20040323-branchpoint:1.37
	cagney_tramp-20040321-mergepoint:1.37
	cagney_tramp-20040309-branch:1.37.0.4
	cagney_tramp-20040309-branchpoint:1.37
	gdb_6_1-branch:1.37.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.37
	drow_intercu-20040221-branch:1.36.0.6
	drow_intercu-20040221-branchpoint:1.36
	cagney_bfdfile-20040213-branch:1.36.0.4
	cagney_bfdfile-20040213-branchpoint:1.36
	drow-cplus-merge-20040208:1.36
	carlton_dictionary-20040126-merge:1.36
	cagney_bigcore-20040122-branch:1.36.0.2
	cagney_bigcore-20040122-branchpoint:1.36
	drow-cplus-merge-20040113:1.36
	drow-cplus-merge-20031224:1.36
	drow-cplus-merge-20031220:1.36
	carlton_dictionary-20031215-merge:1.36
	drow-cplus-merge-20031214:1.36
	carlton-dictionary-20031111-merge:1.34
	gdb_6_0-2003-10-04-release:1.33
	kettenis_sparc-20030918-branch:1.34.0.4
	kettenis_sparc-20030918-branchpoint:1.34
	carlton_dictionary-20030917-merge:1.34
	ezannoni_pie-20030916-branchpoint:1.34
	ezannoni_pie-20030916-branch:1.34.0.2
	cagney_x86i386-20030821-branch:1.33.0.8
	cagney_x86i386-20030821-branchpoint:1.33
	carlton_dictionary-20030805-merge:1.33
	carlton_dictionary-20030627-merge:1.33
	gdb_6_0-branch:1.33.0.6
	gdb_6_0-2003-06-23-branchpoint:1.33
	jimb-ppc64-linux-20030613-branch:1.33.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.33
	cagney_convert-20030606-branch:1.33.0.2
	cagney_convert-20030606-branchpoint:1.33
	cagney_writestrings-20030508-branch:1.31.0.8
	cagney_writestrings-20030508-branchpoint:1.31
	jimb-ppc64-linux-20030528-branch:1.31.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.31
	carlton_dictionary-20030523-merge:1.31
	cagney_fileio-20030521-branch:1.31.0.4
	cagney_fileio-20030521-branchpoint:1.31
	kettenis_i386newframe-20030517-mergepoint:1.31
	jimb-ppc64-linux-20030509-branch:1.31.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.31
	kettenis_i386newframe-20030504-mergepoint:1.30
	carlton_dictionary-20030430-merge:1.30
	kettenis_i386newframe-20030419-branch:1.30.0.2
	kettenis_i386newframe-20030419-branchpoint:1.30
	carlton_dictionary-20030416-merge:1.29
	cagney_frameaddr-20030409-mergepoint:1.29
	kettenis_i386newframe-20030406-branch:1.29.0.16
	kettenis_i386newframe-20030406-branchpoint:1.29
	cagney_frameaddr-20030403-branchpoint:1.29
	cagney_frameaddr-20030403-branch:1.29.0.14
	cagney_framebase-20030330-mergepoint:1.29
	cagney_framebase-20030326-branch:1.29.0.12
	cagney_framebase-20030326-branchpoint:1.29
	cagney_lazyid-20030317-branch:1.29.0.10
	cagney_lazyid-20030317-branchpoint:1.29
	kettenis-i386newframe-20030316-mergepoint:1.29
	offbyone-20030313-branch:1.29.0.8
	offbyone-20030313-branchpoint:1.29
	kettenis-i386newframe-20030308-branch:1.29.0.6
	kettenis-i386newframe-20030308-branchpoint:1.29
	carlton_dictionary-20030305-merge:1.29
	cagney_offbyone-20030303-branch:1.29.0.4
	cagney_offbyone-20030303-branchpoint:1.29
	carlton_dictionary-20030207-merge:1.29
	interps-20030203-mergepoint:1.29
	interps-20030202-branch:1.29.0.2
	interps-20030202-branchpoint:1.29
	cagney-unwind-20030108-branch:1.26.0.2
	cagney-unwind-20030108-branchpoint:1.26
	carlton_dictionary-20021223-merge:1.26
	gdb_5_3-2002-12-12-release:1.22
	carlton_dictionary-20021115-merge:1.24
	kseitz_interps-20021105-merge:1.23
	kseitz_interps-20021103-merge:1.23
	drow-cplus-merge-20021020:1.22
	drow-cplus-merge-20021025:1.22
	carlton_dictionary-20021025-merge:1.22
	carlton_dictionary-20021011-merge:1.22
	drow-cplus-branch:1.22.0.16
	drow-cplus-branchpoint:1.22
	kseitz_interps-20020930-merge:1.22
	carlton_dictionary-20020927-merge:1.22
	carlton_dictionary-branch:1.22.0.14
	carlton_dictionary-20020920-branchpoint:1.22
	gdb_5_3-branch:1.22.0.12
	gdb_5_3-2002-09-04-branchpoint:1.22
	kseitz_interps-20020829-merge:1.22
	cagney_sysregs-20020825-branch:1.22.0.10
	cagney_sysregs-20020825-branchpoint:1.22
	readline_4_3-import-branch:1.22.0.8
	readline_4_3-import-branchpoint:1.22
	gdb_5_2_1-2002-07-23-release:1.21
	kseitz_interps-20020528-branch:1.22.0.6
	kseitz_interps-20020528-branchpoint:1.22
	cagney_regbuf-20020515-branch:1.22.0.4
	cagney_regbuf-20020515-branchpoint:1.22
	jimb-macro-020506-branch:1.22.0.2
	jimb-macro-020506-branchpoint:1.22
	gdb_5_2-2002-04-29-release:1.21
	gdb_5_2-branch:1.21.0.2
	gdb_5_2-2002-03-03-branchpoint:1.21
	gdb_5_1_1-2002-01-24-release:1.17
	gdb_5_1_0_1-2002-01-03-release:1.17
	cygnus_cvs_20020108_pre:1.19
	gdb_5_1_0_1-2002-01-03-branchpoint:1.17
	gdb_5_1_0_1-2002-01-03-branch:1.17.0.6
	gdb_5_1-2001-11-21-release:1.17
	gdb_s390-2001-09-26-branch:1.17.0.4
	gdb_s390-2001-09-26-branchpoint:1.17
	gdb_5_1-2001-07-29-branch:1.17.0.2
	gdb_5_1-2001-07-29-branchpoint:1.17
	dberlin-typesystem-branch:1.16.0.2
	dberlin-typesystem-branchpoint:1.16
	gdb-post-ptid_t-2001-05-03:1.10
	gdb-pre-ptid_t-2001-05-03:1.9
	insight-precleanup-2001-01-01:1.2;
locks; strict;
comment	@ * @;


1.47
date	2004.11.14.18.47.50;	author drow;	state dead;
branches;
next	1.46;

1.46
date	2004.10.08.20.29.56;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2004.09.14.14.46.13;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2004.09.08.19.44.22;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2004.07.22.01.31.49;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.07.22.35.55;	author jjohnstn;	state Exp;
branches
	1.42.4.1;
next	1.41;

1.41
date	2004.06.04.21.28.15;	author jjohnstn;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.25.14.58.31;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.21.23.52.21;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.29.18.07.14;	author drow;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.29.02.39.47;	author drow;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.04.00.20.25;	author roland;	state Exp;
branches
	1.36.6.1
	1.36.8.1;
next	1.35;

1.35
date	2003.11.25.23.31.40;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2003.09.04.21.03.37;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.05.18.22.02;	author jjohnstn;	state Exp;
branches
	1.33.8.1;
next	1.32;

1.32
date	2003.06.03.20.00.56;	author jjohnstn;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.08.22.33.14;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2003.04.17.17.30.02;	author jjohnstn;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2003.02.02.05.46.14;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.14.00.49.04;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.13.21.48.32;	author drow;	state Exp;
branches;
next	1.26;

1.26
date	2002.12.13.23.28.28;	author msnyder;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.23.01.34.43;	author msnyder;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.12.02.39.40;	author ezannoni;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.23.17.38.13;	author cagney;	state Exp;
branches
	1.22.6.1
	1.22.14.1
	1.22.16.1;
next	1.21;

1.21
date	2002.02.24.21.53.02;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.08.01.34.12;	author msnyder;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.05.01.46.30;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.13.15.04.02;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.11.09.14.51;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.03.21.04.49;	author msnyder;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.07.03.21.01.59;	author msnyder;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.23.00.06.15;	author msnyder;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.15.00.03.36;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.06.22.22.03;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.06.17.00.44;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.04.04.15.28;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.30.18.21.17;	author msnyder;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.26.23.14.20;	author msnyder;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.17.19.14.54;	author msnyder;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.30.19.36.35;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.24.00.26.46;	author jtc;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.27.21.37.57;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.15.01.01.50;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.03.18.41.28;	author kettenis;	state Exp;
branches;
next	;

1.16.2.1
date	2001.07.06.19.17.03;	author dberlin;	state Exp;
branches;
next	;

1.22.6.1
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.22.14.1
date	2002.11.15.19.19.00;	author carlton;	state Exp;
branches;
next	1.22.14.2;

1.22.14.2
date	2002.12.23.19.38.46;	author carlton;	state Exp;
branches;
next	1.22.14.3;

1.22.14.3
date	2003.02.07.19.17.53;	author carlton;	state Exp;
branches;
next	1.22.14.4;

1.22.14.4
date	2003.05.01.00.46.52;	author carlton;	state Exp;
branches;
next	1.22.14.5;

1.22.14.5
date	2003.05.23.18.40.46;	author carlton;	state Exp;
branches;
next	1.22.14.6;

1.22.14.6
date	2003.06.27.21.50.12;	author carlton;	state Exp;
branches;
next	1.22.14.7;

1.22.14.7
date	2003.09.17.21.28.33;	author carlton;	state Exp;
branches;
next	1.22.14.8;

1.22.14.8
date	2003.12.16.00.00.51;	author carlton;	state Exp;
branches;
next	;

1.22.16.1
date	2003.12.14.20.27.33;	author drow;	state Exp;
branches;
next	;

1.30.2.1
date	2003.05.18.09.44.25;	author kettenis;	state Exp;
branches;
next	;

1.33.8.1
date	2003.08.21.23.40.51;	author cagney;	state Exp;
branches;
next	;

1.36.6.1
date	2004.03.27.17.37.54;	author drow;	state Exp;
branches;
next	1.36.6.2;

1.36.6.2
date	2004.04.02.16.47.49;	author drow;	state Exp;
branches;
next	1.36.6.3;

1.36.6.3
date	2004.09.16.17.01.24;	author drow;	state Exp;
branches;
next	;

1.36.8.1
date	2004.02.29.02.41.29;	author drow;	state Exp;
branches;
next	;

1.42.4.1
date	2004.09.01.18.09.58;	author jimb;	state Exp;
branches;
next	;


desc
@@


1.47
log
@	* linux-thread-db.c: New file, renamed from thread-db.c.
	* thread-db.c: Remove.
	* Makefile.in (linux-thread-db.o): Rename from thread-db.o rule.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Rename thread-db.o
	to linux-thread-db.o.
	* config/arm/linux.mh (NATDEPFILES): Likewise.
	* config/i386/linux.mh (NATDEPFILES): Likewise.
	* config/i386/linux64.mh (NATDEPFILES): Likewise.
	* config/ia64/linux.mh (NATDEPFILES): Likewise.
	* config/m32r/linux.mh (NATDEPFILES): Likewise.
	* config/m68k/linux.mh (NATDEPFILES): Likewise.
	* config/mips/linux.mh (NATDEPFILES): Likewise.
	* config/pa/linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Likewise.
	* config/s390/s390.mh (NATDEPFILES): Likewise.
	* config/sparc/linux.mh (NATDEPFILES): Likewise.
	* config/sparc/linux64.mh (NATDEPFILES): Likewise.
@
text
@/* libthread_db assisted debugging support, generic parts.

   Copyright 1999, 2000, 2001, 2003, 2004 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"

#include "gdb_assert.h"
#include <dlfcn.h>
#include "gdb_proc_service.h"
#include "gdb_thread_db.h"

#include "bfd.h"
#include "gdbthread.h"
#include "inferior.h"
#include "symfile.h"
#include "objfiles.h"
#include "target.h"
#include "regcache.h"
#include "solib-svr4.h"

#ifdef HAVE_GNU_LIBC_VERSION_H
#include <gnu/libc-version.h>
#endif

#ifndef LIBTHREAD_DB_SO
#define LIBTHREAD_DB_SO "libthread_db.so.1"
#endif

/* If we're running on GNU/Linux, we must explicitly attach to any new
   threads.  */

/* FIXME: There is certainly some room for improvements:
   - Cache LWP ids.
   - Bypass libthread_db when fetching or storing registers for
   threads bound to a LWP.  */

/* This module's target vector.  */
static struct target_ops thread_db_ops;

/* The target vector that we call for things this module can't handle.  */
static struct target_ops *target_beneath;

/* Pointer to the next function on the objfile event chain.  */
static void (*target_new_objfile_chain) (struct objfile * objfile);

/* Non-zero if we're using this module's target vector.  */
static int using_thread_db;

/* Non-zero if we have determined the signals used by the threads
   library.  */
static int thread_signals;
static sigset_t thread_stop_set;
static sigset_t thread_print_set;

/* Structure that identifies the child process for the
   <proc_service.h> interface.  */
static struct ps_prochandle proc_handle;

/* Connection to the libthread_db library.  */
static td_thragent_t *thread_agent;

/* Pointers to the libthread_db functions.  */

static td_err_e (*td_init_p) (void);

static td_err_e (*td_ta_new_p) (struct ps_prochandle * ps,
				td_thragent_t **ta);
static td_err_e (*td_ta_map_id2thr_p) (const td_thragent_t *ta, thread_t pt,
				       td_thrhandle_t *__th);
static td_err_e (*td_ta_map_lwp2thr_p) (const td_thragent_t *ta,
					lwpid_t lwpid, td_thrhandle_t *th);
static td_err_e (*td_ta_thr_iter_p) (const td_thragent_t *ta,
				     td_thr_iter_f *callback, void *cbdata_p,
				     td_thr_state_e state, int ti_pri,
				     sigset_t *ti_sigmask_p,
				     unsigned int ti_user_flags);
static td_err_e (*td_ta_event_addr_p) (const td_thragent_t *ta,
				       td_event_e event, td_notify_t *ptr);
static td_err_e (*td_ta_set_event_p) (const td_thragent_t *ta,
				      td_thr_events_t *event);
static td_err_e (*td_ta_event_getmsg_p) (const td_thragent_t *ta,
					 td_event_msg_t *msg);

static td_err_e (*td_thr_validate_p) (const td_thrhandle_t *th);
static td_err_e (*td_thr_get_info_p) (const td_thrhandle_t *th,
				      td_thrinfo_t *infop);
static td_err_e (*td_thr_getfpregs_p) (const td_thrhandle_t *th,
				       gdb_prfpregset_t *regset);
static td_err_e (*td_thr_getgregs_p) (const td_thrhandle_t *th,
				      prgregset_t gregs);
static td_err_e (*td_thr_setfpregs_p) (const td_thrhandle_t *th,
				       const gdb_prfpregset_t *fpregs);
static td_err_e (*td_thr_setgregs_p) (const td_thrhandle_t *th,
				      prgregset_t gregs);
static td_err_e (*td_thr_event_enable_p) (const td_thrhandle_t *th,
					  int event);

static td_err_e (*td_thr_tls_get_addr_p) (const td_thrhandle_t *th,
					  void *map_address,
					  size_t offset, void **address);

/* Location of the thread creation event breakpoint.  The code at this
   location in the child process will be called by the pthread library
   whenever a new thread is created.  By setting a special breakpoint
   at this location, GDB can detect when a new thread is created.  We
   obtain this location via the td_ta_event_addr call.  */
static CORE_ADDR td_create_bp_addr;

/* Location of the thread death event breakpoint.  */
static CORE_ADDR td_death_bp_addr;

/* Prototypes for local functions.  */
static void thread_db_find_new_threads (void);
static void attach_thread (ptid_t ptid, const td_thrhandle_t *th_p,
			   const td_thrinfo_t *ti_p, int verbose);
static void detach_thread (ptid_t ptid, int verbose);


/* Building process ids.  */

#define GET_PID(ptid)		ptid_get_pid (ptid)
#define GET_LWP(ptid)		ptid_get_lwp (ptid)
#define GET_THREAD(ptid)	ptid_get_tid (ptid)

#define is_lwp(ptid)		(GET_LWP (ptid) != 0)
#define is_thread(ptid)		(GET_THREAD (ptid) != 0)

#define BUILD_LWP(lwp, pid)	ptid_build (pid, lwp, 0)
#define BUILD_THREAD(tid, pid)	ptid_build (pid, 0, tid)


/* Use "struct private_thread_info" to cache thread state.  This is
   a substantial optimization.  */

struct private_thread_info
{
  /* Flag set when we see a TD_DEATH event for this thread.  */
  unsigned int dying:1;

  /* Cached thread state.  */
  unsigned int th_valid:1;
  unsigned int ti_valid:1;

  td_thrhandle_t th;
  td_thrinfo_t ti;
};


static char *
thread_db_err_str (td_err_e err)
{
  static char buf[64];

  switch (err)
    {
    case TD_OK:
      return "generic 'call succeeded'";
    case TD_ERR:
      return "generic error";
    case TD_NOTHR:
      return "no thread to satisfy query";
    case TD_NOSV:
      return "no sync handle to satisfy query";
    case TD_NOLWP:
      return "no LWP to satisfy query";
    case TD_BADPH:
      return "invalid process handle";
    case TD_BADTH:
      return "invalid thread handle";
    case TD_BADSH:
      return "invalid synchronization handle";
    case TD_BADTA:
      return "invalid thread agent";
    case TD_BADKEY:
      return "invalid key";
    case TD_NOMSG:
      return "no event message for getmsg";
    case TD_NOFPREGS:
      return "FPU register set not available";
    case TD_NOLIBTHREAD:
      return "application not linked with libthread";
    case TD_NOEVENT:
      return "requested event is not supported";
    case TD_NOCAPAB:
      return "capability not available";
    case TD_DBERR:
      return "debugger service failed";
    case TD_NOAPLIC:
      return "operation not applicable to";
    case TD_NOTSD:
      return "no thread-specific data for this thread";
    case TD_MALLOC:
      return "malloc failed";
    case TD_PARTIALREG:
      return "only part of register set was written/read";
    case TD_NOXREGS:
      return "X register set not available for this thread";
    default:
      snprintf (buf, sizeof (buf), "unknown thread_db error '%d'", err);
      return buf;
    }
}

static char *
thread_db_state_str (td_thr_state_e state)
{
  static char buf[64];

  switch (state)
    {
    case TD_THR_STOPPED:
      return "stopped by debugger";
    case TD_THR_RUN:
      return "runnable";
    case TD_THR_ACTIVE:
      return "active";
    case TD_THR_ZOMBIE:
      return "zombie";
    case TD_THR_SLEEP:
      return "sleeping";
    case TD_THR_STOPPED_ASLEEP:
      return "stopped by debugger AND blocked";
    default:
      snprintf (buf, sizeof (buf), "unknown thread_db state %d", state);
      return buf;
    }
}

/* A callback function for td_ta_thr_iter, which we use to map all
   threads to LWPs.

   THP is a handle to the current thread; if INFOP is not NULL, the
   struct thread_info associated with this thread is returned in
   *INFOP.

   If the thread is a zombie, TD_THR_ZOMBIE is returned.  Otherwise,
   zero is returned to indicate success.  */

static int
thread_get_info_callback (const td_thrhandle_t *thp, void *infop)
{
  td_thrinfo_t ti;
  td_err_e err;
  struct thread_info *thread_info;
  ptid_t thread_ptid;

  err = td_thr_get_info_p (thp, &ti);
  if (err != TD_OK)
    error ("thread_get_info_callback: cannot get thread info: %s",
	   thread_db_err_str (err));

  /* Fill the cache.  */
  thread_ptid = BUILD_THREAD (ti.ti_tid, GET_PID (inferior_ptid));
  thread_info = find_thread_pid (thread_ptid);

  /* In the case of a zombie thread, don't continue.  We don't want to
     attach to it thinking it is a new thread.  */
  if (ti.ti_state == TD_THR_UNKNOWN || ti.ti_state == TD_THR_ZOMBIE)
    {
      if (infop != NULL)
        *(struct thread_info **) infop = thread_info;
      if (thread_info != NULL)
	{
	  memcpy (&thread_info->private->th, thp, sizeof (*thp));
	  thread_info->private->th_valid = 1;
	  memcpy (&thread_info->private->ti, &ti, sizeof (ti));
	  thread_info->private->ti_valid = 1;
	}
      return TD_THR_ZOMBIE;
    }

  if (thread_info == NULL)
    {
      /* New thread.  Attach to it now (why wait?).  */
      attach_thread (thread_ptid, thp, &ti, 1);
      thread_info = find_thread_pid (thread_ptid);
      gdb_assert (thread_info != NULL);
    }

  memcpy (&thread_info->private->th, thp, sizeof (*thp));
  thread_info->private->th_valid = 1;
  memcpy (&thread_info->private->ti, &ti, sizeof (ti));
  thread_info->private->ti_valid = 1;

  if (infop != NULL)
    *(struct thread_info **) infop = thread_info;

  return 0;
}

/* Accessor functions for the thread_db information, with caching.  */

static void
thread_db_map_id2thr (struct thread_info *thread_info, int fatal)
{
  td_err_e err;

  if (thread_info->private->th_valid)
    return;

  err = td_ta_map_id2thr_p (thread_agent, GET_THREAD (thread_info->ptid),
			    &thread_info->private->th);
  if (err != TD_OK)
    {
      if (fatal)
	error ("Cannot find thread %ld: %s",
	       (long) GET_THREAD (thread_info->ptid),
	       thread_db_err_str (err));
    }
  else
    thread_info->private->th_valid = 1;
}

static td_thrinfo_t *
thread_db_get_info (struct thread_info *thread_info)
{
  td_err_e err;

  if (thread_info->private->ti_valid)
    return &thread_info->private->ti;

  if (!thread_info->private->th_valid)
    thread_db_map_id2thr (thread_info, 1);

  err =
    td_thr_get_info_p (&thread_info->private->th, &thread_info->private->ti);
  if (err != TD_OK)
    error ("thread_db_get_info: cannot get thread info: %s",
	   thread_db_err_str (err));

  thread_info->private->ti_valid = 1;
  return &thread_info->private->ti;
}

/* Convert between user-level thread ids and LWP ids.  */

static ptid_t
thread_from_lwp (ptid_t ptid)
{
  td_thrhandle_t th;
  td_err_e err;
  struct thread_info *thread_info;
  ptid_t thread_ptid;

  if (GET_LWP (ptid) == 0)
    ptid = BUILD_LWP (GET_PID (ptid), GET_PID (ptid));

  gdb_assert (is_lwp (ptid));

  err = td_ta_map_lwp2thr_p (thread_agent, GET_LWP (ptid), &th);
  if (err != TD_OK)
    error ("Cannot find user-level thread for LWP %ld: %s",
	   GET_LWP (ptid), thread_db_err_str (err));

  thread_info = NULL;

  /* Fetch the thread info.  If we get back TD_THR_ZOMBIE, then the
     event thread has already died.  If another gdb interface has called
     thread_alive() previously, the thread won't be found on the thread list
     anymore.  In that case, we don't want to process this ptid anymore
     to avoid the possibility of later treating it as a newly
     discovered thread id that we should add to the list.  Thus,
     we return a -1 ptid which is also how the thread list marks a
     dead thread.  */
  if (thread_get_info_callback (&th, &thread_info) == TD_THR_ZOMBIE
      && thread_info == NULL)
    return pid_to_ptid (-1);

  gdb_assert (thread_info && thread_info->private->ti_valid);

  return BUILD_THREAD (thread_info->private->ti.ti_tid, GET_PID (ptid));
}

static ptid_t
lwp_from_thread (ptid_t ptid)
{
  struct thread_info *thread_info;
  ptid_t thread_ptid;

  if (!is_thread (ptid))
    return ptid;

  thread_info = find_thread_pid (ptid);
  thread_db_get_info (thread_info);

  return BUILD_LWP (thread_info->private->ti.ti_lid, GET_PID (ptid));
}


void
thread_db_init (struct target_ops *target)
{
  target_beneath = target;
}

static void *
verbose_dlsym (void *handle, const char *name)
{
  void *sym = dlsym (handle, name);
  if (sym == NULL)
    warning ("Symbol \"%s\" not found in libthread_db: %s", name, dlerror ());
  return sym;
}

static int
thread_db_load (void)
{
  void *handle;
  td_err_e err;

  handle = dlopen (LIBTHREAD_DB_SO, RTLD_NOW);
  if (handle == NULL)
    {
      fprintf_filtered (gdb_stderr, "\n\ndlopen failed on '%s' - %s\n",
			LIBTHREAD_DB_SO, dlerror ());
      fprintf_filtered (gdb_stderr,
			"GDB will not be able to debug pthreads.\n\n");
      return 0;
    }

  /* Initialize pointers to the dynamic library functions we will use.
     Essential functions first.  */

  td_init_p = verbose_dlsym (handle, "td_init");
  if (td_init_p == NULL)
    return 0;

  td_ta_new_p = verbose_dlsym (handle, "td_ta_new");
  if (td_ta_new_p == NULL)
    return 0;

  td_ta_map_id2thr_p = verbose_dlsym (handle, "td_ta_map_id2thr");
  if (td_ta_map_id2thr_p == NULL)
    return 0;

  td_ta_map_lwp2thr_p = verbose_dlsym (handle, "td_ta_map_lwp2thr");
  if (td_ta_map_lwp2thr_p == NULL)
    return 0;

  td_ta_thr_iter_p = verbose_dlsym (handle, "td_ta_thr_iter");
  if (td_ta_thr_iter_p == NULL)
    return 0;

  td_thr_validate_p = verbose_dlsym (handle, "td_thr_validate");
  if (td_thr_validate_p == NULL)
    return 0;

  td_thr_get_info_p = verbose_dlsym (handle, "td_thr_get_info");
  if (td_thr_get_info_p == NULL)
    return 0;

  td_thr_getfpregs_p = verbose_dlsym (handle, "td_thr_getfpregs");
  if (td_thr_getfpregs_p == NULL)
    return 0;

  td_thr_getgregs_p = verbose_dlsym (handle, "td_thr_getgregs");
  if (td_thr_getgregs_p == NULL)
    return 0;

  td_thr_setfpregs_p = verbose_dlsym (handle, "td_thr_setfpregs");
  if (td_thr_setfpregs_p == NULL)
    return 0;

  td_thr_setgregs_p = verbose_dlsym (handle, "td_thr_setgregs");
  if (td_thr_setgregs_p == NULL)
    return 0;

  /* Initialize the library.  */
  err = td_init_p ();
  if (err != TD_OK)
    {
      warning ("Cannot initialize libthread_db: %s", thread_db_err_str (err));
      return 0;
    }

  /* These are not essential.  */
  td_ta_event_addr_p = dlsym (handle, "td_ta_event_addr");
  td_ta_set_event_p = dlsym (handle, "td_ta_set_event");
  td_ta_event_getmsg_p = dlsym (handle, "td_ta_event_getmsg");
  td_thr_event_enable_p = dlsym (handle, "td_thr_event_enable");
  td_thr_tls_get_addr_p = dlsym (handle, "td_thr_tls_get_addr");

  return 1;
}

static td_err_e
enable_thread_event (td_thragent_t *thread_agent, int event, CORE_ADDR *bp)
{
  td_notify_t notify;
  td_err_e err;

  /* Get the breakpoint address for thread EVENT.  */
  err = td_ta_event_addr_p (thread_agent, event, &notify);
  if (err != TD_OK)
    return err;

  /* Set up the breakpoint.  */
  (*bp) = gdbarch_convert_from_func_ptr_addr (current_gdbarch,
					      (CORE_ADDR) notify.u.bptaddr,
					      &current_target);
  create_thread_event_breakpoint ((*bp));

  return TD_OK;
}

static void
enable_thread_event_reporting (void)
{
  td_thr_events_t events;
  td_notify_t notify;
  td_err_e err;
#ifdef HAVE_GNU_LIBC_VERSION_H
  const char *libc_version;
  int libc_major, libc_minor;
#endif

  /* We cannot use the thread event reporting facility if these
     functions aren't available.  */
  if (td_ta_event_addr_p == NULL || td_ta_set_event_p == NULL
      || td_ta_event_getmsg_p == NULL || td_thr_event_enable_p == NULL)
    return;

  /* Set the process wide mask saying which events we're interested in.  */
  td_event_emptyset (&events);
  td_event_addset (&events, TD_CREATE);

#ifdef HAVE_GNU_LIBC_VERSION_H
  /* FIXME: kettenis/2000-04-23: The event reporting facility is
     broken for TD_DEATH events in glibc 2.1.3, so don't enable it for
     now.  */
  libc_version = gnu_get_libc_version ();
  if (sscanf (libc_version, "%d.%d", &libc_major, &libc_minor) == 2
      && (libc_major > 2 || (libc_major == 2 && libc_minor > 1)))
#endif
    td_event_addset (&events, TD_DEATH);

  err = td_ta_set_event_p (thread_agent, &events);
  if (err != TD_OK)
    {
      warning ("Unable to set global thread event mask: %s",
	       thread_db_err_str (err));
      return;
    }

  /* Delete previous thread event breakpoints, if any.  */
  remove_thread_event_breakpoints ();
  td_create_bp_addr = 0;
  td_death_bp_addr = 0;

  /* Set up the thread creation event.  */
  err = enable_thread_event (thread_agent, TD_CREATE, &td_create_bp_addr);
  if (err != TD_OK)
    {
      warning ("Unable to get location for thread creation breakpoint: %s",
	       thread_db_err_str (err));
      return;
    }

  /* Set up the thread death event.  */
  err = enable_thread_event (thread_agent, TD_DEATH, &td_death_bp_addr);
  if (err != TD_OK)
    {
      warning ("Unable to get location for thread death breakpoint: %s",
	       thread_db_err_str (err));
      return;
    }
}

static void
disable_thread_event_reporting (void)
{
  td_thr_events_t events;

  /* Set the process wide mask saying we aren't interested in any
     events anymore.  */
  td_event_emptyset (&events);
  td_ta_set_event_p (thread_agent, &events);

  /* Delete thread event breakpoints, if any.  */
  remove_thread_event_breakpoints ();
  td_create_bp_addr = 0;
  td_death_bp_addr = 0;
}

static void
check_thread_signals (void)
{
#ifdef GET_THREAD_SIGNALS
  if (!thread_signals)
    {
      sigset_t mask;
      int i;

      GET_THREAD_SIGNALS (&mask);
      sigemptyset (&thread_stop_set);
      sigemptyset (&thread_print_set);

      for (i = 1; i < NSIG; i++)
	{
	  if (sigismember (&mask, i))
	    {
	      if (signal_stop_update (target_signal_from_host (i), 0))
		sigaddset (&thread_stop_set, i);
	      if (signal_print_update (target_signal_from_host (i), 0))
		sigaddset (&thread_print_set, i);
	      thread_signals = 1;
	    }
	}
    }
#endif
}

static void
thread_db_new_objfile (struct objfile *objfile)
{
  td_err_e err;

  /* First time through, report that libthread_db was successfuly
     loaded.  Can't print this in in thread_db_load as, at that stage,
     the interpreter and it's console haven't started.  The real
     problem here is that libthread_db is loaded too early - it should
     only be loaded when there is a program to debug.  */
  {
    static int dejavu;
    if (!dejavu)
      {
	Dl_info info;
	const char *library = NULL;
	/* Try dladdr.  */
	if (dladdr ((*td_ta_new_p), &info) != 0)
	  library = info.dli_fname;
	/* Try dlinfo?  */
	if (library == NULL)
	  /* Paranoid - don't let a NULL path slip through.  */
	  library = LIBTHREAD_DB_SO;
	printf_unfiltered ("Using host libthread_db library \"%s\".\n",
			   library);
	dejavu = 1;
      }
  }

  /* Don't attempt to use thread_db on targets which can not run
     (core files).  */
  if (objfile == NULL || !target_has_execution)
    {
      /* All symbols have been discarded.  If the thread_db target is
         active, deactivate it now.  */
      if (using_thread_db)
	{
	  gdb_assert (proc_handle.pid == 0);
	  unpush_target (&thread_db_ops);
	  using_thread_db = 0;
	}

      goto quit;
    }

  if (using_thread_db)
    /* Nothing to do.  The thread library was already detected and the
       target vector was already activated.  */
    goto quit;

  /* Initialize the structure that identifies the child process.  Note
     that at this point there is no guarantee that we actually have a
     child process.  */
  proc_handle.pid = GET_PID (inferior_ptid);

  /* Now attempt to open a connection to the thread library.  */
  err = td_ta_new_p (&proc_handle, &thread_agent);
  switch (err)
    {
    case TD_NOLIBTHREAD:
      /* No thread library was detected.  */
      break;

    case TD_OK:
      printf_unfiltered ("[Thread debugging using libthread_db enabled]\n");

      /* The thread library was detected.  Activate the thread_db target.  */
      push_target (&thread_db_ops);
      using_thread_db = 1;

      enable_thread_event_reporting ();
      thread_db_find_new_threads ();
      break;

    default:
      warning ("Cannot initialize thread debugging library: %s",
	       thread_db_err_str (err));
      break;
    }

quit:
  if (target_new_objfile_chain)
    target_new_objfile_chain (objfile);
}

/* Attach to a new thread.  This function is called when we receive a
   TD_CREATE event or when we iterate over all threads and find one
   that wasn't already in our list.  */

static void
attach_thread (ptid_t ptid, const td_thrhandle_t *th_p,
	       const td_thrinfo_t *ti_p, int verbose)
{
  struct thread_info *tp;
  td_err_e err;

  /* If we're being called after a TD_CREATE event, we may already
     know about this thread.  There are two ways this can happen.  We
     may have iterated over all threads between the thread creation
     and the TD_CREATE event, for instance when the user has issued
     the `info threads' command before the SIGTRAP for hitting the
     thread creation breakpoint was reported.  Alternatively, the
     thread may have exited and a new one been created with the same
     thread ID.  In the first case we don't need to do anything; in
     the second case we should discard information about the dead
     thread and attach to the new one.  */
  if (in_thread_list (ptid))
    {
      tp = find_thread_pid (ptid);
      gdb_assert (tp != NULL);

      if (!tp->private->dying)
        return;

      delete_thread (ptid);
    }

  check_thread_signals ();

  /* Add the thread to GDB's thread list.  */
  tp = add_thread (ptid);
  tp->private = xmalloc (sizeof (struct private_thread_info));
  memset (tp->private, 0, sizeof (struct private_thread_info));

  if (verbose)
    printf_unfiltered ("[New %s]\n", target_pid_to_str (ptid));

  if (ti_p->ti_state == TD_THR_UNKNOWN || ti_p->ti_state == TD_THR_ZOMBIE)
    return;			/* A zombie thread -- do not attach.  */

  /* Under GNU/Linux, we have to attach to each and every thread.  */
#ifdef ATTACH_LWP
  ATTACH_LWP (BUILD_LWP (ti_p->ti_lid, GET_PID (ptid)), 0);
#endif

  /* Enable thread event reporting for this thread.  */
  err = td_thr_event_enable_p (th_p, 1);
  if (err != TD_OK)
    error ("Cannot enable thread event reporting for %s: %s",
	   target_pid_to_str (ptid), thread_db_err_str (err));
}

static void
thread_db_attach (char *args, int from_tty)
{
  target_beneath->to_attach (args, from_tty);

  /* Destroy thread info; it's no longer valid.  */
  init_thread_list ();

  /* The child process is now the actual multi-threaded
     program.  Snatch its process ID...  */
  proc_handle.pid = GET_PID (inferior_ptid);

  /* ...and perform the remaining initialization steps.  */
  enable_thread_event_reporting ();
  thread_db_find_new_threads ();
}

static void
detach_thread (ptid_t ptid, int verbose)
{
  struct thread_info *thread_info;

  if (verbose)
    printf_unfiltered ("[%s exited]\n", target_pid_to_str (ptid));

  /* Don't delete the thread now, because it still reports as active
     until it has executed a few instructions after the event
     breakpoint - if we deleted it now, "info threads" would cause us
     to re-attach to it.  Just mark it as having had a TD_DEATH
     event.  This means that we won't delete it from our thread list
     until we notice that it's dead (via prune_threads), or until
     something re-uses its thread ID.  */
  thread_info = find_thread_pid (ptid);
  gdb_assert (thread_info != NULL);
  thread_info->private->dying = 1;
}

static void
thread_db_detach (char *args, int from_tty)
{
  disable_thread_event_reporting ();

  /* There's no need to save & restore inferior_ptid here, since the
     inferior is supposed to be survive this function call.  */
  inferior_ptid = lwp_from_thread (inferior_ptid);

  /* Forget about the child's process ID.  We shouldn't need it
     anymore.  */
  proc_handle.pid = 0;

  target_beneath->to_detach (args, from_tty);
}

static int
clear_lwpid_callback (struct thread_info *thread, void *dummy)
{
  /* If we know that our thread implementation is 1-to-1, we could save
     a certain amount of information; it's not clear how much, so we
     are always conservative.  */

  thread->private->th_valid = 0;
  thread->private->ti_valid = 0;

  return 0;
}

static void
thread_db_resume (ptid_t ptid, int step, enum target_signal signo)
{
  struct cleanup *old_chain = save_inferior_ptid ();

  if (GET_PID (ptid) == -1)
    inferior_ptid = lwp_from_thread (inferior_ptid);
  else if (is_thread (ptid))
    ptid = lwp_from_thread (ptid);

  /* Clear cached data which may not be valid after the resume.  */
  iterate_over_threads (clear_lwpid_callback, NULL);

  target_beneath->to_resume (ptid, step, signo);

  do_cleanups (old_chain);
}

/* Check if PID is currently stopped at the location of a thread event
   breakpoint location.  If it is, read the event message and act upon
   the event.  */

static void
check_event (ptid_t ptid)
{
  td_event_msg_t msg;
  td_thrinfo_t ti;
  td_err_e err;
  CORE_ADDR stop_pc;
  int loop = 0;

  /* Bail out early if we're not at a thread event breakpoint.  */
  stop_pc = read_pc_pid (ptid) - DECR_PC_AFTER_BREAK;
  if (stop_pc != td_create_bp_addr && stop_pc != td_death_bp_addr)
    return;

  /* If we are at a create breakpoint, we do not know what new lwp
     was created and cannot specifically locate the event message for it.
     We have to call td_ta_event_getmsg() to get
     the latest message.  Since we have no way of correlating whether
     the event message we get back corresponds to our breakpoint, we must
     loop and read all event messages, processing them appropriately.
     This guarantees we will process the correct message before continuing
     from the breakpoint.

     Currently, death events are not enabled.  If they are enabled,
     the death event can use the td_thr_event_getmsg() interface to
     get the message specifically for that lwp and avoid looping
     below.  */

  loop = 1;

  do
    {
      err = td_ta_event_getmsg_p (thread_agent, &msg);
      if (err != TD_OK)
	{
	  if (err == TD_NOMSG)
	    return;

	  error ("Cannot get thread event message: %s",
		 thread_db_err_str (err));
	}

      err = td_thr_get_info_p (msg.th_p, &ti);
      if (err != TD_OK)
	error ("Cannot get thread info: %s", thread_db_err_str (err));

      ptid = BUILD_THREAD (ti.ti_tid, GET_PID (ptid));

      switch (msg.event)
	{
	case TD_CREATE:
	  /* Call attach_thread whether or not we already know about a
	     thread with this thread ID.  */
	  attach_thread (ptid, msg.th_p, &ti, 1);

	  break;

	case TD_DEATH:

	  if (!in_thread_list (ptid))
	    error ("Spurious thread death event.");

	  detach_thread (ptid, 1);

	  break;

	default:
	  error ("Spurious thread event.");
	}
    }
  while (loop);
}

static ptid_t
thread_db_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  extern ptid_t trap_ptid;

  if (GET_PID (ptid) != -1 && is_thread (ptid))
    ptid = lwp_from_thread (ptid);

  ptid = target_beneath->to_wait (ptid, ourstatus);

  if (proc_handle.pid == 0)
    /* The current child process isn't the actual multi-threaded
       program yet, so don't try to do any special thread-specific
       post-processing and bail out early.  */
    return ptid;

  if (ourstatus->kind == TARGET_WAITKIND_EXITED)
    return pid_to_ptid (-1);

  if (ourstatus->kind == TARGET_WAITKIND_STOPPED
      && ourstatus->value.sig == TARGET_SIGNAL_TRAP)
    /* Check for a thread event.  */
    check_event (ptid);

  if (!ptid_equal (trap_ptid, null_ptid))
    trap_ptid = thread_from_lwp (trap_ptid);

  /* Change the ptid back into the higher level PID + TID format.
     If the thread is dead and no longer on the thread list, we will 
     get back a dead ptid.  This can occur if the thread death event
     gets postponed by other simultaneous events.  In such a case, 
     we want to just ignore the event and continue on.  */
  ptid = thread_from_lwp (ptid);
  if (GET_PID (ptid) == -1)
    ourstatus->kind = TARGET_WAITKIND_SPURIOUS;
  
  return ptid;
}

static int
thread_db_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		       struct mem_attrib *attrib, struct target_ops *target)
{
  struct cleanup *old_chain = save_inferior_ptid ();
  int xfer;

  if (is_thread (inferior_ptid))
    {
      /* FIXME: This seems to be necessary to make sure breakpoints
         are removed.  */
      if (!target_thread_alive (inferior_ptid))
	inferior_ptid = pid_to_ptid (GET_PID (inferior_ptid));
      else
	inferior_ptid = lwp_from_thread (inferior_ptid);
    }

  xfer =
    target_beneath->deprecated_xfer_memory (memaddr, myaddr, len, write,
					    attrib, target);

  do_cleanups (old_chain);
  return xfer;
}

static void
thread_db_fetch_registers (int regno)
{
  struct thread_info *thread_info;
  prgregset_t gregset;
  gdb_prfpregset_t fpregset;
  td_err_e err;

  if (!is_thread (inferior_ptid))
    {
      /* Pass the request to the target beneath us.  */
      target_beneath->to_fetch_registers (regno);
      return;
    }

  thread_info = find_thread_pid (inferior_ptid);
  thread_db_map_id2thr (thread_info, 1);

  err = td_thr_getgregs_p (&thread_info->private->th, gregset);
  if (err != TD_OK)
    error ("Cannot fetch general-purpose registers for thread %ld: %s",
	   (long) GET_THREAD (inferior_ptid), thread_db_err_str (err));

  err = td_thr_getfpregs_p (&thread_info->private->th, &fpregset);
  if (err != TD_OK)
    error ("Cannot get floating-point registers for thread %ld: %s",
	   (long) GET_THREAD (inferior_ptid), thread_db_err_str (err));

  /* Note that we must call supply_gregset after calling the thread_db
     routines because the thread_db routines call ps_lgetgregs and
     friends which clobber GDB's register cache.  */
  supply_gregset ((gdb_gregset_t *) gregset);
  supply_fpregset (&fpregset);
}

static void
thread_db_store_registers (int regno)
{
  prgregset_t gregset;
  gdb_prfpregset_t fpregset;
  td_err_e err;
  struct thread_info *thread_info;

  if (!is_thread (inferior_ptid))
    {
      /* Pass the request to the target beneath us.  */
      target_beneath->to_store_registers (regno);
      return;
    }

  thread_info = find_thread_pid (inferior_ptid);
  thread_db_map_id2thr (thread_info, 1);

  if (regno != -1)
    {
      char raw[MAX_REGISTER_SIZE];

      deprecated_read_register_gen (regno, raw);
      thread_db_fetch_registers (-1);
      regcache_raw_supply (current_regcache, regno, raw);
    }

  fill_gregset ((gdb_gregset_t *) gregset, -1);
  fill_fpregset (&fpregset, -1);

  err = td_thr_setgregs_p (&thread_info->private->th, gregset);
  if (err != TD_OK)
    error ("Cannot store general-purpose registers for thread %ld: %s",
	   (long) GET_THREAD (inferior_ptid), thread_db_err_str (err));
  err = td_thr_setfpregs_p (&thread_info->private->th, &fpregset);
  if (err != TD_OK)
    error ("Cannot store floating-point registers  for thread %ld: %s",
	   (long) GET_THREAD (inferior_ptid), thread_db_err_str (err));
}

static void
thread_db_kill (void)
{
  /* There's no need to save & restore inferior_ptid here, since the
     inferior isn't supposed to survive this function call.  */
  inferior_ptid = lwp_from_thread (inferior_ptid);
  target_beneath->to_kill ();
}

static void
thread_db_create_inferior (char *exec_file, char *allargs, char **env,
			   int from_tty)
{
  unpush_target (&thread_db_ops);
  using_thread_db = 0;
  target_beneath->to_create_inferior (exec_file, allargs, env, from_tty);
}

static void
thread_db_post_startup_inferior (ptid_t ptid)
{
  if (proc_handle.pid == 0)
    {
      /* The child process is now the actual multi-threaded
         program.  Snatch its process ID...  */
      proc_handle.pid = GET_PID (ptid);

      /* ...and perform the remaining initialization steps.  */
      enable_thread_event_reporting ();
      thread_db_find_new_threads ();
    }
}

static void
thread_db_mourn_inferior (void)
{
  remove_thread_event_breakpoints ();

  /* Forget about the child's process ID.  We shouldn't need it
     anymore.  */
  proc_handle.pid = 0;

  target_beneath->to_mourn_inferior ();

  /* Detach thread_db target ops.  */
  unpush_target (&thread_db_ops);
  using_thread_db = 0;
}

static int
thread_db_thread_alive (ptid_t ptid)
{
  td_thrhandle_t th;
  td_err_e err;

  if (is_thread (ptid))
    {
      struct thread_info *thread_info;
      thread_info = find_thread_pid (ptid);

      thread_db_map_id2thr (thread_info, 0);
      if (!thread_info->private->th_valid)
	return 0;

      err = td_thr_validate_p (&thread_info->private->th);
      if (err != TD_OK)
	return 0;

      if (!thread_info->private->ti_valid)
	{
	  err =
	    td_thr_get_info_p (&thread_info->private->th,
			       &thread_info->private->ti);
	  if (err != TD_OK)
	    return 0;
	  thread_info->private->ti_valid = 1;
	}

      if (thread_info->private->ti.ti_state == TD_THR_UNKNOWN
	  || thread_info->private->ti.ti_state == TD_THR_ZOMBIE)
	return 0;		/* A zombie thread.  */

      return 1;
    }

  if (target_beneath->to_thread_alive)
    return target_beneath->to_thread_alive (ptid);

  return 0;
}

static int
find_new_threads_callback (const td_thrhandle_t *th_p, void *data)
{
  td_thrinfo_t ti;
  td_err_e err;
  ptid_t ptid;

  err = td_thr_get_info_p (th_p, &ti);
  if (err != TD_OK)
    error ("find_new_threads_callback: cannot get thread info: %s",
	   thread_db_err_str (err));

  if (ti.ti_state == TD_THR_UNKNOWN || ti.ti_state == TD_THR_ZOMBIE)
    return 0;			/* A zombie -- ignore.  */

  ptid = BUILD_THREAD (ti.ti_tid, GET_PID (inferior_ptid));

  if (!in_thread_list (ptid))
    attach_thread (ptid, th_p, &ti, 1);

  return 0;
}

static void
thread_db_find_new_threads (void)
{
  td_err_e err;

  /* Iterate over all user-space threads to discover new threads.  */
  err = td_ta_thr_iter_p (thread_agent, find_new_threads_callback, NULL,
			  TD_THR_ANY_STATE, TD_THR_LOWEST_PRIORITY,
			  TD_SIGNO_MASK, TD_THR_ANY_USER_FLAGS);
  if (err != TD_OK)
    error ("Cannot find new threads: %s", thread_db_err_str (err));
}

static char *
thread_db_pid_to_str (ptid_t ptid)
{
  if (is_thread (ptid))
    {
      static char buf[64];
      td_thrinfo_t *ti_p;
      td_err_e err;
      struct thread_info *thread_info;

      thread_info = find_thread_pid (ptid);
      thread_db_map_id2thr (thread_info, 0);
      if (!thread_info->private->th_valid)
	{
	  snprintf (buf, sizeof (buf), "Thread %ld (Missing)",
		    GET_THREAD (ptid));
	  return buf;
	}

      ti_p = thread_db_get_info (thread_info);

      if (ti_p->ti_state == TD_THR_ACTIVE && ti_p->ti_lid != 0)
	{
	  snprintf (buf, sizeof (buf), "Thread %ld (LWP %d)",
		    (long) ti_p->ti_tid, ti_p->ti_lid);
	}
      else
	{
	  snprintf (buf, sizeof (buf), "Thread %ld (%s)",
		    (long) ti_p->ti_tid,
		    thread_db_state_str (ti_p->ti_state));
	}

      return buf;
    }

  if (target_beneath->to_pid_to_str (ptid))
    return target_beneath->to_pid_to_str (ptid);

  return normal_pid_to_str (ptid);
}

/* Get the address of the thread local variable in OBJFILE which is
   stored at OFFSET within the thread local storage for thread PTID.  */

static CORE_ADDR
thread_db_get_thread_local_address (ptid_t ptid, struct objfile *objfile,
				    CORE_ADDR offset)
{
  if (is_thread (ptid))
    {
      int objfile_is_library = (objfile->flags & OBJF_SHARED);
      td_err_e err;
      void *address;
      CORE_ADDR lm;
      struct thread_info *thread_info;

      /* glibc doesn't provide the needed interface.  */
      if (!td_thr_tls_get_addr_p)
	error ("Cannot find thread-local variables in this thread library.");

      /* Get the address of the link map for this objfile.  */
      lm = svr4_fetch_objfile_link_map (objfile);

      /* Whoops, we couldn't find one. Bail out.  */
      if (!lm)
	{
	  if (objfile_is_library)
	    error ("Cannot find shared library `%s' link_map in dynamic"
		   " linker's module list", objfile->name);
	  else
	    error ("Cannot find executable file `%s' link_map in dynamic"
		   " linker's module list", objfile->name);
	}

      /* Get info about the thread.  */
      thread_info = find_thread_pid (ptid);
      thread_db_map_id2thr (thread_info, 1);

      /* Finally, get the address of the variable.  */
      err = td_thr_tls_get_addr_p (&thread_info->private->th, (void *) lm,
				   offset, &address);

#ifdef THREAD_DB_HAS_TD_NOTALLOC
      /* The memory hasn't been allocated, yet.  */
      if (err == TD_NOTALLOC)
	{
	  /* Now, if libthread_db provided the initialization image's
	     address, we *could* try to build a non-lvalue value from
	     the initialization image.  */
	  if (objfile_is_library)
	    error ("The inferior has not yet allocated storage for"
		   " thread-local variables in\n"
		   "the shared library `%s'\n"
		   "for the thread %ld",
		   objfile->name, (long) GET_THREAD (ptid));
	  else
	    error ("The inferior has not yet allocated storage for"
		   " thread-local variables in\n"
		   "the executable `%s'\n"
		   "for the thread %ld",
		   objfile->name, (long) GET_THREAD (ptid));
	}
#endif

      /* Something else went wrong.  */
      if (err != TD_OK)
	{
	  if (objfile_is_library)
	    error ("Cannot find thread-local storage for thread %ld, "
		   "shared library %s:\n%s",
		   (long) GET_THREAD (ptid),
		   objfile->name, thread_db_err_str (err));
	  else
	    error ("Cannot find thread-local storage for thread %ld, "
		   "executable file %s:\n%s",
		   (long) GET_THREAD (ptid),
		   objfile->name, thread_db_err_str (err));
	}

      /* Cast assuming host == target.  Joy.  */
      return (CORE_ADDR) address;
    }

  if (target_beneath->to_get_thread_local_address)
    return target_beneath->to_get_thread_local_address (ptid, objfile,
							offset);

  error ("Cannot find thread-local values on this target.");
}

static void
init_thread_db_ops (void)
{
  thread_db_ops.to_shortname = "multi-thread";
  thread_db_ops.to_longname = "multi-threaded child process.";
  thread_db_ops.to_doc = "Threads and pthreads support.";
  thread_db_ops.to_attach = thread_db_attach;
  thread_db_ops.to_detach = thread_db_detach;
  thread_db_ops.to_resume = thread_db_resume;
  thread_db_ops.to_wait = thread_db_wait;
  thread_db_ops.to_fetch_registers = thread_db_fetch_registers;
  thread_db_ops.to_store_registers = thread_db_store_registers;
  thread_db_ops.deprecated_xfer_memory = thread_db_xfer_memory;
  thread_db_ops.to_kill = thread_db_kill;
  thread_db_ops.to_create_inferior = thread_db_create_inferior;
  thread_db_ops.to_post_startup_inferior = thread_db_post_startup_inferior;
  thread_db_ops.to_mourn_inferior = thread_db_mourn_inferior;
  thread_db_ops.to_thread_alive = thread_db_thread_alive;
  thread_db_ops.to_find_new_threads = thread_db_find_new_threads;
  thread_db_ops.to_pid_to_str = thread_db_pid_to_str;
  thread_db_ops.to_stratum = thread_stratum;
  thread_db_ops.to_has_thread_control = tc_schedlock;
  thread_db_ops.to_get_thread_local_address
    = thread_db_get_thread_local_address;
  thread_db_ops.to_magic = OPS_MAGIC;
}

void
_initialize_thread_db (void)
{
  /* Only initialize the module if we can load libthread_db.  */
  if (thread_db_load ())
    {
      init_thread_db_ops ();
      add_target (&thread_db_ops);

      /* Add ourselves to objfile event chain.  */
      target_new_objfile_chain = deprecated_target_new_objfile_hook;
      deprecated_target_new_objfile_hook = thread_db_new_objfile;
    }
}
@


1.46
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@@


1.45
log
@2004-09-14  Andrew Cagney  <cagney@@gnu.org>

	* thread-db.c (thread_db_new_objfile): Assume that there is a
	child process.
@
text
@d990 2
a991 2
    target_beneath->to_xfer_memory (memaddr, myaddr, len, write, attrib,
				    target);
d1342 1
a1342 1
  thread_db_ops.to_xfer_memory = thread_db_xfer_memory;
@


1.44
log
@2004-09-08  Andrew Cagney  <cagney@@gnu.org>

	* thread-db.c (keep_thread_db): Delete.
	(thread_db_new_objfile, thread_db_create_inferior)
	(thread_db_mourn_inferior): Simplify assuming !keep_thread_db.
@
text
@d700 2
a701 8
      /* We can only poke around if there actually is a child process.
         If there is no child process alive, postpone the steps below
         until one has been created.  */
      if (proc_handle.pid != 0)
	{
	  enable_thread_event_reporting ();
	  thread_db_find_new_threads ();
	}
@


1.43
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@a65 4
/* Non-zero if we have to keep this module's target vector active
   across re-runs.  */
static int keep_thread_db;

a671 2
      keep_thread_db = 0;

a699 12
      /* If the thread library was detected in the main symbol file
         itself, we assume that the program was statically linked
         against the thread library and well have to keep this
         module's target vector activated until forever...  Well, at
         least until all symbols have been discarded anyway (see
         above).  */
      if (objfile == symfile_objfile)
	{
	  gdb_assert (proc_handle.pid == 0);
	  keep_thread_db = 1;
	}

d1091 2
a1092 6
  if (!keep_thread_db)
    {
      unpush_target (&thread_db_ops);
      using_thread_db = 0;
    }

d1122 3
a1124 11
  /* Detach thread_db target ops if not dealing with a statically
     linked threaded program.  This allows a corefile to be debugged
     after finishing debugging of a threaded program.  At present,
     debugging a statically-linked threaded program is broken, but
     the check is added below in the event that it is fixed in the
     future.  */
  if (!keep_thread_db)
    {
      unpush_target (&thread_db_ops);
      using_thread_db = 0;
    }
@


1.42
log
@
2004-06-07  Jeff Johnston  <jjohnstn@@redhat.com>

        * thread-db.c (thread_get_info_callback): Fill in the thread_info
        struct if one exists, even if we are dealing with a zombie thread.
@
text
@d1080 1
a1080 1
      supply_register (regno, raw);
@


1.42.4.1
log
@Allow access to all 64 bits of the SPE GPR's in multi-threaded
programs.
* ppc-tdep.h (struct speregset): New struct type.
* ppc-linux-tdep.c: #include "gdb_assert.h".
(ppc_linux_supply_speregset, ppc_linux_collect_speregset): New
functions.
(ppc_linux_speregset): New structure.
(ppc_linux_init_abi): Describe how to pass the full 64-bit values
of the SPE GPRs across the thread-db interface.
* ppc-linux-nat.c (struct gdb_evrregset_t): Doc fix.
* Makefile.in (ppc-linux-tdep.o): Update dependencies.

Allow targets to specify an extended register set, to be passed
through libthread_db via its 'xregs' functions.
* gdbarch.sh (XREGS_REGSET, XREGS_SIZE, XREGS_NAME): New gdbarch
members.
* gdbarch.c, gdbarch.h: Regenerated.
* proc-service.c: #include "regset.h" and "regcache.h".
(ps_lgetxregsize, ps_lgetxregs, ps_lsetxregs): Fill in real
implementations of these functions.
* thread-db.c: #include "regset.h".
(td_thr_getxregsize_p, td_thr_getxregs_p, td_thr_setxregs_p): New
variables.
(thread_db_load): Initialize them.
(warned_xregs_not_implemented): New variable.
(thread_db_new_objfile): Clear it here.
(thread_db_fetch_registers, thread_db_store_registers): Supply and
collect the xregset, too, if the architecture says it has one, and
libthread_db seems to be able to support it.
* Makefile.in (proc-service.o, thread-db.o): Update dependencies.
@
text
@a34 1
#include "regset.h"
a107 2
static td_err_e (*td_thr_getxregsize_p) (const td_thrhandle_t *__th,
                                         int *__sizep);
a111 2
static td_err_e (*td_thr_getxregs_p) (const td_thrhandle_t *__th,
                                      void *__xregs);
a115 2
static td_err_e (*td_thr_setxregs_p) (const td_thrhandle_t *__th,
                                      const void *__addr);
a132 8
/* On some architectures, there are additional regs beyond the gregset
   and fpregset.  The libthread_db interface has functions to access
   these, but on some versions of libthread_db they are not
   implemented.  We want to warn the user about this, but not treat it
   as a fatal error, since you can still access the other
   registers.  */
static int warned_xregs_not_implemented;

a472 4
  td_thr_getxregsize_p = verbose_dlsym (handle, "td_thr_getxregsize");
  if (td_thr_getxregsize_p == NULL)
    return 0;

a480 4
  td_thr_getxregs_p = verbose_dlsym (handle, "td_thr_getxregs");
  if (td_thr_getxregs_p == NULL)
    return 0;

a488 4
  td_thr_setxregs_p = verbose_dlsym (handle, "td_thr_setxregs");
  if (td_thr_setxregs_p == NULL)
    return 0;

a705 5
      /* If the gdbarch says we have an extended register set, but we are
         unable to access them via libthread_db, we want to issue one
         warning each time we active libthread_db.  */
      warned_xregs_not_implemented = 0;

a1026 3
  void *xregs = 0;
  int fetched_xregs = 0;
  struct regset *xregs_regset = gdbarch_xregs_regset (current_gdbarch);
a1038 3
  if (xregs_regset)
    xregs = alloca (gdbarch_xregs_size (current_gdbarch));

a1048 26
  if (xregs_regset)
    {
      err = td_thr_getxregs_p (&thread_info->private->th, xregs);
      switch (err)
        {
        case TD_OK:
          fetched_xregs = 1;
          break;

        case TD_NOXREGS:
          if (! warned_xregs_not_implemented)
            {
              warning ("thread debugging library is too old to access "
                       "%s registers.",
                       gdbarch_xregs_name (current_gdbarch));
              warned_xregs_not_implemented = 1;
            }
          break;

        default:
          error ("Cannot get %s registers for thread %ld: %s",
                 gdbarch_xregs_name (current_gdbarch),
                 (long) GET_THREAD (inferior_ptid), thread_db_err_str (err));
        }
    }

a1053 4

  if (fetched_xregs)
    xregs_regset->supply_regset (xregs_regset, current_regcache, -1, xregs,
                                 gdbarch_xregs_size (current_gdbarch));
a1060 2
  void *xregs = 0;
  struct regset *xregs_regset = gdbarch_xregs_regset (current_gdbarch);
a1073 3
  if (xregs_regset)
    xregs = alloca (gdbarch_xregs_size (current_gdbarch));

a1084 4
  if (xregs_regset)
    xregs_regset->collect_regset (xregs_regset, current_regcache, -1,
                                  (void *) xregs,
                                  gdbarch_xregs_size (current_gdbarch));
a1093 18
  if (xregs_regset)
    {
      err = td_thr_setxregs_p (&thread_info->private->th, xregs);
      if (err == TD_NOXREGS)
        {
          if (! warned_xregs_not_implemented)
            {
              warning ("thread debugging library is too old to access"
                       " %s registers.",
                       gdbarch_xregs_name (current_gdbarch));
              warned_xregs_not_implemented = 1;
            }
        }
      else if (err != TD_OK)
        error ("Cannot store %s registers for thread %ld: %s",
               gdbarch_xregs_name (current_gdbarch),
               (long) GET_THREAD (inferior_ptid), thread_db_err_str (err));
    }
@


1.41
log
@
2004-06-04  Jeff Johnston  <jjohnstn@@redhat.com>

        * infrun.c (handle_inferior_event): Don't treat an invalid ptid
        as a new thread event.
        * thread_db.c (thread_get_info_callback): If the thread is a
        zombie, return TD_THR_ZOMBIE.
        * (thread_from_lwp): If thread_get_info_callback returns
        TD_THR_ZOMBIE, check if the thread is still on the thread list
        and return a -1 ptid if not found.
        (thread_db_wait): If thread_from_lwp returns a -1 ptid, then
        change the status to TARGET_WAITKIND_SPURIOUS.
@
text
@d278 1
a278 2
     attach to it thinking it is a new thread and we don't want to mark
     it as valid.  */
d283 7
@


1.40
log
@2004-05-25  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Add from_tty to
	to_create_inferior.
	(target_create_inferior, find_default_create_inferior): Update.
	* infcmd.c (run_command): Update.
	* wince.c (child_create_inferior): Update.
	* win32-nat.c (child_create_inferior): Update.
	* uw-thread.c (uw_thread_create_inferior): Update.
	* thread-db.c (thread_db_create_inferior): Update.
	* target.c (debug_to_create_inferior)
	(find_default_create_inferior): Update.
	(maybe_kill_then_create_inferior): Update.
	* sol-thread.c (sol_thread_create_inferior): Update.
	* remote.c (extended_remote_async_create_inferior)
	(extended_remote_create_inferior): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* remote-st.c (st2000_create_inferior): Update.
	* remote-sim.c (gdbsim_create_inferior): Update.
	* remote-sds.c (sds_create_inferior): Update.
	* remote-rdp.c (remote_rdp_create_inferior): Update.
	* remote-rdi.c (arm_rdi_create_inferior): Update.
	* remote-m32r-sdi.c (m32r_create_inferior): Update.
	* remote-e7000.c (e7000_create_inferior): Update.
	* procfs.c (procfs_create_inferior): Update.
	* ocd.c (ocd_create_inferior): Update.
	* ocd.h (ocd_create_inferior): Update.
	* nto-procfs.c (procfs_create_inferior): Update.
	* monitor.c (monitor_create_inferior): Update.
	* lin-lwp.c (lin_lwp_create_inferior): Update.
	* inftarg.c (child_create_inferior): Update.
	* hpux-thread.c (hpux_thread_create_inferior): Update.
	* gnu-nat.c (gnu_create_inferior): Update.
@
text
@d255 4
a258 1
   *INFOP.  */
d277 10
d371 13
a383 1
  thread_get_info_callback (&th, &thread_info);
d978 10
a987 1
  return thread_from_lwp (ptid);
@


1.39
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d1066 2
a1067 1
thread_db_create_inferior (char *exec_file, char *allargs, char **env)
d1075 1
a1075 1
  target_beneath->to_create_inferior (exec_file, allargs, env);
@


1.38
log
@	* Makefile.in (linux_nat_h): Update dependencies.
	* configure.in: Check for <gnu/libc-version.h>.
	* configure: Regenerate.
	* config.in: Regenerate.
	* linux-nat.h: Include "target.h".  Add waitstatus field to
	struct lwp_info.
	* lin-lwp.c (add_lwp): Initialize waitstatus.kind.
	(lin_lwp_attach_lwp): Don't attach to LWPs we have already attached
	to.
	(lin_lwp_handle_extended): New function.  Handle clone events.
	(wait_lwp): Use lin_lwp_handle_extended.  Update comment about
	thread exit events.
	(child_wait): Handle clone events.
	(lin_lwp_wait: Use lin_lwp_handle_extended and handle clone events.
	* linux-nat.c (linux_enable_event_reporting): Turn on
	PTRACE_O_TRACECLONE.
	(linux_handle_extended_wait): Handle clone events.
	* thread-db.c: Include <gnu/libc-version.h>.
	(struct private_thread_info): Add dying flag.
	(enable_thread_event_reporting): Enable TD_DEATH for glibc 2.2 and
	higher.
	(attach_thread): Update comments.  Handle dying threads.
	(detach_thread): Set the dying flag.
	(check_event): Always call attach_thread.
@
text
@d1362 2
a1363 2
      target_new_objfile_chain = target_new_objfile_hook;
      target_new_objfile_hook = thread_db_new_objfile;
@


1.37
log
@	* thread-db.c (disable_thread_signals): Remove unused function.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
d38 4
d137 1
d158 3
d502 4
d516 2
a517 1
#if 0
d521 3
a523 1
  td_event_addset (&events, TD_DEATH);
d525 1
d708 4
d719 21
d785 2
d789 11
d904 3
a906 6

	  /* We may already know about this thread, for instance when the
	     user has issued the `info threads' command before the SIGTRAP
	     for hitting the thread creation breakpoint was reported.  */
	  if (!in_thread_list (ptid))
	    attach_thread (ptid, msg.th_p, &ti, 1);
@


1.36
log
@2003-12-02  Roland McGrath  <roland@@redhat.com>

	* thread-db.c (enable_thread_event): Change return type to
	td_err_e.  Return TD_OK or error code.
	(enable_thread_event_reporting): Update callers.
@
text
@a587 21
disable_thread_signals (void)
{
#ifdef GET_THREAD_SIGNALS
  if (thread_signals)
    {
      int i;

      for (i = 1; i < NSIG; i++)
	{
	  if (sigismember (&thread_stop_set, i))
	    signal_stop_update (target_signal_from_host (i), 1);
	  if (sigismember (&thread_print_set, i))
	    signal_print_update (target_signal_from_host (i), 1);
	}

      thread_signals = 0;
    }
#endif
}

static void
@


1.36.6.1
log
@Merge mainline to intercu branch.
@
text
@d588 21
@


1.36.6.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2003, 2004 Free Software Foundation, Inc.
a37 4
#ifdef HAVE_GNU_LIBC_VERSION_H
#include <gnu/libc-version.h>
#endif

a132 1
static void detach_thread (ptid_t ptid, int verbose);
a152 3
  /* Flag set when we see a TD_DEATH event for this thread.  */
  unsigned int dying:1;

a493 4
#ifdef HAVE_GNU_LIBC_VERSION_H
  const char *libc_version;
  int libc_major, libc_minor;
#endif
d504 1
a504 2

#ifdef HAVE_GNU_LIBC_VERSION_H
d508 1
a508 3
  libc_version = gnu_get_libc_version ();
  if (sscanf (libc_version, "%d.%d", &libc_major, &libc_minor) == 2
      && (libc_major > 2 || (libc_major == 2 && libc_minor > 1)))
a509 1
    td_event_addset (&events, TD_DEATH);
a691 4
/* Attach to a new thread.  This function is called when we receive a
   TD_CREATE event or when we iterate over all threads and find one
   that wasn't already in our list.  */

a698 21
  /* If we're being called after a TD_CREATE event, we may already
     know about this thread.  There are two ways this can happen.  We
     may have iterated over all threads between the thread creation
     and the TD_CREATE event, for instance when the user has issued
     the `info threads' command before the SIGTRAP for hitting the
     thread creation breakpoint was reported.  Alternatively, the
     thread may have exited and a new one been created with the same
     thread ID.  In the first case we don't need to do anything; in
     the second case we should discard information about the dead
     thread and attach to the new one.  */
  if (in_thread_list (ptid))
    {
      tp = find_thread_pid (ptid);
      gdb_assert (tp != NULL);

      if (!tp->private->dying)
        return;

      delete_thread (ptid);
    }

a743 2
  struct thread_info *thread_info;

a745 11

  /* Don't delete the thread now, because it still reports as active
     until it has executed a few instructions after the event
     breakpoint - if we deleted it now, "info threads" would cause us
     to re-attach to it.  Just mark it as having had a TD_DEATH
     event.  This means that we won't delete it from our thread list
     until we notice that it's dead (via prune_threads), or until
     something re-uses its thread ID.  */
  thread_info = find_thread_pid (ptid);
  gdb_assert (thread_info != NULL);
  thread_info->private->dying = 1;
d850 6
a855 3
	  /* Call attach_thread whether or not we already know about a
	     thread with this thread ID.  */
	  attach_thread (ptid, msg.th_p, &ti, 1);
@


1.36.6.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d66 4
d255 1
a255 4
   *INFOP.

   If the thread is a zombie, TD_THR_ZOMBIE is returned.  Otherwise,
   zero is returned to indicate success.  */
a273 16
  /* In the case of a zombie thread, don't continue.  We don't want to
     attach to it thinking it is a new thread.  */
  if (ti.ti_state == TD_THR_UNKNOWN || ti.ti_state == TD_THR_ZOMBIE)
    {
      if (infop != NULL)
        *(struct thread_info **) infop = thread_info;
      if (thread_info != NULL)
	{
	  memcpy (&thread_info->private->th, thp, sizeof (*thp));
	  thread_info->private->th_valid = 1;
	  memcpy (&thread_info->private->ti, &ti, sizeof (ti));
	  thread_info->private->ti_valid = 1;
	}
      return TD_THR_ZOMBIE;
    }

d358 1
a358 13

  /* Fetch the thread info.  If we get back TD_THR_ZOMBIE, then the
     event thread has already died.  If another gdb interface has called
     thread_alive() previously, the thread won't be found on the thread list
     anymore.  In that case, we don't want to process this ptid anymore
     to avoid the possibility of later treating it as a newly
     discovered thread id that we should add to the list.  Thus,
     we return a -1 ptid which is also how the thread list marks a
     dead thread.  */
  if (thread_get_info_callback (&th, &thread_info) == TD_THR_ZOMBIE
      && thread_info == NULL)
    return pid_to_ptid (-1);

d645 2
d675 20
a694 2
      enable_thread_event_reporting ();
      thread_db_find_new_threads ();
d953 1
a953 10
  /* Change the ptid back into the higher level PID + TID format.
     If the thread is dead and no longer on the thread list, we will 
     get back a dead ptid.  This can occur if the thread death event
     gets postponed by other simultaneous events.  In such a case, 
     we want to just ignore the event and continue on.  */
  ptid = thread_from_lwp (ptid);
  if (GET_PID (ptid) == -1)
    ourstatus->kind = TARGET_WAITKIND_SPURIOUS;
  
  return ptid;
d1040 1
a1040 1
      regcache_raw_supply (current_regcache, regno, raw);
d1066 1
a1066 2
thread_db_create_inferior (char *exec_file, char *allargs, char **env,
			   int from_tty)
d1068 7
a1074 3
  unpush_target (&thread_db_ops);
  using_thread_db = 0;
  target_beneath->to_create_inferior (exec_file, allargs, env, from_tty);
d1103 11
a1113 3
  /* Detach thread_db target ops.  */
  unpush_target (&thread_db_ops);
  using_thread_db = 0;
d1362 2
a1363 2
      target_new_objfile_chain = deprecated_target_new_objfile_hook;
      deprecated_target_new_objfile_hook = thread_db_new_objfile;
@


1.36.8.1
log
@	* thread-db.c (disable_thread_signals): Remove unused function.
@
text
@d588 21
@


1.35
log
@2003-11-25  Andrew Cagney  <cagney@@redhat.com>

	* thread-db.c (enable_thread_event): New function.  Ensure that BP
	is a code address.
	(enable_thread_event_reporting): Use enable_thread_event.
@
text
@d243 1
a243 1
   threads to LWPs.  
d468 1
a468 1
static int
d472 1
a472 1
  int err;
d477 1
a477 1
    return 0;
d485 1
a485 1
  return 1;
d525 2
a526 1
  if (!enable_thread_event (thread_agent, TD_CREATE, &td_create_bp_addr))
d534 2
a535 1
  if (!enable_thread_event (thread_agent, TD_DEATH, &td_death_bp_addr))
d838 1
a838 1
     the event message we get back corresponds to our breakpoint, we must 
d840 2
a841 2
     This guarantees we will process the correct message before continuing 
     from the breakpoint.  
@


1.34
log
@2003-09-04  Andrew Cagney  <cagney@@redhat.com>

	* thread-db.c (verbose_dlsym): New function.
	(thread_db_load): Use verbose_dlsym
	(thread_db_new_objfile): Print that libthread_db was loaded, and
	that thread debugging was enabled.
@
text
@d468 20
d521 2
d524 2
a525 3
  /* Get address for thread creation breakpoint.  */
  err = td_ta_event_addr_p (thread_agent, TD_CREATE, &notify);
  if (err != TD_OK)
d532 2
a533 7
  /* Set up the breakpoint.  */
  td_create_bp_addr = (CORE_ADDR) notify.u.bptaddr;
  create_thread_event_breakpoint (td_create_bp_addr);

  /* Get address for thread death breakpoint.  */
  err = td_ta_event_addr_p (thread_agent, TD_DEATH, &notify);
  if (err != TD_OK)
a538 4

  /* Set up the breakpoint.  */
  td_death_bp_addr = (CORE_ADDR) notify.u.bptaddr;
  create_thread_event_breakpoint (td_death_bp_addr);
@


1.33
log
@
2003-06-05  Jeff Johnston  <jjohnstn@@redhat.com>

        * thread-db.c (check_event): For create/death event breakpoints,
        loop through all messages to ensure that we read the message
        corresponding to the breakpoint we are at.
@
text
@d378 9
d406 1
a406 1
  td_init_p = dlsym (handle, "td_init");
d410 1
a410 1
  td_ta_new_p = dlsym (handle, "td_ta_new");
d414 1
a414 1
  td_ta_map_id2thr_p = dlsym (handle, "td_ta_map_id2thr");
d418 1
a418 1
  td_ta_map_lwp2thr_p = dlsym (handle, "td_ta_map_lwp2thr");
d422 1
a422 1
  td_ta_thr_iter_p = dlsym (handle, "td_ta_thr_iter");
d426 1
a426 1
  td_thr_validate_p = dlsym (handle, "td_thr_validate");
d430 1
a430 1
  td_thr_get_info_p = dlsym (handle, "td_thr_get_info");
d434 1
a434 1
  td_thr_getfpregs_p = dlsym (handle, "td_thr_getfpregs");
d438 1
a438 1
  td_thr_getgregs_p = dlsym (handle, "td_thr_getgregs");
d442 1
a442 1
  td_thr_setfpregs_p = dlsym (handle, "td_thr_setfpregs");
d446 1
a446 1
  td_thr_setgregs_p = dlsym (handle, "td_thr_setgregs");
d599 24
d660 2
@


1.33.8.1
log
@2003-08-21  Andrew Cagney  <cagney@@redhat.com>

	* thread-db.c (verbose_dlsym): New function.
	(thread_db_load): Use verbose_dlsym
	(thread_db_new_objfile): Print that libthread_db was loaded, and
	that thread debugging was enabled.
@
text
@a377 9
static void *
verbose_dlsym (void *handle, const char *name)
{
  void *sym = dlsym (handle, name);
  if (sym == NULL)
    warning ("Symbol \"%s\" not found in libthread_db: %s", name, dlerror ());
  return sym;
}

d397 1
a397 1
  td_init_p = verbose_dlsym (handle, "td_init");
d401 1
a401 1
  td_ta_new_p = verbose_dlsym (handle, "td_ta_new");
d405 1
a405 1
  td_ta_map_id2thr_p = verbose_dlsym (handle, "td_ta_map_id2thr");
d409 1
a409 1
  td_ta_map_lwp2thr_p = verbose_dlsym (handle, "td_ta_map_lwp2thr");
d413 1
a413 1
  td_ta_thr_iter_p = verbose_dlsym (handle, "td_ta_thr_iter");
d417 1
a417 1
  td_thr_validate_p = verbose_dlsym (handle, "td_thr_validate");
d421 1
a421 1
  td_thr_get_info_p = verbose_dlsym (handle, "td_thr_get_info");
d425 1
a425 1
  td_thr_getfpregs_p = verbose_dlsym (handle, "td_thr_getfpregs");
d429 1
a429 1
  td_thr_getgregs_p = verbose_dlsym (handle, "td_thr_getgregs");
d433 1
a433 1
  td_thr_setfpregs_p = verbose_dlsym (handle, "td_thr_setfpregs");
d437 1
a437 1
  td_thr_setgregs_p = verbose_dlsym (handle, "td_thr_setgregs");
a589 15
  /* First time through, report that libthread_db was successfuly
     loaded.  Can't print this in in thread_db_load as, at that stage,
     the interpreter and it's console haven't started.  The real
     problem here is probably that libthread_db is loaded too early -
     should it only be loaded when there is a program to debug?  */
  {
    static int dejavu;
    if (!dejavu)
      {
	printf_unfiltered ("Using host libthread_db library \"%s\"\n",
			   LIBTHREAD_DB_SO);
	dejavu = 1;
      }
  }

a626 2
      printf_unfiltered ("[Thread debugging using libthread_db enabled]\n");

@


1.32
log
@
2003-06-03  Jeff Johnston  <jjohnstn@@redhat.com>

        * thread-db.c (thread_db_mourn_inferior): Unpush thread target
        layer if not dealing with a statically-linked threaded program.
@
text
@d778 1
d785 17
a801 2
  err = td_ta_event_getmsg_p (thread_agent, &msg);
  if (err != TD_OK)
d803 13
a815 2
      if (err == TD_NOMSG)
	return;
d817 11
a827 2
      error ("Cannot get thread event message: %s", thread_db_err_str (err));
    }
d829 1
a829 4
  err = td_thr_get_info_p (msg.th_p, &ti);
  if (err != TD_OK)
    error ("check_event: cannot get thread info: %s",
	   thread_db_err_str (err));
d831 1
a831 1
  ptid = BUILD_THREAD (ti.ti_tid, GET_PID (ptid));
d833 2
a834 26
  switch (msg.event)
    {
    case TD_CREATE:
#if 0
      /* FIXME: kettenis/2000-08-26: Since we use td_ta_event_getmsg,
         there is no guarantee that the breakpoint will match the
         event.  Should we use td_thr_event_getmsg instead?  */

      if (stop_pc != td_create_bp_addr)
	error ("Thread creation event doesn't match breakpoint.");
#endif

      /* We may already know about this thread, for instance when the
         user has issued the `info threads' command before the SIGTRAP
         for hitting the thread creation breakpoint was reported.  */
      if (!in_thread_list (ptid))
	attach_thread (ptid, msg.th_p, &ti, 1);
      return;

    case TD_DEATH:
#if 0
      /* FIXME: See TD_CREATE.  */

      if (stop_pc != td_death_bp_addr)
	error ("Thread death event doesn't match breakpoint.");
#endif
d836 1
a836 2
      if (!in_thread_list (ptid))
	error ("Spurious thread death event.");
d838 1
a838 2
      detach_thread (ptid, 1);
      return;
d840 3
a842 2
    default:
      error ("Spurious thread event.");
d844 1
@


1.31
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (max_register_size): Delete declaration.
	* regcache.c (max_register_size): Delete function.
	(struct regcache_descr): Delete field "max_register_size".
	(init_regcache_descr, init_legacy_regcache_descr): Assert that all
	registers fit in MAX_REGISTER_SIZE.
	(regcache_save): Replace max_register_size with MAX_REGISTER_SIZE.
	(regcache_restore, regcache_xfer_part, regcache_dump): Ditto.
	* thread-db.c: Replace max_register_size with MAX_REGISTER_SIZE.
	* sh-tdep.c, rom68k-rom.c, remote-sim.c, remote-mips.c: Ditto.
	* remote-e7000.c, monitor.c, mipsv4-nat.c, mips-nat.c: Ditto.
	* m68klinux-nat.c, lynx-nat.c, irix4-nat.c: Ditto.
	* hpux-thread.c, hppah-nat.c, hppab-nat.c, hppa-tdep.c: Ditto.
	* dve3900-rom.c, hppa-tdep.c: Ditto.
@
text
@d1014 12
@


1.30
log
@
2003-04-17  Jeff Johnston  <jjohnstn@@redhat.com>

        * thread-db.c: Reindented.
@
text
@d948 1
a948 1
      char *raw = alloca (max_register_size (current_gdbarch));
@


1.30.2.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d948 1
a948 1
      char raw[MAX_REGISTER_SIZE];
@


1.29
log
@2003-02-02  Andrew Cagney  <ac131313@@redhat.com>

	* mips-nat.c (zerobuf): Delete.
	(fetch_inferior_registers): Alloc local zerobuf.
	(fetch_core_registers): Alloc local zerobuf.
	* d10v-tdep.c (show_regs): Don't allocate a dynamic array using
	MAX_REGISTER_RAW_SIZE or MAX_REGISTER_VIRTUAL_SIZE.
	* thread-db.c (thread_db_store_registers): Ditto.
	* sh-tdep.c (sh_do_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote-sim.c (gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* monitor.c (monitor_supply_register): Ditto.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	* m68klinux-nat.c (fetch_register): Ditto.
	* lynx-nat.c (fetch_inferior_registers): Ditto.
	(fetch_inferior_registers): Ditto.
	* irix4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (fetch_register): Ditto.
	* hppab-nat.c (fetch_register): Ditto.
	* hppa-tdep.c (pa_register_look_aside): Ditto.
	(pa_print_fp_reg, pa_strcat_fp_reg): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register): Ditto.
@
text
@d57 1
a57 1
static void (*target_new_objfile_chain) (struct objfile *objfile);
d83 2
a84 1
static td_err_e (*td_ta_new_p) (struct ps_prochandle *ps, td_thragent_t **ta);
d87 2
a88 2
static td_err_e (*td_ta_map_lwp2thr_p) (const td_thragent_t *ta, lwpid_t lwpid,
					td_thrhandle_t *th);
d90 3
a92 3
				     td_thr_iter_f *callback,
				     void *cbdata_p, td_thr_state_e state,
				     int ti_pri, sigset_t *ti_sigmask_p,
d112 2
a113 1
static td_err_e (*td_thr_event_enable_p) (const td_thrhandle_t *th, int event);
d116 2
a117 3
                                          void *map_address,
                                          size_t offset,
                                          void **address);
d154 2
a155 2
  unsigned int th_valid : 1;
  unsigned int ti_valid : 1;
d259 1
a259 1
    error ("thread_get_info_callback: cannot get thread info: %s", 
d301 2
a302 1
	       (long) GET_THREAD (thread_info->ptid), thread_db_err_str (err));
d316 1
a316 1
  if (! thread_info->private->th_valid)
d319 2
a320 1
  err = td_thr_get_info_p (&thread_info->private->th, &thread_info->private->ti);
d322 1
a322 1
    error ("thread_db_get_info: cannot get thread info: %s", 
d387 1
a387 1
      fprintf_filtered (gdb_stderr, "\n\ndlopen failed on '%s' - %s\n", 
d389 1
a389 1
      fprintf_filtered (gdb_stderr, 
d659 1
a659 1
 quit:
d710 1
a710 1
  thread_db_find_new_threads();
d795 1
a795 1
    error ("check_event: cannot get thread info: %s", 
d870 1
a870 2
		       struct mem_attrib *attrib,
		       struct target_ops *target)
d885 3
a887 1
  xfer = target_beneath->to_xfer_memory (memaddr, myaddr, len, write, attrib, target);
d1028 1
a1028 1
      if (! thread_info->private->th_valid)
d1035 1
a1035 1
      if (! thread_info->private->ti_valid)
d1037 3
a1039 1
	  err = td_thr_get_info_p (&thread_info->private->th, &thread_info->private->ti);
d1067 1
a1067 1
    error ("find_new_threads_callback: cannot get thread info: %s", 
d1106 1
a1106 1
      if (! thread_info->private->th_valid)
d1108 2
a1109 1
	  snprintf (buf, sizeof (buf), "Thread %ld (Missing)", GET_THREAD (ptid));
d1123 2
a1124 1
		    (long) ti_p->ti_tid, thread_db_state_str (ti_p->ti_state));
d1141 1
a1141 1
                                    CORE_ADDR offset)
d1152 2
a1153 2
      if (! td_thr_tls_get_addr_p)
        error ("Cannot find thread-local variables in this thread library.");
d1160 3
a1162 3
        {
          if (objfile_is_library)
            error ("Cannot find shared library `%s' link_map in dynamic"
d1165 1
a1165 1
            error ("Cannot find executable file `%s' link_map in dynamic"
d1180 9
a1188 9
        {
          /* Now, if libthread_db provided the initialization image's
             address, we *could* try to build a non-lvalue value from
             the initialization image.  */
          if (objfile_is_library)
            error ("The inferior has not yet allocated storage for"
                   " thread-local variables in\n"
                   "the shared library `%s'\n"
                   "for the thread %ld",
d1190 5
a1194 5
          else
            error ("The inferior has not yet allocated storage for"
                   " thread-local variables in\n"
                   "the executable `%s'\n"
                   "for the thread %ld",
d1206 1
a1206 2
		   objfile->name,
		   thread_db_err_str (err));
d1211 1
a1211 2
		   objfile->name,
		   thread_db_err_str (err));
d1219 2
a1220 1
    return target_beneath->to_get_thread_local_address (ptid, objfile, offset);
@


1.28
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@d944 1
a944 1
      char raw[MAX_REGISTER_RAW_SIZE];
@


1.27
log
@	* thread-db.c (attach_thread): Prototype.
	(struct private_thread_info): Remove lwpid.  Add thread handle (th),
	thread information (ti), and valid flags (th_valid, ti_valid).
	(attach_thread): Move target_pid_to_str call to after the thread
	is added to GDB's list.  Initialize the cache.
	(thread_get_info_callback, thread_db_map_id2thr)
	(thread_db_get_info): New functions.
	(thread_from_lwp, lwp_from_thread, thread_db_fetch_registers)
	(thread_db_store_registers, thread_db_thread_alive)
	(thread_db_get_thread_local_address): Use them.
	(thread_db_pid_to_str): Likewise.  Return "Missing" instead
	of calling error() for threads in unknown state.

	(clear_lwpid_callback): New function.
	(thread_db_resume): Use it to clear the cache.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.26
log
@2002-12-13  Michael Snyder  <msnyder@@to-limbo.toronto.redhat.com>

	* thread-db.c (thread_from_lwp): Uniquify error msg.
	(lwp_from_thread): Ditto.
	(check_event): Ditto.
	(find_new_threads_callback): Ditto.
	(thread_db_pid_to_str): Ditto.
@
text
@d129 2
d146 3
d151 6
a156 2
  /* Cached LWP id.  Must come first, see lin-lwp.c.  */
  lwpid_t lwpid;
d240 44
d285 40
a329 1
  td_thrinfo_t ti;
d332 2
d345 3
a347 4
  err = td_thr_get_info_p (&th, &ti);
  if (err != TD_OK)
    error ("thread_from_lwp: cannot get thread info: %s", 
	   thread_db_err_str (err));
d349 1
a349 1
  return BUILD_THREAD (ti.ti_tid, GET_PID (ptid));
d355 2
a356 3
  td_thrinfo_t ti;
  td_thrhandle_t th;
  td_err_e err;
d361 2
a362 9
  err = td_ta_map_id2thr_p (thread_agent, GET_THREAD (ptid), &th);
  if (err != TD_OK)
    error ("Cannot find thread %ld: %s",
	   (long) GET_THREAD (ptid), thread_db_err_str (err));

  err = td_thr_get_info_p (&th, &ti);
  if (err != TD_OK)
    error ("lwp_from_thread: cannot get thread info: %s", 
	   thread_db_err_str (err));
d364 1
a364 1
  return BUILD_LWP (ti.ti_lid, GET_PID (ptid));
a668 3
  if (verbose)
    printf_unfiltered ("[New %s]\n", target_pid_to_str (ptid));

d672 4
a675 1
  tp->private->lwpid = ti_p->ti_lid;
d732 13
d755 3
d891 1
a891 1
  td_thrhandle_t th;
d903 2
a904 4
  err = td_ta_map_id2thr_p (thread_agent, GET_THREAD (inferior_ptid), &th);
  if (err != TD_OK)
    error ("Cannot find thread %ld: %s",
	   (long) GET_THREAD (inferior_ptid), thread_db_err_str (err));
d906 1
a906 1
  err = td_thr_getgregs_p (&th, gregset);
d911 1
a911 1
  err = td_thr_getfpregs_p (&th, &fpregset);
a925 1
  td_thrhandle_t th;
d929 1
d938 2
a939 4
  err = td_ta_map_id2thr_p (thread_agent, GET_THREAD (inferior_ptid), &th);
  if (err != TD_OK)
    error ("Cannot find thread %ld: %s",
	   (long) GET_THREAD (inferior_ptid), thread_db_err_str (err));
d953 1
a953 1
  err = td_thr_setgregs_p (&th, gregset);
d957 1
a957 1
  err = td_thr_setfpregs_p (&th, &fpregset);
a1014 1
  td_thrinfo_t ti;
d1019 5
a1023 2
      err = td_ta_map_id2thr_p (thread_agent, GET_THREAD (ptid), &th);
      if (err != TD_OK)
d1026 1
a1026 1
      err = td_thr_validate_p (&th);
d1030 7
a1036 3
      err = td_thr_get_info_p (&th, &ti);
      if (err != TD_OK)
	return 0;
d1038 2
a1039 1
      if (ti.ti_state == TD_THR_UNKNOWN || ti.ti_state == TD_THR_ZOMBIE)
d1093 1
a1093 2
      td_thrhandle_t th;
      td_thrinfo_t ti;
d1095 1
d1097 7
a1103 4
      err = td_ta_map_id2thr_p (thread_agent, GET_THREAD (ptid), &th);
      if (err != TD_OK)
	error ("Cannot find thread %ld: %s",
	       (long) GET_THREAD (ptid), thread_db_err_str (err));
d1105 1
a1105 4
      err = td_thr_get_info_p (&th, &ti);
      if (err != TD_OK)
	error ("thread_db_pid_to_str: cannot get thread info for %ld: %s",
	       (long) GET_THREAD (ptid), thread_db_err_str (err));
d1107 1
a1107 1
      if (ti.ti_state == TD_THR_ACTIVE && ti.ti_lid != 0)
d1110 1
a1110 1
		    (long) ti.ti_tid, ti.ti_lid);
d1115 1
a1115 1
		    (long) ti.ti_tid, thread_db_state_str (ti.ti_state));
a1137 1
      td_thrhandle_t th;
d1140 1
d1161 3
a1163 5
      err = td_ta_map_id2thr_p (thread_agent, GET_THREAD (ptid), &th);
      if (err != TD_OK)
	error ("Cannot find thread %ld: %s",
	       (long) GET_THREAD (ptid), thread_db_err_str (err));
      
d1165 2
a1166 1
      err = td_thr_tls_get_addr_p (&th, (void *) lm, offset, &address);
@


1.25
log
@2002-11-22  Michael Snyder  <msnyder@@redhat.com>

	* thread-db.c (thread_db_load): Tell the user what's going on
	if dlopen fails on libthread_db.
@
text
@d253 2
a254 1
    error ("Cannot get thread info: %s", thread_db_err_str (err));
d276 2
a277 1
    error ("Cannot get thread info: %s", thread_db_err_str (err));
d690 2
a691 1
    error ("Cannot get thread info: %s", thread_db_err_str (err));
d956 2
a957 1
    error ("Cannot get thread info: %s", thread_db_err_str (err));
d1000 1
a1000 1
	error ("Cannot get thread info for thread %ld: %s",
@


1.24
log
@2002-11-11  Elena Zannoni  <ezannoni@@redhat.com>

        * findvar.c (read_var_value): Reenable TLS code.

2002-11-11  Elena Zannoni  <ezannoni@@redhat.com>
            Jim Blandy  <jimb@@redhat.com>

	* gdb_thread_db.h (enum): Add TD_NOTALLOC.
	* target.c (update_current_target): Add
	to_get_thread_local_address.
	* target.h (to_get_thread_local_address): Export.
	(target_get_thread_local_address): Define.
	(target_get_thread_local_address_p): Define.
	* thread-db.c: Include solib-svr4.h.
	(td_thr_tls_get_addr_p): Define.
	(thread_db_load): Get a pointer to td_thr_tls_get_addr.
	(thread_db_get_thread_local_address): New function.
	(init_thread_db_ops): Initialize to_get_thread_local_address.
	* configure.in: Add test for TD_NOTALLOC in thread_db.h.
	* configure: Regenerate.
	* config.in: Regenerate.
@
text
@d295 7
a301 1
    return 0;
@


1.23
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@d35 1
d112 5
d357 1
d1013 91
d1126 2
@


1.22
log
@* defs.h (error): Add printf format attribute.
* thread-db.c (thread_from_lwp): Fix error format string.
* stack.c (parse_frame_specification): Ditto.
* cli/cli-decode.c (undef_cmd_error): Ditto.
* scm-lang.c (scm_lookup_name): Ditto.
* tracepoint.c (trace_error): Ditto.
* remote-utils.c (usage): Ditto.
* remote.c (compare_sections_command): Ditto.
Fix PR gdb/328.
@
text
@d832 1
a832 1
      read_register_gen (regno, raw);
@


1.22.16.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 2

   Copyright 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
a34 1
#include "solib-svr4.h"
d55 1
a55 1
static void (*target_new_objfile_chain) (struct objfile * objfile);
d81 1
a81 2
static td_err_e (*td_ta_new_p) (struct ps_prochandle * ps,
				td_thragent_t **ta);
d84 2
a85 2
static td_err_e (*td_ta_map_lwp2thr_p) (const td_thragent_t *ta,
					lwpid_t lwpid, td_thrhandle_t *th);
d87 3
a89 3
				     td_thr_iter_f *callback, void *cbdata_p,
				     td_thr_state_e state, int ti_pri,
				     sigset_t *ti_sigmask_p,
d109 1
a109 6
static td_err_e (*td_thr_event_enable_p) (const td_thrhandle_t *th,
					  int event);

static td_err_e (*td_thr_tls_get_addr_p) (const td_thrhandle_t *th,
					  void *map_address,
					  size_t offset, void **address);
a122 2
static void attach_thread (ptid_t ptid, const td_thrhandle_t *th_p,
			   const td_thrinfo_t *ti_p, int verbose);
a137 3
/* Use "struct private_thread_info" to cache thread state.  This is
   a substantial optimization.  */

d140 2
a141 6
  /* Cached thread state.  */
  unsigned int th_valid:1;
  unsigned int ti_valid:1;

  td_thrhandle_t th;
  td_thrinfo_t ti;
a224 70
/* A callback function for td_ta_thr_iter, which we use to map all
   threads to LWPs.

   THP is a handle to the current thread; if INFOP is not NULL, the
   struct thread_info associated with this thread is returned in
   *INFOP.  */

static int
thread_get_info_callback (const td_thrhandle_t *thp, void *infop)
{
  td_thrinfo_t ti;
  td_err_e err;
  struct thread_info *thread_info;
  ptid_t thread_ptid;

  err = td_thr_get_info_p (thp, &ti);
  if (err != TD_OK)
    error ("thread_get_info_callback: cannot get thread info: %s",
	   thread_db_err_str (err));

  /* Fill the cache.  */
  thread_ptid = BUILD_THREAD (ti.ti_tid, GET_PID (inferior_ptid));
  thread_info = find_thread_pid (thread_ptid);

  if (thread_info == NULL)
    {
      /* New thread.  Attach to it now (why wait?).  */
      attach_thread (thread_ptid, thp, &ti, 1);
      thread_info = find_thread_pid (thread_ptid);
      gdb_assert (thread_info != NULL);
    }

  memcpy (&thread_info->private->th, thp, sizeof (*thp));
  thread_info->private->th_valid = 1;
  memcpy (&thread_info->private->ti, &ti, sizeof (ti));
  thread_info->private->ti_valid = 1;

  if (infop != NULL)
    *(struct thread_info **) infop = thread_info;

  return 0;
}

/* Accessor functions for the thread_db information, with caching.  */

static void
thread_db_map_id2thr (struct thread_info *thread_info, int fatal)
{
  td_err_e err;

  if (thread_info->private->th_valid)
    return;

  err = td_ta_map_id2thr_p (thread_agent, GET_THREAD (thread_info->ptid),
			    &thread_info->private->th);
  if (err != TD_OK)
    {
      if (fatal)
	error ("Cannot find thread %ld: %s",
	       (long) GET_THREAD (thread_info->ptid),
	       thread_db_err_str (err));
    }
  else
    thread_info->private->th_valid = 1;
}

static td_thrinfo_t *
thread_db_get_info (struct thread_info *thread_info)
{
  td_err_e err;
a225 16
  if (thread_info->private->ti_valid)
    return &thread_info->private->ti;

  if (!thread_info->private->th_valid)
    thread_db_map_id2thr (thread_info, 1);

  err =
    td_thr_get_info_p (&thread_info->private->th, &thread_info->private->ti);
  if (err != TD_OK)
    error ("thread_db_get_info: cannot get thread info: %s",
	   thread_db_err_str (err));

  thread_info->private->ti_valid = 1;
  return &thread_info->private->ti;
}

d231 1
a233 2
  struct thread_info *thread_info;
  ptid_t thread_ptid;
d245 3
a247 3
  thread_info = NULL;
  thread_get_info_callback (&th, &thread_info);
  gdb_assert (thread_info && thread_info->private->ti_valid);
d249 1
a249 1
  return BUILD_THREAD (thread_info->private->ti.ti_tid, GET_PID (ptid));
d255 3
a257 2
  struct thread_info *thread_info;
  ptid_t thread_ptid;
d262 4
a265 2
  thread_info = find_thread_pid (ptid);
  thread_db_get_info (thread_info);
d267 5
a271 1
  return BUILD_LWP (thread_info->private->ti.ti_lid, GET_PID (ptid));
a280 9
static void *
verbose_dlsym (void *handle, const char *name)
{
  void *sym = dlsym (handle, name);
  if (sym == NULL)
    warning ("Symbol \"%s\" not found in libthread_db: %s", name, dlerror ());
  return sym;
}

d289 1
a289 7
    {
      fprintf_filtered (gdb_stderr, "\n\ndlopen failed on '%s' - %s\n",
			LIBTHREAD_DB_SO, dlerror ());
      fprintf_filtered (gdb_stderr,
			"GDB will not be able to debug pthreads.\n\n");
      return 0;
    }
d294 1
a294 1
  td_init_p = verbose_dlsym (handle, "td_init");
d298 1
a298 1
  td_ta_new_p = verbose_dlsym (handle, "td_ta_new");
d302 1
a302 1
  td_ta_map_id2thr_p = verbose_dlsym (handle, "td_ta_map_id2thr");
d306 1
a306 1
  td_ta_map_lwp2thr_p = verbose_dlsym (handle, "td_ta_map_lwp2thr");
d310 1
a310 1
  td_ta_thr_iter_p = verbose_dlsym (handle, "td_ta_thr_iter");
d314 1
a314 1
  td_thr_validate_p = verbose_dlsym (handle, "td_thr_validate");
d318 1
a318 1
  td_thr_get_info_p = verbose_dlsym (handle, "td_thr_get_info");
d322 1
a322 1
  td_thr_getfpregs_p = verbose_dlsym (handle, "td_thr_getfpregs");
d326 1
a326 1
  td_thr_getgregs_p = verbose_dlsym (handle, "td_thr_getgregs");
d330 1
a330 1
  td_thr_setfpregs_p = verbose_dlsym (handle, "td_thr_setfpregs");
d334 1
a334 1
  td_thr_setgregs_p = verbose_dlsym (handle, "td_thr_setgregs");
a350 1
  td_thr_tls_get_addr_p = dlsym (handle, "td_thr_tls_get_addr");
a354 20
static td_err_e
enable_thread_event (td_thragent_t *thread_agent, int event, CORE_ADDR *bp)
{
  td_notify_t notify;
  td_err_e err;

  /* Get the breakpoint address for thread EVENT.  */
  err = td_ta_event_addr_p (thread_agent, event, &notify);
  if (err != TD_OK)
    return err;

  /* Set up the breakpoint.  */
  (*bp) = gdbarch_convert_from_func_ptr_addr (current_gdbarch,
					      (CORE_ADDR) notify.u.bptaddr,
					      &current_target);
  create_thread_event_breakpoint ((*bp));

  return TD_OK;
}

a387 2
  td_create_bp_addr = 0;
  td_death_bp_addr = 0;
d389 2
a390 2
  /* Set up the thread creation event.  */
  err = enable_thread_event (thread_agent, TD_CREATE, &td_create_bp_addr);
d398 6
a403 2
  /* Set up the thread death event.  */
  err = enable_thread_event (thread_agent, TD_DEATH, &td_death_bp_addr);
d410 4
a485 24
  /* First time through, report that libthread_db was successfuly
     loaded.  Can't print this in in thread_db_load as, at that stage,
     the interpreter and it's console haven't started.  The real
     problem here is that libthread_db is loaded too early - it should
     only be loaded when there is a program to debug.  */
  {
    static int dejavu;
    if (!dejavu)
      {
	Dl_info info;
	const char *library = NULL;
	/* Try dladdr.  */
	if (dladdr ((*td_ta_new_p), &info) != 0)
	  library = info.dli_fname;
	/* Try dlinfo?  */
	if (library == NULL)
	  /* Paranoid - don't let a NULL path slip through.  */
	  library = LIBTHREAD_DB_SO;
	printf_unfiltered ("Using host libthread_db library \"%s\".\n",
			   library);
	dejavu = 1;
      }
  }

a522 2
      printf_unfiltered ("[Thread debugging using libthread_db enabled]\n");

d555 1
a555 1
quit:
d569 3
d575 1
a575 4
  memset (tp->private, 0, sizeof (struct private_thread_info));

  if (verbose)
    printf_unfiltered ("[New %s]\n", target_pid_to_str (ptid));
d606 1
a606 1
  thread_db_find_new_threads ();
a631 13
static int
clear_lwpid_callback (struct thread_info *thread, void *dummy)
{
  /* If we know that our thread implementation is 1-to-1, we could save
     a certain amount of information; it's not clear how much, so we
     are always conservative.  */

  thread->private->th_valid = 0;
  thread->private->ti_valid = 0;

  return 0;
}

a641 3
  /* Clear cached data which may not be valid after the resume.  */
  iterate_over_threads (clear_lwpid_callback, NULL);

a657 1
  int loop = 0;
d664 2
a665 17
  /* If we are at a create breakpoint, we do not know what new lwp
     was created and cannot specifically locate the event message for it.
     We have to call td_ta_event_getmsg() to get
     the latest message.  Since we have no way of correlating whether
     the event message we get back corresponds to our breakpoint, we must
     loop and read all event messages, processing them appropriately.
     This guarantees we will process the correct message before continuing
     from the breakpoint.

     Currently, death events are not enabled.  If they are enabled,
     the death event can use the td_thr_event_getmsg() interface to
     get the message specifically for that lwp and avoid looping
     below.  */

  loop = 1;

  do
d667 2
a668 5
      err = td_ta_event_getmsg_p (thread_agent, &msg);
      if (err != TD_OK)
	{
	  if (err == TD_NOMSG)
	    return;
d670 2
a671 3
	  error ("Cannot get thread event message: %s",
		 thread_db_err_str (err));
	}
d673 3
a675 3
      err = td_thr_get_info_p (msg.th_p, &ti);
      if (err != TD_OK)
	error ("Cannot get thread info: %s", thread_db_err_str (err));
d677 1
a677 1
      ptid = BUILD_THREAD (ti.ti_tid, GET_PID (ptid));
d679 7
a685 3
      switch (msg.event)
	{
	case TD_CREATE:
d687 3
a689 5
	  /* We may already know about this thread, for instance when the
	     user has issued the `info threads' command before the SIGTRAP
	     for hitting the thread creation breakpoint was reported.  */
	  if (!in_thread_list (ptid))
	    attach_thread (ptid, msg.th_p, &ti, 1);
d691 6
a696 1
	  break;
d698 3
a700 1
	case TD_DEATH:
d702 3
a704 2
	  if (!in_thread_list (ptid))
	    error ("Spurious thread death event.");
d706 2
a707 1
	  detach_thread (ptid, 1);
d709 2
a710 1
	  break;
d712 2
a713 3
	default:
	  error ("Spurious thread event.");
	}
a714 1
  while (loop);
d749 2
a750 1
		       struct mem_attrib *attrib, struct target_ops *target)
d765 1
a765 3
  xfer =
    target_beneath->to_xfer_memory (memaddr, myaddr, len, write, attrib,
				    target);
d774 1
a774 1
  struct thread_info *thread_info;
d786 4
a789 2
  thread_info = find_thread_pid (inferior_ptid);
  thread_db_map_id2thr (thread_info, 1);
d791 1
a791 1
  err = td_thr_getgregs_p (&thread_info->private->th, gregset);
d796 1
a796 1
  err = td_thr_getfpregs_p (&thread_info->private->th, &fpregset);
d811 1
a814 1
  struct thread_info *thread_info;
d823 4
a826 2
  thread_info = find_thread_pid (inferior_ptid);
  thread_db_map_id2thr (thread_info, 1);
d830 1
a830 1
      char raw[MAX_REGISTER_SIZE];
d832 1
a832 1
      deprecated_read_register_gen (regno, raw);
d840 1
a840 1
  err = td_thr_setgregs_p (&thread_info->private->th, gregset);
d844 1
a844 1
  err = td_thr_setfpregs_p (&thread_info->private->th, &fpregset);
a895 12

  /* Detach thread_db target ops if not dealing with a statically
     linked threaded program.  This allows a corefile to be debugged
     after finishing debugging of a threaded program.  At present,
     debugging a statically-linked threaded program is broken, but
     the check is added below in the event that it is fixed in the
     future.  */
  if (!keep_thread_db)
    {
      unpush_target (&thread_db_ops);
      using_thread_db = 0;
    }
d902 1
d907 3
a909 2
      struct thread_info *thread_info;
      thread_info = find_thread_pid (ptid);
d911 2
a912 2
      thread_db_map_id2thr (thread_info, 0);
      if (!thread_info->private->th_valid)
d915 1
a915 1
      err = td_thr_validate_p (&thread_info->private->th);
d919 1
a919 12
      if (!thread_info->private->ti_valid)
	{
	  err =
	    td_thr_get_info_p (&thread_info->private->th,
			       &thread_info->private->ti);
	  if (err != TD_OK)
	    return 0;
	  thread_info->private->ti_valid = 1;
	}

      if (thread_info->private->ti.ti_state == TD_THR_UNKNOWN
	  || thread_info->private->ti.ti_state == TD_THR_ZOMBIE)
d940 1
a940 2
    error ("find_new_threads_callback: cannot get thread info: %s",
	   thread_db_err_str (err));
d972 2
a973 1
      td_thrinfo_t *ti_p;
a974 1
      struct thread_info *thread_info;
d976 4
a979 8
      thread_info = find_thread_pid (ptid);
      thread_db_map_id2thr (thread_info, 0);
      if (!thread_info->private->th_valid)
	{
	  snprintf (buf, sizeof (buf), "Thread %ld (Missing)",
		    GET_THREAD (ptid));
	  return buf;
	}
d981 4
a984 1
      ti_p = thread_db_get_info (thread_info);
d986 1
a986 1
      if (ti_p->ti_state == TD_THR_ACTIVE && ti_p->ti_lid != 0)
d989 1
a989 1
		    (long) ti_p->ti_tid, ti_p->ti_lid);
d994 1
a994 2
		    (long) ti_p->ti_tid,
		    thread_db_state_str (ti_p->ti_state));
a1005 89
/* Get the address of the thread local variable in OBJFILE which is
   stored at OFFSET within the thread local storage for thread PTID.  */

static CORE_ADDR
thread_db_get_thread_local_address (ptid_t ptid, struct objfile *objfile,
				    CORE_ADDR offset)
{
  if (is_thread (ptid))
    {
      int objfile_is_library = (objfile->flags & OBJF_SHARED);
      td_err_e err;
      void *address;
      CORE_ADDR lm;
      struct thread_info *thread_info;

      /* glibc doesn't provide the needed interface.  */
      if (!td_thr_tls_get_addr_p)
	error ("Cannot find thread-local variables in this thread library.");

      /* Get the address of the link map for this objfile.  */
      lm = svr4_fetch_objfile_link_map (objfile);

      /* Whoops, we couldn't find one. Bail out.  */
      if (!lm)
	{
	  if (objfile_is_library)
	    error ("Cannot find shared library `%s' link_map in dynamic"
		   " linker's module list", objfile->name);
	  else
	    error ("Cannot find executable file `%s' link_map in dynamic"
		   " linker's module list", objfile->name);
	}

      /* Get info about the thread.  */
      thread_info = find_thread_pid (ptid);
      thread_db_map_id2thr (thread_info, 1);

      /* Finally, get the address of the variable.  */
      err = td_thr_tls_get_addr_p (&thread_info->private->th, (void *) lm,
				   offset, &address);

#ifdef THREAD_DB_HAS_TD_NOTALLOC
      /* The memory hasn't been allocated, yet.  */
      if (err == TD_NOTALLOC)
	{
	  /* Now, if libthread_db provided the initialization image's
	     address, we *could* try to build a non-lvalue value from
	     the initialization image.  */
	  if (objfile_is_library)
	    error ("The inferior has not yet allocated storage for"
		   " thread-local variables in\n"
		   "the shared library `%s'\n"
		   "for the thread %ld",
		   objfile->name, (long) GET_THREAD (ptid));
	  else
	    error ("The inferior has not yet allocated storage for"
		   " thread-local variables in\n"
		   "the executable `%s'\n"
		   "for the thread %ld",
		   objfile->name, (long) GET_THREAD (ptid));
	}
#endif

      /* Something else went wrong.  */
      if (err != TD_OK)
	{
	  if (objfile_is_library)
	    error ("Cannot find thread-local storage for thread %ld, "
		   "shared library %s:\n%s",
		   (long) GET_THREAD (ptid),
		   objfile->name, thread_db_err_str (err));
	  else
	    error ("Cannot find thread-local storage for thread %ld, "
		   "executable file %s:\n%s",
		   (long) GET_THREAD (ptid),
		   objfile->name, thread_db_err_str (err));
	}

      /* Cast assuming host == target.  Joy.  */
      return (CORE_ADDR) address;
    }

  if (target_beneath->to_get_thread_local_address)
    return target_beneath->to_get_thread_local_address (ptid, objfile,
							offset);

  error ("Cannot find thread-local values on this target.");
}

a1027 2
  thread_db_ops.to_get_thread_local_address
    = thread_db_get_thread_local_address;
@


1.22.14.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a34 1
#include "solib-svr4.h"
a110 5
static td_err_e (*td_thr_tls_get_addr_p) (const td_thrhandle_t *th,
                                          void *map_address,
                                          size_t offset,
                                          void **address);

a350 1
  td_thr_tls_get_addr_p = dlsym (handle, "td_thr_tls_get_addr");
d832 1
a832 1
      deprecated_read_register_gen (regno, raw);
a1005 91
/* Get the address of the thread local variable in OBJFILE which is
   stored at OFFSET within the thread local storage for thread PTID.  */

static CORE_ADDR
thread_db_get_thread_local_address (ptid_t ptid, struct objfile *objfile,
                                    CORE_ADDR offset)
{
  if (is_thread (ptid))
    {
      int objfile_is_library = (objfile->flags & OBJF_SHARED);
      td_err_e err;
      td_thrhandle_t th;
      void *address;
      CORE_ADDR lm;

      /* glibc doesn't provide the needed interface.  */
      if (! td_thr_tls_get_addr_p)
        error ("Cannot find thread-local variables in this thread library.");

      /* Get the address of the link map for this objfile.  */
      lm = svr4_fetch_objfile_link_map (objfile);

      /* Whoops, we couldn't find one. Bail out.  */
      if (!lm)
        {
          if (objfile_is_library)
            error ("Cannot find shared library `%s' link_map in dynamic"
		   " linker's module list", objfile->name);
	  else
            error ("Cannot find executable file `%s' link_map in dynamic"
		   " linker's module list", objfile->name);
	}

      /* Get info about the thread.  */
      err = td_ta_map_id2thr_p (thread_agent, GET_THREAD (ptid), &th);
      if (err != TD_OK)
	error ("Cannot find thread %ld: %s",
	       (long) GET_THREAD (ptid), thread_db_err_str (err));
      
      /* Finally, get the address of the variable.  */
      err = td_thr_tls_get_addr_p (&th, (void *) lm, offset, &address);

#ifdef THREAD_DB_HAS_TD_NOTALLOC
      /* The memory hasn't been allocated, yet.  */
      if (err == TD_NOTALLOC)
        {
          /* Now, if libthread_db provided the initialization image's
             address, we *could* try to build a non-lvalue value from
             the initialization image.  */
          if (objfile_is_library)
            error ("The inferior has not yet allocated storage for"
                   " thread-local variables in\n"
                   "the shared library `%s'\n"
                   "for the thread %ld",
		   objfile->name, (long) GET_THREAD (ptid));
          else
            error ("The inferior has not yet allocated storage for"
                   " thread-local variables in\n"
                   "the executable `%s'\n"
                   "for the thread %ld",
		   objfile->name, (long) GET_THREAD (ptid));
	}
#endif

      /* Something else went wrong.  */
      if (err != TD_OK)
	{
	  if (objfile_is_library)
	    error ("Cannot find thread-local storage for thread %ld, "
		   "shared library %s:\n%s",
		   (long) GET_THREAD (ptid),
		   objfile->name,
		   thread_db_err_str (err));
	  else
	    error ("Cannot find thread-local storage for thread %ld, "
		   "executable file %s:\n%s",
		   (long) GET_THREAD (ptid),
		   objfile->name,
		   thread_db_err_str (err));
	}

      /* Cast assuming host == target.  Joy.  */
      return (CORE_ADDR) address;
    }

  if (target_beneath->to_get_thread_local_address)
    return target_beneath->to_get_thread_local_address (ptid, objfile, offset);

  error ("Cannot find thread-local values on this target.");
}

a1027 2
  thread_db_ops.to_get_thread_local_address
    = thread_db_get_thread_local_address;
@


1.22.14.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d253 1
a253 2
    error ("thread_from_lwp: cannot get thread info: %s", 
	   thread_db_err_str (err));
d275 1
a275 2
    error ("lwp_from_thread: cannot get thread info: %s", 
	   thread_db_err_str (err));
d295 1
a295 7
    {
      fprintf_filtered (gdb_stderr, "\n\ndlopen failed on '%s' - %s\n", 
			LIBTHREAD_DB_SO, dlerror ());
      fprintf_filtered (gdb_stderr, 
			"GDB will not be able to debug pthreads.\n\n");
      return 0;
    }
d682 1
a682 2
    error ("check_event: cannot get thread info: %s", 
	   thread_db_err_str (err));
d947 1
a947 2
    error ("find_new_threads_callback: cannot get thread info: %s", 
	   thread_db_err_str (err));
d990 1
a990 1
	error ("thread_db_pid_to_str: cannot get thread info for %ld: %s",
@


1.22.14.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 2

   Copyright 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
a128 2
static void attach_thread (ptid_t ptid, const td_thrhandle_t *th_p,
			   const td_thrinfo_t *ti_p, int verbose);
a143 3
/* Use "struct private_thread_info" to cache thread state.  This is
   a substantial optimization.  */

d146 2
a147 6
  /* Cached thread state.  */
  unsigned int th_valid : 1;
  unsigned int ti_valid : 1;

  td_thrhandle_t th;
  td_thrinfo_t ti;
a230 42
/* A callback function for td_ta_thr_iter, which we use to map all
   threads to LWPs.  

   THP is a handle to the current thread; if INFOP is not NULL, the
   struct thread_info associated with this thread is returned in
   *INFOP.  */

static int
thread_get_info_callback (const td_thrhandle_t *thp, void *infop)
{
  td_thrinfo_t ti;
  td_err_e err;
  struct thread_info *thread_info;
  ptid_t thread_ptid;

  err = td_thr_get_info_p (thp, &ti);
  if (err != TD_OK)
    error ("thread_get_info_callback: cannot get thread info: %s", 
	   thread_db_err_str (err));

  /* Fill the cache.  */
  thread_ptid = BUILD_THREAD (ti.ti_tid, GET_PID (inferior_ptid));
  thread_info = find_thread_pid (thread_ptid);

  if (thread_info == NULL)
    {
      /* New thread.  Attach to it now (why wait?).  */
      attach_thread (thread_ptid, thp, &ti, 1);
      thread_info = find_thread_pid (thread_ptid);
      gdb_assert (thread_info != NULL);
    }

  memcpy (&thread_info->private->th, thp, sizeof (*thp));
  thread_info->private->th_valid = 1;
  memcpy (&thread_info->private->ti, &ti, sizeof (ti));
  thread_info->private->ti_valid = 1;

  if (infop != NULL)
    *(struct thread_info **) infop = thread_info;

  return 0;
}
a231 42
/* Accessor functions for the thread_db information, with caching.  */

static void
thread_db_map_id2thr (struct thread_info *thread_info, int fatal)
{
  td_err_e err;

  if (thread_info->private->th_valid)
    return;

  err = td_ta_map_id2thr_p (thread_agent, GET_THREAD (thread_info->ptid),
			    &thread_info->private->th);
  if (err != TD_OK)
    {
      if (fatal)
	error ("Cannot find thread %ld: %s",
	       (long) GET_THREAD (thread_info->ptid), thread_db_err_str (err));
    }
  else
    thread_info->private->th_valid = 1;
}

static td_thrinfo_t *
thread_db_get_info (struct thread_info *thread_info)
{
  td_err_e err;

  if (thread_info->private->ti_valid)
    return &thread_info->private->ti;

  if (! thread_info->private->th_valid)
    thread_db_map_id2thr (thread_info, 1);

  err = td_thr_get_info_p (&thread_info->private->th, &thread_info->private->ti);
  if (err != TD_OK)
    error ("thread_db_get_info: cannot get thread info: %s", 
	   thread_db_err_str (err));

  thread_info->private->ti_valid = 1;
  return &thread_info->private->ti;
}

d237 1
a239 2
  struct thread_info *thread_info;
  ptid_t thread_ptid;
d251 4
a254 3
  thread_info = NULL;
  thread_get_info_callback (&th, &thread_info);
  gdb_assert (thread_info && thread_info->private->ti_valid);
d256 1
a256 1
  return BUILD_THREAD (thread_info->private->ti.ti_tid, GET_PID (ptid));
d262 3
a264 2
  struct thread_info *thread_info;
  ptid_t thread_ptid;
d269 9
a277 2
  thread_info = find_thread_pid (ptid);
  thread_db_get_info (thread_info);
d279 1
a279 1
  return BUILD_LWP (thread_info->private->ti.ti_lid, GET_PID (ptid));
d584 3
d590 1
a590 4
  memset (tp->private, 0, sizeof (struct private_thread_info));

  if (verbose)
    printf_unfiltered ("[New %s]\n", target_pid_to_str (ptid));
a646 13
static int
clear_lwpid_callback (struct thread_info *thread, void *dummy)
{
  /* If we know that our thread implementation is 1-to-1, we could save
     a certain amount of information; it's not clear how much, so we
     are always conservative.  */

  thread->private->th_valid = 0;
  thread->private->ti_valid = 0;

  return 0;
}

a656 3
  /* Clear cached data which may not be valid after the resume.  */
  iterate_over_threads (clear_lwpid_callback, NULL);

d790 1
a790 1
  struct thread_info *thread_info;
d802 4
a805 2
  thread_info = find_thread_pid (inferior_ptid);
  thread_db_map_id2thr (thread_info, 1);
d807 1
a807 1
  err = td_thr_getgregs_p (&thread_info->private->th, gregset);
d812 1
a812 1
  err = td_thr_getfpregs_p (&thread_info->private->th, &fpregset);
d827 1
a830 1
  struct thread_info *thread_info;
d839 4
a842 2
  thread_info = find_thread_pid (inferior_ptid);
  thread_db_map_id2thr (thread_info, 1);
d846 1
a846 1
      char *raw = alloca (max_register_size (current_gdbarch));
d856 1
a856 1
  err = td_thr_setgregs_p (&thread_info->private->th, gregset);
d860 1
a860 1
  err = td_thr_setfpregs_p (&thread_info->private->th, &fpregset);
d918 1
d923 3
a925 2
      struct thread_info *thread_info;
      thread_info = find_thread_pid (ptid);
d927 2
a928 2
      thread_db_map_id2thr (thread_info, 0);
      if (! thread_info->private->th_valid)
d931 1
a931 1
      err = td_thr_validate_p (&thread_info->private->th);
d935 1
a935 10
      if (! thread_info->private->ti_valid)
	{
	  err = td_thr_get_info_p (&thread_info->private->th, &thread_info->private->ti);
	  if (err != TD_OK)
	    return 0;
	  thread_info->private->ti_valid = 1;
	}

      if (thread_info->private->ti.ti_state == TD_THR_UNKNOWN
	  || thread_info->private->ti.ti_state == TD_THR_ZOMBIE)
d989 2
a990 1
      td_thrinfo_t *ti_p;
a991 1
      struct thread_info *thread_info;
d993 4
a996 7
      thread_info = find_thread_pid (ptid);
      thread_db_map_id2thr (thread_info, 0);
      if (! thread_info->private->th_valid)
	{
	  snprintf (buf, sizeof (buf), "Thread %ld (Missing)", GET_THREAD (ptid));
	  return buf;
	}
d998 4
a1001 1
      ti_p = thread_db_get_info (thread_info);
d1003 1
a1003 1
      if (ti_p->ti_state == TD_THR_ACTIVE && ti_p->ti_lid != 0)
d1006 1
a1006 1
		    (long) ti_p->ti_tid, ti_p->ti_lid);
d1011 1
a1011 1
		    (long) ti_p->ti_tid, thread_db_state_str (ti_p->ti_state));
d1034 1
a1036 1
      struct thread_info *thread_info;
d1057 5
a1061 3
      thread_info = find_thread_pid (ptid);
      thread_db_map_id2thr (thread_info, 1);

d1063 1
a1063 2
      err = td_thr_tls_get_addr_p (&thread_info->private->th, (void *) lm,
				   offset, &address);
@


1.22.14.4
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d57 1
a57 1
static void (*target_new_objfile_chain) (struct objfile * objfile);
d83 1
a83 2
static td_err_e (*td_ta_new_p) (struct ps_prochandle * ps,
				td_thragent_t **ta);
d86 2
a87 2
static td_err_e (*td_ta_map_lwp2thr_p) (const td_thragent_t *ta,
					lwpid_t lwpid, td_thrhandle_t *th);
d89 3
a91 3
				     td_thr_iter_f *callback, void *cbdata_p,
				     td_thr_state_e state, int ti_pri,
				     sigset_t *ti_sigmask_p,
d111 1
a111 2
static td_err_e (*td_thr_event_enable_p) (const td_thrhandle_t *th,
					  int event);
d114 3
a116 2
					  void *map_address,
					  size_t offset, void **address);
d153 2
a154 2
  unsigned int th_valid:1;
  unsigned int ti_valid:1;
d258 1
a258 1
    error ("thread_get_info_callback: cannot get thread info: %s",
d300 1
a300 2
	       (long) GET_THREAD (thread_info->ptid),
	       thread_db_err_str (err));
d314 1
a314 1
  if (!thread_info->private->th_valid)
d317 1
a317 2
  err =
    td_thr_get_info_p (&thread_info->private->th, &thread_info->private->ti);
d319 1
a319 1
    error ("thread_db_get_info: cannot get thread info: %s",
d384 1
a384 1
      fprintf_filtered (gdb_stderr, "\n\ndlopen failed on '%s' - %s\n",
d386 1
a386 1
      fprintf_filtered (gdb_stderr,
d656 1
a656 1
quit:
d707 1
a707 1
  thread_db_find_new_threads ();
d792 1
a792 1
    error ("check_event: cannot get thread info: %s",
d867 2
a868 1
		       struct mem_attrib *attrib, struct target_ops *target)
d883 1
a883 3
  xfer =
    target_beneath->to_xfer_memory (memaddr, myaddr, len, write, attrib,
				    target);
d1024 1
a1024 1
      if (!thread_info->private->th_valid)
d1031 1
a1031 1
      if (!thread_info->private->ti_valid)
d1033 1
a1033 3
	  err =
	    td_thr_get_info_p (&thread_info->private->th,
			       &thread_info->private->ti);
d1061 1
a1061 1
    error ("find_new_threads_callback: cannot get thread info: %s",
d1100 1
a1100 1
      if (!thread_info->private->th_valid)
d1102 1
a1102 2
	  snprintf (buf, sizeof (buf), "Thread %ld (Missing)",
		    GET_THREAD (ptid));
d1116 1
a1116 2
		    (long) ti_p->ti_tid,
		    thread_db_state_str (ti_p->ti_state));
d1133 1
a1133 1
				    CORE_ADDR offset)
d1144 2
a1145 2
      if (!td_thr_tls_get_addr_p)
	error ("Cannot find thread-local variables in this thread library.");
d1152 3
a1154 3
	{
	  if (objfile_is_library)
	    error ("Cannot find shared library `%s' link_map in dynamic"
d1157 1
a1157 1
	    error ("Cannot find executable file `%s' link_map in dynamic"
d1172 9
a1180 9
	{
	  /* Now, if libthread_db provided the initialization image's
	     address, we *could* try to build a non-lvalue value from
	     the initialization image.  */
	  if (objfile_is_library)
	    error ("The inferior has not yet allocated storage for"
		   " thread-local variables in\n"
		   "the shared library `%s'\n"
		   "for the thread %ld",
d1182 5
a1186 5
	  else
	    error ("The inferior has not yet allocated storage for"
		   " thread-local variables in\n"
		   "the executable `%s'\n"
		   "for the thread %ld",
d1198 2
a1199 1
		   objfile->name, thread_db_err_str (err));
d1204 2
a1205 1
		   objfile->name, thread_db_err_str (err));
d1213 1
a1213 2
    return target_beneath->to_get_thread_local_address (ptid, objfile,
							offset);
@


1.22.14.5
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d948 1
a948 1
      char raw[MAX_REGISTER_SIZE];
@


1.22.14.6
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a777 1
  int loop = 0;
d784 2
a785 17
  /* If we are at a create breakpoint, we do not know what new lwp
     was created and cannot specifically locate the event message for it.
     We have to call td_ta_event_getmsg() to get
     the latest message.  Since we have no way of correlating whether
     the event message we get back corresponds to our breakpoint, we must 
     loop and read all event messages, processing them appropriately.
     This guarantees we will process the correct message before continuing 
     from the breakpoint.  

     Currently, death events are not enabled.  If they are enabled,
     the death event can use the td_thr_event_getmsg() interface to
     get the message specifically for that lwp and avoid looping
     below.  */

  loop = 1;

  do
d787 2
a788 5
      err = td_ta_event_getmsg_p (thread_agent, &msg);
      if (err != TD_OK)
	{
	  if (err == TD_NOMSG)
	    return;
d790 2
a791 3
	  error ("Cannot get thread event message: %s",
		 thread_db_err_str (err));
	}
d793 4
a796 3
      err = td_thr_get_info_p (msg.th_p, &ti);
      if (err != TD_OK)
	error ("Cannot get thread info: %s", thread_db_err_str (err));
d798 1
a798 1
      ptid = BUILD_THREAD (ti.ti_tid, GET_PID (ptid));
d800 18
a817 3
      switch (msg.event)
	{
	case TD_CREATE:
d819 7
a825 5
	  /* We may already know about this thread, for instance when the
	     user has issued the `info threads' command before the SIGTRAP
	     for hitting the thread creation breakpoint was reported.  */
	  if (!in_thread_list (ptid))
	    attach_thread (ptid, msg.th_p, &ti, 1);
d827 2
a828 1
	  break;
d830 2
a831 4
	case TD_DEATH:

	  if (!in_thread_list (ptid))
	    error ("Spurious thread death event.");
d833 2
a834 7
	  detach_thread (ptid, 1);

	  break;

	default:
	  error ("Spurious thread event.");
	}
a835 1
  while (loop);
a1013 12

  /* Detach thread_db target ops if not dealing with a statically
     linked threaded program.  This allows a corefile to be debugged
     after finishing debugging of a threaded program.  At present,
     debugging a statically-linked threaded program is broken, but
     the check is added below in the event that it is fixed in the
     future.  */
  if (!keep_thread_db)
    {
      unpush_target (&thread_db_ops);
      using_thread_db = 0;
    }
@


1.22.14.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a377 9
static void *
verbose_dlsym (void *handle, const char *name)
{
  void *sym = dlsym (handle, name);
  if (sym == NULL)
    warning ("Symbol \"%s\" not found in libthread_db: %s", name, dlerror ());
  return sym;
}

d397 1
a397 1
  td_init_p = verbose_dlsym (handle, "td_init");
d401 1
a401 1
  td_ta_new_p = verbose_dlsym (handle, "td_ta_new");
d405 1
a405 1
  td_ta_map_id2thr_p = verbose_dlsym (handle, "td_ta_map_id2thr");
d409 1
a409 1
  td_ta_map_lwp2thr_p = verbose_dlsym (handle, "td_ta_map_lwp2thr");
d413 1
a413 1
  td_ta_thr_iter_p = verbose_dlsym (handle, "td_ta_thr_iter");
d417 1
a417 1
  td_thr_validate_p = verbose_dlsym (handle, "td_thr_validate");
d421 1
a421 1
  td_thr_get_info_p = verbose_dlsym (handle, "td_thr_get_info");
d425 1
a425 1
  td_thr_getfpregs_p = verbose_dlsym (handle, "td_thr_getfpregs");
d429 1
a429 1
  td_thr_getgregs_p = verbose_dlsym (handle, "td_thr_getgregs");
d433 1
a433 1
  td_thr_setfpregs_p = verbose_dlsym (handle, "td_thr_setfpregs");
d437 1
a437 1
  td_thr_setgregs_p = verbose_dlsym (handle, "td_thr_setgregs");
a589 24
  /* First time through, report that libthread_db was successfuly
     loaded.  Can't print this in in thread_db_load as, at that stage,
     the interpreter and it's console haven't started.  The real
     problem here is that libthread_db is loaded too early - it should
     only be loaded when there is a program to debug.  */
  {
    static int dejavu;
    if (!dejavu)
      {
	Dl_info info;
	const char *library = NULL;
	/* Try dladdr.  */
	if (dladdr ((*td_ta_new_p), &info) != 0)
	  library = info.dli_fname;
	/* Try dlinfo?  */
	if (library == NULL)
	  /* Paranoid - don't let a NULL path slip through.  */
	  library = LIBTHREAD_DB_SO;
	printf_unfiltered ("Using host libthread_db library \"%s\".\n",
			   library);
	dejavu = 1;
      }
  }

a626 2
      printf_unfiltered ("[Thread debugging using libthread_db enabled]\n");

@


1.22.14.8
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d243 1
a243 1
   threads to LWPs.
a467 20
static td_err_e
enable_thread_event (td_thragent_t *thread_agent, int event, CORE_ADDR *bp)
{
  td_notify_t notify;
  td_err_e err;

  /* Get the breakpoint address for thread EVENT.  */
  err = td_ta_event_addr_p (thread_agent, event, &notify);
  if (err != TD_OK)
    return err;

  /* Set up the breakpoint.  */
  (*bp) = gdbarch_convert_from_func_ptr_addr (current_gdbarch,
					      (CORE_ADDR) notify.u.bptaddr,
					      &current_target);
  create_thread_event_breakpoint ((*bp));

  return TD_OK;
}

a500 2
  td_create_bp_addr = 0;
  td_death_bp_addr = 0;
d502 2
a503 2
  /* Set up the thread creation event.  */
  err = enable_thread_event (thread_agent, TD_CREATE, &td_create_bp_addr);
d511 6
a516 2
  /* Set up the thread death event.  */
  err = enable_thread_event (thread_agent, TD_DEATH, &td_death_bp_addr);
d523 4
d824 1
a824 1
     the event message we get back corresponds to our breakpoint, we must
d826 2
a827 2
     This guarantees we will process the correct message before continuing
     from the breakpoint.
@


1.22.6.1
log
@merge from mainline
@
text
@d832 1
a832 1
      deprecated_read_register_gen (regno, raw);
@


1.21
log
@* lin-lwp.c, thread-db.c, defs.h, cris-tdep.c: Replace ``Linux''
with either ``GNU/Linux'' or ``Linux kernel''.
Fix PR gdb/378.
@
text
@d242 1
a242 1
    error ("Cannot find user-level thread for LWP %d: %s",
@


1.20
log
@2002-01-07  Michael Snyder  <msnyder@@redhat.com>

	* thread-db.c (thread_db_new_objfile): Indendation fix.
@
text
@d40 2
a41 1
/* If we're running on Linux, we must explicitly attach to any new threads.  */
d580 1
a580 1
  /* Under Linux, we have to attach to each and every thread.  */
@


1.19
log
@2002-01-04  Daniel Jacobowitz  <drow@@mvista.com>

        * thread-db.c (thread_db_new_objfile): Do not enable thread_db
        for core files.
@
text
@d485 3
a487 3
 /* Don't attempt to use thread_db on targets which can not run
    (core files).  */
 if (objfile == NULL || !target_has_execution)
@


1.18
log
@* thread-db.c: Fix a few formatting mistakes.
@
text
@d485 3
a487 1
  if (objfile == NULL)
@


1.17
log
@* thread-db.c (enable_thread_event_reporting): Correct warning
message about getting thread death breakpoint.
Reported by John S Kallal <jskallal@@home.com>.
@
text
@a125 1

a134 1

d142 1
a143 1

d258 1
a258 1
  if (! is_thread (ptid))
d435 1
a435 1
  if (! thread_signals)
d574 2
a575 3
  if (ti_p->ti_state == TD_THR_UNKNOWN ||
      ti_p->ti_state == TD_THR_ZOMBIE)
    return;/* A zombie thread -- do not attach. */
d691 1
a691 1
      if (! in_thread_list (ptid))
d703 1
a703 1
      if (! in_thread_list (ptid))
d756 1
a756 1
      if (! target_thread_alive (inferior_ptid))
d776 1
a776 1
  if (! is_thread (inferior_ptid))
d813 1
a813 1
  if (! is_thread (inferior_ptid))
d859 1
a859 1
  if (! keep_thread_db)
d879 1
a879 1
      thread_db_find_new_threads();
d899 2
a900 2
  td_thrinfo_t   ti;
  td_err_e       err;
d916 2
a917 3
      if (ti.ti_state == TD_THR_UNKNOWN ||
	  ti.ti_state == TD_THR_ZOMBIE)
	return 0;	/* A zombie thread. */
d939 2
a940 4
  if (ti.ti_state == TD_THR_UNKNOWN ||
      ti.ti_state == TD_THR_ZOMBIE)

    return 0;	/* A zombie -- ignore. */
d944 1
a944 1
  if (! in_thread_list (ptid))
@


1.16
log
@2001-07-03  Michael Snyder  <msnyder@@redhat.com>

	* thread_db (find_new_threads_callback, thread_db_thread_alive,
        attach_thread): Update comments.
@
text
@d407 1
a407 1
      warning ("Unable to get location for thread creation breakpoint: %s",
@


1.16.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d844 1
a844 1
  err = td_thr_setfpregs_p (&th, (const gdb_prfpregset_t *)&fpregset);
@


1.15
log
@2001-06-29  Ken Whaley  <ken@@believe.com>

	* thread-db.c (attach_thread): Check for TD_THR_ZOMBIE in addition
	to TD_THR_UNKNOWN when looking for defunct zombie threads.
	(thread_db_thread_alive): Ditto.
	(find_new_threads_callback): Ditto.
@
text
@d578 1
a578 1
    return;/* A zombie thread that's been joined -- do not attach. */
d921 1
a921 1
	return 0;	/* A zombie thread that's been joined. */
d946 1
a946 1
    return 0;	/* A zombie that's been reaped -- ignore. */
@


1.14
log
@2001-05-22  Michael Snyder  <msnyder@@redhat.com>

	* thread-db.c: Allow for defunct zombie threads.
	(attach_thread): Do not attempt to attach zombie thread.
	(thread_db_thread_alive): Return false for defunct zombie thread.
	(find_new_threads_callback): Don't add defunct zombie thread to list.
@
text
@d576 2
a577 1
  if (ti_p->ti_state == TD_THR_UNKNOWN)
d919 2
a920 1
      if (ti.ti_state == TD_THR_UNKNOWN)
d943 3
a945 1
  if (ti.ti_state == TD_THR_UNKNOWN)
@


1.13
log
@Redefine ptid_t to be a struct rather than an int.
@
text
@d576 3
d900 4
a905 3
      td_thrhandle_t th;
      td_err_e err;

d914 7
d940 3
@


1.12
log
@Consolidate save_inferior_ptid/restore_inferior_ptid implementation to
one source file.
@
text
@a125 6
#ifndef TIDGET
#define TIDGET(PID)		(((PID) & 0x7fffffff) >> 16)
#define PIDGET0(PID)		(((PID) & 0xffff))
#define PIDGET(PID)		((PIDGET0 (PID) == 0xffff) ? -1 : PIDGET0 (PID))
#define MERGEPID(PID, TID)	(((PID) & 0xffff) | ((TID) << 16))
#endif
d127 3
a129 1
#define THREAD_FLAG		0x80000000
d131 2
a132 2
#define is_lwp(pid)		(((pid) & THREAD_FLAG) == 0 && TIDGET (pid))
#define is_thread(pid)		((pid) & THREAD_FLAG)
d134 2
a135 3
#define GET_PID(pid)		PIDGET (pid)
#define GET_LWP(pid)		TIDGET (pid)
#define GET_THREAD(pid)		TIDGET (pid)
a136 2
#define BUILD_LWP(tid, pid)	MERGEPID (pid, tid)
#define BUILD_THREAD(tid, pid)	(MERGEPID (pid, tid) | THREAD_FLAG)
@


1.11
log
@Implement attach/detach for multi-threaded programs on Linux.
* thread-db.c (keep_thread_db): Adjust comment.
(deactivate_target): Removed.
(thread_db_new_objfile): Don't call deactivate_target.  Implement
guts of deactivate_target inline instead.
(attach_thread): Call ATTACH_LWP unconditionally if defined.
(thread_db_attach): New function.
(thread_db_detach): Don't call deactivate_target.  Do necessary
cleanup inline instead.  Set inferior_ptid to LWP corresponding to
the current user-level thread.
(thread_db_kill): Set inferior_ptid to LWP corresponding to the
current user-level thread.
(thread_db_create_inferior): Deactivate target vector if
KEEP_THREAD_DB is zero.
(thread_db_mourn_inferior): Don't call deactivate_target.  Do
necessary cleanup inline instead.
(init_thread_db_ops): Initialize to_attach field to
thread_db_attach.
* lin-lwp.c (lin_lwp_mourn_inferior): Remove prototype.
(stop_wait_callback): Add prototype.
(init_lwp_list): Add comment about when to re-initialize the LWP
list.
(lin_lwp_attach_lwp): Only call ptrace for cloned processes.
Avoid adding publicates to the LWP list.  Only mark an LWP as
signalled if it doesn't correspond to a cloned process.
(lin_lwp_attach): Add initial process to the LWP list.  Make sure
it's stopped and fake a SIGSTOP.
(detach_callback): New function.
(lin_lwp_detach): Implement.
(lin_lwp_create_inferior): Don't re-initialize LWP list here.
Call child_ops.to_create_inferior directly instead of via
target_beneath local.
(lin_lwp_mourn_inferior): Call child_ops.to_mourn_inferior
directly instead of via target_beneath local.
@
text
@a152 21
/* Helper functions.  */

static void
restore_inferior_ptid (void *arg)
{
  ptid_t *saved_ptid_ptr = arg;
  inferior_ptid = *saved_ptid_ptr;
  xfree (arg);
}

static struct cleanup *
save_inferior_ptid (void)
{
  ptid_t *saved_ptid_ptr;

  saved_ptid_ptr = xmalloc (sizeof (ptid_t));
  *saved_ptid_ptr = inferior_ptid;
  return make_cleanup (restore_inferior_ptid, saved_ptid_ptr);
}


@


1.10
log
@Phase 1 of the ptid_t changes.
@
text
@d59 2
a60 1
/* Non-zero if we musn't deactivate this module's target vector.  */
a510 14
deactivate_target (void)
{
  /* Forget about the child's process ID.  We shouldn't need it
     anymore.  */
  proc_handle.pid = 0;

  if (! keep_thread_db)
    {
      using_thread_db = 0;
      unpush_target (&thread_db_ops);
    }
}

static void
d518 8
a525 2
         active, deactivate it now, even if the application was linked
         statically against the thread library.  */
a526 2
      if (using_thread_db)
	deactivate_target ();
d606 1
a606 2
  if (ti_p->ti_lid != GET_PID (ptid))
    ATTACH_LWP (BUILD_LWP (ti_p->ti_lid, GET_PID (ptid)), 0);
d617 17
d644 8
a651 1
  deactivate_target ();
d877 3
d886 6
d914 4
a917 1
  deactivate_target ();
d1025 1
@


1.9
log
@2001-04-30  Michael Snyder  <msnyder@@redhat.com>

	* thread-db.c: Revert 2001-04-26 change for debugging output.
	* lin-lwp.c:   Ditto.
@
text
@d127 2
a128 1
#define PIDGET(PID)		(((PID) & 0xffff))
d155 1
a155 1
restore_inferior_pid (void *arg)
d157 2
a158 2
  int *saved_pid_ptr = arg;
  inferior_pid = *saved_pid_ptr;
d163 1
a163 1
save_inferior_pid (void)
d165 1
a165 1
  int *saved_pid_ptr;
d167 3
a169 3
  saved_pid_ptr = xmalloc (sizeof (int));
  *saved_pid_ptr = inferior_pid;
  return make_cleanup (restore_inferior_pid, saved_pid_ptr);
d256 2
a257 2
static int
thread_from_lwp (int pid)
d263 2
a264 2
  if (GET_LWP (pid) == 0)
    pid = BUILD_LWP (pid, pid);
d266 1
a266 1
  gdb_assert (is_lwp (pid));
d268 1
a268 1
  err = td_ta_map_lwp2thr_p (thread_agent, GET_LWP (pid), &th);
d271 1
a271 1
	   GET_LWP (pid), thread_db_err_str (err));
d277 1
a277 1
  return BUILD_THREAD (ti.ti_tid, GET_PID (pid));
d280 2
a281 2
static int
lwp_from_thread (int pid)
d287 2
a288 2
  if (! is_thread (pid))
    return pid;
d290 1
a290 1
  err = td_ta_map_id2thr_p (thread_agent, GET_THREAD (pid), &th);
d293 1
a293 1
	   (long) GET_THREAD (pid), thread_db_err_str (err));
d299 1
a299 1
  return BUILD_LWP (ti.ti_lid, GET_PID (pid));
d548 1
a548 1
  proc_handle.pid = GET_PID (inferior_pid);
d597 1
a597 1
attach_thread (int pid, const td_thrhandle_t *th_p,
d606 1
a606 1
    printf_unfiltered ("[New %s]\n", target_pid_to_str (pid));
d609 1
a609 1
  tp = add_thread (pid);
d615 2
a616 2
  if (ti_p->ti_lid != GET_PID (pid))
    ATTACH_LWP (BUILD_LWP (ti_p->ti_lid, GET_PID (pid)), 0);
d623 1
a623 1
	   target_pid_to_str (pid), thread_db_err_str (err));
d627 1
a627 1
detach_thread (int pid, int verbose)
d630 1
a630 1
    printf_unfiltered ("[%s exited]\n", target_pid_to_str (pid));
d643 1
a643 1
thread_db_resume (int pid, int step, enum target_signal signo)
d645 1
a645 1
  struct cleanup *old_chain = save_inferior_pid ();
d647 4
a650 4
  if (pid == -1)
    inferior_pid = lwp_from_thread (inferior_pid);
  else if (is_thread (pid))
    pid = lwp_from_thread (pid);
d652 1
a652 1
  target_beneath->to_resume (pid, step, signo);
d662 1
a662 1
check_event (int pid)
d670 1
a670 1
  stop_pc = read_pc_pid (pid) - DECR_PC_AFTER_BREAK;
d687 1
a687 1
  pid = BUILD_THREAD (ti.ti_tid, GET_PID (pid));
d704 2
a705 2
      if (! in_thread_list (pid))
	attach_thread (pid, msg.th_p, &ti, 1);
d716 1
a716 1
      if (! in_thread_list (pid))
d719 1
a719 1
      detach_thread (pid, 1);
d727 2
a728 2
static int
thread_db_wait (int pid, struct target_waitstatus *ourstatus)
d730 1
a730 1
  extern int trap_pid;
d732 2
a733 2
  if (pid != -1 && is_thread (pid))
    pid = lwp_from_thread (pid);
d735 1
a735 1
  pid = target_beneath->to_wait (pid, ourstatus);
d741 1
a741 1
    return pid;
d744 1
a744 1
    return -1;
d749 1
a749 1
    check_event (pid);
d751 2
a752 2
  if (trap_pid)
    trap_pid = thread_from_lwp (trap_pid);
d754 1
a754 1
  return thread_from_lwp (pid);
d762 1
a762 1
  struct cleanup *old_chain = save_inferior_pid ();
d765 1
a765 1
  if (is_thread (inferior_pid))
d769 2
a770 2
      if (! target_thread_alive (inferior_pid))
	inferior_pid = GET_PID (inferior_pid);
d772 1
a772 1
	inferior_pid = lwp_from_thread (inferior_pid);
d789 1
a789 1
  if (! is_thread (inferior_pid))
d796 1
a796 1
  err = td_ta_map_id2thr_p (thread_agent, GET_THREAD (inferior_pid), &th);
d799 1
a799 1
	   (long) GET_THREAD (inferior_pid), thread_db_err_str (err));
d804 1
a804 1
	   (long) GET_THREAD (inferior_pid), thread_db_err_str (err));
d809 1
a809 1
	   (long) GET_THREAD (inferior_pid), thread_db_err_str (err));
d826 1
a826 1
  if (! is_thread (inferior_pid))
d833 1
a833 1
  err = td_ta_map_id2thr_p (thread_agent, GET_THREAD (inferior_pid), &th);
d836 1
a836 1
	   (long) GET_THREAD (inferior_pid), thread_db_err_str (err));
d853 1
a853 1
	   (long) GET_THREAD (inferior_pid), thread_db_err_str (err));
d857 1
a857 1
	   (long) GET_THREAD (inferior_pid), thread_db_err_str (err));
d873 1
a873 1
thread_db_post_startup_inferior (int pid)
d879 1
a879 1
      proc_handle.pid = GET_PID (pid);
d897 1
a897 1
thread_db_thread_alive (int pid)
d899 1
a899 1
  if (is_thread (pid))
d904 1
a904 1
      err = td_ta_map_id2thr_p (thread_agent, GET_THREAD (pid), &th);
d916 1
a916 1
    return target_beneath->to_thread_alive (pid);
d926 1
a926 1
  int pid;
d932 1
a932 1
  pid = BUILD_THREAD (ti.ti_tid, GET_PID (inferior_pid));
d934 2
a935 2
  if (! in_thread_list (pid))
    attach_thread (pid, th_p, &ti, 1);
d954 1
a954 1
thread_db_pid_to_str (int pid)
d956 1
a956 1
  if (is_thread (pid))
d963 1
a963 1
      err = td_ta_map_id2thr_p (thread_agent, GET_THREAD (pid), &th);
d966 1
a966 1
	       (long) GET_THREAD (pid), thread_db_err_str (err));
d971 1
a971 1
	       (long) GET_THREAD (pid), thread_db_err_str (err));
d987 2
a988 2
  if (target_beneath->to_pid_to_str (pid))
    return target_beneath->to_pid_to_str (pid);
d990 1
a990 1
  return normal_pid_to_str (pid);
@


1.8
log
@2001-04-26  Michael Snyder  <msnyder@@redhat.com>

	* thread-db.c (_initialize_thread_db): Add set/show command
	"debug-linux-threads" for debugging output.
	* lin-lwp.c (various): Use global "debug_linux_threads to
	turn on extra debugging output.
@
text
@a33 2
#include "command.h"
#include "gdbcmd.h"
a39 2
int debug_linux_threads = 0;	/* Set non-zero for debugging output. */

d54 1
a54 1
static void (*new_objfile_event_chain) (struct objfile *objfile);
d591 2
a592 2
  if (new_objfile_event_chain)
    new_objfile_event_chain (objfile);
d700 5
a704 4
      if (in_thread_list (pid))
	error ("Spurious thread creation event.");

      attach_thread (pid, msg.th_p, &ti, 1);
d1026 1
a1026 1
      new_objfile_event_chain = target_new_objfile_hook;
a1028 5
  add_show_from_set (add_set_cmd ("debug-linux-threads", class_support, 
				  var_boolean, (char *) &debug_linux_threads,
				  "Set debug output for linux-threads \
on or off.\nUse \"on\" to enable, \"off\" to disable.", &setlist),
		     &showlist);
@


1.7
log
@2001-04-17  Michael Snyder  <msnyder@@redhat.com>

	* thread-db.c (check_thread_signals): When looping over all
	signals, ignore signal zero.
	(disable_thread_signals): Ditto.
@
text
@d34 2
d42 2
d58 1
a58 1
static void (*target_new_objfile_chain) (struct objfile *objfile);
d595 2
a596 2
  if (target_new_objfile_chain)
    target_new_objfile_chain (objfile);
d704 4
a707 5
      /* We may already know about this thread, for instance when the
         user has issued the `info threads' command before the SIGTRAP
         for hitting the thread creation breakpoint was reported.  */
      if (! in_thread_list (pid))
	attach_thread (pid, msg.th_p, &ti, 1);
d1029 1
a1029 1
      target_new_objfile_chain = target_new_objfile_hook;
d1032 5
@


1.6
log
@* thread-db.c (check_event): Don't report an error if we encounter
a thread creation event for a thread that's already in the thread
list, since that may legitemately happen.  Instead only call
attach_thread if it's not already in the thread list.
@
text
@d472 1
a472 1
      for (i = 0; i < NSIG; i++)
d495 1
a495 1
      for (i = 0; i < NSIG; i++)
@


1.5
log
@Create new file regcache.h.  Update all uses.
@
text
@d700 5
a704 4
      if (in_thread_list (pid))
	error ("Spurious thread creation event.");

      attach_thread (pid, msg.th_p, &ti, 1);
@


1.4
log
@* lin-lwp.c (lin_lwp_xfer_memory): Add attrib argument.
* thread-db.c (thread_db_xfer_memory): Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
d34 1
@


1.3
log
@Fix debugging programs statically linked against the thread library.
* thread-db.c: Various comment fixes and additions.
Include "bfd.h", "symfile.h" and "objfiles.h".
(keep_thread_db): New variable.
(find_new_threads_callback): Remove prototype.
(thread_db_find_new_threads): New prototype.
(thread_db_push_target, thread_db_unpush_target): Remove
functions.
(deactivate_target): New function.
(thread_db_new_objfile): If OBJFILE == NULL, force deactivation of
target vector.  Activate target vector directly instead of calling
thread_db_push_target.  Set keep_thread_db if thread library is
detected in the main symbol file.  Only enable thread event
reporting if there actually is a child process.  Likewise for
detecting new threads, done by calling thread_db_find_new_threads
instead of iterating over the threads ourselves.
(thread_db_detach): Call deactivate_target instead of
thread_db_unpush_target.
(thread_db_wait): Bail out early if we're not debugging the
multi-threaded child process yet.
(thread_db_post_startup_inferior): New function.
(thread_db_mourn_inferior): Call deactivate_target instead of
thread_db_unpush_target.
(init_thread_db_ops): Add thread_db_post_startup_inferior to
thread_db_ops.
@
text
@d756 1
d772 1
a772 1
  xfer = target_beneath->to_xfer_memory (memaddr, myaddr, len, write, target);
@


1.2
log
@Replace free() with xfree().
@
text
@d28 1
d31 2
d58 3
d119 1
a119 1
static int find_new_threads_callback (const td_thrhandle_t *th_p, void *data);
d508 1
a508 1
thread_db_push_target (void)
d510 3
a512 1
  using_thread_db = 1;
d514 5
a518 4
  /* Push this target vector.  */
  push_target (&thread_db_ops);

  enable_thread_event_reporting ();
d522 1
a522 1
thread_db_unpush_target (void)
d524 1
a524 2
  /* Unpush this target vector.  */
  unpush_target (&thread_db_ops);
d526 8
a533 2
  using_thread_db = 0;
}
d535 2
a536 4
static void
thread_db_new_objfile (struct objfile *objfile)
{
  td_err_e err;
d543 3
a545 5
  if (objfile == NULL)
    /* Un-interesting object file.  */
    goto quit;

  /* Initialize the structure that identifies the child process.  */
d548 1
a548 2
  /* Now attempt to open a connection to the thread library running in
     the child process.  */
d553 1
a553 2
      /* No thread library found in the child process, probably
         because the child process isn't running yet.  */
d557 15
a571 2
      /* The thread library was detected in the child; we go live now!  */
      thread_db_push_target ();
d573 8
a580 7
      /* Find all user-space threads.  */
      err = td_ta_thr_iter_p (thread_agent, find_new_threads_callback,
			      &inferior_pid, TD_THR_ANY_STATE,
			      TD_THR_LOWEST_PRIORITY, TD_SIGNO_MASK,
			      TD_THR_ANY_USER_FLAGS);
      if (err != TD_OK)
	error ("Finding new threads failed: %s", thread_db_err_str (err));
d635 1
a635 1
  thread_db_unpush_target ();
d734 6
d865 2
a866 7
  /* We never want to actually create the inferior!  If this is ever
     called, it means we were on the target stack when the user said
     "run".  But we don't want to be on the new inferior's target
     stack until the libthread_db connection is ready to be made.  So
     we unpush ourselves from the stack, and then invoke
     find_default_create_inferior, which will invoke the appropriate
     process_stratum target to do the create.  */
d868 8
a875 1
  thread_db_unpush_target ();
d877 4
a880 1
  find_default_create_inferior (exec_file, allargs, env);
d887 1
a887 1
  thread_db_unpush_target ();
d1003 1
@


1.1
log
@* config/i386/nm-linux.h (PREPARE_TO_PROCEED, ATTCH_LWP,
GET_THREAD_SIGNALS): New defines.
* config/i386/linux.mh (NATDEPFILES): Remove lin-thread.o and
linux-threads.o.  Add proc-service.o, thread-db.o and lin-lwp.o.
* proc-service.c: New file.
* thread-db.c: New file.
* lin-lwp.c: New file.
@
text
@d151 1
a151 1
  free (arg);
@

