head	1.18;
access;
symbols
	gdb_6_0-2003-10-04-release:1.17
	kettenis_sparc-20030918-branch:1.17.0.36
	kettenis_sparc-20030918-branchpoint:1.17
	carlton_dictionary-20030917-merge:1.17
	ezannoni_pie-20030916-branchpoint:1.17
	ezannoni_pie-20030916-branch:1.17.0.34
	cagney_x86i386-20030821-branch:1.17.0.32
	cagney_x86i386-20030821-branchpoint:1.17
	carlton_dictionary-20030805-merge:1.17
	carlton_dictionary-20030627-merge:1.17
	gdb_6_0-branch:1.17.0.30
	gdb_6_0-2003-06-23-branchpoint:1.17
	jimb-ppc64-linux-20030613-branch:1.17.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.17
	cagney_convert-20030606-branch:1.17.0.26
	cagney_convert-20030606-branchpoint:1.17
	cagney_writestrings-20030508-branch:1.17.0.24
	cagney_writestrings-20030508-branchpoint:1.17
	jimb-ppc64-linux-20030528-branch:1.17.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.17
	carlton_dictionary-20030523-merge:1.17
	cagney_fileio-20030521-branch:1.17.0.20
	cagney_fileio-20030521-branchpoint:1.17
	kettenis_i386newframe-20030517-mergepoint:1.17
	jimb-ppc64-linux-20030509-branch:1.17.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.17
	kettenis_i386newframe-20030504-mergepoint:1.17
	carlton_dictionary-20030430-merge:1.17
	kettenis_i386newframe-20030419-branch:1.17.0.16
	kettenis_i386newframe-20030419-branchpoint:1.17
	carlton_dictionary-20030416-merge:1.17
	cagney_frameaddr-20030409-mergepoint:1.17
	kettenis_i386newframe-20030406-branch:1.17.0.14
	kettenis_i386newframe-20030406-branchpoint:1.17
	cagney_frameaddr-20030403-branchpoint:1.17
	cagney_frameaddr-20030403-branch:1.17.0.12
	cagney_framebase-20030330-mergepoint:1.17
	cagney_framebase-20030326-branch:1.17.0.10
	cagney_framebase-20030326-branchpoint:1.17
	cagney_lazyid-20030317-branch:1.17.0.8
	cagney_lazyid-20030317-branchpoint:1.17
	kettenis-i386newframe-20030316-mergepoint:1.17
	offbyone-20030313-branch:1.17.0.6
	offbyone-20030313-branchpoint:1.17
	kettenis-i386newframe-20030308-branch:1.17.0.4
	kettenis-i386newframe-20030308-branchpoint:1.17
	carlton_dictionary-20030305-merge:1.17
	cagney_offbyone-20030303-branch:1.17.0.2
	cagney_offbyone-20030303-branchpoint:1.17
	carlton_dictionary-20030207-merge:1.17
	interps-20030203-mergepoint:1.16
	interps-20030202-branch:1.16.0.2
	interps-20030202-branchpoint:1.16
	cagney-unwind-20030108-branch:1.15.0.2
	cagney-unwind-20030108-branchpoint:1.15
	carlton_dictionary-20021223-merge:1.10
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.10
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.8
	carlton_dictionary-20020920-branchpoint:1.8
	gdb_5_3-branch:1.8.0.6
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.4
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.2
	readline_4_3-import-branchpoint:1.8
	gdb_5_2_1-2002-07-23-release:1.7
	kseitz_interps-20020528-branch:1.7.0.14
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.7.0.12
	cagney_regbuf-20020515-branchpoint:1.7
	jimb-macro-020506-branch:1.7.0.10
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.7
	gdb_5_2-branch:1.7.0.8
	gdb_5_2-2002-03-03-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.6
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.4
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.2
	gdb_5_1-2001-07-29-branchpoint:1.7
	dberlin-typesystem-branch:1.6.0.2
	dberlin-typesystem-branchpoint:1.6
	gdb-post-ptid_t-2001-05-03:1.6
	gdb-pre-ptid_t-2001-05-03:1.6
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.4
	gdb-premipsmulti-2000-06-06-branch:1.1.1.4.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.4
	gdb-post-params-removal-2000-06-04:1.1.1.4
	gdb-pre-params-removal-2000-06-04:1.1.1.4
	gdb-post-params-removal-2000-05-28:1.1.1.4
	gdb-pre-params-removal-2000-05-28:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.4
	gdb-1999-10-25:1.1.1.4
	gdb-1999-10-18:1.1.1.4
	gdb-1999-10-11:1.1.1.4
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.4
	gdb-1999-09-13:1.1.1.4
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.18
date	2003.10.06.19.10.44;	author cagney;	state dead;
branches;
next	1.17;

1.17
date	2003.02.04.22.49.19;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.14.00.49.04;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.08.15.56.37;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.08.01.53.37;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.06.21.50.25;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.03.18.23.01;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.02.22.20.46;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.01.19.07.15;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.24.19.48.13;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.29.16.34.06;	author cagney;	state Exp;
branches
	1.8.8.1
	1.8.10.1;
next	1.7;

1.7
date	2001.07.15.20.10.02;	author cagney;	state Exp;
branches
	1.7.14.1;
next	1.6;

1.6
date	2001.03.28.21.42.31;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.06.08.21.10;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.03.01.38.49;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.50;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.17.22.18;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.08.13;	author jsm;	state Exp;
branches;
next	;

1.7.14.1
date	2002.08.09.18.34.25;	author kseitz;	state Exp;
branches;
next	;

1.8.8.1
date	2002.12.23.19.38.36;	author carlton;	state Exp;
branches;
next	1.8.8.2;

1.8.8.2
date	2003.02.07.19.17.51;	author carlton;	state Exp;
branches;
next	1.8.8.3;

1.8.8.3
date	2003.11.11.23.50.51;	author carlton;	state dead;
branches;
next	;

1.8.10.1
date	2003.12.14.20.27.22;	author drow;	state dead;
branches;
next	;


desc
@@


1.18
log
@2003-10-06  Andrew Cagney  <cagney@@redhat.com>

	* z8k-tdep.c, symm-tdep.c, symm-nat.c: Delete obsolete file.
	* sparclet-stub.c, sparclet-rom.c: Delete obsolete file.
	* sparcl-tdep.c, sparcl-stub.c, h8500-tdep.c: Delete obsolete file.
	* m3-nat.c, mipsm3-nat.c, mn10200-tdep.c: Delete obsolete file.
@
text
@// OBSOLETE /* Target-dependent code for the Matsushita MN10200 for GDB, the GNU debugger.
// OBSOLETE 
// OBSOLETE    Copyright 1997, 1998, 1999, 2000, 2001, 2003 Free Software
// OBSOLETE    Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "bfd.h"
// OBSOLETE #include "gdb_string.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "symfile.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Should call_function allocate stack space for a struct return?  */
// OBSOLETE int
// OBSOLETE mn10200_use_struct_convention (int gcc_p, struct type *type)
// OBSOLETE {
// OBSOLETE   return (TYPE_NFIELDS (type) > 1 || TYPE_LENGTH (type) > 8);
// OBSOLETE }
// OBSOLETE /* *INDENT-OFF* */
// OBSOLETE /* The main purpose of this file is dealing with prologues to extract
// OBSOLETE    information about stack frames and saved registers.
// OBSOLETE 
// OBSOLETE    For reference here's how prologues look on the mn10200:
// OBSOLETE 
// OBSOLETE      With frame pointer:
// OBSOLETE 	mov fp,a0
// OBSOLETE 	mov sp,fp
// OBSOLETE 	add <size>,sp
// OBSOLETE 	Register saves for d2, d3, a1, a2 as needed.  Saves start
// OBSOLETE 	at fp - <size> + <outgoing_args_size> and work towards higher
// OBSOLETE 	addresses.  Note that the saves are actually done off the stack
// OBSOLETE 	pointer in the prologue!  This makes for smaller code and easier
// OBSOLETE 	prologue scanning as the displacement fields will unlikely
// OBSOLETE         be more than 8 bits!
// OBSOLETE 
// OBSOLETE      Without frame pointer:
// OBSOLETE         add <size>,sp
// OBSOLETE 	Register saves for d2, d3, a1, a2 as needed.  Saves start
// OBSOLETE 	at sp + <outgoing_args_size> and work towards higher addresses.
// OBSOLETE 
// OBSOLETE      Out of line prologue:
// OBSOLETE 	add <local size>,sp  -- optional
// OBSOLETE 	jsr __prologue
// OBSOLETE 	add <outgoing_size>,sp -- optional
// OBSOLETE 
// OBSOLETE    The stack pointer remains constant throughout the life of most
// OBSOLETE    functions.  As a result the compiler will usually omit the
// OBSOLETE    frame pointer, so we must handle frame pointerless functions.  */
// OBSOLETE 
// OBSOLETE /* Analyze the prologue to determine where registers are saved,
// OBSOLETE    the end of the prologue, etc etc.  Return the end of the prologue
// OBSOLETE    scanned.
// OBSOLETE 
// OBSOLETE    We store into FI (if non-null) several tidbits of information:
// OBSOLETE 
// OBSOLETE     * stack_size -- size of this stack frame.  Note that if we stop in
// OBSOLETE     certain parts of the prologue/epilogue we may claim the size of the
// OBSOLETE     current frame is zero.  This happens when the current frame has
// OBSOLETE     not been allocated yet or has already been deallocated.
// OBSOLETE 
// OBSOLETE     * fsr -- Addresses of registers saved in the stack by this frame.
// OBSOLETE 
// OBSOLETE     * status -- A (relatively) generic status indicator.  It's a bitmask
// OBSOLETE     with the following bits: 
// OBSOLETE 
// OBSOLETE       MY_FRAME_IN_SP: The base of the current frame is actually in
// OBSOLETE       the stack pointer.  This can happen for frame pointerless
// OBSOLETE       functions, or cases where we're stopped in the prologue/epilogue
// OBSOLETE       itself.  For these cases mn10200_analyze_prologue will need up
// OBSOLETE       update fi->frame before returning or analyzing the register
// OBSOLETE       save instructions.
// OBSOLETE 
// OBSOLETE       MY_FRAME_IN_FP: The base of the current frame is in the
// OBSOLETE       frame pointer register ($a2).
// OBSOLETE 
// OBSOLETE       CALLER_A2_IN_A0: $a2 from the caller's frame is temporarily
// OBSOLETE       in $a0.  This can happen if we're stopped in the prologue.
// OBSOLETE 
// OBSOLETE       NO_MORE_FRAMES: Set this if the current frame is "start" or
// OBSOLETE       if the first instruction looks like mov <imm>,sp.  This tells
// OBSOLETE       frame chain to not bother trying to unwind past this frame.  */
// OBSOLETE /* *INDENT-ON* */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE #define MY_FRAME_IN_SP 0x1
// OBSOLETE #define MY_FRAME_IN_FP 0x2
// OBSOLETE #define CALLER_A2_IN_A0 0x4
// OBSOLETE #define NO_MORE_FRAMES 0x8
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE mn10200_analyze_prologue (struct frame_info *fi, CORE_ADDR pc)
// OBSOLETE {
// OBSOLETE   CORE_ADDR func_addr, func_end, addr, stop;
// OBSOLETE   CORE_ADDR stack_size = 0;
// OBSOLETE   unsigned char buf[4];
// OBSOLETE   int status;
// OBSOLETE   char *name;
// OBSOLETE   int out_of_line_prologue = 0;
// OBSOLETE 
// OBSOLETE   /* Use the PC in the frame if it's provided to look up the
// OBSOLETE      start of this function.  */
// OBSOLETE   pc = (fi ? get_frame_pc (fi) : pc);
// OBSOLETE 
// OBSOLETE   /* Find the start of this function.  */
// OBSOLETE   status = find_pc_partial_function (pc, &name, &func_addr, &func_end);
// OBSOLETE 
// OBSOLETE   /* Do nothing if we couldn't find the start of this function or if we're
// OBSOLETE      stopped at the first instruction in the prologue.  */
// OBSOLETE   if (status == 0)
// OBSOLETE     return pc;
// OBSOLETE 
// OBSOLETE   /* If we're in start, then give up.  */
// OBSOLETE   if (strcmp (name, "start") == 0)
// OBSOLETE     {
// OBSOLETE       if (fi)
// OBSOLETE 	fi->status = NO_MORE_FRAMES;
// OBSOLETE       return pc;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* At the start of a function our frame is in the stack pointer.  */
// OBSOLETE   if (fi)
// OBSOLETE     fi->status = MY_FRAME_IN_SP;
// OBSOLETE 
// OBSOLETE   /* If we're physically on an RTS instruction, then our frame has already
// OBSOLETE      been deallocated.
// OBSOLETE 
// OBSOLETE      fi->frame is bogus, we need to fix it.  */
// OBSOLETE   if (fi && get_frame_pc (fi) + 1 == func_end)
// OBSOLETE     {
// OBSOLETE       status = target_read_memory (get_frame_pc (fi), buf, 1);
// OBSOLETE       if (status != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (get_next_frame (fi) == NULL)
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return get_frame_pc (fi);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (buf[0] == 0xfe)
// OBSOLETE 	{
// OBSOLETE 	  if (get_next_frame (fi) == NULL)
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return get_frame_pc (fi);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Similarly if we're stopped on the first insn of a prologue as our
// OBSOLETE      frame hasn't been allocated yet.  */
// OBSOLETE   if (fi && get_frame_pc (fi) == func_addr)
// OBSOLETE     {
// OBSOLETE       if (get_next_frame (fi) == NULL)
// OBSOLETE 	deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE       return get_frame_pc (fi);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Figure out where to stop scanning.  */
// OBSOLETE   stop = fi ? get_frame_pc (fi) : func_end;
// OBSOLETE 
// OBSOLETE   /* Don't walk off the end of the function.  */
// OBSOLETE   stop = stop > func_end ? func_end : stop;
// OBSOLETE 
// OBSOLETE   /* Start scanning on the first instruction of this function.  */
// OBSOLETE   addr = func_addr;
// OBSOLETE 
// OBSOLETE   status = target_read_memory (addr, buf, 2);
// OBSOLETE   if (status != 0)
// OBSOLETE     {
// OBSOLETE       if (fi && get_next_frame (fi) == NULL && fi->status & MY_FRAME_IN_SP)
// OBSOLETE 	deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE       return addr;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* First see if this insn sets the stack pointer; if so, it's something
// OBSOLETE      we won't understand, so quit now.   */
// OBSOLETE   if (buf[0] == 0xdf
// OBSOLETE       || (buf[0] == 0xf4 && buf[1] == 0x77))
// OBSOLETE     {
// OBSOLETE       if (fi)
// OBSOLETE 	fi->status = NO_MORE_FRAMES;
// OBSOLETE       return addr;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Now see if we have a frame pointer.
// OBSOLETE 
// OBSOLETE      Search for mov a2,a0 (0xf278)
// OBSOLETE      then       mov a3,a2 (0xf27e).  */
// OBSOLETE 
// OBSOLETE   if (buf[0] == 0xf2 && buf[1] == 0x78)
// OBSOLETE     {
// OBSOLETE       /* Our caller's $a2 will be found in $a0 now.  Note it for
// OBSOLETE          our callers.  */
// OBSOLETE       if (fi)
// OBSOLETE 	fi->status |= CALLER_A2_IN_A0;
// OBSOLETE       addr += 2;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	{
// OBSOLETE 	  /* We still haven't allocated our local stack.  Handle this
// OBSOLETE 	     as if we stopped on the first or last insn of a function.   */
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL)
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       status = target_read_memory (addr, buf, 2);
// OBSOLETE       if (status != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL)
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE       if (buf[0] == 0xf2 && buf[1] == 0x7e)
// OBSOLETE 	{
// OBSOLETE 	  addr += 2;
// OBSOLETE 
// OBSOLETE 	  /* Our frame pointer is valid now.  */
// OBSOLETE 	  if (fi)
// OBSOLETE 	    {
// OBSOLETE 	      fi->status |= MY_FRAME_IN_FP;
// OBSOLETE 	      fi->status &= ~MY_FRAME_IN_SP;
// OBSOLETE 	    }
// OBSOLETE 	  if (addr >= stop)
// OBSOLETE 	    return addr;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL)
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Next we should allocate the local frame.
// OBSOLETE 
// OBSOLETE      Search for add imm8,a3 (0xd3XX)
// OBSOLETE      or add imm16,a3 (0xf70bXXXX)
// OBSOLETE      or add imm24,a3 (0xf467XXXXXX).
// OBSOLETE 
// OBSOLETE      If none of the above was found, then this prologue has
// OBSOLETE      no stack, and therefore can't have any register saves,
// OBSOLETE      so quit now.  */
// OBSOLETE   status = target_read_memory (addr, buf, 2);
// OBSOLETE   if (status != 0)
// OBSOLETE     {
// OBSOLETE       if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE       return addr;
// OBSOLETE     }
// OBSOLETE   if (buf[0] == 0xd3)
// OBSOLETE     {
// OBSOLETE       stack_size = extract_signed_integer (&buf[1], 1);
// OBSOLETE       if (fi)
// OBSOLETE 	fi->stack_size = stack_size;
// OBSOLETE       addr += 2;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp () - stack_size);
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else if (buf[0] == 0xf7 && buf[1] == 0x0b)
// OBSOLETE     {
// OBSOLETE       status = target_read_memory (addr + 2, buf, 2);
// OBSOLETE       if (status != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE       stack_size = extract_signed_integer (buf, 2);
// OBSOLETE       if (fi)
// OBSOLETE 	fi->stack_size = stack_size;
// OBSOLETE       addr += 4;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp () - stack_size);
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else if (buf[0] == 0xf4 && buf[1] == 0x67)
// OBSOLETE     {
// OBSOLETE       status = target_read_memory (addr + 2, buf, 3);
// OBSOLETE       if (status != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE       stack_size = extract_signed_integer (buf, 3);
// OBSOLETE       if (fi)
// OBSOLETE 	fi->stack_size = stack_size;
// OBSOLETE       addr += 5;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp () - stack_size);
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Now see if we have a call to __prologue for an out of line
// OBSOLETE      prologue.  */
// OBSOLETE   status = target_read_memory (addr, buf, 2);
// OBSOLETE   if (status != 0)
// OBSOLETE     return addr;
// OBSOLETE 
// OBSOLETE   /* First check for 16bit pc-relative call to __prologue.  */
// OBSOLETE   if (buf[0] == 0xfd)
// OBSOLETE     {
// OBSOLETE       CORE_ADDR temp;
// OBSOLETE       status = target_read_memory (addr + 1, buf, 2);
// OBSOLETE       if (status != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Get the PC this instruction will branch to.  */
// OBSOLETE       temp = (extract_signed_integer (buf, 2) + addr + 3) & 0xffffff;
// OBSOLETE 
// OBSOLETE       /* Get the name of the function at the target address.  */
// OBSOLETE       status = find_pc_partial_function (temp, &name, NULL, NULL);
// OBSOLETE       if (status == 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Note if it is an out of line prologue.  */
// OBSOLETE       out_of_line_prologue = (strcmp (name, "__prologue") == 0);
// OBSOLETE 
// OBSOLETE       /* This sucks up 3 bytes of instruction space.  */
// OBSOLETE       if (out_of_line_prologue)
// OBSOLETE 	addr += 3;
// OBSOLETE 
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL)
// OBSOLETE 	    {
// OBSOLETE 	      fi->stack_size -= 16;
// OBSOLETE 	      deprecated_update_frame_base_hack (fi, read_sp () - fi->stack_size);
// OBSOLETE 	    }
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   /* Now check for the 24bit pc-relative call to __prologue.  */
// OBSOLETE   else if (buf[0] == 0xf4 && buf[1] == 0xe1)
// OBSOLETE     {
// OBSOLETE       CORE_ADDR temp;
// OBSOLETE       status = target_read_memory (addr + 2, buf, 3);
// OBSOLETE       if (status != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Get the PC this instruction will branch to.  */
// OBSOLETE       temp = (extract_signed_integer (buf, 3) + addr + 5) & 0xffffff;
// OBSOLETE 
// OBSOLETE       /* Get the name of the function at the target address.  */
// OBSOLETE       status = find_pc_partial_function (temp, &name, NULL, NULL);
// OBSOLETE       if (status == 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Note if it is an out of line prologue.  */
// OBSOLETE       out_of_line_prologue = (strcmp (name, "__prologue") == 0);
// OBSOLETE 
// OBSOLETE       /* This sucks up 5 bytes of instruction space.  */
// OBSOLETE       if (out_of_line_prologue)
// OBSOLETE 	addr += 5;
// OBSOLETE 
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    {
// OBSOLETE 	      fi->stack_size -= 16;
// OBSOLETE 	      deprecated_update_frame_base_hack (fi, read_sp () - fi->stack_size);
// OBSOLETE 	    }
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Now actually handle the out of line prologue.  */
// OBSOLETE   if (out_of_line_prologue)
// OBSOLETE     {
// OBSOLETE       int outgoing_args_size = 0;
// OBSOLETE 
// OBSOLETE       /* First adjust the stack size for this function.  The out of
// OBSOLETE          line prologue saves 4 registers (16bytes of data).  */
// OBSOLETE       if (fi)
// OBSOLETE 	fi->stack_size -= 16;
// OBSOLETE 
// OBSOLETE       /* Update fi->frame if necessary.  */
// OBSOLETE       if (fi && get_next_frame (fi) == NULL)
// OBSOLETE 	deprecated_update_frame_base_hack (fi, read_sp () - fi->stack_size);
// OBSOLETE 
// OBSOLETE       /* After the out of line prologue, there may be another
// OBSOLETE          stack adjustment for the outgoing arguments.
// OBSOLETE 
// OBSOLETE          Search for add imm8,a3 (0xd3XX)
// OBSOLETE          or     add imm16,a3 (0xf70bXXXX)
// OBSOLETE          or     add imm24,a3 (0xf467XXXXXX).  */
// OBSOLETE 
// OBSOLETE       status = target_read_memory (addr, buf, 2);
// OBSOLETE       if (status != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi)
// OBSOLETE 	    {
// OBSOLETE 	      fi->fsr.regs[2] = get_frame_base (fi) + fi->stack_size + 4;
// OBSOLETE 	      fi->fsr.regs[3] = get_frame_base (fi) + fi->stack_size + 8;
// OBSOLETE 	      fi->fsr.regs[5] = get_frame_base (fi) + fi->stack_size + 12;
// OBSOLETE 	      fi->fsr.regs[6] = get_frame_base (fi) + fi->stack_size + 16;
// OBSOLETE 	    }
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (buf[0] == 0xd3)
// OBSOLETE 	{
// OBSOLETE 	  outgoing_args_size = extract_signed_integer (&buf[1], 1);
// OBSOLETE 	  addr += 2;
// OBSOLETE 	}
// OBSOLETE       else if (buf[0] == 0xf7 && buf[1] == 0x0b)
// OBSOLETE 	{
// OBSOLETE 	  status = target_read_memory (addr + 2, buf, 2);
// OBSOLETE 	  if (status != 0)
// OBSOLETE 	    {
// OBSOLETE 	      if (fi)
// OBSOLETE 		{
// OBSOLETE 		  fi->fsr.regs[2] = get_frame_base (fi) + fi->stack_size + 4;
// OBSOLETE 		  fi->fsr.regs[3] = get_frame_base (fi) + fi->stack_size + 8;
// OBSOLETE 		  fi->fsr.regs[5] = get_frame_base (fi) + fi->stack_size + 12;
// OBSOLETE 		  fi->fsr.regs[6] = get_frame_base (fi) + fi->stack_size + 16;
// OBSOLETE 		}
// OBSOLETE 	      return addr;
// OBSOLETE 	    }
// OBSOLETE 	  outgoing_args_size = extract_signed_integer (buf, 2);
// OBSOLETE 	  addr += 4;
// OBSOLETE 	}
// OBSOLETE       else if (buf[0] == 0xf4 && buf[1] == 0x67)
// OBSOLETE 	{
// OBSOLETE 	  status = target_read_memory (addr + 2, buf, 3);
// OBSOLETE 	  if (status != 0)
// OBSOLETE 	    {
// OBSOLETE 	      if (fi && get_next_frame (fi) == NULL)
// OBSOLETE 		{
// OBSOLETE 		  fi->fsr.regs[2] = get_frame_base (fi) + fi->stack_size + 4;
// OBSOLETE 		  fi->fsr.regs[3] = get_frame_base (fi) + fi->stack_size + 8;
// OBSOLETE 		  fi->fsr.regs[5] = get_frame_base (fi) + fi->stack_size + 12;
// OBSOLETE 		  fi->fsr.regs[6] = get_frame_base (fi) + fi->stack_size + 16;
// OBSOLETE 		}
// OBSOLETE 	      return addr;
// OBSOLETE 	    }
// OBSOLETE 	  outgoing_args_size = extract_signed_integer (buf, 3);
// OBSOLETE 	  addr += 5;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	outgoing_args_size = 0;
// OBSOLETE 
// OBSOLETE       /* Now that we know the size of the outgoing arguments, fix
// OBSOLETE          fi->frame again if this is the innermost frame.  */
// OBSOLETE       if (fi && get_next_frame (fi) == NULL)
// OBSOLETE 	deprecated_update_frame_base_hack (fi, get_frame_base (fi) - outgoing_args_size);
// OBSOLETE 
// OBSOLETE       /* Note the register save information and update the stack
// OBSOLETE          size for this frame too.  */
// OBSOLETE       if (fi)
// OBSOLETE 	{
// OBSOLETE 	  fi->fsr.regs[2] = get_frame_base (fi) + fi->stack_size + 4;
// OBSOLETE 	  fi->fsr.regs[3] = get_frame_base (fi) + fi->stack_size + 8;
// OBSOLETE 	  fi->fsr.regs[5] = get_frame_base (fi) + fi->stack_size + 12;
// OBSOLETE 	  fi->fsr.regs[6] = get_frame_base (fi) + fi->stack_size + 16;
// OBSOLETE 	  fi->stack_size += outgoing_args_size;
// OBSOLETE 	}
// OBSOLETE       /* There can be no more prologue insns, so return now.  */
// OBSOLETE       return addr;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* At this point fi->frame needs to be correct.
// OBSOLETE 
// OBSOLETE      If MY_FRAME_IN_SP is set and we're the innermost frame, then we
// OBSOLETE      need to fix fi->frame so that backtracing, find_frame_saved_regs,
// OBSOLETE      etc work correctly.  */
// OBSOLETE   if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP) != 0)
// OBSOLETE     deprecated_update_frame_base_hack (fi, read_sp () - fi->stack_size);
// OBSOLETE 
// OBSOLETE   /* And last we have the register saves.  These are relatively
// OBSOLETE      simple because they're physically done off the stack pointer,
// OBSOLETE      and thus the number of different instructions we need to
// OBSOLETE      check is greatly reduced because we know the displacements
// OBSOLETE      will be small.
// OBSOLETE 
// OBSOLETE      Search for movx d2,(X,a3) (0xf55eXX)
// OBSOLETE      then       movx d3,(X,a3) (0xf55fXX)
// OBSOLETE      then       mov  a1,(X,a3) (0x5dXX)    No frame pointer case
// OBSOLETE      then       mov  a2,(X,a3) (0x5eXX)    No frame pointer case
// OBSOLETE      or  mov  a0,(X,a3) (0x5cXX)           Frame pointer case.  */
// OBSOLETE 
// OBSOLETE   status = target_read_memory (addr, buf, 2);
// OBSOLETE   if (status != 0)
// OBSOLETE     return addr;
// OBSOLETE   if (buf[0] == 0xf5 && buf[1] == 0x5e)
// OBSOLETE     {
// OBSOLETE       if (fi)
// OBSOLETE 	{
// OBSOLETE 	  status = target_read_memory (addr + 2, buf, 1);
// OBSOLETE 	  if (status != 0)
// OBSOLETE 	    return addr;
// OBSOLETE 	  fi->fsr.regs[2] = (get_frame_base (fi) + stack_size
// OBSOLETE 			     + extract_signed_integer (buf, 1));
// OBSOLETE 	}
// OBSOLETE       addr += 3;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	return addr;
// OBSOLETE       status = target_read_memory (addr, buf, 2);
// OBSOLETE       if (status != 0)
// OBSOLETE 	return addr;
// OBSOLETE     }
// OBSOLETE   if (buf[0] == 0xf5 && buf[1] == 0x5f)
// OBSOLETE     {
// OBSOLETE       if (fi)
// OBSOLETE 	{
// OBSOLETE 	  status = target_read_memory (addr + 2, buf, 1);
// OBSOLETE 	  if (status != 0)
// OBSOLETE 	    return addr;
// OBSOLETE 	  fi->fsr.regs[3] = (get_frame_base (fi) + stack_size
// OBSOLETE 			     + extract_signed_integer (buf, 1));
// OBSOLETE 	}
// OBSOLETE       addr += 3;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	return addr;
// OBSOLETE       status = target_read_memory (addr, buf, 2);
// OBSOLETE       if (status != 0)
// OBSOLETE 	return addr;
// OBSOLETE     }
// OBSOLETE   if (buf[0] == 0x5d)
// OBSOLETE     {
// OBSOLETE       if (fi)
// OBSOLETE 	{
// OBSOLETE 	  status = target_read_memory (addr + 1, buf, 1);
// OBSOLETE 	  if (status != 0)
// OBSOLETE 	    return addr;
// OBSOLETE 	  fi->fsr.regs[5] = (get_frame_base (fi) + stack_size
// OBSOLETE 			     + extract_signed_integer (buf, 1));
// OBSOLETE 	}
// OBSOLETE       addr += 2;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	return addr;
// OBSOLETE       status = target_read_memory (addr, buf, 2);
// OBSOLETE       if (status != 0)
// OBSOLETE 	return addr;
// OBSOLETE     }
// OBSOLETE   if (buf[0] == 0x5e || buf[0] == 0x5c)
// OBSOLETE     {
// OBSOLETE       if (fi)
// OBSOLETE 	{
// OBSOLETE 	  status = target_read_memory (addr + 1, buf, 1);
// OBSOLETE 	  if (status != 0)
// OBSOLETE 	    return addr;
// OBSOLETE 	  fi->fsr.regs[6] = (get_frame_base (fi) + stack_size
// OBSOLETE 			     + extract_signed_integer (buf, 1));
// OBSOLETE 	  fi->status &= ~CALLER_A2_IN_A0;
// OBSOLETE 	}
// OBSOLETE       addr += 2;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	return addr;
// OBSOLETE       return addr;
// OBSOLETE     }
// OBSOLETE   return addr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: frame_chain
// OBSOLETE    Figure out and return the caller's frame pointer given current
// OBSOLETE    frame_info struct.
// OBSOLETE 
// OBSOLETE    We don't handle dummy frames yet but we would probably just return the
// OBSOLETE    stack pointer that was in use at the time the function call was made?  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE mn10200_frame_chain (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   struct frame_info *dummy_frame = deprecated_frame_xmalloc ();
// OBSOLETE   struct cleanup *old_chain = make_cleanup (xfree, dummy_frame);
// OBSOLETE   CORE_ADDR ret;
// OBSOLETE 
// OBSOLETE   /* Walk through the prologue to determine the stack size,
// OBSOLETE      location of saved registers, end of the prologue, etc.  */
// OBSOLETE   if (fi->status == 0)
// OBSOLETE     mn10200_analyze_prologue (fi, (CORE_ADDR) 0);
// OBSOLETE 
// OBSOLETE   /* Quit now if mn10200_analyze_prologue set NO_MORE_FRAMES.  */
// OBSOLETE   if (fi->status & NO_MORE_FRAMES)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   /* Now that we've analyzed our prologue, determine the frame
// OBSOLETE      pointer for our caller.
// OBSOLETE 
// OBSOLETE      If our caller has a frame pointer, then we need to
// OBSOLETE      find the entry value of $a2 to our function.
// OBSOLETE 
// OBSOLETE      If CALLER_A2_IN_A0, then the chain is in $a0.
// OBSOLETE 
// OBSOLETE      If fsr.regs[6] is nonzero, then it's at the memory
// OBSOLETE      location pointed to by fsr.regs[6].
// OBSOLETE 
// OBSOLETE      Else it's still in $a2.
// OBSOLETE 
// OBSOLETE      If our caller does not have a frame pointer, then his
// OBSOLETE      frame base is fi->frame + -caller's stack size + 4.  */
// OBSOLETE 
// OBSOLETE   /* The easiest way to get that info is to analyze our caller's frame.
// OBSOLETE 
// OBSOLETE      So we set up a dummy frame and call mn10200_analyze_prologue to
// OBSOLETE      find stuff for us.  */
// OBSOLETE   deprecated_update_frame_pc_hack (dummy_frame, FRAME_SAVED_PC (fi));
// OBSOLETE   deprecated_update_frame_base_hack (dummy_frame, get_frame_base (fi));
// OBSOLETE   memset (dummy_frame->fsr.regs, '\000', sizeof dummy_frame->fsr.regs);
// OBSOLETE   dummy_frame->status = 0;
// OBSOLETE   dummy_frame->stack_size = 0;
// OBSOLETE   mn10200_analyze_prologue (dummy_frame, 0);
// OBSOLETE 
// OBSOLETE   if (dummy_frame->status & MY_FRAME_IN_FP)
// OBSOLETE     {
// OBSOLETE       /* Our caller has a frame pointer.  So find the frame in $a2, $a0,
// OBSOLETE          or in the stack.  */
// OBSOLETE       if (fi->fsr.regs[6])
// OBSOLETE 	ret = (read_memory_integer (fi->fsr.regs[FP_REGNUM], REGISTER_SIZE)
// OBSOLETE 	       & 0xffffff);
// OBSOLETE       else if (fi->status & CALLER_A2_IN_A0)
// OBSOLETE 	ret = read_register (4);
// OBSOLETE       else
// OBSOLETE 	ret = read_register (FP_REGNUM);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* Our caller does not have a frame pointer.  So his frame starts
// OBSOLETE          at the base of our frame (fi->frame) + <his size> + 4 (saved pc).  */
// OBSOLETE       ret = get_frame_base (fi) + -dummy_frame->stack_size + 4;
// OBSOLETE     }
// OBSOLETE   do_cleanups (old_chain);
// OBSOLETE   return ret;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: skip_prologue
// OBSOLETE    Return the address of the first inst past the prologue of the function.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE mn10200_skip_prologue (CORE_ADDR pc)
// OBSOLETE {
// OBSOLETE   /* We used to check the debug symbols, but that can lose if
// OBSOLETE      we have a null prologue.  */
// OBSOLETE   return mn10200_analyze_prologue (NULL, pc);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: pop_frame
// OBSOLETE    This routine gets called when either the user uses the `return'
// OBSOLETE    command, or the call dummy breakpoint gets hit.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE mn10200_pop_frame (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   int regnum;
// OBSOLETE 
// OBSOLETE   if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
// OBSOLETE 				   get_frame_base (frame),
// OBSOLETE 				   get_frame_base (frame)))
// OBSOLETE     generic_pop_dummy_frame ();
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       write_register (PC_REGNUM, FRAME_SAVED_PC (frame));
// OBSOLETE 
// OBSOLETE       /* Restore any saved registers.  */
// OBSOLETE       for (regnum = 0; regnum < NUM_REGS; regnum++)
// OBSOLETE 	if (frame->fsr.regs[regnum] != 0)
// OBSOLETE 	  {
// OBSOLETE 	    ULONGEST value;
// OBSOLETE 
// OBSOLETE 	    value = read_memory_unsigned_integer (frame->fsr.regs[regnum],
// OBSOLETE 						REGISTER_RAW_SIZE (regnum));
// OBSOLETE 	    write_register (regnum, value);
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE       /* Actually cut back the stack.  */
// OBSOLETE       write_register (SP_REGNUM, get_frame_base (frame));
// OBSOLETE 
// OBSOLETE       /* Don't we need to set the PC?!?  XXX FIXME.  */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Throw away any cached frame information.  */
// OBSOLETE   flush_cached_frames ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: push_arguments
// OBSOLETE    Setup arguments for a call to the target.  Arguments go in
// OBSOLETE    order on the stack.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE mn10200_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
// OBSOLETE 			unsigned char struct_return, CORE_ADDR struct_addr)
// OBSOLETE {
// OBSOLETE   int argnum = 0;
// OBSOLETE   int len = 0;
// OBSOLETE   int stack_offset = 0;
// OBSOLETE   int regsused = struct_return ? 1 : 0;
// OBSOLETE 
// OBSOLETE   /* This should be a nop, but align the stack just in case something
// OBSOLETE      went wrong.  Stacks are two byte aligned on the mn10200.  */
// OBSOLETE   sp &= ~1;
// OBSOLETE 
// OBSOLETE   /* Now make space on the stack for the args.
// OBSOLETE 
// OBSOLETE      XXX This doesn't appear to handle pass-by-invisible reference
// OBSOLETE      arguments.  */
// OBSOLETE   for (argnum = 0; argnum < nargs; argnum++)
// OBSOLETE     {
// OBSOLETE       int arg_length = (TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 1) & ~1;
// OBSOLETE 
// OBSOLETE       /* If we've used all argument registers, then this argument is
// OBSOLETE          pushed.  */
// OBSOLETE       if (regsused >= 2 || arg_length > 4)
// OBSOLETE 	{
// OBSOLETE 	  regsused = 2;
// OBSOLETE 	  len += arg_length;
// OBSOLETE 	}
// OBSOLETE       /* We know we've got some arg register space left.  If this argument
// OBSOLETE          will fit entirely in regs, then put it there.  */
// OBSOLETE       else if (arg_length <= 2
// OBSOLETE 	       || TYPE_CODE (VALUE_TYPE (args[argnum])) == TYPE_CODE_PTR)
// OBSOLETE 	{
// OBSOLETE 	  regsused++;
// OBSOLETE 	}
// OBSOLETE       else if (regsused == 0)
// OBSOLETE 	{
// OBSOLETE 	  regsused = 2;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  regsused = 2;
// OBSOLETE 	  len += arg_length;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Allocate stack space.  */
// OBSOLETE   sp -= len;
// OBSOLETE 
// OBSOLETE   regsused = struct_return ? 1 : 0;
// OBSOLETE   /* Push all arguments onto the stack. */
// OBSOLETE   for (argnum = 0; argnum < nargs; argnum++)
// OBSOLETE     {
// OBSOLETE       int len;
// OBSOLETE       char *val;
// OBSOLETE 
// OBSOLETE       /* XXX Check this.  What about UNIONS?  */
// OBSOLETE       if (TYPE_CODE (VALUE_TYPE (*args)) == TYPE_CODE_STRUCT
// OBSOLETE 	  && TYPE_LENGTH (VALUE_TYPE (*args)) > 8)
// OBSOLETE 	{
// OBSOLETE 	  /* XXX Wrong, we want a pointer to this argument.  */
// OBSOLETE 	  len = TYPE_LENGTH (VALUE_TYPE (*args));
// OBSOLETE 	  val = (char *) VALUE_CONTENTS (*args);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  len = TYPE_LENGTH (VALUE_TYPE (*args));
// OBSOLETE 	  val = (char *) VALUE_CONTENTS (*args);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (regsused < 2
// OBSOLETE 	  && (len <= 2
// OBSOLETE 	      || TYPE_CODE (VALUE_TYPE (*args)) == TYPE_CODE_PTR))
// OBSOLETE 	{
// OBSOLETE 	  write_register (regsused, extract_unsigned_integer (val, 4));
// OBSOLETE 	  regsused++;
// OBSOLETE 	}
// OBSOLETE       else if (regsused == 0 && len == 4)
// OBSOLETE 	{
// OBSOLETE 	  write_register (regsused, extract_unsigned_integer (val, 2));
// OBSOLETE 	  write_register (regsused + 1, extract_unsigned_integer (val + 2, 2));
// OBSOLETE 	  regsused = 2;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  regsused = 2;
// OBSOLETE 	  while (len > 0)
// OBSOLETE 	    {
// OBSOLETE 	      write_memory (sp + stack_offset, val, 2);
// OBSOLETE 
// OBSOLETE 	      len -= 2;
// OBSOLETE 	      val += 2;
// OBSOLETE 	      stack_offset += 2;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       args++;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return sp;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: push_return_address (pc)
// OBSOLETE    Set up the return address for the inferior function call.
// OBSOLETE    Needed for targets where we don't actually execute a JSR/BSR instruction */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE mn10200_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
// OBSOLETE {
// OBSOLETE   unsigned char buf[4];
// OBSOLETE 
// OBSOLETE   store_unsigned_integer (buf, 4, CALL_DUMMY_ADDRESS ());
// OBSOLETE   write_memory (sp - 4, buf, 4);
// OBSOLETE   return sp - 4;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: store_struct_return (addr,sp)
// OBSOLETE    Store the structure value return address for an inferior function
// OBSOLETE    call.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE mn10200_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
// OBSOLETE {
// OBSOLETE   /* The structure return address is passed as the first argument.  */
// OBSOLETE   write_register (0, addr);
// OBSOLETE   return sp;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: frame_saved_pc 
// OBSOLETE    Find the caller of this frame.  We do this by seeing if RP_REGNUM
// OBSOLETE    is saved in the stack anywhere, otherwise we get it from the
// OBSOLETE    registers.  If the inner frame is a dummy frame, return its PC
// OBSOLETE    instead of RP, because that's where "caller" of the dummy-frame
// OBSOLETE    will be found.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE mn10200_frame_saved_pc (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   /* The saved PC will always be at the base of the current frame.  */
// OBSOLETE   return (read_memory_integer (get_frame_base (fi), REGISTER_SIZE) & 0xffffff);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: init_extra_frame_info
// OBSOLETE    Setup the frame's frame pointer, pc, and frame addresses for saved
// OBSOLETE    registers.  Most of the work is done in mn10200_analyze_prologue().
// OBSOLETE 
// OBSOLETE    Note that when we are called for the last frame (currently active frame),
// OBSOLETE    that get_frame_pc (fi) and fi->frame will already be setup.  However, fi->frame will
// OBSOLETE    be valid only if this routine uses FP.  For previous frames, fi-frame will
// OBSOLETE    always be correct.  mn10200_analyze_prologue will fix fi->frame if
// OBSOLETE    it's not valid.
// OBSOLETE 
// OBSOLETE    We can be called with the PC in the call dummy under two circumstances.
// OBSOLETE    First, during normal backtracing, second, while figuring out the frame
// OBSOLETE    pointer just prior to calling the target function (see run_stack_dummy).  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE mn10200_init_extra_frame_info (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   if (get_next_frame (fi))
// OBSOLETE     deprecated_update_frame_pc_hack (fi, FRAME_SAVED_PC (get_next_frame (fi)));
// OBSOLETE 
// OBSOLETE   memset (fi->fsr.regs, '\000', sizeof fi->fsr.regs);
// OBSOLETE   fi->status = 0;
// OBSOLETE   fi->stack_size = 0;
// OBSOLETE 
// OBSOLETE   mn10200_analyze_prologue (fi, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_mn10200_tdep (void)
// OBSOLETE {
// OBSOLETE   tm_print_insn = print_insn_mn10200;
// OBSOLETE }
@


1.17
log
@2003-02-04  Andrew Cagney  <ac131313@@redhat.com>

	* NEWS: Mention that the mn10200-elf is obsolete.
	* configure.tgt: Obsolete mn10200-*-* target.
	* breakpoint.c (update_breakpoints_after_exec): Update comment to
	mention that the mn10200 is obsolete.
	* breakpoint.h: Ditto.
	* MAINTAINERS: Mark the mn10200-elf as obsolete.
	* config/mn10200/mn10200.mt: Obsolete file.
	* config/mn10200/tm-mn10200.h: Obsolete file.
	* mn10200-tdep.c: Obsolete file.

Index: testsuite/ChangeLog
2003-02-04  Andrew Cagney  <ac131313@@redhat.com>

	* gdb.disasm/mn10200.exp: Obsolete file.
	* gdb.trace/Makefile.in (clean mostlyclean): Remove mn10200.
	* gdb.disasm/Makefile.in (clean mostlyclean): Remove mn10200.
	* gdb.base/watchpoint.exp: Mark the mn10200 xfails as obsolete.
@
text
@@


1.16
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@d1 899
a899 899
/* Target-dependent code for the Matsushita MN10200 for GDB, the GNU debugger.

   Copyright 1997, 1998, 1999, 2000, 2001, 2003 Free Software
   Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "target.h"
#include "value.h"
#include "bfd.h"
#include "gdb_string.h"
#include "gdbcore.h"
#include "symfile.h"
#include "regcache.h"


/* Should call_function allocate stack space for a struct return?  */
int
mn10200_use_struct_convention (int gcc_p, struct type *type)
{
  return (TYPE_NFIELDS (type) > 1 || TYPE_LENGTH (type) > 8);
}
/* *INDENT-OFF* */
/* The main purpose of this file is dealing with prologues to extract
   information about stack frames and saved registers.

   For reference here's how prologues look on the mn10200:

     With frame pointer:
	mov fp,a0
	mov sp,fp
	add <size>,sp
	Register saves for d2, d3, a1, a2 as needed.  Saves start
	at fp - <size> + <outgoing_args_size> and work towards higher
	addresses.  Note that the saves are actually done off the stack
	pointer in the prologue!  This makes for smaller code and easier
	prologue scanning as the displacement fields will unlikely
        be more than 8 bits!

     Without frame pointer:
        add <size>,sp
	Register saves for d2, d3, a1, a2 as needed.  Saves start
	at sp + <outgoing_args_size> and work towards higher addresses.

     Out of line prologue:
	add <local size>,sp  -- optional
	jsr __prologue
	add <outgoing_size>,sp -- optional

   The stack pointer remains constant throughout the life of most
   functions.  As a result the compiler will usually omit the
   frame pointer, so we must handle frame pointerless functions.  */

/* Analyze the prologue to determine where registers are saved,
   the end of the prologue, etc etc.  Return the end of the prologue
   scanned.

   We store into FI (if non-null) several tidbits of information:

    * stack_size -- size of this stack frame.  Note that if we stop in
    certain parts of the prologue/epilogue we may claim the size of the
    current frame is zero.  This happens when the current frame has
    not been allocated yet or has already been deallocated.

    * fsr -- Addresses of registers saved in the stack by this frame.

    * status -- A (relatively) generic status indicator.  It's a bitmask
    with the following bits: 

      MY_FRAME_IN_SP: The base of the current frame is actually in
      the stack pointer.  This can happen for frame pointerless
      functions, or cases where we're stopped in the prologue/epilogue
      itself.  For these cases mn10200_analyze_prologue will need up
      update fi->frame before returning or analyzing the register
      save instructions.

      MY_FRAME_IN_FP: The base of the current frame is in the
      frame pointer register ($a2).

      CALLER_A2_IN_A0: $a2 from the caller's frame is temporarily
      in $a0.  This can happen if we're stopped in the prologue.

      NO_MORE_FRAMES: Set this if the current frame is "start" or
      if the first instruction looks like mov <imm>,sp.  This tells
      frame chain to not bother trying to unwind past this frame.  */
/* *INDENT-ON* */




#define MY_FRAME_IN_SP 0x1
#define MY_FRAME_IN_FP 0x2
#define CALLER_A2_IN_A0 0x4
#define NO_MORE_FRAMES 0x8

static CORE_ADDR
mn10200_analyze_prologue (struct frame_info *fi, CORE_ADDR pc)
{
  CORE_ADDR func_addr, func_end, addr, stop;
  CORE_ADDR stack_size = 0;
  unsigned char buf[4];
  int status;
  char *name;
  int out_of_line_prologue = 0;

  /* Use the PC in the frame if it's provided to look up the
     start of this function.  */
  pc = (fi ? get_frame_pc (fi) : pc);

  /* Find the start of this function.  */
  status = find_pc_partial_function (pc, &name, &func_addr, &func_end);

  /* Do nothing if we couldn't find the start of this function or if we're
     stopped at the first instruction in the prologue.  */
  if (status == 0)
    return pc;

  /* If we're in start, then give up.  */
  if (strcmp (name, "start") == 0)
    {
      if (fi)
	fi->status = NO_MORE_FRAMES;
      return pc;
    }

  /* At the start of a function our frame is in the stack pointer.  */
  if (fi)
    fi->status = MY_FRAME_IN_SP;

  /* If we're physically on an RTS instruction, then our frame has already
     been deallocated.

     fi->frame is bogus, we need to fix it.  */
  if (fi && get_frame_pc (fi) + 1 == func_end)
    {
      status = target_read_memory (get_frame_pc (fi), buf, 1);
      if (status != 0)
	{
	  if (get_next_frame (fi) == NULL)
	    deprecated_update_frame_base_hack (fi, read_sp ());
	  return get_frame_pc (fi);
	}

      if (buf[0] == 0xfe)
	{
	  if (get_next_frame (fi) == NULL)
	    deprecated_update_frame_base_hack (fi, read_sp ());
	  return get_frame_pc (fi);
	}
    }

  /* Similarly if we're stopped on the first insn of a prologue as our
     frame hasn't been allocated yet.  */
  if (fi && get_frame_pc (fi) == func_addr)
    {
      if (get_next_frame (fi) == NULL)
	deprecated_update_frame_base_hack (fi, read_sp ());
      return get_frame_pc (fi);
    }

  /* Figure out where to stop scanning.  */
  stop = fi ? get_frame_pc (fi) : func_end;

  /* Don't walk off the end of the function.  */
  stop = stop > func_end ? func_end : stop;

  /* Start scanning on the first instruction of this function.  */
  addr = func_addr;

  status = target_read_memory (addr, buf, 2);
  if (status != 0)
    {
      if (fi && get_next_frame (fi) == NULL && fi->status & MY_FRAME_IN_SP)
	deprecated_update_frame_base_hack (fi, read_sp ());
      return addr;
    }

  /* First see if this insn sets the stack pointer; if so, it's something
     we won't understand, so quit now.   */
  if (buf[0] == 0xdf
      || (buf[0] == 0xf4 && buf[1] == 0x77))
    {
      if (fi)
	fi->status = NO_MORE_FRAMES;
      return addr;
    }

  /* Now see if we have a frame pointer.

     Search for mov a2,a0 (0xf278)
     then       mov a3,a2 (0xf27e).  */

  if (buf[0] == 0xf2 && buf[1] == 0x78)
    {
      /* Our caller's $a2 will be found in $a0 now.  Note it for
         our callers.  */
      if (fi)
	fi->status |= CALLER_A2_IN_A0;
      addr += 2;
      if (addr >= stop)
	{
	  /* We still haven't allocated our local stack.  Handle this
	     as if we stopped on the first or last insn of a function.   */
	  if (fi && get_next_frame (fi) == NULL)
	    deprecated_update_frame_base_hack (fi, read_sp ());
	  return addr;
	}

      status = target_read_memory (addr, buf, 2);
      if (status != 0)
	{
	  if (fi && get_next_frame (fi) == NULL)
	    deprecated_update_frame_base_hack (fi, read_sp ());
	  return addr;
	}
      if (buf[0] == 0xf2 && buf[1] == 0x7e)
	{
	  addr += 2;

	  /* Our frame pointer is valid now.  */
	  if (fi)
	    {
	      fi->status |= MY_FRAME_IN_FP;
	      fi->status &= ~MY_FRAME_IN_SP;
	    }
	  if (addr >= stop)
	    return addr;
	}
      else
	{
	  if (fi && get_next_frame (fi) == NULL)
	    deprecated_update_frame_base_hack (fi, read_sp ());
	  return addr;
	}
    }

  /* Next we should allocate the local frame.

     Search for add imm8,a3 (0xd3XX)
     or add imm16,a3 (0xf70bXXXX)
     or add imm24,a3 (0xf467XXXXXX).

     If none of the above was found, then this prologue has
     no stack, and therefore can't have any register saves,
     so quit now.  */
  status = target_read_memory (addr, buf, 2);
  if (status != 0)
    {
      if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
	deprecated_update_frame_base_hack (fi, read_sp ());
      return addr;
    }
  if (buf[0] == 0xd3)
    {
      stack_size = extract_signed_integer (&buf[1], 1);
      if (fi)
	fi->stack_size = stack_size;
      addr += 2;
      if (addr >= stop)
	{
	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
	    deprecated_update_frame_base_hack (fi, read_sp () - stack_size);
	  return addr;
	}
    }
  else if (buf[0] == 0xf7 && buf[1] == 0x0b)
    {
      status = target_read_memory (addr + 2, buf, 2);
      if (status != 0)
	{
	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
	    deprecated_update_frame_base_hack (fi, read_sp ());
	  return addr;
	}
      stack_size = extract_signed_integer (buf, 2);
      if (fi)
	fi->stack_size = stack_size;
      addr += 4;
      if (addr >= stop)
	{
	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
	    deprecated_update_frame_base_hack (fi, read_sp () - stack_size);
	  return addr;
	}
    }
  else if (buf[0] == 0xf4 && buf[1] == 0x67)
    {
      status = target_read_memory (addr + 2, buf, 3);
      if (status != 0)
	{
	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
	    deprecated_update_frame_base_hack (fi, read_sp ());
	  return addr;
	}
      stack_size = extract_signed_integer (buf, 3);
      if (fi)
	fi->stack_size = stack_size;
      addr += 5;
      if (addr >= stop)
	{
	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
	    deprecated_update_frame_base_hack (fi, read_sp () - stack_size);
	  return addr;
	}
    }

  /* Now see if we have a call to __prologue for an out of line
     prologue.  */
  status = target_read_memory (addr, buf, 2);
  if (status != 0)
    return addr;

  /* First check for 16bit pc-relative call to __prologue.  */
  if (buf[0] == 0xfd)
    {
      CORE_ADDR temp;
      status = target_read_memory (addr + 1, buf, 2);
      if (status != 0)
	{
	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
	    deprecated_update_frame_base_hack (fi, read_sp ());
	  return addr;
	}

      /* Get the PC this instruction will branch to.  */
      temp = (extract_signed_integer (buf, 2) + addr + 3) & 0xffffff;

      /* Get the name of the function at the target address.  */
      status = find_pc_partial_function (temp, &name, NULL, NULL);
      if (status == 0)
	{
	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
	    deprecated_update_frame_base_hack (fi, read_sp ());
	  return addr;
	}

      /* Note if it is an out of line prologue.  */
      out_of_line_prologue = (strcmp (name, "__prologue") == 0);

      /* This sucks up 3 bytes of instruction space.  */
      if (out_of_line_prologue)
	addr += 3;

      if (addr >= stop)
	{
	  if (fi && get_next_frame (fi) == NULL)
	    {
	      fi->stack_size -= 16;
	      deprecated_update_frame_base_hack (fi, read_sp () - fi->stack_size);
	    }
	  return addr;
	}
    }
  /* Now check for the 24bit pc-relative call to __prologue.  */
  else if (buf[0] == 0xf4 && buf[1] == 0xe1)
    {
      CORE_ADDR temp;
      status = target_read_memory (addr + 2, buf, 3);
      if (status != 0)
	{
	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
	    deprecated_update_frame_base_hack (fi, read_sp ());
	  return addr;
	}

      /* Get the PC this instruction will branch to.  */
      temp = (extract_signed_integer (buf, 3) + addr + 5) & 0xffffff;

      /* Get the name of the function at the target address.  */
      status = find_pc_partial_function (temp, &name, NULL, NULL);
      if (status == 0)
	{
	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
	    deprecated_update_frame_base_hack (fi, read_sp ());
	  return addr;
	}

      /* Note if it is an out of line prologue.  */
      out_of_line_prologue = (strcmp (name, "__prologue") == 0);

      /* This sucks up 5 bytes of instruction space.  */
      if (out_of_line_prologue)
	addr += 5;

      if (addr >= stop)
	{
	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
	    {
	      fi->stack_size -= 16;
	      deprecated_update_frame_base_hack (fi, read_sp () - fi->stack_size);
	    }
	  return addr;
	}
    }

  /* Now actually handle the out of line prologue.  */
  if (out_of_line_prologue)
    {
      int outgoing_args_size = 0;

      /* First adjust the stack size for this function.  The out of
         line prologue saves 4 registers (16bytes of data).  */
      if (fi)
	fi->stack_size -= 16;

      /* Update fi->frame if necessary.  */
      if (fi && get_next_frame (fi) == NULL)
	deprecated_update_frame_base_hack (fi, read_sp () - fi->stack_size);

      /* After the out of line prologue, there may be another
         stack adjustment for the outgoing arguments.

         Search for add imm8,a3 (0xd3XX)
         or     add imm16,a3 (0xf70bXXXX)
         or     add imm24,a3 (0xf467XXXXXX).  */

      status = target_read_memory (addr, buf, 2);
      if (status != 0)
	{
	  if (fi)
	    {
	      fi->fsr.regs[2] = get_frame_base (fi) + fi->stack_size + 4;
	      fi->fsr.regs[3] = get_frame_base (fi) + fi->stack_size + 8;
	      fi->fsr.regs[5] = get_frame_base (fi) + fi->stack_size + 12;
	      fi->fsr.regs[6] = get_frame_base (fi) + fi->stack_size + 16;
	    }
	  return addr;
	}

      if (buf[0] == 0xd3)
	{
	  outgoing_args_size = extract_signed_integer (&buf[1], 1);
	  addr += 2;
	}
      else if (buf[0] == 0xf7 && buf[1] == 0x0b)
	{
	  status = target_read_memory (addr + 2, buf, 2);
	  if (status != 0)
	    {
	      if (fi)
		{
		  fi->fsr.regs[2] = get_frame_base (fi) + fi->stack_size + 4;
		  fi->fsr.regs[3] = get_frame_base (fi) + fi->stack_size + 8;
		  fi->fsr.regs[5] = get_frame_base (fi) + fi->stack_size + 12;
		  fi->fsr.regs[6] = get_frame_base (fi) + fi->stack_size + 16;
		}
	      return addr;
	    }
	  outgoing_args_size = extract_signed_integer (buf, 2);
	  addr += 4;
	}
      else if (buf[0] == 0xf4 && buf[1] == 0x67)
	{
	  status = target_read_memory (addr + 2, buf, 3);
	  if (status != 0)
	    {
	      if (fi && get_next_frame (fi) == NULL)
		{
		  fi->fsr.regs[2] = get_frame_base (fi) + fi->stack_size + 4;
		  fi->fsr.regs[3] = get_frame_base (fi) + fi->stack_size + 8;
		  fi->fsr.regs[5] = get_frame_base (fi) + fi->stack_size + 12;
		  fi->fsr.regs[6] = get_frame_base (fi) + fi->stack_size + 16;
		}
	      return addr;
	    }
	  outgoing_args_size = extract_signed_integer (buf, 3);
	  addr += 5;
	}
      else
	outgoing_args_size = 0;

      /* Now that we know the size of the outgoing arguments, fix
         fi->frame again if this is the innermost frame.  */
      if (fi && get_next_frame (fi) == NULL)
	deprecated_update_frame_base_hack (fi, get_frame_base (fi) - outgoing_args_size);

      /* Note the register save information and update the stack
         size for this frame too.  */
      if (fi)
	{
	  fi->fsr.regs[2] = get_frame_base (fi) + fi->stack_size + 4;
	  fi->fsr.regs[3] = get_frame_base (fi) + fi->stack_size + 8;
	  fi->fsr.regs[5] = get_frame_base (fi) + fi->stack_size + 12;
	  fi->fsr.regs[6] = get_frame_base (fi) + fi->stack_size + 16;
	  fi->stack_size += outgoing_args_size;
	}
      /* There can be no more prologue insns, so return now.  */
      return addr;
    }

  /* At this point fi->frame needs to be correct.

     If MY_FRAME_IN_SP is set and we're the innermost frame, then we
     need to fix fi->frame so that backtracing, find_frame_saved_regs,
     etc work correctly.  */
  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP) != 0)
    deprecated_update_frame_base_hack (fi, read_sp () - fi->stack_size);

  /* And last we have the register saves.  These are relatively
     simple because they're physically done off the stack pointer,
     and thus the number of different instructions we need to
     check is greatly reduced because we know the displacements
     will be small.

     Search for movx d2,(X,a3) (0xf55eXX)
     then       movx d3,(X,a3) (0xf55fXX)
     then       mov  a1,(X,a3) (0x5dXX)    No frame pointer case
     then       mov  a2,(X,a3) (0x5eXX)    No frame pointer case
     or  mov  a0,(X,a3) (0x5cXX)           Frame pointer case.  */

  status = target_read_memory (addr, buf, 2);
  if (status != 0)
    return addr;
  if (buf[0] == 0xf5 && buf[1] == 0x5e)
    {
      if (fi)
	{
	  status = target_read_memory (addr + 2, buf, 1);
	  if (status != 0)
	    return addr;
	  fi->fsr.regs[2] = (get_frame_base (fi) + stack_size
			     + extract_signed_integer (buf, 1));
	}
      addr += 3;
      if (addr >= stop)
	return addr;
      status = target_read_memory (addr, buf, 2);
      if (status != 0)
	return addr;
    }
  if (buf[0] == 0xf5 && buf[1] == 0x5f)
    {
      if (fi)
	{
	  status = target_read_memory (addr + 2, buf, 1);
	  if (status != 0)
	    return addr;
	  fi->fsr.regs[3] = (get_frame_base (fi) + stack_size
			     + extract_signed_integer (buf, 1));
	}
      addr += 3;
      if (addr >= stop)
	return addr;
      status = target_read_memory (addr, buf, 2);
      if (status != 0)
	return addr;
    }
  if (buf[0] == 0x5d)
    {
      if (fi)
	{
	  status = target_read_memory (addr + 1, buf, 1);
	  if (status != 0)
	    return addr;
	  fi->fsr.regs[5] = (get_frame_base (fi) + stack_size
			     + extract_signed_integer (buf, 1));
	}
      addr += 2;
      if (addr >= stop)
	return addr;
      status = target_read_memory (addr, buf, 2);
      if (status != 0)
	return addr;
    }
  if (buf[0] == 0x5e || buf[0] == 0x5c)
    {
      if (fi)
	{
	  status = target_read_memory (addr + 1, buf, 1);
	  if (status != 0)
	    return addr;
	  fi->fsr.regs[6] = (get_frame_base (fi) + stack_size
			     + extract_signed_integer (buf, 1));
	  fi->status &= ~CALLER_A2_IN_A0;
	}
      addr += 2;
      if (addr >= stop)
	return addr;
      return addr;
    }
  return addr;
}

/* Function: frame_chain
   Figure out and return the caller's frame pointer given current
   frame_info struct.

   We don't handle dummy frames yet but we would probably just return the
   stack pointer that was in use at the time the function call was made?  */

CORE_ADDR
mn10200_frame_chain (struct frame_info *fi)
{
  struct frame_info *dummy_frame = deprecated_frame_xmalloc ();
  struct cleanup *old_chain = make_cleanup (xfree, dummy_frame);
  CORE_ADDR ret;

  /* Walk through the prologue to determine the stack size,
     location of saved registers, end of the prologue, etc.  */
  if (fi->status == 0)
    mn10200_analyze_prologue (fi, (CORE_ADDR) 0);

  /* Quit now if mn10200_analyze_prologue set NO_MORE_FRAMES.  */
  if (fi->status & NO_MORE_FRAMES)
    return 0;

  /* Now that we've analyzed our prologue, determine the frame
     pointer for our caller.

     If our caller has a frame pointer, then we need to
     find the entry value of $a2 to our function.

     If CALLER_A2_IN_A0, then the chain is in $a0.

     If fsr.regs[6] is nonzero, then it's at the memory
     location pointed to by fsr.regs[6].

     Else it's still in $a2.

     If our caller does not have a frame pointer, then his
     frame base is fi->frame + -caller's stack size + 4.  */

  /* The easiest way to get that info is to analyze our caller's frame.

     So we set up a dummy frame and call mn10200_analyze_prologue to
     find stuff for us.  */
  deprecated_update_frame_pc_hack (dummy_frame, FRAME_SAVED_PC (fi));
  deprecated_update_frame_base_hack (dummy_frame, get_frame_base (fi));
  memset (dummy_frame->fsr.regs, '\000', sizeof dummy_frame->fsr.regs);
  dummy_frame->status = 0;
  dummy_frame->stack_size = 0;
  mn10200_analyze_prologue (dummy_frame, 0);

  if (dummy_frame->status & MY_FRAME_IN_FP)
    {
      /* Our caller has a frame pointer.  So find the frame in $a2, $a0,
         or in the stack.  */
      if (fi->fsr.regs[6])
	ret = (read_memory_integer (fi->fsr.regs[FP_REGNUM], REGISTER_SIZE)
	       & 0xffffff);
      else if (fi->status & CALLER_A2_IN_A0)
	ret = read_register (4);
      else
	ret = read_register (FP_REGNUM);
    }
  else
    {
      /* Our caller does not have a frame pointer.  So his frame starts
         at the base of our frame (fi->frame) + <his size> + 4 (saved pc).  */
      ret = get_frame_base (fi) + -dummy_frame->stack_size + 4;
    }
  do_cleanups (old_chain);
  return ret;
}

/* Function: skip_prologue
   Return the address of the first inst past the prologue of the function.  */

CORE_ADDR
mn10200_skip_prologue (CORE_ADDR pc)
{
  /* We used to check the debug symbols, but that can lose if
     we have a null prologue.  */
  return mn10200_analyze_prologue (NULL, pc);
}

/* Function: pop_frame
   This routine gets called when either the user uses the `return'
   command, or the call dummy breakpoint gets hit.  */

void
mn10200_pop_frame (struct frame_info *frame)
{
  int regnum;

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
    generic_pop_dummy_frame ();
  else
    {
      write_register (PC_REGNUM, FRAME_SAVED_PC (frame));

      /* Restore any saved registers.  */
      for (regnum = 0; regnum < NUM_REGS; regnum++)
	if (frame->fsr.regs[regnum] != 0)
	  {
	    ULONGEST value;

	    value = read_memory_unsigned_integer (frame->fsr.regs[regnum],
						REGISTER_RAW_SIZE (regnum));
	    write_register (regnum, value);
	  }

      /* Actually cut back the stack.  */
      write_register (SP_REGNUM, get_frame_base (frame));

      /* Don't we need to set the PC?!?  XXX FIXME.  */
    }

  /* Throw away any cached frame information.  */
  flush_cached_frames ();
}

/* Function: push_arguments
   Setup arguments for a call to the target.  Arguments go in
   order on the stack.  */

CORE_ADDR
mn10200_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
			unsigned char struct_return, CORE_ADDR struct_addr)
{
  int argnum = 0;
  int len = 0;
  int stack_offset = 0;
  int regsused = struct_return ? 1 : 0;

  /* This should be a nop, but align the stack just in case something
     went wrong.  Stacks are two byte aligned on the mn10200.  */
  sp &= ~1;

  /* Now make space on the stack for the args.

     XXX This doesn't appear to handle pass-by-invisible reference
     arguments.  */
  for (argnum = 0; argnum < nargs; argnum++)
    {
      int arg_length = (TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 1) & ~1;

      /* If we've used all argument registers, then this argument is
         pushed.  */
      if (regsused >= 2 || arg_length > 4)
	{
	  regsused = 2;
	  len += arg_length;
	}
      /* We know we've got some arg register space left.  If this argument
         will fit entirely in regs, then put it there.  */
      else if (arg_length <= 2
	       || TYPE_CODE (VALUE_TYPE (args[argnum])) == TYPE_CODE_PTR)
	{
	  regsused++;
	}
      else if (regsused == 0)
	{
	  regsused = 2;
	}
      else
	{
	  regsused = 2;
	  len += arg_length;
	}
    }

  /* Allocate stack space.  */
  sp -= len;

  regsused = struct_return ? 1 : 0;
  /* Push all arguments onto the stack. */
  for (argnum = 0; argnum < nargs; argnum++)
    {
      int len;
      char *val;

      /* XXX Check this.  What about UNIONS?  */
      if (TYPE_CODE (VALUE_TYPE (*args)) == TYPE_CODE_STRUCT
	  && TYPE_LENGTH (VALUE_TYPE (*args)) > 8)
	{
	  /* XXX Wrong, we want a pointer to this argument.  */
	  len = TYPE_LENGTH (VALUE_TYPE (*args));
	  val = (char *) VALUE_CONTENTS (*args);
	}
      else
	{
	  len = TYPE_LENGTH (VALUE_TYPE (*args));
	  val = (char *) VALUE_CONTENTS (*args);
	}

      if (regsused < 2
	  && (len <= 2
	      || TYPE_CODE (VALUE_TYPE (*args)) == TYPE_CODE_PTR))
	{
	  write_register (regsused, extract_unsigned_integer (val, 4));
	  regsused++;
	}
      else if (regsused == 0 && len == 4)
	{
	  write_register (regsused, extract_unsigned_integer (val, 2));
	  write_register (regsused + 1, extract_unsigned_integer (val + 2, 2));
	  regsused = 2;
	}
      else
	{
	  regsused = 2;
	  while (len > 0)
	    {
	      write_memory (sp + stack_offset, val, 2);

	      len -= 2;
	      val += 2;
	      stack_offset += 2;
	    }
	}
      args++;
    }

  return sp;
}

/* Function: push_return_address (pc)
   Set up the return address for the inferior function call.
   Needed for targets where we don't actually execute a JSR/BSR instruction */

CORE_ADDR
mn10200_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
{
  unsigned char buf[4];

  store_unsigned_integer (buf, 4, CALL_DUMMY_ADDRESS ());
  write_memory (sp - 4, buf, 4);
  return sp - 4;
}

/* Function: store_struct_return (addr,sp)
   Store the structure value return address for an inferior function
   call.  */

CORE_ADDR
mn10200_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  /* The structure return address is passed as the first argument.  */
  write_register (0, addr);
  return sp;
}

/* Function: frame_saved_pc 
   Find the caller of this frame.  We do this by seeing if RP_REGNUM
   is saved in the stack anywhere, otherwise we get it from the
   registers.  If the inner frame is a dummy frame, return its PC
   instead of RP, because that's where "caller" of the dummy-frame
   will be found.  */

CORE_ADDR
mn10200_frame_saved_pc (struct frame_info *fi)
{
  /* The saved PC will always be at the base of the current frame.  */
  return (read_memory_integer (get_frame_base (fi), REGISTER_SIZE) & 0xffffff);
}

/* Function: init_extra_frame_info
   Setup the frame's frame pointer, pc, and frame addresses for saved
   registers.  Most of the work is done in mn10200_analyze_prologue().

   Note that when we are called for the last frame (currently active frame),
   that get_frame_pc (fi) and fi->frame will already be setup.  However, fi->frame will
   be valid only if this routine uses FP.  For previous frames, fi-frame will
   always be correct.  mn10200_analyze_prologue will fix fi->frame if
   it's not valid.

   We can be called with the PC in the call dummy under two circumstances.
   First, during normal backtracing, second, while figuring out the frame
   pointer just prior to calling the target function (see run_stack_dummy).  */

void
mn10200_init_extra_frame_info (struct frame_info *fi)
{
  if (get_next_frame (fi))
    deprecated_update_frame_pc_hack (fi, FRAME_SAVED_PC (get_next_frame (fi)));

  memset (fi->fsr.regs, '\000', sizeof fi->fsr.regs);
  fi->status = 0;
  fi->stack_size = 0;

  mn10200_analyze_prologue (fi, 0);
}

void
_initialize_mn10200_tdep (void)
{
  tm_print_insn = print_insn_mn10200;
}
@


1.15
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_next_frame.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10200-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, sparc-tdep.c: Ditto.
	* v850-tdep.c, vax-tdep.c, x86-64-linux-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
@
text
@d2 3
a4 1
   Copyright 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.14
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_base.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10200-tdep.c: Ditto.
	* mn10300-tdep.c, ns32k-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c: Ditto.
	* x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* config/h8500/tm-h8500.h, config/mn10200/tm-mn10200.h: Ditto.
	* config/sparc/tm-sparc.h: Ditto.
@
text
@d155 1
a155 1
	  if (fi->next == NULL)
d162 1
a162 1
	  if (fi->next == NULL)
d172 1
a172 1
      if (fi->next == NULL)
d189 1
a189 1
      if (fi && fi->next == NULL && fi->status & MY_FRAME_IN_SP)
d220 1
a220 1
	  if (fi && fi->next == NULL)
d228 1
a228 1
	  if (fi && fi->next == NULL)
d247 1
a247 1
	  if (fi && fi->next == NULL)
d265 1
a265 1
      if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
d277 1
a277 1
	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
d287 1
a287 1
	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
d297 1
a297 1
	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
d307 1
a307 1
	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
d317 1
a317 1
	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
d336 1
a336 1
	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
d348 1
a348 1
	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
d362 1
a362 1
	  if (fi && fi->next == NULL)
d377 1
a377 1
	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
d389 1
a389 1
	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
d403 1
a403 1
	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
d423 1
a423 1
      if (fi && fi->next == NULL)
d473 1
a473 1
	      if (fi && fi->next == NULL)
d490 1
a490 1
      if (fi && fi->next == NULL)
d512 1
a512 1
  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP) != 0)
d883 2
a884 2
  if (fi->next)
    deprecated_update_frame_pc_hack (fi, FRAME_SAVED_PC (fi->next));
@


1.13
log
@2003-01-06  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (deprecated_frame_xmalloc_with_cleanup): Declare.
	* frame.c (deprecated_frame_xmalloc_with_cleanup): New function.
	* arm-tdep.c (arm_frame_chain): Allocate caller_fi using
	deprecated_frame_xmalloc_with_cleanup.
	* m32r-tdep.c (m32r_virtual_frame_pointer): Allocate `fi' using
	deprecated_frame_xmalloc.
	* mcore-tdep.c (analyze_dummy_frame): Ditto for dummy.
	* mn10200-tdep.c (mn10200_frame_chain): Ditto for dummy_frame.
@
text
@d438 4
a441 4
	      fi->fsr.regs[2] = fi->frame + fi->stack_size + 4;
	      fi->fsr.regs[3] = fi->frame + fi->stack_size + 8;
	      fi->fsr.regs[5] = fi->frame + fi->stack_size + 12;
	      fi->fsr.regs[6] = fi->frame + fi->stack_size + 16;
d458 4
a461 4
		  fi->fsr.regs[2] = fi->frame + fi->stack_size + 4;
		  fi->fsr.regs[3] = fi->frame + fi->stack_size + 8;
		  fi->fsr.regs[5] = fi->frame + fi->stack_size + 12;
		  fi->fsr.regs[6] = fi->frame + fi->stack_size + 16;
d475 4
a478 4
		  fi->fsr.regs[2] = fi->frame + fi->stack_size + 4;
		  fi->fsr.regs[3] = fi->frame + fi->stack_size + 8;
		  fi->fsr.regs[5] = fi->frame + fi->stack_size + 12;
		  fi->fsr.regs[6] = fi->frame + fi->stack_size + 16;
d491 1
a491 1
	deprecated_update_frame_base_hack (fi, fi->frame - outgoing_args_size);
d497 4
a500 4
	  fi->fsr.regs[2] = fi->frame + fi->stack_size + 4;
	  fi->fsr.regs[3] = fi->frame + fi->stack_size + 8;
	  fi->fsr.regs[5] = fi->frame + fi->stack_size + 12;
	  fi->fsr.regs[6] = fi->frame + fi->stack_size + 16;
d537 1
a537 1
	  fi->fsr.regs[2] = (fi->frame + stack_size
d554 1
a554 1
	  fi->fsr.regs[3] = (fi->frame + stack_size
d571 1
a571 1
	  fi->fsr.regs[5] = (fi->frame + stack_size
d588 1
a588 1
	  fi->fsr.regs[6] = (fi->frame + stack_size
d644 1
a644 1
  deprecated_update_frame_base_hack (dummy_frame, fi->frame);
d666 1
a666 1
      ret = fi->frame + -dummy_frame->stack_size + 4;
d692 3
a694 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), frame->frame, frame->frame))
d863 1
a863 1
  return (read_memory_integer (fi->frame, REGISTER_SIZE) & 0xffffff);
@


1.12
log
@2003-01-03  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use deprecated_update_frame_base_hack.
	* avr-tdep.c, cris-tdep.c: Ditto.
	* mcore-tdep.c, mips-tdep.c, mn10200-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
@
text
@d610 3
a612 1
  struct frame_info dummy_frame;
d643 6
a648 6
  deprecated_update_frame_pc_hack (&dummy_frame, FRAME_SAVED_PC (fi));
  deprecated_update_frame_base_hack (&dummy_frame, fi->frame);
  memset (dummy_frame.fsr.regs, '\000', sizeof dummy_frame.fsr.regs);
  dummy_frame.status = 0;
  dummy_frame.stack_size = 0;
  mn10200_analyze_prologue (&dummy_frame, 0);
d650 1
a650 1
  if (dummy_frame.status & MY_FRAME_IN_FP)
d655 2
a656 2
	return (read_memory_integer (fi->fsr.regs[FP_REGNUM], REGISTER_SIZE)
		& 0xffffff);
d658 1
a658 1
	return read_register (4);
d660 1
a660 1
	return read_register (FP_REGNUM);
d666 1
a666 1
      return fi->frame + -dummy_frame.stack_size + 4;
d668 2
@


1.11
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c: Use get_frame_pc and deprecated_update_frame_pc_hack
	frame accessor methods.
	* alpha-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Ditto.
	* s390-tdep.c, sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* z8k-tdep.c: Ditto.
@
text
@d156 1
a156 1
	    fi->frame = read_sp ();
d163 1
a163 1
	    fi->frame = read_sp ();
d173 1
a173 1
	fi->frame = read_sp ();
d190 1
a190 1
	fi->frame = read_sp ();
d221 1
a221 1
	    fi->frame = read_sp ();
d229 1
a229 1
	    fi->frame = read_sp ();
d248 1
a248 1
	    fi->frame = read_sp ();
d266 1
a266 1
	fi->frame = read_sp ();
d278 1
a278 1
	    fi->frame = read_sp () - stack_size;
d288 1
a288 1
	    fi->frame = read_sp ();
d298 1
a298 1
	    fi->frame = read_sp () - stack_size;
d308 1
a308 1
	    fi->frame = read_sp ();
d318 1
a318 1
	    fi->frame = read_sp () - stack_size;
d337 1
a337 1
	    fi->frame = read_sp ();
d349 1
a349 1
	    fi->frame = read_sp ();
d365 1
a365 1
	      fi->frame = read_sp () - fi->stack_size;
d378 1
a378 1
	    fi->frame = read_sp ();
d390 1
a390 1
	    fi->frame = read_sp ();
d406 1
a406 1
	      fi->frame = read_sp () - fi->stack_size;
d424 1
a424 1
	fi->frame = read_sp () - fi->stack_size;
d491 1
a491 1
	fi->frame -= outgoing_args_size;
d513 1
a513 1
    fi->frame = read_sp () - fi->stack_size;
d642 1
a642 1
  dummy_frame.frame = fi->frame;
@


1.10
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d124 1
a124 1
  pc = (fi ? fi->pc : pc);
d150 1
a150 1
  if (fi && fi->pc + 1 == func_end)
d152 1
a152 1
      status = target_read_memory (fi->pc, buf, 1);
d157 1
a157 1
	  return fi->pc;
d164 1
a164 1
	  return fi->pc;
d170 1
a170 1
  if (fi && fi->pc == func_addr)
d174 1
a174 1
      return fi->pc;
d178 1
a178 1
  stop = fi ? fi->pc : func_end;
d641 1
a641 1
  dummy_frame.pc = FRAME_SAVED_PC (fi);
d688 1
a688 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d865 1
a865 1
   that fi->pc and fi->frame will already be setup.  However, fi->frame will
d878 1
a878 1
    fi->pc = FRAME_SAVED_PC (fi->next);
@


1.9
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@d688 1
a688 1
  if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
@


1.8
log
@2002-07-26  Andrew Cagney  <ac131313@@redhat.com>

* z8k-tdep.c: Do not include "obstack.h".
* h8300-tdep.c, h8500-tdep.c: Ditto.
* m68hc11-tdep.c, sh-tdep.c: Ditto.
* valprint.c, v850-tdep.c: Ditto.
* d10v-tdep.c, mn10300-tdep.c: Ditto.
* mn10200-tdep.c: Ditto.

* Makefile.in (z8k-tdep.o): Update dependencies.
(m68hc11-tdep.o, valprint.o): Ditto.
(v850-tdep.o, d10v-tdep.o): Ditto.
(mn10300-tdep.o, sparc-tdep.o): Ditto.
(sh-tdep.o, h8500-tdep.o, h8300-tdep.o): Ditto.
(m32r-tdep.o, mn10200-tdep.o): Specify dependencies.
(sh_opc_h, gdb_sim_sh_h): Define.
(elf_sh_h, elf_bfd_h): Define.
(opcode_m68hc11_h): Define.
(OPCODES_SRC, OPCODES_DIR): define.
(OPCODES): Use $(OPCODES_DIR).
(gdb_sim_d10v_h): Rename sim_d10v_h.
(gdb_sim_arm_h): Rename sim_arm_h.
@
text
@d706 1
a706 1
      write_register (SP_REGNUM, FRAME_FP (frame));
@


1.8.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.8.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d688 1
a688 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d706 1
a706 1
      write_register (SP_REGNUM, get_frame_base (frame));
@


1.8.8.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d1 891
a891 899
// OBSOLETE /* Target-dependent code for the Matsushita MN10200 for GDB, the GNU debugger.
// OBSOLETE 
// OBSOLETE    Copyright 1997, 1998, 1999, 2000, 2001, 2003 Free Software
// OBSOLETE    Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "bfd.h"
// OBSOLETE #include "gdb_string.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "symfile.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Should call_function allocate stack space for a struct return?  */
// OBSOLETE int
// OBSOLETE mn10200_use_struct_convention (int gcc_p, struct type *type)
// OBSOLETE {
// OBSOLETE   return (TYPE_NFIELDS (type) > 1 || TYPE_LENGTH (type) > 8);
// OBSOLETE }
// OBSOLETE /* *INDENT-OFF* */
// OBSOLETE /* The main purpose of this file is dealing with prologues to extract
// OBSOLETE    information about stack frames and saved registers.
// OBSOLETE 
// OBSOLETE    For reference here's how prologues look on the mn10200:
// OBSOLETE 
// OBSOLETE      With frame pointer:
// OBSOLETE 	mov fp,a0
// OBSOLETE 	mov sp,fp
// OBSOLETE 	add <size>,sp
// OBSOLETE 	Register saves for d2, d3, a1, a2 as needed.  Saves start
// OBSOLETE 	at fp - <size> + <outgoing_args_size> and work towards higher
// OBSOLETE 	addresses.  Note that the saves are actually done off the stack
// OBSOLETE 	pointer in the prologue!  This makes for smaller code and easier
// OBSOLETE 	prologue scanning as the displacement fields will unlikely
// OBSOLETE         be more than 8 bits!
// OBSOLETE 
// OBSOLETE      Without frame pointer:
// OBSOLETE         add <size>,sp
// OBSOLETE 	Register saves for d2, d3, a1, a2 as needed.  Saves start
// OBSOLETE 	at sp + <outgoing_args_size> and work towards higher addresses.
// OBSOLETE 
// OBSOLETE      Out of line prologue:
// OBSOLETE 	add <local size>,sp  -- optional
// OBSOLETE 	jsr __prologue
// OBSOLETE 	add <outgoing_size>,sp -- optional
// OBSOLETE 
// OBSOLETE    The stack pointer remains constant throughout the life of most
// OBSOLETE    functions.  As a result the compiler will usually omit the
// OBSOLETE    frame pointer, so we must handle frame pointerless functions.  */
// OBSOLETE 
// OBSOLETE /* Analyze the prologue to determine where registers are saved,
// OBSOLETE    the end of the prologue, etc etc.  Return the end of the prologue
// OBSOLETE    scanned.
// OBSOLETE 
// OBSOLETE    We store into FI (if non-null) several tidbits of information:
// OBSOLETE 
// OBSOLETE     * stack_size -- size of this stack frame.  Note that if we stop in
// OBSOLETE     certain parts of the prologue/epilogue we may claim the size of the
// OBSOLETE     current frame is zero.  This happens when the current frame has
// OBSOLETE     not been allocated yet or has already been deallocated.
// OBSOLETE 
// OBSOLETE     * fsr -- Addresses of registers saved in the stack by this frame.
// OBSOLETE 
// OBSOLETE     * status -- A (relatively) generic status indicator.  It's a bitmask
// OBSOLETE     with the following bits: 
// OBSOLETE 
// OBSOLETE       MY_FRAME_IN_SP: The base of the current frame is actually in
// OBSOLETE       the stack pointer.  This can happen for frame pointerless
// OBSOLETE       functions, or cases where we're stopped in the prologue/epilogue
// OBSOLETE       itself.  For these cases mn10200_analyze_prologue will need up
// OBSOLETE       update fi->frame before returning or analyzing the register
// OBSOLETE       save instructions.
// OBSOLETE 
// OBSOLETE       MY_FRAME_IN_FP: The base of the current frame is in the
// OBSOLETE       frame pointer register ($a2).
// OBSOLETE 
// OBSOLETE       CALLER_A2_IN_A0: $a2 from the caller's frame is temporarily
// OBSOLETE       in $a0.  This can happen if we're stopped in the prologue.
// OBSOLETE 
// OBSOLETE       NO_MORE_FRAMES: Set this if the current frame is "start" or
// OBSOLETE       if the first instruction looks like mov <imm>,sp.  This tells
// OBSOLETE       frame chain to not bother trying to unwind past this frame.  */
// OBSOLETE /* *INDENT-ON* */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE #define MY_FRAME_IN_SP 0x1
// OBSOLETE #define MY_FRAME_IN_FP 0x2
// OBSOLETE #define CALLER_A2_IN_A0 0x4
// OBSOLETE #define NO_MORE_FRAMES 0x8
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE mn10200_analyze_prologue (struct frame_info *fi, CORE_ADDR pc)
// OBSOLETE {
// OBSOLETE   CORE_ADDR func_addr, func_end, addr, stop;
// OBSOLETE   CORE_ADDR stack_size = 0;
// OBSOLETE   unsigned char buf[4];
// OBSOLETE   int status;
// OBSOLETE   char *name;
// OBSOLETE   int out_of_line_prologue = 0;
// OBSOLETE 
// OBSOLETE   /* Use the PC in the frame if it's provided to look up the
// OBSOLETE      start of this function.  */
// OBSOLETE   pc = (fi ? get_frame_pc (fi) : pc);
// OBSOLETE 
// OBSOLETE   /* Find the start of this function.  */
// OBSOLETE   status = find_pc_partial_function (pc, &name, &func_addr, &func_end);
// OBSOLETE 
// OBSOLETE   /* Do nothing if we couldn't find the start of this function or if we're
// OBSOLETE      stopped at the first instruction in the prologue.  */
// OBSOLETE   if (status == 0)
// OBSOLETE     return pc;
// OBSOLETE 
// OBSOLETE   /* If we're in start, then give up.  */
// OBSOLETE   if (strcmp (name, "start") == 0)
// OBSOLETE     {
// OBSOLETE       if (fi)
// OBSOLETE 	fi->status = NO_MORE_FRAMES;
// OBSOLETE       return pc;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* At the start of a function our frame is in the stack pointer.  */
// OBSOLETE   if (fi)
// OBSOLETE     fi->status = MY_FRAME_IN_SP;
// OBSOLETE 
// OBSOLETE   /* If we're physically on an RTS instruction, then our frame has already
// OBSOLETE      been deallocated.
// OBSOLETE 
// OBSOLETE      fi->frame is bogus, we need to fix it.  */
// OBSOLETE   if (fi && get_frame_pc (fi) + 1 == func_end)
// OBSOLETE     {
// OBSOLETE       status = target_read_memory (get_frame_pc (fi), buf, 1);
// OBSOLETE       if (status != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (get_next_frame (fi) == NULL)
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return get_frame_pc (fi);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (buf[0] == 0xfe)
// OBSOLETE 	{
// OBSOLETE 	  if (get_next_frame (fi) == NULL)
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return get_frame_pc (fi);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Similarly if we're stopped on the first insn of a prologue as our
// OBSOLETE      frame hasn't been allocated yet.  */
// OBSOLETE   if (fi && get_frame_pc (fi) == func_addr)
// OBSOLETE     {
// OBSOLETE       if (get_next_frame (fi) == NULL)
// OBSOLETE 	deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE       return get_frame_pc (fi);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Figure out where to stop scanning.  */
// OBSOLETE   stop = fi ? get_frame_pc (fi) : func_end;
// OBSOLETE 
// OBSOLETE   /* Don't walk off the end of the function.  */
// OBSOLETE   stop = stop > func_end ? func_end : stop;
// OBSOLETE 
// OBSOLETE   /* Start scanning on the first instruction of this function.  */
// OBSOLETE   addr = func_addr;
// OBSOLETE 
// OBSOLETE   status = target_read_memory (addr, buf, 2);
// OBSOLETE   if (status != 0)
// OBSOLETE     {
// OBSOLETE       if (fi && get_next_frame (fi) == NULL && fi->status & MY_FRAME_IN_SP)
// OBSOLETE 	deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE       return addr;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* First see if this insn sets the stack pointer; if so, it's something
// OBSOLETE      we won't understand, so quit now.   */
// OBSOLETE   if (buf[0] == 0xdf
// OBSOLETE       || (buf[0] == 0xf4 && buf[1] == 0x77))
// OBSOLETE     {
// OBSOLETE       if (fi)
// OBSOLETE 	fi->status = NO_MORE_FRAMES;
// OBSOLETE       return addr;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Now see if we have a frame pointer.
// OBSOLETE 
// OBSOLETE      Search for mov a2,a0 (0xf278)
// OBSOLETE      then       mov a3,a2 (0xf27e).  */
// OBSOLETE 
// OBSOLETE   if (buf[0] == 0xf2 && buf[1] == 0x78)
// OBSOLETE     {
// OBSOLETE       /* Our caller's $a2 will be found in $a0 now.  Note it for
// OBSOLETE          our callers.  */
// OBSOLETE       if (fi)
// OBSOLETE 	fi->status |= CALLER_A2_IN_A0;
// OBSOLETE       addr += 2;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	{
// OBSOLETE 	  /* We still haven't allocated our local stack.  Handle this
// OBSOLETE 	     as if we stopped on the first or last insn of a function.   */
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL)
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       status = target_read_memory (addr, buf, 2);
// OBSOLETE       if (status != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL)
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE       if (buf[0] == 0xf2 && buf[1] == 0x7e)
// OBSOLETE 	{
// OBSOLETE 	  addr += 2;
// OBSOLETE 
// OBSOLETE 	  /* Our frame pointer is valid now.  */
// OBSOLETE 	  if (fi)
// OBSOLETE 	    {
// OBSOLETE 	      fi->status |= MY_FRAME_IN_FP;
// OBSOLETE 	      fi->status &= ~MY_FRAME_IN_SP;
// OBSOLETE 	    }
// OBSOLETE 	  if (addr >= stop)
// OBSOLETE 	    return addr;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL)
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Next we should allocate the local frame.
// OBSOLETE 
// OBSOLETE      Search for add imm8,a3 (0xd3XX)
// OBSOLETE      or add imm16,a3 (0xf70bXXXX)
// OBSOLETE      or add imm24,a3 (0xf467XXXXXX).
// OBSOLETE 
// OBSOLETE      If none of the above was found, then this prologue has
// OBSOLETE      no stack, and therefore can't have any register saves,
// OBSOLETE      so quit now.  */
// OBSOLETE   status = target_read_memory (addr, buf, 2);
// OBSOLETE   if (status != 0)
// OBSOLETE     {
// OBSOLETE       if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE       return addr;
// OBSOLETE     }
// OBSOLETE   if (buf[0] == 0xd3)
// OBSOLETE     {
// OBSOLETE       stack_size = extract_signed_integer (&buf[1], 1);
// OBSOLETE       if (fi)
// OBSOLETE 	fi->stack_size = stack_size;
// OBSOLETE       addr += 2;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp () - stack_size);
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else if (buf[0] == 0xf7 && buf[1] == 0x0b)
// OBSOLETE     {
// OBSOLETE       status = target_read_memory (addr + 2, buf, 2);
// OBSOLETE       if (status != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE       stack_size = extract_signed_integer (buf, 2);
// OBSOLETE       if (fi)
// OBSOLETE 	fi->stack_size = stack_size;
// OBSOLETE       addr += 4;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp () - stack_size);
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else if (buf[0] == 0xf4 && buf[1] == 0x67)
// OBSOLETE     {
// OBSOLETE       status = target_read_memory (addr + 2, buf, 3);
// OBSOLETE       if (status != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE       stack_size = extract_signed_integer (buf, 3);
// OBSOLETE       if (fi)
// OBSOLETE 	fi->stack_size = stack_size;
// OBSOLETE       addr += 5;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp () - stack_size);
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Now see if we have a call to __prologue for an out of line
// OBSOLETE      prologue.  */
// OBSOLETE   status = target_read_memory (addr, buf, 2);
// OBSOLETE   if (status != 0)
// OBSOLETE     return addr;
// OBSOLETE 
// OBSOLETE   /* First check for 16bit pc-relative call to __prologue.  */
// OBSOLETE   if (buf[0] == 0xfd)
// OBSOLETE     {
// OBSOLETE       CORE_ADDR temp;
// OBSOLETE       status = target_read_memory (addr + 1, buf, 2);
// OBSOLETE       if (status != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Get the PC this instruction will branch to.  */
// OBSOLETE       temp = (extract_signed_integer (buf, 2) + addr + 3) & 0xffffff;
// OBSOLETE 
// OBSOLETE       /* Get the name of the function at the target address.  */
// OBSOLETE       status = find_pc_partial_function (temp, &name, NULL, NULL);
// OBSOLETE       if (status == 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Note if it is an out of line prologue.  */
// OBSOLETE       out_of_line_prologue = (strcmp (name, "__prologue") == 0);
// OBSOLETE 
// OBSOLETE       /* This sucks up 3 bytes of instruction space.  */
// OBSOLETE       if (out_of_line_prologue)
// OBSOLETE 	addr += 3;
// OBSOLETE 
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL)
// OBSOLETE 	    {
// OBSOLETE 	      fi->stack_size -= 16;
// OBSOLETE 	      deprecated_update_frame_base_hack (fi, read_sp () - fi->stack_size);
// OBSOLETE 	    }
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   /* Now check for the 24bit pc-relative call to __prologue.  */
// OBSOLETE   else if (buf[0] == 0xf4 && buf[1] == 0xe1)
// OBSOLETE     {
// OBSOLETE       CORE_ADDR temp;
// OBSOLETE       status = target_read_memory (addr + 2, buf, 3);
// OBSOLETE       if (status != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Get the PC this instruction will branch to.  */
// OBSOLETE       temp = (extract_signed_integer (buf, 3) + addr + 5) & 0xffffff;
// OBSOLETE 
// OBSOLETE       /* Get the name of the function at the target address.  */
// OBSOLETE       status = find_pc_partial_function (temp, &name, NULL, NULL);
// OBSOLETE       if (status == 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    deprecated_update_frame_base_hack (fi, read_sp ());
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Note if it is an out of line prologue.  */
// OBSOLETE       out_of_line_prologue = (strcmp (name, "__prologue") == 0);
// OBSOLETE 
// OBSOLETE       /* This sucks up 5 bytes of instruction space.  */
// OBSOLETE       if (out_of_line_prologue)
// OBSOLETE 	addr += 5;
// OBSOLETE 
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	{
// OBSOLETE 	  if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP))
// OBSOLETE 	    {
// OBSOLETE 	      fi->stack_size -= 16;
// OBSOLETE 	      deprecated_update_frame_base_hack (fi, read_sp () - fi->stack_size);
// OBSOLETE 	    }
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Now actually handle the out of line prologue.  */
// OBSOLETE   if (out_of_line_prologue)
// OBSOLETE     {
// OBSOLETE       int outgoing_args_size = 0;
// OBSOLETE 
// OBSOLETE       /* First adjust the stack size for this function.  The out of
// OBSOLETE          line prologue saves 4 registers (16bytes of data).  */
// OBSOLETE       if (fi)
// OBSOLETE 	fi->stack_size -= 16;
// OBSOLETE 
// OBSOLETE       /* Update fi->frame if necessary.  */
// OBSOLETE       if (fi && get_next_frame (fi) == NULL)
// OBSOLETE 	deprecated_update_frame_base_hack (fi, read_sp () - fi->stack_size);
// OBSOLETE 
// OBSOLETE       /* After the out of line prologue, there may be another
// OBSOLETE          stack adjustment for the outgoing arguments.
// OBSOLETE 
// OBSOLETE          Search for add imm8,a3 (0xd3XX)
// OBSOLETE          or     add imm16,a3 (0xf70bXXXX)
// OBSOLETE          or     add imm24,a3 (0xf467XXXXXX).  */
// OBSOLETE 
// OBSOLETE       status = target_read_memory (addr, buf, 2);
// OBSOLETE       if (status != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (fi)
// OBSOLETE 	    {
// OBSOLETE 	      fi->fsr.regs[2] = get_frame_base (fi) + fi->stack_size + 4;
// OBSOLETE 	      fi->fsr.regs[3] = get_frame_base (fi) + fi->stack_size + 8;
// OBSOLETE 	      fi->fsr.regs[5] = get_frame_base (fi) + fi->stack_size + 12;
// OBSOLETE 	      fi->fsr.regs[6] = get_frame_base (fi) + fi->stack_size + 16;
// OBSOLETE 	    }
// OBSOLETE 	  return addr;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (buf[0] == 0xd3)
// OBSOLETE 	{
// OBSOLETE 	  outgoing_args_size = extract_signed_integer (&buf[1], 1);
// OBSOLETE 	  addr += 2;
// OBSOLETE 	}
// OBSOLETE       else if (buf[0] == 0xf7 && buf[1] == 0x0b)
// OBSOLETE 	{
// OBSOLETE 	  status = target_read_memory (addr + 2, buf, 2);
// OBSOLETE 	  if (status != 0)
// OBSOLETE 	    {
// OBSOLETE 	      if (fi)
// OBSOLETE 		{
// OBSOLETE 		  fi->fsr.regs[2] = get_frame_base (fi) + fi->stack_size + 4;
// OBSOLETE 		  fi->fsr.regs[3] = get_frame_base (fi) + fi->stack_size + 8;
// OBSOLETE 		  fi->fsr.regs[5] = get_frame_base (fi) + fi->stack_size + 12;
// OBSOLETE 		  fi->fsr.regs[6] = get_frame_base (fi) + fi->stack_size + 16;
// OBSOLETE 		}
// OBSOLETE 	      return addr;
// OBSOLETE 	    }
// OBSOLETE 	  outgoing_args_size = extract_signed_integer (buf, 2);
// OBSOLETE 	  addr += 4;
// OBSOLETE 	}
// OBSOLETE       else if (buf[0] == 0xf4 && buf[1] == 0x67)
// OBSOLETE 	{
// OBSOLETE 	  status = target_read_memory (addr + 2, buf, 3);
// OBSOLETE 	  if (status != 0)
// OBSOLETE 	    {
// OBSOLETE 	      if (fi && get_next_frame (fi) == NULL)
// OBSOLETE 		{
// OBSOLETE 		  fi->fsr.regs[2] = get_frame_base (fi) + fi->stack_size + 4;
// OBSOLETE 		  fi->fsr.regs[3] = get_frame_base (fi) + fi->stack_size + 8;
// OBSOLETE 		  fi->fsr.regs[5] = get_frame_base (fi) + fi->stack_size + 12;
// OBSOLETE 		  fi->fsr.regs[6] = get_frame_base (fi) + fi->stack_size + 16;
// OBSOLETE 		}
// OBSOLETE 	      return addr;
// OBSOLETE 	    }
// OBSOLETE 	  outgoing_args_size = extract_signed_integer (buf, 3);
// OBSOLETE 	  addr += 5;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	outgoing_args_size = 0;
// OBSOLETE 
// OBSOLETE       /* Now that we know the size of the outgoing arguments, fix
// OBSOLETE          fi->frame again if this is the innermost frame.  */
// OBSOLETE       if (fi && get_next_frame (fi) == NULL)
// OBSOLETE 	deprecated_update_frame_base_hack (fi, get_frame_base (fi) - outgoing_args_size);
// OBSOLETE 
// OBSOLETE       /* Note the register save information and update the stack
// OBSOLETE          size for this frame too.  */
// OBSOLETE       if (fi)
// OBSOLETE 	{
// OBSOLETE 	  fi->fsr.regs[2] = get_frame_base (fi) + fi->stack_size + 4;
// OBSOLETE 	  fi->fsr.regs[3] = get_frame_base (fi) + fi->stack_size + 8;
// OBSOLETE 	  fi->fsr.regs[5] = get_frame_base (fi) + fi->stack_size + 12;
// OBSOLETE 	  fi->fsr.regs[6] = get_frame_base (fi) + fi->stack_size + 16;
// OBSOLETE 	  fi->stack_size += outgoing_args_size;
// OBSOLETE 	}
// OBSOLETE       /* There can be no more prologue insns, so return now.  */
// OBSOLETE       return addr;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* At this point fi->frame needs to be correct.
// OBSOLETE 
// OBSOLETE      If MY_FRAME_IN_SP is set and we're the innermost frame, then we
// OBSOLETE      need to fix fi->frame so that backtracing, find_frame_saved_regs,
// OBSOLETE      etc work correctly.  */
// OBSOLETE   if (fi && get_next_frame (fi) == NULL && (fi->status & MY_FRAME_IN_SP) != 0)
// OBSOLETE     deprecated_update_frame_base_hack (fi, read_sp () - fi->stack_size);
// OBSOLETE 
// OBSOLETE   /* And last we have the register saves.  These are relatively
// OBSOLETE      simple because they're physically done off the stack pointer,
// OBSOLETE      and thus the number of different instructions we need to
// OBSOLETE      check is greatly reduced because we know the displacements
// OBSOLETE      will be small.
// OBSOLETE 
// OBSOLETE      Search for movx d2,(X,a3) (0xf55eXX)
// OBSOLETE      then       movx d3,(X,a3) (0xf55fXX)
// OBSOLETE      then       mov  a1,(X,a3) (0x5dXX)    No frame pointer case
// OBSOLETE      then       mov  a2,(X,a3) (0x5eXX)    No frame pointer case
// OBSOLETE      or  mov  a0,(X,a3) (0x5cXX)           Frame pointer case.  */
// OBSOLETE 
// OBSOLETE   status = target_read_memory (addr, buf, 2);
// OBSOLETE   if (status != 0)
// OBSOLETE     return addr;
// OBSOLETE   if (buf[0] == 0xf5 && buf[1] == 0x5e)
// OBSOLETE     {
// OBSOLETE       if (fi)
// OBSOLETE 	{
// OBSOLETE 	  status = target_read_memory (addr + 2, buf, 1);
// OBSOLETE 	  if (status != 0)
// OBSOLETE 	    return addr;
// OBSOLETE 	  fi->fsr.regs[2] = (get_frame_base (fi) + stack_size
// OBSOLETE 			     + extract_signed_integer (buf, 1));
// OBSOLETE 	}
// OBSOLETE       addr += 3;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	return addr;
// OBSOLETE       status = target_read_memory (addr, buf, 2);
// OBSOLETE       if (status != 0)
// OBSOLETE 	return addr;
// OBSOLETE     }
// OBSOLETE   if (buf[0] == 0xf5 && buf[1] == 0x5f)
// OBSOLETE     {
// OBSOLETE       if (fi)
// OBSOLETE 	{
// OBSOLETE 	  status = target_read_memory (addr + 2, buf, 1);
// OBSOLETE 	  if (status != 0)
// OBSOLETE 	    return addr;
// OBSOLETE 	  fi->fsr.regs[3] = (get_frame_base (fi) + stack_size
// OBSOLETE 			     + extract_signed_integer (buf, 1));
// OBSOLETE 	}
// OBSOLETE       addr += 3;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	return addr;
// OBSOLETE       status = target_read_memory (addr, buf, 2);
// OBSOLETE       if (status != 0)
// OBSOLETE 	return addr;
// OBSOLETE     }
// OBSOLETE   if (buf[0] == 0x5d)
// OBSOLETE     {
// OBSOLETE       if (fi)
// OBSOLETE 	{
// OBSOLETE 	  status = target_read_memory (addr + 1, buf, 1);
// OBSOLETE 	  if (status != 0)
// OBSOLETE 	    return addr;
// OBSOLETE 	  fi->fsr.regs[5] = (get_frame_base (fi) + stack_size
// OBSOLETE 			     + extract_signed_integer (buf, 1));
// OBSOLETE 	}
// OBSOLETE       addr += 2;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	return addr;
// OBSOLETE       status = target_read_memory (addr, buf, 2);
// OBSOLETE       if (status != 0)
// OBSOLETE 	return addr;
// OBSOLETE     }
// OBSOLETE   if (buf[0] == 0x5e || buf[0] == 0x5c)
// OBSOLETE     {
// OBSOLETE       if (fi)
// OBSOLETE 	{
// OBSOLETE 	  status = target_read_memory (addr + 1, buf, 1);
// OBSOLETE 	  if (status != 0)
// OBSOLETE 	    return addr;
// OBSOLETE 	  fi->fsr.regs[6] = (get_frame_base (fi) + stack_size
// OBSOLETE 			     + extract_signed_integer (buf, 1));
// OBSOLETE 	  fi->status &= ~CALLER_A2_IN_A0;
// OBSOLETE 	}
// OBSOLETE       addr += 2;
// OBSOLETE       if (addr >= stop)
// OBSOLETE 	return addr;
// OBSOLETE       return addr;
// OBSOLETE     }
// OBSOLETE   return addr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: frame_chain
// OBSOLETE    Figure out and return the caller's frame pointer given current
// OBSOLETE    frame_info struct.
// OBSOLETE 
// OBSOLETE    We don't handle dummy frames yet but we would probably just return the
// OBSOLETE    stack pointer that was in use at the time the function call was made?  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE mn10200_frame_chain (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   struct frame_info *dummy_frame = deprecated_frame_xmalloc ();
// OBSOLETE   struct cleanup *old_chain = make_cleanup (xfree, dummy_frame);
// OBSOLETE   CORE_ADDR ret;
// OBSOLETE 
// OBSOLETE   /* Walk through the prologue to determine the stack size,
// OBSOLETE      location of saved registers, end of the prologue, etc.  */
// OBSOLETE   if (fi->status == 0)
// OBSOLETE     mn10200_analyze_prologue (fi, (CORE_ADDR) 0);
// OBSOLETE 
// OBSOLETE   /* Quit now if mn10200_analyze_prologue set NO_MORE_FRAMES.  */
// OBSOLETE   if (fi->status & NO_MORE_FRAMES)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   /* Now that we've analyzed our prologue, determine the frame
// OBSOLETE      pointer for our caller.
// OBSOLETE 
// OBSOLETE      If our caller has a frame pointer, then we need to
// OBSOLETE      find the entry value of $a2 to our function.
// OBSOLETE 
// OBSOLETE      If CALLER_A2_IN_A0, then the chain is in $a0.
// OBSOLETE 
// OBSOLETE      If fsr.regs[6] is nonzero, then it's at the memory
// OBSOLETE      location pointed to by fsr.regs[6].
// OBSOLETE 
// OBSOLETE      Else it's still in $a2.
// OBSOLETE 
// OBSOLETE      If our caller does not have a frame pointer, then his
// OBSOLETE      frame base is fi->frame + -caller's stack size + 4.  */
// OBSOLETE 
// OBSOLETE   /* The easiest way to get that info is to analyze our caller's frame.
// OBSOLETE 
// OBSOLETE      So we set up a dummy frame and call mn10200_analyze_prologue to
// OBSOLETE      find stuff for us.  */
// OBSOLETE   deprecated_update_frame_pc_hack (dummy_frame, FRAME_SAVED_PC (fi));
// OBSOLETE   deprecated_update_frame_base_hack (dummy_frame, get_frame_base (fi));
// OBSOLETE   memset (dummy_frame->fsr.regs, '\000', sizeof dummy_frame->fsr.regs);
// OBSOLETE   dummy_frame->status = 0;
// OBSOLETE   dummy_frame->stack_size = 0;
// OBSOLETE   mn10200_analyze_prologue (dummy_frame, 0);
// OBSOLETE 
// OBSOLETE   if (dummy_frame->status & MY_FRAME_IN_FP)
// OBSOLETE     {
// OBSOLETE       /* Our caller has a frame pointer.  So find the frame in $a2, $a0,
// OBSOLETE          or in the stack.  */
// OBSOLETE       if (fi->fsr.regs[6])
// OBSOLETE 	ret = (read_memory_integer (fi->fsr.regs[FP_REGNUM], REGISTER_SIZE)
// OBSOLETE 	       & 0xffffff);
// OBSOLETE       else if (fi->status & CALLER_A2_IN_A0)
// OBSOLETE 	ret = read_register (4);
// OBSOLETE       else
// OBSOLETE 	ret = read_register (FP_REGNUM);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* Our caller does not have a frame pointer.  So his frame starts
// OBSOLETE          at the base of our frame (fi->frame) + <his size> + 4 (saved pc).  */
// OBSOLETE       ret = get_frame_base (fi) + -dummy_frame->stack_size + 4;
// OBSOLETE     }
// OBSOLETE   do_cleanups (old_chain);
// OBSOLETE   return ret;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: skip_prologue
// OBSOLETE    Return the address of the first inst past the prologue of the function.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE mn10200_skip_prologue (CORE_ADDR pc)
// OBSOLETE {
// OBSOLETE   /* We used to check the debug symbols, but that can lose if
// OBSOLETE      we have a null prologue.  */
// OBSOLETE   return mn10200_analyze_prologue (NULL, pc);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: pop_frame
// OBSOLETE    This routine gets called when either the user uses the `return'
// OBSOLETE    command, or the call dummy breakpoint gets hit.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE mn10200_pop_frame (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   int regnum;
// OBSOLETE 
// OBSOLETE   if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
// OBSOLETE 				   get_frame_base (frame),
// OBSOLETE 				   get_frame_base (frame)))
// OBSOLETE     generic_pop_dummy_frame ();
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       write_register (PC_REGNUM, FRAME_SAVED_PC (frame));
// OBSOLETE 
// OBSOLETE       /* Restore any saved registers.  */
// OBSOLETE       for (regnum = 0; regnum < NUM_REGS; regnum++)
// OBSOLETE 	if (frame->fsr.regs[regnum] != 0)
// OBSOLETE 	  {
// OBSOLETE 	    ULONGEST value;
// OBSOLETE 
// OBSOLETE 	    value = read_memory_unsigned_integer (frame->fsr.regs[regnum],
// OBSOLETE 						REGISTER_RAW_SIZE (regnum));
// OBSOLETE 	    write_register (regnum, value);
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE       /* Actually cut back the stack.  */
// OBSOLETE       write_register (SP_REGNUM, get_frame_base (frame));
// OBSOLETE 
// OBSOLETE       /* Don't we need to set the PC?!?  XXX FIXME.  */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Throw away any cached frame information.  */
// OBSOLETE   flush_cached_frames ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: push_arguments
// OBSOLETE    Setup arguments for a call to the target.  Arguments go in
// OBSOLETE    order on the stack.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE mn10200_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
// OBSOLETE 			unsigned char struct_return, CORE_ADDR struct_addr)
// OBSOLETE {
// OBSOLETE   int argnum = 0;
// OBSOLETE   int len = 0;
// OBSOLETE   int stack_offset = 0;
// OBSOLETE   int regsused = struct_return ? 1 : 0;
// OBSOLETE 
// OBSOLETE   /* This should be a nop, but align the stack just in case something
// OBSOLETE      went wrong.  Stacks are two byte aligned on the mn10200.  */
// OBSOLETE   sp &= ~1;
// OBSOLETE 
// OBSOLETE   /* Now make space on the stack for the args.
// OBSOLETE 
// OBSOLETE      XXX This doesn't appear to handle pass-by-invisible reference
// OBSOLETE      arguments.  */
// OBSOLETE   for (argnum = 0; argnum < nargs; argnum++)
// OBSOLETE     {
// OBSOLETE       int arg_length = (TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 1) & ~1;
// OBSOLETE 
// OBSOLETE       /* If we've used all argument registers, then this argument is
// OBSOLETE          pushed.  */
// OBSOLETE       if (regsused >= 2 || arg_length > 4)
// OBSOLETE 	{
// OBSOLETE 	  regsused = 2;
// OBSOLETE 	  len += arg_length;
// OBSOLETE 	}
// OBSOLETE       /* We know we've got some arg register space left.  If this argument
// OBSOLETE          will fit entirely in regs, then put it there.  */
// OBSOLETE       else if (arg_length <= 2
// OBSOLETE 	       || TYPE_CODE (VALUE_TYPE (args[argnum])) == TYPE_CODE_PTR)
// OBSOLETE 	{
// OBSOLETE 	  regsused++;
// OBSOLETE 	}
// OBSOLETE       else if (regsused == 0)
// OBSOLETE 	{
// OBSOLETE 	  regsused = 2;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  regsused = 2;
// OBSOLETE 	  len += arg_length;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Allocate stack space.  */
// OBSOLETE   sp -= len;
// OBSOLETE 
// OBSOLETE   regsused = struct_return ? 1 : 0;
// OBSOLETE   /* Push all arguments onto the stack. */
// OBSOLETE   for (argnum = 0; argnum < nargs; argnum++)
// OBSOLETE     {
// OBSOLETE       int len;
// OBSOLETE       char *val;
// OBSOLETE 
// OBSOLETE       /* XXX Check this.  What about UNIONS?  */
// OBSOLETE       if (TYPE_CODE (VALUE_TYPE (*args)) == TYPE_CODE_STRUCT
// OBSOLETE 	  && TYPE_LENGTH (VALUE_TYPE (*args)) > 8)
// OBSOLETE 	{
// OBSOLETE 	  /* XXX Wrong, we want a pointer to this argument.  */
// OBSOLETE 	  len = TYPE_LENGTH (VALUE_TYPE (*args));
// OBSOLETE 	  val = (char *) VALUE_CONTENTS (*args);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  len = TYPE_LENGTH (VALUE_TYPE (*args));
// OBSOLETE 	  val = (char *) VALUE_CONTENTS (*args);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (regsused < 2
// OBSOLETE 	  && (len <= 2
// OBSOLETE 	      || TYPE_CODE (VALUE_TYPE (*args)) == TYPE_CODE_PTR))
// OBSOLETE 	{
// OBSOLETE 	  write_register (regsused, extract_unsigned_integer (val, 4));
// OBSOLETE 	  regsused++;
// OBSOLETE 	}
// OBSOLETE       else if (regsused == 0 && len == 4)
// OBSOLETE 	{
// OBSOLETE 	  write_register (regsused, extract_unsigned_integer (val, 2));
// OBSOLETE 	  write_register (regsused + 1, extract_unsigned_integer (val + 2, 2));
// OBSOLETE 	  regsused = 2;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  regsused = 2;
// OBSOLETE 	  while (len > 0)
// OBSOLETE 	    {
// OBSOLETE 	      write_memory (sp + stack_offset, val, 2);
// OBSOLETE 
// OBSOLETE 	      len -= 2;
// OBSOLETE 	      val += 2;
// OBSOLETE 	      stack_offset += 2;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       args++;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return sp;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: push_return_address (pc)
// OBSOLETE    Set up the return address for the inferior function call.
// OBSOLETE    Needed for targets where we don't actually execute a JSR/BSR instruction */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE mn10200_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
// OBSOLETE {
// OBSOLETE   unsigned char buf[4];
// OBSOLETE 
// OBSOLETE   store_unsigned_integer (buf, 4, CALL_DUMMY_ADDRESS ());
// OBSOLETE   write_memory (sp - 4, buf, 4);
// OBSOLETE   return sp - 4;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: store_struct_return (addr,sp)
// OBSOLETE    Store the structure value return address for an inferior function
// OBSOLETE    call.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE mn10200_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
// OBSOLETE {
// OBSOLETE   /* The structure return address is passed as the first argument.  */
// OBSOLETE   write_register (0, addr);
// OBSOLETE   return sp;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: frame_saved_pc 
// OBSOLETE    Find the caller of this frame.  We do this by seeing if RP_REGNUM
// OBSOLETE    is saved in the stack anywhere, otherwise we get it from the
// OBSOLETE    registers.  If the inner frame is a dummy frame, return its PC
// OBSOLETE    instead of RP, because that's where "caller" of the dummy-frame
// OBSOLETE    will be found.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE mn10200_frame_saved_pc (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   /* The saved PC will always be at the base of the current frame.  */
// OBSOLETE   return (read_memory_integer (get_frame_base (fi), REGISTER_SIZE) & 0xffffff);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: init_extra_frame_info
// OBSOLETE    Setup the frame's frame pointer, pc, and frame addresses for saved
// OBSOLETE    registers.  Most of the work is done in mn10200_analyze_prologue().
// OBSOLETE 
// OBSOLETE    Note that when we are called for the last frame (currently active frame),
// OBSOLETE    that get_frame_pc (fi) and fi->frame will already be setup.  However, fi->frame will
// OBSOLETE    be valid only if this routine uses FP.  For previous frames, fi-frame will
// OBSOLETE    always be correct.  mn10200_analyze_prologue will fix fi->frame if
// OBSOLETE    it's not valid.
// OBSOLETE 
// OBSOLETE    We can be called with the PC in the call dummy under two circumstances.
// OBSOLETE    First, during normal backtracing, second, while figuring out the frame
// OBSOLETE    pointer just prior to calling the target function (see run_stack_dummy).  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE mn10200_init_extra_frame_info (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   if (get_next_frame (fi))
// OBSOLETE     deprecated_update_frame_pc_hack (fi, FRAME_SAVED_PC (get_next_frame (fi)));
// OBSOLETE 
// OBSOLETE   memset (fi->fsr.regs, '\000', sizeof fi->fsr.regs);
// OBSOLETE   fi->status = 0;
// OBSOLETE   fi->stack_size = 0;
// OBSOLETE 
// OBSOLETE   mn10200_analyze_prologue (fi, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_mn10200_tdep (void)
// OBSOLETE {
// OBSOLETE   tm_print_insn = print_insn_mn10200;
// OBSOLETE }
@


1.8.8.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@@


1.7
log
@s/value_ptr/struct value */
@
text
@a23 1
#include "obstack.h"
@


1.7.14.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d24 1
@


1.6
log
@Gag -Wuninitialized warnings.
Add -Wuninitialized to default warning list.
@
text
@d721 1
a721 1
mn10200_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
@


1.5
log
@Update/correct copyright notices.
@
text
@d117 1
a117 1
  CORE_ADDR stack_size;
@


1.4
log
@From 2001-03-01 Tom Rix <trix@@redhat.com>:
* mn10200-tdep.c (mn10200_frame_chain): Pass 0 for ``pc''
parameter to mn10200_analyze_prologue.
* config/mn10200/tm-mn10200.h: Include "regcache.h".
* MAINTAINERS: Document that mn10200-elf target is buildable.
@
text
@d2 1
a2 1
   Copyright 1997, 2001 Free Software Foundation, Inc.
@


1.3
log
@Create new file regcache.h.  Update all uses.
@
text
@d647 1
a647 1
  mn10200_analyze_prologue (&dummy_frame);
@


1.2
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright 1997 Free Software Foundation, Inc.
d31 1
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d32 1
a32 1
  	
d35 1
a35 3
mn10200_use_struct_convention (gcc_p, type)
     int gcc_p;
     struct type *type;
d39 1
a39 3



d102 4
d111 1
a111 1
 
d113 1
a113 3
mn10200_analyze_prologue (fi, pc)
    struct frame_info *fi;
    CORE_ADDR pc;
d138 1
a138 1
        fi->status = NO_MORE_FRAMES;
d205 1
a205 1
       
d207 1
a207 1
        then	mov a3,a2 (0xf27e).  */
d212 1
a212 1
	 our callers.  */
d254 1
a254 1
       
d256 3
a258 3
        or	add imm16,a3 (0xf70bXXXX)
        or	add imm24,a3 (0xf467XXXXXX).
       
d336 2
a337 2
  	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
    	    fi->frame = read_sp ();
d340 1
a340 1
      
d348 2
a349 2
  	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
    	    fi->frame = read_sp ();
d377 2
a378 2
  	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
    	    fi->frame = read_sp ();
d381 1
a381 1
      
d389 2
a390 2
  	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
    	    fi->frame = read_sp ();
d418 1
a418 1
	 line prologue saves 4 registers (16bytes of data).  */
d427 5
a431 1
	 stack adjustment for the outgoing arguments.
a432 4
	 Search for add imm8,a3 (0xd3XX)
	    or	add imm16,a3 (0xf70bXXXX)
	    or	add imm24,a3 (0xf467XXXXXX).  */
       
d489 1
a489 1
	 fi->frame again if this is the innermost frame.  */
d494 1
a494 1
	 size for this frame too.  */
d520 1
a520 1
       
d522 4
a525 4
        then	movx d3,(X,a3) (0xf55fXX)
        then	mov  a1,(X,a3) (0x5dXX)	   No frame pointer case
        then	mov  a2,(X,a3) (0x5eXX)	   No frame pointer case
        or  mov  a0,(X,a3) (0x5cXX)	   Frame pointer case.  */
d599 1
a599 1
  
d608 1
a608 2
mn10200_frame_chain (fi)
     struct frame_info *fi;
d615 1
a615 1
    mn10200_analyze_prologue (fi, (CORE_ADDR)0);
d624 2
a625 2
       If our caller has a frame pointer, then we need to
       find the entry value of $a2 to our function.
d627 1
a627 1
	 If CALLER_A2_IN_A0, then the chain is in $a0.
d629 2
a630 2
	 If fsr.regs[6] is nonzero, then it's at the memory
	 location pointed to by fsr.regs[6].
d632 4
a635 1
	 Else it's still in $a2.
a636 3
       If our caller does not have a frame pointer, then his
       frame base is fi->frame + -caller's stack size + 4.  */
       
d651 1
a651 1
	 or in the stack.  */
d663 1
a663 1
	 at the base of our frame (fi->frame) + <his size> + 4 (saved pc).  */
d672 1
a672 2
mn10200_skip_prologue (pc)
     CORE_ADDR pc;
d684 1
a684 2
mn10200_pop_frame (frame)
     struct frame_info *frame;
d688 1
a688 1
  if (PC_IN_CALL_DUMMY(frame->pc, frame->frame, frame->frame))
d701 1
a701 1
						  REGISTER_RAW_SIZE (regnum));
d720 2
a721 6
mn10200_push_arguments (nargs, args, sp, struct_return, struct_addr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     unsigned char struct_return;
     CORE_ADDR struct_addr;
d741 1
a741 1
	 pushed.  */
d748 1
a748 1
	 will fit entirely in regs, then put it there.  */
d750 1
a750 1
	       || TYPE_CODE (VALUE_TYPE (args[argnum])) == TYPE_CODE_PTR) 
d780 2
a781 2
          len = TYPE_LENGTH (VALUE_TYPE (*args));
          val = (char *)VALUE_CONTENTS (*args);
d786 1
a786 1
	  val = (char *)VALUE_CONTENTS (*args);
d823 1
a823 1
 
d825 1
a825 3
mn10200_push_return_address (pc, sp)
     CORE_ADDR pc;
     CORE_ADDR sp;
d837 1
a837 1
 
d839 1
a839 3
mn10200_store_struct_return (addr, sp)
     CORE_ADDR addr;
     CORE_ADDR sp;
d845 1
a845 1
 
d854 1
a854 2
mn10200_frame_saved_pc (fi)
     struct frame_info *fi;
a859 13
void
get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lval)
     char *raw_buffer;
     int *optimized;
     CORE_ADDR *addrp;
     struct frame_info *frame;
     int regnum;
     enum lval_type *lval;
{
  generic_get_saved_register (raw_buffer, optimized, addrp, 
			      frame, regnum, lval);
}

d875 1
a875 2
mn10200_init_extra_frame_info (fi)
     struct frame_info *fi;
d888 1
a888 1
_initialize_mn10200_tdep ()
a891 1

@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d873 13
@


1.1.1.3
log
@import gdb-1999-07-07 pre reformat
@
text
@d42 1
a42 1
/* *INDENT-OFF* */
a104 1
/* *INDENT-ON* */
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d31 1
a31 1

d40 2
a106 3



d111 1
a111 1

d114 2
a115 2
     struct frame_info *fi;
     CORE_ADDR pc;
d140 1
a140 1
	fi->status = NO_MORE_FRAMES;
d207 1
a207 1

d209 1
a209 1
     then       mov a3,a2 (0xf27e).  */
d214 1
a214 1
         our callers.  */
d256 1
a256 1

d258 3
a260 3
     or add imm16,a3 (0xf70bXXXX)
     or add imm24,a3 (0xf467XXXXXX).

d338 2
a339 2
	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
	    fi->frame = read_sp ();
d342 1
a342 1

d350 2
a351 2
	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
	    fi->frame = read_sp ();
d379 2
a380 2
	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
	    fi->frame = read_sp ();
d383 1
a383 1

d391 2
a392 2
	  if (fi && fi->next == NULL && (fi->status & MY_FRAME_IN_SP))
	    fi->frame = read_sp ();
d420 1
a420 1
         line prologue saves 4 registers (16bytes of data).  */
d429 1
a429 5
         stack adjustment for the outgoing arguments.

         Search for add imm8,a3 (0xd3XX)
         or     add imm16,a3 (0xf70bXXXX)
         or     add imm24,a3 (0xf467XXXXXX).  */
d431 4
d491 1
a491 1
         fi->frame again if this is the innermost frame.  */
d496 1
a496 1
         size for this frame too.  */
d522 1
a522 1

d524 4
a527 4
     then       movx d3,(X,a3) (0xf55fXX)
     then       mov  a1,(X,a3) (0x5dXX)    No frame pointer case
     then       mov  a2,(X,a3) (0x5eXX)    No frame pointer case
     or  mov  a0,(X,a3) (0x5cXX)           Frame pointer case.  */
d601 1
a601 1

d618 1
a618 1
    mn10200_analyze_prologue (fi, (CORE_ADDR) 0);
d627 2
a628 2
     If our caller has a frame pointer, then we need to
     find the entry value of $a2 to our function.
d630 1
a630 1
     If CALLER_A2_IN_A0, then the chain is in $a0.
d632 2
a633 2
     If fsr.regs[6] is nonzero, then it's at the memory
     location pointed to by fsr.regs[6].
d635 1
a635 4
     Else it's still in $a2.

     If our caller does not have a frame pointer, then his
     frame base is fi->frame + -caller's stack size + 4.  */
d637 3
d654 1
a654 1
         or in the stack.  */
d666 1
a666 1
         at the base of our frame (fi->frame) + <his size> + 4 (saved pc).  */
d693 1
a693 1
  if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d706 1
a706 1
						REGISTER_RAW_SIZE (regnum));
d750 1
a750 1
         pushed.  */
d757 1
a757 1
         will fit entirely in regs, then put it there.  */
d759 1
a759 1
	       || TYPE_CODE (VALUE_TYPE (args[argnum])) == TYPE_CODE_PTR)
d789 2
a790 2
	  len = TYPE_LENGTH (VALUE_TYPE (*args));
	  val = (char *) VALUE_CONTENTS (*args);
d795 1
a795 1
	  val = (char *) VALUE_CONTENTS (*args);
d832 1
a832 1

d848 1
a848 1

d858 1
a858 1

d907 1
@

