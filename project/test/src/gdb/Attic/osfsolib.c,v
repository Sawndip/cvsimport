head	1.14;
access;
symbols
	gdb_5_3-2002-12-12-release:1.13
	gdb_5_3-branch:1.13.0.14
	gdb_5_3-2002-09-04-branchpoint:1.13
	kseitz_interps-20020829-merge:1.13
	cagney_sysregs-20020825-branch:1.13.0.12
	cagney_sysregs-20020825-branchpoint:1.13
	readline_4_3-import-branch:1.13.0.10
	readline_4_3-import-branchpoint:1.13
	gdb_5_2_1-2002-07-23-release:1.13
	kseitz_interps-20020528-branch:1.13.0.8
	kseitz_interps-20020528-branchpoint:1.13
	cagney_regbuf-20020515-branch:1.13.0.6
	cagney_regbuf-20020515-branchpoint:1.13
	jimb-macro-020506-branch:1.13.0.4
	jimb-macro-020506-branchpoint:1.13
	gdb_5_2-2002-04-29-release:1.13
	gdb_5_2-branch:1.13.0.2
	gdb_5_2-2002-03-03-branchpoint:1.13
	gdb_5_1_1-2002-01-24-release:1.9.4.1
	gdb_5_1_0_1-2002-01-03-release:1.9.4.1
	cygnus_cvs_20020108_pre:1.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9.4.1
	gdb_5_1_0_1-2002-01-03-branch:1.9.4.1.0.2
	gdb_5_1-2001-11-21-release:1.9.4.1
	gdb_s390-2001-09-26-branch:1.9.0.6
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.4
	gdb_5_1-2001-07-29-branchpoint:1.9
	dberlin-typesystem-branch:1.9.0.2
	dberlin-typesystem-branchpoint:1.9
	gdb-post-ptid_t-2001-05-03:1.9
	gdb-pre-ptid_t-2001-05-03:1.8
	insight-precleanup-2001-01-01:1.7
	gdb-post-protoization-2000-07-29:1.5
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb-post-params-removal-2000-06-04:1.4
	gdb-pre-params-removal-2000-06-04:1.4
	gdb-post-params-removal-2000-05-28:1.4
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.7
	insight-2000-02-04:1.1.1.7
	gdb-2000-02-04:1.1.1.7
	gdb-2000-02-02:1.1.1.7
	gdb-2000-02-01:1.1.1.7
	gdb-2000-01-31:1.1.1.7
	gdb-2000-01-26:1.1.1.7
	gdb-2000-01-24:1.1.1.7
	gdb-2000-01-17:1.1.1.7
	gdb-2000-01-10:1.1.1.7
	gdb-2000-01-05:1.1.1.7
	gdb-1999-12-21:1.1.1.7
	gdb-1999-12-13:1.1.1.7
	gdb-1999-12-07:1.1.1.7
	gdb-1999-12-06:1.1.1.7
	gdb-1999-11-16:1.1.1.7
	gdb-1999-11-08:1.1.1.6
	gdb-1999-11-01:1.1.1.6
	gdb-1999-10-25:1.1.1.6
	gdb-1999-10-18:1.1.1.6
	gdb-1999-10-11:1.1.1.6
	gdb-1999-10-04:1.1.1.5
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.14
date	2002.09.17.04.44.21;	author brobecke;	state dead;
branches;
next	1.13;

1.13
date	2002.02.27.01.40.35;	author cagney;	state Exp;
branches
	1.13.8.1;
next	1.12;

1.12
date	2001.11.01.16.17.08;	author fnf;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.30.04.05.34;	author fnf;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.14.00.40.29;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.04.04.15.26;	author kevinb;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2001.03.06.08.21.11;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.15.01.01.48;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.27.17.43.07;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.28.01.12.28;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.27.15.11.13;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.04.02.08.52;	author hjl;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.08.37;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.09.21.33.44;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.09.28.21.52.23;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.10.05.23.08.35;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.10.12.04.37.23;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.11.17.02.30.27;	author jsm;	state Exp;
branches;
next	;

1.9.4.1
date	2001.09.27.05.03.08;	author kevinb;	state Exp;
branches;
next	;

1.13.8.1
date	2002.10.01.00.46.13;	author kseitz;	state dead;
branches;
next	;


desc
@@


1.14
log
@        * osfsolib.c: Remove file, replaced by solib-osf.c.
        * Makefile.in: Remove compilation rules for osfsolib.c.
@
text
@/* Handle OSF/1 shared libraries for GDB, the GNU Debugger.
   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2000
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* FIXME: Most of this code could be merged with solib.c by using
   next_link_map_member and xfer_link_map_member in solib.c.  */

#include "defs.h"

#include <sys/types.h>
#include <signal.h>
#include "gdb_string.h"
#include <fcntl.h>

#include "symtab.h"
#include "bfd.h"
#include "symfile.h"
#include "objfiles.h"
#include "gdbcore.h"
#include "command.h"
#include "target.h"
#include "frame.h"
#include "gdb_regex.h"
#include "inferior.h"
#include "language.h"
#include "gdbcmd.h"

#define MAX_PATH_SIZE 1024	/* FIXME: Should be dynamic */

/* When handling shared libraries, GDB has to find out the pathnames
   of all shared libraries that are currently loaded (to read in their
   symbols) and where the shared libraries are loaded in memory
   (to relocate them properly from their prelinked addresses to the
   current load address).

   Under OSF/1 there are two possibilities to get at this information:
   1) Peek around in the runtime loader structures.
   These are not documented, and they are not defined in the system
   header files. The definitions below were obtained by experimentation,
   but they seem stable enough.
   2) Use the undocumented libxproc.a library, which contains the
   equivalent ldr_* routines.
   This approach is somewhat cleaner, but it requires that the GDB
   executable is dynamically linked. In addition it requires a
   NAT_CLIBS= -lxproc -Wl,-expect_unresolved,ldr_process_context
   linker specification for GDB and all applications that are using
   libgdb.
   We will use the peeking approach until it becomes unwieldy.  */

#ifndef USE_LDR_ROUTINES

/* Definition of runtime loader structures, found by experimentation.  */
#define RLD_CONTEXT_ADDRESS	0x3ffc0000000

typedef struct
  {
    CORE_ADDR next;
    CORE_ADDR previous;
    CORE_ADDR unknown1;
    char *module_name;
    CORE_ADDR modinfo_addr;
    long module_id;
    CORE_ADDR unknown2;
    CORE_ADDR unknown3;
    long region_count;
    CORE_ADDR regioninfo_addr;
  }
ldr_module_info_t;

typedef struct
  {
    long unknown1;
    CORE_ADDR regionname_addr;
    long protection;
    CORE_ADDR vaddr;
    CORE_ADDR mapaddr;
    long size;
    long unknown2[5];
  }
ldr_region_info_t;

typedef struct
  {
    CORE_ADDR unknown1;
    CORE_ADDR unknown2;
    CORE_ADDR head;
    CORE_ADDR tail;
  }
ldr_context_t;

static ldr_context_t ldr_context;

#else

#include <loader.h>
static ldr_process_t fake_ldr_process;

/* Called by ldr_* routines to read memory from the current target.  */

static int ldr_read_memory (CORE_ADDR, char *, int, int);

static int
ldr_read_memory (CORE_ADDR memaddr, char *myaddr, int len, int readstring)
{
  int result;
  char *buffer;

  if (readstring)
    {
      target_read_string (memaddr, &buffer, len, &result);
      if (result == 0)
	strcpy (myaddr, buffer);
      xfree (buffer);
    }
  else
    result = target_read_memory (memaddr, myaddr, len);

  if (result != 0)
    result = -result;
  return result;
}

#endif

/* Define our own link_map structure.
   This will help to share code with solib.c.  */

struct link_map
{
  CORE_ADDR l_offset;		/* prelink to load address offset */
  char *l_name;			/* full name of loaded object */
  ldr_module_info_t module_info;	/* corresponding module info */
};

#define LM_OFFSET(so) ((so) -> lm.l_offset)
#define LM_NAME(so) ((so) -> lm.l_name)

struct so_list
  {
    struct so_list *next;	/* next structure in linked list */
    struct link_map lm;		/* copy of link map from inferior */
    struct link_map *lmaddr;	/* addr in inferior lm was read from */
    CORE_ADDR lmend;		/* upper addr bound of mapped object */
    char so_name[MAX_PATH_SIZE];	/* shared object lib name (FIXME) */
    char symbols_loaded;	/* flag: symbols read in yet? */
    char from_tty;		/* flag: print msgs? */
    struct objfile *objfile;	/* objfile for loaded lib */
    struct section_table *sections;
    struct section_table *sections_end;
    struct section_table *textsection;
    bfd *abfd;
  };

static struct so_list *so_list_head;	/* List of known shared objects */

extern int fdmatch (int, int);	/* In libiberty */

/* Local function prototypes */

static void sharedlibrary_command (char *, int);

static void info_sharedlibrary_command (char *, int);

static int symbol_add_stub (char *);

static struct so_list *find_solib (struct so_list *);

static struct link_map *first_link_map_member (void);

static struct link_map *next_link_map_member (struct so_list *);

static void xfer_link_map_member (struct so_list *, struct link_map *);

static int solib_map_sections (char *);

/*

   LOCAL FUNCTION

   solib_map_sections -- open bfd and build sections for shared lib

   SYNOPSIS

   static int solib_map_sections (struct so_list *so)

   DESCRIPTION

   Given a pointer to one of the shared objects in our list
   of mapped objects, use the recorded name to open a bfd
   descriptor for the object, build a section table, and then
   relocate all the section addresses by the base address at
   which the shared object was mapped.

   FIXMES

   In most (all?) cases the shared object file name recorded in the
   dynamic linkage tables will be a fully qualified pathname.  For
   cases where it isn't, do we really mimic the systems search
   mechanism correctly in the below code (particularly the tilde
   expansion stuff?).
 */

static int
solib_map_sections (char *arg)
{
  struct so_list *so = (struct so_list *) arg;	/* catch_errors bogon */
  char *filename;
  char *scratch_pathname;
  int scratch_chan;
  struct section_table *p;
  struct cleanup *old_chain;
  bfd *abfd;

  filename = tilde_expand (so->so_name);
  old_chain = make_cleanup (xfree, filename);

  scratch_chan = openp (getenv ("PATH"), 1, filename, O_RDONLY, 0,
			&scratch_pathname);
  if (scratch_chan < 0)
    {
      scratch_chan = openp (getenv ("LD_LIBRARY_PATH"), 1, filename,
			    O_RDONLY, 0, &scratch_pathname);
    }
  if (scratch_chan < 0)
    {
      perror_with_name (filename);
    }
  /* Leave scratch_pathname allocated.  bfd->name will point to it.  */

  abfd = bfd_fdopenr (scratch_pathname, gnutarget, scratch_chan);
  if (!abfd)
    {
      close (scratch_chan);
      error ("Could not open `%s' as an executable file: %s",
	     scratch_pathname, bfd_errmsg (bfd_get_error ()));
    }
  /* Leave bfd open, core_xfer_memory and "info files" need it.  */
  so->abfd = abfd;
  abfd->cacheable = 1;

  if (!bfd_check_format (abfd, bfd_object))
    {
      error ("\"%s\": not in executable format: %s.",
	     scratch_pathname, bfd_errmsg (bfd_get_error ()));
    }
  if (build_section_table (abfd, &so->sections, &so->sections_end))
    {
      error ("Can't find the file sections in `%s': %s",
	     bfd_get_filename (exec_bfd), bfd_errmsg (bfd_get_error ()));
    }

  for (p = so->sections; p < so->sections_end; p++)
    {
      /* Relocate the section binding addresses as recorded in the shared
         object's file by the offset to get the address to which the
         object was actually mapped.  */
      p->addr += LM_OFFSET (so);
      p->endaddr += LM_OFFSET (so);
      so->lmend = (CORE_ADDR) max (p->endaddr, so->lmend);
      if (STREQ (p->the_bfd_section->name, ".text"))
	{
	  so->textsection = p;
	}
    }

  /* Free the file names, close the file now.  */
  do_cleanups (old_chain);

  return (1);
}

/*

   LOCAL FUNCTION

   first_link_map_member -- locate first member in dynamic linker's map

   SYNOPSIS

   static struct link_map *first_link_map_member (void)

   DESCRIPTION

   Read in a copy of the first member in the inferior's dynamic
   link map from the inferior's dynamic linker structures, and return
   a pointer to the copy in our address space.
 */

static struct link_map *
first_link_map_member (void)
{
  struct link_map *lm = NULL;
  static struct link_map first_lm;

#ifdef USE_LDR_ROUTINES
  ldr_module_t mod_id = LDR_NULL_MODULE;
  size_t retsize;

  fake_ldr_process = ldr_core_process ();
  ldr_set_core_reader (ldr_read_memory);
  ldr_xdetach (fake_ldr_process);
  if (ldr_xattach (fake_ldr_process) != 0
      || ldr_next_module (fake_ldr_process, &mod_id) != 0
      || mod_id == LDR_NULL_MODULE
      || ldr_inq_module (fake_ldr_process, mod_id,
			 &first_lm.module_info, sizeof (ldr_module_info_t),
			 &retsize) != 0)
    return lm;
#else
  CORE_ADDR ldr_context_addr;

  if (target_read_memory ((CORE_ADDR) RLD_CONTEXT_ADDRESS,
			  (char *) &ldr_context_addr,
			  sizeof (CORE_ADDR)) != 0
      || target_read_memory (ldr_context_addr,
			     (char *) &ldr_context,
			     sizeof (ldr_context_t)) != 0
      || target_read_memory ((CORE_ADDR) ldr_context.head,
			     (char *) &first_lm.module_info,
			     sizeof (ldr_module_info_t)) != 0)
    return lm;
#endif

  lm = &first_lm;

  /* The first entry is for the main program and should be skipped.  */
  lm->l_name = NULL;

  return lm;
}

static struct link_map *
next_link_map_member (struct so_list *so_list_ptr)
{
  struct link_map *lm = NULL;
  static struct link_map next_lm;
#ifdef USE_LDR_ROUTINES
  ldr_module_t mod_id = so_list_ptr->lm.module_info.lmi_modid;
  size_t retsize;

  if (ldr_next_module (fake_ldr_process, &mod_id) != 0
      || mod_id == LDR_NULL_MODULE
      || ldr_inq_module (fake_ldr_process, mod_id,
			 &next_lm.module_info, sizeof (ldr_module_info_t),
			 &retsize) != 0)
    return lm;

  lm = &next_lm;
  lm->l_name = lm->module_info.lmi_name;
#else
  CORE_ADDR ldr_context_addr;

  /* Reread context in case ldr_context.tail was updated.  */

  if (target_read_memory ((CORE_ADDR) RLD_CONTEXT_ADDRESS,
			  (char *) &ldr_context_addr,
			  sizeof (CORE_ADDR)) != 0
      || target_read_memory (ldr_context_addr,
			     (char *) &ldr_context,
			     sizeof (ldr_context_t)) != 0
      || so_list_ptr->lm.module_info.modinfo_addr == ldr_context.tail
      || target_read_memory (so_list_ptr->lm.module_info.next,
			     (char *) &next_lm.module_info,
			     sizeof (ldr_module_info_t)) != 0)
    return lm;

  lm = &next_lm;
  lm->l_name = lm->module_info.module_name;
#endif
  return lm;
}

static void
xfer_link_map_member (struct so_list *so_list_ptr, struct link_map *lm)
{
  int i;
  so_list_ptr->lm = *lm;

  /* OSF/1 shared libraries are pre-linked to particular addresses,
     but the runtime loader may have to relocate them if the
     address ranges of the libraries used by the target executable clash,
     or if the target executable is linked with the -taso option.
     The offset is the difference between the address where the shared
     library is mapped and the pre-linked address of the shared library.

     FIXME:  GDB is currently unable to relocate the shared library
     sections by different offsets. If sections are relocated by
     different offsets, put out a warning and use the offset of the
     first section for all remaining sections.  */
  LM_OFFSET (so_list_ptr) = 0;

  /* There is one entry that has no name (for the inferior executable)
     since it is not a shared object. */
  if (LM_NAME (so_list_ptr) != 0)
    {

#ifdef USE_LDR_ROUTINES
      int len = strlen (LM_NAME (so_list_ptr) + 1);

      if (len > MAX_PATH_SIZE)
	len = MAX_PATH_SIZE;
      strncpy (so_list_ptr->so_name, LM_NAME (so_list_ptr), MAX_PATH_SIZE);
      so_list_ptr->so_name[MAX_PATH_SIZE - 1] = '\0';

      for (i = 0; i < lm->module_info.lmi_nregion; i++)
	{
	  ldr_region_info_t region_info;
	  size_t retsize;
	  CORE_ADDR region_offset;

	  if (ldr_inq_region (fake_ldr_process, lm->module_info.lmi_modid,
			      i, &region_info, sizeof (region_info),
			      &retsize) != 0)
	    break;
	  region_offset = (CORE_ADDR) region_info.lri_mapaddr
	    - (CORE_ADDR) region_info.lri_vaddr;
	  if (i == 0)
	    LM_OFFSET (so_list_ptr) = region_offset;
	  else if (LM_OFFSET (so_list_ptr) != region_offset)
	    warning ("cannot handle shared library relocation for %s (%s)",
		     so_list_ptr->so_name, region_info.lri_name);
	}
#else
      int errcode;
      char *buffer;
      target_read_string ((CORE_ADDR) LM_NAME (so_list_ptr), &buffer,
			  MAX_PATH_SIZE - 1, &errcode);
      if (errcode != 0)
	error ("xfer_link_map_member: Can't read pathname for load map: %s\n",
	       safe_strerror (errcode));
      strncpy (so_list_ptr->so_name, buffer, MAX_PATH_SIZE - 1);
      xfree (buffer);
      so_list_ptr->so_name[MAX_PATH_SIZE - 1] = '\0';

      for (i = 0; i < lm->module_info.region_count; i++)
	{
	  ldr_region_info_t region_info;
	  CORE_ADDR region_offset;

	  if (target_read_memory (lm->module_info.regioninfo_addr
				  + i * sizeof (region_info),
				  (char *) &region_info,
				  sizeof (region_info)) != 0)
	    break;
	  region_offset = region_info.mapaddr - region_info.vaddr;
	  if (i == 0)
	    LM_OFFSET (so_list_ptr) = region_offset;
	  else if (LM_OFFSET (so_list_ptr) != region_offset)
	    {
	      char *region_name;
	      target_read_string (region_info.regionname_addr, &buffer,
				  MAX_PATH_SIZE - 1, &errcode);
	      if (errcode == 0)
		region_name = buffer;
	      else
		region_name = "??";
	      warning ("cannot handle shared library relocation for %s (%s)",
		       so_list_ptr->so_name, region_name);
	      xfree (buffer);
	    }
	}
#endif

      catch_errors (solib_map_sections, (char *) so_list_ptr,
		    "Error while mapping shared library sections:\n",
		    RETURN_MASK_ALL);
    }
}

/*

   LOCAL FUNCTION

   find_solib -- step through list of shared objects

   SYNOPSIS

   struct so_list *find_solib (struct so_list *so_list_ptr)

   DESCRIPTION

   This module contains the routine which finds the names of any
   loaded "images" in the current process. The argument in must be
   NULL on the first call, and then the returned value must be passed
   in on subsequent calls. This provides the capability to "step" down
   the list of loaded objects. On the last object, a NULL value is
   returned.

   The arg and return value are "struct link_map" pointers, as defined
   in <link.h>.
 */

static struct so_list *
find_solib (struct so_list *so_list_ptr)
{
  struct so_list *so_list_next = NULL;
  struct link_map *lm = NULL;
  struct so_list *new;

  if (so_list_ptr == NULL)
    {
      /* We are setting up for a new scan through the loaded images. */
      if ((so_list_next = so_list_head) == NULL)
	{
	  /* Find the first link map list member. */
	  lm = first_link_map_member ();
	}
    }
  else
    {
      /* We have been called before, and are in the process of walking
         the shared library list.  Advance to the next shared object. */
      lm = next_link_map_member (so_list_ptr);
      so_list_next = so_list_ptr->next;
    }
  if ((so_list_next == NULL) && (lm != NULL))
    {
      /* Get next link map structure from inferior image and build a local
         abbreviated load_map structure */
      new = (struct so_list *) xmalloc (sizeof (struct so_list));
      memset ((char *) new, 0, sizeof (struct so_list));
      new->lmaddr = lm;
      /* Add the new node as the next node in the list, or as the root
         node if this is the first one. */
      if (so_list_ptr != NULL)
	{
	  so_list_ptr->next = new;
	}
      else
	{
	  so_list_head = new;
	}
      so_list_next = new;
      xfer_link_map_member (new, lm);
    }
  return (so_list_next);
}

/* A small stub to get us past the arg-passing pinhole of catch_errors.  */

static int
symbol_add_stub (char *arg)
{
  register struct so_list *so = (struct so_list *) arg;		/* catch_errs bogon */
  CORE_ADDR text_addr = 0;
  struct section_addr_info section_addrs;

  memset (&section_addrs, 0, sizeof (section_addrs));
  if (so->textsection)
    text_addr = so->textsection->addr;
  else if (so->abfd != NULL)
    {
      asection *lowest_sect;

      /* If we didn't find a mapped non zero sized .text section, set up
         text_addr so that the relocation in symbol_file_add does no harm.  */

      lowest_sect = bfd_get_section_by_name (so->abfd, ".text");
      if (lowest_sect == NULL)
	bfd_map_over_sections (so->abfd, find_lowest_section,
			       (PTR) &lowest_sect);
      if (lowest_sect)
	text_addr = bfd_section_vma (so->abfd, lowest_sect) + LM_OFFSET (so);
    }

  section_addrs.other[0].addr = text_addr;
  section_addrs.other[0].name = ".text";
  so->objfile = symbol_file_add (so->so_name, so->from_tty,
				 &section_addrs, 0, OBJF_SHARED);
  return (1);
}

/*

   GLOBAL FUNCTION

   solib_add -- add a shared library file to the symtab and section list

   SYNOPSIS

   void solib_add (char *arg_string, int from_tty,
   struct target_ops *target, int readsyms)

   DESCRIPTION

 */

void
solib_add (char *arg_string, int from_tty, struct target_ops *target, int readsyms)
{
  register struct so_list *so = NULL;	/* link map state variable */

  /* Last shared library that we read.  */
  struct so_list *so_last = NULL;

  char *re_err;
  int count;
  int old;

  if (!readsyms)
    return;

  if ((re_err = re_comp (arg_string ? arg_string : ".")) != NULL)
    {
      error ("Invalid regexp: %s", re_err);
    }


  /* Add the shared library sections to the section table of the
     specified target, if any.  */
  if (target)
    {
      /* Count how many new section_table entries there are.  */
      so = NULL;
      count = 0;
      while ((so = find_solib (so)) != NULL)
	{
	  if (so->so_name[0])
	    {
	      count += so->sections_end - so->sections;
	    }
	}

      if (count)
	{
	  /* Add these section table entries to the target's table.  */

	  old = target_resize_to_sections (target, count);
	  
	  while ((so = find_solib (so)) != NULL)
	    {
	      if (so->so_name[0])
		{
		  count = so->sections_end - so->sections;
		  memcpy ((char *) (target->to_sections + old),
			  so->sections,
			  (sizeof (struct section_table)) * count);
		  old += count;
		}
	    }
	}
    }

  /* Now add the symbol files.  */
  so = NULL;
  while ((so = find_solib (so)) != NULL)
    {
      if (so->so_name[0] && re_exec (so->so_name))
	{
	  so->from_tty = from_tty;
	  if (so->symbols_loaded)
	    {
	      if (from_tty)
		{
		  printf_unfiltered ("Symbols already loaded for %s\n", so->so_name);
		}
	    }
	  else if (catch_errors
		   (symbol_add_stub, (char *) so,
		    "Error while reading shared library symbols:\n",
		    RETURN_MASK_ALL))
	    {
	      so_last = so;
	      so->symbols_loaded = 1;
	    }
	}
    }

  /* Getting new symbols may change our opinion about what is
     frameless.  */
  if (so_last)
    reinit_frame_cache ();
}

/*

   LOCAL FUNCTION

   info_sharedlibrary_command -- code for "info sharedlibrary"

   SYNOPSIS

   static void info_sharedlibrary_command ()

   DESCRIPTION

   Walk through the shared library list and print information
   about each attached library.
 */

static void
info_sharedlibrary_command (char *ignore, int from_tty)
{
  register struct so_list *so = NULL;	/* link map state variable */
  int header_done = 0;

  if (exec_bfd == NULL)
    {
      printf_unfiltered ("No executable file.\n");
      return;
    }
  while ((so = find_solib (so)) != NULL)
    {
      if (so->so_name[0])
	{
	  unsigned long txt_start = 0;
	  unsigned long txt_end = 0;

	  if (!header_done)
	    {
	      printf_unfiltered ("%-20s%-20s%-12s%s\n", "From", "To", "Syms Read",
				 "Shared Object Library");
	      header_done++;
	    }
	  if (so->textsection)
	    {
	      txt_start = (unsigned long) so->textsection->addr;
	      txt_end = (unsigned long) so->textsection->endaddr;
	    }
	  printf_unfiltered ("%-20s", local_hex_string_custom (txt_start, "08l"));
	  printf_unfiltered ("%-20s", local_hex_string_custom (txt_end, "08l"));
	  printf_unfiltered ("%-12s", so->symbols_loaded ? "Yes" : "No");
	  printf_unfiltered ("%s\n", so->so_name);
	}
    }
  if (so_list_head == NULL)
    {
      printf_unfiltered ("No shared libraries loaded at this time.\n");
    }
}

/*

   GLOBAL FUNCTION

   solib_address -- check to see if an address is in a shared lib

   SYNOPSIS

   char *solib_address (CORE_ADDR address)

   DESCRIPTION

   Provides a hook for other gdb routines to discover whether or
   not a particular address is within the mapped address space of
   a shared library.  Any address between the base mapping address
   and the first address beyond the end of the last mapping, is
   considered to be within the shared library address space, for
   our purposes.

   For example, this routine is called at one point to disable
   breakpoints which are in shared libraries that are not currently
   mapped in.
 */

char *
solib_address (CORE_ADDR address)
{
  register struct so_list *so = 0;	/* link map state variable */

  while ((so = find_solib (so)) != NULL)
    {
      if (so->so_name[0] && so->textsection)
	{
	  if ((address >= (CORE_ADDR) so->textsection->addr) &&
	      (address < (CORE_ADDR) so->textsection->endaddr))
	    return (so->so_name);
	}
    }
  return (0);
}

/* Called by free_all_symtabs */

void
clear_solib (void)
{
  struct so_list *next;
  char *bfd_filename;

  disable_breakpoints_in_shlibs (1);

  while (so_list_head)
    {
      if (so_list_head->sections)
	{
	  xfree (so_list_head->sections);
	}
      if (so_list_head->abfd)
	{
	  remove_target_sections (so_list_head->abfd);
	  bfd_filename = bfd_get_filename (so_list_head->abfd);
	  if (!bfd_close (so_list_head->abfd))
	    warning ("cannot close \"%s\": %s",
		     bfd_filename, bfd_errmsg (bfd_get_error ()));
	}
      else
	/* This happens for the executable on SVR4.  */
	bfd_filename = NULL;

      next = so_list_head->next;
      if (bfd_filename)
	xfree (bfd_filename);
      xfree (so_list_head);
      so_list_head = next;
    }
}

/*

   GLOBAL FUNCTION

   solib_create_inferior_hook -- shared library startup support

   SYNOPSIS

   void solib_create_inferior_hook()

   DESCRIPTION

   When gdb starts up the inferior, it nurses it along (through the
   shell) until it is ready to execute it's first instruction.  At this
   point, this function gets called via expansion of the macro
   SOLIB_CREATE_INFERIOR_HOOK.
   For a statically bound executable, this first instruction is the
   one at "_start", or a similar text label. No further processing is
   needed in that case.
   For a dynamically bound executable, this first instruction is somewhere
   in the rld, and the actual user executable is not yet mapped in.
   We continue the inferior again, rld then maps in the actual user
   executable and any needed shared libraries and then sends
   itself a SIGTRAP.
   At that point we discover the names of all shared libraries and
   read their symbols in.

   FIXME

   This code does not properly handle hitting breakpoints which the
   user might have set in the rld itself.  Proper handling would have
   to check if the SIGTRAP happened due to a kill call.

   Also, what if child has exit()ed?  Must exit loop somehow.
 */

void
solib_create_inferior_hook (void)
{

  /* Nothing to do for statically bound executables.  */

  if (symfile_objfile == NULL
      || symfile_objfile->obfd == NULL
      || ((bfd_get_file_flags (symfile_objfile->obfd) & DYNAMIC) == 0))
    return;

  /* Now run the target.  It will eventually get a SIGTRAP, at
     which point all of the libraries will have been mapped in and we
     can go groveling around in the rld structures to find
     out what we need to know about them. */

  clear_proceed_status ();
  stop_soon_quietly = 1;
  stop_signal = TARGET_SIGNAL_0;
  do
    {
      target_resume (minus_one_ptid, 0, stop_signal);
      wait_for_inferior ();
    }
  while (stop_signal != TARGET_SIGNAL_TRAP);

  /*  solib_add will call reinit_frame_cache.
     But we are stopped in the runtime loader and we do not have symbols
     for the runtime loader. So heuristic_proc_start will be called
     and will put out an annoying warning.
     Delaying the resetting of stop_soon_quietly until after symbol loading
     suppresses the warning.  */
  solib_add ((char *) 0, 0, (struct target_ops *) 0, auto_solib_add);
  stop_soon_quietly = 0;
}


/*

   LOCAL FUNCTION

   sharedlibrary_command -- handle command to explicitly add library

   SYNOPSIS

   static void sharedlibrary_command (char *args, int from_tty)

   DESCRIPTION

 */

static void
sharedlibrary_command (char *args, int from_tty)
{
  dont_repeat ();
  solib_add (args, from_tty, (struct target_ops *) 0, 1);
}

void
_initialize_solib (void)
{
  add_com ("sharedlibrary", class_files, sharedlibrary_command,
	   "Load shared object library symbols for files matching REGEXP.");
  add_info ("sharedlibrary", info_sharedlibrary_command,
	    "Status of loaded shared object libraries.");

  add_show_from_set
    (add_set_cmd ("auto-solib-add", class_support, var_boolean,
		  (char *) &auto_solib_add,
		  "Set autoloading of shared library symbols.\n\
If \"on\", symbols from all shared object libraries will be loaded\n\
automatically when the inferior begins execution, when the dynamic linker\n\
informs gdb that a new library has been loaded, or when attaching to the\n\
inferior.  Otherwise, symbols must be loaded manually, using `sharedlibrary'.",
		  &setlist),
     &showlist);
}
@


1.13
log
@* memattr.c (mem_command): Eliminate ``true'' and ``false''.
* osfsolib.c (solib_map_sections): Ditto.
* irix5-nat.c (solib_map_sections): Ditto.
* corelow.c (gdb_check_format): Ditto.
* symfile.c (symfile_bfd_open): Ditto.
* solib.c (solib_map_sections): Ditto.
Partially fix PR gdb/354.
@
text
@@


1.13.8.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@@


1.12
log
@Approved by kev@@cygnus.com
ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* coff-solib.c (coff_solib_add): Add new readsyms arg.
	* irix5-nat.c (solib_add): Ditto.
	* osfsolib.c (solib_add): Ditto.
	* pa64solib.c (pa64_solib_add): Ditto.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* solib.c (solib_add): Ditto.
	* somsolib.c (som_solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* coff-solib.h (coff_solib_add): Add new readsyms arg to prototype.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* pa64solib.h (pa64_solib_add): Ditto.
	* solib.h (solib_add): Ditto.
	* somsolib.h (som_solib_add): Ditto.
	* config/i386/tm-cygwin.h (child_solib_add): Ditto.

	* coff-solib.c (coff_solib_add):  If readsyms is zero don't read
	symbols but do any other needed work for shared libs.
	* irix5-nat.c: Ditto.
	* osfsolib.c (solib_add): Ditto.
	* solib.c (solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* irix5-nat.c (sharedlibrary_command): Pass 1 as readsyms to
	solib_add to force reading of shared library symbols.
	* osfsolib.c (sharedlibrary_command;): Ditto.
	* pa64solib.c (pa64_solib_sharedlibrary_command): Ditto.
	* solib.c (sharedlibrary_command): Ditto.
	* somsolib.c (som_solib_sharedlibrary_command): Ditto.
	* xcoffsolib.c (sharedlibrary_command): Ditto.

	* coff-solib.c (coff_solib_create_inferior_hook): Call solib_add
	unconditionally with auto_solib_add.
	* irix5-nat.c (solib_create_inferior_hook): Ditto.
	* osfsolib.c (solib_create_inferior_hook): Ditto.
	* solib.c (solib_create_inferior_hook): Ditto.
	* solib-osf.c (osf_solib_create_inferior_hook): Ditto.
	* solib-svr4.c (enable_break): Ditto.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Ditto.

	* corelow.c (solib_add_stub): Add auto_solib_add to args passed
	via SOLIB_ADD.
	* sol-thread.c (sol_thread_attach): Ditto.
	* config/rs6000/nm-rs6000.h (SOLIB_ADD): Ditto.

	* infcmd.c (attach_command): Remove auto_solib_add decl.
	Call SOLIB_ADD directly with auto_solib_add.
	* infrun.c (handle_inferior_event): Ditto.

	* coff-solib.h (SOLIB_ADD): Add readsyms arg.
	* pa64solib.h (SOLIB_ADD): Ditto.
	* solib.h (SOLIB_ADD): Ditto.
	* somsolib.h (SOLIB_ADD): Ditto.
	* config/i386/tm-cygwin.h (SOLIB_ADD): Ditto.

	* fork-child.c (clone_and_follow_inferior): Remove unused
	auto_solib_add decl.

	* pa64solib.c (pa64_solib_add): Call add_to_solist with readsyms.
	(read_dld_descriptor): Ditto.
	(pa64_solib_add): Call read_dld_descriptor with	readsyms.
	(pa64_solib_in_dynamic_linker): Ditto.

	* corelow.c (symfile.h): Need this for auto_solib_add declaration.
	* sol-thread.c (symfile.h): Ditto.

Approved by eliz@@is.elta.co.il
doc/ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* gdbint.texinfo (SOLIB_ADD): Document additional new
	"readsyms" arg.
@
text
@d256 1
a256 1
  abfd->cacheable = true;
@


1.11
log
@Changes approved by kev@@cygnus.com, ezannoni@@cygnus.com, eliz@@is.elta.co.il.

  Changelog:

	2001-10-27  Fred Fish  <fnf@@redhat.com>

	* symfile.c (auto_solib_add): Update comment to note that
	this variable is now just used as a boolean to control shlib
	autoloading, and clarify when it is used.
	* symfile.h (auto_solib_add): Ditto.

	* symfile.c (auto_solib_limit): New variable that holds the
	autoloading threshold instead of overloading auto_solib_add.
	* symfile.h (auto_solib_limit): Ditto.

	* irix5-nat.c (_initialize_solib): Change auto-solib-add
	variable from var_zinteger to var_boolean and update help.
	* osfsolib.c (_initialize_solib): Ditto.
	* pa64solib.c (_initialize_pa64_solib): Ditto.
	* solib.c (_initialize_solib): Ditto.
	* somsolib.c (_initialize_som_solib): Ditto.
	* xcoffsolib.c (_initialize_solib): Ditto.

	* pa64solib.c (pa64_solib_total_st_size): Update comment to
	note that the new auto_solib_limit variable is used instead
	of overloading auto_solib_add variable.
	(_initialize_pa64_solib): Ditto.
	* somsolib.c (som_solib_total_st_size): Ditto.
	(_initialize_som_solib): Ditto.

	* pa64solib.c (_initialize_pa64_solib): Add new set/show
	commands for auto-solib-limit variable.
	* somsolib.c (_initialize_som_solib): Ditto

	* pa64solib.c (add_to_solist): Check that auto_solib_add is
	set and use auto_solib_limit as the threshold size instead
	of auto_solib_add.
	* somsolib.c (som_solib_add): Ditto, and also change warning
	text about size threshold exceeded.

  doc/ChangeLog:

	2001-10-28  Fred Fish  <fnf@@redhat.com>

	* gdb.texinfo (auto-solib-add): Change docs to match
	implementation change.
	(auto-solib-limit): Add docs for new variable.
@
text
@d599 1
a599 1
   struct target_ops *target)
d606 1
a606 1
solib_add (char *arg_string, int from_tty, struct target_ops *target)
d617 3
d894 1
a894 2
  if (auto_solib_add)
    solib_add ((char *) 0, 0, (struct target_ops *) 0);
d917 1
a917 1
  solib_add (args, from_tty, (struct target_ops *) 0);
@


1.10
log
@Commit Ilya Golubev's clear_solib() fixes.
@
text
@d927 1
a927 1
    (add_set_cmd ("auto-solib-add", class_support, var_zinteger,
d930 4
a933 4
If nonzero, symbols from all shared object libraries will be loaded\n\
automatically when the inferior begins execution or when the dynamic linker\n\
informs gdb that a new library has been loaded.  Otherwise, symbols\n\
must be loaded manually, using `sharedlibrary'.",
@


1.9
log
@Phase 1 of the ptid_t changes.
@
text
@d805 1
@


1.9.4.1
log
@	From Ilya Golubev <gin@@mo.msk.ru>:
	* solib.c (clear_solib): Call `remove_target_sections' to fix
	stale pointers in `struct target_ops'.
	* irix5-nat.c (clear_solib): Likewise.
	* osfsolib.c (clear_solib): Likewise.
@
text
@a804 1
	  remove_target_sections (so_list_head->abfd);
@


1.8
log
@Update/correct copyright notices.
@
text
@d879 1
a879 1
      target_resume (-1, 0, stop_signal);
@


1.7
log
@Replace free() with xfree().
@
text
@d2 2
a3 1
   Copyright 1993, 94, 95, 96, 98, 1999 Free Software Foundation, Inc.
@


1.6
log
@Protoization.
@
text
@d129 1
a129 1
      free (buffer);
d231 1
a231 1
  old_chain = make_cleanup (free, filename);
d448 1
a448 1
      free (buffer);
d475 1
a475 1
	      free (buffer);
d800 1
a800 1
	  free ((PTR) so_list_head->sections);
d815 2
a816 2
	free ((PTR) bfd_filename);
      free ((PTR) so_list_head);
@


1.5
log
@Protoization.
@
text
@d510 1
a510 2
find_solib (so_list_ptr)
     struct so_list *so_list_ptr;	/* Last lm or NULL for first one */
@


1.4
log
@PARAMS removal.
@
text
@d119 1
a119 5
ldr_read_memory (memaddr, myaddr, len, readstring)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int readstring;
d220 1
a220 2
solib_map_sections (arg)
     char *arg;
d306 1
a306 1
first_link_map_member ()
d349 1
a349 2
next_link_map_member (so_list_ptr)
     struct so_list *so_list_ptr;
d390 1
a390 3
xfer_link_map_member (so_list_ptr, lm)
     struct so_list *so_list_ptr;
     struct link_map *lm;
d559 1
a559 2
symbol_add_stub (arg)
     char *arg;
d606 1
a606 4
solib_add (arg_string, from_tty, target)
     char *arg_string;
     int from_tty;
     struct target_ops *target;
d706 1
a706 3
info_sharedlibrary_command (ignore, from_tty)
     char *ignore;
     int from_tty;
d771 1
a771 2
solib_address (address)
     CORE_ADDR address;
d790 1
a790 1
clear_solib ()
d859 1
a859 1
solib_create_inferior_hook ()
d911 1
a911 3
sharedlibrary_command (args, from_tty)
     char *args;
     int from_tty;
d918 1
a918 1
_initialize_solib ()
@


1.3
log
@2000-04-27  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* cxux-nat.c (add_shared_symbol_files): Don't treat .text section
 	as special in the section_addr_info structure.
	* pa64solib.c (pa64_solib_add_solib_objfile): Ditto.
	* osfsolib.c (symbol_add_stub): Ditto.
	* irix5-nat.c (symbol_add_stub): Ditto.
@
text
@d116 1
a116 1
static int ldr_read_memory PARAMS ((CORE_ADDR, char *, int, int));
d176 1
a176 2
extern int
fdmatch PARAMS ((int, int));	/* In libiberty */
d180 1
a180 2
static void
sharedlibrary_command PARAMS ((char *, int));
d182 1
a182 2
static void
info_sharedlibrary_command PARAMS ((char *, int));
d184 1
a184 2
static int
symbol_add_stub PARAMS ((char *));
d186 1
a186 2
static struct so_list *
  find_solib PARAMS ((struct so_list *));
d188 1
a188 2
static struct link_map *
  first_link_map_member PARAMS ((void));
d190 1
a190 2
static struct link_map *
  next_link_map_member PARAMS ((struct so_list *));
d192 1
a192 2
static void
xfer_link_map_member PARAMS ((struct so_list *, struct link_map *));
d194 1
a194 2
static int
solib_map_sections PARAMS ((char *));
@


1.2
log
@2000-04-03  H.J. Lu  <hjl@@gnu.org>

	* gdb_regex.h: New. Include "regex.h" if USE_INCLUDED_REGEX
	is defined and <regex.h> otherwise.

        * irix5-nat.c: Include "gdb_regex.h" instead of "gnu-regex.h".
	* monitor.c: Likewise.
	* osfsolib.c: Likewise.
	* solib.c: Likewise.
	* source.c: Likewise.
	* symtab.c: Likewise.

	* Makefile.in (REGEX): Changed to @@REGEX@@.
	(REGEX_CFLAGS): New.
	(REGEX1): Removed.
	(ADD_DEPS): Use $(REGEX) instead of $(REGEX1).
	(INTERNAL_WARN_CFLAGS): Add $(REGEX_CFLAGS).

	* configure.in (--with-included-regex): New switch.
	(REGEX): New. Subsstitue @@REGEX@@ in Makefile.in.
	(REGEX_CFLAGS): New. Subsstitue @@REGEX_CFLAGS@@ in Makefile.in.
	* configure: Regenerated.
@
text
@d601 2
a602 1
  section_addrs.text_addr = text_addr;
@


1.1
log
@Initial revision
@
text
@a2 2
   
This file is part of GDB.
d4 16
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d39 1
a39 1
#include "gnu-regex.h"
d44 1
a44 1
#define MAX_PATH_SIZE 1024		/* FIXME: Should be dynamic */
d54 3
a56 3
      These are not documented, and they are not defined in the system
      header files. The definitions below were obtained by experimentation,
      but they seem stable enough.
d58 6
a63 6
      equivalent ldr_* routines.
      This approach is somewhat cleaner, but it requires that the GDB
      executable is dynamically linked. In addition it requires a
      NAT_CLIBS= -lxproc -Wl,-expect_unresolved,ldr_process_context
      linker specification for GDB and all applications that are using
      libgdb.
d72 13
a84 12
{
	CORE_ADDR next;
	CORE_ADDR previous;
	CORE_ADDR unknown1;
	char *module_name;
	CORE_ADDR modinfo_addr;
	long module_id;
	CORE_ADDR unknown2;
	CORE_ADDR unknown3;
	long region_count;
	CORE_ADDR regioninfo_addr;
} ldr_module_info_t;
d87 10
a96 9
{
	long unknown1;
	CORE_ADDR regionname_addr;
	long protection;
	CORE_ADDR vaddr;
	CORE_ADDR mapaddr;
	long size;
	long unknown2[5];
} ldr_region_info_t;
d99 7
a105 6
{
	CORE_ADDR unknown1;
	CORE_ADDR unknown2;
	CORE_ADDR head;
	CORE_ADDR tail;
} ldr_context_t;
d132 1
a132 1
        strcpy (myaddr, buffer);
d148 4
a151 3
struct link_map {
  CORE_ADDR l_offset;			/* prelink to load address offset */
  char *l_name;				/* full name of loaded object */
d158 15
a172 14
struct so_list {
  struct so_list *next;			/* next structure in linked list */
  struct link_map lm;			/* copy of link map from inferior */
  struct link_map *lmaddr;		/* addr in inferior lm was read from */
  CORE_ADDR lmend;			/* upper addr bound of mapped object */
  char so_name[MAX_PATH_SIZE];		/* shared object lib name (FIXME) */
  char symbols_loaded;			/* flag: symbols read in yet? */
  char from_tty;			/* flag: print msgs? */
  struct objfile *objfile;		/* objfile for loaded lib */
  struct section_table *sections;
  struct section_table *sections_end;
  struct section_table *textsection;
  bfd *abfd;
};
d177 1
a177 1
fdmatch PARAMS ((int, int));		/* In libiberty */
d191 1
a191 1
find_solib PARAMS ((struct so_list *));
d194 1
a194 1
first_link_map_member PARAMS ((void));
d197 1
a197 1
next_link_map_member PARAMS ((struct so_list *));
d207 1
a207 1
LOCAL FUNCTION
d209 1
a209 1
	solib_map_sections -- open bfd and build sections for shared lib
d211 1
a211 1
SYNOPSIS
d213 1
a213 1
	static int solib_map_sections (struct so_list *so)
d215 1
a215 1
DESCRIPTION
d217 5
a221 5
	Given a pointer to one of the shared objects in our list
	of mapped objects, use the recorded name to open a bfd
	descriptor for the object, build a section table, and then
	relocate all the section addresses by the base address at
	which the shared object was mapped.
d223 1
a223 1
FIXMES
d225 5
a229 5
	In most (all?) cases the shared object file name recorded in the
	dynamic linkage tables will be a fully qualified pathname.  For
	cases where it isn't, do we really mimic the systems search
	mechanism correctly in the below code (particularly the tilde
	expansion stuff?).
d243 2
a244 2
  
  filename = tilde_expand (so -> so_name);
d246 1
a246 1
  
d268 2
a269 2
  so -> abfd = abfd;
  abfd -> cacheable = true;
d276 1
a276 1
  if (build_section_table (abfd, &so -> sections, &so -> sections_end))
d278 1
a278 1
      error ("Can't find the file sections in `%s': %s", 
d282 1
a282 1
  for (p = so -> sections; p < so -> sections_end; p++)
d285 6
a290 6
	 object's file by the offset to get the address to which the
	 object was actually mapped.  */
      p -> addr += LM_OFFSET (so);
      p -> endaddr += LM_OFFSET (so);
      so -> lmend = (CORE_ADDR) max (p -> endaddr, so -> lmend);
      if (STREQ (p -> the_bfd_section -> name, ".text"))
d292 1
a292 1
	  so -> textsection = p;
d304 1
a304 1
LOCAL FUNCTION
d306 1
a306 1
	first_link_map_member -- locate first member in dynamic linker's map
d308 1
a308 1
SYNOPSIS
d310 1
a310 1
	static struct link_map *first_link_map_member (void)
d312 1
a312 1
DESCRIPTION
d314 4
a317 4
	Read in a copy of the first member in the inferior's dynamic
	link map from the inferior's dynamic linker structures, and return
	a pointer to the copy in our address space.
*/
d333 1
a333 1
      || ldr_next_module(fake_ldr_process, &mod_id) != 0
d335 3
a337 3
      || ldr_inq_module(fake_ldr_process, mod_id,
			&first_lm.module_info, sizeof(ldr_module_info_t),
			&retsize) != 0)
d372 1
a372 1
  if (ldr_next_module(fake_ldr_process, &mod_id) != 0
d374 3
a376 3
      || ldr_inq_module(fake_ldr_process, mod_id,
			&next_lm.module_info, sizeof(ldr_module_info_t),
			&retsize) != 0)
d449 1
a449 1
			  - (CORE_ADDR) region_info.lri_vaddr;
d474 1
a474 1
				   + i * sizeof (region_info),
d491 1
a491 1
		        so_list_ptr->so_name, region_name);
d505 1
a505 1
LOCAL FUNCTION
d507 1
a507 1
	find_solib -- step through list of shared objects
d509 1
a509 1
SYNOPSIS
d511 1
a511 1
	struct so_list *find_solib (struct so_list *so_list_ptr)
d513 1
a513 1
DESCRIPTION
d515 6
a520 6
	This module contains the routine which finds the names of any
	loaded "images" in the current process. The argument in must be
	NULL on the first call, and then the returned value must be passed
	in on subsequent calls. This provides the capability to "step" down
	the list of loaded objects. On the last object, a NULL value is
	returned.
d522 2
a523 2
	The arg and return value are "struct link_map" pointers, as defined
	in <link.h>.
d533 1
a533 1
  
d546 1
a546 1
	 the shared library list.  Advance to the next shared object. */
d548 1
a548 1
      so_list_next = so_list_ptr -> next;
d553 1
a553 1
	 abbreviated load_map structure */
d556 1
a556 1
      new -> lmaddr = lm;
d558 1
a558 1
	 node if this is the first one. */
d561 1
a561 1
	  so_list_ptr -> next = new;
d566 1
a566 1
	}      
d579 1
a579 1
  register struct so_list *so = (struct so_list *) arg;	/* catch_errs bogon */
d581 1
d583 4
a586 3
  if (so -> textsection)
    text_addr = so -> textsection -> addr;
  else if (so -> abfd != NULL)
d591 1
a591 1
	 text_addr so that the relocation in symbol_file_add does no harm.  */
d593 1
a593 1
      lowest_sect = bfd_get_section_by_name (so -> abfd, ".text");
d595 1
a595 1
	bfd_map_over_sections (so -> abfd, find_lowest_section,
d598 1
a598 1
	text_addr = bfd_section_vma (so -> abfd, lowest_sect) + LM_OFFSET (so);
d600 4
a603 4
  
  so -> objfile = symbol_file_add (so -> so_name, so -> from_tty,
				   text_addr,
				   0, 0, 0, 0, 1);
d609 1
a609 1
GLOBAL FUNCTION
d611 1
a611 1
	solib_add -- add a shared library file to the symtab and section list
d613 1
a613 1
SYNOPSIS
d615 2
a616 2
	void solib_add (char *arg_string, int from_tty,
			struct target_ops *target)
d618 1
a618 1
DESCRIPTION
d620 1
a620 1
*/
d627 2
a628 2
{	
  register struct so_list *so = NULL;   	/* link map state variable */
d636 1
a636 1
  
d641 2
a642 2
  
  
d652 1
a652 1
	  if (so -> so_name[0])
d654 1
a654 1
	      count += so -> sections_end - so -> sections;
d657 1
a657 1
      
d660 1
a660 1
	  int update_coreops;
d662 1
a662 20
	  /* We must update the to_sections field in the core_ops structure
	     here, otherwise we dereference a potential dangling pointer
	     for each call to target_read/write_memory within this routine.  */
	  update_coreops = core_ops.to_sections == target->to_sections;
	     
	  /* Reallocate the target's section table including the new size.  */
	  if (target -> to_sections)
	    {
	      old = target -> to_sections_end - target -> to_sections;
	      target -> to_sections = (struct section_table *)
		xrealloc ((char *)target -> to_sections,
			 (sizeof (struct section_table)) * (count + old));
	    }
	  else
	    {
	      old = 0;
	      target -> to_sections = (struct section_table *)
		xmalloc ((sizeof (struct section_table)) * count);
	    }
	  target -> to_sections_end = target -> to_sections + (count + old);
a663 9
	  /* Update the to_sections field in the core_ops structure
	     if needed.  */
	  if (update_coreops)
	    {
	      core_ops.to_sections = target->to_sections;
	      core_ops.to_sections_end = target->to_sections_end;
	    }

	  /* Add these section table entries to the target's table.  */
d666 1
a666 1
	      if (so -> so_name[0])
d668 3
a670 3
		  count = so -> sections_end - so -> sections;
		  memcpy ((char *) (target -> to_sections + old),
			  so -> sections, 
d677 1
a677 1
  
d682 1
a682 1
      if (so -> so_name[0] && re_exec (so -> so_name))
d684 2
a685 2
	  so -> from_tty = from_tty;
	  if (so -> symbols_loaded)
d689 1
a689 1
		  printf_unfiltered ("Symbols already loaded for %s\n", so -> so_name);
d698 1
a698 1
	      so -> symbols_loaded = 1;
d711 1
a711 1
LOCAL FUNCTION
d713 1
a713 1
	info_sharedlibrary_command -- code for "info sharedlibrary"
d715 1
a715 1
SYNOPSIS
d717 1
a717 1
	static void info_sharedlibrary_command ()
d719 1
a719 1
DESCRIPTION
d721 3
a723 3
	Walk through the shared library list and print information
	about each attached library.
*/
d730 1
a730 1
  register struct so_list *so = NULL;  	/* link map state variable */
d732 1
a732 1
  
d735 1
a735 1
      printf_unfiltered ("No exec file.\n");
d740 1
a740 1
      if (so -> so_name[0])
d747 2
a748 2
	      printf_unfiltered("%-20s%-20s%-12s%s\n", "From", "To", "Syms Read",
		     "Shared Object Library");
d751 1
a751 1
	  if (so -> textsection)
d753 2
a754 2
	      txt_start = (unsigned long) so -> textsection -> addr;
	      txt_end = (unsigned long) so -> textsection -> endaddr;
d758 2
a759 2
	  printf_unfiltered ("%-12s", so -> symbols_loaded ? "Yes" : "No");
	  printf_unfiltered ("%s\n",  so -> so_name);
d764 1
a764 1
      printf_unfiltered ("No shared libraries loaded at this time.\n");	
d770 1
a770 1
GLOBAL FUNCTION
d772 1
a772 1
	solib_address -- check to see if an address is in a shared lib
d774 1
a774 1
SYNOPSIS
d776 1
a776 1
	char *solib_address (CORE_ADDR address)
d778 1
a778 1
DESCRIPTION
d780 6
a785 6
	Provides a hook for other gdb routines to discover whether or
	not a particular address is within the mapped address space of
	a shared library.  Any address between the base mapping address
	and the first address beyond the end of the last mapping, is
	considered to be within the shared library address space, for
	our purposes.
d787 3
a789 3
	For example, this routine is called at one point to disable
	breakpoints which are in shared libraries that are not currently
	mapped in.
d796 2
a797 2
  register struct so_list *so = 0;   	/* link map state variable */
  
d800 1
a800 1
      if (so -> so_name[0] && so -> textsection)
d802 2
a803 2
	  if ((address >= (CORE_ADDR) so -> textsection -> addr) &&
	      (address < (CORE_ADDR) so -> textsection -> endaddr))
d812 2
a813 2
void 
clear_solib()
d817 1
a817 1
  
d822 1
a822 1
      if (so_list_head -> sections)
d824 1
a824 1
	  free ((PTR)so_list_head -> sections);
d826 1
a826 1
      if (so_list_head -> abfd)
d828 2
a829 2
	  bfd_filename = bfd_get_filename (so_list_head -> abfd);
	  if (!bfd_close (so_list_head -> abfd))
d837 1
a837 1
      next = so_list_head -> next;
d839 2
a840 2
	free ((PTR)bfd_filename);
      free ((PTR)so_list_head);
d844 1
a844 1
  
a845 31
  
GLOBAL FUNCTION
  
	solib_create_inferior_hook -- shared library startup support
  
SYNOPSIS
  
	void solib_create_inferior_hook()
  
DESCRIPTION

	When gdb starts up the inferior, it nurses it along (through the
	shell) until it is ready to execute it's first instruction.  At this
	point, this function gets called via expansion of the macro
	SOLIB_CREATE_INFERIOR_HOOK.
	For a statically bound executable, this first instruction is the
	one at "_start", or a similar text label. No further processing is
	needed in that case.
	For a dynamically bound executable, this first instruction is somewhere
	in the rld, and the actual user executable is not yet mapped in.
	We continue the inferior again, rld then maps in the actual user
	executable and any needed shared libraries and then sends
	itself a SIGTRAP.
	At that point we discover the names of all shared libraries and
	read their symbols in.

FIXME

	This code does not properly handle hitting breakpoints which the
	user might have set in the rld itself.  Proper handling would have
	to check if the SIGTRAP happened due to a kill call.
d847 33
a879 2
	Also, what if child has exit()ed?  Must exit loop somehow.
  */
d882 1
a882 1
solib_create_inferior_hook()
d896 1
a896 1
 
d908 5
a912 5
      But we are stopped in the runtime loader and we do not have symbols
      for the runtime loader. So heuristic_proc_start will be called
      and will put out an annoying warning.
      Delaying the resetting of stop_soon_quietly until after symbol loading
      suppresses the warning.  */
d921 1
a921 1
LOCAL FUNCTION
d923 1
a923 1
	sharedlibrary_command -- handle command to explicitly add library
d925 1
a925 1
SYNOPSIS
d927 1
a927 1
	static void sharedlibrary_command (char *args, int from_tty)
d929 1
a929 1
DESCRIPTION
d931 1
a931 1
*/
d935 2
a936 2
char *args;
int from_tty;
d943 1
a943 1
_initialize_solib()
d947 1
a947 1
  add_info ("sharedlibrary", info_sharedlibrary_command, 
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d3 2
d6 13
a18 16
   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d43 1
a43 1
#define MAX_PATH_SIZE 1024	/* FIXME: Should be dynamic */
d53 3
a55 3
   These are not documented, and they are not defined in the system
   header files. The definitions below were obtained by experimentation,
   but they seem stable enough.
d57 6
a62 6
   equivalent ldr_* routines.
   This approach is somewhat cleaner, but it requires that the GDB
   executable is dynamically linked. In addition it requires a
   NAT_CLIBS= -lxproc -Wl,-expect_unresolved,ldr_process_context
   linker specification for GDB and all applications that are using
   libgdb.
d71 12
a82 13
  {
    CORE_ADDR next;
    CORE_ADDR previous;
    CORE_ADDR unknown1;
    char *module_name;
    CORE_ADDR modinfo_addr;
    long module_id;
    CORE_ADDR unknown2;
    CORE_ADDR unknown3;
    long region_count;
    CORE_ADDR regioninfo_addr;
  }
ldr_module_info_t;
d85 9
a93 10
  {
    long unknown1;
    CORE_ADDR regionname_addr;
    long protection;
    CORE_ADDR vaddr;
    CORE_ADDR mapaddr;
    long size;
    long unknown2[5];
  }
ldr_region_info_t;
d96 6
a101 7
  {
    CORE_ADDR unknown1;
    CORE_ADDR unknown2;
    CORE_ADDR head;
    CORE_ADDR tail;
  }
ldr_context_t;
d128 1
a128 1
	strcpy (myaddr, buffer);
d144 3
a146 4
struct link_map
{
  CORE_ADDR l_offset;		/* prelink to load address offset */
  char *l_name;			/* full name of loaded object */
d153 14
a166 15
struct so_list
  {
    struct so_list *next;	/* next structure in linked list */
    struct link_map lm;		/* copy of link map from inferior */
    struct link_map *lmaddr;	/* addr in inferior lm was read from */
    CORE_ADDR lmend;		/* upper addr bound of mapped object */
    char so_name[MAX_PATH_SIZE];	/* shared object lib name (FIXME) */
    char symbols_loaded;	/* flag: symbols read in yet? */
    char from_tty;		/* flag: print msgs? */
    struct objfile *objfile;	/* objfile for loaded lib */
    struct section_table *sections;
    struct section_table *sections_end;
    struct section_table *textsection;
    bfd *abfd;
  };
d171 1
a171 1
fdmatch PARAMS ((int, int));	/* In libiberty */
d185 1
a185 1
  find_solib PARAMS ((struct so_list *));
d188 1
a188 1
  first_link_map_member PARAMS ((void));
d191 1
a191 1
  next_link_map_member PARAMS ((struct so_list *));
d201 1
a201 1
   LOCAL FUNCTION
d203 1
a203 1
   solib_map_sections -- open bfd and build sections for shared lib
d205 1
a205 1
   SYNOPSIS
d207 1
a207 1
   static int solib_map_sections (struct so_list *so)
d209 1
a209 1
   DESCRIPTION
d211 5
a215 5
   Given a pointer to one of the shared objects in our list
   of mapped objects, use the recorded name to open a bfd
   descriptor for the object, build a section table, and then
   relocate all the section addresses by the base address at
   which the shared object was mapped.
d217 1
a217 1
   FIXMES
d219 5
a223 5
   In most (all?) cases the shared object file name recorded in the
   dynamic linkage tables will be a fully qualified pathname.  For
   cases where it isn't, do we really mimic the systems search
   mechanism correctly in the below code (particularly the tilde
   expansion stuff?).
d237 2
a238 2

  filename = tilde_expand (so->so_name);
d240 1
a240 1

d262 2
a263 2
  so->abfd = abfd;
  abfd->cacheable = true;
d270 1
a270 1
  if (build_section_table (abfd, &so->sections, &so->sections_end))
d272 1
a272 1
      error ("Can't find the file sections in `%s': %s",
d276 1
a276 1
  for (p = so->sections; p < so->sections_end; p++)
d279 6
a284 6
         object's file by the offset to get the address to which the
         object was actually mapped.  */
      p->addr += LM_OFFSET (so);
      p->endaddr += LM_OFFSET (so);
      so->lmend = (CORE_ADDR) max (p->endaddr, so->lmend);
      if (STREQ (p->the_bfd_section->name, ".text"))
d286 1
a286 1
	  so->textsection = p;
d298 1
a298 1
   LOCAL FUNCTION
d300 1
a300 1
   first_link_map_member -- locate first member in dynamic linker's map
d302 1
a302 1
   SYNOPSIS
d304 1
a304 1
   static struct link_map *first_link_map_member (void)
d306 1
a306 1
   DESCRIPTION
d308 4
a311 4
   Read in a copy of the first member in the inferior's dynamic
   link map from the inferior's dynamic linker structures, and return
   a pointer to the copy in our address space.
 */
d327 1
a327 1
      || ldr_next_module (fake_ldr_process, &mod_id) != 0
d329 3
a331 3
      || ldr_inq_module (fake_ldr_process, mod_id,
			 &first_lm.module_info, sizeof (ldr_module_info_t),
			 &retsize) != 0)
d366 1
a366 1
  if (ldr_next_module (fake_ldr_process, &mod_id) != 0
d368 3
a370 3
      || ldr_inq_module (fake_ldr_process, mod_id,
			 &next_lm.module_info, sizeof (ldr_module_info_t),
			 &retsize) != 0)
d443 1
a443 1
	    - (CORE_ADDR) region_info.lri_vaddr;
d468 1
a468 1
				  + i * sizeof (region_info),
d485 1
a485 1
		       so_list_ptr->so_name, region_name);
d499 1
a499 1
   LOCAL FUNCTION
d501 1
a501 1
   find_solib -- step through list of shared objects
d503 1
a503 1
   SYNOPSIS
d505 1
a505 1
   struct so_list *find_solib (struct so_list *so_list_ptr)
d507 1
a507 1
   DESCRIPTION
d509 6
a514 6
   This module contains the routine which finds the names of any
   loaded "images" in the current process. The argument in must be
   NULL on the first call, and then the returned value must be passed
   in on subsequent calls. This provides the capability to "step" down
   the list of loaded objects. On the last object, a NULL value is
   returned.
d516 2
a517 2
   The arg and return value are "struct link_map" pointers, as defined
   in <link.h>.
d527 1
a527 1

d540 1
a540 1
         the shared library list.  Advance to the next shared object. */
d542 1
a542 1
      so_list_next = so_list_ptr->next;
d547 1
a547 1
         abbreviated load_map structure */
d550 1
a550 1
      new->lmaddr = lm;
d552 1
a552 1
         node if this is the first one. */
d555 1
a555 1
	  so_list_ptr->next = new;
d560 1
a560 1
	}
d573 1
a573 1
  register struct so_list *so = (struct so_list *) arg;		/* catch_errs bogon */
d576 3
a578 3
  if (so->textsection)
    text_addr = so->textsection->addr;
  else if (so->abfd != NULL)
d583 1
a583 1
         text_addr so that the relocation in symbol_file_add does no harm.  */
d585 1
a585 1
      lowest_sect = bfd_get_section_by_name (so->abfd, ".text");
d587 2
a588 2
	bfd_map_over_sections (so->abfd, find_lowest_section,
			       (PTR) & lowest_sect);
d590 1
a590 1
	text_addr = bfd_section_vma (so->abfd, lowest_sect) + LM_OFFSET (so);
d592 4
a595 4

  so->objfile = symbol_file_add (so->so_name, so->from_tty,
				 text_addr,
				 0, 0, 0, 0, 1);
d601 1
a601 1
   GLOBAL FUNCTION
d603 1
a603 1
   solib_add -- add a shared library file to the symtab and section list
d605 1
a605 1
   SYNOPSIS
d607 2
a608 2
   void solib_add (char *arg_string, int from_tty,
   struct target_ops *target)
d610 1
a610 1
   DESCRIPTION
d612 1
a612 1
 */
d619 2
a620 2
{
  register struct so_list *so = NULL;	/* link map state variable */
d628 1
a628 1

d633 2
a634 2


d644 1
a644 1
	  if (so->so_name[0])
d646 1
a646 1
	      count += so->sections_end - so->sections;
d649 1
a649 1

d658 1
a658 1

d660 1
a660 1
	  if (target->to_sections)
d662 4
a665 4
	      old = target->to_sections_end - target->to_sections;
	      target->to_sections = (struct section_table *)
		xrealloc ((char *) target->to_sections,
			  (sizeof (struct section_table)) * (count + old));
d670 1
a670 1
	      target->to_sections = (struct section_table *)
d673 2
a674 2
	  target->to_sections_end = target->to_sections + (count + old);

d686 1
a686 1
	      if (so->so_name[0])
d688 3
a690 3
		  count = so->sections_end - so->sections;
		  memcpy ((char *) (target->to_sections + old),
			  so->sections,
d697 1
a697 1

d702 1
a702 1
      if (so->so_name[0] && re_exec (so->so_name))
d704 2
a705 2
	  so->from_tty = from_tty;
	  if (so->symbols_loaded)
d709 1
a709 1
		  printf_unfiltered ("Symbols already loaded for %s\n", so->so_name);
d718 1
a718 1
	      so->symbols_loaded = 1;
d731 1
a731 1
   LOCAL FUNCTION
d733 1
a733 1
   info_sharedlibrary_command -- code for "info sharedlibrary"
d735 1
a735 1
   SYNOPSIS
d737 1
a737 1
   static void info_sharedlibrary_command ()
d739 1
a739 1
   DESCRIPTION
d741 3
a743 3
   Walk through the shared library list and print information
   about each attached library.
 */
d750 1
a750 1
  register struct so_list *so = NULL;	/* link map state variable */
d752 1
a752 1

d760 1
a760 1
      if (so->so_name[0])
d767 2
a768 2
	      printf_unfiltered ("%-20s%-20s%-12s%s\n", "From", "To", "Syms Read",
				 "Shared Object Library");
d771 1
a771 1
	  if (so->textsection)
d773 2
a774 2
	      txt_start = (unsigned long) so->textsection->addr;
	      txt_end = (unsigned long) so->textsection->endaddr;
d778 2
a779 2
	  printf_unfiltered ("%-12s", so->symbols_loaded ? "Yes" : "No");
	  printf_unfiltered ("%s\n", so->so_name);
d784 1
a784 1
      printf_unfiltered ("No shared libraries loaded at this time.\n");
d790 1
a790 1
   GLOBAL FUNCTION
d792 1
a792 1
   solib_address -- check to see if an address is in a shared lib
d794 1
a794 1
   SYNOPSIS
d796 1
a796 1
   char *solib_address (CORE_ADDR address)
d798 1
a798 1
   DESCRIPTION
d800 6
a805 6
   Provides a hook for other gdb routines to discover whether or
   not a particular address is within the mapped address space of
   a shared library.  Any address between the base mapping address
   and the first address beyond the end of the last mapping, is
   considered to be within the shared library address space, for
   our purposes.
d807 3
a809 3
   For example, this routine is called at one point to disable
   breakpoints which are in shared libraries that are not currently
   mapped in.
d816 2
a817 2
  register struct so_list *so = 0;	/* link map state variable */

d820 1
a820 1
      if (so->so_name[0] && so->textsection)
d822 2
a823 2
	  if ((address >= (CORE_ADDR) so->textsection->addr) &&
	      (address < (CORE_ADDR) so->textsection->endaddr))
d832 2
a833 2
void
clear_solib ()
d837 1
a837 1

d842 1
a842 1
      if (so_list_head->sections)
d844 1
a844 1
	  free ((PTR) so_list_head->sections);
d846 1
a846 1
      if (so_list_head->abfd)
d848 2
a849 2
	  bfd_filename = bfd_get_filename (so_list_head->abfd);
	  if (!bfd_close (so_list_head->abfd))
d857 1
a857 1
      next = so_list_head->next;
d859 2
a860 2
	free ((PTR) bfd_filename);
      free ((PTR) so_list_head);
d864 1
a864 1

d866 31
d898 2
a899 33
   GLOBAL FUNCTION

   solib_create_inferior_hook -- shared library startup support

   SYNOPSIS

   void solib_create_inferior_hook()

   DESCRIPTION

   When gdb starts up the inferior, it nurses it along (through the
   shell) until it is ready to execute it's first instruction.  At this
   point, this function gets called via expansion of the macro
   SOLIB_CREATE_INFERIOR_HOOK.
   For a statically bound executable, this first instruction is the
   one at "_start", or a similar text label. No further processing is
   needed in that case.
   For a dynamically bound executable, this first instruction is somewhere
   in the rld, and the actual user executable is not yet mapped in.
   We continue the inferior again, rld then maps in the actual user
   executable and any needed shared libraries and then sends
   itself a SIGTRAP.
   At that point we discover the names of all shared libraries and
   read their symbols in.

   FIXME

   This code does not properly handle hitting breakpoints which the
   user might have set in the rld itself.  Proper handling would have
   to check if the SIGTRAP happened due to a kill call.

   Also, what if child has exit()ed?  Must exit loop somehow.
 */
d902 1
a902 1
solib_create_inferior_hook ()
d916 1
a916 1

d928 5
a932 5
     But we are stopped in the runtime loader and we do not have symbols
     for the runtime loader. So heuristic_proc_start will be called
     and will put out an annoying warning.
     Delaying the resetting of stop_soon_quietly until after symbol loading
     suppresses the warning.  */
d941 1
a941 1
   LOCAL FUNCTION
d943 1
a943 1
   sharedlibrary_command -- handle command to explicitly add library
d945 1
a945 1
   SYNOPSIS
d947 1
a947 1
   static void sharedlibrary_command (char *args, int from_tty)
d949 1
a949 1
   DESCRIPTION
d951 1
a951 1
 */
d955 2
a956 2
     char *args;
     int from_tty;
d963 1
a963 1
_initialize_solib ()
d967 1
a967 1
  add_info ("sharedlibrary", info_sharedlibrary_command,
@


1.1.1.3
log
@import gdb-1999-08-09 snapshot
@
text
@d594 1
a594 1
			       (PTR) &lowest_sect);
@


1.1.1.4
log
@import gdb-1999-09-28 snapshot
@
text
@d658 31
a689 3

	  old = target_resize_to_sections (target, count);
	  
@


1.1.1.5
log
@import gdb-1999-10-04 snapshot
@
text
@a580 1
  struct section_addr_info section_addrs;
a581 1
  memset (&section_addrs, 0, sizeof (section_addrs));
a598 1
  section_addrs.text_addr = text_addr;
d600 2
a601 2
				 &section_addrs,
				 0, 0, 0, 1);
@


1.1.1.6
log
@import gdb-1999-10-11 snapshot
@
text
@d603 2
a604 1
				 &section_addrs, 0, OBJF_SHARED);
@


1.1.1.7
log
@import gdb-1999-11-16 snapshot
@
text
@d735 1
a735 1
      printf_unfiltered ("No executable file.\n");
@


