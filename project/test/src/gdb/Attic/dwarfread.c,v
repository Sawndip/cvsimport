head	1.48;
access;
symbols
	insight_6_6-20070208-release:1.45
	gdb_6_6-2006-12-18-release:1.45
	gdb_6_6-branch:1.45.0.18
	gdb_6_6-2006-11-15-branchpoint:1.45
	insight_6_5-20061003-release:1.45
	gdb-csl-symbian-6_4_50_20060226-12:1.45
	gdb-csl-sourcerygxx-3_4_4-25:1.44
	nickrob-async-20060828-mergepoint:1.45
	gdb-csl-symbian-6_4_50_20060226-11:1.45
	gdb-csl-sourcerygxx-4_1-17:1.45
	gdb-csl-20060226-branch-local-2:1.45
	gdb-csl-sourcerygxx-4_1-14:1.45
	gdb-csl-sourcerygxx-4_1-13:1.45
	gdb-csl-sourcerygxx-4_1-12:1.45
	gdb-csl-sourcerygxx-3_4_4-21:1.45
	gdb_6_5-20060621-release:1.45
	gdb-csl-sourcerygxx-4_1-9:1.45
	gdb-csl-sourcerygxx-4_1-8:1.45
	gdb-csl-sourcerygxx-4_1-7:1.45
	gdb-csl-arm-2006q1-6:1.45
	gdb-csl-sourcerygxx-4_1-6:1.45
	gdb-csl-symbian-6_4_50_20060226-10:1.45
	gdb-csl-symbian-6_4_50_20060226-9:1.45
	gdb-csl-symbian-6_4_50_20060226-8:1.45
	gdb-csl-coldfire-4_1-11:1.45
	gdb-csl-sourcerygxx-3_4_4-19:1.45
	gdb-csl-coldfire-4_1-10:1.45
	gdb_6_5-branch:1.45.0.16
	gdb_6_5-2006-05-14-branchpoint:1.45
	gdb-csl-sourcerygxx-4_1-5:1.45
	nickrob-async-20060513-branch:1.45.0.14
	nickrob-async-20060513-branchpoint:1.45
	gdb-csl-sourcerygxx-4_1-4:1.45
	msnyder-reverse-20060502-branch:1.45.0.12
	msnyder-reverse-20060502-branchpoint:1.45
	gdb-csl-morpho-4_1-4:1.45
	gdb-csl-sourcerygxx-3_4_4-17:1.45
	readline_5_1-import-branch:1.45.0.10
	readline_5_1-import-branchpoint:1.45
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.45
	gdb-csl-symbian-20060226-branch:1.45.0.8
	gdb-csl-symbian-20060226-branchpoint:1.45
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.45
	msnyder-reverse-20060331-branch:1.45.0.6
	msnyder-reverse-20060331-branchpoint:1.45
	gdb-csl-available-20060303-branch:1.45.0.4
	gdb-csl-available-20060303-branchpoint:1.45
	gdb-csl-20060226-branch:1.45.0.2
	gdb-csl-20060226-branchpoint:1.45
	gdb_6_4-20051202-release:1.44
	msnyder-fork-checkpoint-branch:1.44.0.12
	msnyder-fork-checkpoint-branchpoint:1.44
	gdb-csl-gxxpro-6_3-branch:1.44.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.44
	gdb_6_4-branch:1.44.0.8
	gdb_6_4-2005-11-01-branchpoint:1.44
	gdb-csl-arm-20051020-branch:1.44.0.6
	gdb-csl-arm-20051020-branchpoint:1.44
	msnyder-tracepoint-checkpoint-branch:1.44.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.44
	gdb-csl-arm-20050325-2005-q1b:1.44
	gdb-csl-arm-20050325-2005-q1a:1.44
	csl-arm-20050325-branch:1.44.0.2
	csl-arm-20050325-branchpoint:1.44
	gdb-post-i18n-errorwarning-20050211:1.42
	gdb-pre-i18n-errorwarning-20050211:1.41
	gdb_6_3-20041109-release:1.41
	gdb_6_3-branch:1.41.0.2
	gdb_6_3-20041019-branchpoint:1.41
	drow_intercu-merge-20040921:1.41
	drow_intercu-merge-20040915:1.41
	jimb-gdb_6_2-e500-branch:1.40.2.1.0.4
	jimb-gdb_6_2-e500-branchpoint:1.40.2.1
	gdb_6_2-20040730-release:1.40.2.1
	gdb_6_2-branch:1.40.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.40
	gdb_6_1_1-20040616-release:1.37
	gdb_6_1-2004-04-05-release:1.37
	drow_intercu-merge-20040402:1.37
	drow_intercu-merge-20040327:1.37
	ezannoni_pie-20040323-branch:1.37.0.8
	ezannoni_pie-20040323-branchpoint:1.37
	cagney_tramp-20040321-mergepoint:1.37
	cagney_tramp-20040309-branch:1.37.0.6
	cagney_tramp-20040309-branchpoint:1.37
	gdb_6_1-branch:1.37.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.37
	drow_intercu-20040221-branch:1.37.0.2
	drow_intercu-20040221-branchpoint:1.37
	cagney_bfdfile-20040213-branch:1.36.0.2
	cagney_bfdfile-20040213-branchpoint:1.36
	drow-cplus-merge-20040208:1.36
	carlton_dictionary-20040126-merge:1.33
	cagney_bigcore-20040122-branch:1.33.0.2
	cagney_bigcore-20040122-branchpoint:1.33
	drow-cplus-merge-20040113:1.33
	drow-cplus-merge-20031224:1.33
	drow-cplus-merge-20031220:1.33
	carlton_dictionary-20031215-merge:1.33
	drow-cplus-merge-20031214:1.33
	carlton-dictionary-20031111-merge:1.31
	gdb_6_0-2003-10-04-release:1.27.4.2
	kettenis_sparc-20030918-branch:1.30.0.4
	kettenis_sparc-20030918-branchpoint:1.30
	carlton_dictionary-20030917-merge:1.30
	ezannoni_pie-20030916-branchpoint:1.30
	ezannoni_pie-20030916-branch:1.30.0.2
	cagney_x86i386-20030821-branch:1.29.0.2
	cagney_x86i386-20030821-branchpoint:1.29
	carlton_dictionary-20030805-merge:1.29
	carlton_dictionary-20030627-merge:1.29
	gdb_6_0-branch:1.27.0.4
	gdb_6_0-2003-06-23-branchpoint:1.27
	jimb-ppc64-linux-20030613-branch:1.27.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.27
	cagney_convert-20030606-branch:1.26.0.2
	cagney_convert-20030606-branchpoint:1.26
	cagney_writestrings-20030508-branch:1.24.0.20
	cagney_writestrings-20030508-branchpoint:1.24
	jimb-ppc64-linux-20030528-branch:1.25.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.25
	carlton_dictionary-20030523-merge:1.25
	cagney_fileio-20030521-branch:1.25.0.2
	cagney_fileio-20030521-branchpoint:1.25
	kettenis_i386newframe-20030517-mergepoint:1.25
	jimb-ppc64-linux-20030509-branch:1.24.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.24
	kettenis_i386newframe-20030504-mergepoint:1.24
	carlton_dictionary-20030430-merge:1.24
	kettenis_i386newframe-20030419-branch:1.24.0.16
	kettenis_i386newframe-20030419-branchpoint:1.24
	carlton_dictionary-20030416-merge:1.24
	cagney_frameaddr-20030409-mergepoint:1.24
	kettenis_i386newframe-20030406-branch:1.24.0.14
	kettenis_i386newframe-20030406-branchpoint:1.24
	cagney_frameaddr-20030403-branchpoint:1.24
	cagney_frameaddr-20030403-branch:1.24.0.12
	cagney_framebase-20030330-mergepoint:1.24
	cagney_framebase-20030326-branch:1.24.0.10
	cagney_framebase-20030326-branchpoint:1.24
	cagney_lazyid-20030317-branch:1.24.0.8
	cagney_lazyid-20030317-branchpoint:1.24
	kettenis-i386newframe-20030316-mergepoint:1.24
	offbyone-20030313-branch:1.24.0.6
	offbyone-20030313-branchpoint:1.24
	kettenis-i386newframe-20030308-branch:1.24.0.4
	kettenis-i386newframe-20030308-branchpoint:1.24
	carlton_dictionary-20030305-merge:1.24
	cagney_offbyone-20030303-branch:1.24.0.2
	cagney_offbyone-20030303-branchpoint:1.24
	carlton_dictionary-20030207-merge:1.23
	interps-20030203-mergepoint:1.21
	interps-20030202-branch:1.21.0.2
	interps-20030202-branchpoint:1.21
	cagney-unwind-20030108-branch:1.18.0.2
	cagney-unwind-20030108-branchpoint:1.18
	carlton_dictionary-20021223-merge:1.17
	gdb_5_3-2002-12-12-release:1.14
	carlton_dictionary-20021115-merge:1.16
	kseitz_interps-20021105-merge:1.15
	kseitz_interps-20021103-merge:1.15
	drow-cplus-merge-20021020:1.14
	drow-cplus-merge-20021025:1.14
	carlton_dictionary-20021025-merge:1.14
	carlton_dictionary-20021011-merge:1.14
	drow-cplus-branch:1.14.0.10
	drow-cplus-branchpoint:1.14
	kseitz_interps-20020930-merge:1.14
	carlton_dictionary-20020927-merge:1.14
	carlton_dictionary-branch:1.14.0.8
	carlton_dictionary-20020920-branchpoint:1.14
	gdb_5_3-branch:1.14.0.6
	gdb_5_3-2002-09-04-branchpoint:1.14
	kseitz_interps-20020829-merge:1.14
	cagney_sysregs-20020825-branch:1.14.0.4
	cagney_sysregs-20020825-branchpoint:1.14
	readline_4_3-import-branch:1.14.0.2
	readline_4_3-import-branchpoint:1.14
	gdb_5_2_1-2002-07-23-release:1.13
	kseitz_interps-20020528-branch:1.13.0.8
	kseitz_interps-20020528-branchpoint:1.13
	cagney_regbuf-20020515-branch:1.13.0.6
	cagney_regbuf-20020515-branchpoint:1.13
	jimb-macro-020506-branch:1.13.0.4
	jimb-macro-020506-branchpoint:1.13
	gdb_5_2-2002-04-29-release:1.13
	gdb_5_2-branch:1.13.0.2
	gdb_5_2-2002-03-03-branchpoint:1.13
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	cygnus_cvs_20020108_pre:1.11
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.8
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.6
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.4
	gdb_5_1-2001-07-29-branchpoint:1.7
	dberlin-typesystem-branch:1.7.0.2
	dberlin-typesystem-branchpoint:1.7
	gdb-post-ptid_t-2001-05-03:1.7
	gdb-pre-ptid_t-2001-05-03:1.7
	insight-precleanup-2001-01-01:1.5
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.6
	gdb_5_0-2000-05-19-release:1.1.1.6
	gdb_4_18_2-2000-05-18-release:1.1.1.6
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.6
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.6
	gdb_5_0-2000-04-10-branch:1.1.1.6.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.6
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.6
	gdb-1999-11-16:1.1.1.6
	gdb-1999-11-08:1.1.1.6
	gdb-1999-11-01:1.1.1.6
	gdb-1999-10-25:1.1.1.6
	gdb-1999-10-18:1.1.1.6
	gdb-1999-10-11:1.1.1.6
	gdb-1999-10-04:1.1.1.5
	gdb-1999-09-28:1.1.1.5
	gdb-1999-09-21:1.1.1.5
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.5
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.48
date	2007.03.30.17.21.47;	author drow;	state dead;
branches;
next	1.47;

1.47
date	2007.02.12.15.19.31;	author muller;	state Exp;
branches;
next	1.46;

1.46
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.45;

1.45
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.44;

1.44
date	2005.02.12.00.39.18;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2005.02.11.18.13.49;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2005.02.11.04.05.46;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2004.07.17.14.15.30;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2004.06.24.20.42.42;	author cagney;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2004.05.07.14.29.33;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.01.22.30.27;	author chastain;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.14.15.46.32;	author ezannoni;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2004.02.07.23.13.47;	author ezannoni;	state Exp;
branches;
next	1.35;

1.35
date	2004.02.07.18.29.53;	author ezannoni;	state Exp;
branches;
next	1.34;

1.34
date	2004.02.07.16.57.54;	author ezannoni;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.01.22.03.12;	author chastain;	state Exp;
branches;
next	1.32;

1.32
date	2003.11.23.20.41.16;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2003.11.06.22.54.01;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.12.18.40.16;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.27.13.09.38;	author ezannoni;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.23.19.51.38;	author drow;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.11.22.27.12;	author carlton;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2003.06.02.04.16.24;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.14.17.43.17;	author ezannoni;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.25.21.36.17;	author carlton;	state Exp;
branches
	1.24.16.1;
next	1.23;

1.23
date	2003.02.05.06.48.55;	author chastain;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.04.18.07.01;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.19.04.06.45;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.18.15.55.52;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.14.00.49.03;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.02.14.27.26;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.17.00.39.07;	author kevinb;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.11.00.55.34;	author drow;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.25.22.25.55;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.01.17.18.32;	author cagney;	state Exp;
branches
	1.14.8.1
	1.14.10.1;
next	1.13;

1.13
date	2002.02.04.11.55.34;	author rearnsha;	state Exp;
branches
	1.13.8.1;
next	1.12;

1.12
date	2002.02.02.02.28.40;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.12.02.11.51;	author fnf;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.06.23.38.14;	author fnf;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.20.03.03.40;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.05.02.13.11;	author ezannoni;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.06.08.21.07;	author kevinb;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.01.19.14.53.44;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.01.01.46;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.04.04.01.15;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.27;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.00;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.00;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.17.20.54;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.05.45;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.08.02.23.45.24;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.09.08.23.59.08;	author shebs;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.10.12.04.37.20;	author jsm;	state Exp;
branches;
next	;

1.7.2.1
date	2001.07.06.19.16.59;	author dberlin;	state Exp;
branches;
next	;

1.13.8.1
date	2002.08.09.18.34.23;	author kseitz;	state Exp;
branches;
next	1.13.8.2;

1.13.8.2
date	2002.11.04.00.17.30;	author ezannoni;	state Exp;
branches;
next	;

1.14.8.1
date	2002.09.20.18.52.16;	author carlton;	state Exp;
branches;
next	1.14.8.2;

1.14.8.2
date	2002.11.15.19.18.42;	author carlton;	state Exp;
branches;
next	1.14.8.3;

1.14.8.3
date	2002.12.23.19.38.21;	author carlton;	state Exp;
branches;
next	1.14.8.4;

1.14.8.4
date	2003.02.07.19.17.48;	author carlton;	state Exp;
branches;
next	1.14.8.5;

1.14.8.5
date	2003.03.06.00.56.27;	author carlton;	state Exp;
branches;
next	1.14.8.6;

1.14.8.6
date	2003.05.23.18.40.37;	author carlton;	state Exp;
branches;
next	1.14.8.7;

1.14.8.7
date	2003.06.27.21.49.53;	author carlton;	state Exp;
branches;
next	1.14.8.8;

1.14.8.8
date	2003.09.17.21.28.15;	author carlton;	state Exp;
branches;
next	1.14.8.9;

1.14.8.9
date	2003.11.11.23.50.42;	author carlton;	state Exp;
branches;
next	1.14.8.10;

1.14.8.10
date	2003.12.16.00.00.28;	author carlton;	state Exp;
branches;
next	;

1.14.10.1
date	2003.12.14.20.27.12;	author drow;	state Exp;
branches;
next	1.14.10.2;

1.14.10.2
date	2004.02.09.19.43.36;	author drow;	state Exp;
branches;
next	;

1.24.16.1
date	2003.05.18.09.44.05;	author kettenis;	state Exp;
branches;
next	;

1.27.4.1
date	2003.06.23.19.52.28;	author drow;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2003.06.27.13.32.36;	author ezannoni;	state Exp;
branches;
next	;

1.37.2.1
date	2004.09.16.17.01.02;	author drow;	state Exp;
branches;
next	;

1.40.2.1
date	2004.07.17.14.16.14;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.48
log
@	* MAINTAINERS: Remove d10v entry.
	* Makefile.in (SFILES): Remove dwarfread.c.
	(COMMON_OBS): Remove dwarfread.o.
	(gdb_sim_d10v_h, abug-rom.o, cpu32bug-rom.o, d10v-tdep.o, dwarfread.o)
	(remote-est.o, rom68k-rom.o): Delete.
	* NEWS: Mention removal of d10v, target abug, target cpu32bug,
	target est, target rom68k, and DWARF 1.
	* configure.tgt: Mark d10v as removed.
	* dwarf2read.c: Doc update.
	* elfread.c (struct elfinfo): Remove dboffset, dbsize, lnoffset,
	and lnsize.
	(elf_locate_sections): Do not set them.
	(elf_symfile_read): Do not call dwarf_build_psymtabs.
	* symfile.h (dwarf_build_psymtabs): Delete prototype.
	* config/m68k/monitor.mt (TDEPFILES): Prune.
	* abug-rom.c, cpu32bug-rom.c, d10v-tdep.c, dwarfread.c,
	remote-est.c, rom68k-rom.c, config/d10v/d10v.mt: Delete.

	* gdb.texinfo (M68K): Remove obsolete ROM monitors.
	* gdbint.texinfo (DWARF 1): Delete section and other dwarfread.c
	references.

	* gdb.asm/asm-source.exp: Remove d10v case.
	* lib/gdb.exp (skip_cplus_tests): Likewise.
	* gdb.asm/d10v.inc: Deleted.
@
text
@/* DWARF debugging format support for GDB.

   Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004, 2007 Free Software Foundation, Inc.

   Written by Fred Fish at Cygnus Support.  Portions based on dbxread.c,
   mipsread.c, coffread.c, and dwarfread.c from a Data General SVR4 gdb port.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

/*
   If you are looking for DWARF-2 support, you are in the wrong file.
   Go look in dwarf2read.c.  This file is for the original DWARF,
   also known as DWARF-1.

   DWARF-1 is slowly headed for obsoletion.

   In gcc 3.4.0, support for dwarf-1 has been removed.

   In gcc 3.3.2, these targets prefer dwarf-1:

     i[34567]86-sequent-ptx4*
     i[34567]86-sequent-sysv4*
     mips-sni-sysv4
     sparc-hal-solaris2*

   In gcc 3.2.2, these targets prefer dwarf-1:

     i[34567]86-dg-dgux*
     i[34567]86-sequent-ptx4*
     i[34567]86-sequent-sysv4*
     m88k-dg-dgux*
     mips-sni-sysv4
     sparc-hal-solaris2*

   In gcc 2.95.3, these targets prefer dwarf-1:

     i[34567]86-dg-dgux*
     i[34567]86-ncr-sysv4*
     i[34567]86-sequent-ptx4*
     i[34567]86-sequent-sysv4*
     i[34567]86-*-osf1*
     i[34567]86-*-sco3.2v5*
     i[34567]86-*-sysv4*
     i860-alliant-*
     i860-*-sysv4*
     m68k-atari-sysv4*
     m68k-cbm-sysv4*
     m68k-*-sysv4*
     m88k-dg-dgux*
     m88k-*-sysv4*
     mips-sni-sysv4
     mips-*-gnu*
     sh-*-elf*
     sh-*-rtemself*
     sparc-hal-solaris2*
     sparc-*-sysv4*

   Some non-gcc compilers produce dwarf-1: 

     PR gdb/1179 was from a user with Diab C++ 4.3.
     On 2003-07-25 the gdb list received a report from a user
      with Diab Compiler 4.4b.
     Other users have also reported using Diab compilers with dwarf-1.

     Diab Compiler Suite 5.0.1 supports dwarf-2/dwarf-3 for C and C++.
     (Diab(tm) Compiler Suite 5.0.1 Release Notes, DOC-14691-ZD-00,
     Wind River Systems, 2002-07-31).

     On 2003-06-09 the gdb list received a report from a user
       with Absoft ProFortran f77 which is dwarf-1.

     Absoft ProFortran Linux[sic] Fortran User Guide (no version,
     but copyright dates are 1991-2001) says that Absoft ProFortran
     supports -gdwarf1 and -gdwarf2.

   -- chastain 2004-04-24
*/

/*

   FIXME: Do we need to generate dependencies in partial symtabs?
   (Perhaps we don't need to).

   FIXME: Resolve minor differences between what information we put in the
   partial symbol table and what dbxread puts in.  For example, we don't yet
   put enum constants there.  And dbxread seems to invent a lot of typedefs
   we never see.  Use the new printpsym command to see the partial symbol table
   contents.

   FIXME: Figure out a better way to tell gdb about the name of the function
   contain the user's entry point (I.E. main())

   FIXME: See other FIXME's and "ifdef 0" scattered throughout the code for
   other things to work on, if you get bored. :-)

 */

#include "defs.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "objfiles.h"
#include "elf/dwarf.h"
#include "buildsym.h"
#include "demangle.h"
#include "expression.h"		/* Needed for enum exp_opcode in language.h, sigh... */
#include "language.h"
#include "complaints.h"

#include <fcntl.h>
#include "gdb_string.h"

/* Some macros to provide DIE info for complaints. */

#define DIE_ID (curdie!=NULL ? curdie->die_ref : 0)
#define DIE_NAME (curdie!=NULL && curdie->at_name!=NULL) ? curdie->at_name : ""

/* Complaints that can be issued during DWARF debug info reading. */

static void
bad_die_ref_complaint (int arg1, const char *arg2, int arg3)
{
  complaint (&symfile_complaints,
	     _("DIE @@ 0x%x \"%s\", reference to DIE (0x%x) outside compilation unit"),
	     arg1, arg2, arg3);
}

static void
unknown_attribute_form_complaint (int arg1, const char *arg2, int arg3)
{
  complaint (&symfile_complaints,
	     _("DIE @@ 0x%x \"%s\", unknown attribute form (0x%x)"), arg1, arg2,
	     arg3);
}

static void
dup_user_type_definition_complaint (int arg1, const char *arg2)
{
  complaint (&symfile_complaints,
	     _("DIE @@ 0x%x \"%s\", internal error: duplicate user type definition"),
	     arg1, arg2);
}

static void
bad_array_element_type_complaint (int arg1, const char *arg2, int arg3)
{
  complaint (&symfile_complaints,
	     _("DIE @@ 0x%x \"%s\", bad array element type attribute 0x%x"), arg1,
	     arg2, arg3);
}

typedef unsigned int DIE_REF;	/* Reference to a DIE */

#ifndef GCC_PRODUCER
#define GCC_PRODUCER "GNU C "
#endif

#ifndef GPLUS_PRODUCER
#define GPLUS_PRODUCER "GNU C++ "
#endif

#ifndef LCC_PRODUCER
#define LCC_PRODUCER "NCR C/C++"
#endif

/* Flags to target_to_host() that tell whether or not the data object is
   expected to be signed.  Used, for example, when fetching a signed
   integer in the target environment which is used as a signed integer
   in the host environment, and the two environments have different sized
   ints.  In this case, *somebody* has to sign extend the smaller sized
   int. */

#define GET_UNSIGNED	0	/* No sign extension required */
#define GET_SIGNED	1	/* Sign extension required */

/* Defines for things which are specified in the document "DWARF Debugging
   Information Format" published by UNIX International, Programming Languages
   SIG.  These defines are based on revision 1.0.0, Jan 20, 1992. */

#define SIZEOF_DIE_LENGTH	4
#define SIZEOF_DIE_TAG		2
#define SIZEOF_ATTRIBUTE	2
#define SIZEOF_FORMAT_SPECIFIER	1
#define SIZEOF_FMT_FT		2
#define SIZEOF_LINETBL_LENGTH	4
#define SIZEOF_LINETBL_LINENO	4
#define SIZEOF_LINETBL_STMT	2
#define SIZEOF_LINETBL_DELTA	4
#define SIZEOF_LOC_ATOM_CODE	1

#define FORM_FROM_ATTR(attr)	((attr) & 0xF)	/* Implicitly specified */

/* Macros that return the sizes of various types of data in the target
   environment.

   FIXME:  Currently these are just compile time constants (as they are in
   other parts of gdb as well).  They need to be able to get the right size
   either from the bfd or possibly from the DWARF info.  It would be nice if
   the DWARF producer inserted DIES that describe the fundamental types in
   the target environment into the DWARF info, similar to the way dbx stabs
   producers produce information about their fundamental types. */

#define TARGET_FT_POINTER_SIZE(objfile)	(TARGET_PTR_BIT / TARGET_CHAR_BIT)
#define TARGET_FT_LONG_SIZE(objfile)	(TARGET_LONG_BIT / TARGET_CHAR_BIT)

/* The Amiga SVR4 header file <dwarf.h> defines AT_element_list as a
   FORM_BLOCK2, and this is the value emitted by the AT&T compiler.
   However, the Issue 2 DWARF specification from AT&T defines it as
   a FORM_BLOCK4, as does the latest specification from UI/PLSIG.
   For backwards compatibility with the AT&T compiler produced executables
   we define AT_short_element_list for this variant. */

#define	AT_short_element_list	 (0x00f0|FORM_BLOCK2)

/* The DWARF debugging information consists of two major pieces,
   one is a block of DWARF Information Entries (DIE's) and the other
   is a line number table.  The "struct dieinfo" structure contains
   the information for a single DIE, the one currently being processed.

   In order to make it easier to randomly access the attribute fields
   of the current DIE, which are specifically unordered within the DIE,
   each DIE is scanned and an instance of the "struct dieinfo"
   structure is initialized.

   Initialization is done in two levels.  The first, done by basicdieinfo(),
   just initializes those fields that are vital to deciding whether or not
   to use this DIE, how to skip past it, etc.  The second, done by the
   function completedieinfo(), fills in the rest of the information.

   Attributes which have block forms are not interpreted at the time
   the DIE is scanned, instead we just save pointers to the start
   of their value fields.

   Some fields have a flag <name>_p that is set when the value of the
   field is valid (I.E. we found a matching attribute in the DIE).  Since
   we may want to test for the presence of some attributes in the DIE,
   such as AT_low_pc, without restricting the values of the field,
   we need someway to note that we found such an attribute.

 */

typedef char BLOCK;

struct dieinfo
  {
    char *die;			/* Pointer to the raw DIE data */
    unsigned long die_length;	/* Length of the raw DIE data */
    DIE_REF die_ref;		/* Offset of this DIE */
    unsigned short die_tag;	/* Tag for this DIE */
    unsigned long at_padding;
    unsigned long at_sibling;
    BLOCK *at_location;
    char *at_name;
    unsigned short at_fund_type;
    BLOCK *at_mod_fund_type;
    unsigned long at_user_def_type;
    BLOCK *at_mod_u_d_type;
    unsigned short at_ordering;
    BLOCK *at_subscr_data;
    unsigned long at_byte_size;
    unsigned short at_bit_offset;
    unsigned long at_bit_size;
    BLOCK *at_element_list;
    unsigned long at_stmt_list;
    CORE_ADDR at_low_pc;
    CORE_ADDR at_high_pc;
    unsigned long at_language;
    unsigned long at_member;
    unsigned long at_discr;
    BLOCK *at_discr_value;
    BLOCK *at_string_length;
    char *at_comp_dir;
    char *at_producer;
    unsigned long at_start_scope;
    unsigned long at_stride_size;
    unsigned long at_src_info;
    char *at_prototyped;
    unsigned int has_at_low_pc:1;
    unsigned int has_at_stmt_list:1;
    unsigned int has_at_byte_size:1;
    unsigned int short_element_list:1;

    /* Kludge to identify register variables */

    unsigned int isreg;

    /* Kludge to identify optimized out variables */

    unsigned int optimized_out;

    /* Kludge to identify basereg references.
       Nonzero if we have an offset relative to a basereg.  */

    unsigned int offreg;

    /* Kludge to identify which base register is it relative to.  */

    unsigned int basereg;
  };

static int diecount;		/* Approximate count of dies for compilation unit */
static struct dieinfo *curdie;	/* For warnings and such */

static char *dbbase;		/* Base pointer to dwarf info */
static int dbsize;		/* Size of dwarf info in bytes */
static int dbroff;		/* Relative offset from start of .debug section */
static char *lnbase;		/* Base pointer to line section */

/* This value is added to each symbol value.  FIXME:  Generalize to 
   the section_offsets structure used by dbxread (once this is done,
   pass the appropriate section number to end_symtab).  */
static CORE_ADDR baseaddr;	/* Add to each symbol value */

/* The section offsets used in the current psymtab or symtab.  FIXME,
   only used to pass one value (baseaddr) at the moment.  */
static struct section_offsets *base_section_offsets;

/* We put a pointer to this structure in the read_symtab_private field
   of the psymtab.  */

struct dwfinfo
  {
    /* Always the absolute file offset to the start of the ".debug"
       section for the file containing the DIE's being accessed.  */
    file_ptr dbfoff;
    /* Relative offset from the start of the ".debug" section to the
       first DIE to be accessed.  When building the partial symbol
       table, this value will be zero since we are accessing the
       entire ".debug" section.  When expanding a partial symbol
       table entry, this value will be the offset to the first
       DIE for the compilation unit containing the symbol that
       triggers the expansion.  */
    int dbroff;
    /* The size of the chunk of DIE's being examined, in bytes.  */
    int dblength;
    /* The absolute file offset to the line table fragment.  Ignored
       when building partial symbol tables, but used when expanding
       them, and contains the absolute file offset to the fragment
       of the ".line" section containing the line numbers for the
       current compilation unit.  */
    file_ptr lnfoff;
  };

#define DBFOFF(p) (((struct dwfinfo *)((p)->read_symtab_private))->dbfoff)
#define DBROFF(p) (((struct dwfinfo *)((p)->read_symtab_private))->dbroff)
#define DBLENGTH(p) (((struct dwfinfo *)((p)->read_symtab_private))->dblength)
#define LNFOFF(p) (((struct dwfinfo *)((p)->read_symtab_private))->lnfoff)

/* The generic symbol table building routines have separate lists for
   file scope symbols and all all other scopes (local scopes).  So
   we need to select the right one to pass to add_symbol_to_list().
   We do it by keeping a pointer to the correct list in list_in_scope.

   FIXME:  The original dwarf code just treated the file scope as the first
   local scope, and all other local scopes as nested local scopes, and worked
   fine.  Check to see if we really need to distinguish these in buildsym.c */

struct pending **list_in_scope = &file_symbols;

/* DIES which have user defined types or modified user defined types refer to
   other DIES for the type information.  Thus we need to associate the offset
   of a DIE for a user defined type with a pointer to the type information.

   Originally this was done using a simple but expensive algorithm, with an
   array of unsorted structures, each containing an offset/type-pointer pair.
   This array was scanned linearly each time a lookup was done.  The result
   was that gdb was spending over half it's startup time munging through this
   array of pointers looking for a structure that had the right offset member.

   The second attempt used the same array of structures, but the array was
   sorted using qsort each time a new offset/type was recorded, and a binary
   search was used to find the type pointer for a given DIE offset.  This was
   even slower, due to the overhead of sorting the array each time a new
   offset/type pair was entered.

   The third attempt uses a fixed size array of type pointers, indexed by a
   value derived from the DIE offset.  Since the minimum DIE size is 4 bytes,
   we can divide any DIE offset by 4 to obtain a unique index into this fixed
   size array.  Since each element is a 4 byte pointer, it takes exactly as
   much memory to hold this array as to hold the DWARF info for a given
   compilation unit.  But it gets freed as soon as we are done with it.
   This has worked well in practice, as a reasonable tradeoff between memory
   consumption and speed, without having to resort to much more complicated
   algorithms. */

static struct type **utypes;	/* Pointer to array of user type pointers */
static int numutypes;		/* Max number of user type pointers */

/* Maintain an array of referenced fundamental types for the current
   compilation unit being read.  For DWARF version 1, we have to construct
   the fundamental types on the fly, since no information about the
   fundamental types is supplied.  Each such fundamental type is created by
   calling a language dependent routine to create the type, and then a
   pointer to that type is then placed in the array at the index specified
   by it's FT_<TYPENAME> value.  The array has a fixed size set by the
   FT_NUM_MEMBERS compile time constant, which is the number of predefined
   fundamental types gdb knows how to construct. */

static struct type *ftypes[FT_NUM_MEMBERS];	/* Fundamental types */

/* Record the language for the compilation unit which is currently being
   processed.  We know it once we have seen the TAG_compile_unit DIE,
   and we need it while processing the DIE's for that compilation unit.
   It is eventually saved in the symtab structure, but we don't finalize
   the symtab struct until we have processed all the DIE's for the
   compilation unit.  We also need to get and save a pointer to the 
   language struct for this language, so we can call the language
   dependent routines for doing things such as creating fundamental
   types. */

static enum language cu_language;
static const struct language_defn *cu_language_defn;

/* Forward declarations of static functions so we don't have to worry
   about ordering within this file.  */

static void free_utypes (void *);

static int attribute_size (unsigned int);

static CORE_ADDR target_to_host (char *, int, int, struct objfile *);

static void add_enum_psymbol (struct dieinfo *, struct objfile *);

static void handle_producer (char *);

static void read_file_scope (struct dieinfo *, char *, char *,
			     struct objfile *);

static void read_func_scope (struct dieinfo *, char *, char *,
			     struct objfile *);

static void read_lexical_block_scope (struct dieinfo *, char *, char *,
				      struct objfile *);

static void scan_partial_symbols (char *, char *, struct objfile *);

static void scan_compilation_units (char *, char *, file_ptr, file_ptr,
				    struct objfile *);

static void add_partial_symbol (struct dieinfo *, struct objfile *);

static void basicdieinfo (struct dieinfo *, char *, struct objfile *);

static void completedieinfo (struct dieinfo *, struct objfile *);

static void dwarf_psymtab_to_symtab (struct partial_symtab *);

static void psymtab_to_symtab_1 (struct partial_symtab *);

static void read_ofile_symtab (struct partial_symtab *);

static void process_dies (char *, char *, struct objfile *);

static void read_structure_scope (struct dieinfo *, char *, char *,
				  struct objfile *);

static struct type *decode_array_element_type (char *);

static struct type *decode_subscript_data_item (char *, char *);

static void dwarf_read_array_type (struct dieinfo *);

static void read_tag_pointer_type (struct dieinfo *dip);

static void read_tag_string_type (struct dieinfo *dip);

static void read_subroutine_type (struct dieinfo *, char *, char *);

static void read_enumeration (struct dieinfo *, char *, char *,
			      struct objfile *);

static struct type *struct_type (struct dieinfo *, char *, char *,
				 struct objfile *);

static struct type *enum_type (struct dieinfo *, struct objfile *);

static void decode_line_numbers (char *);

static struct type *decode_die_type (struct dieinfo *);

static struct type *decode_mod_fund_type (char *);

static struct type *decode_mod_u_d_type (char *);

static struct type *decode_modified_type (char *, unsigned int, int);

static struct type *decode_fund_type (unsigned int);

static char *create_name (char *, struct obstack *);

static struct type *lookup_utype (DIE_REF);

static struct type *alloc_utype (DIE_REF, struct type *);

static struct symbol *new_symbol (struct dieinfo *, struct objfile *);

static void synthesize_typedef (struct dieinfo *, struct objfile *,
				struct type *);

static int locval (struct dieinfo *);

static void set_cu_language (struct dieinfo *);

static struct type *dwarf_fundamental_type (struct objfile *, int);


/*

   LOCAL FUNCTION

   dwarf_fundamental_type -- lookup or create a fundamental type

   SYNOPSIS

   struct type *
   dwarf_fundamental_type (struct objfile *objfile, int typeid)

   DESCRIPTION

   DWARF version 1 doesn't supply any fundamental type information,
   so gdb has to construct such types.  It has a fixed number of
   fundamental types that it knows how to construct, which is the
   union of all types that it knows how to construct for all languages
   that it knows about.  These are enumerated in gdbtypes.h.

   As an example, assume we find a DIE that references a DWARF
   fundamental type of FT_integer.  We first look in the ftypes
   array to see if we already have such a type, indexed by the
   gdb internal value of FT_INTEGER.  If so, we simply return a
   pointer to that type.  If not, then we ask an appropriate
   language dependent routine to create a type FT_INTEGER, using
   defaults reasonable for the current target machine, and install
   that type in ftypes for future reference.

   RETURNS

   Pointer to a fundamental type.

 */

static struct type *
dwarf_fundamental_type (struct objfile *objfile, int typeid)
{
  if (typeid < 0 || typeid >= FT_NUM_MEMBERS)
    {
      error (_("internal error - invalid fundamental type id %d"), typeid);
    }

  /* Look for this particular type in the fundamental type vector.  If one is
     not found, create and install one appropriate for the current language
     and the current target machine. */

  if (ftypes[typeid] == NULL)
    {
      ftypes[typeid] = cu_language_defn->la_fund_type (objfile, typeid);
    }

  return (ftypes[typeid]);
}

/*

   LOCAL FUNCTION

   set_cu_language -- set local copy of language for compilation unit

   SYNOPSIS

   void
   set_cu_language (struct dieinfo *dip)

   DESCRIPTION

   Decode the language attribute for a compilation unit DIE and
   remember what the language was.  We use this at various times
   when processing DIE's for a given compilation unit.

   RETURNS

   No return value.

 */

static void
set_cu_language (struct dieinfo *dip)
{
  switch (dip->at_language)
    {
    case LANG_C89:
    case LANG_C:
      cu_language = language_c;
      break;
    case LANG_C_PLUS_PLUS:
      cu_language = language_cplus;
      break;
    case LANG_MODULA2:
      cu_language = language_m2;
      break;
    case LANG_FORTRAN77:
    case LANG_FORTRAN90:
      cu_language = language_fortran;
      break;
    case LANG_PASCAL83:
      cu_language = language_pascal;
      break;
    case LANG_ADA83:
    case LANG_COBOL74:
    case LANG_COBOL85:
      /* We don't know anything special about these yet. */
      cu_language = language_unknown;
      break;
    default:
      /* If no at_language, try to deduce one from the filename */
      cu_language = deduce_language_from_filename (dip->at_name);
      break;
    }
  cu_language_defn = language_def (cu_language);
}

/*

   GLOBAL FUNCTION

   dwarf_build_psymtabs -- build partial symtabs from DWARF debug info

   SYNOPSIS

   void dwarf_build_psymtabs (struct objfile *objfile,
   int mainline, file_ptr dbfoff, unsigned int dbfsize,
   file_ptr lnoffset, unsigned int lnsize)

   DESCRIPTION

   This function is called upon to build partial symtabs from files
   containing DIE's (Dwarf Information Entries) and DWARF line numbers.

   It is passed a bfd* containing the DIES
   and line number information, the corresponding filename for that
   file, a base address for relocating the symbols, a flag indicating
   whether or not this debugging information is from a "main symbol
   table" rather than a shared library or dynamically linked file,
   and file offset/size pairs for the DIE information and line number
   information.

   RETURNS

   No return value.

 */

void
dwarf_build_psymtabs (struct objfile *objfile, int mainline, file_ptr dbfoff,
		      unsigned int dbfsize, file_ptr lnoffset,
		      unsigned int lnsize)
{
  bfd *abfd = objfile->obfd;
  struct cleanup *back_to;

  current_objfile = objfile;
  dbsize = dbfsize;
  dbbase = xmalloc (dbsize);
  dbroff = 0;
  if ((bfd_seek (abfd, dbfoff, SEEK_SET) != 0) ||
      (bfd_bread (dbbase, dbsize, abfd) != dbsize))
    {
      xfree (dbbase);
      error (_("can't read DWARF data from '%s'"), bfd_get_filename (abfd));
    }
  back_to = make_cleanup (xfree, dbbase);

  /* If we are reinitializing, or if we have never loaded syms yet, init.
     Since we have no idea how many DIES we are looking at, we just guess
     some arbitrary value. */

  if (mainline
      || (objfile->global_psymbols.size == 0
	  && objfile->static_psymbols.size == 0))
    {
      init_psymbol_list (objfile, 1024);
    }

  /* Save the relocation factor where everybody can see it.  */

  base_section_offsets = objfile->section_offsets;
  baseaddr = ANOFFSET (objfile->section_offsets, 0);

  /* Follow the compilation unit sibling chain, building a partial symbol
     table entry for each one.  Save enough information about each compilation
     unit to locate the full DWARF information later. */

  scan_compilation_units (dbbase, dbbase + dbsize, dbfoff, lnoffset, objfile);

  do_cleanups (back_to);
  current_objfile = NULL;
}

/*

   LOCAL FUNCTION

   read_lexical_block_scope -- process all dies in a lexical block

   SYNOPSIS

   static void read_lexical_block_scope (struct dieinfo *dip,
   char *thisdie, char *enddie)

   DESCRIPTION

   Process all the DIES contained within a lexical block scope.
   Start a new scope, process the dies, and then close the scope.

 */

static void
read_lexical_block_scope (struct dieinfo *dip, char *thisdie, char *enddie,
			  struct objfile *objfile)
{
  struct context_stack *new;

  push_context (0, dip->at_low_pc);
  process_dies (thisdie + dip->die_length, enddie, objfile);
  new = pop_context ();
  if (local_symbols != NULL)
    {
      finish_block (0, &local_symbols, new->old_blocks, new->start_addr,
		    dip->at_high_pc, objfile);
    }
  local_symbols = new->locals;
}

/*

   LOCAL FUNCTION

   lookup_utype -- look up a user defined type from die reference

   SYNOPSIS

   static type *lookup_utype (DIE_REF die_ref)

   DESCRIPTION

   Given a DIE reference, lookup the user defined type associated with
   that DIE, if it has been registered already.  If not registered, then
   return NULL.  Alloc_utype() can be called to register an empty
   type for this reference, which will be filled in later when the
   actual referenced DIE is processed.
 */

static struct type *
lookup_utype (DIE_REF die_ref)
{
  struct type *type = NULL;
  int utypeidx;

  utypeidx = (die_ref - dbroff) / 4;
  if ((utypeidx < 0) || (utypeidx >= numutypes))
    {
      bad_die_ref_complaint (DIE_ID, DIE_NAME, die_ref);
    }
  else
    {
      type = *(utypes + utypeidx);
    }
  return (type);
}


/*

   LOCAL FUNCTION

   alloc_utype  -- add a user defined type for die reference

   SYNOPSIS

   static type *alloc_utype (DIE_REF die_ref, struct type *utypep)

   DESCRIPTION

   Given a die reference DIE_REF, and a possible pointer to a user
   defined type UTYPEP, register that this reference has a user
   defined type and either use the specified type in UTYPEP or
   make a new empty type that will be filled in later.

   We should only be called after calling lookup_utype() to verify that
   there is not currently a type registered for DIE_REF.
 */

static struct type *
alloc_utype (DIE_REF die_ref, struct type *utypep)
{
  struct type **typep;
  int utypeidx;

  utypeidx = (die_ref - dbroff) / 4;
  typep = utypes + utypeidx;
  if ((utypeidx < 0) || (utypeidx >= numutypes))
    {
      utypep = dwarf_fundamental_type (current_objfile, FT_INTEGER);
      bad_die_ref_complaint (DIE_ID, DIE_NAME, die_ref);
    }
  else if (*typep != NULL)
    {
      utypep = *typep;
      complaint (&symfile_complaints,
		 _("DIE @@ 0x%x \"%s\", internal error: duplicate user type allocation"),
		 DIE_ID, DIE_NAME);
    }
  else
    {
      if (utypep == NULL)
	{
	  utypep = alloc_type (current_objfile);
	}
      *typep = utypep;
    }
  return (utypep);
}

/*

   LOCAL FUNCTION

   free_utypes -- free the utypes array and reset pointer & count

   SYNOPSIS

   static void free_utypes (void *dummy)

   DESCRIPTION

   Called via do_cleanups to free the utypes array, reset the pointer to NULL,
   and set numutypes back to zero.  This ensures that the utypes does not get
   referenced after being freed.
 */

static void
free_utypes (void *dummy)
{
  xfree (utypes);
  utypes = NULL;
  numutypes = 0;
}


/*

   LOCAL FUNCTION

   decode_die_type -- return a type for a specified die

   SYNOPSIS

   static struct type *decode_die_type (struct dieinfo *dip)

   DESCRIPTION

   Given a pointer to a die information structure DIP, decode the
   type of the die and return a pointer to the decoded type.  All
   dies without specific types default to type int.
 */

static struct type *
decode_die_type (struct dieinfo *dip)
{
  struct type *type = NULL;

  if (dip->at_fund_type != 0)
    {
      type = decode_fund_type (dip->at_fund_type);
    }
  else if (dip->at_mod_fund_type != NULL)
    {
      type = decode_mod_fund_type (dip->at_mod_fund_type);
    }
  else if (dip->at_user_def_type)
    {
      type = lookup_utype (dip->at_user_def_type);
      if (type == NULL)
	{
	  type = alloc_utype (dip->at_user_def_type, NULL);
	}
    }
  else if (dip->at_mod_u_d_type)
    {
      type = decode_mod_u_d_type (dip->at_mod_u_d_type);
    }
  else
    {
      type = dwarf_fundamental_type (current_objfile, FT_VOID);
    }
  return (type);
}

/*

   LOCAL FUNCTION

   struct_type -- compute and return the type for a struct or union

   SYNOPSIS

   static struct type *struct_type (struct dieinfo *dip, char *thisdie,
   char *enddie, struct objfile *objfile)

   DESCRIPTION

   Given pointer to a die information structure for a die which
   defines a union or structure (and MUST define one or the other),
   and pointers to the raw die data that define the range of dies which
   define the members, compute and return the user defined type for the
   structure or union.
 */

static struct type *
struct_type (struct dieinfo *dip, char *thisdie, char *enddie,
	     struct objfile *objfile)
{
  struct type *type;
  struct nextfield
    {
      struct nextfield *next;
      struct field field;
    };
  struct nextfield *list = NULL;
  struct nextfield *new;
  int nfields = 0;
  int n;
  struct dieinfo mbr;
  char *nextdie;
  int anonymous_size;

  type = lookup_utype (dip->die_ref);
  if (type == NULL)
    {
      /* No forward references created an empty type, so install one now */
      type = alloc_utype (dip->die_ref, NULL);
    }
  INIT_CPLUS_SPECIFIC (type);
  switch (dip->die_tag)
    {
    case TAG_class_type:
      TYPE_CODE (type) = TYPE_CODE_CLASS;
      break;
    case TAG_structure_type:
      TYPE_CODE (type) = TYPE_CODE_STRUCT;
      break;
    case TAG_union_type:
      TYPE_CODE (type) = TYPE_CODE_UNION;
      break;
    default:
      /* Should never happen */
      TYPE_CODE (type) = TYPE_CODE_UNDEF;
      complaint (&symfile_complaints,
		 _("DIE @@ 0x%x \"%s\", missing class, structure, or union tag"),
		 DIE_ID, DIE_NAME);
      break;
    }
  /* Some compilers try to be helpful by inventing "fake" names for
     anonymous enums, structures, and unions, like "~0fake" or ".0fake".
     Thanks, but no thanks... */
  if (dip->at_name != NULL
      && *dip->at_name != '~'
      && *dip->at_name != '.')
    {
      TYPE_TAG_NAME (type) = obconcat (&objfile->objfile_obstack,
				       "", "", dip->at_name);
    }
  /* Use whatever size is known.  Zero is a valid size.  We might however
     wish to check has_at_byte_size to make sure that some byte size was
     given explicitly, but DWARF doesn't specify that explicit sizes of
     zero have to present, so complaining about missing sizes should 
     probably not be the default. */
  TYPE_LENGTH (type) = dip->at_byte_size;
  thisdie += dip->die_length;
  while (thisdie < enddie)
    {
      basicdieinfo (&mbr, thisdie, objfile);
      completedieinfo (&mbr, objfile);
      if (mbr.die_length <= SIZEOF_DIE_LENGTH)
	{
	  break;
	}
      else if (mbr.at_sibling != 0)
	{
	  nextdie = dbbase + mbr.at_sibling - dbroff;
	}
      else
	{
	  nextdie = thisdie + mbr.die_length;
	}
      switch (mbr.die_tag)
	{
	case TAG_member:
	  /* Static fields can be either TAG_global_variable (GCC) or else
	     TAG_member with no location (Diab).  We could treat the latter like
	     the former... but since we don't support the former, just avoid
	     crashing on the latter for now.  */
	  if (mbr.at_location == NULL)
	    break;

	  /* Get space to record the next field's data.  */
	  new = (struct nextfield *) alloca (sizeof (struct nextfield));
	  new->next = list;
	  list = new;
	  /* Save the data.  */
	  list->field.name =
	    obsavestring (mbr.at_name, strlen (mbr.at_name),
			  &objfile->objfile_obstack);
	  FIELD_TYPE (list->field) = decode_die_type (&mbr);
	  FIELD_BITPOS (list->field) = 8 * locval (&mbr);
	  FIELD_STATIC_KIND (list->field) = 0;
	  /* Handle bit fields. */
	  FIELD_BITSIZE (list->field) = mbr.at_bit_size;
	  if (BITS_BIG_ENDIAN)
	    {
	      /* For big endian bits, the at_bit_offset gives the
	         additional bit offset from the MSB of the containing
	         anonymous object to the MSB of the field.  We don't
	         have to do anything special since we don't need to
	         know the size of the anonymous object. */
	      FIELD_BITPOS (list->field) += mbr.at_bit_offset;
	    }
	  else
	    {
	      /* For little endian bits, we need to have a non-zero
	         at_bit_size, so that we know we are in fact dealing
	         with a bitfield.  Compute the bit offset to the MSB
	         of the anonymous object, subtract off the number of
	         bits from the MSB of the field to the MSB of the
	         object, and then subtract off the number of bits of
	         the field itself.  The result is the bit offset of
	         the LSB of the field. */
	      if (mbr.at_bit_size > 0)
		{
		  if (mbr.has_at_byte_size)
		    {
		      /* The size of the anonymous object containing
		         the bit field is explicit, so use the
		         indicated size (in bytes). */
		      anonymous_size = mbr.at_byte_size;
		    }
		  else
		    {
		      /* The size of the anonymous object containing
		         the bit field matches the size of an object
		         of the bit field's type.  DWARF allows
		         at_byte_size to be left out in such cases, as
		         a debug information size optimization. */
		      anonymous_size = TYPE_LENGTH (list->field.type);
		    }
		  FIELD_BITPOS (list->field) +=
		    anonymous_size * 8 - mbr.at_bit_offset - mbr.at_bit_size;
		}
	    }
	  nfields++;
	  break;
	default:
	  process_dies (thisdie, nextdie, objfile);
	  break;
	}
      thisdie = nextdie;
    }
  /* Now create the vector of fields, and record how big it is.  We may
     not even have any fields, if this DIE was generated due to a reference
     to an anonymous structure or union.  In this case, TYPE_FLAG_STUB is
     set, which clues gdb in to the fact that it needs to search elsewhere
     for the full structure definition. */
  if (nfields == 0)
    {
      TYPE_FLAGS (type) |= TYPE_FLAG_STUB;
    }
  else
    {
      TYPE_NFIELDS (type) = nfields;
      TYPE_FIELDS (type) = (struct field *)
	TYPE_ALLOC (type, sizeof (struct field) * nfields);
      /* Copy the saved-up fields into the field vector.  */
      for (n = nfields; list; list = list->next)
	{
	  TYPE_FIELD (type, --n) = list->field;
	}
    }
  return (type);
}

/*

   LOCAL FUNCTION

   read_structure_scope -- process all dies within struct or union

   SYNOPSIS

   static void read_structure_scope (struct dieinfo *dip,
   char *thisdie, char *enddie, struct objfile *objfile)

   DESCRIPTION

   Called when we find the DIE that starts a structure or union
   scope (definition) to process all dies that define the members
   of the structure or union.  DIP is a pointer to the die info
   struct for the DIE that names the structure or union.

   NOTES

   Note that we need to call struct_type regardless of whether or not
   the DIE has an at_name attribute, since it might be an anonymous
   structure or union.  This gets the type entered into our set of
   user defined types.

   However, if the structure is incomplete (an opaque struct/union)
   then suppress creating a symbol table entry for it since gdb only
   wants to find the one with the complete definition.  Note that if
   it is complete, we just call new_symbol, which does it's own
   checking about whether the struct/union is anonymous or not (and
   suppresses creating a symbol table entry itself).

 */

static void
read_structure_scope (struct dieinfo *dip, char *thisdie, char *enddie,
		      struct objfile *objfile)
{
  struct type *type;
  struct symbol *sym;

  type = struct_type (dip, thisdie, enddie, objfile);
  if (!TYPE_STUB (type))
    {
      sym = new_symbol (dip, objfile);
      if (sym != NULL)
	{
	  SYMBOL_TYPE (sym) = type;
	  if (cu_language == language_cplus)
	    {
	      synthesize_typedef (dip, objfile, type);
	    }
	}
    }
}

/*

   LOCAL FUNCTION

   decode_array_element_type -- decode type of the array elements

   SYNOPSIS

   static struct type *decode_array_element_type (char *scan, char *end)

   DESCRIPTION

   As the last step in decoding the array subscript information for an
   array DIE, we need to decode the type of the array elements.  We are
   passed a pointer to this last part of the subscript information and
   must return the appropriate type.  If the type attribute is not
   recognized, just warn about the problem and return type int.
 */

static struct type *
decode_array_element_type (char *scan)
{
  struct type *typep;
  DIE_REF die_ref;
  unsigned short attribute;
  unsigned short fundtype;
  int nbytes;

  attribute = target_to_host (scan, SIZEOF_ATTRIBUTE, GET_UNSIGNED,
			      current_objfile);
  scan += SIZEOF_ATTRIBUTE;
  nbytes = attribute_size (attribute);
  if (nbytes == -1)
    {
      bad_array_element_type_complaint (DIE_ID, DIE_NAME, attribute);
      typep = dwarf_fundamental_type (current_objfile, FT_INTEGER);
    }
  else
    {
      switch (attribute)
	{
	case AT_fund_type:
	  fundtype = target_to_host (scan, nbytes, GET_UNSIGNED,
				     current_objfile);
	  typep = decode_fund_type (fundtype);
	  break;
	case AT_mod_fund_type:
	  typep = decode_mod_fund_type (scan);
	  break;
	case AT_user_def_type:
	  die_ref = target_to_host (scan, nbytes, GET_UNSIGNED,
				    current_objfile);
	  typep = lookup_utype (die_ref);
	  if (typep == NULL)
	    {
	      typep = alloc_utype (die_ref, NULL);
	    }
	  break;
	case AT_mod_u_d_type:
	  typep = decode_mod_u_d_type (scan);
	  break;
	default:
	  bad_array_element_type_complaint (DIE_ID, DIE_NAME, attribute);
	  typep = dwarf_fundamental_type (current_objfile, FT_INTEGER);
	  break;
	}
    }
  return (typep);
}

/*

   LOCAL FUNCTION

   decode_subscript_data_item -- decode array subscript item

   SYNOPSIS

   static struct type *
   decode_subscript_data_item (char *scan, char *end)

   DESCRIPTION

   The array subscripts and the data type of the elements of an
   array are described by a list of data items, stored as a block
   of contiguous bytes.  There is a data item describing each array
   dimension, and a final data item describing the element type.
   The data items are ordered the same as their appearance in the
   source (I.E. leftmost dimension first, next to leftmost second,
   etc).

   The data items describing each array dimension consist of four
   parts: (1) a format specifier, (2) type type of the subscript
   index, (3) a description of the low bound of the array dimension,
   and (4) a description of the high bound of the array dimension.

   The last data item is the description of the type of each of
   the array elements.

   We are passed a pointer to the start of the block of bytes
   containing the remaining data items, and a pointer to the first
   byte past the data.  This function recursively decodes the
   remaining data items and returns a type.

   If we somehow fail to decode some data, we complain about it
   and return a type "array of int".

   BUGS
   FIXME:  This code only implements the forms currently used
   by the AT&T and GNU C compilers.

   The end pointer is supplied for error checking, maybe we should
   use it for that...
 */

static struct type *
decode_subscript_data_item (char *scan, char *end)
{
  struct type *typep = NULL;	/* Array type we are building */
  struct type *nexttype;	/* Type of each element (may be array) */
  struct type *indextype;	/* Type of this index */
  struct type *rangetype;
  unsigned int format;
  unsigned short fundtype;
  unsigned long lowbound;
  unsigned long highbound;
  int nbytes;

  format = target_to_host (scan, SIZEOF_FORMAT_SPECIFIER, GET_UNSIGNED,
			   current_objfile);
  scan += SIZEOF_FORMAT_SPECIFIER;
  switch (format)
    {
    case FMT_ET:
      typep = decode_array_element_type (scan);
      break;
    case FMT_FT_C_C:
      fundtype = target_to_host (scan, SIZEOF_FMT_FT, GET_UNSIGNED,
				 current_objfile);
      indextype = decode_fund_type (fundtype);
      scan += SIZEOF_FMT_FT;
      nbytes = TARGET_FT_LONG_SIZE (current_objfile);
      lowbound = target_to_host (scan, nbytes, GET_UNSIGNED, current_objfile);
      scan += nbytes;
      highbound = target_to_host (scan, nbytes, GET_UNSIGNED, current_objfile);
      scan += nbytes;
      nexttype = decode_subscript_data_item (scan, end);
      if (nexttype == NULL)
	{
	  /* Munged subscript data or other problem, fake it. */
	  complaint (&symfile_complaints,
		     _("DIE @@ 0x%x \"%s\", can't decode subscript data items"),
		     DIE_ID, DIE_NAME);
	  nexttype = dwarf_fundamental_type (current_objfile, FT_INTEGER);
	}
      rangetype = create_range_type ((struct type *) NULL, indextype,
				     lowbound, highbound);
      typep = create_array_type ((struct type *) NULL, nexttype, rangetype);
      break;
    case FMT_FT_C_X:
    case FMT_FT_X_C:
    case FMT_FT_X_X:
    case FMT_UT_C_C:
    case FMT_UT_C_X:
    case FMT_UT_X_C:
    case FMT_UT_X_X:
      complaint (&symfile_complaints,
		 _("DIE @@ 0x%x \"%s\", array subscript format 0x%x not handled yet"),
		 DIE_ID, DIE_NAME, format);
      nexttype = dwarf_fundamental_type (current_objfile, FT_INTEGER);
      rangetype = create_range_type ((struct type *) NULL, nexttype, 0, 0);
      typep = create_array_type ((struct type *) NULL, nexttype, rangetype);
      break;
    default:
      complaint (&symfile_complaints,
		 _("DIE @@ 0x%x \"%s\", unknown array subscript format %x"), DIE_ID,
		 DIE_NAME, format);
      nexttype = dwarf_fundamental_type (current_objfile, FT_INTEGER);
      rangetype = create_range_type ((struct type *) NULL, nexttype, 0, 0);
      typep = create_array_type ((struct type *) NULL, nexttype, rangetype);
      break;
    }
  return (typep);
}

/*

   LOCAL FUNCTION

   dwarf_read_array_type -- read TAG_array_type DIE

   SYNOPSIS

   static void dwarf_read_array_type (struct dieinfo *dip)

   DESCRIPTION

   Extract all information from a TAG_array_type DIE and add to
   the user defined type vector.
 */

static void
dwarf_read_array_type (struct dieinfo *dip)
{
  struct type *type;
  struct type *utype;
  char *sub;
  char *subend;
  unsigned short blocksz;
  int nbytes;

  if (dip->at_ordering != ORD_row_major)
    {
      /* FIXME:  Can gdb even handle column major arrays? */
      complaint (&symfile_complaints,
		 _("DIE @@ 0x%x \"%s\", array not row major; not handled correctly"),
		 DIE_ID, DIE_NAME);
    }
  sub = dip->at_subscr_data;
  if (sub != NULL)
    {
      nbytes = attribute_size (AT_subscr_data);
      blocksz = target_to_host (sub, nbytes, GET_UNSIGNED, current_objfile);
      subend = sub + nbytes + blocksz;
      sub += nbytes;
      type = decode_subscript_data_item (sub, subend);
      utype = lookup_utype (dip->die_ref);
      if (utype == NULL)
	{
	  /* Install user defined type that has not been referenced yet. */
	  alloc_utype (dip->die_ref, type);
	}
      else if (TYPE_CODE (utype) == TYPE_CODE_UNDEF)
	{
	  /* Ick!  A forward ref has already generated a blank type in our
	     slot, and this type probably already has things pointing to it
	     (which is what caused it to be created in the first place).
	     If it's just a place holder we can plop our fully defined type
	     on top of it.  We can't recover the space allocated for our
	     new type since it might be on an obstack, but we could reuse
	     it if we kept a list of them, but it might not be worth it
	     (FIXME). */
	  *utype = *type;
	}
      else
	{
	  /* Double ick!  Not only is a type already in our slot, but
	     someone has decorated it.  Complain and leave it alone. */
	  dup_user_type_definition_complaint (DIE_ID, DIE_NAME);
	}
    }
}

/*

   LOCAL FUNCTION

   read_tag_pointer_type -- read TAG_pointer_type DIE

   SYNOPSIS

   static void read_tag_pointer_type (struct dieinfo *dip)

   DESCRIPTION

   Extract all information from a TAG_pointer_type DIE and add to
   the user defined type vector.
 */

static void
read_tag_pointer_type (struct dieinfo *dip)
{
  struct type *type;
  struct type *utype;

  type = decode_die_type (dip);
  utype = lookup_utype (dip->die_ref);
  if (utype == NULL)
    {
      utype = lookup_pointer_type (type);
      alloc_utype (dip->die_ref, utype);
    }
  else
    {
      TYPE_TARGET_TYPE (utype) = type;
      TYPE_POINTER_TYPE (type) = utype;

      /* We assume the machine has only one representation for pointers!  */
      /* FIXME:  Possably a poor assumption  */
      TYPE_LENGTH (utype) = TARGET_PTR_BIT / TARGET_CHAR_BIT;
      TYPE_CODE (utype) = TYPE_CODE_PTR;
    }
}

/*

   LOCAL FUNCTION

   read_tag_string_type -- read TAG_string_type DIE

   SYNOPSIS

   static void read_tag_string_type (struct dieinfo *dip)

   DESCRIPTION

   Extract all information from a TAG_string_type DIE and add to
   the user defined type vector.  It isn't really a user defined
   type, but it behaves like one, with other DIE's using an
   AT_user_def_type attribute to reference it.
 */

static void
read_tag_string_type (struct dieinfo *dip)
{
  struct type *utype;
  struct type *indextype;
  struct type *rangetype;
  unsigned long lowbound = 0;
  unsigned long highbound;

  if (dip->has_at_byte_size)
    {
      /* A fixed bounds string */
      highbound = dip->at_byte_size - 1;
    }
  else
    {
      /* A varying length string.  Stub for now.  (FIXME) */
      highbound = 1;
    }
  indextype = dwarf_fundamental_type (current_objfile, FT_INTEGER);
  rangetype = create_range_type ((struct type *) NULL, indextype, lowbound,
				 highbound);

  utype = lookup_utype (dip->die_ref);
  if (utype == NULL)
    {
      /* No type defined, go ahead and create a blank one to use. */
      utype = alloc_utype (dip->die_ref, (struct type *) NULL);
    }
  else
    {
      /* Already a type in our slot due to a forward reference. Make sure it
         is a blank one.  If not, complain and leave it alone. */
      if (TYPE_CODE (utype) != TYPE_CODE_UNDEF)
	{
	  dup_user_type_definition_complaint (DIE_ID, DIE_NAME);
	  return;
	}
    }

  /* Create the string type using the blank type we either found or created. */
  utype = create_string_type (utype, rangetype);
}

/*

   LOCAL FUNCTION

   read_subroutine_type -- process TAG_subroutine_type dies

   SYNOPSIS

   static void read_subroutine_type (struct dieinfo *dip, char thisdie,
   char *enddie)

   DESCRIPTION

   Handle DIES due to C code like:

   struct foo {
   int (*funcp)(int a, long l);  (Generates TAG_subroutine_type DIE)
   int b;
   };

   NOTES

   The parameter DIES are currently ignored.  See if gdb has a way to
   include this info in it's type system, and decode them if so.  Is
   this what the type structure's "arg_types" field is for?  (FIXME)
 */

static void
read_subroutine_type (struct dieinfo *dip, char *thisdie, char *enddie)
{
  struct type *type;		/* Type that this function returns */
  struct type *ftype;		/* Function that returns above type */

  /* Decode the type that this subroutine returns */

  type = decode_die_type (dip);

  /* Check to see if we already have a partially constructed user
     defined type for this DIE, from a forward reference. */

  ftype = lookup_utype (dip->die_ref);
  if (ftype == NULL)
    {
      /* This is the first reference to one of these types.  Make
         a new one and place it in the user defined types. */
      ftype = lookup_function_type (type);
      alloc_utype (dip->die_ref, ftype);
    }
  else if (TYPE_CODE (ftype) == TYPE_CODE_UNDEF)
    {
      /* We have an existing partially constructed type, so bash it
         into the correct type. */
      TYPE_TARGET_TYPE (ftype) = type;
      TYPE_LENGTH (ftype) = 1;
      TYPE_CODE (ftype) = TYPE_CODE_FUNC;
    }
  else
    {
      dup_user_type_definition_complaint (DIE_ID, DIE_NAME);
    }
}

/*

   LOCAL FUNCTION

   read_enumeration -- process dies which define an enumeration

   SYNOPSIS

   static void read_enumeration (struct dieinfo *dip, char *thisdie,
   char *enddie, struct objfile *objfile)

   DESCRIPTION

   Given a pointer to a die which begins an enumeration, process all
   the dies that define the members of the enumeration.

   NOTES

   Note that we need to call enum_type regardless of whether or not we
   have a symbol, since we might have an enum without a tag name (thus
   no symbol for the tagname).
 */

static void
read_enumeration (struct dieinfo *dip, char *thisdie, char *enddie,
		  struct objfile *objfile)
{
  struct type *type;
  struct symbol *sym;

  type = enum_type (dip, objfile);
  sym = new_symbol (dip, objfile);
  if (sym != NULL)
    {
      SYMBOL_TYPE (sym) = type;
      if (cu_language == language_cplus)
	{
	  synthesize_typedef (dip, objfile, type);
	}
    }
}

/*

   LOCAL FUNCTION

   enum_type -- decode and return a type for an enumeration

   SYNOPSIS

   static type *enum_type (struct dieinfo *dip, struct objfile *objfile)

   DESCRIPTION

   Given a pointer to a die information structure for the die which
   starts an enumeration, process all the dies that define the members
   of the enumeration and return a type pointer for the enumeration.

   At the same time, for each member of the enumeration, create a
   symbol for it with domain VAR_DOMAIN and class LOC_CONST,
   and give it the type of the enumeration itself.

   NOTES

   Note that the DWARF specification explicitly mandates that enum
   constants occur in reverse order from the source program order,
   for "consistency" and because this ordering is easier for many
   compilers to generate. (Draft 6, sec 3.8.5, Enumeration type
   Entries).  Because gdb wants to see the enum members in program
   source order, we have to ensure that the order gets reversed while
   we are processing them.
 */

static struct type *
enum_type (struct dieinfo *dip, struct objfile *objfile)
{
  struct type *type;
  struct nextfield
    {
      struct nextfield *next;
      struct field field;
    };
  struct nextfield *list = NULL;
  struct nextfield *new;
  int nfields = 0;
  int n;
  char *scan;
  char *listend;
  unsigned short blocksz;
  struct symbol *sym;
  int nbytes;
  int unsigned_enum = 1;

  type = lookup_utype (dip->die_ref);
  if (type == NULL)
    {
      /* No forward references created an empty type, so install one now */
      type = alloc_utype (dip->die_ref, NULL);
    }
  TYPE_CODE (type) = TYPE_CODE_ENUM;
  /* Some compilers try to be helpful by inventing "fake" names for
     anonymous enums, structures, and unions, like "~0fake" or ".0fake".
     Thanks, but no thanks... */
  if (dip->at_name != NULL
      && *dip->at_name != '~'
      && *dip->at_name != '.')
    {
      TYPE_TAG_NAME (type) = obconcat (&objfile->objfile_obstack,
				       "", "", dip->at_name);
    }
  if (dip->at_byte_size != 0)
    {
      TYPE_LENGTH (type) = dip->at_byte_size;
    }
  scan = dip->at_element_list;
  if (scan != NULL)
    {
      if (dip->short_element_list)
	{
	  nbytes = attribute_size (AT_short_element_list);
	}
      else
	{
	  nbytes = attribute_size (AT_element_list);
	}
      blocksz = target_to_host (scan, nbytes, GET_UNSIGNED, objfile);
      listend = scan + nbytes + blocksz;
      scan += nbytes;
      while (scan < listend)
	{
	  new = (struct nextfield *) alloca (sizeof (struct nextfield));
	  new->next = list;
	  list = new;
	  FIELD_TYPE (list->field) = NULL;
	  FIELD_BITSIZE (list->field) = 0;
	  FIELD_STATIC_KIND (list->field) = 0;
	  FIELD_BITPOS (list->field) =
	    target_to_host (scan, TARGET_FT_LONG_SIZE (objfile), GET_SIGNED,
			    objfile);
	  scan += TARGET_FT_LONG_SIZE (objfile);
	  list->field.name = obsavestring (scan, strlen (scan),
					   &objfile->objfile_obstack);
	  scan += strlen (scan) + 1;
	  nfields++;
	  /* Handcraft a new symbol for this enum member. */
	  sym = (struct symbol *) obstack_alloc (&objfile->objfile_obstack,
						 sizeof (struct symbol));
	  memset (sym, 0, sizeof (struct symbol));
	  DEPRECATED_SYMBOL_NAME (sym) = create_name (list->field.name,
					   &objfile->objfile_obstack);
	  SYMBOL_INIT_LANGUAGE_SPECIFIC (sym, cu_language);
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
	  SYMBOL_CLASS (sym) = LOC_CONST;
	  SYMBOL_TYPE (sym) = type;
	  SYMBOL_VALUE (sym) = FIELD_BITPOS (list->field);
	  if (SYMBOL_VALUE (sym) < 0)
	    unsigned_enum = 0;
	  add_symbol_to_list (sym, list_in_scope);
	}
      /* Now create the vector of fields, and record how big it is. This is
         where we reverse the order, by pulling the members off the list in
         reverse order from how they were inserted.  If we have no fields
         (this is apparently possible in C++) then skip building a field
         vector. */
      if (nfields > 0)
	{
	  if (unsigned_enum)
	    TYPE_FLAGS (type) |= TYPE_FLAG_UNSIGNED;
	  TYPE_NFIELDS (type) = nfields;
	  TYPE_FIELDS (type) = (struct field *)
	    obstack_alloc (&objfile->objfile_obstack, sizeof (struct field) * nfields);
	  /* Copy the saved-up fields into the field vector.  */
	  for (n = 0; (n < nfields) && (list != NULL); list = list->next)
	    {
	      TYPE_FIELD (type, n++) = list->field;
	    }
	}
    }
  return (type);
}

/*

   LOCAL FUNCTION

   read_func_scope -- process all dies within a function scope

   DESCRIPTION

   Process all dies within a given function scope.  We are passed
   a die information structure pointer DIP for the die which
   starts the function scope, and pointers into the raw die data
   that define the dies within the function scope.

   For now, we ignore lexical block scopes within the function.
   The problem is that AT&T cc does not define a DWARF lexical
   block scope for the function itself, while gcc defines a
   lexical block scope for the function.  We need to think about
   how to handle this difference, or if it is even a problem.
   (FIXME)
 */

static void
read_func_scope (struct dieinfo *dip, char *thisdie, char *enddie,
		 struct objfile *objfile)
{
  struct context_stack *new;

  /* AT_name is absent if the function is described with an
     AT_abstract_origin tag.
     Ignore the function description for now to avoid GDB core dumps.
     FIXME: Add code to handle AT_abstract_origin tags properly.  */
  if (dip->at_name == NULL)
    {
      complaint (&symfile_complaints, _("DIE @@ 0x%x, AT_name tag missing"),
		 DIE_ID);
      return;
    }

  new = push_context (0, dip->at_low_pc);
  new->name = new_symbol (dip, objfile);
  list_in_scope = &local_symbols;
  process_dies (thisdie + dip->die_length, enddie, objfile);
  new = pop_context ();
  /* Make a block for the local symbols within.  */
  finish_block (new->name, &local_symbols, new->old_blocks,
		new->start_addr, dip->at_high_pc, objfile);
  list_in_scope = &file_symbols;
}


/*

   LOCAL FUNCTION

   handle_producer -- process the AT_producer attribute

   DESCRIPTION

   Perform any operations that depend on finding a particular
   AT_producer attribute.

 */

static void
handle_producer (char *producer)
{

  /* If this compilation unit was compiled with g++ or gcc, then set the
     processing_gcc_compilation flag. */

  if (DEPRECATED_STREQN (producer, GCC_PRODUCER, strlen (GCC_PRODUCER)))
    {
      char version = producer[strlen (GCC_PRODUCER)];
      processing_gcc_compilation = (version == '2' ? 2 : 1);
    }
  else
    {
      processing_gcc_compilation =
	strncmp (producer, GPLUS_PRODUCER, strlen (GPLUS_PRODUCER)) == 0;
    }

  /* Select a demangling style if we can identify the producer and if
     the current style is auto.  We leave the current style alone if it
     is not auto.  We also leave the demangling style alone if we find a
     gcc (cc1) producer, as opposed to a g++ (cc1plus) producer. */

  if (AUTO_DEMANGLING)
    {
      if (DEPRECATED_STREQN (producer, GPLUS_PRODUCER, strlen (GPLUS_PRODUCER)))
	{
#if 0
	  /* For now, stay with AUTO_DEMANGLING for g++ output, as we don't
	     know whether it will use the old style or v3 mangling.  */
	  set_demangling_style (GNU_DEMANGLING_STYLE_STRING);
#endif
	}
      else if (DEPRECATED_STREQN (producer, LCC_PRODUCER, strlen (LCC_PRODUCER)))
	{
	  set_demangling_style (LUCID_DEMANGLING_STYLE_STRING);
	}
    }
}


/*

   LOCAL FUNCTION

   read_file_scope -- process all dies within a file scope

   DESCRIPTION

   Process all dies within a given file scope.  We are passed a
   pointer to the die information structure for the die which
   starts the file scope, and pointers into the raw die data which
   mark the range of dies within the file scope.

   When the partial symbol table is built, the file offset for the line
   number table for each compilation unit is saved in the partial symbol
   table entry for that compilation unit.  As the symbols for each
   compilation unit are read, the line number table is read into memory
   and the variable lnbase is set to point to it.  Thus all we have to
   do is use lnbase to access the line number table for the current
   compilation unit.
 */

static void
read_file_scope (struct dieinfo *dip, char *thisdie, char *enddie,
		 struct objfile *objfile)
{
  struct cleanup *back_to;
  struct symtab *symtab;

  set_cu_language (dip);
  if (dip->at_producer != NULL)
    {
      handle_producer (dip->at_producer);
    }
  numutypes = (enddie - thisdie) / 4;
  utypes = (struct type **) xmalloc (numutypes * sizeof (struct type *));
  back_to = make_cleanup (free_utypes, NULL);
  memset (utypes, 0, numutypes * sizeof (struct type *));
  memset (ftypes, 0, FT_NUM_MEMBERS * sizeof (struct type *));
  start_symtab (dip->at_name, dip->at_comp_dir, dip->at_low_pc);
  record_debugformat ("DWARF 1");
  decode_line_numbers (lnbase);
  process_dies (thisdie + dip->die_length, enddie, objfile);

  symtab = end_symtab (dip->at_high_pc, objfile, 0);
  if (symtab != NULL)
    {
      symtab->language = cu_language;
    }
  do_cleanups (back_to);
}

/*

   LOCAL FUNCTION

   process_dies -- process a range of DWARF Information Entries

   SYNOPSIS

   static void process_dies (char *thisdie, char *enddie,
   struct objfile *objfile)

   DESCRIPTION

   Process all DIE's in a specified range.  May be (and almost
   certainly will be) called recursively.
 */

static void
process_dies (char *thisdie, char *enddie, struct objfile *objfile)
{
  char *nextdie;
  struct dieinfo di;

  while (thisdie < enddie)
    {
      basicdieinfo (&di, thisdie, objfile);
      if (di.die_length < SIZEOF_DIE_LENGTH)
	{
	  break;
	}
      else if (di.die_tag == TAG_padding)
	{
	  nextdie = thisdie + di.die_length;
	}
      else
	{
	  completedieinfo (&di, objfile);
	  if (di.at_sibling != 0)
	    {
	      nextdie = dbbase + di.at_sibling - dbroff;
	    }
	  else
	    {
	      nextdie = thisdie + di.die_length;
	    }
	  /* I think that these are always text, not data, addresses.  */
	  di.at_low_pc = SMASH_TEXT_ADDRESS (di.at_low_pc);
	  di.at_high_pc = SMASH_TEXT_ADDRESS (di.at_high_pc);
	  switch (di.die_tag)
	    {
	    case TAG_compile_unit:
	      /* Skip Tag_compile_unit if we are already inside a compilation
	         unit, we are unable to handle nested compilation units
	         properly (FIXME).  */
	      if (current_subfile == NULL)
		read_file_scope (&di, thisdie, nextdie, objfile);
	      else
		nextdie = thisdie + di.die_length;
	      break;
	    case TAG_global_subroutine:
	    case TAG_subroutine:
	      if (di.has_at_low_pc)
		{
		  read_func_scope (&di, thisdie, nextdie, objfile);
		}
	      break;
	    case TAG_lexical_block:
	      read_lexical_block_scope (&di, thisdie, nextdie, objfile);
	      break;
	    case TAG_class_type:
	    case TAG_structure_type:
	    case TAG_union_type:
	      read_structure_scope (&di, thisdie, nextdie, objfile);
	      break;
	    case TAG_enumeration_type:
	      read_enumeration (&di, thisdie, nextdie, objfile);
	      break;
	    case TAG_subroutine_type:
	      read_subroutine_type (&di, thisdie, nextdie);
	      break;
	    case TAG_array_type:
	      dwarf_read_array_type (&di);
	      break;
	    case TAG_pointer_type:
	      read_tag_pointer_type (&di);
	      break;
	    case TAG_string_type:
	      read_tag_string_type (&di);
	      break;
	    default:
	      new_symbol (&di, objfile);
	      break;
	    }
	}
      thisdie = nextdie;
    }
}

/*

   LOCAL FUNCTION

   decode_line_numbers -- decode a line number table fragment

   SYNOPSIS

   static void decode_line_numbers (char *tblscan, char *tblend,
   long length, long base, long line, long pc)

   DESCRIPTION

   Translate the DWARF line number information to gdb form.

   The ".line" section contains one or more line number tables, one for
   each ".line" section from the objects that were linked.

   The AT_stmt_list attribute for each TAG_source_file entry in the
   ".debug" section contains the offset into the ".line" section for the
   start of the table for that file.

   The table itself has the following structure:

   <table length><base address><source statement entry>
   4 bytes       4 bytes       10 bytes

   The table length is the total size of the table, including the 4 bytes
   for the length information.

   The base address is the address of the first instruction generated
   for the source file.

   Each source statement entry has the following structure:

   <line number><statement position><address delta>
   4 bytes      2 bytes             4 bytes

   The line number is relative to the start of the file, starting with
   line 1.

   The statement position either -1 (0xFFFF) or the number of characters
   from the beginning of the line to the beginning of the statement.

   The address delta is the difference between the base address and
   the address of the first instruction for the statement.

   Note that we must copy the bytes from the packed table to our local
   variables before attempting to use them, to avoid alignment problems
   on some machines, particularly RISC processors.

   BUGS

   Does gdb expect the line numbers to be sorted?  They are now by
   chance/luck, but are not required to be.  (FIXME)

   The line with number 0 is unused, gdb apparently can discover the
   span of the last line some other way. How?  (FIXME)
 */

static void
decode_line_numbers (char *linetable)
{
  char *tblscan;
  char *tblend;
  unsigned long length;
  unsigned long base;
  unsigned long line;
  unsigned long pc;

  if (linetable != NULL)
    {
      tblscan = tblend = linetable;
      length = target_to_host (tblscan, SIZEOF_LINETBL_LENGTH, GET_UNSIGNED,
			       current_objfile);
      tblscan += SIZEOF_LINETBL_LENGTH;
      tblend += length;
      base = target_to_host (tblscan, TARGET_FT_POINTER_SIZE (objfile),
			     GET_UNSIGNED, current_objfile);
      tblscan += TARGET_FT_POINTER_SIZE (objfile);
      base += baseaddr;
      while (tblscan < tblend)
	{
	  line = target_to_host (tblscan, SIZEOF_LINETBL_LINENO, GET_UNSIGNED,
				 current_objfile);
	  tblscan += SIZEOF_LINETBL_LINENO + SIZEOF_LINETBL_STMT;
	  pc = target_to_host (tblscan, SIZEOF_LINETBL_DELTA, GET_UNSIGNED,
			       current_objfile);
	  tblscan += SIZEOF_LINETBL_DELTA;
	  pc += base;
	  if (line != 0)
	    {
	      record_line (current_subfile, line, pc);
	    }
	}
    }
}

/*

   LOCAL FUNCTION

   locval -- compute the value of a location attribute

   SYNOPSIS

   static int locval (struct dieinfo *dip)

   DESCRIPTION

   Given pointer to a string of bytes that define a location, compute
   the location and return the value.
   A location description containing no atoms indicates that the
   object is optimized out. The optimized_out flag is set for those,
   the return value is meaningless.

   When computing values involving the current value of the frame pointer,
   the value zero is used, which results in a value relative to the frame
   pointer, rather than the absolute value.  This is what GDB wants
   anyway.

   When the result is a register number, the isreg flag is set, otherwise
   it is cleared.  This is a kludge until we figure out a better
   way to handle the problem.  Gdb's design does not mesh well with the
   DWARF notion of a location computing interpreter, which is a shame
   because the flexibility goes unused.

   NOTES

   Note that stack[0] is unused except as a default error return.
   Note that stack overflow is not yet handled.
 */

static int
locval (struct dieinfo *dip)
{
  unsigned short nbytes;
  unsigned short locsize;
  auto long stack[64];
  int stacki;
  char *loc;
  char *end;
  int loc_atom_code;
  int loc_value_size;

  loc = dip->at_location;
  nbytes = attribute_size (AT_location);
  locsize = target_to_host (loc, nbytes, GET_UNSIGNED, current_objfile);
  loc += nbytes;
  end = loc + locsize;
  stacki = 0;
  stack[stacki] = 0;
  dip->isreg = 0;
  dip->offreg = 0;
  dip->optimized_out = 1;
  loc_value_size = TARGET_FT_LONG_SIZE (current_objfile);
  while (loc < end)
    {
      dip->optimized_out = 0;
      loc_atom_code = target_to_host (loc, SIZEOF_LOC_ATOM_CODE, GET_UNSIGNED,
				      current_objfile);
      loc += SIZEOF_LOC_ATOM_CODE;
      switch (loc_atom_code)
	{
	case 0:
	  /* error */
	  loc = end;
	  break;
	case OP_REG:
	  /* push register (number) */
	  stack[++stacki]
	    = DWARF_REG_TO_REGNUM (target_to_host (loc, loc_value_size,
						   GET_UNSIGNED,
						   current_objfile));
	  loc += loc_value_size;
	  dip->isreg = 1;
	  break;
	case OP_BASEREG:
	  /* push value of register (number) */
	  /* Actually, we compute the value as if register has 0, so the
	     value ends up being the offset from that register.  */
	  dip->offreg = 1;
	  dip->basereg = target_to_host (loc, loc_value_size, GET_UNSIGNED,
					 current_objfile);
	  loc += loc_value_size;
	  stack[++stacki] = 0;
	  break;
	case OP_ADDR:
	  /* push address (relocated address) */
	  stack[++stacki] = target_to_host (loc, loc_value_size,
					    GET_UNSIGNED, current_objfile);
	  loc += loc_value_size;
	  break;
	case OP_CONST:
	  /* push constant (number)   FIXME: signed or unsigned! */
	  stack[++stacki] = target_to_host (loc, loc_value_size,
					    GET_SIGNED, current_objfile);
	  loc += loc_value_size;
	  break;
	case OP_DEREF2:
	  /* pop, deref and push 2 bytes (as a long) */
	  complaint (&symfile_complaints,
		     _("DIE @@ 0x%x \"%s\", OP_DEREF2 address 0x%lx not handled"),
		     DIE_ID, DIE_NAME, stack[stacki]);
	  break;
	case OP_DEREF4:	/* pop, deref and push 4 bytes (as a long) */
	  complaint (&symfile_complaints,
		     _("DIE @@ 0x%x \"%s\", OP_DEREF4 address 0x%lx not handled"),
		     DIE_ID, DIE_NAME, stack[stacki]);
	  break;
	case OP_ADD:		/* pop top 2 items, add, push result */
	  stack[stacki - 1] += stack[stacki];
	  stacki--;
	  break;
	}
    }
  return (stack[stacki]);
}

/*

   LOCAL FUNCTION

   read_ofile_symtab -- build a full symtab entry from chunk of DIE's

   SYNOPSIS

   static void read_ofile_symtab (struct partial_symtab *pst)

   DESCRIPTION

   When expanding a partial symbol table entry to a full symbol table
   entry, this is the function that gets called to read in the symbols
   for the compilation unit.  A pointer to the newly constructed symtab,
   which is now the new first one on the objfile's symtab list, is
   stashed in the partial symbol table entry.
 */

static void
read_ofile_symtab (struct partial_symtab *pst)
{
  struct cleanup *back_to;
  unsigned long lnsize;
  file_ptr foffset;
  bfd *abfd;
  char lnsizedata[SIZEOF_LINETBL_LENGTH];

  abfd = pst->objfile->obfd;
  current_objfile = pst->objfile;

  /* Allocate a buffer for the entire chunk of DIE's for this compilation
     unit, seek to the location in the file, and read in all the DIE's. */

  diecount = 0;
  dbsize = DBLENGTH (pst);
  dbbase = xmalloc (dbsize);
  dbroff = DBROFF (pst);
  foffset = DBFOFF (pst) + dbroff;
  base_section_offsets = pst->section_offsets;
  baseaddr = ANOFFSET (pst->section_offsets, 0);
  if (bfd_seek (abfd, foffset, SEEK_SET) ||
      (bfd_bread (dbbase, dbsize, abfd) != dbsize))
    {
      xfree (dbbase);
      error (_("can't read DWARF data"));
    }
  back_to = make_cleanup (xfree, dbbase);

  /* If there is a line number table associated with this compilation unit
     then read the size of this fragment in bytes, from the fragment itself.
     Allocate a buffer for the fragment and read it in for future 
     processing. */

  lnbase = NULL;
  if (LNFOFF (pst))
    {
      if (bfd_seek (abfd, LNFOFF (pst), SEEK_SET) ||
	  (bfd_bread (lnsizedata, sizeof (lnsizedata), abfd)
	   != sizeof (lnsizedata)))
	{
	  error (_("can't read DWARF line number table size"));
	}
      lnsize = target_to_host (lnsizedata, SIZEOF_LINETBL_LENGTH,
			       GET_UNSIGNED, pst->objfile);
      lnbase = xmalloc (lnsize);
      if (bfd_seek (abfd, LNFOFF (pst), SEEK_SET) ||
	  (bfd_bread (lnbase, lnsize, abfd) != lnsize))
	{
	  xfree (lnbase);
	  error (_("can't read DWARF line numbers"));
	}
      make_cleanup (xfree, lnbase);
    }

  process_dies (dbbase, dbbase + dbsize, pst->objfile);
  do_cleanups (back_to);
  current_objfile = NULL;
  pst->symtab = pst->objfile->symtabs;
}

/*

   LOCAL FUNCTION

   psymtab_to_symtab_1 -- do grunt work for building a full symtab entry

   SYNOPSIS

   static void psymtab_to_symtab_1 (struct partial_symtab *pst)

   DESCRIPTION

   Called once for each partial symbol table entry that needs to be
   expanded into a full symbol table entry.

 */

static void
psymtab_to_symtab_1 (struct partial_symtab *pst)
{
  int i;
  struct cleanup *old_chain;

  if (pst != NULL)
    {
      if (pst->readin)
	{
	  warning (_("psymtab for %s already read in.  Shouldn't happen."),
		   pst->filename);
	}
      else
	{
	  /* Read in all partial symtabs on which this one is dependent */
	  for (i = 0; i < pst->number_of_dependencies; i++)
	    {
	      if (!pst->dependencies[i]->readin)
		{
		  /* Inform about additional files that need to be read in. */
		  if (info_verbose)
		    {
		      /* FIXME: i18n: Need to make this a single
			 string.  */
		      fputs_filtered (" ", gdb_stdout);
		      wrap_here ("");
		      fputs_filtered ("and ", gdb_stdout);
		      wrap_here ("");
		      printf_filtered ("%s...",
				       pst->dependencies[i]->filename);
		      wrap_here ("");
		      gdb_flush (gdb_stdout);	/* Flush output */
		    }
		  psymtab_to_symtab_1 (pst->dependencies[i]);
		}
	    }
	  if (DBLENGTH (pst))	/* Otherwise it's a dummy */
	    {
	      buildsym_init ();
	      old_chain = make_cleanup (really_free_pendings, 0);
	      read_ofile_symtab (pst);
	      if (info_verbose)
		{
		  printf_filtered (_("%d DIE's, sorting..."), diecount);
		  wrap_here ("");
		  gdb_flush (gdb_stdout);
		}
	      do_cleanups (old_chain);
	    }
	  pst->readin = 1;
	}
    }
}

/*

   LOCAL FUNCTION

   dwarf_psymtab_to_symtab -- build a full symtab entry from partial one

   SYNOPSIS

   static void dwarf_psymtab_to_symtab (struct partial_symtab *pst)

   DESCRIPTION

   This is the DWARF support entry point for building a full symbol
   table entry from a partial symbol table entry.  We are passed a
   pointer to the partial symbol table entry that needs to be expanded.

 */

static void
dwarf_psymtab_to_symtab (struct partial_symtab *pst)
{

  if (pst != NULL)
    {
      if (pst->readin)
	{
	  warning (_("psymtab for %s already read in.  Shouldn't happen."),
		   pst->filename);
	}
      else
	{
	  if (DBLENGTH (pst) || pst->number_of_dependencies)
	    {
	      /* Print the message now, before starting serious work, to avoid
	         disconcerting pauses.  */
	      if (info_verbose)
		{
		  printf_filtered (_("Reading in symbols for %s..."),
				   pst->filename);
		  gdb_flush (gdb_stdout);
		}

	      psymtab_to_symtab_1 (pst);

#if 0				/* FIXME:  Check to see what dbxread is doing here and see if
				   we need to do an equivalent or is this something peculiar to
				   stabs/a.out format.
				   Match with global symbols.  This only needs to be done once,
				   after all of the symtabs and dependencies have been read in.
				 */
	      scan_file_globals (pst->objfile);
#endif

	      /* Finish up the verbose info message.  */
	      if (info_verbose)
		{
		  printf_filtered (_("done.\n"));
		  gdb_flush (gdb_stdout);
		}
	    }
	}
    }
}

/*

   LOCAL FUNCTION

   add_enum_psymbol -- add enumeration members to partial symbol table

   DESCRIPTION

   Given pointer to a DIE that is known to be for an enumeration,
   extract the symbolic names of the enumeration members and add
   partial symbols for them.
 */

static void
add_enum_psymbol (struct dieinfo *dip, struct objfile *objfile)
{
  char *scan;
  char *listend;
  unsigned short blocksz;
  int nbytes;

  scan = dip->at_element_list;
  if (scan != NULL)
    {
      if (dip->short_element_list)
	{
	  nbytes = attribute_size (AT_short_element_list);
	}
      else
	{
	  nbytes = attribute_size (AT_element_list);
	}
      blocksz = target_to_host (scan, nbytes, GET_UNSIGNED, objfile);
      scan += nbytes;
      listend = scan + blocksz;
      while (scan < listend)
	{
	  scan += TARGET_FT_LONG_SIZE (objfile);
	  add_psymbol_to_list (scan, strlen (scan), VAR_DOMAIN, LOC_CONST,
			       &objfile->static_psymbols, 0, 0, cu_language,
			       objfile);
	  scan += strlen (scan) + 1;
	}
    }
}

/*

   LOCAL FUNCTION

   add_partial_symbol -- add symbol to partial symbol table

   DESCRIPTION

   Given a DIE, if it is one of the types that we want to
   add to a partial symbol table, finish filling in the die info
   and then add a partial symbol table entry for it.

   NOTES

   The caller must ensure that the DIE has a valid name attribute.
 */

static void
add_partial_symbol (struct dieinfo *dip, struct objfile *objfile)
{
  switch (dip->die_tag)
    {
    case TAG_global_subroutine:
      add_psymbol_to_list (dip->at_name, strlen (dip->at_name),
			   VAR_DOMAIN, LOC_BLOCK,
			   &objfile->global_psymbols,
			   0, dip->at_low_pc, cu_language, objfile);
      break;
    case TAG_global_variable:
      add_psymbol_to_list (dip->at_name, strlen (dip->at_name),
			   VAR_DOMAIN, LOC_STATIC,
			   &objfile->global_psymbols,
			   0, 0, cu_language, objfile);
      break;
    case TAG_subroutine:
      add_psymbol_to_list (dip->at_name, strlen (dip->at_name),
			   VAR_DOMAIN, LOC_BLOCK,
			   &objfile->static_psymbols,
			   0, dip->at_low_pc, cu_language, objfile);
      break;
    case TAG_local_variable:
      add_psymbol_to_list (dip->at_name, strlen (dip->at_name),
			   VAR_DOMAIN, LOC_STATIC,
			   &objfile->static_psymbols,
			   0, 0, cu_language, objfile);
      break;
    case TAG_typedef:
      add_psymbol_to_list (dip->at_name, strlen (dip->at_name),
			   VAR_DOMAIN, LOC_TYPEDEF,
			   &objfile->static_psymbols,
			   0, 0, cu_language, objfile);
      break;
    case TAG_class_type:
    case TAG_structure_type:
    case TAG_union_type:
    case TAG_enumeration_type:
      /* Do not add opaque aggregate definitions to the psymtab.  */
      if (!dip->has_at_byte_size)
	break;
      add_psymbol_to_list (dip->at_name, strlen (dip->at_name),
			   STRUCT_DOMAIN, LOC_TYPEDEF,
			   &objfile->static_psymbols,
			   0, 0, cu_language, objfile);
      if (cu_language == language_cplus)
	{
	  /* For C++, these implicitly act as typedefs as well. */
	  add_psymbol_to_list (dip->at_name, strlen (dip->at_name),
			       VAR_DOMAIN, LOC_TYPEDEF,
			       &objfile->static_psymbols,
			       0, 0, cu_language, objfile);
	}
      break;
    }
}
/* *INDENT-OFF* */
/*

LOCAL FUNCTION

	scan_partial_symbols -- scan DIE's within a single compilation unit

DESCRIPTION

	Process the DIE's within a single compilation unit, looking for
	interesting DIE's that contribute to the partial symbol table entry
	for this compilation unit.

NOTES

	There are some DIE's that may appear both at file scope and within
	the scope of a function.  We are only interested in the ones at file
	scope, and the only way to tell them apart is to keep track of the
	scope.  For example, consider the test case:

		static int i;
		main () { int j; }

	for which the relevant DWARF segment has the structure:
	
		0x51:
		0x23   global subrtn   sibling     0x9b
		                       name        main
		                       fund_type   FT_integer
		                       low_pc      0x800004cc
		                       high_pc     0x800004d4
		                            
		0x74:
		0x23   local var       sibling     0x97
		                       name        j
		                       fund_type   FT_integer
		                       location    OP_BASEREG 0xe
		                                   OP_CONST 0xfffffffc
		                                   OP_ADD
		0x97:
		0x4         
		
		0x9b:
		0x1d   local var       sibling     0xb8
		                       name        i
		                       fund_type   FT_integer
		                       location    OP_ADDR 0x800025dc
		                            
		0xb8:
		0x4         

	We want to include the symbol 'i' in the partial symbol table, but
	not the symbol 'j'.  In essence, we want to skip all the dies within
	the scope of a TAG_global_subroutine DIE.

	Don't attempt to add anonymous structures or unions since they have
	no name.  Anonymous enumerations however are processed, because we
	want to extract their member names (the check for a tag name is
	done later).

	Also, for variables and subroutines, check that this is the place
	where the actual definition occurs, rather than just a reference
	to an external.
 */
/* *INDENT-ON* */



static void
scan_partial_symbols (char *thisdie, char *enddie, struct objfile *objfile)
{
  char *nextdie;
  char *temp;
  struct dieinfo di;

  while (thisdie < enddie)
    {
      basicdieinfo (&di, thisdie, objfile);
      if (di.die_length < SIZEOF_DIE_LENGTH)
	{
	  break;
	}
      else
	{
	  nextdie = thisdie + di.die_length;
	  /* To avoid getting complete die information for every die, we
	     only do it (below) for the cases we are interested in. */
	  switch (di.die_tag)
	    {
	    case TAG_global_subroutine:
	    case TAG_subroutine:
	      completedieinfo (&di, objfile);
	      if (di.at_name && (di.has_at_low_pc || di.at_location))
		{
		  add_partial_symbol (&di, objfile);
		  /* If there is a sibling attribute, adjust the nextdie
		     pointer to skip the entire scope of the subroutine.
		     Apply some sanity checking to make sure we don't 
		     overrun or underrun the range of remaining DIE's */
		  if (di.at_sibling != 0)
		    {
		      temp = dbbase + di.at_sibling - dbroff;
		      if ((temp < thisdie) || (temp >= enddie))
			{
			  bad_die_ref_complaint (DIE_ID, DIE_NAME,
						 di.at_sibling);
			}
		      else
			{
			  nextdie = temp;
			}
		    }
		}
	      break;
	    case TAG_global_variable:
	    case TAG_local_variable:
	      completedieinfo (&di, objfile);
	      if (di.at_name && (di.has_at_low_pc || di.at_location))
		{
		  add_partial_symbol (&di, objfile);
		}
	      break;
	    case TAG_typedef:
	    case TAG_class_type:
	    case TAG_structure_type:
	    case TAG_union_type:
	      completedieinfo (&di, objfile);
	      if (di.at_name)
		{
		  add_partial_symbol (&di, objfile);
		}
	      break;
	    case TAG_enumeration_type:
	      completedieinfo (&di, objfile);
	      if (di.at_name)
		{
		  add_partial_symbol (&di, objfile);
		}
	      add_enum_psymbol (&di, objfile);
	      break;
	    }
	}
      thisdie = nextdie;
    }
}

/*

   LOCAL FUNCTION

   scan_compilation_units -- build a psymtab entry for each compilation

   DESCRIPTION

   This is the top level dwarf parsing routine for building partial
   symbol tables.

   It scans from the beginning of the DWARF table looking for the first
   TAG_compile_unit DIE, and then follows the sibling chain to locate
   each additional TAG_compile_unit DIE.

   For each TAG_compile_unit DIE it creates a partial symtab structure,
   calls a subordinate routine to collect all the compilation unit's
   global DIE's, file scope DIEs, typedef DIEs, etc, and then links the
   new partial symtab structure into the partial symbol table.  It also
   records the appropriate information in the partial symbol table entry
   to allow the chunk of DIE's and line number table for this compilation
   unit to be located and re-read later, to generate a complete symbol
   table entry for the compilation unit.

   Thus it effectively partitions up a chunk of DIE's for multiple
   compilation units into smaller DIE chunks and line number tables,
   and associates them with a partial symbol table entry.

   NOTES

   If any compilation unit has no line number table associated with
   it for some reason (a missing at_stmt_list attribute, rather than
   just one with a value of zero, which is valid) then we ensure that
   the recorded file offset is zero so that the routine which later
   reads line number table fragments knows that there is no fragment
   to read.

   RETURNS

   Returns no value.

 */

static void
scan_compilation_units (char *thisdie, char *enddie, file_ptr dbfoff,
			file_ptr lnoffset, struct objfile *objfile)
{
  char *nextdie;
  struct dieinfo di;
  struct partial_symtab *pst;
  int culength;
  int curoff;
  file_ptr curlnoffset;

  while (thisdie < enddie)
    {
      basicdieinfo (&di, thisdie, objfile);
      if (di.die_length < SIZEOF_DIE_LENGTH)
	{
	  break;
	}
      else if (di.die_tag != TAG_compile_unit)
	{
	  nextdie = thisdie + di.die_length;
	}
      else
	{
	  completedieinfo (&di, objfile);
	  set_cu_language (&di);
	  if (di.at_sibling != 0)
	    {
	      nextdie = dbbase + di.at_sibling - dbroff;
	    }
	  else
	    {
	      nextdie = thisdie + di.die_length;
	    }
	  curoff = thisdie - dbbase;
	  culength = nextdie - thisdie;
	  curlnoffset = di.has_at_stmt_list ? lnoffset + di.at_stmt_list : 0;

	  /* First allocate a new partial symbol table structure */

	  pst = start_psymtab_common (objfile, base_section_offsets,
				      di.at_name, di.at_low_pc,
				      objfile->global_psymbols.next,
				      objfile->static_psymbols.next);

	  pst->texthigh = di.at_high_pc;
	  pst->read_symtab_private = (char *)
	    obstack_alloc (&objfile->objfile_obstack,
			   sizeof (struct dwfinfo));
	  DBFOFF (pst) = dbfoff;
	  DBROFF (pst) = curoff;
	  DBLENGTH (pst) = culength;
	  LNFOFF (pst) = curlnoffset;
	  pst->read_symtab = dwarf_psymtab_to_symtab;

	  /* Now look for partial symbols */

	  scan_partial_symbols (thisdie + di.die_length, nextdie, objfile);

	  pst->n_global_syms = objfile->global_psymbols.next -
	    (objfile->global_psymbols.list + pst->globals_offset);
	  pst->n_static_syms = objfile->static_psymbols.next -
	    (objfile->static_psymbols.list + pst->statics_offset);
	  sort_pst_symbols (pst);
	  /* If there is already a psymtab or symtab for a file of this name,
	     remove it. (If there is a symtab, more drastic things also
	     happen.)  This happens in VxWorks.  */
	  free_named_symtabs (pst->filename);
	}
      thisdie = nextdie;
    }
}

/*

   LOCAL FUNCTION

   new_symbol -- make a symbol table entry for a new symbol

   SYNOPSIS

   static struct symbol *new_symbol (struct dieinfo *dip,
   struct objfile *objfile)

   DESCRIPTION

   Given a pointer to a DWARF information entry, figure out if we need
   to make a symbol table entry for it, and if so, create a new entry
   and return a pointer to it.
 */

static struct symbol *
new_symbol (struct dieinfo *dip, struct objfile *objfile)
{
  struct symbol *sym = NULL;

  if (dip->at_name != NULL)
    {
      sym = (struct symbol *) obstack_alloc (&objfile->objfile_obstack,
					     sizeof (struct symbol));
      OBJSTAT (objfile, n_syms++);
      memset (sym, 0, sizeof (struct symbol));
      /* default assumptions */
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      SYMBOL_CLASS (sym) = LOC_STATIC;
      SYMBOL_TYPE (sym) = decode_die_type (dip);

      /* If this symbol is from a C++ compilation, then attempt to cache the
         demangled form for future reference.  This is a typical time versus
         space tradeoff, that was decided in favor of time because it sped up
         C++ symbol lookups by a factor of about 20. */

      SYMBOL_LANGUAGE (sym) = cu_language;
      SYMBOL_SET_NAMES (sym, dip->at_name, strlen (dip->at_name), objfile);
      switch (dip->die_tag)
	{
	case TAG_label:
	  SYMBOL_VALUE_ADDRESS (sym) = dip->at_low_pc;
	  SYMBOL_CLASS (sym) = LOC_LABEL;
	  break;
	case TAG_global_subroutine:
	case TAG_subroutine:
	  SYMBOL_VALUE_ADDRESS (sym) = dip->at_low_pc;
	  SYMBOL_TYPE (sym) = lookup_function_type (SYMBOL_TYPE (sym));
	  if (dip->at_prototyped)
	    TYPE_FLAGS (SYMBOL_TYPE (sym)) |= TYPE_FLAG_PROTOTYPED;
	  SYMBOL_CLASS (sym) = LOC_BLOCK;
	  if (dip->die_tag == TAG_global_subroutine)
	    {
	      add_symbol_to_list (sym, &global_symbols);
	    }
	  else
	    {
	      add_symbol_to_list (sym, list_in_scope);
	    }
	  break;
	case TAG_global_variable:
	  if (dip->at_location != NULL)
	    {
	      SYMBOL_VALUE_ADDRESS (sym) = locval (dip);
	      add_symbol_to_list (sym, &global_symbols);
	      SYMBOL_CLASS (sym) = LOC_STATIC;
	      SYMBOL_VALUE (sym) += baseaddr;
	    }
	  break;
	case TAG_local_variable:
	  if (dip->at_location != NULL)
	    {
	      int loc = locval (dip);
	      if (dip->optimized_out)
		{
		  SYMBOL_CLASS (sym) = LOC_OPTIMIZED_OUT;
		}
	      else if (dip->isreg)
		{
		  SYMBOL_CLASS (sym) = LOC_REGISTER;
		}
	      else if (dip->offreg)
		{
		  SYMBOL_CLASS (sym) = LOC_BASEREG;
		  SYMBOL_BASEREG (sym) = dip->basereg;
		}
	      else
		{
		  SYMBOL_CLASS (sym) = LOC_STATIC;
		  SYMBOL_VALUE (sym) += baseaddr;
		}
	      if (SYMBOL_CLASS (sym) == LOC_STATIC)
		{
		  /* LOC_STATIC address class MUST use SYMBOL_VALUE_ADDRESS,
		     which may store to a bigger location than SYMBOL_VALUE. */
		  SYMBOL_VALUE_ADDRESS (sym) = loc;
		}
	      else
		{
		  SYMBOL_VALUE (sym) = loc;
		}
	      add_symbol_to_list (sym, list_in_scope);
	    }
	  break;
	case TAG_formal_parameter:
	  if (dip->at_location != NULL)
	    {
	      SYMBOL_VALUE (sym) = locval (dip);
	    }
	  add_symbol_to_list (sym, list_in_scope);
	  if (dip->isreg)
	    {
	      SYMBOL_CLASS (sym) = LOC_REGPARM;
	    }
	  else if (dip->offreg)
	    {
	      SYMBOL_CLASS (sym) = LOC_BASEREG_ARG;
	      SYMBOL_BASEREG (sym) = dip->basereg;
	    }
	  else
	    {
	      SYMBOL_CLASS (sym) = LOC_ARG;
	    }
	  break;
	case TAG_unspecified_parameters:
	  /* From varargs functions; gdb doesn't seem to have any interest in
	     this information, so just ignore it for now. (FIXME?) */
	  break;
	case TAG_class_type:
	case TAG_structure_type:
	case TAG_union_type:
	case TAG_enumeration_type:
	  SYMBOL_CLASS (sym) = LOC_TYPEDEF;
	  SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;
	  add_symbol_to_list (sym, list_in_scope);
	  break;
	case TAG_typedef:
	  SYMBOL_CLASS (sym) = LOC_TYPEDEF;
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
	  add_symbol_to_list (sym, list_in_scope);
	  break;
	default:
	  /* Not a tag we recognize.  Hopefully we aren't processing trash
	     data, but since we must specifically ignore things we don't
	     recognize, there is nothing else we should do at this point. */
	  break;
	}
    }
  return (sym);
}

/*

   LOCAL FUNCTION

   synthesize_typedef -- make a symbol table entry for a "fake" typedef

   SYNOPSIS

   static void synthesize_typedef (struct dieinfo *dip,
   struct objfile *objfile,
   struct type *type);

   DESCRIPTION

   Given a pointer to a DWARF information entry, synthesize a typedef
   for the name in the DIE, using the specified type.

   This is used for C++ class, structs, unions, and enumerations to
   set up the tag name as a type.

 */

static void
synthesize_typedef (struct dieinfo *dip, struct objfile *objfile,
		    struct type *type)
{
  struct symbol *sym = NULL;

  if (dip->at_name != NULL)
    {
      sym = (struct symbol *)
	obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol));
      OBJSTAT (objfile, n_syms++);
      memset (sym, 0, sizeof (struct symbol));
      DEPRECATED_SYMBOL_NAME (sym) = create_name (dip->at_name,
				       &objfile->objfile_obstack);
      SYMBOL_INIT_LANGUAGE_SPECIFIC (sym, cu_language);
      SYMBOL_TYPE (sym) = type;
      SYMBOL_CLASS (sym) = LOC_TYPEDEF;
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      add_symbol_to_list (sym, list_in_scope);
    }
}

/*

   LOCAL FUNCTION

   decode_mod_fund_type -- decode a modified fundamental type

   SYNOPSIS

   static struct type *decode_mod_fund_type (char *typedata)

   DESCRIPTION

   Decode a block of data containing a modified fundamental
   type specification.  TYPEDATA is a pointer to the block,
   which starts with a length containing the size of the rest
   of the block.  At the end of the block is a fundmental type
   code value that gives the fundamental type.  Everything
   in between are type modifiers.

   We simply compute the number of modifiers and call the general
   function decode_modified_type to do the actual work.
 */

static struct type *
decode_mod_fund_type (char *typedata)
{
  struct type *typep = NULL;
  unsigned short modcount;
  int nbytes;

  /* Get the total size of the block, exclusive of the size itself */

  nbytes = attribute_size (AT_mod_fund_type);
  modcount = target_to_host (typedata, nbytes, GET_UNSIGNED, current_objfile);
  typedata += nbytes;

  /* Deduct the size of the fundamental type bytes at the end of the block. */

  modcount -= attribute_size (AT_fund_type);

  /* Now do the actual decoding */

  typep = decode_modified_type (typedata, modcount, AT_mod_fund_type);
  return (typep);
}

/*

   LOCAL FUNCTION

   decode_mod_u_d_type -- decode a modified user defined type

   SYNOPSIS

   static struct type *decode_mod_u_d_type (char *typedata)

   DESCRIPTION

   Decode a block of data containing a modified user defined
   type specification.  TYPEDATA is a pointer to the block,
   which consists of a two byte length, containing the size
   of the rest of the block.  At the end of the block is a
   four byte value that gives a reference to a user defined type.
   Everything in between are type modifiers.

   We simply compute the number of modifiers and call the general
   function decode_modified_type to do the actual work.
 */

static struct type *
decode_mod_u_d_type (char *typedata)
{
  struct type *typep = NULL;
  unsigned short modcount;
  int nbytes;

  /* Get the total size of the block, exclusive of the size itself */

  nbytes = attribute_size (AT_mod_u_d_type);
  modcount = target_to_host (typedata, nbytes, GET_UNSIGNED, current_objfile);
  typedata += nbytes;

  /* Deduct the size of the reference type bytes at the end of the block. */

  modcount -= attribute_size (AT_user_def_type);

  /* Now do the actual decoding */

  typep = decode_modified_type (typedata, modcount, AT_mod_u_d_type);
  return (typep);
}

/*

   LOCAL FUNCTION

   decode_modified_type -- decode modified user or fundamental type

   SYNOPSIS

   static struct type *decode_modified_type (char *modifiers,
   unsigned short modcount, int mtype)

   DESCRIPTION

   Decode a modified type, either a modified fundamental type or
   a modified user defined type.  MODIFIERS is a pointer to the
   block of bytes that define MODCOUNT modifiers.  Immediately
   following the last modifier is a short containing the fundamental
   type or a long containing the reference to the user defined
   type.  Which one is determined by MTYPE, which is either
   AT_mod_fund_type or AT_mod_u_d_type to indicate what modified
   type we are generating.

   We call ourself recursively to generate each modified type,`
   until MODCOUNT reaches zero, at which point we have consumed
   all the modifiers and generate either the fundamental type or
   user defined type.  When the recursion unwinds, each modifier
   is applied in turn to generate the full modified type.

   NOTES

   If we find a modifier that we don't recognize, and it is not one
   of those reserved for application specific use, then we issue a
   warning and simply ignore the modifier.

   BUGS

   We currently ignore MOD_const and MOD_volatile.  (FIXME)

 */

static struct type *
decode_modified_type (char *modifiers, unsigned int modcount, int mtype)
{
  struct type *typep = NULL;
  unsigned short fundtype;
  DIE_REF die_ref;
  char modifier;
  int nbytes;

  if (modcount == 0)
    {
      switch (mtype)
	{
	case AT_mod_fund_type:
	  nbytes = attribute_size (AT_fund_type);
	  fundtype = target_to_host (modifiers, nbytes, GET_UNSIGNED,
				     current_objfile);
	  typep = decode_fund_type (fundtype);
	  break;
	case AT_mod_u_d_type:
	  nbytes = attribute_size (AT_user_def_type);
	  die_ref = target_to_host (modifiers, nbytes, GET_UNSIGNED,
				    current_objfile);
	  typep = lookup_utype (die_ref);
	  if (typep == NULL)
	    {
	      typep = alloc_utype (die_ref, NULL);
	    }
	  break;
	default:
	  complaint (&symfile_complaints,
		     _("DIE @@ 0x%x \"%s\", botched modified type decoding (mtype 0x%x)"),
		     DIE_ID, DIE_NAME, mtype);
	  typep = dwarf_fundamental_type (current_objfile, FT_INTEGER);
	  break;
	}
    }
  else
    {
      modifier = *modifiers++;
      typep = decode_modified_type (modifiers, --modcount, mtype);
      switch (modifier)
	{
	case MOD_pointer_to:
	  typep = lookup_pointer_type (typep);
	  break;
	case MOD_reference_to:
	  typep = lookup_reference_type (typep);
	  break;
	case MOD_const:
	  complaint (&symfile_complaints,
		     _("DIE @@ 0x%x \"%s\", type modifier 'const' ignored"), DIE_ID,
		     DIE_NAME);	/* FIXME */
	  break;
	case MOD_volatile:
	  complaint (&symfile_complaints,
		     _("DIE @@ 0x%x \"%s\", type modifier 'volatile' ignored"),
		     DIE_ID, DIE_NAME);	/* FIXME */
	  break;
	default:
	  if (!(MOD_lo_user <= (unsigned char) modifier))
#if 0
/* This part of the test would always be true, and it triggers a compiler
   warning.  */
		&& (unsigned char) modifier <= MOD_hi_user))
#endif
	    {
	      complaint (&symfile_complaints,
			 _("DIE @@ 0x%x \"%s\", unknown type modifier %u"), DIE_ID,
			 DIE_NAME, modifier);
	    }
	  break;
	}
    }
  return (typep);
}

/*

   LOCAL FUNCTION

   decode_fund_type -- translate basic DWARF type to gdb base type

   DESCRIPTION

   Given an integer that is one of the fundamental DWARF types,
   translate it to one of the basic internal gdb types and return
   a pointer to the appropriate gdb type (a "struct type *").

   NOTES

   For robustness, if we are asked to translate a fundamental
   type that we are unprepared to deal with, we return int so
   callers can always depend upon a valid type being returned,
   and so gdb may at least do something reasonable by default.
   If the type is not in the range of those types defined as
   application specific types, we also issue a warning.
 */

static struct type *
decode_fund_type (unsigned int fundtype)
{
  struct type *typep = NULL;

  switch (fundtype)
    {

    case FT_void:
      typep = dwarf_fundamental_type (current_objfile, FT_VOID);
      break;

    case FT_boolean:		/* Was FT_set in AT&T version */
      typep = dwarf_fundamental_type (current_objfile, FT_BOOLEAN);
      break;

    case FT_pointer:		/* (void *) */
      typep = dwarf_fundamental_type (current_objfile, FT_VOID);
      typep = lookup_pointer_type (typep);
      break;

    case FT_char:
      typep = dwarf_fundamental_type (current_objfile, FT_CHAR);
      break;

    case FT_signed_char:
      typep = dwarf_fundamental_type (current_objfile, FT_SIGNED_CHAR);
      break;

    case FT_unsigned_char:
      typep = dwarf_fundamental_type (current_objfile, FT_UNSIGNED_CHAR);
      break;

    case FT_short:
      typep = dwarf_fundamental_type (current_objfile, FT_SHORT);
      break;

    case FT_signed_short:
      typep = dwarf_fundamental_type (current_objfile, FT_SIGNED_SHORT);
      break;

    case FT_unsigned_short:
      typep = dwarf_fundamental_type (current_objfile, FT_UNSIGNED_SHORT);
      break;

    case FT_integer:
      typep = dwarf_fundamental_type (current_objfile, FT_INTEGER);
      break;

    case FT_signed_integer:
      typep = dwarf_fundamental_type (current_objfile, FT_SIGNED_INTEGER);
      break;

    case FT_unsigned_integer:
      typep = dwarf_fundamental_type (current_objfile, FT_UNSIGNED_INTEGER);
      break;

    case FT_long:
      typep = dwarf_fundamental_type (current_objfile, FT_LONG);
      break;

    case FT_signed_long:
      typep = dwarf_fundamental_type (current_objfile, FT_SIGNED_LONG);
      break;

    case FT_unsigned_long:
      typep = dwarf_fundamental_type (current_objfile, FT_UNSIGNED_LONG);
      break;

    case FT_long_long:
      typep = dwarf_fundamental_type (current_objfile, FT_LONG_LONG);
      break;

    case FT_signed_long_long:
      typep = dwarf_fundamental_type (current_objfile, FT_SIGNED_LONG_LONG);
      break;

    case FT_unsigned_long_long:
      typep = dwarf_fundamental_type (current_objfile, FT_UNSIGNED_LONG_LONG);
      break;

    case FT_float:
      typep = dwarf_fundamental_type (current_objfile, FT_FLOAT);
      break;

    case FT_dbl_prec_float:
      typep = dwarf_fundamental_type (current_objfile, FT_DBL_PREC_FLOAT);
      break;

    case FT_ext_prec_float:
      typep = dwarf_fundamental_type (current_objfile, FT_EXT_PREC_FLOAT);
      break;

    case FT_complex:
      typep = dwarf_fundamental_type (current_objfile, FT_COMPLEX);
      break;

    case FT_dbl_prec_complex:
      typep = dwarf_fundamental_type (current_objfile, FT_DBL_PREC_COMPLEX);
      break;

    case FT_ext_prec_complex:
      typep = dwarf_fundamental_type (current_objfile, FT_EXT_PREC_COMPLEX);
      break;

    }

  if (typep == NULL)
    {
      typep = dwarf_fundamental_type (current_objfile, FT_INTEGER);
      if (!(FT_lo_user <= fundtype && fundtype <= FT_hi_user))
	{
	  complaint (&symfile_complaints,
		     _("DIE @@ 0x%x \"%s\", unexpected fundamental type 0x%x"),
		     DIE_ID, DIE_NAME, fundtype);
	}
    }

  return (typep);
}

/*

   LOCAL FUNCTION

   create_name -- allocate a fresh copy of a string on an obstack

   DESCRIPTION

   Given a pointer to a string and a pointer to an obstack, allocates
   a fresh copy of the string on the specified obstack.

 */

static char *
create_name (char *name, struct obstack *obstackp)
{
  int length;
  char *newname;

  length = strlen (name) + 1;
  newname = (char *) obstack_alloc (obstackp, length);
  strcpy (newname, name);
  return (newname);
}

/*

   LOCAL FUNCTION

   basicdieinfo -- extract the minimal die info from raw die data

   SYNOPSIS

   void basicdieinfo (char *diep, struct dieinfo *dip,
   struct objfile *objfile)

   DESCRIPTION

   Given a pointer to raw DIE data, and a pointer to an instance of a
   die info structure, this function extracts the basic information
   from the DIE data required to continue processing this DIE, along
   with some bookkeeping information about the DIE.

   The information we absolutely must have includes the DIE tag,
   and the DIE length.  If we need the sibling reference, then we
   will have to call completedieinfo() to process all the remaining
   DIE information.

   Note that since there is no guarantee that the data is properly
   aligned in memory for the type of access required (indirection
   through anything other than a char pointer), and there is no
   guarantee that it is in the same byte order as the gdb host,
   we call a function which deals with both alignment and byte
   swapping issues.  Possibly inefficient, but quite portable.

   We also take care of some other basic things at this point, such
   as ensuring that the instance of the die info structure starts
   out completely zero'd and that curdie is initialized for use
   in error reporting if we have a problem with the current die.

   NOTES

   All DIE's must have at least a valid length, thus the minimum
   DIE size is SIZEOF_DIE_LENGTH.  In order to have a valid tag, the
   DIE size must be at least SIZEOF_DIE_TAG larger, otherwise they
   are forced to be TAG_padding DIES.

   Padding DIES must be at least SIZEOF_DIE_LENGTH in length, implying
   that if a padding DIE is used for alignment and the amount needed is
   less than SIZEOF_DIE_LENGTH, then the padding DIE has to be big
   enough to align to the next alignment boundry.

   We do some basic sanity checking here, such as verifying that the
   length of the die would not cause it to overrun the recorded end of
   the buffer holding the DIE info.  If we find a DIE that is either
   too small or too large, we force it's length to zero which should
   cause the caller to take appropriate action.
 */

static void
basicdieinfo (struct dieinfo *dip, char *diep, struct objfile *objfile)
{
  curdie = dip;
  memset (dip, 0, sizeof (struct dieinfo));
  dip->die = diep;
  dip->die_ref = dbroff + (diep - dbbase);
  dip->die_length = target_to_host (diep, SIZEOF_DIE_LENGTH, GET_UNSIGNED,
				    objfile);
  if ((dip->die_length < SIZEOF_DIE_LENGTH) ||
      ((diep + dip->die_length) > (dbbase + dbsize)))
    {
      complaint (&symfile_complaints,
		 _("DIE @@ 0x%x \"%s\", malformed DIE, bad length (%ld bytes)"),
		 DIE_ID, DIE_NAME, dip->die_length);
      dip->die_length = 0;
    }
  else if (dip->die_length < (SIZEOF_DIE_LENGTH + SIZEOF_DIE_TAG))
    {
      dip->die_tag = TAG_padding;
    }
  else
    {
      diep += SIZEOF_DIE_LENGTH;
      dip->die_tag = target_to_host (diep, SIZEOF_DIE_TAG, GET_UNSIGNED,
				     objfile);
    }
}

/*

   LOCAL FUNCTION

   completedieinfo -- finish reading the information for a given DIE

   SYNOPSIS

   void completedieinfo (struct dieinfo *dip, struct objfile *objfile)

   DESCRIPTION

   Given a pointer to an already partially initialized die info structure,
   scan the raw DIE data and finish filling in the die info structure
   from the various attributes found.

   Note that since there is no guarantee that the data is properly
   aligned in memory for the type of access required (indirection
   through anything other than a char pointer), and there is no
   guarantee that it is in the same byte order as the gdb host,
   we call a function which deals with both alignment and byte
   swapping issues.  Possibly inefficient, but quite portable.

   NOTES

   Each time we are called, we increment the diecount variable, which
   keeps an approximate count of the number of dies processed for
   each compilation unit.  This information is presented to the user
   if the info_verbose flag is set.

 */

static void
completedieinfo (struct dieinfo *dip, struct objfile *objfile)
{
  char *diep;			/* Current pointer into raw DIE data */
  char *end;			/* Terminate DIE scan here */
  unsigned short attr;		/* Current attribute being scanned */
  unsigned short form;		/* Form of the attribute */
  int nbytes;			/* Size of next field to read */

  diecount++;
  diep = dip->die;
  end = diep + dip->die_length;
  diep += SIZEOF_DIE_LENGTH + SIZEOF_DIE_TAG;
  while (diep < end)
    {
      attr = target_to_host (diep, SIZEOF_ATTRIBUTE, GET_UNSIGNED, objfile);
      diep += SIZEOF_ATTRIBUTE;
      nbytes = attribute_size (attr);
      if (nbytes == -1)
	{
	  complaint (&symfile_complaints,
		     _("DIE @@ 0x%x \"%s\", unknown attribute length, skipped remaining attributes"),
		     DIE_ID, DIE_NAME);
	  diep = end;
	  continue;
	}
      switch (attr)
	{
	case AT_fund_type:
	  dip->at_fund_type = target_to_host (diep, nbytes, GET_UNSIGNED,
					      objfile);
	  break;
	case AT_ordering:
	  dip->at_ordering = target_to_host (diep, nbytes, GET_UNSIGNED,
					     objfile);
	  break;
	case AT_bit_offset:
	  dip->at_bit_offset = target_to_host (diep, nbytes, GET_UNSIGNED,
					       objfile);
	  break;
	case AT_sibling:
	  dip->at_sibling = target_to_host (diep, nbytes, GET_UNSIGNED,
					    objfile);
	  break;
	case AT_stmt_list:
	  dip->at_stmt_list = target_to_host (diep, nbytes, GET_UNSIGNED,
					      objfile);
	  dip->has_at_stmt_list = 1;
	  break;
	case AT_low_pc:
	  dip->at_low_pc = target_to_host (diep, nbytes, GET_UNSIGNED,
					   objfile);
	  dip->at_low_pc += baseaddr;
	  dip->has_at_low_pc = 1;
	  break;
	case AT_high_pc:
	  dip->at_high_pc = target_to_host (diep, nbytes, GET_UNSIGNED,
					    objfile);
	  dip->at_high_pc += baseaddr;
	  break;
	case AT_language:
	  dip->at_language = target_to_host (diep, nbytes, GET_UNSIGNED,
					     objfile);
	  break;
	case AT_user_def_type:
	  dip->at_user_def_type = target_to_host (diep, nbytes,
						  GET_UNSIGNED, objfile);
	  break;
	case AT_byte_size:
	  dip->at_byte_size = target_to_host (diep, nbytes, GET_UNSIGNED,
					      objfile);
	  dip->has_at_byte_size = 1;
	  break;
	case AT_bit_size:
	  dip->at_bit_size = target_to_host (diep, nbytes, GET_UNSIGNED,
					     objfile);
	  break;
	case AT_member:
	  dip->at_member = target_to_host (diep, nbytes, GET_UNSIGNED,
					   objfile);
	  break;
	case AT_discr:
	  dip->at_discr = target_to_host (diep, nbytes, GET_UNSIGNED,
					  objfile);
	  break;
	case AT_location:
	  dip->at_location = diep;
	  break;
	case AT_mod_fund_type:
	  dip->at_mod_fund_type = diep;
	  break;
	case AT_subscr_data:
	  dip->at_subscr_data = diep;
	  break;
	case AT_mod_u_d_type:
	  dip->at_mod_u_d_type = diep;
	  break;
	case AT_element_list:
	  dip->at_element_list = diep;
	  dip->short_element_list = 0;
	  break;
	case AT_short_element_list:
	  dip->at_element_list = diep;
	  dip->short_element_list = 1;
	  break;
	case AT_discr_value:
	  dip->at_discr_value = diep;
	  break;
	case AT_string_length:
	  dip->at_string_length = diep;
	  break;
	case AT_name:
	  dip->at_name = diep;
	  break;
	case AT_comp_dir:
	  /* For now, ignore any "hostname:" portion, since gdb doesn't
	     know how to deal with it.  (FIXME). */
	  dip->at_comp_dir = strrchr (diep, ':');
	  if (dip->at_comp_dir != NULL)
	    {
	      dip->at_comp_dir++;
	    }
	  else
	    {
	      dip->at_comp_dir = diep;
	    }
	  break;
	case AT_producer:
	  dip->at_producer = diep;
	  break;
	case AT_start_scope:
	  dip->at_start_scope = target_to_host (diep, nbytes, GET_UNSIGNED,
						objfile);
	  break;
	case AT_stride_size:
	  dip->at_stride_size = target_to_host (diep, nbytes, GET_UNSIGNED,
						objfile);
	  break;
	case AT_src_info:
	  dip->at_src_info = target_to_host (diep, nbytes, GET_UNSIGNED,
					     objfile);
	  break;
	case AT_prototyped:
	  dip->at_prototyped = diep;
	  break;
	default:
	  /* Found an attribute that we are unprepared to handle.  However
	     it is specifically one of the design goals of DWARF that
	     consumers should ignore unknown attributes.  As long as the
	     form is one that we recognize (so we know how to skip it),
	     we can just ignore the unknown attribute. */
	  break;
	}
      form = FORM_FROM_ATTR (attr);
      switch (form)
	{
	case FORM_DATA2:
	  diep += 2;
	  break;
	case FORM_DATA4:
	case FORM_REF:
	  diep += 4;
	  break;
	case FORM_DATA8:
	  diep += 8;
	  break;
	case FORM_ADDR:
	  diep += TARGET_FT_POINTER_SIZE (objfile);
	  break;
	case FORM_BLOCK2:
	  diep += 2 + target_to_host (diep, nbytes, GET_UNSIGNED, objfile);
	  break;
	case FORM_BLOCK4:
	  diep += 4 + target_to_host (diep, nbytes, GET_UNSIGNED, objfile);
	  break;
	case FORM_STRING:
	  diep += strlen (diep) + 1;
	  break;
	default:
	  unknown_attribute_form_complaint (DIE_ID, DIE_NAME, form);
	  diep = end;
	  break;
	}
    }
}

/*

   LOCAL FUNCTION

   target_to_host -- swap in target data to host

   SYNOPSIS

   target_to_host (char *from, int nbytes, int signextend,
   struct objfile *objfile)

   DESCRIPTION

   Given pointer to data in target format in FROM, a byte count for
   the size of the data in NBYTES, a flag indicating whether or not
   the data is signed in SIGNEXTEND, and a pointer to the current
   objfile in OBJFILE, convert the data to host format and return
   the converted value.

   NOTES

   FIXME:  If we read data that is known to be signed, and expect to
   use it as signed data, then we need to explicitly sign extend the
   result until the bfd library is able to do this for us.

   FIXME: Would a 32 bit target ever need an 8 byte result?

 */

static CORE_ADDR
target_to_host (char *from, int nbytes, int signextend,	/* FIXME:  Unused */
		struct objfile *objfile)
{
  CORE_ADDR rtnval;

  switch (nbytes)
    {
    case 8:
      rtnval = bfd_get_64 (objfile->obfd, (bfd_byte *) from);
      break;
    case 4:
      rtnval = bfd_get_32 (objfile->obfd, (bfd_byte *) from);
      break;
    case 2:
      rtnval = bfd_get_16 (objfile->obfd, (bfd_byte *) from);
      break;
    case 1:
      rtnval = bfd_get_8 (objfile->obfd, (bfd_byte *) from);
      break;
    default:
      complaint (&symfile_complaints,
		 _("DIE @@ 0x%x \"%s\", no bfd support for %d byte data object"),
		 DIE_ID, DIE_NAME, nbytes);
      rtnval = 0;
      break;
    }
  return (rtnval);
}

/*

   LOCAL FUNCTION

   attribute_size -- compute size of data for a DWARF attribute

   SYNOPSIS

   static int attribute_size (unsigned int attr)

   DESCRIPTION

   Given a DWARF attribute in ATTR, compute the size of the first
   piece of data associated with this attribute and return that
   size.

   Returns -1 for unrecognized attributes.

 */

static int
attribute_size (unsigned int attr)
{
  int nbytes;			/* Size of next data for this attribute */
  unsigned short form;		/* Form of the attribute */

  form = FORM_FROM_ATTR (attr);
  switch (form)
    {
    case FORM_STRING:		/* A variable length field is next */
      nbytes = 0;
      break;
    case FORM_DATA2:		/* Next 2 byte field is the data itself */
    case FORM_BLOCK2:		/* Next 2 byte field is a block length */
      nbytes = 2;
      break;
    case FORM_DATA4:		/* Next 4 byte field is the data itself */
    case FORM_BLOCK4:		/* Next 4 byte field is a block length */
    case FORM_REF:		/* Next 4 byte field is a DIE offset */
      nbytes = 4;
      break;
    case FORM_DATA8:		/* Next 8 byte field is the data itself */
      nbytes = 8;
      break;
    case FORM_ADDR:		/* Next field size is target sizeof(void *) */
      nbytes = TARGET_FT_POINTER_SIZE (objfile);
      break;
    default:
      unknown_attribute_form_complaint (DIE_ID, DIE_NAME, form);
      nbytes = -1;
      break;
    }
  return (nbytes);
}
@


1.47
log
@ * Fix PR 2223. Recognize Pascal language marker in dwarf readers
@
text
@@


1.46
log
@Copyright updates for 2007.
@
text
@d619 3
a624 1
    case LANG_PASCAL83:
@


1.45
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 2
a4 2
   Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
@


1.44
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d3 1
a3 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
d23 2
a24 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.43
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d2351 2
d2372 1
a2372 1
		  printf_filtered ("%d DIE's, sorting...", diecount);
d2420 1
a2420 1
		  printf_filtered ("Reading in symbols for %s...",
d2439 1
a2439 1
		  printf_filtered ("done.\n");
@


1.42
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d138 1
a138 1
	     "DIE @@ 0x%x \"%s\", reference to DIE (0x%x) outside compilation unit",
d146 1
a146 1
	     "DIE @@ 0x%x \"%s\", unknown attribute form (0x%x)", arg1, arg2,
d154 1
a154 1
	     "DIE @@ 0x%x \"%s\", internal error: duplicate user type definition",
d162 1
a162 1
	     "DIE @@ 0x%x \"%s\", bad array element type attribute 0x%x", arg1,
d821 1
a821 1
		 "DIE @@ 0x%x \"%s\", internal error: duplicate user type allocation",
d970 1
a970 1
		 "DIE @@ 0x%x \"%s\", missing class, structure, or union tag",
d1309 1
a1309 1
		     "DIE @@ 0x%x \"%s\", can't decode subscript data items",
d1325 1
a1325 1
		 "DIE @@ 0x%x \"%s\", array subscript format 0x%x not handled yet",
d1333 1
a1333 1
		 "DIE @@ 0x%x \"%s\", unknown array subscript format %x", DIE_ID,
d1373 1
a1373 1
		 "DIE @@ 0x%x \"%s\", array not row major; not handled correctly",
d1790 1
a1790 1
      complaint (&symfile_complaints, "DIE @@ 0x%x, AT_name tag missing",
d2213 1
a2213 1
		     "DIE @@ 0x%x \"%s\", OP_DEREF2 address 0x%lx not handled",
d2218 1
a2218 1
		     "DIE @@ 0x%x \"%s\", OP_DEREF4 address 0x%lx not handled",
d3188 1
a3188 1
		     "DIE @@ 0x%x \"%s\", botched modified type decoding (mtype 0x%x)",
d3208 1
a3208 1
		     "DIE @@ 0x%x \"%s\", type modifier 'const' ignored", DIE_ID,
d3213 1
a3213 1
		     "DIE @@ 0x%x \"%s\", type modifier 'volatile' ignored",
d3225 1
a3225 1
			 "DIE @@ 0x%x \"%s\", unknown type modifier %u", DIE_ID,
d3369 1
a3369 1
		     "DIE @@ 0x%x \"%s\", unexpected fundamental type 0x%x",
d3469 1
a3469 1
		 "DIE @@ 0x%x \"%s\", malformed DIE, bad length (%ld bytes)",
d3538 1
a3538 1
		     "DIE @@ 0x%x \"%s\", unknown attribute length, skipped remaining attributes",
d3754 1
a3754 1
		 "DIE @@ 0x%x \"%s\", no bfd support for %d byte data object",
@


1.41
log
@2004-07-17  Andrew Cagney  <cagney@@gnu.org>

	* ppc-linux-tdep.c (ppc_linux_init_abi): Add [sic] to Linux.
	* ppc-linux-nat.c: Use "Linux kernel".
	* hppa-linux-tdep.c: Use GNU/Linux.
	* hppa-linux-nat.c: Use GNU/Linux.
	* dwarfread.c: Add [sic] to use of Linux.
@
text
@d561 1
a561 1
      error ("internal error - invalid fundamental type id %d", typeid);
d680 1
a680 1
      error ("can't read DWARF data from '%s'", bfd_get_filename (abfd));
d2275 1
a2275 1
      error ("can't read DWARF data");
d2291 1
a2291 1
	  error ("can't read DWARF line number table size");
d2300 1
a2300 1
	  error ("can't read DWARF line numbers");
d2338 1
a2338 1
	  warning ("psymtab for %s already read in.  Shouldn't happen.",
d2407 1
a2407 1
	  warning ("psymtab for %s already read in.  Shouldn't happen.",
@


1.40
log
@2004-06-24  Andrew Cagney  <cagney@@gnu.org>

	* objfiles.h (struct entry_info): Delete entry_func_lowpc and
	entry_func_highpc fields.
	* objfiles.c (init_entry_point_info): Do not clear
	entry_func_lowpc and entry_func_highpc.
	(objfile_relocate): Do not relocate entry_func_lowpc and
	entry_func_highpc.
	* dwarfread.c (read_func_scope): Do not set entry_func_lowpc and
	entry_func_highpc.
	* dwarf2read.c (read_func_scope): Do not set entry_func_lowpc and
	entry_func_highpc.
	* blockframe.c (legacy_frame_chain_valid): Replace tests against
	entry_func_lowpc and entry_func_highpc with call to
	inside_entry_func.
@
text
@d87 1
a87 1
     Absoft ProFortran Linux Fortran User Guide (no version,
@


1.40.2.1
log
@2004-07-17  Andrew Cagney  <cagney@@gnu.org>

	* ppc-linux-tdep.c (ppc_linux_init_abi): Add [sic] to Linux.
	* ppc-linux-nat.c: Use "Linux kernel".
	* hppa-linux-tdep.c: Use GNU/Linux.
	* hppa-linux-nat.c: Use GNU/Linux.
	* dwarfread.c: Add [sic] to use of Linux.
@
text
@d87 1
a87 1
     Absoft ProFortran Linux[sic] Fortran User Guide (no version,
@


1.39
log
@2004-05-07  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Delete unused fields
	deprecated_entry_file_lowpc and deprecated_entry_file_highpc.
	* objfiles.c (init_entry_point_info, objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab, read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@a1794 6
  if (objfile->ei.entry_point >= dip->at_low_pc &&
      objfile->ei.entry_point < dip->at_high_pc)
    {
      objfile->ei.entry_func_lowpc = dip->at_low_pc;
      objfile->ei.entry_func_highpc = dip->at_high_pc;
    }
@


1.38
log
@2004-05-01  Michael Chastain  <mec.gnu@@mindspring.com>

	* dwarfread.c: Update documentation on the state of dwarf-1.
@
text
@a1895 6
  if (objfile->ei.entry_point >= dip->at_low_pc &&
      objfile->ei.entry_point < dip->at_high_pc)
    {
      objfile->ei.deprecated_entry_file_lowpc = dip->at_low_pc;
      objfile->ei.deprecated_entry_file_highpc = dip->at_high_pc;
    }
@


1.37
log
@2004-02-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (init_entry_point_info, entry_point_address): Move
	from here...
	* objfiles.c (init_entry_point_info, entry_point_address):..to
	here.
	* symfile.h (init_entry_point_info, entry_point_address): Remove
	prototypes.
	* objfiles.h (init_entry_point_info, entry_point_address):Add
	prototypes.
	* cris-tdep.c: Remove include of symfile.h. Add include of
	objfiles.h.
	* infcall.c: Ditto.
	* mcore-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
 	* v850-tdep.c: Ditto.
	* arm-tdep.c: Remove include of symfile.h.
	* blockframe.c: Ditto.
	* coffread.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* frv-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* mipsread.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* s390-tdep.c: Ditto.
	* sh-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* gdbarch.sh: Remove include of symfile.h.
	* gdbarch.c: Regenerate.
	* solib-irix.c (enable_break): Use entry_point_address().
	Add comment about include file.
	* xcoffread.c: Add comment about include file.
	* Makefile.in (arm-tdep.o, blockframe.o, coffread.o, cris-tdep.o)
	(dbxread.o, dwarf2read.o, dwarfread.o, frv-tdep.o, gdbarch.o)
	(ia64-tdep.o, infcall.o, mcore-tdep.o, mdebugread.o, mipsread.o)
	(mn10300-tdep.o, rs6000-nat.o, s390-tdep.o, sh64-tdep.o)
	(sh-tdep.o, v850-tdep.o, xstormy16-tdep.o): Update dependencies.
@
text
@d32 1
a32 1
   In gcc HEAD 2003-11-29 16:28:31 UTC, no targets prefer dwarf-1.
d76 2
d79 5
d87 5
a91 1
   -- chastain 2003-12-01
@


1.37.2.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d32 1
a32 1
   In gcc 3.4.0, support for dwarf-1 has been removed.
a75 2
     On 2003-07-25 the gdb list received a report from a user
      with Diab Compiler 4.4b.
a76 5

     Diab Compiler Suite 5.0.1 supports dwarf-2/dwarf-3 for C and C++.
     (Diab(tm) Compiler Suite 5.0.1 Release Notes, DOC-14691-ZD-00,
     Wind River Systems, 2002-07-31).

d80 1
a80 5
     Absoft ProFortran Linux[sic] Fortran User Guide (no version,
     but copyright dates are 1991-2001) says that Absoft ProFortran
     supports -gdwarf1 and -gdwarf2.

   -- chastain 2004-04-24
d1784 6
d1885 6
@


1.36
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* buildsym.c (free_pending_blocks, finish_block)
	(record_pending_block, make_blockvector, end_symtab): Replace
	symbol_obstack with objfile_obstack.
	* coffread.c (process_coff_symbol, coff_read_struct_type)
	(coff_read_enum_type): Ditto.
	* cp-namespace.c (initialize_namespace_symtab)
	(check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol, dwarf2_const_value, macro_start_file)
	(dwarf2_symbol_mark_computed): Ditto.
	* dwarfread.c (enum_type, new_symbol, synthesize_typedef): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* hpread.c (hpread_symfile_init, hpread_symfile_init)
	(hpread_read_enum_type, hpread_read_function_type)
	(hpread_read_doc_function_type, hpread_process_one_debug_symbol):
	Ditto.
	* jv-lang.c (get_java_class_symtab, add_class_symbol)
	(java_link_class_type): Ditto.
	* mdebugread.c (parse_symbol, psymtab_to_symtab_1, new_symtab)
	(new_symbol): Ditto.
	* minsyms.c (install_minimal_symbols): Ditto.
	* objfiles.c (allocate_objfile): Remove init of symbol_obstack.
	(terminate_minimal_symbol_table): Replace symbol_obstack with
	objfile_obstack.
	(free_objfile): Remove freeing of symbol_obstack.
	* objfiles.h: Remove symbol_obstack field.
	* pa64solib.c (add_to_solist): Replace symbol_obstack with
	objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
	symbol_obstack.
	(solib_add_common_symbols): Replace symbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add): Ditto.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_start, common_block_end): Ditto.
	* symfile.c (reread_symbols): Remove freeing and init of
	symbol_obstack.
	(allocate_symtab): Rename symbol_obstack to objfile_obstack.
	* symfile.h: Update comment.
	* symmisc.c (print_objfile_statistics): Remove symbol_obstack
	stats printing.
	* symtab.c (symbol_set_names): Replace symbol_obstack with
	objfile_obstack.
	* symtab.h (struct general_symbol_info, struct minimal_symbol):
	Update comments.
	* xcoffread.c (read_xcoff_symtab, SYMBOL_DUP, SYMNAME_ALLOC)
	(init_stringtab, xcoff_initial_scan): Replace symbol_obstack with
	objfile_obstack.
@
text
@a104 1
#include "symfile.h"
@


1.35
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* dbxread.c (dbx_symfile_init, start_psymtab, end_psymtab,
	coffstab_build_psymtabs, elfstab_build_psymtabs)
	(stabsect_build_psymtabs): Replace psymbol_obstack with
	objfile_obstack.
	* dwarf2-frame.c (decode_frame_entry_1): Ditto.
	* dwarf2read.c (dwarf2_build_psymtabs_hard, dwarf2_read_section):
	Ditto.
	* dwarfread.c (scan_compilation_units): Ditto.
	* elfread.c (elfstab_offset_sections): Ditto.
	* hppa-tdep.c (read_unwind_info): Ditto.
	* hpread.c (hpread_build_psymtabs, hpread_start_psymtab)
	(hpread_end_psymtab): Ditto.
	* mdebugread.c (mdebug_build_psymtabs, add_pending)
	(parse_partial_symbols, new_psymtab, elfmdebug_build_psymtabs):
	Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* objfiles.c (add_to_objfile_sections)
	(build_objfile_section_table): Ditto.
	(allocate_objfile): Remove init of psymbol_obstack.
	(free_objfile): Remove freeing of psymbol_obstack.
	* objfiles.h (struct objfile): Remove field
	psymbol_obstack. Update comments.
	* pa64solib.c (pa64_solib_add_solib_objfile): Replace
	psymbol_obstack with objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
        psymbol_obstack.
	* somread.c (som_symfile_offsets, init_import_symbols)
	(init_export_symbols): Replace psymbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
	* symfile.c (default_symfile_offsets, syms_from_objfile)
	(reread_symbols): Remove freeing and init of psymbol_obstack.
	(cashier_psymtab): Update comment.
	* symmisc.c (print_objfile_statistics): Don't report stats for
	psymbol obstack.
	* symtab.h (struct general_symbol_info, struct partial_symtab):
	Update comments.
	* xcoffread.c (xcoff_start_psymtab, xcoff_end_psymtab, swap_sym)
	(xcoff_symfile_offsets): Replace psymbol_obstack with
	objfile_obstack.
@
text
@d1711 1
a1711 1
	  sym = (struct symbol *) obstack_alloc (&objfile->symbol_obstack,
d1715 1
a1715 1
					   &objfile->symbol_obstack);
d1736 1
a1736 1
	    obstack_alloc (&objfile->symbol_obstack, sizeof (struct field) * nfields);
d2854 1
a2854 1
      sym = (struct symbol *) obstack_alloc (&objfile->symbol_obstack,
d3014 1
a3014 1
	obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));
d3018 1
a3018 1
				       &objfile->symbol_obstack);
@


1.34
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

        * objfiles.h (struct objfile): Add objfile_obstack field.
        Remove type_obstack field.

        * dwarf2read.c (dwarf2_add_field,dwarf2_add_member_fn,
        read_structure_scope read_enumeration, new_symbol): Replace
        type_obstack with objfile_obstack.
        * dwarfread.c (struct_type, enum_type): Ditto.
        * gdbtypes.c (alloc_type, alloc_type_instance, init_type)
        (lookup_fundamental_type): Ditto.
        * gdbtypes.h (TYPE_ALLOC): Ditto.
        * hpread.c (hpread_read_enum_type, hpread_read_function_type)
        (hpread_read_doc_function_type, hpread_read_struct_type)
        (fix_static_member_physnames, hpread_read_array_type)
        (hpread_read_subrange_type, hpread_type_lookup): Ditto.
        * jv-lang.c (java_lookup_class, type_from_class, type_from_class)
        (java_link_class_type): Ditto.
        * mdebugread.c (parse_type): Ditto.
        * objfiles.c (allocate_objfile, free_objfile): Ditto.
        * solib-sunos.c (solib_add_common_symbols): Ditto.
        * stabsread.c (define_symbol, read_type, read_member_functions,
        read_cpp_abbrev, read_one_struct_field): Ditto.
        * symfile.c (reread_symbols): Ditto.
        * symmisc.c (print_objfile_statistics): Ditto.
@
text
@d2803 1
a2803 1
	    obstack_alloc (&objfile->psymbol_obstack,
@


1.33
log
@2003-12-01  Michael Chastain  <mec.gnu@@mindspring.com>

	* dwarfread.c: Update documentation on the state of dwarf-1.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d971 1
a971 1
      TYPE_TAG_NAME (type) = obconcat (&objfile->type_obstack,
d1014 1
a1014 1
			  &objfile->type_obstack);
d1673 1
a1673 1
      TYPE_TAG_NAME (type) = obconcat (&objfile->type_obstack,
d1707 1
a1707 1
					   &objfile->type_obstack);
@


1.32
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* defs.h (DEPRECATED_STREQN): Rename STREQN.
	(DEPRECATED_STREQ): Rename STREQ.
	* ada-exp.y, ada-lang.c, ada-lex.l, coffread.c: Update.
	* config/mips/tm-irix5.h, config/mips/tm-irix6.h: Update.
	* config/mips/tm-mipsv4.h, config/sparc/tm-sun4sol2.h: Update.
	* dbxread.c, dwarf2read.c, dwarfread.c, environ.c: Update.
	* eval.c, exec.c, f-lang.c, hppa-tdep.c, hpread.c: Update.
	* jv-exp.y, language.c, m2-exp.y, mcore-rom.c: Update.
	* mdebugread.c, mipsread.c, objc-exp.y, objfiles.c: Update.
	* p-exp.y, p-typeprint.c, p-valprint.c, rs6000-nat.c: Update.
	* source.c, sparc-tdep.c, stack.c, target.c: Update.
@
text
@d27 2
a28 1
   Go look in dwarf2read.c.  This file is for the original DWARF.
d30 1
a30 1
   DWARF (also known as DWARF-1) is headed for obsoletion.
d32 1
a32 1
   In gcc 3.2.1, these targets prefer dwarf-1:
d34 1
a34 6
     i[34567]86-sequent-ptx4*   # TD-R2
     i[34567]86-sequent-sysv4*  # TD-R2
     i[34567]86-dg-dgux*        # obsolete in gcc 3.2.1, to be removed in 3.3
     m88k-dg-dgux*              # TD-R2
     mips-sni-sysv4             # TD-R2
     sparc-hal-solaris2*        # TD-R2
d36 43
a78 3
    Configurations marked with "# TD-R2" are on Zach Weinberg's list
    of "Target Deprecation, Round 2".  This is a candidate list of
    targets to be deprecated in gcc 3.3 and removed in gcc 3.4.
d80 1
a80 19
      http://gcc.gnu.org/ml/gcc/2002-12/msg00702.html

    gcc 2.95.3 had many configurations which prefer dwarf-1.
    We may have to support dwarf-1 as long as we support gcc 2.95.3.
    This could use more analysis.

    DG/UX (Data General Unix) used dwarf-1 for its native format.
    DG/UX uses gcc for its system C compiler, but they have their
    own linker and their own debuggers.

    Takis Psarogiannakopoulos has a complete gnu toolchain for DG/UX
    with gcc 2.95.3, gdb 5.1, and debug formats of dwarf-2 and stabs.
    For more info, see PR gdb/979 and PR gdb/1013; also:

      http://sources.redhat.com/ml/gdb/2003-02/msg00074.html

    There may be non-gcc compilers that still emit dwarf-1.

    -- chastain 2003-02-04
@


1.31
log
@2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* valops.c (destructor_name_p): Replace STREQN with strncmp.
	* top.c (command_line_input): Ditto.
	* objc-exp.y (yylex): Ditto.
	* minsyms.c (prim_record_minimal_symbol_and_info): Ditto.
	* jv-exp.y (yylex): Ditto.
	* f-exp.y (yylex): Ditto.
	* event-top.c (command_line_handler): Ditto.
	* environ.c (get_in_environ): Ditto.
	(set_in_environ): Ditto.
	* dwarfread.c (handle_producer): Ditto.
	* dbxread.c (process_one_symbol): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* c-exp.y (yylex): Ditto.

2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* mi-cmd-var.c (mi_cmd_var_set_format): Replace STREQN with
	strncmp.
@
text
@d1805 1
a1805 1
  if (STREQN (producer, GCC_PRODUCER, strlen (GCC_PRODUCER)))
d1823 1
a1823 1
      if (STREQN (producer, GPLUS_PRODUCER, strlen (GPLUS_PRODUCER)))
d1831 1
a1831 1
      else if (STREQN (producer, LCC_PRODUCER, strlen (LCC_PRODUCER)))
@


1.30
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Deprecate "entry_file_lowpc" and
	"entry_file_highpc".  Update comments.
	* defs.h (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* blockframe.c (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* frame.c (get_prev_frame): Update.  Use if 0 instead of #if 0.
	* vax-tdep.c (vax_frame_chain): Update.
	* sh64-tdep.c (sh64_frame_chain): Update.
	* sh-tdep.c (sh_frame_chain): Update.
	* rs6000-tdep.c (rs6000_frame_chain): Update.
	* ns32k-tdep.c (ns32k_frame_chain): Update.
	* mips-tdep.c (mips_frame_chain): Update.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Update.
	* m32r-tdep.c (m32r_frame_this_id): Update.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Update.
	* frv-tdep.c (frv_frame_this_id): Update.
	* d10v-tdep.c (d10v_frame_this_id): Update.
	* cris-tdep.c (cris_frame_chain): Update.
	* blockframe.c (legacy_frame_chain_valid): Update.
	* avr-tdep.c (avr_frame_this_id): Update.
	* arm-tdep.c (arm_prologue_this_id): Update.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Update.
	* objfiles.c (objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	(mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab): Update.
	(read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d1813 1
a1813 1
	STREQN (producer, GPLUS_PRODUCER, strlen (GPLUS_PRODUCER));
@


1.29
log
@2003-06-27  Elena Zannoni  <ezannoni@@redhat.com>

        * dwarfread.c (decode_modified_type): Gag new compiler warning.
@
text
@d1871 2
a1872 2
      objfile->ei.entry_file_lowpc = dip->at_low_pc;
      objfile->ei.entry_file_highpc = dip->at_high_pc;
@


1.28
log
@	PR gdb/1179
	* dwarfread.c (struct_type): Skip static fields without crashing.
@
text
@d3201 4
a3204 1
	  if (!(MOD_lo_user <= (unsigned char) modifier
d3206 1
@


1.27
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* block.h (BLOCK_SHOULD_SORT): Delete.
	* symtab.c (lookup_block_symbol): Don't worry about sorted linear
	blocks.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Ditto.
	* symfile.h: Delete sort_symtabs_syms and sort_block_syms
	declarations.
	* coffread.c (coff_symfile_read): Don't call sort_symtab_syms.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
@
text
@d982 7
@


1.27.4.1
log
@	PR gdb/1179
	* dwarfread.c (struct_type): Skip static fields without crashing.
@
text
@a981 7
	  /* Static fields can be either TAG_global_variable (GCC) or else
	     TAG_member with no location (Diab).  We could treat the latter like
	     the former... but since we don't support the former, just avoid
	     crashing on the latter for now.  */
	  if (mbr.at_location == NULL)
	    break;

@


1.27.4.2
log
@2003-06-27  Elena Zannoni  <ezannoni@@redhat.com>

        * dwarfread.c (decode_modified_type): Gag new compiler warning.
@
text
@d3201 2
a3202 6
	  if (!(MOD_lo_user <= (unsigned char) modifier))
#if 0
/* This part of the test would always be true, and it triggers a compiler
   warning.  */
  		  && (unsigned char) modifier <= MOD_hi_user))
#endif
@


1.26
log
@2003-06-01  Andrew Cagney  <cagney@@redhat.com>

	* dwarfread.c: Eliminate "register"
	(decode_die_type): Eliminate assignment within "if".
	(struct_type, decode_array_element_type): Ditto.
	(dwarf_read_array_type, read_tag_pointer_type): Ditto.
	(read_subroutine_type, enum_type, add_enum_psymbol): Ditto.
	(decode_modified_type, completedieinfo): Ditto.
	* block.c: Eliminate "register".
	(blockvector_for_pc_sect): Eliminate assignment within "if".
	* cp-support.h (struct symbol): Opaque declaration.
	* breakpoint.c (handle_gnu_v3_exceptions): Use xfree, not free.
@
text
@a2350 1
	      sort_symtab_syms (pst->symtab);
@


1.25
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d704 1
a704 1
  register struct context_stack *new;
d865 2
a866 1
      if ((type = lookup_utype (dip->at_user_def_type)) == NULL)
d920 2
a921 1
  if ((type = lookup_utype (dip->die_ref)) == NULL)
d1154 2
a1155 1
  if ((nbytes = attribute_size (attribute)) == -1)
d1175 2
a1176 1
	  if ((typep = lookup_utype (die_ref)) == NULL)
d1341 2
a1342 1
  if ((sub = dip->at_subscr_data) != NULL)
d1349 2
a1350 1
      if ((utype = lookup_utype (dip->die_ref)) == NULL)
d1399 2
a1400 1
  if ((utype = lookup_utype (dip->die_ref)) == NULL)
d1519 2
a1520 1
  if ((ftype = lookup_utype (dip->die_ref)) == NULL)
d1634 2
a1635 1
  if ((type = lookup_utype (dip->die_ref)) == NULL)
d1655 2
a1656 1
  if ((scan = dip->at_element_list) != NULL)
d1747 1
a1747 1
  register struct context_stack *new;
d2444 2
a2445 1
  if ((scan = dip->at_element_list) != NULL)
d3158 2
a3159 1
	  if ((typep = lookup_utype (die_ref)) == NULL)
d3508 2
a3509 1
      if ((nbytes = attribute_size (attr)) == -1)
@


1.24
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d1592 1
a1592 1
   symbol for it with namespace VAR_NAMESPACE and class LOC_CONST,
d1682 1
a1682 1
	  SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d2450 1
a2450 1
	  add_psymbol_to_list (scan, strlen (scan), VAR_NAMESPACE, LOC_CONST,
d2482 1
a2482 1
			   VAR_NAMESPACE, LOC_BLOCK,
d2488 1
a2488 1
			   VAR_NAMESPACE, LOC_STATIC,
d2494 1
a2494 1
			   VAR_NAMESPACE, LOC_BLOCK,
d2500 1
a2500 1
			   VAR_NAMESPACE, LOC_STATIC,
d2506 1
a2506 1
			   VAR_NAMESPACE, LOC_TYPEDEF,
d2518 1
a2518 1
			   STRUCT_NAMESPACE, LOC_TYPEDEF,
d2525 1
a2525 1
			       VAR_NAMESPACE, LOC_TYPEDEF,
d2824 1
a2824 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d2930 1
a2930 1
	  SYMBOL_NAMESPACE (sym) = STRUCT_NAMESPACE;
d2935 1
a2935 1
	  SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d2987 1
a2987 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
@


1.24.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1592 1
a1592 1
   symbol for it with domain VAR_DOMAIN and class LOC_CONST,
d1682 1
a1682 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2450 1
a2450 1
	  add_psymbol_to_list (scan, strlen (scan), VAR_DOMAIN, LOC_CONST,
d2482 1
a2482 1
			   VAR_DOMAIN, LOC_BLOCK,
d2488 1
a2488 1
			   VAR_DOMAIN, LOC_STATIC,
d2494 1
a2494 1
			   VAR_DOMAIN, LOC_BLOCK,
d2500 1
a2500 1
			   VAR_DOMAIN, LOC_STATIC,
d2506 1
a2506 1
			   VAR_DOMAIN, LOC_TYPEDEF,
d2518 1
a2518 1
			   STRUCT_DOMAIN, LOC_TYPEDEF,
d2525 1
a2525 1
			       VAR_DOMAIN, LOC_TYPEDEF,
d2824 1
a2824 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2930 1
a2930 1
	  SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;
d2935 1
a2935 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2987 1
a2987 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
@


1.23
log
@2003-02-04  Michael Chastain  <mec@@shout.net>

	* dwarfread.c: Add documentation on the state of dwarf-1,
	looking towards obsoletion.
@
text
@d1679 1
a1679 1
	  SYMBOL_NAME (sym) = create_name (list->field.name,
d2982 1
a2982 1
      SYMBOL_NAME (sym) = create_name (dip->at_name,
@


1.22
log
@	* defs.h (streq): Add prototype.
	* utils.c (streq): New function.

	* dwarf2read.c (new_symbol): Use SYMBOL_SET_NAMES instead of
	SYMBOL_NAME and SYMBOL_INIT_DEMANGLED_NAME.
	* mdebugread.c (new_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* dwarfread.c (new_symbol): Likewise.

	* minsyms.c (prim_record_minimal_symbol_and_info): Use
	SYMBOL_SET_NAMES instead of setting SYMBOL_NAME.  Set the language
	here.
	(install_minimal_symbols): Don't set SYMBOL_LANGUAGE or call
	SYMBOL_INIT_DEMANGLED_NAME.
	* objfiles.c: Include "hashtab.h".
	(allocate_objfile): Call htab_set_functions_ex for the
	demangled_names_hash.
	(free_objfile): Call htab_delete for the demangled_names_hash.
	* objfiles.h (struct htab): Add declaration.
	(struct objfile): Add demangled_names_hash.
	* symfile.c: Include "hashtab.h".
	(reread_symbols): Call htab_delete for the demangled_names_hash.
	(add_psymbol_to_list): Use SYMBOL_SET_NAMES instead of putting
	SYMBOL_NAME in the bcache.
	* symtab.c: Include "hashtab.h".  Update comments.
	(create_demangled_names_hash, symbol_set_names): New functions.
	(symbol_find_demangled_name): New function, broken out from
	symbol_init_demangled_names.
	(symbol_init_demangled_names): Use it.
	* symtab.h (SYMBOL_INIT_DEMANGLED_NAME): Add missing parentheses.
	(SYMBOL_SET_NAMES): New macro.
	(symbol_set_names): Add prototype.
@
text
@d26 40
@


1.21
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* cris-tdep.c: Fix function declaration indentation.
	* dwarfread.c, gdbcore.h, gdbtypes.h, i386v-nat.c: Ditto.
	* mips-tdep.c, monitor.h, parse.c, proc-utils.h: Ditto.
	* rs6000-nat.c, ser-go32.c, somread.c, stabsread.c: Ditto.
	* symfile.h, symtab.h, target.c, target.h, value.h: Ditto.
	* xcoffread.c, config/pa/tm-hppa.h: Ditto.
	* config/sparc/tm-sp64.h, config/sparc/tm-sparc.h: Ditto.
@
text
@a2782 2
      SYMBOL_NAME (sym) = create_name (dip->at_name,
				       &objfile->symbol_obstack);
d2794 1
a2794 1
      SYMBOL_INIT_DEMANGLED_NAME (sym, &objfile->symbol_obstack);
@


1.20
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d373 2
a374 2
static void
read_file_scope (struct dieinfo *, char *, char *, struct objfile *);
d376 2
a377 2
static void
read_func_scope (struct dieinfo *, char *, char *, struct objfile *);
d379 2
a380 2
static void
read_lexical_block_scope (struct dieinfo *, char *, char *, struct objfile *);
d384 2
a385 2
static void
scan_compilation_units (char *, char *, file_ptr, file_ptr, struct objfile *);
d401 2
a402 2
static void
read_structure_scope (struct dieinfo *, char *, char *, struct objfile *);
d416 2
a417 2
static void
read_enumeration (struct dieinfo *, char *, char *, struct objfile *);
d444 2
a445 2
static void
synthesize_typedef (struct dieinfo *, struct objfile *, struct type *);
@


1.19
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@d363 1
a363 1
static void free_utypes (PTR);
d775 1
a775 1
   static void free_utypes (PTR dummy)
d785 1
a785 1
free_utypes (PTR dummy)
d2215 1
a2215 1
	  (bfd_bread ((PTR) lnsizedata, sizeof (lnsizedata), abfd)
@


1.18
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* valarith.c (value_binop): Delete obsolete code and comments.
	* configure.host: Ditto.
	* buildsym.h (make_blockvector): Ditto.
	* buildsym.c (make_blockvector): Ditto.
	* defs.h (enum language): Ditto.
	(chill_demangle): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* dwarfread.c (CHILL_PRODUCER): Ditto.
	(set_cu_language): Ditto.
	(handle_producer): Ditto.
	* expprint.c (print_subexp): Ditto.
	* gdbtypes.c (chill_varying_type): Ditto.
	* gdbtypes.h (builtin_type_chill_bool): Ditto.
	(builtin_type_chill_char, builtin_type_chill_long): Ditto.
	(builtin_type_chill_ulong, builtin_type_chill_real): Ditto.
	(chill_varying_type): Ditto.
	* language.h (_LANG_chill): Ditto.
	* language.c (binop_result_type, integral_type): Ditto.
	(character_type, string_type, structured_type): Ditto.
	(lang_bool_type, binop_type_check): Ditto.
	* stabsread.h (os9k_stabs): Ditto.
	* stabsread.c (os9k_type_vector, dbx_lookup_type): Ditto.
	(define_symbol, read_type, read_struct_fields): Ditto.
	(read_array_type, read_enum_type, read_huge_number): Ditto.
	(read_range_type, start_stabs): Ditto.
	* symfile.c (init_filename_language_table): Ditto.
	(add_psymbol_with_dem_name_to_list): Ditto.
	* symtab.c (symbol_init_language_specific): Ditto.
	(symbol_init_demangled_name, symbol_demangled_name): Ditto.
	* symtab.h (struct general_symbol_info): Ditto.
	(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* valops.c (value_cast, search_struct_field, value_slice): Delete
	obsolete code.
	(varying_to_slice): Delete function.
	* value.h (COERCE_VARYING_ARRAY): Delete obsolete macro contents.
	(varying_to_slice): Delete declaration.
	* MAINTAINERS: Update.
@
text
@d2 4
a5 3
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002
   Free Software Foundation, Inc.
@


1.17
log
@Replace complain() with complaint().
@
text
@a110 4
/* OBSOLETE #ifndef CHILL_PRODUCER */
/* OBSOLETE #define CHILL_PRODUCER "GNU Chill " */
/* OBSOLETE #endif */

a541 3
      /* OBSOLETE case LANG_CHILL: */
      /* OBSOLETE   cu_language = language_chill; */
      /* OBSOLETE   break; */
a1755 1
      /* OBSOLETE || STREQN (producer, CHILL_PRODUCER, strlen (CHILL_PRODUCER)); */
@


1.16
log
@	* gdbtypes.h (struct main_type): Move artificial flag out of
	loc.  New member of ``struct field'' named static_kind.  Reduce
	overloaded meaning of bitsize.
	(FIELD_ARTIFICIAL, SET_FIELD_PHYSNAME, SET_FIELD_PHYSADDR)
	(TYPE_FIELD_STATIC, TYPE_FIELD_STATIC_HAS_ADDR): Likewise.
	(FIELD_STATIC_KIND, TYPE_FIELD_STATIC_KIND): New macros.

	* ada-lang.c (fill_in_ada_prototype): Initialize static_kind for
	new fields.
	(template_to_fixed_record_type, template_to_static_fixed_type)
	(to_record_with_fixed_variant_part): Likewise.
	* coffread.c (coff_read_struct_type, coff_read_enum_type): Likewise.
	* dwarf2read.c (dwarf2_add_field, read_enumeration): Likewise.
	* dwarfread.c (struct_type, enum_type): Likewise.
	* hpread.c (hpread_read_enum_type)
	(hpread_read_function_type, hpread_read_doc_function_type)
	(hpread_read_struct_type): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
@
text
@d65 2
a66 1
struct deprecated_complaint no_bfd_get_N =
d68 4
a71 2
  "DIE @@ 0x%x \"%s\", no bfd support for %d byte data object", 0, 0
};
d73 2
a74 1
struct deprecated_complaint malformed_die =
d76 4
a79 2
  "DIE @@ 0x%x \"%s\", malformed DIE, bad length (%d bytes)", 0, 0
};
d81 2
a82 1
struct deprecated_complaint bad_die_ref =
d84 4
a87 2
  "DIE @@ 0x%x \"%s\", reference to DIE (0x%x) outside compilation unit", 0, 0
};
d89 2
a90 1
struct deprecated_complaint unknown_attribute_form =
d92 4
a95 92
  "DIE @@ 0x%x \"%s\", unknown attribute form (0x%x)", 0, 0
};

struct deprecated_complaint unknown_attribute_length =
{
  "DIE @@ 0x%x \"%s\", unknown attribute length, skipped remaining attributes", 0, 0
};

struct deprecated_complaint unexpected_fund_type =
{
  "DIE @@ 0x%x \"%s\", unexpected fundamental type 0x%x", 0, 0
};

struct deprecated_complaint unknown_type_modifier =
{
  "DIE @@ 0x%x \"%s\", unknown type modifier %u", 0, 0
};

struct deprecated_complaint volatile_ignored =
{
  "DIE @@ 0x%x \"%s\", type modifier 'volatile' ignored", 0, 0
};

struct deprecated_complaint const_ignored =
{
  "DIE @@ 0x%x \"%s\", type modifier 'const' ignored", 0, 0
};

struct deprecated_complaint botched_modified_type =
{
  "DIE @@ 0x%x \"%s\", botched modified type decoding (mtype 0x%x)", 0, 0
};

struct deprecated_complaint op_deref2 =
{
  "DIE @@ 0x%x \"%s\", OP_DEREF2 address 0x%x not handled", 0, 0
};

struct deprecated_complaint op_deref4 =
{
  "DIE @@ 0x%x \"%s\", OP_DEREF4 address 0x%x not handled", 0, 0
};

struct deprecated_complaint basereg_not_handled =
{
  "DIE @@ 0x%x \"%s\", BASEREG %d not handled", 0, 0
};

struct deprecated_complaint dup_user_type_allocation =
{
  "DIE @@ 0x%x \"%s\", internal error: duplicate user type allocation", 0, 0
};

struct deprecated_complaint dup_user_type_definition =
{
  "DIE @@ 0x%x \"%s\", internal error: duplicate user type definition", 0, 0
};

struct deprecated_complaint missing_tag =
{
  "DIE @@ 0x%x \"%s\", missing class, structure, or union tag", 0, 0
};

struct deprecated_complaint bad_array_element_type =
{
  "DIE @@ 0x%x \"%s\", bad array element type attribute 0x%x", 0, 0
};

struct deprecated_complaint subscript_data_items =
{
  "DIE @@ 0x%x \"%s\", can't decode subscript data items", 0, 0
};

struct deprecated_complaint unhandled_array_subscript_format =
{
  "DIE @@ 0x%x \"%s\", array subscript format 0x%x not handled yet", 0, 0
};

struct deprecated_complaint unknown_array_subscript_format =
{
  "DIE @@ 0x%x \"%s\", unknown array subscript format %x", 0, 0
};

struct deprecated_complaint not_row_major =
{
  "DIE @@ 0x%x \"%s\", array not row major; not handled correctly", 0, 0
};

struct deprecated_complaint missing_at_name =
{
  "DIE @@ 0x%x, AT_name tag missing", 0, 0
};
d711 1
a711 1
      complain (&bad_die_ref, DIE_ID, DIE_NAME);
d753 1
a753 1
      complain (&bad_die_ref, DIE_ID, DIE_NAME);
d758 3
a760 1
      complain (&dup_user_type_allocation, DIE_ID, DIE_NAME);
d905 3
a907 1
      complain (&missing_tag, DIE_ID, DIE_NAME);
d1120 1
a1120 1
      complain (&bad_array_element_type, DIE_ID, DIE_NAME, attribute);
d1147 1
a1147 1
	  complain (&bad_array_element_type, DIE_ID, DIE_NAME, attribute);
d1235 3
a1237 1
	  complain (&subscript_data_items, DIE_ID, DIE_NAME);
d1251 3
a1253 1
      complain (&unhandled_array_subscript_format, DIE_ID, DIE_NAME, format);
d1259 3
a1261 1
      complain (&unknown_array_subscript_format, DIE_ID, DIE_NAME, format);
d1299 3
a1301 1
      complain (&not_row_major, DIE_ID, DIE_NAME);
d1331 1
a1331 1
	  complain (&dup_user_type_definition, DIE_ID, DIE_NAME);
d1429 1
a1429 1
	  complain (&dup_user_type_definition, DIE_ID, DIE_NAME);
d1495 1
a1495 1
      complain (&dup_user_type_definition, DIE_ID, DIE_NAME);
d1711 2
a1712 1
      complain (&missing_at_name, DIE_ID);
d2146 3
a2148 1
	  complain (&op_deref2, DIE_ID, DIE_NAME, stack[stacki]);
d2151 3
a2153 1
	  complain (&op_deref4, DIE_ID, DIE_NAME, stack[stacki]);
d2603 2
a2604 2
			  complain (&bad_die_ref, DIE_ID, DIE_NAME,
				    di.at_sibling);
d3122 3
a3124 1
	  complain (&botched_modified_type, DIE_ID, DIE_NAME, mtype);
d3142 3
a3144 1
	  complain (&const_ignored, DIE_ID, DIE_NAME);	/* FIXME */
d3147 3
a3149 1
	  complain (&volatile_ignored, DIE_ID, DIE_NAME);	/* FIXME */
d3155 3
a3157 1
	      complain (&unknown_type_modifier, DIE_ID, DIE_NAME, modifier);
d3299 3
a3301 1
	  complain (&unexpected_fund_type, DIE_ID, DIE_NAME, fundtype);
d3399 3
a3401 1
      complain (&malformed_die, DIE_ID, DIE_NAME, dip->die_length);
d3467 3
a3469 1
	  complain (&unknown_attribute_length, DIE_ID, DIE_NAME);
d3626 1
a3626 1
	  complain (&unknown_attribute_form, DIE_ID, DIE_NAME, form);
d3683 3
a3685 1
      complain (&no_bfd_get_N, DIE_ID, DIE_NAME, nbytes);
d3740 1
a3740 1
      complain (&unknown_attribute_form, DIE_ID, DIE_NAME, form);
@


1.15
log
@2002-10-25  Andrew Cagney  <cagney@@redhat.com>

	* complaints.h (struct deprecated_complaint): Rename `struct
	complaint'.
	* complaints.c (complain): Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Delete
	incorrect comment indicating that "symfile.h" was being included
	for the `struct complaint' definition.
	* remote-vx.c: Update.
	* objc-lang.c: Update.
	* xcoffread.c: Update.
	* hpread.c: Update.
	* mdebugread.c: Update.
	* stabsread.c: Update.
	* dwarf2read.c: Update.
	* dwarfread.c: Update.
	* elfread.c: Update.
	* coffread.c: Update.
	* stabsread.h: Update.
	* dbxread.c: Update.
	* buildsym.c: Update.
	* gdbtypes.c: Update.
	* macrotab.c: Update.
@
text
@d1030 1
d1698 1
@


1.14
log
@2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* NEWS: Menion that CHILL has been made obsolete.

* gdbtypes.c (chill_varying_type): Make chill references obsolete.
* gdbserver/Makefile.in: Ditto.
* stabsread.c (read_range_type): Ditto.
* gdbtypes.h: Ditto.
* language.c (binop_type_check): Ditto.
(binop_result_type): Ditto.
(integral_type): Ditto.
(character_type): Ditto.
(string_type): Ditto.
(boolean_type): Ditto.
(structured_type): Ditto.
(lang_bool_type): Ditto.
(binop_type_check): Ditto.
* language.h (_LANG_chill): Ditto.
* dwarfread.c (set_cu_language): Ditto.
* dwarfread.c (CHILL_PRODUCER): Ditto.
* dwarfread.c (handle_producer): Ditto.
* expression.h (enum exp_opcode): Ditto.
* eval.c: Ditto for comments.
* typeprint.c (typedef_print) [_LANG_chill]: Ditto.
* expprint.c (print_subexp): Ditto.
(print_subexp): Ditto.
* valops.c (value_cast): Ditto.
(search_struct_field): Ditto.
* value.h (COERCE_VARYING_ARRAY): Ditto.
* symfile.c (init_filename_language_table): Ditto.
(add_psymbol_with_dem_name_to_list): Ditto.
* valarith.c (value_binop): Ditto.
(value_neg): Ditto.
* valops.c (value_slice): Ditto.
* symtab.h (union language_specific): Ditto.
(SYMBOL_INIT_LANGUAGE_SPECIFIC): Ditto.
(SYMBOL_DEMANGLED_NAME): Ditto.
(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
* defs.h (enum language): Ditto.
* symtab.c (got_symtab): Ditto.
* utils.c (fprintf_symbol_filtered): Ditto.

* ch-typeprint.c: Make file obsolete.
* ch-valprint.c: Make file obsolete.
* ch-lang.h: Make file obsolete.
* ch-exp.c: Make file obsolete.
* ch-lang.c: Make file obsolete.

* Makefile.in (FLAGS_TO_PASS): Do not pass CHILL or CHILLFLAGS or
CHILL_LIB.
(TARGET_FLAGS_TO_PASS): Ditto.
(CHILLFLAGS): Obsolete.
(CHILL): Obsolete.
(CHILL_FOR_TARGET): Obsolete.
(CHILL_LIB): Obsolete.
(SFILES): Remove ch-exp.c, ch-lang.c, ch-typeprint.c and
ch-valprint.c.
(HFILES_NO_SRCDIR): Remove ch-lang.h.
(COMMON_OBS): Remove ch-valprint.o, ch-typeprint.o, ch-exp.o and
ch-lang.o.
(ch-exp.o, ch-lang.o, ch-typeprint.o, ch-valprint.o): Delete
targets.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* stabs.texinfo, gdb.texinfo, gdbint.texinfo: Obsolete references
to CHILL.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* Makefile.in (TARGET_FLAGS_TO_PASS): Remove CHILLFLAGS, CHILL,
CHILL_FOR_TARGET and CHILL_LIB.
* configure.in (configdirs): Remove gdb.chill.
* configure: Regenerate.
* lib/gdb.exp: Obsolete references to chill.
* gdb.fortran/types.exp: Ditto.
* gdb.fortran/exprs.exp: Ditto.
@
text
@d65 1
a65 1
struct complaint no_bfd_get_N =
d70 1
a70 1
struct complaint malformed_die =
d75 1
a75 1
struct complaint bad_die_ref =
d80 1
a80 1
struct complaint unknown_attribute_form =
d85 1
a85 1
struct complaint unknown_attribute_length =
d90 1
a90 1
struct complaint unexpected_fund_type =
d95 1
a95 1
struct complaint unknown_type_modifier =
d100 1
a100 1
struct complaint volatile_ignored =
d105 1
a105 1
struct complaint const_ignored =
d110 1
a110 1
struct complaint botched_modified_type =
d115 1
a115 1
struct complaint op_deref2 =
d120 1
a120 1
struct complaint op_deref4 =
d125 1
a125 1
struct complaint basereg_not_handled =
d130 1
a130 1
struct complaint dup_user_type_allocation =
d135 1
a135 1
struct complaint dup_user_type_definition =
d140 1
a140 1
struct complaint missing_tag =
d145 1
a145 1
struct complaint bad_array_element_type =
d150 1
a150 1
struct complaint subscript_data_items =
d155 1
a155 1
struct complaint unhandled_array_subscript_format =
d160 1
a160 1
struct complaint unknown_array_subscript_format =
d165 1
a165 1
struct complaint not_row_major =
d170 1
a170 1
struct complaint missing_at_name =
@


1.14.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 3
a4 4

   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003 Free Software Foundation, Inc.

a24 58
   If you are looking for DWARF-2 support, you are in the wrong file.
   Go look in dwarf2read.c.  This file is for the original DWARF,
   also known as DWARF-1.

   DWARF-1 is slowly headed for obsoletion.

   In gcc HEAD 2003-11-29 16:28:31 UTC, no targets prefer dwarf-1.

   In gcc 3.3.2, these targets prefer dwarf-1:

     i[34567]86-sequent-ptx4*
     i[34567]86-sequent-sysv4*
     mips-sni-sysv4
     sparc-hal-solaris2*

   In gcc 3.2.2, these targets prefer dwarf-1:

     i[34567]86-dg-dgux*
     i[34567]86-sequent-ptx4*
     i[34567]86-sequent-sysv4*
     m88k-dg-dgux*
     mips-sni-sysv4
     sparc-hal-solaris2*

   In gcc 2.95.3, these targets prefer dwarf-1:

     i[34567]86-dg-dgux*
     i[34567]86-ncr-sysv4*
     i[34567]86-sequent-ptx4*
     i[34567]86-sequent-sysv4*
     i[34567]86-*-osf1*
     i[34567]86-*-sco3.2v5*
     i[34567]86-*-sysv4*
     i860-alliant-*
     i860-*-sysv4*
     m68k-atari-sysv4*
     m68k-cbm-sysv4*
     m68k-*-sysv4*
     m88k-dg-dgux*
     m88k-*-sysv4*
     mips-sni-sysv4
     mips-*-gnu*
     sh-*-elf*
     sh-*-rtemself*
     sparc-hal-solaris2*
     sparc-*-sysv4*

   Some non-gcc compilers produce dwarf-1: 

     PR gdb/1179 was from a user with Diab C++ 4.3.
     Other users have also reported using Diab compilers with dwarf-1.
     On 2003-06-09 the gdb list received a report from a user
       with Absoft ProFortran f77 which is dwarf-1.

   -- chastain 2003-12-01
*/

/*
d65 91
a155 2
static void
bad_die_ref_complaint (int arg1, const char *arg2, int arg3)
d157 2
a158 4
  complaint (&symfile_complaints,
	     "DIE @@ 0x%x \"%s\", reference to DIE (0x%x) outside compilation unit",
	     arg1, arg2, arg3);
}
d160 1
a160 2
static void
unknown_attribute_form_complaint (int arg1, const char *arg2, int arg3)
d162 2
a163 4
  complaint (&symfile_complaints,
	     "DIE @@ 0x%x \"%s\", unknown attribute form (0x%x)", arg1, arg2,
	     arg3);
}
d165 1
a165 2
static void
dup_user_type_definition_complaint (int arg1, const char *arg2)
d167 2
a168 4
  complaint (&symfile_complaints,
	     "DIE @@ 0x%x \"%s\", internal error: duplicate user type definition",
	     arg1, arg2);
}
d170 1
a170 2
static void
bad_array_element_type_complaint (int arg1, const char *arg2, int arg3)
d172 2
a173 4
  complaint (&symfile_complaints,
	     "DIE @@ 0x%x \"%s\", bad array element type attribute 0x%x", arg1,
	     arg2, arg3);
}
d189 4
d444 1
a444 1
static void free_utypes (void *);
d454 2
a455 2
static void read_file_scope (struct dieinfo *, char *, char *,
			     struct objfile *);
d457 2
a458 2
static void read_func_scope (struct dieinfo *, char *, char *,
			     struct objfile *);
d460 2
a461 2
static void read_lexical_block_scope (struct dieinfo *, char *, char *,
				      struct objfile *);
d465 2
a466 2
static void scan_compilation_units (char *, char *, file_ptr, file_ptr,
				    struct objfile *);
d482 2
a483 2
static void read_structure_scope (struct dieinfo *, char *, char *,
				  struct objfile *);
d497 2
a498 2
static void read_enumeration (struct dieinfo *, char *, char *,
			      struct objfile *);
d525 2
a526 2
static void synthesize_typedef (struct dieinfo *, struct objfile *,
				struct type *);
d624 3
d748 1
a748 1
  struct context_stack *new;
d789 1
a789 1
      bad_die_ref_complaint (DIE_ID, DIE_NAME, die_ref);
d831 1
a831 1
      bad_die_ref_complaint (DIE_ID, DIE_NAME, die_ref);
d836 1
a836 3
      complaint (&symfile_complaints,
		 "DIE @@ 0x%x \"%s\", internal error: duplicate user type allocation",
		 DIE_ID, DIE_NAME);
d857 1
a857 1
   static void free_utypes (void *dummy)
d867 1
a867 1
free_utypes (void *dummy)
d907 1
a907 2
      type = lookup_utype (dip->at_user_def_type);
      if (type == NULL)
d961 1
a961 2
  type = lookup_utype (dip->die_ref);
  if (type == NULL)
d981 1
a981 3
      complaint (&symfile_complaints,
		 "DIE @@ 0x%x \"%s\", missing class, structure, or union tag",
		 DIE_ID, DIE_NAME);
a1019 7
	  /* Static fields can be either TAG_global_variable (GCC) or else
	     TAG_member with no location (Diab).  We could treat the latter like
	     the former... but since we don't support the former, just avoid
	     crashing on the latter for now.  */
	  if (mbr.at_location == NULL)
	    break;

a1029 1
	  FIELD_STATIC_KIND (list->field) = 0;
d1191 1
a1191 2
  nbytes = attribute_size (attribute);
  if (nbytes == -1)
d1193 1
a1193 1
      bad_array_element_type_complaint (DIE_ID, DIE_NAME, attribute);
d1211 1
a1211 2
	  typep = lookup_utype (die_ref);
	  if (typep == NULL)
d1220 1
a1220 1
	  bad_array_element_type_complaint (DIE_ID, DIE_NAME, attribute);
d1308 1
a1308 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", can't decode subscript data items",
		     DIE_ID, DIE_NAME);
d1322 1
a1322 3
      complaint (&symfile_complaints,
		 "DIE @@ 0x%x \"%s\", array subscript format 0x%x not handled yet",
		 DIE_ID, DIE_NAME, format);
d1328 1
a1328 3
      complaint (&symfile_complaints,
		 "DIE @@ 0x%x \"%s\", unknown array subscript format %x", DIE_ID,
		 DIE_NAME, format);
d1366 1
a1366 3
      complaint (&symfile_complaints,
		 "DIE @@ 0x%x \"%s\", array not row major; not handled correctly",
		 DIE_ID, DIE_NAME);
d1368 1
a1368 2
  sub = dip->at_subscr_data;
  if (sub != NULL)
d1375 1
a1375 2
      utype = lookup_utype (dip->die_ref);
      if (utype == NULL)
d1396 1
a1396 1
	  dup_user_type_definition_complaint (DIE_ID, DIE_NAME);
d1424 1
a1424 2
  utype = lookup_utype (dip->die_ref);
  if (utype == NULL)
d1494 1
a1494 1
	  dup_user_type_definition_complaint (DIE_ID, DIE_NAME);
d1543 1
a1543 2
  ftype = lookup_utype (dip->die_ref);
  if (ftype == NULL)
d1560 1
a1560 1
      dup_user_type_definition_complaint (DIE_ID, DIE_NAME);
d1623 1
a1623 1
   symbol for it with domain VAR_DOMAIN and class LOC_CONST,
d1657 1
a1657 2
  type = lookup_utype (dip->die_ref);
  if (type == NULL)
d1677 1
a1677 2
  scan = dip->at_element_list;
  if (scan != NULL)
a1696 1
	  FIELD_STATIC_KIND (list->field) = 0;
d1709 1
a1709 1
	  DEPRECATED_SYMBOL_NAME (sym) = create_name (list->field.name,
d1712 1
a1712 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d1767 1
a1767 1
  struct context_stack *new;
d1775 1
a1775 2
      complaint (&symfile_complaints, "DIE @@ 0x%x, AT_name tag missing",
		 DIE_ID);
d1817 1
a1817 1
  if (DEPRECATED_STREQN (producer, GCC_PRODUCER, strlen (GCC_PRODUCER)))
d1825 2
a1826 1
	strncmp (producer, GPLUS_PRODUCER, strlen (GPLUS_PRODUCER)) == 0;
d1836 1
a1836 1
      if (DEPRECATED_STREQN (producer, GPLUS_PRODUCER, strlen (GPLUS_PRODUCER)))
d1844 1
a1844 1
      else if (DEPRECATED_STREQN (producer, LCC_PRODUCER, strlen (LCC_PRODUCER)))
d1884 2
a1885 2
      objfile->ei.deprecated_entry_file_lowpc = dip->at_low_pc;
      objfile->ei.deprecated_entry_file_highpc = dip->at_high_pc;
d2209 1
a2209 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", OP_DEREF2 address 0x%lx not handled",
		     DIE_ID, DIE_NAME, stack[stacki]);
d2212 1
a2212 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", OP_DEREF4 address 0x%lx not handled",
		     DIE_ID, DIE_NAME, stack[stacki]);
d2281 1
a2281 1
	  (bfd_bread (lnsizedata, sizeof (lnsizedata), abfd)
d2367 1
d2460 1
a2460 2
  scan = dip->at_element_list;
  if (scan != NULL)
d2476 1
a2476 1
	  add_psymbol_to_list (scan, strlen (scan), VAR_DOMAIN, LOC_CONST,
d2508 1
a2508 1
			   VAR_DOMAIN, LOC_BLOCK,
d2514 1
a2514 1
			   VAR_DOMAIN, LOC_STATIC,
d2520 1
a2520 1
			   VAR_DOMAIN, LOC_BLOCK,
d2526 1
a2526 1
			   VAR_DOMAIN, LOC_STATIC,
d2532 1
a2532 1
			   VAR_DOMAIN, LOC_TYPEDEF,
d2544 1
a2544 1
			   STRUCT_DOMAIN, LOC_TYPEDEF,
d2551 1
a2551 1
			       VAR_DOMAIN, LOC_TYPEDEF,
d2662 2
a2663 2
			  bad_die_ref_complaint (DIE_ID, DIE_NAME,
						 di.at_sibling);
d2849 2
d2852 1
a2852 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2862 1
a2862 1
      SYMBOL_SET_NAMES (sym, dip->at_name, strlen (dip->at_name), objfile);
d2958 1
a2958 1
	  SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;
d2963 1
a2963 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d3010 1
a3010 1
      DEPRECATED_SYMBOL_NAME (sym) = create_name (dip->at_name,
d3015 1
a3015 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d3175 1
a3175 2
	  typep = lookup_utype (die_ref);
	  if (typep == NULL)
d3181 1
a3181 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", botched modified type decoding (mtype 0x%x)",
		     DIE_ID, DIE_NAME, mtype);
d3199 1
a3199 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", type modifier 'const' ignored", DIE_ID,
		     DIE_NAME);	/* FIXME */
d3202 1
a3202 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", type modifier 'volatile' ignored",
		     DIE_ID, DIE_NAME);	/* FIXME */
d3205 1
a3205 4
	  if (!(MOD_lo_user <= (unsigned char) modifier))
#if 0
/* This part of the test would always be true, and it triggers a compiler
   warning.  */
a3206 1
#endif
d3208 1
a3208 3
	      complaint (&symfile_complaints,
			 "DIE @@ 0x%x \"%s\", unknown type modifier %u", DIE_ID,
			 DIE_NAME, modifier);
d3350 1
a3350 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", unexpected fundamental type 0x%x",
		     DIE_ID, DIE_NAME, fundtype);
d3448 1
a3448 3
      complaint (&symfile_complaints,
		 "DIE @@ 0x%x \"%s\", malformed DIE, bad length (%ld bytes)",
		 DIE_ID, DIE_NAME, dip->die_length);
d3512 1
a3512 2
      nbytes = attribute_size (attr);
      if (nbytes == -1)
d3514 1
a3514 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", unknown attribute length, skipped remaining attributes",
		     DIE_ID, DIE_NAME);
d3671 1
a3671 1
	  unknown_attribute_form_complaint (DIE_ID, DIE_NAME, form);
d3728 1
a3728 3
      complaint (&symfile_complaints,
		 "DIE @@ 0x%x \"%s\", no bfd support for %d byte data object",
		 DIE_ID, DIE_NAME, nbytes);
d3783 1
a3783 1
      unknown_attribute_form_complaint (DIE_ID, DIE_NAME, form);
@


1.14.10.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d971 1
a971 1
      TYPE_TAG_NAME (type) = obconcat (&objfile->objfile_obstack,
d1014 1
a1014 1
			  &objfile->objfile_obstack);
d1673 1
a1673 1
      TYPE_TAG_NAME (type) = obconcat (&objfile->objfile_obstack,
d1707 1
a1707 1
					   &objfile->objfile_obstack);
d1711 1
a1711 1
	  sym = (struct symbol *) obstack_alloc (&objfile->objfile_obstack,
d1715 1
a1715 1
					   &objfile->objfile_obstack);
d1736 1
a1736 1
	    obstack_alloc (&objfile->objfile_obstack, sizeof (struct field) * nfields);
d2803 1
a2803 1
	    obstack_alloc (&objfile->objfile_obstack,
d2854 1
a2854 1
      sym = (struct symbol *) obstack_alloc (&objfile->objfile_obstack,
d3014 1
a3014 1
	obstack_alloc (&objfile->objfile_obstack, sizeof (struct symbol));
d3018 1
a3018 1
				       &objfile->objfile_obstack);
@


1.14.8.1
log
@2002-09-18  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h: Delete BLOCK_SHOULD_SORT.
	* symtab.c (lookup_block_symbol): Assume non-hashed blocks aren't
	sorted.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.h: Delete prototypes for sort_block_syms and
	sort_symtab_syms.
	* symfile.c: Delete functions sort_block_syms and
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Remove call to
	sort_symtab_syms.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.

2002-09-20  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (c-lang.o): Correct dependencies.
	(utils.o): Gather dependencies.
	(charset.o): Move.
@
text
@d2367 1
@


1.14.8.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d65 1
a65 1
struct deprecated_complaint no_bfd_get_N =
d70 1
a70 1
struct deprecated_complaint malformed_die =
d75 1
a75 1
struct deprecated_complaint bad_die_ref =
d80 1
a80 1
struct deprecated_complaint unknown_attribute_form =
d85 1
a85 1
struct deprecated_complaint unknown_attribute_length =
d90 1
a90 1
struct deprecated_complaint unexpected_fund_type =
d95 1
a95 1
struct deprecated_complaint unknown_type_modifier =
d100 1
a100 1
struct deprecated_complaint volatile_ignored =
d105 1
a105 1
struct deprecated_complaint const_ignored =
d110 1
a110 1
struct deprecated_complaint botched_modified_type =
d115 1
a115 1
struct deprecated_complaint op_deref2 =
d120 1
a120 1
struct deprecated_complaint op_deref4 =
d125 1
a125 1
struct deprecated_complaint basereg_not_handled =
d130 1
a130 1
struct deprecated_complaint dup_user_type_allocation =
d135 1
a135 1
struct deprecated_complaint dup_user_type_definition =
d140 1
a140 1
struct deprecated_complaint missing_tag =
d145 1
a145 1
struct deprecated_complaint bad_array_element_type =
d150 1
a150 1
struct deprecated_complaint subscript_data_items =
d155 1
a155 1
struct deprecated_complaint unhandled_array_subscript_format =
d160 1
a160 1
struct deprecated_complaint unknown_array_subscript_format =
d165 1
a165 1
struct deprecated_complaint not_row_major =
d170 1
a170 1
struct deprecated_complaint missing_at_name =
a1029 1
	  FIELD_STATIC_KIND (list->field) = 0;
a1696 1
	  FIELD_STATIC_KIND (list->field) = 0;
@


1.14.8.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d65 91
a155 2
static void
bad_die_ref_complaint (int arg1, const char *arg2, int arg3)
d157 2
a158 4
  complaint (&symfile_complaints,
	     "DIE @@ 0x%x \"%s\", reference to DIE (0x%x) outside compilation unit",
	     arg1, arg2, arg3);
}
d160 1
a160 2
static void
unknown_attribute_form_complaint (int arg1, const char *arg2, int arg3)
d162 2
a163 4
  complaint (&symfile_complaints,
	     "DIE @@ 0x%x \"%s\", unknown attribute form (0x%x)", arg1, arg2,
	     arg3);
}
d165 1
a165 2
static void
dup_user_type_definition_complaint (int arg1, const char *arg2)
d167 2
a168 4
  complaint (&symfile_complaints,
	     "DIE @@ 0x%x \"%s\", internal error: duplicate user type definition",
	     arg1, arg2);
}
d170 1
a170 2
static void
bad_array_element_type_complaint (int arg1, const char *arg2, int arg3)
d172 2
a173 4
  complaint (&symfile_complaints,
	     "DIE @@ 0x%x \"%s\", bad array element type attribute 0x%x", arg1,
	     arg2, arg3);
}
d789 1
a789 1
      bad_die_ref_complaint (DIE_ID, DIE_NAME, die_ref);
d831 1
a831 1
      bad_die_ref_complaint (DIE_ID, DIE_NAME, die_ref);
d836 1
a836 3
      complaint (&symfile_complaints,
		 "DIE @@ 0x%x \"%s\", internal error: duplicate user type allocation",
		 DIE_ID, DIE_NAME);
d981 1
a981 3
      complaint (&symfile_complaints,
		 "DIE @@ 0x%x \"%s\", missing class, structure, or union tag",
		 DIE_ID, DIE_NAME);
d1194 1
a1194 1
      bad_array_element_type_complaint (DIE_ID, DIE_NAME, attribute);
d1221 1
a1221 1
	  bad_array_element_type_complaint (DIE_ID, DIE_NAME, attribute);
d1309 1
a1309 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", can't decode subscript data items",
		     DIE_ID, DIE_NAME);
d1323 1
a1323 3
      complaint (&symfile_complaints,
		 "DIE @@ 0x%x \"%s\", array subscript format 0x%x not handled yet",
		 DIE_ID, DIE_NAME, format);
d1329 1
a1329 3
      complaint (&symfile_complaints,
		 "DIE @@ 0x%x \"%s\", unknown array subscript format %x", DIE_ID,
		 DIE_NAME, format);
d1367 1
a1367 3
      complaint (&symfile_complaints,
		 "DIE @@ 0x%x \"%s\", array not row major; not handled correctly",
		 DIE_ID, DIE_NAME);
d1397 1
a1397 1
	  dup_user_type_definition_complaint (DIE_ID, DIE_NAME);
d1495 1
a1495 1
	  dup_user_type_definition_complaint (DIE_ID, DIE_NAME);
d1561 1
a1561 1
      dup_user_type_definition_complaint (DIE_ID, DIE_NAME);
d1777 1
a1777 2
      complaint (&symfile_complaints, "DIE @@ 0x%x, AT_name tag missing",
		 DIE_ID);
d2211 1
a2211 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", OP_DEREF2 address 0x%lx not handled",
		     DIE_ID, DIE_NAME, stack[stacki]);
d2214 1
a2214 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", OP_DEREF4 address 0x%lx not handled",
		     DIE_ID, DIE_NAME, stack[stacki]);
d2663 2
a2664 2
			  bad_die_ref_complaint (DIE_ID, DIE_NAME,
						 di.at_sibling);
d3182 1
a3182 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", botched modified type decoding (mtype 0x%x)",
		     DIE_ID, DIE_NAME, mtype);
d3200 1
a3200 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", type modifier 'const' ignored", DIE_ID,
		     DIE_NAME);	/* FIXME */
d3203 1
a3203 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", type modifier 'volatile' ignored",
		     DIE_ID, DIE_NAME);	/* FIXME */
d3209 1
a3209 3
	      complaint (&symfile_complaints,
			 "DIE @@ 0x%x \"%s\", unknown type modifier %u", DIE_ID,
			 DIE_NAME, modifier);
d3351 1
a3351 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", unexpected fundamental type 0x%x",
		     DIE_ID, DIE_NAME, fundtype);
d3449 1
a3449 3
      complaint (&symfile_complaints,
		 "DIE @@ 0x%x \"%s\", malformed DIE, bad length (%ld bytes)",
		 DIE_ID, DIE_NAME, dip->die_length);
d3515 1
a3515 3
	  complaint (&symfile_complaints,
		     "DIE @@ 0x%x \"%s\", unknown attribute length, skipped remaining attributes",
		     DIE_ID, DIE_NAME);
d3672 1
a3672 1
	  unknown_attribute_form_complaint (DIE_ID, DIE_NAME, form);
d3729 1
a3729 3
      complaint (&symfile_complaints,
		 "DIE @@ 0x%x \"%s\", no bfd support for %d byte data object",
		 DIE_ID, DIE_NAME, nbytes);
d3784 1
a3784 1
      unknown_attribute_form_complaint (DIE_ID, DIE_NAME, form);
@


1.14.8.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 3
a4 4

   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003 Free Software Foundation, Inc.

a24 40
   If you are looking for DWARF-2 support, you are in the wrong file.
   Go look in dwarf2read.c.  This file is for the original DWARF.

   DWARF (also known as DWARF-1) is headed for obsoletion.

   In gcc 3.2.1, these targets prefer dwarf-1:

     i[34567]86-sequent-ptx4*   # TD-R2
     i[34567]86-sequent-sysv4*  # TD-R2
     i[34567]86-dg-dgux*        # obsolete in gcc 3.2.1, to be removed in 3.3
     m88k-dg-dgux*              # TD-R2
     mips-sni-sysv4             # TD-R2
     sparc-hal-solaris2*        # TD-R2

    Configurations marked with "# TD-R2" are on Zach Weinberg's list
    of "Target Deprecation, Round 2".  This is a candidate list of
    targets to be deprecated in gcc 3.3 and removed in gcc 3.4.

      http://gcc.gnu.org/ml/gcc/2002-12/msg00702.html

    gcc 2.95.3 had many configurations which prefer dwarf-1.
    We may have to support dwarf-1 as long as we support gcc 2.95.3.
    This could use more analysis.

    DG/UX (Data General Unix) used dwarf-1 for its native format.
    DG/UX uses gcc for its system C compiler, but they have their
    own linker and their own debuggers.

    Takis Psarogiannakopoulos has a complete gnu toolchain for DG/UX
    with gcc 2.95.3, gdb 5.1, and debug formats of dwarf-2 and stabs.
    For more info, see PR gdb/979 and PR gdb/1013; also:

      http://sources.redhat.com/ml/gdb/2003-02/msg00074.html

    There may be non-gcc compilers that still emit dwarf-1.

    -- chastain 2003-02-04
*/

/*
d111 4
d366 1
a366 1
static void free_utypes (void *);
d376 2
a377 2
static void read_file_scope (struct dieinfo *, char *, char *,
			     struct objfile *);
d379 2
a380 2
static void read_func_scope (struct dieinfo *, char *, char *,
			     struct objfile *);
d382 2
a383 2
static void read_lexical_block_scope (struct dieinfo *, char *, char *,
				      struct objfile *);
d387 2
a388 2
static void scan_compilation_units (char *, char *, file_ptr, file_ptr,
				    struct objfile *);
d404 2
a405 2
static void read_structure_scope (struct dieinfo *, char *, char *,
				  struct objfile *);
d419 2
a420 2
static void read_enumeration (struct dieinfo *, char *, char *,
			      struct objfile *);
d447 2
a448 2
static void synthesize_typedef (struct dieinfo *, struct objfile *,
				struct type *);
d546 3
d781 1
a781 1
   static void free_utypes (void *dummy)
d791 1
a791 1
free_utypes (void *dummy)
d1763 1
d2222 1
a2222 1
	  (bfd_bread (lnsizedata, sizeof (lnsizedata), abfd)
d2789 2
d2802 1
a2802 1
      SYMBOL_SET_NAMES (sym, dip->at_name, strlen (dip->at_name), objfile);
@


1.14.8.5
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d1679 1
a1679 1
	  DEPRECATED_SYMBOL_NAME (sym) = create_name (list->field.name,
d2981 1
a2981 1
      DEPRECATED_SYMBOL_NAME (sym) = create_name (dip->at_name,
@


1.14.8.6
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1592 1
a1592 1
   symbol for it with domain VAR_DOMAIN and class LOC_CONST,
d1682 1
a1682 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2449 1
a2449 1
	  add_psymbol_to_list (scan, strlen (scan), VAR_DOMAIN, LOC_CONST,
d2481 1
a2481 1
			   VAR_DOMAIN, LOC_BLOCK,
d2487 1
a2487 1
			   VAR_DOMAIN, LOC_STATIC,
d2493 1
a2493 1
			   VAR_DOMAIN, LOC_BLOCK,
d2499 1
a2499 1
			   VAR_DOMAIN, LOC_STATIC,
d2505 1
a2505 1
			   VAR_DOMAIN, LOC_TYPEDEF,
d2517 1
a2517 1
			   STRUCT_DOMAIN, LOC_TYPEDEF,
d2524 1
a2524 1
			       VAR_DOMAIN, LOC_TYPEDEF,
d2823 1
a2823 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2929 1
a2929 1
	  SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;
d2934 1
a2934 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d2986 1
a2986 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
@


1.14.8.7
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d704 1
a704 1
  struct context_stack *new;
d865 1
a865 2
      type = lookup_utype (dip->at_user_def_type);
      if (type == NULL)
d919 1
a919 2
  type = lookup_utype (dip->die_ref);
  if (type == NULL)
a979 7
	  /* Static fields can be either TAG_global_variable (GCC) or else
	     TAG_member with no location (Diab).  We could treat the latter like
	     the former... but since we don't support the former, just avoid
	     crashing on the latter for now.  */
	  if (mbr.at_location == NULL)
	    break;

d1152 1
a1152 2
  nbytes = attribute_size (attribute);
  if (nbytes == -1)
d1172 1
a1172 2
	  typep = lookup_utype (die_ref);
	  if (typep == NULL)
d1337 1
a1337 2
  sub = dip->at_subscr_data;
  if (sub != NULL)
d1344 1
a1344 2
      utype = lookup_utype (dip->die_ref);
      if (utype == NULL)
d1393 1
a1393 2
  utype = lookup_utype (dip->die_ref);
  if (utype == NULL)
d1512 1
a1512 2
  ftype = lookup_utype (dip->die_ref);
  if (ftype == NULL)
d1626 1
a1626 2
  type = lookup_utype (dip->die_ref);
  if (type == NULL)
d1646 1
a1646 2
  scan = dip->at_element_list;
  if (scan != NULL)
d1737 1
a1737 1
  struct context_stack *new;
d2433 1
a2433 2
  scan = dip->at_element_list;
  if (scan != NULL)
d3146 1
a3146 2
	  typep = lookup_utype (die_ref);
	  if (typep == NULL)
d3182 1
a3182 4
	  if (!(MOD_lo_user <= (unsigned char) modifier))
#if 0
/* This part of the test would always be true, and it triggers a compiler
   warning.  */
a3183 1
#endif
d3495 1
a3495 2
      nbytes = attribute_size (attr);
      if (nbytes == -1)
@


1.14.8.8
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d1871 2
a1872 2
      objfile->ei.deprecated_entry_file_lowpc = dip->at_low_pc;
      objfile->ei.deprecated_entry_file_highpc = dip->at_high_pc;
@


1.14.8.9
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1813 1
a1813 1
	strncmp (producer, GPLUS_PRODUCER, strlen (GPLUS_PRODUCER)) == 0;
@


1.14.8.10
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d27 1
a27 2
   Go look in dwarf2read.c.  This file is for the original DWARF,
   also known as DWARF-1.
d29 1
a29 1
   DWARF-1 is slowly headed for obsoletion.
d31 1
a31 1
   In gcc HEAD 2003-11-29 16:28:31 UTC, no targets prefer dwarf-1.
d33 6
a38 1
   In gcc 3.3.2, these targets prefer dwarf-1:
d40 3
a42 43
     i[34567]86-sequent-ptx4*
     i[34567]86-sequent-sysv4*
     mips-sni-sysv4
     sparc-hal-solaris2*

   In gcc 3.2.2, these targets prefer dwarf-1:

     i[34567]86-dg-dgux*
     i[34567]86-sequent-ptx4*
     i[34567]86-sequent-sysv4*
     m88k-dg-dgux*
     mips-sni-sysv4
     sparc-hal-solaris2*

   In gcc 2.95.3, these targets prefer dwarf-1:

     i[34567]86-dg-dgux*
     i[34567]86-ncr-sysv4*
     i[34567]86-sequent-ptx4*
     i[34567]86-sequent-sysv4*
     i[34567]86-*-osf1*
     i[34567]86-*-sco3.2v5*
     i[34567]86-*-sysv4*
     i860-alliant-*
     i860-*-sysv4*
     m68k-atari-sysv4*
     m68k-cbm-sysv4*
     m68k-*-sysv4*
     m88k-dg-dgux*
     m88k-*-sysv4*
     mips-sni-sysv4
     mips-*-gnu*
     sh-*-elf*
     sh-*-rtemself*
     sparc-hal-solaris2*
     sparc-*-sysv4*

   Some non-gcc compilers produce dwarf-1: 

     PR gdb/1179 was from a user with Diab C++ 4.3.
     Other users have also reported using Diab compilers with dwarf-1.
     On 2003-06-09 the gdb list received a report from a user
       with Absoft ProFortran f77 which is dwarf-1.
d44 19
a62 1
   -- chastain 2003-12-01
d1805 1
a1805 1
  if (DEPRECATED_STREQN (producer, GCC_PRODUCER, strlen (GCC_PRODUCER)))
d1823 1
a1823 1
      if (DEPRECATED_STREQN (producer, GPLUS_PRODUCER, strlen (GPLUS_PRODUCER)))
d1831 1
a1831 1
      else if (DEPRECATED_STREQN (producer, LCC_PRODUCER, strlen (LCC_PRODUCER)))
@


1.13
log
@* gdbarch.sh (copyright): Update years in generated header.
(SMASH_TEXT_ADDRESS): Add rule.
*gdbarch.h, gdbarch.c: Re-generate.
* coffread.c: Multi-arch uses of SMASH_TEXT_ADDRESS.
* dbxread.c: Likewise.
* dwarfread.c: Likewise.
* elfread.c: Likewise.
* somread.c: Likewise.

* arm-tdep.c (arm_smash_text_address): New function.
* config/arm/tm-arm.h (SMASH_TEXT_ADDRESS): Define in terms of above.
@
text
@d189 3
a191 3
#ifndef CHILL_PRODUCER
#define CHILL_PRODUCER "GNU Chill "
#endif
d624 3
a626 3
    case LANG_CHILL:
      cu_language = language_chill;
      break;
d1825 2
a1826 2
	STREQN (producer, GPLUS_PRODUCER, strlen (GPLUS_PRODUCER))
	|| STREQN (producer, CHILL_PRODUCER, strlen (CHILL_PRODUCER));
@


1.13.8.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d189 3
a191 3
/* OBSOLETE #ifndef CHILL_PRODUCER */
/* OBSOLETE #define CHILL_PRODUCER "GNU Chill " */
/* OBSOLETE #endif */
d624 3
a626 3
      /* OBSOLETE case LANG_CHILL: */
      /* OBSOLETE   cu_language = language_chill; */
      /* OBSOLETE   break; */
d1825 2
a1826 2
	STREQN (producer, GPLUS_PRODUCER, strlen (GPLUS_PRODUCER));
      /* OBSOLETE || STREQN (producer, CHILL_PRODUCER, strlen (CHILL_PRODUCER)); */
@


1.13.8.2
log
@merge from mainline
@
text
@d65 1
a65 1
struct deprecated_complaint no_bfd_get_N =
d70 1
a70 1
struct deprecated_complaint malformed_die =
d75 1
a75 1
struct deprecated_complaint bad_die_ref =
d80 1
a80 1
struct deprecated_complaint unknown_attribute_form =
d85 1
a85 1
struct deprecated_complaint unknown_attribute_length =
d90 1
a90 1
struct deprecated_complaint unexpected_fund_type =
d95 1
a95 1
struct deprecated_complaint unknown_type_modifier =
d100 1
a100 1
struct deprecated_complaint volatile_ignored =
d105 1
a105 1
struct deprecated_complaint const_ignored =
d110 1
a110 1
struct deprecated_complaint botched_modified_type =
d115 1
a115 1
struct deprecated_complaint op_deref2 =
d120 1
a120 1
struct deprecated_complaint op_deref4 =
d125 1
a125 1
struct deprecated_complaint basereg_not_handled =
d130 1
a130 1
struct deprecated_complaint dup_user_type_allocation =
d135 1
a135 1
struct deprecated_complaint dup_user_type_definition =
d140 1
a140 1
struct deprecated_complaint missing_tag =
d145 1
a145 1
struct deprecated_complaint bad_array_element_type =
d150 1
a150 1
struct deprecated_complaint subscript_data_items =
d155 1
a155 1
struct deprecated_complaint unhandled_array_subscript_format =
d160 1
a160 1
struct deprecated_complaint unknown_array_subscript_format =
d165 1
a165 1
struct deprecated_complaint not_row_major =
d170 1
a170 1
struct deprecated_complaint missing_at_name =
@


1.12
log
@* language.h (type_error, range_error): Make string parameter
constant.
* language.c (warning_pre_print): Delete extern declaration.
* dwarfread.c (warning_pre_print): Ditto.
* language.c (type_error, range_error): Rewrite to use verror and
vwarning instead of warning_begin.
@
text
@d3 1
a3 1
   2001
a1954 1
#ifdef SMASH_TEXT_ADDRESS
d1956 2
a1957 3
	  SMASH_TEXT_ADDRESS (di.at_low_pc);
	  SMASH_TEXT_ADDRESS (di.at_high_pc);
#endif
@


1.11
log
@Approved by Jim Blandy:

	2001-12-11  Fred Fish  <fnf@@redhat.com>
	* c-typeprint.c (c_type_print_base): Use type flags access macros
	to test bits.
	* ch-typeprint.c (chill_type_print_base): Ditto.
	* ch-valprint.c (chill_val_print): Ditto.
	* d10v-tdep.c (d10v_pointer_to_address): Ditto.
	* dwarf2read.c (dwarf2_add_member_fn): Ditto.
	* dwarfread.c (read_structure_scope): Ditto.
	* gdbtypes.c (create_range_type): Dittol
	(create_set_type): Ditto.
	(check_typedef): Ditto.
	* jv-typeprint.c (java_type_print_base): Ditto.
	* p-typeprint.c (pascal_type_print_base): Ditto
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (read_cfront_member_functions): Ditto.
	(read_member_functions): Ditto.
	(cleanup_undefined_types): Ditto.
	* valprint.c (val_print): Ditto.
	* valops.c (hand_function_call): Remove is_prototyped
	variable and just use type flag test macro directly.
@
text
@a241 4
/* External variables referenced. */

extern char *warning_pre_print;	/* From utils.c */

@


1.10
log
@	2001-11-06  Fred Fish  <fnf@@redhat.com>
	* complaints.c (info_verbose): Remove unneeded decl, is in defs.h.
	* dbxread.c: Ditto
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* exec.c: Ditto.
	* hpread.c: Ditto.
	* hpread.h: Ditto.
	* mdebugread.c: Ditto.
	* os9kread.c: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* tracepoint.c: Ditto.
@
text
@d1150 1
a1150 1
  if (!(TYPE_FLAGS (type) & TYPE_FLAG_STUB))
@


1.9
log
@	* coffread.c: Replace all occurrences of bfd_read with bfd_bread.
	* dbxread.c: Likewise.
	* dwarf2read.c: Likewise.
	* dwarfread.c: Likewise.
	* somread.c: Likewise.
	* ultra3-nat.c: Likewise.
	* xcoffread.c: Likewise.
@
text
@a243 1
extern int info_verbose;	/* From main.c; nonzero => verbose */
@


1.8
log
@2001-09-04  Elena Zannoni  <ezannoni@@redhat.com>

	From Daniel Jacobowitz  <drow@@mvista.com>
	* dbxread.c (dbx_symfile_read): Only reinitialize
	the psymbol list if mainline or if both static
	and global lists are empty.
	* dwarf2read.c (dwarf2_build_psymtabs): Likewise.
	* dwarfread.c (dwarf_build_psymtabs): Likewise.
	* xcoffread.c (xcoff_initial_scan): Likewise.
	* os9kread.c (os9k_symfile_read): Likewise.
@
text
@d698 1
a698 1
      (bfd_read (dbbase, dbsize, 1, abfd) != dbsize))
d2272 1
a2272 1
      (bfd_read (dbbase, dbsize, 1, abfd) != dbsize))
d2288 2
a2289 2
	  (bfd_read ((PTR) lnsizedata, sizeof (lnsizedata), 1, abfd) !=
	   sizeof (lnsizedata)))
d2297 1
a2297 1
	  (bfd_read (lnbase, lnsize, 1, abfd) != lnsize))
@


1.7
log
@Update/correct copyright notices.
@
text
@d709 3
a711 2
  if (mainline || objfile->global_psymbols.size == 0 ||
      objfile->static_psymbols.size == 0)
@


1.7.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d1283 1
a1283 1
  struct range_type *rangetype;
d1315 1
a1315 1
      rangetype = make_range_type (current_objfile, indextype,
d1317 1
a1317 1
      typep = (struct type *) make_array_type (current_objfile, nexttype, rangetype);
d1328 2
a1329 2
      rangetype = make_range_type (current_objfile, nexttype, 0, 0);
      typep = (struct type *)make_array_type (current_objfile,  nexttype, rangetype);
d1334 2
a1335 2
      rangetype = make_range_type (current_objfile, nexttype, 0, 0);
      typep = (struct type *)make_array_type (current_objfile, nexttype, rangetype);
d1435 1
a1435 1
      POINTER_TARGET_TYPE (utype) = type;
d1468 1
a1468 1
  struct range_type *rangetype;
d1483 1
a1483 1
  rangetype = make_range_type (current_objfile, indextype, lowbound,
d1504 1
a1504 1
  utype = (struct type *)make_string_type (current_objfile, rangetype);
d1551 1
a1551 1
      ftype = (struct type *)make_function_type (current_objfile, type, 0, NULL, 0);
a1555 1
#if TYPEFIX
a1560 1
#endif
a1730 1
#if TYPEFIX
a1732 1
#endif
d2878 1
a2878 1
	  SYMBOL_TYPE (sym) =  (struct type *)make_function_type (objfile, SYMBOL_TYPE (sym), 0, NULL, 0);
@


1.6
log
@        * dbxread.c (read_ofile_symtab): Stay with AUTO_DEMANGLING for G++.
        (process_one_symbol): Likewise.
        * dwarfread.c (handle_producer): Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998
@


1.5
log
@Replace free() with xfree().
@
text
@d1841 3
d1845 1
@


1.4
log
@Multiarch STAB_REG_TO_REGNUM, ECOFF_REG_TO_REGNUM,
DWARF_REG_TO_REGNUM, SDB_REG_TO_REGNUM, DWARF2_REG_TO_REGNUM.
@
text
@d699 1
a699 1
      free (dbbase);
d702 1
a702 1
  back_to = make_cleanup (free, dbbase);
d872 1
a872 1
  free (utypes);
d2268 1
a2268 1
      free (dbbase);
d2271 1
a2271 1
  back_to = make_cleanup (free, dbbase);
d2293 1
a2293 1
	  free (lnbase);
d2296 1
a2296 1
      make_cleanup (free, lnbase);
@


1.3
log
@Protoization.
@
text
@a191 5
/* Provide a default mapping from a DWARF register number to a gdb REGNUM.  */
#ifndef DWARF_REG_TO_REGNUM
#define DWARF_REG_TO_REGNUM(num) (num)
#endif

@


1.2
log
@PARAMS removal.
@
text
@d579 1
a579 3
dwarf_fundamental_type (objfile, typeid)
     struct objfile *objfile;
     int typeid;
d622 1
a622 2
set_cu_language (dip)
     struct dieinfo *dip;
d690 3
a692 8
dwarf_build_psymtabs (objfile, mainline, dbfoff, dbfsize,
		      lnoffset, lnsize)
     struct objfile *objfile;
     int mainline;
     file_ptr dbfoff;
     unsigned int dbfsize;
     file_ptr lnoffset;
     unsigned int lnsize;
d753 2
a754 5
read_lexical_block_scope (dip, thisdie, enddie, objfile)
     struct dieinfo *dip;
     char *thisdie;
     char *enddie;
     struct objfile *objfile;
d789 1
a789 2
lookup_utype (die_ref)
     DIE_REF die_ref;
d829 1
a829 3
alloc_utype (die_ref, utypep)
     DIE_REF die_ref;
     struct type *utypep;
d875 1
a875 2
free_utypes (dummy)
     PTR dummy;
d901 1
a901 2
decode_die_type (dip)
     struct dieinfo *dip;
d952 2
a953 5
struct_type (dip, thisdie, enddie, objfile)
     struct dieinfo *dip;
     char *thisdie;
     char *enddie;
     struct objfile *objfile;
d1147 2
a1148 5
read_structure_scope (dip, thisdie, enddie, objfile)
     struct dieinfo *dip;
     char *thisdie;
     char *enddie;
     struct objfile *objfile;
d1188 1
a1188 2
decode_array_element_type (scan)
     char *scan;
d1282 1
a1282 3
decode_subscript_data_item (scan, end)
     char *scan;
     char *end;
d1362 1
a1362 2
dwarf_read_array_type (dip)
     struct dieinfo *dip;
d1426 1
a1426 2
read_tag_pointer_type (dip)
     struct dieinfo *dip;
d1468 1
a1468 2
read_tag_string_type (dip)
     struct dieinfo *dip;
d1539 1
a1539 4
read_subroutine_type (dip, thisdie, enddie)
     struct dieinfo *dip;
     char *thisdie;
     char *enddie;
d1596 2
a1597 5
read_enumeration (dip, thisdie, enddie, objfile)
     struct dieinfo *dip;
     char *thisdie;
     char *enddie;
     struct objfile *objfile;
d1646 1
a1646 3
enum_type (dip, objfile)
     struct dieinfo *dip;
     struct objfile *objfile;
d1772 2
a1773 5
read_func_scope (dip, thisdie, enddie, objfile)
     struct dieinfo *dip;
     char *thisdie;
     char *enddie;
     struct objfile *objfile;
d1819 1
a1819 2
handle_producer (producer)
     char *producer;
d1879 2
a1880 5
read_file_scope (dip, thisdie, enddie, objfile)
     struct dieinfo *dip;
     char *thisdie;
     char *enddie;
     struct objfile *objfile;
d1932 1
a1932 4
process_dies (thisdie, enddie, objfile)
     char *thisdie;
     char *enddie;
     struct objfile *objfile;
d2075 1
a2075 2
decode_line_numbers (linetable)
     char *linetable;
d2148 1
a2148 2
locval (dip)
     struct dieinfo *dip;
d2249 1
a2249 2
read_ofile_symtab (pst)
     struct partial_symtab *pst;
d2328 1
a2328 2
psymtab_to_symtab_1 (pst)
     struct partial_symtab *pst;
d2400 1
a2400 2
dwarf_psymtab_to_symtab (pst)
     struct partial_symtab *pst;
d2459 1
a2459 3
add_enum_psymbol (dip, objfile)
     struct dieinfo *dip;
     struct objfile *objfile;
d2508 1
a2508 3
add_partial_symbol (dip, objfile)
     struct dieinfo *dip;
     struct objfile *objfile;
d2633 1
a2633 4
scan_partial_symbols (thisdie, enddie, objfile)
     char *thisdie;
     char *enddie;
     struct objfile *objfile;
d2754 2
a2755 6
scan_compilation_units (thisdie, enddie, dbfoff, lnoffset, objfile)
     char *thisdie;
     char *enddie;
     file_ptr dbfoff;
     file_ptr lnoffset;
     struct objfile *objfile;
d2845 1
a2845 3
new_symbol (dip, objfile)
     struct dieinfo *dip;
     struct objfile *objfile;
d3005 2
a3006 4
synthesize_typedef (dip, objfile, type)
     struct dieinfo *dip;
     struct objfile *objfile;
     struct type *type;
d3050 1
a3050 2
decode_mod_fund_type (typedata)
     char *typedata;
d3096 1
a3096 2
decode_mod_u_d_type (typedata)
     char *typedata;
d3159 1
a3159 4
decode_modified_type (modifiers, modcount, mtype)
     char *modifiers;
     unsigned int modcount;
     int mtype;
d3245 1
a3245 2
decode_fund_type (fundtype)
     unsigned int fundtype;
d3377 1
a3377 3
create_name (name, obstackp)
     char *name;
     struct obstack *obstackp;
d3443 1
a3443 4
basicdieinfo (dip, diep, objfile)
     struct dieinfo *dip;
     char *diep;
     struct objfile *objfile;
d3502 1
a3502 3
completedieinfo (dip, objfile)
     struct dieinfo *dip;
     struct objfile *objfile;
d3714 2
a3715 5
target_to_host (from, nbytes, signextend, objfile)
     char *from;
     int nbytes;
     int signextend;		/* FIXME:  Unused */
     struct objfile *objfile;
d3762 1
a3762 2
attribute_size (attr)
     unsigned int attr;
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
This file is part of GDB.
d9 4
a12 4
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
d14 4
a17 4
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
d19 3
a21 3
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d25 2
a26 2
FIXME: Do we need to generate dependencies in partial symtabs?
(Perhaps we don't need to).
d28 5
a32 5
FIXME: Resolve minor differences between what information we put in the
partial symbol table and what dbxread puts in.  For example, we don't yet
put enum constants there.  And dbxread seems to invent a lot of typedefs
we never see.  Use the new printpsym command to see the partial symbol table
contents.
d34 2
a35 2
FIXME: Figure out a better way to tell gdb about the name of the function
contain the user's entry point (I.E. main())
d37 2
a38 2
FIXME: See other FIXME's and "ifdef 0" scattered throughout the code for
other things to work on, if you get bored. :-)
d40 1
a40 1
*/
d50 1
a50 1
#include "expression.h"	/* Needed for enum exp_opcode in language.h, sigh... */
d248 2
a249 2
extern int info_verbose;		/* From main.c; nonzero => verbose */
extern char *warning_pre_print;		/* From utils.c */
d275 1
a275 1
   
d277 1
a277 1
   
d280 46
a325 48
struct dieinfo {
  char *		die;		/* Pointer to the raw DIE data */
  unsigned long 	die_length;	/* Length of the raw DIE data */
  DIE_REF		die_ref;	/* Offset of this DIE */
  unsigned short	die_tag;	/* Tag for this DIE */
  unsigned long		at_padding;
  unsigned long		at_sibling;
  BLOCK *		at_location;
  char *		at_name;
  unsigned short	at_fund_type;
  BLOCK *		at_mod_fund_type;
  unsigned long		at_user_def_type;
  BLOCK *		at_mod_u_d_type;
  unsigned short	at_ordering;
  BLOCK *		at_subscr_data;
  unsigned long		at_byte_size;
  unsigned short	at_bit_offset;
  unsigned long		at_bit_size;
  BLOCK *		at_element_list;
  unsigned long		at_stmt_list;
  CORE_ADDR		at_low_pc;
  CORE_ADDR		at_high_pc;
  unsigned long		at_language;
  unsigned long		at_member;
  unsigned long		at_discr;
  BLOCK *		at_discr_value;
  BLOCK *		at_string_length;
  char *		at_comp_dir;
  char *		at_producer;
  unsigned long		at_start_scope;
  unsigned long		at_stride_size;
  unsigned long		at_src_info;
  char *		at_prototyped;
  unsigned int		has_at_low_pc:1;
  unsigned int		has_at_stmt_list:1;
  unsigned int		has_at_byte_size:1;
  unsigned int		short_element_list:1;

  /* Kludge to identify register variables */

  unsigned int		isreg;

  /* Kludge to identify optimized out variables */

  unsigned int		optimized_out;

  /* Kludge to identify basereg references.
     Nonzero if we have an offset relative to a basereg.  */
d327 2
a328 1
  unsigned int		offreg;
d330 1
a330 1
  /* Kludge to identify which base register is it relative to.  */
d332 4
a335 2
  unsigned int		basereg;
};
d337 1
a337 1
static int diecount;	/* Approximate count of dies for compilation unit */
d340 4
a343 4
static char *dbbase;	/* Base pointer to dwarf info */
static int dbsize;	/* Size of dwarf info in bytes */
static int dbroff;	/* Relative offset from start of .debug section */
static char *lnbase;	/* Base pointer to line section */
d357 22
a378 21
struct dwfinfo {
  /* Always the absolute file offset to the start of the ".debug"
     section for the file containing the DIE's being accessed.  */
  file_ptr dbfoff;
  /* Relative offset from the start of the ".debug" section to the
     first DIE to be accessed.  When building the partial symbol
     table, this value will be zero since we are accessing the
     entire ".debug" section.  When expanding a partial symbol
     table entry, this value will be the offset to the first
     DIE for the compilation unit containing the symbol that
     triggers the expansion.  */
  int dbroff;
  /* The size of the chunk of DIE's being examined, in bytes.  */
  int dblength;
  /* The absolute file offset to the line table fragment.  Ignored
     when building partial symbol tables, but used when expanding
     them, and contains the absolute file offset to the fragment
     of the ".line" section containing the line numbers for the
     current compilation unit.  */
  file_ptr lnfoff;
};
d435 1
a435 1
static struct type *ftypes[FT_NUM_MEMBERS];  /* Fundamental types */
d453 1
a453 2
static void
free_utypes PARAMS ((PTR));
d455 1
a455 2
static int
attribute_size PARAMS ((unsigned int));
d457 1
a457 2
static CORE_ADDR
target_to_host PARAMS ((char *, int, int, struct objfile *));
d459 1
a459 2
static void
add_enum_psymbol PARAMS ((struct dieinfo *, struct objfile *));
d461 1
a461 2
static void
handle_producer PARAMS ((char *));
d464 1
a464 1
read_file_scope PARAMS ((struct dieinfo *, char *, char *, struct objfile *));
d467 1
a467 1
read_func_scope PARAMS ((struct dieinfo *, char *, char *, struct objfile *));
d470 1
a470 2
read_lexical_block_scope PARAMS ((struct dieinfo *, char *, char *,
				  struct objfile *));
d472 1
a472 2
static void
scan_partial_symbols PARAMS ((char *, char *, struct objfile *));
d475 1
a475 2
scan_compilation_units PARAMS ((char *, char *, file_ptr,
				file_ptr, struct objfile *));
d477 1
a477 2
static void
add_partial_symbol PARAMS ((struct dieinfo *, struct objfile *));
d479 1
a479 2
static void
basicdieinfo PARAMS ((struct dieinfo *, char *, struct objfile *));
d481 1
a481 2
static void
completedieinfo PARAMS ((struct dieinfo *, struct objfile *));
d483 1
a483 2
static void
dwarf_psymtab_to_symtab PARAMS ((struct partial_symtab *));
d485 1
a485 2
static void
psymtab_to_symtab_1 PARAMS ((struct partial_symtab *));
d487 1
a487 2
static void
read_ofile_symtab PARAMS ((struct partial_symtab *));
d489 1
a489 2
static void
process_dies PARAMS ((char *, char *, struct objfile *));
d492 1
a492 2
read_structure_scope PARAMS ((struct dieinfo *, char *, char *,
			      struct objfile *));
d494 1
a494 2
static struct type *
decode_array_element_type PARAMS ((char *));
d496 1
a496 2
static struct type *
decode_subscript_data_item PARAMS ((char *, char *));
d498 1
a498 2
static void
dwarf_read_array_type PARAMS ((struct dieinfo *));
d500 1
a500 2
static void
read_tag_pointer_type PARAMS ((struct dieinfo *dip));
d502 1
a502 2
static void
read_tag_string_type PARAMS ((struct dieinfo *dip));
d504 1
a504 2
static void
read_subroutine_type PARAMS ((struct dieinfo *, char *, char *));
d507 1
a507 1
read_enumeration PARAMS ((struct dieinfo *, char *, char *, struct objfile *));
d509 2
a510 2
static struct type *
struct_type PARAMS ((struct dieinfo *, char *, char *, struct objfile *));
d512 1
a512 2
static struct type *
enum_type PARAMS ((struct dieinfo *, struct objfile *));
d514 1
a514 2
static void
decode_line_numbers PARAMS ((char *));
d516 1
a516 2
static struct type *
decode_die_type PARAMS ((struct dieinfo *));
d518 1
a518 2
static struct type *
decode_mod_fund_type PARAMS ((char *));
d520 1
a520 2
static struct type *
decode_mod_u_d_type PARAMS ((char *));
d522 1
a522 2
static struct type *
decode_modified_type PARAMS ((char *, unsigned int, int));
d524 1
a524 2
static struct type *
decode_fund_type PARAMS ((unsigned int));
d526 1
a526 2
static char *
create_name PARAMS ((char *, struct obstack *));
d528 1
a528 2
static struct type *
lookup_utype PARAMS ((DIE_REF));
d530 1
a530 2
static struct type *
alloc_utype PARAMS ((DIE_REF, struct type *));
d532 1
a532 2
static struct symbol *
new_symbol PARAMS ((struct dieinfo *, struct objfile *));
d535 1
a535 2
synthesize_typedef PARAMS ((struct dieinfo *, struct objfile *,
			    struct type *));
d537 1
a537 2
static int
locval PARAMS ((struct dieinfo *));
d539 1
a539 2
static void
set_cu_language PARAMS ((struct dieinfo *));
d541 1
a541 2
static struct type *
dwarf_fundamental_type PARAMS ((struct objfile *, int));
d546 3
a548 1
LOCAL FUNCTION
d550 1
a550 1
	dwarf_fundamental_type -- lookup or create a fundamental type
d552 2
a553 1
SYNOPSIS
d555 1
a555 2
	struct type *
	dwarf_fundamental_type (struct objfile *objfile, int typeid)
d557 5
a561 1
DESCRIPTION
d563 8
a570 14
	DWARF version 1 doesn't supply any fundamental type information,
	so gdb has to construct such types.  It has a fixed number of
	fundamental types that it knows how to construct, which is the
	union of all types that it knows how to construct for all languages
	that it knows about.  These are enumerated in gdbtypes.h.

	As an example, assume we find a DIE that references a DWARF
	fundamental type of FT_integer.  We first look in the ftypes
	array to see if we already have such a type, indexed by the
	gdb internal value of FT_INTEGER.  If so, we simply return a
	pointer to that type.  If not, then we ask an appropriate
	language dependent routine to create a type FT_INTEGER, using
	defaults reasonable for the current target machine, and install
	that type in ftypes for future reference.
d572 1
a572 1
RETURNS
d574 1
a574 1
	Pointer to a fundamental type.
d576 1
a576 1
*/
d594 1
a594 1
      ftypes[typeid] = cu_language_defn -> la_fund_type(objfile, typeid);
d602 1
a602 1
LOCAL FUNCTION
d604 1
a604 1
	set_cu_language -- set local copy of language for compilation unit
d606 1
a606 1
SYNOPSIS
d608 2
a609 2
	void
	set_cu_language (struct dieinfo *dip)
d611 1
a611 1
DESCRIPTION
d613 3
a615 3
	Decode the language attribute for a compilation unit DIE and
	remember what the language was.  We use this at various times
	when processing DIE's for a given compilation unit.
d617 1
a617 1
RETURNS
d619 1
a619 1
	No return value.
d627 1
a627 1
  switch (dip -> at_language)
d629 28
a656 28
      case LANG_C89:
      case LANG_C:
        cu_language = language_c;
	break;
      case LANG_C_PLUS_PLUS:
	cu_language = language_cplus;
	break;
      case LANG_CHILL:
	cu_language = language_chill;
	break;
      case LANG_MODULA2:
	cu_language = language_m2;
	break;
      case LANG_FORTRAN77:
      case LANG_FORTRAN90:
	cu_language = language_fortran;
	break;
      case LANG_ADA83:
      case LANG_COBOL74:
      case LANG_COBOL85:
      case LANG_PASCAL83:
	/* We don't know anything special about these yet. */
	cu_language = language_unknown;
	break;
      default:
	/* If no at_language, try to deduce one from the filename */
	cu_language = deduce_language_from_filename (dip -> at_name);
	break;
d663 1
a663 1
GLOBAL FUNCTION
d665 1
a665 1
	dwarf_build_psymtabs -- build partial symtabs from DWARF debug info
d667 1
a667 1
SYNOPSIS
d669 3
a671 4
	void dwarf_build_psymtabs (struct objfile *objfile,
	     struct section_offsets *section_offsets,
	     int mainline, file_ptr dbfoff, unsigned int dbfsize,
	     file_ptr lnoffset, unsigned int lnsize)
d673 1
a673 1
DESCRIPTION
d675 2
a676 2
	This function is called upon to build partial symtabs from files
	containing DIE's (Dwarf Information Entries) and DWARF line numbers.
d678 7
a684 7
	It is passed a bfd* containing the DIES
	and line number information, the corresponding filename for that
	file, a base address for relocating the symbols, a flag indicating
	whether or not this debugging information is from a "main symbol
	table" rather than a shared library or dynamically linked file,
	and file offset/size pairs for the DIE information and line number
	information.
d686 1
a686 1
RETURNS
d688 1
a688 1
	No return value.
d693 1
a693 1
dwarf_build_psymtabs (objfile, section_offsets, mainline, dbfoff, dbfsize,
a695 1
     struct section_offsets *section_offsets;
d704 1
a704 1
  
d716 1
a716 1
  
d720 3
a722 3
  
  if (mainline || objfile -> global_psymbols.size == 0 ||
      objfile -> static_psymbols.size == 0)
d726 1
a726 1
  
d729 2
a730 2
  base_section_offsets = section_offsets;
  baseaddr = ANOFFSET (section_offsets, 0);
d735 1
a735 1
  
d737 1
a737 1
  
d744 1
a744 1
LOCAL FUNCTION
d746 1
a746 1
	read_lexical_block_scope -- process all dies in a lexical block
d748 1
a748 1
SYNOPSIS
d750 2
a751 2
	static void read_lexical_block_scope (struct dieinfo *dip,
		char *thisdie, char *enddie)
d753 1
a753 1
DESCRIPTION
d755 2
a756 2
	Process all the DIES contained within a lexical block scope.
	Start a new scope, process the dies, and then close the scope.
d769 2
a770 2
  push_context (0, dip -> at_low_pc);
  process_dies (thisdie + dip -> die_length, enddie, objfile);
d774 2
a775 2
      finish_block (0, &local_symbols, new -> old_blocks, new -> start_addr,
		    dip -> at_high_pc, objfile);
d777 1
a777 1
  local_symbols = new -> locals;
d782 1
a782 1
LOCAL FUNCTION
d784 1
a784 1
	lookup_utype -- look up a user defined type from die reference
d786 1
a786 1
SYNOPSIS
d788 1
a788 1
	static type *lookup_utype (DIE_REF die_ref)
d790 1
a790 1
DESCRIPTION
d792 5
a796 5
	Given a DIE reference, lookup the user defined type associated with
	that DIE, if it has been registered already.  If not registered, then
	return NULL.  Alloc_utype() can be called to register an empty
	type for this reference, which will be filled in later when the
	actual referenced DIE is processed.
d805 1
a805 1
  
d821 1
a821 1
LOCAL FUNCTION
d823 1
a823 1
	alloc_utype  -- add a user defined type for die reference
d825 1
a825 1
SYNOPSIS
d827 1
a827 1
	static type *alloc_utype (DIE_REF die_ref, struct type *utypep)
d829 1
a829 1
DESCRIPTION
d831 4
a834 4
	Given a die reference DIE_REF, and a possible pointer to a user
	defined type UTYPEP, register that this reference has a user
	defined type and either use the specified type in UTYPEP or
	make a new empty type that will be filled in later.
d836 2
a837 2
	We should only be called after calling lookup_utype() to verify that
	there is not currently a type registered for DIE_REF.
d847 1
a847 1
  
d873 1
a873 1
LOCAL FUNCTION
d875 1
a875 1
	free_utypes -- free the utypes array and reset pointer & count
d877 1
a877 1
SYNOPSIS
d879 1
a879 1
	static void free_utypes (PTR dummy)
d881 1
a881 1
DESCRIPTION
d883 3
a885 3
	Called via do_cleanups to free the utypes array, reset the pointer to NULL,
	and set numutypes back to zero.  This ensures that the utypes does not get
	referenced after being freed.
d900 1
a900 1
LOCAL FUNCTION
d902 1
a902 1
	decode_die_type -- return a type for a specified die
d904 1
a904 1
SYNOPSIS
d906 1
a906 1
	static struct type *decode_die_type (struct dieinfo *dip)
d908 1
a908 1
DESCRIPTION
d910 3
a912 3
	Given a pointer to a die information structure DIP, decode the
	type of the die and return a pointer to the decoded type.  All
	dies without specific types default to type int.
d920 2
a921 2
  
  if (dip -> at_fund_type != 0)
d923 1
a923 1
      type = decode_fund_type (dip -> at_fund_type);
d925 1
a925 1
  else if (dip -> at_mod_fund_type != NULL)
d927 1
a927 1
      type = decode_mod_fund_type (dip -> at_mod_fund_type);
d929 1
a929 1
  else if (dip -> at_user_def_type)
d931 1
a931 1
      if ((type = lookup_utype (dip -> at_user_def_type)) == NULL)
d933 1
a933 1
	  type = alloc_utype (dip -> at_user_def_type, NULL);
d936 1
a936 1
  else if (dip -> at_mod_u_d_type)
d938 1
a938 1
      type = decode_mod_u_d_type (dip -> at_mod_u_d_type);
d949 1
a949 1
LOCAL FUNCTION
d951 1
a951 1
	struct_type -- compute and return the type for a struct or union
d953 1
a953 1
SYNOPSIS
d955 2
a956 2
	static struct type *struct_type (struct dieinfo *dip, char *thisdie,
	    char *enddie, struct objfile *objfile)
d958 1
a958 1
DESCRIPTION
d960 5
a964 5
	Given pointer to a die information structure for a die which
	defines a union or structure (and MUST define one or the other),
	and pointers to the raw die data that define the range of dies which
	define the members, compute and return the user defined type for the
	structure or union.
d975 5
a979 4
  struct nextfield {
    struct nextfield *next;
    struct field field;
  };
d987 2
a988 2
  
  if ((type = lookup_utype (dip -> die_ref)) == NULL)
d991 1
a991 1
      type = alloc_utype (dip -> die_ref, NULL);
d993 2
a994 2
  INIT_CPLUS_SPECIFIC(type);
  switch (dip -> die_tag)
d996 14
a1009 14
      case TAG_class_type:
        TYPE_CODE (type) = TYPE_CODE_CLASS;
	break;
      case TAG_structure_type:
        TYPE_CODE (type) = TYPE_CODE_STRUCT;
	break;
      case TAG_union_type:
	TYPE_CODE (type) = TYPE_CODE_UNION;
	break;
      default:
	/* Should never happen */
	TYPE_CODE (type) = TYPE_CODE_UNDEF;
	complain (&missing_tag, DIE_ID, DIE_NAME);
	break;
d1014 3
a1016 3
  if (dip -> at_name != NULL
      && *dip -> at_name != '~'
      && *dip -> at_name != '.')
d1018 2
a1019 2
      TYPE_TAG_NAME (type) = obconcat (&objfile -> type_obstack,
				       "", "", dip -> at_name);
d1026 2
a1027 2
  TYPE_LENGTH (type) = dip -> at_byte_size;
  thisdie += dip -> die_length;
d1049 1
a1049 1
	  new -> next = list;
d1052 3
a1054 3
	  list -> field.name =
	      obsavestring (mbr.at_name, strlen (mbr.at_name),
			    &objfile -> type_obstack);
d1062 4
a1065 4
		 additional bit offset from the MSB of the containing
		 anonymous object to the MSB of the field.  We don't
		 have to do anything special since we don't need to
		 know the size of the anonymous object. */
d1071 7
a1077 7
		 at_bit_size, so that we know we are in fact dealing
		 with a bitfield.  Compute the bit offset to the MSB
		 of the anonymous object, subtract off the number of
		 bits from the MSB of the field to the MSB of the
		 object, and then subtract off the number of bits of
		 the field itself.  The result is the bit offset of
		 the LSB of the field. */
d1083 2
a1084 2
			 the bit field is explicit, so use the
			 indicated size (in bytes). */
d1090 5
a1094 5
			 the bit field matches the size of an object
			 of the bit field's type.  DWARF allows
			 at_byte_size to be left out in such cases, as
			 a debug information size optimization. */
		      anonymous_size = TYPE_LENGTH (list -> field.type);
d1123 1
a1123 1
      for (n = nfields; list; list = list -> next)
d1125 2
a1126 2
	  TYPE_FIELD (type, --n) = list -> field;
	}	
d1133 5
a1137 1
LOCAL FUNCTION
d1139 2
a1140 1
	read_structure_scope -- process all dies within struct or union
d1142 1
a1142 1
SYNOPSIS
d1144 4
a1147 2
	static void read_structure_scope (struct dieinfo *dip,
		char *thisdie, char *enddie, struct objfile *objfile)
d1149 1
a1149 1
DESCRIPTION
d1151 4
a1154 4
	Called when we find the DIE that starts a structure or union
	scope (definition) to process all dies that define the members
	of the structure or union.  DIP is a pointer to the die info
	struct for the DIE that names the structure or union.
d1156 6
a1161 1
NOTES
a1162 12
	Note that we need to call struct_type regardless of whether or not
	the DIE has an at_name attribute, since it might be an anonymous
	structure or union.  This gets the type entered into our set of
	user defined types.

	However, if the structure is incomplete (an opaque struct/union)
	then suppress creating a symbol table entry for it since gdb only
	wants to find the one with the complete definition.  Note that if
	it is complete, we just call new_symbol, which does it's own
	checking about whether the struct/union is anonymous or not (and
	suppresses creating a symbol table entry itself).
	
d1174 1
a1174 1
  
d1192 1
a1192 1
LOCAL FUNCTION
d1194 1
a1194 1
	decode_array_element_type -- decode type of the array elements
d1196 1
a1196 1
SYNOPSIS
d1198 1
a1198 1
	static struct type *decode_array_element_type (char *scan, char *end)
d1200 1
a1200 1
DESCRIPTION
d1202 5
a1206 5
	As the last step in decoding the array subscript information for an
	array DIE, we need to decode the type of the array elements.  We are
	passed a pointer to this last part of the subscript information and
	must return the appropriate type.  If the type attribute is not
	recognized, just warn about the problem and return type int.
d1218 1
a1218 1
  
d1231 24
a1254 24
	  case AT_fund_type:
	    fundtype = target_to_host (scan, nbytes, GET_UNSIGNED,
				       current_objfile);
	    typep = decode_fund_type (fundtype);
	    break;
	  case AT_mod_fund_type:
	    typep = decode_mod_fund_type (scan);
	    break;
	  case AT_user_def_type:
	    die_ref = target_to_host (scan, nbytes, GET_UNSIGNED,
				      current_objfile);
	    if ((typep = lookup_utype (die_ref)) == NULL)
	      {
		typep = alloc_utype (die_ref, NULL);
	      }
	    break;
	  case AT_mod_u_d_type:
	    typep = decode_mod_u_d_type (scan);
	    break;
	  default:
	    complain (&bad_array_element_type, DIE_ID, DIE_NAME, attribute);
	    typep = dwarf_fundamental_type (current_objfile, FT_INTEGER);
	    break;
	  }
d1261 18
a1278 1
LOCAL FUNCTION
d1280 4
a1283 1
	decode_subscript_data_item -- decode array subscript item
d1285 2
a1286 1
SYNOPSIS
d1288 4
a1291 2
	static struct type *
	decode_subscript_data_item (char *scan, char *end)
d1293 2
a1294 1
DESCRIPTION
d1296 3
a1298 27
	The array subscripts and the data type of the elements of an
	array are described by a list of data items, stored as a block
	of contiguous bytes.  There is a data item describing each array
	dimension, and a final data item describing the element type.
	The data items are ordered the same as their appearance in the
	source (I.E. leftmost dimension first, next to leftmost second,
	etc).

	The data items describing each array dimension consist of four
	parts: (1) a format specifier, (2) type type of the subscript
	index, (3) a description of the low bound of the array dimension,
	and (4) a description of the high bound of the array dimension.

	The last data item is the description of the type of each of
	the array elements.

	We are passed a pointer to the start of the block of bytes
	containing the remaining data items, and a pointer to the first
	byte past the data.  This function recursively decodes the
	remaining data items and returns a type.

	If we somehow fail to decode some data, we complain about it
	and return a type "array of int".

BUGS
	FIXME:  This code only implements the forms currently used
	by the AT&T and GNU C compilers.
d1300 2
a1301 2
	The end pointer is supplied for error checking, maybe we should
	use it for that...
d1318 1
a1318 1
  
d1345 1
a1345 1
				      lowbound, highbound);
d1372 1
a1372 1
LOCAL FUNCTION
d1374 1
a1374 1
	dwarf_read_array_type -- read TAG_array_type DIE
d1376 1
a1376 1
SYNOPSIS
d1378 1
a1378 1
	static void dwarf_read_array_type (struct dieinfo *dip)
d1380 1
a1380 1
DESCRIPTION
d1382 2
a1383 2
	Extract all information from a TAG_array_type DIE and add to
	the user defined type vector.
d1396 2
a1397 2
  
  if (dip -> at_ordering != ORD_row_major)
d1402 1
a1402 1
  if ((sub = dip -> at_subscr_data) != NULL)
d1409 1
a1409 1
      if ((utype = lookup_utype (dip -> die_ref)) == NULL)
d1412 1
a1412 1
	  alloc_utype (dip -> die_ref, type);
d1437 1
a1437 1
LOCAL FUNCTION
d1439 1
a1439 1
	read_tag_pointer_type -- read TAG_pointer_type DIE
d1441 1
a1441 1
SYNOPSIS
d1443 1
a1443 1
	static void read_tag_pointer_type (struct dieinfo *dip)
d1445 1
a1445 1
DESCRIPTION
d1447 2
a1448 2
	Extract all information from a TAG_pointer_type DIE and add to
	the user defined type vector.
d1457 1
a1457 1
  
d1459 1
a1459 1
  if ((utype = lookup_utype (dip -> die_ref)) == NULL)
d1462 1
a1462 1
      alloc_utype (dip -> die_ref, utype);
d1471 1
a1471 1
      TYPE_LENGTH (utype) = TARGET_PTR_BIT / TARGET_CHAR_BIT ;
d1478 1
a1478 1
LOCAL FUNCTION
d1480 1
a1480 1
	read_tag_string_type -- read TAG_string_type DIE
d1482 1
a1482 1
SYNOPSIS
d1484 1
a1484 1
	static void read_tag_string_type (struct dieinfo *dip)
d1486 1
a1486 1
DESCRIPTION
d1488 4
a1491 4
	Extract all information from a TAG_string_type DIE and add to
	the user defined type vector.  It isn't really a user defined
	type, but it behaves like one, with other DIE's using an
	AT_user_def_type attribute to reference it.
d1504 1
a1504 1
  if (dip -> has_at_byte_size)
d1507 1
a1507 1
      highbound = dip -> at_byte_size - 1;
d1517 2
a1518 2
      
  utype = lookup_utype (dip -> die_ref);
d1522 1
a1522 1
      utype = alloc_utype (dip -> die_ref, (struct type *) NULL);
d1527 1
a1527 1
	 is a blank one.  If not, complain and leave it alone. */
d1541 1
a1541 1
LOCAL FUNCTION
d1543 1
a1543 1
	read_subroutine_type -- process TAG_subroutine_type dies
d1545 1
a1545 1
SYNOPSIS
d1547 2
a1548 2
	static void read_subroutine_type (struct dieinfo *dip, char thisdie,
		char *enddie)
d1550 1
a1550 1
DESCRIPTION
d1552 1
a1552 1
	Handle DIES due to C code like:
d1554 4
a1557 4
	struct foo {
	    int (*funcp)(int a, long l);  (Generates TAG_subroutine_type DIE)
	    int b;
	};
d1559 1
a1559 1
NOTES
d1561 3
a1563 3
	The parameter DIES are currently ignored.  See if gdb has a way to
	include this info in it's type system, and decode them if so.  Is
	this what the type structure's "arg_types" field is for?  (FIXME)
d1574 1
a1574 1
  
d1582 1
a1582 1
  if ((ftype = lookup_utype (dip -> die_ref)) == NULL)
d1585 1
a1585 1
	 a new one and place it in the user defined types. */
d1587 1
a1587 1
      alloc_utype (dip -> die_ref, ftype);
d1592 1
a1592 1
	 into the correct type. */
d1605 1
a1605 1
LOCAL FUNCTION
d1607 1
a1607 1
	read_enumeration -- process dies which define an enumeration
d1609 1
a1609 1
SYNOPSIS
d1611 2
a1612 2
	static void read_enumeration (struct dieinfo *dip, char *thisdie,
		char *enddie, struct objfile *objfile)
d1614 1
a1614 1
DESCRIPTION
d1616 2
a1617 2
	Given a pointer to a die which begins an enumeration, process all
	the dies that define the members of the enumeration.
d1619 1
a1619 1
NOTES
d1621 3
a1623 3
	Note that we need to call enum_type regardless of whether or not we
	have a symbol, since we might have an enum without a tag name (thus
	no symbol for the tagname).
d1635 1
a1635 1
  
d1650 3
a1652 1
LOCAL FUNCTION
d1654 1
a1654 1
	enum_type -- decode and return a type for an enumeration
d1656 1
a1656 1
SYNOPSIS
d1658 1
a1658 1
	static type *enum_type (struct dieinfo *dip, struct objfile *objfile)
d1660 3
a1662 1
DESCRIPTION
d1664 3
a1666 7
	Given a pointer to a die information structure for the die which
	starts an enumeration, process all the dies that define the members
	of the enumeration and return a type pointer for the enumeration.

	At the same time, for each member of the enumeration, create a
	symbol for it with namespace VAR_NAMESPACE and class LOC_CONST,
	and give it the type of the enumeration itself.
d1668 1
a1668 1
NOTES
d1670 7
a1676 7
	Note that the DWARF specification explicitly mandates that enum
	constants occur in reverse order from the source program order,
	for "consistency" and because this ordering is easier for many
	compilers to generate. (Draft 6, sec 3.8.5, Enumeration type
	Entries).  Because gdb wants to see the enum members in program
	source order, we have to ensure that the order gets reversed while
	we are processing them.
d1685 5
a1689 4
  struct nextfield {
    struct nextfield *next;
    struct field field;
  };
d1700 2
a1701 2
  
  if ((type = lookup_utype (dip -> die_ref)) == NULL)
d1704 1
a1704 1
      type = alloc_utype (dip -> die_ref, NULL);
d1710 3
a1712 3
  if (dip -> at_name != NULL
      && *dip -> at_name != '~'
      && *dip -> at_name != '.')
d1714 2
a1715 2
      TYPE_TAG_NAME (type) = obconcat (&objfile -> type_obstack,
				       "", "", dip -> at_name);
d1717 1
a1717 1
  if (dip -> at_byte_size != 0)
d1719 1
a1719 1
      TYPE_LENGTH (type) = dip -> at_byte_size;
d1721 1
a1721 1
  if ((scan = dip -> at_element_list) != NULL)
d1723 1
a1723 1
      if (dip -> short_element_list)
d1737 1
a1737 1
	  new -> next = list;
d1745 2
a1746 2
	  list -> field.name = obsavestring (scan, strlen (scan),
					     &objfile -> type_obstack);
d1753 1
a1753 1
	  SYMBOL_NAME (sym) = create_name (list -> field.name,
d1765 4
a1768 4
	 where we reverse the order, by pulling the members off the list in
	 reverse order from how they were inserted.  If we have no fields
	 (this is apparently possible in C++) then skip building a field
	 vector. */
d1777 1
a1777 1
	  for (n = 0; (n < nfields) && (list != NULL); list = list -> next)
d1779 2
a1780 2
	      TYPE_FIELD (type, n++) = list -> field;
	    }	
d1788 1
a1788 1
LOCAL FUNCTION
d1790 1
a1790 1
	read_func_scope -- process all dies within a function scope
d1792 1
a1792 1
DESCRIPTION
d1794 11
a1804 11
	Process all dies within a given function scope.  We are passed
	a die information structure pointer DIP for the die which
	starts the function scope, and pointers into the raw die data
	that define the dies within the function scope.

	For now, we ignore lexical block scopes within the function.
	The problem is that AT&T cc does not define a DWARF lexical
	block scope for the function itself, while gcc defines a
	lexical block scope for the function.  We need to think about
	how to handle this difference, or if it is even a problem.
	(FIXME)
d1815 1
a1815 1
  
d1820 1
a1820 1
  if (dip -> at_name == NULL)
d1826 2
a1827 2
  if (objfile -> ei.entry_point >= dip -> at_low_pc &&
      objfile -> ei.entry_point <  dip -> at_high_pc)
d1829 2
a1830 2
      objfile -> ei.entry_func_lowpc = dip -> at_low_pc;
      objfile -> ei.entry_func_highpc = dip -> at_high_pc;
d1832 2
a1833 7
  if (STREQ (dip -> at_name, "main"))	/* FIXME: hardwired name */
    {
      objfile -> ei.main_func_lowpc = dip -> at_low_pc;
      objfile -> ei.main_func_highpc = dip -> at_high_pc;
    }
  new = push_context (0, dip -> at_low_pc);
  new -> name = new_symbol (dip, objfile);
d1835 1
a1835 1
  process_dies (thisdie + dip -> die_length, enddie, objfile);
d1838 2
a1839 2
  finish_block (new -> name, &local_symbols, new -> old_blocks,
		new -> start_addr, dip -> at_high_pc, objfile);
d1846 1
a1846 1
LOCAL FUNCTION
d1848 1
a1848 1
	handle_producer -- process the AT_producer attribute
d1850 1
a1850 1
DESCRIPTION
d1852 2
a1853 2
	Perform any operations that depend on finding a particular
	AT_producer attribute.
d1898 1
a1898 1
LOCAL FUNCTION
d1900 1
a1900 1
	read_file_scope -- process all dies within a file scope
d1902 1
a1902 1
DESCRIPTION
d1904 12
a1915 12
	Process all dies within a given file scope.  We are passed a
	pointer to the die information structure for the die which
	starts the file scope, and pointers into the raw die data which
	mark the range of dies within the file scope.

	When the partial symbol table is built, the file offset for the line
	number table for each compilation unit is saved in the partial symbol
	table entry for that compilation unit.  As the symbols for each
	compilation unit are read, the line number table is read into memory
	and the variable lnbase is set to point to it.  Thus all we have to
	do is use lnbase to access the line number table for the current
	compilation unit.
d1927 3
a1929 3
  
  if (objfile -> ei.entry_point >= dip -> at_low_pc &&
      objfile -> ei.entry_point <  dip -> at_high_pc)
d1931 2
a1932 2
      objfile -> ei.entry_file_lowpc = dip -> at_low_pc;
      objfile -> ei.entry_file_highpc = dip -> at_high_pc;
d1935 1
a1935 1
  if (dip -> at_producer != NULL)
d1937 1
a1937 1
      handle_producer (dip -> at_producer);
d1944 1
a1944 1
  start_symtab (dip -> at_name, dip -> at_comp_dir, dip -> at_low_pc);
d1947 1
a1947 1
  process_dies (thisdie + dip -> die_length, enddie, objfile);
d1949 1
a1949 1
  symtab = end_symtab (dip -> at_high_pc, objfile, 0);
d1952 2
a1953 2
      symtab -> language = cu_language;
    }      
d1959 1
a1959 1
LOCAL FUNCTION
d1961 1
a1961 1
	process_dies -- process a range of DWARF Information Entries
d1963 1
a1963 1
SYNOPSIS
d1965 2
a1966 2
	static void process_dies (char *thisdie, char *enddie,
				  struct objfile *objfile)
d1968 1
a1968 1
DESCRIPTION
d1970 2
a1971 2
	Process all DIE's in a specified range.  May be (and almost
	certainly will be) called recursively.
d1982 1
a1982 1
  
d2014 2
a2015 2
		 unit, we are unable to handle nested compilation units
		 properly (FIXME).  */
d2062 1
a2062 1
LOCAL FUNCTION
d2064 1
a2064 1
	decode_line_numbers -- decode a line number table fragment
d2066 1
a2066 1
SYNOPSIS
d2068 2
a2069 2
	static void decode_line_numbers (char *tblscan, char *tblend,
		long length, long base, long line, long pc)
d2071 1
a2071 1
DESCRIPTION
d2073 1
a2073 1
	Translate the DWARF line number information to gdb form.
d2075 2
a2076 2
	The ".line" section contains one or more line number tables, one for
	each ".line" section from the objects that were linked.
d2078 3
a2080 3
	The AT_stmt_list attribute for each TAG_source_file entry in the
	".debug" section contains the offset into the ".line" section for the
	start of the table for that file.
d2082 1
a2082 1
	The table itself has the following structure:
d2084 2
a2085 2
	<table length><base address><source statement entry>
	4 bytes       4 bytes       10 bytes
d2087 2
a2088 2
	The table length is the total size of the table, including the 4 bytes
	for the length information.
d2090 2
a2091 2
	The base address is the address of the first instruction generated
	for the source file.
d2093 1
a2093 1
	Each source statement entry has the following structure:
d2095 2
a2096 2
	<line number><statement position><address delta>
	4 bytes      2 bytes             4 bytes
d2098 2
a2099 2
	The line number is relative to the start of the file, starting with
	line 1.
d2101 2
a2102 2
	The statement position either -1 (0xFFFF) or the number of characters
	from the beginning of the line to the beginning of the statement.
d2104 2
a2105 2
	The address delta is the difference between the base address and
	the address of the first instruction for the statement.
d2107 3
a2109 3
	Note that we must copy the bytes from the packed table to our local
	variables before attempting to use them, to avoid alignment problems
	on some machines, particularly RISC processors.
d2111 1
a2111 1
BUGS
d2113 2
a2114 2
	Does gdb expect the line numbers to be sorted?  They are now by
	chance/luck, but are not required to be.  (FIXME)
d2116 2
a2117 2
	The line with number 0 is unused, gdb apparently can discover the
	span of the last line some other way. How?  (FIXME)
d2130 1
a2130 1
  
d2161 5
a2165 1
LOCAL FUNCTION
d2167 1
a2167 1
	locval -- compute the value of a location attribute
d2169 1
a2169 1
SYNOPSIS
d2171 5
a2175 1
	static int locval (struct dieinfo *dip)
d2177 4
a2180 1
DESCRIPTION
d2182 5
a2186 16
	Given pointer to a string of bytes that define a location, compute
	the location and return the value.
	A location description containing no atoms indicates that the
	object is optimized out. The optimized_out flag is set for those,
	the return value is meaningless.

	When computing values involving the current value of the frame pointer,
	the value zero is used, which results in a value relative to the frame
	pointer, rather than the absolute value.  This is what GDB wants
	anyway.
    
	When the result is a register number, the isreg flag is set, otherwise
	it is cleared.  This is a kludge until we figure out a better
	way to handle the problem.  Gdb's design does not mesh well with the
	DWARF notion of a location computing interpreter, which is a shame
	because the flexibility goes unused.
d2188 1
a2188 1
NOTES
d2190 2
a2191 2
	Note that stack[0] is unused except as a default error return.
	Note that stack overflow is not yet handled.
d2206 2
a2207 2
  
  loc = dip -> at_location;
d2214 3
a2216 3
  dip -> isreg = 0;
  dip -> offreg = 0;
  dip -> optimized_out = 1;
d2220 1
a2220 1
      dip -> optimized_out = 0;
d2226 46
a2271 46
	  case 0:
	    /* error */
	    loc = end;
	    break;
	  case OP_REG:
	    /* push register (number) */
	    stack[++stacki]
	      = DWARF_REG_TO_REGNUM (target_to_host (loc, loc_value_size,
						     GET_UNSIGNED,
						     current_objfile));
	    loc += loc_value_size;
	    dip -> isreg = 1;
	    break;
	  case OP_BASEREG:
	    /* push value of register (number) */
	    /* Actually, we compute the value as if register has 0, so the
	       value ends up being the offset from that register.  */
	    dip -> offreg = 1;
	    dip -> basereg = target_to_host (loc, loc_value_size, GET_UNSIGNED,
					     current_objfile);
	    loc += loc_value_size;
	    stack[++stacki] = 0;
	    break;
	  case OP_ADDR:
	    /* push address (relocated address) */
	    stack[++stacki] = target_to_host (loc, loc_value_size,
					      GET_UNSIGNED, current_objfile);
	    loc += loc_value_size;
	    break;
	  case OP_CONST:
	    /* push constant (number)   FIXME: signed or unsigned! */
	    stack[++stacki] = target_to_host (loc, loc_value_size,
					      GET_SIGNED, current_objfile);
	    loc += loc_value_size;
	    break;
	  case OP_DEREF2:
	    /* pop, deref and push 2 bytes (as a long) */
	    complain (&op_deref2, DIE_ID, DIE_NAME, stack[stacki]);
	    break;
	  case OP_DEREF4:	/* pop, deref and push 4 bytes (as a long) */
	    complain (&op_deref4, DIE_ID, DIE_NAME, stack[stacki]);
	    break;
	  case OP_ADD:	/* pop top 2 items, add, push result */
	    stack[stacki - 1] += stack[stacki];
	    stacki--;
	    break;
d2279 1
a2279 1
LOCAL FUNCTION
d2281 1
a2281 1
	read_ofile_symtab -- build a full symtab entry from chunk of DIE's
d2283 1
a2283 1
SYNOPSIS
d2285 1
a2285 1
	static void read_ofile_symtab (struct partial_symtab *pst)
d2287 1
a2287 1
DESCRIPTION
d2289 5
a2293 5
	When expanding a partial symbol table entry to a full symbol table
	entry, this is the function that gets called to read in the symbols
	for the compilation unit.  A pointer to the newly constructed symtab,
	which is now the new first one on the objfile's symtab list, is
	stashed in the partial symbol table entry.
d2306 2
a2307 2
  abfd = pst -> objfile -> obfd;
  current_objfile = pst -> objfile;
d2315 2
a2316 2
  dbroff = DBROFF(pst);
  foffset = DBFOFF(pst) + dbroff;
d2342 1
a2342 1
			       GET_UNSIGNED, pst -> objfile);
d2353 1
a2353 1
  process_dies (dbbase, dbbase + dbsize, pst -> objfile);
d2356 1
a2356 1
  pst -> symtab = pst -> objfile -> symtabs;
d2361 1
a2361 1
LOCAL FUNCTION
d2363 1
a2363 1
	psymtab_to_symtab_1 -- do grunt work for building a full symtab entry
d2365 1
a2365 1
SYNOPSIS
d2367 1
a2367 1
	static void psymtab_to_symtab_1 (struct partial_symtab *pst)
d2369 1
a2369 1
DESCRIPTION
d2371 2
a2372 2
	Called once for each partial symbol table entry that needs to be
	expanded into a full symbol table entry.
d2374 1
a2374 1
*/
d2382 1
a2382 1
  
d2388 1
a2388 1
		   pst -> filename);
d2393 1
a2393 1
	  for (i = 0; i < pst -> number_of_dependencies; i++)
d2395 1
a2395 1
	      if (!pst -> dependencies[i] -> readin)
d2405 1
a2405 1
				       pst -> dependencies[i] -> filename);
d2407 1
a2407 1
		      gdb_flush (gdb_stdout);		/* Flush output */
d2409 1
a2409 1
		  psymtab_to_symtab_1 (pst -> dependencies[i]);
d2411 2
a2412 2
	    }	  
	  if (DBLENGTH (pst))		/* Otherwise it's a dummy */
d2415 1
a2415 2
	      old_chain = make_cleanup ((make_cleanup_func) 
                                        really_free_pendings, 0);
d2423 1
a2423 1
	      sort_symtab_syms (pst -> symtab);
d2426 1
a2426 1
	  pst -> readin = 1;
d2433 1
a2433 1
LOCAL FUNCTION
d2435 1
a2435 1
	dwarf_psymtab_to_symtab -- build a full symtab entry from partial one
d2437 1
a2437 1
SYNOPSIS
d2439 1
a2439 1
	static void dwarf_psymtab_to_symtab (struct partial_symtab *pst)
d2441 1
a2441 1
DESCRIPTION
d2443 3
a2445 3
	This is the DWARF support entry point for building a full symbol
	table entry from a partial symbol table entry.  We are passed a
	pointer to the partial symbol table entry that needs to be expanded.
d2447 1
a2447 1
*/
d2456 1
a2456 1
      if (pst -> readin)
d2459 1
a2459 1
		   pst -> filename);
d2463 1
a2463 1
	  if (DBLENGTH (pst) || pst -> number_of_dependencies)
d2466 1
a2466 1
		 disconcerting pauses.  */
d2470 1
a2470 1
				   pst -> filename);
d2473 1
a2473 1
	      
d2475 8
a2482 8
	      
#if 0	      /* FIXME:  Check to see what dbxread is doing here and see if
		 we need to do an equivalent or is this something peculiar to
		 stabs/a.out format.
		 Match with global symbols.  This only needs to be done once,
		 after all of the symtabs and dependencies have been read in.
		 */
	      scan_file_globals (pst -> objfile);
d2484 1
a2484 1
	      
d2498 1
a2498 1
LOCAL FUNCTION
d2500 1
a2500 1
	add_enum_psymbol -- add enumeration members to partial symbol table
d2502 1
a2502 1
DESCRIPTION
d2504 4
a2507 4
	Given pointer to a DIE that is known to be for an enumeration,
	extract the symbolic names of the enumeration members and add
	partial symbols for them.
*/
d2518 2
a2519 2
  
  if ((scan = dip -> at_element_list) != NULL)
d2521 1
a2521 1
      if (dip -> short_element_list)
d2536 1
a2536 1
			       &objfile -> static_psymbols, 0, 0, cu_language,
d2545 1
a2545 1
LOCAL FUNCTION
d2547 1
a2547 1
	add_partial_symbol -- add symbol to partial symbol table
d2549 1
a2549 1
DESCRIPTION
d2551 3
a2553 3
	Given a DIE, if it is one of the types that we want to
	add to a partial symbol table, finish filling in the die info
	and then add a partial symbol table entry for it.
d2555 1
a2555 1
NOTES
d2557 2
a2558 2
	The caller must ensure that the DIE has a valid name attribute.
*/
d2565 1
a2565 1
  switch (dip -> die_tag)
d2568 4
a2571 4
      add_psymbol_to_list (dip -> at_name, strlen (dip -> at_name),
				VAR_NAMESPACE, LOC_BLOCK,
				&objfile -> global_psymbols,
				0, dip -> at_low_pc, cu_language, objfile);
d2574 1
a2574 1
      add_psymbol_to_list (dip -> at_name, strlen (dip -> at_name),
d2576 1
a2576 1
			   &objfile -> global_psymbols,
d2580 4
a2583 4
      add_psymbol_to_list (dip -> at_name, strlen (dip -> at_name),
				VAR_NAMESPACE, LOC_BLOCK,
				&objfile -> static_psymbols,
				0, dip -> at_low_pc, cu_language, objfile);
d2586 1
a2586 1
      add_psymbol_to_list (dip -> at_name, strlen (dip -> at_name),
d2588 1
a2588 1
			   &objfile -> static_psymbols,
d2592 1
a2592 1
      add_psymbol_to_list (dip -> at_name, strlen (dip -> at_name),
d2594 1
a2594 1
			   &objfile -> static_psymbols,
d2602 1
a2602 1
      if (!dip -> has_at_byte_size)
d2604 1
a2604 1
      add_psymbol_to_list (dip -> at_name, strlen (dip -> at_name),
d2606 1
a2606 1
			   &objfile -> static_psymbols,
d2611 1
a2611 1
	  add_psymbol_to_list (dip -> at_name, strlen (dip -> at_name),
d2613 1
a2613 1
			       &objfile -> static_psymbols,
d2619 1
a2619 1

d2683 3
d2696 1
a2696 1
  
d2770 5
a2774 1
LOCAL FUNCTION
d2776 2
a2777 1
	scan_compilation_units -- build a psymtab entry for each compilation
d2779 3
a2781 1
DESCRIPTION
d2783 8
a2790 2
	This is the top level dwarf parsing routine for building partial
	symbol tables.
d2792 3
a2794 16
	It scans from the beginning of the DWARF table looking for the first
	TAG_compile_unit DIE, and then follows the sibling chain to locate
	each additional TAG_compile_unit DIE.
   
	For each TAG_compile_unit DIE it creates a partial symtab structure,
	calls a subordinate routine to collect all the compilation unit's
	global DIE's, file scope DIEs, typedef DIEs, etc, and then links the
	new partial symtab structure into the partial symbol table.  It also
	records the appropriate information in the partial symbol table entry
	to allow the chunk of DIE's and line number table for this compilation
	unit to be located and re-read later, to generate a complete symbol
	table entry for the compilation unit.

	Thus it effectively partitions up a chunk of DIE's for multiple
	compilation units into smaller DIE chunks and line number tables,
	and associates them with a partial symbol table entry.
d2796 1
a2796 1
NOTES
d2798 6
a2803 6
	If any compilation unit has no line number table associated with
	it for some reason (a missing at_stmt_list attribute, rather than
	just one with a value of zero, which is valid) then we ensure that
	the recorded file offset is zero so that the routine which later
	reads line number table fragments knows that there is no fragment
	to read.
d2805 1
a2805 1
RETURNS
d2807 1
a2807 1
	Returns no value.
d2857 2
a2858 2
				      objfile -> global_psymbols.next,
				      objfile -> static_psymbols.next);
d2860 4
a2863 4
	  pst -> texthigh = di.at_high_pc;
	  pst -> read_symtab_private = (char *)
	      obstack_alloc (&objfile -> psymbol_obstack,
			     sizeof (struct dwfinfo));
d2867 2
a2868 2
	  LNFOFF (pst)  = curlnoffset;
	  pst -> read_symtab = dwarf_psymtab_to_symtab;
d2874 4
a2877 4
	  pst -> n_global_syms = objfile -> global_psymbols.next -
	    (objfile -> global_psymbols.list + pst -> globals_offset);
	  pst -> n_static_syms = objfile -> static_psymbols.next - 
	    (objfile -> static_psymbols.list + pst -> statics_offset);
d2882 1
a2882 1
	  free_named_symtabs (pst -> filename);
d2884 1
a2884 1
      thisdie = nextdie;      
d2890 1
a2890 1
LOCAL FUNCTION
d2892 1
a2892 1
	new_symbol -- make a symbol table entry for a new symbol
d2894 1
a2894 1
SYNOPSIS
d2896 2
a2897 2
	static struct symbol *new_symbol (struct dieinfo *dip,
					  struct objfile *objfile)
d2899 1
a2899 1
DESCRIPTION
d2901 3
a2903 3
	Given a pointer to a DWARF information entry, figure out if we need
	to make a symbol table entry for it, and if so, create a new entry
	and return a pointer to it.
d2912 2
a2913 2
  
  if (dip -> at_name != NULL)
d2915 1
a2915 1
      sym = (struct symbol *) obstack_alloc (&objfile -> symbol_obstack,
d2919 1
a2919 1
      SYMBOL_NAME (sym) = create_name (dip -> at_name,
d2927 3
a2929 3
	 demangled form for future reference.  This is a typical time versus
	 space tradeoff, that was decided in favor of time because it sped up
	 C++ symbol lookups by a factor of about 20. */
d2932 2
a2933 2
      SYMBOL_INIT_DEMANGLED_NAME (sym, &objfile -> symbol_obstack);
      switch (dip -> die_tag)
d2936 1
a2936 1
	  SYMBOL_VALUE_ADDRESS (sym) = dip -> at_low_pc;
d2941 1
a2941 1
	  SYMBOL_VALUE_ADDRESS (sym) = dip -> at_low_pc;
d2943 1
a2943 1
	  if (dip -> at_prototyped)
d2946 1
a2946 1
	  if (dip -> die_tag == TAG_global_subroutine)
d2956 1
a2956 1
	  if (dip -> at_location != NULL)
d2965 1
a2965 1
	  if (dip -> at_location != NULL)
d2968 1
a2968 1
	      if (dip -> optimized_out)
d2972 1
a2972 1
	      else if (dip -> isreg)
d2976 1
a2976 1
	      else if (dip -> offreg)
d2979 1
a2979 1
		  SYMBOL_BASEREG (sym) = dip -> basereg;
d3000 1
a3000 1
	  if (dip -> at_location != NULL)
d3005 1
a3005 1
	  if (dip -> isreg)
d3009 1
a3009 1
	  else if (dip -> offreg)
d3012 1
a3012 1
	      SYMBOL_BASEREG (sym) = dip -> basereg;
d3048 1
a3048 1
LOCAL FUNCTION
d3050 1
a3050 1
	synthesize_typedef -- make a symbol table entry for a "fake" typedef
d3052 1
a3052 1
SYNOPSIS
d3054 3
a3056 3
	static void synthesize_typedef (struct dieinfo *dip,
					struct objfile *objfile,
					struct type *type);
d3058 1
a3058 1
DESCRIPTION
d3060 2
a3061 2
	Given a pointer to a DWARF information entry, synthesize a typedef
	for the name in the DIE, using the specified type.
d3063 2
a3064 2
	This is used for C++ class, structs, unions, and enumerations to
	set up the tag name as a type.
d3075 2
a3076 2
  
  if (dip -> at_name != NULL)
d3079 1
a3079 1
	obstack_alloc (&objfile -> symbol_obstack, sizeof (struct symbol));
d3082 1
a3082 1
      SYMBOL_NAME (sym) = create_name (dip -> at_name,
d3094 3
a3096 1
LOCAL FUNCTION
d3098 1
a3098 1
	decode_mod_fund_type -- decode a modified fundamental type
d3100 1
a3100 1
SYNOPSIS
d3102 1
a3102 1
	static struct type *decode_mod_fund_type (char *typedata)
d3104 6
a3109 1
DESCRIPTION
d3111 3
a3113 10
	Decode a block of data containing a modified fundamental
	type specification.  TYPEDATA is a pointer to the block,
	which starts with a length containing the size of the rest
	of the block.  At the end of the block is a fundmental type
	code value that gives the fundamental type.  Everything
	in between are type modifiers.

	We simply compute the number of modifiers and call the general
	function decode_modified_type to do the actual work.
*/
d3122 1
a3122 1
  
d3141 3
a3143 1
LOCAL FUNCTION
d3145 1
a3145 1
	decode_mod_u_d_type -- decode a modified user defined type
d3147 1
a3147 1
SYNOPSIS
d3149 1
a3149 1
	static struct type *decode_mod_u_d_type (char *typedata)
d3151 6
a3156 1
DESCRIPTION
d3158 3
a3160 10
	Decode a block of data containing a modified user defined
	type specification.  TYPEDATA is a pointer to the block,
	which consists of a two byte length, containing the size
	of the rest of the block.  At the end of the block is a
	four byte value that gives a reference to a user defined type.
	Everything in between are type modifiers.

	We simply compute the number of modifiers and call the general
	function decode_modified_type to do the actual work.
*/
d3169 1
a3169 1
  
d3188 3
a3190 1
LOCAL FUNCTION
d3192 1
a3192 1
	decode_modified_type -- decode modified user or fundamental type
d3194 2
a3195 1
SYNOPSIS
d3197 1
a3197 2
	static struct type *decode_modified_type (char *modifiers,
	    unsigned short modcount, int mtype)
d3199 8
a3206 1
DESCRIPTION
d3208 5
a3212 14
	Decode a modified type, either a modified fundamental type or
	a modified user defined type.  MODIFIERS is a pointer to the
	block of bytes that define MODCOUNT modifiers.  Immediately
	following the last modifier is a short containing the fundamental
	type or a long containing the reference to the user defined
	type.  Which one is determined by MTYPE, which is either
	AT_mod_fund_type or AT_mod_u_d_type to indicate what modified
	type we are generating.

	We call ourself recursively to generate each modified type,`
	until MODCOUNT reaches zero, at which point we have consumed
	all the modifiers and generate either the fundamental type or
	user defined type.  When the recursion unwinds, each modifier
	is applied in turn to generate the full modified type.
d3214 1
a3214 1
NOTES
d3216 3
a3218 3
	If we find a modifier that we don't recognize, and it is not one
	of those reserved for application specific use, then we issue a
	warning and simply ignore the modifier.
d3220 1
a3220 1
BUGS
d3222 1
a3222 1
	We currently ignore MOD_const and MOD_volatile.  (FIXME)
d3237 1
a3237 1
  
d3269 19
a3287 19
	  case MOD_pointer_to:
	    typep = lookup_pointer_type (typep);
	    break;
	  case MOD_reference_to:
	    typep = lookup_reference_type (typep);
	    break;
	  case MOD_const:
	    complain (&const_ignored, DIE_ID, DIE_NAME);  /* FIXME */
	    break;
	  case MOD_volatile:
	    complain (&volatile_ignored, DIE_ID, DIE_NAME); /* FIXME */
	    break;
	  default:
	    if (!(MOD_lo_user <= (unsigned char) modifier
		  && (unsigned char) modifier <= MOD_hi_user))
	      {
		complain (&unknown_type_modifier, DIE_ID, DIE_NAME, modifier);
	      }
	    break;
d3295 1
a3295 1
LOCAL FUNCTION
d3297 1
a3297 1
	decode_fund_type -- translate basic DWARF type to gdb base type
d3299 1
a3299 1
DESCRIPTION
d3301 3
a3303 3
	Given an integer that is one of the fundamental DWARF types,
	translate it to one of the basic internal gdb types and return
	a pointer to the appropriate gdb type (a "struct type *").
d3305 1
a3305 1
NOTES
d3307 7
a3313 7
	For robustness, if we are asked to translate a fundamental
	type that we are unprepared to deal with, we return int so
	callers can always depend upon a valid type being returned,
	and so gdb may at least do something reasonable by default.
	If the type is not in the range of those types defined as
	application specific types, we also issue a warning.
*/
d3320 1
a3320 1
  
d3327 1
a3327 1
    
d3336 1
a3336 1
    
d3340 1
a3340 1
    
d3348 1
a3348 1
    
d3356 1
a3356 1
    
d3360 1
a3360 1
    
d3368 1
a3368 1
    
d3372 1
a3372 1
    
d3380 1
a3380 1
    
d3384 1
a3384 1
    
d3400 1
a3400 1
    
d3404 1
a3404 1
    
d3408 1
a3408 1
    
d3412 1
a3412 1
    
d3416 1
a3416 1
    
d3420 1
a3420 1
    
d3431 1
a3431 1
    
d3437 1
a3437 1
LOCAL FUNCTION
d3439 1
a3439 1
	create_name -- allocate a fresh copy of a string on an obstack
d3441 1
a3441 1
DESCRIPTION
d3443 2
a3444 2
	Given a pointer to a string and a pointer to an obstack, allocates
	a fresh copy of the string on the specified obstack.
d3446 1
a3446 1
*/
d3464 1
a3464 3
LOCAL FUNCTION

	basicdieinfo -- extract the minimal die info from raw die data
d3466 1
a3466 1
SYNOPSIS
d3468 1
a3468 2
	void basicdieinfo (char *diep, struct dieinfo *dip,
			   struct objfile *objfile)
d3470 2
a3471 25
DESCRIPTION

	Given a pointer to raw DIE data, and a pointer to an instance of a
	die info structure, this function extracts the basic information
	from the DIE data required to continue processing this DIE, along
	with some bookkeeping information about the DIE.

	The information we absolutely must have includes the DIE tag,
	and the DIE length.  If we need the sibling reference, then we
	will have to call completedieinfo() to process all the remaining
	DIE information.

	Note that since there is no guarantee that the data is properly
	aligned in memory for the type of access required (indirection
	through anything other than a char pointer), and there is no
	guarantee that it is in the same byte order as the gdb host,
	we call a function which deals with both alignment and byte
	swapping issues.  Possibly inefficient, but quite portable.

	We also take care of some other basic things at this point, such
	as ensuring that the instance of the die info structure starts
	out completely zero'd and that curdie is initialized for use
	in error reporting if we have a problem with the current die.

NOTES
d3473 41
a3513 15
	All DIE's must have at least a valid length, thus the minimum
	DIE size is SIZEOF_DIE_LENGTH.  In order to have a valid tag, the
	DIE size must be at least SIZEOF_DIE_TAG larger, otherwise they
	are forced to be TAG_padding DIES.

	Padding DIES must be at least SIZEOF_DIE_LENGTH in length, implying
	that if a padding DIE is used for alignment and the amount needed is
	less than SIZEOF_DIE_LENGTH, then the padding DIE has to be big
	enough to align to the next alignment boundry.

	We do some basic sanity checking here, such as verifying that the
	length of the die would not cause it to overrun the recorded end of
	the buffer holding the DIE info.  If we find a DIE that is either
	too small or too large, we force it's length to zero which should
	cause the caller to take appropriate action.
d3524 6
a3529 6
  dip -> die = diep;
  dip -> die_ref = dbroff + (diep - dbbase);
  dip -> die_length = target_to_host (diep, SIZEOF_DIE_LENGTH, GET_UNSIGNED,
				      objfile);
  if ((dip -> die_length < SIZEOF_DIE_LENGTH) ||
      ((diep + dip -> die_length) > (dbbase + dbsize)))
d3531 2
a3532 2
      complain (&malformed_die, DIE_ID, DIE_NAME, dip -> die_length);
      dip -> die_length = 0;
d3534 1
a3534 1
  else if (dip -> die_length < (SIZEOF_DIE_LENGTH + SIZEOF_DIE_TAG))
d3536 1
a3536 1
      dip -> die_tag = TAG_padding;
d3541 2
a3542 2
      dip -> die_tag = target_to_host (diep, SIZEOF_DIE_TAG, GET_UNSIGNED,
				       objfile);
d3548 3
a3550 1
LOCAL FUNCTION
d3552 1
a3552 1
	completedieinfo -- finish reading the information for a given DIE
d3554 1
a3554 1
SYNOPSIS
d3556 1
a3556 1
	void completedieinfo (struct dieinfo *dip, struct objfile *objfile)
d3558 3
a3560 1
DESCRIPTION
d3562 6
a3567 10
	Given a pointer to an already partially initialized die info structure,
	scan the raw DIE data and finish filling in the die info structure
	from the various attributes found.
   
	Note that since there is no guarantee that the data is properly
	aligned in memory for the type of access required (indirection
	through anything other than a char pointer), and there is no
	guarantee that it is in the same byte order as the gdb host,
	we call a function which deals with both alignment and byte
	swapping issues.  Possibly inefficient, but quite portable.
d3569 1
a3569 1
NOTES
d3571 4
a3574 4
	Each time we are called, we increment the diecount variable, which
	keeps an approximate count of the number of dies processed for
	each compilation unit.  This information is presented to the user
	if the info_verbose flag is set.
d3588 1
a3588 1
  
d3590 2
a3591 2
  diep = dip -> die;
  end = diep + dip -> die_length;
d3606 2
a3607 2
	  dip -> at_fund_type = target_to_host (diep, nbytes, GET_UNSIGNED,
						objfile);
d3610 2
a3611 2
	  dip -> at_ordering = target_to_host (diep, nbytes, GET_UNSIGNED,
					       objfile);
d3614 2
a3615 2
	  dip -> at_bit_offset = target_to_host (diep, nbytes, GET_UNSIGNED,
						 objfile);
d3618 2
a3619 2
	  dip -> at_sibling = target_to_host (diep, nbytes, GET_UNSIGNED,
					      objfile);
d3622 3
a3624 3
	  dip -> at_stmt_list = target_to_host (diep, nbytes, GET_UNSIGNED,
						objfile);
	  dip -> has_at_stmt_list = 1;
d3627 4
a3630 4
	  dip -> at_low_pc = target_to_host (diep, nbytes, GET_UNSIGNED,
					     objfile);
	  dip -> at_low_pc += baseaddr;
	  dip -> has_at_low_pc = 1;
d3633 3
a3635 3
	  dip -> at_high_pc = target_to_host (diep, nbytes, GET_UNSIGNED,
					      objfile);
	  dip -> at_high_pc += baseaddr;
d3638 2
a3639 2
	  dip -> at_language = target_to_host (diep, nbytes, GET_UNSIGNED,
					       objfile);
d3642 2
a3643 2
	  dip -> at_user_def_type = target_to_host (diep, nbytes,
						    GET_UNSIGNED, objfile);
d3646 3
a3648 3
	  dip -> at_byte_size = target_to_host (diep, nbytes, GET_UNSIGNED,
						objfile);
	  dip -> has_at_byte_size = 1;
d3651 2
a3652 2
	  dip -> at_bit_size = target_to_host (diep, nbytes, GET_UNSIGNED,
					       objfile);
d3655 2
a3656 2
	  dip -> at_member = target_to_host (diep, nbytes, GET_UNSIGNED,
					     objfile);
d3659 2
a3660 2
	  dip -> at_discr = target_to_host (diep, nbytes, GET_UNSIGNED,
					    objfile);
d3663 1
a3663 1
	  dip -> at_location = diep;
d3666 1
a3666 1
	  dip -> at_mod_fund_type = diep;
d3669 1
a3669 1
	  dip -> at_subscr_data = diep;
d3672 1
a3672 1
	  dip -> at_mod_u_d_type = diep;
d3675 2
a3676 2
	  dip -> at_element_list = diep;
	  dip -> short_element_list = 0;
d3679 2
a3680 2
	  dip -> at_element_list = diep;
	  dip -> short_element_list = 1;
d3683 1
a3683 1
	  dip -> at_discr_value = diep;
d3686 1
a3686 1
	  dip -> at_string_length = diep;
d3689 1
a3689 1
	  dip -> at_name = diep;
d3694 2
a3695 2
	  dip -> at_comp_dir = strrchr (diep, ':');
	  if (dip -> at_comp_dir != NULL)
d3697 1
a3697 1
	      dip -> at_comp_dir++;
d3701 1
a3701 1
	      dip -> at_comp_dir = diep;
d3705 1
a3705 1
	  dip -> at_producer = diep;
d3708 2
a3709 2
	  dip -> at_start_scope = target_to_host (diep, nbytes, GET_UNSIGNED,
						  objfile);
d3712 2
a3713 2
	  dip -> at_stride_size = target_to_host (diep, nbytes, GET_UNSIGNED,
						  objfile);
d3716 2
a3717 2
	  dip -> at_src_info = target_to_host (diep, nbytes, GET_UNSIGNED,
					       objfile);
d3720 1
a3720 1
	  dip -> at_prototyped = diep;
d3765 1
a3765 1
LOCAL FUNCTION
d3767 1
a3767 1
	target_to_host -- swap in target data to host
d3769 1
a3769 1
SYNOPSIS
d3771 2
a3772 2
	target_to_host (char *from, int nbytes, int signextend,
			struct objfile *objfile)
d3774 1
a3774 1
DESCRIPTION
d3776 5
a3780 5
	Given pointer to data in target format in FROM, a byte count for
	the size of the data in NBYTES, a flag indicating whether or not
	the data is signed in SIGNEXTEND, and a pointer to the current
	objfile in OBJFILE, convert the data to host format and return
	the converted value.
d3782 1
a3782 1
NOTES
d3784 3
a3786 3
	FIXME:  If we read data that is known to be signed, and expect to
	use it as signed data, then we need to explicitly sign extend the
	result until the bfd library is able to do this for us.
d3788 1
a3788 1
	FIXME: Would a 32 bit target ever need an 8 byte result?
d3803 16
a3818 16
      case 8:
        rtnval = bfd_get_64 (objfile -> obfd, (bfd_byte *) from);
	break;
      case 4:
	rtnval = bfd_get_32 (objfile -> obfd, (bfd_byte *) from);
	break;
      case 2:
	rtnval = bfd_get_16 (objfile -> obfd, (bfd_byte *) from);
	break;
      case 1:
	rtnval = bfd_get_8 (objfile -> obfd, (bfd_byte *) from);
	break;
      default:
	complain (&no_bfd_get_N, DIE_ID, DIE_NAME, nbytes);
	rtnval = 0;
	break;
d3825 1
a3825 1
LOCAL FUNCTION
d3827 1
a3827 1
	attribute_size -- compute size of data for a DWARF attribute
d3829 1
a3829 1
SYNOPSIS
d3831 1
a3831 1
	static int attribute_size (unsigned int attr)
d3833 1
a3833 1
DESCRIPTION
d3835 3
a3837 3
	Given a DWARF attribute in ATTR, compute the size of the first
	piece of data associated with this attribute and return that
	size.
d3839 1
a3839 1
	Returns -1 for unrecognized attributes.
d3853 23
a3875 23
      case FORM_STRING:		/* A variable length field is next */
        nbytes = 0;
	break;
      case FORM_DATA2:		/* Next 2 byte field is the data itself */
      case FORM_BLOCK2:		/* Next 2 byte field is a block length */
	nbytes = 2;
	break;
      case FORM_DATA4:		/* Next 4 byte field is the data itself */
      case FORM_BLOCK4:		/* Next 4 byte field is a block length */
      case FORM_REF:		/* Next 4 byte field is a DIE offset */
	nbytes = 4;
	break;
      case FORM_DATA8:		/* Next 8 byte field is the data itself */
	nbytes = 8;
	break;
      case FORM_ADDR:		/* Next field size is target sizeof(void *) */
	nbytes = TARGET_FT_POINTER_SIZE (objfile);
	break;
      default:
	complain (&unknown_attribute_form, DIE_ID, DIE_NAME, form);
	nbytes = -1;
	break;
      }
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 pre reformat
@
text
@a2660 1
/* *INDENT-OFF* */
a2723 1
/* *INDENT-ON* */
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d7 1
a7 1
   This file is part of GDB.
d9 4
a12 4
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d14 4
a17 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
d19 3
a21 3
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d25 2
a26 2
   FIXME: Do we need to generate dependencies in partial symtabs?
   (Perhaps we don't need to).
d28 5
a32 5
   FIXME: Resolve minor differences between what information we put in the
   partial symbol table and what dbxread puts in.  For example, we don't yet
   put enum constants there.  And dbxread seems to invent a lot of typedefs
   we never see.  Use the new printpsym command to see the partial symbol table
   contents.
d34 2
a35 2
   FIXME: Figure out a better way to tell gdb about the name of the function
   contain the user's entry point (I.E. main())
d37 2
a38 2
   FIXME: See other FIXME's and "ifdef 0" scattered throughout the code for
   other things to work on, if you get bored. :-)
d40 1
a40 1
 */
d50 1
a50 1
#include "expression.h"		/* Needed for enum exp_opcode in language.h, sigh... */
d248 2
a249 2
extern int info_verbose;	/* From main.c; nonzero => verbose */
extern char *warning_pre_print;	/* From utils.c */
d275 1
a275 1

d277 1
a277 1

d280 48
a327 46
struct dieinfo
  {
    char *die;			/* Pointer to the raw DIE data */
    unsigned long die_length;	/* Length of the raw DIE data */
    DIE_REF die_ref;		/* Offset of this DIE */
    unsigned short die_tag;	/* Tag for this DIE */
    unsigned long at_padding;
    unsigned long at_sibling;
    BLOCK *at_location;
    char *at_name;
    unsigned short at_fund_type;
    BLOCK *at_mod_fund_type;
    unsigned long at_user_def_type;
    BLOCK *at_mod_u_d_type;
    unsigned short at_ordering;
    BLOCK *at_subscr_data;
    unsigned long at_byte_size;
    unsigned short at_bit_offset;
    unsigned long at_bit_size;
    BLOCK *at_element_list;
    unsigned long at_stmt_list;
    CORE_ADDR at_low_pc;
    CORE_ADDR at_high_pc;
    unsigned long at_language;
    unsigned long at_member;
    unsigned long at_discr;
    BLOCK *at_discr_value;
    BLOCK *at_string_length;
    char *at_comp_dir;
    char *at_producer;
    unsigned long at_start_scope;
    unsigned long at_stride_size;
    unsigned long at_src_info;
    char *at_prototyped;
    unsigned int has_at_low_pc:1;
    unsigned int has_at_stmt_list:1;
    unsigned int has_at_byte_size:1;
    unsigned int short_element_list:1;

    /* Kludge to identify register variables */

    unsigned int isreg;

    /* Kludge to identify optimized out variables */

    unsigned int optimized_out;
d329 1
a329 2
    /* Kludge to identify basereg references.
       Nonzero if we have an offset relative to a basereg.  */
d331 1
a331 1
    unsigned int offreg;
d333 2
a334 4
    /* Kludge to identify which base register is it relative to.  */

    unsigned int basereg;
  };
d336 1
a336 1
static int diecount;		/* Approximate count of dies for compilation unit */
d339 4
a342 4
static char *dbbase;		/* Base pointer to dwarf info */
static int dbsize;		/* Size of dwarf info in bytes */
static int dbroff;		/* Relative offset from start of .debug section */
static char *lnbase;		/* Base pointer to line section */
d356 21
a376 22
struct dwfinfo
  {
    /* Always the absolute file offset to the start of the ".debug"
       section for the file containing the DIE's being accessed.  */
    file_ptr dbfoff;
    /* Relative offset from the start of the ".debug" section to the
       first DIE to be accessed.  When building the partial symbol
       table, this value will be zero since we are accessing the
       entire ".debug" section.  When expanding a partial symbol
       table entry, this value will be the offset to the first
       DIE for the compilation unit containing the symbol that
       triggers the expansion.  */
    int dbroff;
    /* The size of the chunk of DIE's being examined, in bytes.  */
    int dblength;
    /* The absolute file offset to the line table fragment.  Ignored
       when building partial symbol tables, but used when expanding
       them, and contains the absolute file offset to the fragment
       of the ".line" section containing the line numbers for the
       current compilation unit.  */
    file_ptr lnfoff;
  };
d433 1
a433 1
static struct type *ftypes[FT_NUM_MEMBERS];	/* Fundamental types */
d458 1
a458 1
  target_to_host PARAMS ((char *, int, int, struct objfile *));
d509 1
a509 1
  decode_array_element_type PARAMS ((char *));
d512 1
a512 1
  decode_subscript_data_item PARAMS ((char *, char *));
d518 1
a518 1
read_tag_pointer_type PARAMS ((struct dieinfo * dip));
d521 1
a521 1
read_tag_string_type PARAMS ((struct dieinfo * dip));
d530 1
a530 1
  struct_type PARAMS ((struct dieinfo *, char *, char *, struct objfile *));
d533 1
a533 1
  enum_type PARAMS ((struct dieinfo *, struct objfile *));
d539 1
a539 1
  decode_die_type PARAMS ((struct dieinfo *));
d542 1
a542 1
  decode_mod_fund_type PARAMS ((char *));
d545 1
a545 1
  decode_mod_u_d_type PARAMS ((char *));
d548 1
a548 1
  decode_modified_type PARAMS ((char *, unsigned int, int));
d551 1
a551 1
  decode_fund_type PARAMS ((unsigned int));
d554 1
a554 1
  create_name PARAMS ((char *, struct obstack *));
d557 1
a557 1
  lookup_utype PARAMS ((DIE_REF));
d560 1
a560 1
  alloc_utype PARAMS ((DIE_REF, struct type *));
d563 1
a563 1
  new_symbol PARAMS ((struct dieinfo *, struct objfile *));
d576 1
a576 1
  dwarf_fundamental_type PARAMS ((struct objfile *, int));
d581 1
a581 1
   LOCAL FUNCTION
d583 1
a583 1
   dwarf_fundamental_type -- lookup or create a fundamental type
d585 1
a585 1
   SYNOPSIS
d587 2
a588 2
   struct type *
   dwarf_fundamental_type (struct objfile *objfile, int typeid)
d590 1
a590 1
   DESCRIPTION
d592 14
a605 5
   DWARF version 1 doesn't supply any fundamental type information,
   so gdb has to construct such types.  It has a fixed number of
   fundamental types that it knows how to construct, which is the
   union of all types that it knows how to construct for all languages
   that it knows about.  These are enumerated in gdbtypes.h.
d607 1
a607 8
   As an example, assume we find a DIE that references a DWARF
   fundamental type of FT_integer.  We first look in the ftypes
   array to see if we already have such a type, indexed by the
   gdb internal value of FT_INTEGER.  If so, we simply return a
   pointer to that type.  If not, then we ask an appropriate
   language dependent routine to create a type FT_INTEGER, using
   defaults reasonable for the current target machine, and install
   that type in ftypes for future reference.
d609 1
a609 1
   RETURNS
d611 1
a611 3
   Pointer to a fundamental type.

 */
d629 1
a629 1
      ftypes[typeid] = cu_language_defn->la_fund_type (objfile, typeid);
d637 1
a637 1
   LOCAL FUNCTION
d639 1
a639 1
   set_cu_language -- set local copy of language for compilation unit
d641 1
a641 1
   SYNOPSIS
d643 2
a644 2
   void
   set_cu_language (struct dieinfo *dip)
d646 1
a646 1
   DESCRIPTION
d648 3
a650 3
   Decode the language attribute for a compilation unit DIE and
   remember what the language was.  We use this at various times
   when processing DIE's for a given compilation unit.
d652 1
a652 1
   RETURNS
d654 1
a654 1
   No return value.
d662 1
a662 1
  switch (dip->at_language)
d664 28
a691 28
    case LANG_C89:
    case LANG_C:
      cu_language = language_c;
      break;
    case LANG_C_PLUS_PLUS:
      cu_language = language_cplus;
      break;
    case LANG_CHILL:
      cu_language = language_chill;
      break;
    case LANG_MODULA2:
      cu_language = language_m2;
      break;
    case LANG_FORTRAN77:
    case LANG_FORTRAN90:
      cu_language = language_fortran;
      break;
    case LANG_ADA83:
    case LANG_COBOL74:
    case LANG_COBOL85:
    case LANG_PASCAL83:
      /* We don't know anything special about these yet. */
      cu_language = language_unknown;
      break;
    default:
      /* If no at_language, try to deduce one from the filename */
      cu_language = deduce_language_from_filename (dip->at_name);
      break;
d698 1
a698 1
   GLOBAL FUNCTION
d700 1
a700 1
   dwarf_build_psymtabs -- build partial symtabs from DWARF debug info
d702 1
a702 1
   SYNOPSIS
d704 4
a707 4
   void dwarf_build_psymtabs (struct objfile *objfile,
   struct section_offsets *section_offsets,
   int mainline, file_ptr dbfoff, unsigned int dbfsize,
   file_ptr lnoffset, unsigned int lnsize)
d709 1
a709 1
   DESCRIPTION
d711 2
a712 2
   This function is called upon to build partial symtabs from files
   containing DIE's (Dwarf Information Entries) and DWARF line numbers.
d714 7
a720 7
   It is passed a bfd* containing the DIES
   and line number information, the corresponding filename for that
   file, a base address for relocating the symbols, a flag indicating
   whether or not this debugging information is from a "main symbol
   table" rather than a shared library or dynamically linked file,
   and file offset/size pairs for the DIE information and line number
   information.
d722 1
a722 1
   RETURNS
d724 1
a724 1
   No return value.
d741 1
a741 1

d753 1
a753 1

d757 3
a759 3

  if (mainline || objfile->global_psymbols.size == 0 ||
      objfile->static_psymbols.size == 0)
d763 1
a763 1

d772 1
a772 1

d774 1
a774 1

d781 1
a781 1
   LOCAL FUNCTION
d783 1
a783 1
   read_lexical_block_scope -- process all dies in a lexical block
d785 1
a785 1
   SYNOPSIS
d787 2
a788 2
   static void read_lexical_block_scope (struct dieinfo *dip,
   char *thisdie, char *enddie)
d790 1
a790 1
   DESCRIPTION
d792 2
a793 2
   Process all the DIES contained within a lexical block scope.
   Start a new scope, process the dies, and then close the scope.
d806 2
a807 2
  push_context (0, dip->at_low_pc);
  process_dies (thisdie + dip->die_length, enddie, objfile);
d811 2
a812 2
      finish_block (0, &local_symbols, new->old_blocks, new->start_addr,
		    dip->at_high_pc, objfile);
d814 1
a814 1
  local_symbols = new->locals;
d819 1
a819 1
   LOCAL FUNCTION
d821 1
a821 1
   lookup_utype -- look up a user defined type from die reference
d823 1
a823 1
   SYNOPSIS
d825 1
a825 1
   static type *lookup_utype (DIE_REF die_ref)
d827 1
a827 1
   DESCRIPTION
d829 5
a833 5
   Given a DIE reference, lookup the user defined type associated with
   that DIE, if it has been registered already.  If not registered, then
   return NULL.  Alloc_utype() can be called to register an empty
   type for this reference, which will be filled in later when the
   actual referenced DIE is processed.
d842 1
a842 1

d858 1
a858 1
   LOCAL FUNCTION
d860 1
a860 1
   alloc_utype  -- add a user defined type for die reference
d862 1
a862 1
   SYNOPSIS
d864 1
a864 1
   static type *alloc_utype (DIE_REF die_ref, struct type *utypep)
d866 1
a866 1
   DESCRIPTION
d868 4
a871 4
   Given a die reference DIE_REF, and a possible pointer to a user
   defined type UTYPEP, register that this reference has a user
   defined type and either use the specified type in UTYPEP or
   make a new empty type that will be filled in later.
d873 2
a874 2
   We should only be called after calling lookup_utype() to verify that
   there is not currently a type registered for DIE_REF.
d884 1
a884 1

d910 1
a910 1
   LOCAL FUNCTION
d912 1
a912 1
   free_utypes -- free the utypes array and reset pointer & count
d914 1
a914 1
   SYNOPSIS
d916 1
a916 1
   static void free_utypes (PTR dummy)
d918 1
a918 1
   DESCRIPTION
d920 3
a922 3
   Called via do_cleanups to free the utypes array, reset the pointer to NULL,
   and set numutypes back to zero.  This ensures that the utypes does not get
   referenced after being freed.
d937 1
a937 1
   LOCAL FUNCTION
d939 1
a939 1
   decode_die_type -- return a type for a specified die
d941 1
a941 1
   SYNOPSIS
d943 1
a943 1
   static struct type *decode_die_type (struct dieinfo *dip)
d945 1
a945 1
   DESCRIPTION
d947 3
a949 3
   Given a pointer to a die information structure DIP, decode the
   type of the die and return a pointer to the decoded type.  All
   dies without specific types default to type int.
d957 2
a958 2

  if (dip->at_fund_type != 0)
d960 1
a960 1
      type = decode_fund_type (dip->at_fund_type);
d962 1
a962 1
  else if (dip->at_mod_fund_type != NULL)
d964 1
a964 1
      type = decode_mod_fund_type (dip->at_mod_fund_type);
d966 1
a966 1
  else if (dip->at_user_def_type)
d968 1
a968 1
      if ((type = lookup_utype (dip->at_user_def_type)) == NULL)
d970 1
a970 1
	  type = alloc_utype (dip->at_user_def_type, NULL);
d973 1
a973 1
  else if (dip->at_mod_u_d_type)
d975 1
a975 1
      type = decode_mod_u_d_type (dip->at_mod_u_d_type);
d986 1
a986 1
   LOCAL FUNCTION
d988 1
a988 1
   struct_type -- compute and return the type for a struct or union
d990 1
a990 1
   SYNOPSIS
d992 2
a993 2
   static struct type *struct_type (struct dieinfo *dip, char *thisdie,
   char *enddie, struct objfile *objfile)
d995 1
a995 1
   DESCRIPTION
d997 5
a1001 5
   Given pointer to a die information structure for a die which
   defines a union or structure (and MUST define one or the other),
   and pointers to the raw die data that define the range of dies which
   define the members, compute and return the user defined type for the
   structure or union.
d1012 4
a1015 5
  struct nextfield
    {
      struct nextfield *next;
      struct field field;
    };
d1023 2
a1024 2

  if ((type = lookup_utype (dip->die_ref)) == NULL)
d1027 1
a1027 1
      type = alloc_utype (dip->die_ref, NULL);
d1029 2
a1030 2
  INIT_CPLUS_SPECIFIC (type);
  switch (dip->die_tag)
d1032 14
a1045 14
    case TAG_class_type:
      TYPE_CODE (type) = TYPE_CODE_CLASS;
      break;
    case TAG_structure_type:
      TYPE_CODE (type) = TYPE_CODE_STRUCT;
      break;
    case TAG_union_type:
      TYPE_CODE (type) = TYPE_CODE_UNION;
      break;
    default:
      /* Should never happen */
      TYPE_CODE (type) = TYPE_CODE_UNDEF;
      complain (&missing_tag, DIE_ID, DIE_NAME);
      break;
d1050 3
a1052 3
  if (dip->at_name != NULL
      && *dip->at_name != '~'
      && *dip->at_name != '.')
d1054 2
a1055 2
      TYPE_TAG_NAME (type) = obconcat (&objfile->type_obstack,
				       "", "", dip->at_name);
d1062 2
a1063 2
  TYPE_LENGTH (type) = dip->at_byte_size;
  thisdie += dip->die_length;
d1085 1
a1085 1
	  new->next = list;
d1088 3
a1090 3
	  list->field.name =
	    obsavestring (mbr.at_name, strlen (mbr.at_name),
			  &objfile->type_obstack);
d1098 4
a1101 4
	         additional bit offset from the MSB of the containing
	         anonymous object to the MSB of the field.  We don't
	         have to do anything special since we don't need to
	         know the size of the anonymous object. */
d1107 7
a1113 7
	         at_bit_size, so that we know we are in fact dealing
	         with a bitfield.  Compute the bit offset to the MSB
	         of the anonymous object, subtract off the number of
	         bits from the MSB of the field to the MSB of the
	         object, and then subtract off the number of bits of
	         the field itself.  The result is the bit offset of
	         the LSB of the field. */
d1119 2
a1120 2
		         the bit field is explicit, so use the
		         indicated size (in bytes). */
d1126 5
a1130 5
		         the bit field matches the size of an object
		         of the bit field's type.  DWARF allows
		         at_byte_size to be left out in such cases, as
		         a debug information size optimization. */
		      anonymous_size = TYPE_LENGTH (list->field.type);
d1159 1
a1159 1
      for (n = nfields; list; list = list->next)
d1161 2
a1162 2
	  TYPE_FIELD (type, --n) = list->field;
	}
d1169 1
a1169 1
   LOCAL FUNCTION
d1171 1
a1171 1
   read_structure_scope -- process all dies within struct or union
d1173 1
a1173 1
   SYNOPSIS
d1175 2
a1176 2
   static void read_structure_scope (struct dieinfo *dip,
   char *thisdie, char *enddie, struct objfile *objfile)
d1178 1
a1178 1
   DESCRIPTION
d1180 4
a1183 4
   Called when we find the DIE that starts a structure or union
   scope (definition) to process all dies that define the members
   of the structure or union.  DIP is a pointer to the die info
   struct for the DIE that names the structure or union.
d1185 1
a1185 13
   NOTES

   Note that we need to call struct_type regardless of whether or not
   the DIE has an at_name attribute, since it might be an anonymous
   structure or union.  This gets the type entered into our set of
   user defined types.

   However, if the structure is incomplete (an opaque struct/union)
   then suppress creating a symbol table entry for it since gdb only
   wants to find the one with the complete definition.  Note that if
   it is complete, we just call new_symbol, which does it's own
   checking about whether the struct/union is anonymous or not (and
   suppresses creating a symbol table entry itself).
d1187 12
d1210 1
a1210 1

d1228 1
a1228 1
   LOCAL FUNCTION
d1230 1
a1230 1
   decode_array_element_type -- decode type of the array elements
d1232 1
a1232 1
   SYNOPSIS
d1234 1
a1234 1
   static struct type *decode_array_element_type (char *scan, char *end)
d1236 1
a1236 1
   DESCRIPTION
d1238 5
a1242 5
   As the last step in decoding the array subscript information for an
   array DIE, we need to decode the type of the array elements.  We are
   passed a pointer to this last part of the subscript information and
   must return the appropriate type.  If the type attribute is not
   recognized, just warn about the problem and return type int.
d1254 1
a1254 1

d1267 24
a1290 24
	case AT_fund_type:
	  fundtype = target_to_host (scan, nbytes, GET_UNSIGNED,
				     current_objfile);
	  typep = decode_fund_type (fundtype);
	  break;
	case AT_mod_fund_type:
	  typep = decode_mod_fund_type (scan);
	  break;
	case AT_user_def_type:
	  die_ref = target_to_host (scan, nbytes, GET_UNSIGNED,
				    current_objfile);
	  if ((typep = lookup_utype (die_ref)) == NULL)
	    {
	      typep = alloc_utype (die_ref, NULL);
	    }
	  break;
	case AT_mod_u_d_type:
	  typep = decode_mod_u_d_type (scan);
	  break;
	default:
	  complain (&bad_array_element_type, DIE_ID, DIE_NAME, attribute);
	  typep = dwarf_fundamental_type (current_objfile, FT_INTEGER);
	  break;
	}
d1297 1
a1297 1
   LOCAL FUNCTION
d1299 1
a1299 1
   decode_subscript_data_item -- decode array subscript item
d1301 1
a1301 1
   SYNOPSIS
d1303 2
a1304 2
   static struct type *
   decode_subscript_data_item (char *scan, char *end)
d1306 1
a1306 1
   DESCRIPTION
d1308 27
a1334 7
   The array subscripts and the data type of the elements of an
   array are described by a list of data items, stored as a block
   of contiguous bytes.  There is a data item describing each array
   dimension, and a final data item describing the element type.
   The data items are ordered the same as their appearance in the
   source (I.E. leftmost dimension first, next to leftmost second,
   etc).
d1336 2
a1337 22
   The data items describing each array dimension consist of four
   parts: (1) a format specifier, (2) type type of the subscript
   index, (3) a description of the low bound of the array dimension,
   and (4) a description of the high bound of the array dimension.

   The last data item is the description of the type of each of
   the array elements.

   We are passed a pointer to the start of the block of bytes
   containing the remaining data items, and a pointer to the first
   byte past the data.  This function recursively decodes the
   remaining data items and returns a type.

   If we somehow fail to decode some data, we complain about it
   and return a type "array of int".

   BUGS
   FIXME:  This code only implements the forms currently used
   by the AT&T and GNU C compilers.

   The end pointer is supplied for error checking, maybe we should
   use it for that...
d1354 1
a1354 1

d1381 1
a1381 1
				     lowbound, highbound);
d1408 1
a1408 1
   LOCAL FUNCTION
d1410 1
a1410 1
   dwarf_read_array_type -- read TAG_array_type DIE
d1412 1
a1412 1
   SYNOPSIS
d1414 1
a1414 1
   static void dwarf_read_array_type (struct dieinfo *dip)
d1416 1
a1416 1
   DESCRIPTION
d1418 2
a1419 2
   Extract all information from a TAG_array_type DIE and add to
   the user defined type vector.
d1432 2
a1433 2

  if (dip->at_ordering != ORD_row_major)
d1438 1
a1438 1
  if ((sub = dip->at_subscr_data) != NULL)
d1445 1
a1445 1
      if ((utype = lookup_utype (dip->die_ref)) == NULL)
d1448 1
a1448 1
	  alloc_utype (dip->die_ref, type);
d1473 1
a1473 1
   LOCAL FUNCTION
d1475 1
a1475 1
   read_tag_pointer_type -- read TAG_pointer_type DIE
d1477 1
a1477 1
   SYNOPSIS
d1479 1
a1479 1
   static void read_tag_pointer_type (struct dieinfo *dip)
d1481 1
a1481 1
   DESCRIPTION
d1483 2
a1484 2
   Extract all information from a TAG_pointer_type DIE and add to
   the user defined type vector.
d1493 1
a1493 1

d1495 1
a1495 1
  if ((utype = lookup_utype (dip->die_ref)) == NULL)
d1498 1
a1498 1
      alloc_utype (dip->die_ref, utype);
d1507 1
a1507 1
      TYPE_LENGTH (utype) = TARGET_PTR_BIT / TARGET_CHAR_BIT;
d1514 1
a1514 1
   LOCAL FUNCTION
d1516 1
a1516 1
   read_tag_string_type -- read TAG_string_type DIE
d1518 1
a1518 1
   SYNOPSIS
d1520 1
a1520 1
   static void read_tag_string_type (struct dieinfo *dip)
d1522 1
a1522 1
   DESCRIPTION
d1524 4
a1527 4
   Extract all information from a TAG_string_type DIE and add to
   the user defined type vector.  It isn't really a user defined
   type, but it behaves like one, with other DIE's using an
   AT_user_def_type attribute to reference it.
d1540 1
a1540 1
  if (dip->has_at_byte_size)
d1543 1
a1543 1
      highbound = dip->at_byte_size - 1;
d1553 2
a1554 2

  utype = lookup_utype (dip->die_ref);
d1558 1
a1558 1
      utype = alloc_utype (dip->die_ref, (struct type *) NULL);
d1563 1
a1563 1
         is a blank one.  If not, complain and leave it alone. */
d1577 1
a1577 1
   LOCAL FUNCTION
d1579 1
a1579 1
   read_subroutine_type -- process TAG_subroutine_type dies
d1581 1
a1581 1
   SYNOPSIS
d1583 2
a1584 2
   static void read_subroutine_type (struct dieinfo *dip, char thisdie,
   char *enddie)
d1586 1
a1586 1
   DESCRIPTION
d1588 1
a1588 1
   Handle DIES due to C code like:
d1590 4
a1593 4
   struct foo {
   int (*funcp)(int a, long l);  (Generates TAG_subroutine_type DIE)
   int b;
   };
d1595 1
a1595 1
   NOTES
d1597 3
a1599 3
   The parameter DIES are currently ignored.  See if gdb has a way to
   include this info in it's type system, and decode them if so.  Is
   this what the type structure's "arg_types" field is for?  (FIXME)
d1610 1
a1610 1

d1618 1
a1618 1
  if ((ftype = lookup_utype (dip->die_ref)) == NULL)
d1621 1
a1621 1
         a new one and place it in the user defined types. */
d1623 1
a1623 1
      alloc_utype (dip->die_ref, ftype);
d1628 1
a1628 1
         into the correct type. */
d1641 1
a1641 1
   LOCAL FUNCTION
d1643 1
a1643 1
   read_enumeration -- process dies which define an enumeration
d1645 1
a1645 1
   SYNOPSIS
d1647 2
a1648 2
   static void read_enumeration (struct dieinfo *dip, char *thisdie,
   char *enddie, struct objfile *objfile)
d1650 1
a1650 1
   DESCRIPTION
d1652 2
a1653 2
   Given a pointer to a die which begins an enumeration, process all
   the dies that define the members of the enumeration.
d1655 1
a1655 1
   NOTES
d1657 3
a1659 3
   Note that we need to call enum_type regardless of whether or not we
   have a symbol, since we might have an enum without a tag name (thus
   no symbol for the tagname).
d1671 1
a1671 1

d1686 1
a1686 1
   LOCAL FUNCTION
d1688 1
a1688 1
   enum_type -- decode and return a type for an enumeration
d1690 1
a1690 1
   SYNOPSIS
d1692 1
a1692 1
   static type *enum_type (struct dieinfo *dip, struct objfile *objfile)
d1694 1
a1694 1
   DESCRIPTION
d1696 7
a1702 3
   Given a pointer to a die information structure for the die which
   starts an enumeration, process all the dies that define the members
   of the enumeration and return a type pointer for the enumeration.
d1704 1
a1704 3
   At the same time, for each member of the enumeration, create a
   symbol for it with namespace VAR_NAMESPACE and class LOC_CONST,
   and give it the type of the enumeration itself.
d1706 7
a1712 9
   NOTES

   Note that the DWARF specification explicitly mandates that enum
   constants occur in reverse order from the source program order,
   for "consistency" and because this ordering is easier for many
   compilers to generate. (Draft 6, sec 3.8.5, Enumeration type
   Entries).  Because gdb wants to see the enum members in program
   source order, we have to ensure that the order gets reversed while
   we are processing them.
d1721 4
a1724 5
  struct nextfield
    {
      struct nextfield *next;
      struct field field;
    };
d1735 2
a1736 2

  if ((type = lookup_utype (dip->die_ref)) == NULL)
d1739 1
a1739 1
      type = alloc_utype (dip->die_ref, NULL);
d1745 3
a1747 3
  if (dip->at_name != NULL
      && *dip->at_name != '~'
      && *dip->at_name != '.')
d1749 2
a1750 2
      TYPE_TAG_NAME (type) = obconcat (&objfile->type_obstack,
				       "", "", dip->at_name);
d1752 1
a1752 1
  if (dip->at_byte_size != 0)
d1754 1
a1754 1
      TYPE_LENGTH (type) = dip->at_byte_size;
d1756 1
a1756 1
  if ((scan = dip->at_element_list) != NULL)
d1758 1
a1758 1
      if (dip->short_element_list)
d1772 1
a1772 1
	  new->next = list;
d1780 2
a1781 2
	  list->field.name = obsavestring (scan, strlen (scan),
					   &objfile->type_obstack);
d1788 1
a1788 1
	  SYMBOL_NAME (sym) = create_name (list->field.name,
d1800 4
a1803 4
         where we reverse the order, by pulling the members off the list in
         reverse order from how they were inserted.  If we have no fields
         (this is apparently possible in C++) then skip building a field
         vector. */
d1812 1
a1812 1
	  for (n = 0; (n < nfields) && (list != NULL); list = list->next)
d1814 2
a1815 2
	      TYPE_FIELD (type, n++) = list->field;
	    }
d1823 1
a1823 1
   LOCAL FUNCTION
d1825 1
a1825 1
   read_func_scope -- process all dies within a function scope
d1827 1
a1827 1
   DESCRIPTION
d1829 11
a1839 11
   Process all dies within a given function scope.  We are passed
   a die information structure pointer DIP for the die which
   starts the function scope, and pointers into the raw die data
   that define the dies within the function scope.

   For now, we ignore lexical block scopes within the function.
   The problem is that AT&T cc does not define a DWARF lexical
   block scope for the function itself, while gcc defines a
   lexical block scope for the function.  We need to think about
   how to handle this difference, or if it is even a problem.
   (FIXME)
d1850 1
a1850 1

d1855 1
a1855 1
  if (dip->at_name == NULL)
d1861 2
a1862 2
  if (objfile->ei.entry_point >= dip->at_low_pc &&
      objfile->ei.entry_point < dip->at_high_pc)
d1864 2
a1865 2
      objfile->ei.entry_func_lowpc = dip->at_low_pc;
      objfile->ei.entry_func_highpc = dip->at_high_pc;
d1867 1
a1867 1
  if (STREQ (dip->at_name, "main"))	/* FIXME: hardwired name */
d1869 2
a1870 2
      objfile->ei.main_func_lowpc = dip->at_low_pc;
      objfile->ei.main_func_highpc = dip->at_high_pc;
d1872 2
a1873 2
  new = push_context (0, dip->at_low_pc);
  new->name = new_symbol (dip, objfile);
d1875 1
a1875 1
  process_dies (thisdie + dip->die_length, enddie, objfile);
d1878 2
a1879 2
  finish_block (new->name, &local_symbols, new->old_blocks,
		new->start_addr, dip->at_high_pc, objfile);
d1886 1
a1886 1
   LOCAL FUNCTION
d1888 1
a1888 1
   handle_producer -- process the AT_producer attribute
d1890 1
a1890 1
   DESCRIPTION
d1892 2
a1893 2
   Perform any operations that depend on finding a particular
   AT_producer attribute.
d1938 1
a1938 1
   LOCAL FUNCTION
d1940 1
a1940 1
   read_file_scope -- process all dies within a file scope
d1942 1
a1942 1
   DESCRIPTION
d1944 12
a1955 12
   Process all dies within a given file scope.  We are passed a
   pointer to the die information structure for the die which
   starts the file scope, and pointers into the raw die data which
   mark the range of dies within the file scope.

   When the partial symbol table is built, the file offset for the line
   number table for each compilation unit is saved in the partial symbol
   table entry for that compilation unit.  As the symbols for each
   compilation unit are read, the line number table is read into memory
   and the variable lnbase is set to point to it.  Thus all we have to
   do is use lnbase to access the line number table for the current
   compilation unit.
d1967 3
a1969 3

  if (objfile->ei.entry_point >= dip->at_low_pc &&
      objfile->ei.entry_point < dip->at_high_pc)
d1971 2
a1972 2
      objfile->ei.entry_file_lowpc = dip->at_low_pc;
      objfile->ei.entry_file_highpc = dip->at_high_pc;
d1975 1
a1975 1
  if (dip->at_producer != NULL)
d1977 1
a1977 1
      handle_producer (dip->at_producer);
d1984 1
a1984 1
  start_symtab (dip->at_name, dip->at_comp_dir, dip->at_low_pc);
d1987 1
a1987 1
  process_dies (thisdie + dip->die_length, enddie, objfile);
d1989 1
a1989 1
  symtab = end_symtab (dip->at_high_pc, objfile, 0);
d1992 2
a1993 2
      symtab->language = cu_language;
    }
d1999 1
a1999 1
   LOCAL FUNCTION
d2001 1
a2001 1
   process_dies -- process a range of DWARF Information Entries
d2003 1
a2003 1
   SYNOPSIS
d2005 2
a2006 2
   static void process_dies (char *thisdie, char *enddie,
   struct objfile *objfile)
d2008 1
a2008 1
   DESCRIPTION
d2010 2
a2011 2
   Process all DIE's in a specified range.  May be (and almost
   certainly will be) called recursively.
d2022 1
a2022 1

d2054 2
a2055 2
	         unit, we are unable to handle nested compilation units
	         properly (FIXME).  */
d2102 1
a2102 1
   LOCAL FUNCTION
d2104 1
a2104 1
   decode_line_numbers -- decode a line number table fragment
d2106 1
a2106 1
   SYNOPSIS
d2108 2
a2109 2
   static void decode_line_numbers (char *tblscan, char *tblend,
   long length, long base, long line, long pc)
d2111 1
a2111 1
   DESCRIPTION
d2113 1
a2113 1
   Translate the DWARF line number information to gdb form.
d2115 2
a2116 2
   The ".line" section contains one or more line number tables, one for
   each ".line" section from the objects that were linked.
d2118 3
a2120 3
   The AT_stmt_list attribute for each TAG_source_file entry in the
   ".debug" section contains the offset into the ".line" section for the
   start of the table for that file.
d2122 1
a2122 1
   The table itself has the following structure:
d2124 2
a2125 2
   <table length><base address><source statement entry>
   4 bytes       4 bytes       10 bytes
d2127 2
a2128 2
   The table length is the total size of the table, including the 4 bytes
   for the length information.
d2130 2
a2131 2
   The base address is the address of the first instruction generated
   for the source file.
d2133 1
a2133 1
   Each source statement entry has the following structure:
d2135 2
a2136 2
   <line number><statement position><address delta>
   4 bytes      2 bytes             4 bytes
d2138 2
a2139 2
   The line number is relative to the start of the file, starting with
   line 1.
d2141 2
a2142 2
   The statement position either -1 (0xFFFF) or the number of characters
   from the beginning of the line to the beginning of the statement.
d2144 2
a2145 2
   The address delta is the difference between the base address and
   the address of the first instruction for the statement.
d2147 3
a2149 3
   Note that we must copy the bytes from the packed table to our local
   variables before attempting to use them, to avoid alignment problems
   on some machines, particularly RISC processors.
d2151 1
a2151 1
   BUGS
d2153 2
a2154 2
   Does gdb expect the line numbers to be sorted?  They are now by
   chance/luck, but are not required to be.  (FIXME)
d2156 2
a2157 2
   The line with number 0 is unused, gdb apparently can discover the
   span of the last line some other way. How?  (FIXME)
d2170 1
a2170 1

d2201 1
a2201 1
   LOCAL FUNCTION
d2203 1
a2203 1
   locval -- compute the value of a location attribute
d2205 1
a2205 1
   SYNOPSIS
d2207 1
a2207 1
   static int locval (struct dieinfo *dip)
d2209 1
a2209 1
   DESCRIPTION
d2211 16
a2226 5
   Given pointer to a string of bytes that define a location, compute
   the location and return the value.
   A location description containing no atoms indicates that the
   object is optimized out. The optimized_out flag is set for those,
   the return value is meaningless.
d2228 1
a2228 12
   When computing values involving the current value of the frame pointer,
   the value zero is used, which results in a value relative to the frame
   pointer, rather than the absolute value.  This is what GDB wants
   anyway.

   When the result is a register number, the isreg flag is set, otherwise
   it is cleared.  This is a kludge until we figure out a better
   way to handle the problem.  Gdb's design does not mesh well with the
   DWARF notion of a location computing interpreter, which is a shame
   because the flexibility goes unused.

   NOTES
d2230 2
a2231 2
   Note that stack[0] is unused except as a default error return.
   Note that stack overflow is not yet handled.
d2246 2
a2247 2

  loc = dip->at_location;
d2254 3
a2256 3
  dip->isreg = 0;
  dip->offreg = 0;
  dip->optimized_out = 1;
d2260 1
a2260 1
      dip->optimized_out = 0;
d2266 46
a2311 46
	case 0:
	  /* error */
	  loc = end;
	  break;
	case OP_REG:
	  /* push register (number) */
	  stack[++stacki]
	    = DWARF_REG_TO_REGNUM (target_to_host (loc, loc_value_size,
						   GET_UNSIGNED,
						   current_objfile));
	  loc += loc_value_size;
	  dip->isreg = 1;
	  break;
	case OP_BASEREG:
	  /* push value of register (number) */
	  /* Actually, we compute the value as if register has 0, so the
	     value ends up being the offset from that register.  */
	  dip->offreg = 1;
	  dip->basereg = target_to_host (loc, loc_value_size, GET_UNSIGNED,
					 current_objfile);
	  loc += loc_value_size;
	  stack[++stacki] = 0;
	  break;
	case OP_ADDR:
	  /* push address (relocated address) */
	  stack[++stacki] = target_to_host (loc, loc_value_size,
					    GET_UNSIGNED, current_objfile);
	  loc += loc_value_size;
	  break;
	case OP_CONST:
	  /* push constant (number)   FIXME: signed or unsigned! */
	  stack[++stacki] = target_to_host (loc, loc_value_size,
					    GET_SIGNED, current_objfile);
	  loc += loc_value_size;
	  break;
	case OP_DEREF2:
	  /* pop, deref and push 2 bytes (as a long) */
	  complain (&op_deref2, DIE_ID, DIE_NAME, stack[stacki]);
	  break;
	case OP_DEREF4:	/* pop, deref and push 4 bytes (as a long) */
	  complain (&op_deref4, DIE_ID, DIE_NAME, stack[stacki]);
	  break;
	case OP_ADD:		/* pop top 2 items, add, push result */
	  stack[stacki - 1] += stack[stacki];
	  stacki--;
	  break;
d2319 1
a2319 1
   LOCAL FUNCTION
d2321 1
a2321 1
   read_ofile_symtab -- build a full symtab entry from chunk of DIE's
d2323 1
a2323 1
   SYNOPSIS
d2325 1
a2325 1
   static void read_ofile_symtab (struct partial_symtab *pst)
d2327 1
a2327 1
   DESCRIPTION
d2329 5
a2333 5
   When expanding a partial symbol table entry to a full symbol table
   entry, this is the function that gets called to read in the symbols
   for the compilation unit.  A pointer to the newly constructed symtab,
   which is now the new first one on the objfile's symtab list, is
   stashed in the partial symbol table entry.
d2346 2
a2347 2
  abfd = pst->objfile->obfd;
  current_objfile = pst->objfile;
d2355 2
a2356 2
  dbroff = DBROFF (pst);
  foffset = DBFOFF (pst) + dbroff;
d2382 1
a2382 1
			       GET_UNSIGNED, pst->objfile);
d2393 1
a2393 1
  process_dies (dbbase, dbbase + dbsize, pst->objfile);
d2396 1
a2396 1
  pst->symtab = pst->objfile->symtabs;
d2401 1
a2401 1
   LOCAL FUNCTION
d2403 1
a2403 1
   psymtab_to_symtab_1 -- do grunt work for building a full symtab entry
d2405 1
a2405 1
   SYNOPSIS
d2407 1
a2407 1
   static void psymtab_to_symtab_1 (struct partial_symtab *pst)
d2409 1
a2409 1
   DESCRIPTION
d2411 2
a2412 2
   Called once for each partial symbol table entry that needs to be
   expanded into a full symbol table entry.
d2414 1
a2414 1
 */
d2422 1
a2422 1

d2428 1
a2428 1
		   pst->filename);
d2433 1
a2433 1
	  for (i = 0; i < pst->number_of_dependencies; i++)
d2435 1
a2435 1
	      if (!pst->dependencies[i]->readin)
d2445 1
a2445 1
				       pst->dependencies[i]->filename);
d2447 1
a2447 1
		      gdb_flush (gdb_stdout);	/* Flush output */
d2449 1
a2449 1
		  psymtab_to_symtab_1 (pst->dependencies[i]);
d2451 2
a2452 2
	    }
	  if (DBLENGTH (pst))	/* Otherwise it's a dummy */
d2455 2
a2456 2
	      old_chain = make_cleanup ((make_cleanup_func)
					really_free_pendings, 0);
d2464 1
a2464 1
	      sort_symtab_syms (pst->symtab);
d2467 1
a2467 1
	  pst->readin = 1;
d2474 1
a2474 1
   LOCAL FUNCTION
d2476 1
a2476 1
   dwarf_psymtab_to_symtab -- build a full symtab entry from partial one
d2478 1
a2478 1
   SYNOPSIS
d2480 1
a2480 1
   static void dwarf_psymtab_to_symtab (struct partial_symtab *pst)
d2482 1
a2482 1
   DESCRIPTION
d2484 3
a2486 3
   This is the DWARF support entry point for building a full symbol
   table entry from a partial symbol table entry.  We are passed a
   pointer to the partial symbol table entry that needs to be expanded.
d2488 1
a2488 1
 */
d2497 1
a2497 1
      if (pst->readin)
d2500 1
a2500 1
		   pst->filename);
d2504 1
a2504 1
	  if (DBLENGTH (pst) || pst->number_of_dependencies)
d2507 1
a2507 1
	         disconcerting pauses.  */
d2511 1
a2511 1
				   pst->filename);
d2514 1
a2514 1

d2516 8
a2523 8

#if 0				/* FIXME:  Check to see what dbxread is doing here and see if
				   we need to do an equivalent or is this something peculiar to
				   stabs/a.out format.
				   Match with global symbols.  This only needs to be done once,
				   after all of the symtabs and dependencies have been read in.
				 */
	      scan_file_globals (pst->objfile);
d2525 1
a2525 1

d2539 1
a2539 1
   LOCAL FUNCTION
d2541 1
a2541 1
   add_enum_psymbol -- add enumeration members to partial symbol table
d2543 1
a2543 1
   DESCRIPTION
d2545 4
a2548 4
   Given pointer to a DIE that is known to be for an enumeration,
   extract the symbolic names of the enumeration members and add
   partial symbols for them.
 */
d2559 2
a2560 2

  if ((scan = dip->at_element_list) != NULL)
d2562 1
a2562 1
      if (dip->short_element_list)
d2577 1
a2577 1
			       &objfile->static_psymbols, 0, 0, cu_language,
d2586 1
a2586 1
   LOCAL FUNCTION
d2588 1
a2588 1
   add_partial_symbol -- add symbol to partial symbol table
d2590 1
a2590 1
   DESCRIPTION
d2592 3
a2594 3
   Given a DIE, if it is one of the types that we want to
   add to a partial symbol table, finish filling in the die info
   and then add a partial symbol table entry for it.
d2596 1
a2596 1
   NOTES
d2598 2
a2599 2
   The caller must ensure that the DIE has a valid name attribute.
 */
d2606 1
a2606 1
  switch (dip->die_tag)
d2609 4
a2612 4
      add_psymbol_to_list (dip->at_name, strlen (dip->at_name),
			   VAR_NAMESPACE, LOC_BLOCK,
			   &objfile->global_psymbols,
			   0, dip->at_low_pc, cu_language, objfile);
d2615 1
a2615 1
      add_psymbol_to_list (dip->at_name, strlen (dip->at_name),
d2617 1
a2617 1
			   &objfile->global_psymbols,
d2621 4
a2624 4
      add_psymbol_to_list (dip->at_name, strlen (dip->at_name),
			   VAR_NAMESPACE, LOC_BLOCK,
			   &objfile->static_psymbols,
			   0, dip->at_low_pc, cu_language, objfile);
d2627 1
a2627 1
      add_psymbol_to_list (dip->at_name, strlen (dip->at_name),
d2629 1
a2629 1
			   &objfile->static_psymbols,
d2633 1
a2633 1
      add_psymbol_to_list (dip->at_name, strlen (dip->at_name),
d2635 1
a2635 1
			   &objfile->static_psymbols,
d2643 1
a2643 1
      if (!dip->has_at_byte_size)
d2645 1
a2645 1
      add_psymbol_to_list (dip->at_name, strlen (dip->at_name),
d2647 1
a2647 1
			   &objfile->static_psymbols,
d2652 1
a2652 1
	  add_psymbol_to_list (dip->at_name, strlen (dip->at_name),
d2654 1
a2654 1
			       &objfile->static_psymbols,
d2660 1
a2726 2


d2736 1
a2736 1

d2810 1
a2810 1
   LOCAL FUNCTION
d2812 1
a2812 1
   scan_compilation_units -- build a psymtab entry for each compilation
d2814 1
a2814 1
   DESCRIPTION
d2816 2
a2817 2
   This is the top level dwarf parsing routine for building partial
   symbol tables.
d2819 16
a2834 3
   It scans from the beginning of the DWARF table looking for the first
   TAG_compile_unit DIE, and then follows the sibling chain to locate
   each additional TAG_compile_unit DIE.
d2836 1
a2836 12
   For each TAG_compile_unit DIE it creates a partial symtab structure,
   calls a subordinate routine to collect all the compilation unit's
   global DIE's, file scope DIEs, typedef DIEs, etc, and then links the
   new partial symtab structure into the partial symbol table.  It also
   records the appropriate information in the partial symbol table entry
   to allow the chunk of DIE's and line number table for this compilation
   unit to be located and re-read later, to generate a complete symbol
   table entry for the compilation unit.

   Thus it effectively partitions up a chunk of DIE's for multiple
   compilation units into smaller DIE chunks and line number tables,
   and associates them with a partial symbol table entry.
d2838 6
a2843 1
   NOTES
d2845 1
a2845 6
   If any compilation unit has no line number table associated with
   it for some reason (a missing at_stmt_list attribute, rather than
   just one with a value of zero, which is valid) then we ensure that
   the recorded file offset is zero so that the routine which later
   reads line number table fragments knows that there is no fragment
   to read.
d2847 1
a2847 3
   RETURNS

   Returns no value.
d2897 2
a2898 2
				      objfile->global_psymbols.next,
				      objfile->static_psymbols.next);
d2900 4
a2903 4
	  pst->texthigh = di.at_high_pc;
	  pst->read_symtab_private = (char *)
	    obstack_alloc (&objfile->psymbol_obstack,
			   sizeof (struct dwfinfo));
d2907 2
a2908 2
	  LNFOFF (pst) = curlnoffset;
	  pst->read_symtab = dwarf_psymtab_to_symtab;
d2914 4
a2917 4
	  pst->n_global_syms = objfile->global_psymbols.next -
	    (objfile->global_psymbols.list + pst->globals_offset);
	  pst->n_static_syms = objfile->static_psymbols.next -
	    (objfile->static_psymbols.list + pst->statics_offset);
d2922 1
a2922 1
	  free_named_symtabs (pst->filename);
d2924 1
a2924 1
      thisdie = nextdie;
d2930 1
a2930 1
   LOCAL FUNCTION
d2932 1
a2932 1
   new_symbol -- make a symbol table entry for a new symbol
d2934 1
a2934 1
   SYNOPSIS
d2936 2
a2937 2
   static struct symbol *new_symbol (struct dieinfo *dip,
   struct objfile *objfile)
d2939 1
a2939 1
   DESCRIPTION
d2941 3
a2943 3
   Given a pointer to a DWARF information entry, figure out if we need
   to make a symbol table entry for it, and if so, create a new entry
   and return a pointer to it.
d2952 2
a2953 2

  if (dip->at_name != NULL)
d2955 1
a2955 1
      sym = (struct symbol *) obstack_alloc (&objfile->symbol_obstack,
d2959 1
a2959 1
      SYMBOL_NAME (sym) = create_name (dip->at_name,
d2967 3
a2969 3
         demangled form for future reference.  This is a typical time versus
         space tradeoff, that was decided in favor of time because it sped up
         C++ symbol lookups by a factor of about 20. */
d2972 2
a2973 2
      SYMBOL_INIT_DEMANGLED_NAME (sym, &objfile->symbol_obstack);
      switch (dip->die_tag)
d2976 1
a2976 1
	  SYMBOL_VALUE_ADDRESS (sym) = dip->at_low_pc;
d2981 1
a2981 1
	  SYMBOL_VALUE_ADDRESS (sym) = dip->at_low_pc;
d2983 1
a2983 1
	  if (dip->at_prototyped)
d2986 1
a2986 1
	  if (dip->die_tag == TAG_global_subroutine)
d2996 1
a2996 1
	  if (dip->at_location != NULL)
d3005 1
a3005 1
	  if (dip->at_location != NULL)
d3008 1
a3008 1
	      if (dip->optimized_out)
d3012 1
a3012 1
	      else if (dip->isreg)
d3016 1
a3016 1
	      else if (dip->offreg)
d3019 1
a3019 1
		  SYMBOL_BASEREG (sym) = dip->basereg;
d3040 1
a3040 1
	  if (dip->at_location != NULL)
d3045 1
a3045 1
	  if (dip->isreg)
d3049 1
a3049 1
	  else if (dip->offreg)
d3052 1
a3052 1
	      SYMBOL_BASEREG (sym) = dip->basereg;
d3088 1
a3088 1
   LOCAL FUNCTION
d3090 1
a3090 1
   synthesize_typedef -- make a symbol table entry for a "fake" typedef
d3092 1
a3092 1
   SYNOPSIS
d3094 3
a3096 3
   static void synthesize_typedef (struct dieinfo *dip,
   struct objfile *objfile,
   struct type *type);
d3098 1
a3098 1
   DESCRIPTION
d3100 2
a3101 2
   Given a pointer to a DWARF information entry, synthesize a typedef
   for the name in the DIE, using the specified type.
d3103 2
a3104 2
   This is used for C++ class, structs, unions, and enumerations to
   set up the tag name as a type.
d3115 2
a3116 2

  if (dip->at_name != NULL)
d3119 1
a3119 1
	obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));
d3122 1
a3122 1
      SYMBOL_NAME (sym) = create_name (dip->at_name,
d3134 1
a3134 1
   LOCAL FUNCTION
d3136 1
a3136 1
   decode_mod_fund_type -- decode a modified fundamental type
d3138 1
a3138 1
   SYNOPSIS
d3140 1
a3140 1
   static struct type *decode_mod_fund_type (char *typedata)
d3142 1
a3142 8
   DESCRIPTION

   Decode a block of data containing a modified fundamental
   type specification.  TYPEDATA is a pointer to the block,
   which starts with a length containing the size of the rest
   of the block.  At the end of the block is a fundmental type
   code value that gives the fundamental type.  Everything
   in between are type modifiers.
d3144 10
a3153 3
   We simply compute the number of modifiers and call the general
   function decode_modified_type to do the actual work.
 */
d3162 1
a3162 1

d3181 1
a3181 1
   LOCAL FUNCTION
d3183 1
a3183 1
   decode_mod_u_d_type -- decode a modified user defined type
d3185 1
a3185 1
   SYNOPSIS
d3187 1
a3187 1
   static struct type *decode_mod_u_d_type (char *typedata)
d3189 1
a3189 8
   DESCRIPTION

   Decode a block of data containing a modified user defined
   type specification.  TYPEDATA is a pointer to the block,
   which consists of a two byte length, containing the size
   of the rest of the block.  At the end of the block is a
   four byte value that gives a reference to a user defined type.
   Everything in between are type modifiers.
d3191 10
a3200 3
   We simply compute the number of modifiers and call the general
   function decode_modified_type to do the actual work.
 */
d3209 1
a3209 1

d3228 1
a3228 1
   LOCAL FUNCTION
d3230 1
a3230 1
   decode_modified_type -- decode modified user or fundamental type
d3232 1
a3232 1
   SYNOPSIS
d3234 2
a3235 2
   static struct type *decode_modified_type (char *modifiers,
   unsigned short modcount, int mtype)
d3237 1
a3237 1
   DESCRIPTION
d3239 14
a3252 8
   Decode a modified type, either a modified fundamental type or
   a modified user defined type.  MODIFIERS is a pointer to the
   block of bytes that define MODCOUNT modifiers.  Immediately
   following the last modifier is a short containing the fundamental
   type or a long containing the reference to the user defined
   type.  Which one is determined by MTYPE, which is either
   AT_mod_fund_type or AT_mod_u_d_type to indicate what modified
   type we are generating.
d3254 1
a3254 7
   We call ourself recursively to generate each modified type,`
   until MODCOUNT reaches zero, at which point we have consumed
   all the modifiers and generate either the fundamental type or
   user defined type.  When the recursion unwinds, each modifier
   is applied in turn to generate the full modified type.

   NOTES
d3256 3
a3258 3
   If we find a modifier that we don't recognize, and it is not one
   of those reserved for application specific use, then we issue a
   warning and simply ignore the modifier.
d3260 1
a3260 1
   BUGS
d3262 1
a3262 1
   We currently ignore MOD_const and MOD_volatile.  (FIXME)
d3277 1
a3277 1

d3309 19
a3327 19
	case MOD_pointer_to:
	  typep = lookup_pointer_type (typep);
	  break;
	case MOD_reference_to:
	  typep = lookup_reference_type (typep);
	  break;
	case MOD_const:
	  complain (&const_ignored, DIE_ID, DIE_NAME);	/* FIXME */
	  break;
	case MOD_volatile:
	  complain (&volatile_ignored, DIE_ID, DIE_NAME);	/* FIXME */
	  break;
	default:
	  if (!(MOD_lo_user <= (unsigned char) modifier
		&& (unsigned char) modifier <= MOD_hi_user))
	    {
	      complain (&unknown_type_modifier, DIE_ID, DIE_NAME, modifier);
	    }
	  break;
d3335 1
a3335 1
   LOCAL FUNCTION
d3337 1
a3337 1
   decode_fund_type -- translate basic DWARF type to gdb base type
d3339 1
a3339 1
   DESCRIPTION
d3341 3
a3343 3
   Given an integer that is one of the fundamental DWARF types,
   translate it to one of the basic internal gdb types and return
   a pointer to the appropriate gdb type (a "struct type *").
d3345 1
a3345 1
   NOTES
d3347 7
a3353 7
   For robustness, if we are asked to translate a fundamental
   type that we are unprepared to deal with, we return int so
   callers can always depend upon a valid type being returned,
   and so gdb may at least do something reasonable by default.
   If the type is not in the range of those types defined as
   application specific types, we also issue a warning.
 */
d3360 1
a3360 1

d3367 1
a3367 1

d3376 1
a3376 1

d3380 1
a3380 1

d3388 1
a3388 1

d3396 1
a3396 1

d3400 1
a3400 1

d3408 1
a3408 1

d3412 1
a3412 1

d3420 1
a3420 1

d3424 1
a3424 1

d3440 1
a3440 1

d3444 1
a3444 1

d3448 1
a3448 1

d3452 1
a3452 1

d3456 1
a3456 1

d3460 1
a3460 1

d3471 1
a3471 1

d3477 1
a3477 1
   LOCAL FUNCTION
d3479 1
a3479 1
   create_name -- allocate a fresh copy of a string on an obstack
d3481 1
a3481 1
   DESCRIPTION
d3483 2
a3484 2
   Given a pointer to a string and a pointer to an obstack, allocates
   a fresh copy of the string on the specified obstack.
d3486 1
a3486 1
 */
d3504 3
a3506 1
   LOCAL FUNCTION
d3508 1
a3508 1
   basicdieinfo -- extract the minimal die info from raw die data
d3510 2
a3511 1
   SYNOPSIS
d3513 1
a3513 2
   void basicdieinfo (char *diep, struct dieinfo *dip,
   struct objfile *objfile)
d3515 39
a3553 41
   DESCRIPTION

   Given a pointer to raw DIE data, and a pointer to an instance of a
   die info structure, this function extracts the basic information
   from the DIE data required to continue processing this DIE, along
   with some bookkeeping information about the DIE.

   The information we absolutely must have includes the DIE tag,
   and the DIE length.  If we need the sibling reference, then we
   will have to call completedieinfo() to process all the remaining
   DIE information.

   Note that since there is no guarantee that the data is properly
   aligned in memory for the type of access required (indirection
   through anything other than a char pointer), and there is no
   guarantee that it is in the same byte order as the gdb host,
   we call a function which deals with both alignment and byte
   swapping issues.  Possibly inefficient, but quite portable.

   We also take care of some other basic things at this point, such
   as ensuring that the instance of the die info structure starts
   out completely zero'd and that curdie is initialized for use
   in error reporting if we have a problem with the current die.

   NOTES

   All DIE's must have at least a valid length, thus the minimum
   DIE size is SIZEOF_DIE_LENGTH.  In order to have a valid tag, the
   DIE size must be at least SIZEOF_DIE_TAG larger, otherwise they
   are forced to be TAG_padding DIES.

   Padding DIES must be at least SIZEOF_DIE_LENGTH in length, implying
   that if a padding DIE is used for alignment and the amount needed is
   less than SIZEOF_DIE_LENGTH, then the padding DIE has to be big
   enough to align to the next alignment boundry.

   We do some basic sanity checking here, such as verifying that the
   length of the die would not cause it to overrun the recorded end of
   the buffer holding the DIE info.  If we find a DIE that is either
   too small or too large, we force it's length to zero which should
   cause the caller to take appropriate action.
d3564 6
a3569 6
  dip->die = diep;
  dip->die_ref = dbroff + (diep - dbbase);
  dip->die_length = target_to_host (diep, SIZEOF_DIE_LENGTH, GET_UNSIGNED,
				    objfile);
  if ((dip->die_length < SIZEOF_DIE_LENGTH) ||
      ((diep + dip->die_length) > (dbbase + dbsize)))
d3571 2
a3572 2
      complain (&malformed_die, DIE_ID, DIE_NAME, dip->die_length);
      dip->die_length = 0;
d3574 1
a3574 1
  else if (dip->die_length < (SIZEOF_DIE_LENGTH + SIZEOF_DIE_TAG))
d3576 1
a3576 1
      dip->die_tag = TAG_padding;
d3581 2
a3582 2
      dip->die_tag = target_to_host (diep, SIZEOF_DIE_TAG, GET_UNSIGNED,
				     objfile);
d3588 1
a3588 1
   LOCAL FUNCTION
d3590 1
a3590 1
   completedieinfo -- finish reading the information for a given DIE
d3592 1
a3592 1
   SYNOPSIS
d3594 1
a3594 1
   void completedieinfo (struct dieinfo *dip, struct objfile *objfile)
d3596 1
a3596 1
   DESCRIPTION
d3598 10
a3607 3
   Given a pointer to an already partially initialized die info structure,
   scan the raw DIE data and finish filling in the die info structure
   from the various attributes found.
d3609 1
a3609 6
   Note that since there is no guarantee that the data is properly
   aligned in memory for the type of access required (indirection
   through anything other than a char pointer), and there is no
   guarantee that it is in the same byte order as the gdb host,
   we call a function which deals with both alignment and byte
   swapping issues.  Possibly inefficient, but quite portable.
d3611 4
a3614 6
   NOTES

   Each time we are called, we increment the diecount variable, which
   keeps an approximate count of the number of dies processed for
   each compilation unit.  This information is presented to the user
   if the info_verbose flag is set.
d3628 1
a3628 1

d3630 2
a3631 2
  diep = dip->die;
  end = diep + dip->die_length;
d3646 2
a3647 2
	  dip->at_fund_type = target_to_host (diep, nbytes, GET_UNSIGNED,
					      objfile);
d3650 2
a3651 2
	  dip->at_ordering = target_to_host (diep, nbytes, GET_UNSIGNED,
					     objfile);
d3654 2
a3655 2
	  dip->at_bit_offset = target_to_host (diep, nbytes, GET_UNSIGNED,
					       objfile);
d3658 2
a3659 2
	  dip->at_sibling = target_to_host (diep, nbytes, GET_UNSIGNED,
					    objfile);
d3662 3
a3664 3
	  dip->at_stmt_list = target_to_host (diep, nbytes, GET_UNSIGNED,
					      objfile);
	  dip->has_at_stmt_list = 1;
d3667 4
a3670 4
	  dip->at_low_pc = target_to_host (diep, nbytes, GET_UNSIGNED,
					   objfile);
	  dip->at_low_pc += baseaddr;
	  dip->has_at_low_pc = 1;
d3673 3
a3675 3
	  dip->at_high_pc = target_to_host (diep, nbytes, GET_UNSIGNED,
					    objfile);
	  dip->at_high_pc += baseaddr;
d3678 2
a3679 2
	  dip->at_language = target_to_host (diep, nbytes, GET_UNSIGNED,
					     objfile);
d3682 2
a3683 2
	  dip->at_user_def_type = target_to_host (diep, nbytes,
						  GET_UNSIGNED, objfile);
d3686 3
a3688 3
	  dip->at_byte_size = target_to_host (diep, nbytes, GET_UNSIGNED,
					      objfile);
	  dip->has_at_byte_size = 1;
d3691 2
a3692 2
	  dip->at_bit_size = target_to_host (diep, nbytes, GET_UNSIGNED,
					     objfile);
d3695 2
a3696 2
	  dip->at_member = target_to_host (diep, nbytes, GET_UNSIGNED,
					   objfile);
d3699 2
a3700 2
	  dip->at_discr = target_to_host (diep, nbytes, GET_UNSIGNED,
					  objfile);
d3703 1
a3703 1
	  dip->at_location = diep;
d3706 1
a3706 1
	  dip->at_mod_fund_type = diep;
d3709 1
a3709 1
	  dip->at_subscr_data = diep;
d3712 1
a3712 1
	  dip->at_mod_u_d_type = diep;
d3715 2
a3716 2
	  dip->at_element_list = diep;
	  dip->short_element_list = 0;
d3719 2
a3720 2
	  dip->at_element_list = diep;
	  dip->short_element_list = 1;
d3723 1
a3723 1
	  dip->at_discr_value = diep;
d3726 1
a3726 1
	  dip->at_string_length = diep;
d3729 1
a3729 1
	  dip->at_name = diep;
d3734 2
a3735 2
	  dip->at_comp_dir = strrchr (diep, ':');
	  if (dip->at_comp_dir != NULL)
d3737 1
a3737 1
	      dip->at_comp_dir++;
d3741 1
a3741 1
	      dip->at_comp_dir = diep;
d3745 1
a3745 1
	  dip->at_producer = diep;
d3748 2
a3749 2
	  dip->at_start_scope = target_to_host (diep, nbytes, GET_UNSIGNED,
						objfile);
d3752 2
a3753 2
	  dip->at_stride_size = target_to_host (diep, nbytes, GET_UNSIGNED,
						objfile);
d3756 2
a3757 2
	  dip->at_src_info = target_to_host (diep, nbytes, GET_UNSIGNED,
					     objfile);
d3760 1
a3760 1
	  dip->at_prototyped = diep;
d3805 1
a3805 1
   LOCAL FUNCTION
d3807 1
a3807 1
   target_to_host -- swap in target data to host
d3809 1
a3809 1
   SYNOPSIS
d3811 2
a3812 2
   target_to_host (char *from, int nbytes, int signextend,
   struct objfile *objfile)
d3814 1
a3814 1
   DESCRIPTION
d3816 5
a3820 5
   Given pointer to data in target format in FROM, a byte count for
   the size of the data in NBYTES, a flag indicating whether or not
   the data is signed in SIGNEXTEND, and a pointer to the current
   objfile in OBJFILE, convert the data to host format and return
   the converted value.
d3822 1
a3822 1
   NOTES
d3824 3
a3826 3
   FIXME:  If we read data that is known to be signed, and expect to
   use it as signed data, then we need to explicitly sign extend the
   result until the bfd library is able to do this for us.
d3828 1
a3828 1
   FIXME: Would a 32 bit target ever need an 8 byte result?
d3843 16
a3858 16
    case 8:
      rtnval = bfd_get_64 (objfile->obfd, (bfd_byte *) from);
      break;
    case 4:
      rtnval = bfd_get_32 (objfile->obfd, (bfd_byte *) from);
      break;
    case 2:
      rtnval = bfd_get_16 (objfile->obfd, (bfd_byte *) from);
      break;
    case 1:
      rtnval = bfd_get_8 (objfile->obfd, (bfd_byte *) from);
      break;
    default:
      complain (&no_bfd_get_N, DIE_ID, DIE_NAME, nbytes);
      rtnval = 0;
      break;
d3865 1
a3865 1
   LOCAL FUNCTION
d3867 1
a3867 1
   attribute_size -- compute size of data for a DWARF attribute
d3869 1
a3869 1
   SYNOPSIS
d3871 1
a3871 1
   static int attribute_size (unsigned int attr)
d3873 1
a3873 1
   DESCRIPTION
d3875 3
a3877 3
   Given a DWARF attribute in ATTR, compute the size of the first
   piece of data associated with this attribute and return that
   size.
d3879 1
a3879 1
   Returns -1 for unrecognized attributes.
d3893 23
a3915 23
    case FORM_STRING:		/* A variable length field is next */
      nbytes = 0;
      break;
    case FORM_DATA2:		/* Next 2 byte field is the data itself */
    case FORM_BLOCK2:		/* Next 2 byte field is a block length */
      nbytes = 2;
      break;
    case FORM_DATA4:		/* Next 4 byte field is the data itself */
    case FORM_BLOCK4:		/* Next 4 byte field is a block length */
    case FORM_REF:		/* Next 4 byte field is a DIE offset */
      nbytes = 4;
      break;
    case FORM_DATA8:		/* Next 8 byte field is the data itself */
      nbytes = 8;
      break;
    case FORM_ADDR:		/* Next field size is target sizeof(void *) */
      nbytes = TARGET_FT_POINTER_SIZE (objfile);
      break;
    default:
      complain (&unknown_attribute_form, DIE_ID, DIE_NAME, form);
      nbytes = -1;
      break;
    }
@


1.1.1.4
log
@import gdb-1999-08-02 snapshot
@
text
@d2459 2
a2460 1
	      old_chain = make_cleanup (really_free_pendings, 0);
@


1.1.1.5
log
@import gdb-1999-09-08 snapshot
@
text
@d707 1
d731 1
a731 1
dwarf_build_psymtabs (objfile, mainline, dbfoff, dbfsize,
d734 1
d768 2
a769 2
  base_section_offsets = objfile->section_offsets;
  baseaddr = ANOFFSET (objfile->section_offsets, 0);
@


1.1.1.6
log
@import gdb-1999-10-11 snapshot
@
text
@d1869 5
@


