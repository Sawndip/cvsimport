head	1.8;
access;
symbols
	gdb_5_3-2002-12-12-release:1.7
	carlton_dictionary-20021115-merge:1.7
	kseitz_interps-20021105-merge:1.7
	kseitz_interps-20021103-merge:1.7
	drow-cplus-merge-20021020:1.7
	drow-cplus-merge-20021025:1.7
	carlton_dictionary-20021025-merge:1.7
	carlton_dictionary-20021011-merge:1.7
	drow-cplus-branch:1.7.0.10
	drow-cplus-branchpoint:1.7
	kseitz_interps-20020930-merge:1.7
	carlton_dictionary-20020927-merge:1.7
	carlton_dictionary-branch:1.7.0.8
	carlton_dictionary-20020920-branchpoint:1.7
	gdb_5_3-branch:1.7.0.6
	gdb_5_3-2002-09-04-branchpoint:1.7
	kseitz_interps-20020829-merge:1.7
	cagney_sysregs-20020825-branch:1.7.0.4
	cagney_sysregs-20020825-branchpoint:1.7
	readline_4_3-import-branch:1.7.0.2
	readline_4_3-import-branchpoint:1.7
	gdb_5_2_1-2002-07-23-release:1.5
	kseitz_interps-20020528-branch:1.5.0.8
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.6
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.5.0.4
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.5
	gdb_5_2-branch:1.5.0.2
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.8
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.6
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.4
	gdb_5_1-2001-07-29-branchpoint:1.3
	dberlin-typesystem-branch:1.3.0.2
	dberlin-typesystem-branchpoint:1.3
	gdb-post-ptid_t-2001-05-03:1.3
	gdb-pre-ptid_t-2001-05-03:1.3
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.3
	gdb-premipsmulti-2000-06-06-branch:1.1.1.3.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.3
	gdb-post-params-removal-2000-06-04:1.1.1.3
	gdb-pre-params-removal-2000-06-04:1.1.1.3
	gdb-post-params-removal-2000-05-28:1.1.1.3
	gdb-pre-params-removal-2000-05-28:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.8
date	2002.12.16.20.39.01;	author cagney;	state dead;
branches;
next	1.7;

1.7
date	2002.08.01.17.18.32;	author cagney;	state Exp;
branches
	1.7.8.1
	1.7.10.1;
next	1.6;

1.6
date	2002.07.29.22.55.26;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.12.02.11.51;	author fnf;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	2001.11.10.20.44.37;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.06.08.21.06;	author kevinb;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.07.30.01.48.24;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.04.50;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.02.00.21.05;	author jsm;	state Exp;
branches;
next	;

1.3.2.1
date	2001.07.06.19.16.57;	author dberlin;	state Exp;
branches;
next	;

1.5.8.1
date	2002.08.09.18.34.23;	author kseitz;	state Exp;
branches;
next	;

1.7.8.1
date	2002.12.23.19.38.14;	author carlton;	state dead;
branches;
next	;

1.7.10.1
date	2003.12.14.20.27.08;	author drow;	state dead;
branches;
next	;


desc
@@


1.8
log
@2002-12-16  Andrew Cagney  <ac131313@@redhat.com>

	* config/arc/arc.mt, config/arc/tm-arc.h: Delete.
	* config/d30v/d30v.mt, config/d30v/tm-d30v.h: Delete.
	* config/fr30/fr30.mt, config/fr30/tm-fr30.h: Delete.
	* config/i386/i386aix.mh, config/i386/i386aix.mt: Delete.
	* config/i386/i386m3.mh, config/i386/i386m3.mt: Delete.
	* config/i386/i386mach.mh, config/i386/i386os9k.mt: Delete.
	* config/i386/nm-i386aix.h, config/i386/nm-i386mach.h: Delete.
	* config/i386/nm-m3.h, config/i386/tm-i386aix.h: Delete.
	* config/i386/tm-i386m3.h, config/i386/tm-i386mk.h: Delete.
	* config/i386/xm-i386aix.h, config/i386/xm-i386m3.h: Delete.
	* config/i386/xm-i386mach.h, config/i386/xm-i386mk.h: Delete.
	* config/i960/mon960.mt, config/i960/nindy960.mt: Delete.
	* config/i960/tm-i960.h, config/i960/tm-mon960.h: Delete.
	* config/i960/tm-nindy960.h, config/i960/tm-vx960.h: Delete.
	* config/i960/vxworks960.mt, config/m68k/apollo68b.mh: Delete.
	* config/m68k/apollo68b.mt, config/m68k/apollo68v.mh: Delete.
	* config/m68k/hp300bsd.mh, config/m68k/hp300bsd.mt: Delete.
	* config/m68k/hp300hpux.mh, config/m68k/hp300hpux.mt: Delete.
	* config/m88k/delta88.mh, config/m88k/delta88.mt: Delete.
	* config/m88k/delta88v4.mh, config/m88k/delta88v4.mt: Delete.
	* config/m88k/m88k.mh, config/m88k/m88k.mt: Delete.
	* config/m88k/nm-delta88v4.h, config/m88k/nm-m88k.h: Delete.
	* config/m88k/tm-delta88.h, config/m88k/tm-delta88v4.h: Delete.
	* config/m88k/tm-m88k.h, config/m88k/xm-delta88.h: Delete.
	* config/m88k/xm-dgux.h: Delete.
	* fr30-tdep.c, i386aix-nat.c, i386m3-nat.c: Delete.
	* i386mach-nat.c, i960-tdep.c, m88k-nat.c: Delete.
	* os9kread.c, remote-bug.c, remote-nindy.c: Delete.
	* remote-nrom.c, remote-os9k.c, remote-vx960.c: Delete.
	* d30v-tdep.c, arc-tdep.c, cxux-nat.c, dst.h, dstread.c: Delete.
	* ch-exp.c, ch-lang.c, ch-lang.h, ch-typeprint.c: Delete.
	* ch-valprint.c: Delete.
@
text
@// OBSOLETE /* Support for printing Chill values for GDB, the GNU debugger.
// OBSOLETE    Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
// OBSOLETE    1998, 2000, 2001
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "gdb_obstack.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "gdbtypes.h"
// OBSOLETE #include "valprint.h"
// OBSOLETE #include "expression.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "language.h"
// OBSOLETE #include "demangle.h"
// OBSOLETE #include "c-lang.h"		/* For c_val_print */
// OBSOLETE #include "typeprint.h"
// OBSOLETE #include "ch-lang.h"
// OBSOLETE #include "annotate.h"
// OBSOLETE 
// OBSOLETE static void chill_print_value_fields (struct type *, char *,
// OBSOLETE 				      struct ui_file *, int, int,
// OBSOLETE 				      enum val_prettyprint, struct type **);
// OBSOLETE 
// OBSOLETE static void chill_print_type_scalar (struct type *, LONGEST,
// OBSOLETE 				     struct ui_file *);
// OBSOLETE 
// OBSOLETE static void chill_val_print_array_elements (struct type *, char *,
// OBSOLETE 					    CORE_ADDR, struct ui_file *,
// OBSOLETE 					    int, int, int,
// OBSOLETE 					    enum val_prettyprint);
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Print integral scalar data VAL, of type TYPE, onto stdio stream STREAM.
// OBSOLETE    Used to print data from type structures in a specified type.  For example,
// OBSOLETE    array bounds may be characters or booleans in some languages, and this
// OBSOLETE    allows the ranges to be printed in their "natural" form rather than as
// OBSOLETE    decimal integer values. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE chill_print_type_scalar (struct type *type, LONGEST val, struct ui_file *stream)
// OBSOLETE {
// OBSOLETE   switch (TYPE_CODE (type))
// OBSOLETE     {
// OBSOLETE     case TYPE_CODE_RANGE:
// OBSOLETE       if (TYPE_TARGET_TYPE (type))
// OBSOLETE 	{
// OBSOLETE 	  chill_print_type_scalar (TYPE_TARGET_TYPE (type), val, stream);
// OBSOLETE 	  return;
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE     case TYPE_CODE_UNDEF:
// OBSOLETE     case TYPE_CODE_PTR:
// OBSOLETE     case TYPE_CODE_ARRAY:
// OBSOLETE     case TYPE_CODE_STRUCT:
// OBSOLETE     case TYPE_CODE_UNION:
// OBSOLETE     case TYPE_CODE_ENUM:
// OBSOLETE     case TYPE_CODE_FUNC:
// OBSOLETE     case TYPE_CODE_INT:
// OBSOLETE     case TYPE_CODE_FLT:
// OBSOLETE     case TYPE_CODE_VOID:
// OBSOLETE     case TYPE_CODE_SET:
// OBSOLETE     case TYPE_CODE_STRING:
// OBSOLETE     case TYPE_CODE_BITSTRING:
// OBSOLETE     case TYPE_CODE_ERROR:
// OBSOLETE     case TYPE_CODE_MEMBER:
// OBSOLETE     case TYPE_CODE_METHOD:
// OBSOLETE     case TYPE_CODE_REF:
// OBSOLETE     case TYPE_CODE_CHAR:
// OBSOLETE     case TYPE_CODE_BOOL:
// OBSOLETE     case TYPE_CODE_COMPLEX:
// OBSOLETE     case TYPE_CODE_TYPEDEF:
// OBSOLETE     default:
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE   print_type_scalar (type, val, stream);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Print the elements of an array.
// OBSOLETE    Similar to val_print_array_elements, but prints
// OBSOLETE    element indexes (in Chill syntax). */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE chill_val_print_array_elements (struct type *type, char *valaddr,
// OBSOLETE 				CORE_ADDR address, struct ui_file *stream,
// OBSOLETE 				int format, int deref_ref, int recurse,
// OBSOLETE 				enum val_prettyprint pretty)
// OBSOLETE {
// OBSOLETE   unsigned int i = 0;
// OBSOLETE   unsigned int things_printed = 0;
// OBSOLETE   unsigned len;
// OBSOLETE   struct type *elttype;
// OBSOLETE   struct type *range_type = TYPE_FIELD_TYPE (type, 0);
// OBSOLETE   struct type *index_type = TYPE_TARGET_TYPE (range_type);
// OBSOLETE   unsigned eltlen;
// OBSOLETE   /* Position of the array element we are examining to see
// OBSOLETE      whether it is repeated.  */
// OBSOLETE   unsigned int rep1;
// OBSOLETE   /* Number of repetitions we have detected so far.  */
// OBSOLETE   unsigned int reps;
// OBSOLETE   LONGEST low_bound = TYPE_FIELD_BITPOS (range_type, 0);
// OBSOLETE 
// OBSOLETE   elttype = check_typedef (TYPE_TARGET_TYPE (type));
// OBSOLETE   eltlen = TYPE_LENGTH (elttype);
// OBSOLETE   len = TYPE_LENGTH (type) / eltlen;
// OBSOLETE 
// OBSOLETE   annotate_array_section_begin (i, elttype);
// OBSOLETE 
// OBSOLETE   for (; i < len && things_printed < print_max; i++)
// OBSOLETE     {
// OBSOLETE       if (i != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (prettyprint_arrays)
// OBSOLETE 	    {
// OBSOLETE 	      fprintf_filtered (stream, ",\n");
// OBSOLETE 	      print_spaces_filtered (2 + 2 * recurse, stream);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      fprintf_filtered (stream, ", ");
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       wrap_here (n_spaces (2 + 2 * recurse));
// OBSOLETE 
// OBSOLETE       rep1 = i + 1;
// OBSOLETE       reps = 1;
// OBSOLETE       while ((rep1 < len) &&
// OBSOLETE 	     !memcmp (valaddr + i * eltlen, valaddr + rep1 * eltlen, eltlen))
// OBSOLETE 	{
// OBSOLETE 	  ++reps;
// OBSOLETE 	  ++rep1;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       fputs_filtered ("(", stream);
// OBSOLETE       chill_print_type_scalar (index_type, low_bound + i, stream);
// OBSOLETE       if (reps > 1)
// OBSOLETE 	{
// OBSOLETE 	  fputs_filtered (":", stream);
// OBSOLETE 	  chill_print_type_scalar (index_type, low_bound + i + reps - 1,
// OBSOLETE 				   stream);
// OBSOLETE 	  fputs_filtered ("): ", stream);
// OBSOLETE 	  val_print (elttype, valaddr + i * eltlen, 0, 0, stream, format,
// OBSOLETE 		     deref_ref, recurse + 1, pretty);
// OBSOLETE 
// OBSOLETE 	  i = rep1 - 1;
// OBSOLETE 	  things_printed += 1;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  fputs_filtered ("): ", stream);
// OBSOLETE 	  val_print (elttype, valaddr + i * eltlen, 0, 0, stream, format,
// OBSOLETE 		     deref_ref, recurse + 1, pretty);
// OBSOLETE 	  annotate_elt ();
// OBSOLETE 	  things_printed++;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   annotate_array_section_end ();
// OBSOLETE   if (i < len)
// OBSOLETE     {
// OBSOLETE       fprintf_filtered (stream, "...");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Print data of type TYPE located at VALADDR (within GDB), which came from
// OBSOLETE    the inferior at address ADDRESS, onto stdio stream STREAM according to
// OBSOLETE    FORMAT (a letter or 0 for natural format).  The data at VALADDR is in
// OBSOLETE    target byte order.
// OBSOLETE 
// OBSOLETE    If the data are a string pointer, returns the number of string characters
// OBSOLETE    printed.
// OBSOLETE 
// OBSOLETE    If DEREF_REF is nonzero, then dereference references, otherwise just print
// OBSOLETE    them like pointers.
// OBSOLETE 
// OBSOLETE    The PRETTY parameter controls prettyprinting.  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE chill_val_print (struct type *type, char *valaddr, int embedded_offset,
// OBSOLETE 		 CORE_ADDR address, struct ui_file *stream, int format,
// OBSOLETE 		 int deref_ref, int recurse, enum val_prettyprint pretty)
// OBSOLETE {
// OBSOLETE   LONGEST val;
// OBSOLETE   unsigned int i = 0;		/* Number of characters printed.  */
// OBSOLETE   struct type *elttype;
// OBSOLETE   CORE_ADDR addr;
// OBSOLETE 
// OBSOLETE   CHECK_TYPEDEF (type);
// OBSOLETE 
// OBSOLETE   switch (TYPE_CODE (type))
// OBSOLETE     {
// OBSOLETE     case TYPE_CODE_ARRAY:
// OBSOLETE       if (TYPE_LENGTH (type) > 0 && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0)
// OBSOLETE 	{
// OBSOLETE 	  if (prettyprint_arrays)
// OBSOLETE 	    {
// OBSOLETE 	      print_spaces_filtered (2 + 2 * recurse, stream);
// OBSOLETE 	    }
// OBSOLETE 	  fprintf_filtered (stream, "[");
// OBSOLETE 	  chill_val_print_array_elements (type, valaddr, address, stream,
// OBSOLETE 					format, deref_ref, recurse, pretty);
// OBSOLETE 	  fprintf_filtered (stream, "]");
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  error ("unimplemented in chill_val_print; unspecified array length");
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_INT:
// OBSOLETE       format = format ? format : output_format;
// OBSOLETE       if (format)
// OBSOLETE 	{
// OBSOLETE 	  print_scalar_formatted (valaddr, type, format, 0, stream);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  val_print_type_code_int (type, valaddr, stream);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_CHAR:
// OBSOLETE       format = format ? format : output_format;
// OBSOLETE       if (format)
// OBSOLETE 	{
// OBSOLETE 	  print_scalar_formatted (valaddr, type, format, 0, stream);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  LA_PRINT_CHAR ((unsigned char) unpack_long (type, valaddr),
// OBSOLETE 			 stream);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_FLT:
// OBSOLETE       if (format)
// OBSOLETE 	{
// OBSOLETE 	  print_scalar_formatted (valaddr, type, format, 0, stream);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  print_floating (valaddr, type, stream);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_BOOL:
// OBSOLETE       format = format ? format : output_format;
// OBSOLETE       if (format)
// OBSOLETE 	{
// OBSOLETE 	  print_scalar_formatted (valaddr, type, format, 0, stream);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* FIXME: Why is this using builtin_type_chill_bool not type?  */
// OBSOLETE 	  val = unpack_long (builtin_type_chill_bool, valaddr);
// OBSOLETE 	  fprintf_filtered (stream, val ? "TRUE" : "FALSE");
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_UNDEF:
// OBSOLETE       /* This happens (without TYPE_FLAG_STUB set) on systems which don't use
// OBSOLETE          dbx xrefs (NO_DBX_XREFS in gcc) if a file has a "struct foo *bar"
// OBSOLETE          and no complete type for struct foo in that file.  */
// OBSOLETE       fprintf_filtered (stream, "<incomplete type>");
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_PTR:
// OBSOLETE       if (format && format != 's')
// OBSOLETE 	{
// OBSOLETE 	  print_scalar_formatted (valaddr, type, format, 0, stream);
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       addr = unpack_pointer (type, valaddr);
// OBSOLETE       elttype = check_typedef (TYPE_TARGET_TYPE (type));
// OBSOLETE 
// OBSOLETE       /* We assume a NULL pointer is all zeros ... */
// OBSOLETE       if (addr == 0)
// OBSOLETE 	{
// OBSOLETE 	  fputs_filtered ("NULL", stream);
// OBSOLETE 	  return 0;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (TYPE_CODE (elttype) == TYPE_CODE_FUNC)
// OBSOLETE 	{
// OBSOLETE 	  /* Try to print what function it points to.  */
// OBSOLETE 	  print_address_demangle (addr, stream, demangle);
// OBSOLETE 	  /* Return value is irrelevant except for string pointers.  */
// OBSOLETE 	  return (0);
// OBSOLETE 	}
// OBSOLETE       if (addressprint && format != 's')
// OBSOLETE 	{
// OBSOLETE 	  print_address_numeric (addr, 1, stream);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* For a pointer to char or unsigned char, also print the string
// OBSOLETE          pointed to, unless pointer is null.  */
// OBSOLETE       if (TYPE_LENGTH (elttype) == 1
// OBSOLETE 	  && TYPE_CODE (elttype) == TYPE_CODE_CHAR
// OBSOLETE 	  && (format == 0 || format == 's')
// OBSOLETE 	  && addr != 0
// OBSOLETE 	  &&			/* If print_max is UINT_MAX, the alloca below will fail.
// OBSOLETE 				   In that case don't try to print the string.  */
// OBSOLETE 	  print_max < UINT_MAX)
// OBSOLETE 	i = val_print_string (addr, -1, TYPE_LENGTH (elttype), stream);
// OBSOLETE 
// OBSOLETE       /* Return number of characters printed, plus one for the
// OBSOLETE          terminating null if we have "reached the end".  */
// OBSOLETE       return (i + (print_max && i != print_max));
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_STRING:
// OBSOLETE       i = TYPE_LENGTH (type);
// OBSOLETE       LA_PRINT_STRING (stream, valaddr, i, 1, 0);
// OBSOLETE       /* Return number of characters printed, plus one for the terminating
// OBSOLETE          null if we have "reached the end".  */
// OBSOLETE       return (i + (print_max && i != print_max));
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_BITSTRING:
// OBSOLETE     case TYPE_CODE_SET:
// OBSOLETE       elttype = TYPE_INDEX_TYPE (type);
// OBSOLETE       CHECK_TYPEDEF (elttype);
// OBSOLETE       if (TYPE_STUB (elttype))
// OBSOLETE 	{
// OBSOLETE 	  fprintf_filtered (stream, "<incomplete type>");
// OBSOLETE 	  gdb_flush (stream);
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       {
// OBSOLETE 	struct type *range = elttype;
// OBSOLETE 	LONGEST low_bound, high_bound;
// OBSOLETE 	int i;
// OBSOLETE 	int is_bitstring = TYPE_CODE (type) == TYPE_CODE_BITSTRING;
// OBSOLETE 	int need_comma = 0;
// OBSOLETE 
// OBSOLETE 	if (is_bitstring)
// OBSOLETE 	  fputs_filtered ("B'", stream);
// OBSOLETE 	else
// OBSOLETE 	  fputs_filtered ("[", stream);
// OBSOLETE 
// OBSOLETE 	i = get_discrete_bounds (range, &low_bound, &high_bound);
// OBSOLETE       maybe_bad_bstring:
// OBSOLETE 	if (i < 0)
// OBSOLETE 	  {
// OBSOLETE 	    fputs_filtered ("<error value>", stream);
// OBSOLETE 	    goto done;
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE 	for (i = low_bound; i <= high_bound; i++)
// OBSOLETE 	  {
// OBSOLETE 	    int element = value_bit_index (type, valaddr, i);
// OBSOLETE 	    if (element < 0)
// OBSOLETE 	      {
// OBSOLETE 		i = element;
// OBSOLETE 		goto maybe_bad_bstring;
// OBSOLETE 	      }
// OBSOLETE 	    if (is_bitstring)
// OBSOLETE 	      fprintf_filtered (stream, "%d", element);
// OBSOLETE 	    else if (element)
// OBSOLETE 	      {
// OBSOLETE 		if (need_comma)
// OBSOLETE 		  fputs_filtered (", ", stream);
// OBSOLETE 		chill_print_type_scalar (range, (LONGEST) i, stream);
// OBSOLETE 		need_comma = 1;
// OBSOLETE 
// OBSOLETE 		/* Look for a continuous range of true elements. */
// OBSOLETE 		if (i + 1 <= high_bound && value_bit_index (type, valaddr, ++i))
// OBSOLETE 		  {
// OBSOLETE 		    int j = i;	/* j is the upper bound so far of the range */
// OBSOLETE 		    fputs_filtered (":", stream);
// OBSOLETE 		    while (i + 1 <= high_bound
// OBSOLETE 			   && value_bit_index (type, valaddr, ++i))
// OBSOLETE 		      j = i;
// OBSOLETE 		    chill_print_type_scalar (range, (LONGEST) j, stream);
// OBSOLETE 		  }
// OBSOLETE 	      }
// OBSOLETE 	  }
// OBSOLETE       done:
// OBSOLETE 	if (is_bitstring)
// OBSOLETE 	  fputs_filtered ("'", stream);
// OBSOLETE 	else
// OBSOLETE 	  fputs_filtered ("]", stream);
// OBSOLETE       }
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_STRUCT:
// OBSOLETE       if (chill_varying_type (type))
// OBSOLETE 	{
// OBSOLETE 	  struct type *inner = check_typedef (TYPE_FIELD_TYPE (type, 1));
// OBSOLETE 	  long length = unpack_long (TYPE_FIELD_TYPE (type, 0), valaddr);
// OBSOLETE 	  char *data_addr = valaddr + TYPE_FIELD_BITPOS (type, 1) / 8;
// OBSOLETE 
// OBSOLETE 	  switch (TYPE_CODE (inner))
// OBSOLETE 	    {
// OBSOLETE 	    case TYPE_CODE_STRING:
// OBSOLETE 	      if (length > TYPE_LENGTH (type) - 2)
// OBSOLETE 		{
// OBSOLETE 		  fprintf_filtered (stream,
// OBSOLETE 			"<dynamic length %ld > static length %d> *invalid*",
// OBSOLETE 				    length, TYPE_LENGTH (type));
// OBSOLETE 
// OBSOLETE 		  /* Don't print the string; doing so might produce a
// OBSOLETE 		     segfault.  */
// OBSOLETE 		  return length;
// OBSOLETE 		}
// OBSOLETE 	      LA_PRINT_STRING (stream, data_addr, length, 1, 0);
// OBSOLETE 	      return length;
// OBSOLETE 	    default:
// OBSOLETE 	      break;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       chill_print_value_fields (type, valaddr, stream, format, recurse, pretty,
// OBSOLETE 				0);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_REF:
// OBSOLETE       if (addressprint)
// OBSOLETE 	{
// OBSOLETE 	  fprintf_filtered (stream, "LOC(");
// OBSOLETE 	  print_address_numeric
// OBSOLETE 	    (extract_address (valaddr, TARGET_PTR_BIT / HOST_CHAR_BIT),
// OBSOLETE 	     1,
// OBSOLETE 	     stream);
// OBSOLETE 	  fprintf_filtered (stream, ")");
// OBSOLETE 	  if (deref_ref)
// OBSOLETE 	    fputs_filtered (": ", stream);
// OBSOLETE 	}
// OBSOLETE       /* De-reference the reference.  */
// OBSOLETE       if (deref_ref)
// OBSOLETE 	{
// OBSOLETE 	  if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_UNDEF)
// OBSOLETE 	    {
// OBSOLETE 	      struct value *deref_val =
// OBSOLETE 	      value_at
// OBSOLETE 	      (TYPE_TARGET_TYPE (type),
// OBSOLETE 	       unpack_pointer (lookup_pointer_type (builtin_type_void),
// OBSOLETE 			       valaddr),
// OBSOLETE 	       NULL);
// OBSOLETE 	      val_print (VALUE_TYPE (deref_val),
// OBSOLETE 			 VALUE_CONTENTS (deref_val),
// OBSOLETE 			 0,
// OBSOLETE 			 VALUE_ADDRESS (deref_val), stream, format,
// OBSOLETE 			 deref_ref, recurse + 1, pretty);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    fputs_filtered ("???", stream);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_ENUM:
// OBSOLETE       c_val_print (type, valaddr, 0, address, stream, format,
// OBSOLETE 		   deref_ref, recurse, pretty);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_RANGE:
// OBSOLETE       if (TYPE_TARGET_TYPE (type))
// OBSOLETE 	chill_val_print (TYPE_TARGET_TYPE (type), valaddr, 0, address, stream,
// OBSOLETE 			 format, deref_ref, recurse, pretty);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_MEMBER:
// OBSOLETE     case TYPE_CODE_UNION:
// OBSOLETE     case TYPE_CODE_FUNC:
// OBSOLETE     case TYPE_CODE_VOID:
// OBSOLETE     case TYPE_CODE_ERROR:
// OBSOLETE     default:
// OBSOLETE       /* Let's defer printing to the C printer, rather than
// OBSOLETE          print an error message.  FIXME! */
// OBSOLETE       c_val_print (type, valaddr, 0, address, stream, format,
// OBSOLETE 		   deref_ref, recurse, pretty);
// OBSOLETE     }
// OBSOLETE   gdb_flush (stream);
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Mutually recursive subroutines of cplus_print_value and c_val_print to
// OBSOLETE    print out a structure's fields: cp_print_value_fields and cplus_print_value.
// OBSOLETE 
// OBSOLETE    TYPE, VALADDR, STREAM, RECURSE, and PRETTY have the
// OBSOLETE    same meanings as in cplus_print_value and c_val_print.
// OBSOLETE 
// OBSOLETE    DONT_PRINT is an array of baseclass types that we
// OBSOLETE    should not print, or zero if called from top level.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE chill_print_value_fields (struct type *type, char *valaddr,
// OBSOLETE 			  struct ui_file *stream, int format, int recurse,
// OBSOLETE 			  enum val_prettyprint pretty, struct type **dont_print)
// OBSOLETE {
// OBSOLETE   int i, len;
// OBSOLETE   int fields_seen = 0;
// OBSOLETE 
// OBSOLETE   CHECK_TYPEDEF (type);
// OBSOLETE 
// OBSOLETE   fprintf_filtered (stream, "[");
// OBSOLETE   len = TYPE_NFIELDS (type);
// OBSOLETE   if (len == 0)
// OBSOLETE     {
// OBSOLETE       fprintf_filtered (stream, "<No data fields>");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       for (i = 0; i < len; i++)
// OBSOLETE 	{
// OBSOLETE 	  if (fields_seen)
// OBSOLETE 	    {
// OBSOLETE 	      fprintf_filtered (stream, ", ");
// OBSOLETE 	    }
// OBSOLETE 	  fields_seen = 1;
// OBSOLETE 	  if (pretty)
// OBSOLETE 	    {
// OBSOLETE 	      fprintf_filtered (stream, "\n");
// OBSOLETE 	      print_spaces_filtered (2 + 2 * recurse, stream);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      wrap_here (n_spaces (2 + 2 * recurse));
// OBSOLETE 	    }
// OBSOLETE 	  fputs_filtered (".", stream);
// OBSOLETE 	  fprintf_symbol_filtered (stream, TYPE_FIELD_NAME (type, i),
// OBSOLETE 				   language_chill, DMGL_NO_OPTS);
// OBSOLETE 	  fputs_filtered (": ", stream);
// OBSOLETE 	  if (TYPE_FIELD_PACKED (type, i))
// OBSOLETE 	    {
// OBSOLETE 	      struct value *v;
// OBSOLETE 
// OBSOLETE 	      /* Bitfields require special handling, especially due to byte
// OBSOLETE 	         order problems.  */
// OBSOLETE 	      v = value_from_longest (TYPE_FIELD_TYPE (type, i),
// OBSOLETE 				   unpack_field_as_long (type, valaddr, i));
// OBSOLETE 
// OBSOLETE 	      chill_val_print (TYPE_FIELD_TYPE (type, i), VALUE_CONTENTS (v), 0, 0,
// OBSOLETE 			       stream, format, 0, recurse + 1, pretty);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      chill_val_print (TYPE_FIELD_TYPE (type, i),
// OBSOLETE 			       valaddr + TYPE_FIELD_BITPOS (type, i) / 8, 0,
// OBSOLETE 			       0, stream, format, 0, recurse + 1, pretty);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       if (pretty)
// OBSOLETE 	{
// OBSOLETE 	  fprintf_filtered (stream, "\n");
// OBSOLETE 	  print_spaces_filtered (2 * recurse, stream);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   fprintf_filtered (stream, "]");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE chill_value_print (struct value *val, struct ui_file *stream, int format,
// OBSOLETE 		   enum val_prettyprint pretty)
// OBSOLETE {
// OBSOLETE   struct type *type = VALUE_TYPE (val);
// OBSOLETE   struct type *real_type = check_typedef (type);
// OBSOLETE 
// OBSOLETE   /* If it is a pointer, indicate what it points to.
// OBSOLETE 
// OBSOLETE      Print type also if it is a reference. */
// OBSOLETE 
// OBSOLETE   if (TYPE_CODE (real_type) == TYPE_CODE_PTR ||
// OBSOLETE       TYPE_CODE (real_type) == TYPE_CODE_REF)
// OBSOLETE     {
// OBSOLETE       char *valaddr = VALUE_CONTENTS (val);
// OBSOLETE       CORE_ADDR addr = unpack_pointer (type, valaddr);
// OBSOLETE       if (TYPE_CODE (type) != TYPE_CODE_PTR || addr != 0)
// OBSOLETE 	{
// OBSOLETE 	  int i;
// OBSOLETE 	  char *name = TYPE_NAME (type);
// OBSOLETE 	  if (name)
// OBSOLETE 	    fputs_filtered (name, stream);
// OBSOLETE 	  else if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_VOID)
// OBSOLETE 	    fputs_filtered ("PTR", stream);
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      fprintf_filtered (stream, "(");
// OBSOLETE 	      type_print (type, "", stream, -1);
// OBSOLETE 	      fprintf_filtered (stream, ")");
// OBSOLETE 	    }
// OBSOLETE 	  fprintf_filtered (stream, "(");
// OBSOLETE 	  i = val_print (type, valaddr, 0, VALUE_ADDRESS (val),
// OBSOLETE 			 stream, format, 1, 0, pretty);
// OBSOLETE 	  fprintf_filtered (stream, ")");
// OBSOLETE 	  return i;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   return (val_print (type, VALUE_CONTENTS (val), 0,
// OBSOLETE 		     VALUE_ADDRESS (val), stream, format, 1, 0, pretty));
// OBSOLETE }
@


1.7
log
@2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* NEWS: Menion that CHILL has been made obsolete.

* gdbtypes.c (chill_varying_type): Make chill references obsolete.
* gdbserver/Makefile.in: Ditto.
* stabsread.c (read_range_type): Ditto.
* gdbtypes.h: Ditto.
* language.c (binop_type_check): Ditto.
(binop_result_type): Ditto.
(integral_type): Ditto.
(character_type): Ditto.
(string_type): Ditto.
(boolean_type): Ditto.
(structured_type): Ditto.
(lang_bool_type): Ditto.
(binop_type_check): Ditto.
* language.h (_LANG_chill): Ditto.
* dwarfread.c (set_cu_language): Ditto.
* dwarfread.c (CHILL_PRODUCER): Ditto.
* dwarfread.c (handle_producer): Ditto.
* expression.h (enum exp_opcode): Ditto.
* eval.c: Ditto for comments.
* typeprint.c (typedef_print) [_LANG_chill]: Ditto.
* expprint.c (print_subexp): Ditto.
(print_subexp): Ditto.
* valops.c (value_cast): Ditto.
(search_struct_field): Ditto.
* value.h (COERCE_VARYING_ARRAY): Ditto.
* symfile.c (init_filename_language_table): Ditto.
(add_psymbol_with_dem_name_to_list): Ditto.
* valarith.c (value_binop): Ditto.
(value_neg): Ditto.
* valops.c (value_slice): Ditto.
* symtab.h (union language_specific): Ditto.
(SYMBOL_INIT_LANGUAGE_SPECIFIC): Ditto.
(SYMBOL_DEMANGLED_NAME): Ditto.
(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
* defs.h (enum language): Ditto.
* symtab.c (got_symtab): Ditto.
* utils.c (fprintf_symbol_filtered): Ditto.

* ch-typeprint.c: Make file obsolete.
* ch-valprint.c: Make file obsolete.
* ch-lang.h: Make file obsolete.
* ch-exp.c: Make file obsolete.
* ch-lang.c: Make file obsolete.

* Makefile.in (FLAGS_TO_PASS): Do not pass CHILL or CHILLFLAGS or
CHILL_LIB.
(TARGET_FLAGS_TO_PASS): Ditto.
(CHILLFLAGS): Obsolete.
(CHILL): Obsolete.
(CHILL_FOR_TARGET): Obsolete.
(CHILL_LIB): Obsolete.
(SFILES): Remove ch-exp.c, ch-lang.c, ch-typeprint.c and
ch-valprint.c.
(HFILES_NO_SRCDIR): Remove ch-lang.h.
(COMMON_OBS): Remove ch-valprint.o, ch-typeprint.o, ch-exp.o and
ch-lang.o.
(ch-exp.o, ch-lang.o, ch-typeprint.o, ch-valprint.o): Delete
targets.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* stabs.texinfo, gdb.texinfo, gdbint.texinfo: Obsolete references
to CHILL.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* Makefile.in (TARGET_FLAGS_TO_PASS): Remove CHILLFLAGS, CHILL,
CHILL_FOR_TARGET and CHILL_LIB.
* configure.in (configdirs): Remove gdb.chill.
* configure: Regenerate.
* lib/gdb.exp: Obsolete references to chill.
* gdb.fortran/types.exp: Ditto.
* gdb.fortran/exprs.exp: Ditto.
@
text
@@


1.7.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.7.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.6
log
@2002-07-29  Andrew Cagney  <ac131313@@redhat.com>

* gdb_obstack.h: New file.
* symtab.h: Include "gdb_obstack.h" instead of "obstack.h".
(obstack_chunk_alloc, obstack_chunk_free): Delete macros.
* objfiles.h: Include "gdb_obstack.h".
* Makefile.in (gdb_obstack_h): Define.
(symtab_h): Add $(gdb_obstack_h).
(objfiles_h): Add $(gdb_obstack_h).

* objfiles.c: Include "gdb_obstack.h" instead of "obstack.h".
* macrotab.c, cp-valprint.c, dbxread.c: Ditto.
* ch-typeprint.c, ch-valprint.c, dstread.c: Ditto.
* macroexp.c, p-typeprint.c, stabsread.c: Ditto.
* symtab.c, f-typeprint.c, mdebugread.c: Ditto.
* p-valprint.c, symmisc.c, typeprint.c: Ditto.
* symfile.c, coffread.c, c-typeprint.c: Ditto.
* buildsym.c, bcache.c, ada-typeprint.c: Ditto.

* Makefile.in (bcache.o): Update dependencies.
(buildsym.o, c-typeprint.o, ch-typeprint.o): Ditto.
(ch-valprint.o, coffread.o, cp-valprint.o): Ditto.
(dbxread.o, dstread.o, f-typeprint.o): Ditto.
(objfiles.o, p-typeprint.o, p-valprint.o): Ditto.
(stabsread.o, symfile.o, symmisc.o): Ditto.
(symtab.o, typeprint.o, macroexp.o): Ditto.
(macrotab.o, mdebugread.o): Ditto.
(f_lang_h, coff_sym_h, coff_symconst_h): Define.
(coff_ecoff_h, aout_aout64_h): Define.
(aout_stabs_gnu_h, libaout_h): Define.
@
text
@d1 605
a605 605
/* Support for printing Chill values for GDB, the GNU debugger.
   Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 2000, 2001
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "gdb_obstack.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "valprint.h"
#include "expression.h"
#include "value.h"
#include "language.h"
#include "demangle.h"
#include "c-lang.h"		/* For c_val_print */
#include "typeprint.h"
#include "ch-lang.h"
#include "annotate.h"

static void chill_print_value_fields (struct type *, char *,
				      struct ui_file *, int, int,
				      enum val_prettyprint, struct type **);

static void chill_print_type_scalar (struct type *, LONGEST,
				     struct ui_file *);

static void chill_val_print_array_elements (struct type *, char *,
					    CORE_ADDR, struct ui_file *,
					    int, int, int,
					    enum val_prettyprint);


/* Print integral scalar data VAL, of type TYPE, onto stdio stream STREAM.
   Used to print data from type structures in a specified type.  For example,
   array bounds may be characters or booleans in some languages, and this
   allows the ranges to be printed in their "natural" form rather than as
   decimal integer values. */

static void
chill_print_type_scalar (struct type *type, LONGEST val, struct ui_file *stream)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_RANGE:
      if (TYPE_TARGET_TYPE (type))
	{
	  chill_print_type_scalar (TYPE_TARGET_TYPE (type), val, stream);
	  return;
	}
      break;
    case TYPE_CODE_UNDEF:
    case TYPE_CODE_PTR:
    case TYPE_CODE_ARRAY:
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_FUNC:
    case TYPE_CODE_INT:
    case TYPE_CODE_FLT:
    case TYPE_CODE_VOID:
    case TYPE_CODE_SET:
    case TYPE_CODE_STRING:
    case TYPE_CODE_BITSTRING:
    case TYPE_CODE_ERROR:
    case TYPE_CODE_MEMBER:
    case TYPE_CODE_METHOD:
    case TYPE_CODE_REF:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_COMPLEX:
    case TYPE_CODE_TYPEDEF:
    default:
      break;
    }
  print_type_scalar (type, val, stream);
}

/* Print the elements of an array.
   Similar to val_print_array_elements, but prints
   element indexes (in Chill syntax). */

static void
chill_val_print_array_elements (struct type *type, char *valaddr,
				CORE_ADDR address, struct ui_file *stream,
				int format, int deref_ref, int recurse,
				enum val_prettyprint pretty)
{
  unsigned int i = 0;
  unsigned int things_printed = 0;
  unsigned len;
  struct type *elttype;
  struct type *range_type = TYPE_FIELD_TYPE (type, 0);
  struct type *index_type = TYPE_TARGET_TYPE (range_type);
  unsigned eltlen;
  /* Position of the array element we are examining to see
     whether it is repeated.  */
  unsigned int rep1;
  /* Number of repetitions we have detected so far.  */
  unsigned int reps;
  LONGEST low_bound = TYPE_FIELD_BITPOS (range_type, 0);

  elttype = check_typedef (TYPE_TARGET_TYPE (type));
  eltlen = TYPE_LENGTH (elttype);
  len = TYPE_LENGTH (type) / eltlen;

  annotate_array_section_begin (i, elttype);

  for (; i < len && things_printed < print_max; i++)
    {
      if (i != 0)
	{
	  if (prettyprint_arrays)
	    {
	      fprintf_filtered (stream, ",\n");
	      print_spaces_filtered (2 + 2 * recurse, stream);
	    }
	  else
	    {
	      fprintf_filtered (stream, ", ");
	    }
	}
      wrap_here (n_spaces (2 + 2 * recurse));

      rep1 = i + 1;
      reps = 1;
      while ((rep1 < len) &&
	     !memcmp (valaddr + i * eltlen, valaddr + rep1 * eltlen, eltlen))
	{
	  ++reps;
	  ++rep1;
	}

      fputs_filtered ("(", stream);
      chill_print_type_scalar (index_type, low_bound + i, stream);
      if (reps > 1)
	{
	  fputs_filtered (":", stream);
	  chill_print_type_scalar (index_type, low_bound + i + reps - 1,
				   stream);
	  fputs_filtered ("): ", stream);
	  val_print (elttype, valaddr + i * eltlen, 0, 0, stream, format,
		     deref_ref, recurse + 1, pretty);

	  i = rep1 - 1;
	  things_printed += 1;
	}
      else
	{
	  fputs_filtered ("): ", stream);
	  val_print (elttype, valaddr + i * eltlen, 0, 0, stream, format,
		     deref_ref, recurse + 1, pretty);
	  annotate_elt ();
	  things_printed++;
	}
    }
  annotate_array_section_end ();
  if (i < len)
    {
      fprintf_filtered (stream, "...");
    }
}

/* Print data of type TYPE located at VALADDR (within GDB), which came from
   the inferior at address ADDRESS, onto stdio stream STREAM according to
   FORMAT (a letter or 0 for natural format).  The data at VALADDR is in
   target byte order.

   If the data are a string pointer, returns the number of string characters
   printed.

   If DEREF_REF is nonzero, then dereference references, otherwise just print
   them like pointers.

   The PRETTY parameter controls prettyprinting.  */

int
chill_val_print (struct type *type, char *valaddr, int embedded_offset,
		 CORE_ADDR address, struct ui_file *stream, int format,
		 int deref_ref, int recurse, enum val_prettyprint pretty)
{
  LONGEST val;
  unsigned int i = 0;		/* Number of characters printed.  */
  struct type *elttype;
  CORE_ADDR addr;

  CHECK_TYPEDEF (type);

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_ARRAY:
      if (TYPE_LENGTH (type) > 0 && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0)
	{
	  if (prettyprint_arrays)
	    {
	      print_spaces_filtered (2 + 2 * recurse, stream);
	    }
	  fprintf_filtered (stream, "[");
	  chill_val_print_array_elements (type, valaddr, address, stream,
					format, deref_ref, recurse, pretty);
	  fprintf_filtered (stream, "]");
	}
      else
	{
	  error ("unimplemented in chill_val_print; unspecified array length");
	}
      break;

    case TYPE_CODE_INT:
      format = format ? format : output_format;
      if (format)
	{
	  print_scalar_formatted (valaddr, type, format, 0, stream);
	}
      else
	{
	  val_print_type_code_int (type, valaddr, stream);
	}
      break;

    case TYPE_CODE_CHAR:
      format = format ? format : output_format;
      if (format)
	{
	  print_scalar_formatted (valaddr, type, format, 0, stream);
	}
      else
	{
	  LA_PRINT_CHAR ((unsigned char) unpack_long (type, valaddr),
			 stream);
	}
      break;

    case TYPE_CODE_FLT:
      if (format)
	{
	  print_scalar_formatted (valaddr, type, format, 0, stream);
	}
      else
	{
	  print_floating (valaddr, type, stream);
	}
      break;

    case TYPE_CODE_BOOL:
      format = format ? format : output_format;
      if (format)
	{
	  print_scalar_formatted (valaddr, type, format, 0, stream);
	}
      else
	{
	  /* FIXME: Why is this using builtin_type_chill_bool not type?  */
	  val = unpack_long (builtin_type_chill_bool, valaddr);
	  fprintf_filtered (stream, val ? "TRUE" : "FALSE");
	}
      break;

    case TYPE_CODE_UNDEF:
      /* This happens (without TYPE_FLAG_STUB set) on systems which don't use
         dbx xrefs (NO_DBX_XREFS in gcc) if a file has a "struct foo *bar"
         and no complete type for struct foo in that file.  */
      fprintf_filtered (stream, "<incomplete type>");
      break;

    case TYPE_CODE_PTR:
      if (format && format != 's')
	{
	  print_scalar_formatted (valaddr, type, format, 0, stream);
	  break;
	}
      addr = unpack_pointer (type, valaddr);
      elttype = check_typedef (TYPE_TARGET_TYPE (type));

      /* We assume a NULL pointer is all zeros ... */
      if (addr == 0)
	{
	  fputs_filtered ("NULL", stream);
	  return 0;
	}

      if (TYPE_CODE (elttype) == TYPE_CODE_FUNC)
	{
	  /* Try to print what function it points to.  */
	  print_address_demangle (addr, stream, demangle);
	  /* Return value is irrelevant except for string pointers.  */
	  return (0);
	}
      if (addressprint && format != 's')
	{
	  print_address_numeric (addr, 1, stream);
	}

      /* For a pointer to char or unsigned char, also print the string
         pointed to, unless pointer is null.  */
      if (TYPE_LENGTH (elttype) == 1
	  && TYPE_CODE (elttype) == TYPE_CODE_CHAR
	  && (format == 0 || format == 's')
	  && addr != 0
	  &&			/* If print_max is UINT_MAX, the alloca below will fail.
				   In that case don't try to print the string.  */
	  print_max < UINT_MAX)
	i = val_print_string (addr, -1, TYPE_LENGTH (elttype), stream);

      /* Return number of characters printed, plus one for the
         terminating null if we have "reached the end".  */
      return (i + (print_max && i != print_max));
      break;

    case TYPE_CODE_STRING:
      i = TYPE_LENGTH (type);
      LA_PRINT_STRING (stream, valaddr, i, 1, 0);
      /* Return number of characters printed, plus one for the terminating
         null if we have "reached the end".  */
      return (i + (print_max && i != print_max));
      break;

    case TYPE_CODE_BITSTRING:
    case TYPE_CODE_SET:
      elttype = TYPE_INDEX_TYPE (type);
      CHECK_TYPEDEF (elttype);
      if (TYPE_STUB (elttype))
	{
	  fprintf_filtered (stream, "<incomplete type>");
	  gdb_flush (stream);
	  break;
	}
      {
	struct type *range = elttype;
	LONGEST low_bound, high_bound;
	int i;
	int is_bitstring = TYPE_CODE (type) == TYPE_CODE_BITSTRING;
	int need_comma = 0;

	if (is_bitstring)
	  fputs_filtered ("B'", stream);
	else
	  fputs_filtered ("[", stream);

	i = get_discrete_bounds (range, &low_bound, &high_bound);
      maybe_bad_bstring:
	if (i < 0)
	  {
	    fputs_filtered ("<error value>", stream);
	    goto done;
	  }

	for (i = low_bound; i <= high_bound; i++)
	  {
	    int element = value_bit_index (type, valaddr, i);
	    if (element < 0)
	      {
		i = element;
		goto maybe_bad_bstring;
	      }
	    if (is_bitstring)
	      fprintf_filtered (stream, "%d", element);
	    else if (element)
	      {
		if (need_comma)
		  fputs_filtered (", ", stream);
		chill_print_type_scalar (range, (LONGEST) i, stream);
		need_comma = 1;

		/* Look for a continuous range of true elements. */
		if (i + 1 <= high_bound && value_bit_index (type, valaddr, ++i))
		  {
		    int j = i;	/* j is the upper bound so far of the range */
		    fputs_filtered (":", stream);
		    while (i + 1 <= high_bound
			   && value_bit_index (type, valaddr, ++i))
		      j = i;
		    chill_print_type_scalar (range, (LONGEST) j, stream);
		  }
	      }
	  }
      done:
	if (is_bitstring)
	  fputs_filtered ("'", stream);
	else
	  fputs_filtered ("]", stream);
      }
      break;

    case TYPE_CODE_STRUCT:
      if (chill_varying_type (type))
	{
	  struct type *inner = check_typedef (TYPE_FIELD_TYPE (type, 1));
	  long length = unpack_long (TYPE_FIELD_TYPE (type, 0), valaddr);
	  char *data_addr = valaddr + TYPE_FIELD_BITPOS (type, 1) / 8;

	  switch (TYPE_CODE (inner))
	    {
	    case TYPE_CODE_STRING:
	      if (length > TYPE_LENGTH (type) - 2)
		{
		  fprintf_filtered (stream,
			"<dynamic length %ld > static length %d> *invalid*",
				    length, TYPE_LENGTH (type));

		  /* Don't print the string; doing so might produce a
		     segfault.  */
		  return length;
		}
	      LA_PRINT_STRING (stream, data_addr, length, 1, 0);
	      return length;
	    default:
	      break;
	    }
	}
      chill_print_value_fields (type, valaddr, stream, format, recurse, pretty,
				0);
      break;

    case TYPE_CODE_REF:
      if (addressprint)
	{
	  fprintf_filtered (stream, "LOC(");
	  print_address_numeric
	    (extract_address (valaddr, TARGET_PTR_BIT / HOST_CHAR_BIT),
	     1,
	     stream);
	  fprintf_filtered (stream, ")");
	  if (deref_ref)
	    fputs_filtered (": ", stream);
	}
      /* De-reference the reference.  */
      if (deref_ref)
	{
	  if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_UNDEF)
	    {
	      struct value *deref_val =
	      value_at
	      (TYPE_TARGET_TYPE (type),
	       unpack_pointer (lookup_pointer_type (builtin_type_void),
			       valaddr),
	       NULL);
	      val_print (VALUE_TYPE (deref_val),
			 VALUE_CONTENTS (deref_val),
			 0,
			 VALUE_ADDRESS (deref_val), stream, format,
			 deref_ref, recurse + 1, pretty);
	    }
	  else
	    fputs_filtered ("???", stream);
	}
      break;

    case TYPE_CODE_ENUM:
      c_val_print (type, valaddr, 0, address, stream, format,
		   deref_ref, recurse, pretty);
      break;

    case TYPE_CODE_RANGE:
      if (TYPE_TARGET_TYPE (type))
	chill_val_print (TYPE_TARGET_TYPE (type), valaddr, 0, address, stream,
			 format, deref_ref, recurse, pretty);
      break;

    case TYPE_CODE_MEMBER:
    case TYPE_CODE_UNION:
    case TYPE_CODE_FUNC:
    case TYPE_CODE_VOID:
    case TYPE_CODE_ERROR:
    default:
      /* Let's defer printing to the C printer, rather than
         print an error message.  FIXME! */
      c_val_print (type, valaddr, 0, address, stream, format,
		   deref_ref, recurse, pretty);
    }
  gdb_flush (stream);
  return (0);
}

/* Mutually recursive subroutines of cplus_print_value and c_val_print to
   print out a structure's fields: cp_print_value_fields and cplus_print_value.

   TYPE, VALADDR, STREAM, RECURSE, and PRETTY have the
   same meanings as in cplus_print_value and c_val_print.

   DONT_PRINT is an array of baseclass types that we
   should not print, or zero if called from top level.  */

static void
chill_print_value_fields (struct type *type, char *valaddr,
			  struct ui_file *stream, int format, int recurse,
			  enum val_prettyprint pretty, struct type **dont_print)
{
  int i, len;
  int fields_seen = 0;

  CHECK_TYPEDEF (type);

  fprintf_filtered (stream, "[");
  len = TYPE_NFIELDS (type);
  if (len == 0)
    {
      fprintf_filtered (stream, "<No data fields>");
    }
  else
    {
      for (i = 0; i < len; i++)
	{
	  if (fields_seen)
	    {
	      fprintf_filtered (stream, ", ");
	    }
	  fields_seen = 1;
	  if (pretty)
	    {
	      fprintf_filtered (stream, "\n");
	      print_spaces_filtered (2 + 2 * recurse, stream);
	    }
	  else
	    {
	      wrap_here (n_spaces (2 + 2 * recurse));
	    }
	  fputs_filtered (".", stream);
	  fprintf_symbol_filtered (stream, TYPE_FIELD_NAME (type, i),
				   language_chill, DMGL_NO_OPTS);
	  fputs_filtered (": ", stream);
	  if (TYPE_FIELD_PACKED (type, i))
	    {
	      struct value *v;

	      /* Bitfields require special handling, especially due to byte
	         order problems.  */
	      v = value_from_longest (TYPE_FIELD_TYPE (type, i),
				   unpack_field_as_long (type, valaddr, i));

	      chill_val_print (TYPE_FIELD_TYPE (type, i), VALUE_CONTENTS (v), 0, 0,
			       stream, format, 0, recurse + 1, pretty);
	    }
	  else
	    {
	      chill_val_print (TYPE_FIELD_TYPE (type, i),
			       valaddr + TYPE_FIELD_BITPOS (type, i) / 8, 0,
			       0, stream, format, 0, recurse + 1, pretty);
	    }
	}
      if (pretty)
	{
	  fprintf_filtered (stream, "\n");
	  print_spaces_filtered (2 * recurse, stream);
	}
    }
  fprintf_filtered (stream, "]");
}

int
chill_value_print (struct value *val, struct ui_file *stream, int format,
		   enum val_prettyprint pretty)
{
  struct type *type = VALUE_TYPE (val);
  struct type *real_type = check_typedef (type);

  /* If it is a pointer, indicate what it points to.

     Print type also if it is a reference. */

  if (TYPE_CODE (real_type) == TYPE_CODE_PTR ||
      TYPE_CODE (real_type) == TYPE_CODE_REF)
    {
      char *valaddr = VALUE_CONTENTS (val);
      CORE_ADDR addr = unpack_pointer (type, valaddr);
      if (TYPE_CODE (type) != TYPE_CODE_PTR || addr != 0)
	{
	  int i;
	  char *name = TYPE_NAME (type);
	  if (name)
	    fputs_filtered (name, stream);
	  else if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_VOID)
	    fputs_filtered ("PTR", stream);
	  else
	    {
	      fprintf_filtered (stream, "(");
	      type_print (type, "", stream, -1);
	      fprintf_filtered (stream, ")");
	    }
	  fprintf_filtered (stream, "(");
	  i = val_print (type, valaddr, 0, VALUE_ADDRESS (val),
			 stream, format, 1, 0, pretty);
	  fprintf_filtered (stream, ")");
	  return i;
	}
    }
  return (val_print (type, VALUE_CONTENTS (val), 0,
		     VALUE_ADDRESS (val), stream, format, 1, 0, pretty));
}
@


1.5
log
@Approved by Jim Blandy:

	2001-12-11  Fred Fish  <fnf@@redhat.com>
	* c-typeprint.c (c_type_print_base): Use type flags access macros
	to test bits.
	* ch-typeprint.c (chill_type_print_base): Ditto.
	* ch-valprint.c (chill_val_print): Ditto.
	* d10v-tdep.c (d10v_pointer_to_address): Ditto.
	* dwarf2read.c (dwarf2_add_member_fn): Ditto.
	* dwarfread.c (read_structure_scope): Ditto.
	* gdbtypes.c (create_range_type): Dittol
	(create_set_type): Ditto.
	(check_typedef): Ditto.
	* jv-typeprint.c (java_type_print_base): Ditto.
	* p-typeprint.c (pascal_type_print_base): Ditto
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (read_cfront_member_functions): Ditto.
	(read_member_functions): Ditto.
	(cleanup_undefined_types): Ditto.
	* valprint.c (val_print): Ditto.
	* valops.c (hand_function_call): Remove is_prototyped
	variable and just use type flag test macro directly.
@
text
@d24 1
a24 1
#include "obstack.h"
@


1.5.8.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d1 605
a605 605
// OBSOLETE /* Support for printing Chill values for GDB, the GNU debugger.
// OBSOLETE    Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
// OBSOLETE    1998, 2000, 2001
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "gdb_obstack.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "gdbtypes.h"
// OBSOLETE #include "valprint.h"
// OBSOLETE #include "expression.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "language.h"
// OBSOLETE #include "demangle.h"
// OBSOLETE #include "c-lang.h"		/* For c_val_print */
// OBSOLETE #include "typeprint.h"
// OBSOLETE #include "ch-lang.h"
// OBSOLETE #include "annotate.h"
// OBSOLETE 
// OBSOLETE static void chill_print_value_fields (struct type *, char *,
// OBSOLETE 				      struct ui_file *, int, int,
// OBSOLETE 				      enum val_prettyprint, struct type **);
// OBSOLETE 
// OBSOLETE static void chill_print_type_scalar (struct type *, LONGEST,
// OBSOLETE 				     struct ui_file *);
// OBSOLETE 
// OBSOLETE static void chill_val_print_array_elements (struct type *, char *,
// OBSOLETE 					    CORE_ADDR, struct ui_file *,
// OBSOLETE 					    int, int, int,
// OBSOLETE 					    enum val_prettyprint);
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Print integral scalar data VAL, of type TYPE, onto stdio stream STREAM.
// OBSOLETE    Used to print data from type structures in a specified type.  For example,
// OBSOLETE    array bounds may be characters or booleans in some languages, and this
// OBSOLETE    allows the ranges to be printed in their "natural" form rather than as
// OBSOLETE    decimal integer values. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE chill_print_type_scalar (struct type *type, LONGEST val, struct ui_file *stream)
// OBSOLETE {
// OBSOLETE   switch (TYPE_CODE (type))
// OBSOLETE     {
// OBSOLETE     case TYPE_CODE_RANGE:
// OBSOLETE       if (TYPE_TARGET_TYPE (type))
// OBSOLETE 	{
// OBSOLETE 	  chill_print_type_scalar (TYPE_TARGET_TYPE (type), val, stream);
// OBSOLETE 	  return;
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE     case TYPE_CODE_UNDEF:
// OBSOLETE     case TYPE_CODE_PTR:
// OBSOLETE     case TYPE_CODE_ARRAY:
// OBSOLETE     case TYPE_CODE_STRUCT:
// OBSOLETE     case TYPE_CODE_UNION:
// OBSOLETE     case TYPE_CODE_ENUM:
// OBSOLETE     case TYPE_CODE_FUNC:
// OBSOLETE     case TYPE_CODE_INT:
// OBSOLETE     case TYPE_CODE_FLT:
// OBSOLETE     case TYPE_CODE_VOID:
// OBSOLETE     case TYPE_CODE_SET:
// OBSOLETE     case TYPE_CODE_STRING:
// OBSOLETE     case TYPE_CODE_BITSTRING:
// OBSOLETE     case TYPE_CODE_ERROR:
// OBSOLETE     case TYPE_CODE_MEMBER:
// OBSOLETE     case TYPE_CODE_METHOD:
// OBSOLETE     case TYPE_CODE_REF:
// OBSOLETE     case TYPE_CODE_CHAR:
// OBSOLETE     case TYPE_CODE_BOOL:
// OBSOLETE     case TYPE_CODE_COMPLEX:
// OBSOLETE     case TYPE_CODE_TYPEDEF:
// OBSOLETE     default:
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE   print_type_scalar (type, val, stream);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Print the elements of an array.
// OBSOLETE    Similar to val_print_array_elements, but prints
// OBSOLETE    element indexes (in Chill syntax). */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE chill_val_print_array_elements (struct type *type, char *valaddr,
// OBSOLETE 				CORE_ADDR address, struct ui_file *stream,
// OBSOLETE 				int format, int deref_ref, int recurse,
// OBSOLETE 				enum val_prettyprint pretty)
// OBSOLETE {
// OBSOLETE   unsigned int i = 0;
// OBSOLETE   unsigned int things_printed = 0;
// OBSOLETE   unsigned len;
// OBSOLETE   struct type *elttype;
// OBSOLETE   struct type *range_type = TYPE_FIELD_TYPE (type, 0);
// OBSOLETE   struct type *index_type = TYPE_TARGET_TYPE (range_type);
// OBSOLETE   unsigned eltlen;
// OBSOLETE   /* Position of the array element we are examining to see
// OBSOLETE      whether it is repeated.  */
// OBSOLETE   unsigned int rep1;
// OBSOLETE   /* Number of repetitions we have detected so far.  */
// OBSOLETE   unsigned int reps;
// OBSOLETE   LONGEST low_bound = TYPE_FIELD_BITPOS (range_type, 0);
// OBSOLETE 
// OBSOLETE   elttype = check_typedef (TYPE_TARGET_TYPE (type));
// OBSOLETE   eltlen = TYPE_LENGTH (elttype);
// OBSOLETE   len = TYPE_LENGTH (type) / eltlen;
// OBSOLETE 
// OBSOLETE   annotate_array_section_begin (i, elttype);
// OBSOLETE 
// OBSOLETE   for (; i < len && things_printed < print_max; i++)
// OBSOLETE     {
// OBSOLETE       if (i != 0)
// OBSOLETE 	{
// OBSOLETE 	  if (prettyprint_arrays)
// OBSOLETE 	    {
// OBSOLETE 	      fprintf_filtered (stream, ",\n");
// OBSOLETE 	      print_spaces_filtered (2 + 2 * recurse, stream);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      fprintf_filtered (stream, ", ");
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       wrap_here (n_spaces (2 + 2 * recurse));
// OBSOLETE 
// OBSOLETE       rep1 = i + 1;
// OBSOLETE       reps = 1;
// OBSOLETE       while ((rep1 < len) &&
// OBSOLETE 	     !memcmp (valaddr + i * eltlen, valaddr + rep1 * eltlen, eltlen))
// OBSOLETE 	{
// OBSOLETE 	  ++reps;
// OBSOLETE 	  ++rep1;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       fputs_filtered ("(", stream);
// OBSOLETE       chill_print_type_scalar (index_type, low_bound + i, stream);
// OBSOLETE       if (reps > 1)
// OBSOLETE 	{
// OBSOLETE 	  fputs_filtered (":", stream);
// OBSOLETE 	  chill_print_type_scalar (index_type, low_bound + i + reps - 1,
// OBSOLETE 				   stream);
// OBSOLETE 	  fputs_filtered ("): ", stream);
// OBSOLETE 	  val_print (elttype, valaddr + i * eltlen, 0, 0, stream, format,
// OBSOLETE 		     deref_ref, recurse + 1, pretty);
// OBSOLETE 
// OBSOLETE 	  i = rep1 - 1;
// OBSOLETE 	  things_printed += 1;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  fputs_filtered ("): ", stream);
// OBSOLETE 	  val_print (elttype, valaddr + i * eltlen, 0, 0, stream, format,
// OBSOLETE 		     deref_ref, recurse + 1, pretty);
// OBSOLETE 	  annotate_elt ();
// OBSOLETE 	  things_printed++;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   annotate_array_section_end ();
// OBSOLETE   if (i < len)
// OBSOLETE     {
// OBSOLETE       fprintf_filtered (stream, "...");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Print data of type TYPE located at VALADDR (within GDB), which came from
// OBSOLETE    the inferior at address ADDRESS, onto stdio stream STREAM according to
// OBSOLETE    FORMAT (a letter or 0 for natural format).  The data at VALADDR is in
// OBSOLETE    target byte order.
// OBSOLETE 
// OBSOLETE    If the data are a string pointer, returns the number of string characters
// OBSOLETE    printed.
// OBSOLETE 
// OBSOLETE    If DEREF_REF is nonzero, then dereference references, otherwise just print
// OBSOLETE    them like pointers.
// OBSOLETE 
// OBSOLETE    The PRETTY parameter controls prettyprinting.  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE chill_val_print (struct type *type, char *valaddr, int embedded_offset,
// OBSOLETE 		 CORE_ADDR address, struct ui_file *stream, int format,
// OBSOLETE 		 int deref_ref, int recurse, enum val_prettyprint pretty)
// OBSOLETE {
// OBSOLETE   LONGEST val;
// OBSOLETE   unsigned int i = 0;		/* Number of characters printed.  */
// OBSOLETE   struct type *elttype;
// OBSOLETE   CORE_ADDR addr;
// OBSOLETE 
// OBSOLETE   CHECK_TYPEDEF (type);
// OBSOLETE 
// OBSOLETE   switch (TYPE_CODE (type))
// OBSOLETE     {
// OBSOLETE     case TYPE_CODE_ARRAY:
// OBSOLETE       if (TYPE_LENGTH (type) > 0 && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0)
// OBSOLETE 	{
// OBSOLETE 	  if (prettyprint_arrays)
// OBSOLETE 	    {
// OBSOLETE 	      print_spaces_filtered (2 + 2 * recurse, stream);
// OBSOLETE 	    }
// OBSOLETE 	  fprintf_filtered (stream, "[");
// OBSOLETE 	  chill_val_print_array_elements (type, valaddr, address, stream,
// OBSOLETE 					format, deref_ref, recurse, pretty);
// OBSOLETE 	  fprintf_filtered (stream, "]");
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  error ("unimplemented in chill_val_print; unspecified array length");
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_INT:
// OBSOLETE       format = format ? format : output_format;
// OBSOLETE       if (format)
// OBSOLETE 	{
// OBSOLETE 	  print_scalar_formatted (valaddr, type, format, 0, stream);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  val_print_type_code_int (type, valaddr, stream);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_CHAR:
// OBSOLETE       format = format ? format : output_format;
// OBSOLETE       if (format)
// OBSOLETE 	{
// OBSOLETE 	  print_scalar_formatted (valaddr, type, format, 0, stream);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  LA_PRINT_CHAR ((unsigned char) unpack_long (type, valaddr),
// OBSOLETE 			 stream);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_FLT:
// OBSOLETE       if (format)
// OBSOLETE 	{
// OBSOLETE 	  print_scalar_formatted (valaddr, type, format, 0, stream);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  print_floating (valaddr, type, stream);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_BOOL:
// OBSOLETE       format = format ? format : output_format;
// OBSOLETE       if (format)
// OBSOLETE 	{
// OBSOLETE 	  print_scalar_formatted (valaddr, type, format, 0, stream);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* FIXME: Why is this using builtin_type_chill_bool not type?  */
// OBSOLETE 	  val = unpack_long (builtin_type_chill_bool, valaddr);
// OBSOLETE 	  fprintf_filtered (stream, val ? "TRUE" : "FALSE");
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_UNDEF:
// OBSOLETE       /* This happens (without TYPE_FLAG_STUB set) on systems which don't use
// OBSOLETE          dbx xrefs (NO_DBX_XREFS in gcc) if a file has a "struct foo *bar"
// OBSOLETE          and no complete type for struct foo in that file.  */
// OBSOLETE       fprintf_filtered (stream, "<incomplete type>");
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_PTR:
// OBSOLETE       if (format && format != 's')
// OBSOLETE 	{
// OBSOLETE 	  print_scalar_formatted (valaddr, type, format, 0, stream);
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       addr = unpack_pointer (type, valaddr);
// OBSOLETE       elttype = check_typedef (TYPE_TARGET_TYPE (type));
// OBSOLETE 
// OBSOLETE       /* We assume a NULL pointer is all zeros ... */
// OBSOLETE       if (addr == 0)
// OBSOLETE 	{
// OBSOLETE 	  fputs_filtered ("NULL", stream);
// OBSOLETE 	  return 0;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (TYPE_CODE (elttype) == TYPE_CODE_FUNC)
// OBSOLETE 	{
// OBSOLETE 	  /* Try to print what function it points to.  */
// OBSOLETE 	  print_address_demangle (addr, stream, demangle);
// OBSOLETE 	  /* Return value is irrelevant except for string pointers.  */
// OBSOLETE 	  return (0);
// OBSOLETE 	}
// OBSOLETE       if (addressprint && format != 's')
// OBSOLETE 	{
// OBSOLETE 	  print_address_numeric (addr, 1, stream);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* For a pointer to char or unsigned char, also print the string
// OBSOLETE          pointed to, unless pointer is null.  */
// OBSOLETE       if (TYPE_LENGTH (elttype) == 1
// OBSOLETE 	  && TYPE_CODE (elttype) == TYPE_CODE_CHAR
// OBSOLETE 	  && (format == 0 || format == 's')
// OBSOLETE 	  && addr != 0
// OBSOLETE 	  &&			/* If print_max is UINT_MAX, the alloca below will fail.
// OBSOLETE 				   In that case don't try to print the string.  */
// OBSOLETE 	  print_max < UINT_MAX)
// OBSOLETE 	i = val_print_string (addr, -1, TYPE_LENGTH (elttype), stream);
// OBSOLETE 
// OBSOLETE       /* Return number of characters printed, plus one for the
// OBSOLETE          terminating null if we have "reached the end".  */
// OBSOLETE       return (i + (print_max && i != print_max));
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_STRING:
// OBSOLETE       i = TYPE_LENGTH (type);
// OBSOLETE       LA_PRINT_STRING (stream, valaddr, i, 1, 0);
// OBSOLETE       /* Return number of characters printed, plus one for the terminating
// OBSOLETE          null if we have "reached the end".  */
// OBSOLETE       return (i + (print_max && i != print_max));
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_BITSTRING:
// OBSOLETE     case TYPE_CODE_SET:
// OBSOLETE       elttype = TYPE_INDEX_TYPE (type);
// OBSOLETE       CHECK_TYPEDEF (elttype);
// OBSOLETE       if (TYPE_STUB (elttype))
// OBSOLETE 	{
// OBSOLETE 	  fprintf_filtered (stream, "<incomplete type>");
// OBSOLETE 	  gdb_flush (stream);
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       {
// OBSOLETE 	struct type *range = elttype;
// OBSOLETE 	LONGEST low_bound, high_bound;
// OBSOLETE 	int i;
// OBSOLETE 	int is_bitstring = TYPE_CODE (type) == TYPE_CODE_BITSTRING;
// OBSOLETE 	int need_comma = 0;
// OBSOLETE 
// OBSOLETE 	if (is_bitstring)
// OBSOLETE 	  fputs_filtered ("B'", stream);
// OBSOLETE 	else
// OBSOLETE 	  fputs_filtered ("[", stream);
// OBSOLETE 
// OBSOLETE 	i = get_discrete_bounds (range, &low_bound, &high_bound);
// OBSOLETE       maybe_bad_bstring:
// OBSOLETE 	if (i < 0)
// OBSOLETE 	  {
// OBSOLETE 	    fputs_filtered ("<error value>", stream);
// OBSOLETE 	    goto done;
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE 	for (i = low_bound; i <= high_bound; i++)
// OBSOLETE 	  {
// OBSOLETE 	    int element = value_bit_index (type, valaddr, i);
// OBSOLETE 	    if (element < 0)
// OBSOLETE 	      {
// OBSOLETE 		i = element;
// OBSOLETE 		goto maybe_bad_bstring;
// OBSOLETE 	      }
// OBSOLETE 	    if (is_bitstring)
// OBSOLETE 	      fprintf_filtered (stream, "%d", element);
// OBSOLETE 	    else if (element)
// OBSOLETE 	      {
// OBSOLETE 		if (need_comma)
// OBSOLETE 		  fputs_filtered (", ", stream);
// OBSOLETE 		chill_print_type_scalar (range, (LONGEST) i, stream);
// OBSOLETE 		need_comma = 1;
// OBSOLETE 
// OBSOLETE 		/* Look for a continuous range of true elements. */
// OBSOLETE 		if (i + 1 <= high_bound && value_bit_index (type, valaddr, ++i))
// OBSOLETE 		  {
// OBSOLETE 		    int j = i;	/* j is the upper bound so far of the range */
// OBSOLETE 		    fputs_filtered (":", stream);
// OBSOLETE 		    while (i + 1 <= high_bound
// OBSOLETE 			   && value_bit_index (type, valaddr, ++i))
// OBSOLETE 		      j = i;
// OBSOLETE 		    chill_print_type_scalar (range, (LONGEST) j, stream);
// OBSOLETE 		  }
// OBSOLETE 	      }
// OBSOLETE 	  }
// OBSOLETE       done:
// OBSOLETE 	if (is_bitstring)
// OBSOLETE 	  fputs_filtered ("'", stream);
// OBSOLETE 	else
// OBSOLETE 	  fputs_filtered ("]", stream);
// OBSOLETE       }
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_STRUCT:
// OBSOLETE       if (chill_varying_type (type))
// OBSOLETE 	{
// OBSOLETE 	  struct type *inner = check_typedef (TYPE_FIELD_TYPE (type, 1));
// OBSOLETE 	  long length = unpack_long (TYPE_FIELD_TYPE (type, 0), valaddr);
// OBSOLETE 	  char *data_addr = valaddr + TYPE_FIELD_BITPOS (type, 1) / 8;
// OBSOLETE 
// OBSOLETE 	  switch (TYPE_CODE (inner))
// OBSOLETE 	    {
// OBSOLETE 	    case TYPE_CODE_STRING:
// OBSOLETE 	      if (length > TYPE_LENGTH (type) - 2)
// OBSOLETE 		{
// OBSOLETE 		  fprintf_filtered (stream,
// OBSOLETE 			"<dynamic length %ld > static length %d> *invalid*",
// OBSOLETE 				    length, TYPE_LENGTH (type));
// OBSOLETE 
// OBSOLETE 		  /* Don't print the string; doing so might produce a
// OBSOLETE 		     segfault.  */
// OBSOLETE 		  return length;
// OBSOLETE 		}
// OBSOLETE 	      LA_PRINT_STRING (stream, data_addr, length, 1, 0);
// OBSOLETE 	      return length;
// OBSOLETE 	    default:
// OBSOLETE 	      break;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       chill_print_value_fields (type, valaddr, stream, format, recurse, pretty,
// OBSOLETE 				0);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_REF:
// OBSOLETE       if (addressprint)
// OBSOLETE 	{
// OBSOLETE 	  fprintf_filtered (stream, "LOC(");
// OBSOLETE 	  print_address_numeric
// OBSOLETE 	    (extract_address (valaddr, TARGET_PTR_BIT / HOST_CHAR_BIT),
// OBSOLETE 	     1,
// OBSOLETE 	     stream);
// OBSOLETE 	  fprintf_filtered (stream, ")");
// OBSOLETE 	  if (deref_ref)
// OBSOLETE 	    fputs_filtered (": ", stream);
// OBSOLETE 	}
// OBSOLETE       /* De-reference the reference.  */
// OBSOLETE       if (deref_ref)
// OBSOLETE 	{
// OBSOLETE 	  if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_UNDEF)
// OBSOLETE 	    {
// OBSOLETE 	      struct value *deref_val =
// OBSOLETE 	      value_at
// OBSOLETE 	      (TYPE_TARGET_TYPE (type),
// OBSOLETE 	       unpack_pointer (lookup_pointer_type (builtin_type_void),
// OBSOLETE 			       valaddr),
// OBSOLETE 	       NULL);
// OBSOLETE 	      val_print (VALUE_TYPE (deref_val),
// OBSOLETE 			 VALUE_CONTENTS (deref_val),
// OBSOLETE 			 0,
// OBSOLETE 			 VALUE_ADDRESS (deref_val), stream, format,
// OBSOLETE 			 deref_ref, recurse + 1, pretty);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    fputs_filtered ("???", stream);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_ENUM:
// OBSOLETE       c_val_print (type, valaddr, 0, address, stream, format,
// OBSOLETE 		   deref_ref, recurse, pretty);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_RANGE:
// OBSOLETE       if (TYPE_TARGET_TYPE (type))
// OBSOLETE 	chill_val_print (TYPE_TARGET_TYPE (type), valaddr, 0, address, stream,
// OBSOLETE 			 format, deref_ref, recurse, pretty);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_MEMBER:
// OBSOLETE     case TYPE_CODE_UNION:
// OBSOLETE     case TYPE_CODE_FUNC:
// OBSOLETE     case TYPE_CODE_VOID:
// OBSOLETE     case TYPE_CODE_ERROR:
// OBSOLETE     default:
// OBSOLETE       /* Let's defer printing to the C printer, rather than
// OBSOLETE          print an error message.  FIXME! */
// OBSOLETE       c_val_print (type, valaddr, 0, address, stream, format,
// OBSOLETE 		   deref_ref, recurse, pretty);
// OBSOLETE     }
// OBSOLETE   gdb_flush (stream);
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Mutually recursive subroutines of cplus_print_value and c_val_print to
// OBSOLETE    print out a structure's fields: cp_print_value_fields and cplus_print_value.
// OBSOLETE 
// OBSOLETE    TYPE, VALADDR, STREAM, RECURSE, and PRETTY have the
// OBSOLETE    same meanings as in cplus_print_value and c_val_print.
// OBSOLETE 
// OBSOLETE    DONT_PRINT is an array of baseclass types that we
// OBSOLETE    should not print, or zero if called from top level.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE chill_print_value_fields (struct type *type, char *valaddr,
// OBSOLETE 			  struct ui_file *stream, int format, int recurse,
// OBSOLETE 			  enum val_prettyprint pretty, struct type **dont_print)
// OBSOLETE {
// OBSOLETE   int i, len;
// OBSOLETE   int fields_seen = 0;
// OBSOLETE 
// OBSOLETE   CHECK_TYPEDEF (type);
// OBSOLETE 
// OBSOLETE   fprintf_filtered (stream, "[");
// OBSOLETE   len = TYPE_NFIELDS (type);
// OBSOLETE   if (len == 0)
// OBSOLETE     {
// OBSOLETE       fprintf_filtered (stream, "<No data fields>");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       for (i = 0; i < len; i++)
// OBSOLETE 	{
// OBSOLETE 	  if (fields_seen)
// OBSOLETE 	    {
// OBSOLETE 	      fprintf_filtered (stream, ", ");
// OBSOLETE 	    }
// OBSOLETE 	  fields_seen = 1;
// OBSOLETE 	  if (pretty)
// OBSOLETE 	    {
// OBSOLETE 	      fprintf_filtered (stream, "\n");
// OBSOLETE 	      print_spaces_filtered (2 + 2 * recurse, stream);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      wrap_here (n_spaces (2 + 2 * recurse));
// OBSOLETE 	    }
// OBSOLETE 	  fputs_filtered (".", stream);
// OBSOLETE 	  fprintf_symbol_filtered (stream, TYPE_FIELD_NAME (type, i),
// OBSOLETE 				   language_chill, DMGL_NO_OPTS);
// OBSOLETE 	  fputs_filtered (": ", stream);
// OBSOLETE 	  if (TYPE_FIELD_PACKED (type, i))
// OBSOLETE 	    {
// OBSOLETE 	      struct value *v;
// OBSOLETE 
// OBSOLETE 	      /* Bitfields require special handling, especially due to byte
// OBSOLETE 	         order problems.  */
// OBSOLETE 	      v = value_from_longest (TYPE_FIELD_TYPE (type, i),
// OBSOLETE 				   unpack_field_as_long (type, valaddr, i));
// OBSOLETE 
// OBSOLETE 	      chill_val_print (TYPE_FIELD_TYPE (type, i), VALUE_CONTENTS (v), 0, 0,
// OBSOLETE 			       stream, format, 0, recurse + 1, pretty);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      chill_val_print (TYPE_FIELD_TYPE (type, i),
// OBSOLETE 			       valaddr + TYPE_FIELD_BITPOS (type, i) / 8, 0,
// OBSOLETE 			       0, stream, format, 0, recurse + 1, pretty);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       if (pretty)
// OBSOLETE 	{
// OBSOLETE 	  fprintf_filtered (stream, "\n");
// OBSOLETE 	  print_spaces_filtered (2 * recurse, stream);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   fprintf_filtered (stream, "]");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE chill_value_print (struct value *val, struct ui_file *stream, int format,
// OBSOLETE 		   enum val_prettyprint pretty)
// OBSOLETE {
// OBSOLETE   struct type *type = VALUE_TYPE (val);
// OBSOLETE   struct type *real_type = check_typedef (type);
// OBSOLETE 
// OBSOLETE   /* If it is a pointer, indicate what it points to.
// OBSOLETE 
// OBSOLETE      Print type also if it is a reference. */
// OBSOLETE 
// OBSOLETE   if (TYPE_CODE (real_type) == TYPE_CODE_PTR ||
// OBSOLETE       TYPE_CODE (real_type) == TYPE_CODE_REF)
// OBSOLETE     {
// OBSOLETE       char *valaddr = VALUE_CONTENTS (val);
// OBSOLETE       CORE_ADDR addr = unpack_pointer (type, valaddr);
// OBSOLETE       if (TYPE_CODE (type) != TYPE_CODE_PTR || addr != 0)
// OBSOLETE 	{
// OBSOLETE 	  int i;
// OBSOLETE 	  char *name = TYPE_NAME (type);
// OBSOLETE 	  if (name)
// OBSOLETE 	    fputs_filtered (name, stream);
// OBSOLETE 	  else if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_VOID)
// OBSOLETE 	    fputs_filtered ("PTR", stream);
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      fprintf_filtered (stream, "(");
// OBSOLETE 	      type_print (type, "", stream, -1);
// OBSOLETE 	      fprintf_filtered (stream, ")");
// OBSOLETE 	    }
// OBSOLETE 	  fprintf_filtered (stream, "(");
// OBSOLETE 	  i = val_print (type, valaddr, 0, VALUE_ADDRESS (val),
// OBSOLETE 			 stream, format, 1, 0, pretty);
// OBSOLETE 	  fprintf_filtered (stream, ")");
// OBSOLETE 	  return i;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   return (val_print (type, VALUE_CONTENTS (val), 0,
// OBSOLETE 		     VALUE_ADDRESS (val), stream, format, 1, 0, pretty));
// OBSOLETE }
@


1.4
log
@s/value_ptr/struct value */
@
text
@d338 1
a338 1
      if (TYPE_FLAGS (elttype) & TYPE_FLAG_STUB)
@


1.3
log
@Update/correct copyright notices.
@
text
@d3 1
a3 1
   1998, 2000
d448 1
a448 1
	      value_ptr deref_val =
d540 1
a540 1
	      value_ptr v;
d567 1
a567 1
chill_value_print (value_ptr val, struct ui_file *stream, int format,
@


1.3.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d208 1
a208 1
      if (TYPE_LENGTH (type) > 0 && TYPE_LENGTH (ARRAY_RANGE_TYPE (type)) > 0)
d289 1
a289 1
      elttype = check_typedef (POINTER_TARGET_TYPE (type));
d333 1
d336 1
a336 1
      elttype = (struct type *) SET_RANGE_TYPE (type);
d345 1
a345 1
	struct range_type *range = (struct range_type *) elttype;
d356 1
a356 3
	low_bound = RANGE_LOWER_BOUND (range);
	high_bound = RANGE_UPPER_BOUND (range);
	i = (low_bound < 0 || high_bound < 0) ? -1 : 0;
d378 1
a378 1
		chill_print_type_scalar ((struct type *)range, (LONGEST) i, stream);
d389 1
a389 1
		    chill_print_type_scalar ((struct type *)range, (LONGEST) j, stream);
d400 1
d446 1
a446 1
	  if (TYPE_CODE (POINTER_TARGET_TYPE (type)) != TYPE_CODE_UNDEF)
d450 1
a450 1
	      (POINTER_TARGET_TYPE (type),
d576 1
d585 1
a585 1
	  const char *name = TYPE_NAME (type);
d588 1
a588 1
	  else if (TYPE_CODE (POINTER_TARGET_TYPE (type)) == TYPE_CODE_VOID)
@


1.2
log
@Protoization.
@
text
@d2 2
a3 1
   Copyright 1986, 1988, 1989, 1991-1994, 2000
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994
d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 1
a31 1
#include "c-lang.h" /* For c_val_print */
d36 12
a47 6
static void
chill_print_value_fields PARAMS ((struct type *, char *, GDB_FILE *, int, int,
				  enum val_prettyprint, struct type **));

static void
chill_print_type_scalar PARAMS ((struct type *, LONGEST, GDB_FILE *));
a48 5
static void
chill_val_print_array_elements PARAMS ((struct type *, char *, CORE_ADDR, GDB_FILE *,
					int, int, int, enum val_prettyprint));


d56 1
a56 4
chill_print_type_scalar (type, val, stream)
     struct type *type;
     LONGEST val;
     GDB_FILE *stream;
d99 4
a102 10
chill_val_print_array_elements (type, valaddr, address, stream,
				format, deref_ref, recurse, pretty)
     struct type *type;
     char *valaddr;
     CORE_ADDR address;
     GDB_FILE *stream;
     int format;
     int deref_ref;
     int recurse;
     enum val_prettyprint pretty;
d116 2
a117 2
  LONGEST low_bound =  TYPE_FIELD_BITPOS (range_type, 0);
      
d142 1
a142 1
      while ((rep1 < len) && 
d193 3
a195 11
chill_val_print (type, valaddr, embedded_offset, address,
                 stream, format, deref_ref, recurse, pretty)
     struct type *type;
     char *valaddr;
     int embedded_offset;
     CORE_ADDR address;
     GDB_FILE *stream;
     int format;
     int deref_ref;
     int recurse;
     enum val_prettyprint pretty;
d215 1
a215 1
					  format, deref_ref, recurse, pretty);
d276 2
a277 2
	 dbx xrefs (NO_DBX_XREFS in gcc) if a file has a "struct foo *bar"
	 and no complete type for struct foo in that file.  */
d296 1
a296 1
      
d308 1
a308 1
      
d310 1
a310 1
	 pointed to, unless pointer is null.  */
d315 2
a316 2
	  && /* If print_max is UINT_MAX, the alloca below will fail.
		In that case don't try to print the string.  */
d321 1
a321 1
	 terminating null if we have "reached the end".  */
d329 1
a329 1
	 null if we have "reached the end".  */
d381 1
a381 1
		if (i+1 <= high_bound && value_bit_index (type, valaddr, ++i))
d383 1
a383 1
		    int j = i; /* j is the upper bound so far of the range */
d385 1
a385 1
		    while (i+1 <= high_bound
d406 1
a406 1
	  
d413 1
a413 1
				    "<dynamic length %ld > static length %d> *invalid*",
d432 1
a432 1
        {
d441 1
a441 1
        }
d448 5
a452 5
		value_at
		  (TYPE_TARGET_TYPE (type),
		   unpack_pointer (lookup_pointer_type (builtin_type_void),
				   valaddr),
		   NULL);
d455 1
a455 1
                         0,
d482 1
a482 1
	 print an error message.  FIXME! */
d500 3
a502 9
chill_print_value_fields (type, valaddr, stream, format, recurse, pretty,
			  dont_print)
     struct type *type;
     char *valaddr;
     GDB_FILE *stream;
     int format;
     int recurse;
     enum val_prettyprint pretty;
     struct type **dont_print;
d529 1
a529 1
	  else 
d542 1
a542 1
		 order problems.  */
d544 1
a544 1
				      unpack_field_as_long (type, valaddr, i));
d551 1
a551 1
	      chill_val_print (TYPE_FIELD_TYPE (type, i), 
d566 2
a567 5
chill_value_print (val, stream, format, pretty)
     value_ptr val;
     GDB_FILE *stream;
     int format;
     enum val_prettyprint pretty;
d570 1
a570 1
  struct type *real_type = check_typedef  (type);
a604 2


@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d30 1
a30 1
#include "c-lang.h"		/* For c_val_print */
d44 2
a45 1
				      int, int, int, enum val_prettyprint));
a46 1

d123 2
a124 2
  LONGEST low_bound = TYPE_FIELD_BITPOS (range_type, 0);

d149 1
a149 1
      while ((rep1 < len) &&
d201 1
a201 1
		 stream, format, deref_ref, recurse, pretty)
d230 1
a230 1
					format, deref_ref, recurse, pretty);
d291 2
a292 2
         dbx xrefs (NO_DBX_XREFS in gcc) if a file has a "struct foo *bar"
         and no complete type for struct foo in that file.  */
d311 1
a311 1

d323 1
a323 1

d325 1
a325 1
         pointed to, unless pointer is null.  */
d330 2
a331 2
	  &&			/* If print_max is UINT_MAX, the alloca below will fail.
				   In that case don't try to print the string.  */
d336 1
a336 1
         terminating null if we have "reached the end".  */
d344 1
a344 1
         null if we have "reached the end".  */
d396 1
a396 1
		if (i + 1 <= high_bound && value_bit_index (type, valaddr, ++i))
d398 1
a398 1
		    int j = i;	/* j is the upper bound so far of the range */
d400 1
a400 1
		    while (i + 1 <= high_bound
d421 1
a421 1

d428 1
a428 1
			"<dynamic length %ld > static length %d> *invalid*",
d447 1
a447 1
	{
d456 1
a456 1
	}
d463 5
a467 5
	      value_at
	      (TYPE_TARGET_TYPE (type),
	       unpack_pointer (lookup_pointer_type (builtin_type_void),
			       valaddr),
	       NULL);
d470 1
a470 1
			 0,
d497 1
a497 1
         print an error message.  FIXME! */
d550 1
a550 1
	  else
d563 1
a563 1
	         order problems.  */
d565 1
a565 1
				   unpack_field_as_long (type, valaddr, i));
d572 1
a572 1
	      chill_val_print (TYPE_FIELD_TYPE (type, i),
d594 1
a594 1
  struct type *real_type = check_typedef (type);
d629 2
@


1.1.1.3
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright 1986, 1988, 1989, 1991-1994, 2000
d36 10
a45 11
static void chill_print_value_fields (struct type *, char *,
				      struct ui_file *, int, int,
				      enum val_prettyprint, struct type **);

static void chill_print_type_scalar (struct type *, LONGEST,
				     struct ui_file *);

static void chill_val_print_array_elements (struct type *, char *,
					    CORE_ADDR, struct ui_file *,
					    int, int, int,
					    enum val_prettyprint);
d58 1
a58 1
     struct ui_file *stream;
d106 1
a106 1
     struct ui_file *stream;
d207 1
a207 1
     struct ui_file *stream;
d520 1
a520 1
     struct ui_file *stream;
d590 1
a590 1
     struct ui_file *stream;
@


