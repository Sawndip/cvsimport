head	1.16;
access;
symbols
	gdb_6_0-2003-10-04-release:1.15
	kettenis_sparc-20030918-branch:1.15.0.22
	kettenis_sparc-20030918-branchpoint:1.15
	carlton_dictionary-20030917-merge:1.15
	ezannoni_pie-20030916-branchpoint:1.15
	ezannoni_pie-20030916-branch:1.15.0.20
	cagney_x86i386-20030821-branch:1.15.0.18
	cagney_x86i386-20030821-branchpoint:1.15
	carlton_dictionary-20030805-merge:1.15
	carlton_dictionary-20030627-merge:1.15
	gdb_6_0-branch:1.15.0.16
	gdb_6_0-2003-06-23-branchpoint:1.15
	jimb-ppc64-linux-20030613-branch:1.15.0.14
	jimb-ppc64-linux-20030613-branchpoint:1.15
	cagney_convert-20030606-branch:1.15.0.12
	cagney_convert-20030606-branchpoint:1.15
	cagney_writestrings-20030508-branch:1.15.0.10
	cagney_writestrings-20030508-branchpoint:1.15
	jimb-ppc64-linux-20030528-branch:1.15.0.8
	jimb-ppc64-linux-20030528-branchpoint:1.15
	carlton_dictionary-20030523-merge:1.15
	cagney_fileio-20030521-branch:1.15.0.6
	cagney_fileio-20030521-branchpoint:1.15
	kettenis_i386newframe-20030517-mergepoint:1.15
	jimb-ppc64-linux-20030509-branch:1.15.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.15
	kettenis_i386newframe-20030504-mergepoint:1.15
	carlton_dictionary-20030430-merge:1.15
	kettenis_i386newframe-20030419-branch:1.15.0.2
	kettenis_i386newframe-20030419-branchpoint:1.15
	carlton_dictionary-20030416-merge:1.15
	cagney_frameaddr-20030409-mergepoint:1.15
	kettenis_i386newframe-20030406-branch:1.14.0.14
	kettenis_i386newframe-20030406-branchpoint:1.14
	cagney_frameaddr-20030403-branchpoint:1.14
	cagney_frameaddr-20030403-branch:1.14.0.12
	cagney_framebase-20030330-mergepoint:1.14
	cagney_framebase-20030326-branch:1.14.0.10
	cagney_framebase-20030326-branchpoint:1.14
	cagney_lazyid-20030317-branch:1.14.0.8
	cagney_lazyid-20030317-branchpoint:1.14
	kettenis-i386newframe-20030316-mergepoint:1.14
	offbyone-20030313-branch:1.14.0.6
	offbyone-20030313-branchpoint:1.14
	kettenis-i386newframe-20030308-branch:1.14.0.4
	kettenis-i386newframe-20030308-branchpoint:1.14
	carlton_dictionary-20030305-merge:1.14
	cagney_offbyone-20030303-branch:1.14.0.2
	cagney_offbyone-20030303-branchpoint:1.14
	carlton_dictionary-20030207-merge:1.14
	interps-20030203-mergepoint:1.13
	interps-20030202-branch:1.13.0.4
	interps-20030202-branchpoint:1.13
	cagney-unwind-20030108-branch:1.13.0.2
	cagney-unwind-20030108-branchpoint:1.13
	carlton_dictionary-20021223-merge:1.13
	gdb_5_3-2002-12-12-release:1.11
	carlton_dictionary-20021115-merge:1.13
	kseitz_interps-20021105-merge:1.11
	kseitz_interps-20021103-merge:1.11
	drow-cplus-merge-20021020:1.11
	drow-cplus-merge-20021025:1.11
	carlton_dictionary-20021025-merge:1.11
	carlton_dictionary-20021011-merge:1.11
	drow-cplus-branch:1.11.0.18
	drow-cplus-branchpoint:1.11
	kseitz_interps-20020930-merge:1.11
	carlton_dictionary-20020927-merge:1.11
	carlton_dictionary-branch:1.11.0.16
	carlton_dictionary-20020920-branchpoint:1.11
	gdb_5_3-branch:1.11.0.14
	gdb_5_3-2002-09-04-branchpoint:1.11
	kseitz_interps-20020829-merge:1.11
	cagney_sysregs-20020825-branch:1.11.0.12
	cagney_sysregs-20020825-branchpoint:1.11
	readline_4_3-import-branch:1.11.0.10
	readline_4_3-import-branchpoint:1.11
	gdb_5_2_1-2002-07-23-release:1.11
	kseitz_interps-20020528-branch:1.11.0.8
	kseitz_interps-20020528-branchpoint:1.11
	cagney_regbuf-20020515-branch:1.11.0.6
	cagney_regbuf-20020515-branchpoint:1.11
	jimb-macro-020506-branch:1.11.0.4
	jimb-macro-020506-branchpoint:1.11
	gdb_5_2-2002-04-29-release:1.11
	gdb_5_2-branch:1.11.0.2
	gdb_5_2-2002-03-03-branchpoint:1.11
	gdb_5_1_1-2002-01-24-release:1.10
	gdb_5_1_0_1-2002-01-03-release:1.10
	cygnus_cvs_20020108_pre:1.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.10.0.6
	gdb_5_1-2001-11-21-release:1.10
	gdb_s390-2001-09-26-branch:1.10.0.4
	gdb_s390-2001-09-26-branchpoint:1.10
	gdb_5_1-2001-07-29-branch:1.10.0.2
	gdb_5_1-2001-07-29-branchpoint:1.10
	dberlin-typesystem-branch:1.9.0.2
	dberlin-typesystem-branchpoint:1.9
	gdb-post-ptid_t-2001-05-03:1.9
	gdb-pre-ptid_t-2001-05-03:1.8
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.4
	gdb-premipsmulti-2000-06-06-branch:1.1.1.4.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.4
	gdb-post-params-removal-2000-06-04:1.1.1.4
	gdb-pre-params-removal-2000-06-04:1.1.1.4
	gdb-post-params-removal-2000-05-28:1.1.1.4
	gdb-pre-params-removal-2000-05-28:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.4
	gdb-1999-10-25:1.1.1.4
	gdb-1999-10-18:1.1.1.4
	gdb-1999-10-11:1.1.1.4
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.4
	gdb-1999-09-13:1.1.1.4
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.16
date	2003.10.06.19.10.44;	author cagney;	state dead;
branches;
next	1.15;

1.15
date	2003.04.09.16.19.51;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.07.04.49.34;	author cagney;	state Exp;
branches
	1.14.12.1;
next	1.13;

1.13
date	2002.11.14.20.37.29;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.07.15.31.31;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.08.00.59.31;	author msnyder;	state Exp;
branches
	1.11.16.1
	1.11.18.1;
next	1.10;

1.10
date	2001.07.26.02.23.57;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.04.04.15.27;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.15.16.55.15;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.06.08.21.17;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.02.03.18.49;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.27.01.25.10;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.29;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.10.29;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.08.09.21.33.56;	author jsm;	state Exp;
branches;
next	;

1.11.16.1
date	2002.11.15.19.18.59;	author carlton;	state Exp;
branches;
next	1.11.16.2;

1.11.16.2
date	2003.02.07.19.17.53;	author carlton;	state Exp;
branches;
next	1.11.16.3;

1.11.16.3
date	2003.04.16.19.56.54;	author carlton;	state Exp;
branches;
next	1.11.16.4;

1.11.16.4
date	2003.11.11.23.50.57;	author carlton;	state dead;
branches;
next	;

1.11.18.1
date	2003.12.14.20.27.32;	author drow;	state dead;
branches;
next	;

1.14.12.1
date	2003.04.10.21.33.50;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.16
log
@2003-10-06  Andrew Cagney  <cagney@@redhat.com>

	* z8k-tdep.c, symm-tdep.c, symm-nat.c: Delete obsolete file.
	* sparclet-stub.c, sparclet-rom.c: Delete obsolete file.
	* sparcl-tdep.c, sparcl-stub.c, h8500-tdep.c: Delete obsolete file.
	* m3-nat.c, mipsm3-nat.c, mn10200-tdep.c: Delete obsolete file.
@
text
@// OBSOLETE /* Sequent Symmetry host interface, for GDB when running under Unix.
// OBSOLETE 
// OBSOLETE    Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1999,
// OBSOLETE    2000, 2001, 2003 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /* FIXME, some 387-specific items of use taken from i387-tdep.c -- ought to be
// OBSOLETE    merged back in. */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE /* FIXME: What is the _INKERNEL define for?  */
// OBSOLETE #define _INKERNEL
// OBSOLETE #include <signal.h>
// OBSOLETE #undef _INKERNEL
// OBSOLETE #include "gdb_wait.h"
// OBSOLETE #include <sys/param.h>
// OBSOLETE #include <sys/user.h>
// OBSOLETE #include <sys/proc.h>
// OBSOLETE #include <sys/dir.h>
// OBSOLETE #include <sys/ioctl.h>
// OBSOLETE #include "gdb_stat.h"
// OBSOLETE #ifdef _SEQUENT_
// OBSOLETE #include <sys/ptrace.h>
// OBSOLETE #else
// OBSOLETE /* Dynix has only machine/ptrace.h, which is already included by sys/user.h  */
// OBSOLETE /* Dynix has no mptrace call */
// OBSOLETE #define mptrace ptrace
// OBSOLETE #endif
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include <fcntl.h>
// OBSOLETE #include <sgtty.h>
// OBSOLETE #define TERMINAL struct sgttyb
// OBSOLETE 
// OBSOLETE #include "gdbcore.h"
// OBSOLETE 
// OBSOLETE void
// OBSOLETE store_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   struct pt_regset regs;
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   /* FIXME: Fetching the registers is a kludge to initialize all elements
// OBSOLETE      in the fpu and fpa status. This works for normal debugging, but
// OBSOLETE      might cause problems when calling functions in the inferior.
// OBSOLETE      At least fpu_control and fpa_pcr (probably more) should be added 
// OBSOLETE      to the registers array to solve this properly.  */
// OBSOLETE   mptrace (XPT_RREGS, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regs, 0);
// OBSOLETE 
// OBSOLETE   regs.pr_eax = *(int *) &deprecated_registers[REGISTER_BYTE (0)];
// OBSOLETE   regs.pr_ebx = *(int *) &deprecated_registers[REGISTER_BYTE (5)];
// OBSOLETE   regs.pr_ecx = *(int *) &deprecated_registers[REGISTER_BYTE (2)];
// OBSOLETE   regs.pr_edx = *(int *) &deprecated_registers[REGISTER_BYTE (1)];
// OBSOLETE   regs.pr_esi = *(int *) &deprecated_registers[REGISTER_BYTE (6)];
// OBSOLETE   regs.pr_edi = *(int *) &deprecated_registers[REGISTER_BYTE (7)];
// OBSOLETE   regs.pr_esp = *(int *) &deprecated_registers[REGISTER_BYTE (14)];
// OBSOLETE   regs.pr_ebp = *(int *) &deprecated_registers[REGISTER_BYTE (15)];
// OBSOLETE   regs.pr_eip = *(int *) &deprecated_registers[REGISTER_BYTE (16)];
// OBSOLETE   regs.pr_flags = *(int *) &deprecated_registers[REGISTER_BYTE (17)];
// OBSOLETE   for (i = 0; i < 31; i++)
// OBSOLETE     {
// OBSOLETE       regs.pr_fpa.fpa_regs[i] =
// OBSOLETE 	*(int *) &deprecated_registers[REGISTER_BYTE (FP1_REGNUM + i)];
// OBSOLETE     }
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[0], &deprecated_registers[REGISTER_BYTE (ST0_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[1], &deprecated_registers[REGISTER_BYTE (ST1_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[2], &deprecated_registers[REGISTER_BYTE (ST2_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[3], &deprecated_registers[REGISTER_BYTE (ST3_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[4], &deprecated_registers[REGISTER_BYTE (ST4_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[5], &deprecated_registers[REGISTER_BYTE (ST5_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[6], &deprecated_registers[REGISTER_BYTE (ST6_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[7], &deprecated_registers[REGISTER_BYTE (ST7_REGNUM)], 10);
// OBSOLETE   mptrace (XPT_WREGS, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regs, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fetch_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   struct pt_regset regs;
// OBSOLETE 
// OBSOLETE   deprecated_registers_fetched ();
// OBSOLETE 
// OBSOLETE   mptrace (XPT_RREGS, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regs, 0);
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EAX_REGNUM)] = regs.pr_eax;
// OBSOLETE   *(int *) &rdeprecated_egisters[REGISTER_BYTE (EBX_REGNUM)] = regs.pr_ebx;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (ECX_REGNUM)] = regs.pr_ecx;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EDX_REGNUM)] = regs.pr_edx;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (ESI_REGNUM)] = regs.pr_esi;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EDI_REGNUM)] = regs.pr_edi;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EBP_REGNUM)] = regs.pr_ebp;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (ESP_REGNUM)] = regs.pr_esp;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EIP_REGNUM)] = regs.pr_eip;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EFLAGS_REGNUM)] = regs.pr_flags;
// OBSOLETE   for (i = 0; i < FPA_NREGS; i++)
// OBSOLETE     {
// OBSOLETE       *(int *) &deprecated_registers[REGISTER_BYTE (FP1_REGNUM + i)] =
// OBSOLETE 	regs.pr_fpa.fpa_regs[i];
// OBSOLETE     }
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST0_REGNUM)], regs.pr_fpu.fpu_stack[0], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST1_REGNUM)], regs.pr_fpu.fpu_stack[1], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST2_REGNUM)], regs.pr_fpu.fpu_stack[2], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST3_REGNUM)], regs.pr_fpu.fpu_stack[3], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST4_REGNUM)], regs.pr_fpu.fpu_stack[4], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST5_REGNUM)], regs.pr_fpu.fpu_stack[5], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST6_REGNUM)], regs.pr_fpu.fpu_stack[6], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST7_REGNUM)], regs.pr_fpu.fpu_stack[7], 10);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* FIXME:  This should be merged with i387-tdep.c as well. */
// OBSOLETE static
// OBSOLETE print_fpu_status (struct pt_regset ep)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   int bothstatus;
// OBSOLETE   int top;
// OBSOLETE   int fpreg;
// OBSOLETE   unsigned char *p;
// OBSOLETE 
// OBSOLETE   printf_unfiltered ("80387:");
// OBSOLETE   if (ep.pr_fpu.fpu_ip == 0)
// OBSOLETE     {
// OBSOLETE       printf_unfiltered (" not in use.\n");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("\n");
// OBSOLETE     }
// OBSOLETE   if (ep.pr_fpu.fpu_status != 0)
// OBSOLETE     {
// OBSOLETE       print_387_status_word (ep.pr_fpu.fpu_status);
// OBSOLETE     }
// OBSOLETE   print_387_control_word (ep.pr_fpu.fpu_control);
// OBSOLETE   printf_unfiltered ("last exception: ");
// OBSOLETE   printf_unfiltered ("opcode 0x%x; ", ep.pr_fpu.fpu_rsvd4);
// OBSOLETE   printf_unfiltered ("pc 0x%x:0x%x; ", ep.pr_fpu.fpu_cs, ep.pr_fpu.fpu_ip);
// OBSOLETE   printf_unfiltered ("operand 0x%x:0x%x\n", ep.pr_fpu.fpu_data_offset, ep.pr_fpu.fpu_op_sel);
// OBSOLETE 
// OBSOLETE   top = (ep.pr_fpu.fpu_status >> 11) & 7;
// OBSOLETE 
// OBSOLETE   printf_unfiltered ("regno  tag  msb              lsb  value\n");
// OBSOLETE   for (fpreg = 7; fpreg >= 0; fpreg--)
// OBSOLETE     {
// OBSOLETE       double val;
// OBSOLETE 
// OBSOLETE       printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg);
// OBSOLETE 
// OBSOLETE       switch ((ep.pr_fpu.fpu_tag >> (fpreg * 2)) & 3)
// OBSOLETE 	{
// OBSOLETE 	case 0:
// OBSOLETE 	  printf_unfiltered ("valid ");
// OBSOLETE 	  break;
// OBSOLETE 	case 1:
// OBSOLETE 	  printf_unfiltered ("zero  ");
// OBSOLETE 	  break;
// OBSOLETE 	case 2:
// OBSOLETE 	  printf_unfiltered ("trap  ");
// OBSOLETE 	  break;
// OBSOLETE 	case 3:
// OBSOLETE 	  printf_unfiltered ("empty ");
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       for (i = 9; i >= 0; i--)
// OBSOLETE 	printf_unfiltered ("%02x", ep.pr_fpu.fpu_stack[fpreg][i]);
// OBSOLETE 
// OBSOLETE       i387_to_double ((char *) ep.pr_fpu.fpu_stack[fpreg], (char *) &val);
// OBSOLETE       printf_unfiltered ("  %g\n", val);
// OBSOLETE     }
// OBSOLETE   if (ep.pr_fpu.fpu_rsvd1)
// OBSOLETE     warning ("rsvd1 is 0x%x\n", ep.pr_fpu.fpu_rsvd1);
// OBSOLETE   if (ep.pr_fpu.fpu_rsvd2)
// OBSOLETE     warning ("rsvd2 is 0x%x\n", ep.pr_fpu.fpu_rsvd2);
// OBSOLETE   if (ep.pr_fpu.fpu_rsvd3)
// OBSOLETE     warning ("rsvd3 is 0x%x\n", ep.pr_fpu.fpu_rsvd3);
// OBSOLETE   if (ep.pr_fpu.fpu_rsvd5)
// OBSOLETE     warning ("rsvd5 is 0x%x\n", ep.pr_fpu.fpu_rsvd5);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE print_1167_control_word (unsigned int pcr)
// OBSOLETE {
// OBSOLETE   int pcr_tmp;
// OBSOLETE 
// OBSOLETE   pcr_tmp = pcr & FPA_PCR_MODE;
// OBSOLETE   printf_unfiltered ("\tMODE= %#x; RND= %#x ", pcr_tmp, pcr_tmp & 12);
// OBSOLETE   switch (pcr_tmp & 12)
// OBSOLETE     {
// OBSOLETE     case 0:
// OBSOLETE       printf_unfiltered ("RN (Nearest Value)");
// OBSOLETE       break;
// OBSOLETE     case 1:
// OBSOLETE       printf_unfiltered ("RZ (Zero)");
// OBSOLETE       break;
// OBSOLETE     case 2:
// OBSOLETE       printf_unfiltered ("RP (Positive Infinity)");
// OBSOLETE       break;
// OBSOLETE     case 3:
// OBSOLETE       printf_unfiltered ("RM (Negative Infinity)");
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE   printf_unfiltered ("; IRND= %d ", pcr_tmp & 2);
// OBSOLETE   if (0 == pcr_tmp & 2)
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("(same as RND)\n");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("(toward zero)\n");
// OBSOLETE     }
// OBSOLETE   pcr_tmp = pcr & FPA_PCR_EM;
// OBSOLETE   printf_unfiltered ("\tEM= %#x", pcr_tmp);
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_DM)
// OBSOLETE     printf_unfiltered (" DM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_UOM)
// OBSOLETE     printf_unfiltered (" UOM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_PM)
// OBSOLETE     printf_unfiltered (" PM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_UM)
// OBSOLETE     printf_unfiltered (" UM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_OM)
// OBSOLETE     printf_unfiltered (" OM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_ZM)
// OBSOLETE     printf_unfiltered (" ZM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_IM)
// OBSOLETE     printf_unfiltered (" IM");
// OBSOLETE   printf_unfiltered ("\n");
// OBSOLETE   pcr_tmp = FPA_PCR_CC;
// OBSOLETE   printf_unfiltered ("\tCC= %#x", pcr_tmp);
// OBSOLETE   if (pcr_tmp & FPA_PCR_20MHZ)
// OBSOLETE     printf_unfiltered (" 20MHZ");
// OBSOLETE   if (pcr_tmp & FPA_PCR_CC_Z)
// OBSOLETE     printf_unfiltered (" Z");
// OBSOLETE   if (pcr_tmp & FPA_PCR_CC_C2)
// OBSOLETE     printf_unfiltered (" C2");
// OBSOLETE 
// OBSOLETE   /* Dynix defines FPA_PCR_CC_C0 to 0x100 and ptx defines
// OBSOLETE      FPA_PCR_CC_C1 to 0x100.  Use whichever is defined and assume
// OBSOLETE      the OS knows what it is doing.  */
// OBSOLETE #ifdef FPA_PCR_CC_C1
// OBSOLETE   if (pcr_tmp & FPA_PCR_CC_C1)
// OBSOLETE     printf_unfiltered (" C1");
// OBSOLETE #else
// OBSOLETE   if (pcr_tmp & FPA_PCR_CC_C0)
// OBSOLETE     printf_unfiltered (" C0");
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   switch (pcr_tmp)
// OBSOLETE     {
// OBSOLETE     case FPA_PCR_CC_Z:
// OBSOLETE       printf_unfiltered (" (Equal)");
// OBSOLETE       break;
// OBSOLETE #ifdef FPA_PCR_CC_C1
// OBSOLETE     case FPA_PCR_CC_C1:
// OBSOLETE #else
// OBSOLETE     case FPA_PCR_CC_C0:
// OBSOLETE #endif
// OBSOLETE       printf_unfiltered (" (Less than)");
// OBSOLETE       break;
// OBSOLETE     case 0:
// OBSOLETE       printf_unfiltered (" (Greater than)");
// OBSOLETE       break;
// OBSOLETE       case FPA_PCR_CC_Z |
// OBSOLETE #ifdef FPA_PCR_CC_C1
// OBSOLETE 	FPA_PCR_CC_C1
// OBSOLETE #else
// OBSOLETE 	FPA_PCR_CC_C0
// OBSOLETE #endif
// OBSOLETE     | FPA_PCR_CC_C2:
// OBSOLETE       printf_unfiltered (" (Unordered)");
// OBSOLETE       break;
// OBSOLETE     default:
// OBSOLETE       printf_unfiltered (" (Undefined)");
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE   printf_unfiltered ("\n");
// OBSOLETE   pcr_tmp = pcr & FPA_PCR_AE;
// OBSOLETE   printf_unfiltered ("\tAE= %#x", pcr_tmp);
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_DE)
// OBSOLETE     printf_unfiltered (" DE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_UOE)
// OBSOLETE     printf_unfiltered (" UOE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_PE)
// OBSOLETE     printf_unfiltered (" PE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_UE)
// OBSOLETE     printf_unfiltered (" UE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_OE)
// OBSOLETE     printf_unfiltered (" OE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_ZE)
// OBSOLETE     printf_unfiltered (" ZE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_EE)
// OBSOLETE     printf_unfiltered (" EE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_IE)
// OBSOLETE     printf_unfiltered (" IE");
// OBSOLETE   printf_unfiltered ("\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE print_1167_regs (long regs[FPA_NREGS])
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   union
// OBSOLETE     {
// OBSOLETE       double d;
// OBSOLETE       long l[2];
// OBSOLETE     }
// OBSOLETE   xd;
// OBSOLETE   union
// OBSOLETE     {
// OBSOLETE       float f;
// OBSOLETE       long l;
// OBSOLETE     }
// OBSOLETE   xf;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   for (i = 0; i < FPA_NREGS; i++)
// OBSOLETE     {
// OBSOLETE       xf.l = regs[i];
// OBSOLETE       printf_unfiltered ("%%fp%d: raw= %#x, single= %f", i + 1, regs[i], xf.f);
// OBSOLETE       if (!(i & 1))
// OBSOLETE 	{
// OBSOLETE 	  printf_unfiltered ("\n");
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  xd.l[1] = regs[i];
// OBSOLETE 	  xd.l[0] = regs[i + 1];
// OBSOLETE 	  printf_unfiltered (", double= %f\n", xd.d);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE print_fpa_status (struct pt_regset ep)
// OBSOLETE {
// OBSOLETE 
// OBSOLETE   printf_unfiltered ("WTL 1167:");
// OBSOLETE   if (ep.pr_fpa.fpa_pcr != 0)
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("\n");
// OBSOLETE       print_1167_control_word (ep.pr_fpa.fpa_pcr);
// OBSOLETE       print_1167_regs (ep.pr_fpa.fpa_regs);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       printf_unfiltered (" not in use.\n");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0				/* disabled because it doesn't go through the target vector.  */
// OBSOLETE i386_float_info (void)
// OBSOLETE {
// OBSOLETE   char ubuf[UPAGES * NBPG];
// OBSOLETE   struct pt_regset regset;
// OBSOLETE 
// OBSOLETE   if (have_inferior_p ())
// OBSOLETE     {
// OBSOLETE       PTRACE_READ_REGS (PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regset);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       int corechan = bfd_cache_lookup (core_bfd);
// OBSOLETE       if (lseek (corechan, 0, 0) < 0)
// OBSOLETE 	{
// OBSOLETE 	  perror ("seek on core file");
// OBSOLETE 	}
// OBSOLETE       if (myread (corechan, ubuf, UPAGES * NBPG) < 0)
// OBSOLETE 	{
// OBSOLETE 	  perror ("read on core file");
// OBSOLETE 	}
// OBSOLETE       /* only interested in the floating point registers */
// OBSOLETE       regset.pr_fpu = ((struct user *) ubuf)->u_fpusave;
// OBSOLETE       regset.pr_fpa = ((struct user *) ubuf)->u_fpasave;
// OBSOLETE     }
// OBSOLETE   print_fpu_status (regset);
// OBSOLETE   print_fpa_status (regset);
// OBSOLETE }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE static volatile int got_sigchld;
// OBSOLETE 
// OBSOLETE /*ARGSUSED */
// OBSOLETE /* This will eventually be more interesting. */
// OBSOLETE void
// OBSOLETE sigchld_handler (int signo)
// OBSOLETE {
// OBSOLETE   got_sigchld++;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Signals for which the default action does not cause the process
// OBSOLETE  * to die.  See <sys/signal.h> for where this came from (alas, we
// OBSOLETE  * can't use those macros directly)
// OBSOLETE  */
// OBSOLETE #ifndef sigmask
// OBSOLETE #define sigmask(s) (1 << ((s) - 1))
// OBSOLETE #endif
// OBSOLETE #define SIGNALS_DFL_SAFE sigmask(SIGSTOP) | sigmask(SIGTSTP) | \
// OBSOLETE 	sigmask(SIGTTIN) | sigmask(SIGTTOU) | sigmask(SIGCHLD) | \
// OBSOLETE 	sigmask(SIGCONT) | sigmask(SIGWINCH) | sigmask(SIGPWR) | \
// OBSOLETE 	sigmask(SIGURG) | sigmask(SIGPOLL)
// OBSOLETE 
// OBSOLETE #ifdef ATTACH_DETACH
// OBSOLETE /*
// OBSOLETE  * Thanks to XPT_MPDEBUGGER, we have to mange child_wait().
// OBSOLETE  */
// OBSOLETE ptid_t
// OBSOLETE child_wait (ptid_t ptid, struct target_waitstatus *status)
// OBSOLETE {
// OBSOLETE   int save_errno, rv, xvaloff, saoff, sa_hand;
// OBSOLETE   struct pt_stop pt;
// OBSOLETE   struct user u;
// OBSOLETE   sigset_t set;
// OBSOLETE   /* Host signal number for a signal which the inferior terminates with, or
// OBSOLETE      0 if it hasn't terminated due to a signal.  */
// OBSOLETE   static int death_by_signal = 0;
// OBSOLETE #ifdef SVR4_SHARED_LIBS		/* use this to distinguish ptx 2 vs ptx 4 */
// OBSOLETE   prstatus_t pstatus;
// OBSOLETE #endif
// OBSOLETE   int pid = PIDGET (ptid);
// OBSOLETE 
// OBSOLETE   do
// OBSOLETE     {
// OBSOLETE       set_sigint_trap ();	/* Causes SIGINT to be passed on to the
// OBSOLETE 				   attached process. */
// OBSOLETE       save_errno = errno;
// OBSOLETE 
// OBSOLETE       got_sigchld = 0;
// OBSOLETE 
// OBSOLETE       sigemptyset (&set);
// OBSOLETE 
// OBSOLETE       while (got_sigchld == 0)
// OBSOLETE 	{
// OBSOLETE 	  sigsuspend (&set);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       clear_sigint_trap ();
// OBSOLETE 
// OBSOLETE       rv = mptrace (XPT_STOPSTAT, 0, (char *) &pt, 0);
// OBSOLETE       if (-1 == rv)
// OBSOLETE 	{
// OBSOLETE 	  printf ("XPT_STOPSTAT: errno %d\n", errno);	/* DEBUG */
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       pid = pt.ps_pid;
// OBSOLETE 
// OBSOLETE       if (pid != PIDGET (inferior_ptid))
// OBSOLETE 	{
// OBSOLETE 	  /* NOTE: the mystery fork in csh/tcsh needs to be ignored.
// OBSOLETE 	   * We should not return new children for the initial run
// OBSOLETE 	   * of a process until it has done the exec.
// OBSOLETE 	   */
// OBSOLETE 	  /* inferior probably forked; send it on its way */
// OBSOLETE 	  rv = mptrace (XPT_UNDEBUG, pid, 0, 0);
// OBSOLETE 	  if (-1 == rv)
// OBSOLETE 	    {
// OBSOLETE 	      printf ("child_wait: XPT_UNDEBUG: pid %d: %s\n", pid,
// OBSOLETE 		      safe_strerror (errno));
// OBSOLETE 	    }
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE       /* FIXME: Do we deal with fork notification correctly?  */
// OBSOLETE       switch (pt.ps_reason)
// OBSOLETE 	{
// OBSOLETE 	case PTS_FORK:
// OBSOLETE 	  /* multi proc: treat like PTS_EXEC */
// OBSOLETE 	  /*
// OBSOLETE 	   * Pretend this didn't happen, since gdb isn't set up
// OBSOLETE 	   * to deal with stops on fork.
// OBSOLETE 	   */
// OBSOLETE 	  rv = ptrace (PT_CONTSIG, pid, 1, 0);
// OBSOLETE 	  if (-1 == rv)
// OBSOLETE 	    {
// OBSOLETE 	      printf ("PTS_FORK: PT_CONTSIG: error %d\n", errno);
// OBSOLETE 	    }
// OBSOLETE 	  continue;
// OBSOLETE 	case PTS_EXEC:
// OBSOLETE 	  /*
// OBSOLETE 	   * Pretend this is a SIGTRAP.
// OBSOLETE 	   */
// OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE 	  status->value.sig = TARGET_SIGNAL_TRAP;
// OBSOLETE 	  break;
// OBSOLETE 	case PTS_EXIT:
// OBSOLETE 	  /*
// OBSOLETE 	   * Note: we stop before the exit actually occurs.  Extract
// OBSOLETE 	   * the exit code from the uarea.  If we're stopped in the
// OBSOLETE 	   * exit() system call, the exit code will be in
// OBSOLETE 	   * u.u_ap[0].  An exit due to an uncaught signal will have
// OBSOLETE 	   * something else in here, see the comment in the default:
// OBSOLETE 	   * case, below.  Finally,let the process exit.
// OBSOLETE 	   */
// OBSOLETE 	  if (death_by_signal)
// OBSOLETE 	    {
// OBSOLETE 	      status->kind = TARGET_WAITKIND_SIGNALED;
// OBSOLETE 	      status->value.sig = target_signal_from_host (death_by_signal);
// OBSOLETE 	      death_by_signal = 0;
// OBSOLETE 	      break;
// OBSOLETE 	    }
// OBSOLETE 	  xvaloff = (unsigned long) &u.u_ap[0] - (unsigned long) &u;
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  rv = ptrace (PT_RUSER, pid, (char *) xvaloff, 0);
// OBSOLETE 	  status->kind = TARGET_WAITKIND_EXITED;
// OBSOLETE 	  status->value.integer = rv;
// OBSOLETE 	  /*
// OBSOLETE 	   * addr & data to mptrace() don't matter here, since
// OBSOLETE 	   * the process is already dead.
// OBSOLETE 	   */
// OBSOLETE 	  rv = mptrace (XPT_UNDEBUG, pid, 0, 0);
// OBSOLETE 	  if (-1 == rv)
// OBSOLETE 	    {
// OBSOLETE 	      printf ("child_wait: PTS_EXIT: XPT_UNDEBUG: pid %d error %d\n", pid,
// OBSOLETE 		      errno);
// OBSOLETE 	    }
// OBSOLETE 	  break;
// OBSOLETE 	case PTS_WATCHPT_HIT:
// OBSOLETE 	  internal_error (__FILE__, __LINE__,
// OBSOLETE 			  "PTS_WATCHPT_HIT\n");
// OBSOLETE 	  break;
// OBSOLETE 	default:
// OBSOLETE 	  /* stopped by signal */
// OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE 	  status->value.sig = target_signal_from_host (pt.ps_reason);
// OBSOLETE 	  death_by_signal = 0;
// OBSOLETE 
// OBSOLETE 	  if (0 == (SIGNALS_DFL_SAFE & sigmask (pt.ps_reason)))
// OBSOLETE 	    {
// OBSOLETE 	      break;
// OBSOLETE 	    }
// OBSOLETE 	  /* else default action of signal is to die */
// OBSOLETE #ifdef SVR4_SHARED_LIBS
// OBSOLETE 	  rv = ptrace (PT_GET_PRSTATUS, pid, (char *) &pstatus, 0);
// OBSOLETE 	  if (-1 == rv)
// OBSOLETE 	    error ("child_wait: signal %d PT_GET_PRSTATUS: %s\n",
// OBSOLETE 		   pt.ps_reason, safe_strerror (errno));
// OBSOLETE 	  if (pstatus.pr_cursig != pt.ps_reason)
// OBSOLETE 	    {
// OBSOLETE 	      printf ("pstatus signal %d, pt signal %d\n",
// OBSOLETE 		      pstatus.pr_cursig, pt.ps_reason);
// OBSOLETE 	    }
// OBSOLETE 	  sa_hand = (int) pstatus.pr_action.sa_handler;
// OBSOLETE #else
// OBSOLETE 	  saoff = (unsigned long) &u.u_sa[0] - (unsigned long) &u;
// OBSOLETE 	  saoff += sizeof (struct sigaction) * (pt.ps_reason - 1);
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  sa_hand = ptrace (PT_RUSER, pid, (char *) saoff, 0);
// OBSOLETE 	  if (errno)
// OBSOLETE 	    error ("child_wait: signal %d: RUSER: %s\n",
// OBSOLETE 		   pt.ps_reason, safe_strerror (errno));
// OBSOLETE #endif
// OBSOLETE 	  if ((int) SIG_DFL == sa_hand)
// OBSOLETE 	    {
// OBSOLETE 	      /* we will be dying */
// OBSOLETE 	      death_by_signal = pt.ps_reason;
// OBSOLETE 	    }
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE     }
// OBSOLETE   while (pid != PIDGET (inferior_ptid));	/* Some other child died or stopped */
// OBSOLETE 
// OBSOLETE   return pid_to_ptid (pid);
// OBSOLETE }
// OBSOLETE #else /* !ATTACH_DETACH */
// OBSOLETE /*
// OBSOLETE  * Simple child_wait() based on inftarg.c child_wait() for use until
// OBSOLETE  * the MPDEBUGGER child_wait() works properly.  This will go away when
// OBSOLETE  * that is fixed.
// OBSOLETE  */
// OBSOLETE ptid_t
// OBSOLETE child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
// OBSOLETE {
// OBSOLETE   int save_errno;
// OBSOLETE   int status;
// OBSOLETE   int pid = PIDGET (ptid);
// OBSOLETE 
// OBSOLETE   do
// OBSOLETE     {
// OBSOLETE       pid = wait (&status);
// OBSOLETE       save_errno = errno;
// OBSOLETE 
// OBSOLETE       if (pid == -1)
// OBSOLETE 	{
// OBSOLETE 	  if (save_errno == EINTR)
// OBSOLETE 	    continue;
// OBSOLETE 	  fprintf (stderr, "Child process unexpectedly missing: %s.\n",
// OBSOLETE 		   safe_strerror (save_errno));
// OBSOLETE 	  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
// OBSOLETE 	  ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
// OBSOLETE 	  return pid_to_ptid (-1);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   while (pid != PIDGET (inferior_ptid));	/* Some other child died or stopped */
// OBSOLETE   store_waitstatus (ourstatus, status);
// OBSOLETE   return pid_to_ptid (pid);
// OBSOLETE }
// OBSOLETE #endif /* ATTACH_DETACH */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* This function simply calls ptrace with the given arguments.  
// OBSOLETE    It exists so that all calls to ptrace are isolated in this 
// OBSOLETE    machine-dependent file. */
// OBSOLETE int
// OBSOLETE call_ptrace (int request, int pid, PTRACE_ARG3_TYPE addr, int data)
// OBSOLETE {
// OBSOLETE   return ptrace (request, pid, addr, data);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE call_mptrace (int request, int pid, PTRACE_ARG3_TYPE addr, int data)
// OBSOLETE {
// OBSOLETE   return mptrace (request, pid, addr, data);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if defined (DEBUG_PTRACE)
// OBSOLETE /* For the rest of the file, use an extra level of indirection */
// OBSOLETE /* This lets us breakpoint usefully on call_ptrace. */
// OBSOLETE #define ptrace call_ptrace
// OBSOLETE #define mptrace call_mptrace
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE void
// OBSOLETE kill_inferior (void)
// OBSOLETE {
// OBSOLETE   if (ptid_equal (inferior_ptid, null_ptid))
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   /* For MPDEBUGGER, don't use PT_KILL, since the child will stop
// OBSOLETE      again with a PTS_EXIT.  Just hit him with SIGKILL (so he stops)
// OBSOLETE      and detach. */
// OBSOLETE 
// OBSOLETE   kill (PIDGET (inferior_ptid), SIGKILL);
// OBSOLETE #ifdef ATTACH_DETACH
// OBSOLETE   detach (SIGKILL);
// OBSOLETE #else /* ATTACH_DETACH */
// OBSOLETE   ptrace (PT_KILL, PIDGET (inferior_ptid), 0, 0);
// OBSOLETE   wait ((int *) NULL);
// OBSOLETE #endif /* ATTACH_DETACH */
// OBSOLETE   target_mourn_inferior ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Resume execution of the inferior process.
// OBSOLETE    If STEP is nonzero, single-step it.
// OBSOLETE    If SIGNAL is nonzero, give it that signal.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE child_resume (ptid_t ptid, int step, enum target_signal signal)
// OBSOLETE {
// OBSOLETE   int pid = PIDGET (ptid);
// OBSOLETE 
// OBSOLETE   errno = 0;
// OBSOLETE 
// OBSOLETE   if (pid == -1)
// OBSOLETE     pid = PIDGET (inferior_ptid);
// OBSOLETE 
// OBSOLETE   /* An address of (PTRACE_ARG3_TYPE)1 tells ptrace to continue from where
// OBSOLETE      it was.  (If GDB wanted it to start some other way, we have already
// OBSOLETE      written a new PC value to the child.)
// OBSOLETE 
// OBSOLETE      If this system does not support PT_SSTEP, a higher level function will
// OBSOLETE      have called single_step() to transmute the step request into a
// OBSOLETE      continue request (by setting breakpoints on all possible successor
// OBSOLETE      instructions), so we don't have to worry about that here.  */
// OBSOLETE 
// OBSOLETE   if (step)
// OBSOLETE     ptrace (PT_SSTEP, pid, (PTRACE_ARG3_TYPE) 1, signal);
// OBSOLETE   else
// OBSOLETE     ptrace (PT_CONTSIG, pid, (PTRACE_ARG3_TYPE) 1, signal);
// OBSOLETE 
// OBSOLETE   if (errno)
// OBSOLETE     perror_with_name ("ptrace");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef ATTACH_DETACH
// OBSOLETE /* Start debugging the process whose number is PID.  */
// OBSOLETE int
// OBSOLETE attach (int pid)
// OBSOLETE {
// OBSOLETE   sigset_t set;
// OBSOLETE   int rv;
// OBSOLETE 
// OBSOLETE   rv = mptrace (XPT_DEBUG, pid, 0, 0);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       error ("mptrace(XPT_DEBUG): %s", safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE   rv = mptrace (XPT_SIGNAL, pid, 0, SIGSTOP);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       error ("mptrace(XPT_SIGNAL): %s", safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE   attach_flag = 1;
// OBSOLETE   return pid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE detach (int signo)
// OBSOLETE {
// OBSOLETE   int rv;
// OBSOLETE 
// OBSOLETE   rv = mptrace (XPT_UNDEBUG, PIDGET (inferior_ptid), 1, signo);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       error ("mptrace(XPT_UNDEBUG): %s", safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE   attach_flag = 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* ATTACH_DETACH */
// OBSOLETE 
// OBSOLETE /* Default the type of the ptrace transfer to int.  */
// OBSOLETE #ifndef PTRACE_XFER_TYPE
// OBSOLETE #define PTRACE_XFER_TYPE int
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory
// OBSOLETE    in the NEW_SUN_PTRACE case.
// OBSOLETE    It ought to be straightforward.  But it appears that writing did
// OBSOLETE    not write the data that I specified.  I cannot understand where
// OBSOLETE    it got the data that it actually did write.  */
// OBSOLETE 
// OBSOLETE /* Copy LEN bytes to or from inferior's memory starting at MEMADDR
// OBSOLETE    to debugger memory starting at MYADDR.   Copy to inferior if
// OBSOLETE    WRITE is nonzero.  TARGET is ignored.
// OBSOLETE 
// OBSOLETE    Returns the length copied, which is either the LEN argument or zero.
// OBSOLETE    This xfer function does not do partial moves, since child_ops
// OBSOLETE    doesn't allow memory operations to cross below us in the target stack
// OBSOLETE    anyway.  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE child_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
// OBSOLETE 		   struct mem_attrib *attrib,
// OBSOLETE 		   struct target_ops *target)
// OBSOLETE {
// OBSOLETE   register int i;
// OBSOLETE   /* Round starting address down to longword boundary.  */
// OBSOLETE   register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_XFER_TYPE);
// OBSOLETE   /* Round ending address up; get number of longwords that makes.  */
// OBSOLETE   register int count
// OBSOLETE   = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
// OBSOLETE   / sizeof (PTRACE_XFER_TYPE);
// OBSOLETE   /* Allocate buffer of that many longwords.  */
// OBSOLETE   /* FIXME (alloca): This code, cloned from infptrace.c, is unsafe
// OBSOLETE      because it uses alloca to allocate a buffer of arbitrary size.
// OBSOLETE      For very large xfers, this could crash GDB's stack.  */
// OBSOLETE   register PTRACE_XFER_TYPE *buffer
// OBSOLETE     = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
// OBSOLETE 
// OBSOLETE   if (write)
// OBSOLETE     {
// OBSOLETE       /* Fill start and end extra bytes of buffer with existing memory data.  */
// OBSOLETE 
// OBSOLETE       if (addr != memaddr || len < (int) sizeof (PTRACE_XFER_TYPE))
// OBSOLETE 	{
// OBSOLETE 	  /* Need part of initial word -- fetch it.  */
// OBSOLETE 	  buffer[0] = ptrace (PT_RTEXT, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) addr,
// OBSOLETE 			      0);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (count > 1)		/* FIXME, avoid if even boundary */
// OBSOLETE 	{
// OBSOLETE 	  buffer[count - 1]
// OBSOLETE 	    = ptrace (PT_RTEXT, PIDGET (inferior_ptid),
// OBSOLETE 		      ((PTRACE_ARG3_TYPE)
// OBSOLETE 		       (addr + (count - 1) * sizeof (PTRACE_XFER_TYPE))),
// OBSOLETE 		      0);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Copy data to be written over corresponding part of buffer */
// OBSOLETE 
// OBSOLETE       memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
// OBSOLETE 	      myaddr,
// OBSOLETE 	      len);
// OBSOLETE 
// OBSOLETE       /* Write the entire buffer.  */
// OBSOLETE 
// OBSOLETE       for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
// OBSOLETE 	{
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  ptrace (PT_WDATA, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) addr,
// OBSOLETE 		  buffer[i]);
// OBSOLETE 	  if (errno)
// OBSOLETE 	    {
// OBSOLETE 	      /* Using the appropriate one (I or D) is necessary for
// OBSOLETE 	         Gould NP1, at least.  */
// OBSOLETE 	      errno = 0;
// OBSOLETE 	      ptrace (PT_WTEXT, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) addr,
// OBSOLETE 		      buffer[i]);
// OBSOLETE 	    }
// OBSOLETE 	  if (errno)
// OBSOLETE 	    return 0;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* Read all the longwords */
// OBSOLETE       for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
// OBSOLETE 	{
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  buffer[i] = ptrace (PT_RTEXT, PIDGET (inferior_ptid),
// OBSOLETE 			      (PTRACE_ARG3_TYPE) addr, 0);
// OBSOLETE 	  if (errno)
// OBSOLETE 	    return 0;
// OBSOLETE 	  QUIT;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Copy appropriate bytes out of the buffer.  */
// OBSOLETE       memcpy (myaddr,
// OBSOLETE 	      (char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
// OBSOLETE 	      len);
// OBSOLETE     }
// OBSOLETE   return len;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_symm_nat (void)
// OBSOLETE {
// OBSOLETE #ifdef ATTACH_DETACH
// OBSOLETE /*
// OBSOLETE  * the MPDEBUGGER is necessary for process tree debugging and attach
// OBSOLETE  * to work, but it alters the behavior of debugged processes, so other
// OBSOLETE  * things (at least child_wait()) will have to change to accomodate
// OBSOLETE  * that.
// OBSOLETE  *
// OBSOLETE  * Note that attach is not implemented in dynix 3, and not in ptx
// OBSOLETE  * until version 2.1 of the OS.
// OBSOLETE  */
// OBSOLETE   int rv;
// OBSOLETE   sigset_t set;
// OBSOLETE   struct sigaction sact;
// OBSOLETE 
// OBSOLETE   rv = mptrace (XPT_MPDEBUGGER, 0, 0, 0);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       internal_error (__FILE__, __LINE__,
// OBSOLETE 		      "_initialize_symm_nat(): mptrace(XPT_MPDEBUGGER): %s",
// OBSOLETE 		      safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /*
// OBSOLETE    * Under MPDEBUGGER, we get SIGCLHD when a traced process does
// OBSOLETE    * anything of interest.
// OBSOLETE    */
// OBSOLETE 
// OBSOLETE   /*
// OBSOLETE    * Block SIGCHLD.  We leave it blocked all the time, and then
// OBSOLETE    * call sigsuspend() in child_wait() to wait for the child
// OBSOLETE    * to do something.  None of these ought to fail, but check anyway.
// OBSOLETE    */
// OBSOLETE   sigemptyset (&set);
// OBSOLETE   rv = sigaddset (&set, SIGCHLD);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       internal_error (__FILE__, __LINE__,
// OBSOLETE 		      "_initialize_symm_nat(): sigaddset(SIGCHLD): %s",
// OBSOLETE 		      safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE   rv = sigprocmask (SIG_BLOCK, &set, (sigset_t *) NULL);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       internal_error (__FILE__, __LINE__,
// OBSOLETE 		      "_initialize_symm_nat(): sigprocmask(SIG_BLOCK): %s",
// OBSOLETE 		      safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   sact.sa_handler = sigchld_handler;
// OBSOLETE   sigemptyset (&sact.sa_mask);
// OBSOLETE   sact.sa_flags = SA_NOCLDWAIT;	/* keep the zombies away */
// OBSOLETE   rv = sigaction (SIGCHLD, &sact, (struct sigaction *) NULL);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       internal_error (__FILE__, __LINE__,
// OBSOLETE 		      "_initialize_symm_nat(): sigaction(SIGCHLD): %s",
// OBSOLETE 		      safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE #endif
// OBSOLETE }
@


1.15
log
@2003-04-09  Andrew Cagney  <cagney@@redhat.com>

	* NEWS: Mention that the "Sequent family" is obsolete.
	* configure.tgt: Obsolete i[3456]86-sequent-bsd*,
	i[3456]86-sequent-sysv4*, and i[3456]86-sequent-sysv*.
	* configure.host: Obsolete i[3456]86-sequent-bsd*,
	i[3456]86-sequent-sysv4*, and i[3456]86-sequent-sysv*.
	* config/i386/tm-ptx4.h: Obsolete file.
	* config/i386/tm-ptx.h: Obsolete file.
	* symm-tdep.c: Obsolete file.
	* config/i386/symmetry.mt: Obsolete file.
	* config/i386/tm-symmetry.h: Obsolete file.
	* symm-nat.c: Obsolete file.
	* config/i386/nm-symmetry.h: Obsolete file.
	* config/i386/xm-symmetry.h: Obsolete file.
	* config/i386/symmetry.mh: Obsolete file.
	* config/i386/nm-ptx4.h: Obsolete file.
	* config/i386/ptx4.mh: Obsolete file.
	* config/i386/ptx.mt: Obsolete file.
	* config/i386/ptx.mh: Obsolete file.
	* config/i386/xm-ptx4.h: Obsolete file.
	* config/i386/xm-ptx.h: Obsolete file.
@
text
@@


1.14
log
@2003-02-06  Andrew Cagney  <ac131313@@redhat.com>

	* Makefile.in (symm-nat.o): Update dependencies.
	(sparc-nat.o, procfs.o, proc-api.o, ppc-linux-nat.o): Ditto.
	(lynx-nat.o, ia64-linux-nat.): Ditto.
	* symm-nat.c, sparc-nat.c, procfs.c, proc-api.c: Include
	"gdb_wait.h" instead of <wait.h> or <sys/wait.h>.
	* ppc-linux-nat.c, lynx-nat.c, ia64-linux-nat.c: Ditto.
@
text
@d1 902
a902 902
/* Sequent Symmetry host interface, for GDB when running under Unix.

   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1999,
   2000, 2001, 2003 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* FIXME, some 387-specific items of use taken from i387-tdep.c -- ought to be
   merged back in. */

#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "symtab.h"
#include "target.h"
#include "regcache.h"

/* FIXME: What is the _INKERNEL define for?  */
#define _INKERNEL
#include <signal.h>
#undef _INKERNEL
#include "gdb_wait.h"
#include <sys/param.h>
#include <sys/user.h>
#include <sys/proc.h>
#include <sys/dir.h>
#include <sys/ioctl.h>
#include "gdb_stat.h"
#ifdef _SEQUENT_
#include <sys/ptrace.h>
#else
/* Dynix has only machine/ptrace.h, which is already included by sys/user.h  */
/* Dynix has no mptrace call */
#define mptrace ptrace
#endif
#include "gdbcore.h"
#include <fcntl.h>
#include <sgtty.h>
#define TERMINAL struct sgttyb

#include "gdbcore.h"

void
store_inferior_registers (int regno)
{
  struct pt_regset regs;
  int i;

  /* FIXME: Fetching the registers is a kludge to initialize all elements
     in the fpu and fpa status. This works for normal debugging, but
     might cause problems when calling functions in the inferior.
     At least fpu_control and fpa_pcr (probably more) should be added 
     to the registers array to solve this properly.  */
  mptrace (XPT_RREGS, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regs, 0);

  regs.pr_eax = *(int *) &deprecated_registers[REGISTER_BYTE (0)];
  regs.pr_ebx = *(int *) &deprecated_registers[REGISTER_BYTE (5)];
  regs.pr_ecx = *(int *) &deprecated_registers[REGISTER_BYTE (2)];
  regs.pr_edx = *(int *) &deprecated_registers[REGISTER_BYTE (1)];
  regs.pr_esi = *(int *) &deprecated_registers[REGISTER_BYTE (6)];
  regs.pr_edi = *(int *) &deprecated_registers[REGISTER_BYTE (7)];
  regs.pr_esp = *(int *) &deprecated_registers[REGISTER_BYTE (14)];
  regs.pr_ebp = *(int *) &deprecated_registers[REGISTER_BYTE (15)];
  regs.pr_eip = *(int *) &deprecated_registers[REGISTER_BYTE (16)];
  regs.pr_flags = *(int *) &deprecated_registers[REGISTER_BYTE (17)];
  for (i = 0; i < 31; i++)
    {
      regs.pr_fpa.fpa_regs[i] =
	*(int *) &deprecated_registers[REGISTER_BYTE (FP1_REGNUM + i)];
    }
  memcpy (regs.pr_fpu.fpu_stack[0], &deprecated_registers[REGISTER_BYTE (ST0_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[1], &deprecated_registers[REGISTER_BYTE (ST1_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[2], &deprecated_registers[REGISTER_BYTE (ST2_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[3], &deprecated_registers[REGISTER_BYTE (ST3_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[4], &deprecated_registers[REGISTER_BYTE (ST4_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[5], &deprecated_registers[REGISTER_BYTE (ST5_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[6], &deprecated_registers[REGISTER_BYTE (ST6_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[7], &deprecated_registers[REGISTER_BYTE (ST7_REGNUM)], 10);
  mptrace (XPT_WREGS, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regs, 0);
}

void
fetch_inferior_registers (int regno)
{
  int i;
  struct pt_regset regs;

  deprecated_registers_fetched ();

  mptrace (XPT_RREGS, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regs, 0);
  *(int *) &deprecated_registers[REGISTER_BYTE (EAX_REGNUM)] = regs.pr_eax;
  *(int *) &rdeprecated_egisters[REGISTER_BYTE (EBX_REGNUM)] = regs.pr_ebx;
  *(int *) &deprecated_registers[REGISTER_BYTE (ECX_REGNUM)] = regs.pr_ecx;
  *(int *) &deprecated_registers[REGISTER_BYTE (EDX_REGNUM)] = regs.pr_edx;
  *(int *) &deprecated_registers[REGISTER_BYTE (ESI_REGNUM)] = regs.pr_esi;
  *(int *) &deprecated_registers[REGISTER_BYTE (EDI_REGNUM)] = regs.pr_edi;
  *(int *) &deprecated_registers[REGISTER_BYTE (EBP_REGNUM)] = regs.pr_ebp;
  *(int *) &deprecated_registers[REGISTER_BYTE (ESP_REGNUM)] = regs.pr_esp;
  *(int *) &deprecated_registers[REGISTER_BYTE (EIP_REGNUM)] = regs.pr_eip;
  *(int *) &deprecated_registers[REGISTER_BYTE (EFLAGS_REGNUM)] = regs.pr_flags;
  for (i = 0; i < FPA_NREGS; i++)
    {
      *(int *) &deprecated_registers[REGISTER_BYTE (FP1_REGNUM + i)] =
	regs.pr_fpa.fpa_regs[i];
    }
  memcpy (&deprecated_registers[REGISTER_BYTE (ST0_REGNUM)], regs.pr_fpu.fpu_stack[0], 10);
  memcpy (&deprecated_registers[REGISTER_BYTE (ST1_REGNUM)], regs.pr_fpu.fpu_stack[1], 10);
  memcpy (&deprecated_registers[REGISTER_BYTE (ST2_REGNUM)], regs.pr_fpu.fpu_stack[2], 10);
  memcpy (&deprecated_registers[REGISTER_BYTE (ST3_REGNUM)], regs.pr_fpu.fpu_stack[3], 10);
  memcpy (&deprecated_registers[REGISTER_BYTE (ST4_REGNUM)], regs.pr_fpu.fpu_stack[4], 10);
  memcpy (&deprecated_registers[REGISTER_BYTE (ST5_REGNUM)], regs.pr_fpu.fpu_stack[5], 10);
  memcpy (&deprecated_registers[REGISTER_BYTE (ST6_REGNUM)], regs.pr_fpu.fpu_stack[6], 10);
  memcpy (&deprecated_registers[REGISTER_BYTE (ST7_REGNUM)], regs.pr_fpu.fpu_stack[7], 10);
}

/* FIXME:  This should be merged with i387-tdep.c as well. */
static
print_fpu_status (struct pt_regset ep)
{
  int i;
  int bothstatus;
  int top;
  int fpreg;
  unsigned char *p;

  printf_unfiltered ("80387:");
  if (ep.pr_fpu.fpu_ip == 0)
    {
      printf_unfiltered (" not in use.\n");
      return;
    }
  else
    {
      printf_unfiltered ("\n");
    }
  if (ep.pr_fpu.fpu_status != 0)
    {
      print_387_status_word (ep.pr_fpu.fpu_status);
    }
  print_387_control_word (ep.pr_fpu.fpu_control);
  printf_unfiltered ("last exception: ");
  printf_unfiltered ("opcode 0x%x; ", ep.pr_fpu.fpu_rsvd4);
  printf_unfiltered ("pc 0x%x:0x%x; ", ep.pr_fpu.fpu_cs, ep.pr_fpu.fpu_ip);
  printf_unfiltered ("operand 0x%x:0x%x\n", ep.pr_fpu.fpu_data_offset, ep.pr_fpu.fpu_op_sel);

  top = (ep.pr_fpu.fpu_status >> 11) & 7;

  printf_unfiltered ("regno  tag  msb              lsb  value\n");
  for (fpreg = 7; fpreg >= 0; fpreg--)
    {
      double val;

      printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg);

      switch ((ep.pr_fpu.fpu_tag >> (fpreg * 2)) & 3)
	{
	case 0:
	  printf_unfiltered ("valid ");
	  break;
	case 1:
	  printf_unfiltered ("zero  ");
	  break;
	case 2:
	  printf_unfiltered ("trap  ");
	  break;
	case 3:
	  printf_unfiltered ("empty ");
	  break;
	}
      for (i = 9; i >= 0; i--)
	printf_unfiltered ("%02x", ep.pr_fpu.fpu_stack[fpreg][i]);

      i387_to_double ((char *) ep.pr_fpu.fpu_stack[fpreg], (char *) &val);
      printf_unfiltered ("  %g\n", val);
    }
  if (ep.pr_fpu.fpu_rsvd1)
    warning ("rsvd1 is 0x%x\n", ep.pr_fpu.fpu_rsvd1);
  if (ep.pr_fpu.fpu_rsvd2)
    warning ("rsvd2 is 0x%x\n", ep.pr_fpu.fpu_rsvd2);
  if (ep.pr_fpu.fpu_rsvd3)
    warning ("rsvd3 is 0x%x\n", ep.pr_fpu.fpu_rsvd3);
  if (ep.pr_fpu.fpu_rsvd5)
    warning ("rsvd5 is 0x%x\n", ep.pr_fpu.fpu_rsvd5);
}


print_1167_control_word (unsigned int pcr)
{
  int pcr_tmp;

  pcr_tmp = pcr & FPA_PCR_MODE;
  printf_unfiltered ("\tMODE= %#x; RND= %#x ", pcr_tmp, pcr_tmp & 12);
  switch (pcr_tmp & 12)
    {
    case 0:
      printf_unfiltered ("RN (Nearest Value)");
      break;
    case 1:
      printf_unfiltered ("RZ (Zero)");
      break;
    case 2:
      printf_unfiltered ("RP (Positive Infinity)");
      break;
    case 3:
      printf_unfiltered ("RM (Negative Infinity)");
      break;
    }
  printf_unfiltered ("; IRND= %d ", pcr_tmp & 2);
  if (0 == pcr_tmp & 2)
    {
      printf_unfiltered ("(same as RND)\n");
    }
  else
    {
      printf_unfiltered ("(toward zero)\n");
    }
  pcr_tmp = pcr & FPA_PCR_EM;
  printf_unfiltered ("\tEM= %#x", pcr_tmp);
  if (pcr_tmp & FPA_PCR_EM_DM)
    printf_unfiltered (" DM");
  if (pcr_tmp & FPA_PCR_EM_UOM)
    printf_unfiltered (" UOM");
  if (pcr_tmp & FPA_PCR_EM_PM)
    printf_unfiltered (" PM");
  if (pcr_tmp & FPA_PCR_EM_UM)
    printf_unfiltered (" UM");
  if (pcr_tmp & FPA_PCR_EM_OM)
    printf_unfiltered (" OM");
  if (pcr_tmp & FPA_PCR_EM_ZM)
    printf_unfiltered (" ZM");
  if (pcr_tmp & FPA_PCR_EM_IM)
    printf_unfiltered (" IM");
  printf_unfiltered ("\n");
  pcr_tmp = FPA_PCR_CC;
  printf_unfiltered ("\tCC= %#x", pcr_tmp);
  if (pcr_tmp & FPA_PCR_20MHZ)
    printf_unfiltered (" 20MHZ");
  if (pcr_tmp & FPA_PCR_CC_Z)
    printf_unfiltered (" Z");
  if (pcr_tmp & FPA_PCR_CC_C2)
    printf_unfiltered (" C2");

  /* Dynix defines FPA_PCR_CC_C0 to 0x100 and ptx defines
     FPA_PCR_CC_C1 to 0x100.  Use whichever is defined and assume
     the OS knows what it is doing.  */
#ifdef FPA_PCR_CC_C1
  if (pcr_tmp & FPA_PCR_CC_C1)
    printf_unfiltered (" C1");
#else
  if (pcr_tmp & FPA_PCR_CC_C0)
    printf_unfiltered (" C0");
#endif

  switch (pcr_tmp)
    {
    case FPA_PCR_CC_Z:
      printf_unfiltered (" (Equal)");
      break;
#ifdef FPA_PCR_CC_C1
    case FPA_PCR_CC_C1:
#else
    case FPA_PCR_CC_C0:
#endif
      printf_unfiltered (" (Less than)");
      break;
    case 0:
      printf_unfiltered (" (Greater than)");
      break;
      case FPA_PCR_CC_Z |
#ifdef FPA_PCR_CC_C1
	FPA_PCR_CC_C1
#else
	FPA_PCR_CC_C0
#endif
    | FPA_PCR_CC_C2:
      printf_unfiltered (" (Unordered)");
      break;
    default:
      printf_unfiltered (" (Undefined)");
      break;
    }
  printf_unfiltered ("\n");
  pcr_tmp = pcr & FPA_PCR_AE;
  printf_unfiltered ("\tAE= %#x", pcr_tmp);
  if (pcr_tmp & FPA_PCR_AE_DE)
    printf_unfiltered (" DE");
  if (pcr_tmp & FPA_PCR_AE_UOE)
    printf_unfiltered (" UOE");
  if (pcr_tmp & FPA_PCR_AE_PE)
    printf_unfiltered (" PE");
  if (pcr_tmp & FPA_PCR_AE_UE)
    printf_unfiltered (" UE");
  if (pcr_tmp & FPA_PCR_AE_OE)
    printf_unfiltered (" OE");
  if (pcr_tmp & FPA_PCR_AE_ZE)
    printf_unfiltered (" ZE");
  if (pcr_tmp & FPA_PCR_AE_EE)
    printf_unfiltered (" EE");
  if (pcr_tmp & FPA_PCR_AE_IE)
    printf_unfiltered (" IE");
  printf_unfiltered ("\n");
}

print_1167_regs (long regs[FPA_NREGS])
{
  int i;

  union
    {
      double d;
      long l[2];
    }
  xd;
  union
    {
      float f;
      long l;
    }
  xf;


  for (i = 0; i < FPA_NREGS; i++)
    {
      xf.l = regs[i];
      printf_unfiltered ("%%fp%d: raw= %#x, single= %f", i + 1, regs[i], xf.f);
      if (!(i & 1))
	{
	  printf_unfiltered ("\n");
	}
      else
	{
	  xd.l[1] = regs[i];
	  xd.l[0] = regs[i + 1];
	  printf_unfiltered (", double= %f\n", xd.d);
	}
    }
}

print_fpa_status (struct pt_regset ep)
{

  printf_unfiltered ("WTL 1167:");
  if (ep.pr_fpa.fpa_pcr != 0)
    {
      printf_unfiltered ("\n");
      print_1167_control_word (ep.pr_fpa.fpa_pcr);
      print_1167_regs (ep.pr_fpa.fpa_regs);
    }
  else
    {
      printf_unfiltered (" not in use.\n");
    }
}

#if 0				/* disabled because it doesn't go through the target vector.  */
i386_float_info (void)
{
  char ubuf[UPAGES * NBPG];
  struct pt_regset regset;

  if (have_inferior_p ())
    {
      PTRACE_READ_REGS (PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regset);
    }
  else
    {
      int corechan = bfd_cache_lookup (core_bfd);
      if (lseek (corechan, 0, 0) < 0)
	{
	  perror ("seek on core file");
	}
      if (myread (corechan, ubuf, UPAGES * NBPG) < 0)
	{
	  perror ("read on core file");
	}
      /* only interested in the floating point registers */
      regset.pr_fpu = ((struct user *) ubuf)->u_fpusave;
      regset.pr_fpa = ((struct user *) ubuf)->u_fpasave;
    }
  print_fpu_status (regset);
  print_fpa_status (regset);
}
#endif

static volatile int got_sigchld;

/*ARGSUSED */
/* This will eventually be more interesting. */
void
sigchld_handler (int signo)
{
  got_sigchld++;
}

/*
 * Signals for which the default action does not cause the process
 * to die.  See <sys/signal.h> for where this came from (alas, we
 * can't use those macros directly)
 */
#ifndef sigmask
#define sigmask(s) (1 << ((s) - 1))
#endif
#define SIGNALS_DFL_SAFE sigmask(SIGSTOP) | sigmask(SIGTSTP) | \
	sigmask(SIGTTIN) | sigmask(SIGTTOU) | sigmask(SIGCHLD) | \
	sigmask(SIGCONT) | sigmask(SIGWINCH) | sigmask(SIGPWR) | \
	sigmask(SIGURG) | sigmask(SIGPOLL)

#ifdef ATTACH_DETACH
/*
 * Thanks to XPT_MPDEBUGGER, we have to mange child_wait().
 */
ptid_t
child_wait (ptid_t ptid, struct target_waitstatus *status)
{
  int save_errno, rv, xvaloff, saoff, sa_hand;
  struct pt_stop pt;
  struct user u;
  sigset_t set;
  /* Host signal number for a signal which the inferior terminates with, or
     0 if it hasn't terminated due to a signal.  */
  static int death_by_signal = 0;
#ifdef SVR4_SHARED_LIBS		/* use this to distinguish ptx 2 vs ptx 4 */
  prstatus_t pstatus;
#endif
  int pid = PIDGET (ptid);

  do
    {
      set_sigint_trap ();	/* Causes SIGINT to be passed on to the
				   attached process. */
      save_errno = errno;

      got_sigchld = 0;

      sigemptyset (&set);

      while (got_sigchld == 0)
	{
	  sigsuspend (&set);
	}

      clear_sigint_trap ();

      rv = mptrace (XPT_STOPSTAT, 0, (char *) &pt, 0);
      if (-1 == rv)
	{
	  printf ("XPT_STOPSTAT: errno %d\n", errno);	/* DEBUG */
	  continue;
	}

      pid = pt.ps_pid;

      if (pid != PIDGET (inferior_ptid))
	{
	  /* NOTE: the mystery fork in csh/tcsh needs to be ignored.
	   * We should not return new children for the initial run
	   * of a process until it has done the exec.
	   */
	  /* inferior probably forked; send it on its way */
	  rv = mptrace (XPT_UNDEBUG, pid, 0, 0);
	  if (-1 == rv)
	    {
	      printf ("child_wait: XPT_UNDEBUG: pid %d: %s\n", pid,
		      safe_strerror (errno));
	    }
	  continue;
	}
      /* FIXME: Do we deal with fork notification correctly?  */
      switch (pt.ps_reason)
	{
	case PTS_FORK:
	  /* multi proc: treat like PTS_EXEC */
	  /*
	   * Pretend this didn't happen, since gdb isn't set up
	   * to deal with stops on fork.
	   */
	  rv = ptrace (PT_CONTSIG, pid, 1, 0);
	  if (-1 == rv)
	    {
	      printf ("PTS_FORK: PT_CONTSIG: error %d\n", errno);
	    }
	  continue;
	case PTS_EXEC:
	  /*
	   * Pretend this is a SIGTRAP.
	   */
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_TRAP;
	  break;
	case PTS_EXIT:
	  /*
	   * Note: we stop before the exit actually occurs.  Extract
	   * the exit code from the uarea.  If we're stopped in the
	   * exit() system call, the exit code will be in
	   * u.u_ap[0].  An exit due to an uncaught signal will have
	   * something else in here, see the comment in the default:
	   * case, below.  Finally,let the process exit.
	   */
	  if (death_by_signal)
	    {
	      status->kind = TARGET_WAITKIND_SIGNALED;
	      status->value.sig = target_signal_from_host (death_by_signal);
	      death_by_signal = 0;
	      break;
	    }
	  xvaloff = (unsigned long) &u.u_ap[0] - (unsigned long) &u;
	  errno = 0;
	  rv = ptrace (PT_RUSER, pid, (char *) xvaloff, 0);
	  status->kind = TARGET_WAITKIND_EXITED;
	  status->value.integer = rv;
	  /*
	   * addr & data to mptrace() don't matter here, since
	   * the process is already dead.
	   */
	  rv = mptrace (XPT_UNDEBUG, pid, 0, 0);
	  if (-1 == rv)
	    {
	      printf ("child_wait: PTS_EXIT: XPT_UNDEBUG: pid %d error %d\n", pid,
		      errno);
	    }
	  break;
	case PTS_WATCHPT_HIT:
	  internal_error (__FILE__, __LINE__,
			  "PTS_WATCHPT_HIT\n");
	  break;
	default:
	  /* stopped by signal */
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = target_signal_from_host (pt.ps_reason);
	  death_by_signal = 0;

	  if (0 == (SIGNALS_DFL_SAFE & sigmask (pt.ps_reason)))
	    {
	      break;
	    }
	  /* else default action of signal is to die */
#ifdef SVR4_SHARED_LIBS
	  rv = ptrace (PT_GET_PRSTATUS, pid, (char *) &pstatus, 0);
	  if (-1 == rv)
	    error ("child_wait: signal %d PT_GET_PRSTATUS: %s\n",
		   pt.ps_reason, safe_strerror (errno));
	  if (pstatus.pr_cursig != pt.ps_reason)
	    {
	      printf ("pstatus signal %d, pt signal %d\n",
		      pstatus.pr_cursig, pt.ps_reason);
	    }
	  sa_hand = (int) pstatus.pr_action.sa_handler;
#else
	  saoff = (unsigned long) &u.u_sa[0] - (unsigned long) &u;
	  saoff += sizeof (struct sigaction) * (pt.ps_reason - 1);
	  errno = 0;
	  sa_hand = ptrace (PT_RUSER, pid, (char *) saoff, 0);
	  if (errno)
	    error ("child_wait: signal %d: RUSER: %s\n",
		   pt.ps_reason, safe_strerror (errno));
#endif
	  if ((int) SIG_DFL == sa_hand)
	    {
	      /* we will be dying */
	      death_by_signal = pt.ps_reason;
	    }
	  break;
	}

    }
  while (pid != PIDGET (inferior_ptid));	/* Some other child died or stopped */

  return pid_to_ptid (pid);
}
#else /* !ATTACH_DETACH */
/*
 * Simple child_wait() based on inftarg.c child_wait() for use until
 * the MPDEBUGGER child_wait() works properly.  This will go away when
 * that is fixed.
 */
ptid_t
child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  int save_errno;
  int status;
  int pid = PIDGET (ptid);

  do
    {
      pid = wait (&status);
      save_errno = errno;

      if (pid == -1)
	{
	  if (save_errno == EINTR)
	    continue;
	  fprintf (stderr, "Child process unexpectedly missing: %s.\n",
		   safe_strerror (save_errno));
	  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
	  ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
	  return pid_to_ptid (-1);
	}
    }
  while (pid != PIDGET (inferior_ptid));	/* Some other child died or stopped */
  store_waitstatus (ourstatus, status);
  return pid_to_ptid (pid);
}
#endif /* ATTACH_DETACH */



/* This function simply calls ptrace with the given arguments.  
   It exists so that all calls to ptrace are isolated in this 
   machine-dependent file. */
int
call_ptrace (int request, int pid, PTRACE_ARG3_TYPE addr, int data)
{
  return ptrace (request, pid, addr, data);
}

int
call_mptrace (int request, int pid, PTRACE_ARG3_TYPE addr, int data)
{
  return mptrace (request, pid, addr, data);
}

#if defined (DEBUG_PTRACE)
/* For the rest of the file, use an extra level of indirection */
/* This lets us breakpoint usefully on call_ptrace. */
#define ptrace call_ptrace
#define mptrace call_mptrace
#endif

void
kill_inferior (void)
{
  if (ptid_equal (inferior_ptid, null_ptid))
    return;

  /* For MPDEBUGGER, don't use PT_KILL, since the child will stop
     again with a PTS_EXIT.  Just hit him with SIGKILL (so he stops)
     and detach. */

  kill (PIDGET (inferior_ptid), SIGKILL);
#ifdef ATTACH_DETACH
  detach (SIGKILL);
#else /* ATTACH_DETACH */
  ptrace (PT_KILL, PIDGET (inferior_ptid), 0, 0);
  wait ((int *) NULL);
#endif /* ATTACH_DETACH */
  target_mourn_inferior ();
}

/* Resume execution of the inferior process.
   If STEP is nonzero, single-step it.
   If SIGNAL is nonzero, give it that signal.  */

void
child_resume (ptid_t ptid, int step, enum target_signal signal)
{
  int pid = PIDGET (ptid);

  errno = 0;

  if (pid == -1)
    pid = PIDGET (inferior_ptid);

  /* An address of (PTRACE_ARG3_TYPE)1 tells ptrace to continue from where
     it was.  (If GDB wanted it to start some other way, we have already
     written a new PC value to the child.)

     If this system does not support PT_SSTEP, a higher level function will
     have called single_step() to transmute the step request into a
     continue request (by setting breakpoints on all possible successor
     instructions), so we don't have to worry about that here.  */

  if (step)
    ptrace (PT_SSTEP, pid, (PTRACE_ARG3_TYPE) 1, signal);
  else
    ptrace (PT_CONTSIG, pid, (PTRACE_ARG3_TYPE) 1, signal);

  if (errno)
    perror_with_name ("ptrace");
}

#ifdef ATTACH_DETACH
/* Start debugging the process whose number is PID.  */
int
attach (int pid)
{
  sigset_t set;
  int rv;

  rv = mptrace (XPT_DEBUG, pid, 0, 0);
  if (-1 == rv)
    {
      error ("mptrace(XPT_DEBUG): %s", safe_strerror (errno));
    }
  rv = mptrace (XPT_SIGNAL, pid, 0, SIGSTOP);
  if (-1 == rv)
    {
      error ("mptrace(XPT_SIGNAL): %s", safe_strerror (errno));
    }
  attach_flag = 1;
  return pid;
}

void
detach (int signo)
{
  int rv;

  rv = mptrace (XPT_UNDEBUG, PIDGET (inferior_ptid), 1, signo);
  if (-1 == rv)
    {
      error ("mptrace(XPT_UNDEBUG): %s", safe_strerror (errno));
    }
  attach_flag = 0;
}

#endif /* ATTACH_DETACH */

/* Default the type of the ptrace transfer to int.  */
#ifndef PTRACE_XFER_TYPE
#define PTRACE_XFER_TYPE int
#endif


/* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory
   in the NEW_SUN_PTRACE case.
   It ought to be straightforward.  But it appears that writing did
   not write the data that I specified.  I cannot understand where
   it got the data that it actually did write.  */

/* Copy LEN bytes to or from inferior's memory starting at MEMADDR
   to debugger memory starting at MYADDR.   Copy to inferior if
   WRITE is nonzero.  TARGET is ignored.

   Returns the length copied, which is either the LEN argument or zero.
   This xfer function does not do partial moves, since child_ops
   doesn't allow memory operations to cross below us in the target stack
   anyway.  */

int
child_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		   struct mem_attrib *attrib,
		   struct target_ops *target)
{
  register int i;
  /* Round starting address down to longword boundary.  */
  register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_XFER_TYPE);
  /* Round ending address up; get number of longwords that makes.  */
  register int count
  = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
  / sizeof (PTRACE_XFER_TYPE);
  /* Allocate buffer of that many longwords.  */
  /* FIXME (alloca): This code, cloned from infptrace.c, is unsafe
     because it uses alloca to allocate a buffer of arbitrary size.
     For very large xfers, this could crash GDB's stack.  */
  register PTRACE_XFER_TYPE *buffer
    = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));

  if (write)
    {
      /* Fill start and end extra bytes of buffer with existing memory data.  */

      if (addr != memaddr || len < (int) sizeof (PTRACE_XFER_TYPE))
	{
	  /* Need part of initial word -- fetch it.  */
	  buffer[0] = ptrace (PT_RTEXT, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) addr,
			      0);
	}

      if (count > 1)		/* FIXME, avoid if even boundary */
	{
	  buffer[count - 1]
	    = ptrace (PT_RTEXT, PIDGET (inferior_ptid),
		      ((PTRACE_ARG3_TYPE)
		       (addr + (count - 1) * sizeof (PTRACE_XFER_TYPE))),
		      0);
	}

      /* Copy data to be written over corresponding part of buffer */

      memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
	      myaddr,
	      len);

      /* Write the entire buffer.  */

      for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
	{
	  errno = 0;
	  ptrace (PT_WDATA, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) addr,
		  buffer[i]);
	  if (errno)
	    {
	      /* Using the appropriate one (I or D) is necessary for
	         Gould NP1, at least.  */
	      errno = 0;
	      ptrace (PT_WTEXT, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) addr,
		      buffer[i]);
	    }
	  if (errno)
	    return 0;
	}
    }
  else
    {
      /* Read all the longwords */
      for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
	{
	  errno = 0;
	  buffer[i] = ptrace (PT_RTEXT, PIDGET (inferior_ptid),
			      (PTRACE_ARG3_TYPE) addr, 0);
	  if (errno)
	    return 0;
	  QUIT;
	}

      /* Copy appropriate bytes out of the buffer.  */
      memcpy (myaddr,
	      (char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
	      len);
    }
  return len;
}


void
_initialize_symm_nat (void)
{
#ifdef ATTACH_DETACH
/*
 * the MPDEBUGGER is necessary for process tree debugging and attach
 * to work, but it alters the behavior of debugged processes, so other
 * things (at least child_wait()) will have to change to accomodate
 * that.
 *
 * Note that attach is not implemented in dynix 3, and not in ptx
 * until version 2.1 of the OS.
 */
  int rv;
  sigset_t set;
  struct sigaction sact;

  rv = mptrace (XPT_MPDEBUGGER, 0, 0, 0);
  if (-1 == rv)
    {
      internal_error (__FILE__, __LINE__,
		      "_initialize_symm_nat(): mptrace(XPT_MPDEBUGGER): %s",
		      safe_strerror (errno));
    }

  /*
   * Under MPDEBUGGER, we get SIGCLHD when a traced process does
   * anything of interest.
   */

  /*
   * Block SIGCHLD.  We leave it blocked all the time, and then
   * call sigsuspend() in child_wait() to wait for the child
   * to do something.  None of these ought to fail, but check anyway.
   */
  sigemptyset (&set);
  rv = sigaddset (&set, SIGCHLD);
  if (-1 == rv)
    {
      internal_error (__FILE__, __LINE__,
		      "_initialize_symm_nat(): sigaddset(SIGCHLD): %s",
		      safe_strerror (errno));
    }
  rv = sigprocmask (SIG_BLOCK, &set, (sigset_t *) NULL);
  if (-1 == rv)
    {
      internal_error (__FILE__, __LINE__,
		      "_initialize_symm_nat(): sigprocmask(SIG_BLOCK): %s",
		      safe_strerror (errno));
    }

  sact.sa_handler = sigchld_handler;
  sigemptyset (&sact.sa_mask);
  sact.sa_flags = SA_NOCLDWAIT;	/* keep the zombies away */
  rv = sigaction (SIGCHLD, &sact, (struct sigaction *) NULL);
  if (-1 == rv)
    {
      internal_error (__FILE__, __LINE__,
		      "_initialize_symm_nat(): sigaction(SIGCHLD): %s",
		      safe_strerror (errno));
    }
#endif
}
@


1.14.12.1
log
@Merge with mainline.
@
text
@d1 902
a902 902
// OBSOLETE /* Sequent Symmetry host interface, for GDB when running under Unix.
// OBSOLETE 
// OBSOLETE    Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1999,
// OBSOLETE    2000, 2001, 2003 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /* FIXME, some 387-specific items of use taken from i387-tdep.c -- ought to be
// OBSOLETE    merged back in. */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE /* FIXME: What is the _INKERNEL define for?  */
// OBSOLETE #define _INKERNEL
// OBSOLETE #include <signal.h>
// OBSOLETE #undef _INKERNEL
// OBSOLETE #include "gdb_wait.h"
// OBSOLETE #include <sys/param.h>
// OBSOLETE #include <sys/user.h>
// OBSOLETE #include <sys/proc.h>
// OBSOLETE #include <sys/dir.h>
// OBSOLETE #include <sys/ioctl.h>
// OBSOLETE #include "gdb_stat.h"
// OBSOLETE #ifdef _SEQUENT_
// OBSOLETE #include <sys/ptrace.h>
// OBSOLETE #else
// OBSOLETE /* Dynix has only machine/ptrace.h, which is already included by sys/user.h  */
// OBSOLETE /* Dynix has no mptrace call */
// OBSOLETE #define mptrace ptrace
// OBSOLETE #endif
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include <fcntl.h>
// OBSOLETE #include <sgtty.h>
// OBSOLETE #define TERMINAL struct sgttyb
// OBSOLETE 
// OBSOLETE #include "gdbcore.h"
// OBSOLETE 
// OBSOLETE void
// OBSOLETE store_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   struct pt_regset regs;
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   /* FIXME: Fetching the registers is a kludge to initialize all elements
// OBSOLETE      in the fpu and fpa status. This works for normal debugging, but
// OBSOLETE      might cause problems when calling functions in the inferior.
// OBSOLETE      At least fpu_control and fpa_pcr (probably more) should be added 
// OBSOLETE      to the registers array to solve this properly.  */
// OBSOLETE   mptrace (XPT_RREGS, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regs, 0);
// OBSOLETE 
// OBSOLETE   regs.pr_eax = *(int *) &deprecated_registers[REGISTER_BYTE (0)];
// OBSOLETE   regs.pr_ebx = *(int *) &deprecated_registers[REGISTER_BYTE (5)];
// OBSOLETE   regs.pr_ecx = *(int *) &deprecated_registers[REGISTER_BYTE (2)];
// OBSOLETE   regs.pr_edx = *(int *) &deprecated_registers[REGISTER_BYTE (1)];
// OBSOLETE   regs.pr_esi = *(int *) &deprecated_registers[REGISTER_BYTE (6)];
// OBSOLETE   regs.pr_edi = *(int *) &deprecated_registers[REGISTER_BYTE (7)];
// OBSOLETE   regs.pr_esp = *(int *) &deprecated_registers[REGISTER_BYTE (14)];
// OBSOLETE   regs.pr_ebp = *(int *) &deprecated_registers[REGISTER_BYTE (15)];
// OBSOLETE   regs.pr_eip = *(int *) &deprecated_registers[REGISTER_BYTE (16)];
// OBSOLETE   regs.pr_flags = *(int *) &deprecated_registers[REGISTER_BYTE (17)];
// OBSOLETE   for (i = 0; i < 31; i++)
// OBSOLETE     {
// OBSOLETE       regs.pr_fpa.fpa_regs[i] =
// OBSOLETE 	*(int *) &deprecated_registers[REGISTER_BYTE (FP1_REGNUM + i)];
// OBSOLETE     }
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[0], &deprecated_registers[REGISTER_BYTE (ST0_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[1], &deprecated_registers[REGISTER_BYTE (ST1_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[2], &deprecated_registers[REGISTER_BYTE (ST2_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[3], &deprecated_registers[REGISTER_BYTE (ST3_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[4], &deprecated_registers[REGISTER_BYTE (ST4_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[5], &deprecated_registers[REGISTER_BYTE (ST5_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[6], &deprecated_registers[REGISTER_BYTE (ST6_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[7], &deprecated_registers[REGISTER_BYTE (ST7_REGNUM)], 10);
// OBSOLETE   mptrace (XPT_WREGS, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regs, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fetch_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   struct pt_regset regs;
// OBSOLETE 
// OBSOLETE   deprecated_registers_fetched ();
// OBSOLETE 
// OBSOLETE   mptrace (XPT_RREGS, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regs, 0);
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EAX_REGNUM)] = regs.pr_eax;
// OBSOLETE   *(int *) &rdeprecated_egisters[REGISTER_BYTE (EBX_REGNUM)] = regs.pr_ebx;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (ECX_REGNUM)] = regs.pr_ecx;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EDX_REGNUM)] = regs.pr_edx;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (ESI_REGNUM)] = regs.pr_esi;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EDI_REGNUM)] = regs.pr_edi;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EBP_REGNUM)] = regs.pr_ebp;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (ESP_REGNUM)] = regs.pr_esp;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EIP_REGNUM)] = regs.pr_eip;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EFLAGS_REGNUM)] = regs.pr_flags;
// OBSOLETE   for (i = 0; i < FPA_NREGS; i++)
// OBSOLETE     {
// OBSOLETE       *(int *) &deprecated_registers[REGISTER_BYTE (FP1_REGNUM + i)] =
// OBSOLETE 	regs.pr_fpa.fpa_regs[i];
// OBSOLETE     }
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST0_REGNUM)], regs.pr_fpu.fpu_stack[0], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST1_REGNUM)], regs.pr_fpu.fpu_stack[1], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST2_REGNUM)], regs.pr_fpu.fpu_stack[2], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST3_REGNUM)], regs.pr_fpu.fpu_stack[3], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST4_REGNUM)], regs.pr_fpu.fpu_stack[4], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST5_REGNUM)], regs.pr_fpu.fpu_stack[5], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST6_REGNUM)], regs.pr_fpu.fpu_stack[6], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST7_REGNUM)], regs.pr_fpu.fpu_stack[7], 10);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* FIXME:  This should be merged with i387-tdep.c as well. */
// OBSOLETE static
// OBSOLETE print_fpu_status (struct pt_regset ep)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   int bothstatus;
// OBSOLETE   int top;
// OBSOLETE   int fpreg;
// OBSOLETE   unsigned char *p;
// OBSOLETE 
// OBSOLETE   printf_unfiltered ("80387:");
// OBSOLETE   if (ep.pr_fpu.fpu_ip == 0)
// OBSOLETE     {
// OBSOLETE       printf_unfiltered (" not in use.\n");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("\n");
// OBSOLETE     }
// OBSOLETE   if (ep.pr_fpu.fpu_status != 0)
// OBSOLETE     {
// OBSOLETE       print_387_status_word (ep.pr_fpu.fpu_status);
// OBSOLETE     }
// OBSOLETE   print_387_control_word (ep.pr_fpu.fpu_control);
// OBSOLETE   printf_unfiltered ("last exception: ");
// OBSOLETE   printf_unfiltered ("opcode 0x%x; ", ep.pr_fpu.fpu_rsvd4);
// OBSOLETE   printf_unfiltered ("pc 0x%x:0x%x; ", ep.pr_fpu.fpu_cs, ep.pr_fpu.fpu_ip);
// OBSOLETE   printf_unfiltered ("operand 0x%x:0x%x\n", ep.pr_fpu.fpu_data_offset, ep.pr_fpu.fpu_op_sel);
// OBSOLETE 
// OBSOLETE   top = (ep.pr_fpu.fpu_status >> 11) & 7;
// OBSOLETE 
// OBSOLETE   printf_unfiltered ("regno  tag  msb              lsb  value\n");
// OBSOLETE   for (fpreg = 7; fpreg >= 0; fpreg--)
// OBSOLETE     {
// OBSOLETE       double val;
// OBSOLETE 
// OBSOLETE       printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg);
// OBSOLETE 
// OBSOLETE       switch ((ep.pr_fpu.fpu_tag >> (fpreg * 2)) & 3)
// OBSOLETE 	{
// OBSOLETE 	case 0:
// OBSOLETE 	  printf_unfiltered ("valid ");
// OBSOLETE 	  break;
// OBSOLETE 	case 1:
// OBSOLETE 	  printf_unfiltered ("zero  ");
// OBSOLETE 	  break;
// OBSOLETE 	case 2:
// OBSOLETE 	  printf_unfiltered ("trap  ");
// OBSOLETE 	  break;
// OBSOLETE 	case 3:
// OBSOLETE 	  printf_unfiltered ("empty ");
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       for (i = 9; i >= 0; i--)
// OBSOLETE 	printf_unfiltered ("%02x", ep.pr_fpu.fpu_stack[fpreg][i]);
// OBSOLETE 
// OBSOLETE       i387_to_double ((char *) ep.pr_fpu.fpu_stack[fpreg], (char *) &val);
// OBSOLETE       printf_unfiltered ("  %g\n", val);
// OBSOLETE     }
// OBSOLETE   if (ep.pr_fpu.fpu_rsvd1)
// OBSOLETE     warning ("rsvd1 is 0x%x\n", ep.pr_fpu.fpu_rsvd1);
// OBSOLETE   if (ep.pr_fpu.fpu_rsvd2)
// OBSOLETE     warning ("rsvd2 is 0x%x\n", ep.pr_fpu.fpu_rsvd2);
// OBSOLETE   if (ep.pr_fpu.fpu_rsvd3)
// OBSOLETE     warning ("rsvd3 is 0x%x\n", ep.pr_fpu.fpu_rsvd3);
// OBSOLETE   if (ep.pr_fpu.fpu_rsvd5)
// OBSOLETE     warning ("rsvd5 is 0x%x\n", ep.pr_fpu.fpu_rsvd5);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE print_1167_control_word (unsigned int pcr)
// OBSOLETE {
// OBSOLETE   int pcr_tmp;
// OBSOLETE 
// OBSOLETE   pcr_tmp = pcr & FPA_PCR_MODE;
// OBSOLETE   printf_unfiltered ("\tMODE= %#x; RND= %#x ", pcr_tmp, pcr_tmp & 12);
// OBSOLETE   switch (pcr_tmp & 12)
// OBSOLETE     {
// OBSOLETE     case 0:
// OBSOLETE       printf_unfiltered ("RN (Nearest Value)");
// OBSOLETE       break;
// OBSOLETE     case 1:
// OBSOLETE       printf_unfiltered ("RZ (Zero)");
// OBSOLETE       break;
// OBSOLETE     case 2:
// OBSOLETE       printf_unfiltered ("RP (Positive Infinity)");
// OBSOLETE       break;
// OBSOLETE     case 3:
// OBSOLETE       printf_unfiltered ("RM (Negative Infinity)");
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE   printf_unfiltered ("; IRND= %d ", pcr_tmp & 2);
// OBSOLETE   if (0 == pcr_tmp & 2)
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("(same as RND)\n");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("(toward zero)\n");
// OBSOLETE     }
// OBSOLETE   pcr_tmp = pcr & FPA_PCR_EM;
// OBSOLETE   printf_unfiltered ("\tEM= %#x", pcr_tmp);
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_DM)
// OBSOLETE     printf_unfiltered (" DM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_UOM)
// OBSOLETE     printf_unfiltered (" UOM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_PM)
// OBSOLETE     printf_unfiltered (" PM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_UM)
// OBSOLETE     printf_unfiltered (" UM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_OM)
// OBSOLETE     printf_unfiltered (" OM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_ZM)
// OBSOLETE     printf_unfiltered (" ZM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_IM)
// OBSOLETE     printf_unfiltered (" IM");
// OBSOLETE   printf_unfiltered ("\n");
// OBSOLETE   pcr_tmp = FPA_PCR_CC;
// OBSOLETE   printf_unfiltered ("\tCC= %#x", pcr_tmp);
// OBSOLETE   if (pcr_tmp & FPA_PCR_20MHZ)
// OBSOLETE     printf_unfiltered (" 20MHZ");
// OBSOLETE   if (pcr_tmp & FPA_PCR_CC_Z)
// OBSOLETE     printf_unfiltered (" Z");
// OBSOLETE   if (pcr_tmp & FPA_PCR_CC_C2)
// OBSOLETE     printf_unfiltered (" C2");
// OBSOLETE 
// OBSOLETE   /* Dynix defines FPA_PCR_CC_C0 to 0x100 and ptx defines
// OBSOLETE      FPA_PCR_CC_C1 to 0x100.  Use whichever is defined and assume
// OBSOLETE      the OS knows what it is doing.  */
// OBSOLETE #ifdef FPA_PCR_CC_C1
// OBSOLETE   if (pcr_tmp & FPA_PCR_CC_C1)
// OBSOLETE     printf_unfiltered (" C1");
// OBSOLETE #else
// OBSOLETE   if (pcr_tmp & FPA_PCR_CC_C0)
// OBSOLETE     printf_unfiltered (" C0");
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   switch (pcr_tmp)
// OBSOLETE     {
// OBSOLETE     case FPA_PCR_CC_Z:
// OBSOLETE       printf_unfiltered (" (Equal)");
// OBSOLETE       break;
// OBSOLETE #ifdef FPA_PCR_CC_C1
// OBSOLETE     case FPA_PCR_CC_C1:
// OBSOLETE #else
// OBSOLETE     case FPA_PCR_CC_C0:
// OBSOLETE #endif
// OBSOLETE       printf_unfiltered (" (Less than)");
// OBSOLETE       break;
// OBSOLETE     case 0:
// OBSOLETE       printf_unfiltered (" (Greater than)");
// OBSOLETE       break;
// OBSOLETE       case FPA_PCR_CC_Z |
// OBSOLETE #ifdef FPA_PCR_CC_C1
// OBSOLETE 	FPA_PCR_CC_C1
// OBSOLETE #else
// OBSOLETE 	FPA_PCR_CC_C0
// OBSOLETE #endif
// OBSOLETE     | FPA_PCR_CC_C2:
// OBSOLETE       printf_unfiltered (" (Unordered)");
// OBSOLETE       break;
// OBSOLETE     default:
// OBSOLETE       printf_unfiltered (" (Undefined)");
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE   printf_unfiltered ("\n");
// OBSOLETE   pcr_tmp = pcr & FPA_PCR_AE;
// OBSOLETE   printf_unfiltered ("\tAE= %#x", pcr_tmp);
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_DE)
// OBSOLETE     printf_unfiltered (" DE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_UOE)
// OBSOLETE     printf_unfiltered (" UOE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_PE)
// OBSOLETE     printf_unfiltered (" PE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_UE)
// OBSOLETE     printf_unfiltered (" UE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_OE)
// OBSOLETE     printf_unfiltered (" OE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_ZE)
// OBSOLETE     printf_unfiltered (" ZE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_EE)
// OBSOLETE     printf_unfiltered (" EE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_IE)
// OBSOLETE     printf_unfiltered (" IE");
// OBSOLETE   printf_unfiltered ("\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE print_1167_regs (long regs[FPA_NREGS])
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   union
// OBSOLETE     {
// OBSOLETE       double d;
// OBSOLETE       long l[2];
// OBSOLETE     }
// OBSOLETE   xd;
// OBSOLETE   union
// OBSOLETE     {
// OBSOLETE       float f;
// OBSOLETE       long l;
// OBSOLETE     }
// OBSOLETE   xf;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   for (i = 0; i < FPA_NREGS; i++)
// OBSOLETE     {
// OBSOLETE       xf.l = regs[i];
// OBSOLETE       printf_unfiltered ("%%fp%d: raw= %#x, single= %f", i + 1, regs[i], xf.f);
// OBSOLETE       if (!(i & 1))
// OBSOLETE 	{
// OBSOLETE 	  printf_unfiltered ("\n");
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  xd.l[1] = regs[i];
// OBSOLETE 	  xd.l[0] = regs[i + 1];
// OBSOLETE 	  printf_unfiltered (", double= %f\n", xd.d);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE print_fpa_status (struct pt_regset ep)
// OBSOLETE {
// OBSOLETE 
// OBSOLETE   printf_unfiltered ("WTL 1167:");
// OBSOLETE   if (ep.pr_fpa.fpa_pcr != 0)
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("\n");
// OBSOLETE       print_1167_control_word (ep.pr_fpa.fpa_pcr);
// OBSOLETE       print_1167_regs (ep.pr_fpa.fpa_regs);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       printf_unfiltered (" not in use.\n");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0				/* disabled because it doesn't go through the target vector.  */
// OBSOLETE i386_float_info (void)
// OBSOLETE {
// OBSOLETE   char ubuf[UPAGES * NBPG];
// OBSOLETE   struct pt_regset regset;
// OBSOLETE 
// OBSOLETE   if (have_inferior_p ())
// OBSOLETE     {
// OBSOLETE       PTRACE_READ_REGS (PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regset);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       int corechan = bfd_cache_lookup (core_bfd);
// OBSOLETE       if (lseek (corechan, 0, 0) < 0)
// OBSOLETE 	{
// OBSOLETE 	  perror ("seek on core file");
// OBSOLETE 	}
// OBSOLETE       if (myread (corechan, ubuf, UPAGES * NBPG) < 0)
// OBSOLETE 	{
// OBSOLETE 	  perror ("read on core file");
// OBSOLETE 	}
// OBSOLETE       /* only interested in the floating point registers */
// OBSOLETE       regset.pr_fpu = ((struct user *) ubuf)->u_fpusave;
// OBSOLETE       regset.pr_fpa = ((struct user *) ubuf)->u_fpasave;
// OBSOLETE     }
// OBSOLETE   print_fpu_status (regset);
// OBSOLETE   print_fpa_status (regset);
// OBSOLETE }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE static volatile int got_sigchld;
// OBSOLETE 
// OBSOLETE /*ARGSUSED */
// OBSOLETE /* This will eventually be more interesting. */
// OBSOLETE void
// OBSOLETE sigchld_handler (int signo)
// OBSOLETE {
// OBSOLETE   got_sigchld++;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Signals for which the default action does not cause the process
// OBSOLETE  * to die.  See <sys/signal.h> for where this came from (alas, we
// OBSOLETE  * can't use those macros directly)
// OBSOLETE  */
// OBSOLETE #ifndef sigmask
// OBSOLETE #define sigmask(s) (1 << ((s) - 1))
// OBSOLETE #endif
// OBSOLETE #define SIGNALS_DFL_SAFE sigmask(SIGSTOP) | sigmask(SIGTSTP) | \
// OBSOLETE 	sigmask(SIGTTIN) | sigmask(SIGTTOU) | sigmask(SIGCHLD) | \
// OBSOLETE 	sigmask(SIGCONT) | sigmask(SIGWINCH) | sigmask(SIGPWR) | \
// OBSOLETE 	sigmask(SIGURG) | sigmask(SIGPOLL)
// OBSOLETE 
// OBSOLETE #ifdef ATTACH_DETACH
// OBSOLETE /*
// OBSOLETE  * Thanks to XPT_MPDEBUGGER, we have to mange child_wait().
// OBSOLETE  */
// OBSOLETE ptid_t
// OBSOLETE child_wait (ptid_t ptid, struct target_waitstatus *status)
// OBSOLETE {
// OBSOLETE   int save_errno, rv, xvaloff, saoff, sa_hand;
// OBSOLETE   struct pt_stop pt;
// OBSOLETE   struct user u;
// OBSOLETE   sigset_t set;
// OBSOLETE   /* Host signal number for a signal which the inferior terminates with, or
// OBSOLETE      0 if it hasn't terminated due to a signal.  */
// OBSOLETE   static int death_by_signal = 0;
// OBSOLETE #ifdef SVR4_SHARED_LIBS		/* use this to distinguish ptx 2 vs ptx 4 */
// OBSOLETE   prstatus_t pstatus;
// OBSOLETE #endif
// OBSOLETE   int pid = PIDGET (ptid);
// OBSOLETE 
// OBSOLETE   do
// OBSOLETE     {
// OBSOLETE       set_sigint_trap ();	/* Causes SIGINT to be passed on to the
// OBSOLETE 				   attached process. */
// OBSOLETE       save_errno = errno;
// OBSOLETE 
// OBSOLETE       got_sigchld = 0;
// OBSOLETE 
// OBSOLETE       sigemptyset (&set);
// OBSOLETE 
// OBSOLETE       while (got_sigchld == 0)
// OBSOLETE 	{
// OBSOLETE 	  sigsuspend (&set);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       clear_sigint_trap ();
// OBSOLETE 
// OBSOLETE       rv = mptrace (XPT_STOPSTAT, 0, (char *) &pt, 0);
// OBSOLETE       if (-1 == rv)
// OBSOLETE 	{
// OBSOLETE 	  printf ("XPT_STOPSTAT: errno %d\n", errno);	/* DEBUG */
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       pid = pt.ps_pid;
// OBSOLETE 
// OBSOLETE       if (pid != PIDGET (inferior_ptid))
// OBSOLETE 	{
// OBSOLETE 	  /* NOTE: the mystery fork in csh/tcsh needs to be ignored.
// OBSOLETE 	   * We should not return new children for the initial run
// OBSOLETE 	   * of a process until it has done the exec.
// OBSOLETE 	   */
// OBSOLETE 	  /* inferior probably forked; send it on its way */
// OBSOLETE 	  rv = mptrace (XPT_UNDEBUG, pid, 0, 0);
// OBSOLETE 	  if (-1 == rv)
// OBSOLETE 	    {
// OBSOLETE 	      printf ("child_wait: XPT_UNDEBUG: pid %d: %s\n", pid,
// OBSOLETE 		      safe_strerror (errno));
// OBSOLETE 	    }
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE       /* FIXME: Do we deal with fork notification correctly?  */
// OBSOLETE       switch (pt.ps_reason)
// OBSOLETE 	{
// OBSOLETE 	case PTS_FORK:
// OBSOLETE 	  /* multi proc: treat like PTS_EXEC */
// OBSOLETE 	  /*
// OBSOLETE 	   * Pretend this didn't happen, since gdb isn't set up
// OBSOLETE 	   * to deal with stops on fork.
// OBSOLETE 	   */
// OBSOLETE 	  rv = ptrace (PT_CONTSIG, pid, 1, 0);
// OBSOLETE 	  if (-1 == rv)
// OBSOLETE 	    {
// OBSOLETE 	      printf ("PTS_FORK: PT_CONTSIG: error %d\n", errno);
// OBSOLETE 	    }
// OBSOLETE 	  continue;
// OBSOLETE 	case PTS_EXEC:
// OBSOLETE 	  /*
// OBSOLETE 	   * Pretend this is a SIGTRAP.
// OBSOLETE 	   */
// OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE 	  status->value.sig = TARGET_SIGNAL_TRAP;
// OBSOLETE 	  break;
// OBSOLETE 	case PTS_EXIT:
// OBSOLETE 	  /*
// OBSOLETE 	   * Note: we stop before the exit actually occurs.  Extract
// OBSOLETE 	   * the exit code from the uarea.  If we're stopped in the
// OBSOLETE 	   * exit() system call, the exit code will be in
// OBSOLETE 	   * u.u_ap[0].  An exit due to an uncaught signal will have
// OBSOLETE 	   * something else in here, see the comment in the default:
// OBSOLETE 	   * case, below.  Finally,let the process exit.
// OBSOLETE 	   */
// OBSOLETE 	  if (death_by_signal)
// OBSOLETE 	    {
// OBSOLETE 	      status->kind = TARGET_WAITKIND_SIGNALED;
// OBSOLETE 	      status->value.sig = target_signal_from_host (death_by_signal);
// OBSOLETE 	      death_by_signal = 0;
// OBSOLETE 	      break;
// OBSOLETE 	    }
// OBSOLETE 	  xvaloff = (unsigned long) &u.u_ap[0] - (unsigned long) &u;
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  rv = ptrace (PT_RUSER, pid, (char *) xvaloff, 0);
// OBSOLETE 	  status->kind = TARGET_WAITKIND_EXITED;
// OBSOLETE 	  status->value.integer = rv;
// OBSOLETE 	  /*
// OBSOLETE 	   * addr & data to mptrace() don't matter here, since
// OBSOLETE 	   * the process is already dead.
// OBSOLETE 	   */
// OBSOLETE 	  rv = mptrace (XPT_UNDEBUG, pid, 0, 0);
// OBSOLETE 	  if (-1 == rv)
// OBSOLETE 	    {
// OBSOLETE 	      printf ("child_wait: PTS_EXIT: XPT_UNDEBUG: pid %d error %d\n", pid,
// OBSOLETE 		      errno);
// OBSOLETE 	    }
// OBSOLETE 	  break;
// OBSOLETE 	case PTS_WATCHPT_HIT:
// OBSOLETE 	  internal_error (__FILE__, __LINE__,
// OBSOLETE 			  "PTS_WATCHPT_HIT\n");
// OBSOLETE 	  break;
// OBSOLETE 	default:
// OBSOLETE 	  /* stopped by signal */
// OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE 	  status->value.sig = target_signal_from_host (pt.ps_reason);
// OBSOLETE 	  death_by_signal = 0;
// OBSOLETE 
// OBSOLETE 	  if (0 == (SIGNALS_DFL_SAFE & sigmask (pt.ps_reason)))
// OBSOLETE 	    {
// OBSOLETE 	      break;
// OBSOLETE 	    }
// OBSOLETE 	  /* else default action of signal is to die */
// OBSOLETE #ifdef SVR4_SHARED_LIBS
// OBSOLETE 	  rv = ptrace (PT_GET_PRSTATUS, pid, (char *) &pstatus, 0);
// OBSOLETE 	  if (-1 == rv)
// OBSOLETE 	    error ("child_wait: signal %d PT_GET_PRSTATUS: %s\n",
// OBSOLETE 		   pt.ps_reason, safe_strerror (errno));
// OBSOLETE 	  if (pstatus.pr_cursig != pt.ps_reason)
// OBSOLETE 	    {
// OBSOLETE 	      printf ("pstatus signal %d, pt signal %d\n",
// OBSOLETE 		      pstatus.pr_cursig, pt.ps_reason);
// OBSOLETE 	    }
// OBSOLETE 	  sa_hand = (int) pstatus.pr_action.sa_handler;
// OBSOLETE #else
// OBSOLETE 	  saoff = (unsigned long) &u.u_sa[0] - (unsigned long) &u;
// OBSOLETE 	  saoff += sizeof (struct sigaction) * (pt.ps_reason - 1);
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  sa_hand = ptrace (PT_RUSER, pid, (char *) saoff, 0);
// OBSOLETE 	  if (errno)
// OBSOLETE 	    error ("child_wait: signal %d: RUSER: %s\n",
// OBSOLETE 		   pt.ps_reason, safe_strerror (errno));
// OBSOLETE #endif
// OBSOLETE 	  if ((int) SIG_DFL == sa_hand)
// OBSOLETE 	    {
// OBSOLETE 	      /* we will be dying */
// OBSOLETE 	      death_by_signal = pt.ps_reason;
// OBSOLETE 	    }
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE     }
// OBSOLETE   while (pid != PIDGET (inferior_ptid));	/* Some other child died or stopped */
// OBSOLETE 
// OBSOLETE   return pid_to_ptid (pid);
// OBSOLETE }
// OBSOLETE #else /* !ATTACH_DETACH */
// OBSOLETE /*
// OBSOLETE  * Simple child_wait() based on inftarg.c child_wait() for use until
// OBSOLETE  * the MPDEBUGGER child_wait() works properly.  This will go away when
// OBSOLETE  * that is fixed.
// OBSOLETE  */
// OBSOLETE ptid_t
// OBSOLETE child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
// OBSOLETE {
// OBSOLETE   int save_errno;
// OBSOLETE   int status;
// OBSOLETE   int pid = PIDGET (ptid);
// OBSOLETE 
// OBSOLETE   do
// OBSOLETE     {
// OBSOLETE       pid = wait (&status);
// OBSOLETE       save_errno = errno;
// OBSOLETE 
// OBSOLETE       if (pid == -1)
// OBSOLETE 	{
// OBSOLETE 	  if (save_errno == EINTR)
// OBSOLETE 	    continue;
// OBSOLETE 	  fprintf (stderr, "Child process unexpectedly missing: %s.\n",
// OBSOLETE 		   safe_strerror (save_errno));
// OBSOLETE 	  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
// OBSOLETE 	  ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
// OBSOLETE 	  return pid_to_ptid (-1);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   while (pid != PIDGET (inferior_ptid));	/* Some other child died or stopped */
// OBSOLETE   store_waitstatus (ourstatus, status);
// OBSOLETE   return pid_to_ptid (pid);
// OBSOLETE }
// OBSOLETE #endif /* ATTACH_DETACH */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* This function simply calls ptrace with the given arguments.  
// OBSOLETE    It exists so that all calls to ptrace are isolated in this 
// OBSOLETE    machine-dependent file. */
// OBSOLETE int
// OBSOLETE call_ptrace (int request, int pid, PTRACE_ARG3_TYPE addr, int data)
// OBSOLETE {
// OBSOLETE   return ptrace (request, pid, addr, data);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE call_mptrace (int request, int pid, PTRACE_ARG3_TYPE addr, int data)
// OBSOLETE {
// OBSOLETE   return mptrace (request, pid, addr, data);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if defined (DEBUG_PTRACE)
// OBSOLETE /* For the rest of the file, use an extra level of indirection */
// OBSOLETE /* This lets us breakpoint usefully on call_ptrace. */
// OBSOLETE #define ptrace call_ptrace
// OBSOLETE #define mptrace call_mptrace
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE void
// OBSOLETE kill_inferior (void)
// OBSOLETE {
// OBSOLETE   if (ptid_equal (inferior_ptid, null_ptid))
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   /* For MPDEBUGGER, don't use PT_KILL, since the child will stop
// OBSOLETE      again with a PTS_EXIT.  Just hit him with SIGKILL (so he stops)
// OBSOLETE      and detach. */
// OBSOLETE 
// OBSOLETE   kill (PIDGET (inferior_ptid), SIGKILL);
// OBSOLETE #ifdef ATTACH_DETACH
// OBSOLETE   detach (SIGKILL);
// OBSOLETE #else /* ATTACH_DETACH */
// OBSOLETE   ptrace (PT_KILL, PIDGET (inferior_ptid), 0, 0);
// OBSOLETE   wait ((int *) NULL);
// OBSOLETE #endif /* ATTACH_DETACH */
// OBSOLETE   target_mourn_inferior ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Resume execution of the inferior process.
// OBSOLETE    If STEP is nonzero, single-step it.
// OBSOLETE    If SIGNAL is nonzero, give it that signal.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE child_resume (ptid_t ptid, int step, enum target_signal signal)
// OBSOLETE {
// OBSOLETE   int pid = PIDGET (ptid);
// OBSOLETE 
// OBSOLETE   errno = 0;
// OBSOLETE 
// OBSOLETE   if (pid == -1)
// OBSOLETE     pid = PIDGET (inferior_ptid);
// OBSOLETE 
// OBSOLETE   /* An address of (PTRACE_ARG3_TYPE)1 tells ptrace to continue from where
// OBSOLETE      it was.  (If GDB wanted it to start some other way, we have already
// OBSOLETE      written a new PC value to the child.)
// OBSOLETE 
// OBSOLETE      If this system does not support PT_SSTEP, a higher level function will
// OBSOLETE      have called single_step() to transmute the step request into a
// OBSOLETE      continue request (by setting breakpoints on all possible successor
// OBSOLETE      instructions), so we don't have to worry about that here.  */
// OBSOLETE 
// OBSOLETE   if (step)
// OBSOLETE     ptrace (PT_SSTEP, pid, (PTRACE_ARG3_TYPE) 1, signal);
// OBSOLETE   else
// OBSOLETE     ptrace (PT_CONTSIG, pid, (PTRACE_ARG3_TYPE) 1, signal);
// OBSOLETE 
// OBSOLETE   if (errno)
// OBSOLETE     perror_with_name ("ptrace");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef ATTACH_DETACH
// OBSOLETE /* Start debugging the process whose number is PID.  */
// OBSOLETE int
// OBSOLETE attach (int pid)
// OBSOLETE {
// OBSOLETE   sigset_t set;
// OBSOLETE   int rv;
// OBSOLETE 
// OBSOLETE   rv = mptrace (XPT_DEBUG, pid, 0, 0);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       error ("mptrace(XPT_DEBUG): %s", safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE   rv = mptrace (XPT_SIGNAL, pid, 0, SIGSTOP);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       error ("mptrace(XPT_SIGNAL): %s", safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE   attach_flag = 1;
// OBSOLETE   return pid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE detach (int signo)
// OBSOLETE {
// OBSOLETE   int rv;
// OBSOLETE 
// OBSOLETE   rv = mptrace (XPT_UNDEBUG, PIDGET (inferior_ptid), 1, signo);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       error ("mptrace(XPT_UNDEBUG): %s", safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE   attach_flag = 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* ATTACH_DETACH */
// OBSOLETE 
// OBSOLETE /* Default the type of the ptrace transfer to int.  */
// OBSOLETE #ifndef PTRACE_XFER_TYPE
// OBSOLETE #define PTRACE_XFER_TYPE int
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory
// OBSOLETE    in the NEW_SUN_PTRACE case.
// OBSOLETE    It ought to be straightforward.  But it appears that writing did
// OBSOLETE    not write the data that I specified.  I cannot understand where
// OBSOLETE    it got the data that it actually did write.  */
// OBSOLETE 
// OBSOLETE /* Copy LEN bytes to or from inferior's memory starting at MEMADDR
// OBSOLETE    to debugger memory starting at MYADDR.   Copy to inferior if
// OBSOLETE    WRITE is nonzero.  TARGET is ignored.
// OBSOLETE 
// OBSOLETE    Returns the length copied, which is either the LEN argument or zero.
// OBSOLETE    This xfer function does not do partial moves, since child_ops
// OBSOLETE    doesn't allow memory operations to cross below us in the target stack
// OBSOLETE    anyway.  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE child_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
// OBSOLETE 		   struct mem_attrib *attrib,
// OBSOLETE 		   struct target_ops *target)
// OBSOLETE {
// OBSOLETE   register int i;
// OBSOLETE   /* Round starting address down to longword boundary.  */
// OBSOLETE   register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_XFER_TYPE);
// OBSOLETE   /* Round ending address up; get number of longwords that makes.  */
// OBSOLETE   register int count
// OBSOLETE   = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
// OBSOLETE   / sizeof (PTRACE_XFER_TYPE);
// OBSOLETE   /* Allocate buffer of that many longwords.  */
// OBSOLETE   /* FIXME (alloca): This code, cloned from infptrace.c, is unsafe
// OBSOLETE      because it uses alloca to allocate a buffer of arbitrary size.
// OBSOLETE      For very large xfers, this could crash GDB's stack.  */
// OBSOLETE   register PTRACE_XFER_TYPE *buffer
// OBSOLETE     = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
// OBSOLETE 
// OBSOLETE   if (write)
// OBSOLETE     {
// OBSOLETE       /* Fill start and end extra bytes of buffer with existing memory data.  */
// OBSOLETE 
// OBSOLETE       if (addr != memaddr || len < (int) sizeof (PTRACE_XFER_TYPE))
// OBSOLETE 	{
// OBSOLETE 	  /* Need part of initial word -- fetch it.  */
// OBSOLETE 	  buffer[0] = ptrace (PT_RTEXT, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) addr,
// OBSOLETE 			      0);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (count > 1)		/* FIXME, avoid if even boundary */
// OBSOLETE 	{
// OBSOLETE 	  buffer[count - 1]
// OBSOLETE 	    = ptrace (PT_RTEXT, PIDGET (inferior_ptid),
// OBSOLETE 		      ((PTRACE_ARG3_TYPE)
// OBSOLETE 		       (addr + (count - 1) * sizeof (PTRACE_XFER_TYPE))),
// OBSOLETE 		      0);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Copy data to be written over corresponding part of buffer */
// OBSOLETE 
// OBSOLETE       memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
// OBSOLETE 	      myaddr,
// OBSOLETE 	      len);
// OBSOLETE 
// OBSOLETE       /* Write the entire buffer.  */
// OBSOLETE 
// OBSOLETE       for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
// OBSOLETE 	{
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  ptrace (PT_WDATA, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) addr,
// OBSOLETE 		  buffer[i]);
// OBSOLETE 	  if (errno)
// OBSOLETE 	    {
// OBSOLETE 	      /* Using the appropriate one (I or D) is necessary for
// OBSOLETE 	         Gould NP1, at least.  */
// OBSOLETE 	      errno = 0;
// OBSOLETE 	      ptrace (PT_WTEXT, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) addr,
// OBSOLETE 		      buffer[i]);
// OBSOLETE 	    }
// OBSOLETE 	  if (errno)
// OBSOLETE 	    return 0;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* Read all the longwords */
// OBSOLETE       for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
// OBSOLETE 	{
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  buffer[i] = ptrace (PT_RTEXT, PIDGET (inferior_ptid),
// OBSOLETE 			      (PTRACE_ARG3_TYPE) addr, 0);
// OBSOLETE 	  if (errno)
// OBSOLETE 	    return 0;
// OBSOLETE 	  QUIT;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Copy appropriate bytes out of the buffer.  */
// OBSOLETE       memcpy (myaddr,
// OBSOLETE 	      (char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
// OBSOLETE 	      len);
// OBSOLETE     }
// OBSOLETE   return len;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_symm_nat (void)
// OBSOLETE {
// OBSOLETE #ifdef ATTACH_DETACH
// OBSOLETE /*
// OBSOLETE  * the MPDEBUGGER is necessary for process tree debugging and attach
// OBSOLETE  * to work, but it alters the behavior of debugged processes, so other
// OBSOLETE  * things (at least child_wait()) will have to change to accomodate
// OBSOLETE  * that.
// OBSOLETE  *
// OBSOLETE  * Note that attach is not implemented in dynix 3, and not in ptx
// OBSOLETE  * until version 2.1 of the OS.
// OBSOLETE  */
// OBSOLETE   int rv;
// OBSOLETE   sigset_t set;
// OBSOLETE   struct sigaction sact;
// OBSOLETE 
// OBSOLETE   rv = mptrace (XPT_MPDEBUGGER, 0, 0, 0);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       internal_error (__FILE__, __LINE__,
// OBSOLETE 		      "_initialize_symm_nat(): mptrace(XPT_MPDEBUGGER): %s",
// OBSOLETE 		      safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /*
// OBSOLETE    * Under MPDEBUGGER, we get SIGCLHD when a traced process does
// OBSOLETE    * anything of interest.
// OBSOLETE    */
// OBSOLETE 
// OBSOLETE   /*
// OBSOLETE    * Block SIGCHLD.  We leave it blocked all the time, and then
// OBSOLETE    * call sigsuspend() in child_wait() to wait for the child
// OBSOLETE    * to do something.  None of these ought to fail, but check anyway.
// OBSOLETE    */
// OBSOLETE   sigemptyset (&set);
// OBSOLETE   rv = sigaddset (&set, SIGCHLD);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       internal_error (__FILE__, __LINE__,
// OBSOLETE 		      "_initialize_symm_nat(): sigaddset(SIGCHLD): %s",
// OBSOLETE 		      safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE   rv = sigprocmask (SIG_BLOCK, &set, (sigset_t *) NULL);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       internal_error (__FILE__, __LINE__,
// OBSOLETE 		      "_initialize_symm_nat(): sigprocmask(SIG_BLOCK): %s",
// OBSOLETE 		      safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   sact.sa_handler = sigchld_handler;
// OBSOLETE   sigemptyset (&sact.sa_mask);
// OBSOLETE   sact.sa_flags = SA_NOCLDWAIT;	/* keep the zombies away */
// OBSOLETE   rv = sigaction (SIGCHLD, &sact, (struct sigaction *) NULL);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       internal_error (__FILE__, __LINE__,
// OBSOLETE 		      "_initialize_symm_nat(): sigaction(SIGCHLD): %s",
// OBSOLETE 		      safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE #endif
// OBSOLETE }
@


1.13
log
@2002-11-14  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_registers): Rename registers.
	* a68v-nat.c, alpha-nat.c, arch-utils.c, core-sol2.c: Update.
	* hp300ux-nat.c, hppab-nat.c, hppah-nat.c: Update.
	* hppam3-nat.c, hpux-thread.c, i386gnu-nat.c: Update.
	* ia64-aix-nat.c, ia64-linux-nat.c, ia64-tdep.c: Update.
	* irix4-nat.c, irix5-nat.c, lynx-nat.c, m68k-tdep.c: Update.
	* m68knbsd-nat.c, mips-linux-tdep.c, mipsm3-nat.c: Update.
	* mipsv4-nat.c, ns32knbsd-nat.c, ppc-bdm.c: Update.
	* ppc-sysv-tdep.c, ptx4-nat.c, regcache.c, remote-es.c: Update.
	* remote-sds.c, remote-vx68.c, remote-vxmips.c: Update.
	* remote-vxsparc.c, rs6000-tdep.c, sol-thread.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, symm-nat.c: Update.
	* v850ice.c: Update.
@
text
@d2 3
a4 3
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1999, 2000,
   2001
   Free Software Foundation, Inc.
d37 1
a37 1
#include <sys/wait.h>
@


1.12
log
@2002-11-07  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.c (deprecated_registers_fetched): Update.
	* regcache.h (deprecated_registers_fetched): Rename
	registers_fetched.
	* remote-vxsparc.c (vx_read_register): Update.
	* remote-vxmips.c (vx_read_register): Update.
	* remote-vx68.c (vx_read_register): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* mipsm3-nat.c (fetch_inferior_registers): Update.
	* sun3-nat.c (fetch_inferior_registers): Update.
	* symm-nat.c (fetch_inferior_registers): Update.
	* ns32knbsd-nat.c (fetch_inferior_registers): Update.
	(fetch_core_registers): Update.
	(fetch_kcore_registers): Update.
	* mips-nat.c (fetch_inferior_registers): Update.
	* corelow.c (get_core_registers): Update.
	* a68v-nat.c (fetch_inferior_registers): Update.
@
text
@d71 10
a80 10
  regs.pr_eax = *(int *) &registers[REGISTER_BYTE (0)];
  regs.pr_ebx = *(int *) &registers[REGISTER_BYTE (5)];
  regs.pr_ecx = *(int *) &registers[REGISTER_BYTE (2)];
  regs.pr_edx = *(int *) &registers[REGISTER_BYTE (1)];
  regs.pr_esi = *(int *) &registers[REGISTER_BYTE (6)];
  regs.pr_edi = *(int *) &registers[REGISTER_BYTE (7)];
  regs.pr_esp = *(int *) &registers[REGISTER_BYTE (14)];
  regs.pr_ebp = *(int *) &registers[REGISTER_BYTE (15)];
  regs.pr_eip = *(int *) &registers[REGISTER_BYTE (16)];
  regs.pr_flags = *(int *) &registers[REGISTER_BYTE (17)];
d84 1
a84 1
	*(int *) &registers[REGISTER_BYTE (FP1_REGNUM + i)];
d86 8
a93 8
  memcpy (regs.pr_fpu.fpu_stack[0], &registers[REGISTER_BYTE (ST0_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[1], &registers[REGISTER_BYTE (ST1_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[2], &registers[REGISTER_BYTE (ST2_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[3], &registers[REGISTER_BYTE (ST3_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[4], &registers[REGISTER_BYTE (ST4_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[5], &registers[REGISTER_BYTE (ST5_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[6], &registers[REGISTER_BYTE (ST6_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[7], &registers[REGISTER_BYTE (ST7_REGNUM)], 10);
d106 10
a115 10
  *(int *) &registers[REGISTER_BYTE (EAX_REGNUM)] = regs.pr_eax;
  *(int *) &registers[REGISTER_BYTE (EBX_REGNUM)] = regs.pr_ebx;
  *(int *) &registers[REGISTER_BYTE (ECX_REGNUM)] = regs.pr_ecx;
  *(int *) &registers[REGISTER_BYTE (EDX_REGNUM)] = regs.pr_edx;
  *(int *) &registers[REGISTER_BYTE (ESI_REGNUM)] = regs.pr_esi;
  *(int *) &registers[REGISTER_BYTE (EDI_REGNUM)] = regs.pr_edi;
  *(int *) &registers[REGISTER_BYTE (EBP_REGNUM)] = regs.pr_ebp;
  *(int *) &registers[REGISTER_BYTE (ESP_REGNUM)] = regs.pr_esp;
  *(int *) &registers[REGISTER_BYTE (EIP_REGNUM)] = regs.pr_eip;
  *(int *) &registers[REGISTER_BYTE (EFLAGS_REGNUM)] = regs.pr_flags;
d118 1
a118 1
      *(int *) &registers[REGISTER_BYTE (FP1_REGNUM + i)] =
d121 8
a128 8
  memcpy (&registers[REGISTER_BYTE (ST0_REGNUM)], regs.pr_fpu.fpu_stack[0], 10);
  memcpy (&registers[REGISTER_BYTE (ST1_REGNUM)], regs.pr_fpu.fpu_stack[1], 10);
  memcpy (&registers[REGISTER_BYTE (ST2_REGNUM)], regs.pr_fpu.fpu_stack[2], 10);
  memcpy (&registers[REGISTER_BYTE (ST3_REGNUM)], regs.pr_fpu.fpu_stack[3], 10);
  memcpy (&registers[REGISTER_BYTE (ST4_REGNUM)], regs.pr_fpu.fpu_stack[4], 10);
  memcpy (&registers[REGISTER_BYTE (ST5_REGNUM)], regs.pr_fpu.fpu_stack[5], 10);
  memcpy (&registers[REGISTER_BYTE (ST6_REGNUM)], regs.pr_fpu.fpu_stack[6], 10);
  memcpy (&registers[REGISTER_BYTE (ST7_REGNUM)], regs.pr_fpu.fpu_stack[7], 10);
@


1.11
log
@2002-01-07  Michael Snyder  <msnyder@@redhat.com>

	* infptrace.c (GDB_MAX_ALLOCA): New define.
	(child_xfer_memory): Use xmalloc/xfree instead of alloca if the
	size of the buffer exceeds GDB_MAX_ALLOCA (default 1 megabyte,
	can be overridden with whatever value is appropriate to the host).
	* infttrace.c (child_xfer_memory): Add FIXME warning about use of
	alloca to allocate potentially large buffer.
	* rs6000-nat.c (child_xfer_memory): Ditto.
	* symm-nat.c (child_xfer_memory): Ditto.
	* x86-64-linux-nat.c (child_xfer_memory): Ditto.
@
text
@d103 1
a103 1
  registers_fetched ();
@


1.11.18.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.11.16.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d71 10
a80 10
  regs.pr_eax = *(int *) &deprecated_registers[REGISTER_BYTE (0)];
  regs.pr_ebx = *(int *) &deprecated_registers[REGISTER_BYTE (5)];
  regs.pr_ecx = *(int *) &deprecated_registers[REGISTER_BYTE (2)];
  regs.pr_edx = *(int *) &deprecated_registers[REGISTER_BYTE (1)];
  regs.pr_esi = *(int *) &deprecated_registers[REGISTER_BYTE (6)];
  regs.pr_edi = *(int *) &deprecated_registers[REGISTER_BYTE (7)];
  regs.pr_esp = *(int *) &deprecated_registers[REGISTER_BYTE (14)];
  regs.pr_ebp = *(int *) &deprecated_registers[REGISTER_BYTE (15)];
  regs.pr_eip = *(int *) &deprecated_registers[REGISTER_BYTE (16)];
  regs.pr_flags = *(int *) &deprecated_registers[REGISTER_BYTE (17)];
d84 1
a84 1
	*(int *) &deprecated_registers[REGISTER_BYTE (FP1_REGNUM + i)];
d86 8
a93 8
  memcpy (regs.pr_fpu.fpu_stack[0], &deprecated_registers[REGISTER_BYTE (ST0_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[1], &deprecated_registers[REGISTER_BYTE (ST1_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[2], &deprecated_registers[REGISTER_BYTE (ST2_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[3], &deprecated_registers[REGISTER_BYTE (ST3_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[4], &deprecated_registers[REGISTER_BYTE (ST4_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[5], &deprecated_registers[REGISTER_BYTE (ST5_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[6], &deprecated_registers[REGISTER_BYTE (ST6_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[7], &deprecated_registers[REGISTER_BYTE (ST7_REGNUM)], 10);
d103 1
a103 1
  deprecated_registers_fetched ();
d106 10
a115 10
  *(int *) &deprecated_registers[REGISTER_BYTE (EAX_REGNUM)] = regs.pr_eax;
  *(int *) &rdeprecated_egisters[REGISTER_BYTE (EBX_REGNUM)] = regs.pr_ebx;
  *(int *) &deprecated_registers[REGISTER_BYTE (ECX_REGNUM)] = regs.pr_ecx;
  *(int *) &deprecated_registers[REGISTER_BYTE (EDX_REGNUM)] = regs.pr_edx;
  *(int *) &deprecated_registers[REGISTER_BYTE (ESI_REGNUM)] = regs.pr_esi;
  *(int *) &deprecated_registers[REGISTER_BYTE (EDI_REGNUM)] = regs.pr_edi;
  *(int *) &deprecated_registers[REGISTER_BYTE (EBP_REGNUM)] = regs.pr_ebp;
  *(int *) &deprecated_registers[REGISTER_BYTE (ESP_REGNUM)] = regs.pr_esp;
  *(int *) &deprecated_registers[REGISTER_BYTE (EIP_REGNUM)] = regs.pr_eip;
  *(int *) &deprecated_registers[REGISTER_BYTE (EFLAGS_REGNUM)] = regs.pr_flags;
d118 1
a118 1
      *(int *) &deprecated_registers[REGISTER_BYTE (FP1_REGNUM + i)] =
d121 8
a128 8
  memcpy (&deprecated_registers[REGISTER_BYTE (ST0_REGNUM)], regs.pr_fpu.fpu_stack[0], 10);
  memcpy (&deprecated_registers[REGISTER_BYTE (ST1_REGNUM)], regs.pr_fpu.fpu_stack[1], 10);
  memcpy (&deprecated_registers[REGISTER_BYTE (ST2_REGNUM)], regs.pr_fpu.fpu_stack[2], 10);
  memcpy (&deprecated_registers[REGISTER_BYTE (ST3_REGNUM)], regs.pr_fpu.fpu_stack[3], 10);
  memcpy (&deprecated_registers[REGISTER_BYTE (ST4_REGNUM)], regs.pr_fpu.fpu_stack[4], 10);
  memcpy (&deprecated_registers[REGISTER_BYTE (ST5_REGNUM)], regs.pr_fpu.fpu_stack[5], 10);
  memcpy (&deprecated_registers[REGISTER_BYTE (ST6_REGNUM)], regs.pr_fpu.fpu_stack[6], 10);
  memcpy (&deprecated_registers[REGISTER_BYTE (ST7_REGNUM)], regs.pr_fpu.fpu_stack[7], 10);
@


1.11.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 3
a4 3

   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1999,
   2000, 2001, 2003 Free Software Foundation, Inc.
d37 1
a37 1
#include "gdb_wait.h"
@


1.11.16.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d1 902
a902 902
// OBSOLETE /* Sequent Symmetry host interface, for GDB when running under Unix.
// OBSOLETE 
// OBSOLETE    Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1999,
// OBSOLETE    2000, 2001, 2003 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /* FIXME, some 387-specific items of use taken from i387-tdep.c -- ought to be
// OBSOLETE    merged back in. */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE /* FIXME: What is the _INKERNEL define for?  */
// OBSOLETE #define _INKERNEL
// OBSOLETE #include <signal.h>
// OBSOLETE #undef _INKERNEL
// OBSOLETE #include "gdb_wait.h"
// OBSOLETE #include <sys/param.h>
// OBSOLETE #include <sys/user.h>
// OBSOLETE #include <sys/proc.h>
// OBSOLETE #include <sys/dir.h>
// OBSOLETE #include <sys/ioctl.h>
// OBSOLETE #include "gdb_stat.h"
// OBSOLETE #ifdef _SEQUENT_
// OBSOLETE #include <sys/ptrace.h>
// OBSOLETE #else
// OBSOLETE /* Dynix has only machine/ptrace.h, which is already included by sys/user.h  */
// OBSOLETE /* Dynix has no mptrace call */
// OBSOLETE #define mptrace ptrace
// OBSOLETE #endif
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include <fcntl.h>
// OBSOLETE #include <sgtty.h>
// OBSOLETE #define TERMINAL struct sgttyb
// OBSOLETE 
// OBSOLETE #include "gdbcore.h"
// OBSOLETE 
// OBSOLETE void
// OBSOLETE store_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   struct pt_regset regs;
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   /* FIXME: Fetching the registers is a kludge to initialize all elements
// OBSOLETE      in the fpu and fpa status. This works for normal debugging, but
// OBSOLETE      might cause problems when calling functions in the inferior.
// OBSOLETE      At least fpu_control and fpa_pcr (probably more) should be added 
// OBSOLETE      to the registers array to solve this properly.  */
// OBSOLETE   mptrace (XPT_RREGS, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regs, 0);
// OBSOLETE 
// OBSOLETE   regs.pr_eax = *(int *) &deprecated_registers[REGISTER_BYTE (0)];
// OBSOLETE   regs.pr_ebx = *(int *) &deprecated_registers[REGISTER_BYTE (5)];
// OBSOLETE   regs.pr_ecx = *(int *) &deprecated_registers[REGISTER_BYTE (2)];
// OBSOLETE   regs.pr_edx = *(int *) &deprecated_registers[REGISTER_BYTE (1)];
// OBSOLETE   regs.pr_esi = *(int *) &deprecated_registers[REGISTER_BYTE (6)];
// OBSOLETE   regs.pr_edi = *(int *) &deprecated_registers[REGISTER_BYTE (7)];
// OBSOLETE   regs.pr_esp = *(int *) &deprecated_registers[REGISTER_BYTE (14)];
// OBSOLETE   regs.pr_ebp = *(int *) &deprecated_registers[REGISTER_BYTE (15)];
// OBSOLETE   regs.pr_eip = *(int *) &deprecated_registers[REGISTER_BYTE (16)];
// OBSOLETE   regs.pr_flags = *(int *) &deprecated_registers[REGISTER_BYTE (17)];
// OBSOLETE   for (i = 0; i < 31; i++)
// OBSOLETE     {
// OBSOLETE       regs.pr_fpa.fpa_regs[i] =
// OBSOLETE 	*(int *) &deprecated_registers[REGISTER_BYTE (FP1_REGNUM + i)];
// OBSOLETE     }
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[0], &deprecated_registers[REGISTER_BYTE (ST0_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[1], &deprecated_registers[REGISTER_BYTE (ST1_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[2], &deprecated_registers[REGISTER_BYTE (ST2_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[3], &deprecated_registers[REGISTER_BYTE (ST3_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[4], &deprecated_registers[REGISTER_BYTE (ST4_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[5], &deprecated_registers[REGISTER_BYTE (ST5_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[6], &deprecated_registers[REGISTER_BYTE (ST6_REGNUM)], 10);
// OBSOLETE   memcpy (regs.pr_fpu.fpu_stack[7], &deprecated_registers[REGISTER_BYTE (ST7_REGNUM)], 10);
// OBSOLETE   mptrace (XPT_WREGS, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regs, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fetch_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   struct pt_regset regs;
// OBSOLETE 
// OBSOLETE   deprecated_registers_fetched ();
// OBSOLETE 
// OBSOLETE   mptrace (XPT_RREGS, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regs, 0);
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EAX_REGNUM)] = regs.pr_eax;
// OBSOLETE   *(int *) &rdeprecated_egisters[REGISTER_BYTE (EBX_REGNUM)] = regs.pr_ebx;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (ECX_REGNUM)] = regs.pr_ecx;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EDX_REGNUM)] = regs.pr_edx;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (ESI_REGNUM)] = regs.pr_esi;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EDI_REGNUM)] = regs.pr_edi;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EBP_REGNUM)] = regs.pr_ebp;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (ESP_REGNUM)] = regs.pr_esp;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EIP_REGNUM)] = regs.pr_eip;
// OBSOLETE   *(int *) &deprecated_registers[REGISTER_BYTE (EFLAGS_REGNUM)] = regs.pr_flags;
// OBSOLETE   for (i = 0; i < FPA_NREGS; i++)
// OBSOLETE     {
// OBSOLETE       *(int *) &deprecated_registers[REGISTER_BYTE (FP1_REGNUM + i)] =
// OBSOLETE 	regs.pr_fpa.fpa_regs[i];
// OBSOLETE     }
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST0_REGNUM)], regs.pr_fpu.fpu_stack[0], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST1_REGNUM)], regs.pr_fpu.fpu_stack[1], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST2_REGNUM)], regs.pr_fpu.fpu_stack[2], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST3_REGNUM)], regs.pr_fpu.fpu_stack[3], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST4_REGNUM)], regs.pr_fpu.fpu_stack[4], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST5_REGNUM)], regs.pr_fpu.fpu_stack[5], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST6_REGNUM)], regs.pr_fpu.fpu_stack[6], 10);
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (ST7_REGNUM)], regs.pr_fpu.fpu_stack[7], 10);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* FIXME:  This should be merged with i387-tdep.c as well. */
// OBSOLETE static
// OBSOLETE print_fpu_status (struct pt_regset ep)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   int bothstatus;
// OBSOLETE   int top;
// OBSOLETE   int fpreg;
// OBSOLETE   unsigned char *p;
// OBSOLETE 
// OBSOLETE   printf_unfiltered ("80387:");
// OBSOLETE   if (ep.pr_fpu.fpu_ip == 0)
// OBSOLETE     {
// OBSOLETE       printf_unfiltered (" not in use.\n");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("\n");
// OBSOLETE     }
// OBSOLETE   if (ep.pr_fpu.fpu_status != 0)
// OBSOLETE     {
// OBSOLETE       print_387_status_word (ep.pr_fpu.fpu_status);
// OBSOLETE     }
// OBSOLETE   print_387_control_word (ep.pr_fpu.fpu_control);
// OBSOLETE   printf_unfiltered ("last exception: ");
// OBSOLETE   printf_unfiltered ("opcode 0x%x; ", ep.pr_fpu.fpu_rsvd4);
// OBSOLETE   printf_unfiltered ("pc 0x%x:0x%x; ", ep.pr_fpu.fpu_cs, ep.pr_fpu.fpu_ip);
// OBSOLETE   printf_unfiltered ("operand 0x%x:0x%x\n", ep.pr_fpu.fpu_data_offset, ep.pr_fpu.fpu_op_sel);
// OBSOLETE 
// OBSOLETE   top = (ep.pr_fpu.fpu_status >> 11) & 7;
// OBSOLETE 
// OBSOLETE   printf_unfiltered ("regno  tag  msb              lsb  value\n");
// OBSOLETE   for (fpreg = 7; fpreg >= 0; fpreg--)
// OBSOLETE     {
// OBSOLETE       double val;
// OBSOLETE 
// OBSOLETE       printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg);
// OBSOLETE 
// OBSOLETE       switch ((ep.pr_fpu.fpu_tag >> (fpreg * 2)) & 3)
// OBSOLETE 	{
// OBSOLETE 	case 0:
// OBSOLETE 	  printf_unfiltered ("valid ");
// OBSOLETE 	  break;
// OBSOLETE 	case 1:
// OBSOLETE 	  printf_unfiltered ("zero  ");
// OBSOLETE 	  break;
// OBSOLETE 	case 2:
// OBSOLETE 	  printf_unfiltered ("trap  ");
// OBSOLETE 	  break;
// OBSOLETE 	case 3:
// OBSOLETE 	  printf_unfiltered ("empty ");
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       for (i = 9; i >= 0; i--)
// OBSOLETE 	printf_unfiltered ("%02x", ep.pr_fpu.fpu_stack[fpreg][i]);
// OBSOLETE 
// OBSOLETE       i387_to_double ((char *) ep.pr_fpu.fpu_stack[fpreg], (char *) &val);
// OBSOLETE       printf_unfiltered ("  %g\n", val);
// OBSOLETE     }
// OBSOLETE   if (ep.pr_fpu.fpu_rsvd1)
// OBSOLETE     warning ("rsvd1 is 0x%x\n", ep.pr_fpu.fpu_rsvd1);
// OBSOLETE   if (ep.pr_fpu.fpu_rsvd2)
// OBSOLETE     warning ("rsvd2 is 0x%x\n", ep.pr_fpu.fpu_rsvd2);
// OBSOLETE   if (ep.pr_fpu.fpu_rsvd3)
// OBSOLETE     warning ("rsvd3 is 0x%x\n", ep.pr_fpu.fpu_rsvd3);
// OBSOLETE   if (ep.pr_fpu.fpu_rsvd5)
// OBSOLETE     warning ("rsvd5 is 0x%x\n", ep.pr_fpu.fpu_rsvd5);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE print_1167_control_word (unsigned int pcr)
// OBSOLETE {
// OBSOLETE   int pcr_tmp;
// OBSOLETE 
// OBSOLETE   pcr_tmp = pcr & FPA_PCR_MODE;
// OBSOLETE   printf_unfiltered ("\tMODE= %#x; RND= %#x ", pcr_tmp, pcr_tmp & 12);
// OBSOLETE   switch (pcr_tmp & 12)
// OBSOLETE     {
// OBSOLETE     case 0:
// OBSOLETE       printf_unfiltered ("RN (Nearest Value)");
// OBSOLETE       break;
// OBSOLETE     case 1:
// OBSOLETE       printf_unfiltered ("RZ (Zero)");
// OBSOLETE       break;
// OBSOLETE     case 2:
// OBSOLETE       printf_unfiltered ("RP (Positive Infinity)");
// OBSOLETE       break;
// OBSOLETE     case 3:
// OBSOLETE       printf_unfiltered ("RM (Negative Infinity)");
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE   printf_unfiltered ("; IRND= %d ", pcr_tmp & 2);
// OBSOLETE   if (0 == pcr_tmp & 2)
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("(same as RND)\n");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("(toward zero)\n");
// OBSOLETE     }
// OBSOLETE   pcr_tmp = pcr & FPA_PCR_EM;
// OBSOLETE   printf_unfiltered ("\tEM= %#x", pcr_tmp);
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_DM)
// OBSOLETE     printf_unfiltered (" DM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_UOM)
// OBSOLETE     printf_unfiltered (" UOM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_PM)
// OBSOLETE     printf_unfiltered (" PM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_UM)
// OBSOLETE     printf_unfiltered (" UM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_OM)
// OBSOLETE     printf_unfiltered (" OM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_ZM)
// OBSOLETE     printf_unfiltered (" ZM");
// OBSOLETE   if (pcr_tmp & FPA_PCR_EM_IM)
// OBSOLETE     printf_unfiltered (" IM");
// OBSOLETE   printf_unfiltered ("\n");
// OBSOLETE   pcr_tmp = FPA_PCR_CC;
// OBSOLETE   printf_unfiltered ("\tCC= %#x", pcr_tmp);
// OBSOLETE   if (pcr_tmp & FPA_PCR_20MHZ)
// OBSOLETE     printf_unfiltered (" 20MHZ");
// OBSOLETE   if (pcr_tmp & FPA_PCR_CC_Z)
// OBSOLETE     printf_unfiltered (" Z");
// OBSOLETE   if (pcr_tmp & FPA_PCR_CC_C2)
// OBSOLETE     printf_unfiltered (" C2");
// OBSOLETE 
// OBSOLETE   /* Dynix defines FPA_PCR_CC_C0 to 0x100 and ptx defines
// OBSOLETE      FPA_PCR_CC_C1 to 0x100.  Use whichever is defined and assume
// OBSOLETE      the OS knows what it is doing.  */
// OBSOLETE #ifdef FPA_PCR_CC_C1
// OBSOLETE   if (pcr_tmp & FPA_PCR_CC_C1)
// OBSOLETE     printf_unfiltered (" C1");
// OBSOLETE #else
// OBSOLETE   if (pcr_tmp & FPA_PCR_CC_C0)
// OBSOLETE     printf_unfiltered (" C0");
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   switch (pcr_tmp)
// OBSOLETE     {
// OBSOLETE     case FPA_PCR_CC_Z:
// OBSOLETE       printf_unfiltered (" (Equal)");
// OBSOLETE       break;
// OBSOLETE #ifdef FPA_PCR_CC_C1
// OBSOLETE     case FPA_PCR_CC_C1:
// OBSOLETE #else
// OBSOLETE     case FPA_PCR_CC_C0:
// OBSOLETE #endif
// OBSOLETE       printf_unfiltered (" (Less than)");
// OBSOLETE       break;
// OBSOLETE     case 0:
// OBSOLETE       printf_unfiltered (" (Greater than)");
// OBSOLETE       break;
// OBSOLETE       case FPA_PCR_CC_Z |
// OBSOLETE #ifdef FPA_PCR_CC_C1
// OBSOLETE 	FPA_PCR_CC_C1
// OBSOLETE #else
// OBSOLETE 	FPA_PCR_CC_C0
// OBSOLETE #endif
// OBSOLETE     | FPA_PCR_CC_C2:
// OBSOLETE       printf_unfiltered (" (Unordered)");
// OBSOLETE       break;
// OBSOLETE     default:
// OBSOLETE       printf_unfiltered (" (Undefined)");
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE   printf_unfiltered ("\n");
// OBSOLETE   pcr_tmp = pcr & FPA_PCR_AE;
// OBSOLETE   printf_unfiltered ("\tAE= %#x", pcr_tmp);
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_DE)
// OBSOLETE     printf_unfiltered (" DE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_UOE)
// OBSOLETE     printf_unfiltered (" UOE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_PE)
// OBSOLETE     printf_unfiltered (" PE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_UE)
// OBSOLETE     printf_unfiltered (" UE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_OE)
// OBSOLETE     printf_unfiltered (" OE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_ZE)
// OBSOLETE     printf_unfiltered (" ZE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_EE)
// OBSOLETE     printf_unfiltered (" EE");
// OBSOLETE   if (pcr_tmp & FPA_PCR_AE_IE)
// OBSOLETE     printf_unfiltered (" IE");
// OBSOLETE   printf_unfiltered ("\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE print_1167_regs (long regs[FPA_NREGS])
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   union
// OBSOLETE     {
// OBSOLETE       double d;
// OBSOLETE       long l[2];
// OBSOLETE     }
// OBSOLETE   xd;
// OBSOLETE   union
// OBSOLETE     {
// OBSOLETE       float f;
// OBSOLETE       long l;
// OBSOLETE     }
// OBSOLETE   xf;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   for (i = 0; i < FPA_NREGS; i++)
// OBSOLETE     {
// OBSOLETE       xf.l = regs[i];
// OBSOLETE       printf_unfiltered ("%%fp%d: raw= %#x, single= %f", i + 1, regs[i], xf.f);
// OBSOLETE       if (!(i & 1))
// OBSOLETE 	{
// OBSOLETE 	  printf_unfiltered ("\n");
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  xd.l[1] = regs[i];
// OBSOLETE 	  xd.l[0] = regs[i + 1];
// OBSOLETE 	  printf_unfiltered (", double= %f\n", xd.d);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE print_fpa_status (struct pt_regset ep)
// OBSOLETE {
// OBSOLETE 
// OBSOLETE   printf_unfiltered ("WTL 1167:");
// OBSOLETE   if (ep.pr_fpa.fpa_pcr != 0)
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("\n");
// OBSOLETE       print_1167_control_word (ep.pr_fpa.fpa_pcr);
// OBSOLETE       print_1167_regs (ep.pr_fpa.fpa_regs);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       printf_unfiltered (" not in use.\n");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0				/* disabled because it doesn't go through the target vector.  */
// OBSOLETE i386_float_info (void)
// OBSOLETE {
// OBSOLETE   char ubuf[UPAGES * NBPG];
// OBSOLETE   struct pt_regset regset;
// OBSOLETE 
// OBSOLETE   if (have_inferior_p ())
// OBSOLETE     {
// OBSOLETE       PTRACE_READ_REGS (PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) & regset);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       int corechan = bfd_cache_lookup (core_bfd);
// OBSOLETE       if (lseek (corechan, 0, 0) < 0)
// OBSOLETE 	{
// OBSOLETE 	  perror ("seek on core file");
// OBSOLETE 	}
// OBSOLETE       if (myread (corechan, ubuf, UPAGES * NBPG) < 0)
// OBSOLETE 	{
// OBSOLETE 	  perror ("read on core file");
// OBSOLETE 	}
// OBSOLETE       /* only interested in the floating point registers */
// OBSOLETE       regset.pr_fpu = ((struct user *) ubuf)->u_fpusave;
// OBSOLETE       regset.pr_fpa = ((struct user *) ubuf)->u_fpasave;
// OBSOLETE     }
// OBSOLETE   print_fpu_status (regset);
// OBSOLETE   print_fpa_status (regset);
// OBSOLETE }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE static volatile int got_sigchld;
// OBSOLETE 
// OBSOLETE /*ARGSUSED */
// OBSOLETE /* This will eventually be more interesting. */
// OBSOLETE void
// OBSOLETE sigchld_handler (int signo)
// OBSOLETE {
// OBSOLETE   got_sigchld++;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Signals for which the default action does not cause the process
// OBSOLETE  * to die.  See <sys/signal.h> for where this came from (alas, we
// OBSOLETE  * can't use those macros directly)
// OBSOLETE  */
// OBSOLETE #ifndef sigmask
// OBSOLETE #define sigmask(s) (1 << ((s) - 1))
// OBSOLETE #endif
// OBSOLETE #define SIGNALS_DFL_SAFE sigmask(SIGSTOP) | sigmask(SIGTSTP) | \
// OBSOLETE 	sigmask(SIGTTIN) | sigmask(SIGTTOU) | sigmask(SIGCHLD) | \
// OBSOLETE 	sigmask(SIGCONT) | sigmask(SIGWINCH) | sigmask(SIGPWR) | \
// OBSOLETE 	sigmask(SIGURG) | sigmask(SIGPOLL)
// OBSOLETE 
// OBSOLETE #ifdef ATTACH_DETACH
// OBSOLETE /*
// OBSOLETE  * Thanks to XPT_MPDEBUGGER, we have to mange child_wait().
// OBSOLETE  */
// OBSOLETE ptid_t
// OBSOLETE child_wait (ptid_t ptid, struct target_waitstatus *status)
// OBSOLETE {
// OBSOLETE   int save_errno, rv, xvaloff, saoff, sa_hand;
// OBSOLETE   struct pt_stop pt;
// OBSOLETE   struct user u;
// OBSOLETE   sigset_t set;
// OBSOLETE   /* Host signal number for a signal which the inferior terminates with, or
// OBSOLETE      0 if it hasn't terminated due to a signal.  */
// OBSOLETE   static int death_by_signal = 0;
// OBSOLETE #ifdef SVR4_SHARED_LIBS		/* use this to distinguish ptx 2 vs ptx 4 */
// OBSOLETE   prstatus_t pstatus;
// OBSOLETE #endif
// OBSOLETE   int pid = PIDGET (ptid);
// OBSOLETE 
// OBSOLETE   do
// OBSOLETE     {
// OBSOLETE       set_sigint_trap ();	/* Causes SIGINT to be passed on to the
// OBSOLETE 				   attached process. */
// OBSOLETE       save_errno = errno;
// OBSOLETE 
// OBSOLETE       got_sigchld = 0;
// OBSOLETE 
// OBSOLETE       sigemptyset (&set);
// OBSOLETE 
// OBSOLETE       while (got_sigchld == 0)
// OBSOLETE 	{
// OBSOLETE 	  sigsuspend (&set);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       clear_sigint_trap ();
// OBSOLETE 
// OBSOLETE       rv = mptrace (XPT_STOPSTAT, 0, (char *) &pt, 0);
// OBSOLETE       if (-1 == rv)
// OBSOLETE 	{
// OBSOLETE 	  printf ("XPT_STOPSTAT: errno %d\n", errno);	/* DEBUG */
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       pid = pt.ps_pid;
// OBSOLETE 
// OBSOLETE       if (pid != PIDGET (inferior_ptid))
// OBSOLETE 	{
// OBSOLETE 	  /* NOTE: the mystery fork in csh/tcsh needs to be ignored.
// OBSOLETE 	   * We should not return new children for the initial run
// OBSOLETE 	   * of a process until it has done the exec.
// OBSOLETE 	   */
// OBSOLETE 	  /* inferior probably forked; send it on its way */
// OBSOLETE 	  rv = mptrace (XPT_UNDEBUG, pid, 0, 0);
// OBSOLETE 	  if (-1 == rv)
// OBSOLETE 	    {
// OBSOLETE 	      printf ("child_wait: XPT_UNDEBUG: pid %d: %s\n", pid,
// OBSOLETE 		      safe_strerror (errno));
// OBSOLETE 	    }
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE       /* FIXME: Do we deal with fork notification correctly?  */
// OBSOLETE       switch (pt.ps_reason)
// OBSOLETE 	{
// OBSOLETE 	case PTS_FORK:
// OBSOLETE 	  /* multi proc: treat like PTS_EXEC */
// OBSOLETE 	  /*
// OBSOLETE 	   * Pretend this didn't happen, since gdb isn't set up
// OBSOLETE 	   * to deal with stops on fork.
// OBSOLETE 	   */
// OBSOLETE 	  rv = ptrace (PT_CONTSIG, pid, 1, 0);
// OBSOLETE 	  if (-1 == rv)
// OBSOLETE 	    {
// OBSOLETE 	      printf ("PTS_FORK: PT_CONTSIG: error %d\n", errno);
// OBSOLETE 	    }
// OBSOLETE 	  continue;
// OBSOLETE 	case PTS_EXEC:
// OBSOLETE 	  /*
// OBSOLETE 	   * Pretend this is a SIGTRAP.
// OBSOLETE 	   */
// OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE 	  status->value.sig = TARGET_SIGNAL_TRAP;
// OBSOLETE 	  break;
// OBSOLETE 	case PTS_EXIT:
// OBSOLETE 	  /*
// OBSOLETE 	   * Note: we stop before the exit actually occurs.  Extract
// OBSOLETE 	   * the exit code from the uarea.  If we're stopped in the
// OBSOLETE 	   * exit() system call, the exit code will be in
// OBSOLETE 	   * u.u_ap[0].  An exit due to an uncaught signal will have
// OBSOLETE 	   * something else in here, see the comment in the default:
// OBSOLETE 	   * case, below.  Finally,let the process exit.
// OBSOLETE 	   */
// OBSOLETE 	  if (death_by_signal)
// OBSOLETE 	    {
// OBSOLETE 	      status->kind = TARGET_WAITKIND_SIGNALED;
// OBSOLETE 	      status->value.sig = target_signal_from_host (death_by_signal);
// OBSOLETE 	      death_by_signal = 0;
// OBSOLETE 	      break;
// OBSOLETE 	    }
// OBSOLETE 	  xvaloff = (unsigned long) &u.u_ap[0] - (unsigned long) &u;
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  rv = ptrace (PT_RUSER, pid, (char *) xvaloff, 0);
// OBSOLETE 	  status->kind = TARGET_WAITKIND_EXITED;
// OBSOLETE 	  status->value.integer = rv;
// OBSOLETE 	  /*
// OBSOLETE 	   * addr & data to mptrace() don't matter here, since
// OBSOLETE 	   * the process is already dead.
// OBSOLETE 	   */
// OBSOLETE 	  rv = mptrace (XPT_UNDEBUG, pid, 0, 0);
// OBSOLETE 	  if (-1 == rv)
// OBSOLETE 	    {
// OBSOLETE 	      printf ("child_wait: PTS_EXIT: XPT_UNDEBUG: pid %d error %d\n", pid,
// OBSOLETE 		      errno);
// OBSOLETE 	    }
// OBSOLETE 	  break;
// OBSOLETE 	case PTS_WATCHPT_HIT:
// OBSOLETE 	  internal_error (__FILE__, __LINE__,
// OBSOLETE 			  "PTS_WATCHPT_HIT\n");
// OBSOLETE 	  break;
// OBSOLETE 	default:
// OBSOLETE 	  /* stopped by signal */
// OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE 	  status->value.sig = target_signal_from_host (pt.ps_reason);
// OBSOLETE 	  death_by_signal = 0;
// OBSOLETE 
// OBSOLETE 	  if (0 == (SIGNALS_DFL_SAFE & sigmask (pt.ps_reason)))
// OBSOLETE 	    {
// OBSOLETE 	      break;
// OBSOLETE 	    }
// OBSOLETE 	  /* else default action of signal is to die */
// OBSOLETE #ifdef SVR4_SHARED_LIBS
// OBSOLETE 	  rv = ptrace (PT_GET_PRSTATUS, pid, (char *) &pstatus, 0);
// OBSOLETE 	  if (-1 == rv)
// OBSOLETE 	    error ("child_wait: signal %d PT_GET_PRSTATUS: %s\n",
// OBSOLETE 		   pt.ps_reason, safe_strerror (errno));
// OBSOLETE 	  if (pstatus.pr_cursig != pt.ps_reason)
// OBSOLETE 	    {
// OBSOLETE 	      printf ("pstatus signal %d, pt signal %d\n",
// OBSOLETE 		      pstatus.pr_cursig, pt.ps_reason);
// OBSOLETE 	    }
// OBSOLETE 	  sa_hand = (int) pstatus.pr_action.sa_handler;
// OBSOLETE #else
// OBSOLETE 	  saoff = (unsigned long) &u.u_sa[0] - (unsigned long) &u;
// OBSOLETE 	  saoff += sizeof (struct sigaction) * (pt.ps_reason - 1);
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  sa_hand = ptrace (PT_RUSER, pid, (char *) saoff, 0);
// OBSOLETE 	  if (errno)
// OBSOLETE 	    error ("child_wait: signal %d: RUSER: %s\n",
// OBSOLETE 		   pt.ps_reason, safe_strerror (errno));
// OBSOLETE #endif
// OBSOLETE 	  if ((int) SIG_DFL == sa_hand)
// OBSOLETE 	    {
// OBSOLETE 	      /* we will be dying */
// OBSOLETE 	      death_by_signal = pt.ps_reason;
// OBSOLETE 	    }
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE     }
// OBSOLETE   while (pid != PIDGET (inferior_ptid));	/* Some other child died or stopped */
// OBSOLETE 
// OBSOLETE   return pid_to_ptid (pid);
// OBSOLETE }
// OBSOLETE #else /* !ATTACH_DETACH */
// OBSOLETE /*
// OBSOLETE  * Simple child_wait() based on inftarg.c child_wait() for use until
// OBSOLETE  * the MPDEBUGGER child_wait() works properly.  This will go away when
// OBSOLETE  * that is fixed.
// OBSOLETE  */
// OBSOLETE ptid_t
// OBSOLETE child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
// OBSOLETE {
// OBSOLETE   int save_errno;
// OBSOLETE   int status;
// OBSOLETE   int pid = PIDGET (ptid);
// OBSOLETE 
// OBSOLETE   do
// OBSOLETE     {
// OBSOLETE       pid = wait (&status);
// OBSOLETE       save_errno = errno;
// OBSOLETE 
// OBSOLETE       if (pid == -1)
// OBSOLETE 	{
// OBSOLETE 	  if (save_errno == EINTR)
// OBSOLETE 	    continue;
// OBSOLETE 	  fprintf (stderr, "Child process unexpectedly missing: %s.\n",
// OBSOLETE 		   safe_strerror (save_errno));
// OBSOLETE 	  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
// OBSOLETE 	  ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
// OBSOLETE 	  return pid_to_ptid (-1);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   while (pid != PIDGET (inferior_ptid));	/* Some other child died or stopped */
// OBSOLETE   store_waitstatus (ourstatus, status);
// OBSOLETE   return pid_to_ptid (pid);
// OBSOLETE }
// OBSOLETE #endif /* ATTACH_DETACH */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* This function simply calls ptrace with the given arguments.  
// OBSOLETE    It exists so that all calls to ptrace are isolated in this 
// OBSOLETE    machine-dependent file. */
// OBSOLETE int
// OBSOLETE call_ptrace (int request, int pid, PTRACE_ARG3_TYPE addr, int data)
// OBSOLETE {
// OBSOLETE   return ptrace (request, pid, addr, data);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE call_mptrace (int request, int pid, PTRACE_ARG3_TYPE addr, int data)
// OBSOLETE {
// OBSOLETE   return mptrace (request, pid, addr, data);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if defined (DEBUG_PTRACE)
// OBSOLETE /* For the rest of the file, use an extra level of indirection */
// OBSOLETE /* This lets us breakpoint usefully on call_ptrace. */
// OBSOLETE #define ptrace call_ptrace
// OBSOLETE #define mptrace call_mptrace
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE void
// OBSOLETE kill_inferior (void)
// OBSOLETE {
// OBSOLETE   if (ptid_equal (inferior_ptid, null_ptid))
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   /* For MPDEBUGGER, don't use PT_KILL, since the child will stop
// OBSOLETE      again with a PTS_EXIT.  Just hit him with SIGKILL (so he stops)
// OBSOLETE      and detach. */
// OBSOLETE 
// OBSOLETE   kill (PIDGET (inferior_ptid), SIGKILL);
// OBSOLETE #ifdef ATTACH_DETACH
// OBSOLETE   detach (SIGKILL);
// OBSOLETE #else /* ATTACH_DETACH */
// OBSOLETE   ptrace (PT_KILL, PIDGET (inferior_ptid), 0, 0);
// OBSOLETE   wait ((int *) NULL);
// OBSOLETE #endif /* ATTACH_DETACH */
// OBSOLETE   target_mourn_inferior ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Resume execution of the inferior process.
// OBSOLETE    If STEP is nonzero, single-step it.
// OBSOLETE    If SIGNAL is nonzero, give it that signal.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE child_resume (ptid_t ptid, int step, enum target_signal signal)
// OBSOLETE {
// OBSOLETE   int pid = PIDGET (ptid);
// OBSOLETE 
// OBSOLETE   errno = 0;
// OBSOLETE 
// OBSOLETE   if (pid == -1)
// OBSOLETE     pid = PIDGET (inferior_ptid);
// OBSOLETE 
// OBSOLETE   /* An address of (PTRACE_ARG3_TYPE)1 tells ptrace to continue from where
// OBSOLETE      it was.  (If GDB wanted it to start some other way, we have already
// OBSOLETE      written a new PC value to the child.)
// OBSOLETE 
// OBSOLETE      If this system does not support PT_SSTEP, a higher level function will
// OBSOLETE      have called single_step() to transmute the step request into a
// OBSOLETE      continue request (by setting breakpoints on all possible successor
// OBSOLETE      instructions), so we don't have to worry about that here.  */
// OBSOLETE 
// OBSOLETE   if (step)
// OBSOLETE     ptrace (PT_SSTEP, pid, (PTRACE_ARG3_TYPE) 1, signal);
// OBSOLETE   else
// OBSOLETE     ptrace (PT_CONTSIG, pid, (PTRACE_ARG3_TYPE) 1, signal);
// OBSOLETE 
// OBSOLETE   if (errno)
// OBSOLETE     perror_with_name ("ptrace");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef ATTACH_DETACH
// OBSOLETE /* Start debugging the process whose number is PID.  */
// OBSOLETE int
// OBSOLETE attach (int pid)
// OBSOLETE {
// OBSOLETE   sigset_t set;
// OBSOLETE   int rv;
// OBSOLETE 
// OBSOLETE   rv = mptrace (XPT_DEBUG, pid, 0, 0);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       error ("mptrace(XPT_DEBUG): %s", safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE   rv = mptrace (XPT_SIGNAL, pid, 0, SIGSTOP);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       error ("mptrace(XPT_SIGNAL): %s", safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE   attach_flag = 1;
// OBSOLETE   return pid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE detach (int signo)
// OBSOLETE {
// OBSOLETE   int rv;
// OBSOLETE 
// OBSOLETE   rv = mptrace (XPT_UNDEBUG, PIDGET (inferior_ptid), 1, signo);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       error ("mptrace(XPT_UNDEBUG): %s", safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE   attach_flag = 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* ATTACH_DETACH */
// OBSOLETE 
// OBSOLETE /* Default the type of the ptrace transfer to int.  */
// OBSOLETE #ifndef PTRACE_XFER_TYPE
// OBSOLETE #define PTRACE_XFER_TYPE int
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory
// OBSOLETE    in the NEW_SUN_PTRACE case.
// OBSOLETE    It ought to be straightforward.  But it appears that writing did
// OBSOLETE    not write the data that I specified.  I cannot understand where
// OBSOLETE    it got the data that it actually did write.  */
// OBSOLETE 
// OBSOLETE /* Copy LEN bytes to or from inferior's memory starting at MEMADDR
// OBSOLETE    to debugger memory starting at MYADDR.   Copy to inferior if
// OBSOLETE    WRITE is nonzero.  TARGET is ignored.
// OBSOLETE 
// OBSOLETE    Returns the length copied, which is either the LEN argument or zero.
// OBSOLETE    This xfer function does not do partial moves, since child_ops
// OBSOLETE    doesn't allow memory operations to cross below us in the target stack
// OBSOLETE    anyway.  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE child_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
// OBSOLETE 		   struct mem_attrib *attrib,
// OBSOLETE 		   struct target_ops *target)
// OBSOLETE {
// OBSOLETE   register int i;
// OBSOLETE   /* Round starting address down to longword boundary.  */
// OBSOLETE   register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_XFER_TYPE);
// OBSOLETE   /* Round ending address up; get number of longwords that makes.  */
// OBSOLETE   register int count
// OBSOLETE   = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
// OBSOLETE   / sizeof (PTRACE_XFER_TYPE);
// OBSOLETE   /* Allocate buffer of that many longwords.  */
// OBSOLETE   /* FIXME (alloca): This code, cloned from infptrace.c, is unsafe
// OBSOLETE      because it uses alloca to allocate a buffer of arbitrary size.
// OBSOLETE      For very large xfers, this could crash GDB's stack.  */
// OBSOLETE   register PTRACE_XFER_TYPE *buffer
// OBSOLETE     = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
// OBSOLETE 
// OBSOLETE   if (write)
// OBSOLETE     {
// OBSOLETE       /* Fill start and end extra bytes of buffer with existing memory data.  */
// OBSOLETE 
// OBSOLETE       if (addr != memaddr || len < (int) sizeof (PTRACE_XFER_TYPE))
// OBSOLETE 	{
// OBSOLETE 	  /* Need part of initial word -- fetch it.  */
// OBSOLETE 	  buffer[0] = ptrace (PT_RTEXT, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) addr,
// OBSOLETE 			      0);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (count > 1)		/* FIXME, avoid if even boundary */
// OBSOLETE 	{
// OBSOLETE 	  buffer[count - 1]
// OBSOLETE 	    = ptrace (PT_RTEXT, PIDGET (inferior_ptid),
// OBSOLETE 		      ((PTRACE_ARG3_TYPE)
// OBSOLETE 		       (addr + (count - 1) * sizeof (PTRACE_XFER_TYPE))),
// OBSOLETE 		      0);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Copy data to be written over corresponding part of buffer */
// OBSOLETE 
// OBSOLETE       memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
// OBSOLETE 	      myaddr,
// OBSOLETE 	      len);
// OBSOLETE 
// OBSOLETE       /* Write the entire buffer.  */
// OBSOLETE 
// OBSOLETE       for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
// OBSOLETE 	{
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  ptrace (PT_WDATA, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) addr,
// OBSOLETE 		  buffer[i]);
// OBSOLETE 	  if (errno)
// OBSOLETE 	    {
// OBSOLETE 	      /* Using the appropriate one (I or D) is necessary for
// OBSOLETE 	         Gould NP1, at least.  */
// OBSOLETE 	      errno = 0;
// OBSOLETE 	      ptrace (PT_WTEXT, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) addr,
// OBSOLETE 		      buffer[i]);
// OBSOLETE 	    }
// OBSOLETE 	  if (errno)
// OBSOLETE 	    return 0;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* Read all the longwords */
// OBSOLETE       for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
// OBSOLETE 	{
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  buffer[i] = ptrace (PT_RTEXT, PIDGET (inferior_ptid),
// OBSOLETE 			      (PTRACE_ARG3_TYPE) addr, 0);
// OBSOLETE 	  if (errno)
// OBSOLETE 	    return 0;
// OBSOLETE 	  QUIT;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Copy appropriate bytes out of the buffer.  */
// OBSOLETE       memcpy (myaddr,
// OBSOLETE 	      (char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
// OBSOLETE 	      len);
// OBSOLETE     }
// OBSOLETE   return len;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_symm_nat (void)
// OBSOLETE {
// OBSOLETE #ifdef ATTACH_DETACH
// OBSOLETE /*
// OBSOLETE  * the MPDEBUGGER is necessary for process tree debugging and attach
// OBSOLETE  * to work, but it alters the behavior of debugged processes, so other
// OBSOLETE  * things (at least child_wait()) will have to change to accomodate
// OBSOLETE  * that.
// OBSOLETE  *
// OBSOLETE  * Note that attach is not implemented in dynix 3, and not in ptx
// OBSOLETE  * until version 2.1 of the OS.
// OBSOLETE  */
// OBSOLETE   int rv;
// OBSOLETE   sigset_t set;
// OBSOLETE   struct sigaction sact;
// OBSOLETE 
// OBSOLETE   rv = mptrace (XPT_MPDEBUGGER, 0, 0, 0);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       internal_error (__FILE__, __LINE__,
// OBSOLETE 		      "_initialize_symm_nat(): mptrace(XPT_MPDEBUGGER): %s",
// OBSOLETE 		      safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /*
// OBSOLETE    * Under MPDEBUGGER, we get SIGCLHD when a traced process does
// OBSOLETE    * anything of interest.
// OBSOLETE    */
// OBSOLETE 
// OBSOLETE   /*
// OBSOLETE    * Block SIGCHLD.  We leave it blocked all the time, and then
// OBSOLETE    * call sigsuspend() in child_wait() to wait for the child
// OBSOLETE    * to do something.  None of these ought to fail, but check anyway.
// OBSOLETE    */
// OBSOLETE   sigemptyset (&set);
// OBSOLETE   rv = sigaddset (&set, SIGCHLD);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       internal_error (__FILE__, __LINE__,
// OBSOLETE 		      "_initialize_symm_nat(): sigaddset(SIGCHLD): %s",
// OBSOLETE 		      safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE   rv = sigprocmask (SIG_BLOCK, &set, (sigset_t *) NULL);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       internal_error (__FILE__, __LINE__,
// OBSOLETE 		      "_initialize_symm_nat(): sigprocmask(SIG_BLOCK): %s",
// OBSOLETE 		      safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   sact.sa_handler = sigchld_handler;
// OBSOLETE   sigemptyset (&sact.sa_mask);
// OBSOLETE   sact.sa_flags = SA_NOCLDWAIT;	/* keep the zombies away */
// OBSOLETE   rv = sigaction (SIGCHLD, &sact, (struct sigaction *) NULL);
// OBSOLETE   if (-1 == rv)
// OBSOLETE     {
// OBSOLETE       internal_error (__FILE__, __LINE__,
// OBSOLETE 		      "_initialize_symm_nat(): sigaction(SIGCHLD): %s",
// OBSOLETE 		      safe_strerror (errno));
// OBSOLETE     }
// OBSOLETE #endif
// OBSOLETE }
@


1.11.16.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@@


1.10
log
@        * infptrace.c (child_xfer_memory): Add cast to CORE_ADDR.
        * infttrace.c (child_xfer_memory): Likewise.
        * symm-nat.c (child_xfer_memory): Likewise.
        * gdbserver/low-hppabsd.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-linux.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-lynx.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-nbsd.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-sparc.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-sun3.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
@
text
@d767 3
d771 1
a771 1
  = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
@


1.9
log
@Phase 1 of the ptid_t changes.
@
text
@d761 1
a761 1
  register CORE_ADDR addr = memaddr & -sizeof (PTRACE_XFER_TYPE);
@


1.8
log
@Add ``attrib'' parameter to *xfer_memory() functions.
@
text
@d69 1
a69 1
  mptrace (XPT_RREGS, inferior_pid, (PTRACE_ARG3_TYPE) & regs, 0);
d94 1
a94 1
  mptrace (XPT_WREGS, inferior_pid, (PTRACE_ARG3_TYPE) & regs, 0);
d105 1
a105 1
  mptrace (XPT_RREGS, inferior_pid, (PTRACE_ARG3_TYPE) & regs, 0);
d378 1
a378 1
      PTRACE_READ_REGS (inferior_pid, (PTRACE_ARG3_TYPE) & regset);
d427 2
a428 2
int
child_wait (int pid, struct target_waitstatus *status)
d440 1
d468 1
a468 1
      if (pid != inferior_pid)
d581 1
a581 1
  while (pid != inferior_pid);	/* Some other child died or stopped */
d583 1
a583 1
  return pid;
d591 2
a592 1
child_wait (int pid, struct target_waitstatus *ourstatus)
d596 1
d611 1
a611 1
	  return -1;
d614 1
a614 1
  while (pid != inferior_pid);	/* Some other child died or stopped */
d616 1
a616 1
  return pid;
d647 1
a647 1
  if (inferior_pid == 0)
d654 1
a654 1
  kill (inferior_pid, SIGKILL);
d658 1
a658 1
  ptrace (PT_KILL, inferior_pid, 0, 0);
d669 1
a669 1
child_resume (int pid, int step, enum target_signal signal)
d671 2
d676 1
a676 1
    pid = inferior_pid;
d723 1
a723 1
  rv = mptrace (XPT_UNDEBUG, inferior_pid, 1, signo);
d777 1
a777 1
	  buffer[0] = ptrace (PT_RTEXT, inferior_pid, (PTRACE_ARG3_TYPE) addr,
d784 1
a784 1
	    = ptrace (PT_RTEXT, inferior_pid,
d801 1
a801 1
	  ptrace (PT_WDATA, inferior_pid, (PTRACE_ARG3_TYPE) addr,
d808 1
a808 1
	      ptrace (PT_WTEXT, inferior_pid, (PTRACE_ARG3_TYPE) addr,
d821 1
a821 1
	  buffer[i] = ptrace (PT_RTEXT, inferior_pid,
@


1.7
log
@Update/correct copyright notices.
@
text
@d751 1
@


1.6
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1986, 1987, 1989, 1991, 1992, 1994, 2001
@


1.5
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d30 1
@


1.4
log
@Protoization.
@
text
@d2 2
a3 1
   Copyright 1986, 1987, 1989, 1991, 1992, 1994 Free Software Foundation, Inc.
d535 2
a536 1
	  internal_error ("PTS_WATCHPT_HIT\n");
d849 2
a850 1
      internal_error ("_initialize_symm_nat(): mptrace(XPT_MPDEBUGGER): %s",
d868 2
a869 1
      internal_error ("_initialize_symm_nat(): sigaddset(SIGCHLD): %s",
d875 2
a876 1
      internal_error ("_initialize_symm_nat(): sigprocmask(SIG_BLOCK): %s",
d886 2
a887 1
      internal_error ("_initialize_symm_nat(): sigaction(SIGCHLD): %s",
@


1.3
log
@Protoization.
@
text
@a316 1

@


1.2
log
@Protoization.
@
text
@d316 1
a316 2
print_1167_regs (regs)
     long regs[FPA_NREGS];
d739 1
a739 1
   WRITE is nonzero.
d747 2
a748 6
child_xfer_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *target;	/* ignored */
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d56 1
a56 2
store_inferior_registers(regno)
int regno;
a59 1
  extern char registers[];
d66 1
a66 1
  mptrace (XPT_RREGS, inferior_pid, (PTRACE_ARG3_TYPE) &regs, 0);
d68 10
a77 10
  regs.pr_eax = *(int *)&registers[REGISTER_BYTE(0)];
  regs.pr_ebx = *(int *)&registers[REGISTER_BYTE(5)];
  regs.pr_ecx = *(int *)&registers[REGISTER_BYTE(2)];
  regs.pr_edx = *(int *)&registers[REGISTER_BYTE(1)];
  regs.pr_esi = *(int *)&registers[REGISTER_BYTE(6)];
  regs.pr_edi = *(int *)&registers[REGISTER_BYTE(7)];
  regs.pr_esp = *(int *)&registers[REGISTER_BYTE(14)];
  regs.pr_ebp = *(int *)&registers[REGISTER_BYTE(15)];
  regs.pr_eip = *(int *)&registers[REGISTER_BYTE(16)];
  regs.pr_flags = *(int *)&registers[REGISTER_BYTE(17)];
d81 1
a81 1
	*(int *)&registers[REGISTER_BYTE(FP1_REGNUM+i)];
d83 9
a91 9
  memcpy (regs.pr_fpu.fpu_stack[0], &registers[REGISTER_BYTE(ST0_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[1], &registers[REGISTER_BYTE(ST1_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[2], &registers[REGISTER_BYTE(ST2_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[3], &registers[REGISTER_BYTE(ST3_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[4], &registers[REGISTER_BYTE(ST4_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[5], &registers[REGISTER_BYTE(ST5_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[6], &registers[REGISTER_BYTE(ST6_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[7], &registers[REGISTER_BYTE(ST7_REGNUM)], 10);
  mptrace (XPT_WREGS, inferior_pid, (PTRACE_ARG3_TYPE) &regs, 0);
d95 1
a95 2
fetch_inferior_registers (regno)
     int regno;
a98 1
  extern char registers[];
d102 11
a112 11
  mptrace (XPT_RREGS, inferior_pid, (PTRACE_ARG3_TYPE) &regs, 0);
  *(int *)&registers[REGISTER_BYTE(EAX_REGNUM)] = regs.pr_eax;
  *(int *)&registers[REGISTER_BYTE(EBX_REGNUM)] = regs.pr_ebx;
  *(int *)&registers[REGISTER_BYTE(ECX_REGNUM)] = regs.pr_ecx;
  *(int *)&registers[REGISTER_BYTE(EDX_REGNUM)] = regs.pr_edx;
  *(int *)&registers[REGISTER_BYTE(ESI_REGNUM)] = regs.pr_esi;
  *(int *)&registers[REGISTER_BYTE(EDI_REGNUM)] = regs.pr_edi;
  *(int *)&registers[REGISTER_BYTE(EBP_REGNUM)] = regs.pr_ebp;
  *(int *)&registers[REGISTER_BYTE(ESP_REGNUM)] = regs.pr_esp;
  *(int *)&registers[REGISTER_BYTE(EIP_REGNUM)] = regs.pr_eip;
  *(int *)&registers[REGISTER_BYTE(EFLAGS_REGNUM)] = regs.pr_flags;
d115 1
a115 1
      *(int *)&registers[REGISTER_BYTE(FP1_REGNUM+i)] =
d118 8
a125 8
  memcpy (&registers[REGISTER_BYTE(ST0_REGNUM)], regs.pr_fpu.fpu_stack[0], 10);
  memcpy (&registers[REGISTER_BYTE(ST1_REGNUM)], regs.pr_fpu.fpu_stack[1], 10);
  memcpy (&registers[REGISTER_BYTE(ST2_REGNUM)], regs.pr_fpu.fpu_stack[2], 10);
  memcpy (&registers[REGISTER_BYTE(ST3_REGNUM)], regs.pr_fpu.fpu_stack[3], 10);
  memcpy (&registers[REGISTER_BYTE(ST4_REGNUM)], regs.pr_fpu.fpu_stack[4], 10);
  memcpy (&registers[REGISTER_BYTE(ST5_REGNUM)], regs.pr_fpu.fpu_stack[5], 10);
  memcpy (&registers[REGISTER_BYTE(ST6_REGNUM)], regs.pr_fpu.fpu_stack[6], 10);
  memcpy (&registers[REGISTER_BYTE(ST7_REGNUM)], regs.pr_fpu.fpu_stack[7], 10);
d130 1
a130 2
print_fpu_status(ep)
struct pt_regset ep;
d132 75
a206 64
    int i;
    int bothstatus;
    int top;
    int fpreg;
    unsigned char *p;
    
    printf_unfiltered("80387:");
    if (ep.pr_fpu.fpu_ip == 0) {
	printf_unfiltered(" not in use.\n");
	return;
    } else {
	printf_unfiltered("\n");
    }
    if (ep.pr_fpu.fpu_status != 0) {
	print_387_status_word (ep.pr_fpu.fpu_status);
    }
    print_387_control_word (ep.pr_fpu.fpu_control);
    printf_unfiltered ("last exception: ");
    printf_unfiltered ("opcode 0x%x; ", ep.pr_fpu.fpu_rsvd4);
    printf_unfiltered ("pc 0x%x:0x%x; ", ep.pr_fpu.fpu_cs, ep.pr_fpu.fpu_ip);
    printf_unfiltered ("operand 0x%x:0x%x\n", ep.pr_fpu.fpu_data_offset, ep.pr_fpu.fpu_op_sel);
    
    top = (ep.pr_fpu.fpu_status >> 11) & 7;
    
    printf_unfiltered ("regno  tag  msb              lsb  value\n");
    for (fpreg = 7; fpreg >= 0; fpreg--) 
	{
	    double val;
	    
	    printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg);
	    
	    switch ((ep.pr_fpu.fpu_tag >> (fpreg * 2)) & 3) 
		{
		case 0: printf_unfiltered ("valid "); break;
		case 1: printf_unfiltered ("zero  "); break;
		case 2: printf_unfiltered ("trap  "); break;
		case 3: printf_unfiltered ("empty "); break;
		}
	    for (i = 9; i >= 0; i--)
		printf_unfiltered ("%02x", ep.pr_fpu.fpu_stack[fpreg][i]);
	    
	    i387_to_double ((char *)ep.pr_fpu.fpu_stack[fpreg], (char *)&val);
	    printf_unfiltered ("  %g\n", val);
	}
    if (ep.pr_fpu.fpu_rsvd1)
	warning ("rsvd1 is 0x%x\n", ep.pr_fpu.fpu_rsvd1);
    if (ep.pr_fpu.fpu_rsvd2)
	warning ("rsvd2 is 0x%x\n", ep.pr_fpu.fpu_rsvd2);
    if (ep.pr_fpu.fpu_rsvd3)
	warning ("rsvd3 is 0x%x\n", ep.pr_fpu.fpu_rsvd3);
    if (ep.pr_fpu.fpu_rsvd5)
	warning ("rsvd5 is 0x%x\n", ep.pr_fpu.fpu_rsvd5);
}


print_1167_control_word(pcr)
unsigned int pcr;

{
    int pcr_tmp;

    pcr_tmp = pcr & FPA_PCR_MODE;
    printf_unfiltered("\tMODE= %#x; RND= %#x ", pcr_tmp, pcr_tmp & 12);
    switch (pcr_tmp & 12) {
d208 2
a209 2
	printf_unfiltered("RN (Nearest Value)");
	break;
d211 2
a212 2
	printf_unfiltered("RZ (Zero)");
	break;
d214 2
a215 2
	printf_unfiltered("RP (Positive Infinity)");
	break;
d217 11
a227 2
	printf_unfiltered("RM (Negative Infinity)");
	break;
d229 29
a257 25
    printf_unfiltered("; IRND= %d ", pcr_tmp & 2);
    if (0 == pcr_tmp & 2) {
	printf_unfiltered("(same as RND)\n");
    } else {
	printf_unfiltered("(toward zero)\n");
    }
    pcr_tmp = pcr & FPA_PCR_EM;
    printf_unfiltered("\tEM= %#x", pcr_tmp);
    if (pcr_tmp & FPA_PCR_EM_DM) printf_unfiltered(" DM");
    if (pcr_tmp & FPA_PCR_EM_UOM) printf_unfiltered(" UOM");
    if (pcr_tmp & FPA_PCR_EM_PM) printf_unfiltered(" PM");
    if (pcr_tmp & FPA_PCR_EM_UM) printf_unfiltered(" UM");
    if (pcr_tmp & FPA_PCR_EM_OM) printf_unfiltered(" OM");
    if (pcr_tmp & FPA_PCR_EM_ZM) printf_unfiltered(" ZM");
    if (pcr_tmp & FPA_PCR_EM_IM) printf_unfiltered(" IM");
    printf_unfiltered("\n");
    pcr_tmp = FPA_PCR_CC;
    printf_unfiltered("\tCC= %#x", pcr_tmp);
    if (pcr_tmp & FPA_PCR_20MHZ) printf_unfiltered(" 20MHZ");
    if (pcr_tmp & FPA_PCR_CC_Z) printf_unfiltered(" Z");
    if (pcr_tmp & FPA_PCR_CC_C2) printf_unfiltered(" C2");

    /* Dynix defines FPA_PCR_CC_C0 to 0x100 and ptx defines
       FPA_PCR_CC_C1 to 0x100.  Use whichever is defined and assume
       the OS knows what it is doing.  */
d259 2
a260 1
    if (pcr_tmp & FPA_PCR_CC_C1) printf_unfiltered(" C1");
d262 2
a263 1
    if (pcr_tmp & FPA_PCR_CC_C0) printf_unfiltered(" C0");
d266 5
a270 5
    switch (pcr_tmp)
      {
      case FPA_PCR_CC_Z:
	printf_unfiltered(" (Equal)");
	break;
d272 1
a272 1
      case FPA_PCR_CC_C1:
d274 1
a274 1
      case FPA_PCR_CC_C0:
d276 6
a281 6
	printf_unfiltered(" (Less than)");
	break;
      case 0:
	printf_unfiltered(" (Greater than)");
	break;
      case FPA_PCR_CC_Z | 
d287 27
a313 19
	  | FPA_PCR_CC_C2:
	printf_unfiltered(" (Unordered)");
	break;
      default:
	printf_unfiltered(" (Undefined)");
	break;
      }
    printf_unfiltered("\n");
    pcr_tmp = pcr & FPA_PCR_AE;
    printf_unfiltered("\tAE= %#x", pcr_tmp);
    if (pcr_tmp & FPA_PCR_AE_DE) printf_unfiltered(" DE");
    if (pcr_tmp & FPA_PCR_AE_UOE) printf_unfiltered(" UOE");
    if (pcr_tmp & FPA_PCR_AE_PE) printf_unfiltered(" PE");
    if (pcr_tmp & FPA_PCR_AE_UE) printf_unfiltered(" UE");
    if (pcr_tmp & FPA_PCR_AE_OE) printf_unfiltered(" OE");
    if (pcr_tmp & FPA_PCR_AE_ZE) printf_unfiltered(" ZE");
    if (pcr_tmp & FPA_PCR_AE_EE) printf_unfiltered(" EE");
    if (pcr_tmp & FPA_PCR_AE_IE) printf_unfiltered(" IE");
    printf_unfiltered("\n");
d316 2
a317 2
print_1167_regs(regs)
long regs[FPA_NREGS];
d320 1
a320 1
    int i;
d322 12
a333 8
    union {
	double	d;
	long	l[2];
    } xd;
    union {
	float	f;
	long	l;
    } xf;
d336 13
a348 9
    for (i = 0; i < FPA_NREGS; i++) {
	xf.l = regs[i];
	printf_unfiltered("%%fp%d: raw= %#x, single= %f", i+1, regs[i], xf.f);
	if (!(i & 1)) {
	    printf_unfiltered("\n");
	} else {
	    xd.l[1] = regs[i];
	    xd.l[0] = regs[i+1];
	    printf_unfiltered(", double= %f\n", xd.d);
d353 1
a353 3
print_fpa_status(ep)
struct pt_regset ep;

d356 10
a365 7
    printf_unfiltered("WTL 1167:");
    if (ep.pr_fpa.fpa_pcr !=0) {
	printf_unfiltered("\n");
	print_1167_control_word(ep.pr_fpa.fpa_pcr);
	print_1167_regs(ep.pr_fpa.fpa_regs);
    } else {
	printf_unfiltered(" not in use.\n");
d369 2
a370 2
#if 0 /* disabled because it doesn't go through the target vector.  */
i386_float_info ()
d372 1
a372 1
  char ubuf[UPAGES*NBPG];
d375 1
a375 1
  if (have_inferior_p())
d377 1
a377 1
      PTRACE_READ_REGS (inferior_pid, (PTRACE_ARG3_TYPE) &regset);
d386 1
a386 1
      if (myread (corechan, ubuf, UPAGES*NBPG) < 0)
d394 2
a395 2
  print_fpu_status(regset);
  print_fpa_status(regset);
d401 1
a401 1
/*ARGSUSED*/
d404 1
a404 2
sigchld_handler(signo)
	int signo;
d406 1
a406 1
	got_sigchld++;
d427 1
a427 3
child_wait(pid, status)
     int pid;
     struct target_waitstatus *status;
d440 7
a446 4
  do {
    set_sigint_trap();	/* Causes SIGINT to be passed on to the
			   attached process. */
    save_errno = errno;
d448 1
a448 1
    got_sigchld = 0;
d450 4
a453 1
    sigemptyset(&set);
d455 1
a455 5
    while (got_sigchld == 0) {
	    sigsuspend(&set);
    }
    
    clear_sigint_trap();
d457 6
a462 5
    rv = mptrace(XPT_STOPSTAT, 0, (char *)&pt, 0);
    if (-1 == rv) {
	    printf("XPT_STOPSTAT: errno %d\n", errno); /* DEBUG */
	    continue;
    }
d464 1
a464 1
    pid = pt.ps_pid;
d466 12
a477 10
    if (pid != inferior_pid) {
	    /* NOTE: the mystery fork in csh/tcsh needs to be ignored.
	     * We should not return new children for the initial run
	     * of a process until it has done the exec.
	     */
	    /* inferior probably forked; send it on its way */
	    rv = mptrace(XPT_UNDEBUG, pid, 0, 0);
	    if (-1 == rv) {
		    printf("child_wait: XPT_UNDEBUG: pid %d: %s\n", pid,
			   safe_strerror(errno));
d479 39
a517 13
	    continue;
    }
    /* FIXME: Do we deal with fork notification correctly?  */
    switch (pt.ps_reason) {
    case PTS_FORK:
	/* multi proc: treat like PTS_EXEC */
	    /*
	     * Pretend this didn't happen, since gdb isn't set up
	     * to deal with stops on fork.
	     */
	    rv = ptrace(PT_CONTSIG, pid, 1, 0);
	    if (-1 == rv) {
		    printf("PTS_FORK: PT_CONTSIG: error %d\n", errno);
d519 14
a532 37
	    continue;
    case PTS_EXEC:
	    /*
	     * Pretend this is a SIGTRAP.
	     */
	    status->kind = TARGET_WAITKIND_STOPPED;
	    status->value.sig = TARGET_SIGNAL_TRAP;
	    break;
    case PTS_EXIT:
	    /*
	     * Note: we stop before the exit actually occurs.  Extract
	     * the exit code from the uarea.  If we're stopped in the
	     * exit() system call, the exit code will be in
	     * u.u_ap[0].  An exit due to an uncaught signal will have
	     * something else in here, see the comment in the default:
	     * case, below.  Finally,let the process exit.
	     */
	    if (death_by_signal)
	      {
		status->kind = TARGET_WAITKIND_SIGNALED;
		status->value.sig = target_signal_from_host (death_by_signal);
		death_by_signal = 0;
		break;
	      }
	    xvaloff = (unsigned long)&u.u_ap[0] - (unsigned long)&u;
	    errno = 0;
	    rv = ptrace(PT_RUSER, pid, (char *)xvaloff, 0);
	    status->kind = TARGET_WAITKIND_EXITED;
	    status->value.integer = rv;
	    /*
	     * addr & data to mptrace() don't matter here, since
	     * the process is already dead.
	     */
	    rv = mptrace(XPT_UNDEBUG, pid, 0, 0);
	    if (-1 == rv) {
		    printf("child_wait: PTS_EXIT: XPT_UNDEBUG: pid %d error %d\n", pid,
			   errno);
d534 9
a542 9
	    break;
    case PTS_WATCHPT_HIT:
	    fatal("PTS_WATCHPT_HIT\n");
	    break;
    default:
	    /* stopped by signal */
	    status->kind = TARGET_WAITKIND_STOPPED;
	    status->value.sig = target_signal_from_host (pt.ps_reason);
	    death_by_signal = 0;
d544 3
a546 2
	    if (0 == (SIGNALS_DFL_SAFE & sigmask(pt.ps_reason))) {
		    break;
d548 1
a548 1
	    /* else default action of signal is to die */
d550 8
a557 7
	    rv = ptrace(PT_GET_PRSTATUS, pid, (char *)&pstatus, 0);
	    if (-1 == rv)
		error("child_wait: signal %d PT_GET_PRSTATUS: %s\n",
			pt.ps_reason, safe_strerror(errno));
	    if (pstatus.pr_cursig != pt.ps_reason) {
		printf("pstatus signal %d, pt signal %d\n",
			pstatus.pr_cursig, pt.ps_reason);
d559 1
a559 1
	    sa_hand = (int)pstatus.pr_action.sa_handler;
d561 7
a567 7
	    saoff = (unsigned long)&u.u_sa[0] - (unsigned long)&u;
	    saoff += sizeof(struct sigaction) * (pt.ps_reason - 1);
	    errno = 0;
	    sa_hand = ptrace(PT_RUSER, pid, (char *)saoff, 0);
	    if (errno)
		    error("child_wait: signal %d: RUSER: %s\n",
			   pt.ps_reason, safe_strerror(errno));
d569 4
a572 3
	    if ((int)SIG_DFL == sa_hand) {
		    /* we will be dying */
		    death_by_signal = pt.ps_reason;
d574 3
a576 1
	    break;
d578 1
a578 2

  } while (pid != inferior_pid); /* Some other child died or stopped */
d588 1
a588 3
child_wait (pid, ourstatus)
     int pid;
     struct target_waitstatus *ourstatus;
d593 17
a609 15
  do {
    pid = wait (&status);
    save_errno = errno;

    if (pid == -1)
      {
	if (save_errno == EINTR)
	  continue;
	fprintf (stderr, "Child process unexpectedly missing: %s.\n",
		 safe_strerror (save_errno));
	ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
	ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
        return -1;
      }
  } while (pid != inferior_pid); /* Some other child died or stopped */
d614 1
a616 1

d621 1
a621 4
call_ptrace (request, pid, addr, data)
     int request, pid;
     PTRACE_ARG3_TYPE addr;
     int data;
d627 1
a627 4
call_mptrace(request, pid, addr, data)
	int request, pid;
	PTRACE_ARG3_TYPE addr;
	int data;
d629 1
a629 1
	return mptrace(request, pid, addr, data);
d640 1
a640 1
kill_inferior ()
d651 1
a651 1
  detach(SIGKILL);
d653 2
a654 2
  ptrace(PT_KILL, inferior_pid, 0, 0);
  wait((int *)NULL);
d664 1
a664 4
child_resume (pid, step, signal)
     int pid;
     int step;
     enum target_signal signal;
d681 1
a681 1
    ptrace (PT_SSTEP,     pid, (PTRACE_ARG3_TYPE) 1, signal);
d692 1
a692 2
attach (pid)
     int pid;
d694 2
a695 2
	sigset_t set;
	int rv;
d697 12
a708 10
	rv = mptrace(XPT_DEBUG, pid, 0, 0);
	if (-1 == rv) {
		error("mptrace(XPT_DEBUG): %s", safe_strerror(errno));
	}
	rv = mptrace(XPT_SIGNAL, pid, 0, SIGSTOP);
	if (-1 == rv) {
		error("mptrace(XPT_SIGNAL): %s", safe_strerror(errno));
	}
	attach_flag = 1;
	return pid;
d712 1
a712 2
detach (signo)
     int signo;
d714 1
a714 1
	int rv;
d716 6
a721 5
	rv = mptrace(XPT_UNDEBUG, inferior_pid, 1, signo);
	if (-1 == rv) {
		error("mptrace(XPT_UNDEBUG): %s", safe_strerror(errno));
	}
	attach_flag = 0;
d730 1
a731 1

d741 1
a741 1
  
d753 1
a753 1
     struct target_ops *target;		/* ignored */
d757 1
a757 1
  register CORE_ADDR addr = memaddr & - sizeof (PTRACE_XFER_TYPE);
d760 2
a761 2
    = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
      / sizeof (PTRACE_XFER_TYPE);
d764 1
a764 1
    = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
d770 6
a775 5
      if (addr != memaddr || len < (int) sizeof (PTRACE_XFER_TYPE)) {
	/* Need part of initial word -- fetch it.  */
        buffer[0] = ptrace (PT_RTEXT, inferior_pid, (PTRACE_ARG3_TYPE) addr,
			    0);
      }
d802 1
a802 1
		 Gould NP1, at least.  */
d834 1
a834 1
_initialize_symm_nat ()
d846 44
a889 40
	int rv;
	sigset_t set;
	struct sigaction sact;

	rv = mptrace(XPT_MPDEBUGGER, 0, 0, 0);
	if (-1 == rv) {
		fatal("_initialize_symm_nat(): mptrace(XPT_MPDEBUGGER): %s",
		      safe_strerror(errno));
	}

	/*
	 * Under MPDEBUGGER, we get SIGCLHD when a traced process does
	 * anything of interest.
	 */

	/*
	 * Block SIGCHLD.  We leave it blocked all the time, and then
	 * call sigsuspend() in child_wait() to wait for the child
	 * to do something.  None of these ought to fail, but check anyway.
	 */
	sigemptyset(&set);
	rv = sigaddset(&set, SIGCHLD);
	if (-1 == rv) {
		fatal("_initialize_symm_nat(): sigaddset(SIGCHLD): %s",
		      safe_strerror(errno));
	}
	rv = sigprocmask(SIG_BLOCK, &set, (sigset_t *)NULL);
	if (-1 == rv) {
		fatal("_initialize_symm_nat(): sigprocmask(SIG_BLOCK): %s",
		      safe_strerror(errno));
	}

	sact.sa_handler = sigchld_handler;
	sigemptyset(&sact.sa_mask);
	sact.sa_flags = SA_NOCLDWAIT; /* keep the zombies away */
	rv = sigaction(SIGCHLD, &sact, (struct sigaction *)NULL);
	if (-1 == rv) {
		fatal("_initialize_symm_nat(): sigaction(SIGCHLD): %s",
		      safe_strerror(errno));
	}
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d60 1
d101 1
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d55 2
a56 2
store_inferior_registers (regno)
     int regno;
d66 1
a66 1
  mptrace (XPT_RREGS, inferior_pid, (PTRACE_ARG3_TYPE) & regs, 0);
d68 10
a77 10
  regs.pr_eax = *(int *) &registers[REGISTER_BYTE (0)];
  regs.pr_ebx = *(int *) &registers[REGISTER_BYTE (5)];
  regs.pr_ecx = *(int *) &registers[REGISTER_BYTE (2)];
  regs.pr_edx = *(int *) &registers[REGISTER_BYTE (1)];
  regs.pr_esi = *(int *) &registers[REGISTER_BYTE (6)];
  regs.pr_edi = *(int *) &registers[REGISTER_BYTE (7)];
  regs.pr_esp = *(int *) &registers[REGISTER_BYTE (14)];
  regs.pr_ebp = *(int *) &registers[REGISTER_BYTE (15)];
  regs.pr_eip = *(int *) &registers[REGISTER_BYTE (16)];
  regs.pr_flags = *(int *) &registers[REGISTER_BYTE (17)];
d81 1
a81 1
	*(int *) &registers[REGISTER_BYTE (FP1_REGNUM + i)];
d83 9
a91 9
  memcpy (regs.pr_fpu.fpu_stack[0], &registers[REGISTER_BYTE (ST0_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[1], &registers[REGISTER_BYTE (ST1_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[2], &registers[REGISTER_BYTE (ST2_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[3], &registers[REGISTER_BYTE (ST3_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[4], &registers[REGISTER_BYTE (ST4_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[5], &registers[REGISTER_BYTE (ST5_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[6], &registers[REGISTER_BYTE (ST6_REGNUM)], 10);
  memcpy (regs.pr_fpu.fpu_stack[7], &registers[REGISTER_BYTE (ST7_REGNUM)], 10);
  mptrace (XPT_WREGS, inferior_pid, (PTRACE_ARG3_TYPE) & regs, 0);
d103 11
a113 11
  mptrace (XPT_RREGS, inferior_pid, (PTRACE_ARG3_TYPE) & regs, 0);
  *(int *) &registers[REGISTER_BYTE (EAX_REGNUM)] = regs.pr_eax;
  *(int *) &registers[REGISTER_BYTE (EBX_REGNUM)] = regs.pr_ebx;
  *(int *) &registers[REGISTER_BYTE (ECX_REGNUM)] = regs.pr_ecx;
  *(int *) &registers[REGISTER_BYTE (EDX_REGNUM)] = regs.pr_edx;
  *(int *) &registers[REGISTER_BYTE (ESI_REGNUM)] = regs.pr_esi;
  *(int *) &registers[REGISTER_BYTE (EDI_REGNUM)] = regs.pr_edi;
  *(int *) &registers[REGISTER_BYTE (EBP_REGNUM)] = regs.pr_ebp;
  *(int *) &registers[REGISTER_BYTE (ESP_REGNUM)] = regs.pr_esp;
  *(int *) &registers[REGISTER_BYTE (EIP_REGNUM)] = regs.pr_eip;
  *(int *) &registers[REGISTER_BYTE (EFLAGS_REGNUM)] = regs.pr_flags;
d116 1
a116 1
      *(int *) &registers[REGISTER_BYTE (FP1_REGNUM + i)] =
d119 8
a126 8
  memcpy (&registers[REGISTER_BYTE (ST0_REGNUM)], regs.pr_fpu.fpu_stack[0], 10);
  memcpy (&registers[REGISTER_BYTE (ST1_REGNUM)], regs.pr_fpu.fpu_stack[1], 10);
  memcpy (&registers[REGISTER_BYTE (ST2_REGNUM)], regs.pr_fpu.fpu_stack[2], 10);
  memcpy (&registers[REGISTER_BYTE (ST3_REGNUM)], regs.pr_fpu.fpu_stack[3], 10);
  memcpy (&registers[REGISTER_BYTE (ST4_REGNUM)], regs.pr_fpu.fpu_stack[4], 10);
  memcpy (&registers[REGISTER_BYTE (ST5_REGNUM)], regs.pr_fpu.fpu_stack[5], 10);
  memcpy (&registers[REGISTER_BYTE (ST6_REGNUM)], regs.pr_fpu.fpu_stack[6], 10);
  memcpy (&registers[REGISTER_BYTE (ST7_REGNUM)], regs.pr_fpu.fpu_stack[7], 10);
d131 2
a132 2
print_fpu_status (ep)
     struct pt_regset ep;
d134 64
a197 77
  int i;
  int bothstatus;
  int top;
  int fpreg;
  unsigned char *p;

  printf_unfiltered ("80387:");
  if (ep.pr_fpu.fpu_ip == 0)
    {
      printf_unfiltered (" not in use.\n");
      return;
    }
  else
    {
      printf_unfiltered ("\n");
    }
  if (ep.pr_fpu.fpu_status != 0)
    {
      print_387_status_word (ep.pr_fpu.fpu_status);
    }
  print_387_control_word (ep.pr_fpu.fpu_control);
  printf_unfiltered ("last exception: ");
  printf_unfiltered ("opcode 0x%x; ", ep.pr_fpu.fpu_rsvd4);
  printf_unfiltered ("pc 0x%x:0x%x; ", ep.pr_fpu.fpu_cs, ep.pr_fpu.fpu_ip);
  printf_unfiltered ("operand 0x%x:0x%x\n", ep.pr_fpu.fpu_data_offset, ep.pr_fpu.fpu_op_sel);

  top = (ep.pr_fpu.fpu_status >> 11) & 7;

  printf_unfiltered ("regno  tag  msb              lsb  value\n");
  for (fpreg = 7; fpreg >= 0; fpreg--)
    {
      double val;

      printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg);

      switch ((ep.pr_fpu.fpu_tag >> (fpreg * 2)) & 3)
	{
	case 0:
	  printf_unfiltered ("valid ");
	  break;
	case 1:
	  printf_unfiltered ("zero  ");
	  break;
	case 2:
	  printf_unfiltered ("trap  ");
	  break;
	case 3:
	  printf_unfiltered ("empty ");
	  break;
	}
      for (i = 9; i >= 0; i--)
	printf_unfiltered ("%02x", ep.pr_fpu.fpu_stack[fpreg][i]);

      i387_to_double ((char *) ep.pr_fpu.fpu_stack[fpreg], (char *) &val);
      printf_unfiltered ("  %g\n", val);
    }
  if (ep.pr_fpu.fpu_rsvd1)
    warning ("rsvd1 is 0x%x\n", ep.pr_fpu.fpu_rsvd1);
  if (ep.pr_fpu.fpu_rsvd2)
    warning ("rsvd2 is 0x%x\n", ep.pr_fpu.fpu_rsvd2);
  if (ep.pr_fpu.fpu_rsvd3)
    warning ("rsvd3 is 0x%x\n", ep.pr_fpu.fpu_rsvd3);
  if (ep.pr_fpu.fpu_rsvd5)
    warning ("rsvd5 is 0x%x\n", ep.pr_fpu.fpu_rsvd5);
}


print_1167_control_word (pcr)
     unsigned int pcr;

{
  int pcr_tmp;

  pcr_tmp = pcr & FPA_PCR_MODE;
  printf_unfiltered ("\tMODE= %#x; RND= %#x ", pcr_tmp, pcr_tmp & 12);
  switch (pcr_tmp & 12)
    {
d199 2
a200 2
      printf_unfiltered ("RN (Nearest Value)");
      break;
d202 2
a203 2
      printf_unfiltered ("RZ (Zero)");
      break;
d205 2
a206 2
      printf_unfiltered ("RP (Positive Infinity)");
      break;
d208 2
a209 7
      printf_unfiltered ("RM (Negative Infinity)");
      break;
    }
  printf_unfiltered ("; IRND= %d ", pcr_tmp & 2);
  if (0 == pcr_tmp & 2)
    {
      printf_unfiltered ("(same as RND)\n");
d211 25
a235 33
  else
    {
      printf_unfiltered ("(toward zero)\n");
    }
  pcr_tmp = pcr & FPA_PCR_EM;
  printf_unfiltered ("\tEM= %#x", pcr_tmp);
  if (pcr_tmp & FPA_PCR_EM_DM)
    printf_unfiltered (" DM");
  if (pcr_tmp & FPA_PCR_EM_UOM)
    printf_unfiltered (" UOM");
  if (pcr_tmp & FPA_PCR_EM_PM)
    printf_unfiltered (" PM");
  if (pcr_tmp & FPA_PCR_EM_UM)
    printf_unfiltered (" UM");
  if (pcr_tmp & FPA_PCR_EM_OM)
    printf_unfiltered (" OM");
  if (pcr_tmp & FPA_PCR_EM_ZM)
    printf_unfiltered (" ZM");
  if (pcr_tmp & FPA_PCR_EM_IM)
    printf_unfiltered (" IM");
  printf_unfiltered ("\n");
  pcr_tmp = FPA_PCR_CC;
  printf_unfiltered ("\tCC= %#x", pcr_tmp);
  if (pcr_tmp & FPA_PCR_20MHZ)
    printf_unfiltered (" 20MHZ");
  if (pcr_tmp & FPA_PCR_CC_Z)
    printf_unfiltered (" Z");
  if (pcr_tmp & FPA_PCR_CC_C2)
    printf_unfiltered (" C2");

  /* Dynix defines FPA_PCR_CC_C0 to 0x100 and ptx defines
     FPA_PCR_CC_C1 to 0x100.  Use whichever is defined and assume
     the OS knows what it is doing.  */
d237 1
a237 2
  if (pcr_tmp & FPA_PCR_CC_C1)
    printf_unfiltered (" C1");
d239 1
a239 2
  if (pcr_tmp & FPA_PCR_CC_C0)
    printf_unfiltered (" C0");
d242 5
a246 5
  switch (pcr_tmp)
    {
    case FPA_PCR_CC_Z:
      printf_unfiltered (" (Equal)");
      break;
d248 1
a248 1
    case FPA_PCR_CC_C1:
d250 1
a250 1
    case FPA_PCR_CC_C0:
d252 6
a257 6
      printf_unfiltered (" (Less than)");
      break;
    case 0:
      printf_unfiltered (" (Greater than)");
      break;
      case FPA_PCR_CC_Z |
d263 19
a281 27
    | FPA_PCR_CC_C2:
      printf_unfiltered (" (Unordered)");
      break;
    default:
      printf_unfiltered (" (Undefined)");
      break;
    }
  printf_unfiltered ("\n");
  pcr_tmp = pcr & FPA_PCR_AE;
  printf_unfiltered ("\tAE= %#x", pcr_tmp);
  if (pcr_tmp & FPA_PCR_AE_DE)
    printf_unfiltered (" DE");
  if (pcr_tmp & FPA_PCR_AE_UOE)
    printf_unfiltered (" UOE");
  if (pcr_tmp & FPA_PCR_AE_PE)
    printf_unfiltered (" PE");
  if (pcr_tmp & FPA_PCR_AE_UE)
    printf_unfiltered (" UE");
  if (pcr_tmp & FPA_PCR_AE_OE)
    printf_unfiltered (" OE");
  if (pcr_tmp & FPA_PCR_AE_ZE)
    printf_unfiltered (" ZE");
  if (pcr_tmp & FPA_PCR_AE_EE)
    printf_unfiltered (" EE");
  if (pcr_tmp & FPA_PCR_AE_IE)
    printf_unfiltered (" IE");
  printf_unfiltered ("\n");
d284 2
a285 2
print_1167_regs (regs)
     long regs[FPA_NREGS];
d288 1
a288 1
  int i;
d290 8
a297 12
  union
    {
      double d;
      long l[2];
    }
  xd;
  union
    {
      float f;
      long l;
    }
  xf;
d300 9
a308 13
  for (i = 0; i < FPA_NREGS; i++)
    {
      xf.l = regs[i];
      printf_unfiltered ("%%fp%d: raw= %#x, single= %f", i + 1, regs[i], xf.f);
      if (!(i & 1))
	{
	  printf_unfiltered ("\n");
	}
      else
	{
	  xd.l[1] = regs[i];
	  xd.l[0] = regs[i + 1];
	  printf_unfiltered (", double= %f\n", xd.d);
d313 2
a314 2
print_fpa_status (ep)
     struct pt_regset ep;
d318 7
a324 10
  printf_unfiltered ("WTL 1167:");
  if (ep.pr_fpa.fpa_pcr != 0)
    {
      printf_unfiltered ("\n");
      print_1167_control_word (ep.pr_fpa.fpa_pcr);
      print_1167_regs (ep.pr_fpa.fpa_regs);
    }
  else
    {
      printf_unfiltered (" not in use.\n");
d328 1
a328 1
#if 0				/* disabled because it doesn't go through the target vector.  */
d331 1
a331 1
  char ubuf[UPAGES * NBPG];
d334 1
a334 1
  if (have_inferior_p ())
d336 1
a336 1
      PTRACE_READ_REGS (inferior_pid, (PTRACE_ARG3_TYPE) & regset);
d345 1
a345 1
      if (myread (corechan, ubuf, UPAGES * NBPG) < 0)
d353 2
a354 2
  print_fpu_status (regset);
  print_fpa_status (regset);
d360 1
a360 1
/*ARGSUSED */
d363 2
a364 2
sigchld_handler (signo)
     int signo;
d366 1
a366 1
  got_sigchld++;
d387 1
a387 1
child_wait (pid, status)
d402 4
a405 5
  do
    {
      set_sigint_trap ();	/* Causes SIGINT to be passed on to the
				   attached process. */
      save_errno = errno;
d407 1
a407 1
      got_sigchld = 0;
d409 1
a409 1
      sigemptyset (&set);
d411 5
a415 4
      while (got_sigchld == 0)
	{
	  sigsuspend (&set);
	}
d417 5
a421 8
      clear_sigint_trap ();

      rv = mptrace (XPT_STOPSTAT, 0, (char *) &pt, 0);
      if (-1 == rv)
	{
	  printf ("XPT_STOPSTAT: errno %d\n", errno);	/* DEBUG */
	  continue;
	}
d423 1
a423 1
      pid = pt.ps_pid;
d425 10
a434 12
      if (pid != inferior_pid)
	{
	  /* NOTE: the mystery fork in csh/tcsh needs to be ignored.
	   * We should not return new children for the initial run
	   * of a process until it has done the exec.
	   */
	  /* inferior probably forked; send it on its way */
	  rv = mptrace (XPT_UNDEBUG, pid, 0, 0);
	  if (-1 == rv)
	    {
	      printf ("child_wait: XPT_UNDEBUG: pid %d: %s\n", pid,
		      safe_strerror (errno));
d436 13
a448 15
	  continue;
	}
      /* FIXME: Do we deal with fork notification correctly?  */
      switch (pt.ps_reason)
	{
	case PTS_FORK:
	  /* multi proc: treat like PTS_EXEC */
	  /*
	   * Pretend this didn't happen, since gdb isn't set up
	   * to deal with stops on fork.
	   */
	  rv = ptrace (PT_CONTSIG, pid, 1, 0);
	  if (-1 == rv)
	    {
	      printf ("PTS_FORK: PT_CONTSIG: error %d\n", errno);
d450 37
a486 23
	  continue;
	case PTS_EXEC:
	  /*
	   * Pretend this is a SIGTRAP.
	   */
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_TRAP;
	  break;
	case PTS_EXIT:
	  /*
	   * Note: we stop before the exit actually occurs.  Extract
	   * the exit code from the uarea.  If we're stopped in the
	   * exit() system call, the exit code will be in
	   * u.u_ap[0].  An exit due to an uncaught signal will have
	   * something else in here, see the comment in the default:
	   * case, below.  Finally,let the process exit.
	   */
	  if (death_by_signal)
	    {
	      status->kind = TARGET_WAITKIND_SIGNALED;
	      status->value.sig = target_signal_from_host (death_by_signal);
	      death_by_signal = 0;
	      break;
d488 9
a496 24
	  xvaloff = (unsigned long) &u.u_ap[0] - (unsigned long) &u;
	  errno = 0;
	  rv = ptrace (PT_RUSER, pid, (char *) xvaloff, 0);
	  status->kind = TARGET_WAITKIND_EXITED;
	  status->value.integer = rv;
	  /*
	   * addr & data to mptrace() don't matter here, since
	   * the process is already dead.
	   */
	  rv = mptrace (XPT_UNDEBUG, pid, 0, 0);
	  if (-1 == rv)
	    {
	      printf ("child_wait: PTS_EXIT: XPT_UNDEBUG: pid %d error %d\n", pid,
		      errno);
	    }
	  break;
	case PTS_WATCHPT_HIT:
	  fatal ("PTS_WATCHPT_HIT\n");
	  break;
	default:
	  /* stopped by signal */
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = target_signal_from_host (pt.ps_reason);
	  death_by_signal = 0;
d498 2
a499 3
	  if (0 == (SIGNALS_DFL_SAFE & sigmask (pt.ps_reason)))
	    {
	      break;
d501 1
a501 1
	  /* else default action of signal is to die */
d503 7
a509 8
	  rv = ptrace (PT_GET_PRSTATUS, pid, (char *) &pstatus, 0);
	  if (-1 == rv)
	    error ("child_wait: signal %d PT_GET_PRSTATUS: %s\n",
		   pt.ps_reason, safe_strerror (errno));
	  if (pstatus.pr_cursig != pt.ps_reason)
	    {
	      printf ("pstatus signal %d, pt signal %d\n",
		      pstatus.pr_cursig, pt.ps_reason);
d511 1
a511 1
	  sa_hand = (int) pstatus.pr_action.sa_handler;
d513 7
a519 7
	  saoff = (unsigned long) &u.u_sa[0] - (unsigned long) &u;
	  saoff += sizeof (struct sigaction) * (pt.ps_reason - 1);
	  errno = 0;
	  sa_hand = ptrace (PT_RUSER, pid, (char *) saoff, 0);
	  if (errno)
	    error ("child_wait: signal %d: RUSER: %s\n",
		   pt.ps_reason, safe_strerror (errno));
d521 3
a523 4
	  if ((int) SIG_DFL == sa_hand)
	    {
	      /* we will be dying */
	      death_by_signal = pt.ps_reason;
d525 2
a526 2
	  break;
	}
d528 1
a528 2
    }
  while (pid != inferior_pid);	/* Some other child died or stopped */
d545 15
a559 17
  do
    {
      pid = wait (&status);
      save_errno = errno;

      if (pid == -1)
	{
	  if (save_errno == EINTR)
	    continue;
	  fprintf (stderr, "Child process unexpectedly missing: %s.\n",
		   safe_strerror (save_errno));
	  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
	  ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
	  return -1;
	}
    }
  while (pid != inferior_pid);	/* Some other child died or stopped */
a563 1

d566 1
d580 4
a583 4
call_mptrace (request, pid, addr, data)
     int request, pid;
     PTRACE_ARG3_TYPE addr;
     int data;
d585 1
a585 1
  return mptrace (request, pid, addr, data);
d607 1
a607 1
  detach (SIGKILL);
d609 2
a610 2
  ptrace (PT_KILL, inferior_pid, 0, 0);
  wait ((int *) NULL);
d640 1
a640 1
    ptrace (PT_SSTEP, pid, (PTRACE_ARG3_TYPE) 1, signal);
d654 2
a655 2
  sigset_t set;
  int rv;
d657 10
a666 12
  rv = mptrace (XPT_DEBUG, pid, 0, 0);
  if (-1 == rv)
    {
      error ("mptrace(XPT_DEBUG): %s", safe_strerror (errno));
    }
  rv = mptrace (XPT_SIGNAL, pid, 0, SIGSTOP);
  if (-1 == rv)
    {
      error ("mptrace(XPT_SIGNAL): %s", safe_strerror (errno));
    }
  attach_flag = 1;
  return pid;
d673 1
a673 1
  int rv;
d675 5
a679 6
  rv = mptrace (XPT_UNDEBUG, inferior_pid, 1, signo);
  if (-1 == rv)
    {
      error ("mptrace(XPT_UNDEBUG): %s", safe_strerror (errno));
    }
  attach_flag = 0;
d688 1
a689 1

d699 1
a699 1

d711 1
a711 1
     struct target_ops *target;	/* ignored */
d715 1
a715 1
  register CORE_ADDR addr = memaddr & -sizeof (PTRACE_XFER_TYPE);
d718 2
a719 2
  = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
  / sizeof (PTRACE_XFER_TYPE);
d722 1
a722 1
  = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
d728 5
a732 6
      if (addr != memaddr || len < (int) sizeof (PTRACE_XFER_TYPE))
	{
	  /* Need part of initial word -- fetch it.  */
	  buffer[0] = ptrace (PT_RTEXT, inferior_pid, (PTRACE_ARG3_TYPE) addr,
			      0);
	}
d759 1
a759 1
	         Gould NP1, at least.  */
d803 40
a842 44
  int rv;
  sigset_t set;
  struct sigaction sact;

  rv = mptrace (XPT_MPDEBUGGER, 0, 0, 0);
  if (-1 == rv)
    {
      fatal ("_initialize_symm_nat(): mptrace(XPT_MPDEBUGGER): %s",
	     safe_strerror (errno));
    }

  /*
   * Under MPDEBUGGER, we get SIGCLHD when a traced process does
   * anything of interest.
   */

  /*
   * Block SIGCHLD.  We leave it blocked all the time, and then
   * call sigsuspend() in child_wait() to wait for the child
   * to do something.  None of these ought to fail, but check anyway.
   */
  sigemptyset (&set);
  rv = sigaddset (&set, SIGCHLD);
  if (-1 == rv)
    {
      fatal ("_initialize_symm_nat(): sigaddset(SIGCHLD): %s",
	     safe_strerror (errno));
    }
  rv = sigprocmask (SIG_BLOCK, &set, (sigset_t *) NULL);
  if (-1 == rv)
    {
      fatal ("_initialize_symm_nat(): sigprocmask(SIG_BLOCK): %s",
	     safe_strerror (errno));
    }

  sact.sa_handler = sigchld_handler;
  sigemptyset (&sact.sa_mask);
  sact.sa_flags = SA_NOCLDWAIT;	/* keep the zombies away */
  rv = sigaction (SIGCHLD, &sact, (struct sigaction *) NULL);
  if (-1 == rv)
    {
      fatal ("_initialize_symm_nat(): sigaction(SIGCHLD): %s",
	     safe_strerror (errno));
    }
@


1.1.1.4
log
@import gdb-1999-08-09 snapshot
@
text
@d546 1
a546 1
	  internal_error ("PTS_WATCHPT_HIT\n");
d876 2
a877 2
      internal_error ("_initialize_symm_nat(): mptrace(XPT_MPDEBUGGER): %s",
		      safe_strerror (errno));
d894 2
a895 2
      internal_error ("_initialize_symm_nat(): sigaddset(SIGCHLD): %s",
		      safe_strerror (errno));
d900 2
a901 2
      internal_error ("_initialize_symm_nat(): sigprocmask(SIG_BLOCK): %s",
		      safe_strerror (errno));
d910 2
a911 2
      internal_error ("_initialize_symm_nat(): sigaction(SIGCHLD): %s",
		      safe_strerror (errno));
@


