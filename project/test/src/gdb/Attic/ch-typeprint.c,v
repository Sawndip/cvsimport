head	1.9;
access;
symbols
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.10
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.8
	carlton_dictionary-20020920-branchpoint:1.8
	gdb_5_3-branch:1.8.0.6
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.4
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.2
	readline_4_3-import-branchpoint:1.8
	gdb_5_2_1-2002-07-23-release:1.6
	kseitz_interps-20020528-branch:1.6.0.8
	kseitz_interps-20020528-branchpoint:1.6
	cagney_regbuf-20020515-branch:1.6.0.6
	cagney_regbuf-20020515-branchpoint:1.6
	jimb-macro-020506-branch:1.6.0.4
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.6
	gdb_5_2-branch:1.6.0.2
	gdb_5_2-2002-03-03-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.8
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.6
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.4
	gdb_5_1-2001-07-29-branchpoint:1.5
	dberlin-typesystem-branch:1.5.0.2
	dberlin-typesystem-branchpoint:1.5
	gdb-post-ptid_t-2001-05-03:1.5
	gdb-pre-ptid_t-2001-05-03:1.5
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.3
	gdb-premipsmulti-2000-06-06-branch:1.1.1.3.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.3
	gdb-post-params-removal-2000-06-04:1.1.1.3
	gdb-pre-params-removal-2000-06-04:1.1.1.3
	gdb-post-params-removal-2000-05-28:1.1.1.3
	gdb-pre-params-removal-2000-05-28:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.9
date	2002.12.16.20.39.01;	author cagney;	state dead;
branches;
next	1.8;

1.8
date	2002.08.01.17.18.32;	author cagney;	state Exp;
branches
	1.8.8.1
	1.8.10.1;
next	1.7;

1.7
date	2002.07.29.22.55.26;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.12.02.11.51;	author fnf;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	2001.03.27.20.36.23;	author jtc;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.03.07.02.57.08;	author jtc;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.06.08.21.06;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.24;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.04.48;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.02.00.21.05;	author jsm;	state Exp;
branches;
next	;

1.5.2.1
date	2001.07.06.19.16.57;	author dberlin;	state Exp;
branches;
next	;

1.6.8.1
date	2002.08.09.18.34.23;	author kseitz;	state Exp;
branches;
next	;

1.8.8.1
date	2002.12.23.19.38.14;	author carlton;	state dead;
branches;
next	;

1.8.10.1
date	2003.12.14.20.27.08;	author drow;	state dead;
branches;
next	;


desc
@@


1.9
log
@2002-12-16  Andrew Cagney  <ac131313@@redhat.com>

	* config/arc/arc.mt, config/arc/tm-arc.h: Delete.
	* config/d30v/d30v.mt, config/d30v/tm-d30v.h: Delete.
	* config/fr30/fr30.mt, config/fr30/tm-fr30.h: Delete.
	* config/i386/i386aix.mh, config/i386/i386aix.mt: Delete.
	* config/i386/i386m3.mh, config/i386/i386m3.mt: Delete.
	* config/i386/i386mach.mh, config/i386/i386os9k.mt: Delete.
	* config/i386/nm-i386aix.h, config/i386/nm-i386mach.h: Delete.
	* config/i386/nm-m3.h, config/i386/tm-i386aix.h: Delete.
	* config/i386/tm-i386m3.h, config/i386/tm-i386mk.h: Delete.
	* config/i386/xm-i386aix.h, config/i386/xm-i386m3.h: Delete.
	* config/i386/xm-i386mach.h, config/i386/xm-i386mk.h: Delete.
	* config/i960/mon960.mt, config/i960/nindy960.mt: Delete.
	* config/i960/tm-i960.h, config/i960/tm-mon960.h: Delete.
	* config/i960/tm-nindy960.h, config/i960/tm-vx960.h: Delete.
	* config/i960/vxworks960.mt, config/m68k/apollo68b.mh: Delete.
	* config/m68k/apollo68b.mt, config/m68k/apollo68v.mh: Delete.
	* config/m68k/hp300bsd.mh, config/m68k/hp300bsd.mt: Delete.
	* config/m68k/hp300hpux.mh, config/m68k/hp300hpux.mt: Delete.
	* config/m88k/delta88.mh, config/m88k/delta88.mt: Delete.
	* config/m88k/delta88v4.mh, config/m88k/delta88v4.mt: Delete.
	* config/m88k/m88k.mh, config/m88k/m88k.mt: Delete.
	* config/m88k/nm-delta88v4.h, config/m88k/nm-m88k.h: Delete.
	* config/m88k/tm-delta88.h, config/m88k/tm-delta88v4.h: Delete.
	* config/m88k/tm-m88k.h, config/m88k/xm-delta88.h: Delete.
	* config/m88k/xm-dgux.h: Delete.
	* fr30-tdep.c, i386aix-nat.c, i386m3-nat.c: Delete.
	* i386mach-nat.c, i960-tdep.c, m88k-nat.c: Delete.
	* os9kread.c, remote-bug.c, remote-nindy.c: Delete.
	* remote-nrom.c, remote-os9k.c, remote-vx960.c: Delete.
	* d30v-tdep.c, arc-tdep.c, cxux-nat.c, dst.h, dstread.c: Delete.
	* ch-exp.c, ch-lang.c, ch-lang.h, ch-typeprint.c: Delete.
	* ch-valprint.c: Delete.
@
text
@// OBSOLETE /* Support for printing Chill types for GDB, the GNU debugger.
// OBSOLETE    Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 2000
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "gdb_obstack.h"
// OBSOLETE #include "bfd.h"		/* Binary File Description */
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "gdbtypes.h"
// OBSOLETE #include "expression.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "language.h"
// OBSOLETE #include "ch-lang.h"
// OBSOLETE #include "typeprint.h"
// OBSOLETE 
// OBSOLETE #include "gdb_string.h"
// OBSOLETE #include <errno.h>
// OBSOLETE 
// OBSOLETE static void chill_type_print_base (struct type *, struct ui_file *, int, int);
// OBSOLETE 
// OBSOLETE void
// OBSOLETE chill_print_type (struct type *type, char *varstring, struct ui_file *stream,
// OBSOLETE 		  int show, int level)
// OBSOLETE {
// OBSOLETE   if (varstring != NULL && *varstring != '\0')
// OBSOLETE     {
// OBSOLETE       fputs_filtered (varstring, stream);
// OBSOLETE       fputs_filtered (" ", stream);
// OBSOLETE     }
// OBSOLETE   chill_type_print_base (type, stream, show, level);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Print the name of the type (or the ultimate pointer target,
// OBSOLETE    function value or array element).
// OBSOLETE 
// OBSOLETE    SHOW nonzero means don't print this type as just its name;
// OBSOLETE    show its real definition even if it has a name.
// OBSOLETE    SHOW zero means print just typename or tag if there is one
// OBSOLETE    SHOW negative means abbreviate structure elements.
// OBSOLETE    SHOW is decremented for printing of structure elements.
// OBSOLETE 
// OBSOLETE    LEVEL is the depth to indent by.
// OBSOLETE    We increase it for some recursive calls.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE chill_type_print_base (struct type *type, struct ui_file *stream, int show,
// OBSOLETE 		       int level)
// OBSOLETE {
// OBSOLETE   register int len;
// OBSOLETE   register int i;
// OBSOLETE   struct type *index_type;
// OBSOLETE   struct type *range_type;
// OBSOLETE   LONGEST low_bound;
// OBSOLETE   LONGEST high_bound;
// OBSOLETE 
// OBSOLETE   QUIT;
// OBSOLETE 
// OBSOLETE   wrap_here ("    ");
// OBSOLETE   if (type == NULL)
// OBSOLETE     {
// OBSOLETE       fputs_filtered ("<type unknown>", stream);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* When SHOW is zero or less, and there is a valid type name, then always
// OBSOLETE      just print the type name directly from the type. */
// OBSOLETE 
// OBSOLETE   if ((show <= 0) && (TYPE_NAME (type) != NULL))
// OBSOLETE     {
// OBSOLETE       fputs_filtered (TYPE_NAME (type), stream);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (TYPE_CODE (type) != TYPE_CODE_TYPEDEF)
// OBSOLETE     CHECK_TYPEDEF (type);
// OBSOLETE 
// OBSOLETE   switch (TYPE_CODE (type))
// OBSOLETE     {
// OBSOLETE     case TYPE_CODE_TYPEDEF:
// OBSOLETE       chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
// OBSOLETE       break;
// OBSOLETE     case TYPE_CODE_PTR:
// OBSOLETE       if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_VOID)
// OBSOLETE 	{
// OBSOLETE 	  fprintf_filtered (stream,
// OBSOLETE 			    TYPE_NAME (type) ? TYPE_NAME (type) : "PTR");
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       fprintf_filtered (stream, "REF ");
// OBSOLETE       chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_BOOL:
// OBSOLETE       /* FIXME: we should probably just print the TYPE_NAME, in case
// OBSOLETE          anyone ever fixes the compiler to give us the real names
// OBSOLETE          in the presence of the chill equivalent of typedef (assuming
// OBSOLETE          there is one).  */
// OBSOLETE       fprintf_filtered (stream,
// OBSOLETE 			TYPE_NAME (type) ? TYPE_NAME (type) : "BOOL");
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_ARRAY:
// OBSOLETE       fputs_filtered ("ARRAY (", stream);
// OBSOLETE       range_type = TYPE_FIELD_TYPE (type, 0);
// OBSOLETE       if (TYPE_CODE (range_type) != TYPE_CODE_RANGE)
// OBSOLETE 	chill_print_type (range_type, "", stream, 0, level);
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  index_type = TYPE_TARGET_TYPE (range_type);
// OBSOLETE 	  low_bound = TYPE_FIELD_BITPOS (range_type, 0);
// OBSOLETE 	  high_bound = TYPE_FIELD_BITPOS (range_type, 1);
// OBSOLETE 	  print_type_scalar (index_type, low_bound, stream);
// OBSOLETE 	  fputs_filtered (":", stream);
// OBSOLETE 	  print_type_scalar (index_type, high_bound, stream);
// OBSOLETE 	}
// OBSOLETE       fputs_filtered (") ", stream);
// OBSOLETE       chill_print_type (TYPE_TARGET_TYPE (type), "", stream, 0, level);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_BITSTRING:
// OBSOLETE       fprintf_filtered (stream, "BOOLS (%d)",
// OBSOLETE 		      TYPE_FIELD_BITPOS (TYPE_FIELD_TYPE (type, 0), 1) + 1);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_SET:
// OBSOLETE       fputs_filtered ("POWERSET ", stream);
// OBSOLETE       chill_print_type (TYPE_INDEX_TYPE (type), "", stream,
// OBSOLETE 			show - 1, level);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_STRING:
// OBSOLETE       range_type = TYPE_FIELD_TYPE (type, 0);
// OBSOLETE       index_type = TYPE_TARGET_TYPE (range_type);
// OBSOLETE       high_bound = TYPE_FIELD_BITPOS (range_type, 1);
// OBSOLETE       fputs_filtered ("CHARS (", stream);
// OBSOLETE       print_type_scalar (index_type, high_bound + 1, stream);
// OBSOLETE       fputs_filtered (")", stream);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_MEMBER:
// OBSOLETE       fprintf_filtered (stream, "MEMBER ");
// OBSOLETE       chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
// OBSOLETE       break;
// OBSOLETE     case TYPE_CODE_REF:
// OBSOLETE       fprintf_filtered (stream, "/*LOC*/ ");
// OBSOLETE       chill_type_print_base (TYPE_TARGET_TYPE (type), stream, show, level);
// OBSOLETE       break;
// OBSOLETE     case TYPE_CODE_FUNC:
// OBSOLETE       fprintf_filtered (stream, "PROC (");
// OBSOLETE       len = TYPE_NFIELDS (type);
// OBSOLETE       for (i = 0; i < len; i++)
// OBSOLETE 	{
// OBSOLETE 	  struct type *param_type = TYPE_FIELD_TYPE (type, i);
// OBSOLETE 	  if (i > 0)
// OBSOLETE 	    {
// OBSOLETE 	      fputs_filtered (", ", stream);
// OBSOLETE 	      wrap_here ("    ");
// OBSOLETE 	    }
// OBSOLETE 	  if (TYPE_CODE (param_type) == TYPE_CODE_REF)
// OBSOLETE 	    {
// OBSOLETE 	      chill_type_print_base (TYPE_TARGET_TYPE (param_type),
// OBSOLETE 				     stream, 0, level);
// OBSOLETE 	      fputs_filtered (" LOC", stream);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    chill_type_print_base (param_type, stream, show, level);
// OBSOLETE 	}
// OBSOLETE       fprintf_filtered (stream, ")");
// OBSOLETE       if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)
// OBSOLETE 	{
// OBSOLETE 	  fputs_filtered (" RETURNS (", stream);
// OBSOLETE 	  chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
// OBSOLETE 	  fputs_filtered (")", stream);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_STRUCT:
// OBSOLETE       if (chill_varying_type (type))
// OBSOLETE 	{
// OBSOLETE 	  chill_type_print_base (TYPE_FIELD_TYPE (type, 1),
// OBSOLETE 				 stream, 0, level);
// OBSOLETE 	  fputs_filtered (" VARYING", stream);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  fprintf_filtered (stream, "STRUCT ");
// OBSOLETE 
// OBSOLETE 	  fprintf_filtered (stream, "(\n");
// OBSOLETE 	  if ((TYPE_NFIELDS (type) == 0) && (TYPE_NFN_FIELDS (type) == 0))
// OBSOLETE 	    {
// OBSOLETE 	      if (TYPE_STUB (type))
// OBSOLETE 		{
// OBSOLETE 		  fprintfi_filtered (level + 4, stream, "<incomplete type>\n");
// OBSOLETE 		}
// OBSOLETE 	      else
// OBSOLETE 		{
// OBSOLETE 		  fprintfi_filtered (level + 4, stream, "<no data fields>\n");
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      len = TYPE_NFIELDS (type);
// OBSOLETE 	      for (i = TYPE_N_BASECLASSES (type); i < len; i++)
// OBSOLETE 		{
// OBSOLETE 		  struct type *field_type = TYPE_FIELD_TYPE (type, i);
// OBSOLETE 		  QUIT;
// OBSOLETE 		  print_spaces_filtered (level + 4, stream);
// OBSOLETE 		  if (TYPE_CODE (field_type) == TYPE_CODE_UNION)
// OBSOLETE 		    {
// OBSOLETE 		      int j;	/* variant number */
// OBSOLETE 		      fputs_filtered ("CASE OF\n", stream);
// OBSOLETE 		      for (j = 0; j < TYPE_NFIELDS (field_type); j++)
// OBSOLETE 			{
// OBSOLETE 			  int k;	/* variant field index */
// OBSOLETE 			  struct type *variant_type
// OBSOLETE 			  = TYPE_FIELD_TYPE (field_type, j);
// OBSOLETE 			  int var_len = TYPE_NFIELDS (variant_type);
// OBSOLETE 			  print_spaces_filtered (level + 4, stream);
// OBSOLETE 			  if (strcmp (TYPE_FIELD_NAME (field_type, j),
// OBSOLETE 				      "else") == 0)
// OBSOLETE 			    fputs_filtered ("ELSE\n", stream);
// OBSOLETE 			  else
// OBSOLETE 			    fputs_filtered (":\n", stream);
// OBSOLETE 			  if (TYPE_CODE (variant_type) != TYPE_CODE_STRUCT)
// OBSOLETE 			    error ("variant record confusion");
// OBSOLETE 			  for (k = 0; k < var_len; k++)
// OBSOLETE 			    {
// OBSOLETE 			      print_spaces_filtered (level + 8, stream);
// OBSOLETE 			      chill_print_type (TYPE_FIELD_TYPE (variant_type, k),
// OBSOLETE 					  TYPE_FIELD_NAME (variant_type, k),
// OBSOLETE 						stream, show - 1, level + 8);
// OBSOLETE 			      if (k < (var_len - 1))
// OBSOLETE 				fputs_filtered (",", stream);
// OBSOLETE 			      fputs_filtered ("\n", stream);
// OBSOLETE 			    }
// OBSOLETE 			}
// OBSOLETE 		      print_spaces_filtered (level + 4, stream);
// OBSOLETE 		      fputs_filtered ("ESAC", stream);
// OBSOLETE 		    }
// OBSOLETE 		  else
// OBSOLETE 		    chill_print_type (field_type,
// OBSOLETE 				      TYPE_FIELD_NAME (type, i),
// OBSOLETE 				      stream, show - 1, level + 4);
// OBSOLETE 		  if (i < (len - 1))
// OBSOLETE 		    {
// OBSOLETE 		      fputs_filtered (",", stream);
// OBSOLETE 		    }
// OBSOLETE 		  fputs_filtered ("\n", stream);
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	  fprintfi_filtered (level, stream, ")");
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_RANGE:
// OBSOLETE       {
// OBSOLETE 	struct type *target = TYPE_TARGET_TYPE (type);
// OBSOLETE 	if (target && TYPE_NAME (target))
// OBSOLETE 	  fputs_filtered (TYPE_NAME (target), stream);
// OBSOLETE 	else
// OBSOLETE 	  fputs_filtered ("RANGE", stream);
// OBSOLETE 	if (target == NULL)
// OBSOLETE 	  target = builtin_type_long;
// OBSOLETE 	fputs_filtered (" (", stream);
// OBSOLETE 	print_type_scalar (target, TYPE_LOW_BOUND (type), stream);
// OBSOLETE 	fputs_filtered (":", stream);
// OBSOLETE 	print_type_scalar (target, TYPE_HIGH_BOUND (type), stream);
// OBSOLETE 	fputs_filtered (")", stream);
// OBSOLETE       }
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_ENUM:
// OBSOLETE       {
// OBSOLETE 	register int lastval = 0;
// OBSOLETE 	fprintf_filtered (stream, "SET (");
// OBSOLETE 	len = TYPE_NFIELDS (type);
// OBSOLETE 	for (i = 0; i < len; i++)
// OBSOLETE 	  {
// OBSOLETE 	    QUIT;
// OBSOLETE 	    if (i)
// OBSOLETE 	      fprintf_filtered (stream, ", ");
// OBSOLETE 	    wrap_here ("    ");
// OBSOLETE 	    fputs_filtered (TYPE_FIELD_NAME (type, i), stream);
// OBSOLETE 	    if (lastval != TYPE_FIELD_BITPOS (type, i))
// OBSOLETE 	      {
// OBSOLETE 		fprintf_filtered (stream, " = %d", TYPE_FIELD_BITPOS (type, i));
// OBSOLETE 		lastval = TYPE_FIELD_BITPOS (type, i);
// OBSOLETE 	      }
// OBSOLETE 	    lastval++;
// OBSOLETE 	  }
// OBSOLETE 	fprintf_filtered (stream, ")");
// OBSOLETE       }
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_VOID:
// OBSOLETE     case TYPE_CODE_UNDEF:
// OBSOLETE     case TYPE_CODE_ERROR:
// OBSOLETE     case TYPE_CODE_UNION:
// OBSOLETE     case TYPE_CODE_METHOD:
// OBSOLETE       error ("missing language support in chill_type_print_base");
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     default:
// OBSOLETE 
// OBSOLETE       /* Handle types not explicitly handled by the other cases,
// OBSOLETE          such as fundamental types.  For these, just print whatever
// OBSOLETE          the type name is, as recorded in the type itself.  If there
// OBSOLETE          is no type name, then complain. */
// OBSOLETE 
// OBSOLETE       if (TYPE_NAME (type) != NULL)
// OBSOLETE 	{
// OBSOLETE 	  fputs_filtered (TYPE_NAME (type), stream);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  error ("Unrecognized type code (%d) in symbol table.",
// OBSOLETE 		 TYPE_CODE (type));
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE }
@


1.8
log
@2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* NEWS: Menion that CHILL has been made obsolete.

* gdbtypes.c (chill_varying_type): Make chill references obsolete.
* gdbserver/Makefile.in: Ditto.
* stabsread.c (read_range_type): Ditto.
* gdbtypes.h: Ditto.
* language.c (binop_type_check): Ditto.
(binop_result_type): Ditto.
(integral_type): Ditto.
(character_type): Ditto.
(string_type): Ditto.
(boolean_type): Ditto.
(structured_type): Ditto.
(lang_bool_type): Ditto.
(binop_type_check): Ditto.
* language.h (_LANG_chill): Ditto.
* dwarfread.c (set_cu_language): Ditto.
* dwarfread.c (CHILL_PRODUCER): Ditto.
* dwarfread.c (handle_producer): Ditto.
* expression.h (enum exp_opcode): Ditto.
* eval.c: Ditto for comments.
* typeprint.c (typedef_print) [_LANG_chill]: Ditto.
* expprint.c (print_subexp): Ditto.
(print_subexp): Ditto.
* valops.c (value_cast): Ditto.
(search_struct_field): Ditto.
* value.h (COERCE_VARYING_ARRAY): Ditto.
* symfile.c (init_filename_language_table): Ditto.
(add_psymbol_with_dem_name_to_list): Ditto.
* valarith.c (value_binop): Ditto.
(value_neg): Ditto.
* valops.c (value_slice): Ditto.
* symtab.h (union language_specific): Ditto.
(SYMBOL_INIT_LANGUAGE_SPECIFIC): Ditto.
(SYMBOL_DEMANGLED_NAME): Ditto.
(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
* defs.h (enum language): Ditto.
* symtab.c (got_symtab): Ditto.
* utils.c (fprintf_symbol_filtered): Ditto.

* ch-typeprint.c: Make file obsolete.
* ch-valprint.c: Make file obsolete.
* ch-lang.h: Make file obsolete.
* ch-exp.c: Make file obsolete.
* ch-lang.c: Make file obsolete.

* Makefile.in (FLAGS_TO_PASS): Do not pass CHILL or CHILLFLAGS or
CHILL_LIB.
(TARGET_FLAGS_TO_PASS): Ditto.
(CHILLFLAGS): Obsolete.
(CHILL): Obsolete.
(CHILL_FOR_TARGET): Obsolete.
(CHILL_LIB): Obsolete.
(SFILES): Remove ch-exp.c, ch-lang.c, ch-typeprint.c and
ch-valprint.c.
(HFILES_NO_SRCDIR): Remove ch-lang.h.
(COMMON_OBS): Remove ch-valprint.o, ch-typeprint.o, ch-exp.o and
ch-lang.o.
(ch-exp.o, ch-lang.o, ch-typeprint.o, ch-valprint.o): Delete
targets.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* stabs.texinfo, gdb.texinfo, gdbint.texinfo: Obsolete references
to CHILL.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* Makefile.in (TARGET_FLAGS_TO_PASS): Remove CHILLFLAGS, CHILL,
CHILL_FOR_TARGET and CHILL_LIB.
* configure.in (configdirs): Remove gdb.chill.
* configure: Regenerate.
* lib/gdb.exp: Obsolete references to chill.
* gdb.fortran/types.exp: Ditto.
* gdb.fortran/exprs.exp: Ditto.
@
text
@@


1.8.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.8.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.7
log
@2002-07-29  Andrew Cagney  <ac131313@@redhat.com>

* gdb_obstack.h: New file.
* symtab.h: Include "gdb_obstack.h" instead of "obstack.h".
(obstack_chunk_alloc, obstack_chunk_free): Delete macros.
* objfiles.h: Include "gdb_obstack.h".
* Makefile.in (gdb_obstack_h): Define.
(symtab_h): Add $(gdb_obstack_h).
(objfiles_h): Add $(gdb_obstack_h).

* objfiles.c: Include "gdb_obstack.h" instead of "obstack.h".
* macrotab.c, cp-valprint.c, dbxread.c: Ditto.
* ch-typeprint.c, ch-valprint.c, dstread.c: Ditto.
* macroexp.c, p-typeprint.c, stabsread.c: Ditto.
* symtab.c, f-typeprint.c, mdebugread.c: Ditto.
* p-valprint.c, symmisc.c, typeprint.c: Ditto.
* symfile.c, coffread.c, c-typeprint.c: Ditto.
* buildsym.c, bcache.c, ada-typeprint.c: Ditto.

* Makefile.in (bcache.o): Update dependencies.
(buildsym.o, c-typeprint.o, ch-typeprint.o): Ditto.
(ch-valprint.o, coffread.o, cp-valprint.o): Ditto.
(dbxread.o, dstread.o, f-typeprint.o): Ditto.
(objfiles.o, p-typeprint.o, p-valprint.o): Ditto.
(stabsread.o, symfile.o, symmisc.o): Ditto.
(symtab.o, typeprint.o, macroexp.o): Ditto.
(macrotab.o, mdebugread.o): Ditto.
(f_lang_h, coff_sym_h, coff_symconst_h): Define.
(coff_ecoff_h, aout_aout64_h): Define.
(aout_stabs_gnu_h, libaout_h): Define.
@
text
@d1 340
a340 340
/* Support for printing Chill types for GDB, the GNU debugger.
   Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 2000
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "gdb_obstack.h"
#include "bfd.h"		/* Binary File Description */
#include "symtab.h"
#include "gdbtypes.h"
#include "expression.h"
#include "value.h"
#include "gdbcore.h"
#include "target.h"
#include "language.h"
#include "ch-lang.h"
#include "typeprint.h"

#include "gdb_string.h"
#include <errno.h>

static void chill_type_print_base (struct type *, struct ui_file *, int, int);

void
chill_print_type (struct type *type, char *varstring, struct ui_file *stream,
		  int show, int level)
{
  if (varstring != NULL && *varstring != '\0')
    {
      fputs_filtered (varstring, stream);
      fputs_filtered (" ", stream);
    }
  chill_type_print_base (type, stream, show, level);
}

/* Print the name of the type (or the ultimate pointer target,
   function value or array element).

   SHOW nonzero means don't print this type as just its name;
   show its real definition even if it has a name.
   SHOW zero means print just typename or tag if there is one
   SHOW negative means abbreviate structure elements.
   SHOW is decremented for printing of structure elements.

   LEVEL is the depth to indent by.
   We increase it for some recursive calls.  */

static void
chill_type_print_base (struct type *type, struct ui_file *stream, int show,
		       int level)
{
  register int len;
  register int i;
  struct type *index_type;
  struct type *range_type;
  LONGEST low_bound;
  LONGEST high_bound;

  QUIT;

  wrap_here ("    ");
  if (type == NULL)
    {
      fputs_filtered ("<type unknown>", stream);
      return;
    }

  /* When SHOW is zero or less, and there is a valid type name, then always
     just print the type name directly from the type. */

  if ((show <= 0) && (TYPE_NAME (type) != NULL))
    {
      fputs_filtered (TYPE_NAME (type), stream);
      return;
    }

  if (TYPE_CODE (type) != TYPE_CODE_TYPEDEF)
    CHECK_TYPEDEF (type);

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_TYPEDEF:
      chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
      break;
    case TYPE_CODE_PTR:
      if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_VOID)
	{
	  fprintf_filtered (stream,
			    TYPE_NAME (type) ? TYPE_NAME (type) : "PTR");
	  break;
	}
      fprintf_filtered (stream, "REF ");
      chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
      break;

    case TYPE_CODE_BOOL:
      /* FIXME: we should probably just print the TYPE_NAME, in case
         anyone ever fixes the compiler to give us the real names
         in the presence of the chill equivalent of typedef (assuming
         there is one).  */
      fprintf_filtered (stream,
			TYPE_NAME (type) ? TYPE_NAME (type) : "BOOL");
      break;

    case TYPE_CODE_ARRAY:
      fputs_filtered ("ARRAY (", stream);
      range_type = TYPE_FIELD_TYPE (type, 0);
      if (TYPE_CODE (range_type) != TYPE_CODE_RANGE)
	chill_print_type (range_type, "", stream, 0, level);
      else
	{
	  index_type = TYPE_TARGET_TYPE (range_type);
	  low_bound = TYPE_FIELD_BITPOS (range_type, 0);
	  high_bound = TYPE_FIELD_BITPOS (range_type, 1);
	  print_type_scalar (index_type, low_bound, stream);
	  fputs_filtered (":", stream);
	  print_type_scalar (index_type, high_bound, stream);
	}
      fputs_filtered (") ", stream);
      chill_print_type (TYPE_TARGET_TYPE (type), "", stream, 0, level);
      break;

    case TYPE_CODE_BITSTRING:
      fprintf_filtered (stream, "BOOLS (%d)",
		      TYPE_FIELD_BITPOS (TYPE_FIELD_TYPE (type, 0), 1) + 1);
      break;

    case TYPE_CODE_SET:
      fputs_filtered ("POWERSET ", stream);
      chill_print_type (TYPE_INDEX_TYPE (type), "", stream,
			show - 1, level);
      break;

    case TYPE_CODE_STRING:
      range_type = TYPE_FIELD_TYPE (type, 0);
      index_type = TYPE_TARGET_TYPE (range_type);
      high_bound = TYPE_FIELD_BITPOS (range_type, 1);
      fputs_filtered ("CHARS (", stream);
      print_type_scalar (index_type, high_bound + 1, stream);
      fputs_filtered (")", stream);
      break;

    case TYPE_CODE_MEMBER:
      fprintf_filtered (stream, "MEMBER ");
      chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
      break;
    case TYPE_CODE_REF:
      fprintf_filtered (stream, "/*LOC*/ ");
      chill_type_print_base (TYPE_TARGET_TYPE (type), stream, show, level);
      break;
    case TYPE_CODE_FUNC:
      fprintf_filtered (stream, "PROC (");
      len = TYPE_NFIELDS (type);
      for (i = 0; i < len; i++)
	{
	  struct type *param_type = TYPE_FIELD_TYPE (type, i);
	  if (i > 0)
	    {
	      fputs_filtered (", ", stream);
	      wrap_here ("    ");
	    }
	  if (TYPE_CODE (param_type) == TYPE_CODE_REF)
	    {
	      chill_type_print_base (TYPE_TARGET_TYPE (param_type),
				     stream, 0, level);
	      fputs_filtered (" LOC", stream);
	    }
	  else
	    chill_type_print_base (param_type, stream, show, level);
	}
      fprintf_filtered (stream, ")");
      if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)
	{
	  fputs_filtered (" RETURNS (", stream);
	  chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
	  fputs_filtered (")", stream);
	}
      break;

    case TYPE_CODE_STRUCT:
      if (chill_varying_type (type))
	{
	  chill_type_print_base (TYPE_FIELD_TYPE (type, 1),
				 stream, 0, level);
	  fputs_filtered (" VARYING", stream);
	}
      else
	{
	  fprintf_filtered (stream, "STRUCT ");

	  fprintf_filtered (stream, "(\n");
	  if ((TYPE_NFIELDS (type) == 0) && (TYPE_NFN_FIELDS (type) == 0))
	    {
	      if (TYPE_STUB (type))
		{
		  fprintfi_filtered (level + 4, stream, "<incomplete type>\n");
		}
	      else
		{
		  fprintfi_filtered (level + 4, stream, "<no data fields>\n");
		}
	    }
	  else
	    {
	      len = TYPE_NFIELDS (type);
	      for (i = TYPE_N_BASECLASSES (type); i < len; i++)
		{
		  struct type *field_type = TYPE_FIELD_TYPE (type, i);
		  QUIT;
		  print_spaces_filtered (level + 4, stream);
		  if (TYPE_CODE (field_type) == TYPE_CODE_UNION)
		    {
		      int j;	/* variant number */
		      fputs_filtered ("CASE OF\n", stream);
		      for (j = 0; j < TYPE_NFIELDS (field_type); j++)
			{
			  int k;	/* variant field index */
			  struct type *variant_type
			  = TYPE_FIELD_TYPE (field_type, j);
			  int var_len = TYPE_NFIELDS (variant_type);
			  print_spaces_filtered (level + 4, stream);
			  if (strcmp (TYPE_FIELD_NAME (field_type, j),
				      "else") == 0)
			    fputs_filtered ("ELSE\n", stream);
			  else
			    fputs_filtered (":\n", stream);
			  if (TYPE_CODE (variant_type) != TYPE_CODE_STRUCT)
			    error ("variant record confusion");
			  for (k = 0; k < var_len; k++)
			    {
			      print_spaces_filtered (level + 8, stream);
			      chill_print_type (TYPE_FIELD_TYPE (variant_type, k),
					  TYPE_FIELD_NAME (variant_type, k),
						stream, show - 1, level + 8);
			      if (k < (var_len - 1))
				fputs_filtered (",", stream);
			      fputs_filtered ("\n", stream);
			    }
			}
		      print_spaces_filtered (level + 4, stream);
		      fputs_filtered ("ESAC", stream);
		    }
		  else
		    chill_print_type (field_type,
				      TYPE_FIELD_NAME (type, i),
				      stream, show - 1, level + 4);
		  if (i < (len - 1))
		    {
		      fputs_filtered (",", stream);
		    }
		  fputs_filtered ("\n", stream);
		}
	    }
	  fprintfi_filtered (level, stream, ")");
	}
      break;

    case TYPE_CODE_RANGE:
      {
	struct type *target = TYPE_TARGET_TYPE (type);
	if (target && TYPE_NAME (target))
	  fputs_filtered (TYPE_NAME (target), stream);
	else
	  fputs_filtered ("RANGE", stream);
	if (target == NULL)
	  target = builtin_type_long;
	fputs_filtered (" (", stream);
	print_type_scalar (target, TYPE_LOW_BOUND (type), stream);
	fputs_filtered (":", stream);
	print_type_scalar (target, TYPE_HIGH_BOUND (type), stream);
	fputs_filtered (")", stream);
      }
      break;

    case TYPE_CODE_ENUM:
      {
	register int lastval = 0;
	fprintf_filtered (stream, "SET (");
	len = TYPE_NFIELDS (type);
	for (i = 0; i < len; i++)
	  {
	    QUIT;
	    if (i)
	      fprintf_filtered (stream, ", ");
	    wrap_here ("    ");
	    fputs_filtered (TYPE_FIELD_NAME (type, i), stream);
	    if (lastval != TYPE_FIELD_BITPOS (type, i))
	      {
		fprintf_filtered (stream, " = %d", TYPE_FIELD_BITPOS (type, i));
		lastval = TYPE_FIELD_BITPOS (type, i);
	      }
	    lastval++;
	  }
	fprintf_filtered (stream, ")");
      }
      break;

    case TYPE_CODE_VOID:
    case TYPE_CODE_UNDEF:
    case TYPE_CODE_ERROR:
    case TYPE_CODE_UNION:
    case TYPE_CODE_METHOD:
      error ("missing language support in chill_type_print_base");
      break;

    default:

      /* Handle types not explicitly handled by the other cases,
         such as fundamental types.  For these, just print whatever
         the type name is, as recorded in the type itself.  If there
         is no type name, then complain. */

      if (TYPE_NAME (type) != NULL)
	{
	  fputs_filtered (TYPE_NAME (type), stream);
	}
      else
	{
	  error ("Unrecognized type code (%d) in symbol table.",
		 TYPE_CODE (type));
	}
      break;
    }
}
@


1.6
log
@Approved by Jim Blandy:

	2001-12-11  Fred Fish  <fnf@@redhat.com>
	* c-typeprint.c (c_type_print_base): Use type flags access macros
	to test bits.
	* ch-typeprint.c (chill_type_print_base): Ditto.
	* ch-valprint.c (chill_val_print): Ditto.
	* d10v-tdep.c (d10v_pointer_to_address): Ditto.
	* dwarf2read.c (dwarf2_add_member_fn): Ditto.
	* dwarfread.c (read_structure_scope): Ditto.
	* gdbtypes.c (create_range_type): Dittol
	(create_set_type): Ditto.
	(check_typedef): Ditto.
	* jv-typeprint.c (java_type_print_base): Ditto.
	* p-typeprint.c (pascal_type_print_base): Ditto
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (read_cfront_member_functions): Ditto.
	(read_member_functions): Ditto.
	(cleanup_undefined_types): Ditto.
	* valprint.c (val_print): Ditto.
	* valops.c (hand_function_call): Remove is_prototyped
	variable and just use type flag test macro directly.
@
text
@d23 1
a23 1
#include "obstack.h"
@


1.6.8.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d1 340
a340 340
// OBSOLETE /* Support for printing Chill types for GDB, the GNU debugger.
// OBSOLETE    Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 2000
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "gdb_obstack.h"
// OBSOLETE #include "bfd.h"		/* Binary File Description */
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "gdbtypes.h"
// OBSOLETE #include "expression.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "language.h"
// OBSOLETE #include "ch-lang.h"
// OBSOLETE #include "typeprint.h"
// OBSOLETE 
// OBSOLETE #include "gdb_string.h"
// OBSOLETE #include <errno.h>
// OBSOLETE 
// OBSOLETE static void chill_type_print_base (struct type *, struct ui_file *, int, int);
// OBSOLETE 
// OBSOLETE void
// OBSOLETE chill_print_type (struct type *type, char *varstring, struct ui_file *stream,
// OBSOLETE 		  int show, int level)
// OBSOLETE {
// OBSOLETE   if (varstring != NULL && *varstring != '\0')
// OBSOLETE     {
// OBSOLETE       fputs_filtered (varstring, stream);
// OBSOLETE       fputs_filtered (" ", stream);
// OBSOLETE     }
// OBSOLETE   chill_type_print_base (type, stream, show, level);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Print the name of the type (or the ultimate pointer target,
// OBSOLETE    function value or array element).
// OBSOLETE 
// OBSOLETE    SHOW nonzero means don't print this type as just its name;
// OBSOLETE    show its real definition even if it has a name.
// OBSOLETE    SHOW zero means print just typename or tag if there is one
// OBSOLETE    SHOW negative means abbreviate structure elements.
// OBSOLETE    SHOW is decremented for printing of structure elements.
// OBSOLETE 
// OBSOLETE    LEVEL is the depth to indent by.
// OBSOLETE    We increase it for some recursive calls.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE chill_type_print_base (struct type *type, struct ui_file *stream, int show,
// OBSOLETE 		       int level)
// OBSOLETE {
// OBSOLETE   register int len;
// OBSOLETE   register int i;
// OBSOLETE   struct type *index_type;
// OBSOLETE   struct type *range_type;
// OBSOLETE   LONGEST low_bound;
// OBSOLETE   LONGEST high_bound;
// OBSOLETE 
// OBSOLETE   QUIT;
// OBSOLETE 
// OBSOLETE   wrap_here ("    ");
// OBSOLETE   if (type == NULL)
// OBSOLETE     {
// OBSOLETE       fputs_filtered ("<type unknown>", stream);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* When SHOW is zero or less, and there is a valid type name, then always
// OBSOLETE      just print the type name directly from the type. */
// OBSOLETE 
// OBSOLETE   if ((show <= 0) && (TYPE_NAME (type) != NULL))
// OBSOLETE     {
// OBSOLETE       fputs_filtered (TYPE_NAME (type), stream);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (TYPE_CODE (type) != TYPE_CODE_TYPEDEF)
// OBSOLETE     CHECK_TYPEDEF (type);
// OBSOLETE 
// OBSOLETE   switch (TYPE_CODE (type))
// OBSOLETE     {
// OBSOLETE     case TYPE_CODE_TYPEDEF:
// OBSOLETE       chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
// OBSOLETE       break;
// OBSOLETE     case TYPE_CODE_PTR:
// OBSOLETE       if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_VOID)
// OBSOLETE 	{
// OBSOLETE 	  fprintf_filtered (stream,
// OBSOLETE 			    TYPE_NAME (type) ? TYPE_NAME (type) : "PTR");
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       fprintf_filtered (stream, "REF ");
// OBSOLETE       chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_BOOL:
// OBSOLETE       /* FIXME: we should probably just print the TYPE_NAME, in case
// OBSOLETE          anyone ever fixes the compiler to give us the real names
// OBSOLETE          in the presence of the chill equivalent of typedef (assuming
// OBSOLETE          there is one).  */
// OBSOLETE       fprintf_filtered (stream,
// OBSOLETE 			TYPE_NAME (type) ? TYPE_NAME (type) : "BOOL");
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_ARRAY:
// OBSOLETE       fputs_filtered ("ARRAY (", stream);
// OBSOLETE       range_type = TYPE_FIELD_TYPE (type, 0);
// OBSOLETE       if (TYPE_CODE (range_type) != TYPE_CODE_RANGE)
// OBSOLETE 	chill_print_type (range_type, "", stream, 0, level);
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  index_type = TYPE_TARGET_TYPE (range_type);
// OBSOLETE 	  low_bound = TYPE_FIELD_BITPOS (range_type, 0);
// OBSOLETE 	  high_bound = TYPE_FIELD_BITPOS (range_type, 1);
// OBSOLETE 	  print_type_scalar (index_type, low_bound, stream);
// OBSOLETE 	  fputs_filtered (":", stream);
// OBSOLETE 	  print_type_scalar (index_type, high_bound, stream);
// OBSOLETE 	}
// OBSOLETE       fputs_filtered (") ", stream);
// OBSOLETE       chill_print_type (TYPE_TARGET_TYPE (type), "", stream, 0, level);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_BITSTRING:
// OBSOLETE       fprintf_filtered (stream, "BOOLS (%d)",
// OBSOLETE 		      TYPE_FIELD_BITPOS (TYPE_FIELD_TYPE (type, 0), 1) + 1);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_SET:
// OBSOLETE       fputs_filtered ("POWERSET ", stream);
// OBSOLETE       chill_print_type (TYPE_INDEX_TYPE (type), "", stream,
// OBSOLETE 			show - 1, level);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_STRING:
// OBSOLETE       range_type = TYPE_FIELD_TYPE (type, 0);
// OBSOLETE       index_type = TYPE_TARGET_TYPE (range_type);
// OBSOLETE       high_bound = TYPE_FIELD_BITPOS (range_type, 1);
// OBSOLETE       fputs_filtered ("CHARS (", stream);
// OBSOLETE       print_type_scalar (index_type, high_bound + 1, stream);
// OBSOLETE       fputs_filtered (")", stream);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_MEMBER:
// OBSOLETE       fprintf_filtered (stream, "MEMBER ");
// OBSOLETE       chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
// OBSOLETE       break;
// OBSOLETE     case TYPE_CODE_REF:
// OBSOLETE       fprintf_filtered (stream, "/*LOC*/ ");
// OBSOLETE       chill_type_print_base (TYPE_TARGET_TYPE (type), stream, show, level);
// OBSOLETE       break;
// OBSOLETE     case TYPE_CODE_FUNC:
// OBSOLETE       fprintf_filtered (stream, "PROC (");
// OBSOLETE       len = TYPE_NFIELDS (type);
// OBSOLETE       for (i = 0; i < len; i++)
// OBSOLETE 	{
// OBSOLETE 	  struct type *param_type = TYPE_FIELD_TYPE (type, i);
// OBSOLETE 	  if (i > 0)
// OBSOLETE 	    {
// OBSOLETE 	      fputs_filtered (", ", stream);
// OBSOLETE 	      wrap_here ("    ");
// OBSOLETE 	    }
// OBSOLETE 	  if (TYPE_CODE (param_type) == TYPE_CODE_REF)
// OBSOLETE 	    {
// OBSOLETE 	      chill_type_print_base (TYPE_TARGET_TYPE (param_type),
// OBSOLETE 				     stream, 0, level);
// OBSOLETE 	      fputs_filtered (" LOC", stream);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    chill_type_print_base (param_type, stream, show, level);
// OBSOLETE 	}
// OBSOLETE       fprintf_filtered (stream, ")");
// OBSOLETE       if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)
// OBSOLETE 	{
// OBSOLETE 	  fputs_filtered (" RETURNS (", stream);
// OBSOLETE 	  chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
// OBSOLETE 	  fputs_filtered (")", stream);
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_STRUCT:
// OBSOLETE       if (chill_varying_type (type))
// OBSOLETE 	{
// OBSOLETE 	  chill_type_print_base (TYPE_FIELD_TYPE (type, 1),
// OBSOLETE 				 stream, 0, level);
// OBSOLETE 	  fputs_filtered (" VARYING", stream);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  fprintf_filtered (stream, "STRUCT ");
// OBSOLETE 
// OBSOLETE 	  fprintf_filtered (stream, "(\n");
// OBSOLETE 	  if ((TYPE_NFIELDS (type) == 0) && (TYPE_NFN_FIELDS (type) == 0))
// OBSOLETE 	    {
// OBSOLETE 	      if (TYPE_STUB (type))
// OBSOLETE 		{
// OBSOLETE 		  fprintfi_filtered (level + 4, stream, "<incomplete type>\n");
// OBSOLETE 		}
// OBSOLETE 	      else
// OBSOLETE 		{
// OBSOLETE 		  fprintfi_filtered (level + 4, stream, "<no data fields>\n");
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      len = TYPE_NFIELDS (type);
// OBSOLETE 	      for (i = TYPE_N_BASECLASSES (type); i < len; i++)
// OBSOLETE 		{
// OBSOLETE 		  struct type *field_type = TYPE_FIELD_TYPE (type, i);
// OBSOLETE 		  QUIT;
// OBSOLETE 		  print_spaces_filtered (level + 4, stream);
// OBSOLETE 		  if (TYPE_CODE (field_type) == TYPE_CODE_UNION)
// OBSOLETE 		    {
// OBSOLETE 		      int j;	/* variant number */
// OBSOLETE 		      fputs_filtered ("CASE OF\n", stream);
// OBSOLETE 		      for (j = 0; j < TYPE_NFIELDS (field_type); j++)
// OBSOLETE 			{
// OBSOLETE 			  int k;	/* variant field index */
// OBSOLETE 			  struct type *variant_type
// OBSOLETE 			  = TYPE_FIELD_TYPE (field_type, j);
// OBSOLETE 			  int var_len = TYPE_NFIELDS (variant_type);
// OBSOLETE 			  print_spaces_filtered (level + 4, stream);
// OBSOLETE 			  if (strcmp (TYPE_FIELD_NAME (field_type, j),
// OBSOLETE 				      "else") == 0)
// OBSOLETE 			    fputs_filtered ("ELSE\n", stream);
// OBSOLETE 			  else
// OBSOLETE 			    fputs_filtered (":\n", stream);
// OBSOLETE 			  if (TYPE_CODE (variant_type) != TYPE_CODE_STRUCT)
// OBSOLETE 			    error ("variant record confusion");
// OBSOLETE 			  for (k = 0; k < var_len; k++)
// OBSOLETE 			    {
// OBSOLETE 			      print_spaces_filtered (level + 8, stream);
// OBSOLETE 			      chill_print_type (TYPE_FIELD_TYPE (variant_type, k),
// OBSOLETE 					  TYPE_FIELD_NAME (variant_type, k),
// OBSOLETE 						stream, show - 1, level + 8);
// OBSOLETE 			      if (k < (var_len - 1))
// OBSOLETE 				fputs_filtered (",", stream);
// OBSOLETE 			      fputs_filtered ("\n", stream);
// OBSOLETE 			    }
// OBSOLETE 			}
// OBSOLETE 		      print_spaces_filtered (level + 4, stream);
// OBSOLETE 		      fputs_filtered ("ESAC", stream);
// OBSOLETE 		    }
// OBSOLETE 		  else
// OBSOLETE 		    chill_print_type (field_type,
// OBSOLETE 				      TYPE_FIELD_NAME (type, i),
// OBSOLETE 				      stream, show - 1, level + 4);
// OBSOLETE 		  if (i < (len - 1))
// OBSOLETE 		    {
// OBSOLETE 		      fputs_filtered (",", stream);
// OBSOLETE 		    }
// OBSOLETE 		  fputs_filtered ("\n", stream);
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	  fprintfi_filtered (level, stream, ")");
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_RANGE:
// OBSOLETE       {
// OBSOLETE 	struct type *target = TYPE_TARGET_TYPE (type);
// OBSOLETE 	if (target && TYPE_NAME (target))
// OBSOLETE 	  fputs_filtered (TYPE_NAME (target), stream);
// OBSOLETE 	else
// OBSOLETE 	  fputs_filtered ("RANGE", stream);
// OBSOLETE 	if (target == NULL)
// OBSOLETE 	  target = builtin_type_long;
// OBSOLETE 	fputs_filtered (" (", stream);
// OBSOLETE 	print_type_scalar (target, TYPE_LOW_BOUND (type), stream);
// OBSOLETE 	fputs_filtered (":", stream);
// OBSOLETE 	print_type_scalar (target, TYPE_HIGH_BOUND (type), stream);
// OBSOLETE 	fputs_filtered (")", stream);
// OBSOLETE       }
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_ENUM:
// OBSOLETE       {
// OBSOLETE 	register int lastval = 0;
// OBSOLETE 	fprintf_filtered (stream, "SET (");
// OBSOLETE 	len = TYPE_NFIELDS (type);
// OBSOLETE 	for (i = 0; i < len; i++)
// OBSOLETE 	  {
// OBSOLETE 	    QUIT;
// OBSOLETE 	    if (i)
// OBSOLETE 	      fprintf_filtered (stream, ", ");
// OBSOLETE 	    wrap_here ("    ");
// OBSOLETE 	    fputs_filtered (TYPE_FIELD_NAME (type, i), stream);
// OBSOLETE 	    if (lastval != TYPE_FIELD_BITPOS (type, i))
// OBSOLETE 	      {
// OBSOLETE 		fprintf_filtered (stream, " = %d", TYPE_FIELD_BITPOS (type, i));
// OBSOLETE 		lastval = TYPE_FIELD_BITPOS (type, i);
// OBSOLETE 	      }
// OBSOLETE 	    lastval++;
// OBSOLETE 	  }
// OBSOLETE 	fprintf_filtered (stream, ")");
// OBSOLETE       }
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_VOID:
// OBSOLETE     case TYPE_CODE_UNDEF:
// OBSOLETE     case TYPE_CODE_ERROR:
// OBSOLETE     case TYPE_CODE_UNION:
// OBSOLETE     case TYPE_CODE_METHOD:
// OBSOLETE       error ("missing language support in chill_type_print_base");
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     default:
// OBSOLETE 
// OBSOLETE       /* Handle types not explicitly handled by the other cases,
// OBSOLETE          such as fundamental types.  For these, just print whatever
// OBSOLETE          the type name is, as recorded in the type itself.  If there
// OBSOLETE          is no type name, then complain. */
// OBSOLETE 
// OBSOLETE       if (TYPE_NAME (type) != NULL)
// OBSOLETE 	{
// OBSOLETE 	  fputs_filtered (TYPE_NAME (type), stream);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  error ("Unrecognized type code (%d) in symbol table.",
// OBSOLETE 		 TYPE_CODE (type));
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE }
@


1.5
log
@* arch-utils.c (#include "gdbthread.h"): Removed.
(#include "symfile.h"): Removed.
(XMALLOC): Removed unused macro.
* breakpoint.c (tbreak_command): Removed local declaration.
(awatch_command, do_enable_breakpoint, set_breakpoint_count):
Remove duplicate declarations.
(bpstat_should_step, bpstat_have_active_hw_watchpoints)
(remove_solib_event_breakpoints): Fix indentation botch.
* c-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* ch-exp.c (ch_terminal_match_float_literal, parse_expr)
(parse_primval, parse_untyped_expr, parse_opt_untyped_expr):
Removed duplicate declarations.
* ch-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* corefile.c (#include "frame.h"): Removed
(#include "symfile.h"): Removed.
(#include "language.h"): Removed.
* dbxread.c (#include "command.h"): Removed.
* environ.c (#include "gdbcore.h"): Removed.
* event-loop.c (#include "top.h"): Removed.
* f-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
(#include "typeprint.h"): Removed.
(#include "frame.h"): Removed.
* gdbtypes.h (print_type_scalar): Removed declaration.
* infcmd.c (#include "completer.h"): Removed.
* language.c (#include "frame.h"): Removed.
* m2-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
* m2-valprint.c (#include "valprint.h"): Removed.
* p-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* p-valprint.c (#include "typeprint.h"): Removed.
* parse.c (#include "linespec.h"): Removed.
* regcache.c (#include "frame.h"): Removed.
* remote.c (#include "frame.h"): Removed.
(getpkt_sane): Make static.
* source.c (#include "completer.h"): Removed.
* stack.c (#include "symfile.h"): Removed.
(#include "objfiles.h"): Removed.
* symfile.c (#include "completer.h"): Removed.
* tracepoint.c (#include "completer.h"): Removed.
* values.c (#include "frame.h"): Removed.
* varobj.c (#include "valprint.h"): Removed.
* wrapper.c (#include "frame.h"): Removed.

* memattr.c (create_mem_region): Removed unused variable.
* remote-nrom.c: Removed spurious semicolon after init_nrom_ops.
-------------------------------------------------------------------
@
text
@d210 1
a210 1
	      if (TYPE_FLAGS (type) & TYPE_FLAG_STUB)
@


1.5.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d71 1
a71 1
  struct range_type *range_type;
d102 1
a102 1
      if (TYPE_CODE (POINTER_TARGET_TYPE (type)) == TYPE_CODE_VOID)
d109 1
a109 1
      chill_type_print_base (POINTER_TARGET_TYPE (type), stream, 0, level);
d123 1
a123 1
      range_type = ARRAY_RANGE_TYPE (type);
d125 1
a125 1
	chill_print_type ((struct type *)range_type, "", stream, 0, level);
d128 3
a130 3
	  index_type = RANGE_INDEX_TYPE (range_type);
	  low_bound = RANGE_LOWER_BOUND (range_type);
	  high_bound = RANGE_UPPER_BOUND (range_type);
d143 1
d146 1
a146 1
      chill_print_type ((struct type *)SET_RANGE_TYPE (type), "", stream,
d149 1
d151 3
a153 3
      range_type = ARRAY_RANGE_TYPE (type);
      index_type = RANGE_INDEX_TYPE (range_type);
      high_bound = RANGE_UPPER_BOUND (range_type);
d165 1
a165 1
      chill_type_print_base (POINTER_TARGET_TYPE (type), stream, show, level);
d169 1
a169 1
      len = FUNCTION_NUM_ARGUMENTS (type);
d172 1
a172 1
	  struct type *param_type = FUNCTION_ARGUMENT_TYPE (type, i);
d180 1
a180 1
	      chill_type_print_base (POINTER_TARGET_TYPE (param_type),
d188 1
a188 1
      if (TYPE_CODE (FUNCTION_RETURN_TYPE (type)) != TYPE_CODE_VOID)
d191 1
a191 1
	  chill_type_print_base (FUNCTION_RETURN_TYPE (type), stream, 0, level);
d284 1
a284 1
	print_type_scalar (target, RANGE_LOWER_BOUND (type), stream);
d286 1
a286 1
	print_type_scalar (target, RANGE_UPPER_BOUND (type), stream);
d295 1
a295 1
	len = ENUM_NUM_VALUES (type);
d302 2
a303 2
	    fputs_filtered (ENUM_VALUE_NAME (type, i), stream);
	    if (lastval != ENUM_VALUE_VALUE (type, i))
d305 2
a306 2
		fprintf_filtered (stream, " = %d", ENUM_VALUE_VALUE (type, i));
		lastval = ENUM_VALUE_VALUE (type, i);
@


1.4
log
@2001-03-06  J.T. Conklin  <jtc@@redback.com>

        * symtab.h (decode_line_1): Removed declaration.

        * symfile.c (#include <assert.h>): Removed.

        * arch-utils.c (#include <ctype.h>): Removed.
        * c-typeprint.c: Likewise.
        * dbxread.c: Likewise.
        * gdbtypes.c: Likewise.
        * target.c: Likewise.
        * os9kread.c: Likewise.

        * c-valprint.c (#include "demangle.h"): Removed.
        * ch-typeprint.c: Likewise.
        * eval.c: Likewise.
        * f-typeprint.c: Likewise.
        * f-valprint.c: Likewise.
        * m2-typeprint.c: Likewise.
        * typeprint.c: Likewise.
        * p-typeprint.c: Likewise.
        * valarith.c: Likewise.
        * valprint.c: Likewise.

        * m2-typeprint.c (#include "gdb_string.h"): Removed.
        * nlmread.c: Likewise.

        * mdebugread.c (#include "gdb-stabs.h"): Removed.
        * minsyms.c: Likewise.
        * mipsread.c: Likewise.
        * nlmread.c: Likewise.

        * m2-typeprint.c (#include "obstack.h"): Removed.
        * m2-valprint.c: Likewise.

        * event-loop.c (#include <setjmp.h>): Removed.
@
text
@a30 2
#include "command.h"
#include "gdbcmd.h"
@


1.3
log
@Update/correct copyright notices.
@
text
@a33 1
#include "demangle.h"
@


1.2
log
@Protoization.
@
text
@d2 2
a3 1
   Copyright 1986, 1988, 1989, 1991, 2000 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1986, 1988, 1989, 1991 Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d40 1
a40 2
static void
chill_type_print_base PARAMS ((struct type *, GDB_FILE *, int, int));
d43 2
a44 6
chill_print_type (type, varstring, stream, show, level)
     struct type *type;
     char *varstring;
     GDB_FILE *stream;
     int show;
     int level;
d67 2
a68 5
chill_type_print_base (type, stream, show, level)
     struct type *type;
     GDB_FILE *stream;
     int show;
     int level;
d100 181
a280 28
      case TYPE_CODE_TYPEDEF:
        chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
	break;
      case TYPE_CODE_PTR:
	if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_VOID)
	  {
	    fprintf_filtered (stream,
			      TYPE_NAME (type) ? TYPE_NAME (type) : "PTR");
	    break;
	  }
	fprintf_filtered (stream, "REF ");
	chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
	break;

      case TYPE_CODE_BOOL:
	/* FIXME: we should probably just print the TYPE_NAME, in case
	   anyone ever fixes the compiler to give us the real names
	   in the presence of the chill equivalent of typedef (assuming
	   there is one).  */
	fprintf_filtered (stream,
			  TYPE_NAME (type) ? TYPE_NAME (type) : "BOOL");
	break;

      case TYPE_CODE_ARRAY:
        fputs_filtered ("ARRAY (", stream);
	range_type = TYPE_FIELD_TYPE (type, 0);
	if (TYPE_CODE (range_type) != TYPE_CODE_RANGE)
	  chill_print_type (range_type, "", stream, 0, level);
d282 7
a288 29
	  {
	    index_type = TYPE_TARGET_TYPE (range_type);
	    low_bound = TYPE_FIELD_BITPOS (range_type, 0);
	    high_bound = TYPE_FIELD_BITPOS (range_type, 1);
	    print_type_scalar (index_type, low_bound, stream);
	    fputs_filtered (":", stream);
	    print_type_scalar (index_type, high_bound, stream);
	  }
	fputs_filtered (") ", stream);
	chill_print_type (TYPE_TARGET_TYPE (type), "", stream, 0, level);
	break;

      case TYPE_CODE_BITSTRING:
        fprintf_filtered (stream, "BOOLS (%d)",
			  TYPE_FIELD_BITPOS (TYPE_FIELD_TYPE(type,0), 1) + 1);
	break;

      case TYPE_CODE_SET:
        fputs_filtered ("POWERSET ", stream);
	chill_print_type (TYPE_INDEX_TYPE (type), "", stream,
			  show - 1, level);
	break;

      case TYPE_CODE_STRING:
	range_type = TYPE_FIELD_TYPE (type, 0);
	index_type = TYPE_TARGET_TYPE (range_type);
	high_bound = TYPE_FIELD_BITPOS (range_type, 1);
        fputs_filtered ("CHARS (", stream);
	print_type_scalar (index_type, high_bound + 1, stream);
d290 2
a291 1
	break;
d293 4
a296 10
      case TYPE_CODE_MEMBER:
	fprintf_filtered (stream, "MEMBER ");
        chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
	break;
      case TYPE_CODE_REF:
	fprintf_filtered (stream, "/*LOC*/ ");
        chill_type_print_base (TYPE_TARGET_TYPE (type), stream, show, level);
	break;
      case TYPE_CODE_FUNC:
	fprintf_filtered (stream, "PROC (");
d300 6
a305 7
	    struct type *param_type = TYPE_FIELD_TYPE (type, i);
	    if (i > 0)
	      {
		fputs_filtered (", ", stream);
		wrap_here ("    ");
	      }
	    if (TYPE_CODE (param_type) == TYPE_CODE_REF)
d307 2
a308 3
		chill_type_print_base (TYPE_TARGET_TYPE (param_type),
				       stream, 0, level);
		fputs_filtered (" LOC", stream);
d310 1
a310 2
	    else
	      chill_type_print_base (param_type, stream, show, level);
d313 2
a314 18
	if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)
	  {
	    fputs_filtered (" RETURNS (", stream);
	    chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
	    fputs_filtered (")", stream);
	  }
	break;

      case TYPE_CODE_STRUCT:
	if (chill_varying_type (type))
	  {
	    chill_type_print_base (TYPE_FIELD_TYPE (type, 1),
				   stream, 0, level);
	    fputs_filtered (" VARYING", stream);
	  }
	else
	  {
	    fprintf_filtered (stream, "STRUCT ");
d316 14
a329 64
	    fprintf_filtered (stream, "(\n");
	    if ((TYPE_NFIELDS (type) == 0) && (TYPE_NFN_FIELDS (type) == 0))
	      {
		if (TYPE_FLAGS (type) & TYPE_FLAG_STUB)
		  {
		    fprintfi_filtered (level + 4, stream, "<incomplete type>\n");
		  }
		else
		  {
		    fprintfi_filtered (level + 4, stream, "<no data fields>\n");
		  }
	      }
	    else
	      {
		len = TYPE_NFIELDS (type);
		for (i = TYPE_N_BASECLASSES (type); i < len; i++)
		  {
		    struct type *field_type = TYPE_FIELD_TYPE (type, i);
		    QUIT;
		    print_spaces_filtered (level + 4, stream);
		    if (TYPE_CODE (field_type) == TYPE_CODE_UNION)
		      { int j; /* variant number */
			fputs_filtered ("CASE OF\n", stream);
			for (j = 0; j < TYPE_NFIELDS (field_type); j++)
			  { int k; /* variant field index */
			    struct type *variant_type
			      = TYPE_FIELD_TYPE (field_type, j);
			    int var_len = TYPE_NFIELDS (variant_type);
			    print_spaces_filtered (level + 4, stream);
			    if (strcmp (TYPE_FIELD_NAME (field_type, j),
					"else") == 0)
			      fputs_filtered ("ELSE\n", stream);
			    else
			      fputs_filtered (":\n", stream);
			    if (TYPE_CODE (variant_type) != TYPE_CODE_STRUCT)
			      error ("variant record confusion");
			    for (k = 0; k < var_len; k++)
			      {
				print_spaces_filtered (level + 8, stream);
				chill_print_type (TYPE_FIELD_TYPE (variant_type, k),
						  TYPE_FIELD_NAME (variant_type, k),
						  stream, show - 1, level + 8);
				if (k < (var_len - 1))
				  fputs_filtered (",", stream);
				fputs_filtered ("\n", stream);
			      }
			  }
			print_spaces_filtered (level + 4, stream);
			fputs_filtered ("ESAC", stream);
		      }
		    else
		      chill_print_type (field_type,
					TYPE_FIELD_NAME (type, i),
					stream, show - 1, level + 4);
		    if (i < (len - 1))
		      {
			fputs_filtered (",", stream);
		      }
		    fputs_filtered ("\n", stream);
		  }
	      }
	    fprintfi_filtered (level, stream, ")");
	  }
	break;
d331 5
a335 18
      case TYPE_CODE_RANGE:
	  {
	    struct type *target = TYPE_TARGET_TYPE (type);
	    if (target && TYPE_NAME (target))
	      fputs_filtered (TYPE_NAME (target), stream);
	    else
	      fputs_filtered ("RANGE", stream);
	    if (target == NULL)
	      target = builtin_type_long;
	    fputs_filtered (" (", stream);
	    print_type_scalar (target, TYPE_LOW_BOUND (type), stream);
	    fputs_filtered (":", stream);
	    print_type_scalar (target, TYPE_HIGH_BOUND (type), stream);
	    fputs_filtered (")", stream);
	  }
	break;

      case TYPE_CODE_ENUM:
d337 2
a338 17
	  register int lastval = 0;
	  fprintf_filtered (stream, "SET (");
	  len = TYPE_NFIELDS (type);
	  for (i = 0; i < len; i++)
	    {
	      QUIT;
	      if (i) fprintf_filtered (stream, ", ");
	      wrap_here ("    ");
	      fputs_filtered (TYPE_FIELD_NAME (type, i), stream);
	      if (lastval != TYPE_FIELD_BITPOS (type, i))
		{
		  fprintf_filtered (stream, " = %d", TYPE_FIELD_BITPOS (type, i));
		  lastval = TYPE_FIELD_BITPOS (type, i);
		}
	      lastval++;
	    }
	  fprintf_filtered (stream, ")");
d340 2
a341 28
	break;

      case TYPE_CODE_VOID:
      case TYPE_CODE_UNDEF:
      case TYPE_CODE_ERROR:
      case TYPE_CODE_UNION:
      case TYPE_CODE_METHOD:
	error ("missing language support in chill_type_print_base");
	break;

      default:

	/* Handle types not explicitly handled by the other cases,
	   such as fundamental types.  For these, just print whatever
	   the type name is, as recorded in the type itself.  If there
	   is no type name, then complain. */

	if (TYPE_NAME (type) != NULL)
	  {
	    fputs_filtered (TYPE_NAME (type), stream);
	  }
	else
	  {
	    error ("Unrecognized type code (%d) in symbol table.",
		   TYPE_CODE (type));
	  }
	break;
      }
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d107 28
a134 181
    case TYPE_CODE_TYPEDEF:
      chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
      break;
    case TYPE_CODE_PTR:
      if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_VOID)
	{
	  fprintf_filtered (stream,
			    TYPE_NAME (type) ? TYPE_NAME (type) : "PTR");
	  break;
	}
      fprintf_filtered (stream, "REF ");
      chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
      break;

    case TYPE_CODE_BOOL:
      /* FIXME: we should probably just print the TYPE_NAME, in case
         anyone ever fixes the compiler to give us the real names
         in the presence of the chill equivalent of typedef (assuming
         there is one).  */
      fprintf_filtered (stream,
			TYPE_NAME (type) ? TYPE_NAME (type) : "BOOL");
      break;

    case TYPE_CODE_ARRAY:
      fputs_filtered ("ARRAY (", stream);
      range_type = TYPE_FIELD_TYPE (type, 0);
      if (TYPE_CODE (range_type) != TYPE_CODE_RANGE)
	chill_print_type (range_type, "", stream, 0, level);
      else
	{
	  index_type = TYPE_TARGET_TYPE (range_type);
	  low_bound = TYPE_FIELD_BITPOS (range_type, 0);
	  high_bound = TYPE_FIELD_BITPOS (range_type, 1);
	  print_type_scalar (index_type, low_bound, stream);
	  fputs_filtered (":", stream);
	  print_type_scalar (index_type, high_bound, stream);
	}
      fputs_filtered (") ", stream);
      chill_print_type (TYPE_TARGET_TYPE (type), "", stream, 0, level);
      break;

    case TYPE_CODE_BITSTRING:
      fprintf_filtered (stream, "BOOLS (%d)",
		      TYPE_FIELD_BITPOS (TYPE_FIELD_TYPE (type, 0), 1) + 1);
      break;

    case TYPE_CODE_SET:
      fputs_filtered ("POWERSET ", stream);
      chill_print_type (TYPE_INDEX_TYPE (type), "", stream,
			show - 1, level);
      break;

    case TYPE_CODE_STRING:
      range_type = TYPE_FIELD_TYPE (type, 0);
      index_type = TYPE_TARGET_TYPE (range_type);
      high_bound = TYPE_FIELD_BITPOS (range_type, 1);
      fputs_filtered ("CHARS (", stream);
      print_type_scalar (index_type, high_bound + 1, stream);
      fputs_filtered (")", stream);
      break;

    case TYPE_CODE_MEMBER:
      fprintf_filtered (stream, "MEMBER ");
      chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
      break;
    case TYPE_CODE_REF:
      fprintf_filtered (stream, "/*LOC*/ ");
      chill_type_print_base (TYPE_TARGET_TYPE (type), stream, show, level);
      break;
    case TYPE_CODE_FUNC:
      fprintf_filtered (stream, "PROC (");
      len = TYPE_NFIELDS (type);
      for (i = 0; i < len; i++)
	{
	  struct type *param_type = TYPE_FIELD_TYPE (type, i);
	  if (i > 0)
	    {
	      fputs_filtered (", ", stream);
	      wrap_here ("    ");
	    }
	  if (TYPE_CODE (param_type) == TYPE_CODE_REF)
	    {
	      chill_type_print_base (TYPE_TARGET_TYPE (param_type),
				     stream, 0, level);
	      fputs_filtered (" LOC", stream);
	    }
	  else
	    chill_type_print_base (param_type, stream, show, level);
	}
      fprintf_filtered (stream, ")");
      if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)
	{
	  fputs_filtered (" RETURNS (", stream);
	  chill_type_print_base (TYPE_TARGET_TYPE (type), stream, 0, level);
	  fputs_filtered (")", stream);
	}
      break;

    case TYPE_CODE_STRUCT:
      if (chill_varying_type (type))
	{
	  chill_type_print_base (TYPE_FIELD_TYPE (type, 1),
				 stream, 0, level);
	  fputs_filtered (" VARYING", stream);
	}
      else
	{
	  fprintf_filtered (stream, "STRUCT ");

	  fprintf_filtered (stream, "(\n");
	  if ((TYPE_NFIELDS (type) == 0) && (TYPE_NFN_FIELDS (type) == 0))
	    {
	      if (TYPE_FLAGS (type) & TYPE_FLAG_STUB)
		{
		  fprintfi_filtered (level + 4, stream, "<incomplete type>\n");
		}
	      else
		{
		  fprintfi_filtered (level + 4, stream, "<no data fields>\n");
		}
	    }
	  else
	    {
	      len = TYPE_NFIELDS (type);
	      for (i = TYPE_N_BASECLASSES (type); i < len; i++)
		{
		  struct type *field_type = TYPE_FIELD_TYPE (type, i);
		  QUIT;
		  print_spaces_filtered (level + 4, stream);
		  if (TYPE_CODE (field_type) == TYPE_CODE_UNION)
		    {
		      int j;	/* variant number */
		      fputs_filtered ("CASE OF\n", stream);
		      for (j = 0; j < TYPE_NFIELDS (field_type); j++)
			{
			  int k;	/* variant field index */
			  struct type *variant_type
			  = TYPE_FIELD_TYPE (field_type, j);
			  int var_len = TYPE_NFIELDS (variant_type);
			  print_spaces_filtered (level + 4, stream);
			  if (strcmp (TYPE_FIELD_NAME (field_type, j),
				      "else") == 0)
			    fputs_filtered ("ELSE\n", stream);
			  else
			    fputs_filtered (":\n", stream);
			  if (TYPE_CODE (variant_type) != TYPE_CODE_STRUCT)
			    error ("variant record confusion");
			  for (k = 0; k < var_len; k++)
			    {
			      print_spaces_filtered (level + 8, stream);
			      chill_print_type (TYPE_FIELD_TYPE (variant_type, k),
					  TYPE_FIELD_NAME (variant_type, k),
						stream, show - 1, level + 8);
			      if (k < (var_len - 1))
				fputs_filtered (",", stream);
			      fputs_filtered ("\n", stream);
			    }
			}
		      print_spaces_filtered (level + 4, stream);
		      fputs_filtered ("ESAC", stream);
		    }
		  else
		    chill_print_type (field_type,
				      TYPE_FIELD_NAME (type, i),
				      stream, show - 1, level + 4);
		  if (i < (len - 1))
		    {
		      fputs_filtered (",", stream);
		    }
		  fputs_filtered ("\n", stream);
		}
	    }
	  fprintfi_filtered (level, stream, ")");
	}
      break;

    case TYPE_CODE_RANGE:
      {
	struct type *target = TYPE_TARGET_TYPE (type);
	if (target && TYPE_NAME (target))
	  fputs_filtered (TYPE_NAME (target), stream);
d136 29
a164 7
	  fputs_filtered ("RANGE", stream);
	if (target == NULL)
	  target = builtin_type_long;
	fputs_filtered (" (", stream);
	print_type_scalar (target, TYPE_LOW_BOUND (type), stream);
	fputs_filtered (":", stream);
	print_type_scalar (target, TYPE_HIGH_BOUND (type), stream);
d166 1
a166 2
      }
      break;
d168 10
a177 4
    case TYPE_CODE_ENUM:
      {
	register int lastval = 0;
	fprintf_filtered (stream, "SET (");
d181 2
a182 6
	    QUIT;
	    if (i)
	      fprintf_filtered (stream, ", ");
	    wrap_here ("    ");
	    fputs_filtered (TYPE_FIELD_NAME (type, i), stream);
	    if (lastval != TYPE_FIELD_BITPOS (type, i))
d184 2
a185 2
		fprintf_filtered (stream, " = %d", TYPE_FIELD_BITPOS (type, i));
		lastval = TYPE_FIELD_BITPOS (type, i);
d187 8
a194 1
	    lastval++;
d197 83
a279 2
      }
      break;
d281 16
a296 14
    case TYPE_CODE_VOID:
    case TYPE_CODE_UNDEF:
    case TYPE_CODE_ERROR:
    case TYPE_CODE_UNION:
    case TYPE_CODE_METHOD:
      error ("missing language support in chill_type_print_base");
      break;

    default:

      /* Handle types not explicitly handled by the other cases,
         such as fundamental types.  For these, just print whatever
         the type name is, as recorded in the type itself.  If there
         is no type name, then complain. */
d298 1
a298 1
      if (TYPE_NAME (type) != NULL)
d300 17
a316 1
	  fputs_filtered (TYPE_NAME (type), stream);
d318 28
a345 7
      else
	{
	  error ("Unrecognized type code (%d) in symbol table.",
		 TYPE_CODE (type));
	}
      break;
    }
@


1.1.1.3
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright 1986, 1988, 1989, 1991, 2000 Free Software Foundation, Inc.
d40 2
a41 1
static void chill_type_print_base (struct type *, struct ui_file *, int, int);
d47 1
a47 1
     struct ui_file *stream;
d74 1
a74 1
     struct ui_file *stream;
@


