head	1.8;
access;
symbols
	gdb_5_2_1-2002-07-23-release:1.7
	gdb_5_2-2002-04-29-release:1.7
	gdb_5_2-branch:1.7.0.2
	gdb_5_2-2002-03-03-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.8
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.6
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.4
	gdb_5_1-2001-07-29-branchpoint:1.5
	dberlin-typesystem-branch:1.5.0.2
	dberlin-typesystem-branchpoint:1.5
	gdb-post-ptid_t-2001-05-03:1.5
	gdb-pre-ptid_t-2001-05-03:1.5
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.5
	gdb-premipsmulti-2000-06-06-branch:1.1.1.5.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.5
	gdb-post-params-removal-2000-06-04:1.1.1.5
	gdb-pre-params-removal-2000-06-04:1.1.1.5
	gdb-post-params-removal-2000-05-28:1.1.1.5
	gdb-pre-params-removal-2000-05-28:1.1.1.5
	gdb_5_0-2000-05-19-release:1.1.1.5
	gdb_4_18_2-2000-05-18-release:1.1.1.5
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.5
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.5
	gdb_5_0-2000-04-10-branch:1.1.1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.5
	repo-unification-2000-02-06:1.1.1.5
	insight-2000-02-04:1.1.1.5
	gdb-2000-02-04:1.1.1.5
	gdb-2000-02-02:1.1.1.5
	gdb-2000-02-01:1.1.1.5
	gdb-2000-01-31:1.1.1.5
	gdb-2000-01-26:1.1.1.5
	gdb-2000-01-24:1.1.1.5
	gdb-2000-01-17:1.1.1.5
	gdb-2000-01-10:1.1.1.5
	gdb-2000-01-05:1.1.1.5
	gdb-1999-12-21:1.1.1.5
	gdb-1999-12-13:1.1.1.5
	gdb-1999-12-07:1.1.1.5
	gdb-1999-12-06:1.1.1.5
	gdb-1999-11-16:1.1.1.5
	gdb-1999-11-08:1.1.1.5
	gdb-1999-11-01:1.1.1.5
	gdb-1999-10-25:1.1.1.5
	gdb-1999-10-18:1.1.1.5
	gdb-1999-10-11:1.1.1.5
	gdb-1999-10-04:1.1.1.5
	gdb-1999-09-28:1.1.1.5
	gdb-1999-09-21:1.1.1.5
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.5
	gdb-1999-08-30:1.1.1.5
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.5
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.3
	gdb-1999-05-10:1.1.1.3
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.8
date	2002.05.04.15.52.37;	author cagney;	state dead;
branches;
next	1.7;

1.7
date	2002.01.06.15.02.00;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.05.04.30.14;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.06.08.21.05;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.08.06.03.52;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.24;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.57;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.33.57;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.23.22;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.42.09;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.03.59;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.09.21.33.17;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.8
log
@* MAINTAINERS: Mark a29k as deleted.
* NEWS: Mention that a29k was removed.  Add OBSOLETE section.
Move new configurations to the top.
* configure.tgt: Remove a29k.
* config/a29k/tm-vx29k.h: Delete.
* config/a29k/vx29k.mt: Delete.
* config/a29k/tm-a29k.h: Delete.
* config/a29k/a29k-udi.mt: Delete.
* config/a29k/a29k.mt: Delete.
* a29k-tdep.c: Delete.
* remote-udi.c: Delete.
* remote-mm.c: Delete.
* remote-eb.c: Delete.
* remote-adapt.c: Delete.
* Makefile.in: Remove obsolete code.
* gdbserver/Makefile.in: Ditto.
* config/s390/s390x.mt: Ditto.
* config/s390/s390.mt: Ditto.
* config/sparc/sparclynx.mh: Ditto.
* config/sparc/linux.mh: Ditto.
* config/pa/hppaosf.mh: Ditto.
* config/pa/hppabsd.mh: Ditto.
* config/ns32k/nbsd.mt: Ditto.
* config/mips/vr5000.mt: Ditto.
* config/m68k/sun3os4.mh: Ditto.
* config/m68k/nbsd.mt: Ditto.
* config/m68k/m68klynx.mh: Ditto.
* config/m32r/m32r.mt: Ditto.
* config/i386/x86-64linux.mt: Ditto.
* config/i386/nbsdelf.mt: Ditto.
* config/i386/nbsd.mt: Ditto.
* config/i386/i386lynx.mh: Ditto.
@
text
@/* OBSOLETE /* Target-machine dependent code for the AMD 29000 */
/* OBSOLETE    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, */
/* OBSOLETE    2001 */
/* OBSOLETE    Free Software Foundation, Inc. */
/* OBSOLETE    Contributed by Cygnus Support.  Written by Jim Kingdon. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "gdbcore.h" */
/* OBSOLETE #include "frame.h" */
/* OBSOLETE #include "value.h" */
/* OBSOLETE #include "symtab.h" */
/* OBSOLETE #include "inferior.h" */
/* OBSOLETE #include "gdbcmd.h" */
/* OBSOLETE #include "regcache.h" */
/* OBSOLETE  */
/* OBSOLETE /* If all these bits in an instruction word are zero, it is a "tag word" */
/* OBSOLETE    which precedes a function entry point and gives stack traceback info. */
/* OBSOLETE    This used to be defined as 0xff000000, but that treated 0x00000deb as */
/* OBSOLETE    a tag word, while it is really used as a breakpoint.  */ */
/* OBSOLETE #define	TAGWORD_ZERO_MASK	0xff00f800 */
/* OBSOLETE  */
/* OBSOLETE extern CORE_ADDR text_start;	/* FIXME, kludge... */ */
/* OBSOLETE  */
/* OBSOLETE /* The user-settable top of the register stack in virtual memory.  We */
/* OBSOLETE    won't attempt to access any stored registers above this address, if set */
/* OBSOLETE    nonzero.  */ */
/* OBSOLETE  */
/* OBSOLETE static CORE_ADDR rstack_high_address = UINT_MAX; */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Should call_function allocate stack space for a struct return?  */ */
/* OBSOLETE /* On the a29k objects over 16 words require the caller to allocate space.  */ */
/* OBSOLETE int */
/* OBSOLETE a29k_use_struct_convention (int gcc_p, struct type *type) */
/* OBSOLETE { */
/* OBSOLETE   return (TYPE_LENGTH (type) > 16 * 4); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Structure to hold cached info about function prologues.  */ */
/* OBSOLETE  */
/* OBSOLETE struct prologue_info */
/* OBSOLETE { */
/* OBSOLETE   CORE_ADDR pc;			/* First addr after fn prologue */ */
/* OBSOLETE   unsigned rsize, msize;	/* register stack frame size, mem stack ditto */ */
/* OBSOLETE   unsigned mfp_used:1;		/* memory frame pointer used */ */
/* OBSOLETE   unsigned rsize_valid:1;	/* Validity bits for the above */ */
/* OBSOLETE   unsigned msize_valid:1; */
/* OBSOLETE   unsigned mfp_valid:1; */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE /* Examine the prologue of a function which starts at PC.  Return */
/* OBSOLETE    the first addess past the prologue.  If MSIZE is non-NULL, then */
/* OBSOLETE    set *MSIZE to the memory stack frame size.  If RSIZE is non-NULL, */
/* OBSOLETE    then set *RSIZE to the register stack frame size (not including */
/* OBSOLETE    incoming arguments and the return address & frame pointer stored */
/* OBSOLETE    with them).  If no prologue is found, *RSIZE is set to zero. */
/* OBSOLETE    If no prologue is found, or a prologue which doesn't involve */
/* OBSOLETE    allocating a memory stack frame, then set *MSIZE to zero. */
/* OBSOLETE  */
/* OBSOLETE    Note that both msize and rsize are in bytes.  This is not consistent */
/* OBSOLETE    with the _User's Manual_ with respect to rsize, but it is much more */
/* OBSOLETE    convenient. */
/* OBSOLETE  */
/* OBSOLETE    If MFP_USED is non-NULL, *MFP_USED is set to nonzero if a memory */
/* OBSOLETE    frame pointer is being used.  */ */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE examine_prologue (CORE_ADDR pc, unsigned *rsize, unsigned *msize, int *mfp_used) */
/* OBSOLETE { */
/* OBSOLETE   long insn; */
/* OBSOLETE   CORE_ADDR p = pc; */
/* OBSOLETE   struct minimal_symbol *msymbol = lookup_minimal_symbol_by_pc (pc); */
/* OBSOLETE   struct prologue_info *mi = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (msymbol != NULL) */
/* OBSOLETE     mi = (struct prologue_info *) msymbol->info; */
/* OBSOLETE  */
/* OBSOLETE   if (mi != 0) */
/* OBSOLETE     { */
/* OBSOLETE       int valid = 1; */
/* OBSOLETE       if (rsize != NULL) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  *rsize = mi->rsize; */
/* OBSOLETE 	  valid &= mi->rsize_valid; */
/* OBSOLETE 	} */
/* OBSOLETE       if (msize != NULL) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  *msize = mi->msize; */
/* OBSOLETE 	  valid &= mi->msize_valid; */
/* OBSOLETE 	} */
/* OBSOLETE       if (mfp_used != NULL) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  *mfp_used = mi->mfp_used; */
/* OBSOLETE 	  valid &= mi->mfp_valid; */
/* OBSOLETE 	} */
/* OBSOLETE       if (valid) */
/* OBSOLETE 	return mi->pc; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   if (rsize != NULL) */
/* OBSOLETE     *rsize = 0; */
/* OBSOLETE   if (msize != NULL) */
/* OBSOLETE     *msize = 0; */
/* OBSOLETE   if (mfp_used != NULL) */
/* OBSOLETE     *mfp_used = 0; */
/* OBSOLETE  */
/* OBSOLETE   /* Prologue must start with subtracting a constant from gr1. */
/* OBSOLETE      Normally this is sub gr1,gr1,<rsize * 4>.  */ */
/* OBSOLETE   insn = read_memory_integer (p, 4); */
/* OBSOLETE   if ((insn & 0xffffff00) != 0x25010100) */
/* OBSOLETE     { */
/* OBSOLETE       /* If the frame is large, instead of a single instruction it */
/* OBSOLETE          might be a pair of instructions: */
/* OBSOLETE          const <reg>, <rsize * 4> */
/* OBSOLETE          sub gr1,gr1,<reg> */
/* OBSOLETE        */ */
/* OBSOLETE       int reg; */
/* OBSOLETE       /* Possible value for rsize.  */ */
/* OBSOLETE       unsigned int rsize0; */
/* OBSOLETE  */
/* OBSOLETE       if ((insn & 0xff000000) != 0x03000000) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  p = pc; */
/* OBSOLETE 	  goto done; */
/* OBSOLETE 	} */
/* OBSOLETE       reg = (insn >> 8) & 0xff; */
/* OBSOLETE       rsize0 = (((insn >> 8) & 0xff00) | (insn & 0xff)); */
/* OBSOLETE       p += 4; */
/* OBSOLETE       insn = read_memory_integer (p, 4); */
/* OBSOLETE       if ((insn & 0xffffff00) != 0x24010100 */
/* OBSOLETE 	  || (insn & 0xff) != reg) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  p = pc; */
/* OBSOLETE 	  goto done; */
/* OBSOLETE 	} */
/* OBSOLETE       if (rsize != NULL) */
/* OBSOLETE 	*rsize = rsize0; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       if (rsize != NULL) */
/* OBSOLETE 	*rsize = (insn & 0xff); */
/* OBSOLETE     } */
/* OBSOLETE   p += 4; */
/* OBSOLETE  */
/* OBSOLETE   /* Next instruction ought to be asgeu V_SPILL,gr1,rab.   */
/* OBSOLETE    * We don't check the vector number to allow for kernel debugging.  The  */
/* OBSOLETE    * kernel will use a different trap number.  */
/* OBSOLETE    * If this insn is missing, we just keep going; Metaware R2.3u compiler */
/* OBSOLETE    * generates prologue that intermixes initializations and puts the asgeu */
/* OBSOLETE    * way down. */
/* OBSOLETE    */ */
/* OBSOLETE   insn = read_memory_integer (p, 4); */
/* OBSOLETE   if ((insn & 0xff00ffff) == (0x5e000100 | RAB_HW_REGNUM)) */
/* OBSOLETE     { */
/* OBSOLETE       p += 4; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Next instruction usually sets the frame pointer (lr1) by adding */
/* OBSOLETE      <size * 4> from gr1.  However, this can (and high C does) be */
/* OBSOLETE      deferred until anytime before the first function call.  So it is */
/* OBSOLETE      OK if we don't see anything which sets lr1.   */
/* OBSOLETE      To allow for alternate register sets (gcc -mkernel-registers)  the msp */
/* OBSOLETE      register number is a compile time constant. */ */
/* OBSOLETE  */
/* OBSOLETE   /* Normally this is just add lr1,gr1,<size * 4>.  */ */
/* OBSOLETE   insn = read_memory_integer (p, 4); */
/* OBSOLETE   if ((insn & 0xffffff00) == 0x15810100) */
/* OBSOLETE     p += 4; */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       /* However, for large frames it can be */
/* OBSOLETE          const <reg>, <size *4> */
/* OBSOLETE          add lr1,gr1,<reg> */
/* OBSOLETE        */ */
/* OBSOLETE       int reg; */
/* OBSOLETE       CORE_ADDR q; */
/* OBSOLETE  */
/* OBSOLETE       if ((insn & 0xff000000) == 0x03000000) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  reg = (insn >> 8) & 0xff; */
/* OBSOLETE 	  q = p + 4; */
/* OBSOLETE 	  insn = read_memory_integer (q, 4); */
/* OBSOLETE 	  if ((insn & 0xffffff00) == 0x14810100 */
/* OBSOLETE 	      && (insn & 0xff) == reg) */
/* OBSOLETE 	    p = q; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Next comes "add lr{<rsize-1>},msp,0", but only if a memory */
/* OBSOLETE      frame pointer is in use.  We just check for add lr<anything>,msp,0; */
/* OBSOLETE      we don't check this rsize against the first instruction, and */
/* OBSOLETE      we don't check that the trace-back tag indicates a memory frame pointer */
/* OBSOLETE      is in use.   */
/* OBSOLETE      To allow for alternate register sets (gcc -mkernel-registers)  the msp */
/* OBSOLETE      register number is a compile time constant. */
/* OBSOLETE  */
/* OBSOLETE      The recommended instruction is actually "sll lr<whatever>,msp,0".  */
/* OBSOLETE      We check for that, too.  Originally Jim Kingdon's code seemed */
/* OBSOLETE      to be looking for a "sub" instruction here, but the mask was set */
/* OBSOLETE      up to lose all the time. */ */
/* OBSOLETE   insn = read_memory_integer (p, 4); */
/* OBSOLETE   if (((insn & 0xff80ffff) == (0x15800000 | (MSP_HW_REGNUM << 8)))	/* add */ */
/* OBSOLETE       || ((insn & 0xff80ffff) == (0x81800000 | (MSP_HW_REGNUM << 8))))	/* sll */ */
/* OBSOLETE     { */
/* OBSOLETE       p += 4; */
/* OBSOLETE       if (mfp_used != NULL) */
/* OBSOLETE 	*mfp_used = 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Next comes a subtraction from msp to allocate a memory frame, */
/* OBSOLETE      but only if a memory frame is */
/* OBSOLETE      being used.  We don't check msize against the trace-back tag. */
/* OBSOLETE  */
/* OBSOLETE      To allow for alternate register sets (gcc -mkernel-registers) the msp */
/* OBSOLETE      register number is a compile time constant. */
/* OBSOLETE  */
/* OBSOLETE      Normally this is just */
/* OBSOLETE      sub msp,msp,<msize> */
/* OBSOLETE    */ */
/* OBSOLETE   insn = read_memory_integer (p, 4); */
/* OBSOLETE   if ((insn & 0xffffff00) == */
/* OBSOLETE       (0x25000000 | (MSP_HW_REGNUM << 16) | (MSP_HW_REGNUM << 8))) */
/* OBSOLETE     { */
/* OBSOLETE       p += 4; */
/* OBSOLETE       if (msize != NULL) */
/* OBSOLETE 	*msize = insn & 0xff; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       /* For large frames, instead of a single instruction it might */
/* OBSOLETE          be */
/* OBSOLETE  */
/* OBSOLETE          const <reg>, <msize> */
/* OBSOLETE          consth <reg>, <msize>     ; optional */
/* OBSOLETE          sub msp,msp,<reg> */
/* OBSOLETE        */ */
/* OBSOLETE       int reg; */
/* OBSOLETE       unsigned msize0; */
/* OBSOLETE       CORE_ADDR q = p; */
/* OBSOLETE  */
/* OBSOLETE       if ((insn & 0xff000000) == 0x03000000) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  reg = (insn >> 8) & 0xff; */
/* OBSOLETE 	  msize0 = ((insn >> 8) & 0xff00) | (insn & 0xff); */
/* OBSOLETE 	  q += 4; */
/* OBSOLETE 	  insn = read_memory_integer (q, 4); */
/* OBSOLETE 	  /* Check for consth.  */ */
/* OBSOLETE 	  if ((insn & 0xff000000) == 0x02000000 */
/* OBSOLETE 	      && (insn & 0x0000ff00) == reg) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      msize0 |= (insn << 8) & 0xff000000; */
/* OBSOLETE 	      msize0 |= (insn << 16) & 0x00ff0000; */
/* OBSOLETE 	      q += 4; */
/* OBSOLETE 	      insn = read_memory_integer (q, 4); */
/* OBSOLETE 	    } */
/* OBSOLETE 	  /* Check for sub msp,msp,<reg>.  */ */
/* OBSOLETE 	  if ((insn & 0xffffff00) == */
/* OBSOLETE 	      (0x24000000 | (MSP_HW_REGNUM << 16) | (MSP_HW_REGNUM << 8)) */
/* OBSOLETE 	      && (insn & 0xff) == reg) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      p = q + 4; */
/* OBSOLETE 	      if (msize != NULL) */
/* OBSOLETE 		*msize = msize0; */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Next instruction might be asgeu V_SPILL,gr1,rab.   */
/* OBSOLETE    * We don't check the vector number to allow for kernel debugging.  The  */
/* OBSOLETE    * kernel will use a different trap number.  */
/* OBSOLETE    * Metaware R2.3u compiler */
/* OBSOLETE    * generates prologue that intermixes initializations and puts the asgeu */
/* OBSOLETE    * way down after everything else. */
/* OBSOLETE    */ */
/* OBSOLETE   insn = read_memory_integer (p, 4); */
/* OBSOLETE   if ((insn & 0xff00ffff) == (0x5e000100 | RAB_HW_REGNUM)) */
/* OBSOLETE     { */
/* OBSOLETE       p += 4; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE done: */
/* OBSOLETE   if (msymbol != NULL) */
/* OBSOLETE     { */
/* OBSOLETE       if (mi == 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* Add a new cache entry.  */ */
/* OBSOLETE 	  mi = (struct prologue_info *) xmalloc (sizeof (struct prologue_info)); */
/* OBSOLETE 	  msymbol->info = (char *) mi; */
/* OBSOLETE 	  mi->rsize_valid = 0; */
/* OBSOLETE 	  mi->msize_valid = 0; */
/* OBSOLETE 	  mi->mfp_valid = 0; */
/* OBSOLETE 	} */
/* OBSOLETE       /* else, cache entry exists, but info is incomplete.  */ */
/* OBSOLETE       mi->pc = p; */
/* OBSOLETE       if (rsize != NULL) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  mi->rsize = *rsize; */
/* OBSOLETE 	  mi->rsize_valid = 1; */
/* OBSOLETE 	} */
/* OBSOLETE       if (msize != NULL) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  mi->msize = *msize; */
/* OBSOLETE 	  mi->msize_valid = 1; */
/* OBSOLETE 	} */
/* OBSOLETE       if (mfp_used != NULL) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  mi->mfp_used = *mfp_used; */
/* OBSOLETE 	  mi->mfp_valid = 1; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   return p; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Advance PC across any function entry prologue instructions */
/* OBSOLETE    to reach some "real" code.  */ */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE a29k_skip_prologue (CORE_ADDR pc) */
/* OBSOLETE { */
/* OBSOLETE   return examine_prologue (pc, NULL, NULL, NULL); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* */
/* OBSOLETE  * Examine the one or two word tag at the beginning of a function. */
/* OBSOLETE  * The tag word is expect to be at 'p', if it is not there, we fail */
/* OBSOLETE  * by returning 0.  The documentation for the tag word was taken from */
/* OBSOLETE  * page 7-15 of the 29050 User's Manual.  We are assuming that the */
/* OBSOLETE  * m bit is in bit 22 of the tag word, which seems to be the agreed upon */
/* OBSOLETE  * convention today (1/15/92). */
/* OBSOLETE  * msize is return in bytes. */
/* OBSOLETE  */ */
/* OBSOLETE  */
/* OBSOLETE static int			/* 0/1 - failure/success of finding the tag word  */ */
/* OBSOLETE examine_tag (CORE_ADDR p, int *is_trans, int *argcount, unsigned *msize, */
/* OBSOLETE 	     int *mfp_used) */
/* OBSOLETE { */
/* OBSOLETE   unsigned int tag1, tag2; */
/* OBSOLETE  */
/* OBSOLETE   tag1 = read_memory_integer (p, 4); */
/* OBSOLETE   if ((tag1 & TAGWORD_ZERO_MASK) != 0)	/* Not a tag word */ */
/* OBSOLETE     return 0; */
/* OBSOLETE   if (tag1 & (1 << 23))		/* A two word tag */ */
/* OBSOLETE     { */
/* OBSOLETE       tag2 = read_memory_integer (p - 4, 4); */
/* OBSOLETE       if (msize) */
/* OBSOLETE 	*msize = tag2 * 2; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     /* A one word tag */ */
/* OBSOLETE     { */
/* OBSOLETE       if (msize) */
/* OBSOLETE 	*msize = tag1 & 0x7ff; */
/* OBSOLETE     } */
/* OBSOLETE   if (is_trans) */
/* OBSOLETE     *is_trans = ((tag1 & (1 << 21)) ? 1 : 0); */
/* OBSOLETE   /* Note that this includes the frame pointer and the return address */
/* OBSOLETE      register, so the actual number of registers of arguments is two less. */
/* OBSOLETE      argcount can be zero, however, sometimes, for strange assembler */
/* OBSOLETE      routines.  */ */
/* OBSOLETE   if (argcount) */
/* OBSOLETE     *argcount = (tag1 >> 16) & 0x1f; */
/* OBSOLETE   if (mfp_used) */
/* OBSOLETE     *mfp_used = ((tag1 & (1 << 22)) ? 1 : 0); */
/* OBSOLETE   return 1; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Initialize the frame.  In addition to setting "extra" frame info, */
/* OBSOLETE    we also set ->frame because we use it in a nonstandard way, and ->pc */
/* OBSOLETE    because we need to know it to get the other stuff.  See the diagram */
/* OBSOLETE    of stacks and the frame cache in tm-a29k.h for more detail.  */ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE init_frame_info (int innermost_frame, struct frame_info *frame) */
/* OBSOLETE { */
/* OBSOLETE   CORE_ADDR p; */
/* OBSOLETE   long insn; */
/* OBSOLETE   unsigned rsize; */
/* OBSOLETE   unsigned msize; */
/* OBSOLETE   int mfp_used, trans; */
/* OBSOLETE   struct symbol *func; */
/* OBSOLETE  */
/* OBSOLETE   p = frame->pc; */
/* OBSOLETE  */
/* OBSOLETE   if (innermost_frame) */
/* OBSOLETE     frame->frame = read_register (GR1_REGNUM); */
/* OBSOLETE   else */
/* OBSOLETE     frame->frame = frame->next->frame + frame->next->rsize; */
/* OBSOLETE  */
/* OBSOLETE #if 0				/* CALL_DUMMY_LOCATION == ON_STACK */ */
/* OBSOLETE   This wont work; */
/* OBSOLETE #else */
/* OBSOLETE   if (PC_IN_CALL_DUMMY (p, 0, 0)) */
/* OBSOLETE #endif */
/* OBSOLETE     { */
/* OBSOLETE       frame->rsize = DUMMY_FRAME_RSIZE; */
/* OBSOLETE       /* This doesn't matter since we never try to get locals or args */
/* OBSOLETE          from a dummy frame.  */ */
/* OBSOLETE       frame->msize = 0; */
/* OBSOLETE       /* Dummy frames always use a memory frame pointer.  */ */
/* OBSOLETE       frame->saved_msp = */
/* OBSOLETE 	read_register_stack_integer (frame->frame + DUMMY_FRAME_RSIZE - 4, 4); */
/* OBSOLETE       frame->flags |= (TRANSPARENT_FRAME | MFP_USED); */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   func = find_pc_function (p); */
/* OBSOLETE   if (func != NULL) */
/* OBSOLETE     p = BLOCK_START (SYMBOL_BLOCK_VALUE (func)); */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       /* Search backward to find the trace-back tag.  However, */
/* OBSOLETE          do not trace back beyond the start of the text segment */
/* OBSOLETE          (just as a sanity check to avoid going into never-never land).  */ */
/* OBSOLETE #if 1 */
/* OBSOLETE       while (p >= text_start */
/* OBSOLETE 	  && ((insn = read_memory_integer (p, 4)) & TAGWORD_ZERO_MASK) != 0) */
/* OBSOLETE 	p -= 4; */
/* OBSOLETE #else /* 0 */ */
/* OBSOLETE       char pat[4] = */
/* OBSOLETE       {0, 0, 0, 0}; */
/* OBSOLETE       char mask[4]; */
/* OBSOLETE       char insn_raw[4]; */
/* OBSOLETE       store_unsigned_integer (mask, 4, TAGWORD_ZERO_MASK); */
/* OBSOLETE       /* Enable this once target_search is enabled and tested.  */ */
/* OBSOLETE       target_search (4, pat, mask, p, -4, text_start, p + 1, &p, &insn_raw); */
/* OBSOLETE       insn = extract_unsigned_integer (insn_raw, 4); */
/* OBSOLETE #endif /* 0 */ */
/* OBSOLETE  */
/* OBSOLETE       if (p < text_start) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* Couldn't find the trace-back tag. */
/* OBSOLETE 	     Something strange is going on.  */ */
/* OBSOLETE 	  frame->saved_msp = 0; */
/* OBSOLETE 	  frame->rsize = 0; */
/* OBSOLETE 	  frame->msize = 0; */
/* OBSOLETE 	  frame->flags = TRANSPARENT_FRAME; */
/* OBSOLETE 	  return; */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	/* Advance to the first word of the function, i.e. the word */
/* OBSOLETE 	   after the trace-back tag.  */ */
/* OBSOLETE 	p += 4; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* We've found the start of the function.   */
/* OBSOLETE      Try looking for a tag word that indicates whether there is a */
/* OBSOLETE      memory frame pointer and what the memory stack allocation is. */
/* OBSOLETE      If one doesn't exist, try using a more exhaustive search of */
/* OBSOLETE      the prologue.  */ */
/* OBSOLETE  */
/* OBSOLETE   if (examine_tag (p - 4, &trans, (int *) NULL, &msize, &mfp_used))	/* Found good tag */ */
/* OBSOLETE     examine_prologue (p, &rsize, 0, 0); */
/* OBSOLETE   else				/* No tag try prologue */ */
/* OBSOLETE     examine_prologue (p, &rsize, &msize, &mfp_used); */
/* OBSOLETE  */
/* OBSOLETE   frame->rsize = rsize; */
/* OBSOLETE   frame->msize = msize; */
/* OBSOLETE   frame->flags = 0; */
/* OBSOLETE   if (mfp_used) */
/* OBSOLETE     frame->flags |= MFP_USED; */
/* OBSOLETE   if (trans) */
/* OBSOLETE     frame->flags |= TRANSPARENT_FRAME; */
/* OBSOLETE   if (innermost_frame) */
/* OBSOLETE     { */
/* OBSOLETE       frame->saved_msp = read_register (MSP_REGNUM) + msize; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       if (mfp_used) */
/* OBSOLETE 	frame->saved_msp = */
/* OBSOLETE 	  read_register_stack_integer (frame->frame + rsize - 4, 4); */
/* OBSOLETE       else */
/* OBSOLETE 	frame->saved_msp = frame->next->saved_msp + msize; */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE init_extra_frame_info (struct frame_info *frame) */
/* OBSOLETE { */
/* OBSOLETE   if (frame->next == 0) */
/* OBSOLETE     /* Assume innermost frame.  May produce strange results for "info frame" */
/* OBSOLETE        but there isn't any way to tell the difference.  */ */
/* OBSOLETE     init_frame_info (1, frame); */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       /* We're in get_prev_frame. */
/* OBSOLETE          Take care of everything in init_frame_pc.  */ */
/* OBSOLETE       ; */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE init_frame_pc (int fromleaf, struct frame_info *frame) */
/* OBSOLETE { */
/* OBSOLETE   frame->pc = (fromleaf ? SAVED_PC_AFTER_CALL (frame->next) : */
/* OBSOLETE 	       frame->next ? FRAME_SAVED_PC (frame->next) : read_pc ()); */
/* OBSOLETE   init_frame_info (fromleaf, frame); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Local variables (i.e. LOC_LOCAL) are on the memory stack, with their */
/* OBSOLETE    offsets being relative to the memory stack pointer (high C) or */
/* OBSOLETE    saved_msp (gcc).  */ */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE frame_locals_address (struct frame_info *fi) */
/* OBSOLETE { */
/* OBSOLETE   if (fi->flags & MFP_USED) */
/* OBSOLETE     return fi->saved_msp; */
/* OBSOLETE   else */
/* OBSOLETE     return fi->saved_msp - fi->msize; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Routines for reading the register stack.  The caller gets to treat */
/* OBSOLETE    the register stack as a uniform stack in memory, from address $gr1 */
/* OBSOLETE    straight through $rfb and beyond.  */ */
/* OBSOLETE  */
/* OBSOLETE /* Analogous to read_memory except the length is understood to be 4. */
/* OBSOLETE    Also, myaddr can be NULL (meaning don't bother to read), and */
/* OBSOLETE    if actual_mem_addr is non-NULL, store there the address that it */
/* OBSOLETE    was fetched from (or if from a register the offset within */
/* OBSOLETE    registers).  Set *LVAL to lval_memory or lval_register, depending */
/* OBSOLETE    on where it came from.  The contents written into MYADDR are in */
/* OBSOLETE    target format.  */ */
/* OBSOLETE void */
/* OBSOLETE read_register_stack (CORE_ADDR memaddr, char *myaddr, */
/* OBSOLETE 		     CORE_ADDR *actual_mem_addr, enum lval_type *lval) */
/* OBSOLETE { */
/* OBSOLETE   long rfb = read_register (RFB_REGNUM); */
/* OBSOLETE   long rsp = read_register (RSP_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE   /* If we don't do this 'info register' stops in the middle. */ */
/* OBSOLETE   if (memaddr >= rstack_high_address) */
/* OBSOLETE     { */
/* OBSOLETE       /* a bogus value */ */
/* OBSOLETE       static char val[] = */
/* OBSOLETE       {~0, ~0, ~0, ~0}; */
/* OBSOLETE       /* It's in a local register, but off the end of the stack.  */ */
/* OBSOLETE       int regnum = (memaddr - rsp) / 4 + LR0_REGNUM; */
/* OBSOLETE       if (myaddr != NULL) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* Provide bogusness */ */
/* OBSOLETE 	  memcpy (myaddr, val, 4); */
/* OBSOLETE 	} */
/* OBSOLETE       supply_register (regnum, val);	/* More bogusness */ */
/* OBSOLETE       if (lval != NULL) */
/* OBSOLETE 	*lval = lval_register; */
/* OBSOLETE       if (actual_mem_addr != NULL) */
/* OBSOLETE 	*actual_mem_addr = REGISTER_BYTE (regnum); */
/* OBSOLETE     } */
/* OBSOLETE   /* If it's in the part of the register stack that's in real registers, */
/* OBSOLETE      get the value from the registers.  If it's anywhere else in memory */
/* OBSOLETE      (e.g. in another thread's saved stack), skip this part and get */
/* OBSOLETE      it from real live memory.  */ */
/* OBSOLETE   else if (memaddr < rfb && memaddr >= rsp) */
/* OBSOLETE     { */
/* OBSOLETE       /* It's in a register.  */ */
/* OBSOLETE       int regnum = (memaddr - rsp) / 4 + LR0_REGNUM; */
/* OBSOLETE       if (regnum > LR0_REGNUM + 127) */
/* OBSOLETE 	error ("Attempt to read register stack out of range."); */
/* OBSOLETE       if (myaddr != NULL) */
/* OBSOLETE 	read_register_gen (regnum, myaddr); */
/* OBSOLETE       if (lval != NULL) */
/* OBSOLETE 	*lval = lval_register; */
/* OBSOLETE       if (actual_mem_addr != NULL) */
/* OBSOLETE 	*actual_mem_addr = REGISTER_BYTE (regnum); */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       /* It's in the memory portion of the register stack.  */ */
/* OBSOLETE       if (myaddr != NULL) */
/* OBSOLETE 	read_memory (memaddr, myaddr, 4); */
/* OBSOLETE       if (lval != NULL) */
/* OBSOLETE 	*lval = lval_memory; */
/* OBSOLETE       if (actual_mem_addr != NULL) */
/* OBSOLETE 	*actual_mem_addr = memaddr; */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Analogous to read_memory_integer */
/* OBSOLETE    except the length is understood to be 4.  */ */
/* OBSOLETE long */
/* OBSOLETE read_register_stack_integer (CORE_ADDR memaddr, int len) */
/* OBSOLETE { */
/* OBSOLETE   char buf[4]; */
/* OBSOLETE   read_register_stack (memaddr, buf, NULL, NULL); */
/* OBSOLETE   return extract_signed_integer (buf, 4); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Copy 4 bytes from GDB memory at MYADDR into inferior memory */
/* OBSOLETE    at MEMADDR and put the actual address written into in */
/* OBSOLETE    *ACTUAL_MEM_ADDR.  */ */
/* OBSOLETE static void */
/* OBSOLETE write_register_stack (CORE_ADDR memaddr, char *myaddr, */
/* OBSOLETE 		      CORE_ADDR *actual_mem_addr) */
/* OBSOLETE { */
/* OBSOLETE   long rfb = read_register (RFB_REGNUM); */
/* OBSOLETE   long rsp = read_register (RSP_REGNUM); */
/* OBSOLETE   /* If we don't do this 'info register' stops in the middle. */ */
/* OBSOLETE   if (memaddr >= rstack_high_address) */
/* OBSOLETE     { */
/* OBSOLETE       /* It's in a register, but off the end of the stack.  */ */
/* OBSOLETE       if (actual_mem_addr != NULL) */
/* OBSOLETE 	*actual_mem_addr = 0; */
/* OBSOLETE     } */
/* OBSOLETE   else if (memaddr < rfb) */
/* OBSOLETE     { */
/* OBSOLETE       /* It's in a register.  */ */
/* OBSOLETE       int regnum = (memaddr - rsp) / 4 + LR0_REGNUM; */
/* OBSOLETE       if (regnum < LR0_REGNUM || regnum > LR0_REGNUM + 127) */
/* OBSOLETE 	error ("Attempt to read register stack out of range."); */
/* OBSOLETE       if (myaddr != NULL) */
/* OBSOLETE 	write_register (regnum, *(long *) myaddr); */
/* OBSOLETE       if (actual_mem_addr != NULL) */
/* OBSOLETE 	*actual_mem_addr = 0; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       /* It's in the memory portion of the register stack.  */ */
/* OBSOLETE       if (myaddr != NULL) */
/* OBSOLETE 	write_memory (memaddr, myaddr, 4); */
/* OBSOLETE       if (actual_mem_addr != NULL) */
/* OBSOLETE 	*actual_mem_addr = memaddr; */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Find register number REGNUM relative to FRAME and put its */
/* OBSOLETE    (raw) contents in *RAW_BUFFER.  Set *OPTIMIZED if the variable */
/* OBSOLETE    was optimized out (and thus can't be fetched).  If the variable */
/* OBSOLETE    was fetched from memory, set *ADDRP to where it was fetched from, */
/* OBSOLETE    otherwise it was fetched from a register. */
/* OBSOLETE  */
/* OBSOLETE    The argument RAW_BUFFER must point to aligned memory.  */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE a29k_get_saved_register (char *raw_buffer, int *optimized, CORE_ADDR *addrp, */
/* OBSOLETE 			 struct frame_info *frame, int regnum, */
/* OBSOLETE 			 enum lval_type *lvalp) */
/* OBSOLETE { */
/* OBSOLETE   struct frame_info *fi; */
/* OBSOLETE   CORE_ADDR addr; */
/* OBSOLETE   enum lval_type lval; */
/* OBSOLETE  */
/* OBSOLETE   if (!target_has_registers) */
/* OBSOLETE     error ("No registers."); */
/* OBSOLETE  */
/* OBSOLETE   /* Probably now redundant with the target_has_registers check.  */ */
/* OBSOLETE   if (frame == 0) */
/* OBSOLETE     return; */
/* OBSOLETE  */
/* OBSOLETE   /* Once something has a register number, it doesn't get optimized out.  */ */
/* OBSOLETE   if (optimized != NULL) */
/* OBSOLETE     *optimized = 0; */
/* OBSOLETE   if (regnum == RSP_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       if (raw_buffer != NULL) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), frame->frame); */
/* OBSOLETE 	} */
/* OBSOLETE       if (lvalp != NULL) */
/* OBSOLETE 	*lvalp = not_lval; */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE   else if (regnum == PC_REGNUM && frame->next != NULL) */
/* OBSOLETE     { */
/* OBSOLETE       if (raw_buffer != NULL) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), frame->pc); */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       /* Not sure we have to do this.  */ */
/* OBSOLETE       if (lvalp != NULL) */
/* OBSOLETE 	*lvalp = not_lval; */
/* OBSOLETE  */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE   else if (regnum == MSP_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       if (raw_buffer != NULL) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  if (frame->next != NULL) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), */
/* OBSOLETE 			     frame->next->saved_msp); */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    read_register_gen (MSP_REGNUM, raw_buffer); */
/* OBSOLETE 	} */
/* OBSOLETE       /* The value may have been computed, not fetched.  */ */
/* OBSOLETE       if (lvalp != NULL) */
/* OBSOLETE 	*lvalp = not_lval; */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE   else if (regnum < LR0_REGNUM || regnum >= LR0_REGNUM + 128) */
/* OBSOLETE     { */
/* OBSOLETE       /* These registers are not saved over procedure calls, */
/* OBSOLETE          so just print out the current values.  */ */
/* OBSOLETE       if (raw_buffer != NULL) */
/* OBSOLETE 	read_register_gen (regnum, raw_buffer); */
/* OBSOLETE       if (lvalp != NULL) */
/* OBSOLETE 	*lvalp = lval_register; */
/* OBSOLETE       if (addrp != NULL) */
/* OBSOLETE 	*addrp = REGISTER_BYTE (regnum); */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   addr = frame->frame + (regnum - LR0_REGNUM) * 4; */
/* OBSOLETE   if (raw_buffer != NULL) */
/* OBSOLETE     read_register_stack (addr, raw_buffer, &addr, &lval); */
/* OBSOLETE   if (lvalp != NULL) */
/* OBSOLETE     *lvalp = lval; */
/* OBSOLETE   if (addrp != NULL) */
/* OBSOLETE     *addrp = addr; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Discard from the stack the innermost frame, */
/* OBSOLETE    restoring all saved registers.  */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE pop_frame (void) */
/* OBSOLETE { */
/* OBSOLETE   struct frame_info *frame = get_current_frame (); */
/* OBSOLETE   CORE_ADDR rfb = read_register (RFB_REGNUM); */
/* OBSOLETE   CORE_ADDR gr1 = frame->frame + frame->rsize; */
/* OBSOLETE   CORE_ADDR lr1; */
/* OBSOLETE   CORE_ADDR original_lr0; */
/* OBSOLETE   int must_fix_lr0 = 0; */
/* OBSOLETE   int i; */
/* OBSOLETE  */
/* OBSOLETE   /* If popping a dummy frame, need to restore registers.  */ */
/* OBSOLETE   if (PC_IN_CALL_DUMMY (read_register (PC_REGNUM), */
/* OBSOLETE 			read_register (SP_REGNUM), */
/* OBSOLETE 			FRAME_FP (frame))) */
/* OBSOLETE     { */
/* OBSOLETE       int lrnum = LR0_REGNUM + DUMMY_ARG / 4; */
/* OBSOLETE       for (i = 0; i < DUMMY_SAVE_SR128; ++i) */
/* OBSOLETE 	write_register (SR_REGNUM (i + 128), read_register (lrnum++)); */
/* OBSOLETE       for (i = 0; i < DUMMY_SAVE_SR160; ++i) */
/* OBSOLETE 	write_register (SR_REGNUM (i + 160), read_register (lrnum++)); */
/* OBSOLETE       for (i = 0; i < DUMMY_SAVE_GREGS; ++i) */
/* OBSOLETE 	write_register (RETURN_REGNUM + i, read_register (lrnum++)); */
/* OBSOLETE       /* Restore the PCs and prepare to restore LR0.  */ */
/* OBSOLETE       write_register (PC_REGNUM, read_register (lrnum++)); */
/* OBSOLETE       write_register (NPC_REGNUM, read_register (lrnum++)); */
/* OBSOLETE       write_register (PC2_REGNUM, read_register (lrnum++)); */
/* OBSOLETE       original_lr0 = read_register (lrnum++); */
/* OBSOLETE       must_fix_lr0 = 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Restore the memory stack pointer.  */ */
/* OBSOLETE   write_register (MSP_REGNUM, frame->saved_msp); */
/* OBSOLETE   /* Restore the register stack pointer.  */ */
/* OBSOLETE   write_register (GR1_REGNUM, gr1); */
/* OBSOLETE  */
/* OBSOLETE   /* If we popped a dummy frame, restore lr0 now that gr1 has been restored. */ */
/* OBSOLETE   if (must_fix_lr0) */
/* OBSOLETE     write_register (LR0_REGNUM, original_lr0); */
/* OBSOLETE  */
/* OBSOLETE   /* Check whether we need to fill registers.  */ */
/* OBSOLETE   lr1 = read_register (LR0_REGNUM + 1); */
/* OBSOLETE   if (lr1 > rfb) */
/* OBSOLETE     { */
/* OBSOLETE       /* Fill.  */ */
/* OBSOLETE       int num_bytes = lr1 - rfb; */
/* OBSOLETE       int i; */
/* OBSOLETE       long word; */
/* OBSOLETE  */
/* OBSOLETE       write_register (RAB_REGNUM, read_register (RAB_REGNUM) + num_bytes); */
/* OBSOLETE       write_register (RFB_REGNUM, lr1); */
/* OBSOLETE       for (i = 0; i < num_bytes; i += 4) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* Note: word is in host byte order.  */ */
/* OBSOLETE 	  word = read_memory_integer (rfb + i, 4); */
/* OBSOLETE 	  write_register (LR0_REGNUM + ((rfb - gr1) % 0x80) + i / 4, word); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   flush_cached_frames (); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Push an empty stack frame, to record the current PC, etc.  */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE push_dummy_frame (void) */
/* OBSOLETE { */
/* OBSOLETE   long w; */
/* OBSOLETE   CORE_ADDR rab, gr1; */
/* OBSOLETE   CORE_ADDR msp = read_register (MSP_REGNUM); */
/* OBSOLETE   int lrnum, i; */
/* OBSOLETE   CORE_ADDR original_lr0; */
/* OBSOLETE  */
/* OBSOLETE   /* Read original lr0 before changing gr1.  This order isn't really needed */
/* OBSOLETE      since GDB happens to have a snapshot of all the regs and doesn't toss */
/* OBSOLETE      it when gr1 is changed.  But it's The Right Thing To Do.  */ */
/* OBSOLETE   original_lr0 = read_register (LR0_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE   /* Allocate the new frame. */ */
/* OBSOLETE   gr1 = read_register (GR1_REGNUM) - DUMMY_FRAME_RSIZE; */
/* OBSOLETE   write_register (GR1_REGNUM, gr1); */
/* OBSOLETE  */
/* OBSOLETE #ifdef VXWORKS_TARGET */
/* OBSOLETE   /* We force re-reading all registers to get the new local registers set */
/* OBSOLETE      after gr1 has been modified. This fix is due to the lack of single */
/* OBSOLETE      register read/write operation in the RPC interface between VxGDB and */
/* OBSOLETE      VxWorks. This really must be changed ! */ */
/* OBSOLETE  */
/* OBSOLETE   vx_read_register (-1); */
/* OBSOLETE  */
/* OBSOLETE #endif /* VXWORK_TARGET */ */
/* OBSOLETE  */
/* OBSOLETE   rab = read_register (RAB_REGNUM); */
/* OBSOLETE   if (gr1 < rab) */
/* OBSOLETE     { */
/* OBSOLETE       /* We need to spill registers.  */ */
/* OBSOLETE       int num_bytes = rab - gr1; */
/* OBSOLETE       CORE_ADDR rfb = read_register (RFB_REGNUM); */
/* OBSOLETE       int i; */
/* OBSOLETE       long word; */
/* OBSOLETE  */
/* OBSOLETE       write_register (RFB_REGNUM, rfb - num_bytes); */
/* OBSOLETE       write_register (RAB_REGNUM, gr1); */
/* OBSOLETE       for (i = 0; i < num_bytes; i += 4) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* Note:  word is in target byte order.  */ */
/* OBSOLETE 	  read_register_gen (LR0_REGNUM + i / 4, (char *) &word); */
/* OBSOLETE 	  write_memory (rfb - num_bytes + i, (char *) &word, 4); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* There are no arguments in to the dummy frame, so we don't need */
/* OBSOLETE      more than rsize plus the return address and lr1.  */ */
/* OBSOLETE   write_register (LR0_REGNUM + 1, gr1 + DUMMY_FRAME_RSIZE + 2 * 4); */
/* OBSOLETE  */
/* OBSOLETE   /* Set the memory frame pointer.  */ */
/* OBSOLETE   write_register (LR0_REGNUM + DUMMY_FRAME_RSIZE / 4 - 1, msp); */
/* OBSOLETE  */
/* OBSOLETE   /* Allocate arg_slop.  */ */
/* OBSOLETE   write_register (MSP_REGNUM, msp - 16 * 4); */
/* OBSOLETE  */
/* OBSOLETE   /* Save registers.  */ */
/* OBSOLETE   lrnum = LR0_REGNUM + DUMMY_ARG / 4; */
/* OBSOLETE   for (i = 0; i < DUMMY_SAVE_SR128; ++i) */
/* OBSOLETE     write_register (lrnum++, read_register (SR_REGNUM (i + 128))); */
/* OBSOLETE   for (i = 0; i < DUMMY_SAVE_SR160; ++i) */
/* OBSOLETE     write_register (lrnum++, read_register (SR_REGNUM (i + 160))); */
/* OBSOLETE   for (i = 0; i < DUMMY_SAVE_GREGS; ++i) */
/* OBSOLETE     write_register (lrnum++, read_register (RETURN_REGNUM + i)); */
/* OBSOLETE   /* Save the PCs and LR0.  */ */
/* OBSOLETE   write_register (lrnum++, read_register (PC_REGNUM)); */
/* OBSOLETE   write_register (lrnum++, read_register (NPC_REGNUM)); */
/* OBSOLETE   write_register (lrnum++, read_register (PC2_REGNUM)); */
/* OBSOLETE  */
/* OBSOLETE   /* Why are we saving LR0?  What would clobber it? (the dummy frame should */
/* OBSOLETE      be below it on the register stack, no?).  */ */
/* OBSOLETE   write_register (lrnum++, original_lr0); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* */
/* OBSOLETE    This routine takes three arguments and makes the cached frames look */
/* OBSOLETE    as if these arguments defined a frame on the cache.  This allows the */
/* OBSOLETE    rest of `info frame' to extract the important arguments without much */
/* OBSOLETE    difficulty.  Since an individual frame on the 29K is determined by */
/* OBSOLETE    three values (FP, PC, and MSP), we really need all three to do a */
/* OBSOLETE    good job.  */ */
/* OBSOLETE  */
/* OBSOLETE struct frame_info * */
/* OBSOLETE setup_arbitrary_frame (int argc, CORE_ADDR *argv) */
/* OBSOLETE { */
/* OBSOLETE   struct frame_info *frame; */
/* OBSOLETE  */
/* OBSOLETE   if (argc != 3) */
/* OBSOLETE     error ("AMD 29k frame specifications require three arguments: rsp pc msp"); */
/* OBSOLETE  */
/* OBSOLETE   frame = create_new_frame (argv[0], argv[1]); */
/* OBSOLETE  */
/* OBSOLETE   if (!frame) */
/* OBSOLETE     internal_error (__FILE__, __LINE__, */
/* OBSOLETE 		    "create_new_frame returned invalid frame id"); */
/* OBSOLETE  */
/* OBSOLETE   /* Creating a new frame munges the `frame' value from the current */
/* OBSOLETE      GR1, so we restore it again here.  FIXME, untangle all this */
/* OBSOLETE      29K frame stuff...  */ */
/* OBSOLETE   frame->frame = argv[0]; */
/* OBSOLETE  */
/* OBSOLETE   /* Our MSP is in argv[2].  It'd be intelligent if we could just */
/* OBSOLETE      save this value in the FRAME.  But the way it's set up (FIXME), */
/* OBSOLETE      we must save our caller's MSP.  We compute that by adding our */
/* OBSOLETE      memory stack frame size to our MSP.  */ */
/* OBSOLETE   frame->saved_msp = argv[2] + frame->msize; */
/* OBSOLETE  */
/* OBSOLETE   return frame; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE gdb_print_insn_a29k (bfd_vma memaddr, disassemble_info *info) */
/* OBSOLETE { */
/* OBSOLETE   if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG) */
/* OBSOLETE     return print_insn_big_a29k (memaddr, info); */
/* OBSOLETE   else */
/* OBSOLETE     return print_insn_little_a29k (memaddr, info); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE enum a29k_processor_types processor_type = a29k_unknown; */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE a29k_get_processor_type (void) */
/* OBSOLETE { */
/* OBSOLETE   unsigned int cfg_reg = (unsigned int) read_register (CFG_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE   /* Most of these don't have freeze mode.  */ */
/* OBSOLETE   processor_type = a29k_no_freeze_mode; */
/* OBSOLETE  */
/* OBSOLETE   switch ((cfg_reg >> 28) & 0xf) */
/* OBSOLETE     { */
/* OBSOLETE     case 0: */
/* OBSOLETE       fprintf_filtered (gdb_stderr, "Remote debugging an Am29000"); */
/* OBSOLETE       break; */
/* OBSOLETE     case 1: */
/* OBSOLETE       fprintf_filtered (gdb_stderr, "Remote debugging an Am29005"); */
/* OBSOLETE       break; */
/* OBSOLETE     case 2: */
/* OBSOLETE       fprintf_filtered (gdb_stderr, "Remote debugging an Am29050"); */
/* OBSOLETE       processor_type = a29k_freeze_mode; */
/* OBSOLETE       break; */
/* OBSOLETE     case 3: */
/* OBSOLETE       fprintf_filtered (gdb_stderr, "Remote debugging an Am29035"); */
/* OBSOLETE       break; */
/* OBSOLETE     case 4: */
/* OBSOLETE       fprintf_filtered (gdb_stderr, "Remote debugging an Am29030"); */
/* OBSOLETE       break; */
/* OBSOLETE     case 5: */
/* OBSOLETE       fprintf_filtered (gdb_stderr, "Remote debugging an Am2920*"); */
/* OBSOLETE       break; */
/* OBSOLETE     case 6: */
/* OBSOLETE       fprintf_filtered (gdb_stderr, "Remote debugging an Am2924*"); */
/* OBSOLETE       break; */
/* OBSOLETE     case 7: */
/* OBSOLETE       fprintf_filtered (gdb_stderr, "Remote debugging an Am29040"); */
/* OBSOLETE       break; */
/* OBSOLETE     default: */
/* OBSOLETE       fprintf_filtered (gdb_stderr, "Remote debugging an unknown Am29k\n"); */
/* OBSOLETE       /* Don't bother to print the revision.  */ */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE   fprintf_filtered (gdb_stderr, " revision %c\n", 'A' + ((cfg_reg >> 24) & 0x0f)); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #ifdef GET_LONGJMP_TARGET */
/* OBSOLETE /* Figure out where the longjmp will land.  We expect that we have just entered */
/* OBSOLETE    longjmp and haven't yet setup the stack frame, so the args are still in the */
/* OBSOLETE    output regs.  lr2 (LR2_REGNUM) points at the jmp_buf structure from which we */
/* OBSOLETE    extract the pc (JB_PC) that we will land at.  The pc is copied into ADDR. */
/* OBSOLETE    This routine returns true on success */ */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE get_longjmp_target (CORE_ADDR *pc) */
/* OBSOLETE { */
/* OBSOLETE   CORE_ADDR jb_addr; */
/* OBSOLETE   char buf[sizeof (CORE_ADDR)]; */
/* OBSOLETE  */
/* OBSOLETE   jb_addr = read_register (LR2_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE   if (target_read_memory (jb_addr + JB_PC * JB_ELEMENT_SIZE, (char *) buf, */
/* OBSOLETE 			  sizeof (CORE_ADDR))) */
/* OBSOLETE     return 0; */
/* OBSOLETE  */
/* OBSOLETE   *pc = extract_address ((PTR) buf, sizeof (CORE_ADDR)); */
/* OBSOLETE   return 1; */
/* OBSOLETE } */
/* OBSOLETE #endif /* GET_LONGJMP_TARGET */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE _initialize_a29k_tdep (void) */
/* OBSOLETE { */
/* OBSOLETE   extern CORE_ADDR text_end; */
/* OBSOLETE  */
/* OBSOLETE   tm_print_insn = gdb_print_insn_a29k; */
/* OBSOLETE  */
/* OBSOLETE   /* FIXME, there should be a way to make a CORE_ADDR variable settable. */ */
/* OBSOLETE   add_show_from_set */
/* OBSOLETE     (add_set_cmd ("rstack_high_address", class_support, var_uinteger, */
/* OBSOLETE 		  (char *) &rstack_high_address, */
/* OBSOLETE 		  "Set top address in memory of the register stack.\n\ */
/* OBSOLETE Attempts to access registers saved above this address will be ignored\n\ */
/* OBSOLETE or will produce the value -1.", &setlist), */
/* OBSOLETE      &showlist); */
/* OBSOLETE  */
/* OBSOLETE   /* FIXME, there should be a way to make a CORE_ADDR variable settable. */ */
/* OBSOLETE   add_show_from_set */
/* OBSOLETE     (add_set_cmd ("call_scratch_address", class_support, var_uinteger, */
/* OBSOLETE 		  (char *) &text_end, */
/* OBSOLETE 		  "Set address in memory where small amounts of RAM can be used\n\ */
/* OBSOLETE when making function calls into the inferior.", &setlist), */
/* OBSOLETE      &showlist); */
/* OBSOLETE } */
@


1.7
log
@* MAINTAINERS: Mark a29k target as obsolete.
* Makefile.in (a29k-tdep.o, remote-adapt.o, remote-eb.o)
(remote-mm.o, remote-udi.o): Obsolete.  Remove references in
comments.
* NEWS: Note that a29k targets are obsolete.
* a29k-tdep.c: Mark as obsolete.
* configure.tgt: Mark a29k-*-aout*, a29k-*-coff*, a29k-*-elf*,
a29k-*-ebmon*, a29k-*-kern*, a29k-*-none*, a29k-*-udi* and
a29k-*-vxworks* targets as obsolete.
* remote-adapt.c: Obsolete.
* remote-eb.c: Obsolete.
* remote-mm.c: Obsolete.
* remote-udi.c: Obsolete.
* config/a29k/a29k-udi.mt: Obsolete.
* config/a29k/a29k.mt: Obsolete.
* config/a29k/tm-a29k.h: Obsolete.
* config/a29k/tm-vx29k.h: Obsolete.
* config/a29k/vx29k.mt: Obsolete.
@
text
@@


1.6
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d1 1015
a1015 1015
/* Target-machine dependent code for the AMD 29000
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2001
   Free Software Foundation, Inc.
   Contributed by Cygnus Support.  Written by Jim Kingdon.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "gdbcore.h"
#include "frame.h"
#include "value.h"
#include "symtab.h"
#include "inferior.h"
#include "gdbcmd.h"
#include "regcache.h"

/* If all these bits in an instruction word are zero, it is a "tag word"
   which precedes a function entry point and gives stack traceback info.
   This used to be defined as 0xff000000, but that treated 0x00000deb as
   a tag word, while it is really used as a breakpoint.  */
#define	TAGWORD_ZERO_MASK	0xff00f800

extern CORE_ADDR text_start;	/* FIXME, kludge... */

/* The user-settable top of the register stack in virtual memory.  We
   won't attempt to access any stored registers above this address, if set
   nonzero.  */

static CORE_ADDR rstack_high_address = UINT_MAX;


/* Should call_function allocate stack space for a struct return?  */
/* On the a29k objects over 16 words require the caller to allocate space.  */
int
a29k_use_struct_convention (int gcc_p, struct type *type)
{
  return (TYPE_LENGTH (type) > 16 * 4);
}


/* Structure to hold cached info about function prologues.  */

struct prologue_info
{
  CORE_ADDR pc;			/* First addr after fn prologue */
  unsigned rsize, msize;	/* register stack frame size, mem stack ditto */
  unsigned mfp_used:1;		/* memory frame pointer used */
  unsigned rsize_valid:1;	/* Validity bits for the above */
  unsigned msize_valid:1;
  unsigned mfp_valid:1;
};

/* Examine the prologue of a function which starts at PC.  Return
   the first addess past the prologue.  If MSIZE is non-NULL, then
   set *MSIZE to the memory stack frame size.  If RSIZE is non-NULL,
   then set *RSIZE to the register stack frame size (not including
   incoming arguments and the return address & frame pointer stored
   with them).  If no prologue is found, *RSIZE is set to zero.
   If no prologue is found, or a prologue which doesn't involve
   allocating a memory stack frame, then set *MSIZE to zero.

   Note that both msize and rsize are in bytes.  This is not consistent
   with the _User's Manual_ with respect to rsize, but it is much more
   convenient.

   If MFP_USED is non-NULL, *MFP_USED is set to nonzero if a memory
   frame pointer is being used.  */

CORE_ADDR
examine_prologue (CORE_ADDR pc, unsigned *rsize, unsigned *msize, int *mfp_used)
{
  long insn;
  CORE_ADDR p = pc;
  struct minimal_symbol *msymbol = lookup_minimal_symbol_by_pc (pc);
  struct prologue_info *mi = 0;

  if (msymbol != NULL)
    mi = (struct prologue_info *) msymbol->info;

  if (mi != 0)
    {
      int valid = 1;
      if (rsize != NULL)
	{
	  *rsize = mi->rsize;
	  valid &= mi->rsize_valid;
	}
      if (msize != NULL)
	{
	  *msize = mi->msize;
	  valid &= mi->msize_valid;
	}
      if (mfp_used != NULL)
	{
	  *mfp_used = mi->mfp_used;
	  valid &= mi->mfp_valid;
	}
      if (valid)
	return mi->pc;
    }

  if (rsize != NULL)
    *rsize = 0;
  if (msize != NULL)
    *msize = 0;
  if (mfp_used != NULL)
    *mfp_used = 0;

  /* Prologue must start with subtracting a constant from gr1.
     Normally this is sub gr1,gr1,<rsize * 4>.  */
  insn = read_memory_integer (p, 4);
  if ((insn & 0xffffff00) != 0x25010100)
    {
      /* If the frame is large, instead of a single instruction it
         might be a pair of instructions:
         const <reg>, <rsize * 4>
         sub gr1,gr1,<reg>
       */
      int reg;
      /* Possible value for rsize.  */
      unsigned int rsize0;

      if ((insn & 0xff000000) != 0x03000000)
	{
	  p = pc;
	  goto done;
	}
      reg = (insn >> 8) & 0xff;
      rsize0 = (((insn >> 8) & 0xff00) | (insn & 0xff));
      p += 4;
      insn = read_memory_integer (p, 4);
      if ((insn & 0xffffff00) != 0x24010100
	  || (insn & 0xff) != reg)
	{
	  p = pc;
	  goto done;
	}
      if (rsize != NULL)
	*rsize = rsize0;
    }
  else
    {
      if (rsize != NULL)
	*rsize = (insn & 0xff);
    }
  p += 4;

  /* Next instruction ought to be asgeu V_SPILL,gr1,rab.  
   * We don't check the vector number to allow for kernel debugging.  The 
   * kernel will use a different trap number. 
   * If this insn is missing, we just keep going; Metaware R2.3u compiler
   * generates prologue that intermixes initializations and puts the asgeu
   * way down.
   */
  insn = read_memory_integer (p, 4);
  if ((insn & 0xff00ffff) == (0x5e000100 | RAB_HW_REGNUM))
    {
      p += 4;
    }

  /* Next instruction usually sets the frame pointer (lr1) by adding
     <size * 4> from gr1.  However, this can (and high C does) be
     deferred until anytime before the first function call.  So it is
     OK if we don't see anything which sets lr1.  
     To allow for alternate register sets (gcc -mkernel-registers)  the msp
     register number is a compile time constant. */

  /* Normally this is just add lr1,gr1,<size * 4>.  */
  insn = read_memory_integer (p, 4);
  if ((insn & 0xffffff00) == 0x15810100)
    p += 4;
  else
    {
      /* However, for large frames it can be
         const <reg>, <size *4>
         add lr1,gr1,<reg>
       */
      int reg;
      CORE_ADDR q;

      if ((insn & 0xff000000) == 0x03000000)
	{
	  reg = (insn >> 8) & 0xff;
	  q = p + 4;
	  insn = read_memory_integer (q, 4);
	  if ((insn & 0xffffff00) == 0x14810100
	      && (insn & 0xff) == reg)
	    p = q;
	}
    }

  /* Next comes "add lr{<rsize-1>},msp,0", but only if a memory
     frame pointer is in use.  We just check for add lr<anything>,msp,0;
     we don't check this rsize against the first instruction, and
     we don't check that the trace-back tag indicates a memory frame pointer
     is in use.  
     To allow for alternate register sets (gcc -mkernel-registers)  the msp
     register number is a compile time constant.

     The recommended instruction is actually "sll lr<whatever>,msp,0". 
     We check for that, too.  Originally Jim Kingdon's code seemed
     to be looking for a "sub" instruction here, but the mask was set
     up to lose all the time. */
  insn = read_memory_integer (p, 4);
  if (((insn & 0xff80ffff) == (0x15800000 | (MSP_HW_REGNUM << 8)))	/* add */
      || ((insn & 0xff80ffff) == (0x81800000 | (MSP_HW_REGNUM << 8))))	/* sll */
    {
      p += 4;
      if (mfp_used != NULL)
	*mfp_used = 1;
    }

  /* Next comes a subtraction from msp to allocate a memory frame,
     but only if a memory frame is
     being used.  We don't check msize against the trace-back tag.

     To allow for alternate register sets (gcc -mkernel-registers) the msp
     register number is a compile time constant.

     Normally this is just
     sub msp,msp,<msize>
   */
  insn = read_memory_integer (p, 4);
  if ((insn & 0xffffff00) ==
      (0x25000000 | (MSP_HW_REGNUM << 16) | (MSP_HW_REGNUM << 8)))
    {
      p += 4;
      if (msize != NULL)
	*msize = insn & 0xff;
    }
  else
    {
      /* For large frames, instead of a single instruction it might
         be

         const <reg>, <msize>
         consth <reg>, <msize>     ; optional
         sub msp,msp,<reg>
       */
      int reg;
      unsigned msize0;
      CORE_ADDR q = p;

      if ((insn & 0xff000000) == 0x03000000)
	{
	  reg = (insn >> 8) & 0xff;
	  msize0 = ((insn >> 8) & 0xff00) | (insn & 0xff);
	  q += 4;
	  insn = read_memory_integer (q, 4);
	  /* Check for consth.  */
	  if ((insn & 0xff000000) == 0x02000000
	      && (insn & 0x0000ff00) == reg)
	    {
	      msize0 |= (insn << 8) & 0xff000000;
	      msize0 |= (insn << 16) & 0x00ff0000;
	      q += 4;
	      insn = read_memory_integer (q, 4);
	    }
	  /* Check for sub msp,msp,<reg>.  */
	  if ((insn & 0xffffff00) ==
	      (0x24000000 | (MSP_HW_REGNUM << 16) | (MSP_HW_REGNUM << 8))
	      && (insn & 0xff) == reg)
	    {
	      p = q + 4;
	      if (msize != NULL)
		*msize = msize0;
	    }
	}
    }

  /* Next instruction might be asgeu V_SPILL,gr1,rab.  
   * We don't check the vector number to allow for kernel debugging.  The 
   * kernel will use a different trap number. 
   * Metaware R2.3u compiler
   * generates prologue that intermixes initializations and puts the asgeu
   * way down after everything else.
   */
  insn = read_memory_integer (p, 4);
  if ((insn & 0xff00ffff) == (0x5e000100 | RAB_HW_REGNUM))
    {
      p += 4;
    }

done:
  if (msymbol != NULL)
    {
      if (mi == 0)
	{
	  /* Add a new cache entry.  */
	  mi = (struct prologue_info *) xmalloc (sizeof (struct prologue_info));
	  msymbol->info = (char *) mi;
	  mi->rsize_valid = 0;
	  mi->msize_valid = 0;
	  mi->mfp_valid = 0;
	}
      /* else, cache entry exists, but info is incomplete.  */
      mi->pc = p;
      if (rsize != NULL)
	{
	  mi->rsize = *rsize;
	  mi->rsize_valid = 1;
	}
      if (msize != NULL)
	{
	  mi->msize = *msize;
	  mi->msize_valid = 1;
	}
      if (mfp_used != NULL)
	{
	  mi->mfp_used = *mfp_used;
	  mi->mfp_valid = 1;
	}
    }
  return p;
}

/* Advance PC across any function entry prologue instructions
   to reach some "real" code.  */

CORE_ADDR
a29k_skip_prologue (CORE_ADDR pc)
{
  return examine_prologue (pc, NULL, NULL, NULL);
}

/*
 * Examine the one or two word tag at the beginning of a function.
 * The tag word is expect to be at 'p', if it is not there, we fail
 * by returning 0.  The documentation for the tag word was taken from
 * page 7-15 of the 29050 User's Manual.  We are assuming that the
 * m bit is in bit 22 of the tag word, which seems to be the agreed upon
 * convention today (1/15/92).
 * msize is return in bytes.
 */

static int			/* 0/1 - failure/success of finding the tag word  */
examine_tag (CORE_ADDR p, int *is_trans, int *argcount, unsigned *msize,
	     int *mfp_used)
{
  unsigned int tag1, tag2;

  tag1 = read_memory_integer (p, 4);
  if ((tag1 & TAGWORD_ZERO_MASK) != 0)	/* Not a tag word */
    return 0;
  if (tag1 & (1 << 23))		/* A two word tag */
    {
      tag2 = read_memory_integer (p - 4, 4);
      if (msize)
	*msize = tag2 * 2;
    }
  else
    /* A one word tag */
    {
      if (msize)
	*msize = tag1 & 0x7ff;
    }
  if (is_trans)
    *is_trans = ((tag1 & (1 << 21)) ? 1 : 0);
  /* Note that this includes the frame pointer and the return address
     register, so the actual number of registers of arguments is two less.
     argcount can be zero, however, sometimes, for strange assembler
     routines.  */
  if (argcount)
    *argcount = (tag1 >> 16) & 0x1f;
  if (mfp_used)
    *mfp_used = ((tag1 & (1 << 22)) ? 1 : 0);
  return 1;
}

/* Initialize the frame.  In addition to setting "extra" frame info,
   we also set ->frame because we use it in a nonstandard way, and ->pc
   because we need to know it to get the other stuff.  See the diagram
   of stacks and the frame cache in tm-a29k.h for more detail.  */

static void
init_frame_info (int innermost_frame, struct frame_info *frame)
{
  CORE_ADDR p;
  long insn;
  unsigned rsize;
  unsigned msize;
  int mfp_used, trans;
  struct symbol *func;

  p = frame->pc;

  if (innermost_frame)
    frame->frame = read_register (GR1_REGNUM);
  else
    frame->frame = frame->next->frame + frame->next->rsize;

#if 0				/* CALL_DUMMY_LOCATION == ON_STACK */
  This wont work;
#else
  if (PC_IN_CALL_DUMMY (p, 0, 0))
#endif
    {
      frame->rsize = DUMMY_FRAME_RSIZE;
      /* This doesn't matter since we never try to get locals or args
         from a dummy frame.  */
      frame->msize = 0;
      /* Dummy frames always use a memory frame pointer.  */
      frame->saved_msp =
	read_register_stack_integer (frame->frame + DUMMY_FRAME_RSIZE - 4, 4);
      frame->flags |= (TRANSPARENT_FRAME | MFP_USED);
      return;
    }

  func = find_pc_function (p);
  if (func != NULL)
    p = BLOCK_START (SYMBOL_BLOCK_VALUE (func));
  else
    {
      /* Search backward to find the trace-back tag.  However,
         do not trace back beyond the start of the text segment
         (just as a sanity check to avoid going into never-never land).  */
#if 1
      while (p >= text_start
	  && ((insn = read_memory_integer (p, 4)) & TAGWORD_ZERO_MASK) != 0)
	p -= 4;
#else /* 0 */
      char pat[4] =
      {0, 0, 0, 0};
      char mask[4];
      char insn_raw[4];
      store_unsigned_integer (mask, 4, TAGWORD_ZERO_MASK);
      /* Enable this once target_search is enabled and tested.  */
      target_search (4, pat, mask, p, -4, text_start, p + 1, &p, &insn_raw);
      insn = extract_unsigned_integer (insn_raw, 4);
#endif /* 0 */

      if (p < text_start)
	{
	  /* Couldn't find the trace-back tag.
	     Something strange is going on.  */
	  frame->saved_msp = 0;
	  frame->rsize = 0;
	  frame->msize = 0;
	  frame->flags = TRANSPARENT_FRAME;
	  return;
	}
      else
	/* Advance to the first word of the function, i.e. the word
	   after the trace-back tag.  */
	p += 4;
    }

  /* We've found the start of the function.  
     Try looking for a tag word that indicates whether there is a
     memory frame pointer and what the memory stack allocation is.
     If one doesn't exist, try using a more exhaustive search of
     the prologue.  */

  if (examine_tag (p - 4, &trans, (int *) NULL, &msize, &mfp_used))	/* Found good tag */
    examine_prologue (p, &rsize, 0, 0);
  else				/* No tag try prologue */
    examine_prologue (p, &rsize, &msize, &mfp_used);

  frame->rsize = rsize;
  frame->msize = msize;
  frame->flags = 0;
  if (mfp_used)
    frame->flags |= MFP_USED;
  if (trans)
    frame->flags |= TRANSPARENT_FRAME;
  if (innermost_frame)
    {
      frame->saved_msp = read_register (MSP_REGNUM) + msize;
    }
  else
    {
      if (mfp_used)
	frame->saved_msp =
	  read_register_stack_integer (frame->frame + rsize - 4, 4);
      else
	frame->saved_msp = frame->next->saved_msp + msize;
    }
}

void
init_extra_frame_info (struct frame_info *frame)
{
  if (frame->next == 0)
    /* Assume innermost frame.  May produce strange results for "info frame"
       but there isn't any way to tell the difference.  */
    init_frame_info (1, frame);
  else
    {
      /* We're in get_prev_frame.
         Take care of everything in init_frame_pc.  */
      ;
    }
}

void
init_frame_pc (int fromleaf, struct frame_info *frame)
{
  frame->pc = (fromleaf ? SAVED_PC_AFTER_CALL (frame->next) :
	       frame->next ? FRAME_SAVED_PC (frame->next) : read_pc ());
  init_frame_info (fromleaf, frame);
}

/* Local variables (i.e. LOC_LOCAL) are on the memory stack, with their
   offsets being relative to the memory stack pointer (high C) or
   saved_msp (gcc).  */

CORE_ADDR
frame_locals_address (struct frame_info *fi)
{
  if (fi->flags & MFP_USED)
    return fi->saved_msp;
  else
    return fi->saved_msp - fi->msize;
}

/* Routines for reading the register stack.  The caller gets to treat
   the register stack as a uniform stack in memory, from address $gr1
   straight through $rfb and beyond.  */

/* Analogous to read_memory except the length is understood to be 4.
   Also, myaddr can be NULL (meaning don't bother to read), and
   if actual_mem_addr is non-NULL, store there the address that it
   was fetched from (or if from a register the offset within
   registers).  Set *LVAL to lval_memory or lval_register, depending
   on where it came from.  The contents written into MYADDR are in
   target format.  */
void
read_register_stack (CORE_ADDR memaddr, char *myaddr,
		     CORE_ADDR *actual_mem_addr, enum lval_type *lval)
{
  long rfb = read_register (RFB_REGNUM);
  long rsp = read_register (RSP_REGNUM);

  /* If we don't do this 'info register' stops in the middle. */
  if (memaddr >= rstack_high_address)
    {
      /* a bogus value */
      static char val[] =
      {~0, ~0, ~0, ~0};
      /* It's in a local register, but off the end of the stack.  */
      int regnum = (memaddr - rsp) / 4 + LR0_REGNUM;
      if (myaddr != NULL)
	{
	  /* Provide bogusness */
	  memcpy (myaddr, val, 4);
	}
      supply_register (regnum, val);	/* More bogusness */
      if (lval != NULL)
	*lval = lval_register;
      if (actual_mem_addr != NULL)
	*actual_mem_addr = REGISTER_BYTE (regnum);
    }
  /* If it's in the part of the register stack that's in real registers,
     get the value from the registers.  If it's anywhere else in memory
     (e.g. in another thread's saved stack), skip this part and get
     it from real live memory.  */
  else if (memaddr < rfb && memaddr >= rsp)
    {
      /* It's in a register.  */
      int regnum = (memaddr - rsp) / 4 + LR0_REGNUM;
      if (regnum > LR0_REGNUM + 127)
	error ("Attempt to read register stack out of range.");
      if (myaddr != NULL)
	read_register_gen (regnum, myaddr);
      if (lval != NULL)
	*lval = lval_register;
      if (actual_mem_addr != NULL)
	*actual_mem_addr = REGISTER_BYTE (regnum);
    }
  else
    {
      /* It's in the memory portion of the register stack.  */
      if (myaddr != NULL)
	read_memory (memaddr, myaddr, 4);
      if (lval != NULL)
	*lval = lval_memory;
      if (actual_mem_addr != NULL)
	*actual_mem_addr = memaddr;
    }
}

/* Analogous to read_memory_integer
   except the length is understood to be 4.  */
long
read_register_stack_integer (CORE_ADDR memaddr, int len)
{
  char buf[4];
  read_register_stack (memaddr, buf, NULL, NULL);
  return extract_signed_integer (buf, 4);
}

/* Copy 4 bytes from GDB memory at MYADDR into inferior memory
   at MEMADDR and put the actual address written into in
   *ACTUAL_MEM_ADDR.  */
static void
write_register_stack (CORE_ADDR memaddr, char *myaddr,
		      CORE_ADDR *actual_mem_addr)
{
  long rfb = read_register (RFB_REGNUM);
  long rsp = read_register (RSP_REGNUM);
  /* If we don't do this 'info register' stops in the middle. */
  if (memaddr >= rstack_high_address)
    {
      /* It's in a register, but off the end of the stack.  */
      if (actual_mem_addr != NULL)
	*actual_mem_addr = 0;
    }
  else if (memaddr < rfb)
    {
      /* It's in a register.  */
      int regnum = (memaddr - rsp) / 4 + LR0_REGNUM;
      if (regnum < LR0_REGNUM || regnum > LR0_REGNUM + 127)
	error ("Attempt to read register stack out of range.");
      if (myaddr != NULL)
	write_register (regnum, *(long *) myaddr);
      if (actual_mem_addr != NULL)
	*actual_mem_addr = 0;
    }
  else
    {
      /* It's in the memory portion of the register stack.  */
      if (myaddr != NULL)
	write_memory (memaddr, myaddr, 4);
      if (actual_mem_addr != NULL)
	*actual_mem_addr = memaddr;
    }
}

/* Find register number REGNUM relative to FRAME and put its
   (raw) contents in *RAW_BUFFER.  Set *OPTIMIZED if the variable
   was optimized out (and thus can't be fetched).  If the variable
   was fetched from memory, set *ADDRP to where it was fetched from,
   otherwise it was fetched from a register.

   The argument RAW_BUFFER must point to aligned memory.  */

void
a29k_get_saved_register (char *raw_buffer, int *optimized, CORE_ADDR *addrp,
			 struct frame_info *frame, int regnum,
			 enum lval_type *lvalp)
{
  struct frame_info *fi;
  CORE_ADDR addr;
  enum lval_type lval;

  if (!target_has_registers)
    error ("No registers.");

  /* Probably now redundant with the target_has_registers check.  */
  if (frame == 0)
    return;

  /* Once something has a register number, it doesn't get optimized out.  */
  if (optimized != NULL)
    *optimized = 0;
  if (regnum == RSP_REGNUM)
    {
      if (raw_buffer != NULL)
	{
	  store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), frame->frame);
	}
      if (lvalp != NULL)
	*lvalp = not_lval;
      return;
    }
  else if (regnum == PC_REGNUM && frame->next != NULL)
    {
      if (raw_buffer != NULL)
	{
	  store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), frame->pc);
	}

      /* Not sure we have to do this.  */
      if (lvalp != NULL)
	*lvalp = not_lval;

      return;
    }
  else if (regnum == MSP_REGNUM)
    {
      if (raw_buffer != NULL)
	{
	  if (frame->next != NULL)
	    {
	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum),
			     frame->next->saved_msp);
	    }
	  else
	    read_register_gen (MSP_REGNUM, raw_buffer);
	}
      /* The value may have been computed, not fetched.  */
      if (lvalp != NULL)
	*lvalp = not_lval;
      return;
    }
  else if (regnum < LR0_REGNUM || regnum >= LR0_REGNUM + 128)
    {
      /* These registers are not saved over procedure calls,
         so just print out the current values.  */
      if (raw_buffer != NULL)
	read_register_gen (regnum, raw_buffer);
      if (lvalp != NULL)
	*lvalp = lval_register;
      if (addrp != NULL)
	*addrp = REGISTER_BYTE (regnum);
      return;
    }

  addr = frame->frame + (regnum - LR0_REGNUM) * 4;
  if (raw_buffer != NULL)
    read_register_stack (addr, raw_buffer, &addr, &lval);
  if (lvalp != NULL)
    *lvalp = lval;
  if (addrp != NULL)
    *addrp = addr;
}


/* Discard from the stack the innermost frame,
   restoring all saved registers.  */

void
pop_frame (void)
{
  struct frame_info *frame = get_current_frame ();
  CORE_ADDR rfb = read_register (RFB_REGNUM);
  CORE_ADDR gr1 = frame->frame + frame->rsize;
  CORE_ADDR lr1;
  CORE_ADDR original_lr0;
  int must_fix_lr0 = 0;
  int i;

  /* If popping a dummy frame, need to restore registers.  */
  if (PC_IN_CALL_DUMMY (read_register (PC_REGNUM),
			read_register (SP_REGNUM),
			FRAME_FP (frame)))
    {
      int lrnum = LR0_REGNUM + DUMMY_ARG / 4;
      for (i = 0; i < DUMMY_SAVE_SR128; ++i)
	write_register (SR_REGNUM (i + 128), read_register (lrnum++));
      for (i = 0; i < DUMMY_SAVE_SR160; ++i)
	write_register (SR_REGNUM (i + 160), read_register (lrnum++));
      for (i = 0; i < DUMMY_SAVE_GREGS; ++i)
	write_register (RETURN_REGNUM + i, read_register (lrnum++));
      /* Restore the PCs and prepare to restore LR0.  */
      write_register (PC_REGNUM, read_register (lrnum++));
      write_register (NPC_REGNUM, read_register (lrnum++));
      write_register (PC2_REGNUM, read_register (lrnum++));
      original_lr0 = read_register (lrnum++);
      must_fix_lr0 = 1;
    }

  /* Restore the memory stack pointer.  */
  write_register (MSP_REGNUM, frame->saved_msp);
  /* Restore the register stack pointer.  */
  write_register (GR1_REGNUM, gr1);

  /* If we popped a dummy frame, restore lr0 now that gr1 has been restored. */
  if (must_fix_lr0)
    write_register (LR0_REGNUM, original_lr0);

  /* Check whether we need to fill registers.  */
  lr1 = read_register (LR0_REGNUM + 1);
  if (lr1 > rfb)
    {
      /* Fill.  */
      int num_bytes = lr1 - rfb;
      int i;
      long word;

      write_register (RAB_REGNUM, read_register (RAB_REGNUM) + num_bytes);
      write_register (RFB_REGNUM, lr1);
      for (i = 0; i < num_bytes; i += 4)
	{
	  /* Note: word is in host byte order.  */
	  word = read_memory_integer (rfb + i, 4);
	  write_register (LR0_REGNUM + ((rfb - gr1) % 0x80) + i / 4, word);
	}
    }
  flush_cached_frames ();
}

/* Push an empty stack frame, to record the current PC, etc.  */

void
push_dummy_frame (void)
{
  long w;
  CORE_ADDR rab, gr1;
  CORE_ADDR msp = read_register (MSP_REGNUM);
  int lrnum, i;
  CORE_ADDR original_lr0;

  /* Read original lr0 before changing gr1.  This order isn't really needed
     since GDB happens to have a snapshot of all the regs and doesn't toss
     it when gr1 is changed.  But it's The Right Thing To Do.  */
  original_lr0 = read_register (LR0_REGNUM);

  /* Allocate the new frame. */
  gr1 = read_register (GR1_REGNUM) - DUMMY_FRAME_RSIZE;
  write_register (GR1_REGNUM, gr1);

#ifdef VXWORKS_TARGET
  /* We force re-reading all registers to get the new local registers set
     after gr1 has been modified. This fix is due to the lack of single
     register read/write operation in the RPC interface between VxGDB and
     VxWorks. This really must be changed ! */

  vx_read_register (-1);

#endif /* VXWORK_TARGET */

  rab = read_register (RAB_REGNUM);
  if (gr1 < rab)
    {
      /* We need to spill registers.  */
      int num_bytes = rab - gr1;
      CORE_ADDR rfb = read_register (RFB_REGNUM);
      int i;
      long word;

      write_register (RFB_REGNUM, rfb - num_bytes);
      write_register (RAB_REGNUM, gr1);
      for (i = 0; i < num_bytes; i += 4)
	{
	  /* Note:  word is in target byte order.  */
	  read_register_gen (LR0_REGNUM + i / 4, (char *) &word);
	  write_memory (rfb - num_bytes + i, (char *) &word, 4);
	}
    }

  /* There are no arguments in to the dummy frame, so we don't need
     more than rsize plus the return address and lr1.  */
  write_register (LR0_REGNUM + 1, gr1 + DUMMY_FRAME_RSIZE + 2 * 4);

  /* Set the memory frame pointer.  */
  write_register (LR0_REGNUM + DUMMY_FRAME_RSIZE / 4 - 1, msp);

  /* Allocate arg_slop.  */
  write_register (MSP_REGNUM, msp - 16 * 4);

  /* Save registers.  */
  lrnum = LR0_REGNUM + DUMMY_ARG / 4;
  for (i = 0; i < DUMMY_SAVE_SR128; ++i)
    write_register (lrnum++, read_register (SR_REGNUM (i + 128)));
  for (i = 0; i < DUMMY_SAVE_SR160; ++i)
    write_register (lrnum++, read_register (SR_REGNUM (i + 160)));
  for (i = 0; i < DUMMY_SAVE_GREGS; ++i)
    write_register (lrnum++, read_register (RETURN_REGNUM + i));
  /* Save the PCs and LR0.  */
  write_register (lrnum++, read_register (PC_REGNUM));
  write_register (lrnum++, read_register (NPC_REGNUM));
  write_register (lrnum++, read_register (PC2_REGNUM));

  /* Why are we saving LR0?  What would clobber it? (the dummy frame should
     be below it on the register stack, no?).  */
  write_register (lrnum++, original_lr0);
}



/*
   This routine takes three arguments and makes the cached frames look
   as if these arguments defined a frame on the cache.  This allows the
   rest of `info frame' to extract the important arguments without much
   difficulty.  Since an individual frame on the 29K is determined by
   three values (FP, PC, and MSP), we really need all three to do a
   good job.  */

struct frame_info *
setup_arbitrary_frame (int argc, CORE_ADDR *argv)
{
  struct frame_info *frame;

  if (argc != 3)
    error ("AMD 29k frame specifications require three arguments: rsp pc msp");

  frame = create_new_frame (argv[0], argv[1]);

  if (!frame)
    internal_error (__FILE__, __LINE__,
		    "create_new_frame returned invalid frame id");

  /* Creating a new frame munges the `frame' value from the current
     GR1, so we restore it again here.  FIXME, untangle all this
     29K frame stuff...  */
  frame->frame = argv[0];

  /* Our MSP is in argv[2].  It'd be intelligent if we could just
     save this value in the FRAME.  But the way it's set up (FIXME),
     we must save our caller's MSP.  We compute that by adding our
     memory stack frame size to our MSP.  */
  frame->saved_msp = argv[2] + frame->msize;

  return frame;
}

int
gdb_print_insn_a29k (bfd_vma memaddr, disassemble_info *info)
{
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    return print_insn_big_a29k (memaddr, info);
  else
    return print_insn_little_a29k (memaddr, info);
}

enum a29k_processor_types processor_type = a29k_unknown;

void
a29k_get_processor_type (void)
{
  unsigned int cfg_reg = (unsigned int) read_register (CFG_REGNUM);

  /* Most of these don't have freeze mode.  */
  processor_type = a29k_no_freeze_mode;

  switch ((cfg_reg >> 28) & 0xf)
    {
    case 0:
      fprintf_filtered (gdb_stderr, "Remote debugging an Am29000");
      break;
    case 1:
      fprintf_filtered (gdb_stderr, "Remote debugging an Am29005");
      break;
    case 2:
      fprintf_filtered (gdb_stderr, "Remote debugging an Am29050");
      processor_type = a29k_freeze_mode;
      break;
    case 3:
      fprintf_filtered (gdb_stderr, "Remote debugging an Am29035");
      break;
    case 4:
      fprintf_filtered (gdb_stderr, "Remote debugging an Am29030");
      break;
    case 5:
      fprintf_filtered (gdb_stderr, "Remote debugging an Am2920*");
      break;
    case 6:
      fprintf_filtered (gdb_stderr, "Remote debugging an Am2924*");
      break;
    case 7:
      fprintf_filtered (gdb_stderr, "Remote debugging an Am29040");
      break;
    default:
      fprintf_filtered (gdb_stderr, "Remote debugging an unknown Am29k\n");
      /* Don't bother to print the revision.  */
      return;
    }
  fprintf_filtered (gdb_stderr, " revision %c\n", 'A' + ((cfg_reg >> 24) & 0x0f));
}

#ifdef GET_LONGJMP_TARGET
/* Figure out where the longjmp will land.  We expect that we have just entered
   longjmp and haven't yet setup the stack frame, so the args are still in the
   output regs.  lr2 (LR2_REGNUM) points at the jmp_buf structure from which we
   extract the pc (JB_PC) that we will land at.  The pc is copied into ADDR.
   This routine returns true on success */

int
get_longjmp_target (CORE_ADDR *pc)
{
  CORE_ADDR jb_addr;
  char buf[sizeof (CORE_ADDR)];

  jb_addr = read_register (LR2_REGNUM);

  if (target_read_memory (jb_addr + JB_PC * JB_ELEMENT_SIZE, (char *) buf,
			  sizeof (CORE_ADDR)))
    return 0;

  *pc = extract_address ((PTR) buf, sizeof (CORE_ADDR));
  return 1;
}
#endif /* GET_LONGJMP_TARGET */

void
_initialize_a29k_tdep (void)
{
  extern CORE_ADDR text_end;

  tm_print_insn = gdb_print_insn_a29k;

  /* FIXME, there should be a way to make a CORE_ADDR variable settable. */
  add_show_from_set
    (add_set_cmd ("rstack_high_address", class_support, var_uinteger,
		  (char *) &rstack_high_address,
		  "Set top address in memory of the register stack.\n\
Attempts to access registers saved above this address will be ignored\n\
or will produce the value -1.", &setlist),
     &showlist);

  /* FIXME, there should be a way to make a CORE_ADDR variable settable. */
  add_show_from_set
    (add_set_cmd ("call_scratch_address", class_support, var_uinteger,
		  (char *) &text_end,
		  "Set address in memory where small amounts of RAM can be used\n\
when making function calls into the inferior.", &setlist),
     &showlist);
}
@


1.5
log
@Update/correct copyright notices.
@
text
@d917 1
a917 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
@


1.4
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 2001
@


1.3
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d30 1
@


1.2
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995
d895 2
a896 1
    internal_error ("create_new_frame returned invalid frame id");
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
This file is part of GDB.
d8 14
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d49 1
a49 3
a29k_use_struct_convention (gcc_p, type)
     int gcc_p;
     struct type *type;
d61 4
a64 4
  unsigned mfp_used : 1;	/* memory frame pointer used */
  unsigned rsize_valid : 1;	/* Validity bits for the above */
  unsigned msize_valid : 1;
  unsigned mfp_valid : 1;
d84 1
a84 5
examine_prologue (pc, rsize, msize, mfp_used)
     CORE_ADDR pc;
     unsigned *msize;
     unsigned *rsize;
     int *mfp_used;
d92 1
a92 1
    mi = (struct prologue_info *) msymbol -> info;
d122 1
a122 1
  
d129 4
a132 4
	 might be a pair of instructions:
	 const <reg>, <rsize * 4>
	 sub gr1,gr1,<reg>
	 */
d136 1
a136 1
      
d170 1
a170 1
  if ((insn & 0xff00ffff) == (0x5e000100|RAB_HW_REGNUM))
d189 3
a191 3
	 const <reg>, <size *4>
	 add lr1,gr1,<reg>
	 */
d219 2
a220 2
  if (((insn & 0xff80ffff) == (0x15800000|(MSP_HW_REGNUM<<8)))     /* add */
   || ((insn & 0xff80ffff) == (0x81800000|(MSP_HW_REGNUM<<8))))    /* sll */
d236 1
a236 1
     */
d238 2
a239 2
  if ((insn & 0xffffff00) == 
		(0x25000000|(MSP_HW_REGNUM<<16)|(MSP_HW_REGNUM<<8)))
d242 1
a242 1
      if (msize != NULL) 
d248 1
a248 1
	 be
d250 4
a253 4
	 const <reg>, <msize>
	 consth <reg>, <msize>     ; optional
	 sub msp,msp,<reg>
	 */
d274 2
a275 2
          if ((insn & 0xffffff00) == 
		(0x24000000|(MSP_HW_REGNUM<<16)|(MSP_HW_REGNUM<<8))
d293 1
a293 1
  if ((insn & 0xff00ffff) == (0x5e000100|RAB_HW_REGNUM))
d298 1
a298 1
 done:
d304 2
a305 2
	  mi = (struct prologue_info *)xmalloc (sizeof (struct prologue_info));
	  msymbol -> info = (char *)mi;
d335 1
a335 2
skip_prologue (pc)
     CORE_ADDR pc;
d350 3
a352 7
static int	/* 0/1 - failure/success of finding the tag word  */
examine_tag (p, is_trans, argcount, msize, mfp_used)
     CORE_ADDR p;
     int *is_trans;
     int *argcount;
     unsigned *msize;
     int *mfp_used;
d359 1
a359 1
  if (tag1 & (1<<23)) 			/* A two word tag */
d361 3
a363 3
       tag2 = read_memory_integer (p-4, 4);
       if (msize)
	 *msize = tag2 * 2;
d365 2
a366 1
  else					/* A one word tag */
d368 2
a369 2
       if (msize)
	 *msize = tag1 & 0x7ff;
d372 1
a372 1
    *is_trans = ((tag1 & (1<<21)) ? 1 : 0);
d380 1
a380 1
    *mfp_used = ((tag1 & (1<<22)) ? 1 : 0); 
d390 1
a390 3
init_frame_info (innermost_frame, frame)
     int innermost_frame;
     struct frame_info *frame;
d405 2
a406 2
  
#if 0 /* CALL_DUMMY_LOCATION == ON_STACK */
d414 1
a414 1
	 from a dummy frame.  */
d417 1
a417 1
      frame->saved_msp = 
d419 1
a419 1
      frame->flags |= (TRANSPARENT_FRAME|MFP_USED);
d422 1
a422 1
    
d429 2
a430 2
	 do not trace back beyond the start of the text segment
	 (just as a sanity check to avoid going into never-never land).  */
d433 1
a433 1
	     && ((insn = read_memory_integer (p, 4)) & TAGWORD_ZERO_MASK) != 0)
d436 2
a437 1
      char pat[4] = {0, 0, 0, 0};
d442 1
a442 1
      target_search (4, pat, mask, p, -4, text_start, p+1, &p, &insn_raw);
d468 4
a471 4
  if (examine_tag(p-4,&trans,(int *)NULL,&msize,&mfp_used)) /* Found good tag */
      examine_prologue (p, &rsize, 0, 0);
  else 						/* No tag try prologue */
      examine_prologue (p, &rsize, &msize, &mfp_used);
d477 1
a477 1
  	frame->flags |= MFP_USED;
d479 1
a479 1
  	frame->flags |= TRANSPARENT_FRAME;
d487 2
a488 2
  	 frame->saved_msp =
	      read_register_stack_integer (frame->frame + rsize - 4, 4);
d490 1
a490 1
  	    frame->saved_msp = frame->next->saved_msp + msize;
d495 1
a495 2
init_extra_frame_info (frame)
     struct frame_info *frame;
d501 3
a503 2
  else {
      /* We're in get_prev_frame_info.
d510 1
a510 3
init_frame_pc (fromleaf, frame)
     int fromleaf;
     struct frame_info *frame;
d513 1
a513 1
	     frame->next ? FRAME_SAVED_PC (frame->next) : read_pc ());
d522 1
a522 2
frame_locals_address (fi)
     struct frame_info *fi;
d524 1
a524 1
  if (fi->flags & MFP_USED) 
d542 2
a543 5
read_register_stack (memaddr, myaddr, actual_mem_addr, lval)
     CORE_ADDR memaddr;
     char *myaddr;
     CORE_ADDR *actual_mem_addr;
     enum lval_type *lval;
d549 1
a549 1
  if (memaddr >= rstack_high_address) 
d552 2
a553 1
      static char val[] = {~0, ~0, ~0, ~0};
d561 1
a561 1
      supply_register(regnum, val);	/* More bogusness */
d587 1
a587 1
      if (myaddr != NULL) 
d599 1
a599 3
read_register_stack_integer (memaddr, len)
     CORE_ADDR memaddr;
     int len;
d610 2
a611 4
write_register_stack (memaddr, myaddr, actual_mem_addr)
     CORE_ADDR memaddr;
     char *myaddr;
     CORE_ADDR *actual_mem_addr;
d616 1
a616 1
  if (memaddr >= rstack_high_address) 
d620 1
a620 1
	*actual_mem_addr = 0; 
d629 1
a629 1
	write_register (regnum, *(long *)myaddr);
d652 3
a654 7
get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lvalp)
     char *raw_buffer;
     int *optimized;
     CORE_ADDR *addrp;
     struct frame_info *frame;
     int regnum;
     enum lval_type *lvalp;
d713 1
a713 1
	 so just print out the current values.  */
d722 1
a722 1
      
d737 1
a737 1
pop_frame ()
d740 1
a740 1
  CORE_ADDR rfb = read_register (RFB_REGNUM);		      
d742 1
a742 1
  CORE_ADDR lr1;							      
d752 1
a752 1
      int lrnum = LR0_REGNUM + DUMMY_ARG/4;
d754 1
a754 1
	write_register (SR_REGNUM (i + 128),read_register (lrnum++));
d756 1
a756 1
	write_register (SR_REGNUM(i+160), read_register (lrnum++));
d760 3
a762 3
      write_register(PC_REGNUM, read_register (lrnum++));
      write_register(NPC_REGNUM, read_register (lrnum++));
      write_register(PC2_REGNUM, read_register (lrnum++));
d769 1
a769 1
  /* Restore the register stack pointer.  */				      
d773 1
a773 1
  if (must_fix_lr0) 
d776 5
a780 5
  /* Check whether we need to fill registers.  */			      
  lr1 = read_register (LR0_REGNUM + 1);				      
  if (lr1 > rfb)							      
    {									      
      /* Fill.  */							      
d782 1
a782 1
      int i;								      
d784 5
a788 5
						      
      write_register (RAB_REGNUM, read_register (RAB_REGNUM) + num_bytes);  
      write_register (RFB_REGNUM, lr1);				      
      for (i = 0; i < num_bytes; i += 4)				      
        {
d790 3
a792 3
          word = read_memory_integer (rfb + i, 4);
          write_register (LR0_REGNUM + ((rfb - gr1) % 0x80) + i / 4, word);
        }								      
d794 1
a794 1
  flush_cached_frames ();						      
d799 2
a800 2
void 
push_dummy_frame ()
d807 1
a807 1
      
d813 1
a813 1
  /* Allocate the new frame. */ 
d857 1
a857 1
  lrnum = LR0_REGNUM + DUMMY_ARG/4;
d885 1
a885 3
setup_arbitrary_frame (argc, argv)
     int argc;
     CORE_ADDR *argv;
d895 2
a896 2
    fatal ("internal: create_new_frame returned invalid frame id");
  
d912 1
a912 3
gdb_print_insn_a29k (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
d923 1
a923 1
a29k_get_processor_type ()
d967 1
a967 1
  longjmp and haven't yet setup the stack frame, so the args are still in the
d973 1
a973 2
get_longjmp_target(pc)
     CORE_ADDR *pc;
d976 1
a976 1
  char buf[sizeof(CORE_ADDR)];
d978 1
a978 1
  jb_addr = read_register(LR2_REGNUM);
d980 2
a981 2
  if (target_read_memory(jb_addr + JB_PC * JB_ELEMENT_SIZE, (char *) buf,
                         sizeof(CORE_ADDR)))
d984 1
a984 1
  *pc = extract_address ((PTR) buf, sizeof(CORE_ADDR));
d990 1
a990 1
_initialize_a29k_tdep ()
d999 1
a999 1
		  (char *)&rstack_high_address,
d1008 2
a1009 2
		  (char *)&text_end,
"Set address in memory where small amounts of RAM can be used\n\
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d513 1
a513 1
      /* We're in get_prev_frame.
d671 1
a671 1
a29k_get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lvalp)
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@d340 1
a340 1
a29k_skip_prologue (pc)
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d6 1
a6 1
   This file is part of GDB.
d8 13
a20 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d62 4
a65 4
  unsigned mfp_used:1;		/* memory frame pointer used */
  unsigned rsize_valid:1;	/* Validity bits for the above */
  unsigned msize_valid:1;
  unsigned mfp_valid:1;
d97 1
a97 1
    mi = (struct prologue_info *) msymbol->info;
d127 1
a127 1

d134 4
a137 4
         might be a pair of instructions:
         const <reg>, <rsize * 4>
         sub gr1,gr1,<reg>
       */
d141 1
a141 1

d175 1
a175 1
  if ((insn & 0xff00ffff) == (0x5e000100 | RAB_HW_REGNUM))
d194 3
a196 3
         const <reg>, <size *4>
         add lr1,gr1,<reg>
       */
d224 2
a225 2
  if (((insn & 0xff80ffff) == (0x15800000 | (MSP_HW_REGNUM << 8)))	/* add */
      || ((insn & 0xff80ffff) == (0x81800000 | (MSP_HW_REGNUM << 8))))	/* sll */
d241 1
a241 1
   */
d243 2
a244 2
  if ((insn & 0xffffff00) ==
      (0x25000000 | (MSP_HW_REGNUM << 16) | (MSP_HW_REGNUM << 8)))
d247 1
a247 1
      if (msize != NULL)
d253 1
a253 1
         be
d255 4
a258 4
         const <reg>, <msize>
         consth <reg>, <msize>     ; optional
         sub msp,msp,<reg>
       */
d279 2
a280 2
	  if ((insn & 0xffffff00) ==
	      (0x24000000 | (MSP_HW_REGNUM << 16) | (MSP_HW_REGNUM << 8))
d298 1
a298 1
  if ((insn & 0xff00ffff) == (0x5e000100 | RAB_HW_REGNUM))
d303 1
a303 1
done:
d309 2
a310 2
	  mi = (struct prologue_info *) xmalloc (sizeof (struct prologue_info));
	  msymbol->info = (char *) mi;
d356 1
a356 1
static int			/* 0/1 - failure/success of finding the tag word  */
d369 1
a369 1
  if (tag1 & (1 << 23))		/* A two word tag */
d371 3
a373 3
      tag2 = read_memory_integer (p - 4, 4);
      if (msize)
	*msize = tag2 * 2;
d375 1
a375 2
  else
    /* A one word tag */
d377 2
a378 2
      if (msize)
	*msize = tag1 & 0x7ff;
d381 1
a381 1
    *is_trans = ((tag1 & (1 << 21)) ? 1 : 0);
d389 1
a389 1
    *mfp_used = ((tag1 & (1 << 22)) ? 1 : 0);
d416 2
a417 2

#if 0				/* CALL_DUMMY_LOCATION == ON_STACK */
d425 1
a425 1
         from a dummy frame.  */
d428 1
a428 1
      frame->saved_msp =
d430 1
a430 1
      frame->flags |= (TRANSPARENT_FRAME | MFP_USED);
d433 1
a433 1

d440 2
a441 2
         do not trace back beyond the start of the text segment
         (just as a sanity check to avoid going into never-never land).  */
d444 1
a444 1
	  && ((insn = read_memory_integer (p, 4)) & TAGWORD_ZERO_MASK) != 0)
d447 1
a447 2
      char pat[4] =
      {0, 0, 0, 0};
d452 1
a452 1
      target_search (4, pat, mask, p, -4, text_start, p + 1, &p, &insn_raw);
d478 4
a481 4
  if (examine_tag (p - 4, &trans, (int *) NULL, &msize, &mfp_used))	/* Found good tag */
    examine_prologue (p, &rsize, 0, 0);
  else				/* No tag try prologue */
    examine_prologue (p, &rsize, &msize, &mfp_used);
d487 1
a487 1
    frame->flags |= MFP_USED;
d489 1
a489 1
    frame->flags |= TRANSPARENT_FRAME;
d497 2
a498 2
	frame->saved_msp =
	  read_register_stack_integer (frame->frame + rsize - 4, 4);
d500 1
a500 1
	frame->saved_msp = frame->next->saved_msp + msize;
d512 1
a512 2
  else
    {
d525 1
a525 1
	       frame->next ? FRAME_SAVED_PC (frame->next) : read_pc ());
d537 1
a537 1
  if (fi->flags & MFP_USED)
d565 1
a565 1
  if (memaddr >= rstack_high_address)
d568 1
a568 2
      static char val[] =
      {~0, ~0, ~0, ~0};
d576 1
a576 1
      supply_register (regnum, val);	/* More bogusness */
d602 1
a602 1
      if (myaddr != NULL)
d635 1
a635 1
  if (memaddr >= rstack_high_address)
d639 1
a639 1
	*actual_mem_addr = 0;
d648 1
a648 1
	write_register (regnum, *(long *) myaddr);
d736 1
a736 1
         so just print out the current values.  */
d745 1
a745 1

d763 1
a763 1
  CORE_ADDR rfb = read_register (RFB_REGNUM);
d765 1
a765 1
  CORE_ADDR lr1;
d775 1
a775 1
      int lrnum = LR0_REGNUM + DUMMY_ARG / 4;
d777 1
a777 1
	write_register (SR_REGNUM (i + 128), read_register (lrnum++));
d779 1
a779 1
	write_register (SR_REGNUM (i + 160), read_register (lrnum++));
d783 3
a785 3
      write_register (PC_REGNUM, read_register (lrnum++));
      write_register (NPC_REGNUM, read_register (lrnum++));
      write_register (PC2_REGNUM, read_register (lrnum++));
d792 1
a792 1
  /* Restore the register stack pointer.  */
d796 1
a796 1
  if (must_fix_lr0)
d799 5
a803 5
  /* Check whether we need to fill registers.  */
  lr1 = read_register (LR0_REGNUM + 1);
  if (lr1 > rfb)
    {
      /* Fill.  */
d805 1
a805 1
      int i;
d807 5
a811 5

      write_register (RAB_REGNUM, read_register (RAB_REGNUM) + num_bytes);
      write_register (RFB_REGNUM, lr1);
      for (i = 0; i < num_bytes; i += 4)
	{
d813 3
a815 3
	  word = read_memory_integer (rfb + i, 4);
	  write_register (LR0_REGNUM + ((rfb - gr1) % 0x80) + i / 4, word);
	}
d817 1
a817 1
  flush_cached_frames ();
d822 1
a822 1
void
d830 1
a830 1

d836 1
a836 1
  /* Allocate the new frame. */
d880 1
a880 1
  lrnum = LR0_REGNUM + DUMMY_ARG / 4;
d921 1
a921 1

d994 1
a994 1
   longjmp and haven't yet setup the stack frame, so the args are still in the
d1000 1
a1000 1
get_longjmp_target (pc)
d1004 1
a1004 1
  char buf[sizeof (CORE_ADDR)];
d1006 1
a1006 1
  jb_addr = read_register (LR2_REGNUM);
d1008 2
a1009 2
  if (target_read_memory (jb_addr + JB_PC * JB_ELEMENT_SIZE, (char *) buf,
			  sizeof (CORE_ADDR)))
d1012 1
a1012 1
  *pc = extract_address ((PTR) buf, sizeof (CORE_ADDR));
d1027 1
a1027 1
		  (char *) &rstack_high_address,
d1036 2
a1037 2
		  (char *) &text_end,
		  "Set address in memory where small amounts of RAM can be used\n\
@


1.1.1.5
log
@import gdb-1999-08-09 snapshot
@
text
@d925 1
a925 1
    internal_error ("create_new_frame returned invalid frame id");
@


