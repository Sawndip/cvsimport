head	1.11;
access;
symbols
	cagney-unwind-20030108-branch:1.10.0.2
	cagney-unwind-20030108-branchpoint:1.10
	carlton_dictionary-20021223-merge:1.10
	gdb_5_3-2002-12-12-release:1.9
	carlton_dictionary-20021115-merge:1.10
	kseitz_interps-20021105-merge:1.9
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.9
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.26
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.24
	carlton_dictionary-20020920-branchpoint:1.9
	gdb_5_3-branch:1.9.0.22
	gdb_5_3-2002-09-04-branchpoint:1.9
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.20
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.18
	readline_4_3-import-branchpoint:1.9
	gdb_5_2_1-2002-07-23-release:1.9
	kseitz_interps-20020528-branch:1.9.0.16
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.14
	cagney_regbuf-20020515-branchpoint:1.9
	jimb-macro-020506-branch:1.9.0.12
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	gdb_5_2-branch:1.9.0.10
	gdb_5_2-2002-03-03-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.9
	gdb_5_1_0_1-2002-01-03-release:1.9
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.8
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.6
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.4
	gdb_5_1-2001-07-29-branchpoint:1.9
	dberlin-typesystem-branch:1.9.0.2
	dberlin-typesystem-branchpoint:1.9
	gdb-post-ptid_t-2001-05-03:1.9
	gdb-pre-ptid_t-2001-05-03:1.8
	insight-precleanup-2001-01-01:1.6
	gdb-post-protoization-2000-07-29:1.5
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb-post-params-removal-2000-06-04:1.4
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.11
date	2003.01.31.20.43.53;	author cagney;	state dead;
branches;
next	1.10;

1.10
date	2002.11.14.20.37.28;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.04.04.15.26;	author kevinb;	state Exp;
branches
	1.9.24.1
	1.9.26.1;
next	1.8;

1.8
date	2001.03.06.08.21.11;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.30.02.39.10;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.26.23.22.41;	author msnyder;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.10.17.38.16;	author msnyder;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.59;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.08.48;	author jsm;	state Exp;
branches;
next	;

1.9.24.1
date	2002.11.15.19.18.52;	author carlton;	state Exp;
branches;
next	1.9.24.2;

1.9.24.2
date	2003.02.07.19.17.51;	author carlton;	state dead;
branches;
next	;

1.9.26.1
date	2003.12.14.20.27.28;	author drow;	state dead;
branches;
next	;


desc
@@


1.11
log
@2003-01-31  Andrew Cagney  <ac131313@@redhat.com>

	* config/djgpp/fnchange.lst: Delete nindy files.
	* nindy-share/ttyflush.c, nindy-share/stop.h: Delete files.
	* nindy-share/nindy.c, nindy-share/env.h: Delete files.
	* nindy-share/coff.h, nindy-share/block_io.h: Delete files.
	* nindy-share/b.out.h, nindy-share/VERSION: Delete files.
	* nindy-share/README, nindy-share/Onindy.c: Delete files.
	* nindy-tdep.c, nindy-share/Makefile: Delete files.
	* Makefile.in (init.c): Remove nindy references.
	(saber_gdb): Delete rule.
	(ALLDEPFILES): Delete hp300ux-nat.c, nindy-tdep.c,
	nindy-share/Onindy.c, nindy-share/nindy.c, nindy-share/ttyflush.c,
	and a68v-nat.c.
	(hp300ux-nat.o, a68v-nat.o, ptx4-nat.o): Delete rules.
	(Onindy.o, nindy.o, ttyflush.o, nindy-tdep.o): Delete rules.
	(HFILES_NO_SRCDIR): Delete nindy-share/b.out.h,
	nindy-share/block_io.h, nindy-share/coff.h, nindy-share/env.h, and
	nindy-share/stop.h.
	* hp300ux-nat.c, a68v-nat.c, ptx4-nat.c: Delete files.
	* saber.suppress: Delete file.
@
text
@/* Native-dependent code for ptx 4.0
   Copyright 1988, 1989, 1991, 1992, 1994, 1999, 2000, 2001
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "inferior.h"
#include "gdbcore.h"
#include "regcache.h"
#include <sys/procfs.h>
#include <sys/ptrace.h>
#include <sys/param.h>
#include <fcntl.h>

/* Prototypes for supply_gregset etc. */
#include "gregset.h"

/*  Given a pointer to a general register set in /proc format (gregset_t *),
   unpack the register contents and supply them as gdb's idea of the current
   register values. */

void
supply_gregset (gregset_t *gregsetp)
{
  supply_register (EAX_REGNUM, (char *) &(*gregsetp)[EAX]);
  supply_register (EDX_REGNUM, (char *) &(*gregsetp)[EDX]);
  supply_register (ECX_REGNUM, (char *) &(*gregsetp)[ECX]);
  supply_register (EBX_REGNUM, (char *) &(*gregsetp)[EBX]);
  supply_register (ESI_REGNUM, (char *) &(*gregsetp)[ESI]);
  supply_register (EDI_REGNUM, (char *) &(*gregsetp)[EDI]);
  supply_register (ESP_REGNUM, (char *) &(*gregsetp)[UESP]);
  supply_register (EBP_REGNUM, (char *) &(*gregsetp)[EBP]);
  supply_register (EIP_REGNUM, (char *) &(*gregsetp)[EIP]);
  supply_register (EFLAGS_REGNUM, (char *) &(*gregsetp)[EFL]);
}

void
fill_gregset (gregset_t *gregsetp, int regno)
{
  int regi;

  for (regi = 0; regi < NUM_REGS; regi++)
    {
      if ((regno == -1) || (regno == regi))
	{
	  (*gregsetp)[regi] = *(greg_t *) & deprecated_registers[REGISTER_BYTE (regi)];
	}
    }
}

/*  Given a pointer to a floating point register set in /proc format
   (fpregset_t *), unpack the register contents and supply them as gdb's
   idea of the current floating point register values. */

void
supply_fpregset (fpregset_t *fpregsetp)
{
  supply_fpu_registers ((struct fpusave *) &fpregsetp->fp_reg_set);
  supply_fpa_registers ((struct fpasave *) &fpregsetp->f_wregs);
}

/*  Given a pointer to a floating point register set in /proc format
   (fpregset_t *), update the register specified by REGNO from gdb's idea
   of the current floating point register set.  If REGNO is -1, update
   them all. */

void
fill_fpregset (fpregset_t *fpregsetp, int regno)
{
  int regi;
  char *to;
  char *from;

  /* FIXME: see m68k-tdep.c for an example, for the m68k. */
}

/*
 * This doesn't quite do the same thing as the procfs.c version, but give
 * it the same name so we don't have to put an ifdef in solib.c.
 */
/* this could use elf_interpreter() from elfread.c */
int
proc_iterate_over_mappings (int (*func) (int, CORE_ADDR))
{
  vaddr_t curseg, memptr;
  pt_vseg_t pv;
  int rv, cmperr;
  sec_ptr interp_sec;
  char *interp_content;
  int interp_fd, funcstat;
  unsigned int size;
  char buf1[NBPG], buf2[NBPG];

  /*
   * The following is really vile.  We can get the name of the
   * shared library from the exec_bfd, and we can get a list of
   * each virtual memory segment, but there is no simple way to
   * find the mapped segment from the shared library (ala
   * procfs's PIOCOPENMEM).  As a pretty nasty kludge, we
   * compare the virtual memory segment to the contents of the
   * .interp file.  If they match, we assume that we've got the
   * right one.
   */

  /*
   * TODO: for attach, use XPT_OPENT to get the executable, in
   * case we're attached without knowning the executable's
   * filename.
   */

#ifdef VERBOSE_DEBUG
  printf ("proc_iter\n");
#endif
  interp_sec = bfd_get_section_by_name (exec_bfd, ".interp");
  if (!interp_sec)
    {
      return 0;
    }

  size = bfd_section_size (exec_bfd, interp_sec);
  interp_content = alloca (size);
  if (0 == bfd_get_section_contents (exec_bfd, interp_sec,
				     interp_content, (file_ptr) 0, size))
    {
      return 0;
    }

#ifdef VERBOSE_DEBUG
  printf ("proc_iter: \"%s\"\n", interp_content);
#endif
  interp_fd = open (interp_content, O_RDONLY, 0);
  if (-1 == interp_fd)
    {
      return 0;
    }

  curseg = 0;
  while (1)
    {
      rv = ptrace (PT_NEXT_VSEG, PIDGET (inferior_ptid), &pv, curseg);
#ifdef VERBOSE_DEBUG
      printf ("PT_NEXT_VSEG: rv %d errno %d\n", rv, errno);
#endif
      if (-1 == rv)
	break;
      if (0 == rv)
	break;
#ifdef VERBOSE_DEBUG
      printf ("pv.pv_start 0x%x pv_size 0x%x pv_prot 0x%x\n",
	      pv.pv_start, pv.pv_size, pv.pv_prot);
#endif
      curseg = pv.pv_start + pv.pv_size;

      rv = lseek (interp_fd, 0, SEEK_SET);
      if (-1 == rv)
	{
	  perror ("lseek");
	  close (interp_fd);
	  return 0;
	}
      for (memptr = pv.pv_start; memptr < pv.pv_start + pv.pv_size;
	   memptr += NBPG)
	{
#ifdef VERBOSE_DEBUG
	  printf ("memptr 0x%x\n", memptr);
#endif
	  rv = read (interp_fd, buf1, NBPG);
	  if (-1 == rv)
	    {
	      perror ("read");
	      close (interp_fd);
	      return 0;
	    }
	  rv = ptrace (PT_RDATA_PAGE, PIDGET (inferior_ptid), buf2,
		       memptr);
	  if (-1 == rv)
	    {
	      perror ("ptrace");
	      close (interp_fd);
	      return 0;
	    }
	  cmperr = memcmp (buf1, buf2, NBPG);
	  if (cmperr)
	    break;
	}
      if (0 == cmperr)
	{
	  /* this is it */
	  funcstat = (*func) (interp_fd, pv.pv_start);
	  break;
	}
    }
  close (interp_fd);
  return 0;
}
@


1.10
log
@2002-11-14  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_registers): Rename registers.
	* a68v-nat.c, alpha-nat.c, arch-utils.c, core-sol2.c: Update.
	* hp300ux-nat.c, hppab-nat.c, hppah-nat.c: Update.
	* hppam3-nat.c, hpux-thread.c, i386gnu-nat.c: Update.
	* ia64-aix-nat.c, ia64-linux-nat.c, ia64-tdep.c: Update.
	* irix4-nat.c, irix5-nat.c, lynx-nat.c, m68k-tdep.c: Update.
	* m68knbsd-nat.c, mips-linux-tdep.c, mipsm3-nat.c: Update.
	* mipsv4-nat.c, ns32knbsd-nat.c, ppc-bdm.c: Update.
	* ppc-sysv-tdep.c, ptx4-nat.c, regcache.c, remote-es.c: Update.
	* remote-sds.c, remote-vx68.c, remote-vxmips.c: Update.
	* remote-vxsparc.c, rs6000-tdep.c, sol-thread.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, symm-nat.c: Update.
	* v850ice.c: Update.
@
text
@@


1.9
log
@Phase 1 of the ptid_t changes.
@
text
@d62 1
a62 1
	  (*gregsetp)[regi] = *(greg_t *) & registers[REGISTER_BYTE (regi)];
@


1.9.26.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.9.24.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d62 1
a62 1
	  (*gregsetp)[regi] = *(greg_t *) & deprecated_registers[REGISTER_BYTE (regi)];
@


1.9.24.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@@


1.8
log
@Update/correct copyright notices.
@
text
@d156 1
a156 1
      rv = ptrace (PT_NEXT_VSEG, inferior_pid, &pv, curseg);
d190 1
a190 1
	  rv = ptrace (PT_RDATA_PAGE, inferior_pid, buf2,
@


1.7
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1988, 1989, 1991, 1992, 2001 Free Software Foundation,
   Inc.
@


1.6
log
@Protoization.
@
text
@d2 2
a3 1
   Copyright 1988, 1989, 1991, 1992 Free Software Foundation, Inc.
d25 1
@


1.5
log
@Protoization.
@
text
@d97 1
a97 2
proc_iterate_over_mappings (func)
     int (*func) (int, CORE_ADDR);
@


1.4
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d37 1
a37 2
supply_gregset (gregsetp)
     gregset_t *gregsetp;
d52 1
a52 3
fill_gregset (gregsetp, regno)
     gregset_t *gregsetp;
     int regno;
d70 1
a70 2
supply_fpregset (fpregsetp)
     fpregset_t *fpregsetp;
d82 1
a82 3
fill_fpregset (fpregsetp, regno)
     fpregset_t *fpregsetp;
     int regno;
@


1.3
log
@2000-05-26  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * gregset.h: New file.  Typedefs for gdb_gregset_t and
        gdb_fpregset_t, prototypes for supply_gregset and friends.
        * procfs.c: Include gregset.h.  Delete local prototypes for
        supply_gregset etc., and local typedef gdb_gregset_t etc.
        * sol-thread.c: Include gregset.h, delete local prototypes,
        add appropriate casts to gdb_gregset_t.
        * uw-thread.c, lin-thread.c, core-sol2.c, core-regset.c,
        sparc-tdep.c, ptx4-nat.c, ppc-linux-nat.c, mipsv4-nat.c,
        m88k-nat.c, m68klinux-nat.c, m68k-tdep.c, irix5-nat.c,
        irix4-nat.c, ia64-linux-nat.c, i386v4-nat.c, cxux-nat.c,
        arm-linux-nat.c, alpha-nat.c: Include gregset.h.
        * config/nm-linux.h: Define GDB_GREGSET_T, GDB_FPREGET_T.
        * config/sparc/tm-sun4sol2.h: Ditto.
@
text
@d104 1
a104 1
     int (*func) PARAMS ((int, CORE_ADDR));
@


1.2
log
@2000-05-08  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * gdbarch.sh: Add FP0_REGNUM to list of multi-arched register numbers.
        * gdbarch.c, gdbarch.h: Regenerate.
        * core-regset.c: Change FP0_REGNUM to a runtime test.
        * procfs.c: Ditto.
        * sun3-nat.c: Ditto.
        * sparc-tdep.c: Ditto.

        * i386mach-nat.c: Remove unnecessary ifdef for FP0_REGNUM.
        * ptx4-nat.c: Ditto.

        * sol-thread.c (sol_thread_create_inferior): only add the thread
        to the thread list if it is not already in there.
        (prototypes for thread_db func ptrs): pretty up formatting.
@
text
@d29 3
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d30 2
a31 2
    unpack the register contents and supply them as gdb's idea of the current
    register values. */
d37 10
a46 10
	supply_register(EAX_REGNUM, (char *)&(*gregsetp)[EAX]);
	supply_register(EDX_REGNUM, (char *)&(*gregsetp)[EDX]);
	supply_register(ECX_REGNUM, (char *)&(*gregsetp)[ECX]);
	supply_register(EBX_REGNUM, (char *)&(*gregsetp)[EBX]);
	supply_register(ESI_REGNUM, (char *)&(*gregsetp)[ESI]);
	supply_register(EDI_REGNUM, (char *)&(*gregsetp)[EDI]);
	supply_register(ESP_REGNUM, (char *)&(*gregsetp)[UESP]);
	supply_register(EBP_REGNUM, (char *)&(*gregsetp)[EBP]);
	supply_register(EIP_REGNUM, (char *)&(*gregsetp)[EIP]);
	supply_register(EFLAGS_REGNUM, (char *)&(*gregsetp)[EFL]);
a54 1
  extern char registers[];
d56 1
a56 1
  for (regi = 0 ; regi < NUM_REGS ; regi++)
d60 1
a60 1
	  (*gregsetp)[regi] = *(greg_t *)&registers[REGISTER_BYTE (regi)];
a64 2
#if defined (FP0_REGNUM)

d66 2
a67 2
    (fpregset_t *), unpack the register contents and supply them as gdb's
    idea of the current floating point register values. */
d69 1
a69 1
void 
d73 2
a74 2
  supply_fpu_registers((struct fpusave *)&fpregsetp->fp_reg_set);
  supply_fpa_registers((struct fpasave *)&fpregsetp->f_wregs);
d78 3
a80 3
    (fpregset_t *), update the register specified by REGNO from gdb's idea
    of the current floating point register set.  If REGNO is -1, update
    them all. */
a89 1
  extern char registers[];
a93 2
#endif	/* defined (FP0_REGNUM) */

d100 2
a101 2
proc_iterate_over_mappings(func)
	int (*func) PARAMS ((int, CORE_ADDR));
d103 25
a127 25
	vaddr_t curseg, memptr;
	pt_vseg_t pv;
	int rv, cmperr;
	sec_ptr interp_sec;
	char *interp_content;
	int interp_fd, funcstat;
	unsigned int size;
	char buf1[NBPG], buf2[NBPG];

	/*
	 * The following is really vile.  We can get the name of the
	 * shared library from the exec_bfd, and we can get a list of
	 * each virtual memory segment, but there is no simple way to
	 * find the mapped segment from the shared library (ala
	 * procfs's PIOCOPENMEM).  As a pretty nasty kludge, we
	 * compare the virtual memory segment to the contents of the
	 * .interp file.  If they match, we assume that we've got the
	 * right one.
	 */

	/*
	 * TODO: for attach, use XPT_OPENT to get the executable, in
	 * case we're attached without knowning the executable's
	 * filename.
	 */
d130 1
a130 1
	printf("proc_iter\n");
d132 5
a136 4
	interp_sec = bfd_get_section_by_name(exec_bfd, ".interp");
	if (!interp_sec) {
		return 0;
	}
d138 7
a144 6
	size = bfd_section_size(exec_bfd, interp_sec);
	interp_content = alloca(size);
	if (0 == bfd_get_section_contents(exec_bfd, interp_sec,
		interp_content, (file_ptr)0, size)) {
		return 0;
	}
d147 1
a147 1
	printf("proc_iter: \"%s\"\n", interp_content);
d149 5
a153 4
	interp_fd = open(interp_content, O_RDONLY, 0);
	if (-1 == interp_fd) {
		return 0;
	}
d155 4
a158 3
	curseg = 0;
	while (1) {
		rv = ptrace(PT_NEXT_VSEG, inferior_pid, &pv, curseg);
d160 1
a160 1
		printf("PT_NEXT_VSEG: rv %d errno %d\n", rv, errno);
d162 4
a165 4
		if (-1 == rv)
			break;
		if (0 == rv)
			break;
d167 2
a168 2
		printf("pv.pv_start 0x%x pv_size 0x%x pv_prot 0x%x\n",
		       pv.pv_start, pv.pv_size, pv.pv_prot);
d170 1
a170 1
		curseg = pv.pv_start + pv.pv_size;
d172 10
a181 8
		rv = lseek(interp_fd, 0, SEEK_SET);
		if (-1 == rv) {
			perror("lseek");
			close(interp_fd);
			return 0;
		}
		for (memptr = pv.pv_start; memptr < pv.pv_start + pv.pv_size;
		     memptr += NBPG) {
d183 1
a183 1
			printf("memptr 0x%x\n", memptr);
d185 24
a208 22
			rv = read(interp_fd, buf1, NBPG);
			if (-1 == rv) {
				perror("read");
				close(interp_fd);
				return 0;
			}
			rv = ptrace(PT_RDATA_PAGE, inferior_pid, buf2,
				    memptr);
			if (-1 == rv) {
				perror("ptrace");
				close(interp_fd);
				return 0;
			}
			cmperr = memcmp(buf1, buf2, NBPG);
			if (cmperr)
				break;
		}
		if (0 == cmperr) {
			/* this is it */
			funcstat = (*func)(interp_fd, pv.pv_start);
			break;
		}
d210 3
a212 2
	close(interp_fd);
	return 0;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d54 1
d92 1
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d29 2
a30 2
   unpack the register contents and supply them as gdb's idea of the current
   register values. */
d36 10
a45 10
  supply_register (EAX_REGNUM, (char *) &(*gregsetp)[EAX]);
  supply_register (EDX_REGNUM, (char *) &(*gregsetp)[EDX]);
  supply_register (ECX_REGNUM, (char *) &(*gregsetp)[ECX]);
  supply_register (EBX_REGNUM, (char *) &(*gregsetp)[EBX]);
  supply_register (ESI_REGNUM, (char *) &(*gregsetp)[ESI]);
  supply_register (EDI_REGNUM, (char *) &(*gregsetp)[EDI]);
  supply_register (ESP_REGNUM, (char *) &(*gregsetp)[UESP]);
  supply_register (EBP_REGNUM, (char *) &(*gregsetp)[EBP]);
  supply_register (EIP_REGNUM, (char *) &(*gregsetp)[EIP]);
  supply_register (EFLAGS_REGNUM, (char *) &(*gregsetp)[EFL]);
d55 1
a55 1
  for (regi = 0; regi < NUM_REGS; regi++)
d59 1
a59 1
	  (*gregsetp)[regi] = *(greg_t *) & registers[REGISTER_BYTE (regi)];
d67 2
a68 2
   (fpregset_t *), unpack the register contents and supply them as gdb's
   idea of the current floating point register values. */
d70 1
a70 1
void
d74 2
a75 2
  supply_fpu_registers ((struct fpusave *) &fpregsetp->fp_reg_set);
  supply_fpa_registers ((struct fpasave *) &fpregsetp->f_wregs);
d79 3
a81 3
   (fpregset_t *), update the register specified by REGNO from gdb's idea
   of the current floating point register set.  If REGNO is -1, update
   them all. */
d95 1
a95 1
#endif /* defined (FP0_REGNUM) */
d103 2
a104 2
proc_iterate_over_mappings (func)
     int (*func) PARAMS ((int, CORE_ADDR));
d106 25
a130 25
  vaddr_t curseg, memptr;
  pt_vseg_t pv;
  int rv, cmperr;
  sec_ptr interp_sec;
  char *interp_content;
  int interp_fd, funcstat;
  unsigned int size;
  char buf1[NBPG], buf2[NBPG];

  /*
   * The following is really vile.  We can get the name of the
   * shared library from the exec_bfd, and we can get a list of
   * each virtual memory segment, but there is no simple way to
   * find the mapped segment from the shared library (ala
   * procfs's PIOCOPENMEM).  As a pretty nasty kludge, we
   * compare the virtual memory segment to the contents of the
   * .interp file.  If they match, we assume that we've got the
   * right one.
   */

  /*
   * TODO: for attach, use XPT_OPENT to get the executable, in
   * case we're attached without knowning the executable's
   * filename.
   */
d133 1
a133 1
  printf ("proc_iter\n");
d135 4
a138 5
  interp_sec = bfd_get_section_by_name (exec_bfd, ".interp");
  if (!interp_sec)
    {
      return 0;
    }
d140 6
a145 7
  size = bfd_section_size (exec_bfd, interp_sec);
  interp_content = alloca (size);
  if (0 == bfd_get_section_contents (exec_bfd, interp_sec,
				     interp_content, (file_ptr) 0, size))
    {
      return 0;
    }
d148 1
a148 1
  printf ("proc_iter: \"%s\"\n", interp_content);
d150 4
a153 5
  interp_fd = open (interp_content, O_RDONLY, 0);
  if (-1 == interp_fd)
    {
      return 0;
    }
d155 3
a157 4
  curseg = 0;
  while (1)
    {
      rv = ptrace (PT_NEXT_VSEG, inferior_pid, &pv, curseg);
d159 1
a159 1
      printf ("PT_NEXT_VSEG: rv %d errno %d\n", rv, errno);
d161 4
a164 4
      if (-1 == rv)
	break;
      if (0 == rv)
	break;
d166 2
a167 2
      printf ("pv.pv_start 0x%x pv_size 0x%x pv_prot 0x%x\n",
	      pv.pv_start, pv.pv_size, pv.pv_prot);
d169 1
a169 1
      curseg = pv.pv_start + pv.pv_size;
d171 8
a178 10
      rv = lseek (interp_fd, 0, SEEK_SET);
      if (-1 == rv)
	{
	  perror ("lseek");
	  close (interp_fd);
	  return 0;
	}
      for (memptr = pv.pv_start; memptr < pv.pv_start + pv.pv_size;
	   memptr += NBPG)
	{
d180 1
a180 1
	  printf ("memptr 0x%x\n", memptr);
d182 22
a203 24
	  rv = read (interp_fd, buf1, NBPG);
	  if (-1 == rv)
	    {
	      perror ("read");
	      close (interp_fd);
	      return 0;
	    }
	  rv = ptrace (PT_RDATA_PAGE, inferior_pid, buf2,
		       memptr);
	  if (-1 == rv)
	    {
	      perror ("ptrace");
	      close (interp_fd);
	      return 0;
	    }
	  cmperr = memcmp (buf1, buf2, NBPG);
	  if (cmperr)
	    break;
	}
      if (0 == cmperr)
	{
	  /* this is it */
	  funcstat = (*func) (interp_fd, pv.pv_start);
	  break;
d205 2
a206 3
    }
  close (interp_fd);
  return 0;
@

