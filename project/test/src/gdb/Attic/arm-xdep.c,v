head	1.3;
access;
symbols
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.1.1.6
	gdb-pre-protoization-2000-07-29:1.1.1.6
	gdb-premipsmulti-2000-06-06-branch:1.1.1.6.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.6
	gdb-post-params-removal-2000-06-04:1.1.1.6
	gdb-pre-params-removal-2000-06-04:1.1.1.6
	gdb-post-params-removal-2000-05-28:1.1.1.6
	gdb-pre-params-removal-2000-05-28:1.1.1.6
	gdb_5_0-2000-05-19-release:1.1.1.6
	gdb_4_18_2-2000-05-18-release:1.1.1.6
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.6
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.6
	gdb_5_0-2000-04-10-branch:1.1.1.6.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.6
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.5
	gdb-1999-12-07:1.1.1.5
	gdb-1999-12-06:1.1.1.5
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.4
	gdb-1999-10-25:1.1.1.4
	gdb-1999-10-18:1.1.1.4
	gdb-1999-10-11:1.1.1.4
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.4
	gdb-1999-09-13:1.1.1.4
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.3
date	2001.02.08.06.30.23;	author cagney;	state dead;
branches;
next	1.2;

1.2
date	2000.12.15.01.01.45;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.23.34;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.04.15;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.08.09.21.33.18;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.12.07.03.55.58;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.12.22.21.45.03;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Remove configurations marked as obsolete in 5.0.
@
text
@/* OBSOLETE /* Acorn Risc Machine host machine support. */
/* OBSOLETE    Copyright (C) 1988, 1989, 1991 Free Software Foundation, Inc. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "frame.h" */
/* OBSOLETE #include "inferior.h" */
/* OBSOLETE #include "opcode/arm.h" */
/* OBSOLETE  */
/* OBSOLETE #include <sys/param.h> */
/* OBSOLETE #include <sys/dir.h> */
/* OBSOLETE #include <signal.h> */
/* OBSOLETE #include <sys/ioctl.h> */
/* OBSOLETE #include <sys/ptrace.h> */
/* OBSOLETE #include <machine/reg.h> */
/* OBSOLETE  */
/* OBSOLETE #define N_TXTADDR(hdr) 0x8000 */
/* OBSOLETE #define N_DATADDR(hdr) (hdr.a_text + 0x8000) */
/* OBSOLETE  */
/* OBSOLETE #include "gdbcore.h" */
/* OBSOLETE  */
/* OBSOLETE #include <sys/user.h>		/* After a.out.h  *x/ */
/* OBSOLETE #include <sys/file.h> */
/* OBSOLETE #include "gdb_stat.h" */
/* OBSOLETE  */
/* OBSOLETE #include <errno.h> */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE fetch_inferior_registers (regno) */
/* OBSOLETE      int regno;			/* Original value discarded *x/ */
/* OBSOLETE { */
/* OBSOLETE   register unsigned int regaddr; */
/* OBSOLETE   char buf[MAX_REGISTER_RAW_SIZE]; */
/* OBSOLETE   register int i; */
/* OBSOLETE  */
/* OBSOLETE   struct user u; */
/* OBSOLETE   unsigned int offset = (char *) &u.u_ar0 - (char *) &u; */
/* OBSOLETE   offset = ptrace (PT_READ_U, inferior_pid, (PTRACE_ARG3_TYPE) offset, 0) */
/* OBSOLETE     - KERNEL_U_ADDR; */
/* OBSOLETE  */
/* OBSOLETE   registers_fetched (); */
/* OBSOLETE  */
/* OBSOLETE   for (regno = 0; regno < 16; regno++) */
/* OBSOLETE     { */
/* OBSOLETE       regaddr = offset + regno * 4; */
/* OBSOLETE       *(int *) &buf[0] = ptrace (PT_READ_U, inferior_pid, */
/* OBSOLETE 				 (PTRACE_ARG3_TYPE) regaddr, 0); */
/* OBSOLETE       if (regno == PC_REGNUM) */
/* OBSOLETE 	*(int *) &buf[0] = GET_PC_PART (*(int *) &buf[0]); */
/* OBSOLETE       supply_register (regno, buf); */
/* OBSOLETE     } */
/* OBSOLETE   *(int *) &buf[0] = ptrace (PT_READ_U, inferior_pid, */
/* OBSOLETE 			     (PTRACE_ARG3_TYPE) (offset + PC * 4), 0); */
/* OBSOLETE   supply_register (PS_REGNUM, buf);	/* set virtual register ps same as pc *x/ */
/* OBSOLETE  */
/* OBSOLETE   /* read the floating point registers *x/ */
/* OBSOLETE   offset = (char *) &u.u_fp_regs - (char *) &u; */
/* OBSOLETE   *(int *) buf = ptrace (PT_READ_U, inferior_pid, (PTRACE_ARG3_TYPE) offset, 0); */
/* OBSOLETE   supply_register (FPS_REGNUM, buf); */
/* OBSOLETE   for (regno = 16; regno < 24; regno++) */
/* OBSOLETE     { */
/* OBSOLETE       regaddr = offset + 4 + 12 * (regno - 16); */
/* OBSOLETE       for (i = 0; i < 12; i += sizeof (int)) */
/* OBSOLETE 	 *(int *) &buf[i] = ptrace (PT_READ_U, inferior_pid, */
/* OBSOLETE 				      (PTRACE_ARG3_TYPE) (regaddr + i), 0); */
/* OBSOLETE       supply_register (regno, buf); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Store our register values back into the inferior. */
/* OBSOLETE    If REGNO is -1, do this for all registers. */
/* OBSOLETE    Otherwise, REGNO specifies which register (so we can save time).  *x/ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE store_inferior_registers (regno) */
/* OBSOLETE      int regno; */
/* OBSOLETE { */
/* OBSOLETE   register unsigned int regaddr; */
/* OBSOLETE   char buf[80]; */
/* OBSOLETE  */
/* OBSOLETE   struct user u; */
/* OBSOLETE   unsigned long value; */
/* OBSOLETE   unsigned int offset = (char *) &u.u_ar0 - (char *) &u; */
/* OBSOLETE   offset = ptrace (PT_READ_U, inferior_pid, (PTRACE_ARG3_TYPE) offset, 0) */
/* OBSOLETE     - KERNEL_U_ADDR; */
/* OBSOLETE  */
/* OBSOLETE   if (regno >= 0) */
/* OBSOLETE     { */
/* OBSOLETE       if (regno >= 16) */
/* OBSOLETE 	return; */
/* OBSOLETE       regaddr = offset + 4 * regno; */
/* OBSOLETE       errno = 0; */
/* OBSOLETE       value = read_register (regno); */
/* OBSOLETE       if (regno == PC_REGNUM) */
/* OBSOLETE 	value = SET_PC_PART (read_register (PS_REGNUM), value); */
/* OBSOLETE       ptrace (PT_WRITE_U, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, value); */
/* OBSOLETE       if (errno != 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  sprintf (buf, "writing register number %d", regno); */
/* OBSOLETE 	  perror_with_name (buf); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     for (regno = 0; regno < 15; regno++) */
/* OBSOLETE       { */
/* OBSOLETE 	regaddr = offset + regno * 4; */
/* OBSOLETE 	errno = 0; */
/* OBSOLETE 	value = read_register (regno); */
/* OBSOLETE 	if (regno == PC_REGNUM) */
/* OBSOLETE 	  value = SET_PC_PART (read_register (PS_REGNUM), value); */
/* OBSOLETE 	ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, value); */
/* OBSOLETE 	if (errno != 0) */
/* OBSOLETE 	  { */
/* OBSOLETE 	    sprintf (buf, "writing all regs, number %d", regno); */
/* OBSOLETE 	    perror_with_name (buf); */
/* OBSOLETE 	  } */
/* OBSOLETE       } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Work with core dump and executable files, for GDB.  */
/* OBSOLETE    This code would be in corefile.c if it weren't machine-dependent. *x/ */
/* OBSOLETE  */
/* OBSOLETE /* Structure to describe the chain of shared libraries used */
/* OBSOLETE    by the execfile. */
/* OBSOLETE    e.g. prog shares Xt which shares X11 which shares c. *x/ */
/* OBSOLETE  */
/* OBSOLETE struct shared_library */
/* OBSOLETE { */
/* OBSOLETE   struct exec_header header; */
/* OBSOLETE   char name[SHLIBLEN]; */
/* OBSOLETE   CORE_ADDR text_start;		/* CORE_ADDR of 1st byte of text, this file *x/ */
/* OBSOLETE   long data_offset;		/* offset of data section in file *x/ */
/* OBSOLETE   int chan;			/* file descriptor for the file *x/ */
/* OBSOLETE   struct shared_library *shares;	/* library this one shares *x/ */
/* OBSOLETE }; */
/* OBSOLETE static struct shared_library *shlib = 0; */
/* OBSOLETE  */
/* OBSOLETE /* Hook for `exec_file_command' command to call.  *x/ */
/* OBSOLETE  */
/* OBSOLETE extern void (*exec_file_display_hook) (); */
/* OBSOLETE  */
/* OBSOLETE static CORE_ADDR unshared_text_start; */
/* OBSOLETE  */
/* OBSOLETE /* extended header from exec file (for shared library info) *x/ */
/* OBSOLETE  */
/* OBSOLETE static struct exec_header exec_header; */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE core_file_command (filename, from_tty) */
/* OBSOLETE      char *filename; */
/* OBSOLETE      int from_tty; */
/* OBSOLETE { */
/* OBSOLETE   int val; */
/* OBSOLETE  */
/* OBSOLETE   /* Discard all vestiges of any previous core file */
/* OBSOLETE      and mark data and stack spaces as empty.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (corefile) */
/* OBSOLETE     xfree (corefile); */
/* OBSOLETE   corefile = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (corechan >= 0) */
/* OBSOLETE     close (corechan); */
/* OBSOLETE   corechan = -1; */
/* OBSOLETE  */
/* OBSOLETE   data_start = 0; */
/* OBSOLETE   data_end = 0; */
/* OBSOLETE   stack_start = STACK_END_ADDR; */
/* OBSOLETE   stack_end = STACK_END_ADDR; */
/* OBSOLETE  */
/* OBSOLETE   /* Now, if a new core file was specified, open it and digest it.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (filename) */
/* OBSOLETE     { */
/* OBSOLETE       filename = tilde_expand (filename); */
/* OBSOLETE       make_cleanup (xfree, filename); */
/* OBSOLETE  */
/* OBSOLETE       if (have_inferior_p ()) */
/* OBSOLETE 	error ("To look at a core file, you must kill the program with \"kill\"."); */
/* OBSOLETE       corechan = open (filename, O_RDONLY, 0); */
/* OBSOLETE       if (corechan < 0) */
/* OBSOLETE 	perror_with_name (filename); */
/* OBSOLETE       /* 4.2-style (and perhaps also sysV-style) core dump file.  *x/ */
/* OBSOLETE       { */
/* OBSOLETE 	struct user u; */
/* OBSOLETE  */
/* OBSOLETE 	unsigned int reg_offset, fp_reg_offset; */
/* OBSOLETE  */
/* OBSOLETE 	val = myread (corechan, &u, sizeof u); */
/* OBSOLETE 	if (val < 0) */
/* OBSOLETE 	  perror_with_name ("Not a core file: reading upage"); */
/* OBSOLETE 	if (val != sizeof u) */
/* OBSOLETE 	  error ("Not a core file: could only read %d bytes", val); */
/* OBSOLETE  */
/* OBSOLETE 	/* We are depending on exec_file_command having been called */
/* OBSOLETE 	   previously to set exec_data_start.  Since the executable */
/* OBSOLETE 	   and the core file share the same text segment, the address */
/* OBSOLETE 	   of the data segment will be the same in both.  *x/ */
/* OBSOLETE 	data_start = exec_data_start; */
/* OBSOLETE  */
/* OBSOLETE 	data_end = data_start + NBPG * u.u_dsize; */
/* OBSOLETE 	stack_start = stack_end - NBPG * u.u_ssize; */
/* OBSOLETE 	data_offset = NBPG * UPAGES; */
/* OBSOLETE 	stack_offset = NBPG * (UPAGES + u.u_dsize); */
/* OBSOLETE  */
/* OBSOLETE 	/* Some machines put an absolute address in here and some put */
/* OBSOLETE 	   the offset in the upage of the regs.  *x/ */
/* OBSOLETE 	reg_offset = (int) u.u_ar0; */
/* OBSOLETE 	if (reg_offset > NBPG * UPAGES) */
/* OBSOLETE 	  reg_offset -= KERNEL_U_ADDR; */
/* OBSOLETE 	fp_reg_offset = (char *) &u.u_fp_regs - (char *) &u; */
/* OBSOLETE  */
/* OBSOLETE 	/* I don't know where to find this info. */
/* OBSOLETE 	   So, for now, mark it as not available.  *x/ */
/* OBSOLETE 	N_SET_MAGIC (core_aouthdr, 0); */
/* OBSOLETE  */
/* OBSOLETE 	/* Read the register values out of the core file and store */
/* OBSOLETE 	   them where `read_register' will find them.  *x/ */
/* OBSOLETE  */
/* OBSOLETE 	{ */
/* OBSOLETE 	  register int regno; */
/* OBSOLETE  */
/* OBSOLETE 	  for (regno = 0; regno < NUM_REGS; regno++) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      char buf[MAX_REGISTER_RAW_SIZE]; */
/* OBSOLETE  */
/* OBSOLETE 	      if (regno < 16) */
/* OBSOLETE 		val = lseek (corechan, reg_offset + 4 * regno, 0); */
/* OBSOLETE 	      else if (regno < 24) */
/* OBSOLETE 		val = lseek (corechan, fp_reg_offset + 4 + 12 * (regno - 24), 0); */
/* OBSOLETE 	      else if (regno == 24) */
/* OBSOLETE 		val = lseek (corechan, fp_reg_offset, 0); */
/* OBSOLETE 	      else if (regno == 25) */
/* OBSOLETE 		val = lseek (corechan, reg_offset + 4 * PC, 0); */
/* OBSOLETE 	      if (val < 0 */
/* OBSOLETE 		  || (val = myread (corechan, buf, sizeof buf)) < 0) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  char *buffer = (char *) alloca (strlen (REGISTER_NAME (regno)) */
/* OBSOLETE 						  + 30); */
/* OBSOLETE 		  strcpy (buffer, "Reading register "); */
/* OBSOLETE 		  strcat (buffer, REGISTER_NAME (regno)); */
/* OBSOLETE  */
/* OBSOLETE 		  perror_with_name (buffer); */
/* OBSOLETE 		} */
/* OBSOLETE  */
/* OBSOLETE 	      if (regno == PC_REGNUM) */
/* OBSOLETE 		*(int *) buf = GET_PC_PART (*(int *) buf); */
/* OBSOLETE 	      supply_register (regno, buf); */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE       } */
/* OBSOLETE       if (filename[0] == '/') */
/* OBSOLETE 	corefile = savestring (filename, strlen (filename)); */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  corefile = concat (current_directory, "/", filename, NULL); */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       flush_cached_frames (); */
/* OBSOLETE       select_frame (get_current_frame (), 0); */
/* OBSOLETE       validate_files (); */
/* OBSOLETE     } */
/* OBSOLETE   else if (from_tty) */
/* OBSOLETE     printf ("No core file now.\n"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #if 0 */
/* OBSOLETE /* Work with core dump and executable files, for GDB.  */
/* OBSOLETE    This code would be in corefile.c if it weren't machine-dependent. *x/ */
/* OBSOLETE  */
/* OBSOLETE /* Structure to describe the chain of shared libraries used */
/* OBSOLETE    by the execfile. */
/* OBSOLETE    e.g. prog shares Xt which shares X11 which shares c. *x/ */
/* OBSOLETE  */
/* OBSOLETE struct shared_library */
/* OBSOLETE { */
/* OBSOLETE   struct exec_header header; */
/* OBSOLETE   char name[SHLIBLEN]; */
/* OBSOLETE   CORE_ADDR text_start;		/* CORE_ADDR of 1st byte of text, this file *x/ */
/* OBSOLETE   long data_offset;		/* offset of data section in file *x/ */
/* OBSOLETE   int chan;			/* file descriptor for the file *x/ */
/* OBSOLETE   struct shared_library *shares;	/* library this one shares *x/ */
/* OBSOLETE }; */
/* OBSOLETE static struct shared_library *shlib = 0; */
/* OBSOLETE  */
/* OBSOLETE /* Hook for `exec_file_command' command to call.  *x/ */
/* OBSOLETE  */
/* OBSOLETE extern void (*exec_file_display_hook) (); */
/* OBSOLETE  */
/* OBSOLETE static CORE_ADDR unshared_text_start; */
/* OBSOLETE  */
/* OBSOLETE /* extended header from exec file (for shared library info) *x/ */
/* OBSOLETE  */
/* OBSOLETE static struct exec_header exec_header; */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE exec_file_command (filename, from_tty) */
/* OBSOLETE      char *filename; */
/* OBSOLETE      int from_tty; */
/* OBSOLETE { */
/* OBSOLETE   int val; */
/* OBSOLETE  */
/* OBSOLETE   /* Eliminate all traces of old exec file. */
/* OBSOLETE      Mark text segment as empty.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (execfile) */
/* OBSOLETE     xfree (execfile); */
/* OBSOLETE   execfile = 0; */
/* OBSOLETE   data_start = 0; */
/* OBSOLETE   data_end -= exec_data_start; */
/* OBSOLETE   text_start = 0; */
/* OBSOLETE   unshared_text_start = 0; */
/* OBSOLETE   text_end = 0; */
/* OBSOLETE   exec_data_start = 0; */
/* OBSOLETE   exec_data_end = 0; */
/* OBSOLETE   if (execchan >= 0) */
/* OBSOLETE     close (execchan); */
/* OBSOLETE   execchan = -1; */
/* OBSOLETE   if (shlib) */
/* OBSOLETE     { */
/* OBSOLETE       close_shared_library (shlib); */
/* OBSOLETE       shlib = 0; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Now open and digest the file the user requested, if any.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (filename) */
/* OBSOLETE     { */
/* OBSOLETE       filename = tilde_expand (filename); */
/* OBSOLETE       make_cleanup (xfree, filename); */
/* OBSOLETE  */
/* OBSOLETE       execchan = openp (getenv ("PATH"), 1, filename, O_RDONLY, 0, */
/* OBSOLETE 			&execfile); */
/* OBSOLETE       if (execchan < 0) */
/* OBSOLETE 	perror_with_name (filename); */
/* OBSOLETE  */
/* OBSOLETE       { */
/* OBSOLETE 	struct stat st_exec; */
/* OBSOLETE  */
/* OBSOLETE #ifdef HEADER_SEEK_FD */
/* OBSOLETE 	HEADER_SEEK_FD (execchan); */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE 	val = myread (execchan, &exec_header, sizeof exec_header); */
/* OBSOLETE 	exec_aouthdr = exec_header.a_exec; */
/* OBSOLETE  */
/* OBSOLETE 	if (val < 0) */
/* OBSOLETE 	  perror_with_name (filename); */
/* OBSOLETE  */
/* OBSOLETE 	text_start = 0x8000; */
/* OBSOLETE  */
/* OBSOLETE 	/* Look for shared library if needed *x/ */
/* OBSOLETE 	if (exec_header.a_exec.a_magic & MF_USES_SL) */
/* OBSOLETE 	  shlib = open_shared_library (exec_header.a_shlibname, text_start); */
/* OBSOLETE  */
/* OBSOLETE 	text_offset = N_TXTOFF (exec_aouthdr); */
/* OBSOLETE 	exec_data_offset = N_TXTOFF (exec_aouthdr) + exec_aouthdr.a_text; */
/* OBSOLETE  */
/* OBSOLETE 	if (shlib) */
/* OBSOLETE 	  { */
/* OBSOLETE 	    unshared_text_start = shared_text_end (shlib) & ~0x7fff; */
/* OBSOLETE 	    stack_start = shlib->header.a_exec.a_sldatabase; */
/* OBSOLETE 	    stack_end = STACK_END_ADDR; */
/* OBSOLETE 	  } */
/* OBSOLETE 	else */
/* OBSOLETE 	  unshared_text_start = 0x8000; */
/* OBSOLETE 	text_end = unshared_text_start + exec_aouthdr.a_text; */
/* OBSOLETE  */
/* OBSOLETE 	exec_data_start = unshared_text_start + exec_aouthdr.a_text; */
/* OBSOLETE 	exec_data_end = exec_data_start + exec_aouthdr.a_data; */
/* OBSOLETE  */
/* OBSOLETE 	data_start = exec_data_start; */
/* OBSOLETE 	data_end += exec_data_start; */
/* OBSOLETE  */
/* OBSOLETE 	fstat (execchan, &st_exec); */
/* OBSOLETE 	exec_mtime = st_exec.st_mtime; */
/* OBSOLETE       } */
/* OBSOLETE  */
/* OBSOLETE       validate_files (); */
/* OBSOLETE     } */
/* OBSOLETE   else if (from_tty) */
/* OBSOLETE     printf ("No executable file now.\n"); */
/* OBSOLETE  */
/* OBSOLETE   /* Tell display code (if any) about the changed file name.  *x/ */
/* OBSOLETE   if (exec_file_display_hook) */
/* OBSOLETE     (*exec_file_display_hook) (filename); */
/* OBSOLETE } */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE #if 0 */
/* OBSOLETE /* Read from the program's memory (except for inferior processes). */
/* OBSOLETE    This function is misnamed, since it only reads, never writes; and */
/* OBSOLETE    since it will use the core file and/or executable file as necessary. */
/* OBSOLETE  */
/* OBSOLETE    It should be extended to write as well as read, FIXME, for patching files. */
/* OBSOLETE  */
/* OBSOLETE    Return 0 if address could be read, EIO if addresss out of bounds.  *x/ */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE xfer_core_file (memaddr, myaddr, len) */
/* OBSOLETE      CORE_ADDR memaddr; */
/* OBSOLETE      char *myaddr; */
/* OBSOLETE      int len; */
/* OBSOLETE { */
/* OBSOLETE   register int i; */
/* OBSOLETE   register int val; */
/* OBSOLETE   int xferchan; */
/* OBSOLETE   char **xferfile; */
/* OBSOLETE   int fileptr; */
/* OBSOLETE   int returnval = 0; */
/* OBSOLETE  */
/* OBSOLETE   while (len > 0) */
/* OBSOLETE     { */
/* OBSOLETE       xferfile = 0; */
/* OBSOLETE       xferchan = 0; */
/* OBSOLETE  */
/* OBSOLETE       /* Determine which file the next bunch of addresses reside in, */
/* OBSOLETE          and where in the file.  Set the file's read/write pointer */
/* OBSOLETE          to point at the proper place for the desired address */
/* OBSOLETE          and set xferfile and xferchan for the correct file. */
/* OBSOLETE  */
/* OBSOLETE          If desired address is nonexistent, leave them zero. */
/* OBSOLETE  */
/* OBSOLETE          i is set to the number of bytes that can be handled */
/* OBSOLETE          along with the next address. */
/* OBSOLETE  */
/* OBSOLETE          We put the most likely tests first for efficiency.  *x/ */
/* OBSOLETE  */
/* OBSOLETE       /* Note that if there is no core file */
/* OBSOLETE          data_start and data_end are equal.  *x/ */
/* OBSOLETE       if (memaddr >= data_start && memaddr < data_end) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  i = min (len, data_end - memaddr); */
/* OBSOLETE 	  fileptr = memaddr - data_start + data_offset; */
/* OBSOLETE 	  xferfile = &corefile; */
/* OBSOLETE 	  xferchan = corechan; */
/* OBSOLETE 	} */
/* OBSOLETE       /* Note that if there is no core file */
/* OBSOLETE          stack_start and stack_end define the shared library data.  *x/ */
/* OBSOLETE       else if (memaddr >= stack_start && memaddr < stack_end) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  if (corechan < 0) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      struct shared_library *lib; */
/* OBSOLETE 	      for (lib = shlib; lib; lib = lib->shares) */
/* OBSOLETE 		if (memaddr >= lib->header.a_exec.a_sldatabase && */
/* OBSOLETE 		    memaddr < lib->header.a_exec.a_sldatabase + */
/* OBSOLETE 		    lib->header.a_exec.a_data) */
/* OBSOLETE 		  break; */
/* OBSOLETE 	      if (lib) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  i = min (len, lib->header.a_exec.a_sldatabase + */
/* OBSOLETE 			   lib->header.a_exec.a_data - memaddr); */
/* OBSOLETE 		  fileptr = lib->data_offset + memaddr - */
/* OBSOLETE 		    lib->header.a_exec.a_sldatabase; */
/* OBSOLETE 		  xferfile = execfile; */
/* OBSOLETE 		  xferchan = lib->chan; */
/* OBSOLETE 		} */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    { */
/* OBSOLETE 	      i = min (len, stack_end - memaddr); */
/* OBSOLETE 	      fileptr = memaddr - stack_start + stack_offset; */
/* OBSOLETE 	      xferfile = &corefile; */
/* OBSOLETE 	      xferchan = corechan; */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE       else if (corechan < 0 */
/* OBSOLETE 	       && memaddr >= exec_data_start && memaddr < exec_data_end) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  i = min (len, exec_data_end - memaddr); */
/* OBSOLETE 	  fileptr = memaddr - exec_data_start + exec_data_offset; */
/* OBSOLETE 	  xferfile = &execfile; */
/* OBSOLETE 	  xferchan = execchan; */
/* OBSOLETE 	} */
/* OBSOLETE       else if (memaddr >= text_start && memaddr < text_end) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  struct shared_library *lib; */
/* OBSOLETE 	  for (lib = shlib; lib; lib = lib->shares) */
/* OBSOLETE 	    if (memaddr >= lib->text_start && */
/* OBSOLETE 		memaddr < lib->text_start + lib->header.a_exec.a_text) */
/* OBSOLETE 	      break; */
/* OBSOLETE 	  if (lib) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      i = min (len, lib->header.a_exec.a_text + */
/* OBSOLETE 		       lib->text_start - memaddr); */
/* OBSOLETE 	      fileptr = memaddr - lib->text_start + text_offset; */
/* OBSOLETE 	      xferfile = &execfile; */
/* OBSOLETE 	      xferchan = lib->chan; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    { */
/* OBSOLETE 	      i = min (len, text_end - memaddr); */
/* OBSOLETE 	      fileptr = memaddr - unshared_text_start + text_offset; */
/* OBSOLETE 	      xferfile = &execfile; */
/* OBSOLETE 	      xferchan = execchan; */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE       else if (memaddr < text_start) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  i = min (len, text_start - memaddr); */
/* OBSOLETE 	} */
/* OBSOLETE       else if (memaddr >= text_end */
/* OBSOLETE 	       && memaddr < (corechan >= 0 ? data_start : exec_data_start)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  i = min (len, data_start - memaddr); */
/* OBSOLETE 	} */
/* OBSOLETE       else if (corechan >= 0 */
/* OBSOLETE 	       && memaddr >= data_end && memaddr < stack_start) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  i = min (len, stack_start - memaddr); */
/* OBSOLETE 	} */
/* OBSOLETE       else if (corechan < 0 && memaddr >= exec_data_end) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  i = min (len, -memaddr); */
/* OBSOLETE 	} */
/* OBSOLETE       else if (memaddr >= stack_end && stack_end != 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  i = min (len, -memaddr); */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* Address did not classify into one of the known ranges. */
/* OBSOLETE 	     This shouldn't happen; we catch the endpoints.  *x/ */
/* OBSOLETE 	  internal_error ("Bad case logic in xfer_core_file."); */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       /* Now we know which file to use. */
/* OBSOLETE          Set up its pointer and transfer the data.  *x/ */
/* OBSOLETE       if (xferfile) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  if (*xferfile == 0) */
/* OBSOLETE 	    if (xferfile == &execfile) */
/* OBSOLETE 	      error ("No program file to examine."); */
/* OBSOLETE 	    else */
/* OBSOLETE 	      error ("No core dump file or running program to examine."); */
/* OBSOLETE 	  val = lseek (xferchan, fileptr, 0); */
/* OBSOLETE 	  if (val < 0) */
/* OBSOLETE 	    perror_with_name (*xferfile); */
/* OBSOLETE 	  val = myread (xferchan, myaddr, i); */
/* OBSOLETE 	  if (val < 0) */
/* OBSOLETE 	    perror_with_name (*xferfile); */
/* OBSOLETE 	} */
/* OBSOLETE       /* If this address is for nonexistent memory, */
/* OBSOLETE          read zeros if reading, or do nothing if writing. */
/* OBSOLETE          Actually, we never right.  *x/ */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  memset (myaddr, '\0', i); */
/* OBSOLETE 	  returnval = EIO; */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       memaddr += i; */
/* OBSOLETE       myaddr += i; */
/* OBSOLETE       len -= i; */
/* OBSOLETE     } */
/* OBSOLETE   return returnval; */
/* OBSOLETE } */
/* OBSOLETE #endif */
@


1.2
log
@Replace free() with xfree().
@
text
@@


1.1
log
@Initial revision
@
text
@d1 575
a575 559
/* Acorn Risc Machine host machine support.
   Copyright (C) 1988, 1989, 1991 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "arm-opcode.h"

#include <sys/param.h>
#include <sys/dir.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/ptrace.h>
#include <machine/reg.h>

#define N_TXTADDR(hdr) 0x8000
#define N_DATADDR(hdr) (hdr.a_text + 0x8000)

#include "gdbcore.h"

#include <sys/user.h>		/* After a.out.h  */
#include <sys/file.h>
#include "gdb_stat.h"

#include <errno.h>

void
fetch_inferior_registers (regno)
     int regno;		/* Original value discarded */
{
  register unsigned int regaddr;
  char buf[MAX_REGISTER_RAW_SIZE];
  register int i;

  struct user u;
  unsigned int offset = (char *) &u.u_ar0 - (char *) &u;
  offset = ptrace (PT_READ_U, inferior_pid, (PTRACE_ARG3_TYPE) offset, 0)
      - KERNEL_U_ADDR;

  registers_fetched ();
  
  for (regno = 0; regno < 16; regno++)
    {
      regaddr = offset + regno * 4;
      *(int *)&buf[0] = ptrace (PT_READ_U, inferior_pid,
				(PTRACE_ARG3_TYPE) regaddr, 0);
      if (regno == PC_REGNUM)
	  *(int *)&buf[0] = GET_PC_PART(*(int *)&buf[0]);
      supply_register (regno, buf);
    }
  *(int *)&buf[0] = ptrace (PT_READ_U, inferior_pid,
			    (PTRACE_ARG3_TYPE) (offset + PC*4), 0);
  supply_register (PS_REGNUM, buf); /* set virtual register ps same as pc */

  /* read the floating point registers */
  offset = (char *) &u.u_fp_regs - (char *)&u;
  *(int *)buf = ptrace (PT_READ_U, inferior_pid, (PTRACE_ARG3_TYPE) offset, 0);
  supply_register (FPS_REGNUM, buf);
  for (regno = 16; regno < 24; regno++) {
      regaddr = offset + 4 + 12 * (regno - 16);
      for (i = 0; i < 12; i += sizeof(int))
	  *(int *) &buf[i] = ptrace (PT_READ_U, inferior_pid,
				     (PTRACE_ARG3_TYPE) (regaddr + i), 0);
      supply_register (regno, buf);
  }
}

/* Store our register values back into the inferior.
   If REGNO is -1, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time).  */

void
store_inferior_registers (regno)
     int regno;
{
  register unsigned int regaddr;
  char buf[80];

  struct user u;
  unsigned long value;
  unsigned int offset = (char *) &u.u_ar0 - (char *) &u;
  offset = ptrace (PT_READ_U, inferior_pid, (PTRACE_ARG3_TYPE) offset, 0)
      - KERNEL_U_ADDR;

  if (regno >= 0) {
      if (regno >= 16) return;
      regaddr = offset + 4 * regno;
      errno = 0;
      value = read_register(regno);
      if (regno == PC_REGNUM)
	  value = SET_PC_PART(read_register (PS_REGNUM), value);
      ptrace (PT_WRITE_U, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, value);
      if (errno != 0)
	{
	  sprintf (buf, "writing register number %d", regno);
	  perror_with_name (buf);
	}
    }
  else for (regno = 0; regno < 15; regno++)
    {
      regaddr = offset + regno * 4;
      errno = 0;
      value = read_register(regno);
      if (regno == PC_REGNUM)
	  value = SET_PC_PART(read_register (PS_REGNUM), value);
      ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, value);
      if (errno != 0)
	{
	  sprintf (buf, "writing all regs, number %d", regno);
	  perror_with_name (buf);
	}
    }
}

/* Work with core dump and executable files, for GDB. 
   This code would be in corefile.c if it weren't machine-dependent. */

/* Structure to describe the chain of shared libraries used
   by the execfile.
   e.g. prog shares Xt which shares X11 which shares c. */

struct shared_library {
    struct exec_header header;
    char name[SHLIBLEN];
    CORE_ADDR text_start;	/* CORE_ADDR of 1st byte of text, this file */
    long data_offset;		/* offset of data section in file */
    int chan;			/* file descriptor for the file */
    struct shared_library *shares; /* library this one shares */
};
static struct shared_library *shlib = 0;

/* Hook for `exec_file_command' command to call.  */

extern void (*exec_file_display_hook) ();
   
static CORE_ADDR unshared_text_start;

/* extended header from exec file (for shared library info) */

static struct exec_header exec_header;

void
core_file_command (filename, from_tty)
     char *filename;
     int from_tty;
{
  int val;
  extern char registers[];

  /* Discard all vestiges of any previous core file
     and mark data and stack spaces as empty.  */

  if (corefile)
    free (corefile);
  corefile = 0;

  if (corechan >= 0)
    close (corechan);
  corechan = -1;

  data_start = 0;
  data_end = 0;
  stack_start = STACK_END_ADDR;
  stack_end = STACK_END_ADDR;

  /* Now, if a new core file was specified, open it and digest it.  */

  if (filename)
    {
      filename = tilde_expand (filename);
      make_cleanup (free, filename);
      
      if (have_inferior_p ())
	error ("To look at a core file, you must kill the program with \"kill\".");
      corechan = open (filename, O_RDONLY, 0);
      if (corechan < 0)
	perror_with_name (filename);
      /* 4.2-style (and perhaps also sysV-style) core dump file.  */
      {
	struct user u;

	unsigned int reg_offset, fp_reg_offset;

	val = myread (corechan, &u, sizeof u);
	if (val < 0)
	  perror_with_name ("Not a core file: reading upage");
	if (val != sizeof u)
	  error ("Not a core file: could only read %d bytes", val);

	/* We are depending on exec_file_command having been called
	   previously to set exec_data_start.  Since the executable
	   and the core file share the same text segment, the address
	   of the data segment will be the same in both.  */
	data_start = exec_data_start;

	data_end = data_start + NBPG * u.u_dsize;
	stack_start = stack_end - NBPG * u.u_ssize;
	data_offset = NBPG * UPAGES;
	stack_offset = NBPG * (UPAGES + u.u_dsize);

	/* Some machines put an absolute address in here and some put
	   the offset in the upage of the regs.  */
	reg_offset = (int) u.u_ar0;
	if (reg_offset > NBPG * UPAGES)
	  reg_offset -= KERNEL_U_ADDR;
	fp_reg_offset = (char *) &u.u_fp_regs - (char *)&u;

	/* I don't know where to find this info.
	   So, for now, mark it as not available.  */
	N_SET_MAGIC (core_aouthdr, 0);

	/* Read the register values out of the core file and store
	   them where `read_register' will find them.  */

	{
	  register int regno;

	  for (regno = 0; regno < NUM_REGS; regno++)
	    {
	      char buf[MAX_REGISTER_RAW_SIZE];

	      if (regno < 16)
		  val = lseek (corechan, reg_offset + 4 * regno, 0);
	      else if (regno < 24)
		  val = lseek (corechan, fp_reg_offset + 4 + 12*(regno - 24), 0);
	      else if (regno == 24)
		  val = lseek (corechan, fp_reg_offset, 0);
	      else if (regno == 25)
		  val = lseek (corechan, reg_offset + 4 * PC, 0);
	      if (val < 0
		  || (val = myread (corechan, buf, sizeof buf)) < 0)
		{
		  char * buffer = (char *) alloca (strlen (REGISTER_NAME (regno))
						   + 30);
		  strcpy (buffer, "Reading register ");
		  strcat (buffer, REGISTER_NAME (regno));
						   
		  perror_with_name (buffer);
		}

	      if (regno == PC_REGNUM)
		  *(int *)buf = GET_PC_PART(*(int *)buf);
	      supply_register (regno, buf);
	    }
	}
      }
      if (filename[0] == '/')
	corefile = savestring (filename, strlen (filename));
      else
	{
	  corefile = concat (current_directory, "/", filename, NULL);
	}

      flush_cached_frames ();
      select_frame (get_current_frame (), 0);
      validate_files ();
    }
  else if (from_tty)
    printf ("No core file now.\n");
}

#if 0
/* Work with core dump and executable files, for GDB. 
   This code would be in corefile.c if it weren't machine-dependent. */

/* Structure to describe the chain of shared libraries used
   by the execfile.
   e.g. prog shares Xt which shares X11 which shares c. */

struct shared_library {
    struct exec_header header;
    char name[SHLIBLEN];
    CORE_ADDR text_start;	/* CORE_ADDR of 1st byte of text, this file */
    long data_offset;		/* offset of data section in file */
    int chan;			/* file descriptor for the file */
    struct shared_library *shares; /* library this one shares */
};
static struct shared_library *shlib = 0;

/* Hook for `exec_file_command' command to call.  */

extern void (*exec_file_display_hook) ();
   
static CORE_ADDR unshared_text_start;

/* extended header from exec file (for shared library info) */

static struct exec_header exec_header;

void
exec_file_command (filename, from_tty)
     char *filename;
     int from_tty;
{
  int val;

  /* Eliminate all traces of old exec file.
     Mark text segment as empty.  */

  if (execfile)
    free (execfile);
  execfile = 0;
  data_start = 0;
  data_end -= exec_data_start;
  text_start = 0;
  unshared_text_start = 0;
  text_end = 0;
  exec_data_start = 0;
  exec_data_end = 0;
  if (execchan >= 0)
    close (execchan);
  execchan = -1;
  if (shlib) {
      close_shared_library(shlib);
      shlib = 0;
  }

  /* Now open and digest the file the user requested, if any.  */

  if (filename)
    {
      filename = tilde_expand (filename);
      make_cleanup (free, filename);

      execchan = openp (getenv ("PATH"), 1, filename, O_RDONLY, 0,
			&execfile);
      if (execchan < 0)
	perror_with_name (filename);

      {
	struct stat st_exec;

#ifdef HEADER_SEEK_FD
	HEADER_SEEK_FD (execchan);
#endif
	
	val = myread (execchan, &exec_header, sizeof exec_header);
	exec_aouthdr = exec_header.a_exec;

	if (val < 0)
	  perror_with_name (filename);

	text_start = 0x8000;

	/* Look for shared library if needed */
	if (exec_header.a_exec.a_magic & MF_USES_SL)
	    shlib = open_shared_library(exec_header.a_shlibname, text_start);

	text_offset = N_TXTOFF (exec_aouthdr);
	exec_data_offset = N_TXTOFF (exec_aouthdr) + exec_aouthdr.a_text;

	if (shlib) {
	    unshared_text_start = shared_text_end(shlib) & ~0x7fff;
	    stack_start = shlib->header.a_exec.a_sldatabase;
	    stack_end = STACK_END_ADDR;
	} else
	    unshared_text_start = 0x8000;
	text_end = unshared_text_start + exec_aouthdr.a_text;

	exec_data_start = unshared_text_start + exec_aouthdr.a_text;
        exec_data_end = exec_data_start + exec_aouthdr.a_data;

	data_start = exec_data_start;
	data_end += exec_data_start;

	fstat (execchan, &st_exec);
	exec_mtime = st_exec.st_mtime;
      }

      validate_files ();
    }
  else if (from_tty)
    printf ("No executable file now.\n");

  /* Tell display code (if any) about the changed file name.  */
  if (exec_file_display_hook)
    (*exec_file_display_hook) (filename);
}
#endif

#if 0
/* Read from the program's memory (except for inferior processes).
   This function is misnamed, since it only reads, never writes; and
   since it will use the core file and/or executable file as necessary.

   It should be extended to write as well as read, FIXME, for patching files.

   Return 0 if address could be read, EIO if addresss out of bounds.  */

int
xfer_core_file (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
{
  register int i;
  register int val;
  int xferchan;
  char **xferfile;
  int fileptr;
  int returnval = 0;

  while (len > 0)
    {
      xferfile = 0;
      xferchan = 0;

      /* Determine which file the next bunch of addresses reside in,
	 and where in the file.  Set the file's read/write pointer
	 to point at the proper place for the desired address
	 and set xferfile and xferchan for the correct file.

	 If desired address is nonexistent, leave them zero.

	 i is set to the number of bytes that can be handled
	 along with the next address.

	 We put the most likely tests first for efficiency.  */

      /* Note that if there is no core file
	 data_start and data_end are equal.  */
      if (memaddr >= data_start && memaddr < data_end)
	{
	  i = min (len, data_end - memaddr);
	  fileptr = memaddr - data_start + data_offset;
	  xferfile = &corefile;
	  xferchan = corechan;
	}
      /* Note that if there is no core file
	 stack_start and stack_end define the shared library data.  */
      else if (memaddr >= stack_start && memaddr < stack_end)
	{
	    if (corechan < 0) {
		struct shared_library *lib;
		for (lib = shlib; lib; lib = lib->shares)
		    if (memaddr >= lib->header.a_exec.a_sldatabase &&
			memaddr < lib->header.a_exec.a_sldatabase +
			  lib->header.a_exec.a_data)
			break;
		if (lib) {
		    i = min (len, lib->header.a_exec.a_sldatabase +
			     lib->header.a_exec.a_data - memaddr);
		    fileptr = lib->data_offset + memaddr -
			lib->header.a_exec.a_sldatabase;
		    xferfile = execfile;
		    xferchan = lib->chan;
		}
	    } else {
		i = min (len, stack_end - memaddr);
		fileptr = memaddr - stack_start + stack_offset;
		xferfile = &corefile;
		xferchan = corechan;
	    }
	}
      else if (corechan < 0
	       && memaddr >= exec_data_start && memaddr < exec_data_end)
	{
	  i = min (len, exec_data_end - memaddr);
	  fileptr = memaddr - exec_data_start + exec_data_offset;
	  xferfile = &execfile;
	  xferchan = execchan;
	}
      else if (memaddr >= text_start && memaddr < text_end)
	{
	    struct shared_library *lib;
	    for (lib = shlib; lib; lib = lib->shares)
		if (memaddr >= lib->text_start &&
		    memaddr < lib->text_start + lib->header.a_exec.a_text)
		    break;
	    if (lib) {
		i = min (len, lib->header.a_exec.a_text +
			 lib->text_start - memaddr);
		fileptr = memaddr - lib->text_start + text_offset;
		xferfile = &execfile;
		xferchan = lib->chan;
	    } else {
		i = min (len, text_end - memaddr);
		fileptr = memaddr - unshared_text_start + text_offset;
		xferfile = &execfile;
		xferchan = execchan;
	    }
	}
      else if (memaddr < text_start)
	{
	  i = min (len, text_start - memaddr);
	}
      else if (memaddr >= text_end
	       && memaddr < (corechan >= 0? data_start : exec_data_start))
	{
	  i = min (len, data_start - memaddr);
	}
      else if (corechan >= 0
	       && memaddr >= data_end && memaddr < stack_start)
	{
	  i = min (len, stack_start - memaddr);
	}
      else if (corechan < 0 && memaddr >= exec_data_end)
	{
	  i = min (len, - memaddr);
	}
      else if (memaddr >= stack_end && stack_end != 0)
	{
	  i = min (len, - memaddr);
	}
      else
	{
	  /* Address did not classify into one of the known ranges.
	     This shouldn't happen; we catch the endpoints.  */
	  fatal ("Internal: Bad case logic in xfer_core_file.");
	}

      /* Now we know which file to use.
	 Set up its pointer and transfer the data.  */
      if (xferfile)
	{
	  if (*xferfile == 0)
	    if (xferfile == &execfile)
	      error ("No program file to examine.");
	    else
	      error ("No core dump file or running program to examine.");
	  val = lseek (xferchan, fileptr, 0);
	  if (val < 0)
	    perror_with_name (*xferfile);
	  val = myread (xferchan, myaddr, i);
	  if (val < 0)
	    perror_with_name (*xferfile);
	}
      /* If this address is for nonexistent memory,
	 read zeros if reading, or do nothing if writing.
	 Actually, we never right.  */
      else
	{
	  memset (myaddr, '\0', i);
	  returnval = EIO;
	}

      memaddr += i;
      myaddr += i;
      len -= i;
    }
  return returnval;
}
#endif
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d164 1
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d45 1
a45 1
     int regno;			/* Original value discarded */
d54 1
a54 1
    - KERNEL_U_ADDR;
d57 1
a57 1

d61 2
a62 2
      *(int *) &buf[0] = ptrace (PT_READ_U, inferior_pid,
				 (PTRACE_ARG3_TYPE) regaddr, 0);
d64 1
a64 1
	*(int *) &buf[0] = GET_PC_PART (*(int *) &buf[0]);
d67 3
a69 3
  *(int *) &buf[0] = ptrace (PT_READ_U, inferior_pid,
			     (PTRACE_ARG3_TYPE) (offset + PC * 4), 0);
  supply_register (PS_REGNUM, buf);	/* set virtual register ps same as pc */
d72 2
a73 2
  offset = (char *) &u.u_fp_regs - (char *) &u;
  *(int *) buf = ptrace (PT_READ_U, inferior_pid, (PTRACE_ARG3_TYPE) offset, 0);
d75 1
a75 2
  for (regno = 16; regno < 24; regno++)
    {
d77 3
a79 3
      for (i = 0; i < 12; i += sizeof (int))
	 *(int *) &buf[i] = ptrace (PT_READ_U, inferior_pid,
				      (PTRACE_ARG3_TYPE) (regaddr + i), 0);
d81 1
a81 1
    }
d99 1
a99 1
    - KERNEL_U_ADDR;
d101 2
a102 4
  if (regno >= 0)
    {
      if (regno >= 16)
	return;
d105 1
a105 1
      value = read_register (regno);
d107 1
a107 1
	value = SET_PC_PART (read_register (PS_REGNUM), value);
d115 14
a128 15
  else
    for (regno = 0; regno < 15; regno++)
      {
	regaddr = offset + regno * 4;
	errno = 0;
	value = read_register (regno);
	if (regno == PC_REGNUM)
	  value = SET_PC_PART (read_register (PS_REGNUM), value);
	ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, value);
	if (errno != 0)
	  {
	    sprintf (buf, "writing all regs, number %d", regno);
	    perror_with_name (buf);
	  }
      }
d138 7
a144 8
struct shared_library
{
  struct exec_header header;
  char name[SHLIBLEN];
  CORE_ADDR text_start;		/* CORE_ADDR of 1st byte of text, this file */
  long data_offset;		/* offset of data section in file */
  int chan;			/* file descriptor for the file */
  struct shared_library *shares;	/* library this one shares */
d151 1
a151 1

d187 1
a187 1

d221 1
a221 1
	fp_reg_offset = (char *) &u.u_fp_regs - (char *) &u;
d238 1
a238 1
		val = lseek (corechan, reg_offset + 4 * regno, 0);
d240 1
a240 1
		val = lseek (corechan, fp_reg_offset + 4 + 12 * (regno - 24), 0);
d242 1
a242 1
		val = lseek (corechan, fp_reg_offset, 0);
d244 1
a244 1
		val = lseek (corechan, reg_offset + 4 * PC, 0);
d248 2
a249 2
		  char *buffer = (char *) alloca (strlen (REGISTER_NAME (regno))
						  + 30);
d252 1
a252 1

d257 1
a257 1
		*(int *) buf = GET_PC_PART (*(int *) buf);
d285 7
a291 8
struct shared_library
{
  struct exec_header header;
  char name[SHLIBLEN];
  CORE_ADDR text_start;		/* CORE_ADDR of 1st byte of text, this file */
  long data_offset;		/* offset of data section in file */
  int chan;			/* file descriptor for the file */
  struct shared_library *shares;	/* library this one shares */
d298 1
a298 1

d328 2
a329 3
  if (shlib)
    {
      close_shared_library (shlib);
d331 1
a331 1
    }
d351 1
a351 1

d362 1
a362 1
	  shlib = open_shared_library (exec_header.a_shlibname, text_start);
d367 2
a368 3
	if (shlib)
	  {
	    unshared_text_start = shared_text_end (shlib) & ~0x7fff;
d371 2
a372 3
	  }
	else
	  unshared_text_start = 0x8000;
d376 1
a376 1
	exec_data_end = exec_data_start + exec_aouthdr.a_data;
d424 3
a426 3
         and where in the file.  Set the file's read/write pointer
         to point at the proper place for the desired address
         and set xferfile and xferchan for the correct file.
d428 1
a428 1
         If desired address is nonexistent, leave them zero.
d430 2
a431 2
         i is set to the number of bytes that can be handled
         along with the next address.
d433 1
a433 1
         We put the most likely tests first for efficiency.  */
d436 1
a436 1
         data_start and data_end are equal.  */
d445 1
a445 1
         stack_start and stack_end define the shared library data.  */
d448 14
a461 16
	  if (corechan < 0)
	    {
	      struct shared_library *lib;
	      for (lib = shlib; lib; lib = lib->shares)
		if (memaddr >= lib->header.a_exec.a_sldatabase &&
		    memaddr < lib->header.a_exec.a_sldatabase +
		    lib->header.a_exec.a_data)
		  break;
	      if (lib)
		{
		  i = min (len, lib->header.a_exec.a_sldatabase +
			   lib->header.a_exec.a_data - memaddr);
		  fileptr = lib->data_offset + memaddr -
		    lib->header.a_exec.a_sldatabase;
		  xferfile = execfile;
		  xferchan = lib->chan;
d463 5
a467 7
	    }
	  else
	    {
	      i = min (len, stack_end - memaddr);
	      fileptr = memaddr - stack_start + stack_offset;
	      xferfile = &corefile;
	      xferchan = corechan;
d480 16
a495 19
	  struct shared_library *lib;
	  for (lib = shlib; lib; lib = lib->shares)
	    if (memaddr >= lib->text_start &&
		memaddr < lib->text_start + lib->header.a_exec.a_text)
	      break;
	  if (lib)
	    {
	      i = min (len, lib->header.a_exec.a_text +
		       lib->text_start - memaddr);
	      fileptr = memaddr - lib->text_start + text_offset;
	      xferfile = &execfile;
	      xferchan = lib->chan;
	    }
	  else
	    {
	      i = min (len, text_end - memaddr);
	      fileptr = memaddr - unshared_text_start + text_offset;
	      xferfile = &execfile;
	      xferchan = execchan;
d503 1
a503 1
	       && memaddr < (corechan >= 0 ? data_start : exec_data_start))
d514 1
a514 1
	  i = min (len, -memaddr);
d518 1
a518 1
	  i = min (len, -memaddr);
d528 1
a528 1
         Set up its pointer and transfer the data.  */
d544 2
a545 2
         read zeros if reading, or do nothing if writing.
         Actually, we never right.  */
@


1.1.1.4
log
@import gdb-1999-08-09 snapshot
@
text
@d541 1
a541 1
	  internal_error ("Bad case logic in xfer_core_file.");
@


1.1.1.5
log
@import gdb-1999-12-06 snapshot
@
text
@d24 1
a24 1
#include "opcode/arm.h"
@


1.1.1.6
log
@import gdb-1999-12-21 snapshot
@
text
@d1 575
a575 575
/* OBSOLETE /* Acorn Risc Machine host machine support. */
/* OBSOLETE    Copyright (C) 1988, 1989, 1991 Free Software Foundation, Inc. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "frame.h" */
/* OBSOLETE #include "inferior.h" */
/* OBSOLETE #include "opcode/arm.h" */
/* OBSOLETE  */
/* OBSOLETE #include <sys/param.h> */
/* OBSOLETE #include <sys/dir.h> */
/* OBSOLETE #include <signal.h> */
/* OBSOLETE #include <sys/ioctl.h> */
/* OBSOLETE #include <sys/ptrace.h> */
/* OBSOLETE #include <machine/reg.h> */
/* OBSOLETE  */
/* OBSOLETE #define N_TXTADDR(hdr) 0x8000 */
/* OBSOLETE #define N_DATADDR(hdr) (hdr.a_text + 0x8000) */
/* OBSOLETE  */
/* OBSOLETE #include "gdbcore.h" */
/* OBSOLETE  */
/* OBSOLETE #include <sys/user.h>		/* After a.out.h  *x/ */
/* OBSOLETE #include <sys/file.h> */
/* OBSOLETE #include "gdb_stat.h" */
/* OBSOLETE  */
/* OBSOLETE #include <errno.h> */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE fetch_inferior_registers (regno) */
/* OBSOLETE      int regno;			/* Original value discarded *x/ */
/* OBSOLETE { */
/* OBSOLETE   register unsigned int regaddr; */
/* OBSOLETE   char buf[MAX_REGISTER_RAW_SIZE]; */
/* OBSOLETE   register int i; */
/* OBSOLETE  */
/* OBSOLETE   struct user u; */
/* OBSOLETE   unsigned int offset = (char *) &u.u_ar0 - (char *) &u; */
/* OBSOLETE   offset = ptrace (PT_READ_U, inferior_pid, (PTRACE_ARG3_TYPE) offset, 0) */
/* OBSOLETE     - KERNEL_U_ADDR; */
/* OBSOLETE  */
/* OBSOLETE   registers_fetched (); */
/* OBSOLETE  */
/* OBSOLETE   for (regno = 0; regno < 16; regno++) */
/* OBSOLETE     { */
/* OBSOLETE       regaddr = offset + regno * 4; */
/* OBSOLETE       *(int *) &buf[0] = ptrace (PT_READ_U, inferior_pid, */
/* OBSOLETE 				 (PTRACE_ARG3_TYPE) regaddr, 0); */
/* OBSOLETE       if (regno == PC_REGNUM) */
/* OBSOLETE 	*(int *) &buf[0] = GET_PC_PART (*(int *) &buf[0]); */
/* OBSOLETE       supply_register (regno, buf); */
/* OBSOLETE     } */
/* OBSOLETE   *(int *) &buf[0] = ptrace (PT_READ_U, inferior_pid, */
/* OBSOLETE 			     (PTRACE_ARG3_TYPE) (offset + PC * 4), 0); */
/* OBSOLETE   supply_register (PS_REGNUM, buf);	/* set virtual register ps same as pc *x/ */
/* OBSOLETE  */
/* OBSOLETE   /* read the floating point registers *x/ */
/* OBSOLETE   offset = (char *) &u.u_fp_regs - (char *) &u; */
/* OBSOLETE   *(int *) buf = ptrace (PT_READ_U, inferior_pid, (PTRACE_ARG3_TYPE) offset, 0); */
/* OBSOLETE   supply_register (FPS_REGNUM, buf); */
/* OBSOLETE   for (regno = 16; regno < 24; regno++) */
/* OBSOLETE     { */
/* OBSOLETE       regaddr = offset + 4 + 12 * (regno - 16); */
/* OBSOLETE       for (i = 0; i < 12; i += sizeof (int)) */
/* OBSOLETE 	 *(int *) &buf[i] = ptrace (PT_READ_U, inferior_pid, */
/* OBSOLETE 				      (PTRACE_ARG3_TYPE) (regaddr + i), 0); */
/* OBSOLETE       supply_register (regno, buf); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Store our register values back into the inferior. */
/* OBSOLETE    If REGNO is -1, do this for all registers. */
/* OBSOLETE    Otherwise, REGNO specifies which register (so we can save time).  *x/ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE store_inferior_registers (regno) */
/* OBSOLETE      int regno; */
/* OBSOLETE { */
/* OBSOLETE   register unsigned int regaddr; */
/* OBSOLETE   char buf[80]; */
/* OBSOLETE  */
/* OBSOLETE   struct user u; */
/* OBSOLETE   unsigned long value; */
/* OBSOLETE   unsigned int offset = (char *) &u.u_ar0 - (char *) &u; */
/* OBSOLETE   offset = ptrace (PT_READ_U, inferior_pid, (PTRACE_ARG3_TYPE) offset, 0) */
/* OBSOLETE     - KERNEL_U_ADDR; */
/* OBSOLETE  */
/* OBSOLETE   if (regno >= 0) */
/* OBSOLETE     { */
/* OBSOLETE       if (regno >= 16) */
/* OBSOLETE 	return; */
/* OBSOLETE       regaddr = offset + 4 * regno; */
/* OBSOLETE       errno = 0; */
/* OBSOLETE       value = read_register (regno); */
/* OBSOLETE       if (regno == PC_REGNUM) */
/* OBSOLETE 	value = SET_PC_PART (read_register (PS_REGNUM), value); */
/* OBSOLETE       ptrace (PT_WRITE_U, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, value); */
/* OBSOLETE       if (errno != 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  sprintf (buf, "writing register number %d", regno); */
/* OBSOLETE 	  perror_with_name (buf); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     for (regno = 0; regno < 15; regno++) */
/* OBSOLETE       { */
/* OBSOLETE 	regaddr = offset + regno * 4; */
/* OBSOLETE 	errno = 0; */
/* OBSOLETE 	value = read_register (regno); */
/* OBSOLETE 	if (regno == PC_REGNUM) */
/* OBSOLETE 	  value = SET_PC_PART (read_register (PS_REGNUM), value); */
/* OBSOLETE 	ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, value); */
/* OBSOLETE 	if (errno != 0) */
/* OBSOLETE 	  { */
/* OBSOLETE 	    sprintf (buf, "writing all regs, number %d", regno); */
/* OBSOLETE 	    perror_with_name (buf); */
/* OBSOLETE 	  } */
/* OBSOLETE       } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Work with core dump and executable files, for GDB.  */
/* OBSOLETE    This code would be in corefile.c if it weren't machine-dependent. *x/ */
/* OBSOLETE  */
/* OBSOLETE /* Structure to describe the chain of shared libraries used */
/* OBSOLETE    by the execfile. */
/* OBSOLETE    e.g. prog shares Xt which shares X11 which shares c. *x/ */
/* OBSOLETE  */
/* OBSOLETE struct shared_library */
/* OBSOLETE { */
/* OBSOLETE   struct exec_header header; */
/* OBSOLETE   char name[SHLIBLEN]; */
/* OBSOLETE   CORE_ADDR text_start;		/* CORE_ADDR of 1st byte of text, this file *x/ */
/* OBSOLETE   long data_offset;		/* offset of data section in file *x/ */
/* OBSOLETE   int chan;			/* file descriptor for the file *x/ */
/* OBSOLETE   struct shared_library *shares;	/* library this one shares *x/ */
/* OBSOLETE }; */
/* OBSOLETE static struct shared_library *shlib = 0; */
/* OBSOLETE  */
/* OBSOLETE /* Hook for `exec_file_command' command to call.  *x/ */
/* OBSOLETE  */
/* OBSOLETE extern void (*exec_file_display_hook) (); */
/* OBSOLETE  */
/* OBSOLETE static CORE_ADDR unshared_text_start; */
/* OBSOLETE  */
/* OBSOLETE /* extended header from exec file (for shared library info) *x/ */
/* OBSOLETE  */
/* OBSOLETE static struct exec_header exec_header; */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE core_file_command (filename, from_tty) */
/* OBSOLETE      char *filename; */
/* OBSOLETE      int from_tty; */
/* OBSOLETE { */
/* OBSOLETE   int val; */
/* OBSOLETE  */
/* OBSOLETE   /* Discard all vestiges of any previous core file */
/* OBSOLETE      and mark data and stack spaces as empty.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (corefile) */
/* OBSOLETE     free (corefile); */
/* OBSOLETE   corefile = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (corechan >= 0) */
/* OBSOLETE     close (corechan); */
/* OBSOLETE   corechan = -1; */
/* OBSOLETE  */
/* OBSOLETE   data_start = 0; */
/* OBSOLETE   data_end = 0; */
/* OBSOLETE   stack_start = STACK_END_ADDR; */
/* OBSOLETE   stack_end = STACK_END_ADDR; */
/* OBSOLETE  */
/* OBSOLETE   /* Now, if a new core file was specified, open it and digest it.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (filename) */
/* OBSOLETE     { */
/* OBSOLETE       filename = tilde_expand (filename); */
/* OBSOLETE       make_cleanup (free, filename); */
/* OBSOLETE  */
/* OBSOLETE       if (have_inferior_p ()) */
/* OBSOLETE 	error ("To look at a core file, you must kill the program with \"kill\"."); */
/* OBSOLETE       corechan = open (filename, O_RDONLY, 0); */
/* OBSOLETE       if (corechan < 0) */
/* OBSOLETE 	perror_with_name (filename); */
/* OBSOLETE       /* 4.2-style (and perhaps also sysV-style) core dump file.  *x/ */
/* OBSOLETE       { */
/* OBSOLETE 	struct user u; */
/* OBSOLETE  */
/* OBSOLETE 	unsigned int reg_offset, fp_reg_offset; */
/* OBSOLETE  */
/* OBSOLETE 	val = myread (corechan, &u, sizeof u); */
/* OBSOLETE 	if (val < 0) */
/* OBSOLETE 	  perror_with_name ("Not a core file: reading upage"); */
/* OBSOLETE 	if (val != sizeof u) */
/* OBSOLETE 	  error ("Not a core file: could only read %d bytes", val); */
/* OBSOLETE  */
/* OBSOLETE 	/* We are depending on exec_file_command having been called */
/* OBSOLETE 	   previously to set exec_data_start.  Since the executable */
/* OBSOLETE 	   and the core file share the same text segment, the address */
/* OBSOLETE 	   of the data segment will be the same in both.  *x/ */
/* OBSOLETE 	data_start = exec_data_start; */
/* OBSOLETE  */
/* OBSOLETE 	data_end = data_start + NBPG * u.u_dsize; */
/* OBSOLETE 	stack_start = stack_end - NBPG * u.u_ssize; */
/* OBSOLETE 	data_offset = NBPG * UPAGES; */
/* OBSOLETE 	stack_offset = NBPG * (UPAGES + u.u_dsize); */
/* OBSOLETE  */
/* OBSOLETE 	/* Some machines put an absolute address in here and some put */
/* OBSOLETE 	   the offset in the upage of the regs.  *x/ */
/* OBSOLETE 	reg_offset = (int) u.u_ar0; */
/* OBSOLETE 	if (reg_offset > NBPG * UPAGES) */
/* OBSOLETE 	  reg_offset -= KERNEL_U_ADDR; */
/* OBSOLETE 	fp_reg_offset = (char *) &u.u_fp_regs - (char *) &u; */
/* OBSOLETE  */
/* OBSOLETE 	/* I don't know where to find this info. */
/* OBSOLETE 	   So, for now, mark it as not available.  *x/ */
/* OBSOLETE 	N_SET_MAGIC (core_aouthdr, 0); */
/* OBSOLETE  */
/* OBSOLETE 	/* Read the register values out of the core file and store */
/* OBSOLETE 	   them where `read_register' will find them.  *x/ */
/* OBSOLETE  */
/* OBSOLETE 	{ */
/* OBSOLETE 	  register int regno; */
/* OBSOLETE  */
/* OBSOLETE 	  for (regno = 0; regno < NUM_REGS; regno++) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      char buf[MAX_REGISTER_RAW_SIZE]; */
/* OBSOLETE  */
/* OBSOLETE 	      if (regno < 16) */
/* OBSOLETE 		val = lseek (corechan, reg_offset + 4 * regno, 0); */
/* OBSOLETE 	      else if (regno < 24) */
/* OBSOLETE 		val = lseek (corechan, fp_reg_offset + 4 + 12 * (regno - 24), 0); */
/* OBSOLETE 	      else if (regno == 24) */
/* OBSOLETE 		val = lseek (corechan, fp_reg_offset, 0); */
/* OBSOLETE 	      else if (regno == 25) */
/* OBSOLETE 		val = lseek (corechan, reg_offset + 4 * PC, 0); */
/* OBSOLETE 	      if (val < 0 */
/* OBSOLETE 		  || (val = myread (corechan, buf, sizeof buf)) < 0) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  char *buffer = (char *) alloca (strlen (REGISTER_NAME (regno)) */
/* OBSOLETE 						  + 30); */
/* OBSOLETE 		  strcpy (buffer, "Reading register "); */
/* OBSOLETE 		  strcat (buffer, REGISTER_NAME (regno)); */
/* OBSOLETE  */
/* OBSOLETE 		  perror_with_name (buffer); */
/* OBSOLETE 		} */
/* OBSOLETE  */
/* OBSOLETE 	      if (regno == PC_REGNUM) */
/* OBSOLETE 		*(int *) buf = GET_PC_PART (*(int *) buf); */
/* OBSOLETE 	      supply_register (regno, buf); */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE       } */
/* OBSOLETE       if (filename[0] == '/') */
/* OBSOLETE 	corefile = savestring (filename, strlen (filename)); */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  corefile = concat (current_directory, "/", filename, NULL); */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       flush_cached_frames (); */
/* OBSOLETE       select_frame (get_current_frame (), 0); */
/* OBSOLETE       validate_files (); */
/* OBSOLETE     } */
/* OBSOLETE   else if (from_tty) */
/* OBSOLETE     printf ("No core file now.\n"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #if 0 */
/* OBSOLETE /* Work with core dump and executable files, for GDB.  */
/* OBSOLETE    This code would be in corefile.c if it weren't machine-dependent. *x/ */
/* OBSOLETE  */
/* OBSOLETE /* Structure to describe the chain of shared libraries used */
/* OBSOLETE    by the execfile. */
/* OBSOLETE    e.g. prog shares Xt which shares X11 which shares c. *x/ */
/* OBSOLETE  */
/* OBSOLETE struct shared_library */
/* OBSOLETE { */
/* OBSOLETE   struct exec_header header; */
/* OBSOLETE   char name[SHLIBLEN]; */
/* OBSOLETE   CORE_ADDR text_start;		/* CORE_ADDR of 1st byte of text, this file *x/ */
/* OBSOLETE   long data_offset;		/* offset of data section in file *x/ */
/* OBSOLETE   int chan;			/* file descriptor for the file *x/ */
/* OBSOLETE   struct shared_library *shares;	/* library this one shares *x/ */
/* OBSOLETE }; */
/* OBSOLETE static struct shared_library *shlib = 0; */
/* OBSOLETE  */
/* OBSOLETE /* Hook for `exec_file_command' command to call.  *x/ */
/* OBSOLETE  */
/* OBSOLETE extern void (*exec_file_display_hook) (); */
/* OBSOLETE  */
/* OBSOLETE static CORE_ADDR unshared_text_start; */
/* OBSOLETE  */
/* OBSOLETE /* extended header from exec file (for shared library info) *x/ */
/* OBSOLETE  */
/* OBSOLETE static struct exec_header exec_header; */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE exec_file_command (filename, from_tty) */
/* OBSOLETE      char *filename; */
/* OBSOLETE      int from_tty; */
/* OBSOLETE { */
/* OBSOLETE   int val; */
/* OBSOLETE  */
/* OBSOLETE   /* Eliminate all traces of old exec file. */
/* OBSOLETE      Mark text segment as empty.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (execfile) */
/* OBSOLETE     free (execfile); */
/* OBSOLETE   execfile = 0; */
/* OBSOLETE   data_start = 0; */
/* OBSOLETE   data_end -= exec_data_start; */
/* OBSOLETE   text_start = 0; */
/* OBSOLETE   unshared_text_start = 0; */
/* OBSOLETE   text_end = 0; */
/* OBSOLETE   exec_data_start = 0; */
/* OBSOLETE   exec_data_end = 0; */
/* OBSOLETE   if (execchan >= 0) */
/* OBSOLETE     close (execchan); */
/* OBSOLETE   execchan = -1; */
/* OBSOLETE   if (shlib) */
/* OBSOLETE     { */
/* OBSOLETE       close_shared_library (shlib); */
/* OBSOLETE       shlib = 0; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Now open and digest the file the user requested, if any.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (filename) */
/* OBSOLETE     { */
/* OBSOLETE       filename = tilde_expand (filename); */
/* OBSOLETE       make_cleanup (free, filename); */
/* OBSOLETE  */
/* OBSOLETE       execchan = openp (getenv ("PATH"), 1, filename, O_RDONLY, 0, */
/* OBSOLETE 			&execfile); */
/* OBSOLETE       if (execchan < 0) */
/* OBSOLETE 	perror_with_name (filename); */
/* OBSOLETE  */
/* OBSOLETE       { */
/* OBSOLETE 	struct stat st_exec; */
/* OBSOLETE  */
/* OBSOLETE #ifdef HEADER_SEEK_FD */
/* OBSOLETE 	HEADER_SEEK_FD (execchan); */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE 	val = myread (execchan, &exec_header, sizeof exec_header); */
/* OBSOLETE 	exec_aouthdr = exec_header.a_exec; */
/* OBSOLETE  */
/* OBSOLETE 	if (val < 0) */
/* OBSOLETE 	  perror_with_name (filename); */
/* OBSOLETE  */
/* OBSOLETE 	text_start = 0x8000; */
/* OBSOLETE  */
/* OBSOLETE 	/* Look for shared library if needed *x/ */
/* OBSOLETE 	if (exec_header.a_exec.a_magic & MF_USES_SL) */
/* OBSOLETE 	  shlib = open_shared_library (exec_header.a_shlibname, text_start); */
/* OBSOLETE  */
/* OBSOLETE 	text_offset = N_TXTOFF (exec_aouthdr); */
/* OBSOLETE 	exec_data_offset = N_TXTOFF (exec_aouthdr) + exec_aouthdr.a_text; */
/* OBSOLETE  */
/* OBSOLETE 	if (shlib) */
/* OBSOLETE 	  { */
/* OBSOLETE 	    unshared_text_start = shared_text_end (shlib) & ~0x7fff; */
/* OBSOLETE 	    stack_start = shlib->header.a_exec.a_sldatabase; */
/* OBSOLETE 	    stack_end = STACK_END_ADDR; */
/* OBSOLETE 	  } */
/* OBSOLETE 	else */
/* OBSOLETE 	  unshared_text_start = 0x8000; */
/* OBSOLETE 	text_end = unshared_text_start + exec_aouthdr.a_text; */
/* OBSOLETE  */
/* OBSOLETE 	exec_data_start = unshared_text_start + exec_aouthdr.a_text; */
/* OBSOLETE 	exec_data_end = exec_data_start + exec_aouthdr.a_data; */
/* OBSOLETE  */
/* OBSOLETE 	data_start = exec_data_start; */
/* OBSOLETE 	data_end += exec_data_start; */
/* OBSOLETE  */
/* OBSOLETE 	fstat (execchan, &st_exec); */
/* OBSOLETE 	exec_mtime = st_exec.st_mtime; */
/* OBSOLETE       } */
/* OBSOLETE  */
/* OBSOLETE       validate_files (); */
/* OBSOLETE     } */
/* OBSOLETE   else if (from_tty) */
/* OBSOLETE     printf ("No executable file now.\n"); */
/* OBSOLETE  */
/* OBSOLETE   /* Tell display code (if any) about the changed file name.  *x/ */
/* OBSOLETE   if (exec_file_display_hook) */
/* OBSOLETE     (*exec_file_display_hook) (filename); */
/* OBSOLETE } */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE #if 0 */
/* OBSOLETE /* Read from the program's memory (except for inferior processes). */
/* OBSOLETE    This function is misnamed, since it only reads, never writes; and */
/* OBSOLETE    since it will use the core file and/or executable file as necessary. */
/* OBSOLETE  */
/* OBSOLETE    It should be extended to write as well as read, FIXME, for patching files. */
/* OBSOLETE  */
/* OBSOLETE    Return 0 if address could be read, EIO if addresss out of bounds.  *x/ */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE xfer_core_file (memaddr, myaddr, len) */
/* OBSOLETE      CORE_ADDR memaddr; */
/* OBSOLETE      char *myaddr; */
/* OBSOLETE      int len; */
/* OBSOLETE { */
/* OBSOLETE   register int i; */
/* OBSOLETE   register int val; */
/* OBSOLETE   int xferchan; */
/* OBSOLETE   char **xferfile; */
/* OBSOLETE   int fileptr; */
/* OBSOLETE   int returnval = 0; */
/* OBSOLETE  */
/* OBSOLETE   while (len > 0) */
/* OBSOLETE     { */
/* OBSOLETE       xferfile = 0; */
/* OBSOLETE       xferchan = 0; */
/* OBSOLETE  */
/* OBSOLETE       /* Determine which file the next bunch of addresses reside in, */
/* OBSOLETE          and where in the file.  Set the file's read/write pointer */
/* OBSOLETE          to point at the proper place for the desired address */
/* OBSOLETE          and set xferfile and xferchan for the correct file. */
/* OBSOLETE  */
/* OBSOLETE          If desired address is nonexistent, leave them zero. */
/* OBSOLETE  */
/* OBSOLETE          i is set to the number of bytes that can be handled */
/* OBSOLETE          along with the next address. */
/* OBSOLETE  */
/* OBSOLETE          We put the most likely tests first for efficiency.  *x/ */
/* OBSOLETE  */
/* OBSOLETE       /* Note that if there is no core file */
/* OBSOLETE          data_start and data_end are equal.  *x/ */
/* OBSOLETE       if (memaddr >= data_start && memaddr < data_end) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  i = min (len, data_end - memaddr); */
/* OBSOLETE 	  fileptr = memaddr - data_start + data_offset; */
/* OBSOLETE 	  xferfile = &corefile; */
/* OBSOLETE 	  xferchan = corechan; */
/* OBSOLETE 	} */
/* OBSOLETE       /* Note that if there is no core file */
/* OBSOLETE          stack_start and stack_end define the shared library data.  *x/ */
/* OBSOLETE       else if (memaddr >= stack_start && memaddr < stack_end) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  if (corechan < 0) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      struct shared_library *lib; */
/* OBSOLETE 	      for (lib = shlib; lib; lib = lib->shares) */
/* OBSOLETE 		if (memaddr >= lib->header.a_exec.a_sldatabase && */
/* OBSOLETE 		    memaddr < lib->header.a_exec.a_sldatabase + */
/* OBSOLETE 		    lib->header.a_exec.a_data) */
/* OBSOLETE 		  break; */
/* OBSOLETE 	      if (lib) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  i = min (len, lib->header.a_exec.a_sldatabase + */
/* OBSOLETE 			   lib->header.a_exec.a_data - memaddr); */
/* OBSOLETE 		  fileptr = lib->data_offset + memaddr - */
/* OBSOLETE 		    lib->header.a_exec.a_sldatabase; */
/* OBSOLETE 		  xferfile = execfile; */
/* OBSOLETE 		  xferchan = lib->chan; */
/* OBSOLETE 		} */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    { */
/* OBSOLETE 	      i = min (len, stack_end - memaddr); */
/* OBSOLETE 	      fileptr = memaddr - stack_start + stack_offset; */
/* OBSOLETE 	      xferfile = &corefile; */
/* OBSOLETE 	      xferchan = corechan; */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE       else if (corechan < 0 */
/* OBSOLETE 	       && memaddr >= exec_data_start && memaddr < exec_data_end) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  i = min (len, exec_data_end - memaddr); */
/* OBSOLETE 	  fileptr = memaddr - exec_data_start + exec_data_offset; */
/* OBSOLETE 	  xferfile = &execfile; */
/* OBSOLETE 	  xferchan = execchan; */
/* OBSOLETE 	} */
/* OBSOLETE       else if (memaddr >= text_start && memaddr < text_end) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  struct shared_library *lib; */
/* OBSOLETE 	  for (lib = shlib; lib; lib = lib->shares) */
/* OBSOLETE 	    if (memaddr >= lib->text_start && */
/* OBSOLETE 		memaddr < lib->text_start + lib->header.a_exec.a_text) */
/* OBSOLETE 	      break; */
/* OBSOLETE 	  if (lib) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      i = min (len, lib->header.a_exec.a_text + */
/* OBSOLETE 		       lib->text_start - memaddr); */
/* OBSOLETE 	      fileptr = memaddr - lib->text_start + text_offset; */
/* OBSOLETE 	      xferfile = &execfile; */
/* OBSOLETE 	      xferchan = lib->chan; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    { */
/* OBSOLETE 	      i = min (len, text_end - memaddr); */
/* OBSOLETE 	      fileptr = memaddr - unshared_text_start + text_offset; */
/* OBSOLETE 	      xferfile = &execfile; */
/* OBSOLETE 	      xferchan = execchan; */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE       else if (memaddr < text_start) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  i = min (len, text_start - memaddr); */
/* OBSOLETE 	} */
/* OBSOLETE       else if (memaddr >= text_end */
/* OBSOLETE 	       && memaddr < (corechan >= 0 ? data_start : exec_data_start)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  i = min (len, data_start - memaddr); */
/* OBSOLETE 	} */
/* OBSOLETE       else if (corechan >= 0 */
/* OBSOLETE 	       && memaddr >= data_end && memaddr < stack_start) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  i = min (len, stack_start - memaddr); */
/* OBSOLETE 	} */
/* OBSOLETE       else if (corechan < 0 && memaddr >= exec_data_end) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  i = min (len, -memaddr); */
/* OBSOLETE 	} */
/* OBSOLETE       else if (memaddr >= stack_end && stack_end != 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  i = min (len, -memaddr); */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* Address did not classify into one of the known ranges. */
/* OBSOLETE 	     This shouldn't happen; we catch the endpoints.  *x/ */
/* OBSOLETE 	  internal_error ("Bad case logic in xfer_core_file."); */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       /* Now we know which file to use. */
/* OBSOLETE          Set up its pointer and transfer the data.  *x/ */
/* OBSOLETE       if (xferfile) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  if (*xferfile == 0) */
/* OBSOLETE 	    if (xferfile == &execfile) */
/* OBSOLETE 	      error ("No program file to examine."); */
/* OBSOLETE 	    else */
/* OBSOLETE 	      error ("No core dump file or running program to examine."); */
/* OBSOLETE 	  val = lseek (xferchan, fileptr, 0); */
/* OBSOLETE 	  if (val < 0) */
/* OBSOLETE 	    perror_with_name (*xferfile); */
/* OBSOLETE 	  val = myread (xferchan, myaddr, i); */
/* OBSOLETE 	  if (val < 0) */
/* OBSOLETE 	    perror_with_name (*xferfile); */
/* OBSOLETE 	} */
/* OBSOLETE       /* If this address is for nonexistent memory, */
/* OBSOLETE          read zeros if reading, or do nothing if writing. */
/* OBSOLETE          Actually, we never right.  *x/ */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  memset (myaddr, '\0', i); */
/* OBSOLETE 	  returnval = EIO; */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       memaddr += i; */
/* OBSOLETE       myaddr += i; */
/* OBSOLETE       len -= i; */
/* OBSOLETE     } */
/* OBSOLETE   return returnval; */
/* OBSOLETE } */
/* OBSOLETE #endif */
@


