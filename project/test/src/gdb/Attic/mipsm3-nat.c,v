head	1.8;
access;
symbols
	gdb_6_0-2003-10-04-release:1.7
	kettenis_sparc-20030918-branch:1.7.0.22
	kettenis_sparc-20030918-branchpoint:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.20
	cagney_x86i386-20030821-branch:1.7.0.18
	cagney_x86i386-20030821-branchpoint:1.7
	carlton_dictionary-20030805-merge:1.7
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.16
	gdb_6_0-2003-06-23-branchpoint:1.7
	jimb-ppc64-linux-20030613-branch:1.7.0.14
	jimb-ppc64-linux-20030613-branchpoint:1.7
	cagney_convert-20030606-branch:1.7.0.12
	cagney_convert-20030606-branchpoint:1.7
	cagney_writestrings-20030508-branch:1.7.0.10
	cagney_writestrings-20030508-branchpoint:1.7
	jimb-ppc64-linux-20030528-branch:1.7.0.8
	jimb-ppc64-linux-20030528-branchpoint:1.7
	carlton_dictionary-20030523-merge:1.7
	cagney_fileio-20030521-branch:1.7.0.6
	cagney_fileio-20030521-branchpoint:1.7
	kettenis_i386newframe-20030517-mergepoint:1.7
	jimb-ppc64-linux-20030509-branch:1.7.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.7
	kettenis_i386newframe-20030504-mergepoint:1.7
	carlton_dictionary-20030430-merge:1.7
	kettenis_i386newframe-20030419-branch:1.7.0.2
	kettenis_i386newframe-20030419-branchpoint:1.7
	carlton_dictionary-20030416-merge:1.7
	cagney_frameaddr-20030409-mergepoint:1.7
	kettenis_i386newframe-20030406-branch:1.6.0.18
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.16
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.14
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.12
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.10
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.8
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.6
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030203-mergepoint:1.6
	interps-20030202-branch:1.6.0.4
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.2
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.4
	carlton_dictionary-20021115-merge:1.6
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.4.0.26
	drow-cplus-branchpoint:1.4
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.24
	carlton_dictionary-20020920-branchpoint:1.4
	gdb_5_3-branch:1.4.0.22
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.20
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.18
	readline_4_3-import-branchpoint:1.4
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.16
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.14
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.12
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.10
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.8
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.6
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.4
	gdb_5_1-2001-07-29-branchpoint:1.4
	dberlin-typesystem-branch:1.4.0.2
	dberlin-typesystem-branchpoint:1.4
	gdb-post-ptid_t-2001-05-03:1.4
	gdb-pre-ptid_t-2001-05-03:1.4
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb-post-params-removal-2000-06-04:1.1.1.2
	gdb-pre-params-removal-2000-06-04:1.1.1.2
	gdb-post-params-removal-2000-05-28:1.1.1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.8
date	2003.10.06.19.10.44;	author cagney;	state dead;
branches;
next	1.7;

1.7
date	2003.04.09.16.10.05;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.14.20.37.28;	author cagney;	state Exp;
branches
	1.6.16.1;
next	1.5;

1.5
date	2002.11.07.15.31.31;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.06.08.21.10;	author kevinb;	state Exp;
branches
	1.4.24.1
	1.4.26.1;
next	1.3;

1.3
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.08.09;	author jsm;	state Exp;
branches;
next	;

1.4.24.1
date	2002.11.15.19.18.51;	author carlton;	state Exp;
branches;
next	1.4.24.2;

1.4.24.2
date	2003.04.16.19.56.53;	author carlton;	state Exp;
branches;
next	1.4.24.3;

1.4.24.3
date	2003.11.11.23.50.51;	author carlton;	state dead;
branches;
next	;

1.4.26.1
date	2003.12.14.20.27.22;	author drow;	state dead;
branches;
next	;

1.6.16.1
date	2003.04.10.21.33.49;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.8
log
@2003-10-06  Andrew Cagney  <cagney@@redhat.com>

	* z8k-tdep.c, symm-tdep.c, symm-nat.c: Delete obsolete file.
	* sparclet-stub.c, sparclet-rom.c: Delete obsolete file.
	* sparcl-tdep.c, sparcl-stub.c, h8500-tdep.c: Delete obsolete file.
	* m3-nat.c, mipsm3-nat.c, mn10200-tdep.c: Delete obsolete file.
@
text
@// OBSOLETE /* Definitions to make GDB run on a mips box under Mach 3.0
// OBSOLETE    Copyright 1992, 1993, 1998, 2000, 2001 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /* Mach specific routines for little endian mips (e.g. pmax)
// OBSOLETE  * running Mach 3.0
// OBSOLETE  *
// OBSOLETE  * Author: Jukka Virtanen <jtv@@hut.fi>
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #include <stdio.h>
// OBSOLETE 
// OBSOLETE #include <mach.h>
// OBSOLETE #include <mach/message.h>
// OBSOLETE #include <mach/exception.h>
// OBSOLETE #include <mach_error.h>
// OBSOLETE 
// OBSOLETE /* Find offsets to thread states at compile time.
// OBSOLETE  * If your compiler does not grok this, check the hand coded
// OBSOLETE  * offsets and use them.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #if 1
// OBSOLETE 
// OBSOLETE #define  REG_OFFSET(reg) (int)(&((struct mips_thread_state *)0)->reg)
// OBSOLETE #define CREG_OFFSET(reg) (int)(&((struct mips_float_state *)0)->reg)
// OBSOLETE #define EREG_OFFSET(reg) (int)(&((struct mips_exc_state *)0)->reg)
// OBSOLETE 
// OBSOLETE /* at reg_offset[i] is the offset to the mips_thread_state
// OBSOLETE  * location where the gdb registers[i] is stored.
// OBSOLETE  *
// OBSOLETE  * -1 means mach does not save it anywhere.
// OBSOLETE  */
// OBSOLETE static int reg_offset[] =
// OBSOLETE {
// OBSOLETE   /*  zero              at                v0                v1       */
// OBSOLETE   -1, REG_OFFSET (r1), REG_OFFSET (r2), REG_OFFSET (r3),
// OBSOLETE 
// OBSOLETE   /*  a0                a1                a2                a3       */
// OBSOLETE   REG_OFFSET (r4), REG_OFFSET (r5), REG_OFFSET (r6), REG_OFFSET (r7),
// OBSOLETE 
// OBSOLETE   /*  t0                t1                t2                t3       */
// OBSOLETE   REG_OFFSET (r8), REG_OFFSET (r9), REG_OFFSET (r10), REG_OFFSET (r11),
// OBSOLETE 
// OBSOLETE   /*  t4                t5                t6                t7       */
// OBSOLETE   REG_OFFSET (r12), REG_OFFSET (r13), REG_OFFSET (r14), REG_OFFSET (r15),
// OBSOLETE 
// OBSOLETE   /*  s0                s1                s2                s3       */
// OBSOLETE   REG_OFFSET (r16), REG_OFFSET (r17), REG_OFFSET (r18), REG_OFFSET (r19),
// OBSOLETE 
// OBSOLETE   /*  s4                s5                s6                s7       */
// OBSOLETE   REG_OFFSET (r20), REG_OFFSET (r21), REG_OFFSET (r22), REG_OFFSET (r23),
// OBSOLETE 
// OBSOLETE   /*  t8                t9                k0                k1       */
// OBSOLETE   REG_OFFSET (r24), REG_OFFSET (r25), REG_OFFSET (r26), REG_OFFSET (r27),
// OBSOLETE 
// OBSOLETE   /*  gp                sp            s8(30) == fp(72)      ra       */
// OBSOLETE   REG_OFFSET (r28), REG_OFFSET (r29), REG_OFFSET (r30), REG_OFFSET (r31),
// OBSOLETE 
// OBSOLETE   /*  sr(32) PS_REGNUM   */
// OBSOLETE   EREG_OFFSET (coproc_state),
// OBSOLETE 
// OBSOLETE   /*  lo(33)            hi(34)    */
// OBSOLETE   REG_OFFSET (mdlo), REG_OFFSET (mdhi),
// OBSOLETE 
// OBSOLETE   /*  bad(35)                 cause(36)          pc(37)  */
// OBSOLETE   EREG_OFFSET (address), EREG_OFFSET (cause), REG_OFFSET (pc),
// OBSOLETE 
// OBSOLETE   /*  f0(38)             f1(39)             f2(40)             f3(41)   */
// OBSOLETE   CREG_OFFSET (r0), CREG_OFFSET (r1), CREG_OFFSET (r2), CREG_OFFSET (r3),
// OBSOLETE   CREG_OFFSET (r4), CREG_OFFSET (r5), CREG_OFFSET (r6), CREG_OFFSET (r7),
// OBSOLETE   CREG_OFFSET (r8), CREG_OFFSET (r9), CREG_OFFSET (r10), CREG_OFFSET (r11),
// OBSOLETE   CREG_OFFSET (r12), CREG_OFFSET (r13), CREG_OFFSET (r14), CREG_OFFSET (r15),
// OBSOLETE   CREG_OFFSET (r16), CREG_OFFSET (r17), CREG_OFFSET (r18), CREG_OFFSET (r19),
// OBSOLETE   CREG_OFFSET (r20), CREG_OFFSET (r21), CREG_OFFSET (r22), CREG_OFFSET (r23),
// OBSOLETE   CREG_OFFSET (r24), CREG_OFFSET (r25), CREG_OFFSET (r26), CREG_OFFSET (r27),
// OBSOLETE   CREG_OFFSET (r28), CREG_OFFSET (r29), CREG_OFFSET (r30), CREG_OFFSET (r31),
// OBSOLETE 
// OBSOLETE   /*  fsr(70)           fir(71)         fp(72) == s8(30) */
// OBSOLETE   CREG_OFFSET (csr), CREG_OFFSET (esr), REG_OFFSET (r30)
// OBSOLETE };
// OBSOLETE #else
// OBSOLETE /* If the compiler does not grok the above defines */
// OBSOLETE static int reg_offset[] =
// OBSOLETE {
// OBSOLETE /* mach_thread_state offsets: */
// OBSOLETE   -1, 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56,
// OBSOLETE   60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120,
// OBSOLETE /*sr, lo, hi,addr,cause,pc   */
// OBSOLETE   8, 124, 128, 4, 0, 132,
// OBSOLETE /* mach_float_state offsets: */
// OBSOLETE   0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60,
// OBSOLETE   64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124,
// OBSOLETE /*fsr,fir */
// OBSOLETE   128, 132,
// OBSOLETE /* FP_REGNUM pseudo maps to s8==r30 in mach_thread_state */
// OBSOLETE   116
// OBSOLETE };
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /* Fetch COUNT contiguous registers from thread STATE starting from REGNUM
// OBSOLETE  * Caller knows that the regs handled in one transaction are of same size.
// OBSOLETE  */
// OBSOLETE #define FETCH_REGS(state, regnum, count) \
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (regnum)], \
// OBSOLETE 	  (char *)state+reg_offset[ regnum ], \
// OBSOLETE 	  count*REGISTER_SIZE)
// OBSOLETE 
// OBSOLETE /* Store COUNT contiguous registers to thread STATE starting from REGNUM */
// OBSOLETE #define STORE_REGS(state, regnum, count) \
// OBSOLETE   memcpy ((char *)state+reg_offset[ regnum ], \
// OBSOLETE 	  &deprecated_registers[REGISTER_BYTE (regnum)], \
// OBSOLETE 	  count*REGISTER_SIZE)
// OBSOLETE 
// OBSOLETE #define REGS_ALL    -1
// OBSOLETE #define REGS_NORMAL  1
// OBSOLETE #define REGS_EXC     2
// OBSOLETE #define REGS_COP1    4
// OBSOLETE 
// OBSOLETE /* Hardware regs that matches FP_REGNUM */
// OBSOLETE #define MACH_FP_REGNUM 30
// OBSOLETE 
// OBSOLETE /* Fech thread's registers. if regno == -1, fetch all regs */
// OBSOLETE void
// OBSOLETE fetch_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   thread_state_data_t state;
// OBSOLETE   struct mips_exc_state exc_state;
// OBSOLETE 
// OBSOLETE   int stateCnt = MIPS_THREAD_STATE_COUNT;
// OBSOLETE 
// OBSOLETE   int which_regs = 0;		/* A bit mask */
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (current_thread))
// OBSOLETE     error ("fetch inferior registers: Invalid thread");
// OBSOLETE 
// OBSOLETE   if (regno < -1 || regno >= NUM_REGS)
// OBSOLETE     error ("invalid register %d supplied to fetch_inferior_registers", regno);
// OBSOLETE 
// OBSOLETE   if (regno == -1)
// OBSOLETE     which_regs = REGS_ALL;
// OBSOLETE   else if (regno == ZERO_REGNUM)
// OBSOLETE     {
// OBSOLETE       int zero = 0;
// OBSOLETE       supply_register (ZERO_REGNUM, &zero);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE   else if ((ZERO_REGNUM < regno && regno < PS_REGNUM)
// OBSOLETE 	   || regno == FP_REGNUM
// OBSOLETE 	   || regno == LO_REGNUM
// OBSOLETE 	   || regno == HI_REGNUM
// OBSOLETE 	   || regno == PC_REGNUM)
// OBSOLETE     which_regs = REGS_NORMAL;
// OBSOLETE   else if (FP0_REGNUM <= regno && regno <= FCRIR_REGNUM)
// OBSOLETE     which_regs = REGS_COP1 | REGS_EXC;
// OBSOLETE   else
// OBSOLETE     which_regs = REGS_EXC;
// OBSOLETE 
// OBSOLETE   /* fetch regs saved to mips_thread_state */
// OBSOLETE   if (which_regs & REGS_NORMAL)
// OBSOLETE     {
// OBSOLETE       ret = thread_get_state (current_thread,
// OBSOLETE 			      MIPS_THREAD_STATE,
// OBSOLETE 			      state,
// OBSOLETE 			      &stateCnt);
// OBSOLETE       CHK ("fetch inferior registers: thread_get_state", ret);
// OBSOLETE 
// OBSOLETE       if (which_regs == REGS_NORMAL)
// OBSOLETE 	{
// OBSOLETE 	  /* Fetch also FP_REGNUM if fetching MACH_FP_REGNUM and vice versa */
// OBSOLETE 	  if (regno == MACH_FP_REGNUM || regno == FP_REGNUM)
// OBSOLETE 	    {
// OBSOLETE 	      supply_register (FP_REGNUM,
// OBSOLETE 			       (char *) state + reg_offset[MACH_FP_REGNUM]);
// OBSOLETE 	      supply_register (MACH_FP_REGNUM,
// OBSOLETE 			       (char *) state + reg_offset[MACH_FP_REGNUM]);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    supply_register (regno,
// OBSOLETE 			     (char *) state + reg_offset[regno]);
// OBSOLETE 	  return;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* ZERO_REGNUM is always zero */
// OBSOLETE       *(int *) deprecated_registers = 0;
// OBSOLETE 
// OBSOLETE       /* Copy thread saved regs 1..31 to gdb's reg value array
// OBSOLETE        * Luckily, they are contiquous
// OBSOLETE        */
// OBSOLETE       FETCH_REGS (state, 1, 31);
// OBSOLETE 
// OBSOLETE       /* Copy mdlo and mdhi */
// OBSOLETE       FETCH_REGS (state, LO_REGNUM, 2);
// OBSOLETE 
// OBSOLETE       /* Copy PC */
// OBSOLETE       FETCH_REGS (state, PC_REGNUM, 1);
// OBSOLETE 
// OBSOLETE       /* Mach 3.0 saves FP to MACH_FP_REGNUM.
// OBSOLETE        * For some reason gdb wants to assign a pseudo register for it.
// OBSOLETE        */
// OBSOLETE       FETCH_REGS (state, FP_REGNUM, 1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Read exc state. Also read if need to fetch floats */
// OBSOLETE   if (which_regs & REGS_EXC)
// OBSOLETE     {
// OBSOLETE       stateCnt = MIPS_EXC_STATE_COUNT;
// OBSOLETE       ret = thread_get_state (current_thread,
// OBSOLETE 			      MIPS_EXC_STATE,
// OBSOLETE 			      (thread_state_t) & exc_state,
// OBSOLETE 			      &stateCnt);
// OBSOLETE       CHK ("fetch inferior regs (exc): thread_get_state", ret);
// OBSOLETE 
// OBSOLETE       /* We need to fetch exc_state to see if the floating
// OBSOLETE        * state is valid for the thread.
// OBSOLETE        */
// OBSOLETE 
// OBSOLETE       /* cproc_state: Which coprocessors the thread uses */
// OBSOLETE       supply_register (PS_REGNUM,
// OBSOLETE 		       (char *) &exc_state + reg_offset[PS_REGNUM]);
// OBSOLETE 
// OBSOLETE       if (which_regs == REGS_EXC || which_regs == REGS_ALL)
// OBSOLETE 	{
// OBSOLETE 	  supply_register (BADVADDR_REGNUM,
// OBSOLETE 			 (char *) &exc_state + reg_offset[BADVADDR_REGNUM]);
// OBSOLETE 
// OBSOLETE 	  supply_register (CAUSE_REGNUM,
// OBSOLETE 			   (char *) &exc_state + reg_offset[CAUSE_REGNUM]);
// OBSOLETE 	  if (which_regs == REGS_EXC)
// OBSOLETE 	    return;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   if (which_regs & REGS_COP1)
// OBSOLETE     {
// OBSOLETE       /* If the thread does not have saved COPROC1, set regs to zero */
// OBSOLETE 
// OBSOLETE       if (!(exc_state.coproc_state & MIPS_STATUS_USE_COP1))
// OBSOLETE 	bzero (&deprecated_registers[REGISTER_BYTE (FP0_REGNUM)],
// OBSOLETE 	       sizeof (struct mips_float_state));
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  stateCnt = MIPS_FLOAT_STATE_COUNT;
// OBSOLETE 	  ret = thread_get_state (current_thread,
// OBSOLETE 				  MIPS_FLOAT_STATE,
// OBSOLETE 				  state,
// OBSOLETE 				  &stateCnt);
// OBSOLETE 	  CHK ("fetch inferior regs (floats): thread_get_state", ret);
// OBSOLETE 
// OBSOLETE 	  if (regno != -1)
// OBSOLETE 	    {
// OBSOLETE 	      supply_register (regno,
// OBSOLETE 			       (char *) state + reg_offset[regno]);
// OBSOLETE 	      return;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  FETCH_REGS (state, FP0_REGNUM, 34);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* All registers are valid, if not returned yet */
// OBSOLETE   deprecated_registers_fetched ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store gdb's view of registers to the thread.
// OBSOLETE  * All registers are always valid when entering here.
// OBSOLETE  * @@@@ ahem, maybe that is too strict, we could validate the necessary ones
// OBSOLETE  *    here.
// OBSOLETE  *
// OBSOLETE  * Hmm. It seems that gdb set $reg=value command first reads everything,
// OBSOLETE  * then sets the reg and then stores everything. -> we must make sure
// OBSOLETE  * that the immutable registers are not changed by reading them first.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE store_inferior_registers (register int regno)
// OBSOLETE {
// OBSOLETE   thread_state_data_t state;
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (current_thread))
// OBSOLETE     error ("store inferior registers: Invalid thread");
// OBSOLETE 
// OBSOLETE   /* Check for read only regs.
// OBSOLETE    * @@@@ If some of these is can be changed, fix this
// OBSOLETE    */
// OBSOLETE   if (regno == ZERO_REGNUM ||
// OBSOLETE       regno == PS_REGNUM ||
// OBSOLETE       regno == BADVADDR_REGNUM ||
// OBSOLETE       regno == CAUSE_REGNUM ||
// OBSOLETE       regno == FCRIR_REGNUM)
// OBSOLETE     {
// OBSOLETE       message ("You can not alter read-only register `%s'",
// OBSOLETE 	       REGISTER_NAME (regno));
// OBSOLETE       fetch_inferior_registers (regno);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (regno == -1)
// OBSOLETE     {
// OBSOLETE       /* Don't allow these to change */
// OBSOLETE 
// OBSOLETE       /* ZERO_REGNUM */
// OBSOLETE       *(int *) deprecated_registers = 0;
// OBSOLETE 
// OBSOLETE       fetch_inferior_registers (PS_REGNUM);
// OBSOLETE       fetch_inferior_registers (BADVADDR_REGNUM);
// OBSOLETE       fetch_inferior_registers (CAUSE_REGNUM);
// OBSOLETE       fetch_inferior_registers (FCRIR_REGNUM);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (regno == -1 || (ZERO_REGNUM < regno && regno <= PC_REGNUM))
// OBSOLETE     {
// OBSOLETE #if 1
// OBSOLETE       /* Mach 3.0 saves thread's FP to MACH_FP_REGNUM.
// OBSOLETE        * GDB wants assigns a pseudo register FP_REGNUM for frame pointer.
// OBSOLETE        *
// OBSOLETE        * @@@@@@ Here I assume (!) that gdb's FP has the value that
// OBSOLETE        *     should go to threads frame pointer. If not true, this
// OBSOLETE        *     fails badly!!!!!
// OBSOLETE        */
// OBSOLETE       memcpy (&deprecated_registers[REGISTER_BYTE (MACH_FP_REGNUM)],
// OBSOLETE 	      &deprecated_registers[REGISTER_BYTE (FP_REGNUM)],
// OBSOLETE 	      REGISTER_RAW_SIZE (FP_REGNUM));
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE       /* Save gdb's regs 1..31 to thread saved regs 1..31
// OBSOLETE        * Luckily, they are contiquous
// OBSOLETE        */
// OBSOLETE       STORE_REGS (state, 1, 31);
// OBSOLETE 
// OBSOLETE       /* Save mdlo, mdhi */
// OBSOLETE       STORE_REGS (state, LO_REGNUM, 2);
// OBSOLETE 
// OBSOLETE       /* Save PC */
// OBSOLETE       STORE_REGS (state, PC_REGNUM, 1);
// OBSOLETE 
// OBSOLETE       ret = thread_set_state (current_thread,
// OBSOLETE 			      MIPS_THREAD_STATE,
// OBSOLETE 			      state,
// OBSOLETE 			      MIPS_FLOAT_STATE_COUNT);
// OBSOLETE       CHK ("store inferior regs : thread_set_state", ret);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (regno == -1 || regno >= FP0_REGNUM)
// OBSOLETE     {
// OBSOLETE       /* If thread has floating state, save it */
// OBSOLETE       if (read_register (PS_REGNUM) & MIPS_STATUS_USE_COP1)
// OBSOLETE 	{
// OBSOLETE 	  /* Do NOT save FCRIR_REGNUM */
// OBSOLETE 	  STORE_REGS (state, FP0_REGNUM, 33);
// OBSOLETE 
// OBSOLETE 	  ret = thread_set_state (current_thread,
// OBSOLETE 				  MIPS_FLOAT_STATE,
// OBSOLETE 				  state,
// OBSOLETE 				  MIPS_FLOAT_STATE_COUNT);
// OBSOLETE 	  CHK ("store inferior registers (floats): thread_set_state", ret);
// OBSOLETE 	}
// OBSOLETE       else if (regno != -1)
// OBSOLETE 	message
// OBSOLETE 	  ("Thread does not use floating point unit, floating regs not saved");
// OBSOLETE     }
// OBSOLETE }
@


1.7
log
@2003-04-09  Andrew Cagney  <cagney@@redhat.com>

	Obsolete mips*-*-mach3*.
	* NEWS: Mention that mips*-*-mach3* is obsolete.
	* m3-nat.c: Obsolete file.
	* config/nm-m3.h: Obsolete file.
	* config/mips/tm-mipsm3.h: Obsolete file.
	* config/mips/mipsm3.mt: Obsolete file.
	* config/mips/mipsm3.mh: Obsolete file.
	* config/mips/xm-mipsm3.h: Obsolete file.
	* mipsm3-nat.c: Obsolete file.
	* configure.host: Obsolete mips-dec-mach3*.
	* configure.tgt: Obsolete mips*-*-mach3*.
@
text
@@


1.6
log
@2002-11-14  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_registers): Rename registers.
	* a68v-nat.c, alpha-nat.c, arch-utils.c, core-sol2.c: Update.
	* hp300ux-nat.c, hppab-nat.c, hppah-nat.c: Update.
	* hppam3-nat.c, hpux-thread.c, i386gnu-nat.c: Update.
	* ia64-aix-nat.c, ia64-linux-nat.c, ia64-tdep.c: Update.
	* irix4-nat.c, irix5-nat.c, lynx-nat.c, m68k-tdep.c: Update.
	* m68knbsd-nat.c, mips-linux-tdep.c, mipsm3-nat.c: Update.
	* mipsv4-nat.c, ns32knbsd-nat.c, ppc-bdm.c: Update.
	* ppc-sysv-tdep.c, ptx4-nat.c, regcache.c, remote-es.c: Update.
	* remote-sds.c, remote-vx68.c, remote-vxmips.c: Update.
	* remote-vxsparc.c, rs6000-tdep.c, sol-thread.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, symm-nat.c: Update.
	* v850ice.c: Update.
@
text
@d1 386
a386 386
/* Definitions to make GDB run on a mips box under Mach 3.0
   Copyright 1992, 1993, 1998, 2000, 2001 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* Mach specific routines for little endian mips (e.g. pmax)
 * running Mach 3.0
 *
 * Author: Jukka Virtanen <jtv@@hut.fi>
 */

#include "defs.h"
#include "inferior.h"
#include "regcache.h"

#include <stdio.h>

#include <mach.h>
#include <mach/message.h>
#include <mach/exception.h>
#include <mach_error.h>

/* Find offsets to thread states at compile time.
 * If your compiler does not grok this, check the hand coded
 * offsets and use them.
 */

#if 1

#define  REG_OFFSET(reg) (int)(&((struct mips_thread_state *)0)->reg)
#define CREG_OFFSET(reg) (int)(&((struct mips_float_state *)0)->reg)
#define EREG_OFFSET(reg) (int)(&((struct mips_exc_state *)0)->reg)

/* at reg_offset[i] is the offset to the mips_thread_state
 * location where the gdb registers[i] is stored.
 *
 * -1 means mach does not save it anywhere.
 */
static int reg_offset[] =
{
  /*  zero              at                v0                v1       */
  -1, REG_OFFSET (r1), REG_OFFSET (r2), REG_OFFSET (r3),

  /*  a0                a1                a2                a3       */
  REG_OFFSET (r4), REG_OFFSET (r5), REG_OFFSET (r6), REG_OFFSET (r7),

  /*  t0                t1                t2                t3       */
  REG_OFFSET (r8), REG_OFFSET (r9), REG_OFFSET (r10), REG_OFFSET (r11),

  /*  t4                t5                t6                t7       */
  REG_OFFSET (r12), REG_OFFSET (r13), REG_OFFSET (r14), REG_OFFSET (r15),

  /*  s0                s1                s2                s3       */
  REG_OFFSET (r16), REG_OFFSET (r17), REG_OFFSET (r18), REG_OFFSET (r19),

  /*  s4                s5                s6                s7       */
  REG_OFFSET (r20), REG_OFFSET (r21), REG_OFFSET (r22), REG_OFFSET (r23),

  /*  t8                t9                k0                k1       */
  REG_OFFSET (r24), REG_OFFSET (r25), REG_OFFSET (r26), REG_OFFSET (r27),

  /*  gp                sp            s8(30) == fp(72)      ra       */
  REG_OFFSET (r28), REG_OFFSET (r29), REG_OFFSET (r30), REG_OFFSET (r31),

  /*  sr(32) PS_REGNUM   */
  EREG_OFFSET (coproc_state),

  /*  lo(33)            hi(34)    */
  REG_OFFSET (mdlo), REG_OFFSET (mdhi),

  /*  bad(35)                 cause(36)          pc(37)  */
  EREG_OFFSET (address), EREG_OFFSET (cause), REG_OFFSET (pc),

  /*  f0(38)             f1(39)             f2(40)             f3(41)   */
  CREG_OFFSET (r0), CREG_OFFSET (r1), CREG_OFFSET (r2), CREG_OFFSET (r3),
  CREG_OFFSET (r4), CREG_OFFSET (r5), CREG_OFFSET (r6), CREG_OFFSET (r7),
  CREG_OFFSET (r8), CREG_OFFSET (r9), CREG_OFFSET (r10), CREG_OFFSET (r11),
  CREG_OFFSET (r12), CREG_OFFSET (r13), CREG_OFFSET (r14), CREG_OFFSET (r15),
  CREG_OFFSET (r16), CREG_OFFSET (r17), CREG_OFFSET (r18), CREG_OFFSET (r19),
  CREG_OFFSET (r20), CREG_OFFSET (r21), CREG_OFFSET (r22), CREG_OFFSET (r23),
  CREG_OFFSET (r24), CREG_OFFSET (r25), CREG_OFFSET (r26), CREG_OFFSET (r27),
  CREG_OFFSET (r28), CREG_OFFSET (r29), CREG_OFFSET (r30), CREG_OFFSET (r31),

  /*  fsr(70)           fir(71)         fp(72) == s8(30) */
  CREG_OFFSET (csr), CREG_OFFSET (esr), REG_OFFSET (r30)
};
#else
/* If the compiler does not grok the above defines */
static int reg_offset[] =
{
/* mach_thread_state offsets: */
  -1, 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56,
  60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120,
/*sr, lo, hi,addr,cause,pc   */
  8, 124, 128, 4, 0, 132,
/* mach_float_state offsets: */
  0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60,
  64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124,
/*fsr,fir */
  128, 132,
/* FP_REGNUM pseudo maps to s8==r30 in mach_thread_state */
  116
};
#endif

/* Fetch COUNT contiguous registers from thread STATE starting from REGNUM
 * Caller knows that the regs handled in one transaction are of same size.
 */
#define FETCH_REGS(state, regnum, count) \
  memcpy (&deprecated_registers[REGISTER_BYTE (regnum)], \
	  (char *)state+reg_offset[ regnum ], \
	  count*REGISTER_SIZE)

/* Store COUNT contiguous registers to thread STATE starting from REGNUM */
#define STORE_REGS(state, regnum, count) \
  memcpy ((char *)state+reg_offset[ regnum ], \
	  &deprecated_registers[REGISTER_BYTE (regnum)], \
	  count*REGISTER_SIZE)

#define REGS_ALL    -1
#define REGS_NORMAL  1
#define REGS_EXC     2
#define REGS_COP1    4

/* Hardware regs that matches FP_REGNUM */
#define MACH_FP_REGNUM 30

/* Fech thread's registers. if regno == -1, fetch all regs */
void
fetch_inferior_registers (int regno)
{
  kern_return_t ret;

  thread_state_data_t state;
  struct mips_exc_state exc_state;

  int stateCnt = MIPS_THREAD_STATE_COUNT;

  int which_regs = 0;		/* A bit mask */

  if (!MACH_PORT_VALID (current_thread))
    error ("fetch inferior registers: Invalid thread");

  if (regno < -1 || regno >= NUM_REGS)
    error ("invalid register %d supplied to fetch_inferior_registers", regno);

  if (regno == -1)
    which_regs = REGS_ALL;
  else if (regno == ZERO_REGNUM)
    {
      int zero = 0;
      supply_register (ZERO_REGNUM, &zero);
      return;
    }
  else if ((ZERO_REGNUM < regno && regno < PS_REGNUM)
	   || regno == FP_REGNUM
	   || regno == LO_REGNUM
	   || regno == HI_REGNUM
	   || regno == PC_REGNUM)
    which_regs = REGS_NORMAL;
  else if (FP0_REGNUM <= regno && regno <= FCRIR_REGNUM)
    which_regs = REGS_COP1 | REGS_EXC;
  else
    which_regs = REGS_EXC;

  /* fetch regs saved to mips_thread_state */
  if (which_regs & REGS_NORMAL)
    {
      ret = thread_get_state (current_thread,
			      MIPS_THREAD_STATE,
			      state,
			      &stateCnt);
      CHK ("fetch inferior registers: thread_get_state", ret);

      if (which_regs == REGS_NORMAL)
	{
	  /* Fetch also FP_REGNUM if fetching MACH_FP_REGNUM and vice versa */
	  if (regno == MACH_FP_REGNUM || regno == FP_REGNUM)
	    {
	      supply_register (FP_REGNUM,
			       (char *) state + reg_offset[MACH_FP_REGNUM]);
	      supply_register (MACH_FP_REGNUM,
			       (char *) state + reg_offset[MACH_FP_REGNUM]);
	    }
	  else
	    supply_register (regno,
			     (char *) state + reg_offset[regno]);
	  return;
	}

      /* ZERO_REGNUM is always zero */
      *(int *) deprecated_registers = 0;

      /* Copy thread saved regs 1..31 to gdb's reg value array
       * Luckily, they are contiquous
       */
      FETCH_REGS (state, 1, 31);

      /* Copy mdlo and mdhi */
      FETCH_REGS (state, LO_REGNUM, 2);

      /* Copy PC */
      FETCH_REGS (state, PC_REGNUM, 1);

      /* Mach 3.0 saves FP to MACH_FP_REGNUM.
       * For some reason gdb wants to assign a pseudo register for it.
       */
      FETCH_REGS (state, FP_REGNUM, 1);
    }

  /* Read exc state. Also read if need to fetch floats */
  if (which_regs & REGS_EXC)
    {
      stateCnt = MIPS_EXC_STATE_COUNT;
      ret = thread_get_state (current_thread,
			      MIPS_EXC_STATE,
			      (thread_state_t) & exc_state,
			      &stateCnt);
      CHK ("fetch inferior regs (exc): thread_get_state", ret);

      /* We need to fetch exc_state to see if the floating
       * state is valid for the thread.
       */

      /* cproc_state: Which coprocessors the thread uses */
      supply_register (PS_REGNUM,
		       (char *) &exc_state + reg_offset[PS_REGNUM]);

      if (which_regs == REGS_EXC || which_regs == REGS_ALL)
	{
	  supply_register (BADVADDR_REGNUM,
			 (char *) &exc_state + reg_offset[BADVADDR_REGNUM]);

	  supply_register (CAUSE_REGNUM,
			   (char *) &exc_state + reg_offset[CAUSE_REGNUM]);
	  if (which_regs == REGS_EXC)
	    return;
	}
    }


  if (which_regs & REGS_COP1)
    {
      /* If the thread does not have saved COPROC1, set regs to zero */

      if (!(exc_state.coproc_state & MIPS_STATUS_USE_COP1))
	bzero (&deprecated_registers[REGISTER_BYTE (FP0_REGNUM)],
	       sizeof (struct mips_float_state));
      else
	{
	  stateCnt = MIPS_FLOAT_STATE_COUNT;
	  ret = thread_get_state (current_thread,
				  MIPS_FLOAT_STATE,
				  state,
				  &stateCnt);
	  CHK ("fetch inferior regs (floats): thread_get_state", ret);

	  if (regno != -1)
	    {
	      supply_register (regno,
			       (char *) state + reg_offset[regno]);
	      return;
	    }

	  FETCH_REGS (state, FP0_REGNUM, 34);
	}
    }

  /* All registers are valid, if not returned yet */
  deprecated_registers_fetched ();
}

/* Store gdb's view of registers to the thread.
 * All registers are always valid when entering here.
 * @@@@ ahem, maybe that is too strict, we could validate the necessary ones
 *    here.
 *
 * Hmm. It seems that gdb set $reg=value command first reads everything,
 * then sets the reg and then stores everything. -> we must make sure
 * that the immutable registers are not changed by reading them first.
 */

void
store_inferior_registers (register int regno)
{
  thread_state_data_t state;
  kern_return_t ret;

  if (!MACH_PORT_VALID (current_thread))
    error ("store inferior registers: Invalid thread");

  /* Check for read only regs.
   * @@@@ If some of these is can be changed, fix this
   */
  if (regno == ZERO_REGNUM ||
      regno == PS_REGNUM ||
      regno == BADVADDR_REGNUM ||
      regno == CAUSE_REGNUM ||
      regno == FCRIR_REGNUM)
    {
      message ("You can not alter read-only register `%s'",
	       REGISTER_NAME (regno));
      fetch_inferior_registers (regno);
      return;
    }

  if (regno == -1)
    {
      /* Don't allow these to change */

      /* ZERO_REGNUM */
      *(int *) deprecated_registers = 0;

      fetch_inferior_registers (PS_REGNUM);
      fetch_inferior_registers (BADVADDR_REGNUM);
      fetch_inferior_registers (CAUSE_REGNUM);
      fetch_inferior_registers (FCRIR_REGNUM);
    }

  if (regno == -1 || (ZERO_REGNUM < regno && regno <= PC_REGNUM))
    {
#if 1
      /* Mach 3.0 saves thread's FP to MACH_FP_REGNUM.
       * GDB wants assigns a pseudo register FP_REGNUM for frame pointer.
       *
       * @@@@@@ Here I assume (!) that gdb's FP has the value that
       *     should go to threads frame pointer. If not true, this
       *     fails badly!!!!!
       */
      memcpy (&deprecated_registers[REGISTER_BYTE (MACH_FP_REGNUM)],
	      &deprecated_registers[REGISTER_BYTE (FP_REGNUM)],
	      REGISTER_RAW_SIZE (FP_REGNUM));
#endif

      /* Save gdb's regs 1..31 to thread saved regs 1..31
       * Luckily, they are contiquous
       */
      STORE_REGS (state, 1, 31);

      /* Save mdlo, mdhi */
      STORE_REGS (state, LO_REGNUM, 2);

      /* Save PC */
      STORE_REGS (state, PC_REGNUM, 1);

      ret = thread_set_state (current_thread,
			      MIPS_THREAD_STATE,
			      state,
			      MIPS_FLOAT_STATE_COUNT);
      CHK ("store inferior regs : thread_set_state", ret);
    }

  if (regno == -1 || regno >= FP0_REGNUM)
    {
      /* If thread has floating state, save it */
      if (read_register (PS_REGNUM) & MIPS_STATUS_USE_COP1)
	{
	  /* Do NOT save FCRIR_REGNUM */
	  STORE_REGS (state, FP0_REGNUM, 33);

	  ret = thread_set_state (current_thread,
				  MIPS_FLOAT_STATE,
				  state,
				  MIPS_FLOAT_STATE_COUNT);
	  CHK ("store inferior registers (floats): thread_set_state", ret);
	}
      else if (regno != -1)
	message
	  ("Thread does not use floating point unit, floating regs not saved");
    }
}
@


1.6.16.1
log
@Merge with mainline.
@
text
@d1 386
a386 386
// OBSOLETE /* Definitions to make GDB run on a mips box under Mach 3.0
// OBSOLETE    Copyright 1992, 1993, 1998, 2000, 2001 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /* Mach specific routines for little endian mips (e.g. pmax)
// OBSOLETE  * running Mach 3.0
// OBSOLETE  *
// OBSOLETE  * Author: Jukka Virtanen <jtv@@hut.fi>
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #include <stdio.h>
// OBSOLETE 
// OBSOLETE #include <mach.h>
// OBSOLETE #include <mach/message.h>
// OBSOLETE #include <mach/exception.h>
// OBSOLETE #include <mach_error.h>
// OBSOLETE 
// OBSOLETE /* Find offsets to thread states at compile time.
// OBSOLETE  * If your compiler does not grok this, check the hand coded
// OBSOLETE  * offsets and use them.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #if 1
// OBSOLETE 
// OBSOLETE #define  REG_OFFSET(reg) (int)(&((struct mips_thread_state *)0)->reg)
// OBSOLETE #define CREG_OFFSET(reg) (int)(&((struct mips_float_state *)0)->reg)
// OBSOLETE #define EREG_OFFSET(reg) (int)(&((struct mips_exc_state *)0)->reg)
// OBSOLETE 
// OBSOLETE /* at reg_offset[i] is the offset to the mips_thread_state
// OBSOLETE  * location where the gdb registers[i] is stored.
// OBSOLETE  *
// OBSOLETE  * -1 means mach does not save it anywhere.
// OBSOLETE  */
// OBSOLETE static int reg_offset[] =
// OBSOLETE {
// OBSOLETE   /*  zero              at                v0                v1       */
// OBSOLETE   -1, REG_OFFSET (r1), REG_OFFSET (r2), REG_OFFSET (r3),
// OBSOLETE 
// OBSOLETE   /*  a0                a1                a2                a3       */
// OBSOLETE   REG_OFFSET (r4), REG_OFFSET (r5), REG_OFFSET (r6), REG_OFFSET (r7),
// OBSOLETE 
// OBSOLETE   /*  t0                t1                t2                t3       */
// OBSOLETE   REG_OFFSET (r8), REG_OFFSET (r9), REG_OFFSET (r10), REG_OFFSET (r11),
// OBSOLETE 
// OBSOLETE   /*  t4                t5                t6                t7       */
// OBSOLETE   REG_OFFSET (r12), REG_OFFSET (r13), REG_OFFSET (r14), REG_OFFSET (r15),
// OBSOLETE 
// OBSOLETE   /*  s0                s1                s2                s3       */
// OBSOLETE   REG_OFFSET (r16), REG_OFFSET (r17), REG_OFFSET (r18), REG_OFFSET (r19),
// OBSOLETE 
// OBSOLETE   /*  s4                s5                s6                s7       */
// OBSOLETE   REG_OFFSET (r20), REG_OFFSET (r21), REG_OFFSET (r22), REG_OFFSET (r23),
// OBSOLETE 
// OBSOLETE   /*  t8                t9                k0                k1       */
// OBSOLETE   REG_OFFSET (r24), REG_OFFSET (r25), REG_OFFSET (r26), REG_OFFSET (r27),
// OBSOLETE 
// OBSOLETE   /*  gp                sp            s8(30) == fp(72)      ra       */
// OBSOLETE   REG_OFFSET (r28), REG_OFFSET (r29), REG_OFFSET (r30), REG_OFFSET (r31),
// OBSOLETE 
// OBSOLETE   /*  sr(32) PS_REGNUM   */
// OBSOLETE   EREG_OFFSET (coproc_state),
// OBSOLETE 
// OBSOLETE   /*  lo(33)            hi(34)    */
// OBSOLETE   REG_OFFSET (mdlo), REG_OFFSET (mdhi),
// OBSOLETE 
// OBSOLETE   /*  bad(35)                 cause(36)          pc(37)  */
// OBSOLETE   EREG_OFFSET (address), EREG_OFFSET (cause), REG_OFFSET (pc),
// OBSOLETE 
// OBSOLETE   /*  f0(38)             f1(39)             f2(40)             f3(41)   */
// OBSOLETE   CREG_OFFSET (r0), CREG_OFFSET (r1), CREG_OFFSET (r2), CREG_OFFSET (r3),
// OBSOLETE   CREG_OFFSET (r4), CREG_OFFSET (r5), CREG_OFFSET (r6), CREG_OFFSET (r7),
// OBSOLETE   CREG_OFFSET (r8), CREG_OFFSET (r9), CREG_OFFSET (r10), CREG_OFFSET (r11),
// OBSOLETE   CREG_OFFSET (r12), CREG_OFFSET (r13), CREG_OFFSET (r14), CREG_OFFSET (r15),
// OBSOLETE   CREG_OFFSET (r16), CREG_OFFSET (r17), CREG_OFFSET (r18), CREG_OFFSET (r19),
// OBSOLETE   CREG_OFFSET (r20), CREG_OFFSET (r21), CREG_OFFSET (r22), CREG_OFFSET (r23),
// OBSOLETE   CREG_OFFSET (r24), CREG_OFFSET (r25), CREG_OFFSET (r26), CREG_OFFSET (r27),
// OBSOLETE   CREG_OFFSET (r28), CREG_OFFSET (r29), CREG_OFFSET (r30), CREG_OFFSET (r31),
// OBSOLETE 
// OBSOLETE   /*  fsr(70)           fir(71)         fp(72) == s8(30) */
// OBSOLETE   CREG_OFFSET (csr), CREG_OFFSET (esr), REG_OFFSET (r30)
// OBSOLETE };
// OBSOLETE #else
// OBSOLETE /* If the compiler does not grok the above defines */
// OBSOLETE static int reg_offset[] =
// OBSOLETE {
// OBSOLETE /* mach_thread_state offsets: */
// OBSOLETE   -1, 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56,
// OBSOLETE   60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120,
// OBSOLETE /*sr, lo, hi,addr,cause,pc   */
// OBSOLETE   8, 124, 128, 4, 0, 132,
// OBSOLETE /* mach_float_state offsets: */
// OBSOLETE   0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60,
// OBSOLETE   64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124,
// OBSOLETE /*fsr,fir */
// OBSOLETE   128, 132,
// OBSOLETE /* FP_REGNUM pseudo maps to s8==r30 in mach_thread_state */
// OBSOLETE   116
// OBSOLETE };
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /* Fetch COUNT contiguous registers from thread STATE starting from REGNUM
// OBSOLETE  * Caller knows that the regs handled in one transaction are of same size.
// OBSOLETE  */
// OBSOLETE #define FETCH_REGS(state, regnum, count) \
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (regnum)], \
// OBSOLETE 	  (char *)state+reg_offset[ regnum ], \
// OBSOLETE 	  count*REGISTER_SIZE)
// OBSOLETE 
// OBSOLETE /* Store COUNT contiguous registers to thread STATE starting from REGNUM */
// OBSOLETE #define STORE_REGS(state, regnum, count) \
// OBSOLETE   memcpy ((char *)state+reg_offset[ regnum ], \
// OBSOLETE 	  &deprecated_registers[REGISTER_BYTE (regnum)], \
// OBSOLETE 	  count*REGISTER_SIZE)
// OBSOLETE 
// OBSOLETE #define REGS_ALL    -1
// OBSOLETE #define REGS_NORMAL  1
// OBSOLETE #define REGS_EXC     2
// OBSOLETE #define REGS_COP1    4
// OBSOLETE 
// OBSOLETE /* Hardware regs that matches FP_REGNUM */
// OBSOLETE #define MACH_FP_REGNUM 30
// OBSOLETE 
// OBSOLETE /* Fech thread's registers. if regno == -1, fetch all regs */
// OBSOLETE void
// OBSOLETE fetch_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   thread_state_data_t state;
// OBSOLETE   struct mips_exc_state exc_state;
// OBSOLETE 
// OBSOLETE   int stateCnt = MIPS_THREAD_STATE_COUNT;
// OBSOLETE 
// OBSOLETE   int which_regs = 0;		/* A bit mask */
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (current_thread))
// OBSOLETE     error ("fetch inferior registers: Invalid thread");
// OBSOLETE 
// OBSOLETE   if (regno < -1 || regno >= NUM_REGS)
// OBSOLETE     error ("invalid register %d supplied to fetch_inferior_registers", regno);
// OBSOLETE 
// OBSOLETE   if (regno == -1)
// OBSOLETE     which_regs = REGS_ALL;
// OBSOLETE   else if (regno == ZERO_REGNUM)
// OBSOLETE     {
// OBSOLETE       int zero = 0;
// OBSOLETE       supply_register (ZERO_REGNUM, &zero);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE   else if ((ZERO_REGNUM < regno && regno < PS_REGNUM)
// OBSOLETE 	   || regno == FP_REGNUM
// OBSOLETE 	   || regno == LO_REGNUM
// OBSOLETE 	   || regno == HI_REGNUM
// OBSOLETE 	   || regno == PC_REGNUM)
// OBSOLETE     which_regs = REGS_NORMAL;
// OBSOLETE   else if (FP0_REGNUM <= regno && regno <= FCRIR_REGNUM)
// OBSOLETE     which_regs = REGS_COP1 | REGS_EXC;
// OBSOLETE   else
// OBSOLETE     which_regs = REGS_EXC;
// OBSOLETE 
// OBSOLETE   /* fetch regs saved to mips_thread_state */
// OBSOLETE   if (which_regs & REGS_NORMAL)
// OBSOLETE     {
// OBSOLETE       ret = thread_get_state (current_thread,
// OBSOLETE 			      MIPS_THREAD_STATE,
// OBSOLETE 			      state,
// OBSOLETE 			      &stateCnt);
// OBSOLETE       CHK ("fetch inferior registers: thread_get_state", ret);
// OBSOLETE 
// OBSOLETE       if (which_regs == REGS_NORMAL)
// OBSOLETE 	{
// OBSOLETE 	  /* Fetch also FP_REGNUM if fetching MACH_FP_REGNUM and vice versa */
// OBSOLETE 	  if (regno == MACH_FP_REGNUM || regno == FP_REGNUM)
// OBSOLETE 	    {
// OBSOLETE 	      supply_register (FP_REGNUM,
// OBSOLETE 			       (char *) state + reg_offset[MACH_FP_REGNUM]);
// OBSOLETE 	      supply_register (MACH_FP_REGNUM,
// OBSOLETE 			       (char *) state + reg_offset[MACH_FP_REGNUM]);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    supply_register (regno,
// OBSOLETE 			     (char *) state + reg_offset[regno]);
// OBSOLETE 	  return;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* ZERO_REGNUM is always zero */
// OBSOLETE       *(int *) deprecated_registers = 0;
// OBSOLETE 
// OBSOLETE       /* Copy thread saved regs 1..31 to gdb's reg value array
// OBSOLETE        * Luckily, they are contiquous
// OBSOLETE        */
// OBSOLETE       FETCH_REGS (state, 1, 31);
// OBSOLETE 
// OBSOLETE       /* Copy mdlo and mdhi */
// OBSOLETE       FETCH_REGS (state, LO_REGNUM, 2);
// OBSOLETE 
// OBSOLETE       /* Copy PC */
// OBSOLETE       FETCH_REGS (state, PC_REGNUM, 1);
// OBSOLETE 
// OBSOLETE       /* Mach 3.0 saves FP to MACH_FP_REGNUM.
// OBSOLETE        * For some reason gdb wants to assign a pseudo register for it.
// OBSOLETE        */
// OBSOLETE       FETCH_REGS (state, FP_REGNUM, 1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Read exc state. Also read if need to fetch floats */
// OBSOLETE   if (which_regs & REGS_EXC)
// OBSOLETE     {
// OBSOLETE       stateCnt = MIPS_EXC_STATE_COUNT;
// OBSOLETE       ret = thread_get_state (current_thread,
// OBSOLETE 			      MIPS_EXC_STATE,
// OBSOLETE 			      (thread_state_t) & exc_state,
// OBSOLETE 			      &stateCnt);
// OBSOLETE       CHK ("fetch inferior regs (exc): thread_get_state", ret);
// OBSOLETE 
// OBSOLETE       /* We need to fetch exc_state to see if the floating
// OBSOLETE        * state is valid for the thread.
// OBSOLETE        */
// OBSOLETE 
// OBSOLETE       /* cproc_state: Which coprocessors the thread uses */
// OBSOLETE       supply_register (PS_REGNUM,
// OBSOLETE 		       (char *) &exc_state + reg_offset[PS_REGNUM]);
// OBSOLETE 
// OBSOLETE       if (which_regs == REGS_EXC || which_regs == REGS_ALL)
// OBSOLETE 	{
// OBSOLETE 	  supply_register (BADVADDR_REGNUM,
// OBSOLETE 			 (char *) &exc_state + reg_offset[BADVADDR_REGNUM]);
// OBSOLETE 
// OBSOLETE 	  supply_register (CAUSE_REGNUM,
// OBSOLETE 			   (char *) &exc_state + reg_offset[CAUSE_REGNUM]);
// OBSOLETE 	  if (which_regs == REGS_EXC)
// OBSOLETE 	    return;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   if (which_regs & REGS_COP1)
// OBSOLETE     {
// OBSOLETE       /* If the thread does not have saved COPROC1, set regs to zero */
// OBSOLETE 
// OBSOLETE       if (!(exc_state.coproc_state & MIPS_STATUS_USE_COP1))
// OBSOLETE 	bzero (&deprecated_registers[REGISTER_BYTE (FP0_REGNUM)],
// OBSOLETE 	       sizeof (struct mips_float_state));
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  stateCnt = MIPS_FLOAT_STATE_COUNT;
// OBSOLETE 	  ret = thread_get_state (current_thread,
// OBSOLETE 				  MIPS_FLOAT_STATE,
// OBSOLETE 				  state,
// OBSOLETE 				  &stateCnt);
// OBSOLETE 	  CHK ("fetch inferior regs (floats): thread_get_state", ret);
// OBSOLETE 
// OBSOLETE 	  if (regno != -1)
// OBSOLETE 	    {
// OBSOLETE 	      supply_register (regno,
// OBSOLETE 			       (char *) state + reg_offset[regno]);
// OBSOLETE 	      return;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  FETCH_REGS (state, FP0_REGNUM, 34);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* All registers are valid, if not returned yet */
// OBSOLETE   deprecated_registers_fetched ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store gdb's view of registers to the thread.
// OBSOLETE  * All registers are always valid when entering here.
// OBSOLETE  * @@@@ ahem, maybe that is too strict, we could validate the necessary ones
// OBSOLETE  *    here.
// OBSOLETE  *
// OBSOLETE  * Hmm. It seems that gdb set $reg=value command first reads everything,
// OBSOLETE  * then sets the reg and then stores everything. -> we must make sure
// OBSOLETE  * that the immutable registers are not changed by reading them first.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE store_inferior_registers (register int regno)
// OBSOLETE {
// OBSOLETE   thread_state_data_t state;
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (current_thread))
// OBSOLETE     error ("store inferior registers: Invalid thread");
// OBSOLETE 
// OBSOLETE   /* Check for read only regs.
// OBSOLETE    * @@@@ If some of these is can be changed, fix this
// OBSOLETE    */
// OBSOLETE   if (regno == ZERO_REGNUM ||
// OBSOLETE       regno == PS_REGNUM ||
// OBSOLETE       regno == BADVADDR_REGNUM ||
// OBSOLETE       regno == CAUSE_REGNUM ||
// OBSOLETE       regno == FCRIR_REGNUM)
// OBSOLETE     {
// OBSOLETE       message ("You can not alter read-only register `%s'",
// OBSOLETE 	       REGISTER_NAME (regno));
// OBSOLETE       fetch_inferior_registers (regno);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (regno == -1)
// OBSOLETE     {
// OBSOLETE       /* Don't allow these to change */
// OBSOLETE 
// OBSOLETE       /* ZERO_REGNUM */
// OBSOLETE       *(int *) deprecated_registers = 0;
// OBSOLETE 
// OBSOLETE       fetch_inferior_registers (PS_REGNUM);
// OBSOLETE       fetch_inferior_registers (BADVADDR_REGNUM);
// OBSOLETE       fetch_inferior_registers (CAUSE_REGNUM);
// OBSOLETE       fetch_inferior_registers (FCRIR_REGNUM);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (regno == -1 || (ZERO_REGNUM < regno && regno <= PC_REGNUM))
// OBSOLETE     {
// OBSOLETE #if 1
// OBSOLETE       /* Mach 3.0 saves thread's FP to MACH_FP_REGNUM.
// OBSOLETE        * GDB wants assigns a pseudo register FP_REGNUM for frame pointer.
// OBSOLETE        *
// OBSOLETE        * @@@@@@ Here I assume (!) that gdb's FP has the value that
// OBSOLETE        *     should go to threads frame pointer. If not true, this
// OBSOLETE        *     fails badly!!!!!
// OBSOLETE        */
// OBSOLETE       memcpy (&deprecated_registers[REGISTER_BYTE (MACH_FP_REGNUM)],
// OBSOLETE 	      &deprecated_registers[REGISTER_BYTE (FP_REGNUM)],
// OBSOLETE 	      REGISTER_RAW_SIZE (FP_REGNUM));
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE       /* Save gdb's regs 1..31 to thread saved regs 1..31
// OBSOLETE        * Luckily, they are contiquous
// OBSOLETE        */
// OBSOLETE       STORE_REGS (state, 1, 31);
// OBSOLETE 
// OBSOLETE       /* Save mdlo, mdhi */
// OBSOLETE       STORE_REGS (state, LO_REGNUM, 2);
// OBSOLETE 
// OBSOLETE       /* Save PC */
// OBSOLETE       STORE_REGS (state, PC_REGNUM, 1);
// OBSOLETE 
// OBSOLETE       ret = thread_set_state (current_thread,
// OBSOLETE 			      MIPS_THREAD_STATE,
// OBSOLETE 			      state,
// OBSOLETE 			      MIPS_FLOAT_STATE_COUNT);
// OBSOLETE       CHK ("store inferior regs : thread_set_state", ret);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (regno == -1 || regno >= FP0_REGNUM)
// OBSOLETE     {
// OBSOLETE       /* If thread has floating state, save it */
// OBSOLETE       if (read_register (PS_REGNUM) & MIPS_STATUS_USE_COP1)
// OBSOLETE 	{
// OBSOLETE 	  /* Do NOT save FCRIR_REGNUM */
// OBSOLETE 	  STORE_REGS (state, FP0_REGNUM, 33);
// OBSOLETE 
// OBSOLETE 	  ret = thread_set_state (current_thread,
// OBSOLETE 				  MIPS_FLOAT_STATE,
// OBSOLETE 				  state,
// OBSOLETE 				  MIPS_FLOAT_STATE_COUNT);
// OBSOLETE 	  CHK ("store inferior registers (floats): thread_set_state", ret);
// OBSOLETE 	}
// OBSOLETE       else if (regno != -1)
// OBSOLETE 	message
// OBSOLETE 	  ("Thread does not use floating point unit, floating regs not saved");
// OBSOLETE     }
// OBSOLETE }
@


1.5
log
@2002-11-07  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.c (deprecated_registers_fetched): Update.
	* regcache.h (deprecated_registers_fetched): Rename
	registers_fetched.
	* remote-vxsparc.c (vx_read_register): Update.
	* remote-vxmips.c (vx_read_register): Update.
	* remote-vx68.c (vx_read_register): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* mipsm3-nat.c (fetch_inferior_registers): Update.
	* sun3-nat.c (fetch_inferior_registers): Update.
	* symm-nat.c (fetch_inferior_registers): Update.
	* ns32knbsd-nat.c (fetch_inferior_registers): Update.
	(fetch_core_registers): Update.
	(fetch_kcore_registers): Update.
	* mips-nat.c (fetch_inferior_registers): Update.
	* corelow.c (get_core_registers): Update.
	* a68v-nat.c (fetch_inferior_registers): Update.
@
text
@d125 1
a125 1
  memcpy (&registers[REGISTER_BYTE (regnum)], \
d132 1
a132 1
	  &registers[REGISTER_BYTE (regnum)], \
d207 1
a207 1
      *(int *) registers = 0;
d262 1
a262 1
	bzero (&registers[REGISTER_BYTE (FP0_REGNUM)],
d327 1
a327 1
      *(int *) registers = 0;
d345 2
a346 2
      memcpy (&registers[REGISTER_BYTE (MACH_FP_REGNUM)],
	      &registers[REGISTER_BYTE (FP_REGNUM)],
@


1.4
log
@Update/correct copyright notices.
@
text
@d285 1
a285 1
  registers_fetched ();
@


1.4.26.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.4.24.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d125 1
a125 1
  memcpy (&deprecated_registers[REGISTER_BYTE (regnum)], \
d132 1
a132 1
	  &deprecated_registers[REGISTER_BYTE (regnum)], \
d207 1
a207 1
      *(int *) deprecated_registers = 0;
d262 1
a262 1
	bzero (&deprecated_registers[REGISTER_BYTE (FP0_REGNUM)],
d285 1
a285 1
  deprecated_registers_fetched ();
d327 1
a327 1
      *(int *) deprecated_registers = 0;
d345 2
a346 2
      memcpy (&deprecated_registers[REGISTER_BYTE (MACH_FP_REGNUM)],
	      &deprecated_registers[REGISTER_BYTE (FP_REGNUM)],
@


1.4.24.2
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d1 386
a386 386
// OBSOLETE /* Definitions to make GDB run on a mips box under Mach 3.0
// OBSOLETE    Copyright 1992, 1993, 1998, 2000, 2001 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /* Mach specific routines for little endian mips (e.g. pmax)
// OBSOLETE  * running Mach 3.0
// OBSOLETE  *
// OBSOLETE  * Author: Jukka Virtanen <jtv@@hut.fi>
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #include <stdio.h>
// OBSOLETE 
// OBSOLETE #include <mach.h>
// OBSOLETE #include <mach/message.h>
// OBSOLETE #include <mach/exception.h>
// OBSOLETE #include <mach_error.h>
// OBSOLETE 
// OBSOLETE /* Find offsets to thread states at compile time.
// OBSOLETE  * If your compiler does not grok this, check the hand coded
// OBSOLETE  * offsets and use them.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #if 1
// OBSOLETE 
// OBSOLETE #define  REG_OFFSET(reg) (int)(&((struct mips_thread_state *)0)->reg)
// OBSOLETE #define CREG_OFFSET(reg) (int)(&((struct mips_float_state *)0)->reg)
// OBSOLETE #define EREG_OFFSET(reg) (int)(&((struct mips_exc_state *)0)->reg)
// OBSOLETE 
// OBSOLETE /* at reg_offset[i] is the offset to the mips_thread_state
// OBSOLETE  * location where the gdb registers[i] is stored.
// OBSOLETE  *
// OBSOLETE  * -1 means mach does not save it anywhere.
// OBSOLETE  */
// OBSOLETE static int reg_offset[] =
// OBSOLETE {
// OBSOLETE   /*  zero              at                v0                v1       */
// OBSOLETE   -1, REG_OFFSET (r1), REG_OFFSET (r2), REG_OFFSET (r3),
// OBSOLETE 
// OBSOLETE   /*  a0                a1                a2                a3       */
// OBSOLETE   REG_OFFSET (r4), REG_OFFSET (r5), REG_OFFSET (r6), REG_OFFSET (r7),
// OBSOLETE 
// OBSOLETE   /*  t0                t1                t2                t3       */
// OBSOLETE   REG_OFFSET (r8), REG_OFFSET (r9), REG_OFFSET (r10), REG_OFFSET (r11),
// OBSOLETE 
// OBSOLETE   /*  t4                t5                t6                t7       */
// OBSOLETE   REG_OFFSET (r12), REG_OFFSET (r13), REG_OFFSET (r14), REG_OFFSET (r15),
// OBSOLETE 
// OBSOLETE   /*  s0                s1                s2                s3       */
// OBSOLETE   REG_OFFSET (r16), REG_OFFSET (r17), REG_OFFSET (r18), REG_OFFSET (r19),
// OBSOLETE 
// OBSOLETE   /*  s4                s5                s6                s7       */
// OBSOLETE   REG_OFFSET (r20), REG_OFFSET (r21), REG_OFFSET (r22), REG_OFFSET (r23),
// OBSOLETE 
// OBSOLETE   /*  t8                t9                k0                k1       */
// OBSOLETE   REG_OFFSET (r24), REG_OFFSET (r25), REG_OFFSET (r26), REG_OFFSET (r27),
// OBSOLETE 
// OBSOLETE   /*  gp                sp            s8(30) == fp(72)      ra       */
// OBSOLETE   REG_OFFSET (r28), REG_OFFSET (r29), REG_OFFSET (r30), REG_OFFSET (r31),
// OBSOLETE 
// OBSOLETE   /*  sr(32) PS_REGNUM   */
// OBSOLETE   EREG_OFFSET (coproc_state),
// OBSOLETE 
// OBSOLETE   /*  lo(33)            hi(34)    */
// OBSOLETE   REG_OFFSET (mdlo), REG_OFFSET (mdhi),
// OBSOLETE 
// OBSOLETE   /*  bad(35)                 cause(36)          pc(37)  */
// OBSOLETE   EREG_OFFSET (address), EREG_OFFSET (cause), REG_OFFSET (pc),
// OBSOLETE 
// OBSOLETE   /*  f0(38)             f1(39)             f2(40)             f3(41)   */
// OBSOLETE   CREG_OFFSET (r0), CREG_OFFSET (r1), CREG_OFFSET (r2), CREG_OFFSET (r3),
// OBSOLETE   CREG_OFFSET (r4), CREG_OFFSET (r5), CREG_OFFSET (r6), CREG_OFFSET (r7),
// OBSOLETE   CREG_OFFSET (r8), CREG_OFFSET (r9), CREG_OFFSET (r10), CREG_OFFSET (r11),
// OBSOLETE   CREG_OFFSET (r12), CREG_OFFSET (r13), CREG_OFFSET (r14), CREG_OFFSET (r15),
// OBSOLETE   CREG_OFFSET (r16), CREG_OFFSET (r17), CREG_OFFSET (r18), CREG_OFFSET (r19),
// OBSOLETE   CREG_OFFSET (r20), CREG_OFFSET (r21), CREG_OFFSET (r22), CREG_OFFSET (r23),
// OBSOLETE   CREG_OFFSET (r24), CREG_OFFSET (r25), CREG_OFFSET (r26), CREG_OFFSET (r27),
// OBSOLETE   CREG_OFFSET (r28), CREG_OFFSET (r29), CREG_OFFSET (r30), CREG_OFFSET (r31),
// OBSOLETE 
// OBSOLETE   /*  fsr(70)           fir(71)         fp(72) == s8(30) */
// OBSOLETE   CREG_OFFSET (csr), CREG_OFFSET (esr), REG_OFFSET (r30)
// OBSOLETE };
// OBSOLETE #else
// OBSOLETE /* If the compiler does not grok the above defines */
// OBSOLETE static int reg_offset[] =
// OBSOLETE {
// OBSOLETE /* mach_thread_state offsets: */
// OBSOLETE   -1, 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56,
// OBSOLETE   60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120,
// OBSOLETE /*sr, lo, hi,addr,cause,pc   */
// OBSOLETE   8, 124, 128, 4, 0, 132,
// OBSOLETE /* mach_float_state offsets: */
// OBSOLETE   0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60,
// OBSOLETE   64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124,
// OBSOLETE /*fsr,fir */
// OBSOLETE   128, 132,
// OBSOLETE /* FP_REGNUM pseudo maps to s8==r30 in mach_thread_state */
// OBSOLETE   116
// OBSOLETE };
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /* Fetch COUNT contiguous registers from thread STATE starting from REGNUM
// OBSOLETE  * Caller knows that the regs handled in one transaction are of same size.
// OBSOLETE  */
// OBSOLETE #define FETCH_REGS(state, regnum, count) \
// OBSOLETE   memcpy (&deprecated_registers[REGISTER_BYTE (regnum)], \
// OBSOLETE 	  (char *)state+reg_offset[ regnum ], \
// OBSOLETE 	  count*REGISTER_SIZE)
// OBSOLETE 
// OBSOLETE /* Store COUNT contiguous registers to thread STATE starting from REGNUM */
// OBSOLETE #define STORE_REGS(state, regnum, count) \
// OBSOLETE   memcpy ((char *)state+reg_offset[ regnum ], \
// OBSOLETE 	  &deprecated_registers[REGISTER_BYTE (regnum)], \
// OBSOLETE 	  count*REGISTER_SIZE)
// OBSOLETE 
// OBSOLETE #define REGS_ALL    -1
// OBSOLETE #define REGS_NORMAL  1
// OBSOLETE #define REGS_EXC     2
// OBSOLETE #define REGS_COP1    4
// OBSOLETE 
// OBSOLETE /* Hardware regs that matches FP_REGNUM */
// OBSOLETE #define MACH_FP_REGNUM 30
// OBSOLETE 
// OBSOLETE /* Fech thread's registers. if regno == -1, fetch all regs */
// OBSOLETE void
// OBSOLETE fetch_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   thread_state_data_t state;
// OBSOLETE   struct mips_exc_state exc_state;
// OBSOLETE 
// OBSOLETE   int stateCnt = MIPS_THREAD_STATE_COUNT;
// OBSOLETE 
// OBSOLETE   int which_regs = 0;		/* A bit mask */
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (current_thread))
// OBSOLETE     error ("fetch inferior registers: Invalid thread");
// OBSOLETE 
// OBSOLETE   if (regno < -1 || regno >= NUM_REGS)
// OBSOLETE     error ("invalid register %d supplied to fetch_inferior_registers", regno);
// OBSOLETE 
// OBSOLETE   if (regno == -1)
// OBSOLETE     which_regs = REGS_ALL;
// OBSOLETE   else if (regno == ZERO_REGNUM)
// OBSOLETE     {
// OBSOLETE       int zero = 0;
// OBSOLETE       supply_register (ZERO_REGNUM, &zero);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE   else if ((ZERO_REGNUM < regno && regno < PS_REGNUM)
// OBSOLETE 	   || regno == FP_REGNUM
// OBSOLETE 	   || regno == LO_REGNUM
// OBSOLETE 	   || regno == HI_REGNUM
// OBSOLETE 	   || regno == PC_REGNUM)
// OBSOLETE     which_regs = REGS_NORMAL;
// OBSOLETE   else if (FP0_REGNUM <= regno && regno <= FCRIR_REGNUM)
// OBSOLETE     which_regs = REGS_COP1 | REGS_EXC;
// OBSOLETE   else
// OBSOLETE     which_regs = REGS_EXC;
// OBSOLETE 
// OBSOLETE   /* fetch regs saved to mips_thread_state */
// OBSOLETE   if (which_regs & REGS_NORMAL)
// OBSOLETE     {
// OBSOLETE       ret = thread_get_state (current_thread,
// OBSOLETE 			      MIPS_THREAD_STATE,
// OBSOLETE 			      state,
// OBSOLETE 			      &stateCnt);
// OBSOLETE       CHK ("fetch inferior registers: thread_get_state", ret);
// OBSOLETE 
// OBSOLETE       if (which_regs == REGS_NORMAL)
// OBSOLETE 	{
// OBSOLETE 	  /* Fetch also FP_REGNUM if fetching MACH_FP_REGNUM and vice versa */
// OBSOLETE 	  if (regno == MACH_FP_REGNUM || regno == FP_REGNUM)
// OBSOLETE 	    {
// OBSOLETE 	      supply_register (FP_REGNUM,
// OBSOLETE 			       (char *) state + reg_offset[MACH_FP_REGNUM]);
// OBSOLETE 	      supply_register (MACH_FP_REGNUM,
// OBSOLETE 			       (char *) state + reg_offset[MACH_FP_REGNUM]);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    supply_register (regno,
// OBSOLETE 			     (char *) state + reg_offset[regno]);
// OBSOLETE 	  return;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* ZERO_REGNUM is always zero */
// OBSOLETE       *(int *) deprecated_registers = 0;
// OBSOLETE 
// OBSOLETE       /* Copy thread saved regs 1..31 to gdb's reg value array
// OBSOLETE        * Luckily, they are contiquous
// OBSOLETE        */
// OBSOLETE       FETCH_REGS (state, 1, 31);
// OBSOLETE 
// OBSOLETE       /* Copy mdlo and mdhi */
// OBSOLETE       FETCH_REGS (state, LO_REGNUM, 2);
// OBSOLETE 
// OBSOLETE       /* Copy PC */
// OBSOLETE       FETCH_REGS (state, PC_REGNUM, 1);
// OBSOLETE 
// OBSOLETE       /* Mach 3.0 saves FP to MACH_FP_REGNUM.
// OBSOLETE        * For some reason gdb wants to assign a pseudo register for it.
// OBSOLETE        */
// OBSOLETE       FETCH_REGS (state, FP_REGNUM, 1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Read exc state. Also read if need to fetch floats */
// OBSOLETE   if (which_regs & REGS_EXC)
// OBSOLETE     {
// OBSOLETE       stateCnt = MIPS_EXC_STATE_COUNT;
// OBSOLETE       ret = thread_get_state (current_thread,
// OBSOLETE 			      MIPS_EXC_STATE,
// OBSOLETE 			      (thread_state_t) & exc_state,
// OBSOLETE 			      &stateCnt);
// OBSOLETE       CHK ("fetch inferior regs (exc): thread_get_state", ret);
// OBSOLETE 
// OBSOLETE       /* We need to fetch exc_state to see if the floating
// OBSOLETE        * state is valid for the thread.
// OBSOLETE        */
// OBSOLETE 
// OBSOLETE       /* cproc_state: Which coprocessors the thread uses */
// OBSOLETE       supply_register (PS_REGNUM,
// OBSOLETE 		       (char *) &exc_state + reg_offset[PS_REGNUM]);
// OBSOLETE 
// OBSOLETE       if (which_regs == REGS_EXC || which_regs == REGS_ALL)
// OBSOLETE 	{
// OBSOLETE 	  supply_register (BADVADDR_REGNUM,
// OBSOLETE 			 (char *) &exc_state + reg_offset[BADVADDR_REGNUM]);
// OBSOLETE 
// OBSOLETE 	  supply_register (CAUSE_REGNUM,
// OBSOLETE 			   (char *) &exc_state + reg_offset[CAUSE_REGNUM]);
// OBSOLETE 	  if (which_regs == REGS_EXC)
// OBSOLETE 	    return;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   if (which_regs & REGS_COP1)
// OBSOLETE     {
// OBSOLETE       /* If the thread does not have saved COPROC1, set regs to zero */
// OBSOLETE 
// OBSOLETE       if (!(exc_state.coproc_state & MIPS_STATUS_USE_COP1))
// OBSOLETE 	bzero (&deprecated_registers[REGISTER_BYTE (FP0_REGNUM)],
// OBSOLETE 	       sizeof (struct mips_float_state));
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  stateCnt = MIPS_FLOAT_STATE_COUNT;
// OBSOLETE 	  ret = thread_get_state (current_thread,
// OBSOLETE 				  MIPS_FLOAT_STATE,
// OBSOLETE 				  state,
// OBSOLETE 				  &stateCnt);
// OBSOLETE 	  CHK ("fetch inferior regs (floats): thread_get_state", ret);
// OBSOLETE 
// OBSOLETE 	  if (regno != -1)
// OBSOLETE 	    {
// OBSOLETE 	      supply_register (regno,
// OBSOLETE 			       (char *) state + reg_offset[regno]);
// OBSOLETE 	      return;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  FETCH_REGS (state, FP0_REGNUM, 34);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* All registers are valid, if not returned yet */
// OBSOLETE   deprecated_registers_fetched ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store gdb's view of registers to the thread.
// OBSOLETE  * All registers are always valid when entering here.
// OBSOLETE  * @@@@ ahem, maybe that is too strict, we could validate the necessary ones
// OBSOLETE  *    here.
// OBSOLETE  *
// OBSOLETE  * Hmm. It seems that gdb set $reg=value command first reads everything,
// OBSOLETE  * then sets the reg and then stores everything. -> we must make sure
// OBSOLETE  * that the immutable registers are not changed by reading them first.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE store_inferior_registers (register int regno)
// OBSOLETE {
// OBSOLETE   thread_state_data_t state;
// OBSOLETE   kern_return_t ret;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (current_thread))
// OBSOLETE     error ("store inferior registers: Invalid thread");
// OBSOLETE 
// OBSOLETE   /* Check for read only regs.
// OBSOLETE    * @@@@ If some of these is can be changed, fix this
// OBSOLETE    */
// OBSOLETE   if (regno == ZERO_REGNUM ||
// OBSOLETE       regno == PS_REGNUM ||
// OBSOLETE       regno == BADVADDR_REGNUM ||
// OBSOLETE       regno == CAUSE_REGNUM ||
// OBSOLETE       regno == FCRIR_REGNUM)
// OBSOLETE     {
// OBSOLETE       message ("You can not alter read-only register `%s'",
// OBSOLETE 	       REGISTER_NAME (regno));
// OBSOLETE       fetch_inferior_registers (regno);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (regno == -1)
// OBSOLETE     {
// OBSOLETE       /* Don't allow these to change */
// OBSOLETE 
// OBSOLETE       /* ZERO_REGNUM */
// OBSOLETE       *(int *) deprecated_registers = 0;
// OBSOLETE 
// OBSOLETE       fetch_inferior_registers (PS_REGNUM);
// OBSOLETE       fetch_inferior_registers (BADVADDR_REGNUM);
// OBSOLETE       fetch_inferior_registers (CAUSE_REGNUM);
// OBSOLETE       fetch_inferior_registers (FCRIR_REGNUM);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (regno == -1 || (ZERO_REGNUM < regno && regno <= PC_REGNUM))
// OBSOLETE     {
// OBSOLETE #if 1
// OBSOLETE       /* Mach 3.0 saves thread's FP to MACH_FP_REGNUM.
// OBSOLETE        * GDB wants assigns a pseudo register FP_REGNUM for frame pointer.
// OBSOLETE        *
// OBSOLETE        * @@@@@@ Here I assume (!) that gdb's FP has the value that
// OBSOLETE        *     should go to threads frame pointer. If not true, this
// OBSOLETE        *     fails badly!!!!!
// OBSOLETE        */
// OBSOLETE       memcpy (&deprecated_registers[REGISTER_BYTE (MACH_FP_REGNUM)],
// OBSOLETE 	      &deprecated_registers[REGISTER_BYTE (FP_REGNUM)],
// OBSOLETE 	      REGISTER_RAW_SIZE (FP_REGNUM));
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE       /* Save gdb's regs 1..31 to thread saved regs 1..31
// OBSOLETE        * Luckily, they are contiquous
// OBSOLETE        */
// OBSOLETE       STORE_REGS (state, 1, 31);
// OBSOLETE 
// OBSOLETE       /* Save mdlo, mdhi */
// OBSOLETE       STORE_REGS (state, LO_REGNUM, 2);
// OBSOLETE 
// OBSOLETE       /* Save PC */
// OBSOLETE       STORE_REGS (state, PC_REGNUM, 1);
// OBSOLETE 
// OBSOLETE       ret = thread_set_state (current_thread,
// OBSOLETE 			      MIPS_THREAD_STATE,
// OBSOLETE 			      state,
// OBSOLETE 			      MIPS_FLOAT_STATE_COUNT);
// OBSOLETE       CHK ("store inferior regs : thread_set_state", ret);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (regno == -1 || regno >= FP0_REGNUM)
// OBSOLETE     {
// OBSOLETE       /* If thread has floating state, save it */
// OBSOLETE       if (read_register (PS_REGNUM) & MIPS_STATUS_USE_COP1)
// OBSOLETE 	{
// OBSOLETE 	  /* Do NOT save FCRIR_REGNUM */
// OBSOLETE 	  STORE_REGS (state, FP0_REGNUM, 33);
// OBSOLETE 
// OBSOLETE 	  ret = thread_set_state (current_thread,
// OBSOLETE 				  MIPS_FLOAT_STATE,
// OBSOLETE 				  state,
// OBSOLETE 				  MIPS_FLOAT_STATE_COUNT);
// OBSOLETE 	  CHK ("store inferior registers (floats): thread_set_state", ret);
// OBSOLETE 	}
// OBSOLETE       else if (regno != -1)
// OBSOLETE 	message
// OBSOLETE 	  ("Thread does not use floating point unit, floating regs not saved");
// OBSOLETE     }
// OBSOLETE }
@


1.4.24.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@@


1.3
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 1
a2 1
   Copyright (C) 1992, 2001 Free Software Foundation, Inc.
@


1.2
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright (C) 1992 Free Software Foundation, Inc.
d29 1
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d53 1
a53 1
static int reg_offset[] = 
d55 2
a56 2
  /*  zero		at		  v0		    v1       */
      -1,           REG_OFFSET(r1),   REG_OFFSET(r2),   REG_OFFSET(r3),
d58 2
a59 2
  /*  a0		a1		  a2		    a3       */
  REG_OFFSET(r4),   REG_OFFSET(r5),   REG_OFFSET(r6),   REG_OFFSET(r7),
d61 2
a62 2
  /*  t0		t1		  t2		    t3       */
  REG_OFFSET(r8),   REG_OFFSET(r9),   REG_OFFSET(r10),  REG_OFFSET(r11),
d64 2
a65 2
  /*  t4		t5		  t6		    t7       */
  REG_OFFSET(r12),  REG_OFFSET(r13),  REG_OFFSET(r14),  REG_OFFSET(r15),
d67 2
a68 2
  /*  s0		s1		  s2		    s3       */
  REG_OFFSET(r16),  REG_OFFSET(r17),  REG_OFFSET(r18),  REG_OFFSET(r19),
d70 2
a71 2
  /*  s4		s5		  s6		    s7       */
  REG_OFFSET(r20),  REG_OFFSET(r21),  REG_OFFSET(r22),  REG_OFFSET(r23),
d73 2
a74 2
  /*  t8		t9		  k0		    k1       */
  REG_OFFSET(r24),  REG_OFFSET(r25),  REG_OFFSET(r26),  REG_OFFSET(r27),
d76 2
a77 2
  /*  gp		sp	      s8(30) == fp(72)	    ra       */
  REG_OFFSET(r28),  REG_OFFSET(r29),  REG_OFFSET(r30),  REG_OFFSET(r31),
d80 1
a80 1
  EREG_OFFSET(coproc_state),
d82 2
a83 2
  /*  lo(33)		hi(34)    */
  REG_OFFSET(mdlo), REG_OFFSET(mdhi),
d85 2
a86 2
  /*  bad(35)          	      cause(36)	         pc(37)  */
  EREG_OFFSET(address),  EREG_OFFSET(cause), REG_OFFSET(pc),
d88 9
a96 9
  /*  f0(38)		 f1(39)		    f2(40)	       f3(41)   */
  CREG_OFFSET(r0),   CREG_OFFSET(r1),   CREG_OFFSET(r2),   CREG_OFFSET(r3),
  CREG_OFFSET(r4),   CREG_OFFSET(r5),   CREG_OFFSET(r6),   CREG_OFFSET(r7),
  CREG_OFFSET(r8),   CREG_OFFSET(r9),   CREG_OFFSET(r10),  CREG_OFFSET(r11),
  CREG_OFFSET(r12),  CREG_OFFSET(r13),  CREG_OFFSET(r14),  CREG_OFFSET(r15),
  CREG_OFFSET(r16),  CREG_OFFSET(r17),  CREG_OFFSET(r18),  CREG_OFFSET(r19),
  CREG_OFFSET(r20),  CREG_OFFSET(r21),  CREG_OFFSET(r22),  CREG_OFFSET(r23),
  CREG_OFFSET(r24),  CREG_OFFSET(r25),  CREG_OFFSET(r26),  CREG_OFFSET(r27),
  CREG_OFFSET(r28),  CREG_OFFSET(r29),  CREG_OFFSET(r30),  CREG_OFFSET(r31),
d98 2
a99 2
  /*  fsr(70)		fir(71)		fp(72) == s8(30) */
  CREG_OFFSET(csr),  CREG_OFFSET(esr),  REG_OFFSET(r30)
d103 1
a103 1
static int reg_offset[] = 
d106 2
a107 2
  -1,  0,  4,  8,  12, 16, 20, 24,  28, 32, 36, 40,  44, 48, 52, 56,
  60, 64, 68, 72,  76, 80, 84, 88,  92, 96,100,104, 108,112,116,120,
d109 1
a109 1
   8,124,128,  4,   0,132,
d111 4
a114 4
   0,  4,  8, 12,  16, 20, 24, 28,  32, 36, 40, 44,  48, 52, 56, 60,
  64, 68, 72, 76,  80, 84, 88, 92,  96,100,104,108, 112,116,120,124,
/*fsr,fir*/
 128,132,
d116 1
a116 1
 116
d144 1
a144 2
fetch_inferior_registers (regno)
     int regno;
d146 1
a146 1
  kern_return_t ret;  
d148 2
a149 2
  thread_state_data_t      state;
  struct mips_exc_state    exc_state;
d151 1
a151 1
  int stateCnt   = MIPS_THREAD_STATE_COUNT;
d153 1
a153 1
  int which_regs = 0; /* A bit mask */
d155 1
a155 1
  if (! MACH_PORT_VALID (current_thread))
d157 1
a157 1
  
d195 1
a195 1
			       (char *)state+reg_offset[ MACH_FP_REGNUM ]);
d197 1
a197 1
			       (char *)state+reg_offset[ MACH_FP_REGNUM ]);
d201 1
a201 1
			     (char *)state+reg_offset[ regno ]);
d204 1
a204 1
			   
d207 1
a207 1
      
d212 1
a212 1
      
d231 1
a231 1
			      (thread_state_t) &exc_state,
d241 2
a242 2
		       (char *)&exc_state+reg_offset[ PS_REGNUM ]);
      
d246 2
a247 2
			   (char *)&exc_state+reg_offset[ BADVADDR_REGNUM ]);
	  
d249 1
a249 1
			   (char *)&exc_state+reg_offset[ CAUSE_REGNUM ]);
d259 3
a261 3
      
      if (! (exc_state.coproc_state & MIPS_STATUS_USE_COP1))
	bzero (&registers[ REGISTER_BYTE (FP0_REGNUM) ],
d271 1
a271 1
	  
d275 1
a275 1
			       (char *)state+reg_offset[ regno ]);
d278 1
a278 1
	  
d282 1
a282 1
  
d298 1
a298 2
store_inferior_registers (regno)
     register int regno;
d302 2
a303 2
  
  if (! MACH_PORT_VALID (current_thread))
d305 1
a305 1
  
d309 4
a312 4
  if (regno == ZERO_REGNUM	||
      regno == PS_REGNUM	||
      regno == BADVADDR_REGNUM	||
      regno == CAUSE_REGNUM	||
d316 1
a316 1
	       REGISTER_NAME ( regno ));
d326 2
a327 2
      *(int *)registers = 0;
      
d348 1
a348 1
      
d357 1
a357 1
     /* Save PC */
d366 1
a366 1
  
d374 1
a374 1
	
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d52 1
a52 1
static int reg_offset[] =
d54 2
a55 2
  /*  zero              at                v0                v1       */
  -1, REG_OFFSET (r1), REG_OFFSET (r2), REG_OFFSET (r3),
d57 2
a58 2
  /*  a0                a1                a2                a3       */
  REG_OFFSET (r4), REG_OFFSET (r5), REG_OFFSET (r6), REG_OFFSET (r7),
d60 2
a61 2
  /*  t0                t1                t2                t3       */
  REG_OFFSET (r8), REG_OFFSET (r9), REG_OFFSET (r10), REG_OFFSET (r11),
d63 2
a64 2
  /*  t4                t5                t6                t7       */
  REG_OFFSET (r12), REG_OFFSET (r13), REG_OFFSET (r14), REG_OFFSET (r15),
d66 2
a67 2
  /*  s0                s1                s2                s3       */
  REG_OFFSET (r16), REG_OFFSET (r17), REG_OFFSET (r18), REG_OFFSET (r19),
d69 2
a70 2
  /*  s4                s5                s6                s7       */
  REG_OFFSET (r20), REG_OFFSET (r21), REG_OFFSET (r22), REG_OFFSET (r23),
d72 2
a73 2
  /*  t8                t9                k0                k1       */
  REG_OFFSET (r24), REG_OFFSET (r25), REG_OFFSET (r26), REG_OFFSET (r27),
d75 2
a76 2
  /*  gp                sp            s8(30) == fp(72)      ra       */
  REG_OFFSET (r28), REG_OFFSET (r29), REG_OFFSET (r30), REG_OFFSET (r31),
d79 1
a79 1
  EREG_OFFSET (coproc_state),
d81 2
a82 2
  /*  lo(33)            hi(34)    */
  REG_OFFSET (mdlo), REG_OFFSET (mdhi),
d84 2
a85 2
  /*  bad(35)                 cause(36)          pc(37)  */
  EREG_OFFSET (address), EREG_OFFSET (cause), REG_OFFSET (pc),
d87 9
a95 9
  /*  f0(38)             f1(39)             f2(40)             f3(41)   */
  CREG_OFFSET (r0), CREG_OFFSET (r1), CREG_OFFSET (r2), CREG_OFFSET (r3),
  CREG_OFFSET (r4), CREG_OFFSET (r5), CREG_OFFSET (r6), CREG_OFFSET (r7),
  CREG_OFFSET (r8), CREG_OFFSET (r9), CREG_OFFSET (r10), CREG_OFFSET (r11),
  CREG_OFFSET (r12), CREG_OFFSET (r13), CREG_OFFSET (r14), CREG_OFFSET (r15),
  CREG_OFFSET (r16), CREG_OFFSET (r17), CREG_OFFSET (r18), CREG_OFFSET (r19),
  CREG_OFFSET (r20), CREG_OFFSET (r21), CREG_OFFSET (r22), CREG_OFFSET (r23),
  CREG_OFFSET (r24), CREG_OFFSET (r25), CREG_OFFSET (r26), CREG_OFFSET (r27),
  CREG_OFFSET (r28), CREG_OFFSET (r29), CREG_OFFSET (r30), CREG_OFFSET (r31),
d97 2
a98 2
  /*  fsr(70)           fir(71)         fp(72) == s8(30) */
  CREG_OFFSET (csr), CREG_OFFSET (esr), REG_OFFSET (r30)
d102 1
a102 1
static int reg_offset[] =
d105 2
a106 2
  -1, 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56,
  60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120,
d108 1
a108 1
  8, 124, 128, 4, 0, 132,
d110 4
a113 4
  0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60,
  64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124,
/*fsr,fir */
  128, 132,
d115 1
a115 1
  116
d146 1
a146 1
  kern_return_t ret;
d148 2
a149 2
  thread_state_data_t state;
  struct mips_exc_state exc_state;
d151 1
a151 1
  int stateCnt = MIPS_THREAD_STATE_COUNT;
d153 1
a153 1
  int which_regs = 0;		/* A bit mask */
d155 1
a155 1
  if (!MACH_PORT_VALID (current_thread))
d157 1
a157 1

d195 1
a195 1
			       (char *) state + reg_offset[MACH_FP_REGNUM]);
d197 1
a197 1
			       (char *) state + reg_offset[MACH_FP_REGNUM]);
d201 1
a201 1
			     (char *) state + reg_offset[regno]);
d204 1
a204 1

d207 1
a207 1

d212 1
a212 1

d231 1
a231 1
			      (thread_state_t) & exc_state,
d241 2
a242 2
		       (char *) &exc_state + reg_offset[PS_REGNUM]);

d246 2
a247 2
			 (char *) &exc_state + reg_offset[BADVADDR_REGNUM]);

d249 1
a249 1
			   (char *) &exc_state + reg_offset[CAUSE_REGNUM]);
d259 3
a261 3

      if (!(exc_state.coproc_state & MIPS_STATUS_USE_COP1))
	bzero (&registers[REGISTER_BYTE (FP0_REGNUM)],
d271 1
a271 1

d275 1
a275 1
			       (char *) state + reg_offset[regno]);
d278 1
a278 1

d282 1
a282 1

d303 2
a304 2

  if (!MACH_PORT_VALID (current_thread))
d306 1
a306 1

d310 4
a313 4
  if (regno == ZERO_REGNUM ||
      regno == PS_REGNUM ||
      regno == BADVADDR_REGNUM ||
      regno == CAUSE_REGNUM ||
d317 1
a317 1
	       REGISTER_NAME (regno));
d327 2
a328 2
      *(int *) registers = 0;

d349 1
a349 1

d358 1
a358 1
      /* Save PC */
d367 1
a367 1

d375 1
a375 1

@

