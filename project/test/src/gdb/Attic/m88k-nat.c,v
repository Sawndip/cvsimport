head	1.9;
access;
symbols
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.10
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.8
	carlton_dictionary-20020920-branchpoint:1.8
	gdb_5_3-branch:1.8.0.6
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.4
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.2
	readline_4_3-import-branchpoint:1.8
	gdb_5_2_1-2002-07-23-release:1.7
	kseitz_interps-20020528-branch:1.7.0.16
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.7.0.14
	cagney_regbuf-20020515-branchpoint:1.7
	jimb-macro-020506-branch:1.7.0.12
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.7
	gdb_5_2-branch:1.7.0.10
	gdb_5_2-2002-03-03-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.8
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.6
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.4
	gdb_5_1-2001-07-29-branchpoint:1.7
	dberlin-typesystem-branch:1.7.0.2
	dberlin-typesystem-branchpoint:1.7
	gdb-post-ptid_t-2001-05-03:1.7
	gdb-pre-ptid_t-2001-05-03:1.6
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.9
date	2002.12.16.20.39.07;	author cagney;	state dead;
branches;
next	1.8;

1.8
date	2002.07.24.23.51.35;	author cagney;	state Exp;
branches
	1.8.8.1
	1.8.10.1;
next	1.7;

1.7
date	2001.05.04.04.15.25;	author kevinb;	state Exp;
branches
	1.7.16.1;
next	1.6;

1.6
date	2001.03.06.08.21.10;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.18.00.34.51;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.26.23.22.40;	author msnyder;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.44;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.07.52;	author jsm;	state Exp;
branches;
next	;

1.7.16.1
date	2002.08.09.18.34.25;	author kseitz;	state Exp;
branches;
next	;

1.8.8.1
date	2002.12.23.19.38.33;	author carlton;	state dead;
branches;
next	;

1.8.10.1
date	2003.12.14.20.27.21;	author drow;	state dead;
branches;
next	;


desc
@@


1.9
log
@2002-12-16  Andrew Cagney  <ac131313@@redhat.com>

	* config/arc/arc.mt, config/arc/tm-arc.h: Delete.
	* config/d30v/d30v.mt, config/d30v/tm-d30v.h: Delete.
	* config/fr30/fr30.mt, config/fr30/tm-fr30.h: Delete.
	* config/i386/i386aix.mh, config/i386/i386aix.mt: Delete.
	* config/i386/i386m3.mh, config/i386/i386m3.mt: Delete.
	* config/i386/i386mach.mh, config/i386/i386os9k.mt: Delete.
	* config/i386/nm-i386aix.h, config/i386/nm-i386mach.h: Delete.
	* config/i386/nm-m3.h, config/i386/tm-i386aix.h: Delete.
	* config/i386/tm-i386m3.h, config/i386/tm-i386mk.h: Delete.
	* config/i386/xm-i386aix.h, config/i386/xm-i386m3.h: Delete.
	* config/i386/xm-i386mach.h, config/i386/xm-i386mk.h: Delete.
	* config/i960/mon960.mt, config/i960/nindy960.mt: Delete.
	* config/i960/tm-i960.h, config/i960/tm-mon960.h: Delete.
	* config/i960/tm-nindy960.h, config/i960/tm-vx960.h: Delete.
	* config/i960/vxworks960.mt, config/m68k/apollo68b.mh: Delete.
	* config/m68k/apollo68b.mt, config/m68k/apollo68v.mh: Delete.
	* config/m68k/hp300bsd.mh, config/m68k/hp300bsd.mt: Delete.
	* config/m68k/hp300hpux.mh, config/m68k/hp300hpux.mt: Delete.
	* config/m88k/delta88.mh, config/m88k/delta88.mt: Delete.
	* config/m88k/delta88v4.mh, config/m88k/delta88v4.mt: Delete.
	* config/m88k/m88k.mh, config/m88k/m88k.mt: Delete.
	* config/m88k/nm-delta88v4.h, config/m88k/nm-m88k.h: Delete.
	* config/m88k/tm-delta88.h, config/m88k/tm-delta88v4.h: Delete.
	* config/m88k/tm-m88k.h, config/m88k/xm-delta88.h: Delete.
	* config/m88k/xm-dgux.h: Delete.
	* fr30-tdep.c, i386aix-nat.c, i386m3-nat.c: Delete.
	* i386mach-nat.c, i960-tdep.c, m88k-nat.c: Delete.
	* os9kread.c, remote-bug.c, remote-nindy.c: Delete.
	* remote-nrom.c, remote-os9k.c, remote-vx960.c: Delete.
	* d30v-tdep.c, arc-tdep.c, cxux-nat.c, dst.h, dstread.c: Delete.
	* ch-exp.c, ch-lang.c, ch-lang.h, ch-typeprint.c: Delete.
	* ch-valprint.c: Delete.
@
text
@// OBSOLETE /* Native-dependent Motorola 88xxx support for GDB, the GNU Debugger.
// OBSOLETE    Copyright 1988, 1990, 1991, 1992, 1993, 1995, 1999, 2000, 2001
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #include <sys/types.h>
// OBSOLETE #include <sys/param.h>
// OBSOLETE #include <sys/dir.h>
// OBSOLETE #include <signal.h>
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include <sys/user.h>
// OBSOLETE 
// OBSOLETE #ifndef USER			/* added to support BCS ptrace_user */
// OBSOLETE #define USER ptrace_user
// OBSOLETE #endif
// OBSOLETE #include <sys/ioctl.h>
// OBSOLETE #include <fcntl.h>
// OBSOLETE #include <sys/file.h>
// OBSOLETE #include "gdb_stat.h"
// OBSOLETE 
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "setjmp.h"
// OBSOLETE #include "value.h"
// OBSOLETE 
// OBSOLETE #ifdef DELTA88
// OBSOLETE #include <sys/ptrace.h>
// OBSOLETE 
// OBSOLETE /* define offsets to the pc instruction offsets in ptrace_user struct */
// OBSOLETE #define SXIP_OFFSET ((char *)&u.pt_sigframe.sig_sxip - (char *)&u)
// OBSOLETE #define SNIP_OFFSET ((char *)&u.pt_sigframe.sig_snip - (char *)&u)
// OBSOLETE #define SFIP_OFFSET ((char *)&u.pt_sigframe.sig_sfip - (char *)&u)
// OBSOLETE #else
// OBSOLETE /* define offsets to the pc instruction offsets in ptrace_user struct */
// OBSOLETE #define SXIP_OFFSET ((char *)&u.pt_sigframe.dg_sigframe.sc_sxip - (char *)&u)
// OBSOLETE #define SNIP_OFFSET ((char *)&u.pt_sigframe.dg_sigframe.sc_snip - (char *)&u)
// OBSOLETE #define SFIP_OFFSET ((char *)&u.pt_sigframe.dg_sigframe.sc_sfip - (char *)&u)
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE extern int have_symbol_file_p ();
// OBSOLETE 
// OBSOLETE extern jmp_buf stack_jmp;
// OBSOLETE 
// OBSOLETE extern int errno;
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fetch_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   register unsigned int regaddr;
// OBSOLETE   char buf[MAX_REGISTER_RAW_SIZE];
// OBSOLETE   register int i;
// OBSOLETE 
// OBSOLETE   struct USER u;
// OBSOLETE   unsigned int offset;
// OBSOLETE 
// OBSOLETE   offset = (char *) &u.pt_r0 - (char *) &u;
// OBSOLETE   regaddr = offset;		/* byte offset to r0; */
// OBSOLETE 
// OBSOLETE /*  offset = ptrace (3, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) offset, 0) - KERNEL_U_ADDR; */
// OBSOLETE   for (regno = 0; regno < NUM_REGS; regno++)
// OBSOLETE     {
// OBSOLETE       /*regaddr = register_addr (regno, offset); */
// OBSOLETE       /* 88k enhancement  */
// OBSOLETE 
// OBSOLETE       for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
// OBSOLETE 	{
// OBSOLETE 	  *(int *) &buf[i] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 				     (PTRACE_ARG3_TYPE) regaddr, 0);
// OBSOLETE 	  regaddr += sizeof (int);
// OBSOLETE 	}
// OBSOLETE       supply_register (regno, buf);
// OBSOLETE     }
// OBSOLETE   /* now load up registers 36 - 38; special pc registers */
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) SXIP_OFFSET, 0);
// OBSOLETE   supply_register (SXIP_REGNUM, buf);
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) SNIP_OFFSET, 0);
// OBSOLETE   supply_register (SNIP_REGNUM, buf);
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) SFIP_OFFSET, 0);
// OBSOLETE   supply_register (SFIP_REGNUM, buf);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store our register values back into the inferior.
// OBSOLETE    If REGNO is -1, do this for all registers.
// OBSOLETE    Otherwise, REGNO specifies which register (so we can save time).  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE store_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   register unsigned int regaddr;
// OBSOLETE   char buf[80];
// OBSOLETE 
// OBSOLETE   struct USER u;
// OBSOLETE 
// OBSOLETE   unsigned int offset = (char *) &u.pt_r0 - (char *) &u;
// OBSOLETE 
// OBSOLETE   regaddr = offset;
// OBSOLETE 
// OBSOLETE   /* Don't try to deal with EXIP_REGNUM or ENIP_REGNUM, because I think either
// OBSOLETE      svr3 doesn't run on an 88110, or the kernel isolates the different (not
// OBSOLETE      completely sure this is true, but seems to be.  */
// OBSOLETE   if (regno >= 0)
// OBSOLETE     {
// OBSOLETE       /*      regaddr = register_addr (regno, offset); */
// OBSOLETE       if (regno < PC_REGNUM)
// OBSOLETE 	{
// OBSOLETE 	  regaddr = offset + regno * sizeof (int);
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		  (PTRACE_ARG3_TYPE) regaddr, read_register (regno));
// OBSOLETE 	  if (errno != 0)
// OBSOLETE 	    {
// OBSOLETE 	      sprintf (buf, "writing register number %d", regno);
// OBSOLETE 	      perror_with_name (buf);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       else if (regno == SXIP_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (regno));
// OBSOLETE       else if (regno == SNIP_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (regno));
// OBSOLETE       else if (regno == SFIP_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (regno));
// OBSOLETE       else
// OBSOLETE 	printf_unfiltered ("Bad register number for store_inferior routine\n");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       for (regno = 0; regno < PC_REGNUM; regno++)
// OBSOLETE 	{
// OBSOLETE 	  /*      regaddr = register_addr (regno, offset); */
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  regaddr = offset + regno * sizeof (int);
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		  (PTRACE_ARG3_TYPE) regaddr, read_register (regno));
// OBSOLETE 	  if (errno != 0)
// OBSOLETE 	    {
// OBSOLETE 	      sprintf (buf, "writing register number %d", regno);
// OBSOLETE 	      perror_with_name (buf);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (SXIP_REGNUM));
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (SNIP_REGNUM));
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (SFIP_REGNUM));
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* blockend is the address of the end of the user structure */
// OBSOLETE m88k_register_u_addr (int blockend, int regnum)
// OBSOLETE {
// OBSOLETE   struct USER u;
// OBSOLETE   int ustart = blockend - sizeof (struct USER);
// OBSOLETE   switch (regnum)
// OBSOLETE     {
// OBSOLETE     case 0:
// OBSOLETE     case 1:
// OBSOLETE     case 2:
// OBSOLETE     case 3:
// OBSOLETE     case 4:
// OBSOLETE     case 5:
// OBSOLETE     case 6:
// OBSOLETE     case 7:
// OBSOLETE     case 8:
// OBSOLETE     case 9:
// OBSOLETE     case 10:
// OBSOLETE     case 11:
// OBSOLETE     case 12:
// OBSOLETE     case 13:
// OBSOLETE     case 14:
// OBSOLETE     case 15:
// OBSOLETE     case 16:
// OBSOLETE     case 17:
// OBSOLETE     case 18:
// OBSOLETE     case 19:
// OBSOLETE     case 20:
// OBSOLETE     case 21:
// OBSOLETE     case 22:
// OBSOLETE     case 23:
// OBSOLETE     case 24:
// OBSOLETE     case 25:
// OBSOLETE     case 26:
// OBSOLETE     case 27:
// OBSOLETE     case 28:
// OBSOLETE     case 29:
// OBSOLETE     case 30:
// OBSOLETE     case 31:
// OBSOLETE       return (ustart + ((int) &u.pt_r0 - (int) &u) + REGISTER_SIZE * regnum);
// OBSOLETE     case PSR_REGNUM:
// OBSOLETE       return (ustart + ((int) &u.pt_psr - (int) &u));
// OBSOLETE     case FPSR_REGNUM:
// OBSOLETE       return (ustart + ((int) &u.pt_fpsr - (int) &u));
// OBSOLETE     case FPCR_REGNUM:
// OBSOLETE       return (ustart + ((int) &u.pt_fpcr - (int) &u));
// OBSOLETE     case SXIP_REGNUM:
// OBSOLETE       return (ustart + SXIP_OFFSET);
// OBSOLETE     case SNIP_REGNUM:
// OBSOLETE       return (ustart + SNIP_OFFSET);
// OBSOLETE     case SFIP_REGNUM:
// OBSOLETE       return (ustart + SFIP_OFFSET);
// OBSOLETE     default:
// OBSOLETE       if (regnum < NUM_REGS)
// OBSOLETE 	/* The register is one of those which is not defined...
// OBSOLETE 	   give it zero */
// OBSOLETE 	return (ustart + ((int) &u.pt_r0 - (int) &u));
// OBSOLETE       else
// OBSOLETE 	return (blockend + REGISTER_SIZE * regnum);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef USE_PROC_FS
// OBSOLETE 
// OBSOLETE #include <sys/procfs.h>
// OBSOLETE 
// OBSOLETE /* Prototypes for supply_gregset etc. */
// OBSOLETE #include "gregset.h"
// OBSOLETE 
// OBSOLETE /*  Given a pointer to a general register set in /proc format (gregset_t *),
// OBSOLETE    unpack the register contents and supply them as gdb's idea of the current
// OBSOLETE    register values. */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE supply_gregset (gregset_t *gregsetp)
// OBSOLETE {
// OBSOLETE   register int regi;
// OBSOLETE   register greg_t *regp = (greg_t *) gregsetp;
// OBSOLETE 
// OBSOLETE   for (regi = 0; regi <= SP_REGNUM; regi++)
// OBSOLETE     supply_register (regi, (char *) (regp + regi));
// OBSOLETE 
// OBSOLETE   supply_register (SXIP_REGNUM, (char *) (regp + R_XIP));
// OBSOLETE   supply_register (SNIP_REGNUM, (char *) (regp + R_NIP));
// OBSOLETE   supply_register (SFIP_REGNUM, (char *) (regp + R_FIP));
// OBSOLETE   supply_register (PSR_REGNUM, (char *) (regp + R_PSR));
// OBSOLETE   supply_register (FPSR_REGNUM, (char *) (regp + R_FPSR));
// OBSOLETE   supply_register (FPCR_REGNUM, (char *) (regp + R_FPCR));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fill_gregset (gregset_t *gregsetp, int regno)
// OBSOLETE {
// OBSOLETE   int regi;
// OBSOLETE   register greg_t *regp = (greg_t *) gregsetp;
// OBSOLETE 
// OBSOLETE   for (regi = 0; regi <= R_R31; regi++)
// OBSOLETE     if ((regno == -1) || (regno == regi))
// OBSOLETE       *(regp + regi) = *(int *) &registers[REGISTER_BYTE (regi)];
// OBSOLETE 
// OBSOLETE   if ((regno == -1) || (regno == SXIP_REGNUM))
// OBSOLETE     *(regp + R_XIP) = *(int *) &registers[REGISTER_BYTE (SXIP_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == SNIP_REGNUM))
// OBSOLETE     *(regp + R_NIP) = *(int *) &registers[REGISTER_BYTE (SNIP_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == SFIP_REGNUM))
// OBSOLETE     *(regp + R_FIP) = *(int *) &registers[REGISTER_BYTE (SFIP_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == PSR_REGNUM))
// OBSOLETE     *(regp + R_PSR) = *(int *) &registers[REGISTER_BYTE (PSR_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == FPSR_REGNUM))
// OBSOLETE     *(regp + R_FPSR) = *(int *) &registers[REGISTER_BYTE (FPSR_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == FPCR_REGNUM))
// OBSOLETE     *(regp + R_FPCR) = *(int *) &registers[REGISTER_BYTE (FPCR_REGNUM)];
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* USE_PROC_FS */
@


1.8
log
@Obsolete m88k.
@
text
@@


1.8.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.8.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.7
log
@Phase 1 of the ptid_t changes.
@
text
@d1 290
a290 290
/* Native-dependent Motorola 88xxx support for GDB, the GNU Debugger.
   Copyright 1988, 1990, 1991, 1992, 1993, 1995, 1999, 2000, 2001
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "regcache.h"

#include <sys/types.h>
#include <sys/param.h>
#include <sys/dir.h>
#include <signal.h>
#include "gdbcore.h"
#include <sys/user.h>

#ifndef USER			/* added to support BCS ptrace_user */
#define USER ptrace_user
#endif
#include <sys/ioctl.h>
#include <fcntl.h>
#include <sys/file.h>
#include "gdb_stat.h"

#include "symtab.h"
#include "setjmp.h"
#include "value.h"

#ifdef DELTA88
#include <sys/ptrace.h>

/* define offsets to the pc instruction offsets in ptrace_user struct */
#define SXIP_OFFSET ((char *)&u.pt_sigframe.sig_sxip - (char *)&u)
#define SNIP_OFFSET ((char *)&u.pt_sigframe.sig_snip - (char *)&u)
#define SFIP_OFFSET ((char *)&u.pt_sigframe.sig_sfip - (char *)&u)
#else
/* define offsets to the pc instruction offsets in ptrace_user struct */
#define SXIP_OFFSET ((char *)&u.pt_sigframe.dg_sigframe.sc_sxip - (char *)&u)
#define SNIP_OFFSET ((char *)&u.pt_sigframe.dg_sigframe.sc_snip - (char *)&u)
#define SFIP_OFFSET ((char *)&u.pt_sigframe.dg_sigframe.sc_sfip - (char *)&u)
#endif

extern int have_symbol_file_p ();

extern jmp_buf stack_jmp;

extern int errno;

void
fetch_inferior_registers (int regno)
{
  register unsigned int regaddr;
  char buf[MAX_REGISTER_RAW_SIZE];
  register int i;

  struct USER u;
  unsigned int offset;

  offset = (char *) &u.pt_r0 - (char *) &u;
  regaddr = offset;		/* byte offset to r0; */

/*  offset = ptrace (3, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) offset, 0) - KERNEL_U_ADDR; */
  for (regno = 0; regno < NUM_REGS; regno++)
    {
      /*regaddr = register_addr (regno, offset); */
      /* 88k enhancement  */

      for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
	{
	  *(int *) &buf[i] = ptrace (3, PIDGET (inferior_ptid),
				     (PTRACE_ARG3_TYPE) regaddr, 0);
	  regaddr += sizeof (int);
	}
      supply_register (regno, buf);
    }
  /* now load up registers 36 - 38; special pc registers */
  *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
			     (PTRACE_ARG3_TYPE) SXIP_OFFSET, 0);
  supply_register (SXIP_REGNUM, buf);
  *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
			     (PTRACE_ARG3_TYPE) SNIP_OFFSET, 0);
  supply_register (SNIP_REGNUM, buf);
  *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
			     (PTRACE_ARG3_TYPE) SFIP_OFFSET, 0);
  supply_register (SFIP_REGNUM, buf);
}

/* Store our register values back into the inferior.
   If REGNO is -1, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time).  */

void
store_inferior_registers (int regno)
{
  register unsigned int regaddr;
  char buf[80];

  struct USER u;

  unsigned int offset = (char *) &u.pt_r0 - (char *) &u;

  regaddr = offset;

  /* Don't try to deal with EXIP_REGNUM or ENIP_REGNUM, because I think either
     svr3 doesn't run on an 88110, or the kernel isolates the different (not
     completely sure this is true, but seems to be.  */
  if (regno >= 0)
    {
      /*      regaddr = register_addr (regno, offset); */
      if (regno < PC_REGNUM)
	{
	  regaddr = offset + regno * sizeof (int);
	  errno = 0;
	  ptrace (6, PIDGET (inferior_ptid),
		  (PTRACE_ARG3_TYPE) regaddr, read_register (regno));
	  if (errno != 0)
	    {
	      sprintf (buf, "writing register number %d", regno);
	      perror_with_name (buf);
	    }
	}
      else if (regno == SXIP_REGNUM)
	ptrace (6, PIDGET (inferior_ptid),
		(PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (regno));
      else if (regno == SNIP_REGNUM)
	ptrace (6, PIDGET (inferior_ptid),
		(PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (regno));
      else if (regno == SFIP_REGNUM)
	ptrace (6, PIDGET (inferior_ptid),
		(PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (regno));
      else
	printf_unfiltered ("Bad register number for store_inferior routine\n");
    }
  else
    {
      for (regno = 0; regno < PC_REGNUM; regno++)
	{
	  /*      regaddr = register_addr (regno, offset); */
	  errno = 0;
	  regaddr = offset + regno * sizeof (int);
	  ptrace (6, PIDGET (inferior_ptid),
		  (PTRACE_ARG3_TYPE) regaddr, read_register (regno));
	  if (errno != 0)
	    {
	      sprintf (buf, "writing register number %d", regno);
	      perror_with_name (buf);
	    }
	}
      ptrace (6, PIDGET (inferior_ptid),
	      (PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (SXIP_REGNUM));
      ptrace (6, PIDGET (inferior_ptid),
	      (PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (SNIP_REGNUM));
      ptrace (6, PIDGET (inferior_ptid),
	      (PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (SFIP_REGNUM));
    }
}


/* blockend is the address of the end of the user structure */
m88k_register_u_addr (int blockend, int regnum)
{
  struct USER u;
  int ustart = blockend - sizeof (struct USER);
  switch (regnum)
    {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
      return (ustart + ((int) &u.pt_r0 - (int) &u) + REGISTER_SIZE * regnum);
    case PSR_REGNUM:
      return (ustart + ((int) &u.pt_psr - (int) &u));
    case FPSR_REGNUM:
      return (ustart + ((int) &u.pt_fpsr - (int) &u));
    case FPCR_REGNUM:
      return (ustart + ((int) &u.pt_fpcr - (int) &u));
    case SXIP_REGNUM:
      return (ustart + SXIP_OFFSET);
    case SNIP_REGNUM:
      return (ustart + SNIP_OFFSET);
    case SFIP_REGNUM:
      return (ustart + SFIP_OFFSET);
    default:
      if (regnum < NUM_REGS)
	/* The register is one of those which is not defined...
	   give it zero */
	return (ustart + ((int) &u.pt_r0 - (int) &u));
      else
	return (blockend + REGISTER_SIZE * regnum);
    }
}

#ifdef USE_PROC_FS

#include <sys/procfs.h>

/* Prototypes for supply_gregset etc. */
#include "gregset.h"

/*  Given a pointer to a general register set in /proc format (gregset_t *),
   unpack the register contents and supply them as gdb's idea of the current
   register values. */

void
supply_gregset (gregset_t *gregsetp)
{
  register int regi;
  register greg_t *regp = (greg_t *) gregsetp;

  for (regi = 0; regi <= SP_REGNUM; regi++)
    supply_register (regi, (char *) (regp + regi));

  supply_register (SXIP_REGNUM, (char *) (regp + R_XIP));
  supply_register (SNIP_REGNUM, (char *) (regp + R_NIP));
  supply_register (SFIP_REGNUM, (char *) (regp + R_FIP));
  supply_register (PSR_REGNUM, (char *) (regp + R_PSR));
  supply_register (FPSR_REGNUM, (char *) (regp + R_FPSR));
  supply_register (FPCR_REGNUM, (char *) (regp + R_FPCR));
}

void
fill_gregset (gregset_t *gregsetp, int regno)
{
  int regi;
  register greg_t *regp = (greg_t *) gregsetp;

  for (regi = 0; regi <= R_R31; regi++)
    if ((regno == -1) || (regno == regi))
      *(regp + regi) = *(int *) &registers[REGISTER_BYTE (regi)];

  if ((regno == -1) || (regno == SXIP_REGNUM))
    *(regp + R_XIP) = *(int *) &registers[REGISTER_BYTE (SXIP_REGNUM)];
  if ((regno == -1) || (regno == SNIP_REGNUM))
    *(regp + R_NIP) = *(int *) &registers[REGISTER_BYTE (SNIP_REGNUM)];
  if ((regno == -1) || (regno == SFIP_REGNUM))
    *(regp + R_FIP) = *(int *) &registers[REGISTER_BYTE (SFIP_REGNUM)];
  if ((regno == -1) || (regno == PSR_REGNUM))
    *(regp + R_PSR) = *(int *) &registers[REGISTER_BYTE (PSR_REGNUM)];
  if ((regno == -1) || (regno == FPSR_REGNUM))
    *(regp + R_FPSR) = *(int *) &registers[REGISTER_BYTE (FPSR_REGNUM)];
  if ((regno == -1) || (regno == FPCR_REGNUM))
    *(regp + R_FPCR) = *(int *) &registers[REGISTER_BYTE (FPCR_REGNUM)];
}

#endif /* USE_PROC_FS */
@


1.7.16.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d1 290
a290 290
// OBSOLETE /* Native-dependent Motorola 88xxx support for GDB, the GNU Debugger.
// OBSOLETE    Copyright 1988, 1990, 1991, 1992, 1993, 1995, 1999, 2000, 2001
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #include <sys/types.h>
// OBSOLETE #include <sys/param.h>
// OBSOLETE #include <sys/dir.h>
// OBSOLETE #include <signal.h>
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include <sys/user.h>
// OBSOLETE 
// OBSOLETE #ifndef USER			/* added to support BCS ptrace_user */
// OBSOLETE #define USER ptrace_user
// OBSOLETE #endif
// OBSOLETE #include <sys/ioctl.h>
// OBSOLETE #include <fcntl.h>
// OBSOLETE #include <sys/file.h>
// OBSOLETE #include "gdb_stat.h"
// OBSOLETE 
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "setjmp.h"
// OBSOLETE #include "value.h"
// OBSOLETE 
// OBSOLETE #ifdef DELTA88
// OBSOLETE #include <sys/ptrace.h>
// OBSOLETE 
// OBSOLETE /* define offsets to the pc instruction offsets in ptrace_user struct */
// OBSOLETE #define SXIP_OFFSET ((char *)&u.pt_sigframe.sig_sxip - (char *)&u)
// OBSOLETE #define SNIP_OFFSET ((char *)&u.pt_sigframe.sig_snip - (char *)&u)
// OBSOLETE #define SFIP_OFFSET ((char *)&u.pt_sigframe.sig_sfip - (char *)&u)
// OBSOLETE #else
// OBSOLETE /* define offsets to the pc instruction offsets in ptrace_user struct */
// OBSOLETE #define SXIP_OFFSET ((char *)&u.pt_sigframe.dg_sigframe.sc_sxip - (char *)&u)
// OBSOLETE #define SNIP_OFFSET ((char *)&u.pt_sigframe.dg_sigframe.sc_snip - (char *)&u)
// OBSOLETE #define SFIP_OFFSET ((char *)&u.pt_sigframe.dg_sigframe.sc_sfip - (char *)&u)
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE extern int have_symbol_file_p ();
// OBSOLETE 
// OBSOLETE extern jmp_buf stack_jmp;
// OBSOLETE 
// OBSOLETE extern int errno;
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fetch_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   register unsigned int regaddr;
// OBSOLETE   char buf[MAX_REGISTER_RAW_SIZE];
// OBSOLETE   register int i;
// OBSOLETE 
// OBSOLETE   struct USER u;
// OBSOLETE   unsigned int offset;
// OBSOLETE 
// OBSOLETE   offset = (char *) &u.pt_r0 - (char *) &u;
// OBSOLETE   regaddr = offset;		/* byte offset to r0; */
// OBSOLETE 
// OBSOLETE /*  offset = ptrace (3, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) offset, 0) - KERNEL_U_ADDR; */
// OBSOLETE   for (regno = 0; regno < NUM_REGS; regno++)
// OBSOLETE     {
// OBSOLETE       /*regaddr = register_addr (regno, offset); */
// OBSOLETE       /* 88k enhancement  */
// OBSOLETE 
// OBSOLETE       for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
// OBSOLETE 	{
// OBSOLETE 	  *(int *) &buf[i] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 				     (PTRACE_ARG3_TYPE) regaddr, 0);
// OBSOLETE 	  regaddr += sizeof (int);
// OBSOLETE 	}
// OBSOLETE       supply_register (regno, buf);
// OBSOLETE     }
// OBSOLETE   /* now load up registers 36 - 38; special pc registers */
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) SXIP_OFFSET, 0);
// OBSOLETE   supply_register (SXIP_REGNUM, buf);
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) SNIP_OFFSET, 0);
// OBSOLETE   supply_register (SNIP_REGNUM, buf);
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) SFIP_OFFSET, 0);
// OBSOLETE   supply_register (SFIP_REGNUM, buf);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store our register values back into the inferior.
// OBSOLETE    If REGNO is -1, do this for all registers.
// OBSOLETE    Otherwise, REGNO specifies which register (so we can save time).  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE store_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   register unsigned int regaddr;
// OBSOLETE   char buf[80];
// OBSOLETE 
// OBSOLETE   struct USER u;
// OBSOLETE 
// OBSOLETE   unsigned int offset = (char *) &u.pt_r0 - (char *) &u;
// OBSOLETE 
// OBSOLETE   regaddr = offset;
// OBSOLETE 
// OBSOLETE   /* Don't try to deal with EXIP_REGNUM or ENIP_REGNUM, because I think either
// OBSOLETE      svr3 doesn't run on an 88110, or the kernel isolates the different (not
// OBSOLETE      completely sure this is true, but seems to be.  */
// OBSOLETE   if (regno >= 0)
// OBSOLETE     {
// OBSOLETE       /*      regaddr = register_addr (regno, offset); */
// OBSOLETE       if (regno < PC_REGNUM)
// OBSOLETE 	{
// OBSOLETE 	  regaddr = offset + regno * sizeof (int);
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		  (PTRACE_ARG3_TYPE) regaddr, read_register (regno));
// OBSOLETE 	  if (errno != 0)
// OBSOLETE 	    {
// OBSOLETE 	      sprintf (buf, "writing register number %d", regno);
// OBSOLETE 	      perror_with_name (buf);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       else if (regno == SXIP_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (regno));
// OBSOLETE       else if (regno == SNIP_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (regno));
// OBSOLETE       else if (regno == SFIP_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (regno));
// OBSOLETE       else
// OBSOLETE 	printf_unfiltered ("Bad register number for store_inferior routine\n");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       for (regno = 0; regno < PC_REGNUM; regno++)
// OBSOLETE 	{
// OBSOLETE 	  /*      regaddr = register_addr (regno, offset); */
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  regaddr = offset + regno * sizeof (int);
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		  (PTRACE_ARG3_TYPE) regaddr, read_register (regno));
// OBSOLETE 	  if (errno != 0)
// OBSOLETE 	    {
// OBSOLETE 	      sprintf (buf, "writing register number %d", regno);
// OBSOLETE 	      perror_with_name (buf);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (SXIP_REGNUM));
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (SNIP_REGNUM));
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (SFIP_REGNUM));
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* blockend is the address of the end of the user structure */
// OBSOLETE m88k_register_u_addr (int blockend, int regnum)
// OBSOLETE {
// OBSOLETE   struct USER u;
// OBSOLETE   int ustart = blockend - sizeof (struct USER);
// OBSOLETE   switch (regnum)
// OBSOLETE     {
// OBSOLETE     case 0:
// OBSOLETE     case 1:
// OBSOLETE     case 2:
// OBSOLETE     case 3:
// OBSOLETE     case 4:
// OBSOLETE     case 5:
// OBSOLETE     case 6:
// OBSOLETE     case 7:
// OBSOLETE     case 8:
// OBSOLETE     case 9:
// OBSOLETE     case 10:
// OBSOLETE     case 11:
// OBSOLETE     case 12:
// OBSOLETE     case 13:
// OBSOLETE     case 14:
// OBSOLETE     case 15:
// OBSOLETE     case 16:
// OBSOLETE     case 17:
// OBSOLETE     case 18:
// OBSOLETE     case 19:
// OBSOLETE     case 20:
// OBSOLETE     case 21:
// OBSOLETE     case 22:
// OBSOLETE     case 23:
// OBSOLETE     case 24:
// OBSOLETE     case 25:
// OBSOLETE     case 26:
// OBSOLETE     case 27:
// OBSOLETE     case 28:
// OBSOLETE     case 29:
// OBSOLETE     case 30:
// OBSOLETE     case 31:
// OBSOLETE       return (ustart + ((int) &u.pt_r0 - (int) &u) + REGISTER_SIZE * regnum);
// OBSOLETE     case PSR_REGNUM:
// OBSOLETE       return (ustart + ((int) &u.pt_psr - (int) &u));
// OBSOLETE     case FPSR_REGNUM:
// OBSOLETE       return (ustart + ((int) &u.pt_fpsr - (int) &u));
// OBSOLETE     case FPCR_REGNUM:
// OBSOLETE       return (ustart + ((int) &u.pt_fpcr - (int) &u));
// OBSOLETE     case SXIP_REGNUM:
// OBSOLETE       return (ustart + SXIP_OFFSET);
// OBSOLETE     case SNIP_REGNUM:
// OBSOLETE       return (ustart + SNIP_OFFSET);
// OBSOLETE     case SFIP_REGNUM:
// OBSOLETE       return (ustart + SFIP_OFFSET);
// OBSOLETE     default:
// OBSOLETE       if (regnum < NUM_REGS)
// OBSOLETE 	/* The register is one of those which is not defined...
// OBSOLETE 	   give it zero */
// OBSOLETE 	return (ustart + ((int) &u.pt_r0 - (int) &u));
// OBSOLETE       else
// OBSOLETE 	return (blockend + REGISTER_SIZE * regnum);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef USE_PROC_FS
// OBSOLETE 
// OBSOLETE #include <sys/procfs.h>
// OBSOLETE 
// OBSOLETE /* Prototypes for supply_gregset etc. */
// OBSOLETE #include "gregset.h"
// OBSOLETE 
// OBSOLETE /*  Given a pointer to a general register set in /proc format (gregset_t *),
// OBSOLETE    unpack the register contents and supply them as gdb's idea of the current
// OBSOLETE    register values. */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE supply_gregset (gregset_t *gregsetp)
// OBSOLETE {
// OBSOLETE   register int regi;
// OBSOLETE   register greg_t *regp = (greg_t *) gregsetp;
// OBSOLETE 
// OBSOLETE   for (regi = 0; regi <= SP_REGNUM; regi++)
// OBSOLETE     supply_register (regi, (char *) (regp + regi));
// OBSOLETE 
// OBSOLETE   supply_register (SXIP_REGNUM, (char *) (regp + R_XIP));
// OBSOLETE   supply_register (SNIP_REGNUM, (char *) (regp + R_NIP));
// OBSOLETE   supply_register (SFIP_REGNUM, (char *) (regp + R_FIP));
// OBSOLETE   supply_register (PSR_REGNUM, (char *) (regp + R_PSR));
// OBSOLETE   supply_register (FPSR_REGNUM, (char *) (regp + R_FPSR));
// OBSOLETE   supply_register (FPCR_REGNUM, (char *) (regp + R_FPCR));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fill_gregset (gregset_t *gregsetp, int regno)
// OBSOLETE {
// OBSOLETE   int regi;
// OBSOLETE   register greg_t *regp = (greg_t *) gregsetp;
// OBSOLETE 
// OBSOLETE   for (regi = 0; regi <= R_R31; regi++)
// OBSOLETE     if ((regno == -1) || (regno == regi))
// OBSOLETE       *(regp + regi) = *(int *) &registers[REGISTER_BYTE (regi)];
// OBSOLETE 
// OBSOLETE   if ((regno == -1) || (regno == SXIP_REGNUM))
// OBSOLETE     *(regp + R_XIP) = *(int *) &registers[REGISTER_BYTE (SXIP_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == SNIP_REGNUM))
// OBSOLETE     *(regp + R_NIP) = *(int *) &registers[REGISTER_BYTE (SNIP_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == SFIP_REGNUM))
// OBSOLETE     *(regp + R_FIP) = *(int *) &registers[REGISTER_BYTE (SFIP_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == PSR_REGNUM))
// OBSOLETE     *(regp + R_PSR) = *(int *) &registers[REGISTER_BYTE (PSR_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == FPSR_REGNUM))
// OBSOLETE     *(regp + R_FPSR) = *(int *) &registers[REGISTER_BYTE (FPSR_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == FPCR_REGNUM))
// OBSOLETE     *(regp + R_FPCR) = *(int *) &registers[REGISTER_BYTE (FPCR_REGNUM)];
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* USE_PROC_FS */
@


1.6
log
@Update/correct copyright notices.
@
text
@d79 1
a79 1
/*  offset = ptrace (3, inferior_pid, (PTRACE_ARG3_TYPE) offset, 0) - KERNEL_U_ADDR; */
d87 1
a87 1
	  *(int *) &buf[i] = ptrace (3, inferior_pid,
d94 1
a94 1
  *(int *) &buf[0] = ptrace (3, inferior_pid,
d97 1
a97 1
  *(int *) &buf[0] = ptrace (3, inferior_pid,
d100 1
a100 1
  *(int *) &buf[0] = ptrace (3, inferior_pid,
d131 1
a131 1
	  ptrace (6, inferior_pid,
d140 1
a140 1
	ptrace (6, inferior_pid,
d143 1
a143 1
	ptrace (6, inferior_pid,
d146 1
a146 1
	ptrace (6, inferior_pid,
d158 1
a158 1
	  ptrace (6, inferior_pid,
d166 1
a166 1
      ptrace (6, inferior_pid,
d168 1
a168 1
      ptrace (6, inferior_pid,
d170 1
a170 1
      ptrace (6, inferior_pid,
@


1.5
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1988, 1990, 1991, 1992, 2001 Free Software Foundation,
   Inc.
@


1.4
log
@Protoization.
@
text
@d2 2
a3 1
   Copyright 1988, 1990, 1991, 1992 Free Software Foundation, Inc.
d25 1
@


1.3
log
@Protoization.
@
text
@d65 1
a65 2
fetch_inferior_registers (regno)
     int regno;			/* Original value discarded */
@


1.2
log
@2000-05-26  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * gregset.h: New file.  Typedefs for gdb_gregset_t and
        gdb_fpregset_t, prototypes for supply_gregset and friends.
        * procfs.c: Include gregset.h.  Delete local prototypes for
        supply_gregset etc., and local typedef gdb_gregset_t etc.
        * sol-thread.c: Include gregset.h, delete local prototypes,
        add appropriate casts to gdb_gregset_t.
        * uw-thread.c, lin-thread.c, core-sol2.c, core-regset.c,
        sparc-tdep.c, ptx4-nat.c, ppc-linux-nat.c, mipsv4-nat.c,
        m88k-nat.c, m68klinux-nat.c, m68k-tdep.c, irix5-nat.c,
        irix4-nat.c, ia64-linux-nat.c, i386v4-nat.c, cxux-nat.c,
        arm-linux-nat.c, alpha-nat.c: Include gregset.h.
        * config/nm-linux.h: Define GDB_GREGSET_T, GDB_FPREGET_T.
        * config/sparc/tm-sun4sol2.h: Ditto.
@
text
@d109 1
a109 2
store_inferior_registers (regno)
     int regno;
d176 1
a176 1
m88k_register_u_addr (blockend, regnum)
d249 1
a249 2
supply_gregset (gregsetp)
     gregset_t *gregsetp;
d266 1
a266 3
fill_gregset (gregsetp, regno)
     gregset_t *gregsetp;
     int regno;
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d58 1
a58 1
extern int have_symbol_file_p();
a62 1
extern char registers[REGISTER_BYTES];
d66 1
a66 1
     int regno;		/* Original value discarded */
d75 2
a76 2
  offset = (char *) &u.pt_r0 - (char *) &u; 
  regaddr = offset; /* byte offset to r0;*/
d81 3
a83 3
      /*regaddr = register_addr (regno, offset);*/
	/* 88k enhancement  */
        
d85 2
a86 2
 	{
 	  *(int *) &buf[i] = ptrace (3, inferior_pid,
d88 2
a89 2
 	  regaddr += sizeof (int);
 	}
d92 10
a101 10
    /* now load up registers 36 - 38; special pc registers */
    *(int *) &buf[0] = ptrace (3,inferior_pid,
			       (PTRACE_ARG3_TYPE) SXIP_OFFSET ,0);
    supply_register (SXIP_REGNUM, buf);
    *(int *) &buf[0] = ptrace (3, inferior_pid,
			       (PTRACE_ARG3_TYPE) SNIP_OFFSET,0);
    supply_register (SNIP_REGNUM, buf);
    *(int *) &buf[0] = ptrace (3, inferior_pid,
			       (PTRACE_ARG3_TYPE) SFIP_OFFSET,0);
    supply_register (SFIP_REGNUM, buf);
d128 1
a128 1
	{ 
d141 1
a141 1
		(PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register(regno));
d144 1
a144 1
		(PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register(regno));
d147 1
a147 1
		(PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register(regno));
d152 1
a152 1
    { 
d166 6
a171 6
      ptrace (6,inferior_pid,
	      (PTRACE_ARG3_TYPE) SXIP_OFFSET,read_register(SXIP_REGNUM));
      ptrace (6,inferior_pid,
	      (PTRACE_ARG3_TYPE) SNIP_OFFSET,read_register(SNIP_REGNUM));
      ptrace (6,inferior_pid,
	      (PTRACE_ARG3_TYPE) SFIP_OFFSET,read_register(SFIP_REGNUM));
d216 19
a234 13
    case PSR_REGNUM:  return (ustart + ((int) &u.pt_psr - (int) &u));
    case FPSR_REGNUM: return (ustart + ((int) &u.pt_fpsr - (int) &u));
    case FPCR_REGNUM: return (ustart + ((int) &u.pt_fpcr - (int) &u));
    case SXIP_REGNUM: return (ustart + SXIP_OFFSET); 
    case SNIP_REGNUM: return (ustart + SNIP_OFFSET);
    case SFIP_REGNUM: return (ustart + SFIP_OFFSET); 
    default: 
	if (regnum < NUM_REGS)
	    /* The register is one of those which is not defined...
	       give it zero */
	    return (ustart + ((int) &u.pt_r0 - (int) &u));
	else
	    return (blockend + REGISTER_SIZE * regnum);
d242 3
d246 2
a247 2
    unpack the register contents and supply them as gdb's idea of the current
    register values. */
d253 2
a254 2
    register int regi;
    register greg_t *regp = (greg_t *) gregsetp;
d256 2
a257 2
    for (regi=0; regi <= SP_REGNUM; regi++)
	supply_register (regi, (char *) (regp + regi));
d259 6
a264 6
    supply_register (SXIP_REGNUM, (char *) (regp + R_XIP));
    supply_register (SNIP_REGNUM, (char *) (regp + R_NIP));
    supply_register (SFIP_REGNUM, (char *) (regp + R_FIP));
    supply_register (PSR_REGNUM, (char *) (regp + R_PSR));
    supply_register (FPSR_REGNUM, (char *) (regp + R_FPSR));
    supply_register (FPCR_REGNUM, (char *) (regp + R_FPCR));
d272 19
a290 20
    int regi;
    register greg_t *regp = (greg_t *) gregsetp;
    extern char registers[];

    for (regi = 0 ; regi <= R_R31 ; regi++)
	if ((regno == -1) || (regno == regi))
	    *(regp + regi) = *(int *) &registers[REGISTER_BYTE(regi)];

    if ((regno == -1) || (regno == SXIP_REGNUM))
	*(regp + R_XIP) = *(int *) &registers[REGISTER_BYTE(SXIP_REGNUM)];
    if ((regno == -1) || (regno == SNIP_REGNUM))
	*(regp + R_NIP) = *(int *) &registers[REGISTER_BYTE(SNIP_REGNUM)];
    if ((regno == -1) || (regno == SFIP_REGNUM))
	*(regp + R_FIP) = *(int *) &registers[REGISTER_BYTE(SFIP_REGNUM)];
    if ((regno == -1) || (regno == PSR_REGNUM))
	*(regp + R_PSR) = *(int *) &registers[REGISTER_BYTE(PSR_REGNUM)];
    if ((regno == -1) || (regno == FPSR_REGNUM))
	*(regp + R_FPSR) = *(int *) &registers[REGISTER_BYTE(FPSR_REGNUM)];
    if ((regno == -1) || (regno == FPCR_REGNUM))
	*(regp + R_FPCR) = *(int *) &registers[REGISTER_BYTE(FPCR_REGNUM)];
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d62 1
d265 1
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d57 1
a57 1
extern int have_symbol_file_p ();
d65 1
a65 1
     int regno;			/* Original value discarded */
d74 2
a75 2
  offset = (char *) &u.pt_r0 - (char *) &u;
  regaddr = offset;		/* byte offset to r0; */
d80 3
a82 3
      /*regaddr = register_addr (regno, offset); */
      /* 88k enhancement  */

d84 2
a85 2
	{
	  *(int *) &buf[i] = ptrace (3, inferior_pid,
d87 2
a88 2
	  regaddr += sizeof (int);
	}
d91 10
a100 10
  /* now load up registers 36 - 38; special pc registers */
  *(int *) &buf[0] = ptrace (3, inferior_pid,
			     (PTRACE_ARG3_TYPE) SXIP_OFFSET, 0);
  supply_register (SXIP_REGNUM, buf);
  *(int *) &buf[0] = ptrace (3, inferior_pid,
			     (PTRACE_ARG3_TYPE) SNIP_OFFSET, 0);
  supply_register (SNIP_REGNUM, buf);
  *(int *) &buf[0] = ptrace (3, inferior_pid,
			     (PTRACE_ARG3_TYPE) SFIP_OFFSET, 0);
  supply_register (SFIP_REGNUM, buf);
d127 1
a127 1
	{
d140 1
a140 1
		(PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (regno));
d143 1
a143 1
		(PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (regno));
d146 1
a146 1
		(PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (regno));
d151 1
a151 1
    {
d165 6
a170 6
      ptrace (6, inferior_pid,
	      (PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (SXIP_REGNUM));
      ptrace (6, inferior_pid,
	      (PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (SNIP_REGNUM));
      ptrace (6, inferior_pid,
	      (PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (SFIP_REGNUM));
d215 13
a227 19
    case PSR_REGNUM:
      return (ustart + ((int) &u.pt_psr - (int) &u));
    case FPSR_REGNUM:
      return (ustart + ((int) &u.pt_fpsr - (int) &u));
    case FPCR_REGNUM:
      return (ustart + ((int) &u.pt_fpcr - (int) &u));
    case SXIP_REGNUM:
      return (ustart + SXIP_OFFSET);
    case SNIP_REGNUM:
      return (ustart + SNIP_OFFSET);
    case SFIP_REGNUM:
      return (ustart + SFIP_OFFSET);
    default:
      if (regnum < NUM_REGS)
	/* The register is one of those which is not defined...
	   give it zero */
	return (ustart + ((int) &u.pt_r0 - (int) &u));
      else
	return (blockend + REGISTER_SIZE * regnum);
d236 2
a237 2
   unpack the register contents and supply them as gdb's idea of the current
   register values. */
d243 2
a244 2
  register int regi;
  register greg_t *regp = (greg_t *) gregsetp;
d246 2
a247 2
  for (regi = 0; regi <= SP_REGNUM; regi++)
    supply_register (regi, (char *) (regp + regi));
d249 6
a254 6
  supply_register (SXIP_REGNUM, (char *) (regp + R_XIP));
  supply_register (SNIP_REGNUM, (char *) (regp + R_NIP));
  supply_register (SFIP_REGNUM, (char *) (regp + R_FIP));
  supply_register (PSR_REGNUM, (char *) (regp + R_PSR));
  supply_register (FPSR_REGNUM, (char *) (regp + R_FPSR));
  supply_register (FPCR_REGNUM, (char *) (regp + R_FPCR));
d262 2
a263 2
  int regi;
  register greg_t *regp = (greg_t *) gregsetp;
d265 16
a280 16
  for (regi = 0; regi <= R_R31; regi++)
    if ((regno == -1) || (regno == regi))
      *(regp + regi) = *(int *) &registers[REGISTER_BYTE (regi)];

  if ((regno == -1) || (regno == SXIP_REGNUM))
    *(regp + R_XIP) = *(int *) &registers[REGISTER_BYTE (SXIP_REGNUM)];
  if ((regno == -1) || (regno == SNIP_REGNUM))
    *(regp + R_NIP) = *(int *) &registers[REGISTER_BYTE (SNIP_REGNUM)];
  if ((regno == -1) || (regno == SFIP_REGNUM))
    *(regp + R_FIP) = *(int *) &registers[REGISTER_BYTE (SFIP_REGNUM)];
  if ((regno == -1) || (regno == PSR_REGNUM))
    *(regp + R_PSR) = *(int *) &registers[REGISTER_BYTE (PSR_REGNUM)];
  if ((regno == -1) || (regno == FPSR_REGNUM))
    *(regp + R_FPSR) = *(int *) &registers[REGISTER_BYTE (FPSR_REGNUM)];
  if ((regno == -1) || (regno == FPCR_REGNUM))
    *(regp + R_FPCR) = *(int *) &registers[REGISTER_BYTE (FPCR_REGNUM)];
@

