head	1.11;
access;
symbols
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.10
	kseitz_interps-20021105-merge:1.10
	kseitz_interps-20021103-merge:1.10
	drow-cplus-merge-20021020:1.10
	drow-cplus-merge-20021025:1.10
	carlton_dictionary-20021025-merge:1.10
	carlton_dictionary-20021011-merge:1.10
	drow-cplus-branch:1.10.0.10
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.8
	carlton_dictionary-20020920-branchpoint:1.10
	gdb_5_3-branch:1.10.0.6
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.4
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.2
	readline_4_3-import-branchpoint:1.10
	gdb_5_2_1-2002-07-23-release:1.9
	kseitz_interps-20020528-branch:1.9.0.8
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.6
	cagney_regbuf-20020515-branchpoint:1.9
	jimb-macro-020506-branch:1.9.0.4
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	gdb_5_2-branch:1.9.0.2
	gdb_5_2-2002-03-03-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.6
	gdb_5_1_0_1-2002-01-03-release:1.6
	cygnus_cvs_20020108_pre:1.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.8
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.6
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.4
	gdb_5_1-2001-07-29-branchpoint:1.6
	dberlin-typesystem-branch:1.6.0.2
	dberlin-typesystem-branchpoint:1.6
	gdb-post-ptid_t-2001-05-03:1.6
	gdb-pre-ptid_t-2001-05-03:1.6
	insight-precleanup-2001-01-01:1.5
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.11
date	2002.12.16.20.39.00;	author cagney;	state dead;
branches;
next	1.10;

1.10
date	2002.08.01.17.18.32;	author cagney;	state Exp;
branches
	1.10.8.1
	1.10.10.1;
next	1.9;

1.9
date	2002.02.13.18.49.29;	author chastain;	state Exp;
branches
	1.9.8.1;
next	1.8;

1.8
date	2001.12.25.22.24.38;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.10.20.44.37;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.06.08.21.06;	author kevinb;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.08.11.01.02.35;	author guo;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.30.01.48.24;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.28.01.12.26;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.08.04.39.01;	author kingdon;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.05.25.18.01.13;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.04.44;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.02.02.00.21.05;	author jsm;	state Exp;
branches;
next	;

1.6.2.1
date	2001.07.06.19.16.57;	author dberlin;	state Exp;
branches;
next	;

1.9.8.1
date	2002.08.09.18.34.23;	author kseitz;	state Exp;
branches;
next	;

1.10.8.1
date	2002.12.23.19.38.13;	author carlton;	state dead;
branches;
next	;

1.10.10.1
date	2003.12.14.20.27.08;	author drow;	state dead;
branches;
next	;


desc
@@


1.11
log
@2002-12-16  Andrew Cagney  <ac131313@@redhat.com>

	* config/arc/arc.mt, config/arc/tm-arc.h: Delete.
	* config/d30v/d30v.mt, config/d30v/tm-d30v.h: Delete.
	* config/fr30/fr30.mt, config/fr30/tm-fr30.h: Delete.
	* config/i386/i386aix.mh, config/i386/i386aix.mt: Delete.
	* config/i386/i386m3.mh, config/i386/i386m3.mt: Delete.
	* config/i386/i386mach.mh, config/i386/i386os9k.mt: Delete.
	* config/i386/nm-i386aix.h, config/i386/nm-i386mach.h: Delete.
	* config/i386/nm-m3.h, config/i386/tm-i386aix.h: Delete.
	* config/i386/tm-i386m3.h, config/i386/tm-i386mk.h: Delete.
	* config/i386/xm-i386aix.h, config/i386/xm-i386m3.h: Delete.
	* config/i386/xm-i386mach.h, config/i386/xm-i386mk.h: Delete.
	* config/i960/mon960.mt, config/i960/nindy960.mt: Delete.
	* config/i960/tm-i960.h, config/i960/tm-mon960.h: Delete.
	* config/i960/tm-nindy960.h, config/i960/tm-vx960.h: Delete.
	* config/i960/vxworks960.mt, config/m68k/apollo68b.mh: Delete.
	* config/m68k/apollo68b.mt, config/m68k/apollo68v.mh: Delete.
	* config/m68k/hp300bsd.mh, config/m68k/hp300bsd.mt: Delete.
	* config/m68k/hp300hpux.mh, config/m68k/hp300hpux.mt: Delete.
	* config/m88k/delta88.mh, config/m88k/delta88.mt: Delete.
	* config/m88k/delta88v4.mh, config/m88k/delta88v4.mt: Delete.
	* config/m88k/m88k.mh, config/m88k/m88k.mt: Delete.
	* config/m88k/nm-delta88v4.h, config/m88k/nm-m88k.h: Delete.
	* config/m88k/tm-delta88.h, config/m88k/tm-delta88v4.h: Delete.
	* config/m88k/tm-m88k.h, config/m88k/xm-delta88.h: Delete.
	* config/m88k/xm-dgux.h: Delete.
	* fr30-tdep.c, i386aix-nat.c, i386m3-nat.c: Delete.
	* i386mach-nat.c, i960-tdep.c, m88k-nat.c: Delete.
	* os9kread.c, remote-bug.c, remote-nindy.c: Delete.
	* remote-nrom.c, remote-os9k.c, remote-vx960.c: Delete.
	* d30v-tdep.c, arc-tdep.c, cxux-nat.c, dst.h, dstread.c: Delete.
	* ch-exp.c, ch-lang.c, ch-lang.h, ch-typeprint.c: Delete.
	* ch-valprint.c: Delete.
@
text
@// OBSOLETE /* Chill language support routines for GDB, the GNU debugger.
// OBSOLETE    Copyright 1992, 1993, 1994, 1995, 1996, 2000, 2001, 2002
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "gdbtypes.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "expression.h"
// OBSOLETE #include "parser-defs.h"
// OBSOLETE #include "language.h"
// OBSOLETE #include "ch-lang.h"
// OBSOLETE #include "valprint.h"
// OBSOLETE 
// OBSOLETE extern void _initialize_chill_language (void);
// OBSOLETE 
// OBSOLETE static struct value *evaluate_subexp_chill (struct type *, struct expression *,
// OBSOLETE 					    int *, enum noside);
// OBSOLETE 
// OBSOLETE static struct value *value_chill_max_min (enum exp_opcode, struct value *);
// OBSOLETE 
// OBSOLETE static struct value *value_chill_card (struct value *);
// OBSOLETE 
// OBSOLETE static struct value *value_chill_length (struct value *);
// OBSOLETE 
// OBSOLETE static struct type *chill_create_fundamental_type (struct objfile *, int);
// OBSOLETE 
// OBSOLETE static void chill_printstr (struct ui_file * stream, char *string,
// OBSOLETE 			    unsigned int length, int width,
// OBSOLETE 			    int force_ellipses);
// OBSOLETE 
// OBSOLETE static void chill_printchar (int, struct ui_file *);
// OBSOLETE 
// OBSOLETE /* For now, Chill uses a simple mangling algorithm whereby you simply
// OBSOLETE    discard everything after the occurance of two successive CPLUS_MARKER
// OBSOLETE    characters to derive the demangled form. */
// OBSOLETE 
// OBSOLETE char *
// OBSOLETE chill_demangle (const char *mangled)
// OBSOLETE {
// OBSOLETE   const char *joiner = NULL;
// OBSOLETE   char *demangled;
// OBSOLETE   const char *cp = mangled;
// OBSOLETE 
// OBSOLETE   while (*cp)
// OBSOLETE     {
// OBSOLETE       if (is_cplus_marker (*cp))
// OBSOLETE 	{
// OBSOLETE 	  joiner = cp;
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       cp++;
// OBSOLETE     }
// OBSOLETE   if (joiner != NULL && *(joiner + 1) == *joiner)
// OBSOLETE     {
// OBSOLETE       demangled = savestring (mangled, joiner - mangled);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       demangled = NULL;
// OBSOLETE     }
// OBSOLETE   return (demangled);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE chill_printchar (register int c, struct ui_file *stream)
// OBSOLETE {
// OBSOLETE   c &= 0xFF;			/* Avoid sign bit follies */
// OBSOLETE 
// OBSOLETE   if (PRINT_LITERAL_FORM (c))
// OBSOLETE     {
// OBSOLETE       if (c == '\'' || c == '^')
// OBSOLETE 	fprintf_filtered (stream, "'%c%c'", c, c);
// OBSOLETE       else
// OBSOLETE 	fprintf_filtered (stream, "'%c'", c);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       fprintf_filtered (stream, "'^(%u)'", (unsigned int) c);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Print the character string STRING, printing at most LENGTH characters.
// OBSOLETE    Printing stops early if the number hits print_max; repeat counts
// OBSOLETE    are printed as appropriate.  Print ellipses at the end if we
// OBSOLETE    had to stop before printing LENGTH characters, or if FORCE_ELLIPSES.
// OBSOLETE    Note that gdb maintains the length of strings without counting the
// OBSOLETE    terminating null byte, while chill strings are typically written with
// OBSOLETE    an explicit null byte.  So we always assume an implied null byte
// OBSOLETE    until gdb is able to maintain non-null terminated strings as well
// OBSOLETE    as null terminated strings (FIXME).
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE chill_printstr (struct ui_file *stream, char *string, unsigned int length,
// OBSOLETE 		int width, int force_ellipses)
// OBSOLETE {
// OBSOLETE   register unsigned int i;
// OBSOLETE   unsigned int things_printed = 0;
// OBSOLETE   int in_literal_form = 0;
// OBSOLETE   int in_control_form = 0;
// OBSOLETE   int need_slashslash = 0;
// OBSOLETE   unsigned int c;
// OBSOLETE 
// OBSOLETE   if (length == 0)
// OBSOLETE     {
// OBSOLETE       fputs_filtered ("\"\"", stream);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   for (i = 0; i < length && things_printed < print_max; ++i)
// OBSOLETE     {
// OBSOLETE       /* Position of the character we are examining
// OBSOLETE          to see whether it is repeated.  */
// OBSOLETE       unsigned int rep1;
// OBSOLETE       /* Number of repetitions we have detected so far.  */
// OBSOLETE       unsigned int reps;
// OBSOLETE 
// OBSOLETE       QUIT;
// OBSOLETE 
// OBSOLETE       if (need_slashslash)
// OBSOLETE 	{
// OBSOLETE 	  fputs_filtered ("//", stream);
// OBSOLETE 	  need_slashslash = 0;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       rep1 = i + 1;
// OBSOLETE       reps = 1;
// OBSOLETE       while (rep1 < length && string[rep1] == string[i])
// OBSOLETE 	{
// OBSOLETE 	  ++rep1;
// OBSOLETE 	  ++reps;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       c = string[i];
// OBSOLETE       if (reps > repeat_count_threshold)
// OBSOLETE 	{
// OBSOLETE 	  if (in_control_form || in_literal_form)
// OBSOLETE 	    {
// OBSOLETE 	      if (in_control_form)
// OBSOLETE 		fputs_filtered (")", stream);
// OBSOLETE 	      fputs_filtered ("\"//", stream);
// OBSOLETE 	      in_control_form = in_literal_form = 0;
// OBSOLETE 	    }
// OBSOLETE 	  chill_printchar (c, stream);
// OBSOLETE 	  fprintf_filtered (stream, "<repeats %u times>", reps);
// OBSOLETE 	  i = rep1 - 1;
// OBSOLETE 	  things_printed += repeat_count_threshold;
// OBSOLETE 	  need_slashslash = 1;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (!in_literal_form && !in_control_form)
// OBSOLETE 	    fputs_filtered ("\"", stream);
// OBSOLETE 	  if (PRINT_LITERAL_FORM (c))
// OBSOLETE 	    {
// OBSOLETE 	      if (!in_literal_form)
// OBSOLETE 		{
// OBSOLETE 		  if (in_control_form)
// OBSOLETE 		    {
// OBSOLETE 		      fputs_filtered (")", stream);
// OBSOLETE 		      in_control_form = 0;
// OBSOLETE 		    }
// OBSOLETE 		  in_literal_form = 1;
// OBSOLETE 		}
// OBSOLETE 	      fprintf_filtered (stream, "%c", c);
// OBSOLETE 	      if (c == '"' || c == '^')
// OBSOLETE 		/* duplicate this one as must be done at input */
// OBSOLETE 		fprintf_filtered (stream, "%c", c);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      if (!in_control_form)
// OBSOLETE 		{
// OBSOLETE 		  if (in_literal_form)
// OBSOLETE 		    {
// OBSOLETE 		      in_literal_form = 0;
// OBSOLETE 		    }
// OBSOLETE 		  fputs_filtered ("^(", stream);
// OBSOLETE 		  in_control_form = 1;
// OBSOLETE 		}
// OBSOLETE 	      else
// OBSOLETE 		fprintf_filtered (stream, ",");
// OBSOLETE 	      c = c & 0xff;
// OBSOLETE 	      fprintf_filtered (stream, "%u", (unsigned int) c);
// OBSOLETE 	    }
// OBSOLETE 	  ++things_printed;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Terminate the quotes if necessary.  */
// OBSOLETE   if (in_control_form)
// OBSOLETE     {
// OBSOLETE       fputs_filtered (")", stream);
// OBSOLETE     }
// OBSOLETE   if (in_literal_form || in_control_form)
// OBSOLETE     {
// OBSOLETE       fputs_filtered ("\"", stream);
// OBSOLETE     }
// OBSOLETE   if (force_ellipses || (i < length))
// OBSOLETE     {
// OBSOLETE       fputs_filtered ("...", stream);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct type *
// OBSOLETE chill_create_fundamental_type (struct objfile *objfile, int typeid)
// OBSOLETE {
// OBSOLETE   register struct type *type = NULL;
// OBSOLETE 
// OBSOLETE   switch (typeid)
// OBSOLETE     {
// OBSOLETE     default:
// OBSOLETE       /* FIXME:  For now, if we are asked to produce a type not in this
// OBSOLETE          language, create the equivalent of a C integer type with the
// OBSOLETE          name "<?type?>".  When all the dust settles from the type
// OBSOLETE          reconstruction work, this should probably become an error. */
// OBSOLETE       type = init_type (TYPE_CODE_INT, 2, 0, "<?type?>", objfile);
// OBSOLETE       warning ("internal error: no chill fundamental type %d", typeid);
// OBSOLETE       break;
// OBSOLETE     case FT_VOID:
// OBSOLETE       /* FIXME:  Currently the GNU Chill compiler emits some DWARF entries for
// OBSOLETE          typedefs, unrelated to anything directly in the code being compiled,
// OBSOLETE          that have some FT_VOID types.  Just fake it for now. */
// OBSOLETE       type = init_type (TYPE_CODE_VOID, 0, 0, "<?VOID?>", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_BOOLEAN:
// OBSOLETE       type = init_type (TYPE_CODE_BOOL, 1, TYPE_FLAG_UNSIGNED, "BOOL", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_CHAR:
// OBSOLETE       type = init_type (TYPE_CODE_CHAR, 1, TYPE_FLAG_UNSIGNED, "CHAR", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_SIGNED_CHAR:
// OBSOLETE       type = init_type (TYPE_CODE_INT, 1, 0, "BYTE", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_UNSIGNED_CHAR:
// OBSOLETE       type = init_type (TYPE_CODE_INT, 1, TYPE_FLAG_UNSIGNED, "UBYTE", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_SHORT:		/* Chill ints are 2 bytes */
// OBSOLETE       type = init_type (TYPE_CODE_INT, 2, 0, "INT", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_UNSIGNED_SHORT:	/* Chill ints are 2 bytes */
// OBSOLETE       type = init_type (TYPE_CODE_INT, 2, TYPE_FLAG_UNSIGNED, "UINT", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_INTEGER:		/* FIXME? */
// OBSOLETE     case FT_SIGNED_INTEGER:	/* FIXME? */
// OBSOLETE     case FT_LONG:		/* Chill longs are 4 bytes */
// OBSOLETE     case FT_SIGNED_LONG:	/* Chill longs are 4 bytes */
// OBSOLETE       type = init_type (TYPE_CODE_INT, 4, 0, "LONG", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_UNSIGNED_INTEGER:	/* FIXME? */
// OBSOLETE     case FT_UNSIGNED_LONG:	/* Chill longs are 4 bytes */
// OBSOLETE       type = init_type (TYPE_CODE_INT, 4, TYPE_FLAG_UNSIGNED, "ULONG", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_FLOAT:
// OBSOLETE       type = init_type (TYPE_CODE_FLT, 4, 0, "REAL", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_DBL_PREC_FLOAT:
// OBSOLETE       type = init_type (TYPE_CODE_FLT, 8, 0, "LONG_REAL", objfile);
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE   return (type);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Table of operators and their precedences for printing expressions.  */
// OBSOLETE 
// OBSOLETE static const struct op_print chill_op_print_tab[] =
// OBSOLETE {
// OBSOLETE   {"AND", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},
// OBSOLETE   {"OR", BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},
// OBSOLETE   {"NOT", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},
// OBSOLETE   {"MOD", BINOP_MOD, PREC_MUL, 0},
// OBSOLETE   {"REM", BINOP_REM, PREC_MUL, 0},
// OBSOLETE   {"SIZE", UNOP_SIZEOF, PREC_BUILTIN_FUNCTION, 0},
// OBSOLETE   {"LOWER", UNOP_LOWER, PREC_BUILTIN_FUNCTION, 0},
// OBSOLETE   {"UPPER", UNOP_UPPER, PREC_BUILTIN_FUNCTION, 0},
// OBSOLETE   {"CARD", UNOP_CARD, PREC_BUILTIN_FUNCTION, 0},
// OBSOLETE   {"MAX", UNOP_CHMAX, PREC_BUILTIN_FUNCTION, 0},
// OBSOLETE   {"MIN", UNOP_CHMIN, PREC_BUILTIN_FUNCTION, 0},
// OBSOLETE   {":=", BINOP_ASSIGN, PREC_ASSIGN, 1},
// OBSOLETE   {"=", BINOP_EQUAL, PREC_EQUAL, 0},
// OBSOLETE   {"/=", BINOP_NOTEQUAL, PREC_EQUAL, 0},
// OBSOLETE   {"<=", BINOP_LEQ, PREC_ORDER, 0},
// OBSOLETE   {">=", BINOP_GEQ, PREC_ORDER, 0},
// OBSOLETE   {">", BINOP_GTR, PREC_ORDER, 0},
// OBSOLETE   {"<", BINOP_LESS, PREC_ORDER, 0},
// OBSOLETE   {"+", BINOP_ADD, PREC_ADD, 0},
// OBSOLETE   {"-", BINOP_SUB, PREC_ADD, 0},
// OBSOLETE   {"*", BINOP_MUL, PREC_MUL, 0},
// OBSOLETE   {"/", BINOP_DIV, PREC_MUL, 0},
// OBSOLETE   {"//", BINOP_CONCAT, PREC_PREFIX, 0},		/* FIXME: precedence? */
// OBSOLETE   {"-", UNOP_NEG, PREC_PREFIX, 0},
// OBSOLETE   {"->", UNOP_IND, PREC_SUFFIX, 1},
// OBSOLETE   {"->", UNOP_ADDR, PREC_PREFIX, 0},
// OBSOLETE   {":", BINOP_RANGE, PREC_ASSIGN, 0},
// OBSOLETE   {NULL, 0, 0, 0}
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* The built-in types of Chill.  */
// OBSOLETE 
// OBSOLETE struct type *builtin_type_chill_bool;
// OBSOLETE struct type *builtin_type_chill_char;
// OBSOLETE struct type *builtin_type_chill_long;
// OBSOLETE struct type *builtin_type_chill_ulong;
// OBSOLETE struct type *builtin_type_chill_real;
// OBSOLETE 
// OBSOLETE struct type **const (chill_builtin_types[]) =
// OBSOLETE {
// OBSOLETE   &builtin_type_chill_bool,
// OBSOLETE     &builtin_type_chill_char,
// OBSOLETE     &builtin_type_chill_long,
// OBSOLETE     &builtin_type_chill_ulong,
// OBSOLETE     &builtin_type_chill_real,
// OBSOLETE     0
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* Calculate LOWER or UPPER of TYPE.
// OBSOLETE    Returns the result as an integer.
// OBSOLETE    *RESULT_TYPE is the appropriate type for the result. */
// OBSOLETE 
// OBSOLETE LONGEST
// OBSOLETE type_lower_upper (enum exp_opcode op,	/* Either UNOP_LOWER or UNOP_UPPER */
// OBSOLETE 		  struct type *type, struct type **result_type)
// OBSOLETE {
// OBSOLETE   LONGEST low, high;
// OBSOLETE   *result_type = type;
// OBSOLETE   CHECK_TYPEDEF (type);
// OBSOLETE   switch (TYPE_CODE (type))
// OBSOLETE     {
// OBSOLETE     case TYPE_CODE_STRUCT:
// OBSOLETE       *result_type = builtin_type_int;
// OBSOLETE       if (chill_varying_type (type))
// OBSOLETE 	return type_lower_upper (op, TYPE_FIELD_TYPE (type, 1), result_type);
// OBSOLETE       break;
// OBSOLETE     case TYPE_CODE_ARRAY:
// OBSOLETE     case TYPE_CODE_BITSTRING:
// OBSOLETE     case TYPE_CODE_STRING:
// OBSOLETE       type = TYPE_FIELD_TYPE (type, 0);		/* Get index type */
// OBSOLETE 
// OBSOLETE       /* ... fall through ... */
// OBSOLETE     case TYPE_CODE_RANGE:
// OBSOLETE       *result_type = TYPE_TARGET_TYPE (type);
// OBSOLETE       return op == UNOP_LOWER ? TYPE_LOW_BOUND (type) : TYPE_HIGH_BOUND (type);
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_ENUM:
// OBSOLETE     case TYPE_CODE_BOOL:
// OBSOLETE     case TYPE_CODE_INT:
// OBSOLETE     case TYPE_CODE_CHAR:
// OBSOLETE       if (get_discrete_bounds (type, &low, &high) >= 0)
// OBSOLETE 	{
// OBSOLETE 	  *result_type = type;
// OBSOLETE 	  return op == UNOP_LOWER ? low : high;
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE     case TYPE_CODE_UNDEF:
// OBSOLETE     case TYPE_CODE_PTR:
// OBSOLETE     case TYPE_CODE_UNION:
// OBSOLETE     case TYPE_CODE_FUNC:
// OBSOLETE     case TYPE_CODE_FLT:
// OBSOLETE     case TYPE_CODE_VOID:
// OBSOLETE     case TYPE_CODE_SET:
// OBSOLETE     case TYPE_CODE_ERROR:
// OBSOLETE     case TYPE_CODE_MEMBER:
// OBSOLETE     case TYPE_CODE_METHOD:
// OBSOLETE     case TYPE_CODE_REF:
// OBSOLETE     case TYPE_CODE_COMPLEX:
// OBSOLETE     default:
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE   error ("unknown mode for LOWER/UPPER builtin");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct value *
// OBSOLETE value_chill_length (struct value *val)
// OBSOLETE {
// OBSOLETE   LONGEST tmp;
// OBSOLETE   struct type *type = VALUE_TYPE (val);
// OBSOLETE   struct type *ttype;
// OBSOLETE   CHECK_TYPEDEF (type);
// OBSOLETE   switch (TYPE_CODE (type))
// OBSOLETE     {
// OBSOLETE     case TYPE_CODE_ARRAY:
// OBSOLETE     case TYPE_CODE_BITSTRING:
// OBSOLETE     case TYPE_CODE_STRING:
// OBSOLETE       tmp = type_lower_upper (UNOP_UPPER, type, &ttype)
// OBSOLETE 	- type_lower_upper (UNOP_LOWER, type, &ttype) + 1;
// OBSOLETE       break;
// OBSOLETE     case TYPE_CODE_STRUCT:
// OBSOLETE       if (chill_varying_type (type))
// OBSOLETE 	{
// OBSOLETE 	  tmp = unpack_long (TYPE_FIELD_TYPE (type, 0), VALUE_CONTENTS (val));
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       /* ... else fall through ... */
// OBSOLETE     default:
// OBSOLETE       error ("bad argument to LENGTH builtin");
// OBSOLETE     }
// OBSOLETE   return value_from_longest (builtin_type_int, tmp);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct value *
// OBSOLETE value_chill_card (struct value *val)
// OBSOLETE {
// OBSOLETE   LONGEST tmp = 0;
// OBSOLETE   struct type *type = VALUE_TYPE (val);
// OBSOLETE   CHECK_TYPEDEF (type);
// OBSOLETE 
// OBSOLETE   if (TYPE_CODE (type) == TYPE_CODE_SET)
// OBSOLETE     {
// OBSOLETE       struct type *range_type = TYPE_INDEX_TYPE (type);
// OBSOLETE       LONGEST lower_bound, upper_bound;
// OBSOLETE       int i;
// OBSOLETE 
// OBSOLETE       get_discrete_bounds (range_type, &lower_bound, &upper_bound);
// OBSOLETE       for (i = lower_bound; i <= upper_bound; i++)
// OBSOLETE 	if (value_bit_index (type, VALUE_CONTENTS (val), i) > 0)
// OBSOLETE 	  tmp++;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     error ("bad argument to CARD builtin");
// OBSOLETE 
// OBSOLETE   return value_from_longest (builtin_type_int, tmp);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct value *
// OBSOLETE value_chill_max_min (enum exp_opcode op, struct value *val)
// OBSOLETE {
// OBSOLETE   LONGEST tmp = 0;
// OBSOLETE   struct type *type = VALUE_TYPE (val);
// OBSOLETE   struct type *elttype;
// OBSOLETE   CHECK_TYPEDEF (type);
// OBSOLETE 
// OBSOLETE   if (TYPE_CODE (type) == TYPE_CODE_SET)
// OBSOLETE     {
// OBSOLETE       LONGEST lower_bound, upper_bound;
// OBSOLETE       int i, empty = 1;
// OBSOLETE 
// OBSOLETE       elttype = TYPE_INDEX_TYPE (type);
// OBSOLETE       CHECK_TYPEDEF (elttype);
// OBSOLETE       get_discrete_bounds (elttype, &lower_bound, &upper_bound);
// OBSOLETE 
// OBSOLETE       if (op == UNOP_CHMAX)
// OBSOLETE 	{
// OBSOLETE 	  for (i = upper_bound; i >= lower_bound; i--)
// OBSOLETE 	    {
// OBSOLETE 	      if (value_bit_index (type, VALUE_CONTENTS (val), i) > 0)
// OBSOLETE 		{
// OBSOLETE 		  tmp = i;
// OBSOLETE 		  empty = 0;
// OBSOLETE 		  break;
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  for (i = lower_bound; i <= upper_bound; i++)
// OBSOLETE 	    {
// OBSOLETE 	      if (value_bit_index (type, VALUE_CONTENTS (val), i) > 0)
// OBSOLETE 		{
// OBSOLETE 		  tmp = i;
// OBSOLETE 		  empty = 0;
// OBSOLETE 		  break;
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       if (empty)
// OBSOLETE 	error ("%s for empty powerset", op == UNOP_CHMAX ? "MAX" : "MIN");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     error ("bad argument to %s builtin", op == UNOP_CHMAX ? "MAX" : "MIN");
// OBSOLETE 
// OBSOLETE   return value_from_longest (TYPE_CODE (elttype) == TYPE_CODE_RANGE
// OBSOLETE 			     ? TYPE_TARGET_TYPE (elttype)
// OBSOLETE 			     : elttype,
// OBSOLETE 			     tmp);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct value *
// OBSOLETE evaluate_subexp_chill (struct type *expect_type,
// OBSOLETE 		       register struct expression *exp, register int *pos,
// OBSOLETE 		       enum noside noside)
// OBSOLETE {
// OBSOLETE   int pc = *pos;
// OBSOLETE   struct type *type;
// OBSOLETE   int tem, nargs;
// OBSOLETE   struct value *arg1;
// OBSOLETE   struct value **argvec;
// OBSOLETE   enum exp_opcode op = exp->elts[*pos].opcode;
// OBSOLETE   switch (op)
// OBSOLETE     {
// OBSOLETE     case MULTI_SUBSCRIPT:
// OBSOLETE       if (noside == EVAL_SKIP)
// OBSOLETE 	break;
// OBSOLETE       (*pos) += 3;
// OBSOLETE       nargs = longest_to_int (exp->elts[pc + 1].longconst);
// OBSOLETE       arg1 = evaluate_subexp_with_coercion (exp, pos, noside);
// OBSOLETE       type = check_typedef (VALUE_TYPE (arg1));
// OBSOLETE 
// OBSOLETE       if (nargs == 1 && TYPE_CODE (type) == TYPE_CODE_INT)
// OBSOLETE 	{
// OBSOLETE 	  /* Looks like string repetition. */
// OBSOLETE 	  struct value *string = evaluate_subexp_with_coercion (exp, pos,
// OBSOLETE 								noside);
// OBSOLETE 	  return value_concat (arg1, string);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       switch (TYPE_CODE (type))
// OBSOLETE 	{
// OBSOLETE 	case TYPE_CODE_PTR:
// OBSOLETE 	  type = check_typedef (TYPE_TARGET_TYPE (type));
// OBSOLETE 	  if (!type || TYPE_CODE (type) != TYPE_CODE_FUNC)
// OBSOLETE 	    error ("reference value used as function");
// OBSOLETE 	  /* ... fall through ... */
// OBSOLETE 	case TYPE_CODE_FUNC:
// OBSOLETE 	  /* It's a function call. */
// OBSOLETE 	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
// OBSOLETE 	    break;
// OBSOLETE 
// OBSOLETE 	  /* Allocate arg vector, including space for the function to be
// OBSOLETE 	     called in argvec[0] and a terminating NULL */
// OBSOLETE 	  argvec = (struct value **) alloca (sizeof (struct value *)
// OBSOLETE 					     * (nargs + 2));
// OBSOLETE 	  argvec[0] = arg1;
// OBSOLETE 	  tem = 1;
// OBSOLETE 	  for (; tem <= nargs && tem <= TYPE_NFIELDS (type); tem++)
// OBSOLETE 	    {
// OBSOLETE 	      argvec[tem]
// OBSOLETE 		= evaluate_subexp_chill (TYPE_FIELD_TYPE (type, tem - 1),
// OBSOLETE 					 exp, pos, noside);
// OBSOLETE 	    }
// OBSOLETE 	  for (; tem <= nargs; tem++)
// OBSOLETE 	    argvec[tem] = evaluate_subexp_with_coercion (exp, pos, noside);
// OBSOLETE 	  argvec[tem] = 0;	/* signal end of arglist */
// OBSOLETE 
// OBSOLETE 	  return call_function_by_hand (argvec[0], nargs, argvec + 1);
// OBSOLETE 	default:
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       while (nargs-- > 0)
// OBSOLETE 	{
// OBSOLETE 	  struct value *index = evaluate_subexp_with_coercion (exp, pos,
// OBSOLETE 							       noside);
// OBSOLETE 	  arg1 = value_subscript (arg1, index);
// OBSOLETE 	}
// OBSOLETE       return (arg1);
// OBSOLETE 
// OBSOLETE     case UNOP_LOWER:
// OBSOLETE     case UNOP_UPPER:
// OBSOLETE       (*pos)++;
// OBSOLETE       if (noside == EVAL_SKIP)
// OBSOLETE 	{
// OBSOLETE 	  (*exp->language_defn->evaluate_exp) (NULL_TYPE, exp, pos, EVAL_SKIP);
// OBSOLETE 	  goto nosideret;
// OBSOLETE 	}
// OBSOLETE       arg1 = (*exp->language_defn->evaluate_exp) (NULL_TYPE, exp, pos,
// OBSOLETE 						  EVAL_AVOID_SIDE_EFFECTS);
// OBSOLETE       tem = type_lower_upper (op, VALUE_TYPE (arg1), &type);
// OBSOLETE       return value_from_longest (type, tem);
// OBSOLETE 
// OBSOLETE     case UNOP_LENGTH:
// OBSOLETE       (*pos)++;
// OBSOLETE       arg1 = (*exp->language_defn->evaluate_exp) (NULL_TYPE, exp, pos, noside);
// OBSOLETE       return value_chill_length (arg1);
// OBSOLETE 
// OBSOLETE     case UNOP_CARD:
// OBSOLETE       (*pos)++;
// OBSOLETE       arg1 = (*exp->language_defn->evaluate_exp) (NULL_TYPE, exp, pos, noside);
// OBSOLETE       return value_chill_card (arg1);
// OBSOLETE 
// OBSOLETE     case UNOP_CHMAX:
// OBSOLETE     case UNOP_CHMIN:
// OBSOLETE       (*pos)++;
// OBSOLETE       arg1 = (*exp->language_defn->evaluate_exp) (NULL_TYPE, exp, pos, noside);
// OBSOLETE       return value_chill_max_min (op, arg1);
// OBSOLETE 
// OBSOLETE     case BINOP_COMMA:
// OBSOLETE       error ("',' operator used in invalid context");
// OBSOLETE 
// OBSOLETE     default:
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return evaluate_subexp_standard (expect_type, exp, pos, noside);
// OBSOLETE nosideret:
// OBSOLETE   return value_from_longest (builtin_type_long, (LONGEST) 1);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE const struct language_defn chill_language_defn =
// OBSOLETE {
// OBSOLETE   "chill",
// OBSOLETE   language_chill,
// OBSOLETE   chill_builtin_types,
// OBSOLETE   range_check_on,
// OBSOLETE   type_check_on,
// OBSOLETE   case_sensitive_on,
// OBSOLETE   chill_parse,			/* parser */
// OBSOLETE   chill_error,			/* parser error function */
// OBSOLETE   evaluate_subexp_chill,
// OBSOLETE   chill_printchar,		/* print a character constant */
// OBSOLETE   chill_printstr,		/* function to print a string constant */
// OBSOLETE   NULL,				/* Function to print a single char */
// OBSOLETE   chill_create_fundamental_type,	/* Create fundamental type in this language */
// OBSOLETE   chill_print_type,		/* Print a type using appropriate syntax */
// OBSOLETE   chill_val_print,		/* Print a value using appropriate syntax */
// OBSOLETE   chill_value_print,		/* Print a top-levl value */
// OBSOLETE   {"", "B'", "", ""},		/* Binary format info */
// OBSOLETE   {"O'%lo", "O'", "o", ""},	/* Octal format info */
// OBSOLETE   {"D'%ld", "D'", "d", ""},	/* Decimal format info */
// OBSOLETE   {"H'%lx", "H'", "x", ""},	/* Hex format info */
// OBSOLETE   chill_op_print_tab,		/* expression operators for printing */
// OBSOLETE   0,				/* arrays are first-class (not c-style) */
// OBSOLETE   0,				/* String lower bound */
// OBSOLETE   &builtin_type_chill_char,	/* Type of string elements */
// OBSOLETE   LANG_MAGIC
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* Initialization for Chill */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_chill_language (void)
// OBSOLETE {
// OBSOLETE   builtin_type_chill_bool =
// OBSOLETE     init_type (TYPE_CODE_BOOL, TARGET_CHAR_BIT / TARGET_CHAR_BIT,
// OBSOLETE 	       TYPE_FLAG_UNSIGNED,
// OBSOLETE 	       "BOOL", (struct objfile *) NULL);
// OBSOLETE   builtin_type_chill_char =
// OBSOLETE     init_type (TYPE_CODE_CHAR, TARGET_CHAR_BIT / TARGET_CHAR_BIT,
// OBSOLETE 	       TYPE_FLAG_UNSIGNED,
// OBSOLETE 	       "CHAR", (struct objfile *) NULL);
// OBSOLETE   builtin_type_chill_long =
// OBSOLETE     init_type (TYPE_CODE_INT, TARGET_LONG_BIT / TARGET_CHAR_BIT,
// OBSOLETE 	       0,
// OBSOLETE 	       "LONG", (struct objfile *) NULL);
// OBSOLETE   builtin_type_chill_ulong =
// OBSOLETE     init_type (TYPE_CODE_INT, TARGET_LONG_BIT / TARGET_CHAR_BIT,
// OBSOLETE 	       TYPE_FLAG_UNSIGNED,
// OBSOLETE 	       "ULONG", (struct objfile *) NULL);
// OBSOLETE   builtin_type_chill_real =
// OBSOLETE     init_type (TYPE_CODE_FLT, TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
// OBSOLETE 	       0,
// OBSOLETE 	       "LONG_REAL", (struct objfile *) NULL);
// OBSOLETE 
// OBSOLETE   add_language (&chill_language_defn);
// OBSOLETE }
@


1.10
log
@2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* NEWS: Menion that CHILL has been made obsolete.

* gdbtypes.c (chill_varying_type): Make chill references obsolete.
* gdbserver/Makefile.in: Ditto.
* stabsread.c (read_range_type): Ditto.
* gdbtypes.h: Ditto.
* language.c (binop_type_check): Ditto.
(binop_result_type): Ditto.
(integral_type): Ditto.
(character_type): Ditto.
(string_type): Ditto.
(boolean_type): Ditto.
(structured_type): Ditto.
(lang_bool_type): Ditto.
(binop_type_check): Ditto.
* language.h (_LANG_chill): Ditto.
* dwarfread.c (set_cu_language): Ditto.
* dwarfread.c (CHILL_PRODUCER): Ditto.
* dwarfread.c (handle_producer): Ditto.
* expression.h (enum exp_opcode): Ditto.
* eval.c: Ditto for comments.
* typeprint.c (typedef_print) [_LANG_chill]: Ditto.
* expprint.c (print_subexp): Ditto.
(print_subexp): Ditto.
* valops.c (value_cast): Ditto.
(search_struct_field): Ditto.
* value.h (COERCE_VARYING_ARRAY): Ditto.
* symfile.c (init_filename_language_table): Ditto.
(add_psymbol_with_dem_name_to_list): Ditto.
* valarith.c (value_binop): Ditto.
(value_neg): Ditto.
* valops.c (value_slice): Ditto.
* symtab.h (union language_specific): Ditto.
(SYMBOL_INIT_LANGUAGE_SPECIFIC): Ditto.
(SYMBOL_DEMANGLED_NAME): Ditto.
(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
* defs.h (enum language): Ditto.
* symtab.c (got_symtab): Ditto.
* utils.c (fprintf_symbol_filtered): Ditto.

* ch-typeprint.c: Make file obsolete.
* ch-valprint.c: Make file obsolete.
* ch-lang.h: Make file obsolete.
* ch-exp.c: Make file obsolete.
* ch-lang.c: Make file obsolete.

* Makefile.in (FLAGS_TO_PASS): Do not pass CHILL or CHILLFLAGS or
CHILL_LIB.
(TARGET_FLAGS_TO_PASS): Ditto.
(CHILLFLAGS): Obsolete.
(CHILL): Obsolete.
(CHILL_FOR_TARGET): Obsolete.
(CHILL_LIB): Obsolete.
(SFILES): Remove ch-exp.c, ch-lang.c, ch-typeprint.c and
ch-valprint.c.
(HFILES_NO_SRCDIR): Remove ch-lang.h.
(COMMON_OBS): Remove ch-valprint.o, ch-typeprint.o, ch-exp.o and
ch-lang.o.
(ch-exp.o, ch-lang.o, ch-typeprint.o, ch-valprint.o): Delete
targets.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* stabs.texinfo, gdb.texinfo, gdbint.texinfo: Obsolete references
to CHILL.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* Makefile.in (TARGET_FLAGS_TO_PASS): Remove CHILLFLAGS, CHILL,
CHILL_FOR_TARGET and CHILL_LIB.
* configure.in (configdirs): Remove gdb.chill.
* configure: Regenerate.
* lib/gdb.exp: Obsolete references to chill.
* gdb.fortran/types.exp: Ditto.
* gdb.fortran/exprs.exp: Ditto.
@
text
@@


1.10.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.10.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.9
log
@2002-02-13  Michael Chastain <mec@@shout.net>

	* defs.h: Kill CONST_PTR.
	* c-lang.h (c_builtin_types): Change CONST_PTR to simple "const".
	* c-lang.c (c_builtin_types): Likewise.
	* ch-lang.c (ch_builtin_types): Likewise.
	* f-lang.c (f_builtin_types): Likewise.
	* language.c (unknown_builtin_types): Likewise.
	* m2-lang.c (m2_builtin_types): Likewise.
	* p-lang.c (pascal_builtin_types): Likewise.
	* scm-lang.c (c_builtin_types): Likewise.
@
text
@d1 663
a663 663
/* Chill language support routines for GDB, the GNU debugger.
   Copyright 1992, 1993, 1994, 1995, 1996, 2000, 2001, 2002
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "value.h"
#include "expression.h"
#include "parser-defs.h"
#include "language.h"
#include "ch-lang.h"
#include "valprint.h"

extern void _initialize_chill_language (void);

static struct value *evaluate_subexp_chill (struct type *, struct expression *,
					    int *, enum noside);

static struct value *value_chill_max_min (enum exp_opcode, struct value *);

static struct value *value_chill_card (struct value *);

static struct value *value_chill_length (struct value *);

static struct type *chill_create_fundamental_type (struct objfile *, int);

static void chill_printstr (struct ui_file * stream, char *string,
			    unsigned int length, int width,
			    int force_ellipses);

static void chill_printchar (int, struct ui_file *);

/* For now, Chill uses a simple mangling algorithm whereby you simply
   discard everything after the occurance of two successive CPLUS_MARKER
   characters to derive the demangled form. */

char *
chill_demangle (const char *mangled)
{
  const char *joiner = NULL;
  char *demangled;
  const char *cp = mangled;

  while (*cp)
    {
      if (is_cplus_marker (*cp))
	{
	  joiner = cp;
	  break;
	}
      cp++;
    }
  if (joiner != NULL && *(joiner + 1) == *joiner)
    {
      demangled = savestring (mangled, joiner - mangled);
    }
  else
    {
      demangled = NULL;
    }
  return (demangled);
}

static void
chill_printchar (register int c, struct ui_file *stream)
{
  c &= 0xFF;			/* Avoid sign bit follies */

  if (PRINT_LITERAL_FORM (c))
    {
      if (c == '\'' || c == '^')
	fprintf_filtered (stream, "'%c%c'", c, c);
      else
	fprintf_filtered (stream, "'%c'", c);
    }
  else
    {
      fprintf_filtered (stream, "'^(%u)'", (unsigned int) c);
    }
}

/* Print the character string STRING, printing at most LENGTH characters.
   Printing stops early if the number hits print_max; repeat counts
   are printed as appropriate.  Print ellipses at the end if we
   had to stop before printing LENGTH characters, or if FORCE_ELLIPSES.
   Note that gdb maintains the length of strings without counting the
   terminating null byte, while chill strings are typically written with
   an explicit null byte.  So we always assume an implied null byte
   until gdb is able to maintain non-null terminated strings as well
   as null terminated strings (FIXME).
 */

static void
chill_printstr (struct ui_file *stream, char *string, unsigned int length,
		int width, int force_ellipses)
{
  register unsigned int i;
  unsigned int things_printed = 0;
  int in_literal_form = 0;
  int in_control_form = 0;
  int need_slashslash = 0;
  unsigned int c;

  if (length == 0)
    {
      fputs_filtered ("\"\"", stream);
      return;
    }

  for (i = 0; i < length && things_printed < print_max; ++i)
    {
      /* Position of the character we are examining
         to see whether it is repeated.  */
      unsigned int rep1;
      /* Number of repetitions we have detected so far.  */
      unsigned int reps;

      QUIT;

      if (need_slashslash)
	{
	  fputs_filtered ("//", stream);
	  need_slashslash = 0;
	}

      rep1 = i + 1;
      reps = 1;
      while (rep1 < length && string[rep1] == string[i])
	{
	  ++rep1;
	  ++reps;
	}

      c = string[i];
      if (reps > repeat_count_threshold)
	{
	  if (in_control_form || in_literal_form)
	    {
	      if (in_control_form)
		fputs_filtered (")", stream);
	      fputs_filtered ("\"//", stream);
	      in_control_form = in_literal_form = 0;
	    }
	  chill_printchar (c, stream);
	  fprintf_filtered (stream, "<repeats %u times>", reps);
	  i = rep1 - 1;
	  things_printed += repeat_count_threshold;
	  need_slashslash = 1;
	}
      else
	{
	  if (!in_literal_form && !in_control_form)
	    fputs_filtered ("\"", stream);
	  if (PRINT_LITERAL_FORM (c))
	    {
	      if (!in_literal_form)
		{
		  if (in_control_form)
		    {
		      fputs_filtered (")", stream);
		      in_control_form = 0;
		    }
		  in_literal_form = 1;
		}
	      fprintf_filtered (stream, "%c", c);
	      if (c == '"' || c == '^')
		/* duplicate this one as must be done at input */
		fprintf_filtered (stream, "%c", c);
	    }
	  else
	    {
	      if (!in_control_form)
		{
		  if (in_literal_form)
		    {
		      in_literal_form = 0;
		    }
		  fputs_filtered ("^(", stream);
		  in_control_form = 1;
		}
	      else
		fprintf_filtered (stream, ",");
	      c = c & 0xff;
	      fprintf_filtered (stream, "%u", (unsigned int) c);
	    }
	  ++things_printed;
	}
    }

  /* Terminate the quotes if necessary.  */
  if (in_control_form)
    {
      fputs_filtered (")", stream);
    }
  if (in_literal_form || in_control_form)
    {
      fputs_filtered ("\"", stream);
    }
  if (force_ellipses || (i < length))
    {
      fputs_filtered ("...", stream);
    }
}

static struct type *
chill_create_fundamental_type (struct objfile *objfile, int typeid)
{
  register struct type *type = NULL;

  switch (typeid)
    {
    default:
      /* FIXME:  For now, if we are asked to produce a type not in this
         language, create the equivalent of a C integer type with the
         name "<?type?>".  When all the dust settles from the type
         reconstruction work, this should probably become an error. */
      type = init_type (TYPE_CODE_INT, 2, 0, "<?type?>", objfile);
      warning ("internal error: no chill fundamental type %d", typeid);
      break;
    case FT_VOID:
      /* FIXME:  Currently the GNU Chill compiler emits some DWARF entries for
         typedefs, unrelated to anything directly in the code being compiled,
         that have some FT_VOID types.  Just fake it for now. */
      type = init_type (TYPE_CODE_VOID, 0, 0, "<?VOID?>", objfile);
      break;
    case FT_BOOLEAN:
      type = init_type (TYPE_CODE_BOOL, 1, TYPE_FLAG_UNSIGNED, "BOOL", objfile);
      break;
    case FT_CHAR:
      type = init_type (TYPE_CODE_CHAR, 1, TYPE_FLAG_UNSIGNED, "CHAR", objfile);
      break;
    case FT_SIGNED_CHAR:
      type = init_type (TYPE_CODE_INT, 1, 0, "BYTE", objfile);
      break;
    case FT_UNSIGNED_CHAR:
      type = init_type (TYPE_CODE_INT, 1, TYPE_FLAG_UNSIGNED, "UBYTE", objfile);
      break;
    case FT_SHORT:		/* Chill ints are 2 bytes */
      type = init_type (TYPE_CODE_INT, 2, 0, "INT", objfile);
      break;
    case FT_UNSIGNED_SHORT:	/* Chill ints are 2 bytes */
      type = init_type (TYPE_CODE_INT, 2, TYPE_FLAG_UNSIGNED, "UINT", objfile);
      break;
    case FT_INTEGER:		/* FIXME? */
    case FT_SIGNED_INTEGER:	/* FIXME? */
    case FT_LONG:		/* Chill longs are 4 bytes */
    case FT_SIGNED_LONG:	/* Chill longs are 4 bytes */
      type = init_type (TYPE_CODE_INT, 4, 0, "LONG", objfile);
      break;
    case FT_UNSIGNED_INTEGER:	/* FIXME? */
    case FT_UNSIGNED_LONG:	/* Chill longs are 4 bytes */
      type = init_type (TYPE_CODE_INT, 4, TYPE_FLAG_UNSIGNED, "ULONG", objfile);
      break;
    case FT_FLOAT:
      type = init_type (TYPE_CODE_FLT, 4, 0, "REAL", objfile);
      break;
    case FT_DBL_PREC_FLOAT:
      type = init_type (TYPE_CODE_FLT, 8, 0, "LONG_REAL", objfile);
      break;
    }
  return (type);
}


/* Table of operators and their precedences for printing expressions.  */

static const struct op_print chill_op_print_tab[] =
{
  {"AND", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},
  {"OR", BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},
  {"NOT", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},
  {"MOD", BINOP_MOD, PREC_MUL, 0},
  {"REM", BINOP_REM, PREC_MUL, 0},
  {"SIZE", UNOP_SIZEOF, PREC_BUILTIN_FUNCTION, 0},
  {"LOWER", UNOP_LOWER, PREC_BUILTIN_FUNCTION, 0},
  {"UPPER", UNOP_UPPER, PREC_BUILTIN_FUNCTION, 0},
  {"CARD", UNOP_CARD, PREC_BUILTIN_FUNCTION, 0},
  {"MAX", UNOP_CHMAX, PREC_BUILTIN_FUNCTION, 0},
  {"MIN", UNOP_CHMIN, PREC_BUILTIN_FUNCTION, 0},
  {":=", BINOP_ASSIGN, PREC_ASSIGN, 1},
  {"=", BINOP_EQUAL, PREC_EQUAL, 0},
  {"/=", BINOP_NOTEQUAL, PREC_EQUAL, 0},
  {"<=", BINOP_LEQ, PREC_ORDER, 0},
  {">=", BINOP_GEQ, PREC_ORDER, 0},
  {">", BINOP_GTR, PREC_ORDER, 0},
  {"<", BINOP_LESS, PREC_ORDER, 0},
  {"+", BINOP_ADD, PREC_ADD, 0},
  {"-", BINOP_SUB, PREC_ADD, 0},
  {"*", BINOP_MUL, PREC_MUL, 0},
  {"/", BINOP_DIV, PREC_MUL, 0},
  {"//", BINOP_CONCAT, PREC_PREFIX, 0},		/* FIXME: precedence? */
  {"-", UNOP_NEG, PREC_PREFIX, 0},
  {"->", UNOP_IND, PREC_SUFFIX, 1},
  {"->", UNOP_ADDR, PREC_PREFIX, 0},
  {":", BINOP_RANGE, PREC_ASSIGN, 0},
  {NULL, 0, 0, 0}
};

/* The built-in types of Chill.  */

struct type *builtin_type_chill_bool;
struct type *builtin_type_chill_char;
struct type *builtin_type_chill_long;
struct type *builtin_type_chill_ulong;
struct type *builtin_type_chill_real;

struct type **const (chill_builtin_types[]) =
{
  &builtin_type_chill_bool,
    &builtin_type_chill_char,
    &builtin_type_chill_long,
    &builtin_type_chill_ulong,
    &builtin_type_chill_real,
    0
};

/* Calculate LOWER or UPPER of TYPE.
   Returns the result as an integer.
   *RESULT_TYPE is the appropriate type for the result. */

LONGEST
type_lower_upper (enum exp_opcode op,	/* Either UNOP_LOWER or UNOP_UPPER */
		  struct type *type, struct type **result_type)
{
  LONGEST low, high;
  *result_type = type;
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_STRUCT:
      *result_type = builtin_type_int;
      if (chill_varying_type (type))
	return type_lower_upper (op, TYPE_FIELD_TYPE (type, 1), result_type);
      break;
    case TYPE_CODE_ARRAY:
    case TYPE_CODE_BITSTRING:
    case TYPE_CODE_STRING:
      type = TYPE_FIELD_TYPE (type, 0);		/* Get index type */

      /* ... fall through ... */
    case TYPE_CODE_RANGE:
      *result_type = TYPE_TARGET_TYPE (type);
      return op == UNOP_LOWER ? TYPE_LOW_BOUND (type) : TYPE_HIGH_BOUND (type);

    case TYPE_CODE_ENUM:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_INT:
    case TYPE_CODE_CHAR:
      if (get_discrete_bounds (type, &low, &high) >= 0)
	{
	  *result_type = type;
	  return op == UNOP_LOWER ? low : high;
	}
      break;
    case TYPE_CODE_UNDEF:
    case TYPE_CODE_PTR:
    case TYPE_CODE_UNION:
    case TYPE_CODE_FUNC:
    case TYPE_CODE_FLT:
    case TYPE_CODE_VOID:
    case TYPE_CODE_SET:
    case TYPE_CODE_ERROR:
    case TYPE_CODE_MEMBER:
    case TYPE_CODE_METHOD:
    case TYPE_CODE_REF:
    case TYPE_CODE_COMPLEX:
    default:
      break;
    }
  error ("unknown mode for LOWER/UPPER builtin");
}

static struct value *
value_chill_length (struct value *val)
{
  LONGEST tmp;
  struct type *type = VALUE_TYPE (val);
  struct type *ttype;
  CHECK_TYPEDEF (type);
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_ARRAY:
    case TYPE_CODE_BITSTRING:
    case TYPE_CODE_STRING:
      tmp = type_lower_upper (UNOP_UPPER, type, &ttype)
	- type_lower_upper (UNOP_LOWER, type, &ttype) + 1;
      break;
    case TYPE_CODE_STRUCT:
      if (chill_varying_type (type))
	{
	  tmp = unpack_long (TYPE_FIELD_TYPE (type, 0), VALUE_CONTENTS (val));
	  break;
	}
      /* ... else fall through ... */
    default:
      error ("bad argument to LENGTH builtin");
    }
  return value_from_longest (builtin_type_int, tmp);
}

static struct value *
value_chill_card (struct value *val)
{
  LONGEST tmp = 0;
  struct type *type = VALUE_TYPE (val);
  CHECK_TYPEDEF (type);

  if (TYPE_CODE (type) == TYPE_CODE_SET)
    {
      struct type *range_type = TYPE_INDEX_TYPE (type);
      LONGEST lower_bound, upper_bound;
      int i;

      get_discrete_bounds (range_type, &lower_bound, &upper_bound);
      for (i = lower_bound; i <= upper_bound; i++)
	if (value_bit_index (type, VALUE_CONTENTS (val), i) > 0)
	  tmp++;
    }
  else
    error ("bad argument to CARD builtin");

  return value_from_longest (builtin_type_int, tmp);
}

static struct value *
value_chill_max_min (enum exp_opcode op, struct value *val)
{
  LONGEST tmp = 0;
  struct type *type = VALUE_TYPE (val);
  struct type *elttype;
  CHECK_TYPEDEF (type);

  if (TYPE_CODE (type) == TYPE_CODE_SET)
    {
      LONGEST lower_bound, upper_bound;
      int i, empty = 1;

      elttype = TYPE_INDEX_TYPE (type);
      CHECK_TYPEDEF (elttype);
      get_discrete_bounds (elttype, &lower_bound, &upper_bound);

      if (op == UNOP_CHMAX)
	{
	  for (i = upper_bound; i >= lower_bound; i--)
	    {
	      if (value_bit_index (type, VALUE_CONTENTS (val), i) > 0)
		{
		  tmp = i;
		  empty = 0;
		  break;
		}
	    }
	}
      else
	{
	  for (i = lower_bound; i <= upper_bound; i++)
	    {
	      if (value_bit_index (type, VALUE_CONTENTS (val), i) > 0)
		{
		  tmp = i;
		  empty = 0;
		  break;
		}
	    }
	}
      if (empty)
	error ("%s for empty powerset", op == UNOP_CHMAX ? "MAX" : "MIN");
    }
  else
    error ("bad argument to %s builtin", op == UNOP_CHMAX ? "MAX" : "MIN");

  return value_from_longest (TYPE_CODE (elttype) == TYPE_CODE_RANGE
			     ? TYPE_TARGET_TYPE (elttype)
			     : elttype,
			     tmp);
}

static struct value *
evaluate_subexp_chill (struct type *expect_type,
		       register struct expression *exp, register int *pos,
		       enum noside noside)
{
  int pc = *pos;
  struct type *type;
  int tem, nargs;
  struct value *arg1;
  struct value **argvec;
  enum exp_opcode op = exp->elts[*pos].opcode;
  switch (op)
    {
    case MULTI_SUBSCRIPT:
      if (noside == EVAL_SKIP)
	break;
      (*pos) += 3;
      nargs = longest_to_int (exp->elts[pc + 1].longconst);
      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);
      type = check_typedef (VALUE_TYPE (arg1));

      if (nargs == 1 && TYPE_CODE (type) == TYPE_CODE_INT)
	{
	  /* Looks like string repetition. */
	  struct value *string = evaluate_subexp_with_coercion (exp, pos,
								noside);
	  return value_concat (arg1, string);
	}

      switch (TYPE_CODE (type))
	{
	case TYPE_CODE_PTR:
	  type = check_typedef (TYPE_TARGET_TYPE (type));
	  if (!type || TYPE_CODE (type) != TYPE_CODE_FUNC)
	    error ("reference value used as function");
	  /* ... fall through ... */
	case TYPE_CODE_FUNC:
	  /* It's a function call. */
	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    break;

	  /* Allocate arg vector, including space for the function to be
	     called in argvec[0] and a terminating NULL */
	  argvec = (struct value **) alloca (sizeof (struct value *)
					     * (nargs + 2));
	  argvec[0] = arg1;
	  tem = 1;
	  for (; tem <= nargs && tem <= TYPE_NFIELDS (type); tem++)
	    {
	      argvec[tem]
		= evaluate_subexp_chill (TYPE_FIELD_TYPE (type, tem - 1),
					 exp, pos, noside);
	    }
	  for (; tem <= nargs; tem++)
	    argvec[tem] = evaluate_subexp_with_coercion (exp, pos, noside);
	  argvec[tem] = 0;	/* signal end of arglist */

	  return call_function_by_hand (argvec[0], nargs, argvec + 1);
	default:
	  break;
	}

      while (nargs-- > 0)
	{
	  struct value *index = evaluate_subexp_with_coercion (exp, pos,
							       noside);
	  arg1 = value_subscript (arg1, index);
	}
      return (arg1);

    case UNOP_LOWER:
    case UNOP_UPPER:
      (*pos)++;
      if (noside == EVAL_SKIP)
	{
	  (*exp->language_defn->evaluate_exp) (NULL_TYPE, exp, pos, EVAL_SKIP);
	  goto nosideret;
	}
      arg1 = (*exp->language_defn->evaluate_exp) (NULL_TYPE, exp, pos,
						  EVAL_AVOID_SIDE_EFFECTS);
      tem = type_lower_upper (op, VALUE_TYPE (arg1), &type);
      return value_from_longest (type, tem);

    case UNOP_LENGTH:
      (*pos)++;
      arg1 = (*exp->language_defn->evaluate_exp) (NULL_TYPE, exp, pos, noside);
      return value_chill_length (arg1);

    case UNOP_CARD:
      (*pos)++;
      arg1 = (*exp->language_defn->evaluate_exp) (NULL_TYPE, exp, pos, noside);
      return value_chill_card (arg1);

    case UNOP_CHMAX:
    case UNOP_CHMIN:
      (*pos)++;
      arg1 = (*exp->language_defn->evaluate_exp) (NULL_TYPE, exp, pos, noside);
      return value_chill_max_min (op, arg1);

    case BINOP_COMMA:
      error ("',' operator used in invalid context");

    default:
      break;
    }

  return evaluate_subexp_standard (expect_type, exp, pos, noside);
nosideret:
  return value_from_longest (builtin_type_long, (LONGEST) 1);
}

const struct language_defn chill_language_defn =
{
  "chill",
  language_chill,
  chill_builtin_types,
  range_check_on,
  type_check_on,
  case_sensitive_on,
  chill_parse,			/* parser */
  chill_error,			/* parser error function */
  evaluate_subexp_chill,
  chill_printchar,		/* print a character constant */
  chill_printstr,		/* function to print a string constant */
  NULL,				/* Function to print a single char */
  chill_create_fundamental_type,	/* Create fundamental type in this language */
  chill_print_type,		/* Print a type using appropriate syntax */
  chill_val_print,		/* Print a value using appropriate syntax */
  chill_value_print,		/* Print a top-levl value */
  {"", "B'", "", ""},		/* Binary format info */
  {"O'%lo", "O'", "o", ""},	/* Octal format info */
  {"D'%ld", "D'", "d", ""},	/* Decimal format info */
  {"H'%lx", "H'", "x", ""},	/* Hex format info */
  chill_op_print_tab,		/* expression operators for printing */
  0,				/* arrays are first-class (not c-style) */
  0,				/* String lower bound */
  &builtin_type_chill_char,	/* Type of string elements */
  LANG_MAGIC
};

/* Initialization for Chill */

void
_initialize_chill_language (void)
{
  builtin_type_chill_bool =
    init_type (TYPE_CODE_BOOL, TARGET_CHAR_BIT / TARGET_CHAR_BIT,
	       TYPE_FLAG_UNSIGNED,
	       "BOOL", (struct objfile *) NULL);
  builtin_type_chill_char =
    init_type (TYPE_CODE_CHAR, TARGET_CHAR_BIT / TARGET_CHAR_BIT,
	       TYPE_FLAG_UNSIGNED,
	       "CHAR", (struct objfile *) NULL);
  builtin_type_chill_long =
    init_type (TYPE_CODE_INT, TARGET_LONG_BIT / TARGET_CHAR_BIT,
	       0,
	       "LONG", (struct objfile *) NULL);
  builtin_type_chill_ulong =
    init_type (TYPE_CODE_INT, TARGET_LONG_BIT / TARGET_CHAR_BIT,
	       TYPE_FLAG_UNSIGNED,
	       "ULONG", (struct objfile *) NULL);
  builtin_type_chill_real =
    init_type (TYPE_CODE_FLT, TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
	       0,
	       "LONG_REAL", (struct objfile *) NULL);

  add_language (&chill_language_defn);
}
@


1.9.8.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d1 663
a663 663
// OBSOLETE /* Chill language support routines for GDB, the GNU debugger.
// OBSOLETE    Copyright 1992, 1993, 1994, 1995, 1996, 2000, 2001, 2002
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "gdbtypes.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "expression.h"
// OBSOLETE #include "parser-defs.h"
// OBSOLETE #include "language.h"
// OBSOLETE #include "ch-lang.h"
// OBSOLETE #include "valprint.h"
// OBSOLETE 
// OBSOLETE extern void _initialize_chill_language (void);
// OBSOLETE 
// OBSOLETE static struct value *evaluate_subexp_chill (struct type *, struct expression *,
// OBSOLETE 					    int *, enum noside);
// OBSOLETE 
// OBSOLETE static struct value *value_chill_max_min (enum exp_opcode, struct value *);
// OBSOLETE 
// OBSOLETE static struct value *value_chill_card (struct value *);
// OBSOLETE 
// OBSOLETE static struct value *value_chill_length (struct value *);
// OBSOLETE 
// OBSOLETE static struct type *chill_create_fundamental_type (struct objfile *, int);
// OBSOLETE 
// OBSOLETE static void chill_printstr (struct ui_file * stream, char *string,
// OBSOLETE 			    unsigned int length, int width,
// OBSOLETE 			    int force_ellipses);
// OBSOLETE 
// OBSOLETE static void chill_printchar (int, struct ui_file *);
// OBSOLETE 
// OBSOLETE /* For now, Chill uses a simple mangling algorithm whereby you simply
// OBSOLETE    discard everything after the occurance of two successive CPLUS_MARKER
// OBSOLETE    characters to derive the demangled form. */
// OBSOLETE 
// OBSOLETE char *
// OBSOLETE chill_demangle (const char *mangled)
// OBSOLETE {
// OBSOLETE   const char *joiner = NULL;
// OBSOLETE   char *demangled;
// OBSOLETE   const char *cp = mangled;
// OBSOLETE 
// OBSOLETE   while (*cp)
// OBSOLETE     {
// OBSOLETE       if (is_cplus_marker (*cp))
// OBSOLETE 	{
// OBSOLETE 	  joiner = cp;
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       cp++;
// OBSOLETE     }
// OBSOLETE   if (joiner != NULL && *(joiner + 1) == *joiner)
// OBSOLETE     {
// OBSOLETE       demangled = savestring (mangled, joiner - mangled);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       demangled = NULL;
// OBSOLETE     }
// OBSOLETE   return (demangled);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE chill_printchar (register int c, struct ui_file *stream)
// OBSOLETE {
// OBSOLETE   c &= 0xFF;			/* Avoid sign bit follies */
// OBSOLETE 
// OBSOLETE   if (PRINT_LITERAL_FORM (c))
// OBSOLETE     {
// OBSOLETE       if (c == '\'' || c == '^')
// OBSOLETE 	fprintf_filtered (stream, "'%c%c'", c, c);
// OBSOLETE       else
// OBSOLETE 	fprintf_filtered (stream, "'%c'", c);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       fprintf_filtered (stream, "'^(%u)'", (unsigned int) c);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Print the character string STRING, printing at most LENGTH characters.
// OBSOLETE    Printing stops early if the number hits print_max; repeat counts
// OBSOLETE    are printed as appropriate.  Print ellipses at the end if we
// OBSOLETE    had to stop before printing LENGTH characters, or if FORCE_ELLIPSES.
// OBSOLETE    Note that gdb maintains the length of strings without counting the
// OBSOLETE    terminating null byte, while chill strings are typically written with
// OBSOLETE    an explicit null byte.  So we always assume an implied null byte
// OBSOLETE    until gdb is able to maintain non-null terminated strings as well
// OBSOLETE    as null terminated strings (FIXME).
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE chill_printstr (struct ui_file *stream, char *string, unsigned int length,
// OBSOLETE 		int width, int force_ellipses)
// OBSOLETE {
// OBSOLETE   register unsigned int i;
// OBSOLETE   unsigned int things_printed = 0;
// OBSOLETE   int in_literal_form = 0;
// OBSOLETE   int in_control_form = 0;
// OBSOLETE   int need_slashslash = 0;
// OBSOLETE   unsigned int c;
// OBSOLETE 
// OBSOLETE   if (length == 0)
// OBSOLETE     {
// OBSOLETE       fputs_filtered ("\"\"", stream);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   for (i = 0; i < length && things_printed < print_max; ++i)
// OBSOLETE     {
// OBSOLETE       /* Position of the character we are examining
// OBSOLETE          to see whether it is repeated.  */
// OBSOLETE       unsigned int rep1;
// OBSOLETE       /* Number of repetitions we have detected so far.  */
// OBSOLETE       unsigned int reps;
// OBSOLETE 
// OBSOLETE       QUIT;
// OBSOLETE 
// OBSOLETE       if (need_slashslash)
// OBSOLETE 	{
// OBSOLETE 	  fputs_filtered ("//", stream);
// OBSOLETE 	  need_slashslash = 0;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       rep1 = i + 1;
// OBSOLETE       reps = 1;
// OBSOLETE       while (rep1 < length && string[rep1] == string[i])
// OBSOLETE 	{
// OBSOLETE 	  ++rep1;
// OBSOLETE 	  ++reps;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       c = string[i];
// OBSOLETE       if (reps > repeat_count_threshold)
// OBSOLETE 	{
// OBSOLETE 	  if (in_control_form || in_literal_form)
// OBSOLETE 	    {
// OBSOLETE 	      if (in_control_form)
// OBSOLETE 		fputs_filtered (")", stream);
// OBSOLETE 	      fputs_filtered ("\"//", stream);
// OBSOLETE 	      in_control_form = in_literal_form = 0;
// OBSOLETE 	    }
// OBSOLETE 	  chill_printchar (c, stream);
// OBSOLETE 	  fprintf_filtered (stream, "<repeats %u times>", reps);
// OBSOLETE 	  i = rep1 - 1;
// OBSOLETE 	  things_printed += repeat_count_threshold;
// OBSOLETE 	  need_slashslash = 1;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (!in_literal_form && !in_control_form)
// OBSOLETE 	    fputs_filtered ("\"", stream);
// OBSOLETE 	  if (PRINT_LITERAL_FORM (c))
// OBSOLETE 	    {
// OBSOLETE 	      if (!in_literal_form)
// OBSOLETE 		{
// OBSOLETE 		  if (in_control_form)
// OBSOLETE 		    {
// OBSOLETE 		      fputs_filtered (")", stream);
// OBSOLETE 		      in_control_form = 0;
// OBSOLETE 		    }
// OBSOLETE 		  in_literal_form = 1;
// OBSOLETE 		}
// OBSOLETE 	      fprintf_filtered (stream, "%c", c);
// OBSOLETE 	      if (c == '"' || c == '^')
// OBSOLETE 		/* duplicate this one as must be done at input */
// OBSOLETE 		fprintf_filtered (stream, "%c", c);
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      if (!in_control_form)
// OBSOLETE 		{
// OBSOLETE 		  if (in_literal_form)
// OBSOLETE 		    {
// OBSOLETE 		      in_literal_form = 0;
// OBSOLETE 		    }
// OBSOLETE 		  fputs_filtered ("^(", stream);
// OBSOLETE 		  in_control_form = 1;
// OBSOLETE 		}
// OBSOLETE 	      else
// OBSOLETE 		fprintf_filtered (stream, ",");
// OBSOLETE 	      c = c & 0xff;
// OBSOLETE 	      fprintf_filtered (stream, "%u", (unsigned int) c);
// OBSOLETE 	    }
// OBSOLETE 	  ++things_printed;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Terminate the quotes if necessary.  */
// OBSOLETE   if (in_control_form)
// OBSOLETE     {
// OBSOLETE       fputs_filtered (")", stream);
// OBSOLETE     }
// OBSOLETE   if (in_literal_form || in_control_form)
// OBSOLETE     {
// OBSOLETE       fputs_filtered ("\"", stream);
// OBSOLETE     }
// OBSOLETE   if (force_ellipses || (i < length))
// OBSOLETE     {
// OBSOLETE       fputs_filtered ("...", stream);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct type *
// OBSOLETE chill_create_fundamental_type (struct objfile *objfile, int typeid)
// OBSOLETE {
// OBSOLETE   register struct type *type = NULL;
// OBSOLETE 
// OBSOLETE   switch (typeid)
// OBSOLETE     {
// OBSOLETE     default:
// OBSOLETE       /* FIXME:  For now, if we are asked to produce a type not in this
// OBSOLETE          language, create the equivalent of a C integer type with the
// OBSOLETE          name "<?type?>".  When all the dust settles from the type
// OBSOLETE          reconstruction work, this should probably become an error. */
// OBSOLETE       type = init_type (TYPE_CODE_INT, 2, 0, "<?type?>", objfile);
// OBSOLETE       warning ("internal error: no chill fundamental type %d", typeid);
// OBSOLETE       break;
// OBSOLETE     case FT_VOID:
// OBSOLETE       /* FIXME:  Currently the GNU Chill compiler emits some DWARF entries for
// OBSOLETE          typedefs, unrelated to anything directly in the code being compiled,
// OBSOLETE          that have some FT_VOID types.  Just fake it for now. */
// OBSOLETE       type = init_type (TYPE_CODE_VOID, 0, 0, "<?VOID?>", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_BOOLEAN:
// OBSOLETE       type = init_type (TYPE_CODE_BOOL, 1, TYPE_FLAG_UNSIGNED, "BOOL", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_CHAR:
// OBSOLETE       type = init_type (TYPE_CODE_CHAR, 1, TYPE_FLAG_UNSIGNED, "CHAR", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_SIGNED_CHAR:
// OBSOLETE       type = init_type (TYPE_CODE_INT, 1, 0, "BYTE", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_UNSIGNED_CHAR:
// OBSOLETE       type = init_type (TYPE_CODE_INT, 1, TYPE_FLAG_UNSIGNED, "UBYTE", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_SHORT:		/* Chill ints are 2 bytes */
// OBSOLETE       type = init_type (TYPE_CODE_INT, 2, 0, "INT", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_UNSIGNED_SHORT:	/* Chill ints are 2 bytes */
// OBSOLETE       type = init_type (TYPE_CODE_INT, 2, TYPE_FLAG_UNSIGNED, "UINT", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_INTEGER:		/* FIXME? */
// OBSOLETE     case FT_SIGNED_INTEGER:	/* FIXME? */
// OBSOLETE     case FT_LONG:		/* Chill longs are 4 bytes */
// OBSOLETE     case FT_SIGNED_LONG:	/* Chill longs are 4 bytes */
// OBSOLETE       type = init_type (TYPE_CODE_INT, 4, 0, "LONG", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_UNSIGNED_INTEGER:	/* FIXME? */
// OBSOLETE     case FT_UNSIGNED_LONG:	/* Chill longs are 4 bytes */
// OBSOLETE       type = init_type (TYPE_CODE_INT, 4, TYPE_FLAG_UNSIGNED, "ULONG", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_FLOAT:
// OBSOLETE       type = init_type (TYPE_CODE_FLT, 4, 0, "REAL", objfile);
// OBSOLETE       break;
// OBSOLETE     case FT_DBL_PREC_FLOAT:
// OBSOLETE       type = init_type (TYPE_CODE_FLT, 8, 0, "LONG_REAL", objfile);
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE   return (type);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Table of operators and their precedences for printing expressions.  */
// OBSOLETE 
// OBSOLETE static const struct op_print chill_op_print_tab[] =
// OBSOLETE {
// OBSOLETE   {"AND", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},
// OBSOLETE   {"OR", BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},
// OBSOLETE   {"NOT", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},
// OBSOLETE   {"MOD", BINOP_MOD, PREC_MUL, 0},
// OBSOLETE   {"REM", BINOP_REM, PREC_MUL, 0},
// OBSOLETE   {"SIZE", UNOP_SIZEOF, PREC_BUILTIN_FUNCTION, 0},
// OBSOLETE   {"LOWER", UNOP_LOWER, PREC_BUILTIN_FUNCTION, 0},
// OBSOLETE   {"UPPER", UNOP_UPPER, PREC_BUILTIN_FUNCTION, 0},
// OBSOLETE   {"CARD", UNOP_CARD, PREC_BUILTIN_FUNCTION, 0},
// OBSOLETE   {"MAX", UNOP_CHMAX, PREC_BUILTIN_FUNCTION, 0},
// OBSOLETE   {"MIN", UNOP_CHMIN, PREC_BUILTIN_FUNCTION, 0},
// OBSOLETE   {":=", BINOP_ASSIGN, PREC_ASSIGN, 1},
// OBSOLETE   {"=", BINOP_EQUAL, PREC_EQUAL, 0},
// OBSOLETE   {"/=", BINOP_NOTEQUAL, PREC_EQUAL, 0},
// OBSOLETE   {"<=", BINOP_LEQ, PREC_ORDER, 0},
// OBSOLETE   {">=", BINOP_GEQ, PREC_ORDER, 0},
// OBSOLETE   {">", BINOP_GTR, PREC_ORDER, 0},
// OBSOLETE   {"<", BINOP_LESS, PREC_ORDER, 0},
// OBSOLETE   {"+", BINOP_ADD, PREC_ADD, 0},
// OBSOLETE   {"-", BINOP_SUB, PREC_ADD, 0},
// OBSOLETE   {"*", BINOP_MUL, PREC_MUL, 0},
// OBSOLETE   {"/", BINOP_DIV, PREC_MUL, 0},
// OBSOLETE   {"//", BINOP_CONCAT, PREC_PREFIX, 0},		/* FIXME: precedence? */
// OBSOLETE   {"-", UNOP_NEG, PREC_PREFIX, 0},
// OBSOLETE   {"->", UNOP_IND, PREC_SUFFIX, 1},
// OBSOLETE   {"->", UNOP_ADDR, PREC_PREFIX, 0},
// OBSOLETE   {":", BINOP_RANGE, PREC_ASSIGN, 0},
// OBSOLETE   {NULL, 0, 0, 0}
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* The built-in types of Chill.  */
// OBSOLETE 
// OBSOLETE struct type *builtin_type_chill_bool;
// OBSOLETE struct type *builtin_type_chill_char;
// OBSOLETE struct type *builtin_type_chill_long;
// OBSOLETE struct type *builtin_type_chill_ulong;
// OBSOLETE struct type *builtin_type_chill_real;
// OBSOLETE 
// OBSOLETE struct type **const (chill_builtin_types[]) =
// OBSOLETE {
// OBSOLETE   &builtin_type_chill_bool,
// OBSOLETE     &builtin_type_chill_char,
// OBSOLETE     &builtin_type_chill_long,
// OBSOLETE     &builtin_type_chill_ulong,
// OBSOLETE     &builtin_type_chill_real,
// OBSOLETE     0
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* Calculate LOWER or UPPER of TYPE.
// OBSOLETE    Returns the result as an integer.
// OBSOLETE    *RESULT_TYPE is the appropriate type for the result. */
// OBSOLETE 
// OBSOLETE LONGEST
// OBSOLETE type_lower_upper (enum exp_opcode op,	/* Either UNOP_LOWER or UNOP_UPPER */
// OBSOLETE 		  struct type *type, struct type **result_type)
// OBSOLETE {
// OBSOLETE   LONGEST low, high;
// OBSOLETE   *result_type = type;
// OBSOLETE   CHECK_TYPEDEF (type);
// OBSOLETE   switch (TYPE_CODE (type))
// OBSOLETE     {
// OBSOLETE     case TYPE_CODE_STRUCT:
// OBSOLETE       *result_type = builtin_type_int;
// OBSOLETE       if (chill_varying_type (type))
// OBSOLETE 	return type_lower_upper (op, TYPE_FIELD_TYPE (type, 1), result_type);
// OBSOLETE       break;
// OBSOLETE     case TYPE_CODE_ARRAY:
// OBSOLETE     case TYPE_CODE_BITSTRING:
// OBSOLETE     case TYPE_CODE_STRING:
// OBSOLETE       type = TYPE_FIELD_TYPE (type, 0);		/* Get index type */
// OBSOLETE 
// OBSOLETE       /* ... fall through ... */
// OBSOLETE     case TYPE_CODE_RANGE:
// OBSOLETE       *result_type = TYPE_TARGET_TYPE (type);
// OBSOLETE       return op == UNOP_LOWER ? TYPE_LOW_BOUND (type) : TYPE_HIGH_BOUND (type);
// OBSOLETE 
// OBSOLETE     case TYPE_CODE_ENUM:
// OBSOLETE     case TYPE_CODE_BOOL:
// OBSOLETE     case TYPE_CODE_INT:
// OBSOLETE     case TYPE_CODE_CHAR:
// OBSOLETE       if (get_discrete_bounds (type, &low, &high) >= 0)
// OBSOLETE 	{
// OBSOLETE 	  *result_type = type;
// OBSOLETE 	  return op == UNOP_LOWER ? low : high;
// OBSOLETE 	}
// OBSOLETE       break;
// OBSOLETE     case TYPE_CODE_UNDEF:
// OBSOLETE     case TYPE_CODE_PTR:
// OBSOLETE     case TYPE_CODE_UNION:
// OBSOLETE     case TYPE_CODE_FUNC:
// OBSOLETE     case TYPE_CODE_FLT:
// OBSOLETE     case TYPE_CODE_VOID:
// OBSOLETE     case TYPE_CODE_SET:
// OBSOLETE     case TYPE_CODE_ERROR:
// OBSOLETE     case TYPE_CODE_MEMBER:
// OBSOLETE     case TYPE_CODE_METHOD:
// OBSOLETE     case TYPE_CODE_REF:
// OBSOLETE     case TYPE_CODE_COMPLEX:
// OBSOLETE     default:
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE   error ("unknown mode for LOWER/UPPER builtin");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct value *
// OBSOLETE value_chill_length (struct value *val)
// OBSOLETE {
// OBSOLETE   LONGEST tmp;
// OBSOLETE   struct type *type = VALUE_TYPE (val);
// OBSOLETE   struct type *ttype;
// OBSOLETE   CHECK_TYPEDEF (type);
// OBSOLETE   switch (TYPE_CODE (type))
// OBSOLETE     {
// OBSOLETE     case TYPE_CODE_ARRAY:
// OBSOLETE     case TYPE_CODE_BITSTRING:
// OBSOLETE     case TYPE_CODE_STRING:
// OBSOLETE       tmp = type_lower_upper (UNOP_UPPER, type, &ttype)
// OBSOLETE 	- type_lower_upper (UNOP_LOWER, type, &ttype) + 1;
// OBSOLETE       break;
// OBSOLETE     case TYPE_CODE_STRUCT:
// OBSOLETE       if (chill_varying_type (type))
// OBSOLETE 	{
// OBSOLETE 	  tmp = unpack_long (TYPE_FIELD_TYPE (type, 0), VALUE_CONTENTS (val));
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       /* ... else fall through ... */
// OBSOLETE     default:
// OBSOLETE       error ("bad argument to LENGTH builtin");
// OBSOLETE     }
// OBSOLETE   return value_from_longest (builtin_type_int, tmp);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct value *
// OBSOLETE value_chill_card (struct value *val)
// OBSOLETE {
// OBSOLETE   LONGEST tmp = 0;
// OBSOLETE   struct type *type = VALUE_TYPE (val);
// OBSOLETE   CHECK_TYPEDEF (type);
// OBSOLETE 
// OBSOLETE   if (TYPE_CODE (type) == TYPE_CODE_SET)
// OBSOLETE     {
// OBSOLETE       struct type *range_type = TYPE_INDEX_TYPE (type);
// OBSOLETE       LONGEST lower_bound, upper_bound;
// OBSOLETE       int i;
// OBSOLETE 
// OBSOLETE       get_discrete_bounds (range_type, &lower_bound, &upper_bound);
// OBSOLETE       for (i = lower_bound; i <= upper_bound; i++)
// OBSOLETE 	if (value_bit_index (type, VALUE_CONTENTS (val), i) > 0)
// OBSOLETE 	  tmp++;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     error ("bad argument to CARD builtin");
// OBSOLETE 
// OBSOLETE   return value_from_longest (builtin_type_int, tmp);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct value *
// OBSOLETE value_chill_max_min (enum exp_opcode op, struct value *val)
// OBSOLETE {
// OBSOLETE   LONGEST tmp = 0;
// OBSOLETE   struct type *type = VALUE_TYPE (val);
// OBSOLETE   struct type *elttype;
// OBSOLETE   CHECK_TYPEDEF (type);
// OBSOLETE 
// OBSOLETE   if (TYPE_CODE (type) == TYPE_CODE_SET)
// OBSOLETE     {
// OBSOLETE       LONGEST lower_bound, upper_bound;
// OBSOLETE       int i, empty = 1;
// OBSOLETE 
// OBSOLETE       elttype = TYPE_INDEX_TYPE (type);
// OBSOLETE       CHECK_TYPEDEF (elttype);
// OBSOLETE       get_discrete_bounds (elttype, &lower_bound, &upper_bound);
// OBSOLETE 
// OBSOLETE       if (op == UNOP_CHMAX)
// OBSOLETE 	{
// OBSOLETE 	  for (i = upper_bound; i >= lower_bound; i--)
// OBSOLETE 	    {
// OBSOLETE 	      if (value_bit_index (type, VALUE_CONTENTS (val), i) > 0)
// OBSOLETE 		{
// OBSOLETE 		  tmp = i;
// OBSOLETE 		  empty = 0;
// OBSOLETE 		  break;
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  for (i = lower_bound; i <= upper_bound; i++)
// OBSOLETE 	    {
// OBSOLETE 	      if (value_bit_index (type, VALUE_CONTENTS (val), i) > 0)
// OBSOLETE 		{
// OBSOLETE 		  tmp = i;
// OBSOLETE 		  empty = 0;
// OBSOLETE 		  break;
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       if (empty)
// OBSOLETE 	error ("%s for empty powerset", op == UNOP_CHMAX ? "MAX" : "MIN");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     error ("bad argument to %s builtin", op == UNOP_CHMAX ? "MAX" : "MIN");
// OBSOLETE 
// OBSOLETE   return value_from_longest (TYPE_CODE (elttype) == TYPE_CODE_RANGE
// OBSOLETE 			     ? TYPE_TARGET_TYPE (elttype)
// OBSOLETE 			     : elttype,
// OBSOLETE 			     tmp);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct value *
// OBSOLETE evaluate_subexp_chill (struct type *expect_type,
// OBSOLETE 		       register struct expression *exp, register int *pos,
// OBSOLETE 		       enum noside noside)
// OBSOLETE {
// OBSOLETE   int pc = *pos;
// OBSOLETE   struct type *type;
// OBSOLETE   int tem, nargs;
// OBSOLETE   struct value *arg1;
// OBSOLETE   struct value **argvec;
// OBSOLETE   enum exp_opcode op = exp->elts[*pos].opcode;
// OBSOLETE   switch (op)
// OBSOLETE     {
// OBSOLETE     case MULTI_SUBSCRIPT:
// OBSOLETE       if (noside == EVAL_SKIP)
// OBSOLETE 	break;
// OBSOLETE       (*pos) += 3;
// OBSOLETE       nargs = longest_to_int (exp->elts[pc + 1].longconst);
// OBSOLETE       arg1 = evaluate_subexp_with_coercion (exp, pos, noside);
// OBSOLETE       type = check_typedef (VALUE_TYPE (arg1));
// OBSOLETE 
// OBSOLETE       if (nargs == 1 && TYPE_CODE (type) == TYPE_CODE_INT)
// OBSOLETE 	{
// OBSOLETE 	  /* Looks like string repetition. */
// OBSOLETE 	  struct value *string = evaluate_subexp_with_coercion (exp, pos,
// OBSOLETE 								noside);
// OBSOLETE 	  return value_concat (arg1, string);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       switch (TYPE_CODE (type))
// OBSOLETE 	{
// OBSOLETE 	case TYPE_CODE_PTR:
// OBSOLETE 	  type = check_typedef (TYPE_TARGET_TYPE (type));
// OBSOLETE 	  if (!type || TYPE_CODE (type) != TYPE_CODE_FUNC)
// OBSOLETE 	    error ("reference value used as function");
// OBSOLETE 	  /* ... fall through ... */
// OBSOLETE 	case TYPE_CODE_FUNC:
// OBSOLETE 	  /* It's a function call. */
// OBSOLETE 	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
// OBSOLETE 	    break;
// OBSOLETE 
// OBSOLETE 	  /* Allocate arg vector, including space for the function to be
// OBSOLETE 	     called in argvec[0] and a terminating NULL */
// OBSOLETE 	  argvec = (struct value **) alloca (sizeof (struct value *)
// OBSOLETE 					     * (nargs + 2));
// OBSOLETE 	  argvec[0] = arg1;
// OBSOLETE 	  tem = 1;
// OBSOLETE 	  for (; tem <= nargs && tem <= TYPE_NFIELDS (type); tem++)
// OBSOLETE 	    {
// OBSOLETE 	      argvec[tem]
// OBSOLETE 		= evaluate_subexp_chill (TYPE_FIELD_TYPE (type, tem - 1),
// OBSOLETE 					 exp, pos, noside);
// OBSOLETE 	    }
// OBSOLETE 	  for (; tem <= nargs; tem++)
// OBSOLETE 	    argvec[tem] = evaluate_subexp_with_coercion (exp, pos, noside);
// OBSOLETE 	  argvec[tem] = 0;	/* signal end of arglist */
// OBSOLETE 
// OBSOLETE 	  return call_function_by_hand (argvec[0], nargs, argvec + 1);
// OBSOLETE 	default:
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       while (nargs-- > 0)
// OBSOLETE 	{
// OBSOLETE 	  struct value *index = evaluate_subexp_with_coercion (exp, pos,
// OBSOLETE 							       noside);
// OBSOLETE 	  arg1 = value_subscript (arg1, index);
// OBSOLETE 	}
// OBSOLETE       return (arg1);
// OBSOLETE 
// OBSOLETE     case UNOP_LOWER:
// OBSOLETE     case UNOP_UPPER:
// OBSOLETE       (*pos)++;
// OBSOLETE       if (noside == EVAL_SKIP)
// OBSOLETE 	{
// OBSOLETE 	  (*exp->language_defn->evaluate_exp) (NULL_TYPE, exp, pos, EVAL_SKIP);
// OBSOLETE 	  goto nosideret;
// OBSOLETE 	}
// OBSOLETE       arg1 = (*exp->language_defn->evaluate_exp) (NULL_TYPE, exp, pos,
// OBSOLETE 						  EVAL_AVOID_SIDE_EFFECTS);
// OBSOLETE       tem = type_lower_upper (op, VALUE_TYPE (arg1), &type);
// OBSOLETE       return value_from_longest (type, tem);
// OBSOLETE 
// OBSOLETE     case UNOP_LENGTH:
// OBSOLETE       (*pos)++;
// OBSOLETE       arg1 = (*exp->language_defn->evaluate_exp) (NULL_TYPE, exp, pos, noside);
// OBSOLETE       return value_chill_length (arg1);
// OBSOLETE 
// OBSOLETE     case UNOP_CARD:
// OBSOLETE       (*pos)++;
// OBSOLETE       arg1 = (*exp->language_defn->evaluate_exp) (NULL_TYPE, exp, pos, noside);
// OBSOLETE       return value_chill_card (arg1);
// OBSOLETE 
// OBSOLETE     case UNOP_CHMAX:
// OBSOLETE     case UNOP_CHMIN:
// OBSOLETE       (*pos)++;
// OBSOLETE       arg1 = (*exp->language_defn->evaluate_exp) (NULL_TYPE, exp, pos, noside);
// OBSOLETE       return value_chill_max_min (op, arg1);
// OBSOLETE 
// OBSOLETE     case BINOP_COMMA:
// OBSOLETE       error ("',' operator used in invalid context");
// OBSOLETE 
// OBSOLETE     default:
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return evaluate_subexp_standard (expect_type, exp, pos, noside);
// OBSOLETE nosideret:
// OBSOLETE   return value_from_longest (builtin_type_long, (LONGEST) 1);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE const struct language_defn chill_language_defn =
// OBSOLETE {
// OBSOLETE   "chill",
// OBSOLETE   language_chill,
// OBSOLETE   chill_builtin_types,
// OBSOLETE   range_check_on,
// OBSOLETE   type_check_on,
// OBSOLETE   case_sensitive_on,
// OBSOLETE   chill_parse,			/* parser */
// OBSOLETE   chill_error,			/* parser error function */
// OBSOLETE   evaluate_subexp_chill,
// OBSOLETE   chill_printchar,		/* print a character constant */
// OBSOLETE   chill_printstr,		/* function to print a string constant */
// OBSOLETE   NULL,				/* Function to print a single char */
// OBSOLETE   chill_create_fundamental_type,	/* Create fundamental type in this language */
// OBSOLETE   chill_print_type,		/* Print a type using appropriate syntax */
// OBSOLETE   chill_val_print,		/* Print a value using appropriate syntax */
// OBSOLETE   chill_value_print,		/* Print a top-levl value */
// OBSOLETE   {"", "B'", "", ""},		/* Binary format info */
// OBSOLETE   {"O'%lo", "O'", "o", ""},	/* Octal format info */
// OBSOLETE   {"D'%ld", "D'", "d", ""},	/* Decimal format info */
// OBSOLETE   {"H'%lx", "H'", "x", ""},	/* Hex format info */
// OBSOLETE   chill_op_print_tab,		/* expression operators for printing */
// OBSOLETE   0,				/* arrays are first-class (not c-style) */
// OBSOLETE   0,				/* String lower bound */
// OBSOLETE   &builtin_type_chill_char,	/* Type of string elements */
// OBSOLETE   LANG_MAGIC
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* Initialization for Chill */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_chill_language (void)
// OBSOLETE {
// OBSOLETE   builtin_type_chill_bool =
// OBSOLETE     init_type (TYPE_CODE_BOOL, TARGET_CHAR_BIT / TARGET_CHAR_BIT,
// OBSOLETE 	       TYPE_FLAG_UNSIGNED,
// OBSOLETE 	       "BOOL", (struct objfile *) NULL);
// OBSOLETE   builtin_type_chill_char =
// OBSOLETE     init_type (TYPE_CODE_CHAR, TARGET_CHAR_BIT / TARGET_CHAR_BIT,
// OBSOLETE 	       TYPE_FLAG_UNSIGNED,
// OBSOLETE 	       "CHAR", (struct objfile *) NULL);
// OBSOLETE   builtin_type_chill_long =
// OBSOLETE     init_type (TYPE_CODE_INT, TARGET_LONG_BIT / TARGET_CHAR_BIT,
// OBSOLETE 	       0,
// OBSOLETE 	       "LONG", (struct objfile *) NULL);
// OBSOLETE   builtin_type_chill_ulong =
// OBSOLETE     init_type (TYPE_CODE_INT, TARGET_LONG_BIT / TARGET_CHAR_BIT,
// OBSOLETE 	       TYPE_FLAG_UNSIGNED,
// OBSOLETE 	       "ULONG", (struct objfile *) NULL);
// OBSOLETE   builtin_type_chill_real =
// OBSOLETE     init_type (TYPE_CODE_FLT, TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
// OBSOLETE 	       0,
// OBSOLETE 	       "LONG_REAL", (struct objfile *) NULL);
// OBSOLETE 
// OBSOLETE   add_language (&chill_language_defn);
// OBSOLETE }
@


1.8
log
@* cli/cli-script.c (execute_control_command): Replace value_ptr
with a struct value pointer.
* ch-lang.c (evaluate_subexp_chill): Ditto.
* printcmd.c (printf_command): Ditto.
* tracepoint.c (set_traceframe_context): Ditto.
(encode_actions): Ditto.
* eval.c (evaluate_subexp_standard): Ditto.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 2000, 2001
d325 1
a325 1
struct type **CONST_PTR (chill_builtin_types[]) =
@


1.7
log
@s/value_ptr/struct value */
@
text
@d539 2
a540 1
	  argvec = (value_ptr *) alloca (sizeof (value_ptr) * (nargs + 2));
@


1.6
log
@Update/correct copyright notices.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 2000
d34 2
a35 3
static value_ptr
evaluate_subexp_chill (struct type *, struct expression *, int *,
		       enum noside);
d37 1
a37 1
static value_ptr value_chill_max_min (enum exp_opcode, value_ptr);
d39 1
a39 1
static value_ptr value_chill_card (value_ptr);
d41 1
a41 1
static value_ptr value_chill_length (value_ptr);
d391 2
a392 2
static value_ptr
value_chill_length (value_ptr val)
d419 2
a420 2
static value_ptr
value_chill_card (value_ptr val)
d443 2
a444 2
static value_ptr
value_chill_max_min (enum exp_opcode op, value_ptr val)
d496 1
a496 1
static value_ptr
d504 2
a505 2
  value_ptr arg1;
  value_ptr *argvec;
d520 2
a521 1
	  value_ptr string = evaluate_subexp_with_coercion (exp, pos, noside);
d559 2
a560 1
	  value_ptr index = evaluate_subexp_with_coercion (exp, pos, noside);
@


1.6.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@a226 1
  
d232 5
a237 1
      type = NULL;
d240 4
a243 1
        type = (struct type *) make_void_type (objfile, "VOID");
d246 1
a246 1
      type = (struct type *) make_boolean_type (objfile, "BOOL");
d249 1
a249 1
      type = (struct type *) make_character_type (objfile, "CHAR", 1, ST_unsigned);
d252 1
a252 1
      type = (struct type *) make_integer_type (objfile, "BYTE", 1, ST_signed);
d255 1
a255 1
      type = (struct type *) make_integer_type (objfile, "UBYTE", 1, ST_unsigned);
d258 1
a258 1
      type = (struct type *) make_integer_type (objfile, "INT", 2, ST_signed);
d261 1
a261 1
      type = (struct type *) make_integer_type (objfile, "UINT", 2, ST_unsigned);
d267 1
a267 1
      type = (struct type *) make_integer_type (objfile, "LONG", 4, ST_signed);
d271 1
a271 1
      type = (struct type *) make_integer_type (objfile, "ULONG", 4, ST_unsigned);
d354 1
a354 1
      /* TYPEFIX - Check if bitstring is really *always a set* */
a355 3
      type = (struct type *) SET_RANGE_TYPE (type);
      /* ... fall through ... */
    case TYPE_CODE_ARRAY:
d357 1
a357 1
      type = (struct type *) ARRAY_RANGE_TYPE (type);		/* Get index type */
d361 2
a362 2
      *result_type = RANGE_INDEX_TYPE (type);
      return op == UNOP_LOWER ? RANGE_LOWER_BOUND (type) : RANGE_UPPER_BOUND (type);
a367 1
#if TYPEFIX
a373 3
#else
      break;
#endif
d426 1
d429 1
a429 1
      struct range_type *range_type = SET_RANGE_TYPE (type);
d433 1
a433 2
      lower_bound = RANGE_LOWER_BOUND (range_type);
      upper_bound = RANGE_UPPER_BOUND (range_type);
d449 1
a449 1
  struct range_type *elttype;
d451 1
d457 3
a459 4
      elttype = SET_RANGE_TYPE (type);
      CHECK_TYPEDEF ((struct type *)elttype);
      lower_bound = RANGE_LOWER_BOUND (elttype);
      upper_bound = RANGE_UPPER_BOUND (elttype);
d492 2
a493 2
			     ? (struct type *)RANGE_INDEX_TYPE (elttype)
			     : (struct type *)elttype,
d528 1
a528 1
	  type = check_typedef (POINTER_TARGET_TYPE (type));
d542 1
a542 1
	  for (; tem <= nargs && tem <= FUNCTION_NUM_ARGUMENTS (type); tem++)
d545 1
a545 1
		= evaluate_subexp_chill (FUNCTION_ARGUMENT_TYPE (type, tem),
d639 16
a654 4
  builtin_type_chill_bool = (struct type *) make_boolean_type (NULL, "BOOL");
  builtin_type_chill_char = (struct type *) make_character_type (NULL, "CHAR", 1, ST_unsigned);
  builtin_type_chill_long = (struct type *) make_integer_type (NULL, "LONG", TARGET_LONG_BIT / TARGET_CHAR_BIT, ST_signed);
  builtin_type_chill_ulong = (struct type *) make_integer_type (NULL, "ULONG", TARGET_LONG_BIT / TARGET_CHAR_BIT, ST_unsigned);
@


1.5
log
@2000-08-10	Jimmy Guo	<guo@@cup.hp.com>

	* c-lang.c: Set case sensitivity on for c_language_defn,
	cplus_language_defn, and asm_language_defn.
	* ch-lang.c: Set case sensitivity on for chill_language_defn.
	* f-lang.c: Set case sensivitity off for f_language_defn.
	* jv-lang.c: Set case sensitivity on for java_language_defn.
	* language.h: Add enum case_mode, case_sensitivity.
	* language.c: Define case_mode, case_sensitivity.  Set case
	sensitivity on for unknown_language_defn, auto_language_defn,
	and local_language_defn.
	(show_case_command,set_case_command,set_case_str): New static func.
	(set_type_range_case): New static func, replaces set_type_range ().
	(set_language_command,set_type_command,set_range_command,set_language):
	Call set_type_range_case ().
	(language_info): Print case sensitivity setting.
	(_initialize_language): Add set/show commands for 'case-sensitive'.
	Set default case mode 'auto'.  Set default language 'auto'.
	* m2-lang.c: Set case sensitivity on for m2_language_defn.
	* p-lang.c: Set case sensitivity on for pascal_language_defn.
	* scm-lang.c: Set case sensitivity off for scm_language_defn.
	* symtab.c (lookup_symbol): Downcase symbol name if case sensivitity
	is off.
@
text
@d2 2
a3 1
   Copyright 1992, 1995, 1996, 2000 Free Software Foundation, Inc.
@


1.4
log
@Protoization.
@
text
@d611 1
@


1.3
log
@PARAMS removal.
@
text
@d56 1
a56 2
chill_demangle (mangled)
     const char *mangled;
d83 1
a83 3
chill_printchar (c, stream)
     register int c;
     struct ui_file *stream;
d112 2
a113 6
chill_printstr (stream, string, length, width, force_ellipses)
     struct ui_file *stream;
     char *string;
     unsigned int length;
     int width;
     int force_ellipses;
d224 1
a224 3
chill_create_fundamental_type (objfile, typeid)
     struct objfile *objfile;
     int typeid;
d340 2
a341 4
type_lower_upper (op, type, result_type)
     enum exp_opcode op;	/* Either UNOP_LOWER or UNOP_UPPER */
     struct type *type;
     struct type **result_type;
d392 1
a392 2
value_chill_length (val)
     value_ptr val;
d420 1
a420 2
value_chill_card (val)
     value_ptr val;
d444 1
a444 3
value_chill_max_min (op, val)
     enum exp_opcode op;
     value_ptr val;
d497 3
a499 5
evaluate_subexp_chill (expect_type, exp, pos, noside)
     struct type *expect_type;
     register struct expression *exp;
     register int *pos;
     enum noside noside;
d635 1
a635 1
_initialize_chill_language ()
@


1.2
log
@	Clean up compiler warnings:
	* bcache.h, bcache.c, c-valprint.c, coffread.c, stabsread.c,
	stack.c, valprint.c: Change variables to unsigned.
	* bcache.c: Rearrange to avoid warnings about variables not being set.
	* c-lang.c, ch-lang.c, f-lang.c, m2-lang.c: Include valprint.h
	rather than declaring print_max and repeat_count_threashold
	ourselves (incorrectly).
	* valprint.h: Do declare repeat_count_threashold.
	* ch-exp.c: Use default case for internal error.
	* findvar.c: Don't omit argument type.
	* symtab.c: Remove unused variable.
@
text
@d31 1
a31 1
extern void _initialize_chill_language PARAMS ((void));
d34 2
a35 1
  evaluate_subexp_chill PARAMS ((struct type *, struct expression *, int *, enum noside));
d37 1
a37 2
static value_ptr
  value_chill_max_min PARAMS ((enum exp_opcode, value_ptr));
d39 1
a39 2
static value_ptr
  value_chill_card PARAMS ((value_ptr));
d41 1
a41 2
static value_ptr
  value_chill_length PARAMS ((value_ptr));
d43 1
a43 2
static struct type *
  chill_create_fundamental_type PARAMS ((struct objfile *, int));
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1992, 1995, 1996 Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d29 3
d34 1
a34 1
evaluate_subexp_chill PARAMS ((struct type *, struct expression *, int *, enum noside));
d37 1
a37 1
value_chill_max_min PARAMS ((enum exp_opcode, value_ptr));
d40 1
a40 1
value_chill_card PARAMS ((value_ptr));
d43 1
a43 1
 value_chill_length PARAMS ((value_ptr));
d46 1
a46 1
chill_create_fundamental_type PARAMS ((struct objfile *, int));
d48 3
a50 2
static void
chill_printstr PARAMS ((GDB_FILE *stream, char *string, unsigned int length, int width, int force_ellipses));
d52 1
a52 2
static void
chill_printchar PARAMS ((int, GDB_FILE *));
d89 1
a89 1
     GDB_FILE *stream;
d115 1
a115 1
  */
d119 1
a119 1
     GDB_FILE *stream;
a130 2
  extern int repeat_count_threshold;
  extern int print_max;
d141 1
a141 1
	 to see whether it is repeated.  */
d180 1
a180 1
	  if (! in_literal_form && ! in_control_form)
d242 49
a290 49
      default:
	/* FIXME:  For now, if we are asked to produce a type not in this
	   language, create the equivalent of a C integer type with the
	   name "<?type?>".  When all the dust settles from the type
	   reconstruction work, this should probably become an error. */
	type = init_type (TYPE_CODE_INT, 2, 0, "<?type?>", objfile);
        warning ("internal error: no chill fundamental type %d", typeid);
	break;
      case FT_VOID:
	/* FIXME:  Currently the GNU Chill compiler emits some DWARF entries for
	   typedefs, unrelated to anything directly in the code being compiled,
	   that have some FT_VOID types.  Just fake it for now. */
	type = init_type (TYPE_CODE_VOID, 0, 0, "<?VOID?>", objfile);
	break;
      case FT_BOOLEAN:
	type = init_type (TYPE_CODE_BOOL, 1, TYPE_FLAG_UNSIGNED, "BOOL", objfile);
	break;
      case FT_CHAR:
	type = init_type (TYPE_CODE_CHAR, 1, TYPE_FLAG_UNSIGNED, "CHAR", objfile);
	break;
      case FT_SIGNED_CHAR:
	type = init_type (TYPE_CODE_INT, 1, 0, "BYTE", objfile);
	break;
      case FT_UNSIGNED_CHAR:
	type = init_type (TYPE_CODE_INT, 1, TYPE_FLAG_UNSIGNED, "UBYTE", objfile);
	break;
      case FT_SHORT:			/* Chill ints are 2 bytes */
	type = init_type (TYPE_CODE_INT, 2, 0, "INT", objfile);
	break;
      case FT_UNSIGNED_SHORT:		/* Chill ints are 2 bytes */
	type = init_type (TYPE_CODE_INT, 2, TYPE_FLAG_UNSIGNED, "UINT", objfile);
	break;
      case FT_INTEGER:			/* FIXME? */
      case FT_SIGNED_INTEGER:		/* FIXME? */
      case FT_LONG:			/* Chill longs are 4 bytes */
      case FT_SIGNED_LONG:		/* Chill longs are 4 bytes */
	type = init_type (TYPE_CODE_INT, 4, 0, "LONG", objfile);
	break;
      case FT_UNSIGNED_INTEGER:		/* FIXME? */
      case FT_UNSIGNED_LONG:		/* Chill longs are 4 bytes */
	type = init_type (TYPE_CODE_INT, 4, TYPE_FLAG_UNSIGNED, "ULONG", objfile);
	break;
      case FT_FLOAT:
	type = init_type (TYPE_CODE_FLT, 4, 0, "REAL", objfile);
	break;
      case FT_DBL_PREC_FLOAT:
	type = init_type (TYPE_CODE_FLT, 8, 0, "LONG_REAL", objfile);
	break;
      }
d293 1
a294 1

d297 30
a326 29
static const struct op_print chill_op_print_tab[] = {
    {"AND", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},
    {"OR",  BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},
    {"NOT", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},
    {"MOD", BINOP_MOD, PREC_MUL, 0},
    {"REM", BINOP_REM, PREC_MUL, 0},
    {"SIZE",UNOP_SIZEOF, PREC_BUILTIN_FUNCTION, 0},
    {"LOWER",UNOP_LOWER, PREC_BUILTIN_FUNCTION, 0},
    {"UPPER",UNOP_UPPER, PREC_BUILTIN_FUNCTION, 0},
    {"CARD",UNOP_CARD, PREC_BUILTIN_FUNCTION, 0},
    {"MAX",UNOP_CHMAX, PREC_BUILTIN_FUNCTION, 0},
    {"MIN",UNOP_CHMIN, PREC_BUILTIN_FUNCTION, 0},
    {":=",  BINOP_ASSIGN, PREC_ASSIGN, 1},
    {"=",   BINOP_EQUAL, PREC_EQUAL, 0},
    {"/=",  BINOP_NOTEQUAL, PREC_EQUAL, 0},
    {"<=",  BINOP_LEQ, PREC_ORDER, 0},
    {">=",  BINOP_GEQ, PREC_ORDER, 0},
    {">",   BINOP_GTR, PREC_ORDER, 0},
    {"<",   BINOP_LESS, PREC_ORDER, 0},
    {"+",   BINOP_ADD, PREC_ADD, 0},
    {"-",   BINOP_SUB, PREC_ADD, 0},
    {"*",   BINOP_MUL, PREC_MUL, 0},
    {"/",   BINOP_DIV, PREC_MUL, 0},
    {"//",  BINOP_CONCAT, PREC_PREFIX, 0},	/* FIXME: precedence? */
    {"-",   UNOP_NEG, PREC_PREFIX, 0},
    {"->",  UNOP_IND, PREC_SUFFIX, 1},
    {"->",  UNOP_ADDR, PREC_PREFIX, 0},
    {":",   BINOP_RANGE, PREC_ASSIGN, 0},
    {NULL,  0, 0, 0}
d337 1
a337 1
struct type ** CONST_PTR (chill_builtin_types[]) = 
d340 5
a344 5
  &builtin_type_chill_char,
  &builtin_type_chill_long,
  &builtin_type_chill_ulong,
  &builtin_type_chill_real,
  0
d353 1
a353 1
     enum exp_opcode op;  /* Either UNOP_LOWER or UNOP_UPPER */
d370 1
a370 1
      type = TYPE_FIELD_TYPE (type, 0);  /* Get index type */
d509 2
a510 2
			       ? TYPE_TARGET_TYPE (elttype)
			       : elttype,
d564 1
a564 1
		= evaluate_subexp_chill (TYPE_FIELD_TYPE (type, tem-1),
d569 1
a569 1
	  argvec[tem] = 0; /* signal end of arglist */
d620 1
a620 1
 nosideret:
d624 2
a625 1
const struct language_defn chill_language_defn = {
d637 1
a637 1
  chill_create_fundamental_type,/* Create fundamental type in this language */
d641 4
a644 4
  {"",      "B'",  "",   ""},	/* Binary format info */
  {"O'%lo",  "O'",  "o",  ""},	/* Octal format info */
  {"D'%ld",  "D'",  "d",  ""},	/* Decimal format info */
  {"H'%lx",  "H'",  "x",  ""},	/* Hex format info */
d648 1
a648 1
  &builtin_type_chill_char,	/* Type of string elements */ 
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-05-25 snapshot
@
text
@a28 2
extern void _initialize_chill_language PARAMS ((void));

@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d32 1
a32 1
  evaluate_subexp_chill PARAMS ((struct type *, struct expression *, int *, enum noside));
d35 1
a35 1
  value_chill_max_min PARAMS ((enum exp_opcode, value_ptr));
d38 1
a38 1
  value_chill_card PARAMS ((value_ptr));
d41 1
a41 1
  value_chill_length PARAMS ((value_ptr));
d44 1
a44 1
  chill_create_fundamental_type PARAMS ((struct objfile *, int));
d47 1
a47 1
chill_printstr PARAMS ((GDB_FILE * stream, char *string, unsigned int length, int width, int force_ellipses));
d113 1
a113 1
 */
d141 1
a141 1
         to see whether it is repeated.  */
d180 1
a180 1
	  if (!in_literal_form && !in_control_form)
d242 49
a290 49
    default:
      /* FIXME:  For now, if we are asked to produce a type not in this
         language, create the equivalent of a C integer type with the
         name "<?type?>".  When all the dust settles from the type
         reconstruction work, this should probably become an error. */
      type = init_type (TYPE_CODE_INT, 2, 0, "<?type?>", objfile);
      warning ("internal error: no chill fundamental type %d", typeid);
      break;
    case FT_VOID:
      /* FIXME:  Currently the GNU Chill compiler emits some DWARF entries for
         typedefs, unrelated to anything directly in the code being compiled,
         that have some FT_VOID types.  Just fake it for now. */
      type = init_type (TYPE_CODE_VOID, 0, 0, "<?VOID?>", objfile);
      break;
    case FT_BOOLEAN:
      type = init_type (TYPE_CODE_BOOL, 1, TYPE_FLAG_UNSIGNED, "BOOL", objfile);
      break;
    case FT_CHAR:
      type = init_type (TYPE_CODE_CHAR, 1, TYPE_FLAG_UNSIGNED, "CHAR", objfile);
      break;
    case FT_SIGNED_CHAR:
      type = init_type (TYPE_CODE_INT, 1, 0, "BYTE", objfile);
      break;
    case FT_UNSIGNED_CHAR:
      type = init_type (TYPE_CODE_INT, 1, TYPE_FLAG_UNSIGNED, "UBYTE", objfile);
      break;
    case FT_SHORT:		/* Chill ints are 2 bytes */
      type = init_type (TYPE_CODE_INT, 2, 0, "INT", objfile);
      break;
    case FT_UNSIGNED_SHORT:	/* Chill ints are 2 bytes */
      type = init_type (TYPE_CODE_INT, 2, TYPE_FLAG_UNSIGNED, "UINT", objfile);
      break;
    case FT_INTEGER:		/* FIXME? */
    case FT_SIGNED_INTEGER:	/* FIXME? */
    case FT_LONG:		/* Chill longs are 4 bytes */
    case FT_SIGNED_LONG:	/* Chill longs are 4 bytes */
      type = init_type (TYPE_CODE_INT, 4, 0, "LONG", objfile);
      break;
    case FT_UNSIGNED_INTEGER:	/* FIXME? */
    case FT_UNSIGNED_LONG:	/* Chill longs are 4 bytes */
      type = init_type (TYPE_CODE_INT, 4, TYPE_FLAG_UNSIGNED, "ULONG", objfile);
      break;
    case FT_FLOAT:
      type = init_type (TYPE_CODE_FLT, 4, 0, "REAL", objfile);
      break;
    case FT_DBL_PREC_FLOAT:
      type = init_type (TYPE_CODE_FLT, 8, 0, "LONG_REAL", objfile);
      break;
    }
d293 1
a294 1

d297 29
a325 30
static const struct op_print chill_op_print_tab[] =
{
  {"AND", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},
  {"OR", BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},
  {"NOT", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},
  {"MOD", BINOP_MOD, PREC_MUL, 0},
  {"REM", BINOP_REM, PREC_MUL, 0},
  {"SIZE", UNOP_SIZEOF, PREC_BUILTIN_FUNCTION, 0},
  {"LOWER", UNOP_LOWER, PREC_BUILTIN_FUNCTION, 0},
  {"UPPER", UNOP_UPPER, PREC_BUILTIN_FUNCTION, 0},
  {"CARD", UNOP_CARD, PREC_BUILTIN_FUNCTION, 0},
  {"MAX", UNOP_CHMAX, PREC_BUILTIN_FUNCTION, 0},
  {"MIN", UNOP_CHMIN, PREC_BUILTIN_FUNCTION, 0},
  {":=", BINOP_ASSIGN, PREC_ASSIGN, 1},
  {"=", BINOP_EQUAL, PREC_EQUAL, 0},
  {"/=", BINOP_NOTEQUAL, PREC_EQUAL, 0},
  {"<=", BINOP_LEQ, PREC_ORDER, 0},
  {">=", BINOP_GEQ, PREC_ORDER, 0},
  {">", BINOP_GTR, PREC_ORDER, 0},
  {"<", BINOP_LESS, PREC_ORDER, 0},
  {"+", BINOP_ADD, PREC_ADD, 0},
  {"-", BINOP_SUB, PREC_ADD, 0},
  {"*", BINOP_MUL, PREC_MUL, 0},
  {"/", BINOP_DIV, PREC_MUL, 0},
  {"//", BINOP_CONCAT, PREC_PREFIX, 0},		/* FIXME: precedence? */
  {"-", UNOP_NEG, PREC_PREFIX, 0},
  {"->", UNOP_IND, PREC_SUFFIX, 1},
  {"->", UNOP_ADDR, PREC_PREFIX, 0},
  {":", BINOP_RANGE, PREC_ASSIGN, 0},
  {NULL, 0, 0, 0}
d336 1
a336 1
struct type **CONST_PTR (chill_builtin_types[]) =
d339 5
a343 5
    &builtin_type_chill_char,
    &builtin_type_chill_long,
    &builtin_type_chill_ulong,
    &builtin_type_chill_real,
    0
d352 1
a352 1
     enum exp_opcode op;	/* Either UNOP_LOWER or UNOP_UPPER */
d369 1
a369 1
      type = TYPE_FIELD_TYPE (type, 0);		/* Get index type */
d508 2
a509 2
			     ? TYPE_TARGET_TYPE (elttype)
			     : elttype,
d563 1
a563 1
		= evaluate_subexp_chill (TYPE_FIELD_TYPE (type, tem - 1),
d568 1
a568 1
	  argvec[tem] = 0;	/* signal end of arglist */
d619 1
a619 1
nosideret:
d623 1
a623 2
const struct language_defn chill_language_defn =
{
d635 1
a635 1
  chill_create_fundamental_type,	/* Create fundamental type in this language */
d639 4
a642 4
  {"", "B'", "", ""},		/* Binary format info */
  {"O'%lo", "O'", "o", ""},	/* Octal format info */
  {"D'%ld", "D'", "d", ""},	/* Decimal format info */
  {"H'%lx", "H'", "x", ""},	/* Hex format info */
d646 1
a646 1
  &builtin_type_chill_char,	/* Type of string elements */
@


1.1.1.4
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright 1992, 1995, 1996, 2000 Free Software Foundation, Inc.
d47 2
a48 3
static void chill_printstr (struct ui_file * stream, char *string,
			    unsigned int length, int width,
			    int force_ellipses);
d50 2
a51 1
static void chill_printchar (int, struct ui_file *);
d88 1
a88 1
     struct ui_file *stream;
d118 1
a118 1
     struct ui_file *stream;
@


