head	1.1;
access;
symbols
	arc-sim-20090309:1.1.2.1
	arc-insight_6_8-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.1
date	2009.03.09.21.07.40;	author amylaar;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2009.03.09.21.07.40;	author amylaar;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2009.09.11.04.45.44;	author amylaar;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file arc-jtag.c was initially added on branch arc-insight_6_8-branch.
@
text
@@


1.1.2.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@a0 1297
/* Target dependent code for ARC700, for GDB, the GNU debugger.

   Copyright 2005 Free Software Foundation, Inc.

   Contributed by Codito Technologies Pvt. Ltd. (www.codito.com)

   Authors: 
      Sameer Dhavale <sameer.dhavale@@codito.com>
      Ramana Radhakrishnan <ramana.radhakrishnan@@codito.com> 

   This file is part of GDB.
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
*/

#include <stdio.h>
#include <string.h>
#include "defs.h"
#include "inferior.h"
#include "target.h"
#include "breakpoint.h"

#include "arc-tdep.h"

#include <unistd.h>
#include <stdlib.h>

#include <sys/io.h>
#include <sys/types.h>

#include <assert.h>

#include "arc-jtag.h"
#include "arc-jtag-ops.h"
#include "gdbcore.h"
#include "gdbarch.h"
#include "regcache.h"
#include "command.h"
#include "gdbcmd.h"
#include <signal.h>

/* Flag to print debug messages from here. */
/* FIXMEA:
static int debug_arc_jtag_target_message;
*/

#define ENTERMSG  \
do {\
if(debug_arc_jtag_target_message) \
printf_filtered ("--- entered %s:%s()\n", __FILE__, __FUNCTION__); \
} while(0)

#define ENTERARGS(fmt, args...) \
do { \
if(debug_arc_jtag_target_message) \
printf_filtered ("--- entered %s:%s(" fmt ")\n", __FILE__, __FUNCTION__, args);\
} while(0)

#define LEAVEMSG \
do { \
if(debug_arc_jtag_target_message) \
printf_filtered ("--- exited %s:%s()\n", __FILE__, __FUNCTION__); \
} while(0)

/* The number of times a memory read/write operation should be attempted
   before returning an error.
*/
#define MEMORY_TRANSFER_ATTEMPTS 10

/* defined in arc-jtag-ops.c */
extern unsigned int arcjtag_retry_count;

struct target_ops arc_debug_ops;
extern struct jtag_ops arc_jtag_ops;

static void arc_debug_interrupt (int signo);
static void arc_debug_interrupt_twice (int signo);
static void arc_print_processor_variant_info (void);
static int arc_debug_write_aux_register (int hwregno, int *buf);
static int arc_debug_read_aux_register (int hwregno, int *buf);
static int arc_debug_read_core_register (int hwregno, int *buf);


/* Register Mapping information between GDB regnums
   and actual hardware register numbers. 
*/

struct arc_reg_info 
{
  char *name ;
  enum arc_hw_regnums hw_regno;
  char *description;
#ifdef ARC4_JTAG
  enum arc4_jtag_regnums gdbregno;
#else
  enum arc700_jtag_regnums gdbregno;
#endif
  enum ARCProcessorVersion arcVersionSupported;
};

#define RBCR(name, hwregno , desc, gdbregno, version) { #name, hwregno , desc , gdbregno , version } ,

#undef RAUX
struct arc_reg_info arc_bcr_reg_info [] = 
  {
   #include "arc-regnums-defs.h"
  };

#undef RAUX
#undef RBCR
#define RAUX(name, hwregno , desc, gdbregno, version) { #name , hwregno , desc , gdbregno , version } ,
struct arc_reg_info arc_aux_reg_map[] =
  {
    #include "arc-regnums-defs.h"
  };



static void 
arc_update_architecture(void)
{
  unsigned int idinfo;
  unsigned short tmp;
  struct gdbarch_tdep * tdep = gdbarch_tdep (current_gdbarch);

  if (IS_ARC700) {
    tdep->arc_processor_variant_info->arcprocessorversion = ARC700;
    set_gdbarch_decr_pc_after_break (current_gdbarch,0);
  }
  else if(IS_ARC600) {
    tdep->arc_processor_variant_info->arcprocessorversion = ARC600;
    set_gdbarch_decr_pc_after_break (current_gdbarch,2);
  }
  else if(IS_A5) {
    warning ("A5 debugging is unsupported and may be buggy.");
    tdep->arc_processor_variant_info->arcprocessorversion = A5;
  }
  else {
    tdep->arc_processor_variant_info->arcprocessorversion = A4;
    set_gdbarch_decr_pc_after_break (current_gdbarch,0);
  }    
}

/* Get us out of user mode.  */
static unsigned int
clear_status32_user_bit ()
{
  int rd;
#ifndef ARC4_JTAG  
  if(arc_jtag_ops.jtag_read_aux_reg(ARC_HW_STATUS32_REGNUM, &rd) == JTAG_READ_FAILURE)
    error("Failure reading auxillary register 0x%x:status32 register", ARC_HW_STATUS32_REGNUM);

  if(arc_jtag_ops.jtag_write_aux_reg(ARC_HW_STATUS32_REGNUM, rd & ~0x80) == JTAG_READ_FAILURE)
    error("Failure writing to auxillary register 0x%x:status32 register", ARC_HW_STATUS32_REGNUM);
#endif
  return rd;
}

/* Restore a saved status32; use with clear_status32_user_bit().  */
static void
restore_status32_user_bit (unsigned int status32)
{
#ifndef ARC4_JTAG
  if(arc_jtag_ops.jtag_write_aux_reg(ARC_HW_STATUS32_REGNUM, status32) == JTAG_READ_FAILURE)
    error("Failure writing to auxillary register 0x%x:status32 register", ARC_HW_STATUS32_REGNUM);
#endif
}

/* UB bit in the debug register.  It allows brk_s to work in user mode.  */
static void
set_debug_user_bit ()
{
  if(is_arc700 ())
    {
      /* set UB = 1 */
      unsigned int debug;
      if (arc_jtag_ops.jtag_read_aux_reg (ARC_HW_DEBUG_REGNUM, &debug) == JTAG_READ_FAILURE)
	error("Failure reading auxillary register 0x%x:debug register",ARC_HW_DEBUG_REGNUM);
      debug |= 0x10000000;                     
      arc_jtag_ops.jtag_write_aux_reg (ARC_HW_DEBUG_REGNUM, debug);
    }
}



static void
invalidateCaches (void)
{
    if(arc_jtag_ops.jtag_write_aux_reg ( ARC_HW_ICACHE_IVIC , 1)==JTAG_WRITE_FAILURE)
	error("Failure writing 0x1 to auxillary register 0x%x:Icache invalidate\n",ARC_HW_ICACHE_IVIC);
    if(arc_jtag_ops.jtag_write_aux_reg ( ARC_HW_DCACHE_IVIC , 1)==JTAG_WRITE_FAILURE)
	error("Failure writing 0x1 to auxillary register 0x%x:Dcache invalidate\n",ARC_HW_DCACHE_IVIC);
}

static void
disableCaches (void)
{
  /* Disabling Icache */
    if(arc_jtag_ops.jtag_write_aux_reg( ARC_HW_ICACHE_CONTROL ,0x1)==JTAG_WRITE_FAILURE)
      error("Failure writing 0x1 to auxillary register 0x%x:Icache control register\n",ARC_HW_ICACHE_CONTROL);
  /* Disabling Dcache */
    if(arc_jtag_ops.jtag_write_aux_reg( ARC_HW_DCACHE_CONTROL ,0x1)==JTAG_WRITE_FAILURE)
	error("Failure writing 0x1 to auxillary register 0x%x:Dcache control register\n",ARC_HW_DCACHE_CONTROL);
}


/* Function: arc_debug_open
 * Parameters :
 * 1. args :
 * 2. from_tty:
 * Returns : void
 * Description: 
	1. Connect to the jtag target . 
	2. Read the number of action points supported. 
	3. Read the configuration of action points. 
	4. Set up internal data structures for number of hardware
	   breakpoints and watchpoints. 
	5. Set the UB bit to 1 for ARC700 and not for ARC600.
 * 
 */

void
arc_debug_open (char *args, int from_tty)
{
  ENTERARGS("%s", args);
  target_preopen(from_tty);
  
  reopen_exec_file ();
  reread_symbols ();
  
  unpush_target (&arc_debug_ops);  
  arc_jtag_ops.jtag_open();
  push_target (&arc_debug_ops);

  /* Call arc_update_architecture if opened successfully.  */
  arc_update_architecture();
  /* Fixme  :: Should these be in create_inferior or 
     some place else ?. We would not like these here
     when attach starts working. 
  */
  disableCaches();
#ifdef ARC4_JTAG
  if(arc_jtag_ops.jtag_write_aux_reg (ARC_HW_STATUS_REGNUM, 0x02000000)==JTAG_WRITE_FAILURE)
          error("Failure writing 0x0200 0000 to auxillary register 0x%x:status register\n",ARC_HW_STATUS_REGNUM);

  if (from_tty)
    printf_filtered ("Connected to the arcjtag target.\n");  
  
#else
  if(arc_jtag_ops.jtag_write_aux_reg (ARC_HW_STATUS32_REGNUM, 0x1)==JTAG_WRITE_FAILURE)

    error("Failure writing 0x1 to auxillary register 0x%x:status32 register\n",ARC_HW_STATUS32_REGNUM);
  
  /* allow breakpoints in user mode.  */
  set_debug_user_bit ();


  if (from_tty)
    printf_filtered ("Connected to the arcjtag target.\n");  
#endif
}

void arc_debug_close()
{
    arc_jtag_ops.jtag_close();
}

/* Function: arc_debug_attach
 * Parameters :
 * 1. char *x:
 * 2. int i:
 * Returns : void
 * Description: 
 *  1. attach without resetting the board 
 *  2. get all Board configuration registers of interest.
 *  if ARC700 set the UB bit to 1. (This is invalid in the 
 *  ARC600).
 */


void
arc_debug_attach (char *x, int i)
{

  ENTERMSG;
}


/* Function: arc_debug_attach
 * Parameters :
 * 1. char *x:
 * 2. int i:
 * Returns : void
 * Description: 
 *  1. Detach without resetting the board. 
 */
void
arc_debug_detach (char *x, int i)
{
	
  ENTERMSG;

  /* Let it continue.  */
  target_resume (inferior_ptid, 0, 0);
}


/* Function: arc_debug_resume
 * Parameters :
 * 1. ptid_t ptid:
 * 2. int step: 1 - single step , 0 run freely.
 * 3. enum target_signal signal;
 * Returns : void
 * Description: 
 *  	1. What about Pipecleaning?
 *	2. Write 0 to the HALT bit in status32.
 *      3. Send a signal (ignore) in this case. 
 *      4. if(step) use hardware single step on the ARC700.
 *          done by setting the IS bit in the debug register
 *          and clearing the halt bit in status32. 
 *	
 */

void
arc_debug_resume (ptid_t ptid, int step, enum target_signal signal)
{
  
  ENTERARGS("%d,%d,%d", ptid.pid, step, signal);
  /* Make the inferior resume execution, sending a signal if necessary */
  unsigned int rd;

  /* Because breakpoints may have been set/removed.  */
  invalidateCaches ();

  /* This bit is required if breakpoints are to be allowed in user mode.  We
     set it in target_open, but the operating system might clear it.  So we
     set it every time we resume.  */
  set_debug_user_bit ();

  if(step)
  {

    /* reading debug reg */
      if(arc_jtag_ops.jtag_read_aux_reg(ARC_HW_DEBUG_REGNUM,&rd)==JTAG_READ_FAILURE)
	  error("Failure reading auxillary register 0x%x:debug register",ARC_HW_DEBUG_REGNUM);
#ifdef ARC4_JTAG      
      rd |= 0x801; /*Setting the IS and the SS bit in the status register
		     for the A4 core to allow it to single step.  */
#else
      /* Mask for Single Stepping changes for ARC600 and ARC700. */
      if(is_arc700())
	rd |= 0x800;
      else
	if(is_arc600())
	  rd |= 0x801;
#endif
      
      /* Writing to IS bit in DEBUG register for 
	 hardware single instruction stepping.  */
      if(arc_jtag_ops.jtag_write_aux_reg(ARC_HW_DEBUG_REGNUM ,rd)==JTAG_WRITE_FAILURE)
	  error("Failure writing 0x%x to auxillary register 0x%x:debug register\n",rd,ARC_HW_DEBUG_REGNUM);
  }
  else
  {
    /* Restarting the processor by clearing the 'H' bit in the status register*/
#ifdef ARC4_JTAG    
    /* reading the status reg */     
    if(arc_jtag_ops.jtag_read_aux_reg(ARC_HW_STATUS_REGNUM,&rd)==JTAG_READ_FAILURE)
      error("Failure reading auxillary register 0x%x:status register",ARC_HW_STATUS_REGNUM);
  
    rd = rd & ~(0x02000000);
  
    /* starting the halted processor */
    if(arc_jtag_ops.jtag_write_aux_reg(ARC_HW_STATUS_REGNUM,rd)==JTAG_WRITE_FAILURE)
      error("Failure writing 0x%x to auxillary register 0x%x:status register\n",rd,ARC_HW_STATUS_REGNUM);
#else
    /* reading the status32 reg */     
    if(arc_jtag_ops.jtag_read_aux_reg(ARC_HW_STATUS32_REGNUM,&rd)==JTAG_READ_FAILURE)
      error("Failure reading auxillary register 0x%x:status32 register",ARC_HW_STATUS32_REGNUM);
  
    rd = rd & ~(0x1);
  
    /* starting the halted processor */
    if(arc_jtag_ops.jtag_write_aux_reg(ARC_HW_STATUS32_REGNUM,rd)==JTAG_WRITE_FAILURE)
      error("Failure writing 0x%x to auxillary register 0x%x:status32 register\n",rd,ARC_HW_STATUS32_REGNUM);
#endif
  }
}

/* For the ^C signal handler.  */
static  void (*ofunc) (int);

/* The command line interface's stop routine.  This function is installed as
   a signal handler for SIGINT.  The first time a user requests a stop, we
   call target_stop to send a break or ^C.  If there is no response from the
   target (it didn't stop when the user requested it), we ask the user if
   he'd like to detach from the target.  */
static void
arc_debug_interrupt (int signo)
{
  /* If we get the signal twice, do something more drastic.  */
  signal (signo, arc_debug_interrupt_twice);
  
  target_stop ();
}

/* The user typed ^C twice.  */
static void
arc_debug_interrupt_twice (int signo)
{
  signal (signo, ofunc);

  if (query ("Interrupted while waiting for the program.\n\
Give up (and stop debugging it)? "))
    {
      target_mourn_inferior ();
      throw_exception (RETURN_QUIT);
    }

  signal (signo, arc_debug_interrupt);
}

/* Function: arc_debug_wait
 * Parameters :
 * 1. ptid_t ptid:
 * 2. struct target_waitstatus *status: Indicates status at end
                                        of wait for F.E.
 * Returns : void
 * Description: 
 *        Poll status32 for the value of H bit.	
 *        After H bit is set in status32. 
 *        Wait till LD(load pending bit) in the DEBUG register
 *        is cleared.
 *        SH bit is set if flag instruction was used to halt the processor.
 *        BH bit is set if the ARCompact processor stopped due to 
 *        a brk_s instruction. Set the target_waitstatus (signal) to SIGTRAP
 *        only in such a situation. 
 *	
 */

ptid_t
arc_debug_wait (ptid_t ptid, struct target_waitstatus *status)
{
  unsigned int debug;
  ENTERMSG;

  /* signal handler for Control-C.  */
  ofunc = signal (SIGINT, arc_debug_interrupt);

  arc_jtag_ops.jtag_wait();
  /* put the old function back.  */
  signal (SIGINT, ofunc);

  /* If the SH ("self halt") bit is set, we stopped because of the flag
     instruction, which is used by programs to exit.  */
  if (arc_jtag_ops.jtag_read_aux_reg (ARC_HW_DEBUG_REGNUM,
				      &debug) == JTAG_READ_FAILURE)
    {
      error ("Failure reading from debug register");
    }

  /* SH bit of debug register */
  if (debug & ARC_DEBUG_REG_SH_BIT)
    {
      int exitcode;
      status->kind = TARGET_WAITKIND_EXITED;

      /* Exit code of the program.  */
      if (arc_jtag_ops.jtag_read_core_reg (0, &exitcode) == JTAG_READ_FAILURE)
	{
	  warning ("Failure reading from register r0, assuming exit code = 0");
	  status->value.integer = 0;
	}
      status->value.integer = exitcode;
    }
  else
    {
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_TRAP;
    }

#ifndef ARC4_JTAG
  /* Bug #1311 (ARC600): Setting a breakpoint on the last instruction of a
     ZOL causes GDB to stop at LP_START.  Detect this condition and warn the
     user.  */
  if (is_arc600 ())
    {
      unsigned int pc, lp_start, lp_end, lp_count;
      arc_debug_read_core_register (ARC_LP_COUNT_REGNUM, &lp_count);
      if (lp_count != 0)
	{
	  arc_debug_read_aux_register (ARC_HW_PC_REGNUM, &pc);
	  arc_debug_read_aux_register (ARC_HW_LP_START_REGNUM, &lp_start);
	  
	  if (pc == lp_start)
	    {
	      extern struct breakpoint *breakpoint_chain;
	      struct breakpoint *b;
	      arc_debug_read_aux_register (ARC_HW_LP_END_REGNUM, &lp_end);

	      for (b = breakpoint_chain; b; b = b->next)
		{
		  /* lp_end is the address of the last instruction + the
		     size of the last instruction.  We could use the
		     disassembler and find out the size, or just try both
		     possible sizes.  */
		  if ((b->enable_state == bp_enabled && !b->pending) &&
		      b->loc->address == lp_end-4 || b->loc->address == lp_end-2)
		    {
		      warning ("Did you set a breakpoint on the last instruction of \n\
a Zero Overhead Loop ?  Such breakpoints do not work properly.");
		    }
		}
	    }
	}
    }
#endif
  return inferior_ptid;
}

static unsigned int 
arc_get_hw_regnum_mapping ( int regno )
{
  int i;

  if (regno >= ARC_STATUS_REGNUM 
#ifdef ARC4_JTAG
      && regno <= ARC_DEBUG_REGNUM
#else
      && regno <= ARC_AUX_IRQ_PENDING_REGNUM
#endif      
      )
    return  arc_aux_reg_map[regno - ARC_STATUS_REGNUM].hw_regno;
  
  for ( i = 0 ; i < (sizeof(arc_bcr_reg_info) / sizeof (struct arc_reg_info)) ; i++)
    {
      if (regno == arc_bcr_reg_info[i].gdbregno)
	return arc_bcr_reg_info[i].hw_regno;
    }

  return -1;
}


/* Function: arc_debug_fetch_regs.
 * Parameters :
 * 1. int regnum: Register number. If register number is -1.Fetch
 *                all the registers.Read all core registers here.
 * Returns : void
 * Description: 
 *          Set up regcache_raw_supply(current_regcache,regno)
 *
 */
void
arc_debug_fetch_regs (int regno)
{
	/* Read all core registers */
  ENTERARGS("%d",regno);

  int dummyvalue = 0xABCDABCD;
  unsigned int hw_regno;
  unsigned int read_buf;

  if( regno < ARC_NR_CORE_REGS )
  {
      hw_regno = regno;
      if(arc_jtag_ops.jtag_read_core_reg(regno,&read_buf)==JTAG_READ_FAILURE)
	  error("Failure reading from core register 0x%x\n",regno);
  }
  else
  {
#ifndef ARC4_JTAG    
    if( regno > ARC_NR_REGS)
      error("Invalid Register Number\n");
#endif
    
    hw_regno  = arc_get_hw_regnum_mapping (regno);
    if(arc_jtag_ops.jtag_read_aux_reg(hw_regno,&read_buf)==JTAG_READ_FAILURE)
	error("Failure reading auxillary register 0x%x",hw_regno);
  }
  
  if(debug_arc_jtag_target_message)
    {
      printf_filtered("HW_Regno=0x%x",hw_regno);
      printf_filtered("Read Regno 0x%x the value 0x%x\n",hw_regno,read_buf);
    }
  regcache_raw_supply(current_regcache,regno,&read_buf);

  LEAVEMSG;
}


/* Function: arc_debug_fetch_regs.
 * Parameters :
 * 1. int regnum: Register number. If register number is -1.Fetch
 *                all the registers.Read all core registers here.
 * Returns : void
 * Description: 
 *          Use deprecated register information for this or regcache_read_unsigned .
 * FIXME: would need to change to use regcache_raw_supply instead.
 */


void
arc_debug_store_regs (int regno)
{
  /* write_all core registers */
  ENTERARGS("%d", regno);
  unsigned int hw_regno;
  unsigned int write_buf;

  if(debug_arc_jtag_target_message)
    printf_filtered("\n%d",regno);

  regcache_raw_collect(current_regcache,regno,&write_buf);
  if( regno < ARC_NR_CORE_REGS )
  {
      if(arc_jtag_ops.jtag_write_core_reg(regno,write_buf)==JTAG_WRITE_FAILURE)
	  error("Failure writing 0x%x to core register 0x%x",write_buf,regno);
  }
  else
  {
#ifndef ARC4_JTAG    
    if (regno > ARC_NR_REGS)
      error ("Invalid register number \n");
#endif

    hw_regno = arc_get_hw_regnum_mapping (regno);

    if(debug_arc_jtag_target_message)
	printf_filtered("Writing to regno 0x%x the value 0x%x",
			hw_regno,write_buf);
    if(arc_jtag_ops.jtag_write_aux_reg(hw_regno,write_buf)==JTAG_WRITE_FAILURE)
	error("Failure writing 0x%x to auxillary register 0x%x\n",write_buf,hw_regno);
  }

}


/* Function: arc_debug_prepare_to_store.
 * Parameters :
 * 1. int regnum: Register number. If register number is -1.Fetch
 *                all the registers.Read all core registers here.
 * Returns : void
 * Description: 
 *          Use deprecated register information for this. 
 * FIXME: would need to change to use regcache_raw_supply instead.
 */

/* This gets called just before store_regs */
void
arc_debug_prepare_to_store (void)
{
	/* does nothing . Why is this around ? */
  ENTERMSG;
}

/* Read or write memory */



/* Function: arc_debug_xfer_memory. 
 * Parameters : 
 * 1. int regnum: Register number. If register number is -1.Fetch
 *                all the registers.Read all core registers here.
 * Returns : void
 * Description: 
 *    This has been superceded by target_xfer_memory_partial.
 *
 */
int
arc_debug_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		      struct mem_attrib *attrib, struct target_ops *target)
{
	/* There is no xfer_memory . Its been deprecated in 6.3 .Replace	
	 * this by target_xfer_memory_partial .
	 */
  ENTERARGS("memaddr=%lx, myaddr=%lx, len=%d, write=%d",
	    memaddr, (unsigned long)myaddr, len, write);
  
  return len; /* success */
}


    

LONGEST 
arc_debug_xfer_partial (struct target_ops *ops,
			enum target_object object, 
			const char *annex,
			void *readbuf, 
			const void *writebuf,
			ULONGEST offset, 
			LONGEST len)
{

  int i=0, read_num=0, temp_len=0;
  unsigned int small_buf;
  char query_type;
  ULONGEST temp_offset=0;
  if(debug_arc_jtag_target_message)
    printf("..Entered arc_debug_xfer_partial()...with offset 0x%x\n",(unsigned int)offset);
  /* Handle memory */
  if (object == TARGET_OBJECT_MEMORY)
    {
      int saved_status32;
      int xfered=0;
      int attempts;
      errno = 0;

      /* Get out of user mode so that we can read/write anything anywhere.  */
      saved_status32 = clear_status32_user_bit ();

      if (writebuf != NULL)
	{
	    char *buffer=(char *)xmalloc(4);
	    char *temp_buf = (char *)writebuf;

	    /* Address alignment to integral multiple of four */
	    temp_offset = offset;
	    temp_len = temp_offset % 4;
	    
	    i = 0;
	    if(temp_len)
	    {
		temp_offset = offset - temp_len;
		if(debug_arc_jtag_target_message)
		  {
		    printf("---- Aligning-----------\n");
		    printf("calling write_chunk at 0x%x where \
offset = 0x%x\n",
			   (unsigned int)temp_offset,(unsigned int)offset);
		  }

		attempts = 0;
		do{
		    if (attempts++ == MEMORY_TRANSFER_ATTEMPTS)
		      return 0;
		    xfered = arc_jtag_ops.jtag_memory_chunk_read(temp_offset,
								 (unsigned int *)buffer,4);
		}while(xfered != 4);
		
		for(i=0;i<len && i<(4-temp_len);i++)
		    
		    buffer[i+temp_len]=temp_buf[i];

		attempts = 0;
		do{
		    if (attempts++ == MEMORY_TRANSFER_ATTEMPTS)
		      return 0;
		    xfered = arc_jtag_ops.jtag_memory_chunk_write(temp_offset,
								  (unsigned int *)buffer,4);
		}while(xfered != 4);

		
		temp_buf = (char *)writebuf + i;
		temp_offset = offset + i;
		len = len - i;
	    }
	    if(len>0)
	      len =arc_jtag_ops.jtag_memory_chunk_write(temp_offset,
							(unsigned int *)temp_buf,len);
	    if(debug_arc_jtag_target_message)
	      printf("...leaving arc_debug_xfer_partial() write.. \
with return value %d",(int)len);

	    restore_status32_user_bit (saved_status32);
	  return (len + i);
	}
      else
      {
	  char *buffer=(char *)xmalloc(4);
	  char *temp_buf = (char *)readbuf;
	  /* Address alignment to integral multiple of four */
	  temp_offset= offset;
	  temp_len= temp_offset % 4 ;

	  i = 0;
	  if(temp_len)
	    {
	      temp_offset = offset - temp_len;
	      if(debug_arc_jtag_target_message)
		{
		  printf("---- Aligning-----------\n");
		  printf("calling read_chunk at 0x%x where offset =0x%x \n",
			 (unsigned int)temp_offset,(unsigned int)offset);
		}

	      attempts = 0;
	      do{
		if (attempts++ == MEMORY_TRANSFER_ATTEMPTS)
		  return 0;
		xfered = arc_jtag_ops.jtag_memory_chunk_read(temp_offset,(unsigned int *)buffer,4);
	      }while(xfered != 4);
	      
	      for(i=0;i<len && i<(4-temp_len);i++)
		temp_buf[i]=buffer[i+temp_len];
	      
	      temp_buf = (char *)readbuf + i;
	      temp_offset = offset + i;
	      len = len - i;
	    }
	  if(len>0)
	    len = arc_jtag_ops.jtag_memory_chunk_read(temp_offset,(unsigned int *)temp_buf,len);
	  if(debug_arc_jtag_target_message)
	    {
	      printf("\nlen=%d",(int)len + temp_len);
	      printf("...leaving arc_debug_xfer_partial() read.. \
with return value %d",
		     (int)len + temp_len);
	    }

	  restore_status32_user_bit (saved_status32);
	  return (len + i);
	  
      }

    }

  /* ARC auxillary registers: they are 32bits wide and are in a 32 bit
     address space, although only part of the address space is used.  */
  else if (object == ARC_TARGET_OBJECT_AUXREGS)
    {
      unsigned int regno;

      if (readbuf)
	{
	  for (regno = offset; regno < offset+len; ++regno)
	    {
	      unsigned int rd;

	      if (arc_jtag_ops.jtag_read_aux_reg (regno, &rd) == JTAG_READ_FAILURE)
		{
		  return (regno - offset);
		}
	      ((int *)readbuf)[regno - offset] = rd;
	    }
	}
      else if (writebuf)
	{
	  for (regno = offset; regno < offset+len; ++regno)
	    {
	      if (arc_jtag_ops.jtag_write_aux_reg (regno, ((int*)writebuf)[regno - offset]) ==
		  JTAG_WRITE_FAILURE)
		{
		  return (regno - offset);
		}
	    }
	}

      /* success */
      return (LONGEST)len;
    }
    else
    {
	printf("\nRequested target_object not yet supported with arc-jtag");
    }

  return -1;

}




void
arc_debug_files_info (struct target_ops *target)
{
	/* Do nothing. Just say its a remote target */
  ENTERMSG;
}


/* Function: arc_debug_insert_breakpoint
 * Parameters : 
 * 1. CORE_ADDR addr: Address for breakpoint.
 * 2. char * contents: Contents for the breakpoint.
 * Returns : int
 * Description: 
 * See if you can insert a hardware breakpoint using the actionpoints
 * interface. Use brk_s if architecture is ARC700 and you need to use
 * a software breakpoint.The gdbarch breakpoint should be initialized to
 * the right value if used with target_arc_debug.
 *
 */


int
arc_debug_insert_breakpoint (CORE_ADDR addr, char *contents)
{
	
  ENTERARGS("%x", (unsigned int)addr);
#ifndef ARC4_JTAG
  unsigned int bp = 0x20207fff; /*FIXMEA: what does 0x2020 stand for ?*/
#else
  unsigned int bp = 0x1ffffe00;
#endif
  unsigned int r;
  int instr_size;
  const unsigned char *breakpt_instr;
  breakpt_instr=BREAKPOINT_FROM_PC(&addr,&instr_size);

  /* save the existing value */
  /* r==0 means the read succeeded */
  if(debug_arc_jtag_target_message)
    printf_filtered ("instrcution size = %d and instruction 0x%x",
	   instr_size, *(unsigned int *)breakpt_instr);
  r = target_read_memory (addr, contents, instr_size);
  /* put the breakpoint */
  if(r==0)
    r = target_write_memory (addr, (char *)&bp, instr_size);
  return r;
}


/* Function: arc_debug_remove_breakpoint. 
 * Parameters : 
 * 1. CORE_ADDR addr: Address. 
 * 2. char * contents : contents. 
 * Returns : int.
 * Description: 
 *  Write the old contents back for the breakpoint.
 *
 */

int
arc_debug_remove_breakpoint (CORE_ADDR addr, char *contents)
{
  ENTERARGS("%x, %lx", (unsigned int)addr, *(unsigned long *)contents);

  /* write the old value back */
#ifdef ARC4_JTAG
  return target_write_memory (addr, contents, 4);
#else
  return target_write_memory (addr, contents, 2);
#endif
}



/* Function: arc_debug_kill
 * Parameters : void.

 * Returns : void.
 * Description: Heavy duty arsenal.Kill the process. 
 * Maybe we do a board reset and kill it. Write 1 to Halt
 * in Status32. 
 */

void
arc_debug_kill (void)
{
  ENTERMSG;

  /* Do stuff */

  target_mourn_inferior ();
}

/* Function: arc_debug_load
 * Parameters :
 * 1. char * args: Arguments. 
 * 2. int from_tty: Which terminal.
 * Returns : void.
 * Description: Load the program into jtag.
 */

void
arc_debug_load (char *args, int from_tty)
{
	/* Write to RAM of the ARC700 board by running through the sections .*/
  asection *bss_section;
  CORE_ADDR bss_addr;
  bfd_size_type bss_size;
  char *zero_buf;
  int target_errno;

  ENTERARGS("%s", args);

  generic_load(args, from_tty);

  /* Zero the bss, if it exists.  */
  bss_section = bfd_get_section_by_name (exec_bfd, ".bss");
  if (bss_section)
    {
      bss_addr = bfd_section_lma (exec_bfd, bss_section);
      bss_size = bfd_get_section_size (bss_section);
      zero_buf = (char *)xcalloc (bss_size, 1);
      
      if (debug_arc_jtag_target_message)
	printf_filtered("%s: bss at %x, size = %x\n", __FUNCTION__, (unsigned int)bss_addr,(unsigned int)bss_size);
      
      target_errno = target_write_memory (bss_addr, zero_buf, bss_size);
      free (zero_buf);
      if (target_errno)
	{
	  error ("load: error zeroing bss: %s\n", strerror(target_errno));
	}
    }
  else
    {
      if (debug_arc_jtag_target_message)
	printf_filtered("%s: no bss\n", __FUNCTION__);
    }
      
  clear_symtab_users();
}

/* Function: arc_debug_create_inferior
 * Parameters :
 * 1. char * exec_file:
 * 2. char * args: 
 * 3. char ** env;
 * Returns : void.
 * Description: Set up sanity values for arc_debug_create_inferior. More thought
 * needed for this. 
 */


void
arc_debug_create_inferior (char *exec_file, char *args, char **env,int dummy)
{
  ENTERARGS("%s,%s", exec_file, args);

  /* If no exec file handed to us, get it from the exec-file command
     -- with a good, common error message if none is specified.  */
  if (exec_file == 0)
    exec_file = get_exec_file (1);

  /* We dont really have a PID or anything, but GDB uses this value to check
     if the program is running. */
  inferior_ptid.pid = 42;

  clear_proceed_status();
  /* -1 means resume from current place
     TARGET_SIGNAL_0 means dont give it any signal
     Last arg should be true if you want to single step */
  //proceed ((CORE_ADDR) -1, TARGET_SIGNAL_0, 0);
  proceed (bfd_get_start_address (exec_bfd), TARGET_SIGNAL_0, 0);
}


/* Function: arc_debug_mourn_inferior
 * Parameters :void.
 * Returns : void.
 * Description: Set up sanity values for arc_debug_create_inferior. More thought
 * needed for this. 
 */

void
arc_debug_mourn_inferior (void)
{
  ENTERMSG;

  unpush_target (&arc_debug_ops);

  generic_mourn_inferior ();
}


/* Function: arc_debug_mourn_inferior
 * Parameters :ptid_t ptid.
 * Returns : 1 always. 
 * Description: Checks for return values .
 */


int
arc_debug_thread_alive (ptid_t ptid)
{
  ENTERMSG;
  return 1;
}


/* Function: arc_debug_stop
 * Parameters: void
 * Returns: void.
 * Description: Stop the Processor. We stop by writing FH bit to Debug Register . 
 *	write 1 to the FH bit in the Debug register after 
 *	polling for the DEBUG register to have no loads pending .
 */
void
arc_debug_stop (void)
{

  ENTERMSG;
  int val = 0x2;
  /* Stop using the FH bit in the debug register. */
  arc_debug_write_aux_register (ARC_HW_DEBUG_REGNUM, &val);
  
}

/* Read core register.  Return 0 on success.  */
static int
arc_debug_read_core_register (int hwregno, int *buf)
{
  int rd;
  if(arc_jtag_ops.jtag_read_core_reg(hwregno,&rd)==JTAG_READ_FAILURE)
      error("Failure reading auxillary register 0x%x",hwregno);
  *buf = rd;
  return 0;
}

/* Read aux register.  Return 0 on success.  */
static int
arc_debug_read_aux_register (int hwregno, int *buf)
{
  int rd;
  if(arc_jtag_ops.jtag_read_aux_reg(hwregno,&rd)==JTAG_READ_FAILURE)
      error("Failure reading auxillary register 0x%x",hwregno);
  *buf = rd;
  return 0;
}

/* Write aux register.  Return 0 on success.  */
static int
arc_debug_write_aux_register (int hwregno, int *buf)
{
    if(arc_jtag_ops.jtag_write_aux_reg(hwregno, *buf)==JTAG_WRITE_FAILURE)
	error("Failure writing 0x%x to auxillary register 0x%x\n",*buf,hwregno);
  return 0;
}

/* Helper routine for commands added.  */
/* Print Processor Variant Info.  */
static void
arc_print_processor_variant_info (void)
{
  struct gdbarch_tdep *tdep  = gdbarch_tdep (current_gdbarch);
  
#ifdef ARC4_JTAG
  if (tdep->arc_processor_variant_info && 
      tdep->arc_processor_variant_info->arcprocessorversion == A4)
    {
      printf_filtered ("A4\n");
    }
#else
  if (tdep->arc_processor_variant_info)
    {
      if(tdep->arc_processor_variant_info->arcprocessorversion == ARC700)
	printf_filtered ("ARC700\n");
      else
	printf_filtered ("ARC600\n");
    }
#endif
  else
    {
      printf_filtered ("ARC Processor Information not available \n");
    }

}


static void 
arc_print_bcr_regs (void)
{
  int i = 0;
  unsigned int bcrval = 0;
  for ( i = 0 ; i < (sizeof(arc_bcr_reg_info) / sizeof (struct arc_reg_info)) ; i++)
    {
	if(arc_jtag_ops.jtag_read_aux_reg (arc_bcr_reg_info[i].hw_regno, &bcrval)==JTAG_READ_FAILURE)
	    error("Failure reading auxillary register 0x%x",arc_bcr_reg_info[i].hw_regno);
      printf_filtered ("[%02x] %-15s : 0x%02x\n",arc_bcr_reg_info[i].hw_regno,
		       arc_bcr_reg_info[i].name, bcrval );
    }

}

static void
arc_debug_jtag_reset_board (void)
{
  arc_jtag_ops.jtag_reset_board();
}


/* Function: init_arc_debug_ops
 * Parameters: void
 * Returns: void.
 * Description: Initialize the jtag operations. 
 */

void
init_arc_debug_ops (void)
{
  ENTERMSG;
#ifdef ARC4_JTAG
  arc_debug_ops.to_shortname = "arcjtag";
  arc_debug_ops.to_longname = "Target for debugging an A4 board with JTAG.";
  arc_debug_ops.to_doc = "Debug a remote A4 board via a JTAG"; /* to_doc */
#else
  arc_debug_ops.to_shortname = "arcjtag";
  arc_debug_ops.to_longname = "Target for debugging an ARC700 board with JTAG.";
  arc_debug_ops.to_doc = "Debug a remote ARC700 board via a JTAG"; /* to_doc */
#endif


  arc_debug_ops.to_open = arc_debug_open;
  arc_debug_ops.to_close = arc_debug_close;
  arc_debug_ops.to_attach = arc_debug_attach;
  arc_debug_ops.to_detach = arc_debug_detach;
  arc_debug_ops.to_resume = arc_debug_resume;
  arc_debug_ops.to_wait = arc_debug_wait;

  arc_debug_ops.to_fetch_registers = arc_debug_fetch_regs;
  arc_debug_ops.to_store_registers = arc_debug_store_regs;
  arc_debug_ops.to_prepare_to_store = arc_debug_prepare_to_store;
  //arc_debug_ops.to_xfer_memory = arc_debug_xfer_memory;
  arc_debug_ops.to_xfer_partial = arc_debug_xfer_partial;
  arc_debug_ops.to_files_info = arc_debug_files_info;
  arc_debug_ops.to_insert_breakpoint = arc_debug_insert_breakpoint;
  arc_debug_ops.to_remove_breakpoint = arc_debug_remove_breakpoint;
  arc_debug_ops.to_kill = arc_debug_kill;
  arc_debug_ops.to_load = arc_debug_load;

  arc_debug_ops.to_create_inferior = arc_debug_create_inferior;

  arc_debug_ops.to_mourn_inferior = arc_debug_mourn_inferior;
  arc_debug_ops.to_thread_alive = arc_debug_thread_alive;
  arc_debug_ops.to_stop = arc_debug_stop;

  arc_debug_ops.to_terminal_inferior = NULL;

  
  arc_debug_ops.to_stratum = process_stratum;
  
  arc_debug_ops.to_has_all_memory = 1;
  arc_debug_ops.to_has_memory = 1;
  arc_debug_ops.to_has_stack = 1;
  arc_debug_ops.to_has_registers = 1;
  arc_debug_ops.to_has_execution = 1;

  arc_debug_ops.to_magic = OPS_MAGIC;
}



void
_initialize_arc_debug (void)
{
  ENTERMSG;
  init_arc_debug_ops ();
  add_target (&arc_debug_ops);
  add_setshow_boolean_cmd("arcjtag-debug-target",no_class, 
			  &debug_arc_jtag_target_message,
			  "Set whether to print arc jtag debug messages.\n",
			  "Show whether to print arc jtag debug messages.\n",
			  "If set the jtag debug messages from the target are \
printed.\n",
			  "Whether to print debug jtag messages is %s.\n",		  
			  NULL,NULL,&setlist,&showlist);

  add_setshow_boolean_cmd("arcjtag-debug-statemachine",no_class, 
			  &(arc_jtag_ops.arc_jtag_state_machine_debug),
			  "Set whether to print JTAG state machine \
debug messages \n",
			  "Show whether to print JTAG state machine \
debug messages \n",
			  "If set the JTAG state machine messages are \
printed.\n",
			  "Whether to print JTAG state machine debug \
messages is %s\n",
			  NULL,NULL,&setlist,&showlist);

  add_setshow_uinteger_cmd("arcjtag-retry-count",no_class, &arcjtag_retry_count,
			   "Set the number of attempts to be made for \
a JTAG operation.\n",
			   "Show the number of attempts to be made for \
a JTAG operation.\n",
			   "Indicates the number of times a JTAG operation \
is attempted before returning a failure.\n",
			   "The number of times a JTAG operation is attempted \
before returning a failure is %s.\n",
			   NULL, NULL, &setlist, &showlist);

  add_cmd ("arc-configuration", class_info, arc_print_processor_variant_info,
	   "Show ARC configuration information." , &infolist);

  add_cmd ("arc-bcr-registers", class_info, arc_print_bcr_regs,
           "Show BCR Registers in the ARC Processor Variant", &infolist);

  add_cmd ("arc-reset-board", class_obscure, arc_debug_jtag_reset_board,
           "Reset the board.", &cmdlist);

}
@


1.1.2.2
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@d1 1
a1 1
/* Target dependent code for ARC processor family, for GDB, the GNU debugger.
d3 1
a3 1
   Copyright 2005, 2008, 2009 Free Software Foundation, Inc.
d7 3
a9 4
   Authors:
      Sameer Dhavale       <sameer.dhavale@@codito.com>
      Ramana Radhakrishnan <ramana.radhakrishnan@@codito.com>
      Richard Stuckey      <richard.stuckey@@arc.com>
d12 1
a12 1

d15 1
a15 1
   the Free Software Foundation; either version 3 of the License, or
d17 1
a17 1

d22 1
a22 1

d24 3
a26 17
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/******************************************************************************/
/*                                                                            */
/* Outline:                                                                   */
/*     This module creates an instance of a gdb 'target_ops' structure which  */
/*     contains information and operations for debugging a remote ARC target  */
/*     with JTAG.                                                             */
/*                                                                            */
/*     It also registers a number of ARC-specific commands with gdb.          */
/*                                                                            */
/* Usage:                                                                     */
/*     The module exports a function _initialize_arc_jtag: the call to this   */
/*     function is generated by the gdb build mechanism, so this function     */
/*     should not be explicitly called.                                       */
/*                                                                            */
/******************************************************************************/
d28 2
a29 3
/* system header files */

/* gdb header files */
d32 2
a33 4
#include "gdbcmd.h"
#include "objfiles.h"
#include "libiberty.h"
#include "gdb_assert.h"
a34 4
/* ARC header files */
#include "config/arc/tm-embed.h"
#include "arc-jtag.h"
#include "arc-gpio.h"
a35 6
#include "arc-board.h"
#include "arc-jtag-ops.h"
#include "arc-elf32-tdep.h"
#include "arc-architecture.h"
#include "arc-registers.h"
#include "arc-jtag-actionpoints.h"
d37 2
d40 2
a41 3
/* -------------------------------------------------------------------------- */
/*                               local types                                  */
/* -------------------------------------------------------------------------- */
d43 1
a43 5
typedef enum
{
    CLEAR_USER_BIT,
    RESTORE_USER_BIT
} Status32Action;
d45 8
d54 4
a57 3
/* -------------------------------------------------------------------------- */
/*                               local data                                   */
/* -------------------------------------------------------------------------- */
d59 17
a75 5
#define ARC_CONFIGURATION_COMMAND      "arc-configuration"
#define ARC_RESET_BOARD_COMMAND        "arc-reset-board"
#define ARC_LIST_ACTIONPOINTS_COMMAND  "arc-list-actionpoints"
#define ARC_FSM_DEBUG_COMMAND          "arcjtag-debug-statemachine"
#define ARC_JTAG_RETRY_COMMAND         "arcjtag-retry-count"
d77 4
a80 3
#define ARC_CONFIGURATION_COMMAND_USAGE      "Usage: info " ARC_CONFIGURATION_COMMAND     "\n"
#define ARC_RESET_BOARD_COMMAND_USAGE        "Usage: "      ARC_RESET_BOARD_COMMAND       "\n"
#define ARC_LIST_ACTIONPOINTS_COMMAND_USAGE  "Usage: "      ARC_LIST_ACTIONPOINTS_COMMAND "\n"
d82 2
d85 2
a86 2
/* The gdb target operations structure for this target.  */
static struct target_ops jtag_target_ops;
d88 6
a93 3
/* A set of pointers to operations for reading/writing registers/memory in the
   JTAG target. */
static TargetOperations operations;
a94 8
/* The h/w register numbers of various auxiliary registers needed for
   controlling the target processor.  */
static ARC_RegisterNumber lp_start_regnum;
static ARC_RegisterNumber lp_end_regnum;
static ARC_RegisterNumber icache_ivic_regnum;
static ARC_RegisterNumber icache_control_regnum;
static ARC_RegisterNumber dcache_ivdc_regnum;
static ARC_RegisterNumber dcache_control_regnum;
d96 3
d100 12
a111 3
/* -------------------------------------------------------------------------- */
/*                               external data                                */
/* -------------------------------------------------------------------------- */
d113 1
a113 2
/* This declaration should be in the file breakpoint.h (a gdb core file).  */
extern struct breakpoint *breakpoint_chain;
d115 13
a128 3
/* -------------------------------------------------------------------------- */
/*                               local macros                                 */
/* -------------------------------------------------------------------------- */
a129 2
#define IS_ARC700   (arc_get_architecture(arc_read_jtag_aux_register) == ARC700)
#define IS_ARC600   (arc_get_architecture(arc_read_jtag_aux_register) == ARC600)
d131 24
d156 8
a163 3
/* -------------------------------------------------------------------------- */
/*                               local functions                              */
/* -------------------------------------------------------------------------- */
d165 5
a169 3
/* -------------------------------------------------------------------------- */
/* 1)                functions for reading/writing registers                  */
/* -------------------------------------------------------------------------- */
d171 3
a173 7
/* Set UB bit in the DEBUG register: this allows brk_s instruction to work in
   User mode.

  Returns TRUE if the operation is successful.  */

static Boolean
set_debug_user_bit (ARC_RegisterContents extra_bits)
d175 4
a178 23
    /* The DEBUG User bit exists only in the ARC700 variant.  */
    if (IS_ARC700)
        extra_bits |= DEBUG_USER;

    /* If we have extra bits to be set in the DEBUG register.  */
    if (extra_bits != 0)
    {
        ARC_RegisterContents debug;

        if (arc_read_jtag_aux_register(arc_debug_regnum, &debug, TRUE))
        {
            /* Set UB = 1.  */
            ARC_RegisterContents new_debug = debug | extra_bits;

            /* Do the write only if it will change the register contents.  */
            if (new_debug != debug)
                return arc_write_jtag_aux_register(arc_debug_regnum, new_debug, TRUE);
        }
        else
            return FALSE;
    }

    return TRUE;
d181 1
a181 3

/* Clear or restore the User bit in the STATUS32 auxiliary register.  */

d183 1
a183 1
change_status32 (Status32Action action)
d185 1
a185 18
    static ARC_RegisterContents status32 = 0;

    if (action == CLEAR_USER_BIT)
    {
        /* Get processor out of user mode.  */

        if (arc_read_jtag_aux_register(arc_status32_regnum, &status32, FALSE))
        {
            /* If the User bit is actually set.  */
            if (status32 & STATUS32_USER)
                if (!arc_write_jtag_aux_register(arc_status32_regnum,
                                                 status32 & ~STATUS32_USER, FALSE))
                    warning(_("can not clear User bit in STATUS32 auxiliary register"));
        }
        else
            warning(_("can not read STATUS32 auxiliary register"));
    }
    else
d187 6
a192 4
        /* If the User bit was actually cleared.  */
        if (status32 & STATUS32_USER)
            if (!arc_write_jtag_aux_register(arc_status32_regnum, status32, FALSE))
                warning(_("can not restore User bit in STATUS32 auxiliary register"));
a196 7
/* -------------------------------------------------------------------------- */
/* 2)                functions for reading/writing mmeory                     */
/* -------------------------------------------------------------------------- */

/* These functions should NOT be used within this module: they are intended
   purely for use by the arc-memory module for reading/writing multiple words
   of data at word-aligned addresses.  */
d198 2
a199 4
static unsigned int
read_words (ARC_Address  address,
            ARC_Byte    *data,
            unsigned int words)
d201 5
a205 1
    DEBUG("reading %u words from 0x%08X on target board\n", words, address);
d207 10
a216 1
    gdb_assert(IS_WORD_ALIGNED(address));
a217 2
    return arc_jtag_ops.memory_read_chunk(address, data, words);
}
d219 14
d234 2
a235 4
static unsigned int
write_words (ARC_Address  address,
             ARC_Byte    *data,
             unsigned int words)
d237 31
a267 1
    gdb_assert(IS_WORD_ALIGNED(address));
a268 1
    DEBUG("writing %u words to 0x%08X on target board\n", words, address);
d270 3
a272 1
    return arc_jtag_ops.memory_write_chunk(address, data, words);
d275 1
a275 5

static unsigned int
write_pattern (ARC_Address  address,
               ARC_Word     pattern,
               unsigned int words)
d277 1
a277 5
    gdb_assert(IS_WORD_ALIGNED(address));

    DEBUG("writing pattern 0x%08X repeated %u times to 0x%08X on target board\n", pattern, words, address);

    return arc_jtag_ops.memory_write_pattern(address, pattern, words);
d280 11
a291 3
/* -------------------------------------------------------------------------- */
/* 3)               functions for processor cache management                  */
/* -------------------------------------------------------------------------- */
d293 2
a294 4
/* Invalidate the target processor's caches.  */

static void
invalidate_caches (void)
a295 7
    /* N.B. when invalidating the data caches, we must first set the DC_CTRL.IM
            bit to 1 to ensure that any "dirty" lines in the cache get flushed
            to main memory.  */
    (void) arc_write_jtag_aux_register(dcache_control_regnum, DC_CTRL_IM, TRUE);
    (void) arc_write_jtag_aux_register(icache_ivic_regnum,    IC_IVIC_IV, TRUE);
    (void) arc_write_jtag_aux_register(dcache_ivdc_regnum,    DC_IVDC_IV, TRUE);
}
d297 1
a297 8

/* Disable the target processor's caches.  */

static void
disable_caches (void)
{
    (void) arc_write_jtag_aux_register(icache_control_regnum, IC_CTRL_DC, TRUE);
    (void) arc_write_jtag_aux_register(dcache_control_regnum, DC_CTRL_DC, TRUE);
d301 10
a310 8
/* -------------------------------------------------------------------------- */
/* 4)                   functions for JTAG interface management               */
/* -------------------------------------------------------------------------- */

/* Open the JTAG interface to the debug target.  */

static Boolean
open_JTAG_interface (int from_tty)
d312 2
a313 8
    /* This is somewhat inelegant, but commands read from scripts in the gdb
       testsuite are regarded as though they were being input interactively
       (i.e. from_tty is 1), and interactive queries may be made (such as
       asking the user whether the program currently being debugged should be
       killed first) - and these queries hang the tests!

       So, if the environment variable is set, assume that the gdb test suite is
       being run, so that no such queries will be made.
d315 2
a316 9
       It is not possible to make this check in the top-level command handler
       loop, as the output from some other commands (e.g. 'file') depend on the
       from_tty parameter passed to them, and the gdb test scripts expect to get
       the interactive version of the output!  */
    target_preopen(from_tty && (getenv("ARC_GDB_TEST") == NULL));

    gdb_assert(arc_jtag_ops.open != NULL);

    return arc_jtag_ops.open(arc_aux_find_register_number("MEMSUBSYS", ARC_HW_MEMSUBSYS_REGNUM));
d320 14
a333 4
/* Close the JTAG interface to the debug target.

   Parameter:
      resume: TRUE if program execution on the target should be allowed to resume
d336 2
a337 2
static void
close_JTAG_interface (Boolean resume)
d339 61
a399 8
    /* If we have a target connected.  */
    if (arc_jtag_ops.status == JTAG_OPENED)
    {
        arc_elf32_close(resume);

        /* And close the connection.  */
        arc_jtag_ops.close();
    }
d402 2
d405 5
a409 6
/* -------------------------------------------------------------------------- */
/* 5)                functions for starting/stopping the processor            */
/* -------------------------------------------------------------------------- */

/* Start the processor by clearing the 'H' bit in the STATUS32 register. */

d411 1
a411 1
start_processor (void)
d413 4
a416 5
    ARC_RegisterContents status32;

    if (!arc_read_jtag_aux_register (arc_status32_regnum, &status32,                  FALSE) ||
        !arc_write_jtag_aux_register(arc_status32_regnum,  status32 & ~STATUS32_HALT, FALSE))
        warning(_("can not clear Halt bit in STATUS32 auxiliary register - can not start processor"));
d419 1
a419 3

/* Stop the processor by setting the 'FH' bit in the DEBUG register.  */

d421 1
a421 12
stop_processor (void)
{
    if (!arc_write_jtag_aux_register(arc_debug_regnum, DEBUG_FORCE_HALT, FALSE))
        warning(_("can not set Force Halt bit in DEBUG auxiliary register - can not halt processor"));
}


/* Try to halt the processor (if it is running) upon connection to the debug
   target.  Return TRUE if the processor is successfuly halted.  */

static Boolean
halt_processor_on_connection (void)
d423 1
a423 4
    Boolean      warn_on_read_failure = TRUE;
    Boolean      inform_running       = TRUE;
    Boolean      halt_attempted       = FALSE;
    unsigned int tries                = 0;
d425 2
a426 8
    /* Unfortunately, if the gpio driver module has been installed on the host
       machine, the gpio read/write operations appear to work even if the host
       is NOT physically connected to the JTAG target!

       There does not appear to be any way of detecting that situation - all we
       can do is bale out if we have not succeded in reading the STATUS32 register
       after the required number of retries!  */
    do
d428 2
a429 37
        ARC_RegisterContents status = 0;

        /* Read the STATUS32 register here to check if the halt bit is set.  */
        if (arc_read_jtag_aux_register(arc_status32_regnum, &status, warn_on_read_failure))
        {
            if (status & STATUS32_HALT)
            {
                printf_filtered(_("Processor is halted.\n"));
                return TRUE;
            }

            if (inform_running)
            {
                /* We inform the user that the processor is running only once
                   (to avoid swamping the user with messages!).  */
                printf_filtered(_("Processor is running. Trying to halt it...\n"));
                inform_running = FALSE;
            }

            stop_processor();
            halt_attempted = TRUE;
        }
        else
        {
            /* We give a warning only on the first read failure (otherwise the
               user can get swamped with warnings!).  */
            warn_on_read_failure = FALSE;
        }

        /* Just in case we actually did fail to read/write the port.  */
        if (gpio_port_error)
        {
            warning(_("error in accessing parallel port via "
                      GPIO_DEVICE
                      " - check connection to target board."));
            return FALSE;
        }
a430 6
    while (++tries <= arc_jtag_ops.retry_count);

    if (halt_attempted)
        printf_filtered(_("Can not halt processor!\n"));
    else
        printf_filtered(_("Can not connect to processor!\n"));
d432 1
a432 1
    return FALSE;
d435 17
d453 2
a454 18
/* -------------------------------------------------------------------------- */
/* 6)       local functions called from outside this module (from gdb)        */
/* -------------------------------------------------------------------------- */

/* Connect to the JTAG target.

   Parameters:
      args    : user arguments to the 'target' command
      from_tty: non-zero if the 'target' command was issued at the terminal

   The arguments may be:
      noreset | <xbf file>

   If a XBF file is specified, the target board FPGA is blasted as part of the
   connection process.  */

static void
arc_jtag_open (char *args, int from_tty)
d456 2
a457 5
    /* By default, reset the board, in case it has been left in a funny state by
       the last connection.  */
    Boolean     reset_required = TRUE;
    char       *xbf_file       = NULL;
    FPGA_Status fpga;
d459 2
a460 1
    ENTERARGS("\"%s\" (%d)", (args) ? args : "", from_tty);
d462 8
a469 1
    if (args)
d471 1
a471 4
        if (strcmp(args, "noreset") == 0)
            reset_required = FALSE;
        else
            xbf_file = args;
d474 5
a478 2
    /* Is the target board FPGA already configured?  */
    fpga = arc_is_FPGA_configured();
d480 9
a488 1
    switch (fpga)
d490 2
a491 14
        case INACCESSIBLE:
            /* A warning has already been given.  */
            return;

        case UNCONFIGURED:
            if (xbf_file == NULL)
            {
                warning(_("target FPGA is not configured; XBF file must be specified"));
                return;
            }
            break;

        case CONFIGURED:
            break;
d494 5
a498 40
    /* As far as we know, there is no program loaded on the target.  */
    arc_program_is_loaded = FALSE;

    /* Find the h/w register numbers of various auxiliary registers that we need
       for debugging.

       N.B. the gdb 'attach' command can attach only to an arcjtag target that
            has been created (by this function) within the *same* debugging
            session, i.e. the sequence of commands issued by the user is of the
            form:
                      target arcjtag ... detach ... attach

            This means that we do not need to worry about finding these numbers
            again on an 'attach', as they should be the same (they should really
            be the same for *any* target, anyway - we are simply being paranoid
            in looking them up, rather than having their numbers hard-coded, in
            any case!).

            Of course, there are really pathological cases such as the user
            blasting the (ARCangel) target with an XBF giving a different
            processor configuration, or even physically disconnecting the target
            from the host machine and connecting a different target, between
            issuing the 'detach' and the 'attach' commands (and that could change
            the target's actionpoint configuration, if nothing else!) - but if
            the user wants to do that then that is his problem!  */
    arc_elf32_find_register_numbers();

    lp_start_regnum       = arc_aux_find_register_number("LP_START", ARC_HW_LP_START_REGNUM);
    lp_end_regnum         = arc_aux_find_register_number("LP_END",   ARC_HW_LP_END_REGNUM);
    icache_ivic_regnum    = arc_aux_find_register_number("IC_IVIC", ARC_HW_IC_IVIC_REGNUM);
    icache_control_regnum = arc_aux_find_register_number("IC_CTRL", ARC_HW_IC_CTRL_REGNUM);
    dcache_ivdc_regnum    = arc_aux_find_register_number("DC_IVDC", ARC_HW_DC_IVDC_REGNUM);
    dcache_control_regnum = arc_aux_find_register_number("DC_CTRL", ARC_HW_DC_CTRL_REGNUM);


    /* Just to be sure that it is not in the target stack...  */
    (void) unpush_target (&jtag_target_ops);

    /* Now try to open the JTAG interface.  */
    if (open_JTAG_interface(from_tty))
d500 28
a527 60
        /* If a reset is required, do it now, in case it is necessary to reset
           the target clock sources to their defaults before trying to access
           the target's auxiliary registers!  */
        if (reset_required)
        {
            arc_reset_board();
            arc_jtag_ops.reset_board();
        }

        if (fpga == CONFIGURED)
        {
            /* If we are going to blast the board, don't bother halting the
               processor first.  */
            if ((xbf_file == NULL) && !halt_processor_on_connection())
            {
                /* We could not halt the processor.  */
                close_JTAG_interface(FALSE);
                return;
            }
        }

        /* If we have been given an XBF file.  */
        if (xbf_file)
        {
            /* Try to blast the board.
               N.B. if the blasting operation fails for any reason,
                    arc_blast_board calls error and does not return!  */
            arc_blast_board(xbf_file, from_tty);
        }

        /* Get out of user mode so that we can access anything anywhere.  */
        change_status32(CLEAR_USER_BIT);

        /* We do not know whether the target processor supports actionpoints until
           after we have connected to it, as we have to read the AP_BUILD
           configuration register to find that out.  */
        (void) arc_initialize_actionpoint_ops(&jtag_target_ops);

        (void) push_target (&jtag_target_ops);

        if (!reset_required)
        {
            /* If we have been explicitly told NOT to reset the board, it is
               most likely because we have connected to a target upon which a
               program is running and we want to debug that program - so assume
               we have a program ready for execution on the target.  */
            target_mark_running(&jtag_target_ops);
            arc_program_is_loaded = TRUE;

            /* Set to_has_execution back to 0; this stops the user getting the

                  A program is being debugged already.
                  Are you sure you want to change the file? (y or n) n

               message on issuing the 'file' command after the connection.  */
            current_target.to_has_execution = 0;
        }

        if (from_tty)
            printf_filtered (_("Connected to the " ARC_TARGET_NAME " target.\n"));
d529 2
a530 2
    else
        error(_("Can not connect to target"));
d533 4
d538 14
a551 1
/* Close the connection to the target.  */
d553 1
a553 5
static void
arc_jtag_close (int quitting)
{
    ENTERMSG;
    close_JTAG_interface(FALSE);
d557 11
a567 9
/* Attach to the debug target without resetting the board.

   Parameters:
      args    : user arguments to the 'attach' command (ignored)
      from_tty: non-zero if the 'attach' command was issued at the terminal
*/

static void
arc_jtag_attach (char *args, int from_tty)
d569 2
a570 1
    ENTERARGS("\"%s\" (%d)", args, from_tty);
d572 23
a594 2
    /* Try to open the JTAG interface.  */
    if (open_JTAG_interface(from_tty))
d596 2
a597 10
        /* Try to halt the processor (if it is running).  */
        if (halt_processor_on_connection())
        {
            /* Check that the processor architecture is correct.  */
            ARCHITECTURE_CHECK(current_gdbarch,
                               (current_objfile) ? current_objfile->obfd : NULL);

            if (from_tty)
                printf_filtered (_("Connected to the " ARC_TARGET_NAME " target.\n"));
        }
d599 3
a601 2
    else
        error(_("Can not connect to target"));
d605 9
a613 1
/* Detach from the debug target without resetting the board.
a614 4
   Parameters:
      args    : user arguments to the 'detach' command (ignored)
      from_tty: non-zero if the 'detach' command was issued at the terminal
*/
d616 2
a617 2
static void
arc_jtag_detach (char *args, int from_tty)
d619 20
a638 3
    ENTERMSG;
    close_JTAG_interface(TRUE);
}
d640 1
d642 6
a647 2
/* Cause the inferior on the debug target to resume execution, sending a signal
   if necessary.
d649 1
a649 4
   Parameters:
      ptid  : the thread id of the thread to be resumed (ignored)
      step  : 1 means single step, 0 run freely.
      signal: the number of the signal to be sent
a650 1
   N.B. signals are not supported.  */
d652 13
a664 2
static void
arc_jtag_resume (ptid_t ptid, int step, enum target_signal signal)
d666 5
a670 1
    ENTERARGS("%d, %d, %d", ptid.pid, step, signal);
a671 2
    if (signal != TARGET_SIGNAL_0)
        error(_("Signals are not supported by the " ARC_TARGET_NAME " target"));
a672 3
    /* If we cleared the User bit in the STATUS32 bit the last time that
       execution halted, restore it now.  */
    change_status32(RESTORE_USER_BIT);
d674 21
a694 3
    /* Software breakpoints may have been set/removed, and data in main memory
       may have been altered, so invalidate (and flush!) the instruction and
       data caches before restarting!
a695 1
       N.B. arc_jtag_open disabled the caches, so what is the point of doing this?
d697 132
a828 3
            Also, invalidating a disabled cache when DC_CTRL.IM = 1 seems to have
            the effect of overwriting valid data!!!!!  */
//  invalidate_caches ();
d830 1
a830 4
    /* The DEBUG User bit must be set if breakpoints are to be allowed in user
       mode. We could set it in target_open, but something (the user?) might clear it.
       So we set it every time we resume (if stepping, we set the extra bit(s) we
       need in the DEBUG register in the same operation).  */
d832 3
a834 1
    if (step)
d836 1
a836 1
        ARC_RegisterContents mask = 0;
d838 24
a861 1
        DEBUG("setting DEBUG.IS bit for single-step\n");
d863 2
a864 11
        /* The mask for single-stepping differs between ARC600 and ARC700.  */
        if (IS_ARC700)
            mask = DEBUG_INSTRUCTION_STEP;
        else
            if (IS_ARC600)
                mask = DEBUG_INSTRUCTION_STEP | DEBUG_SINGLE_STEP;

        /* Allow breakpoints in User mode, and set the IS bit in the DEBUG
           register for hardware single instruction stepping.  */
        if (!set_debug_user_bit (mask))
            error(_("Can not single-step one instruction"));
d868 1
a868 3
        /* Allow breakpoints in User mode (no extra bits required).  */
        (void) set_debug_user_bit (0);
        start_processor();
d871 2
a872 1
    LEAVEMSG;
a875 1
/* Wait for execution on the target to halt (for whatever reason).
a876 4
   Parameters :
      ptid  : ignored
      status: set to indicate status at end of the wait
*/
d878 2
a879 2
static ptid_t
arc_jtag_wait (ptid_t ptid, struct target_waitstatus *status)
d881 3
a883 1
    ENTERMSG;
a884 5
    /* Execute the program on the target processor. */
    arc_elf32_execute(status,
                      NULL,
                      start_processor,
                      stop_processor);
d886 12
a897 1
    /* The target has now halted.  */
a898 2
    if (status->kind == TARGET_WAITKIND_EXITED)
        target_mark_exited (&jtag_target_ops);
d900 25
a924 38
    /* Get out of user mode so that we can access anything anywhere.  */
    change_status32(CLEAR_USER_BIT);

    /* Inform the actionpoints module that the target has halted.  */
    arc_target_halted();

    /* Bug #1311 (ARC600): Setting a breakpoint on the last instruction of a
       ZOL causes GDB to stop at LP_START.  Detect this condition and warn the
       user.  */
    if (IS_ARC600)
    {
        ARC_RegisterContents pc, lp_start, lp_end, lp_count;

        if (arc_read_jtag_core_register(ARC_LP_COUNT_REGNUM, &lp_count, TRUE) && (lp_count != 0)  &&
            arc_read_jtag_aux_register (arc_pc_regnum,       &pc,       TRUE)                     &&
            arc_read_jtag_aux_register (lp_start_regnum,     &lp_start, TRUE) && (pc == lp_start) &&
            arc_read_jtag_aux_register (lp_end_regnum,       &lp_end,   TRUE))
        {
            struct breakpoint *b;

            for (b = breakpoint_chain; b != NULL; b = b->next)
            {
                /* lp_end is the address of the last instruction + the size of
                   the last instruction.  We could use the disassembler and find
                   out the size, but it's easier just to try both possible sizes.  */
                if ((b->enable_state == bp_enabled) &&
                    (b->loc->address == lp_end - 4 || b->loc->address == lp_end - 2))
                {
                    warning(_("did you set a breakpoint on the last instruction of a"
                              "Zero Overhead Loop? Such breakpoints do not work properly."));
                }
            }
        }
    }

    LEAVEMSG;

    return inferior_ptid;
d928 9
a936 1
/* This gets called just before store_regs.  */
d938 2
a939 2
static void
arc_jtag_prepare_to_store (struct regcache *regcache)
d941 8
a948 1
    ENTERMSG;
a951 6
static void
arc_jtag_files_info (struct target_ops *target)
{
    /* Do nothing.  */
    ENTERMSG;
}
d953 2
d956 5
a960 2
/* Heavy duty arsenal. Kill the process.
   Maybe we should do a board reset and kill it.  */
d962 2
a963 2
static void
arc_jtag_kill (void)
d967 2
d972 6
a977 8

/* Create the inferior that will be executed upon the target.

   Parameters :
      exec_file: the executable file containing the program to be executed
      args     : the command line arguments to be passed to the program
      env      : the environment (name/value pairs) for the program
      from_tty : ignored
d980 2
a981 2
static void
arc_jtag_create_inferior (char *exec_file, char *args, char **env, int from_tty)
d983 36
a1018 5
    arc_elf32_create_inferior(exec_file, args, env, &jtag_target_ops);

    /* Why are the caches disabled anyway? Particularly as arc_jtag_resume
       invalidates them before each restart?  */
   disable_caches();
d1021 9
a1030 1
/* Mourn the inferior.  */
d1032 2
a1033 2
static void
arc_jtag_mourn_inferior (void)
d1035 1
a1035 6
    ENTERMSG;

//  (void) unpush_target (&jtag_target_ops);
    generic_mourn_inferior ();
    current_target.to_has_execution = 0;
}
d1037 4
d1042 3
a1044 6
/* Check whether the given thread is alive.  */

static int
arc_jtag_thread_alive (ptid_t ptid)
{
    ENTERMSG;
d1046 6
a1051 2
    /* We only have one thread.  */
    return 1;
d1055 6
a1060 1
/* Check whether our debug target is runnable: return 1 if it is, 0 otherwise. */
d1062 2
a1063 2
static int
arc_jtag_can_run (void)
d1065 1
a1065 3
    /* If we are connected to the JTAG i/f, and a program is loaded.  */
    return (arc_jtag_ops.status == JTAG_OPENED) && arc_program_is_loaded;
}
d1067 1
d1069 1
a1069 11
/* We do not support asynchronous execution of the target program (i.e. commands
   like 'run' or 'continue' or 'step' can not be executed in background mode
   by appending a '&' to them) so we do not need to implement the target stop
   operation (called by the 'interrupt' command); interrupting a running program
   is handled by the Ctrl-C mechanism.  */

#if 0
static void
arc_jtag_stop (void)
{
    ENTERMSG;
a1070 1
#endif
d1073 5
a1077 3
/* -------------------------------------------------------------------------- */
/* 7)                  local functions implementing commands                  */
/* -------------------------------------------------------------------------- */
a1078 1
/* Print processor-variant information.  */
d1080 2
a1081 2
static void
arc_print_processor_variant_info (char *arg, int from_tty)
d1083 2
a1084 3
    printf_filtered
        (_("%s\n"),
         arc_version_image(arc_get_architecture(arc_read_jtag_aux_register)));
d1088 9
a1096 4
/* Reset the target board.  */

static void
arc_jtag_reset_board (char *arg, int from_tty)
a1097 4
    /* Make sure the GPIO interface is open.  */
    if (gpio_open())
    {
        printf_filtered(_("Attempting to reset target board...\n"));
d1099 5
a1103 18
        if (arc_jtag_ops.status == JTAG_OPENED)
        {
            /* Try to force the processor to halt.  */
            stop_processor();
        }

        /* Try to reset the board.  */
        arc_reset_board();
        arc_jtag_ops.reset_board();

        if (arc_jtag_ops.status == JTAG_OPENED)
        {
            /* The ARC actionpoint registers are cleared upon reset, so it is
               necessary to restore any actionpoints that were set.  */
            if (!arc_restore_actionpoints_after_reset())
                warning(_("can not restore hardware actionpoints"));
        }
    }
d1106 3
a1108 5

/* List the ARC target processor actionpoints.  */

static void
arc_list_actionpoints (char *arg, int from_tty)
d1110 5
a1114 9
    /* gdb manages breakpoints by deleting them from the target as soon as it
       has halted, then re-inserting them again immediately before execution is
       resumed (no, I don't know why either, unless it is to make generating a
       disassembly display easier by removing all the s/w b/ps from the code) -
       so in order to display what actionpoints are currently in use, we must
       temporarily re-insert the breakpoints!  */
    insert_breakpoints();
    arc_display_actionpoints();
    (void) remove_breakpoints();
d1117 3
a1119 9

/* -------------------------------------------------------------------------- */
/* 8)                           initialization functions                      */
/* -------------------------------------------------------------------------- */

/* Initialize the JTAG target operations.  */

static void
initialize_jtag_target_ops (void)
d1121 5
a1125 43
    ENTERMSG;

    jtag_target_ops.to_data = &operations;

    jtag_target_ops.to_shortname = ARC_TARGET_NAME;
    jtag_target_ops.to_longname  = "Remote JTAG debug target (ARC Processors)";
    jtag_target_ops.to_doc       = "Remote JTAG debug target (ARC Processors)";

    jtag_target_ops.to_open   = arc_jtag_open;
    jtag_target_ops.to_close  = arc_jtag_close;
    jtag_target_ops.to_attach = arc_jtag_attach;
    jtag_target_ops.to_detach = arc_jtag_detach;
    jtag_target_ops.to_resume = arc_jtag_resume;
    jtag_target_ops.to_wait   = arc_jtag_wait;

    jtag_target_ops.to_fetch_registers  = arc_elf32_fetch_registers;
    jtag_target_ops.to_store_registers  = arc_elf32_store_registers;
    jtag_target_ops.to_prepare_to_store = arc_jtag_prepare_to_store;
    jtag_target_ops.to_xfer_partial     = arc_elf32_xfer_partial;
    jtag_target_ops.to_files_info       = arc_jtag_files_info;

    jtag_target_ops.to_insert_breakpoint = arc_elf32_insert_breakpoint;
    jtag_target_ops.to_remove_breakpoint = arc_elf32_remove_breakpoint;

    jtag_target_ops.to_kill = arc_jtag_kill;
    jtag_target_ops.to_load = arc_elf32_load_program;

    jtag_target_ops.to_create_inferior   = arc_jtag_create_inferior;
    jtag_target_ops.to_mourn_inferior    = arc_jtag_mourn_inferior;
    jtag_target_ops.to_thread_alive      = arc_jtag_thread_alive;
//  jtag_target_ops.to_stop              = arc_jtag_stop;
    jtag_target_ops.to_can_run           = arc_jtag_can_run;
    jtag_target_ops.to_terminal_inferior = NULL;

    jtag_target_ops.to_stratum = process_stratum;

    jtag_target_ops.to_has_all_memory = 1;
    jtag_target_ops.to_has_memory     = 1;
    jtag_target_ops.to_has_stack      = 0;  /* Defer setting this until the program has been loaded.  */
    jtag_target_ops.to_has_registers  = 1;
    jtag_target_ops.to_has_execution  = 0;  /* Defer setting this until the program has been started.  */

    jtag_target_ops.to_magic = OPS_MAGIC;
d1128 3
a1130 9

/* -------------------------------------------------------------------------- */
/*                               externally visible functions                 */
/* -------------------------------------------------------------------------- */

/* Initialize the module.  This function is called from the gdb core on start-up.  */

void
_initialize_arc_jtag (void)
d1132 4
a1135 1
    ENTERMSG;
d1137 4
a1140 81
    operations.read_core_register       = arc_read_jtag_core_register;
    operations.write_core_register      = arc_write_jtag_core_register;
    operations.read_auxiliary_register  = arc_read_jtag_aux_register;
    operations.write_auxiliary_register = arc_write_jtag_aux_register;
    operations.read_memory              = read_words;
    operations.write_memory             = write_words;
    operations.fill_memory              = write_pattern;

    initialize_jtag_target_ops ();
    add_target (&jtag_target_ops);

    /* Register ARC-specific commands with gdb.  */

    add_setshow_boolean_cmd(ARC_FSM_DEBUG_COMMAND,
                            no_class,
                            &arc_jtag_ops.state_machine_debug,
                            _("Set whether to print JTAG state machine debug messages.\n"),
                            _("Show whether to print JTAG state machine debug messages.\n"),
                            _("If set the JTAG state machine messages are printed.\n"),
                            NULL,
                            NULL,
                            &setlist,
                            &showlist);

    add_setshow_uinteger_cmd(ARC_JTAG_RETRY_COMMAND,
                             no_class,
                             &arc_jtag_ops.retry_count,
                             _("Set the number of attempts to be made for a JTAG operation.\n"),
                             _("Show the number of attempts to be made for a JTAG operation.\n"),
                             _("Indicates the number of times a JTAG operation is attempted before returning a failure.\n"),
                             NULL,
                             NULL,
                             &setlist,
                             &showlist);

    (void) add_cmd(ARC_CONFIGURATION_COMMAND,
                   class_info,
                   arc_print_processor_variant_info,
                   _("Show ARC configuration information.\n"
                     ARC_CONFIGURATION_COMMAND_USAGE),
                   &infolist);

    (void) add_cmd(ARC_RESET_BOARD_COMMAND,
                   class_obscure,
                   arc_jtag_reset_board,
                   _("Reset the board.\n"
                     ARC_RESET_BOARD_COMMAND_USAGE),
                   &cmdlist);

    (void) add_cmd(ARC_LIST_ACTIONPOINTS_COMMAND,
                   class_obscure,
                   arc_list_actionpoints,
                   _("List the processor actionpoints.\n"
                     ARC_LIST_ACTIONPOINTS_COMMAND_USAGE),
                   &cmdlist);
}


/* N.B. the core and auxiliary register contents read from or written to the
        target via the arc-jtag-ops module are ALWAYS in little-endian format,
        regardless of the endianness of the target processor.  Given that the
        values passed to/from the functions below are in host byte order, and
        the host is little-endian (since the ARC gdb is currently built only 
        on an X86 Linux host), this means that no byte-swapping is required
        here.  This will require changing if the debugger is ever built upon a
        big-endian host (such as a Sun).  */


/* Read a core register on the target.

   Parameters:
      hw_regno       : the ARC hardware number of the register
      value          : set to the contents of the register
      warn_on_failure: TRUE if a warning should be issued if the read fails

   Result: TRUE if the register contents are read. */

Boolean
arc_read_jtag_core_register (ARC_RegisterNumber    hw_regno,
                             ARC_RegisterContents *contents,
                             Boolean               warn_on_failure)
d1142 10
a1151 1
    if (arc_jtag_ops.read_core_reg(hw_regno, contents) == JTAG_SUCCESS)
d1153 9
a1161 2
        DEBUG("Read value 0x%08X from core register %d\n", *contents, hw_regno);
        return TRUE;
a1163 3
    if (warn_on_failure)
        arc_elf32_core_warning(ERROR_ON_READING_REGISTER, hw_regno);
    return FALSE;
d1167 2
a1168 13
/* Write a core register on the target.

   Parameters:
      hw_regno       : the ARC hardware number of the register
      value          : set to the contents of the register
      warn_on_failure: TRUE if a warning should be issued if the write fails

   Result: TRUE if the register contents are written. */

Boolean
arc_write_jtag_core_register (ARC_RegisterNumber   hw_regno,
                              ARC_RegisterContents contents,
                              Boolean              warn_on_failure)
d1170 3
a1172 1
    if (arc_jtag_ops.write_core_reg(hw_regno, contents) == JTAG_SUCCESS)
d1174 4
a1177 2
        DEBUG("Written value 0x%08X to core register %d\n", contents, hw_regno);
        return TRUE;
a1179 3
    if (warn_on_failure)
        arc_elf32_core_warning(ERROR_ON_WRITING_REGISTER, hw_regno);
    return FALSE;
d1182 5
a1187 1
/* Read an auxiliary register on the target.
d1189 5
a1193 4
   Parameters:
      hw_regno       : the ARC hardware number of the register
      value          : set to the contents of the register
      warn_on_failure: TRUE if a warning should be issued if the read fails
d1195 2
a1196 6
   Result: TRUE if the register contents are read. */

Boolean
arc_read_jtag_aux_register (ARC_RegisterNumber    hw_regno,
                            ARC_RegisterContents *contents,
                            Boolean               warn_on_failure)
d1198 10
a1207 5
    if (arc_jtag_ops.read_aux_reg(hw_regno, contents) == JTAG_SUCCESS)
    {
        DEBUG("Read value 0x%08X from auxiliary register %d\n", *contents, hw_regno);
        return TRUE;
    }
a1208 4
    if (warn_on_failure)
        arc_elf32_aux_warning(ERROR_ON_READING_REGISTER, hw_regno);
    return FALSE;
}
d1210 34
d1245 2
a1246 1
/* Write an auxiliary register on the target.
a1247 4
   Parameters:
      hw_regno       : the ARC hardware number of the register
      value          : the contents of the register
      warn_on_failure: TRUE if a warning should be issued if the write fails
a1248 1
   Result: TRUE if the register contents are written. */
d1250 2
a1251 4
Boolean
arc_write_jtag_aux_register (ARC_RegisterNumber   hw_regno,
                             ARC_RegisterContents contents,
                             Boolean              warn_on_failure)
d1253 34
a1286 1
    ARC_AuxRegisterDefinition *def = arc_find_aux_register_by_hw_number(hw_regno);
d1288 2
a1289 2
   if (def)
       contents = arc_write_value(def, contents);
d1291 5
a1295 5
    if (arc_jtag_ops.write_aux_reg(hw_regno, contents) == JTAG_SUCCESS)
    {
        DEBUG("Written value 0x%08X to auxiliary register %d\n", contents, hw_regno);
        return TRUE;
    }
a1296 3
    if (warn_on_failure)
        arc_elf32_aux_warning(ERROR_ON_WRITING_REGISTER, hw_regno);
    return FALSE;
a1297 2

/******************************************************************************/
@


