head	1.47;
access;
symbols
	insight_6_6-20070208-release:1.45
	gdb_6_6-2006-12-18-release:1.45
	gdb_6_6-branch:1.45.0.10
	gdb_6_6-2006-11-15-branchpoint:1.45
	insight_6_5-20061003-release:1.45
	gdb-csl-symbian-6_4_50_20060226-12:1.44.8.1
	gdb-csl-sourcerygxx-3_4_4-25:1.42.8.1
	nickrob-async-20060828-mergepoint:1.45
	gdb-csl-symbian-6_4_50_20060226-11:1.44.8.1
	gdb-csl-sourcerygxx-4_1-17:1.44
	gdb-csl-20060226-branch-local-2:1.44
	gdb-csl-sourcerygxx-4_1-14:1.44
	gdb-csl-sourcerygxx-4_1-13:1.44
	gdb-csl-sourcerygxx-4_1-12:1.44
	gdb-csl-sourcerygxx-3_4_4-21:1.44
	gdb_6_5-20060621-release:1.45
	gdb-csl-sourcerygxx-4_1-9:1.44
	gdb-csl-sourcerygxx-4_1-8:1.44
	gdb-csl-sourcerygxx-4_1-7:1.44
	gdb-csl-arm-2006q1-6:1.44
	gdb-csl-sourcerygxx-4_1-6:1.44
	gdb-csl-symbian-6_4_50_20060226-10:1.44.8.1
	gdb-csl-symbian-6_4_50_20060226-9:1.44.8.1
	gdb-csl-symbian-6_4_50_20060226-8:1.44.8.1
	gdb-csl-coldfire-4_1-11:1.44
	gdb-csl-sourcerygxx-3_4_4-19:1.44
	gdb-csl-coldfire-4_1-10:1.44
	gdb_6_5-branch:1.45.0.8
	gdb_6_5-2006-05-14-branchpoint:1.45
	gdb-csl-sourcerygxx-4_1-5:1.44
	nickrob-async-20060513-branch:1.45.0.6
	nickrob-async-20060513-branchpoint:1.45
	gdb-csl-sourcerygxx-4_1-4:1.44
	msnyder-reverse-20060502-branch:1.45.0.4
	msnyder-reverse-20060502-branchpoint:1.45
	gdb-csl-morpho-4_1-4:1.44
	gdb-csl-sourcerygxx-3_4_4-17:1.44
	readline_5_1-import-branch:1.45.0.2
	readline_5_1-import-branchpoint:1.45
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.44
	gdb-csl-symbian-20060226-branch:1.44.0.8
	gdb-csl-symbian-20060226-branchpoint:1.44
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.44
	msnyder-reverse-20060331-branch:1.44.0.6
	msnyder-reverse-20060331-branchpoint:1.44
	gdb-csl-available-20060303-branch:1.44.0.4
	gdb-csl-available-20060303-branchpoint:1.44
	gdb-csl-20060226-branch:1.44.0.2
	gdb-csl-20060226-branchpoint:1.44
	gdb_6_4-20051202-release:1.42
	msnyder-fork-checkpoint-branch:1.42.0.10
	msnyder-fork-checkpoint-branchpoint:1.42
	gdb-csl-gxxpro-6_3-branch:1.42.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.42
	gdb_6_4-branch:1.42.0.6
	gdb_6_4-2005-11-01-branchpoint:1.42
	gdb-csl-arm-20051020-branch:1.42.0.4
	gdb-csl-arm-20051020-branchpoint:1.42
	msnyder-tracepoint-checkpoint-branch:1.42.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.42
	gdb-csl-arm-20050325-2005-q1b:1.41
	gdb-csl-arm-20050325-2005-q1a:1.41
	csl-arm-20050325-branch:1.41.0.2
	csl-arm-20050325-branchpoint:1.41
	gdb-post-i18n-errorwarning-20050211:1.39
	gdb-pre-i18n-errorwarning-20050211:1.38
	gdb_6_3-20041109-release:1.36
	gdb_6_3-branch:1.36.0.2
	gdb_6_3-20041019-branchpoint:1.36
	drow_intercu-merge-20040921:1.32
	drow_intercu-merge-20040915:1.32
	jimb-gdb_6_2-e500-branch:1.29.0.6
	jimb-gdb_6_2-e500-branchpoint:1.29
	gdb_6_2-20040730-release:1.29
	gdb_6_2-branch:1.29.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.29
	gdb_6_1_1-20040616-release:1.26
	gdb_6_1-2004-04-05-release:1.26
	drow_intercu-merge-20040402:1.26
	drow_intercu-merge-20040327:1.26
	ezannoni_pie-20040323-branch:1.26.0.12
	ezannoni_pie-20040323-branchpoint:1.26
	cagney_tramp-20040321-mergepoint:1.26
	cagney_tramp-20040309-branch:1.26.0.10
	cagney_tramp-20040309-branchpoint:1.26
	gdb_6_1-branch:1.26.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.26
	drow_intercu-20040221-branch:1.26.0.6
	drow_intercu-20040221-branchpoint:1.26
	cagney_bfdfile-20040213-branch:1.26.0.4
	cagney_bfdfile-20040213-branchpoint:1.26
	drow-cplus-merge-20040208:1.26
	carlton_dictionary-20040126-merge:1.26
	cagney_bigcore-20040122-branch:1.26.0.2
	cagney_bigcore-20040122-branchpoint:1.26
	drow-cplus-merge-20040113:1.26
	drow-cplus-merge-20031224:1.26
	drow-cplus-merge-20031220:1.26
	carlton_dictionary-20031215-merge:1.26
	drow-cplus-merge-20031214:1.26
	carlton-dictionary-20031111-merge:1.26
	gdb_6_0-2003-10-04-release:1.23
	kettenis_sparc-20030918-branch:1.23.0.10
	kettenis_sparc-20030918-branchpoint:1.23
	carlton_dictionary-20030917-merge:1.23
	ezannoni_pie-20030916-branchpoint:1.23
	ezannoni_pie-20030916-branch:1.23.0.8
	cagney_x86i386-20030821-branch:1.23.0.6
	cagney_x86i386-20030821-branchpoint:1.23
	carlton_dictionary-20030805-merge:1.23
	carlton_dictionary-20030627-merge:1.23
	gdb_6_0-branch:1.23.0.4
	gdb_6_0-2003-06-23-branchpoint:1.23
	jimb-ppc64-linux-20030613-branch:1.23.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.23
	cagney_convert-20030606-branch:1.22.0.30
	cagney_convert-20030606-branchpoint:1.22
	cagney_writestrings-20030508-branch:1.22.0.28
	cagney_writestrings-20030508-branchpoint:1.22
	jimb-ppc64-linux-20030528-branch:1.22.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.22
	carlton_dictionary-20030523-merge:1.22
	cagney_fileio-20030521-branch:1.22.0.24
	cagney_fileio-20030521-branchpoint:1.22
	kettenis_i386newframe-20030517-mergepoint:1.22
	jimb-ppc64-linux-20030509-branch:1.22.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.22
	kettenis_i386newframe-20030504-mergepoint:1.22
	carlton_dictionary-20030430-merge:1.22
	kettenis_i386newframe-20030419-branch:1.22.0.20
	kettenis_i386newframe-20030419-branchpoint:1.22
	carlton_dictionary-20030416-merge:1.22
	cagney_frameaddr-20030409-mergepoint:1.22
	kettenis_i386newframe-20030406-branch:1.22.0.18
	kettenis_i386newframe-20030406-branchpoint:1.22
	cagney_frameaddr-20030403-branchpoint:1.22
	cagney_frameaddr-20030403-branch:1.22.0.16
	cagney_framebase-20030330-mergepoint:1.22
	cagney_framebase-20030326-branch:1.22.0.14
	cagney_framebase-20030326-branchpoint:1.22
	cagney_lazyid-20030317-branch:1.22.0.12
	cagney_lazyid-20030317-branchpoint:1.22
	kettenis-i386newframe-20030316-mergepoint:1.22
	offbyone-20030313-branch:1.22.0.10
	offbyone-20030313-branchpoint:1.22
	kettenis-i386newframe-20030308-branch:1.22.0.8
	kettenis-i386newframe-20030308-branchpoint:1.22
	carlton_dictionary-20030305-merge:1.22
	cagney_offbyone-20030303-branch:1.22.0.6
	cagney_offbyone-20030303-branchpoint:1.22
	carlton_dictionary-20030207-merge:1.22
	interps-20030203-mergepoint:1.22
	interps-20030202-branch:1.22.0.4
	interps-20030202-branchpoint:1.22
	cagney-unwind-20030108-branch:1.22.0.2
	cagney-unwind-20030108-branchpoint:1.22
	carlton_dictionary-20021223-merge:1.22
	gdb_5_3-2002-12-12-release:1.20
	carlton_dictionary-20021115-merge:1.22
	kseitz_interps-20021105-merge:1.21
	kseitz_interps-20021103-merge:1.21
	drow-cplus-merge-20021020:1.20
	drow-cplus-merge-20021025:1.20
	carlton_dictionary-20021025-merge:1.20
	carlton_dictionary-20021011-merge:1.20
	drow-cplus-branch:1.20.0.6
	drow-cplus-branchpoint:1.20
	kseitz_interps-20020930-merge:1.20
	carlton_dictionary-20020927-merge:1.20
	carlton_dictionary-branch:1.20.0.4
	carlton_dictionary-20020920-branchpoint:1.20
	gdb_5_3-branch:1.20.0.2
	gdb_5_3-2002-09-04-branchpoint:1.20
	kseitz_interps-20020829-merge:1.20
	cagney_sysregs-20020825-branch:1.19.0.4
	cagney_sysregs-20020825-branchpoint:1.19
	readline_4_3-import-branch:1.19.0.2
	readline_4_3-import-branchpoint:1.19
	gdb_5_2_1-2002-07-23-release:1.18
	kseitz_interps-20020528-branch:1.18.0.8
	kseitz_interps-20020528-branchpoint:1.18
	cagney_regbuf-20020515-branch:1.18.0.6
	cagney_regbuf-20020515-branchpoint:1.18
	jimb-macro-020506-branch:1.18.0.4
	jimb-macro-020506-branchpoint:1.18
	gdb_5_2-2002-04-29-release:1.18
	gdb_5_2-branch:1.18.0.2
	gdb_5_2-2002-03-03-branchpoint:1.18
	gdb_5_1_1-2002-01-24-release:1.17
	gdb_5_1_0_1-2002-01-03-release:1.17
	cygnus_cvs_20020108_pre:1.17
	gdb_5_1_0_1-2002-01-03-branchpoint:1.17
	gdb_5_1_0_1-2002-01-03-branch:1.17.0.8
	gdb_5_1-2001-11-21-release:1.17
	gdb_s390-2001-09-26-branch:1.17.0.6
	gdb_s390-2001-09-26-branchpoint:1.17
	gdb_5_1-2001-07-29-branch:1.17.0.4
	gdb_5_1-2001-07-29-branchpoint:1.17
	dberlin-typesystem-branch:1.17.0.2
	dberlin-typesystem-branchpoint:1.17
	gdb-post-ptid_t-2001-05-03:1.17
	gdb-pre-ptid_t-2001-05-03:1.16
	insight-precleanup-2001-01-01:1.11
	gdb-post-protoization-2000-07-29:1.8
	gdb-pre-protoization-2000-07-29:1.7
	gdb-premipsmulti-2000-06-06-branch:1.7.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.7
	gdb-post-params-removal-2000-06-04:1.7
	gdb-pre-params-removal-2000-06-04:1.6
	gdb-post-params-removal-2000-05-28:1.6
	gdb-pre-params-removal-2000-05-28:1.5
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.3;
locks; strict;
comment	@ * @;


1.47
date	2007.03.30.22.50.33;	author palves;	state dead;
branches;
next	1.46;

1.46
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.45;

1.45
date	2006.04.18.19.20.06;	author drow;	state Exp;
branches;
next	1.44;

1.44
date	2006.01.24.22.09.28;	author drow;	state Exp;
branches
	1.44.8.1;
next	1.43;

1.43
date	2005.12.17.22.34.03;	author eliz;	state Exp;
branches;
next	1.42;

1.42
date	2005.05.23.19.32.28;	author cagney;	state Exp;
branches
	1.42.4.1
	1.42.8.1;
next	1.41;

1.41
date	2005.02.18.15.25.31;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2005.02.17.15.00.32;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2005.02.11.04.06.09;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.14.04.33.08;	author msnyder;	state Exp;
branches;
next	1.37;

1.37
date	2005.01.12.18.31.34;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2004.10.08.20.30.00;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2004.10.05.21.53.33;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2004.09.29.14.26.52;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2004.09.29.13.54.33;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2004.07.30.19.23.51;	author eliz;	state Exp;
branches;
next	1.31;

1.31
date	2004.07.26.14.53.06;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2004.07.22.01.31.49;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.25.19.46.08;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.24.21.51.49;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.25.14.58.31;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.06.02.52.28;	author cagney;	state Exp;
branches
	1.26.6.1;
next	1.25;

1.25
date	2003.10.10.07.13.11;	author ksakamot;	state Exp;
branches;
next	1.24;

1.24
date	2003.09.21.01.26.46;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.12.18.01.28;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.12.21.43.55;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.26.19.18.33;	author ciceron;	state Exp;
branches
	1.20.4.1
	1.20.6.1;
next	1.19;

1.19
date	2002.07.10.22.38.05;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.05.04.37.22;	author cagney;	state Exp;
branches
	1.18.8.1;
next	1.17;

1.17
date	2001.05.04.04.15.28;	author kevinb;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.21.18.31.47;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.15.16.55.15;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.05.16.59.54;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.01.01.39.22;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.23.22.48.56;	author jtc;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.15.01.01.51;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.03.22.00.56;	author jtc;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.18.22.52.23;	author jtc;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.30.01.48.28;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.28.01.12.33;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.22.15.54.56;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.21.03.04.35;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.28.06.43.20;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.28.05.03.09;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.21.39.15;	author cgf;	state Exp;
branches;
next	;

1.18.8.1
date	2002.07.22.21.47.04;	author kseitz;	state Exp;
branches;
next	1.18.8.2;

1.18.8.2
date	2002.08.30.22.52.46;	author kseitz;	state Exp;
branches;
next	1.18.8.3;

1.18.8.3
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.20.4.1
date	2002.11.15.19.19.01;	author carlton;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2003.06.27.21.50.13;	author carlton;	state Exp;
branches;
next	1.20.4.3;

1.20.4.3
date	2003.11.11.23.50.59;	author carlton;	state Exp;
branches;
next	;

1.20.6.1
date	2003.12.14.20.27.34;	author drow;	state Exp;
branches;
next	;

1.26.6.1
date	2004.09.16.17.01.27;	author drow;	state Exp;
branches;
next	;

1.42.4.1
date	2006.01.26.18.05.55;	author drow;	state Exp;
branches;
next	;

1.42.8.1
date	2006.01.26.18.10.22;	author drow;	state Exp;
branches;
next	;

1.44.8.1
date	2006.04.11.21.58.25;	author drow;	state Exp;
branches;
next	;


desc
@@


1.47
log
@gdb/

	* configure.tgt: Move mips*-*-pe and sh*-*-pe to
	the obsoletion stanza.
	* NEWS: Mention deleted targets.

	* config/sh/tm-wince.h: Remove.
	* config/sh/wince.mt: Remove.
	* config/mips/tm-wince.h: Remove.
	* config/mips/wince.mt: Remove.

	* wince.c: Remove.
	* wince-stub.c: Remove.
	* wince-stub.h: Remove.
	* Makefile.in (wince.o): Remove rule.
	(wince-stub.o): Likewise.

	* mips-tdep.c (mips_next_pc): Make static.
	* mips-tdep.h (mips_next_pc): Remove declaration.
	* arm-tdep.c (arm_pc_is_thumb): Make static.
	(thumb_get_next_pc): Likewise.
	(arm_get_next_pc): Likewise.
	* arm-tdep.h (arm_pc_is_thumb_dummy): Remove declaration.
	(arm_pc_is_thumb): Likewise.
	(thumb_get_next_pc): Likewise.
	(arm_get_next_pc): Likewise.

gdb/doc/

	* gdb.texinfo (WinCE): Delete obsolete subsection.
@
text
@/* Target-vector operations for controlling Windows CE child processes, for GDB.

   Copyright (C) 1999, 2000, 2001, 2004, 2006, 2007
   Free Software Foundation, Inc.
   Contributed by Cygnus Solutions, A Red Hat Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.
 */

/* by Christopher Faylor (cgf@@cygnus.com) */

/* We assume we're being built with and will be used for cygwin.  */

#ifdef SHx
#undef SH4
#define SH4		/* Just to get all of the CONTEXT defines.  */
#endif

#include "defs.h"
#include "frame.h"	/* required by inferior.h */
#include "inferior.h"
#include "target.h"
#include "exceptions.h"
#include "gdbcore.h"
#include "command.h"
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>

#include <windows.h>
#include <rapi.h>
#include <netdb.h>
#include <cygwin/in.h>
#include <cygwin/socket.h>

#include "buildsym.h"
#include "symfile.h"
#include "objfiles.h"
#include "gdb_string.h"
#include "gdbthread.h"
#include "gdbcmd.h"
#include <sys/param.h>
#include "wince-stub.h"
#include <time.h>
#include "regcache.h"
#ifdef MIPS
#include "mips-tdep.h"
#endif

/* If we're not using the old Cygwin header file set, define the
   following which never should have been in the generic Win32 API
   headers in the first place since they were our own invention...  */
#ifndef _GNU_H_WINDOWS_H
#define FLAG_TRACE_BIT 0x100
#ifdef CONTEXT_FLOATING_POINT
#define CONTEXT_DEBUGGER0 (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
#else
#define CONTEXT_DEBUGGER0 (CONTEXT_FULL)
#endif
#endif

#ifdef SH4
#define CONTEXT_DEBUGGER ((CONTEXT_DEBUGGER0 & ~(CONTEXT_SH4 | CONTEXT_FLOATING_POINT)) | CONTEXT_SH3)
#else
#define CONTEXT_DEBUGGER CONTEXT_DEBUGGER0
#endif
/* The string sent by cygwin when it processes a signal.
   FIXME: This should be in a cygwin include file.  */
#define CYGWIN_SIGNAL_STRING "cygwin: signal"

#define CHECK(x)	check (x, __FILE__,__LINE__)
#define DEBUG_EXEC(x)	if (debug_exec)		printf x
#define DEBUG_EVENTS(x)	if (debug_events)	printf x
#define DEBUG_MEM(x)	if (debug_memory)	printf x
#define DEBUG_EXCEPT(x)	if (debug_exceptions)	printf x

static int connection_initialized = 0;	/* True if we've initialized a
					   RAPI session.  */

/* The directory where the stub and executable files are uploaded.  */
static const char *remote_directory = "\\gdb";

/* The types automatic upload available.  */
static enum
  {
    UPLOAD_ALWAYS = 0,
    UPLOAD_NEWER = 1,
    UPLOAD_NEVER = 2
  }
upload_when = UPLOAD_NEWER;

/* Valid options for 'set remoteupload'.  Note that options
   must track upload_when enum.  */
static struct opts
  {
    const char *name;
    int abbrev;
  }
upload_options[3] =
{
  {
    "always", 1
  }
  ,
  {
    "newer", 3
  }
  ,
  {
    "never", 3
  }
};

static char *remote_upload = NULL;	/* Set by set remoteupload.  */
static int remote_add_host = 0;

static int win32_child_thread_alive (ptid_t);
void child_kill_inferior (void);

static int last_sig = 0;	/* Set if a signal was received from
				   the debugged process.  */

/* Thread information structure used to track information that is
   not available in gdb's thread structure.  */
typedef struct thread_info_struct
  {
    struct thread_info_struct *next;
    DWORD id;
    HANDLE h;
    char *name;
    int suspend_count;
    int stepped;		/* True if stepped.  */
    CORE_ADDR step_pc;
    CONTEXT context;
  }
thread_info;

static thread_info thread_head =
{NULL};
static thread_info * thread_rec (DWORD id, int get_context);

/* The process and thread handles for the above context.  */

static DEBUG_EVENT current_event;	/* The current debug event from
					   WaitForDebugEvent.  */
static HANDLE current_process_handle;	/* Currently executing process.  */
static thread_info *current_thread;	/* Info on currently selected
					   thread.  */
static thread_info *this_thread;	/* Info on thread returned by
					   wait_for_debug_event.  */
static DWORD main_thread_id;		/* Thread ID of the main thread.  */

/* Counts of things.  */
static int exception_count = 0;
static int event_count = 0;

/* User options.  */
static int debug_exec = 0;		/* show execution */
static int debug_events = 0;		/* show events from kernel */
static int debug_memory = 0;		/* show target memory accesses */
static int debug_exceptions = 0;	/* show target exceptions */

/* An array of offset mappings into a Win32 Context structure.
   This is a one-to-one mapping which is indexed by gdb's register
   numbers.  It retrieves an offset into the context structure where
   the 4 byte register is located.
   An offset value of -1 indicates that Win32 does not provide this
   register in it's CONTEXT structure.  regptr will return zero for this
   register.

   This is used by the regptr function.  */
#define context_offset(x) ((int)&(((PCONTEXT)NULL)->x))
static const int mappings[NUM_REGS + 1] =
{
#ifdef __i386__
  context_offset (Eax),
  context_offset (Ecx),
  context_offset (Edx),
  context_offset (Ebx),
  context_offset (Esp),
  context_offset (Ebp),
  context_offset (Esi),
  context_offset (Edi),
  context_offset (Eip),
  context_offset (EFlags),
  context_offset (SegCs),
  context_offset (SegSs),
  context_offset (SegDs),
  context_offset (SegEs),
  context_offset (SegFs),
  context_offset (SegGs),
  context_offset (FloatSave.RegisterArea[0 * 10]),
  context_offset (FloatSave.RegisterArea[1 * 10]),
  context_offset (FloatSave.RegisterArea[2 * 10]),
  context_offset (FloatSave.RegisterArea[3 * 10]),
  context_offset (FloatSave.RegisterArea[4 * 10]),
  context_offset (FloatSave.RegisterArea[5 * 10]),
  context_offset (FloatSave.RegisterArea[6 * 10]),
  context_offset (FloatSave.RegisterArea[7 * 10]),
#elif defined(SHx)
  context_offset (R0),
  context_offset (R1),
  context_offset (R2),
  context_offset (R3),
  context_offset (R4),
  context_offset (R5),
  context_offset (R6),
  context_offset (R7),
  context_offset (R8),
  context_offset (R9),
  context_offset (R10),
  context_offset (R11),
  context_offset (R12),
  context_offset (R13),
  context_offset (R14),
  context_offset (R15),
  context_offset (Fir),
  context_offset (PR),		/* Procedure Register */
  context_offset (GBR),		/* Global Base Register */
  context_offset (MACH),	/* Accumulate */
  context_offset (MACL),	/* Multiply */
  context_offset (Psr),
  context_offset (Fpul),
  context_offset (Fpscr),
  context_offset (FRegs[0]),
  context_offset (FRegs[1]),
  context_offset (FRegs[2]),
  context_offset (FRegs[3]),
  context_offset (FRegs[4]),
  context_offset (FRegs[5]),
  context_offset (FRegs[6]),
  context_offset (FRegs[7]),
  context_offset (FRegs[8]),
  context_offset (FRegs[9]),
  context_offset (FRegs[10]),
  context_offset (FRegs[11]),
  context_offset (FRegs[12]),
  context_offset (FRegs[13]),
  context_offset (FRegs[14]),
  context_offset (FRegs[15]),
  context_offset (xFRegs[0]),
  context_offset (xFRegs[1]),
  context_offset (xFRegs[2]),
  context_offset (xFRegs[3]),
  context_offset (xFRegs[4]),
  context_offset (xFRegs[5]),
  context_offset (xFRegs[6]),
  context_offset (xFRegs[7]),
  context_offset (xFRegs[8]),
  context_offset (xFRegs[9]),
  context_offset (xFRegs[10]),
  context_offset (xFRegs[11]),
  context_offset (xFRegs[12]),
  context_offset (xFRegs[13]),
  context_offset (xFRegs[14]),
  context_offset (xFRegs[15]),
#elif defined(MIPS)
  context_offset (IntZero),
  context_offset (IntAt),
  context_offset (IntV0),
  context_offset (IntV1),
  context_offset (IntA0),
  context_offset (IntA1),
  context_offset (IntA2),
  context_offset (IntA3),
  context_offset (IntT0),
  context_offset (IntT1),
  context_offset (IntT2),
  context_offset (IntT3),
  context_offset (IntT4),
  context_offset (IntT5),
  context_offset (IntT6),
  context_offset (IntT7),
  context_offset (IntS0),
  context_offset (IntS1),
  context_offset (IntS2),
  context_offset (IntS3),
  context_offset (IntS4),
  context_offset (IntS5),
  context_offset (IntS6),
  context_offset (IntS7),
  context_offset (IntT8),
  context_offset (IntT9),
  context_offset (IntK0),
  context_offset (IntK1),
  context_offset (IntGp),
  context_offset (IntSp),
  context_offset (IntS8),
  context_offset (IntRa),
  context_offset (Psr),
  context_offset (IntLo),
  context_offset (IntHi),
  -1,				/* bad */
  -1,				/* cause */
  context_offset (Fir),
  context_offset (FltF0),
  context_offset (FltF1),
  context_offset (FltF2),
  context_offset (FltF3),
  context_offset (FltF4),
  context_offset (FltF5),
  context_offset (FltF6),
  context_offset (FltF7),
  context_offset (FltF8),
  context_offset (FltF9),
  context_offset (FltF10),
  context_offset (FltF11),
  context_offset (FltF12),
  context_offset (FltF13),
  context_offset (FltF14),
  context_offset (FltF15),
  context_offset (FltF16),
  context_offset (FltF17),
  context_offset (FltF18),
  context_offset (FltF19),
  context_offset (FltF20),
  context_offset (FltF21),
  context_offset (FltF22),
  context_offset (FltF23),
  context_offset (FltF24),
  context_offset (FltF25),
  context_offset (FltF26),
  context_offset (FltF27),
  context_offset (FltF28),
  context_offset (FltF29),
  context_offset (FltF30),
  context_offset (FltF31),
  context_offset (Fsr),
  context_offset (Fir),
  -1,				/* fp */
#elif defined(ARM)
  context_offset (R0),
  context_offset (R1),
  context_offset (R2),
  context_offset (R3),
  context_offset (R4),
  context_offset (R5),
  context_offset (R6),
  context_offset (R7),
  context_offset (R8),
  context_offset (R9),
  context_offset (R10),
  context_offset (R11),
  context_offset (R12),
  context_offset (Sp),
  context_offset (Lr),
  context_offset (Pc),
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  context_offset (Psr),
#endif
  -1
};

/* Return a pointer into a CONTEXT field indexed by gdb register number.
   Return a pointer to an address pointing to zero if there is no
   corresponding CONTEXT field for the given register number.
 */
static ULONG *
regptr (LPCONTEXT c, int r)
{
  static ULONG zero = 0;
  ULONG *p;
  if (mappings[r] < 0)
    p = &zero;
  else
    p = (ULONG *) (((char *) c) + mappings[r]);
  return p;
}

/******************** Beginning of stub interface ********************/

/* Stub interface description:

   The Windows CE stub implements a crude RPC.  The hand-held device
   connects to gdb using port 7000.  gdb and the stub then communicate
   using packets where:

   byte 0:              command id (e.g. Create Process)

   byte 1-4:    DWORD

   byte 1-2:    WORD

   byte 1-2:    length
   byte 3-n:    arbitrary memory.

   The interface is deterministic, i.e., if the stub expects a DWORD
   then the gdb server should send a DWORD.
 */

/* Note: In the functions below, the `huh' parameter is a string
   passed from the function containing a descriptive string concerning
   the current operation.  This is used for error reporting.

   The 'what' parameter is a command id as found in wince-stub.h.

   Hopefully, the rest of the parameters are self-explanatory.
 */

static int s;			/* communication socket */

/* v-style interface for handling varying argyment list error messages.
   Displays the error message in a dialog box and exits when user clicks
   on OK.  */
static void
vstub_error (LPCSTR fmt, va_list * args)
{
  char buf[4096];
  vsprintf (buf, fmt, args);
  s = -1;
  error (("%s"), buf);
}

/* The standard way to display an error message and exit.  */
static void
stub_error (LPCSTR fmt,...)
{
  va_list args;
  va_start (args, fmt);
  vstub_error (fmt, args);
}

/* Standard "oh well" can't communicate error.  Someday this might
   attempt synchronization.  */
static void
attempt_resync (LPCSTR huh, int s)
{
  stub_error ("lost synchronization with target attempting %s", huh);
}

/* Read arbitrary stuff from a socket.  */
static int
sockread (LPCSTR huh, int s, void *str, size_t n)
{
  for (;;)
    {
      if (recv (s, str, n, 0) == n)
	return n;
      attempt_resync (huh, s);
    }
}

/* Write arbitrary stuff to a socket.  */
static int
sockwrite (LPCSTR huh, const void *str, size_t n)
{
  for (;;)
    {
      if (send (s, str, n, 0) == n)
	return n;
      attempt_resync (huh, s);
    }
}

/* Output an id/dword to the host.  */
static void
putdword (LPCSTR huh, gdb_wince_id what, DWORD n)
{
  if (sockwrite (huh, &what, sizeof (what)) != sizeof (what))
    stub_error ("error writing record id to host for %s", huh);
  if (sockwrite (huh, &n, sizeof (n)) != sizeof (n))
    stub_error ("error writing %s to host.", huh);
}

/* Output an id/word to the host.  */
static void
putword (LPCSTR huh, gdb_wince_id what, WORD n)
{
  if (sockwrite (huh, &what, sizeof (what)) != sizeof (what))
    stub_error ("error writing record id to host for %s", huh);
  if (sockwrite (huh, &n, sizeof (n)) != sizeof (n))
    stub_error ("error writing %s host.", huh);
}

/* Convenience define for outputting a "gdb_wince_len" type.  */
#define putlen(huh, what, n) putword((huh), (what), (gdb_wince_len) (n))

/* Put an arbitrary block of memory to the gdb host.  This comes in
   two chunks an id/dword representing the length and the stream of
   memory itself.  */
static void
putmemory (LPCSTR huh, gdb_wince_id what, 
	   const void *mem, gdb_wince_len len)
{
  putlen (huh, what, len);
  if (((short) len > 0) && sockwrite (huh, mem, len) != len)
    stub_error ("error writing %s to host.", huh);
}

/* Output the result of an operation to the host.  If res != 0, sends
   a block of memory starting at mem of len bytes.  If res == 0, sends
   -GetLastError () and avoids sending the mem.  */
static DWORD
getdword (LPCSTR huh, gdb_wince_id what_this)
{
  DWORD n;
  gdb_wince_id what;
  do
    if (sockread (huh, s, &what, sizeof (what)) != sizeof (what))
      stub_error ("error getting record type from host - %s.", huh);
  while (what_this != what);

  if (sockread (huh, s, &n, sizeof (n)) != sizeof (n))
    stub_error ("error getting %s from host.", huh);

  return n;
}

/* Get a an ID (possibly) and a WORD from the host gdb.
   Don't bother with the id if the main loop has already
   read it.  */
static WORD
getword (LPCSTR huh, gdb_wince_id what_this)
{
  WORD n;
  gdb_wince_id what;
  do
    if (sockread (huh, s, &what, sizeof (what)) != sizeof (what))
      stub_error ("error getting record type from host - %s.", huh);
  while (what_this != what);

  if (sockread (huh, s, &n, sizeof (n)) != sizeof (n))
    stub_error ("error getting %s from host.", huh);

  return n;
}

/* Handy defines for getting/putting various types of values.  */
#define gethandle(huh, what) (HANDLE) getdword ((huh), (what))
#define getpvoid(huh, what) (LPVOID) getdword ((huh), (what))
#define getlen(huh, what) (gdb_wince_len) getword ((huh), (what))
#define puthandle(huh, what, h) putdword ((huh), (what), (DWORD) (h))
#define putpvoid(huh, what, p) putdword ((huh), (what), (DWORD) (p))

/* Retrieve the result of an operation from the stub.  If nbytes < 0)
   then nbytes is actually an error and nothing else follows.  Use
   SetLastError to remember this.  if nbytes > 0, retrieve a block of
   *nbytes into buf.
 */
int
getresult (LPCSTR huh, gdb_wince_id what, LPVOID buf, 
	   gdb_wince_len * nbytes)
{
  gdb_wince_len dummy;
  if (nbytes == NULL)
    nbytes = &dummy;

  *nbytes = getlen (huh, what);

  if ((short) *nbytes < 0)
    {
      SetLastError (-(short) *nbytes);
      return 0;
    }

  if ((gdb_wince_len) sockread (huh, s, buf, *nbytes) != *nbytes)
    stub_error ("couldn't read information from wince stub - %s", huh);

  return 1;
}

/* Convert "narrow" string to "wide".  Manipulates a buffer ring of 8
   buffers which hold the translated string.  This is an arbitrary limit
   but it is approximately double the current needs of this module.
 */
LPWSTR
towide (const char *s, gdb_wince_len * out_len)
{
  static int n = -1;
  static LPWSTR outs[8] =
  {NULL /*, NULL, etc.  */ };
  gdb_wince_len dummy;

  if (!out_len)
    out_len = &dummy;

  /* First determine the length required to hold the converted string.  */
  *out_len = sizeof (WCHAR) * MultiByteToWideChar (CP_ACP, 0, s, 
						   -1, NULL, 0);
  if (!*out_len)
    return NULL;		/* The conversion failed.  */

  if (++n >= (sizeof (outs) / sizeof (outs[0])))
    n = 0;			/* wrap */

  /* Allocate space for the converted string, reusing any previously
     allocated space, if applicable. Note that if outs[n] is NULL,
     xrealloc will act as a malloc (under cygwin, at least).
   */
  outs[n] = (LPWSTR) xrealloc (outs[n], *out_len);
  memset (outs[n], 0, *out_len);
  (void) MultiByteToWideChar (CP_ACP, 0, s, -1, outs[n], *out_len);
  return outs[n];
}

/******************** Emulation routines start here. ********************

  The functions below are modelled after their Win32 counterparts.
  They are named similarly to Win32 and take exactly the same
  arguments except where otherwise noted.  They communicate with the
  stub on the hand-held device by sending their arguments over the
  socket and waiting for results from the socket.

  There is one universal change.  In cases where a length is expected
  to be returned in a DWORD, we use a gdb_wince_len type instead.
  Currently this is an unsigned short which is smaller than the
  standard Win32 DWORD.  This is done to minimize unnecessary traffic
  since the connection to Windows CE can be slow.  To change this,
  modify the typedef in wince-stub.h and change the putlen/getlen
  macros in this file and in the stub.
*/

static int
create_process (LPSTR exec_file, LPSTR args, DWORD flags, 
		PROCESS_INFORMATION * pi)
{
  gdb_wince_len len;
  LPWSTR buf;

  buf = towide (exec_file, &len);
  putmemory ("CreateProcess exec_file", GDB_CREATEPROCESS, buf, len);
  buf = towide (args, &len);
  putmemory ("CreateProcess args", GDB_CREATEPROCESS, buf, len);
  putdword ("CreateProcess flags", GDB_CREATEPROCESS, flags);
  return getresult ("CreateProcess result", GDB_CREATEPROCESS, pi, NULL);
}

/* Emulate TerminateProcess.  
   Don't bother with the second argument since CE ignores it.
 */
static int
terminate_process (HANDLE h)
{
  gdb_wince_result res;
  if (s < 0)
    return 1;
  puthandle ("TerminateProcess handle", GDB_TERMINATEPROCESS, h);

  return getresult ("TerminateProcess result", 
		    GDB_TERMINATEPROCESS, &res, NULL);
}

static int
wait_for_debug_event (DEBUG_EVENT * ev, DWORD ms)
{
  if (s < 0)
    return 1;
  putdword ("WaitForDebugEvent ms", GDB_WAITFORDEBUGEVENT, ms);

  return getresult ("WaitForDebugEvent event", 
		    GDB_WAITFORDEBUGEVENT, ev, NULL);
}

static int
get_thread_context (HANDLE h, CONTEXT * c)
{
  if (s < 0)
    return 1;
  puthandle ("GetThreadContext handle", GDB_GETTHREADCONTEXT, h);
  putdword ("GetThreadContext flags", GDB_GETTHREADCONTEXT, 
	    c->ContextFlags);

  return getresult ("GetThreadContext context", 
		    GDB_GETTHREADCONTEXT, c, NULL);
}

static int
set_thread_context (HANDLE h, CONTEXT * c)
{
  gdb_wince_result res;
  if (s < 0)
    return 1;
  puthandle ("SetThreadContext handle", GDB_SETTHREADCONTEXT, h);
  putmemory ("SetThreadContext context", GDB_SETTHREADCONTEXT, 
	     c, sizeof (*c));

  return getresult ("SetThreadContext context", 
		    GDB_SETTHREADCONTEXT, &res, NULL);
}

static int
read_process_memory (HANDLE h, LPCVOID where, 
		     LPVOID buf, gdb_wince_len len, 
		     gdb_wince_len * nbytes)
{
  if (s < 0)
    return 1;
  puthandle ("ReadProcessMemory handle", GDB_READPROCESSMEMORY, h);
  putpvoid ("ReadProcessMemory location", GDB_READPROCESSMEMORY, where);
  putlen ("ReadProcessMemory size", GDB_READPROCESSMEMORY, len);

  return getresult ("ReadProcessMemory buf", 
		    GDB_READPROCESSMEMORY, buf, nbytes);
}

static int
write_process_memory (HANDLE h, LPCVOID where, 
		      LPCVOID buf, gdb_wince_len len, 
		      gdb_wince_len * nbytes)
{
  if (s < 0)
    return 1;
  puthandle ("WriteProcessMemory handle", GDB_WRITEPROCESSMEMORY, h);
  putpvoid ("WriteProcessMemory location", GDB_WRITEPROCESSMEMORY, where);
  putmemory ("WriteProcProcessMemory buf", GDB_WRITEPROCESSMEMORY, buf, len);

  return getresult ("WriteProcessMemory result", 
		    GDB_WRITEPROCESSMEMORY, nbytes, NULL);
}

static int
remote_read_bytes (CORE_ADDR memaddr, char *myaddr, int len)
{
  gdb_wince_len nbytes;
  if (!read_process_memory (current_process_handle, 
			    (LPCVOID) memaddr,
			    (LPVOID) myaddr, 
			    len, &nbytes))
    return -1;
  return nbytes;
}

static int
remote_write_bytes (CORE_ADDR memaddr, char *myaddr, int len)
{
  gdb_wince_len nbytes;
  if (!write_process_memory (current_process_handle, 
			     (LPCVOID) memaddr, 
			     (LPCVOID) myaddr, 
			     len, &nbytes))
    return -1;
  return nbytes;
}

/* This is not a standard Win32 function.  It instructs the stub to
   return TRUE if the thread referenced by HANDLE h is alive.
 */
static int
thread_alive (HANDLE h)
{
  gdb_wince_result res;
  if (s < 0)
    return 1;
  puthandle ("ThreadAlive handle", GDB_THREADALIVE, h);
  return getresult ("ThreadAlive result", GDB_THREADALIVE, &res, NULL);
}

static int
suspend_thread (HANDLE h)
{
  if (s < 0)
    return 1;
  puthandle ("SuspendThread handle", GDB_SUSPENDTHREAD, h);
  return (int) getdword ("SuspendThread result", GDB_SUSPENDTHREAD);
}

static int
resume_thread (HANDLE h)
{
  if (s < 0)
    return 1;
  puthandle ("ResumeThread handle", GDB_RESUMETHREAD, h);
  return (int) getdword ("SuspendThread result", GDB_RESUMETHREAD);
}

static int
continue_debug_event (DWORD pid, DWORD tid, DWORD status)
{
  gdb_wince_result res;
  if (s < 0)
    return 0;
  putdword ("ContinueDebugEvent pid", GDB_CONTINUEDEBUGEVENT, pid);
  putdword ("ContinueDebugEvent tid", GDB_CONTINUEDEBUGEVENT, tid);
  putdword ("ContinueDebugEvent status", GDB_CONTINUEDEBUGEVENT, status);
  return getresult ("ContinueDebugEvent result", 
		    GDB_CONTINUEDEBUGEVENT, &res, NULL);
}

static int
close_handle (HANDLE h)
{
  gdb_wince_result res;
  if (s < 0)
    return 1;
  puthandle ("CloseHandle handle", GDB_CLOSEHANDLE, h);
  return (int) getresult ("CloseHandle result", 
			  GDB_CLOSEHANDLE, &res, NULL);
}

/* This is not a standard Win32 interface.  This function tells the
   stub to terminate.
 */
static void
stop_stub (void)
{
  if (s < 0)
    return;
  (void) putdword ("Stopping gdb stub", GDB_STOPSTUB, 0);
  s = -1;
}

/******************** End of emulation routines. ********************/
/******************** End of stub interface ********************/

#define check_for_step(a, x) (x)

#ifdef MIPS
static void
undoSStep (thread_info * th)
{
  if (th->stepped)
    {
      remove_single_step_breakpoints ();
      th->stepped = 0;
    }
}

void
wince_software_single_step (enum target_signal ignore,
			    int insert_breakpoints_p)
{
  unsigned long pc;
  /* Info on currently selected thread.  */
  thread_info *th = current_thread;
  CORE_ADDR mips_next_pc (CORE_ADDR pc);

  if (!insert_breakpoints_p)
    {
      undoSStep (th);
      return;
    }

  th->stepped = 1;
  pc = read_register (PC_REGNUM);
  th->step_pc = mips_next_pc (pc);
  insert_single_step_breakpoint (th->step_pc);
  return;
}
#elif SHx
/* Renesas SH architecture instruction encoding masks */

#define COND_BR_MASK   0xff00
#define UCOND_DBR_MASK 0xe000
#define UCOND_RBR_MASK 0xf0df
#define TRAPA_MASK     0xff00

#define COND_DISP      0x00ff
#define UCOND_DISP     0x0fff
#define UCOND_REG      0x0f00

/* Renesas SH instruction opcodes */

#define BF_INSTR       0x8b00
#define BT_INSTR       0x8900
#define BRA_INSTR      0xa000
#define BSR_INSTR      0xb000
#define JMP_INSTR      0x402b
#define JSR_INSTR      0x400b
#define RTS_INSTR      0x000b
#define RTE_INSTR      0x002b
#define TRAPA_INSTR    0xc300
#define SSTEP_INSTR    0xc3ff


#define T_BIT_MASK     0x0001

static CORE_ADDR
sh_get_next_pc (CONTEXT *c)
{
  short *instrMem;
  int displacement;
  int reg;
  unsigned short opcode;

  instrMem = (short *) c->Fir;

  opcode = read_memory_integer ((CORE_ADDR) c->Fir, sizeof (opcode));

  if ((opcode & COND_BR_MASK) == BT_INSTR)
    {
      if (c->Psr & T_BIT_MASK)
	{
	  displacement = (opcode & COND_DISP) << 1;
	  if (displacement & 0x80)
	    displacement |= 0xffffff00;
	  /*
	     * Remember PC points to second instr.
	     * after PC of branch ... so add 4
	   */
	  instrMem = (short *) (c->Fir + displacement + 4);
	}
      else
	instrMem += 1;
    }
  else if ((opcode & COND_BR_MASK) == BF_INSTR)
    {
      if (c->Psr & T_BIT_MASK)
	instrMem += 1;
      else
	{
	  displacement = (opcode & COND_DISP) << 1;
	  if (displacement & 0x80)
	    displacement |= 0xffffff00;
	  /*
	     * Remember PC points to second instr.
	     * after PC of branch ... so add 4
	   */
	  instrMem = (short *) (c->Fir + displacement + 4);
	}
    }
  else if ((opcode & UCOND_DBR_MASK) == BRA_INSTR)
    {
      displacement = (opcode & UCOND_DISP) << 1;
      if (displacement & 0x0800)
	displacement |= 0xfffff000;

      /*
	 * Remember PC points to second instr.
	 * after PC of branch ... so add 4
       */
      instrMem = (short *) (c->Fir + displacement + 4);
    }
  else if ((opcode & UCOND_RBR_MASK) == JSR_INSTR)
    {
      reg = (char) ((opcode & UCOND_REG) >> 8);

      instrMem = (short *) *regptr (c, reg);
    }
  else if (opcode == RTS_INSTR)
    instrMem = (short *) c->PR;
  else if (opcode == RTE_INSTR)
    instrMem = (short *) *regptr (c, 15);
  else if ((opcode & TRAPA_MASK) == TRAPA_INSTR)
    instrMem = (short *) ((opcode & ~TRAPA_MASK) << 2);
  else
    instrMem += 1;

  return (CORE_ADDR) instrMem;
}
/* Single step (in a painstaking fashion) by inspecting the current
   instruction and setting a breakpoint on the "next" instruction
   which would be executed.  This code hails from sh-stub.c.
 */
static void
undoSStep (thread_info * th)
{
  if (th->stepped)
    {
      remove_single_step_breakpoints ();
      th->stepped = 0;
    }
  return;
}

/* Single step (in a painstaking fashion) by inspecting the current
   instruction and setting a breakpoint on the "next" instruction
   which would be executed.  This code hails from sh-stub.c.
 */
void
wince_software_single_step (enum target_signal ignore,
			    int insert_breakpoints_p)
{
  /* Info on currently selected thread.  */
  thread_info *th = current_thread;

  if (!insert_breakpoints_p)
    {
      undoSStep (th);
      return;
    }

  th->stepped = 1;
  th->step_pc = sh_get_next_pc (&th->context);
  insert_single_step_breakpoint (th->step_pc);
  return;
}
#elif defined (ARM)
#undef check_for_step

static enum target_signal
check_for_step (DEBUG_EVENT *ev, enum target_signal x)
{
  thread_info *th = thread_rec (ev->dwThreadId, 1);

  if (th->stepped &&
      th->step_pc == (CORE_ADDR) ev->u.Exception.ExceptionRecord.ExceptionAddress)
    return TARGET_SIGNAL_TRAP;
  else
    return x;
}

/* Single step (in a painstaking fashion) by inspecting the current
   instruction and setting a breakpoint on the "next" instruction
   which would be executed.  This code hails from sh-stub.c.
 */
static void
undoSStep (thread_info * th)
{
  if (th->stepped)
    {
      remove_single_step_breakpoints ();
      th->stepped = 0;
    }
}

void
wince_software_single_step (enum target_signal ignore,
			    int insert_breakpoints_p)
{
  unsigned long pc;
  /* Info on currently selected thread.  */
  thread_info *th = current_thread;
  CORE_ADDR mips_next_pc (CORE_ADDR pc);

  if (!insert_breakpoints_p)
    {
      undoSStep (th);
      return;
    }

  th->stepped = 1;
  pc = read_register (PC_REGNUM);
  th->step_pc = arm_get_next_pc (pc);
  insert_single_step_breakpoint (th->step_pc);
  return;
}
#endif

/* Find a thread record given a thread id.
   If get_context then also retrieve the context for this thread.  */

static thread_info *
thread_rec (DWORD id, int get_context)
{
  thread_info *th;

  for (th = &thread_head; (th = th->next) != NULL;)
    if (th->id == id)
      {
	if (!th->suspend_count && get_context)
	  {
	    if (get_context > 0 && th != this_thread)
	      th->suspend_count = suspend_thread (th->h) + 1;
	    else if (get_context < 0)
	      th->suspend_count = -1;

	    th->context.ContextFlags = CONTEXT_DEBUGGER;
	    get_thread_context (th->h, &th->context);
	  }
	return th;
      }
  return NULL;
}

/* Add a thread to the thread list.  */
static thread_info *
child_add_thread (DWORD id, HANDLE h)
{
  thread_info *th;

  if ((th = thread_rec (id, FALSE)))
    return th;

  th = (thread_info *) xmalloc (sizeof (*th));
  memset (th, 0, sizeof (*th));
  th->id = id;
  th->h = h;
  th->next = thread_head.next;
  thread_head.next = th;
  add_thread (id);
  return th;
}

/* Clear out any old thread list and reintialize it to a
   pristine state.  */
static void
child_init_thread_list (void)
{
  thread_info *th = &thread_head;

  DEBUG_EVENTS (("gdb: child_init_thread_list\n"));
  init_thread_list ();
  while (th->next != NULL)
    {
      thread_info *here = th->next;
      th->next = here->next;
      (void) close_handle (here->h);
      xfree (here);
    }
}

/* Delete a thread from the list of threads.  */
static void
child_delete_thread (DWORD id)
{
  thread_info *th;

  if (info_verbose)
    printf_unfiltered ("[Deleting %s]\n", target_pid_to_str (id));
  delete_thread (id);

  for (th = &thread_head;
       th->next != NULL && th->next->id != id;
       th = th->next)
    continue;

  if (th->next != NULL)
    {
      thread_info *here = th->next;
      th->next = here->next;
      close_handle (here->h);
      xfree (here);
    }
}

static void
check (BOOL ok, const char *file, int line)
{
  if (!ok)
    printf_filtered ("error return %s:%d was %d\n", 
		     file, line, GetLastError ());
}

static void
do_child_fetch_inferior_registers (int r)
{
  if (r >= 0)
    {
      regcache_raw_supply (current_regcache, r,
			   (char *) regptr (&current_thread->context, r));
    }
  else
    {
      for (r = 0; r < NUM_REGS; r++)
	do_child_fetch_inferior_registers (r);
    }
}

static void
child_fetch_inferior_registers (int r)
{
  current_thread = thread_rec (PIDGET (inferior_ptid), TRUE);
  do_child_fetch_inferior_registers (r);
}

static void
do_child_store_inferior_registers (int r)
{
  if (r >= 0)
    deprecated_read_register_gen (r, ((char *) &current_thread->context) + mappings[r]);
  else
    {
      for (r = 0; r < NUM_REGS; r++)
	do_child_store_inferior_registers (r);
    }
}

/* Store a new register value into the current thread context.  */
static void
child_store_inferior_registers (int r)
{
  current_thread = thread_rec (PIDGET (inferior_ptid), TRUE);
  do_child_store_inferior_registers (r);
}

/* Wait for child to do something.  Return pid of child, or -1 in case
   of error; store status through argument pointer OURSTATUS.  */

static int
handle_load_dll (void *dummy)
{
  LOAD_DLL_DEBUG_INFO *event = &current_event.u.LoadDll;
  char dll_buf[MAX_PATH + 1];
  char *p, *bufp, *imgp, *dll_name, *dll_basename;
  int len;

  dll_buf[0] = dll_buf[sizeof (dll_buf) - 1] = '\0';
  if (!event->lpImageName)
    return 1;

  len = 0;
  for (bufp = dll_buf, imgp = event->lpImageName;
       bufp < dll_buf + sizeof (dll_buf);
       bufp += 16, imgp += 16)
    {
      gdb_wince_len nbytes = 0;
      (void) read_process_memory (current_process_handle,
				  imgp, bufp, 16, &nbytes);

      if (!nbytes && bufp == dll_buf)
	return 1;		/* couldn't read it */
      for (p = bufp; p < bufp + nbytes; p++)
	{
	  len++;
	  if (*p == '\0')
	    goto out;
	  if (event->fUnicode)
	    p++;
	}
      if (!nbytes)
	break;
    }

out:
  if (!len)
    return 1;
#if 0
  dll_buf[len] = '\0';
#endif
  dll_name = alloca (len);

  if (!dll_name)
    return 1;

  if (!event->fUnicode)
    memcpy (dll_name, dll_buf, len);
  else
    WideCharToMultiByte (CP_ACP, 0, (LPCWSTR) dll_buf,
			 len, dll_name, len, 0, 0);

  while ((p = strchr (dll_name, '\\')))
    *p = '/';

  /* FIXME!! It would be nice to define one symbol which pointed to
     the front of the dll if we can't find any symbols.  */

  if (!(dll_basename = strrchr (dll_name, '/')))
    dll_basename = dll_name;
  else
    dll_basename++;

  /* The symbols in a dll are offset by 0x1000, which is the
     the offset from 0 of the first byte in an image - because
     of the file header and the section alignment.

     FIXME: Is this the real reason that we need the 0x1000 ? */

  printf_unfiltered ("%x:%s", event->lpBaseOfDll, dll_name);
  printf_unfiltered ("\n");

  return 1;
}

/* Handle DEBUG_STRING output from child process.  */
static void
handle_output_debug_string (struct target_waitstatus *ourstatus)
{
  char p[256];
  char s[255];
  char *q;
  gdb_wince_len nbytes_read;
  gdb_wince_len nbytes = current_event.u.DebugString.nDebugStringLength;

  if (nbytes > 255)
    nbytes = 255;

  memset (p, 0, sizeof (p));
  if (!read_process_memory (current_process_handle,
			    current_event.u.DebugString.lpDebugStringData,
			    &p, nbytes, &nbytes_read)
      || !*p)
    return;

  memset (s, 0, sizeof (s));
  WideCharToMultiByte (CP_ACP, 0, (LPCWSTR) p, (int) nbytes_read,
		       s, sizeof (s) - 1, NULL, NULL);
  q = strchr (s, '\n');
  if (q != NULL)
    {
      *q = '\0';
      if (*--q = '\r')
	*q = '\0';
    }

  warning (s);

  return;
}

/* Handle target exceptions.  */
static int
handle_exception (struct target_waitstatus *ourstatus)
{
#if 0
  if (current_event.u.Exception.dwFirstChance)
    return 0;
#endif

  ourstatus->kind = TARGET_WAITKIND_STOPPED;

  switch (current_event.u.Exception.ExceptionRecord.ExceptionCode)
    {
    case EXCEPTION_ACCESS_VIOLATION:
      DEBUG_EXCEPT (("gdb: Target exception ACCESS_VIOLATION at 0x%08x\n",
		     (unsigned) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
      ourstatus->value.sig = TARGET_SIGNAL_SEGV;
      break;
    case STATUS_STACK_OVERFLOW:
      DEBUG_EXCEPT (("gdb: Target exception STACK_OVERFLOW at 0x%08x\n",
		     (unsigned) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
      ourstatus->value.sig = TARGET_SIGNAL_SEGV;
      break;
    case EXCEPTION_BREAKPOINT:
      DEBUG_EXCEPT (("gdb: Target exception BREAKPOINT at 0x%08x\n",
		     (unsigned) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
      ourstatus->value.sig = TARGET_SIGNAL_TRAP;
      break;
    case DBG_CONTROL_C:
      DEBUG_EXCEPT (("gdb: Target exception CONTROL_C at 0x%08x\n",
		     (unsigned) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
      ourstatus->value.sig = TARGET_SIGNAL_INT;
      /* User typed CTRL-C.  Continue with this status.  */
      last_sig = SIGINT;	/* FIXME - should check pass state.  */
      break;
    case EXCEPTION_SINGLE_STEP:
      DEBUG_EXCEPT (("gdb: Target exception SINGLE_STEP at 0x%08x\n",
		     (unsigned) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
      ourstatus->value.sig = TARGET_SIGNAL_TRAP;
      break;
    case EXCEPTION_ILLEGAL_INSTRUCTION:
      DEBUG_EXCEPT (("gdb: Target exception SINGLE_ILL at 0x%08x\n",
		     /* (unsigned)? */ current_event.u.Exception.ExceptionRecord.ExceptionAddress));
      ourstatus->value.sig = check_for_step (&current_event, 
					     TARGET_SIGNAL_ILL);
      break;
    default:
      /* This may be a structured exception handling exception.  In
	 that case, we want to let the program try to handle it, and
	 only break if we see the exception a second time.  */

      printf_unfiltered 
	("gdb: unknown target exception 0x%08x at 0x%08x\n",
	 current_event.u.Exception.ExceptionRecord.ExceptionCode,
	 current_event.u.Exception.ExceptionRecord.ExceptionAddress);
      ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
      break;
    }
  exception_count++;
  return 1;
}

/* Resume all artificially suspended threads if we are continuing
   execution.  */
static BOOL
child_continue (DWORD continue_status, int id)
{
  int i;
  thread_info *th;
  BOOL res;

  DEBUG_EVENTS (("ContinueDebugEvent (cpid=%d, ctid=%d, DBG_CONTINUE);\n",
		 (unsigned) current_event.dwProcessId, 
		 (unsigned) current_event.dwThreadId));
  res = continue_debug_event (current_event.dwProcessId,
			      current_event.dwThreadId,
			      continue_status);
  if (res)
    for (th = &thread_head; (th = th->next) != NULL;)
      if (((id == -1) || (id == th->id)) && th->suspend_count)
	{
	  for (i = 0; i < th->suspend_count; i++)
	    (void) resume_thread (th->h);
	  th->suspend_count = 0;
	}

  return res;
}

/* Get the next event from the child.  Return 1 if the event requires
   handling by WFI (or whatever).
 */
static int
get_child_debug_event (int pid, struct target_waitstatus *ourstatus,
		       DWORD target_event_code, int *retval)
{
  int breakout = 0;
  BOOL debug_event;
  DWORD continue_status, event_code;
  thread_info *th = NULL;
  static thread_info dummy_thread_info;

  if (!(debug_event = wait_for_debug_event (&current_event, 1000)))
    {
      *retval = 0;
      goto out;
    }

  event_count++;
  continue_status = DBG_CONTINUE;
  *retval = 0;

  event_code = current_event.dwDebugEventCode;
  breakout = event_code == target_event_code;

  switch (event_code)
    {
    case CREATE_THREAD_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "CREATE_THREAD_DEBUG_EVENT"));
      /* Record the existence of this thread */
      th = child_add_thread (current_event.dwThreadId,
			     current_event.u.CreateThread.hThread);
      if (info_verbose)
	printf_unfiltered ("[New %s]\n",
			   target_pid_to_str (current_event.dwThreadId));
      break;

    case EXIT_THREAD_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "EXIT_THREAD_DEBUG_EVENT"));
      child_delete_thread (current_event.dwThreadId);
      th = &dummy_thread_info;
      break;

    case CREATE_PROCESS_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "CREATE_PROCESS_DEBUG_EVENT"));
      current_process_handle = current_event.u.CreateProcessInfo.hProcess;

      main_thread_id = current_event.dwThreadId;
      inferior_ptid = pid_to_ptid (main_thread_id);
      /* Add the main thread */
      th = child_add_thread (PIDGET (inferior_ptid),
			     current_event.u.CreateProcessInfo.hThread);
      break;

    case EXIT_PROCESS_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "EXIT_PROCESS_DEBUG_EVENT"));
      ourstatus->kind = TARGET_WAITKIND_EXITED;
      ourstatus->value.integer = current_event.u.ExitProcess.dwExitCode;
      close_handle (current_process_handle);
      *retval = current_event.dwProcessId;
      breakout = 1;
      break;

    case LOAD_DLL_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "LOAD_DLL_DEBUG_EVENT"));
      catch_errors (handle_load_dll, NULL, 
		    (char *) "", RETURN_MASK_ALL);
      registers_changed ();	/* mark all regs invalid */
      break;

    case UNLOAD_DLL_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "UNLOAD_DLL_DEBUG_EVENT"));
      break;			/* FIXME: don't know what to do here */

    case EXCEPTION_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "EXCEPTION_DEBUG_EVENT"));
      if (handle_exception (ourstatus))
	*retval = current_event.dwThreadId;
      else
	{
	  continue_status = DBG_EXCEPTION_NOT_HANDLED;
	  breakout = 0;
	}
      break;

    case OUTPUT_DEBUG_STRING_EVENT:	/* message from the kernel */
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "OUTPUT_DEBUG_STRING_EVENT"));
      handle_output_debug_string ( ourstatus);
      break;
    default:
      printf_unfiltered ("gdb: kernel event for pid=%d tid=%d\n",
			 current_event.dwProcessId,
			 current_event.dwThreadId);
      printf_unfiltered ("                 unknown event code %d\n",
			 current_event.dwDebugEventCode);
      break;
    }

  if (breakout)
    this_thread = current_thread = th ?: thread_rec (current_event.dwThreadId,
						     TRUE);
  else
    CHECK (child_continue (continue_status, -1));

out:
  return breakout;
}

/* Wait for interesting events to occur in the target process.  */
static ptid_t
child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  DWORD event_code;
  int retval;
  int pid = PIDGET (ptid);

  /* We loop when we get a non-standard exception rather than return
     with a SPURIOUS because resume can try and step or modify things,
     which needs a current_thread->h.  But some of these exceptions mark
     the birth or death of threads, which mean that the current thread
     isn't necessarily what you think it is.  */

  while (1)
    if (get_child_debug_event (pid, ourstatus, 
			       EXCEPTION_DEBUG_EVENT, &retval))
      return pid_to_ptid (retval);
    else
      {
	int detach = 0;

	if (deprecated_ui_loop_hook != NULL)
	  detach = deprecated_ui_loop_hook (0);

	if (detach)
	  child_kill_inferior ();
      }
}

/* Print status information about what we're accessing.  */

static void
child_files_info (struct target_ops *ignore)
{
  printf_unfiltered ("\tUsing the running image of child %s.\n",
		     target_pid_to_str (inferior_ptid));
}

static void
child_open (char *arg, int from_tty)
{
  error (_("Use the \"run\" command to start a child process."));
}

#define FACTOR (0x19db1ded53ea710LL)
#define NSPERSEC 10000000

/* Convert a Win32 time to "UNIX" format.  */
long
to_time_t (FILETIME * ptr)
{
  /* A file time is the number of 100ns since jan 1 1601
     stuffed into two long words.
     A time_t is the number of seconds since jan 1 1970.  */

  long rem;
  long long x = ((long long) ptr->dwHighDateTime << 32) + ((unsigned) ptr->dwLowDateTime);
  x -= FACTOR;			/* Number of 100ns between 1601 and 1970.  */
  rem = x % ((long long) NSPERSEC);
  rem += (NSPERSEC / 2);
  x /= (long long) NSPERSEC;	/* Number of 100ns in a second.  */
  x += (long long) (rem / NSPERSEC);
  return x;
}

/* Upload a file to the remote device depending on the user's
   'set remoteupload' specification.  */
char *
upload_to_device (const char *to, const char *from)
{
  HANDLE h;
  const char *dir = remote_directory ?: "\\gdb";
  int len;
  static char *remotefile = NULL;
  LPWSTR wstr;
  char *p;
  DWORD err;
  const char *in_to = to;
  FILETIME crtime, actime, wrtime;
  time_t utime;
  struct stat st;
  int fd;

  /* Look for a path separator and only use trailing part.  */
  while ((p = strpbrk (to, "/\\")) != NULL)
    to = p + 1;

  if (!*to)
    error (_("no filename found to upload - %s."), in_to);

  len = strlen (dir) + strlen (to) + 2;
  remotefile = (char *) xrealloc (remotefile, len);
  strcpy (remotefile, dir);
  strcat (remotefile, "\\");
  strcat (remotefile, to);

  if (upload_when == UPLOAD_NEVER)
    return remotefile;		/* Don't bother uploading.  */

  /* Open the source.  */
  if ((fd = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, (char *) from,
		   O_RDONLY, 0, NULL)) < 0)
    error (_("couldn't open %s"), from);

  /* Get the time for later comparison.  */
  if (fstat (fd, &st))
    st.st_mtime = (time_t) - 1;

  /* Always attempt to create the directory on the remote system.  */
  wstr = towide (dir, NULL);
  (void) CeCreateDirectory (wstr, NULL);

  /* Attempt to open the remote file, creating it if it doesn't exist.  */
  wstr = towide (remotefile, NULL);
  h = CeCreateFile (wstr, GENERIC_READ | GENERIC_WRITE, 0, NULL,
		    OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  /* Some kind of problem?  */
  err = CeGetLastError ();
  if (h == NULL || h == INVALID_HANDLE_VALUE)
    error (_("error opening file \"%s\".  Windows error %d."),
	   remotefile, err);

  CeGetFileTime (h, &crtime, &actime, &wrtime);
  utime = to_time_t (&wrtime);
#if 0
  if (utime < st.st_mtime)
    {
      char buf[80];
      strcpy (buf, ctime(&utime));
      printf ("%s < %s\n", buf, ctime(&st.st_mtime));
    }
#endif
  /* See if we need to upload the file.  */
  if (upload_when == UPLOAD_ALWAYS ||
      err != ERROR_ALREADY_EXISTS ||
      !CeGetFileTime (h, &crtime, &actime, &wrtime) ||
      to_time_t (&wrtime) < st.st_mtime)
    {
      DWORD nbytes;
      char buf[4096];
      int n;

      /* Upload the file.  */
      while ((n = read (fd, buf, sizeof (buf))) > 0)
	if (!CeWriteFile (h, buf, (DWORD) n, &nbytes, NULL))
	  error (_("error writing to remote device - %d."),
		 CeGetLastError ());
    }

  close (fd);
  if (!CeCloseHandle (h))
    error (_("error closing remote file - %d."), CeGetLastError ());

  return remotefile;
}

/* Initialize the connection to the remote device.  */
static void
wince_initialize (void)
{
  int tmp;
  char args[256];
  char *hostname;
  struct sockaddr_in sin;
  char *stub_file_name;
  int s0;
  PROCESS_INFORMATION pi;

  if (!connection_initialized)
    switch (CeRapiInit ())
      {
      case 0:
	connection_initialized = 1;
	break;
      default:
	CeRapiUninit ();
	error (_("Can't initialize connection to remote device."));
      }

  /* Upload the stub to the handheld device.  */
  stub_file_name = upload_to_device ("wince-stub.exe", WINCE_STUB);
  strcpy (args, stub_file_name);

  if (remote_add_host)
    {
      strcat (args, " ");
      hostname = strchr (args, '\0');
      if (gethostname (hostname, sizeof (args) - strlen (args)))
	error (_("couldn't get hostname of this system."));
    }

  /* Get a socket.  */
  if ((s0 = socket (AF_INET, SOCK_STREAM, 0)) < 0)
    stub_error ("Couldn't connect to host system.");

  /* Allow rapid reuse of the port.  */
  tmp = 1;
  (void) setsockopt (s0, SOL_SOCKET, SO_REUSEADDR, 
		     (char *) &tmp, sizeof (tmp));


  /* Set up the information for connecting to the host gdb process.  */
  memset (&sin, 0, sizeof (sin));
  sin.sin_family = AF_INET;
  sin.sin_port = htons (7000);	/* FIXME: This should be configurable.  */

  if (bind (s0, (struct sockaddr *) &sin, sizeof (sin)))
    error (_("couldn't bind socket"));

  if (listen (s0, 1))
    error (_("Couldn't open socket for listening."));

  /* Start up the stub on the remote device.  */
  if (!CeCreateProcess (towide (stub_file_name, NULL), 
			towide (args, NULL),
			NULL, NULL, 0, 0, 
			NULL, NULL, NULL, &pi))
    error (_("Unable to start remote stub '%s'.  Windows CE error %d."),
	   stub_file_name, CeGetLastError ());

  /* Wait for a connection */

  if ((s = accept (s0, NULL, NULL)) < 0)
    error (_("couldn't set up server for connection."));

  close (s0);
}

/* Start an inferior win32 child process and sets inferior_ptid to its pid.
   EXEC_FILE is the file to run.
   ALLARGS is a string containing the arguments to the program.
   ENV is the environment vector to pass.  
   Errors reported with error().  */
static void
child_create_inferior (char *exec_file, char *args, char **env,
		       int from_tty)
{
  PROCESS_INFORMATION pi;
  struct target_waitstatus dummy;
  int ret;
  DWORD flags, event_code;
  char *exec_and_args;

  if (!exec_file)
    error (_("No executable specified, use `target exec'."));

  flags = DEBUG_PROCESS;

  wince_initialize ();		/* Make sure we've got a connection.  */

  exec_file = upload_to_device (exec_file, exec_file);

  while (*args == ' ')
    args++;

  /* Allocate space for "command<sp>args" */
  if (*args == '\0')
    {
      exec_and_args = alloca (strlen (exec_file) + 1);
      strcpy (exec_and_args, exec_file);
    }
  else
    {
      exec_and_args = alloca (strlen (exec_file + strlen (args) + 2));
      sprintf (exec_and_args, "%s %s", exec_file, args);
    }

  memset (&pi, 0, sizeof (pi));
  /* Execute the process.  */
  if (!create_process (exec_file, exec_and_args, flags, &pi))
    error (_("Error creating process %s, (error %d)."), 
	   exec_file, GetLastError ());

  exception_count = 0;
  event_count = 0;

  current_process_handle = pi.hProcess;
  current_event.dwProcessId = pi.dwProcessId;
  memset (&current_event, 0, sizeof (current_event));
  current_event.dwThreadId = pi.dwThreadId;
  inferior_ptid = pid_to_ptid (current_event.dwThreadId);
  push_target (&deprecated_child_ops);
  child_init_thread_list ();
  child_add_thread (pi.dwThreadId, pi.hThread);
  init_wait_for_inferior ();
  clear_proceed_status ();
  target_terminal_init ();
  target_terminal_inferior ();

  /* Run until process and threads are loaded */
  while (!get_child_debug_event (PIDGET (inferior_ptid), &dummy,
				 CREATE_PROCESS_DEBUG_EVENT, &ret))
    continue;
}

/* Chile has gone bye-bye.  */
static void
child_mourn_inferior (void)
{
  (void) child_continue (DBG_CONTINUE, -1);
  unpush_target (&deprecated_child_ops);
  stop_stub ();
  CeRapiUninit ();
  connection_initialized = 0;
  generic_mourn_inferior ();
}

/* Move memory from child to/from gdb.  */
int
child_xfer_memory (CORE_ADDR memaddr, gdb_byte *our, 
		   int len, int write,
		   struct mem_attrib *attrib,
		   struct target_ops *target)
{
  if (len <= 0)
    return 0;

  if (write)
    res = remote_write_bytes (memaddr, our, len);
  else
    res = remote_read_bytes (memaddr, our, len);

  return res;
}

/* Terminate the process and wait for child to tell us it has
   completed.  */
void
child_kill_inferior (void)
{
  CHECK (terminate_process (current_process_handle));

  for (;;)
    {
      if (!child_continue (DBG_CONTINUE, -1))
	break;
      if (!wait_for_debug_event (&current_event, INFINITE))
	break;
      if (current_event.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT)
	break;
    }

  CHECK (close_handle (current_process_handle));
  close_handle (current_thread->h);
  target_mourn_inferior ();	/* or just child_mourn_inferior?  */
}

/* Resume the child after an exception.  */
void
child_resume (ptid_t ptid, int step, enum target_signal sig)
{
  thread_info *th;
  DWORD continue_status = last_sig > 0 && last_sig < NSIG ?
    DBG_EXCEPTION_NOT_HANDLED : DBG_CONTINUE;
  int pid = PIDGET (ptid);

  DEBUG_EXEC (("gdb: child_resume (pid=%d, step=%d, sig=%d);\n",
	       pid, step, sig));

  /* Get context for currently selected thread */
  th = thread_rec (current_event.dwThreadId, FALSE);

  if (th->context.ContextFlags)
    {
      CHECK (set_thread_context (th->h, &th->context));
      th->context.ContextFlags = 0;
    }

  /* Allow continuing with the same signal that interrupted us.
     Otherwise complain.  */
  if (sig && sig != last_sig)
    fprintf_unfiltered (gdb_stderr, 
			"Can't send signals to the child.  signal %d\n", 
			sig);

  last_sig = 0;
  child_continue (continue_status, pid);
}

static void
child_prepare_to_store (void)
{
  /* Do nothing, since we can store individual regs */
}

static int
child_can_run (void)
{
  return 1;
}

static void
child_close (void)
{
  DEBUG_EVENTS (("gdb: child_close, inferior_ptid=%d\n",
		 PIDGET (inferior_ptid)));
}

/* Explicitly upload file to remotedir */

static void
child_load (char *file, int from_tty)
{
  upload_to_device (file, file);
}

static void
init_child_ops (void)
{
  memset (&deprecated_child_ops, 0, sizeof (deprecated_child_ops));
  deprecated_child_ops.to_shortname = (char *) "child";
  deprecated_child_ops.to_longname = (char *) "Windows CE process";
  deprecated_child_ops.to_doc = (char *) "Windows CE process (started by the \"run\" command).";
  deprecated_child_ops.to_open = child_open;
  deprecated_child_ops.to_close = child_close;
  deprecated_child_ops.to_resume = child_resume;
  deprecated_child_ops.to_wait = child_wait;
  deprecated_child_ops.to_fetch_registers = child_fetch_inferior_registers;
  deprecated_child_ops.to_store_registers = child_store_inferior_registers;
  deprecated_child_ops.to_prepare_to_store = child_prepare_to_store;
  deprecated_child_ops.deprecated_xfer_memory = child_xfer_memory;
  deprecated_child_ops.to_files_info = child_files_info;
  deprecated_child_ops.to_insert_breakpoint = memory_insert_breakpoint;
  deprecated_child_ops.to_remove_breakpoint = memory_remove_breakpoint;
  deprecated_child_ops.to_terminal_init = terminal_init_inferior;
  deprecated_child_ops.to_terminal_inferior = terminal_inferior;
  deprecated_child_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  deprecated_child_ops.to_terminal_ours = terminal_ours;
  deprecated_child_ops.to_terminal_save_ours = terminal_save_ours;
  deprecated_child_ops.to_terminal_info = child_terminal_info;
  deprecated_child_ops.to_kill = child_kill_inferior;
  deprecated_child_ops.to_load = child_load;
  deprecated_child_ops.to_create_inferior = child_create_inferior;
  deprecated_child_ops.to_mourn_inferior = child_mourn_inferior;
  deprecated_child_ops.to_can_run = child_can_run;
  deprecated_child_ops.to_thread_alive = win32_child_thread_alive;
  deprecated_child_ops.to_stratum = process_stratum;
  deprecated_child_ops.to_has_all_memory = 1;
  deprecated_child_ops.to_has_memory = 1;
  deprecated_child_ops.to_has_stack = 1;
  deprecated_child_ops.to_has_registers = 1;
  deprecated_child_ops.to_has_execution = 1;
  deprecated_child_ops.to_magic = OPS_MAGIC;
}


/* Handle 'set remoteupload' parameter.  */

#define replace_upload(what) \
    upload_when = what; \
    remote_upload = xrealloc (remote_upload, \
			      strlen (upload_options[upload_when].name) + 1); \
    strcpy (remote_upload, upload_options[upload_when].name);

static void
set_upload_type (char *ignore, int from_tty)
{
  int i, len;
  char *bad_option;

  if (!remote_upload || !remote_upload[0])
    {
      replace_upload (UPLOAD_NEWER);
      if (from_tty)
	printf_unfiltered ("Upload upload_options are: always, newer, never.\n");
      return;
    }

  len = strlen (remote_upload);
  for (i = 0; 
       i < (sizeof (upload_options) / sizeof (upload_options[0])); 
       i++)
    if (len >= upload_options[i].abbrev &&
	strncasecmp (remote_upload, upload_options[i].name, len) == 0)
      {
	replace_upload (i);
	return;
      }

  bad_option = remote_upload;
  replace_upload (UPLOAD_NEWER);
  error (_("Unknown upload type: %s."), bad_option);
}

void
_initialize_wince (void)
{
  struct cmd_list_element *set;
  init_child_ops ();

  add_setshow_string_noescape_cmd ("remotedirectory", no_class,
				   &remote_directory, _("\
Set directory for remote upload."), _("\
Show directory for remote upload."), NULL,
				   NULL, /* FIXME: i18n: */
				   NULL, NULL,
				   &setlist, &showlist);
  remote_directory = xstrdup (remote_directory);

  add_setshow_string_noescape_cmd ("remoteupload", no_class,
				   &remote_upload, _("\
Set how to upload executables to remote device."), _("\
Show how to upload executables to remote device."), NULL,
				   NULL, /* FIXME: i18n: */
				   set_upload_type, NULL,
				   &setlist, &showlist);
  set_upload_type (NULL, 0);

  add_setshow_boolean_cmd ("debugexec", class_support, &debug_exec, _("\
Set whether to display execution in child process."), _("\
Show whether to display execution in child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("remoteaddhost", class_support,
			   &remote_add_host, _("\
Set whether to add this host to remote stub arguments for\n\
debugging over a network."), _("\
Show whether to add this host to remote stub arguments for\n\
debugging over a network."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("debugevents", class_support, &debug_events, _("\
Set whether to display kernel events in child process."), _("\
Show whether to display kernel events in child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("debugmemory", class_support, &debug_memory, _("\
Set whether to display memory accesses in child process."), _("\
Show whether to display memory accesses in child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("debugexceptions", class_support,
			   &debug_exceptions, _("\
Set whether to display kernel exceptions in child process."), _("\
Show whether to display kernel exceptions in child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_target (&deprecated_child_ops);
}

/* Determine if the thread referenced by "pid" is alive by "polling"
   it.  If WaitForSingleObject returns WAIT_OBJECT_0 it means that the
   pid has died.  Otherwise it is assumed to be alive.  */
static int
win32_child_thread_alive (ptid_t ptid)
{
  int pid = PIDGET (ptid);
  return thread_alive (thread_rec (pid, FALSE)->h);
}

/* Convert pid to printable format.  */
char *
cygwin_pid_to_str (int pid)
{
  static char buf[80];
  if (pid == current_event.dwProcessId)
    sprintf (buf, "process %d", pid);
  else
    sprintf (buf, "thread %d.0x%x", 
	     (unsigned) current_event.dwProcessId, pid);
  return buf;
}
@


1.46
log
@Copyright updates for 2007.
@
text
@@


1.45
log
@gdb/
	* breakpoint.c (deprecated_read_memory_nobpt): Update to use
	shadow_len.
	(insert_bp_location, reattach_breakpoints, remove_breakpoint)
	(delete_breakpoint): Update calls to changed methods.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(single_step_breakpoints, insert_single_step_breakpoint)
	(remove_single_step_breakpoints): New.
	* breakpoint.h (struct bp_target_info): New.
	(struct bp_location): Replace shadow_contents with
	target_info and overlay_target_info.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(insert_single_step_breakpoint, remove_single_step_breakpoints): New
	prototypes.
	* gdbarch.sh: Forward declare struct bp_target_info in gdbarch.h.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update second
	argument.
	* mem-break.c (default_memory_insert_breakpoint): Update.  Set
	placed_address, placed_size, and shadow_len.
	(default_memory_remove_breakpoint): Update.  Don't use
	BREAKPOINT_FROM_PC.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update.
	* target.c (update_current_target): Update prototypes for changed
	functions.
	(debug_to_insert_breakpoint, debug_to_remove_breakpoint)
	(debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint):
	Update.
	* target.h: Forward declare struct bp_target_info.
	(struct target_ops): Use a bp_target_info argument for
	to_insert_breakpoint, to_remove_breakpoint,
	to_insert_hw_breakpoint, and to_remove_hw_breakpoint.
	(target_insert_breakpoint, target_remove_breakpoint)
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint)
	(memory_insert_breakpoint, memory_remove_breakpoint)
	(default_memory_insert_breakpoint, default_memory_remove_breakpoint):
	Update.
	* config/i386/nm-i386.h: Forward declare struct bp_target_info.
	(i386_insert_hw_breakpoint, i386_remove_hw_breakpoint): Update.
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint): Likewise.

	* gdbarch.c, gdbarch.h: Regenerated.

	* alpha-tdep.c (alpha_software_single_step): Use
	insert_single_step_breakpoint and remove_single_step_breakpoints.
	Remove unused statics.
	* arm-tdep.c (arm_software_single_step): Likewise.  Add a note.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* wince.c (struct thread_info_struct): Remove step_prev.
	(undoSStep): Use remove_single_step_breakpoints.
	(wince_software_single_step): Use insert_single_step_breakpoint.

	* corelow.c (ignore): Remove unneeded prototype.  Update arguments.
	* exec.c (ignore): Likewise.
	* sol-thread.c (ignore): Likewise.

	* procfs.c (dbx_link_shadow_contents): Delete.
	(dbx_link_bpt): New.
	(procfs_mourn_inferior): Remove it if necessary.
	(remove_dbx_link_breakpoint): Use it.
	(insert_dbx_link_bpt_in_file): Set it.
	(procfs_init_inferior): Don't update dbx_link_bpt_addr.
	* rs6000-nat.c (exec_one_dummy_insn): Use
	deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* solib-irix.c (shadow_contents, breakpoint_addr): Delete.
	(base_breakpoint): New.
	(disable_break): Use it.
	(enable_break): Set it.

	* i386-nat.c (i386_insert_hw_breakpoint, i386_remove_hw_breakpoint):
	Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
	* monitor.c (monitor_insert_breakpoint, monitor_remove_breakpoint):
	Likewise.  Remove unnecessary prototypes.  Use placed_address
	and placed_size.  Removed useless read from memory.
	* nto-procfs.c (procfs_insert_breakpoint)
	(procfs_remove_breakpoint, procfs_insert_hw_breakpoint)
	(procfs_remove_hw_breakpoint): Update.
	* ocd.c (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ocd.h (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Likewise.
	* remote-m32r-sdi.c (m32r_insert_breakpoint)
	(m32r_remove_breakpoint): Likewise.
	* remote-mips.c (mips_insert_breakpoint)
	(mips_remove_breakpoint): Likewise.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Likewise.
	(rdp_step): Use deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* remote-sds.c (sds_insert_breakpoint, sds_remove_breakpoint):
	Update.
	* remote-sim.c (gdbsim_insert_breakpoint, gdbsim_remove_breakpoint):
	Delete.
	(init_gdbsim_ops): Use memory_insert_breakpoint and
	memory_remove_breakpoint.
	* remote-st.c (st2000_insert_breakpoint)
	(st2000_remove_breakpoint): Update.  Remove unused
	BREAKPOINT_FROM_PC.
	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint):
	Update.  Use placed_address and placed_size.
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Likewise.
gdb/doc/
	* gdbint.texinfo (x86 Watchpoints, Target Conditionals): Update insert
	and remove breakpoint prototypes.
	(Watchpoints): Move description of target_insert_hw_breakpoint and
	target_remove_hw_breakpoint ...
	(Breakpoints): ... to here.  Document target_insert_breakpoint and
	target_remove_breakpoint.
@
text
@d3 2
a4 1
   Copyright (C) 1999, 2000, 2001, 2004, 2006 Free Software Foundation, Inc.
@


1.44
log
@	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.

	* gnu-nat.c (gnu_create_inferior): Don't call proceed.
	* go32-nat.c (go32_create_inferior): Likewise.
	* nto-procfs.c (procfs_create_inferior): Likewise.
	* procfs.c (procfs_create_inferior): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Likewise.
	* remote.c (extended_remote_create_inferior)
	(extended_remote_async_create_inferior): Likewise.
	* win32-nat.c (win32_create_inferior): Likewise.
	* wince.c (child_create_inferior): Likewise.

	* monitor.c (monitor_create_inferior): Don't call proceed.
	Set the PC manually.
	* ocd.c (ocd_create_inferior): Likewise.
	* remote-e7000.c (e7000_create_inferior): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior): Likewise.
	* remote-mips.c (mips_create_inferior): Likewise.
	* remote-rdp.c (remote_rdp_create_inferior): Likewise.
	* remote-sds.c (sds_create_inferior): Likewise.
	* remote-st.c (st2000_create_inferior): Likewise.

	* inf-ptrace.c (inf_ptrace_create_inferior): Don't call
	proceed or observer_notify_inferior_created.
	* inf-ttrace.c (inf_ttrace_create_inferior): Likewise.
	* inftarg.c (child_create_inferior): Likewise.
@
text
@a148 1
    unsigned long step_prev;
d836 1
a836 1
      memory_remove_breakpoint (th->step_pc, (void *) &th->step_prev);
d859 1
a859 2
  th->step_prev = 0;
  memory_insert_breakpoint (th->step_pc, (void *) &th->step_prev);
d972 1
a972 1
      memory_remove_breakpoint (th->step_pc, (void *) &th->step_prev);
d997 1
a997 2
  th->step_prev = 0;
  memory_insert_breakpoint (th->step_pc, (void *) &th->step_prev);
d1024 1
a1024 1
      memory_remove_breakpoint (th->step_pc, (void *) &th->step_prev);
d1047 1
a1047 2
  th->step_prev = 0;
  memory_insert_breakpoint (th->step_pc, (void *) &th->step_prev);
@


1.44.8.1
log
@Merge to branch:
  http://sourceware.org/ml/gdb-patches/2006-04/msg00139.html
@
text
@d149 1
d837 1
a837 1
      remove_single_step_breakpoints ();
d860 2
a861 1
  insert_single_step_breakpoint (th->step_pc);
d974 1
a974 1
      remove_single_step_breakpoints ();
d999 2
a1000 1
  insert_single_step_breakpoint (th->step_pc);
d1027 1
a1027 1
      remove_single_step_breakpoints ();
d1050 2
a1051 1
  insert_single_step_breakpoint (th->step_pc);
@


1.43
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2004 Free Software Foundation, Inc.
a1823 2

  proceed ((CORE_ADDR) -1, TARGET_SIGNAL_0, 0);
@


1.42
log
@2005-05-23  Andrew Cagney  <cagney@@gnu.org>

	* target.h (child_xfer_memory): Use gdb_byte for byte buffer
	parameters.
	* inftarg.c (child_xfer_partial): Update.
	* wince.c (child_xfer_memory): Update.
	* win32-nat.c (child_xfer_memory): Update.
	* rs6000-nat.c (child_xfer_memory): Update.
	* infptrace.c (child_xfer_memory): Update.
	* dcache.c (struct dcache_block): Use gdb_byte for the byte
	buffers.
	(dcache_read_line, dcache_xfer_memory, dcache_poke_byte)
	(dcache_peek_byte, dcache_write_line): Ditto.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2004 Free Software Foundation, Inc.
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.
@


1.42.8.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d1824 2
@


1.42.4.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d1824 2
@


1.41
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_boolean_command through out.  Delete #ifdef 0'ed
	code adding set/show boolean commands.
	* cp-valprint.c, dcache.c, exec.c, gdbtypes.c, infrun.c: Update.
	* monitor.c, p-valprint.c, pa64solib.c, printcmd.c: Update.
	* proc-api.c, remote-mips.c, remote.c, solib.c: Update.
	* somsolib.c, symfile.c, top.c, utils.c, valops.c: Update.
	* valprint.c, win32-nat.c, wince.c, xcoffsolib.c: Update.
	* cli/cli-cmds.c: Update.
@
text
@d1842 1
a1842 1
child_xfer_memory (CORE_ADDR memaddr, char *our, 
@


1.40
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* command.h (fprint_setshow_ftype): Delete.
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* complaints.c, cris-tdep.c, dwarf2read.c, frame.c: Update.
	* hppa-tdep.c, infcall.c, m32r-rom.c, maint.c: Update.
	* mips-tdep.c, nto-tdep.c, observer.c, remote-rdi.c: Update
	* remote.c, target.c, cli/cli-logging.c: Update.
@
text
@d2041 9
a2049 14
  deprecated_add_show_from_set
    (add_set_cmd ((char *) "debugexec", 
		  class_support, var_boolean,
		  (char *) &debug_exec,
		  (char *) "\
Set whether to display execution in child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ((char *) "remoteaddhost", 
		  class_support, var_boolean,
		  (char *) &remote_add_host,
		  (char *) "\
d2051 28
a2078 30
debugging over a network.", 
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ((char *) "debugevents", 
		  class_support, var_boolean,
		  (char *) &debug_events,
		  (char *) "\
Set whether to display kernel events in child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ((char *) "debugmemory", 
		  class_support, var_boolean,
		  (char *) &debug_memory,
		  (char *) "\
Set whether to display memory accesses in child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set 
    (add_set_cmd ((char *) "debugexceptions", 
		  class_support, var_boolean,
		  (char *) &debug_exceptions,
		  (char *) "\
Set whether to display kernel exceptions in child process.",
		  &setlist),
     &showlist);
@


1.39
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d2023 7
a2029 6
  deprecated_add_show_from_set
    (add_set_cmd ((char *) "remotedirectory", no_class,
		  var_string_noescape, (char *) &remote_directory,
		  (char *) "Set directory for remote upload.\n",
		  &setlist),
     &showlist);
d2032 7
a2038 8
  set = add_set_cmd ((char *) "remoteupload", no_class,
		     var_string_noescape, (char *) &remote_upload,
		     (char *) "\
Set how to upload executables to remote device.\n",
		     &setlist);

  deprecated_add_show_from_set (set, &showlist);
  set_cmd_cfunc (set, set_upload_type);
@


1.38
log
@2005-01-13  Michael Snyder  <msnyder@@redhat.com>

	* wince.c: Whitespace tweaks.
@
text
@d435 1
a435 1
  error ("%s", buf);
d1571 1
a1571 1
  error ("Use the \"run\" command to start a child process.");
d1618 1
a1618 1
    error ("no filename found to upload - %s.", in_to);
d1632 1
a1632 1
    error ("couldn't open %s", from);
d1650 1
a1650 1
    error ("error opening file \"%s\".  Windows error %d.",
d1676 1
a1676 1
	  error ("error writing to remote device - %d.",
d1682 1
a1682 1
    error ("error closing remote file - %d.", CeGetLastError ());
d1707 1
a1707 2
	error ("Can't initialize connection to remote device.\n");
	break;
d1719 1
a1719 1
	error ("couldn't get hostname of this system.");
d1738 1
a1738 1
    error ("couldn't bind socket");
d1741 1
a1741 1
    error ("Couldn't open socket for listening.\n");
d1748 1
a1748 1
    error ("Unable to start remote stub '%s'.  Windows CE error %d.",
d1754 1
a1754 1
    error ("couldn't set up server for connection.");
d1775 1
a1775 1
    error ("No executable specified, use `target exec'.\n");
d1801 1
a1801 1
    error ("Error creating process %s, (error %d)\n", 
d2014 1
a2014 1
  error ("Unknown upload type: %s.", bad_option);
@


1.37
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d30 1
a30 1
#define SH4			/* Just to get all of the CONTEXT defines. */
d34 1
a34 1
#include "frame.h"		/* required by inferior.h */
d67 1
a67 1
   headers in the first place since they were our own invention... */
d83 1
a83 1
   FIXME: This should be in a cygwin include file. */
d92 2
a93 1
static int connection_initialized = 0;	/* True if we've initialized a RAPI session. */
d95 1
a95 1
/* The directory where the stub and executable files are uploaded. */
d98 1
a98 1
/* The types automatic upload available. */
d108 1
a108 1
   must track upload_when enum. */
d129 1
a129 1
static char *remote_upload = NULL;	/* Set by set remoteupload */
d135 2
a136 2
static int last_sig = 0;	/* Set if a signal was received from the
				   debugged process */
d139 1
a139 1
   not available in gdb's thread structure. */
d147 1
a147 1
    int stepped;		/* True if stepped. */
d158 1
a158 1
/* The process and thread handles for the above context. */
d161 7
a167 5
					   WaitForDebugEvent */
static HANDLE current_process_handle;	/* Currently executing process */
static thread_info *current_thread;	/* Info on currently selected thread */
static thread_info *this_thread;	/* Info on thread returned by wait_for_debug_event */
static DWORD main_thread_id;	/* Thread ID of the main thread */
d169 1
a169 1
/* Counts of things. */
d173 4
a176 4
/* User options. */
static int debug_exec = 0;	/* show execution */
static int debug_events = 0;	/* show events from kernel */
static int debug_memory = 0;	/* show target memory accesses */
d187 1
a187 1
   This is used by the regptr function. */
d411 2
a412 2
   The interface is deterministic, i.e., if the stub expects a DWORD then
   the gdb server should send a DWORD.
d415 3
a417 3
/* Note:  In the functions below, the `huh' parameter is a string passed from the
   function containing a descriptive string concerning the current operation.
   This is used for error reporting.
d428 1
a428 1
   on OK. */
d438 1
a438 1
/* The standard way to display an error message and exit. */
d447 2
a448 2
/* Standard "oh well" can't communicate error.  Someday this might attempt
   synchronization. */
d455 1
a455 1
/* Read arbitrary stuff from a socket. */
d467 1
a467 1
/* Write arbitrary stuff to a socket. */
d479 1
a479 1
/* Output an id/dword to the host */
d489 1
a489 1
/* Output an id/word to the host */
d499 1
a499 1
/* Convenience define for outputting a "gdb_wince_len" type. */
d503 2
a504 2
   two chunks an id/dword representing the length and the stream of memory
   itself. */
d506 2
a507 1
putmemory (LPCSTR huh, gdb_wince_id what, const void *mem, gdb_wince_len len)
d514 3
a516 3
/* Output the result of an operation to the host.  If res != 0, sends a block of
   memory starting at mem of len bytes.  If res == 0, sends -GetLastError () and
   avoids sending the mem. */
d535 1
a535 1
   read it. */
d552 1
a552 1
/* Handy defines for getting/putting various types of values. */
d559 4
a562 3
/* Retrieve the result of an operation from the stub.  If nbytes < 0) then nbytes
   is actually an error and nothing else follows.  Use SetLastError to remember this.
   if nbytes > 0, retrieve a block of *nbytes into buf.
d565 2
a566 1
getresult (LPCSTR huh, gdb_wince_id what, LPVOID buf, gdb_wince_len * nbytes)
d595 1
a595 1
  {NULL /*, NULL, etc. */ };
d601 3
a603 2
  /* First determine the length required to hold the converted string. */
  *out_len = sizeof (WCHAR) * MultiByteToWideChar (CP_ACP, 0, s, -1, NULL, 0);
d605 1
a605 1
    return NULL;		/* The conversion failed */
d610 3
a612 3
  /* Allocate space for the converted string, reusing any previously allocated
     space, if applicable. Note that if outs[n] is NULL, xrealloc will act as
     a malloc (under cygwin, at least).
d622 13
a634 11
  The functions below are modelled after their Win32 counterparts.  They are named
  similarly to Win32 and take exactly the same arguments except where otherwise noted.
  They communicate with the stub on the hand-held device by sending their arguments
  over the socket and waiting for results from the socket.

  There is one universal change.  In cases where a length is expected to be returned
  in a DWORD, we use a gdb_wince_len type instead.  Currently this is an unsigned short
  which is smaller than the standard Win32 DWORD.  This is done to minimize unnecessary
  traffic since the connection to Windows CE can be slow.  To change this, modify the
  typedef in wince-stub.h and change the putlen/getlen macros in this file and in
  the stub.
d638 2
a639 1
create_process (LPSTR exec_file, LPSTR args, DWORD flags, PROCESS_INFORMATION * pi)
d652 2
a653 2
/* Emulate TerminateProcess.  Don't bother with the second argument since CE
   ignores it.
d662 3
a664 1
  return getresult ("TerminateProcess result", GDB_TERMINATEPROCESS, &res, NULL);
d673 3
a675 1
  return getresult ("WaitForDebugEvent event", GDB_WAITFORDEBUGEVENT, ev, NULL);
d684 5
a688 2
  putdword ("GetThreadContext flags", GDB_GETTHREADCONTEXT, c->ContextFlags);
  return getresult ("GetThreadContext context", GDB_GETTHREADCONTEXT, c, NULL);
d698 5
a702 2
  putmemory ("SetThreadContext context", GDB_SETTHREADCONTEXT, c, sizeof (*c));
  return getresult ("SetThreadContext context", GDB_SETTHREADCONTEXT, &res, NULL);
d706 3
a708 1
read_process_memory (HANDLE h, LPCVOID where, LPVOID buf, gdb_wince_len len, gdb_wince_len * nbytes)
d716 2
a717 1
  return getresult ("ReadProcessMemory buf", GDB_READPROCESSMEMORY, buf, nbytes);
d721 3
a723 1
write_process_memory (HANDLE h, LPCVOID where, LPCVOID buf, gdb_wince_len len, gdb_wince_len * nbytes)
d731 2
a732 1
  return getresult ("WriteProcessMemory result", GDB_WRITEPROCESSMEMORY, nbytes, NULL);
d739 4
a742 2
  if (!read_process_memory (current_process_handle, (LPCVOID) memaddr,
			    (LPVOID) myaddr, len, &nbytes))
d751 4
a754 2
  if (!write_process_memory (current_process_handle, (LPCVOID) memaddr,
			     (LPCVOID) myaddr, len, &nbytes))
d759 2
a760 2
/* This is not a standard Win32 function.  It instructs the stub to return TRUE
   if the thread referenced by HANDLE h is alive.
d799 2
a800 1
  return getresult ("ContinueDebugEvent result", GDB_CONTINUEDEBUGEVENT, &res, NULL);
d810 2
a811 1
  return (int) getresult ("CloseHandle result", GDB_CLOSEHANDLE, &res, NULL);
d814 2
a815 2
/* This is not a standard Win32 interface.  This function tells the stub
   to terminate.
d847 2
a848 1
  thread_info *th = current_thread;	/* Info on currently selected thread */
d988 2
a989 1
  thread_info *th = current_thread;	/* Info on currently selected thread */
d1037 2
a1038 1
  thread_info *th = current_thread;	/* Info on currently selected thread */
d1057 2
a1058 2
   If get_context then also retrieve the context for this
   thread. */
a1078 1

d1082 1
a1082 1
/* Add a thread to the thread list */
d1102 1
a1102 1
   pristine state. */
d1119 1
a1119 1
/* Delete a thread from the list of threads */
d1147 2
a1148 1
    printf_filtered ("error return %s:%d was %d\n", file, line, GetLastError ());
d1185 1
a1185 1
/* Store a new register value into the current thread context */
d1245 2
a1246 2
    WideCharToMultiByte (CP_ACP, 0, (LPCWSTR) dll_buf, len,
			 dll_name, len, 0, 0);
d1251 2
a1252 2
  /* FIXME!! It would be nice to define one symbol which pointed to the
     front of the dll if we can't find any symbols. */
d1271 1
a1271 1
/* Handle DEBUG_STRING output from child process. */
d1292 2
a1293 2
  WideCharToMultiByte (CP_ACP, 0, (LPCWSTR) p, (int) nbytes_read, s,
		       sizeof (s) - 1, NULL, NULL);
d1307 1
a1307 1
/* Handle target exceptions. */
d1339 2
a1340 2
      /* User typed CTRL-C.  Continue with this status */
      last_sig = SIGINT;	/* FIXME - should check pass state */
d1349 3
a1351 2
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
      ourstatus->value.sig = check_for_step (&current_event, TARGET_SIGNAL_ILL);
d1358 4
a1361 3
      printf_unfiltered ("gdb: unknown target exception 0x%08x at 0x%08x\n",
		    current_event.u.Exception.ExceptionRecord.ExceptionCode,
		current_event.u.Exception.ExceptionRecord.ExceptionAddress);
d1370 1
a1370 1
   execution */
d1379 2
a1380 1
		 (unsigned) current_event.dwProcessId, (unsigned) current_event.dwThreadId));
d1477 2
a1478 1
      catch_errors (handle_load_dll, NULL, (char *) "", RETURN_MASK_ALL);
d1520 2
a1521 1
    this_thread = current_thread = th ?: thread_rec (current_event.dwThreadId, TRUE);
d1529 1
a1529 1
/* Wait for interesting events to occur in the target process. */
d1541 1
a1541 1
     isn't necessarily what you think it is. */
d1544 2
a1545 1
    if (get_child_debug_event (pid, ourstatus, EXCEPTION_DEBUG_EVENT, &retval))
d1577 1
a1577 1
/* Convert a Win32 time to "UNIX" format. */
d1587 1
a1587 1
  x -= FACTOR;			/* number of 100ns between 1601 and 1970 */
d1590 1
a1590 1
  x /= (long long) NSPERSEC;	/* number of 100ns in a second */
d1596 1
a1596 1
   'set remoteupload' specification. */
d1613 1
a1613 1
  /* Look for a path separator and only use trailing part. */
d1627 1
a1627 1
    return remotefile;		/* Don't bother uploading. */
d1629 3
a1631 3
  /* Open the source. */
  if ((fd = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, (char *) from, O_RDONLY,
		   0, NULL)) < 0)
d1634 1
a1634 1
  /* Get the time for later comparison. */
d1638 1
a1638 1
  /* Always attempt to create the directory on the remote system. */
d1642 1
a1642 1
  /* Attempt to open the remote file, creating it if it doesn't exist. */
d1647 1
a1647 1
  /* Some kind of problem? */
d1663 1
a1663 1
  /* See if we need to upload the file. */
d1673 1
a1673 1
      /* Upload the file. */
d1687 1
a1687 1
/* Initialize the connection to the remote device. */
d1711 1
a1711 1
  /* Upload the stub to the handheld device. */
d1723 1
a1723 1
  /* Get a socket. */
d1727 1
a1727 1
  /* Allow rapid reuse of the port. */
d1729 2
a1730 1
  (void) setsockopt (s0, SOL_SOCKET, SO_REUSEADDR, (char *) &tmp, sizeof (tmp));
d1733 1
a1733 1
  /* Set up the information for connecting to the host gdb process. */
d1736 1
a1736 1
  sin.sin_port = htons (7000);	/* FIXME: This should be configurable */
d1744 5
a1748 3
  /* Start up the stub on the remote device. */
  if (!CeCreateProcess (towide (stub_file_name, NULL), towide (args, NULL),
			NULL, NULL, 0, 0, NULL, NULL, NULL, &pi))
d1763 2
a1764 1
   ENV is the environment vector to pass.  Errors reported with error().  */
d1780 1
a1780 1
  wince_initialize ();		/* Make sure we've got a connection. */
d1800 1
a1800 1
  /* Execute the process */
d1802 2
a1803 1
    error ("Error creating process %s, (error %d)\n", exec_file, GetLastError ());
d1829 1
a1829 1
/* Chile has gone bye-bye. */
d1841 1
a1841 1
/* Move memory from child to/from gdb. */
d1843 2
a1844 1
child_xfer_memory (CORE_ADDR memaddr, char *our, int len, int write,
d1859 2
a1860 1
/* Terminate the process and wait for child to tell us it has completed. */
d1878 1
a1878 1
  target_mourn_inferior ();	/* or just child_mourn_inferior? */
d1881 1
a1881 1
/* Resume the child after an exception. */
d1887 1
a1887 1
  DBG_EXCEPTION_NOT_HANDLED : DBG_CONTINUE;
d1903 1
a1903 1
     Otherwise complain. */
d1905 3
a1907 1
    fprintf_unfiltered (gdb_stderr, "Can't send signals to the child.  signal %d\n", sig);
d1929 1
a1929 1
                PIDGET (inferior_ptid)));
d1980 1
a1980 1
/* Handle 'set remoteupload' parameter. */
d1983 4
a1986 3
      upload_when = what; \
      remote_upload = xrealloc (remote_upload, strlen (upload_options[upload_when].name) + 1); \
      strcpy (remote_upload, upload_options[upload_when].name);
d2003 3
a2005 1
  for (i = 0; i < (sizeof (upload_options) / sizeof (upload_options[0])); i++)
d2034 2
a2035 1
	       (char *) "Set how to upload executables to remote device.\n",
d2037 1
d2043 2
a2044 1
    (add_set_cmd ((char *) "debugexec", class_support, var_boolean,
d2046 2
a2047 1
	      (char *) "Set whether to display execution in child process.",
d2052 2
a2053 1
    (add_set_cmd ((char *) "remoteaddhost", class_support, var_boolean,
d2057 2
a2058 1
debugging over a network.", &setlist),
d2062 2
a2063 1
    (add_set_cmd ((char *) "debugevents", class_support, var_boolean,
d2065 2
a2066 1
	  (char *) "Set whether to display kernel events in child process.",
d2071 2
a2072 1
    (add_set_cmd ((char *) "debugmemory", class_support, var_boolean,
d2074 2
a2075 1
	(char *) "Set whether to display memory accesses in child process.",
d2079 3
a2081 2
  deprecated_add_show_from_set
    (add_set_cmd ((char *) "debugexceptions", class_support, var_boolean,
d2083 2
a2084 1
      (char *) "Set whether to display kernel exceptions in child process.",
d2091 3
a2093 3
/* Determine if the thread referenced by "pid" is alive
   by "polling" it.  If WaitForSingleObject returns WAIT_OBJECT_0
   it means that the pid has died.  Otherwise it is assumed to be alive. */
d2101 1
a2101 1
/* Convert pid to printable format. */
d2109 2
a2110 1
    sprintf (buf, "thread %d.0x%x", (unsigned) current_event.dwProcessId, pid);
@


1.36
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@d37 1
@


1.35
log
@2004-10-05  Andrew Cagney  <cagney@@gnu.org>

	* target.h (deprecated_child_ops): Rename child_ops.
	* wince.c: Update copyright.  Rename child_ops.
	* win32-nat.c: Rename child_ops.
	* target.c: Rename child_ops.
	* rs6000-nat.c: Rename child_ops.
	* linux-nat.c: Rename child_ops.
	* infttrace.c: Rename child_ops.
	* inftarg.c: Rename child_ops.
	* infptrace.c: Rename child_ops.
	* hppah-nat.c: Update copyright.  Rename child_ops.
	* hpux-thread.c: Update copyright.  Rename child_ops.
@
text
@d1903 1
a1903 1
  deprecated_child_ops.to_xfer_memory = child_xfer_memory;
@


1.34
log
@2004-09-29  Andrew Cagney  <cagney@@gnu.org>

	* wince.c (child_ops): Delete.
	* win32-nat.c (child_ops): Delete.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d1766 1
a1766 1
  push_target (&child_ops);
d1787 1
a1787 1
  unpush_target (&child_ops);
d1892 34
a1925 34
  memset (&child_ops, 0, sizeof (child_ops));
  child_ops.to_shortname = (char *) "child";
  child_ops.to_longname = (char *) "Windows CE process";
  child_ops.to_doc = (char *) "Windows CE process (started by the \"run\" command).";
  child_ops.to_open = child_open;
  child_ops.to_close = child_close;
  child_ops.to_resume = child_resume;
  child_ops.to_wait = child_wait;
  child_ops.to_fetch_registers = child_fetch_inferior_registers;
  child_ops.to_store_registers = child_store_inferior_registers;
  child_ops.to_prepare_to_store = child_prepare_to_store;
  child_ops.to_xfer_memory = child_xfer_memory;
  child_ops.to_files_info = child_files_info;
  child_ops.to_insert_breakpoint = memory_insert_breakpoint;
  child_ops.to_remove_breakpoint = memory_remove_breakpoint;
  child_ops.to_terminal_init = terminal_init_inferior;
  child_ops.to_terminal_inferior = terminal_inferior;
  child_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  child_ops.to_terminal_ours = terminal_ours;
  child_ops.to_terminal_save_ours = terminal_save_ours;
  child_ops.to_terminal_info = child_terminal_info;
  child_ops.to_kill = child_kill_inferior;
  child_ops.to_load = child_load;
  child_ops.to_create_inferior = child_create_inferior;
  child_ops.to_mourn_inferior = child_mourn_inferior;
  child_ops.to_can_run = child_can_run;
  child_ops.to_thread_alive = win32_child_thread_alive;
  child_ops.to_stratum = process_stratum;
  child_ops.to_has_all_memory = 1;
  child_ops.to_has_memory = 1;
  child_ops.to_has_stack = 1;
  child_ops.to_has_registers = 1;
  child_ops.to_has_execution = 1;
  child_ops.to_magic = OPS_MAGIC;
d2022 1
a2022 1
  add_target (&child_ops);
@


1.33
log
@2004-09-29  Andrew Cagney  <cagney@@gnu.org>

	* target.h (child_ops): Declare.
	* inftarg.c (child_ops): Move from here ...
	* target.c (child_ops): ... to here.
	* wince.c (child_ops): Delete extern declaration.
	* win32-nat.c (child_ops): Delete extern declaration.
	* linux-nat.c (child_ops): Delete extern declaration.
	* hpux-thread.c (child_ops): Delete extern declaration.
@
text
@a1887 2
struct target_ops child_ops;

@


1.32
log
@	* defs.h (OPF_TRY_CWD_FIRST, OPF_SEARCH_IN_PATH): New macros.

	* exec.c (exec_file_attach):
	* nto-tdep.c (nto_find_and_open_solib):
	* pa64solib.c (pa64_solib_sizeof_symbol_table):
	* solib.c (solib_open):
	* somsolib.c (som_solib_sizeof_symbol_table):
	* source.c (is_regular_file, openp, open_source_file):
	* symfile.c (symfile_bfd_open):
	* wince.c (upload_to_device): Differentiate between the search for
	binary and source files.

	* gdb.texinfo (Source Path): Document the new behavior of
	searching for the source files.
@
text
@a128 3
/* Forward declaration */
extern struct target_ops child_ops;

@


1.31
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d1590 2
a1591 1
  if ((fd = openp (getenv ("PATH"), TRUE, (char *) from, O_RDONLY, 0, NULL)) < 0)
@


1.30
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d1973 1
a1973 1
  add_show_from_set
d1985 1
a1985 1
  add_show_from_set (set, &showlist);
d1989 1
a1989 1
  add_show_from_set
d1996 1
a1996 1
  add_show_from_set
d2004 1
a2004 1
  add_show_from_set
d2011 1
a2011 1
  add_show_from_set
d2018 1
a2018 1
  add_show_from_set
@


1.29
log
@2004-06-25  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (deprecated_ui_loop_hook): Deprecated.
	* wince.c (child_wait): Update.
	* win32-nat.c (child_wait): Update.
	* v850ice.c (v850ice_wait): Update.
	* top.c (deprecated_ui_loop_hook): Update.
	* serial.h: Update.
	* ser-unix.c (do_hardwire_readchar, do_hardwire_readchar)
	(do_unix_readchar): Update.
	* ser-tcp.c (net_open): Update.
	* remote-sim.c (gdb_os_poll_quit): Update.
	* rdi-share/ardi.c (angel_RDI_ExecuteOrStep): Update.
@
text
@d1122 2
a1123 1
      supply_register (r, (char *) regptr (&current_thread->context, r));
@


1.28
log
@2004-06-24  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (post_add_symbol_hook, pre_add_symbol_hook)
	(ui_loop_hook, selected_frame_level_changed_hook): Declare.
	* wince.c (ui_loop_hook): Delete extern declaration.
	* win32-nat.c (ui_loop_hook): Delete extern declaration..
	* v850ice.c (ui_loop_hook): Delete extern declaration..
	* ser-unix.c (ui_loop_hook): Delete extern declaration..
	* ser-tcp.c (ui_loop_hook): Delete extern declaration..
	* remote-sim.c (ui_loop_hook): Delete extern declaration..
	* rdi-share/ardi.c (angel_RDI_ExecuteOrStep): Delete extern.
	ui_loop_hook declaration.
@
text
@d1510 2
a1511 2
	if (ui_loop_hook != NULL)
	  detach = ui_loop_hook (0);
@


1.27
log
@2004-05-25  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Add from_tty to
	to_create_inferior.
	(target_create_inferior, find_default_create_inferior): Update.
	* infcmd.c (run_command): Update.
	* wince.c (child_create_inferior): Update.
	* win32-nat.c (child_create_inferior): Update.
	* uw-thread.c (uw_thread_create_inferior): Update.
	* thread-db.c (thread_db_create_inferior): Update.
	* target.c (debug_to_create_inferior)
	(find_default_create_inferior): Update.
	(maybe_kill_then_create_inferior): Update.
	* sol-thread.c (sol_thread_create_inferior): Update.
	* remote.c (extended_remote_async_create_inferior)
	(extended_remote_create_inferior): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* remote-st.c (st2000_create_inferior): Update.
	* remote-sim.c (gdbsim_create_inferior): Update.
	* remote-sds.c (sds_create_inferior): Update.
	* remote-rdp.c (remote_rdp_create_inferior): Update.
	* remote-rdi.c (arm_rdi_create_inferior): Update.
	* remote-m32r-sdi.c (m32r_create_inferior): Update.
	* remote-e7000.c (e7000_create_inferior): Update.
	* procfs.c (procfs_create_inferior): Update.
	* ocd.c (ocd_create_inferior): Update.
	* ocd.h (ocd_create_inferior): Update.
	* nto-procfs.c (procfs_create_inferior): Update.
	* monitor.c (monitor_create_inferior): Update.
	* lin-lwp.c (lin_lwp_create_inferior): Update.
	* inftarg.c (child_create_inferior): Update.
	* hpux-thread.c (hpux_thread_create_inferior): Update.
	* gnu-nat.c (gnu_create_inferior): Update.
@
text
@a62 3
/* The ui's event loop. */
extern int (*ui_loop_hook) (int signo);

@


1.26
log
@2003-11-05  Andrew Cagney  <cagney@@redhat.com>

	* xcoffread.c (find_linenos): Replace "sec_ptr" and "bfd" with
	"struct bfd_section" and "struct bfd".
	* target.h (struct section_table): Ditto.
	* rs6000-nat.c (xcoff_relocate_core): Ditto.
	* solib-svr4.c (elf_locate_base): Ditto.
	* pa64solib.c (dld_cache_t): Ditto.
	* objfiles.h (struct obj_section): Ditto.
	* objfiles.c (add_to_objfile_sections): Ditto.
	* exec.c (bfdsec_to_vmap): Ditto.
	(add_to_section_table): Ditto.
	(build_section_table): Ditto.
	* corelow.c (get_core_register_section): Ditto.
	* coffread.c (find_linenos): Ditto.
	* elfread.c (elf_interpreter): Delete #if0'd function.

	* mips-tdep.c (mips_dump_tdep): Delete code prinint VX_NUM_REGS.
	* config/sparc/tm-vxsparc.h (VX_NUM_REGS): Delete macro.
	* config/mips/tm-vxmips.h (VX_NUM_REGS): Delete macro.
	* config/m68k/tm-vx68.h (VX_NUM_REGS): Delete macro.

	* arch-utils.h (generic_cannot_extract_struct_value_address):
	Delete declaration.
	* wince.c (_initialize_wince): Fix multi-line string.
	* ia64-tdep.c (floatformat_valid): Convert to ISO C.
@
text
@d1723 2
a1724 1
child_create_inferior (char *exec_file, char *args, char **env)
@


1.26.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d63 3
d1125 1
a1125 2
      regcache_raw_supply (current_regcache, r,
			   (char *) regptr (&current_thread->context, r));
d1513 2
a1514 2
	if (deprecated_ui_loop_hook != NULL)
	  detach = deprecated_ui_loop_hook (0);
d1592 1
a1592 2
  if ((fd = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, (char *) from, O_RDONLY,
		   0, NULL)) < 0)
d1723 1
a1723 2
child_create_inferior (char *exec_file, char *args, char **env,
		       int from_tty)
d1974 1
a1974 1
  deprecated_add_show_from_set
d1986 1
a1986 1
  deprecated_add_show_from_set (set, &showlist);
d1990 1
a1990 1
  deprecated_add_show_from_set
d1997 1
a1997 1
  deprecated_add_show_from_set
d2005 1
a2005 1
  deprecated_add_show_from_set
d2012 1
a2012 1
  deprecated_add_show_from_set
d2019 1
a2019 1
  deprecated_add_show_from_set
@


1.25
log
@2003-10-10  Kei Sakamoto  <sakamoto.kei@@renesas.com>

	* NEWS: Replace "Hitachi" and "Mitsubishi" with "Renesas".
	* README: Ditto.
	* d10v-tdep.c: Ditto.
	* h8300-tdep.c: Ditto.
	* remote-e7000.c: Ditto.
	* remote-hms.c: Ditto.
	* ser-e7kpc.c: Ditto.
	* sh-stub.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* sh3-rom.c: Ditto.
	* sh64-tdep.c: Ditto.
	* top.c: Ditto.
	* wince.c: Ditto.
	* config/d10v/d10v.mt: Ditto.
	* config/sh/embed.mt: Ditto.
	* config/sh/linux.mt: Ditto.
	* config/sh/tm-linux.h: Ditto.
	* config/sh/tm-sh.h: Ditto.
	* config/sh/wince.mt: Ditto.
@
text
@d2000 2
a2001 1
		  (char *) "Set whether to add this host to remote stub arguments for\n
@


1.24
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d836 1
a836 1
/* Hitachi SH architecture instruction encoding masks */
d847 1
a847 1
/* Hitachi SH instruction opcodes */
@


1.23
log
@2003-06-12  Andrew Cagney  <cagney@@redhat.com>

	* wince.c: Include "mips-tdep.h".
	* mips-tdep.h (mips_next_pc): Declare.
	* mcore-tdep.c: Make more local functions static.
	* Makefile.in (wince.o): Update dependencies.
@
text
@a1529 1
/* ARGSUSED */
@


1.22
log
@	* gnu-nat.c (init_gnu_ops): Remove NULL initializations.
	* monitor.c (init_base_monitor_ops): Likewise.
	* ppc-bdm.c (init_bdm_ppc_ops): Likewise.
	* remote-array.c (init_array_ops): Likewise.
	* remote-e7000.c (init_e7000_ops): Likewise.
	* remote-es.c (init_es1800_ops): Likewise.
	(init_es1800_child_ops): Likewise.
	* remote-rdp.c (init_remote_rdp_ops): Likewise.
	* remote-sim.c (init_gdbsim_ops): Likewise.
	* remote-st.c (init_st2000_ops): Likewise.
	* sol-thread.c (init_sol_core_ops): Likewise.
	(init_sol_thread_ops): Likewise.
	* v850ice.c (init_850ice_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
@
text
@d59 3
@


1.21
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@a1926 2
  child_ops.to_sections = 0;
  child_ops.to_sections_end = 0;
@


1.20
log
@	Fix PR gdb/393:
	* inflow.c (terminal_save_ours): New function to save terminal
	settings.
	* inferior.h (terminal_save_ours): Declare.
	* target.c (debug_to_terminal_save_ours): New function.
	(cleanup_target): Defaults to_terminal_save_ours.
	(update_current_target): Inherit to_terminal_save_ours.
	(setup_target_debug): Set to_terminal_save_ours.
	* target.h (target_terminal_save_ours): New to save terminal settings.
	(target_ops): New member to_terminal_save_ours.
	* gnu-nat.c (init_gnu_ops): Set to_terminal_save_ours.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* inftarg.c (init_child_ops): Likewise.
	* m3-nat.c (init_m3_ops): Likewise.
	* procfs.c (init_procfs_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* sol-thread.c (init_sol_thread_ops): Likewise.
@
text
@d1142 1
a1142 1
    read_register_gen (r, ((char *) &current_thread->context) + mappings[r]);
@


1.20.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a58 3
#ifdef MIPS
#include "mips-tdep.h"
#endif
d833 1
a833 1
/* Renesas SH architecture instruction encoding masks */
d844 1
a844 1
/* Renesas SH instruction opcodes */
d1142 1
a1142 1
    deprecated_read_register_gen (r, ((char *) &current_thread->context) + mappings[r]);
d1527 1
d1927 2
d2000 1
a2000 2
		  (char *) "\
Set whether to add this host to remote stub arguments for\n\
@


1.20.4.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d1142 1
a1142 1
    deprecated_read_register_gen (r, ((char *) &current_thread->context) + mappings[r]);
d1927 2
@


1.20.4.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a58 3
#ifdef MIPS
#include "mips-tdep.h"
#endif
@


1.20.4.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d836 1
a836 1
/* Renesas SH architecture instruction encoding masks */
d847 1
a847 1
/* Renesas SH instruction opcodes */
d1530 1
d2001 1
a2001 2
		  (char *) "\
Set whether to add this host to remote stub arguments for\n\
@


1.19
log
@* wince.c (_initialize_wince): Rename _initialize_inftarg.
* win32-nat.c (_initialize_win32_nat): Rename _initialize_inftarg.
@
text
@d1913 1
@


1.18
log
@* cli/cli-decode.c (do_cfunc, set_cmd_cfunc): New functions.
(do_sfunc, set_cmd_sfunc): New functions.

* command.h (struct cmd_list_element): Add field func.
* cli/cli-decode.h (struct cmd_list_element): Ditto.
* command.h (set_cmd_sfunc, set_cmd_cfunc): Declare.
* cli/cli-decode.h: Ditto.

* cli/cli-decode.c (help_cmd): Test for func not cfunc/sfunc.
(help_all, help_cmd_list): Ditto.
(find_cmd, complete_on_cmdlist): Ditto.
* top.c (execute_command): Ditto.

* cli/cli-setshow.c (do_setshow_command): Call func instead of
function.sfunc.

* infcmd.c (notice_args_read): Fix function signature.

* cli/cli-cmds.c (init_cli_cmds): Use set_cmd_sfunc.
* cli/cli-decode.c (add_set_cmd): Ditto.
* utils.c (initialize_utils): Ditto.
* maint.c (_initialize_maint_cmds): Ditto.
* infrun.c (_initialize_infrun): Ditto.
* demangle.c (_initialize_demangler): Ditto.
* remote.c (add_packet_config_cmd): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* cris-tdep.c (_initialize_cris_tdep): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* kod.c (_initialize_kod): Ditto.
* valprint.c (_initialize_valprint): Ditto.
* top.c (init_main): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
* arm-tdep.c (_initialize_arm_tdep): Ditto.
* arch-utils.c (initialize_current_architecture): Ditto.
(_initialize_gdbarch_utils): Ditto.
* alpha-tdep.c (_initialize_alpha_tdep): Ditto.

* cli/cli-decode.c (add_cmd): Use set_cmd_cfunc.
* wince.c (_initialize_inftarg): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* language.c (_initialize_language): Ditto.
* arc-tdep.c (_initialize_arc_tdep): Ditto.
@
text
@d1968 1
a1968 1
_initialize_inftarg (void)
@


1.18.8.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1968 1
a1968 1
_initialize_wince (void)
@


1.18.8.2
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a1912 1
  child_ops.to_terminal_save_ours = terminal_save_ours;
@


1.18.8.3
log
@merge from mainline
@
text
@d1142 1
a1142 1
    deprecated_read_register_gen (r, ((char *) &current_thread->context) + mappings[r]);
@


1.17
log
@Phase 1 of the ptid_t changes.
@
text
@d1986 1
a1986 1
  set->function.cfunc = set_upload_type;
@


1.16
log
@* target.h (enum target_signal): Move definition from here.
* defs.h (enum target_signal): To here.

* config/arc/tm-arc.h (arc_software_single_step): Change type of
first parameter to enum target_signal.
* config/rs6000/tm-rs6000.h (rs6000_software_single_step): Ditto.
* config/sparc/tm-sparc.h (sparc_software_single_step): Ditto.
* rs6000-tdep.c (rs6000_software_single_step): Update.
@
text
@d132 1
a132 1
static int win32_child_thread_alive (int);
d1134 1
a1134 1
  current_thread = thread_rec (inferior_pid, TRUE);
d1154 1
a1154 1
  current_thread = thread_rec (inferior_pid, TRUE);
d1415 2
a1416 1
      main_thread_id = inferior_pid = current_event.dwThreadId;
d1418 1
a1418 1
      th = child_add_thread (inferior_pid,
d1490 2
a1491 2
static int
child_wait (int pid, struct target_waitstatus *ourstatus)
d1495 1
d1505 1
a1505 1
      return retval;
d1524 1
a1524 1
		     target_pid_to_str (inferior_pid));
d1716 1
a1716 1
/* Start an inferior win32 child process and sets inferior_pid to its pid.
d1764 2
a1765 1
  inferior_pid = current_event.dwThreadId = pi.dwThreadId;
d1775 1
a1775 1
  while (!get_child_debug_event (inferior_pid, &dummy,
d1834 1
a1834 1
child_resume (int pid, int step, enum target_signal sig)
d1839 1
d1877 2
a1878 1
  DEBUG_EVENTS (("gdb: child_close, inferior_pid=%d\n", inferior_pid));
d2031 1
a2031 1
win32_child_thread_alive (int pid)
d2033 1
@


1.15
log
@Add ``attrib'' parameter to *xfer_memory() functions.
@
text
@d812 2
a813 1
wince_software_single_step (unsigned int ignore, int insert_breakpoints_p)
d953 2
a954 1
wince_software_single_step (unsigned int ignore, int insert_breakpoints_p)
d1000 2
a1001 1
wince_software_single_step (unsigned int ignore, int insert_breakpoints_p)
@


1.14
log
@* wince.c: Change realloc to xrealloc throughout.
(handle_load_dll): Use void * rather than PTR.
@
text
@d1790 3
a1792 2
child_xfer_memory (CORE_ADDR memaddr, char *our, int len,
		   int write, struct target_ops *target)
@


1.13
log
@Create new file regcache.h.  Update all uses.
@
text
@d605 1
a605 1
     space, if applicable. Note that if outs[n] is NULL, realloc will act as
d608 1
a608 1
  outs[n] = (LPWSTR) realloc (outs[n], *out_len);
d1159 1
a1159 1
handle_load_dll (PTR dummy)
d1576 1
a1576 1
  remotefile = (char *) realloc (remotefile, len);
d1927 1
a1927 1
      remote_upload = realloc (remote_upload, strlen (upload_options[upload_when].name) + 1); \
@


1.12
log
@* exec.c (xfer_memory): Add attrib argument.
* infptrace.c (child_xfer_memory): Likewise.
* monitor.c (monitor_xfer_memory): Likewise.
* remote-adapt.c (adapt_xfer_inferior_memory): Likewise.
* remote-array.c (array_xfer_memory): Likewise.
* remote-bug.c (bug_xfer_memory): Likewise.
* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
* remote-eb.c (eb_xfer_inferior_memory): Likewise.
* remote-es.c (es1800_xfer_inferior_memory): Likewise.
* remote-mips.c (mips_xfer_memory): Likewise.
* remote-mm.c (mm_xfer_inferior_memory): Likewise.
* remote-nindy.c (nindy_xfer_inferior_memory): Likewise.
* remote-os9k.c (rombug_xfer_inferior_memory): Likewise.
* remote-rdi.c (arm_rdi_xfer_memory): Likewise.
* remote-rdp.c (remote_rdp_xfer_inferior_memory): Likewise.
* remote-sds.c (sds_xfer_memory): Likewise.
* remote-sim.c (gdbsim_xfer_inferior_memory): Likewise.
* remote-st.c (st2000_xfer_inferior_memory): Likewise.
* remote-udi.c (udi_xfer_inferior_memory): Likewise.
* remote-vx.c (vx_xfer_memory): Likewise.
* remote.c (remote_xfer_memory): Likewise.
* target.c (debug_to_xfer_memory, do_xfer_memory): Likewise.
* target.h (child_xfer_memory, do_xfer_memory, xfer_memory): Likewise.

* target.h (#include "memattr.h"): Added.
(target_ops.to_xfer_memory): Add attrib argument.

* wince.c (_initialize_inftarg): Removed call to set_dcache_state.
* dcache.h (set_dcache_state): Removed declaration.
* dcache.c (set_dcache_state): Removed definition

* dcache.c: Update module comment, as dcache is now enabled and
disabled with memory region attributes instead of by the global
variable "remotecache".  Add comment describing the interaction
between dcache and memory region attributes.
(dcache_xfer_memory): Add comment describing benefits of moving
cache writeback to a higher level.
(dcache_struct): Removed cache_has_stuff field.  This was used to
record whether the cache had been accessed in order to invalidate
it when it was disabled.  However, this is not needed because the
cache is write through and the code that enables, disables, and
deletes memory regions invalidate the cache.  Add comment which
suggests that we could be more selective and only invalidate those
cache lines containing data from those memory regions.
(dcache_invalidate): Updated.
(dcache_xfer_memory): Updated.

(dcache_alloc): Don't abort() if dcache_enabled_p is clear.
(dcache_xfer_memory): Removed code that called do_xfer_memory() to
perform a uncached transfer if dcache_enabled_p was clear.  This
function is now only called if caching is enabled for the memory
region.
(dcache_info): Always print cache info.

* target.c (do_xfer_memory): Add attrib argument.
(target_xfer_memory, target_xfer_memory_partial): Break transfer
into chunks defined by memory regions, pass region attributes to
do_xfer_memory().
* dcache.c (dcache_read_line, dcache_write_line): Likewise.

* Makefile.in (SFILES): Add memattr.c.
(COMMON_OBS): Add memattr.o.
(dcache.o): Add target.h to dependencies.
* memattr.c: New file.
* memattr.h: Likewise.
@
text
@d58 1
@


1.11
log
@Replace free() with xfree().
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
a1977 1
  set_dcache_state (1);
@


1.10
log
@* TODO: Note abstraction layer violation where "ocd reset" command
must invalidate the dcache, and how this might be fixed.

* monitor.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(monitor_open): Removed code that created local dcache.
(flush_monitor_dcache): Removed (unused function).
(monitor_resume): Removed call to dcache_invd().
(monitor_load): Likewise.
(monitor_xfer_memory): Changed to call monitor_write_memory(),
monitor_write_memory_block(), and monitor_read_memory() instead
of dcache_xfer_memory().
* monitor.h (flush_monitor_dcache): Removed (unused function).
* ocd.c (#include "dcache.h"): Removed.
(ocd_dcache): Removed.
(ocd_open): Removed code that created local dcache.
(ocd_resume): Removed call to dcache_invd().
(ocd_xfer_memory): Changed to call ocd_write_bytes() and
ocd_read_bytes() instead of dcache_xfer_memory().
(bdm_reset_command): Invalidate target dcache.
* remote-bug.c (bug_load): Remove call to dcache_invd().
(bug_resume): Likewise.
(bug_settings): Remove dcache, readfunc, and writefunc fields
from initializer.
(bug_xfer_memory): Changed to call bug_read_memory() and
bug_write_memory() instead of dcache_xfer_memory().
* remote-nindy.c (#include "dcache.h"): Removed.
(nindy_dcache): Removed.
(nindy_open): Removed code that created local dcache.
(nindy_resume): Removed call to dcache_invd().
(nindy_load): Likewise.
(nindy_xfer_inferior_memory): Changed to call ninMemPut() and
ninMemGet() instead of dcache_xfer_memory().
* remote-sds.c (#include "dcache.h"): Removed.
(sds_dcache): Removed.
(sds_open): Removed code that created local dcache.
(sds_resume): Removed call to dcache_invd().
(sds_xfer_memory): Changed to call sds_write_bytes() and
sds_read_bytes() instead of dcache_xfer_memory().
* remote-utils.c (gr_open): Removed code that created local dcache.
* remote-utils.h (#include "dcache.h"): Removed.
(struct gr_settings): Removed dcache, readfunc, and writefunc fields.
(gr_get_dcache, gr_set_dcache): Removed macro definitions.
* remote.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(remote_open_1): Removed code that created local dcache.
(remote_async_open_1): Likewise.
(remote_resume): Removed call to dcache_invd().
(remote_async_resume): Likewise.
(remote_xfer_memory): Changed to call remote_write_bytes() and
remote_read_bytes() instead of dcache_xfer_memory().
* wince.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(child_create_inferior): Removed code that created local dcache.
(child_xfer_memory): Changed to call remote_write_bytes() and
remote_read_bytes() instead of dcache_xfer_memory().
(child_resume): Removed call to dcache_invd().

* target.c (target_dcache): Added.
(target_load): Invalidate target_dcache.
(do_xfer_memory): New function.
(target_xfer_memory): Reimplement in terms of dcache_xfer_memory().
(target_xfer_memory_partial): Likewise.
(initialize_targets): Create target_dcache.
* target.h (#include "dcache.h"): Added.
(target_open): Invalidate target_dcache.
(target_resume): Likewise.
(do_xfer_memory): New declaration.

* dcache.c (dcache_init): Removed reading and writing arguments.
(dcache_struct): Removed read_memory and write_memory fields.
(dcache_write_line): Call do_xfer_memory.
(dcache_read_line): Likewise.
(dcache_xfer_memory): Likewise.
(dcache_invalidate): Renamed from dcache_invd.
(dcache_init): Updated.
(dcache_xfer_memory): Updated.
* dcache.h (memxferfunc): Removed definition.
@
text
@d1078 1
a1078 1
      free (here);
d1102 1
a1102 1
      free (here);
@


1.9
log
@* MAINTAINERS: Add myself as dcache.c maintainer.

* remote-nindy.c (nindy_load): Invalidate dcache.

* dcache.c (dcache_invd): Renamed from dcache_flush.  The term
flush with respect to caches usually implies that data will be
written to memory.
(dcache_init, dcache_xfer_memory): Updated.
* monitor.c (flush_monitor_dcache, monitor_resume, monitor_load):
Updated.
* ocd.c (ocd_open, ocd_resume, bdm_reset_command): Updated.
* remote-bug.c (bug_load, bug_resume): Updated.
* remote-nindy.c (nindy_open, nindy_resume): Updated.
* remote-sds.c (sds_open, sds_resume): Updated.
* remote-utils.c (gr_open): Updated.
* remote.c (remote_open_1, remote_resume, remote_async_resume,
remote_cisco_open): Updated.
* wince.c (child_create_inferior, child_resume): Updated.

* monitor.c (monitor_open): Free dcache before creating a new one.
* dcache.c (dcache_free): New function.
* dcache.h (dcache_free): New prototype.
-------------------------------------------------------------------
@
text
@a56 1
#include "dcache.h"
a90 2
static DCACHE *remote_dcache;

a1728 4
  if (!remote_dcache)
    remote_dcache = dcache_init (remote_read_bytes, remote_write_bytes);
  else
    dcache_invd (remote_dcache);
d1794 7
a1800 1
  return dcache_xfer_memory (remote_dcache, memaddr, our, len, write);
a1842 2

  dcache_invd (remote_dcache);
@


1.8
log
@Protoization.
@
text
@d1735 1
a1735 1
    dcache_flush (remote_dcache);
d1845 1
a1845 1
  dcache_flush (remote_dcache);
@


1.7
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d789 1
a789 1
stop_stub ()
d1070 1
a1070 1
child_init_thread_list ()
d1518 1
a1518 2
child_files_info (ignore)
     struct target_ops *ignore;
d1526 1
a1526 3
child_open (arg, from_tty)
     char *arg;
     int from_tty;
d1645 1
a1645 1
wince_initialize ()
d1784 1
a1784 1
child_mourn_inferior ()
d1857 1
a1857 1
child_prepare_to_store ()
d1863 1
a1863 1
child_can_run ()
d1869 1
a1869 1
child_close ()
d1961 1
a1961 1
_initialize_inftarg ()
@


1.6
log
@PARAMS removal.
@
text
@d61 1
a61 1
extern int (*ui_loop_hook) PARAMS ((int signo));
@


1.5
log
@Fix typo in comment.
@
text
@d134 2
a135 2
static int win32_child_thread_alive PARAMS ((int));
void child_kill_inferior PARAMS ((void));
@


1.4
log
@* wince-stub.c (FREE): New macro.
(mempool): Just free any buffer prior to reuse.  Don't bother with realloc.
(flag_single_step): New function.
(skip_message): Detect "helpful" Windows CE messages and skip sending them to
the host.
(wait_for_debug_event): Use skip_message to avoid sending debug messages to the
host.
(dispatch): Prelimary implementation of single step detection.
* wince.c: Rework SH single stepping code to be more consistent with other
wince targets.
(handle_output_debug_string): Allow first chance exceptions to come through
since they seem to be all that we get on some versions of Windows CE.
(check_for_step): New function, conditionally compiled based on target.
(regptr): Delete obsolete function.
(handle_exception): Detect illegal instructions.
(get_child_debug_event): Return success only if event code matches target.
(child_create_inferior): Reflect change to get_child_debug_event arguments.
@
text
@d13 1
a13 1
   but WITHOUT ANY WARRANTY; without eve nthe implied warranty of
@


1.3
log
@* win32-nat.c: Remove unneeded header.
* wince.c: Ditto.
@
text
@d58 1
a150 1
    unsigned long step_instr;
d158 1
d378 15
a392 18
/* This vector maps the target's idea of an exception (extracted
   from the DEBUG_EVENT structure) to GDB's idea. */

struct xlate_exception
  {
    int them;
    enum target_signal us;
  };

static const struct xlate_exception
  xlate[] =
{
  {EXCEPTION_ACCESS_VIOLATION, TARGET_SIGNAL_SEGV},
  {STATUS_STACK_OVERFLOW, TARGET_SIGNAL_SEGV},
  {EXCEPTION_BREAKPOINT, TARGET_SIGNAL_TRAP},
  {DBG_CONTROL_C, TARGET_SIGNAL_INT},
  {EXCEPTION_SINGLE_STEP, TARGET_SIGNAL_TRAP},
  {-1, -1}};
d630 1
d800 221
a1115 16
/* Return a pointer into a CONTEXT field indexed by gdb register number.
   Return a pointer to an address pointing to zero if there is no
   corresponding CONTEXT field for the given register number.
 */
static ULONG *
regptr (LPCONTEXT c, int r)
{
  static ULONG zero = 0;
  ULONG *p;
  if (mappings[r] < 0)
    p = &zero;
  else
    p = (ULONG *) (((char *) c) + mappings[r]);
  return p;
}

d1198 1
d1200 1
a1229 8
#if 0				/* FIXME:  Need to use RAPI stuff to read the file someday. */
  {
    struct section_addr_info section_addrs;
    memset (&section_addrs, 0, sizeof (section_addrs));
    section_addrs.text_addr = (int) event->lpBaseOfDll + 0x1000;
    symbol_file_add (dll_name, 0, &section_addrs, 0, OBJF_SHARED);
  }
#endif
d1235 1
a1235 3
/* Handle DEBUG_STRING output from child process.
   Cygwin prepends its messages with a "cygwin:".  Interpret this as
   a Cygwin signal.  Otherwise just print the string as a warning. */
d1267 1
d1275 1
a1275 2
  thread_info *th;

d1278 1
a1281 3
  /* Record the context of the current thread */
  th = thread_rec (current_event.dwThreadId, -1);

d1311 5
d1318 2
a1319 2
         that case, we want to let the program try to handle it, and
         only break if we see the exception a second time.  */
d1361 2
a1362 1
get_child_debug_event (int pid, struct target_waitstatus *ourstatus, DWORD * event_code, int *retval)
d1364 1
d1366 3
a1368 2
  DWORD continue_status;
  int breakout = 1;
d1372 1
a1372 1
      breakout = *retval = *event_code = 0;
a1375 1
  this_thread = thread_rec (current_event.dwThreadId, FALSE);
d1379 5
a1383 1
  switch (*event_code = current_event.dwDebugEventCode)
d1391 2
a1392 2
      child_add_thread (current_event.dwThreadId,
			current_event.u.CreateThread.hThread);
d1404 1
d1416 2
a1417 2
      current_thread = child_add_thread (inferior_pid,
				 current_event.u.CreateProcessInfo.hThread);
d1429 2
a1430 1
      goto out;
d1454 2
d1457 2
a1458 5
	  char buf[32];
	  *retval = current_event.dwThreadId;
	  remote_read_bytes (read_pc (), buf, sizeof (buf));
	  dcache_xfer_memory (remote_dcache, read_pc (), buf, sizeof (buf), 0);
	  goto out;
a1459 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
d1467 1
a1467 1
      handle_output_debug_string (ourstatus);
d1478 4
a1481 2
  breakout = 0;
  CHECK (child_continue (continue_status, -1));
d1501 1
a1501 1
    if (get_child_debug_event (pid, ourstatus, &event_code, &retval))
d1561 1
a1561 1
  const char *dir = remote_directory ? : "\\gdb";
d1568 2
a1569 1
  FILETIME ctime, atime, wtime;
d1608 2
a1609 2
  if (h == NULL)
    error ("error creating file to \"%s\".  Windows error %d.",
d1612 10
d1625 2
a1626 2
      !CeGetFileTime (h, &ctime, &atime, &wtime) ||
      to_time_t (&wtime) < st.st_mtime)
d1640 2
a1641 1
  CeCloseHandle (h);
a1776 1

d1778 3
a1780 3
  do
    get_child_debug_event (inferior_pid, &dummy, &event_code, &ret);
  while (event_code != CREATE_PROCESS_DEBUG_EVENT);
a1827 207
#ifdef MIPS
static void
undoSStep (thread_info * th)
{
  if (th->stepped)
    {
      memory_remove_breakpoint (th->step_pc, (void *) &th->step_prev);
      th->stepped = 0;
    }
}

void
wince_software_single_step (unsigned int ignore, int insert_breakpoints_p)
{
  unsigned long pc;
  thread_info *th = current_thread;	/* Info on currently selected thread */
  CORE_ADDR mips_next_pc (CORE_ADDR pc);

  if (!insert_breakpoints_p)
    {
      undoSStep (th);
      return;
    }

  th->stepped = 1;
  pc = read_register (PC_REGNUM);
  th->step_pc = mips_next_pc (pc);
  th->step_prev = 0;
  memory_insert_breakpoint (th->step_pc, (void *) &th->step_prev);
}
#elif SHx
/* Hitachi SH architecture instruction encoding masks */

#define COND_BR_MASK   0xff00
#define UCOND_DBR_MASK 0xe000
#define UCOND_RBR_MASK 0xf0df
#define TRAPA_MASK     0xff00

#define COND_DISP      0x00ff
#define UCOND_DISP     0x0fff
#define UCOND_REG      0x0f00

/* Hitachi SH instruction opcodes */

#define BF_INSTR       0x8b00
#define BT_INSTR       0x8900
#define BRA_INSTR      0xa000
#define BSR_INSTR      0xb000
#define JMP_INSTR      0x402b
#define JSR_INSTR      0x400b
#define RTS_INSTR      0x000b
#define RTE_INSTR      0x002b
#define TRAPA_INSTR    0xc300
#define SSTEP_INSTR    0xc3ff


#define T_BIT_MASK     0x0001

/* Undo the effect of a previous doSStep.  If we single stepped,
   restore the old instruction. */

static void
undoSStep (thread_info * th)
{
  if (th->stepped)
    {
      gdb_wince_len done;
      write_process_memory (current_process_handle, (LPVOID) th->step_pc,
			  (LPVOID) & th->step_instr, sizeof (short), &done);
      if (done != sizeof (short))
	  error ("error unsetting single step.");
      th->stepped = 0;
    }
}

/* Single step (in a painstaking fashion) by inspecting the current
   instruction and setting a breakpoint on the "next" instruction
   which would be executed.  This code hails from sh-stub.c.
 */
void
wince_software_single_step (unsigned int ignore, int insert_breakpoints_p)
{
  thread_info *th = current_thread;	/* Info on currently selected thread */

  if (!insert_breakpoints_p)
    undoSStep (th);
  else
    {
      short *instrMem;
      int displacement;
      int reg;
      unsigned short opcode;
      gdb_wince_len done;
      LPCONTEXT c = &th->context;

      instrMem = (short *) c->Fir;

      read_process_memory (current_process_handle, (LPCVOID) c->Fir, &opcode,
			   sizeof (opcode), &done);
      if (done != sizeof (opcode))
	error ("couldn't retrieve opcode");
      th->stepped = 1;

      if ((opcode & COND_BR_MASK) == BT_INSTR)
	{
	  if (c->Psr & T_BIT_MASK)
	    {
	      displacement = (opcode & COND_DISP) << 1;
	      if (displacement & 0x80)
		displacement |= 0xffffff00;
	      /*
	         * Remember PC points to second instr.
	         * after PC of branch ... so add 4
	       */
	      instrMem = (short *) (c->Fir + displacement + 4);
	    }
	  else
	    instrMem += 1;
	}
      else if ((opcode & COND_BR_MASK) == BF_INSTR)
	{
	  if (c->Psr & T_BIT_MASK)
	    instrMem += 1;
	  else
	    {
	      displacement = (opcode & COND_DISP) << 1;
	      if (displacement & 0x80)
		displacement |= 0xffffff00;
	      /*
	         * Remember PC points to second instr.
	         * after PC of branch ... so add 4
	       */
	      instrMem = (short *) (c->Fir + displacement + 4);
	    }
	}
      else if ((opcode & UCOND_DBR_MASK) == BRA_INSTR)
	{
	  displacement = (opcode & UCOND_DISP) << 1;
	  if (displacement & 0x0800)
	    displacement |= 0xfffff000;

	  /*
	     * Remember PC points to second instr.
	     * after PC of branch ... so add 4
	   */
	  instrMem = (short *) (c->Fir + displacement + 4);
	}
      else if ((opcode & UCOND_RBR_MASK) == JSR_INSTR)
	{
	  reg = (char) ((opcode & UCOND_REG) >> 8);

	  instrMem = (short *) *regptr (c, reg);
	}
      else if (opcode == RTS_INSTR)
	instrMem = (short *) c->PR;
      else if (opcode == RTE_INSTR)
	instrMem = (short *) *regptr (c, 15);
      else if ((opcode & TRAPA_MASK) == TRAPA_INSTR)
	instrMem = (short *) ((opcode & ~TRAPA_MASK) << 2);
      else
	instrMem += 1;

      th->step_pc = (CORE_ADDR) instrMem;

      read_process_memory (current_process_handle, (LPVOID) instrMem,
			   (LPVOID) & th->step_instr, sizeof (short), &done);
      opcode = SSTEP_INSTR;
      write_process_memory (current_process_handle, (LPVOID) instrMem,
			    (LPVOID) & opcode, sizeof (short), &done);
    }
}
#elif defined (ARM)
/* Single step (in a painstaking fashion) by inspecting the current
   instruction and setting a breakpoint on the "next" instruction
   which would be executed.  This code hails from sh-stub.c.
 */
static void
undoSStep (thread_info * th)
{
  if (th->stepped)
    {
      memory_remove_breakpoint (th->step_pc, (void *) &th->step_prev);
      th->stepped = 0;
    }
}

void
wince_software_single_step (unsigned int ignore, int insert_breakpoints_p)
{
  unsigned long pc;
  thread_info *th = current_thread;	/* Info on currently selected thread */
  CORE_ADDR mips_next_pc (CORE_ADDR pc);

  if (!insert_breakpoints_p)
    {
      undoSStep (th);
      return;
    }

  th->stepped = 1;
  pc = read_register (PC_REGNUM);
  th->step_pc = arm_get_next_pc (pc);
  th->step_prev = 0;
  memory_insert_breakpoint (th->step_pc, (void *) &th->step_prev);
}
#endif

d1931 2
a1932 2
      upload_when = UPLOAD_NEWER; \
      remote_upload = realloc (remote_upload, strlen (upload_options[upload_when].name)); \
d1954 1
a1954 2
	remote_upload = (char *) upload_options[i].name;
	upload_when = i;
@


1.2
log
@Include "gdb_wait.h" instead of "wait.h".
@
text
@a35 1
#include "gdb_wait.h"
@


1.1
log
@Windows CE support.
@
text
@d36 1
a36 1
#include "wait.h"
@

