head	1.18;
access;
symbols
	gdb_5_2_1-2002-07-23-release:1.17
	gdb_5_2-2002-04-29-release:1.17
	gdb_5_2-branch:1.17.0.2
	gdb_5_2-2002-03-03-branchpoint:1.17
	gdb_5_1_1-2002-01-24-release:1.16
	gdb_5_1_0_1-2002-01-03-release:1.16
	cygnus_cvs_20020108_pre:1.17
	gdb_5_1_0_1-2002-01-03-branchpoint:1.16
	gdb_5_1_0_1-2002-01-03-branch:1.16.0.6
	gdb_5_1-2001-11-21-release:1.16
	gdb_s390-2001-09-26-branch:1.16.0.4
	gdb_s390-2001-09-26-branchpoint:1.16
	gdb_5_1-2001-07-29-branch:1.16.0.2
	gdb_5_1-2001-07-29-branchpoint:1.16
	dberlin-typesystem-branch:1.15.0.2
	dberlin-typesystem-branchpoint:1.15
	gdb-post-ptid_t-2001-05-03:1.15
	gdb-pre-ptid_t-2001-05-03:1.14
	insight-precleanup-2001-01-01:1.8
	gdb-post-protoization-2000-07-29:1.6
	gdb-pre-protoization-2000-07-29:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb-post-params-removal-2000-06-04:1.5
	gdb-pre-params-removal-2000-06-04:1.5
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.4
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.5
	gdb-2000-01-26:1.1.1.5
	gdb-2000-01-24:1.1.1.5
	gdb-2000-01-17:1.1.1.5
	gdb-2000-01-10:1.1.1.5
	gdb-2000-01-05:1.1.1.5
	gdb-1999-12-21:1.1.1.5
	gdb-1999-12-13:1.1.1.5
	gdb-1999-12-07:1.1.1.5
	gdb-1999-12-06:1.1.1.5
	gdb-1999-11-16:1.1.1.5
	gdb-1999-11-08:1.1.1.5
	gdb-1999-11-01:1.1.1.5
	gdb-1999-10-25:1.1.1.5
	gdb-1999-10-18:1.1.1.5
	gdb-1999-10-11:1.1.1.5
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.18
date	2002.05.04.15.52.38;	author cagney;	state dead;
branches;
next	1.17;

1.17
date	2002.01.06.15.02.01;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.08.20.21.36;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.04.04.15.26;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.06.08.21.13;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.02.23.04.14;	author jtc;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.02.19.14.33;	author jtc;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.26.19.47.19;	author jeffh;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.23.22.48.55;	author jtc;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.15.01.01.49;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.02.05.17.27;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.22.09.02.23;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.16.02.43.39;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.47;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.17.22.55;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.09.21;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.10.05.23.08.42;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.10.12.04.37.24;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.02.02.00.21.10;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.18
log
@* MAINTAINERS: Mark a29k as deleted.
* NEWS: Mention that a29k was removed.  Add OBSOLETE section.
Move new configurations to the top.
* configure.tgt: Remove a29k.
* config/a29k/tm-vx29k.h: Delete.
* config/a29k/vx29k.mt: Delete.
* config/a29k/tm-a29k.h: Delete.
* config/a29k/a29k-udi.mt: Delete.
* config/a29k/a29k.mt: Delete.
* a29k-tdep.c: Delete.
* remote-udi.c: Delete.
* remote-mm.c: Delete.
* remote-eb.c: Delete.
* remote-adapt.c: Delete.
* Makefile.in: Remove obsolete code.
* gdbserver/Makefile.in: Ditto.
* config/s390/s390x.mt: Ditto.
* config/s390/s390.mt: Ditto.
* config/sparc/sparclynx.mh: Ditto.
* config/sparc/linux.mh: Ditto.
* config/pa/hppaosf.mh: Ditto.
* config/pa/hppabsd.mh: Ditto.
* config/ns32k/nbsd.mt: Ditto.
* config/mips/vr5000.mt: Ditto.
* config/m68k/sun3os4.mh: Ditto.
* config/m68k/nbsd.mt: Ditto.
* config/m68k/m68klynx.mh: Ditto.
* config/m32r/m32r.mt: Ditto.
* config/i386/x86-64linux.mt: Ditto.
* config/i386/nbsdelf.mt: Ditto.
* config/i386/nbsd.mt: Ditto.
* config/i386/i386lynx.mh: Ditto.
@
text
@/* OBSOLETE /* Remote debugging interface for AMD 29k interfaced via UDI, for GDB. */
/* OBSOLETE    Copyright 1990, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001 */
/* OBSOLETE    Free Software Foundation, Inc. */
/* OBSOLETE    Written by Daniel Mann.  Contributed by AMD. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE /* This is like remote.c but uses the Universal Debug Interface (UDI) to  */
/* OBSOLETE    talk to the target hardware (or simulator).  UDI is a TCP/IP based */
/* OBSOLETE    protocol; for hardware that doesn't run TCP, an interface adapter  */
/* OBSOLETE    daemon talks UDI on one side, and talks to the hardware (typically */
/* OBSOLETE    over a serial port) on the other side. */
/* OBSOLETE  */
/* OBSOLETE    - Originally written by Daniel Mann at AMD for MiniMON and gdb 3.91.6. */
/* OBSOLETE    - David Wood (wood@@lab.ultra.nyu.edu) at New York University adapted this */
/* OBSOLETE    file to gdb 3.95.  I was unable to get this working on sun3os4 */
/* OBSOLETE    with termio, only with sgtty. */
/* OBSOLETE    - Daniel Mann at AMD took the 3.95 adaptions above and replaced */
/* OBSOLETE    MiniMON interface with UDI-p interface.        */ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "frame.h" */
/* OBSOLETE #include "inferior.h" */
/* OBSOLETE #include "value.h" */
/* OBSOLETE #include <ctype.h> */
/* OBSOLETE #include <fcntl.h> */
/* OBSOLETE #include <errno.h> */
/* OBSOLETE #include "gdb_string.h" */
/* OBSOLETE #include "terminal.h" */
/* OBSOLETE #include "target.h" */
/* OBSOLETE #include "29k-share/udi/udiproc.h" */
/* OBSOLETE #include "gdbcmd.h" */
/* OBSOLETE #include "bfd.h" */
/* OBSOLETE #include "gdbcore.h"		/* For download function */ */
/* OBSOLETE #include "regcache.h" */
/* OBSOLETE  */
/* OBSOLETE /* access the register store directly, without going through */
/* OBSOLETE    the normal handler functions. This avoids an extra data copy.  */ */
/* OBSOLETE  */
/* OBSOLETE extern int stop_soon_quietly;	/* for wait_for_inferior */ */
/* OBSOLETE extern struct value *call_function_by_hand (); */
/* OBSOLETE static void udi_resume (ptid_t ptid, int step, enum target_signal sig); */
/* OBSOLETE static void udi_fetch_registers (int regno); */
/* OBSOLETE static void udi_load (char *args, int from_tty); */
/* OBSOLETE static void fetch_register (int regno); */
/* OBSOLETE static void udi_store_registers (int regno); */
/* OBSOLETE static int store_register (int regno); */
/* OBSOLETE static int regnum_to_srnum (int regno); */
/* OBSOLETE static void udi_close (int quitting); */
/* OBSOLETE static CPUSpace udi_memory_space (CORE_ADDR addr); */
/* OBSOLETE static int udi_write_inferior_memory (CORE_ADDR memaddr, char *myaddr, */
/* OBSOLETE 				      int len); */
/* OBSOLETE static int udi_read_inferior_memory (CORE_ADDR memaddr, char *myaddr, */
/* OBSOLETE 				     int len); */
/* OBSOLETE static void download (char *load_arg_string, int from_tty); */
/* OBSOLETE char CoffFileName[100] = ""; */
/* OBSOLETE  */
/* OBSOLETE #define FREEZE_MODE     (read_register(CPS_REGNUM) & 0x400) */
/* OBSOLETE #define USE_SHADOW_PC	((processor_type == a29k_freeze_mode) && FREEZE_MODE) */
/* OBSOLETE  */
/* OBSOLETE static int timeout = 5; */
/* OBSOLETE extern struct target_ops udi_ops;	/* Forward declaration */ */
/* OBSOLETE  */
/* OBSOLETE /* Special register enumeration. */
/* OBSOLETE  */ */
/* OBSOLETE  */
/* OBSOLETE /******************************************************************* UDI DATA*/ */
/* OBSOLETE #define	MAXDATA		2*1024	/* max UDI[read/write] byte size */ */
/* OBSOLETE /* Descriptor for I/O to remote machine.  Initialize it to -1 so that */
/* OBSOLETE    udi_open knows that we don't have a file open when the program */
/* OBSOLETE    starts.  */ */
/* OBSOLETE  */
/* OBSOLETE UDISessionId udi_session_id = -1; */
/* OBSOLETE static char *udi_config_id; */
/* OBSOLETE  */
/* OBSOLETE CPUOffset IMemStart = 0; */
/* OBSOLETE CPUSizeT IMemSize = 0; */
/* OBSOLETE CPUOffset DMemStart = 0; */
/* OBSOLETE CPUSizeT DMemSize = 0; */
/* OBSOLETE CPUOffset RMemStart = 0; */
/* OBSOLETE CPUSizeT RMemSize = 0; */
/* OBSOLETE UDIUInt32 CPUPRL; */
/* OBSOLETE UDIUInt32 CoProcPRL; */
/* OBSOLETE  */
/* OBSOLETE UDIMemoryRange address_ranges[2];	/* Text and data */ */
/* OBSOLETE UDIResource entry = */
/* OBSOLETE {0, 0};				/* Entry point */ */
/* OBSOLETE CPUSizeT stack_sizes[2];	/* Regular and memory stacks */ */
/* OBSOLETE  */
/* OBSOLETE #define	SBUF_MAX	1024	/* maximum size of string handling buffer */ */
/* OBSOLETE char sbuf[SBUF_MAX]; */
/* OBSOLETE  */
/* OBSOLETE typedef struct bkpt_entry_str */
/* OBSOLETE   { */
/* OBSOLETE     UDIResource Addr; */
/* OBSOLETE     UDIUInt32 PassCount; */
/* OBSOLETE     UDIBreakType Type; */
/* OBSOLETE     unsigned int BreakId; */
/* OBSOLETE   } */
/* OBSOLETE bkpt_entry_t; */
/* OBSOLETE #define		BKPT_TABLE_SIZE 40 */
/* OBSOLETE static bkpt_entry_t bkpt_table[BKPT_TABLE_SIZE]; */
/* OBSOLETE extern char dfe_errmsg[];	/* error string */ */
/* OBSOLETE  */
/* OBSOLETE /* malloc'd name of the program on the remote system.  */ */
/* OBSOLETE static char *prog_name = NULL; */
/* OBSOLETE  */
/* OBSOLETE /* This is called not only when we first attach, but also when the */
/* OBSOLETE    user types "run" after having attached.  */ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE udi_create_inferior (char *execfile, char *args, char **env) */
/* OBSOLETE { */
/* OBSOLETE   char *args1; */
/* OBSOLETE  */
/* OBSOLETE   if (execfile) */
/* OBSOLETE     { */
/* OBSOLETE       if (prog_name != NULL) */
/* OBSOLETE 	xfree (prog_name); */
/* OBSOLETE       prog_name = savestring (execfile, strlen (execfile)); */
/* OBSOLETE     } */
/* OBSOLETE   else if (entry.Offset) */
/* OBSOLETE     execfile = ""; */
/* OBSOLETE   else */
/* OBSOLETE     error ("No image loaded into target."); */
/* OBSOLETE  */
/* OBSOLETE   if (udi_session_id < 0) */
/* OBSOLETE     { */
/* OBSOLETE       /* If the TIP is not open, open it.  */ */
/* OBSOLETE       if (UDIConnect (udi_config_id, &udi_session_id)) */
/* OBSOLETE 	error ("UDIConnect() failed: %s\n", dfe_errmsg); */
/* OBSOLETE       /* We will need to download the program.  */ */
/* OBSOLETE       entry.Offset = 0; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   inferior_ptid = pid_to_ptid (40000); */
/* OBSOLETE  */
/* OBSOLETE   if (!entry.Offset) */
/* OBSOLETE     download (execfile, 0); */
/* OBSOLETE  */
/* OBSOLETE   args1 = alloca (strlen (execfile) + strlen (args) + 2); */
/* OBSOLETE  */
/* OBSOLETE   if (execfile[0] == '\0') */
/* OBSOLETE  */
/* OBSOLETE     /* It is empty.  We need to quote it somehow, or else the target */
/* OBSOLETE        will think there is no argument being passed here.  According */
/* OBSOLETE        to the UDI spec it is quoted "according to TIP OS rules" which */
/* OBSOLETE        I guess means quoting it like the Unix shell should work */
/* OBSOLETE        (sounds pretty bogus to me...).  In fact it doesn't work (with */
/* OBSOLETE        isstip anyway), but passing in two quotes as the argument seems */
/* OBSOLETE        like a reasonable enough behavior anyway (I guess).  */ */
/* OBSOLETE  */
/* OBSOLETE     strcpy (args1, "''"); */
/* OBSOLETE   else */
/* OBSOLETE     strcpy (args1, execfile); */
/* OBSOLETE   strcat (args1, " "); */
/* OBSOLETE   strcat (args1, args); */
/* OBSOLETE  */
/* OBSOLETE   UDIInitializeProcess (address_ranges,		/* ProcessMemory[] */ */
/* OBSOLETE 			(UDIInt) 2,	/* NumberOfRanges */ */
/* OBSOLETE 			entry,	/* EntryPoint */ */
/* OBSOLETE 			stack_sizes,	/* *StackSizes */ */
/* OBSOLETE 			(UDIInt) 2,	/* NumberOfStacks */ */
/* OBSOLETE 			args1);	/* ArgString */ */
/* OBSOLETE  */
/* OBSOLETE   init_wait_for_inferior (); */
/* OBSOLETE   clear_proceed_status (); */
/* OBSOLETE   proceed (-1, TARGET_SIGNAL_DEFAULT, 0); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE udi_mourn (void) */
/* OBSOLETE { */
/* OBSOLETE #if 0 */
/* OBSOLETE   /* Requiring "target udi" each time you run is a major pain.  I suspect */
/* OBSOLETE      this was just blindy copied from remote.c, in which "target" and */
/* OBSOLETE      "run" are combined.  Having a udi target without an inferior seems */
/* OBSOLETE      to work between "target udi" and "run", so why not now?  */ */
/* OBSOLETE   pop_target ();		/* Pop back to no-child state */ */
/* OBSOLETE #endif */
/* OBSOLETE   /* But if we're going to want to run it again, we better remove the */
/* OBSOLETE      breakpoints...  */ */
/* OBSOLETE   remove_breakpoints (); */
/* OBSOLETE   generic_mourn_inferior (); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /******************************************************************** UDI_OPEN */
/* OBSOLETE ** Open a connection to remote TIP. */
/* OBSOLETE    NAME is the socket domain used for communication with the TIP, */
/* OBSOLETE    then a space and the socket name or TIP-host name. */
/* OBSOLETE    '<udi_udi_config_id>' for example. */
/* OBSOLETE  */ */
/* OBSOLETE  */
/* OBSOLETE /* XXX - need cleanups for udiconnect for various failures!!! */ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE udi_open (char *name, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   unsigned int prl; */
/* OBSOLETE   char *p; */
/* OBSOLETE   int cnt; */
/* OBSOLETE   UDIMemoryRange KnownMemory[10]; */
/* OBSOLETE   UDIUInt32 ChipVersions[10]; */
/* OBSOLETE   UDIInt NumberOfRanges = 10; */
/* OBSOLETE   UDIInt NumberOfChips = 10; */
/* OBSOLETE   UDIPId PId; */
/* OBSOLETE   UDIUInt32 TIPId, TargetId, DFEId, DFE, TIP, DFEIPCId, TIPIPCId; */
/* OBSOLETE  */
/* OBSOLETE   target_preopen (from_tty); */
/* OBSOLETE  */
/* OBSOLETE   entry.Offset = 0; */
/* OBSOLETE  */
/* OBSOLETE   for (cnt = 0; cnt < BKPT_TABLE_SIZE; cnt++) */
/* OBSOLETE     bkpt_table[cnt].Type = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (udi_config_id) */
/* OBSOLETE     xfree (udi_config_id); */
/* OBSOLETE  */
/* OBSOLETE   if (!name) */
/* OBSOLETE     error ("Usage: target udi config_id, where config_id appears in udi_soc file"); */
/* OBSOLETE  */
/* OBSOLETE   udi_config_id = xstrdup (strtok (name, " \t")); */
/* OBSOLETE  */
/* OBSOLETE   if (UDIConnect (udi_config_id, &udi_session_id)) */
/* OBSOLETE     /* FIXME: Should set udi_session_id to -1 here.  */ */
/* OBSOLETE     error ("UDIConnect() failed: %s\n", dfe_errmsg); */
/* OBSOLETE  */
/* OBSOLETE   push_target (&udi_ops); */
/* OBSOLETE  */
/* OBSOLETE   /* */
/* OBSOLETE      ** Initialize target configuration structure (global) */
/* OBSOLETE    */ */
/* OBSOLETE   if (UDIGetTargetConfig (KnownMemory, &NumberOfRanges, */
/* OBSOLETE 			  ChipVersions, &NumberOfChips)) */
/* OBSOLETE     error ("UDIGetTargetConfig() failed"); */
/* OBSOLETE   if (NumberOfChips > 2) */
/* OBSOLETE     fprintf_unfiltered (gdb_stderr, "Target has more than one processor\n"); */
/* OBSOLETE   for (cnt = 0; cnt < NumberOfRanges; cnt++) */
/* OBSOLETE     { */
/* OBSOLETE       switch (KnownMemory[cnt].Space) */
/* OBSOLETE 	{ */
/* OBSOLETE 	default: */
/* OBSOLETE 	  fprintf_unfiltered (gdb_stderr, "UDIGetTargetConfig() unknown memory space\n"); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case UDI29KCP_S: */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case UDI29KIROMSpace: */
/* OBSOLETE 	  RMemStart = KnownMemory[cnt].Offset; */
/* OBSOLETE 	  RMemSize = KnownMemory[cnt].Size; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case UDI29KIRAMSpace: */
/* OBSOLETE 	  IMemStart = KnownMemory[cnt].Offset; */
/* OBSOLETE 	  IMemSize = KnownMemory[cnt].Size; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case UDI29KDRAMSpace: */
/* OBSOLETE 	  DMemStart = KnownMemory[cnt].Offset; */
/* OBSOLETE 	  DMemSize = KnownMemory[cnt].Size; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   a29k_get_processor_type (); */
/* OBSOLETE  */
/* OBSOLETE   if (UDICreateProcess (&PId)) */
/* OBSOLETE     fprintf_unfiltered (gdb_stderr, "UDICreateProcess() failed\n"); */
/* OBSOLETE  */
/* OBSOLETE   /* Print out some stuff, letting the user now what's going on */ */
/* OBSOLETE   if (UDICapabilities (&TIPId, &TargetId, DFEId, DFE, &TIP, &DFEIPCId, */
/* OBSOLETE 		       &TIPIPCId, sbuf)) */
/* OBSOLETE     error ("UDICapabilities() failed"); */
/* OBSOLETE   if (from_tty) */
/* OBSOLETE     { */
/* OBSOLETE       printf_filtered ("Connected via UDI socket,\n\ */
/* OBSOLETE  DFE-IPC version %x.%x.%x  TIP-IPC version %x.%x.%x  TIP version %x.%x.%x\n %s\n", */
/* OBSOLETE 	       (DFEIPCId >> 8) & 0xf, (DFEIPCId >> 4) & 0xf, DFEIPCId & 0xf, */
/* OBSOLETE 	       (TIPIPCId >> 8) & 0xf, (TIPIPCId >> 4) & 0xf, TIPIPCId & 0xf, */
/* OBSOLETE 	       (TargetId >> 8) & 0xf, (TargetId >> 4) & 0xf, TargetId & 0xf, */
/* OBSOLETE 		       sbuf); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /******************************************************************* UDI_CLOSE */
/* OBSOLETE    Close the open connection to the TIP process. */
/* OBSOLETE    Use this when you want to detach and do something else */
/* OBSOLETE    with your gdb.  */ */
/* OBSOLETE static void */
/* OBSOLETE udi_close (			/*FIXME: how is quitting used */ */
/* OBSOLETE 	    int quitting) */
/* OBSOLETE { */
/* OBSOLETE   if (udi_session_id < 0) */
/* OBSOLETE     return; */
/* OBSOLETE  */
/* OBSOLETE   /* We should never get here if there isn't something valid in */
/* OBSOLETE      udi_session_id.  */ */
/* OBSOLETE  */
/* OBSOLETE   if (UDIDisconnect (udi_session_id, UDITerminateSession)) */
/* OBSOLETE     { */
/* OBSOLETE       if (quitting) */
/* OBSOLETE 	warning ("UDIDisconnect() failed in udi_close"); */
/* OBSOLETE       else */
/* OBSOLETE 	error ("UDIDisconnect() failed in udi_close"); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Do not try to close udi_session_id again, later in the program.  */ */
/* OBSOLETE   udi_session_id = -1; */
/* OBSOLETE   inferior_ptid = null_ptid; */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("  Ending remote debugging\n"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /**************************************************************** UDI_ATACH */ */
/* OBSOLETE /* Attach to a program that is already loaded and running  */
/* OBSOLETE  * Upon exiting the process's execution is stopped. */
/* OBSOLETE  */ */
/* OBSOLETE static void */
/* OBSOLETE udi_attach (char *args, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   UDIResource From; */
/* OBSOLETE   UDIInt32 PC_adds; */
/* OBSOLETE   UDICount Count = 1; */
/* OBSOLETE   UDISizeT Size = 4; */
/* OBSOLETE   UDICount CountDone; */
/* OBSOLETE   UDIBool HostEndian = 0; */
/* OBSOLETE   UDIError err; */
/* OBSOLETE  */
/* OBSOLETE   if (args == NULL) */
/* OBSOLETE     error_no_arg ("program to attach"); */
/* OBSOLETE  */
/* OBSOLETE   if (udi_session_id < 0) */
/* OBSOLETE     error ("UDI connection not opened yet, use the 'target udi' command.\n"); */
/* OBSOLETE  */
/* OBSOLETE   if (from_tty) */
/* OBSOLETE     printf_unfiltered ("Attaching to remote program %s...\n", prog_name); */
/* OBSOLETE  */
/* OBSOLETE   UDIStop (); */
/* OBSOLETE   From.Space = UDI29KSpecialRegs; */
/* OBSOLETE   From.Offset = 11; */
/* OBSOLETE   if (err = UDIRead (From, &PC_adds, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIRead failed in udi_attach"); */
/* OBSOLETE   printf_unfiltered ("Remote process is now halted, pc1 = 0x%x.\n", PC_adds); */
/* OBSOLETE } */
/* OBSOLETE /************************************************************* UDI_DETACH */ */
/* OBSOLETE /* Terminate the open connection to the TIP process. */
/* OBSOLETE    Use this when you want to detach and do something else */
/* OBSOLETE    with your gdb.  Leave remote process running (with no breakpoints set). */ */
/* OBSOLETE static void */
/* OBSOLETE udi_detach (char *args, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE  */
/* OBSOLETE   remove_breakpoints ();	/* Just in case there were any left in */ */
/* OBSOLETE  */
/* OBSOLETE   if (UDIDisconnect (udi_session_id, UDIContinueSession)) */
/* OBSOLETE     error ("UDIDisconnect() failed in udi_detach"); */
/* OBSOLETE  */
/* OBSOLETE   /* Don't try to UDIDisconnect it again in udi_close, which is called from */
/* OBSOLETE      pop_target.  */ */
/* OBSOLETE   udi_session_id = -1; */
/* OBSOLETE   inferior_ptid = null_ptid; */
/* OBSOLETE  */
/* OBSOLETE   pop_target (); */
/* OBSOLETE  */
/* OBSOLETE   if (from_tty) */
/* OBSOLETE     printf_unfiltered ("Detaching from TIP\n"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /****************************************************************** UDI_RESUME */
/* OBSOLETE ** Tell the remote machine to resume.  */ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE udi_resume (ptid_t ptid, int step, enum target_signal sig) */
/* OBSOLETE { */
/* OBSOLETE   UDIError tip_error; */
/* OBSOLETE   UDIUInt32 Steps = 1; */
/* OBSOLETE   UDIStepType StepType = UDIStepNatural; */
/* OBSOLETE   UDIRange Range; */
/* OBSOLETE  */
/* OBSOLETE   if (step)			/* step 1 instruction */ */
/* OBSOLETE     { */
/* OBSOLETE       tip_error = UDIStep (Steps, StepType, Range); */
/* OBSOLETE       if (!tip_error) */
/* OBSOLETE 	return; */
/* OBSOLETE  */
/* OBSOLETE       fprintf_unfiltered (gdb_stderr, "UDIStep() error = %d\n", tip_error); */
/* OBSOLETE       error ("failed in udi_resume"); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   if (UDIExecute ()) */
/* OBSOLETE     error ("UDIExecute() failed in udi_resume"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /******************************************************************** UDI_WAIT */
/* OBSOLETE ** Wait until the remote machine stops, then return, */
/* OBSOLETE    storing status in STATUS just as `wait' would.  */ */
/* OBSOLETE  */
/* OBSOLETE static ptid_t */
/* OBSOLETE udi_wait (ptid_t ptid, struct target_waitstatus *status) */
/* OBSOLETE { */
/* OBSOLETE   UDIInt32 MaxTime; */
/* OBSOLETE   UDIPId PId; */
/* OBSOLETE   UDIInt32 StopReason; */
/* OBSOLETE   UDISizeT CountDone; */
/* OBSOLETE   int old_timeout = timeout; */
/* OBSOLETE   int old_immediate_quit = immediate_quit; */
/* OBSOLETE   int i; */
/* OBSOLETE  */
/* OBSOLETE   status->kind = TARGET_WAITKIND_EXITED; */
/* OBSOLETE   status->value.integer = 0; */
/* OBSOLETE  */
/* OBSOLETE /* wait for message to arrive. It should be: */
/* OBSOLETE    If the target stops executing, udi_wait() should return. */
/* OBSOLETE  */ */
/* OBSOLETE   timeout = 0;			/* Wait indefinetly for a message */ */
/* OBSOLETE   immediate_quit = 1;		/* Helps ability to QUIT */ */
/* OBSOLETE  */
/* OBSOLETE   while (1) */
/* OBSOLETE     { */
/* OBSOLETE       i = 0; */
/* OBSOLETE       MaxTime = UDIWaitForever; */
/* OBSOLETE       UDIWait (MaxTime, &PId, &StopReason); */
/* OBSOLETE       QUIT;			/* Let user quit if they want */ */
/* OBSOLETE  */
/* OBSOLETE       switch (StopReason & UDIGrossState) */
/* OBSOLETE 	{ */
/* OBSOLETE 	case UDIStdoutReady: */
/* OBSOLETE 	  if (UDIGetStdout (sbuf, (UDISizeT) SBUF_MAX, &CountDone)) */
/* OBSOLETE 	    /* This is said to happen if the program tries to output */
/* OBSOLETE 	       a whole bunch of output (more than SBUF_MAX, I would */
/* OBSOLETE 	       guess).  It doesn't seem to happen with the simulator.  */ */
/* OBSOLETE 	    warning ("UDIGetStdout() failed in udi_wait"); */
/* OBSOLETE 	  fwrite (sbuf, 1, CountDone, stdout); */
/* OBSOLETE 	  gdb_flush (gdb_stdout); */
/* OBSOLETE 	  continue; */
/* OBSOLETE  */
/* OBSOLETE 	case UDIStderrReady: */
/* OBSOLETE 	  UDIGetStderr (sbuf, (UDISizeT) SBUF_MAX, &CountDone); */
/* OBSOLETE 	  fwrite (sbuf, 1, CountDone, stderr); */
/* OBSOLETE 	  gdb_flush (gdb_stderr); */
/* OBSOLETE 	  continue; */
/* OBSOLETE  */
/* OBSOLETE 	case UDIStdinNeeded: */
/* OBSOLETE 	  { */
/* OBSOLETE 	    int ch; */
/* OBSOLETE 	    i = 0; */
/* OBSOLETE 	    do */
/* OBSOLETE 	      { */
/* OBSOLETE 		ch = getchar (); */
/* OBSOLETE 		if (ch == EOF) */
/* OBSOLETE 		  break; */
/* OBSOLETE 		sbuf[i++] = ch; */
/* OBSOLETE 	      } */
/* OBSOLETE 	    while (i < SBUF_MAX && ch != '\n'); */
/* OBSOLETE 	    UDIPutStdin (sbuf, (UDISizeT) i, &CountDone); */
/* OBSOLETE 	    continue; */
/* OBSOLETE 	  } */
/* OBSOLETE  */
/* OBSOLETE 	case UDIRunning: */
/* OBSOLETE 	  /* In spite of the fact that we told UDIWait to wait forever, it will */
/* OBSOLETE 	     return spuriously sometimes.  */ */
/* OBSOLETE 	case UDIStdinModeX: */
/* OBSOLETE 	  continue; */
/* OBSOLETE 	default: */
/* OBSOLETE 	  break; */
/* OBSOLETE 	} */
/* OBSOLETE       break; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   switch (StopReason & UDIGrossState) */
/* OBSOLETE     { */
/* OBSOLETE     case UDITrapped: */
/* OBSOLETE       printf_unfiltered ("Am290*0 received vector number %d\n", StopReason >> 24); */
/* OBSOLETE  */
/* OBSOLETE       switch ((StopReason >> 8) & 0xff) */
/* OBSOLETE 	{ */
/* OBSOLETE 	case 0:		/* Illegal opcode */ */
/* OBSOLETE 	  printf_unfiltered ("	(break point)\n"); */
/* OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE 	  status->value.sig = TARGET_SIGNAL_TRAP; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case 1:		/* Unaligned Access */ */
/* OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE 	  status->value.sig = TARGET_SIGNAL_BUS; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case 3: */
/* OBSOLETE 	case 4: */
/* OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE 	  status->value.sig = TARGET_SIGNAL_FPE; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case 5:		/* Protection Violation */ */
/* OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE 	  /* Why not SEGV?  What is a Protection Violation?  */ */
/* OBSOLETE 	  status->value.sig = TARGET_SIGNAL_ILL; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case 6: */
/* OBSOLETE 	case 7: */
/* OBSOLETE 	case 8:		/* User Instruction Mapping Miss */ */
/* OBSOLETE 	case 9:		/* User Data Mapping Miss */ */
/* OBSOLETE 	case 10:		/* Supervisor Instruction Mapping Miss */ */
/* OBSOLETE 	case 11:		/* Supervisor Data Mapping Miss */ */
/* OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE 	  status->value.sig = TARGET_SIGNAL_SEGV; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case 12: */
/* OBSOLETE 	case 13: */
/* OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE 	  status->value.sig = TARGET_SIGNAL_ILL; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case 14:		/* Timer */ */
/* OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE 	  status->value.sig = TARGET_SIGNAL_ALRM; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case 15:		/* Trace */ */
/* OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE 	  status->value.sig = TARGET_SIGNAL_TRAP; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case 16:		/* INTR0 */ */
/* OBSOLETE 	case 17:		/* INTR1 */ */
/* OBSOLETE 	case 18:		/* INTR2 */ */
/* OBSOLETE 	case 19:		/* INTR3/Internal */ */
/* OBSOLETE 	case 20:		/* TRAP0 */ */
/* OBSOLETE 	case 21:		/* TRAP1 */ */
/* OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE 	  status->value.sig = TARGET_SIGNAL_INT; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case 22:		/* Floating-Point Exception */ */
/* OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE 	  /* Why not FPE?  */ */
/* OBSOLETE 	  status->value.sig = TARGET_SIGNAL_ILL; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case 77:		/* assert 77 */ */
/* OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE 	  status->value.sig = TARGET_SIGNAL_TRAP; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	default: */
/* OBSOLETE 	  status->kind = TARGET_WAITKIND_EXITED; */
/* OBSOLETE 	  status->value.integer = 0; */
/* OBSOLETE 	} */
/* OBSOLETE       break; */
/* OBSOLETE     case UDINotExecuting: */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_TERM; */
/* OBSOLETE       break; */
/* OBSOLETE     case UDIStopped: */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_TSTP; */
/* OBSOLETE       break; */
/* OBSOLETE     case UDIWarned: */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_URG; */
/* OBSOLETE       break; */
/* OBSOLETE     case UDIStepped: */
/* OBSOLETE     case UDIBreak: */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_TRAP; */
/* OBSOLETE       break; */
/* OBSOLETE     case UDIWaiting: */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_STOP; */
/* OBSOLETE       break; */
/* OBSOLETE     case UDIHalted: */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_KILL; */
/* OBSOLETE       break; */
/* OBSOLETE     case UDIExited: */
/* OBSOLETE     default: */
/* OBSOLETE       status->kind = TARGET_WAITKIND_EXITED; */
/* OBSOLETE       status->value.integer = 0; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   timeout = old_timeout;	/* Restore original timeout value */ */
/* OBSOLETE   immediate_quit = old_immediate_quit; */
/* OBSOLETE   return inferior_ptid; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #if 0 */
/* OBSOLETE /* Handy for debugging */ */
/* OBSOLETE udi_pc (void) */
/* OBSOLETE { */
/* OBSOLETE   UDIResource From; */
/* OBSOLETE   UDIUInt32 *To; */
/* OBSOLETE   UDICount Count; */
/* OBSOLETE   UDISizeT Size = 4; */
/* OBSOLETE   UDICount CountDone; */
/* OBSOLETE   UDIBool HostEndian = 0; */
/* OBSOLETE   UDIError err; */
/* OBSOLETE   int pc[2]; */
/* OBSOLETE   unsigned long myregs[256]; */
/* OBSOLETE   int i; */
/* OBSOLETE  */
/* OBSOLETE   From.Space = UDI29KPC; */
/* OBSOLETE   From.Offset = 0; */
/* OBSOLETE   To = (UDIUInt32 *) pc; */
/* OBSOLETE   Count = 2; */
/* OBSOLETE  */
/* OBSOLETE   err = UDIRead (From, To, Count, Size, &CountDone, HostEndian); */
/* OBSOLETE  */
/* OBSOLETE   printf_unfiltered ("err = %d, CountDone = %d, pc[0] = 0x%x, pc[1] = 0x%x\n", */
/* OBSOLETE 		     err, CountDone, pc[0], pc[1]); */
/* OBSOLETE  */
/* OBSOLETE   udi_fetch_registers (-1); */
/* OBSOLETE  */
/* OBSOLETE   printf_unfiltered ("other pc1 = 0x%x, pc0 = 0x%x\n", *(int *) &registers[4 * PC_REGNUM], */
/* OBSOLETE 		     *(int *) &registers[4 * NPC_REGNUM]); */
/* OBSOLETE  */
/* OBSOLETE   /* Now, read all the registers globally */ */
/* OBSOLETE  */
/* OBSOLETE   From.Space = UDI29KGlobalRegs; */
/* OBSOLETE   From.Offset = 0; */
/* OBSOLETE   err = UDIRead (From, myregs, 256, 4, &CountDone, HostEndian); */
/* OBSOLETE  */
/* OBSOLETE   printf ("err = %d, CountDone = %d\n", err, CountDone); */
/* OBSOLETE  */
/* OBSOLETE   printf ("\n"); */
/* OBSOLETE  */
/* OBSOLETE   for (i = 0; i < 256; i += 2) */
/* OBSOLETE     printf ("%d:\t%#10x\t%11d\t%#10x\t%11d\n", i, myregs[i], myregs[i], */
/* OBSOLETE 	    myregs[i + 1], myregs[i + 1]); */
/* OBSOLETE   printf ("\n"); */
/* OBSOLETE  */
/* OBSOLETE   return pc[0]; */
/* OBSOLETE } */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE /********************************************************** UDI_FETCH_REGISTERS */
/* OBSOLETE  * Read a remote register 'regno'.  */
/* OBSOLETE  * If regno==-1 then read all the registers. */
/* OBSOLETE  */ */
/* OBSOLETE static void */
/* OBSOLETE udi_fetch_registers (int regno) */
/* OBSOLETE { */
/* OBSOLETE   UDIResource From; */
/* OBSOLETE   UDIUInt32 *To; */
/* OBSOLETE   UDICount Count; */
/* OBSOLETE   UDISizeT Size = 4; */
/* OBSOLETE   UDICount CountDone; */
/* OBSOLETE   UDIBool HostEndian = 0; */
/* OBSOLETE   UDIError err; */
/* OBSOLETE   int i; */
/* OBSOLETE  */
/* OBSOLETE   if (regno >= 0) */
/* OBSOLETE     { */
/* OBSOLETE       fetch_register (regno); */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE /* Gr1/rsp */ */
/* OBSOLETE  */
/* OBSOLETE   From.Space = UDI29KGlobalRegs; */
/* OBSOLETE   From.Offset = 1; */
/* OBSOLETE   To = (UDIUInt32 *) & registers[4 * GR1_REGNUM]; */
/* OBSOLETE   Count = 1; */
/* OBSOLETE   if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIRead() failed in udi_fetch_registers"); */
/* OBSOLETE  */
/* OBSOLETE   register_valid[GR1_REGNUM] = 1; */
/* OBSOLETE  */
/* OBSOLETE #if defined(GR64_REGNUM)	/* Read gr64-127 */ */
/* OBSOLETE  */
/* OBSOLETE /* Global Registers gr64-gr95 */ */
/* OBSOLETE  */
/* OBSOLETE   From.Space = UDI29KGlobalRegs; */
/* OBSOLETE   From.Offset = 64; */
/* OBSOLETE   To = (UDIUInt32 *) & registers[4 * GR64_REGNUM]; */
/* OBSOLETE   Count = 32; */
/* OBSOLETE   if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIRead() failed in udi_fetch_registers"); */
/* OBSOLETE  */
/* OBSOLETE   for (i = GR64_REGNUM; i < GR64_REGNUM + 32; i++) */
/* OBSOLETE     register_valid[i] = 1; */
/* OBSOLETE  */
/* OBSOLETE #endif /*  GR64_REGNUM */ */
/* OBSOLETE  */
/* OBSOLETE /* Global Registers gr96-gr127 */ */
/* OBSOLETE  */
/* OBSOLETE   From.Space = UDI29KGlobalRegs; */
/* OBSOLETE   From.Offset = 96; */
/* OBSOLETE   To = (UDIUInt32 *) & registers[4 * GR96_REGNUM]; */
/* OBSOLETE   Count = 32; */
/* OBSOLETE   if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIRead() failed in udi_fetch_registers"); */
/* OBSOLETE  */
/* OBSOLETE   for (i = GR96_REGNUM; i < GR96_REGNUM + 32; i++) */
/* OBSOLETE     register_valid[i] = 1; */
/* OBSOLETE  */
/* OBSOLETE /* Local Registers */ */
/* OBSOLETE  */
/* OBSOLETE   From.Space = UDI29KLocalRegs; */
/* OBSOLETE   From.Offset = 0; */
/* OBSOLETE   To = (UDIUInt32 *) & registers[4 * LR0_REGNUM]; */
/* OBSOLETE   Count = 128; */
/* OBSOLETE   if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIRead() failed in udi_fetch_registers"); */
/* OBSOLETE  */
/* OBSOLETE   for (i = LR0_REGNUM; i < LR0_REGNUM + 128; i++) */
/* OBSOLETE     register_valid[i] = 1; */
/* OBSOLETE  */
/* OBSOLETE /* Protected Special Registers */ */
/* OBSOLETE  */
/* OBSOLETE   From.Space = UDI29KSpecialRegs; */
/* OBSOLETE   From.Offset = 0; */
/* OBSOLETE   To = (UDIUInt32 *) & registers[4 * SR_REGNUM (0)]; */
/* OBSOLETE   Count = 15; */
/* OBSOLETE   if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIRead() failed in udi_fetch_registers"); */
/* OBSOLETE  */
/* OBSOLETE   for (i = SR_REGNUM (0); i < SR_REGNUM (0) + 15; i++) */
/* OBSOLETE     register_valid[i] = 1; */
/* OBSOLETE  */
/* OBSOLETE   if (USE_SHADOW_PC) */
/* OBSOLETE     {				/* Let regno_to_srnum() handle the register number */ */
/* OBSOLETE       fetch_register (NPC_REGNUM); */
/* OBSOLETE       fetch_register (PC_REGNUM); */
/* OBSOLETE       fetch_register (PC2_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE /* Unprotected Special Registers sr128-sr135 */ */
/* OBSOLETE  */
/* OBSOLETE       From.Space = UDI29KSpecialRegs; */
/* OBSOLETE       From.Offset = 128; */
/* OBSOLETE       To = (UDIUInt32 *) & registers[4 * SR_REGNUM (128)]; */
/* OBSOLETE       Count = 135 - 128 + 1; */
/* OBSOLETE       if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE 	error ("UDIRead() failed in udi_fetch_registers"); */
/* OBSOLETE  */
/* OBSOLETE       for (i = SR_REGNUM (128); i < SR_REGNUM (128) + 135 - 128 + 1; i++) */
/* OBSOLETE 	register_valid[i] = 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   if (remote_debug) */
/* OBSOLETE     { */
/* OBSOLETE       fprintf_unfiltered (gdb_stdlog, "Fetching all registers\n"); */
/* OBSOLETE       fprintf_unfiltered (gdb_stdlog, */
/* OBSOLETE 			  "Fetching PC0 = 0x%x, PC1 = 0x%x, PC2 = 0x%x\n", */
/* OBSOLETE 			  read_register (NPC_REGNUM), */
/* OBSOLETE 			  read_register (PC_REGNUM), */
/* OBSOLETE 			  read_register (PC2_REGNUM)); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* There doesn't seem to be any way to get these.  */ */
/* OBSOLETE   { */
/* OBSOLETE     int val = -1; */
/* OBSOLETE     supply_register (FPE_REGNUM, (char *) &val); */
/* OBSOLETE     supply_register (INTE_REGNUM, (char *) &val); */
/* OBSOLETE     supply_register (FPS_REGNUM, (char *) &val); */
/* OBSOLETE     supply_register (EXO_REGNUM, (char *) &val); */
/* OBSOLETE   } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /********************************************************* UDI_STORE_REGISTERS */
/* OBSOLETE ** Store register regno into the target.   */
/* OBSOLETE  * If regno==-1 then store all the registers. */
/* OBSOLETE  */ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE udi_store_registers (int regno) */
/* OBSOLETE { */
/* OBSOLETE   UDIUInt32 *From; */
/* OBSOLETE   UDIResource To; */
/* OBSOLETE   UDICount Count; */
/* OBSOLETE   UDISizeT Size = 4; */
/* OBSOLETE   UDICount CountDone; */
/* OBSOLETE   UDIBool HostEndian = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (regno >= 0) */
/* OBSOLETE     { */
/* OBSOLETE       store_register (regno); */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   if (remote_debug) */
/* OBSOLETE     { */
/* OBSOLETE       fprintf_unfiltered (gdb_stdlog, "Storing all registers\n"); */
/* OBSOLETE       fprintf_unfiltered (gdb_stdlog, */
/* OBSOLETE 			  "PC0 = 0x%x, PC1 = 0x%x, PC2 = 0x%x\n", */
/* OBSOLETE 			  read_register (NPC_REGNUM), */
/* OBSOLETE 			  read_register (PC_REGNUM), */
/* OBSOLETE 			  read_register (PC2_REGNUM)); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE /* Gr1/rsp */ */
/* OBSOLETE  */
/* OBSOLETE   From = (UDIUInt32 *) & registers[4 * GR1_REGNUM]; */
/* OBSOLETE   To.Space = UDI29KGlobalRegs; */
/* OBSOLETE   To.Offset = 1; */
/* OBSOLETE   Count = 1; */
/* OBSOLETE   if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIWrite() failed in udi_store_regisetrs"); */
/* OBSOLETE  */
/* OBSOLETE #if defined(GR64_REGNUM) */
/* OBSOLETE  */
/* OBSOLETE /* Global registers gr64-gr95 */ */
/* OBSOLETE  */
/* OBSOLETE   From = (UDIUInt32 *) & registers[4 * GR64_REGNUM]; */
/* OBSOLETE   To.Space = UDI29KGlobalRegs; */
/* OBSOLETE   To.Offset = 64; */
/* OBSOLETE   Count = 32; */
/* OBSOLETE   if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIWrite() failed in udi_store_regisetrs"); */
/* OBSOLETE  */
/* OBSOLETE #endif /* GR64_REGNUM */ */
/* OBSOLETE  */
/* OBSOLETE /* Global registers gr96-gr127 */ */
/* OBSOLETE  */
/* OBSOLETE   From = (UDIUInt32 *) & registers[4 * GR96_REGNUM]; */
/* OBSOLETE   To.Space = UDI29KGlobalRegs; */
/* OBSOLETE   To.Offset = 96; */
/* OBSOLETE   Count = 32; */
/* OBSOLETE   if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIWrite() failed in udi_store_regisetrs"); */
/* OBSOLETE  */
/* OBSOLETE /* Local Registers */ */
/* OBSOLETE  */
/* OBSOLETE   From = (UDIUInt32 *) & registers[4 * LR0_REGNUM]; */
/* OBSOLETE   To.Space = UDI29KLocalRegs; */
/* OBSOLETE   To.Offset = 0; */
/* OBSOLETE   Count = 128; */
/* OBSOLETE   if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIWrite() failed in udi_store_regisetrs"); */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE   /* Protected Special Registers *//* VAB through TMR */ */
/* OBSOLETE  */
/* OBSOLETE   From = (UDIUInt32 *) & registers[4 * SR_REGNUM (0)]; */
/* OBSOLETE   To.Space = UDI29KSpecialRegs; */
/* OBSOLETE   To.Offset = 0; */
/* OBSOLETE   Count = 10; */
/* OBSOLETE   if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIWrite() failed in udi_store_regisetrs"); */
/* OBSOLETE  */
/* OBSOLETE /* PC0, PC1, PC2 possibly as shadow registers */ */
/* OBSOLETE  */
/* OBSOLETE   From = (UDIUInt32 *) & registers[4 * SR_REGNUM (10)]; */
/* OBSOLETE   To.Space = UDI29KSpecialRegs; */
/* OBSOLETE   Count = 3; */
/* OBSOLETE   if (USE_SHADOW_PC) */
/* OBSOLETE     To.Offset = 20;		/* SPC0 */ */
/* OBSOLETE   else */
/* OBSOLETE     To.Offset = 10;		/* PC0 */ */
/* OBSOLETE   if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIWrite() failed in udi_store_regisetrs"); */
/* OBSOLETE  */
/* OBSOLETE /* PC1 via UDI29KPC */ */
/* OBSOLETE  */
/* OBSOLETE   From = (UDIUInt32 *) & registers[4 * PC_REGNUM]; */
/* OBSOLETE   To.Space = UDI29KPC; */
/* OBSOLETE   To.Offset = 0;		/* PC1 */ */
/* OBSOLETE   Count = 1; */
/* OBSOLETE   if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIWrite() failed in udi_store_regisetrs"); */
/* OBSOLETE  */
/* OBSOLETE   /* LRU and MMU */ */
/* OBSOLETE  */
/* OBSOLETE   From = (UDIUInt32 *) & registers[4 * SR_REGNUM (13)]; */
/* OBSOLETE   To.Space = UDI29KSpecialRegs; */
/* OBSOLETE   To.Offset = 13; */
/* OBSOLETE   Count = 2; */
/* OBSOLETE   if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIWrite() failed in udi_store_regisetrs"); */
/* OBSOLETE  */
/* OBSOLETE /* Unprotected Special Registers */ */
/* OBSOLETE  */
/* OBSOLETE   From = (UDIUInt32 *) & registers[4 * SR_REGNUM (128)]; */
/* OBSOLETE   To.Space = UDI29KSpecialRegs; */
/* OBSOLETE   To.Offset = 128; */
/* OBSOLETE   Count = 135 - 128 + 1; */
/* OBSOLETE   if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIWrite() failed in udi_store_regisetrs"); */
/* OBSOLETE  */
/* OBSOLETE   registers_changed (); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /****************************************************** UDI_PREPARE_TO_STORE */ */
/* OBSOLETE /* Get ready to modify the registers array.  On machines which store */
/* OBSOLETE    individual registers, this doesn't need to do anything.  On machines */
/* OBSOLETE    which store all the registers in one fell swoop, this makes sure */
/* OBSOLETE    that registers contains all the registers from the program being */
/* OBSOLETE    debugged.  */ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE udi_prepare_to_store (void) */
/* OBSOLETE { */
/* OBSOLETE   /* Do nothing, since we can store individual regs */ */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /********************************************************** TRANSLATE_ADDR */ */
/* OBSOLETE static CORE_ADDR */
/* OBSOLETE translate_addr (CORE_ADDR addr) */
/* OBSOLETE { */
/* OBSOLETE #if defined(ULTRA3) && defined(KERNEL_DEBUGGING) */
/* OBSOLETE   /* Check for a virtual address in the kernel */ */
/* OBSOLETE   /* Assume physical address of ublock is in  paddr_u register */ */
/* OBSOLETE   /* FIXME: doesn't work for user virtual addresses */ */
/* OBSOLETE   if (addr >= UVADDR) */
/* OBSOLETE     { */
/* OBSOLETE       /* PADDR_U register holds the physical address of the ublock */ */
/* OBSOLETE       CORE_ADDR i = (CORE_ADDR) read_register (PADDR_U_REGNUM); */
/* OBSOLETE       return (i + addr - (CORE_ADDR) UVADDR); */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       return (addr); */
/* OBSOLETE     } */
/* OBSOLETE #else */
/* OBSOLETE   return (addr); */
/* OBSOLETE #endif */
/* OBSOLETE } */
/* OBSOLETE /************************************************* UDI_XFER_INFERIOR_MEMORY */ */
/* OBSOLETE /* FIXME!  Merge these two.  */ */
/* OBSOLETE static int */
/* OBSOLETE udi_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len, int write, */
/* OBSOLETE 			  struct mem_attrib *attrib ATTRIBUTE_UNUSED, */
/* OBSOLETE 			  struct target_ops *target ATTRIBUTE_UNUSED) */
/* OBSOLETE { */
/* OBSOLETE  */
/* OBSOLETE   memaddr = translate_addr (memaddr); */
/* OBSOLETE  */
/* OBSOLETE   if (write) */
/* OBSOLETE     return udi_write_inferior_memory (memaddr, myaddr, len); */
/* OBSOLETE   else */
/* OBSOLETE     return udi_read_inferior_memory (memaddr, myaddr, len); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /********************************************************** UDI_FILES_INFO */ */
/* OBSOLETE static void */
/* OBSOLETE udi_files_info (struct target_ops *target) */
/* OBSOLETE { */
/* OBSOLETE   printf_unfiltered ("\tAttached to UDI socket to %s", udi_config_id); */
/* OBSOLETE   if (prog_name != NULL) */
/* OBSOLETE     printf_unfiltered ("and running program %s", prog_name); */
/* OBSOLETE   printf_unfiltered (".\n"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /**************************************************** UDI_INSERT_BREAKPOINT */ */
/* OBSOLETE static int */
/* OBSOLETE udi_insert_breakpoint (CORE_ADDR addr, char *contents_cache) */
/* OBSOLETE { */
/* OBSOLETE   int cnt; */
/* OBSOLETE   UDIError err; */
/* OBSOLETE  */
/* OBSOLETE   for (cnt = 0; cnt < BKPT_TABLE_SIZE; cnt++) */
/* OBSOLETE     if (bkpt_table[cnt].Type == 0)	/* Find first free slot */ */
/* OBSOLETE       break; */
/* OBSOLETE  */
/* OBSOLETE   if (cnt >= BKPT_TABLE_SIZE) */
/* OBSOLETE     error ("Too many breakpoints set"); */
/* OBSOLETE  */
/* OBSOLETE   bkpt_table[cnt].Addr.Offset = addr; */
/* OBSOLETE   bkpt_table[cnt].Addr.Space = UDI29KIRAMSpace; */
/* OBSOLETE   bkpt_table[cnt].PassCount = 1; */
/* OBSOLETE   bkpt_table[cnt].Type = UDIBreakFlagExecute; */
/* OBSOLETE  */
/* OBSOLETE   err = UDISetBreakpoint (bkpt_table[cnt].Addr, */
/* OBSOLETE 			  bkpt_table[cnt].PassCount, */
/* OBSOLETE 			  bkpt_table[cnt].Type, */
/* OBSOLETE 			  &bkpt_table[cnt].BreakId); */
/* OBSOLETE  */
/* OBSOLETE   if (err == 0) */
/* OBSOLETE     return 0;			/* Success */ */
/* OBSOLETE  */
/* OBSOLETE   bkpt_table[cnt].Type = 0; */
/* OBSOLETE   error ("UDISetBreakpoint returned error code %d\n", err); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /**************************************************** UDI_REMOVE_BREAKPOINT */ */
/* OBSOLETE static int */
/* OBSOLETE udi_remove_breakpoint (CORE_ADDR addr, char *contents_cache) */
/* OBSOLETE { */
/* OBSOLETE   int cnt; */
/* OBSOLETE   UDIError err; */
/* OBSOLETE  */
/* OBSOLETE   for (cnt = 0; cnt < BKPT_TABLE_SIZE; cnt++) */
/* OBSOLETE     if (bkpt_table[cnt].Addr.Offset == addr)	/* Find matching breakpoint */ */
/* OBSOLETE       break; */
/* OBSOLETE  */
/* OBSOLETE   if (cnt >= BKPT_TABLE_SIZE) */
/* OBSOLETE     error ("Can't find breakpoint in table"); */
/* OBSOLETE  */
/* OBSOLETE   bkpt_table[cnt].Type = 0; */
/* OBSOLETE  */
/* OBSOLETE   err = UDIClearBreakpoint (bkpt_table[cnt].BreakId); */
/* OBSOLETE   if (err == 0) */
/* OBSOLETE     return 0;			/* Success */ */
/* OBSOLETE  */
/* OBSOLETE   error ("UDIClearBreakpoint returned error code %d\n", err); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE udi_kill (void) */
/* OBSOLETE { */
/* OBSOLETE  */
/* OBSOLETE #if 0 */
/* OBSOLETE /* */
/* OBSOLETE    UDIStop does not really work as advertised.  It causes the TIP to close it's */
/* OBSOLETE    connection, which usually results in GDB dying with a SIGPIPE.  For now, we */
/* OBSOLETE    just invoke udi_close, which seems to get things right. */
/* OBSOLETE  */ */
/* OBSOLETE   UDIStop (); */
/* OBSOLETE  */
/* OBSOLETE   udi_session_id = -1; */
/* OBSOLETE   inferior_ptid = null_ptid; */
/* OBSOLETE  */
/* OBSOLETE   if (from_tty) */
/* OBSOLETE     printf_unfiltered ("Target has been stopped."); */
/* OBSOLETE #endif /* 0 */ */
/* OBSOLETE #if 0 */
/* OBSOLETE   udi_close (0); */
/* OBSOLETE   pop_target (); */
/* OBSOLETE #endif /* 0 */ */
/* OBSOLETE  */
/* OBSOLETE   /* Keep the target around, e.g. so "run" can do the right thing when */
/* OBSOLETE      we are already debugging something.  */ */
/* OBSOLETE  */
/* OBSOLETE   if (UDIDisconnect (udi_session_id, UDITerminateSession)) */
/* OBSOLETE     { */
/* OBSOLETE       warning ("UDIDisconnect() failed"); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Do not try to close udi_session_id again, later in the program.  */ */
/* OBSOLETE   udi_session_id = -1; */
/* OBSOLETE   inferior_ptid = null_ptid; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /*  */
/* OBSOLETE    Load a program into the target.  Args are: `program {options}'.  The options */
/* OBSOLETE    are used to control loading of the program, and are NOT passed onto the */
/* OBSOLETE    loaded code as arguments.  (You need to use the `run' command to do that.) */
/* OBSOLETE  */
/* OBSOLETE    The options are: */
/* OBSOLETE    -ms %d       Set mem stack size to %d */
/* OBSOLETE    -rs %d       Set regular stack size to %d */
/* OBSOLETE    -i   send init info (default) */
/* OBSOLETE    -noi don't send init info */
/* OBSOLETE    -[tT]        Load Text section */
/* OBSOLETE    -[dD]        Load Data section */
/* OBSOLETE    -[bB]        Load BSS section */
/* OBSOLETE    -[lL]        Load Lit section */
/* OBSOLETE  */ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE download (char *load_arg_string, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE #define DEFAULT_MEM_STACK_SIZE 		0x6000 */
/* OBSOLETE #define DEFAULT_REG_STACK_SIZE 		0x2000 */
/* OBSOLETE  */
/* OBSOLETE   char *token; */
/* OBSOLETE   char *filename; */
/* OBSOLETE   asection *section; */
/* OBSOLETE   bfd *pbfd; */
/* OBSOLETE   UDIError err; */
/* OBSOLETE   int load_text = 1, load_data = 1, load_bss = 1, load_lit = 1; */
/* OBSOLETE  */
/* OBSOLETE   address_ranges[0].Space = UDI29KIRAMSpace; */
/* OBSOLETE   address_ranges[0].Offset = 0xffffffff; */
/* OBSOLETE   address_ranges[0].Size = 0; */
/* OBSOLETE  */
/* OBSOLETE   address_ranges[1].Space = UDI29KDRAMSpace; */
/* OBSOLETE   address_ranges[1].Offset = 0xffffffff; */
/* OBSOLETE   address_ranges[1].Size = 0; */
/* OBSOLETE  */
/* OBSOLETE   stack_sizes[0] = DEFAULT_REG_STACK_SIZE; */
/* OBSOLETE   stack_sizes[1] = DEFAULT_MEM_STACK_SIZE; */
/* OBSOLETE  */
/* OBSOLETE   dont_repeat (); */
/* OBSOLETE  */
/* OBSOLETE   filename = strtok (load_arg_string, " \t"); */
/* OBSOLETE   if (!filename) */
/* OBSOLETE     error ("Must specify at least a file name with the load command"); */
/* OBSOLETE  */
/* OBSOLETE   filename = tilde_expand (filename); */
/* OBSOLETE   make_cleanup (xfree, filename); */
/* OBSOLETE  */
/* OBSOLETE   while (token = strtok (NULL, " \t")) */
/* OBSOLETE     { */
/* OBSOLETE       if (token[0] == '-') */
/* OBSOLETE 	{ */
/* OBSOLETE 	  token++; */
/* OBSOLETE  */
/* OBSOLETE 	  if (STREQ (token, "ms")) */
/* OBSOLETE 	    stack_sizes[1] = atol (strtok (NULL, " \t")); */
/* OBSOLETE 	  else if (STREQ (token, "rs")) */
/* OBSOLETE 	    stack_sizes[0] = atol (strtok (NULL, " \t")); */
/* OBSOLETE 	  else */
/* OBSOLETE 	    { */
/* OBSOLETE 	      load_text = load_data = load_bss = load_lit = 0; */
/* OBSOLETE  */
/* OBSOLETE 	      while (*token) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  switch (*token++) */
/* OBSOLETE 		    { */
/* OBSOLETE 		    case 't': */
/* OBSOLETE 		    case 'T': */
/* OBSOLETE 		      load_text = 1; */
/* OBSOLETE 		      break; */
/* OBSOLETE 		    case 'd': */
/* OBSOLETE 		    case 'D': */
/* OBSOLETE 		      load_data = 1; */
/* OBSOLETE 		      break; */
/* OBSOLETE 		    case 'b': */
/* OBSOLETE 		    case 'B': */
/* OBSOLETE 		      load_bss = 1; */
/* OBSOLETE 		      break; */
/* OBSOLETE 		    case 'l': */
/* OBSOLETE 		    case 'L': */
/* OBSOLETE 		      load_lit = 1; */
/* OBSOLETE 		      break; */
/* OBSOLETE 		    default: */
/* OBSOLETE 		      error ("Unknown UDI load option -%s", token - 1); */
/* OBSOLETE 		    } */
/* OBSOLETE 		} */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   pbfd = bfd_openr (filename, gnutarget); */
/* OBSOLETE  */
/* OBSOLETE   if (!pbfd) */
/* OBSOLETE     /* FIXME: should be using bfd_errmsg, not assuming it was */
/* OBSOLETE        bfd_error_system_call.  */ */
/* OBSOLETE     perror_with_name (filename); */
/* OBSOLETE  */
/* OBSOLETE   /* FIXME: should be checking for errors from bfd_close (for one thing, */
/* OBSOLETE      on error it does not free all the storage associated with the */
/* OBSOLETE      bfd).  */ */
/* OBSOLETE   make_cleanup_bfd_close (pbfd); */
/* OBSOLETE  */
/* OBSOLETE   QUIT; */
/* OBSOLETE   immediate_quit++; */
/* OBSOLETE  */
/* OBSOLETE   if (!bfd_check_format (pbfd, bfd_object)) */
/* OBSOLETE     error ("It doesn't seem to be an object file"); */
/* OBSOLETE  */
/* OBSOLETE   for (section = pbfd->sections; section; section = section->next) */
/* OBSOLETE     { */
/* OBSOLETE       if (bfd_get_section_flags (pbfd, section) & SEC_ALLOC) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  UDIResource To; */
/* OBSOLETE 	  UDICount Count; */
/* OBSOLETE 	  unsigned long section_size, section_end; */
/* OBSOLETE 	  const char *section_name; */
/* OBSOLETE  */
/* OBSOLETE 	  section_name = bfd_get_section_name (pbfd, section); */
/* OBSOLETE 	  if (STREQ (section_name, ".text") && !load_text) */
/* OBSOLETE 	    continue; */
/* OBSOLETE 	  else if (STREQ (section_name, ".data") && !load_data) */
/* OBSOLETE 	    continue; */
/* OBSOLETE 	  else if (STREQ (section_name, ".bss") && !load_bss) */
/* OBSOLETE 	    continue; */
/* OBSOLETE 	  else if (STREQ (section_name, ".lit") && !load_lit) */
/* OBSOLETE 	    continue; */
/* OBSOLETE  */
/* OBSOLETE 	  To.Offset = bfd_get_section_vma (pbfd, section); */
/* OBSOLETE 	  section_size = bfd_section_size (pbfd, section); */
/* OBSOLETE 	  section_end = To.Offset + section_size; */
/* OBSOLETE  */
/* OBSOLETE 	  if (section_size == 0) */
/* OBSOLETE 	    /* This is needed at least in the BSS case, where the code */
/* OBSOLETE 	       below starts writing before it even checks the size.  */ */
/* OBSOLETE 	    continue; */
/* OBSOLETE  */
/* OBSOLETE 	  printf_unfiltered ("[Loading section %s at %x (%d bytes)]\n", */
/* OBSOLETE 			     section_name, */
/* OBSOLETE 			     To.Offset, */
/* OBSOLETE 			     section_size); */
/* OBSOLETE  */
/* OBSOLETE 	  if (bfd_get_section_flags (pbfd, section) & SEC_CODE) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      To.Space = UDI29KIRAMSpace; */
/* OBSOLETE  */
/* OBSOLETE 	      address_ranges[0].Offset = min (address_ranges[0].Offset, */
/* OBSOLETE 					      To.Offset); */
/* OBSOLETE 	      address_ranges[0].Size = max (address_ranges[0].Size, */
/* OBSOLETE 					    section_end */
/* OBSOLETE 					    - address_ranges[0].Offset); */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    { */
/* OBSOLETE 	      To.Space = UDI29KDRAMSpace; */
/* OBSOLETE  */
/* OBSOLETE 	      address_ranges[1].Offset = min (address_ranges[1].Offset, */
/* OBSOLETE 					      To.Offset); */
/* OBSOLETE 	      address_ranges[1].Size = max (address_ranges[1].Size, */
/* OBSOLETE 					    section_end */
/* OBSOLETE 					    - address_ranges[1].Offset); */
/* OBSOLETE 	    } */
/* OBSOLETE  */
/* OBSOLETE 	  if (bfd_get_section_flags (pbfd, section) & SEC_LOAD)		/* Text, data or lit */ */
/* OBSOLETE 	    { */
/* OBSOLETE 	      file_ptr fptr; */
/* OBSOLETE  */
/* OBSOLETE 	      fptr = 0; */
/* OBSOLETE  */
/* OBSOLETE 	      while (section_size > 0) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  char buffer[1024]; */
/* OBSOLETE  */
/* OBSOLETE 		  Count = min (section_size, 1024); */
/* OBSOLETE  */
/* OBSOLETE 		  bfd_get_section_contents (pbfd, section, buffer, fptr, */
/* OBSOLETE 					    Count); */
/* OBSOLETE  */
/* OBSOLETE 		  err = UDIWrite ((UDIHostMemPtr) buffer,	/* From */ */
/* OBSOLETE 				  To,	/* To */ */
/* OBSOLETE 				  Count,	/* Count */ */
/* OBSOLETE 				  (UDISizeT) 1,		/* Size */ */
/* OBSOLETE 				  &Count,	/* CountDone */ */
/* OBSOLETE 				  (UDIBool) 0);		/* HostEndian */ */
/* OBSOLETE 		  if (err) */
/* OBSOLETE 		    error ("UDIWrite failed, error = %d", err); */
/* OBSOLETE  */
/* OBSOLETE 		  To.Offset += Count; */
/* OBSOLETE 		  fptr += Count; */
/* OBSOLETE 		  section_size -= Count; */
/* OBSOLETE 		} */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    /* BSS */ */
/* OBSOLETE 	    { */
/* OBSOLETE 	      UDIResource From; */
/* OBSOLETE 	      unsigned long zero = 0; */
/* OBSOLETE  */
/* OBSOLETE 	      /* Write a zero byte at the vma */ */
/* OBSOLETE 	      /* FIXME: Broken for sections of 1-3 bytes (we test for */
/* OBSOLETE 	         zero above).  */ */
/* OBSOLETE 	      err = UDIWrite ((UDIHostMemPtr) & zero,	/* From */ */
/* OBSOLETE 			      To,	/* To */ */
/* OBSOLETE 			      (UDICount) 1,	/* Count */ */
/* OBSOLETE 			      (UDISizeT) 4,	/* Size */ */
/* OBSOLETE 			      &Count,	/* CountDone */ */
/* OBSOLETE 			      (UDIBool) 0);	/* HostEndian */ */
/* OBSOLETE 	      if (err) */
/* OBSOLETE 		error ("UDIWrite failed, error = %d", err); */
/* OBSOLETE  */
/* OBSOLETE 	      From = To; */
/* OBSOLETE 	      To.Offset += 4; */
/* OBSOLETE  */
/* OBSOLETE 	      /* Now, duplicate it for the length of the BSS */ */
/* OBSOLETE 	      err = UDICopy (From,	/* From */ */
/* OBSOLETE 			     To,	/* To */ */
/* OBSOLETE 			     (UDICount) (section_size / 4 - 1),		/* Count */ */
/* OBSOLETE 			     (UDISizeT) 4,	/* Size */ */
/* OBSOLETE 			     &Count,	/* CountDone */ */
/* OBSOLETE 			     (UDIBool) 1);	/* Direction */ */
/* OBSOLETE 	      if (err) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  char message[100]; */
/* OBSOLETE 		  int xerr; */
/* OBSOLETE  */
/* OBSOLETE 		  xerr = UDIGetErrorMsg (err, 100, message, &Count); */
/* OBSOLETE 		  if (!xerr) */
/* OBSOLETE 		    fprintf_unfiltered (gdb_stderr, "Error is %s\n", message); */
/* OBSOLETE 		  else */
/* OBSOLETE 		    fprintf_unfiltered (gdb_stderr, "xerr is %d\n", xerr); */
/* OBSOLETE 		  error ("UDICopy failed, error = %d", err); */
/* OBSOLETE 		} */
/* OBSOLETE 	    } */
/* OBSOLETE  */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   entry.Space = UDI29KIRAMSpace; */
/* OBSOLETE   entry.Offset = bfd_get_start_address (pbfd); */
/* OBSOLETE  */
/* OBSOLETE   immediate_quit--; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Function to download an image into the remote target.  */ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE udi_load (char *args, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   download (args, from_tty); */
/* OBSOLETE  */
/* OBSOLETE   /* As a convenience, pick up any symbol info that is in the program */
/* OBSOLETE      being loaded.  Note that we assume that the program is the``mainline''; */
/* OBSOLETE      if this is not always true, then this code will need to be augmented.  */ */
/* OBSOLETE   symbol_file_add (strtok (args, " \t"), from_tty, NULL, 1, 0); */
/* OBSOLETE  */
/* OBSOLETE   /* Getting new symbols may change our opinion about what is */
/* OBSOLETE      frameless.  */ */
/* OBSOLETE   reinit_frame_cache (); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /*************************************************** UDI_WRITE_INFERIOR_MEMORY */
/* OBSOLETE ** Copy LEN bytes of data from debugger memory at MYADDR */
/* OBSOLETE    to inferior's memory at MEMADDR.  Returns number of bytes written.  */ */
/* OBSOLETE static int */
/* OBSOLETE udi_write_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len) */
/* OBSOLETE { */
/* OBSOLETE   int nwritten = 0; */
/* OBSOLETE   UDIUInt32 *From; */
/* OBSOLETE   UDIResource To; */
/* OBSOLETE   UDICount Count; */
/* OBSOLETE   UDISizeT Size = 1; */
/* OBSOLETE   UDICount CountDone = 0; */
/* OBSOLETE   UDIBool HostEndian = 0; */
/* OBSOLETE  */
/* OBSOLETE   To.Space = udi_memory_space (memaddr); */
/* OBSOLETE   From = (UDIUInt32 *) myaddr; */
/* OBSOLETE  */
/* OBSOLETE   while (nwritten < len) */
/* OBSOLETE     { */
/* OBSOLETE       Count = len - nwritten; */
/* OBSOLETE       if (Count > MAXDATA) */
/* OBSOLETE 	Count = MAXDATA; */
/* OBSOLETE       To.Offset = memaddr + nwritten; */
/* OBSOLETE       if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  error ("UDIWrite() failed in udi_write_inferior_memory"); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  nwritten += CountDone; */
/* OBSOLETE 	  From += CountDone; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   return (nwritten); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /**************************************************** UDI_READ_INFERIOR_MEMORY */
/* OBSOLETE ** Read LEN bytes from inferior memory at MEMADDR.  Put the result */
/* OBSOLETE    at debugger address MYADDR.  Returns number of bytes read.  */ */
/* OBSOLETE static int */
/* OBSOLETE udi_read_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len) */
/* OBSOLETE { */
/* OBSOLETE   int nread = 0; */
/* OBSOLETE   UDIResource From; */
/* OBSOLETE   UDIUInt32 *To; */
/* OBSOLETE   UDICount Count; */
/* OBSOLETE   UDISizeT Size = 1; */
/* OBSOLETE   UDICount CountDone = 0; */
/* OBSOLETE   UDIBool HostEndian = 0; */
/* OBSOLETE   UDIError err; */
/* OBSOLETE  */
/* OBSOLETE   From.Space = udi_memory_space (memaddr); */
/* OBSOLETE   To = (UDIUInt32 *) myaddr; */
/* OBSOLETE  */
/* OBSOLETE   while (nread < len) */
/* OBSOLETE     { */
/* OBSOLETE       Count = len - nread; */
/* OBSOLETE       if (Count > MAXDATA) */
/* OBSOLETE 	Count = MAXDATA; */
/* OBSOLETE       From.Offset = memaddr + nread; */
/* OBSOLETE       if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  error ("UDIRead() failed in udi_read_inferior_memory"); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  nread += CountDone; */
/* OBSOLETE 	  To += CountDone; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   return (nread); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /********************************************************************* WARNING */
/* OBSOLETE */ */
/* OBSOLETE udi_warning (int num) */
/* OBSOLETE { */
/* OBSOLETE   error ("ERROR while loading program into remote TIP: $d\n", num); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /*****************************************************************************/ */
/* OBSOLETE /* Fetch a single register indicatated by 'regno'.  */
/* OBSOLETE  * Returns 0/-1 on success/failure.   */
/* OBSOLETE  */ */
/* OBSOLETE static void */
/* OBSOLETE fetch_register (int regno) */
/* OBSOLETE { */
/* OBSOLETE   UDIResource From; */
/* OBSOLETE   UDIUInt32 To; */
/* OBSOLETE   UDICount Count = 1; */
/* OBSOLETE   UDISizeT Size = 4; */
/* OBSOLETE   UDICount CountDone; */
/* OBSOLETE   UDIBool HostEndian = 0; */
/* OBSOLETE   UDIError err; */
/* OBSOLETE   int result; */
/* OBSOLETE  */
/* OBSOLETE   if (regno == GR1_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       From.Space = UDI29KGlobalRegs; */
/* OBSOLETE       From.Offset = 1; */
/* OBSOLETE     } */
/* OBSOLETE   else if (regno >= GR96_REGNUM && regno < GR96_REGNUM + 32) */
/* OBSOLETE     { */
/* OBSOLETE       From.Space = UDI29KGlobalRegs; */
/* OBSOLETE       From.Offset = (regno - GR96_REGNUM) + 96;; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE #if defined(GR64_REGNUM) */
/* OBSOLETE  */
/* OBSOLETE   else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32) */
/* OBSOLETE     { */
/* OBSOLETE       From.Space = UDI29KGlobalRegs; */
/* OBSOLETE       From.Offset = (regno - GR64_REGNUM) + 64; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE #endif /* GR64_REGNUM */ */
/* OBSOLETE  */
/* OBSOLETE   else if (regno >= LR0_REGNUM && regno < LR0_REGNUM + 128) */
/* OBSOLETE     { */
/* OBSOLETE       From.Space = UDI29KLocalRegs; */
/* OBSOLETE       From.Offset = (regno - LR0_REGNUM); */
/* OBSOLETE     } */
/* OBSOLETE   else if (regno >= FPE_REGNUM && regno <= EXO_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       int val = -1; */
/* OBSOLETE       /*supply_register(160 + (regno - FPE_REGNUM),(char *) &val); */ */
/* OBSOLETE       supply_register (regno, (char *) &val); */
/* OBSOLETE       return;			/* Pretend Success */ */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       From.Space = UDI29KSpecialRegs; */
/* OBSOLETE       From.Offset = regnum_to_srnum (regno); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   if (err = UDIRead (From, &To, Count, Size, &CountDone, HostEndian)) */
/* OBSOLETE     error ("UDIRead() failed in udi_fetch_registers"); */
/* OBSOLETE  */
/* OBSOLETE   supply_register (regno, (char *) &To); */
/* OBSOLETE  */
/* OBSOLETE   if (remote_debug) */
/* OBSOLETE     fprintf_unfiltered (gdb_stdlog, "Fetching register %s = 0x%x\n", */
/* OBSOLETE 			REGISTER_NAME (regno), To); */
/* OBSOLETE } */
/* OBSOLETE /*****************************************************************************/ */
/* OBSOLETE /* Store a single register indicated by 'regno'.  */
/* OBSOLETE  * Returns 0/-1 on success/failure.   */
/* OBSOLETE  */ */
/* OBSOLETE static int */
/* OBSOLETE store_register (int regno) */
/* OBSOLETE { */
/* OBSOLETE   int result; */
/* OBSOLETE   UDIUInt32 From; */
/* OBSOLETE   UDIResource To; */
/* OBSOLETE   UDICount Count = 1; */
/* OBSOLETE   UDISizeT Size = 4; */
/* OBSOLETE   UDICount CountDone; */
/* OBSOLETE   UDIBool HostEndian = 0; */
/* OBSOLETE  */
/* OBSOLETE   From = read_register (regno);	/* get data value */ */
/* OBSOLETE  */
/* OBSOLETE   if (remote_debug) */
/* OBSOLETE     fprintf_unfiltered (gdb_stdlog, "Storing register %s = 0x%x\n", */
/* OBSOLETE 			REGISTER_NAME (regno), From); */
/* OBSOLETE  */
/* OBSOLETE   if (regno == GR1_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       To.Space = UDI29KGlobalRegs; */
/* OBSOLETE       To.Offset = 1; */
/* OBSOLETE       result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian); */
/* OBSOLETE       /* Setting GR1 changes the numbers of all the locals, so invalidate the  */
/* OBSOLETE        * register cache.  Do this *after* calling read_register, because we want  */
/* OBSOLETE        * read_register to return the value that write_register has just stuffed  */
/* OBSOLETE        * into the registers array, not the value of the register fetched from  */
/* OBSOLETE        * the inferior.   */
/* OBSOLETE        */ */
/* OBSOLETE       registers_changed (); */
/* OBSOLETE     } */
/* OBSOLETE #if defined(GR64_REGNUM) */
/* OBSOLETE   else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32) */
/* OBSOLETE     { */
/* OBSOLETE       To.Space = UDI29KGlobalRegs; */
/* OBSOLETE       To.Offset = (regno - GR64_REGNUM) + 64; */
/* OBSOLETE       result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian); */
/* OBSOLETE     } */
/* OBSOLETE #endif /* GR64_REGNUM */ */
/* OBSOLETE   else if (regno >= GR96_REGNUM && regno < GR96_REGNUM + 32) */
/* OBSOLETE     { */
/* OBSOLETE       To.Space = UDI29KGlobalRegs; */
/* OBSOLETE       To.Offset = (regno - GR96_REGNUM) + 96; */
/* OBSOLETE       result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian); */
/* OBSOLETE     } */
/* OBSOLETE   else if (regno >= LR0_REGNUM && regno < LR0_REGNUM + 128) */
/* OBSOLETE     { */
/* OBSOLETE       To.Space = UDI29KLocalRegs; */
/* OBSOLETE       To.Offset = (regno - LR0_REGNUM); */
/* OBSOLETE       result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian); */
/* OBSOLETE     } */
/* OBSOLETE   else if (regno >= FPE_REGNUM && regno <= EXO_REGNUM) */
/* OBSOLETE     return 0;			/* Pretend Success */ */
/* OBSOLETE   else if (regno == PC_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       /* PC1 via UDI29KPC */ */
/* OBSOLETE  */
/* OBSOLETE       To.Space = UDI29KPC; */
/* OBSOLETE       To.Offset = 0;		/* PC1 */ */
/* OBSOLETE       result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian); */
/* OBSOLETE  */
/* OBSOLETE       /* Writing to this loc actually changes the values of pc0 & pc1 */ */
/* OBSOLETE  */
/* OBSOLETE       register_valid[PC_REGNUM] = 0;	/* pc1 */ */
/* OBSOLETE       register_valid[NPC_REGNUM] = 0;	/* pc0 */ */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     /* An unprotected or protected special register */ */
/* OBSOLETE     { */
/* OBSOLETE       To.Space = UDI29KSpecialRegs; */
/* OBSOLETE       To.Offset = regnum_to_srnum (regno); */
/* OBSOLETE       result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   if (result != 0) */
/* OBSOLETE     error ("UDIWrite() failed in store_registers"); */
/* OBSOLETE  */
/* OBSOLETE   return 0; */
/* OBSOLETE } */
/* OBSOLETE /********************************************************** REGNUM_TO_SRNUM */ */
/* OBSOLETE /*  */
/* OBSOLETE  * Convert a gdb special register number to a 29000 special register number. */
/* OBSOLETE  */ */
/* OBSOLETE static int */
/* OBSOLETE regnum_to_srnum (int regno) */
/* OBSOLETE { */
/* OBSOLETE   switch (regno) */
/* OBSOLETE     { */
/* OBSOLETE     case VAB_REGNUM: */
/* OBSOLETE       return (0); */
/* OBSOLETE     case OPS_REGNUM: */
/* OBSOLETE       return (1); */
/* OBSOLETE     case CPS_REGNUM: */
/* OBSOLETE       return (2); */
/* OBSOLETE     case CFG_REGNUM: */
/* OBSOLETE       return (3); */
/* OBSOLETE     case CHA_REGNUM: */
/* OBSOLETE       return (4); */
/* OBSOLETE     case CHD_REGNUM: */
/* OBSOLETE       return (5); */
/* OBSOLETE     case CHC_REGNUM: */
/* OBSOLETE       return (6); */
/* OBSOLETE     case RBP_REGNUM: */
/* OBSOLETE       return (7); */
/* OBSOLETE     case TMC_REGNUM: */
/* OBSOLETE       return (8); */
/* OBSOLETE     case TMR_REGNUM: */
/* OBSOLETE       return (9); */
/* OBSOLETE     case NPC_REGNUM: */
/* OBSOLETE       return (USE_SHADOW_PC ? (20) : (10)); */
/* OBSOLETE     case PC_REGNUM: */
/* OBSOLETE       return (USE_SHADOW_PC ? (21) : (11)); */
/* OBSOLETE     case PC2_REGNUM: */
/* OBSOLETE       return (USE_SHADOW_PC ? (22) : (12)); */
/* OBSOLETE     case MMU_REGNUM: */
/* OBSOLETE       return (13); */
/* OBSOLETE     case LRU_REGNUM: */
/* OBSOLETE       return (14); */
/* OBSOLETE     case IPC_REGNUM: */
/* OBSOLETE       return (128); */
/* OBSOLETE     case IPA_REGNUM: */
/* OBSOLETE       return (129); */
/* OBSOLETE     case IPB_REGNUM: */
/* OBSOLETE       return (130); */
/* OBSOLETE     case Q_REGNUM: */
/* OBSOLETE       return (131); */
/* OBSOLETE     case ALU_REGNUM: */
/* OBSOLETE       return (132); */
/* OBSOLETE     case BP_REGNUM: */
/* OBSOLETE       return (133); */
/* OBSOLETE     case FC_REGNUM: */
/* OBSOLETE       return (134); */
/* OBSOLETE     case CR_REGNUM: */
/* OBSOLETE       return (135); */
/* OBSOLETE     case FPE_REGNUM: */
/* OBSOLETE       return (160); */
/* OBSOLETE     case INTE_REGNUM: */
/* OBSOLETE       return (161); */
/* OBSOLETE     case FPS_REGNUM: */
/* OBSOLETE       return (162); */
/* OBSOLETE     case EXO_REGNUM: */
/* OBSOLETE       return (164); */
/* OBSOLETE     default: */
/* OBSOLETE       return (255);		/* Failure ? */ */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE /****************************************************************************/ */
/* OBSOLETE /* */
/* OBSOLETE  * Determine the Target memory space qualifier based on the addr.  */
/* OBSOLETE  * FIXME: Can't distinguis I_ROM/D_ROM.   */
/* OBSOLETE  * FIXME: Doesn't know anything about I_CACHE/D_CACHE. */
/* OBSOLETE  */ */
/* OBSOLETE static CPUSpace */
/* OBSOLETE udi_memory_space (CORE_ADDR addr) */
/* OBSOLETE { */
/* OBSOLETE   UDIUInt32 tstart = IMemStart; */
/* OBSOLETE   UDIUInt32 tend = tstart + IMemSize; */
/* OBSOLETE   UDIUInt32 dstart = DMemStart; */
/* OBSOLETE   UDIUInt32 dend = tstart + DMemSize; */
/* OBSOLETE   UDIUInt32 rstart = RMemStart; */
/* OBSOLETE   UDIUInt32 rend = tstart + RMemSize; */
/* OBSOLETE  */
/* OBSOLETE   if (((UDIUInt32) addr >= tstart) && ((UDIUInt32) addr < tend)) */
/* OBSOLETE     { */
/* OBSOLETE       return UDI29KIRAMSpace; */
/* OBSOLETE     } */
/* OBSOLETE   else if (((UDIUInt32) addr >= dstart) && ((UDIUInt32) addr < dend)) */
/* OBSOLETE     { */
/* OBSOLETE       return UDI29KDRAMSpace; */
/* OBSOLETE     } */
/* OBSOLETE   else if (((UDIUInt32) addr >= rstart) && ((UDIUInt32) addr < rend)) */
/* OBSOLETE     { */
/* OBSOLETE       /* FIXME: how do we determine between D_ROM and I_ROM */ */
/* OBSOLETE       return UDI29KIROMSpace; */
/* OBSOLETE     } */
/* OBSOLETE   else				/* FIXME: what do me do now? */ */
/* OBSOLETE     return UDI29KDRAMSpace;	/* Hmmm! */ */
/* OBSOLETE } */
/* OBSOLETE /*********************************************************************** STUBS */
/* OBSOLETE */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE convert16 (void) */
/* OBSOLETE {; */
/* OBSOLETE } */
/* OBSOLETE void */
/* OBSOLETE convert32 (void) */
/* OBSOLETE {; */
/* OBSOLETE } */
/* OBSOLETE struct ui_file *EchoFile = 0;	/* used for debugging */ */
/* OBSOLETE int QuietMode = 0;		/* used for debugging */ */
/* OBSOLETE  */
/* OBSOLETE #ifdef NO_HIF_SUPPORT */
/* OBSOLETE service_HIF (union msg_t *msg) */
/* OBSOLETE { */
/* OBSOLETE   return (0);			/* Emulate a failure */ */
/* OBSOLETE } */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE /* Target_ops vector.  Not static because there does not seem to be */
/* OBSOLETE    any portable way to do a forward declaration of a static variable. */
/* OBSOLETE    The RS/6000 doesn't like "extern" followed by "static"; SunOS */
/* OBSOLETE    /bin/cc doesn't like "static" twice.  */ */
/* OBSOLETE  */
/* OBSOLETE struct target_ops udi_ops; */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE init_udi_ops (void) */
/* OBSOLETE { */
/* OBSOLETE   udi_ops.to_shortname = "udi"; */
/* OBSOLETE   udi_ops.to_longname = "Remote UDI connected TIP"; */
/* OBSOLETE   udi_ops.to_doc = "Remote debug an AMD 29k using UDI socket connection to TIP process.\n\ */
/* OBSOLETE Arguments are\n\ */
/* OBSOLETE `configuration-id AF_INET hostname port-number'\n\ */
/* OBSOLETE To connect via the network, where hostname and port-number specify the\n\ */
/* OBSOLETE host and port where you can connect via UDI.\n\ */
/* OBSOLETE configuration-id is unused.\n\ */
/* OBSOLETE \n\ */
/* OBSOLETE `configuration-id AF_UNIX socket-name tip-program'\n\ */
/* OBSOLETE To connect using a local connection to the \"tip.exe\" program which is\n\ */
/* OBSOLETE     supplied by AMD.  If socket-name specifies an AF_UNIX socket then the\n\ */
/* OBSOLETE     tip program must already be started; connect to it using that socket.\n\ */
/* OBSOLETE     If not, start up tip-program, which should be the name of the tip\n\ */
/* OBSOLETE     program.  If appropriate, the PATH environment variable is searched.\n\ */
/* OBSOLETE     configuration-id is unused.\n\ */
/* OBSOLETE \n\ */
/* OBSOLETE `configuration-id'\n\ */
/* OBSOLETE     Look up the configuration in ./udi_soc or /etc/udi_soc, which\n\ */
/* OBSOLETE     are files containing lines in the above formats.  configuration-id is\n\ */
/* OBSOLETE     used to pick which line of the file to use."; */
/* OBSOLETE   udi_ops.to_open = udi_open; */
/* OBSOLETE   udi_ops.to_close = udi_close; */
/* OBSOLETE   udi_ops.to_attach = udi_attach; */
/* OBSOLETE   udi_ops.to_detach = udi_detach; */
/* OBSOLETE   udi_ops.to_resume = udi_resume; */
/* OBSOLETE   udi_ops.to_wait = udi_wait; */
/* OBSOLETE   udi_ops.to_fetch_registers = udi_fetch_registers; */
/* OBSOLETE   udi_ops.to_store_registers = udi_store_registers; */
/* OBSOLETE   udi_ops.to_prepare_to_store = udi_prepare_to_store; */
/* OBSOLETE   udi_ops.to_xfer_memory = udi_xfer_inferior_memory; */
/* OBSOLETE   udi_ops.to_files_info = udi_files_info; */
/* OBSOLETE   udi_ops.to_insert_breakpoint = udi_insert_breakpoint; */
/* OBSOLETE   udi_ops.to_remove_breakpoint = udi_remove_breakpoint; */
/* OBSOLETE   udi_ops.to_terminal_init = 0; */
/* OBSOLETE   udi_ops.to_terminal_inferior = 0; */
/* OBSOLETE   udi_ops.to_terminal_ours_for_output = 0; */
/* OBSOLETE   udi_ops.to_terminal_ours = 0; */
/* OBSOLETE   udi_ops.to_terminal_info = 0; */
/* OBSOLETE   udi_ops.to_kill = udi_kill; */
/* OBSOLETE   udi_ops.to_load = udi_load; */
/* OBSOLETE   udi_ops.to_lookup_symbol = 0; */
/* OBSOLETE   udi_ops.to_create_inferior = udi_create_inferior; */
/* OBSOLETE   udi_ops.to_mourn_inferior = udi_mourn; */
/* OBSOLETE   udi_ops.to_can_run = 0; */
/* OBSOLETE   udi_ops.to_notice_signals = 0; */
/* OBSOLETE   udi_ops.to_thread_alive = 0; */
/* OBSOLETE   udi_ops.to_stop = 0; */
/* OBSOLETE   udi_ops.to_stratum = process_stratum; */
/* OBSOLETE   udi_ops.DONT_USE = 0; */
/* OBSOLETE   udi_ops.to_has_all_memory = 1; */
/* OBSOLETE   udi_ops.to_has_memory = 1; */
/* OBSOLETE   udi_ops.to_has_stack = 1; */
/* OBSOLETE   udi_ops.to_has_registers = 1; */
/* OBSOLETE   udi_ops.to_has_execution = 1; */
/* OBSOLETE   udi_ops.to_sections = 0; */
/* OBSOLETE   udi_ops.to_sections_end = 0; */
/* OBSOLETE   udi_ops.to_magic = OPS_MAGIC; */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE _initialize_remote_udi (void) */
/* OBSOLETE { */
/* OBSOLETE   init_udi_ops (); */
/* OBSOLETE   add_target (&udi_ops); */
/* OBSOLETE } */
@


1.17
log
@* MAINTAINERS: Mark a29k target as obsolete.
* Makefile.in (a29k-tdep.o, remote-adapt.o, remote-eb.o)
(remote-mm.o, remote-udi.o): Obsolete.  Remove references in
comments.
* NEWS: Note that a29k targets are obsolete.
* a29k-tdep.c: Mark as obsolete.
* configure.tgt: Mark a29k-*-aout*, a29k-*-coff*, a29k-*-elf*,
a29k-*-ebmon*, a29k-*-kern*, a29k-*-none*, a29k-*-udi* and
a29k-*-vxworks* targets as obsolete.
* remote-adapt.c: Obsolete.
* remote-eb.c: Obsolete.
* remote-mm.c: Obsolete.
* remote-udi.c: Obsolete.
* config/a29k/a29k-udi.mt: Obsolete.
* config/a29k/a29k.mt: Obsolete.
* config/a29k/tm-a29k.h: Obsolete.
* config/a29k/tm-vx29k.h: Obsolete.
* config/a29k/vx29k.mt: Obsolete.
@
text
@@


1.16
log
@* remote-udi.c (udi_wait): Make type, instead of name, of first
parameter a ptid_t.
@
text
@d1 1722
a1722 1722
/* Remote debugging interface for AMD 29k interfaced via UDI, for GDB.
   Copyright 1990, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
   Written by Daniel Mann.  Contributed by AMD.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* This is like remote.c but uses the Universal Debug Interface (UDI) to 
   talk to the target hardware (or simulator).  UDI is a TCP/IP based
   protocol; for hardware that doesn't run TCP, an interface adapter 
   daemon talks UDI on one side, and talks to the hardware (typically
   over a serial port) on the other side.

   - Originally written by Daniel Mann at AMD for MiniMON and gdb 3.91.6.
   - David Wood (wood@@lab.ultra.nyu.edu) at New York University adapted this
   file to gdb 3.95.  I was unable to get this working on sun3os4
   with termio, only with sgtty.
   - Daniel Mann at AMD took the 3.95 adaptions above and replaced
   MiniMON interface with UDI-p interface.        */

#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "value.h"
#include <ctype.h>
#include <fcntl.h>
#include <errno.h>
#include "gdb_string.h"
#include "terminal.h"
#include "target.h"
#include "29k-share/udi/udiproc.h"
#include "gdbcmd.h"
#include "bfd.h"
#include "gdbcore.h"		/* For download function */
#include "regcache.h"

/* access the register store directly, without going through
   the normal handler functions. This avoids an extra data copy.  */

extern int stop_soon_quietly;	/* for wait_for_inferior */
extern struct value *call_function_by_hand ();
static void udi_resume (ptid_t ptid, int step, enum target_signal sig);
static void udi_fetch_registers (int regno);
static void udi_load (char *args, int from_tty);
static void fetch_register (int regno);
static void udi_store_registers (int regno);
static int store_register (int regno);
static int regnum_to_srnum (int regno);
static void udi_close (int quitting);
static CPUSpace udi_memory_space (CORE_ADDR addr);
static int udi_write_inferior_memory (CORE_ADDR memaddr, char *myaddr,
				      int len);
static int udi_read_inferior_memory (CORE_ADDR memaddr, char *myaddr,
				     int len);
static void download (char *load_arg_string, int from_tty);
char CoffFileName[100] = "";

#define FREEZE_MODE     (read_register(CPS_REGNUM) & 0x400)
#define USE_SHADOW_PC	((processor_type == a29k_freeze_mode) && FREEZE_MODE)

static int timeout = 5;
extern struct target_ops udi_ops;	/* Forward declaration */

/* Special register enumeration.
 */

/******************************************************************* UDI DATA*/
#define	MAXDATA		2*1024	/* max UDI[read/write] byte size */
/* Descriptor for I/O to remote machine.  Initialize it to -1 so that
   udi_open knows that we don't have a file open when the program
   starts.  */

UDISessionId udi_session_id = -1;
static char *udi_config_id;

CPUOffset IMemStart = 0;
CPUSizeT IMemSize = 0;
CPUOffset DMemStart = 0;
CPUSizeT DMemSize = 0;
CPUOffset RMemStart = 0;
CPUSizeT RMemSize = 0;
UDIUInt32 CPUPRL;
UDIUInt32 CoProcPRL;

UDIMemoryRange address_ranges[2];	/* Text and data */
UDIResource entry =
{0, 0};				/* Entry point */
CPUSizeT stack_sizes[2];	/* Regular and memory stacks */

#define	SBUF_MAX	1024	/* maximum size of string handling buffer */
char sbuf[SBUF_MAX];

typedef struct bkpt_entry_str
  {
    UDIResource Addr;
    UDIUInt32 PassCount;
    UDIBreakType Type;
    unsigned int BreakId;
  }
bkpt_entry_t;
#define		BKPT_TABLE_SIZE 40
static bkpt_entry_t bkpt_table[BKPT_TABLE_SIZE];
extern char dfe_errmsg[];	/* error string */

/* malloc'd name of the program on the remote system.  */
static char *prog_name = NULL;

/* This is called not only when we first attach, but also when the
   user types "run" after having attached.  */

static void
udi_create_inferior (char *execfile, char *args, char **env)
{
  char *args1;

  if (execfile)
    {
      if (prog_name != NULL)
	xfree (prog_name);
      prog_name = savestring (execfile, strlen (execfile));
    }
  else if (entry.Offset)
    execfile = "";
  else
    error ("No image loaded into target.");

  if (udi_session_id < 0)
    {
      /* If the TIP is not open, open it.  */
      if (UDIConnect (udi_config_id, &udi_session_id))
	error ("UDIConnect() failed: %s\n", dfe_errmsg);
      /* We will need to download the program.  */
      entry.Offset = 0;
    }

  inferior_ptid = pid_to_ptid (40000);

  if (!entry.Offset)
    download (execfile, 0);

  args1 = alloca (strlen (execfile) + strlen (args) + 2);

  if (execfile[0] == '\0')

    /* It is empty.  We need to quote it somehow, or else the target
       will think there is no argument being passed here.  According
       to the UDI spec it is quoted "according to TIP OS rules" which
       I guess means quoting it like the Unix shell should work
       (sounds pretty bogus to me...).  In fact it doesn't work (with
       isstip anyway), but passing in two quotes as the argument seems
       like a reasonable enough behavior anyway (I guess).  */

    strcpy (args1, "''");
  else
    strcpy (args1, execfile);
  strcat (args1, " ");
  strcat (args1, args);

  UDIInitializeProcess (address_ranges,		/* ProcessMemory[] */
			(UDIInt) 2,	/* NumberOfRanges */
			entry,	/* EntryPoint */
			stack_sizes,	/* *StackSizes */
			(UDIInt) 2,	/* NumberOfStacks */
			args1);	/* ArgString */

  init_wait_for_inferior ();
  clear_proceed_status ();
  proceed (-1, TARGET_SIGNAL_DEFAULT, 0);
}

static void
udi_mourn (void)
{
#if 0
  /* Requiring "target udi" each time you run is a major pain.  I suspect
     this was just blindy copied from remote.c, in which "target" and
     "run" are combined.  Having a udi target without an inferior seems
     to work between "target udi" and "run", so why not now?  */
  pop_target ();		/* Pop back to no-child state */
#endif
  /* But if we're going to want to run it again, we better remove the
     breakpoints...  */
  remove_breakpoints ();
  generic_mourn_inferior ();
}

/******************************************************************** UDI_OPEN
** Open a connection to remote TIP.
   NAME is the socket domain used for communication with the TIP,
   then a space and the socket name or TIP-host name.
   '<udi_udi_config_id>' for example.
 */

/* XXX - need cleanups for udiconnect for various failures!!! */

static void
udi_open (char *name, int from_tty)
{
  unsigned int prl;
  char *p;
  int cnt;
  UDIMemoryRange KnownMemory[10];
  UDIUInt32 ChipVersions[10];
  UDIInt NumberOfRanges = 10;
  UDIInt NumberOfChips = 10;
  UDIPId PId;
  UDIUInt32 TIPId, TargetId, DFEId, DFE, TIP, DFEIPCId, TIPIPCId;

  target_preopen (from_tty);

  entry.Offset = 0;

  for (cnt = 0; cnt < BKPT_TABLE_SIZE; cnt++)
    bkpt_table[cnt].Type = 0;

  if (udi_config_id)
    xfree (udi_config_id);

  if (!name)
    error ("Usage: target udi config_id, where config_id appears in udi_soc file");

  udi_config_id = xstrdup (strtok (name, " \t"));

  if (UDIConnect (udi_config_id, &udi_session_id))
    /* FIXME: Should set udi_session_id to -1 here.  */
    error ("UDIConnect() failed: %s\n", dfe_errmsg);

  push_target (&udi_ops);

  /*
     ** Initialize target configuration structure (global)
   */
  if (UDIGetTargetConfig (KnownMemory, &NumberOfRanges,
			  ChipVersions, &NumberOfChips))
    error ("UDIGetTargetConfig() failed");
  if (NumberOfChips > 2)
    fprintf_unfiltered (gdb_stderr, "Target has more than one processor\n");
  for (cnt = 0; cnt < NumberOfRanges; cnt++)
    {
      switch (KnownMemory[cnt].Space)
	{
	default:
	  fprintf_unfiltered (gdb_stderr, "UDIGetTargetConfig() unknown memory space\n");
	  break;
	case UDI29KCP_S:
	  break;
	case UDI29KIROMSpace:
	  RMemStart = KnownMemory[cnt].Offset;
	  RMemSize = KnownMemory[cnt].Size;
	  break;
	case UDI29KIRAMSpace:
	  IMemStart = KnownMemory[cnt].Offset;
	  IMemSize = KnownMemory[cnt].Size;
	  break;
	case UDI29KDRAMSpace:
	  DMemStart = KnownMemory[cnt].Offset;
	  DMemSize = KnownMemory[cnt].Size;
	  break;
	}
    }

  a29k_get_processor_type ();

  if (UDICreateProcess (&PId))
    fprintf_unfiltered (gdb_stderr, "UDICreateProcess() failed\n");

  /* Print out some stuff, letting the user now what's going on */
  if (UDICapabilities (&TIPId, &TargetId, DFEId, DFE, &TIP, &DFEIPCId,
		       &TIPIPCId, sbuf))
    error ("UDICapabilities() failed");
  if (from_tty)
    {
      printf_filtered ("Connected via UDI socket,\n\
 DFE-IPC version %x.%x.%x  TIP-IPC version %x.%x.%x  TIP version %x.%x.%x\n %s\n",
	       (DFEIPCId >> 8) & 0xf, (DFEIPCId >> 4) & 0xf, DFEIPCId & 0xf,
	       (TIPIPCId >> 8) & 0xf, (TIPIPCId >> 4) & 0xf, TIPIPCId & 0xf,
	       (TargetId >> 8) & 0xf, (TargetId >> 4) & 0xf, TargetId & 0xf,
		       sbuf);
    }
}

/******************************************************************* UDI_CLOSE
   Close the open connection to the TIP process.
   Use this when you want to detach and do something else
   with your gdb.  */
static void
udi_close (			/*FIXME: how is quitting used */
	    int quitting)
{
  if (udi_session_id < 0)
    return;

  /* We should never get here if there isn't something valid in
     udi_session_id.  */

  if (UDIDisconnect (udi_session_id, UDITerminateSession))
    {
      if (quitting)
	warning ("UDIDisconnect() failed in udi_close");
      else
	error ("UDIDisconnect() failed in udi_close");
    }

  /* Do not try to close udi_session_id again, later in the program.  */
  udi_session_id = -1;
  inferior_ptid = null_ptid;

  printf_filtered ("  Ending remote debugging\n");
}

/**************************************************************** UDI_ATACH */
/* Attach to a program that is already loaded and running 
 * Upon exiting the process's execution is stopped.
 */
static void
udi_attach (char *args, int from_tty)
{
  UDIResource From;
  UDIInt32 PC_adds;
  UDICount Count = 1;
  UDISizeT Size = 4;
  UDICount CountDone;
  UDIBool HostEndian = 0;
  UDIError err;

  if (args == NULL)
    error_no_arg ("program to attach");

  if (udi_session_id < 0)
    error ("UDI connection not opened yet, use the 'target udi' command.\n");

  if (from_tty)
    printf_unfiltered ("Attaching to remote program %s...\n", prog_name);

  UDIStop ();
  From.Space = UDI29KSpecialRegs;
  From.Offset = 11;
  if (err = UDIRead (From, &PC_adds, Count, Size, &CountDone, HostEndian))
    error ("UDIRead failed in udi_attach");
  printf_unfiltered ("Remote process is now halted, pc1 = 0x%x.\n", PC_adds);
}
/************************************************************* UDI_DETACH */
/* Terminate the open connection to the TIP process.
   Use this when you want to detach and do something else
   with your gdb.  Leave remote process running (with no breakpoints set). */
static void
udi_detach (char *args, int from_tty)
{

  remove_breakpoints ();	/* Just in case there were any left in */

  if (UDIDisconnect (udi_session_id, UDIContinueSession))
    error ("UDIDisconnect() failed in udi_detach");

  /* Don't try to UDIDisconnect it again in udi_close, which is called from
     pop_target.  */
  udi_session_id = -1;
  inferior_ptid = null_ptid;

  pop_target ();

  if (from_tty)
    printf_unfiltered ("Detaching from TIP\n");
}


/****************************************************************** UDI_RESUME
** Tell the remote machine to resume.  */

static void
udi_resume (ptid_t ptid, int step, enum target_signal sig)
{
  UDIError tip_error;
  UDIUInt32 Steps = 1;
  UDIStepType StepType = UDIStepNatural;
  UDIRange Range;

  if (step)			/* step 1 instruction */
    {
      tip_error = UDIStep (Steps, StepType, Range);
      if (!tip_error)
	return;

      fprintf_unfiltered (gdb_stderr, "UDIStep() error = %d\n", tip_error);
      error ("failed in udi_resume");
    }

  if (UDIExecute ())
    error ("UDIExecute() failed in udi_resume");
}

/******************************************************************** UDI_WAIT
** Wait until the remote machine stops, then return,
   storing status in STATUS just as `wait' would.  */

static ptid_t
udi_wait (ptid_t ptid, struct target_waitstatus *status)
{
  UDIInt32 MaxTime;
  UDIPId PId;
  UDIInt32 StopReason;
  UDISizeT CountDone;
  int old_timeout = timeout;
  int old_immediate_quit = immediate_quit;
  int i;

  status->kind = TARGET_WAITKIND_EXITED;
  status->value.integer = 0;

/* wait for message to arrive. It should be:
   If the target stops executing, udi_wait() should return.
 */
  timeout = 0;			/* Wait indefinetly for a message */
  immediate_quit = 1;		/* Helps ability to QUIT */

  while (1)
    {
      i = 0;
      MaxTime = UDIWaitForever;
      UDIWait (MaxTime, &PId, &StopReason);
      QUIT;			/* Let user quit if they want */

      switch (StopReason & UDIGrossState)
	{
	case UDIStdoutReady:
	  if (UDIGetStdout (sbuf, (UDISizeT) SBUF_MAX, &CountDone))
	    /* This is said to happen if the program tries to output
	       a whole bunch of output (more than SBUF_MAX, I would
	       guess).  It doesn't seem to happen with the simulator.  */
	    warning ("UDIGetStdout() failed in udi_wait");
	  fwrite (sbuf, 1, CountDone, stdout);
	  gdb_flush (gdb_stdout);
	  continue;

	case UDIStderrReady:
	  UDIGetStderr (sbuf, (UDISizeT) SBUF_MAX, &CountDone);
	  fwrite (sbuf, 1, CountDone, stderr);
	  gdb_flush (gdb_stderr);
	  continue;

	case UDIStdinNeeded:
	  {
	    int ch;
	    i = 0;
	    do
	      {
		ch = getchar ();
		if (ch == EOF)
		  break;
		sbuf[i++] = ch;
	      }
	    while (i < SBUF_MAX && ch != '\n');
	    UDIPutStdin (sbuf, (UDISizeT) i, &CountDone);
	    continue;
	  }

	case UDIRunning:
	  /* In spite of the fact that we told UDIWait to wait forever, it will
	     return spuriously sometimes.  */
	case UDIStdinModeX:
	  continue;
	default:
	  break;
	}
      break;
    }

  switch (StopReason & UDIGrossState)
    {
    case UDITrapped:
      printf_unfiltered ("Am290*0 received vector number %d\n", StopReason >> 24);

      switch ((StopReason >> 8) & 0xff)
	{
	case 0:		/* Illegal opcode */
	  printf_unfiltered ("	(break point)\n");
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_TRAP;
	  break;
	case 1:		/* Unaligned Access */
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_BUS;
	  break;
	case 3:
	case 4:
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_FPE;
	  break;
	case 5:		/* Protection Violation */
	  status->kind = TARGET_WAITKIND_STOPPED;
	  /* Why not SEGV?  What is a Protection Violation?  */
	  status->value.sig = TARGET_SIGNAL_ILL;
	  break;
	case 6:
	case 7:
	case 8:		/* User Instruction Mapping Miss */
	case 9:		/* User Data Mapping Miss */
	case 10:		/* Supervisor Instruction Mapping Miss */
	case 11:		/* Supervisor Data Mapping Miss */
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_SEGV;
	  break;
	case 12:
	case 13:
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_ILL;
	  break;
	case 14:		/* Timer */
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_ALRM;
	  break;
	case 15:		/* Trace */
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_TRAP;
	  break;
	case 16:		/* INTR0 */
	case 17:		/* INTR1 */
	case 18:		/* INTR2 */
	case 19:		/* INTR3/Internal */
	case 20:		/* TRAP0 */
	case 21:		/* TRAP1 */
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_INT;
	  break;
	case 22:		/* Floating-Point Exception */
	  status->kind = TARGET_WAITKIND_STOPPED;
	  /* Why not FPE?  */
	  status->value.sig = TARGET_SIGNAL_ILL;
	  break;
	case 77:		/* assert 77 */
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_TRAP;
	  break;
	default:
	  status->kind = TARGET_WAITKIND_EXITED;
	  status->value.integer = 0;
	}
      break;
    case UDINotExecuting:
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_TERM;
      break;
    case UDIStopped:
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_TSTP;
      break;
    case UDIWarned:
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_URG;
      break;
    case UDIStepped:
    case UDIBreak:
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_TRAP;
      break;
    case UDIWaiting:
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_STOP;
      break;
    case UDIHalted:
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_KILL;
      break;
    case UDIExited:
    default:
      status->kind = TARGET_WAITKIND_EXITED;
      status->value.integer = 0;
    }

  timeout = old_timeout;	/* Restore original timeout value */
  immediate_quit = old_immediate_quit;
  return inferior_ptid;
}

#if 0
/* Handy for debugging */
udi_pc (void)
{
  UDIResource From;
  UDIUInt32 *To;
  UDICount Count;
  UDISizeT Size = 4;
  UDICount CountDone;
  UDIBool HostEndian = 0;
  UDIError err;
  int pc[2];
  unsigned long myregs[256];
  int i;

  From.Space = UDI29KPC;
  From.Offset = 0;
  To = (UDIUInt32 *) pc;
  Count = 2;

  err = UDIRead (From, To, Count, Size, &CountDone, HostEndian);

  printf_unfiltered ("err = %d, CountDone = %d, pc[0] = 0x%x, pc[1] = 0x%x\n",
		     err, CountDone, pc[0], pc[1]);

  udi_fetch_registers (-1);

  printf_unfiltered ("other pc1 = 0x%x, pc0 = 0x%x\n", *(int *) &registers[4 * PC_REGNUM],
		     *(int *) &registers[4 * NPC_REGNUM]);

  /* Now, read all the registers globally */

  From.Space = UDI29KGlobalRegs;
  From.Offset = 0;
  err = UDIRead (From, myregs, 256, 4, &CountDone, HostEndian);

  printf ("err = %d, CountDone = %d\n", err, CountDone);

  printf ("\n");

  for (i = 0; i < 256; i += 2)
    printf ("%d:\t%#10x\t%11d\t%#10x\t%11d\n", i, myregs[i], myregs[i],
	    myregs[i + 1], myregs[i + 1]);
  printf ("\n");

  return pc[0];
}
#endif

/********************************************************** UDI_FETCH_REGISTERS
 * Read a remote register 'regno'. 
 * If regno==-1 then read all the registers.
 */
static void
udi_fetch_registers (int regno)
{
  UDIResource From;
  UDIUInt32 *To;
  UDICount Count;
  UDISizeT Size = 4;
  UDICount CountDone;
  UDIBool HostEndian = 0;
  UDIError err;
  int i;

  if (regno >= 0)
    {
      fetch_register (regno);
      return;
    }

/* Gr1/rsp */

  From.Space = UDI29KGlobalRegs;
  From.Offset = 1;
  To = (UDIUInt32 *) & registers[4 * GR1_REGNUM];
  Count = 1;
  if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIRead() failed in udi_fetch_registers");

  register_valid[GR1_REGNUM] = 1;

#if defined(GR64_REGNUM)	/* Read gr64-127 */

/* Global Registers gr64-gr95 */

  From.Space = UDI29KGlobalRegs;
  From.Offset = 64;
  To = (UDIUInt32 *) & registers[4 * GR64_REGNUM];
  Count = 32;
  if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIRead() failed in udi_fetch_registers");

  for (i = GR64_REGNUM; i < GR64_REGNUM + 32; i++)
    register_valid[i] = 1;

#endif /*  GR64_REGNUM */

/* Global Registers gr96-gr127 */

  From.Space = UDI29KGlobalRegs;
  From.Offset = 96;
  To = (UDIUInt32 *) & registers[4 * GR96_REGNUM];
  Count = 32;
  if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIRead() failed in udi_fetch_registers");

  for (i = GR96_REGNUM; i < GR96_REGNUM + 32; i++)
    register_valid[i] = 1;

/* Local Registers */

  From.Space = UDI29KLocalRegs;
  From.Offset = 0;
  To = (UDIUInt32 *) & registers[4 * LR0_REGNUM];
  Count = 128;
  if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIRead() failed in udi_fetch_registers");

  for (i = LR0_REGNUM; i < LR0_REGNUM + 128; i++)
    register_valid[i] = 1;

/* Protected Special Registers */

  From.Space = UDI29KSpecialRegs;
  From.Offset = 0;
  To = (UDIUInt32 *) & registers[4 * SR_REGNUM (0)];
  Count = 15;
  if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIRead() failed in udi_fetch_registers");

  for (i = SR_REGNUM (0); i < SR_REGNUM (0) + 15; i++)
    register_valid[i] = 1;

  if (USE_SHADOW_PC)
    {				/* Let regno_to_srnum() handle the register number */
      fetch_register (NPC_REGNUM);
      fetch_register (PC_REGNUM);
      fetch_register (PC2_REGNUM);

/* Unprotected Special Registers sr128-sr135 */

      From.Space = UDI29KSpecialRegs;
      From.Offset = 128;
      To = (UDIUInt32 *) & registers[4 * SR_REGNUM (128)];
      Count = 135 - 128 + 1;
      if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian))
	error ("UDIRead() failed in udi_fetch_registers");

      for (i = SR_REGNUM (128); i < SR_REGNUM (128) + 135 - 128 + 1; i++)
	register_valid[i] = 1;
    }

  if (remote_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Fetching all registers\n");
      fprintf_unfiltered (gdb_stdlog,
			  "Fetching PC0 = 0x%x, PC1 = 0x%x, PC2 = 0x%x\n",
			  read_register (NPC_REGNUM),
			  read_register (PC_REGNUM),
			  read_register (PC2_REGNUM));
    }

  /* There doesn't seem to be any way to get these.  */
  {
    int val = -1;
    supply_register (FPE_REGNUM, (char *) &val);
    supply_register (INTE_REGNUM, (char *) &val);
    supply_register (FPS_REGNUM, (char *) &val);
    supply_register (EXO_REGNUM, (char *) &val);
  }
}


/********************************************************* UDI_STORE_REGISTERS
** Store register regno into the target.  
 * If regno==-1 then store all the registers.
 */

static void
udi_store_registers (int regno)
{
  UDIUInt32 *From;
  UDIResource To;
  UDICount Count;
  UDISizeT Size = 4;
  UDICount CountDone;
  UDIBool HostEndian = 0;

  if (regno >= 0)
    {
      store_register (regno);
      return;
    }

  if (remote_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Storing all registers\n");
      fprintf_unfiltered (gdb_stdlog,
			  "PC0 = 0x%x, PC1 = 0x%x, PC2 = 0x%x\n",
			  read_register (NPC_REGNUM),
			  read_register (PC_REGNUM),
			  read_register (PC2_REGNUM));
    }

/* Gr1/rsp */

  From = (UDIUInt32 *) & registers[4 * GR1_REGNUM];
  To.Space = UDI29KGlobalRegs;
  To.Offset = 1;
  Count = 1;
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");

#if defined(GR64_REGNUM)

/* Global registers gr64-gr95 */

  From = (UDIUInt32 *) & registers[4 * GR64_REGNUM];
  To.Space = UDI29KGlobalRegs;
  To.Offset = 64;
  Count = 32;
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");

#endif /* GR64_REGNUM */

/* Global registers gr96-gr127 */

  From = (UDIUInt32 *) & registers[4 * GR96_REGNUM];
  To.Space = UDI29KGlobalRegs;
  To.Offset = 96;
  Count = 32;
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");

/* Local Registers */

  From = (UDIUInt32 *) & registers[4 * LR0_REGNUM];
  To.Space = UDI29KLocalRegs;
  To.Offset = 0;
  Count = 128;
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");


  /* Protected Special Registers *//* VAB through TMR */

  From = (UDIUInt32 *) & registers[4 * SR_REGNUM (0)];
  To.Space = UDI29KSpecialRegs;
  To.Offset = 0;
  Count = 10;
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");

/* PC0, PC1, PC2 possibly as shadow registers */

  From = (UDIUInt32 *) & registers[4 * SR_REGNUM (10)];
  To.Space = UDI29KSpecialRegs;
  Count = 3;
  if (USE_SHADOW_PC)
    To.Offset = 20;		/* SPC0 */
  else
    To.Offset = 10;		/* PC0 */
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");

/* PC1 via UDI29KPC */

  From = (UDIUInt32 *) & registers[4 * PC_REGNUM];
  To.Space = UDI29KPC;
  To.Offset = 0;		/* PC1 */
  Count = 1;
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");

  /* LRU and MMU */

  From = (UDIUInt32 *) & registers[4 * SR_REGNUM (13)];
  To.Space = UDI29KSpecialRegs;
  To.Offset = 13;
  Count = 2;
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");

/* Unprotected Special Registers */

  From = (UDIUInt32 *) & registers[4 * SR_REGNUM (128)];
  To.Space = UDI29KSpecialRegs;
  To.Offset = 128;
  Count = 135 - 128 + 1;
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");

  registers_changed ();
}

/****************************************************** UDI_PREPARE_TO_STORE */
/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
udi_prepare_to_store (void)
{
  /* Do nothing, since we can store individual regs */
}

/********************************************************** TRANSLATE_ADDR */
static CORE_ADDR
translate_addr (CORE_ADDR addr)
{
#if defined(ULTRA3) && defined(KERNEL_DEBUGGING)
  /* Check for a virtual address in the kernel */
  /* Assume physical address of ublock is in  paddr_u register */
  /* FIXME: doesn't work for user virtual addresses */
  if (addr >= UVADDR)
    {
      /* PADDR_U register holds the physical address of the ublock */
      CORE_ADDR i = (CORE_ADDR) read_register (PADDR_U_REGNUM);
      return (i + addr - (CORE_ADDR) UVADDR);
    }
  else
    {
      return (addr);
    }
#else
  return (addr);
#endif
}
/************************************************* UDI_XFER_INFERIOR_MEMORY */
/* FIXME!  Merge these two.  */
static int
udi_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
			  struct mem_attrib *attrib ATTRIBUTE_UNUSED,
			  struct target_ops *target ATTRIBUTE_UNUSED)
{

  memaddr = translate_addr (memaddr);

  if (write)
    return udi_write_inferior_memory (memaddr, myaddr, len);
  else
    return udi_read_inferior_memory (memaddr, myaddr, len);
}

/********************************************************** UDI_FILES_INFO */
static void
udi_files_info (struct target_ops *target)
{
  printf_unfiltered ("\tAttached to UDI socket to %s", udi_config_id);
  if (prog_name != NULL)
    printf_unfiltered ("and running program %s", prog_name);
  printf_unfiltered (".\n");
}

/**************************************************** UDI_INSERT_BREAKPOINT */
static int
udi_insert_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  int cnt;
  UDIError err;

  for (cnt = 0; cnt < BKPT_TABLE_SIZE; cnt++)
    if (bkpt_table[cnt].Type == 0)	/* Find first free slot */
      break;

  if (cnt >= BKPT_TABLE_SIZE)
    error ("Too many breakpoints set");

  bkpt_table[cnt].Addr.Offset = addr;
  bkpt_table[cnt].Addr.Space = UDI29KIRAMSpace;
  bkpt_table[cnt].PassCount = 1;
  bkpt_table[cnt].Type = UDIBreakFlagExecute;

  err = UDISetBreakpoint (bkpt_table[cnt].Addr,
			  bkpt_table[cnt].PassCount,
			  bkpt_table[cnt].Type,
			  &bkpt_table[cnt].BreakId);

  if (err == 0)
    return 0;			/* Success */

  bkpt_table[cnt].Type = 0;
  error ("UDISetBreakpoint returned error code %d\n", err);
}

/**************************************************** UDI_REMOVE_BREAKPOINT */
static int
udi_remove_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  int cnt;
  UDIError err;

  for (cnt = 0; cnt < BKPT_TABLE_SIZE; cnt++)
    if (bkpt_table[cnt].Addr.Offset == addr)	/* Find matching breakpoint */
      break;

  if (cnt >= BKPT_TABLE_SIZE)
    error ("Can't find breakpoint in table");

  bkpt_table[cnt].Type = 0;

  err = UDIClearBreakpoint (bkpt_table[cnt].BreakId);
  if (err == 0)
    return 0;			/* Success */

  error ("UDIClearBreakpoint returned error code %d\n", err);
}

static void
udi_kill (void)
{

#if 0
/*
   UDIStop does not really work as advertised.  It causes the TIP to close it's
   connection, which usually results in GDB dying with a SIGPIPE.  For now, we
   just invoke udi_close, which seems to get things right.
 */
  UDIStop ();

  udi_session_id = -1;
  inferior_ptid = null_ptid;

  if (from_tty)
    printf_unfiltered ("Target has been stopped.");
#endif /* 0 */
#if 0
  udi_close (0);
  pop_target ();
#endif /* 0 */

  /* Keep the target around, e.g. so "run" can do the right thing when
     we are already debugging something.  */

  if (UDIDisconnect (udi_session_id, UDITerminateSession))
    {
      warning ("UDIDisconnect() failed");
    }

  /* Do not try to close udi_session_id again, later in the program.  */
  udi_session_id = -1;
  inferior_ptid = null_ptid;
}

/* 
   Load a program into the target.  Args are: `program {options}'.  The options
   are used to control loading of the program, and are NOT passed onto the
   loaded code as arguments.  (You need to use the `run' command to do that.)

   The options are:
   -ms %d       Set mem stack size to %d
   -rs %d       Set regular stack size to %d
   -i   send init info (default)
   -noi don't send init info
   -[tT]        Load Text section
   -[dD]        Load Data section
   -[bB]        Load BSS section
   -[lL]        Load Lit section
 */

static void
download (char *load_arg_string, int from_tty)
{
#define DEFAULT_MEM_STACK_SIZE 		0x6000
#define DEFAULT_REG_STACK_SIZE 		0x2000

  char *token;
  char *filename;
  asection *section;
  bfd *pbfd;
  UDIError err;
  int load_text = 1, load_data = 1, load_bss = 1, load_lit = 1;

  address_ranges[0].Space = UDI29KIRAMSpace;
  address_ranges[0].Offset = 0xffffffff;
  address_ranges[0].Size = 0;

  address_ranges[1].Space = UDI29KDRAMSpace;
  address_ranges[1].Offset = 0xffffffff;
  address_ranges[1].Size = 0;

  stack_sizes[0] = DEFAULT_REG_STACK_SIZE;
  stack_sizes[1] = DEFAULT_MEM_STACK_SIZE;

  dont_repeat ();

  filename = strtok (load_arg_string, " \t");
  if (!filename)
    error ("Must specify at least a file name with the load command");

  filename = tilde_expand (filename);
  make_cleanup (xfree, filename);

  while (token = strtok (NULL, " \t"))
    {
      if (token[0] == '-')
	{
	  token++;

	  if (STREQ (token, "ms"))
	    stack_sizes[1] = atol (strtok (NULL, " \t"));
	  else if (STREQ (token, "rs"))
	    stack_sizes[0] = atol (strtok (NULL, " \t"));
	  else
	    {
	      load_text = load_data = load_bss = load_lit = 0;

	      while (*token)
		{
		  switch (*token++)
		    {
		    case 't':
		    case 'T':
		      load_text = 1;
		      break;
		    case 'd':
		    case 'D':
		      load_data = 1;
		      break;
		    case 'b':
		    case 'B':
		      load_bss = 1;
		      break;
		    case 'l':
		    case 'L':
		      load_lit = 1;
		      break;
		    default:
		      error ("Unknown UDI load option -%s", token - 1);
		    }
		}
	    }
	}
    }

  pbfd = bfd_openr (filename, gnutarget);

  if (!pbfd)
    /* FIXME: should be using bfd_errmsg, not assuming it was
       bfd_error_system_call.  */
    perror_with_name (filename);

  /* FIXME: should be checking for errors from bfd_close (for one thing,
     on error it does not free all the storage associated with the
     bfd).  */
  make_cleanup_bfd_close (pbfd);

  QUIT;
  immediate_quit++;

  if (!bfd_check_format (pbfd, bfd_object))
    error ("It doesn't seem to be an object file");

  for (section = pbfd->sections; section; section = section->next)
    {
      if (bfd_get_section_flags (pbfd, section) & SEC_ALLOC)
	{
	  UDIResource To;
	  UDICount Count;
	  unsigned long section_size, section_end;
	  const char *section_name;

	  section_name = bfd_get_section_name (pbfd, section);
	  if (STREQ (section_name, ".text") && !load_text)
	    continue;
	  else if (STREQ (section_name, ".data") && !load_data)
	    continue;
	  else if (STREQ (section_name, ".bss") && !load_bss)
	    continue;
	  else if (STREQ (section_name, ".lit") && !load_lit)
	    continue;

	  To.Offset = bfd_get_section_vma (pbfd, section);
	  section_size = bfd_section_size (pbfd, section);
	  section_end = To.Offset + section_size;

	  if (section_size == 0)
	    /* This is needed at least in the BSS case, where the code
	       below starts writing before it even checks the size.  */
	    continue;

	  printf_unfiltered ("[Loading section %s at %x (%d bytes)]\n",
			     section_name,
			     To.Offset,
			     section_size);

	  if (bfd_get_section_flags (pbfd, section) & SEC_CODE)
	    {
	      To.Space = UDI29KIRAMSpace;

	      address_ranges[0].Offset = min (address_ranges[0].Offset,
					      To.Offset);
	      address_ranges[0].Size = max (address_ranges[0].Size,
					    section_end
					    - address_ranges[0].Offset);
	    }
	  else
	    {
	      To.Space = UDI29KDRAMSpace;

	      address_ranges[1].Offset = min (address_ranges[1].Offset,
					      To.Offset);
	      address_ranges[1].Size = max (address_ranges[1].Size,
					    section_end
					    - address_ranges[1].Offset);
	    }

	  if (bfd_get_section_flags (pbfd, section) & SEC_LOAD)		/* Text, data or lit */
	    {
	      file_ptr fptr;

	      fptr = 0;

	      while (section_size > 0)
		{
		  char buffer[1024];

		  Count = min (section_size, 1024);

		  bfd_get_section_contents (pbfd, section, buffer, fptr,
					    Count);

		  err = UDIWrite ((UDIHostMemPtr) buffer,	/* From */
				  To,	/* To */
				  Count,	/* Count */
				  (UDISizeT) 1,		/* Size */
				  &Count,	/* CountDone */
				  (UDIBool) 0);		/* HostEndian */
		  if (err)
		    error ("UDIWrite failed, error = %d", err);

		  To.Offset += Count;
		  fptr += Count;
		  section_size -= Count;
		}
	    }
	  else
	    /* BSS */
	    {
	      UDIResource From;
	      unsigned long zero = 0;

	      /* Write a zero byte at the vma */
	      /* FIXME: Broken for sections of 1-3 bytes (we test for
	         zero above).  */
	      err = UDIWrite ((UDIHostMemPtr) & zero,	/* From */
			      To,	/* To */
			      (UDICount) 1,	/* Count */
			      (UDISizeT) 4,	/* Size */
			      &Count,	/* CountDone */
			      (UDIBool) 0);	/* HostEndian */
	      if (err)
		error ("UDIWrite failed, error = %d", err);

	      From = To;
	      To.Offset += 4;

	      /* Now, duplicate it for the length of the BSS */
	      err = UDICopy (From,	/* From */
			     To,	/* To */
			     (UDICount) (section_size / 4 - 1),		/* Count */
			     (UDISizeT) 4,	/* Size */
			     &Count,	/* CountDone */
			     (UDIBool) 1);	/* Direction */
	      if (err)
		{
		  char message[100];
		  int xerr;

		  xerr = UDIGetErrorMsg (err, 100, message, &Count);
		  if (!xerr)
		    fprintf_unfiltered (gdb_stderr, "Error is %s\n", message);
		  else
		    fprintf_unfiltered (gdb_stderr, "xerr is %d\n", xerr);
		  error ("UDICopy failed, error = %d", err);
		}
	    }

	}
    }

  entry.Space = UDI29KIRAMSpace;
  entry.Offset = bfd_get_start_address (pbfd);

  immediate_quit--;
}

/* Function to download an image into the remote target.  */

static void
udi_load (char *args, int from_tty)
{
  download (args, from_tty);

  /* As a convenience, pick up any symbol info that is in the program
     being loaded.  Note that we assume that the program is the``mainline'';
     if this is not always true, then this code will need to be augmented.  */
  symbol_file_add (strtok (args, " \t"), from_tty, NULL, 1, 0);

  /* Getting new symbols may change our opinion about what is
     frameless.  */
  reinit_frame_cache ();
}

/*************************************************** UDI_WRITE_INFERIOR_MEMORY
** Copy LEN bytes of data from debugger memory at MYADDR
   to inferior's memory at MEMADDR.  Returns number of bytes written.  */
static int
udi_write_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  int nwritten = 0;
  UDIUInt32 *From;
  UDIResource To;
  UDICount Count;
  UDISizeT Size = 1;
  UDICount CountDone = 0;
  UDIBool HostEndian = 0;

  To.Space = udi_memory_space (memaddr);
  From = (UDIUInt32 *) myaddr;

  while (nwritten < len)
    {
      Count = len - nwritten;
      if (Count > MAXDATA)
	Count = MAXDATA;
      To.Offset = memaddr + nwritten;
      if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
	{
	  error ("UDIWrite() failed in udi_write_inferior_memory");
	  break;
	}
      else
	{
	  nwritten += CountDone;
	  From += CountDone;
	}
    }
  return (nwritten);
}

/**************************************************** UDI_READ_INFERIOR_MEMORY
** Read LEN bytes from inferior memory at MEMADDR.  Put the result
   at debugger address MYADDR.  Returns number of bytes read.  */
static int
udi_read_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  int nread = 0;
  UDIResource From;
  UDIUInt32 *To;
  UDICount Count;
  UDISizeT Size = 1;
  UDICount CountDone = 0;
  UDIBool HostEndian = 0;
  UDIError err;

  From.Space = udi_memory_space (memaddr);
  To = (UDIUInt32 *) myaddr;

  while (nread < len)
    {
      Count = len - nread;
      if (Count > MAXDATA)
	Count = MAXDATA;
      From.Offset = memaddr + nread;
      if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian))
	{
	  error ("UDIRead() failed in udi_read_inferior_memory");
	  break;
	}
      else
	{
	  nread += CountDone;
	  To += CountDone;
	}
    }
  return (nread);
}

/********************************************************************* WARNING
*/
udi_warning (int num)
{
  error ("ERROR while loading program into remote TIP: $d\n", num);
}


/*****************************************************************************/
/* Fetch a single register indicatated by 'regno'. 
 * Returns 0/-1 on success/failure.  
 */
static void
fetch_register (int regno)
{
  UDIResource From;
  UDIUInt32 To;
  UDICount Count = 1;
  UDISizeT Size = 4;
  UDICount CountDone;
  UDIBool HostEndian = 0;
  UDIError err;
  int result;

  if (regno == GR1_REGNUM)
    {
      From.Space = UDI29KGlobalRegs;
      From.Offset = 1;
    }
  else if (regno >= GR96_REGNUM && regno < GR96_REGNUM + 32)
    {
      From.Space = UDI29KGlobalRegs;
      From.Offset = (regno - GR96_REGNUM) + 96;;
    }

#if defined(GR64_REGNUM)

  else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32)
    {
      From.Space = UDI29KGlobalRegs;
      From.Offset = (regno - GR64_REGNUM) + 64;
    }

#endif /* GR64_REGNUM */

  else if (regno >= LR0_REGNUM && regno < LR0_REGNUM + 128)
    {
      From.Space = UDI29KLocalRegs;
      From.Offset = (regno - LR0_REGNUM);
    }
  else if (regno >= FPE_REGNUM && regno <= EXO_REGNUM)
    {
      int val = -1;
      /*supply_register(160 + (regno - FPE_REGNUM),(char *) &val); */
      supply_register (regno, (char *) &val);
      return;			/* Pretend Success */
    }
  else
    {
      From.Space = UDI29KSpecialRegs;
      From.Offset = regnum_to_srnum (regno);
    }

  if (err = UDIRead (From, &To, Count, Size, &CountDone, HostEndian))
    error ("UDIRead() failed in udi_fetch_registers");

  supply_register (regno, (char *) &To);

  if (remote_debug)
    fprintf_unfiltered (gdb_stdlog, "Fetching register %s = 0x%x\n",
			REGISTER_NAME (regno), To);
}
/*****************************************************************************/
/* Store a single register indicated by 'regno'. 
 * Returns 0/-1 on success/failure.  
 */
static int
store_register (int regno)
{
  int result;
  UDIUInt32 From;
  UDIResource To;
  UDICount Count = 1;
  UDISizeT Size = 4;
  UDICount CountDone;
  UDIBool HostEndian = 0;

  From = read_register (regno);	/* get data value */

  if (remote_debug)
    fprintf_unfiltered (gdb_stdlog, "Storing register %s = 0x%x\n",
			REGISTER_NAME (regno), From);

  if (regno == GR1_REGNUM)
    {
      To.Space = UDI29KGlobalRegs;
      To.Offset = 1;
      result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian);
      /* Setting GR1 changes the numbers of all the locals, so invalidate the 
       * register cache.  Do this *after* calling read_register, because we want 
       * read_register to return the value that write_register has just stuffed 
       * into the registers array, not the value of the register fetched from 
       * the inferior.  
       */
      registers_changed ();
    }
#if defined(GR64_REGNUM)
  else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32)
    {
      To.Space = UDI29KGlobalRegs;
      To.Offset = (regno - GR64_REGNUM) + 64;
      result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian);
    }
#endif /* GR64_REGNUM */
  else if (regno >= GR96_REGNUM && regno < GR96_REGNUM + 32)
    {
      To.Space = UDI29KGlobalRegs;
      To.Offset = (regno - GR96_REGNUM) + 96;
      result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian);
    }
  else if (regno >= LR0_REGNUM && regno < LR0_REGNUM + 128)
    {
      To.Space = UDI29KLocalRegs;
      To.Offset = (regno - LR0_REGNUM);
      result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian);
    }
  else if (regno >= FPE_REGNUM && regno <= EXO_REGNUM)
    return 0;			/* Pretend Success */
  else if (regno == PC_REGNUM)
    {
      /* PC1 via UDI29KPC */

      To.Space = UDI29KPC;
      To.Offset = 0;		/* PC1 */
      result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian);

      /* Writing to this loc actually changes the values of pc0 & pc1 */

      register_valid[PC_REGNUM] = 0;	/* pc1 */
      register_valid[NPC_REGNUM] = 0;	/* pc0 */
    }
  else
    /* An unprotected or protected special register */
    {
      To.Space = UDI29KSpecialRegs;
      To.Offset = regnum_to_srnum (regno);
      result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian);
    }

  if (result != 0)
    error ("UDIWrite() failed in store_registers");

  return 0;
}
/********************************************************** REGNUM_TO_SRNUM */
/* 
 * Convert a gdb special register number to a 29000 special register number.
 */
static int
regnum_to_srnum (int regno)
{
  switch (regno)
    {
    case VAB_REGNUM:
      return (0);
    case OPS_REGNUM:
      return (1);
    case CPS_REGNUM:
      return (2);
    case CFG_REGNUM:
      return (3);
    case CHA_REGNUM:
      return (4);
    case CHD_REGNUM:
      return (5);
    case CHC_REGNUM:
      return (6);
    case RBP_REGNUM:
      return (7);
    case TMC_REGNUM:
      return (8);
    case TMR_REGNUM:
      return (9);
    case NPC_REGNUM:
      return (USE_SHADOW_PC ? (20) : (10));
    case PC_REGNUM:
      return (USE_SHADOW_PC ? (21) : (11));
    case PC2_REGNUM:
      return (USE_SHADOW_PC ? (22) : (12));
    case MMU_REGNUM:
      return (13);
    case LRU_REGNUM:
      return (14);
    case IPC_REGNUM:
      return (128);
    case IPA_REGNUM:
      return (129);
    case IPB_REGNUM:
      return (130);
    case Q_REGNUM:
      return (131);
    case ALU_REGNUM:
      return (132);
    case BP_REGNUM:
      return (133);
    case FC_REGNUM:
      return (134);
    case CR_REGNUM:
      return (135);
    case FPE_REGNUM:
      return (160);
    case INTE_REGNUM:
      return (161);
    case FPS_REGNUM:
      return (162);
    case EXO_REGNUM:
      return (164);
    default:
      return (255);		/* Failure ? */
    }
}
/****************************************************************************/
/*
 * Determine the Target memory space qualifier based on the addr. 
 * FIXME: Can't distinguis I_ROM/D_ROM.  
 * FIXME: Doesn't know anything about I_CACHE/D_CACHE.
 */
static CPUSpace
udi_memory_space (CORE_ADDR addr)
{
  UDIUInt32 tstart = IMemStart;
  UDIUInt32 tend = tstart + IMemSize;
  UDIUInt32 dstart = DMemStart;
  UDIUInt32 dend = tstart + DMemSize;
  UDIUInt32 rstart = RMemStart;
  UDIUInt32 rend = tstart + RMemSize;

  if (((UDIUInt32) addr >= tstart) && ((UDIUInt32) addr < tend))
    {
      return UDI29KIRAMSpace;
    }
  else if (((UDIUInt32) addr >= dstart) && ((UDIUInt32) addr < dend))
    {
      return UDI29KDRAMSpace;
    }
  else if (((UDIUInt32) addr >= rstart) && ((UDIUInt32) addr < rend))
    {
      /* FIXME: how do we determine between D_ROM and I_ROM */
      return UDI29KIROMSpace;
    }
  else				/* FIXME: what do me do now? */
    return UDI29KDRAMSpace;	/* Hmmm! */
}
/*********************************************************************** STUBS
*/

void
convert16 (void)
{;
}
void
convert32 (void)
{;
}
struct ui_file *EchoFile = 0;	/* used for debugging */
int QuietMode = 0;		/* used for debugging */

#ifdef NO_HIF_SUPPORT
service_HIF (union msg_t *msg)
{
  return (0);			/* Emulate a failure */
}
#endif

/* Target_ops vector.  Not static because there does not seem to be
   any portable way to do a forward declaration of a static variable.
   The RS/6000 doesn't like "extern" followed by "static"; SunOS
   /bin/cc doesn't like "static" twice.  */

struct target_ops udi_ops;

static void
init_udi_ops (void)
{
  udi_ops.to_shortname = "udi";
  udi_ops.to_longname = "Remote UDI connected TIP";
  udi_ops.to_doc = "Remote debug an AMD 29k using UDI socket connection to TIP process.\n\
Arguments are\n\
`configuration-id AF_INET hostname port-number'\n\
To connect via the network, where hostname and port-number specify the\n\
host and port where you can connect via UDI.\n\
configuration-id is unused.\n\
\n\
`configuration-id AF_UNIX socket-name tip-program'\n\
To connect using a local connection to the \"tip.exe\" program which is\n\
    supplied by AMD.  If socket-name specifies an AF_UNIX socket then the\n\
    tip program must already be started; connect to it using that socket.\n\
    If not, start up tip-program, which should be the name of the tip\n\
    program.  If appropriate, the PATH environment variable is searched.\n\
    configuration-id is unused.\n\
\n\
`configuration-id'\n\
    Look up the configuration in ./udi_soc or /etc/udi_soc, which\n\
    are files containing lines in the above formats.  configuration-id is\n\
    used to pick which line of the file to use.";
  udi_ops.to_open = udi_open;
  udi_ops.to_close = udi_close;
  udi_ops.to_attach = udi_attach;
  udi_ops.to_detach = udi_detach;
  udi_ops.to_resume = udi_resume;
  udi_ops.to_wait = udi_wait;
  udi_ops.to_fetch_registers = udi_fetch_registers;
  udi_ops.to_store_registers = udi_store_registers;
  udi_ops.to_prepare_to_store = udi_prepare_to_store;
  udi_ops.to_xfer_memory = udi_xfer_inferior_memory;
  udi_ops.to_files_info = udi_files_info;
  udi_ops.to_insert_breakpoint = udi_insert_breakpoint;
  udi_ops.to_remove_breakpoint = udi_remove_breakpoint;
  udi_ops.to_terminal_init = 0;
  udi_ops.to_terminal_inferior = 0;
  udi_ops.to_terminal_ours_for_output = 0;
  udi_ops.to_terminal_ours = 0;
  udi_ops.to_terminal_info = 0;
  udi_ops.to_kill = udi_kill;
  udi_ops.to_load = udi_load;
  udi_ops.to_lookup_symbol = 0;
  udi_ops.to_create_inferior = udi_create_inferior;
  udi_ops.to_mourn_inferior = udi_mourn;
  udi_ops.to_can_run = 0;
  udi_ops.to_notice_signals = 0;
  udi_ops.to_thread_alive = 0;
  udi_ops.to_stop = 0;
  udi_ops.to_stratum = process_stratum;
  udi_ops.DONT_USE = 0;
  udi_ops.to_has_all_memory = 1;
  udi_ops.to_has_memory = 1;
  udi_ops.to_has_stack = 1;
  udi_ops.to_has_registers = 1;
  udi_ops.to_has_execution = 1;
  udi_ops.to_sections = 0;
  udi_ops.to_sections_end = 0;
  udi_ops.to_magic = OPS_MAGIC;
};

void
_initialize_remote_udi (void)
{
  init_udi_ops ();
  add_target (&udi_ops);
}
@


1.15
log
@Phase 1 of the ptid_t changes.
@
text
@d412 1
a412 1
udi_wait (int ptid_t, struct target_waitstatus *status)
@


1.14
log
@Update/correct copyright notices.
@
text
@d57 1
a57 1
static void udi_resume (int pid, int step, enum target_signal sig);
d151 1
a151 1
  inferior_pid = 40000;
d321 1
a321 1
  inferior_pid = 0;
d373 1
a373 1
  inferior_pid = 0;
d386 1
a386 1
udi_resume (int pid, int step, enum target_signal sig)
d411 2
a412 2
static int
udi_wait (int pid, struct target_waitstatus *status)
d587 1
a587 1
  return inferior_pid;
d1015 1
a1015 1
  inferior_pid = 0;
d1035 1
a1035 1
  inferior_pid = 0;
@


1.13
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1990, 1992, 1995, 2000, 2001 Free Software Foundation, Inc.
@


1.12
log
@* ppc-bdm.c (#include <signal.h>): Removed.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-mips.c: Likewise.
* remote-os9k.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
@
text
@d49 1
@


1.11
log
@* monitor.c (#include "gdb_wait.h"): Removed.
* ocd.c: Likewise.
* ppc-bdm.c: Likewise.
* remote-adapt.c: Likewise.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-eb.c: Likewise.
* remote-es.c: Likewise.
* remote-mips.c: Likewise.
* remote-mm.c: Likewise.
* remote-nindy.c: Likewise.
* remote-os9k.c: Likewise.
* remote-rdi.c: Likewise.
* remote-rdp.c: Likewise.
* remote-sds.c: Likewise.
* remote-sim.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
* remote.c: Likewise.
* ser-pipe.c: Likewise.
* ser-unix.c: Likewise.
* Makefile.in: Updated dependencies.
-------------------------------------------------------------------
@
text
@a40 1
#include <signal.h>
@


1.10
log
@2001-01-24  Jeff Holcomb  <jeffh@@redhat.com>

        * remote-udi.c (udi_open): Change strdup to xstrdup.
        * thread.c (thread_apply_all_command): Change strdup to xstrdup.
        Update copyright message.
        * varobj.c (delete_variable_1): Likewise.

        * gdb_string.h: Remove declaration of strdup.  Update copyright
        message.
        * config/xm-mpw.h: Likewise.
        * config/i386/xm-i386mach.h: Likewise.
        * config/m68k/xm-apollo68b.h: Likewise.
        * config/m68k/xm-hp300bsd.h: Likewise.
        * config/rs6000/xm-rs6000.h: Likewise.
        * config/vax/xm-vaxult.h: Remove declaration of strdup.
        * config/vax/xm-vaxult2.h: Likewise.
@
text
@a37 1
#include "gdb_wait.h"
@


1.9
log
@* exec.c (xfer_memory): Add attrib argument.
* infptrace.c (child_xfer_memory): Likewise.
* monitor.c (monitor_xfer_memory): Likewise.
* remote-adapt.c (adapt_xfer_inferior_memory): Likewise.
* remote-array.c (array_xfer_memory): Likewise.
* remote-bug.c (bug_xfer_memory): Likewise.
* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
* remote-eb.c (eb_xfer_inferior_memory): Likewise.
* remote-es.c (es1800_xfer_inferior_memory): Likewise.
* remote-mips.c (mips_xfer_memory): Likewise.
* remote-mm.c (mm_xfer_inferior_memory): Likewise.
* remote-nindy.c (nindy_xfer_inferior_memory): Likewise.
* remote-os9k.c (rombug_xfer_inferior_memory): Likewise.
* remote-rdi.c (arm_rdi_xfer_memory): Likewise.
* remote-rdp.c (remote_rdp_xfer_inferior_memory): Likewise.
* remote-sds.c (sds_xfer_memory): Likewise.
* remote-sim.c (gdbsim_xfer_inferior_memory): Likewise.
* remote-st.c (st2000_xfer_inferior_memory): Likewise.
* remote-udi.c (udi_xfer_inferior_memory): Likewise.
* remote-vx.c (vx_xfer_memory): Likewise.
* remote.c (remote_xfer_memory): Likewise.
* target.c (debug_to_xfer_memory, do_xfer_memory): Likewise.
* target.h (child_xfer_memory, do_xfer_memory, xfer_memory): Likewise.

* target.h (#include "memattr.h"): Added.
(target_ops.to_xfer_memory): Add attrib argument.

* wince.c (_initialize_inftarg): Removed call to set_dcache_state.
* dcache.h (set_dcache_state): Removed declaration.
* dcache.c (set_dcache_state): Removed definition

* dcache.c: Update module comment, as dcache is now enabled and
disabled with memory region attributes instead of by the global
variable "remotecache".  Add comment describing the interaction
between dcache and memory region attributes.
(dcache_xfer_memory): Add comment describing benefits of moving
cache writeback to a higher level.
(dcache_struct): Removed cache_has_stuff field.  This was used to
record whether the cache had been accessed in order to invalidate
it when it was disabled.  However, this is not needed because the
cache is write through and the code that enables, disables, and
deletes memory regions invalidate the cache.  Add comment which
suggests that we could be more selective and only invalidate those
cache lines containing data from those memory regions.
(dcache_invalidate): Updated.
(dcache_xfer_memory): Updated.

(dcache_alloc): Don't abort() if dcache_enabled_p is clear.
(dcache_xfer_memory): Removed code that called do_xfer_memory() to
perform a uncached transfer if dcache_enabled_p was clear.  This
function is now only called if caching is enabled for the memory
region.
(dcache_info): Always print cache info.

* target.c (do_xfer_memory): Add attrib argument.
(target_xfer_memory, target_xfer_memory_partial): Break transfer
into chunks defined by memory regions, pass region attributes to
do_xfer_memory().
* dcache.c (dcache_read_line, dcache_write_line): Likewise.

* Makefile.in (SFILES): Add memattr.c.
(COMMON_OBS): Add memattr.o.
(dcache.o): Add target.h to dependencies.
* memattr.c: New file.
* memattr.h: Likewise.
@
text
@d237 1
a237 1
  udi_config_id = strdup (strtok (name, " \t"));
@


1.8
log
@Replace free() with xfree().
@
text
@d2 1
a2 1
   Copyright 1990, 1992, 1995, 2000 Free Software Foundation, Inc.
d926 2
a927 1
			  struct target_ops * target)
@


1.7
log
@Update function signatures to match target vector.
@
text
@d134 1
a134 1
	free (prog_name);
d232 1
a232 1
    free (udi_config_id);
d1084 1
a1084 1
  make_cleanup (free, filename);
@


1.6
log
@Protoization.
@
text
@d925 2
a926 1
udi_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len, int write)
d939 1
a939 1
udi_files_info (void)
d1002 1
a1002 1
udi_kill (char *arg, int from_tty)
@


1.5
log
@PARAMS removal.
@
text
@d127 1
a127 4
udi_create_inferior (execfile, args, env)
     char *execfile;
     char *args;
     char **env;
d187 1
a187 1
udi_mourn ()
d212 1
a212 3
udi_open (name, from_tty)
     char *name;
     int from_tty;
d302 2
a303 2
udi_close (quitting)		/*FIXME: how is quitting used */
     int quitting;
d331 1
a331 3
udi_attach (args, from_tty)
     char *args;
     int from_tty;
d362 1
a362 3
udi_detach (args, from_tty)
     char *args;
     int from_tty;
d386 1
a386 3
udi_resume (pid, step, sig)
     int pid, step;
     enum target_signal sig;
d412 1
a412 3
udi_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d592 1
a592 1
udi_pc ()
d644 1
a644 2
udi_fetch_registers (regno)
     int regno;
d770 1
a770 2
udi_store_registers (regno)
     int regno;
d895 1
a895 1
udi_prepare_to_store ()
d902 1
a902 2
translate_addr (addr)
     CORE_ADDR addr;
d925 1
a925 5
udi_xfer_inferior_memory (memaddr, myaddr, len, write)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
d938 1
a938 1
udi_files_info ()
d948 1
a948 3
udi_insert_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d979 1
a979 3
udi_remove_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d1001 1
a1001 3
udi_kill (arg, from_tty)
     char *arg;
     int from_tty;
d1053 1
a1053 3
download (load_arg_string, from_tty)
     char *load_arg_string;
     int from_tty;
d1282 1
a1282 3
udi_load (args, from_tty)
     char *args;
     int from_tty;
d1300 1
a1300 4
udi_write_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d1337 1
a1337 4
udi_read_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d1373 1
a1373 2
udi_warning (num)
     int num;
d1384 1
a1384 2
fetch_register (regno)
     int regno;
d1448 1
a1448 2
store_register (regno)
     int regno;
d1530 1
a1530 2
regnum_to_srnum (regno)
     int regno;
d1599 1
a1599 2
udi_memory_space (addr)
     CORE_ADDR addr;
d1628 1
a1628 1
convert16 ()
d1632 1
a1632 1
convert32 ()
d1639 1
a1639 2
service_HIF (msg)
     union msg_t *msg;
d1716 1
a1716 1
_initialize_remote_udi ()
@


1.4
log
@Purge (almost) make_cleanup_func.
@
text
@d57 14
a70 14
static void udi_resume PARAMS ((int pid, int step, enum target_signal sig));
static void udi_fetch_registers PARAMS ((int regno));
static void udi_load PARAMS ((char *args, int from_tty));
static void fetch_register PARAMS ((int regno));
static void udi_store_registers PARAMS ((int regno));
static int store_register PARAMS ((int regno));
static int regnum_to_srnum PARAMS ((int regno));
static void udi_close PARAMS ((int quitting));
static CPUSpace udi_memory_space PARAMS ((CORE_ADDR addr));
static int udi_write_inferior_memory PARAMS ((CORE_ADDR memaddr, char *myaddr,
					      int len));
static int udi_read_inferior_memory PARAMS ((CORE_ADDR memaddr, char *myaddr,
					     int len));
static void download PARAMS ((char *load_arg_string, int from_tty));
@


1.3
log
@Cleanup bfd_close() cleanups.
@
text
@d1111 1
a1111 1
  make_cleanup ((make_cleanup_func) free, filename);
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d1165 1
a1165 1
  make_cleanup ((make_cleanup_func) bfd_close, pbfd);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 1992, 1995 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d28 7
a34 7
 - Originally written by Daniel Mann at AMD for MiniMON and gdb 3.91.6.
 - David Wood (wood@@lab.ultra.nyu.edu) at New York University adapted this
	file to gdb 3.95.  I was unable to get this working on sun3os4
	with termio, only with sgtty.
 - Daniel Mann at AMD took the 3.95 adaptions above and replaced
   	MiniMON interface with UDI-p interface.	  */
 
d38 1
a38 1
#include "wait.h"
d50 1
a50 1
#include "gdbcore.h" /* For download function */
d55 2
a56 2
extern int stop_soon_quietly;           /* for wait_for_inferior */
extern struct value *call_function_by_hand();
d71 1
a71 1
char   CoffFileName[100] = "";
d77 1
a77 1
extern struct target_ops udi_ops;             /* Forward declaration */
d80 1
a80 1
*/
d83 1
a83 1
#define	MAXDATA		2*1024		/* max UDI[read/write] byte size */
d100 3
a102 2
UDIMemoryRange address_ranges[2]; /* Text and data */
UDIResource entry = {0, 0};	/* Entry point */
d108 4
a111 4
typedef	struct 	bkpt_entry_str
{
    UDIResource	 Addr;
    UDIUInt32	 PassCount;
d114 2
a115 1
} bkpt_entry_t;
d117 2
a118 2
static bkpt_entry_t	bkpt_table[BKPT_TABLE_SIZE];
extern	char	dfe_errmsg[];		/* error string */
d149 1
a149 1
	error("UDIConnect() failed: %s\n", dfe_errmsg);
d157 1
a157 1
    download(execfile, 0);
d159 1
a159 1
  args1 = alloca (strlen(execfile) + strlen(args) + 2);
d178 5
a182 5
			(UDIInt)2,		/* NumberOfRanges */
			entry,			/* EntryPoint */
			stack_sizes,		/* *StackSizes */
			(UDIInt)2,		/* NumberOfStacks */
			args1);			/* ArgString */
d190 1
a190 1
udi_mourn()
d197 1
a197 1
  pop_target ();                /* Pop back to no-child state */
d229 1
a229 1
  target_preopen(from_tty);
d240 1
a240 1
    error("Usage: target udi config_id, where config_id appears in udi_soc file");
d246 1
a246 1
    error("UDIConnect() failed: %s\n", dfe_errmsg);
d251 2
a252 2
  ** Initialize target configuration structure (global)
  */
d257 2
a258 2
    fprintf_unfiltered(gdb_stderr,"Target has more than one processor\n");
  for (cnt=0; cnt < NumberOfRanges; cnt++)
d260 1
a260 1
      switch(KnownMemory[cnt].Space)
d263 1
a263 1
	  fprintf_unfiltered(gdb_stderr, "UDIGetTargetConfig() unknown memory space\n");
d285 1
a285 1
     fprintf_unfiltered(gdb_stderr, "UDICreateProcess() failed\n");
d295 3
a297 3
		       (DFEIPCId>>8)&0xf, (DFEIPCId>>4)&0xf, DFEIPCId&0xf,
		       (TIPIPCId>>8)&0xf, (TIPIPCId>>4)&0xf, TIPIPCId&0xf,
		       (TargetId>>8)&0xf, (TargetId>>4)&0xf, TargetId&0xf,
d307 1
a307 1
udi_close (quitting)	/*FIXME: how is quitting used */
d329 1
a329 1
} 
d340 7
a346 7
  UDIResource	From;
  UDIInt32	PC_adds;
  UDICount	Count = 1;
  UDISizeT	Size = 4;
  UDICount	CountDone;
  UDIBool	HostEndian = 0;
  UDIError	err;
d352 2
a353 2
      error ("UDI connection not opened yet, use the 'target udi' command.\n");
	
d355 1
a355 1
      printf_unfiltered ("Attaching to remote program %s...\n", prog_name);
d357 1
a357 1
  UDIStop();
d360 1
a360 1
  if (err = UDIRead(From, &PC_adds, Count, Size, &CountDone, HostEndian))
d369 1
a369 1
udi_detach (args,from_tty)
d374 1
a374 1
  remove_breakpoints();		/* Just in case there were any left in */
d384 1
a384 1
  pop_target();
d404 1
a404 1
  if (step) 			/* step 1 instruction */
d410 1
a410 1
      fprintf_unfiltered (gdb_stderr,  "UDIStep() error = %d\n", tip_error);
d414 1
a414 1
  if (UDIExecute())
d427 7
a433 7
  UDIInt32	MaxTime;
  UDIPId	PId;
  UDIInt32	StopReason;
  UDISizeT	CountDone;
  int 		old_timeout = timeout;
  int 		old_immediate_quit = immediate_quit;
  int		i;
d439 2
a440 2
  If the target stops executing, udi_wait() should return.
*/
d442 1
a442 1
  immediate_quit = 1;   	/* Helps ability to QUIT */
d444 1
a444 1
  while(1)
d448 1
a448 1
      UDIWait(MaxTime, &PId, &StopReason);
d454 1
a454 1
	  if (UDIGetStdout (sbuf, (UDISizeT)SBUF_MAX, &CountDone))
d460 1
a460 1
	  gdb_flush(gdb_stdout);
d464 1
a464 1
	  UDIGetStderr (sbuf, (UDISizeT)SBUF_MAX, &CountDone);
d466 1
a466 1
	  gdb_flush(gdb_stderr);
d479 3
a481 2
	      } while (i < SBUF_MAX && ch != '\n');
	    UDIPutStdin (sbuf, (UDISizeT)i, &CountDone);
d499 3
a501 3
      printf_unfiltered("Am290*0 received vector number %d\n", StopReason >> 24);
	  
      switch ((StopReason >> 8 ) & 0xff)
d503 2
a504 2
	case 0:			/* Illegal opcode */
	  printf_unfiltered("	(break point)\n");
d508 1
a508 1
	case 1:			/* Unaligned Access */
d517 1
a517 1
	case 5:			/* Protection Violation */
d524 2
a525 2
	case 8:			/* User Instruction Mapping Miss */
	case 9:			/* User Data Mapping Miss */
d605 1
a605 1
udi_pc()
d607 7
a613 7
  UDIResource	From;
  UDIUInt32	*To;
  UDICount	Count;
  UDISizeT	Size = 4;
  UDICount	CountDone;
  UDIBool	HostEndian = 0;
  UDIError	err;
d620 1
a620 1
  To = (UDIUInt32 *)pc;
d623 1
a623 1
  err = UDIRead(From, To, Count, Size, &CountDone, HostEndian);
d626 1
a626 1
	  err, CountDone, pc[0], pc[1]);
d628 1
a628 1
  udi_fetch_registers(-1);
d630 2
a631 2
  printf_unfiltered("other pc1 = 0x%x, pc0 = 0x%x\n", *(int *)&registers[4 * PC_REGNUM],
	  *(int *)&registers[4 * NPC_REGNUM]);
d637 1
a637 1
  err = UDIRead(From, myregs, 256, 4, &CountDone, HostEndian);
d641 1
a641 1
  printf("\n");
d644 3
a646 3
    printf("%d:\t%#10x\t%11d\t%#10x\t%11d\n", i, myregs[i], myregs[i],
	   myregs[i+1], myregs[i+1]);
  printf("\n");
d656 1
a656 1
static void 
d658 1
a658 1
int	regno;
d660 8
a667 8
  UDIResource	From;
  UDIUInt32	*To;
  UDICount	Count;
  UDISizeT	Size = 4;
  UDICount	CountDone;
  UDIBool	HostEndian = 0;
  UDIError	err;
  int		i;
d669 5
a673 4
  if (regno >= 0)  {
    fetch_register(regno);
    return;
  }
d679 1
a679 1
  To = (UDIUInt32 *)&registers[4 * GR1_REGNUM];
d681 2
a682 2
  if (err = UDIRead(From, To, Count, Size, &CountDone, HostEndian))
    error("UDIRead() failed in udi_fetch_registers");
d688 1
a688 1
/* Global Registers gr64-gr95 */ 
d692 1
a692 1
  To = (UDIUInt32 *)&registers[4 * GR64_REGNUM];
d694 2
a695 2
  if (err = UDIRead(From, To, Count, Size, &CountDone, HostEndian))
    error("UDIRead() failed in udi_fetch_registers");
d700 1
a700 1
#endif	/*  GR64_REGNUM */
d702 1
a702 1
/* Global Registers gr96-gr127 */ 
d706 1
a706 1
  To = (UDIUInt32 *)&registers[4 * GR96_REGNUM];
d708 2
a709 2
  if (err = UDIRead(From, To, Count, Size, &CountDone, HostEndian))
    error("UDIRead() failed in udi_fetch_registers");
d718 1
a718 1
  To = (UDIUInt32 *)&registers[4 * LR0_REGNUM];
d720 2
a721 2
  if (err = UDIRead(From, To, Count, Size, &CountDone, HostEndian))
    error("UDIRead() failed in udi_fetch_registers");
d730 1
a730 1
  To = (UDIUInt32 *)&registers[4 * SR_REGNUM(0)];
d732 2
a733 2
  if (err = UDIRead(From, To, Count, Size, &CountDone, HostEndian))
    error("UDIRead() failed in udi_fetch_registers");
d735 1
a735 1
  for (i = SR_REGNUM(0); i < SR_REGNUM(0) + 15; i++)
d738 5
a742 4
  if (USE_SHADOW_PC) {	/* Let regno_to_srnum() handle the register number */
    fetch_register(NPC_REGNUM);
    fetch_register(PC_REGNUM);
    fetch_register(PC2_REGNUM);
d746 6
a751 6
    From.Space = UDI29KSpecialRegs;
    From.Offset = 128;
    To = (UDIUInt32 *)&registers[4 * SR_REGNUM(128)];
    Count = 135-128 + 1;
    if (err = UDIRead(From, To, Count, Size, &CountDone, HostEndian))
      error("UDIRead() failed in udi_fetch_registers");
d753 3
a755 3
    for (i = SR_REGNUM(128); i < SR_REGNUM(128) + 135-128+1; i++)
      register_valid[i] = 1;
  }
d759 6
a764 4
      printf_unfiltered("Fetching all registers\n");
      printf_unfiltered("Fetching PC0 = 0x%x, PC1 = 0x%x, PC2 = 0x%x\n",
	     read_register(NPC_REGNUM), read_register(PC_REGNUM),
	     read_register(PC2_REGNUM));
d785 1
a785 1
int regno;
d787 7
a793 7
  UDIUInt32	*From;
  UDIResource	To;
  UDICount	Count;
  UDISizeT	Size = 4;
  UDICount	CountDone;
  UDIBool	HostEndian = 0;
  
d796 1
a796 1
      store_register(regno);
d802 6
a807 3
      printf_unfiltered("Storing all registers\n");
      printf_unfiltered("PC0 = 0x%x, PC1 = 0x%x, PC2 = 0x%x\n", read_register(NPC_REGNUM),
	     read_register(PC_REGNUM), read_register(PC2_REGNUM));
d812 1
a812 1
  From = (UDIUInt32 *)&registers[4 * GR1_REGNUM];
d816 2
a817 2
  if(UDIWrite(From, To, Count, Size, &CountDone, HostEndian))
    error("UDIWrite() failed in udi_store_regisetrs");
d823 1
a823 1
  From = (UDIUInt32 *)&registers[4 * GR64_REGNUM];
d827 2
a828 2
  if(UDIWrite(From, To, Count, Size, &CountDone, HostEndian))
    error("UDIWrite() failed in udi_store_regisetrs");
d830 1
a830 1
#endif	/* GR64_REGNUM */
d834 1
a834 1
  From = (UDIUInt32 *)&registers[4 * GR96_REGNUM];
d838 2
a839 2
  if(UDIWrite(From, To, Count, Size, &CountDone, HostEndian))
    error("UDIWrite() failed in udi_store_regisetrs");
d843 1
a843 1
  From = (UDIUInt32 *)&registers[4 * LR0_REGNUM];
d847 2
a848 2
  if(UDIWrite(From, To, Count, Size, &CountDone, HostEndian))
    error("UDIWrite() failed in udi_store_regisetrs");
d851 1
a851 1
/* Protected Special Registers */ /* VAB through TMR */
d853 1
a853 1
  From = (UDIUInt32 *)&registers[4 * SR_REGNUM(0)];
d857 2
a858 2
  if(UDIWrite(From, To, Count, Size, &CountDone, HostEndian))
    error("UDIWrite() failed in udi_store_regisetrs");
d862 1
a862 1
  From = (UDIUInt32 *)&registers[4 * SR_REGNUM(10)];
d865 6
a870 6
  if (USE_SHADOW_PC) 
    To.Offset = 20;				/* SPC0 */
  else 
    To.Offset = 10;				/* PC0 */
  if(UDIWrite(From, To, Count, Size, &CountDone, HostEndian))
    error("UDIWrite() failed in udi_store_regisetrs");
d874 1
a874 1
  From = (UDIUInt32 *)&registers[4 * PC_REGNUM];
d876 1
a876 1
  To.Offset = 0;				/* PC1 */
d883 1
a883 1
  From = (UDIUInt32 *)&registers[4 * SR_REGNUM(13)];
d887 2
a888 2
  if(UDIWrite(From, To, Count, Size, &CountDone, HostEndian))
    error("UDIWrite() failed in udi_store_regisetrs");
d890 1
a890 1
/* Unprotected Special Registers */ 
d892 1
a892 1
  From = (UDIUInt32 *)&registers[4 * SR_REGNUM(128)];
d895 3
a897 3
  Count = 135-128 +1;
  if(UDIWrite(From, To, Count, Size, &CountDone, HostEndian))
    error("UDIWrite() failed in udi_store_regisetrs");
d917 2
a918 2
translate_addr(addr)
CORE_ADDR addr;
d921 13
a933 10
        /* Check for a virtual address in the kernel */
        /* Assume physical address of ublock is in  paddr_u register */
	/* FIXME: doesn't work for user virtual addresses */
        if (addr >= UVADDR) {
                /* PADDR_U register holds the physical address of the ublock */
                CORE_ADDR i = (CORE_ADDR)read_register(PADDR_U_REGNUM);
                return(i + addr - (CORE_ADDR)UVADDR);
        } else {
        	return(addr);
        }
d935 1
a935 1
        return(addr);
d948 1
a948 1
  memaddr = translate_addr(memaddr);
d976 1
a976 1
    if (bkpt_table[cnt].Type == 0) /* Find first free slot */
d979 2
a980 2
  if(cnt >= BKPT_TABLE_SIZE)
    error("Too many breakpoints set");
d983 1
a983 1
  bkpt_table[cnt].Addr.Space  = UDI29KIRAMSpace;
a985 5
  
  err = UDISetBreakpoint(bkpt_table[cnt].Addr,
			 bkpt_table[cnt].PassCount,
			 bkpt_table[cnt].Type,
			 &bkpt_table[cnt].BreakId);
d987 7
a993 1
  if (err == 0) return 0;		/* Success */
d996 1
a996 1
  error("UDISetBreakpoint returned error code %d\n", err);
d1009 1
a1009 1
    if (bkpt_table[cnt].Addr.Offset == addr) /* Find matching breakpoint */
d1012 2
a1013 2
  if(cnt >= BKPT_TABLE_SIZE)
    error("Can't find breakpoint in table");
d1017 3
a1019 2
  err = UDIClearBreakpoint(bkpt_table[cnt].BreakId);
  if (err == 0) return 0;	/* Success */
d1021 1
a1021 1
  error("UDIClearBreakpoint returned error code %d\n", err);
d1025 1
a1025 1
udi_kill(arg,from_tty)
d1032 5
a1036 5
UDIStop does not really work as advertised.  It causes the TIP to close it's
connection, which usually results in GDB dying with a SIGPIPE.  For now, we
just invoke udi_close, which seems to get things right.
*/
  UDIStop();
d1042 1
a1042 1
    printf_unfiltered("Target has been stopped.");
d1045 2
a1046 2
  udi_close(0);
  pop_target();
d1068 9
a1076 9
 		-ms %d	Set mem stack size to %d
		-rs %d	Set regular stack size to %d
		-i	send init info (default)
		-noi	don't send init info
		-[tT]  	Load Text section
		-[dD]	Load Data section
		-[bB]	Load BSS section
		-[lL]	Load Lit section
  */
d1079 1
a1079 1
download(load_arg_string, from_tty)
d1106 1
a1106 1
  filename = strtok(load_arg_string, " \t");
d1148 1
a1148 1
		      error ("Unknown UDI load option -%s", token-1);
d1157 1
a1157 1
  if (!pbfd) 
d1161 1
a1161 1
  
d1170 1
a1170 1
  if (!bfd_check_format (pbfd, bfd_object)) 
d1172 2
a1173 2
  
  for (section = pbfd->sections; section; section = section->next) 
d1201 4
a1204 4
	  printf_unfiltered("[Loading section %s at %x (%d bytes)]\n",
		 section_name,
		 To.Offset,
		 section_size);
d1227 1
a1227 1
	  if (bfd_get_section_flags (pbfd, section) & SEC_LOAD) /* Text, data or lit */
d1242 6
a1247 6
		  err = UDIWrite ((UDIHostMemPtr)buffer, /* From */
				  To,			/* To */
				  Count,		/* Count */
				  (UDISizeT)1,		/* Size */
				  &Count,		/* CountDone */
				  (UDIBool)0);		/* HostEndian */
d1256 2
a1257 1
	  else			/* BSS */
d1264 7
a1270 7
		 zero above).  */
	      err = UDIWrite ((UDIHostMemPtr)&zero,	/* From */
			      To,			/* To */
			      (UDICount)1,		/* Count */
			      (UDISizeT)4,		/* Size */
			      &Count,			/* CountDone */
			      (UDIBool)0);		/* HostEndian */
d1275 1
a1275 1
	      To.Offset+=4;
d1278 6
a1283 6
	      err = UDICopy (From,			/* From */
			     To,			/* To */
			     (UDICount)(section_size/4 - 1), /* Count */
			     (UDISizeT)4,		/* Size */
			     &Count,			/* CountDone */
			     (UDIBool)1);		/* Direction */
d1289 1
a1289 1
		  xerr = UDIGetErrorMsg(err, 100, message, &Count);
d1303 1
a1303 1
  
d1319 1
a1319 1
  symbol_file_add (strtok (args, " \t"), from_tty, 0, 1, 0, 0, 0, 0);
d1335 10
a1344 10
  int		nwritten = 0;
  UDIUInt32	*From;
  UDIResource	To;
  UDICount	Count;
  UDISizeT	Size = 1;
  UDICount	CountDone = 0;
  UDIBool	HostEndian = 0;
  
  To.Space = udi_memory_space(memaddr);
  From = (UDIUInt32*)myaddr;
d1347 9
a1355 6
  {	Count = len - nwritten;
	if (Count > MAXDATA) Count = MAXDATA;
  	To.Offset = memaddr + nwritten;
        if(UDIWrite(From, To, Count, Size, &CountDone, HostEndian))
    	{  error("UDIWrite() failed in udi_write_inferior_memory");
	   break;	
d1357 4
a1360 3
	else
  	{  nwritten += CountDone;
	   From += CountDone;
d1362 2
a1363 2
  }
  return(nwritten);
d1370 1
a1370 1
udi_read_inferior_memory(memaddr, myaddr, len)
d1375 11
a1385 11
  int		nread = 0;
  UDIResource	From;
  UDIUInt32	*To;
  UDICount	Count;
  UDISizeT	Size = 1;
  UDICount	CountDone = 0;
  UDIBool	HostEndian = 0;
  UDIError	err;
  
  From.Space = udi_memory_space(memaddr);	
  To = (UDIUInt32*)myaddr;
d1388 9
a1396 6
  {	Count = len - nread;
	if (Count > MAXDATA) Count = MAXDATA;
  	From.Offset = memaddr + nread;
        if(err = UDIRead(From, To, Count, Size, &CountDone, HostEndian))
    	{  error("UDIRead() failed in udi_read_inferior_memory");
	   break;	
d1398 4
a1401 3
	else
  	{  nread += CountDone;
	   To += CountDone;
d1403 2
a1404 2
  }
  return(nread);
d1409 2
a1410 2
udi_warning(num)
int	num;
d1412 1
a1412 1
    error ("ERROR while loading program into remote TIP: $d\n", num);
d1416 1
a1416 1
/*****************************************************************************/ 
d1424 8
a1431 8
  UDIResource	From;
  UDIUInt32	To;
  UDICount	Count = 1;
  UDISizeT	Size = 4;
  UDICount	CountDone;
  UDIBool	HostEndian = 0;
  UDIError	err;
  int  		result;
d1446 1
a1446 1
  else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32 )
d1452 1
a1452 1
#endif	/* GR64_REGNUM */
d1459 1
a1459 1
  else if (regno>=FPE_REGNUM && regno<=EXO_REGNUM)  
d1462 3
a1464 3
      /*supply_register(160 + (regno - FPE_REGNUM),(char *) &val);*/
      supply_register(regno, (char *) &val);
      return;		/* Pretend Success */
d1466 1
a1466 1
  else 
d1469 1
a1469 1
      From.Offset = regnum_to_srnum(regno); 
d1472 2
a1473 2
  if (err = UDIRead(From, &To, Count, Size, &CountDone, HostEndian))
    error("UDIRead() failed in udi_fetch_registers");
d1475 1
a1475 1
  supply_register(regno, (char *) &To);
d1478 2
a1479 1
    printf_unfiltered("Fetching register %s = 0x%x\n", REGISTER_NAME (regno), To);
d1481 1
a1481 1
/*****************************************************************************/ 
d1489 7
a1495 7
  int  		result;
  UDIUInt32	From;
  UDIResource	To;
  UDICount	Count = 1;
  UDISizeT	Size = 4;
  UDICount	CountDone;
  UDIBool	HostEndian = 0;
d1497 1
a1497 1
  From =  read_register (regno);	/* get data value */
d1500 2
a1501 1
    printf_unfiltered("Storing register %s = 0x%x\n", REGISTER_NAME (regno), From);
d1507 1
a1507 1
      result = UDIWrite(&From, To, Count, Size, &CountDone, HostEndian);
d1517 1
a1517 1
  else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32 )
d1521 1
a1521 1
      result = UDIWrite(&From, To, Count, Size, &CountDone, HostEndian);
d1523 1
a1523 1
#endif	/* GR64_REGNUM */
d1528 1
a1528 1
      result = UDIWrite(&From, To, Count, Size, &CountDone, HostEndian);
d1534 1
a1534 1
      result = UDIWrite(&From, To, Count, Size, &CountDone, HostEndian);
d1536 2
a1537 2
  else if (regno >= FPE_REGNUM && regno <= EXO_REGNUM)  
    return 0;		/* Pretend Success */
d1539 1
a1539 1
    {    
d1548 2
a1549 2
      register_valid[PC_REGNUM] = 0; /* pc1 */
      register_valid[NPC_REGNUM] = 0; /* pc0 */
d1551 2
a1552 1
  else 	/* An unprotected or protected special register */
d1555 2
a1556 2
      To.Offset = regnum_to_srnum(regno); 
      result = UDIWrite(&From, To, Count, Size, &CountDone, HostEndian);
d1560 1
a1560 1
    error("UDIWrite() failed in store_registers");
d1569 2
a1570 2
regnum_to_srnum(regno)
int	regno;
d1572 59
a1630 31
	switch(regno) {
		case VAB_REGNUM: return(0); 
		case OPS_REGNUM: return(1); 
		case CPS_REGNUM: return(2); 
		case CFG_REGNUM: return(3); 
		case CHA_REGNUM: return(4); 
		case CHD_REGNUM: return(5); 
		case CHC_REGNUM: return(6); 
		case RBP_REGNUM: return(7); 
		case TMC_REGNUM: return(8); 
		case TMR_REGNUM: return(9); 
		case NPC_REGNUM: return(USE_SHADOW_PC ? (20) : (10));
		case PC_REGNUM:  return(USE_SHADOW_PC ? (21) : (11));
		case PC2_REGNUM: return(USE_SHADOW_PC ? (22) : (12));
		case MMU_REGNUM: return(13); 
		case LRU_REGNUM: return(14); 
		case IPC_REGNUM: return(128); 
		case IPA_REGNUM: return(129); 
		case IPB_REGNUM: return(130); 
		case Q_REGNUM:   return(131); 
		case ALU_REGNUM: return(132); 
		case BP_REGNUM:  return(133); 
		case FC_REGNUM:  return(134); 
		case CR_REGNUM:  return(135); 
		case FPE_REGNUM: return(160); 
		case INTE_REGNUM: return(161); 
		case FPS_REGNUM: return(162); 
		case EXO_REGNUM:return(164); 
		default:
			return(255);	/* Failure ? */
	}
d1639 2
a1640 2
udi_memory_space(addr)
CORE_ADDR	addr;
d1642 22
a1663 16
	UDIUInt32 tstart = IMemStart;
	UDIUInt32 tend   = tstart + IMemSize;  
	UDIUInt32 dstart = DMemStart;
	UDIUInt32 dend   = tstart + DMemSize;  
	UDIUInt32 rstart = RMemStart;
	UDIUInt32 rend   = tstart + RMemSize;  

	if (((UDIUInt32)addr >= tstart) && ((UDIUInt32)addr < tend)) { 
		return UDI29KIRAMSpace;
	} else if (((UDIUInt32)addr >= dstart) && ((UDIUInt32)addr < dend)) { 
		return UDI29KDRAMSpace;
	} else if (((UDIUInt32)addr >= rstart) && ((UDIUInt32)addr < rend)) {
		/* FIXME: how do we determine between D_ROM and I_ROM */
		return UDI29KIROMSpace;
	} else	/* FIXME: what do me do now? */
		return UDI29KDRAMSpace;	/* Hmmm! */
d1668 10
a1677 4
void  convert16() {;}
void  convert32() {;}
GDB_FILE * EchoFile = 0;		/* used for debugging */
int   QuietMode = 0;		/* used for debugging */
d1680 1
a1680 1
service_HIF(msg)
d1683 1
a1683 1
  return(0);			/* Emulate a failure */
d1694 2
a1695 2
static void 
init_udi_ops(void)
d1697 3
a1699 3
  udi_ops.to_shortname =         "udi";
  udi_ops.to_longname = 	"Remote UDI connected TIP";
  udi_ops.to_doc = 	"Remote debug an AMD 29k using UDI socket connection to TIP process.\n\
d1717 38
a1754 38
    used to pick which line of the file to use." ;
  udi_ops.to_open =         udi_open;
  udi_ops.to_close = 	udi_close;
  udi_ops.to_attach =         udi_attach;
  udi_ops.to_detach = 	udi_detach;
  udi_ops.to_resume = 	udi_resume;
  udi_ops.to_wait  = 	udi_wait;
  udi_ops.to_fetch_registers  =         udi_fetch_registers;
  udi_ops.to_store_registers  = 	udi_store_registers;
  udi_ops.to_prepare_to_store =         udi_prepare_to_store;
  udi_ops.to_xfer_memory  =         udi_xfer_inferior_memory;
  udi_ops.to_files_info  =         udi_files_info;
  udi_ops.to_insert_breakpoint =         udi_insert_breakpoint;
  udi_ops.to_remove_breakpoint = 	udi_remove_breakpoint;
  udi_ops.to_terminal_init  =         0;		
  udi_ops.to_terminal_inferior = 	0;		
  udi_ops.to_terminal_ours_for_output = 	0;
  udi_ops.to_terminal_ours  = 	0;	
  udi_ops.to_terminal_info  = 	0;	
  udi_ops.to_kill  =         udi_kill;  
  udi_ops.to_load  =         udi_load;	
  udi_ops.to_lookup_symbol =         0; 
  udi_ops.to_create_inferior =         udi_create_inferior;
  udi_ops.to_mourn_inferior =         udi_mourn;
  udi_ops.to_can_run  = 	0;	
  udi_ops.to_notice_signals = 	0;	
  udi_ops.to_thread_alive  = 	0;	
  udi_ops.to_stop  =         0;
  udi_ops.to_stratum =         process_stratum;
  udi_ops.DONT_USE = 	0;		
  udi_ops.to_has_all_memory =         1;
  udi_ops.to_has_memory = 	1;	
  udi_ops.to_has_stack = 	1;	
  udi_ops.to_has_registers = 	1;	
  udi_ops.to_has_execution = 	1;	
  udi_ops.to_sections = 	0;	
  udi_ops.to_sections_end = 	0;	
  udi_ops.to_magic = 	OPS_MAGIC;
d1760 1
a1760 1
  init_udi_ops() ;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 pre reformat
@
text
@d753 4
a756 6
      fprintf_unfiltered (gdb_stdlog, "Fetching all registers\n");
      fprintf_unfiltered (gdb_stdlog,
			  "Fetching PC0 = 0x%x, PC1 = 0x%x, PC2 = 0x%x\n",
			  read_register (NPC_REGNUM),
			  read_register (PC_REGNUM),
			  read_register (PC2_REGNUM));
d794 3
a796 6
      fprintf_unfiltered (gdb_stdlog, "Storing all registers\n");
      fprintf_unfiltered (gdb_stdlog,
			  "PC0 = 0x%x, PC1 = 0x%x, PC2 = 0x%x\n",
			  read_register (NPC_REGNUM),
			  read_register (PC_REGNUM),
			  read_register (PC2_REGNUM));
d1453 1
a1453 2
    fprintf_unfiltered (gdb_stdlog, "Fetching register %s = 0x%x\n",
			REGISTER_NAME (regno), To);
d1474 1
a1474 2
    fprintf_unfiltered (gdb_stdlog, "Storing register %s = 0x%x\n",
			REGISTER_NAME (regno), From);
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d27 7
a33 7
   - Originally written by Daniel Mann at AMD for MiniMON and gdb 3.91.6.
   - David Wood (wood@@lab.ultra.nyu.edu) at New York University adapted this
   file to gdb 3.95.  I was unable to get this working on sun3os4
   with termio, only with sgtty.
   - Daniel Mann at AMD took the 3.95 adaptions above and replaced
   MiniMON interface with UDI-p interface.        */

d49 1
a49 1
#include "gdbcore.h"		/* For download function */
d54 2
a55 2
extern int stop_soon_quietly;	/* for wait_for_inferior */
extern struct value *call_function_by_hand ();
d70 1
a70 1
char CoffFileName[100] = "";
d76 1
a76 1
extern struct target_ops udi_ops;	/* Forward declaration */
d79 1
a79 1
 */
d82 1
a82 1
#define	MAXDATA		2*1024	/* max UDI[read/write] byte size */
d99 2
a100 3
UDIMemoryRange address_ranges[2];	/* Text and data */
UDIResource entry =
{0, 0};				/* Entry point */
d106 4
a109 4
typedef struct bkpt_entry_str
  {
    UDIResource Addr;
    UDIUInt32 PassCount;
d112 1
a112 2
  }
bkpt_entry_t;
d114 2
a115 2
static bkpt_entry_t bkpt_table[BKPT_TABLE_SIZE];
extern char dfe_errmsg[];	/* error string */
d146 1
a146 1
	error ("UDIConnect() failed: %s\n", dfe_errmsg);
d154 1
a154 1
    download (execfile, 0);
d156 1
a156 1
  args1 = alloca (strlen (execfile) + strlen (args) + 2);
d175 5
a179 5
			(UDIInt) 2,	/* NumberOfRanges */
			entry,	/* EntryPoint */
			stack_sizes,	/* *StackSizes */
			(UDIInt) 2,	/* NumberOfStacks */
			args1);	/* ArgString */
d187 1
a187 1
udi_mourn ()
d194 1
a194 1
  pop_target ();		/* Pop back to no-child state */
d226 1
a226 1
  target_preopen (from_tty);
d237 1
a237 1
    error ("Usage: target udi config_id, where config_id appears in udi_soc file");
d243 1
a243 1
    error ("UDIConnect() failed: %s\n", dfe_errmsg);
d248 2
a249 2
     ** Initialize target configuration structure (global)
   */
d254 2
a255 2
    fprintf_unfiltered (gdb_stderr, "Target has more than one processor\n");
  for (cnt = 0; cnt < NumberOfRanges; cnt++)
d257 1
a257 1
      switch (KnownMemory[cnt].Space)
d260 1
a260 1
	  fprintf_unfiltered (gdb_stderr, "UDIGetTargetConfig() unknown memory space\n");
d282 1
a282 1
    fprintf_unfiltered (gdb_stderr, "UDICreateProcess() failed\n");
d292 3
a294 3
	       (DFEIPCId >> 8) & 0xf, (DFEIPCId >> 4) & 0xf, DFEIPCId & 0xf,
	       (TIPIPCId >> 8) & 0xf, (TIPIPCId >> 4) & 0xf, TIPIPCId & 0xf,
	       (TargetId >> 8) & 0xf, (TargetId >> 4) & 0xf, TargetId & 0xf,
d304 1
a304 1
udi_close (quitting)		/*FIXME: how is quitting used */
d326 1
a326 1
}
d337 7
a343 7
  UDIResource From;
  UDIInt32 PC_adds;
  UDICount Count = 1;
  UDISizeT Size = 4;
  UDICount CountDone;
  UDIBool HostEndian = 0;
  UDIError err;
d349 2
a350 2
    error ("UDI connection not opened yet, use the 'target udi' command.\n");

d352 1
a352 1
    printf_unfiltered ("Attaching to remote program %s...\n", prog_name);
d354 1
a354 1
  UDIStop ();
d357 1
a357 1
  if (err = UDIRead (From, &PC_adds, Count, Size, &CountDone, HostEndian))
d366 1
a366 1
udi_detach (args, from_tty)
d371 1
a371 1
  remove_breakpoints ();	/* Just in case there were any left in */
d381 1
a381 1
  pop_target ();
d401 1
a401 1
  if (step)			/* step 1 instruction */
d407 1
a407 1
      fprintf_unfiltered (gdb_stderr, "UDIStep() error = %d\n", tip_error);
d411 1
a411 1
  if (UDIExecute ())
d424 7
a430 7
  UDIInt32 MaxTime;
  UDIPId PId;
  UDIInt32 StopReason;
  UDISizeT CountDone;
  int old_timeout = timeout;
  int old_immediate_quit = immediate_quit;
  int i;
d436 2
a437 2
   If the target stops executing, udi_wait() should return.
 */
d439 1
a439 1
  immediate_quit = 1;		/* Helps ability to QUIT */
d441 1
a441 1
  while (1)
d445 1
a445 1
      UDIWait (MaxTime, &PId, &StopReason);
d451 1
a451 1
	  if (UDIGetStdout (sbuf, (UDISizeT) SBUF_MAX, &CountDone))
d457 1
a457 1
	  gdb_flush (gdb_stdout);
d461 1
a461 1
	  UDIGetStderr (sbuf, (UDISizeT) SBUF_MAX, &CountDone);
d463 1
a463 1
	  gdb_flush (gdb_stderr);
d476 2
a477 3
	      }
	    while (i < SBUF_MAX && ch != '\n');
	    UDIPutStdin (sbuf, (UDISizeT) i, &CountDone);
d495 3
a497 3
      printf_unfiltered ("Am290*0 received vector number %d\n", StopReason >> 24);

      switch ((StopReason >> 8) & 0xff)
d499 2
a500 2
	case 0:		/* Illegal opcode */
	  printf_unfiltered ("	(break point)\n");
d504 1
a504 1
	case 1:		/* Unaligned Access */
d513 1
a513 1
	case 5:		/* Protection Violation */
d520 2
a521 2
	case 8:		/* User Instruction Mapping Miss */
	case 9:		/* User Data Mapping Miss */
d601 1
a601 1
udi_pc ()
d603 7
a609 7
  UDIResource From;
  UDIUInt32 *To;
  UDICount Count;
  UDISizeT Size = 4;
  UDICount CountDone;
  UDIBool HostEndian = 0;
  UDIError err;
d616 1
a616 1
  To = (UDIUInt32 *) pc;
d619 1
a619 1
  err = UDIRead (From, To, Count, Size, &CountDone, HostEndian);
d622 1
a622 1
		     err, CountDone, pc[0], pc[1]);
d624 1
a624 1
  udi_fetch_registers (-1);
d626 2
a627 2
  printf_unfiltered ("other pc1 = 0x%x, pc0 = 0x%x\n", *(int *) &registers[4 * PC_REGNUM],
		     *(int *) &registers[4 * NPC_REGNUM]);
d633 1
a633 1
  err = UDIRead (From, myregs, 256, 4, &CountDone, HostEndian);
d637 1
a637 1
  printf ("\n");
d640 3
a642 3
    printf ("%d:\t%#10x\t%11d\t%#10x\t%11d\n", i, myregs[i], myregs[i],
	    myregs[i + 1], myregs[i + 1]);
  printf ("\n");
d652 1
a652 1
static void
d654 1
a654 1
     int regno;
d656 8
a663 8
  UDIResource From;
  UDIUInt32 *To;
  UDICount Count;
  UDISizeT Size = 4;
  UDICount CountDone;
  UDIBool HostEndian = 0;
  UDIError err;
  int i;
d665 4
a668 5
  if (regno >= 0)
    {
      fetch_register (regno);
      return;
    }
d674 1
a674 1
  To = (UDIUInt32 *) & registers[4 * GR1_REGNUM];
d676 2
a677 2
  if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIRead() failed in udi_fetch_registers");
d683 1
a683 1
/* Global Registers gr64-gr95 */
d687 1
a687 1
  To = (UDIUInt32 *) & registers[4 * GR64_REGNUM];
d689 2
a690 2
  if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIRead() failed in udi_fetch_registers");
d695 1
a695 1
#endif /*  GR64_REGNUM */
d697 1
a697 1
/* Global Registers gr96-gr127 */
d701 1
a701 1
  To = (UDIUInt32 *) & registers[4 * GR96_REGNUM];
d703 2
a704 2
  if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIRead() failed in udi_fetch_registers");
d713 1
a713 1
  To = (UDIUInt32 *) & registers[4 * LR0_REGNUM];
d715 2
a716 2
  if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIRead() failed in udi_fetch_registers");
d725 1
a725 1
  To = (UDIUInt32 *) & registers[4 * SR_REGNUM (0)];
d727 2
a728 2
  if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIRead() failed in udi_fetch_registers");
d730 1
a730 1
  for (i = SR_REGNUM (0); i < SR_REGNUM (0) + 15; i++)
d733 4
a736 5
  if (USE_SHADOW_PC)
    {				/* Let regno_to_srnum() handle the register number */
      fetch_register (NPC_REGNUM);
      fetch_register (PC_REGNUM);
      fetch_register (PC2_REGNUM);
d740 6
a745 6
      From.Space = UDI29KSpecialRegs;
      From.Offset = 128;
      To = (UDIUInt32 *) & registers[4 * SR_REGNUM (128)];
      Count = 135 - 128 + 1;
      if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian))
	error ("UDIRead() failed in udi_fetch_registers");
d747 3
a749 3
      for (i = SR_REGNUM (128); i < SR_REGNUM (128) + 135 - 128 + 1; i++)
	register_valid[i] = 1;
    }
d779 1
a779 1
     int regno;
d781 7
a787 7
  UDIUInt32 *From;
  UDIResource To;
  UDICount Count;
  UDISizeT Size = 4;
  UDICount CountDone;
  UDIBool HostEndian = 0;

d790 1
a790 1
      store_register (regno);
d806 1
a806 1
  From = (UDIUInt32 *) & registers[4 * GR1_REGNUM];
d810 2
a811 2
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");
d817 1
a817 1
  From = (UDIUInt32 *) & registers[4 * GR64_REGNUM];
d821 2
a822 2
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");
d824 1
a824 1
#endif /* GR64_REGNUM */
d828 1
a828 1
  From = (UDIUInt32 *) & registers[4 * GR96_REGNUM];
d832 2
a833 2
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");
d837 1
a837 1
  From = (UDIUInt32 *) & registers[4 * LR0_REGNUM];
d841 2
a842 2
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");
d845 1
a845 1
  /* Protected Special Registers *//* VAB through TMR */
d847 1
a847 1
  From = (UDIUInt32 *) & registers[4 * SR_REGNUM (0)];
d851 2
a852 2
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");
d856 1
a856 1
  From = (UDIUInt32 *) & registers[4 * SR_REGNUM (10)];
d859 6
a864 6
  if (USE_SHADOW_PC)
    To.Offset = 20;		/* SPC0 */
  else
    To.Offset = 10;		/* PC0 */
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");
d868 1
a868 1
  From = (UDIUInt32 *) & registers[4 * PC_REGNUM];
d870 1
a870 1
  To.Offset = 0;		/* PC1 */
d877 1
a877 1
  From = (UDIUInt32 *) & registers[4 * SR_REGNUM (13)];
d881 2
a882 2
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");
d884 1
a884 1
/* Unprotected Special Registers */
d886 1
a886 1
  From = (UDIUInt32 *) & registers[4 * SR_REGNUM (128)];
d889 3
a891 3
  Count = 135 - 128 + 1;
  if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
    error ("UDIWrite() failed in udi_store_regisetrs");
d911 2
a912 2
translate_addr (addr)
     CORE_ADDR addr;
d915 10
a924 13
  /* Check for a virtual address in the kernel */
  /* Assume physical address of ublock is in  paddr_u register */
  /* FIXME: doesn't work for user virtual addresses */
  if (addr >= UVADDR)
    {
      /* PADDR_U register holds the physical address of the ublock */
      CORE_ADDR i = (CORE_ADDR) read_register (PADDR_U_REGNUM);
      return (i + addr - (CORE_ADDR) UVADDR);
    }
  else
    {
      return (addr);
    }
d926 1
a926 1
  return (addr);
d939 1
a939 1
  memaddr = translate_addr (memaddr);
d967 1
a967 1
    if (bkpt_table[cnt].Type == 0)	/* Find first free slot */
d970 2
a971 2
  if (cnt >= BKPT_TABLE_SIZE)
    error ("Too many breakpoints set");
d974 1
a974 1
  bkpt_table[cnt].Addr.Space = UDI29KIRAMSpace;
d977 5
d983 1
a983 7
  err = UDISetBreakpoint (bkpt_table[cnt].Addr,
			  bkpt_table[cnt].PassCount,
			  bkpt_table[cnt].Type,
			  &bkpt_table[cnt].BreakId);

  if (err == 0)
    return 0;			/* Success */
d986 1
a986 1
  error ("UDISetBreakpoint returned error code %d\n", err);
d999 1
a999 1
    if (bkpt_table[cnt].Addr.Offset == addr)	/* Find matching breakpoint */
d1002 2
a1003 2
  if (cnt >= BKPT_TABLE_SIZE)
    error ("Can't find breakpoint in table");
d1007 2
a1008 3
  err = UDIClearBreakpoint (bkpt_table[cnt].BreakId);
  if (err == 0)
    return 0;			/* Success */
d1010 1
a1010 1
  error ("UDIClearBreakpoint returned error code %d\n", err);
d1014 1
a1014 1
udi_kill (arg, from_tty)
d1021 5
a1025 5
   UDIStop does not really work as advertised.  It causes the TIP to close it's
   connection, which usually results in GDB dying with a SIGPIPE.  For now, we
   just invoke udi_close, which seems to get things right.
 */
  UDIStop ();
d1031 1
a1031 1
    printf_unfiltered ("Target has been stopped.");
d1034 2
a1035 2
  udi_close (0);
  pop_target ();
d1057 9
a1065 9
   -ms %d       Set mem stack size to %d
   -rs %d       Set regular stack size to %d
   -i   send init info (default)
   -noi don't send init info
   -[tT]        Load Text section
   -[dD]        Load Data section
   -[bB]        Load BSS section
   -[lL]        Load Lit section
 */
d1068 1
a1068 1
download (load_arg_string, from_tty)
d1095 1
a1095 1
  filename = strtok (load_arg_string, " \t");
d1137 1
a1137 1
		      error ("Unknown UDI load option -%s", token - 1);
d1146 1
a1146 1
  if (!pbfd)
d1150 1
a1150 1

d1159 1
a1159 1
  if (!bfd_check_format (pbfd, bfd_object))
d1161 2
a1162 2

  for (section = pbfd->sections; section; section = section->next)
d1190 4
a1193 4
	  printf_unfiltered ("[Loading section %s at %x (%d bytes)]\n",
			     section_name,
			     To.Offset,
			     section_size);
d1216 1
a1216 1
	  if (bfd_get_section_flags (pbfd, section) & SEC_LOAD)		/* Text, data or lit */
d1231 6
a1236 6
		  err = UDIWrite ((UDIHostMemPtr) buffer,	/* From */
				  To,	/* To */
				  Count,	/* Count */
				  (UDISizeT) 1,		/* Size */
				  &Count,	/* CountDone */
				  (UDIBool) 0);		/* HostEndian */
d1245 1
a1245 2
	  else
	    /* BSS */
d1252 7
a1258 7
	         zero above).  */
	      err = UDIWrite ((UDIHostMemPtr) & zero,	/* From */
			      To,	/* To */
			      (UDICount) 1,	/* Count */
			      (UDISizeT) 4,	/* Size */
			      &Count,	/* CountDone */
			      (UDIBool) 0);	/* HostEndian */
d1263 1
a1263 1
	      To.Offset += 4;
d1266 6
a1271 6
	      err = UDICopy (From,	/* From */
			     To,	/* To */
			     (UDICount) (section_size / 4 - 1),		/* Count */
			     (UDISizeT) 4,	/* Size */
			     &Count,	/* CountDone */
			     (UDIBool) 1);	/* Direction */
d1277 1
a1277 1
		  xerr = UDIGetErrorMsg (err, 100, message, &Count);
d1291 1
a1291 1

d1323 10
a1332 10
  int nwritten = 0;
  UDIUInt32 *From;
  UDIResource To;
  UDICount Count;
  UDISizeT Size = 1;
  UDICount CountDone = 0;
  UDIBool HostEndian = 0;

  To.Space = udi_memory_space (memaddr);
  From = (UDIUInt32 *) myaddr;
d1335 6
a1340 9
    {
      Count = len - nwritten;
      if (Count > MAXDATA)
	Count = MAXDATA;
      To.Offset = memaddr + nwritten;
      if (UDIWrite (From, To, Count, Size, &CountDone, HostEndian))
	{
	  error ("UDIWrite() failed in udi_write_inferior_memory");
	  break;
d1342 3
a1344 4
      else
	{
	  nwritten += CountDone;
	  From += CountDone;
d1346 2
a1347 2
    }
  return (nwritten);
d1354 1
a1354 1
udi_read_inferior_memory (memaddr, myaddr, len)
d1359 11
a1369 11
  int nread = 0;
  UDIResource From;
  UDIUInt32 *To;
  UDICount Count;
  UDISizeT Size = 1;
  UDICount CountDone = 0;
  UDIBool HostEndian = 0;
  UDIError err;

  From.Space = udi_memory_space (memaddr);
  To = (UDIUInt32 *) myaddr;
d1372 6
a1377 9
    {
      Count = len - nread;
      if (Count > MAXDATA)
	Count = MAXDATA;
      From.Offset = memaddr + nread;
      if (err = UDIRead (From, To, Count, Size, &CountDone, HostEndian))
	{
	  error ("UDIRead() failed in udi_read_inferior_memory");
	  break;
d1379 3
a1381 4
      else
	{
	  nread += CountDone;
	  To += CountDone;
d1383 2
a1384 2
    }
  return (nread);
d1389 2
a1390 2
udi_warning (num)
     int num;
d1392 1
a1392 1
  error ("ERROR while loading program into remote TIP: $d\n", num);
d1396 1
a1396 1
/*****************************************************************************/
d1404 8
a1411 8
  UDIResource From;
  UDIUInt32 To;
  UDICount Count = 1;
  UDISizeT Size = 4;
  UDICount CountDone;
  UDIBool HostEndian = 0;
  UDIError err;
  int result;
d1426 1
a1426 1
  else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32)
d1432 1
a1432 1
#endif /* GR64_REGNUM */
d1439 1
a1439 1
  else if (regno >= FPE_REGNUM && regno <= EXO_REGNUM)
d1442 3
a1444 3
      /*supply_register(160 + (regno - FPE_REGNUM),(char *) &val); */
      supply_register (regno, (char *) &val);
      return;			/* Pretend Success */
d1446 1
a1446 1
  else
d1449 1
a1449 1
      From.Offset = regnum_to_srnum (regno);
d1452 2
a1453 2
  if (err = UDIRead (From, &To, Count, Size, &CountDone, HostEndian))
    error ("UDIRead() failed in udi_fetch_registers");
d1455 1
a1455 1
  supply_register (regno, (char *) &To);
d1461 1
a1461 1
/*****************************************************************************/
d1469 7
a1475 7
  int result;
  UDIUInt32 From;
  UDIResource To;
  UDICount Count = 1;
  UDISizeT Size = 4;
  UDICount CountDone;
  UDIBool HostEndian = 0;
d1477 1
a1477 1
  From = read_register (regno);	/* get data value */
d1487 1
a1487 1
      result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian);
d1497 1
a1497 1
  else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32)
d1501 1
a1501 1
      result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian);
d1503 1
a1503 1
#endif /* GR64_REGNUM */
d1508 1
a1508 1
      result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian);
d1514 1
a1514 1
      result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian);
d1516 2
a1517 2
  else if (regno >= FPE_REGNUM && regno <= EXO_REGNUM)
    return 0;			/* Pretend Success */
d1519 1
a1519 1
    {
d1528 2
a1529 2
      register_valid[PC_REGNUM] = 0;	/* pc1 */
      register_valid[NPC_REGNUM] = 0;	/* pc0 */
d1531 1
a1531 2
  else
    /* An unprotected or protected special register */
d1534 2
a1535 2
      To.Offset = regnum_to_srnum (regno);
      result = UDIWrite (&From, To, Count, Size, &CountDone, HostEndian);
d1539 1
a1539 1
    error ("UDIWrite() failed in store_registers");
d1548 2
a1549 2
regnum_to_srnum (regno)
     int regno;
d1551 31
a1581 59
  switch (regno)
    {
    case VAB_REGNUM:
      return (0);
    case OPS_REGNUM:
      return (1);
    case CPS_REGNUM:
      return (2);
    case CFG_REGNUM:
      return (3);
    case CHA_REGNUM:
      return (4);
    case CHD_REGNUM:
      return (5);
    case CHC_REGNUM:
      return (6);
    case RBP_REGNUM:
      return (7);
    case TMC_REGNUM:
      return (8);
    case TMR_REGNUM:
      return (9);
    case NPC_REGNUM:
      return (USE_SHADOW_PC ? (20) : (10));
    case PC_REGNUM:
      return (USE_SHADOW_PC ? (21) : (11));
    case PC2_REGNUM:
      return (USE_SHADOW_PC ? (22) : (12));
    case MMU_REGNUM:
      return (13);
    case LRU_REGNUM:
      return (14);
    case IPC_REGNUM:
      return (128);
    case IPA_REGNUM:
      return (129);
    case IPB_REGNUM:
      return (130);
    case Q_REGNUM:
      return (131);
    case ALU_REGNUM:
      return (132);
    case BP_REGNUM:
      return (133);
    case FC_REGNUM:
      return (134);
    case CR_REGNUM:
      return (135);
    case FPE_REGNUM:
      return (160);
    case INTE_REGNUM:
      return (161);
    case FPS_REGNUM:
      return (162);
    case EXO_REGNUM:
      return (164);
    default:
      return (255);		/* Failure ? */
    }
d1590 2
a1591 2
udi_memory_space (addr)
     CORE_ADDR addr;
d1593 16
a1608 22
  UDIUInt32 tstart = IMemStart;
  UDIUInt32 tend = tstart + IMemSize;
  UDIUInt32 dstart = DMemStart;
  UDIUInt32 dend = tstart + DMemSize;
  UDIUInt32 rstart = RMemStart;
  UDIUInt32 rend = tstart + RMemSize;

  if (((UDIUInt32) addr >= tstart) && ((UDIUInt32) addr < tend))
    {
      return UDI29KIRAMSpace;
    }
  else if (((UDIUInt32) addr >= dstart) && ((UDIUInt32) addr < dend))
    {
      return UDI29KDRAMSpace;
    }
  else if (((UDIUInt32) addr >= rstart) && ((UDIUInt32) addr < rend))
    {
      /* FIXME: how do we determine between D_ROM and I_ROM */
      return UDI29KIROMSpace;
    }
  else				/* FIXME: what do me do now? */
    return UDI29KDRAMSpace;	/* Hmmm! */
d1613 4
a1616 10
void
convert16 ()
{;
}
void
convert32 ()
{;
}
GDB_FILE *EchoFile = 0;		/* used for debugging */
int QuietMode = 0;		/* used for debugging */
d1619 1
a1619 1
service_HIF (msg)
d1622 1
a1622 1
  return (0);			/* Emulate a failure */
d1633 2
a1634 2
static void
init_udi_ops (void)
d1636 3
a1638 3
  udi_ops.to_shortname = "udi";
  udi_ops.to_longname = "Remote UDI connected TIP";
  udi_ops.to_doc = "Remote debug an AMD 29k using UDI socket connection to TIP process.\n\
d1656 38
a1693 38
    used to pick which line of the file to use.";
  udi_ops.to_open = udi_open;
  udi_ops.to_close = udi_close;
  udi_ops.to_attach = udi_attach;
  udi_ops.to_detach = udi_detach;
  udi_ops.to_resume = udi_resume;
  udi_ops.to_wait = udi_wait;
  udi_ops.to_fetch_registers = udi_fetch_registers;
  udi_ops.to_store_registers = udi_store_registers;
  udi_ops.to_prepare_to_store = udi_prepare_to_store;
  udi_ops.to_xfer_memory = udi_xfer_inferior_memory;
  udi_ops.to_files_info = udi_files_info;
  udi_ops.to_insert_breakpoint = udi_insert_breakpoint;
  udi_ops.to_remove_breakpoint = udi_remove_breakpoint;
  udi_ops.to_terminal_init = 0;
  udi_ops.to_terminal_inferior = 0;
  udi_ops.to_terminal_ours_for_output = 0;
  udi_ops.to_terminal_ours = 0;
  udi_ops.to_terminal_info = 0;
  udi_ops.to_kill = udi_kill;
  udi_ops.to_load = udi_load;
  udi_ops.to_lookup_symbol = 0;
  udi_ops.to_create_inferior = udi_create_inferior;
  udi_ops.to_mourn_inferior = udi_mourn;
  udi_ops.to_can_run = 0;
  udi_ops.to_notice_signals = 0;
  udi_ops.to_thread_alive = 0;
  udi_ops.to_stop = 0;
  udi_ops.to_stratum = process_stratum;
  udi_ops.DONT_USE = 0;
  udi_ops.to_has_all_memory = 1;
  udi_ops.to_has_memory = 1;
  udi_ops.to_has_stack = 1;
  udi_ops.to_has_registers = 1;
  udi_ops.to_has_execution = 1;
  udi_ops.to_sections = 0;
  udi_ops.to_sections_end = 0;
  udi_ops.to_magic = OPS_MAGIC;
d1699 1
a1699 1
  init_udi_ops ();
@


1.1.1.4
log
@import gdb-1999-10-04 snapshot
@
text
@d1319 1
a1319 1
  symbol_file_add (strtok (args, " \t"), from_tty, NULL, 1, 0, 0, 0);
@


1.1.1.5
log
@import gdb-1999-10-11 snapshot
@
text
@d1319 1
a1319 1
  symbol_file_add (strtok (args, " \t"), from_tty, NULL, 1, 0);
@


1.1.1.6
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright 1990, 1992, 1995, 2000 Free Software Foundation, Inc.
d1676 1
a1676 1
struct ui_file *EchoFile = 0;	/* used for debugging */
@


