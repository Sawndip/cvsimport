head	1.1;
access;
symbols
	gdb-csl-symbian-6_4_50_20060226-12:1.1.4.1
	gdb-csl-symbian-6_4_50_20060226-11:1.1.4.1
	gdb-csl-sourcerygxx-4_1-17:1.1.4.1
	gdb-csl-20060226-branch-local-2:1.1.4.1
	gdb-csl-sourcerygxx-4_1-14:1.1.4.1
	gdb-csl-sourcerygxx-4_1-13:1.1.4.1
	gdb-csl-sourcerygxx-4_1-12:1.1.4.1
	gdb-csl-sourcerygxx-3_4_4-21:1.1.4.1
	gdb-csl-sourcerygxx-4_1-9:1.1.4.1
	gdb-csl-sourcerygxx-4_1-8:1.1.4.1
	gdb-csl-sourcerygxx-4_1-7:1.1.4.1
	gdb-csl-arm-2006q1-6:1.1.4.1
	gdb-csl-sourcerygxx-4_1-6:1.1.4.1
	gdb-csl-symbian-6_4_50_20060226-10:1.1.4.1
	gdb-csl-symbian-6_4_50_20060226-9:1.1.4.1
	gdb-csl-symbian-6_4_50_20060226-8:1.1.4.1
	gdb-csl-coldfire-4_1-11:1.1.4.1
	gdb-csl-sourcerygxx-3_4_4-19:1.1.4.1
	gdb-csl-coldfire-4_1-10:1.1.4.1
	gdb-csl-sourcerygxx-4_1-5:1.1.4.1
	gdb-csl-sourcerygxx-4_1-4:1.1.4.1
	gdb-csl-morpho-4_1-4:1.1.4.1
	gdb-csl-sourcerygxx-3_4_4-17:1.1.4.1
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.1.4.1
	gdb-csl-symbian-20060226-branch:1.1.4.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.1.4.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.1.4.1
	gdb-csl-20060226-branch:1.1.0.4
	gdb-csl-available-20060303-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.1
date	2006.03.03.20.46.36;	author drow;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2006.03.03.20.46.36;	author drow;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2006.03.14.13.58.41;	author drow;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2006.03.18.22.50.52;	author drow;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2006.03.21.20.48.28;	author drow;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2006.03.23.16.52.21;	author drow;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2006.03.23.21.49.57;	author drow;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2006.03.27.19.11.10;	author drow;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2006.03.31.17.24.57;	author drow;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2006.03.31.18.14.46;	author drow;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2006.04.02.02.35.32;	author drow;	state Exp;
branches;
next	;

1.1.4.1
date	2006.04.03.00.47.37;	author drow;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file available.c was initially added on branch gdb-csl-available-20060303-branch.
@
text
@@


1.1.4.1
log
@Merge XML and VFP support to this branch.
@
text
@a0 726
/* Support for runtime-defined target features for GDB.

   Copyright (C) 2006
   Free Software Foundation, Inc.

   Contributed by CodeSourcery.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "defs.h"
#include "arch-utils.h"
#include "exceptions.h"
#include "gdbtypes.h"
#include "reggroups.h"
#include "symfile.h"
#include "target.h"
#include "sha1.h"

#include "available.h"

#include "gdb_assert.h"
#include "gdb_string.h"
#include "gdb_obstack.h"
#include "gdb_stdint.h"

/* TODO: Remote target "guess" features from g packet size */

/* TODO: Clarify warning messages.  Remember, they will appear to
   the user with no context after a "target remote".  The user
   doesn't know how we got into this code.  */

/* Architecture TODO to support this:

   - Call available_register_type from _register_type method.
   - Handle unexpected changes to _num_regs.
   - Call record_available_features from _gdbarch_init.
   - Do not override the default _register_byte

  (WARNING: This list is out of date and should be redone before submission.
  And moved into gdbint.texi.)
*/



/* Support for caching XML objects read from the target.

   TODO ITEMS:
   - Support caching to disk.
   - Support compiled-in feature cache.
   - Figure out memory management for feature contents strings.
*/


/* Saved information about cached XML objects.  Each cache entry
   corresponds to a file in the cache, or an object fetched from
   the target with one particular annex.  */

struct xml_cache_entry
{
  const char *annex;
  const char *contents;

  /* This flag is cleared when we begin reading features, and set
     for new features when they are read.  It is used to prevent
     reading the same file from the target twice (for multiple
     xi:include's or DTD references).  */
  int recently_used;

  union
  {
    /* We use a union to represent the checksum in order to guarantee
       sufficient alignment.  */
    uint32_t words[5];
    unsigned char bytes[20];
  } sha1sum;

  struct xml_cache_entry *next;
};

/* A list of all the cached objects.  */

static struct xml_cache_entry *xml_global_cache;

/* Look for a feature in the cache with ANNEX and CHECKSUM.  If
   CHECKSUM is NULL, then look for a feature in the cache which has
   already been used this session.  If no entry is found, return
   NULL.  */

static const char *
find_xml_feature_in_cache (const char *annex, const unsigned char *checksum)
{
  struct xml_cache_entry *ent;

  for (ent = xml_global_cache; ent != NULL; ent = ent->next)
    {
      if (strcmp (ent->annex, annex) != 0)
	continue;

      if (checksum == NULL && !ent->recently_used)
	continue;

      if (checksum != NULL && memcmp (ent->sha1sum.bytes, checksum, 20) != 0)
	continue;

      ent->recently_used = 1;
      return ent->contents;
    }

  return NULL;
}

/* Add CONTENTS, which represents the object named ANNEX, to the
   cache if it is not already cached.  */

static void
add_xml_feature_to_cache (const char *annex, const char *contents)
{
  struct xml_cache_entry new_ent;

  /* FIXME: Again, memory allocation?  */
  new_ent.annex = xstrdup (annex);
  new_ent.contents = xstrdup (contents);

  sha1_buffer (new_ent.contents, strlen (new_ent.contents),
	       new_ent.sha1sum.bytes);

  /* If this entry is already in the cache, do not add it again.  This
     call also marks the cache entry as used.  */
  if (find_xml_feature_in_cache (annex, new_ent.sha1sum.bytes))
    return;

  new_ent.recently_used = 1;
  new_ent.next = xml_global_cache;

  xml_global_cache = xmalloc (sizeof (struct xml_cache_entry));
  memcpy (xml_global_cache, &new_ent, sizeof (struct xml_cache_entry));
}

/* Convert an ASCII checksum string, CHECKSUM, to a binary blob,
   BYTES.  Returns 0 for success, or -1 if a bad character is
   encountered.  CHECKSUM does not need to be NUL terminated.  */

static int
checksum_to_bytes (char *checksum, unsigned char *bytes)
{
  int i;

  for (i = 0; i < 20; i++)
    {
      int n;
      char c1, c2;

      c1 = checksum[2 * i];
      if (c1 >= '0' && c1 <= '9')
	n = c1 - '0';
      else if (c1 >= 'a' && c1 <= 'f')
	n = c1 - 'a' + 10;
      else if (c1 >= 'A' && c1 <= 'F')
	n = c1 - 'A' + 10;
      else
	return -1;

      n *= 16;

      c2 = checksum[2 * i + 1];
      if (c2 >= '0' && c2 <= '9')
	n += c2 - '0';
      else if (c2 >= 'a' && c2 <= 'f')
	n += c2 - 'a' + 10;
      else if (c2 >= 'A' && c2 <= 'F')
	n += c2 - 'A' + 10;
      else
	return -1;

      bytes[i] = n;
    }

  return 0;
}

/* Baton passed to fetch_available_features_from_target.  */

struct fetch_features_baton
{
  struct target_ops *ops;

  struct fetch_features_checksum
  {
    const char *annex;
    unsigned char checksum[20];
  } *checksums;
};

/* Read a string representation of available features from the target,
   using TARGET_OBJECT_AVAILABLE_FEATURES.  The returned string is
   malloc allocated and NUL-terminated.  NAME should be a non-NULL
   string identifying the XML document we want; the top level document
   is "target.xml".  Other calls may be performed for the DTD or
   for xi:include.  */

static char *
fetch_available_features_from_target (const char *name, void *baton_)
{
  struct fetch_features_baton *baton = baton_;
  char *features_str;
  gdb_byte *features_buf;
  LONGEST len;
  const unsigned char *checksum = NULL;
  const char *cached_str;

  if (baton->checksums)
    {
      struct fetch_features_checksum *checksum_ent;

      for (checksum_ent = baton->checksums;
	   checksum_ent->annex != NULL;
	   checksum_ent++)
	if (strcmp (checksum_ent->annex, name) == 0)
	  break;

      if (checksum_ent->annex)
	checksum = checksum_ent->checksum;
    }

  cached_str = find_xml_feature_in_cache (name, checksum);

  /* This function always returns something which the caller is
     responsible for freeing.  So, if we got a match, return a
     copy of it.  */
  if (cached_str)
    return xstrdup (cached_str);

  len = target_read_whole (baton->ops, TARGET_OBJECT_AVAILABLE_FEATURES,
			   name, &features_buf);
  if (len <= 0)
    return NULL;

  /* Since we decode this object as a string, simplify processing by
     making sure it is NUL terminated.  */
  features_str = (char *) features_buf;
  if (features_str[len - 1] != '\0')
    {
      features_str = xrealloc (features_str, len + 1);
      features_str[len] = '\0';
    }

  if (baton->checksums)
    add_xml_feature_to_cache (name, features_str);

  return features_str;
}

/* Standard method to convert a string representation of available features
   to a binary representation.  The string representation is fetched using
   TARGET_OBJECT_AVAILABLE_FEATURES.  */

/* TODO: Document \n conventions */

struct gdb_feature_set *
available_features_from_target_object (struct target_ops *ops,
				       struct obstack *obstack)
{
  struct fetch_features_baton baton;
  struct gdb_feature_set *features;
  char *features_str, *checksums_str;
  int ret;
  struct xml_cache_entry *ent;
  struct cleanup *back_to = make_cleanup (null_cleanup, NULL);

  /* Reset the recently used flag so that we read any objects
     without checksums from the target.  */
  for (ent = xml_global_cache; ent != NULL; ent = ent->next)
    ent->recently_used = 0;

  /* Initialize the baton.  */
  baton.ops = ops;
  baton.checksums = NULL;

  /* Attempt to read checksums from the target.  */
  checksums_str = fetch_available_features_from_target ("CHECKSUMS", &baton);
  if (checksums_str)
    {
      char *p;
      int n_checksums;

      make_cleanup (xfree, checksums_str);

      /* Allow for one checksum in case there is no trailing newline,
	 and one to serve as a NULL terminator.  */
      n_checksums = 2;

      /* Allocate one additional checksum per newline.  */
      for (p = checksums_str; *p; p++)
	if (*p == '\n')
	  n_checksums++;

      baton.checksums = xmalloc (n_checksums
				 * sizeof (struct fetch_features_checksum));
      make_cleanup (xfree, baton.checksums);

      n_checksums = 0;
      p = checksums_str;
      while (*p)
	{
	  char *field_end;

	  /* Find the first space on the line, marking the end of the
	     checksum.  */
	  field_end = p;
	  while (*field_end && *field_end != '\n'
		 && *field_end != ' ')
	    field_end++;

	  /* Check for a malformed checksum.  */
	  if (*field_end != ' '
	      || field_end - p != 40
	      || checksum_to_bytes (p, baton.checksums[n_checksums].checksum))
	    {
	      /* Skip this line.  */
	      p = field_end;
	      while (*p && *p != '\n')
		p++;
	      if (*p == '\n')
		p++;
	      continue;
	    }

	  *field_end = '\0';

	  /* Skip whitespace after the checksum.  */
	  p = field_end + 1;
	  while (*p == ' ')
	    p++;

	  field_end = p;
	  while (*field_end && *field_end != '\n')
	    field_end++;

	  if (field_end == p)
	    {
	      /* Malformed line; skip it.  */
	      if (*p == '\n')
		p++;
	      continue;
	    }

	  baton.checksums[n_checksums++].annex = p;

	  /* Advance to the next line, inserting a NUL for the end of
	     the annex name if necessary.  */
	  if (*field_end)
	    {
	      *field_end = '\0';
	      p = field_end + 1;
	    }
	  else
	    break;
	}

      baton.checksums[n_checksums].annex = NULL;
    }

  /* FIXME: Memory management: what happens to features_str?  */

  features_str = fetch_available_features_from_target ("target.xml", &baton);
  if (features_str == NULL)
    return NULL;

  features = OBSTACK_ZALLOC (obstack, struct gdb_feature_set);
  features->obstack = obstack;
  ret = available_features_from_xml_string (features,
					    features_str,
					    fetch_available_features_from_target,
					    &baton, 0);

  do_cleanups (back_to);

  if (ret < 0)
    {
      warning (_("Could not parse features XML from target"));
      return NULL;
    }

  return features;
}

/* Return non-zero if LHS and RHS refer to compatible feature sets.  */

int
features_same_p (const struct gdb_feature_set *lhs,
		 const struct gdb_feature_set *rhs)
{
  /* Two feature sets are the same if and only if they are described
     by the same XML.  */

  if (memcmp (lhs->checksum, rhs->checksum, 20) == 0)
    return 1;
  else
    return 0;
}

/* Switch the architecture (gdbarch) to one which supports FEATURES.  */

void
arch_set_available_features (struct gdb_feature_set *features)
{
  volatile struct gdb_exception e;
  struct gdbarch_info info;

  TRY_CATCH (e, RETURN_MASK_ERROR)
    {
      gdbarch_info_init (&info);
      info.feature_set = features;

      if (!gdbarch_update_p (info))
	internal_error (__FILE__, __LINE__, "could not update architecture");
    }

  if (e.reason == RETURN_ERROR)
    exception_fprintf (gdb_stderr, e,
		       _("warning: could not use supplied target description: "));
}

static struct gdb_feature_set *
copy_features_to_obstack (struct obstack *obstack,
			  const struct gdb_feature_set *features)
{
  struct gdb_feature_set *result;
  struct gdb_available_feature **slot, *orig_feature;

  result = obstack_alloc (obstack, sizeof (struct gdb_feature_set));
  result->obstack = obstack;

  slot = &result->features;
  for (orig_feature = features->features;
       orig_feature;
       orig_feature = orig_feature->next)
    {
      struct gdb_available_feature *feature;
      struct gdb_available_register **reg_slot, *orig_reg;

      feature = OBSTACK_ZALLOC (obstack, struct gdb_available_feature);
      *slot = feature;
      slot = &feature->next;

      memcpy (feature, orig_feature, sizeof (struct gdb_available_feature));
      feature->name = obsavestring (feature->name, strlen (feature->name),
				    obstack);
      if (feature->arch_data)
	feature->arch_data = obsavestring (feature->arch_data,
					   strlen (feature->arch_data),
					   obstack);

      reg_slot = &feature->registers;
      for (orig_reg = orig_feature->registers;
	   orig_reg;
	   orig_reg = orig_reg->next)
	{
	  struct gdb_available_register *reg;

	  reg = OBSTACK_ZALLOC (obstack, struct gdb_available_register);
	  *reg_slot = reg;
	  reg_slot = &reg->next;

	  memcpy (reg, orig_reg, sizeof (struct gdb_available_register));
	  reg->name = obsavestring (reg->name, strlen (reg->name), obstack);
	  if (reg->arch_data)
	    reg->arch_data = obsavestring (reg->arch_data,
					   strlen (reg->arch_data),
					   obstack);
	  if (reg->group)
	    reg->group = obsavestring (reg->group, strlen (reg->group),
				       obstack);
	  if (reg->type)
	    reg->type = obsavestring (reg->type, strlen (reg->type),
				      obstack);
	}
    }

  return result;
}

/* Set an architecture's feature set.  Store BASE_FEATURES in GDBARCH,
   and on the correct obstack.

   This function will update GDBARCH's num_regs.  It is the
   architecture's responsibility to handle this if it has pseudo
   registers.  Before calling this function, num_regs should be
   the number of fixed registers handled by the target code; all
   unassigned registers will be given numbers above that point.  */

void
record_available_features (struct gdbarch *gdbarch,
			   struct gdb_feature_set *base_features)
{
  struct gdb_available_feature *feature;
  struct gdb_available_register *reg;
  struct gdb_feature_set *features;
  int gdb_regnum;

  features = copy_features_to_obstack (gdbarch_obstack (gdbarch),
				       base_features);
  set_gdbarch_feature_set (gdbarch, features);

  gdb_regnum = gdbarch_num_regs (gdbarch);

  for (feature = features->features; feature; feature = feature->next)
    for (reg = feature->registers; reg; reg = reg->next)
      if (reg->gdb_regnum == -1)
	reg->gdb_regnum = gdb_regnum++;

  set_gdbarch_num_regs (gdbarch, gdb_regnum);
}

/* Search FEATURES for a register with GDB register number REGNUM.  */

static struct gdb_available_register *
find_register (const struct gdb_feature_set *features, int regnum)
{
  struct gdb_available_feature *feature;
  struct gdb_available_register *reg;

  if (features == NULL)
    return NULL;

  for (feature = features->features; feature; feature = feature->next)
    for (reg = feature->registers; reg; reg = reg->next)
      if (reg->gdb_regnum == regnum)
	return reg;

  return NULL;
}

/* Search FEATURES for a register with target-specified name NAME, and
   set its GDB register number to REGNUM.  Pass REGNUM == -1 if you do
   not need to fix a register number for this register.  Return 1 if
   the register was found, and 0 if it was not.  This function should
   only be used while initializing a gdbarch.  */

int
available_find_named_register (struct gdb_feature_set *features,
			       const char *name, int regnum)
{
  struct gdb_available_feature *feature;
  struct gdb_available_register *reg;

  if (features == NULL)
    return 0;

  for (feature = features->features; feature; feature = feature->next)
    for (reg = feature->registers; reg; reg = reg->next)
      if (strcmp (reg->name, name) == 0)
	{
	  reg->gdb_regnum = regnum;
	  return 1;
	}

  /* FIXME: Should we sanity check the target-supplied data here for
     duplicate register names?  Right now GDB can't handle duplicated
     register names at all, but in the future it may.  */

  return 0;
}

/* Search FEATURES for a feature with the well-known name NAME,
   which GDB may have special support for.  */

int
available_find_named_feature (struct gdb_feature_set *features,
			      const char *name)
{
  struct gdb_available_feature *feature;

  if (features == NULL)
    return 0;

  for (feature = features->features; feature; feature = feature->next)
    if (strcmp (feature->name, name) == 0)
      return 1;

  return 0;
}

/* Return the type of target-described register REGNUM, if the feature set
   for GDBARCH describes that register.  Otherwise return NULL.  */

struct type *
available_register_type (struct gdbarch *gdbarch, int regnum)
{
  struct gdb_available_register *reg;

  reg = find_register (gdbarch_feature_set (gdbarch), regnum);
  if (reg == NULL)
    return NULL;

  if (reg->type && strcmp (reg->type, "float") == 0)
    {
      if (reg->bitsize == gdbarch_float_bit (gdbarch))
	return builtin_type_float;
      else if (reg->bitsize == gdbarch_double_bit (gdbarch))
	return builtin_type_double;
      else if (reg->bitsize == gdbarch_long_double_bit (gdbarch))
	return builtin_type_long_double;
    }

  if (reg->type && strcmp (reg->type, "int") != 0)
    {
      /* FIXME: Warn the user about an unknown type + size?  */
    }

  /* Use an integer type; default to "long".  */
  if (reg->bitsize == gdbarch_long_bit (gdbarch))
    return builtin_type_long;
  else if (reg->bitsize == TARGET_CHAR_BIT)
    return builtin_type_signed_char;
  else if (reg->bitsize == gdbarch_short_bit (gdbarch))
    return builtin_type_short;
  else if (reg->bitsize == gdbarch_int_bit (gdbarch))
    return builtin_type_int;
  else if (reg->bitsize == gdbarch_long_long_bit (gdbarch))
    return builtin_type_long_long;
  else if (reg->bitsize == gdbarch_ptr_bit (gdbarch))
    /* A bit desperate by this point... */
    return builtin_type_void_data_ptr;
  else
    {
      /* FIXME: Create a new integer type of the appropriate size?  */
      internal_error (__FILE__, __LINE__,
		      _("GDB does not support %ld-bit registers on this target"),
		      reg->bitsize);
    }
}

/* Return the name of target-described register REGNUM, if the feature set
   for GDBARCH describes that register.  Otherwise return NULL.  */

const char *
available_register_name (struct gdbarch *gdbarch, int regnum)
{
  struct gdb_available_register *reg;

  reg = find_register (gdbarch_feature_set (gdbarch), regnum);
  if (reg == NULL)
    return NULL;

  return reg->name;
}

/* Return the target-supplied register of target-described register
   REGNUM, or -1 if the register can not be accessed.  */

int
available_register_target_regnum (struct gdbarch *gdbarch, int regnum)
{
  struct gdb_available_register *reg;

  /* If there is no feature set, use the legacy 1:1 mapping.  */
  if (gdbarch_feature_set (gdbarch) == NULL)
    return regnum;

  reg = find_register (gdbarch_feature_set (gdbarch), regnum);
  if (reg == NULL)
    return -1;

  return reg->protocol_number;
}

/* Check whether REGNUM is a member of REGGROUP.  */

/* TODO: This function only supports "info registers", "info float",
   and "info vector".  Registers with group="general" go in general;
   group="float" and group="vector" are similar.  Other specified
   values of group go into all-registers only.  Registers with no
   group specified go to the default function and are handled by
   type.  When we have a hierarchy of features, it may make more
   sense to use that to show registers.  */

int
available_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			       struct reggroup *reggroup)
{
  struct gdb_available_register *reg;

  reg = find_register (gdbarch_feature_set (gdbarch), regnum);
  if (reg != NULL && reg->group != NULL)
    {
      int general_p = 0, float_p = 0, vector_p = 0;

      if (strcmp (reg->group, "general") == 0)
	general_p = 1;
      else if (strcmp (reg->group, "float") == 0)
	float_p = 1;
      else if (strcmp (reg->group, "vector") == 0)
	vector_p = 1;

      if (reggroup == float_reggroup)
	return float_p;

      if (reggroup == vector_reggroup)
	return vector_p;

      if (reggroup == general_reggroup)
	return general_p;
    }

  if (reg != NULL
      && (reggroup == save_reggroup || reggroup == restore_reggroup))
    return reg->save_restore;

  return default_register_reggroup_p (gdbarch, regnum, reggroup);
}
@


1.1.2.1
log
@Initial version of available features support.
@
text
@a0 367
/* Support for runtime-defined target features for GDB.

   Copyright (C) 2006
   Free Software Foundation, Inc.

   Contributed by CodeSourcery.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "defs.h"
#include "arch-utils.h"
#include "gdbtypes.h"
#include "symfile.h"
#include "target.h"

#include "available.h"

#include "gdb_assert.h"
#include "gdb_string.h"
#include "gdb_obstack.h"

/* TODO: Remote target "guess" features from g packet size */

/* TODO: Clarify warning messages.  Remember, they will appear to
   the user with no context after a "target remote".  The user
   doesn't know how we got into this code.  */

/* Architecture TODO to support this:

   - Call available_register_type from _register_type method.
   - Handle unexpected changes to _num_regs.
   - Call record_available_features from _gdbarch_init.
   - Do not override the default _register_byte
   - Provide gdbarch_remote_num_g_packet_regs
*/

/* FIXME: Everywhere we call internal_error from this file leads to a failure
   to initialize a gdbarch, which leads to later failures when we expect
   e.g. current_regcache to have been initialized.  */

/* Read a string representation of available features from the target,
   using TARGET_OBJECT_AVAILABLE_FEATURES.  The returned string is
   malloc allocated and NUL-terminated.  If NAME is NULL, the overall
   feature set is read; otherwise the specified name is read (e.g.
   resolving xi:include).  */

static char *
fetch_available_features_from_target (const char *name, void *ops_)
{
  struct target_ops *ops = ops_;
  char *features_str;
  gdb_byte *features_buf;
  LONGEST len;

  struct gdb_feature_set *features;
  struct gdb_available_feature **slot;
  int ret;

  len = target_read_whole (ops, TARGET_OBJECT_AVAILABLE_FEATURES,
			   NULL, &features_buf);
  if (len <= 0)
    return NULL;

  /* Since we decode this object as a string, simplify processing by
     making sure it is NUL terminated.  */
  features_str = (char *) features_buf;
  if (features_str[len - 1] != '\0')
    {
      features_str = xrealloc (features_str, len + 1);
      features_str[len] = '\0';
    }

  return features_str;
}

/* Standard method to convert a string representation of available features
   to a binary representation.  The string representation is fetched using
   TARGET_OBJECT_AVAILABLE_FEATURES.  */

struct gdb_feature_set *
available_features_from_target_object (struct target_ops *ops,
				       struct obstack *obstack)
{
  struct gdb_feature_set *features;
  char *features_str, *cur;
  gdb_byte *features_buf;
  LONGEST len;
  struct gdb_available_feature **slot;
  int ret;

  features_str = fetch_available_features_from_target (NULL, ops);

  features = OBSTACK_ZALLOC (obstack, struct gdb_feature_set);
  features->obstack = obstack;
  ret = available_features_from_xml_string (&features->features, obstack,
					    features_str,
					    fetch_available_features_from_target,
					    ops, 0);

  if (ret < 0)
    {
      warning (_("Could not parse features XML from target"));
      return NULL;
    }

  return features;
}

/* Return non-zero if LHS and RHS refer to compatible feature sets.  */

int
features_same_p (const struct gdb_feature_set *lhs,
		 const struct gdb_feature_set *rhs)
{
  const struct gdb_available_feature *lhs_p, *rhs_p;

  lhs_p = lhs->features;
  rhs_p = rhs->features;
  while (lhs_p && rhs_p)
    {
      lhs_p = lhs_p->next;
      rhs_p = rhs_p->next;
    }
  if (lhs_p || rhs_p)
    return 0;

  /* FIXME: This checking assumes that there are no features with
     duplicate names in either set; enforce that when creating sets.  */

  for (lhs_p = lhs->features; lhs_p; lhs_p = lhs_p->next)
    {
      for (rhs_p = rhs->features; rhs_p; rhs_p = rhs_p->next)
	if (strcmp (lhs_p->name, rhs_p->name) == 0)
	  break;
      if (rhs_p == NULL)
	return 0;

      /* FIXME: Check feature contents, especially for "custom" features
	 which don't have a standard meaning!  */
    }

  return 1;
}

/* Switch the architecture (gdbarch) to one which supports FEATURES.  */

void
arch_set_available_features (const struct gdb_feature_set *features)
{
  struct gdbarch_info info;

  gdbarch_info_init (&info);
  info.feature_set = features;
  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__, "could not update architecture");
}

static struct gdb_feature_set *
copy_features_to_obstack (struct obstack *obstack,
			  const struct gdb_feature_set *features)
{
  struct gdb_feature_set *result;
  struct gdb_available_feature **slot, *orig_feature;

  result = obstack_alloc (obstack, sizeof (struct gdb_feature_set));
  result->obstack = obstack;

  slot = &result->features;
  for (orig_feature = features->features;
       orig_feature;
       orig_feature = orig_feature->next)
    {
      struct gdb_available_feature *feature;
      struct gdb_available_register **reg_slot, *orig_reg;

      feature = OBSTACK_ZALLOC (obstack, struct gdb_available_feature);
      *slot = feature;
      slot = &feature->next;

      memcpy (feature, orig_feature, sizeof (struct gdb_available_feature));
      feature->name = obsavestring (feature->name, strlen (feature->name),
				    obstack);
      if (feature->arch_data)
	feature->arch_data = obsavestring (feature->arch_data,
					   strlen (feature->arch_data),
					   obstack);

      reg_slot = &feature->registers;
      for (orig_reg = orig_feature->registers;
	   orig_reg;
	   orig_reg = orig_reg->next)
	{
	  struct gdb_available_register *reg;

	  reg = OBSTACK_ZALLOC (obstack, struct gdb_available_register);
	  *reg_slot = reg;
	  reg_slot = &reg->next;

	  memcpy (reg, orig_reg, sizeof (struct gdb_available_register));
	  reg->name = obsavestring (reg->name, strlen (reg->name), obstack);
	  if (reg->arch_data)
	    reg->arch_data = obsavestring (reg->arch_data,
					   strlen (reg->arch_data),
					   obstack);
	  if (reg->group)
	    reg->group = obsavestring (reg->group, strlen (reg->group),
				       obstack);
	  if (reg->type)
	    reg->type = obsavestring (reg->type, strlen (reg->type),
				      obstack);
	}
    }

  return result;
}

/* Set an architecture's feature set.  Store BASE_FEATURES in GDBARCH,
   and on the correct obstack.

   This function will update num_regs.  It is the architecture's
   responsibility to handle this if it has pseudo registers.

   FIXME: This interface may need to go away; what if we want to add
   a single additional feature to that provided by the target?  */

void
record_available_features (struct gdbarch *gdbarch,
			   const struct gdb_feature_set *base_features)
{
  struct gdb_available_feature *feature;
  struct gdb_available_register *reg;
  struct gdb_feature_set *features;
  int gdb_regnum, protocol_number;

  features = copy_features_to_obstack (gdbarch_obstack (gdbarch),
				       base_features);
  set_gdbarch_feature_set (gdbarch, features);

  gdb_regnum = gdbarch_num_regs (gdbarch);

  for (feature = features->features; feature; feature = feature->next)
    {
      protocol_number = feature->protocol_number;
      for (reg = feature->registers; reg; reg = reg->next)
	{
	  reg->gdb_regnum = gdb_regnum++;
	  reg->protocol_number = protocol_number++;
	}
    }

  set_gdbarch_num_regs (gdbarch, gdb_regnum);
}

/* Search FEATURES for a register with GDB register number REGNUM.  */

struct gdb_available_register *
find_register (const struct gdb_feature_set *features, int regnum)
{
  struct gdb_available_feature *feature;
  struct gdb_available_register *reg;

  if (features == NULL)
    return NULL;

  for (feature = features->features; feature; feature = feature->next)
    for (reg = feature->registers; reg; reg = reg->next)
      if (reg->gdb_regnum == regnum)
	return reg;

  return NULL;
}

/* Return the type of target-described register REGNUM, if the feature set
   for GDBARCH describes that register.  Otherwise return NULL.  */

struct type *
available_register_type (struct gdbarch *gdbarch, int regnum)
{
  struct gdb_available_register *reg;

  reg = find_register (gdbarch_feature_set (gdbarch), regnum);
  if (reg == NULL)
    return NULL;

  if (reg->type && strcmp (reg->type, "float") == 0)
    {
      if (reg->bitsize == gdbarch_float_bit (gdbarch))
	return builtin_type_float;
      else if (reg->bitsize == gdbarch_double_bit (gdbarch))
	return builtin_type_double;
      else if (reg->bitsize == gdbarch_long_double_bit (gdbarch))
	return builtin_type_long_double;
    }

  if (reg->type && strcmp (reg->type, "int") != 0)
    {
      /* FIXME: Warn the user about an unknown type + size?  */
    }

  /* Use an integer type; default to "long".  */
  if (reg->bitsize == gdbarch_long_bit (gdbarch))
    return builtin_type_long;
  else if (reg->bitsize == TARGET_CHAR_BIT)
    return builtin_type_signed_char;
  else if (reg->bitsize == gdbarch_short_bit (gdbarch))
    return builtin_type_short;
  else if (reg->bitsize == gdbarch_int_bit (gdbarch))
    return builtin_type_int;
  else if (reg->bitsize == gdbarch_long_long_bit (gdbarch))
    return builtin_type_long_long;
  else if (reg->bitsize == gdbarch_ptr_bit (gdbarch))
    /* A bit desperate by this point... */
    return builtin_type_void_data_ptr;
  else
    {
      /* FIXME: Create a new integer type of the appropriate size?  */
      internal_error (__FILE__, __LINE__,
		      _("GDB does not support %ld-bit registers on this target"),
		      reg->bitsize);
    }
}

/* Return the name of target-described register REGNUM, if the feature set
   for GDBARCH describes that register.  Otherwise return NULL.  */

const char *
available_register_name (struct gdbarch *gdbarch, int regnum)
{
  struct gdb_available_register *reg;

  reg = find_register (gdbarch_feature_set (gdbarch), regnum);
  if (reg == NULL)
    return NULL;

  return reg->name;
}

/* Return the target-supplied register of target-described register
   REGNUM, if the feature set for GDBARCH describes that register.
   Otherwise return REGNUM (the legacy 1:1 mapping).  */

int
available_register_target_regnum (struct gdbarch *gdbarch, int regnum)
{
  struct gdb_available_register *reg;

  reg = find_register (gdbarch_feature_set (gdbarch), regnum);
  if (reg == NULL)
    return regnum;

  return reg->protocol_number;
}
@


1.1.2.2
log
@Add RAM caching, checksum, and non-sequential register support.
@
text
@a29 1
#include "sha1.h"
a35 1
#include "gdb_stdint.h"
a55 136


/* Support for caching XML objects read from the target.

   TODO ITEMS:
   - Support caching to disk.
   - Support compiled-in feature cache.
   - Figure out memory management for feature contents strings.
*/


/* Saved information about cached XML objects.  Each cache entry
   corresponds to a file in the cache, or an object fetched from
   the target with one particular annex.  */

struct xml_cache_entry
{
  const char *annex;
  const char *contents;

  union
  {
    /* We use a union to represent the checksum in order to guarantee
       sufficient alignment.  */
    uint32_t words[5];
    unsigned char bytes[20];
  } sha1sum;

  struct xml_cache_entry *next;
};

/* A list of all the cached objects.  */

static struct xml_cache_entry *xml_global_cache;

/* Look for a feature in the cache with ANNEX and CHECKSUM.  If no
   entry is found, return NULL.  */

static const char *
find_xml_feature_in_cache (const char *annex, const unsigned char *checksum)
{
  struct xml_cache_entry *ent;

  for (ent = xml_global_cache; ent != NULL; ent = ent->next)
    {
      if (strcmp (ent->annex, annex) != 0)
	continue;
      if (memcmp (ent->sha1sum.bytes, checksum, 20) != 0)
	continue;

      return ent->contents;
    }

  return NULL;
}

/* Add CONTENTS, which represents the object named ANNEX, to the
   cache if it is not already cached.  */

static void
add_xml_feature_to_cache (const char *annex, const char *contents)
{
  struct xml_cache_entry new_ent;

  /* FIXME: Again, memory allocation?  */
  new_ent.annex = xstrdup (annex);
  new_ent.contents = xstrdup (contents);

  sha1_buffer (new_ent.contents, strlen (new_ent.contents),
	       new_ent.sha1sum.bytes);

  /* If this entry is already in the cache, do not add it again.  */
  if (find_xml_feature_in_cache (annex, new_ent.sha1sum.bytes))
    return;

  new_ent.next = xml_global_cache;

  xml_global_cache = xmalloc (sizeof (struct xml_cache_entry));
  memcpy (xml_global_cache, &new_ent, sizeof (struct xml_cache_entry));
}

/* Convert an ASCII checksum string, CHECKSUM, to a binary blob,
   BYTES.  Returns 0 for success, or -1 if a bad character is
   encountered.  CHECKSUM does not need to be NUL terminated.  */

static int
checksum_to_bytes (char *checksum, unsigned char *bytes)
{
  int i;

  for (i = 0; i < 20; i++)
    {
      int n;
      char c1, c2;

      c1 = checksum[2 * i];
      if (c1 >= '0' && c1 <= '9')
	n = c1 - '0';
      else if (c1 >= 'a' && c1 <= 'f')
	n = c1 - 'a' + 10;
      else if (c1 >= 'A' && c1 <= 'F')
	n = c1 - 'A' + 10;
      else
	return -1;

      n *= 16;

      c2 = checksum[2 * i + 1];
      if (c2 >= '0' && c2 <= '9')
	n += c2 - '0';
      else if (c2 >= 'a' && c2 <= 'f')
	n += c2 - 'a' + 10;
      else if (c2 >= 'A' && c2 <= 'F')
	n += c2 - 'A' + 10;
      else
	return -1;

      bytes[i] = n;
    }

  return 0;
}

/* Baton passed to fetch_available_features_from_target.  */

struct fetch_features_baton
{
  struct target_ops *ops;

  struct fetch_features_checksum
  {
    const char *annex;
    unsigned char checksum[20];
  } *checksums;
};

d58 3
a60 4
   malloc allocated and NUL-terminated.  NAME should be a non-NULL
   string identifying the XML document we want; the top level document
   is "target.xml".  Other calls may be performed for the DTD or
   for xi:include.  */
d63 1
a63 1
fetch_available_features_from_target (const char *name, void *baton_)
d65 1
a65 1
  struct fetch_features_baton *baton = baton_;
d70 3
a72 24
  if (baton->checksums)
    {
      struct fetch_features_checksum *checksum_ent;

      for (checksum_ent = baton->checksums;
	   checksum_ent->annex != NULL;
	   checksum_ent++)
	if (strcmp (checksum_ent->annex, name) == 0)
	  break;

      if (checksum_ent)
	{
	  const char *cached_str;

	  cached_str = find_xml_feature_in_cache (name,
						  checksum_ent->checksum);

	  /* This function always returns something which the caller is
	     responsible for freeing.  So, if we got a match, return a
	     copy of it.  */
	  if (cached_str)
	    return xstrdup (cached_str);
	}
    }
d74 2
a75 2
  len = target_read_whole (baton->ops, TARGET_OBJECT_AVAILABLE_FEATURES,
			   name, &features_buf);
a87 3
  if (baton->checksums)
    add_xml_feature_to_cache (name, features_str);

a94 2
/* TODO: Document \n conventions */

a98 1
  struct fetch_features_baton baton;
d100 4
a103 1
  char *features_str, *checksums_str;
a104 14
  struct cleanup *back_to = make_cleanup (null_cleanup, NULL);

  /* Initialize the baton.  */
  baton.ops = ops;
  baton.checksums = NULL;

  /* Attempt to read checksums from the target.  */
  checksums_str = fetch_available_features_from_target ("CHECKSUMS", &baton);
  if (checksums_str)
    {
      char *p;
      int n_checksums;

      make_cleanup (xfree, checksums_str);
d106 1
a106 80
      /* Allow for one checksum in case there is no trailing newline,
	 and one to serve as a NULL terminator.  */
      n_checksums = 2;

      /* Allocate one additional checksum per newline.  */
      for (p = checksums_str; *p; p++)
	if (*p == '\n')
	  n_checksums++;

      baton.checksums = xmalloc (n_checksums
				 * sizeof (struct fetch_features_checksum));
      make_cleanup (xfree, baton.checksums);

      n_checksums = 0;
      p = checksums_str;
      while (*p)
	{
	  char *field_end;

	  /* Find the first space on the line, marking the end of the
	     checksum.  */
	  field_end = p;
	  while (*field_end && *field_end != '\n'
		 && *field_end != ' ')
	    field_end++;

	  /* Check for a malformed checksum.  */
	  if (*field_end != ' '
	      || field_end - p != 40
	      || checksum_to_bytes (p, baton.checksums[n_checksums].checksum))
	    {
	      /* Skip this line.  */
	      p = field_end;
	      while (*p && *p != '\n')
		p++;
	      if (*p == '\n')
		p++;
	      continue;
	    }

	  *field_end = '\0';

	  /* Skip whitespace after the checksum.  */
	  p = field_end + 1;
	  while (*p == ' ')
	    p++;

	  field_end = p;
	  while (*field_end && *field_end != '\n')
	    field_end++;

	  if (field_end == p)
	    {
	      /* Malformed line; skip it.  */
	      if (*p == '\n')
		p++;
	      continue;
	    }

	  baton.checksums[n_checksums++].annex = p;

	  /* Advance to the next line, inserting a NUL for the end of
	     the annex name if necessary.  */
	  if (*field_end)
	    {
	      *field_end = '\0';
	      p = field_end + 1;
	    }
	  else
	    break;
	}

      baton.checksums[n_checksums].annex = NULL;
    }

  /* FIXME: Memory management: what happens to features_str?  */

  features_str = fetch_available_features_from_target ("target.xml", &baton);
  if (features_str == NULL)
    return NULL;
d113 1
a113 3
					    &baton, 0);

  do_cleanups (back_to);
@


1.1.2.3
log
@Cache items read from the target this session, even without checksums.
@
text
@a77 6
  /* This flag is cleared when we begin reading features, and set
     for new features when they are read.  It is used to prevent
     reading the same file from the target twice (for multiple
     xi:include's or DTD references).  */
  int recently_used;

d93 2
a94 4
/* Look for a feature in the cache with ANNEX and CHECKSUM.  If
   CHECKSUM is NULL, then look for a feature in the cache which has
   already been used this session.  If no entry is found, return
   NULL.  */
d105 1
a105 5

      if (checksum == NULL && !ent->recently_used)
	continue;

      if (checksum != NULL && memcmp (ent->sha1sum.bytes, checksum, 20) != 0)
a107 1
      ent->recently_used = 1;
d129 1
a129 2
  /* If this entry is already in the cache, do not add it again.  This
     call also marks the cache entry as used.  */
a132 1
  new_ent.recently_used = 1;
a207 2
  const unsigned char *checksum = NULL;
  const char *cached_str;
d219 3
a221 3
      if (checksum_ent->annex)
	checksum = checksum_ent->checksum;
    }
d223 2
a224 1
  cached_str = find_xml_feature_in_cache (name, checksum);
d226 7
a232 5
  /* This function always returns something which the caller is
     responsible for freeing.  So, if we got a match, return a
     copy of it.  */
  if (cached_str)
    return xstrdup (cached_str);
a267 1
  struct xml_cache_entry *ent;
a269 5
  /* Reset the recently used flag so that we read any objects
     without checksums from the target.  */
  for (ent = xml_global_cache; ent != NULL; ent = ent->next)
    ent->recently_used = 0;

@


1.1.2.4
log
@Compile in the XML DTD.
Handle XInclude processing as a separate pass.
@
text
@d386 1
a386 1
  ret = available_features_from_xml_string (features,
d410 24
a433 2
  /* Two feature sets are the same if and only if they are described
     by the same XML.  */
d435 1
a435 4
  if (memcmp (lhs->checksum, rhs->checksum, 20) == 0)
    return 1;
  else
    return 0;
@


1.1.2.5
log
@Require targets to provide all their registers if an XML description
is used; fix various bugs this uncovered.  Allow ARM descriptions without
FPA.
@
text
@a26 1
#include "exceptions.h"
d408 2
d422 1
a422 1
arch_set_available_features (struct gdb_feature_set *features)
a423 1
  volatile struct gdb_exception e;
d426 4
a429 12
  TRY_CATCH (e, RETURN_MASK_ERROR)
    {
      gdbarch_info_init (&info);
      info.feature_set = features;

      if (!gdbarch_update_p (info))
	internal_error (__FILE__, __LINE__, "could not update architecture");
    }

  if (e.reason == RETURN_ERROR)
    exception_fprintf (gdb_stderr, e,
		       _("warning: could not use supplied target description: "));
d494 5
a498 5
   This function will update GDBARCH's num_regs.  It is the
   architecture's responsibility to handle this if it has pseudo
   registers.  Before calling this function, num_regs should be
   the number of fixed registers handled by the target code; all
   unassigned registers will be given numbers above that point.  */
d502 1
a502 1
			   struct gdb_feature_set *base_features)
d507 1
a507 1
  int gdb_regnum;
d516 8
a523 3
    for (reg = feature->registers; reg; reg = reg->next)
      if (reg->gdb_regnum == -1)
	reg->gdb_regnum = gdb_regnum++;
d530 1
a530 1
static struct gdb_available_register *
a546 49
/* Search FEATURES for a register with target-specified name NAME,
   and set its GDB register number to REGNUM.  Return 1 if the
   register was found, and 0 if it was not.  This function should
   only be used while initializing a gdbarch.  */

int
available_find_named_register (struct gdb_feature_set *features,
			       const char *name, int regnum)
{
  struct gdb_available_feature *feature;
  struct gdb_available_register *reg;

  if (features == NULL)
    return 0;

  for (feature = features->features; feature; feature = feature->next)
    for (reg = feature->registers; reg; reg = reg->next)
      if (strcmp (reg->name, name) == 0)
	{
	  reg->gdb_regnum = regnum;
	  return 1;
	}

  /* FIXME: Should we sanity check the target-supplied data here for
     duplicate register names?  Right now GDB can't handle duplicated
     register names at all, but in the future it may.  */

  return 0;
}

/* Search FEATURES for a feature with the well-known name NAME,
   which GDB may have special support for.  */

int
available_find_named_feature (struct gdb_feature_set *features,
			      const char *name)
{
  struct gdb_available_feature *feature;

  if (features == NULL)
    return 0;

  for (feature = features->features; feature; feature = feature->next)
    if (strcmp (feature->name, name) == 0)
      return 1;

  return 0;
}

@


1.1.2.6
log
@Update g/G packet support.
@
text
@d52 2
d55 3
a57 3
  (WARNING: This list is out of date and should be redone before submission.
  And moved into gdbint.texi.)
*/
d665 2
a666 1
   REGNUM, or -1 if the register can not be accessed.  */
a672 4
  /* If there is no feature set, use the legacy 1:1 mapping.  */
  if (gdbarch_feature_set (gdbarch) == NULL)
    return regnum;

d675 1
a675 1
    return -1;
@


1.1.2.7
log
@Basic register group support.
@
text
@a28 1
#include "reggroups.h"
a679 41

/* Check whether REGNUM is a member of REGGROUP.  */

/* TODO: This function only supports "info registers", "info float",
   and "info vector".  Registers with group="general" go in general;
   group="float" and group="vector" are similar.  Other specified
   values of group go into all-registers only.  Registers with no
   group specified go to the default function and are handled by
   type.  When we have a hierarchy of features, it may make more
   sense to use that to show registers.  */

int
available_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			       struct reggroup *reggroup)
{
  struct gdb_available_register *reg;

  reg = find_register (gdbarch_feature_set (gdbarch), regnum);
  if (reg != NULL && reg->group != NULL)
    {
      int general_p, float_p, vector_p;

      if (strcmp (reg->group, "general") == 0)
	general_p = 1;
      else if (strcmp (reg->group, "float") == 0)
	float_p = 1;
      else if (strcmp (reg->group, "vector") == 0)
	vector_p = 1;

      if (reggroup == float_reggroup)
	return float_p;

      if (reggroup == vector_reggroup)
	return vector_p;

      if (reggroup == general_reggroup)
	return general_p;
    }

  return default_register_reggroup_p (gdbarch, regnum, reggroup);
}
@


1.1.2.8
log
@Remove readonly; implement save-restore.
@
text
@a719 3
  if (reg != NULL && (group == save_reggroup || group == restore_reggroup))
    return reg->save_restore;

@


1.1.2.9
log
@Make the last few reggroup changes compile.
@
text
@d701 1
a701 1
      int general_p = 0, float_p = 0, vector_p = 0;
d720 1
a720 2
  if (reg != NULL
      && (reggroup == save_reggroup || reggroup == restore_reggroup))
@


1.1.2.10
log
@Add support for VFP DWARF information and VFP single-precision
pseudo-registers.
@
text
@d549 3
a551 4
/* Search FEATURES for a register with target-specified name NAME, and
   set its GDB register number to REGNUM.  Pass REGNUM == -1 if you do
   not need to fix a register number for this register.  Return 1 if
   the register was found, and 0 if it was not.  This function should
@


