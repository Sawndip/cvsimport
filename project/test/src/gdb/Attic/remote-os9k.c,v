head	1.21;
access;
symbols
	gdb_5_3-2002-12-12-release:1.20
	carlton_dictionary-20021115-merge:1.20
	kseitz_interps-20021105-merge:1.20
	kseitz_interps-20021103-merge:1.20
	drow-cplus-merge-20021020:1.20
	drow-cplus-merge-20021025:1.20
	carlton_dictionary-20021025-merge:1.20
	carlton_dictionary-20021011-merge:1.20
	drow-cplus-branch:1.20.0.10
	drow-cplus-branchpoint:1.20
	kseitz_interps-20020930-merge:1.20
	carlton_dictionary-20020927-merge:1.20
	carlton_dictionary-branch:1.20.0.8
	carlton_dictionary-20020920-branchpoint:1.20
	gdb_5_3-branch:1.20.0.6
	gdb_5_3-2002-09-04-branchpoint:1.20
	kseitz_interps-20020829-merge:1.20
	cagney_sysregs-20020825-branch:1.20.0.4
	cagney_sysregs-20020825-branchpoint:1.20
	readline_4_3-import-branch:1.20.0.2
	readline_4_3-import-branchpoint:1.20
	gdb_5_2_1-2002-07-23-release:1.18
	kseitz_interps-20020528-branch:1.19.0.6
	kseitz_interps-20020528-branchpoint:1.19
	cagney_regbuf-20020515-branch:1.19.0.4
	cagney_regbuf-20020515-branchpoint:1.19
	jimb-macro-020506-branch:1.19.0.2
	jimb-macro-020506-branchpoint:1.19
	gdb_5_2-2002-04-29-release:1.18
	gdb_5_2-branch:1.18.0.2
	gdb_5_2-2002-03-03-branchpoint:1.18
	gdb_5_1_1-2002-01-24-release:1.16
	gdb_5_1_0_1-2002-01-03-release:1.16
	cygnus_cvs_20020108_pre:1.17
	gdb_5_1_0_1-2002-01-03-branchpoint:1.16
	gdb_5_1_0_1-2002-01-03-branch:1.16.0.6
	gdb_5_1-2001-11-21-release:1.16
	gdb_s390-2001-09-26-branch:1.16.0.4
	gdb_s390-2001-09-26-branchpoint:1.16
	gdb_5_1-2001-07-29-branch:1.16.0.2
	gdb_5_1-2001-07-29-branchpoint:1.16
	dberlin-typesystem-branch:1.14.0.2
	dberlin-typesystem-branchpoint:1.14
	gdb-post-ptid_t-2001-05-03:1.14
	gdb-pre-ptid_t-2001-05-03:1.13
	insight-precleanup-2001-01-01:1.7
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.7
	insight-2000-02-04:1.1.1.7
	gdb-2000-02-04:1.1.1.7
	gdb-2000-02-02:1.1.1.7
	gdb-2000-02-01:1.1.1.7
	gdb-2000-01-31:1.1.1.7
	gdb-2000-01-26:1.1.1.7
	gdb-2000-01-24:1.1.1.7
	gdb-2000-01-17:1.1.1.7
	gdb-2000-01-10:1.1.1.7
	gdb-2000-01-05:1.1.1.7
	gdb-1999-12-21:1.1.1.7
	gdb-1999-12-13:1.1.1.7
	gdb-1999-12-07:1.1.1.7
	gdb-1999-12-06:1.1.1.7
	gdb-1999-11-16:1.1.1.7
	gdb-1999-11-08:1.1.1.7
	gdb-1999-11-01:1.1.1.7
	gdb-1999-10-25:1.1.1.7
	gdb-1999-10-18:1.1.1.7
	gdb-1999-10-11:1.1.1.7
	gdb-1999-10-04:1.1.1.7
	gdb-1999-09-28:1.1.1.7
	gdb-1999-09-21:1.1.1.7
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.5
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.5
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.21
date	2002.12.16.20.39.10;	author cagney;	state dead;
branches;
next	1.20;

1.20
date	2002.07.16.15.19.18;	author cagney;	state Exp;
branches
	1.20.8.1
	1.20.10.1;
next	1.19;

1.19
date	2002.04.29.11.01.13;	author muller;	state Exp;
branches
	1.19.6.1;
next	1.18;

1.18
date	2002.01.19.03.32.38;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.05.04.30.18;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.15.20.34.13;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.11.17.52.32;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.04.04.15.26;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.14.19.23.02;	author jtc;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.06.08.21.12;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.02.23.04.14;	author jtc;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.02.19.14.33;	author jtc;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.23.22.48.55;	author jtc;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.10.05.17.25;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.01.00.12.10;	author jtc;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.27.22.30.29;	author ezannoni;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.04.16.52.34;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.47;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.05.17.53.42;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.17.22.48;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.09.12;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.09.21.33.47;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.09.08.23.59.27;	author shebs;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.09.22.03.24.55;	author jsm;	state Exp;
branches;
next	;

1.19.6.1
date	2002.07.22.21.47.02;	author kseitz;	state Exp;
branches;
next	;

1.20.8.1
date	2002.12.23.19.38.40;	author carlton;	state dead;
branches;
next	;

1.20.10.1
date	2003.12.14.20.27.28;	author drow;	state dead;
branches;
next	;


desc
@@


1.21
log
@2002-12-16  Andrew Cagney  <ac131313@@redhat.com>

	* config/arc/arc.mt, config/arc/tm-arc.h: Delete.
	* config/d30v/d30v.mt, config/d30v/tm-d30v.h: Delete.
	* config/fr30/fr30.mt, config/fr30/tm-fr30.h: Delete.
	* config/i386/i386aix.mh, config/i386/i386aix.mt: Delete.
	* config/i386/i386m3.mh, config/i386/i386m3.mt: Delete.
	* config/i386/i386mach.mh, config/i386/i386os9k.mt: Delete.
	* config/i386/nm-i386aix.h, config/i386/nm-i386mach.h: Delete.
	* config/i386/nm-m3.h, config/i386/tm-i386aix.h: Delete.
	* config/i386/tm-i386m3.h, config/i386/tm-i386mk.h: Delete.
	* config/i386/xm-i386aix.h, config/i386/xm-i386m3.h: Delete.
	* config/i386/xm-i386mach.h, config/i386/xm-i386mk.h: Delete.
	* config/i960/mon960.mt, config/i960/nindy960.mt: Delete.
	* config/i960/tm-i960.h, config/i960/tm-mon960.h: Delete.
	* config/i960/tm-nindy960.h, config/i960/tm-vx960.h: Delete.
	* config/i960/vxworks960.mt, config/m68k/apollo68b.mh: Delete.
	* config/m68k/apollo68b.mt, config/m68k/apollo68v.mh: Delete.
	* config/m68k/hp300bsd.mh, config/m68k/hp300bsd.mt: Delete.
	* config/m68k/hp300hpux.mh, config/m68k/hp300hpux.mt: Delete.
	* config/m88k/delta88.mh, config/m88k/delta88.mt: Delete.
	* config/m88k/delta88v4.mh, config/m88k/delta88v4.mt: Delete.
	* config/m88k/m88k.mh, config/m88k/m88k.mt: Delete.
	* config/m88k/nm-delta88v4.h, config/m88k/nm-m88k.h: Delete.
	* config/m88k/tm-delta88.h, config/m88k/tm-delta88v4.h: Delete.
	* config/m88k/tm-m88k.h, config/m88k/xm-delta88.h: Delete.
	* config/m88k/xm-dgux.h: Delete.
	* fr30-tdep.c, i386aix-nat.c, i386m3-nat.c: Delete.
	* i386mach-nat.c, i960-tdep.c, m88k-nat.c: Delete.
	* os9kread.c, remote-bug.c, remote-nindy.c: Delete.
	* remote-nrom.c, remote-os9k.c, remote-vx960.c: Delete.
	* d30v-tdep.c, arc-tdep.c, cxux-nat.c, dst.h, dstread.c: Delete.
	* ch-exp.c, ch-lang.c, ch-lang.h, ch-typeprint.c: Delete.
	* ch-valprint.c: Delete.
@
text
@// OBSOLETE /* Remote debugging interface for boot monitors, for GDB.
// OBSOLETE 
// OBSOLETE    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
// OBSOLETE    2000, 2001, 2002 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /* This file was derived from remote-eb.c, which did a similar job, but for
// OBSOLETE    an AMD-29K running EBMON.  That file was in turn derived from remote.c
// OBSOLETE    as mentioned in the following comment (left in for comic relief):
// OBSOLETE 
// OBSOLETE    "This is like remote.c but is for a different situation--
// OBSOLETE    having a PC running os9000 hook up with a unix machine with
// OBSOLETE    a serial line, and running ctty com2 on the PC. os9000 has a debug
// OBSOLETE    monitor called ROMBUG running.  Not to mention that the PC
// OBSOLETE    has PC/NFS, so it can access the same executables that gdb can,
// OBSOLETE    over the net in real time."
// OBSOLETE 
// OBSOLETE    In reality, this module talks to a debug monitor called 'ROMBUG', which
// OBSOLETE    We communicate with ROMBUG via a direct serial line, the network version
// OBSOLETE    of ROMBUG is not available yet.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE /* FIXME This file needs to be rewritten if it's to work again, either
// OBSOLETE    to self-contained or to use the new monitor interface.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "gdb_string.h"
// OBSOLETE #include <sys/types.h>
// OBSOLETE #include "command.h"
// OBSOLETE #include "serial.h"
// OBSOLETE #include "monitor.h"
// OBSOLETE #include "remote-utils.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "symfile.h"
// OBSOLETE #include "objfiles.h"
// OBSOLETE #include "gdb-stabs.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE struct cmd_list_element *showlist;
// OBSOLETE extern struct target_ops rombug_ops;	/* Forward declaration */
// OBSOLETE extern struct monitor_ops rombug_cmds;	/* Forward declaration */
// OBSOLETE extern struct cmd_list_element *setlist;
// OBSOLETE extern struct cmd_list_element *unsetlist;
// OBSOLETE extern int attach_flag;
// OBSOLETE 
// OBSOLETE static void rombug_close ();
// OBSOLETE static void rombug_fetch_register ();
// OBSOLETE static void rombug_fetch_registers ();
// OBSOLETE static void rombug_store_register ();
// OBSOLETE #if 0
// OBSOLETE static int sr_get_debug ();	/* flag set by "set remotedebug" */
// OBSOLETE #endif
// OBSOLETE static int hashmark;		/* flag set by "set hash" */
// OBSOLETE static int rombug_is_open = 0;
// OBSOLETE 
// OBSOLETE /* FIXME: Replace with sr_get_debug ().  */
// OBSOLETE #define LOG_FILE "monitor.log"
// OBSOLETE FILE *log_file;
// OBSOLETE static int monitor_log = 0;
// OBSOLETE static int tty_xon = 0;
// OBSOLETE static int tty_xoff = 0;
// OBSOLETE 
// OBSOLETE static int timeout = 10;
// OBSOLETE static int is_trace_mode = 0;
// OBSOLETE /* Descriptor for I/O to remote machine.  Initialize it to NULL */
// OBSOLETE static struct serial *monitor_desc = NULL;
// OBSOLETE 
// OBSOLETE static CORE_ADDR bufaddr = 0;
// OBSOLETE static int buflen = 0;
// OBSOLETE static char readbuf[16];
// OBSOLETE 
// OBSOLETE /* Send data to monitor.  Works just like printf. */
// OBSOLETE static void
// OBSOLETE printf_monitor (char *pattern,...)
// OBSOLETE {
// OBSOLETE   va_list args;
// OBSOLETE   char buf[200];
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   va_start (args, pattern);
// OBSOLETE 
// OBSOLETE   vsprintf (buf, pattern, args);
// OBSOLETE   va_end (args);
// OBSOLETE 
// OBSOLETE   if (serial_write (monitor_desc, buf, strlen (buf)))
// OBSOLETE     fprintf_unfiltered (gdb_stderr, "serial_write failed: %s\n",
// OBSOLETE 			safe_strerror (errno));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Read a character from the remote system, doing all the fancy timeout stuff */
// OBSOLETE static int
// OBSOLETE readchar (int timeout)
// OBSOLETE {
// OBSOLETE   int c;
// OBSOLETE 
// OBSOLETE   c = serial_readchar (monitor_desc, timeout);
// OBSOLETE 
// OBSOLETE   if (sr_get_debug ())
// OBSOLETE     putchar (c & 0x7f);
// OBSOLETE 
// OBSOLETE   if (monitor_log && isascii (c))
// OBSOLETE     putc (c & 0x7f, log_file);
// OBSOLETE 
// OBSOLETE   if (c >= 0)
// OBSOLETE     return c & 0x7f;
// OBSOLETE 
// OBSOLETE   if (c == SERIAL_TIMEOUT)
// OBSOLETE     {
// OBSOLETE       if (timeout == 0)
// OBSOLETE 	return c;		/* Polls shouldn't generate timeout errors */
// OBSOLETE 
// OBSOLETE       error ("Timeout reading from remote system.");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   perror_with_name ("remote-monitor");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Scan input from the remote system, until STRING is found.  If DISCARD is
// OBSOLETE    non-zero, then discard non-matching input, else print it out.
// OBSOLETE    Let the user break out immediately.  */
// OBSOLETE static void
// OBSOLETE expect (char *string, int discard)
// OBSOLETE {
// OBSOLETE   char *p = string;
// OBSOLETE   int c;
// OBSOLETE 
// OBSOLETE   if (sr_get_debug ())
// OBSOLETE     printf ("Expecting \"%s\"\n", string);
// OBSOLETE 
// OBSOLETE   immediate_quit++;
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       c = readchar (timeout);
// OBSOLETE       if (!isascii (c))
// OBSOLETE 	continue;
// OBSOLETE       if (c == *p++)
// OBSOLETE 	{
// OBSOLETE 	  if (*p == '\0')
// OBSOLETE 	    {
// OBSOLETE 	      immediate_quit--;
// OBSOLETE 	      if (sr_get_debug ())
// OBSOLETE 		printf ("\nMatched\n");
// OBSOLETE 	      return;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (!discard)
// OBSOLETE 	    {
// OBSOLETE 	      fwrite (string, 1, (p - 1) - string, stdout);
// OBSOLETE 	      putchar ((char) c);
// OBSOLETE 	      fflush (stdout);
// OBSOLETE 	    }
// OBSOLETE 	  p = string;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Keep discarding input until we see the ROMBUG prompt.
// OBSOLETE 
// OBSOLETE    The convention for dealing with the prompt is that you
// OBSOLETE    o give your command
// OBSOLETE    o *then* wait for the prompt.
// OBSOLETE 
// OBSOLETE    Thus the last thing that a procedure does with the serial line
// OBSOLETE    will be an expect_prompt().  Exception:  rombug_resume does not
// OBSOLETE    wait for the prompt, because the terminal is being handed over
// OBSOLETE    to the inferior.  However, the next thing which happens after that
// OBSOLETE    is a rombug_wait which does wait for the prompt.
// OBSOLETE    Note that this includes abnormal exit, e.g. error().  This is
// OBSOLETE    necessary to prevent getting into states from which we can't
// OBSOLETE    recover.  */
// OBSOLETE static void
// OBSOLETE expect_prompt (int discard)
// OBSOLETE {
// OBSOLETE   if (monitor_log)
// OBSOLETE     /* This is a convenient place to do this.  The idea is to do it often
// OBSOLETE        enough that we never lose much data if we terminate abnormally.  */
// OBSOLETE     fflush (log_file);
// OBSOLETE 
// OBSOLETE   if (is_trace_mode)
// OBSOLETE     {
// OBSOLETE       expect ("trace", discard);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       expect (PROMPT, discard);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Get a hex digit from the remote system & return its value.
// OBSOLETE    If ignore_space is nonzero, ignore spaces (not newline, tab, etc).  */
// OBSOLETE static int
// OBSOLETE get_hex_digit (int ignore_space)
// OBSOLETE {
// OBSOLETE   int ch;
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       ch = readchar (timeout);
// OBSOLETE       if (ch >= '0' && ch <= '9')
// OBSOLETE 	return ch - '0';
// OBSOLETE       else if (ch >= 'A' && ch <= 'F')
// OBSOLETE 	return ch - 'A' + 10;
// OBSOLETE       else if (ch >= 'a' && ch <= 'f')
// OBSOLETE 	return ch - 'a' + 10;
// OBSOLETE       else if (ch == ' ' && ignore_space)
// OBSOLETE 	;
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  expect_prompt (1);
// OBSOLETE 	  error ("Invalid hex digit from remote system.");
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Get a byte from monitor and put it in *BYT.  Accept any number
// OBSOLETE    leading spaces.  */
// OBSOLETE static void
// OBSOLETE get_hex_byte (char *byt)
// OBSOLETE {
// OBSOLETE   int val;
// OBSOLETE 
// OBSOLETE   val = get_hex_digit (1) << 4;
// OBSOLETE   val |= get_hex_digit (0);
// OBSOLETE   *byt = val;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Get N 32-bit words from remote, each preceded by a space,
// OBSOLETE    and put them in registers starting at REGNO.  */
// OBSOLETE static void
// OBSOLETE get_hex_regs (int n, int regno)
// OBSOLETE {
// OBSOLETE   long val;
// OBSOLETE   int i;
// OBSOLETE   unsigned char b;
// OBSOLETE 
// OBSOLETE   for (i = 0; i < n; i++)
// OBSOLETE     {
// OBSOLETE       int j;
// OBSOLETE 
// OBSOLETE       val = 0;
// OBSOLETE       for (j = 0; j < 4; j++)
// OBSOLETE 	{
// OBSOLETE 	  get_hex_byte (&b);
// OBSOLETE 	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
// OBSOLETE 	    val = (val << 8) + b;
// OBSOLETE 	  else
// OBSOLETE 	    val = val + (b << (j * 8));
// OBSOLETE 	}
// OBSOLETE       supply_register (regno++, (char *) &val);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* This is called not only when we first attach, but also when the
// OBSOLETE    user types "run" after having attached.  */
// OBSOLETE static void
// OBSOLETE rombug_create_inferior (char *execfile, char *args, char **env)
// OBSOLETE {
// OBSOLETE   int entry_pt;
// OBSOLETE 
// OBSOLETE   if (args && *args)
// OBSOLETE     error ("Can't pass arguments to remote ROMBUG process");
// OBSOLETE 
// OBSOLETE   if (execfile == 0 || exec_bfd == 0)
// OBSOLETE     error ("No executable file specified");
// OBSOLETE 
// OBSOLETE   entry_pt = (int) bfd_get_start_address (exec_bfd);
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fputs ("\nIn Create_inferior()", log_file);
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* The "process" (board) is already stopped awaiting our commands, and
// OBSOLETE    the program is already downloaded.  We just set its PC and go.  */
// OBSOLETE 
// OBSOLETE   init_wait_for_inferior ();
// OBSOLETE   proceed ((CORE_ADDR) entry_pt, TARGET_SIGNAL_DEFAULT, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Open a connection to a remote debugger.
// OBSOLETE    NAME is the filename used for communication.  */
// OBSOLETE 
// OBSOLETE static char dev_name[100];
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_open (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   if (args == NULL)
// OBSOLETE     error ("Use `target RomBug DEVICE-NAME' to use a serial port, or \n\
// OBSOLETE `target RomBug HOST-NAME:PORT-NUMBER' to use a network connection.");
// OBSOLETE 
// OBSOLETE   target_preopen (from_tty);
// OBSOLETE 
// OBSOLETE   if (rombug_is_open)
// OBSOLETE     unpush_target (&rombug_ops);
// OBSOLETE 
// OBSOLETE   strcpy (dev_name, args);
// OBSOLETE   monitor_desc = serial_open (dev_name);
// OBSOLETE   if (monitor_desc == NULL)
// OBSOLETE     perror_with_name (dev_name);
// OBSOLETE 
// OBSOLETE   /* if baud rate is set by 'set remotebaud' */
// OBSOLETE   if (serial_setbaudrate (monitor_desc, sr_get_baud_rate ()))
// OBSOLETE     {
// OBSOLETE       serial_close (monitor_desc);
// OBSOLETE       perror_with_name ("RomBug");
// OBSOLETE     }
// OBSOLETE   serial_raw (monitor_desc);
// OBSOLETE   if (tty_xon || tty_xoff)
// OBSOLETE     {
// OBSOLETE       struct hardware_ttystate
// OBSOLETE 	{
// OBSOLETE 	  struct termios t;
// OBSOLETE 	}
// OBSOLETE        *tty_s;
// OBSOLETE 
// OBSOLETE       tty_s = (struct hardware_ttystate *) serial_get_tty_state (monitor_desc);
// OBSOLETE       if (tty_xon)
// OBSOLETE 	tty_s->t.c_iflag |= IXON;
// OBSOLETE       if (tty_xoff)
// OBSOLETE 	tty_s->t.c_iflag |= IXOFF;
// OBSOLETE       serial_set_tty_state (monitor_desc, (serial_ttystate) tty_s);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   rombug_is_open = 1;
// OBSOLETE 
// OBSOLETE   log_file = fopen (LOG_FILE, "w");
// OBSOLETE   if (log_file == NULL)
// OBSOLETE     perror_with_name (LOG_FILE);
// OBSOLETE 
// OBSOLETE   push_monitor (&rombug_cmds);
// OBSOLETE   printf_monitor ("\r");	/* CR wakes up monitor */
// OBSOLETE   expect_prompt (1);
// OBSOLETE   push_target (&rombug_ops);
// OBSOLETE   attach_flag = 1;
// OBSOLETE 
// OBSOLETE   if (from_tty)
// OBSOLETE     printf ("Remote %s connected to %s\n", target_shortname,
// OBSOLETE 	    dev_name);
// OBSOLETE 
// OBSOLETE   rombug_fetch_registers ();
// OBSOLETE 
// OBSOLETE   printf_monitor ("ov e \r");
// OBSOLETE   expect_prompt (1);
// OBSOLETE   bufaddr = 0;
// OBSOLETE   buflen = 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Close out all files and local state before this target loses control.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_close (int quitting)
// OBSOLETE {
// OBSOLETE   if (rombug_is_open)
// OBSOLETE     {
// OBSOLETE       serial_close (monitor_desc);
// OBSOLETE       monitor_desc = NULL;
// OBSOLETE       rombug_is_open = 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (log_file)
// OBSOLETE     {
// OBSOLETE       if (ferror (log_file))
// OBSOLETE 	fprintf_unfiltered (gdb_stderr, "Error writing log file.\n");
// OBSOLETE       if (fclose (log_file) != 0)
// OBSOLETE 	fprintf_unfiltered (gdb_stderr, "Error closing log file.\n");
// OBSOLETE       log_file = 0;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE rombug_link (char *mod_name, CORE_ADDR *text_reloc)
// OBSOLETE {
// OBSOLETE   int i, j;
// OBSOLETE   unsigned long val;
// OBSOLETE   unsigned char b;
// OBSOLETE 
// OBSOLETE   printf_monitor ("l %s \r", mod_name);
// OBSOLETE   expect_prompt (1);
// OBSOLETE   printf_monitor (".r \r");
// OBSOLETE   expect (REG_DELIM, 1);
// OBSOLETE   for (i = 0; i <= 7; i++)
// OBSOLETE     {
// OBSOLETE       val = 0;
// OBSOLETE       for (j = 0; j < 4; j++)
// OBSOLETE 	{
// OBSOLETE 	  get_hex_byte (&b);
// OBSOLETE 	  val = (val << 8) + b;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   expect_prompt (1);
// OBSOLETE   *text_reloc = val;
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Terminate the open connection to the remote debugger.
// OBSOLETE    Use this when you want to detach and do something else
// OBSOLETE    with your gdb.  */
// OBSOLETE static void
// OBSOLETE rombug_detach (int from_tty)
// OBSOLETE {
// OBSOLETE   if (attach_flag)
// OBSOLETE     {
// OBSOLETE       printf_monitor (GO_CMD);
// OBSOLETE       attach_flag = 0;
// OBSOLETE     }
// OBSOLETE   pop_target ();		/* calls rombug_close to do the real work */
// OBSOLETE   if (from_tty)
// OBSOLETE     printf ("Ending remote %s debugging\n", target_shortname);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Tell the remote machine to resume.
// OBSOLETE  */
// OBSOLETE static void
// OBSOLETE rombug_resume (ptid_t ptid, int step, enum target_signal sig)
// OBSOLETE {
// OBSOLETE   if (monitor_log)
// OBSOLETE     fprintf (log_file, "\nIn Resume (step=%d, sig=%d)\n", step, sig);
// OBSOLETE 
// OBSOLETE   if (step)
// OBSOLETE     {
// OBSOLETE       is_trace_mode = 1;
// OBSOLETE       printf_monitor (STEP_CMD);
// OBSOLETE       /* wait for the echo.  **
// OBSOLETE          expect (STEP_CMD, 1);
// OBSOLETE        */
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       printf_monitor (GO_CMD);
// OBSOLETE       /* swallow the echo.  **
// OBSOLETE          expect (GO_CMD, 1);
// OBSOLETE        */
// OBSOLETE     }
// OBSOLETE   bufaddr = 0;
// OBSOLETE   buflen = 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Wait until the remote machine stops, then return,
// OBSOLETE  * storing status in status just as `wait' would.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static ptid *
// OBSOLETE rombug_wait (ptid_t ptid, struct target_waitstatus *status)
// OBSOLETE {
// OBSOLETE   int old_timeout = timeout;
// OBSOLETE   struct section_offsets *offs;
// OBSOLETE   CORE_ADDR addr, pc;
// OBSOLETE   struct obj_section *obj_sec;
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fputs ("\nIn wait ()", log_file);
// OBSOLETE 
// OBSOLETE   status->kind = TARGET_WAITKIND_EXITED;
// OBSOLETE   status->value.integer = 0;
// OBSOLETE 
// OBSOLETE   timeout = -1;			/* Don't time out -- user program is running. */
// OBSOLETE   expect ("eax:", 0);		/* output any message before register display */
// OBSOLETE   expect_prompt (1);		/* Wait for prompt, outputting extraneous text */
// OBSOLETE 
// OBSOLETE   status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE   status->value.sig = TARGET_SIGNAL_TRAP;
// OBSOLETE   timeout = old_timeout;
// OBSOLETE   rombug_fetch_registers ();
// OBSOLETE   bufaddr = 0;
// OBSOLETE   buflen = 0;
// OBSOLETE   pc = read_register (PC_REGNUM);
// OBSOLETE   addr = read_register (DATABASE_REG);
// OBSOLETE   obj_sec = find_pc_section (pc);
// OBSOLETE   if (obj_sec != NULL)
// OBSOLETE     {
// OBSOLETE       if (obj_sec->objfile != symfile_objfile)
// OBSOLETE 	new_symfile_objfile (obj_sec->objfile, 1, 0);
// OBSOLETE       offs = (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
// OBSOLETE       memcpy (offs, symfile_objfile->section_offsets, SIZEOF_SECTION_OFFSETS);
// OBSOLETE       offs->offsets[SECT_OFF_DATA (symfile_objfile)]  = addr;
// OBSOLETE       offs->offsets[SECT_OFF_BSS (symfile_objfile)]  = addr;
// OBSOLETE 
// OBSOLETE       objfile_relocate (symfile_objfile, offs);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return inferior_ptid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the name of register number regno in the form input and output by
// OBSOLETE    monitor.  Currently, register_names just happens to contain exactly what
// OBSOLETE    monitor wants.  Lets take advantage of that just as long as possible! */
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE get_reg_name (int regno)
// OBSOLETE {
// OBSOLETE   static char buf[50];
// OBSOLETE   char *p;
// OBSOLETE   char *b;
// OBSOLETE 
// OBSOLETE   b = buf;
// OBSOLETE 
// OBSOLETE   if (regno < 0)
// OBSOLETE     return ("");
// OBSOLETE /*
// OBSOLETE    for (p = REGISTER_NAME (regno); *p; p++)
// OBSOLETE    *b++ = toupper(*p);
// OBSOLETE    *b = '\000';
// OBSOLETE  */
// OBSOLETE   p = (char *) REGISTER_NAME (regno);
// OBSOLETE   return p;
// OBSOLETE /*
// OBSOLETE    return buf;
// OBSOLETE  */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* read the remote registers into the block regs.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_fetch_registers (void)
// OBSOLETE {
// OBSOLETE   int regno, j, i;
// OBSOLETE   long val;
// OBSOLETE   unsigned char b;
// OBSOLETE 
// OBSOLETE   printf_monitor (GET_REG);
// OBSOLETE   expect ("eax:", 1);
// OBSOLETE   expect ("\n", 1);
// OBSOLETE   get_hex_regs (1, 0);
// OBSOLETE   get_hex_regs (1, 3);
// OBSOLETE   get_hex_regs (1, 1);
// OBSOLETE   get_hex_regs (1, 2);
// OBSOLETE   get_hex_regs (1, 6);
// OBSOLETE   get_hex_regs (1, 7);
// OBSOLETE   get_hex_regs (1, 5);
// OBSOLETE   get_hex_regs (1, 4);
// OBSOLETE   for (regno = 8; regno <= 15; regno++)
// OBSOLETE     {
// OBSOLETE       expect (REG_DELIM, 1);
// OBSOLETE       if (regno >= 8 && regno <= 13)
// OBSOLETE 	{
// OBSOLETE 	  val = 0;
// OBSOLETE 	  for (j = 0; j < 2; j++)
// OBSOLETE 	    {
// OBSOLETE 	      get_hex_byte (&b);
// OBSOLETE 	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
// OBSOLETE 		val = (val << 8) + b;
// OBSOLETE 	      else
// OBSOLETE 		val = val + (b << (j * 8));
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  if (regno == 8)
// OBSOLETE 	    i = 10;
// OBSOLETE 	  if (regno >= 9 && regno <= 12)
// OBSOLETE 	    i = regno + 3;
// OBSOLETE 	  if (regno == 13)
// OBSOLETE 	    i = 11;
// OBSOLETE 	  supply_register (i, (char *) &val);
// OBSOLETE 	}
// OBSOLETE       else if (regno == 14)
// OBSOLETE 	{
// OBSOLETE 	  get_hex_regs (1, PC_REGNUM);
// OBSOLETE 	}
// OBSOLETE       else if (regno == 15)
// OBSOLETE 	{
// OBSOLETE 	  get_hex_regs (1, 9);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  val = 0;
// OBSOLETE 	  supply_register (regno, (char *) &val);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   is_trace_mode = 0;
// OBSOLETE   expect_prompt (1);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Fetch register REGNO, or all registers if REGNO is -1.
// OBSOLETE    Returns errno value.  */
// OBSOLETE static void
// OBSOLETE rombug_fetch_register (int regno)
// OBSOLETE {
// OBSOLETE   int val, j;
// OBSOLETE   unsigned char b;
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     {
// OBSOLETE       fprintf (log_file, "\nIn Fetch Register (reg=%s)\n", get_reg_name (regno));
// OBSOLETE       fflush (log_file);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (regno < 0)
// OBSOLETE     {
// OBSOLETE       rombug_fetch_registers ();
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       char *name = get_reg_name (regno);
// OBSOLETE       printf_monitor (GET_REG);
// OBSOLETE       if (regno >= 10 && regno <= 15)
// OBSOLETE 	{
// OBSOLETE 	  expect ("\n", 1);
// OBSOLETE 	  expect ("\n", 1);
// OBSOLETE 	  expect (name, 1);
// OBSOLETE 	  expect (REG_DELIM, 1);
// OBSOLETE 	  val = 0;
// OBSOLETE 	  for (j = 0; j < 2; j++)
// OBSOLETE 	    {
// OBSOLETE 	      get_hex_byte (&b);
// OBSOLETE 	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
// OBSOLETE 		val = (val << 8) + b;
// OBSOLETE 	      else
// OBSOLETE 		val = val + (b << (j * 8));
// OBSOLETE 	    }
// OBSOLETE 	  supply_register (regno, (char *) &val);
// OBSOLETE 	}
// OBSOLETE       else if (regno == 8 || regno == 9)
// OBSOLETE 	{
// OBSOLETE 	  expect ("\n", 1);
// OBSOLETE 	  expect ("\n", 1);
// OBSOLETE 	  expect ("\n", 1);
// OBSOLETE 	  expect (name, 1);
// OBSOLETE 	  expect (REG_DELIM, 1);
// OBSOLETE 	  get_hex_regs (1, regno);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  expect (name, 1);
// OBSOLETE 	  expect (REG_DELIM, 1);
// OBSOLETE 	  expect ("\n", 1);
// OBSOLETE 	  get_hex_regs (1, 0);
// OBSOLETE 	  get_hex_regs (1, 3);
// OBSOLETE 	  get_hex_regs (1, 1);
// OBSOLETE 	  get_hex_regs (1, 2);
// OBSOLETE 	  get_hex_regs (1, 6);
// OBSOLETE 	  get_hex_regs (1, 7);
// OBSOLETE 	  get_hex_regs (1, 5);
// OBSOLETE 	  get_hex_regs (1, 4);
// OBSOLETE 	}
// OBSOLETE       expect_prompt (1);
// OBSOLETE     }
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store the remote registers from the contents of the block REGS.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_store_registers (void)
// OBSOLETE {
// OBSOLETE   int regno;
// OBSOLETE 
// OBSOLETE   for (regno = 0; regno <= PC_REGNUM; regno++)
// OBSOLETE     rombug_store_register (regno);
// OBSOLETE 
// OBSOLETE   registers_changed ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store register REGNO, or all if REGNO == 0.
// OBSOLETE    return errno value.  */
// OBSOLETE static void
// OBSOLETE rombug_store_register (int regno)
// OBSOLETE {
// OBSOLETE   char *name;
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fprintf (log_file, "\nIn Store_register (regno=%d)\n", regno);
// OBSOLETE 
// OBSOLETE   if (regno == -1)
// OBSOLETE     rombug_store_registers ();
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if (sr_get_debug ())
// OBSOLETE 	printf ("Setting register %s to 0x%x\n", get_reg_name (regno), read_register (regno));
// OBSOLETE 
// OBSOLETE       name = get_reg_name (regno);
// OBSOLETE       if (name == 0)
// OBSOLETE 	return;
// OBSOLETE       printf_monitor (SET_REG, name, read_register (regno));
// OBSOLETE 
// OBSOLETE       is_trace_mode = 0;
// OBSOLETE       expect_prompt (1);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Get ready to modify the registers array.  On machines which store
// OBSOLETE    individual registers, this doesn't need to do anything.  On machines
// OBSOLETE    which store all the registers in one fell swoop, this makes sure
// OBSOLETE    that registers contains all the registers from the program being
// OBSOLETE    debugged.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_prepare_to_store (void)
// OBSOLETE {
// OBSOLETE   /* Do nothing, since we can store individual regs */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_files_info (void)
// OBSOLETE {
// OBSOLETE   printf ("\tAttached to %s at %d baud.\n",
// OBSOLETE 	  dev_name, sr_get_baud_rate ());
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Copy LEN bytes of data from debugger memory at MYADDR
// OBSOLETE    to inferior's memory at MEMADDR.  Returns length moved.  */
// OBSOLETE static int
// OBSOLETE rombug_write_inferior_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   char buf[10];
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fprintf (log_file, "\nIn Write_inferior_memory (memaddr=%x, len=%d)\n", memaddr, len);
// OBSOLETE 
// OBSOLETE   printf_monitor (MEM_SET_CMD, memaddr);
// OBSOLETE   for (i = 0; i < len; i++)
// OBSOLETE     {
// OBSOLETE       expect (CMD_DELIM, 1);
// OBSOLETE       printf_monitor ("%x \r", myaddr[i]);
// OBSOLETE       if (sr_get_debug ())
// OBSOLETE 	printf ("\nSet 0x%x to 0x%x\n", memaddr + i, myaddr[i]);
// OBSOLETE     }
// OBSOLETE   expect (CMD_DELIM, 1);
// OBSOLETE   if (CMD_END)
// OBSOLETE     printf_monitor (CMD_END);
// OBSOLETE   is_trace_mode = 0;
// OBSOLETE   expect_prompt (1);
// OBSOLETE 
// OBSOLETE   bufaddr = 0;
// OBSOLETE   buflen = 0;
// OBSOLETE   return len;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Read LEN bytes from inferior memory at MEMADDR.  Put the result
// OBSOLETE    at debugger address MYADDR.  Returns length moved.  */
// OBSOLETE static int
// OBSOLETE rombug_read_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
// OBSOLETE {
// OBSOLETE   int i, j;
// OBSOLETE 
// OBSOLETE   /* Number of bytes read so far.  */
// OBSOLETE   int count;
// OBSOLETE 
// OBSOLETE   /* Starting address of this pass.  */
// OBSOLETE   unsigned long startaddr;
// OBSOLETE 
// OBSOLETE   /* Number of bytes to read in this pass.  */
// OBSOLETE   int len_this_pass;
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fprintf (log_file, "\nIn Read_inferior_memory (memaddr=%x, len=%d)\n", memaddr, len);
// OBSOLETE 
// OBSOLETE   /* Note that this code works correctly if startaddr is just less
// OBSOLETE      than UINT_MAX (well, really CORE_ADDR_MAX if there was such a
// OBSOLETE      thing).  That is, something like
// OBSOLETE      rombug_read_bytes (CORE_ADDR_MAX - 4, foo, 4)
// OBSOLETE      works--it never adds len To memaddr and gets 0.  */
// OBSOLETE   /* However, something like
// OBSOLETE      rombug_read_bytes (CORE_ADDR_MAX - 3, foo, 4)
// OBSOLETE      doesn't need to work.  Detect it and give up if there's an attempt
// OBSOLETE      to do that.  */
// OBSOLETE   if (((memaddr - 1) + len) < memaddr)
// OBSOLETE     {
// OBSOLETE       errno = EIO;
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE   if (bufaddr <= memaddr && (memaddr + len) <= (bufaddr + buflen))
// OBSOLETE     {
// OBSOLETE       memcpy (myaddr, &readbuf[memaddr - bufaddr], len);
// OBSOLETE       return len;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   startaddr = memaddr;
// OBSOLETE   count = 0;
// OBSOLETE   while (count < len)
// OBSOLETE     {
// OBSOLETE       len_this_pass = 16;
// OBSOLETE       if ((startaddr % 16) != 0)
// OBSOLETE 	len_this_pass -= startaddr % 16;
// OBSOLETE       if (len_this_pass > (len - count))
// OBSOLETE 	len_this_pass = (len - count);
// OBSOLETE       if (sr_get_debug ())
// OBSOLETE 	printf ("\nDisplay %d bytes at %x\n", len_this_pass, startaddr);
// OBSOLETE 
// OBSOLETE       printf_monitor (MEM_DIS_CMD, startaddr, 8);
// OBSOLETE       expect ("- ", 1);
// OBSOLETE       for (i = 0; i < 16; i++)
// OBSOLETE 	{
// OBSOLETE 	  get_hex_byte (&readbuf[i]);
// OBSOLETE 	}
// OBSOLETE       bufaddr = startaddr;
// OBSOLETE       buflen = 16;
// OBSOLETE       memcpy (&myaddr[count], readbuf, len_this_pass);
// OBSOLETE       count += len_this_pass;
// OBSOLETE       startaddr += len_this_pass;
// OBSOLETE       expect (CMD_DELIM, 1);
// OBSOLETE     }
// OBSOLETE   if (CMD_END)
// OBSOLETE     printf_monitor (CMD_END);
// OBSOLETE   is_trace_mode = 0;
// OBSOLETE   expect_prompt (1);
// OBSOLETE 
// OBSOLETE   return len;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Transfer LEN bytes between GDB address MYADDR and target address
// OBSOLETE    MEMADDR.  If WRITE is non-zero, transfer them to the target,
// OBSOLETE    otherwise transfer them from the target.  TARGET is unused.
// OBSOLETE 
// OBSOLETE    Returns the number of bytes transferred. */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE rombug_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len,
// OBSOLETE 			     int write, struct mem_attrib *attrib,
// OBSOLETE 			     struct target_ops *target)
// OBSOLETE {
// OBSOLETE   if (write)
// OBSOLETE     return rombug_write_inferior_memory (memaddr, myaddr, len);
// OBSOLETE   else
// OBSOLETE     return rombug_read_inferior_memory (memaddr, myaddr, len);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_kill (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   return;			/* ignore attempts to kill target system */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Clean up when a program exits.
// OBSOLETE    The program actually lives on in the remote processor's RAM, and may be
// OBSOLETE    run again without a download.  Don't leave it full of breakpoint
// OBSOLETE    instructions.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_mourn_inferior (void)
// OBSOLETE {
// OBSOLETE   remove_breakpoints ();
// OBSOLETE   generic_mourn_inferior ();	/* Do all the proper things now */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #define MAX_MONITOR_BREAKPOINTS 16
// OBSOLETE 
// OBSOLETE static CORE_ADDR breakaddr[MAX_MONITOR_BREAKPOINTS] =
// OBSOLETE {0};
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE rombug_insert_breakpoint (CORE_ADDR addr, char *shadow)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   CORE_ADDR bp_addr = addr;
// OBSOLETE   int bp_size = 0;
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fprintf (log_file, "\nIn Insert_breakpoint (addr=%x)\n", addr);
// OBSOLETE   BREAKPOINT_FROM_PC (&bp_addr, &bp_size);
// OBSOLETE 
// OBSOLETE   for (i = 0; i <= MAX_MONITOR_BREAKPOINTS; i++)
// OBSOLETE     if (breakaddr[i] == 0)
// OBSOLETE       {
// OBSOLETE 	breakaddr[i] = addr;
// OBSOLETE 	if (sr_get_debug ())
// OBSOLETE 	  printf ("Breakpoint at %x\n", addr);
// OBSOLETE 	rombug_read_inferior_memory (bp_addr, shadow, bp_size);
// OBSOLETE 	printf_monitor (SET_BREAK_CMD, addr);
// OBSOLETE 	is_trace_mode = 0;
// OBSOLETE 	expect_prompt (1);
// OBSOLETE 	return 0;
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE   fprintf_unfiltered (gdb_stderr, "Too many breakpoints (> 16) for monitor\n");
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * _remove_breakpoint -- Tell the monitor to remove a breakpoint
// OBSOLETE  */
// OBSOLETE static int
// OBSOLETE rombug_remove_breakpoint (CORE_ADDR addr, char *shadow)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fprintf (log_file, "\nIn Remove_breakpoint (addr=%x)\n", addr);
// OBSOLETE 
// OBSOLETE   for (i = 0; i < MAX_MONITOR_BREAKPOINTS; i++)
// OBSOLETE     if (breakaddr[i] == addr)
// OBSOLETE       {
// OBSOLETE 	breakaddr[i] = 0;
// OBSOLETE 	printf_monitor (CLR_BREAK_CMD, addr);
// OBSOLETE 	is_trace_mode = 0;
// OBSOLETE 	expect_prompt (1);
// OBSOLETE 	return 0;
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE   fprintf_unfiltered (gdb_stderr,
// OBSOLETE 		      "Can't find breakpoint associated with 0x%x\n", addr);
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Load a file. This is usually an srecord, which is ascii. No 
// OBSOLETE    protocol, just sent line by line. */
// OBSOLETE 
// OBSOLETE #define DOWNLOAD_LINE_SIZE 100
// OBSOLETE static void
// OBSOLETE rombug_load (char *arg)
// OBSOLETE {
// OBSOLETE /* this part comment out for os9* */
// OBSOLETE #if 0
// OBSOLETE   FILE *download;
// OBSOLETE   char buf[DOWNLOAD_LINE_SIZE];
// OBSOLETE   int i, bytes_read;
// OBSOLETE 
// OBSOLETE   if (sr_get_debug ())
// OBSOLETE     printf ("Loading %s to monitor\n", arg);
// OBSOLETE 
// OBSOLETE   download = fopen (arg, "r");
// OBSOLETE   if (download == NULL)
// OBSOLETE     {
// OBSOLETE       error (sprintf (buf, "%s Does not exist", arg));
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   printf_monitor (LOAD_CMD);
// OBSOLETE /*  expect ("Waiting for S-records from host... ", 1); */
// OBSOLETE 
// OBSOLETE   while (!feof (download))
// OBSOLETE     {
// OBSOLETE       bytes_read = fread (buf, sizeof (char), DOWNLOAD_LINE_SIZE, download);
// OBSOLETE       if (hashmark)
// OBSOLETE 	{
// OBSOLETE 	  putchar ('.');
// OBSOLETE 	  fflush (stdout);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (serial_write (monitor_desc, buf, bytes_read))
// OBSOLETE 	{
// OBSOLETE 	  fprintf_unfiltered (gdb_stderr,
// OBSOLETE 			      "serial_write failed: (while downloading) %s\n",
// OBSOLETE 			      safe_strerror (errno));
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       i = 0;
// OBSOLETE       while (i++ <= 200000)
// OBSOLETE 	{
// OBSOLETE 	};			/* Ugly HACK, probably needs flow control */
// OBSOLETE       if (bytes_read < DOWNLOAD_LINE_SIZE)
// OBSOLETE 	{
// OBSOLETE 	  if (!feof (download))
// OBSOLETE 	    error ("Only read %d bytes\n", bytes_read);
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (hashmark)
// OBSOLETE     {
// OBSOLETE       putchar ('\n');
// OBSOLETE     }
// OBSOLETE   if (!feof (download))
// OBSOLETE     error ("Never got EOF while downloading");
// OBSOLETE   fclose (download);
// OBSOLETE #endif /* 0 */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Put a command string, in args, out to MONITOR.  
// OBSOLETE    Output from MONITOR is placed on the users terminal until the prompt 
// OBSOLETE    is seen. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_command (char *args, int fromtty)
// OBSOLETE {
// OBSOLETE   if (monitor_desc == NULL)
// OBSOLETE     error ("monitor target not open.");
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fprintf (log_file, "\nIn command (args=%s)\n", args);
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     error ("Missing command.");
// OBSOLETE 
// OBSOLETE   printf_monitor ("%s\r", args);
// OBSOLETE   expect_prompt (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE /* Connect the user directly to MONITOR.  This command acts just like the
// OBSOLETE    'cu' or 'tip' command.  Use <CR>~. or <CR>~^D to break out.  */
// OBSOLETE 
// OBSOLETE static struct ttystate ttystate;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE cleanup_tty (void)
// OBSOLETE {
// OBSOLETE   printf ("\r\n[Exiting connect mode]\r\n");
// OBSOLETE   /*serial_restore(0, &ttystate); */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE connect_command (char *args, int fromtty)
// OBSOLETE {
// OBSOLETE   fd_set readfds;
// OBSOLETE   int numfds;
// OBSOLETE   int c;
// OBSOLETE   char cur_esc = 0;
// OBSOLETE 
// OBSOLETE   dont_repeat ();
// OBSOLETE 
// OBSOLETE   if (monitor_desc == NULL)
// OBSOLETE     error ("monitor target not open.");
// OBSOLETE 
// OBSOLETE   if (args)
// OBSOLETE     fprintf ("This command takes no args.  They have been ignored.\n");
// OBSOLETE 
// OBSOLETE   printf ("[Entering connect mode.  Use ~. or ~^D to escape]\n");
// OBSOLETE 
// OBSOLETE   serial_raw (0, &ttystate);
// OBSOLETE 
// OBSOLETE   make_cleanup (cleanup_tty, 0);
// OBSOLETE 
// OBSOLETE   FD_ZERO (&readfds);
// OBSOLETE 
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       do
// OBSOLETE 	{
// OBSOLETE 	  FD_SET (0, &readfds);
// OBSOLETE 	  FD_SET (deprecated_serial_fd (monitor_desc), &readfds);
// OBSOLETE 	  numfds = select (sizeof (readfds) * 8, &readfds, 0, 0, 0);
// OBSOLETE 	}
// OBSOLETE       while (numfds == 0);
// OBSOLETE 
// OBSOLETE       if (numfds < 0)
// OBSOLETE 	perror_with_name ("select");
// OBSOLETE 
// OBSOLETE       if (FD_ISSET (0, &readfds))
// OBSOLETE 	{			/* tty input, send to monitor */
// OBSOLETE 	  c = getchar ();
// OBSOLETE 	  if (c < 0)
// OBSOLETE 	    perror_with_name ("connect");
// OBSOLETE 
// OBSOLETE 	  printf_monitor ("%c", c);
// OBSOLETE 	  switch (cur_esc)
// OBSOLETE 	    {
// OBSOLETE 	    case 0:
// OBSOLETE 	      if (c == '\r')
// OBSOLETE 		cur_esc = c;
// OBSOLETE 	      break;
// OBSOLETE 	    case '\r':
// OBSOLETE 	      if (c == '~')
// OBSOLETE 		cur_esc = c;
// OBSOLETE 	      else
// OBSOLETE 		cur_esc = 0;
// OBSOLETE 	      break;
// OBSOLETE 	    case '~':
// OBSOLETE 	      if (c == '.' || c == '\004')
// OBSOLETE 		return;
// OBSOLETE 	      else
// OBSOLETE 		cur_esc = 0;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (FD_ISSET (deprecated_serial_fd (monitor_desc), &readfds))
// OBSOLETE 	{
// OBSOLETE 	  while (1)
// OBSOLETE 	    {
// OBSOLETE 	      c = readchar (0);
// OBSOLETE 	      if (c < 0)
// OBSOLETE 		break;
// OBSOLETE 	      putchar (c);
// OBSOLETE 	    }
// OBSOLETE 	  fflush (stdout);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Define the monitor command strings. Since these are passed directly
// OBSOLETE  * through to a printf style function, we need can include formatting
// OBSOLETE  * strings. We also need a CR or LF on the end.
// OBSOLETE  */
// OBSOLETE #warning FIXME: monitor interface pattern strings, stale struct decl
// OBSOLETE struct monitor_ops rombug_cmds =
// OBSOLETE {
// OBSOLETE   "g \r",			/* execute or usually GO command */
// OBSOLETE   "g \r",			/* continue command */
// OBSOLETE   "t \r",			/* single step */
// OBSOLETE   "b %x\r",			/* set a breakpoint */
// OBSOLETE   "k %x\r",			/* clear a breakpoint */
// OBSOLETE   "c %x\r",			/* set memory to a value */
// OBSOLETE   "d %x %d\r",			/* display memory */
// OBSOLETE   "$%08X",			/* prompt memory commands use */
// OBSOLETE   ".%s %x\r",			/* set a register */
// OBSOLETE   ":",				/* delimiter between registers */
// OBSOLETE   ". \r",			/* read a register */
// OBSOLETE   "mf \r",			/* download command */
// OBSOLETE   "RomBug: ",			/* monitor command prompt */
// OBSOLETE   ": ",				/* end-of-command delimitor */
// OBSOLETE   ".\r"				/* optional command terminator */
// OBSOLETE };
// OBSOLETE 
// OBSOLETE struct target_ops rombug_ops;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_rombug_ops (void)
// OBSOLETE {
// OBSOLETE   rombug_ops.to_shortname = "rombug";
// OBSOLETE   rombug_ops.to_longname = "Microware's ROMBUG debug monitor";
// OBSOLETE   rombug_ops.to_doc = "Use a remote computer running the ROMBUG debug monitor.\n\
// OBSOLETE Specify the serial device it is connected to (e.g. /dev/ttya).",
// OBSOLETE     rombug_ops.to_open = rombug_open;
// OBSOLETE   rombug_ops.to_close = rombug_close;
// OBSOLETE   rombug_ops.to_attach = 0;
// OBSOLETE   rombug_ops.to_post_attach = NULL;
// OBSOLETE   rombug_ops.to_require_attach = NULL;
// OBSOLETE   rombug_ops.to_detach = rombug_detach;
// OBSOLETE   rombug_ops.to_require_detach = NULL;
// OBSOLETE   rombug_ops.to_resume = rombug_resume;
// OBSOLETE   rombug_ops.to_wait = rombug_wait;
// OBSOLETE   rombug_ops.to_post_wait = NULL;
// OBSOLETE   rombug_ops.to_fetch_registers = rombug_fetch_register;
// OBSOLETE   rombug_ops.to_store_registers = rombug_store_register;
// OBSOLETE   rombug_ops.to_prepare_to_store = rombug_prepare_to_store;
// OBSOLETE   rombug_ops.to_xfer_memory = rombug_xfer_inferior_memory;
// OBSOLETE   rombug_ops.to_files_info = rombug_files_info;
// OBSOLETE   rombug_ops.to_insert_breakpoint = rombug_insert_breakpoint;
// OBSOLETE   rombug_ops.to_remove_breakpoint = rombug_remove_breakpoint;	/* Breakpoints */
// OBSOLETE   rombug_ops.to_terminal_init = 0;
// OBSOLETE   rombug_ops.to_terminal_inferior = 0;
// OBSOLETE   rombug_ops.to_terminal_ours_for_output = 0;
// OBSOLETE   rombug_ops.to_terminal_ours = 0;
// OBSOLETE   rombug_ops.to_terminal_info = 0;	/* Terminal handling */
// OBSOLETE   rombug_ops.to_kill = rombug_kill;
// OBSOLETE   rombug_ops.to_load = rombug_load;	/* load */
// OBSOLETE   rombug_ops.to_lookup_symbol = rombug_link;	/* lookup_symbol */
// OBSOLETE   rombug_ops.to_create_inferior = rombug_create_inferior;
// OBSOLETE   rombug_ops.to_post_startup_inferior = NULL;
// OBSOLETE   rombug_ops.to_acknowledge_created_inferior = NULL;
// OBSOLETE   rombug_ops.to_clone_and_follow_inferior = NULL;
// OBSOLETE   rombug_ops.to_post_follow_inferior_by_clone = NULL;
// OBSOLETE   rombug_ops.to_insert_fork_catchpoint = NULL;
// OBSOLETE   rombug_ops.to_remove_fork_catchpoint = NULL;
// OBSOLETE   rombug_ops.to_insert_vfork_catchpoint = NULL;
// OBSOLETE   rombug_ops.to_remove_vfork_catchpoint = NULL;
// OBSOLETE   rombug_ops.to_has_forked = NULL;
// OBSOLETE   rombug_ops.to_has_vforked = NULL;
// OBSOLETE   rombug_ops.to_can_follow_vfork_prior_to_exec = NULL;
// OBSOLETE   rombug_ops.to_post_follow_vfork = NULL;
// OBSOLETE   rombug_ops.to_insert_exec_catchpoint = NULL;
// OBSOLETE   rombug_ops.to_remove_exec_catchpoint = NULL;
// OBSOLETE   rombug_ops.to_has_execd = NULL;
// OBSOLETE   rombug_ops.to_reported_exec_events_per_exec_call = NULL;
// OBSOLETE   rombug_ops.to_has_exited = NULL;
// OBSOLETE   rombug_ops.to_mourn_inferior = rombug_mourn_inferior;
// OBSOLETE   rombug_ops.to_can_run = 0;	/* can_run */
// OBSOLETE   rombug_ops.to_notice_signals = 0;	/* notice_signals */
// OBSOLETE   rombug_ops.to_thread_alive = 0;
// OBSOLETE   rombug_ops.to_stop = 0;	/* to_stop */
// OBSOLETE   rombug_ops.to_pid_to_exec_file = NULL;
// OBSOLETE   rombug_ops.to_stratum = process_stratum;
// OBSOLETE   rombug_ops.DONT_USE = 0;	/* next */
// OBSOLETE   rombug_ops.to_has_all_memory = 1;
// OBSOLETE   rombug_ops.to_has_memory = 1;
// OBSOLETE   rombug_ops.to_has_stack = 1;
// OBSOLETE   rombug_ops.to_has_registers = 1;
// OBSOLETE   rombug_ops.to_has_execution = 1;	/* has execution */
// OBSOLETE   rombug_ops.to_sections = 0;
// OBSOLETE   rombug_ops.to_sections_end = 0;	/* Section pointers */
// OBSOLETE   rombug_ops.to_magic = OPS_MAGIC;	/* Always the last thing */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_remote_os9k (void)
// OBSOLETE {
// OBSOLETE   init_rombug_ops ();
// OBSOLETE   add_target (&rombug_ops);
// OBSOLETE 
// OBSOLETE   add_show_from_set (
// OBSOLETE 	     add_set_cmd ("hash", no_class, var_boolean, (char *) &hashmark,
// OBSOLETE 			  "Set display of activity while downloading a file.\nWhen enabled, a period \'.\' is displayed.",
// OBSOLETE 			  &setlist),
// OBSOLETE 		      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set (
// OBSOLETE 		      add_set_cmd ("timeout", no_class, var_zinteger,
// OBSOLETE 				   (char *) &timeout,
// OBSOLETE 		       "Set timeout in seconds for remote MIPS serial I/O.",
// OBSOLETE 				   &setlist),
// OBSOLETE 		      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set (
// OBSOLETE 		      add_set_cmd ("remotelog", no_class, var_zinteger,
// OBSOLETE 				   (char *) &monitor_log,
// OBSOLETE 			      "Set monitor activity log on(=1) or off(=0).",
// OBSOLETE 				   &setlist),
// OBSOLETE 		      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set (
// OBSOLETE 		      add_set_cmd ("remotexon", no_class, var_zinteger,
// OBSOLETE 				   (char *) &tty_xon,
// OBSOLETE 				   "Set remote tty line XON control",
// OBSOLETE 				   &setlist),
// OBSOLETE 		      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set (
// OBSOLETE 		      add_set_cmd ("remotexoff", no_class, var_zinteger,
// OBSOLETE 				   (char *) &tty_xoff,
// OBSOLETE 				   "Set remote tty line XOFF control",
// OBSOLETE 				   &setlist),
// OBSOLETE 		      &showlist);
// OBSOLETE 
// OBSOLETE   add_com ("rombug <command>", class_obscure, rombug_command,
// OBSOLETE 	   "Send a command to the debug monitor.");
// OBSOLETE #if 0
// OBSOLETE   add_com ("connect", class_obscure, connect_command,
// OBSOLETE 	   "Connect the terminal directly up to a serial based command monitor.\nUse <CR>~. or <CR>~^D to break out.");
// OBSOLETE #endif
// OBSOLETE }
@


1.20
log
@Obsolete i[3456]86-*-os9k.
@
text
@@


1.20.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.20.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.19
log
@2002-04-24  Pierre Muller  <ics.u-strasbg.fr>

	* remote-array.c (printf_monitor, write_monitor,
	array_insert_breakpoint, array_remove_breakpoint ):
	Replace fprintf (stderr,...
	with fprintf_unfiltered (gdb_stderr,....
	* remote-es.c: Likewise.
	* remote-os9k.c: Likewise.
	* remote-st.c: Likewise.
@
text
@d1 1234
a1234 1234
/* Remote debugging interface for boot monitors, for GDB.

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
   2000, 2001, 2002 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* This file was derived from remote-eb.c, which did a similar job, but for
   an AMD-29K running EBMON.  That file was in turn derived from remote.c
   as mentioned in the following comment (left in for comic relief):

   "This is like remote.c but is for a different situation--
   having a PC running os9000 hook up with a unix machine with
   a serial line, and running ctty com2 on the PC. os9000 has a debug
   monitor called ROMBUG running.  Not to mention that the PC
   has PC/NFS, so it can access the same executables that gdb can,
   over the net in real time."

   In reality, this module talks to a debug monitor called 'ROMBUG', which
   We communicate with ROMBUG via a direct serial line, the network version
   of ROMBUG is not available yet.
 */

/* FIXME This file needs to be rewritten if it's to work again, either
   to self-contained or to use the new monitor interface.  */

#include "defs.h"
#include "gdbcore.h"
#include "target.h"
#include "gdb_string.h"
#include <sys/types.h>
#include "command.h"
#include "serial.h"
#include "monitor.h"
#include "remote-utils.h"
#include "symtab.h"
#include "symfile.h"
#include "objfiles.h"
#include "gdb-stabs.h"
#include "regcache.h"

struct cmd_list_element *showlist;
extern struct target_ops rombug_ops;	/* Forward declaration */
extern struct monitor_ops rombug_cmds;	/* Forward declaration */
extern struct cmd_list_element *setlist;
extern struct cmd_list_element *unsetlist;
extern int attach_flag;

static void rombug_close ();
static void rombug_fetch_register ();
static void rombug_fetch_registers ();
static void rombug_store_register ();
#if 0
static int sr_get_debug ();	/* flag set by "set remotedebug" */
#endif
static int hashmark;		/* flag set by "set hash" */
static int rombug_is_open = 0;

/* FIXME: Replace with sr_get_debug ().  */
#define LOG_FILE "monitor.log"
FILE *log_file;
static int monitor_log = 0;
static int tty_xon = 0;
static int tty_xoff = 0;

static int timeout = 10;
static int is_trace_mode = 0;
/* Descriptor for I/O to remote machine.  Initialize it to NULL */
static struct serial *monitor_desc = NULL;

static CORE_ADDR bufaddr = 0;
static int buflen = 0;
static char readbuf[16];

/* Send data to monitor.  Works just like printf. */
static void
printf_monitor (char *pattern,...)
{
  va_list args;
  char buf[200];
  int i;

  va_start (args, pattern);

  vsprintf (buf, pattern, args);
  va_end (args);

  if (serial_write (monitor_desc, buf, strlen (buf)))
    fprintf_unfiltered (gdb_stderr, "serial_write failed: %s\n",
			safe_strerror (errno));
}

/* Read a character from the remote system, doing all the fancy timeout stuff */
static int
readchar (int timeout)
{
  int c;

  c = serial_readchar (monitor_desc, timeout);

  if (sr_get_debug ())
    putchar (c & 0x7f);

  if (monitor_log && isascii (c))
    putc (c & 0x7f, log_file);

  if (c >= 0)
    return c & 0x7f;

  if (c == SERIAL_TIMEOUT)
    {
      if (timeout == 0)
	return c;		/* Polls shouldn't generate timeout errors */

      error ("Timeout reading from remote system.");
    }

  perror_with_name ("remote-monitor");
}

/* Scan input from the remote system, until STRING is found.  If DISCARD is
   non-zero, then discard non-matching input, else print it out.
   Let the user break out immediately.  */
static void
expect (char *string, int discard)
{
  char *p = string;
  int c;

  if (sr_get_debug ())
    printf ("Expecting \"%s\"\n", string);

  immediate_quit++;
  while (1)
    {
      c = readchar (timeout);
      if (!isascii (c))
	continue;
      if (c == *p++)
	{
	  if (*p == '\0')
	    {
	      immediate_quit--;
	      if (sr_get_debug ())
		printf ("\nMatched\n");
	      return;
	    }
	}
      else
	{
	  if (!discard)
	    {
	      fwrite (string, 1, (p - 1) - string, stdout);
	      putchar ((char) c);
	      fflush (stdout);
	    }
	  p = string;
	}
    }
}

/* Keep discarding input until we see the ROMBUG prompt.

   The convention for dealing with the prompt is that you
   o give your command
   o *then* wait for the prompt.

   Thus the last thing that a procedure does with the serial line
   will be an expect_prompt().  Exception:  rombug_resume does not
   wait for the prompt, because the terminal is being handed over
   to the inferior.  However, the next thing which happens after that
   is a rombug_wait which does wait for the prompt.
   Note that this includes abnormal exit, e.g. error().  This is
   necessary to prevent getting into states from which we can't
   recover.  */
static void
expect_prompt (int discard)
{
  if (monitor_log)
    /* This is a convenient place to do this.  The idea is to do it often
       enough that we never lose much data if we terminate abnormally.  */
    fflush (log_file);

  if (is_trace_mode)
    {
      expect ("trace", discard);
    }
  else
    {
      expect (PROMPT, discard);
    }
}

/* Get a hex digit from the remote system & return its value.
   If ignore_space is nonzero, ignore spaces (not newline, tab, etc).  */
static int
get_hex_digit (int ignore_space)
{
  int ch;
  while (1)
    {
      ch = readchar (timeout);
      if (ch >= '0' && ch <= '9')
	return ch - '0';
      else if (ch >= 'A' && ch <= 'F')
	return ch - 'A' + 10;
      else if (ch >= 'a' && ch <= 'f')
	return ch - 'a' + 10;
      else if (ch == ' ' && ignore_space)
	;
      else
	{
	  expect_prompt (1);
	  error ("Invalid hex digit from remote system.");
	}
    }
}

/* Get a byte from monitor and put it in *BYT.  Accept any number
   leading spaces.  */
static void
get_hex_byte (char *byt)
{
  int val;

  val = get_hex_digit (1) << 4;
  val |= get_hex_digit (0);
  *byt = val;
}

/* Get N 32-bit words from remote, each preceded by a space,
   and put them in registers starting at REGNO.  */
static void
get_hex_regs (int n, int regno)
{
  long val;
  int i;
  unsigned char b;

  for (i = 0; i < n; i++)
    {
      int j;

      val = 0;
      for (j = 0; j < 4; j++)
	{
	  get_hex_byte (&b);
	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	    val = (val << 8) + b;
	  else
	    val = val + (b << (j * 8));
	}
      supply_register (regno++, (char *) &val);
    }
}

/* This is called not only when we first attach, but also when the
   user types "run" after having attached.  */
static void
rombug_create_inferior (char *execfile, char *args, char **env)
{
  int entry_pt;

  if (args && *args)
    error ("Can't pass arguments to remote ROMBUG process");

  if (execfile == 0 || exec_bfd == 0)
    error ("No executable file specified");

  entry_pt = (int) bfd_get_start_address (exec_bfd);

  if (monitor_log)
    fputs ("\nIn Create_inferior()", log_file);


/* The "process" (board) is already stopped awaiting our commands, and
   the program is already downloaded.  We just set its PC and go.  */

  init_wait_for_inferior ();
  proceed ((CORE_ADDR) entry_pt, TARGET_SIGNAL_DEFAULT, 0);
}

/* Open a connection to a remote debugger.
   NAME is the filename used for communication.  */

static char dev_name[100];

static void
rombug_open (char *args, int from_tty)
{
  if (args == NULL)
    error ("Use `target RomBug DEVICE-NAME' to use a serial port, or \n\
`target RomBug HOST-NAME:PORT-NUMBER' to use a network connection.");

  target_preopen (from_tty);

  if (rombug_is_open)
    unpush_target (&rombug_ops);

  strcpy (dev_name, args);
  monitor_desc = serial_open (dev_name);
  if (monitor_desc == NULL)
    perror_with_name (dev_name);

  /* if baud rate is set by 'set remotebaud' */
  if (serial_setbaudrate (monitor_desc, sr_get_baud_rate ()))
    {
      serial_close (monitor_desc);
      perror_with_name ("RomBug");
    }
  serial_raw (monitor_desc);
  if (tty_xon || tty_xoff)
    {
      struct hardware_ttystate
	{
	  struct termios t;
	}
       *tty_s;

      tty_s = (struct hardware_ttystate *) serial_get_tty_state (monitor_desc);
      if (tty_xon)
	tty_s->t.c_iflag |= IXON;
      if (tty_xoff)
	tty_s->t.c_iflag |= IXOFF;
      serial_set_tty_state (monitor_desc, (serial_ttystate) tty_s);
    }

  rombug_is_open = 1;

  log_file = fopen (LOG_FILE, "w");
  if (log_file == NULL)
    perror_with_name (LOG_FILE);

  push_monitor (&rombug_cmds);
  printf_monitor ("\r");	/* CR wakes up monitor */
  expect_prompt (1);
  push_target (&rombug_ops);
  attach_flag = 1;

  if (from_tty)
    printf ("Remote %s connected to %s\n", target_shortname,
	    dev_name);

  rombug_fetch_registers ();

  printf_monitor ("ov e \r");
  expect_prompt (1);
  bufaddr = 0;
  buflen = 0;
}

/*
 * Close out all files and local state before this target loses control.
 */

static void
rombug_close (int quitting)
{
  if (rombug_is_open)
    {
      serial_close (monitor_desc);
      monitor_desc = NULL;
      rombug_is_open = 0;
    }

  if (log_file)
    {
      if (ferror (log_file))
	fprintf_unfiltered (gdb_stderr, "Error writing log file.\n");
      if (fclose (log_file) != 0)
	fprintf_unfiltered (gdb_stderr, "Error closing log file.\n");
      log_file = 0;
    }
}

int
rombug_link (char *mod_name, CORE_ADDR *text_reloc)
{
  int i, j;
  unsigned long val;
  unsigned char b;

  printf_monitor ("l %s \r", mod_name);
  expect_prompt (1);
  printf_monitor (".r \r");
  expect (REG_DELIM, 1);
  for (i = 0; i <= 7; i++)
    {
      val = 0;
      for (j = 0; j < 4; j++)
	{
	  get_hex_byte (&b);
	  val = (val << 8) + b;
	}
    }
  expect_prompt (1);
  *text_reloc = val;
  return 1;
}

/* Terminate the open connection to the remote debugger.
   Use this when you want to detach and do something else
   with your gdb.  */
static void
rombug_detach (int from_tty)
{
  if (attach_flag)
    {
      printf_monitor (GO_CMD);
      attach_flag = 0;
    }
  pop_target ();		/* calls rombug_close to do the real work */
  if (from_tty)
    printf ("Ending remote %s debugging\n", target_shortname);
}

/*
 * Tell the remote machine to resume.
 */
static void
rombug_resume (ptid_t ptid, int step, enum target_signal sig)
{
  if (monitor_log)
    fprintf (log_file, "\nIn Resume (step=%d, sig=%d)\n", step, sig);

  if (step)
    {
      is_trace_mode = 1;
      printf_monitor (STEP_CMD);
      /* wait for the echo.  **
         expect (STEP_CMD, 1);
       */
    }
  else
    {
      printf_monitor (GO_CMD);
      /* swallow the echo.  **
         expect (GO_CMD, 1);
       */
    }
  bufaddr = 0;
  buflen = 0;
}

/*
 * Wait until the remote machine stops, then return,
 * storing status in status just as `wait' would.
 */

static ptid *
rombug_wait (ptid_t ptid, struct target_waitstatus *status)
{
  int old_timeout = timeout;
  struct section_offsets *offs;
  CORE_ADDR addr, pc;
  struct obj_section *obj_sec;

  if (monitor_log)
    fputs ("\nIn wait ()", log_file);

  status->kind = TARGET_WAITKIND_EXITED;
  status->value.integer = 0;

  timeout = -1;			/* Don't time out -- user program is running. */
  expect ("eax:", 0);		/* output any message before register display */
  expect_prompt (1);		/* Wait for prompt, outputting extraneous text */

  status->kind = TARGET_WAITKIND_STOPPED;
  status->value.sig = TARGET_SIGNAL_TRAP;
  timeout = old_timeout;
  rombug_fetch_registers ();
  bufaddr = 0;
  buflen = 0;
  pc = read_register (PC_REGNUM);
  addr = read_register (DATABASE_REG);
  obj_sec = find_pc_section (pc);
  if (obj_sec != NULL)
    {
      if (obj_sec->objfile != symfile_objfile)
	new_symfile_objfile (obj_sec->objfile, 1, 0);
      offs = (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
      memcpy (offs, symfile_objfile->section_offsets, SIZEOF_SECTION_OFFSETS);
      offs->offsets[SECT_OFF_DATA (symfile_objfile)]  = addr;
      offs->offsets[SECT_OFF_BSS (symfile_objfile)]  = addr;

      objfile_relocate (symfile_objfile, offs);
    }

  return inferior_ptid;
}

/* Return the name of register number regno in the form input and output by
   monitor.  Currently, register_names just happens to contain exactly what
   monitor wants.  Lets take advantage of that just as long as possible! */

static char *
get_reg_name (int regno)
{
  static char buf[50];
  char *p;
  char *b;

  b = buf;

  if (regno < 0)
    return ("");
/*
   for (p = REGISTER_NAME (regno); *p; p++)
   *b++ = toupper(*p);
   *b = '\000';
 */
  p = (char *) REGISTER_NAME (regno);
  return p;
/*
   return buf;
 */
}

/* read the remote registers into the block regs.  */

static void
rombug_fetch_registers (void)
{
  int regno, j, i;
  long val;
  unsigned char b;

  printf_monitor (GET_REG);
  expect ("eax:", 1);
  expect ("\n", 1);
  get_hex_regs (1, 0);
  get_hex_regs (1, 3);
  get_hex_regs (1, 1);
  get_hex_regs (1, 2);
  get_hex_regs (1, 6);
  get_hex_regs (1, 7);
  get_hex_regs (1, 5);
  get_hex_regs (1, 4);
  for (regno = 8; regno <= 15; regno++)
    {
      expect (REG_DELIM, 1);
      if (regno >= 8 && regno <= 13)
	{
	  val = 0;
	  for (j = 0; j < 2; j++)
	    {
	      get_hex_byte (&b);
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		val = (val << 8) + b;
	      else
		val = val + (b << (j * 8));
	    }

	  if (regno == 8)
	    i = 10;
	  if (regno >= 9 && regno <= 12)
	    i = regno + 3;
	  if (regno == 13)
	    i = 11;
	  supply_register (i, (char *) &val);
	}
      else if (regno == 14)
	{
	  get_hex_regs (1, PC_REGNUM);
	}
      else if (regno == 15)
	{
	  get_hex_regs (1, 9);
	}
      else
	{
	  val = 0;
	  supply_register (regno, (char *) &val);
	}
    }
  is_trace_mode = 0;
  expect_prompt (1);
}

/* Fetch register REGNO, or all registers if REGNO is -1.
   Returns errno value.  */
static void
rombug_fetch_register (int regno)
{
  int val, j;
  unsigned char b;

  if (monitor_log)
    {
      fprintf (log_file, "\nIn Fetch Register (reg=%s)\n", get_reg_name (regno));
      fflush (log_file);
    }

  if (regno < 0)
    {
      rombug_fetch_registers ();
    }
  else
    {
      char *name = get_reg_name (regno);
      printf_monitor (GET_REG);
      if (regno >= 10 && regno <= 15)
	{
	  expect ("\n", 1);
	  expect ("\n", 1);
	  expect (name, 1);
	  expect (REG_DELIM, 1);
	  val = 0;
	  for (j = 0; j < 2; j++)
	    {
	      get_hex_byte (&b);
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		val = (val << 8) + b;
	      else
		val = val + (b << (j * 8));
	    }
	  supply_register (regno, (char *) &val);
	}
      else if (regno == 8 || regno == 9)
	{
	  expect ("\n", 1);
	  expect ("\n", 1);
	  expect ("\n", 1);
	  expect (name, 1);
	  expect (REG_DELIM, 1);
	  get_hex_regs (1, regno);
	}
      else
	{
	  expect (name, 1);
	  expect (REG_DELIM, 1);
	  expect ("\n", 1);
	  get_hex_regs (1, 0);
	  get_hex_regs (1, 3);
	  get_hex_regs (1, 1);
	  get_hex_regs (1, 2);
	  get_hex_regs (1, 6);
	  get_hex_regs (1, 7);
	  get_hex_regs (1, 5);
	  get_hex_regs (1, 4);
	}
      expect_prompt (1);
    }
  return;
}

/* Store the remote registers from the contents of the block REGS.  */

static void
rombug_store_registers (void)
{
  int regno;

  for (regno = 0; regno <= PC_REGNUM; regno++)
    rombug_store_register (regno);

  registers_changed ();
}

/* Store register REGNO, or all if REGNO == 0.
   return errno value.  */
static void
rombug_store_register (int regno)
{
  char *name;

  if (monitor_log)
    fprintf (log_file, "\nIn Store_register (regno=%d)\n", regno);

  if (regno == -1)
    rombug_store_registers ();
  else
    {
      if (sr_get_debug ())
	printf ("Setting register %s to 0x%x\n", get_reg_name (regno), read_register (regno));

      name = get_reg_name (regno);
      if (name == 0)
	return;
      printf_monitor (SET_REG, name, read_register (regno));

      is_trace_mode = 0;
      expect_prompt (1);
    }
}

/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
rombug_prepare_to_store (void)
{
  /* Do nothing, since we can store individual regs */
}

static void
rombug_files_info (void)
{
  printf ("\tAttached to %s at %d baud.\n",
	  dev_name, sr_get_baud_rate ());
}

/* Copy LEN bytes of data from debugger memory at MYADDR
   to inferior's memory at MEMADDR.  Returns length moved.  */
static int
rombug_write_inferior_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  int i;
  char buf[10];

  if (monitor_log)
    fprintf (log_file, "\nIn Write_inferior_memory (memaddr=%x, len=%d)\n", memaddr, len);

  printf_monitor (MEM_SET_CMD, memaddr);
  for (i = 0; i < len; i++)
    {
      expect (CMD_DELIM, 1);
      printf_monitor ("%x \r", myaddr[i]);
      if (sr_get_debug ())
	printf ("\nSet 0x%x to 0x%x\n", memaddr + i, myaddr[i]);
    }
  expect (CMD_DELIM, 1);
  if (CMD_END)
    printf_monitor (CMD_END);
  is_trace_mode = 0;
  expect_prompt (1);

  bufaddr = 0;
  buflen = 0;
  return len;
}

/* Read LEN bytes from inferior memory at MEMADDR.  Put the result
   at debugger address MYADDR.  Returns length moved.  */
static int
rombug_read_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  int i, j;

  /* Number of bytes read so far.  */
  int count;

  /* Starting address of this pass.  */
  unsigned long startaddr;

  /* Number of bytes to read in this pass.  */
  int len_this_pass;

  if (monitor_log)
    fprintf (log_file, "\nIn Read_inferior_memory (memaddr=%x, len=%d)\n", memaddr, len);

  /* Note that this code works correctly if startaddr is just less
     than UINT_MAX (well, really CORE_ADDR_MAX if there was such a
     thing).  That is, something like
     rombug_read_bytes (CORE_ADDR_MAX - 4, foo, 4)
     works--it never adds len To memaddr and gets 0.  */
  /* However, something like
     rombug_read_bytes (CORE_ADDR_MAX - 3, foo, 4)
     doesn't need to work.  Detect it and give up if there's an attempt
     to do that.  */
  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }
  if (bufaddr <= memaddr && (memaddr + len) <= (bufaddr + buflen))
    {
      memcpy (myaddr, &readbuf[memaddr - bufaddr], len);
      return len;
    }

  startaddr = memaddr;
  count = 0;
  while (count < len)
    {
      len_this_pass = 16;
      if ((startaddr % 16) != 0)
	len_this_pass -= startaddr % 16;
      if (len_this_pass > (len - count))
	len_this_pass = (len - count);
      if (sr_get_debug ())
	printf ("\nDisplay %d bytes at %x\n", len_this_pass, startaddr);

      printf_monitor (MEM_DIS_CMD, startaddr, 8);
      expect ("- ", 1);
      for (i = 0; i < 16; i++)
	{
	  get_hex_byte (&readbuf[i]);
	}
      bufaddr = startaddr;
      buflen = 16;
      memcpy (&myaddr[count], readbuf, len_this_pass);
      count += len_this_pass;
      startaddr += len_this_pass;
      expect (CMD_DELIM, 1);
    }
  if (CMD_END)
    printf_monitor (CMD_END);
  is_trace_mode = 0;
  expect_prompt (1);

  return len;
}

/* Transfer LEN bytes between GDB address MYADDR and target address
   MEMADDR.  If WRITE is non-zero, transfer them to the target,
   otherwise transfer them from the target.  TARGET is unused.

   Returns the number of bytes transferred. */

static int
rombug_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len,
			     int write, struct mem_attrib *attrib,
			     struct target_ops *target)
{
  if (write)
    return rombug_write_inferior_memory (memaddr, myaddr, len);
  else
    return rombug_read_inferior_memory (memaddr, myaddr, len);
}

static void
rombug_kill (char *args, int from_tty)
{
  return;			/* ignore attempts to kill target system */
}

/* Clean up when a program exits.
   The program actually lives on in the remote processor's RAM, and may be
   run again without a download.  Don't leave it full of breakpoint
   instructions.  */

static void
rombug_mourn_inferior (void)
{
  remove_breakpoints ();
  generic_mourn_inferior ();	/* Do all the proper things now */
}

#define MAX_MONITOR_BREAKPOINTS 16

static CORE_ADDR breakaddr[MAX_MONITOR_BREAKPOINTS] =
{0};

static int
rombug_insert_breakpoint (CORE_ADDR addr, char *shadow)
{
  int i;
  CORE_ADDR bp_addr = addr;
  int bp_size = 0;

  if (monitor_log)
    fprintf (log_file, "\nIn Insert_breakpoint (addr=%x)\n", addr);
  BREAKPOINT_FROM_PC (&bp_addr, &bp_size);

  for (i = 0; i <= MAX_MONITOR_BREAKPOINTS; i++)
    if (breakaddr[i] == 0)
      {
	breakaddr[i] = addr;
	if (sr_get_debug ())
	  printf ("Breakpoint at %x\n", addr);
	rombug_read_inferior_memory (bp_addr, shadow, bp_size);
	printf_monitor (SET_BREAK_CMD, addr);
	is_trace_mode = 0;
	expect_prompt (1);
	return 0;
      }

  fprintf_unfiltered (gdb_stderr, "Too many breakpoints (> 16) for monitor\n");
  return 1;
}

/*
 * _remove_breakpoint -- Tell the monitor to remove a breakpoint
 */
static int
rombug_remove_breakpoint (CORE_ADDR addr, char *shadow)
{
  int i;

  if (monitor_log)
    fprintf (log_file, "\nIn Remove_breakpoint (addr=%x)\n", addr);

  for (i = 0; i < MAX_MONITOR_BREAKPOINTS; i++)
    if (breakaddr[i] == addr)
      {
	breakaddr[i] = 0;
	printf_monitor (CLR_BREAK_CMD, addr);
	is_trace_mode = 0;
	expect_prompt (1);
	return 0;
      }

  fprintf_unfiltered (gdb_stderr,
		      "Can't find breakpoint associated with 0x%x\n", addr);
  return 1;
}

/* Load a file. This is usually an srecord, which is ascii. No 
   protocol, just sent line by line. */

#define DOWNLOAD_LINE_SIZE 100
static void
rombug_load (char *arg)
{
/* this part comment out for os9* */
#if 0
  FILE *download;
  char buf[DOWNLOAD_LINE_SIZE];
  int i, bytes_read;

  if (sr_get_debug ())
    printf ("Loading %s to monitor\n", arg);

  download = fopen (arg, "r");
  if (download == NULL)
    {
      error (sprintf (buf, "%s Does not exist", arg));
      return;
    }

  printf_monitor (LOAD_CMD);
/*  expect ("Waiting for S-records from host... ", 1); */

  while (!feof (download))
    {
      bytes_read = fread (buf, sizeof (char), DOWNLOAD_LINE_SIZE, download);
      if (hashmark)
	{
	  putchar ('.');
	  fflush (stdout);
	}

      if (serial_write (monitor_desc, buf, bytes_read))
	{
	  fprintf_unfiltered (gdb_stderr,
			      "serial_write failed: (while downloading) %s\n",
			      safe_strerror (errno));
	  break;
	}
      i = 0;
      while (i++ <= 200000)
	{
	};			/* Ugly HACK, probably needs flow control */
      if (bytes_read < DOWNLOAD_LINE_SIZE)
	{
	  if (!feof (download))
	    error ("Only read %d bytes\n", bytes_read);
	  break;
	}
    }

  if (hashmark)
    {
      putchar ('\n');
    }
  if (!feof (download))
    error ("Never got EOF while downloading");
  fclose (download);
#endif /* 0 */
}

/* Put a command string, in args, out to MONITOR.  
   Output from MONITOR is placed on the users terminal until the prompt 
   is seen. */

static void
rombug_command (char *args, int fromtty)
{
  if (monitor_desc == NULL)
    error ("monitor target not open.");

  if (monitor_log)
    fprintf (log_file, "\nIn command (args=%s)\n", args);

  if (!args)
    error ("Missing command.");

  printf_monitor ("%s\r", args);
  expect_prompt (0);
}

#if 0
/* Connect the user directly to MONITOR.  This command acts just like the
   'cu' or 'tip' command.  Use <CR>~. or <CR>~^D to break out.  */

static struct ttystate ttystate;

static void
cleanup_tty (void)
{
  printf ("\r\n[Exiting connect mode]\r\n");
  /*serial_restore(0, &ttystate); */
}

static void
connect_command (char *args, int fromtty)
{
  fd_set readfds;
  int numfds;
  int c;
  char cur_esc = 0;

  dont_repeat ();

  if (monitor_desc == NULL)
    error ("monitor target not open.");

  if (args)
    fprintf ("This command takes no args.  They have been ignored.\n");

  printf ("[Entering connect mode.  Use ~. or ~^D to escape]\n");

  serial_raw (0, &ttystate);

  make_cleanup (cleanup_tty, 0);

  FD_ZERO (&readfds);

  while (1)
    {
      do
	{
	  FD_SET (0, &readfds);
	  FD_SET (deprecated_serial_fd (monitor_desc), &readfds);
	  numfds = select (sizeof (readfds) * 8, &readfds, 0, 0, 0);
	}
      while (numfds == 0);

      if (numfds < 0)
	perror_with_name ("select");

      if (FD_ISSET (0, &readfds))
	{			/* tty input, send to monitor */
	  c = getchar ();
	  if (c < 0)
	    perror_with_name ("connect");

	  printf_monitor ("%c", c);
	  switch (cur_esc)
	    {
	    case 0:
	      if (c == '\r')
		cur_esc = c;
	      break;
	    case '\r':
	      if (c == '~')
		cur_esc = c;
	      else
		cur_esc = 0;
	      break;
	    case '~':
	      if (c == '.' || c == '\004')
		return;
	      else
		cur_esc = 0;
	    }
	}

      if (FD_ISSET (deprecated_serial_fd (monitor_desc), &readfds))
	{
	  while (1)
	    {
	      c = readchar (0);
	      if (c < 0)
		break;
	      putchar (c);
	    }
	  fflush (stdout);
	}
    }
}
#endif

/*
 * Define the monitor command strings. Since these are passed directly
 * through to a printf style function, we need can include formatting
 * strings. We also need a CR or LF on the end.
 */
#warning FIXME: monitor interface pattern strings, stale struct decl
struct monitor_ops rombug_cmds =
{
  "g \r",			/* execute or usually GO command */
  "g \r",			/* continue command */
  "t \r",			/* single step */
  "b %x\r",			/* set a breakpoint */
  "k %x\r",			/* clear a breakpoint */
  "c %x\r",			/* set memory to a value */
  "d %x %d\r",			/* display memory */
  "$%08X",			/* prompt memory commands use */
  ".%s %x\r",			/* set a register */
  ":",				/* delimiter between registers */
  ". \r",			/* read a register */
  "mf \r",			/* download command */
  "RomBug: ",			/* monitor command prompt */
  ": ",				/* end-of-command delimitor */
  ".\r"				/* optional command terminator */
};

struct target_ops rombug_ops;

static void
init_rombug_ops (void)
{
  rombug_ops.to_shortname = "rombug";
  rombug_ops.to_longname = "Microware's ROMBUG debug monitor";
  rombug_ops.to_doc = "Use a remote computer running the ROMBUG debug monitor.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).",
    rombug_ops.to_open = rombug_open;
  rombug_ops.to_close = rombug_close;
  rombug_ops.to_attach = 0;
  rombug_ops.to_post_attach = NULL;
  rombug_ops.to_require_attach = NULL;
  rombug_ops.to_detach = rombug_detach;
  rombug_ops.to_require_detach = NULL;
  rombug_ops.to_resume = rombug_resume;
  rombug_ops.to_wait = rombug_wait;
  rombug_ops.to_post_wait = NULL;
  rombug_ops.to_fetch_registers = rombug_fetch_register;
  rombug_ops.to_store_registers = rombug_store_register;
  rombug_ops.to_prepare_to_store = rombug_prepare_to_store;
  rombug_ops.to_xfer_memory = rombug_xfer_inferior_memory;
  rombug_ops.to_files_info = rombug_files_info;
  rombug_ops.to_insert_breakpoint = rombug_insert_breakpoint;
  rombug_ops.to_remove_breakpoint = rombug_remove_breakpoint;	/* Breakpoints */
  rombug_ops.to_terminal_init = 0;
  rombug_ops.to_terminal_inferior = 0;
  rombug_ops.to_terminal_ours_for_output = 0;
  rombug_ops.to_terminal_ours = 0;
  rombug_ops.to_terminal_info = 0;	/* Terminal handling */
  rombug_ops.to_kill = rombug_kill;
  rombug_ops.to_load = rombug_load;	/* load */
  rombug_ops.to_lookup_symbol = rombug_link;	/* lookup_symbol */
  rombug_ops.to_create_inferior = rombug_create_inferior;
  rombug_ops.to_post_startup_inferior = NULL;
  rombug_ops.to_acknowledge_created_inferior = NULL;
  rombug_ops.to_clone_and_follow_inferior = NULL;
  rombug_ops.to_post_follow_inferior_by_clone = NULL;
  rombug_ops.to_insert_fork_catchpoint = NULL;
  rombug_ops.to_remove_fork_catchpoint = NULL;
  rombug_ops.to_insert_vfork_catchpoint = NULL;
  rombug_ops.to_remove_vfork_catchpoint = NULL;
  rombug_ops.to_has_forked = NULL;
  rombug_ops.to_has_vforked = NULL;
  rombug_ops.to_can_follow_vfork_prior_to_exec = NULL;
  rombug_ops.to_post_follow_vfork = NULL;
  rombug_ops.to_insert_exec_catchpoint = NULL;
  rombug_ops.to_remove_exec_catchpoint = NULL;
  rombug_ops.to_has_execd = NULL;
  rombug_ops.to_reported_exec_events_per_exec_call = NULL;
  rombug_ops.to_has_exited = NULL;
  rombug_ops.to_mourn_inferior = rombug_mourn_inferior;
  rombug_ops.to_can_run = 0;	/* can_run */
  rombug_ops.to_notice_signals = 0;	/* notice_signals */
  rombug_ops.to_thread_alive = 0;
  rombug_ops.to_stop = 0;	/* to_stop */
  rombug_ops.to_pid_to_exec_file = NULL;
  rombug_ops.to_stratum = process_stratum;
  rombug_ops.DONT_USE = 0;	/* next */
  rombug_ops.to_has_all_memory = 1;
  rombug_ops.to_has_memory = 1;
  rombug_ops.to_has_stack = 1;
  rombug_ops.to_has_registers = 1;
  rombug_ops.to_has_execution = 1;	/* has execution */
  rombug_ops.to_sections = 0;
  rombug_ops.to_sections_end = 0;	/* Section pointers */
  rombug_ops.to_magic = OPS_MAGIC;	/* Always the last thing */
}

void
_initialize_remote_os9k (void)
{
  init_rombug_ops ();
  add_target (&rombug_ops);

  add_show_from_set (
	     add_set_cmd ("hash", no_class, var_boolean, (char *) &hashmark,
			  "Set display of activity while downloading a file.\nWhen enabled, a period \'.\' is displayed.",
			  &setlist),
		      &showlist);

  add_show_from_set (
		      add_set_cmd ("timeout", no_class, var_zinteger,
				   (char *) &timeout,
		       "Set timeout in seconds for remote MIPS serial I/O.",
				   &setlist),
		      &showlist);

  add_show_from_set (
		      add_set_cmd ("remotelog", no_class, var_zinteger,
				   (char *) &monitor_log,
			      "Set monitor activity log on(=1) or off(=0).",
				   &setlist),
		      &showlist);

  add_show_from_set (
		      add_set_cmd ("remotexon", no_class, var_zinteger,
				   (char *) &tty_xon,
				   "Set remote tty line XON control",
				   &setlist),
		      &showlist);

  add_show_from_set (
		      add_set_cmd ("remotexoff", no_class, var_zinteger,
				   (char *) &tty_xoff,
				   "Set remote tty line XOFF control",
				   &setlist),
		      &showlist);

  add_com ("rombug <command>", class_obscure, rombug_command,
	   "Send a command to the debug monitor.");
#if 0
  add_com ("connect", class_obscure, connect_command,
	   "Connect the terminal directly up to a serial based command monitor.\nUse <CR>~. or <CR>~^D to break out.");
#endif
}
@


1.19.6.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1 1234
a1234 1234
// OBSOLETE /* Remote debugging interface for boot monitors, for GDB.
// OBSOLETE 
// OBSOLETE    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
// OBSOLETE    2000, 2001, 2002 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /* This file was derived from remote-eb.c, which did a similar job, but for
// OBSOLETE    an AMD-29K running EBMON.  That file was in turn derived from remote.c
// OBSOLETE    as mentioned in the following comment (left in for comic relief):
// OBSOLETE 
// OBSOLETE    "This is like remote.c but is for a different situation--
// OBSOLETE    having a PC running os9000 hook up with a unix machine with
// OBSOLETE    a serial line, and running ctty com2 on the PC. os9000 has a debug
// OBSOLETE    monitor called ROMBUG running.  Not to mention that the PC
// OBSOLETE    has PC/NFS, so it can access the same executables that gdb can,
// OBSOLETE    over the net in real time."
// OBSOLETE 
// OBSOLETE    In reality, this module talks to a debug monitor called 'ROMBUG', which
// OBSOLETE    We communicate with ROMBUG via a direct serial line, the network version
// OBSOLETE    of ROMBUG is not available yet.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE /* FIXME This file needs to be rewritten if it's to work again, either
// OBSOLETE    to self-contained or to use the new monitor interface.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "gdb_string.h"
// OBSOLETE #include <sys/types.h>
// OBSOLETE #include "command.h"
// OBSOLETE #include "serial.h"
// OBSOLETE #include "monitor.h"
// OBSOLETE #include "remote-utils.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "symfile.h"
// OBSOLETE #include "objfiles.h"
// OBSOLETE #include "gdb-stabs.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE struct cmd_list_element *showlist;
// OBSOLETE extern struct target_ops rombug_ops;	/* Forward declaration */
// OBSOLETE extern struct monitor_ops rombug_cmds;	/* Forward declaration */
// OBSOLETE extern struct cmd_list_element *setlist;
// OBSOLETE extern struct cmd_list_element *unsetlist;
// OBSOLETE extern int attach_flag;
// OBSOLETE 
// OBSOLETE static void rombug_close ();
// OBSOLETE static void rombug_fetch_register ();
// OBSOLETE static void rombug_fetch_registers ();
// OBSOLETE static void rombug_store_register ();
// OBSOLETE #if 0
// OBSOLETE static int sr_get_debug ();	/* flag set by "set remotedebug" */
// OBSOLETE #endif
// OBSOLETE static int hashmark;		/* flag set by "set hash" */
// OBSOLETE static int rombug_is_open = 0;
// OBSOLETE 
// OBSOLETE /* FIXME: Replace with sr_get_debug ().  */
// OBSOLETE #define LOG_FILE "monitor.log"
// OBSOLETE FILE *log_file;
// OBSOLETE static int monitor_log = 0;
// OBSOLETE static int tty_xon = 0;
// OBSOLETE static int tty_xoff = 0;
// OBSOLETE 
// OBSOLETE static int timeout = 10;
// OBSOLETE static int is_trace_mode = 0;
// OBSOLETE /* Descriptor for I/O to remote machine.  Initialize it to NULL */
// OBSOLETE static struct serial *monitor_desc = NULL;
// OBSOLETE 
// OBSOLETE static CORE_ADDR bufaddr = 0;
// OBSOLETE static int buflen = 0;
// OBSOLETE static char readbuf[16];
// OBSOLETE 
// OBSOLETE /* Send data to monitor.  Works just like printf. */
// OBSOLETE static void
// OBSOLETE printf_monitor (char *pattern,...)
// OBSOLETE {
// OBSOLETE   va_list args;
// OBSOLETE   char buf[200];
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   va_start (args, pattern);
// OBSOLETE 
// OBSOLETE   vsprintf (buf, pattern, args);
// OBSOLETE   va_end (args);
// OBSOLETE 
// OBSOLETE   if (serial_write (monitor_desc, buf, strlen (buf)))
// OBSOLETE     fprintf_unfiltered (gdb_stderr, "serial_write failed: %s\n",
// OBSOLETE 			safe_strerror (errno));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Read a character from the remote system, doing all the fancy timeout stuff */
// OBSOLETE static int
// OBSOLETE readchar (int timeout)
// OBSOLETE {
// OBSOLETE   int c;
// OBSOLETE 
// OBSOLETE   c = serial_readchar (monitor_desc, timeout);
// OBSOLETE 
// OBSOLETE   if (sr_get_debug ())
// OBSOLETE     putchar (c & 0x7f);
// OBSOLETE 
// OBSOLETE   if (monitor_log && isascii (c))
// OBSOLETE     putc (c & 0x7f, log_file);
// OBSOLETE 
// OBSOLETE   if (c >= 0)
// OBSOLETE     return c & 0x7f;
// OBSOLETE 
// OBSOLETE   if (c == SERIAL_TIMEOUT)
// OBSOLETE     {
// OBSOLETE       if (timeout == 0)
// OBSOLETE 	return c;		/* Polls shouldn't generate timeout errors */
// OBSOLETE 
// OBSOLETE       error ("Timeout reading from remote system.");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   perror_with_name ("remote-monitor");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Scan input from the remote system, until STRING is found.  If DISCARD is
// OBSOLETE    non-zero, then discard non-matching input, else print it out.
// OBSOLETE    Let the user break out immediately.  */
// OBSOLETE static void
// OBSOLETE expect (char *string, int discard)
// OBSOLETE {
// OBSOLETE   char *p = string;
// OBSOLETE   int c;
// OBSOLETE 
// OBSOLETE   if (sr_get_debug ())
// OBSOLETE     printf ("Expecting \"%s\"\n", string);
// OBSOLETE 
// OBSOLETE   immediate_quit++;
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       c = readchar (timeout);
// OBSOLETE       if (!isascii (c))
// OBSOLETE 	continue;
// OBSOLETE       if (c == *p++)
// OBSOLETE 	{
// OBSOLETE 	  if (*p == '\0')
// OBSOLETE 	    {
// OBSOLETE 	      immediate_quit--;
// OBSOLETE 	      if (sr_get_debug ())
// OBSOLETE 		printf ("\nMatched\n");
// OBSOLETE 	      return;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (!discard)
// OBSOLETE 	    {
// OBSOLETE 	      fwrite (string, 1, (p - 1) - string, stdout);
// OBSOLETE 	      putchar ((char) c);
// OBSOLETE 	      fflush (stdout);
// OBSOLETE 	    }
// OBSOLETE 	  p = string;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Keep discarding input until we see the ROMBUG prompt.
// OBSOLETE 
// OBSOLETE    The convention for dealing with the prompt is that you
// OBSOLETE    o give your command
// OBSOLETE    o *then* wait for the prompt.
// OBSOLETE 
// OBSOLETE    Thus the last thing that a procedure does with the serial line
// OBSOLETE    will be an expect_prompt().  Exception:  rombug_resume does not
// OBSOLETE    wait for the prompt, because the terminal is being handed over
// OBSOLETE    to the inferior.  However, the next thing which happens after that
// OBSOLETE    is a rombug_wait which does wait for the prompt.
// OBSOLETE    Note that this includes abnormal exit, e.g. error().  This is
// OBSOLETE    necessary to prevent getting into states from which we can't
// OBSOLETE    recover.  */
// OBSOLETE static void
// OBSOLETE expect_prompt (int discard)
// OBSOLETE {
// OBSOLETE   if (monitor_log)
// OBSOLETE     /* This is a convenient place to do this.  The idea is to do it often
// OBSOLETE        enough that we never lose much data if we terminate abnormally.  */
// OBSOLETE     fflush (log_file);
// OBSOLETE 
// OBSOLETE   if (is_trace_mode)
// OBSOLETE     {
// OBSOLETE       expect ("trace", discard);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       expect (PROMPT, discard);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Get a hex digit from the remote system & return its value.
// OBSOLETE    If ignore_space is nonzero, ignore spaces (not newline, tab, etc).  */
// OBSOLETE static int
// OBSOLETE get_hex_digit (int ignore_space)
// OBSOLETE {
// OBSOLETE   int ch;
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       ch = readchar (timeout);
// OBSOLETE       if (ch >= '0' && ch <= '9')
// OBSOLETE 	return ch - '0';
// OBSOLETE       else if (ch >= 'A' && ch <= 'F')
// OBSOLETE 	return ch - 'A' + 10;
// OBSOLETE       else if (ch >= 'a' && ch <= 'f')
// OBSOLETE 	return ch - 'a' + 10;
// OBSOLETE       else if (ch == ' ' && ignore_space)
// OBSOLETE 	;
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  expect_prompt (1);
// OBSOLETE 	  error ("Invalid hex digit from remote system.");
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Get a byte from monitor and put it in *BYT.  Accept any number
// OBSOLETE    leading spaces.  */
// OBSOLETE static void
// OBSOLETE get_hex_byte (char *byt)
// OBSOLETE {
// OBSOLETE   int val;
// OBSOLETE 
// OBSOLETE   val = get_hex_digit (1) << 4;
// OBSOLETE   val |= get_hex_digit (0);
// OBSOLETE   *byt = val;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Get N 32-bit words from remote, each preceded by a space,
// OBSOLETE    and put them in registers starting at REGNO.  */
// OBSOLETE static void
// OBSOLETE get_hex_regs (int n, int regno)
// OBSOLETE {
// OBSOLETE   long val;
// OBSOLETE   int i;
// OBSOLETE   unsigned char b;
// OBSOLETE 
// OBSOLETE   for (i = 0; i < n; i++)
// OBSOLETE     {
// OBSOLETE       int j;
// OBSOLETE 
// OBSOLETE       val = 0;
// OBSOLETE       for (j = 0; j < 4; j++)
// OBSOLETE 	{
// OBSOLETE 	  get_hex_byte (&b);
// OBSOLETE 	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
// OBSOLETE 	    val = (val << 8) + b;
// OBSOLETE 	  else
// OBSOLETE 	    val = val + (b << (j * 8));
// OBSOLETE 	}
// OBSOLETE       supply_register (regno++, (char *) &val);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* This is called not only when we first attach, but also when the
// OBSOLETE    user types "run" after having attached.  */
// OBSOLETE static void
// OBSOLETE rombug_create_inferior (char *execfile, char *args, char **env)
// OBSOLETE {
// OBSOLETE   int entry_pt;
// OBSOLETE 
// OBSOLETE   if (args && *args)
// OBSOLETE     error ("Can't pass arguments to remote ROMBUG process");
// OBSOLETE 
// OBSOLETE   if (execfile == 0 || exec_bfd == 0)
// OBSOLETE     error ("No executable file specified");
// OBSOLETE 
// OBSOLETE   entry_pt = (int) bfd_get_start_address (exec_bfd);
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fputs ("\nIn Create_inferior()", log_file);
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* The "process" (board) is already stopped awaiting our commands, and
// OBSOLETE    the program is already downloaded.  We just set its PC and go.  */
// OBSOLETE 
// OBSOLETE   init_wait_for_inferior ();
// OBSOLETE   proceed ((CORE_ADDR) entry_pt, TARGET_SIGNAL_DEFAULT, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Open a connection to a remote debugger.
// OBSOLETE    NAME is the filename used for communication.  */
// OBSOLETE 
// OBSOLETE static char dev_name[100];
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_open (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   if (args == NULL)
// OBSOLETE     error ("Use `target RomBug DEVICE-NAME' to use a serial port, or \n\
// OBSOLETE `target RomBug HOST-NAME:PORT-NUMBER' to use a network connection.");
// OBSOLETE 
// OBSOLETE   target_preopen (from_tty);
// OBSOLETE 
// OBSOLETE   if (rombug_is_open)
// OBSOLETE     unpush_target (&rombug_ops);
// OBSOLETE 
// OBSOLETE   strcpy (dev_name, args);
// OBSOLETE   monitor_desc = serial_open (dev_name);
// OBSOLETE   if (monitor_desc == NULL)
// OBSOLETE     perror_with_name (dev_name);
// OBSOLETE 
// OBSOLETE   /* if baud rate is set by 'set remotebaud' */
// OBSOLETE   if (serial_setbaudrate (monitor_desc, sr_get_baud_rate ()))
// OBSOLETE     {
// OBSOLETE       serial_close (monitor_desc);
// OBSOLETE       perror_with_name ("RomBug");
// OBSOLETE     }
// OBSOLETE   serial_raw (monitor_desc);
// OBSOLETE   if (tty_xon || tty_xoff)
// OBSOLETE     {
// OBSOLETE       struct hardware_ttystate
// OBSOLETE 	{
// OBSOLETE 	  struct termios t;
// OBSOLETE 	}
// OBSOLETE        *tty_s;
// OBSOLETE 
// OBSOLETE       tty_s = (struct hardware_ttystate *) serial_get_tty_state (monitor_desc);
// OBSOLETE       if (tty_xon)
// OBSOLETE 	tty_s->t.c_iflag |= IXON;
// OBSOLETE       if (tty_xoff)
// OBSOLETE 	tty_s->t.c_iflag |= IXOFF;
// OBSOLETE       serial_set_tty_state (monitor_desc, (serial_ttystate) tty_s);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   rombug_is_open = 1;
// OBSOLETE 
// OBSOLETE   log_file = fopen (LOG_FILE, "w");
// OBSOLETE   if (log_file == NULL)
// OBSOLETE     perror_with_name (LOG_FILE);
// OBSOLETE 
// OBSOLETE   push_monitor (&rombug_cmds);
// OBSOLETE   printf_monitor ("\r");	/* CR wakes up monitor */
// OBSOLETE   expect_prompt (1);
// OBSOLETE   push_target (&rombug_ops);
// OBSOLETE   attach_flag = 1;
// OBSOLETE 
// OBSOLETE   if (from_tty)
// OBSOLETE     printf ("Remote %s connected to %s\n", target_shortname,
// OBSOLETE 	    dev_name);
// OBSOLETE 
// OBSOLETE   rombug_fetch_registers ();
// OBSOLETE 
// OBSOLETE   printf_monitor ("ov e \r");
// OBSOLETE   expect_prompt (1);
// OBSOLETE   bufaddr = 0;
// OBSOLETE   buflen = 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Close out all files and local state before this target loses control.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_close (int quitting)
// OBSOLETE {
// OBSOLETE   if (rombug_is_open)
// OBSOLETE     {
// OBSOLETE       serial_close (monitor_desc);
// OBSOLETE       monitor_desc = NULL;
// OBSOLETE       rombug_is_open = 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (log_file)
// OBSOLETE     {
// OBSOLETE       if (ferror (log_file))
// OBSOLETE 	fprintf_unfiltered (gdb_stderr, "Error writing log file.\n");
// OBSOLETE       if (fclose (log_file) != 0)
// OBSOLETE 	fprintf_unfiltered (gdb_stderr, "Error closing log file.\n");
// OBSOLETE       log_file = 0;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE rombug_link (char *mod_name, CORE_ADDR *text_reloc)
// OBSOLETE {
// OBSOLETE   int i, j;
// OBSOLETE   unsigned long val;
// OBSOLETE   unsigned char b;
// OBSOLETE 
// OBSOLETE   printf_monitor ("l %s \r", mod_name);
// OBSOLETE   expect_prompt (1);
// OBSOLETE   printf_monitor (".r \r");
// OBSOLETE   expect (REG_DELIM, 1);
// OBSOLETE   for (i = 0; i <= 7; i++)
// OBSOLETE     {
// OBSOLETE       val = 0;
// OBSOLETE       for (j = 0; j < 4; j++)
// OBSOLETE 	{
// OBSOLETE 	  get_hex_byte (&b);
// OBSOLETE 	  val = (val << 8) + b;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   expect_prompt (1);
// OBSOLETE   *text_reloc = val;
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Terminate the open connection to the remote debugger.
// OBSOLETE    Use this when you want to detach and do something else
// OBSOLETE    with your gdb.  */
// OBSOLETE static void
// OBSOLETE rombug_detach (int from_tty)
// OBSOLETE {
// OBSOLETE   if (attach_flag)
// OBSOLETE     {
// OBSOLETE       printf_monitor (GO_CMD);
// OBSOLETE       attach_flag = 0;
// OBSOLETE     }
// OBSOLETE   pop_target ();		/* calls rombug_close to do the real work */
// OBSOLETE   if (from_tty)
// OBSOLETE     printf ("Ending remote %s debugging\n", target_shortname);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Tell the remote machine to resume.
// OBSOLETE  */
// OBSOLETE static void
// OBSOLETE rombug_resume (ptid_t ptid, int step, enum target_signal sig)
// OBSOLETE {
// OBSOLETE   if (monitor_log)
// OBSOLETE     fprintf (log_file, "\nIn Resume (step=%d, sig=%d)\n", step, sig);
// OBSOLETE 
// OBSOLETE   if (step)
// OBSOLETE     {
// OBSOLETE       is_trace_mode = 1;
// OBSOLETE       printf_monitor (STEP_CMD);
// OBSOLETE       /* wait for the echo.  **
// OBSOLETE          expect (STEP_CMD, 1);
// OBSOLETE        */
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       printf_monitor (GO_CMD);
// OBSOLETE       /* swallow the echo.  **
// OBSOLETE          expect (GO_CMD, 1);
// OBSOLETE        */
// OBSOLETE     }
// OBSOLETE   bufaddr = 0;
// OBSOLETE   buflen = 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Wait until the remote machine stops, then return,
// OBSOLETE  * storing status in status just as `wait' would.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static ptid *
// OBSOLETE rombug_wait (ptid_t ptid, struct target_waitstatus *status)
// OBSOLETE {
// OBSOLETE   int old_timeout = timeout;
// OBSOLETE   struct section_offsets *offs;
// OBSOLETE   CORE_ADDR addr, pc;
// OBSOLETE   struct obj_section *obj_sec;
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fputs ("\nIn wait ()", log_file);
// OBSOLETE 
// OBSOLETE   status->kind = TARGET_WAITKIND_EXITED;
// OBSOLETE   status->value.integer = 0;
// OBSOLETE 
// OBSOLETE   timeout = -1;			/* Don't time out -- user program is running. */
// OBSOLETE   expect ("eax:", 0);		/* output any message before register display */
// OBSOLETE   expect_prompt (1);		/* Wait for prompt, outputting extraneous text */
// OBSOLETE 
// OBSOLETE   status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE   status->value.sig = TARGET_SIGNAL_TRAP;
// OBSOLETE   timeout = old_timeout;
// OBSOLETE   rombug_fetch_registers ();
// OBSOLETE   bufaddr = 0;
// OBSOLETE   buflen = 0;
// OBSOLETE   pc = read_register (PC_REGNUM);
// OBSOLETE   addr = read_register (DATABASE_REG);
// OBSOLETE   obj_sec = find_pc_section (pc);
// OBSOLETE   if (obj_sec != NULL)
// OBSOLETE     {
// OBSOLETE       if (obj_sec->objfile != symfile_objfile)
// OBSOLETE 	new_symfile_objfile (obj_sec->objfile, 1, 0);
// OBSOLETE       offs = (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
// OBSOLETE       memcpy (offs, symfile_objfile->section_offsets, SIZEOF_SECTION_OFFSETS);
// OBSOLETE       offs->offsets[SECT_OFF_DATA (symfile_objfile)]  = addr;
// OBSOLETE       offs->offsets[SECT_OFF_BSS (symfile_objfile)]  = addr;
// OBSOLETE 
// OBSOLETE       objfile_relocate (symfile_objfile, offs);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return inferior_ptid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the name of register number regno in the form input and output by
// OBSOLETE    monitor.  Currently, register_names just happens to contain exactly what
// OBSOLETE    monitor wants.  Lets take advantage of that just as long as possible! */
// OBSOLETE 
// OBSOLETE static char *
// OBSOLETE get_reg_name (int regno)
// OBSOLETE {
// OBSOLETE   static char buf[50];
// OBSOLETE   char *p;
// OBSOLETE   char *b;
// OBSOLETE 
// OBSOLETE   b = buf;
// OBSOLETE 
// OBSOLETE   if (regno < 0)
// OBSOLETE     return ("");
// OBSOLETE /*
// OBSOLETE    for (p = REGISTER_NAME (regno); *p; p++)
// OBSOLETE    *b++ = toupper(*p);
// OBSOLETE    *b = '\000';
// OBSOLETE  */
// OBSOLETE   p = (char *) REGISTER_NAME (regno);
// OBSOLETE   return p;
// OBSOLETE /*
// OBSOLETE    return buf;
// OBSOLETE  */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* read the remote registers into the block regs.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_fetch_registers (void)
// OBSOLETE {
// OBSOLETE   int regno, j, i;
// OBSOLETE   long val;
// OBSOLETE   unsigned char b;
// OBSOLETE 
// OBSOLETE   printf_monitor (GET_REG);
// OBSOLETE   expect ("eax:", 1);
// OBSOLETE   expect ("\n", 1);
// OBSOLETE   get_hex_regs (1, 0);
// OBSOLETE   get_hex_regs (1, 3);
// OBSOLETE   get_hex_regs (1, 1);
// OBSOLETE   get_hex_regs (1, 2);
// OBSOLETE   get_hex_regs (1, 6);
// OBSOLETE   get_hex_regs (1, 7);
// OBSOLETE   get_hex_regs (1, 5);
// OBSOLETE   get_hex_regs (1, 4);
// OBSOLETE   for (regno = 8; regno <= 15; regno++)
// OBSOLETE     {
// OBSOLETE       expect (REG_DELIM, 1);
// OBSOLETE       if (regno >= 8 && regno <= 13)
// OBSOLETE 	{
// OBSOLETE 	  val = 0;
// OBSOLETE 	  for (j = 0; j < 2; j++)
// OBSOLETE 	    {
// OBSOLETE 	      get_hex_byte (&b);
// OBSOLETE 	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
// OBSOLETE 		val = (val << 8) + b;
// OBSOLETE 	      else
// OBSOLETE 		val = val + (b << (j * 8));
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  if (regno == 8)
// OBSOLETE 	    i = 10;
// OBSOLETE 	  if (regno >= 9 && regno <= 12)
// OBSOLETE 	    i = regno + 3;
// OBSOLETE 	  if (regno == 13)
// OBSOLETE 	    i = 11;
// OBSOLETE 	  supply_register (i, (char *) &val);
// OBSOLETE 	}
// OBSOLETE       else if (regno == 14)
// OBSOLETE 	{
// OBSOLETE 	  get_hex_regs (1, PC_REGNUM);
// OBSOLETE 	}
// OBSOLETE       else if (regno == 15)
// OBSOLETE 	{
// OBSOLETE 	  get_hex_regs (1, 9);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  val = 0;
// OBSOLETE 	  supply_register (regno, (char *) &val);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   is_trace_mode = 0;
// OBSOLETE   expect_prompt (1);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Fetch register REGNO, or all registers if REGNO is -1.
// OBSOLETE    Returns errno value.  */
// OBSOLETE static void
// OBSOLETE rombug_fetch_register (int regno)
// OBSOLETE {
// OBSOLETE   int val, j;
// OBSOLETE   unsigned char b;
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     {
// OBSOLETE       fprintf (log_file, "\nIn Fetch Register (reg=%s)\n", get_reg_name (regno));
// OBSOLETE       fflush (log_file);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (regno < 0)
// OBSOLETE     {
// OBSOLETE       rombug_fetch_registers ();
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       char *name = get_reg_name (regno);
// OBSOLETE       printf_monitor (GET_REG);
// OBSOLETE       if (regno >= 10 && regno <= 15)
// OBSOLETE 	{
// OBSOLETE 	  expect ("\n", 1);
// OBSOLETE 	  expect ("\n", 1);
// OBSOLETE 	  expect (name, 1);
// OBSOLETE 	  expect (REG_DELIM, 1);
// OBSOLETE 	  val = 0;
// OBSOLETE 	  for (j = 0; j < 2; j++)
// OBSOLETE 	    {
// OBSOLETE 	      get_hex_byte (&b);
// OBSOLETE 	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
// OBSOLETE 		val = (val << 8) + b;
// OBSOLETE 	      else
// OBSOLETE 		val = val + (b << (j * 8));
// OBSOLETE 	    }
// OBSOLETE 	  supply_register (regno, (char *) &val);
// OBSOLETE 	}
// OBSOLETE       else if (regno == 8 || regno == 9)
// OBSOLETE 	{
// OBSOLETE 	  expect ("\n", 1);
// OBSOLETE 	  expect ("\n", 1);
// OBSOLETE 	  expect ("\n", 1);
// OBSOLETE 	  expect (name, 1);
// OBSOLETE 	  expect (REG_DELIM, 1);
// OBSOLETE 	  get_hex_regs (1, regno);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  expect (name, 1);
// OBSOLETE 	  expect (REG_DELIM, 1);
// OBSOLETE 	  expect ("\n", 1);
// OBSOLETE 	  get_hex_regs (1, 0);
// OBSOLETE 	  get_hex_regs (1, 3);
// OBSOLETE 	  get_hex_regs (1, 1);
// OBSOLETE 	  get_hex_regs (1, 2);
// OBSOLETE 	  get_hex_regs (1, 6);
// OBSOLETE 	  get_hex_regs (1, 7);
// OBSOLETE 	  get_hex_regs (1, 5);
// OBSOLETE 	  get_hex_regs (1, 4);
// OBSOLETE 	}
// OBSOLETE       expect_prompt (1);
// OBSOLETE     }
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store the remote registers from the contents of the block REGS.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_store_registers (void)
// OBSOLETE {
// OBSOLETE   int regno;
// OBSOLETE 
// OBSOLETE   for (regno = 0; regno <= PC_REGNUM; regno++)
// OBSOLETE     rombug_store_register (regno);
// OBSOLETE 
// OBSOLETE   registers_changed ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store register REGNO, or all if REGNO == 0.
// OBSOLETE    return errno value.  */
// OBSOLETE static void
// OBSOLETE rombug_store_register (int regno)
// OBSOLETE {
// OBSOLETE   char *name;
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fprintf (log_file, "\nIn Store_register (regno=%d)\n", regno);
// OBSOLETE 
// OBSOLETE   if (regno == -1)
// OBSOLETE     rombug_store_registers ();
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if (sr_get_debug ())
// OBSOLETE 	printf ("Setting register %s to 0x%x\n", get_reg_name (regno), read_register (regno));
// OBSOLETE 
// OBSOLETE       name = get_reg_name (regno);
// OBSOLETE       if (name == 0)
// OBSOLETE 	return;
// OBSOLETE       printf_monitor (SET_REG, name, read_register (regno));
// OBSOLETE 
// OBSOLETE       is_trace_mode = 0;
// OBSOLETE       expect_prompt (1);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Get ready to modify the registers array.  On machines which store
// OBSOLETE    individual registers, this doesn't need to do anything.  On machines
// OBSOLETE    which store all the registers in one fell swoop, this makes sure
// OBSOLETE    that registers contains all the registers from the program being
// OBSOLETE    debugged.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_prepare_to_store (void)
// OBSOLETE {
// OBSOLETE   /* Do nothing, since we can store individual regs */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_files_info (void)
// OBSOLETE {
// OBSOLETE   printf ("\tAttached to %s at %d baud.\n",
// OBSOLETE 	  dev_name, sr_get_baud_rate ());
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Copy LEN bytes of data from debugger memory at MYADDR
// OBSOLETE    to inferior's memory at MEMADDR.  Returns length moved.  */
// OBSOLETE static int
// OBSOLETE rombug_write_inferior_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   char buf[10];
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fprintf (log_file, "\nIn Write_inferior_memory (memaddr=%x, len=%d)\n", memaddr, len);
// OBSOLETE 
// OBSOLETE   printf_monitor (MEM_SET_CMD, memaddr);
// OBSOLETE   for (i = 0; i < len; i++)
// OBSOLETE     {
// OBSOLETE       expect (CMD_DELIM, 1);
// OBSOLETE       printf_monitor ("%x \r", myaddr[i]);
// OBSOLETE       if (sr_get_debug ())
// OBSOLETE 	printf ("\nSet 0x%x to 0x%x\n", memaddr + i, myaddr[i]);
// OBSOLETE     }
// OBSOLETE   expect (CMD_DELIM, 1);
// OBSOLETE   if (CMD_END)
// OBSOLETE     printf_monitor (CMD_END);
// OBSOLETE   is_trace_mode = 0;
// OBSOLETE   expect_prompt (1);
// OBSOLETE 
// OBSOLETE   bufaddr = 0;
// OBSOLETE   buflen = 0;
// OBSOLETE   return len;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Read LEN bytes from inferior memory at MEMADDR.  Put the result
// OBSOLETE    at debugger address MYADDR.  Returns length moved.  */
// OBSOLETE static int
// OBSOLETE rombug_read_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
// OBSOLETE {
// OBSOLETE   int i, j;
// OBSOLETE 
// OBSOLETE   /* Number of bytes read so far.  */
// OBSOLETE   int count;
// OBSOLETE 
// OBSOLETE   /* Starting address of this pass.  */
// OBSOLETE   unsigned long startaddr;
// OBSOLETE 
// OBSOLETE   /* Number of bytes to read in this pass.  */
// OBSOLETE   int len_this_pass;
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fprintf (log_file, "\nIn Read_inferior_memory (memaddr=%x, len=%d)\n", memaddr, len);
// OBSOLETE 
// OBSOLETE   /* Note that this code works correctly if startaddr is just less
// OBSOLETE      than UINT_MAX (well, really CORE_ADDR_MAX if there was such a
// OBSOLETE      thing).  That is, something like
// OBSOLETE      rombug_read_bytes (CORE_ADDR_MAX - 4, foo, 4)
// OBSOLETE      works--it never adds len To memaddr and gets 0.  */
// OBSOLETE   /* However, something like
// OBSOLETE      rombug_read_bytes (CORE_ADDR_MAX - 3, foo, 4)
// OBSOLETE      doesn't need to work.  Detect it and give up if there's an attempt
// OBSOLETE      to do that.  */
// OBSOLETE   if (((memaddr - 1) + len) < memaddr)
// OBSOLETE     {
// OBSOLETE       errno = EIO;
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE   if (bufaddr <= memaddr && (memaddr + len) <= (bufaddr + buflen))
// OBSOLETE     {
// OBSOLETE       memcpy (myaddr, &readbuf[memaddr - bufaddr], len);
// OBSOLETE       return len;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   startaddr = memaddr;
// OBSOLETE   count = 0;
// OBSOLETE   while (count < len)
// OBSOLETE     {
// OBSOLETE       len_this_pass = 16;
// OBSOLETE       if ((startaddr % 16) != 0)
// OBSOLETE 	len_this_pass -= startaddr % 16;
// OBSOLETE       if (len_this_pass > (len - count))
// OBSOLETE 	len_this_pass = (len - count);
// OBSOLETE       if (sr_get_debug ())
// OBSOLETE 	printf ("\nDisplay %d bytes at %x\n", len_this_pass, startaddr);
// OBSOLETE 
// OBSOLETE       printf_monitor (MEM_DIS_CMD, startaddr, 8);
// OBSOLETE       expect ("- ", 1);
// OBSOLETE       for (i = 0; i < 16; i++)
// OBSOLETE 	{
// OBSOLETE 	  get_hex_byte (&readbuf[i]);
// OBSOLETE 	}
// OBSOLETE       bufaddr = startaddr;
// OBSOLETE       buflen = 16;
// OBSOLETE       memcpy (&myaddr[count], readbuf, len_this_pass);
// OBSOLETE       count += len_this_pass;
// OBSOLETE       startaddr += len_this_pass;
// OBSOLETE       expect (CMD_DELIM, 1);
// OBSOLETE     }
// OBSOLETE   if (CMD_END)
// OBSOLETE     printf_monitor (CMD_END);
// OBSOLETE   is_trace_mode = 0;
// OBSOLETE   expect_prompt (1);
// OBSOLETE 
// OBSOLETE   return len;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Transfer LEN bytes between GDB address MYADDR and target address
// OBSOLETE    MEMADDR.  If WRITE is non-zero, transfer them to the target,
// OBSOLETE    otherwise transfer them from the target.  TARGET is unused.
// OBSOLETE 
// OBSOLETE    Returns the number of bytes transferred. */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE rombug_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len,
// OBSOLETE 			     int write, struct mem_attrib *attrib,
// OBSOLETE 			     struct target_ops *target)
// OBSOLETE {
// OBSOLETE   if (write)
// OBSOLETE     return rombug_write_inferior_memory (memaddr, myaddr, len);
// OBSOLETE   else
// OBSOLETE     return rombug_read_inferior_memory (memaddr, myaddr, len);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_kill (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   return;			/* ignore attempts to kill target system */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Clean up when a program exits.
// OBSOLETE    The program actually lives on in the remote processor's RAM, and may be
// OBSOLETE    run again without a download.  Don't leave it full of breakpoint
// OBSOLETE    instructions.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_mourn_inferior (void)
// OBSOLETE {
// OBSOLETE   remove_breakpoints ();
// OBSOLETE   generic_mourn_inferior ();	/* Do all the proper things now */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #define MAX_MONITOR_BREAKPOINTS 16
// OBSOLETE 
// OBSOLETE static CORE_ADDR breakaddr[MAX_MONITOR_BREAKPOINTS] =
// OBSOLETE {0};
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE rombug_insert_breakpoint (CORE_ADDR addr, char *shadow)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   CORE_ADDR bp_addr = addr;
// OBSOLETE   int bp_size = 0;
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fprintf (log_file, "\nIn Insert_breakpoint (addr=%x)\n", addr);
// OBSOLETE   BREAKPOINT_FROM_PC (&bp_addr, &bp_size);
// OBSOLETE 
// OBSOLETE   for (i = 0; i <= MAX_MONITOR_BREAKPOINTS; i++)
// OBSOLETE     if (breakaddr[i] == 0)
// OBSOLETE       {
// OBSOLETE 	breakaddr[i] = addr;
// OBSOLETE 	if (sr_get_debug ())
// OBSOLETE 	  printf ("Breakpoint at %x\n", addr);
// OBSOLETE 	rombug_read_inferior_memory (bp_addr, shadow, bp_size);
// OBSOLETE 	printf_monitor (SET_BREAK_CMD, addr);
// OBSOLETE 	is_trace_mode = 0;
// OBSOLETE 	expect_prompt (1);
// OBSOLETE 	return 0;
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE   fprintf_unfiltered (gdb_stderr, "Too many breakpoints (> 16) for monitor\n");
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * _remove_breakpoint -- Tell the monitor to remove a breakpoint
// OBSOLETE  */
// OBSOLETE static int
// OBSOLETE rombug_remove_breakpoint (CORE_ADDR addr, char *shadow)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fprintf (log_file, "\nIn Remove_breakpoint (addr=%x)\n", addr);
// OBSOLETE 
// OBSOLETE   for (i = 0; i < MAX_MONITOR_BREAKPOINTS; i++)
// OBSOLETE     if (breakaddr[i] == addr)
// OBSOLETE       {
// OBSOLETE 	breakaddr[i] = 0;
// OBSOLETE 	printf_monitor (CLR_BREAK_CMD, addr);
// OBSOLETE 	is_trace_mode = 0;
// OBSOLETE 	expect_prompt (1);
// OBSOLETE 	return 0;
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE   fprintf_unfiltered (gdb_stderr,
// OBSOLETE 		      "Can't find breakpoint associated with 0x%x\n", addr);
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Load a file. This is usually an srecord, which is ascii. No 
// OBSOLETE    protocol, just sent line by line. */
// OBSOLETE 
// OBSOLETE #define DOWNLOAD_LINE_SIZE 100
// OBSOLETE static void
// OBSOLETE rombug_load (char *arg)
// OBSOLETE {
// OBSOLETE /* this part comment out for os9* */
// OBSOLETE #if 0
// OBSOLETE   FILE *download;
// OBSOLETE   char buf[DOWNLOAD_LINE_SIZE];
// OBSOLETE   int i, bytes_read;
// OBSOLETE 
// OBSOLETE   if (sr_get_debug ())
// OBSOLETE     printf ("Loading %s to monitor\n", arg);
// OBSOLETE 
// OBSOLETE   download = fopen (arg, "r");
// OBSOLETE   if (download == NULL)
// OBSOLETE     {
// OBSOLETE       error (sprintf (buf, "%s Does not exist", arg));
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   printf_monitor (LOAD_CMD);
// OBSOLETE /*  expect ("Waiting for S-records from host... ", 1); */
// OBSOLETE 
// OBSOLETE   while (!feof (download))
// OBSOLETE     {
// OBSOLETE       bytes_read = fread (buf, sizeof (char), DOWNLOAD_LINE_SIZE, download);
// OBSOLETE       if (hashmark)
// OBSOLETE 	{
// OBSOLETE 	  putchar ('.');
// OBSOLETE 	  fflush (stdout);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (serial_write (monitor_desc, buf, bytes_read))
// OBSOLETE 	{
// OBSOLETE 	  fprintf_unfiltered (gdb_stderr,
// OBSOLETE 			      "serial_write failed: (while downloading) %s\n",
// OBSOLETE 			      safe_strerror (errno));
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       i = 0;
// OBSOLETE       while (i++ <= 200000)
// OBSOLETE 	{
// OBSOLETE 	};			/* Ugly HACK, probably needs flow control */
// OBSOLETE       if (bytes_read < DOWNLOAD_LINE_SIZE)
// OBSOLETE 	{
// OBSOLETE 	  if (!feof (download))
// OBSOLETE 	    error ("Only read %d bytes\n", bytes_read);
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (hashmark)
// OBSOLETE     {
// OBSOLETE       putchar ('\n');
// OBSOLETE     }
// OBSOLETE   if (!feof (download))
// OBSOLETE     error ("Never got EOF while downloading");
// OBSOLETE   fclose (download);
// OBSOLETE #endif /* 0 */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Put a command string, in args, out to MONITOR.  
// OBSOLETE    Output from MONITOR is placed on the users terminal until the prompt 
// OBSOLETE    is seen. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE rombug_command (char *args, int fromtty)
// OBSOLETE {
// OBSOLETE   if (monitor_desc == NULL)
// OBSOLETE     error ("monitor target not open.");
// OBSOLETE 
// OBSOLETE   if (monitor_log)
// OBSOLETE     fprintf (log_file, "\nIn command (args=%s)\n", args);
// OBSOLETE 
// OBSOLETE   if (!args)
// OBSOLETE     error ("Missing command.");
// OBSOLETE 
// OBSOLETE   printf_monitor ("%s\r", args);
// OBSOLETE   expect_prompt (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE /* Connect the user directly to MONITOR.  This command acts just like the
// OBSOLETE    'cu' or 'tip' command.  Use <CR>~. or <CR>~^D to break out.  */
// OBSOLETE 
// OBSOLETE static struct ttystate ttystate;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE cleanup_tty (void)
// OBSOLETE {
// OBSOLETE   printf ("\r\n[Exiting connect mode]\r\n");
// OBSOLETE   /*serial_restore(0, &ttystate); */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE connect_command (char *args, int fromtty)
// OBSOLETE {
// OBSOLETE   fd_set readfds;
// OBSOLETE   int numfds;
// OBSOLETE   int c;
// OBSOLETE   char cur_esc = 0;
// OBSOLETE 
// OBSOLETE   dont_repeat ();
// OBSOLETE 
// OBSOLETE   if (monitor_desc == NULL)
// OBSOLETE     error ("monitor target not open.");
// OBSOLETE 
// OBSOLETE   if (args)
// OBSOLETE     fprintf ("This command takes no args.  They have been ignored.\n");
// OBSOLETE 
// OBSOLETE   printf ("[Entering connect mode.  Use ~. or ~^D to escape]\n");
// OBSOLETE 
// OBSOLETE   serial_raw (0, &ttystate);
// OBSOLETE 
// OBSOLETE   make_cleanup (cleanup_tty, 0);
// OBSOLETE 
// OBSOLETE   FD_ZERO (&readfds);
// OBSOLETE 
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       do
// OBSOLETE 	{
// OBSOLETE 	  FD_SET (0, &readfds);
// OBSOLETE 	  FD_SET (deprecated_serial_fd (monitor_desc), &readfds);
// OBSOLETE 	  numfds = select (sizeof (readfds) * 8, &readfds, 0, 0, 0);
// OBSOLETE 	}
// OBSOLETE       while (numfds == 0);
// OBSOLETE 
// OBSOLETE       if (numfds < 0)
// OBSOLETE 	perror_with_name ("select");
// OBSOLETE 
// OBSOLETE       if (FD_ISSET (0, &readfds))
// OBSOLETE 	{			/* tty input, send to monitor */
// OBSOLETE 	  c = getchar ();
// OBSOLETE 	  if (c < 0)
// OBSOLETE 	    perror_with_name ("connect");
// OBSOLETE 
// OBSOLETE 	  printf_monitor ("%c", c);
// OBSOLETE 	  switch (cur_esc)
// OBSOLETE 	    {
// OBSOLETE 	    case 0:
// OBSOLETE 	      if (c == '\r')
// OBSOLETE 		cur_esc = c;
// OBSOLETE 	      break;
// OBSOLETE 	    case '\r':
// OBSOLETE 	      if (c == '~')
// OBSOLETE 		cur_esc = c;
// OBSOLETE 	      else
// OBSOLETE 		cur_esc = 0;
// OBSOLETE 	      break;
// OBSOLETE 	    case '~':
// OBSOLETE 	      if (c == '.' || c == '\004')
// OBSOLETE 		return;
// OBSOLETE 	      else
// OBSOLETE 		cur_esc = 0;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (FD_ISSET (deprecated_serial_fd (monitor_desc), &readfds))
// OBSOLETE 	{
// OBSOLETE 	  while (1)
// OBSOLETE 	    {
// OBSOLETE 	      c = readchar (0);
// OBSOLETE 	      if (c < 0)
// OBSOLETE 		break;
// OBSOLETE 	      putchar (c);
// OBSOLETE 	    }
// OBSOLETE 	  fflush (stdout);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Define the monitor command strings. Since these are passed directly
// OBSOLETE  * through to a printf style function, we need can include formatting
// OBSOLETE  * strings. We also need a CR or LF on the end.
// OBSOLETE  */
// OBSOLETE #warning FIXME: monitor interface pattern strings, stale struct decl
// OBSOLETE struct monitor_ops rombug_cmds =
// OBSOLETE {
// OBSOLETE   "g \r",			/* execute or usually GO command */
// OBSOLETE   "g \r",			/* continue command */
// OBSOLETE   "t \r",			/* single step */
// OBSOLETE   "b %x\r",			/* set a breakpoint */
// OBSOLETE   "k %x\r",			/* clear a breakpoint */
// OBSOLETE   "c %x\r",			/* set memory to a value */
// OBSOLETE   "d %x %d\r",			/* display memory */
// OBSOLETE   "$%08X",			/* prompt memory commands use */
// OBSOLETE   ".%s %x\r",			/* set a register */
// OBSOLETE   ":",				/* delimiter between registers */
// OBSOLETE   ". \r",			/* read a register */
// OBSOLETE   "mf \r",			/* download command */
// OBSOLETE   "RomBug: ",			/* monitor command prompt */
// OBSOLETE   ": ",				/* end-of-command delimitor */
// OBSOLETE   ".\r"				/* optional command terminator */
// OBSOLETE };
// OBSOLETE 
// OBSOLETE struct target_ops rombug_ops;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_rombug_ops (void)
// OBSOLETE {
// OBSOLETE   rombug_ops.to_shortname = "rombug";
// OBSOLETE   rombug_ops.to_longname = "Microware's ROMBUG debug monitor";
// OBSOLETE   rombug_ops.to_doc = "Use a remote computer running the ROMBUG debug monitor.\n\
// OBSOLETE Specify the serial device it is connected to (e.g. /dev/ttya).",
// OBSOLETE     rombug_ops.to_open = rombug_open;
// OBSOLETE   rombug_ops.to_close = rombug_close;
// OBSOLETE   rombug_ops.to_attach = 0;
// OBSOLETE   rombug_ops.to_post_attach = NULL;
// OBSOLETE   rombug_ops.to_require_attach = NULL;
// OBSOLETE   rombug_ops.to_detach = rombug_detach;
// OBSOLETE   rombug_ops.to_require_detach = NULL;
// OBSOLETE   rombug_ops.to_resume = rombug_resume;
// OBSOLETE   rombug_ops.to_wait = rombug_wait;
// OBSOLETE   rombug_ops.to_post_wait = NULL;
// OBSOLETE   rombug_ops.to_fetch_registers = rombug_fetch_register;
// OBSOLETE   rombug_ops.to_store_registers = rombug_store_register;
// OBSOLETE   rombug_ops.to_prepare_to_store = rombug_prepare_to_store;
// OBSOLETE   rombug_ops.to_xfer_memory = rombug_xfer_inferior_memory;
// OBSOLETE   rombug_ops.to_files_info = rombug_files_info;
// OBSOLETE   rombug_ops.to_insert_breakpoint = rombug_insert_breakpoint;
// OBSOLETE   rombug_ops.to_remove_breakpoint = rombug_remove_breakpoint;	/* Breakpoints */
// OBSOLETE   rombug_ops.to_terminal_init = 0;
// OBSOLETE   rombug_ops.to_terminal_inferior = 0;
// OBSOLETE   rombug_ops.to_terminal_ours_for_output = 0;
// OBSOLETE   rombug_ops.to_terminal_ours = 0;
// OBSOLETE   rombug_ops.to_terminal_info = 0;	/* Terminal handling */
// OBSOLETE   rombug_ops.to_kill = rombug_kill;
// OBSOLETE   rombug_ops.to_load = rombug_load;	/* load */
// OBSOLETE   rombug_ops.to_lookup_symbol = rombug_link;	/* lookup_symbol */
// OBSOLETE   rombug_ops.to_create_inferior = rombug_create_inferior;
// OBSOLETE   rombug_ops.to_post_startup_inferior = NULL;
// OBSOLETE   rombug_ops.to_acknowledge_created_inferior = NULL;
// OBSOLETE   rombug_ops.to_clone_and_follow_inferior = NULL;
// OBSOLETE   rombug_ops.to_post_follow_inferior_by_clone = NULL;
// OBSOLETE   rombug_ops.to_insert_fork_catchpoint = NULL;
// OBSOLETE   rombug_ops.to_remove_fork_catchpoint = NULL;
// OBSOLETE   rombug_ops.to_insert_vfork_catchpoint = NULL;
// OBSOLETE   rombug_ops.to_remove_vfork_catchpoint = NULL;
// OBSOLETE   rombug_ops.to_has_forked = NULL;
// OBSOLETE   rombug_ops.to_has_vforked = NULL;
// OBSOLETE   rombug_ops.to_can_follow_vfork_prior_to_exec = NULL;
// OBSOLETE   rombug_ops.to_post_follow_vfork = NULL;
// OBSOLETE   rombug_ops.to_insert_exec_catchpoint = NULL;
// OBSOLETE   rombug_ops.to_remove_exec_catchpoint = NULL;
// OBSOLETE   rombug_ops.to_has_execd = NULL;
// OBSOLETE   rombug_ops.to_reported_exec_events_per_exec_call = NULL;
// OBSOLETE   rombug_ops.to_has_exited = NULL;
// OBSOLETE   rombug_ops.to_mourn_inferior = rombug_mourn_inferior;
// OBSOLETE   rombug_ops.to_can_run = 0;	/* can_run */
// OBSOLETE   rombug_ops.to_notice_signals = 0;	/* notice_signals */
// OBSOLETE   rombug_ops.to_thread_alive = 0;
// OBSOLETE   rombug_ops.to_stop = 0;	/* to_stop */
// OBSOLETE   rombug_ops.to_pid_to_exec_file = NULL;
// OBSOLETE   rombug_ops.to_stratum = process_stratum;
// OBSOLETE   rombug_ops.DONT_USE = 0;	/* next */
// OBSOLETE   rombug_ops.to_has_all_memory = 1;
// OBSOLETE   rombug_ops.to_has_memory = 1;
// OBSOLETE   rombug_ops.to_has_stack = 1;
// OBSOLETE   rombug_ops.to_has_registers = 1;
// OBSOLETE   rombug_ops.to_has_execution = 1;	/* has execution */
// OBSOLETE   rombug_ops.to_sections = 0;
// OBSOLETE   rombug_ops.to_sections_end = 0;	/* Section pointers */
// OBSOLETE   rombug_ops.to_magic = OPS_MAGIC;	/* Always the last thing */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_remote_os9k (void)
// OBSOLETE {
// OBSOLETE   init_rombug_ops ();
// OBSOLETE   add_target (&rombug_ops);
// OBSOLETE 
// OBSOLETE   add_show_from_set (
// OBSOLETE 	     add_set_cmd ("hash", no_class, var_boolean, (char *) &hashmark,
// OBSOLETE 			  "Set display of activity while downloading a file.\nWhen enabled, a period \'.\' is displayed.",
// OBSOLETE 			  &setlist),
// OBSOLETE 		      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set (
// OBSOLETE 		      add_set_cmd ("timeout", no_class, var_zinteger,
// OBSOLETE 				   (char *) &timeout,
// OBSOLETE 		       "Set timeout in seconds for remote MIPS serial I/O.",
// OBSOLETE 				   &setlist),
// OBSOLETE 		      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set (
// OBSOLETE 		      add_set_cmd ("remotelog", no_class, var_zinteger,
// OBSOLETE 				   (char *) &monitor_log,
// OBSOLETE 			      "Set monitor activity log on(=1) or off(=0).",
// OBSOLETE 				   &setlist),
// OBSOLETE 		      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set (
// OBSOLETE 		      add_set_cmd ("remotexon", no_class, var_zinteger,
// OBSOLETE 				   (char *) &tty_xon,
// OBSOLETE 				   "Set remote tty line XON control",
// OBSOLETE 				   &setlist),
// OBSOLETE 		      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set (
// OBSOLETE 		      add_set_cmd ("remotexoff", no_class, var_zinteger,
// OBSOLETE 				   (char *) &tty_xoff,
// OBSOLETE 				   "Set remote tty line XOFF control",
// OBSOLETE 				   &setlist),
// OBSOLETE 		      &showlist);
// OBSOLETE 
// OBSOLETE   add_com ("rombug <command>", class_obscure, rombug_command,
// OBSOLETE 	   "Send a command to the debug monitor.");
// OBSOLETE #if 0
// OBSOLETE   add_com ("connect", class_obscure, connect_command,
// OBSOLETE 	   "Connect the terminal directly up to a serial based command monitor.\nUse <CR>~. or <CR>~^D to break out.");
// OBSOLETE #endif
// OBSOLETE }
@


1.18
log
@Remove ATTRIBUTE_UNUSED.  Update (C).
@
text
@d104 2
a105 1
    fprintf (stderr, "serial_write failed: %s\n", safe_strerror (errno));
d384 1
a384 1
	fprintf (stderr, "Error writing log file.\n");
d386 1
a386 1
	fprintf (stderr, "Error closing log file.\n");
d887 1
a887 1
  fprintf (stderr, "Too many breakpoints (> 16) for monitor\n");
d912 2
a913 1
  fprintf (stderr, "Can't find breakpoint associated with 0x%x\n", addr);
d954 3
a956 1
	  fprintf (stderr, "serial_write failed: (while downloading) %s\n", safe_strerror (errno));
@


1.17
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d2 3
a4 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2001 Free Software Foundation, Inc.
d830 2
a831 3
			     int write, 
			     struct mem_attrib *attrib ATTRIBUTE_UNUSED,
			     struct target_ops *target ATTRIBUTE_UNUSED)
@


1.16
log
@* serial.h (SERIAL_ASYNC): Delete.
(DEPRECATED_SERIAL_FD): Delete.
(SERIAL_DEBUG): Delete.
(SERIAL_DEBUG_P): Delete.
(SERIAL_DRAIN_OUTPUT): Delete.
(SERIAL_FLUSH_OUTPUT): Delete.
(SERIAL_FLUSH_INPUT): Delete.
(SERIAL_SEND_BREAK): Delete.
(SERIAL_RAW): Delete.
(SERIAL_GET_TTY_STATE): Delete.
(SERIAL_SET_TTY_STATE): Delete.
(SERIAL_PRINT_TTY_STATE): Delete.
(SERIAL_NOFLUSH_SET_TTY_STATE): Delete.
(SERIAL_SETBAUDRATE): Delete.
(SERIAL_SETSTOPBITS): Delete.
(SERIAL_CAN_ASYNC_P): Delete.
(SERIAL_IS_ASYNC_P): Delete.
(SERIAL_UN_FDOPEN): Delete.
(SERIAL_READCHAR): Delete.
(SERIAL_CLOSE): Delete.
(SERIAL_FDOPEN): Delete.
(SERIAL_OPEN): Delete.
@
text
@d261 1
a261 1
	  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d561 1
a561 1
	      if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d625 1
a625 1
	      if (TARGET_BYTE_ORDER == BIG_ENDIAN)
@


1.15
log
@s/typedef serial_t/struct serial */
@
text
@d102 2
a103 2
  if (SERIAL_WRITE (monitor_desc, buf, strlen (buf)))
    fprintf (stderr, "SERIAL_WRITE failed: %s\n", safe_strerror (errno));
d112 1
a112 1
  c = SERIAL_READCHAR (monitor_desc, timeout);
d314 1
a314 1
  monitor_desc = SERIAL_OPEN (dev_name);
d319 1
a319 1
  if (SERIAL_SETBAUDRATE (monitor_desc, sr_get_baud_rate ()))
d321 1
a321 1
      SERIAL_CLOSE (monitor_desc);
d324 1
a324 1
  SERIAL_RAW (monitor_desc);
d333 1
a333 1
      tty_s = (struct hardware_ttystate *) SERIAL_GET_TTY_STATE (monitor_desc);
d338 1
a338 1
      SERIAL_SET_TTY_STATE (monitor_desc, (serial_ttystate) tty_s);
d374 1
a374 1
      SERIAL_CLOSE (monitor_desc);
d950 1
a950 1
      if (SERIAL_WRITE (monitor_desc, buf, bytes_read))
d952 1
a952 1
	  fprintf (stderr, "SERIAL_WRITE failed: (while downloading) %s\n", safe_strerror (errno));
d1007 1
a1007 1
  /*SERIAL_RESTORE(0, &ttystate); */
d1039 1
a1039 1
	  FD_SET (DEPRECATED_SERIAL_FD (monitor_desc), &readfds);
d1074 1
a1074 1
      if (FD_ISSET (DEPRECATED_SERIAL_FD (monitor_desc), &readfds))
@


1.14
log
@Phase 1 of the ptid_t changes.
@
text
@d83 1
a83 1
static serial_t monitor_desc = NULL;
@


1.13
log
@* target.h (target_ops): Removed to_core_file_to_sym_file vector
function.
* corelow.c (core_ops): Updated for above change.
* gnu-nat.c (core_ops): Likewise.
* inftarg.c (child_ops): Likewise.
* monitor.c (monitor_ops): Likewise.
* ppc-bdm.c (bdm_ppc_ops): Likewise.
* remote-adapt.c (adapt_ops): Likewise.
* remote-bug.c (bug_ops): Likewise.
* remote-e7000.c (e7000_ops): Likewise.
* remote-eb.c (eb_ops): Likewise.
* remote-es.c (es1800_ops, es1800_child_ops): Likewise.
* remote-mm.c (mm_ops): Likewise.
* remote-nindy.c (nindy_ops): Likewise.
* remote-nrom.c (nrom_ops): Likewise.
* remote-os9k.c (rombug_ops): Likewise.
* remote-rdp.c (remote_rdp_ops): Likewise.
* remote-sim.c (gdbsim_ops): Likewise.
* remote-st.c (st2000_ops): Likewise.
* v850ice.c (v850ice_ops): Likewise.
* target.c (cleanup_target): Likewise
(update_current_target): Likewise.
(setup_target_debug): Likewise
(debug_to_core_file_to_sym_file): Removed.

* corefile.c (core_file_command) [HPUXHPPA]: Removed code that
sets symbol file from information obtained from the core file.
* corelow.c (core_file_to_sym_file): Removed.
@
text
@d434 1
a434 1
rombug_resume (int pid, int step, enum target_signal sig)
d463 2
a464 2
static int
rombug_wait (int pid, struct target_waitstatus *status)
d502 1
a502 1
  return 0;
@


1.12
log
@Update/correct copyright notices.
@
text
@a1171 1
  rombug_ops.to_core_file_to_sym_file = NULL;
@


1.11
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 2001 Free Software Foundation, Inc.
@


1.10
log
@* ppc-bdm.c (#include <signal.h>): Removed.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-mips.c: Likewise.
* remote-os9k.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
@
text
@d53 1
@


1.9
log
@* monitor.c (#include "gdb_wait.h"): Removed.
* ocd.c: Likewise.
* ppc-bdm.c: Likewise.
* remote-adapt.c: Likewise.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-eb.c: Likewise.
* remote-es.c: Likewise.
* remote-mips.c: Likewise.
* remote-mm.c: Likewise.
* remote-nindy.c: Likewise.
* remote-os9k.c: Likewise.
* remote-rdi.c: Likewise.
* remote-rdp.c: Likewise.
* remote-sds.c: Likewise.
* remote-sim.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
* remote.c: Likewise.
* ser-pipe.c: Likewise.
* ser-unix.c: Likewise.
* Makefile.in: Updated dependencies.
-------------------------------------------------------------------
@
text
@a42 1
#include <signal.h>
@


1.8
log
@* exec.c (xfer_memory): Add attrib argument.
* infptrace.c (child_xfer_memory): Likewise.
* monitor.c (monitor_xfer_memory): Likewise.
* remote-adapt.c (adapt_xfer_inferior_memory): Likewise.
* remote-array.c (array_xfer_memory): Likewise.
* remote-bug.c (bug_xfer_memory): Likewise.
* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
* remote-eb.c (eb_xfer_inferior_memory): Likewise.
* remote-es.c (es1800_xfer_inferior_memory): Likewise.
* remote-mips.c (mips_xfer_memory): Likewise.
* remote-mm.c (mm_xfer_inferior_memory): Likewise.
* remote-nindy.c (nindy_xfer_inferior_memory): Likewise.
* remote-os9k.c (rombug_xfer_inferior_memory): Likewise.
* remote-rdi.c (arm_rdi_xfer_memory): Likewise.
* remote-rdp.c (remote_rdp_xfer_inferior_memory): Likewise.
* remote-sds.c (sds_xfer_memory): Likewise.
* remote-sim.c (gdbsim_xfer_inferior_memory): Likewise.
* remote-st.c (st2000_xfer_inferior_memory): Likewise.
* remote-udi.c (udi_xfer_inferior_memory): Likewise.
* remote-vx.c (vx_xfer_memory): Likewise.
* remote.c (remote_xfer_memory): Likewise.
* target.c (debug_to_xfer_memory, do_xfer_memory): Likewise.
* target.h (child_xfer_memory, do_xfer_memory, xfer_memory): Likewise.

* target.h (#include "memattr.h"): Added.
(target_ops.to_xfer_memory): Add attrib argument.

* wince.c (_initialize_inftarg): Removed call to set_dcache_state.
* dcache.h (set_dcache_state): Removed declaration.
* dcache.c (set_dcache_state): Removed definition

* dcache.c: Update module comment, as dcache is now enabled and
disabled with memory region attributes instead of by the global
variable "remotecache".  Add comment describing the interaction
between dcache and memory region attributes.
(dcache_xfer_memory): Add comment describing benefits of moving
cache writeback to a higher level.
(dcache_struct): Removed cache_has_stuff field.  This was used to
record whether the cache had been accessed in order to invalidate
it when it was disabled.  However, this is not needed because the
cache is write through and the code that enables, disables, and
deletes memory regions invalidate the cache.  Add comment which
suggests that we could be more selective and only invalidate those
cache lines containing data from those memory regions.
(dcache_invalidate): Updated.
(dcache_xfer_memory): Updated.

(dcache_alloc): Don't abort() if dcache_enabled_p is clear.
(dcache_xfer_memory): Removed code that called do_xfer_memory() to
perform a uncached transfer if dcache_enabled_p was clear.  This
function is now only called if caching is enabled for the memory
region.
(dcache_info): Always print cache info.

* target.c (do_xfer_memory): Add attrib argument.
(target_xfer_memory, target_xfer_memory_partial): Break transfer
into chunks defined by memory regions, pass region attributes to
do_xfer_memory().
* dcache.c (dcache_read_line, dcache_write_line): Likewise.

* Makefile.in (SFILES): Add memattr.c.
(COMMON_OBS): Add memattr.o.
(dcache.o): Add target.h to dependencies.
* memattr.c: New file.
* memattr.h: Likewise.
@
text
@a42 1
#include "gdb_wait.h"
@


1.7
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
d829 3
a831 1
			     int write, struct target_ops *target)
@


1.6
log
@* dcache.c (dcache_info): Output a cache line's state vector so it
lines up under the data vector.

* dcache.c (dcache_read_line): New function.
(dcache_peek_byte): Use it.
(dcache_alloc): Return NULL if write of reclaimed cache line fails.
(dcache_peek_byte, dcache_poke_byte): Return failure if
dcache_alloc() returns a NULL data block pointer.
(dcache_xfer_memory): Don't force writeback unless we were writing.

* monitor.c (monitor_expect): Change places where immediate_quit
is set to 1 or 0 to increments and decrements respectively.  This
allows such changes to nest properly.
* ocd.c (ocd_start_remote): Likewise.
* remote-adapt.c (expect): Likewise.
* remote-array.c (expect): Likewise.
* remote-eb.c (expect): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-mips.c (mips_expect_timeout, mips_getstring): Likewise.
* remote-nrom.c (expect): Likewise.
* remote-os9k.c (expect): Likewise.
* remote-sds.c (sds_start_remote): Likewise.
* remote-st.c (expect): Likewise.
* remote-utils.c (sr_expect): Likewise.
* remote.c (remote_start_remote): Likewise.
* tracepoint.c (read_actions): Likewise.

* remote-mips.c (mips_getstring): Balance changes to immediate_quit.
@
text
@d821 6
a826 1
/* FIXME-someday!  merge these two.  */
d828 2
a829 6
rombug_xfer_inferior_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *target;	/* ignored */
@


1.5
log
@2000-08-27  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* pa64solib.c (pa64_solib_load_symbols): Don't use ANOFFSET as an
 	lvalue.
	* xcoffread.c (xcoff_symfile_offsets): Ditto
	* somsolib.c (som_solib_section_offsets): Ditto.
	* somread.c (som_symfile_offsets): Ditto.
	* rs6000-nat.c (vmap_symtab): Ditto.
	* remote-vx.c (vx_add_symbols): Ditto.
	* remote-os9k.c (rombug_wait): Ditto.
@
text
@d146 1
a146 1
  immediate_quit = 1;
d156 1
a156 1
	      immediate_quit = 0;
@


1.4
log
@Protoization.
@
text
@d496 2
a497 2
      ANOFFSET (offs, SECT_OFF_DATA (symfile_objfile)) = addr;
      ANOFFSET (offs, SECT_OFF_BSS (symfile_objfile)) = addr;
@


1.3
log
@Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * objfiles.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Define as functions of OBJFILE.  Add
        sect_index_text, sect_index_data, sect_index_rodata,
        sect_index_bss to objfile structure.
        * gdb-stabs.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Remove.
        * objfiles.c (allocate_objfile): Initialize
        sect_index_{text,data,bss,rodata} to -1, for error detection.

        * symfile.c (default_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata} from bfd information.
        * xcoffread.c (xcoff_symfile_offsets): Ditto.
        * somread.c (som_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata}.

        * coffread.c, dbxread.c, elfread.c, hp-psymtab-read.c,
        hp-symtab-read.c, hpread.c, mdebugread.c, minsyms.c,
        mipsread.c, objfiles.c, os9kread.c, pa64solib.c, partial-stab.h,
        remote-os9k.c, remote-vx.c, remote.c, rs6000-nat.c, somsolib.c,
        stabsread.c, symfile.c, xcoffread.c:
        Update use of SECT_OFF_{TEXT,DATA,BSS,RODATA} to depend on the
        current objfile.

        * xcoffread.c: Add new field objfile to find_targ_sec_arg.
@
text
@d108 1
a108 2
readchar (timeout)
     int timeout;
d138 1
a138 3
expect (string, discard)
     char *string;
     int discard;
d190 1
a190 2
expect_prompt (discard)
     int discard;
d210 1
a210 2
get_hex_digit (ignore_space)
     int ignore_space;
d235 1
a235 2
get_hex_byte (byt)
     char *byt;
d247 1
a247 3
get_hex_regs (n, regno)
     int n;
     int regno;
d273 1
a273 4
rombug_create_inferior (execfile, args, env)
     char *execfile;
     char *args;
     char **env;
d302 1
a302 3
rombug_open (args, from_tty)
     char *args;
     int from_tty;
d370 1
a370 2
rombug_close (quitting)
     int quitting;
d390 1
a390 3
rombug_link (mod_name, text_reloc)
     char *mod_name;
     CORE_ADDR *text_reloc;
d418 1
a418 2
rombug_detach (from_tty)
     int from_tty;
d434 1
a434 3
rombug_resume (pid, step, sig)
     int pid, step;
     enum target_signal sig;
d464 1
a464 3
rombug_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d510 1
a510 2
get_reg_name (regno)
     int regno;
d535 1
a535 1
rombug_fetch_registers ()
d596 1
a596 2
rombug_fetch_register (regno)
     int regno;
d663 1
a663 1
rombug_store_registers ()
d676 1
a676 2
rombug_store_register (regno)
     int regno;
d707 1
a707 1
rombug_prepare_to_store ()
d713 1
a713 1
rombug_files_info ()
d722 1
a722 4
rombug_write_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
d752 1
a752 4
rombug_read_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d837 1
a837 3
rombug_kill (args, from_tty)
     char *args;
     int from_tty;
d848 1
a848 1
rombug_mourn_inferior ()
d860 1
a860 3
rombug_insert_breakpoint (addr, shadow)
     CORE_ADDR addr;
     char *shadow;
d891 1
a891 3
rombug_remove_breakpoint (addr, shadow)
     CORE_ADDR addr;
     char *shadow;
d917 1
a917 2
rombug_load (arg)
     char *arg;
d979 1
a979 3
rombug_command (args, fromtty)
     char *args;
     int fromtty;
d1001 1
a1001 1
cleanup_tty ()
d1008 1
a1008 3
connect_command (args, fromtty)
     char *args;
     int fromtty;
d1183 1
a1183 1
_initialize_remote_os9k ()
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d517 2
a518 2
      ANOFFSET (offs, SECT_OFF_DATA) = addr;
      ANOFFSET (offs, SECT_OFF_BSS) = addr;
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d25 1
a25 1
  "This is like remote.c but is for a different situation--
d35 1
a35 1
*/
d43 1
a43 6
#include "wait.h"
#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif
d57 2
a58 2
extern struct target_ops rombug_ops;		/* Forward declaration */
extern struct monitor_ops rombug_cmds;		/* Forward declaration */
d63 4
a66 4
static void rombug_close();
static void rombug_fetch_register();
static void rombug_fetch_registers();
static void rombug_store_register();
d68 1
a68 1
static int sr_get_debug();			/* flag set by "set remotedebug" */
d70 1
a70 1
static int hashmark;				/* flag set by "set hash" */
d82 1
a82 1
/* Descriptor for I/O to remote machine.  Initialize it to NULL*/
d91 1
a91 6
#ifdef ANSI_PROTOTYPES
printf_monitor(char *pattern, ...)
#else
printf_monitor(va_alist)
     va_dcl
#endif
a96 1
#ifdef ANSI_PROTOTYPES
a97 5
#else
  char *pattern;
  va_start(args);
  pattern = va_arg(args, char *);
#endif
d99 2
a100 2
  vsprintf(buf, pattern, args);
  va_end(args);
d102 2
a103 2
  if (SERIAL_WRITE(monitor_desc, buf, strlen(buf)))
    fprintf(stderr, "SERIAL_WRITE failed: %s\n", safe_strerror(errno));
d106 1
a106 1
/* Read a character from the remote system, doing all the fancy timeout stuff*/
d108 1
a108 1
readchar(timeout)
d113 1
a113 1
  c = SERIAL_READCHAR(monitor_desc, timeout);
d115 2
a116 2
  if (sr_get_debug())
    putchar(c & 0x7f);
d118 2
a119 2
  if (monitor_log && isascii(c))
    putc(c & 0x7f, log_file);
d129 1
a129 1
      error("Timeout reading from remote system.");
d132 1
a132 1
  perror_with_name("remote-monitor");
d139 1
a139 1
expect(string, discard)
d146 1
a146 1
  if (sr_get_debug())
d152 1
a152 1
      c = readchar(timeout);
d160 1
a160 1
	      if (sr_get_debug())
d169 3
a171 3
	      fwrite(string, 1, (p - 1) - string, stdout);
	      putchar((char)c);
	      fflush(stdout);
d193 1
a193 1
expect_prompt(discard)
d197 12
a208 9
  /* This is a convenient place to do this.  The idea is to do it often
     enough that we never lose much data if we terminate abnormally.  */
    fflush(log_file);

  if (is_trace_mode) {
    expect("trace", discard);
  } else {
    expect (PROMPT, discard);
  }
d214 1
a214 1
get_hex_digit(ignore_space)
d220 1
a220 1
      ch = readchar(timeout);
d231 2
a232 2
	  expect_prompt(1);
	  error("Invalid hex digit from remote system.");
d264 1
a264 1
      
d272 1
a272 1
	    val = val + (b << (j*8));
d289 1
a289 1
    error("Can't pass arguments to remote ROMBUG process");
d292 1
a292 1
    error("No executable file specified");
d304 1
a304 1
  proceed ((CORE_ADDR)entry_pt, TARGET_SIGNAL_DEFAULT, 0);
d313 1
a313 1
rombug_open(args, from_tty)
d321 1
a321 1
  target_preopen(from_tty);
d324 1
a324 1
    unpush_target(&rombug_ops);
d326 2
a327 2
  strcpy(dev_name, args);
  monitor_desc = SERIAL_OPEN(dev_name);
d329 1
a329 1
    perror_with_name(dev_name);
d332 1
a332 1
  if (SERIAL_SETBAUDRATE (monitor_desc, sr_get_baud_rate()))
d337 1
a337 1
  SERIAL_RAW(monitor_desc);
d340 5
a344 1
    struct hardware_ttystate { struct termios t;} *tty_s;
d346 6
a351 4
      tty_s =(struct hardware_ttystate  *)SERIAL_GET_TTY_STATE(monitor_desc);
      if (tty_xon) tty_s->t.c_iflag |= IXON; 
      if (tty_xoff) tty_s->t.c_iflag |= IXOFF;
      SERIAL_SET_TTY_STATE(monitor_desc, (serial_ttystate) tty_s);
d361 2
a362 2
  printf_monitor("\r");	/* CR wakes up monitor */
  expect_prompt(1);
d367 2
a368 2
    printf("Remote %s connected to %s\n", target_shortname,
	   dev_name);
d370 1
a370 1
  rombug_fetch_registers();
d373 1
a373 1
  expect_prompt(1);
d386 15
a400 13
  if (rombug_is_open) {
    SERIAL_CLOSE(monitor_desc);
    monitor_desc = NULL;
    rombug_is_open = 0;
  }

  if (log_file) {
    if (ferror(log_file))
      fprintf(stderr, "Error writing log file.\n");
    if (fclose(log_file) != 0)
      fprintf(stderr, "Error closing log file.\n");
    log_file = 0;
  }
d404 1
a404 1
rombug_link(mod_name, text_reloc)
d412 5
a416 5
  printf_monitor("l %s \r", mod_name); 
  expect_prompt(1);
  printf_monitor(".r \r");
  expect(REG_DELIM, 1);
  for (i=0; i <= 7; i++)
d420 3
a422 3
        {
          get_hex_byte(&b);
          val = (val << 8) + b;
d425 1
a425 1
  expect_prompt(1);
d437 6
a442 5
  if (attach_flag) {
    printf_monitor (GO_CMD);
    attach_flag = 0;
  }
  pop_target();		/* calls rombug_close to do the real work */
d446 1
a446 1
 
d463 2
a464 2
      expect (STEP_CMD, 1);
      */
d470 2
a471 2
      expect (GO_CMD, 1);
      */
d474 1
a474 1
  buflen= 0;
d498 3
a500 3
  timeout = -1;		/* Don't time out -- user program is running. */
  expect ("eax:", 0);   /* output any message before register display */
  expect_prompt(1);     /* Wait for prompt, outputting extraneous text */
d505 1
a505 1
  rombug_fetch_registers();
d508 2
a509 2
  pc = read_register(PC_REGNUM);
  addr = read_register(DATABASE_REG);
d514 3
a516 7
        new_symfile_objfile(obj_sec->objfile, 1, 0);
      offs = ((struct section_offsets *)
	 alloca (sizeof (struct section_offsets)
	 + (symfile_objfile->num_sections * sizeof (offs->offsets))));
      memcpy (offs, symfile_objfile->section_offsets,
         (sizeof (struct section_offsets) + 
	 (symfile_objfile->num_sections * sizeof (offs->offsets))));
d520 1
a520 1
      objfile_relocate(symfile_objfile, offs);
d543 5
a547 5
  for (p = REGISTER_NAME (regno); *p; p++)
    *b++ = toupper(*p);
  *b = '\000';
*/
  p = (char *)REGISTER_NAME (regno);
d550 2
a551 2
  return buf;
*/
d564 10
a573 10
  expect("eax:", 1);
  expect("\n", 1);
  get_hex_regs(1, 0);
  get_hex_regs(1, 3);
  get_hex_regs(1, 1);
  get_hex_regs(1, 2);
  get_hex_regs(1, 6);
  get_hex_regs(1, 7);
  get_hex_regs(1, 5);
  get_hex_regs(1, 4);
d576 1
a576 1
      expect(REG_DELIM, 1);
d581 2
a582 2
            {
              get_hex_byte (&b);
d586 2
a587 2
		val = val + (b << (j*8));
            }
d589 6
a594 3
	  if (regno == 8) i = 10;
	  if (regno >=  9 && regno <= 12) i = regno + 3;
	  if (regno == 13) i = 11;
d599 1
a599 1
	  get_hex_regs(1, PC_REGNUM);
d603 1
a603 1
	  get_hex_regs(1, 9);
d608 1
a608 1
	  supply_register(regno, (char *) &val);
d624 5
a628 4
  if (monitor_log) {
    fprintf (log_file, "\nIn Fetch Register (reg=%s)\n", get_reg_name (regno));
    fflush (log_file);
  }
d642 2
a643 2
          expect (name, 1);
          expect (REG_DELIM, 1);
d646 2
a647 2
            {
              get_hex_byte (&b);
d651 2
a652 2
		val = val + (b << (j*8));
            }
d660 2
a661 2
          expect (name, 1);
          expect (REG_DELIM, 1);
d666 11
a676 11
          expect (name, 1);
          expect (REG_DELIM, 1);
	  expect("\n", 1);
	  get_hex_regs(1, 0);
	  get_hex_regs(1, 3);
	  get_hex_regs(1, 1);
	  get_hex_regs(1, 2);
	  get_hex_regs(1, 6);
	  get_hex_regs(1, 7);
	  get_hex_regs(1, 5);
	  get_hex_regs(1, 4);
d691 1
a691 1
    rombug_store_register(regno);
d702 1
a702 1
char *name;
d711 1
a711 1
      if (sr_get_debug())
d714 3
a716 2
      name = get_reg_name(regno);
      if (name == 0) return;
d740 1
a740 1
	  dev_name, sr_get_baud_rate());
d762 1
a762 1
      if (sr_get_debug())
d779 1
a779 1
rombug_read_inferior_memory(memaddr, myaddr, len)
d807 6
a812 5
  if (((memaddr - 1) + len) < memaddr) {
    errno = EIO;
    return 0;
  }
  if (bufaddr <= memaddr && (memaddr+len) <= (bufaddr+buflen))
d814 1
a814 1
      memcpy(myaddr, &readbuf[memaddr-bufaddr], len);
d817 1
a817 1
  
d827 1
a827 1
      if (sr_get_debug())
d838 1
a838 1
      memcpy(&myaddr[count], readbuf, len_this_pass); 
d841 1
a841 1
      expect(CMD_DELIM, 1);
d843 2
a844 2
  if (CMD_END) 
      printf_monitor (CMD_END);
d858 1
a858 1
     struct target_ops *target;		/* ignored */
d871 1
a871 1
  return;		/* ignore attempts to kill target system */
d888 2
a889 1
static CORE_ADDR breakaddr[MAX_MONITOR_BREAKPOINTS] = {0};
d908 1
a908 1
	if (sr_get_debug())
d911 1
a911 1
	printf_monitor(SET_BREAK_CMD, addr);
d913 1
a913 1
	expect_prompt(1);
d917 1
a917 1
  fprintf(stderr, "Too many breakpoints (> 16) for monitor\n");
d938 1
a938 1
	printf_monitor(CLR_BREAK_CMD, addr);
d940 1
a940 1
	expect_prompt(1);
d944 1
a944 1
  fprintf(stderr, "Can't find breakpoint associated with 0x%x\n", addr);
d954 1
a954 1
    char	*arg;
d962 1
a962 1
  if (sr_get_debug())
d968 3
a970 3
    error (sprintf (buf, "%s Does not exist", arg));
    return;
  }
d984 5
a988 4
      if (SERIAL_WRITE(monitor_desc, buf, bytes_read)) {
	fprintf(stderr, "SERIAL_WRITE failed: (while downloading) %s\n", safe_strerror(errno));
	break;
      }
d990 3
a992 1
      while (i++ <=200000) {} ;     			/* Ugly HACK, probably needs flow control */
d1008 1
a1008 1
#endif 0
d1017 2
a1018 2
     char	*args;
     int	fromtty;
d1021 2
a1022 2
    error("monitor target not open.");
  
d1027 4
a1030 4
    error("Missing command.");
	
  printf_monitor("%s\r", args);
  expect_prompt(0);
d1040 4
a1043 3
cleanup_tty()
{  printf("\r\n[Exiting connect mode]\r\n");
  /*SERIAL_RESTORE(0, &ttystate);*/
d1048 2
a1049 2
     char	*args;
     int	fromtty;
d1056 1
a1056 1
  dont_repeat();
d1059 2
a1060 2
    error("monitor target not open.");
  
d1062 3
a1064 3
    fprintf("This command takes no args.  They have been ignored.\n");
	
  printf("[Entering connect mode.  Use ~. or ~^D to escape]\n");
d1066 1
a1066 1
  serial_raw(0, &ttystate);
d1068 1
a1068 1
  make_cleanup(cleanup_tty, 0);
d1070 1
a1070 1
  FD_ZERO(&readfds);
d1076 3
a1078 3
	  FD_SET(0, &readfds);
	  FD_SET(monitor_desc, &readfds);
	  numfds = select(sizeof(readfds)*8, &readfds, 0, 0, 0);
d1083 1
a1083 1
	perror_with_name("select");
d1085 1
a1085 1
      if (FD_ISSET(0, &readfds))
d1087 1
a1087 1
	  c = getchar();
d1089 1
a1089 1
	    perror_with_name("connect");
d1091 1
a1091 1
	  printf_monitor("%c", c);
d1112 1
a1112 1
      if (FD_ISSET(monitor_desc, &readfds))
d1116 1
a1116 1
	      c = readchar(0);
d1119 1
a1119 1
	      putchar(c);
d1121 1
a1121 1
	  fflush(stdout);
d1133 17
a1149 16
struct monitor_ops rombug_cmds = {
  "g \r",				/* execute or usually GO command */
  "g \r",				/* continue command */
  "t \r",				/* single step */
  "b %x\r",				/* set a breakpoint */
  "k %x\r",				/* clear a breakpoint */
  "c %x\r",				/* set memory to a value */
  "d %x %d\r",				/* display memory */
  "$%08X",				/* prompt memory commands use */
  ".%s %x\r",				/* set a register */
  ":",					/* delimiter between registers */
  ". \r",				/* read a register */
  "mf \r",				/* download command */
  "RomBug: ",				/* monitor command prompt */
  ": ",					/* end-of-command delimitor */
  ".\r"					/* optional command terminator */
d1152 1
a1152 1
struct target_ops rombug_ops ;
d1154 2
a1155 2
static void 
init_rombug_ops(void)
d1157 3
a1159 3
  rombug_ops.to_shortname =   "rombug";
  rombug_ops.to_longname =   "Microware's ROMBUG debug monitor";
  rombug_ops.to_doc =   "Use a remote computer running the ROMBUG debug monitor.\n\
d1161 3
a1163 3
    rombug_ops.to_open =   rombug_open;
  rombug_ops.to_close =   rombug_close;
  rombug_ops.to_attach =   0;
d1166 1
a1166 1
  rombug_ops.to_detach =   rombug_detach;
d1168 2
a1169 2
  rombug_ops.to_resume =   rombug_resume;
  rombug_ops.to_wait  =   rombug_wait;
d1171 16
a1186 16
  rombug_ops.to_fetch_registers  =   rombug_fetch_register;
  rombug_ops.to_store_registers  =   rombug_store_register;
  rombug_ops.to_prepare_to_store =   rombug_prepare_to_store;
  rombug_ops.to_xfer_memory  =   rombug_xfer_inferior_memory;
  rombug_ops.to_files_info  =   rombug_files_info;
  rombug_ops.to_insert_breakpoint =   rombug_insert_breakpoint;
  rombug_ops.to_remove_breakpoint =   rombug_remove_breakpoint;	/* Breakpoints */
  rombug_ops.to_terminal_init  =   0;
  rombug_ops.to_terminal_inferior =   0;
  rombug_ops.to_terminal_ours_for_output =   0;
  rombug_ops.to_terminal_ours  =   0;
  rombug_ops.to_terminal_info  =   0;				/* Terminal handling */
  rombug_ops.to_kill  =   rombug_kill;
  rombug_ops.to_load  =   rombug_load;			/* load */
  rombug_ops.to_lookup_symbol =   rombug_link;				/* lookup_symbol */
  rombug_ops.to_create_inferior =   rombug_create_inferior;
d1204 5
a1208 5
  rombug_ops.to_mourn_inferior =   rombug_mourn_inferior;
  rombug_ops.to_can_run  =   0;				/* can_run */
  rombug_ops.to_notice_signals =   0; 				/* notice_signals */
  rombug_ops.to_thread_alive  =   0;
  rombug_ops.to_stop  =   0;				/* to_stop */
d1211 11
a1221 11
  rombug_ops.to_stratum =   process_stratum;
  rombug_ops.DONT_USE =   0;				/* next */
  rombug_ops.to_has_all_memory =   1;
  rombug_ops.to_has_memory =   1;
  rombug_ops.to_has_stack =   1;
  rombug_ops.to_has_registers =   1;
  rombug_ops.to_has_execution =   1;				/* has execution */
  rombug_ops.to_sections =   0;
  rombug_ops.to_sections_end =   0;				/* Section pointers */
  rombug_ops.to_magic =   OPS_MAGIC;			/* Always the last thing */
} 
d1226 1
a1226 1
  init_rombug_ops() ;
d1230 4
a1233 4
        add_set_cmd ("hash", no_class, var_boolean, (char *)&hashmark,
		"Set display of activity while downloading a file.\nWhen enabled, a period \'.\' is displayed.",
                &setlist),
	&showlist);
d1236 5
a1240 5
        add_set_cmd ("timeout", no_class, var_zinteger,
                 (char *) &timeout,
                 "Set timeout in seconds for remote MIPS serial I/O.",
                 &setlist),
        &showlist);
d1243 5
a1247 5
        add_set_cmd ("remotelog", no_class, var_zinteger,
                 (char *) &monitor_log,
                 "Set monitor activity log on(=1) or off(=0).",
                 &setlist),
        &showlist);
d1250 5
a1254 5
        add_set_cmd ("remotexon", no_class, var_zinteger,
                 (char *) &tty_xon,
                 "Set remote tty line XON control",
                 &setlist),
        &showlist);
d1257 5
a1261 5
        add_set_cmd ("remotexoff", no_class, var_zinteger,
                 (char *) &tty_xoff,
                 "Set remote tty line XOFF control",
                 &setlist),
        &showlist);
d1264 1
a1264 1
	   "Send a command to the debug monitor."); 
d1267 1
a1267 1
   	   "Connect the terminal directly up to a serial based command monitor.\nUse <CR>~. or <CR>~^D to break out.");
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-05 snapshot
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1999 Free Software Foundation, Inc.
a42 1

a47 3
#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif
d49 1
a50 2

#include "gdb_string.h"
@


1.1.1.3
log
@import gdb-1999-07-07 pre reformat
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
d43 1
d49 3
d53 2
a55 1
#include <sys/types.h>
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d24 1
a24 1
   "This is like remote.c but is for a different situation--
d34 1
a34 1
 */
d61 2
a62 2
extern struct target_ops rombug_ops;	/* Forward declaration */
extern struct monitor_ops rombug_cmds;	/* Forward declaration */
d67 4
a70 4
static void rombug_close ();
static void rombug_fetch_register ();
static void rombug_fetch_registers ();
static void rombug_store_register ();
d72 1
a72 1
static int sr_get_debug ();	/* flag set by "set remotedebug" */
d74 1
a74 1
static int hashmark;		/* flag set by "set hash" */
d86 1
a86 1
/* Descriptor for I/O to remote machine.  Initialize it to NULL */
d96 1
a96 1
printf_monitor (char *pattern,...)
d98 1
a98 1
printf_monitor (va_alist)
d110 2
a111 2
  va_start (args);
  pattern = va_arg (args, char *);
d114 2
a115 2
  vsprintf (buf, pattern, args);
  va_end (args);
d117 2
a118 2
  if (SERIAL_WRITE (monitor_desc, buf, strlen (buf)))
    fprintf (stderr, "SERIAL_WRITE failed: %s\n", safe_strerror (errno));
d121 1
a121 1
/* Read a character from the remote system, doing all the fancy timeout stuff */
d123 1
a123 1
readchar (timeout)
d128 1
a128 1
  c = SERIAL_READCHAR (monitor_desc, timeout);
d130 2
a131 2
  if (sr_get_debug ())
    putchar (c & 0x7f);
d133 2
a134 2
  if (monitor_log && isascii (c))
    putc (c & 0x7f, log_file);
d144 1
a144 1
      error ("Timeout reading from remote system.");
d147 1
a147 1
  perror_with_name ("remote-monitor");
d154 1
a154 1
expect (string, discard)
d161 1
a161 1
  if (sr_get_debug ())
d167 1
a167 1
      c = readchar (timeout);
d175 1
a175 1
	      if (sr_get_debug ())
d184 3
a186 3
	      fwrite (string, 1, (p - 1) - string, stdout);
	      putchar ((char) c);
	      fflush (stdout);
d208 1
a208 1
expect_prompt (discard)
d212 9
a220 12
    /* This is a convenient place to do this.  The idea is to do it often
       enough that we never lose much data if we terminate abnormally.  */
    fflush (log_file);

  if (is_trace_mode)
    {
      expect ("trace", discard);
    }
  else
    {
      expect (PROMPT, discard);
    }
d226 1
a226 1
get_hex_digit (ignore_space)
d232 1
a232 1
      ch = readchar (timeout);
d243 2
a244 2
	  expect_prompt (1);
	  error ("Invalid hex digit from remote system.");
d276 1
a276 1

d284 1
a284 1
	    val = val + (b << (j * 8));
d301 1
a301 1
    error ("Can't pass arguments to remote ROMBUG process");
d304 1
a304 1
    error ("No executable file specified");
d316 1
a316 1
  proceed ((CORE_ADDR) entry_pt, TARGET_SIGNAL_DEFAULT, 0);
d325 1
a325 1
rombug_open (args, from_tty)
d333 1
a333 1
  target_preopen (from_tty);
d336 1
a336 1
    unpush_target (&rombug_ops);
d338 2
a339 2
  strcpy (dev_name, args);
  monitor_desc = SERIAL_OPEN (dev_name);
d341 1
a341 1
    perror_with_name (dev_name);
d344 1
a344 1
  if (SERIAL_SETBAUDRATE (monitor_desc, sr_get_baud_rate ()))
d349 1
a349 1
  SERIAL_RAW (monitor_desc);
d352 1
a352 5
      struct hardware_ttystate
	{
	  struct termios t;
	}
       *tty_s;
d354 4
a357 6
      tty_s = (struct hardware_ttystate *) SERIAL_GET_TTY_STATE (monitor_desc);
      if (tty_xon)
	tty_s->t.c_iflag |= IXON;
      if (tty_xoff)
	tty_s->t.c_iflag |= IXOFF;
      SERIAL_SET_TTY_STATE (monitor_desc, (serial_ttystate) tty_s);
d367 2
a368 2
  printf_monitor ("\r");	/* CR wakes up monitor */
  expect_prompt (1);
d373 2
a374 2
    printf ("Remote %s connected to %s\n", target_shortname,
	    dev_name);
d376 1
a376 1
  rombug_fetch_registers ();
d379 1
a379 1
  expect_prompt (1);
d392 13
a404 15
  if (rombug_is_open)
    {
      SERIAL_CLOSE (monitor_desc);
      monitor_desc = NULL;
      rombug_is_open = 0;
    }

  if (log_file)
    {
      if (ferror (log_file))
	fprintf (stderr, "Error writing log file.\n");
      if (fclose (log_file) != 0)
	fprintf (stderr, "Error closing log file.\n");
      log_file = 0;
    }
d408 1
a408 1
rombug_link (mod_name, text_reloc)
d416 5
a420 5
  printf_monitor ("l %s \r", mod_name);
  expect_prompt (1);
  printf_monitor (".r \r");
  expect (REG_DELIM, 1);
  for (i = 0; i <= 7; i++)
d424 3
a426 3
	{
	  get_hex_byte (&b);
	  val = (val << 8) + b;
d429 1
a429 1
  expect_prompt (1);
d441 5
a445 6
  if (attach_flag)
    {
      printf_monitor (GO_CMD);
      attach_flag = 0;
    }
  pop_target ();		/* calls rombug_close to do the real work */
d449 1
a449 1

d466 2
a467 2
         expect (STEP_CMD, 1);
       */
d473 2
a474 2
         expect (GO_CMD, 1);
       */
d477 1
a477 1
  buflen = 0;
d501 3
a503 3
  timeout = -1;			/* Don't time out -- user program is running. */
  expect ("eax:", 0);		/* output any message before register display */
  expect_prompt (1);		/* Wait for prompt, outputting extraneous text */
d508 1
a508 1
  rombug_fetch_registers ();
d511 2
a512 2
  pc = read_register (PC_REGNUM);
  addr = read_register (DATABASE_REG);
d517 1
a517 1
	new_symfile_objfile (obj_sec->objfile, 1, 0);
d519 2
a520 2
	      alloca (sizeof (struct section_offsets)
	       + (symfile_objfile->num_sections * sizeof (offs->offsets))));
d522 2
a523 2
	      (sizeof (struct section_offsets) +
	         (symfile_objfile->num_sections * sizeof (offs->offsets))));
d527 1
a527 1
      objfile_relocate (symfile_objfile, offs);
d550 5
a554 5
   for (p = REGISTER_NAME (regno); *p; p++)
   *b++ = toupper(*p);
   *b = '\000';
 */
  p = (char *) REGISTER_NAME (regno);
d557 2
a558 2
   return buf;
 */
d571 10
a580 10
  expect ("eax:", 1);
  expect ("\n", 1);
  get_hex_regs (1, 0);
  get_hex_regs (1, 3);
  get_hex_regs (1, 1);
  get_hex_regs (1, 2);
  get_hex_regs (1, 6);
  get_hex_regs (1, 7);
  get_hex_regs (1, 5);
  get_hex_regs (1, 4);
d583 1
a583 1
      expect (REG_DELIM, 1);
d588 2
a589 2
	    {
	      get_hex_byte (&b);
d593 2
a594 2
		val = val + (b << (j * 8));
	    }
d596 3
a598 6
	  if (regno == 8)
	    i = 10;
	  if (regno >= 9 && regno <= 12)
	    i = regno + 3;
	  if (regno == 13)
	    i = 11;
d603 1
a603 1
	  get_hex_regs (1, PC_REGNUM);
d607 1
a607 1
	  get_hex_regs (1, 9);
d612 1
a612 1
	  supply_register (regno, (char *) &val);
d628 4
a631 5
  if (monitor_log)
    {
      fprintf (log_file, "\nIn Fetch Register (reg=%s)\n", get_reg_name (regno));
      fflush (log_file);
    }
d645 2
a646 2
	  expect (name, 1);
	  expect (REG_DELIM, 1);
d649 2
a650 2
	    {
	      get_hex_byte (&b);
d654 2
a655 2
		val = val + (b << (j * 8));
	    }
d663 2
a664 2
	  expect (name, 1);
	  expect (REG_DELIM, 1);
d669 11
a679 11
	  expect (name, 1);
	  expect (REG_DELIM, 1);
	  expect ("\n", 1);
	  get_hex_regs (1, 0);
	  get_hex_regs (1, 3);
	  get_hex_regs (1, 1);
	  get_hex_regs (1, 2);
	  get_hex_regs (1, 6);
	  get_hex_regs (1, 7);
	  get_hex_regs (1, 5);
	  get_hex_regs (1, 4);
d694 1
a694 1
    rombug_store_register (regno);
d705 1
a705 1
  char *name;
d714 1
a714 1
      if (sr_get_debug ())
d717 2
a718 3
      name = get_reg_name (regno);
      if (name == 0)
	return;
d742 1
a742 1
	  dev_name, sr_get_baud_rate ());
d764 1
a764 1
      if (sr_get_debug ())
d781 1
a781 1
rombug_read_inferior_memory (memaddr, myaddr, len)
d809 5
a813 6
  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }
  if (bufaddr <= memaddr && (memaddr + len) <= (bufaddr + buflen))
d815 1
a815 1
      memcpy (myaddr, &readbuf[memaddr - bufaddr], len);
d818 1
a818 1

d828 1
a828 1
      if (sr_get_debug ())
d839 1
a839 1
      memcpy (&myaddr[count], readbuf, len_this_pass);
d842 1
a842 1
      expect (CMD_DELIM, 1);
d844 2
a845 2
  if (CMD_END)
    printf_monitor (CMD_END);
d859 1
a859 1
     struct target_ops *target;	/* ignored */
d872 1
a872 1
  return;			/* ignore attempts to kill target system */
d889 1
a889 2
static CORE_ADDR breakaddr[MAX_MONITOR_BREAKPOINTS] =
{0};
d908 1
a908 1
	if (sr_get_debug ())
d911 1
a911 1
	printf_monitor (SET_BREAK_CMD, addr);
d913 1
a913 1
	expect_prompt (1);
d917 1
a917 1
  fprintf (stderr, "Too many breakpoints (> 16) for monitor\n");
d938 1
a938 1
	printf_monitor (CLR_BREAK_CMD, addr);
d940 1
a940 1
	expect_prompt (1);
d944 1
a944 1
  fprintf (stderr, "Can't find breakpoint associated with 0x%x\n", addr);
d954 1
a954 1
     char *arg;
d962 1
a962 1
  if (sr_get_debug ())
d968 3
a970 3
      error (sprintf (buf, "%s Does not exist", arg));
      return;
    }
d984 4
a987 5
      if (SERIAL_WRITE (monitor_desc, buf, bytes_read))
	{
	  fprintf (stderr, "SERIAL_WRITE failed: (while downloading) %s\n", safe_strerror (errno));
	  break;
	}
d989 1
a989 3
      while (i++ <= 200000)
	{
	};			/* Ugly HACK, probably needs flow control */
d1005 1
a1005 1
#endif /* 0 */
d1014 2
a1015 2
     char *args;
     int fromtty;
d1018 2
a1019 2
    error ("monitor target not open.");

d1024 4
a1027 4
    error ("Missing command.");

  printf_monitor ("%s\r", args);
  expect_prompt (0);
d1037 3
a1039 4
cleanup_tty ()
{
  printf ("\r\n[Exiting connect mode]\r\n");
  /*SERIAL_RESTORE(0, &ttystate); */
d1044 2
a1045 2
     char *args;
     int fromtty;
d1052 1
a1052 1
  dont_repeat ();
d1055 2
a1056 2
    error ("monitor target not open.");

d1058 3
a1060 3
    fprintf ("This command takes no args.  They have been ignored.\n");

  printf ("[Entering connect mode.  Use ~. or ~^D to escape]\n");
d1062 1
a1062 1
  serial_raw (0, &ttystate);
d1064 1
a1064 1
  make_cleanup (cleanup_tty, 0);
d1066 1
a1066 1
  FD_ZERO (&readfds);
d1072 3
a1074 3
	  FD_SET (0, &readfds);
	  FD_SET (monitor_desc, &readfds);
	  numfds = select (sizeof (readfds) * 8, &readfds, 0, 0, 0);
d1079 1
a1079 1
	perror_with_name ("select");
d1081 1
a1081 1
      if (FD_ISSET (0, &readfds))
d1083 1
a1083 1
	  c = getchar ();
d1085 1
a1085 1
	    perror_with_name ("connect");
d1087 1
a1087 1
	  printf_monitor ("%c", c);
d1108 1
a1108 1
      if (FD_ISSET (monitor_desc, &readfds))
d1112 1
a1112 1
	      c = readchar (0);
d1115 1
a1115 1
	      putchar (c);
d1117 1
a1117 1
	  fflush (stdout);
d1129 16
a1144 17
struct monitor_ops rombug_cmds =
{
  "g \r",			/* execute or usually GO command */
  "g \r",			/* continue command */
  "t \r",			/* single step */
  "b %x\r",			/* set a breakpoint */
  "k %x\r",			/* clear a breakpoint */
  "c %x\r",			/* set memory to a value */
  "d %x %d\r",			/* display memory */
  "$%08X",			/* prompt memory commands use */
  ".%s %x\r",			/* set a register */
  ":",				/* delimiter between registers */
  ". \r",			/* read a register */
  "mf \r",			/* download command */
  "RomBug: ",			/* monitor command prompt */
  ": ",				/* end-of-command delimitor */
  ".\r"				/* optional command terminator */
d1147 1
a1147 1
struct target_ops rombug_ops;
d1149 2
a1150 2
static void
init_rombug_ops (void)
d1152 3
a1154 3
  rombug_ops.to_shortname = "rombug";
  rombug_ops.to_longname = "Microware's ROMBUG debug monitor";
  rombug_ops.to_doc = "Use a remote computer running the ROMBUG debug monitor.\n\
d1156 3
a1158 3
    rombug_ops.to_open = rombug_open;
  rombug_ops.to_close = rombug_close;
  rombug_ops.to_attach = 0;
d1161 1
a1161 1
  rombug_ops.to_detach = rombug_detach;
d1163 2
a1164 2
  rombug_ops.to_resume = rombug_resume;
  rombug_ops.to_wait = rombug_wait;
d1166 16
a1181 16
  rombug_ops.to_fetch_registers = rombug_fetch_register;
  rombug_ops.to_store_registers = rombug_store_register;
  rombug_ops.to_prepare_to_store = rombug_prepare_to_store;
  rombug_ops.to_xfer_memory = rombug_xfer_inferior_memory;
  rombug_ops.to_files_info = rombug_files_info;
  rombug_ops.to_insert_breakpoint = rombug_insert_breakpoint;
  rombug_ops.to_remove_breakpoint = rombug_remove_breakpoint;	/* Breakpoints */
  rombug_ops.to_terminal_init = 0;
  rombug_ops.to_terminal_inferior = 0;
  rombug_ops.to_terminal_ours_for_output = 0;
  rombug_ops.to_terminal_ours = 0;
  rombug_ops.to_terminal_info = 0;	/* Terminal handling */
  rombug_ops.to_kill = rombug_kill;
  rombug_ops.to_load = rombug_load;	/* load */
  rombug_ops.to_lookup_symbol = rombug_link;	/* lookup_symbol */
  rombug_ops.to_create_inferior = rombug_create_inferior;
d1199 5
a1203 5
  rombug_ops.to_mourn_inferior = rombug_mourn_inferior;
  rombug_ops.to_can_run = 0;	/* can_run */
  rombug_ops.to_notice_signals = 0;	/* notice_signals */
  rombug_ops.to_thread_alive = 0;
  rombug_ops.to_stop = 0;	/* to_stop */
d1206 11
a1216 11
  rombug_ops.to_stratum = process_stratum;
  rombug_ops.DONT_USE = 0;	/* next */
  rombug_ops.to_has_all_memory = 1;
  rombug_ops.to_has_memory = 1;
  rombug_ops.to_has_stack = 1;
  rombug_ops.to_has_registers = 1;
  rombug_ops.to_has_execution = 1;	/* has execution */
  rombug_ops.to_sections = 0;
  rombug_ops.to_sections_end = 0;	/* Section pointers */
  rombug_ops.to_magic = OPS_MAGIC;	/* Always the last thing */
}
d1221 1
a1221 1
  init_rombug_ops ();
d1225 4
a1228 4
	     add_set_cmd ("hash", no_class, var_boolean, (char *) &hashmark,
			  "Set display of activity while downloading a file.\nWhen enabled, a period \'.\' is displayed.",
			  &setlist),
		      &showlist);
d1231 5
a1235 5
		      add_set_cmd ("timeout", no_class, var_zinteger,
				   (char *) &timeout,
		       "Set timeout in seconds for remote MIPS serial I/O.",
				   &setlist),
		      &showlist);
d1238 5
a1242 5
		      add_set_cmd ("remotelog", no_class, var_zinteger,
				   (char *) &monitor_log,
			      "Set monitor activity log on(=1) or off(=0).",
				   &setlist),
		      &showlist);
d1245 5
a1249 5
		      add_set_cmd ("remotexon", no_class, var_zinteger,
				   (char *) &tty_xon,
				   "Set remote tty line XON control",
				   &setlist),
		      &showlist);
d1252 5
a1256 5
		      add_set_cmd ("remotexoff", no_class, var_zinteger,
				   (char *) &tty_xoff,
				   "Set remote tty line XOFF control",
				   &setlist),
		      &showlist);
d1259 1
a1259 1
	   "Send a command to the debug monitor.");
d1262 1
a1262 1
	   "Connect the terminal directly up to a serial based command monitor.\nUse <CR>~. or <CR>~^D to break out.");
@


1.1.1.5
log
@import gdb-1999-08-09 snapshot
@
text
@d44 5
d96 1
d98 4
d107 1
d109 5
@


1.1.1.6
log
@import gdb-1999-09-08 snapshot
@
text
@d515 6
a520 2
      offs = (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
      memcpy (offs, symfile_objfile->section_offsets, SIZEOF_SECTION_OFFSETS);
@


1.1.1.7
log
@import gdb-1999-09-21
@
text
@d1077 1
a1077 1
	  FD_SET (DEPRECATED_SERIAL_FD (monitor_desc), &readfds);
d1112 1
a1112 1
      if (FD_ISSET (DEPRECATED_SERIAL_FD (monitor_desc), &readfds))
@


