head	1.23;
access;
symbols
	gdb_5_3-2002-12-12-release:1.22
	carlton_dictionary-20021115-merge:1.22
	kseitz_interps-20021105-merge:1.22
	kseitz_interps-20021103-merge:1.22
	drow-cplus-merge-20021020:1.22
	drow-cplus-merge-20021025:1.22
	carlton_dictionary-20021025-merge:1.22
	carlton_dictionary-20021011-merge:1.22
	drow-cplus-branch:1.22.0.10
	drow-cplus-branchpoint:1.22
	kseitz_interps-20020930-merge:1.22
	carlton_dictionary-20020927-merge:1.22
	carlton_dictionary-branch:1.22.0.8
	carlton_dictionary-20020920-branchpoint:1.22
	gdb_5_3-branch:1.22.0.6
	gdb_5_3-2002-09-04-branchpoint:1.22
	kseitz_interps-20020829-merge:1.22
	cagney_sysregs-20020825-branch:1.22.0.4
	cagney_sysregs-20020825-branchpoint:1.22
	readline_4_3-import-branch:1.22.0.2
	readline_4_3-import-branchpoint:1.22
	gdb_5_2_1-2002-07-23-release:1.21
	kseitz_interps-20020528-branch:1.21.0.8
	kseitz_interps-20020528-branchpoint:1.21
	cagney_regbuf-20020515-branch:1.21.0.6
	cagney_regbuf-20020515-branchpoint:1.21
	jimb-macro-020506-branch:1.21.0.4
	jimb-macro-020506-branchpoint:1.21
	gdb_5_2-2002-04-29-release:1.21
	gdb_5_2-branch:1.21.0.2
	gdb_5_2-2002-03-03-branchpoint:1.21
	gdb_5_1_1-2002-01-24-release:1.20
	gdb_5_1_0_1-2002-01-03-release:1.20
	cygnus_cvs_20020108_pre:1.20
	gdb_5_1_0_1-2002-01-03-branchpoint:1.20
	gdb_5_1_0_1-2002-01-03-branch:1.20.0.6
	gdb_5_1-2001-11-21-release:1.20
	gdb_s390-2001-09-26-branch:1.20.0.4
	gdb_s390-2001-09-26-branchpoint:1.20
	gdb_5_1-2001-07-29-branch:1.20.0.2
	gdb_5_1-2001-07-29-branchpoint:1.20
	dberlin-typesystem-branch:1.18.0.2
	dberlin-typesystem-branchpoint:1.18
	gdb-post-ptid_t-2001-05-03:1.18
	gdb-pre-ptid_t-2001-05-03:1.17
	insight-precleanup-2001-01-01:1.9
	gdb-post-protoization-2000-07-29:1.5
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.23
date	2002.12.16.20.39.09;	author cagney;	state dead;
branches;
next	1.22;

1.22
date	2002.07.24.23.51.35;	author cagney;	state Exp;
branches
	1.22.8.1
	1.22.10.1;
next	1.21;

1.21
date	2002.01.19.03.32.37;	author cagney;	state Exp;
branches
	1.21.8.1;
next	1.20;

1.20
date	2001.07.15.20.34.13;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.10.22.38.38;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.04.04.15.26;	author kevinb;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.14.19.23.02;	author jtc;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.02.14.47.21;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.06.08.21.12;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.02.23.04.14;	author jtc;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.02.19.14.32;	author jtc;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.23.22.48.55;	author jtc;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.15.01.01.48;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.03.22.00.56;	author jtc;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.03.22.42.32;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.18.22.52.22;	author jtc;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.19.18.59.07;	author jtc;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.46;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.08.55;	author jsm;	state Exp;
branches;
next	;

1.21.8.1
date	2002.08.09.18.34.26;	author kseitz;	state Exp;
branches;
next	;

1.22.8.1
date	2002.12.23.19.38.39;	author carlton;	state dead;
branches;
next	;

1.22.10.1
date	2003.12.14.20.27.28;	author drow;	state dead;
branches;
next	;


desc
@@


1.23
log
@2002-12-16  Andrew Cagney  <ac131313@@redhat.com>

	* config/arc/arc.mt, config/arc/tm-arc.h: Delete.
	* config/d30v/d30v.mt, config/d30v/tm-d30v.h: Delete.
	* config/fr30/fr30.mt, config/fr30/tm-fr30.h: Delete.
	* config/i386/i386aix.mh, config/i386/i386aix.mt: Delete.
	* config/i386/i386m3.mh, config/i386/i386m3.mt: Delete.
	* config/i386/i386mach.mh, config/i386/i386os9k.mt: Delete.
	* config/i386/nm-i386aix.h, config/i386/nm-i386mach.h: Delete.
	* config/i386/nm-m3.h, config/i386/tm-i386aix.h: Delete.
	* config/i386/tm-i386m3.h, config/i386/tm-i386mk.h: Delete.
	* config/i386/xm-i386aix.h, config/i386/xm-i386m3.h: Delete.
	* config/i386/xm-i386mach.h, config/i386/xm-i386mk.h: Delete.
	* config/i960/mon960.mt, config/i960/nindy960.mt: Delete.
	* config/i960/tm-i960.h, config/i960/tm-mon960.h: Delete.
	* config/i960/tm-nindy960.h, config/i960/tm-vx960.h: Delete.
	* config/i960/vxworks960.mt, config/m68k/apollo68b.mh: Delete.
	* config/m68k/apollo68b.mt, config/m68k/apollo68v.mh: Delete.
	* config/m68k/hp300bsd.mh, config/m68k/hp300bsd.mt: Delete.
	* config/m68k/hp300hpux.mh, config/m68k/hp300hpux.mt: Delete.
	* config/m88k/delta88.mh, config/m88k/delta88.mt: Delete.
	* config/m88k/delta88v4.mh, config/m88k/delta88v4.mt: Delete.
	* config/m88k/m88k.mh, config/m88k/m88k.mt: Delete.
	* config/m88k/nm-delta88v4.h, config/m88k/nm-m88k.h: Delete.
	* config/m88k/tm-delta88.h, config/m88k/tm-delta88v4.h: Delete.
	* config/m88k/tm-m88k.h, config/m88k/xm-delta88.h: Delete.
	* config/m88k/xm-dgux.h: Delete.
	* fr30-tdep.c, i386aix-nat.c, i386m3-nat.c: Delete.
	* i386mach-nat.c, i960-tdep.c, m88k-nat.c: Delete.
	* os9kread.c, remote-bug.c, remote-nindy.c: Delete.
	* remote-nrom.c, remote-os9k.c, remote-vx960.c: Delete.
	* d30v-tdep.c, arc-tdep.c, cxux-nat.c, dst.h, dstread.c: Delete.
	* ch-exp.c, ch-lang.c, ch-lang.h, ch-typeprint.c: Delete.
	* ch-valprint.c: Delete.
@
text
@// OBSOLETE /* Remote debugging interface for Motorola's MVME187BUG monitor, an embedded
// OBSOLETE    monitor for the m88k.
// OBSOLETE 
// OBSOLETE    Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
// OBSOLETE    2002 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    Contributed by Cygnus Support.  Written by K. Richard Pixley.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "gdb_string.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE #include <ctype.h>
// OBSOLETE #include <fcntl.h>
// OBSOLETE #include <setjmp.h>
// OBSOLETE #include <errno.h>
// OBSOLETE 
// OBSOLETE #include "terminal.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "gdbcmd.h"
// OBSOLETE 
// OBSOLETE #include "serial.h"
// OBSOLETE #include "remote-utils.h"
// OBSOLETE 
// OBSOLETE /* External data declarations */
// OBSOLETE extern int stop_soon_quietly;	/* for wait_for_inferior */
// OBSOLETE 
// OBSOLETE /* Forward data declarations */
// OBSOLETE extern struct target_ops bug_ops;	/* Forward declaration */
// OBSOLETE 
// OBSOLETE /* Forward function declarations */
// OBSOLETE static int bug_clear_breakpoints (void);
// OBSOLETE 
// OBSOLETE static int bug_read_memory (CORE_ADDR memaddr,
// OBSOLETE 			    unsigned char *myaddr, int len);
// OBSOLETE 
// OBSOLETE static int bug_write_memory (CORE_ADDR memaddr,
// OBSOLETE 			     unsigned char *myaddr, int len);
// OBSOLETE 
// OBSOLETE /* This variable is somewhat arbitrary.  It's here so that it can be
// OBSOLETE    set from within a running gdb.  */
// OBSOLETE 
// OBSOLETE static int srec_max_retries = 3;
// OBSOLETE 
// OBSOLETE /* Each S-record download to the target consists of an S0 header
// OBSOLETE    record, some number of S3 data records, and one S7 termination
// OBSOLETE    record.  I call this download a "frame".  Srec_frame says how many
// OBSOLETE    bytes will be represented in each frame.  */
// OBSOLETE 
// OBSOLETE #define SREC_SIZE 160
// OBSOLETE static int srec_frame = SREC_SIZE;
// OBSOLETE 
// OBSOLETE /* This variable determines how many bytes will be represented in each
// OBSOLETE    S3 s-record.  */
// OBSOLETE 
// OBSOLETE static int srec_bytes = 40;
// OBSOLETE 
// OBSOLETE /* At one point it appeared to me as though the bug monitor could not
// OBSOLETE    really be expected to receive two sequential characters at 9600
// OBSOLETE    baud reliably.  Echo-pacing is an attempt to force data across the
// OBSOLETE    line even in this condition.  Specifically, in echo-pace mode, each
// OBSOLETE    character is sent one at a time and we look for the echo before
// OBSOLETE    sending the next.  This is excruciatingly slow.  */
// OBSOLETE 
// OBSOLETE static int srec_echo_pace = 0;
// OBSOLETE 
// OBSOLETE /* How long to wait after an srec for a possible error message.
// OBSOLETE    Similar to the above, I tried sleeping after sending each S3 record
// OBSOLETE    in hopes that I might actually see error messages from the bug
// OBSOLETE    monitor.  This might actually work if we were to use sleep
// OBSOLETE    intervals smaller than 1 second.  */
// OBSOLETE 
// OBSOLETE static int srec_sleep = 0;
// OBSOLETE 
// OBSOLETE /* Every srec_noise records, flub the checksum.  This is a debugging
// OBSOLETE    feature.  Set the variable to something other than 1 in order to
// OBSOLETE    inject *deliberate* checksum errors.  One might do this if one
// OBSOLETE    wanted to test error handling and recovery.  */
// OBSOLETE 
// OBSOLETE static int srec_noise = 0;
// OBSOLETE 
// OBSOLETE /* Called when SIGALRM signal sent due to alarm() timeout.  */
// OBSOLETE 
// OBSOLETE /* Number of SIGTRAPs we need to simulate.  That is, the next
// OBSOLETE    NEED_ARTIFICIAL_TRAP calls to bug_wait should just return
// OBSOLETE    SIGTRAP without actually waiting for anything.  */
// OBSOLETE 
// OBSOLETE static int need_artificial_trap = 0;
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Download a file specified in 'args', to the bug.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE bug_load (char *args, int fromtty)
// OBSOLETE {
// OBSOLETE   bfd *abfd;
// OBSOLETE   asection *s;
// OBSOLETE   char buffer[1024];
// OBSOLETE 
// OBSOLETE   sr_check_open ();
// OBSOLETE 
// OBSOLETE   inferior_ptid = null_ptid;
// OBSOLETE   abfd = bfd_openr (args, 0);
// OBSOLETE   if (!abfd)
// OBSOLETE     {
// OBSOLETE       printf_filtered ("Unable to open file %s\n", args);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (bfd_check_format (abfd, bfd_object) == 0)
// OBSOLETE     {
// OBSOLETE       printf_filtered ("File is not an object file\n");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   s = abfd->sections;
// OBSOLETE   while (s != (asection *) NULL)
// OBSOLETE     {
// OBSOLETE       srec_frame = SREC_SIZE;
// OBSOLETE       if (s->flags & SEC_LOAD)
// OBSOLETE 	{
// OBSOLETE 	  int i;
// OBSOLETE 
// OBSOLETE 	  char *buffer = xmalloc (srec_frame);
// OBSOLETE 
// OBSOLETE 	  printf_filtered ("%s\t: 0x%4lx .. 0x%4lx  ", s->name, s->vma, s->vma + s->_raw_size);
// OBSOLETE 	  gdb_flush (gdb_stdout);
// OBSOLETE 	  for (i = 0; i < s->_raw_size; i += srec_frame)
// OBSOLETE 	    {
// OBSOLETE 	      if (srec_frame > s->_raw_size - i)
// OBSOLETE 		srec_frame = s->_raw_size - i;
// OBSOLETE 
// OBSOLETE 	      bfd_get_section_contents (abfd, s, buffer, i, srec_frame);
// OBSOLETE 	      bug_write_memory (s->vma + i, buffer, srec_frame);
// OBSOLETE 	      printf_filtered ("*");
// OBSOLETE 	      gdb_flush (gdb_stdout);
// OBSOLETE 	    }
// OBSOLETE 	  printf_filtered ("\n");
// OBSOLETE 	  xfree (buffer);
// OBSOLETE 	}
// OBSOLETE       s = s->next;
// OBSOLETE     }
// OBSOLETE   sprintf (buffer, "rs ip %lx", (unsigned long) abfd->start_address);
// OBSOLETE   sr_write_cr (buffer);
// OBSOLETE   gr_expect_prompt ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE static char *
// OBSOLETE get_word (char **p)
// OBSOLETE {
// OBSOLETE   char *s = *p;
// OBSOLETE   char *word;
// OBSOLETE   char *copy;
// OBSOLETE   size_t len;
// OBSOLETE 
// OBSOLETE   while (isspace (*s))
// OBSOLETE     s++;
// OBSOLETE 
// OBSOLETE   word = s;
// OBSOLETE 
// OBSOLETE   len = 0;
// OBSOLETE 
// OBSOLETE   while (*s && !isspace (*s))
// OBSOLETE     {
// OBSOLETE       s++;
// OBSOLETE       len++;
// OBSOLETE 
// OBSOLETE     }
// OBSOLETE   copy = xmalloc (len + 1);
// OBSOLETE   memcpy (copy, word, len);
// OBSOLETE   copy[len] = 0;
// OBSOLETE   *p = s;
// OBSOLETE   return copy;
// OBSOLETE }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE static struct gr_settings bug_settings =
// OBSOLETE {
// OBSOLETE   "Bug>",			/* prompt */
// OBSOLETE   &bug_ops,			/* ops */
// OBSOLETE   bug_clear_breakpoints,	/* clear_all_breakpoints */
// OBSOLETE   gr_generic_checkin,		/* checkin */
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static char *cpu_check_strings[] =
// OBSOLETE {
// OBSOLETE   "=",
// OBSOLETE   "Invalid Register",
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE bug_open (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   if (args == NULL)
// OBSOLETE     args = "";
// OBSOLETE 
// OBSOLETE   gr_open (args, from_tty, &bug_settings);
// OBSOLETE   /* decide *now* whether we are on an 88100 or an 88110 */
// OBSOLETE   sr_write_cr ("rs cr06");
// OBSOLETE   sr_expect ("rs cr06");
// OBSOLETE 
// OBSOLETE   switch (gr_multi_scan (cpu_check_strings, 0))
// OBSOLETE     {
// OBSOLETE     case 0:			/* this is an m88100 */
// OBSOLETE       target_is_m88110 = 0;
// OBSOLETE       break;
// OBSOLETE     case 1:			/* this is an m88110 */
// OBSOLETE       target_is_m88110 = 1;
// OBSOLETE       break;
// OBSOLETE     default:
// OBSOLETE       internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Tell the remote machine to resume.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE bug_resume (ptid_t ptid, int step, enum target_signal sig)
// OBSOLETE {
// OBSOLETE   if (step)
// OBSOLETE     {
// OBSOLETE       sr_write_cr ("t");
// OBSOLETE 
// OBSOLETE       /* Force the next bug_wait to return a trap.  Not doing anything
// OBSOLETE          about I/O from the target means that the user has to type
// OBSOLETE          "continue" to see any.  FIXME, this should be fixed.  */
// OBSOLETE       need_artificial_trap = 1;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     sr_write_cr ("g");
// OBSOLETE 
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Wait until the remote machine stops, then return,
// OBSOLETE    storing status in STATUS just as `wait' would.  */
// OBSOLETE 
// OBSOLETE static char *wait_strings[] =
// OBSOLETE {
// OBSOLETE   "At Breakpoint",
// OBSOLETE   "Exception: Data Access Fault (Local Bus Timeout)",
// OBSOLETE   "\r8??\?-Bug>",		/* The '\?' avoids creating a trigraph */
// OBSOLETE   "\r197-Bug>",
// OBSOLETE   NULL,
// OBSOLETE };
// OBSOLETE 
// OBSOLETE ptid_t
// OBSOLETE bug_wait (ptid_t ptid, struct target_waitstatus *status)
// OBSOLETE {
// OBSOLETE   int old_timeout = sr_get_timeout ();
// OBSOLETE   int old_immediate_quit = immediate_quit;
// OBSOLETE 
// OBSOLETE   status->kind = TARGET_WAITKIND_EXITED;
// OBSOLETE   status->value.integer = 0;
// OBSOLETE 
// OBSOLETE   /* read off leftovers from resume so that the rest can be passed
// OBSOLETE      back out as stdout.  */
// OBSOLETE   if (need_artificial_trap == 0)
// OBSOLETE     {
// OBSOLETE       sr_expect ("Effective address: ");
// OBSOLETE       (void) sr_get_hex_word ();
// OBSOLETE       sr_expect ("\r\n");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   sr_set_timeout (-1);		/* Don't time out -- user program is running. */
// OBSOLETE   immediate_quit = 1;		/* Helps ability to QUIT */
// OBSOLETE 
// OBSOLETE   switch (gr_multi_scan (wait_strings, need_artificial_trap == 0))
// OBSOLETE     {
// OBSOLETE     case 0:			/* breakpoint case */
// OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE       status->value.sig = TARGET_SIGNAL_TRAP;
// OBSOLETE       /* user output from the target can be discarded here. (?) */
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case 1:			/* bus error */
// OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE       status->value.sig = TARGET_SIGNAL_BUS;
// OBSOLETE       /* user output from the target can be discarded here. (?) */
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case 2:			/* normal case */
// OBSOLETE     case 3:
// OBSOLETE       if (need_artificial_trap != 0)
// OBSOLETE 	{
// OBSOLETE 	  /* stepping */
// OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE 	  status->value.sig = TARGET_SIGNAL_TRAP;
// OBSOLETE 	  need_artificial_trap--;
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* exit case */
// OBSOLETE 	  status->kind = TARGET_WAITKIND_EXITED;
// OBSOLETE 	  status->value.integer = 0;
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE     case -1:			/* trouble */
// OBSOLETE     default:
// OBSOLETE       fprintf_filtered (gdb_stderr,
// OBSOLETE 			"Trouble reading target during wait\n");
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   sr_set_timeout (old_timeout);
// OBSOLETE   immediate_quit = old_immediate_quit;
// OBSOLETE   return inferior_ptid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the name of register number REGNO
// OBSOLETE    in the form input and output by bug.
// OBSOLETE 
// OBSOLETE    Returns a pointer to a static buffer containing the answer.  */
// OBSOLETE static char *
// OBSOLETE get_reg_name (int regno)
// OBSOLETE {
// OBSOLETE   static char *rn[] =
// OBSOLETE   {
// OBSOLETE     "r00", "r01", "r02", "r03", "r04", "r05", "r06", "r07",
// OBSOLETE     "r08", "r09", "r10", "r11", "r12", "r13", "r14", "r15",
// OBSOLETE     "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
// OBSOLETE     "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",
// OBSOLETE 
// OBSOLETE   /* these get confusing because we omit a few and switch some ordering around. */
// OBSOLETE 
// OBSOLETE     "cr01",			/* 32 = psr */
// OBSOLETE     "fcr62",			/* 33 = fpsr */
// OBSOLETE     "fcr63",			/* 34 = fpcr */
// OBSOLETE     "ip",			/* this is something of a cheat. */
// OBSOLETE   /* 35 = sxip */
// OBSOLETE     "cr05",			/* 36 = snip */
// OBSOLETE     "cr06",			/* 37 = sfip */
// OBSOLETE 
// OBSOLETE     "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07",
// OBSOLETE     "x08", "x09", "x10", "x11", "x12", "x13", "x14", "x15",
// OBSOLETE     "x16", "x17", "x18", "x19", "x20", "x21", "x22", "x23",
// OBSOLETE     "x24", "x25", "x26", "x27", "x28", "x29", "x30", "x31",
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE   return rn[regno];
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0				/* not currently used */
// OBSOLETE /* Read from remote while the input matches STRING.  Return zero on
// OBSOLETE    success, -1 on failure.  */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE bug_scan (char *s)
// OBSOLETE {
// OBSOLETE   int c;
// OBSOLETE 
// OBSOLETE   while (*s)
// OBSOLETE     {
// OBSOLETE       c = sr_readchar ();
// OBSOLETE       if (c != *s++)
// OBSOLETE 	{
// OBSOLETE 	  fflush (stdout);
// OBSOLETE 	  printf ("\nNext character is '%c' - %d and s is \"%s\".\n", c, c, --s);
// OBSOLETE 	  return (-1);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE #endif /* never */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE bug_srec_write_cr (char *s)
// OBSOLETE {
// OBSOLETE   char *p = s;
// OBSOLETE 
// OBSOLETE   if (srec_echo_pace)
// OBSOLETE     for (p = s; *p; ++p)
// OBSOLETE       {
// OBSOLETE 	if (sr_get_debug () > 0)
// OBSOLETE 	  printf ("%c", *p);
// OBSOLETE 
// OBSOLETE 	do
// OBSOLETE 	  serial_write (sr_get_desc (), p, 1);
// OBSOLETE 	while (sr_pollchar () != *p);
// OBSOLETE       }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       sr_write_cr (s);
// OBSOLETE /*       return(bug_scan (s) || bug_scan ("\n")); */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store register REGNO, or all if REGNO == -1. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE bug_fetch_register (int regno)
// OBSOLETE {
// OBSOLETE   sr_check_open ();
// OBSOLETE 
// OBSOLETE   if (regno == -1)
// OBSOLETE     {
// OBSOLETE       int i;
// OBSOLETE 
// OBSOLETE       for (i = 0; i < NUM_REGS; ++i)
// OBSOLETE 	bug_fetch_register (i);
// OBSOLETE     }
// OBSOLETE   else if (target_is_m88110 && regno == SFIP_REGNUM)
// OBSOLETE     {
// OBSOLETE       /* m88110 has no sfip. */
// OBSOLETE       long l = 0;
// OBSOLETE       supply_register (regno, (char *) &l);
// OBSOLETE     }
// OBSOLETE   else if (regno < XFP_REGNUM)
// OBSOLETE     {
// OBSOLETE       char buffer[MAX_REGISTER_RAW_SIZE];
// OBSOLETE 
// OBSOLETE       sr_write ("rs ", 3);
// OBSOLETE       sr_write_cr (get_reg_name (regno));
// OBSOLETE       sr_expect ("=");
// OBSOLETE       store_unsigned_integer (buffer, REGISTER_RAW_SIZE (regno),
// OBSOLETE 			      sr_get_hex_word ());
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE       supply_register (regno, buffer);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* Float register so we need to parse a strange data format. */
// OBSOLETE       long p;
// OBSOLETE       unsigned char fpreg_buf[10];
// OBSOLETE 
// OBSOLETE       sr_write ("rs ", 3);
// OBSOLETE       sr_write (get_reg_name (regno), strlen (get_reg_name (regno)));
// OBSOLETE       sr_write_cr (";d");
// OBSOLETE       sr_expect ("rs");
// OBSOLETE       sr_expect (get_reg_name (regno));
// OBSOLETE       sr_expect (";d");
// OBSOLETE       sr_expect ("=");
// OBSOLETE 
// OBSOLETE       /* sign */
// OBSOLETE       p = sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[0] = p << 7;
// OBSOLETE 
// OBSOLETE       /* exponent */
// OBSOLETE       sr_expect ("_");
// OBSOLETE       p = sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[0] += (p << 4);
// OBSOLETE       fpreg_buf[0] += sr_get_hex_digit (1);
// OBSOLETE 
// OBSOLETE       fpreg_buf[1] = sr_get_hex_digit (1) << 4;
// OBSOLETE 
// OBSOLETE       /* fraction */
// OBSOLETE       sr_expect ("_");
// OBSOLETE       fpreg_buf[1] += sr_get_hex_digit (1);
// OBSOLETE 
// OBSOLETE       fpreg_buf[2] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[3] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[4] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[5] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[6] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[7] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[8] = 0;
// OBSOLETE       fpreg_buf[9] = 0;
// OBSOLETE 
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE       supply_register (regno, fpreg_buf);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store register REGNO, or all if REGNO == -1. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE bug_store_register (int regno)
// OBSOLETE {
// OBSOLETE   char buffer[1024];
// OBSOLETE   sr_check_open ();
// OBSOLETE 
// OBSOLETE   if (regno == -1)
// OBSOLETE     {
// OBSOLETE       int i;
// OBSOLETE 
// OBSOLETE       for (i = 0; i < NUM_REGS; ++i)
// OBSOLETE 	bug_store_register (i);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       char *regname;
// OBSOLETE 
// OBSOLETE       regname = get_reg_name (regno);
// OBSOLETE 
// OBSOLETE       if (target_is_m88110 && regno == SFIP_REGNUM)
// OBSOLETE 	return;
// OBSOLETE       else if (regno < XFP_REGNUM)
// OBSOLETE 	sprintf (buffer, "rs %s %08lx",
// OBSOLETE 		 regname,
// OBSOLETE 		 (long) read_register (regno));
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  unsigned char *fpreg_buf =
// OBSOLETE 	  (unsigned char *) &registers[REGISTER_BYTE (regno)];
// OBSOLETE 
// OBSOLETE 	  sprintf (buffer, "rs %s %1x_%02x%1x_%1x%02x%02x%02x%02x%02x%02x;d",
// OBSOLETE 		   regname,
// OBSOLETE 	  /* sign */
// OBSOLETE 		   (fpreg_buf[0] >> 7) & 0xf,
// OBSOLETE 	  /* exponent */
// OBSOLETE 		   fpreg_buf[0] & 0x7f,
// OBSOLETE 		   (fpreg_buf[1] >> 8) & 0xf,
// OBSOLETE 	  /* fraction */
// OBSOLETE 		   fpreg_buf[1] & 0xf,
// OBSOLETE 		   fpreg_buf[2],
// OBSOLETE 		   fpreg_buf[3],
// OBSOLETE 		   fpreg_buf[4],
// OBSOLETE 		   fpreg_buf[5],
// OBSOLETE 		   fpreg_buf[6],
// OBSOLETE 		   fpreg_buf[7]);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       sr_write_cr (buffer);
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Transfer LEN bytes between GDB address MYADDR and target address
// OBSOLETE    MEMADDR.  If WRITE is non-zero, transfer them to the target,
// OBSOLETE    otherwise transfer them from the target.  TARGET is unused.
// OBSOLETE 
// OBSOLETE    Returns the number of bytes transferred. */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE bug_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
// OBSOLETE 		 struct mem_attrib *attrib, struct target_ops *target)
// OBSOLETE {
// OBSOLETE   int res;
// OBSOLETE 
// OBSOLETE   if (len <= 0)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   if (write)
// OBSOLETE     res = bug_write_memory (memaddr, myaddr, len);
// OBSOLETE   else
// OBSOLETE     res = bug_read_memory (memaddr, myaddr, len);
// OBSOLETE 
// OBSOLETE   return res;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE start_load (void)
// OBSOLETE {
// OBSOLETE   char *command;
// OBSOLETE 
// OBSOLETE   command = (srec_echo_pace ? "lo 0 ;x" : "lo 0");
// OBSOLETE 
// OBSOLETE   sr_write_cr (command);
// OBSOLETE   sr_expect (command);
// OBSOLETE   sr_expect ("\r\n");
// OBSOLETE   bug_srec_write_cr ("S0030000FC");
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* This is an extremely vulnerable and fragile function.  I've made
// OBSOLETE    considerable attempts to make this deterministic, but I've
// OBSOLETE    certainly forgotten something.  The trouble is that S-records are
// OBSOLETE    only a partial file format, not a protocol.  Worse, apparently the
// OBSOLETE    m88k bug monitor does not run in real time while receiving
// OBSOLETE    S-records.  Hence, we must pay excruciating attention to when and
// OBSOLETE    where error messages are returned, and what has actually been sent.
// OBSOLETE 
// OBSOLETE    Each call represents a chunk of memory to be sent to the target.
// OBSOLETE    We break that chunk into an S0 header record, some number of S3
// OBSOLETE    data records each containing srec_bytes, and an S7 termination
// OBSOLETE    record.  */
// OBSOLETE 
// OBSOLETE static char *srecord_strings[] =
// OBSOLETE {
// OBSOLETE   "S-RECORD",
// OBSOLETE   "-Bug>",
// OBSOLETE   NULL,
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE bug_write_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
// OBSOLETE {
// OBSOLETE   int done;
// OBSOLETE   int checksum;
// OBSOLETE   int x;
// OBSOLETE   int retries;
// OBSOLETE   char *buffer = alloca ((srec_bytes + 8) << 1);
// OBSOLETE 
// OBSOLETE   retries = 0;
// OBSOLETE 
// OBSOLETE   do
// OBSOLETE     {
// OBSOLETE       done = 0;
// OBSOLETE 
// OBSOLETE       if (retries > srec_max_retries)
// OBSOLETE 	return (-1);
// OBSOLETE 
// OBSOLETE       if (retries > 0)
// OBSOLETE 	{
// OBSOLETE 	  if (sr_get_debug () > 0)
// OBSOLETE 	    printf ("\n<retrying...>\n");
// OBSOLETE 
// OBSOLETE 	  /* This gr_expect_prompt call is extremely important.  Without
// OBSOLETE 	     it, we will tend to resend our packet so fast that it
// OBSOLETE 	     will arrive before the bug monitor is ready to receive
// OBSOLETE 	     it.  This would lead to a very ugly resend loop.  */
// OBSOLETE 
// OBSOLETE 	  gr_expect_prompt ();
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       start_load ();
// OBSOLETE 
// OBSOLETE       while (done < len)
// OBSOLETE 	{
// OBSOLETE 	  int thisgo;
// OBSOLETE 	  int idx;
// OBSOLETE 	  char *buf = buffer;
// OBSOLETE 	  CORE_ADDR address;
// OBSOLETE 
// OBSOLETE 	  checksum = 0;
// OBSOLETE 	  thisgo = len - done;
// OBSOLETE 	  if (thisgo > srec_bytes)
// OBSOLETE 	    thisgo = srec_bytes;
// OBSOLETE 
// OBSOLETE 	  address = memaddr + done;
// OBSOLETE 	  sprintf (buf, "S3%02X%08lX", thisgo + 4 + 1, (long) address);
// OBSOLETE 	  buf += 12;
// OBSOLETE 
// OBSOLETE 	  checksum += (thisgo + 4 + 1
// OBSOLETE 		       + (address & 0xff)
// OBSOLETE 		       + ((address >> 8) & 0xff)
// OBSOLETE 		       + ((address >> 16) & 0xff)
// OBSOLETE 		       + ((address >> 24) & 0xff));
// OBSOLETE 
// OBSOLETE 	  for (idx = 0; idx < thisgo; idx++)
// OBSOLETE 	    {
// OBSOLETE 	      sprintf (buf, "%02X", myaddr[idx + done]);
// OBSOLETE 	      checksum += myaddr[idx + done];
// OBSOLETE 	      buf += 2;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  if (srec_noise > 0)
// OBSOLETE 	    {
// OBSOLETE 	      /* FIXME-NOW: insert a deliberate error every now and then.
// OBSOLETE 	         This is intended for testing/debugging the error handling
// OBSOLETE 	         stuff.  */
// OBSOLETE 	      static int counter = 0;
// OBSOLETE 	      if (++counter > srec_noise)
// OBSOLETE 		{
// OBSOLETE 		  counter = 0;
// OBSOLETE 		  ++checksum;
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  sprintf (buf, "%02X", ~checksum & 0xff);
// OBSOLETE 	  bug_srec_write_cr (buffer);
// OBSOLETE 
// OBSOLETE 	  if (srec_sleep != 0)
// OBSOLETE 	    sleep (srec_sleep);
// OBSOLETE 
// OBSOLETE 	  /* This pollchar is probably redundant to the gr_multi_scan
// OBSOLETE 	     below.  Trouble is, we can't be sure when or where an
// OBSOLETE 	     error message will appear.  Apparently, when running at
// OBSOLETE 	     full speed from a typical sun4, error messages tend to
// OBSOLETE 	     appear to arrive only *after* the s7 record.   */
// OBSOLETE 
// OBSOLETE 	  if ((x = sr_pollchar ()) != 0)
// OBSOLETE 	    {
// OBSOLETE 	      if (sr_get_debug () > 0)
// OBSOLETE 		printf ("\n<retrying...>\n");
// OBSOLETE 
// OBSOLETE 	      ++retries;
// OBSOLETE 
// OBSOLETE 	      /* flush any remaining input and verify that we are back
// OBSOLETE 	         at the prompt level. */
// OBSOLETE 	      gr_expect_prompt ();
// OBSOLETE 	      /* start all over again. */
// OBSOLETE 	      start_load ();
// OBSOLETE 	      done = 0;
// OBSOLETE 	      continue;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  done += thisgo;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       bug_srec_write_cr ("S7060000000000F9");
// OBSOLETE       ++retries;
// OBSOLETE 
// OBSOLETE       /* Having finished the load, we need to figure out whether we
// OBSOLETE          had any errors.  */
// OBSOLETE     }
// OBSOLETE   while (gr_multi_scan (srecord_strings, 0) == 0);;
// OBSOLETE 
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Copy LEN bytes of data from debugger memory at MYADDR
// OBSOLETE    to inferior's memory at MEMADDR.  Returns errno value.
// OBSOLETE    * sb/sh instructions don't work on unaligned addresses, when TU=1.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE /* Read LEN bytes from inferior memory at MEMADDR.  Put the result
// OBSOLETE    at debugger address MYADDR.  Returns errno value.  */
// OBSOLETE static int
// OBSOLETE bug_read_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
// OBSOLETE {
// OBSOLETE   char request[100];
// OBSOLETE   char *buffer;
// OBSOLETE   char *p;
// OBSOLETE   char type;
// OBSOLETE   char size;
// OBSOLETE   unsigned char c;
// OBSOLETE   unsigned int inaddr;
// OBSOLETE   unsigned int checksum;
// OBSOLETE 
// OBSOLETE   sprintf (request, "du 0 %lx:&%d", (long) memaddr, len);
// OBSOLETE   sr_write_cr (request);
// OBSOLETE 
// OBSOLETE   p = buffer = alloca (len);
// OBSOLETE 
// OBSOLETE   /* scan up through the header */
// OBSOLETE   sr_expect ("S0030000FC");
// OBSOLETE 
// OBSOLETE   while (p < buffer + len)
// OBSOLETE     {
// OBSOLETE       /* scan off any white space. */
// OBSOLETE       while (sr_readchar () != 'S');;
// OBSOLETE 
// OBSOLETE       /* what kind of s-rec? */
// OBSOLETE       type = sr_readchar ();
// OBSOLETE 
// OBSOLETE       /* scan record size */
// OBSOLETE       sr_get_hex_byte (&size);
// OBSOLETE       checksum = size;
// OBSOLETE       --size;
// OBSOLETE       inaddr = 0;
// OBSOLETE 
// OBSOLETE       switch (type)
// OBSOLETE 	{
// OBSOLETE 	case '7':
// OBSOLETE 	case '8':
// OBSOLETE 	case '9':
// OBSOLETE 	  goto done;
// OBSOLETE 
// OBSOLETE 	case '3':
// OBSOLETE 	  sr_get_hex_byte (&c);
// OBSOLETE 	  inaddr = (inaddr << 8) + c;
// OBSOLETE 	  checksum += c;
// OBSOLETE 	  --size;
// OBSOLETE 	  /* intentional fall through */
// OBSOLETE 	case '2':
// OBSOLETE 	  sr_get_hex_byte (&c);
// OBSOLETE 	  inaddr = (inaddr << 8) + c;
// OBSOLETE 	  checksum += c;
// OBSOLETE 	  --size;
// OBSOLETE 	  /* intentional fall through */
// OBSOLETE 	case '1':
// OBSOLETE 	  sr_get_hex_byte (&c);
// OBSOLETE 	  inaddr = (inaddr << 8) + c;
// OBSOLETE 	  checksum += c;
// OBSOLETE 	  --size;
// OBSOLETE 	  sr_get_hex_byte (&c);
// OBSOLETE 	  inaddr = (inaddr << 8) + c;
// OBSOLETE 	  checksum += c;
// OBSOLETE 	  --size;
// OBSOLETE 	  break;
// OBSOLETE 
// OBSOLETE 	default:
// OBSOLETE 	  /* bonk */
// OBSOLETE 	  error ("reading s-records.");
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (inaddr < memaddr
// OBSOLETE 	  || (memaddr + len) < (inaddr + size))
// OBSOLETE 	error ("srec out of memory range.");
// OBSOLETE 
// OBSOLETE       if (p != buffer + inaddr - memaddr)
// OBSOLETE 	error ("srec out of sequence.");
// OBSOLETE 
// OBSOLETE       for (; size; --size, ++p)
// OBSOLETE 	{
// OBSOLETE 	  sr_get_hex_byte (p);
// OBSOLETE 	  checksum += *p;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       sr_get_hex_byte (&c);
// OBSOLETE       if (c != (~checksum & 0xff))
// OBSOLETE 	error ("bad s-rec checksum");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE done:
// OBSOLETE   gr_expect_prompt ();
// OBSOLETE   if (p != buffer + len)
// OBSOLETE     return (1);
// OBSOLETE 
// OBSOLETE   memcpy (myaddr, buffer, len);
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #define MAX_BREAKS	16
// OBSOLETE static int num_brkpts = 0;
// OBSOLETE 
// OBSOLETE /* Insert a breakpoint at ADDR.  SAVE is normally the address of the
// OBSOLETE    pattern buffer where the instruction that the breakpoint overwrites
// OBSOLETE    is saved.  It is unused here since the bug is responsible for
// OBSOLETE    saving/restoring the original instruction. */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE bug_insert_breakpoint (CORE_ADDR addr, char *save)
// OBSOLETE {
// OBSOLETE   sr_check_open ();
// OBSOLETE 
// OBSOLETE   if (num_brkpts < MAX_BREAKS)
// OBSOLETE     {
// OBSOLETE       char buffer[100];
// OBSOLETE 
// OBSOLETE       num_brkpts++;
// OBSOLETE       sprintf (buffer, "br %lx", (long) addr);
// OBSOLETE       sr_write_cr (buffer);
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE       return (0);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       fprintf_filtered (gdb_stderr,
// OBSOLETE 		      "Too many break points, break point not installed\n");
// OBSOLETE       return (1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Remove a breakpoint at ADDR.  SAVE is normally the previously
// OBSOLETE    saved pattern, but is unused here since the bug is responsible
// OBSOLETE    for saving/restoring instructions. */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE bug_remove_breakpoint (CORE_ADDR addr, char *save)
// OBSOLETE {
// OBSOLETE   if (num_brkpts > 0)
// OBSOLETE     {
// OBSOLETE       char buffer[100];
// OBSOLETE 
// OBSOLETE       num_brkpts--;
// OBSOLETE       sprintf (buffer, "nobr %lx", (long) addr);
// OBSOLETE       sr_write_cr (buffer);
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE 
// OBSOLETE     }
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Clear the bugs notion of what the break points are */
// OBSOLETE static int
// OBSOLETE bug_clear_breakpoints (void)
// OBSOLETE {
// OBSOLETE 
// OBSOLETE   if (sr_is_open ())
// OBSOLETE     {
// OBSOLETE       sr_write_cr ("nobr");
// OBSOLETE       sr_expect ("nobr");
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE     }
// OBSOLETE   num_brkpts = 0;
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE struct target_ops bug_ops;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_bug_ops (void)
// OBSOLETE {
// OBSOLETE   bug_ops.to_shortname = "bug";
// OBSOLETE   "Remote BUG monitor",
// OBSOLETE     bug_ops.to_longname = "Use the mvme187 board running the BUG monitor connected by a serial line.";
// OBSOLETE   bug_ops.to_doc = " ";
// OBSOLETE   bug_ops.to_open = bug_open;
// OBSOLETE   bug_ops.to_close = gr_close;
// OBSOLETE   bug_ops.to_attach = 0;
// OBSOLETE   bug_ops.to_post_attach = NULL;
// OBSOLETE   bug_ops.to_require_attach = NULL;
// OBSOLETE   bug_ops.to_detach = gr_detach;
// OBSOLETE   bug_ops.to_require_detach = NULL;
// OBSOLETE   bug_ops.to_resume = bug_resume;
// OBSOLETE   bug_ops.to_wait = bug_wait;
// OBSOLETE   bug_ops.to_post_wait = NULL;
// OBSOLETE   bug_ops.to_fetch_registers = bug_fetch_register;
// OBSOLETE   bug_ops.to_store_registers = bug_store_register;
// OBSOLETE   bug_ops.to_prepare_to_store = gr_prepare_to_store;
// OBSOLETE   bug_ops.to_xfer_memory = bug_xfer_memory;
// OBSOLETE   bug_ops.to_files_info = gr_files_info;
// OBSOLETE   bug_ops.to_insert_breakpoint = bug_insert_breakpoint;
// OBSOLETE   bug_ops.to_remove_breakpoint = bug_remove_breakpoint;
// OBSOLETE   bug_ops.to_terminal_init = 0;
// OBSOLETE   bug_ops.to_terminal_inferior = 0;
// OBSOLETE   bug_ops.to_terminal_ours_for_output = 0;
// OBSOLETE   bug_ops.to_terminal_ours = 0;
// OBSOLETE   bug_ops.to_terminal_info = 0;
// OBSOLETE   bug_ops.to_kill = gr_kill;
// OBSOLETE   bug_ops.to_load = bug_load;
// OBSOLETE   bug_ops.to_lookup_symbol = 0;
// OBSOLETE   bug_ops.to_create_inferior = gr_create_inferior;
// OBSOLETE   bug_ops.to_post_startup_inferior = NULL;
// OBSOLETE   bug_ops.to_acknowledge_created_inferior = NULL;
// OBSOLETE   bug_ops.to_clone_and_follow_inferior = NULL;
// OBSOLETE   bug_ops.to_post_follow_inferior_by_clone = NULL;
// OBSOLETE   bug_ops.to_insert_fork_catchpoint = NULL;
// OBSOLETE   bug_ops.to_remove_fork_catchpoint = NULL;
// OBSOLETE   bug_ops.to_insert_vfork_catchpoint = NULL;
// OBSOLETE   bug_ops.to_remove_vfork_catchpoint = NULL;
// OBSOLETE   bug_ops.to_has_forked = NULL;
// OBSOLETE   bug_ops.to_has_vforked = NULL;
// OBSOLETE   bug_ops.to_can_follow_vfork_prior_to_exec = NULL;
// OBSOLETE   bug_ops.to_post_follow_vfork = NULL;
// OBSOLETE   bug_ops.to_insert_exec_catchpoint = NULL;
// OBSOLETE   bug_ops.to_remove_exec_catchpoint = NULL;
// OBSOLETE   bug_ops.to_has_execd = NULL;
// OBSOLETE   bug_ops.to_reported_exec_events_per_exec_call = NULL;
// OBSOLETE   bug_ops.to_has_exited = NULL;
// OBSOLETE   bug_ops.to_mourn_inferior = gr_mourn;
// OBSOLETE   bug_ops.to_can_run = 0;
// OBSOLETE   bug_ops.to_notice_signals = 0;
// OBSOLETE   bug_ops.to_thread_alive = 0;
// OBSOLETE   bug_ops.to_stop = 0;
// OBSOLETE   bug_ops.to_pid_to_exec_file = NULL;
// OBSOLETE   bug_ops.to_stratum = process_stratum;
// OBSOLETE   bug_ops.DONT_USE = 0;
// OBSOLETE   bug_ops.to_has_all_memory = 1;
// OBSOLETE   bug_ops.to_has_memory = 1;
// OBSOLETE   bug_ops.to_has_stack = 1;
// OBSOLETE   bug_ops.to_has_registers = 0;
// OBSOLETE   bug_ops.to_has_execution = 0;
// OBSOLETE   bug_ops.to_sections = 0;
// OBSOLETE   bug_ops.to_sections_end = 0;
// OBSOLETE   bug_ops.to_magic = OPS_MAGIC;	/* Always the last thing */
// OBSOLETE }				/* init_bug_ops */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_remote_bug (void)
// OBSOLETE {
// OBSOLETE   init_bug_ops ();
// OBSOLETE   add_target (&bug_ops);
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("srec-bytes", class_support, var_uinteger,
// OBSOLETE 		  (char *) &srec_bytes,
// OBSOLETE 		  "\
// OBSOLETE Set the number of bytes represented in each S-record.\n\
// OBSOLETE This affects the communication protocol with the remote target.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("srec-max-retries", class_support, var_uinteger,
// OBSOLETE 		  (char *) &srec_max_retries,
// OBSOLETE 		  "\
// OBSOLETE Set the number of retries for shipping S-records.\n\
// OBSOLETE This affects the communication protocol with the remote target.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE   /* This needs to set SREC_SIZE, not srec_frame which gets changed at the
// OBSOLETE      end of a download.  But do we need the option at all?  */
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("srec-frame", class_support, var_uinteger,
// OBSOLETE 		  (char *) &srec_frame,
// OBSOLETE 		  "\
// OBSOLETE Set the number of bytes in an S-record frame.\n\
// OBSOLETE This affects the communication protocol with the remote target.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE #endif /* 0 */
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("srec-noise", class_support, var_zinteger,
// OBSOLETE 		  (char *) &srec_noise,
// OBSOLETE 		  "\
// OBSOLETE Set number of S-record to send before deliberately flubbing a checksum.\n\
// OBSOLETE Zero means flub none at all.  This affects the communication protocol\n\
// OBSOLETE with the remote target.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("srec-sleep", class_support, var_zinteger,
// OBSOLETE 		  (char *) &srec_sleep,
// OBSOLETE 		  "\
// OBSOLETE Set number of seconds to sleep after an S-record for a possible error message to arrive.\n\
// OBSOLETE This affects the communication protocol with the remote target.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("srec-echo-pace", class_support, var_boolean,
// OBSOLETE 		  (char *) &srec_echo_pace,
// OBSOLETE 		  "\
// OBSOLETE Set echo-verification.\n\
// OBSOLETE When on, use verification by echo when downloading S-records.  This is\n\
// OBSOLETE much slower, but generally more reliable.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE }
@


1.22
log
@Obsolete m88k.
@
text
@@


1.22.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.22.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.21
log
@Remove ATTRIBUTE_UNUSED.  Update (C).
@
text
@d1 1027
a1027 1027
/* Remote debugging interface for Motorola's MVME187BUG monitor, an embedded
   monitor for the m88k.

   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
   2002 Free Software Foundation, Inc.

   Contributed by Cygnus Support.  Written by K. Richard Pixley.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "inferior.h"
#include "gdb_string.h"
#include "regcache.h"
#include <ctype.h>
#include <fcntl.h>
#include <setjmp.h>
#include <errno.h>

#include "terminal.h"
#include "gdbcore.h"
#include "gdbcmd.h"

#include "serial.h"
#include "remote-utils.h"

/* External data declarations */
extern int stop_soon_quietly;	/* for wait_for_inferior */

/* Forward data declarations */
extern struct target_ops bug_ops;	/* Forward declaration */

/* Forward function declarations */
static int bug_clear_breakpoints (void);

static int bug_read_memory (CORE_ADDR memaddr,
			    unsigned char *myaddr, int len);

static int bug_write_memory (CORE_ADDR memaddr,
			     unsigned char *myaddr, int len);

/* This variable is somewhat arbitrary.  It's here so that it can be
   set from within a running gdb.  */

static int srec_max_retries = 3;

/* Each S-record download to the target consists of an S0 header
   record, some number of S3 data records, and one S7 termination
   record.  I call this download a "frame".  Srec_frame says how many
   bytes will be represented in each frame.  */

#define SREC_SIZE 160
static int srec_frame = SREC_SIZE;

/* This variable determines how many bytes will be represented in each
   S3 s-record.  */

static int srec_bytes = 40;

/* At one point it appeared to me as though the bug monitor could not
   really be expected to receive two sequential characters at 9600
   baud reliably.  Echo-pacing is an attempt to force data across the
   line even in this condition.  Specifically, in echo-pace mode, each
   character is sent one at a time and we look for the echo before
   sending the next.  This is excruciatingly slow.  */

static int srec_echo_pace = 0;

/* How long to wait after an srec for a possible error message.
   Similar to the above, I tried sleeping after sending each S3 record
   in hopes that I might actually see error messages from the bug
   monitor.  This might actually work if we were to use sleep
   intervals smaller than 1 second.  */

static int srec_sleep = 0;

/* Every srec_noise records, flub the checksum.  This is a debugging
   feature.  Set the variable to something other than 1 in order to
   inject *deliberate* checksum errors.  One might do this if one
   wanted to test error handling and recovery.  */

static int srec_noise = 0;

/* Called when SIGALRM signal sent due to alarm() timeout.  */

/* Number of SIGTRAPs we need to simulate.  That is, the next
   NEED_ARTIFICIAL_TRAP calls to bug_wait should just return
   SIGTRAP without actually waiting for anything.  */

static int need_artificial_trap = 0;

/*
 * Download a file specified in 'args', to the bug.
 */

static void
bug_load (char *args, int fromtty)
{
  bfd *abfd;
  asection *s;
  char buffer[1024];

  sr_check_open ();

  inferior_ptid = null_ptid;
  abfd = bfd_openr (args, 0);
  if (!abfd)
    {
      printf_filtered ("Unable to open file %s\n", args);
      return;
    }

  if (bfd_check_format (abfd, bfd_object) == 0)
    {
      printf_filtered ("File is not an object file\n");
      return;
    }

  s = abfd->sections;
  while (s != (asection *) NULL)
    {
      srec_frame = SREC_SIZE;
      if (s->flags & SEC_LOAD)
	{
	  int i;

	  char *buffer = xmalloc (srec_frame);

	  printf_filtered ("%s\t: 0x%4lx .. 0x%4lx  ", s->name, s->vma, s->vma + s->_raw_size);
	  gdb_flush (gdb_stdout);
	  for (i = 0; i < s->_raw_size; i += srec_frame)
	    {
	      if (srec_frame > s->_raw_size - i)
		srec_frame = s->_raw_size - i;

	      bfd_get_section_contents (abfd, s, buffer, i, srec_frame);
	      bug_write_memory (s->vma + i, buffer, srec_frame);
	      printf_filtered ("*");
	      gdb_flush (gdb_stdout);
	    }
	  printf_filtered ("\n");
	  xfree (buffer);
	}
      s = s->next;
    }
  sprintf (buffer, "rs ip %lx", (unsigned long) abfd->start_address);
  sr_write_cr (buffer);
  gr_expect_prompt ();
}

#if 0
static char *
get_word (char **p)
{
  char *s = *p;
  char *word;
  char *copy;
  size_t len;

  while (isspace (*s))
    s++;

  word = s;

  len = 0;

  while (*s && !isspace (*s))
    {
      s++;
      len++;

    }
  copy = xmalloc (len + 1);
  memcpy (copy, word, len);
  copy[len] = 0;
  *p = s;
  return copy;
}
#endif

static struct gr_settings bug_settings =
{
  "Bug>",			/* prompt */
  &bug_ops,			/* ops */
  bug_clear_breakpoints,	/* clear_all_breakpoints */
  gr_generic_checkin,		/* checkin */
};

static char *cpu_check_strings[] =
{
  "=",
  "Invalid Register",
};

static void
bug_open (char *args, int from_tty)
{
  if (args == NULL)
    args = "";

  gr_open (args, from_tty, &bug_settings);
  /* decide *now* whether we are on an 88100 or an 88110 */
  sr_write_cr ("rs cr06");
  sr_expect ("rs cr06");

  switch (gr_multi_scan (cpu_check_strings, 0))
    {
    case 0:			/* this is an m88100 */
      target_is_m88110 = 0;
      break;
    case 1:			/* this is an m88110 */
      target_is_m88110 = 1;
      break;
    default:
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
    }
}

/* Tell the remote machine to resume.  */

void
bug_resume (ptid_t ptid, int step, enum target_signal sig)
{
  if (step)
    {
      sr_write_cr ("t");

      /* Force the next bug_wait to return a trap.  Not doing anything
         about I/O from the target means that the user has to type
         "continue" to see any.  FIXME, this should be fixed.  */
      need_artificial_trap = 1;
    }
  else
    sr_write_cr ("g");

  return;
}

/* Wait until the remote machine stops, then return,
   storing status in STATUS just as `wait' would.  */

static char *wait_strings[] =
{
  "At Breakpoint",
  "Exception: Data Access Fault (Local Bus Timeout)",
  "\r8??\?-Bug>",		/* The '\?' avoids creating a trigraph */
  "\r197-Bug>",
  NULL,
};

ptid_t
bug_wait (ptid_t ptid, struct target_waitstatus *status)
{
  int old_timeout = sr_get_timeout ();
  int old_immediate_quit = immediate_quit;

  status->kind = TARGET_WAITKIND_EXITED;
  status->value.integer = 0;

  /* read off leftovers from resume so that the rest can be passed
     back out as stdout.  */
  if (need_artificial_trap == 0)
    {
      sr_expect ("Effective address: ");
      (void) sr_get_hex_word ();
      sr_expect ("\r\n");
    }

  sr_set_timeout (-1);		/* Don't time out -- user program is running. */
  immediate_quit = 1;		/* Helps ability to QUIT */

  switch (gr_multi_scan (wait_strings, need_artificial_trap == 0))
    {
    case 0:			/* breakpoint case */
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_TRAP;
      /* user output from the target can be discarded here. (?) */
      gr_expect_prompt ();
      break;

    case 1:			/* bus error */
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_BUS;
      /* user output from the target can be discarded here. (?) */
      gr_expect_prompt ();
      break;

    case 2:			/* normal case */
    case 3:
      if (need_artificial_trap != 0)
	{
	  /* stepping */
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_TRAP;
	  need_artificial_trap--;
	  break;
	}
      else
	{
	  /* exit case */
	  status->kind = TARGET_WAITKIND_EXITED;
	  status->value.integer = 0;
	  break;
	}

    case -1:			/* trouble */
    default:
      fprintf_filtered (gdb_stderr,
			"Trouble reading target during wait\n");
      break;
    }

  sr_set_timeout (old_timeout);
  immediate_quit = old_immediate_quit;
  return inferior_ptid;
}

/* Return the name of register number REGNO
   in the form input and output by bug.

   Returns a pointer to a static buffer containing the answer.  */
static char *
get_reg_name (int regno)
{
  static char *rn[] =
  {
    "r00", "r01", "r02", "r03", "r04", "r05", "r06", "r07",
    "r08", "r09", "r10", "r11", "r12", "r13", "r14", "r15",
    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",

  /* these get confusing because we omit a few and switch some ordering around. */

    "cr01",			/* 32 = psr */
    "fcr62",			/* 33 = fpsr */
    "fcr63",			/* 34 = fpcr */
    "ip",			/* this is something of a cheat. */
  /* 35 = sxip */
    "cr05",			/* 36 = snip */
    "cr06",			/* 37 = sfip */

    "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07",
    "x08", "x09", "x10", "x11", "x12", "x13", "x14", "x15",
    "x16", "x17", "x18", "x19", "x20", "x21", "x22", "x23",
    "x24", "x25", "x26", "x27", "x28", "x29", "x30", "x31",
  };

  return rn[regno];
}

#if 0				/* not currently used */
/* Read from remote while the input matches STRING.  Return zero on
   success, -1 on failure.  */

static int
bug_scan (char *s)
{
  int c;

  while (*s)
    {
      c = sr_readchar ();
      if (c != *s++)
	{
	  fflush (stdout);
	  printf ("\nNext character is '%c' - %d and s is \"%s\".\n", c, c, --s);
	  return (-1);
	}
    }

  return (0);
}
#endif /* never */

static int
bug_srec_write_cr (char *s)
{
  char *p = s;

  if (srec_echo_pace)
    for (p = s; *p; ++p)
      {
	if (sr_get_debug () > 0)
	  printf ("%c", *p);

	do
	  serial_write (sr_get_desc (), p, 1);
	while (sr_pollchar () != *p);
      }
  else
    {
      sr_write_cr (s);
/*       return(bug_scan (s) || bug_scan ("\n")); */
    }

  return (0);
}

/* Store register REGNO, or all if REGNO == -1. */

static void
bug_fetch_register (int regno)
{
  sr_check_open ();

  if (regno == -1)
    {
      int i;

      for (i = 0; i < NUM_REGS; ++i)
	bug_fetch_register (i);
    }
  else if (target_is_m88110 && regno == SFIP_REGNUM)
    {
      /* m88110 has no sfip. */
      long l = 0;
      supply_register (regno, (char *) &l);
    }
  else if (regno < XFP_REGNUM)
    {
      char buffer[MAX_REGISTER_RAW_SIZE];

      sr_write ("rs ", 3);
      sr_write_cr (get_reg_name (regno));
      sr_expect ("=");
      store_unsigned_integer (buffer, REGISTER_RAW_SIZE (regno),
			      sr_get_hex_word ());
      gr_expect_prompt ();
      supply_register (regno, buffer);
    }
  else
    {
      /* Float register so we need to parse a strange data format. */
      long p;
      unsigned char fpreg_buf[10];

      sr_write ("rs ", 3);
      sr_write (get_reg_name (regno), strlen (get_reg_name (regno)));
      sr_write_cr (";d");
      sr_expect ("rs");
      sr_expect (get_reg_name (regno));
      sr_expect (";d");
      sr_expect ("=");

      /* sign */
      p = sr_get_hex_digit (1);
      fpreg_buf[0] = p << 7;

      /* exponent */
      sr_expect ("_");
      p = sr_get_hex_digit (1);
      fpreg_buf[0] += (p << 4);
      fpreg_buf[0] += sr_get_hex_digit (1);

      fpreg_buf[1] = sr_get_hex_digit (1) << 4;

      /* fraction */
      sr_expect ("_");
      fpreg_buf[1] += sr_get_hex_digit (1);

      fpreg_buf[2] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
      fpreg_buf[3] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
      fpreg_buf[4] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
      fpreg_buf[5] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
      fpreg_buf[6] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
      fpreg_buf[7] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
      fpreg_buf[8] = 0;
      fpreg_buf[9] = 0;

      gr_expect_prompt ();
      supply_register (regno, fpreg_buf);
    }

  return;
}

/* Store register REGNO, or all if REGNO == -1. */

static void
bug_store_register (int regno)
{
  char buffer[1024];
  sr_check_open ();

  if (regno == -1)
    {
      int i;

      for (i = 0; i < NUM_REGS; ++i)
	bug_store_register (i);
    }
  else
    {
      char *regname;

      regname = get_reg_name (regno);

      if (target_is_m88110 && regno == SFIP_REGNUM)
	return;
      else if (regno < XFP_REGNUM)
	sprintf (buffer, "rs %s %08lx",
		 regname,
		 (long) read_register (regno));
      else
	{
	  unsigned char *fpreg_buf =
	  (unsigned char *) &registers[REGISTER_BYTE (regno)];

	  sprintf (buffer, "rs %s %1x_%02x%1x_%1x%02x%02x%02x%02x%02x%02x;d",
		   regname,
	  /* sign */
		   (fpreg_buf[0] >> 7) & 0xf,
	  /* exponent */
		   fpreg_buf[0] & 0x7f,
		   (fpreg_buf[1] >> 8) & 0xf,
	  /* fraction */
		   fpreg_buf[1] & 0xf,
		   fpreg_buf[2],
		   fpreg_buf[3],
		   fpreg_buf[4],
		   fpreg_buf[5],
		   fpreg_buf[6],
		   fpreg_buf[7]);
	}

      sr_write_cr (buffer);
      gr_expect_prompt ();
    }

  return;
}

/* Transfer LEN bytes between GDB address MYADDR and target address
   MEMADDR.  If WRITE is non-zero, transfer them to the target,
   otherwise transfer them from the target.  TARGET is unused.

   Returns the number of bytes transferred. */

int
bug_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		 struct mem_attrib *attrib, struct target_ops *target)
{
  int res;

  if (len <= 0)
    return 0;

  if (write)
    res = bug_write_memory (memaddr, myaddr, len);
  else
    res = bug_read_memory (memaddr, myaddr, len);

  return res;
}

static void
start_load (void)
{
  char *command;

  command = (srec_echo_pace ? "lo 0 ;x" : "lo 0");

  sr_write_cr (command);
  sr_expect (command);
  sr_expect ("\r\n");
  bug_srec_write_cr ("S0030000FC");
  return;
}

/* This is an extremely vulnerable and fragile function.  I've made
   considerable attempts to make this deterministic, but I've
   certainly forgotten something.  The trouble is that S-records are
   only a partial file format, not a protocol.  Worse, apparently the
   m88k bug monitor does not run in real time while receiving
   S-records.  Hence, we must pay excruciating attention to when and
   where error messages are returned, and what has actually been sent.

   Each call represents a chunk of memory to be sent to the target.
   We break that chunk into an S0 header record, some number of S3
   data records each containing srec_bytes, and an S7 termination
   record.  */

static char *srecord_strings[] =
{
  "S-RECORD",
  "-Bug>",
  NULL,
};

static int
bug_write_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  int done;
  int checksum;
  int x;
  int retries;
  char *buffer = alloca ((srec_bytes + 8) << 1);

  retries = 0;

  do
    {
      done = 0;

      if (retries > srec_max_retries)
	return (-1);

      if (retries > 0)
	{
	  if (sr_get_debug () > 0)
	    printf ("\n<retrying...>\n");

	  /* This gr_expect_prompt call is extremely important.  Without
	     it, we will tend to resend our packet so fast that it
	     will arrive before the bug monitor is ready to receive
	     it.  This would lead to a very ugly resend loop.  */

	  gr_expect_prompt ();
	}

      start_load ();

      while (done < len)
	{
	  int thisgo;
	  int idx;
	  char *buf = buffer;
	  CORE_ADDR address;

	  checksum = 0;
	  thisgo = len - done;
	  if (thisgo > srec_bytes)
	    thisgo = srec_bytes;

	  address = memaddr + done;
	  sprintf (buf, "S3%02X%08lX", thisgo + 4 + 1, (long) address);
	  buf += 12;

	  checksum += (thisgo + 4 + 1
		       + (address & 0xff)
		       + ((address >> 8) & 0xff)
		       + ((address >> 16) & 0xff)
		       + ((address >> 24) & 0xff));

	  for (idx = 0; idx < thisgo; idx++)
	    {
	      sprintf (buf, "%02X", myaddr[idx + done]);
	      checksum += myaddr[idx + done];
	      buf += 2;
	    }

	  if (srec_noise > 0)
	    {
	      /* FIXME-NOW: insert a deliberate error every now and then.
	         This is intended for testing/debugging the error handling
	         stuff.  */
	      static int counter = 0;
	      if (++counter > srec_noise)
		{
		  counter = 0;
		  ++checksum;
		}
	    }

	  sprintf (buf, "%02X", ~checksum & 0xff);
	  bug_srec_write_cr (buffer);

	  if (srec_sleep != 0)
	    sleep (srec_sleep);

	  /* This pollchar is probably redundant to the gr_multi_scan
	     below.  Trouble is, we can't be sure when or where an
	     error message will appear.  Apparently, when running at
	     full speed from a typical sun4, error messages tend to
	     appear to arrive only *after* the s7 record.   */

	  if ((x = sr_pollchar ()) != 0)
	    {
	      if (sr_get_debug () > 0)
		printf ("\n<retrying...>\n");

	      ++retries;

	      /* flush any remaining input and verify that we are back
	         at the prompt level. */
	      gr_expect_prompt ();
	      /* start all over again. */
	      start_load ();
	      done = 0;
	      continue;
	    }

	  done += thisgo;
	}

      bug_srec_write_cr ("S7060000000000F9");
      ++retries;

      /* Having finished the load, we need to figure out whether we
         had any errors.  */
    }
  while (gr_multi_scan (srecord_strings, 0) == 0);;

  return (0);
}

/* Copy LEN bytes of data from debugger memory at MYADDR
   to inferior's memory at MEMADDR.  Returns errno value.
   * sb/sh instructions don't work on unaligned addresses, when TU=1.
 */

/* Read LEN bytes from inferior memory at MEMADDR.  Put the result
   at debugger address MYADDR.  Returns errno value.  */
static int
bug_read_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  char request[100];
  char *buffer;
  char *p;
  char type;
  char size;
  unsigned char c;
  unsigned int inaddr;
  unsigned int checksum;

  sprintf (request, "du 0 %lx:&%d", (long) memaddr, len);
  sr_write_cr (request);

  p = buffer = alloca (len);

  /* scan up through the header */
  sr_expect ("S0030000FC");

  while (p < buffer + len)
    {
      /* scan off any white space. */
      while (sr_readchar () != 'S');;

      /* what kind of s-rec? */
      type = sr_readchar ();

      /* scan record size */
      sr_get_hex_byte (&size);
      checksum = size;
      --size;
      inaddr = 0;

      switch (type)
	{
	case '7':
	case '8':
	case '9':
	  goto done;

	case '3':
	  sr_get_hex_byte (&c);
	  inaddr = (inaddr << 8) + c;
	  checksum += c;
	  --size;
	  /* intentional fall through */
	case '2':
	  sr_get_hex_byte (&c);
	  inaddr = (inaddr << 8) + c;
	  checksum += c;
	  --size;
	  /* intentional fall through */
	case '1':
	  sr_get_hex_byte (&c);
	  inaddr = (inaddr << 8) + c;
	  checksum += c;
	  --size;
	  sr_get_hex_byte (&c);
	  inaddr = (inaddr << 8) + c;
	  checksum += c;
	  --size;
	  break;

	default:
	  /* bonk */
	  error ("reading s-records.");
	}

      if (inaddr < memaddr
	  || (memaddr + len) < (inaddr + size))
	error ("srec out of memory range.");

      if (p != buffer + inaddr - memaddr)
	error ("srec out of sequence.");

      for (; size; --size, ++p)
	{
	  sr_get_hex_byte (p);
	  checksum += *p;
	}

      sr_get_hex_byte (&c);
      if (c != (~checksum & 0xff))
	error ("bad s-rec checksum");
    }

done:
  gr_expect_prompt ();
  if (p != buffer + len)
    return (1);

  memcpy (myaddr, buffer, len);
  return (0);
}

#define MAX_BREAKS	16
static int num_brkpts = 0;

/* Insert a breakpoint at ADDR.  SAVE is normally the address of the
   pattern buffer where the instruction that the breakpoint overwrites
   is saved.  It is unused here since the bug is responsible for
   saving/restoring the original instruction. */

static int
bug_insert_breakpoint (CORE_ADDR addr, char *save)
{
  sr_check_open ();

  if (num_brkpts < MAX_BREAKS)
    {
      char buffer[100];

      num_brkpts++;
      sprintf (buffer, "br %lx", (long) addr);
      sr_write_cr (buffer);
      gr_expect_prompt ();
      return (0);
    }
  else
    {
      fprintf_filtered (gdb_stderr,
		      "Too many break points, break point not installed\n");
      return (1);
    }

}

/* Remove a breakpoint at ADDR.  SAVE is normally the previously
   saved pattern, but is unused here since the bug is responsible
   for saving/restoring instructions. */

static int
bug_remove_breakpoint (CORE_ADDR addr, char *save)
{
  if (num_brkpts > 0)
    {
      char buffer[100];

      num_brkpts--;
      sprintf (buffer, "nobr %lx", (long) addr);
      sr_write_cr (buffer);
      gr_expect_prompt ();

    }
  return (0);
}

/* Clear the bugs notion of what the break points are */
static int
bug_clear_breakpoints (void)
{

  if (sr_is_open ())
    {
      sr_write_cr ("nobr");
      sr_expect ("nobr");
      gr_expect_prompt ();
    }
  num_brkpts = 0;
  return (0);
}

struct target_ops bug_ops;

static void
init_bug_ops (void)
{
  bug_ops.to_shortname = "bug";
  "Remote BUG monitor",
    bug_ops.to_longname = "Use the mvme187 board running the BUG monitor connected by a serial line.";
  bug_ops.to_doc = " ";
  bug_ops.to_open = bug_open;
  bug_ops.to_close = gr_close;
  bug_ops.to_attach = 0;
  bug_ops.to_post_attach = NULL;
  bug_ops.to_require_attach = NULL;
  bug_ops.to_detach = gr_detach;
  bug_ops.to_require_detach = NULL;
  bug_ops.to_resume = bug_resume;
  bug_ops.to_wait = bug_wait;
  bug_ops.to_post_wait = NULL;
  bug_ops.to_fetch_registers = bug_fetch_register;
  bug_ops.to_store_registers = bug_store_register;
  bug_ops.to_prepare_to_store = gr_prepare_to_store;
  bug_ops.to_xfer_memory = bug_xfer_memory;
  bug_ops.to_files_info = gr_files_info;
  bug_ops.to_insert_breakpoint = bug_insert_breakpoint;
  bug_ops.to_remove_breakpoint = bug_remove_breakpoint;
  bug_ops.to_terminal_init = 0;
  bug_ops.to_terminal_inferior = 0;
  bug_ops.to_terminal_ours_for_output = 0;
  bug_ops.to_terminal_ours = 0;
  bug_ops.to_terminal_info = 0;
  bug_ops.to_kill = gr_kill;
  bug_ops.to_load = bug_load;
  bug_ops.to_lookup_symbol = 0;
  bug_ops.to_create_inferior = gr_create_inferior;
  bug_ops.to_post_startup_inferior = NULL;
  bug_ops.to_acknowledge_created_inferior = NULL;
  bug_ops.to_clone_and_follow_inferior = NULL;
  bug_ops.to_post_follow_inferior_by_clone = NULL;
  bug_ops.to_insert_fork_catchpoint = NULL;
  bug_ops.to_remove_fork_catchpoint = NULL;
  bug_ops.to_insert_vfork_catchpoint = NULL;
  bug_ops.to_remove_vfork_catchpoint = NULL;
  bug_ops.to_has_forked = NULL;
  bug_ops.to_has_vforked = NULL;
  bug_ops.to_can_follow_vfork_prior_to_exec = NULL;
  bug_ops.to_post_follow_vfork = NULL;
  bug_ops.to_insert_exec_catchpoint = NULL;
  bug_ops.to_remove_exec_catchpoint = NULL;
  bug_ops.to_has_execd = NULL;
  bug_ops.to_reported_exec_events_per_exec_call = NULL;
  bug_ops.to_has_exited = NULL;
  bug_ops.to_mourn_inferior = gr_mourn;
  bug_ops.to_can_run = 0;
  bug_ops.to_notice_signals = 0;
  bug_ops.to_thread_alive = 0;
  bug_ops.to_stop = 0;
  bug_ops.to_pid_to_exec_file = NULL;
  bug_ops.to_stratum = process_stratum;
  bug_ops.DONT_USE = 0;
  bug_ops.to_has_all_memory = 1;
  bug_ops.to_has_memory = 1;
  bug_ops.to_has_stack = 1;
  bug_ops.to_has_registers = 0;
  bug_ops.to_has_execution = 0;
  bug_ops.to_sections = 0;
  bug_ops.to_sections_end = 0;
  bug_ops.to_magic = OPS_MAGIC;	/* Always the last thing */
}				/* init_bug_ops */

void
_initialize_remote_bug (void)
{
  init_bug_ops ();
  add_target (&bug_ops);

  add_show_from_set
    (add_set_cmd ("srec-bytes", class_support, var_uinteger,
		  (char *) &srec_bytes,
		  "\
Set the number of bytes represented in each S-record.\n\
This affects the communication protocol with the remote target.",
		  &setlist),
     &showlist);

  add_show_from_set
    (add_set_cmd ("srec-max-retries", class_support, var_uinteger,
		  (char *) &srec_max_retries,
		  "\
Set the number of retries for shipping S-records.\n\
This affects the communication protocol with the remote target.",
		  &setlist),
     &showlist);

#if 0
  /* This needs to set SREC_SIZE, not srec_frame which gets changed at the
     end of a download.  But do we need the option at all?  */
  add_show_from_set
    (add_set_cmd ("srec-frame", class_support, var_uinteger,
		  (char *) &srec_frame,
		  "\
Set the number of bytes in an S-record frame.\n\
This affects the communication protocol with the remote target.",
		  &setlist),
     &showlist);
#endif /* 0 */

  add_show_from_set
    (add_set_cmd ("srec-noise", class_support, var_zinteger,
		  (char *) &srec_noise,
		  "\
Set number of S-record to send before deliberately flubbing a checksum.\n\
Zero means flub none at all.  This affects the communication protocol\n\
with the remote target.",
		  &setlist),
     &showlist);

  add_show_from_set
    (add_set_cmd ("srec-sleep", class_support, var_zinteger,
		  (char *) &srec_sleep,
		  "\
Set number of seconds to sleep after an S-record for a possible error message to arrive.\n\
This affects the communication protocol with the remote target.",
		  &setlist),
     &showlist);

  add_show_from_set
    (add_set_cmd ("srec-echo-pace", class_support, var_boolean,
		  (char *) &srec_echo_pace,
		  "\
Set echo-verification.\n\
When on, use verification by echo when downloading S-records.  This is\n\
much slower, but generally more reliable.",
		  &setlist),
     &showlist);
}
@


1.21.8.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d1 1027
a1027 1027
// OBSOLETE /* Remote debugging interface for Motorola's MVME187BUG monitor, an embedded
// OBSOLETE    monitor for the m88k.
// OBSOLETE 
// OBSOLETE    Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
// OBSOLETE    2002 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    Contributed by Cygnus Support.  Written by K. Richard Pixley.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "gdb_string.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE #include <ctype.h>
// OBSOLETE #include <fcntl.h>
// OBSOLETE #include <setjmp.h>
// OBSOLETE #include <errno.h>
// OBSOLETE 
// OBSOLETE #include "terminal.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "gdbcmd.h"
// OBSOLETE 
// OBSOLETE #include "serial.h"
// OBSOLETE #include "remote-utils.h"
// OBSOLETE 
// OBSOLETE /* External data declarations */
// OBSOLETE extern int stop_soon_quietly;	/* for wait_for_inferior */
// OBSOLETE 
// OBSOLETE /* Forward data declarations */
// OBSOLETE extern struct target_ops bug_ops;	/* Forward declaration */
// OBSOLETE 
// OBSOLETE /* Forward function declarations */
// OBSOLETE static int bug_clear_breakpoints (void);
// OBSOLETE 
// OBSOLETE static int bug_read_memory (CORE_ADDR memaddr,
// OBSOLETE 			    unsigned char *myaddr, int len);
// OBSOLETE 
// OBSOLETE static int bug_write_memory (CORE_ADDR memaddr,
// OBSOLETE 			     unsigned char *myaddr, int len);
// OBSOLETE 
// OBSOLETE /* This variable is somewhat arbitrary.  It's here so that it can be
// OBSOLETE    set from within a running gdb.  */
// OBSOLETE 
// OBSOLETE static int srec_max_retries = 3;
// OBSOLETE 
// OBSOLETE /* Each S-record download to the target consists of an S0 header
// OBSOLETE    record, some number of S3 data records, and one S7 termination
// OBSOLETE    record.  I call this download a "frame".  Srec_frame says how many
// OBSOLETE    bytes will be represented in each frame.  */
// OBSOLETE 
// OBSOLETE #define SREC_SIZE 160
// OBSOLETE static int srec_frame = SREC_SIZE;
// OBSOLETE 
// OBSOLETE /* This variable determines how many bytes will be represented in each
// OBSOLETE    S3 s-record.  */
// OBSOLETE 
// OBSOLETE static int srec_bytes = 40;
// OBSOLETE 
// OBSOLETE /* At one point it appeared to me as though the bug monitor could not
// OBSOLETE    really be expected to receive two sequential characters at 9600
// OBSOLETE    baud reliably.  Echo-pacing is an attempt to force data across the
// OBSOLETE    line even in this condition.  Specifically, in echo-pace mode, each
// OBSOLETE    character is sent one at a time and we look for the echo before
// OBSOLETE    sending the next.  This is excruciatingly slow.  */
// OBSOLETE 
// OBSOLETE static int srec_echo_pace = 0;
// OBSOLETE 
// OBSOLETE /* How long to wait after an srec for a possible error message.
// OBSOLETE    Similar to the above, I tried sleeping after sending each S3 record
// OBSOLETE    in hopes that I might actually see error messages from the bug
// OBSOLETE    monitor.  This might actually work if we were to use sleep
// OBSOLETE    intervals smaller than 1 second.  */
// OBSOLETE 
// OBSOLETE static int srec_sleep = 0;
// OBSOLETE 
// OBSOLETE /* Every srec_noise records, flub the checksum.  This is a debugging
// OBSOLETE    feature.  Set the variable to something other than 1 in order to
// OBSOLETE    inject *deliberate* checksum errors.  One might do this if one
// OBSOLETE    wanted to test error handling and recovery.  */
// OBSOLETE 
// OBSOLETE static int srec_noise = 0;
// OBSOLETE 
// OBSOLETE /* Called when SIGALRM signal sent due to alarm() timeout.  */
// OBSOLETE 
// OBSOLETE /* Number of SIGTRAPs we need to simulate.  That is, the next
// OBSOLETE    NEED_ARTIFICIAL_TRAP calls to bug_wait should just return
// OBSOLETE    SIGTRAP without actually waiting for anything.  */
// OBSOLETE 
// OBSOLETE static int need_artificial_trap = 0;
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Download a file specified in 'args', to the bug.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE bug_load (char *args, int fromtty)
// OBSOLETE {
// OBSOLETE   bfd *abfd;
// OBSOLETE   asection *s;
// OBSOLETE   char buffer[1024];
// OBSOLETE 
// OBSOLETE   sr_check_open ();
// OBSOLETE 
// OBSOLETE   inferior_ptid = null_ptid;
// OBSOLETE   abfd = bfd_openr (args, 0);
// OBSOLETE   if (!abfd)
// OBSOLETE     {
// OBSOLETE       printf_filtered ("Unable to open file %s\n", args);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (bfd_check_format (abfd, bfd_object) == 0)
// OBSOLETE     {
// OBSOLETE       printf_filtered ("File is not an object file\n");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   s = abfd->sections;
// OBSOLETE   while (s != (asection *) NULL)
// OBSOLETE     {
// OBSOLETE       srec_frame = SREC_SIZE;
// OBSOLETE       if (s->flags & SEC_LOAD)
// OBSOLETE 	{
// OBSOLETE 	  int i;
// OBSOLETE 
// OBSOLETE 	  char *buffer = xmalloc (srec_frame);
// OBSOLETE 
// OBSOLETE 	  printf_filtered ("%s\t: 0x%4lx .. 0x%4lx  ", s->name, s->vma, s->vma + s->_raw_size);
// OBSOLETE 	  gdb_flush (gdb_stdout);
// OBSOLETE 	  for (i = 0; i < s->_raw_size; i += srec_frame)
// OBSOLETE 	    {
// OBSOLETE 	      if (srec_frame > s->_raw_size - i)
// OBSOLETE 		srec_frame = s->_raw_size - i;
// OBSOLETE 
// OBSOLETE 	      bfd_get_section_contents (abfd, s, buffer, i, srec_frame);
// OBSOLETE 	      bug_write_memory (s->vma + i, buffer, srec_frame);
// OBSOLETE 	      printf_filtered ("*");
// OBSOLETE 	      gdb_flush (gdb_stdout);
// OBSOLETE 	    }
// OBSOLETE 	  printf_filtered ("\n");
// OBSOLETE 	  xfree (buffer);
// OBSOLETE 	}
// OBSOLETE       s = s->next;
// OBSOLETE     }
// OBSOLETE   sprintf (buffer, "rs ip %lx", (unsigned long) abfd->start_address);
// OBSOLETE   sr_write_cr (buffer);
// OBSOLETE   gr_expect_prompt ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE static char *
// OBSOLETE get_word (char **p)
// OBSOLETE {
// OBSOLETE   char *s = *p;
// OBSOLETE   char *word;
// OBSOLETE   char *copy;
// OBSOLETE   size_t len;
// OBSOLETE 
// OBSOLETE   while (isspace (*s))
// OBSOLETE     s++;
// OBSOLETE 
// OBSOLETE   word = s;
// OBSOLETE 
// OBSOLETE   len = 0;
// OBSOLETE 
// OBSOLETE   while (*s && !isspace (*s))
// OBSOLETE     {
// OBSOLETE       s++;
// OBSOLETE       len++;
// OBSOLETE 
// OBSOLETE     }
// OBSOLETE   copy = xmalloc (len + 1);
// OBSOLETE   memcpy (copy, word, len);
// OBSOLETE   copy[len] = 0;
// OBSOLETE   *p = s;
// OBSOLETE   return copy;
// OBSOLETE }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE static struct gr_settings bug_settings =
// OBSOLETE {
// OBSOLETE   "Bug>",			/* prompt */
// OBSOLETE   &bug_ops,			/* ops */
// OBSOLETE   bug_clear_breakpoints,	/* clear_all_breakpoints */
// OBSOLETE   gr_generic_checkin,		/* checkin */
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static char *cpu_check_strings[] =
// OBSOLETE {
// OBSOLETE   "=",
// OBSOLETE   "Invalid Register",
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE bug_open (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   if (args == NULL)
// OBSOLETE     args = "";
// OBSOLETE 
// OBSOLETE   gr_open (args, from_tty, &bug_settings);
// OBSOLETE   /* decide *now* whether we are on an 88100 or an 88110 */
// OBSOLETE   sr_write_cr ("rs cr06");
// OBSOLETE   sr_expect ("rs cr06");
// OBSOLETE 
// OBSOLETE   switch (gr_multi_scan (cpu_check_strings, 0))
// OBSOLETE     {
// OBSOLETE     case 0:			/* this is an m88100 */
// OBSOLETE       target_is_m88110 = 0;
// OBSOLETE       break;
// OBSOLETE     case 1:			/* this is an m88110 */
// OBSOLETE       target_is_m88110 = 1;
// OBSOLETE       break;
// OBSOLETE     default:
// OBSOLETE       internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Tell the remote machine to resume.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE bug_resume (ptid_t ptid, int step, enum target_signal sig)
// OBSOLETE {
// OBSOLETE   if (step)
// OBSOLETE     {
// OBSOLETE       sr_write_cr ("t");
// OBSOLETE 
// OBSOLETE       /* Force the next bug_wait to return a trap.  Not doing anything
// OBSOLETE          about I/O from the target means that the user has to type
// OBSOLETE          "continue" to see any.  FIXME, this should be fixed.  */
// OBSOLETE       need_artificial_trap = 1;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     sr_write_cr ("g");
// OBSOLETE 
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Wait until the remote machine stops, then return,
// OBSOLETE    storing status in STATUS just as `wait' would.  */
// OBSOLETE 
// OBSOLETE static char *wait_strings[] =
// OBSOLETE {
// OBSOLETE   "At Breakpoint",
// OBSOLETE   "Exception: Data Access Fault (Local Bus Timeout)",
// OBSOLETE   "\r8??\?-Bug>",		/* The '\?' avoids creating a trigraph */
// OBSOLETE   "\r197-Bug>",
// OBSOLETE   NULL,
// OBSOLETE };
// OBSOLETE 
// OBSOLETE ptid_t
// OBSOLETE bug_wait (ptid_t ptid, struct target_waitstatus *status)
// OBSOLETE {
// OBSOLETE   int old_timeout = sr_get_timeout ();
// OBSOLETE   int old_immediate_quit = immediate_quit;
// OBSOLETE 
// OBSOLETE   status->kind = TARGET_WAITKIND_EXITED;
// OBSOLETE   status->value.integer = 0;
// OBSOLETE 
// OBSOLETE   /* read off leftovers from resume so that the rest can be passed
// OBSOLETE      back out as stdout.  */
// OBSOLETE   if (need_artificial_trap == 0)
// OBSOLETE     {
// OBSOLETE       sr_expect ("Effective address: ");
// OBSOLETE       (void) sr_get_hex_word ();
// OBSOLETE       sr_expect ("\r\n");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   sr_set_timeout (-1);		/* Don't time out -- user program is running. */
// OBSOLETE   immediate_quit = 1;		/* Helps ability to QUIT */
// OBSOLETE 
// OBSOLETE   switch (gr_multi_scan (wait_strings, need_artificial_trap == 0))
// OBSOLETE     {
// OBSOLETE     case 0:			/* breakpoint case */
// OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE       status->value.sig = TARGET_SIGNAL_TRAP;
// OBSOLETE       /* user output from the target can be discarded here. (?) */
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case 1:			/* bus error */
// OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE       status->value.sig = TARGET_SIGNAL_BUS;
// OBSOLETE       /* user output from the target can be discarded here. (?) */
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case 2:			/* normal case */
// OBSOLETE     case 3:
// OBSOLETE       if (need_artificial_trap != 0)
// OBSOLETE 	{
// OBSOLETE 	  /* stepping */
// OBSOLETE 	  status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE 	  status->value.sig = TARGET_SIGNAL_TRAP;
// OBSOLETE 	  need_artificial_trap--;
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* exit case */
// OBSOLETE 	  status->kind = TARGET_WAITKIND_EXITED;
// OBSOLETE 	  status->value.integer = 0;
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE     case -1:			/* trouble */
// OBSOLETE     default:
// OBSOLETE       fprintf_filtered (gdb_stderr,
// OBSOLETE 			"Trouble reading target during wait\n");
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   sr_set_timeout (old_timeout);
// OBSOLETE   immediate_quit = old_immediate_quit;
// OBSOLETE   return inferior_ptid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the name of register number REGNO
// OBSOLETE    in the form input and output by bug.
// OBSOLETE 
// OBSOLETE    Returns a pointer to a static buffer containing the answer.  */
// OBSOLETE static char *
// OBSOLETE get_reg_name (int regno)
// OBSOLETE {
// OBSOLETE   static char *rn[] =
// OBSOLETE   {
// OBSOLETE     "r00", "r01", "r02", "r03", "r04", "r05", "r06", "r07",
// OBSOLETE     "r08", "r09", "r10", "r11", "r12", "r13", "r14", "r15",
// OBSOLETE     "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
// OBSOLETE     "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",
// OBSOLETE 
// OBSOLETE   /* these get confusing because we omit a few and switch some ordering around. */
// OBSOLETE 
// OBSOLETE     "cr01",			/* 32 = psr */
// OBSOLETE     "fcr62",			/* 33 = fpsr */
// OBSOLETE     "fcr63",			/* 34 = fpcr */
// OBSOLETE     "ip",			/* this is something of a cheat. */
// OBSOLETE   /* 35 = sxip */
// OBSOLETE     "cr05",			/* 36 = snip */
// OBSOLETE     "cr06",			/* 37 = sfip */
// OBSOLETE 
// OBSOLETE     "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07",
// OBSOLETE     "x08", "x09", "x10", "x11", "x12", "x13", "x14", "x15",
// OBSOLETE     "x16", "x17", "x18", "x19", "x20", "x21", "x22", "x23",
// OBSOLETE     "x24", "x25", "x26", "x27", "x28", "x29", "x30", "x31",
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE   return rn[regno];
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0				/* not currently used */
// OBSOLETE /* Read from remote while the input matches STRING.  Return zero on
// OBSOLETE    success, -1 on failure.  */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE bug_scan (char *s)
// OBSOLETE {
// OBSOLETE   int c;
// OBSOLETE 
// OBSOLETE   while (*s)
// OBSOLETE     {
// OBSOLETE       c = sr_readchar ();
// OBSOLETE       if (c != *s++)
// OBSOLETE 	{
// OBSOLETE 	  fflush (stdout);
// OBSOLETE 	  printf ("\nNext character is '%c' - %d and s is \"%s\".\n", c, c, --s);
// OBSOLETE 	  return (-1);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE #endif /* never */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE bug_srec_write_cr (char *s)
// OBSOLETE {
// OBSOLETE   char *p = s;
// OBSOLETE 
// OBSOLETE   if (srec_echo_pace)
// OBSOLETE     for (p = s; *p; ++p)
// OBSOLETE       {
// OBSOLETE 	if (sr_get_debug () > 0)
// OBSOLETE 	  printf ("%c", *p);
// OBSOLETE 
// OBSOLETE 	do
// OBSOLETE 	  serial_write (sr_get_desc (), p, 1);
// OBSOLETE 	while (sr_pollchar () != *p);
// OBSOLETE       }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       sr_write_cr (s);
// OBSOLETE /*       return(bug_scan (s) || bug_scan ("\n")); */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store register REGNO, or all if REGNO == -1. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE bug_fetch_register (int regno)
// OBSOLETE {
// OBSOLETE   sr_check_open ();
// OBSOLETE 
// OBSOLETE   if (regno == -1)
// OBSOLETE     {
// OBSOLETE       int i;
// OBSOLETE 
// OBSOLETE       for (i = 0; i < NUM_REGS; ++i)
// OBSOLETE 	bug_fetch_register (i);
// OBSOLETE     }
// OBSOLETE   else if (target_is_m88110 && regno == SFIP_REGNUM)
// OBSOLETE     {
// OBSOLETE       /* m88110 has no sfip. */
// OBSOLETE       long l = 0;
// OBSOLETE       supply_register (regno, (char *) &l);
// OBSOLETE     }
// OBSOLETE   else if (regno < XFP_REGNUM)
// OBSOLETE     {
// OBSOLETE       char buffer[MAX_REGISTER_RAW_SIZE];
// OBSOLETE 
// OBSOLETE       sr_write ("rs ", 3);
// OBSOLETE       sr_write_cr (get_reg_name (regno));
// OBSOLETE       sr_expect ("=");
// OBSOLETE       store_unsigned_integer (buffer, REGISTER_RAW_SIZE (regno),
// OBSOLETE 			      sr_get_hex_word ());
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE       supply_register (regno, buffer);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* Float register so we need to parse a strange data format. */
// OBSOLETE       long p;
// OBSOLETE       unsigned char fpreg_buf[10];
// OBSOLETE 
// OBSOLETE       sr_write ("rs ", 3);
// OBSOLETE       sr_write (get_reg_name (regno), strlen (get_reg_name (regno)));
// OBSOLETE       sr_write_cr (";d");
// OBSOLETE       sr_expect ("rs");
// OBSOLETE       sr_expect (get_reg_name (regno));
// OBSOLETE       sr_expect (";d");
// OBSOLETE       sr_expect ("=");
// OBSOLETE 
// OBSOLETE       /* sign */
// OBSOLETE       p = sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[0] = p << 7;
// OBSOLETE 
// OBSOLETE       /* exponent */
// OBSOLETE       sr_expect ("_");
// OBSOLETE       p = sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[0] += (p << 4);
// OBSOLETE       fpreg_buf[0] += sr_get_hex_digit (1);
// OBSOLETE 
// OBSOLETE       fpreg_buf[1] = sr_get_hex_digit (1) << 4;
// OBSOLETE 
// OBSOLETE       /* fraction */
// OBSOLETE       sr_expect ("_");
// OBSOLETE       fpreg_buf[1] += sr_get_hex_digit (1);
// OBSOLETE 
// OBSOLETE       fpreg_buf[2] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[3] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[4] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[5] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[6] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[7] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
// OBSOLETE       fpreg_buf[8] = 0;
// OBSOLETE       fpreg_buf[9] = 0;
// OBSOLETE 
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE       supply_register (regno, fpreg_buf);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store register REGNO, or all if REGNO == -1. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE bug_store_register (int regno)
// OBSOLETE {
// OBSOLETE   char buffer[1024];
// OBSOLETE   sr_check_open ();
// OBSOLETE 
// OBSOLETE   if (regno == -1)
// OBSOLETE     {
// OBSOLETE       int i;
// OBSOLETE 
// OBSOLETE       for (i = 0; i < NUM_REGS; ++i)
// OBSOLETE 	bug_store_register (i);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       char *regname;
// OBSOLETE 
// OBSOLETE       regname = get_reg_name (regno);
// OBSOLETE 
// OBSOLETE       if (target_is_m88110 && regno == SFIP_REGNUM)
// OBSOLETE 	return;
// OBSOLETE       else if (regno < XFP_REGNUM)
// OBSOLETE 	sprintf (buffer, "rs %s %08lx",
// OBSOLETE 		 regname,
// OBSOLETE 		 (long) read_register (regno));
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  unsigned char *fpreg_buf =
// OBSOLETE 	  (unsigned char *) &registers[REGISTER_BYTE (regno)];
// OBSOLETE 
// OBSOLETE 	  sprintf (buffer, "rs %s %1x_%02x%1x_%1x%02x%02x%02x%02x%02x%02x;d",
// OBSOLETE 		   regname,
// OBSOLETE 	  /* sign */
// OBSOLETE 		   (fpreg_buf[0] >> 7) & 0xf,
// OBSOLETE 	  /* exponent */
// OBSOLETE 		   fpreg_buf[0] & 0x7f,
// OBSOLETE 		   (fpreg_buf[1] >> 8) & 0xf,
// OBSOLETE 	  /* fraction */
// OBSOLETE 		   fpreg_buf[1] & 0xf,
// OBSOLETE 		   fpreg_buf[2],
// OBSOLETE 		   fpreg_buf[3],
// OBSOLETE 		   fpreg_buf[4],
// OBSOLETE 		   fpreg_buf[5],
// OBSOLETE 		   fpreg_buf[6],
// OBSOLETE 		   fpreg_buf[7]);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       sr_write_cr (buffer);
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Transfer LEN bytes between GDB address MYADDR and target address
// OBSOLETE    MEMADDR.  If WRITE is non-zero, transfer them to the target,
// OBSOLETE    otherwise transfer them from the target.  TARGET is unused.
// OBSOLETE 
// OBSOLETE    Returns the number of bytes transferred. */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE bug_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
// OBSOLETE 		 struct mem_attrib *attrib, struct target_ops *target)
// OBSOLETE {
// OBSOLETE   int res;
// OBSOLETE 
// OBSOLETE   if (len <= 0)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   if (write)
// OBSOLETE     res = bug_write_memory (memaddr, myaddr, len);
// OBSOLETE   else
// OBSOLETE     res = bug_read_memory (memaddr, myaddr, len);
// OBSOLETE 
// OBSOLETE   return res;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE start_load (void)
// OBSOLETE {
// OBSOLETE   char *command;
// OBSOLETE 
// OBSOLETE   command = (srec_echo_pace ? "lo 0 ;x" : "lo 0");
// OBSOLETE 
// OBSOLETE   sr_write_cr (command);
// OBSOLETE   sr_expect (command);
// OBSOLETE   sr_expect ("\r\n");
// OBSOLETE   bug_srec_write_cr ("S0030000FC");
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* This is an extremely vulnerable and fragile function.  I've made
// OBSOLETE    considerable attempts to make this deterministic, but I've
// OBSOLETE    certainly forgotten something.  The trouble is that S-records are
// OBSOLETE    only a partial file format, not a protocol.  Worse, apparently the
// OBSOLETE    m88k bug monitor does not run in real time while receiving
// OBSOLETE    S-records.  Hence, we must pay excruciating attention to when and
// OBSOLETE    where error messages are returned, and what has actually been sent.
// OBSOLETE 
// OBSOLETE    Each call represents a chunk of memory to be sent to the target.
// OBSOLETE    We break that chunk into an S0 header record, some number of S3
// OBSOLETE    data records each containing srec_bytes, and an S7 termination
// OBSOLETE    record.  */
// OBSOLETE 
// OBSOLETE static char *srecord_strings[] =
// OBSOLETE {
// OBSOLETE   "S-RECORD",
// OBSOLETE   "-Bug>",
// OBSOLETE   NULL,
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE bug_write_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
// OBSOLETE {
// OBSOLETE   int done;
// OBSOLETE   int checksum;
// OBSOLETE   int x;
// OBSOLETE   int retries;
// OBSOLETE   char *buffer = alloca ((srec_bytes + 8) << 1);
// OBSOLETE 
// OBSOLETE   retries = 0;
// OBSOLETE 
// OBSOLETE   do
// OBSOLETE     {
// OBSOLETE       done = 0;
// OBSOLETE 
// OBSOLETE       if (retries > srec_max_retries)
// OBSOLETE 	return (-1);
// OBSOLETE 
// OBSOLETE       if (retries > 0)
// OBSOLETE 	{
// OBSOLETE 	  if (sr_get_debug () > 0)
// OBSOLETE 	    printf ("\n<retrying...>\n");
// OBSOLETE 
// OBSOLETE 	  /* This gr_expect_prompt call is extremely important.  Without
// OBSOLETE 	     it, we will tend to resend our packet so fast that it
// OBSOLETE 	     will arrive before the bug monitor is ready to receive
// OBSOLETE 	     it.  This would lead to a very ugly resend loop.  */
// OBSOLETE 
// OBSOLETE 	  gr_expect_prompt ();
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       start_load ();
// OBSOLETE 
// OBSOLETE       while (done < len)
// OBSOLETE 	{
// OBSOLETE 	  int thisgo;
// OBSOLETE 	  int idx;
// OBSOLETE 	  char *buf = buffer;
// OBSOLETE 	  CORE_ADDR address;
// OBSOLETE 
// OBSOLETE 	  checksum = 0;
// OBSOLETE 	  thisgo = len - done;
// OBSOLETE 	  if (thisgo > srec_bytes)
// OBSOLETE 	    thisgo = srec_bytes;
// OBSOLETE 
// OBSOLETE 	  address = memaddr + done;
// OBSOLETE 	  sprintf (buf, "S3%02X%08lX", thisgo + 4 + 1, (long) address);
// OBSOLETE 	  buf += 12;
// OBSOLETE 
// OBSOLETE 	  checksum += (thisgo + 4 + 1
// OBSOLETE 		       + (address & 0xff)
// OBSOLETE 		       + ((address >> 8) & 0xff)
// OBSOLETE 		       + ((address >> 16) & 0xff)
// OBSOLETE 		       + ((address >> 24) & 0xff));
// OBSOLETE 
// OBSOLETE 	  for (idx = 0; idx < thisgo; idx++)
// OBSOLETE 	    {
// OBSOLETE 	      sprintf (buf, "%02X", myaddr[idx + done]);
// OBSOLETE 	      checksum += myaddr[idx + done];
// OBSOLETE 	      buf += 2;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  if (srec_noise > 0)
// OBSOLETE 	    {
// OBSOLETE 	      /* FIXME-NOW: insert a deliberate error every now and then.
// OBSOLETE 	         This is intended for testing/debugging the error handling
// OBSOLETE 	         stuff.  */
// OBSOLETE 	      static int counter = 0;
// OBSOLETE 	      if (++counter > srec_noise)
// OBSOLETE 		{
// OBSOLETE 		  counter = 0;
// OBSOLETE 		  ++checksum;
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  sprintf (buf, "%02X", ~checksum & 0xff);
// OBSOLETE 	  bug_srec_write_cr (buffer);
// OBSOLETE 
// OBSOLETE 	  if (srec_sleep != 0)
// OBSOLETE 	    sleep (srec_sleep);
// OBSOLETE 
// OBSOLETE 	  /* This pollchar is probably redundant to the gr_multi_scan
// OBSOLETE 	     below.  Trouble is, we can't be sure when or where an
// OBSOLETE 	     error message will appear.  Apparently, when running at
// OBSOLETE 	     full speed from a typical sun4, error messages tend to
// OBSOLETE 	     appear to arrive only *after* the s7 record.   */
// OBSOLETE 
// OBSOLETE 	  if ((x = sr_pollchar ()) != 0)
// OBSOLETE 	    {
// OBSOLETE 	      if (sr_get_debug () > 0)
// OBSOLETE 		printf ("\n<retrying...>\n");
// OBSOLETE 
// OBSOLETE 	      ++retries;
// OBSOLETE 
// OBSOLETE 	      /* flush any remaining input and verify that we are back
// OBSOLETE 	         at the prompt level. */
// OBSOLETE 	      gr_expect_prompt ();
// OBSOLETE 	      /* start all over again. */
// OBSOLETE 	      start_load ();
// OBSOLETE 	      done = 0;
// OBSOLETE 	      continue;
// OBSOLETE 	    }
// OBSOLETE 
// OBSOLETE 	  done += thisgo;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       bug_srec_write_cr ("S7060000000000F9");
// OBSOLETE       ++retries;
// OBSOLETE 
// OBSOLETE       /* Having finished the load, we need to figure out whether we
// OBSOLETE          had any errors.  */
// OBSOLETE     }
// OBSOLETE   while (gr_multi_scan (srecord_strings, 0) == 0);;
// OBSOLETE 
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Copy LEN bytes of data from debugger memory at MYADDR
// OBSOLETE    to inferior's memory at MEMADDR.  Returns errno value.
// OBSOLETE    * sb/sh instructions don't work on unaligned addresses, when TU=1.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE /* Read LEN bytes from inferior memory at MEMADDR.  Put the result
// OBSOLETE    at debugger address MYADDR.  Returns errno value.  */
// OBSOLETE static int
// OBSOLETE bug_read_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
// OBSOLETE {
// OBSOLETE   char request[100];
// OBSOLETE   char *buffer;
// OBSOLETE   char *p;
// OBSOLETE   char type;
// OBSOLETE   char size;
// OBSOLETE   unsigned char c;
// OBSOLETE   unsigned int inaddr;
// OBSOLETE   unsigned int checksum;
// OBSOLETE 
// OBSOLETE   sprintf (request, "du 0 %lx:&%d", (long) memaddr, len);
// OBSOLETE   sr_write_cr (request);
// OBSOLETE 
// OBSOLETE   p = buffer = alloca (len);
// OBSOLETE 
// OBSOLETE   /* scan up through the header */
// OBSOLETE   sr_expect ("S0030000FC");
// OBSOLETE 
// OBSOLETE   while (p < buffer + len)
// OBSOLETE     {
// OBSOLETE       /* scan off any white space. */
// OBSOLETE       while (sr_readchar () != 'S');;
// OBSOLETE 
// OBSOLETE       /* what kind of s-rec? */
// OBSOLETE       type = sr_readchar ();
// OBSOLETE 
// OBSOLETE       /* scan record size */
// OBSOLETE       sr_get_hex_byte (&size);
// OBSOLETE       checksum = size;
// OBSOLETE       --size;
// OBSOLETE       inaddr = 0;
// OBSOLETE 
// OBSOLETE       switch (type)
// OBSOLETE 	{
// OBSOLETE 	case '7':
// OBSOLETE 	case '8':
// OBSOLETE 	case '9':
// OBSOLETE 	  goto done;
// OBSOLETE 
// OBSOLETE 	case '3':
// OBSOLETE 	  sr_get_hex_byte (&c);
// OBSOLETE 	  inaddr = (inaddr << 8) + c;
// OBSOLETE 	  checksum += c;
// OBSOLETE 	  --size;
// OBSOLETE 	  /* intentional fall through */
// OBSOLETE 	case '2':
// OBSOLETE 	  sr_get_hex_byte (&c);
// OBSOLETE 	  inaddr = (inaddr << 8) + c;
// OBSOLETE 	  checksum += c;
// OBSOLETE 	  --size;
// OBSOLETE 	  /* intentional fall through */
// OBSOLETE 	case '1':
// OBSOLETE 	  sr_get_hex_byte (&c);
// OBSOLETE 	  inaddr = (inaddr << 8) + c;
// OBSOLETE 	  checksum += c;
// OBSOLETE 	  --size;
// OBSOLETE 	  sr_get_hex_byte (&c);
// OBSOLETE 	  inaddr = (inaddr << 8) + c;
// OBSOLETE 	  checksum += c;
// OBSOLETE 	  --size;
// OBSOLETE 	  break;
// OBSOLETE 
// OBSOLETE 	default:
// OBSOLETE 	  /* bonk */
// OBSOLETE 	  error ("reading s-records.");
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (inaddr < memaddr
// OBSOLETE 	  || (memaddr + len) < (inaddr + size))
// OBSOLETE 	error ("srec out of memory range.");
// OBSOLETE 
// OBSOLETE       if (p != buffer + inaddr - memaddr)
// OBSOLETE 	error ("srec out of sequence.");
// OBSOLETE 
// OBSOLETE       for (; size; --size, ++p)
// OBSOLETE 	{
// OBSOLETE 	  sr_get_hex_byte (p);
// OBSOLETE 	  checksum += *p;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       sr_get_hex_byte (&c);
// OBSOLETE       if (c != (~checksum & 0xff))
// OBSOLETE 	error ("bad s-rec checksum");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE done:
// OBSOLETE   gr_expect_prompt ();
// OBSOLETE   if (p != buffer + len)
// OBSOLETE     return (1);
// OBSOLETE 
// OBSOLETE   memcpy (myaddr, buffer, len);
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #define MAX_BREAKS	16
// OBSOLETE static int num_brkpts = 0;
// OBSOLETE 
// OBSOLETE /* Insert a breakpoint at ADDR.  SAVE is normally the address of the
// OBSOLETE    pattern buffer where the instruction that the breakpoint overwrites
// OBSOLETE    is saved.  It is unused here since the bug is responsible for
// OBSOLETE    saving/restoring the original instruction. */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE bug_insert_breakpoint (CORE_ADDR addr, char *save)
// OBSOLETE {
// OBSOLETE   sr_check_open ();
// OBSOLETE 
// OBSOLETE   if (num_brkpts < MAX_BREAKS)
// OBSOLETE     {
// OBSOLETE       char buffer[100];
// OBSOLETE 
// OBSOLETE       num_brkpts++;
// OBSOLETE       sprintf (buffer, "br %lx", (long) addr);
// OBSOLETE       sr_write_cr (buffer);
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE       return (0);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       fprintf_filtered (gdb_stderr,
// OBSOLETE 		      "Too many break points, break point not installed\n");
// OBSOLETE       return (1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Remove a breakpoint at ADDR.  SAVE is normally the previously
// OBSOLETE    saved pattern, but is unused here since the bug is responsible
// OBSOLETE    for saving/restoring instructions. */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE bug_remove_breakpoint (CORE_ADDR addr, char *save)
// OBSOLETE {
// OBSOLETE   if (num_brkpts > 0)
// OBSOLETE     {
// OBSOLETE       char buffer[100];
// OBSOLETE 
// OBSOLETE       num_brkpts--;
// OBSOLETE       sprintf (buffer, "nobr %lx", (long) addr);
// OBSOLETE       sr_write_cr (buffer);
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE 
// OBSOLETE     }
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Clear the bugs notion of what the break points are */
// OBSOLETE static int
// OBSOLETE bug_clear_breakpoints (void)
// OBSOLETE {
// OBSOLETE 
// OBSOLETE   if (sr_is_open ())
// OBSOLETE     {
// OBSOLETE       sr_write_cr ("nobr");
// OBSOLETE       sr_expect ("nobr");
// OBSOLETE       gr_expect_prompt ();
// OBSOLETE     }
// OBSOLETE   num_brkpts = 0;
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE struct target_ops bug_ops;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_bug_ops (void)
// OBSOLETE {
// OBSOLETE   bug_ops.to_shortname = "bug";
// OBSOLETE   "Remote BUG monitor",
// OBSOLETE     bug_ops.to_longname = "Use the mvme187 board running the BUG monitor connected by a serial line.";
// OBSOLETE   bug_ops.to_doc = " ";
// OBSOLETE   bug_ops.to_open = bug_open;
// OBSOLETE   bug_ops.to_close = gr_close;
// OBSOLETE   bug_ops.to_attach = 0;
// OBSOLETE   bug_ops.to_post_attach = NULL;
// OBSOLETE   bug_ops.to_require_attach = NULL;
// OBSOLETE   bug_ops.to_detach = gr_detach;
// OBSOLETE   bug_ops.to_require_detach = NULL;
// OBSOLETE   bug_ops.to_resume = bug_resume;
// OBSOLETE   bug_ops.to_wait = bug_wait;
// OBSOLETE   bug_ops.to_post_wait = NULL;
// OBSOLETE   bug_ops.to_fetch_registers = bug_fetch_register;
// OBSOLETE   bug_ops.to_store_registers = bug_store_register;
// OBSOLETE   bug_ops.to_prepare_to_store = gr_prepare_to_store;
// OBSOLETE   bug_ops.to_xfer_memory = bug_xfer_memory;
// OBSOLETE   bug_ops.to_files_info = gr_files_info;
// OBSOLETE   bug_ops.to_insert_breakpoint = bug_insert_breakpoint;
// OBSOLETE   bug_ops.to_remove_breakpoint = bug_remove_breakpoint;
// OBSOLETE   bug_ops.to_terminal_init = 0;
// OBSOLETE   bug_ops.to_terminal_inferior = 0;
// OBSOLETE   bug_ops.to_terminal_ours_for_output = 0;
// OBSOLETE   bug_ops.to_terminal_ours = 0;
// OBSOLETE   bug_ops.to_terminal_info = 0;
// OBSOLETE   bug_ops.to_kill = gr_kill;
// OBSOLETE   bug_ops.to_load = bug_load;
// OBSOLETE   bug_ops.to_lookup_symbol = 0;
// OBSOLETE   bug_ops.to_create_inferior = gr_create_inferior;
// OBSOLETE   bug_ops.to_post_startup_inferior = NULL;
// OBSOLETE   bug_ops.to_acknowledge_created_inferior = NULL;
// OBSOLETE   bug_ops.to_clone_and_follow_inferior = NULL;
// OBSOLETE   bug_ops.to_post_follow_inferior_by_clone = NULL;
// OBSOLETE   bug_ops.to_insert_fork_catchpoint = NULL;
// OBSOLETE   bug_ops.to_remove_fork_catchpoint = NULL;
// OBSOLETE   bug_ops.to_insert_vfork_catchpoint = NULL;
// OBSOLETE   bug_ops.to_remove_vfork_catchpoint = NULL;
// OBSOLETE   bug_ops.to_has_forked = NULL;
// OBSOLETE   bug_ops.to_has_vforked = NULL;
// OBSOLETE   bug_ops.to_can_follow_vfork_prior_to_exec = NULL;
// OBSOLETE   bug_ops.to_post_follow_vfork = NULL;
// OBSOLETE   bug_ops.to_insert_exec_catchpoint = NULL;
// OBSOLETE   bug_ops.to_remove_exec_catchpoint = NULL;
// OBSOLETE   bug_ops.to_has_execd = NULL;
// OBSOLETE   bug_ops.to_reported_exec_events_per_exec_call = NULL;
// OBSOLETE   bug_ops.to_has_exited = NULL;
// OBSOLETE   bug_ops.to_mourn_inferior = gr_mourn;
// OBSOLETE   bug_ops.to_can_run = 0;
// OBSOLETE   bug_ops.to_notice_signals = 0;
// OBSOLETE   bug_ops.to_thread_alive = 0;
// OBSOLETE   bug_ops.to_stop = 0;
// OBSOLETE   bug_ops.to_pid_to_exec_file = NULL;
// OBSOLETE   bug_ops.to_stratum = process_stratum;
// OBSOLETE   bug_ops.DONT_USE = 0;
// OBSOLETE   bug_ops.to_has_all_memory = 1;
// OBSOLETE   bug_ops.to_has_memory = 1;
// OBSOLETE   bug_ops.to_has_stack = 1;
// OBSOLETE   bug_ops.to_has_registers = 0;
// OBSOLETE   bug_ops.to_has_execution = 0;
// OBSOLETE   bug_ops.to_sections = 0;
// OBSOLETE   bug_ops.to_sections_end = 0;
// OBSOLETE   bug_ops.to_magic = OPS_MAGIC;	/* Always the last thing */
// OBSOLETE }				/* init_bug_ops */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_remote_bug (void)
// OBSOLETE {
// OBSOLETE   init_bug_ops ();
// OBSOLETE   add_target (&bug_ops);
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("srec-bytes", class_support, var_uinteger,
// OBSOLETE 		  (char *) &srec_bytes,
// OBSOLETE 		  "\
// OBSOLETE Set the number of bytes represented in each S-record.\n\
// OBSOLETE This affects the communication protocol with the remote target.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("srec-max-retries", class_support, var_uinteger,
// OBSOLETE 		  (char *) &srec_max_retries,
// OBSOLETE 		  "\
// OBSOLETE Set the number of retries for shipping S-records.\n\
// OBSOLETE This affects the communication protocol with the remote target.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE   /* This needs to set SREC_SIZE, not srec_frame which gets changed at the
// OBSOLETE      end of a download.  But do we need the option at all?  */
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("srec-frame", class_support, var_uinteger,
// OBSOLETE 		  (char *) &srec_frame,
// OBSOLETE 		  "\
// OBSOLETE Set the number of bytes in an S-record frame.\n\
// OBSOLETE This affects the communication protocol with the remote target.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE #endif /* 0 */
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("srec-noise", class_support, var_zinteger,
// OBSOLETE 		  (char *) &srec_noise,
// OBSOLETE 		  "\
// OBSOLETE Set number of S-record to send before deliberately flubbing a checksum.\n\
// OBSOLETE Zero means flub none at all.  This affects the communication protocol\n\
// OBSOLETE with the remote target.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("srec-sleep", class_support, var_zinteger,
// OBSOLETE 		  (char *) &srec_sleep,
// OBSOLETE 		  "\
// OBSOLETE Set number of seconds to sleep after an S-record for a possible error message to arrive.\n\
// OBSOLETE This affects the communication protocol with the remote target.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("srec-echo-pace", class_support, var_boolean,
// OBSOLETE 		  (char *) &srec_echo_pace,
// OBSOLETE 		  "\
// OBSOLETE Set echo-verification.\n\
// OBSOLETE When on, use verification by echo when downloading S-records.  This is\n\
// OBSOLETE much slower, but generally more reliable.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE }
@


1.20
log
@* serial.h (SERIAL_ASYNC): Delete.
(DEPRECATED_SERIAL_FD): Delete.
(SERIAL_DEBUG): Delete.
(SERIAL_DEBUG_P): Delete.
(SERIAL_DRAIN_OUTPUT): Delete.
(SERIAL_FLUSH_OUTPUT): Delete.
(SERIAL_FLUSH_INPUT): Delete.
(SERIAL_SEND_BREAK): Delete.
(SERIAL_RAW): Delete.
(SERIAL_GET_TTY_STATE): Delete.
(SERIAL_SET_TTY_STATE): Delete.
(SERIAL_PRINT_TTY_STATE): Delete.
(SERIAL_NOFLUSH_SET_TTY_STATE): Delete.
(SERIAL_SETBAUDRATE): Delete.
(SERIAL_SETSTOPBITS): Delete.
(SERIAL_CAN_ASYNC_P): Delete.
(SERIAL_IS_ASYNC_P): Delete.
(SERIAL_UN_FDOPEN): Delete.
(SERIAL_READCHAR): Delete.
(SERIAL_CLOSE): Delete.
(SERIAL_FDOPEN): Delete.
(SERIAL_OPEN): Delete.
@
text
@d4 3
a6 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d556 1
a556 2
		 struct mem_attrib *attrib ATTRIBUTE_UNUSED,
		 struct target_ops *target ATTRIBUTE_UNUSED)
@


1.19
log
@m88k builds.  Tweek remote-bug.c to include "serial.h".
@
text
@d401 1
a401 1
	  SERIAL_WRITE (sr_get_desc (), p, 1);
@


1.18
log
@Phase 1 of the ptid_t changes.
@
text
@d38 1
@


1.17
log
@* target.h (target_ops): Removed to_core_file_to_sym_file vector
function.
* corelow.c (core_ops): Updated for above change.
* gnu-nat.c (core_ops): Likewise.
* inftarg.c (child_ops): Likewise.
* monitor.c (monitor_ops): Likewise.
* ppc-bdm.c (bdm_ppc_ops): Likewise.
* remote-adapt.c (adapt_ops): Likewise.
* remote-bug.c (bug_ops): Likewise.
* remote-e7000.c (e7000_ops): Likewise.
* remote-eb.c (eb_ops): Likewise.
* remote-es.c (es1800_ops, es1800_child_ops): Likewise.
* remote-mm.c (mm_ops): Likewise.
* remote-nindy.c (nindy_ops): Likewise.
* remote-nrom.c (nrom_ops): Likewise.
* remote-os9k.c (rombug_ops): Likewise.
* remote-rdp.c (remote_rdp_ops): Likewise.
* remote-sim.c (gdbsim_ops): Likewise.
* remote-st.c (st2000_ops): Likewise.
* v850ice.c (v850ice_ops): Likewise.
* target.c (cleanup_target): Likewise
(update_current_target): Likewise.
(setup_target_debug): Likewise
(debug_to_core_file_to_sym_file): Removed.

* corefile.c (core_file_command) [HPUXHPPA]: Removed code that
sets symbol file from information obtained from the core file.
* corelow.c (core_file_to_sym_file): Removed.
@
text
@d118 1
a118 1
  inferior_pid = 0;
d235 1
a235 1
bug_resume (int pid, int step, enum target_signal sig)
d264 2
a265 2
int
bug_wait (int pid, struct target_waitstatus *status)
d328 1
a328 1
  return 0;
@


1.16
log
@Make --target=m88k buildable again.
@
text
@a948 1
  bug_ops.to_core_file_to_sym_file = NULL;
@


1.15
log
@Update/correct copyright notices.
@
text
@a39 3

extern int sleep ();

d142 1
a142 1
	  printf_filtered ("%s\t: 0x%4x .. 0x%4x  ", s->name, s->vma, s->vma + s->_raw_size);
d514 1
a514 1
	sprintf (buffer, "rs %s %08x",
d516 1
a516 1
		 read_register (regno));
d650 1
a650 1
	  sprintf (buf, "S3%02X%08X", thisgo + 4 + 1, address);
d740 1
a740 1
  sprintf (request, "du 0 %x:&%d", memaddr, len);
d842 1
a842 1
      sprintf (buffer, "br %x", addr);
d868 1
a868 1
      sprintf (buffer, "nobr %x", addr);
@


1.14
log
@Create new file regcache.h.  Update all uses.
@
text
@d4 2
a5 1
   Copyright 1992, 1993, 2001 Free Software Foundation, Inc.
@


1.13
log
@Replace calls to abort() with calls to internal_error().
@
text
@d27 1
@


1.12
log
@* ppc-bdm.c (#include <signal.h>): Removed.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-mips.c: Likewise.
* remote-os9k.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
@
text
@d229 1
a229 1
      abort ();
@


1.11
log
@* monitor.c (#include "gdb_wait.h"): Removed.
* ocd.c: Likewise.
* ppc-bdm.c: Likewise.
* remote-adapt.c: Likewise.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-eb.c: Likewise.
* remote-es.c: Likewise.
* remote-mips.c: Likewise.
* remote-mm.c: Likewise.
* remote-nindy.c: Likewise.
* remote-os9k.c: Likewise.
* remote-rdi.c: Likewise.
* remote-rdp.c: Likewise.
* remote-sds.c: Likewise.
* remote-sim.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
* remote.c: Likewise.
* ser-pipe.c: Likewise.
* ser-unix.c: Likewise.
* Makefile.in: Updated dependencies.
-------------------------------------------------------------------
@
text
@a28 1
#include <signal.h>
@


1.10
log
@* exec.c (xfer_memory): Add attrib argument.
* infptrace.c (child_xfer_memory): Likewise.
* monitor.c (monitor_xfer_memory): Likewise.
* remote-adapt.c (adapt_xfer_inferior_memory): Likewise.
* remote-array.c (array_xfer_memory): Likewise.
* remote-bug.c (bug_xfer_memory): Likewise.
* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
* remote-eb.c (eb_xfer_inferior_memory): Likewise.
* remote-es.c (es1800_xfer_inferior_memory): Likewise.
* remote-mips.c (mips_xfer_memory): Likewise.
* remote-mm.c (mm_xfer_inferior_memory): Likewise.
* remote-nindy.c (nindy_xfer_inferior_memory): Likewise.
* remote-os9k.c (rombug_xfer_inferior_memory): Likewise.
* remote-rdi.c (arm_rdi_xfer_memory): Likewise.
* remote-rdp.c (remote_rdp_xfer_inferior_memory): Likewise.
* remote-sds.c (sds_xfer_memory): Likewise.
* remote-sim.c (gdbsim_xfer_inferior_memory): Likewise.
* remote-st.c (st2000_xfer_inferior_memory): Likewise.
* remote-udi.c (udi_xfer_inferior_memory): Likewise.
* remote-vx.c (vx_xfer_memory): Likewise.
* remote.c (remote_xfer_memory): Likewise.
* target.c (debug_to_xfer_memory, do_xfer_memory): Likewise.
* target.h (child_xfer_memory, do_xfer_memory, xfer_memory): Likewise.

* target.h (#include "memattr.h"): Added.
(target_ops.to_xfer_memory): Add attrib argument.

* wince.c (_initialize_inftarg): Removed call to set_dcache_state.
* dcache.h (set_dcache_state): Removed declaration.
* dcache.c (set_dcache_state): Removed definition

* dcache.c: Update module comment, as dcache is now enabled and
disabled with memory region attributes instead of by the global
variable "remotecache".  Add comment describing the interaction
between dcache and memory region attributes.
(dcache_xfer_memory): Add comment describing benefits of moving
cache writeback to a higher level.
(dcache_struct): Removed cache_has_stuff field.  This was used to
record whether the cache had been accessed in order to invalidate
it when it was disabled.  However, this is not needed because the
cache is write through and the code that enables, disables, and
deletes memory regions invalidate the cache.  Add comment which
suggests that we could be more selective and only invalidate those
cache lines containing data from those memory regions.
(dcache_invalidate): Updated.
(dcache_xfer_memory): Updated.

(dcache_alloc): Don't abort() if dcache_enabled_p is clear.
(dcache_xfer_memory): Removed code that called do_xfer_memory() to
perform a uncached transfer if dcache_enabled_p was clear.  This
function is now only called if caching is enabled for the memory
region.
(dcache_info): Always print cache info.

* target.c (do_xfer_memory): Add attrib argument.
(target_xfer_memory, target_xfer_memory_partial): Break transfer
into chunks defined by memory regions, pass region attributes to
do_xfer_memory().
* dcache.c (dcache_read_line, dcache_write_line): Likewise.

* Makefile.in (SFILES): Add memattr.c.
(COMMON_OBS): Add memattr.o.
(dcache.o): Add target.h to dependencies.
* memattr.c: New file.
* memattr.h: Likewise.
@
text
@a25 2
#include "gdb_wait.h"

@


1.9
log
@Replace free() with xfree().
@
text
@d4 1
a4 1
   Copyright 1992, 1993 Free Software Foundation, Inc.
d558 2
a559 1
		 struct target_ops *target)
@


1.8
log
@* TODO: Note abstraction layer violation where "ocd reset" command
must invalidate the dcache, and how this might be fixed.

* monitor.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(monitor_open): Removed code that created local dcache.
(flush_monitor_dcache): Removed (unused function).
(monitor_resume): Removed call to dcache_invd().
(monitor_load): Likewise.
(monitor_xfer_memory): Changed to call monitor_write_memory(),
monitor_write_memory_block(), and monitor_read_memory() instead
of dcache_xfer_memory().
* monitor.h (flush_monitor_dcache): Removed (unused function).
* ocd.c (#include "dcache.h"): Removed.
(ocd_dcache): Removed.
(ocd_open): Removed code that created local dcache.
(ocd_resume): Removed call to dcache_invd().
(ocd_xfer_memory): Changed to call ocd_write_bytes() and
ocd_read_bytes() instead of dcache_xfer_memory().
(bdm_reset_command): Invalidate target dcache.
* remote-bug.c (bug_load): Remove call to dcache_invd().
(bug_resume): Likewise.
(bug_settings): Remove dcache, readfunc, and writefunc fields
from initializer.
(bug_xfer_memory): Changed to call bug_read_memory() and
bug_write_memory() instead of dcache_xfer_memory().
* remote-nindy.c (#include "dcache.h"): Removed.
(nindy_dcache): Removed.
(nindy_open): Removed code that created local dcache.
(nindy_resume): Removed call to dcache_invd().
(nindy_load): Likewise.
(nindy_xfer_inferior_memory): Changed to call ninMemPut() and
ninMemGet() instead of dcache_xfer_memory().
* remote-sds.c (#include "dcache.h"): Removed.
(sds_dcache): Removed.
(sds_open): Removed code that created local dcache.
(sds_resume): Removed call to dcache_invd().
(sds_xfer_memory): Changed to call sds_write_bytes() and
sds_read_bytes() instead of dcache_xfer_memory().
* remote-utils.c (gr_open): Removed code that created local dcache.
* remote-utils.h (#include "dcache.h"): Removed.
(struct gr_settings): Removed dcache, readfunc, and writefunc fields.
(gr_get_dcache, gr_set_dcache): Removed macro definitions.
* remote.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(remote_open_1): Removed code that created local dcache.
(remote_async_open_1): Likewise.
(remote_resume): Removed call to dcache_invd().
(remote_async_resume): Likewise.
(remote_xfer_memory): Changed to call remote_write_bytes() and
remote_read_bytes() instead of dcache_xfer_memory().
* wince.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(child_create_inferior): Removed code that created local dcache.
(child_xfer_memory): Changed to call remote_write_bytes() and
remote_read_bytes() instead of dcache_xfer_memory().
(child_resume): Removed call to dcache_invd().

* target.c (target_dcache): Added.
(target_load): Invalidate target_dcache.
(do_xfer_memory): New function.
(target_xfer_memory): Reimplement in terms of dcache_xfer_memory().
(target_xfer_memory_partial): Likewise.
(initialize_targets): Create target_dcache.
* target.h (#include "dcache.h"): Added.
(target_open): Invalidate target_dcache.
(target_resume): Likewise.
(do_xfer_memory): New declaration.

* dcache.c (dcache_init): Removed reading and writing arguments.
(dcache_struct): Removed read_memory and write_memory fields.
(dcache_write_line): Call do_xfer_memory.
(dcache_read_line): Likewise.
(dcache_xfer_memory): Likewise.
(dcache_invalidate): Renamed from dcache_invd.
(dcache_init): Updated.
(dcache_xfer_memory): Updated.
* dcache.h (memxferfunc): Removed definition.
@
text
@d159 1
a159 1
	  free (buffer);
@


1.7
log
@Protoization.
@
text
@a121 1
  dcache_invd (gr_get_dcache ());
a199 1
  NULL,				/* dcache */
a202 2
  bug_read_memory,		/* readfunc */
  bug_write_memory,		/* writefunc */
a240 2
  dcache_invd (gr_get_dcache ());

d560 2
d565 6
a570 1
  return dcache_xfer_memory (gr_get_dcache (), memaddr, myaddr, len, write);
@


1.6
log
@* MAINTAINERS: Add myself as dcache.c maintainer.

* remote-nindy.c (nindy_load): Invalidate dcache.

* dcache.c (dcache_invd): Renamed from dcache_flush.  The term
flush with respect to caches usually implies that data will be
written to memory.
(dcache_init, dcache_xfer_memory): Updated.
* monitor.c (flush_monitor_dcache, monitor_resume, monitor_load):
Updated.
* ocd.c (ocd_open, ocd_resume, bdm_reset_command): Updated.
* remote-bug.c (bug_load, bug_resume): Updated.
* remote-nindy.c (nindy_open, nindy_resume): Updated.
* remote-sds.c (sds_open, sds_resume): Updated.
* remote-utils.c (gr_open): Updated.
* remote.c (remote_open_1, remote_resume, remote_async_resume,
remote_cisco_open): Updated.
* wince.c (child_create_inferior, child_resume): Updated.

* monitor.c (monitor_open): Free dcache before creating a new one.
* dcache.c (dcache_free): New function.
* dcache.h (dcache_free): New prototype.
-------------------------------------------------------------------
@
text
@d556 6
d563 2
a564 6
bug_xfer_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *target;	/* ignored */
d828 6
d835 1
a835 3
bug_insert_breakpoint (addr, save)
     CORE_ADDR addr;
     char *save;		/* Throw away, let bug save instructions */
d857 5
d863 1
a863 3
bug_remove_breakpoint (addr, save)
     CORE_ADDR addr;
     char *save;		/* Throw away, let bug save instructions */
@


1.5
log
@Protoization.
@
text
@d122 1
a122 1
  dcache_flush (gr_get_dcache ());
d245 1
a245 1
  dcache_flush (gr_get_dcache ());
@


1.4
log
@* remote-nindy.c (nindy_fetch_word, nindy_store_word): Removed
(nindy_xfer_inferior_memory): Use dcache_xfer_memory() instead of
breaking transfer into chunks and using nindy_fetch_word() and
nindy_store_word().

* remote-bug.c (bug_xfer_memory): Use dcache_xfer_memory() instead
of breaking transfer into chunks and using gr_fetch_word() and
gr_store_word().

* remote.c (remote_fetch_word, remote_store_word): Removed.

* remote-utils.h (gr_fetch_word, gr_store_word): Removed.
* remote-utils.c (gr_fetch_word, gr_store_word): Removed.

* dcache.h (dcache_fetch, dcache_poke, dcache_poke_block): Removed.
* dcache.c (dcache_fetch, dcache_poke): Removed.
@
text
@d114 1
a114 3
bug_load (args, fromtty)
     char *args;
     int fromtty;
d171 1
a171 2
get_word (p)
     char **p;
d217 1
a217 3
bug_open (args, from_tty)
     char *args;
     int from_tty;
d243 1
a243 3
bug_resume (pid, step, sig)
     int pid, step;
     enum target_signal sig;
d275 1
a275 3
bug_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d346 1
a346 2
get_reg_name (regno)
     int regno;
d379 1
a379 2
bug_scan (s)
     char *s;
d399 1
a399 2
bug_srec_write_cr (s)
     char *s;
d425 1
a425 2
bug_fetch_register (regno)
     int regno;
d503 1
a503 2
bug_store_register (regno)
     int regno;
d571 1
a571 1
start_load ()
d605 1
a605 4
bug_write_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
d729 1
a729 4
bug_read_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
d871 1
a871 1
bug_clear_breakpoints ()
d956 1
a956 1
_initialize_remote_bug ()
@


1.3
log
@PARAMS removal.
@
text
@d578 2
a579 1
  register int i;
d581 1
a581 67
  /* Round starting address down to longword boundary.  */
  register CORE_ADDR addr;

  /* Round ending address up; get number of longwords that makes.  */
  register int count;

  /* Allocate buffer of that many longwords.  */
  register int *buffer;

  addr = memaddr & -sizeof (int);
  count = (((memaddr + len) - addr) + sizeof (int) - 1) / sizeof (int);

  buffer = (int *) alloca (count * sizeof (int));

  if (write)
    {
      /* Fill start and end extra bytes of buffer with existing memory data.  */

      if (addr != memaddr || len < (int) sizeof (int))
	{
	  /* Need part of initial word -- fetch it.  */
	  buffer[0] = gr_fetch_word (addr);
	}

      if (count > 1)		/* FIXME, avoid if even boundary */
	{
	  buffer[count - 1]
	    = gr_fetch_word (addr + (count - 1) * sizeof (int));
	}

      /* Copy data to be written over corresponding part of buffer */

      memcpy ((char *) buffer + (memaddr & (sizeof (int) - 1)), myaddr, len);

      /* Write the entire buffer.  */

      for (i = 0; i < count; i++, addr += sizeof (int))
	{
	  errno = 0;
	  gr_store_word (addr, buffer[i]);
	  if (errno)
	    {

	      return 0;
	    }

	}
    }
  else
    {
      /* Read all the longwords */
      for (i = 0; i < count; i++, addr += sizeof (int))
	{
	  errno = 0;
	  buffer[i] = gr_fetch_word (addr);
	  if (errno)
	    {
	      return 0;
	    }
	  QUIT;
	}

      /* Copy appropriate bytes out of the buffer.  */
      memcpy (myaddr, (char *) buffer + (memaddr & (sizeof (int) - 1)), len);
    }

  return len;
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d51 1
a51 1
static int bug_clear_breakpoints PARAMS ((void));
d53 2
a54 3
static int bug_read_memory PARAMS ((CORE_ADDR memaddr,
				    unsigned char *myaddr,
				    int len));
d56 2
a57 3
static int bug_write_memory PARAMS ((CORE_ADDR memaddr,
				     unsigned char *myaddr,
				     int len));
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
This file is part of GDB.
d9 14
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d26 1
a26 1
#include "wait.h"
d42 1
a42 1
extern int sleep();
d51 1
a51 1
static int bug_clear_breakpoints PARAMS((void));
d53 7
a59 7
static int bug_read_memory PARAMS((CORE_ADDR memaddr,
					    unsigned char *myaddr,
					    int len));

static int bug_write_memory PARAMS((CORE_ADDR memaddr,
					     unsigned char *myaddr,
					     int len));
d126 1
a126 1
  dcache_flush (gr_get_dcache());
d204 9
a212 8
static struct gr_settings bug_settings = {
  NULL,	/* dcache */
  "Bug>", /* prompt */
  &bug_ops, /* ops */
  bug_clear_breakpoints, /* clear_all_breakpoints */
  bug_read_memory, /* readfunc */
  bug_write_memory, /* writefunc */
  gr_generic_checkin, /* checkin */
d215 2
a216 1
static char *cpu_check_strings[] = {
d227 1
a227 1
      args = "";
d229 1
a229 1
  gr_open(args, from_tty, &bug_settings);
d231 2
a232 2
  sr_write_cr("rs cr06");
  sr_expect("rs cr06");
d234 1
a234 1
  switch (gr_multi_scan(cpu_check_strings, 0))
d236 1
a236 1
    case 0: /* this is an m88100 */
d239 1
a239 1
    case 1: /* this is an m88110 */
d243 1
a243 1
      abort();
d254 1
a254 1
  dcache_flush (gr_get_dcache());
d258 1
a258 1
      sr_write_cr("t");
d261 2
a262 2
       about I/O from the target means that the user has to type
       "continue" to see any.  FIXME, this should be fixed.  */
d266 1
a266 1
      sr_write_cr ("g");
d274 2
a275 1
static char *wait_strings[] = {
d278 1
a278 1
  "\r8??\?-Bug>",	/* The '\?' avoids creating a trigraph */
d288 1
a288 1
  int old_timeout = sr_get_timeout();
d298 2
a299 2
      sr_expect("Effective address: ");
      (void) sr_get_hex_word();
d303 2
a304 2
  sr_set_timeout(-1); /* Don't time out -- user program is running. */
  immediate_quit = 1; /* Helps ability to QUIT */
d306 1
a306 1
  switch (gr_multi_scan(wait_strings, need_artificial_trap == 0))
d308 1
a308 1
    case 0: /* breakpoint case */
d312 1
a312 1
      gr_expect_prompt();
d315 1
a315 1
    case 1: /* bus error */
d319 1
a319 1
      gr_expect_prompt();
d322 1
a322 1
    case 2: /* normal case */
d340 1
a340 1
    case -1: /* trouble */
d347 1
a347 1
  sr_set_timeout(old_timeout);
d360 2
a361 1
  static char *rn[] = {
d367 1
a367 1
    /* these get confusing because we omit a few and switch some ordering around. */
d369 3
a371 3
    "cr01",  /* 32 = psr */
    "fcr62", /* 33 = fpsr*/
    "fcr63", /* 34 = fpcr */
d374 2
a375 2
    "cr05", /* 36 = snip */
    "cr06", /* 37 = sfip */
d386 1
a386 1
#if 0 /* not currently used */
d398 1
a398 1
      c = sr_readchar();
d401 3
a403 3
	  fflush(stdout);
	  printf("\nNext character is '%c' - %d and s is \"%s\".\n", c, c, --s);
	  return(-1);
d407 1
a407 1
  return(0);
d420 1
a420 1
	if (sr_get_debug() > 0)
d424 2
a425 2
	  SERIAL_WRITE(sr_get_desc(), p, 1);
	while (sr_pollchar() != *p);
d428 1
a428 1
    {  
d433 1
a433 1
  return(0);
d439 1
a439 1
bug_fetch_register(regno)
d442 1
a442 1
  sr_check_open();
d449 1
a449 1
	bug_fetch_register(i);
d455 1
a455 1
      supply_register(regno, (char *) &l);
d462 1
a462 1
      sr_write_cr (get_reg_name(regno));
d465 1
a465 1
			      sr_get_hex_word());
d475 7
a481 7
      sr_write("rs ", 3);
      sr_write(get_reg_name(regno), strlen(get_reg_name(regno)));
      sr_write_cr(";d");
      sr_expect("rs");
      sr_expect(get_reg_name(regno));
      sr_expect(";d");
      sr_expect("=");
d484 1
a484 1
      p = sr_get_hex_digit(1);
d488 2
a489 2
      sr_expect("_");
      p = sr_get_hex_digit(1);
d491 1
a491 1
      fpreg_buf[0] += sr_get_hex_digit(1);
d493 1
a493 1
      fpreg_buf[1] = sr_get_hex_digit(1) << 4;
d496 2
a497 2
      sr_expect("_");
      fpreg_buf[1] += sr_get_hex_digit(1);
d499 6
a504 6
      fpreg_buf[2] = (sr_get_hex_digit(1) << 4) + sr_get_hex_digit(1);
      fpreg_buf[3] = (sr_get_hex_digit(1) << 4) + sr_get_hex_digit(1);
      fpreg_buf[4] = (sr_get_hex_digit(1) << 4) + sr_get_hex_digit(1);
      fpreg_buf[5] = (sr_get_hex_digit(1) << 4) + sr_get_hex_digit(1);
      fpreg_buf[6] = (sr_get_hex_digit(1) << 4) + sr_get_hex_digit(1);
      fpreg_buf[7] = (sr_get_hex_digit(1) << 4) + sr_get_hex_digit(1);
d508 2
a509 2
      gr_expect_prompt();
      supply_register(regno, fpreg_buf);
d522 1
a522 1
  sr_check_open();
d529 1
a529 1
	bug_store_register(i);
d535 1
a535 1
      regname = get_reg_name(regno);
d540 3
a542 3
	sprintf(buffer, "rs %s %08x",
		regname,
		read_register(regno));
d546 17
a562 17
	    (unsigned char *)&registers[REGISTER_BYTE(regno)];
	  
	  sprintf(buffer, "rs %s %1x_%02x%1x_%1x%02x%02x%02x%02x%02x%02x;d",
		  regname,
		  /* sign */
		  (fpreg_buf[0] >> 7) & 0xf,
		  /* exponent */
		  fpreg_buf[0] & 0x7f,
		  (fpreg_buf[1] >> 8) & 0xf,
		  /* fraction */
		  fpreg_buf[1] & 0xf,
		  fpreg_buf[2],
		  fpreg_buf[3],
		  fpreg_buf[4],
		  fpreg_buf[5],
		  fpreg_buf[6],
		  fpreg_buf[7]);
d565 2
a566 2
      sr_write_cr(buffer);
      gr_expect_prompt();
d652 1
a652 1
start_load()
d678 2
a679 1
static char *srecord_strings[] = {
d704 1
a704 1
	return(-1);
d708 2
a709 2
	  if (sr_get_debug() > 0)
	    printf("\n<retrying...>\n");
d716 1
a716 1
	  gr_expect_prompt();
d719 1
a719 1
      start_load();
d739 1
a739 1
		       + ((address >>  8) & 0xff)
d753 2
a754 2
		 This is intended for testing/debugging the error handling
		 stuff.  */
d763 1
a763 1
	  sprintf(buf, "%02X", ~checksum & 0xff);
d767 1
a767 1
	    sleep(srec_sleep);
d775 1
a775 1
	  if ((x = sr_pollchar()) != 0)
d777 2
a778 2
	      if (sr_get_debug() > 0)
		printf("\n<retrying...>\n");
d783 2
a784 2
		 at the prompt level. */
	      gr_expect_prompt();
d786 1
a786 1
	      start_load();
d794 1
a794 1
      bug_srec_write_cr("S7060000000000F9");
d798 3
a800 2
	 had any errors.  */
    } while (gr_multi_scan(srecord_strings, 0) == 0);;
d802 1
a802 1
  return(0);
d807 1
a807 1
 * sb/sh instructions don't work on unaligned addresses, when TU=1.
d827 2
a828 2
  sprintf(request, "du 0 %x:&%d", memaddr, len);
  sr_write_cr(request);
d830 1
a830 1
  p = buffer = alloca(len);
d833 1
a833 1
  sr_expect("S0030000FC");
d838 1
a838 1
      while (sr_readchar() != 'S') ;;
d841 1
a841 1
      type = sr_readchar();
d844 1
a844 1
      sr_get_hex_byte(&size);
d857 1
a857 1
	  sr_get_hex_byte(&c);
d863 1
a863 1
	  sr_get_hex_byte(&c);
d869 1
a869 1
	  sr_get_hex_byte(&c);
d873 1
a873 1
	  sr_get_hex_byte(&c);
d881 1
a881 1
	  error("reading s-records.");
d886 1
a886 1
	error("srec out of memory range.");
d889 1
a889 1
	error("srec out of sequence.");
d893 1
a893 1
	  sr_get_hex_byte(p);
d897 1
a897 1
      sr_get_hex_byte(&c);
d899 1
a899 1
	error("bad s-rec checksum");
d902 2
a903 2
 done:
  gr_expect_prompt();
d905 1
a905 1
    return(1);
d907 2
a908 2
  memcpy(myaddr, buffer, len);
  return(0);
d928 1
a928 1
      return(0);
d934 1
a934 1
      return(1);
d961 1
a961 1
  if (sr_is_open())
d964 1
a964 1
      sr_expect("nobr");
d968 1
a968 1
  return(0);
d971 1
a971 1
struct target_ops bug_ops ;
d973 2
a974 2
static void 
init_bug_ops(void)
d976 7
a982 6
  bug_ops.to_shortname =   "bug"; "Remote BUG monitor",
				    bug_ops.to_longname =   "Use the mvme187 board running the BUG monitor connected by a serial line.";
  bug_ops.to_doc =   " ";
  bug_ops.to_open =   bug_open;
  bug_ops.to_close =   gr_close;
  bug_ops.to_attach =   0;
d985 1
a985 1
  bug_ops.to_detach =   gr_detach;
d987 2
a988 2
  bug_ops.to_resume =   bug_resume;
  bug_ops.to_wait  =   bug_wait;
d990 16
a1005 16
  bug_ops.to_fetch_registers  =   bug_fetch_register;
  bug_ops.to_store_registers  =   bug_store_register;
  bug_ops.to_prepare_to_store =   gr_prepare_to_store;
  bug_ops.to_xfer_memory  =   bug_xfer_memory;
  bug_ops.to_files_info  =   gr_files_info;
  bug_ops.to_insert_breakpoint =   bug_insert_breakpoint;
  bug_ops.to_remove_breakpoint =   bug_remove_breakpoint;
  bug_ops.to_terminal_init  =   0;
  bug_ops.to_terminal_inferior =   0;
  bug_ops.to_terminal_ours_for_output =   0;
  bug_ops.to_terminal_ours  =   0;
  bug_ops.to_terminal_info  =   0;		
  bug_ops.to_kill  =   gr_kill;			
  bug_ops.to_load  =   bug_load;
  bug_ops.to_lookup_symbol =   0;			
  bug_ops.to_create_inferior =   gr_create_inferior;	
d1008 2
a1009 2
  bug_ops.to_clone_and_follow_inferior = NULL;          
  bug_ops.to_post_follow_inferior_by_clone = NULL;  
d1013 1
a1013 1
  bug_ops.to_remove_vfork_catchpoint = NULL;                      
d1015 2
a1016 2
  bug_ops.to_has_vforked = NULL; 
  bug_ops.to_can_follow_vfork_prior_to_exec = NULL;                       
d1023 5
a1027 5
  bug_ops.to_mourn_inferior =   gr_mourn;		
  bug_ops.to_can_run  =   0;				
  bug_ops.to_notice_signals =   0;			
  bug_ops.to_thread_alive  =  0 ;
  bug_ops.to_stop  =   0;
d1030 11
a1040 11
  bug_ops.to_stratum =   process_stratum ;
  bug_ops.DONT_USE =   0;
  bug_ops.to_has_all_memory =   1;
  bug_ops.to_has_memory =   1;
  bug_ops.to_has_stack =   1;	
  bug_ops.to_has_registers =   0;
  bug_ops.to_has_execution =   0;			
  bug_ops.to_sections =   0 ;
  bug_ops.to_sections_end = 0 ;
  bug_ops.to_magic = OPS_MAGIC;			/* Always the last thing */
} /* init_bug_ops */
d1045 1
a1045 1
  init_bug_ops() ;
d1104 1
a1104 1
much slower, but generally more reliable.", 
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d7 1
a7 1
   This file is part of GDB.
d9 13
a21 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d41 1
a41 1
extern int sleep ();
d50 1
a50 1
static int bug_clear_breakpoints PARAMS ((void));
d52 7
a58 7
static int bug_read_memory PARAMS ((CORE_ADDR memaddr,
				    unsigned char *myaddr,
				    int len));

static int bug_write_memory PARAMS ((CORE_ADDR memaddr,
				     unsigned char *myaddr,
				     int len));
d125 1
a125 1
  dcache_flush (gr_get_dcache ());
d203 8
a210 9
static struct gr_settings bug_settings =
{
  NULL,				/* dcache */
  "Bug>",			/* prompt */
  &bug_ops,			/* ops */
  bug_clear_breakpoints,	/* clear_all_breakpoints */
  bug_read_memory,		/* readfunc */
  bug_write_memory,		/* writefunc */
  gr_generic_checkin,		/* checkin */
d213 1
a213 2
static char *cpu_check_strings[] =
{
d224 1
a224 1
    args = "";
d226 1
a226 1
  gr_open (args, from_tty, &bug_settings);
d228 2
a229 2
  sr_write_cr ("rs cr06");
  sr_expect ("rs cr06");
d231 1
a231 1
  switch (gr_multi_scan (cpu_check_strings, 0))
d233 1
a233 1
    case 0:			/* this is an m88100 */
d236 1
a236 1
    case 1:			/* this is an m88110 */
d240 1
a240 1
      abort ();
d251 1
a251 1
  dcache_flush (gr_get_dcache ());
d255 1
a255 1
      sr_write_cr ("t");
d258 2
a259 2
         about I/O from the target means that the user has to type
         "continue" to see any.  FIXME, this should be fixed.  */
d263 1
a263 1
    sr_write_cr ("g");
d271 1
a271 2
static char *wait_strings[] =
{
d274 1
a274 1
  "\r8??\?-Bug>",		/* The '\?' avoids creating a trigraph */
d284 1
a284 1
  int old_timeout = sr_get_timeout ();
d294 2
a295 2
      sr_expect ("Effective address: ");
      (void) sr_get_hex_word ();
d299 2
a300 2
  sr_set_timeout (-1);		/* Don't time out -- user program is running. */
  immediate_quit = 1;		/* Helps ability to QUIT */
d302 1
a302 1
  switch (gr_multi_scan (wait_strings, need_artificial_trap == 0))
d304 1
a304 1
    case 0:			/* breakpoint case */
d308 1
a308 1
      gr_expect_prompt ();
d311 1
a311 1
    case 1:			/* bus error */
d315 1
a315 1
      gr_expect_prompt ();
d318 1
a318 1
    case 2:			/* normal case */
d336 1
a336 1
    case -1:			/* trouble */
d343 1
a343 1
  sr_set_timeout (old_timeout);
d356 1
a356 2
  static char *rn[] =
  {
d362 1
a362 1
  /* these get confusing because we omit a few and switch some ordering around. */
d364 3
a366 3
    "cr01",			/* 32 = psr */
    "fcr62",			/* 33 = fpsr */
    "fcr63",			/* 34 = fpcr */
d369 2
a370 2
    "cr05",			/* 36 = snip */
    "cr06",			/* 37 = sfip */
d381 1
a381 1
#if 0				/* not currently used */
d393 1
a393 1
      c = sr_readchar ();
d396 3
a398 3
	  fflush (stdout);
	  printf ("\nNext character is '%c' - %d and s is \"%s\".\n", c, c, --s);
	  return (-1);
d402 1
a402 1
  return (0);
d415 1
a415 1
	if (sr_get_debug () > 0)
d419 2
a420 2
	  SERIAL_WRITE (sr_get_desc (), p, 1);
	while (sr_pollchar () != *p);
d423 1
a423 1
    {
d428 1
a428 1
  return (0);
d434 1
a434 1
bug_fetch_register (regno)
d437 1
a437 1
  sr_check_open ();
d444 1
a444 1
	bug_fetch_register (i);
d450 1
a450 1
      supply_register (regno, (char *) &l);
d457 1
a457 1
      sr_write_cr (get_reg_name (regno));
d460 1
a460 1
			      sr_get_hex_word ());
d470 7
a476 7
      sr_write ("rs ", 3);
      sr_write (get_reg_name (regno), strlen (get_reg_name (regno)));
      sr_write_cr (";d");
      sr_expect ("rs");
      sr_expect (get_reg_name (regno));
      sr_expect (";d");
      sr_expect ("=");
d479 1
a479 1
      p = sr_get_hex_digit (1);
d483 2
a484 2
      sr_expect ("_");
      p = sr_get_hex_digit (1);
d486 1
a486 1
      fpreg_buf[0] += sr_get_hex_digit (1);
d488 1
a488 1
      fpreg_buf[1] = sr_get_hex_digit (1) << 4;
d491 2
a492 2
      sr_expect ("_");
      fpreg_buf[1] += sr_get_hex_digit (1);
d494 6
a499 6
      fpreg_buf[2] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
      fpreg_buf[3] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
      fpreg_buf[4] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
      fpreg_buf[5] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
      fpreg_buf[6] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
      fpreg_buf[7] = (sr_get_hex_digit (1) << 4) + sr_get_hex_digit (1);
d503 2
a504 2
      gr_expect_prompt ();
      supply_register (regno, fpreg_buf);
d517 1
a517 1
  sr_check_open ();
d524 1
a524 1
	bug_store_register (i);
d530 1
a530 1
      regname = get_reg_name (regno);
d535 3
a537 3
	sprintf (buffer, "rs %s %08x",
		 regname,
		 read_register (regno));
d541 17
a557 17
	  (unsigned char *) &registers[REGISTER_BYTE (regno)];

	  sprintf (buffer, "rs %s %1x_%02x%1x_%1x%02x%02x%02x%02x%02x%02x;d",
		   regname,
	  /* sign */
		   (fpreg_buf[0] >> 7) & 0xf,
	  /* exponent */
		   fpreg_buf[0] & 0x7f,
		   (fpreg_buf[1] >> 8) & 0xf,
	  /* fraction */
		   fpreg_buf[1] & 0xf,
		   fpreg_buf[2],
		   fpreg_buf[3],
		   fpreg_buf[4],
		   fpreg_buf[5],
		   fpreg_buf[6],
		   fpreg_buf[7]);
d560 2
a561 2
      sr_write_cr (buffer);
      gr_expect_prompt ();
d647 1
a647 1
start_load ()
d673 1
a673 2
static char *srecord_strings[] =
{
d698 1
a698 1
	return (-1);
d702 2
a703 2
	  if (sr_get_debug () > 0)
	    printf ("\n<retrying...>\n");
d710 1
a710 1
	  gr_expect_prompt ();
d713 1
a713 1
      start_load ();
d733 1
a733 1
		       + ((address >> 8) & 0xff)
d747 2
a748 2
	         This is intended for testing/debugging the error handling
	         stuff.  */
d757 1
a757 1
	  sprintf (buf, "%02X", ~checksum & 0xff);
d761 1
a761 1
	    sleep (srec_sleep);
d769 1
a769 1
	  if ((x = sr_pollchar ()) != 0)
d771 2
a772 2
	      if (sr_get_debug () > 0)
		printf ("\n<retrying...>\n");
d777 2
a778 2
	         at the prompt level. */
	      gr_expect_prompt ();
d780 1
a780 1
	      start_load ();
d788 1
a788 1
      bug_srec_write_cr ("S7060000000000F9");
d792 2
a793 3
         had any errors.  */
    }
  while (gr_multi_scan (srecord_strings, 0) == 0);;
d795 1
a795 1
  return (0);
d800 1
a800 1
   * sb/sh instructions don't work on unaligned addresses, when TU=1.
d820 2
a821 2
  sprintf (request, "du 0 %x:&%d", memaddr, len);
  sr_write_cr (request);
d823 1
a823 1
  p = buffer = alloca (len);
d826 1
a826 1
  sr_expect ("S0030000FC");
d831 1
a831 1
      while (sr_readchar () != 'S');;
d834 1
a834 1
      type = sr_readchar ();
d837 1
a837 1
      sr_get_hex_byte (&size);
d850 1
a850 1
	  sr_get_hex_byte (&c);
d856 1
a856 1
	  sr_get_hex_byte (&c);
d862 1
a862 1
	  sr_get_hex_byte (&c);
d866 1
a866 1
	  sr_get_hex_byte (&c);
d874 1
a874 1
	  error ("reading s-records.");
d879 1
a879 1
	error ("srec out of memory range.");
d882 1
a882 1
	error ("srec out of sequence.");
d886 1
a886 1
	  sr_get_hex_byte (p);
d890 1
a890 1
      sr_get_hex_byte (&c);
d892 1
a892 1
	error ("bad s-rec checksum");
d895 2
a896 2
done:
  gr_expect_prompt ();
d898 1
a898 1
    return (1);
d900 2
a901 2
  memcpy (myaddr, buffer, len);
  return (0);
d921 1
a921 1
      return (0);
d927 1
a927 1
      return (1);
d954 1
a954 1
  if (sr_is_open ())
d957 1
a957 1
      sr_expect ("nobr");
d961 1
a961 1
  return (0);
d964 1
a964 1
struct target_ops bug_ops;
d966 2
a967 2
static void
init_bug_ops (void)
d969 6
a974 7
  bug_ops.to_shortname = "bug";
  "Remote BUG monitor",
    bug_ops.to_longname = "Use the mvme187 board running the BUG monitor connected by a serial line.";
  bug_ops.to_doc = " ";
  bug_ops.to_open = bug_open;
  bug_ops.to_close = gr_close;
  bug_ops.to_attach = 0;
d977 1
a977 1
  bug_ops.to_detach = gr_detach;
d979 2
a980 2
  bug_ops.to_resume = bug_resume;
  bug_ops.to_wait = bug_wait;
d982 16
a997 16
  bug_ops.to_fetch_registers = bug_fetch_register;
  bug_ops.to_store_registers = bug_store_register;
  bug_ops.to_prepare_to_store = gr_prepare_to_store;
  bug_ops.to_xfer_memory = bug_xfer_memory;
  bug_ops.to_files_info = gr_files_info;
  bug_ops.to_insert_breakpoint = bug_insert_breakpoint;
  bug_ops.to_remove_breakpoint = bug_remove_breakpoint;
  bug_ops.to_terminal_init = 0;
  bug_ops.to_terminal_inferior = 0;
  bug_ops.to_terminal_ours_for_output = 0;
  bug_ops.to_terminal_ours = 0;
  bug_ops.to_terminal_info = 0;
  bug_ops.to_kill = gr_kill;
  bug_ops.to_load = bug_load;
  bug_ops.to_lookup_symbol = 0;
  bug_ops.to_create_inferior = gr_create_inferior;
d1000 2
a1001 2
  bug_ops.to_clone_and_follow_inferior = NULL;
  bug_ops.to_post_follow_inferior_by_clone = NULL;
d1005 1
a1005 1
  bug_ops.to_remove_vfork_catchpoint = NULL;
d1007 2
a1008 2
  bug_ops.to_has_vforked = NULL;
  bug_ops.to_can_follow_vfork_prior_to_exec = NULL;
d1015 5
a1019 5
  bug_ops.to_mourn_inferior = gr_mourn;
  bug_ops.to_can_run = 0;
  bug_ops.to_notice_signals = 0;
  bug_ops.to_thread_alive = 0;
  bug_ops.to_stop = 0;
d1022 11
a1032 11
  bug_ops.to_stratum = process_stratum;
  bug_ops.DONT_USE = 0;
  bug_ops.to_has_all_memory = 1;
  bug_ops.to_has_memory = 1;
  bug_ops.to_has_stack = 1;
  bug_ops.to_has_registers = 0;
  bug_ops.to_has_execution = 0;
  bug_ops.to_sections = 0;
  bug_ops.to_sections_end = 0;
  bug_ops.to_magic = OPS_MAGIC;	/* Always the last thing */
}				/* init_bug_ops */
d1037 1
a1037 1
  init_bug_ops ();
d1096 1
a1096 1
much slower, but generally more reliable.",
@

