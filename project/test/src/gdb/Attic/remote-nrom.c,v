head	1.11;
access;
symbols
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.10
	kseitz_interps-20021105-merge:1.10
	kseitz_interps-20021103-merge:1.10
	drow-cplus-merge-20021020:1.10
	drow-cplus-merge-20021025:1.10
	carlton_dictionary-20021025-merge:1.10
	carlton_dictionary-20021011-merge:1.10
	drow-cplus-branch:1.10.0.10
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.8
	carlton_dictionary-20020920-branchpoint:1.10
	gdb_5_3-branch:1.10.0.6
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.4
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.2
	readline_4_3-import-branchpoint:1.10
	gdb_5_2_1-2002-07-23-release:1.9
	kseitz_interps-20020528-branch:1.9.0.14
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.12
	cagney_regbuf-20020515-branchpoint:1.9
	jimb-macro-020506-branch:1.9.0.10
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	gdb_5_2-branch:1.9.0.8
	gdb_5_2-2002-03-03-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.9
	gdb_5_1_0_1-2002-01-03-release:1.9
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.6
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.4
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.2
	gdb_5_1-2001-07-29-branchpoint:1.9
	dberlin-typesystem-branch:1.7.0.2
	dberlin-typesystem-branchpoint:1.7
	gdb-post-ptid_t-2001-05-03:1.7
	gdb-pre-ptid_t-2001-05-03:1.7
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.11
date	2002.12.16.20.39.10;	author cagney;	state dead;
branches;
next	1.10;

1.10
date	2002.08.22.21.52.44;	author cagney;	state Exp;
branches
	1.10.8.1
	1.10.10.1;
next	1.9;

1.9
date	2001.07.15.20.34.13;	author cagney;	state Exp;
branches
	1.9.14.1;
next	1.8;

1.8
date	2001.07.11.17.52.32;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.14.19.23.02;	author jtc;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.27.20.36.24;	author jtc;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.06.08.21.12;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.01.00.12.10;	author jtc;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.09.11;	author jsm;	state Exp;
branches;
next	;

1.9.14.1
date	2002.08.30.22.52.45;	author kseitz;	state Exp;
branches;
next	;

1.10.8.1
date	2002.12.23.19.38.39;	author carlton;	state dead;
branches;
next	;

1.10.10.1
date	2003.12.14.20.27.28;	author drow;	state dead;
branches;
next	;


desc
@@


1.11
log
@2002-12-16  Andrew Cagney  <ac131313@@redhat.com>

	* config/arc/arc.mt, config/arc/tm-arc.h: Delete.
	* config/d30v/d30v.mt, config/d30v/tm-d30v.h: Delete.
	* config/fr30/fr30.mt, config/fr30/tm-fr30.h: Delete.
	* config/i386/i386aix.mh, config/i386/i386aix.mt: Delete.
	* config/i386/i386m3.mh, config/i386/i386m3.mt: Delete.
	* config/i386/i386mach.mh, config/i386/i386os9k.mt: Delete.
	* config/i386/nm-i386aix.h, config/i386/nm-i386mach.h: Delete.
	* config/i386/nm-m3.h, config/i386/tm-i386aix.h: Delete.
	* config/i386/tm-i386m3.h, config/i386/tm-i386mk.h: Delete.
	* config/i386/xm-i386aix.h, config/i386/xm-i386m3.h: Delete.
	* config/i386/xm-i386mach.h, config/i386/xm-i386mk.h: Delete.
	* config/i960/mon960.mt, config/i960/nindy960.mt: Delete.
	* config/i960/tm-i960.h, config/i960/tm-mon960.h: Delete.
	* config/i960/tm-nindy960.h, config/i960/tm-vx960.h: Delete.
	* config/i960/vxworks960.mt, config/m68k/apollo68b.mh: Delete.
	* config/m68k/apollo68b.mt, config/m68k/apollo68v.mh: Delete.
	* config/m68k/hp300bsd.mh, config/m68k/hp300bsd.mt: Delete.
	* config/m68k/hp300hpux.mh, config/m68k/hp300hpux.mt: Delete.
	* config/m88k/delta88.mh, config/m88k/delta88.mt: Delete.
	* config/m88k/delta88v4.mh, config/m88k/delta88v4.mt: Delete.
	* config/m88k/m88k.mh, config/m88k/m88k.mt: Delete.
	* config/m88k/nm-delta88v4.h, config/m88k/nm-m88k.h: Delete.
	* config/m88k/tm-delta88.h, config/m88k/tm-delta88v4.h: Delete.
	* config/m88k/tm-m88k.h, config/m88k/xm-delta88.h: Delete.
	* config/m88k/xm-dgux.h: Delete.
	* fr30-tdep.c, i386aix-nat.c, i386m3-nat.c: Delete.
	* i386mach-nat.c, i960-tdep.c, m88k-nat.c: Delete.
	* os9kread.c, remote-bug.c, remote-nindy.c: Delete.
	* remote-nrom.c, remote-os9k.c, remote-vx960.c: Delete.
	* d30v-tdep.c, arc-tdep.c, cxux-nat.c, dst.h, dstread.c: Delete.
	* ch-exp.c, ch-lang.c, ch-lang.h, ch-typeprint.c: Delete.
	* ch-valprint.c: Delete.
@
text
@// OBSOLETE /* Remote debugging with the XLNT Designs, Inc (XDI) NetROM.
// OBSOLETE    Copyright 1990, 1991, 1992, 1995, 1998, 1999, 2000
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE    Contributed by:
// OBSOLETE    Roger Moyers 
// OBSOLETE    XLNT Designs, Inc.
// OBSOLETE    15050 Avenue of Science, Suite 106
// OBSOLETE    San Diego, CA  92128
// OBSOLETE    (619)487-9320
// OBSOLETE    roger@@xlnt.com
// OBSOLETE    Adapted from work done at Cygnus Support in remote-nindy.c,
// OBSOLETE    later merged in by Stan Shebs at Cygnus.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "gdbcmd.h"
// OBSOLETE #include "serial.h"
// OBSOLETE #include "target.h"
// OBSOLETE 
// OBSOLETE /* Default ports used to talk with the NetROM.  */
// OBSOLETE 
// OBSOLETE #define DEFAULT_NETROM_LOAD_PORT    1236
// OBSOLETE #define DEFAULT_NETROM_CONTROL_PORT 1237
// OBSOLETE 
// OBSOLETE static void nrom_close (int quitting);
// OBSOLETE 
// OBSOLETE /* New commands.  */
// OBSOLETE 
// OBSOLETE static void nrom_passthru (char *, int);
// OBSOLETE 
// OBSOLETE /* We talk to the NetROM over these sockets.  */
// OBSOLETE 
// OBSOLETE static struct serial *load_desc = NULL;
// OBSOLETE static struct serial *ctrl_desc = NULL;
// OBSOLETE 
// OBSOLETE static int load_port = DEFAULT_NETROM_LOAD_PORT;
// OBSOLETE static int control_port = DEFAULT_NETROM_CONTROL_PORT;
// OBSOLETE 
// OBSOLETE static char nrom_hostname[100];
// OBSOLETE 
// OBSOLETE /* Forward data declaration. */
// OBSOLETE 
// OBSOLETE extern struct target_ops nrom_ops;
// OBSOLETE 
// OBSOLETE /* Scan input from the remote system, until STRING is found.  Print chars that
// OBSOLETE    don't match.  */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE expect (char *string)
// OBSOLETE {
// OBSOLETE   char *p = string;
// OBSOLETE   int c;
// OBSOLETE 
// OBSOLETE   immediate_quit++;
// OBSOLETE 
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       c = serial_readchar (ctrl_desc, 5);
// OBSOLETE 
// OBSOLETE       if (c == *p++)
// OBSOLETE 	{
// OBSOLETE 	  if (*p == '\0')
// OBSOLETE 	    {
// OBSOLETE 	      immediate_quit--;
// OBSOLETE 	      return 0;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  fputc_unfiltered (c, gdb_stdout);
// OBSOLETE 	  p = string;
// OBSOLETE 	  if (c == *p)
// OBSOLETE 	    p++;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nrom_kill (void)
// OBSOLETE {
// OBSOLETE   nrom_close (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct serial *
// OBSOLETE open_socket (char *name, int port)
// OBSOLETE {
// OBSOLETE   char sockname[100];
// OBSOLETE   struct serial *desc;
// OBSOLETE 
// OBSOLETE   sprintf (sockname, "%s:%d", name, port);
// OBSOLETE   desc = serial_open (sockname);
// OBSOLETE   if (!desc)
// OBSOLETE     perror_with_name (sockname);
// OBSOLETE 
// OBSOLETE   return desc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE load_cleanup (void)
// OBSOLETE {
// OBSOLETE   serial_close (load_desc);
// OBSOLETE   load_desc = NULL;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Download a file specified in ARGS to the netROM.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nrom_load (char *args, int fromtty)
// OBSOLETE {
// OBSOLETE   int fd, rd_amt, fsize;
// OBSOLETE   bfd *pbfd;
// OBSOLETE   asection *section;
// OBSOLETE   char *downloadstring = "download 0\n";
// OBSOLETE   struct cleanup *old_chain;
// OBSOLETE 
// OBSOLETE   /* Tell the netrom to get ready to download. */
// OBSOLETE   if (serial_write (ctrl_desc, downloadstring, strlen (downloadstring)))
// OBSOLETE     error ("nrom_load: control_send() of `%s' failed", downloadstring);
// OBSOLETE 
// OBSOLETE   expect ("Waiting for a connection...\n");
// OBSOLETE 
// OBSOLETE   load_desc = open_socket (nrom_hostname, load_port);
// OBSOLETE 
// OBSOLETE   old_chain = make_cleanup (load_cleanup, 0);
// OBSOLETE 
// OBSOLETE   pbfd = bfd_openr (args, 0);
// OBSOLETE 
// OBSOLETE   if (pbfd)
// OBSOLETE     {
// OBSOLETE       make_cleanup (bfd_close, pbfd);
// OBSOLETE 
// OBSOLETE       if (!bfd_check_format (pbfd, bfd_object))
// OBSOLETE 	error ("\"%s\": not in executable format: %s",
// OBSOLETE 	       args, bfd_errmsg (bfd_get_error ()));
// OBSOLETE 
// OBSOLETE       for (section = pbfd->sections; section; section = section->next)
// OBSOLETE 	{
// OBSOLETE 	  if (bfd_get_section_flags (pbfd, section) & SEC_ALLOC)
// OBSOLETE 	    {
// OBSOLETE 	      bfd_vma section_address;
// OBSOLETE 	      unsigned long section_size;
// OBSOLETE 	      const char *section_name;
// OBSOLETE 
// OBSOLETE 	      section_name = bfd_get_section_name (pbfd, section);
// OBSOLETE 	      section_address = bfd_get_section_vma (pbfd, section);
// OBSOLETE 	      section_size = bfd_section_size (pbfd, section);
// OBSOLETE 
// OBSOLETE 	      if (bfd_get_section_flags (pbfd, section) & SEC_LOAD)
// OBSOLETE 		{
// OBSOLETE 		  file_ptr fptr;
// OBSOLETE 
// OBSOLETE 		  printf_filtered ("[Loading section %s at %x (%d bytes)]\n",
// OBSOLETE 				   section_name, section_address,
// OBSOLETE 				   section_size);
// OBSOLETE 
// OBSOLETE 		  fptr = 0;
// OBSOLETE 
// OBSOLETE 		  while (section_size > 0)
// OBSOLETE 		    {
// OBSOLETE 		      char buffer[1024];
// OBSOLETE 		      int count;
// OBSOLETE 
// OBSOLETE 		      count = min (section_size, 1024);
// OBSOLETE 
// OBSOLETE 		      bfd_get_section_contents (pbfd, section, buffer, fptr,
// OBSOLETE 						count);
// OBSOLETE 
// OBSOLETE 		      serial_write (load_desc, buffer, count);
// OBSOLETE 		      section_address += count;
// OBSOLETE 		      fptr += count;
// OBSOLETE 		      section_size -= count;
// OBSOLETE 		    }
// OBSOLETE 		}
// OBSOLETE 	      else
// OBSOLETE 		/* BSS and such */
// OBSOLETE 		{
// OBSOLETE 		  printf_filtered ("[section %s: not loading]\n",
// OBSOLETE 				   section_name);
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     error ("\"%s\": Could not open", args);
// OBSOLETE 
// OBSOLETE   do_cleanups (old_chain);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Open a connection to the remote NetROM devices.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nrom_open (char *name, int from_tty)
// OBSOLETE {
// OBSOLETE   int errn;
// OBSOLETE 
// OBSOLETE   if (!name || strchr (name, '/') || strchr (name, ':'))
// OBSOLETE     error (
// OBSOLETE 	    "To open a NetROM connection, you must specify the hostname\n\
// OBSOLETE or IP address of the NetROM device you wish to use.");
// OBSOLETE 
// OBSOLETE   strcpy (nrom_hostname, name);
// OBSOLETE 
// OBSOLETE   target_preopen (from_tty);
// OBSOLETE 
// OBSOLETE   unpush_target (&nrom_ops);
// OBSOLETE 
// OBSOLETE   ctrl_desc = open_socket (nrom_hostname, control_port);
// OBSOLETE 
// OBSOLETE   push_target (&nrom_ops);
// OBSOLETE 
// OBSOLETE   if (from_tty)
// OBSOLETE     printf_filtered ("Connected to NetROM device \"%s\"\n", nrom_hostname);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Close out all files and local state before this target loses control. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nrom_close (int quitting)
// OBSOLETE {
// OBSOLETE   if (load_desc)
// OBSOLETE     serial_close (load_desc);
// OBSOLETE   if (ctrl_desc)
// OBSOLETE     serial_close (ctrl_desc);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Pass arguments directly to the NetROM. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nrom_passthru (char *args, int fromtty)
// OBSOLETE {
// OBSOLETE   char buf[1024];
// OBSOLETE 
// OBSOLETE   sprintf (buf, "%s\n", args);
// OBSOLETE   if (serial_write (ctrl_desc, buf, strlen (buf)))
// OBSOLETE     error ("nrom_reset: control_send() of `%s'failed", args);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nrom_mourn (void)
// OBSOLETE {
// OBSOLETE   unpush_target (&nrom_ops);
// OBSOLETE   generic_mourn_inferior ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Define the target vector. */
// OBSOLETE 
// OBSOLETE struct target_ops nrom_ops;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_nrom_ops (void)
// OBSOLETE {
// OBSOLETE   nrom_ops.to_shortname = "nrom";
// OBSOLETE   nrom_ops.to_longname = "Remote XDI `NetROM' target";
// OBSOLETE   nrom_ops.to_doc = "Remote debug using a NetROM over Ethernet";
// OBSOLETE   nrom_ops.to_open = nrom_open;
// OBSOLETE   nrom_ops.to_close = nrom_close;
// OBSOLETE   nrom_ops.to_attach = NULL;
// OBSOLETE   nrom_ops.to_post_attach = NULL;
// OBSOLETE   nrom_ops.to_require_attach = NULL;
// OBSOLETE   nrom_ops.to_detach = NULL;
// OBSOLETE   nrom_ops.to_require_detach = NULL;
// OBSOLETE   nrom_ops.to_resume = NULL;
// OBSOLETE   nrom_ops.to_wait = NULL;
// OBSOLETE   nrom_ops.to_post_wait = NULL;
// OBSOLETE   nrom_ops.to_fetch_registers = NULL;
// OBSOLETE   nrom_ops.to_store_registers = NULL;
// OBSOLETE   nrom_ops.to_prepare_to_store = NULL;
// OBSOLETE   nrom_ops.to_xfer_memory = NULL;
// OBSOLETE   nrom_ops.to_files_info = NULL;
// OBSOLETE   nrom_ops.to_insert_breakpoint = NULL;
// OBSOLETE   nrom_ops.to_remove_breakpoint = NULL;
// OBSOLETE   nrom_ops.to_terminal_init = NULL;
// OBSOLETE   nrom_ops.to_terminal_inferior = NULL;
// OBSOLETE   nrom_ops.to_terminal_ours_for_output = NULL;
// OBSOLETE   nrom_ops.to_terminal_ours = NULL;
// OBSOLETE   nrom_ops.to_terminal_info = NULL;
// OBSOLETE   nrom_ops.to_kill = nrom_kill;
// OBSOLETE   nrom_ops.to_load = nrom_load;
// OBSOLETE   nrom_ops.to_lookup_symbol = NULL;
// OBSOLETE   nrom_ops.to_create_inferior = NULL;
// OBSOLETE   nrom_ops.to_post_startup_inferior = NULL;
// OBSOLETE   nrom_ops.to_acknowledge_created_inferior = NULL;
// OBSOLETE   nrom_ops.to_clone_and_follow_inferior = NULL;
// OBSOLETE   nrom_ops.to_post_follow_inferior_by_clone = NULL;
// OBSOLETE   nrom_ops.to_insert_fork_catchpoint = NULL;
// OBSOLETE   nrom_ops.to_remove_fork_catchpoint = NULL;
// OBSOLETE   nrom_ops.to_insert_vfork_catchpoint = NULL;
// OBSOLETE   nrom_ops.to_remove_vfork_catchpoint = NULL;
// OBSOLETE   nrom_ops.to_has_forked = NULL;
// OBSOLETE   nrom_ops.to_has_vforked = NULL;
// OBSOLETE   nrom_ops.to_can_follow_vfork_prior_to_exec = NULL;
// OBSOLETE   nrom_ops.to_post_follow_vfork = NULL;
// OBSOLETE   nrom_ops.to_insert_exec_catchpoint = NULL;
// OBSOLETE   nrom_ops.to_remove_exec_catchpoint = NULL;
// OBSOLETE   nrom_ops.to_has_execd = NULL;
// OBSOLETE   nrom_ops.to_reported_exec_events_per_exec_call = NULL;
// OBSOLETE   nrom_ops.to_has_exited = NULL;
// OBSOLETE   nrom_ops.to_mourn_inferior = nrom_mourn;
// OBSOLETE   nrom_ops.to_can_run = NULL;
// OBSOLETE   nrom_ops.to_notice_signals = 0;
// OBSOLETE   nrom_ops.to_thread_alive = 0;
// OBSOLETE   nrom_ops.to_stop = 0;
// OBSOLETE   nrom_ops.to_pid_to_exec_file = NULL;
// OBSOLETE   nrom_ops.to_stratum = download_stratum;
// OBSOLETE   nrom_ops.DONT_USE = NULL;
// OBSOLETE   nrom_ops.to_has_all_memory = 1;
// OBSOLETE   nrom_ops.to_has_memory = 1;
// OBSOLETE   nrom_ops.to_has_stack = 1;
// OBSOLETE   nrom_ops.to_has_registers = 1;
// OBSOLETE   nrom_ops.to_has_execution = 0;
// OBSOLETE   nrom_ops.to_sections = NULL;
// OBSOLETE   nrom_ops.to_sections_end = NULL;
// OBSOLETE   nrom_ops.to_magic = OPS_MAGIC;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_remote_nrom (void)
// OBSOLETE {
// OBSOLETE   init_nrom_ops ();
// OBSOLETE   add_target (&nrom_ops);
// OBSOLETE 
// OBSOLETE   add_show_from_set (
// OBSOLETE   add_set_cmd ("nrom_load_port", no_class, var_zinteger, (char *) &load_port,
// OBSOLETE 	       "Set the port to use for NetROM downloads\n", &setlist),
// OBSOLETE 		      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set (
// OBSOLETE 		      add_set_cmd ("nrom_control_port", no_class, var_zinteger, (char *) &control_port,
// OBSOLETE 	    "Set the port to use for NetROM debugger services\n", &setlist),
// OBSOLETE 		      &showlist);
// OBSOLETE 
// OBSOLETE   add_cmd ("nrom", no_class, nrom_passthru,
// OBSOLETE 	   "Pass arguments as command to NetROM",
// OBSOLETE 	   &cmdlist);
// OBSOLETE }
@


1.10
log
@Obsolete i960.
@
text
@@


1.10.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.10.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.9
log
@* serial.h (SERIAL_ASYNC): Delete.
(DEPRECATED_SERIAL_FD): Delete.
(SERIAL_DEBUG): Delete.
(SERIAL_DEBUG_P): Delete.
(SERIAL_DRAIN_OUTPUT): Delete.
(SERIAL_FLUSH_OUTPUT): Delete.
(SERIAL_FLUSH_INPUT): Delete.
(SERIAL_SEND_BREAK): Delete.
(SERIAL_RAW): Delete.
(SERIAL_GET_TTY_STATE): Delete.
(SERIAL_SET_TTY_STATE): Delete.
(SERIAL_PRINT_TTY_STATE): Delete.
(SERIAL_NOFLUSH_SET_TTY_STATE): Delete.
(SERIAL_SETBAUDRATE): Delete.
(SERIAL_SETSTOPBITS): Delete.
(SERIAL_CAN_ASYNC_P): Delete.
(SERIAL_IS_ASYNC_P): Delete.
(SERIAL_UN_FDOPEN): Delete.
(SERIAL_READCHAR): Delete.
(SERIAL_CLOSE): Delete.
(SERIAL_FDOPEN): Delete.
(SERIAL_OPEN): Delete.
@
text
@d1 351
a351 351
/* Remote debugging with the XLNT Designs, Inc (XDI) NetROM.
   Copyright 1990, 1991, 1992, 1995, 1998, 1999, 2000
   Free Software Foundation, Inc.
   Contributed by:
   Roger Moyers 
   XLNT Designs, Inc.
   15050 Avenue of Science, Suite 106
   San Diego, CA  92128
   (619)487-9320
   roger@@xlnt.com
   Adapted from work done at Cygnus Support in remote-nindy.c,
   later merged in by Stan Shebs at Cygnus.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "gdbcmd.h"
#include "serial.h"
#include "target.h"

/* Default ports used to talk with the NetROM.  */

#define DEFAULT_NETROM_LOAD_PORT    1236
#define DEFAULT_NETROM_CONTROL_PORT 1237

static void nrom_close (int quitting);

/* New commands.  */

static void nrom_passthru (char *, int);

/* We talk to the NetROM over these sockets.  */

static struct serial *load_desc = NULL;
static struct serial *ctrl_desc = NULL;

static int load_port = DEFAULT_NETROM_LOAD_PORT;
static int control_port = DEFAULT_NETROM_CONTROL_PORT;

static char nrom_hostname[100];

/* Forward data declaration. */

extern struct target_ops nrom_ops;

/* Scan input from the remote system, until STRING is found.  Print chars that
   don't match.  */

static int
expect (char *string)
{
  char *p = string;
  int c;

  immediate_quit++;

  while (1)
    {
      c = serial_readchar (ctrl_desc, 5);

      if (c == *p++)
	{
	  if (*p == '\0')
	    {
	      immediate_quit--;
	      return 0;
	    }
	}
      else
	{
	  fputc_unfiltered (c, gdb_stdout);
	  p = string;
	  if (c == *p)
	    p++;
	}
    }
}

static void
nrom_kill (void)
{
  nrom_close (0);
}

static struct serial *
open_socket (char *name, int port)
{
  char sockname[100];
  struct serial *desc;

  sprintf (sockname, "%s:%d", name, port);
  desc = serial_open (sockname);
  if (!desc)
    perror_with_name (sockname);

  return desc;
}

static void
load_cleanup (void)
{
  serial_close (load_desc);
  load_desc = NULL;
}

/* Download a file specified in ARGS to the netROM.  */

static void
nrom_load (char *args, int fromtty)
{
  int fd, rd_amt, fsize;
  bfd *pbfd;
  asection *section;
  char *downloadstring = "download 0\n";
  struct cleanup *old_chain;

  /* Tell the netrom to get ready to download. */
  if (serial_write (ctrl_desc, downloadstring, strlen (downloadstring)))
    error ("nrom_load: control_send() of `%s' failed", downloadstring);

  expect ("Waiting for a connection...\n");

  load_desc = open_socket (nrom_hostname, load_port);

  old_chain = make_cleanup (load_cleanup, 0);

  pbfd = bfd_openr (args, 0);

  if (pbfd)
    {
      make_cleanup (bfd_close, pbfd);

      if (!bfd_check_format (pbfd, bfd_object))
	error ("\"%s\": not in executable format: %s",
	       args, bfd_errmsg (bfd_get_error ()));

      for (section = pbfd->sections; section; section = section->next)
	{
	  if (bfd_get_section_flags (pbfd, section) & SEC_ALLOC)
	    {
	      bfd_vma section_address;
	      unsigned long section_size;
	      const char *section_name;

	      section_name = bfd_get_section_name (pbfd, section);
	      section_address = bfd_get_section_vma (pbfd, section);
	      section_size = bfd_section_size (pbfd, section);

	      if (bfd_get_section_flags (pbfd, section) & SEC_LOAD)
		{
		  file_ptr fptr;

		  printf_filtered ("[Loading section %s at %x (%d bytes)]\n",
				   section_name, section_address,
				   section_size);

		  fptr = 0;

		  while (section_size > 0)
		    {
		      char buffer[1024];
		      int count;

		      count = min (section_size, 1024);

		      bfd_get_section_contents (pbfd, section, buffer, fptr,
						count);

		      serial_write (load_desc, buffer, count);
		      section_address += count;
		      fptr += count;
		      section_size -= count;
		    }
		}
	      else
		/* BSS and such */
		{
		  printf_filtered ("[section %s: not loading]\n",
				   section_name);
		}
	    }
	}
    }
  else
    error ("\"%s\": Could not open", args);

  do_cleanups (old_chain);
}

/* Open a connection to the remote NetROM devices.  */

static void
nrom_open (char *name, int from_tty)
{
  int errn;

  if (!name || strchr (name, '/') || strchr (name, ':'))
    error (
	    "To open a NetROM connection, you must specify the hostname\n\
or IP address of the NetROM device you wish to use.");

  strcpy (nrom_hostname, name);

  target_preopen (from_tty);

  unpush_target (&nrom_ops);

  ctrl_desc = open_socket (nrom_hostname, control_port);

  push_target (&nrom_ops);

  if (from_tty)
    printf_filtered ("Connected to NetROM device \"%s\"\n", nrom_hostname);
}

/* Close out all files and local state before this target loses control. */

static void
nrom_close (int quitting)
{
  if (load_desc)
    serial_close (load_desc);
  if (ctrl_desc)
    serial_close (ctrl_desc);
}

/* Pass arguments directly to the NetROM. */

static void
nrom_passthru (char *args, int fromtty)
{
  char buf[1024];

  sprintf (buf, "%s\n", args);
  if (serial_write (ctrl_desc, buf, strlen (buf)))
    error ("nrom_reset: control_send() of `%s'failed", args);
}

static void
nrom_mourn (void)
{
  unpush_target (&nrom_ops);
  generic_mourn_inferior ();
}

/* Define the target vector. */

struct target_ops nrom_ops;

static void
init_nrom_ops (void)
{
  nrom_ops.to_shortname = "nrom";
  nrom_ops.to_longname = "Remote XDI `NetROM' target";
  nrom_ops.to_doc = "Remote debug using a NetROM over Ethernet";
  nrom_ops.to_open = nrom_open;
  nrom_ops.to_close = nrom_close;
  nrom_ops.to_attach = NULL;
  nrom_ops.to_post_attach = NULL;
  nrom_ops.to_require_attach = NULL;
  nrom_ops.to_detach = NULL;
  nrom_ops.to_require_detach = NULL;
  nrom_ops.to_resume = NULL;
  nrom_ops.to_wait = NULL;
  nrom_ops.to_post_wait = NULL;
  nrom_ops.to_fetch_registers = NULL;
  nrom_ops.to_store_registers = NULL;
  nrom_ops.to_prepare_to_store = NULL;
  nrom_ops.to_xfer_memory = NULL;
  nrom_ops.to_files_info = NULL;
  nrom_ops.to_insert_breakpoint = NULL;
  nrom_ops.to_remove_breakpoint = NULL;
  nrom_ops.to_terminal_init = NULL;
  nrom_ops.to_terminal_inferior = NULL;
  nrom_ops.to_terminal_ours_for_output = NULL;
  nrom_ops.to_terminal_ours = NULL;
  nrom_ops.to_terminal_info = NULL;
  nrom_ops.to_kill = nrom_kill;
  nrom_ops.to_load = nrom_load;
  nrom_ops.to_lookup_symbol = NULL;
  nrom_ops.to_create_inferior = NULL;
  nrom_ops.to_post_startup_inferior = NULL;
  nrom_ops.to_acknowledge_created_inferior = NULL;
  nrom_ops.to_clone_and_follow_inferior = NULL;
  nrom_ops.to_post_follow_inferior_by_clone = NULL;
  nrom_ops.to_insert_fork_catchpoint = NULL;
  nrom_ops.to_remove_fork_catchpoint = NULL;
  nrom_ops.to_insert_vfork_catchpoint = NULL;
  nrom_ops.to_remove_vfork_catchpoint = NULL;
  nrom_ops.to_has_forked = NULL;
  nrom_ops.to_has_vforked = NULL;
  nrom_ops.to_can_follow_vfork_prior_to_exec = NULL;
  nrom_ops.to_post_follow_vfork = NULL;
  nrom_ops.to_insert_exec_catchpoint = NULL;
  nrom_ops.to_remove_exec_catchpoint = NULL;
  nrom_ops.to_has_execd = NULL;
  nrom_ops.to_reported_exec_events_per_exec_call = NULL;
  nrom_ops.to_has_exited = NULL;
  nrom_ops.to_mourn_inferior = nrom_mourn;
  nrom_ops.to_can_run = NULL;
  nrom_ops.to_notice_signals = 0;
  nrom_ops.to_thread_alive = 0;
  nrom_ops.to_stop = 0;
  nrom_ops.to_pid_to_exec_file = NULL;
  nrom_ops.to_stratum = download_stratum;
  nrom_ops.DONT_USE = NULL;
  nrom_ops.to_has_all_memory = 1;
  nrom_ops.to_has_memory = 1;
  nrom_ops.to_has_stack = 1;
  nrom_ops.to_has_registers = 1;
  nrom_ops.to_has_execution = 0;
  nrom_ops.to_sections = NULL;
  nrom_ops.to_sections_end = NULL;
  nrom_ops.to_magic = OPS_MAGIC;
}

void
_initialize_remote_nrom (void)
{
  init_nrom_ops ();
  add_target (&nrom_ops);

  add_show_from_set (
  add_set_cmd ("nrom_load_port", no_class, var_zinteger, (char *) &load_port,
	       "Set the port to use for NetROM downloads\n", &setlist),
		      &showlist);

  add_show_from_set (
		      add_set_cmd ("nrom_control_port", no_class, var_zinteger, (char *) &control_port,
	    "Set the port to use for NetROM debugger services\n", &setlist),
		      &showlist);

  add_cmd ("nrom", no_class, nrom_passthru,
	   "Pass arguments as command to NetROM",
	   &cmdlist);
}
@


1.9.14.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d1 351
a351 351
// OBSOLETE /* Remote debugging with the XLNT Designs, Inc (XDI) NetROM.
// OBSOLETE    Copyright 1990, 1991, 1992, 1995, 1998, 1999, 2000
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE    Contributed by:
// OBSOLETE    Roger Moyers 
// OBSOLETE    XLNT Designs, Inc.
// OBSOLETE    15050 Avenue of Science, Suite 106
// OBSOLETE    San Diego, CA  92128
// OBSOLETE    (619)487-9320
// OBSOLETE    roger@@xlnt.com
// OBSOLETE    Adapted from work done at Cygnus Support in remote-nindy.c,
// OBSOLETE    later merged in by Stan Shebs at Cygnus.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "gdbcmd.h"
// OBSOLETE #include "serial.h"
// OBSOLETE #include "target.h"
// OBSOLETE 
// OBSOLETE /* Default ports used to talk with the NetROM.  */
// OBSOLETE 
// OBSOLETE #define DEFAULT_NETROM_LOAD_PORT    1236
// OBSOLETE #define DEFAULT_NETROM_CONTROL_PORT 1237
// OBSOLETE 
// OBSOLETE static void nrom_close (int quitting);
// OBSOLETE 
// OBSOLETE /* New commands.  */
// OBSOLETE 
// OBSOLETE static void nrom_passthru (char *, int);
// OBSOLETE 
// OBSOLETE /* We talk to the NetROM over these sockets.  */
// OBSOLETE 
// OBSOLETE static struct serial *load_desc = NULL;
// OBSOLETE static struct serial *ctrl_desc = NULL;
// OBSOLETE 
// OBSOLETE static int load_port = DEFAULT_NETROM_LOAD_PORT;
// OBSOLETE static int control_port = DEFAULT_NETROM_CONTROL_PORT;
// OBSOLETE 
// OBSOLETE static char nrom_hostname[100];
// OBSOLETE 
// OBSOLETE /* Forward data declaration. */
// OBSOLETE 
// OBSOLETE extern struct target_ops nrom_ops;
// OBSOLETE 
// OBSOLETE /* Scan input from the remote system, until STRING is found.  Print chars that
// OBSOLETE    don't match.  */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE expect (char *string)
// OBSOLETE {
// OBSOLETE   char *p = string;
// OBSOLETE   int c;
// OBSOLETE 
// OBSOLETE   immediate_quit++;
// OBSOLETE 
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       c = serial_readchar (ctrl_desc, 5);
// OBSOLETE 
// OBSOLETE       if (c == *p++)
// OBSOLETE 	{
// OBSOLETE 	  if (*p == '\0')
// OBSOLETE 	    {
// OBSOLETE 	      immediate_quit--;
// OBSOLETE 	      return 0;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  fputc_unfiltered (c, gdb_stdout);
// OBSOLETE 	  p = string;
// OBSOLETE 	  if (c == *p)
// OBSOLETE 	    p++;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nrom_kill (void)
// OBSOLETE {
// OBSOLETE   nrom_close (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct serial *
// OBSOLETE open_socket (char *name, int port)
// OBSOLETE {
// OBSOLETE   char sockname[100];
// OBSOLETE   struct serial *desc;
// OBSOLETE 
// OBSOLETE   sprintf (sockname, "%s:%d", name, port);
// OBSOLETE   desc = serial_open (sockname);
// OBSOLETE   if (!desc)
// OBSOLETE     perror_with_name (sockname);
// OBSOLETE 
// OBSOLETE   return desc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE load_cleanup (void)
// OBSOLETE {
// OBSOLETE   serial_close (load_desc);
// OBSOLETE   load_desc = NULL;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Download a file specified in ARGS to the netROM.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nrom_load (char *args, int fromtty)
// OBSOLETE {
// OBSOLETE   int fd, rd_amt, fsize;
// OBSOLETE   bfd *pbfd;
// OBSOLETE   asection *section;
// OBSOLETE   char *downloadstring = "download 0\n";
// OBSOLETE   struct cleanup *old_chain;
// OBSOLETE 
// OBSOLETE   /* Tell the netrom to get ready to download. */
// OBSOLETE   if (serial_write (ctrl_desc, downloadstring, strlen (downloadstring)))
// OBSOLETE     error ("nrom_load: control_send() of `%s' failed", downloadstring);
// OBSOLETE 
// OBSOLETE   expect ("Waiting for a connection...\n");
// OBSOLETE 
// OBSOLETE   load_desc = open_socket (nrom_hostname, load_port);
// OBSOLETE 
// OBSOLETE   old_chain = make_cleanup (load_cleanup, 0);
// OBSOLETE 
// OBSOLETE   pbfd = bfd_openr (args, 0);
// OBSOLETE 
// OBSOLETE   if (pbfd)
// OBSOLETE     {
// OBSOLETE       make_cleanup (bfd_close, pbfd);
// OBSOLETE 
// OBSOLETE       if (!bfd_check_format (pbfd, bfd_object))
// OBSOLETE 	error ("\"%s\": not in executable format: %s",
// OBSOLETE 	       args, bfd_errmsg (bfd_get_error ()));
// OBSOLETE 
// OBSOLETE       for (section = pbfd->sections; section; section = section->next)
// OBSOLETE 	{
// OBSOLETE 	  if (bfd_get_section_flags (pbfd, section) & SEC_ALLOC)
// OBSOLETE 	    {
// OBSOLETE 	      bfd_vma section_address;
// OBSOLETE 	      unsigned long section_size;
// OBSOLETE 	      const char *section_name;
// OBSOLETE 
// OBSOLETE 	      section_name = bfd_get_section_name (pbfd, section);
// OBSOLETE 	      section_address = bfd_get_section_vma (pbfd, section);
// OBSOLETE 	      section_size = bfd_section_size (pbfd, section);
// OBSOLETE 
// OBSOLETE 	      if (bfd_get_section_flags (pbfd, section) & SEC_LOAD)
// OBSOLETE 		{
// OBSOLETE 		  file_ptr fptr;
// OBSOLETE 
// OBSOLETE 		  printf_filtered ("[Loading section %s at %x (%d bytes)]\n",
// OBSOLETE 				   section_name, section_address,
// OBSOLETE 				   section_size);
// OBSOLETE 
// OBSOLETE 		  fptr = 0;
// OBSOLETE 
// OBSOLETE 		  while (section_size > 0)
// OBSOLETE 		    {
// OBSOLETE 		      char buffer[1024];
// OBSOLETE 		      int count;
// OBSOLETE 
// OBSOLETE 		      count = min (section_size, 1024);
// OBSOLETE 
// OBSOLETE 		      bfd_get_section_contents (pbfd, section, buffer, fptr,
// OBSOLETE 						count);
// OBSOLETE 
// OBSOLETE 		      serial_write (load_desc, buffer, count);
// OBSOLETE 		      section_address += count;
// OBSOLETE 		      fptr += count;
// OBSOLETE 		      section_size -= count;
// OBSOLETE 		    }
// OBSOLETE 		}
// OBSOLETE 	      else
// OBSOLETE 		/* BSS and such */
// OBSOLETE 		{
// OBSOLETE 		  printf_filtered ("[section %s: not loading]\n",
// OBSOLETE 				   section_name);
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     error ("\"%s\": Could not open", args);
// OBSOLETE 
// OBSOLETE   do_cleanups (old_chain);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Open a connection to the remote NetROM devices.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nrom_open (char *name, int from_tty)
// OBSOLETE {
// OBSOLETE   int errn;
// OBSOLETE 
// OBSOLETE   if (!name || strchr (name, '/') || strchr (name, ':'))
// OBSOLETE     error (
// OBSOLETE 	    "To open a NetROM connection, you must specify the hostname\n\
// OBSOLETE or IP address of the NetROM device you wish to use.");
// OBSOLETE 
// OBSOLETE   strcpy (nrom_hostname, name);
// OBSOLETE 
// OBSOLETE   target_preopen (from_tty);
// OBSOLETE 
// OBSOLETE   unpush_target (&nrom_ops);
// OBSOLETE 
// OBSOLETE   ctrl_desc = open_socket (nrom_hostname, control_port);
// OBSOLETE 
// OBSOLETE   push_target (&nrom_ops);
// OBSOLETE 
// OBSOLETE   if (from_tty)
// OBSOLETE     printf_filtered ("Connected to NetROM device \"%s\"\n", nrom_hostname);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Close out all files and local state before this target loses control. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nrom_close (int quitting)
// OBSOLETE {
// OBSOLETE   if (load_desc)
// OBSOLETE     serial_close (load_desc);
// OBSOLETE   if (ctrl_desc)
// OBSOLETE     serial_close (ctrl_desc);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Pass arguments directly to the NetROM. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nrom_passthru (char *args, int fromtty)
// OBSOLETE {
// OBSOLETE   char buf[1024];
// OBSOLETE 
// OBSOLETE   sprintf (buf, "%s\n", args);
// OBSOLETE   if (serial_write (ctrl_desc, buf, strlen (buf)))
// OBSOLETE     error ("nrom_reset: control_send() of `%s'failed", args);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nrom_mourn (void)
// OBSOLETE {
// OBSOLETE   unpush_target (&nrom_ops);
// OBSOLETE   generic_mourn_inferior ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Define the target vector. */
// OBSOLETE 
// OBSOLETE struct target_ops nrom_ops;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_nrom_ops (void)
// OBSOLETE {
// OBSOLETE   nrom_ops.to_shortname = "nrom";
// OBSOLETE   nrom_ops.to_longname = "Remote XDI `NetROM' target";
// OBSOLETE   nrom_ops.to_doc = "Remote debug using a NetROM over Ethernet";
// OBSOLETE   nrom_ops.to_open = nrom_open;
// OBSOLETE   nrom_ops.to_close = nrom_close;
// OBSOLETE   nrom_ops.to_attach = NULL;
// OBSOLETE   nrom_ops.to_post_attach = NULL;
// OBSOLETE   nrom_ops.to_require_attach = NULL;
// OBSOLETE   nrom_ops.to_detach = NULL;
// OBSOLETE   nrom_ops.to_require_detach = NULL;
// OBSOLETE   nrom_ops.to_resume = NULL;
// OBSOLETE   nrom_ops.to_wait = NULL;
// OBSOLETE   nrom_ops.to_post_wait = NULL;
// OBSOLETE   nrom_ops.to_fetch_registers = NULL;
// OBSOLETE   nrom_ops.to_store_registers = NULL;
// OBSOLETE   nrom_ops.to_prepare_to_store = NULL;
// OBSOLETE   nrom_ops.to_xfer_memory = NULL;
// OBSOLETE   nrom_ops.to_files_info = NULL;
// OBSOLETE   nrom_ops.to_insert_breakpoint = NULL;
// OBSOLETE   nrom_ops.to_remove_breakpoint = NULL;
// OBSOLETE   nrom_ops.to_terminal_init = NULL;
// OBSOLETE   nrom_ops.to_terminal_inferior = NULL;
// OBSOLETE   nrom_ops.to_terminal_ours_for_output = NULL;
// OBSOLETE   nrom_ops.to_terminal_ours = NULL;
// OBSOLETE   nrom_ops.to_terminal_info = NULL;
// OBSOLETE   nrom_ops.to_kill = nrom_kill;
// OBSOLETE   nrom_ops.to_load = nrom_load;
// OBSOLETE   nrom_ops.to_lookup_symbol = NULL;
// OBSOLETE   nrom_ops.to_create_inferior = NULL;
// OBSOLETE   nrom_ops.to_post_startup_inferior = NULL;
// OBSOLETE   nrom_ops.to_acknowledge_created_inferior = NULL;
// OBSOLETE   nrom_ops.to_clone_and_follow_inferior = NULL;
// OBSOLETE   nrom_ops.to_post_follow_inferior_by_clone = NULL;
// OBSOLETE   nrom_ops.to_insert_fork_catchpoint = NULL;
// OBSOLETE   nrom_ops.to_remove_fork_catchpoint = NULL;
// OBSOLETE   nrom_ops.to_insert_vfork_catchpoint = NULL;
// OBSOLETE   nrom_ops.to_remove_vfork_catchpoint = NULL;
// OBSOLETE   nrom_ops.to_has_forked = NULL;
// OBSOLETE   nrom_ops.to_has_vforked = NULL;
// OBSOLETE   nrom_ops.to_can_follow_vfork_prior_to_exec = NULL;
// OBSOLETE   nrom_ops.to_post_follow_vfork = NULL;
// OBSOLETE   nrom_ops.to_insert_exec_catchpoint = NULL;
// OBSOLETE   nrom_ops.to_remove_exec_catchpoint = NULL;
// OBSOLETE   nrom_ops.to_has_execd = NULL;
// OBSOLETE   nrom_ops.to_reported_exec_events_per_exec_call = NULL;
// OBSOLETE   nrom_ops.to_has_exited = NULL;
// OBSOLETE   nrom_ops.to_mourn_inferior = nrom_mourn;
// OBSOLETE   nrom_ops.to_can_run = NULL;
// OBSOLETE   nrom_ops.to_notice_signals = 0;
// OBSOLETE   nrom_ops.to_thread_alive = 0;
// OBSOLETE   nrom_ops.to_stop = 0;
// OBSOLETE   nrom_ops.to_pid_to_exec_file = NULL;
// OBSOLETE   nrom_ops.to_stratum = download_stratum;
// OBSOLETE   nrom_ops.DONT_USE = NULL;
// OBSOLETE   nrom_ops.to_has_all_memory = 1;
// OBSOLETE   nrom_ops.to_has_memory = 1;
// OBSOLETE   nrom_ops.to_has_stack = 1;
// OBSOLETE   nrom_ops.to_has_registers = 1;
// OBSOLETE   nrom_ops.to_has_execution = 0;
// OBSOLETE   nrom_ops.to_sections = NULL;
// OBSOLETE   nrom_ops.to_sections_end = NULL;
// OBSOLETE   nrom_ops.to_magic = OPS_MAGIC;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_remote_nrom (void)
// OBSOLETE {
// OBSOLETE   init_nrom_ops ();
// OBSOLETE   add_target (&nrom_ops);
// OBSOLETE 
// OBSOLETE   add_show_from_set (
// OBSOLETE   add_set_cmd ("nrom_load_port", no_class, var_zinteger, (char *) &load_port,
// OBSOLETE 	       "Set the port to use for NetROM downloads\n", &setlist),
// OBSOLETE 		      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set (
// OBSOLETE 		      add_set_cmd ("nrom_control_port", no_class, var_zinteger, (char *) &control_port,
// OBSOLETE 	    "Set the port to use for NetROM debugger services\n", &setlist),
// OBSOLETE 		      &showlist);
// OBSOLETE 
// OBSOLETE   add_cmd ("nrom", no_class, nrom_passthru,
// OBSOLETE 	   "Pass arguments as command to NetROM",
// OBSOLETE 	   &cmdlist);
// OBSOLETE }
@


1.8
log
@s/typedef serial_t/struct serial */
@
text
@d74 1
a74 1
      c = SERIAL_READCHAR (ctrl_desc, 5);
d107 1
a107 1
  desc = SERIAL_OPEN (sockname);
d117 1
a117 1
  SERIAL_CLOSE (load_desc);
d133 1
a133 1
  if (SERIAL_WRITE (ctrl_desc, downloadstring, strlen (downloadstring)))
d184 1
a184 1
		      SERIAL_WRITE (load_desc, buffer, count);
d237 1
a237 1
    SERIAL_CLOSE (load_desc);
d239 1
a239 1
    SERIAL_CLOSE (ctrl_desc);
d250 1
a250 1
  if (SERIAL_WRITE (ctrl_desc, buf, strlen (buf)))
@


1.7
log
@* target.h (target_ops): Removed to_core_file_to_sym_file vector
function.
* corelow.c (core_ops): Updated for above change.
* gnu-nat.c (core_ops): Likewise.
* inftarg.c (child_ops): Likewise.
* monitor.c (monitor_ops): Likewise.
* ppc-bdm.c (bdm_ppc_ops): Likewise.
* remote-adapt.c (adapt_ops): Likewise.
* remote-bug.c (bug_ops): Likewise.
* remote-e7000.c (e7000_ops): Likewise.
* remote-eb.c (eb_ops): Likewise.
* remote-es.c (es1800_ops, es1800_child_ops): Likewise.
* remote-mm.c (mm_ops): Likewise.
* remote-nindy.c (nindy_ops): Likewise.
* remote-nrom.c (nrom_ops): Likewise.
* remote-os9k.c (rombug_ops): Likewise.
* remote-rdp.c (remote_rdp_ops): Likewise.
* remote-sim.c (gdbsim_ops): Likewise.
* remote-st.c (st2000_ops): Likewise.
* v850ice.c (v850ice_ops): Likewise.
* target.c (cleanup_target): Likewise
(update_current_target): Likewise.
(setup_target_debug): Likewise
(debug_to_core_file_to_sym_file): Removed.

* corefile.c (core_file_command) [HPUXHPPA]: Removed code that
sets symbol file from information obtained from the core file.
* corelow.c (core_file_to_sym_file): Removed.
@
text
@d49 2
a50 2
static serial_t load_desc = NULL;
static serial_t ctrl_desc = NULL;
d100 1
a100 1
static serial_t
d104 1
a104 1
  serial_t desc;
@


1.6
log
@* arch-utils.c (#include "gdbthread.h"): Removed.
(#include "symfile.h"): Removed.
(XMALLOC): Removed unused macro.
* breakpoint.c (tbreak_command): Removed local declaration.
(awatch_command, do_enable_breakpoint, set_breakpoint_count):
Remove duplicate declarations.
(bpstat_should_step, bpstat_have_active_hw_watchpoints)
(remove_solib_event_breakpoints): Fix indentation botch.
* c-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* ch-exp.c (ch_terminal_match_float_literal, parse_expr)
(parse_primval, parse_untyped_expr, parse_opt_untyped_expr):
Removed duplicate declarations.
* ch-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* corefile.c (#include "frame.h"): Removed
(#include "symfile.h"): Removed.
(#include "language.h"): Removed.
* dbxread.c (#include "command.h"): Removed.
* environ.c (#include "gdbcore.h"): Removed.
* event-loop.c (#include "top.h"): Removed.
* f-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
(#include "typeprint.h"): Removed.
(#include "frame.h"): Removed.
* gdbtypes.h (print_type_scalar): Removed declaration.
* infcmd.c (#include "completer.h"): Removed.
* language.c (#include "frame.h"): Removed.
* m2-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
* m2-valprint.c (#include "valprint.h"): Removed.
* p-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* p-valprint.c (#include "typeprint.h"): Removed.
* parse.c (#include "linespec.h"): Removed.
* regcache.c (#include "frame.h"): Removed.
* remote.c (#include "frame.h"): Removed.
(getpkt_sane): Make static.
* source.c (#include "completer.h"): Removed.
* stack.c (#include "symfile.h"): Removed.
(#include "objfiles.h"): Removed.
* symfile.c (#include "completer.h"): Removed.
* tracepoint.c (#include "completer.h"): Removed.
* values.c (#include "frame.h"): Removed.
* varobj.c (#include "valprint.h"): Removed.
* wrapper.c (#include "frame.h"): Removed.

* memattr.c (create_mem_region): Removed unused variable.
* remote-nrom.c: Removed spurious semicolon after init_nrom_ops.
-------------------------------------------------------------------
@
text
@a319 1
  nrom_ops.to_core_file_to_sym_file = NULL;
@


1.5
log
@Update/correct copyright notices.
@
text
@d331 1
a331 1
};
@


1.4
log
@* dcache.c (dcache_info): Output a cache line's state vector so it
lines up under the data vector.

* dcache.c (dcache_read_line): New function.
(dcache_peek_byte): Use it.
(dcache_alloc): Return NULL if write of reclaimed cache line fails.
(dcache_peek_byte, dcache_poke_byte): Return failure if
dcache_alloc() returns a NULL data block pointer.
(dcache_xfer_memory): Don't force writeback unless we were writing.

* monitor.c (monitor_expect): Change places where immediate_quit
is set to 1 or 0 to increments and decrements respectively.  This
allows such changes to nest properly.
* ocd.c (ocd_start_remote): Likewise.
* remote-adapt.c (expect): Likewise.
* remote-array.c (expect): Likewise.
* remote-eb.c (expect): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-mips.c (mips_expect_timeout, mips_getstring): Likewise.
* remote-nrom.c (expect): Likewise.
* remote-os9k.c (expect): Likewise.
* remote-sds.c (sds_start_remote): Likewise.
* remote-st.c (expect): Likewise.
* remote-utils.c (sr_expect): Likewise.
* remote.c (remote_start_remote): Likewise.
* tracepoint.c (read_actions): Likewise.

* remote-mips.c (mips_getstring): Balance changes to immediate_quit.
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1995 Free Software Foundation, Inc.
@


1.3
log
@Protoization.
@
text
@d69 1
a69 1
  immediate_quit = 1;
d79 1
a79 2
	      immediate_quit = 0;

@


1.2
log
@PARAMS removal.
@
text
@d64 1
a64 2
expect (string)
     char *string;
d95 1
a95 1
nrom_kill ()
d101 1
a101 3
open_socket (name, port)
     char *name;
     int port;
d115 1
a115 1
load_cleanup ()
d124 1
a124 3
nrom_load (args, fromtty)
     char *args;
     int fromtty;
d208 1
a208 3
nrom_open (name, from_tty)
     char *name;
     int from_tty;
d234 1
a234 2
nrom_close (quitting)
     int quitting;
d245 1
a245 3
nrom_passthru (args, fromtty)
     char *args;
     int fromtty;
d255 1
a255 1
nrom_mourn ()
d334 1
a334 1
_initialize_remote_nrom ()
@


1.1
log
@Initial revision
@
text
@d4 6
a9 6
	 Roger Moyers 
	 XLNT Designs, Inc.
	 15050 Avenue of Science, Suite 106
	 San Diego, CA  92128
	 (619)487-9320
	 roger@@xlnt.com
d13 1
a13 1
This file is part of GDB.
d15 14
a28 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d40 1
a40 1
static void nrom_close PARAMS ((int quitting));
d44 1
a44 1
static void nrom_passthru PARAMS ((char *, int));
d153 1
a153 1
      if (!bfd_check_format (pbfd, bfd_object)) 
d157 1
a157 1
      for (section = pbfd->sections; section; section = section->next) 
d183 1
a183 1
		      
d195 2
a196 1
	      else			/* BSS and such */
d221 1
a221 1
"To open a NetROM connection, you must specify the hostname\n\
d265 2
a266 2
nrom_mourn() 
{ 
d273 1
a273 1
struct target_ops nrom_ops ;
d275 2
a276 2
static void 
init_nrom_ops(void)
d278 6
a283 6
  nrom_ops.to_shortname =   "nrom";	
  nrom_ops.to_longname =   "Remote XDI `NetROM' target";
  nrom_ops.to_doc =   "Remote debug using a NetROM over Ethernet"; 
  nrom_ops.to_open =   nrom_open;		
  nrom_ops.to_close =   nrom_close;		
  nrom_ops.to_attach =   NULL;
d285 22
a306 22
  nrom_ops.to_require_attach = NULL;			
  nrom_ops.to_detach =   NULL;
  nrom_ops.to_require_detach = NULL;	
  nrom_ops.to_resume =   NULL;			
  nrom_ops.to_wait  =   NULL;
  nrom_ops.to_post_wait = NULL;		
  nrom_ops.to_fetch_registers  =   NULL;
  nrom_ops.to_store_registers  =   NULL;
  nrom_ops.to_prepare_to_store =   NULL;
  nrom_ops.to_xfer_memory  =   NULL;	
  nrom_ops.to_files_info  =   NULL;
  nrom_ops.to_insert_breakpoint =   NULL;
  nrom_ops.to_remove_breakpoint =   NULL;
  nrom_ops.to_terminal_init  =   NULL;	
  nrom_ops.to_terminal_inferior =   NULL;
  nrom_ops.to_terminal_ours_for_output =   NULL;
  nrom_ops.to_terminal_ours  =   NULL;	
  nrom_ops.to_terminal_info  =   NULL;	
  nrom_ops.to_kill  =   nrom_kill;
  nrom_ops.to_load  =   nrom_load;
  nrom_ops.to_lookup_symbol =   NULL;	
  nrom_ops.to_create_inferior =   NULL;
d318 1
a318 1
  nrom_ops.to_post_follow_vfork = NULL;	
d324 5
a328 5
  nrom_ops.to_mourn_inferior =   nrom_mourn;
  nrom_ops.to_can_run  =   NULL;
  nrom_ops.to_notice_signals =   0;
  nrom_ops.to_thread_alive  =   0;
  nrom_ops.to_stop  =   0;
d331 10
a340 10
  nrom_ops.to_stratum =   download_stratum;
  nrom_ops.DONT_USE =   NULL;			
  nrom_ops.to_has_all_memory =   1;		
  nrom_ops.to_has_memory =   1;			
  nrom_ops.to_has_stack =   1;			
  nrom_ops.to_has_registers =   1;		
  nrom_ops.to_has_execution =   0;		
  nrom_ops.to_sections =   NULL;		
  nrom_ops.to_sections_end =   NULL;		
  nrom_ops.to_magic =   OPS_MAGIC ;		
d346 1
a346 1
  init_nrom_ops() ;
d350 3
a352 3
    add_set_cmd ("nrom_load_port", no_class, var_zinteger, (char *)&load_port,
		 "Set the port to use for NetROM downloads\n", &setlist),
		     &showlist);
d355 3
a357 3
    add_set_cmd ("nrom_control_port", no_class, var_zinteger, (char *)&control_port,
		 "Set the port to use for NetROM debugger services\n", &setlist),
		     &showlist);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 6
a9 6
   Roger Moyers 
   XLNT Designs, Inc.
   15050 Avenue of Science, Suite 106
   San Diego, CA  92128
   (619)487-9320
   roger@@xlnt.com
d13 1
a13 1
   This file is part of GDB.
d15 13
a27 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d152 1
a152 1
      if (!bfd_check_format (pbfd, bfd_object))
d156 1
a156 1
      for (section = pbfd->sections; section; section = section->next)
d182 1
a182 1

d194 1
a194 2
	      else
		/* BSS and such */
d219 1
a219 1
	    "To open a NetROM connection, you must specify the hostname\n\
d263 2
a264 2
nrom_mourn ()
{
d271 1
a271 1
struct target_ops nrom_ops;
d273 2
a274 2
static void
init_nrom_ops (void)
d276 6
a281 6
  nrom_ops.to_shortname = "nrom";
  nrom_ops.to_longname = "Remote XDI `NetROM' target";
  nrom_ops.to_doc = "Remote debug using a NetROM over Ethernet";
  nrom_ops.to_open = nrom_open;
  nrom_ops.to_close = nrom_close;
  nrom_ops.to_attach = NULL;
d283 22
a304 22
  nrom_ops.to_require_attach = NULL;
  nrom_ops.to_detach = NULL;
  nrom_ops.to_require_detach = NULL;
  nrom_ops.to_resume = NULL;
  nrom_ops.to_wait = NULL;
  nrom_ops.to_post_wait = NULL;
  nrom_ops.to_fetch_registers = NULL;
  nrom_ops.to_store_registers = NULL;
  nrom_ops.to_prepare_to_store = NULL;
  nrom_ops.to_xfer_memory = NULL;
  nrom_ops.to_files_info = NULL;
  nrom_ops.to_insert_breakpoint = NULL;
  nrom_ops.to_remove_breakpoint = NULL;
  nrom_ops.to_terminal_init = NULL;
  nrom_ops.to_terminal_inferior = NULL;
  nrom_ops.to_terminal_ours_for_output = NULL;
  nrom_ops.to_terminal_ours = NULL;
  nrom_ops.to_terminal_info = NULL;
  nrom_ops.to_kill = nrom_kill;
  nrom_ops.to_load = nrom_load;
  nrom_ops.to_lookup_symbol = NULL;
  nrom_ops.to_create_inferior = NULL;
d316 1
a316 1
  nrom_ops.to_post_follow_vfork = NULL;
d322 5
a326 5
  nrom_ops.to_mourn_inferior = nrom_mourn;
  nrom_ops.to_can_run = NULL;
  nrom_ops.to_notice_signals = 0;
  nrom_ops.to_thread_alive = 0;
  nrom_ops.to_stop = 0;
d329 10
a338 10
  nrom_ops.to_stratum = download_stratum;
  nrom_ops.DONT_USE = NULL;
  nrom_ops.to_has_all_memory = 1;
  nrom_ops.to_has_memory = 1;
  nrom_ops.to_has_stack = 1;
  nrom_ops.to_has_registers = 1;
  nrom_ops.to_has_execution = 0;
  nrom_ops.to_sections = NULL;
  nrom_ops.to_sections_end = NULL;
  nrom_ops.to_magic = OPS_MAGIC;
d344 1
a344 1
  init_nrom_ops ();
d348 3
a350 3
  add_set_cmd ("nrom_load_port", no_class, var_zinteger, (char *) &load_port,
	       "Set the port to use for NetROM downloads\n", &setlist),
		      &showlist);
d353 3
a355 3
		      add_set_cmd ("nrom_control_port", no_class, var_zinteger, (char *) &control_port,
	    "Set the port to use for NetROM debugger services\n", &setlist),
		      &showlist);
@

