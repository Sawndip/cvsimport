head	1.4;
access;
symbols
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.4
	gdb-1999-10-25:1.1.1.4
	gdb-1999-10-18:1.1.1.4
	gdb-1999-10-11:1.1.1.4
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.4
	gdb-1999-09-13:1.1.1.4
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.4
date	2001.02.08.06.30.24;	author cagney;	state dead;
branches;
next	1.3;

1.3
date	2000.12.15.01.01.46;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.45;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.23.53;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.06.28.16.00.22;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.05.11;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Remove configurations marked as obsolete in 5.0.
@
text
@/* OBSOLETE /* Convex host-dependent code for GDB. */
/* OBSOLETE    Copyright 1990, 1991, 1992 Free Software Foundation, Inc. */
/* OBSOLETE  */
/* OBSOLETE This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE This program is free software; you can redistribute it and/or modify */
/* OBSOLETE it under the terms of the GNU General Public License as published by */
/* OBSOLETE the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE This program is distributed in the hope that it will be useful, */
/* OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE You should have received a copy of the GNU General Public License */
/* OBSOLETE along with this program; if not, write to the Free Software */
/* OBSOLETE Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "command.h" */
/* OBSOLETE #include "symtab.h" */
/* OBSOLETE #include "value.h" */
/* OBSOLETE #include "frame.h" */
/* OBSOLETE #include "inferior.h" */
/* OBSOLETE #include "gdb_wait.h" */
/* OBSOLETE  */
/* OBSOLETE #include <signal.h> */
/* OBSOLETE #include <fcntl.h> */
/* OBSOLETE #include "gdbcore.h" */
/* OBSOLETE  */
/* OBSOLETE #include <sys/param.h> */
/* OBSOLETE #include <sys/dir.h> */
/* OBSOLETE #include <sys/user.h> */
/* OBSOLETE #include <sys/ioctl.h> */
/* OBSOLETE #include <sys/pcntl.h> */
/* OBSOLETE #include <sys/thread.h> */
/* OBSOLETE #include <sys/proc.h> */
/* OBSOLETE #include <sys/file.h> */
/* OBSOLETE #include "gdb_stat.h" */
/* OBSOLETE #include <sys/mman.h> */
/* OBSOLETE  */
/* OBSOLETE #include <convex/vmparam.h> */
/* OBSOLETE #include <convex/filehdr.h> */
/* OBSOLETE #include <convex/opthdr.h> */
/* OBSOLETE #include <convex/scnhdr.h> */
/* OBSOLETE #include <convex/core.h> */
/* OBSOLETE  */
/* OBSOLETE /* Per-thread data, read from the inferior at each stop and written */
/* OBSOLETE    back at each resume.  *x/ */
/* OBSOLETE  */
/* OBSOLETE /* Number of active threads. */
/* OBSOLETE    Tables are valid for thread numbers less than this.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int n_threads; */
/* OBSOLETE  */
/* OBSOLETE #define MAXTHREADS 8 */
/* OBSOLETE              */
/* OBSOLETE /* Thread state.  The remaining data is valid only if this is PI_TALIVE.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int thread_state[MAXTHREADS]; */
/* OBSOLETE  */
/* OBSOLETE /* Stop pc, signal, signal subcode *x/ */
/* OBSOLETE  */
/* OBSOLETE static int thread_pc[MAXTHREADS]; */
/* OBSOLETE static int thread_signal[MAXTHREADS]; */
/* OBSOLETE static int thread_sigcode[MAXTHREADS];       */
/* OBSOLETE  */
/* OBSOLETE /* Thread registers. */
/* OBSOLETE    If thread is selected, the regs are in registers[] instead.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static char thread_regs[MAXTHREADS][REGISTER_BYTES]; */
/* OBSOLETE  */
/* OBSOLETE /* 1 if the top frame on the thread's stack was a context frame, */
/* OBSOLETE    meaning that the kernel is up to something and we should not */
/* OBSOLETE    touch the thread at all except to resume it.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static char thread_is_in_kernel[MAXTHREADS]; */
/* OBSOLETE  */
/* OBSOLETE /* The currently selected thread's number.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int inferior_thread; */
/* OBSOLETE  */
/* OBSOLETE /* Inferior process's file handle and a process control block */
/* OBSOLETE    to feed args to ioctl with.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int inferior_fd; */
/* OBSOLETE static struct pcntl ps; */
/* OBSOLETE  */
/* OBSOLETE /* SOFF file headers for exec or core file.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static FILEHDR filehdr; */
/* OBSOLETE static OPTHDR opthdr; */
/* OBSOLETE static SCNHDR scnhdr; */
/* OBSOLETE  */
/* OBSOLETE /* Address maps constructed from section headers of exec and core files. */
/* OBSOLETE    Defines process address -> file address translation.  *x/ */
/* OBSOLETE  */
/* OBSOLETE struct pmap  */
/* OBSOLETE { */
/* OBSOLETE     long mem_addr;          /* process start address *x/ */
/* OBSOLETE     long mem_end;           /* process end+1 address *x/ */
/* OBSOLETE     long file_addr;         /* file start address *x/ */
/* OBSOLETE     long thread;            /* -1 shared; 0,1,... thread-local *x/ */
/* OBSOLETE     long type;                      /* S_TEXT S_DATA S_BSS S_TBSS etc *x/ */
/* OBSOLETE     long which;                     /* used to sort map for info files *x/ */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE static int n_exec, n_core; */
/* OBSOLETE static struct pmap exec_map[100]; */
/* OBSOLETE static struct pmap core_map[100]; */
/* OBSOLETE  */
/* OBSOLETE /* Offsets in the core file of core_context and core_tcontext blocks.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int context_offset; */
/* OBSOLETE static int tcontext_offset[MAXTHREADS]; */
/* OBSOLETE  */
/* OBSOLETE /* Core file control blocks.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static struct core_context_v70 c; */
/* OBSOLETE static struct core_tcontext_v70 tc; */
/* OBSOLETE static struct user u; */
/* OBSOLETE static thread_t th; */
/* OBSOLETE static proc_t pr; */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Vector and communication registers from core dump or from inferior. */
/* OBSOLETE    These are read on demand, ie, not normally valid.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static struct vecst vector_registers; */
/* OBSOLETE static struct creg_ctx comm_registers; */
/* OBSOLETE  */
/* OBSOLETE /* Flag, set on a vanilla CONT command and cleared when the inferior */
/* OBSOLETE    is continued.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int all_continue; */
/* OBSOLETE  */
/* OBSOLETE /* Flag, set when the inferior is continued by a vanilla CONT command, */
/* OBSOLETE    cleared if it is continued for any other purpose.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int thread_switch_ok; */
/* OBSOLETE  */
/* OBSOLETE /* Stack of signals recieved from threads but not yet delivered to gdb.  *x/ */
/* OBSOLETE  */
/* OBSOLETE struct threadpid  */
/* OBSOLETE { */
/* OBSOLETE     int pid; */
/* OBSOLETE     int thread; */
/* OBSOLETE     int signo; */
/* OBSOLETE     int subsig; */
/* OBSOLETE     int pc; */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE static struct threadpid signal_stack_bot[100]; */
/* OBSOLETE static struct threadpid *signal_stack = signal_stack_bot; */
/* OBSOLETE  */
/* OBSOLETE /* How to detect empty stack -- bottom frame is all zero.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define signal_stack_is_empty() (signal_stack->pid == 0) */
/* OBSOLETE  */
/* OBSOLETE /* Mode controlled by SET PIPE command, controls the psw SEQ bit */
/* OBSOLETE    which forces each instruction to complete before the next one starts.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int sequential = 0; */
/* OBSOLETE  */
/* OBSOLETE /* Mode controlled by the SET PARALLEL command.  Values are: */
/* OBSOLETE    0  concurrency limit 1 thread, dynamic scheduling */
/* OBSOLETE    1  no concurrency limit, dynamic scheduling */
/* OBSOLETE    2  no concurrency limit, fixed scheduling  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int parallel = 1; */
/* OBSOLETE  */
/* OBSOLETE /* Mode controlled by SET BASE command, output radix for unformatted */
/* OBSOLETE    integer typeout, as in argument lists, aggregates, and so on. */
/* OBSOLETE    Zero means guess whether it's an address (hex) or not (decimal).  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int output_radix = 0; */
/* OBSOLETE  */
/* OBSOLETE /* Signal subcode at last thread stop.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int stop_sigcode; */
/* OBSOLETE  */
/* OBSOLETE /* Hack, see wait() below.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int exec_trap_timer; */
/* OBSOLETE  */
/* OBSOLETE #include "gdbcmd.h" */
/* OBSOLETE  */
/* OBSOLETE static struct type *vector_type (); */
/* OBSOLETE static long *read_vector_register (); */
/* OBSOLETE static long *read_vector_register_1 (); */
/* OBSOLETE static void write_vector_register (); */
/* OBSOLETE static ULONGEST read_comm_register (); */
/* OBSOLETE static void write_comm_register (); */
/* OBSOLETE static void convex_cont_command (); */
/* OBSOLETE static void thread_continue (); */
/* OBSOLETE static void select_thread (); */
/* OBSOLETE static void scan_stack (); */
/* OBSOLETE static void set_fixed_scheduling (); */
/* OBSOLETE static char *subsig_name (); */
/* OBSOLETE static void psw_info (); */
/* OBSOLETE static sig_noop (); */
/* OBSOLETE static ptr_cmp (); */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Execute ptrace.  Convex V7 replaced ptrace with pattach. */
/* OBSOLETE    Allow ptrace (0) as a no-op.  *x/ */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE call_ptrace (request, pid, procaddr, buf) */
/* OBSOLETE      int request, pid; */
/* OBSOLETE      PTRACE_ARG3_TYPE procaddr; */
/* OBSOLETE      int buf; */
/* OBSOLETE { */
/* OBSOLETE   if (request == 0) */
/* OBSOLETE     return; */
/* OBSOLETE   error ("no ptrace"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Replacement for system execle routine. */
/* OBSOLETE    Convert it to an equivalent exect, which pattach insists on.  *x/ */
/* OBSOLETE  */
/* OBSOLETE execle (name, argv) */
/* OBSOLETE      char *name, *argv; */
/* OBSOLETE { */
/* OBSOLETE   char ***envp = (char ***) &argv; */
/* OBSOLETE   while (*envp++) ; */
/* OBSOLETE  */
/* OBSOLETE   signal (SIGTRAP, sig_noop); */
/* OBSOLETE   exect (name, &argv, *envp); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Stupid handler for stupid trace trap that otherwise causes */
/* OBSOLETE    startup to stupidly hang.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static sig_noop ()  */
/* OBSOLETE {} */
/* OBSOLETE  */
/* OBSOLETE /* Read registers from inferior into registers[] array. */
/* OBSOLETE    For convex, they are already there, read in when the inferior stops.  *x/ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE fetch_inferior_registers (regno) */
/* OBSOLETE      int regno; */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Store our register values back into the inferior. */
/* OBSOLETE    For Convex, do this only once, right before resuming inferior.  *x/ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE store_inferior_registers (regno) */
/* OBSOLETE      int regno; */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Copy LEN bytes from inferior's memory starting at MEMADDR */
/* OBSOLETE    to debugger memory starting at MYADDR.  */
/* OBSOLETE    On failure (cannot read from inferior, usually because address is out */
/* OBSOLETE    of bounds) returns the value of errno. *x/ */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE read_inferior_memory (memaddr, myaddr, len) */
/* OBSOLETE      CORE_ADDR memaddr; */
/* OBSOLETE      char *myaddr; */
/* OBSOLETE      int len; */
/* OBSOLETE { */
/* OBSOLETE   errno = 0; */
/* OBSOLETE   while (len > 0) */
/* OBSOLETE     { */
/* OBSOLETE       /* little-known undocumented max request size *x/ */
/* OBSOLETE       int i = (len < 12288) ? len : 12288; */
/* OBSOLETE  */
/* OBSOLETE       lseek (inferior_fd, memaddr, 0); */
/* OBSOLETE       read (inferior_fd, myaddr, i); */
/* OBSOLETE  */
/* OBSOLETE       memaddr += i; */
/* OBSOLETE       myaddr += i; */
/* OBSOLETE       len -= i; */
/* OBSOLETE     } */
/* OBSOLETE   if (errno)  */
/* OBSOLETE     memset (myaddr, '\0', len); */
/* OBSOLETE   return errno; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Copy LEN bytes of data from debugger memory at MYADDR */
/* OBSOLETE    to inferior's memory at MEMADDR. */
/* OBSOLETE    Returns errno on failure (cannot write the inferior) *x/ */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE write_inferior_memory (memaddr, myaddr, len) */
/* OBSOLETE      CORE_ADDR memaddr; */
/* OBSOLETE      char *myaddr; */
/* OBSOLETE      int len; */
/* OBSOLETE { */
/* OBSOLETE   errno = 0; */
/* OBSOLETE   lseek (inferior_fd, memaddr, 0); */
/* OBSOLETE   write (inferior_fd, myaddr, len); */
/* OBSOLETE   return errno; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Here from create_inferior when the inferior process has been created */
/* OBSOLETE    and started up.  We must do a pattach to grab it for debugging. */
/* OBSOLETE  */
/* OBSOLETE    Also, intercept the CONT command by altering its dispatch address.  *x/ */
/* OBSOLETE /* FIXME: This used to be called from a macro CREATE_INFERIOR_HOOK. */
/* OBSOLETE    But now init_trace_fun is in the same place.  So re-write this to */
/* OBSOLETE    use the init_trace_fun (making convex a debugging target).  *x/ */
/* OBSOLETE  */
/* OBSOLETE create_inferior_hook (pid) */
/* OBSOLETE     int pid; */
/* OBSOLETE { */
/* OBSOLETE   static char cont[] = "cont"; */
/* OBSOLETE   static char cont1[] = "c"; */
/* OBSOLETE   char *linep = cont; */
/* OBSOLETE   char *linep1 = cont1; */
/* OBSOLETE   char **line = &linep; */
/* OBSOLETE   char **line1 = &linep1; */
/* OBSOLETE   struct cmd_list_element *c; */
/* OBSOLETE  */
/* OBSOLETE   c = lookup_cmd (line, cmdlist, "", 0); */
/* OBSOLETE   c->function = convex_cont_command; */
/* OBSOLETE   c = lookup_cmd (line1, cmdlist, "", 0); */
/* OBSOLETE   c->function = convex_cont_command; */
/* OBSOLETE  */
/* OBSOLETE   inferior_fd = pattach (pid, O_EXCL); */
/* OBSOLETE   if (inferior_fd < 0) */
/* OBSOLETE     perror_with_name ("pattach"); */
/* OBSOLETE   inferior_thread = 0; */
/* OBSOLETE   set_fixed_scheduling (pid, parallel == 2); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Attach process PID for debugging.  *x/ */
/* OBSOLETE  */
/* OBSOLETE attach (pid) */
/* OBSOLETE     int pid; */
/* OBSOLETE { */
/* OBSOLETE   int fd = pattach (pid, O_EXCL); */
/* OBSOLETE   if (fd < 0) */
/* OBSOLETE     perror_with_name ("pattach"); */
/* OBSOLETE   attach_flag = 1; */
/* OBSOLETE   /* wait for strange kernel reverberations to go away *x/ */
/* OBSOLETE   sleep (1); */
/* OBSOLETE  */
/* OBSOLETE   setpgrp (pid, pid); */
/* OBSOLETE  */
/* OBSOLETE   inferior_fd = fd; */
/* OBSOLETE   inferior_thread = 0; */
/* OBSOLETE   return pid; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Stop debugging the process whose number is PID */
/* OBSOLETE    and continue it with signal number SIGNAL. */
/* OBSOLETE    SIGNAL = 0 means just continue it.  *x/ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE detach (signal) */
/* OBSOLETE      int signal; */
/* OBSOLETE { */
/* OBSOLETE   signal_stack = signal_stack_bot; */
/* OBSOLETE   thread_continue (-1, 0, signal); */
/* OBSOLETE   ioctl (inferior_fd, PIXDETACH, &ps); */
/* OBSOLETE   close (inferior_fd); */
/* OBSOLETE   inferior_fd = 0; */
/* OBSOLETE   attach_flag = 0; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Kill off the inferior process.  *x/ */
/* OBSOLETE  */
/* OBSOLETE kill_inferior () */
/* OBSOLETE { */
/* OBSOLETE   if (inferior_pid == 0) */
/* OBSOLETE     return; */
/* OBSOLETE   ioctl (inferior_fd, PIXTERMINATE, 0); */
/* OBSOLETE   wait (0); */
/* OBSOLETE   target_mourn_inferior (); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Read vector register REG, and return a pointer to the value.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static long * */
/* OBSOLETE read_vector_register (reg) */
/* OBSOLETE     int reg; */
/* OBSOLETE { */
/* OBSOLETE   if (have_inferior_p ()) */
/* OBSOLETE     { */
/* OBSOLETE       errno = 0; */
/* OBSOLETE       ps.pi_buffer = (char *) &vector_registers; */
/* OBSOLETE       ps.pi_nbytes = sizeof vector_registers; */
/* OBSOLETE       ps.pi_offset = 0; */
/* OBSOLETE       ps.pi_thread = inferior_thread; */
/* OBSOLETE       ioctl (inferior_fd, PIXRDVREGS, &ps); */
/* OBSOLETE       if (errno) */
/* OBSOLETE     memset (&vector_registers, '\0', sizeof vector_registers); */
/* OBSOLETE     } */
/* OBSOLETE   else if (corechan >= 0) */
/* OBSOLETE     { */
/* OBSOLETE       lseek (corechan, tcontext_offset[inferior_thread], 0); */
/* OBSOLETE       if (myread (corechan, &tc, sizeof tc) < 0) */
/* OBSOLETE     perror_with_name (corefile); */
/* OBSOLETE       lseek (corechan, tc.core_thread_p, 0); */
/* OBSOLETE       if (myread (corechan, &th, sizeof th) < 0) */
/* OBSOLETE     perror_with_name (corefile); */
/* OBSOLETE       lseek (corechan, tc.core_vregs_p, 0); */
/* OBSOLETE       if (myread (corechan, &vector_registers, 16*128) < 0) */
/* OBSOLETE     perror_with_name (corefile); */
/* OBSOLETE       vector_registers.vm[0] = th.t_vect_ctx.vc_vm[0]; */
/* OBSOLETE       vector_registers.vm[1] = th.t_vect_ctx.vc_vm[1]; */
/* OBSOLETE       vector_registers.vls = th.t_vect_ctx.vc_vls; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   return read_vector_register_1 (reg); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Return a pointer to vector register REG, which must already have been */
/* OBSOLETE    fetched from the inferior or core file.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static long * */
/* OBSOLETE read_vector_register_1 (reg)  */
/* OBSOLETE     int reg; */
/* OBSOLETE { */
/* OBSOLETE   switch (reg) */
/* OBSOLETE     { */
/* OBSOLETE     case VM_REGNUM: */
/* OBSOLETE       return (long *) vector_registers.vm; */
/* OBSOLETE     case VS_REGNUM: */
/* OBSOLETE       return (long *) &vector_registers.vls; */
/* OBSOLETE     case VL_REGNUM: */
/* OBSOLETE       return 1 + (long *) &vector_registers.vls; */
/* OBSOLETE     default: */
/* OBSOLETE       return (long *) &vector_registers.vr[reg]; */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Write vector register REG, element ELEMENT, new value VAL. */
/* OBSOLETE    NB: must use read-modify-write on the entire vector state, */
/* OBSOLETE    since pattach does not do offsetted writes correctly.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE write_vector_register (reg, element, val) */
/* OBSOLETE     int reg, element; */
/* OBSOLETE     ULONGEST val; */
/* OBSOLETE { */
/* OBSOLETE   if (have_inferior_p ()) */
/* OBSOLETE     { */
/* OBSOLETE       errno = 0; */
/* OBSOLETE       ps.pi_thread = inferior_thread; */
/* OBSOLETE       ps.pi_offset = 0; */
/* OBSOLETE       ps.pi_buffer = (char *) &vector_registers; */
/* OBSOLETE       ps.pi_nbytes = sizeof vector_registers; */
/* OBSOLETE  */
/* OBSOLETE       ioctl (inferior_fd, PIXRDVREGS, &ps); */
/* OBSOLETE  */
/* OBSOLETE       switch (reg) */
/* OBSOLETE     { */
/* OBSOLETE     case VL_REGNUM: */
/* OBSOLETE       vector_registers.vls = */
/* OBSOLETE         (vector_registers.vls & 0xffffffff00000000LL) */
/* OBSOLETE           + (unsigned long) val; */
/* OBSOLETE       break; */
/* OBSOLETE  */
/* OBSOLETE     case VS_REGNUM: */
/* OBSOLETE       vector_registers.vls = */
/* OBSOLETE         (val << 32) + (unsigned long) vector_registers.vls; */
/* OBSOLETE       break; */
/* OBSOLETE          */
/* OBSOLETE     default: */
/* OBSOLETE       vector_registers.vr[reg].el[element] = val; */
/* OBSOLETE       break; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE       ioctl (inferior_fd, PIXWRVREGS, &ps); */
/* OBSOLETE  */
/* OBSOLETE       if (errno) */
/* OBSOLETE     perror_with_name ("writing vector register"); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Return the contents of communication register NUM.  *x/  */
/* OBSOLETE  */
/* OBSOLETE static ULONGEST  */
/* OBSOLETE read_comm_register (num) */
/* OBSOLETE      int num; */
/* OBSOLETE { */
/* OBSOLETE   if (have_inferior_p ()) */
/* OBSOLETE     { */
/* OBSOLETE       ps.pi_buffer = (char *) &comm_registers; */
/* OBSOLETE       ps.pi_nbytes = sizeof comm_registers; */
/* OBSOLETE       ps.pi_offset = 0; */
/* OBSOLETE       ps.pi_thread = inferior_thread; */
/* OBSOLETE       ioctl (inferior_fd, PIXRDCREGS, &ps); */
/* OBSOLETE     } */
/* OBSOLETE   return comm_registers.crreg.r4[num]; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Store a new value VAL into communication register NUM.   */
/* OBSOLETE    NB: Must use read-modify-write on the whole comm register set */
/* OBSOLETE    since pattach does not do offsetted writes correctly.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE write_comm_register (num, val) */
/* OBSOLETE      int num; */
/* OBSOLETE      ULONGEST val; */
/* OBSOLETE { */
/* OBSOLETE   if (have_inferior_p ()) */
/* OBSOLETE     { */
/* OBSOLETE       ps.pi_buffer = (char *) &comm_registers; */
/* OBSOLETE       ps.pi_nbytes = sizeof comm_registers; */
/* OBSOLETE       ps.pi_offset = 0; */
/* OBSOLETE       ps.pi_thread = inferior_thread; */
/* OBSOLETE       ioctl (inferior_fd, PIXRDCREGS, &ps); */
/* OBSOLETE       comm_registers.crreg.r4[num] = val; */
/* OBSOLETE       ioctl (inferior_fd, PIXWRCREGS, &ps); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Resume execution of the inferior process. */
/* OBSOLETE    If STEP is nonzero, single-step it. */
/* OBSOLETE    If SIGNAL is nonzero, give it that signal.  *x/ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE resume (step, signal) */
/* OBSOLETE      int step; */
/* OBSOLETE      int signal; */
/* OBSOLETE { */
/* OBSOLETE   errno = 0; */
/* OBSOLETE   if (step || signal) */
/* OBSOLETE     thread_continue (inferior_thread, step, signal); */
/* OBSOLETE   else */
/* OBSOLETE     thread_continue (-1, 0, 0); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Maybe resume some threads. */
/* OBSOLETE    THREAD is which thread to resume, or -1 to resume them all. */
/* OBSOLETE    STEP and SIGNAL are as in resume. */
/* OBSOLETE  */
/* OBSOLETE    Global variable ALL_CONTINUE is set when we are here to do a */
/* OBSOLETE    `cont' command; otherwise we may be doing `finish' or a call or */
/* OBSOLETE    something else that will not tolerate an automatic thread switch. */
/* OBSOLETE  */
/* OBSOLETE    If there are stopped threads waiting to deliver signals, and */
/* OBSOLETE    ALL_CONTINUE, do not actually resume anything.  gdb will do a wait */
/* OBSOLETE    and see one of the stopped threads in the queue.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE thread_continue (thread, step, signal) */
/* OBSOLETE      int thread, step, signal; */
/* OBSOLETE { */
/* OBSOLETE   int n; */
/* OBSOLETE  */
/* OBSOLETE   /* If we are to continue all threads, but not for the CONTINUE command, */
/* OBSOLETE      pay no attention and continue only the selected thread.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (thread < 0 && ! all_continue) */
/* OBSOLETE     thread = inferior_thread; */
/* OBSOLETE  */
/* OBSOLETE   /* If we are not stepping, we have now executed the continue part */
/* OBSOLETE      of a CONTINUE command.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (! step) */
/* OBSOLETE     all_continue = 0; */
/* OBSOLETE  */
/* OBSOLETE   /* Allow wait() to switch threads if this is an all-out continue.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   thread_switch_ok = thread < 0; */
/* OBSOLETE  */
/* OBSOLETE   /* If there are threads queued up, don't resume.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (thread_switch_ok && ! signal_stack_is_empty ()) */
/* OBSOLETE     return; */
/* OBSOLETE  */
/* OBSOLETE   /* OK, do it.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   for (n = 0; n < n_threads; n++) */
/* OBSOLETE     if (thread_state[n] == PI_TALIVE) */
/* OBSOLETE       { */
/* OBSOLETE     select_thread (n); */
/* OBSOLETE  */
/* OBSOLETE     if ((thread < 0 || n == thread) && ! thread_is_in_kernel[n]) */
/* OBSOLETE       { */
/* OBSOLETE         /* Blam the trace bits in the stack's saved psws to match  */
/* OBSOLETE            the desired step mode.  This is required so that */
/* OBSOLETE            single-stepping a return doesn't restore a psw with a */
/* OBSOLETE            clear trace bit and fly away, and conversely, */
/* OBSOLETE            proceeding through a return in a routine that was */
/* OBSOLETE            stepped into doesn't cause a phantom break by restoring */
/* OBSOLETE            a psw with the trace bit set. *x/ */
/* OBSOLETE         scan_stack (PSW_T_BIT, step); */
/* OBSOLETE         scan_stack (PSW_S_BIT, sequential); */
/* OBSOLETE       } */
/* OBSOLETE  */
/* OBSOLETE     ps.pi_buffer = registers; */
/* OBSOLETE     ps.pi_nbytes = REGISTER_BYTES; */
/* OBSOLETE     ps.pi_offset = 0; */
/* OBSOLETE     ps.pi_thread = n; */
/* OBSOLETE     if (! thread_is_in_kernel[n]) */
/* OBSOLETE       if (ioctl (inferior_fd, PIXWRREGS, &ps)) */
/* OBSOLETE         perror_with_name ("PIXWRREGS"); */
/* OBSOLETE  */
/* OBSOLETE     if (thread < 0 || n == thread) */
/* OBSOLETE       { */
/* OBSOLETE         ps.pi_pc = 1; */
/* OBSOLETE         ps.pi_signo = signal; */
/* OBSOLETE         if (ioctl (inferior_fd, step ? PIXSTEP : PIXCONTINUE, &ps) < 0) */
/* OBSOLETE           perror_with_name ("PIXCONTINUE"); */
/* OBSOLETE       } */
/* OBSOLETE       } */
/* OBSOLETE  */
/* OBSOLETE   if (ioctl (inferior_fd, PIXRUN, &ps) < 0) */
/* OBSOLETE     perror_with_name ("PIXRUN"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Replacement for system wait routine.   */
/* OBSOLETE  */
/* OBSOLETE    The system wait returns with one or more threads stopped by */
/* OBSOLETE    signals.  Put stopped threads on a stack and return them one by */
/* OBSOLETE    one, so that it appears that wait returns one thread at a time. */
/* OBSOLETE  */
/* OBSOLETE    Global variable THREAD_SWITCH_OK is set when gdb can tolerate wait */
/* OBSOLETE    returning a new thread.  If it is false, then only one thread is */
/* OBSOLETE    running; we will do a real wait, the thread will do something, and */
/* OBSOLETE    we will return that.  *x/ */
/* OBSOLETE  */
/* OBSOLETE pid_t */
/* OBSOLETE wait (w) */
/* OBSOLETE     union wait *w; */
/* OBSOLETE { */
/* OBSOLETE   int pid; */
/* OBSOLETE  */
/* OBSOLETE   if (!w) */
/* OBSOLETE     return wait3 (0, 0, 0); */
/* OBSOLETE  */
/* OBSOLETE   /* Do a real wait if we were told to, or if there are no queued threads.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (! thread_switch_ok || signal_stack_is_empty ()) */
/* OBSOLETE     { */
/* OBSOLETE       int thread; */
/* OBSOLETE  */
/* OBSOLETE       pid = wait3 (w, 0, 0); */
/* OBSOLETE  */
/* OBSOLETE       if (!WIFSTOPPED (*w) || pid != inferior_pid) */
/* OBSOLETE     return pid; */
/* OBSOLETE  */
/* OBSOLETE       /* The inferior has done something and stopped.  Read in all the */
/* OBSOLETE      threads' registers, and queue up any signals that happened.  *x/ */
/* OBSOLETE  */
/* OBSOLETE       if (ioctl (inferior_fd, PIXGETTHCOUNT, &ps) < 0) */
/* OBSOLETE     perror_with_name ("PIXGETTHCOUNT"); */
/* OBSOLETE        */
/* OBSOLETE       n_threads = ps.pi_othdcnt; */
/* OBSOLETE       for (thread = 0; thread < n_threads; thread++) */
/* OBSOLETE     { */
/* OBSOLETE       ps.pi_thread = thread; */
/* OBSOLETE       if (ioctl (inferior_fd, PIXGETSUBCODE, &ps) < 0) */
/* OBSOLETE         perror_with_name ("PIXGETSUBCODE"); */
/* OBSOLETE       thread_state[thread] = ps.pi_otstate; */
/* OBSOLETE  */
/* OBSOLETE       if (ps.pi_otstate == PI_TALIVE) */
/* OBSOLETE         { */
/* OBSOLETE           select_thread (thread); */
/* OBSOLETE           ps.pi_buffer = registers; */
/* OBSOLETE           ps.pi_nbytes = REGISTER_BYTES; */
/* OBSOLETE           ps.pi_offset = 0; */
/* OBSOLETE           ps.pi_thread = thread; */
/* OBSOLETE           if (ioctl (inferior_fd, PIXRDREGS, &ps) < 0) */
/* OBSOLETE             perror_with_name ("PIXRDREGS"); */
/* OBSOLETE  */
/* OBSOLETE           registers_fetched (); */
/* OBSOLETE  */
/* OBSOLETE           thread_pc[thread] = read_pc (); */
/* OBSOLETE           thread_signal[thread] = ps.pi_osigno; */
/* OBSOLETE           thread_sigcode[thread] = ps.pi_osigcode; */
/* OBSOLETE  */
/* OBSOLETE           /* If the thread's stack has a context frame */
/* OBSOLETE              on top, something fucked is going on.  I do not */
/* OBSOLETE              know what, but do I know this: the only thing you */
/* OBSOLETE              can do with such a thread is continue it.  *x/ */
/* OBSOLETE  */
/* OBSOLETE           thread_is_in_kernel[thread] =  */
/* OBSOLETE             ((read_register (PS_REGNUM) >> 25) & 3) == 0; */
/* OBSOLETE  */
/* OBSOLETE           /* Signals push an extended frame and then fault */
/* OBSOLETE              with a ridiculous pc.  Pop the frame.  *x/ */
/* OBSOLETE  */
/* OBSOLETE           if (thread_pc[thread] > STACK_END_ADDR) */
/* OBSOLETE             { */
/* OBSOLETE               POP_FRAME; */
/* OBSOLETE               if (is_break_pc (thread_pc[thread])) */
/* OBSOLETE                 thread_pc[thread] = read_pc () - 2; */
/* OBSOLETE               else */
/* OBSOLETE                 thread_pc[thread] = read_pc (); */
/* OBSOLETE               write_register (PC_REGNUM, thread_pc[thread]); */
/* OBSOLETE             } */
/* OBSOLETE            */
/* OBSOLETE           if (ps.pi_osigno || ps.pi_osigcode) */
/* OBSOLETE             { */
/* OBSOLETE               signal_stack++; */
/* OBSOLETE               signal_stack->pid = pid; */
/* OBSOLETE               signal_stack->thread = thread; */
/* OBSOLETE               signal_stack->signo = thread_signal[thread]; */
/* OBSOLETE               signal_stack->subsig = thread_sigcode[thread]; */
/* OBSOLETE               signal_stack->pc = thread_pc[thread]; */
/* OBSOLETE             } */
/* OBSOLETE  */
/* OBSOLETE           /* The following hackery is caused by a unix 7.1 feature: */
/* OBSOLETE              the inferior's fixed scheduling mode is cleared when */
/* OBSOLETE              it execs the shell (since the shell is not a parallel */
/* OBSOLETE              program).  So, note the 5.4 trap we get when */
/* OBSOLETE              the shell does its exec, then catch the 5.0 trap  */
/* OBSOLETE              that occurs when the debuggee starts, and set fixed */
/* OBSOLETE              scheduling mode properly.  *x/ */
/* OBSOLETE  */
/* OBSOLETE           if (ps.pi_osigno == 5 && ps.pi_osigcode == 4) */
/* OBSOLETE             exec_trap_timer = 1; */
/* OBSOLETE           else */
/* OBSOLETE             exec_trap_timer--; */
/* OBSOLETE            */
/* OBSOLETE           if (ps.pi_osigno == 5 && exec_trap_timer == 0) */
/* OBSOLETE             set_fixed_scheduling (pid, parallel == 2); */
/* OBSOLETE         } */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE       if (signal_stack_is_empty ()) */
/* OBSOLETE     error ("no active threads?!"); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Select the thread that stopped, and return *w saying why.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   select_thread (signal_stack->thread); */
/* OBSOLETE  */
/* OBSOLETE  FIXME: need to convert from host sig. */
/* OBSOLETE   stop_signal = signal_stack->signo; */
/* OBSOLETE   stop_sigcode = signal_stack->subsig; */
/* OBSOLETE  */
/* OBSOLETE   WSETSTOP (*w, signal_stack->signo); */
/* OBSOLETE   w->w_thread = signal_stack->thread; */
/* OBSOLETE   return (signal_stack--)->pid; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Select thread THREAD -- its registers, stack, per-thread memory. */
/* OBSOLETE    This is the only routine that may assign to inferior_thread */
/* OBSOLETE    or thread_regs[].  *x/ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE select_thread (thread) */
/* OBSOLETE      int thread; */
/* OBSOLETE { */
/* OBSOLETE   if (thread == inferior_thread) */
/* OBSOLETE     return; */
/* OBSOLETE  */
/* OBSOLETE   memcpy (thread_regs[inferior_thread], registers, REGISTER_BYTES); */
/* OBSOLETE   ps.pi_thread = inferior_thread = thread; */
/* OBSOLETE   if (have_inferior_p ()) */
/* OBSOLETE     ioctl (inferior_fd, PISETRWTID, &ps); */
/* OBSOLETE   memcpy (registers, thread_regs[thread], REGISTER_BYTES); */
/* OBSOLETE } */
/* OBSOLETE    */
/* OBSOLETE /* Routine to set or clear a psw bit in the psw and also all psws */
/* OBSOLETE    saved on the stack.  Quits when we get to a frame in which the */
/* OBSOLETE    saved psw is correct. *x/ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE scan_stack (bit, val) */
/* OBSOLETE     long bit, val; */
/* OBSOLETE { */
/* OBSOLETE   long ps = read_register (PS_REGNUM); */
/* OBSOLETE   long fp; */
/* OBSOLETE   if (val ? !(ps & bit) : (ps & bit)) */
/* OBSOLETE     {     */
/* OBSOLETE       ps ^= bit; */
/* OBSOLETE       write_register (PS_REGNUM, ps); */
/* OBSOLETE  */
/* OBSOLETE       fp = read_register (FP_REGNUM); */
/* OBSOLETE       while (fp & 0x80000000) */
/* OBSOLETE     { */
/* OBSOLETE       ps = read_memory_integer (fp + 4, 4); */
/* OBSOLETE       if (val ? (ps & bit) : !(ps & bit)) */
/* OBSOLETE         break; */
/* OBSOLETE       ps ^= bit; */
/* OBSOLETE       write_memory (fp + 4, &ps, 4); */
/* OBSOLETE       fp = read_memory_integer (fp + 8, 4); */
/* OBSOLETE     } */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Set fixed scheduling (alliant mode) of process PID to ARG (0 or 1).  *x/ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE set_fixed_scheduling (pid, arg) */
/* OBSOLETE       int arg; */
/* OBSOLETE { */
/* OBSOLETE   struct pattributes pattr; */
/* OBSOLETE   getpattr (pid, &pattr); */
/* OBSOLETE   pattr.pattr_pfixed = arg; */
/* OBSOLETE   setpattr (pid, &pattr); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE core_file_command (filename, from_tty) */
/* OBSOLETE      char *filename; */
/* OBSOLETE      int from_tty; */
/* OBSOLETE { */
/* OBSOLETE   int n; */
/* OBSOLETE  */
/* OBSOLETE   /* Discard all vestiges of any previous core file */
/* OBSOLETE      and mark data and stack spaces as empty.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (corefile) */
/* OBSOLETE     xfree (corefile); */
/* OBSOLETE   corefile = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (corechan >= 0) */
/* OBSOLETE     close (corechan); */
/* OBSOLETE   corechan = -1; */
/* OBSOLETE  */
/* OBSOLETE   data_start = 0; */
/* OBSOLETE   data_end = 0; */
/* OBSOLETE   stack_start = STACK_END_ADDR; */
/* OBSOLETE   stack_end = STACK_END_ADDR; */
/* OBSOLETE   n_core = 0; */
/* OBSOLETE  */
/* OBSOLETE   /* Now, if a new core file was specified, open it and digest it.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (filename) */
/* OBSOLETE     { */
/* OBSOLETE       filename = tilde_expand (filename); */
/* OBSOLETE       make_cleanup (xfree, filename); */
/* OBSOLETE        */
/* OBSOLETE       if (have_inferior_p ()) */
/* OBSOLETE     error ("To look at a core file, you must kill the program with \"kill\"."); */
/* OBSOLETE       corechan = open (filename, O_RDONLY, 0); */
/* OBSOLETE       if (corechan < 0) */
/* OBSOLETE     perror_with_name (filename); */
/* OBSOLETE  */
/* OBSOLETE       if (myread (corechan, &filehdr, sizeof filehdr) < 0) */
/* OBSOLETE     perror_with_name (filename); */
/* OBSOLETE  */
/* OBSOLETE       if (!IS_CORE_SOFF_MAGIC (filehdr.h_magic)) */
/* OBSOLETE     error ("%s: not a core file.\n", filename); */
/* OBSOLETE  */
/* OBSOLETE       if (myread (corechan, &opthdr, filehdr.h_opthdr) < 0) */
/* OBSOLETE     perror_with_name (filename); */
/* OBSOLETE  */
/* OBSOLETE       /* Read through the section headers. */
/* OBSOLETE      For text, data, etc, record an entry in the core file map. */
/* OBSOLETE      For context and tcontext, record the file address of */
/* OBSOLETE      the context blocks.  *x/ */
/* OBSOLETE  */
/* OBSOLETE       lseek (corechan, (long) filehdr.h_scnptr, 0); */
/* OBSOLETE  */
/* OBSOLETE       n_threads = 0; */
/* OBSOLETE       for (n = 0; n < filehdr.h_nscns; n++) */
/* OBSOLETE     { */
/* OBSOLETE       if (myread (corechan, &scnhdr, sizeof scnhdr) < 0) */
/* OBSOLETE         perror_with_name (filename); */
/* OBSOLETE       if ((scnhdr.s_flags & S_TYPMASK) >= S_TEXT */
/* OBSOLETE           && (scnhdr.s_flags & S_TYPMASK) <= S_COMON) */
/* OBSOLETE         { */
/* OBSOLETE           core_map[n_core].mem_addr = scnhdr.s_vaddr; */
/* OBSOLETE           core_map[n_core].mem_end = scnhdr.s_vaddr + scnhdr.s_size; */
/* OBSOLETE           core_map[n_core].file_addr = scnhdr.s_scnptr; */
/* OBSOLETE           core_map[n_core].type = scnhdr.s_flags & S_TYPMASK; */
/* OBSOLETE           if (core_map[n_core].type != S_TBSS */
/* OBSOLETE               && core_map[n_core].type != S_TDATA */
/* OBSOLETE               && core_map[n_core].type != S_TTEXT) */
/* OBSOLETE             core_map[n_core].thread = -1; */
/* OBSOLETE           else if (n_core == 0 */
/* OBSOLETE                    || core_map[n_core-1].mem_addr != scnhdr.s_vaddr) */
/* OBSOLETE             core_map[n_core].thread = 0; */
/* OBSOLETE           else  */
/* OBSOLETE             core_map[n_core].thread = core_map[n_core-1].thread + 1; */
/* OBSOLETE           n_core++; */
/* OBSOLETE         } */
/* OBSOLETE       else if ((scnhdr.s_flags & S_TYPMASK) == S_CONTEXT) */
/* OBSOLETE         context_offset = scnhdr.s_scnptr; */
/* OBSOLETE       else if ((scnhdr.s_flags & S_TYPMASK) == S_TCONTEXT)  */
/* OBSOLETE         tcontext_offset[n_threads++] = scnhdr.s_scnptr; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE       /* Read the context block, struct user, struct proc, */
/* OBSOLETE      and the comm regs.  *x/ */
/* OBSOLETE  */
/* OBSOLETE       lseek (corechan, context_offset, 0); */
/* OBSOLETE       if (myread (corechan, &c, sizeof c) < 0) */
/* OBSOLETE     perror_with_name (filename); */
/* OBSOLETE       lseek (corechan, c.core_user_p, 0); */
/* OBSOLETE       if (myread (corechan, &u, sizeof u) < 0) */
/* OBSOLETE     perror_with_name (filename); */
/* OBSOLETE       lseek (corechan, c.core_proc_p, 0); */
/* OBSOLETE       if (myread (corechan, &pr, sizeof pr) < 0) */
/* OBSOLETE     perror_with_name (filename); */
/* OBSOLETE       comm_registers = pr.p_creg; */
/* OBSOLETE  */
/* OBSOLETE       /* Core file apparently is really there.  Make it really exist */
/* OBSOLETE      for xfer_core_file so we can do read_memory on it. *x/ */
/* OBSOLETE  */
/* OBSOLETE       if (filename[0] == '/') */
/* OBSOLETE     corefile = savestring (filename, strlen (filename)); */
/* OBSOLETE       else */
/* OBSOLETE     corefile = concat (current_directory, "/", filename, NULL); */
/* OBSOLETE  */
/* OBSOLETE       printf_filtered ("Program %s ", u.u_comm); */
/* OBSOLETE  */
/* OBSOLETE       /* Read the thread registers and fill in the thread_xxx[] data.  *x/ */
/* OBSOLETE  */
/* OBSOLETE       for (n = 0; n < n_threads; n++) */
/* OBSOLETE     { */
/* OBSOLETE       select_thread (n); */
/* OBSOLETE  */
/* OBSOLETE       lseek (corechan, tcontext_offset[n], 0); */
/* OBSOLETE       if (myread (corechan, &tc, sizeof tc) < 0) */
/* OBSOLETE         perror_with_name (corefile); */
/* OBSOLETE       lseek (corechan, tc.core_thread_p, 0); */
/* OBSOLETE       if (myread (corechan, &th, sizeof th) < 0) */
/* OBSOLETE         perror_with_name (corefile); */
/* OBSOLETE  */
/* OBSOLETE       lseek (corechan, tc.core_syscall_context_p, 0); */
/* OBSOLETE       if (myread (corechan, registers, REGISTER_BYTES) < 0) */
/* OBSOLETE         perror_with_name (corefile); */
/* OBSOLETE  */
/* OBSOLETE       thread_signal[n] = th.t_cursig; */
/* OBSOLETE       thread_sigcode[n] = th.t_code; */
/* OBSOLETE       thread_state[n] = th.t_state; */
/* OBSOLETE       thread_pc[n] = read_pc (); */
/* OBSOLETE  */
/* OBSOLETE       if (thread_pc[n] > STACK_END_ADDR) */
/* OBSOLETE         { */
/* OBSOLETE           POP_FRAME; */
/* OBSOLETE           if (is_break_pc (thread_pc[n])) */
/* OBSOLETE             thread_pc[n] = read_pc () - 2; */
/* OBSOLETE           else */
/* OBSOLETE             thread_pc[n] = read_pc (); */
/* OBSOLETE           write_register (PC_REGNUM, thread_pc[n]); */
/* OBSOLETE         } */
/* OBSOLETE  */
/* OBSOLETE       printf_filtered ("thread %d received signal %d, %s\n", */
/* OBSOLETE                        n, thread_signal[n], */
/* OBSOLETE                        safe_strsignal (thread_signal[n])); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE       /* Select an interesting thread -- also-rans died with SIGKILL, */
/* OBSOLETE      so find one that didn't.  *x/ */
/* OBSOLETE  */
/* OBSOLETE       for (n = 0; n < n_threads; n++) */
/* OBSOLETE     if (thread_signal[n] != 0 && thread_signal[n] != SIGKILL) */
/* OBSOLETE       { */
/* OBSOLETE         select_thread (n); */
/* OBSOLETE         stop_signal = thread_signal[n]; */
/* OBSOLETE         stop_sigcode = thread_sigcode[n]; */
/* OBSOLETE         break; */
/* OBSOLETE       } */
/* OBSOLETE  */
/* OBSOLETE       core_aouthdr.a_magic = 0; */
/* OBSOLETE  */
/* OBSOLETE       flush_cached_frames (); */
/* OBSOLETE       select_frame (get_current_frame (), 0); */
/* OBSOLETE       validate_files (); */
/* OBSOLETE  */
/* OBSOLETE       print_stack_frame (selected_frame, selected_frame_level, -1); */
/* OBSOLETE     } */
/* OBSOLETE   else if (from_tty) */
/* OBSOLETE     printf_filtered ("No core file now.\n"); */
/* OBSOLETE } */
@


1.3
log
@Replace free() with xfree().
@
text
@@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d809 1
a809 1
/* OBSOLETE     free (corefile); */
d827 1
a827 1
/* OBSOLETE       make_cleanup (free, filename); */
@


1.1
log
@Initial revision
@
text
@d1 963
a963 966
/* Convex host-dependent code for GDB.
   Copyright 1990, 1991, 1992 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "command.h"
#include "symtab.h"
#include "value.h"
#include "frame.h"
#include "inferior.h"
#include "wait.h"

#include <signal.h>
#include <fcntl.h>
#include "gdbcore.h"

#include <sys/param.h>
#include <sys/dir.h>
#include <sys/user.h>
#include <sys/ioctl.h>
#include <sys/pcntl.h>
#include <sys/thread.h>
#include <sys/proc.h>
#include <sys/file.h>
#include "gdb_stat.h"
#include <sys/mman.h>

#include <convex/vmparam.h>
#include <convex/filehdr.h>
#include <convex/opthdr.h>
#include <convex/scnhdr.h>
#include <convex/core.h>

/* Per-thread data, read from the inferior at each stop and written
   back at each resume.  */

/* Number of active threads.
   Tables are valid for thread numbers less than this.  */

static int n_threads;

#define MAXTHREADS 8
		
/* Thread state.  The remaining data is valid only if this is PI_TALIVE.  */

static int thread_state[MAXTHREADS];

/* Stop pc, signal, signal subcode */

static int thread_pc[MAXTHREADS];
static int thread_signal[MAXTHREADS];
static int thread_sigcode[MAXTHREADS];	

/* Thread registers.
   If thread is selected, the regs are in registers[] instead.  */

static char thread_regs[MAXTHREADS][REGISTER_BYTES];

/* 1 if the top frame on the thread's stack was a context frame,
   meaning that the kernel is up to something and we should not
   touch the thread at all except to resume it.  */

static char thread_is_in_kernel[MAXTHREADS];

/* The currently selected thread's number.  */

static int inferior_thread;

/* Inferior process's file handle and a process control block
   to feed args to ioctl with.  */

static int inferior_fd;
static struct pcntl ps;

/* SOFF file headers for exec or core file.  */

static FILEHDR filehdr;
static OPTHDR opthdr;
static SCNHDR scnhdr;

/* Address maps constructed from section headers of exec and core files.
   Defines process address -> file address translation.  */

struct pmap 
{
    long mem_addr;		/* process start address */
    long mem_end;		/* process end+1 address */
    long file_addr;		/* file start address */
    long thread;		/* -1 shared; 0,1,... thread-local */
    long type;			/* S_TEXT S_DATA S_BSS S_TBSS etc */
    long which;			/* used to sort map for info files */
};

static int n_exec, n_core;
static struct pmap exec_map[100];
static struct pmap core_map[100];

/* Offsets in the core file of core_context and core_tcontext blocks.  */

static int context_offset;
static int tcontext_offset[MAXTHREADS];

/* Core file control blocks.  */

static struct core_context_v70 c;
static struct core_tcontext_v70 tc;
static struct user u;
static thread_t th;
static proc_t pr;

/* The registers of the currently selected thread.  */

extern char registers[REGISTER_BYTES];

/* Vector and communication registers from core dump or from inferior.
   These are read on demand, ie, not normally valid.  */

static struct vecst vector_registers;
static struct creg_ctx comm_registers;

/* Flag, set on a vanilla CONT command and cleared when the inferior
   is continued.  */

static int all_continue;

/* Flag, set when the inferior is continued by a vanilla CONT command,
   cleared if it is continued for any other purpose.  */

static int thread_switch_ok;

/* Stack of signals recieved from threads but not yet delivered to gdb.  */

struct threadpid 
{
    int pid;
    int thread;
    int signo;
    int subsig;
    int pc;
};

static struct threadpid signal_stack_bot[100];
static struct threadpid *signal_stack = signal_stack_bot;

/* How to detect empty stack -- bottom frame is all zero.  */

#define signal_stack_is_empty() (signal_stack->pid == 0)

/* Mode controlled by SET PIPE command, controls the psw SEQ bit
   which forces each instruction to complete before the next one starts.  */

static int sequential = 0;

/* Mode controlled by the SET PARALLEL command.  Values are:
   0  concurrency limit 1 thread, dynamic scheduling
   1  no concurrency limit, dynamic scheduling
   2  no concurrency limit, fixed scheduling  */

static int parallel = 1;

/* Mode controlled by SET BASE command, output radix for unformatted
   integer typeout, as in argument lists, aggregates, and so on.
   Zero means guess whether it's an address (hex) or not (decimal).  */

static int output_radix = 0;

/* Signal subcode at last thread stop.  */

static int stop_sigcode;

/* Hack, see wait() below.  */

static int exec_trap_timer;

#include "gdbcmd.h"

static struct type *vector_type ();
static long *read_vector_register ();
static long *read_vector_register_1 ();
static void write_vector_register ();
static ULONGEST read_comm_register ();
static void write_comm_register ();
static void convex_cont_command ();
static void thread_continue ();
static void select_thread ();
static void scan_stack ();
static void set_fixed_scheduling ();
static char *subsig_name ();
static void psw_info ();
static sig_noop ();
static ptr_cmp ();


/* Execute ptrace.  Convex V7 replaced ptrace with pattach.
   Allow ptrace (0) as a no-op.  */

int
call_ptrace (request, pid, procaddr, buf)
     int request, pid;
     PTRACE_ARG3_TYPE procaddr;
     int buf;
{
  if (request == 0)
    return;
  error ("no ptrace");
}

/* Replacement for system execle routine.
   Convert it to an equivalent exect, which pattach insists on.  */

execle (name, argv)
     char *name, *argv;
{
  char ***envp = (char ***) &argv;
  while (*envp++) ;

  signal (SIGTRAP, sig_noop);
  exect (name, &argv, *envp);
}

/* Stupid handler for stupid trace trap that otherwise causes
   startup to stupidly hang.  */

static sig_noop () 
{}

/* Read registers from inferior into registers[] array.
   For convex, they are already there, read in when the inferior stops.  */

void
fetch_inferior_registers (regno)
     int regno;
{
}

/* Store our register values back into the inferior.
   For Convex, do this only once, right before resuming inferior.  */

void
store_inferior_registers (regno)
     int regno;
{
}

/* Copy LEN bytes from inferior's memory starting at MEMADDR
   to debugger memory starting at MYADDR. 
   On failure (cannot read from inferior, usually because address is out
   of bounds) returns the value of errno. */

int
read_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
{
  errno = 0;
  while (len > 0)
    {
      /* little-known undocumented max request size */
      int i = (len < 12288) ? len : 12288;

      lseek (inferior_fd, memaddr, 0);
      read (inferior_fd, myaddr, i);

      memaddr += i;
      myaddr += i;
      len -= i;
    }
  if (errno) 
    memset (myaddr, '\0', len);
  return errno;
}

/* Copy LEN bytes of data from debugger memory at MYADDR
   to inferior's memory at MEMADDR.
   Returns errno on failure (cannot write the inferior) */

int
write_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
{
  errno = 0;
  lseek (inferior_fd, memaddr, 0);
  write (inferior_fd, myaddr, len);
  return errno;
}

/* Here from create_inferior when the inferior process has been created
   and started up.  We must do a pattach to grab it for debugging.

   Also, intercept the CONT command by altering its dispatch address.  */
/* FIXME: This used to be called from a macro CREATE_INFERIOR_HOOK.
   But now init_trace_fun is in the same place.  So re-write this to
   use the init_trace_fun (making convex a debugging target).  */

create_inferior_hook (pid)
    int pid;
{
  static char cont[] = "cont";
  static char cont1[] = "c";
  char *linep = cont;
  char *linep1 = cont1;
  char **line = &linep;
  char **line1 = &linep1;
  struct cmd_list_element *c;

  c = lookup_cmd (line, cmdlist, "", 0);
  c->function = convex_cont_command;
  c = lookup_cmd (line1, cmdlist, "", 0);
  c->function = convex_cont_command;

  inferior_fd = pattach (pid, O_EXCL);
  if (inferior_fd < 0)
    perror_with_name ("pattach");
  inferior_thread = 0;
  set_fixed_scheduling (pid, parallel == 2);
}

/* Attach process PID for debugging.  */

attach (pid)
    int pid;
{
  int fd = pattach (pid, O_EXCL);
  if (fd < 0)
    perror_with_name ("pattach");
  attach_flag = 1;
  /* wait for strange kernel reverberations to go away */
  sleep (1);

  setpgrp (pid, pid);

  inferior_fd = fd;
  inferior_thread = 0;
  return pid;
}

/* Stop debugging the process whose number is PID
   and continue it with signal number SIGNAL.
   SIGNAL = 0 means just continue it.  */

void
detach (signal)
     int signal;
{
  signal_stack = signal_stack_bot;
  thread_continue (-1, 0, signal);
  ioctl (inferior_fd, PIXDETACH, &ps);
  close (inferior_fd);
  inferior_fd = 0;
  attach_flag = 0;
}

/* Kill off the inferior process.  */

kill_inferior ()
{
  if (inferior_pid == 0)
    return;
  ioctl (inferior_fd, PIXTERMINATE, 0);
  wait (0);
  target_mourn_inferior ();
}

/* Read vector register REG, and return a pointer to the value.  */

static long *
read_vector_register (reg)
    int reg;
{
  if (have_inferior_p ())
    {
      errno = 0;
      ps.pi_buffer = (char *) &vector_registers;
      ps.pi_nbytes = sizeof vector_registers;
      ps.pi_offset = 0;
      ps.pi_thread = inferior_thread;
      ioctl (inferior_fd, PIXRDVREGS, &ps);
      if (errno)
	memset (&vector_registers, '\0', sizeof vector_registers);
    }
  else if (corechan >= 0)
    {
      lseek (corechan, tcontext_offset[inferior_thread], 0);
      if (myread (corechan, &tc, sizeof tc) < 0)
	perror_with_name (corefile);
      lseek (corechan, tc.core_thread_p, 0);
      if (myread (corechan, &th, sizeof th) < 0)
	perror_with_name (corefile);
      lseek (corechan, tc.core_vregs_p, 0);
      if (myread (corechan, &vector_registers, 16*128) < 0)
	perror_with_name (corefile);
      vector_registers.vm[0] = th.t_vect_ctx.vc_vm[0];
      vector_registers.vm[1] = th.t_vect_ctx.vc_vm[1];
      vector_registers.vls = th.t_vect_ctx.vc_vls;
    }

  return read_vector_register_1 (reg);
}

/* Return a pointer to vector register REG, which must already have been
   fetched from the inferior or core file.  */

static long *
read_vector_register_1 (reg) 
    int reg;
{
  switch (reg)
    {
    case VM_REGNUM:
      return (long *) vector_registers.vm;
    case VS_REGNUM:
      return (long *) &vector_registers.vls;
    case VL_REGNUM:
      return 1 + (long *) &vector_registers.vls;
    default:
      return (long *) &vector_registers.vr[reg];
    }
}

/* Write vector register REG, element ELEMENT, new value VAL.
   NB: must use read-modify-write on the entire vector state,
   since pattach does not do offsetted writes correctly.  */

static void
write_vector_register (reg, element, val)
    int reg, element;
    ULONGEST val;
{
  if (have_inferior_p ())
    {
      errno = 0;
      ps.pi_thread = inferior_thread;
      ps.pi_offset = 0;
      ps.pi_buffer = (char *) &vector_registers;
      ps.pi_nbytes = sizeof vector_registers;

      ioctl (inferior_fd, PIXRDVREGS, &ps);

      switch (reg)
	{
	case VL_REGNUM:
	  vector_registers.vls =
	    (vector_registers.vls & 0xffffffff00000000LL)
	      + (unsigned long) val;
	  break;

	case VS_REGNUM:
	  vector_registers.vls =
	    (val << 32) + (unsigned long) vector_registers.vls;
	  break;
	    
	default:
	  vector_registers.vr[reg].el[element] = val;
	  break;
	}

      ioctl (inferior_fd, PIXWRVREGS, &ps);

      if (errno)
	perror_with_name ("writing vector register");
    }
}

/* Return the contents of communication register NUM.  */ 

static ULONGEST 
read_comm_register (num)
     int num;
{
  if (have_inferior_p ())
    {
      ps.pi_buffer = (char *) &comm_registers;
      ps.pi_nbytes = sizeof comm_registers;
      ps.pi_offset = 0;
      ps.pi_thread = inferior_thread;
      ioctl (inferior_fd, PIXRDCREGS, &ps);
    }
  return comm_registers.crreg.r4[num];
}

/* Store a new value VAL into communication register NUM.  
   NB: Must use read-modify-write on the whole comm register set
   since pattach does not do offsetted writes correctly.  */

static void
write_comm_register (num, val)
     int num;
     ULONGEST val;
{
  if (have_inferior_p ())
    {
      ps.pi_buffer = (char *) &comm_registers;
      ps.pi_nbytes = sizeof comm_registers;
      ps.pi_offset = 0;
      ps.pi_thread = inferior_thread;
      ioctl (inferior_fd, PIXRDCREGS, &ps);
      comm_registers.crreg.r4[num] = val;
      ioctl (inferior_fd, PIXWRCREGS, &ps);
    }
}

/* Resume execution of the inferior process.
   If STEP is nonzero, single-step it.
   If SIGNAL is nonzero, give it that signal.  */

void
resume (step, signal)
     int step;
     int signal;
{
  errno = 0;
  if (step || signal)
    thread_continue (inferior_thread, step, signal);
  else
    thread_continue (-1, 0, 0);
}

/* Maybe resume some threads.
   THREAD is which thread to resume, or -1 to resume them all.
   STEP and SIGNAL are as in resume.

   Global variable ALL_CONTINUE is set when we are here to do a
   `cont' command; otherwise we may be doing `finish' or a call or
   something else that will not tolerate an automatic thread switch.

   If there are stopped threads waiting to deliver signals, and
   ALL_CONTINUE, do not actually resume anything.  gdb will do a wait
   and see one of the stopped threads in the queue.  */

static void
thread_continue (thread, step, signal)
     int thread, step, signal;
{
  int n;

  /* If we are to continue all threads, but not for the CONTINUE command,
     pay no attention and continue only the selected thread.  */

  if (thread < 0 && ! all_continue)
    thread = inferior_thread;

  /* If we are not stepping, we have now executed the continue part
     of a CONTINUE command.  */

  if (! step)
    all_continue = 0;

  /* Allow wait() to switch threads if this is an all-out continue.  */

  thread_switch_ok = thread < 0;

  /* If there are threads queued up, don't resume.  */

  if (thread_switch_ok && ! signal_stack_is_empty ())
    return;

  /* OK, do it.  */

  for (n = 0; n < n_threads; n++)
    if (thread_state[n] == PI_TALIVE)
      {
	select_thread (n);

	if ((thread < 0 || n == thread) && ! thread_is_in_kernel[n])
	  {
	    /* Blam the trace bits in the stack's saved psws to match 
	       the desired step mode.  This is required so that
	       single-stepping a return doesn't restore a psw with a
	       clear trace bit and fly away, and conversely,
	       proceeding through a return in a routine that was
	       stepped into doesn't cause a phantom break by restoring
	       a psw with the trace bit set. */
	    scan_stack (PSW_T_BIT, step);
	    scan_stack (PSW_S_BIT, sequential);
	  }

	ps.pi_buffer = registers;
	ps.pi_nbytes = REGISTER_BYTES;
	ps.pi_offset = 0;
	ps.pi_thread = n;
	if (! thread_is_in_kernel[n])
	  if (ioctl (inferior_fd, PIXWRREGS, &ps))
	    perror_with_name ("PIXWRREGS");

	if (thread < 0 || n == thread)
	  {
	    ps.pi_pc = 1;
	    ps.pi_signo = signal;
	    if (ioctl (inferior_fd, step ? PIXSTEP : PIXCONTINUE, &ps) < 0)
	      perror_with_name ("PIXCONTINUE");
	  }
      }

  if (ioctl (inferior_fd, PIXRUN, &ps) < 0)
    perror_with_name ("PIXRUN");
}

/* Replacement for system wait routine.  

   The system wait returns with one or more threads stopped by
   signals.  Put stopped threads on a stack and return them one by
   one, so that it appears that wait returns one thread at a time.

   Global variable THREAD_SWITCH_OK is set when gdb can tolerate wait
   returning a new thread.  If it is false, then only one thread is
   running; we will do a real wait, the thread will do something, and
   we will return that.  */

pid_t
wait (w)
    union wait *w;
{
  int pid;

  if (!w)
    return wait3 (0, 0, 0);

  /* Do a real wait if we were told to, or if there are no queued threads.  */

  if (! thread_switch_ok || signal_stack_is_empty ())
    {
      int thread;

      pid = wait3 (w, 0, 0);

      if (!WIFSTOPPED (*w) || pid != inferior_pid)
	return pid;

      /* The inferior has done something and stopped.  Read in all the
	 threads' registers, and queue up any signals that happened.  */

      if (ioctl (inferior_fd, PIXGETTHCOUNT, &ps) < 0)
	perror_with_name ("PIXGETTHCOUNT");
      
      n_threads = ps.pi_othdcnt;
      for (thread = 0; thread < n_threads; thread++)
	{
	  ps.pi_thread = thread;
	  if (ioctl (inferior_fd, PIXGETSUBCODE, &ps) < 0)
	    perror_with_name ("PIXGETSUBCODE");
	  thread_state[thread] = ps.pi_otstate;

	  if (ps.pi_otstate == PI_TALIVE)
	    {
	      select_thread (thread);
	      ps.pi_buffer = registers;
	      ps.pi_nbytes = REGISTER_BYTES;
	      ps.pi_offset = 0;
	      ps.pi_thread = thread;
	      if (ioctl (inferior_fd, PIXRDREGS, &ps) < 0)
		perror_with_name ("PIXRDREGS");

	      registers_fetched ();

	      thread_pc[thread] = read_pc ();
	      thread_signal[thread] = ps.pi_osigno;
	      thread_sigcode[thread] = ps.pi_osigcode;

	      /* If the thread's stack has a context frame
		 on top, something fucked is going on.  I do not
		 know what, but do I know this: the only thing you
		 can do with such a thread is continue it.  */

	      thread_is_in_kernel[thread] = 
		((read_register (PS_REGNUM) >> 25) & 3) == 0;

	      /* Signals push an extended frame and then fault
		 with a ridiculous pc.  Pop the frame.  */

	      if (thread_pc[thread] > STACK_END_ADDR)
		{
		  POP_FRAME;
		  if (is_break_pc (thread_pc[thread]))
		    thread_pc[thread] = read_pc () - 2;
		  else
		    thread_pc[thread] = read_pc ();
		  write_register (PC_REGNUM, thread_pc[thread]);
		}
	      
	      if (ps.pi_osigno || ps.pi_osigcode)
		{
		  signal_stack++;
		  signal_stack->pid = pid;
		  signal_stack->thread = thread;
		  signal_stack->signo = thread_signal[thread];
		  signal_stack->subsig = thread_sigcode[thread];
		  signal_stack->pc = thread_pc[thread];
		}

	      /* The following hackery is caused by a unix 7.1 feature:
		 the inferior's fixed scheduling mode is cleared when
		 it execs the shell (since the shell is not a parallel
		 program).  So, note the 5.4 trap we get when
		 the shell does its exec, then catch the 5.0 trap 
		 that occurs when the debuggee starts, and set fixed
		 scheduling mode properly.  */

	      if (ps.pi_osigno == 5 && ps.pi_osigcode == 4)
		exec_trap_timer = 1;
	      else
		exec_trap_timer--;
	      
	      if (ps.pi_osigno == 5 && exec_trap_timer == 0)
		set_fixed_scheduling (pid, parallel == 2);
	    }
	}

      if (signal_stack_is_empty ())
	error ("no active threads?!");
    }

  /* Select the thread that stopped, and return *w saying why.  */

  select_thread (signal_stack->thread);

 FIXME: need to convert from host sig.
  stop_signal = signal_stack->signo;
  stop_sigcode = signal_stack->subsig;

  WSETSTOP (*w, signal_stack->signo);
  w->w_thread = signal_stack->thread;
  return (signal_stack--)->pid;
}

/* Select thread THREAD -- its registers, stack, per-thread memory.
   This is the only routine that may assign to inferior_thread
   or thread_regs[].  */

static void
select_thread (thread)
     int thread;
{
  if (thread == inferior_thread)
    return;

  memcpy (thread_regs[inferior_thread], registers, REGISTER_BYTES);
  ps.pi_thread = inferior_thread = thread;
  if (have_inferior_p ())
    ioctl (inferior_fd, PISETRWTID, &ps);
  memcpy (registers, thread_regs[thread], REGISTER_BYTES);
}
  
/* Routine to set or clear a psw bit in the psw and also all psws
   saved on the stack.  Quits when we get to a frame in which the
   saved psw is correct. */

static void
scan_stack (bit, val)
    long bit, val;
{
  long ps = read_register (PS_REGNUM);
  long fp;
  if (val ? !(ps & bit) : (ps & bit))
    {    
      ps ^= bit;
      write_register (PS_REGNUM, ps);

      fp = read_register (FP_REGNUM);
      while (fp & 0x80000000)
	{
	  ps = read_memory_integer (fp + 4, 4);
	  if (val ? (ps & bit) : !(ps & bit))
	    break;
	  ps ^= bit;
	  write_memory (fp + 4, &ps, 4);
	  fp = read_memory_integer (fp + 8, 4);
	}
    }
}

/* Set fixed scheduling (alliant mode) of process PID to ARG (0 or 1).  */

static void
set_fixed_scheduling (pid, arg)
      int arg;
{
  struct pattributes pattr;
  getpattr (pid, &pattr);
  pattr.pattr_pfixed = arg;
  setpattr (pid, &pattr);
}

void
core_file_command (filename, from_tty)
     char *filename;
     int from_tty;
{
  int n;

  /* Discard all vestiges of any previous core file
     and mark data and stack spaces as empty.  */

  if (corefile)
    free (corefile);
  corefile = 0;

  if (corechan >= 0)
    close (corechan);
  corechan = -1;

  data_start = 0;
  data_end = 0;
  stack_start = STACK_END_ADDR;
  stack_end = STACK_END_ADDR;
  n_core = 0;

  /* Now, if a new core file was specified, open it and digest it.  */

  if (filename)
    {
      filename = tilde_expand (filename);
      make_cleanup (free, filename);
      
      if (have_inferior_p ())
	error ("To look at a core file, you must kill the program with \"kill\".");
      corechan = open (filename, O_RDONLY, 0);
      if (corechan < 0)
	perror_with_name (filename);

      if (myread (corechan, &filehdr, sizeof filehdr) < 0)
	perror_with_name (filename);

      if (!IS_CORE_SOFF_MAGIC (filehdr.h_magic))
	error ("%s: not a core file.\n", filename);

      if (myread (corechan, &opthdr, filehdr.h_opthdr) < 0)
	perror_with_name (filename);

      /* Read through the section headers.
	 For text, data, etc, record an entry in the core file map.
	 For context and tcontext, record the file address of
	 the context blocks.  */

      lseek (corechan, (long) filehdr.h_scnptr, 0);

      n_threads = 0;
      for (n = 0; n < filehdr.h_nscns; n++)
	{
	  if (myread (corechan, &scnhdr, sizeof scnhdr) < 0)
	    perror_with_name (filename);
	  if ((scnhdr.s_flags & S_TYPMASK) >= S_TEXT
	      && (scnhdr.s_flags & S_TYPMASK) <= S_COMON)
	    {
	      core_map[n_core].mem_addr = scnhdr.s_vaddr;
	      core_map[n_core].mem_end = scnhdr.s_vaddr + scnhdr.s_size;
	      core_map[n_core].file_addr = scnhdr.s_scnptr;
	      core_map[n_core].type = scnhdr.s_flags & S_TYPMASK;
	      if (core_map[n_core].type != S_TBSS
		  && core_map[n_core].type != S_TDATA
		  && core_map[n_core].type != S_TTEXT)
		core_map[n_core].thread = -1;
	      else if (n_core == 0
		       || core_map[n_core-1].mem_addr != scnhdr.s_vaddr)
		core_map[n_core].thread = 0;
	      else 
		core_map[n_core].thread = core_map[n_core-1].thread + 1;
	      n_core++;
	    }
	  else if ((scnhdr.s_flags & S_TYPMASK) == S_CONTEXT)
	    context_offset = scnhdr.s_scnptr;
	  else if ((scnhdr.s_flags & S_TYPMASK) == S_TCONTEXT) 
	    tcontext_offset[n_threads++] = scnhdr.s_scnptr;
	}

      /* Read the context block, struct user, struct proc,
	 and the comm regs.  */

      lseek (corechan, context_offset, 0);
      if (myread (corechan, &c, sizeof c) < 0)
	perror_with_name (filename);
      lseek (corechan, c.core_user_p, 0);
      if (myread (corechan, &u, sizeof u) < 0)
	perror_with_name (filename);
      lseek (corechan, c.core_proc_p, 0);
      if (myread (corechan, &pr, sizeof pr) < 0)
	perror_with_name (filename);
      comm_registers = pr.p_creg;

      /* Core file apparently is really there.  Make it really exist
	 for xfer_core_file so we can do read_memory on it. */

      if (filename[0] == '/')
	corefile = savestring (filename, strlen (filename));
      else
	corefile = concat (current_directory, "/", filename, NULL);

      printf_filtered ("Program %s ", u.u_comm);

      /* Read the thread registers and fill in the thread_xxx[] data.  */

      for (n = 0; n < n_threads; n++)
	{
	  select_thread (n);

	  lseek (corechan, tcontext_offset[n], 0);
	  if (myread (corechan, &tc, sizeof tc) < 0)
	    perror_with_name (corefile);
	  lseek (corechan, tc.core_thread_p, 0);
	  if (myread (corechan, &th, sizeof th) < 0)
	    perror_with_name (corefile);

	  lseek (corechan, tc.core_syscall_context_p, 0);
	  if (myread (corechan, registers, REGISTER_BYTES) < 0)
	    perror_with_name (corefile);

	  thread_signal[n] = th.t_cursig;
	  thread_sigcode[n] = th.t_code;
	  thread_state[n] = th.t_state;
	  thread_pc[n] = read_pc ();

	  if (thread_pc[n] > STACK_END_ADDR)
	    {
	      POP_FRAME;
	      if (is_break_pc (thread_pc[n]))
		thread_pc[n] = read_pc () - 2;
	      else
		thread_pc[n] = read_pc ();
	      write_register (PC_REGNUM, thread_pc[n]);
	    }

	  printf_filtered ("thread %d received signal %d, %s\n",
			   n, thread_signal[n],
			   safe_strsignal (thread_signal[n]));
	}

      /* Select an interesting thread -- also-rans died with SIGKILL,
	 so find one that didn't.  */

      for (n = 0; n < n_threads; n++)
	if (thread_signal[n] != 0 && thread_signal[n] != SIGKILL)
	  {
	    select_thread (n);
	    stop_signal = thread_signal[n];
	    stop_sigcode = thread_sigcode[n];
	    break;
	  }

      core_aouthdr.a_magic = 0;

      flush_cached_frames ();
      select_frame (get_current_frame (), 0);
      validate_files ();

      print_stack_frame (selected_frame, selected_frame_level, -1);
    }
  else if (from_tty)
    printf_filtered ("No core file now.\n");
}
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d126 3
@


1.1.1.3
log
@import gdb-1999-06-28 snapshot
@
text
@d1 963
a963 963
/* OBSOLETE /* Convex host-dependent code for GDB. */
/* OBSOLETE    Copyright 1990, 1991, 1992 Free Software Foundation, Inc. */
/* OBSOLETE  */
/* OBSOLETE This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE This program is free software; you can redistribute it and/or modify */
/* OBSOLETE it under the terms of the GNU General Public License as published by */
/* OBSOLETE the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE This program is distributed in the hope that it will be useful, */
/* OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE You should have received a copy of the GNU General Public License */
/* OBSOLETE along with this program; if not, write to the Free Software */
/* OBSOLETE Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "command.h" */
/* OBSOLETE #include "symtab.h" */
/* OBSOLETE #include "value.h" */
/* OBSOLETE #include "frame.h" */
/* OBSOLETE #include "inferior.h" */
/* OBSOLETE #include "wait.h" */
/* OBSOLETE  */
/* OBSOLETE #include <signal.h> */
/* OBSOLETE #include <fcntl.h> */
/* OBSOLETE #include "gdbcore.h" */
/* OBSOLETE  */
/* OBSOLETE #include <sys/param.h> */
/* OBSOLETE #include <sys/dir.h> */
/* OBSOLETE #include <sys/user.h> */
/* OBSOLETE #include <sys/ioctl.h> */
/* OBSOLETE #include <sys/pcntl.h> */
/* OBSOLETE #include <sys/thread.h> */
/* OBSOLETE #include <sys/proc.h> */
/* OBSOLETE #include <sys/file.h> */
/* OBSOLETE #include "gdb_stat.h" */
/* OBSOLETE #include <sys/mman.h> */
/* OBSOLETE  */
/* OBSOLETE #include <convex/vmparam.h> */
/* OBSOLETE #include <convex/filehdr.h> */
/* OBSOLETE #include <convex/opthdr.h> */
/* OBSOLETE #include <convex/scnhdr.h> */
/* OBSOLETE #include <convex/core.h> */
/* OBSOLETE  */
/* OBSOLETE /* Per-thread data, read from the inferior at each stop and written */
/* OBSOLETE    back at each resume.  *x/ */
/* OBSOLETE  */
/* OBSOLETE /* Number of active threads. */
/* OBSOLETE    Tables are valid for thread numbers less than this.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int n_threads; */
/* OBSOLETE  */
/* OBSOLETE #define MAXTHREADS 8 */
/* OBSOLETE 		 */
/* OBSOLETE /* Thread state.  The remaining data is valid only if this is PI_TALIVE.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int thread_state[MAXTHREADS]; */
/* OBSOLETE  */
/* OBSOLETE /* Stop pc, signal, signal subcode *x/ */
/* OBSOLETE  */
/* OBSOLETE static int thread_pc[MAXTHREADS]; */
/* OBSOLETE static int thread_signal[MAXTHREADS]; */
/* OBSOLETE static int thread_sigcode[MAXTHREADS];	 */
/* OBSOLETE  */
/* OBSOLETE /* Thread registers. */
/* OBSOLETE    If thread is selected, the regs are in registers[] instead.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static char thread_regs[MAXTHREADS][REGISTER_BYTES]; */
/* OBSOLETE  */
/* OBSOLETE /* 1 if the top frame on the thread's stack was a context frame, */
/* OBSOLETE    meaning that the kernel is up to something and we should not */
/* OBSOLETE    touch the thread at all except to resume it.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static char thread_is_in_kernel[MAXTHREADS]; */
/* OBSOLETE  */
/* OBSOLETE /* The currently selected thread's number.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int inferior_thread; */
/* OBSOLETE  */
/* OBSOLETE /* Inferior process's file handle and a process control block */
/* OBSOLETE    to feed args to ioctl with.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int inferior_fd; */
/* OBSOLETE static struct pcntl ps; */
/* OBSOLETE  */
/* OBSOLETE /* SOFF file headers for exec or core file.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static FILEHDR filehdr; */
/* OBSOLETE static OPTHDR opthdr; */
/* OBSOLETE static SCNHDR scnhdr; */
/* OBSOLETE  */
/* OBSOLETE /* Address maps constructed from section headers of exec and core files. */
/* OBSOLETE    Defines process address -> file address translation.  *x/ */
/* OBSOLETE  */
/* OBSOLETE struct pmap  */
/* OBSOLETE { */
/* OBSOLETE     long mem_addr;		/* process start address *x/ */
/* OBSOLETE     long mem_end;		/* process end+1 address *x/ */
/* OBSOLETE     long file_addr;		/* file start address *x/ */
/* OBSOLETE     long thread;		/* -1 shared; 0,1,... thread-local *x/ */
/* OBSOLETE     long type;			/* S_TEXT S_DATA S_BSS S_TBSS etc *x/ */
/* OBSOLETE     long which;			/* used to sort map for info files *x/ */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE static int n_exec, n_core; */
/* OBSOLETE static struct pmap exec_map[100]; */
/* OBSOLETE static struct pmap core_map[100]; */
/* OBSOLETE  */
/* OBSOLETE /* Offsets in the core file of core_context and core_tcontext blocks.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int context_offset; */
/* OBSOLETE static int tcontext_offset[MAXTHREADS]; */
/* OBSOLETE  */
/* OBSOLETE /* Core file control blocks.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static struct core_context_v70 c; */
/* OBSOLETE static struct core_tcontext_v70 tc; */
/* OBSOLETE static struct user u; */
/* OBSOLETE static thread_t th; */
/* OBSOLETE static proc_t pr; */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Vector and communication registers from core dump or from inferior. */
/* OBSOLETE    These are read on demand, ie, not normally valid.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static struct vecst vector_registers; */
/* OBSOLETE static struct creg_ctx comm_registers; */
/* OBSOLETE  */
/* OBSOLETE /* Flag, set on a vanilla CONT command and cleared when the inferior */
/* OBSOLETE    is continued.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int all_continue; */
/* OBSOLETE  */
/* OBSOLETE /* Flag, set when the inferior is continued by a vanilla CONT command, */
/* OBSOLETE    cleared if it is continued for any other purpose.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int thread_switch_ok; */
/* OBSOLETE  */
/* OBSOLETE /* Stack of signals recieved from threads but not yet delivered to gdb.  *x/ */
/* OBSOLETE  */
/* OBSOLETE struct threadpid  */
/* OBSOLETE { */
/* OBSOLETE     int pid; */
/* OBSOLETE     int thread; */
/* OBSOLETE     int signo; */
/* OBSOLETE     int subsig; */
/* OBSOLETE     int pc; */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE static struct threadpid signal_stack_bot[100]; */
/* OBSOLETE static struct threadpid *signal_stack = signal_stack_bot; */
/* OBSOLETE  */
/* OBSOLETE /* How to detect empty stack -- bottom frame is all zero.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define signal_stack_is_empty() (signal_stack->pid == 0) */
/* OBSOLETE  */
/* OBSOLETE /* Mode controlled by SET PIPE command, controls the psw SEQ bit */
/* OBSOLETE    which forces each instruction to complete before the next one starts.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int sequential = 0; */
/* OBSOLETE  */
/* OBSOLETE /* Mode controlled by the SET PARALLEL command.  Values are: */
/* OBSOLETE    0  concurrency limit 1 thread, dynamic scheduling */
/* OBSOLETE    1  no concurrency limit, dynamic scheduling */
/* OBSOLETE    2  no concurrency limit, fixed scheduling  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int parallel = 1; */
/* OBSOLETE  */
/* OBSOLETE /* Mode controlled by SET BASE command, output radix for unformatted */
/* OBSOLETE    integer typeout, as in argument lists, aggregates, and so on. */
/* OBSOLETE    Zero means guess whether it's an address (hex) or not (decimal).  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int output_radix = 0; */
/* OBSOLETE  */
/* OBSOLETE /* Signal subcode at last thread stop.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int stop_sigcode; */
/* OBSOLETE  */
/* OBSOLETE /* Hack, see wait() below.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static int exec_trap_timer; */
/* OBSOLETE  */
/* OBSOLETE #include "gdbcmd.h" */
/* OBSOLETE  */
/* OBSOLETE static struct type *vector_type (); */
/* OBSOLETE static long *read_vector_register (); */
/* OBSOLETE static long *read_vector_register_1 (); */
/* OBSOLETE static void write_vector_register (); */
/* OBSOLETE static ULONGEST read_comm_register (); */
/* OBSOLETE static void write_comm_register (); */
/* OBSOLETE static void convex_cont_command (); */
/* OBSOLETE static void thread_continue (); */
/* OBSOLETE static void select_thread (); */
/* OBSOLETE static void scan_stack (); */
/* OBSOLETE static void set_fixed_scheduling (); */
/* OBSOLETE static char *subsig_name (); */
/* OBSOLETE static void psw_info (); */
/* OBSOLETE static sig_noop (); */
/* OBSOLETE static ptr_cmp (); */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Execute ptrace.  Convex V7 replaced ptrace with pattach. */
/* OBSOLETE    Allow ptrace (0) as a no-op.  *x/ */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE call_ptrace (request, pid, procaddr, buf) */
/* OBSOLETE      int request, pid; */
/* OBSOLETE      PTRACE_ARG3_TYPE procaddr; */
/* OBSOLETE      int buf; */
/* OBSOLETE { */
/* OBSOLETE   if (request == 0) */
/* OBSOLETE     return; */
/* OBSOLETE   error ("no ptrace"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Replacement for system execle routine. */
/* OBSOLETE    Convert it to an equivalent exect, which pattach insists on.  *x/ */
/* OBSOLETE  */
/* OBSOLETE execle (name, argv) */
/* OBSOLETE      char *name, *argv; */
/* OBSOLETE { */
/* OBSOLETE   char ***envp = (char ***) &argv; */
/* OBSOLETE   while (*envp++) ; */
/* OBSOLETE  */
/* OBSOLETE   signal (SIGTRAP, sig_noop); */
/* OBSOLETE   exect (name, &argv, *envp); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Stupid handler for stupid trace trap that otherwise causes */
/* OBSOLETE    startup to stupidly hang.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static sig_noop ()  */
/* OBSOLETE {} */
/* OBSOLETE  */
/* OBSOLETE /* Read registers from inferior into registers[] array. */
/* OBSOLETE    For convex, they are already there, read in when the inferior stops.  *x/ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE fetch_inferior_registers (regno) */
/* OBSOLETE      int regno; */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Store our register values back into the inferior. */
/* OBSOLETE    For Convex, do this only once, right before resuming inferior.  *x/ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE store_inferior_registers (regno) */
/* OBSOLETE      int regno; */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Copy LEN bytes from inferior's memory starting at MEMADDR */
/* OBSOLETE    to debugger memory starting at MYADDR.  */
/* OBSOLETE    On failure (cannot read from inferior, usually because address is out */
/* OBSOLETE    of bounds) returns the value of errno. *x/ */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE read_inferior_memory (memaddr, myaddr, len) */
/* OBSOLETE      CORE_ADDR memaddr; */
/* OBSOLETE      char *myaddr; */
/* OBSOLETE      int len; */
/* OBSOLETE { */
/* OBSOLETE   errno = 0; */
/* OBSOLETE   while (len > 0) */
/* OBSOLETE     { */
/* OBSOLETE       /* little-known undocumented max request size *x/ */
/* OBSOLETE       int i = (len < 12288) ? len : 12288; */
/* OBSOLETE  */
/* OBSOLETE       lseek (inferior_fd, memaddr, 0); */
/* OBSOLETE       read (inferior_fd, myaddr, i); */
/* OBSOLETE  */
/* OBSOLETE       memaddr += i; */
/* OBSOLETE       myaddr += i; */
/* OBSOLETE       len -= i; */
/* OBSOLETE     } */
/* OBSOLETE   if (errno)  */
/* OBSOLETE     memset (myaddr, '\0', len); */
/* OBSOLETE   return errno; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Copy LEN bytes of data from debugger memory at MYADDR */
/* OBSOLETE    to inferior's memory at MEMADDR. */
/* OBSOLETE    Returns errno on failure (cannot write the inferior) *x/ */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE write_inferior_memory (memaddr, myaddr, len) */
/* OBSOLETE      CORE_ADDR memaddr; */
/* OBSOLETE      char *myaddr; */
/* OBSOLETE      int len; */
/* OBSOLETE { */
/* OBSOLETE   errno = 0; */
/* OBSOLETE   lseek (inferior_fd, memaddr, 0); */
/* OBSOLETE   write (inferior_fd, myaddr, len); */
/* OBSOLETE   return errno; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Here from create_inferior when the inferior process has been created */
/* OBSOLETE    and started up.  We must do a pattach to grab it for debugging. */
/* OBSOLETE  */
/* OBSOLETE    Also, intercept the CONT command by altering its dispatch address.  *x/ */
/* OBSOLETE /* FIXME: This used to be called from a macro CREATE_INFERIOR_HOOK. */
/* OBSOLETE    But now init_trace_fun is in the same place.  So re-write this to */
/* OBSOLETE    use the init_trace_fun (making convex a debugging target).  *x/ */
/* OBSOLETE  */
/* OBSOLETE create_inferior_hook (pid) */
/* OBSOLETE     int pid; */
/* OBSOLETE { */
/* OBSOLETE   static char cont[] = "cont"; */
/* OBSOLETE   static char cont1[] = "c"; */
/* OBSOLETE   char *linep = cont; */
/* OBSOLETE   char *linep1 = cont1; */
/* OBSOLETE   char **line = &linep; */
/* OBSOLETE   char **line1 = &linep1; */
/* OBSOLETE   struct cmd_list_element *c; */
/* OBSOLETE  */
/* OBSOLETE   c = lookup_cmd (line, cmdlist, "", 0); */
/* OBSOLETE   c->function = convex_cont_command; */
/* OBSOLETE   c = lookup_cmd (line1, cmdlist, "", 0); */
/* OBSOLETE   c->function = convex_cont_command; */
/* OBSOLETE  */
/* OBSOLETE   inferior_fd = pattach (pid, O_EXCL); */
/* OBSOLETE   if (inferior_fd < 0) */
/* OBSOLETE     perror_with_name ("pattach"); */
/* OBSOLETE   inferior_thread = 0; */
/* OBSOLETE   set_fixed_scheduling (pid, parallel == 2); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Attach process PID for debugging.  *x/ */
/* OBSOLETE  */
/* OBSOLETE attach (pid) */
/* OBSOLETE     int pid; */
/* OBSOLETE { */
/* OBSOLETE   int fd = pattach (pid, O_EXCL); */
/* OBSOLETE   if (fd < 0) */
/* OBSOLETE     perror_with_name ("pattach"); */
/* OBSOLETE   attach_flag = 1; */
/* OBSOLETE   /* wait for strange kernel reverberations to go away *x/ */
/* OBSOLETE   sleep (1); */
/* OBSOLETE  */
/* OBSOLETE   setpgrp (pid, pid); */
/* OBSOLETE  */
/* OBSOLETE   inferior_fd = fd; */
/* OBSOLETE   inferior_thread = 0; */
/* OBSOLETE   return pid; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Stop debugging the process whose number is PID */
/* OBSOLETE    and continue it with signal number SIGNAL. */
/* OBSOLETE    SIGNAL = 0 means just continue it.  *x/ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE detach (signal) */
/* OBSOLETE      int signal; */
/* OBSOLETE { */
/* OBSOLETE   signal_stack = signal_stack_bot; */
/* OBSOLETE   thread_continue (-1, 0, signal); */
/* OBSOLETE   ioctl (inferior_fd, PIXDETACH, &ps); */
/* OBSOLETE   close (inferior_fd); */
/* OBSOLETE   inferior_fd = 0; */
/* OBSOLETE   attach_flag = 0; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Kill off the inferior process.  *x/ */
/* OBSOLETE  */
/* OBSOLETE kill_inferior () */
/* OBSOLETE { */
/* OBSOLETE   if (inferior_pid == 0) */
/* OBSOLETE     return; */
/* OBSOLETE   ioctl (inferior_fd, PIXTERMINATE, 0); */
/* OBSOLETE   wait (0); */
/* OBSOLETE   target_mourn_inferior (); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Read vector register REG, and return a pointer to the value.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static long * */
/* OBSOLETE read_vector_register (reg) */
/* OBSOLETE     int reg; */
/* OBSOLETE { */
/* OBSOLETE   if (have_inferior_p ()) */
/* OBSOLETE     { */
/* OBSOLETE       errno = 0; */
/* OBSOLETE       ps.pi_buffer = (char *) &vector_registers; */
/* OBSOLETE       ps.pi_nbytes = sizeof vector_registers; */
/* OBSOLETE       ps.pi_offset = 0; */
/* OBSOLETE       ps.pi_thread = inferior_thread; */
/* OBSOLETE       ioctl (inferior_fd, PIXRDVREGS, &ps); */
/* OBSOLETE       if (errno) */
/* OBSOLETE 	memset (&vector_registers, '\0', sizeof vector_registers); */
/* OBSOLETE     } */
/* OBSOLETE   else if (corechan >= 0) */
/* OBSOLETE     { */
/* OBSOLETE       lseek (corechan, tcontext_offset[inferior_thread], 0); */
/* OBSOLETE       if (myread (corechan, &tc, sizeof tc) < 0) */
/* OBSOLETE 	perror_with_name (corefile); */
/* OBSOLETE       lseek (corechan, tc.core_thread_p, 0); */
/* OBSOLETE       if (myread (corechan, &th, sizeof th) < 0) */
/* OBSOLETE 	perror_with_name (corefile); */
/* OBSOLETE       lseek (corechan, tc.core_vregs_p, 0); */
/* OBSOLETE       if (myread (corechan, &vector_registers, 16*128) < 0) */
/* OBSOLETE 	perror_with_name (corefile); */
/* OBSOLETE       vector_registers.vm[0] = th.t_vect_ctx.vc_vm[0]; */
/* OBSOLETE       vector_registers.vm[1] = th.t_vect_ctx.vc_vm[1]; */
/* OBSOLETE       vector_registers.vls = th.t_vect_ctx.vc_vls; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   return read_vector_register_1 (reg); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Return a pointer to vector register REG, which must already have been */
/* OBSOLETE    fetched from the inferior or core file.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static long * */
/* OBSOLETE read_vector_register_1 (reg)  */
/* OBSOLETE     int reg; */
/* OBSOLETE { */
/* OBSOLETE   switch (reg) */
/* OBSOLETE     { */
/* OBSOLETE     case VM_REGNUM: */
/* OBSOLETE       return (long *) vector_registers.vm; */
/* OBSOLETE     case VS_REGNUM: */
/* OBSOLETE       return (long *) &vector_registers.vls; */
/* OBSOLETE     case VL_REGNUM: */
/* OBSOLETE       return 1 + (long *) &vector_registers.vls; */
/* OBSOLETE     default: */
/* OBSOLETE       return (long *) &vector_registers.vr[reg]; */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Write vector register REG, element ELEMENT, new value VAL. */
/* OBSOLETE    NB: must use read-modify-write on the entire vector state, */
/* OBSOLETE    since pattach does not do offsetted writes correctly.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE write_vector_register (reg, element, val) */
/* OBSOLETE     int reg, element; */
/* OBSOLETE     ULONGEST val; */
/* OBSOLETE { */
/* OBSOLETE   if (have_inferior_p ()) */
/* OBSOLETE     { */
/* OBSOLETE       errno = 0; */
/* OBSOLETE       ps.pi_thread = inferior_thread; */
/* OBSOLETE       ps.pi_offset = 0; */
/* OBSOLETE       ps.pi_buffer = (char *) &vector_registers; */
/* OBSOLETE       ps.pi_nbytes = sizeof vector_registers; */
/* OBSOLETE  */
/* OBSOLETE       ioctl (inferior_fd, PIXRDVREGS, &ps); */
/* OBSOLETE  */
/* OBSOLETE       switch (reg) */
/* OBSOLETE 	{ */
/* OBSOLETE 	case VL_REGNUM: */
/* OBSOLETE 	  vector_registers.vls = */
/* OBSOLETE 	    (vector_registers.vls & 0xffffffff00000000LL) */
/* OBSOLETE 	      + (unsigned long) val; */
/* OBSOLETE 	  break; */
/* OBSOLETE  */
/* OBSOLETE 	case VS_REGNUM: */
/* OBSOLETE 	  vector_registers.vls = */
/* OBSOLETE 	    (val << 32) + (unsigned long) vector_registers.vls; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	     */
/* OBSOLETE 	default: */
/* OBSOLETE 	  vector_registers.vr[reg].el[element] = val; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       ioctl (inferior_fd, PIXWRVREGS, &ps); */
/* OBSOLETE  */
/* OBSOLETE       if (errno) */
/* OBSOLETE 	perror_with_name ("writing vector register"); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Return the contents of communication register NUM.  *x/  */
/* OBSOLETE  */
/* OBSOLETE static ULONGEST  */
/* OBSOLETE read_comm_register (num) */
/* OBSOLETE      int num; */
/* OBSOLETE { */
/* OBSOLETE   if (have_inferior_p ()) */
/* OBSOLETE     { */
/* OBSOLETE       ps.pi_buffer = (char *) &comm_registers; */
/* OBSOLETE       ps.pi_nbytes = sizeof comm_registers; */
/* OBSOLETE       ps.pi_offset = 0; */
/* OBSOLETE       ps.pi_thread = inferior_thread; */
/* OBSOLETE       ioctl (inferior_fd, PIXRDCREGS, &ps); */
/* OBSOLETE     } */
/* OBSOLETE   return comm_registers.crreg.r4[num]; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Store a new value VAL into communication register NUM.   */
/* OBSOLETE    NB: Must use read-modify-write on the whole comm register set */
/* OBSOLETE    since pattach does not do offsetted writes correctly.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE write_comm_register (num, val) */
/* OBSOLETE      int num; */
/* OBSOLETE      ULONGEST val; */
/* OBSOLETE { */
/* OBSOLETE   if (have_inferior_p ()) */
/* OBSOLETE     { */
/* OBSOLETE       ps.pi_buffer = (char *) &comm_registers; */
/* OBSOLETE       ps.pi_nbytes = sizeof comm_registers; */
/* OBSOLETE       ps.pi_offset = 0; */
/* OBSOLETE       ps.pi_thread = inferior_thread; */
/* OBSOLETE       ioctl (inferior_fd, PIXRDCREGS, &ps); */
/* OBSOLETE       comm_registers.crreg.r4[num] = val; */
/* OBSOLETE       ioctl (inferior_fd, PIXWRCREGS, &ps); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Resume execution of the inferior process. */
/* OBSOLETE    If STEP is nonzero, single-step it. */
/* OBSOLETE    If SIGNAL is nonzero, give it that signal.  *x/ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE resume (step, signal) */
/* OBSOLETE      int step; */
/* OBSOLETE      int signal; */
/* OBSOLETE { */
/* OBSOLETE   errno = 0; */
/* OBSOLETE   if (step || signal) */
/* OBSOLETE     thread_continue (inferior_thread, step, signal); */
/* OBSOLETE   else */
/* OBSOLETE     thread_continue (-1, 0, 0); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Maybe resume some threads. */
/* OBSOLETE    THREAD is which thread to resume, or -1 to resume them all. */
/* OBSOLETE    STEP and SIGNAL are as in resume. */
/* OBSOLETE  */
/* OBSOLETE    Global variable ALL_CONTINUE is set when we are here to do a */
/* OBSOLETE    `cont' command; otherwise we may be doing `finish' or a call or */
/* OBSOLETE    something else that will not tolerate an automatic thread switch. */
/* OBSOLETE  */
/* OBSOLETE    If there are stopped threads waiting to deliver signals, and */
/* OBSOLETE    ALL_CONTINUE, do not actually resume anything.  gdb will do a wait */
/* OBSOLETE    and see one of the stopped threads in the queue.  *x/ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE thread_continue (thread, step, signal) */
/* OBSOLETE      int thread, step, signal; */
/* OBSOLETE { */
/* OBSOLETE   int n; */
/* OBSOLETE  */
/* OBSOLETE   /* If we are to continue all threads, but not for the CONTINUE command, */
/* OBSOLETE      pay no attention and continue only the selected thread.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (thread < 0 && ! all_continue) */
/* OBSOLETE     thread = inferior_thread; */
/* OBSOLETE  */
/* OBSOLETE   /* If we are not stepping, we have now executed the continue part */
/* OBSOLETE      of a CONTINUE command.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (! step) */
/* OBSOLETE     all_continue = 0; */
/* OBSOLETE  */
/* OBSOLETE   /* Allow wait() to switch threads if this is an all-out continue.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   thread_switch_ok = thread < 0; */
/* OBSOLETE  */
/* OBSOLETE   /* If there are threads queued up, don't resume.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (thread_switch_ok && ! signal_stack_is_empty ()) */
/* OBSOLETE     return; */
/* OBSOLETE  */
/* OBSOLETE   /* OK, do it.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   for (n = 0; n < n_threads; n++) */
/* OBSOLETE     if (thread_state[n] == PI_TALIVE) */
/* OBSOLETE       { */
/* OBSOLETE 	select_thread (n); */
/* OBSOLETE  */
/* OBSOLETE 	if ((thread < 0 || n == thread) && ! thread_is_in_kernel[n]) */
/* OBSOLETE 	  { */
/* OBSOLETE 	    /* Blam the trace bits in the stack's saved psws to match  */
/* OBSOLETE 	       the desired step mode.  This is required so that */
/* OBSOLETE 	       single-stepping a return doesn't restore a psw with a */
/* OBSOLETE 	       clear trace bit and fly away, and conversely, */
/* OBSOLETE 	       proceeding through a return in a routine that was */
/* OBSOLETE 	       stepped into doesn't cause a phantom break by restoring */
/* OBSOLETE 	       a psw with the trace bit set. *x/ */
/* OBSOLETE 	    scan_stack (PSW_T_BIT, step); */
/* OBSOLETE 	    scan_stack (PSW_S_BIT, sequential); */
/* OBSOLETE 	  } */
/* OBSOLETE  */
/* OBSOLETE 	ps.pi_buffer = registers; */
/* OBSOLETE 	ps.pi_nbytes = REGISTER_BYTES; */
/* OBSOLETE 	ps.pi_offset = 0; */
/* OBSOLETE 	ps.pi_thread = n; */
/* OBSOLETE 	if (! thread_is_in_kernel[n]) */
/* OBSOLETE 	  if (ioctl (inferior_fd, PIXWRREGS, &ps)) */
/* OBSOLETE 	    perror_with_name ("PIXWRREGS"); */
/* OBSOLETE  */
/* OBSOLETE 	if (thread < 0 || n == thread) */
/* OBSOLETE 	  { */
/* OBSOLETE 	    ps.pi_pc = 1; */
/* OBSOLETE 	    ps.pi_signo = signal; */
/* OBSOLETE 	    if (ioctl (inferior_fd, step ? PIXSTEP : PIXCONTINUE, &ps) < 0) */
/* OBSOLETE 	      perror_with_name ("PIXCONTINUE"); */
/* OBSOLETE 	  } */
/* OBSOLETE       } */
/* OBSOLETE  */
/* OBSOLETE   if (ioctl (inferior_fd, PIXRUN, &ps) < 0) */
/* OBSOLETE     perror_with_name ("PIXRUN"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Replacement for system wait routine.   */
/* OBSOLETE  */
/* OBSOLETE    The system wait returns with one or more threads stopped by */
/* OBSOLETE    signals.  Put stopped threads on a stack and return them one by */
/* OBSOLETE    one, so that it appears that wait returns one thread at a time. */
/* OBSOLETE  */
/* OBSOLETE    Global variable THREAD_SWITCH_OK is set when gdb can tolerate wait */
/* OBSOLETE    returning a new thread.  If it is false, then only one thread is */
/* OBSOLETE    running; we will do a real wait, the thread will do something, and */
/* OBSOLETE    we will return that.  *x/ */
/* OBSOLETE  */
/* OBSOLETE pid_t */
/* OBSOLETE wait (w) */
/* OBSOLETE     union wait *w; */
/* OBSOLETE { */
/* OBSOLETE   int pid; */
/* OBSOLETE  */
/* OBSOLETE   if (!w) */
/* OBSOLETE     return wait3 (0, 0, 0); */
/* OBSOLETE  */
/* OBSOLETE   /* Do a real wait if we were told to, or if there are no queued threads.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (! thread_switch_ok || signal_stack_is_empty ()) */
/* OBSOLETE     { */
/* OBSOLETE       int thread; */
/* OBSOLETE  */
/* OBSOLETE       pid = wait3 (w, 0, 0); */
/* OBSOLETE  */
/* OBSOLETE       if (!WIFSTOPPED (*w) || pid != inferior_pid) */
/* OBSOLETE 	return pid; */
/* OBSOLETE  */
/* OBSOLETE       /* The inferior has done something and stopped.  Read in all the */
/* OBSOLETE 	 threads' registers, and queue up any signals that happened.  *x/ */
/* OBSOLETE  */
/* OBSOLETE       if (ioctl (inferior_fd, PIXGETTHCOUNT, &ps) < 0) */
/* OBSOLETE 	perror_with_name ("PIXGETTHCOUNT"); */
/* OBSOLETE        */
/* OBSOLETE       n_threads = ps.pi_othdcnt; */
/* OBSOLETE       for (thread = 0; thread < n_threads; thread++) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  ps.pi_thread = thread; */
/* OBSOLETE 	  if (ioctl (inferior_fd, PIXGETSUBCODE, &ps) < 0) */
/* OBSOLETE 	    perror_with_name ("PIXGETSUBCODE"); */
/* OBSOLETE 	  thread_state[thread] = ps.pi_otstate; */
/* OBSOLETE  */
/* OBSOLETE 	  if (ps.pi_otstate == PI_TALIVE) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      select_thread (thread); */
/* OBSOLETE 	      ps.pi_buffer = registers; */
/* OBSOLETE 	      ps.pi_nbytes = REGISTER_BYTES; */
/* OBSOLETE 	      ps.pi_offset = 0; */
/* OBSOLETE 	      ps.pi_thread = thread; */
/* OBSOLETE 	      if (ioctl (inferior_fd, PIXRDREGS, &ps) < 0) */
/* OBSOLETE 		perror_with_name ("PIXRDREGS"); */
/* OBSOLETE  */
/* OBSOLETE 	      registers_fetched (); */
/* OBSOLETE  */
/* OBSOLETE 	      thread_pc[thread] = read_pc (); */
/* OBSOLETE 	      thread_signal[thread] = ps.pi_osigno; */
/* OBSOLETE 	      thread_sigcode[thread] = ps.pi_osigcode; */
/* OBSOLETE  */
/* OBSOLETE 	      /* If the thread's stack has a context frame */
/* OBSOLETE 		 on top, something fucked is going on.  I do not */
/* OBSOLETE 		 know what, but do I know this: the only thing you */
/* OBSOLETE 		 can do with such a thread is continue it.  *x/ */
/* OBSOLETE  */
/* OBSOLETE 	      thread_is_in_kernel[thread] =  */
/* OBSOLETE 		((read_register (PS_REGNUM) >> 25) & 3) == 0; */
/* OBSOLETE  */
/* OBSOLETE 	      /* Signals push an extended frame and then fault */
/* OBSOLETE 		 with a ridiculous pc.  Pop the frame.  *x/ */
/* OBSOLETE  */
/* OBSOLETE 	      if (thread_pc[thread] > STACK_END_ADDR) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  POP_FRAME; */
/* OBSOLETE 		  if (is_break_pc (thread_pc[thread])) */
/* OBSOLETE 		    thread_pc[thread] = read_pc () - 2; */
/* OBSOLETE 		  else */
/* OBSOLETE 		    thread_pc[thread] = read_pc (); */
/* OBSOLETE 		  write_register (PC_REGNUM, thread_pc[thread]); */
/* OBSOLETE 		} */
/* OBSOLETE 	       */
/* OBSOLETE 	      if (ps.pi_osigno || ps.pi_osigcode) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  signal_stack++; */
/* OBSOLETE 		  signal_stack->pid = pid; */
/* OBSOLETE 		  signal_stack->thread = thread; */
/* OBSOLETE 		  signal_stack->signo = thread_signal[thread]; */
/* OBSOLETE 		  signal_stack->subsig = thread_sigcode[thread]; */
/* OBSOLETE 		  signal_stack->pc = thread_pc[thread]; */
/* OBSOLETE 		} */
/* OBSOLETE  */
/* OBSOLETE 	      /* The following hackery is caused by a unix 7.1 feature: */
/* OBSOLETE 		 the inferior's fixed scheduling mode is cleared when */
/* OBSOLETE 		 it execs the shell (since the shell is not a parallel */
/* OBSOLETE 		 program).  So, note the 5.4 trap we get when */
/* OBSOLETE 		 the shell does its exec, then catch the 5.0 trap  */
/* OBSOLETE 		 that occurs when the debuggee starts, and set fixed */
/* OBSOLETE 		 scheduling mode properly.  *x/ */
/* OBSOLETE  */
/* OBSOLETE 	      if (ps.pi_osigno == 5 && ps.pi_osigcode == 4) */
/* OBSOLETE 		exec_trap_timer = 1; */
/* OBSOLETE 	      else */
/* OBSOLETE 		exec_trap_timer--; */
/* OBSOLETE 	       */
/* OBSOLETE 	      if (ps.pi_osigno == 5 && exec_trap_timer == 0) */
/* OBSOLETE 		set_fixed_scheduling (pid, parallel == 2); */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       if (signal_stack_is_empty ()) */
/* OBSOLETE 	error ("no active threads?!"); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Select the thread that stopped, and return *w saying why.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   select_thread (signal_stack->thread); */
/* OBSOLETE  */
/* OBSOLETE  FIXME: need to convert from host sig. */
/* OBSOLETE   stop_signal = signal_stack->signo; */
/* OBSOLETE   stop_sigcode = signal_stack->subsig; */
/* OBSOLETE  */
/* OBSOLETE   WSETSTOP (*w, signal_stack->signo); */
/* OBSOLETE   w->w_thread = signal_stack->thread; */
/* OBSOLETE   return (signal_stack--)->pid; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Select thread THREAD -- its registers, stack, per-thread memory. */
/* OBSOLETE    This is the only routine that may assign to inferior_thread */
/* OBSOLETE    or thread_regs[].  *x/ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE select_thread (thread) */
/* OBSOLETE      int thread; */
/* OBSOLETE { */
/* OBSOLETE   if (thread == inferior_thread) */
/* OBSOLETE     return; */
/* OBSOLETE  */
/* OBSOLETE   memcpy (thread_regs[inferior_thread], registers, REGISTER_BYTES); */
/* OBSOLETE   ps.pi_thread = inferior_thread = thread; */
/* OBSOLETE   if (have_inferior_p ()) */
/* OBSOLETE     ioctl (inferior_fd, PISETRWTID, &ps); */
/* OBSOLETE   memcpy (registers, thread_regs[thread], REGISTER_BYTES); */
/* OBSOLETE } */
/* OBSOLETE    */
/* OBSOLETE /* Routine to set or clear a psw bit in the psw and also all psws */
/* OBSOLETE    saved on the stack.  Quits when we get to a frame in which the */
/* OBSOLETE    saved psw is correct. *x/ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE scan_stack (bit, val) */
/* OBSOLETE     long bit, val; */
/* OBSOLETE { */
/* OBSOLETE   long ps = read_register (PS_REGNUM); */
/* OBSOLETE   long fp; */
/* OBSOLETE   if (val ? !(ps & bit) : (ps & bit)) */
/* OBSOLETE     {     */
/* OBSOLETE       ps ^= bit; */
/* OBSOLETE       write_register (PS_REGNUM, ps); */
/* OBSOLETE  */
/* OBSOLETE       fp = read_register (FP_REGNUM); */
/* OBSOLETE       while (fp & 0x80000000) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  ps = read_memory_integer (fp + 4, 4); */
/* OBSOLETE 	  if (val ? (ps & bit) : !(ps & bit)) */
/* OBSOLETE 	    break; */
/* OBSOLETE 	  ps ^= bit; */
/* OBSOLETE 	  write_memory (fp + 4, &ps, 4); */
/* OBSOLETE 	  fp = read_memory_integer (fp + 8, 4); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Set fixed scheduling (alliant mode) of process PID to ARG (0 or 1).  *x/ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE set_fixed_scheduling (pid, arg) */
/* OBSOLETE       int arg; */
/* OBSOLETE { */
/* OBSOLETE   struct pattributes pattr; */
/* OBSOLETE   getpattr (pid, &pattr); */
/* OBSOLETE   pattr.pattr_pfixed = arg; */
/* OBSOLETE   setpattr (pid, &pattr); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE core_file_command (filename, from_tty) */
/* OBSOLETE      char *filename; */
/* OBSOLETE      int from_tty; */
/* OBSOLETE { */
/* OBSOLETE   int n; */
/* OBSOLETE  */
/* OBSOLETE   /* Discard all vestiges of any previous core file */
/* OBSOLETE      and mark data and stack spaces as empty.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (corefile) */
/* OBSOLETE     free (corefile); */
/* OBSOLETE   corefile = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (corechan >= 0) */
/* OBSOLETE     close (corechan); */
/* OBSOLETE   corechan = -1; */
/* OBSOLETE  */
/* OBSOLETE   data_start = 0; */
/* OBSOLETE   data_end = 0; */
/* OBSOLETE   stack_start = STACK_END_ADDR; */
/* OBSOLETE   stack_end = STACK_END_ADDR; */
/* OBSOLETE   n_core = 0; */
/* OBSOLETE  */
/* OBSOLETE   /* Now, if a new core file was specified, open it and digest it.  *x/ */
/* OBSOLETE  */
/* OBSOLETE   if (filename) */
/* OBSOLETE     { */
/* OBSOLETE       filename = tilde_expand (filename); */
/* OBSOLETE       make_cleanup (free, filename); */
/* OBSOLETE        */
/* OBSOLETE       if (have_inferior_p ()) */
/* OBSOLETE 	error ("To look at a core file, you must kill the program with \"kill\"."); */
/* OBSOLETE       corechan = open (filename, O_RDONLY, 0); */
/* OBSOLETE       if (corechan < 0) */
/* OBSOLETE 	perror_with_name (filename); */
/* OBSOLETE  */
/* OBSOLETE       if (myread (corechan, &filehdr, sizeof filehdr) < 0) */
/* OBSOLETE 	perror_with_name (filename); */
/* OBSOLETE  */
/* OBSOLETE       if (!IS_CORE_SOFF_MAGIC (filehdr.h_magic)) */
/* OBSOLETE 	error ("%s: not a core file.\n", filename); */
/* OBSOLETE  */
/* OBSOLETE       if (myread (corechan, &opthdr, filehdr.h_opthdr) < 0) */
/* OBSOLETE 	perror_with_name (filename); */
/* OBSOLETE  */
/* OBSOLETE       /* Read through the section headers. */
/* OBSOLETE 	 For text, data, etc, record an entry in the core file map. */
/* OBSOLETE 	 For context and tcontext, record the file address of */
/* OBSOLETE 	 the context blocks.  *x/ */
/* OBSOLETE  */
/* OBSOLETE       lseek (corechan, (long) filehdr.h_scnptr, 0); */
/* OBSOLETE  */
/* OBSOLETE       n_threads = 0; */
/* OBSOLETE       for (n = 0; n < filehdr.h_nscns; n++) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  if (myread (corechan, &scnhdr, sizeof scnhdr) < 0) */
/* OBSOLETE 	    perror_with_name (filename); */
/* OBSOLETE 	  if ((scnhdr.s_flags & S_TYPMASK) >= S_TEXT */
/* OBSOLETE 	      && (scnhdr.s_flags & S_TYPMASK) <= S_COMON) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      core_map[n_core].mem_addr = scnhdr.s_vaddr; */
/* OBSOLETE 	      core_map[n_core].mem_end = scnhdr.s_vaddr + scnhdr.s_size; */
/* OBSOLETE 	      core_map[n_core].file_addr = scnhdr.s_scnptr; */
/* OBSOLETE 	      core_map[n_core].type = scnhdr.s_flags & S_TYPMASK; */
/* OBSOLETE 	      if (core_map[n_core].type != S_TBSS */
/* OBSOLETE 		  && core_map[n_core].type != S_TDATA */
/* OBSOLETE 		  && core_map[n_core].type != S_TTEXT) */
/* OBSOLETE 		core_map[n_core].thread = -1; */
/* OBSOLETE 	      else if (n_core == 0 */
/* OBSOLETE 		       || core_map[n_core-1].mem_addr != scnhdr.s_vaddr) */
/* OBSOLETE 		core_map[n_core].thread = 0; */
/* OBSOLETE 	      else  */
/* OBSOLETE 		core_map[n_core].thread = core_map[n_core-1].thread + 1; */
/* OBSOLETE 	      n_core++; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else if ((scnhdr.s_flags & S_TYPMASK) == S_CONTEXT) */
/* OBSOLETE 	    context_offset = scnhdr.s_scnptr; */
/* OBSOLETE 	  else if ((scnhdr.s_flags & S_TYPMASK) == S_TCONTEXT)  */
/* OBSOLETE 	    tcontext_offset[n_threads++] = scnhdr.s_scnptr; */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       /* Read the context block, struct user, struct proc, */
/* OBSOLETE 	 and the comm regs.  *x/ */
/* OBSOLETE  */
/* OBSOLETE       lseek (corechan, context_offset, 0); */
/* OBSOLETE       if (myread (corechan, &c, sizeof c) < 0) */
/* OBSOLETE 	perror_with_name (filename); */
/* OBSOLETE       lseek (corechan, c.core_user_p, 0); */
/* OBSOLETE       if (myread (corechan, &u, sizeof u) < 0) */
/* OBSOLETE 	perror_with_name (filename); */
/* OBSOLETE       lseek (corechan, c.core_proc_p, 0); */
/* OBSOLETE       if (myread (corechan, &pr, sizeof pr) < 0) */
/* OBSOLETE 	perror_with_name (filename); */
/* OBSOLETE       comm_registers = pr.p_creg; */
/* OBSOLETE  */
/* OBSOLETE       /* Core file apparently is really there.  Make it really exist */
/* OBSOLETE 	 for xfer_core_file so we can do read_memory on it. *x/ */
/* OBSOLETE  */
/* OBSOLETE       if (filename[0] == '/') */
/* OBSOLETE 	corefile = savestring (filename, strlen (filename)); */
/* OBSOLETE       else */
/* OBSOLETE 	corefile = concat (current_directory, "/", filename, NULL); */
/* OBSOLETE  */
/* OBSOLETE       printf_filtered ("Program %s ", u.u_comm); */
/* OBSOLETE  */
/* OBSOLETE       /* Read the thread registers and fill in the thread_xxx[] data.  *x/ */
/* OBSOLETE  */
/* OBSOLETE       for (n = 0; n < n_threads; n++) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  select_thread (n); */
/* OBSOLETE  */
/* OBSOLETE 	  lseek (corechan, tcontext_offset[n], 0); */
/* OBSOLETE 	  if (myread (corechan, &tc, sizeof tc) < 0) */
/* OBSOLETE 	    perror_with_name (corefile); */
/* OBSOLETE 	  lseek (corechan, tc.core_thread_p, 0); */
/* OBSOLETE 	  if (myread (corechan, &th, sizeof th) < 0) */
/* OBSOLETE 	    perror_with_name (corefile); */
/* OBSOLETE  */
/* OBSOLETE 	  lseek (corechan, tc.core_syscall_context_p, 0); */
/* OBSOLETE 	  if (myread (corechan, registers, REGISTER_BYTES) < 0) */
/* OBSOLETE 	    perror_with_name (corefile); */
/* OBSOLETE  */
/* OBSOLETE 	  thread_signal[n] = th.t_cursig; */
/* OBSOLETE 	  thread_sigcode[n] = th.t_code; */
/* OBSOLETE 	  thread_state[n] = th.t_state; */
/* OBSOLETE 	  thread_pc[n] = read_pc (); */
/* OBSOLETE  */
/* OBSOLETE 	  if (thread_pc[n] > STACK_END_ADDR) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      POP_FRAME; */
/* OBSOLETE 	      if (is_break_pc (thread_pc[n])) */
/* OBSOLETE 		thread_pc[n] = read_pc () - 2; */
/* OBSOLETE 	      else */
/* OBSOLETE 		thread_pc[n] = read_pc (); */
/* OBSOLETE 	      write_register (PC_REGNUM, thread_pc[n]); */
/* OBSOLETE 	    } */
/* OBSOLETE  */
/* OBSOLETE 	  printf_filtered ("thread %d received signal %d, %s\n", */
/* OBSOLETE 			   n, thread_signal[n], */
/* OBSOLETE 			   safe_strsignal (thread_signal[n])); */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       /* Select an interesting thread -- also-rans died with SIGKILL, */
/* OBSOLETE 	 so find one that didn't.  *x/ */
/* OBSOLETE  */
/* OBSOLETE       for (n = 0; n < n_threads; n++) */
/* OBSOLETE 	if (thread_signal[n] != 0 && thread_signal[n] != SIGKILL) */
/* OBSOLETE 	  { */
/* OBSOLETE 	    select_thread (n); */
/* OBSOLETE 	    stop_signal = thread_signal[n]; */
/* OBSOLETE 	    stop_sigcode = thread_sigcode[n]; */
/* OBSOLETE 	    break; */
/* OBSOLETE 	  } */
/* OBSOLETE  */
/* OBSOLETE       core_aouthdr.a_magic = 0; */
/* OBSOLETE  */
/* OBSOLETE       flush_cached_frames (); */
/* OBSOLETE       select_frame (get_current_frame (), 0); */
/* OBSOLETE       validate_files (); */
/* OBSOLETE  */
/* OBSOLETE       print_stack_frame (selected_frame, selected_frame_level, -1); */
/* OBSOLETE     } */
/* OBSOLETE   else if (from_tty) */
/* OBSOLETE     printf_filtered ("No core file now.\n"); */
/* OBSOLETE } */
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d58 1
a58 1
/* OBSOLETE              */
d67 1
a67 1
/* OBSOLETE static int thread_sigcode[MAXTHREADS];       */
d101 6
a106 6
/* OBSOLETE     long mem_addr;          /* process start address *x/ */
/* OBSOLETE     long mem_end;           /* process end+1 address *x/ */
/* OBSOLETE     long file_addr;         /* file start address *x/ */
/* OBSOLETE     long thread;            /* -1 shared; 0,1,... thread-local *x/ */
/* OBSOLETE     long type;                      /* S_TEXT S_DATA S_BSS S_TBSS etc *x/ */
/* OBSOLETE     long which;                     /* used to sort map for info files *x/ */
d394 1
a394 1
/* OBSOLETE     memset (&vector_registers, '\0', sizeof vector_registers); */
d400 1
a400 1
/* OBSOLETE     perror_with_name (corefile); */
d403 1
a403 1
/* OBSOLETE     perror_with_name (corefile); */
d406 1
a406 1
/* OBSOLETE     perror_with_name (corefile); */
d455 16
a470 16
/* OBSOLETE     { */
/* OBSOLETE     case VL_REGNUM: */
/* OBSOLETE       vector_registers.vls = */
/* OBSOLETE         (vector_registers.vls & 0xffffffff00000000LL) */
/* OBSOLETE           + (unsigned long) val; */
/* OBSOLETE       break; */
/* OBSOLETE  */
/* OBSOLETE     case VS_REGNUM: */
/* OBSOLETE       vector_registers.vls = */
/* OBSOLETE         (val << 32) + (unsigned long) vector_registers.vls; */
/* OBSOLETE       break; */
/* OBSOLETE          */
/* OBSOLETE     default: */
/* OBSOLETE       vector_registers.vr[reg].el[element] = val; */
/* OBSOLETE       break; */
/* OBSOLETE     } */
d475 1
a475 1
/* OBSOLETE     perror_with_name ("writing vector register"); */
d577 1
a577 14
/* OBSOLETE     select_thread (n); */
/* OBSOLETE  */
/* OBSOLETE     if ((thread < 0 || n == thread) && ! thread_is_in_kernel[n]) */
/* OBSOLETE       { */
/* OBSOLETE         /* Blam the trace bits in the stack's saved psws to match  */
/* OBSOLETE            the desired step mode.  This is required so that */
/* OBSOLETE            single-stepping a return doesn't restore a psw with a */
/* OBSOLETE            clear trace bit and fly away, and conversely, */
/* OBSOLETE            proceeding through a return in a routine that was */
/* OBSOLETE            stepped into doesn't cause a phantom break by restoring */
/* OBSOLETE            a psw with the trace bit set. *x/ */
/* OBSOLETE         scan_stack (PSW_T_BIT, step); */
/* OBSOLETE         scan_stack (PSW_S_BIT, sequential); */
/* OBSOLETE       } */
d579 28
a606 15
/* OBSOLETE     ps.pi_buffer = registers; */
/* OBSOLETE     ps.pi_nbytes = REGISTER_BYTES; */
/* OBSOLETE     ps.pi_offset = 0; */
/* OBSOLETE     ps.pi_thread = n; */
/* OBSOLETE     if (! thread_is_in_kernel[n]) */
/* OBSOLETE       if (ioctl (inferior_fd, PIXWRREGS, &ps)) */
/* OBSOLETE         perror_with_name ("PIXWRREGS"); */
/* OBSOLETE  */
/* OBSOLETE     if (thread < 0 || n == thread) */
/* OBSOLETE       { */
/* OBSOLETE         ps.pi_pc = 1; */
/* OBSOLETE         ps.pi_signo = signal; */
/* OBSOLETE         if (ioctl (inferior_fd, step ? PIXSTEP : PIXCONTINUE, &ps) < 0) */
/* OBSOLETE           perror_with_name ("PIXCONTINUE"); */
/* OBSOLETE       } */
d642 1
a642 1
/* OBSOLETE     return pid; */
d645 1
a645 1
/* OBSOLETE      threads' registers, and queue up any signals that happened.  *x/ */
d648 1
a648 1
/* OBSOLETE     perror_with_name ("PIXGETTHCOUNT"); */
d652 70
a721 70
/* OBSOLETE     { */
/* OBSOLETE       ps.pi_thread = thread; */
/* OBSOLETE       if (ioctl (inferior_fd, PIXGETSUBCODE, &ps) < 0) */
/* OBSOLETE         perror_with_name ("PIXGETSUBCODE"); */
/* OBSOLETE       thread_state[thread] = ps.pi_otstate; */
/* OBSOLETE  */
/* OBSOLETE       if (ps.pi_otstate == PI_TALIVE) */
/* OBSOLETE         { */
/* OBSOLETE           select_thread (thread); */
/* OBSOLETE           ps.pi_buffer = registers; */
/* OBSOLETE           ps.pi_nbytes = REGISTER_BYTES; */
/* OBSOLETE           ps.pi_offset = 0; */
/* OBSOLETE           ps.pi_thread = thread; */
/* OBSOLETE           if (ioctl (inferior_fd, PIXRDREGS, &ps) < 0) */
/* OBSOLETE             perror_with_name ("PIXRDREGS"); */
/* OBSOLETE  */
/* OBSOLETE           registers_fetched (); */
/* OBSOLETE  */
/* OBSOLETE           thread_pc[thread] = read_pc (); */
/* OBSOLETE           thread_signal[thread] = ps.pi_osigno; */
/* OBSOLETE           thread_sigcode[thread] = ps.pi_osigcode; */
/* OBSOLETE  */
/* OBSOLETE           /* If the thread's stack has a context frame */
/* OBSOLETE              on top, something fucked is going on.  I do not */
/* OBSOLETE              know what, but do I know this: the only thing you */
/* OBSOLETE              can do with such a thread is continue it.  *x/ */
/* OBSOLETE  */
/* OBSOLETE           thread_is_in_kernel[thread] =  */
/* OBSOLETE             ((read_register (PS_REGNUM) >> 25) & 3) == 0; */
/* OBSOLETE  */
/* OBSOLETE           /* Signals push an extended frame and then fault */
/* OBSOLETE              with a ridiculous pc.  Pop the frame.  *x/ */
/* OBSOLETE  */
/* OBSOLETE           if (thread_pc[thread] > STACK_END_ADDR) */
/* OBSOLETE             { */
/* OBSOLETE               POP_FRAME; */
/* OBSOLETE               if (is_break_pc (thread_pc[thread])) */
/* OBSOLETE                 thread_pc[thread] = read_pc () - 2; */
/* OBSOLETE               else */
/* OBSOLETE                 thread_pc[thread] = read_pc (); */
/* OBSOLETE               write_register (PC_REGNUM, thread_pc[thread]); */
/* OBSOLETE             } */
/* OBSOLETE            */
/* OBSOLETE           if (ps.pi_osigno || ps.pi_osigcode) */
/* OBSOLETE             { */
/* OBSOLETE               signal_stack++; */
/* OBSOLETE               signal_stack->pid = pid; */
/* OBSOLETE               signal_stack->thread = thread; */
/* OBSOLETE               signal_stack->signo = thread_signal[thread]; */
/* OBSOLETE               signal_stack->subsig = thread_sigcode[thread]; */
/* OBSOLETE               signal_stack->pc = thread_pc[thread]; */
/* OBSOLETE             } */
/* OBSOLETE  */
/* OBSOLETE           /* The following hackery is caused by a unix 7.1 feature: */
/* OBSOLETE              the inferior's fixed scheduling mode is cleared when */
/* OBSOLETE              it execs the shell (since the shell is not a parallel */
/* OBSOLETE              program).  So, note the 5.4 trap we get when */
/* OBSOLETE              the shell does its exec, then catch the 5.0 trap  */
/* OBSOLETE              that occurs when the debuggee starts, and set fixed */
/* OBSOLETE              scheduling mode properly.  *x/ */
/* OBSOLETE  */
/* OBSOLETE           if (ps.pi_osigno == 5 && ps.pi_osigcode == 4) */
/* OBSOLETE             exec_trap_timer = 1; */
/* OBSOLETE           else */
/* OBSOLETE             exec_trap_timer--; */
/* OBSOLETE            */
/* OBSOLETE           if (ps.pi_osigno == 5 && exec_trap_timer == 0) */
/* OBSOLETE             set_fixed_scheduling (pid, parallel == 2); */
/* OBSOLETE         } */
/* OBSOLETE     } */
d724 1
a724 1
/* OBSOLETE     error ("no active threads?!"); */
d775 8
a782 8
/* OBSOLETE     { */
/* OBSOLETE       ps = read_memory_integer (fp + 4, 4); */
/* OBSOLETE       if (val ? (ps & bit) : !(ps & bit)) */
/* OBSOLETE         break; */
/* OBSOLETE       ps ^= bit; */
/* OBSOLETE       write_memory (fp + 4, &ps, 4); */
/* OBSOLETE       fp = read_memory_integer (fp + 8, 4); */
/* OBSOLETE     } */
d830 1
a830 1
/* OBSOLETE     error ("To look at a core file, you must kill the program with \"kill\"."); */
d833 1
a833 1
/* OBSOLETE     perror_with_name (filename); */
d836 1
a836 1
/* OBSOLETE     perror_with_name (filename); */
d839 1
a839 1
/* OBSOLETE     error ("%s: not a core file.\n", filename); */
d842 1
a842 1
/* OBSOLETE     perror_with_name (filename); */
d845 3
a847 3
/* OBSOLETE      For text, data, etc, record an entry in the core file map. */
/* OBSOLETE      For context and tcontext, record the file address of */
/* OBSOLETE      the context blocks.  *x/ */
d853 26
a878 26
/* OBSOLETE     { */
/* OBSOLETE       if (myread (corechan, &scnhdr, sizeof scnhdr) < 0) */
/* OBSOLETE         perror_with_name (filename); */
/* OBSOLETE       if ((scnhdr.s_flags & S_TYPMASK) >= S_TEXT */
/* OBSOLETE           && (scnhdr.s_flags & S_TYPMASK) <= S_COMON) */
/* OBSOLETE         { */
/* OBSOLETE           core_map[n_core].mem_addr = scnhdr.s_vaddr; */
/* OBSOLETE           core_map[n_core].mem_end = scnhdr.s_vaddr + scnhdr.s_size; */
/* OBSOLETE           core_map[n_core].file_addr = scnhdr.s_scnptr; */
/* OBSOLETE           core_map[n_core].type = scnhdr.s_flags & S_TYPMASK; */
/* OBSOLETE           if (core_map[n_core].type != S_TBSS */
/* OBSOLETE               && core_map[n_core].type != S_TDATA */
/* OBSOLETE               && core_map[n_core].type != S_TTEXT) */
/* OBSOLETE             core_map[n_core].thread = -1; */
/* OBSOLETE           else if (n_core == 0 */
/* OBSOLETE                    || core_map[n_core-1].mem_addr != scnhdr.s_vaddr) */
/* OBSOLETE             core_map[n_core].thread = 0; */
/* OBSOLETE           else  */
/* OBSOLETE             core_map[n_core].thread = core_map[n_core-1].thread + 1; */
/* OBSOLETE           n_core++; */
/* OBSOLETE         } */
/* OBSOLETE       else if ((scnhdr.s_flags & S_TYPMASK) == S_CONTEXT) */
/* OBSOLETE         context_offset = scnhdr.s_scnptr; */
/* OBSOLETE       else if ((scnhdr.s_flags & S_TYPMASK) == S_TCONTEXT)  */
/* OBSOLETE         tcontext_offset[n_threads++] = scnhdr.s_scnptr; */
/* OBSOLETE     } */
d881 1
a881 1
/* OBSOLETE      and the comm regs.  *x/ */
d885 1
a885 1
/* OBSOLETE     perror_with_name (filename); */
d888 1
a888 1
/* OBSOLETE     perror_with_name (filename); */
d891 1
a891 1
/* OBSOLETE     perror_with_name (filename); */
d895 1
a895 1
/* OBSOLETE      for xfer_core_file so we can do read_memory on it. *x/ */
d898 1
a898 1
/* OBSOLETE     corefile = savestring (filename, strlen (filename)); */
d900 1
a900 1
/* OBSOLETE     corefile = concat (current_directory, "/", filename, NULL); */
d907 2
a908 2
/* OBSOLETE     { */
/* OBSOLETE       select_thread (n); */
d910 30
a939 30
/* OBSOLETE       lseek (corechan, tcontext_offset[n], 0); */
/* OBSOLETE       if (myread (corechan, &tc, sizeof tc) < 0) */
/* OBSOLETE         perror_with_name (corefile); */
/* OBSOLETE       lseek (corechan, tc.core_thread_p, 0); */
/* OBSOLETE       if (myread (corechan, &th, sizeof th) < 0) */
/* OBSOLETE         perror_with_name (corefile); */
/* OBSOLETE  */
/* OBSOLETE       lseek (corechan, tc.core_syscall_context_p, 0); */
/* OBSOLETE       if (myread (corechan, registers, REGISTER_BYTES) < 0) */
/* OBSOLETE         perror_with_name (corefile); */
/* OBSOLETE  */
/* OBSOLETE       thread_signal[n] = th.t_cursig; */
/* OBSOLETE       thread_sigcode[n] = th.t_code; */
/* OBSOLETE       thread_state[n] = th.t_state; */
/* OBSOLETE       thread_pc[n] = read_pc (); */
/* OBSOLETE  */
/* OBSOLETE       if (thread_pc[n] > STACK_END_ADDR) */
/* OBSOLETE         { */
/* OBSOLETE           POP_FRAME; */
/* OBSOLETE           if (is_break_pc (thread_pc[n])) */
/* OBSOLETE             thread_pc[n] = read_pc () - 2; */
/* OBSOLETE           else */
/* OBSOLETE             thread_pc[n] = read_pc (); */
/* OBSOLETE           write_register (PC_REGNUM, thread_pc[n]); */
/* OBSOLETE         } */
/* OBSOLETE  */
/* OBSOLETE       printf_filtered ("thread %d received signal %d, %s\n", */
/* OBSOLETE                        n, thread_signal[n], */
/* OBSOLETE                        safe_strsignal (thread_signal[n])); */
/* OBSOLETE     } */
d942 1
a942 1
/* OBSOLETE      so find one that didn't.  *x/ */
d945 7
a951 7
/* OBSOLETE     if (thread_signal[n] != 0 && thread_signal[n] != SIGKILL) */
/* OBSOLETE       { */
/* OBSOLETE         select_thread (n); */
/* OBSOLETE         stop_signal = thread_signal[n]; */
/* OBSOLETE         stop_sigcode = thread_sigcode[n]; */
/* OBSOLETE         break; */
/* OBSOLETE       } */
@

