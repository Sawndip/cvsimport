head	1.37;
access;
symbols
	gdb_6_3-20041109-release:1.36
	gdb_6_3-branch:1.36.0.2
	gdb_6_3-20041019-branchpoint:1.36
	drow_intercu-merge-20040921:1.35
	drow_intercu-merge-20040915:1.35
	jimb-gdb_6_2-e500-branch:1.32.0.6
	jimb-gdb_6_2-e500-branchpoint:1.32
	gdb_6_2-20040730-release:1.32
	gdb_6_2-branch:1.32.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.32
	gdb_6_1_1-20040616-release:1.30
	gdb_6_1-2004-04-05-release:1.30
	drow_intercu-merge-20040402:1.30
	drow_intercu-merge-20040327:1.30
	ezannoni_pie-20040323-branch:1.30.0.12
	ezannoni_pie-20040323-branchpoint:1.30
	cagney_tramp-20040321-mergepoint:1.30
	cagney_tramp-20040309-branch:1.30.0.10
	cagney_tramp-20040309-branchpoint:1.30
	gdb_6_1-branch:1.30.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.30
	drow_intercu-20040221-branch:1.30.0.6
	drow_intercu-20040221-branchpoint:1.30
	cagney_bfdfile-20040213-branch:1.30.0.4
	cagney_bfdfile-20040213-branchpoint:1.30
	drow-cplus-merge-20040208:1.30
	carlton_dictionary-20040126-merge:1.30
	cagney_bigcore-20040122-branch:1.30.0.2
	cagney_bigcore-20040122-branchpoint:1.30
	drow-cplus-merge-20040113:1.30
	drow-cplus-merge-20031224:1.30
	drow-cplus-merge-20031220:1.30
	carlton_dictionary-20031215-merge:1.30
	drow-cplus-merge-20031214:1.30
	carlton-dictionary-20031111-merge:1.30
	gdb_6_0-2003-10-04-release:1.26.10.1
	kettenis_sparc-20030918-branch:1.29.0.4
	kettenis_sparc-20030918-branchpoint:1.29
	carlton_dictionary-20030917-merge:1.29
	ezannoni_pie-20030916-branchpoint:1.29
	ezannoni_pie-20030916-branch:1.29.0.2
	cagney_x86i386-20030821-branch:1.27.0.2
	cagney_x86i386-20030821-branchpoint:1.27
	carlton_dictionary-20030805-merge:1.27
	carlton_dictionary-20030627-merge:1.26
	gdb_6_0-branch:1.26.0.10
	gdb_6_0-2003-06-23-branchpoint:1.26
	jimb-ppc64-linux-20030613-branch:1.26.0.8
	jimb-ppc64-linux-20030613-branchpoint:1.26
	cagney_convert-20030606-branch:1.26.0.6
	cagney_convert-20030606-branchpoint:1.26
	cagney_writestrings-20030508-branch:1.25.0.6
	cagney_writestrings-20030508-branchpoint:1.25
	jimb-ppc64-linux-20030528-branch:1.26.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.26
	carlton_dictionary-20030523-merge:1.26
	cagney_fileio-20030521-branch:1.26.0.2
	cagney_fileio-20030521-branchpoint:1.26
	kettenis_i386newframe-20030517-mergepoint:1.26
	jimb-ppc64-linux-20030509-branch:1.25.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.25
	kettenis_i386newframe-20030504-mergepoint:1.25
	carlton_dictionary-20030430-merge:1.25
	kettenis_i386newframe-20030419-branch:1.25.0.2
	kettenis_i386newframe-20030419-branchpoint:1.25
	carlton_dictionary-20030416-merge:1.25
	cagney_frameaddr-20030409-mergepoint:1.25
	kettenis_i386newframe-20030406-branch:1.23.0.16
	kettenis_i386newframe-20030406-branchpoint:1.23
	cagney_frameaddr-20030403-branchpoint:1.23
	cagney_frameaddr-20030403-branch:1.23.0.14
	cagney_framebase-20030330-mergepoint:1.23
	cagney_framebase-20030326-branch:1.23.0.12
	cagney_framebase-20030326-branchpoint:1.23
	cagney_lazyid-20030317-branch:1.23.0.10
	cagney_lazyid-20030317-branchpoint:1.23
	kettenis-i386newframe-20030316-mergepoint:1.23
	offbyone-20030313-branch:1.23.0.8
	offbyone-20030313-branchpoint:1.23
	kettenis-i386newframe-20030308-branch:1.23.0.6
	kettenis-i386newframe-20030308-branchpoint:1.23
	carlton_dictionary-20030305-merge:1.23
	cagney_offbyone-20030303-branch:1.23.0.4
	cagney_offbyone-20030303-branchpoint:1.23
	carlton_dictionary-20030207-merge:1.23
	interps-20030203-mergepoint:1.23
	interps-20030202-branch:1.23.0.2
	interps-20030202-branchpoint:1.23
	cagney-unwind-20030108-branch:1.22.0.2
	cagney-unwind-20030108-branchpoint:1.22
	carlton_dictionary-20021223-merge:1.22
	gdb_5_3-2002-12-12-release:1.19
	carlton_dictionary-20021115-merge:1.21
	kseitz_interps-20021105-merge:1.20
	kseitz_interps-20021103-merge:1.20
	drow-cplus-merge-20021020:1.19
	drow-cplus-merge-20021025:1.19
	carlton_dictionary-20021025-merge:1.19
	carlton_dictionary-20021011-merge:1.19
	drow-cplus-branch:1.19.0.18
	drow-cplus-branchpoint:1.19
	kseitz_interps-20020930-merge:1.19
	carlton_dictionary-20020927-merge:1.19
	carlton_dictionary-branch:1.19.0.16
	carlton_dictionary-20020920-branchpoint:1.19
	gdb_5_3-branch:1.19.0.14
	gdb_5_3-2002-09-04-branchpoint:1.19
	kseitz_interps-20020829-merge:1.19
	cagney_sysregs-20020825-branch:1.19.0.12
	cagney_sysregs-20020825-branchpoint:1.19
	readline_4_3-import-branch:1.19.0.10
	readline_4_3-import-branchpoint:1.19
	gdb_5_2_1-2002-07-23-release:1.19
	kseitz_interps-20020528-branch:1.19.0.8
	kseitz_interps-20020528-branchpoint:1.19
	cagney_regbuf-20020515-branch:1.19.0.6
	cagney_regbuf-20020515-branchpoint:1.19
	jimb-macro-020506-branch:1.19.0.4
	jimb-macro-020506-branchpoint:1.19
	gdb_5_2-2002-04-29-release:1.19
	gdb_5_2-branch:1.19.0.2
	gdb_5_2-2002-03-03-branchpoint:1.19
	gdb_5_1_1-2002-01-24-release:1.17.4.1
	gdb_5_1_0_1-2002-01-03-release:1.17.4.1
	cygnus_cvs_20020108_pre:1.18
	gdb_5_1_0_1-2002-01-03-branchpoint:1.17.4.1
	gdb_5_1_0_1-2002-01-03-branch:1.17.4.1.0.2
	gdb_5_1-2001-11-21-release:1.17.4.1
	gdb_s390-2001-09-26-branch:1.17.0.6
	gdb_s390-2001-09-26-branchpoint:1.17
	gdb_5_1-2001-07-29-branch:1.17.0.4
	gdb_5_1-2001-07-29-branchpoint:1.17
	dberlin-typesystem-branch:1.17.0.2
	dberlin-typesystem-branchpoint:1.17
	gdb-post-ptid_t-2001-05-03:1.17
	gdb-pre-ptid_t-2001-05-03:1.16
	insight-precleanup-2001-01-01:1.10
	gdb-post-protoization-2000-07-29:1.5
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb-post-params-removal-2000-06-04:1.4
	gdb-pre-params-removal-2000-06-04:1.4
	gdb-post-params-removal-2000-05-28:1.4
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.6
	gdb-1999-11-16:1.1.1.6
	gdb-1999-11-08:1.1.1.6
	gdb-1999-11-01:1.1.1.6
	gdb-1999-10-25:1.1.1.6
	gdb-1999-10-18:1.1.1.6
	gdb-1999-10-11:1.1.1.6
	gdb-1999-10-04:1.1.1.5
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.4
	gdb-1999-09-13:1.1.1.4
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.37
date	2004.11.13.23.10.01;	author cagney;	state dead;
branches;
next	1.36;

1.36
date	2004.10.08.20.29.54;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2004.09.11.10.24.50;	author hilfingr;	state Exp;
branches;
next	1.34;

1.34
date	2004.08.03.02.02.23;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.26.14.53.04;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.25.14.58.30;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.10.04.20.46;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.21.01.26.45;	author cagney;	state Exp;
branches
	1.30.6.1;
next	1.29;

1.29
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.14.16.32.13;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.04.01.27.25;	author brobecke;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.17.05.59.58;	author cagney;	state Exp;
branches
	1.26.10.1;
next	1.25;

1.25
date	2003.04.08.19.21.15;	author ezannoni;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2003.04.08.18.52.04;	author ezannoni;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.18.15.55.52;	author cagney;	state Exp;
branches
	1.23.14.1;
next	1.22;

1.22
date	2002.12.17.00.39.07;	author kevinb;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.14.00.25.03;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.25.22.25.55;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.19.03.32.40;	author cagney;	state Exp;
branches
	1.19.8.1
	1.19.16.1
	1.19.18.1;
next	1.18;

1.18
date	2001.10.31.22.29.21;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.04.04.15.26;	author kevinb;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	2001.03.06.08.21.13;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.02.19.14.33;	author jtc;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.27.00.43.26;	author fnasser;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.23.22.48.55;	author jtc;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.15.01.01.49;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.30.21.50.57;	author jtc;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.16.06.42.28;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.27.22.30.29;	author ezannoni;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.02.14.52.10;	author ezannoni;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.04.16.52.34;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.47;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.09.24;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.09.21.33.49;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.09.08.23.59.28;	author shebs;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.10.05.23.08.42;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.10.12.04.37.24;	author jsm;	state Exp;
branches;
next	;

1.17.4.1
date	2001.10.31.22.24.45;	author cagney;	state Exp;
branches;
next	;

1.19.8.1
date	2002.11.04.00.17.32;	author ezannoni;	state Exp;
branches;
next	;

1.19.16.1
date	2002.11.15.19.18.54;	author carlton;	state Exp;
branches;
next	1.19.16.2;

1.19.16.2
date	2002.12.23.19.38.40;	author carlton;	state Exp;
branches;
next	1.19.16.3;

1.19.16.3
date	2003.02.07.19.17.52;	author carlton;	state Exp;
branches;
next	1.19.16.4;

1.19.16.4
date	2003.04.16.19.56.54;	author carlton;	state Exp;
branches;
next	1.19.16.5;

1.19.16.5
date	2003.05.23.18.40.43;	author carlton;	state Exp;
branches;
next	1.19.16.6;

1.19.16.6
date	2003.08.05.17.13.13;	author carlton;	state Exp;
branches;
next	1.19.16.7;

1.19.16.7
date	2003.09.17.21.28.29;	author carlton;	state Exp;
branches;
next	1.19.16.8;

1.19.16.8
date	2003.11.11.23.50.53;	author carlton;	state Exp;
branches;
next	;

1.19.18.1
date	2003.12.14.20.27.29;	author drow;	state Exp;
branches;
next	;

1.23.14.1
date	2003.04.10.21.33.49;	author cagney;	state Exp;
branches;
next	;

1.25.2.1
date	2003.05.18.09.44.20;	author kettenis;	state Exp;
branches;
next	;

1.26.10.1
date	2003.07.04.01.30.30;	author brobecke;	state Exp;
branches;
next	;

1.30.6.1
date	2004.09.16.17.01.18;	author drow;	state Exp;
branches;
next	;


desc
@@


1.37
log
@2004-11-13  Andrew Cagney  <cagney@@gnu.org>

	* configure.tgt: Delete i[34567]86-*-vxworks*, m68*-netx-*,
	m68*-*-vxworks*, mips*-*-vxworks*, powerpc-*-vxworks*, and
	sparc-*-vxworks*.
	* NEWS: Mention that vxworks was deleted.
	* config/m68k/tm-vx68.h, config/mips/tm-vxmips.h: Delete.
	* config/powerpc/tm-vxworks.h, config/tm-vxworks.h: Delete.
	* config/i386/vxworks.mt, config/m68k/vxworks68.mt: Delete.
	* config/mips/vxmips.mt, config/powerpc/vxworks.mt: Delete.
	* config/sparc/vxworks.mt, vx-share/dbgRpcLib.h: Delete.
	* vx-share/ptrace.h, vx-share/regPacket.h: Delete.
	* vx-share/vxTypes.h, vx-share/vxWorks.h: Delete.
	* vx-share/wait.h, vx-share/xdr_ld.c: Delete.
	* vx-share/xdr_ld.h, vx-share/xdr_ptrace.c: Delete.
	* vx-share/xdr_ptrace.h, vx-share/xdr_rdb.c: Delete.
	* vx-share/xdr_rdb.h, remote-vxsparc.c: Delete.
	* remote-vxmips.c, remote-vx.c: Delete.
	* remote-vx68.c: Delete.
	* config/m68k/tm-os68k.h: Remove reference to VxWorks.
	* config/m68k/os68k.mt, ada-lang.h: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, ALLDEPFILES, remote-vx68.o)
	(remote-vx.o, remote-vxmips.o, remote-vxsparc.o): Delete vx files.
@
text
@/* Memory-access and commands for remote VxWorks processes, for GDB.

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1998, 1999,
   2000, 2001, 2002 Free Software Foundation, Inc.

   Contributed by Wind River Systems and Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "target.h"
#include "gdbcore.h"
#include "command.h"
#include "symtab.h"
#include "complaints.h"
#include "gdbcmd.h"
#include "bfd.h"		/* Required by objfiles.h.  */
#include "symfile.h"
#include "objfiles.h"
#include "gdb-stabs.h"
#include "regcache.h"

#include "gdb_string.h"
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/socket.h>
#define malloc bogon_malloc	/* Sun claims "char *malloc()" not void * */
#define free bogon_free		/* Sun claims "int free()" not void */
#define realloc bogon_realloc	/* Sun claims "char *realloc()", not void * */
#include <rpc/rpc.h>
#undef malloc
#undef free
#undef realloc
#include <sys/time.h>		/* UTek's <rpc/rpc.h> doesn't #incl this */
#include <netdb.h>
#include "vx-share/ptrace.h"
#include "vx-share/xdr_ptrace.h"
#include "vx-share/xdr_ld.h"
#include "vx-share/xdr_rdb.h"
#include "vx-share/dbgRpcLib.h"

#include <symtab.h>

/* Maximum number of bytes to transfer in a single
   PTRACE_{READ,WRITE}DATA request.  */
#define VX_MEMXFER_MAX 4096

extern void vx_read_register ();
extern void vx_write_register ();
extern void symbol_file_command ();
extern enum stop_kind stop_soon;	/* for wait_for_inferior */

static int net_step ();
static int net_ptrace_clnt_call ();	/* Forward decl */
static enum clnt_stat net_clnt_call ();		/* Forward decl */

/* Target ops structure for accessing memory and such over the net */

static struct target_ops vx_ops;

/* Target ops structure for accessing VxWorks child processes over the net */

static struct target_ops vx_run_ops;

/* Saved name of target host and called function for "info files".
   Both malloc'd.  */

static char *vx_host;
static char *vx_running;	/* Called function */

/* Nonzero means target that is being debugged remotely has a floating
   point processor.  */

int target_has_fp;

/* Default error message when the network is forking up.  */

static const char rpcerr[] = "network target debugging:  rpc error";

CLIENT *pClient;		/* client used in net debugging */
static int ptraceSock = RPC_ANYSOCK;

enum clnt_stat net_clnt_call ();
static void parse_args ();

static struct timeval rpcTimeout =
{10, 0};

static char *skip_white_space ();
static char *find_white_space ();

/* Tell the VxWorks target system to download a file.
   The load addresses of the text, data, and bss segments are
   stored in *pTextAddr, *pDataAddr, and *pBssAddr (respectively).
   Returns 0 for success, -1 for failure.  */

static int
net_load (char *filename, CORE_ADDR *pTextAddr, CORE_ADDR *pDataAddr,
	  CORE_ADDR *pBssAddr)
{
  enum clnt_stat status;
  struct ldfile ldstruct;
  struct timeval load_timeout;

  memset ((char *) &ldstruct, '\0', sizeof (ldstruct));

  /* We invoke clnt_call () here directly, instead of through
     net_clnt_call (), because we need to set a large timeout value.
     The load on the target side can take quite a while, easily
     more than 10 seconds.  The user can kill this call by typing
     CTRL-C if there really is a problem with the load.  

     Do not change the tv_sec value without checking -- select() imposes
     a limit of 10**8 on it for no good reason that I can see...  */

  load_timeout.tv_sec = 99999999;	/* A large number, effectively inf. */
  load_timeout.tv_usec = 0;

  status = clnt_call (pClient, VX_LOAD, xdr_wrapstring, &filename, xdr_ldfile,
		      &ldstruct, load_timeout);

  if (status == RPC_SUCCESS)
    {
      if (*ldstruct.name == 0)	/* load failed on VxWorks side */
	return -1;
      *pTextAddr = ldstruct.txt_addr;
      *pDataAddr = ldstruct.data_addr;
      *pBssAddr = ldstruct.bss_addr;
      return 0;
    }
  else
    return -1;
}

/* returns 0 if successful, errno if RPC failed or VxWorks complains. */

static int
net_break (int addr, u_long procnum)
{
  enum clnt_stat status;
  int break_status;
  Rptrace ptrace_in;		/* XXX This is stupid.  It doesn't need to be a ptrace
				   structure.  How about something smaller? */

  memset ((char *) &ptrace_in, '\0', sizeof (ptrace_in));
  break_status = 0;

  ptrace_in.addr = addr;
  ptrace_in.pid = PIDGET (inferior_ptid);

  status = net_clnt_call (procnum, xdr_rptrace, &ptrace_in, xdr_int,
			  &break_status);

  if (status != RPC_SUCCESS)
    return errno;

  if (break_status == -1)
    return ENOMEM;
  return break_status;		/* probably (FIXME) zero */
}

/* returns 0 if successful, errno otherwise */

static int
vx_insert_breakpoint (int addr)
{
  return net_break (addr, VX_BREAK_ADD);
}

/* returns 0 if successful, errno otherwise */

static int
vx_remove_breakpoint (int addr)
{
  return net_break (addr, VX_BREAK_DELETE);
}

/* Start an inferior process and sets inferior_ptid to its pid.
   EXEC_FILE is the file to run.
   ALLARGS is a string containing the arguments to the program.
   ENV is the environment vector to pass.
   Returns process id.  Errors reported with error().
   On VxWorks, we ignore exec_file.  */

static void
vx_create_inferior (char *exec_file, char *args, char **env, int from_tty)
{
  enum clnt_stat status;
  arg_array passArgs;
  TASK_START taskStart;

  memset ((char *) &passArgs, '\0', sizeof (passArgs));
  memset ((char *) &taskStart, '\0', sizeof (taskStart));

  /* parse arguments, put them in passArgs */

  parse_args (args, &passArgs);

  if (passArgs.arg_array_len == 0)
    error ("You must specify a function name to run, and arguments if any");

  status = net_clnt_call (PROCESS_START, xdr_arg_array, &passArgs,
			  xdr_TASK_START, &taskStart);

  if ((status != RPC_SUCCESS) || (taskStart.status == -1))
    error ("Can't create process on remote target machine");

  /* Save the name of the running function */
  vx_running = savestring (passArgs.arg_array_val[0],
			   strlen (passArgs.arg_array_val[0]));

  push_target (&vx_run_ops);
  inferior_ptid = pid_to_ptid (taskStart.pid);

  /* We will get a trace trap after one instruction.
     Insert breakpoints and continue.  */

  init_wait_for_inferior ();

  /* Set up the "saved terminal modes" of the inferior
     based on what modes we are starting it with.  */
  target_terminal_init ();

  /* Install inferior's terminal modes.  */
  target_terminal_inferior ();

  stop_soon = STOP_QUIETLY;
  wait_for_inferior ();		/* Get the task spawn event */
  stop_soon = NO_STOP_QUIETLY;

  /* insert_step_breakpoint ();  FIXME, do we need this?  */
  proceed (-1, TARGET_SIGNAL_DEFAULT, 0);
}

/* Fill ARGSTRUCT in argc/argv form with the arguments from the
   argument string ARGSTRING.  */

static void
parse_args (char *arg_string, arg_array *arg_struct)
{
  int arg_count = 0;	/* number of arguments */
  int arg_index = 0;
  char *p0;

  memset ((char *) arg_struct, '\0', sizeof (arg_array));

  /* first count how many arguments there are */

  p0 = arg_string;
  while (*p0 != '\0')
    {
      if (*(p0 = skip_white_space (p0)) == '\0')
	break;
      p0 = find_white_space (p0);
      arg_count++;
    }

  arg_struct->arg_array_len = arg_count;
  arg_struct->arg_array_val = (char **) xmalloc ((arg_count + 1)
						 * sizeof (char *));

  /* now copy argument strings into arg_struct.  */

  while (*(arg_string = skip_white_space (arg_string)))
    {
      p0 = find_white_space (arg_string);
      arg_struct->arg_array_val[arg_index++] = savestring (arg_string,
							   p0 - arg_string);
      arg_string = p0;
    }

  arg_struct->arg_array_val[arg_count] = NULL;
}

/* Advance a string pointer across whitespace and return a pointer
   to the first non-white character.  */

static char *
skip_white_space (char *p)
{
  while (*p == ' ' || *p == '\t')
    p++;
  return p;
}

/* Search for the first unquoted whitespace character in a string.
   Returns a pointer to the character, or to the null terminator
   if no whitespace is found.  */

static char *
find_white_space (char *p)
{
  int c;

  while ((c = *p) != ' ' && c != '\t' && c)
    {
      if (c == '\'' || c == '"')
	{
	  while (*++p != c && *p)
	    {
	      if (*p == '\\')
		p++;
	    }
	  if (!*p)
	    break;
	}
      p++;
    }
  return p;
}

/* Poll the VxWorks target system for an event related
   to the debugged task.
   Returns -1 if remote wait failed, task status otherwise.  */

static int
net_wait (RDB_EVENT *pEvent)
{
  int pid;
  enum clnt_stat status;

  memset ((char *) pEvent, '\0', sizeof (RDB_EVENT));

  pid = PIDGET (inferior_ptid);
  status = net_clnt_call (PROCESS_WAIT, xdr_int, &pid, xdr_RDB_EVENT,
			  pEvent);

  /* return (status == RPC_SUCCESS)? pEvent->status: -1; */
  if (status == RPC_SUCCESS)
    return ((pEvent->status) ? 1 : 0);
  else if (status == RPC_TIMEDOUT)
    return (1);
  else
    return (-1);
}

/* Suspend the remote task.
   Returns -1 if suspend fails on target system, 0 otherwise.  */

static int
net_quit (void)
{
  int pid;
  int quit_status;
  enum clnt_stat status;

  quit_status = 0;

  /* don't let rdbTask suspend itself by passing a pid of 0 */

  if ((pid = PIDGET (inferior_ptid)) == 0)
    return -1;

  status = net_clnt_call (VX_TASK_SUSPEND, xdr_int, &pid, xdr_int,
			  &quit_status);

  return (status == RPC_SUCCESS) ? quit_status : -1;
}

/* Read a register or registers from the remote system.  */

void
net_read_registers (char *reg_buf, int len, u_long procnum)
{
  int status;
  Rptrace ptrace_in;
  Ptrace_return ptrace_out;
  C_bytes out_data;
  char message[100];

  memset ((char *) &ptrace_in, '\0', sizeof (ptrace_in));
  memset ((char *) &ptrace_out, '\0', sizeof (ptrace_out));

  /* Initialize RPC input argument structure.  */

  ptrace_in.pid = PIDGET (inferior_ptid);
  ptrace_in.info.ttype = NOINFO;

  /* Initialize RPC return value structure.  */

  out_data.bytes = reg_buf;
  out_data.len = len;
  ptrace_out.info.more_data = (caddr_t) & out_data;

  /* Call RPC; take an error exit if appropriate.  */

  status = net_ptrace_clnt_call (procnum, &ptrace_in, &ptrace_out);
  if (status)
    error (rpcerr);
  if (ptrace_out.status == -1)
    {
      errno = ptrace_out.errno_num;
      sprintf (message, "reading %s registers", (procnum == PTRACE_GETREGS)
	       ? "general-purpose"
	       : "floating-point");
      perror_with_name (message);
    }
}

/* Write register values to a VxWorks target.  REG_BUF points to a buffer
   containing the raw register values, LEN is the length of REG_BUF in
   bytes, and PROCNUM is the RPC procedure number (PTRACE_SETREGS or
   PTRACE_SETFPREGS).  An error exit is taken if the RPC call fails or
   if an error status is returned by the remote debug server.  This is
   a utility routine used by vx_write_register ().  */

void
net_write_registers (char *reg_buf, int len, u_long procnum)
{
  int status;
  Rptrace ptrace_in;
  Ptrace_return ptrace_out;
  C_bytes in_data;
  char message[100];

  memset ((char *) &ptrace_in, '\0', sizeof (ptrace_in));
  memset ((char *) &ptrace_out, '\0', sizeof (ptrace_out));

  /* Initialize RPC input argument structure.  */

  in_data.bytes = reg_buf;
  in_data.len = len;

  ptrace_in.pid = PIDGET (inferior_ptid);
  ptrace_in.info.ttype = DATA;
  ptrace_in.info.more_data = (caddr_t) & in_data;

  /* Call RPC; take an error exit if appropriate.  */

  status = net_ptrace_clnt_call (procnum, &ptrace_in, &ptrace_out);
  if (status)
    error (rpcerr);
  if (ptrace_out.status == -1)
    {
      errno = ptrace_out.errno_num;
      sprintf (message, "writing %s registers", (procnum == PTRACE_SETREGS)
	       ? "general-purpose"
	       : "floating-point");
      perror_with_name (message);
    }
}

/* Prepare to store registers.  Since we will store all of them,
   read out their current values now.  */

static void
vx_prepare_to_store (void)
{
  /* Fetch all registers, if any of them are not yet fetched.  */
  deprecated_read_register_bytes (0, NULL, deprecated_register_bytes ());
}

/* Copy LEN bytes to or from remote inferior's memory starting at MEMADDR
   to debugger memory starting at MYADDR.  WRITE is true if writing to the
   inferior.  TARGET is unused.
   Result is the number of bytes written or read (zero if error).  The
   protocol allows us to return a negative count, indicating that we can't
   handle the current address but can handle one N bytes further, but
   vxworks doesn't give us that information.  */

static int
vx_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		struct mem_attrib *attrib, struct target_ops *target)
{
  int status;
  Rptrace ptrace_in;
  Ptrace_return ptrace_out;
  C_bytes data;
  enum ptracereq request;
  int nleft, nxfer;

  memset ((char *) &ptrace_in, '\0', sizeof (ptrace_in));
  memset ((char *) &ptrace_out, '\0', sizeof (ptrace_out));

  ptrace_in.pid = PIDGET (inferior_ptid); /* XXX pid unnecessary for READDATA */
  ptrace_in.addr = (int) memaddr;	/* Where from */
  ptrace_in.data = len;		/* How many bytes */

  if (write)
    {
      ptrace_in.info.ttype = DATA;
      ptrace_in.info.more_data = (caddr_t) & data;

      data.bytes = (caddr_t) myaddr;	/* Where from */
      data.len = len;		/* How many bytes (again, for XDR) */
      request = PTRACE_WRITEDATA;
    }
  else
    {
      ptrace_out.info.more_data = (caddr_t) & data;
      request = PTRACE_READDATA;
    }
  /* Loop until the entire request has been satisfied, transferring
     at most VX_MEMXFER_MAX bytes per iteration.  Break from the loop
     if an error status is returned by the remote debug server.  */

  nleft = len;
  status = 0;

  while (nleft > 0 && status == 0)
    {
      nxfer = min (nleft, VX_MEMXFER_MAX);

      ptrace_in.addr = (int) memaddr;
      ptrace_in.data = nxfer;
      data.bytes = (caddr_t) myaddr;
      data.len = nxfer;

      /* Request a block from the remote debug server; if RPC fails,
         report an error and return to debugger command level.  */

      if (net_ptrace_clnt_call (request, &ptrace_in, &ptrace_out))
	error (rpcerr);

      status = ptrace_out.status;
      if (status == 0)
	{
	  memaddr += nxfer;
	  myaddr += nxfer;
	  nleft -= nxfer;
	}
      else
	{
	  /* A target-side error has ocurred.  Set errno to the error
	     code chosen by the target so that a later perror () will
	     say something meaningful.  */

	  errno = ptrace_out.errno_num;
	}
    }

  /* Return the number of bytes transferred.  */

  return (len - nleft);
}

static void
vx_files_info (void)
{
  printf_unfiltered ("\tAttached to host `%s'", vx_host);
  printf_unfiltered (", which has %sfloating point", target_has_fp ? "" : "no ");
  printf_unfiltered (".\n");
}

static void
vx_run_files_info (void)
{
  printf_unfiltered ("\tRunning %s VxWorks process %s",
		     vx_running ? "child" : "attached",
		     hex_string (PIDGET (inferior_ptid)));
  if (vx_running)
    printf_unfiltered (", function `%s'", vx_running);
  printf_unfiltered (".\n");
}

static void
vx_resume (ptid_t ptid, int step, enum target_signal siggnal)
{
  int status;
  Rptrace ptrace_in;
  Ptrace_return ptrace_out;
  CORE_ADDR cont_addr;

  if (ptid_equal (ptid, minus_one_ptid))
    ptid = inferior_ptid;

  if (siggnal != 0 && siggnal != stop_signal)
    error ("Cannot send signals to VxWorks processes");

  /* Set CONT_ADDR to the address at which we are continuing,
     or to 1 if we are continuing from where the program stopped.
     This conforms to traditional ptrace () usage, but at the same
     time has special meaning for the VxWorks remote debug server.
     If the address is not 1, the server knows that the target
     program is jumping to a new address, which requires special
     handling if there is a breakpoint at the new address.  */

  cont_addr = read_register (PC_REGNUM);
  if (cont_addr == stop_pc)
    cont_addr = 1;

  memset ((char *) &ptrace_in, '\0', sizeof (ptrace_in));
  memset ((char *) &ptrace_out, '\0', sizeof (ptrace_out));

  ptrace_in.pid = PIDGET (ptid);
  ptrace_in.addr = cont_addr;	/* Target side insists on this, or it panics.  */

  if (step)
    status = net_step ();
  else
    status = net_ptrace_clnt_call (PTRACE_CONT, &ptrace_in, &ptrace_out);

  if (status)
    error (rpcerr);
  if (ptrace_out.status == -1)
    {
      errno = ptrace_out.errno_num;
      perror_with_name ("Resuming remote process");
    }
}

static void
vx_mourn_inferior (void)
{
  pop_target ();		/* Pop back to no-child state */
  generic_mourn_inferior ();
}


static void vx_add_symbols (char *, int, CORE_ADDR, CORE_ADDR, CORE_ADDR);

struct find_sect_args
  {
    CORE_ADDR text_start;
    CORE_ADDR data_start;
    CORE_ADDR bss_start;
  };

static void find_sect (bfd *, asection *, void *);

static void
find_sect (bfd *abfd, asection *sect, void *obj)
{
  struct find_sect_args *args = (struct find_sect_args *) obj;

  if (bfd_get_section_flags (abfd, sect) & (SEC_CODE & SEC_READONLY))
    args->text_start = bfd_get_section_vma (abfd, sect);
  else if (bfd_get_section_flags (abfd, sect) & SEC_ALLOC)
    {
      if (bfd_get_section_flags (abfd, sect) & SEC_LOAD)
	{
	  /* Exclude .ctor and .dtor sections which have SEC_CODE set but not
	     SEC_DATA.  */
	  if (bfd_get_section_flags (abfd, sect) & SEC_DATA)
	    args->data_start = bfd_get_section_vma (abfd, sect);
	}
      else
	args->bss_start = bfd_get_section_vma (abfd, sect);
    }
}

static void
vx_add_symbols (char *name, int from_tty, CORE_ADDR text_addr,
		CORE_ADDR data_addr, CORE_ADDR bss_addr)
{
  struct section_offsets *offs;
  struct objfile *objfile;
  struct find_sect_args ss;

  /* It might be nice to suppress the breakpoint_re_set which happens here
     because we are going to do one again after the objfile_relocate.  */
  objfile = symbol_file_add (name, from_tty, NULL, 0, 0);

  /* This is a (slightly cheesy) way of superceding the old symbols.  A less
     cheesy way would be to find the objfile with the same name and
     free_objfile it.  */
  objfile_to_front (objfile);

  offs =
    (struct section_offsets *)
    alloca (SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
  memcpy (offs, objfile->section_offsets,
          SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));

  ss.text_start = 0;
  ss.data_start = 0;
  ss.bss_start = 0;
  bfd_map_over_sections (objfile->obfd, find_sect, &ss);

  /* Both COFF and b.out frontends use these SECT_OFF_* values.  */
  offs->offsets[SECT_OFF_TEXT (objfile)]  = text_addr - ss.text_start;
  offs->offsets[SECT_OFF_DATA (objfile)] = data_addr - ss.data_start;
  offs->offsets[SECT_OFF_BSS (objfile)] = bss_addr - ss.bss_start;
  objfile_relocate (objfile, offs);
}

/* This function allows the addition of incrementally linked object files.  */

static void
vx_load_command (char *arg_string, int from_tty)
{
  CORE_ADDR text_addr;
  CORE_ADDR data_addr;
  CORE_ADDR bss_addr;

  if (arg_string == 0)
    error ("The load command takes a file name");

  arg_string = tilde_expand (arg_string);
  make_cleanup (xfree, arg_string);

  dont_repeat ();

  /* Refuse to load the module if a debugged task is running.  Doing so
     can have a number of unpleasant consequences to the running task.  */

  if (PIDGET (inferior_ptid) != 0 && target_has_execution)
    {
      if (query ("You may not load a module while the target task is running.\n\
Kill the target task? "))
	target_kill ();
      else
	error ("Load canceled.");
    }

  QUIT;
  immediate_quit++;
  if (net_load (arg_string, &text_addr, &data_addr, &bss_addr) == -1)
    error ("Load failed on target machine");
  immediate_quit--;

  vx_add_symbols (arg_string, from_tty, text_addr, data_addr, bss_addr);

  /* Getting new symbols may change our opinion about what is
     frameless.  */
  reinit_frame_cache ();
}

/* Single step the target program at the source or machine level.
   Takes an error exit if rpc fails.
   Returns -1 if remote single-step operation fails, else 0.  */

static int
net_step (void)
{
  enum clnt_stat status;
  int step_status;
  SOURCE_STEP source_step;

  source_step.taskId = PIDGET (inferior_ptid);
  source_step.startAddr = 0;
  source_step.endAddr = 0;

  status = net_clnt_call (VX_SOURCE_STEP, xdr_SOURCE_STEP, &source_step,
			  xdr_int, &step_status);

  if (status == RPC_SUCCESS)
    return step_status;
  else
    error (rpcerr);
}

/* Emulate ptrace using RPC calls to the VxWorks target system.
   Returns nonzero (-1) if RPC status to VxWorks is bad, 0 otherwise.  */

static int
net_ptrace_clnt_call (enum ptracereq request, Rptrace *pPtraceIn,
		      Ptrace_return *pPtraceOut)
{
  enum clnt_stat status;

  status = net_clnt_call (request, xdr_rptrace, pPtraceIn, xdr_ptrace_return,
			  pPtraceOut);

  if (status != RPC_SUCCESS)
    return -1;

  return 0;
}

/* Query the target for the name of the file from which VxWorks was
   booted.  pBootFile is the address of a pointer to the buffer to
   receive the file name; if the pointer pointed to by pBootFile is 
   NULL, memory for the buffer will be allocated by XDR.
   Returns -1 if rpc failed, 0 otherwise.  */

static int
net_get_boot_file (char **pBootFile)
{
  enum clnt_stat status;

  status = net_clnt_call (VX_BOOT_FILE_INQ, xdr_void, (char *) 0,
			  xdr_wrapstring, pBootFile);
  return (status == RPC_SUCCESS) ? 0 : -1;
}

/* Fetch a list of loaded object modules from the VxWorks target
   and store in PLOADTABLE.
   Returns -1 if rpc failed, 0 otherwise
   There's no way to check if the returned loadTable is correct.
   VxWorks doesn't check it.  */

static int
net_get_symbols (ldtabl *pLoadTable)
{
  enum clnt_stat status;

  memset ((char *) pLoadTable, '\0', sizeof (struct ldtabl));

  status = net_clnt_call (VX_STATE_INQ, xdr_void, 0, xdr_ldtabl, pLoadTable);
  return (status == RPC_SUCCESS) ? 0 : -1;
}

/* Look up a symbol in the VxWorks target's symbol table.
   Returns status of symbol read on target side (0=success, -1=fail)
   Returns -1 and complain()s if rpc fails.  */

static int
vx_lookup_symbol (char *name,	/* symbol name */
		  CORE_ADDR *pAddr)
{
  enum clnt_stat status;
  SYMBOL_ADDR symbolAddr;

  *pAddr = 0;
  memset ((char *) &symbolAddr, '\0', sizeof (symbolAddr));

  status = net_clnt_call (VX_SYMBOL_INQ, xdr_wrapstring, &name,
			  xdr_SYMBOL_ADDR, &symbolAddr);
  if (status != RPC_SUCCESS)
    {
      complaint (&symfile_complaints, "Lost contact with VxWorks target");
      return -1;
    }

  *pAddr = symbolAddr.addr;
  return symbolAddr.status;
}

/* Check to see if the VxWorks target has a floating point coprocessor.
   Returns 1 if target has floating point processor, 0 otherwise.
   Calls error() if rpc fails.  */

static int
net_check_for_fp (void)
{
  enum clnt_stat status;
  bool_t fp = 0;		/* true if fp processor is present on target board */

  status = net_clnt_call (VX_FP_INQUIRE, xdr_void, 0, xdr_bool, &fp);
  if (status != RPC_SUCCESS)
    error (rpcerr);

  return (int) fp;
}

/* Establish an RPC connection with the VxWorks target system.
   Calls error () if unable to establish connection.  */

static void
net_connect (char *host)
{
  struct sockaddr_in destAddr;
  struct hostent *destHost;
  unsigned long addr;

  /* Get the internet address for the given host.  Allow a numeric
     IP address or a hostname.  */

  addr = inet_addr (host);
  if (addr == -1)
    {
      destHost = (struct hostent *) gethostbyname (host);
      if (destHost == NULL)
	/* FIXME: Probably should include hostname here in quotes.
	   For example if the user types "target vxworks vx960 " it should
	   say "Invalid host `vx960 '." not just "Invalid hostname".  */
	error ("Invalid hostname.  Couldn't find remote host address.");
      addr = *(unsigned long *) destHost->h_addr;
    }

  memset (&destAddr, '\0', sizeof (destAddr));

  destAddr.sin_addr.s_addr = addr;
  destAddr.sin_family = AF_INET;
  destAddr.sin_port = 0;	/* set to actual port that remote
				   ptrace is listening on.  */

  /* Create a tcp client transport on which to issue
     calls to the remote ptrace server.  */

  ptraceSock = RPC_ANYSOCK;
  pClient = clnttcp_create (&destAddr, RDBPROG, RDBVERS, &ptraceSock, 0, 0);
  /* FIXME, here is where we deal with different version numbers of the
     proto */

  if (pClient == NULL)
    {
      clnt_pcreateerror ("\tnet_connect");
      error ("Couldn't connect to remote target.");
    }
}

/* Sleep for the specified number of milliseconds 
 * (assumed to be less than 1000).
 * If select () is interrupted, returns immediately;
 * takes an error exit if select () fails for some other reason.
 */

static void
sleep_ms (long ms)
{
  struct timeval select_timeout;
  int status;

  select_timeout.tv_sec = 0;
  select_timeout.tv_usec = ms * 1000;

  status = select (0, (fd_set *) 0, (fd_set *) 0, (fd_set *) 0,
		   &select_timeout);

  if (status < 0 && errno != EINTR)
    perror_with_name ("select");
}

static ptid_t
vx_wait (ptid_t ptid_to_wait_for, struct target_waitstatus *status)
{
  int pid;
  RDB_EVENT rdbEvent;
  int quit_failed;

  do
    {
      /* If CTRL-C is hit during this loop,
         suspend the inferior process.  */

      quit_failed = 0;
      if (quit_flag)
	{
	  quit_failed = (net_quit () == -1);
	  quit_flag = 0;
	}

      /* If a net_quit () or net_wait () call has failed,
         allow the user to break the connection with the target.
         We can't simply error () out of this loop, since the 
         data structures representing the state of the inferior
         are in an inconsistent state.  */

      if (quit_failed || net_wait (&rdbEvent) == -1)
	{
	  terminal_ours ();
	  if (query ("Can't %s.  Disconnect from target system? ",
		     (quit_failed) ? "suspend remote task"
		     : "get status of remote task"))
	    {
	      target_mourn_inferior ();
	      error ("Use the \"target\" command to reconnect.");
	    }
	  else
	    {
	      terminal_inferior ();
	      continue;
	    }
	}

      pid = rdbEvent.taskId;
      if (pid == 0)
	{
	  sleep_ms (200);	/* FIXME Don't kill the network too badly */
	}
      else if (pid != PIDGET (inferior_ptid))
	internal_error (__FILE__, __LINE__,
			"Bad pid for debugged task: %s\n",
			hex_string ((unsigned long) pid));
    }
  while (pid == 0);

  /* The mostly likely kind.  */
  status->kind = TARGET_WAITKIND_STOPPED;

  switch (rdbEvent.eventType)
    {
    case EVENT_EXIT:
      status->kind = TARGET_WAITKIND_EXITED;
      /* FIXME is it possible to distinguish between a
         normal vs abnormal exit in VxWorks? */
      status->value.integer = 0;
      break;

    case EVENT_START:
      /* Task was just started. */
      status->value.sig = TARGET_SIGNAL_TRAP;
      break;

    case EVENT_STOP:
      status->value.sig = TARGET_SIGNAL_TRAP;
      /* XXX was it stopped by a signal?  act accordingly */
      break;

    case EVENT_BREAK:		/* Breakpoint was hit. */
      status->value.sig = TARGET_SIGNAL_TRAP;
      break;

    case EVENT_SUSPEND:	/* Task was suspended, probably by ^C. */
      status->value.sig = TARGET_SIGNAL_INT;
      break;

    case EVENT_BUS_ERR:	/* Task made evil nasty reference. */
      status->value.sig = TARGET_SIGNAL_BUS;
      break;

    case EVENT_ZERO_DIV:	/* Division by zero */
      status->value.sig = TARGET_SIGNAL_FPE;
      break;

    case EVENT_SIGNAL:
#ifdef I80960
      status->value.sig = i960_fault_to_signal (rdbEvent.sigType);
#else
      /* Back in the old days, before enum target_signal, this code used
         to add NSIG to the signal number and claim that PRINT_RANDOM_SIGNAL
         would take care of it.  But PRINT_RANDOM_SIGNAL has never been
         defined except on the i960, so I don't really know what we are
         supposed to do on other architectures.  */
      status->value.sig = TARGET_SIGNAL_UNKNOWN;
#endif
      break;
    }				/* switch */
  return pid_to_ptid (pid);
}

static int
symbol_stub (char *arg)
{
  symbol_file_add_main (arg, 0);
  return 1;
}

static int
add_symbol_stub (char *arg)
{
  struct ldfile *pLoadFile = (struct ldfile *) arg;

  printf_unfiltered ("\t%s: ", pLoadFile->name);
  vx_add_symbols (pLoadFile->name, 0, pLoadFile->txt_addr,
		  pLoadFile->data_addr, pLoadFile->bss_addr);
  printf_unfiltered ("ok\n");
  return 1;
}
/* Target command for VxWorks target systems.

   Used in vxgdb.  Takes the name of a remote target machine
   running vxWorks and connects to it to initialize remote network
   debugging.  */

static void
vx_open (char *args, int from_tty)
{
  extern int close ();
  char *bootFile;
  extern char *source_path;
  struct ldtabl loadTable;
  struct ldfile *pLoadFile;
  int i;
  extern CLIENT *pClient;
  int symbols_added = 0;

  if (!args)
    error_no_arg ("target machine name");

  target_preopen (from_tty);

  unpush_target (&vx_ops);
  printf_unfiltered ("Attaching remote machine across net...\n");
  gdb_flush (gdb_stdout);

  /* Allow the user to kill the connect attempt by typing ^C.
     Wait until the call to target_has_fp () completes before
     disallowing an immediate quit, since even if net_connect ()
     is successful, the remote debug server might be hung.  */

  immediate_quit++;

  net_connect (args);
  target_has_fp = net_check_for_fp ();
  printf_filtered ("Connected to %s.\n", args);

  immediate_quit--;

  push_target (&vx_ops);

  /* Save a copy of the target host's name.  */
  vx_host = savestring (args, strlen (args));

  /* Find out the name of the file from which the target was booted
     and load its symbol table.  */

  printf_filtered ("Looking in Unix path for all loaded modules:\n");
  bootFile = NULL;
  if (!net_get_boot_file (&bootFile))
    {
      if (*bootFile)
	{
	  printf_filtered ("\t%s: ", bootFile);
	  /* This assumes that the kernel is never relocated.  Hope that is an
	     accurate assumption.  */
	  if (catch_errors
	      (symbol_stub,
	       bootFile,
	       "Error while reading symbols from boot file:\n",
	       RETURN_MASK_ALL))
	    puts_filtered ("ok\n");
	}
      else if (from_tty)
	printf_unfiltered ("VxWorks kernel symbols not loaded.\n");
    }
  else
    error ("Can't retrieve boot file name from target machine.");

  clnt_freeres (pClient, xdr_wrapstring, &bootFile);

  if (net_get_symbols (&loadTable) != 0)
    error ("Can't read loaded modules from target machine");

  i = 0 - 1;
  while (++i < loadTable.tbl_size)
    {
      QUIT;			/* FIXME, avoids clnt_freeres below:  mem leak */
      pLoadFile = &loadTable.tbl_ent[i];
#ifdef WRS_ORIG
      {
	int desc;
	struct cleanup *old_chain;
	char *fullname = NULL;

	desc = openp (source_path, 0, pLoadFile->name, O_RDONLY, 0, &fullname);
	if (desc < 0)
	  perror_with_name (pLoadFile->name);
	old_chain = make_cleanup (close, desc);
	add_file_at_addr (fullname, desc, pLoadFile->txt_addr, pLoadFile->data_addr,
			  pLoadFile->bss_addr);
	do_cleanups (old_chain);
      }
#else
      /* FIXME: Is there something better to search than the PATH? (probably
         not the source path, since source might be in different directories
         than objects.  */

      if (catch_errors (add_symbol_stub, (char *) pLoadFile, (char *) 0,
			RETURN_MASK_ALL))
	symbols_added = 1;
#endif
    }
  printf_filtered ("Done.\n");

  clnt_freeres (pClient, xdr_ldtabl, &loadTable);

  /* Getting new symbols may change our opinion about what is
     frameless.  */
  if (symbols_added)
    reinit_frame_cache ();
}

/* Takes a task started up outside of gdb and ``attaches'' to it.
   This stops it cold in its tracks and allows us to start tracing it.  */

static void
vx_attach (char *args, int from_tty)
{
  unsigned long pid;
  char *cptr = 0;
  Rptrace ptrace_in;
  Ptrace_return ptrace_out;
  int status;

  if (!args)
    error_no_arg ("process-id to attach");

  pid = strtoul (args, &cptr, 0);
  if ((cptr == args) || (*cptr != '\0'))
    error ("Invalid process-id -- give a single number in decimal or 0xhex");

  if (from_tty)
    printf_unfiltered ("Attaching pid %s.\n",
		       hex_string ((unsigned long) pid));

  memset ((char *) &ptrace_in, '\0', sizeof (ptrace_in));
  memset ((char *) &ptrace_out, '\0', sizeof (ptrace_out));
  ptrace_in.pid = pid;

  status = net_ptrace_clnt_call (PTRACE_ATTACH, &ptrace_in, &ptrace_out);
  if (status == -1)
    error (rpcerr);
  if (ptrace_out.status == -1)
    {
      errno = ptrace_out.errno_num;
      perror_with_name ("Attaching remote process");
    }

  /* It worked... */

  inferior_ptid = pid_to_ptid (pid);
  push_target (&vx_run_ops);

  if (vx_running)
    xfree (vx_running);
  vx_running = 0;
}

/* detach_command --
   takes a program previously attached to and detaches it.
   The program resumes execution and will no longer stop
   on signals, etc.  We better not have left any breakpoints
   in the program or it'll die when it hits one.  For this
   to work, it may be necessary for the process to have been
   previously attached.  It *might* work if the program was
   started via the normal ptrace (PTRACE_TRACEME).  */

static void
vx_detach (char *args, int from_tty)
{
  Rptrace ptrace_in;
  Ptrace_return ptrace_out;
  int signal = 0;
  int status;

  if (args)
    error ("Argument given to VxWorks \"detach\".");

  if (from_tty)
    printf_unfiltered ("Detaching pid %s.\n",
		       hex_string (
		         (unsigned long) PIDGET (inferior_ptid)));

  if (args)			/* FIXME, should be possible to leave suspended */
    signal = atoi (args);

  memset ((char *) &ptrace_in, '\0', sizeof (ptrace_in));
  memset ((char *) &ptrace_out, '\0', sizeof (ptrace_out));
  ptrace_in.pid = PIDGET (inferior_ptid);

  status = net_ptrace_clnt_call (PTRACE_DETACH, &ptrace_in, &ptrace_out);
  if (status == -1)
    error (rpcerr);
  if (ptrace_out.status == -1)
    {
      errno = ptrace_out.errno_num;
      perror_with_name ("Detaching VxWorks process");
    }

  inferior_ptid = null_ptid;
  pop_target ();		/* go back to non-executing VxWorks connection */
}

/* vx_kill -- takes a running task and wipes it out.  */

static void
vx_kill (void)
{
  Rptrace ptrace_in;
  Ptrace_return ptrace_out;
  int status;

  printf_unfiltered ("Killing pid %s.\n", 
		     hex_string ((unsigned long) PIDGET (inferior_ptid)));

  memset ((char *) &ptrace_in, '\0', sizeof (ptrace_in));
  memset ((char *) &ptrace_out, '\0', sizeof (ptrace_out));
  ptrace_in.pid = PIDGET (inferior_ptid);

  status = net_ptrace_clnt_call (PTRACE_KILL, &ptrace_in, &ptrace_out);
  if (status == -1)
    warning (rpcerr);
  else if (ptrace_out.status == -1)
    {
      errno = ptrace_out.errno_num;
      perror_with_name ("Killing VxWorks process");
    }

  /* If it gives good status, the process is *gone*, no events remain.
     If the kill failed, assume the process is gone anyhow.  */
  inferior_ptid = null_ptid;
  pop_target ();		/* go back to non-executing VxWorks connection */
}

/* Clean up from the VxWorks process target as it goes away.  */

static void
vx_proc_close (int quitting)
{
  inferior_ptid = null_ptid;	/* No longer have a process.  */
  if (vx_running)
    xfree (vx_running);
  vx_running = 0;
}

/* Make an RPC call to the VxWorks target.
   Returns RPC status.  */

static enum clnt_stat
net_clnt_call (enum ptracereq procNum, xdrproc_t inProc, char *in,
	       xdrproc_t outProc, char *out)
{
  enum clnt_stat status;

  status = clnt_call (pClient, procNum, inProc, in, outProc, out, rpcTimeout);

  if (status != RPC_SUCCESS)
    clnt_perrno (status);

  return status;
}

/* Clean up before losing control.  */

static void
vx_close (int quitting)
{
  if (pClient)
    clnt_destroy (pClient);	/* The net connection */
  pClient = 0;

  if (vx_host)
    xfree (vx_host);		/* The hostname */
  vx_host = 0;
}

/* A vxprocess target should be started via "run" not "target".  */
static void
vx_proc_open (char *name, int from_tty)
{
  error ("Use the \"run\" command to start a VxWorks process.");
}

static void
init_vx_ops (void)
{
  vx_ops.to_shortname = "vxworks";
  vx_ops.to_longname = "VxWorks target memory via RPC over TCP/IP";
  vx_ops.to_doc = "Use VxWorks target memory.  \n\
Specify the name of the machine to connect to.";
  vx_ops.to_open = vx_open;
  vx_ops.to_close = vx_close;
  vx_ops.to_attach = vx_attach;
  vx_ops.deprecated_xfer_memory = vx_xfer_memory;
  vx_ops.to_files_info = vx_files_info;
  vx_ops.to_load = vx_load_command;
  vx_ops.to_lookup_symbol = vx_lookup_symbol;
  vx_ops.to_create_inferior = vx_create_inferior;
  vx_ops.to_stratum = core_stratum;
  vx_ops.to_has_all_memory = 1;
  vx_ops.to_has_memory = 1;
  vx_ops.to_magic = OPS_MAGIC;	/* Always the last thing */
};

static void
init_vx_run_ops (void)
{
  vx_run_ops.to_shortname = "vxprocess";
  vx_run_ops.to_longname = "VxWorks process";
  vx_run_ops.to_doc = "VxWorks process; started by the \"run\" command.";
  vx_run_ops.to_open = vx_proc_open;
  vx_run_ops.to_close = vx_proc_close;
  vx_run_ops.to_detach = vx_detach;
  vx_run_ops.to_resume = vx_resume;
  vx_run_ops.to_wait = vx_wait;
  vx_run_ops.to_fetch_registers = vx_read_register;
  vx_run_ops.to_store_registers = vx_write_register;
  vx_run_ops.to_prepare_to_store = vx_prepare_to_store;
  vx_run_ops.deprecated_xfer_memory = vx_xfer_memory;
  vx_run_ops.to_files_info = vx_run_files_info;
  vx_run_ops.to_insert_breakpoint = vx_insert_breakpoint;
  vx_run_ops.to_remove_breakpoint = vx_remove_breakpoint;
  vx_run_ops.to_kill = vx_kill;
  vx_run_ops.to_load = vx_load_command;
  vx_run_ops.to_lookup_symbol = vx_lookup_symbol;
  vx_run_ops.to_mourn_inferior = vx_mourn_inferior;
  vx_run_ops.to_stratum = process_stratum;
  vx_run_ops.to_has_memory = 1;
  vx_run_ops.to_has_stack = 1;
  vx_run_ops.to_has_registers = 1;
  vx_run_ops.to_has_execution = 1;
  vx_run_ops.to_magic = OPS_MAGIC;
}

void
_initialize_vx (void)
{
  init_vx_ops ();
  add_target (&vx_ops);
  init_vx_run_ops ();
  add_target (&vx_run_ops);

  deprecated_add_show_from_set
    (add_set_cmd ("vxworks-timeout", class_support, var_uinteger,
		  (char *) &rpcTimeout.tv_sec,
		  "Set seconds to wait for rpc calls to return.\n\
Set the number of seconds to wait for rpc calls to return.", &setlist),
     &showlist);
}
@


1.36
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@@


1.35
log
@* language.c (local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string, use C format, and move to
utils.c
(local_hex_string_custom): Rename to hex_string_custom and change
interface.  Now uses C format.  Move to utils.c
(local_octal_format_custom): Remove.
(local_decimal_format_custom): Remove.
(unknown_language_defn): Remove language-specific number
formatting entries.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* language.h (struct language_format_info): Delete declaration.
(struct language_defn): Remove language_format_info fields
la_binary_format, la_octal_format, la_decimal_format, la_hex_format.
(local_binary_format): Remove macro.
(local_binary_format_prefix): Remove macro.
(local_binary_format_specifier): Remove macro.
(local_binary_format_suffix): Remove macro.
(local_octal_format): Remove macro.
(local_octal_format_prefix): Remove macro.
(local_octal_format_specifier): Remove macro.
(local_octal_format_suffix): Remove macro.
(local_decimal_format): Remove macro.
(local_decimal_format_prefix): Remove macro.
(local_decimal_format_specifier): Remove macro.
(local_decimal_format_suffix): Remove macro.
(local_hex_format): Remove macro.
(local_hex_format_prefix): Remove macro.
(local_hex_format_specifier): Remove macro.
(local_hex_format_suffix): Remove macro.
(local_decimal_format_custom): Remove.
(local_octal_format_custom): Remove.
(local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string and move to defs.h.
(local_hex_string_custom): Rename to hex_string_custom, change
interface, and move to defs.h.
* utils.c: (int_string): New function.
(hex_string): New function (from language.c).
(hex_string_custom): New function (from language.c).
(octal2str): New function.
(decimal2str): Add width parameter.
(paddr_u): Use new decimal2str interface.
(paddr_d): Ditto.
* defs.h (hex_string): Declare.
(hex_string_custom): Declare.
(int_string): Declare.
* printcmd.c (print_scalar_formatted): Remove localized binary
formatting.
* valprint.c (print_longest): Use int_string.
(print_floating): Use C hex format.
(print_hex_chars): Ditto.
(print_binary_chars): Remove language-specific formatting.
(print_octal_chars): Use C octal format.
(print_decimal_chars): Delocalize format.
(print_decimal): Remove.
* ada-lang.c (ada_language_defn): Remove language-specific number
formatting entries.
* p-lang.c (pascal_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.
* memattr.c (mem_info_command): Use renamed hex_string_custom with
new interface.
* pa64solib.c (pa64_sharedlibrary_info_command): Ditto.
* ui-out.c (ui_out_field_core_addr): Ditto.
* breakpoint.c (breakpoint_adjustment_warning): Ditto.
* exec.c (print_section_info): Ditto.
* i387-tdep.c (print_i387_status_word): Ditto.
(print_i387_control_word): Ditto.
(i387_print_float_info): Ditto.
* maint.c (maint_print_section_info): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* somsolib.c (som_sharedlibrary_info_command): Ditto.
* symtab.c (print_msymbol_info): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* solib-frv.c (lm_base): Ditto.
(frv_current_sos): Ditto.
(enable_break2): Ditto.
(enable_break): Ditto.
* dbxread.c (read_dbx_symtab): Use renamed hex_string.
(process_one_symbol): Ditto.
* infcmd.c (program_info): Ditto.
* mdebugread.c (parse_partial_symbols): Ditto.
* symfile.c (add_symbol_file_command): Ditto.
* cli/cli-cmds.c (edit_command): Ditto.
(list_command): Ditto.
* infcall.c (call_function_by_hand): Ditto.
* remote-vx.c (vx_run_files_info): Ditto.
(vx_wait): Ditto.
(vx_attach): Ditto.
(vx_detach): Ditto.
(vx_kill): Ditto.
* aix-thread.c (pdc_symbol_addrs): Ditto.
(pdc_read_regs): Ditto.
(pdc_write_regs): Ditto.
(pdc_read_data): Ditto.
(pdc_write_data): Ditto.
* d10v-tdep.c (display_trace): Ditto.
* rs6000-nat.c (find_toc_address): Ditto.
* aix-thread.c: Don't include language.h.
* buildsym.c: Ditto.
* dbxread.c: Ditto.
* mdebugread.c: Ditto.
* rs6000-nat.c: Ditto.
* buildsym.c (make_blockvector): Use renamed hex_string.
@
text
@d1346 1
a1346 1
  vx_ops.to_xfer_memory = vx_xfer_memory;
d1371 1
a1371 1
  vx_run_ops.to_xfer_memory = vx_xfer_memory;
@


1.34
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_register_bytes): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* regcache.c (deprecated_register_bytes): New function.
	* regcache.h (deprecated_register_bytes): Declare.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* remote.c (init_remote_state): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers, sds_prepare_to_store): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
@
text
@d569 1
a569 1
		     local_hex_string (PIDGET (inferior_ptid)));
d975 1
a975 1
			local_hex_string ((unsigned long) pid));
d1186 1
a1186 1
		       local_hex_string ((unsigned long) pid));
d1233 1
a1233 1
		       local_hex_string (
d1265 2
a1266 1
  printf_unfiltered ("Killing pid %s.\n", local_hex_string ((unsigned long) PIDGET (inferior_ptid)));
@


1.33
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d469 1
a469 1
  deprecated_read_register_bytes (0, NULL, DEPRECATED_REGISTER_BYTES);
@


1.32
log
@2004-05-25  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Add from_tty to
	to_create_inferior.
	(target_create_inferior, find_default_create_inferior): Update.
	* infcmd.c (run_command): Update.
	* wince.c (child_create_inferior): Update.
	* win32-nat.c (child_create_inferior): Update.
	* uw-thread.c (uw_thread_create_inferior): Update.
	* thread-db.c (thread_db_create_inferior): Update.
	* target.c (debug_to_create_inferior)
	(find_default_create_inferior): Update.
	(maybe_kill_then_create_inferior): Update.
	* sol-thread.c (sol_thread_create_inferior): Update.
	* remote.c (extended_remote_async_create_inferior)
	(extended_remote_create_inferior): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* remote-st.c (st2000_create_inferior): Update.
	* remote-sim.c (gdbsim_create_inferior): Update.
	* remote-sds.c (sds_create_inferior): Update.
	* remote-rdp.c (remote_rdp_create_inferior): Update.
	* remote-rdi.c (arm_rdi_create_inferior): Update.
	* remote-m32r-sdi.c (m32r_create_inferior): Update.
	* remote-e7000.c (e7000_create_inferior): Update.
	* procfs.c (procfs_create_inferior): Update.
	* ocd.c (ocd_create_inferior): Update.
	* ocd.h (ocd_create_inferior): Update.
	* nto-procfs.c (procfs_create_inferior): Update.
	* monitor.c (monitor_create_inferior): Update.
	* lin-lwp.c (lin_lwp_create_inferior): Update.
	* inftarg.c (child_create_inferior): Update.
	* hpux-thread.c (hpux_thread_create_inferior): Update.
	* gnu-nat.c (gnu_create_inferior): Update.
@
text
@d1394 1
a1394 1
  add_show_from_set
@


1.31
log
@2004-05-09  Andrew Cagney  <cagney@@redhat.com>

	* remote-vx.c (net_step): Delete step-range code.
	* remote.c (remote_resume, init_all_packet_configs)
	(set_remote_protocol_E_packet_cmd)
	(show_remote_protocol_E_packet_cmd)
	(remote_protocol_E, show_remote_cmd, _initialize_remote)
	(remote_protocol_e, set_remote_protocol_e_packet_cmd)
	(show_remote_protocol_e_packet_cmd): Ditto.
@
text
@d205 1
a205 1
vx_create_inferior (char *exec_file, char *args, char **env)
@


1.30
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d750 2
a751 11

  if (step_range_end)
    {
      source_step.startAddr = step_range_start;
      source_step.endAddr = step_range_end;
    }
  else
    {
      source_step.startAddr = 0;
      source_step.endAddr = 0;
    }
@


1.30.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d205 1
a205 1
vx_create_inferior (char *exec_file, char *args, char **env, int from_tty)
d469 1
a469 1
  deprecated_read_register_bytes (0, NULL, deprecated_register_bytes ());
d569 1
a569 1
		     hex_string (PIDGET (inferior_ptid)));
d750 11
a760 2
  source_step.startAddr = 0;
  source_step.endAddr = 0;
d984 1
a984 1
			hex_string ((unsigned long) pid));
d1195 1
a1195 1
		       hex_string ((unsigned long) pid));
d1242 1
a1242 1
		       hex_string (
d1274 1
a1274 2
  printf_unfiltered ("Killing pid %s.\n", 
		     hex_string ((unsigned long) PIDGET (inferior_ptid)));
d1403 1
a1403 1
  deprecated_add_show_from_set
@


1.29
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@a1337 1
/*ARGSUSED */
@


1.28
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d258 1
a258 1
parse_args (register char *arg_string, arg_array *arg_struct)
d298 1
a298 1
skip_white_space (register char *p)
d310 1
a310 1
find_white_space (register char *p)
d1142 1
a1142 1
	register int desc;
@


1.27
log
@       * remote-vx.c (vx_add_symbols): Fix compilation error.
@
text
@d260 3
a262 3
  register int arg_count = 0;	/* number of arguments */
  register int arg_index = 0;
  register char *p0;
d312 1
a312 1
  register int c;
d937 1
a937 1
  register int pid;
@


1.26
log
@2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTES): Rename REGISTER_BYTES.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_extract_return_value): Delete reference.
	* TODO (REGISTER_BYTES): Delete reference.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	(ns32k_gdbarch_init_32382): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* sparc-tdep.c (sparc_pop_frame): Update.
	* rs6000-tdep.c (rs6000_pop_frame): Update.
	* remote.c (init_remote_state): Update.
	(remote_prepare_to_store): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	(sds_prepare_to_store): Update.
	* remote-array.c: Update.
	* regcache.c (init_legacy_regcache_descr): Update.
	(init_regcache_descr): Update.
	* mips-tdep.c (mips_eabi_extract_return_value): Update.
	(mips_o64_extract_return_value): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* irix4-nat.c (fetch_core_registers): Update.
	* i386-tdep.h: Update.
	* hppa-tdep.c (pa_do_registers_info): Update.
	(pa_do_strcat_registers_info): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/sparc/nm-sun4sol2.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-sun4os4.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-nbsd.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/s390/tm-s390.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-mips.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/m68k/tm-sun3.h (DEPRECATED_REGISTER_BYTES): Update.
	(REGISTER_BYTES_OK): Update.
	* config/m68k/nm-sun3.h (CHILD_PREPARE_TO_STORE): Update.
	* config/ia64/tm-ia64.h (DEPRECATED_REGISTER_BYTES): Update.

Index: doc/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	REGISTER_BYTES with DEPRECATED_REGISTER_BYTES.  Fix typo,
	DEPRECATED_REGISTER_SIZE instead of REGISTER_BYTE.

Index: mi/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_setup_architecture_data):
@
text
@d678 5
a682 2
  offs = (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
  memcpy (offs, objfile->section_offsets, SIZEOF_SECTION_OFFSETS);
@


1.26.10.1
log
@       * remote-vx.c (vx_add_symbols): Fix compilation error.
@
text
@d678 2
a679 5
  offs =
    (struct section_offsets *)
    alloca (SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
  memcpy (offs, objfile->section_offsets,
          SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
@


1.25
log
@2003-04-08  Elena Zannoni  <ezannoni@@redhat.com>

        * infrun.c (stop_soon): Rename from stop_soon_quietly.
	(struct inferior_status): Rename stop_soon_quietly field to stop_soon.
	(clear_proceed_status): Rename stop_soon_quietly to stop_soon.
	(start_remote): Ditto.
	(handle_inferior_event): Ditto.
	(save_inferior_status): Ditto.
	(restore_inferior_status): Ditto.
	* infcmd.c (attach_command): Ditto.
	* fork-child.c (startup_inferior): Ditto.
        * inferior.h (stop_soon): Rename from stop_soon_quietly.
	* alpha-tdep.c (heuristic_proc_start): Ditto.
	* mips-tdep.c (heuristic_proc_start): Ditto.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Ditto.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Ditto.
	* solib-osf.c (osf_solib_create_inferior_hook): Ditto.
	* solib-irix.c (irix_solib_create_inferior_hook): Ditto.
	* remote-vx.c (vx_create_inferior): Ditto.
@
text
@d469 1
a469 1
  deprecated_read_register_bytes (0, NULL, REGISTER_BYTES);
@


1.25.2.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d469 1
a469 1
  deprecated_read_register_bytes (0, NULL, DEPRECATED_REGISTER_BYTES);
@


1.24
log
@2003-04-08  Elena Zannoni  <ezannoni@@redhat.com>

	* infrun.c (stop_soon_quietly): Make it an enum, to better
	override the default behavior of handle_inferior_event.
	(clear_proceed_status): Update uses of stop_soon_quietly to
	reflect that it is now an enum.
	(start_remote): Ditto.
	(handle_inferior_event): Change logic a bit if stop_soon_quietly
	is set to handle the new GNU/Linux kernel behavior for
	attach/sigstop.  Update uses of stop_soon_quietly.
	* inferior.h (enum stop_kind): New enum.
	* infcmd.c (attach_command): Use STOP_QUIETLY_NO_SIGSTOP.
	Reset normal handle_inferior_event behavior, afterwards.
	* fork-child.c (startup_inferior): Update.
	* alpha-tdep.c (heuristic_proc_start): Update.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Update.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Update.
	* solib-osf.c (osf_solib_create_inferior_hook): Update.
	* solib-irix.c (irix_solib_create_inferior_hook): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* mips-tdep.c (heuristic_proc_start): Update.
@
text
@d70 1
a70 1
extern enum stop_kind stop_soon_quietly;	/* for wait_for_inferior */
d246 1
a246 1
  stop_soon_quietly = STOP_QUIETLY;
d248 1
a248 1
  stop_soon_quietly = NO_STOP_QUIETLY;
@


1.23
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d70 1
a70 1
extern int stop_soon_quietly;	/* for wait_for_inferior */
d246 1
a246 1
  stop_soon_quietly = 1;
d248 1
a248 1
  stop_soon_quietly = 0;
@


1.23.14.1
log
@Merge with mainline.
@
text
@d70 1
a70 1
extern enum stop_kind stop_soon;	/* for wait_for_inferior */
d246 1
a246 1
  stop_soon = STOP_QUIETLY;
d248 1
a248 1
  stop_soon = NO_STOP_QUIETLY;
@


1.22
log
@Replace complain() with complaint().
@
text
@d641 1
a641 1
find_sect (bfd *abfd, asection *sect, PTR obj)
@


1.21
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@a822 3
struct deprecated_complaint cant_contact_target =
{"Lost contact with VxWorks target", 0, 0};

d837 1
a837 1
      complain (&cant_contact_target);
@


1.20
log
@2002-10-25  Andrew Cagney  <cagney@@redhat.com>

	* complaints.h (struct deprecated_complaint): Rename `struct
	complaint'.
	* complaints.c (complain): Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Delete
	incorrect comment indicating that "symfile.h" was being included
	for the `struct complaint' definition.
	* remote-vx.c: Update.
	* objc-lang.c: Update.
	* xcoffread.c: Update.
	* hpread.c: Update.
	* mdebugread.c: Update.
	* stabsread.c: Update.
	* dwarf2read.c: Update.
	* dwarfread.c: Update.
	* elfread.c: Update.
	* coffread.c: Update.
	* stabsread.h: Update.
	* dbxread.c: Update.
	* buildsym.c: Update.
	* gdbtypes.c: Update.
	* macrotab.c: Update.
@
text
@d469 1
a469 1
  read_register_bytes (0, NULL, REGISTER_BYTES);
@


1.19
log
@Remove ATTRIBUTE_UNUSED.  Update (C).
@
text
@d823 1
a823 1
struct complaint cant_contact_target =
@


1.19.18.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d70 1
a70 1
extern enum stop_kind stop_soon;	/* for wait_for_inferior */
d246 1
a246 1
  stop_soon = STOP_QUIETLY;
d248 1
a248 1
  stop_soon = NO_STOP_QUIETLY;
d258 1
a258 1
parse_args (char *arg_string, arg_array *arg_struct)
d260 3
a262 3
  int arg_count = 0;	/* number of arguments */
  int arg_index = 0;
  char *p0;
d298 1
a298 1
skip_white_space (char *p)
d310 1
a310 1
find_white_space (char *p)
d312 1
a312 1
  int c;
d469 1
a469 1
  deprecated_read_register_bytes (0, NULL, DEPRECATED_REGISTER_BYTES);
d641 1
a641 1
find_sect (bfd *abfd, asection *sect, void *obj)
d678 2
a679 5
  offs =
    (struct section_offsets *)
    alloca (SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
  memcpy (offs, objfile->section_offsets,
          SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
d823 3
d840 1
a840 1
      complaint (&symfile_complaints, "Lost contact with VxWorks target");
d937 1
a937 1
  int pid;
d1142 1
a1142 1
	int desc;
d1338 1
@


1.19.16.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d469 1
a469 1
  deprecated_read_register_bytes (0, NULL, REGISTER_BYTES);
d823 1
a823 1
struct deprecated_complaint cant_contact_target =
@


1.19.16.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d823 3
d840 1
a840 1
      complaint (&symfile_complaints, "Lost contact with VxWorks target");
@


1.19.16.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d641 1
a641 1
find_sect (bfd *abfd, asection *sect, void *obj)
@


1.19.16.4
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d70 1
a70 1
extern enum stop_kind stop_soon;	/* for wait_for_inferior */
d246 1
a246 1
  stop_soon = STOP_QUIETLY;
d248 1
a248 1
  stop_soon = NO_STOP_QUIETLY;
@


1.19.16.5
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d469 1
a469 1
  deprecated_read_register_bytes (0, NULL, DEPRECATED_REGISTER_BYTES);
@


1.19.16.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d678 2
a679 5
  offs =
    (struct section_offsets *)
    alloca (SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
  memcpy (offs, objfile->section_offsets,
          SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
@


1.19.16.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d258 1
a258 1
parse_args (char *arg_string, arg_array *arg_struct)
d260 3
a262 3
  int arg_count = 0;	/* number of arguments */
  int arg_index = 0;
  char *p0;
d298 1
a298 1
skip_white_space (char *p)
d310 1
a310 1
find_white_space (char *p)
d312 1
a312 1
  int c;
d937 1
a937 1
  int pid;
d1142 1
a1142 1
	int desc;
@


1.19.16.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1338 1
@


1.19.8.1
log
@merge from mainline
@
text
@d823 1
a823 1
struct deprecated_complaint cant_contact_target =
@


1.18
log
@* remote-vx.c (net_wait): Fix typo from PIDGET change.
@
text
@d2 4
a5 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000,
   2001 Free Software Foundation, Inc.
d482 1
a482 2
		struct mem_attrib *attrib ATTRIBUTE_UNUSED,
		struct target_ops *target ATTRIBUTE_UNUSED)
@


1.17
log
@Phase 1 of the ptid_t changes.
@
text
@d341 1
a341 1
  pid = PIDGET inferior_ptid);
@


1.17.4.1
log
@* remote-vx.c (net_wait): Fix typo from PIDGET change.
@
text
@d341 1
a341 1
  pid = PIDGET (inferior_ptid);
@


1.16
log
@Update/correct copyright notices.
@
text
@d166 1
a166 1
  ptrace_in.pid = inferior_pid;
d195 1
a195 1
/* Start an inferior process and sets inferior_pid to its pid.
d230 1
a230 1
  inferior_pid = taskStart.pid;
d341 1
a341 1
  pid = inferior_pid;
d368 1
a368 1
  if ((pid = inferior_pid) == 0)
d393 1
a393 1
  ptrace_in.pid = inferior_pid;
d441 1
a441 1
  ptrace_in.pid = inferior_pid;
d493 1
a493 1
  ptrace_in.pid = inferior_pid;	/* XXX pid unnecessary for READDATA */
d568 1
a568 1
		     local_hex_string (inferior_pid));
d575 1
a575 1
vx_resume (int pid, int step, enum target_signal siggnal)
d582 2
a583 2
  if (pid == -1)
    pid = inferior_pid;
d603 1
a603 1
  ptrace_in.pid = pid;
d712 1
a712 1
  if (inferior_pid != 0 && target_has_execution)
d745 1
a745 1
  source_step.taskId = inferior_pid;
d933 2
a934 2
static int
vx_wait (int pid_to_wait_for, struct target_waitstatus *status)
d980 1
a980 1
      else if (pid != inferior_pid)
d1038 1
a1038 1
  return pid;
d1211 1
a1211 1
  inferior_pid = pid;
d1241 2
a1242 1
		       local_hex_string ((unsigned long) inferior_pid));
d1249 1
a1249 1
  ptrace_in.pid = inferior_pid;
d1260 1
a1260 1
  inferior_pid = 0;
d1273 1
a1273 1
  printf_unfiltered ("Killing pid %s.\n", local_hex_string ((unsigned long) inferior_pid));
d1277 1
a1277 1
  ptrace_in.pid = inferior_pid;
d1290 1
a1290 1
  inferior_pid = 0;
d1299 1
a1299 1
  inferior_pid = 0;		/* No longer have a process.  */
@


1.15
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright (C) 1990-95, 1997-98, 1999, 2001 Free Software Foundation, Inc.
@


1.14
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d35 1
@


1.13
log
@* monitor.c (#include "gdb_wait.h"): Removed.
* ocd.c: Likewise.
* ppc-bdm.c: Likewise.
* remote-adapt.c: Likewise.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-eb.c: Likewise.
* remote-es.c: Likewise.
* remote-mips.c: Likewise.
* remote-mm.c: Likewise.
* remote-nindy.c: Likewise.
* remote-os9k.c: Likewise.
* remote-rdi.c: Likewise.
* remote-rdp.c: Likewise.
* remote-sds.c: Likewise.
* remote-sim.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
* remote.c: Likewise.
* ser-pipe.c: Likewise.
* ser-unix.c: Likewise.
* Makefile.in: Updated dependencies.
-------------------------------------------------------------------
@
text
@d979 2
a980 1
	internal_error ("Bad pid for debugged task: %s\n",
@


1.12
log
@2001-01-26  Fernando Nasser  <fnasser@@redhat.com>

        Fix double parsing of filenames passed as command line arguments
        to GDB (causes weird handling of escape characters).
        Also, remove dependencies on the CLI from libgdb.
        * call-cmds.h: Remove declaration of exec_file_command().
        * gdbcore.h: Remove declaration of exec_file_command().
        Add declarations for exec_open() and exec_file_clear().
        * symfile.h: Add declarations for symbol_file_add_main() and
        symbol_file_clear().
        * exec.c (exec_open): New function. Implements to_open for exec
        targets.
        (exec_file_clear): New function. Makes GDB forget about a previously
        specified executable file.
        (exec_file_attach): Move parsing of arguments from here ...
        (exec_file_command): ... to here.
        (init_exec_ops): Use exec_open(), not exec_file_command() to
        implement to_open for exec targets.
        * symfile.c (symbol_file_add_main): New function. Call symbol_file_add()        with default values.  Used when the file name has already been parsed.
        (symbol_file_clear): New function. Makes GDB forget about previously
        read symbols.
        (symbol_file_command): Call the above function instead of inline code.
        * main.c: Include "symfile.h" and "gdbcore.h" instead of the deprecated
        "call-cmds.h".
        (captured_main): Call exec_file_attach() and symbol_file_add_main()
        instead of exec_file_command() and symbol_file_command().
        (captured_main): Add comment.
        * corefile.c: Include "symfile.h".
        (core_file_command): Call symbol_file_add_main() instead of
        symbol_file_command().
        (reopen_exec_file): Call exec_open() instead of exec_file_command().
        * infcmd.c: Include "symfile.h".
        (attach_command): Call symbol_file_add_main() instead of
        symbol_file_command().
        * infrun.c: Remove comment about the inclusion of "symfile.h",
        not any longer appropriate.
        (follow_exec): Call symbol_file_add_main() instead of
        symbol_file_command().
        * remote-es.c: Include "symfile.h".
        (es1800_load): Call symbol_file_add_main() instead of
        symbol_file_command().
        * remote-vx.c: Remove comment about the inclusion of "symfile.h",
        not any longer appropriate.
        (vx-wait): Call symbol_file_add_main() instead of
        symbol_file_command().
        * solib-svr4.c (open_symbol_file_object): Call symbol_file_add_main()
        instead of symbol_file_command().
        * v850ice.c (ice_file): Call exec_open(), exec_file_attach() and
        symbol_file_add_main() instead of exec_file_command() and
        symbol_file_command().
        * Makefile.in: Update dependencies.
@
text
@a24 1
#include "gdb_wait.h"
@


1.11
log
@* exec.c (xfer_memory): Add attrib argument.
* infptrace.c (child_xfer_memory): Likewise.
* monitor.c (monitor_xfer_memory): Likewise.
* remote-adapt.c (adapt_xfer_inferior_memory): Likewise.
* remote-array.c (array_xfer_memory): Likewise.
* remote-bug.c (bug_xfer_memory): Likewise.
* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
* remote-eb.c (eb_xfer_inferior_memory): Likewise.
* remote-es.c (es1800_xfer_inferior_memory): Likewise.
* remote-mips.c (mips_xfer_memory): Likewise.
* remote-mm.c (mm_xfer_inferior_memory): Likewise.
* remote-nindy.c (nindy_xfer_inferior_memory): Likewise.
* remote-os9k.c (rombug_xfer_inferior_memory): Likewise.
* remote-rdi.c (arm_rdi_xfer_memory): Likewise.
* remote-rdp.c (remote_rdp_xfer_inferior_memory): Likewise.
* remote-sds.c (sds_xfer_memory): Likewise.
* remote-sim.c (gdbsim_xfer_inferior_memory): Likewise.
* remote-st.c (st2000_xfer_inferior_memory): Likewise.
* remote-udi.c (udi_xfer_inferior_memory): Likewise.
* remote-vx.c (vx_xfer_memory): Likewise.
* remote.c (remote_xfer_memory): Likewise.
* target.c (debug_to_xfer_memory, do_xfer_memory): Likewise.
* target.h (child_xfer_memory, do_xfer_memory, xfer_memory): Likewise.

* target.h (#include "memattr.h"): Added.
(target_ops.to_xfer_memory): Add attrib argument.

* wince.c (_initialize_inftarg): Removed call to set_dcache_state.
* dcache.h (set_dcache_state): Removed declaration.
* dcache.c (set_dcache_state): Removed definition

* dcache.c: Update module comment, as dcache is now enabled and
disabled with memory region attributes instead of by the global
variable "remotecache".  Add comment describing the interaction
between dcache and memory region attributes.
(dcache_xfer_memory): Add comment describing benefits of moving
cache writeback to a higher level.
(dcache_struct): Removed cache_has_stuff field.  This was used to
record whether the cache had been accessed in order to invalidate
it when it was disabled.  However, this is not needed because the
cache is write through and the code that enables, disables, and
deletes memory regions invalidate the cache.  Add comment which
suggests that we could be more selective and only invalidate those
cache lines containing data from those memory regions.
(dcache_invalidate): Updated.
(dcache_xfer_memory): Updated.

(dcache_alloc): Don't abort() if dcache_enabled_p is clear.
(dcache_xfer_memory): Removed code that called do_xfer_memory() to
perform a uncached transfer if dcache_enabled_p was clear.  This
function is now only called if caching is enabled for the memory
region.
(dcache_info): Always print cache info.

* target.c (do_xfer_memory): Add attrib argument.
(target_xfer_memory, target_xfer_memory_partial): Break transfer
into chunks defined by memory regions, pass region attributes to
do_xfer_memory().
* dcache.c (dcache_read_line, dcache_write_line): Likewise.

* Makefile.in (SFILES): Add memattr.c.
(COMMON_OBS): Add memattr.o.
(dcache.o): Add target.h to dependencies.
* memattr.c: New file.
* memattr.h: Likewise.
@
text
@d33 1
a33 1
#include "symfile.h"		/* Required by objfiles.h.  */
d1042 1
a1042 1
  symbol_file_command (arg, 0);
@


1.10
log
@Replace free() with xfree().
@
text
@d2 1
a2 1
   Copyright (C) 1990-95, 1997-98, 1999 Free Software Foundation, Inc.
d479 2
a480 1
		struct target_ops *target)
@


1.9
log
@* gdbarch.sh, hp-psymtab-read.c, hpread.c, m3-nat.c, mcore-tdep.c,
mips-tdep.c, monitor.c, regcache.c, remote-es.c, ser-unix.c,
somread.c, tracepoint.c: Fix spelling errors in comments.
* gdbarch.c: Regenerate.

* gnu-nat.c (S_exception_raise_request): Fix typos and spelling
errors in strings.
* m3-nat.c (intercept_exec_calls, mach_thread_parse_id): Likewise.
* mcore-tdep.c (mcore_analyze_prologue): Likewise.
* mips-tdep.c (mips16_next_pc, _initialize_mips_tdep): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-rdp.c (handle_swi): Likewise.
* remote-vx.c (vx_load_command): Likewise.
* sh-tdep.c (sh_do_pseudo_register): Likewise.
* sol-thread.c (td_err_string): Likewise.
* symtab.c (decode_line_2): Likewise.
-------------------------------------------------------------------
@
text
@d703 1
a703 1
  make_cleanup (free, arg_string);
d1212 1
a1212 1
    free (vx_running);
d1297 1
a1297 1
    free (vx_running);
d1328 1
a1328 1
    free (vx_host);		/* The hostname */
@


1.8
log
@Protoization.
@
text
@d716 1
a716 1
	error ("Load cancelled.");
@


1.7
log
@2000-08-27  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* pa64solib.c (pa64_solib_load_symbols): Don't use ANOFFSET as an
 	lvalue.
	* xcoffread.c (xcoff_symfile_offsets): Ditto
	* somsolib.c (som_solib_section_offsets): Ditto.
	* somread.c (som_symfile_offsets): Ditto.
	* rs6000-nat.c (vmap_symtab): Ditto.
	* remote-vx.c (vx_add_symbols): Ditto.
	* remote-os9k.c (rombug_wait): Ditto.
@
text
@d471 1
a471 1
   inferior.
d478 2
a479 6
vx_xfer_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *target;	/* ignored */
d799 2
a800 1
/* Fetch a list of loaded object modules from the VxWorks target.
d806 1
a806 2
net_get_symbols (pLoadTable)
     ldtabl *pLoadTable;	/* return pointer to ldtabl here */
@


1.6
log
@2000-08-02  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* remote-vx.c (vx_add_symbols): Fix typos.
@
text
@d688 3
a690 3
  ANOFFSET (offs, SECT_OFF_TEXT (objfile)) = text_addr - ss.text_start;
  ANOFFSET (offs, SECT_OFF_DATA (objfile)) = data_addr - ss.data_start;
  ANOFFSET (offs, SECT_OFF_BSS (objfile)) = bss_addr - ss.bss_start;
@


1.5
log
@Protoization.
@
text
@d688 3
a690 3
  ANOFFSET (offs, SECT_OFF_TEXT (so->objfile)) = text_addr - ss.text_start;
  ANOFFSET (offs, SECT_OFF_DATA (so->objfile)) = data_addr - ss.data_start;
  ANOFFSET (offs, SECT_OFF_BSS (so->objfile)) = bss_addr - ss.bss_start;
@


1.4
log
@PARAMS removal.
@
text
@d114 2
a115 5
net_load (filename, pTextAddr, pDataAddr, pBssAddr)
     char *filename;
     CORE_ADDR *pTextAddr;
     CORE_ADDR *pDataAddr;
     CORE_ADDR *pBssAddr;
d154 1
a154 3
net_break (addr, procnum)
     int addr;
     u_long procnum;
d181 1
a181 2
vx_insert_breakpoint (addr)
     int addr;
d189 1
a189 2
vx_remove_breakpoint (addr)
     int addr;
d202 1
a202 4
vx_create_inferior (exec_file, args, env)
     char *exec_file;
     char *args;
     char **env;
d255 1
a255 3
parse_args (arg_string, arg_struct)
     register char *arg_string;
     arg_array *arg_struct;
d295 1
a295 2
skip_white_space (p)
     register char *p;
d307 1
a307 2
find_white_space (p)
     register char *p;
d333 1
a333 2
net_wait (pEvent)
     RDB_EVENT *pEvent;
d357 1
a357 1
net_quit ()
d379 1
a379 4
net_read_registers (reg_buf, len, procnum)
     char *reg_buf;
     int len;
     u_long procnum;
d424 1
a424 4
net_write_registers (reg_buf, len, procnum)
     char *reg_buf;
     int len;
     u_long procnum;
d463 1
a463 1
vx_prepare_to_store ()
d558 1
a558 1
vx_files_info ()
d566 1
a566 1
vx_run_files_info ()
d577 1
a577 4
vx_resume (pid, step, siggnal)
     int pid;
     int step;
     enum target_signal siggnal;
d623 1
a623 1
vx_mourn_inferior ()
d642 1
a642 4
find_sect (abfd, sect, obj)
     bfd *abfd;
     asection *sect;
     PTR obj;
d663 2
a664 6
vx_add_symbols (name, from_tty, text_addr, data_addr, bss_addr)
     char *name;
     int from_tty;
     CORE_ADDR text_addr;
     CORE_ADDR data_addr;
     CORE_ADDR bss_addr;
d697 1
a697 3
vx_load_command (arg_string, from_tty)
     char *arg_string;
     int from_tty;
d741 1
a741 1
net_step ()
d773 2
a774 4
net_ptrace_clnt_call (request, pPtraceIn, pPtraceOut)
     enum ptracereq request;
     Rptrace *pPtraceIn;
     Ptrace_return *pPtraceOut;
d794 1
a794 2
net_get_boot_file (pBootFile)
     char **pBootFile;
d828 2
a829 3
vx_lookup_symbol (name, pAddr)
     char *name;		/* symbol name */
     CORE_ADDR *pAddr;
d854 1
a854 1
net_check_for_fp ()
d870 1
a870 2
net_connect (host)
     char *host;
d920 1
a920 2
sleep_ms (ms)
     long ms;
d936 1
a936 3
vx_wait (pid_to_wait_for, status)
     int pid_to_wait_for;
     struct target_waitstatus *status;
d1043 1
a1043 2
symbol_stub (arg)
     char *arg;
d1050 1
a1050 2
add_symbol_stub (arg)
     char *arg;
d1067 1
a1067 3
vx_open (args, from_tty)
     char *args;
     int from_tty;
d1178 1
a1178 3
vx_attach (args, from_tty)
     char *args;
     int from_tty;
d1230 1
a1230 3
vx_detach (args, from_tty)
     char *args;
     int from_tty;
d1267 1
a1267 1
vx_kill ()
d1297 1
a1297 2
vx_proc_close (quitting)
     int quitting;
d1309 2
a1310 6
net_clnt_call (procNum, inProc, in, outProc, out)
     enum ptracereq procNum;
     xdrproc_t inProc;
     char *in;
     xdrproc_t outProc;
     char *out;
d1325 1
a1325 2
vx_close (quitting)
     int quitting;
d1339 1
a1339 3
vx_proc_open (name, from_tty)
     char *name;
     int from_tty;
d1345 1
a1345 1
init_vx_ops ()
d1366 1
a1366 1
init_vx_run_ops ()
d1396 1
a1396 1
_initialize_vx ()
@


1.3
log
@Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * objfiles.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Define as functions of OBJFILE.  Add
        sect_index_text, sect_index_data, sect_index_rodata,
        sect_index_bss to objfile structure.
        * gdb-stabs.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Remove.
        * objfiles.c (allocate_objfile): Initialize
        sect_index_{text,data,bss,rodata} to -1, for error detection.

        * symfile.c (default_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata} from bfd information.
        * xcoffread.c (xcoff_symfile_offsets): Ditto.
        * somread.c (som_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata}.

        * coffread.c, dbxread.c, elfread.c, hp-psymtab-read.c,
        hp-symtab-read.c, hpread.c, mdebugread.c, minsyms.c,
        mipsread.c, objfiles.c, os9kread.c, pa64solib.c, partial-stab.h,
        remote-os9k.c, remote-vx.c, remote.c, rs6000-nat.c, somsolib.c,
        stabsread.c, symfile.c, xcoffread.c:
        Update use of SECT_OFF_{TEXT,DATA,BSS,RODATA} to depend on the
        current objfile.

        * xcoffread.c: Add new field objfile to find_targ_sec_arg.
@
text
@d654 1
a654 2
static void vx_add_symbols PARAMS ((char *, int, CORE_ADDR, CORE_ADDR,
				    CORE_ADDR));
d663 1
a663 1
static void find_sect PARAMS ((bfd *, asection *, void *));
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d720 3
a722 3
  ANOFFSET (offs, SECT_OFF_TEXT) = text_addr - ss.text_start;
  ANOFFSET (offs, SECT_OFF_DATA) = data_addr - ss.data_start;
  ANOFFSET (offs, SECT_OFF_BSS) = bss_addr - ss.bss_start;
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d25 1
a25 1
#include "wait.h"
d32 2
a33 2
#include "bfd.h" /* Required by objfiles.h.  */
#include "symfile.h" /* Required by objfiles.h.  */
d67 1
a67 1
extern int stop_soon_quietly;		/* for wait_for_inferior */
d71 1
a71 1
static enum clnt_stat net_clnt_call ();	/* Forward decl */
d85 1
a85 1
static char *vx_running;		/* Called function */
d96 1
a96 1
CLIENT *pClient;         /* client used in net debugging */
d99 1
a99 1
enum clnt_stat net_clnt_call();
d102 2
a103 1
static struct timeval rpcTimeout = { 10, 0 };
d107 1
a107 1
 
d135 1
a135 1
  load_timeout.tv_sec = 99999999;   /* A large number, effectively inf. */
d137 1
a137 1
 
d163 2
a164 2
  Rptrace ptrace_in;  /* XXX This is stupid.  It doesn't need to be a ptrace
			 structure.  How about something smaller? */
d176 1
a176 1
      return errno;
d180 1
a180 1
  return break_status;	/* probably (FIXME) zero */
d207 1
a207 1
 
d272 1
a272 1
 
d274 1
a274 1
 
d314 1
a314 1
    
d341 1
a341 1
    
d348 1
a348 1
    RDB_EVENT *pEvent;
d350 2
a351 2
    int pid;
    enum clnt_stat status;
d353 1
a353 1
    memset ((char *) pEvent, '\0', sizeof (RDB_EVENT));
d355 3
a357 3
    pid = inferior_pid;
    status = net_clnt_call (PROCESS_WAIT, xdr_int, &pid, xdr_RDB_EVENT,
			    pEvent);
d359 7
a365 7
    /* return (status == RPC_SUCCESS)? pEvent->status: -1; */
    if (status == RPC_SUCCESS)
      return ((pEvent->status) ? 1 : 0);
    else if (status == RPC_TIMEDOUT)
      return (1);
    else
      return (-1);
d367 1
a367 1
    
d388 1
a388 1
  return (status == RPC_SUCCESS)? quit_status: -1;
d417 1
a417 1
  ptrace_out.info.more_data = (caddr_t) &out_data;
d428 2
a429 2
						 ? "general-purpose"
						 : "floating-point");
d463 1
a463 1
  ptrace_in.info.more_data = (caddr_t) &in_data;
d474 2
a475 2
						 ? "general-purpose"
						 : "floating-point");
d504 1
a504 1
     struct target_ops *target;			/* ignored */
d516 1
a516 1
  ptrace_in.pid = inferior_pid;		/* XXX pid unnecessary for READDATA */
d518 1
a518 1
  ptrace_in.data = len;			/* How many bytes */
d522 2
a523 2
      ptrace_in.info.ttype     = DATA;
      ptrace_in.info.more_data = (caddr_t) &data;
d526 1
a526 1
      data.len   = len;			/* How many bytes (again, for XDR) */
d531 1
a531 1
      ptrace_out.info.more_data = (caddr_t) &data;
d554 1
a554 1
        error (rpcerr);
d558 5
a562 5
        {
          memaddr += nxfer;
          myaddr += nxfer;
          nleft -= nxfer;
        }
d564 4
a567 4
        {
          /* A target-side error has ocurred.  Set errno to the error
             code chosen by the target so that a later perror () will
             say something meaningful.  */
d569 2
a570 2
          errno = ptrace_out.errno_num;
        }
d582 1
a582 1
  printf_unfiltered (", which has %sfloating point", target_has_fp? "": "no ");
d589 1
a589 1
  printf_unfiltered ("\tRunning %s VxWorks process %s", 
d594 1
a594 1
  printf_unfiltered(".\n");
d630 1
a630 1
  ptrace_in.addr = cont_addr; /* Target side insists on this, or it panics.  */
d633 1
a633 1
    status = net_step();
d652 1
a653 1

d657 6
a662 5
struct find_sect_args {
  CORE_ADDR text_start;
  CORE_ADDR data_start;
  CORE_ADDR bss_start;
};
d672 1
a672 1
  struct find_sect_args *args = (struct find_sect_args *)obj;
d704 1
a704 1
  objfile = symbol_file_add (name, from_tty, 0, 0, 0, 0, 0, 0);
d711 2
a712 6
  offs = (struct section_offsets *)
    alloca (sizeof (struct section_offsets)
	    + objfile->num_sections * sizeof (offs->offsets));
  memcpy (offs, objfile->section_offsets,
	  sizeof (struct section_offsets)
	  + objfile->num_sections * sizeof (offs->offsets));
d752 1
a752 1
        target_kill ();
d754 1
a754 1
        error ("Load cancelled.");
d799 1
a799 1
  else 
d808 3
a810 3
    enum ptracereq request;
    Rptrace *pPtraceIn;
    Ptrace_return *pPtraceOut;
d818 1
a818 1
      return -1;
d847 1
a847 1
     ldtabl *pLoadTable;		/* return pointer to ldtabl here */
d862 1
a862 1
  {"Lost contact with VxWorks target", 0, 0};
d895 1
a895 1
  bool_t fp = 0;	/* true if fp processor is present on target board */
d901 1
a901 1
   return (int) fp;
d927 1
a927 1
      addr = * (unsigned long *) destHost->h_addr;
d933 3
a935 3
  destAddr.sin_family      = AF_INET;
  destAddr.sin_port        = 0;	/* set to actual port that remote
			           ptrace is listening on.  */
d987 1
a987 1
	 suspend the inferior process.  */
d997 4
a1000 4
	 allow the user to break the connection with the target.
	 We can't simply error () out of this loop, since the 
	 data structures representing the state of the inferior
	 are in an inconsistent state.  */
d1007 1
a1007 1
		                   : "get status of remote task"))
d1009 1
a1009 1
	      target_mourn_inferior();
d1018 1
a1018 1
      
d1025 4
a1028 3
	fatal ("Bad pid for debugged task: %s\n",
	       local_hex_string((unsigned long) pid));
    } while (pid == 0);
d1038 1
a1038 1
	 normal vs abnormal exit in VxWorks? */
d1056 1
a1056 1
    case EVENT_SUSPEND:		/* Task was suspended, probably by ^C. */
d1060 1
a1060 1
    case EVENT_BUS_ERR:		/* Task made evil nasty reference. */
d1073 4
a1076 4
	 to add NSIG to the signal number and claim that PRINT_RANDOM_SIGNAL
	 would take care of it.  But PRINT_RANDOM_SIGNAL has never been
	 defined except on the i960, so I don't really know what we are
	 supposed to do on other architectures.  */
d1080 1
a1080 1
    } /* switch */
d1096 1
a1096 1
  struct ldfile *pLoadFile = (struct ldfile *)arg;
d1098 1
a1098 1
  printf_unfiltered("\t%s: ", pLoadFile->name);
d1128 1
a1128 1
  
d1181 1
a1181 1
  i = 0-1;
d1184 2
a1185 2
      QUIT;	/* FIXME, avoids clnt_freeres below:  mem leak */
      pLoadFile = &loadTable.tbl_ent [i];
d1187 13
a1199 13
  {
    register int desc;
    struct cleanup *old_chain;
    char *fullname = NULL;

    desc = openp (source_path, 0, pLoadFile->name, O_RDONLY, 0, &fullname);
    if (desc < 0)
	perror_with_name (pLoadFile->name);
    old_chain = make_cleanup (close, desc);
    add_file_at_addr (fullname, desc, pLoadFile->txt_addr, pLoadFile->data_addr,
		      pLoadFile->bss_addr);
    do_cleanups (old_chain);
  }
d1202 2
a1203 2
	 not the source path, since source might be in different directories
	 than objects.  */
d1205 1
a1205 1
      if (catch_errors (add_symbol_stub, (char *)pLoadFile, (char *)0,
d1243 1
a1243 1
		       local_hex_string((unsigned long) pid));
d1245 2
a1246 2
  memset ((char *)&ptrace_in,  '\0', sizeof (ptrace_in));
  memset ((char *)&ptrace_out, '\0', sizeof (ptrace_out));
d1291 2
a1292 2
      printf_unfiltered ("Detaching pid %s.\n",
	      local_hex_string((unsigned long) inferior_pid));
d1294 1
a1294 1
  if (args)		/* FIXME, should be possible to leave suspended */
d1296 3
a1298 3
  
  memset ((char *)&ptrace_in,  '\0', sizeof (ptrace_in));
  memset ((char *)&ptrace_out, '\0', sizeof (ptrace_out));
d1311 1
a1311 1
  pop_target ();	/* go back to non-executing VxWorks connection */
d1323 1
a1323 1
  printf_unfiltered ("Killing pid %s.\n", local_hex_string((unsigned long) inferior_pid));
d1325 2
a1326 2
  memset ((char *)&ptrace_in,  '\0', sizeof (ptrace_in));
  memset ((char *)&ptrace_out, '\0', sizeof (ptrace_out));
d1341 1
a1341 1
  pop_target ();	/* go back to non-executing VxWorks connection */
d1361 5
a1365 5
    enum ptracereq procNum;
    xdrproc_t inProc;
    char *in;
    xdrproc_t outProc;
    char *out;
d1368 1
a1368 1
  
d1372 1
a1372 1
      clnt_perrno (status);
d1393 1
a1393 1
/*ARGSUSED*/
d1420 1
a1420 1
  vx_ops.to_magic = OPS_MAGIC;		/* Always the last thing */
d1444 1
a1444 1
  vx_run_ops.to_mourn_inferior = vx_mourn_inferior ;
d1449 2
a1450 2
  vx_run_ops.to_has_execution = 1;	
  vx_run_ops.to_magic = OPS_MAGIC;	
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d31 2
a32 2
#include "bfd.h"		/* Required by objfiles.h.  */
#include "symfile.h"		/* Required by objfiles.h.  */
d66 1
a66 1
extern int stop_soon_quietly;	/* for wait_for_inferior */
d70 1
a70 1
static enum clnt_stat net_clnt_call ();		/* Forward decl */
d84 1
a84 1
static char *vx_running;	/* Called function */
d95 1
a95 1
CLIENT *pClient;		/* client used in net debugging */
d98 1
a98 1
enum clnt_stat net_clnt_call ();
d101 1
a101 2
static struct timeval rpcTimeout =
{10, 0};
d105 1
a105 1

d133 1
a133 1
  load_timeout.tv_sec = 99999999;	/* A large number, effectively inf. */
d135 1
a135 1

d161 2
a162 2
  Rptrace ptrace_in;		/* XXX This is stupid.  It doesn't need to be a ptrace
				   structure.  How about something smaller? */
d174 1
a174 1
    return errno;
d178 1
a178 1
  return break_status;		/* probably (FIXME) zero */
d205 1
a205 1

d270 1
a270 1

d272 1
a272 1

d312 1
a312 1

d339 1
a339 1

d346 1
a346 1
     RDB_EVENT *pEvent;
d348 2
a349 2
  int pid;
  enum clnt_stat status;
d351 1
a351 1
  memset ((char *) pEvent, '\0', sizeof (RDB_EVENT));
d353 3
a355 3
  pid = inferior_pid;
  status = net_clnt_call (PROCESS_WAIT, xdr_int, &pid, xdr_RDB_EVENT,
			  pEvent);
d357 7
a363 7
  /* return (status == RPC_SUCCESS)? pEvent->status: -1; */
  if (status == RPC_SUCCESS)
    return ((pEvent->status) ? 1 : 0);
  else if (status == RPC_TIMEDOUT)
    return (1);
  else
    return (-1);
d365 1
a365 1

d386 1
a386 1
  return (status == RPC_SUCCESS) ? quit_status : -1;
d415 1
a415 1
  ptrace_out.info.more_data = (caddr_t) & out_data;
d426 2
a427 2
	       ? "general-purpose"
	       : "floating-point");
d461 1
a461 1
  ptrace_in.info.more_data = (caddr_t) & in_data;
d472 2
a473 2
	       ? "general-purpose"
	       : "floating-point");
d502 1
a502 1
     struct target_ops *target;	/* ignored */
d514 1
a514 1
  ptrace_in.pid = inferior_pid;	/* XXX pid unnecessary for READDATA */
d516 1
a516 1
  ptrace_in.data = len;		/* How many bytes */
d520 2
a521 2
      ptrace_in.info.ttype = DATA;
      ptrace_in.info.more_data = (caddr_t) & data;
d524 1
a524 1
      data.len = len;		/* How many bytes (again, for XDR) */
d529 1
a529 1
      ptrace_out.info.more_data = (caddr_t) & data;
d552 1
a552 1
	error (rpcerr);
d556 5
a560 5
	{
	  memaddr += nxfer;
	  myaddr += nxfer;
	  nleft -= nxfer;
	}
d562 4
a565 4
	{
	  /* A target-side error has ocurred.  Set errno to the error
	     code chosen by the target so that a later perror () will
	     say something meaningful.  */
d567 2
a568 2
	  errno = ptrace_out.errno_num;
	}
d580 1
a580 1
  printf_unfiltered (", which has %sfloating point", target_has_fp ? "" : "no ");
d587 1
a587 1
  printf_unfiltered ("\tRunning %s VxWorks process %s",
d592 1
a592 1
  printf_unfiltered (".\n");
d628 1
a628 1
  ptrace_in.addr = cont_addr;	/* Target side insists on this, or it panics.  */
d631 1
a631 1
    status = net_step ();
d650 1
a651 1

d655 5
a659 6
struct find_sect_args
  {
    CORE_ADDR text_start;
    CORE_ADDR data_start;
    CORE_ADDR bss_start;
  };
d669 1
a669 1
  struct find_sect_args *args = (struct find_sect_args *) obj;
d753 1
a753 1
	target_kill ();
d755 1
a755 1
	error ("Load cancelled.");
d800 1
a800 1
  else
d809 3
a811 3
     enum ptracereq request;
     Rptrace *pPtraceIn;
     Ptrace_return *pPtraceOut;
d819 1
a819 1
    return -1;
d848 1
a848 1
     ldtabl *pLoadTable;	/* return pointer to ldtabl here */
d863 1
a863 1
{"Lost contact with VxWorks target", 0, 0};
d896 1
a896 1
  bool_t fp = 0;		/* true if fp processor is present on target board */
d902 1
a902 1
  return (int) fp;
d928 1
a928 1
      addr = *(unsigned long *) destHost->h_addr;
d934 3
a936 3
  destAddr.sin_family = AF_INET;
  destAddr.sin_port = 0;	/* set to actual port that remote
				   ptrace is listening on.  */
d988 1
a988 1
         suspend the inferior process.  */
d998 4
a1001 4
         allow the user to break the connection with the target.
         We can't simply error () out of this loop, since the 
         data structures representing the state of the inferior
         are in an inconsistent state.  */
d1008 1
a1008 1
		     : "get status of remote task"))
d1010 1
a1010 1
	      target_mourn_inferior ();
d1019 1
a1019 1

d1027 2
a1028 3
	       local_hex_string ((unsigned long) pid));
    }
  while (pid == 0);
d1038 1
a1038 1
         normal vs abnormal exit in VxWorks? */
d1056 1
a1056 1
    case EVENT_SUSPEND:	/* Task was suspended, probably by ^C. */
d1060 1
a1060 1
    case EVENT_BUS_ERR:	/* Task made evil nasty reference. */
d1073 4
a1076 4
         to add NSIG to the signal number and claim that PRINT_RANDOM_SIGNAL
         would take care of it.  But PRINT_RANDOM_SIGNAL has never been
         defined except on the i960, so I don't really know what we are
         supposed to do on other architectures.  */
d1080 1
a1080 1
    }				/* switch */
d1096 1
a1096 1
  struct ldfile *pLoadFile = (struct ldfile *) arg;
d1098 1
a1098 1
  printf_unfiltered ("\t%s: ", pLoadFile->name);
d1128 1
a1128 1

d1181 1
a1181 1
  i = 0 - 1;
d1184 2
a1185 2
      QUIT;			/* FIXME, avoids clnt_freeres below:  mem leak */
      pLoadFile = &loadTable.tbl_ent[i];
d1187 13
a1199 13
      {
	register int desc;
	struct cleanup *old_chain;
	char *fullname = NULL;

	desc = openp (source_path, 0, pLoadFile->name, O_RDONLY, 0, &fullname);
	if (desc < 0)
	  perror_with_name (pLoadFile->name);
	old_chain = make_cleanup (close, desc);
	add_file_at_addr (fullname, desc, pLoadFile->txt_addr, pLoadFile->data_addr,
			  pLoadFile->bss_addr);
	do_cleanups (old_chain);
      }
d1202 2
a1203 2
         not the source path, since source might be in different directories
         than objects.  */
d1205 1
a1205 1
      if (catch_errors (add_symbol_stub, (char *) pLoadFile, (char *) 0,
d1243 1
a1243 1
		       local_hex_string ((unsigned long) pid));
d1245 2
a1246 2
  memset ((char *) &ptrace_in, '\0', sizeof (ptrace_in));
  memset ((char *) &ptrace_out, '\0', sizeof (ptrace_out));
d1291 2
a1292 2
    printf_unfiltered ("Detaching pid %s.\n",
		       local_hex_string ((unsigned long) inferior_pid));
d1294 1
a1294 1
  if (args)			/* FIXME, should be possible to leave suspended */
d1296 3
a1298 3

  memset ((char *) &ptrace_in, '\0', sizeof (ptrace_in));
  memset ((char *) &ptrace_out, '\0', sizeof (ptrace_out));
d1311 1
a1311 1
  pop_target ();		/* go back to non-executing VxWorks connection */
d1323 1
a1323 1
  printf_unfiltered ("Killing pid %s.\n", local_hex_string ((unsigned long) inferior_pid));
d1325 2
a1326 2
  memset ((char *) &ptrace_in, '\0', sizeof (ptrace_in));
  memset ((char *) &ptrace_out, '\0', sizeof (ptrace_out));
d1341 1
a1341 1
  pop_target ();		/* go back to non-executing VxWorks connection */
d1361 5
a1365 5
     enum ptracereq procNum;
     xdrproc_t inProc;
     char *in;
     xdrproc_t outProc;
     char *out;
d1368 1
a1368 1

d1372 1
a1372 1
    clnt_perrno (status);
d1393 1
a1393 1
/*ARGSUSED */
d1420 1
a1420 1
  vx_ops.to_magic = OPS_MAGIC;	/* Always the last thing */
d1444 1
a1444 1
  vx_run_ops.to_mourn_inferior = vx_mourn_inferior;
d1449 2
a1450 2
  vx_run_ops.to_has_execution = 1;
  vx_run_ops.to_magic = OPS_MAGIC;
@


1.1.1.3
log
@import gdb-1999-08-09 snapshot
@
text
@d1029 2
a1030 2
	internal_error ("Bad pid for debugged task: %s\n",
			local_hex_string ((unsigned long) pid));
@


1.1.1.4
log
@import gdb-1999-09-08 snapshot
@
text
@d711 6
a716 2
  offs = (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
  memcpy (offs, objfile->section_offsets, SIZEOF_SECTION_OFFSETS);
@


1.1.1.5
log
@import gdb-1999-10-04 snapshot
@
text
@d704 1
a704 1
  objfile = symbol_file_add (name, from_tty, NULL, 0, 0, 0, 0);
@


1.1.1.6
log
@import gdb-1999-10-11 snapshot
@
text
@d704 1
a704 1
  objfile = symbol_file_add (name, from_tty, NULL, 0, 0);
@


