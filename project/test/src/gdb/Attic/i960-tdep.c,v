head	1.13;
access;
symbols
	gdb_5_3-2002-12-12-release:1.12
	carlton_dictionary-20021115-merge:1.12
	kseitz_interps-20021105-merge:1.12
	kseitz_interps-20021103-merge:1.12
	drow-cplus-merge-20021020:1.12
	drow-cplus-merge-20021025:1.12
	carlton_dictionary-20021025-merge:1.12
	carlton_dictionary-20021011-merge:1.12
	drow-cplus-branch:1.12.0.10
	drow-cplus-branchpoint:1.12
	kseitz_interps-20020930-merge:1.12
	carlton_dictionary-20020927-merge:1.12
	carlton_dictionary-branch:1.12.0.8
	carlton_dictionary-20020920-branchpoint:1.12
	gdb_5_3-branch:1.12.0.6
	gdb_5_3-2002-09-04-branchpoint:1.12
	kseitz_interps-20020829-merge:1.12
	cagney_sysregs-20020825-branch:1.12.0.4
	cagney_sysregs-20020825-branchpoint:1.12
	readline_4_3-import-branch:1.12.0.2
	readline_4_3-import-branchpoint:1.12
	gdb_5_2_1-2002-07-23-release:1.8
	kseitz_interps-20020528-branch:1.10.0.6
	kseitz_interps-20020528-branchpoint:1.10
	cagney_regbuf-20020515-branch:1.10.0.4
	cagney_regbuf-20020515-branchpoint:1.10
	jimb-macro-020506-branch:1.10.0.2
	jimb-macro-020506-branchpoint:1.10
	gdb_5_2-2002-04-29-release:1.8
	gdb_5_2-branch:1.8.0.2
	gdb_5_2-2002-03-03-branchpoint:1.8
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	cygnus_cvs_20020108_pre:1.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.8
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.6
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.4
	gdb_5_1-2001-07-29-branchpoint:1.7
	dberlin-typesystem-branch:1.7.0.2
	dberlin-typesystem-branchpoint:1.7
	gdb-post-ptid_t-2001-05-03:1.7
	gdb-pre-ptid_t-2001-05-03:1.7
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.6
	gdb_5_0-2000-05-19-release:1.1.1.6
	gdb_4_18_2-2000-05-18-release:1.1.1.6
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.6
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.6
	gdb_5_0-2000-04-10-branch:1.1.1.6.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.6
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.6
	gdb-1999-11-16:1.1.1.6
	gdb-1999-11-08:1.1.1.6
	gdb-1999-11-01:1.1.1.6
	gdb-1999-10-25:1.1.1.6
	gdb-1999-10-18:1.1.1.6
	gdb-1999-10-11:1.1.1.6
	gdb-1999-10-04:1.1.1.6
	gdb-1999-09-28:1.1.1.5
	gdb-1999-09-21:1.1.1.5
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.5
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.3
	gdb-1999-05-10:1.1.1.3
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.13
date	2002.12.16.20.39.07;	author cagney;	state dead;
branches;
next	1.12;

1.12
date	2002.08.22.21.52.44;	author cagney;	state Exp;
branches
	1.12.8.1
	1.12.10.1;
next	1.11;

1.11
date	2002.07.30.13.45.13;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.24.13.48.28;	author davem;	state Exp;
branches
	1.10.6.1;
next	1.9;

1.9
date	2002.04.21.15.19.06;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.13.03.10.35;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.06.08.21.08;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.07.19.27.15;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.27;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.29;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.42.35;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.07.08;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.09.08.23.59.16;	author shebs;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.10.05.23.08.21;	author jsm;	state Exp;
branches;
next	;

1.10.6.1
date	2002.08.09.18.34.25;	author kseitz;	state Exp;
branches;
next	1.10.6.2;

1.10.6.2
date	2002.08.30.22.52.44;	author kseitz;	state Exp;
branches;
next	;

1.12.8.1
date	2002.12.23.19.38.30;	author carlton;	state dead;
branches;
next	;

1.12.10.1
date	2003.12.14.20.27.19;	author drow;	state dead;
branches;
next	;


desc
@@


1.13
log
@2002-12-16  Andrew Cagney  <ac131313@@redhat.com>

	* config/arc/arc.mt, config/arc/tm-arc.h: Delete.
	* config/d30v/d30v.mt, config/d30v/tm-d30v.h: Delete.
	* config/fr30/fr30.mt, config/fr30/tm-fr30.h: Delete.
	* config/i386/i386aix.mh, config/i386/i386aix.mt: Delete.
	* config/i386/i386m3.mh, config/i386/i386m3.mt: Delete.
	* config/i386/i386mach.mh, config/i386/i386os9k.mt: Delete.
	* config/i386/nm-i386aix.h, config/i386/nm-i386mach.h: Delete.
	* config/i386/nm-m3.h, config/i386/tm-i386aix.h: Delete.
	* config/i386/tm-i386m3.h, config/i386/tm-i386mk.h: Delete.
	* config/i386/xm-i386aix.h, config/i386/xm-i386m3.h: Delete.
	* config/i386/xm-i386mach.h, config/i386/xm-i386mk.h: Delete.
	* config/i960/mon960.mt, config/i960/nindy960.mt: Delete.
	* config/i960/tm-i960.h, config/i960/tm-mon960.h: Delete.
	* config/i960/tm-nindy960.h, config/i960/tm-vx960.h: Delete.
	* config/i960/vxworks960.mt, config/m68k/apollo68b.mh: Delete.
	* config/m68k/apollo68b.mt, config/m68k/apollo68v.mh: Delete.
	* config/m68k/hp300bsd.mh, config/m68k/hp300bsd.mt: Delete.
	* config/m68k/hp300hpux.mh, config/m68k/hp300hpux.mt: Delete.
	* config/m88k/delta88.mh, config/m88k/delta88.mt: Delete.
	* config/m88k/delta88v4.mh, config/m88k/delta88v4.mt: Delete.
	* config/m88k/m88k.mh, config/m88k/m88k.mt: Delete.
	* config/m88k/nm-delta88v4.h, config/m88k/nm-m88k.h: Delete.
	* config/m88k/tm-delta88.h, config/m88k/tm-delta88v4.h: Delete.
	* config/m88k/tm-m88k.h, config/m88k/xm-delta88.h: Delete.
	* config/m88k/xm-dgux.h: Delete.
	* fr30-tdep.c, i386aix-nat.c, i386m3-nat.c: Delete.
	* i386mach-nat.c, i960-tdep.c, m88k-nat.c: Delete.
	* os9kread.c, remote-bug.c, remote-nindy.c: Delete.
	* remote-nrom.c, remote-os9k.c, remote-vx960.c: Delete.
	* d30v-tdep.c, arc-tdep.c, cxux-nat.c, dst.h, dstread.c: Delete.
	* ch-exp.c, ch-lang.c, ch-lang.h, ch-typeprint.c: Delete.
	* ch-valprint.c: Delete.
@
text
@// OBSOLETE /* Target-machine dependent code for the Intel 960
// OBSOLETE 
// OBSOLETE    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
// OBSOLETE    2001, 2002 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    Contributed by Intel Corporation.
// OBSOLETE    examine_prologue and other parts contributed by Wind River Systems.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "floatformat.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE #include "gdb_string.h"
// OBSOLETE 
// OBSOLETE static CORE_ADDR next_insn (CORE_ADDR memaddr,
// OBSOLETE 			    unsigned int *pword1, unsigned int *pword2);
// OBSOLETE 
// OBSOLETE struct type *
// OBSOLETE i960_register_type (int regnum)
// OBSOLETE {
// OBSOLETE   if (regnum < FP0_REGNUM)
// OBSOLETE     return builtin_type_int32;
// OBSOLETE   else
// OBSOLETE     return builtin_type_i960_ext;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Does the specified function use the "struct returning" convention
// OBSOLETE    or the "value returning" convention?  The "value returning" convention
// OBSOLETE    almost invariably returns the entire value in registers.  The
// OBSOLETE    "struct returning" convention often returns the entire value in
// OBSOLETE    memory, and passes a pointer (out of or into the function) saying
// OBSOLETE    where the value (is or should go).
// OBSOLETE 
// OBSOLETE    Since this sometimes depends on whether it was compiled with GCC,
// OBSOLETE    this is also an argument.  This is used in call_function to build a
// OBSOLETE    stack, and in value_being_returned to print return values.
// OBSOLETE 
// OBSOLETE    On i960, a structure is returned in registers g0-g3, if it will fit.
// OBSOLETE    If it's more than 16 bytes long, g13 pointed to it on entry.  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE i960_use_struct_convention (int gcc_p, struct type *type)
// OBSOLETE {
// OBSOLETE   return (TYPE_LENGTH (type) > 16);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* gdb960 is always running on a non-960 host.  Check its characteristics.
// OBSOLETE    This routine must be called as part of gdb initialization.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE check_host (void)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   static struct typestruct
// OBSOLETE     {
// OBSOLETE       int hostsize;		/* Size of type on host         */
// OBSOLETE       int i960size;		/* Size of type on i960         */
// OBSOLETE       char *typename;		/* Name of type, for error msg  */
// OBSOLETE     }
// OBSOLETE   types[] =
// OBSOLETE   {
// OBSOLETE     {
// OBSOLETE       sizeof (short), 2, "short"
// OBSOLETE     }
// OBSOLETE      ,
// OBSOLETE     {
// OBSOLETE       sizeof (int), 4, "int"
// OBSOLETE     }
// OBSOLETE      ,
// OBSOLETE     {
// OBSOLETE       sizeof (long), 4, "long"
// OBSOLETE     }
// OBSOLETE      ,
// OBSOLETE     {
// OBSOLETE       sizeof (float), 4, "float"
// OBSOLETE     }
// OBSOLETE      ,
// OBSOLETE     {
// OBSOLETE       sizeof (double), 8, "double"
// OBSOLETE     }
// OBSOLETE      ,
// OBSOLETE     {
// OBSOLETE       sizeof (char *), 4, "pointer"
// OBSOLETE     }
// OBSOLETE      ,
// OBSOLETE   };
// OBSOLETE #define TYPELEN	(sizeof(types) / sizeof(struct typestruct))
// OBSOLETE 
// OBSOLETE   /* Make sure that host type sizes are same as i960
// OBSOLETE    */
// OBSOLETE   for (i = 0; i < TYPELEN; i++)
// OBSOLETE     {
// OBSOLETE       if (types[i].hostsize != types[i].i960size)
// OBSOLETE 	{
// OBSOLETE 	  printf_unfiltered ("sizeof(%s) != %d:  PROCEED AT YOUR OWN RISK!\n",
// OBSOLETE 			     types[i].typename, types[i].i960size);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Is this register part of the register window system?  A yes answer
// OBSOLETE    implies that 1) The name of this register will not be the same in
// OBSOLETE    other frames, and 2) This register is automatically "saved" upon
// OBSOLETE    subroutine calls and thus there is no need to search more than one
// OBSOLETE    stack frame for it.
// OBSOLETE 
// OBSOLETE    On the i960, in fact, the name of this register in another frame is
// OBSOLETE    "mud" -- there is no overlap between the windows.  Each window is
// OBSOLETE    simply saved into the stack (true for our purposes, after having been
// OBSOLETE    flushed; normally they reside on-chip and are restored from on-chip
// OBSOLETE    without ever going to memory).  */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE register_in_window_p (int regnum)
// OBSOLETE {
// OBSOLETE   return regnum <= R15_REGNUM;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* i960_find_saved_register ()
// OBSOLETE 
// OBSOLETE    Return the address in which frame FRAME's value of register REGNUM
// OBSOLETE    has been saved in memory.  Or return zero if it has not been saved.
// OBSOLETE    If REGNUM specifies the SP, the value we return is actually the SP
// OBSOLETE    value, not an address where it was saved.  */
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE i960_find_saved_register (struct frame_info *frame, int regnum)
// OBSOLETE {
// OBSOLETE   register struct frame_info *frame1 = NULL;
// OBSOLETE   register CORE_ADDR addr = 0;
// OBSOLETE 
// OBSOLETE   if (frame == NULL)		/* No regs saved if want current frame */
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   /* We assume that a register in a register window will only be saved
// OBSOLETE      in one place (since the name changes and/or disappears as you go
// OBSOLETE      towards inner frames), so we only call get_frame_saved_regs on
// OBSOLETE      the current frame.  This is directly in contradiction to the
// OBSOLETE      usage below, which assumes that registers used in a frame must be
// OBSOLETE      saved in a lower (more interior) frame.  This change is a result
// OBSOLETE      of working on a register window machine; get_frame_saved_regs
// OBSOLETE      always returns the registers saved within a frame, within the
// OBSOLETE      context (register namespace) of that frame. */
// OBSOLETE 
// OBSOLETE   /* However, note that we don't want this to return anything if
// OBSOLETE      nothing is saved (if there's a frame inside of this one).  Also,
// OBSOLETE      callers to this routine asking for the stack pointer want the
// OBSOLETE      stack pointer saved for *this* frame; this is returned from the
// OBSOLETE      next frame.  */
// OBSOLETE 
// OBSOLETE   if (register_in_window_p (regnum))
// OBSOLETE     {
// OBSOLETE       frame1 = get_next_frame (frame);
// OBSOLETE       if (!frame1)
// OBSOLETE 	return 0;		/* Registers of this frame are active.  */
// OBSOLETE 
// OBSOLETE       /* Get the SP from the next frame in; it will be this
// OBSOLETE          current frame.  */
// OBSOLETE       if (regnum != SP_REGNUM)
// OBSOLETE 	frame1 = frame;
// OBSOLETE 
// OBSOLETE       FRAME_INIT_SAVED_REGS (frame1);
// OBSOLETE       return frame1->saved_regs[regnum];	/* ... which might be zero */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Note that this next routine assumes that registers used in
// OBSOLETE      frame x will be saved only in the frame that x calls and
// OBSOLETE      frames interior to it.  This is not true on the sparc, but the
// OBSOLETE      above macro takes care of it, so we should be all right. */
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       QUIT;
// OBSOLETE       frame1 = get_next_frame (frame);
// OBSOLETE       if (frame1 == 0)
// OBSOLETE 	break;
// OBSOLETE       frame = frame1;
// OBSOLETE       FRAME_INIT_SAVED_REGS (frame1);
// OBSOLETE       if (frame1->saved_regs[regnum])
// OBSOLETE 	addr = frame1->saved_regs[regnum];
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return addr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* i960_get_saved_register ()
// OBSOLETE 
// OBSOLETE    Find register number REGNUM relative to FRAME and put its (raw,
// OBSOLETE    target format) contents in *RAW_BUFFER.  Set *OPTIMIZED if the
// OBSOLETE    variable was optimized out (and thus can't be fetched).  Set *LVAL
// OBSOLETE    to lval_memory, lval_register, or not_lval, depending on whether
// OBSOLETE    the value was fetched from memory, from a register, or in a strange
// OBSOLETE    and non-modifiable way (e.g. a frame pointer which was calculated
// OBSOLETE    rather than fetched).  Set *ADDRP to the address, either in memory
// OBSOLETE    on as a REGISTER_BYTE offset into the registers array.
// OBSOLETE 
// OBSOLETE    Note that this implementation never sets *LVAL to not_lval.  But it
// OBSOLETE    can be replaced by defining GET_SAVED_REGISTER and supplying your
// OBSOLETE    own.
// OBSOLETE 
// OBSOLETE    The argument RAW_BUFFER must point to aligned memory.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE i960_get_saved_register (char *raw_buffer,
// OBSOLETE 			 int *optimized,
// OBSOLETE 			 CORE_ADDR *addrp,
// OBSOLETE 			 struct frame_info *frame,
// OBSOLETE 			 int regnum,
// OBSOLETE 			 enum lval_type *lval)
// OBSOLETE {
// OBSOLETE   CORE_ADDR addr;
// OBSOLETE 
// OBSOLETE   if (!target_has_registers)
// OBSOLETE     error ("No registers.");
// OBSOLETE 
// OBSOLETE   /* Normal systems don't optimize out things with register numbers.  */
// OBSOLETE   if (optimized != NULL)
// OBSOLETE     *optimized = 0;
// OBSOLETE   addr = i960_find_saved_register (frame, regnum);
// OBSOLETE   if (addr != 0)
// OBSOLETE     {
// OBSOLETE       if (lval != NULL)
// OBSOLETE 	*lval = lval_memory;
// OBSOLETE       if (regnum == SP_REGNUM)
// OBSOLETE 	{
// OBSOLETE 	  if (raw_buffer != NULL)
// OBSOLETE 	    {
// OBSOLETE 	      /* Put it back in target format.  */
// OBSOLETE 	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum),
// OBSOLETE 			     (LONGEST) addr);
// OBSOLETE 	    }
// OBSOLETE 	  if (addrp != NULL)
// OBSOLETE 	    *addrp = 0;
// OBSOLETE 	  return;
// OBSOLETE 	}
// OBSOLETE       if (raw_buffer != NULL)
// OBSOLETE 	target_read_memory (addr, raw_buffer, REGISTER_RAW_SIZE (regnum));
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if (lval != NULL)
// OBSOLETE 	*lval = lval_register;
// OBSOLETE       addr = REGISTER_BYTE (regnum);
// OBSOLETE       if (raw_buffer != NULL)
// OBSOLETE 	read_register_gen (regnum, raw_buffer);
// OBSOLETE     }
// OBSOLETE   if (addrp != NULL)
// OBSOLETE     *addrp = addr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Examine an i960 function prologue, recording the addresses at which
// OBSOLETE    registers are saved explicitly by the prologue code, and returning
// OBSOLETE    the address of the first instruction after the prologue (but not
// OBSOLETE    after the instruction at address LIMIT, as explained below).
// OBSOLETE 
// OBSOLETE    LIMIT places an upper bound on addresses of the instructions to be
// OBSOLETE    examined.  If the prologue code scan reaches LIMIT, the scan is
// OBSOLETE    aborted and LIMIT is returned.  This is used, when examining the
// OBSOLETE    prologue for the current frame, to keep examine_prologue () from
// OBSOLETE    claiming that a given register has been saved when in fact the
// OBSOLETE    instruction that saves it has not yet been executed.  LIMIT is used
// OBSOLETE    at other times to stop the scan when we hit code after the true
// OBSOLETE    function prologue (e.g. for the first source line) which might
// OBSOLETE    otherwise be mistaken for function prologue.
// OBSOLETE 
// OBSOLETE    The format of the function prologue matched by this routine is
// OBSOLETE    derived from examination of the source to gcc960 1.21, particularly
// OBSOLETE    the routine i960_function_prologue ().  A "regular expression" for
// OBSOLETE    the function prologue is given below:
// OBSOLETE 
// OBSOLETE    (lda LRn, g14
// OBSOLETE    mov g14, g[0-7]
// OBSOLETE    (mov 0, g14) | (lda 0, g14))?
// OBSOLETE 
// OBSOLETE    (mov[qtl]? g[0-15], r[4-15])*
// OBSOLETE    ((addo [1-31], sp, sp) | (lda n(sp), sp))?
// OBSOLETE    (st[qtl]? g[0-15], n(fp))*
// OBSOLETE 
// OBSOLETE    (cmpobne 0, g14, LFn
// OBSOLETE    mov sp, g14
// OBSOLETE    lda 0x30(sp), sp
// OBSOLETE    LFn: stq g0, (g14)
// OBSOLETE    stq g4, 0x10(g14)
// OBSOLETE    stq g8, 0x20(g14))?
// OBSOLETE 
// OBSOLETE    (st g14, n(fp))?
// OBSOLETE    (mov g13,r[4-15])?
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE /* Macros for extracting fields from i960 instructions.  */
// OBSOLETE 
// OBSOLETE #define BITMASK(pos, width) (((0x1 << (width)) - 1) << (pos))
// OBSOLETE #define EXTRACT_FIELD(val, pos, width) ((val) >> (pos) & BITMASK (0, width))
// OBSOLETE 
// OBSOLETE #define REG_SRC1(insn)    EXTRACT_FIELD (insn, 0, 5)
// OBSOLETE #define REG_SRC2(insn)    EXTRACT_FIELD (insn, 14, 5)
// OBSOLETE #define REG_SRCDST(insn)  EXTRACT_FIELD (insn, 19, 5)
// OBSOLETE #define MEM_SRCDST(insn)  EXTRACT_FIELD (insn, 19, 5)
// OBSOLETE #define MEMA_OFFSET(insn) EXTRACT_FIELD (insn, 0, 12)
// OBSOLETE 
// OBSOLETE /* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or
// OBSOLETE    is not the address of a valid instruction, the address of the next
// OBSOLETE    instruction beyond ADDR otherwise.  *PWORD1 receives the first word
// OBSOLETE    of the instruction, and (for two-word instructions), *PWORD2 receives
// OBSOLETE    the second.  */
// OBSOLETE 
// OBSOLETE #define NEXT_PROLOGUE_INSN(addr, lim, pword1, pword2) \
// OBSOLETE   (((addr) < (lim)) ? next_insn (addr, pword1, pword2) : 0)
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE examine_prologue (register CORE_ADDR ip, register CORE_ADDR limit,
// OBSOLETE 		  CORE_ADDR frame_addr, struct frame_saved_regs *fsr)
// OBSOLETE {
// OBSOLETE   register CORE_ADDR next_ip;
// OBSOLETE   register int src, dst;
// OBSOLETE   register unsigned int *pcode;
// OBSOLETE   unsigned int insn1, insn2;
// OBSOLETE   int size;
// OBSOLETE   int within_leaf_prologue;
// OBSOLETE   CORE_ADDR save_addr;
// OBSOLETE   static unsigned int varargs_prologue_code[] =
// OBSOLETE   {
// OBSOLETE     0x3507a00c,			/* cmpobne 0x0, g14, LFn */
// OBSOLETE     0x5cf01601,			/* mov sp, g14           */
// OBSOLETE     0x8c086030,			/* lda 0x30(sp), sp      */
// OBSOLETE     0xb2879000,			/* LFn: stq  g0, (g14)   */
// OBSOLETE     0xb2a7a010,			/* stq g4, 0x10(g14)     */
// OBSOLETE     0xb2c7a020			/* stq g8, 0x20(g14)     */
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE   /* Accept a leaf procedure prologue code fragment if present.
// OBSOLETE      Note that ip might point to either the leaf or non-leaf
// OBSOLETE      entry point; we look for the non-leaf entry point first:  */
// OBSOLETE 
// OBSOLETE   within_leaf_prologue = 0;
// OBSOLETE   if ((next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2))
// OBSOLETE       && ((insn1 & 0xfffff000) == 0x8cf00000	/* lda LRx, g14 (MEMA) */
// OBSOLETE 	  || (insn1 & 0xfffffc60) == 0x8cf03000))	/* lda LRx, g14 (MEMB) */
// OBSOLETE     {
// OBSOLETE       within_leaf_prologue = 1;
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (next_ip, limit, &insn1, &insn2);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Now look for the prologue code at a leaf entry point:  */
// OBSOLETE 
// OBSOLETE   if (next_ip
// OBSOLETE       && (insn1 & 0xff87ffff) == 0x5c80161e	/* mov g14, gx */
// OBSOLETE       && REG_SRCDST (insn1) <= G0_REGNUM + 7)
// OBSOLETE     {
// OBSOLETE       within_leaf_prologue = 1;
// OBSOLETE       if ((next_ip = NEXT_PROLOGUE_INSN (next_ip, limit, &insn1, &insn2))
// OBSOLETE 	  && (insn1 == 0x8cf00000	/* lda 0, g14 */
// OBSOLETE 	      || insn1 == 0x5cf01e00))	/* mov 0, g14 */
// OBSOLETE 	{
// OBSOLETE 	  ip = next_ip;
// OBSOLETE 	  next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
// OBSOLETE 	  within_leaf_prologue = 0;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* If something that looks like the beginning of a leaf prologue
// OBSOLETE      has been seen, but the remainder of the prologue is missing, bail.
// OBSOLETE      We don't know what we've got.  */
// OBSOLETE 
// OBSOLETE   if (within_leaf_prologue)
// OBSOLETE     return (ip);
// OBSOLETE 
// OBSOLETE   /* Accept zero or more instances of "mov[qtl]? gx, ry", where y >= 4.
// OBSOLETE      This may cause us to mistake the moving of a register
// OBSOLETE      parameter to a local register for the saving of a callee-saved
// OBSOLETE      register, but that can't be helped, since with the
// OBSOLETE      "-fcall-saved" flag, any register can be made callee-saved.  */
// OBSOLETE 
// OBSOLETE   while (next_ip
// OBSOLETE 	 && (insn1 & 0xfc802fb0) == 0x5c000610
// OBSOLETE 	 && (dst = REG_SRCDST (insn1)) >= (R0_REGNUM + 4))
// OBSOLETE     {
// OBSOLETE       src = REG_SRC1 (insn1);
// OBSOLETE       size = EXTRACT_FIELD (insn1, 24, 2) + 1;
// OBSOLETE       save_addr = frame_addr + ((dst - R0_REGNUM) * 4);
// OBSOLETE       while (size--)
// OBSOLETE 	{
// OBSOLETE 	  fsr->regs[src++] = save_addr;
// OBSOLETE 	  save_addr += 4;
// OBSOLETE 	}
// OBSOLETE       ip = next_ip;
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Accept an optional "addo n, sp, sp" or "lda n(sp), sp".  */
// OBSOLETE 
// OBSOLETE   if (next_ip &&
// OBSOLETE       ((insn1 & 0xffffffe0) == 0x59084800	/* addo n, sp, sp */
// OBSOLETE        || (insn1 & 0xfffff000) == 0x8c086000	/* lda n(sp), sp (MEMA) */
// OBSOLETE        || (insn1 & 0xfffffc60) == 0x8c087400))	/* lda n(sp), sp (MEMB) */
// OBSOLETE     {
// OBSOLETE       ip = next_ip;
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Accept zero or more instances of "st[qtl]? gx, n(fp)".  
// OBSOLETE      This may cause us to mistake the copying of a register
// OBSOLETE      parameter to the frame for the saving of a callee-saved
// OBSOLETE      register, but that can't be helped, since with the
// OBSOLETE      "-fcall-saved" flag, any register can be made callee-saved.
// OBSOLETE      We can, however, refuse to accept a save of register g14,
// OBSOLETE      since that is matched explicitly below.  */
// OBSOLETE 
// OBSOLETE   while (next_ip &&
// OBSOLETE 	 ((insn1 & 0xf787f000) == 0x9287e000	/* stl? gx, n(fp) (MEMA) */
// OBSOLETE 	  || (insn1 & 0xf787fc60) == 0x9287f400		/* stl? gx, n(fp) (MEMB) */
// OBSOLETE 	  || (insn1 & 0xef87f000) == 0xa287e000		/* st[tq] gx, n(fp) (MEMA) */
// OBSOLETE 	  || (insn1 & 0xef87fc60) == 0xa287f400)	/* st[tq] gx, n(fp) (MEMB) */
// OBSOLETE 	 && ((src = MEM_SRCDST (insn1)) != G14_REGNUM))
// OBSOLETE     {
// OBSOLETE       save_addr = frame_addr + ((insn1 & BITMASK (12, 1))
// OBSOLETE 				? insn2 : MEMA_OFFSET (insn1));
// OBSOLETE       size = (insn1 & BITMASK (29, 1)) ? ((insn1 & BITMASK (28, 1)) ? 4 : 3)
// OBSOLETE 	: ((insn1 & BITMASK (27, 1)) ? 2 : 1);
// OBSOLETE       while (size--)
// OBSOLETE 	{
// OBSOLETE 	  fsr->regs[src++] = save_addr;
// OBSOLETE 	  save_addr += 4;
// OBSOLETE 	}
// OBSOLETE       ip = next_ip;
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Accept the varargs prologue code if present.  */
// OBSOLETE 
// OBSOLETE   size = sizeof (varargs_prologue_code) / sizeof (int);
// OBSOLETE   pcode = varargs_prologue_code;
// OBSOLETE   while (size-- && next_ip && *pcode++ == insn1)
// OBSOLETE     {
// OBSOLETE       ip = next_ip;
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Accept an optional "st g14, n(fp)".  */
// OBSOLETE 
// OBSOLETE   if (next_ip &&
// OBSOLETE       ((insn1 & 0xfffff000) == 0x92f7e000	/* st g14, n(fp) (MEMA) */
// OBSOLETE        || (insn1 & 0xfffffc60) == 0x92f7f400))	/* st g14, n(fp) (MEMB) */
// OBSOLETE     {
// OBSOLETE       fsr->regs[G14_REGNUM] = frame_addr + ((insn1 & BITMASK (12, 1))
// OBSOLETE 					    ? insn2 : MEMA_OFFSET (insn1));
// OBSOLETE       ip = next_ip;
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Accept zero or one instance of "mov g13, ry", where y >= 4.
// OBSOLETE      This is saving the address where a struct should be returned.  */
// OBSOLETE 
// OBSOLETE   if (next_ip
// OBSOLETE       && (insn1 & 0xff802fbf) == 0x5c00061d
// OBSOLETE       && (dst = REG_SRCDST (insn1)) >= (R0_REGNUM + 4))
// OBSOLETE     {
// OBSOLETE       save_addr = frame_addr + ((dst - R0_REGNUM) * 4);
// OBSOLETE       fsr->regs[G0_REGNUM + 13] = save_addr;
// OBSOLETE       ip = next_ip;
// OBSOLETE #if 0				/* We'll need this once there is a subsequent instruction examined. */
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
// OBSOLETE #endif
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return (ip);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Given an ip value corresponding to the start of a function,
// OBSOLETE    return the ip of the first instruction after the function 
// OBSOLETE    prologue.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE i960_skip_prologue (CORE_ADDR ip)
// OBSOLETE {
// OBSOLETE   struct frame_saved_regs saved_regs_dummy;
// OBSOLETE   struct symtab_and_line sal;
// OBSOLETE   CORE_ADDR limit;
// OBSOLETE 
// OBSOLETE   sal = find_pc_line (ip, 0);
// OBSOLETE   limit = (sal.end) ? sal.end : 0xffffffff;
// OBSOLETE 
// OBSOLETE   return (examine_prologue (ip, limit, (CORE_ADDR) 0, &saved_regs_dummy));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Put here the code to store, into a struct frame_saved_regs,
// OBSOLETE    the addresses of the saved registers of frame described by FRAME_INFO.
// OBSOLETE    This includes special registers such as pc and fp saved in special
// OBSOLETE    ways in the stack frame.  sp is even more special:
// OBSOLETE    the address we return for it IS the sp for the next frame.
// OBSOLETE 
// OBSOLETE    We cache the result of doing this in the frame_obstack, since it is
// OBSOLETE    fairly expensive.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE frame_find_saved_regs (struct frame_info *fi, struct frame_saved_regs *fsr)
// OBSOLETE {
// OBSOLETE   register CORE_ADDR next_addr;
// OBSOLETE   register CORE_ADDR *saved_regs;
// OBSOLETE   register int regnum;
// OBSOLETE   register struct frame_saved_regs *cache_fsr;
// OBSOLETE   CORE_ADDR ip;
// OBSOLETE   struct symtab_and_line sal;
// OBSOLETE   CORE_ADDR limit;
// OBSOLETE 
// OBSOLETE   if (!fi->fsr)
// OBSOLETE     {
// OBSOLETE       cache_fsr = (struct frame_saved_regs *)
// OBSOLETE 	frame_obstack_alloc (sizeof (struct frame_saved_regs));
// OBSOLETE       memset (cache_fsr, '\0', sizeof (struct frame_saved_regs));
// OBSOLETE       fi->fsr = cache_fsr;
// OBSOLETE 
// OBSOLETE       /* Find the start and end of the function prologue.  If the PC
// OBSOLETE          is in the function prologue, we only consider the part that
// OBSOLETE          has executed already.  */
// OBSOLETE 
// OBSOLETE       ip = get_pc_function_start (fi->pc);
// OBSOLETE       sal = find_pc_line (ip, 0);
// OBSOLETE       limit = (sal.end && sal.end < fi->pc) ? sal.end : fi->pc;
// OBSOLETE 
// OBSOLETE       examine_prologue (ip, limit, fi->frame, cache_fsr);
// OBSOLETE 
// OBSOLETE       /* Record the addresses at which the local registers are saved.
// OBSOLETE          Strictly speaking, we should only do this for non-leaf procedures,
// OBSOLETE          but no one will ever look at these values if it is a leaf procedure,
// OBSOLETE          since local registers are always caller-saved.  */
// OBSOLETE 
// OBSOLETE       next_addr = (CORE_ADDR) fi->frame;
// OBSOLETE       saved_regs = cache_fsr->regs;
// OBSOLETE       for (regnum = R0_REGNUM; regnum <= R15_REGNUM; regnum++)
// OBSOLETE 	{
// OBSOLETE 	  *saved_regs++ = next_addr;
// OBSOLETE 	  next_addr += 4;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       cache_fsr->regs[FP_REGNUM] = cache_fsr->regs[PFP_REGNUM];
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   *fsr = *fi->fsr;
// OBSOLETE 
// OBSOLETE   /* Fetch the value of the sp from memory every time, since it
// OBSOLETE      is conceivable that it has changed since the cache was flushed.  
// OBSOLETE      This unfortunately undoes much of the savings from caching the 
// OBSOLETE      saved register values.  I suggest adding an argument to 
// OBSOLETE      get_frame_saved_regs () specifying the register number we're
// OBSOLETE      interested in (or -1 for all registers).  This would be passed
// OBSOLETE      through to FRAME_FIND_SAVED_REGS (), permitting more efficient
// OBSOLETE      computation of saved register addresses (e.g., on the i960,
// OBSOLETE      we don't have to examine the prologue to find local registers). 
// OBSOLETE      -- markf@@wrs.com 
// OBSOLETE      FIXME, we don't need to refetch this, since the cache is cleared
// OBSOLETE      every time the child process is restarted.  If GDB itself
// OBSOLETE      modifies SP, it has to clear the cache by hand (does it?).  -gnu */
// OBSOLETE 
// OBSOLETE   fsr->regs[SP_REGNUM] = read_memory_integer (fsr->regs[SP_REGNUM], 4);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the address of the argument block for the frame
// OBSOLETE    described by FI.  Returns 0 if the address is unknown.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE frame_args_address (struct frame_info *fi, int must_be_correct)
// OBSOLETE {
// OBSOLETE   struct frame_saved_regs fsr;
// OBSOLETE   CORE_ADDR ap;
// OBSOLETE 
// OBSOLETE   /* If g14 was saved in the frame by the function prologue code, return
// OBSOLETE      the saved value.  If the frame is current and we are being sloppy,
// OBSOLETE      return the value of g14.  Otherwise, return zero.  */
// OBSOLETE 
// OBSOLETE   get_frame_saved_regs (fi, &fsr);
// OBSOLETE   if (fsr.regs[G14_REGNUM])
// OBSOLETE     ap = read_memory_integer (fsr.regs[G14_REGNUM], 4);
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if (must_be_correct)
// OBSOLETE 	return 0;		/* Don't cache this result */
// OBSOLETE       if (get_next_frame (fi))
// OBSOLETE 	ap = 0;
// OBSOLETE       else
// OBSOLETE 	ap = read_register (G14_REGNUM);
// OBSOLETE       if (ap == 0)
// OBSOLETE 	ap = fi->frame;
// OBSOLETE     }
// OBSOLETE   fi->arg_pointer = ap;		/* Cache it for next time */
// OBSOLETE   return ap;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the address of the return struct for the frame
// OBSOLETE    described by FI.  Returns 0 if the address is unknown.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE frame_struct_result_address (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   struct frame_saved_regs fsr;
// OBSOLETE   CORE_ADDR ap;
// OBSOLETE 
// OBSOLETE   /* If the frame is non-current, check to see if g14 was saved in the
// OBSOLETE      frame by the function prologue code; return the saved value if so,
// OBSOLETE      zero otherwise.  If the frame is current, return the value of g14.
// OBSOLETE 
// OBSOLETE      FIXME, shouldn't this use the saved value as long as we are past
// OBSOLETE      the function prologue, and only use the current value if we have
// OBSOLETE      no saved value and are at TOS?   -- gnu@@cygnus.com */
// OBSOLETE 
// OBSOLETE   if (get_next_frame (fi))
// OBSOLETE     {
// OBSOLETE       get_frame_saved_regs (fi, &fsr);
// OBSOLETE       if (fsr.regs[G13_REGNUM])
// OBSOLETE 	ap = read_memory_integer (fsr.regs[G13_REGNUM], 4);
// OBSOLETE       else
// OBSOLETE 	ap = 0;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     ap = read_register (G13_REGNUM);
// OBSOLETE 
// OBSOLETE   return ap;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return address to which the currently executing leafproc will return,
// OBSOLETE    or 0 if IP, the value of the instruction pointer from the currently
// OBSOLETE    executing function, is not in a leafproc (or if we can't tell if it
// OBSOLETE    is).
// OBSOLETE 
// OBSOLETE    Do this by finding the starting address of the routine in which IP lies.
// OBSOLETE    If the instruction there is "mov g14, gx" (where x is in [0,7]), this
// OBSOLETE    is a leafproc and the return address is in register gx.  Well, this is
// OBSOLETE    true unless the return address points at a RET instruction in the current
// OBSOLETE    procedure, which indicates that we have a 'dual entry' routine that
// OBSOLETE    has been entered through the CALL entry point.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE leafproc_return (CORE_ADDR ip)
// OBSOLETE {
// OBSOLETE   register struct minimal_symbol *msymbol;
// OBSOLETE   char *p;
// OBSOLETE   int dst;
// OBSOLETE   unsigned int insn1, insn2;
// OBSOLETE   CORE_ADDR return_addr;
// OBSOLETE 
// OBSOLETE   if ((msymbol = lookup_minimal_symbol_by_pc (ip)) != NULL)
// OBSOLETE     {
// OBSOLETE       if ((p = strchr (SYMBOL_NAME (msymbol), '.')) && STREQ (p, ".lf"))
// OBSOLETE 	{
// OBSOLETE 	  if (next_insn (SYMBOL_VALUE_ADDRESS (msymbol), &insn1, &insn2)
// OBSOLETE 	      && (insn1 & 0xff87ffff) == 0x5c80161e	/* mov g14, gx */
// OBSOLETE 	      && (dst = REG_SRCDST (insn1)) <= G0_REGNUM + 7)
// OBSOLETE 	    {
// OBSOLETE 	      /* Get the return address.  If the "mov g14, gx" 
// OBSOLETE 	         instruction hasn't been executed yet, read
// OBSOLETE 	         the return address from g14; otherwise, read it
// OBSOLETE 	         from the register into which g14 was moved.  */
// OBSOLETE 
// OBSOLETE 	      return_addr =
// OBSOLETE 		read_register ((ip == SYMBOL_VALUE_ADDRESS (msymbol))
// OBSOLETE 			       ? G14_REGNUM : dst);
// OBSOLETE 
// OBSOLETE 	      /* We know we are in a leaf procedure, but we don't know
// OBSOLETE 	         whether the caller actually did a "bal" to the ".lf"
// OBSOLETE 	         entry point, or a normal "call" to the non-leaf entry
// OBSOLETE 	         point one instruction before.  In the latter case, the
// OBSOLETE 	         return address will be the address of a "ret"
// OBSOLETE 	         instruction within the procedure itself.  We test for
// OBSOLETE 	         this below.  */
// OBSOLETE 
// OBSOLETE 	      if (!next_insn (return_addr, &insn1, &insn2)
// OBSOLETE 		  || (insn1 & 0xff000000) != 0xa000000	/* ret */
// OBSOLETE 		  || lookup_minimal_symbol_by_pc (return_addr) != msymbol)
// OBSOLETE 		return (return_addr);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Immediately after a function call, return the saved pc.
// OBSOLETE    Can't go through the frames for this because on some machines
// OBSOLETE    the new frame is not set up until the new function executes
// OBSOLETE    some instructions. 
// OBSOLETE    On the i960, the frame *is* set up immediately after the call,
// OBSOLETE    unless the function is a leaf procedure.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE saved_pc_after_call (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   CORE_ADDR saved_pc;
// OBSOLETE 
// OBSOLETE   saved_pc = leafproc_return (get_frame_pc (frame));
// OBSOLETE   if (!saved_pc)
// OBSOLETE     saved_pc = FRAME_SAVED_PC (frame);
// OBSOLETE 
// OBSOLETE   return saved_pc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Discard from the stack the innermost frame,
// OBSOLETE    restoring all saved registers.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE i960_pop_frame (void)
// OBSOLETE {
// OBSOLETE   register struct frame_info *current_fi, *prev_fi;
// OBSOLETE   register int i;
// OBSOLETE   CORE_ADDR save_addr;
// OBSOLETE   CORE_ADDR leaf_return_addr;
// OBSOLETE   struct frame_saved_regs fsr;
// OBSOLETE   char local_regs_buf[16 * 4];
// OBSOLETE 
// OBSOLETE   current_fi = get_current_frame ();
// OBSOLETE 
// OBSOLETE   /* First, undo what the hardware does when we return.
// OBSOLETE      If this is a non-leaf procedure, restore local registers from
// OBSOLETE      the save area in the calling frame.  Otherwise, load the return
// OBSOLETE      address obtained from leafproc_return () into the rip.  */
// OBSOLETE 
// OBSOLETE   leaf_return_addr = leafproc_return (current_fi->pc);
// OBSOLETE   if (!leaf_return_addr)
// OBSOLETE     {
// OBSOLETE       /* Non-leaf procedure.  Restore local registers, incl IP.  */
// OBSOLETE       prev_fi = get_prev_frame (current_fi);
// OBSOLETE       read_memory (prev_fi->frame, local_regs_buf, sizeof (local_regs_buf));
// OBSOLETE       write_register_bytes (REGISTER_BYTE (R0_REGNUM), local_regs_buf,
// OBSOLETE 			    sizeof (local_regs_buf));
// OBSOLETE 
// OBSOLETE       /* Restore frame pointer.  */
// OBSOLETE       write_register (FP_REGNUM, prev_fi->frame);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* Leaf procedure.  Just restore the return address into the IP.  */
// OBSOLETE       write_register (RIP_REGNUM, leaf_return_addr);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Now restore any global regs that the current function had saved. */
// OBSOLETE   get_frame_saved_regs (current_fi, &fsr);
// OBSOLETE   for (i = G0_REGNUM; i < G14_REGNUM; i++)
// OBSOLETE     {
// OBSOLETE       save_addr = fsr.regs[i];
// OBSOLETE       if (save_addr != 0)
// OBSOLETE 	write_register (i, read_memory_integer (save_addr, 4));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Flush the frame cache, create a frame for the new innermost frame,
// OBSOLETE      and make it the current frame.  */
// OBSOLETE 
// OBSOLETE   flush_cached_frames ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Given a 960 stop code (fault or trace), return the signal which
// OBSOLETE    corresponds.  */
// OBSOLETE 
// OBSOLETE enum target_signal
// OBSOLETE i960_fault_to_signal (int fault)
// OBSOLETE {
// OBSOLETE   switch (fault)
// OBSOLETE     {
// OBSOLETE     case 0:
// OBSOLETE       return TARGET_SIGNAL_BUS;	/* parallel fault */
// OBSOLETE     case 1:
// OBSOLETE       return TARGET_SIGNAL_UNKNOWN;
// OBSOLETE     case 2:
// OBSOLETE       return TARGET_SIGNAL_ILL;	/* operation fault */
// OBSOLETE     case 3:
// OBSOLETE       return TARGET_SIGNAL_FPE;	/* arithmetic fault */
// OBSOLETE     case 4:
// OBSOLETE       return TARGET_SIGNAL_FPE;	/* floating point fault */
// OBSOLETE 
// OBSOLETE       /* constraint fault.  This appears not to distinguish between
// OBSOLETE          a range constraint fault (which should be SIGFPE) and a privileged
// OBSOLETE          fault (which should be SIGILL).  */
// OBSOLETE     case 5:
// OBSOLETE       return TARGET_SIGNAL_ILL;
// OBSOLETE 
// OBSOLETE     case 6:
// OBSOLETE       return TARGET_SIGNAL_SEGV;	/* virtual memory fault */
// OBSOLETE 
// OBSOLETE       /* protection fault.  This is for an out-of-range argument to
// OBSOLETE          "calls".  I guess it also could be SIGILL. */
// OBSOLETE     case 7:
// OBSOLETE       return TARGET_SIGNAL_SEGV;
// OBSOLETE 
// OBSOLETE     case 8:
// OBSOLETE       return TARGET_SIGNAL_BUS;	/* machine fault */
// OBSOLETE     case 9:
// OBSOLETE       return TARGET_SIGNAL_BUS;	/* structural fault */
// OBSOLETE     case 0xa:
// OBSOLETE       return TARGET_SIGNAL_ILL;	/* type fault */
// OBSOLETE     case 0xb:
// OBSOLETE       return TARGET_SIGNAL_UNKNOWN;	/* reserved fault */
// OBSOLETE     case 0xc:
// OBSOLETE       return TARGET_SIGNAL_BUS;	/* process fault */
// OBSOLETE     case 0xd:
// OBSOLETE       return TARGET_SIGNAL_SEGV;	/* descriptor fault */
// OBSOLETE     case 0xe:
// OBSOLETE       return TARGET_SIGNAL_BUS;	/* event fault */
// OBSOLETE     case 0xf:
// OBSOLETE       return TARGET_SIGNAL_UNKNOWN;	/* reserved fault */
// OBSOLETE     case 0x10:
// OBSOLETE       return TARGET_SIGNAL_TRAP;	/* single-step trace */
// OBSOLETE     case 0x11:
// OBSOLETE       return TARGET_SIGNAL_TRAP;	/* branch trace */
// OBSOLETE     case 0x12:
// OBSOLETE       return TARGET_SIGNAL_TRAP;	/* call trace */
// OBSOLETE     case 0x13:
// OBSOLETE       return TARGET_SIGNAL_TRAP;	/* return trace */
// OBSOLETE     case 0x14:
// OBSOLETE       return TARGET_SIGNAL_TRAP;	/* pre-return trace */
// OBSOLETE     case 0x15:
// OBSOLETE       return TARGET_SIGNAL_TRAP;	/* supervisor call trace */
// OBSOLETE     case 0x16:
// OBSOLETE       return TARGET_SIGNAL_TRAP;	/* breakpoint trace */
// OBSOLETE     default:
// OBSOLETE       return TARGET_SIGNAL_UNKNOWN;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /****************************************/
// OBSOLETE /* MEM format                           */
// OBSOLETE /****************************************/
// OBSOLETE 
// OBSOLETE struct tabent
// OBSOLETE {
// OBSOLETE   char *name;
// OBSOLETE   char numops;
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* Return instruction length, either 4 or 8.  When NOPRINT is non-zero
// OBSOLETE    (TRUE), don't output any text.  (Actually, as implemented, if NOPRINT
// OBSOLETE    is 0, abort() is called.) */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE mem (unsigned long memaddr, unsigned long word1, unsigned long word2,
// OBSOLETE      int noprint)
// OBSOLETE {
// OBSOLETE   int i, j;
// OBSOLETE   int len;
// OBSOLETE   int mode;
// OBSOLETE   int offset;
// OBSOLETE   const char *reg1, *reg2, *reg3;
// OBSOLETE 
// OBSOLETE   /* This lookup table is too sparse to make it worth typing in, but not
// OBSOLETE    * so large as to make a sparse array necessary.  We allocate the
// OBSOLETE    * table at runtime, initialize all entries to empty, and copy the
// OBSOLETE    * real ones in from an initialization table.
// OBSOLETE    *
// OBSOLETE    * NOTE: In this table, the meaning of 'numops' is:
// OBSOLETE    *       1: single operand
// OBSOLETE    *       2: 2 operands, load instruction
// OBSOLETE    *      -2: 2 operands, store instruction
// OBSOLETE    */
// OBSOLETE   static struct tabent *mem_tab = NULL;
// OBSOLETE /* Opcodes of 0x8X, 9X, aX, bX, and cX must be in the table.  */
// OBSOLETE #define MEM_MIN	0x80
// OBSOLETE #define MEM_MAX	0xcf
// OBSOLETE #define MEM_SIZ	((MEM_MAX-MEM_MIN+1) * sizeof(struct tabent))
// OBSOLETE 
// OBSOLETE   static struct
// OBSOLETE     {
// OBSOLETE       int opcode;
// OBSOLETE       char *name;
// OBSOLETE       char numops;
// OBSOLETE     }
// OBSOLETE   mem_init[] =
// OBSOLETE   {
// OBSOLETE     0x80, "ldob", 2,
// OBSOLETE       0x82, "stob", -2,
// OBSOLETE       0x84, "bx", 1,
// OBSOLETE       0x85, "balx", 2,
// OBSOLETE       0x86, "callx", 1,
// OBSOLETE       0x88, "ldos", 2,
// OBSOLETE       0x8a, "stos", -2,
// OBSOLETE       0x8c, "lda", 2,
// OBSOLETE       0x90, "ld", 2,
// OBSOLETE       0x92, "st", -2,
// OBSOLETE       0x98, "ldl", 2,
// OBSOLETE       0x9a, "stl", -2,
// OBSOLETE       0xa0, "ldt", 2,
// OBSOLETE       0xa2, "stt", -2,
// OBSOLETE       0xb0, "ldq", 2,
// OBSOLETE       0xb2, "stq", -2,
// OBSOLETE       0xc0, "ldib", 2,
// OBSOLETE       0xc2, "stib", -2,
// OBSOLETE       0xc8, "ldis", 2,
// OBSOLETE       0xca, "stis", -2,
// OBSOLETE       0, NULL, 0
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE   if (mem_tab == NULL)
// OBSOLETE     {
// OBSOLETE       mem_tab = (struct tabent *) xmalloc (MEM_SIZ);
// OBSOLETE       memset (mem_tab, '\0', MEM_SIZ);
// OBSOLETE       for (i = 0; mem_init[i].opcode != 0; i++)
// OBSOLETE 	{
// OBSOLETE 	  j = mem_init[i].opcode - MEM_MIN;
// OBSOLETE 	  mem_tab[j].name = mem_init[i].name;
// OBSOLETE 	  mem_tab[j].numops = mem_init[i].numops;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   i = ((word1 >> 24) & 0xff) - MEM_MIN;
// OBSOLETE   mode = (word1 >> 10) & 0xf;
// OBSOLETE 
// OBSOLETE   if ((mem_tab[i].name != NULL)	/* Valid instruction */
// OBSOLETE       && ((mode == 5) || (mode >= 12)))
// OBSOLETE     {				/* With 32-bit displacement */
// OBSOLETE       len = 8;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       len = 4;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (noprint)
// OBSOLETE     {
// OBSOLETE       return len;
// OBSOLETE     }
// OBSOLETE   internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Read the i960 instruction at 'memaddr' and return the address of 
// OBSOLETE    the next instruction after that, or 0 if 'memaddr' is not the
// OBSOLETE    address of a valid instruction.  The first word of the instruction
// OBSOLETE    is stored at 'pword1', and the second word, if any, is stored at
// OBSOLETE    'pword2'.  */
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE next_insn (CORE_ADDR memaddr, unsigned int *pword1, unsigned int *pword2)
// OBSOLETE {
// OBSOLETE   int len;
// OBSOLETE   char buf[8];
// OBSOLETE 
// OBSOLETE   /* Read the two (potential) words of the instruction at once,
// OBSOLETE      to eliminate the overhead of two calls to read_memory ().
// OBSOLETE      FIXME: Loses if the first one is readable but the second is not
// OBSOLETE      (e.g. last word of the segment).  */
// OBSOLETE 
// OBSOLETE   read_memory (memaddr, buf, 8);
// OBSOLETE   *pword1 = extract_unsigned_integer (buf, 4);
// OBSOLETE   *pword2 = extract_unsigned_integer (buf + 4, 4);
// OBSOLETE 
// OBSOLETE   /* Divide instruction set into classes based on high 4 bits of opcode */
// OBSOLETE 
// OBSOLETE   switch ((*pword1 >> 28) & 0xf)
// OBSOLETE     {
// OBSOLETE     case 0x0:
// OBSOLETE     case 0x1:			/* ctrl */
// OBSOLETE 
// OBSOLETE     case 0x2:
// OBSOLETE     case 0x3:			/* cobr */
// OBSOLETE 
// OBSOLETE     case 0x5:
// OBSOLETE     case 0x6:
// OBSOLETE     case 0x7:			/* reg */
// OBSOLETE       len = 4;
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case 0x8:
// OBSOLETE     case 0x9:
// OBSOLETE     case 0xa:
// OBSOLETE     case 0xb:
// OBSOLETE     case 0xc:
// OBSOLETE       len = mem (memaddr, *pword1, *pword2, 1);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     default:			/* invalid instruction */
// OBSOLETE       len = 0;
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (len)
// OBSOLETE     return memaddr + len;
// OBSOLETE   else
// OBSOLETE     return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* 'start_frame' is a variable in the MON960 runtime startup routine
// OBSOLETE    that contains the frame pointer of the 'start' routine (the routine
// OBSOLETE    that calls 'main').  By reading its contents out of remote memory,
// OBSOLETE    we can tell where the frame chain ends:  backtraces should halt before
// OBSOLETE    they display this frame.  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE mon960_frame_chain_valid (CORE_ADDR chain, struct frame_info *curframe)
// OBSOLETE {
// OBSOLETE   struct symbol *sym;
// OBSOLETE   struct minimal_symbol *msymbol;
// OBSOLETE 
// OBSOLETE   /* crtmon960.o is an assembler module that is assumed to be linked
// OBSOLETE    * first in an i80960 executable.  It contains the true entry point;
// OBSOLETE    * it performs startup up initialization and then calls 'main'.
// OBSOLETE    *
// OBSOLETE    * 'sf' is the name of a variable in crtmon960.o that is set
// OBSOLETE    *      during startup to the address of the first frame.
// OBSOLETE    *
// OBSOLETE    * 'a' is the address of that variable in 80960 memory.
// OBSOLETE    */
// OBSOLETE   static char sf[] = "start_frame";
// OBSOLETE   CORE_ADDR a;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   chain &= ~0x3f;		/* Zero low 6 bits because previous frame pointers
// OBSOLETE 				   contain return status info in them.  */
// OBSOLETE   if (chain == 0)
// OBSOLETE     {
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   sym = lookup_symbol (sf, 0, VAR_NAMESPACE, (int *) NULL,
// OBSOLETE 		       (struct symtab **) NULL);
// OBSOLETE   if (sym != 0)
// OBSOLETE     {
// OBSOLETE       a = SYMBOL_VALUE (sym);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       msymbol = lookup_minimal_symbol (sf, NULL, NULL);
// OBSOLETE       if (msymbol == NULL)
// OBSOLETE 	return 0;
// OBSOLETE       a = SYMBOL_VALUE_ADDRESS (msymbol);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return (chain != read_memory_integer (a, 4));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_i960_tdep (void)
// OBSOLETE {
// OBSOLETE   check_host ();
// OBSOLETE 
// OBSOLETE   tm_print_insn = print_insn_i960;
// OBSOLETE }
@


1.12
log
@Obsolete i960.
@
text
@@


1.12.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.12.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.11
log
@2002-07-30  Andrew Cagney  <ac131313@@redhat.com>

* symtab.h: Replace #include "gdb_obstack.h" with opaque
declaration.
* cli/cli-cmds.c, cli/cli-script.c: Include "gdb_string.h".
* gnu-v3-abi.c, arc-tdep.c, cli/cli-decode.c: Ditto.
* avr-tdep.c, mon960-rom.c, i960-tdep.c: Ditto.
* arch-utils.c, cli/cli-setshow.c: Unconditionally include
"gdb_string.h".
* Makefile.in (cli-script.o, cli-cmds.o): Update dependencies.
(gnu-v3-abi.o, cli-setshow.o, i960-tdep.o): Ditto.
(cli-decode.o, mi-cmd-var.o, mi-cmd-disas.o): Ditto.
(avr-tdep.o, mon960-rom.o): Ditto.
(aout_stabs_gnu_h): Define.
(symtab_h): Remove $(gdb_obstack_h).
@
text
@d1 1056
a1056 1056
/* Target-machine dependent code for the Intel 960

   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2001, 2002 Free Software Foundation, Inc.

   Contributed by Intel Corporation.
   examine_prologue and other parts contributed by Wind River Systems.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "symtab.h"
#include "value.h"
#include "frame.h"
#include "floatformat.h"
#include "target.h"
#include "gdbcore.h"
#include "inferior.h"
#include "regcache.h"
#include "gdb_string.h"

static CORE_ADDR next_insn (CORE_ADDR memaddr,
			    unsigned int *pword1, unsigned int *pword2);

struct type *
i960_register_type (int regnum)
{
  if (regnum < FP0_REGNUM)
    return builtin_type_int32;
  else
    return builtin_type_i960_ext;
}


/* Does the specified function use the "struct returning" convention
   or the "value returning" convention?  The "value returning" convention
   almost invariably returns the entire value in registers.  The
   "struct returning" convention often returns the entire value in
   memory, and passes a pointer (out of or into the function) saying
   where the value (is or should go).

   Since this sometimes depends on whether it was compiled with GCC,
   this is also an argument.  This is used in call_function to build a
   stack, and in value_being_returned to print return values.

   On i960, a structure is returned in registers g0-g3, if it will fit.
   If it's more than 16 bytes long, g13 pointed to it on entry.  */

int
i960_use_struct_convention (int gcc_p, struct type *type)
{
  return (TYPE_LENGTH (type) > 16);
}

/* gdb960 is always running on a non-960 host.  Check its characteristics.
   This routine must be called as part of gdb initialization.  */

static void
check_host (void)
{
  int i;

  static struct typestruct
    {
      int hostsize;		/* Size of type on host         */
      int i960size;		/* Size of type on i960         */
      char *typename;		/* Name of type, for error msg  */
    }
  types[] =
  {
    {
      sizeof (short), 2, "short"
    }
     ,
    {
      sizeof (int), 4, "int"
    }
     ,
    {
      sizeof (long), 4, "long"
    }
     ,
    {
      sizeof (float), 4, "float"
    }
     ,
    {
      sizeof (double), 8, "double"
    }
     ,
    {
      sizeof (char *), 4, "pointer"
    }
     ,
  };
#define TYPELEN	(sizeof(types) / sizeof(struct typestruct))

  /* Make sure that host type sizes are same as i960
   */
  for (i = 0; i < TYPELEN; i++)
    {
      if (types[i].hostsize != types[i].i960size)
	{
	  printf_unfiltered ("sizeof(%s) != %d:  PROCEED AT YOUR OWN RISK!\n",
			     types[i].typename, types[i].i960size);
	}

    }
}

/* Is this register part of the register window system?  A yes answer
   implies that 1) The name of this register will not be the same in
   other frames, and 2) This register is automatically "saved" upon
   subroutine calls and thus there is no need to search more than one
   stack frame for it.

   On the i960, in fact, the name of this register in another frame is
   "mud" -- there is no overlap between the windows.  Each window is
   simply saved into the stack (true for our purposes, after having been
   flushed; normally they reside on-chip and are restored from on-chip
   without ever going to memory).  */

static int
register_in_window_p (int regnum)
{
  return regnum <= R15_REGNUM;
}

/* i960_find_saved_register ()

   Return the address in which frame FRAME's value of register REGNUM
   has been saved in memory.  Or return zero if it has not been saved.
   If REGNUM specifies the SP, the value we return is actually the SP
   value, not an address where it was saved.  */

static CORE_ADDR
i960_find_saved_register (struct frame_info *frame, int regnum)
{
  register struct frame_info *frame1 = NULL;
  register CORE_ADDR addr = 0;

  if (frame == NULL)		/* No regs saved if want current frame */
    return 0;

  /* We assume that a register in a register window will only be saved
     in one place (since the name changes and/or disappears as you go
     towards inner frames), so we only call get_frame_saved_regs on
     the current frame.  This is directly in contradiction to the
     usage below, which assumes that registers used in a frame must be
     saved in a lower (more interior) frame.  This change is a result
     of working on a register window machine; get_frame_saved_regs
     always returns the registers saved within a frame, within the
     context (register namespace) of that frame. */

  /* However, note that we don't want this to return anything if
     nothing is saved (if there's a frame inside of this one).  Also,
     callers to this routine asking for the stack pointer want the
     stack pointer saved for *this* frame; this is returned from the
     next frame.  */

  if (register_in_window_p (regnum))
    {
      frame1 = get_next_frame (frame);
      if (!frame1)
	return 0;		/* Registers of this frame are active.  */

      /* Get the SP from the next frame in; it will be this
         current frame.  */
      if (regnum != SP_REGNUM)
	frame1 = frame;

      FRAME_INIT_SAVED_REGS (frame1);
      return frame1->saved_regs[regnum];	/* ... which might be zero */
    }

  /* Note that this next routine assumes that registers used in
     frame x will be saved only in the frame that x calls and
     frames interior to it.  This is not true on the sparc, but the
     above macro takes care of it, so we should be all right. */
  while (1)
    {
      QUIT;
      frame1 = get_next_frame (frame);
      if (frame1 == 0)
	break;
      frame = frame1;
      FRAME_INIT_SAVED_REGS (frame1);
      if (frame1->saved_regs[regnum])
	addr = frame1->saved_regs[regnum];
    }

  return addr;
}

/* i960_get_saved_register ()

   Find register number REGNUM relative to FRAME and put its (raw,
   target format) contents in *RAW_BUFFER.  Set *OPTIMIZED if the
   variable was optimized out (and thus can't be fetched).  Set *LVAL
   to lval_memory, lval_register, or not_lval, depending on whether
   the value was fetched from memory, from a register, or in a strange
   and non-modifiable way (e.g. a frame pointer which was calculated
   rather than fetched).  Set *ADDRP to the address, either in memory
   on as a REGISTER_BYTE offset into the registers array.

   Note that this implementation never sets *LVAL to not_lval.  But it
   can be replaced by defining GET_SAVED_REGISTER and supplying your
   own.

   The argument RAW_BUFFER must point to aligned memory.  */

void
i960_get_saved_register (char *raw_buffer,
			 int *optimized,
			 CORE_ADDR *addrp,
			 struct frame_info *frame,
			 int regnum,
			 enum lval_type *lval)
{
  CORE_ADDR addr;

  if (!target_has_registers)
    error ("No registers.");

  /* Normal systems don't optimize out things with register numbers.  */
  if (optimized != NULL)
    *optimized = 0;
  addr = i960_find_saved_register (frame, regnum);
  if (addr != 0)
    {
      if (lval != NULL)
	*lval = lval_memory;
      if (regnum == SP_REGNUM)
	{
	  if (raw_buffer != NULL)
	    {
	      /* Put it back in target format.  */
	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum),
			     (LONGEST) addr);
	    }
	  if (addrp != NULL)
	    *addrp = 0;
	  return;
	}
      if (raw_buffer != NULL)
	target_read_memory (addr, raw_buffer, REGISTER_RAW_SIZE (regnum));
    }
  else
    {
      if (lval != NULL)
	*lval = lval_register;
      addr = REGISTER_BYTE (regnum);
      if (raw_buffer != NULL)
	read_register_gen (regnum, raw_buffer);
    }
  if (addrp != NULL)
    *addrp = addr;
}

/* Examine an i960 function prologue, recording the addresses at which
   registers are saved explicitly by the prologue code, and returning
   the address of the first instruction after the prologue (but not
   after the instruction at address LIMIT, as explained below).

   LIMIT places an upper bound on addresses of the instructions to be
   examined.  If the prologue code scan reaches LIMIT, the scan is
   aborted and LIMIT is returned.  This is used, when examining the
   prologue for the current frame, to keep examine_prologue () from
   claiming that a given register has been saved when in fact the
   instruction that saves it has not yet been executed.  LIMIT is used
   at other times to stop the scan when we hit code after the true
   function prologue (e.g. for the first source line) which might
   otherwise be mistaken for function prologue.

   The format of the function prologue matched by this routine is
   derived from examination of the source to gcc960 1.21, particularly
   the routine i960_function_prologue ().  A "regular expression" for
   the function prologue is given below:

   (lda LRn, g14
   mov g14, g[0-7]
   (mov 0, g14) | (lda 0, g14))?

   (mov[qtl]? g[0-15], r[4-15])*
   ((addo [1-31], sp, sp) | (lda n(sp), sp))?
   (st[qtl]? g[0-15], n(fp))*

   (cmpobne 0, g14, LFn
   mov sp, g14
   lda 0x30(sp), sp
   LFn: stq g0, (g14)
   stq g4, 0x10(g14)
   stq g8, 0x20(g14))?

   (st g14, n(fp))?
   (mov g13,r[4-15])?
 */

/* Macros for extracting fields from i960 instructions.  */

#define BITMASK(pos, width) (((0x1 << (width)) - 1) << (pos))
#define EXTRACT_FIELD(val, pos, width) ((val) >> (pos) & BITMASK (0, width))

#define REG_SRC1(insn)    EXTRACT_FIELD (insn, 0, 5)
#define REG_SRC2(insn)    EXTRACT_FIELD (insn, 14, 5)
#define REG_SRCDST(insn)  EXTRACT_FIELD (insn, 19, 5)
#define MEM_SRCDST(insn)  EXTRACT_FIELD (insn, 19, 5)
#define MEMA_OFFSET(insn) EXTRACT_FIELD (insn, 0, 12)

/* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or
   is not the address of a valid instruction, the address of the next
   instruction beyond ADDR otherwise.  *PWORD1 receives the first word
   of the instruction, and (for two-word instructions), *PWORD2 receives
   the second.  */

#define NEXT_PROLOGUE_INSN(addr, lim, pword1, pword2) \
  (((addr) < (lim)) ? next_insn (addr, pword1, pword2) : 0)

static CORE_ADDR
examine_prologue (register CORE_ADDR ip, register CORE_ADDR limit,
		  CORE_ADDR frame_addr, struct frame_saved_regs *fsr)
{
  register CORE_ADDR next_ip;
  register int src, dst;
  register unsigned int *pcode;
  unsigned int insn1, insn2;
  int size;
  int within_leaf_prologue;
  CORE_ADDR save_addr;
  static unsigned int varargs_prologue_code[] =
  {
    0x3507a00c,			/* cmpobne 0x0, g14, LFn */
    0x5cf01601,			/* mov sp, g14           */
    0x8c086030,			/* lda 0x30(sp), sp      */
    0xb2879000,			/* LFn: stq  g0, (g14)   */
    0xb2a7a010,			/* stq g4, 0x10(g14)     */
    0xb2c7a020			/* stq g8, 0x20(g14)     */
  };

  /* Accept a leaf procedure prologue code fragment if present.
     Note that ip might point to either the leaf or non-leaf
     entry point; we look for the non-leaf entry point first:  */

  within_leaf_prologue = 0;
  if ((next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2))
      && ((insn1 & 0xfffff000) == 0x8cf00000	/* lda LRx, g14 (MEMA) */
	  || (insn1 & 0xfffffc60) == 0x8cf03000))	/* lda LRx, g14 (MEMB) */
    {
      within_leaf_prologue = 1;
      next_ip = NEXT_PROLOGUE_INSN (next_ip, limit, &insn1, &insn2);
    }

  /* Now look for the prologue code at a leaf entry point:  */

  if (next_ip
      && (insn1 & 0xff87ffff) == 0x5c80161e	/* mov g14, gx */
      && REG_SRCDST (insn1) <= G0_REGNUM + 7)
    {
      within_leaf_prologue = 1;
      if ((next_ip = NEXT_PROLOGUE_INSN (next_ip, limit, &insn1, &insn2))
	  && (insn1 == 0x8cf00000	/* lda 0, g14 */
	      || insn1 == 0x5cf01e00))	/* mov 0, g14 */
	{
	  ip = next_ip;
	  next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
	  within_leaf_prologue = 0;
	}
    }

  /* If something that looks like the beginning of a leaf prologue
     has been seen, but the remainder of the prologue is missing, bail.
     We don't know what we've got.  */

  if (within_leaf_prologue)
    return (ip);

  /* Accept zero or more instances of "mov[qtl]? gx, ry", where y >= 4.
     This may cause us to mistake the moving of a register
     parameter to a local register for the saving of a callee-saved
     register, but that can't be helped, since with the
     "-fcall-saved" flag, any register can be made callee-saved.  */

  while (next_ip
	 && (insn1 & 0xfc802fb0) == 0x5c000610
	 && (dst = REG_SRCDST (insn1)) >= (R0_REGNUM + 4))
    {
      src = REG_SRC1 (insn1);
      size = EXTRACT_FIELD (insn1, 24, 2) + 1;
      save_addr = frame_addr + ((dst - R0_REGNUM) * 4);
      while (size--)
	{
	  fsr->regs[src++] = save_addr;
	  save_addr += 4;
	}
      ip = next_ip;
      next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
    }

  /* Accept an optional "addo n, sp, sp" or "lda n(sp), sp".  */

  if (next_ip &&
      ((insn1 & 0xffffffe0) == 0x59084800	/* addo n, sp, sp */
       || (insn1 & 0xfffff000) == 0x8c086000	/* lda n(sp), sp (MEMA) */
       || (insn1 & 0xfffffc60) == 0x8c087400))	/* lda n(sp), sp (MEMB) */
    {
      ip = next_ip;
      next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
    }

  /* Accept zero or more instances of "st[qtl]? gx, n(fp)".  
     This may cause us to mistake the copying of a register
     parameter to the frame for the saving of a callee-saved
     register, but that can't be helped, since with the
     "-fcall-saved" flag, any register can be made callee-saved.
     We can, however, refuse to accept a save of register g14,
     since that is matched explicitly below.  */

  while (next_ip &&
	 ((insn1 & 0xf787f000) == 0x9287e000	/* stl? gx, n(fp) (MEMA) */
	  || (insn1 & 0xf787fc60) == 0x9287f400		/* stl? gx, n(fp) (MEMB) */
	  || (insn1 & 0xef87f000) == 0xa287e000		/* st[tq] gx, n(fp) (MEMA) */
	  || (insn1 & 0xef87fc60) == 0xa287f400)	/* st[tq] gx, n(fp) (MEMB) */
	 && ((src = MEM_SRCDST (insn1)) != G14_REGNUM))
    {
      save_addr = frame_addr + ((insn1 & BITMASK (12, 1))
				? insn2 : MEMA_OFFSET (insn1));
      size = (insn1 & BITMASK (29, 1)) ? ((insn1 & BITMASK (28, 1)) ? 4 : 3)
	: ((insn1 & BITMASK (27, 1)) ? 2 : 1);
      while (size--)
	{
	  fsr->regs[src++] = save_addr;
	  save_addr += 4;
	}
      ip = next_ip;
      next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
    }

  /* Accept the varargs prologue code if present.  */

  size = sizeof (varargs_prologue_code) / sizeof (int);
  pcode = varargs_prologue_code;
  while (size-- && next_ip && *pcode++ == insn1)
    {
      ip = next_ip;
      next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
    }

  /* Accept an optional "st g14, n(fp)".  */

  if (next_ip &&
      ((insn1 & 0xfffff000) == 0x92f7e000	/* st g14, n(fp) (MEMA) */
       || (insn1 & 0xfffffc60) == 0x92f7f400))	/* st g14, n(fp) (MEMB) */
    {
      fsr->regs[G14_REGNUM] = frame_addr + ((insn1 & BITMASK (12, 1))
					    ? insn2 : MEMA_OFFSET (insn1));
      ip = next_ip;
      next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
    }

  /* Accept zero or one instance of "mov g13, ry", where y >= 4.
     This is saving the address where a struct should be returned.  */

  if (next_ip
      && (insn1 & 0xff802fbf) == 0x5c00061d
      && (dst = REG_SRCDST (insn1)) >= (R0_REGNUM + 4))
    {
      save_addr = frame_addr + ((dst - R0_REGNUM) * 4);
      fsr->regs[G0_REGNUM + 13] = save_addr;
      ip = next_ip;
#if 0				/* We'll need this once there is a subsequent instruction examined. */
      next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
#endif
    }

  return (ip);
}

/* Given an ip value corresponding to the start of a function,
   return the ip of the first instruction after the function 
   prologue.  */

CORE_ADDR
i960_skip_prologue (CORE_ADDR ip)
{
  struct frame_saved_regs saved_regs_dummy;
  struct symtab_and_line sal;
  CORE_ADDR limit;

  sal = find_pc_line (ip, 0);
  limit = (sal.end) ? sal.end : 0xffffffff;

  return (examine_prologue (ip, limit, (CORE_ADDR) 0, &saved_regs_dummy));
}

/* Put here the code to store, into a struct frame_saved_regs,
   the addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.

   We cache the result of doing this in the frame_obstack, since it is
   fairly expensive.  */

void
frame_find_saved_regs (struct frame_info *fi, struct frame_saved_regs *fsr)
{
  register CORE_ADDR next_addr;
  register CORE_ADDR *saved_regs;
  register int regnum;
  register struct frame_saved_regs *cache_fsr;
  CORE_ADDR ip;
  struct symtab_and_line sal;
  CORE_ADDR limit;

  if (!fi->fsr)
    {
      cache_fsr = (struct frame_saved_regs *)
	frame_obstack_alloc (sizeof (struct frame_saved_regs));
      memset (cache_fsr, '\0', sizeof (struct frame_saved_regs));
      fi->fsr = cache_fsr;

      /* Find the start and end of the function prologue.  If the PC
         is in the function prologue, we only consider the part that
         has executed already.  */

      ip = get_pc_function_start (fi->pc);
      sal = find_pc_line (ip, 0);
      limit = (sal.end && sal.end < fi->pc) ? sal.end : fi->pc;

      examine_prologue (ip, limit, fi->frame, cache_fsr);

      /* Record the addresses at which the local registers are saved.
         Strictly speaking, we should only do this for non-leaf procedures,
         but no one will ever look at these values if it is a leaf procedure,
         since local registers are always caller-saved.  */

      next_addr = (CORE_ADDR) fi->frame;
      saved_regs = cache_fsr->regs;
      for (regnum = R0_REGNUM; regnum <= R15_REGNUM; regnum++)
	{
	  *saved_regs++ = next_addr;
	  next_addr += 4;
	}

      cache_fsr->regs[FP_REGNUM] = cache_fsr->regs[PFP_REGNUM];
    }

  *fsr = *fi->fsr;

  /* Fetch the value of the sp from memory every time, since it
     is conceivable that it has changed since the cache was flushed.  
     This unfortunately undoes much of the savings from caching the 
     saved register values.  I suggest adding an argument to 
     get_frame_saved_regs () specifying the register number we're
     interested in (or -1 for all registers).  This would be passed
     through to FRAME_FIND_SAVED_REGS (), permitting more efficient
     computation of saved register addresses (e.g., on the i960,
     we don't have to examine the prologue to find local registers). 
     -- markf@@wrs.com 
     FIXME, we don't need to refetch this, since the cache is cleared
     every time the child process is restarted.  If GDB itself
     modifies SP, it has to clear the cache by hand (does it?).  -gnu */

  fsr->regs[SP_REGNUM] = read_memory_integer (fsr->regs[SP_REGNUM], 4);
}

/* Return the address of the argument block for the frame
   described by FI.  Returns 0 if the address is unknown.  */

CORE_ADDR
frame_args_address (struct frame_info *fi, int must_be_correct)
{
  struct frame_saved_regs fsr;
  CORE_ADDR ap;

  /* If g14 was saved in the frame by the function prologue code, return
     the saved value.  If the frame is current and we are being sloppy,
     return the value of g14.  Otherwise, return zero.  */

  get_frame_saved_regs (fi, &fsr);
  if (fsr.regs[G14_REGNUM])
    ap = read_memory_integer (fsr.regs[G14_REGNUM], 4);
  else
    {
      if (must_be_correct)
	return 0;		/* Don't cache this result */
      if (get_next_frame (fi))
	ap = 0;
      else
	ap = read_register (G14_REGNUM);
      if (ap == 0)
	ap = fi->frame;
    }
  fi->arg_pointer = ap;		/* Cache it for next time */
  return ap;
}

/* Return the address of the return struct for the frame
   described by FI.  Returns 0 if the address is unknown.  */

CORE_ADDR
frame_struct_result_address (struct frame_info *fi)
{
  struct frame_saved_regs fsr;
  CORE_ADDR ap;

  /* If the frame is non-current, check to see if g14 was saved in the
     frame by the function prologue code; return the saved value if so,
     zero otherwise.  If the frame is current, return the value of g14.

     FIXME, shouldn't this use the saved value as long as we are past
     the function prologue, and only use the current value if we have
     no saved value and are at TOS?   -- gnu@@cygnus.com */

  if (get_next_frame (fi))
    {
      get_frame_saved_regs (fi, &fsr);
      if (fsr.regs[G13_REGNUM])
	ap = read_memory_integer (fsr.regs[G13_REGNUM], 4);
      else
	ap = 0;
    }
  else
    ap = read_register (G13_REGNUM);

  return ap;
}

/* Return address to which the currently executing leafproc will return,
   or 0 if IP, the value of the instruction pointer from the currently
   executing function, is not in a leafproc (or if we can't tell if it
   is).

   Do this by finding the starting address of the routine in which IP lies.
   If the instruction there is "mov g14, gx" (where x is in [0,7]), this
   is a leafproc and the return address is in register gx.  Well, this is
   true unless the return address points at a RET instruction in the current
   procedure, which indicates that we have a 'dual entry' routine that
   has been entered through the CALL entry point.  */

CORE_ADDR
leafproc_return (CORE_ADDR ip)
{
  register struct minimal_symbol *msymbol;
  char *p;
  int dst;
  unsigned int insn1, insn2;
  CORE_ADDR return_addr;

  if ((msymbol = lookup_minimal_symbol_by_pc (ip)) != NULL)
    {
      if ((p = strchr (SYMBOL_NAME (msymbol), '.')) && STREQ (p, ".lf"))
	{
	  if (next_insn (SYMBOL_VALUE_ADDRESS (msymbol), &insn1, &insn2)
	      && (insn1 & 0xff87ffff) == 0x5c80161e	/* mov g14, gx */
	      && (dst = REG_SRCDST (insn1)) <= G0_REGNUM + 7)
	    {
	      /* Get the return address.  If the "mov g14, gx" 
	         instruction hasn't been executed yet, read
	         the return address from g14; otherwise, read it
	         from the register into which g14 was moved.  */

	      return_addr =
		read_register ((ip == SYMBOL_VALUE_ADDRESS (msymbol))
			       ? G14_REGNUM : dst);

	      /* We know we are in a leaf procedure, but we don't know
	         whether the caller actually did a "bal" to the ".lf"
	         entry point, or a normal "call" to the non-leaf entry
	         point one instruction before.  In the latter case, the
	         return address will be the address of a "ret"
	         instruction within the procedure itself.  We test for
	         this below.  */

	      if (!next_insn (return_addr, &insn1, &insn2)
		  || (insn1 & 0xff000000) != 0xa000000	/* ret */
		  || lookup_minimal_symbol_by_pc (return_addr) != msymbol)
		return (return_addr);
	    }
	}
    }

  return (0);
}

/* Immediately after a function call, return the saved pc.
   Can't go through the frames for this because on some machines
   the new frame is not set up until the new function executes
   some instructions. 
   On the i960, the frame *is* set up immediately after the call,
   unless the function is a leaf procedure.  */

CORE_ADDR
saved_pc_after_call (struct frame_info *frame)
{
  CORE_ADDR saved_pc;

  saved_pc = leafproc_return (get_frame_pc (frame));
  if (!saved_pc)
    saved_pc = FRAME_SAVED_PC (frame);

  return saved_pc;
}

/* Discard from the stack the innermost frame,
   restoring all saved registers.  */

void
i960_pop_frame (void)
{
  register struct frame_info *current_fi, *prev_fi;
  register int i;
  CORE_ADDR save_addr;
  CORE_ADDR leaf_return_addr;
  struct frame_saved_regs fsr;
  char local_regs_buf[16 * 4];

  current_fi = get_current_frame ();

  /* First, undo what the hardware does when we return.
     If this is a non-leaf procedure, restore local registers from
     the save area in the calling frame.  Otherwise, load the return
     address obtained from leafproc_return () into the rip.  */

  leaf_return_addr = leafproc_return (current_fi->pc);
  if (!leaf_return_addr)
    {
      /* Non-leaf procedure.  Restore local registers, incl IP.  */
      prev_fi = get_prev_frame (current_fi);
      read_memory (prev_fi->frame, local_regs_buf, sizeof (local_regs_buf));
      write_register_bytes (REGISTER_BYTE (R0_REGNUM), local_regs_buf,
			    sizeof (local_regs_buf));

      /* Restore frame pointer.  */
      write_register (FP_REGNUM, prev_fi->frame);
    }
  else
    {
      /* Leaf procedure.  Just restore the return address into the IP.  */
      write_register (RIP_REGNUM, leaf_return_addr);
    }

  /* Now restore any global regs that the current function had saved. */
  get_frame_saved_regs (current_fi, &fsr);
  for (i = G0_REGNUM; i < G14_REGNUM; i++)
    {
      save_addr = fsr.regs[i];
      if (save_addr != 0)
	write_register (i, read_memory_integer (save_addr, 4));
    }

  /* Flush the frame cache, create a frame for the new innermost frame,
     and make it the current frame.  */

  flush_cached_frames ();
}

/* Given a 960 stop code (fault or trace), return the signal which
   corresponds.  */

enum target_signal
i960_fault_to_signal (int fault)
{
  switch (fault)
    {
    case 0:
      return TARGET_SIGNAL_BUS;	/* parallel fault */
    case 1:
      return TARGET_SIGNAL_UNKNOWN;
    case 2:
      return TARGET_SIGNAL_ILL;	/* operation fault */
    case 3:
      return TARGET_SIGNAL_FPE;	/* arithmetic fault */
    case 4:
      return TARGET_SIGNAL_FPE;	/* floating point fault */

      /* constraint fault.  This appears not to distinguish between
         a range constraint fault (which should be SIGFPE) and a privileged
         fault (which should be SIGILL).  */
    case 5:
      return TARGET_SIGNAL_ILL;

    case 6:
      return TARGET_SIGNAL_SEGV;	/* virtual memory fault */

      /* protection fault.  This is for an out-of-range argument to
         "calls".  I guess it also could be SIGILL. */
    case 7:
      return TARGET_SIGNAL_SEGV;

    case 8:
      return TARGET_SIGNAL_BUS;	/* machine fault */
    case 9:
      return TARGET_SIGNAL_BUS;	/* structural fault */
    case 0xa:
      return TARGET_SIGNAL_ILL;	/* type fault */
    case 0xb:
      return TARGET_SIGNAL_UNKNOWN;	/* reserved fault */
    case 0xc:
      return TARGET_SIGNAL_BUS;	/* process fault */
    case 0xd:
      return TARGET_SIGNAL_SEGV;	/* descriptor fault */
    case 0xe:
      return TARGET_SIGNAL_BUS;	/* event fault */
    case 0xf:
      return TARGET_SIGNAL_UNKNOWN;	/* reserved fault */
    case 0x10:
      return TARGET_SIGNAL_TRAP;	/* single-step trace */
    case 0x11:
      return TARGET_SIGNAL_TRAP;	/* branch trace */
    case 0x12:
      return TARGET_SIGNAL_TRAP;	/* call trace */
    case 0x13:
      return TARGET_SIGNAL_TRAP;	/* return trace */
    case 0x14:
      return TARGET_SIGNAL_TRAP;	/* pre-return trace */
    case 0x15:
      return TARGET_SIGNAL_TRAP;	/* supervisor call trace */
    case 0x16:
      return TARGET_SIGNAL_TRAP;	/* breakpoint trace */
    default:
      return TARGET_SIGNAL_UNKNOWN;
    }
}

/****************************************/
/* MEM format                           */
/****************************************/

struct tabent
{
  char *name;
  char numops;
};

/* Return instruction length, either 4 or 8.  When NOPRINT is non-zero
   (TRUE), don't output any text.  (Actually, as implemented, if NOPRINT
   is 0, abort() is called.) */

static int
mem (unsigned long memaddr, unsigned long word1, unsigned long word2,
     int noprint)
{
  int i, j;
  int len;
  int mode;
  int offset;
  const char *reg1, *reg2, *reg3;

  /* This lookup table is too sparse to make it worth typing in, but not
   * so large as to make a sparse array necessary.  We allocate the
   * table at runtime, initialize all entries to empty, and copy the
   * real ones in from an initialization table.
   *
   * NOTE: In this table, the meaning of 'numops' is:
   *       1: single operand
   *       2: 2 operands, load instruction
   *      -2: 2 operands, store instruction
   */
  static struct tabent *mem_tab = NULL;
/* Opcodes of 0x8X, 9X, aX, bX, and cX must be in the table.  */
#define MEM_MIN	0x80
#define MEM_MAX	0xcf
#define MEM_SIZ	((MEM_MAX-MEM_MIN+1) * sizeof(struct tabent))

  static struct
    {
      int opcode;
      char *name;
      char numops;
    }
  mem_init[] =
  {
    0x80, "ldob", 2,
      0x82, "stob", -2,
      0x84, "bx", 1,
      0x85, "balx", 2,
      0x86, "callx", 1,
      0x88, "ldos", 2,
      0x8a, "stos", -2,
      0x8c, "lda", 2,
      0x90, "ld", 2,
      0x92, "st", -2,
      0x98, "ldl", 2,
      0x9a, "stl", -2,
      0xa0, "ldt", 2,
      0xa2, "stt", -2,
      0xb0, "ldq", 2,
      0xb2, "stq", -2,
      0xc0, "ldib", 2,
      0xc2, "stib", -2,
      0xc8, "ldis", 2,
      0xca, "stis", -2,
      0, NULL, 0
  };

  if (mem_tab == NULL)
    {
      mem_tab = (struct tabent *) xmalloc (MEM_SIZ);
      memset (mem_tab, '\0', MEM_SIZ);
      for (i = 0; mem_init[i].opcode != 0; i++)
	{
	  j = mem_init[i].opcode - MEM_MIN;
	  mem_tab[j].name = mem_init[i].name;
	  mem_tab[j].numops = mem_init[i].numops;
	}
    }

  i = ((word1 >> 24) & 0xff) - MEM_MIN;
  mode = (word1 >> 10) & 0xf;

  if ((mem_tab[i].name != NULL)	/* Valid instruction */
      && ((mode == 5) || (mode >= 12)))
    {				/* With 32-bit displacement */
      len = 8;
    }
  else
    {
      len = 4;
    }

  if (noprint)
    {
      return len;
    }
  internal_error (__FILE__, __LINE__, "failed internal consistency check");
}

/* Read the i960 instruction at 'memaddr' and return the address of 
   the next instruction after that, or 0 if 'memaddr' is not the
   address of a valid instruction.  The first word of the instruction
   is stored at 'pword1', and the second word, if any, is stored at
   'pword2'.  */

static CORE_ADDR
next_insn (CORE_ADDR memaddr, unsigned int *pword1, unsigned int *pword2)
{
  int len;
  char buf[8];

  /* Read the two (potential) words of the instruction at once,
     to eliminate the overhead of two calls to read_memory ().
     FIXME: Loses if the first one is readable but the second is not
     (e.g. last word of the segment).  */

  read_memory (memaddr, buf, 8);
  *pword1 = extract_unsigned_integer (buf, 4);
  *pword2 = extract_unsigned_integer (buf + 4, 4);

  /* Divide instruction set into classes based on high 4 bits of opcode */

  switch ((*pword1 >> 28) & 0xf)
    {
    case 0x0:
    case 0x1:			/* ctrl */

    case 0x2:
    case 0x3:			/* cobr */

    case 0x5:
    case 0x6:
    case 0x7:			/* reg */
      len = 4;
      break;

    case 0x8:
    case 0x9:
    case 0xa:
    case 0xb:
    case 0xc:
      len = mem (memaddr, *pword1, *pword2, 1);
      break;

    default:			/* invalid instruction */
      len = 0;
      break;
    }

  if (len)
    return memaddr + len;
  else
    return 0;
}

/* 'start_frame' is a variable in the MON960 runtime startup routine
   that contains the frame pointer of the 'start' routine (the routine
   that calls 'main').  By reading its contents out of remote memory,
   we can tell where the frame chain ends:  backtraces should halt before
   they display this frame.  */

int
mon960_frame_chain_valid (CORE_ADDR chain, struct frame_info *curframe)
{
  struct symbol *sym;
  struct minimal_symbol *msymbol;

  /* crtmon960.o is an assembler module that is assumed to be linked
   * first in an i80960 executable.  It contains the true entry point;
   * it performs startup up initialization and then calls 'main'.
   *
   * 'sf' is the name of a variable in crtmon960.o that is set
   *      during startup to the address of the first frame.
   *
   * 'a' is the address of that variable in 80960 memory.
   */
  static char sf[] = "start_frame";
  CORE_ADDR a;


  chain &= ~0x3f;		/* Zero low 6 bits because previous frame pointers
				   contain return status info in them.  */
  if (chain == 0)
    {
      return 0;
    }

  sym = lookup_symbol (sf, 0, VAR_NAMESPACE, (int *) NULL,
		       (struct symtab **) NULL);
  if (sym != 0)
    {
      a = SYMBOL_VALUE (sym);
    }
  else
    {
      msymbol = lookup_minimal_symbol (sf, NULL, NULL);
      if (msymbol == NULL)
	return 0;
      a = SYMBOL_VALUE_ADDRESS (msymbol);
    }

  return (chain != read_memory_integer (a, 4));
}


void
_initialize_i960_tdep (void)
{
  check_host ();

  tm_print_insn = print_insn_i960;
}
@


1.10
log
@2002-04-24  David S. Miller  <davem@@redhat.com>

	* i960-tdep.c (register_in_window_p): New function.
	(i960_find_saved_register): Use it instead of
	REGISTER_IN_WINDOW_P.
	* config/i960/tm-i960.h (REGISTER_IN_WINDOW): Delete.

2002-04-24  David S. Miller  <davem@@redhat.com>

	* gdbint.texinfo (REGISTER_IN_WINDOW): Delete definition.
@
text
@d35 1
@


1.10.6.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a34 1
#include "gdb_string.h"
@


1.10.6.2
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d1 1056
a1056 1056
// OBSOLETE /* Target-machine dependent code for the Intel 960
// OBSOLETE 
// OBSOLETE    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
// OBSOLETE    2001, 2002 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    Contributed by Intel Corporation.
// OBSOLETE    examine_prologue and other parts contributed by Wind River Systems.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "floatformat.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE #include "gdb_string.h"
// OBSOLETE 
// OBSOLETE static CORE_ADDR next_insn (CORE_ADDR memaddr,
// OBSOLETE 			    unsigned int *pword1, unsigned int *pword2);
// OBSOLETE 
// OBSOLETE struct type *
// OBSOLETE i960_register_type (int regnum)
// OBSOLETE {
// OBSOLETE   if (regnum < FP0_REGNUM)
// OBSOLETE     return builtin_type_int32;
// OBSOLETE   else
// OBSOLETE     return builtin_type_i960_ext;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Does the specified function use the "struct returning" convention
// OBSOLETE    or the "value returning" convention?  The "value returning" convention
// OBSOLETE    almost invariably returns the entire value in registers.  The
// OBSOLETE    "struct returning" convention often returns the entire value in
// OBSOLETE    memory, and passes a pointer (out of or into the function) saying
// OBSOLETE    where the value (is or should go).
// OBSOLETE 
// OBSOLETE    Since this sometimes depends on whether it was compiled with GCC,
// OBSOLETE    this is also an argument.  This is used in call_function to build a
// OBSOLETE    stack, and in value_being_returned to print return values.
// OBSOLETE 
// OBSOLETE    On i960, a structure is returned in registers g0-g3, if it will fit.
// OBSOLETE    If it's more than 16 bytes long, g13 pointed to it on entry.  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE i960_use_struct_convention (int gcc_p, struct type *type)
// OBSOLETE {
// OBSOLETE   return (TYPE_LENGTH (type) > 16);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* gdb960 is always running on a non-960 host.  Check its characteristics.
// OBSOLETE    This routine must be called as part of gdb initialization.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE check_host (void)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   static struct typestruct
// OBSOLETE     {
// OBSOLETE       int hostsize;		/* Size of type on host         */
// OBSOLETE       int i960size;		/* Size of type on i960         */
// OBSOLETE       char *typename;		/* Name of type, for error msg  */
// OBSOLETE     }
// OBSOLETE   types[] =
// OBSOLETE   {
// OBSOLETE     {
// OBSOLETE       sizeof (short), 2, "short"
// OBSOLETE     }
// OBSOLETE      ,
// OBSOLETE     {
// OBSOLETE       sizeof (int), 4, "int"
// OBSOLETE     }
// OBSOLETE      ,
// OBSOLETE     {
// OBSOLETE       sizeof (long), 4, "long"
// OBSOLETE     }
// OBSOLETE      ,
// OBSOLETE     {
// OBSOLETE       sizeof (float), 4, "float"
// OBSOLETE     }
// OBSOLETE      ,
// OBSOLETE     {
// OBSOLETE       sizeof (double), 8, "double"
// OBSOLETE     }
// OBSOLETE      ,
// OBSOLETE     {
// OBSOLETE       sizeof (char *), 4, "pointer"
// OBSOLETE     }
// OBSOLETE      ,
// OBSOLETE   };
// OBSOLETE #define TYPELEN	(sizeof(types) / sizeof(struct typestruct))
// OBSOLETE 
// OBSOLETE   /* Make sure that host type sizes are same as i960
// OBSOLETE    */
// OBSOLETE   for (i = 0; i < TYPELEN; i++)
// OBSOLETE     {
// OBSOLETE       if (types[i].hostsize != types[i].i960size)
// OBSOLETE 	{
// OBSOLETE 	  printf_unfiltered ("sizeof(%s) != %d:  PROCEED AT YOUR OWN RISK!\n",
// OBSOLETE 			     types[i].typename, types[i].i960size);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Is this register part of the register window system?  A yes answer
// OBSOLETE    implies that 1) The name of this register will not be the same in
// OBSOLETE    other frames, and 2) This register is automatically "saved" upon
// OBSOLETE    subroutine calls and thus there is no need to search more than one
// OBSOLETE    stack frame for it.
// OBSOLETE 
// OBSOLETE    On the i960, in fact, the name of this register in another frame is
// OBSOLETE    "mud" -- there is no overlap between the windows.  Each window is
// OBSOLETE    simply saved into the stack (true for our purposes, after having been
// OBSOLETE    flushed; normally they reside on-chip and are restored from on-chip
// OBSOLETE    without ever going to memory).  */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE register_in_window_p (int regnum)
// OBSOLETE {
// OBSOLETE   return regnum <= R15_REGNUM;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* i960_find_saved_register ()
// OBSOLETE 
// OBSOLETE    Return the address in which frame FRAME's value of register REGNUM
// OBSOLETE    has been saved in memory.  Or return zero if it has not been saved.
// OBSOLETE    If REGNUM specifies the SP, the value we return is actually the SP
// OBSOLETE    value, not an address where it was saved.  */
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE i960_find_saved_register (struct frame_info *frame, int regnum)
// OBSOLETE {
// OBSOLETE   register struct frame_info *frame1 = NULL;
// OBSOLETE   register CORE_ADDR addr = 0;
// OBSOLETE 
// OBSOLETE   if (frame == NULL)		/* No regs saved if want current frame */
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   /* We assume that a register in a register window will only be saved
// OBSOLETE      in one place (since the name changes and/or disappears as you go
// OBSOLETE      towards inner frames), so we only call get_frame_saved_regs on
// OBSOLETE      the current frame.  This is directly in contradiction to the
// OBSOLETE      usage below, which assumes that registers used in a frame must be
// OBSOLETE      saved in a lower (more interior) frame.  This change is a result
// OBSOLETE      of working on a register window machine; get_frame_saved_regs
// OBSOLETE      always returns the registers saved within a frame, within the
// OBSOLETE      context (register namespace) of that frame. */
// OBSOLETE 
// OBSOLETE   /* However, note that we don't want this to return anything if
// OBSOLETE      nothing is saved (if there's a frame inside of this one).  Also,
// OBSOLETE      callers to this routine asking for the stack pointer want the
// OBSOLETE      stack pointer saved for *this* frame; this is returned from the
// OBSOLETE      next frame.  */
// OBSOLETE 
// OBSOLETE   if (register_in_window_p (regnum))
// OBSOLETE     {
// OBSOLETE       frame1 = get_next_frame (frame);
// OBSOLETE       if (!frame1)
// OBSOLETE 	return 0;		/* Registers of this frame are active.  */
// OBSOLETE 
// OBSOLETE       /* Get the SP from the next frame in; it will be this
// OBSOLETE          current frame.  */
// OBSOLETE       if (regnum != SP_REGNUM)
// OBSOLETE 	frame1 = frame;
// OBSOLETE 
// OBSOLETE       FRAME_INIT_SAVED_REGS (frame1);
// OBSOLETE       return frame1->saved_regs[regnum];	/* ... which might be zero */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Note that this next routine assumes that registers used in
// OBSOLETE      frame x will be saved only in the frame that x calls and
// OBSOLETE      frames interior to it.  This is not true on the sparc, but the
// OBSOLETE      above macro takes care of it, so we should be all right. */
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       QUIT;
// OBSOLETE       frame1 = get_next_frame (frame);
// OBSOLETE       if (frame1 == 0)
// OBSOLETE 	break;
// OBSOLETE       frame = frame1;
// OBSOLETE       FRAME_INIT_SAVED_REGS (frame1);
// OBSOLETE       if (frame1->saved_regs[regnum])
// OBSOLETE 	addr = frame1->saved_regs[regnum];
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return addr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* i960_get_saved_register ()
// OBSOLETE 
// OBSOLETE    Find register number REGNUM relative to FRAME and put its (raw,
// OBSOLETE    target format) contents in *RAW_BUFFER.  Set *OPTIMIZED if the
// OBSOLETE    variable was optimized out (and thus can't be fetched).  Set *LVAL
// OBSOLETE    to lval_memory, lval_register, or not_lval, depending on whether
// OBSOLETE    the value was fetched from memory, from a register, or in a strange
// OBSOLETE    and non-modifiable way (e.g. a frame pointer which was calculated
// OBSOLETE    rather than fetched).  Set *ADDRP to the address, either in memory
// OBSOLETE    on as a REGISTER_BYTE offset into the registers array.
// OBSOLETE 
// OBSOLETE    Note that this implementation never sets *LVAL to not_lval.  But it
// OBSOLETE    can be replaced by defining GET_SAVED_REGISTER and supplying your
// OBSOLETE    own.
// OBSOLETE 
// OBSOLETE    The argument RAW_BUFFER must point to aligned memory.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE i960_get_saved_register (char *raw_buffer,
// OBSOLETE 			 int *optimized,
// OBSOLETE 			 CORE_ADDR *addrp,
// OBSOLETE 			 struct frame_info *frame,
// OBSOLETE 			 int regnum,
// OBSOLETE 			 enum lval_type *lval)
// OBSOLETE {
// OBSOLETE   CORE_ADDR addr;
// OBSOLETE 
// OBSOLETE   if (!target_has_registers)
// OBSOLETE     error ("No registers.");
// OBSOLETE 
// OBSOLETE   /* Normal systems don't optimize out things with register numbers.  */
// OBSOLETE   if (optimized != NULL)
// OBSOLETE     *optimized = 0;
// OBSOLETE   addr = i960_find_saved_register (frame, regnum);
// OBSOLETE   if (addr != 0)
// OBSOLETE     {
// OBSOLETE       if (lval != NULL)
// OBSOLETE 	*lval = lval_memory;
// OBSOLETE       if (regnum == SP_REGNUM)
// OBSOLETE 	{
// OBSOLETE 	  if (raw_buffer != NULL)
// OBSOLETE 	    {
// OBSOLETE 	      /* Put it back in target format.  */
// OBSOLETE 	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum),
// OBSOLETE 			     (LONGEST) addr);
// OBSOLETE 	    }
// OBSOLETE 	  if (addrp != NULL)
// OBSOLETE 	    *addrp = 0;
// OBSOLETE 	  return;
// OBSOLETE 	}
// OBSOLETE       if (raw_buffer != NULL)
// OBSOLETE 	target_read_memory (addr, raw_buffer, REGISTER_RAW_SIZE (regnum));
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if (lval != NULL)
// OBSOLETE 	*lval = lval_register;
// OBSOLETE       addr = REGISTER_BYTE (regnum);
// OBSOLETE       if (raw_buffer != NULL)
// OBSOLETE 	read_register_gen (regnum, raw_buffer);
// OBSOLETE     }
// OBSOLETE   if (addrp != NULL)
// OBSOLETE     *addrp = addr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Examine an i960 function prologue, recording the addresses at which
// OBSOLETE    registers are saved explicitly by the prologue code, and returning
// OBSOLETE    the address of the first instruction after the prologue (but not
// OBSOLETE    after the instruction at address LIMIT, as explained below).
// OBSOLETE 
// OBSOLETE    LIMIT places an upper bound on addresses of the instructions to be
// OBSOLETE    examined.  If the prologue code scan reaches LIMIT, the scan is
// OBSOLETE    aborted and LIMIT is returned.  This is used, when examining the
// OBSOLETE    prologue for the current frame, to keep examine_prologue () from
// OBSOLETE    claiming that a given register has been saved when in fact the
// OBSOLETE    instruction that saves it has not yet been executed.  LIMIT is used
// OBSOLETE    at other times to stop the scan when we hit code after the true
// OBSOLETE    function prologue (e.g. for the first source line) which might
// OBSOLETE    otherwise be mistaken for function prologue.
// OBSOLETE 
// OBSOLETE    The format of the function prologue matched by this routine is
// OBSOLETE    derived from examination of the source to gcc960 1.21, particularly
// OBSOLETE    the routine i960_function_prologue ().  A "regular expression" for
// OBSOLETE    the function prologue is given below:
// OBSOLETE 
// OBSOLETE    (lda LRn, g14
// OBSOLETE    mov g14, g[0-7]
// OBSOLETE    (mov 0, g14) | (lda 0, g14))?
// OBSOLETE 
// OBSOLETE    (mov[qtl]? g[0-15], r[4-15])*
// OBSOLETE    ((addo [1-31], sp, sp) | (lda n(sp), sp))?
// OBSOLETE    (st[qtl]? g[0-15], n(fp))*
// OBSOLETE 
// OBSOLETE    (cmpobne 0, g14, LFn
// OBSOLETE    mov sp, g14
// OBSOLETE    lda 0x30(sp), sp
// OBSOLETE    LFn: stq g0, (g14)
// OBSOLETE    stq g4, 0x10(g14)
// OBSOLETE    stq g8, 0x20(g14))?
// OBSOLETE 
// OBSOLETE    (st g14, n(fp))?
// OBSOLETE    (mov g13,r[4-15])?
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE /* Macros for extracting fields from i960 instructions.  */
// OBSOLETE 
// OBSOLETE #define BITMASK(pos, width) (((0x1 << (width)) - 1) << (pos))
// OBSOLETE #define EXTRACT_FIELD(val, pos, width) ((val) >> (pos) & BITMASK (0, width))
// OBSOLETE 
// OBSOLETE #define REG_SRC1(insn)    EXTRACT_FIELD (insn, 0, 5)
// OBSOLETE #define REG_SRC2(insn)    EXTRACT_FIELD (insn, 14, 5)
// OBSOLETE #define REG_SRCDST(insn)  EXTRACT_FIELD (insn, 19, 5)
// OBSOLETE #define MEM_SRCDST(insn)  EXTRACT_FIELD (insn, 19, 5)
// OBSOLETE #define MEMA_OFFSET(insn) EXTRACT_FIELD (insn, 0, 12)
// OBSOLETE 
// OBSOLETE /* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or
// OBSOLETE    is not the address of a valid instruction, the address of the next
// OBSOLETE    instruction beyond ADDR otherwise.  *PWORD1 receives the first word
// OBSOLETE    of the instruction, and (for two-word instructions), *PWORD2 receives
// OBSOLETE    the second.  */
// OBSOLETE 
// OBSOLETE #define NEXT_PROLOGUE_INSN(addr, lim, pword1, pword2) \
// OBSOLETE   (((addr) < (lim)) ? next_insn (addr, pword1, pword2) : 0)
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE examine_prologue (register CORE_ADDR ip, register CORE_ADDR limit,
// OBSOLETE 		  CORE_ADDR frame_addr, struct frame_saved_regs *fsr)
// OBSOLETE {
// OBSOLETE   register CORE_ADDR next_ip;
// OBSOLETE   register int src, dst;
// OBSOLETE   register unsigned int *pcode;
// OBSOLETE   unsigned int insn1, insn2;
// OBSOLETE   int size;
// OBSOLETE   int within_leaf_prologue;
// OBSOLETE   CORE_ADDR save_addr;
// OBSOLETE   static unsigned int varargs_prologue_code[] =
// OBSOLETE   {
// OBSOLETE     0x3507a00c,			/* cmpobne 0x0, g14, LFn */
// OBSOLETE     0x5cf01601,			/* mov sp, g14           */
// OBSOLETE     0x8c086030,			/* lda 0x30(sp), sp      */
// OBSOLETE     0xb2879000,			/* LFn: stq  g0, (g14)   */
// OBSOLETE     0xb2a7a010,			/* stq g4, 0x10(g14)     */
// OBSOLETE     0xb2c7a020			/* stq g8, 0x20(g14)     */
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE   /* Accept a leaf procedure prologue code fragment if present.
// OBSOLETE      Note that ip might point to either the leaf or non-leaf
// OBSOLETE      entry point; we look for the non-leaf entry point first:  */
// OBSOLETE 
// OBSOLETE   within_leaf_prologue = 0;
// OBSOLETE   if ((next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2))
// OBSOLETE       && ((insn1 & 0xfffff000) == 0x8cf00000	/* lda LRx, g14 (MEMA) */
// OBSOLETE 	  || (insn1 & 0xfffffc60) == 0x8cf03000))	/* lda LRx, g14 (MEMB) */
// OBSOLETE     {
// OBSOLETE       within_leaf_prologue = 1;
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (next_ip, limit, &insn1, &insn2);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Now look for the prologue code at a leaf entry point:  */
// OBSOLETE 
// OBSOLETE   if (next_ip
// OBSOLETE       && (insn1 & 0xff87ffff) == 0x5c80161e	/* mov g14, gx */
// OBSOLETE       && REG_SRCDST (insn1) <= G0_REGNUM + 7)
// OBSOLETE     {
// OBSOLETE       within_leaf_prologue = 1;
// OBSOLETE       if ((next_ip = NEXT_PROLOGUE_INSN (next_ip, limit, &insn1, &insn2))
// OBSOLETE 	  && (insn1 == 0x8cf00000	/* lda 0, g14 */
// OBSOLETE 	      || insn1 == 0x5cf01e00))	/* mov 0, g14 */
// OBSOLETE 	{
// OBSOLETE 	  ip = next_ip;
// OBSOLETE 	  next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
// OBSOLETE 	  within_leaf_prologue = 0;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* If something that looks like the beginning of a leaf prologue
// OBSOLETE      has been seen, but the remainder of the prologue is missing, bail.
// OBSOLETE      We don't know what we've got.  */
// OBSOLETE 
// OBSOLETE   if (within_leaf_prologue)
// OBSOLETE     return (ip);
// OBSOLETE 
// OBSOLETE   /* Accept zero or more instances of "mov[qtl]? gx, ry", where y >= 4.
// OBSOLETE      This may cause us to mistake the moving of a register
// OBSOLETE      parameter to a local register for the saving of a callee-saved
// OBSOLETE      register, but that can't be helped, since with the
// OBSOLETE      "-fcall-saved" flag, any register can be made callee-saved.  */
// OBSOLETE 
// OBSOLETE   while (next_ip
// OBSOLETE 	 && (insn1 & 0xfc802fb0) == 0x5c000610
// OBSOLETE 	 && (dst = REG_SRCDST (insn1)) >= (R0_REGNUM + 4))
// OBSOLETE     {
// OBSOLETE       src = REG_SRC1 (insn1);
// OBSOLETE       size = EXTRACT_FIELD (insn1, 24, 2) + 1;
// OBSOLETE       save_addr = frame_addr + ((dst - R0_REGNUM) * 4);
// OBSOLETE       while (size--)
// OBSOLETE 	{
// OBSOLETE 	  fsr->regs[src++] = save_addr;
// OBSOLETE 	  save_addr += 4;
// OBSOLETE 	}
// OBSOLETE       ip = next_ip;
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Accept an optional "addo n, sp, sp" or "lda n(sp), sp".  */
// OBSOLETE 
// OBSOLETE   if (next_ip &&
// OBSOLETE       ((insn1 & 0xffffffe0) == 0x59084800	/* addo n, sp, sp */
// OBSOLETE        || (insn1 & 0xfffff000) == 0x8c086000	/* lda n(sp), sp (MEMA) */
// OBSOLETE        || (insn1 & 0xfffffc60) == 0x8c087400))	/* lda n(sp), sp (MEMB) */
// OBSOLETE     {
// OBSOLETE       ip = next_ip;
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Accept zero or more instances of "st[qtl]? gx, n(fp)".  
// OBSOLETE      This may cause us to mistake the copying of a register
// OBSOLETE      parameter to the frame for the saving of a callee-saved
// OBSOLETE      register, but that can't be helped, since with the
// OBSOLETE      "-fcall-saved" flag, any register can be made callee-saved.
// OBSOLETE      We can, however, refuse to accept a save of register g14,
// OBSOLETE      since that is matched explicitly below.  */
// OBSOLETE 
// OBSOLETE   while (next_ip &&
// OBSOLETE 	 ((insn1 & 0xf787f000) == 0x9287e000	/* stl? gx, n(fp) (MEMA) */
// OBSOLETE 	  || (insn1 & 0xf787fc60) == 0x9287f400		/* stl? gx, n(fp) (MEMB) */
// OBSOLETE 	  || (insn1 & 0xef87f000) == 0xa287e000		/* st[tq] gx, n(fp) (MEMA) */
// OBSOLETE 	  || (insn1 & 0xef87fc60) == 0xa287f400)	/* st[tq] gx, n(fp) (MEMB) */
// OBSOLETE 	 && ((src = MEM_SRCDST (insn1)) != G14_REGNUM))
// OBSOLETE     {
// OBSOLETE       save_addr = frame_addr + ((insn1 & BITMASK (12, 1))
// OBSOLETE 				? insn2 : MEMA_OFFSET (insn1));
// OBSOLETE       size = (insn1 & BITMASK (29, 1)) ? ((insn1 & BITMASK (28, 1)) ? 4 : 3)
// OBSOLETE 	: ((insn1 & BITMASK (27, 1)) ? 2 : 1);
// OBSOLETE       while (size--)
// OBSOLETE 	{
// OBSOLETE 	  fsr->regs[src++] = save_addr;
// OBSOLETE 	  save_addr += 4;
// OBSOLETE 	}
// OBSOLETE       ip = next_ip;
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Accept the varargs prologue code if present.  */
// OBSOLETE 
// OBSOLETE   size = sizeof (varargs_prologue_code) / sizeof (int);
// OBSOLETE   pcode = varargs_prologue_code;
// OBSOLETE   while (size-- && next_ip && *pcode++ == insn1)
// OBSOLETE     {
// OBSOLETE       ip = next_ip;
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Accept an optional "st g14, n(fp)".  */
// OBSOLETE 
// OBSOLETE   if (next_ip &&
// OBSOLETE       ((insn1 & 0xfffff000) == 0x92f7e000	/* st g14, n(fp) (MEMA) */
// OBSOLETE        || (insn1 & 0xfffffc60) == 0x92f7f400))	/* st g14, n(fp) (MEMB) */
// OBSOLETE     {
// OBSOLETE       fsr->regs[G14_REGNUM] = frame_addr + ((insn1 & BITMASK (12, 1))
// OBSOLETE 					    ? insn2 : MEMA_OFFSET (insn1));
// OBSOLETE       ip = next_ip;
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Accept zero or one instance of "mov g13, ry", where y >= 4.
// OBSOLETE      This is saving the address where a struct should be returned.  */
// OBSOLETE 
// OBSOLETE   if (next_ip
// OBSOLETE       && (insn1 & 0xff802fbf) == 0x5c00061d
// OBSOLETE       && (dst = REG_SRCDST (insn1)) >= (R0_REGNUM + 4))
// OBSOLETE     {
// OBSOLETE       save_addr = frame_addr + ((dst - R0_REGNUM) * 4);
// OBSOLETE       fsr->regs[G0_REGNUM + 13] = save_addr;
// OBSOLETE       ip = next_ip;
// OBSOLETE #if 0				/* We'll need this once there is a subsequent instruction examined. */
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn1, &insn2);
// OBSOLETE #endif
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return (ip);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Given an ip value corresponding to the start of a function,
// OBSOLETE    return the ip of the first instruction after the function 
// OBSOLETE    prologue.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE i960_skip_prologue (CORE_ADDR ip)
// OBSOLETE {
// OBSOLETE   struct frame_saved_regs saved_regs_dummy;
// OBSOLETE   struct symtab_and_line sal;
// OBSOLETE   CORE_ADDR limit;
// OBSOLETE 
// OBSOLETE   sal = find_pc_line (ip, 0);
// OBSOLETE   limit = (sal.end) ? sal.end : 0xffffffff;
// OBSOLETE 
// OBSOLETE   return (examine_prologue (ip, limit, (CORE_ADDR) 0, &saved_regs_dummy));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Put here the code to store, into a struct frame_saved_regs,
// OBSOLETE    the addresses of the saved registers of frame described by FRAME_INFO.
// OBSOLETE    This includes special registers such as pc and fp saved in special
// OBSOLETE    ways in the stack frame.  sp is even more special:
// OBSOLETE    the address we return for it IS the sp for the next frame.
// OBSOLETE 
// OBSOLETE    We cache the result of doing this in the frame_obstack, since it is
// OBSOLETE    fairly expensive.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE frame_find_saved_regs (struct frame_info *fi, struct frame_saved_regs *fsr)
// OBSOLETE {
// OBSOLETE   register CORE_ADDR next_addr;
// OBSOLETE   register CORE_ADDR *saved_regs;
// OBSOLETE   register int regnum;
// OBSOLETE   register struct frame_saved_regs *cache_fsr;
// OBSOLETE   CORE_ADDR ip;
// OBSOLETE   struct symtab_and_line sal;
// OBSOLETE   CORE_ADDR limit;
// OBSOLETE 
// OBSOLETE   if (!fi->fsr)
// OBSOLETE     {
// OBSOLETE       cache_fsr = (struct frame_saved_regs *)
// OBSOLETE 	frame_obstack_alloc (sizeof (struct frame_saved_regs));
// OBSOLETE       memset (cache_fsr, '\0', sizeof (struct frame_saved_regs));
// OBSOLETE       fi->fsr = cache_fsr;
// OBSOLETE 
// OBSOLETE       /* Find the start and end of the function prologue.  If the PC
// OBSOLETE          is in the function prologue, we only consider the part that
// OBSOLETE          has executed already.  */
// OBSOLETE 
// OBSOLETE       ip = get_pc_function_start (fi->pc);
// OBSOLETE       sal = find_pc_line (ip, 0);
// OBSOLETE       limit = (sal.end && sal.end < fi->pc) ? sal.end : fi->pc;
// OBSOLETE 
// OBSOLETE       examine_prologue (ip, limit, fi->frame, cache_fsr);
// OBSOLETE 
// OBSOLETE       /* Record the addresses at which the local registers are saved.
// OBSOLETE          Strictly speaking, we should only do this for non-leaf procedures,
// OBSOLETE          but no one will ever look at these values if it is a leaf procedure,
// OBSOLETE          since local registers are always caller-saved.  */
// OBSOLETE 
// OBSOLETE       next_addr = (CORE_ADDR) fi->frame;
// OBSOLETE       saved_regs = cache_fsr->regs;
// OBSOLETE       for (regnum = R0_REGNUM; regnum <= R15_REGNUM; regnum++)
// OBSOLETE 	{
// OBSOLETE 	  *saved_regs++ = next_addr;
// OBSOLETE 	  next_addr += 4;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       cache_fsr->regs[FP_REGNUM] = cache_fsr->regs[PFP_REGNUM];
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   *fsr = *fi->fsr;
// OBSOLETE 
// OBSOLETE   /* Fetch the value of the sp from memory every time, since it
// OBSOLETE      is conceivable that it has changed since the cache was flushed.  
// OBSOLETE      This unfortunately undoes much of the savings from caching the 
// OBSOLETE      saved register values.  I suggest adding an argument to 
// OBSOLETE      get_frame_saved_regs () specifying the register number we're
// OBSOLETE      interested in (or -1 for all registers).  This would be passed
// OBSOLETE      through to FRAME_FIND_SAVED_REGS (), permitting more efficient
// OBSOLETE      computation of saved register addresses (e.g., on the i960,
// OBSOLETE      we don't have to examine the prologue to find local registers). 
// OBSOLETE      -- markf@@wrs.com 
// OBSOLETE      FIXME, we don't need to refetch this, since the cache is cleared
// OBSOLETE      every time the child process is restarted.  If GDB itself
// OBSOLETE      modifies SP, it has to clear the cache by hand (does it?).  -gnu */
// OBSOLETE 
// OBSOLETE   fsr->regs[SP_REGNUM] = read_memory_integer (fsr->regs[SP_REGNUM], 4);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the address of the argument block for the frame
// OBSOLETE    described by FI.  Returns 0 if the address is unknown.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE frame_args_address (struct frame_info *fi, int must_be_correct)
// OBSOLETE {
// OBSOLETE   struct frame_saved_regs fsr;
// OBSOLETE   CORE_ADDR ap;
// OBSOLETE 
// OBSOLETE   /* If g14 was saved in the frame by the function prologue code, return
// OBSOLETE      the saved value.  If the frame is current and we are being sloppy,
// OBSOLETE      return the value of g14.  Otherwise, return zero.  */
// OBSOLETE 
// OBSOLETE   get_frame_saved_regs (fi, &fsr);
// OBSOLETE   if (fsr.regs[G14_REGNUM])
// OBSOLETE     ap = read_memory_integer (fsr.regs[G14_REGNUM], 4);
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if (must_be_correct)
// OBSOLETE 	return 0;		/* Don't cache this result */
// OBSOLETE       if (get_next_frame (fi))
// OBSOLETE 	ap = 0;
// OBSOLETE       else
// OBSOLETE 	ap = read_register (G14_REGNUM);
// OBSOLETE       if (ap == 0)
// OBSOLETE 	ap = fi->frame;
// OBSOLETE     }
// OBSOLETE   fi->arg_pointer = ap;		/* Cache it for next time */
// OBSOLETE   return ap;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the address of the return struct for the frame
// OBSOLETE    described by FI.  Returns 0 if the address is unknown.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE frame_struct_result_address (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   struct frame_saved_regs fsr;
// OBSOLETE   CORE_ADDR ap;
// OBSOLETE 
// OBSOLETE   /* If the frame is non-current, check to see if g14 was saved in the
// OBSOLETE      frame by the function prologue code; return the saved value if so,
// OBSOLETE      zero otherwise.  If the frame is current, return the value of g14.
// OBSOLETE 
// OBSOLETE      FIXME, shouldn't this use the saved value as long as we are past
// OBSOLETE      the function prologue, and only use the current value if we have
// OBSOLETE      no saved value and are at TOS?   -- gnu@@cygnus.com */
// OBSOLETE 
// OBSOLETE   if (get_next_frame (fi))
// OBSOLETE     {
// OBSOLETE       get_frame_saved_regs (fi, &fsr);
// OBSOLETE       if (fsr.regs[G13_REGNUM])
// OBSOLETE 	ap = read_memory_integer (fsr.regs[G13_REGNUM], 4);
// OBSOLETE       else
// OBSOLETE 	ap = 0;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     ap = read_register (G13_REGNUM);
// OBSOLETE 
// OBSOLETE   return ap;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return address to which the currently executing leafproc will return,
// OBSOLETE    or 0 if IP, the value of the instruction pointer from the currently
// OBSOLETE    executing function, is not in a leafproc (or if we can't tell if it
// OBSOLETE    is).
// OBSOLETE 
// OBSOLETE    Do this by finding the starting address of the routine in which IP lies.
// OBSOLETE    If the instruction there is "mov g14, gx" (where x is in [0,7]), this
// OBSOLETE    is a leafproc and the return address is in register gx.  Well, this is
// OBSOLETE    true unless the return address points at a RET instruction in the current
// OBSOLETE    procedure, which indicates that we have a 'dual entry' routine that
// OBSOLETE    has been entered through the CALL entry point.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE leafproc_return (CORE_ADDR ip)
// OBSOLETE {
// OBSOLETE   register struct minimal_symbol *msymbol;
// OBSOLETE   char *p;
// OBSOLETE   int dst;
// OBSOLETE   unsigned int insn1, insn2;
// OBSOLETE   CORE_ADDR return_addr;
// OBSOLETE 
// OBSOLETE   if ((msymbol = lookup_minimal_symbol_by_pc (ip)) != NULL)
// OBSOLETE     {
// OBSOLETE       if ((p = strchr (SYMBOL_NAME (msymbol), '.')) && STREQ (p, ".lf"))
// OBSOLETE 	{
// OBSOLETE 	  if (next_insn (SYMBOL_VALUE_ADDRESS (msymbol), &insn1, &insn2)
// OBSOLETE 	      && (insn1 & 0xff87ffff) == 0x5c80161e	/* mov g14, gx */
// OBSOLETE 	      && (dst = REG_SRCDST (insn1)) <= G0_REGNUM + 7)
// OBSOLETE 	    {
// OBSOLETE 	      /* Get the return address.  If the "mov g14, gx" 
// OBSOLETE 	         instruction hasn't been executed yet, read
// OBSOLETE 	         the return address from g14; otherwise, read it
// OBSOLETE 	         from the register into which g14 was moved.  */
// OBSOLETE 
// OBSOLETE 	      return_addr =
// OBSOLETE 		read_register ((ip == SYMBOL_VALUE_ADDRESS (msymbol))
// OBSOLETE 			       ? G14_REGNUM : dst);
// OBSOLETE 
// OBSOLETE 	      /* We know we are in a leaf procedure, but we don't know
// OBSOLETE 	         whether the caller actually did a "bal" to the ".lf"
// OBSOLETE 	         entry point, or a normal "call" to the non-leaf entry
// OBSOLETE 	         point one instruction before.  In the latter case, the
// OBSOLETE 	         return address will be the address of a "ret"
// OBSOLETE 	         instruction within the procedure itself.  We test for
// OBSOLETE 	         this below.  */
// OBSOLETE 
// OBSOLETE 	      if (!next_insn (return_addr, &insn1, &insn2)
// OBSOLETE 		  || (insn1 & 0xff000000) != 0xa000000	/* ret */
// OBSOLETE 		  || lookup_minimal_symbol_by_pc (return_addr) != msymbol)
// OBSOLETE 		return (return_addr);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return (0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Immediately after a function call, return the saved pc.
// OBSOLETE    Can't go through the frames for this because on some machines
// OBSOLETE    the new frame is not set up until the new function executes
// OBSOLETE    some instructions. 
// OBSOLETE    On the i960, the frame *is* set up immediately after the call,
// OBSOLETE    unless the function is a leaf procedure.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE saved_pc_after_call (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   CORE_ADDR saved_pc;
// OBSOLETE 
// OBSOLETE   saved_pc = leafproc_return (get_frame_pc (frame));
// OBSOLETE   if (!saved_pc)
// OBSOLETE     saved_pc = FRAME_SAVED_PC (frame);
// OBSOLETE 
// OBSOLETE   return saved_pc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Discard from the stack the innermost frame,
// OBSOLETE    restoring all saved registers.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE i960_pop_frame (void)
// OBSOLETE {
// OBSOLETE   register struct frame_info *current_fi, *prev_fi;
// OBSOLETE   register int i;
// OBSOLETE   CORE_ADDR save_addr;
// OBSOLETE   CORE_ADDR leaf_return_addr;
// OBSOLETE   struct frame_saved_regs fsr;
// OBSOLETE   char local_regs_buf[16 * 4];
// OBSOLETE 
// OBSOLETE   current_fi = get_current_frame ();
// OBSOLETE 
// OBSOLETE   /* First, undo what the hardware does when we return.
// OBSOLETE      If this is a non-leaf procedure, restore local registers from
// OBSOLETE      the save area in the calling frame.  Otherwise, load the return
// OBSOLETE      address obtained from leafproc_return () into the rip.  */
// OBSOLETE 
// OBSOLETE   leaf_return_addr = leafproc_return (current_fi->pc);
// OBSOLETE   if (!leaf_return_addr)
// OBSOLETE     {
// OBSOLETE       /* Non-leaf procedure.  Restore local registers, incl IP.  */
// OBSOLETE       prev_fi = get_prev_frame (current_fi);
// OBSOLETE       read_memory (prev_fi->frame, local_regs_buf, sizeof (local_regs_buf));
// OBSOLETE       write_register_bytes (REGISTER_BYTE (R0_REGNUM), local_regs_buf,
// OBSOLETE 			    sizeof (local_regs_buf));
// OBSOLETE 
// OBSOLETE       /* Restore frame pointer.  */
// OBSOLETE       write_register (FP_REGNUM, prev_fi->frame);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* Leaf procedure.  Just restore the return address into the IP.  */
// OBSOLETE       write_register (RIP_REGNUM, leaf_return_addr);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Now restore any global regs that the current function had saved. */
// OBSOLETE   get_frame_saved_regs (current_fi, &fsr);
// OBSOLETE   for (i = G0_REGNUM; i < G14_REGNUM; i++)
// OBSOLETE     {
// OBSOLETE       save_addr = fsr.regs[i];
// OBSOLETE       if (save_addr != 0)
// OBSOLETE 	write_register (i, read_memory_integer (save_addr, 4));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Flush the frame cache, create a frame for the new innermost frame,
// OBSOLETE      and make it the current frame.  */
// OBSOLETE 
// OBSOLETE   flush_cached_frames ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Given a 960 stop code (fault or trace), return the signal which
// OBSOLETE    corresponds.  */
// OBSOLETE 
// OBSOLETE enum target_signal
// OBSOLETE i960_fault_to_signal (int fault)
// OBSOLETE {
// OBSOLETE   switch (fault)
// OBSOLETE     {
// OBSOLETE     case 0:
// OBSOLETE       return TARGET_SIGNAL_BUS;	/* parallel fault */
// OBSOLETE     case 1:
// OBSOLETE       return TARGET_SIGNAL_UNKNOWN;
// OBSOLETE     case 2:
// OBSOLETE       return TARGET_SIGNAL_ILL;	/* operation fault */
// OBSOLETE     case 3:
// OBSOLETE       return TARGET_SIGNAL_FPE;	/* arithmetic fault */
// OBSOLETE     case 4:
// OBSOLETE       return TARGET_SIGNAL_FPE;	/* floating point fault */
// OBSOLETE 
// OBSOLETE       /* constraint fault.  This appears not to distinguish between
// OBSOLETE          a range constraint fault (which should be SIGFPE) and a privileged
// OBSOLETE          fault (which should be SIGILL).  */
// OBSOLETE     case 5:
// OBSOLETE       return TARGET_SIGNAL_ILL;
// OBSOLETE 
// OBSOLETE     case 6:
// OBSOLETE       return TARGET_SIGNAL_SEGV;	/* virtual memory fault */
// OBSOLETE 
// OBSOLETE       /* protection fault.  This is for an out-of-range argument to
// OBSOLETE          "calls".  I guess it also could be SIGILL. */
// OBSOLETE     case 7:
// OBSOLETE       return TARGET_SIGNAL_SEGV;
// OBSOLETE 
// OBSOLETE     case 8:
// OBSOLETE       return TARGET_SIGNAL_BUS;	/* machine fault */
// OBSOLETE     case 9:
// OBSOLETE       return TARGET_SIGNAL_BUS;	/* structural fault */
// OBSOLETE     case 0xa:
// OBSOLETE       return TARGET_SIGNAL_ILL;	/* type fault */
// OBSOLETE     case 0xb:
// OBSOLETE       return TARGET_SIGNAL_UNKNOWN;	/* reserved fault */
// OBSOLETE     case 0xc:
// OBSOLETE       return TARGET_SIGNAL_BUS;	/* process fault */
// OBSOLETE     case 0xd:
// OBSOLETE       return TARGET_SIGNAL_SEGV;	/* descriptor fault */
// OBSOLETE     case 0xe:
// OBSOLETE       return TARGET_SIGNAL_BUS;	/* event fault */
// OBSOLETE     case 0xf:
// OBSOLETE       return TARGET_SIGNAL_UNKNOWN;	/* reserved fault */
// OBSOLETE     case 0x10:
// OBSOLETE       return TARGET_SIGNAL_TRAP;	/* single-step trace */
// OBSOLETE     case 0x11:
// OBSOLETE       return TARGET_SIGNAL_TRAP;	/* branch trace */
// OBSOLETE     case 0x12:
// OBSOLETE       return TARGET_SIGNAL_TRAP;	/* call trace */
// OBSOLETE     case 0x13:
// OBSOLETE       return TARGET_SIGNAL_TRAP;	/* return trace */
// OBSOLETE     case 0x14:
// OBSOLETE       return TARGET_SIGNAL_TRAP;	/* pre-return trace */
// OBSOLETE     case 0x15:
// OBSOLETE       return TARGET_SIGNAL_TRAP;	/* supervisor call trace */
// OBSOLETE     case 0x16:
// OBSOLETE       return TARGET_SIGNAL_TRAP;	/* breakpoint trace */
// OBSOLETE     default:
// OBSOLETE       return TARGET_SIGNAL_UNKNOWN;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /****************************************/
// OBSOLETE /* MEM format                           */
// OBSOLETE /****************************************/
// OBSOLETE 
// OBSOLETE struct tabent
// OBSOLETE {
// OBSOLETE   char *name;
// OBSOLETE   char numops;
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* Return instruction length, either 4 or 8.  When NOPRINT is non-zero
// OBSOLETE    (TRUE), don't output any text.  (Actually, as implemented, if NOPRINT
// OBSOLETE    is 0, abort() is called.) */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE mem (unsigned long memaddr, unsigned long word1, unsigned long word2,
// OBSOLETE      int noprint)
// OBSOLETE {
// OBSOLETE   int i, j;
// OBSOLETE   int len;
// OBSOLETE   int mode;
// OBSOLETE   int offset;
// OBSOLETE   const char *reg1, *reg2, *reg3;
// OBSOLETE 
// OBSOLETE   /* This lookup table is too sparse to make it worth typing in, but not
// OBSOLETE    * so large as to make a sparse array necessary.  We allocate the
// OBSOLETE    * table at runtime, initialize all entries to empty, and copy the
// OBSOLETE    * real ones in from an initialization table.
// OBSOLETE    *
// OBSOLETE    * NOTE: In this table, the meaning of 'numops' is:
// OBSOLETE    *       1: single operand
// OBSOLETE    *       2: 2 operands, load instruction
// OBSOLETE    *      -2: 2 operands, store instruction
// OBSOLETE    */
// OBSOLETE   static struct tabent *mem_tab = NULL;
// OBSOLETE /* Opcodes of 0x8X, 9X, aX, bX, and cX must be in the table.  */
// OBSOLETE #define MEM_MIN	0x80
// OBSOLETE #define MEM_MAX	0xcf
// OBSOLETE #define MEM_SIZ	((MEM_MAX-MEM_MIN+1) * sizeof(struct tabent))
// OBSOLETE 
// OBSOLETE   static struct
// OBSOLETE     {
// OBSOLETE       int opcode;
// OBSOLETE       char *name;
// OBSOLETE       char numops;
// OBSOLETE     }
// OBSOLETE   mem_init[] =
// OBSOLETE   {
// OBSOLETE     0x80, "ldob", 2,
// OBSOLETE       0x82, "stob", -2,
// OBSOLETE       0x84, "bx", 1,
// OBSOLETE       0x85, "balx", 2,
// OBSOLETE       0x86, "callx", 1,
// OBSOLETE       0x88, "ldos", 2,
// OBSOLETE       0x8a, "stos", -2,
// OBSOLETE       0x8c, "lda", 2,
// OBSOLETE       0x90, "ld", 2,
// OBSOLETE       0x92, "st", -2,
// OBSOLETE       0x98, "ldl", 2,
// OBSOLETE       0x9a, "stl", -2,
// OBSOLETE       0xa0, "ldt", 2,
// OBSOLETE       0xa2, "stt", -2,
// OBSOLETE       0xb0, "ldq", 2,
// OBSOLETE       0xb2, "stq", -2,
// OBSOLETE       0xc0, "ldib", 2,
// OBSOLETE       0xc2, "stib", -2,
// OBSOLETE       0xc8, "ldis", 2,
// OBSOLETE       0xca, "stis", -2,
// OBSOLETE       0, NULL, 0
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE   if (mem_tab == NULL)
// OBSOLETE     {
// OBSOLETE       mem_tab = (struct tabent *) xmalloc (MEM_SIZ);
// OBSOLETE       memset (mem_tab, '\0', MEM_SIZ);
// OBSOLETE       for (i = 0; mem_init[i].opcode != 0; i++)
// OBSOLETE 	{
// OBSOLETE 	  j = mem_init[i].opcode - MEM_MIN;
// OBSOLETE 	  mem_tab[j].name = mem_init[i].name;
// OBSOLETE 	  mem_tab[j].numops = mem_init[i].numops;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   i = ((word1 >> 24) & 0xff) - MEM_MIN;
// OBSOLETE   mode = (word1 >> 10) & 0xf;
// OBSOLETE 
// OBSOLETE   if ((mem_tab[i].name != NULL)	/* Valid instruction */
// OBSOLETE       && ((mode == 5) || (mode >= 12)))
// OBSOLETE     {				/* With 32-bit displacement */
// OBSOLETE       len = 8;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       len = 4;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (noprint)
// OBSOLETE     {
// OBSOLETE       return len;
// OBSOLETE     }
// OBSOLETE   internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Read the i960 instruction at 'memaddr' and return the address of 
// OBSOLETE    the next instruction after that, or 0 if 'memaddr' is not the
// OBSOLETE    address of a valid instruction.  The first word of the instruction
// OBSOLETE    is stored at 'pword1', and the second word, if any, is stored at
// OBSOLETE    'pword2'.  */
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE next_insn (CORE_ADDR memaddr, unsigned int *pword1, unsigned int *pword2)
// OBSOLETE {
// OBSOLETE   int len;
// OBSOLETE   char buf[8];
// OBSOLETE 
// OBSOLETE   /* Read the two (potential) words of the instruction at once,
// OBSOLETE      to eliminate the overhead of two calls to read_memory ().
// OBSOLETE      FIXME: Loses if the first one is readable but the second is not
// OBSOLETE      (e.g. last word of the segment).  */
// OBSOLETE 
// OBSOLETE   read_memory (memaddr, buf, 8);
// OBSOLETE   *pword1 = extract_unsigned_integer (buf, 4);
// OBSOLETE   *pword2 = extract_unsigned_integer (buf + 4, 4);
// OBSOLETE 
// OBSOLETE   /* Divide instruction set into classes based on high 4 bits of opcode */
// OBSOLETE 
// OBSOLETE   switch ((*pword1 >> 28) & 0xf)
// OBSOLETE     {
// OBSOLETE     case 0x0:
// OBSOLETE     case 0x1:			/* ctrl */
// OBSOLETE 
// OBSOLETE     case 0x2:
// OBSOLETE     case 0x3:			/* cobr */
// OBSOLETE 
// OBSOLETE     case 0x5:
// OBSOLETE     case 0x6:
// OBSOLETE     case 0x7:			/* reg */
// OBSOLETE       len = 4;
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     case 0x8:
// OBSOLETE     case 0x9:
// OBSOLETE     case 0xa:
// OBSOLETE     case 0xb:
// OBSOLETE     case 0xc:
// OBSOLETE       len = mem (memaddr, *pword1, *pword2, 1);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     default:			/* invalid instruction */
// OBSOLETE       len = 0;
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (len)
// OBSOLETE     return memaddr + len;
// OBSOLETE   else
// OBSOLETE     return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* 'start_frame' is a variable in the MON960 runtime startup routine
// OBSOLETE    that contains the frame pointer of the 'start' routine (the routine
// OBSOLETE    that calls 'main').  By reading its contents out of remote memory,
// OBSOLETE    we can tell where the frame chain ends:  backtraces should halt before
// OBSOLETE    they display this frame.  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE mon960_frame_chain_valid (CORE_ADDR chain, struct frame_info *curframe)
// OBSOLETE {
// OBSOLETE   struct symbol *sym;
// OBSOLETE   struct minimal_symbol *msymbol;
// OBSOLETE 
// OBSOLETE   /* crtmon960.o is an assembler module that is assumed to be linked
// OBSOLETE    * first in an i80960 executable.  It contains the true entry point;
// OBSOLETE    * it performs startup up initialization and then calls 'main'.
// OBSOLETE    *
// OBSOLETE    * 'sf' is the name of a variable in crtmon960.o that is set
// OBSOLETE    *      during startup to the address of the first frame.
// OBSOLETE    *
// OBSOLETE    * 'a' is the address of that variable in 80960 memory.
// OBSOLETE    */
// OBSOLETE   static char sf[] = "start_frame";
// OBSOLETE   CORE_ADDR a;
// OBSOLETE 
// OBSOLETE 
// OBSOLETE   chain &= ~0x3f;		/* Zero low 6 bits because previous frame pointers
// OBSOLETE 				   contain return status info in them.  */
// OBSOLETE   if (chain == 0)
// OBSOLETE     {
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   sym = lookup_symbol (sf, 0, VAR_NAMESPACE, (int *) NULL,
// OBSOLETE 		       (struct symtab **) NULL);
// OBSOLETE   if (sym != 0)
// OBSOLETE     {
// OBSOLETE       a = SYMBOL_VALUE (sym);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       msymbol = lookup_minimal_symbol (sf, NULL, NULL);
// OBSOLETE       if (msymbol == NULL)
// OBSOLETE 	return 0;
// OBSOLETE       a = SYMBOL_VALUE_ADDRESS (msymbol);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return (chain != read_memory_integer (a, 4));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_i960_tdep (void)
// OBSOLETE {
// OBSOLETE   check_host ();
// OBSOLETE 
// OBSOLETE   tm_print_insn = print_insn_i960;
// OBSOLETE }
@


1.9
log
@* i960-tdep.c (i960_find_saved_register): New function.
(i960_get_saved_register): New function.
* config/i960/tm-i960.h (GET_SAVED_REGISTER): Define.
(i960_get_saved_register): Declare.
* config/i960/tm-i960.h, i960-tdep.c: Update copyright.
@
text
@d125 18
d175 1
a175 1
  if (REGISTER_IN_WINDOW_P (regnum))
@


1.8
log
@Eliminate REGISTER_CONVERTIBLE().
@
text
@d2 4
a5 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d123 131
@


1.7
log
@Update/correct copyright notices.
@
text
@d37 10
@


1.6
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1991, 1992, 1993, 1994, 1995, 2001 Free Software
   Foundation, Inc.
@


1.5
log
@Replace calls to abort() with calls to internal_error().
@
text
@d2 2
a3 1
   Copyright 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
d32 1
@


1.4
log
@Protoization.
@
text
@d777 1
a777 1
  abort ();
@


1.3
log
@Protoization.
@
text
@d334 1
a334 2
i960_skip_prologue (ip)
CORE_ADDR (ip);
d481 3
a483 1
   or 0 if ip is not in a leafproc (or if we can't tell if it is).
d485 1
a485 1
   Do this by finding the starting address of the routine in which ip lies.
d493 1
a493 2
leafproc_return (ip)
     CORE_ADDR ip;		/* ip from currently executing function */
d687 7
a693 6
static int			/* returns instruction length: 4 or 8 */
mem (memaddr, word1, word2, noprint)
     unsigned long memaddr;
     unsigned long word1, word2;
     int noprint;		/* If TRUE, return instruction length, but
				   don't output any text.  */
@


1.2
log
@PARAMS removal.
@
text
@d50 1
a50 3
i960_use_struct_convention (gcc_p, type)
     int gcc_p;
     struct type *type;
d59 1
a59 1
check_host ()
d171 2
a172 5
examine_prologue (ip, limit, frame_addr, fsr)
     register CORE_ADDR ip;
     register CORE_ADDR limit;
     CORE_ADDR frame_addr;
     struct frame_saved_regs *fsr;
d357 1
a357 3
frame_find_saved_regs (fi, fsr)
     struct frame_info *fi;
     struct frame_saved_regs *fsr;
d423 1
a423 2
frame_args_address (fi, must_be_correct)
     struct frame_info *fi;
d454 1
a454 2
frame_struct_result_address (fi)
     struct frame_info *fi;
d545 1
a545 2
saved_pc_after_call (frame)
     struct frame_info *frame;
d613 1
a613 2
i960_fault_to_signal (fault)
     int fault;
d786 1
a786 3
next_insn (memaddr, pword1, pword2)
     unsigned int *pword1, *pword2;
     CORE_ADDR memaddr;
d842 1
a842 3
mon960_frame_chain_valid (chain, curframe)
     CORE_ADDR chain;
     struct frame_info *curframe;
d886 1
a886 1
_initialize_i960_tdep ()
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
This file is part of GDB.
d8 14
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d30 1
d32 2
a33 3
static CORE_ADDR next_insn PARAMS ((CORE_ADDR memaddr,
				    unsigned int *pword1,
				    unsigned int *pword2));
d61 1
a61 1
check_host()
d63 1
a63 1
	int i;
d65 33
a97 12
	static struct typestruct {
		int hostsize;		/* Size of type on host		*/
		int i960size;		/* Size of type on i960		*/
		char *typename;		/* Name of type, for error msg	*/
	} types[] = {
		{ sizeof(short),  2, "short" },
		{ sizeof(int),    4, "int" },
		{ sizeof(long),   4, "long" },
		{ sizeof(float),  4, "float" },
		{ sizeof(double), 8, "double" },
		{ sizeof(char *), 4, "pointer" },
	};
d100 9
a108 7
	/* Make sure that host type sizes are same as i960
	 */
	for ( i = 0; i < TYPELEN; i++ ){
		if ( types[i].hostsize != types[i].i960size ){
			printf_unfiltered("sizeof(%s) != %d:  PROCEED AT YOUR OWN RISK!\n",
					types[i].typename, types[i].i960size );
		}
d110 1
a110 1
	}
d134 2
a135 2
    mov g14, g[0-7]
    (mov 0, g14) | (lda 0, g14))?
d142 5
a146 5
    mov sp, g14
    lda 0x30(sp), sp
    LFn: stq g0, (g14)
    stq g4, 0x10(g14)
    stq g8, 0x20(g14))?
d150 1
a150 1
*/
d186 9
a194 9
  static unsigned int varargs_prologue_code [] =
    {
       0x3507a00c,	/* cmpobne 0x0, g14, LFn */
       0x5cf01601,	/* mov sp, g14		 */
       0x8c086030,	/* lda 0x30(sp), sp	 */
       0xb2879000,	/* LFn: stq  g0, (g14)   */
       0xb2a7a010,	/* stq g4, 0x10(g14)	 */
       0xb2c7a020	/* stq g8, 0x20(g14)	 */
    };
d202 2
a203 2
      && ((insn1 & 0xfffff000) == 0x8cf00000         /* lda LRx, g14 (MEMA) */
	  || (insn1 & 0xfffffc60) == 0x8cf03000))    /* lda LRx, g14 (MEMB) */
d212 1
a212 1
      && (insn1 & 0xff87ffff) == 0x5c80161e         /* mov g14, gx */
d217 2
a218 2
	  && (insn1 == 0x8cf00000                   /* lda 0, g14 */
	      || insn1 == 0x5cf01e00))              /* mov 0, g14 */
d232 1
a232 1
	  
d275 4
a278 4
	 ((insn1 & 0xf787f000) == 0x9287e000      /* stl? gx, n(fp) (MEMA) */
	  || (insn1 & 0xf787fc60) == 0x9287f400   /* stl? gx, n(fp) (MEMB) */
	  || (insn1 & 0xef87f000) == 0xa287e000   /* st[tq] gx, n(fp) (MEMA) */
	  || (insn1 & 0xef87fc60) == 0xa287f400)  /* st[tq] gx, n(fp) (MEMB) */
d284 1
a284 1
	                               : ((insn1 & BITMASK (27, 1)) ? 2 : 1);
d307 2
a308 2
      ((insn1 & 0xfffff000) == 0x92f7e000	 /* st g14, n(fp) (MEMA) */
       || (insn1 & 0xfffffc60) == 0x92f7f400))   /* st g14, n(fp) (MEMB) */
d311 1
a311 1
				            ? insn2 : MEMA_OFFSET (insn1));
d324 1
a324 1
      fsr->regs[G0_REGNUM+13] = save_addr;
d326 1
a326 1
#if 0  /* We'll need this once there is a subsequent instruction examined. */
d339 2
a340 2
skip_prologue (ip)
     CORE_ADDR (ip);
d382 3
a384 3
	 is in the function prologue, we only consider the part that
	 has executed already.  */
         
d387 1
a387 1
      limit = (sal.end && sal.end < fi->pc) ? sal.end: fi->pc;
d392 3
a394 3
	 Strictly speaking, we should only do this for non-leaf procedures,
	 but no one will ever look at these values if it is a leaf procedure,
	 since local registers are always caller-saved.  */
d418 1
a418 1
	-- markf@@wrs.com 
d442 1
a442 1
    ap = read_memory_integer (fsr.regs[G14_REGNUM],4);
d446 1
a446 1
	return 0;			/* Don't cache this result */
d480 1
a480 1
	ap = read_memory_integer (fsr.regs[G13_REGNUM],4);
d492 1
a492 1
  
d502 1
a502 1
     CORE_ADDR ip;	/* ip from currently executing function	*/
d512 1
a512 1
      if ((p = strchr(SYMBOL_NAME (msymbol), '.')) && STREQ (p, ".lf"))
d515 1
a515 1
	      && (insn1 & 0xff87ffff) == 0x5c80161e       /* mov g14, gx */
d519 3
a521 3
		 instruction hasn't been executed yet, read
		 the return address from g14; otherwise, read it
		 from the register into which g14 was moved.  */
d524 2
a525 2
		  read_register ((ip == SYMBOL_VALUE_ADDRESS (msymbol))
				           ? G14_REGNUM : dst);
d528 6
a533 6
		 whether the caller actually did a "bal" to the ".lf"
		 entry point, or a normal "call" to the non-leaf entry
		 point one instruction before.  In the latter case, the
		 return address will be the address of a "ret"
		 instruction within the procedure itself.  We test for
		 this below.  */
d536 2
a537 2
		  || (insn1 & 0xff000000) != 0xa000000   /* ret */
	          || lookup_minimal_symbol_by_pc (return_addr) != msymbol)
d542 1
a542 1
  
d570 1
a570 1
pop_frame ()
d592 2
a593 2
      write_register_bytes (REGISTER_BYTE (R0_REGNUM), local_regs_buf, 
		            sizeof (local_regs_buf));
d608 2
a609 1
      if (save_addr = fsr.regs[i])
d624 1
a624 1
    int fault;
d628 10
a637 5
    case 0: return TARGET_SIGNAL_BUS; /* parallel fault */
    case 1: return TARGET_SIGNAL_UNKNOWN;
    case 2: return TARGET_SIGNAL_ILL; /* operation fault */
    case 3: return TARGET_SIGNAL_FPE; /* arithmetic fault */
    case 4: return TARGET_SIGNAL_FPE; /* floating point fault */
d640 4
a643 3
	 a range constraint fault (which should be SIGFPE) and a privileged
	 fault (which should be SIGILL).  */
    case 5: return TARGET_SIGNAL_ILL;
d645 2
a646 1
    case 6: return TARGET_SIGNAL_SEGV; /* virtual memory fault */
d649 36
a684 19
	 "calls".  I guess it also could be SIGILL. */
    case 7: return TARGET_SIGNAL_SEGV;

    case 8: return TARGET_SIGNAL_BUS; /* machine fault */
    case 9: return TARGET_SIGNAL_BUS; /* structural fault */
    case 0xa: return TARGET_SIGNAL_ILL; /* type fault */
    case 0xb: return TARGET_SIGNAL_UNKNOWN; /* reserved fault */
    case 0xc: return TARGET_SIGNAL_BUS; /* process fault */
    case 0xd: return TARGET_SIGNAL_SEGV; /* descriptor fault */
    case 0xe: return TARGET_SIGNAL_BUS; /* event fault */
    case 0xf: return TARGET_SIGNAL_UNKNOWN; /* reserved fault */
    case 0x10: return TARGET_SIGNAL_TRAP; /* single-step trace */
    case 0x11: return TARGET_SIGNAL_TRAP; /* branch trace */
    case 0x12: return TARGET_SIGNAL_TRAP; /* call trace */
    case 0x13: return TARGET_SIGNAL_TRAP; /* return trace */
    case 0x14: return TARGET_SIGNAL_TRAP; /* pre-return trace */
    case 0x15: return TARGET_SIGNAL_TRAP; /* supervisor call trace */
    case 0x16: return TARGET_SIGNAL_TRAP; /* breakpoint trace */
    default: return TARGET_SIGNAL_UNKNOWN;
d689 1
a689 1
/* MEM format				*/
d692 4
a695 3
struct tabent {
	char	*name;
	char	numops;
d698 5
a702 5
static int				/* returns instruction length: 4 or 8 */
mem( memaddr, word1, word2, noprint )
    unsigned long memaddr;
    unsigned long word1, word2;
    int noprint;		/* If TRUE, return instruction length, but
d705 17
a721 17
	int i, j;
	int len;
	int mode;
	int offset;
	const char *reg1, *reg2, *reg3;

	/* This lookup table is too sparse to make it worth typing in, but not
	 * so large as to make a sparse array necessary.  We allocate the
	 * table at runtime, initialize all entries to empty, and copy the
	 * real ones in from an initialization table.
	 *
	 * NOTE: In this table, the meaning of 'numops' is:
	 *	 1: single operand
	 *	 2: 2 operands, load instruction
	 *	-2: 2 operands, store instruction
	 */
	static struct tabent *mem_tab = NULL;
d727 40
a766 32
	static struct { int opcode; char *name; char numops; } mem_init[] = {
		0x80,	"ldob",	 2,
		0x82,	"stob",	-2,
		0x84,	"bx",	 1,
		0x85,	"balx",	 2,
		0x86,	"callx", 1,
		0x88,	"ldos",	 2,
		0x8a,	"stos",	-2,
		0x8c,	"lda",	 2,
		0x90,	"ld",	 2,
		0x92,	"st",	-2,
		0x98,	"ldl",	 2,
		0x9a,	"stl",	-2,
		0xa0,	"ldt",	 2,
		0xa2,	"stt",	-2,
		0xb0,	"ldq",	 2,
		0xb2,	"stq",	-2,
		0xc0,	"ldib",	 2,
		0xc2,	"stib",	-2,
		0xc8,	"ldis",	 2,
		0xca,	"stis",	-2,
		0,	NULL,	0
	};

	if ( mem_tab == NULL ){
		mem_tab = (struct tabent *) xmalloc( MEM_SIZ );
		memset( mem_tab, '\0', MEM_SIZ );
		for ( i = 0; mem_init[i].opcode != 0; i++ ){
			j = mem_init[i].opcode - MEM_MIN;
			mem_tab[j].name = mem_init[i].name;
			mem_tab[j].numops = mem_init[i].numops;
		}
d768 1
d770 2
a771 2
	i = ((word1 >> 24) & 0xff) - MEM_MIN;
	mode = (word1 >> 10) & 0xf;
d773 9
a781 6
	if ( (mem_tab[i].name != NULL)		/* Valid instruction */
	&&   ((mode == 5) || (mode >=12)) ){	/* With 32-bit displacement */
		len = 8;
	} else {
		len = 4;
	}
d783 5
a787 4
	if ( noprint ){
		return len;
	}
	abort ();
d813 1
a813 1
  /* Divide instruction set into classes based on high 4 bits of opcode*/
d818 1
a818 1
    case 0x1:	/* ctrl */
d821 1
a821 1
    case 0x3:	/* cobr */
d825 1
a825 1
    case 0x7:	/* reg */
d837 1
a837 1
    default:	/* invalid instruction */
d856 2
a857 2
    CORE_ADDR chain;
    struct frame_info *curframe;
d859 14
a872 2
	struct symbol *sym;
	struct minimal_symbol *msymbol;
a873 18
	/* crtmon960.o is an assembler module that is assumed to be linked
	 * first in an i80960 executable.  It contains the true entry point;
	 * it performs startup up initialization and then calls 'main'.
	 *
	 * 'sf' is the name of a variable in crtmon960.o that is set
	 *	during startup to the address of the first frame.
	 *
	 * 'a' is the address of that variable in 80960 memory.
	 */
	static char sf[] = "start_frame";
	CORE_ADDR a;


	chain &= ~0x3f; /* Zero low 6 bits because previous frame pointers
			   contain return status info in them.  */
	if ( chain == 0 ){
		return 0;
	}
d875 20
a894 10
	sym = lookup_symbol(sf, 0, VAR_NAMESPACE, (int *)NULL, 
				  (struct symtab **)NULL);
	if ( sym != 0 ){
		a = SYMBOL_VALUE (sym);
	} else {
		msymbol = lookup_minimal_symbol (sf, NULL, NULL);
		if (msymbol == NULL)
			return 0;
		a = SYMBOL_VALUE_ADDRESS (msymbol);
	}
d896 1
a896 1
	return ( chain != read_memory_integer(a,4) );
d898 1
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d584 1
a584 2
      save_addr = fsr.regs[i];
      if (save_addr != 0)
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@d315 1
a315 1
i960_skip_prologue (ip)
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d6 1
a6 1
   This file is part of GDB.
d8 13
a20 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d60 1
a60 1
check_host ()
d62 1
a62 1
  int i;
d64 12
a75 33
  static struct typestruct
    {
      int hostsize;		/* Size of type on host         */
      int i960size;		/* Size of type on i960         */
      char *typename;		/* Name of type, for error msg  */
    }
  types[] =
  {
    {
      sizeof (short), 2, "short"
    }
     ,
    {
      sizeof (int), 4, "int"
    }
     ,
    {
      sizeof (long), 4, "long"
    }
     ,
    {
      sizeof (float), 4, "float"
    }
     ,
    {
      sizeof (double), 8, "double"
    }
     ,
    {
      sizeof (char *), 4, "pointer"
    }
     ,
  };
d78 8
a85 8
  /* Make sure that host type sizes are same as i960
   */
  for (i = 0; i < TYPELEN; i++)
    {
      if (types[i].hostsize != types[i].i960size)
	{
	  printf_unfiltered ("sizeof(%s) != %d:  PROCEED AT YOUR OWN RISK!\n",
			     types[i].typename, types[i].i960size);
a86 2

    }
d110 2
a111 2
   mov g14, g[0-7]
   (mov 0, g14) | (lda 0, g14))?
d118 5
a122 5
   mov sp, g14
   lda 0x30(sp), sp
   LFn: stq g0, (g14)
   stq g4, 0x10(g14)
   stq g8, 0x20(g14))?
d126 1
a126 1
 */
d162 9
a170 9
  static unsigned int varargs_prologue_code[] =
  {
    0x3507a00c,			/* cmpobne 0x0, g14, LFn */
    0x5cf01601,			/* mov sp, g14           */
    0x8c086030,			/* lda 0x30(sp), sp      */
    0xb2879000,			/* LFn: stq  g0, (g14)   */
    0xb2a7a010,			/* stq g4, 0x10(g14)     */
    0xb2c7a020			/* stq g8, 0x20(g14)     */
  };
d178 2
a179 2
      && ((insn1 & 0xfffff000) == 0x8cf00000	/* lda LRx, g14 (MEMA) */
	  || (insn1 & 0xfffffc60) == 0x8cf03000))	/* lda LRx, g14 (MEMB) */
d188 1
a188 1
      && (insn1 & 0xff87ffff) == 0x5c80161e	/* mov g14, gx */
d193 2
a194 2
	  && (insn1 == 0x8cf00000	/* lda 0, g14 */
	      || insn1 == 0x5cf01e00))	/* mov 0, g14 */
d208 1
a208 1

d251 4
a254 4
	 ((insn1 & 0xf787f000) == 0x9287e000	/* stl? gx, n(fp) (MEMA) */
	  || (insn1 & 0xf787fc60) == 0x9287f400		/* stl? gx, n(fp) (MEMB) */
	  || (insn1 & 0xef87f000) == 0xa287e000		/* st[tq] gx, n(fp) (MEMA) */
	  || (insn1 & 0xef87fc60) == 0xa287f400)	/* st[tq] gx, n(fp) (MEMB) */
d260 1
a260 1
	: ((insn1 & BITMASK (27, 1)) ? 2 : 1);
d283 2
a284 2
      ((insn1 & 0xfffff000) == 0x92f7e000	/* st g14, n(fp) (MEMA) */
       || (insn1 & 0xfffffc60) == 0x92f7f400))	/* st g14, n(fp) (MEMB) */
d287 1
a287 1
					    ? insn2 : MEMA_OFFSET (insn1));
d300 1
a300 1
      fsr->regs[G0_REGNUM + 13] = save_addr;
d302 1
a302 1
#if 0				/* We'll need this once there is a subsequent instruction examined. */
d316 1
a316 1
CORE_ADDR (ip);
d358 3
a360 3
         is in the function prologue, we only consider the part that
         has executed already.  */

d363 1
a363 1
      limit = (sal.end && sal.end < fi->pc) ? sal.end : fi->pc;
d368 3
a370 3
         Strictly speaking, we should only do this for non-leaf procedures,
         but no one will ever look at these values if it is a leaf procedure,
         since local registers are always caller-saved.  */
d394 1
a394 1
     -- markf@@wrs.com 
d418 1
a418 1
    ap = read_memory_integer (fsr.regs[G14_REGNUM], 4);
d422 1
a422 1
	return 0;		/* Don't cache this result */
d456 1
a456 1
	ap = read_memory_integer (fsr.regs[G13_REGNUM], 4);
d468 1
a468 1

d478 1
a478 1
     CORE_ADDR ip;		/* ip from currently executing function */
d488 1
a488 1
      if ((p = strchr (SYMBOL_NAME (msymbol), '.')) && STREQ (p, ".lf"))
d491 1
a491 1
	      && (insn1 & 0xff87ffff) == 0x5c80161e	/* mov g14, gx */
d495 3
a497 3
	         instruction hasn't been executed yet, read
	         the return address from g14; otherwise, read it
	         from the register into which g14 was moved.  */
d500 2
a501 2
		read_register ((ip == SYMBOL_VALUE_ADDRESS (msymbol))
			       ? G14_REGNUM : dst);
d504 6
a509 6
	         whether the caller actually did a "bal" to the ".lf"
	         entry point, or a normal "call" to the non-leaf entry
	         point one instruction before.  In the latter case, the
	         return address will be the address of a "ret"
	         instruction within the procedure itself.  We test for
	         this below.  */
d512 2
a513 2
		  || (insn1 & 0xff000000) != 0xa000000	/* ret */
		  || lookup_minimal_symbol_by_pc (return_addr) != msymbol)
d518 1
a518 1

d568 2
a569 2
      write_register_bytes (REGISTER_BYTE (R0_REGNUM), local_regs_buf,
			    sizeof (local_regs_buf));
d600 1
a600 1
     int fault;
d604 5
a608 10
    case 0:
      return TARGET_SIGNAL_BUS;	/* parallel fault */
    case 1:
      return TARGET_SIGNAL_UNKNOWN;
    case 2:
      return TARGET_SIGNAL_ILL;	/* operation fault */
    case 3:
      return TARGET_SIGNAL_FPE;	/* arithmetic fault */
    case 4:
      return TARGET_SIGNAL_FPE;	/* floating point fault */
d611 3
a613 4
         a range constraint fault (which should be SIGFPE) and a privileged
         fault (which should be SIGILL).  */
    case 5:
      return TARGET_SIGNAL_ILL;
d615 1
a615 2
    case 6:
      return TARGET_SIGNAL_SEGV;	/* virtual memory fault */
d618 19
a636 36
         "calls".  I guess it also could be SIGILL. */
    case 7:
      return TARGET_SIGNAL_SEGV;

    case 8:
      return TARGET_SIGNAL_BUS;	/* machine fault */
    case 9:
      return TARGET_SIGNAL_BUS;	/* structural fault */
    case 0xa:
      return TARGET_SIGNAL_ILL;	/* type fault */
    case 0xb:
      return TARGET_SIGNAL_UNKNOWN;	/* reserved fault */
    case 0xc:
      return TARGET_SIGNAL_BUS;	/* process fault */
    case 0xd:
      return TARGET_SIGNAL_SEGV;	/* descriptor fault */
    case 0xe:
      return TARGET_SIGNAL_BUS;	/* event fault */
    case 0xf:
      return TARGET_SIGNAL_UNKNOWN;	/* reserved fault */
    case 0x10:
      return TARGET_SIGNAL_TRAP;	/* single-step trace */
    case 0x11:
      return TARGET_SIGNAL_TRAP;	/* branch trace */
    case 0x12:
      return TARGET_SIGNAL_TRAP;	/* call trace */
    case 0x13:
      return TARGET_SIGNAL_TRAP;	/* return trace */
    case 0x14:
      return TARGET_SIGNAL_TRAP;	/* pre-return trace */
    case 0x15:
      return TARGET_SIGNAL_TRAP;	/* supervisor call trace */
    case 0x16:
      return TARGET_SIGNAL_TRAP;	/* breakpoint trace */
    default:
      return TARGET_SIGNAL_UNKNOWN;
d641 1
a641 1
/* MEM format                           */
d644 3
a646 4
struct tabent
{
  char *name;
  char numops;
d649 5
a653 5
static int			/* returns instruction length: 4 or 8 */
mem (memaddr, word1, word2, noprint)
     unsigned long memaddr;
     unsigned long word1, word2;
     int noprint;		/* If TRUE, return instruction length, but
d656 17
a672 17
  int i, j;
  int len;
  int mode;
  int offset;
  const char *reg1, *reg2, *reg3;

  /* This lookup table is too sparse to make it worth typing in, but not
   * so large as to make a sparse array necessary.  We allocate the
   * table at runtime, initialize all entries to empty, and copy the
   * real ones in from an initialization table.
   *
   * NOTE: In this table, the meaning of 'numops' is:
   *       1: single operand
   *       2: 2 operands, load instruction
   *      -2: 2 operands, store instruction
   */
  static struct tabent *mem_tab = NULL;
d678 32
a709 40
  static struct
    {
      int opcode;
      char *name;
      char numops;
    }
  mem_init[] =
  {
    0x80, "ldob", 2,
      0x82, "stob", -2,
      0x84, "bx", 1,
      0x85, "balx", 2,
      0x86, "callx", 1,
      0x88, "ldos", 2,
      0x8a, "stos", -2,
      0x8c, "lda", 2,
      0x90, "ld", 2,
      0x92, "st", -2,
      0x98, "ldl", 2,
      0x9a, "stl", -2,
      0xa0, "ldt", 2,
      0xa2, "stt", -2,
      0xb0, "ldq", 2,
      0xb2, "stq", -2,
      0xc0, "ldib", 2,
      0xc2, "stib", -2,
      0xc8, "ldis", 2,
      0xca, "stis", -2,
      0, NULL, 0
  };

  if (mem_tab == NULL)
    {
      mem_tab = (struct tabent *) xmalloc (MEM_SIZ);
      memset (mem_tab, '\0', MEM_SIZ);
      for (i = 0; mem_init[i].opcode != 0; i++)
	{
	  j = mem_init[i].opcode - MEM_MIN;
	  mem_tab[j].name = mem_init[i].name;
	  mem_tab[j].numops = mem_init[i].numops;
a710 1
    }
d712 2
a713 2
  i = ((word1 >> 24) & 0xff) - MEM_MIN;
  mode = (word1 >> 10) & 0xf;
d715 6
a720 9
  if ((mem_tab[i].name != NULL)	/* Valid instruction */
      && ((mode == 5) || (mode >= 12)))
    {				/* With 32-bit displacement */
      len = 8;
    }
  else
    {
      len = 4;
    }
d722 4
a725 5
  if (noprint)
    {
      return len;
    }
  abort ();
d751 1
a751 1
  /* Divide instruction set into classes based on high 4 bits of opcode */
d756 1
a756 1
    case 0x1:			/* ctrl */
d759 1
a759 1
    case 0x3:			/* cobr */
d763 1
a763 1
    case 0x7:			/* reg */
d775 1
a775 1
    default:			/* invalid instruction */
d794 2
a795 2
     CORE_ADDR chain;
     struct frame_info *curframe;
d797 2
a798 2
  struct symbol *sym;
  struct minimal_symbol *msymbol;
d800 18
a817 11
  /* crtmon960.o is an assembler module that is assumed to be linked
   * first in an i80960 executable.  It contains the true entry point;
   * it performs startup up initialization and then calls 'main'.
   *
   * 'sf' is the name of a variable in crtmon960.o that is set
   *      during startup to the address of the first frame.
   *
   * 'a' is the address of that variable in 80960 memory.
   */
  static char sf[] = "start_frame";
  CORE_ADDR a;
d819 10
d830 1
a830 22
  chain &= ~0x3f;		/* Zero low 6 bits because previous frame pointers
				   contain return status info in them.  */
  if (chain == 0)
    {
      return 0;
    }

  sym = lookup_symbol (sf, 0, VAR_NAMESPACE, (int *) NULL,
		       (struct symtab **) NULL);
  if (sym != 0)
    {
      a = SYMBOL_VALUE (sym);
    }
  else
    {
      msymbol = lookup_minimal_symbol (sf, NULL, NULL);
      if (msymbol == NULL)
	return 0;
      a = SYMBOL_VALUE_ADDRESS (msymbol);
    }

  return (chain != read_memory_integer (a, 4));
@


1.1.1.5
log
@import gdb-1999-09-08 snapshot
@
text
@d570 1
a570 1
i960_pop_frame (void)
@


1.1.1.6
log
@import gdb-1999-10-04 snapshot
@
text
@a29 1
#include "inferior.h"
a897 1

@


