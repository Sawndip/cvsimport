head	1.6;
access;
symbols
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.10
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.8
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.6
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.4
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.2
	readline_4_3-import-branchpoint:1.5
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.16
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.14
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.12
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.10
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.8
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.6
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.4
	gdb_5_1-2001-07-29-branchpoint:1.4
	dberlin-typesystem-branch:1.4.0.2
	dberlin-typesystem-branchpoint:1.4
	gdb-post-ptid_t-2001-05-03:1.4
	gdb-pre-ptid_t-2001-05-03:1.4
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb-post-params-removal-2000-06-04:1.1.1.2
	gdb-pre-params-removal-2000-06-04:1.1.1.2
	gdb-post-params-removal-2000-05-28:1.1.1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.6
date	2002.12.16.20.39.06;	author cagney;	state dead;
branches;
next	1.5;

1.5
date	2002.08.18.16.32.14;	author kettenis;	state Exp;
branches
	1.5.8.1
	1.5.10.1;
next	1.4;

1.4
date	2001.03.06.08.21.08;	author kevinb;	state Exp;
branches
	1.4.16.1;
next	1.3;

1.3
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.07.01;	author jsm;	state Exp;
branches;
next	;

1.4.16.1
date	2002.08.30.22.52.44;	author kseitz;	state Exp;
branches;
next	;

1.5.8.1
date	2002.12.23.19.38.29;	author carlton;	state dead;
branches;
next	;

1.5.10.1
date	2003.12.14.20.27.17;	author drow;	state dead;
branches;
next	;


desc
@@


1.6
log
@2002-12-16  Andrew Cagney  <ac131313@@redhat.com>

	* config/arc/arc.mt, config/arc/tm-arc.h: Delete.
	* config/d30v/d30v.mt, config/d30v/tm-d30v.h: Delete.
	* config/fr30/fr30.mt, config/fr30/tm-fr30.h: Delete.
	* config/i386/i386aix.mh, config/i386/i386aix.mt: Delete.
	* config/i386/i386m3.mh, config/i386/i386m3.mt: Delete.
	* config/i386/i386mach.mh, config/i386/i386os9k.mt: Delete.
	* config/i386/nm-i386aix.h, config/i386/nm-i386mach.h: Delete.
	* config/i386/nm-m3.h, config/i386/tm-i386aix.h: Delete.
	* config/i386/tm-i386m3.h, config/i386/tm-i386mk.h: Delete.
	* config/i386/xm-i386aix.h, config/i386/xm-i386m3.h: Delete.
	* config/i386/xm-i386mach.h, config/i386/xm-i386mk.h: Delete.
	* config/i960/mon960.mt, config/i960/nindy960.mt: Delete.
	* config/i960/tm-i960.h, config/i960/tm-mon960.h: Delete.
	* config/i960/tm-nindy960.h, config/i960/tm-vx960.h: Delete.
	* config/i960/vxworks960.mt, config/m68k/apollo68b.mh: Delete.
	* config/m68k/apollo68b.mt, config/m68k/apollo68v.mh: Delete.
	* config/m68k/hp300bsd.mh, config/m68k/hp300bsd.mt: Delete.
	* config/m68k/hp300hpux.mh, config/m68k/hp300hpux.mt: Delete.
	* config/m88k/delta88.mh, config/m88k/delta88.mt: Delete.
	* config/m88k/delta88v4.mh, config/m88k/delta88v4.mt: Delete.
	* config/m88k/m88k.mh, config/m88k/m88k.mt: Delete.
	* config/m88k/nm-delta88v4.h, config/m88k/nm-m88k.h: Delete.
	* config/m88k/tm-delta88.h, config/m88k/tm-delta88v4.h: Delete.
	* config/m88k/tm-m88k.h, config/m88k/xm-delta88.h: Delete.
	* config/m88k/xm-dgux.h: Delete.
	* fr30-tdep.c, i386aix-nat.c, i386m3-nat.c: Delete.
	* i386mach-nat.c, i960-tdep.c, m88k-nat.c: Delete.
	* os9kread.c, remote-bug.c, remote-nindy.c: Delete.
	* remote-nrom.c, remote-os9k.c, remote-vx960.c: Delete.
	* d30v-tdep.c, arc-tdep.c, cxux-nat.c, dst.h, dstread.c: Delete.
	* ch-exp.c, ch-lang.c, ch-lang.h, ch-typeprint.c: Delete.
	* ch-valprint.c: Delete.
@
text
@// OBSOLETE /* Low level interface to I386 running mach 3.0.
// OBSOLETE    Copyright 1992, 1993, 1994, 1996, 2000, 2001
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "floatformat.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #include <stdio.h>
// OBSOLETE 
// OBSOLETE #include <mach.h>
// OBSOLETE #include <mach/message.h>
// OBSOLETE #include <mach/exception.h>
// OBSOLETE #include <mach_error.h>
// OBSOLETE 
// OBSOLETE /* Hmmm... Should this not be here?
// OBSOLETE  * Now for i386_float_info() target_has_execution
// OBSOLETE  */
// OBSOLETE #include <target.h>
// OBSOLETE 
// OBSOLETE /* This mess is duplicated in bfd/i386mach3.h
// OBSOLETE 
// OBSOLETE  * This is an ugly way to hack around the incorrect
// OBSOLETE  * definition of UPAGES in i386/machparam.h.
// OBSOLETE  *
// OBSOLETE  * The definition should specify the size reserved
// OBSOLETE  * for "struct user" in core files in PAGES,
// OBSOLETE  * but instead it gives it in 512-byte core-clicks
// OBSOLETE  * for i386 and i860.
// OBSOLETE  */
// OBSOLETE #include <sys/param.h>
// OBSOLETE #if UPAGES == 16
// OBSOLETE #define UAREA_SIZE ctob(UPAGES)
// OBSOLETE #elif UPAGES == 2
// OBSOLETE #define UAREA_SIZE (NBPG*UPAGES)
// OBSOLETE #else
// OBSOLETE FIXME ! !UPAGES is neither 2 nor 16
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /* @@@@@@ Should move print_387_status() to i387-tdep.c */
// OBSOLETE extern void print_387_control_word ();		/* i387-tdep.h */
// OBSOLETE extern void print_387_status_word ();
// OBSOLETE 
// OBSOLETE #define private static
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Find offsets to thread states at compile time.
// OBSOLETE  * If your compiler does not grok this, calculate offsets
// OBSOLETE  * offsets yourself and use them (or get a compatible compiler :-)
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #define  REG_OFFSET(reg) (int)(&((struct i386_thread_state *)0)->reg)
// OBSOLETE 
// OBSOLETE /* at reg_offset[i] is the offset to the i386_thread_state
// OBSOLETE  * location where the gdb registers[i] is stored.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static int reg_offset[] =
// OBSOLETE {
// OBSOLETE   REG_OFFSET (eax), REG_OFFSET (ecx), REG_OFFSET (edx), REG_OFFSET (ebx),
// OBSOLETE   REG_OFFSET (uesp), REG_OFFSET (ebp), REG_OFFSET (esi), REG_OFFSET (edi),
// OBSOLETE   REG_OFFSET (eip), REG_OFFSET (efl), REG_OFFSET (cs), REG_OFFSET (ss),
// OBSOLETE   REG_OFFSET (ds), REG_OFFSET (es), REG_OFFSET (fs), REG_OFFSET (gs)
// OBSOLETE };
// OBSOLETE 
// OBSOLETE #define REG_ADDRESS(state,regnum) ((char *)(state)+reg_offset[regnum])
// OBSOLETE 
// OBSOLETE /* Fetch COUNT contiguous registers from thread STATE starting from REGNUM
// OBSOLETE  * Caller knows that the regs handled in one transaction are of same size.
// OBSOLETE  */
// OBSOLETE #define FETCH_REGS(state, regnum, count) \
// OBSOLETE   memcpy (&registers[REGISTER_BYTE (regnum)], \
// OBSOLETE 	  REG_ADDRESS (state, regnum), \
// OBSOLETE 	  count*REGISTER_SIZE)
// OBSOLETE 
// OBSOLETE /* Store COUNT contiguous registers to thread STATE starting from REGNUM */
// OBSOLETE #define STORE_REGS(state, regnum, count) \
// OBSOLETE   memcpy (REG_ADDRESS (state, regnum), \
// OBSOLETE 	  &registers[REGISTER_BYTE (regnum)], \
// OBSOLETE 	  count*REGISTER_SIZE)
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Fetch inferiors registers for gdb.
// OBSOLETE  * REGNO specifies which (as gdb views it) register, -1 for all.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fetch_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_state_data_t state;
// OBSOLETE   unsigned int stateCnt = i386_THREAD_STATE_COUNT;
// OBSOLETE   int index;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (current_thread))
// OBSOLETE     error ("fetch inferior registers: Invalid thread");
// OBSOLETE 
// OBSOLETE   if (must_suspend_thread)
// OBSOLETE     setup_thread (current_thread, 1);
// OBSOLETE 
// OBSOLETE   ret = thread_get_state (current_thread,
// OBSOLETE 			  i386_THREAD_STATE,
// OBSOLETE 			  state,
// OBSOLETE 			  &stateCnt);
// OBSOLETE 
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("fetch_inferior_registers: %s ",
// OBSOLETE 	     mach_error_string (ret));
// OBSOLETE #if 0
// OBSOLETE   /* It may be more effective to store validate all of them,
// OBSOLETE    * since we fetched them all anyway
// OBSOLETE    */
// OBSOLETE   else if (regno != -1)
// OBSOLETE     supply_register (regno, (char *) state + reg_offset[regno]);
// OBSOLETE #endif
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       for (index = 0; index < NUM_REGS; index++)
// OBSOLETE 	supply_register (index, (char *) state + reg_offset[index]);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (must_suspend_thread)
// OBSOLETE     setup_thread (current_thread, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store our register values back into the inferior.
// OBSOLETE  * If REGNO is -1, do this for all registers.
// OBSOLETE  * Otherwise, REGNO specifies which register
// OBSOLETE  *
// OBSOLETE  * On mach3 all registers are always saved in one call.
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE store_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_state_data_t state;
// OBSOLETE   unsigned int stateCnt = i386_THREAD_STATE_COUNT;
// OBSOLETE   register int index;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (current_thread))
// OBSOLETE     error ("store inferior registers: Invalid thread");
// OBSOLETE 
// OBSOLETE   if (must_suspend_thread)
// OBSOLETE     setup_thread (current_thread, 1);
// OBSOLETE 
// OBSOLETE   /* Fetch the state of the current thread */
// OBSOLETE   ret = thread_get_state (current_thread,
// OBSOLETE 			  i386_THREAD_STATE,
// OBSOLETE 			  state,
// OBSOLETE 			  &stateCnt);
// OBSOLETE 
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("store_inferior_registers (get): %s",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE       if (must_suspend_thread)
// OBSOLETE 	setup_thread (current_thread, 0);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* move gdb's registers to thread's state
// OBSOLETE 
// OBSOLETE    * Since we save all registers anyway, save the ones
// OBSOLETE    * that gdb thinks are valid (e.g. ignore the regno
// OBSOLETE    * parameter)
// OBSOLETE    */
// OBSOLETE #if 0
// OBSOLETE   if (regno != -1)
// OBSOLETE     STORE_REGS (state, regno, 1);
// OBSOLETE   else
// OBSOLETE #endif
// OBSOLETE     {
// OBSOLETE       for (index = 0; index < NUM_REGS; index++)
// OBSOLETE 	STORE_REGS (state, index, 1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Write gdb's current view of register to the thread
// OBSOLETE    */
// OBSOLETE   ret = thread_set_state (current_thread,
// OBSOLETE 			  i386_THREAD_STATE,
// OBSOLETE 			  state,
// OBSOLETE 			  i386_THREAD_STATE_COUNT);
// OBSOLETE 
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("store_inferior_registers (set): %s",
// OBSOLETE 	     mach_error_string (ret));
// OBSOLETE 
// OBSOLETE   if (must_suspend_thread)
// OBSOLETE     setup_thread (current_thread, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Return the address in the core dump or inferior of register REGNO.
// OBSOLETE  * BLOCKEND should be the address of the end of the UPAGES area read
// OBSOLETE  * in memory, but it's not?
// OBSOLETE  *
// OBSOLETE  * Currently our UX server dumps the whole thread state to the
// OBSOLETE  * core file. If your UX does something else, adapt the routine
// OBSOLETE  * below to return the offset to the given register.
// OBSOLETE  * 
// OBSOLETE  * Called by core-aout.c(fetch_core_registers)
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE register_addr (int regno, CORE_ADDR blockend)
// OBSOLETE {
// OBSOLETE   CORE_ADDR addr;
// OBSOLETE 
// OBSOLETE   if (regno < 0 || regno >= NUM_REGS)
// OBSOLETE     error ("Invalid register number %d.", regno);
// OBSOLETE 
// OBSOLETE   /* UAREA_SIZE == 8 kB in i386 */
// OBSOLETE   addr = (unsigned int) REG_ADDRESS (UAREA_SIZE - sizeof (struct i386_thread_state), regno);
// OBSOLETE 
// OBSOLETE   return addr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* jtv@@hut.fi: I copied and modified this 387 code from
// OBSOLETE  * gdb/i386-xdep.c. Modifications for Mach 3.0.
// OBSOLETE  *
// OBSOLETE  * i387 status dumper. See also i387-tdep.c
// OBSOLETE  */
// OBSOLETE struct env387
// OBSOLETE {
// OBSOLETE   unsigned short control;
// OBSOLETE   unsigned short r0;
// OBSOLETE   unsigned short status;
// OBSOLETE   unsigned short r1;
// OBSOLETE   unsigned short tag;
// OBSOLETE   unsigned short r2;
// OBSOLETE   unsigned long eip;
// OBSOLETE   unsigned short code_seg;
// OBSOLETE   unsigned short opcode;
// OBSOLETE   unsigned long operand;
// OBSOLETE   unsigned short operand_seg;
// OBSOLETE   unsigned short r3;
// OBSOLETE   unsigned char regs[8][10];
// OBSOLETE };
// OBSOLETE /* This routine is machine independent?
// OBSOLETE  * Should move it to i387-tdep.c but you need to export struct env387
// OBSOLETE  */
// OBSOLETE private
// OBSOLETE print_387_status (unsigned short status, struct env387 *ep)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   int bothstatus;
// OBSOLETE   int top;
// OBSOLETE   int fpreg;
// OBSOLETE   unsigned char *p;
// OBSOLETE 
// OBSOLETE   bothstatus = ((status != 0) && (ep->status != 0));
// OBSOLETE   if (status != 0)
// OBSOLETE     {
// OBSOLETE       if (bothstatus)
// OBSOLETE 	printf_unfiltered ("u: ");
// OBSOLETE       print_387_status_word (status);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (ep->status != 0)
// OBSOLETE     {
// OBSOLETE       if (bothstatus)
// OBSOLETE 	printf_unfiltered ("e: ");
// OBSOLETE       print_387_status_word (ep->status);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   print_387_control_word (ep->control);
// OBSOLETE   printf_unfiltered ("last exception: ");
// OBSOLETE   printf_unfiltered ("opcode %s; ", local_hex_string (ep->opcode));
// OBSOLETE   printf_unfiltered ("pc %s:", local_hex_string (ep->code_seg));
// OBSOLETE   printf_unfiltered ("%s; ", local_hex_string (ep->eip));
// OBSOLETE   printf_unfiltered ("operand %s", local_hex_string (ep->operand_seg));
// OBSOLETE   printf_unfiltered (":%s\n", local_hex_string (ep->operand));
// OBSOLETE 
// OBSOLETE   top = (ep->status >> 11) & 7;
// OBSOLETE 
// OBSOLETE   printf_unfiltered ("regno  tag  msb              lsb  value\n");
// OBSOLETE   for (fpreg = 7; fpreg >= 0; fpreg--)
// OBSOLETE     {
// OBSOLETE       double val;
// OBSOLETE 
// OBSOLETE       printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg);
// OBSOLETE 
// OBSOLETE       switch ((ep->tag >> (fpreg * 2)) & 3)
// OBSOLETE 	{
// OBSOLETE 	case 0:
// OBSOLETE 	  printf_unfiltered ("valid ");
// OBSOLETE 	  break;
// OBSOLETE 	case 1:
// OBSOLETE 	  printf_unfiltered ("zero  ");
// OBSOLETE 	  break;
// OBSOLETE 	case 2:
// OBSOLETE 	  printf_unfiltered ("trap  ");
// OBSOLETE 	  break;
// OBSOLETE 	case 3:
// OBSOLETE 	  printf_unfiltered ("empty ");
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       for (i = 9; i >= 0; i--)
// OBSOLETE 	printf_unfiltered ("%02x", ep->regs[fpreg][i]);
// OBSOLETE 
// OBSOLETE       floatformat_to_double (&floatformat_i387_ext, (char *) ep->regs[fpreg],
// OBSOLETE 			     &val);
// OBSOLETE       printf_unfiltered ("  %g\n", val);
// OBSOLETE     }
// OBSOLETE   if (ep->r0)
// OBSOLETE     printf_unfiltered ("warning: reserved0 is %s\n", local_hex_string (ep->r0));
// OBSOLETE   if (ep->r1)
// OBSOLETE     printf_unfiltered ("warning: reserved1 is %s\n", local_hex_string (ep->r1));
// OBSOLETE   if (ep->r2)
// OBSOLETE     printf_unfiltered ("warning: reserved2 is %s\n", local_hex_string (ep->r2));
// OBSOLETE   if (ep->r3)
// OBSOLETE     printf_unfiltered ("warning: reserved3 is %s\n", local_hex_string (ep->r3));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * values that go into fp_kind (from <i386/fpreg.h>)
// OBSOLETE  */
// OBSOLETE #define FP_NO   0		/* no fp chip, no emulator (no fp support)      */
// OBSOLETE #define FP_SW   1		/* no fp chip, using software emulator          */
// OBSOLETE #define FP_HW   2		/* chip present bit                             */
// OBSOLETE #define FP_287  2		/* 80287 chip present                           */
// OBSOLETE #define FP_387  3		/* 80387 chip present                           */
// OBSOLETE 
// OBSOLETE typedef struct fpstate
// OBSOLETE {
// OBSOLETE #if 1
// OBSOLETE   unsigned char state[FP_STATE_BYTES];	/* "hardware" state */
// OBSOLETE #else
// OBSOLETE   struct env387 state;		/* Actually this */
// OBSOLETE #endif
// OBSOLETE   int status;			/* Duplicate status */
// OBSOLETE }
// OBSOLETE  *fpstate_t;
// OBSOLETE 
// OBSOLETE /* Mach 3 specific routines.
// OBSOLETE  */
// OBSOLETE private boolean_t
// OBSOLETE get_i387_state (struct fpstate *fstate)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_state_data_t state;
// OBSOLETE   unsigned int fsCnt = i386_FLOAT_STATE_COUNT;
// OBSOLETE   struct i386_float_state *fsp;
// OBSOLETE 
// OBSOLETE   ret = thread_get_state (current_thread,
// OBSOLETE 			  i386_FLOAT_STATE,
// OBSOLETE 			  state,
// OBSOLETE 			  &fsCnt);
// OBSOLETE 
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("Can not get live floating point state: %s",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE       return FALSE;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   fsp = (struct i386_float_state *) state;
// OBSOLETE   /* The 387 chip (also 486 counts) or a software emulator? */
// OBSOLETE   if (!fsp->initialized || (fsp->fpkind != FP_387 && fsp->fpkind != FP_SW))
// OBSOLETE     return FALSE;
// OBSOLETE 
// OBSOLETE   /* Clear the target then copy thread's float state there.
// OBSOLETE      Make a copy of the status word, for some reason?
// OBSOLETE    */
// OBSOLETE   memset (fstate, 0, sizeof (struct fpstate));
// OBSOLETE 
// OBSOLETE   fstate->status = fsp->exc_status;
// OBSOLETE 
// OBSOLETE   memcpy (fstate->state, (char *) &fsp->hw_state, FP_STATE_BYTES);
// OBSOLETE 
// OBSOLETE   return TRUE;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE private boolean_t
// OBSOLETE get_i387_core_state (struct fpstate *fstate)
// OBSOLETE {
// OBSOLETE   /* Not implemented yet. Core files do not contain float state. */
// OBSOLETE   return FALSE;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * This is called by "info float" command
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE i386_mach3_float_info (void)
// OBSOLETE {
// OBSOLETE   char buf[sizeof (struct fpstate) + 2 * sizeof (int)];
// OBSOLETE   boolean_t valid = FALSE;
// OBSOLETE   fpstate_t fps;
// OBSOLETE 
// OBSOLETE   if (target_has_execution)
// OBSOLETE     valid = get_i387_state (buf);
// OBSOLETE #if 0
// OBSOLETE   else if (WE HAVE CORE FILE)	/* @@@@@@@@ Core files not supported */
// OBSOLETE     valid = get_i387_core_state (buf);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   if (!valid)
// OBSOLETE     {
// OBSOLETE       warning ("no floating point status saved");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   fps = (fpstate_t) buf;
// OBSOLETE 
// OBSOLETE   print_387_status (fps->status, (struct env387 *) fps->state);
// OBSOLETE }
@


1.5
log
@* NEWS: Mention that the i[3456]-*mach3*, i[3456]-*-mach* and
i[3456]-*-osf1mk* configurations have been made obsolete.
* configure.host: Make i[3456]86-*-mach3*, i[3456]86-*mach* and
i[3456]86-*-osf1mk* hosts obsolete.
* confighure.tgt: Make i[3456]86-*-mach3*, i[3456]86-*-osf1mk*
targets obsolete.
* config/i386/i386mach.mh, config/i386/nm-i386mach.h,
config/i386/xm-i386mach.h, config/i386/i386m3.mh,
config/i386/i386m3.mt, config/i386/nm-m3.h,
config/i386/tm-i386m3.h, config/i386/xm-i386m3.h,
config/i386/i386mk.mh, config/i386/i386mk.mt,
config/i386/tm-i386mk.h, config/i386/xm-i386mk.h: Make files
obsolete.
* i386mach-nat.c, i386m3-nat.c: Make files obsolete.
* Makefile.in (ALLDEPFILES): Remove i386mach.c i386m3-nat.c
(i386mach-nat.o, i386m3-nat.o):Make targets obsolete.
@
text
@@


1.5.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.5.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.4
log
@Update/correct copyright notices.
@
text
@d1 426
a426 426
/* Low level interface to I386 running mach 3.0.
   Copyright 1992, 1993, 1994, 1996, 2000, 2001
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "inferior.h"
#include "floatformat.h"
#include "regcache.h"

#include <stdio.h>

#include <mach.h>
#include <mach/message.h>
#include <mach/exception.h>
#include <mach_error.h>

/* Hmmm... Should this not be here?
 * Now for i386_float_info() target_has_execution
 */
#include <target.h>

/* This mess is duplicated in bfd/i386mach3.h

 * This is an ugly way to hack around the incorrect
 * definition of UPAGES in i386/machparam.h.
 *
 * The definition should specify the size reserved
 * for "struct user" in core files in PAGES,
 * but instead it gives it in 512-byte core-clicks
 * for i386 and i860.
 */
#include <sys/param.h>
#if UPAGES == 16
#define UAREA_SIZE ctob(UPAGES)
#elif UPAGES == 2
#define UAREA_SIZE (NBPG*UPAGES)
#else
FIXME ! !UPAGES is neither 2 nor 16
#endif

/* @@@@@@ Should move print_387_status() to i387-tdep.c */
extern void print_387_control_word ();		/* i387-tdep.h */
extern void print_387_status_word ();

#define private static


/* Find offsets to thread states at compile time.
 * If your compiler does not grok this, calculate offsets
 * offsets yourself and use them (or get a compatible compiler :-)
 */

#define  REG_OFFSET(reg) (int)(&((struct i386_thread_state *)0)->reg)

/* at reg_offset[i] is the offset to the i386_thread_state
 * location where the gdb registers[i] is stored.
 */

static int reg_offset[] =
{
  REG_OFFSET (eax), REG_OFFSET (ecx), REG_OFFSET (edx), REG_OFFSET (ebx),
  REG_OFFSET (uesp), REG_OFFSET (ebp), REG_OFFSET (esi), REG_OFFSET (edi),
  REG_OFFSET (eip), REG_OFFSET (efl), REG_OFFSET (cs), REG_OFFSET (ss),
  REG_OFFSET (ds), REG_OFFSET (es), REG_OFFSET (fs), REG_OFFSET (gs)
};

#define REG_ADDRESS(state,regnum) ((char *)(state)+reg_offset[regnum])

/* Fetch COUNT contiguous registers from thread STATE starting from REGNUM
 * Caller knows that the regs handled in one transaction are of same size.
 */
#define FETCH_REGS(state, regnum, count) \
  memcpy (&registers[REGISTER_BYTE (regnum)], \
	  REG_ADDRESS (state, regnum), \
	  count*REGISTER_SIZE)

/* Store COUNT contiguous registers to thread STATE starting from REGNUM */
#define STORE_REGS(state, regnum, count) \
  memcpy (REG_ADDRESS (state, regnum), \
	  &registers[REGISTER_BYTE (regnum)], \
	  count*REGISTER_SIZE)

/*
 * Fetch inferiors registers for gdb.
 * REGNO specifies which (as gdb views it) register, -1 for all.
 */

void
fetch_inferior_registers (int regno)
{
  kern_return_t ret;
  thread_state_data_t state;
  unsigned int stateCnt = i386_THREAD_STATE_COUNT;
  int index;

  if (!MACH_PORT_VALID (current_thread))
    error ("fetch inferior registers: Invalid thread");

  if (must_suspend_thread)
    setup_thread (current_thread, 1);

  ret = thread_get_state (current_thread,
			  i386_THREAD_STATE,
			  state,
			  &stateCnt);

  if (ret != KERN_SUCCESS)
    warning ("fetch_inferior_registers: %s ",
	     mach_error_string (ret));
#if 0
  /* It may be more effective to store validate all of them,
   * since we fetched them all anyway
   */
  else if (regno != -1)
    supply_register (regno, (char *) state + reg_offset[regno]);
#endif
  else
    {
      for (index = 0; index < NUM_REGS; index++)
	supply_register (index, (char *) state + reg_offset[index]);
    }

  if (must_suspend_thread)
    setup_thread (current_thread, 0);
}

/* Store our register values back into the inferior.
 * If REGNO is -1, do this for all registers.
 * Otherwise, REGNO specifies which register
 *
 * On mach3 all registers are always saved in one call.
 */
void
store_inferior_registers (int regno)
{
  kern_return_t ret;
  thread_state_data_t state;
  unsigned int stateCnt = i386_THREAD_STATE_COUNT;
  register int index;

  if (!MACH_PORT_VALID (current_thread))
    error ("store inferior registers: Invalid thread");

  if (must_suspend_thread)
    setup_thread (current_thread, 1);

  /* Fetch the state of the current thread */
  ret = thread_get_state (current_thread,
			  i386_THREAD_STATE,
			  state,
			  &stateCnt);

  if (ret != KERN_SUCCESS)
    {
      warning ("store_inferior_registers (get): %s",
	       mach_error_string (ret));
      if (must_suspend_thread)
	setup_thread (current_thread, 0);
      return;
    }

  /* move gdb's registers to thread's state

   * Since we save all registers anyway, save the ones
   * that gdb thinks are valid (e.g. ignore the regno
   * parameter)
   */
#if 0
  if (regno != -1)
    STORE_REGS (state, regno, 1);
  else
#endif
    {
      for (index = 0; index < NUM_REGS; index++)
	STORE_REGS (state, index, 1);
    }

  /* Write gdb's current view of register to the thread
   */
  ret = thread_set_state (current_thread,
			  i386_THREAD_STATE,
			  state,
			  i386_THREAD_STATE_COUNT);

  if (ret != KERN_SUCCESS)
    warning ("store_inferior_registers (set): %s",
	     mach_error_string (ret));

  if (must_suspend_thread)
    setup_thread (current_thread, 0);
}



/* Return the address in the core dump or inferior of register REGNO.
 * BLOCKEND should be the address of the end of the UPAGES area read
 * in memory, but it's not?
 *
 * Currently our UX server dumps the whole thread state to the
 * core file. If your UX does something else, adapt the routine
 * below to return the offset to the given register.
 * 
 * Called by core-aout.c(fetch_core_registers)
 */

CORE_ADDR
register_addr (int regno, CORE_ADDR blockend)
{
  CORE_ADDR addr;

  if (regno < 0 || regno >= NUM_REGS)
    error ("Invalid register number %d.", regno);

  /* UAREA_SIZE == 8 kB in i386 */
  addr = (unsigned int) REG_ADDRESS (UAREA_SIZE - sizeof (struct i386_thread_state), regno);

  return addr;
}

/* jtv@@hut.fi: I copied and modified this 387 code from
 * gdb/i386-xdep.c. Modifications for Mach 3.0.
 *
 * i387 status dumper. See also i387-tdep.c
 */
struct env387
{
  unsigned short control;
  unsigned short r0;
  unsigned short status;
  unsigned short r1;
  unsigned short tag;
  unsigned short r2;
  unsigned long eip;
  unsigned short code_seg;
  unsigned short opcode;
  unsigned long operand;
  unsigned short operand_seg;
  unsigned short r3;
  unsigned char regs[8][10];
};
/* This routine is machine independent?
 * Should move it to i387-tdep.c but you need to export struct env387
 */
private
print_387_status (unsigned short status, struct env387 *ep)
{
  int i;
  int bothstatus;
  int top;
  int fpreg;
  unsigned char *p;

  bothstatus = ((status != 0) && (ep->status != 0));
  if (status != 0)
    {
      if (bothstatus)
	printf_unfiltered ("u: ");
      print_387_status_word (status);
    }

  if (ep->status != 0)
    {
      if (bothstatus)
	printf_unfiltered ("e: ");
      print_387_status_word (ep->status);
    }

  print_387_control_word (ep->control);
  printf_unfiltered ("last exception: ");
  printf_unfiltered ("opcode %s; ", local_hex_string (ep->opcode));
  printf_unfiltered ("pc %s:", local_hex_string (ep->code_seg));
  printf_unfiltered ("%s; ", local_hex_string (ep->eip));
  printf_unfiltered ("operand %s", local_hex_string (ep->operand_seg));
  printf_unfiltered (":%s\n", local_hex_string (ep->operand));

  top = (ep->status >> 11) & 7;

  printf_unfiltered ("regno  tag  msb              lsb  value\n");
  for (fpreg = 7; fpreg >= 0; fpreg--)
    {
      double val;

      printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg);

      switch ((ep->tag >> (fpreg * 2)) & 3)
	{
	case 0:
	  printf_unfiltered ("valid ");
	  break;
	case 1:
	  printf_unfiltered ("zero  ");
	  break;
	case 2:
	  printf_unfiltered ("trap  ");
	  break;
	case 3:
	  printf_unfiltered ("empty ");
	  break;
	}
      for (i = 9; i >= 0; i--)
	printf_unfiltered ("%02x", ep->regs[fpreg][i]);

      floatformat_to_double (&floatformat_i387_ext, (char *) ep->regs[fpreg],
			     &val);
      printf_unfiltered ("  %g\n", val);
    }
  if (ep->r0)
    printf_unfiltered ("warning: reserved0 is %s\n", local_hex_string (ep->r0));
  if (ep->r1)
    printf_unfiltered ("warning: reserved1 is %s\n", local_hex_string (ep->r1));
  if (ep->r2)
    printf_unfiltered ("warning: reserved2 is %s\n", local_hex_string (ep->r2));
  if (ep->r3)
    printf_unfiltered ("warning: reserved3 is %s\n", local_hex_string (ep->r3));
}

/*
 * values that go into fp_kind (from <i386/fpreg.h>)
 */
#define FP_NO   0		/* no fp chip, no emulator (no fp support)      */
#define FP_SW   1		/* no fp chip, using software emulator          */
#define FP_HW   2		/* chip present bit                             */
#define FP_287  2		/* 80287 chip present                           */
#define FP_387  3		/* 80387 chip present                           */

typedef struct fpstate
{
#if 1
  unsigned char state[FP_STATE_BYTES];	/* "hardware" state */
#else
  struct env387 state;		/* Actually this */
#endif
  int status;			/* Duplicate status */
}
 *fpstate_t;

/* Mach 3 specific routines.
 */
private boolean_t
get_i387_state (struct fpstate *fstate)
{
  kern_return_t ret;
  thread_state_data_t state;
  unsigned int fsCnt = i386_FLOAT_STATE_COUNT;
  struct i386_float_state *fsp;

  ret = thread_get_state (current_thread,
			  i386_FLOAT_STATE,
			  state,
			  &fsCnt);

  if (ret != KERN_SUCCESS)
    {
      warning ("Can not get live floating point state: %s",
	       mach_error_string (ret));
      return FALSE;
    }

  fsp = (struct i386_float_state *) state;
  /* The 387 chip (also 486 counts) or a software emulator? */
  if (!fsp->initialized || (fsp->fpkind != FP_387 && fsp->fpkind != FP_SW))
    return FALSE;

  /* Clear the target then copy thread's float state there.
     Make a copy of the status word, for some reason?
   */
  memset (fstate, 0, sizeof (struct fpstate));

  fstate->status = fsp->exc_status;

  memcpy (fstate->state, (char *) &fsp->hw_state, FP_STATE_BYTES);

  return TRUE;
}

private boolean_t
get_i387_core_state (struct fpstate *fstate)
{
  /* Not implemented yet. Core files do not contain float state. */
  return FALSE;
}

/*
 * This is called by "info float" command
 */
void
i386_mach3_float_info (void)
{
  char buf[sizeof (struct fpstate) + 2 * sizeof (int)];
  boolean_t valid = FALSE;
  fpstate_t fps;

  if (target_has_execution)
    valid = get_i387_state (buf);
#if 0
  else if (WE HAVE CORE FILE)	/* @@@@@@@@ Core files not supported */
    valid = get_i387_core_state (buf);
#endif

  if (!valid)
    {
      warning ("no floating point status saved");
      return;
    }

  fps = (fpstate_t) buf;

  print_387_status (fps->status, (struct env387 *) fps->state);
}
@


1.4.16.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d1 426
a426 426
// OBSOLETE /* Low level interface to I386 running mach 3.0.
// OBSOLETE    Copyright 1992, 1993, 1994, 1996, 2000, 2001
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "floatformat.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #include <stdio.h>
// OBSOLETE 
// OBSOLETE #include <mach.h>
// OBSOLETE #include <mach/message.h>
// OBSOLETE #include <mach/exception.h>
// OBSOLETE #include <mach_error.h>
// OBSOLETE 
// OBSOLETE /* Hmmm... Should this not be here?
// OBSOLETE  * Now for i386_float_info() target_has_execution
// OBSOLETE  */
// OBSOLETE #include <target.h>
// OBSOLETE 
// OBSOLETE /* This mess is duplicated in bfd/i386mach3.h
// OBSOLETE 
// OBSOLETE  * This is an ugly way to hack around the incorrect
// OBSOLETE  * definition of UPAGES in i386/machparam.h.
// OBSOLETE  *
// OBSOLETE  * The definition should specify the size reserved
// OBSOLETE  * for "struct user" in core files in PAGES,
// OBSOLETE  * but instead it gives it in 512-byte core-clicks
// OBSOLETE  * for i386 and i860.
// OBSOLETE  */
// OBSOLETE #include <sys/param.h>
// OBSOLETE #if UPAGES == 16
// OBSOLETE #define UAREA_SIZE ctob(UPAGES)
// OBSOLETE #elif UPAGES == 2
// OBSOLETE #define UAREA_SIZE (NBPG*UPAGES)
// OBSOLETE #else
// OBSOLETE FIXME ! !UPAGES is neither 2 nor 16
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /* @@@@@@ Should move print_387_status() to i387-tdep.c */
// OBSOLETE extern void print_387_control_word ();		/* i387-tdep.h */
// OBSOLETE extern void print_387_status_word ();
// OBSOLETE 
// OBSOLETE #define private static
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Find offsets to thread states at compile time.
// OBSOLETE  * If your compiler does not grok this, calculate offsets
// OBSOLETE  * offsets yourself and use them (or get a compatible compiler :-)
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #define  REG_OFFSET(reg) (int)(&((struct i386_thread_state *)0)->reg)
// OBSOLETE 
// OBSOLETE /* at reg_offset[i] is the offset to the i386_thread_state
// OBSOLETE  * location where the gdb registers[i] is stored.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static int reg_offset[] =
// OBSOLETE {
// OBSOLETE   REG_OFFSET (eax), REG_OFFSET (ecx), REG_OFFSET (edx), REG_OFFSET (ebx),
// OBSOLETE   REG_OFFSET (uesp), REG_OFFSET (ebp), REG_OFFSET (esi), REG_OFFSET (edi),
// OBSOLETE   REG_OFFSET (eip), REG_OFFSET (efl), REG_OFFSET (cs), REG_OFFSET (ss),
// OBSOLETE   REG_OFFSET (ds), REG_OFFSET (es), REG_OFFSET (fs), REG_OFFSET (gs)
// OBSOLETE };
// OBSOLETE 
// OBSOLETE #define REG_ADDRESS(state,regnum) ((char *)(state)+reg_offset[regnum])
// OBSOLETE 
// OBSOLETE /* Fetch COUNT contiguous registers from thread STATE starting from REGNUM
// OBSOLETE  * Caller knows that the regs handled in one transaction are of same size.
// OBSOLETE  */
// OBSOLETE #define FETCH_REGS(state, regnum, count) \
// OBSOLETE   memcpy (&registers[REGISTER_BYTE (regnum)], \
// OBSOLETE 	  REG_ADDRESS (state, regnum), \
// OBSOLETE 	  count*REGISTER_SIZE)
// OBSOLETE 
// OBSOLETE /* Store COUNT contiguous registers to thread STATE starting from REGNUM */
// OBSOLETE #define STORE_REGS(state, regnum, count) \
// OBSOLETE   memcpy (REG_ADDRESS (state, regnum), \
// OBSOLETE 	  &registers[REGISTER_BYTE (regnum)], \
// OBSOLETE 	  count*REGISTER_SIZE)
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * Fetch inferiors registers for gdb.
// OBSOLETE  * REGNO specifies which (as gdb views it) register, -1 for all.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fetch_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_state_data_t state;
// OBSOLETE   unsigned int stateCnt = i386_THREAD_STATE_COUNT;
// OBSOLETE   int index;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (current_thread))
// OBSOLETE     error ("fetch inferior registers: Invalid thread");
// OBSOLETE 
// OBSOLETE   if (must_suspend_thread)
// OBSOLETE     setup_thread (current_thread, 1);
// OBSOLETE 
// OBSOLETE   ret = thread_get_state (current_thread,
// OBSOLETE 			  i386_THREAD_STATE,
// OBSOLETE 			  state,
// OBSOLETE 			  &stateCnt);
// OBSOLETE 
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("fetch_inferior_registers: %s ",
// OBSOLETE 	     mach_error_string (ret));
// OBSOLETE #if 0
// OBSOLETE   /* It may be more effective to store validate all of them,
// OBSOLETE    * since we fetched them all anyway
// OBSOLETE    */
// OBSOLETE   else if (regno != -1)
// OBSOLETE     supply_register (regno, (char *) state + reg_offset[regno]);
// OBSOLETE #endif
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       for (index = 0; index < NUM_REGS; index++)
// OBSOLETE 	supply_register (index, (char *) state + reg_offset[index]);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (must_suspend_thread)
// OBSOLETE     setup_thread (current_thread, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store our register values back into the inferior.
// OBSOLETE  * If REGNO is -1, do this for all registers.
// OBSOLETE  * Otherwise, REGNO specifies which register
// OBSOLETE  *
// OBSOLETE  * On mach3 all registers are always saved in one call.
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE store_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_state_data_t state;
// OBSOLETE   unsigned int stateCnt = i386_THREAD_STATE_COUNT;
// OBSOLETE   register int index;
// OBSOLETE 
// OBSOLETE   if (!MACH_PORT_VALID (current_thread))
// OBSOLETE     error ("store inferior registers: Invalid thread");
// OBSOLETE 
// OBSOLETE   if (must_suspend_thread)
// OBSOLETE     setup_thread (current_thread, 1);
// OBSOLETE 
// OBSOLETE   /* Fetch the state of the current thread */
// OBSOLETE   ret = thread_get_state (current_thread,
// OBSOLETE 			  i386_THREAD_STATE,
// OBSOLETE 			  state,
// OBSOLETE 			  &stateCnt);
// OBSOLETE 
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("store_inferior_registers (get): %s",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE       if (must_suspend_thread)
// OBSOLETE 	setup_thread (current_thread, 0);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* move gdb's registers to thread's state
// OBSOLETE 
// OBSOLETE    * Since we save all registers anyway, save the ones
// OBSOLETE    * that gdb thinks are valid (e.g. ignore the regno
// OBSOLETE    * parameter)
// OBSOLETE    */
// OBSOLETE #if 0
// OBSOLETE   if (regno != -1)
// OBSOLETE     STORE_REGS (state, regno, 1);
// OBSOLETE   else
// OBSOLETE #endif
// OBSOLETE     {
// OBSOLETE       for (index = 0; index < NUM_REGS; index++)
// OBSOLETE 	STORE_REGS (state, index, 1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Write gdb's current view of register to the thread
// OBSOLETE    */
// OBSOLETE   ret = thread_set_state (current_thread,
// OBSOLETE 			  i386_THREAD_STATE,
// OBSOLETE 			  state,
// OBSOLETE 			  i386_THREAD_STATE_COUNT);
// OBSOLETE 
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     warning ("store_inferior_registers (set): %s",
// OBSOLETE 	     mach_error_string (ret));
// OBSOLETE 
// OBSOLETE   if (must_suspend_thread)
// OBSOLETE     setup_thread (current_thread, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Return the address in the core dump or inferior of register REGNO.
// OBSOLETE  * BLOCKEND should be the address of the end of the UPAGES area read
// OBSOLETE  * in memory, but it's not?
// OBSOLETE  *
// OBSOLETE  * Currently our UX server dumps the whole thread state to the
// OBSOLETE  * core file. If your UX does something else, adapt the routine
// OBSOLETE  * below to return the offset to the given register.
// OBSOLETE  * 
// OBSOLETE  * Called by core-aout.c(fetch_core_registers)
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE register_addr (int regno, CORE_ADDR blockend)
// OBSOLETE {
// OBSOLETE   CORE_ADDR addr;
// OBSOLETE 
// OBSOLETE   if (regno < 0 || regno >= NUM_REGS)
// OBSOLETE     error ("Invalid register number %d.", regno);
// OBSOLETE 
// OBSOLETE   /* UAREA_SIZE == 8 kB in i386 */
// OBSOLETE   addr = (unsigned int) REG_ADDRESS (UAREA_SIZE - sizeof (struct i386_thread_state), regno);
// OBSOLETE 
// OBSOLETE   return addr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* jtv@@hut.fi: I copied and modified this 387 code from
// OBSOLETE  * gdb/i386-xdep.c. Modifications for Mach 3.0.
// OBSOLETE  *
// OBSOLETE  * i387 status dumper. See also i387-tdep.c
// OBSOLETE  */
// OBSOLETE struct env387
// OBSOLETE {
// OBSOLETE   unsigned short control;
// OBSOLETE   unsigned short r0;
// OBSOLETE   unsigned short status;
// OBSOLETE   unsigned short r1;
// OBSOLETE   unsigned short tag;
// OBSOLETE   unsigned short r2;
// OBSOLETE   unsigned long eip;
// OBSOLETE   unsigned short code_seg;
// OBSOLETE   unsigned short opcode;
// OBSOLETE   unsigned long operand;
// OBSOLETE   unsigned short operand_seg;
// OBSOLETE   unsigned short r3;
// OBSOLETE   unsigned char regs[8][10];
// OBSOLETE };
// OBSOLETE /* This routine is machine independent?
// OBSOLETE  * Should move it to i387-tdep.c but you need to export struct env387
// OBSOLETE  */
// OBSOLETE private
// OBSOLETE print_387_status (unsigned short status, struct env387 *ep)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   int bothstatus;
// OBSOLETE   int top;
// OBSOLETE   int fpreg;
// OBSOLETE   unsigned char *p;
// OBSOLETE 
// OBSOLETE   bothstatus = ((status != 0) && (ep->status != 0));
// OBSOLETE   if (status != 0)
// OBSOLETE     {
// OBSOLETE       if (bothstatus)
// OBSOLETE 	printf_unfiltered ("u: ");
// OBSOLETE       print_387_status_word (status);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (ep->status != 0)
// OBSOLETE     {
// OBSOLETE       if (bothstatus)
// OBSOLETE 	printf_unfiltered ("e: ");
// OBSOLETE       print_387_status_word (ep->status);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   print_387_control_word (ep->control);
// OBSOLETE   printf_unfiltered ("last exception: ");
// OBSOLETE   printf_unfiltered ("opcode %s; ", local_hex_string (ep->opcode));
// OBSOLETE   printf_unfiltered ("pc %s:", local_hex_string (ep->code_seg));
// OBSOLETE   printf_unfiltered ("%s; ", local_hex_string (ep->eip));
// OBSOLETE   printf_unfiltered ("operand %s", local_hex_string (ep->operand_seg));
// OBSOLETE   printf_unfiltered (":%s\n", local_hex_string (ep->operand));
// OBSOLETE 
// OBSOLETE   top = (ep->status >> 11) & 7;
// OBSOLETE 
// OBSOLETE   printf_unfiltered ("regno  tag  msb              lsb  value\n");
// OBSOLETE   for (fpreg = 7; fpreg >= 0; fpreg--)
// OBSOLETE     {
// OBSOLETE       double val;
// OBSOLETE 
// OBSOLETE       printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg);
// OBSOLETE 
// OBSOLETE       switch ((ep->tag >> (fpreg * 2)) & 3)
// OBSOLETE 	{
// OBSOLETE 	case 0:
// OBSOLETE 	  printf_unfiltered ("valid ");
// OBSOLETE 	  break;
// OBSOLETE 	case 1:
// OBSOLETE 	  printf_unfiltered ("zero  ");
// OBSOLETE 	  break;
// OBSOLETE 	case 2:
// OBSOLETE 	  printf_unfiltered ("trap  ");
// OBSOLETE 	  break;
// OBSOLETE 	case 3:
// OBSOLETE 	  printf_unfiltered ("empty ");
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       for (i = 9; i >= 0; i--)
// OBSOLETE 	printf_unfiltered ("%02x", ep->regs[fpreg][i]);
// OBSOLETE 
// OBSOLETE       floatformat_to_double (&floatformat_i387_ext, (char *) ep->regs[fpreg],
// OBSOLETE 			     &val);
// OBSOLETE       printf_unfiltered ("  %g\n", val);
// OBSOLETE     }
// OBSOLETE   if (ep->r0)
// OBSOLETE     printf_unfiltered ("warning: reserved0 is %s\n", local_hex_string (ep->r0));
// OBSOLETE   if (ep->r1)
// OBSOLETE     printf_unfiltered ("warning: reserved1 is %s\n", local_hex_string (ep->r1));
// OBSOLETE   if (ep->r2)
// OBSOLETE     printf_unfiltered ("warning: reserved2 is %s\n", local_hex_string (ep->r2));
// OBSOLETE   if (ep->r3)
// OBSOLETE     printf_unfiltered ("warning: reserved3 is %s\n", local_hex_string (ep->r3));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * values that go into fp_kind (from <i386/fpreg.h>)
// OBSOLETE  */
// OBSOLETE #define FP_NO   0		/* no fp chip, no emulator (no fp support)      */
// OBSOLETE #define FP_SW   1		/* no fp chip, using software emulator          */
// OBSOLETE #define FP_HW   2		/* chip present bit                             */
// OBSOLETE #define FP_287  2		/* 80287 chip present                           */
// OBSOLETE #define FP_387  3		/* 80387 chip present                           */
// OBSOLETE 
// OBSOLETE typedef struct fpstate
// OBSOLETE {
// OBSOLETE #if 1
// OBSOLETE   unsigned char state[FP_STATE_BYTES];	/* "hardware" state */
// OBSOLETE #else
// OBSOLETE   struct env387 state;		/* Actually this */
// OBSOLETE #endif
// OBSOLETE   int status;			/* Duplicate status */
// OBSOLETE }
// OBSOLETE  *fpstate_t;
// OBSOLETE 
// OBSOLETE /* Mach 3 specific routines.
// OBSOLETE  */
// OBSOLETE private boolean_t
// OBSOLETE get_i387_state (struct fpstate *fstate)
// OBSOLETE {
// OBSOLETE   kern_return_t ret;
// OBSOLETE   thread_state_data_t state;
// OBSOLETE   unsigned int fsCnt = i386_FLOAT_STATE_COUNT;
// OBSOLETE   struct i386_float_state *fsp;
// OBSOLETE 
// OBSOLETE   ret = thread_get_state (current_thread,
// OBSOLETE 			  i386_FLOAT_STATE,
// OBSOLETE 			  state,
// OBSOLETE 			  &fsCnt);
// OBSOLETE 
// OBSOLETE   if (ret != KERN_SUCCESS)
// OBSOLETE     {
// OBSOLETE       warning ("Can not get live floating point state: %s",
// OBSOLETE 	       mach_error_string (ret));
// OBSOLETE       return FALSE;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   fsp = (struct i386_float_state *) state;
// OBSOLETE   /* The 387 chip (also 486 counts) or a software emulator? */
// OBSOLETE   if (!fsp->initialized || (fsp->fpkind != FP_387 && fsp->fpkind != FP_SW))
// OBSOLETE     return FALSE;
// OBSOLETE 
// OBSOLETE   /* Clear the target then copy thread's float state there.
// OBSOLETE      Make a copy of the status word, for some reason?
// OBSOLETE    */
// OBSOLETE   memset (fstate, 0, sizeof (struct fpstate));
// OBSOLETE 
// OBSOLETE   fstate->status = fsp->exc_status;
// OBSOLETE 
// OBSOLETE   memcpy (fstate->state, (char *) &fsp->hw_state, FP_STATE_BYTES);
// OBSOLETE 
// OBSOLETE   return TRUE;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE private boolean_t
// OBSOLETE get_i387_core_state (struct fpstate *fstate)
// OBSOLETE {
// OBSOLETE   /* Not implemented yet. Core files do not contain float state. */
// OBSOLETE   return FALSE;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * This is called by "info float" command
// OBSOLETE  */
// OBSOLETE void
// OBSOLETE i386_mach3_float_info (void)
// OBSOLETE {
// OBSOLETE   char buf[sizeof (struct fpstate) + 2 * sizeof (int)];
// OBSOLETE   boolean_t valid = FALSE;
// OBSOLETE   fpstate_t fps;
// OBSOLETE 
// OBSOLETE   if (target_has_execution)
// OBSOLETE     valid = get_i387_state (buf);
// OBSOLETE #if 0
// OBSOLETE   else if (WE HAVE CORE FILE)	/* @@@@@@@@ Core files not supported */
// OBSOLETE     valid = get_i387_core_state (buf);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   if (!valid)
// OBSOLETE     {
// OBSOLETE       warning ("no floating point status saved");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   fps = (fpstate_t) buf;
// OBSOLETE 
// OBSOLETE   print_387_status (fps->status, (struct env387 *) fps->state);
// OBSOLETE }
@


1.3
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1992, 2001 Free Software Foundation, Inc.
@


1.2
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright (C) 1992 Free Software Foundation, Inc.
d24 1
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d38 1
a38 1
 *
d53 1
a53 1
FIXME!! UPAGES is neither 2 nor 16
d61 1
a62 1

d74 1
a74 1
static int reg_offset[] = 
d76 4
a79 4
  REG_OFFSET(eax),  REG_OFFSET(ecx), REG_OFFSET(edx), REG_OFFSET(ebx),
  REG_OFFSET(uesp), REG_OFFSET(ebp), REG_OFFSET(esi), REG_OFFSET(edi),
  REG_OFFSET(eip),  REG_OFFSET(efl), REG_OFFSET(cs),  REG_OFFSET(ss),
  REG_OFFSET(ds),   REG_OFFSET(es),  REG_OFFSET(fs),  REG_OFFSET(gs)
d104 1
a104 2
fetch_inferior_registers (regno)
     int regno;
d110 2
a111 2
  
  if (! MACH_PORT_VALID (current_thread))
d130 1
a130 1
    supply_register (regno, (char *)state+reg_offset[regno]);
d134 2
a135 2
      for (index = 0; index < NUM_REGS; index++) 
	supply_register (index, (char *)state+reg_offset[index]);
d149 1
a149 2
store_inferior_registers (regno)
     int regno;
d156 1
a156 1
  if (! MACH_PORT_VALID (current_thread))
d168 1
a168 1
   if (ret != KERN_SUCCESS) 
d178 1
a178 1
   *
d189 1
a189 1
      for (index = 0; index < NUM_REGS; index++) 
d192 1
a192 1
  
d199 1
a199 1
  
d207 1
a208 1

d222 1
a222 3
register_addr (regno, blockend)
     int regno;
     CORE_ADDR blockend;
d230 1
a230 1
  addr = (unsigned int)REG_ADDRESS (UAREA_SIZE - sizeof(struct i386_thread_state), regno);
d240 1
a240 1
struct env387 
d260 1
a260 3
print_387_status (status, ep)
     unsigned short status;
     struct env387 *ep;
d267 1
a267 1
  
d269 1
a269 1
  if (status != 0) 
d275 2
a276 2
  
  if (ep->status != 0) 
d282 1
a282 1
  
d285 6
a290 6
  printf_unfiltered ("opcode %s; ", local_hex_string(ep->opcode));
  printf_unfiltered ("pc %s:", local_hex_string(ep->code_seg));
  printf_unfiltered ("%s; ", local_hex_string(ep->eip));
  printf_unfiltered ("operand %s", local_hex_string(ep->operand_seg));
  printf_unfiltered (":%s\n", local_hex_string(ep->operand));
  
d292 1
a292 1
  
d294 1
a294 1
  for (fpreg = 7; fpreg >= 0; fpreg--) 
d297 1
a297 1
      
d299 2
a300 2
      
      switch ((ep->tag >> (fpreg * 2)) & 3) 
d302 12
a313 4
	case 0: printf_unfiltered ("valid "); break;
	case 1: printf_unfiltered ("zero  "); break;
	case 2: printf_unfiltered ("trap  "); break;
	case 3: printf_unfiltered ("empty "); break;
d317 3
a319 3
      
      floatformat_to_double (&floatformat_i387_ext, (char *)ep->regs[fpreg],
			       &val);
d323 1
a323 1
    printf_unfiltered ("warning: reserved0 is %s\n", local_hex_string(ep->r0));
d325 1
a325 1
    printf_unfiltered ("warning: reserved1 is %s\n", local_hex_string(ep->r1));
d327 1
a327 1
    printf_unfiltered ("warning: reserved2 is %s\n", local_hex_string(ep->r2));
d329 1
a329 1
    printf_unfiltered ("warning: reserved3 is %s\n", local_hex_string(ep->r3));
d331 1
a331 1
	
d335 5
a339 5
#define FP_NO   0       /* no fp chip, no emulator (no fp support)      */
#define FP_SW   1       /* no fp chip, using software emulator          */
#define FP_HW   2       /* chip present bit                             */
#define FP_287  2       /* 80287 chip present                           */
#define FP_387  3       /* 80387 chip present                           */
d341 2
a342 1
typedef struct fpstate {
d344 1
a344 1
  unsigned char	state[FP_STATE_BYTES]; /* "hardware" state */
d346 1
a346 1
  struct env387	state;	/* Actually this */
d348 3
a350 2
  int status;		/* Duplicate status */
} *fpstate_t;
d355 1
a355 2
get_i387_state (fstate)
     struct fpstate *fstate;
d361 1
a361 1
  
d374 1
a374 1
  fsp = (struct i386_float_state *)state;
d386 1
a386 1
  memcpy (fstate->state, (char *)&fsp->hw_state, FP_STATE_BYTES);
d392 1
a392 2
get_i387_core_state (fstate)
     struct fpstate *fstate;
d402 1
a402 1
i386_mach3_float_info()
d404 1
a404 1
  char buf [sizeof (struct fpstate) + 2 * sizeof (int)];
d407 1
a407 1
  
d410 2
a411 2
#if 0  
  else if (WE HAVE CORE FILE)  /* @@@@@@@@ Core files not supported */
d413 1
a413 1
#endif    
d415 1
a415 1
  if (!valid) 
d420 1
a420 1
  
d423 1
a423 1
  print_387_status (fps->status, (struct env387 *)fps->state);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d37 1
a37 1

d52 1
a52 1
FIXME ! !UPAGES is neither 2 nor 16
d60 1
a61 1

d73 1
a73 1
static int reg_offset[] =
d75 4
a78 4
  REG_OFFSET (eax), REG_OFFSET (ecx), REG_OFFSET (edx), REG_OFFSET (ebx),
  REG_OFFSET (uesp), REG_OFFSET (ebp), REG_OFFSET (esi), REG_OFFSET (edi),
  REG_OFFSET (eip), REG_OFFSET (efl), REG_OFFSET (cs), REG_OFFSET (ss),
  REG_OFFSET (ds), REG_OFFSET (es), REG_OFFSET (fs), REG_OFFSET (gs)
d110 2
a111 2

  if (!MACH_PORT_VALID (current_thread))
d130 1
a130 1
    supply_register (regno, (char *) state + reg_offset[regno]);
d134 2
a135 2
      for (index = 0; index < NUM_REGS; index++)
	supply_register (index, (char *) state + reg_offset[index]);
d157 1
a157 1
  if (!MACH_PORT_VALID (current_thread))
d169 1
a169 1
  if (ret != KERN_SUCCESS)
d179 1
a179 1

d190 1
a190 1
      for (index = 0; index < NUM_REGS; index++)
d193 1
a193 1

d200 1
a200 1

d208 1
a210 1

d233 1
a233 1
  addr = (unsigned int) REG_ADDRESS (UAREA_SIZE - sizeof (struct i386_thread_state), regno);
d243 1
a243 1
struct env387
d272 1
a272 1

d274 1
a274 1
  if (status != 0)
d280 2
a281 2

  if (ep->status != 0)
d287 1
a287 1

d290 6
a295 6
  printf_unfiltered ("opcode %s; ", local_hex_string (ep->opcode));
  printf_unfiltered ("pc %s:", local_hex_string (ep->code_seg));
  printf_unfiltered ("%s; ", local_hex_string (ep->eip));
  printf_unfiltered ("operand %s", local_hex_string (ep->operand_seg));
  printf_unfiltered (":%s\n", local_hex_string (ep->operand));

d297 1
a297 1

d299 1
a299 1
  for (fpreg = 7; fpreg >= 0; fpreg--)
d302 1
a302 1

d304 2
a305 2

      switch ((ep->tag >> (fpreg * 2)) & 3)
d307 4
a310 12
	case 0:
	  printf_unfiltered ("valid ");
	  break;
	case 1:
	  printf_unfiltered ("zero  ");
	  break;
	case 2:
	  printf_unfiltered ("trap  ");
	  break;
	case 3:
	  printf_unfiltered ("empty ");
	  break;
d314 3
a316 3

      floatformat_to_double (&floatformat_i387_ext, (char *) ep->regs[fpreg],
			     &val);
d320 1
a320 1
    printf_unfiltered ("warning: reserved0 is %s\n", local_hex_string (ep->r0));
d322 1
a322 1
    printf_unfiltered ("warning: reserved1 is %s\n", local_hex_string (ep->r1));
d324 1
a324 1
    printf_unfiltered ("warning: reserved2 is %s\n", local_hex_string (ep->r2));
d326 1
a326 1
    printf_unfiltered ("warning: reserved3 is %s\n", local_hex_string (ep->r3));
d328 1
a328 1

d332 5
a336 5
#define FP_NO   0		/* no fp chip, no emulator (no fp support)      */
#define FP_SW   1		/* no fp chip, using software emulator          */
#define FP_HW   2		/* chip present bit                             */
#define FP_287  2		/* 80287 chip present                           */
#define FP_387  3		/* 80387 chip present                           */
d338 1
a338 2
typedef struct fpstate
{
d340 1
a340 1
  unsigned char state[FP_STATE_BYTES];	/* "hardware" state */
d342 1
a342 1
  struct env387 state;		/* Actually this */
d344 2
a345 3
  int status;			/* Duplicate status */
}
 *fpstate_t;
d357 1
a357 1

d370 1
a370 1
  fsp = (struct i386_float_state *) state;
d382 1
a382 1
  memcpy (fstate->state, (char *) &fsp->hw_state, FP_STATE_BYTES);
d399 1
a399 1
i386_mach3_float_info ()
d401 1
a401 1
  char buf[sizeof (struct fpstate) + 2 * sizeof (int)];
d404 1
a404 1

d407 2
a408 2
#if 0
  else if (WE HAVE CORE FILE)	/* @@@@@@@@ Core files not supported */
d410 1
a410 1
#endif
d412 1
a412 1
  if (!valid)
d417 1
a417 1

d420 1
a420 1
  print_387_status (fps->status, (struct env387 *) fps->state);
@

