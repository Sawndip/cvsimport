head	1.34;
access;
symbols
	jimb-ppc64-linux-20030613-branch:1.33.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.33
	cagney_convert-20030606-branch:1.33.0.10
	cagney_convert-20030606-branchpoint:1.33
	cagney_writestrings-20030508-branch:1.33.0.8
	cagney_writestrings-20030508-branchpoint:1.33
	jimb-ppc64-linux-20030528-branch:1.33.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.33
	carlton_dictionary-20030523-merge:1.33
	cagney_fileio-20030521-branch:1.33.0.4
	cagney_fileio-20030521-branchpoint:1.33
	kettenis_i386newframe-20030517-mergepoint:1.33
	jimb-ppc64-linux-20030509-branch:1.33.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.33
	kettenis_i386newframe-20030504-mergepoint:1.32
	carlton_dictionary-20030430-merge:1.32
	kettenis_i386newframe-20030419-branch:1.32.0.8
	kettenis_i386newframe-20030419-branchpoint:1.32
	carlton_dictionary-20030416-merge:1.32
	cagney_frameaddr-20030409-mergepoint:1.32
	kettenis_i386newframe-20030406-branch:1.32.0.6
	kettenis_i386newframe-20030406-branchpoint:1.32
	cagney_frameaddr-20030403-branchpoint:1.32
	cagney_frameaddr-20030403-branch:1.32.0.4
	cagney_framebase-20030330-mergepoint:1.32
	cagney_framebase-20030326-branch:1.32.0.2
	cagney_framebase-20030326-branchpoint:1.32
	cagney_lazyid-20030317-branch:1.31.0.8
	cagney_lazyid-20030317-branchpoint:1.31
	kettenis-i386newframe-20030316-mergepoint:1.31
	offbyone-20030313-branch:1.31.0.6
	offbyone-20030313-branchpoint:1.31
	kettenis-i386newframe-20030308-branch:1.31.0.4
	kettenis-i386newframe-20030308-branchpoint:1.31
	carlton_dictionary-20030305-merge:1.31
	cagney_offbyone-20030303-branch:1.31.0.2
	cagney_offbyone-20030303-branchpoint:1.31
	carlton_dictionary-20030207-merge:1.30
	interps-20030203-mergepoint:1.30
	interps-20030202-branch:1.29.0.2
	interps-20030202-branchpoint:1.29
	cagney-unwind-20030108-branch:1.27.0.2
	cagney-unwind-20030108-branchpoint:1.27
	carlton_dictionary-20021223-merge:1.23
	gdb_5_3-2002-12-12-release:1.16
	carlton_dictionary-20021115-merge:1.21
	kseitz_interps-20021105-merge:1.20
	kseitz_interps-20021103-merge:1.20
	drow-cplus-merge-20021020:1.16
	drow-cplus-merge-20021025:1.18
	carlton_dictionary-20021025-merge:1.18
	carlton_dictionary-20021011-merge:1.16
	drow-cplus-branch:1.16.0.10
	drow-cplus-branchpoint:1.16
	kseitz_interps-20020930-merge:1.16
	carlton_dictionary-20020927-merge:1.16
	carlton_dictionary-branch:1.16.0.8
	carlton_dictionary-20020920-branchpoint:1.16
	gdb_5_3-branch:1.16.0.6
	gdb_5_3-2002-09-04-branchpoint:1.16
	kseitz_interps-20020829-merge:1.16
	cagney_sysregs-20020825-branch:1.16.0.4
	cagney_sysregs-20020825-branchpoint:1.16
	readline_4_3-import-branch:1.16.0.2
	readline_4_3-import-branchpoint:1.16
	gdb_5_2_1-2002-07-23-release:1.1.2.6
	kseitz_interps-20020528-branch:1.7.0.2
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.5.0.2
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.3.0.2
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.1.2.1
	gdb_5_2-branch:1.1.0.2
	gdb_5_2-2002-03-03-branchpoint:1.1
	cygnus_cvs_20020108_pre:1.1;
locks; strict;
comment	@ * @;


1.34
date	2003.06.08.12.43.02;	author kettenis;	state dead;
branches;
next	1.33;

1.33
date	2003.05.08.20.52.47;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.26.20.17.36;	author drow;	state Exp;
branches
	1.32.8.1;
next	1.31;

1.31
date	2003.02.10.11.50.20;	author mludvig;	state Exp;
branches;
next	1.30;

1.30
date	2003.02.03.14.33.20;	author mludvig;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.31.19.22.17;	author drow;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2003.01.14.00.49.03;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.09.18.53.20;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.08.15.56.36;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.07.22.53.09;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2003.01.02.22.20.46;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.09.02.44.52;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2002.12.09.02.04.16;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.14.00.25.02;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.26.10.13.53;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.24.01.37.39;	author mludvig;	state Exp;
branches;
next	1.17;

1.17
date	2002.10.24.01.27.43;	author mludvig;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.19.09.40.51;	author mludvig;	state Exp;
branches
	1.16.6.1
	1.16.8.1
	1.16.10.1;
next	1.15;

1.15
date	2002.07.15.16.01.31;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.11.13.50.49;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.08.20.53.45;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.04.14.43.51;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.21.13.53.24;	author mludvig;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.21.12.12.34;	author mludvig;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.11.08.45.05;	author mludvig;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.11.08.32.33;	author mludvig;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.22.13.21.19;	author mludvig;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2002.05.22.12.34.08;	author mludvig;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.14.08.24.26;	author mludvig;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.05.07.11.22.54;	author mludvig;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.06.00.02.50;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.27.14.32.08;	author aj;	state Exp;
branches;
next	1.1;

1.1
date	2001.12.07.12.10.15;	author smid;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2002.03.27.14.31.41;	author aj;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.05.14.09.50.39;	author mludvig;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.05.22.12.55.38;	author mludvig;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.05.22.13.23.23;	author mludvig;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2002.07.03.06.00.26;	author mludvig;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2002.07.15.16.43.10;	author cagney;	state Exp;
branches;
next	;

1.5.2.1
date	2002.06.15.16.42.51;	author cagney;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.06.21.16.46.51;	author cagney;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.20.01.32.20;	author kseitz;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.07.22.21.46.58;	author kseitz;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2002.11.04.00.17.30;	author ezannoni;	state Exp;
branches;
next	;

1.16.6.1
date	2003.02.03.14.40.09;	author mludvig;	state Exp;
branches;
next	;

1.16.8.1
date	2002.10.25.23.49.53;	author carlton;	state Exp;
branches;
next	1.16.8.2;

1.16.8.2
date	2002.11.15.19.18.41;	author carlton;	state Exp;
branches;
next	1.16.8.3;

1.16.8.3
date	2002.12.23.19.38.20;	author carlton;	state Exp;
branches;
next	1.16.8.4;

1.16.8.4
date	2003.02.07.19.17.48;	author carlton;	state Exp;
branches;
next	1.16.8.5;

1.16.8.5
date	2003.03.06.00.56.27;	author carlton;	state Exp;
branches;
next	1.16.8.6;

1.16.8.6
date	2003.04.16.19.56.51;	author carlton;	state Exp;
branches;
next	1.16.8.7;

1.16.8.7
date	2003.05.23.18.40.36;	author carlton;	state Exp;
branches;
next	1.16.8.8;

1.16.8.8
date	2003.06.27.21.49.53;	author carlton;	state dead;
branches;
next	;

1.16.10.1
date	2002.10.26.17.12.06;	author drow;	state Exp;
branches;
next	1.16.10.2;

1.16.10.2
date	2003.12.14.20.27.11;	author drow;	state dead;
branches;
next	;

1.29.2.1
date	2003.02.03.22.00.55;	author cagney;	state Exp;
branches;
next	;

1.32.8.1
date	2003.05.18.09.44.04;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.34
log
@* dwarf2cfi.c, dwarf2cfi.h: Remove.
@
text
@/* Stack unwinding code based on dwarf2 frame info for GDB, the GNU debugger.

   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.

   Contributed by Jiri Smid, SuSE Labs.
   Based on code written by Daniel Berlin (dan@@dberlin.org).

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "gdbcore.h"
#include "symtab.h"
#include "symfile.h"
#include "objfiles.h"
#include "target.h"
#include "elf/dwarf2.h"
#include "inferior.h"
#include "regcache.h"
#include "dwarf2cfi.h"
#include "gdb_assert.h"

/* Common Information Entry - holds information that is shared among many
   Frame Descriptors.  */
struct cie_unit
{
  /* Offset of this unit in .debug_frame or .eh_frame.  */
  ULONGEST offset;

  /* A null-terminated string that identifies the augmentation to this CIE or
     to the FDEs that use it.  */
  char *augmentation;

  /* A constant that is factored out of all advance location instructions.  */
  unsigned int code_align;

  /* A constant that is factored out of all offset instructions.  */
  int data_align;

  /* A constant that indicates which regiter represents the return address
     of a function.  */
  unsigned char ra;

  /* Indicates how addresses are encoded.  */
  unsigned char addr_encoding;

  /* Pointer and length of the cie program.  */
  char *data;
  unsigned int data_length;

  struct objfile *objfile;

  /* Next in chain.  */
  struct cie_unit *next;
};

/* Frame Description Entry.  */
struct fde_unit
{
  /* Address of the first location associated with this entry.  */
  CORE_ADDR initial_location;

  /* Length of program section described by this entry.  */
  CORE_ADDR address_range;

  /* Pointer to asociated CIE.  */
  struct cie_unit *cie_ptr;

  /* Pointer and length of the cie program.  */
  char *data;
  unsigned int data_length;
};

struct fde_array
{
  struct fde_unit **array;
  int elems;
  int array_size;
};

struct frame_state_reg
{
  union
  {
    unsigned int reg;
    long offset;
    unsigned char *exp;
  }
  loc;
  enum
  {
    REG_UNSAVED,
    REG_SAVED_OFFSET,
    REG_SAVED_REG,
    REG_SAVED_EXP,
  }
  how;
};

struct frame_state
{
  /* Each register save state can be described in terms of a CFA slot,
     another register, or a location expression.  */
  struct frame_state_regs
  {
    struct frame_state_reg *reg;

    /* Used to implement DW_CFA_remember_state.  */
    struct frame_state_regs *prev;
  }
  regs;

  /* The CFA can be described in terms of a reg+offset or a
     location expression.  */
  long cfa_offset;
  int cfa_reg;
  unsigned char *cfa_exp;
  enum
  {
    CFA_UNSET,
    CFA_REG_OFFSET,
    CFA_EXP,
  }
  cfa_how;

  /* The PC described by the current frame state.  */
  CORE_ADDR pc;

  /* The information we care about from the CIE/FDE.  */
  int data_align;
  unsigned int code_align;
  unsigned char retaddr_column;
  unsigned char addr_encoding;

  struct objfile *objfile;
};

enum ptr_encoding
{
  PE_absptr = DW_EH_PE_absptr,
  PE_pcrel = DW_EH_PE_pcrel,
  PE_textrel = DW_EH_PE_textrel,
  PE_datarel = DW_EH_PE_datarel,
  PE_funcrel = DW_EH_PE_funcrel
};

#define UNWIND_CONTEXT(fi) ((struct context *) (deprecated_get_frame_context (fi)))


static struct cie_unit *cie_chunks;
static struct fde_array fde_chunks;
/* Obstack for allocating temporary storage used during unwind operations.  */
static struct obstack unwind_tmp_obstack;

extern file_ptr dwarf_frame_offset;
extern unsigned int dwarf_frame_size;
extern file_ptr dwarf_eh_frame_offset;
extern unsigned int dwarf_eh_frame_size;
extern asection *dwarf_frame_section;
extern asection *dwarf_eh_frame_section;



extern char *dwarf2_read_section (struct objfile *objfile, file_ptr offset,
				  unsigned int size, asection *sectp);

static struct fde_unit *fde_unit_alloc (void);
static struct cie_unit *cie_unit_alloc (void);
static void fde_chunks_need_space ();

static void unwind_tmp_obstack_init ();
static void unwind_tmp_obstack_free ();

static unsigned int read_1u (bfd *abfd, char **p);
static int read_1s (bfd *abfd, char **p);
static unsigned int read_2u (bfd *abfd, char **p);
static int read_2s (bfd *abfd, char **p);
static unsigned int read_4u (bfd *abfd, char **p);
static int read_4s (bfd *abfd, char **p);
static ULONGEST read_8u (bfd *abfd, char **p);
static LONGEST read_8s (bfd *abfd, char **p);

static ULONGEST read_uleb128 (bfd *abfd, char **p);
static LONGEST read_sleb128 (bfd *abfd, char **p);
static CORE_ADDR read_pointer (bfd *abfd, char **p);
static CORE_ADDR read_encoded_pointer (bfd *abfd, char **p,
				       unsigned char encoding);
static enum ptr_encoding pointer_encoding (unsigned char encoding,
					   struct objfile *objfile);

static LONGEST read_initial_length (bfd *abfd, char *buf, int *bytes_read);
static ULONGEST read_length (bfd *abfd, char *buf, int *bytes_read,
			     int dwarf64);

static int is_cie (ULONGEST cie_id, int dwarf64);
static int compare_fde_unit (const void *a, const void *b);
void dwarf2_build_frame_info (struct objfile *objfile);

static void execute_cfa_program (struct objfile *objfile, char *insn_ptr,
				 char *insn_end, struct context *context,
				 struct frame_state *fs);
static struct fde_unit *get_fde_for_addr (CORE_ADDR pc);
static void frame_state_for (struct context *context, struct frame_state *fs);
static void get_reg (char *reg, struct context *context, int regnum);
static CORE_ADDR execute_stack_op (struct objfile *objfile,
				   char *op_ptr, char *op_end,
				   struct context *context,
				   CORE_ADDR initial);
static void update_context (struct context *context, struct frame_state *fs,
			    int chain);


/* Memory allocation functions.  */
static struct fde_unit *
fde_unit_alloc (void)
{
  struct fde_unit *fde;

  fde = (struct fde_unit *) xmalloc (sizeof (struct fde_unit));
  memset (fde, 0, sizeof (struct fde_unit));
  return fde;
}

static struct cie_unit *
cie_unit_alloc (void)
{
  struct cie_unit *cie;

  cie = (struct cie_unit *) xmalloc (sizeof (struct cie_unit));
  memset (cie, 0, sizeof (struct cie_unit));
  return cie;
}

static void
fde_chunks_need_space (void)
{
  if (fde_chunks.elems < fde_chunks.array_size)
    return;
  fde_chunks.array_size =
    fde_chunks.array_size ? 2 * fde_chunks.array_size : 1024;
  fde_chunks.array =
    xrealloc (fde_chunks.array,
	      sizeof (struct fde_unit) * fde_chunks.array_size);
}

/* Alocate a new `struct context' on temporary obstack.  */
struct context *
context_alloc (void)
{
  struct context *context;

  int regs_size = sizeof (struct context_reg) * NUM_REGS;

  context = (struct context *) obstack_alloc (&unwind_tmp_obstack,
					      sizeof (struct context));
  memset (context, 0, sizeof (struct context));
  context->reg = (struct context_reg *) obstack_alloc (&unwind_tmp_obstack,
						       regs_size);
  memset (context->reg, 0, regs_size);
  return context;
}

/* Alocate a new `struct frame_state' on temporary obstack.  */
struct frame_state *
frame_state_alloc (void)
{
  struct frame_state *fs;

  int regs_size = sizeof (struct frame_state_reg) * NUM_REGS;

  fs = (struct frame_state *) obstack_alloc (&unwind_tmp_obstack,
					     sizeof (struct frame_state));
  memset (fs, 0, sizeof (struct frame_state));
  fs->regs.reg =
    (struct frame_state_reg *) obstack_alloc (&unwind_tmp_obstack, regs_size);
  memset (fs->regs.reg, 0, regs_size);
  return fs;
}

static void
unwind_tmp_obstack_init (void)
{
  obstack_init (&unwind_tmp_obstack);
}

static void
unwind_tmp_obstack_free (void)
{
  obstack_free (&unwind_tmp_obstack, NULL);
  unwind_tmp_obstack_init ();
}

void
context_cpy (struct context *dst, struct context *src)
{
  int regs_size = sizeof (struct context_reg) * NUM_REGS;
  struct context_reg *dreg;

  /* Since `struct context' contains a pointer to an array with
     register values, make sure we end up with a copy of that array,
     and not with a copy of the pointer to that array.  */
  dreg = dst->reg;
  *dst = *src;
  dst->reg = dreg;
  memcpy (dst->reg, src->reg, regs_size);
}

static unsigned int
read_1u (bfd *abfd, char **p)
{
  unsigned ret;

  ret = bfd_get_8 (abfd, (bfd_byte *) * p);
  (*p)++;
  return ret;
}

static int
read_1s (bfd *abfd, char **p)
{
  int ret;

  ret = bfd_get_signed_8 (abfd, (bfd_byte *) * p);
  (*p)++;
  return ret;
}

static unsigned int
read_2u (bfd *abfd, char **p)
{
  unsigned ret;

  ret = bfd_get_16 (abfd, (bfd_byte *) * p);
  (*p) += 2;
  return ret;
}

static int
read_2s (bfd *abfd, char **p)
{
  int ret;

  ret = bfd_get_signed_16 (abfd, (bfd_byte *) * p);
  (*p) += 2;
  return ret;
}

static unsigned int
read_4u (bfd *abfd, char **p)
{
  unsigned int ret;

  ret = bfd_get_32 (abfd, (bfd_byte *) * p);
  (*p) += 4;
  return ret;
}

static int
read_4s (bfd *abfd, char **p)
{
  int ret;

  ret = bfd_get_signed_32 (abfd, (bfd_byte *) * p);
  (*p) += 4;
  return ret;
}

static ULONGEST
read_8u (bfd *abfd, char **p)
{
  ULONGEST ret;

  ret = bfd_get_64 (abfd, (bfd_byte *) * p);
  (*p) += 8;
  return ret;
}

static LONGEST
read_8s (bfd *abfd, char **p)
{
  LONGEST ret;

  ret = bfd_get_signed_64 (abfd, (bfd_byte *) * p);
  (*p) += 8;
  return ret;
}

static ULONGEST
read_uleb128 (bfd *abfd, char **p)
{
  ULONGEST ret;
  int i, shift;
  unsigned char byte;

  ret = 0;
  shift = 0;
  i = 0;
  while (1)
    {
      byte = bfd_get_8 (abfd, (bfd_byte *) * p);
      (*p)++;
      ret |= ((unsigned long) (byte & 127) << shift);
      if ((byte & 128) == 0)
	{
	  break;
	}
      shift += 7;
    }
  return ret;
}

static LONGEST
read_sleb128 (bfd *abfd, char **p)
{
  LONGEST ret;
  int i, shift, size, num_read;
  unsigned char byte;

  ret = 0;
  shift = 0;
  size = 32;
  num_read = 0;
  i = 0;
  while (1)
    {
      byte = bfd_get_8 (abfd, (bfd_byte *) * p);
      (*p)++;
      ret |= ((long) (byte & 127) << shift);
      shift += 7;
      if ((byte & 128) == 0)
	{
	  break;
	}
    }
  if ((shift < size) && (byte & 0x40))
    {
      ret |= -(1 << shift);
    }
  return ret;
}

static CORE_ADDR
read_pointer (bfd *abfd, char **p)
{
  switch (TARGET_ADDR_BIT / TARGET_CHAR_BIT)
    {
    case 4:
      return read_4u (abfd, p);
    case 8:
      return read_8u (abfd, p);
    default:
      error
	("dwarf cfi error: unsupported target address length [in module %s]",
	 bfd_get_filename (abfd));
    }
}

/* Read the appropriate amount of data from *P and return the
   resulting value based on ENCODING, which the calling function must
   provide.  */
static CORE_ADDR
read_encoded_pointer (bfd *abfd, char **p, unsigned char encoding)
{
  CORE_ADDR ret;

  switch (encoding & 0x0f)
    {
    case DW_EH_PE_absptr:
      ret = read_pointer (abfd, p);
      break;

    case DW_EH_PE_uleb128:
      ret = read_uleb128 (abfd, p);
      break;
    case DW_EH_PE_sleb128:
      ret = read_sleb128 (abfd, p);
      break;

    case DW_EH_PE_udata2:
      ret = read_2u (abfd, p);
      break;
    case DW_EH_PE_udata4:
      ret = read_4u (abfd, p);
      break;
    case DW_EH_PE_udata8:
      ret = read_8u (abfd, p);
      break;

    case DW_EH_PE_sdata2:
      ret = read_2s (abfd, p);
      break;
    case DW_EH_PE_sdata4:
      ret = read_4s (abfd, p);
      break;
    case DW_EH_PE_sdata8:
      ret = read_8s (abfd, p);
      break;

    default:
      internal_error (__FILE__, __LINE__,
		      "read_encoded_pointer: unknown pointer encoding [in module %s]",
		      bfd_get_filename (abfd));
    }

  return ret;
}

/* The variable 'encoding' carries three different flags:
   - encoding & 0x0f : size of the address (handled in read_encoded_pointer())
   - encoding & 0x70 : type (absolute, relative, ...)
   - encoding & 0x80 : indirect flag (DW_EH_PE_indirect == 0x80).  */
enum ptr_encoding
pointer_encoding (unsigned char encoding, struct objfile *objfile)
{
  int ret;

  if (encoding & DW_EH_PE_indirect)
    warning
      ("CFI: Unsupported pointer encoding: DW_EH_PE_indirect [in module %s]",
       objfile->name);

  switch (encoding & 0x70)
    {
    case DW_EH_PE_absptr:
    case DW_EH_PE_pcrel:
    case DW_EH_PE_textrel:
    case DW_EH_PE_datarel:
    case DW_EH_PE_funcrel:
      ret = encoding & 0x70;
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      "CFI: unknown pointer encoding [in module %s]",
		      objfile->name);
    }
  return ret;
}

static LONGEST
read_initial_length (bfd *abfd, char *buf, int *bytes_read)
{
  LONGEST ret = 0;

  ret = bfd_get_32 (abfd, (bfd_byte *) buf);

  if (ret == 0xffffffff)
    {
      ret = bfd_get_64 (abfd, (bfd_byte *) buf + 4);
      *bytes_read = 12;
    }
  else
    {
      *bytes_read = 4;
    }

  return ret;
}

static ULONGEST
read_length (bfd *abfd, char *buf, int *bytes_read, int dwarf64)
{
  if (dwarf64)
    {
      *bytes_read = 8;
      return read_8u (abfd, &buf);
    }
  else
    {
      *bytes_read = 4;
      return read_4u (abfd, &buf);
    }
}

static void
execute_cfa_program (struct objfile *objfile, char *insn_ptr, char *insn_end,
		     struct context *context, struct frame_state *fs)
{
  struct frame_state_regs *unused_rs = NULL;

  /* Don't allow remember/restore between CIE and FDE programs.  */
  fs->regs.prev = NULL;

  while (insn_ptr < insn_end && fs->pc < context->ra)
    {
      unsigned char insn = *insn_ptr++;
      ULONGEST reg, uoffset;
      LONGEST offset;

      if (insn & DW_CFA_advance_loc)
	fs->pc += (insn & 0x3f) * fs->code_align;
      else if (insn & DW_CFA_offset)
	{
	  reg = insn & 0x3f;
	  uoffset = read_uleb128 (objfile->obfd, &insn_ptr);
	  offset = (long) uoffset *fs->data_align;
	  fs->regs.reg[reg].how = REG_SAVED_OFFSET;
	  fs->regs.reg[reg].loc.offset = offset;
	}
      else if (insn & DW_CFA_restore)
	{
	  reg = insn & 0x3f;
	  fs->regs.reg[reg].how = REG_UNSAVED;
	}
      else
	switch (insn)
	  {
	  case DW_CFA_set_loc:
	    fs->pc = read_encoded_pointer (objfile->obfd, &insn_ptr,
					   fs->addr_encoding);

	    if (pointer_encoding (fs->addr_encoding, objfile) != PE_absptr)
	      warning
		("CFI: DW_CFA_set_loc uses relative addressing [in module %s]",
		 objfile->name);

	    break;

	  case DW_CFA_advance_loc1:
	    fs->pc += read_1u (objfile->obfd, &insn_ptr);
	    break;
	  case DW_CFA_advance_loc2:
	    fs->pc += read_2u (objfile->obfd, &insn_ptr);
	    break;
	  case DW_CFA_advance_loc4:
	    fs->pc += read_4u (objfile->obfd, &insn_ptr);
	    break;

	  case DW_CFA_offset_extended:
	    reg = read_uleb128 (objfile->obfd, &insn_ptr);
	    uoffset = read_uleb128 (objfile->obfd, &insn_ptr);
	    offset = (long) uoffset *fs->data_align;
	    fs->regs.reg[reg].how = REG_SAVED_OFFSET;
	    fs->regs.reg[reg].loc.offset = offset;
	    break;

	  case DW_CFA_restore_extended:
	    reg = read_uleb128 (objfile->obfd, &insn_ptr);
	    fs->regs.reg[reg].how = REG_UNSAVED;
	    break;

	  case DW_CFA_undefined:
	  case DW_CFA_same_value:
	  case DW_CFA_nop:
	    break;

	  case DW_CFA_register:
	    {
	      ULONGEST reg2;
	      reg = read_uleb128 (objfile->obfd, &insn_ptr);
	      reg2 = read_uleb128 (objfile->obfd, &insn_ptr);
	      fs->regs.reg[reg].how = REG_SAVED_REG;
	      fs->regs.reg[reg].loc.reg = reg2;
	    }
	    break;

	  case DW_CFA_remember_state:
	    {
	      struct frame_state_regs *new_rs;
	      if (unused_rs)
		{
		  new_rs = unused_rs;
		  unused_rs = unused_rs->prev;
		}
	      else
		new_rs = xmalloc (sizeof (struct frame_state_regs));

	      *new_rs = fs->regs;
	      fs->regs.prev = new_rs;
	    }
	    break;

	  case DW_CFA_restore_state:
	    {
	      struct frame_state_regs *old_rs = fs->regs.prev;
	      fs->regs = *old_rs;
	      old_rs->prev = unused_rs;
	      unused_rs = old_rs;
	    }
	    break;

	  case DW_CFA_def_cfa:
	    reg = read_uleb128 (objfile->obfd, &insn_ptr);
	    uoffset = read_uleb128 (objfile->obfd, &insn_ptr);
	    fs->cfa_reg = reg;
	    fs->cfa_offset = uoffset;
	    fs->cfa_how = CFA_REG_OFFSET;
	    break;

	  case DW_CFA_def_cfa_register:
	    reg = read_uleb128 (objfile->obfd, &insn_ptr);
	    fs->cfa_reg = reg;
	    fs->cfa_how = CFA_REG_OFFSET;
	    break;

	  case DW_CFA_def_cfa_offset:
	    uoffset = read_uleb128 (objfile->obfd, &insn_ptr);
	    fs->cfa_offset = uoffset;
	    break;

	  case DW_CFA_def_cfa_expression:
	    uoffset = read_uleb128 (objfile->obfd, &insn_ptr);
	    fs->cfa_exp = insn_ptr;
	    fs->cfa_how = CFA_EXP;
	    insn_ptr += uoffset;
	    break;

	  case DW_CFA_expression:
	    reg = read_uleb128 (objfile->obfd, &insn_ptr);
	    uoffset = read_uleb128 (objfile->obfd, &insn_ptr);
	    fs->regs.reg[reg].how = REG_SAVED_EXP;
	    fs->regs.reg[reg].loc.exp = insn_ptr;
	    insn_ptr += uoffset;
	    break;

	    /* From the 2.1 draft.  */
	  case DW_CFA_offset_extended_sf:
	    reg = read_uleb128 (objfile->obfd, &insn_ptr);
	    offset = read_sleb128 (objfile->obfd, &insn_ptr);
	    offset *= fs->data_align;
	    fs->regs.reg[reg].how = REG_SAVED_OFFSET;
	    fs->regs.reg[reg].loc.offset = offset;
	    break;

	  case DW_CFA_def_cfa_sf:
	    reg = read_uleb128 (objfile->obfd, &insn_ptr);
	    offset = read_sleb128 (objfile->obfd, &insn_ptr);
	    fs->cfa_offset = offset;
	    fs->cfa_reg = reg;
	    fs->cfa_how = CFA_REG_OFFSET;
	    break;

	  case DW_CFA_def_cfa_offset_sf:
	    uoffset = read_uleb128 (objfile->obfd, &insn_ptr);
	    fs->cfa_offset = uoffset;
	    /* cfa_how deliberately not set.  */
	    break;

	  case DW_CFA_GNU_window_save:
	    /* ??? Hardcoded for SPARC register window configuration.  */
	    for (reg = 16; reg < 32; ++reg)
	      {
		fs->regs.reg[reg].how = REG_SAVED_OFFSET;
		fs->regs.reg[reg].loc.offset = (reg - 16) * sizeof (void *);
	      }
	    break;

	  case DW_CFA_GNU_args_size:
	    uoffset = read_uleb128 (objfile->obfd, &insn_ptr);
	    context->args_size = uoffset;
	    break;

	  case DW_CFA_GNU_negative_offset_extended:
	    /* Obsoleted by DW_CFA_offset_extended_sf, but used by
	       older PowerPC code.  */
	    reg = read_uleb128 (objfile->obfd, &insn_ptr);
	    uoffset = read_uleb128 (objfile->obfd, &insn_ptr);
	    offset = (long) uoffset *fs->data_align;
	    fs->regs.reg[reg].how = REG_SAVED_OFFSET;
	    fs->regs.reg[reg].loc.offset = -offset;
	    break;

	  default:
	    error
	      ("dwarf cfi error: unknown cfa instruction %d [in module %s]",
	       insn, objfile->name);
	  }
    }
}

static struct fde_unit *
get_fde_for_addr (CORE_ADDR pc)
{
  size_t lo, hi;
  struct fde_unit *fde = NULL;
  lo = 0;
  hi = fde_chunks.elems;

  while (lo < hi)
    {
      size_t i = (lo + hi) / 2;
      fde = fde_chunks.array[i];
      if (pc < fde->initial_location)
	hi = i;
      else if (pc >= fde->initial_location + fde->address_range)
	lo = i + 1;
      else
	return fde;
    }
  return 0;
}

static void
frame_state_for (struct context *context, struct frame_state *fs)
{
  struct fde_unit *fde;
  struct cie_unit *cie;

  context->args_size = 0;
  context->lsda = 0;

  fde = get_fde_for_addr (context->ra - 1);

  if (fde == NULL)
    return;

  fs->pc = fde->initial_location;

  gdb_assert (fde->cie_ptr != NULL);

  cie = fde->cie_ptr;

  fs->code_align = cie->code_align;
  fs->data_align = cie->data_align;
  fs->retaddr_column = cie->ra;
  fs->addr_encoding = cie->addr_encoding;
  fs->objfile = cie->objfile;

  execute_cfa_program (cie->objfile, cie->data,
		       cie->data + cie->data_length, context, fs);
  execute_cfa_program (cie->objfile, fde->data,
		       fde->data + fde->data_length, context, fs);
}

static void
get_reg (char *reg, struct context *context, int regnum)
{
  switch (context->reg[regnum].how)
    {
    case REG_CTX_UNSAVED:
      deprecated_read_register_gen (regnum, reg);
      break;
    case REG_CTX_SAVED_OFFSET:
      target_read_memory (context->cfa + context->reg[regnum].loc.offset,
			  reg, REGISTER_RAW_SIZE (regnum));
      break;
    case REG_CTX_SAVED_REG:
      deprecated_read_register_gen (context->reg[regnum].loc.reg, reg);
      break;
    case REG_CTX_SAVED_ADDR:
      target_read_memory (context->reg[regnum].loc.addr,
			  reg, REGISTER_RAW_SIZE (regnum));
      break;
    case REG_CTX_VALUE:
      memcpy (reg, &context->reg[regnum].loc.addr,
	      REGISTER_RAW_SIZE (regnum));
      break;
    default:
      internal_error (__FILE__, __LINE__, "get_reg: unknown register rule");
    }
}

/* Decode a DW_OP stack program.  Return the top of stack.  Push INITIAL
   onto the stack to start.  */
static CORE_ADDR
execute_stack_op (struct objfile *objfile,
		  char *op_ptr, char *op_end, struct context *context,
		  CORE_ADDR initial)
{
  CORE_ADDR stack[64];		/* ??? Assume this is enough. */
  int stack_elt;

  stack[0] = initial;
  stack_elt = 1;

  while (op_ptr < op_end)
    {
      enum dwarf_location_atom op = *op_ptr++;
      CORE_ADDR result;
      ULONGEST reg;
      LONGEST offset;

      switch (op)
	{
	case DW_OP_lit0:
	case DW_OP_lit1:
	case DW_OP_lit2:
	case DW_OP_lit3:
	case DW_OP_lit4:
	case DW_OP_lit5:
	case DW_OP_lit6:
	case DW_OP_lit7:
	case DW_OP_lit8:
	case DW_OP_lit9:
	case DW_OP_lit10:
	case DW_OP_lit11:
	case DW_OP_lit12:
	case DW_OP_lit13:
	case DW_OP_lit14:
	case DW_OP_lit15:
	case DW_OP_lit16:
	case DW_OP_lit17:
	case DW_OP_lit18:
	case DW_OP_lit19:
	case DW_OP_lit20:
	case DW_OP_lit21:
	case DW_OP_lit22:
	case DW_OP_lit23:
	case DW_OP_lit24:
	case DW_OP_lit25:
	case DW_OP_lit26:
	case DW_OP_lit27:
	case DW_OP_lit28:
	case DW_OP_lit29:
	case DW_OP_lit30:
	case DW_OP_lit31:
	  result = op - DW_OP_lit0;
	  break;

	case DW_OP_addr:
	  result = read_pointer (objfile->obfd, &op_ptr);
	  break;

	case DW_OP_const1u:
	  result = read_1u (objfile->obfd, &op_ptr);
	  break;
	case DW_OP_const1s:
	  result = read_1s (objfile->obfd, &op_ptr);
	  break;
	case DW_OP_const2u:
	  result = read_2u (objfile->obfd, &op_ptr);
	  break;
	case DW_OP_const2s:
	  result = read_2s (objfile->obfd, &op_ptr);
	  break;
	case DW_OP_const4u:
	  result = read_4u (objfile->obfd, &op_ptr);
	  break;
	case DW_OP_const4s:
	  result = read_4s (objfile->obfd, &op_ptr);
	  break;
	case DW_OP_const8u:
	  result = read_8u (objfile->obfd, &op_ptr);
	  break;
	case DW_OP_const8s:
	  result = read_8s (objfile->obfd, &op_ptr);
	  break;
	case DW_OP_constu:
	  result = read_uleb128 (objfile->obfd, &op_ptr);
	  break;
	case DW_OP_consts:
	  result = read_sleb128 (objfile->obfd, &op_ptr);
	  break;

	case DW_OP_reg0:
	case DW_OP_reg1:
	case DW_OP_reg2:
	case DW_OP_reg3:
	case DW_OP_reg4:
	case DW_OP_reg5:
	case DW_OP_reg6:
	case DW_OP_reg7:
	case DW_OP_reg8:
	case DW_OP_reg9:
	case DW_OP_reg10:
	case DW_OP_reg11:
	case DW_OP_reg12:
	case DW_OP_reg13:
	case DW_OP_reg14:
	case DW_OP_reg15:
	case DW_OP_reg16:
	case DW_OP_reg17:
	case DW_OP_reg18:
	case DW_OP_reg19:
	case DW_OP_reg20:
	case DW_OP_reg21:
	case DW_OP_reg22:
	case DW_OP_reg23:
	case DW_OP_reg24:
	case DW_OP_reg25:
	case DW_OP_reg26:
	case DW_OP_reg27:
	case DW_OP_reg28:
	case DW_OP_reg29:
	case DW_OP_reg30:
	case DW_OP_reg31:
	  get_reg ((char *) &result, context, op - DW_OP_reg0);
	  break;
	case DW_OP_regx:
	  reg = read_uleb128 (objfile->obfd, &op_ptr);
	  get_reg ((char *) &result, context, reg);
	  break;

	case DW_OP_breg0:
	case DW_OP_breg1:
	case DW_OP_breg2:
	case DW_OP_breg3:
	case DW_OP_breg4:
	case DW_OP_breg5:
	case DW_OP_breg6:
	case DW_OP_breg7:
	case DW_OP_breg8:
	case DW_OP_breg9:
	case DW_OP_breg10:
	case DW_OP_breg11:
	case DW_OP_breg12:
	case DW_OP_breg13:
	case DW_OP_breg14:
	case DW_OP_breg15:
	case DW_OP_breg16:
	case DW_OP_breg17:
	case DW_OP_breg18:
	case DW_OP_breg19:
	case DW_OP_breg20:
	case DW_OP_breg21:
	case DW_OP_breg22:
	case DW_OP_breg23:
	case DW_OP_breg24:
	case DW_OP_breg25:
	case DW_OP_breg26:
	case DW_OP_breg27:
	case DW_OP_breg28:
	case DW_OP_breg29:
	case DW_OP_breg30:
	case DW_OP_breg31:
	  offset = read_sleb128 (objfile->obfd, &op_ptr);
	  get_reg ((char *) &result, context, op - DW_OP_breg0);
	  result += offset;
	  break;
	case DW_OP_bregx:
	  reg = read_uleb128 (objfile->obfd, &op_ptr);
	  offset = read_sleb128 (objfile->obfd, &op_ptr);
	  get_reg ((char *) &result, context, reg);
	  result += offset;
	  break;

	case DW_OP_dup:
	  if (stack_elt < 1)
	    internal_error (__FILE__, __LINE__,
			    "execute_stack_op error [in module %s]",
			    objfile->name);
	  result = stack[stack_elt - 1];
	  break;

	case DW_OP_drop:
	  if (--stack_elt < 0)
	    internal_error (__FILE__, __LINE__,
			    "execute_stack_op error [in module %s]",
			    objfile->name);
	  goto no_push;

	case DW_OP_pick:
	  offset = *op_ptr++;
	  if (offset >= stack_elt - 1)
	    internal_error (__FILE__, __LINE__,
			    "execute_stack_op error [in module %s]",
			    objfile->name);
	  result = stack[stack_elt - 1 - offset];
	  break;

	case DW_OP_over:
	  if (stack_elt < 2)
	    internal_error (__FILE__, __LINE__,
			    "execute_stack_op error [in module %s]",
			    objfile->name);
	  result = stack[stack_elt - 2];
	  break;

	case DW_OP_rot:
	  {
	    CORE_ADDR t1, t2, t3;

	    if (stack_elt < 3)
	      internal_error (__FILE__, __LINE__,
			      "execute_stack_op error [in module %s]",
			      objfile->name);
	    t1 = stack[stack_elt - 1];
	    t2 = stack[stack_elt - 2];
	    t3 = stack[stack_elt - 3];
	    stack[stack_elt - 1] = t2;
	    stack[stack_elt - 2] = t3;
	    stack[stack_elt - 3] = t1;
	    goto no_push;
	  }

	case DW_OP_deref:
	case DW_OP_deref_size:
	case DW_OP_abs:
	case DW_OP_neg:
	case DW_OP_not:
	case DW_OP_plus_uconst:
	  /* Unary operations.  */
	  if (--stack_elt < 0)
	    internal_error (__FILE__, __LINE__,
			    "execute_stack_op error [in module %s]",
			    objfile->name);
	  result = stack[stack_elt];

	  switch (op)
	    {
	    case DW_OP_deref:
	      {
		int len = TARGET_ADDR_BIT / TARGET_CHAR_BIT;
		if (len != 4 && len != 8)
		  internal_error (__FILE__, __LINE__,
				  "execute_stack_op error [in module %s]",
				  objfile->name);
		result = read_memory_unsigned_integer (result, len);
	      }
	      break;

	    case DW_OP_deref_size:
	      {
		int len = *op_ptr++;
		if (len != 1 && len != 2 && len != 4 && len != 8)
		  internal_error (__FILE__, __LINE__,
				  "execute_stack_op error [in module %s]",
				  objfile->name);
		result = read_memory_unsigned_integer (result, len);
	      }
	      break;

	    case DW_OP_abs:
	      if (result < 0)
		result = -result;
	      break;
	    case DW_OP_neg:
	      result = -result;
	      break;
	    case DW_OP_not:
	      result = ~result;
	      break;
	    case DW_OP_plus_uconst:
	      result += read_uleb128 (objfile->obfd, &op_ptr);
	      break;
	    default:
	      break;
	    }
	  break;

	case DW_OP_and:
	case DW_OP_div:
	case DW_OP_minus:
	case DW_OP_mod:
	case DW_OP_mul:
	case DW_OP_or:
	case DW_OP_plus:
	case DW_OP_le:
	case DW_OP_ge:
	case DW_OP_eq:
	case DW_OP_lt:
	case DW_OP_gt:
	case DW_OP_ne:
	  {
	    /* Binary operations.  */
	    CORE_ADDR first, second;
	    if ((stack_elt -= 2) < 0)
	      internal_error (__FILE__, __LINE__,
			      "execute_stack_op error [in module %s]",
			      objfile->name);
	    second = stack[stack_elt];
	    first = stack[stack_elt + 1];

	    switch (op)
	      {
	      case DW_OP_and:
		result = second & first;
		break;
	      case DW_OP_div:
		result = (LONGEST) second / (LONGEST) first;
		break;
	      case DW_OP_minus:
		result = second - first;
		break;
	      case DW_OP_mod:
		result = (LONGEST) second % (LONGEST) first;
		break;
	      case DW_OP_mul:
		result = second * first;
		break;
	      case DW_OP_or:
		result = second | first;
		break;
	      case DW_OP_plus:
		result = second + first;
		break;
	      case DW_OP_shl:
		result = second << first;
		break;
	      case DW_OP_shr:
		result = second >> first;
		break;
	      case DW_OP_shra:
		result = (LONGEST) second >> first;
		break;
	      case DW_OP_xor:
		result = second ^ first;
		break;
	      case DW_OP_le:
		result = (LONGEST) first <= (LONGEST) second;
		break;
	      case DW_OP_ge:
		result = (LONGEST) first >= (LONGEST) second;
		break;
	      case DW_OP_eq:
		result = (LONGEST) first == (LONGEST) second;
		break;
	      case DW_OP_lt:
		result = (LONGEST) first < (LONGEST) second;
		break;
	      case DW_OP_gt:
		result = (LONGEST) first > (LONGEST) second;
		break;
	      case DW_OP_ne:
		result = (LONGEST) first != (LONGEST) second;
		break;
	      default:
		error
		  ("execute_stack_op: Unknown DW_OP_ value [in module %s]",
		   objfile->name);
		break;
	      }
	  }
	  break;

	case DW_OP_skip:
	  offset = read_2s (objfile->obfd, &op_ptr);
	  op_ptr += offset;
	  goto no_push;

	case DW_OP_bra:
	  if (--stack_elt < 0)
	    internal_error (__FILE__, __LINE__,
			    "execute_stack_op error [in module %s]",
			    objfile->name);
	  offset = read_2s (objfile->obfd, &op_ptr);
	  if (stack[stack_elt] != 0)
	    op_ptr += offset;
	  goto no_push;

	case DW_OP_nop:
	  goto no_push;

	default:
	  internal_error (__FILE__, __LINE__,
			  "execute_stack_op error [in module %s]",
			  objfile->name);
	}

      /* Most things push a result value.  */
      if ((size_t) stack_elt >= sizeof (stack) / sizeof (*stack))
	internal_error (__FILE__, __LINE__,
			"execute_stack_op error [in module %s]",
			objfile->name);
      stack[++stack_elt] = result;
    no_push:;
    }

  /* We were executing this program to get a value.  It should be
     at top of stack.  */
  if (--stack_elt < 0)
    internal_error (__FILE__, __LINE__,
		    "execute_stack_op error [in module %s]", objfile->name);
  return stack[stack_elt];
}

static void
update_context (struct context *context, struct frame_state *fs, int chain)
{
  struct context *orig_context;
  CORE_ADDR cfa = 0;
  long i;

  unwind_tmp_obstack_init ();

  orig_context = context_alloc ();
  context_cpy (orig_context, context);

  /* Compute this frame's CFA.  */
  switch (fs->cfa_how)
    {
    case CFA_REG_OFFSET:
      get_reg ((char *) &cfa, context, fs->cfa_reg);
      cfa += fs->cfa_offset;
      break;

    case CFA_EXP:
      /* ??? No way of knowing what register number is the stack pointer
         to do the same sort of handling as above.  Assume that if the
         CFA calculation is so complicated as to require a stack program
         that this will not be a problem.  */
      {
	char *exp = fs->cfa_exp;
	ULONGEST len;

	len = read_uleb128 (fs->objfile->obfd, &exp);
	cfa = (CORE_ADDR) execute_stack_op (fs->objfile, exp,
					    exp + len, context, 0);
	break;
      }
    default:
      break;
    }
  context->cfa = cfa;

  if (!chain)
    orig_context->cfa = cfa;

  /* Compute the addresses of all registers saved in this frame.  */
  for (i = 0; i < NUM_REGS; ++i)
    switch (fs->regs.reg[i].how)
      {
      case REG_UNSAVED:
	if (i == SP_REGNUM)
	  {
	    context->reg[i].how = REG_CTX_VALUE;
	    context->reg[i].loc.addr = cfa;
	  }
	else
	  context->reg[i].how = REG_CTX_UNSAVED;
	break;
      case REG_SAVED_OFFSET:
	context->reg[i].how = REG_CTX_SAVED_OFFSET;
	context->reg[i].loc.offset = fs->regs.reg[i].loc.offset;
	break;
      case REG_SAVED_REG:
	switch (orig_context->reg[fs->regs.reg[i].loc.reg].how)
	  {
	  case REG_CTX_UNSAVED:
	    context->reg[i].how = REG_CTX_UNSAVED;
	    break;
	  case REG_CTX_SAVED_OFFSET:
	    context->reg[i].how = REG_CTX_SAVED_OFFSET;
	    context->reg[i].loc.offset = orig_context->cfa - context->cfa +
	      orig_context->reg[fs->regs.reg[i].loc.reg].loc.offset;
	    break;
	  case REG_CTX_SAVED_REG:
	    context->reg[i].how = REG_CTX_SAVED_REG;
	    context->reg[i].loc.reg =
	      orig_context->reg[fs->regs.reg[i].loc.reg].loc.reg;
	    break;
	  case REG_CTX_SAVED_ADDR:
	    context->reg[i].how = REG_CTX_SAVED_ADDR;
	    context->reg[i].loc.addr =
	      orig_context->reg[fs->regs.reg[i].loc.reg].loc.addr;
	    break;
	  default:
	    internal_error (__FILE__, __LINE__, "bad switch 0x%02X",
			    orig_context->reg[fs->regs.reg[i].loc.reg].how);
	  }
	break;
      case REG_SAVED_EXP:
	{
	  char *exp = fs->regs.reg[i].loc.exp;
	  ULONGEST len;
	  CORE_ADDR val;

	  len = read_uleb128 (fs->objfile->obfd, &exp);
	  val = execute_stack_op (fs->objfile, exp, exp + len,
				  orig_context, cfa);
	  context->reg[i].how = REG_CTX_SAVED_ADDR;
	  context->reg[i].loc.addr = val;
	}
	break;
      default:
	internal_error (__FILE__, __LINE__, "bad switch 0x%02X",
			fs->regs.reg[i].how);
      }
  get_reg ((char *) &context->ra, context, fs->retaddr_column);
  unwind_tmp_obstack_free ();
}

static int
is_cie (ULONGEST cie_id, int dwarf64)
{
  return dwarf64 ? (cie_id == 0xffffffffffffffff) : (cie_id == 0xffffffff);
}

static int
compare_fde_unit (const void *a, const void *b)
{
  struct fde_unit **first, **second;
  first = (struct fde_unit **) a;
  second = (struct fde_unit **) b;
  if ((*first)->initial_location > (*second)->initial_location)
    return 1;
  else if ((*first)->initial_location < (*second)->initial_location)
    return -1;
  else
    return 0;
}

/*  Build the cie_chunks and fde_chunks tables from informations
    found in .debug_frame and .eh_frame sections.  */
/* We can handle both of these sections almost in the same way, however there
   are some exceptions:
   - CIE ID is -1 in debug_frame, but 0 in eh_frame
   - eh_frame may contain some more information that are used only by gcc 
     (eg. personality pointer, LSDA pointer, ...). Most of them we can ignore.
   - In debug_frame FDE's item cie_id contains offset of it's parent CIE.
     In eh_frame FDE's item cie_id is a relative pointer to the parent CIE.
     Anyway we don't need to bother with this, because we are smart enough 
     to keep the pointer to the parent CIE of oncomming FDEs in 'last_cie'.
   - Although debug_frame items can contain Augmentation as well as 
     eh_frame ones, I have never seen them non-empty. Thus only in eh_frame 
     we can encounter for example non-absolute pointers (Aug. 'R').  
                                                              -- mludvig  */
static void
parse_frame_info (struct objfile *objfile, file_ptr frame_offset,
		  unsigned int frame_size, asection *frame_section,
		  int eh_frame)
{
  bfd *abfd = objfile->obfd;
  asection *curr_section_ptr;
  char *start = NULL;
  char *end = NULL;
  char *frame_buffer = NULL;
  char *curr_section_name, *aug_data;
  struct cie_unit *last_cie = NULL;
  int last_dup_fde = 0;
  int aug_len, i;
  CORE_ADDR curr_section_vma = 0;

  unwind_tmp_obstack_init ();

  frame_buffer = dwarf2_read_section (objfile, frame_offset, frame_size,
				      frame_section);

  start = frame_buffer;
  end = frame_buffer + frame_size;

  curr_section_name = eh_frame ? ".eh_frame" : ".debug_frame";
  curr_section_ptr = bfd_get_section_by_name (abfd, curr_section_name);
  if (curr_section_ptr)
    curr_section_vma = curr_section_ptr->vma;

  if (start)
    {
      while (start < end)
	{
	  unsigned long length;
	  ULONGEST cie_id;
	  ULONGEST unit_offset = start - frame_buffer;
	  int bytes_read, dwarf64;
	  char *block_end;

	  length = read_initial_length (abfd, start, &bytes_read);
	  start += bytes_read;
	  dwarf64 = (bytes_read == 12);
	  block_end = start + length;

	  if (length == 0)
	    {
	      start = block_end;
	      continue;
	    }

	  cie_id = read_length (abfd, start, &bytes_read, dwarf64);
	  start += bytes_read;

	  if ((eh_frame && cie_id == 0) || is_cie (cie_id, dwarf64))
	    {
	      struct cie_unit *cie = cie_unit_alloc ();
	      char *aug;

	      cie->objfile = objfile;
	      cie->next = cie_chunks;
	      cie_chunks = cie;

	      cie->objfile = objfile;

	      cie->offset = unit_offset;

	      start++;		/* version */

	      cie->augmentation = aug = start;
	      while (*start++);	/* Skips last NULL as well */

	      cie->code_align = read_uleb128 (abfd, &start);
	      cie->data_align = read_sleb128 (abfd, &start);
	      cie->ra = read_1u (abfd, &start);

	      /* Augmentation:
	         z      Indicates that a uleb128 is present to size the
	         augmentation section.
	         L      Indicates the encoding (and thus presence) of
	         an LSDA pointer in the FDE augmentation.
	         R      Indicates a non-default pointer encoding for
	         FDE code pointers.
	         P      Indicates the presence of an encoding + language
	         personality routine in the CIE augmentation.

	         [This info comes from GCC's dwarf2out.c]
	       */
	      if (*aug == 'z')
		{
		  aug_len = read_uleb128 (abfd, &start);
		  aug_data = start;
		  start += aug_len;
		  ++aug;
		}

	      cie->data = start;
	      cie->data_length = block_end - cie->data;

	      while (*aug != '\0')
		{
		  if (aug[0] == 'e' && aug[1] == 'h')
		    {
		      aug_data += sizeof (void *);
		      aug++;
		    }
		  else if (aug[0] == 'R')
		    cie->addr_encoding = *aug_data++;
		  else if (aug[0] == 'P')
		    {
		      CORE_ADDR pers_addr;
		      int pers_addr_enc;

		      pers_addr_enc = *aug_data++;
		      /* We don't need pers_addr value and so we 
		         don't care about it's encoding.  */
		      pers_addr = read_encoded_pointer (abfd, &aug_data,
							pers_addr_enc);
		    }
		  else if (aug[0] == 'L' && eh_frame)
		    {
		      int lsda_addr_enc;

		      /* Perhaps we should save this to CIE for later use?
		         Do we need it for something in GDB?  */
		      lsda_addr_enc = *aug_data++;
		    }
		  else
		    warning ("CFI warning: unknown augmentation \"%c\""
			     " in \"%s\" of\n"
			     "\t%s", aug[0], curr_section_name,
			     objfile->name);
		  aug++;
		}

	      last_cie = cie;
	    }
	  else
	    {
	      struct fde_unit *fde;
	      struct cie_unit *cie;
	      int dup = 0;
	      CORE_ADDR init_loc;

	      /* We assume that debug_frame is in order 
	         CIE,FDE,CIE,FDE,FDE,...  and thus the CIE for this FDE
	         should be stored in last_cie pointer. If not, we'll 
	         try to find it by the older way.  */
	      if (last_cie)
		cie = last_cie;
	      else
		{
		  warning ("CFI: last_cie == NULL. "
			   "Perhaps a malformed %s section in '%s'...?\n",
			   curr_section_name, objfile->name);

		  cie = cie_chunks;
		  while (cie)
		    {
		      if (cie->objfile == objfile)
			{
			  if (eh_frame &&
			      (cie->offset ==
			       (unit_offset + bytes_read - cie_id)))
			    break;
			  if (!eh_frame && (cie->offset == cie_id))
			    break;
			}

		      cie = cie->next;
		    }
		  if (!cie)
		    error ("CFI: can't find CIE pointer [in module %s]",
			   bfd_get_filename (abfd));
		}

	      init_loc = read_encoded_pointer (abfd, &start,
					       cie->addr_encoding);

	      switch (pointer_encoding (cie->addr_encoding, objfile))
		{
		case PE_absptr:
		  break;
		case PE_pcrel:
		  /* start-frame_buffer gives offset from 
		     the beginning of actual section.  */
		  init_loc += curr_section_vma + start - frame_buffer;
		  break;
		default:
		  warning ("CFI: Unsupported pointer encoding [in module %s]",
			   bfd_get_filename (abfd));
		}

	      /* For relocatable objects we must add an offset telling
	         where the section is actually mapped in the memory.  */
	      init_loc += ANOFFSET (objfile->section_offsets,
				    SECT_OFF_TEXT (objfile));

	      /* If we have both .debug_frame and .eh_frame present in 
	         a file, we must eliminate duplicate FDEs. For now we'll 
	         run through all entries in fde_chunks and check it one 
	         by one. Perhaps in the future we can implement a faster 
	         searching algorithm.  */
	      /* eh_frame==2 indicates, that this file has an already 
	         parsed .debug_frame too. When eh_frame==1 it means, that no
	         .debug_frame is present and thus we don't need to check for
	         duplicities. eh_frame==0 means, that we parse .debug_frame
	         and don't need to care about duplicate FDEs, because
	         .debug_frame is parsed first.  */
	      if (eh_frame == 2)
		for (i = 0; eh_frame == 2 && i < fde_chunks.elems; i++)
		  {
		    /* We assume that FDEs in .debug_frame and .eh_frame 
		       have the same order (if they are present, of course).
		       If we find a duplicate entry for one FDE and save
		       it's index to last_dup_fde it's very likely, that 
		       we'll find an entry for the following FDE right after 
		       the previous one. Thus in many cases we'll run this 
		       loop only once.  */
		    last_dup_fde = (last_dup_fde + i) % fde_chunks.elems;
		    if (fde_chunks.array[last_dup_fde]->initial_location
			== init_loc)
		      {
			dup = 1;
			break;
		      }
		  }

	      /* Allocate a new entry only if this FDE isn't a duplicate of
	         something we have already seen.   */
	      if (!dup)
		{
		  fde_chunks_need_space ();
		  fde = fde_unit_alloc ();

		  fde_chunks.array[fde_chunks.elems++] = fde;

		  fde->initial_location = init_loc;
		  fde->address_range = read_encoded_pointer (abfd, &start,
							     cie->
							     addr_encoding);

		  fde->cie_ptr = cie;

		  /* Here we intentionally ignore augmentation data
		     from FDE, because we don't need them.  */
		  if (cie->augmentation[0] == 'z')
		    start += read_uleb128 (abfd, &start);

		  fde->data = start;
		  fde->data_length = block_end - start;
		}
	    }
	  start = block_end;
	}
      qsort (fde_chunks.array, fde_chunks.elems,
	     sizeof (struct fde_unit *), compare_fde_unit);
    }
}

/* We must parse both .debug_frame section and .eh_frame because 
 * not all frames must be present in both of these sections. */
void
dwarf2_build_frame_info (struct objfile *objfile)
{
  int after_debug_frame = 0;

  /* If we have .debug_frame then the parser is called with 
     eh_frame==0 for .debug_frame and eh_frame==2 for .eh_frame, 
     otherwise it's only called once for .eh_frame with argument 
     eh_frame==1.  */

  if (dwarf_frame_offset)
    {
      parse_frame_info (objfile, dwarf_frame_offset,
			dwarf_frame_size, dwarf_frame_section,
			0 /* = debug_frame */ );
      after_debug_frame = 1;
    }

  if (dwarf_eh_frame_offset)
    parse_frame_info (objfile, dwarf_eh_frame_offset, dwarf_eh_frame_size,
		      dwarf_eh_frame_section,
		      1 /* = eh_frame */  + after_debug_frame);
}

/* Return the frame address.  */
CORE_ADDR
cfi_read_fp (void)
{
  struct context *context;
  struct frame_state *fs;
  CORE_ADDR cfa;

  unwind_tmp_obstack_init ();

  context = context_alloc ();
  fs = frame_state_alloc ();

  context->ra = read_pc () + 1;

  frame_state_for (context, fs);
  update_context (context, fs, 0);

  cfa = context->cfa;

  unwind_tmp_obstack_free ();

  return cfa;
}

/* Store the frame address.  This function is not used.  */

void
cfi_write_fp (CORE_ADDR val)
{
  struct context *context;
  struct frame_state *fs;

  unwind_tmp_obstack_init ();

  context = context_alloc ();
  fs = frame_state_alloc ();

  context->ra = read_pc () + 1;

  frame_state_for (context, fs);

  if (fs->cfa_how == CFA_REG_OFFSET)
    {
      val -= fs->cfa_offset;
      deprecated_write_register_gen (fs->cfa_reg, (char *) &val);
    }
  else
    warning ("Can't write fp.");

  unwind_tmp_obstack_free ();
}

/* Restore the machine to the state it had before the current frame
   was created.  */
void
cfi_pop_frame (struct frame_info *fi)
{
  char regbuf[MAX_REGISTER_SIZE];
  int regnum;

  for (regnum = 0; regnum < NUM_REGS; regnum++)
    {
      get_reg (regbuf, UNWIND_CONTEXT (fi), regnum);
      deprecated_write_register_bytes (REGISTER_BYTE (regnum), regbuf,
				       REGISTER_RAW_SIZE (regnum));
    }
  write_register (PC_REGNUM, UNWIND_CONTEXT (fi)->ra);

  flush_cached_frames ();
}

/* Determine the address of the calling function's frame.  */
CORE_ADDR
cfi_frame_chain (struct frame_info *fi)
{
  struct context *context;
  struct frame_state *fs;
  CORE_ADDR cfa;

  unwind_tmp_obstack_init ();

  context = context_alloc ();
  fs = frame_state_alloc ();
  context_cpy (context, UNWIND_CONTEXT (fi));

  /* outermost frame */
  if (context->ra == 0)
    {
      unwind_tmp_obstack_free ();
      return 0;
    }

  frame_state_for (context, fs);
  update_context (context, fs, 1);

  cfa = context->cfa;
  unwind_tmp_obstack_free ();

  return cfa;
}

/* Sets the pc of the frame.  */
CORE_ADDR
cfi_init_frame_pc (int fromleaf, struct frame_info *fi)
{
  if (get_next_frame (fi))
    {
      CORE_ADDR pc;
      /* FIXME: cagney/2002-12-04: This is straight wrong.  It's
         assuming that the PC is CORE_ADDR (a host quantity) in size.  */
      get_reg ((void *) &pc, UNWIND_CONTEXT (get_next_frame (fi)), PC_REGNUM);
      return pc;
    }
  else
    return read_pc ();
}

/* Initialize unwind context informations of the frame.  */
void
cfi_init_extra_frame_info (int fromleaf, struct frame_info *fi)
{
  struct frame_state *fs;

  unwind_tmp_obstack_init ();

  fs = frame_state_alloc ();
  deprecated_set_frame_context (fi,
				frame_obstack_zalloc (sizeof
						      (struct context)));
  UNWIND_CONTEXT (fi)->reg =
    frame_obstack_zalloc (sizeof (struct context_reg) * NUM_REGS);
  memset (UNWIND_CONTEXT (fi)->reg, 0,
	  sizeof (struct context_reg) * NUM_REGS);

  if (get_next_frame (fi))
    {
      context_cpy (UNWIND_CONTEXT (fi), UNWIND_CONTEXT (get_next_frame (fi)));
      frame_state_for (UNWIND_CONTEXT (fi), fs);
      update_context (UNWIND_CONTEXT (fi), fs, 1);
    }
  else
    {
      UNWIND_CONTEXT (fi)->ra = get_frame_pc (fi) + 1;
      frame_state_for (UNWIND_CONTEXT (fi), fs);
      update_context (UNWIND_CONTEXT (fi), fs, 0);
    }

  unwind_tmp_obstack_free ();
}

/* Obtain return address of the frame.  */
CORE_ADDR
cfi_get_ra (struct frame_info *fi)
{
  return UNWIND_CONTEXT (fi)->ra;
}

/* Find register number REGNUM relative to FRAME and put its
   (raw) contents in *RAW_BUFFER.  Set *OPTIMIZED if the variable
   was optimized out (and thus can't be fetched).  If the variable
   was fetched from memory, set *ADDRP to where it was fetched from,
   otherwise it was fetched from a register.

   The argument RAW_BUFFER must point to aligned memory.  */
void
cfi_get_saved_register (char *raw_buffer,
			int *optimized,
			CORE_ADDR *addrp,
			struct frame_info *frame,
			int regnum, enum lval_type *lval)
{
  if (!target_has_registers)
    error ("No registers.");

  /* Normal systems don't optimize out things with register numbers.  */
  if (optimized != NULL)
    *optimized = 0;

  if (addrp)			/* default assumption: not found in memory */
    *addrp = 0;

  if (!get_next_frame (frame))
    {
      deprecated_read_register_gen (regnum, raw_buffer);
      if (lval != NULL)
	*lval = lval_register;
      if (addrp != NULL)
	*addrp = REGISTER_BYTE (regnum);
    }
  else
    {
      frame = get_next_frame (frame);
      switch (UNWIND_CONTEXT (frame)->reg[regnum].how)
	{
	case REG_CTX_UNSAVED:
	  deprecated_read_register_gen (regnum, raw_buffer);
	  if (lval != NULL)
	    *lval = not_lval;
	  if (optimized != NULL)
	    *optimized = 1;
	  break;
	case REG_CTX_SAVED_OFFSET:
	  target_read_memory (UNWIND_CONTEXT (frame)->cfa +
			      UNWIND_CONTEXT (frame)->reg[regnum].loc.offset,
			      raw_buffer, REGISTER_RAW_SIZE (regnum));
	  if (lval != NULL)
	    *lval = lval_memory;
	  if (addrp != NULL)
	    *addrp =
	      UNWIND_CONTEXT (frame)->cfa +
	      UNWIND_CONTEXT (frame)->reg[regnum].loc.offset;
	  break;
	case REG_CTX_SAVED_REG:
	  deprecated_read_register_gen (UNWIND_CONTEXT (frame)->reg[regnum].
					loc.reg, raw_buffer);
	  if (lval != NULL)
	    *lval = lval_register;
	  if (addrp != NULL)
	    *addrp =
	      REGISTER_BYTE (UNWIND_CONTEXT (frame)->reg[regnum].loc.reg);
	  break;
	case REG_CTX_SAVED_ADDR:
	  target_read_memory (UNWIND_CONTEXT (frame)->reg[regnum].loc.addr,
			      raw_buffer, REGISTER_RAW_SIZE (regnum));
	  if (lval != NULL)
	    *lval = lval_memory;
	  if (addrp != NULL)
	    *addrp = UNWIND_CONTEXT (frame)->reg[regnum].loc.addr;
	  break;
	case REG_CTX_VALUE:
	  memcpy (raw_buffer, &UNWIND_CONTEXT (frame)->reg[regnum].loc.addr,
		  REGISTER_RAW_SIZE (regnum));
	  if (lval != NULL)
	    *lval = not_lval;
	  if (optimized != NULL)
	    *optimized = 0;
	  break;
	default:
	  internal_error (__FILE__, __LINE__,
			  "cfi_get_saved_register: unknown register rule 0x%02X",
			  UNWIND_CONTEXT (frame)->reg[regnum].how);
	}
    }
}

/*  Return the register that the function uses for a frame pointer,
    plus any necessary offset to be applied to the register before
    any frame pointer offsets.  */
void
cfi_virtual_frame_pointer (CORE_ADDR pc, int *frame_reg,
			   LONGEST * frame_offset)
{
  struct context *context;
  struct frame_state *fs;

  unwind_tmp_obstack_init ();

  context = context_alloc ();
  fs = frame_state_alloc ();

  context->ra = read_pc () + 1;

  frame_state_for (context, fs);

  if (fs->cfa_how == CFA_REG_OFFSET)
    {
      *frame_reg = fs->cfa_reg;
      *frame_offset = fs->cfa_offset;
    }
  else
    error ("dwarf cfi error: CFA is not defined as CFA_REG_OFFSET");

  unwind_tmp_obstack_free ();
}
@


1.33
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@@


1.32
log
@	From Mark Dettinger <dettinge@@de.ibm.com>:
	* dwarf2cfi.c (read_2u): Increment pointer by two.
@
text
@d1754 1
a1754 1
  char *regbuf = alloca (MAX_REGISTER_RAW_SIZE);
@


1.32.8.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1754 1
a1754 1
  char regbuf[MAX_REGISTER_SIZE];
@


1.31
log
@* dwarf2cfi.c: Reindented.
@
text
@d348 1
a348 1
  (*p)++;
@


1.30
log
@2003-02-03  Michal Ludvig  <mludvig@@suse.cz>

	* dwarf2cfi.c (pointer_encoding): Added new parameter.
	* dwarf2cfi.c, dwarf2read.c: Changed all warnings and
	error messages to contain BFD filename.
@
text
@d175 1
a176 1

d179 1
a179 1
				  unsigned int size, asection* sectp);
d202 2
a203 1
static enum ptr_encoding pointer_encoding (unsigned char encoding, struct objfile *objfile);
d466 3
a468 2
      error ("dwarf cfi error: unsupported target address length [in module %s]", 
		      bfd_get_filename (abfd));
d532 3
a534 2
    warning ("CFI: Unsupported pointer encoding: DW_EH_PE_indirect [in module %s]",
		    objfile->name);
d546 2
a547 1
      internal_error (__FILE__, __LINE__, "CFI: unknown pointer encoding [in module %s]", 
d626 3
a628 2
	      warning ("CFI: DW_CFA_set_loc uses relative addressing [in module %s]", 
			      objfile->name);
d777 3
a779 2
	    error ("dwarf cfi error: unknown cfa instruction %d [in module %s]", insn, 
			    objfile->name);
d1042 3
a1044 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1050 3
a1052 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1058 3
a1060 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1066 3
a1068 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1077 3
a1079 1
	      internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1097 3
a1099 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1109 2
a1110 1
				  "execute_stack_op error [in module %s]", objfile->name);
d1120 2
a1121 1
				  "execute_stack_op error [in module %s]", objfile->name);
d1161 3
a1163 1
	      internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1221 3
a1223 1
		error ("execute_stack_op: Unknown DW_OP_ value [in module %s]", objfile->name);
d1236 3
a1238 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1248 3
a1250 1
	  internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1255 3
a1257 1
	internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1265 2
a1266 1
    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1351 1
a1351 1
	    internal_error (__FILE__, __LINE__, "bad switch 0x%02X", 
d1582 2
a1583 2
		    error ("CFI: can't find CIE pointer [in module %s]", 
				    bfd_get_filename (abfd));
d1600 1
a1600 1
				  bfd_get_filename (abfd));
d1807 1
a1807 1
      get_reg ((void *)&pc, UNWIND_CONTEXT (get_next_frame (fi)), PC_REGNUM);
d1823 3
a1825 1
  deprecated_set_frame_context (fi, frame_obstack_zalloc (sizeof (struct context)));
d1910 2
a1911 2
	  deprecated_read_register_gen (UNWIND_CONTEXT (frame)->reg[regnum].loc.reg,
					raw_buffer);
@


1.29
log
@	* dbxread.c (stabs_data): New static variable.
	(fill_symbuf): Support an in-memory buffer for stabs data.
	(stabs_seek): New function.
	(dbx_psymtab_to_symtab): Relocate the stabs data if necessary.
	(read_ofile_symtab): Use stabs_seek.
	(elfstab_build_psymtabs): Take an asection* instead of
	an offset and size.  Relocate the stabs data if necessary.
	Save the section* for dbx_psymtab_to_symtab.
	* dwarf2read.c: Add section variables for each debug section.
	(dwarf2_locate_sections): Fill them in.
	(dwarf2_read_section): Take an asection* argument.
	Relocate the section contents if necessary.
	(dwarf2_build_psymtabs, dwarf2_build_psymtabs_easy): Update callers.
	* dwarf2cfi.c (parse_frame_info): Take a section argument and pass
	it to dwarf2_read_section.
	(dwarf2_build_frame_info): Update callers.
	* elfread.c (elf_symfile_read): Update call to
	elfstab_build_psymtabs.
	* gdb-stabs.h (struct dbx_symfile_info): Add stab_section.
	(DBX_STAB_SECTION): New macro.
	* stabsread.h (elfstab_build_psymtabs): Update prototype.
	* symfile.c (symfile_dummy_outputs): New function.
	(symfile_relocate_debug_section): New function.
	* symfile.h (symfile_relocate_debug_section): Add prototype.
@
text
@d202 1
a202 1
static enum ptr_encoding pointer_encoding (unsigned char encoding);
d465 2
a466 1
      error ("dwarf cfi error: unsupported target address length.");
d513 2
a514 1
		      "read_encoded_pointer: unknown pointer encoding");
d525 1
a525 1
pointer_encoding (unsigned char encoding)
d530 2
a531 1
    warning ("CFI: Unsupported pointer encoding: DW_EH_PE_indirect");
d543 2
a544 1
      internal_error (__FILE__, __LINE__, "CFI: unknown pointer encoding");
d621 3
a623 2
	    if (pointer_encoding (fs->addr_encoding) != PE_absptr)
	      warning ("CFI: DW_CFA_set_loc uses relative addressing");
d772 2
a773 1
	    error ("dwarf cfi error: unknown cfa instruction %d.", insn);
d1036 1
a1036 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error");
d1042 1
a1042 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error");
d1048 1
a1048 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error");
d1054 1
a1054 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error");
d1063 1
a1063 1
	      internal_error (__FILE__, __LINE__, "execute_stack_op error");
d1081 1
a1081 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error");
d1091 1
a1091 1
				  "execute_stack_op error");
d1101 1
a1101 1
				  "execute_stack_op error");
d1141 1
a1141 1
	      internal_error (__FILE__, __LINE__, "execute_stack_op error");
d1199 1
a1199 1
		error ("execute_stack_op: Unknown DW_OP_ value");
d1212 1
a1212 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error");
d1222 1
a1222 1
	  internal_error (__FILE__, __LINE__, "execute_stack_op error");
d1227 1
a1227 1
	internal_error (__FILE__, __LINE__, "execute_stack_op error");
d1235 1
a1235 1
    internal_error (__FILE__, __LINE__, "execute_stack_op error");
d1320 2
a1321 1
	    internal_error (__FILE__, __LINE__, "bad switch");
d1338 2
a1339 1
	internal_error (__FILE__, __LINE__, "bad switch");
d1551 2
a1552 1
		    error ("CFI: can't find CIE pointer");
d1558 1
a1558 1
	      switch (pointer_encoding (cie->addr_encoding))
d1568 2
a1569 1
		  warning ("CFI: Unsupported pointer encoding\n");
d1903 2
a1904 1
			  "cfi_get_saved_register: unknown register rule");
@


1.29.2.1
log
@Merge with interps-20030203-mergepoint.
@
text
@d202 1
a202 1
static enum ptr_encoding pointer_encoding (unsigned char encoding, struct objfile *objfile);
d465 1
a465 2
      error ("dwarf cfi error: unsupported target address length [in module %s]", 
		      bfd_get_filename (abfd));
d512 1
a512 2
		      "read_encoded_pointer: unknown pointer encoding [in module %s]",
		      bfd_get_filename (abfd));
d523 1
a523 1
pointer_encoding (unsigned char encoding, struct objfile *objfile)
d528 1
a528 2
    warning ("CFI: Unsupported pointer encoding: DW_EH_PE_indirect [in module %s]",
		    objfile->name);
d540 1
a540 2
      internal_error (__FILE__, __LINE__, "CFI: unknown pointer encoding [in module %s]", 
		      objfile->name);
d617 2
a618 3
	    if (pointer_encoding (fs->addr_encoding, objfile) != PE_absptr)
	      warning ("CFI: DW_CFA_set_loc uses relative addressing [in module %s]", 
			      objfile->name);
d767 1
a767 2
	    error ("dwarf cfi error: unknown cfa instruction %d [in module %s]", insn, 
			    objfile->name);
d1030 1
a1030 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1036 1
a1036 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1042 1
a1042 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1048 1
a1048 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1057 1
a1057 1
	      internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1075 1
a1075 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1085 1
a1085 1
				  "execute_stack_op error [in module %s]", objfile->name);
d1095 1
a1095 1
				  "execute_stack_op error [in module %s]", objfile->name);
d1135 1
a1135 1
	      internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1193 1
a1193 1
		error ("execute_stack_op: Unknown DW_OP_ value [in module %s]", objfile->name);
d1206 1
a1206 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1216 1
a1216 1
	  internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1221 1
a1221 1
	internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1229 1
a1229 1
    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1314 1
a1314 2
	    internal_error (__FILE__, __LINE__, "bad switch 0x%02X", 
			    orig_context->reg[fs->regs.reg[i].loc.reg].how);
d1331 1
a1331 2
	internal_error (__FILE__, __LINE__, "bad switch 0x%02X",
			fs->regs.reg[i].how);
d1543 1
a1543 2
		    error ("CFI: can't find CIE pointer [in module %s]", 
				    bfd_get_filename (abfd));
d1549 1
a1549 1
	      switch (pointer_encoding (cie->addr_encoding, objfile))
d1559 1
a1559 2
		  warning ("CFI: Unsupported pointer encoding [in module %s]",
				  bfd_get_filename (abfd));
d1893 1
a1893 2
			  "cfi_get_saved_register: unknown register rule 0x%02X",
			  UNWIND_CONTEXT (frame)->reg[regnum].how);
@


1.28
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@d173 3
d179 1
a179 1
				  unsigned int size);
d1374 2
a1375 1
		  unsigned int frame_size, int eh_frame)
d1390 2
a1391 1
  frame_buffer = dwarf2_read_section (objfile, frame_offset, frame_size);
d1644 2
a1645 1
			dwarf_frame_size, 0 /* = debug_frame */ );
d1651 1
@


1.27
log
@2003-01-09  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (frame_obstack_zalloc): Replace frame_obstack_alloc.
	Update comments.
	* frame.c (frame_obstack_zalloc): Replace frame_obstack_alloc.
	(frame_saved_regs_zalloc): Update.
	(frame_saved_regs_register_unwind): Update.
	(create_new_frame): Update.
	(get_prev_frame): Update.
	(frame_extra_info_zalloc): Update.
	(deprecated_get_frame_saved_regs): Update.
	* dwarf2cfi.c (cfi_init_extra_frame_info): Update.
	* cris-tdep.c: Update comment.
@
text
@d2 3
a4 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
@


1.26
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_next_frame.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10200-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, sparc-tdep.c: Ditto.
	* v850-tdep.c, vax-tdep.c, x86-64-linux-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
@
text
@d1773 1
a1773 1
  deprecated_set_frame_context (fi, frame_obstack_alloc (sizeof (struct context)));
d1775 1
a1775 1
    frame_obstack_alloc (sizeof (struct context_reg) * NUM_REGS);
@


1.25
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (deprecated_get_frame_context): New function.
	(deprecated_set_frame_context): New function.
	* frame.h (deprecated_get_frame_context): Declare.
	(deprecated_set_frame_context): Declare.
	* dwarf2cfi.c (UNWIND_CONTEXT): Use deprecated_get_frame_context.
	(cfi_init_extra_frame_info): Use deprecated_set_frame_context.
@
text
@d1779 1
a1779 1
  if (fi->next)
d1781 1
a1781 1
      context_cpy (UNWIND_CONTEXT (fi), UNWIND_CONTEXT (fi->next));
d1826 1
a1826 1
  if (!frame->next)
d1836 1
a1836 1
      frame = frame->next;
@


1.24
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c: Use get_frame_pc and deprecated_update_frame_pc_hack
	frame accessor methods.
	* alpha-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Ditto.
	* s390-tdep.c, sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* z8k-tdep.c: Ditto.
@
text
@d159 1
a159 1
#define UNWIND_CONTEXT(fi) ((struct context *) (fi->context))
d1773 1
a1773 1
  fi->context = frame_obstack_alloc (sizeof (struct context));
@


1.23
log
@2002-12-08  Andrew Cagney  <ac131313@@redhat.com>

	* config/rs6000/tm-rs6000.h (init_frame_pc_noop): Add declaration.
	* dwarf2cfi.c (cfi_init_frame_pc): Cast the PC to a pointer.
@
text
@d1787 1
a1787 1
      UNWIND_CONTEXT (fi)->ra = fi->pc + 1;
@


1.22
log
@2002-12-08  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (INIT_FRAME_PC_FIRST, INIT_FRAME_PC_DEFAULT): Convert
	to pure functions.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Explictly assign prev's pc with value
	returned by INIT_FRAME_PC_FIRST and INIT_EXTRA_FRAME_INFO.

	* arch-utils.h (init_frame_pc_default, init_frame_pc_noop): Change
	declaration to a function returning a CORE_ADDR.
	* x86-64-tdep.h (x86_64_init_frame_pc): Ditto.
	* arch-utils.c (init_frame_pc_noop): Return the PC value.
	(init_frame_pc_default): Ditto.
	* x86-64-linux-tdep.c (x86_64_init_frame_pc): Ditto.
	* s390-tdep.c (s390_init_frame_pc_first): Ditto.
	* mips-tdep.c (mips_init_frame_pc_first): Ditto.
	* dwarf2cfi.h (cfi_init_frame_pc): Ditto.
	* dwarf2cfi.c (cfi_init_frame_pc): Ditto.
	* alpha-tdep.c (alpha_init_frame_pc_first): Ditto.

	* i386-interix-tdep.c (i386_interix_init_abi): Set init_frame_pc
	to init_frame_pc_noop.
	(i386_interix_init_frame_pc): Delete function.
	* z8k-tdep.c (init_frame_pc): Delete function.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC): Define as init_frame_pc_noop.
	(INIT_FRAME_PC_FIRST): Ditto.
	* config/mn10200/tm-mn10200.h (INIT_FRAME_PC): Ditto.
	(INIT_FRAME_PC_FIRST): Ditto.
	* config/sparc/tm-sparc.h (INIT_FRAME_PC): Ditto.
	* config/rs6000/tm-rs6000.h (INIT_FRAME_PC): Redefine as
	init_frame_pc_noop.
	(INIT_FRAME_PC_FIRST): Convert to an expression.
	* config/sparc/tm-sparc.h (INIT_FRAME_PC_FIRST): Ditto.
@
text
@d1757 1
a1757 1
      get_reg (&pc, UNWIND_CONTEXT (get_next_frame (fi)), PC_REGNUM);
@


1.21
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@d1749 1
a1749 1
void
d1752 8
a1759 2
  if (fi->next)
    get_reg ((char *) &(fi->pc), UNWIND_CONTEXT (fi->next), PC_REGNUM);
d1761 1
a1761 1
    fi->pc = read_pc ();
@


1.20
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@d1710 2
a1711 2
      write_register_bytes (REGISTER_BYTE (regnum), regbuf,
			    REGISTER_RAW_SIZE (regnum));
@


1.19
log
@* dwarf2cfi.c: Fix some formatting problems.
(context_cpy, read_encoded_pointer): Clarify comments.
@
text
@d827 1
a827 1
      read_register_gen (regnum, reg);
d834 1
a834 1
      read_register_gen (context->reg[regnum].loc.reg, reg);
d1691 1
a1691 1
      write_register_gen (fs->cfa_reg, (char *) &val);
d1822 1
a1822 1
      read_register_gen (regnum, raw_buffer);
d1834 1
a1834 1
	  read_register_gen (regnum, raw_buffer);
d1852 2
a1853 2
	  read_register_gen (UNWIND_CONTEXT (frame)->reg[regnum].loc.reg,
			     raw_buffer);
@


1.18
log
@Reindented.
@
text
@d183 13
a195 13
static unsigned int read_1u (bfd * abfd, char **p);
static int read_1s (bfd * abfd, char **p);
static unsigned int read_2u (bfd * abfd, char **p);
static int read_2s (bfd * abfd, char **p);
static unsigned int read_4u (bfd * abfd, char **p);
static int read_4s (bfd * abfd, char **p);
static ULONGEST read_8u (bfd * abfd, char **p);
static LONGEST read_8s (bfd * abfd, char **p);

static ULONGEST read_uleb128 (bfd * abfd, char **p);
static LONGEST read_sleb128 (bfd * abfd, char **p);
static CORE_ADDR read_pointer (bfd * abfd, char **p);
static CORE_ADDR read_encoded_pointer (bfd * abfd, char **p,
d199 2
a200 2
static LONGEST read_initial_length (bfd * abfd, char *buf, int *bytes_read);
static ULONGEST read_length (bfd * abfd, char *buf, int *bytes_read,
d307 3
a309 11
  /* Structure dst contains a pointer to an array of
   * registers of a given frame as well as src does. This
   * array was already allocated before dst was passed to
   * context_cpy but the pointer to it was overriden by
   * '*dst = *src' and the array was lost. This led to the
   * situation, that we've had a copy of src placed in dst,
   * but both of them pointed to the same regs array and
   * thus we've sometimes blindly rewritten it.  Now we save
   * the pointer before copying src to dst, return it back
   * after that and copy the registers into their new place
   * finally.   ---   mludvig@@suse.cz  */
a312 1

d317 1
a317 1
read_1u (bfd * abfd, char **p)
d327 1
a327 1
read_1s (bfd * abfd, char **p)
d337 1
a337 1
read_2u (bfd * abfd, char **p)
d347 1
a347 1
read_2s (bfd * abfd, char **p)
d357 1
a357 1
read_4u (bfd * abfd, char **p)
d367 1
a367 1
read_4s (bfd * abfd, char **p)
d377 1
a377 1
read_8u (bfd * abfd, char **p)
d387 1
a387 1
read_8s (bfd * abfd, char **p)
d397 1
a397 1
read_uleb128 (bfd * abfd, char **p)
d421 1
a421 1
read_sleb128 (bfd * abfd, char **p)
d451 1
a451 1
read_pointer (bfd * abfd, char **p)
d464 3
a466 3
/* This functions only reads appropriate amount of data from *p 
 * and returns the resulting value. Calling function must handle
 * different encoding possibilities itself!  */
d468 1
a468 1
read_encoded_pointer (bfd * abfd, char **p, unsigned char encoding)
d513 4
a516 4
/* Variable 'encoding' carries 3 different flags:
 * - encoding & 0x0f : size of the address (handled in read_encoded_pointer())
 * - encoding & 0x70 : type (absolute, relative, ...)
 * - encoding & 0x80 : indirect flag (DW_EH_PE_indirect == 0x80).  */
d541 1
a541 1
read_initial_length (bfd * abfd, char *buf, int *bytes_read)
d561 1
a561 1
read_length (bfd * abfd, char *buf, int *bytes_read, int dwarf64)
@


1.17
log
@2002-10-24  Michal Ludvig  <mludvig@@suse.cz>

	* dwarf2cfi.c (struct context)
	(struct context_reg): Moved to dwarf2cfi.h
	(context_alloc, frame_state_alloc, context_cpy):
	Made extern instead of static, removed prototypes.
	* dwarf2cfi.h (struct context)
	(struct context_reg): New, moved from dwarf2cfi.c
	(context_alloc, frame_state_alloc, context_cpy):
	New prototypes.
	* x86-64-linux-tdep.c (x86_64_linux_sigtramp_saved_pc):
	Changed from static to extern.
	(LINUX_SIGINFO_SIZE, LINUX_SIGCONTEXT_PC_OFFSET)
	(LINUX_SIGCONTEXT_FP_OFFSET)
	(LINUX_UCONTEXT_SIGCONTEXT_OFFSET): Adjusted.
	(x86_64_linux_in_sigtramp, x86_64_linux_frame_chain)
	(x86_64_init_frame_pc, x86_64_init_extra_frame_info): New.
	* x86-64-tdep.c (x86_64_gdbarch_init): Several
	set_gdbarch_*() calls now use x86-64 specific functions
	instead of DWARF2 CFI ones.
	* x86-64-tdep.h (x86_64_linux_in_sigtramp)
	(x86_64_linux_frame_chain, x86_64_init_frame_pc)
	(x86_64_init_extra_frame_info): New prototypes.
@
text
@d817 1
a817 1
  
d823 1
a823 1
  
d1097 1
a1097 1
		if (len != 1 && len != 2 && len != 4 && len !=8)
@


1.16
log
@2002-07-17  Michal Ludvig  <michal@@suse.cz>

	* dwarf2cfi.c (execute_stack_op): Complain on unknown DW_OP_ value.
	(update_context): Initialise cfa variable.
@
text
@a92 31
struct context_reg
{
  union
  {
    unsigned int reg;
    long offset;
    CORE_ADDR addr;
  }
  loc;
  enum
  {
    REG_CTX_UNSAVED,
    REG_CTX_SAVED_OFFSET,
    REG_CTX_SAVED_REG,
    REG_CTX_SAVED_ADDR,
    REG_CTX_VALUE,
  }
  how;
};

/* This is the register and unwind state for a particular frame.  */
struct context
{
  struct context_reg *reg;

  CORE_ADDR cfa;
  CORE_ADDR ra;
  void *lsda;
  int args_size;
};

a179 2
static struct context *context_alloc ();
static struct frame_state *frame_state_alloc ();
a181 1
static void context_cpy (struct context *dst, struct context *src);
d255 1
a255 1
static struct context *
d272 1
a272 1
static struct frame_state *
d301 1
a301 1
static void
@


1.16.6.1
log
@2003-02-03  Michal Ludvig  <mludvig@@suse.cz>

	* dwarf2cfi.c (pointer_encoding): Added new parameter.
	* dwarf2cfi.c, dwarf2read.c: Changed all warnings and
	error messages to contain BFD filename.
@
text
@d231 1
a231 1
static enum ptr_encoding pointer_encoding (unsigned char encoding, struct objfile *objfile);
d503 1
a503 2
      error ("dwarf cfi error: unsupported target address length [in module %s]", 
		      bfd_get_filename (abfd));
d550 1
a550 2
		      "read_encoded_pointer: unknown pointer encoding [in module %s]",
		      bfd_get_filename (abfd));
d561 1
a561 1
pointer_encoding (unsigned char encoding, struct objfile *objfile)
d566 1
a566 2
    warning ("CFI: Unsupported pointer encoding: DW_EH_PE_indirect [in module %s]",
		    objfile->name);
d578 1
a578 2
      internal_error (__FILE__, __LINE__, "CFI: unknown pointer encoding [in module %s]", 
		      objfile->name);
d655 2
a656 3
	    if (pointer_encoding (fs->addr_encoding, objfile) != PE_absptr)
	      warning ("CFI: DW_CFA_set_loc uses relative addressing [in module %s]", 
			      objfile->name);
d805 1
a805 2
	    error ("dwarf cfi error: unknown cfa instruction %d [in module %s]", insn, 
			    objfile->name);
d851 1
a851 1

d857 1
a857 1

d1068 1
a1068 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1074 1
a1074 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1080 1
a1080 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1086 1
a1086 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1095 1
a1095 1
	      internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1113 1
a1113 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1123 1
a1123 1
				  "execute_stack_op error [in module %s]", objfile->name);
d1131 1
a1131 1
		if (len != 1 && len != 2 && len != 4 && len != 8)
d1133 1
a1133 1
				  "execute_stack_op error [in module %s]", objfile->name);
d1173 1
a1173 1
	      internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1231 1
a1231 1
		error ("execute_stack_op: Unknown DW_OP_ value [in module %s]", objfile->name);
d1244 1
a1244 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1254 1
a1254 1
	  internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1259 1
a1259 1
	internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1267 1
a1267 1
    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1352 1
a1352 2
	    internal_error (__FILE__, __LINE__, "bad switch 0x%02X", 
			    orig_context->reg[fs->regs.reg[i].loc.reg].how);
d1369 1
a1369 2
	internal_error (__FILE__, __LINE__, "bad switch 0x%02X",
			fs->regs.reg[i].how);
d1579 1
a1579 2
		    error ("CFI: can't find CIE pointer [in module %s]", 
				    bfd_get_filename (abfd));
d1585 1
a1585 1
	      switch (pointer_encoding (cie->addr_encoding, objfile))
d1595 1
a1595 2
		  warning ("CFI: Unsupported pointer encoding [in module %s]",
				  bfd_get_filename (abfd));
d1921 1
a1921 2
			  "cfi_get_saved_register: unknown register rule 0x%02X",
			  UNWIND_CONTEXT (frame)->reg[regnum].how);
@


1.16.10.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d93 31
d211 2
d215 1
d289 1
a289 1
struct context *
d306 1
a306 1
struct frame_state *
d335 1
a335 1
void
d851 1
a851 1

d857 1
a857 1

d1131 1
a1131 1
		if (len != 1 && len != 2 && len != 4 && len != 8)
@


1.16.10.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.16.8.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d93 31
d211 2
d215 1
d289 1
a289 1
struct context *
d306 1
a306 1
struct frame_state *
d335 1
a335 1
void
d851 1
a851 1

d857 1
a857 1

d1131 1
a1131 1
		if (len != 1 && len != 2 && len != 4 && len != 8)
@


1.16.8.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d183 13
a195 13
static unsigned int read_1u (bfd *abfd, char **p);
static int read_1s (bfd *abfd, char **p);
static unsigned int read_2u (bfd *abfd, char **p);
static int read_2s (bfd *abfd, char **p);
static unsigned int read_4u (bfd *abfd, char **p);
static int read_4s (bfd *abfd, char **p);
static ULONGEST read_8u (bfd *abfd, char **p);
static LONGEST read_8s (bfd *abfd, char **p);

static ULONGEST read_uleb128 (bfd *abfd, char **p);
static LONGEST read_sleb128 (bfd *abfd, char **p);
static CORE_ADDR read_pointer (bfd *abfd, char **p);
static CORE_ADDR read_encoded_pointer (bfd *abfd, char **p,
d199 2
a200 2
static LONGEST read_initial_length (bfd *abfd, char *buf, int *bytes_read);
static ULONGEST read_length (bfd *abfd, char *buf, int *bytes_read,
d307 11
a317 3
  /* Since `struct context' contains a pointer to an array with
     register values, make sure we end up with a copy of that array,
     and not with a copy of the pointer to that array.  */
d321 1
d326 1
a326 1
read_1u (bfd *abfd, char **p)
d336 1
a336 1
read_1s (bfd *abfd, char **p)
d346 1
a346 1
read_2u (bfd *abfd, char **p)
d356 1
a356 1
read_2s (bfd *abfd, char **p)
d366 1
a366 1
read_4u (bfd *abfd, char **p)
d376 1
a376 1
read_4s (bfd *abfd, char **p)
d386 1
a386 1
read_8u (bfd *abfd, char **p)
d396 1
a396 1
read_8s (bfd *abfd, char **p)
d406 1
a406 1
read_uleb128 (bfd *abfd, char **p)
d430 1
a430 1
read_sleb128 (bfd *abfd, char **p)
d460 1
a460 1
read_pointer (bfd *abfd, char **p)
d473 3
a475 3
/* Read the appropriate amount of data from *P and return the
   resulting value based on ENCODING, which the calling function must
   provide.  */
d477 1
a477 1
read_encoded_pointer (bfd *abfd, char **p, unsigned char encoding)
d522 4
a525 4
/* The variable 'encoding' carries three different flags:
   - encoding & 0x0f : size of the address (handled in read_encoded_pointer())
   - encoding & 0x70 : type (absolute, relative, ...)
   - encoding & 0x80 : indirect flag (DW_EH_PE_indirect == 0x80).  */
d550 1
a550 1
read_initial_length (bfd *abfd, char *buf, int *bytes_read)
d570 1
a570 1
read_length (bfd *abfd, char *buf, int *bytes_read, int dwarf64)
d836 1
a836 1
      deprecated_read_register_gen (regnum, reg);
d843 1
a843 1
      deprecated_read_register_gen (context->reg[regnum].loc.reg, reg);
d1700 1
a1700 1
      deprecated_write_register_gen (fs->cfa_reg, (char *) &val);
d1719 2
a1720 2
      deprecated_write_register_bytes (REGISTER_BYTE (regnum), regbuf,
				       REGISTER_RAW_SIZE (regnum));
d1831 1
a1831 1
      deprecated_read_register_gen (regnum, raw_buffer);
d1843 1
a1843 1
	  deprecated_read_register_gen (regnum, raw_buffer);
d1861 2
a1862 2
	  deprecated_read_register_gen (UNWIND_CONTEXT (frame)->reg[regnum].loc.reg,
					raw_buffer);
@


1.16.8.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1749 1
a1749 1
CORE_ADDR
d1752 2
a1753 8
  if (get_next_frame (fi))
    {
      CORE_ADDR pc;
      /* FIXME: cagney/2002-12-04: This is straight wrong.  It's
         assuming that the PC is CORE_ADDR (a host quantity) in size.  */
      get_reg ((void *)&pc, UNWIND_CONTEXT (get_next_frame (fi)), PC_REGNUM);
      return pc;
    }
d1755 1
a1755 1
    return read_pc ();
@


1.16.8.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 3

   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.

d159 1
a159 1
#define UNWIND_CONTEXT(fi) ((struct context *) (deprecated_get_frame_context (fi)))
a170 3
extern asection *dwarf_frame_section;
extern asection *dwarf_eh_frame_section;

d174 1
a174 1
				  unsigned int size, asection* sectp);
d197 1
a197 1
static enum ptr_encoding pointer_encoding (unsigned char encoding, struct objfile *objfile);
d460 1
a460 2
      error ("dwarf cfi error: unsupported target address length [in module %s]", 
		      bfd_get_filename (abfd));
d507 1
a507 2
		      "read_encoded_pointer: unknown pointer encoding [in module %s]",
		      bfd_get_filename (abfd));
d518 1
a518 1
pointer_encoding (unsigned char encoding, struct objfile *objfile)
d523 1
a523 2
    warning ("CFI: Unsupported pointer encoding: DW_EH_PE_indirect [in module %s]",
		    objfile->name);
d535 1
a535 2
      internal_error (__FILE__, __LINE__, "CFI: unknown pointer encoding [in module %s]", 
		      objfile->name);
d612 2
a613 3
	    if (pointer_encoding (fs->addr_encoding, objfile) != PE_absptr)
	      warning ("CFI: DW_CFA_set_loc uses relative addressing [in module %s]", 
			      objfile->name);
d762 1
a762 2
	    error ("dwarf cfi error: unknown cfa instruction %d [in module %s]", insn, 
			    objfile->name);
d1025 1
a1025 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1031 1
a1031 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1037 1
a1037 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1043 1
a1043 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1052 1
a1052 1
	      internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1070 1
a1070 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1080 1
a1080 1
				  "execute_stack_op error [in module %s]", objfile->name);
d1090 1
a1090 1
				  "execute_stack_op error [in module %s]", objfile->name);
d1130 1
a1130 1
	      internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1188 1
a1188 1
		error ("execute_stack_op: Unknown DW_OP_ value [in module %s]", objfile->name);
d1201 1
a1201 1
	    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1211 1
a1211 1
	  internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1216 1
a1216 1
	internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1224 1
a1224 1
    internal_error (__FILE__, __LINE__, "execute_stack_op error [in module %s]", objfile->name);
d1309 1
a1309 2
	    internal_error (__FILE__, __LINE__, "bad switch 0x%02X", 
			    orig_context->reg[fs->regs.reg[i].loc.reg].how);
d1326 1
a1326 2
	internal_error (__FILE__, __LINE__, "bad switch 0x%02X",
			fs->regs.reg[i].how);
d1369 1
a1369 2
		  unsigned int frame_size, asection *frame_section,
		  int eh_frame)
d1384 1
a1384 2
  frame_buffer = dwarf2_read_section (objfile, frame_offset, frame_size,
				      frame_section);
d1536 1
a1536 2
		    error ("CFI: can't find CIE pointer [in module %s]", 
				    bfd_get_filename (abfd));
d1542 1
a1542 1
	      switch (pointer_encoding (cie->addr_encoding, objfile))
d1552 1
a1552 2
		  warning ("CFI: Unsupported pointer encoding [in module %s]",
				  bfd_get_filename (abfd));
d1637 1
a1637 2
			dwarf_frame_size, dwarf_frame_section,
			0 /* = debug_frame */ );
a1642 1
		      dwarf_eh_frame_section,
d1773 1
a1773 1
  deprecated_set_frame_context (fi, frame_obstack_zalloc (sizeof (struct context)));
d1775 1
a1775 1
    frame_obstack_zalloc (sizeof (struct context_reg) * NUM_REGS);
d1779 1
a1779 1
  if (get_next_frame (fi))
d1781 1
a1781 1
      context_cpy (UNWIND_CONTEXT (fi), UNWIND_CONTEXT (get_next_frame (fi)));
d1787 1
a1787 1
      UNWIND_CONTEXT (fi)->ra = get_frame_pc (fi) + 1;
d1826 1
a1826 1
  if (!get_next_frame (frame))
d1836 1
a1836 1
      frame = get_next_frame (frame);
d1884 1
a1884 2
			  "cfi_get_saved_register: unknown register rule 0x%02X",
			  UNWIND_CONTEXT (frame)->reg[regnum].how);
@


1.16.8.5
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d175 1
a177 1

d179 1
a179 1
				  unsigned int size, asection *sectp);
d202 1
a202 2
static enum ptr_encoding pointer_encoding (unsigned char encoding,
					   struct objfile *objfile);
d465 2
a466 3
      error
	("dwarf cfi error: unsupported target address length [in module %s]",
	 bfd_get_filename (abfd));
d530 2
a531 3
    warning
      ("CFI: Unsupported pointer encoding: DW_EH_PE_indirect [in module %s]",
       objfile->name);
d543 1
a543 2
      internal_error (__FILE__, __LINE__,
		      "CFI: unknown pointer encoding [in module %s]",
d622 2
a623 3
	      warning
		("CFI: DW_CFA_set_loc uses relative addressing [in module %s]",
		 objfile->name);
d772 2
a773 3
	    error
	      ("dwarf cfi error: unknown cfa instruction %d [in module %s]",
	       insn, objfile->name);
d1036 1
a1036 3
	    internal_error (__FILE__, __LINE__,
			    "execute_stack_op error [in module %s]",
			    objfile->name);
d1042 1
a1042 3
	    internal_error (__FILE__, __LINE__,
			    "execute_stack_op error [in module %s]",
			    objfile->name);
d1048 1
a1048 3
	    internal_error (__FILE__, __LINE__,
			    "execute_stack_op error [in module %s]",
			    objfile->name);
d1054 1
a1054 3
	    internal_error (__FILE__, __LINE__,
			    "execute_stack_op error [in module %s]",
			    objfile->name);
d1063 1
a1063 3
	      internal_error (__FILE__, __LINE__,
			      "execute_stack_op error [in module %s]",
			      objfile->name);
d1081 1
a1081 3
	    internal_error (__FILE__, __LINE__,
			    "execute_stack_op error [in module %s]",
			    objfile->name);
d1091 1
a1091 2
				  "execute_stack_op error [in module %s]",
				  objfile->name);
d1101 1
a1101 2
				  "execute_stack_op error [in module %s]",
				  objfile->name);
d1141 1
a1141 3
	      internal_error (__FILE__, __LINE__,
			      "execute_stack_op error [in module %s]",
			      objfile->name);
d1199 1
a1199 3
		error
		  ("execute_stack_op: Unknown DW_OP_ value [in module %s]",
		   objfile->name);
d1212 1
a1212 3
	    internal_error (__FILE__, __LINE__,
			    "execute_stack_op error [in module %s]",
			    objfile->name);
d1222 1
a1222 3
	  internal_error (__FILE__, __LINE__,
			  "execute_stack_op error [in module %s]",
			  objfile->name);
d1227 1
a1227 3
	internal_error (__FILE__, __LINE__,
			"execute_stack_op error [in module %s]",
			objfile->name);
d1235 1
a1235 2
    internal_error (__FILE__, __LINE__,
		    "execute_stack_op error [in module %s]", objfile->name);
d1320 1
a1320 1
	    internal_error (__FILE__, __LINE__, "bad switch 0x%02X",
d1551 2
a1552 2
		    error ("CFI: can't find CIE pointer [in module %s]",
			   bfd_get_filename (abfd));
d1569 1
a1569 1
			   bfd_get_filename (abfd));
d1776 1
a1776 1
      get_reg ((void *) &pc, UNWIND_CONTEXT (get_next_frame (fi)), PC_REGNUM);
d1792 1
a1792 3
  deprecated_set_frame_context (fi,
				frame_obstack_zalloc (sizeof
						      (struct context)));
d1877 2
a1878 2
	  deprecated_read_register_gen (UNWIND_CONTEXT (frame)->reg[regnum].
					loc.reg, raw_buffer);
@


1.16.8.6
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d348 1
a348 1
  (*p) += 2;
@


1.16.8.7
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1754 1
a1754 1
  char regbuf[MAX_REGISTER_SIZE];
@


1.16.8.8
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@@


1.15
log
@* dwarf2cfi.c: Include "gdb_assert.h".
(frame_state_for): Use gdb_assert to check that fde->cie_ptr is
non-NULL.
(update_context): Do not use __func__.  Add missing ``break''.
(update_context): Do not use __func__.
@
text
@d1230 2
a1231 1
	      default:		/* This label is here just to avoid warning.  */
d1275 1
a1275 1
  CORE_ADDR cfa;
@


1.14
log
@Fix some K&R isms.
@
text
@d33 1
d848 1
a848 3
  if (fde->cie_ptr)
    {
      cie = fde->cie_ptr;
d850 12
a861 14
      fs->code_align = cie->code_align;
      fs->data_align = cie->data_align;
      fs->retaddr_column = cie->ra;
      fs->addr_encoding = cie->addr_encoding;
      fs->objfile = cie->objfile;

      execute_cfa_program (cie->objfile, cie->data,
			   cie->data + cie->data_length, context, fs);
      execute_cfa_program (cie->objfile, fde->data,
			   fde->data + fde->data_length, context, fs);
    }
  else
    internal_error (__FILE__, __LINE__,
		    "%s(): Internal error: fde->cie_ptr==NULL !", __func__);
d1349 1
d1351 1
a1351 2
	    internal_error (__FILE__, __LINE__,
			    "%s: unknown register rule", __func__);
d1368 1
a1368 2
	internal_error (__FILE__, __LINE__,
			"%s: unknown register rule", __func__);
@


1.13
log
@* dwarf2cfi.c: Include "gcore.h".
(execute_stack_op): Fix implementation of the
DW_OP_deref and DW_OP_deref_size operators by letting do their
lookup in the target.
@
text
@d276 1
a276 1
fde_chunks_need_space ()
d289 1
a289 1
context_alloc ()
d306 1
a306 1
frame_state_alloc ()
d322 1
a322 1
unwind_tmp_obstack_init ()
d328 1
a328 1
unwind_tmp_obstack_free ()
d1694 1
a1694 1
cfi_read_fp ()
@


1.12
log
@* dwarf2cfi.c (cfi_pop_frame): Use alloca() for regbuf.
Don't call get_current_frame().
@
text
@d24 1
d1123 5
a1127 2
		char *ptr = (char *) result;
		result = read_pointer (objfile->obfd, &ptr);
d1133 5
a1137 19
		char *ptr = (char *) result;
		switch (*op_ptr++)
		  {
		  case 1:
		    result = read_1u (objfile->obfd, &ptr);
		    break;
		  case 2:
		    result = read_2u (objfile->obfd, &ptr);
		    break;
		  case 4:
		    result = read_4u (objfile->obfd, &ptr);
		    break;
		  case 8:
		    result = read_8u (objfile->obfd, &ptr);
		    break;
		  default:
		    internal_error (__FILE__, __LINE__,
				    "execute_stack_op error");
		  }
@


1.11
log
@	* dwarf2cfi.c: Reindented.
@
text
@d1760 1
a1760 1
  char regbuf[MAX_REGISTER_RAW_SIZE];
a1761 2

  fi = get_current_frame ();
@


1.10
log
@2002-06-21  Michal Ludvig  <mludvig@@suse.cz>

	* dwarf2cfi.c (read_encoded_pointer): Don't handle pointer
	encoding anymore.
	(pointer_encoding, enum ptr_encoding): New.
	(execute_cfa_program): Take care about pointer encoding.
	(dwarf2_build_frame_info): Only call parse_frame_info for
	.debug_frame and .eh_frame.
	(parse_frame_info): New, derived from former dwarf2_build_frame_info.
	fixed augmentation handling, added relative addressing,
	ignore duplicate FDEs. Added comments.
@
text
@d179 2
a180 1
enum ptr_encoding { 
d565 1
a565 1
  
d576 1
a576 2
      internal_error (__FILE__, __LINE__,
    		  "CFI: unknown pointer encoding");
d652 1
a652 1
	    
d654 2
a655 2
		warning ("CFI: DW_CFA_set_loc uses relative addressing");
	    
d1457 1
a1457 1
	  int bytes_read, dwarf64, flag_pcrel;
d1599 1
a1599 1
	      {
d1601 1
a1601 1
			break;
d1603 4
a1606 4
			/* start-frame_buffer gives offset from 
		           the beginning of actual section.  */
			init_loc += curr_section_vma + start - frame_buffer;
			break;
d1608 2
a1609 2
			warning ("CFI: Unsupported pointer encoding\n");
	      }
d1628 17
a1644 17
	        for (i = 0; eh_frame == 2 && i < fde_chunks.elems; i++)
		{
		  /* We assume that FDEs in .debug_frame and .eh_frame 
		     have the same order (if they are present, of course).
		     If we find a duplicate entry for one FDE and save
		     it's index to last_dup_fde it's very likely, that 
		     we'll find an entry for the following FDE right after 
		     the previous one. Thus in many cases we'll run this 
		     loop only once.  */
		  last_dup_fde = (last_dup_fde + i) % fde_chunks.elems;
		  if (fde_chunks.array[last_dup_fde]->initial_location
		      == init_loc)
		    {
		      dup = 1;
		      break;
		    }
		}
d1691 5
a1695 5
  {
    parse_frame_info (objfile, dwarf_frame_offset,
		      dwarf_frame_size, 0 /* = debug_frame */);
    after_debug_frame = 1;
  }
d1698 2
a1699 2
    parse_frame_info (objfile, dwarf_eh_frame_offset, dwarf_eh_frame_size, 
		      1 /* = eh_frame */ + after_debug_frame);
d1864 1
a1864 1
			CORE_ADDR * addrp,
@


1.9
log
@* dwarf2cfi.c: Reindented (using 'indent dwarf2cfi.c')
@
text
@d37 1
a37 1
  /* Offset of this unit in dwarf_frame_buffer.  */
d179 8
a198 2

static char *dwarf_frame_buffer;
d228 1
d504 3
d550 11
a560 15
  if (ret != 0)
    switch (encoding & 0xf0)
      {
      case DW_EH_PE_absptr:
	break;
      case DW_EH_PE_pcrel:
	ret += (CORE_ADDR) * p;
	break;
      case DW_EH_PE_textrel:
      case DW_EH_PE_datarel:
      case DW_EH_PE_funcrel:
      default:
	internal_error (__FILE__, __LINE__,
			"read_encoded_pointer: unknown pointer encoding");
      }
d562 16
d652 4
d1409 17
a1425 3
    in .debug_frame section.  */
void
dwarf2_build_frame_info (struct objfile *objfile)
d1428 1
d1431 6
a1436 1
  int from_eh = 0;
d1440 1
a1440 16
  dwarf_frame_buffer = 0;

  if (dwarf_frame_offset)
    {
      dwarf_frame_buffer = dwarf2_read_section (objfile,
						dwarf_frame_offset,
						dwarf_frame_size);

      start = dwarf_frame_buffer;
      end = dwarf_frame_buffer + dwarf_frame_size;
    }
  else if (dwarf_eh_frame_offset)
    {
      dwarf_frame_buffer = dwarf2_read_section (objfile,
						dwarf_eh_frame_offset,
						dwarf_eh_frame_size);
d1442 2
a1443 2
      start = dwarf_frame_buffer;
      end = dwarf_frame_buffer + dwarf_eh_frame_size;
d1445 4
a1448 2
      from_eh = 1;
    }
d1456 2
a1457 3
	  ULONGEST unit_offset = start - dwarf_frame_buffer;
	  int bytes_read;
	  int dwarf64;
d1465 6
d1474 1
a1474 1
	  if ((from_eh && cie_id == 0) || is_cie (cie_id, dwarf64))
d1490 1
a1490 3
	      while (*start)
		start++;
	      start++;		/* skip past NUL */
d1496 12
d1510 3
a1512 2
		  int xtra = read_uleb128 (abfd, &start);
		  start += xtra;
d1516 3
d1523 2
a1524 2
		      start += sizeof (void *);
		      aug += 2;
d1527 2
d1530 8
a1537 2
		      cie->addr_encoding = *start++;
		      aug += 1;
d1539 1
a1539 1
		  else if (aug[0] == 'P')
d1541 5
a1545 4
		      CORE_ADDR ptr;
		      ptr = read_encoded_pointer (abfd, &start,
						  cie->addr_encoding);
		      aug += 1;
d1548 5
a1552 1
		    warning ("%s(): unknown augmentation", __func__);
d1555 1
a1555 2
	      cie->data = start;
	      cie->data_length = block_end - start;
d1561 27
d1589 5
a1593 2
	      fde_chunks_need_space ();
	      fde = fde_unit_alloc ();
d1595 2
a1596 1
	      fde_chunks.array[fde_chunks.elems++] = fde;
d1598 12
a1609 4
	      fde->initial_location = read_pointer (abfd, &start)
		+ ANOFFSET (objfile->section_offsets,
			    SECT_OFF_TEXT (objfile));
	      fde->address_range = read_pointer (abfd, &start);
d1611 18
a1628 2
	      cie = cie_chunks;
	      while (cie)
d1630 10
a1639 1
		  if (cie->objfile == objfile)
d1641 2
a1642 6
		      if (from_eh
			  && (cie->offset ==
			      (unit_offset + bytes_read - cie_id)))
			break;
		      if (!from_eh && (cie->offset == cie_id))
			break;
d1644 8
d1653 6
a1658 2
		  cie = cie->next;
		}
d1660 1
a1660 3
	      if (!cie)
		error ("%s(): can't find CIE pointer", __func__);
	      fde->cie_ptr = cie;
d1662 4
a1665 2
	      if (cie->augmentation[0] == 'z')
		read_uleb128 (abfd, &start);
d1667 3
a1669 2
	      fde->data = start;
	      fde->data_length = block_end - start;
d1677 24
a1700 1

@


1.8
log
@2002-06-11  Michal Ludvig  <mludvig@@suse.cz>

	* dwarf2cfi.c (unwind_tmp_obstack_init): New.
	(unwind_tmp_obstack_free, parse_frame_info)
	(update_context, cfi_read_fp, cfi_write_fp)
	(cfi_frame_chain, cfi_init_extra_frame_info)
	(cfi_virtual_frame_pointer): Use the above function.
@
text
@d208 13
a220 13
static unsigned int read_1u (bfd *abfd, char **p);
static int read_1s (bfd *abfd, char **p);
static unsigned int read_2u (bfd *abfd, char **p);
static int read_2s (bfd *abfd, char **p);
static unsigned int read_4u (bfd *abfd, char **p);
static int read_4s (bfd *abfd, char **p);
static ULONGEST read_8u (bfd *abfd, char **p);
static LONGEST read_8s (bfd *abfd, char **p);

static ULONGEST read_uleb128 (bfd *abfd, char **p);
static LONGEST read_sleb128 (bfd *abfd, char **p);
static CORE_ADDR read_pointer (bfd *abfd, char **p);
static CORE_ADDR read_encoded_pointer (bfd *abfd, char **p,
d223 2
a224 2
static LONGEST read_initial_length (bfd *abfd, char *buf, int *bytes_read);
static ULONGEST read_length (bfd *abfd, char *buf, int *bytes_read,
d239 2
a240 1
				   struct context *context, CORE_ADDR initial);
d243 1
a244 1

d306 2
a307 2
  fs->regs.reg = (struct frame_state_reg *)  obstack_alloc (&unwind_tmp_obstack,
							    regs_size);
d345 1
a345 1
  
d350 1
a350 1
read_1u (bfd *abfd, char **p)
d354 2
a355 2
  ret= bfd_get_8 (abfd, (bfd_byte *) *p);
  (*p) ++;
d360 1
a360 1
read_1s (bfd *abfd, char **p)
d364 2
a365 2
  ret= bfd_get_signed_8 (abfd, (bfd_byte *) *p);
  (*p) ++;
d370 1
a370 1
read_2u (bfd *abfd, char **p)
d374 2
a375 2
  ret= bfd_get_16 (abfd, (bfd_byte *) *p);
  (*p) ++;
d380 1
a380 1
read_2s (bfd *abfd, char **p)
d384 1
a384 1
  ret= bfd_get_signed_16 (abfd, (bfd_byte *) *p);
d390 1
a390 1
read_4u (bfd *abfd, char **p)
d394 1
a394 1
  ret= bfd_get_32 (abfd, (bfd_byte *) *p);
d400 1
a400 1
read_4s (bfd *abfd, char **p)
d404 1
a404 1
  ret= bfd_get_signed_32 (abfd, (bfd_byte *) *p);
d410 1
a410 1
read_8u (bfd *abfd, char **p)
d414 1
a414 1
  ret = bfd_get_64 (abfd, (bfd_byte *) *p);
d420 1
a420 1
read_8s (bfd *abfd, char **p)
d424 1
a424 1
  ret = bfd_get_signed_64 (abfd, (bfd_byte *) *p);
d430 1
a430 1
read_uleb128 (bfd *abfd, char **p)
d441 2
a442 2
      byte = bfd_get_8 (abfd, (bfd_byte *) *p);
      (*p) ++;
d454 1
a454 1
read_sleb128 (bfd *abfd, char **p)
d467 2
a468 2
      byte = bfd_get_8 (abfd, (bfd_byte *) *p);
      (*p) ++;
d484 1
a484 1
read_pointer (bfd *abfd, char **p)
d498 1
a498 1
read_encoded_pointer (bfd *abfd, char **p, unsigned char encoding)
d546 1
a546 1
	ret += (CORE_ADDR) *p;
d595 2
a596 2
execute_cfa_program ( struct objfile *objfile, char *insn_ptr, char *insn_end,
		      struct context *context, struct frame_state *fs)
d615 1
a615 1
	  offset = (long) uoffset * fs->data_align;
d817 1
a817 1
  
d821 1
a821 1
  {
d823 1
a823 1
      
d834 1
a834 1
  }
d836 2
a837 3
	internal_error (__FILE__, __LINE__,
		"%s(): Internal error: fde->cie_ptr==NULL !", 
		__func__);
d864 1
a864 2
      internal_error (__FILE__, __LINE__,
		      "get_reg: unknown register rule");
d1217 2
a1218 2
	      default:	/* This label is here just to avoid warning.  */
	        break; 
d1279 3
a1281 3
	 to do the same sort of handling as above.  Assume that if the
	 CFA calculation is so complicated as to require a stack program
	 that this will not be a problem.  */
d1502 1
a1502 1
	      
d1504 2
a1505 1
	        + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1509 1
a1509 3
	      while(cie)
	      {
	        if (cie->objfile == objfile)
d1511 11
a1521 4
		  if (from_eh && (cie->offset == (unit_offset + bytes_read - cie_id)))
		      break;
		  if (!from_eh && (cie->offset == cie_id))
		    break;
a1523 3
		cie = cie->next;
	      }
	    
d1529 1
a1529 1
		  read_uleb128 (abfd, &start);
d1561 1
a1561 1
  
d1563 1
a1563 1
  
d1642 1
a1642 1
  
d1663 1
a1663 1
  
d1683 1
a1683 1
  
@


1.7
log
@2002-05-22  Michal Ludvig  <mludvig@@suse.cz>

	* dwarf2cfi.c (execute_stack_op): Change type of 'result'
	from ULONGEST to CORE_ADDR.
@
text
@d204 1
d312 6
d321 1
a321 1
  obstack_init (&unwind_tmp_obstack);
d1265 2
d1269 1
d1393 1
a1393 1
  obstack_init (&unwind_tmp_obstack);
d1548 2
d1559 1
d1561 1
d1573 2
d1622 2
d1660 2
d1681 1
d1788 2
@


1.7.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a203 1
static void unwind_tmp_obstack_init ();
d207 13
a219 13
static unsigned int read_1u (bfd * abfd, char **p);
static int read_1s (bfd * abfd, char **p);
static unsigned int read_2u (bfd * abfd, char **p);
static int read_2s (bfd * abfd, char **p);
static unsigned int read_4u (bfd * abfd, char **p);
static int read_4s (bfd * abfd, char **p);
static ULONGEST read_8u (bfd * abfd, char **p);
static LONGEST read_8s (bfd * abfd, char **p);

static ULONGEST read_uleb128 (bfd * abfd, char **p);
static LONGEST read_sleb128 (bfd * abfd, char **p);
static CORE_ADDR read_pointer (bfd * abfd, char **p);
static CORE_ADDR read_encoded_pointer (bfd * abfd, char **p,
d222 2
a223 2
static LONGEST read_initial_length (bfd * abfd, char *buf, int *bytes_read);
static ULONGEST read_length (bfd * abfd, char *buf, int *bytes_read,
d238 1
a238 2
				   struct context *context,
				   CORE_ADDR initial);
d241 1
a242 1

d304 2
a305 2
  fs->regs.reg =
    (struct frame_state_reg *) obstack_alloc (&unwind_tmp_obstack, regs_size);
a310 6
unwind_tmp_obstack_init ()
{
  obstack_init (&unwind_tmp_obstack);
}

static void
d314 1
a314 1
  unwind_tmp_obstack_init ();
d337 1
a337 1

d342 1
a342 1
read_1u (bfd * abfd, char **p)
d346 2
a347 2
  ret = bfd_get_8 (abfd, (bfd_byte *) * p);
  (*p)++;
d352 1
a352 1
read_1s (bfd * abfd, char **p)
d356 2
a357 2
  ret = bfd_get_signed_8 (abfd, (bfd_byte *) * p);
  (*p)++;
d362 1
a362 1
read_2u (bfd * abfd, char **p)
d366 2
a367 2
  ret = bfd_get_16 (abfd, (bfd_byte *) * p);
  (*p)++;
d372 1
a372 1
read_2s (bfd * abfd, char **p)
d376 1
a376 1
  ret = bfd_get_signed_16 (abfd, (bfd_byte *) * p);
d382 1
a382 1
read_4u (bfd * abfd, char **p)
d386 1
a386 1
  ret = bfd_get_32 (abfd, (bfd_byte *) * p);
d392 1
a392 1
read_4s (bfd * abfd, char **p)
d396 1
a396 1
  ret = bfd_get_signed_32 (abfd, (bfd_byte *) * p);
d402 1
a402 1
read_8u (bfd * abfd, char **p)
d406 1
a406 1
  ret = bfd_get_64 (abfd, (bfd_byte *) * p);
d412 1
a412 1
read_8s (bfd * abfd, char **p)
d416 1
a416 1
  ret = bfd_get_signed_64 (abfd, (bfd_byte *) * p);
d422 1
a422 1
read_uleb128 (bfd * abfd, char **p)
d433 2
a434 2
      byte = bfd_get_8 (abfd, (bfd_byte *) * p);
      (*p)++;
d446 1
a446 1
read_sleb128 (bfd * abfd, char **p)
d459 2
a460 2
      byte = bfd_get_8 (abfd, (bfd_byte *) * p);
      (*p)++;
d476 1
a476 1
read_pointer (bfd * abfd, char **p)
d490 1
a490 1
read_encoded_pointer (bfd * abfd, char **p, unsigned char encoding)
d538 1
a538 1
	ret += (CORE_ADDR) * p;
d587 2
a588 2
execute_cfa_program (struct objfile *objfile, char *insn_ptr, char *insn_end,
		     struct context *context, struct frame_state *fs)
d607 1
a607 1
	  offset = (long) uoffset *fs->data_align;
d809 1
a809 1

d813 1
a813 1
    {
d815 1
a815 1

d826 1
a826 1
    }
d828 3
a830 2
    internal_error (__FILE__, __LINE__,
		    "%s(): Internal error: fde->cie_ptr==NULL !", __func__);
d857 2
a858 1
      internal_error (__FILE__, __LINE__, "get_reg: unknown register rule");
d1211 2
a1212 2
	      default:		/* This label is here just to avoid warning.  */
		break;
a1257 2
  unwind_tmp_obstack_init ();

a1259 1

d1270 3
a1272 3
         to do the same sort of handling as above.  Assume that if the
         CFA calculation is so complicated as to require a stack program
         that this will not be a problem.  */
d1383 1
a1383 1
  unwind_tmp_obstack_init ();
d1493 1
a1493 1

d1495 1
a1495 2
		+ ANOFFSET (objfile->section_offsets,
			    SECT_OFF_TEXT (objfile));
d1499 3
a1501 1
	      while (cie)
d1503 4
a1506 11
		  if (cie->objfile == objfile)
		    {
		      if (from_eh
			  && (cie->offset ==
			      (unit_offset + bytes_read - cie_id)))
			break;
		      if (!from_eh && (cie->offset == cie_id))
			break;
		    }

		  cie = cie->next;
d1509 3
d1517 1
a1517 1
		read_uleb128 (abfd, &start);
a1537 2
  unwind_tmp_obstack_init ();

a1546 1

a1547 1

a1558 2
  unwind_tmp_obstack_init ();

a1605 2
  unwind_tmp_obstack_init ();

d1622 1
a1622 1

a1641 2
  unwind_tmp_obstack_init ();

a1660 1

a1766 2

  unwind_tmp_obstack_init ();
@


1.7.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a23 1
#include "gdbcore.h"
a31 1
#include "gdb_assert.h"
d37 1
a37 1
  /* Offset of this unit in .debug_frame or .eh_frame.  */
a178 9
enum ptr_encoding
{
  PE_absptr = DW_EH_PE_absptr,
  PE_pcrel = DW_EH_PE_pcrel,
  PE_textrel = DW_EH_PE_textrel,
  PE_datarel = DW_EH_PE_datarel,
  PE_funcrel = DW_EH_PE_funcrel
};

d191 2
a221 1
static enum ptr_encoding pointer_encoding (unsigned char encoding);
d267 1
a267 1
fde_chunks_need_space (void)
d280 1
a280 1
context_alloc (void)
d297 1
a297 1
frame_state_alloc (void)
d313 1
a313 1
unwind_tmp_obstack_init (void)
d319 1
a319 1
unwind_tmp_obstack_free (void)
a496 3
/* This functions only reads appropriate amount of data from *p 
 * and returns the resulting value. Calling function must handle
 * different encoding possibilities itself!  */
d540 15
a554 2
  return ret;
}
a555 24
/* Variable 'encoding' carries 3 different flags:
 * - encoding & 0x0f : size of the address (handled in read_encoded_pointer())
 * - encoding & 0x70 : type (absolute, relative, ...)
 * - encoding & 0x80 : indirect flag (DW_EH_PE_indirect == 0x80).  */
enum ptr_encoding
pointer_encoding (unsigned char encoding)
{
  int ret;

  if (encoding & DW_EH_PE_indirect)
    warning ("CFI: Unsupported pointer encoding: DW_EH_PE_indirect");

  switch (encoding & 0x70)
    {
    case DW_EH_PE_absptr:
    case DW_EH_PE_pcrel:
    case DW_EH_PE_textrel:
    case DW_EH_PE_datarel:
    case DW_EH_PE_funcrel:
      ret = encoding & 0x70;
      break;
    default:
      internal_error (__FILE__, __LINE__, "CFI: unknown pointer encoding");
    }
a629 4

	    if (pointer_encoding (fs->addr_encoding) != PE_absptr)
	      warning ("CFI: DW_CFA_set_loc uses relative addressing");

d820 3
a822 1
  gdb_assert (fde->cie_ptr != NULL);
d824 14
a837 12
  cie = fde->cie_ptr;
  
  fs->code_align = cie->code_align;
  fs->data_align = cie->data_align;
  fs->retaddr_column = cie->ra;
  fs->addr_encoding = cie->addr_encoding;
  fs->objfile = cie->objfile;
  
  execute_cfa_program (cie->objfile, cie->data,
		       cie->data + cie->data_length, context, fs);
  execute_cfa_program (cie->objfile, fde->data,
		       fde->data + fde->data_length, context, fs);
d1096 2
a1097 5
		int len = TARGET_ADDR_BIT / TARGET_CHAR_BIT;
		if (len != 4 && len != 8)
		  internal_error (__FILE__, __LINE__,
				  "execute_stack_op error");
		result = read_memory_unsigned_integer (result, len);
d1103 19
a1121 5
		int len = *op_ptr++;
		if (len != 1 && len != 2 && len != 4 && len !=8)
		  internal_error (__FILE__, __LINE__,
				  "execute_stack_op error");
		result = read_memory_unsigned_integer (result, len);
d1217 1
a1217 2
	      default:
		error ("execute_stack_op: Unknown DW_OP_ value");
d1261 1
a1261 1
  CORE_ADDR cfa = 0;
a1335 1
	    break;
d1337 2
a1338 1
	    internal_error (__FILE__, __LINE__, "bad switch");
d1355 2
a1356 1
	internal_error (__FILE__, __LINE__, "bad switch");
d1383 3
a1385 17
    found in .debug_frame and .eh_frame sections.  */
/* We can handle both of these sections almost in the same way, however there
   are some exceptions:
   - CIE ID is -1 in debug_frame, but 0 in eh_frame
   - eh_frame may contain some more information that are used only by gcc 
     (eg. personality pointer, LSDA pointer, ...). Most of them we can ignore.
   - In debug_frame FDE's item cie_id contains offset of it's parent CIE.
     In eh_frame FDE's item cie_id is a relative pointer to the parent CIE.
     Anyway we don't need to bother with this, because we are smart enough 
     to keep the pointer to the parent CIE of oncomming FDEs in 'last_cie'.
   - Although debug_frame items can contain Augmentation as well as 
     eh_frame ones, I have never seen them non-empty. Thus only in eh_frame 
     we can encounter for example non-absolute pointers (Aug. 'R').  
                                                              -- mludvig  */
static void
parse_frame_info (struct objfile *objfile, file_ptr frame_offset,
		  unsigned int frame_size, int eh_frame)
a1387 1
  asection *curr_section_ptr;
d1390 1
a1390 6
  char *frame_buffer = NULL;
  char *curr_section_name, *aug_data;
  struct cie_unit *last_cie = NULL;
  int last_dup_fde = 0;
  int aug_len, i;
  CORE_ADDR curr_section_vma = 0;
d1394 16
a1409 1
  frame_buffer = dwarf2_read_section (objfile, frame_offset, frame_size);
d1411 2
a1412 2
  start = frame_buffer;
  end = frame_buffer + frame_size;
d1414 2
a1415 4
  curr_section_name = eh_frame ? ".eh_frame" : ".debug_frame";
  curr_section_ptr = bfd_get_section_by_name (abfd, curr_section_name);
  if (curr_section_ptr)
    curr_section_vma = curr_section_ptr->vma;
d1423 3
a1425 2
	  ULONGEST unit_offset = start - frame_buffer;
	  int bytes_read, dwarf64;
a1432 6
	  if (length == 0)
	    {
	      start = block_end;
	      continue;
	    }

d1436 1
a1436 1
	  if ((eh_frame && cie_id == 0) || is_cie (cie_id, dwarf64))
d1452 3
a1454 1
	      while (*start++);	/* Skips last NULL as well */
a1459 12
	      /* Augmentation:
	         z      Indicates that a uleb128 is present to size the
	         augmentation section.
	         L      Indicates the encoding (and thus presence) of
	         an LSDA pointer in the FDE augmentation.
	         R      Indicates a non-default pointer encoding for
	         FDE code pointers.
	         P      Indicates the presence of an encoding + language
	         personality routine in the CIE augmentation.

	         [This info comes from GCC's dwarf2out.c]
	       */
d1462 2
a1463 3
		  aug_len = read_uleb128 (abfd, &start);
		  aug_data = start;
		  start += aug_len;
a1466 3
	      cie->data = start;
	      cie->data_length = block_end - cie->data;

d1471 2
a1472 2
		      aug_data += sizeof (void *);
		      aug++;
a1474 2
		    cie->addr_encoding = *aug_data++;
		  else if (aug[0] == 'P')
d1476 2
a1477 8
		      CORE_ADDR pers_addr;
		      int pers_addr_enc;

		      pers_addr_enc = *aug_data++;
		      /* We don't need pers_addr value and so we 
		         don't care about it's encoding.  */
		      pers_addr = read_encoded_pointer (abfd, &aug_data,
							pers_addr_enc);
d1479 1
a1479 1
		  else if (aug[0] == 'L' && eh_frame)
d1481 4
a1484 5
		      int lsda_addr_enc;

		      /* Perhaps we should save this to CIE for later use?
		         Do we need it for something in GDB?  */
		      lsda_addr_enc = *aug_data++;
d1487 1
a1487 5
		    warning ("CFI warning: unknown augmentation \"%c\""
			     " in \"%s\" of\n"
			     "\t%s", aug[0], curr_section_name,
			     objfile->name);
		  aug++;
d1490 2
a1491 1
	      last_cie = cie;
a1496 14
	      int dup = 0;
	      CORE_ADDR init_loc;

	      /* We assume that debug_frame is in order 
	         CIE,FDE,CIE,FDE,FDE,...  and thus the CIE for this FDE
	         should be stored in last_cie pointer. If not, we'll 
	         try to find it by the older way.  */
	      if (last_cie)
		cie = last_cie;
	      else
		{
		  warning ("CFI: last_cie == NULL. "
			   "Perhaps a malformed %s section in '%s'...?\n",
			   curr_section_name, objfile->name);
d1498 2
a1499 12
		  cie = cie_chunks;
		  while (cie)
		    {
		      if (cie->objfile == objfile)
			{
			  if (eh_frame &&
			      (cie->offset ==
			       (unit_offset + bytes_read - cie_id)))
			    break;
			  if (!eh_frame && (cie->offset == cie_id))
			    break;
			}
d1501 1
a1501 5
		      cie = cie->next;
		    }
		  if (!cie)
		    error ("CFI: can't find CIE pointer");
		}
d1503 4
a1506 2
	      init_loc = read_encoded_pointer (abfd, &start,
					       cie->addr_encoding);
d1508 2
a1509 1
	      switch (pointer_encoding (cie->addr_encoding))
d1511 7
a1517 42
		case PE_absptr:
		  break;
		case PE_pcrel:
		  /* start-frame_buffer gives offset from 
		     the beginning of actual section.  */
		  init_loc += curr_section_vma + start - frame_buffer;
		  break;
		default:
		  warning ("CFI: Unsupported pointer encoding\n");
		}

	      /* For relocatable objects we must add an offset telling
	         where the section is actually mapped in the memory.  */
	      init_loc += ANOFFSET (objfile->section_offsets,
				    SECT_OFF_TEXT (objfile));

	      /* If we have both .debug_frame and .eh_frame present in 
	         a file, we must eliminate duplicate FDEs. For now we'll 
	         run through all entries in fde_chunks and check it one 
	         by one. Perhaps in the future we can implement a faster 
	         searching algorithm.  */
	      /* eh_frame==2 indicates, that this file has an already 
	         parsed .debug_frame too. When eh_frame==1 it means, that no
	         .debug_frame is present and thus we don't need to check for
	         duplicities. eh_frame==0 means, that we parse .debug_frame
	         and don't need to care about duplicate FDEs, because
	         .debug_frame is parsed first.  */
	      if (eh_frame == 2)
		for (i = 0; eh_frame == 2 && i < fde_chunks.elems; i++)
		  {
		    /* We assume that FDEs in .debug_frame and .eh_frame 
		       have the same order (if they are present, of course).
		       If we find a duplicate entry for one FDE and save
		       it's index to last_dup_fde it's very likely, that 
		       we'll find an entry for the following FDE right after 
		       the previous one. Thus in many cases we'll run this 
		       loop only once.  */
		    last_dup_fde = (last_dup_fde + i) % fde_chunks.elems;
		    if (fde_chunks.array[last_dup_fde]->initial_location
			== init_loc)
		      {
			dup = 1;
d1519 1
a1519 2
		      }
		  }
d1521 2
a1522 8
	      /* Allocate a new entry only if this FDE isn't a duplicate of
	         something we have already seen.   */
	      if (!dup)
		{
		  fde_chunks_need_space ();
		  fde = fde_unit_alloc ();

		  fde_chunks.array[fde_chunks.elems++] = fde;
d1524 3
a1526 4
		  fde->initial_location = init_loc;
		  fde->address_range = read_encoded_pointer (abfd, &start,
							     cie->
							     addr_encoding);
d1528 2
a1529 1
		  fde->cie_ptr = cie;
d1531 2
a1532 8
		  /* Here we intentionally ignore augmentation data
		     from FDE, because we don't need them.  */
		  if (cie->augmentation[0] == 'z')
		    start += read_uleb128 (abfd, &start);

		  fde->data = start;
		  fde->data_length = block_end - start;
		}
d1540 1
a1540 24

/* We must parse both .debug_frame section and .eh_frame because 
 * not all frames must be present in both of these sections. */
void
dwarf2_build_frame_info (struct objfile *objfile)
{
  int after_debug_frame = 0;

  /* If we have .debug_frame then the parser is called with 
     eh_frame==0 for .debug_frame and eh_frame==2 for .eh_frame, 
     otherwise it's only called once for .eh_frame with argument 
     eh_frame==1.  */

  if (dwarf_frame_offset)
    {
      parse_frame_info (objfile, dwarf_frame_offset,
			dwarf_frame_size, 0 /* = debug_frame */ );
      after_debug_frame = 1;
    }

  if (dwarf_eh_frame_offset)
    parse_frame_info (objfile, dwarf_eh_frame_offset, dwarf_eh_frame_size,
		      1 /* = eh_frame */  + after_debug_frame);
}
d1544 1
a1544 1
cfi_read_fp (void)
d1600 1
a1600 1
  char *regbuf = alloca (MAX_REGISTER_RAW_SIZE);
d1603 2
d1704 1
a1704 1
			CORE_ADDR *addrp,
@


1.7.2.3
log
@merge from mainline
@
text
@d93 31
d211 2
d215 1
d217 13
a229 13
static unsigned int read_1u (bfd *abfd, char **p);
static int read_1s (bfd *abfd, char **p);
static unsigned int read_2u (bfd *abfd, char **p);
static int read_2s (bfd *abfd, char **p);
static unsigned int read_4u (bfd *abfd, char **p);
static int read_4s (bfd *abfd, char **p);
static ULONGEST read_8u (bfd *abfd, char **p);
static LONGEST read_8s (bfd *abfd, char **p);

static ULONGEST read_uleb128 (bfd *abfd, char **p);
static LONGEST read_sleb128 (bfd *abfd, char **p);
static CORE_ADDR read_pointer (bfd *abfd, char **p);
static CORE_ADDR read_encoded_pointer (bfd *abfd, char **p,
d233 2
a234 2
static LONGEST read_initial_length (bfd *abfd, char *buf, int *bytes_read);
static ULONGEST read_length (bfd *abfd, char *buf, int *bytes_read,
d289 1
a289 1
struct context *
d306 1
a306 1
struct frame_state *
d335 1
a335 1
void
d341 11
a351 3
  /* Since `struct context' contains a pointer to an array with
     register values, make sure we end up with a copy of that array,
     and not with a copy of the pointer to that array.  */
d355 1
d360 1
a360 1
read_1u (bfd *abfd, char **p)
d370 1
a370 1
read_1s (bfd *abfd, char **p)
d380 1
a380 1
read_2u (bfd *abfd, char **p)
d390 1
a390 1
read_2s (bfd *abfd, char **p)
d400 1
a400 1
read_4u (bfd *abfd, char **p)
d410 1
a410 1
read_4s (bfd *abfd, char **p)
d420 1
a420 1
read_8u (bfd *abfd, char **p)
d430 1
a430 1
read_8s (bfd *abfd, char **p)
d440 1
a440 1
read_uleb128 (bfd *abfd, char **p)
d464 1
a464 1
read_sleb128 (bfd *abfd, char **p)
d494 1
a494 1
read_pointer (bfd *abfd, char **p)
d507 3
a509 3
/* Read the appropriate amount of data from *P and return the
   resulting value based on ENCODING, which the calling function must
   provide.  */
d511 1
a511 1
read_encoded_pointer (bfd *abfd, char **p, unsigned char encoding)
d556 4
a559 4
/* The variable 'encoding' carries three different flags:
   - encoding & 0x0f : size of the address (handled in read_encoded_pointer())
   - encoding & 0x70 : type (absolute, relative, ...)
   - encoding & 0x80 : indirect flag (DW_EH_PE_indirect == 0x80).  */
d584 1
a584 1
read_initial_length (bfd *abfd, char *buf, int *bytes_read)
d604 1
a604 1
read_length (bfd *abfd, char *buf, int *bytes_read, int dwarf64)
d851 1
a851 1

d857 1
a857 1

d870 1
a870 1
      deprecated_read_register_gen (regnum, reg);
d877 1
a877 1
      deprecated_read_register_gen (context->reg[regnum].loc.reg, reg);
d1131 1
a1131 1
		if (len != 1 && len != 2 && len != 4 && len != 8)
d1734 1
a1734 1
      deprecated_write_register_gen (fs->cfa_reg, (char *) &val);
d1865 1
a1865 1
      deprecated_read_register_gen (regnum, raw_buffer);
d1877 1
a1877 1
	  deprecated_read_register_gen (regnum, raw_buffer);
d1895 2
a1896 2
	  deprecated_read_register_gen (UNWIND_CONTEXT (frame)->reg[regnum].loc.reg,
					raw_buffer);
@


1.6
log
@2002-05-22  Michal Ludvig  <mludvig@@suse.cz>
	* dwarf2cfi.c (frame_state_for): Added safety check for a valid
	fde->cie_ptr.
	(dwarf2_build_frame_info): Corrected handling of eh_frame.
	(dwarf2_build_frame_info): Add offset to fde->initial_location
	so that frames of shared libraries are mapped correctly.
@
text
@d878 2
a879 1
      ULONGEST result, reg;
@


1.5
log
@2002-05-14  Michal Ludvig  <mludvig@@suse.cz>
	* dwarf2cfi.c (context_cpy): Copy registers correctly.
	(update_context): Use __func__ in warnings.
@
text
@d805 6
a810 3
  if ((fde = get_fde_for_addr (context->ra - 1)) != NULL)
    {
      fs->pc = fde->initial_location;
d812 2
d815 1
d826 5
a830 1
    }
d1380 1
d1403 2
d1426 1
a1426 1
	  if (is_cie (cie_id, dwarf64))
d1477 1
a1477 1
		    warning ("unknown augmentation");
d1492 3
a1494 1
	      fde->initial_location = read_pointer (abfd, &start);
d1497 14
a1510 2
	      for (cie = cie_chunks;
		   cie && (cie->offset != cie_id); cie = cie->next);
d1512 1
a1512 1
		error ("dwarf cfi error: can't find CIE pointer");
@


1.5.2.1
log
@merge from trunk
@
text
@a203 1
static void unwind_tmp_obstack_init ();
d207 13
a219 13
static unsigned int read_1u (bfd * abfd, char **p);
static int read_1s (bfd * abfd, char **p);
static unsigned int read_2u (bfd * abfd, char **p);
static int read_2s (bfd * abfd, char **p);
static unsigned int read_4u (bfd * abfd, char **p);
static int read_4s (bfd * abfd, char **p);
static ULONGEST read_8u (bfd * abfd, char **p);
static LONGEST read_8s (bfd * abfd, char **p);

static ULONGEST read_uleb128 (bfd * abfd, char **p);
static LONGEST read_sleb128 (bfd * abfd, char **p);
static CORE_ADDR read_pointer (bfd * abfd, char **p);
static CORE_ADDR read_encoded_pointer (bfd * abfd, char **p,
d222 2
a223 2
static LONGEST read_initial_length (bfd * abfd, char *buf, int *bytes_read);
static ULONGEST read_length (bfd * abfd, char *buf, int *bytes_read,
d238 1
a238 2
				   struct context *context,
				   CORE_ADDR initial);
d241 1
a242 1

d304 2
a305 2
  fs->regs.reg =
    (struct frame_state_reg *) obstack_alloc (&unwind_tmp_obstack, regs_size);
a310 6
unwind_tmp_obstack_init ()
{
  obstack_init (&unwind_tmp_obstack);
}

static void
d314 1
a314 1
  unwind_tmp_obstack_init ();
d337 1
a337 1

d342 1
a342 1
read_1u (bfd * abfd, char **p)
d346 2
a347 2
  ret = bfd_get_8 (abfd, (bfd_byte *) * p);
  (*p)++;
d352 1
a352 1
read_1s (bfd * abfd, char **p)
d356 2
a357 2
  ret = bfd_get_signed_8 (abfd, (bfd_byte *) * p);
  (*p)++;
d362 1
a362 1
read_2u (bfd * abfd, char **p)
d366 2
a367 2
  ret = bfd_get_16 (abfd, (bfd_byte *) * p);
  (*p)++;
d372 1
a372 1
read_2s (bfd * abfd, char **p)
d376 1
a376 1
  ret = bfd_get_signed_16 (abfd, (bfd_byte *) * p);
d382 1
a382 1
read_4u (bfd * abfd, char **p)
d386 1
a386 1
  ret = bfd_get_32 (abfd, (bfd_byte *) * p);
d392 1
a392 1
read_4s (bfd * abfd, char **p)
d396 1
a396 1
  ret = bfd_get_signed_32 (abfd, (bfd_byte *) * p);
d402 1
a402 1
read_8u (bfd * abfd, char **p)
d406 1
a406 1
  ret = bfd_get_64 (abfd, (bfd_byte *) * p);
d412 1
a412 1
read_8s (bfd * abfd, char **p)
d416 1
a416 1
  ret = bfd_get_signed_64 (abfd, (bfd_byte *) * p);
d422 1
a422 1
read_uleb128 (bfd * abfd, char **p)
d433 2
a434 2
      byte = bfd_get_8 (abfd, (bfd_byte *) * p);
      (*p)++;
d446 1
a446 1
read_sleb128 (bfd * abfd, char **p)
d459 2
a460 2
      byte = bfd_get_8 (abfd, (bfd_byte *) * p);
      (*p)++;
d476 1
a476 1
read_pointer (bfd * abfd, char **p)
d490 1
a490 1
read_encoded_pointer (bfd * abfd, char **p, unsigned char encoding)
d538 1
a538 1
	ret += (CORE_ADDR) * p;
d587 2
a588 2
execute_cfa_program (struct objfile *objfile, char *insn_ptr, char *insn_end,
		     struct context *context, struct frame_state *fs)
d607 1
a607 1
	  offset = (long) uoffset *fs->data_align;
d805 3
a807 1
  fde = get_fde_for_addr (context->ra - 1);
a808 7
  if (fde == NULL)
    return;

  fs->pc = fde->initial_location;

  if (fde->cie_ptr)
    {
a809 1

a820 3
  else
    internal_error (__FILE__, __LINE__,
		    "%s(): Internal error: fde->cie_ptr==NULL !", __func__);
d847 2
a848 1
      internal_error (__FILE__, __LINE__, "get_reg: unknown register rule");
d868 1
a868 2
      CORE_ADDR result;
      ULONGEST reg;
d1200 2
a1201 2
	      default:		/* This label is here just to avoid warning.  */
		break;
a1246 2
  unwind_tmp_obstack_init ();

a1248 1

d1259 3
a1261 3
         to do the same sort of handling as above.  Assume that if the
         CFA calculation is so complicated as to require a stack program
         that this will not be a problem.  */
a1369 1
  int from_eh = 0;
d1371 1
a1371 1
  unwind_tmp_obstack_init ();
a1391 2

      from_eh = 1;
d1413 1
a1413 1
	  if ((from_eh && cie_id == 0) || is_cie (cie_id, dwarf64))
d1464 1
a1464 1
		    warning ("%s(): unknown augmentation", __func__);
d1479 1
a1479 4

	      fde->initial_location = read_pointer (abfd, &start)
		+ ANOFFSET (objfile->section_offsets,
			    SECT_OFF_TEXT (objfile));
d1482 2
a1483 16
	      cie = cie_chunks;
	      while (cie)
		{
		  if (cie->objfile == objfile)
		    {
		      if (from_eh
			  && (cie->offset ==
			      (unit_offset + bytes_read - cie_id)))
			break;
		      if (!from_eh && (cie->offset == cie_id))
			break;
		    }

		  cie = cie->next;
		}

d1485 1
a1485 1
		error ("%s(): can't find CIE pointer", __func__);
d1489 1
a1489 1
		read_uleb128 (abfd, &start);
a1509 2
  unwind_tmp_obstack_init ();

a1518 1

a1519 1

a1530 2
  unwind_tmp_obstack_init ();

a1577 2
  unwind_tmp_obstack_init ();

d1594 1
a1594 1

a1613 2
  unwind_tmp_obstack_init ();

a1632 1

a1738 2

  unwind_tmp_obstack_init ();
@


1.5.2.2
log
@More merging.
@
text
@d37 1
a37 1
  /* Offset of this unit in .debug_frame or .eh_frame.  */
a178 9
enum ptr_encoding
{
  PE_absptr = DW_EH_PE_absptr,
  PE_pcrel = DW_EH_PE_pcrel,
  PE_textrel = DW_EH_PE_textrel,
  PE_datarel = DW_EH_PE_datarel,
  PE_funcrel = DW_EH_PE_funcrel
};

d191 2
a221 1
static enum ptr_encoding pointer_encoding (unsigned char encoding);
a496 3
/* This functions only reads appropriate amount of data from *p 
 * and returns the resulting value. Calling function must handle
 * different encoding possibilities itself!  */
d540 15
a554 11
  return ret;
}

/* Variable 'encoding' carries 3 different flags:
 * - encoding & 0x0f : size of the address (handled in read_encoded_pointer())
 * - encoding & 0x70 : type (absolute, relative, ...)
 * - encoding & 0x80 : indirect flag (DW_EH_PE_indirect == 0x80).  */
enum ptr_encoding
pointer_encoding (unsigned char encoding)
{
  int ret;
a555 15
  if (encoding & DW_EH_PE_indirect)
    warning ("CFI: Unsupported pointer encoding: DW_EH_PE_indirect");

  switch (encoding & 0x70)
    {
    case DW_EH_PE_absptr:
    case DW_EH_PE_pcrel:
    case DW_EH_PE_textrel:
    case DW_EH_PE_datarel:
    case DW_EH_PE_funcrel:
      ret = encoding & 0x70;
      break;
    default:
      internal_error (__FILE__, __LINE__, "CFI: unknown pointer encoding");
    }
a629 4

	    if (pointer_encoding (fs->addr_encoding) != PE_absptr)
	      warning ("CFI: DW_CFA_set_loc uses relative addressing");

d1383 3
a1385 17
    found in .debug_frame and .eh_frame sections.  */
/* We can handle both of these sections almost in the same way, however there
   are some exceptions:
   - CIE ID is -1 in debug_frame, but 0 in eh_frame
   - eh_frame may contain some more information that are used only by gcc 
     (eg. personality pointer, LSDA pointer, ...). Most of them we can ignore.
   - In debug_frame FDE's item cie_id contains offset of it's parent CIE.
     In eh_frame FDE's item cie_id is a relative pointer to the parent CIE.
     Anyway we don't need to bother with this, because we are smart enough 
     to keep the pointer to the parent CIE of oncomming FDEs in 'last_cie'.
   - Although debug_frame items can contain Augmentation as well as 
     eh_frame ones, I have never seen them non-empty. Thus only in eh_frame 
     we can encounter for example non-absolute pointers (Aug. 'R').  
                                                              -- mludvig  */
static void
parse_frame_info (struct objfile *objfile, file_ptr frame_offset,
		  unsigned int frame_size, int eh_frame)
a1387 1
  asection *curr_section_ptr;
d1390 1
a1390 6
  char *frame_buffer = NULL;
  char *curr_section_name, *aug_data;
  struct cie_unit *last_cie = NULL;
  int last_dup_fde = 0;
  int aug_len, i;
  CORE_ADDR curr_section_vma = 0;
d1394 16
a1409 1
  frame_buffer = dwarf2_read_section (objfile, frame_offset, frame_size);
d1411 2
a1412 2
  start = frame_buffer;
  end = frame_buffer + frame_size;
d1414 2
a1415 4
  curr_section_name = eh_frame ? ".eh_frame" : ".debug_frame";
  curr_section_ptr = bfd_get_section_by_name (abfd, curr_section_name);
  if (curr_section_ptr)
    curr_section_vma = curr_section_ptr->vma;
d1423 3
a1425 2
	  ULONGEST unit_offset = start - frame_buffer;
	  int bytes_read, dwarf64;
a1432 6
	  if (length == 0)
	    {
	      start = block_end;
	      continue;
	    }

d1436 1
a1436 1
	  if ((eh_frame && cie_id == 0) || is_cie (cie_id, dwarf64))
d1452 3
a1454 1
	      while (*start++);	/* Skips last NULL as well */
a1459 12
	      /* Augmentation:
	         z      Indicates that a uleb128 is present to size the
	         augmentation section.
	         L      Indicates the encoding (and thus presence) of
	         an LSDA pointer in the FDE augmentation.
	         R      Indicates a non-default pointer encoding for
	         FDE code pointers.
	         P      Indicates the presence of an encoding + language
	         personality routine in the CIE augmentation.

	         [This info comes from GCC's dwarf2out.c]
	       */
d1462 2
a1463 3
		  aug_len = read_uleb128 (abfd, &start);
		  aug_data = start;
		  start += aug_len;
a1466 3
	      cie->data = start;
	      cie->data_length = block_end - cie->data;

d1471 2
a1472 2
		      aug_data += sizeof (void *);
		      aug++;
a1474 2
		    cie->addr_encoding = *aug_data++;
		  else if (aug[0] == 'P')
d1476 2
a1477 8
		      CORE_ADDR pers_addr;
		      int pers_addr_enc;

		      pers_addr_enc = *aug_data++;
		      /* We don't need pers_addr value and so we 
		         don't care about it's encoding.  */
		      pers_addr = read_encoded_pointer (abfd, &aug_data,
							pers_addr_enc);
d1479 1
a1479 1
		  else if (aug[0] == 'L' && eh_frame)
d1481 4
a1484 5
		      int lsda_addr_enc;

		      /* Perhaps we should save this to CIE for later use?
		         Do we need it for something in GDB?  */
		      lsda_addr_enc = *aug_data++;
d1487 1
a1487 5
		    warning ("CFI warning: unknown augmentation \"%c\""
			     " in \"%s\" of\n"
			     "\t%s", aug[0], curr_section_name,
			     objfile->name);
		  aug++;
d1490 2
a1491 1
	      last_cie = cie;
a1496 2
	      int dup = 0;
	      CORE_ADDR init_loc;
d1498 2
a1499 11
	      /* We assume that debug_frame is in order 
	         CIE,FDE,CIE,FDE,FDE,...  and thus the CIE for this FDE
	         should be stored in last_cie pointer. If not, we'll 
	         try to find it by the older way.  */
	      if (last_cie)
		cie = last_cie;
	      else
		{
		  warning ("CFI: last_cie == NULL. "
			   "Perhaps a malformed %s section in '%s'...?\n",
			   curr_section_name, objfile->name);
d1501 1
a1501 12
		  cie = cie_chunks;
		  while (cie)
		    {
		      if (cie->objfile == objfile)
			{
			  if (eh_frame &&
			      (cie->offset ==
			       (unit_offset + bytes_read - cie_id)))
			    break;
			  if (!eh_frame && (cie->offset == cie_id))
			    break;
			}
d1503 4
a1506 8
		      cie = cie->next;
		    }
		  if (!cie)
		    error ("CFI: can't find CIE pointer");
		}

	      init_loc = read_encoded_pointer (abfd, &start,
					       cie->addr_encoding);
d1508 2
a1509 1
	      switch (pointer_encoding (cie->addr_encoding))
d1511 7
a1517 42
		case PE_absptr:
		  break;
		case PE_pcrel:
		  /* start-frame_buffer gives offset from 
		     the beginning of actual section.  */
		  init_loc += curr_section_vma + start - frame_buffer;
		  break;
		default:
		  warning ("CFI: Unsupported pointer encoding\n");
		}

	      /* For relocatable objects we must add an offset telling
	         where the section is actually mapped in the memory.  */
	      init_loc += ANOFFSET (objfile->section_offsets,
				    SECT_OFF_TEXT (objfile));

	      /* If we have both .debug_frame and .eh_frame present in 
	         a file, we must eliminate duplicate FDEs. For now we'll 
	         run through all entries in fde_chunks and check it one 
	         by one. Perhaps in the future we can implement a faster 
	         searching algorithm.  */
	      /* eh_frame==2 indicates, that this file has an already 
	         parsed .debug_frame too. When eh_frame==1 it means, that no
	         .debug_frame is present and thus we don't need to check for
	         duplicities. eh_frame==0 means, that we parse .debug_frame
	         and don't need to care about duplicate FDEs, because
	         .debug_frame is parsed first.  */
	      if (eh_frame == 2)
		for (i = 0; eh_frame == 2 && i < fde_chunks.elems; i++)
		  {
		    /* We assume that FDEs in .debug_frame and .eh_frame 
		       have the same order (if they are present, of course).
		       If we find a duplicate entry for one FDE and save
		       it's index to last_dup_fde it's very likely, that 
		       we'll find an entry for the following FDE right after 
		       the previous one. Thus in many cases we'll run this 
		       loop only once.  */
		    last_dup_fde = (last_dup_fde + i) % fde_chunks.elems;
		    if (fde_chunks.array[last_dup_fde]->initial_location
			== init_loc)
		      {
			dup = 1;
d1519 1
a1519 2
		      }
		  }
d1521 2
a1522 13
	      /* Allocate a new entry only if this FDE isn't a duplicate of
	         something we have already seen.   */
	      if (!dup)
		{
		  fde_chunks_need_space ();
		  fde = fde_unit_alloc ();

		  fde_chunks.array[fde_chunks.elems++] = fde;

		  fde->initial_location = init_loc;
		  fde->address_range = read_encoded_pointer (abfd, &start,
							     cie->
							     addr_encoding);
d1524 3
a1526 1
		  fde->cie_ptr = cie;
d1528 2
a1529 4
		  /* Here we intentionally ignore augmentation data
		     from FDE, because we don't need them.  */
		  if (cie->augmentation[0] == 'z')
		    start += read_uleb128 (abfd, &start);
d1531 2
a1532 3
		  fde->data = start;
		  fde->data_length = block_end - start;
		}
d1540 1
a1540 24

/* We must parse both .debug_frame section and .eh_frame because 
 * not all frames must be present in both of these sections. */
void
dwarf2_build_frame_info (struct objfile *objfile)
{
  int after_debug_frame = 0;

  /* If we have .debug_frame then the parser is called with 
     eh_frame==0 for .debug_frame and eh_frame==2 for .eh_frame, 
     otherwise it's only called once for .eh_frame with argument 
     eh_frame==1.  */

  if (dwarf_frame_offset)
    {
      parse_frame_info (objfile, dwarf_frame_offset,
			dwarf_frame_size, 0 /* = debug_frame */ );
      after_debug_frame = 1;
    }

  if (dwarf_eh_frame_offset)
    parse_frame_info (objfile, dwarf_eh_frame_offset, dwarf_eh_frame_size,
		      1 /* = eh_frame */  + after_debug_frame);
}
d1704 1
a1704 1
			CORE_ADDR *addrp,
@


1.4
log
@2002-05-07  Michal Ludvig  <mludvig@@suse.cz>
	* dwarf2cfi.c: Code cleanup, removed unused variables,
	added default labels to switch {} statements.
	* x86-64-tdep.c: Ditto.
	* x86-64-linux-nat.c: Ditto.
@
text
@d321 1
d323 12
d336 2
a339 1

d1318 1
a1318 1
			    "cfi_update_context: unknown register rule");
d1336 1
a1336 2
			"cfi_update_context: unknown register rule");

d1594 1
@


1.3
log
@* h8500-tdep.c (h8500_write_fp): Delete function.
* dwarf2cfi.c (cfi_write_fp): Document as not used.
* mips-tdep.c (mips_gdbarch_init): Do not set write_fp.
* ia64-tdep.c (ia64_gdbarch_init): Do not set write_fp.
* m68hc11-tdep.c (m68hc11_gdbarch_init): Do not set write_fp.
* rs6000-tdep.c (rs6000_gdbarch_init): Do not set write_fp.
* s390-tdep.c (s390_gdbarch_init): Do not set write_fp.
(s390_write_fp):
* sh-tdep.c (sh_gdbarch_init): Do not set write_fp.
* x86-64-tdep.c (i386_gdbarch_init): Do not set write_fp.
* d10v-tdep.c (d10v_gdbarch_init): Do not set write_fp.
(d10v_write_fp): Delete function.
* inferior.h (write_fp, generic_target_write_fp): Delete
declarations.
* regcache.c (generic_target_write_fp): Delete function.
(write_fp): Delete function.
* gdbarch.sh (TARGET_WRITE_FP): Delete.
* gdbarch.h, gdbarch.c: Regenerate.
* config/v850/tm-v850.h (TARGET_WRITE_FP): Delete macro.
* config/sparc/tm-sp64.h (TARGET_WRITE_FP): Delete macro.
(sparc64_write_fp): Delete declaration.
* config/h8500/tm-h8500.h (TARGET_WRITE_FP): Delete macro.
(h8500_write_fp): Delete declaration.
@
text
@a224 2
static ULONGEST read_address (bfd *abfd, char **p);

d281 1
a281 1
  struct context_reg *reg;
d298 1
a298 1
  struct frame_state_reg *reg;
a319 1
  struct context_reg *reg = dst->reg;
a585 1
      int bytes_read;
a786 1
  unsigned char *aug, *insn, *end;
d1107 2
d1186 2
d1257 2
d1350 1
a1350 1
    in .debug.frame section.  */
@


1.2
log
@	* dwarf2cfi.c: Give credit to Daniel Berlin, reformat copyright
	comment.
@
text
@d1509 2
a1510 1
/* Store the frame address.  */
@


1.1
log
@* dwarf2cfi.c: New file.
* dwarf2cfi.h: New file.
* dwarf2read.c (dwarf_frame_offset, dwarf_frame_size): New variables.
(dwarf_eh_frame_offset, dwarf_eh_frame_size): New variables.
(dwarf2_read_section): Change to non static.
(dwarf2_locate_sections): Add .debug_frame and .eh_frame section
recognition.
(FRAME_SECTION, EH_FRAME_SECTION): New define.
* elfread.c (elf_symfile_read): Add call of frame informations build.
* frame.h (frame_info): Add pointer to unwind_context.
* symfile.h (dwarf2_build_frame_info): Add declaration.
* gdbarch.sh (DWARF2_BUILD_FRAME_INFO): Add.
* gdbarch.h, gdbarch.c: Regenerate.
* Makefile.in: Add dwarf2cfi_h, dwarf2cfi.o
* x86-64-tdep.c (i386_gdbarch_init): Initialize target vector to
use debug frame info.
@
text
@d2 1
a2 2
   Copyright 2001
   Free Software Foundation, Inc.
d4 1
@


1.1.2.1
log
@	* dwarf2cfi.c: Give credit to Daniel Berlin, reformat copyright
	comment.
@
text
@d2 2
a3 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
a4 1
   Based on code written by Daniel Berlin (dan@@dberlin.org).
@


1.1.2.2
log
@2002-05-14  Michal Ludvig  <mludvig@@suse.cz>

	Merge from mainline:

	2002-05-14  Michal Ludvig  <mludvig@@suse.cz>

		* dwarf2cfi.c (context_cpy): Copy registers correctly.
		(update_context): Use __func__ in warnings.

	2002-05-07  Michal Ludvig  <mludvig@@suse.cz>

		* dwarf2cfi.c: Code cleanup, removed unused variables,
		added default labels to switch {} statements.
@
text
@d225 2
d283 1
a283 1

d300 1
a300 1

d322 1
a323 1
  struct context_reg *dreg;
a324 12
  /* Structure dst contains a pointer to an array of
   * registers of a given frame as well as src does. This
   * array was already allocated before dst was passed to
   * context_cpy but the pointer to it was overriden by
   * '*dst = *src' and the array was lost. This led to the
   * situation, that we've had a copy of src placed in dst,
   * but both of them pointed to the same regs array and
   * thus we've sometimes blindly rewritten it.  Now we save
   * the pointer before copying src to dst, return it back
   * after that and copy the registers into their new place
   * finally.   ---   mludvig@@suse.cz  */
  dreg = dst->reg;
a325 2
  dst->reg = dreg;
  
d328 1
d589 1
d791 1
a1111 2
	    default:
	      break;
a1188 2
	      default:	/* This label is here just to avoid warning.  */
	        break; 
a1257 2
    default:
      break;
d1303 1
a1303 1
			    "%s: unknown register rule", __func__);
d1321 2
a1322 1
			"%s: unknown register rule", __func__);
d1349 1
a1349 1
    in .debug_frame section.  */
d1509 1
a1509 2
/* Store the frame address.  This function is not used.  */

a1578 1
  
@


1.1.2.3
log
@2002-05-22  Michal Ludvig  <mludvig@@suse.cz>
	* dwarf2cfi.c (frame_state_for): Added safety check for a valid
	fde->cie_ptr.
	(dwarf2_build_frame_info): Corrected handling of eh_frame.
	(dwarf2_build_frame_info): Add offset to fde->initial_location
	so that frames of shared libraries are mapped correctly.
@
text
@d805 3
a807 6
  fde = get_fde_for_addr (context->ra - 1);

  if (fde == NULL)
    return;
  
  fs->pc = fde->initial_location;
a808 2
  if (fde->cie_ptr)
  {
a809 1
      
d820 1
a820 5
  }
  else
	internal_error (__FILE__, __LINE__,
		"%s(): Internal error: fde->cie_ptr==NULL !", 
		__func__);
a1369 1
  int from_eh = 0;
a1391 2

      from_eh = 1;
d1413 1
a1413 1
	  if ((from_eh && cie_id == 0) || is_cie (cie_id, dwarf64))
d1464 1
a1464 1
		    warning ("%s(): unknown augmentation", __func__);
d1479 1
a1479 3
	      
	      fde->initial_location = read_pointer (abfd, &start)
	        + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1482 2
a1483 14
	      cie = cie_chunks;
	      while(cie)
	      {
	        if (cie->objfile == objfile)
		{
		  if (from_eh && (cie->offset == (unit_offset + bytes_read - cie_id)))
		      break;
		  if (!from_eh && (cie->offset == cie_id))
		    break;
		}

		cie = cie->next;
	      }
	    
d1485 1
a1485 1
		error ("%s(): can't find CIE pointer", __func__);
@


1.1.2.4
log
@2002-05-22  Michal Ludvig  <mludvig@@suse.cz>

	* dwarf2cfi.c (execute_stack_op): Change type of 'result'
	from ULONGEST to CORE_ADDR.
@
text
@d878 1
a878 2
      CORE_ADDR result;
      ULONGEST reg;
@


1.1.2.5
log
@Merge with mainline.
@
text
@d37 1
a37 1
  /* Offset of this unit in .debug_frame or .eh_frame.  */
a178 9
enum ptr_encoding
{
  PE_absptr = DW_EH_PE_absptr,
  PE_pcrel = DW_EH_PE_pcrel,
  PE_textrel = DW_EH_PE_textrel,
  PE_datarel = DW_EH_PE_datarel,
  PE_funcrel = DW_EH_PE_funcrel
};

d191 2
a203 1
static void unwind_tmp_obstack_init ();
d207 13
a219 13
static unsigned int read_1u (bfd * abfd, char **p);
static int read_1s (bfd * abfd, char **p);
static unsigned int read_2u (bfd * abfd, char **p);
static int read_2s (bfd * abfd, char **p);
static unsigned int read_4u (bfd * abfd, char **p);
static int read_4s (bfd * abfd, char **p);
static ULONGEST read_8u (bfd * abfd, char **p);
static LONGEST read_8s (bfd * abfd, char **p);

static ULONGEST read_uleb128 (bfd * abfd, char **p);
static LONGEST read_sleb128 (bfd * abfd, char **p);
static CORE_ADDR read_pointer (bfd * abfd, char **p);
static CORE_ADDR read_encoded_pointer (bfd * abfd, char **p,
a220 1
static enum ptr_encoding pointer_encoding (unsigned char encoding);
d222 2
a223 2
static LONGEST read_initial_length (bfd * abfd, char *buf, int *bytes_read);
static ULONGEST read_length (bfd * abfd, char *buf, int *bytes_read,
d238 1
a238 2
				   struct context *context,
				   CORE_ADDR initial);
d241 1
a242 1

d304 2
a305 2
  fs->regs.reg =
    (struct frame_state_reg *) obstack_alloc (&unwind_tmp_obstack, regs_size);
a310 6
unwind_tmp_obstack_init ()
{
  obstack_init (&unwind_tmp_obstack);
}

static void
d314 1
a314 1
  unwind_tmp_obstack_init ();
d337 1
a337 1

d342 1
a342 1
read_1u (bfd * abfd, char **p)
d346 2
a347 2
  ret = bfd_get_8 (abfd, (bfd_byte *) * p);
  (*p)++;
d352 1
a352 1
read_1s (bfd * abfd, char **p)
d356 2
a357 2
  ret = bfd_get_signed_8 (abfd, (bfd_byte *) * p);
  (*p)++;
d362 1
a362 1
read_2u (bfd * abfd, char **p)
d366 2
a367 2
  ret = bfd_get_16 (abfd, (bfd_byte *) * p);
  (*p)++;
d372 1
a372 1
read_2s (bfd * abfd, char **p)
d376 1
a376 1
  ret = bfd_get_signed_16 (abfd, (bfd_byte *) * p);
d382 1
a382 1
read_4u (bfd * abfd, char **p)
d386 1
a386 1
  ret = bfd_get_32 (abfd, (bfd_byte *) * p);
d392 1
a392 1
read_4s (bfd * abfd, char **p)
d396 1
a396 1
  ret = bfd_get_signed_32 (abfd, (bfd_byte *) * p);
d402 1
a402 1
read_8u (bfd * abfd, char **p)
d406 1
a406 1
  ret = bfd_get_64 (abfd, (bfd_byte *) * p);
d412 1
a412 1
read_8s (bfd * abfd, char **p)
d416 1
a416 1
  ret = bfd_get_signed_64 (abfd, (bfd_byte *) * p);
d422 1
a422 1
read_uleb128 (bfd * abfd, char **p)
d433 2
a434 2
      byte = bfd_get_8 (abfd, (bfd_byte *) * p);
      (*p)++;
d446 1
a446 1
read_sleb128 (bfd * abfd, char **p)
d459 2
a460 2
      byte = bfd_get_8 (abfd, (bfd_byte *) * p);
      (*p)++;
d476 1
a476 1
read_pointer (bfd * abfd, char **p)
a488 3
/* This functions only reads appropriate amount of data from *p 
 * and returns the resulting value. Calling function must handle
 * different encoding possibilities itself!  */
d490 1
a490 1
read_encoded_pointer (bfd * abfd, char **p, unsigned char encoding)
d532 15
a546 2
  return ret;
}
a547 24
/* Variable 'encoding' carries 3 different flags:
 * - encoding & 0x0f : size of the address (handled in read_encoded_pointer())
 * - encoding & 0x70 : type (absolute, relative, ...)
 * - encoding & 0x80 : indirect flag (DW_EH_PE_indirect == 0x80).  */
enum ptr_encoding
pointer_encoding (unsigned char encoding)
{
  int ret;

  if (encoding & DW_EH_PE_indirect)
    warning ("CFI: Unsupported pointer encoding: DW_EH_PE_indirect");

  switch (encoding & 0x70)
    {
    case DW_EH_PE_absptr:
    case DW_EH_PE_pcrel:
    case DW_EH_PE_textrel:
    case DW_EH_PE_datarel:
    case DW_EH_PE_funcrel:
      ret = encoding & 0x70;
      break;
    default:
      internal_error (__FILE__, __LINE__, "CFI: unknown pointer encoding");
    }
d587 2
a588 2
execute_cfa_program (struct objfile *objfile, char *insn_ptr, char *insn_end,
		     struct context *context, struct frame_state *fs)
d607 1
a607 1
	  offset = (long) uoffset *fs->data_align;
a621 4

	    if (pointer_encoding (fs->addr_encoding) != PE_absptr)
	      warning ("CFI: DW_CFA_set_loc uses relative addressing");

d809 1
a809 1

d813 1
a813 1
    {
d815 1
a815 1

d826 1
a826 1
    }
d828 3
a830 2
    internal_error (__FILE__, __LINE__,
		    "%s(): Internal error: fde->cie_ptr==NULL !", __func__);
d857 2
a858 1
      internal_error (__FILE__, __LINE__, "get_reg: unknown register rule");
d1211 2
a1212 2
	      default:		/* This label is here just to avoid warning.  */
		break;
a1257 2
  unwind_tmp_obstack_init ();

a1259 1

d1270 3
a1272 3
         to do the same sort of handling as above.  Assume that if the
         CFA calculation is so complicated as to require a stack program
         that this will not be a problem.  */
d1374 3
a1376 17
    found in .debug_frame and .eh_frame sections.  */
/* We can handle both of these sections almost in the same way, however there
   are some exceptions:
   - CIE ID is -1 in debug_frame, but 0 in eh_frame
   - eh_frame may contain some more information that are used only by gcc 
     (eg. personality pointer, LSDA pointer, ...). Most of them we can ignore.
   - In debug_frame FDE's item cie_id contains offset of it's parent CIE.
     In eh_frame FDE's item cie_id is a relative pointer to the parent CIE.
     Anyway we don't need to bother with this, because we are smart enough 
     to keep the pointer to the parent CIE of oncomming FDEs in 'last_cie'.
   - Although debug_frame items can contain Augmentation as well as 
     eh_frame ones, I have never seen them non-empty. Thus only in eh_frame 
     we can encounter for example non-absolute pointers (Aug. 'R').  
                                                              -- mludvig  */
static void
parse_frame_info (struct objfile *objfile, file_ptr frame_offset,
		  unsigned int frame_size, int eh_frame)
a1378 1
  asection *curr_section_ptr;
d1381 26
a1406 18
  char *frame_buffer = NULL;
  char *curr_section_name, *aug_data;
  struct cie_unit *last_cie = NULL;
  int last_dup_fde = 0;
  int aug_len, i;
  CORE_ADDR curr_section_vma = 0;

  unwind_tmp_obstack_init ();

  frame_buffer = dwarf2_read_section (objfile, frame_offset, frame_size);

  start = frame_buffer;
  end = frame_buffer + frame_size;

  curr_section_name = eh_frame ? ".eh_frame" : ".debug_frame";
  curr_section_ptr = bfd_get_section_by_name (abfd, curr_section_name);
  if (curr_section_ptr)
    curr_section_vma = curr_section_ptr->vma;
d1414 3
a1416 2
	  ULONGEST unit_offset = start - frame_buffer;
	  int bytes_read, dwarf64;
a1423 6
	  if (length == 0)
	    {
	      start = block_end;
	      continue;
	    }

d1427 1
a1427 1
	  if ((eh_frame && cie_id == 0) || is_cie (cie_id, dwarf64))
d1443 3
a1445 1
	      while (*start++);	/* Skips last NULL as well */
a1450 12
	      /* Augmentation:
	         z      Indicates that a uleb128 is present to size the
	         augmentation section.
	         L      Indicates the encoding (and thus presence) of
	         an LSDA pointer in the FDE augmentation.
	         R      Indicates a non-default pointer encoding for
	         FDE code pointers.
	         P      Indicates the presence of an encoding + language
	         personality routine in the CIE augmentation.

	         [This info comes from GCC's dwarf2out.c]
	       */
d1453 2
a1454 3
		  aug_len = read_uleb128 (abfd, &start);
		  aug_data = start;
		  start += aug_len;
a1457 3
	      cie->data = start;
	      cie->data_length = block_end - cie->data;

d1462 2
a1463 2
		      aug_data += sizeof (void *);
		      aug++;
a1465 2
		    cie->addr_encoding = *aug_data++;
		  else if (aug[0] == 'P')
d1467 2
a1468 8
		      CORE_ADDR pers_addr;
		      int pers_addr_enc;

		      pers_addr_enc = *aug_data++;
		      /* We don't need pers_addr value and so we 
		         don't care about it's encoding.  */
		      pers_addr = read_encoded_pointer (abfd, &aug_data,
							pers_addr_enc);
d1470 1
a1470 1
		  else if (aug[0] == 'L' && eh_frame)
d1472 4
a1475 5
		      int lsda_addr_enc;

		      /* Perhaps we should save this to CIE for later use?
		         Do we need it for something in GDB?  */
		      lsda_addr_enc = *aug_data++;
d1478 1
a1478 5
		    warning ("CFI warning: unknown augmentation \"%c\""
			     " in \"%s\" of\n"
			     "\t%s", aug[0], curr_section_name,
			     objfile->name);
		  aug++;
d1481 2
a1482 1
	      last_cie = cie;
a1487 2
	      int dup = 0;
	      CORE_ADDR init_loc;
d1489 2
a1490 11
	      /* We assume that debug_frame is in order 
	         CIE,FDE,CIE,FDE,FDE,...  and thus the CIE for this FDE
	         should be stored in last_cie pointer. If not, we'll 
	         try to find it by the older way.  */
	      if (last_cie)
		cie = last_cie;
	      else
		{
		  warning ("CFI: last_cie == NULL. "
			   "Perhaps a malformed %s section in '%s'...?\n",
			   curr_section_name, objfile->name);
d1492 5
a1496 12
		  cie = cie_chunks;
		  while (cie)
		    {
		      if (cie->objfile == objfile)
			{
			  if (eh_frame &&
			      (cie->offset ==
			       (unit_offset + bytes_read - cie_id)))
			    break;
			  if (!eh_frame && (cie->offset == cie_id))
			    break;
			}
d1498 4
a1501 10
		      cie = cie->next;
		    }
		  if (!cie)
		    error ("CFI: can't find CIE pointer");
		}

	      init_loc = read_encoded_pointer (abfd, &start,
					       cie->addr_encoding);

	      switch (pointer_encoding (cie->addr_encoding))
d1503 4
a1506 9
		case PE_absptr:
		  break;
		case PE_pcrel:
		  /* start-frame_buffer gives offset from 
		     the beginning of actual section.  */
		  init_loc += curr_section_vma + start - frame_buffer;
		  break;
		default:
		  warning ("CFI: Unsupported pointer encoding\n");
d1509 6
a1514 34
	      /* For relocatable objects we must add an offset telling
	         where the section is actually mapped in the memory.  */
	      init_loc += ANOFFSET (objfile->section_offsets,
				    SECT_OFF_TEXT (objfile));

	      /* If we have both .debug_frame and .eh_frame present in 
	         a file, we must eliminate duplicate FDEs. For now we'll 
	         run through all entries in fde_chunks and check it one 
	         by one. Perhaps in the future we can implement a faster 
	         searching algorithm.  */
	      /* eh_frame==2 indicates, that this file has an already 
	         parsed .debug_frame too. When eh_frame==1 it means, that no
	         .debug_frame is present and thus we don't need to check for
	         duplicities. eh_frame==0 means, that we parse .debug_frame
	         and don't need to care about duplicate FDEs, because
	         .debug_frame is parsed first.  */
	      if (eh_frame == 2)
		for (i = 0; eh_frame == 2 && i < fde_chunks.elems; i++)
		  {
		    /* We assume that FDEs in .debug_frame and .eh_frame 
		       have the same order (if they are present, of course).
		       If we find a duplicate entry for one FDE and save
		       it's index to last_dup_fde it's very likely, that 
		       we'll find an entry for the following FDE right after 
		       the previous one. Thus in many cases we'll run this 
		       loop only once.  */
		    last_dup_fde = (last_dup_fde + i) % fde_chunks.elems;
		    if (fde_chunks.array[last_dup_fde]->initial_location
			== init_loc)
		      {
			dup = 1;
			break;
		      }
		  }
d1516 2
a1517 15
	      /* Allocate a new entry only if this FDE isn't a duplicate of
	         something we have already seen.   */
	      if (!dup)
		{
		  fde_chunks_need_space ();
		  fde = fde_unit_alloc ();

		  fde_chunks.array[fde_chunks.elems++] = fde;

		  fde->initial_location = init_loc;
		  fde->address_range = read_encoded_pointer (abfd, &start,
							     cie->
							     addr_encoding);

		  fde->cie_ptr = cie;
d1519 2
a1520 8
		  /* Here we intentionally ignore augmentation data
		     from FDE, because we don't need them.  */
		  if (cie->augmentation[0] == 'z')
		    start += read_uleb128 (abfd, &start);

		  fde->data = start;
		  fde->data_length = block_end - start;
		}
d1528 1
a1528 24

/* We must parse both .debug_frame section and .eh_frame because 
 * not all frames must be present in both of these sections. */
void
dwarf2_build_frame_info (struct objfile *objfile)
{
  int after_debug_frame = 0;

  /* If we have .debug_frame then the parser is called with 
     eh_frame==0 for .debug_frame and eh_frame==2 for .eh_frame, 
     otherwise it's only called once for .eh_frame with argument 
     eh_frame==1.  */

  if (dwarf_frame_offset)
    {
      parse_frame_info (objfile, dwarf_frame_offset,
			dwarf_frame_size, 0 /* = debug_frame */ );
      after_debug_frame = 1;
    }

  if (dwarf_eh_frame_offset)
    parse_frame_info (objfile, dwarf_eh_frame_offset, dwarf_eh_frame_size,
		      1 /* = eh_frame */  + after_debug_frame);
}
a1537 2
  unwind_tmp_obstack_init ();

a1546 1

a1547 1

a1558 2
  unwind_tmp_obstack_init ();

a1605 2
  unwind_tmp_obstack_init ();

d1622 1
a1622 1

a1641 2
  unwind_tmp_obstack_init ();

a1660 1

d1681 1
a1681 1
			CORE_ADDR *addrp,
a1766 2

  unwind_tmp_obstack_init ();
@


1.1.2.6
log
@Zap __func__.
@
text
@d863 1
a863 1
		    "%s(): Internal error: fde->cie_ptr==NULL !", "?func?");
d1364 1
a1364 1
			    "%s: unknown register rule", "?func?");
d1382 1
a1382 1
			"%s: unknown register rule", "?func?");
@


