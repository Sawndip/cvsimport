head	1.6;
access;
symbols
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.8
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.6
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.4
	gdb_5_1-2001-07-29-branchpoint:1.5
	dberlin-typesystem-branch:1.5.0.2
	dberlin-typesystem-branchpoint:1.5
	gdb-post-ptid_t-2001-05-03:1.5
	gdb-pre-ptid_t-2001-05-03:1.5
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb-post-params-removal-2000-06-04:1.1.1.2
	gdb-pre-params-removal-2000-06-04:1.1.1.2
	gdb-post-params-removal-2000-05-28:1.1.1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.6
date	2001.12.01.19.10.00;	author cagney;	state dead;
branches;
next	1.5;

1.5
date	2001.04.03.21.14.36;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.06.08.21.17;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.27.01.25.38;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.27.01.25.38;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.10.43;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Delete tic80 target.
@
text
@/* OBSOLETE /* Target-dependent code for the TI TMS320C80 (MVP) for GDB, the GNU debugger. */
/* OBSOLETE    Copyright 1996, 1997, 1999, 2000, 2001 Free Software Foundation, Inc. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "value.h" */
/* OBSOLETE #include "frame.h" */
/* OBSOLETE #include "inferior.h" */
/* OBSOLETE #include "obstack.h" */
/* OBSOLETE #include "target.h" */
/* OBSOLETE #include "bfd.h" */
/* OBSOLETE #include "gdb_string.h" */
/* OBSOLETE #include "gdbcore.h" */
/* OBSOLETE #include "symfile.h" */
/* OBSOLETE #include "regcache.h" */
/* OBSOLETE  */
/* OBSOLETE /* Function: frame_find_saved_regs */
/* OBSOLETE    Return the frame_saved_regs structure for the frame. */
/* OBSOLETE    Doesn't really work for dummy frames, but it does pass back */
/* OBSOLETE    an empty frame_saved_regs, so I guess that's better than total failure */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE tic80_frame_find_saved_regs (struct frame_info *fi, */
/* OBSOLETE 			     struct frame_saved_regs *regaddr) */
/* OBSOLETE { */
/* OBSOLETE   memcpy (regaddr, &fi->fsr, sizeof (struct frame_saved_regs)); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Function: skip_prologue */
/* OBSOLETE    Find end of function prologue.  */ */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE tic80_skip_prologue (CORE_ADDR pc) */
/* OBSOLETE { */
/* OBSOLETE   CORE_ADDR func_addr, func_end; */
/* OBSOLETE   struct symtab_and_line sal; */
/* OBSOLETE  */
/* OBSOLETE   /* See what the symbol table says */ */
/* OBSOLETE  */
/* OBSOLETE   if (find_pc_partial_function (pc, NULL, &func_addr, &func_end)) */
/* OBSOLETE     { */
/* OBSOLETE       sal = find_pc_line (func_addr, 0); */
/* OBSOLETE  */
/* OBSOLETE       if (sal.line != 0 && sal.end < func_end) */
/* OBSOLETE 	return sal.end; */
/* OBSOLETE       else */
/* OBSOLETE 	/* Either there's no line info, or the line after the prologue is after */
/* OBSOLETE 	   the end of the function.  In this case, there probably isn't a */
/* OBSOLETE 	   prologue.  */ */
/* OBSOLETE 	return pc; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* We can't find the start of this function, so there's nothing we can do. */ */
/* OBSOLETE   return pc; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Function: tic80_scan_prologue */
/* OBSOLETE    This function decodes the target function prologue to determine: */
/* OBSOLETE    1) the size of the stack frame */
/* OBSOLETE    2) which registers are saved on it */
/* OBSOLETE    3) the offsets of saved regs */
/* OBSOLETE    4) the frame size */
/* OBSOLETE    This information is stored in the "extra" fields of the frame_info.  */ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE tic80_scan_prologue (struct frame_info *fi) */
/* OBSOLETE { */
/* OBSOLETE   struct symtab_and_line sal; */
/* OBSOLETE   CORE_ADDR prologue_start, prologue_end, current_pc; */
/* OBSOLETE  */
/* OBSOLETE   /* Assume there is no frame until proven otherwise.  */ */
/* OBSOLETE   fi->framereg = SP_REGNUM; */
/* OBSOLETE   fi->framesize = 0; */
/* OBSOLETE   fi->frameoffset = 0; */
/* OBSOLETE  */
/* OBSOLETE   /* this code essentially duplicates skip_prologue,  */
/* OBSOLETE      but we need the start address below.  */ */
/* OBSOLETE  */
/* OBSOLETE   if (find_pc_partial_function (fi->pc, NULL, &prologue_start, &prologue_end)) */
/* OBSOLETE     { */
/* OBSOLETE       sal = find_pc_line (prologue_start, 0); */
/* OBSOLETE  */
/* OBSOLETE       if (sal.line == 0)	/* no line info, use current PC */ */
/* OBSOLETE 	if (prologue_start != entry_point_address ()) */
/* OBSOLETE 	  prologue_end = fi->pc; */
/* OBSOLETE 	else */
/* OBSOLETE 	  return;		/* _start has no frame or prologue */ */
/* OBSOLETE       else if (sal.end < prologue_end)	/* next line begins after fn end */ */
/* OBSOLETE 	prologue_end = sal.end;	/* (probably means no prologue)  */ */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE /* FIXME */ */
/* OBSOLETE     prologue_end = prologue_start + 40;		/* We're in the boondocks: allow for */ */
/* OBSOLETE   /* 16 pushes, an add, and "mv fp,sp" */ */
/* OBSOLETE  */
/* OBSOLETE   prologue_end = min (prologue_end, fi->pc); */
/* OBSOLETE  */
/* OBSOLETE   /* Now search the prologue looking for instructions that set up the */
/* OBSOLETE      frame pointer, adjust the stack pointer, and save registers.  */ */
/* OBSOLETE  */
/* OBSOLETE   for (current_pc = prologue_start; current_pc < prologue_end; current_pc += 4) */
/* OBSOLETE     { */
/* OBSOLETE       unsigned int insn; */
/* OBSOLETE       int regno; */
/* OBSOLETE       int offset = 0; */
/* OBSOLETE  */
/* OBSOLETE       insn = read_memory_unsigned_integer (current_pc, 4); */
/* OBSOLETE  */
/* OBSOLETE       if ((insn & 0x301000) == 0x301000)	/* Long immediate? */ */
/* OBSOLETE /* FIXME - set offset for long immediate instructions */ */
/* OBSOLETE 	current_pc += 4; */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  offset = insn & 0x7fff;	/* extract 15-bit offset */ */
/* OBSOLETE 	  if (offset & 0x4000)	/* if negative, sign-extend */ */
/* OBSOLETE 	    offset = -(0x8000 - offset); */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       if ((insn & 0x7fd0000) == 0x590000)	/* st.{w,d} reg, xx(r1) */ */
/* OBSOLETE 	{ */
/* OBSOLETE 	  regno = ((insn >> 27) & 0x1f); */
/* OBSOLETE 	  fi->fsr.regs[regno] = offset; */
/* OBSOLETE 	  if (insn & 0x8000)	/* 64-bit store (st.d)? */ */
/* OBSOLETE 	    fi->fsr.regs[regno + 1] = offset + 4; */
/* OBSOLETE 	} */
/* OBSOLETE       else if ((insn & 0xffff8000) == 0x086c8000)	/* addu xx, r1, r1 */ */
/* OBSOLETE 	fi->framesize = -offset; */
/* OBSOLETE       else if ((insn & 0xffff8000) == 0xf06c8000)	/* addu xx, r1, r30 */ */
/* OBSOLETE 	{ */
/* OBSOLETE 	  fi->framereg = FP_REGNUM;	/* fp is now valid */ */
/* OBSOLETE 	  fi->frameoffset = offset; */
/* OBSOLETE 	  break;		/* end of stack adjustments */ */
/* OBSOLETE 	} */
/* OBSOLETE       else if (insn == 0xf03b2001)	/* addu r1, r0, r30 */ */
/* OBSOLETE 	{ */
/* OBSOLETE 	  fi->framereg = FP_REGNUM;	/* fp is now valid */ */
/* OBSOLETE 	  fi->frameoffset = 0; */
/* OBSOLETE 	  break;		/* end of stack adjustments */ */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE /* FIXME - handle long immediate instructions */ */
/* OBSOLETE 	break;			/* anything else isn't prologue */ */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Function: init_extra_frame_info */
/* OBSOLETE    This function actually figures out the frame address for a given pc and */
/* OBSOLETE    sp.  This is tricky on the c80 because we sometimes don't use an explicit */
/* OBSOLETE    frame pointer, and the previous stack pointer isn't necessarily recorded */
/* OBSOLETE    on the stack.  The only reliable way to get this info is to */
/* OBSOLETE    examine the prologue.  */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE tic80_init_extra_frame_info (struct frame_info *fi) */
/* OBSOLETE { */
/* OBSOLETE   int reg; */
/* OBSOLETE  */
/* OBSOLETE   if (fi->next) */
/* OBSOLETE     fi->pc = FRAME_SAVED_PC (fi->next); */
/* OBSOLETE  */
/* OBSOLETE   /* Because zero is a valid register offset relative to SP, we initialize */
/* OBSOLETE      the offsets to -1 to indicate unused entries.  */ */
/* OBSOLETE   for (reg = 0; reg < NUM_REGS; reg++) */
/* OBSOLETE     fi->fsr.regs[reg] = -1; */
/* OBSOLETE  */
/* OBSOLETE   if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame)) */
/* OBSOLETE     { */
/* OBSOLETE       /* We need to setup fi->frame here because run_stack_dummy gets it wrong */
/* OBSOLETE          by assuming it's always FP.  */ */
/* OBSOLETE       fi->frame = generic_read_register_dummy (fi->pc, fi->frame, SP_REGNUM); */
/* OBSOLETE       fi->framesize = 0; */
/* OBSOLETE       fi->frameoffset = 0; */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       tic80_scan_prologue (fi); */
/* OBSOLETE  */
/* OBSOLETE       if (!fi->next)		/* this is the innermost frame? */ */
/* OBSOLETE 	fi->frame = read_register (fi->framereg); */
/* OBSOLETE       else */
/* OBSOLETE 	/* not the innermost frame */ */
/* OBSOLETE 	/* If this function uses FP as the frame register, and the function */
/* OBSOLETE 	   it called saved the FP, get the saved FP.  */ if (fi->framereg == FP_REGNUM && */
/* OBSOLETE 			     fi->next->fsr.regs[FP_REGNUM] != (unsigned) -1) */
/* OBSOLETE 	fi->frame = read_memory_integer (fi->next->fsr.regs[FP_REGNUM], 4); */
/* OBSOLETE  */
/* OBSOLETE       /* Convert SP-relative offsets of saved registers to real addresses.  */ */
/* OBSOLETE       for (reg = 0; reg < NUM_REGS; reg++) */
/* OBSOLETE 	if (fi->fsr.regs[reg] == (unsigned) -1) */
/* OBSOLETE 	  fi->fsr.regs[reg] = 0;	/* unused entry */ */
/* OBSOLETE 	else */
/* OBSOLETE 	  fi->fsr.regs[reg] += fi->frame - fi->frameoffset; */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Function: find_callers_reg */
/* OBSOLETE    Find REGNUM on the stack.  Otherwise, it's in an active register.  One thing */
/* OBSOLETE    we might want to do here is to check REGNUM against the clobber mask, and */
/* OBSOLETE    somehow flag it as invalid if it isn't saved on the stack somewhere.  This */
/* OBSOLETE    would provide a graceful failure mode when trying to get the value of */
/* OBSOLETE    caller-saves registers for an inner frame.  */ */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE tic80_find_callers_reg (struct frame_info *fi, int regnum) */
/* OBSOLETE { */
/* OBSOLETE   for (; fi; fi = fi->next) */
/* OBSOLETE     if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame)) */
/* OBSOLETE       return generic_read_register_dummy (fi->pc, fi->frame, regnum); */
/* OBSOLETE     else if (fi->fsr.regs[regnum] != 0) */
/* OBSOLETE       return read_memory_integer (fi->fsr.regs[regnum], */
/* OBSOLETE 				  REGISTER_RAW_SIZE (regnum)); */
/* OBSOLETE   return read_register (regnum); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Function: frame_chain */
/* OBSOLETE    Given a GDB frame, determine the address of the calling function's frame. */
/* OBSOLETE    This will be used to create a new GDB frame struct, and then */
/* OBSOLETE    INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame. */
/* OBSOLETE    For c80, we save the frame size when we initialize the frame_info.  */ */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE tic80_frame_chain (struct frame_info *fi) */
/* OBSOLETE { */
/* OBSOLETE   CORE_ADDR fn_start, callers_pc, fp; */
/* OBSOLETE  */
/* OBSOLETE   /* is this a dummy frame? */ */
/* OBSOLETE   if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame)) */
/* OBSOLETE     return fi->frame;		/* dummy frame same as caller's frame */ */
/* OBSOLETE  */
/* OBSOLETE   /* is caller-of-this a dummy frame? */ */
/* OBSOLETE   callers_pc = FRAME_SAVED_PC (fi);	/* find out who called us: */ */
/* OBSOLETE   fp = tic80_find_callers_reg (fi, FP_REGNUM); */
/* OBSOLETE   if (PC_IN_CALL_DUMMY (callers_pc, fp, fp)) */
/* OBSOLETE     return fp;			/* dummy frame's frame may bear no relation to ours */ */
/* OBSOLETE  */
/* OBSOLETE   if (find_pc_partial_function (fi->pc, 0, &fn_start, 0)) */
/* OBSOLETE     if (fn_start == entry_point_address ()) */
/* OBSOLETE       return 0;			/* in _start fn, don't chain further */ */
/* OBSOLETE  */
/* OBSOLETE   if (fi->framereg == FP_REGNUM) */
/* OBSOLETE     return tic80_find_callers_reg (fi, FP_REGNUM); */
/* OBSOLETE   else */
/* OBSOLETE     return fi->frame + fi->framesize; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Function: pop_frame */
/* OBSOLETE    Discard from the stack the innermost frame, */
/* OBSOLETE    restoring all saved registers.  */ */
/* OBSOLETE  */
/* OBSOLETE struct frame_info * */
/* OBSOLETE tic80_pop_frame (struct frame_info *frame) */
/* OBSOLETE { */
/* OBSOLETE   int regnum; */
/* OBSOLETE  */
/* OBSOLETE   if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame)) */
/* OBSOLETE     generic_pop_dummy_frame (); */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       for (regnum = 0; regnum < NUM_REGS; regnum++) */
/* OBSOLETE 	if (frame->fsr.regs[regnum] != 0) */
/* OBSOLETE 	  write_register (regnum, */
/* OBSOLETE 			  read_memory_integer (frame->fsr.regs[regnum], 4)); */
/* OBSOLETE  */
/* OBSOLETE       write_register (PC_REGNUM, FRAME_SAVED_PC (frame)); */
/* OBSOLETE       write_register (SP_REGNUM, read_register (FP_REGNUM)); */
/* OBSOLETE #if 0 */
/* OBSOLETE       if (read_register (PSW_REGNUM) & 0x80) */
/* OBSOLETE 	write_register (SPU_REGNUM, read_register (SP_REGNUM)); */
/* OBSOLETE       else */
/* OBSOLETE 	write_register (SPI_REGNUM, read_register (SP_REGNUM)); */
/* OBSOLETE #endif */
/* OBSOLETE     } */
/* OBSOLETE   flush_cached_frames (); */
/* OBSOLETE   return NULL; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Function: frame_saved_pc */
/* OBSOLETE    Find the caller of this frame.  We do this by seeing if LR_REGNUM is saved */
/* OBSOLETE    in the stack anywhere, otherwise we get it from the registers. */ */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE tic80_frame_saved_pc (struct frame_info *fi) */
/* OBSOLETE { */
/* OBSOLETE   if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame)) */
/* OBSOLETE     return generic_read_register_dummy (fi->pc, fi->frame, PC_REGNUM); */
/* OBSOLETE   else */
/* OBSOLETE     return tic80_find_callers_reg (fi, LR_REGNUM); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Function: tic80_push_return_address (pc, sp) */
/* OBSOLETE    Set up the return address for the inferior function call. */
/* OBSOLETE    Necessary for targets that don't actually execute a JSR/BSR instruction  */
/* OBSOLETE    (ie. when using an empty CALL_DUMMY) */ */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE tic80_push_return_address (CORE_ADDR pc, CORE_ADDR sp) */
/* OBSOLETE { */
/* OBSOLETE   write_register (LR_REGNUM, CALL_DUMMY_ADDRESS ()); */
/* OBSOLETE   return sp; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Function: push_arguments */
/* OBSOLETE    Setup the function arguments for calling a function in the inferior. */
/* OBSOLETE  */
/* OBSOLETE    On the TI C80 architecture, there are six register pairs (R2/R3 to R12/13) */
/* OBSOLETE    which are dedicated for passing function arguments.  Up to the first six */
/* OBSOLETE    arguments (depending on size) may go into these registers. */
/* OBSOLETE    The rest go on the stack. */
/* OBSOLETE  */
/* OBSOLETE    Arguments that are smaller than 4 bytes will still take up a whole */
/* OBSOLETE    register or a whole 32-bit word on the stack, and will be */
/* OBSOLETE    right-justified in the register or the stack word.  This includes */
/* OBSOLETE    chars, shorts, and small aggregate types. */
/* OBSOLETE  */
/* OBSOLETE    Arguments that are four bytes or less in size are placed in the */
/* OBSOLETE    even-numbered register of a register pair, and the odd-numbered */
/* OBSOLETE    register is not used. */
/* OBSOLETE  */
/* OBSOLETE    Arguments of 8 bytes size (such as floating point doubles) are placed */
/* OBSOLETE    in a register pair.  The least significant 32-bit word is placed in */
/* OBSOLETE    the even-numbered register, and the most significant word in the */
/* OBSOLETE    odd-numbered register. */
/* OBSOLETE  */
/* OBSOLETE    Aggregate types with sizes between 4 and 8 bytes are passed */
/* OBSOLETE    entirely on the stack, and are left-justified within the */
/* OBSOLETE    double-word (as opposed to aggregates smaller than 4 bytes */
/* OBSOLETE    which are right-justified). */
/* OBSOLETE  */
/* OBSOLETE    Aggregates of greater than 8 bytes are first copied onto the stack,  */
/* OBSOLETE    and then a pointer to the copy is passed in the place of the normal */
/* OBSOLETE    argument (either in a register if available, or on the stack). */
/* OBSOLETE  */
/* OBSOLETE    Functions that must return an aggregate type can return it in the  */
/* OBSOLETE    normal return value registers (R2 and R3) if its size is 8 bytes or */
/* OBSOLETE    less.  For larger return values, the caller must allocate space for  */
/* OBSOLETE    the callee to copy the return value to.  A pointer to this space is */
/* OBSOLETE    passed as an implicit first argument, always in R0. */ */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE tic80_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp, */
/* OBSOLETE 		      unsigned char struct_return, CORE_ADDR struct_addr) */
/* OBSOLETE { */
/* OBSOLETE   int stack_offset, stack_alloc; */
/* OBSOLETE   int argreg; */
/* OBSOLETE   int argnum; */
/* OBSOLETE   struct type *type; */
/* OBSOLETE   CORE_ADDR regval; */
/* OBSOLETE   char *val; */
/* OBSOLETE   char valbuf[4]; */
/* OBSOLETE   int len; */
/* OBSOLETE   int odd_sized_struct; */
/* OBSOLETE   int is_struct; */
/* OBSOLETE  */
/* OBSOLETE   /* first force sp to a 4-byte alignment */ */
/* OBSOLETE   sp = sp & ~3; */
/* OBSOLETE  */
/* OBSOLETE   argreg = ARG0_REGNUM; */
/* OBSOLETE   /* The "struct return pointer" pseudo-argument goes in R0 */ */
/* OBSOLETE   if (struct_return) */
/* OBSOLETE     write_register (argreg++, struct_addr); */
/* OBSOLETE  */
/* OBSOLETE   /* Now make sure there's space on the stack */ */
/* OBSOLETE   for (argnum = 0, stack_alloc = 0; */
/* OBSOLETE        argnum < nargs; argnum++) */
/* OBSOLETE     stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 3) & ~3); */
/* OBSOLETE   sp -= stack_alloc;		/* make room on stack for args */ */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE   /* Now load as many as possible of the first arguments into */
/* OBSOLETE      registers, and push the rest onto the stack.  There are 16 bytes */
/* OBSOLETE      in four registers available.  Loop thru args from first to last.  */ */
/* OBSOLETE  */
/* OBSOLETE   argreg = ARG0_REGNUM; */
/* OBSOLETE   for (argnum = 0, stack_offset = 0; argnum < nargs; argnum++) */
/* OBSOLETE     { */
/* OBSOLETE       type = VALUE_TYPE (args[argnum]); */
/* OBSOLETE       len = TYPE_LENGTH (type); */
/* OBSOLETE       memset (valbuf, 0, sizeof (valbuf)); */
/* OBSOLETE       val = (char *) VALUE_CONTENTS (args[argnum]); */
/* OBSOLETE  */
/* OBSOLETE /* FIXME -- tic80 can take doubleword arguments in register pairs */ */
/* OBSOLETE       is_struct = (type->code == TYPE_CODE_STRUCT); */
/* OBSOLETE       odd_sized_struct = 0; */
/* OBSOLETE  */
/* OBSOLETE       if (!is_struct) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  if (len < 4) */
/* OBSOLETE 	    {			/* value gets right-justified in the register or stack word */ */
/* OBSOLETE 	      memcpy (valbuf + (4 - len), val, len); */
/* OBSOLETE 	      val = valbuf; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  if (len > 4 && (len & 3) != 0) */
/* OBSOLETE 	    odd_sized_struct = 1;	/* such structs go entirely on stack */ */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* Structs are always passed by reference. */ */
/* OBSOLETE 	  write_register (argreg, sp + stack_offset); */
/* OBSOLETE 	  argreg++; */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       while (len > 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  if (is_struct || argreg > ARGLAST_REGNUM || odd_sized_struct) */
/* OBSOLETE 	    {			/* must go on the stack */ */
/* OBSOLETE 	      write_memory (sp + stack_offset, val, 4); */
/* OBSOLETE 	      stack_offset += 4; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  /* NOTE WELL!!!!!  This is not an "else if" clause!!! */
/* OBSOLETE 	     That's because some things get passed on the stack */
/* OBSOLETE 	     AND in the registers!   */ */
/* OBSOLETE 	  if (!is_struct && argreg <= ARGLAST_REGNUM) */
/* OBSOLETE 	    {			/* there's room in a register */ */
/* OBSOLETE 	      regval = extract_address (val, REGISTER_RAW_SIZE (argreg)); */
/* OBSOLETE 	      write_register (argreg, regval); */
/* OBSOLETE 	      argreg += 2;	/* FIXME -- what about doubleword args? */ */
/* OBSOLETE 	    } */
/* OBSOLETE 	  /* Store the value 4 bytes at a time.  This means that things */
/* OBSOLETE 	     larger than 4 bytes may go partly in registers and partly */
/* OBSOLETE 	     on the stack.  */ */
/* OBSOLETE 	  len -= REGISTER_RAW_SIZE (argreg); */
/* OBSOLETE 	  val += REGISTER_RAW_SIZE (argreg); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   return sp; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Function: tic80_write_sp */
/* OBSOLETE    Because SP is really a read-only register that mirrors either SPU or SPI, */
/* OBSOLETE    we must actually write one of those two as well, depending on PSW. */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE tic80_write_sp (CORE_ADDR val) */
/* OBSOLETE { */
/* OBSOLETE #if 0 */
/* OBSOLETE   unsigned long psw = read_register (PSW_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE   if (psw & 0x80)		/* stack mode: user or interrupt */ */
/* OBSOLETE     write_register (SPU_REGNUM, val); */
/* OBSOLETE   else */
/* OBSOLETE     write_register (SPI_REGNUM, val); */
/* OBSOLETE #endif */
/* OBSOLETE   write_register (SP_REGNUM, val); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE _initialize_tic80_tdep (void) */
/* OBSOLETE { */
/* OBSOLETE   tm_print_insn = print_insn_tic80; */
/* OBSOLETE } */
@


1.5
log
@Obsolete tic80.
@
text
@@


1.4
log
@Update/correct copyright notices.
@
text
@d1 468
a468 468
/* Target-dependent code for the TI TMS320C80 (MVP) for GDB, the GNU debugger.
   Copyright 1996, 1997, 1999, 2000, 2001 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "value.h"
#include "frame.h"
#include "inferior.h"
#include "obstack.h"
#include "target.h"
#include "bfd.h"
#include "gdb_string.h"
#include "gdbcore.h"
#include "symfile.h"
#include "regcache.h"

/* Function: frame_find_saved_regs
   Return the frame_saved_regs structure for the frame.
   Doesn't really work for dummy frames, but it does pass back
   an empty frame_saved_regs, so I guess that's better than total failure */

void
tic80_frame_find_saved_regs (struct frame_info *fi,
			     struct frame_saved_regs *regaddr)
{
  memcpy (regaddr, &fi->fsr, sizeof (struct frame_saved_regs));
}

/* Function: skip_prologue
   Find end of function prologue.  */

CORE_ADDR
tic80_skip_prologue (CORE_ADDR pc)
{
  CORE_ADDR func_addr, func_end;
  struct symtab_and_line sal;

  /* See what the symbol table says */

  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    {
      sal = find_pc_line (func_addr, 0);

      if (sal.line != 0 && sal.end < func_end)
	return sal.end;
      else
	/* Either there's no line info, or the line after the prologue is after
	   the end of the function.  In this case, there probably isn't a
	   prologue.  */
	return pc;
    }

  /* We can't find the start of this function, so there's nothing we can do. */
  return pc;
}

/* Function: tic80_scan_prologue
   This function decodes the target function prologue to determine:
   1) the size of the stack frame
   2) which registers are saved on it
   3) the offsets of saved regs
   4) the frame size
   This information is stored in the "extra" fields of the frame_info.  */

static void
tic80_scan_prologue (struct frame_info *fi)
{
  struct symtab_and_line sal;
  CORE_ADDR prologue_start, prologue_end, current_pc;

  /* Assume there is no frame until proven otherwise.  */
  fi->framereg = SP_REGNUM;
  fi->framesize = 0;
  fi->frameoffset = 0;

  /* this code essentially duplicates skip_prologue, 
     but we need the start address below.  */

  if (find_pc_partial_function (fi->pc, NULL, &prologue_start, &prologue_end))
    {
      sal = find_pc_line (prologue_start, 0);

      if (sal.line == 0)	/* no line info, use current PC */
	if (prologue_start != entry_point_address ())
	  prologue_end = fi->pc;
	else
	  return;		/* _start has no frame or prologue */
      else if (sal.end < prologue_end)	/* next line begins after fn end */
	prologue_end = sal.end;	/* (probably means no prologue)  */
    }
  else
/* FIXME */
    prologue_end = prologue_start + 40;		/* We're in the boondocks: allow for */
  /* 16 pushes, an add, and "mv fp,sp" */

  prologue_end = min (prologue_end, fi->pc);

  /* Now search the prologue looking for instructions that set up the
     frame pointer, adjust the stack pointer, and save registers.  */

  for (current_pc = prologue_start; current_pc < prologue_end; current_pc += 4)
    {
      unsigned int insn;
      int regno;
      int offset = 0;

      insn = read_memory_unsigned_integer (current_pc, 4);

      if ((insn & 0x301000) == 0x301000)	/* Long immediate? */
/* FIXME - set offset for long immediate instructions */
	current_pc += 4;
      else
	{
	  offset = insn & 0x7fff;	/* extract 15-bit offset */
	  if (offset & 0x4000)	/* if negative, sign-extend */
	    offset = -(0x8000 - offset);
	}

      if ((insn & 0x7fd0000) == 0x590000)	/* st.{w,d} reg, xx(r1) */
	{
	  regno = ((insn >> 27) & 0x1f);
	  fi->fsr.regs[regno] = offset;
	  if (insn & 0x8000)	/* 64-bit store (st.d)? */
	    fi->fsr.regs[regno + 1] = offset + 4;
	}
      else if ((insn & 0xffff8000) == 0x086c8000)	/* addu xx, r1, r1 */
	fi->framesize = -offset;
      else if ((insn & 0xffff8000) == 0xf06c8000)	/* addu xx, r1, r30 */
	{
	  fi->framereg = FP_REGNUM;	/* fp is now valid */
	  fi->frameoffset = offset;
	  break;		/* end of stack adjustments */
	}
      else if (insn == 0xf03b2001)	/* addu r1, r0, r30 */
	{
	  fi->framereg = FP_REGNUM;	/* fp is now valid */
	  fi->frameoffset = 0;
	  break;		/* end of stack adjustments */
	}
      else
/* FIXME - handle long immediate instructions */
	break;			/* anything else isn't prologue */
    }
}

/* Function: init_extra_frame_info
   This function actually figures out the frame address for a given pc and
   sp.  This is tricky on the c80 because we sometimes don't use an explicit
   frame pointer, and the previous stack pointer isn't necessarily recorded
   on the stack.  The only reliable way to get this info is to
   examine the prologue.  */

void
tic80_init_extra_frame_info (struct frame_info *fi)
{
  int reg;

  if (fi->next)
    fi->pc = FRAME_SAVED_PC (fi->next);

  /* Because zero is a valid register offset relative to SP, we initialize
     the offsets to -1 to indicate unused entries.  */
  for (reg = 0; reg < NUM_REGS; reg++)
    fi->fsr.regs[reg] = -1;

  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
    {
      /* We need to setup fi->frame here because run_stack_dummy gets it wrong
         by assuming it's always FP.  */
      fi->frame = generic_read_register_dummy (fi->pc, fi->frame, SP_REGNUM);
      fi->framesize = 0;
      fi->frameoffset = 0;
      return;
    }
  else
    {
      tic80_scan_prologue (fi);

      if (!fi->next)		/* this is the innermost frame? */
	fi->frame = read_register (fi->framereg);
      else
	/* not the innermost frame */
	/* If this function uses FP as the frame register, and the function
	   it called saved the FP, get the saved FP.  */ if (fi->framereg == FP_REGNUM &&
			     fi->next->fsr.regs[FP_REGNUM] != (unsigned) -1)
	fi->frame = read_memory_integer (fi->next->fsr.regs[FP_REGNUM], 4);

      /* Convert SP-relative offsets of saved registers to real addresses.  */
      for (reg = 0; reg < NUM_REGS; reg++)
	if (fi->fsr.regs[reg] == (unsigned) -1)
	  fi->fsr.regs[reg] = 0;	/* unused entry */
	else
	  fi->fsr.regs[reg] += fi->frame - fi->frameoffset;
    }
}

/* Function: find_callers_reg
   Find REGNUM on the stack.  Otherwise, it's in an active register.  One thing
   we might want to do here is to check REGNUM against the clobber mask, and
   somehow flag it as invalid if it isn't saved on the stack somewhere.  This
   would provide a graceful failure mode when trying to get the value of
   caller-saves registers for an inner frame.  */

CORE_ADDR
tic80_find_callers_reg (struct frame_info *fi, int regnum)
{
  for (; fi; fi = fi->next)
    if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
      return generic_read_register_dummy (fi->pc, fi->frame, regnum);
    else if (fi->fsr.regs[regnum] != 0)
      return read_memory_integer (fi->fsr.regs[regnum],
				  REGISTER_RAW_SIZE (regnum));
  return read_register (regnum);
}

/* Function: frame_chain
   Given a GDB frame, determine the address of the calling function's frame.
   This will be used to create a new GDB frame struct, and then
   INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.
   For c80, we save the frame size when we initialize the frame_info.  */

CORE_ADDR
tic80_frame_chain (struct frame_info *fi)
{
  CORE_ADDR fn_start, callers_pc, fp;

  /* is this a dummy frame? */
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
    return fi->frame;		/* dummy frame same as caller's frame */

  /* is caller-of-this a dummy frame? */
  callers_pc = FRAME_SAVED_PC (fi);	/* find out who called us: */
  fp = tic80_find_callers_reg (fi, FP_REGNUM);
  if (PC_IN_CALL_DUMMY (callers_pc, fp, fp))
    return fp;			/* dummy frame's frame may bear no relation to ours */

  if (find_pc_partial_function (fi->pc, 0, &fn_start, 0))
    if (fn_start == entry_point_address ())
      return 0;			/* in _start fn, don't chain further */

  if (fi->framereg == FP_REGNUM)
    return tic80_find_callers_reg (fi, FP_REGNUM);
  else
    return fi->frame + fi->framesize;
}

/* Function: pop_frame
   Discard from the stack the innermost frame,
   restoring all saved registers.  */

struct frame_info *
tic80_pop_frame (struct frame_info *frame)
{
  int regnum;

  if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
    generic_pop_dummy_frame ();
  else
    {
      for (regnum = 0; regnum < NUM_REGS; regnum++)
	if (frame->fsr.regs[regnum] != 0)
	  write_register (regnum,
			  read_memory_integer (frame->fsr.regs[regnum], 4));

      write_register (PC_REGNUM, FRAME_SAVED_PC (frame));
      write_register (SP_REGNUM, read_register (FP_REGNUM));
#if 0
      if (read_register (PSW_REGNUM) & 0x80)
	write_register (SPU_REGNUM, read_register (SP_REGNUM));
      else
	write_register (SPI_REGNUM, read_register (SP_REGNUM));
#endif
    }
  flush_cached_frames ();
  return NULL;
}

/* Function: frame_saved_pc
   Find the caller of this frame.  We do this by seeing if LR_REGNUM is saved
   in the stack anywhere, otherwise we get it from the registers. */

CORE_ADDR
tic80_frame_saved_pc (struct frame_info *fi)
{
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
    return generic_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
  else
    return tic80_find_callers_reg (fi, LR_REGNUM);
}

/* Function: tic80_push_return_address (pc, sp)
   Set up the return address for the inferior function call.
   Necessary for targets that don't actually execute a JSR/BSR instruction 
   (ie. when using an empty CALL_DUMMY) */

CORE_ADDR
tic80_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
{
  write_register (LR_REGNUM, CALL_DUMMY_ADDRESS ());
  return sp;
}


/* Function: push_arguments
   Setup the function arguments for calling a function in the inferior.

   On the TI C80 architecture, there are six register pairs (R2/R3 to R12/13)
   which are dedicated for passing function arguments.  Up to the first six
   arguments (depending on size) may go into these registers.
   The rest go on the stack.

   Arguments that are smaller than 4 bytes will still take up a whole
   register or a whole 32-bit word on the stack, and will be
   right-justified in the register or the stack word.  This includes
   chars, shorts, and small aggregate types.

   Arguments that are four bytes or less in size are placed in the
   even-numbered register of a register pair, and the odd-numbered
   register is not used.

   Arguments of 8 bytes size (such as floating point doubles) are placed
   in a register pair.  The least significant 32-bit word is placed in
   the even-numbered register, and the most significant word in the
   odd-numbered register.

   Aggregate types with sizes between 4 and 8 bytes are passed
   entirely on the stack, and are left-justified within the
   double-word (as opposed to aggregates smaller than 4 bytes
   which are right-justified).

   Aggregates of greater than 8 bytes are first copied onto the stack, 
   and then a pointer to the copy is passed in the place of the normal
   argument (either in a register if available, or on the stack).

   Functions that must return an aggregate type can return it in the 
   normal return value registers (R2 and R3) if its size is 8 bytes or
   less.  For larger return values, the caller must allocate space for 
   the callee to copy the return value to.  A pointer to this space is
   passed as an implicit first argument, always in R0. */

CORE_ADDR
tic80_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
		      unsigned char struct_return, CORE_ADDR struct_addr)
{
  int stack_offset, stack_alloc;
  int argreg;
  int argnum;
  struct type *type;
  CORE_ADDR regval;
  char *val;
  char valbuf[4];
  int len;
  int odd_sized_struct;
  int is_struct;

  /* first force sp to a 4-byte alignment */
  sp = sp & ~3;

  argreg = ARG0_REGNUM;
  /* The "struct return pointer" pseudo-argument goes in R0 */
  if (struct_return)
    write_register (argreg++, struct_addr);

  /* Now make sure there's space on the stack */
  for (argnum = 0, stack_alloc = 0;
       argnum < nargs; argnum++)
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 3) & ~3);
  sp -= stack_alloc;		/* make room on stack for args */


  /* Now load as many as possible of the first arguments into
     registers, and push the rest onto the stack.  There are 16 bytes
     in four registers available.  Loop thru args from first to last.  */

  argreg = ARG0_REGNUM;
  for (argnum = 0, stack_offset = 0; argnum < nargs; argnum++)
    {
      type = VALUE_TYPE (args[argnum]);
      len = TYPE_LENGTH (type);
      memset (valbuf, 0, sizeof (valbuf));
      val = (char *) VALUE_CONTENTS (args[argnum]);

/* FIXME -- tic80 can take doubleword arguments in register pairs */
      is_struct = (type->code == TYPE_CODE_STRUCT);
      odd_sized_struct = 0;

      if (!is_struct)
	{
	  if (len < 4)
	    {			/* value gets right-justified in the register or stack word */
	      memcpy (valbuf + (4 - len), val, len);
	      val = valbuf;
	    }
	  if (len > 4 && (len & 3) != 0)
	    odd_sized_struct = 1;	/* such structs go entirely on stack */
	}
      else
	{
	  /* Structs are always passed by reference. */
	  write_register (argreg, sp + stack_offset);
	  argreg++;
	}

      while (len > 0)
	{
	  if (is_struct || argreg > ARGLAST_REGNUM || odd_sized_struct)
	    {			/* must go on the stack */
	      write_memory (sp + stack_offset, val, 4);
	      stack_offset += 4;
	    }
	  /* NOTE WELL!!!!!  This is not an "else if" clause!!!
	     That's because some things get passed on the stack
	     AND in the registers!   */
	  if (!is_struct && argreg <= ARGLAST_REGNUM)
	    {			/* there's room in a register */
	      regval = extract_address (val, REGISTER_RAW_SIZE (argreg));
	      write_register (argreg, regval);
	      argreg += 2;	/* FIXME -- what about doubleword args? */
	    }
	  /* Store the value 4 bytes at a time.  This means that things
	     larger than 4 bytes may go partly in registers and partly
	     on the stack.  */
	  len -= REGISTER_RAW_SIZE (argreg);
	  val += REGISTER_RAW_SIZE (argreg);
	}
    }
  return sp;
}

/* Function: tic80_write_sp
   Because SP is really a read-only register that mirrors either SPU or SPI,
   we must actually write one of those two as well, depending on PSW. */

void
tic80_write_sp (CORE_ADDR val)
{
#if 0
  unsigned long psw = read_register (PSW_REGNUM);

  if (psw & 0x80)		/* stack mode: user or interrupt */
    write_register (SPU_REGNUM, val);
  else
    write_register (SPI_REGNUM, val);
#endif
  write_register (SP_REGNUM, val);
}

void
_initialize_tic80_tdep (void)
{
  tm_print_insn = print_insn_tic80;
}
@


1.3
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 1
a2 1
   Copyright 1996, 2001 Free Software Foundation, Inc.
@


1.2
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright 1996, Free Software Foundation, Inc.
d31 1
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d37 3
a39 4
void 
tic80_frame_find_saved_regs (fi, regaddr)
     struct frame_info *fi;
     struct frame_saved_regs *regaddr;
d48 1
a48 2
tic80_skip_prologue (pc)
     CORE_ADDR pc;
d74 4
a77 4
     1) the size of the stack frame
     2) which registers are saved on it
     3) the offsets of saved regs
     4) the frame size
d81 1
a81 2
tic80_scan_prologue (fi)
     struct frame_info *fi;
d98 1
a98 1
      if (sal.line == 0)		/* no line info, use current PC */
d102 1
a102 1
	  return;			/* _start has no frame or prologue */
d104 1
a104 1
	prologue_end = sal.end;		/* (probably means no prologue)  */
d108 2
a109 2
    prologue_end = prologue_start + 40; /* We're in the boondocks: allow for */
					/* 16 pushes, an add, and "mv fp,sp" */
d129 2
a130 2
	  offset = insn & 0x7fff;		/* extract 15-bit offset */
	  if (offset & 0x4000)			/* if negative, sign-extend */
d138 2
a139 2
	  if (insn & 0x8000)			/* 64-bit store (st.d)? */
	    fi->fsr.regs[regno+1] = offset+4;
d141 1
a141 1
      else if ((insn & 0xffff8000) == 0x086c8000)   /* addu xx, r1, r1 */
d143 1
a143 1
      else if ((insn & 0xffff8000) == 0xf06c8000)  /* addu xx, r1, r30 */
d145 1
a145 1
	  fi->framereg = FP_REGNUM;		/* fp is now valid */
d147 1
a147 1
	  break;				/* end of stack adjustments */
d149 1
a149 1
      else if (insn == 0xf03b2001)		/* addu r1, r0, r30 */
d151 1
a151 1
	  fi->framereg = FP_REGNUM;		/* fp is now valid */
d153 1
a153 1
	  break;				/* end of stack adjustments */
d157 1
a157 1
	break;				/* anything else isn't prologue */
d169 1
a169 2
tic80_init_extra_frame_info (fi)
     struct frame_info *fi;
d184 1
a184 1
	 by assuming it's always FP.  */
d190 1
a190 1
  else 
d194 1
a194 1
      if (!fi->next)			/* this is the innermost frame? */
d196 2
a197 1
      else			 	/* not the innermost frame */
d199 3
a201 4
	   it called saved the FP, get the saved FP.  */
	if (fi->framereg == FP_REGNUM &&
	    fi->next->fsr.regs[FP_REGNUM] != (unsigned) -1)
	  fi->frame = read_memory_integer (fi->next->fsr.regs[FP_REGNUM], 4);
d206 3
a208 3
	    fi->fsr.regs[reg] = 0;	/* unused entry */
	  else
	    fi->fsr.regs[reg] += fi->frame - fi->frameoffset;
d220 1
a220 3
tic80_find_callers_reg (fi, regnum)
     struct frame_info *fi;
     int regnum;
d226 2
a227 2
      return read_memory_integer (fi->fsr.regs[regnum], 
				  REGISTER_RAW_SIZE(regnum));
d238 1
a238 2
tic80_frame_chain (fi)
     struct frame_info *fi;
d243 2
a244 2
  if (PC_IN_CALL_DUMMY(fi->pc, fi->frame, fi->frame))
    return fi->frame;	/* dummy frame same as caller's frame */
d247 1
a247 1
  callers_pc = FRAME_SAVED_PC(fi);  /* find out who called us: */
d249 2
a250 2
  if (PC_IN_CALL_DUMMY(callers_pc, fp, fp))	
    return fp;		/* dummy frame's frame may bear no relation to ours */
d254 1
a254 1
      return 0;		/* in _start fn, don't chain further */
d267 1
a267 2
tic80_pop_frame (frame)
     struct frame_info *frame;
d277 1
a277 1
	  write_register (regnum, 
d298 1
a298 2
tic80_frame_saved_pc (fi)
     struct frame_info *fi;
d300 1
a300 1
  if (PC_IN_CALL_DUMMY(fi->pc, fi->frame, fi->frame))
d312 1
a312 3
tic80_push_return_address (pc, sp)
     CORE_ADDR pc;
     CORE_ADDR sp;
d331 1
a331 1
 
d357 2
a358 6
tic80_push_arguments (nargs, args, sp, struct_return, struct_addr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     unsigned char struct_return;
     CORE_ADDR struct_addr;
d374 1
a374 1
  argreg = ARG0_REGNUM;  
d377 2
a378 2
      write_register (argreg++, struct_addr);
 
d382 4
a385 4
    stack_alloc += ((TYPE_LENGTH(VALUE_TYPE(args[argnum])) + 3) & ~3);
  sp -= stack_alloc;    /* make room on stack for args */
 
 
d389 1
a389 1
 
d394 1
a394 1
      len  = TYPE_LENGTH (type);
d397 1
a397 1
 
d402 1
a402 1
      if (! is_struct)
d405 1
a405 1
	    { /* value gets right-justified in the register or stack word */
d410 1
a410 1
	    odd_sized_struct = 1;     /* such structs go entirely on stack */
d416 1
a416 1
	  argreg ++;
d420 13
a432 13
        {
          if (is_struct || argreg > ARGLAST_REGNUM || odd_sized_struct)
            {				/* must go on the stack */
              write_memory (sp + stack_offset, val, 4);
              stack_offset += 4;
            }
          /* NOTE WELL!!!!!  This is not an "else if" clause!!!
             That's because some things get passed on the stack
             AND in the registers!   */
          if (!is_struct && argreg <= ARGLAST_REGNUM)
            {				/* there's room in a register */
              regval = extract_address (val, REGISTER_RAW_SIZE(argreg));
              write_register (argreg, regval);
d434 7
a440 7
            }
          /* Store the value 4 bytes at a time.  This means that things
             larger than 4 bytes may go partly in registers and partly
             on the stack.  */
          len -= REGISTER_RAW_SIZE(argreg);
          val += REGISTER_RAW_SIZE(argreg);
        }
d450 1
a450 2
tic80_write_sp (val)
     CORE_ADDR val;
d455 1
a455 1
  if (psw & 0x80)	/* stack mode: user or interrupt */
d464 1
a464 1
_initialize_tic80_tdep ()
a467 1

@


1.1.1.1
log
@import gdb-19990422 snapshot
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d36 1
a36 1
void
d75 4
a78 4
   1) the size of the stack frame
   2) which registers are saved on it
   3) the offsets of saved regs
   4) the frame size
d100 1
a100 1
      if (sal.line == 0)	/* no line info, use current PC */
d104 1
a104 1
	  return;		/* _start has no frame or prologue */
d106 1
a106 1
	prologue_end = sal.end;	/* (probably means no prologue)  */
d110 2
a111 2
    prologue_end = prologue_start + 40;		/* We're in the boondocks: allow for */
  /* 16 pushes, an add, and "mv fp,sp" */
d131 2
a132 2
	  offset = insn & 0x7fff;	/* extract 15-bit offset */
	  if (offset & 0x4000)	/* if negative, sign-extend */
d140 2
a141 2
	  if (insn & 0x8000)	/* 64-bit store (st.d)? */
	    fi->fsr.regs[regno + 1] = offset + 4;
d143 1
a143 1
      else if ((insn & 0xffff8000) == 0x086c8000)	/* addu xx, r1, r1 */
d145 1
a145 1
      else if ((insn & 0xffff8000) == 0xf06c8000)	/* addu xx, r1, r30 */
d147 1
a147 1
	  fi->framereg = FP_REGNUM;	/* fp is now valid */
d149 1
a149 1
	  break;		/* end of stack adjustments */
d151 1
a151 1
      else if (insn == 0xf03b2001)	/* addu r1, r0, r30 */
d153 1
a153 1
	  fi->framereg = FP_REGNUM;	/* fp is now valid */
d155 1
a155 1
	  break;		/* end of stack adjustments */
d159 1
a159 1
	break;			/* anything else isn't prologue */
d187 1
a187 1
         by assuming it's always FP.  */
d193 1
a193 1
  else
d197 1
a197 1
      if (!fi->next)		/* this is the innermost frame? */
d199 1
a199 2
      else
	/* not the innermost frame */
d201 4
a204 3
	   it called saved the FP, get the saved FP.  */ if (fi->framereg == FP_REGNUM &&
			     fi->next->fsr.regs[FP_REGNUM] != (unsigned) -1)
	fi->frame = read_memory_integer (fi->next->fsr.regs[FP_REGNUM], 4);
d209 3
a211 3
	  fi->fsr.regs[reg] = 0;	/* unused entry */
	else
	  fi->fsr.regs[reg] += fi->frame - fi->frameoffset;
d231 2
a232 2
      return read_memory_integer (fi->fsr.regs[regnum],
				  REGISTER_RAW_SIZE (regnum));
d249 2
a250 2
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
    return fi->frame;		/* dummy frame same as caller's frame */
d253 1
a253 1
  callers_pc = FRAME_SAVED_PC (fi);	/* find out who called us: */
d255 2
a256 2
  if (PC_IN_CALL_DUMMY (callers_pc, fp, fp))
    return fp;			/* dummy frame's frame may bear no relation to ours */
d260 1
a260 1
      return 0;			/* in _start fn, don't chain further */
d284 1
a284 1
	  write_register (regnum,
d308 1
a308 1
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d341 1
a341 1

d388 1
a388 1
  argreg = ARG0_REGNUM;
d391 2
a392 2
    write_register (argreg++, struct_addr);

d396 4
a399 4
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 3) & ~3);
  sp -= stack_alloc;		/* make room on stack for args */


d403 1
a403 1

d408 1
a408 1
      len = TYPE_LENGTH (type);
d411 1
a411 1

d416 1
a416 1
      if (!is_struct)
d419 1
a419 1
	    {			/* value gets right-justified in the register or stack word */
d424 1
a424 1
	    odd_sized_struct = 1;	/* such structs go entirely on stack */
d430 1
a430 1
	  argreg++;
d434 13
a446 13
	{
	  if (is_struct || argreg > ARGLAST_REGNUM || odd_sized_struct)
	    {			/* must go on the stack */
	      write_memory (sp + stack_offset, val, 4);
	      stack_offset += 4;
	    }
	  /* NOTE WELL!!!!!  This is not an "else if" clause!!!
	     That's because some things get passed on the stack
	     AND in the registers!   */
	  if (!is_struct && argreg <= ARGLAST_REGNUM)
	    {			/* there's room in a register */
	      regval = extract_address (val, REGISTER_RAW_SIZE (argreg));
	      write_register (argreg, regval);
d448 7
a454 7
	    }
	  /* Store the value 4 bytes at a time.  This means that things
	     larger than 4 bytes may go partly in registers and partly
	     on the stack.  */
	  len -= REGISTER_RAW_SIZE (argreg);
	  val += REGISTER_RAW_SIZE (argreg);
	}
d470 1
a470 1
  if (psw & 0x80)		/* stack mode: user or interrupt */
d483 1
@

