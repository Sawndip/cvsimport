head	1.2;
access;
symbols
	insight-precleanup-2001-01-01:1.1.1.4
	gdb-post-protoization-2000-07-29:1.1.1.4
	gdb-pre-protoization-2000-07-29:1.1.1.4
	gdb-premipsmulti-2000-06-06-branch:1.1.1.4.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.4
	gdb-post-params-removal-2000-06-04:1.1.1.4
	gdb-pre-params-removal-2000-06-04:1.1.1.4
	gdb-post-params-removal-2000-05-28:1.1.1.4
	gdb-pre-params-removal-2000-05-28:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2001.02.08.06.30.24;	author cagney;	state dead;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.17.22.37;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.08.50;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.02.02.00.21.09;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove configurations marked as obsolete in 5.0.
@
text
@/* Pyramid target-dependent code for GDB.
   Copyright (C) 1988, 1989, 1991 Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "defs.h"

/*** Prettier register printing. ***/

/* Print registers in the same format as pyramid's dbx, adb, sdb.  */
pyr_print_registers(reg_buf, regnum)
    long *reg_buf[];
{
  register int regno;
  int usp, ksp;
  struct user u;

  for (regno = 0; regno < 16; regno++) {
    printf_unfiltered/*_filtered*/ ("%6.6s: %8x  %6.6s: %8x  %6s: %8x  %6s: %8x\n",
		     REGISTER_NAME (regno), reg_buf[regno],
		     REGISTER_NAME (regno+16), reg_buf[regno+16],
		     REGISTER_NAME (regno+32), reg_buf[regno+32],
		     REGISTER_NAME (regno+48), reg_buf[regno+48]);
  }
  usp = ptrace (3, inferior_pid,
		(PTRACE_ARG3_TYPE) ((char *)&u.u_pcb.pcb_usp) -
		((char *)&u), 0);
  ksp = ptrace (3, inferior_pid,
		(PTRACE_ARG3_TYPE) ((char *)&u.u_pcb.pcb_ksp) -
		((char *)&u), 0);
  printf_unfiltered/*_filtered*/ ("\n%6.6s: %8x  %6.6s: %8x (%08x) %6.6s %8x\n",
		   REGISTER_NAME (CSP_REGNUM),reg_buf[CSP_REGNUM],
		   REGISTER_NAME (KSP_REGNUM), reg_buf[KSP_REGNUM], ksp,
		   "usp", usp);
}

/* Print the register regnum, or all registers if regnum is -1.
   fpregs is currently ignored.  */

pyr_do_registers_info (regnum, fpregs)
    int regnum;
    int fpregs;
{
  /* On a pyr, we know a virtual register can always fit in an long.
     Here (and elsewhere) we take advantage of that.  Yuk.  */
  long raw_regs[MAX_REGISTER_RAW_SIZE*NUM_REGS];
  register int i;
  
  for (i = 0 ; i < 64 ; i++) {
    read_relative_register_raw_bytes(i, raw_regs+i);
  }
  if (regnum == -1)
    pyr_print_registers (raw_regs, regnum);
  else
    for (i = 0; i < NUM_REGS; i++)
      if (i == regnum) {
	long val = raw_regs[i];
	
	fputs_filtered (REGISTER_NAME (i), gdb_stdout);
	printf_filtered(":");
	print_spaces_filtered (6 - strlen (REGISTER_NAME (i)), gdb_stdout);
	if (val == 0)
	  printf_filtered ("0");
	else
	  printf_filtered ("%s  %d", local_hex_string_custom(val,"08"), val);
	printf_filtered("\n");
      }
}

/*** Debugging editions of various macros from m-pyr.h ****/

CORE_ADDR frame_locals_address (frame)
    struct frame_info *frame;
{
  register int addr = find_saved_register (frame,CFP_REGNUM);
  register int result = read_memory_integer (addr, 4);
#ifdef PYRAMID_CONTROL_FRAME_DEBUGGING
  fprintf_unfiltered (gdb_stderr,
	   "\t[[..frame_locals:%8x, %s= %x @@%x fcfp= %x foo= %x\n\t gr13=%x pr13=%x tr13=%x @@%x]]\n",
	   frame->frame,
	   REGISTER_NAME (CFP_REGNUM),
	   result, addr,
	   frame->frame_cfp, (CFP_REGNUM),


	   read_register(13), read_register(29), read_register(61),
	   find_saved_register(frame, 61));
#endif /* PYRAMID_CONTROL_FRAME_DEBUGGING */

  /* FIXME: I thought read_register (CFP_REGNUM) should be the right answer;
     or at least CFP_REGNUM relative to FRAME (ie, result).
     There seems to be a bug in the way the innermost frame is set up.  */

    return ((frame->next) ? result: frame->frame_cfp);
}

CORE_ADDR frame_args_addr (frame)
    struct frame_info *frame;
{
  register int addr = find_saved_register (frame,CFP_REGNUM);
  register int result = read_memory_integer (addr, 4);

#ifdef PYRAMID_CONTROL_FRAME_DEBUGGING
  fprintf_unfiltered (gdb_stderr,
	   "\t[[..frame_args:%8x, %s= %x @@%x fcfp= %x r_r= %x\n\t gr13=%x pr13=%x tr13=%x @@%x]]\n",
	   frame->frame,
	   REGISTER_NAME (CFP_REGNUM),
	   result, addr,
	   frame->frame_cfp, read_register(CFP_REGNUM),

	   read_register(13), read_register(29), read_register(61),
	   find_saved_register(frame, 61));
#endif /*  PYRAMID_CONTROL_FRAME_DEBUGGING */

  /* FIXME: I thought read_register (CFP_REGNUM) should be the right answer;
     or at least CFP_REGNUM relative to FRAME (ie, result).
     There seems to be a bug in the way the innermost frame is set up.  */
    return ((frame->next) ? result: frame->frame_cfp);
}

#include "symtab.h"
#include "opcode/pyr.h"
#include "gdbcore.h"


/*  A couple of functions used for debugging frame-handling on
    Pyramids. (The Pyramid-dependent handling of register values for
    windowed registers is known to be buggy.)

    When debugging, these functions can supplant the normal definitions of some
    of the macros in tm-pyramid.h  The quantity of information produced
    when these functions are used makes the gdb  unusable as a
    debugger for user programs.  */
    
extern unsigned pyr_saved_pc(), pyr_frame_chain();

CORE_ADDR pyr_frame_chain(frame)
    CORE_ADDR frame;
{
    int foo=frame - CONTROL_STACK_FRAME_SIZE;
    /* printf_unfiltered ("...following chain from %x: got %x\n", frame, foo);*/
    return foo;
}

CORE_ADDR pyr_saved_pc(frame)
    CORE_ADDR frame;
{
    int foo=0;
    foo = read_memory_integer (((CORE_ADDR)(frame))+60, 4);
    printf_unfiltered ("..reading pc from frame 0x%0x+%d regs: got %0x\n",
	    frame, 60/4, foo);
    return foo;
}

/* Pyramid instructions are never longer than this many bytes.  */
#define MAXLEN 24

/* Number of elements in the opcode table.  */
/*const*/ static int nopcodes = (sizeof (pyr_opcodes) / sizeof( pyr_opcodes[0]));
#define NOPCODES (nopcodes)

/* Let's be byte-independent so we can use this as a cross-assembler.  */

#define NEXTLONG(p)  \
  (p += 4, (((((p[-4] << 8) + p[-3]) << 8) + p[-2]) << 8) + p[-1])

/* Print one instruction at address MEMADDR in debugged memory,
   on STREAM.  Returns length of the instruction, in bytes.  */

int
pyr_print_insn (memaddr, stream)
     CORE_ADDR memaddr;
     GDB_FILE *stream;
{
  unsigned char buffer[MAXLEN];
  register int i, nargs, insn_size =4;
  register unsigned char *p;
  register char *d;
  register int insn_opcode, operand_mode;
  register int index_multiplier, index_reg_regno, op_1_regno, op_2_regno ;
  long insn;			/* first word of the insn, not broken down. */
  pyr_insn_format insn_decode;	/* the same, broken out into op{code,erands} */
  long extra_1, extra_2;

  read_memory (memaddr, buffer, MAXLEN);
  insn_decode = *((pyr_insn_format *) buffer);
  insn = * ((int *) buffer);
  insn_opcode = insn_decode.operator;
  operand_mode = insn_decode.mode;
  index_multiplier = insn_decode.index_scale;
  index_reg_regno = insn_decode.index_reg;
  op_1_regno = insn_decode.operand_1;
  op_2_regno = insn_decode.operand_2;
  
  
  if (*((int *)buffer) == 0x0) {
    /* "halt" looks just like an invalid "jump" to the insn decoder,
       so is dealt with as a special case */
    fprintf_unfiltered (stream, "halt");
    return (4);
  }

  for (i = 0; i < NOPCODES; i++)
	  if (pyr_opcodes[i].datum.code == insn_opcode)
		  break;

  if (i == NOPCODES)
	  /* FIXME: Handle unrecognised instructions better.  */
	  fprintf_unfiltered (stream, "???\t#%08x\t(op=%x mode =%x)",
		   insn, insn_decode.operator, insn_decode.mode);
  else
    {
      /* Print the mnemonic for the instruction.  Pyramid insn operands
         are so regular that we can deal with almost all of them
         separately.
	 Unconditional branches are an exception: they are encoded as
	 conditional branches (branch if false condition, I think)
	 with no condition specified. The average user will not be
	 aware of this. To maintain their illusion that an
	 unconditional branch insn exists, we will have to FIXME to
	 treat the insn mnemnonic of all branch instructions here as a
	 special case: check the operands of branch insn and print an
	 appropriate mnemonic. */ 

      fprintf_unfiltered (stream, "%s\t", pyr_opcodes[i].name);

    /* Print the operands of the insn (as specified in
       insn.operand_mode). 
       Branch operands of branches are a special case: they are a word
       offset, not a byte offset. */
  
    if (insn_decode.operator == 0x01 || insn_decode.operator == 0x02) {
      register int bit_codes=(insn >> 16)&0xf;
      register int i;
      register int displacement = (insn & 0x0000ffff) << 2;

      static char cc_bit_names[] = "cvzn";	/* z,n,c,v: strange order? */

      /* Is bfc and no bits specified an unconditional branch?*/
      for (i=0;i<4;i++) {
	if ((bit_codes) & 0x1)
		fputc_unfiltered (cc_bit_names[i], stream);
	bit_codes >>= 1;
      }

      fprintf_unfiltered (stream, ",%0x",
	       displacement + memaddr);
      return (insn_size);
    }

      switch (operand_mode) {
      case 0:
	fprintf_unfiltered (stream, "%s,%s",
		 REGISTER_NAME (op_1_regno),
		 REGISTER_NAME (op_2_regno));
	break;
	    
      case 1:
	fprintf_unfiltered (stream, " 0x%0x,%s",
		 op_1_regno,
		 REGISTER_NAME (op_2_regno));
	break;
	
      case 2:
	read_memory (memaddr+4, buffer, MAXLEN);
	insn_size += 4;
	extra_1 = * ((int *) buffer);
	fprintf_unfiltered (stream, " $0x%0x,%s",
		 extra_1,
		 REGISTER_NAME (op_2_regno));
	break;
      case 3:
	fprintf_unfiltered (stream, " (%s),%s",
		 REGISTER_NAME (op_1_regno),
		 REGISTER_NAME (op_2_regno));
	break;
	
      case 4:
	read_memory (memaddr+4, buffer, MAXLEN);
	insn_size += 4;
	extra_1 = * ((int *) buffer);
	fprintf_unfiltered (stream, " 0x%0x(%s),%s",
		 extra_1,
		 REGISTER_NAME (op_1_regno),
		 REGISTER_NAME (op_2_regno));
	break;
	
	/* S1 destination mode */
      case 5:
	fprintf_unfiltered (stream,
		 ((index_reg_regno) ? "%s,(%s)[%s*%1d]" : "%s,(%s)"),
		 REGISTER_NAME (op_1_regno),
		 REGISTER_NAME (op_2_regno),
		 REGISTER_NAME (index_reg_regno),
		 index_multiplier);
	break;
	
      case 6:
	fprintf_unfiltered (stream,
		 ((index_reg_regno) ? " $%#0x,(%s)[%s*%1d]"
		  : " $%#0x,(%s)"),
		 op_1_regno,
		 REGISTER_NAME (op_2_regno),
		 REGISTER_NAME (index_reg_regno),
		 index_multiplier);
	break;
	
      case 7:
	read_memory (memaddr+4, buffer, MAXLEN);
	insn_size += 4;
	extra_1 = * ((int *) buffer);
	fprintf_unfiltered (stream,
		 ((index_reg_regno) ? " $%#0x,(%s)[%s*%1d]"
		  : " $%#0x,(%s)"),
		 extra_1,
		 REGISTER_NAME (op_2_regno),
		 REGISTER_NAME (index_reg_regno),
		 index_multiplier);
	break;
	
      case 8:
	fprintf_unfiltered (stream,
		 ((index_reg_regno) ? " (%s),(%s)[%s*%1d]" : " (%s),(%s)"),
		 REGISTER_NAME (op_1_regno),
		 REGISTER_NAME (op_2_regno),
		 REGISTER_NAME (index_reg_regno),
		 index_multiplier);
	break;
	
      case 9:
	read_memory (memaddr+4, buffer, MAXLEN);
	insn_size += 4;
	extra_1 = * ((int *) buffer);
	fprintf_unfiltered (stream,
		 ((index_reg_regno)
		  ? "%#0x(%s),(%s)[%s*%1d]"
		  : "%#0x(%s),(%s)"),
		 extra_1,
		 REGISTER_NAME (op_1_regno),
		 REGISTER_NAME (op_2_regno),
		 REGISTER_NAME (index_reg_regno),
		 index_multiplier);
	break;
	
	/* S2 destination mode */
      case 10:
	read_memory (memaddr+4, buffer, MAXLEN);
	insn_size += 4;
	extra_1 = * ((int *) buffer);
	fprintf_unfiltered (stream,
		 ((index_reg_regno) ? "%s,%#0x(%s)[%s*%1d]" : "%s,%#0x(%s)"),
		 REGISTER_NAME (op_1_regno),
		 extra_1,
		 REGISTER_NAME (op_2_regno),
		 REGISTER_NAME (index_reg_regno),
		 index_multiplier);
	break;
      case 11:
	read_memory (memaddr+4, buffer, MAXLEN);
	insn_size += 4;
	extra_1 = * ((int *) buffer);
	fprintf_unfiltered (stream,
		 ((index_reg_regno) ?
		  " $%#0x,%#0x(%s)[%s*%1d]" : " $%#0x,%#0x(%s)"),
		 op_1_regno,
		 extra_1,
		 REGISTER_NAME (op_2_regno),
		 REGISTER_NAME (index_reg_regno),
		 index_multiplier);
	break;
      case 12:
	read_memory (memaddr+4, buffer, MAXLEN);
	insn_size += 4;
	extra_1 = * ((int *) buffer);
	read_memory (memaddr+8, buffer, MAXLEN);
	insn_size += 4;
	extra_2 = * ((int *) buffer);
	fprintf_unfiltered (stream,
		 ((index_reg_regno) ?
		  " $%#0x,%#0x(%s)[%s*%1d]" : " $%#0x,%#0x(%s)"),
		 extra_1,
		 extra_2,
		 REGISTER_NAME (op_2_regno),
		 REGISTER_NAME (index_reg_regno),
		 index_multiplier);
	break;
	
      case 13:
	read_memory (memaddr+4, buffer, MAXLEN);
	insn_size += 4;
	extra_1 = * ((int *) buffer);
	fprintf_unfiltered (stream,
		 ((index_reg_regno)
		  ? " (%s),%#0x(%s)[%s*%1d]" 
		  : " (%s),%#0x(%s)"),
		 REGISTER_NAME (op_1_regno),
		 extra_1,
		 REGISTER_NAME (op_2_regno),
		 REGISTER_NAME (index_reg_regno),
		 index_multiplier);
	break;
      case 14:
	read_memory (memaddr+4, buffer, MAXLEN);
	insn_size += 4;
	extra_1 = * ((int *) buffer);
	read_memory (memaddr+8, buffer, MAXLEN);
	insn_size += 4;
	extra_2 = * ((int *) buffer);
	fprintf_unfiltered (stream,
		 ((index_reg_regno) ? "%#0x(%s),%#0x(%s)[%s*%1d]"
		  : "%#0x(%s),%#0x(%s) "),
		 extra_1,
		 REGISTER_NAME (op_1_regno),
		 extra_2,
		 REGISTER_NAME (op_2_regno),
		 REGISTER_NAME (index_reg_regno),
		 index_multiplier);
	break;
	
      default:
	fprintf_unfiltered (stream,
		 ((index_reg_regno) ? "%s,%s [%s*%1d]" : "%s,%s"),
		 REGISTER_NAME (op_1_regno),
		 REGISTER_NAME (op_2_regno),
		 REGISTER_NAME (index_reg_regno),
		 index_multiplier);
	fprintf_unfiltered (stream,
		 "\t\t# unknown mode in %08x",
		 insn);
	break;
      } /* switch */
    }
  
  {
    return insn_size;
  }
  abort ();
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 pre reformat
@
text
@d1 452
a452 452
/* OBSOLETE /* Pyramid target-dependent code for GDB. */
/* OBSOLETE    Copyright (C) 1988, 1989, 1991 Free Software Foundation, Inc. */
/* OBSOLETE  */
/* OBSOLETE This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE This program is free software; you can redistribute it and/or modify */
/* OBSOLETE it under the terms of the GNU General Public License as published by */
/* OBSOLETE the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE This program is distributed in the hope that it will be useful, */
/* OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE You should have received a copy of the GNU General Public License */
/* OBSOLETE along with this program; if not, write to the Free Software */
/* OBSOLETE Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE  */
/* OBSOLETE /*** Prettier register printing. ***x/ */
/* OBSOLETE  */
/* OBSOLETE /* Print registers in the same format as pyramid's dbx, adb, sdb.  *x/ */
/* OBSOLETE pyr_print_registers(reg_buf, regnum) */
/* OBSOLETE     long *reg_buf[]; */
/* OBSOLETE { */
/* OBSOLETE   register int regno; */
/* OBSOLETE   int usp, ksp; */
/* OBSOLETE   struct user u; */
/* OBSOLETE  */
/* OBSOLETE   for (regno = 0; regno < 16; regno++) { */
/* OBSOLETE     printf_unfiltered/*_filtered*x/ ("%6.6s: %8x  %6.6s: %8x  %6s: %8x  %6s: %8x\n", */
/* OBSOLETE 		     REGISTER_NAME (regno), reg_buf[regno], */
/* OBSOLETE 		     REGISTER_NAME (regno+16), reg_buf[regno+16], */
/* OBSOLETE 		     REGISTER_NAME (regno+32), reg_buf[regno+32], */
/* OBSOLETE 		     REGISTER_NAME (regno+48), reg_buf[regno+48]); */
/* OBSOLETE   } */
/* OBSOLETE   usp = ptrace (3, inferior_pid, */
/* OBSOLETE 		(PTRACE_ARG3_TYPE) ((char *)&u.u_pcb.pcb_usp) - */
/* OBSOLETE 		((char *)&u), 0); */
/* OBSOLETE   ksp = ptrace (3, inferior_pid, */
/* OBSOLETE 		(PTRACE_ARG3_TYPE) ((char *)&u.u_pcb.pcb_ksp) - */
/* OBSOLETE 		((char *)&u), 0); */
/* OBSOLETE   printf_unfiltered/*_filtered*x/ ("\n%6.6s: %8x  %6.6s: %8x (%08x) %6.6s %8x\n", */
/* OBSOLETE 		   REGISTER_NAME (CSP_REGNUM),reg_buf[CSP_REGNUM], */
/* OBSOLETE 		   REGISTER_NAME (KSP_REGNUM), reg_buf[KSP_REGNUM], ksp, */
/* OBSOLETE 		   "usp", usp); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Print the register regnum, or all registers if regnum is -1. */
/* OBSOLETE    fpregs is currently ignored.  *x/ */
/* OBSOLETE  */
/* OBSOLETE pyr_do_registers_info (regnum, fpregs) */
/* OBSOLETE     int regnum; */
/* OBSOLETE     int fpregs; */
/* OBSOLETE { */
/* OBSOLETE   /* On a pyr, we know a virtual register can always fit in an long. */
/* OBSOLETE      Here (and elsewhere) we take advantage of that.  Yuk.  *x/ */
/* OBSOLETE   long raw_regs[MAX_REGISTER_RAW_SIZE*NUM_REGS]; */
/* OBSOLETE   register int i; */
/* OBSOLETE    */
/* OBSOLETE   for (i = 0 ; i < 64 ; i++) { */
/* OBSOLETE     read_relative_register_raw_bytes(i, raw_regs+i); */
/* OBSOLETE   } */
/* OBSOLETE   if (regnum == -1) */
/* OBSOLETE     pyr_print_registers (raw_regs, regnum); */
/* OBSOLETE   else */
/* OBSOLETE     for (i = 0; i < NUM_REGS; i++) */
/* OBSOLETE       if (i == regnum) { */
/* OBSOLETE 	long val = raw_regs[i]; */
/* OBSOLETE 	 */
/* OBSOLETE 	fputs_filtered (REGISTER_NAME (i), gdb_stdout); */
/* OBSOLETE 	printf_filtered(":"); */
/* OBSOLETE 	print_spaces_filtered (6 - strlen (REGISTER_NAME (i)), gdb_stdout); */
/* OBSOLETE 	if (val == 0) */
/* OBSOLETE 	  printf_filtered ("0"); */
/* OBSOLETE 	else */
/* OBSOLETE 	  printf_filtered ("%s  %d", local_hex_string_custom(val,"08"), val); */
/* OBSOLETE 	printf_filtered("\n"); */
/* OBSOLETE       } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /*** Debugging editions of various macros from m-pyr.h ****x/ */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR frame_locals_address (frame) */
/* OBSOLETE     struct frame_info *frame; */
/* OBSOLETE { */
/* OBSOLETE   register int addr = find_saved_register (frame,CFP_REGNUM); */
/* OBSOLETE   register int result = read_memory_integer (addr, 4); */
/* OBSOLETE #ifdef PYRAMID_CONTROL_FRAME_DEBUGGING */
/* OBSOLETE   fprintf_unfiltered (gdb_stderr, */
/* OBSOLETE 	   "\t[[..frame_locals:%8x, %s= %x @@%x fcfp= %x foo= %x\n\t gr13=%x pr13=%x tr13=%x @@%x]]\n", */
/* OBSOLETE 	   frame->frame, */
/* OBSOLETE 	   REGISTER_NAME (CFP_REGNUM), */
/* OBSOLETE 	   result, addr, */
/* OBSOLETE 	   frame->frame_cfp, (CFP_REGNUM), */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE 	   read_register(13), read_register(29), read_register(61), */
/* OBSOLETE 	   find_saved_register(frame, 61)); */
/* OBSOLETE #endif /* PYRAMID_CONTROL_FRAME_DEBUGGING *x/ */
/* OBSOLETE  */
/* OBSOLETE   /* FIXME: I thought read_register (CFP_REGNUM) should be the right answer; */
/* OBSOLETE      or at least CFP_REGNUM relative to FRAME (ie, result). */
/* OBSOLETE      There seems to be a bug in the way the innermost frame is set up.  *x/ */
/* OBSOLETE  */
/* OBSOLETE     return ((frame->next) ? result: frame->frame_cfp); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR frame_args_addr (frame) */
/* OBSOLETE     struct frame_info *frame; */
/* OBSOLETE { */
/* OBSOLETE   register int addr = find_saved_register (frame,CFP_REGNUM); */
/* OBSOLETE   register int result = read_memory_integer (addr, 4); */
/* OBSOLETE  */
/* OBSOLETE #ifdef PYRAMID_CONTROL_FRAME_DEBUGGING */
/* OBSOLETE   fprintf_unfiltered (gdb_stderr, */
/* OBSOLETE 	   "\t[[..frame_args:%8x, %s= %x @@%x fcfp= %x r_r= %x\n\t gr13=%x pr13=%x tr13=%x @@%x]]\n", */
/* OBSOLETE 	   frame->frame, */
/* OBSOLETE 	   REGISTER_NAME (CFP_REGNUM), */
/* OBSOLETE 	   result, addr, */
/* OBSOLETE 	   frame->frame_cfp, read_register(CFP_REGNUM), */
/* OBSOLETE  */
/* OBSOLETE 	   read_register(13), read_register(29), read_register(61), */
/* OBSOLETE 	   find_saved_register(frame, 61)); */
/* OBSOLETE #endif /*  PYRAMID_CONTROL_FRAME_DEBUGGING *x/ */
/* OBSOLETE  */
/* OBSOLETE   /* FIXME: I thought read_register (CFP_REGNUM) should be the right answer; */
/* OBSOLETE      or at least CFP_REGNUM relative to FRAME (ie, result). */
/* OBSOLETE      There seems to be a bug in the way the innermost frame is set up.  *x/ */
/* OBSOLETE     return ((frame->next) ? result: frame->frame_cfp); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #include "symtab.h" */
/* OBSOLETE #include "opcode/pyr.h" */
/* OBSOLETE #include "gdbcore.h" */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /*  A couple of functions used for debugging frame-handling on */
/* OBSOLETE     Pyramids. (The Pyramid-dependent handling of register values for */
/* OBSOLETE     windowed registers is known to be buggy.) */
/* OBSOLETE  */
/* OBSOLETE     When debugging, these functions can supplant the normal definitions of some */
/* OBSOLETE     of the macros in tm-pyramid.h  The quantity of information produced */
/* OBSOLETE     when these functions are used makes the gdb  unusable as a */
/* OBSOLETE     debugger for user programs.  *x/ */
/* OBSOLETE      */
/* OBSOLETE extern unsigned pyr_saved_pc(), pyr_frame_chain(); */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR pyr_frame_chain(frame) */
/* OBSOLETE     CORE_ADDR frame; */
/* OBSOLETE { */
/* OBSOLETE     int foo=frame - CONTROL_STACK_FRAME_SIZE; */
/* OBSOLETE     /* printf_unfiltered ("...following chain from %x: got %x\n", frame, foo);*x/ */
/* OBSOLETE     return foo; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR pyr_saved_pc(frame) */
/* OBSOLETE     CORE_ADDR frame; */
/* OBSOLETE { */
/* OBSOLETE     int foo=0; */
/* OBSOLETE     foo = read_memory_integer (((CORE_ADDR)(frame))+60, 4); */
/* OBSOLETE     printf_unfiltered ("..reading pc from frame 0x%0x+%d regs: got %0x\n", */
/* OBSOLETE 	    frame, 60/4, foo); */
/* OBSOLETE     return foo; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Pyramid instructions are never longer than this many bytes.  *x/ */
/* OBSOLETE #define MAXLEN 24 */
/* OBSOLETE  */
/* OBSOLETE /* Number of elements in the opcode table.  *x/ */
/* OBSOLETE /*const*x/ static int nopcodes = (sizeof (pyr_opcodes) / sizeof( pyr_opcodes[0])); */
/* OBSOLETE #define NOPCODES (nopcodes) */
/* OBSOLETE  */
/* OBSOLETE /* Let's be byte-independent so we can use this as a cross-assembler.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define NEXTLONG(p)  \ */
/* OBSOLETE   (p += 4, (((((p[-4] << 8) + p[-3]) << 8) + p[-2]) << 8) + p[-1]) */
/* OBSOLETE  */
/* OBSOLETE /* Print one instruction at address MEMADDR in debugged memory, */
/* OBSOLETE    on STREAM.  Returns length of the instruction, in bytes.  *x/ */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE pyr_print_insn (memaddr, stream) */
/* OBSOLETE      CORE_ADDR memaddr; */
/* OBSOLETE      GDB_FILE *stream; */
/* OBSOLETE { */
/* OBSOLETE   unsigned char buffer[MAXLEN]; */
/* OBSOLETE   register int i, nargs, insn_size =4; */
/* OBSOLETE   register unsigned char *p; */
/* OBSOLETE   register char *d; */
/* OBSOLETE   register int insn_opcode, operand_mode; */
/* OBSOLETE   register int index_multiplier, index_reg_regno, op_1_regno, op_2_regno ; */
/* OBSOLETE   long insn;			/* first word of the insn, not broken down. *x/ */
/* OBSOLETE   pyr_insn_format insn_decode;	/* the same, broken out into op{code,erands} *x/ */
/* OBSOLETE   long extra_1, extra_2; */
/* OBSOLETE  */
/* OBSOLETE   read_memory (memaddr, buffer, MAXLEN); */
/* OBSOLETE   insn_decode = *((pyr_insn_format *) buffer); */
/* OBSOLETE   insn = * ((int *) buffer); */
/* OBSOLETE   insn_opcode = insn_decode.operator; */
/* OBSOLETE   operand_mode = insn_decode.mode; */
/* OBSOLETE   index_multiplier = insn_decode.index_scale; */
/* OBSOLETE   index_reg_regno = insn_decode.index_reg; */
/* OBSOLETE   op_1_regno = insn_decode.operand_1; */
/* OBSOLETE   op_2_regno = insn_decode.operand_2; */
/* OBSOLETE    */
/* OBSOLETE    */
/* OBSOLETE   if (*((int *)buffer) == 0x0) { */
/* OBSOLETE     /* "halt" looks just like an invalid "jump" to the insn decoder, */
/* OBSOLETE        so is dealt with as a special case *x/ */
/* OBSOLETE     fprintf_unfiltered (stream, "halt"); */
/* OBSOLETE     return (4); */
/* OBSOLETE   } */
/* OBSOLETE  */
/* OBSOLETE   for (i = 0; i < NOPCODES; i++) */
/* OBSOLETE 	  if (pyr_opcodes[i].datum.code == insn_opcode) */
/* OBSOLETE 		  break; */
/* OBSOLETE  */
/* OBSOLETE   if (i == NOPCODES) */
/* OBSOLETE 	  /* FIXME: Handle unrecognised instructions better.  *x/ */
/* OBSOLETE 	  fprintf_unfiltered (stream, "???\t#%08x\t(op=%x mode =%x)", */
/* OBSOLETE 		   insn, insn_decode.operator, insn_decode.mode); */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       /* Print the mnemonic for the instruction.  Pyramid insn operands */
/* OBSOLETE          are so regular that we can deal with almost all of them */
/* OBSOLETE          separately. */
/* OBSOLETE 	 Unconditional branches are an exception: they are encoded as */
/* OBSOLETE 	 conditional branches (branch if false condition, I think) */
/* OBSOLETE 	 with no condition specified. The average user will not be */
/* OBSOLETE 	 aware of this. To maintain their illusion that an */
/* OBSOLETE 	 unconditional branch insn exists, we will have to FIXME to */
/* OBSOLETE 	 treat the insn mnemnonic of all branch instructions here as a */
/* OBSOLETE 	 special case: check the operands of branch insn and print an */
/* OBSOLETE 	 appropriate mnemonic. *x/  */
/* OBSOLETE  */
/* OBSOLETE       fprintf_unfiltered (stream, "%s\t", pyr_opcodes[i].name); */
/* OBSOLETE  */
/* OBSOLETE     /* Print the operands of the insn (as specified in */
/* OBSOLETE        insn.operand_mode).  */
/* OBSOLETE        Branch operands of branches are a special case: they are a word */
/* OBSOLETE        offset, not a byte offset. *x/ */
/* OBSOLETE    */
/* OBSOLETE     if (insn_decode.operator == 0x01 || insn_decode.operator == 0x02) { */
/* OBSOLETE       register int bit_codes=(insn >> 16)&0xf; */
/* OBSOLETE       register int i; */
/* OBSOLETE       register int displacement = (insn & 0x0000ffff) << 2; */
/* OBSOLETE  */
/* OBSOLETE       static char cc_bit_names[] = "cvzn";	/* z,n,c,v: strange order? *x/ */
/* OBSOLETE  */
/* OBSOLETE       /* Is bfc and no bits specified an unconditional branch?*x/ */
/* OBSOLETE       for (i=0;i<4;i++) { */
/* OBSOLETE 	if ((bit_codes) & 0x1) */
/* OBSOLETE 		fputc_unfiltered (cc_bit_names[i], stream); */
/* OBSOLETE 	bit_codes >>= 1; */
/* OBSOLETE       } */
/* OBSOLETE  */
/* OBSOLETE       fprintf_unfiltered (stream, ",%0x", */
/* OBSOLETE 	       displacement + memaddr); */
/* OBSOLETE       return (insn_size); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE       switch (operand_mode) { */
/* OBSOLETE       case 0: */
/* OBSOLETE 	fprintf_unfiltered (stream, "%s,%s", */
/* OBSOLETE 		 REGISTER_NAME (op_1_regno), */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno)); */
/* OBSOLETE 	break; */
/* OBSOLETE 	     */
/* OBSOLETE       case 1: */
/* OBSOLETE 	fprintf_unfiltered (stream, " 0x%0x,%s", */
/* OBSOLETE 		 op_1_regno, */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno)); */
/* OBSOLETE 	break; */
/* OBSOLETE 	 */
/* OBSOLETE       case 2: */
/* OBSOLETE 	read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE 	insn_size += 4; */
/* OBSOLETE 	extra_1 = * ((int *) buffer); */
/* OBSOLETE 	fprintf_unfiltered (stream, " $0x%0x,%s", */
/* OBSOLETE 		 extra_1, */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno)); */
/* OBSOLETE 	break; */
/* OBSOLETE       case 3: */
/* OBSOLETE 	fprintf_unfiltered (stream, " (%s),%s", */
/* OBSOLETE 		 REGISTER_NAME (op_1_regno), */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno)); */
/* OBSOLETE 	break; */
/* OBSOLETE 	 */
/* OBSOLETE       case 4: */
/* OBSOLETE 	read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE 	insn_size += 4; */
/* OBSOLETE 	extra_1 = * ((int *) buffer); */
/* OBSOLETE 	fprintf_unfiltered (stream, " 0x%0x(%s),%s", */
/* OBSOLETE 		 extra_1, */
/* OBSOLETE 		 REGISTER_NAME (op_1_regno), */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno)); */
/* OBSOLETE 	break; */
/* OBSOLETE 	 */
/* OBSOLETE 	/* S1 destination mode *x/ */
/* OBSOLETE       case 5: */
/* OBSOLETE 	fprintf_unfiltered (stream, */
/* OBSOLETE 		 ((index_reg_regno) ? "%s,(%s)[%s*%1d]" : "%s,(%s)"), */
/* OBSOLETE 		 REGISTER_NAME (op_1_regno), */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno), */
/* OBSOLETE 		 REGISTER_NAME (index_reg_regno), */
/* OBSOLETE 		 index_multiplier); */
/* OBSOLETE 	break; */
/* OBSOLETE 	 */
/* OBSOLETE       case 6: */
/* OBSOLETE 	fprintf_unfiltered (stream, */
/* OBSOLETE 		 ((index_reg_regno) ? " $%#0x,(%s)[%s*%1d]" */
/* OBSOLETE 		  : " $%#0x,(%s)"), */
/* OBSOLETE 		 op_1_regno, */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno), */
/* OBSOLETE 		 REGISTER_NAME (index_reg_regno), */
/* OBSOLETE 		 index_multiplier); */
/* OBSOLETE 	break; */
/* OBSOLETE 	 */
/* OBSOLETE       case 7: */
/* OBSOLETE 	read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE 	insn_size += 4; */
/* OBSOLETE 	extra_1 = * ((int *) buffer); */
/* OBSOLETE 	fprintf_unfiltered (stream, */
/* OBSOLETE 		 ((index_reg_regno) ? " $%#0x,(%s)[%s*%1d]" */
/* OBSOLETE 		  : " $%#0x,(%s)"), */
/* OBSOLETE 		 extra_1, */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno), */
/* OBSOLETE 		 REGISTER_NAME (index_reg_regno), */
/* OBSOLETE 		 index_multiplier); */
/* OBSOLETE 	break; */
/* OBSOLETE 	 */
/* OBSOLETE       case 8: */
/* OBSOLETE 	fprintf_unfiltered (stream, */
/* OBSOLETE 		 ((index_reg_regno) ? " (%s),(%s)[%s*%1d]" : " (%s),(%s)"), */
/* OBSOLETE 		 REGISTER_NAME (op_1_regno), */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno), */
/* OBSOLETE 		 REGISTER_NAME (index_reg_regno), */
/* OBSOLETE 		 index_multiplier); */
/* OBSOLETE 	break; */
/* OBSOLETE 	 */
/* OBSOLETE       case 9: */
/* OBSOLETE 	read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE 	insn_size += 4; */
/* OBSOLETE 	extra_1 = * ((int *) buffer); */
/* OBSOLETE 	fprintf_unfiltered (stream, */
/* OBSOLETE 		 ((index_reg_regno) */
/* OBSOLETE 		  ? "%#0x(%s),(%s)[%s*%1d]" */
/* OBSOLETE 		  : "%#0x(%s),(%s)"), */
/* OBSOLETE 		 extra_1, */
/* OBSOLETE 		 REGISTER_NAME (op_1_regno), */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno), */
/* OBSOLETE 		 REGISTER_NAME (index_reg_regno), */
/* OBSOLETE 		 index_multiplier); */
/* OBSOLETE 	break; */
/* OBSOLETE 	 */
/* OBSOLETE 	/* S2 destination mode *x/ */
/* OBSOLETE       case 10: */
/* OBSOLETE 	read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE 	insn_size += 4; */
/* OBSOLETE 	extra_1 = * ((int *) buffer); */
/* OBSOLETE 	fprintf_unfiltered (stream, */
/* OBSOLETE 		 ((index_reg_regno) ? "%s,%#0x(%s)[%s*%1d]" : "%s,%#0x(%s)"), */
/* OBSOLETE 		 REGISTER_NAME (op_1_regno), */
/* OBSOLETE 		 extra_1, */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno), */
/* OBSOLETE 		 REGISTER_NAME (index_reg_regno), */
/* OBSOLETE 		 index_multiplier); */
/* OBSOLETE 	break; */
/* OBSOLETE       case 11: */
/* OBSOLETE 	read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE 	insn_size += 4; */
/* OBSOLETE 	extra_1 = * ((int *) buffer); */
/* OBSOLETE 	fprintf_unfiltered (stream, */
/* OBSOLETE 		 ((index_reg_regno) ? */
/* OBSOLETE 		  " $%#0x,%#0x(%s)[%s*%1d]" : " $%#0x,%#0x(%s)"), */
/* OBSOLETE 		 op_1_regno, */
/* OBSOLETE 		 extra_1, */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno), */
/* OBSOLETE 		 REGISTER_NAME (index_reg_regno), */
/* OBSOLETE 		 index_multiplier); */
/* OBSOLETE 	break; */
/* OBSOLETE       case 12: */
/* OBSOLETE 	read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE 	insn_size += 4; */
/* OBSOLETE 	extra_1 = * ((int *) buffer); */
/* OBSOLETE 	read_memory (memaddr+8, buffer, MAXLEN); */
/* OBSOLETE 	insn_size += 4; */
/* OBSOLETE 	extra_2 = * ((int *) buffer); */
/* OBSOLETE 	fprintf_unfiltered (stream, */
/* OBSOLETE 		 ((index_reg_regno) ? */
/* OBSOLETE 		  " $%#0x,%#0x(%s)[%s*%1d]" : " $%#0x,%#0x(%s)"), */
/* OBSOLETE 		 extra_1, */
/* OBSOLETE 		 extra_2, */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno), */
/* OBSOLETE 		 REGISTER_NAME (index_reg_regno), */
/* OBSOLETE 		 index_multiplier); */
/* OBSOLETE 	break; */
/* OBSOLETE 	 */
/* OBSOLETE       case 13: */
/* OBSOLETE 	read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE 	insn_size += 4; */
/* OBSOLETE 	extra_1 = * ((int *) buffer); */
/* OBSOLETE 	fprintf_unfiltered (stream, */
/* OBSOLETE 		 ((index_reg_regno) */
/* OBSOLETE 		  ? " (%s),%#0x(%s)[%s*%1d]"  */
/* OBSOLETE 		  : " (%s),%#0x(%s)"), */
/* OBSOLETE 		 REGISTER_NAME (op_1_regno), */
/* OBSOLETE 		 extra_1, */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno), */
/* OBSOLETE 		 REGISTER_NAME (index_reg_regno), */
/* OBSOLETE 		 index_multiplier); */
/* OBSOLETE 	break; */
/* OBSOLETE       case 14: */
/* OBSOLETE 	read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE 	insn_size += 4; */
/* OBSOLETE 	extra_1 = * ((int *) buffer); */
/* OBSOLETE 	read_memory (memaddr+8, buffer, MAXLEN); */
/* OBSOLETE 	insn_size += 4; */
/* OBSOLETE 	extra_2 = * ((int *) buffer); */
/* OBSOLETE 	fprintf_unfiltered (stream, */
/* OBSOLETE 		 ((index_reg_regno) ? "%#0x(%s),%#0x(%s)[%s*%1d]" */
/* OBSOLETE 		  : "%#0x(%s),%#0x(%s) "), */
/* OBSOLETE 		 extra_1, */
/* OBSOLETE 		 REGISTER_NAME (op_1_regno), */
/* OBSOLETE 		 extra_2, */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno), */
/* OBSOLETE 		 REGISTER_NAME (index_reg_regno), */
/* OBSOLETE 		 index_multiplier); */
/* OBSOLETE 	break; */
/* OBSOLETE 	 */
/* OBSOLETE       default: */
/* OBSOLETE 	fprintf_unfiltered (stream, */
/* OBSOLETE 		 ((index_reg_regno) ? "%s,%s [%s*%1d]" : "%s,%s"), */
/* OBSOLETE 		 REGISTER_NAME (op_1_regno), */
/* OBSOLETE 		 REGISTER_NAME (op_2_regno), */
/* OBSOLETE 		 REGISTER_NAME (index_reg_regno), */
/* OBSOLETE 		 index_multiplier); */
/* OBSOLETE 	fprintf_unfiltered (stream, */
/* OBSOLETE 		 "\t\t# unknown mode in %08x", */
/* OBSOLETE 		 insn); */
/* OBSOLETE 	break; */
/* OBSOLETE       } /* switch *x/ */
/* OBSOLETE     } */
/* OBSOLETE    */
/* OBSOLETE   { */
/* OBSOLETE     return insn_size; */
/* OBSOLETE   } */
/* OBSOLETE   abort (); */
/* OBSOLETE } */
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d34 4
a37 4
/* OBSOLETE                  REGISTER_NAME (regno), reg_buf[regno], */
/* OBSOLETE                  REGISTER_NAME (regno+16), reg_buf[regno+16], */
/* OBSOLETE                  REGISTER_NAME (regno+32), reg_buf[regno+32], */
/* OBSOLETE                  REGISTER_NAME (regno+48), reg_buf[regno+48]); */
d40 2
a41 2
/* OBSOLETE             (PTRACE_ARG3_TYPE) ((char *)&u.u_pcb.pcb_usp) - */
/* OBSOLETE             ((char *)&u), 0); */
d43 2
a44 2
/* OBSOLETE             (PTRACE_ARG3_TYPE) ((char *)&u.u_pcb.pcb_ksp) - */
/* OBSOLETE             ((char *)&u), 0); */
d46 3
a48 3
/* OBSOLETE                REGISTER_NAME (CSP_REGNUM),reg_buf[CSP_REGNUM], */
/* OBSOLETE                REGISTER_NAME (KSP_REGNUM), reg_buf[KSP_REGNUM], ksp, */
/* OBSOLETE                "usp", usp); */
d71 10
a80 10
/* OBSOLETE     long val = raw_regs[i]; */
/* OBSOLETE      */
/* OBSOLETE     fputs_filtered (REGISTER_NAME (i), gdb_stdout); */
/* OBSOLETE     printf_filtered(":"); */
/* OBSOLETE     print_spaces_filtered (6 - strlen (REGISTER_NAME (i)), gdb_stdout); */
/* OBSOLETE     if (val == 0) */
/* OBSOLETE       printf_filtered ("0"); */
/* OBSOLETE     else */
/* OBSOLETE       printf_filtered ("%s  %d", local_hex_string_custom(val,"08"), val); */
/* OBSOLETE     printf_filtered("\n"); */
d93 5
a97 5
/* OBSOLETE        "\t[[..frame_locals:%8x, %s= %x @@%x fcfp= %x foo= %x\n\t gr13=%x pr13=%x tr13=%x @@%x]]\n", */
/* OBSOLETE        frame->frame, */
/* OBSOLETE        REGISTER_NAME (CFP_REGNUM), */
/* OBSOLETE        result, addr, */
/* OBSOLETE        frame->frame_cfp, (CFP_REGNUM), */
d100 2
a101 2
/* OBSOLETE        read_register(13), read_register(29), read_register(61), */
/* OBSOLETE        find_saved_register(frame, 61)); */
d119 5
a123 5
/* OBSOLETE        "\t[[..frame_args:%8x, %s= %x @@%x fcfp= %x r_r= %x\n\t gr13=%x pr13=%x tr13=%x @@%x]]\n", */
/* OBSOLETE        frame->frame, */
/* OBSOLETE        REGISTER_NAME (CFP_REGNUM), */
/* OBSOLETE        result, addr, */
/* OBSOLETE        frame->frame_cfp, read_register(CFP_REGNUM), */
d125 2
a126 2
/* OBSOLETE        read_register(13), read_register(29), read_register(61), */
/* OBSOLETE        find_saved_register(frame, 61)); */
d165 1
a165 1
/* OBSOLETE         frame, 60/4, foo); */
d195 2
a196 2
/* OBSOLETE   long insn;                        /* first word of the insn, not broken down. *x/ */
/* OBSOLETE   pyr_insn_format insn_decode;      /* the same, broken out into op{code,erands} *x/ */
d218 2
a219 2
/* OBSOLETE       if (pyr_opcodes[i].datum.code == insn_opcode) */
/* OBSOLETE               break; */
d222 3
a224 3
/* OBSOLETE       /* FIXME: Handle unrecognised instructions better.  *x/ */
/* OBSOLETE       fprintf_unfiltered (stream, "???\t#%08x\t(op=%x mode =%x)", */
/* OBSOLETE                insn, insn_decode.operator, insn_decode.mode); */
d230 8
a237 8
/* OBSOLETE      Unconditional branches are an exception: they are encoded as */
/* OBSOLETE      conditional branches (branch if false condition, I think) */
/* OBSOLETE      with no condition specified. The average user will not be */
/* OBSOLETE      aware of this. To maintain their illusion that an */
/* OBSOLETE      unconditional branch insn exists, we will have to FIXME to */
/* OBSOLETE      treat the insn mnemnonic of all branch instructions here as a */
/* OBSOLETE      special case: check the operands of branch insn and print an */
/* OBSOLETE      appropriate mnemonic. *x/  */
d251 1
a251 1
/* OBSOLETE       static char cc_bit_names[] = "cvzn";  /* z,n,c,v: strange order? *x/ */
d255 3
a257 3
/* OBSOLETE     if ((bit_codes) & 0x1) */
/* OBSOLETE             fputc_unfiltered (cc_bit_names[i], stream); */
/* OBSOLETE     bit_codes >>= 1; */
d261 1
a261 1
/* OBSOLETE            displacement + memaddr); */
d267 5
a271 5
/* OBSOLETE     fprintf_unfiltered (stream, "%s,%s", */
/* OBSOLETE              REGISTER_NAME (op_1_regno), */
/* OBSOLETE              REGISTER_NAME (op_2_regno)); */
/* OBSOLETE     break; */
/* OBSOLETE          */
d273 5
a277 5
/* OBSOLETE     fprintf_unfiltered (stream, " 0x%0x,%s", */
/* OBSOLETE              op_1_regno, */
/* OBSOLETE              REGISTER_NAME (op_2_regno)); */
/* OBSOLETE     break; */
/* OBSOLETE      */
d279 7
a285 7
/* OBSOLETE     read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE     insn_size += 4; */
/* OBSOLETE     extra_1 = * ((int *) buffer); */
/* OBSOLETE     fprintf_unfiltered (stream, " $0x%0x,%s", */
/* OBSOLETE              extra_1, */
/* OBSOLETE              REGISTER_NAME (op_2_regno)); */
/* OBSOLETE     break; */
d287 5
a291 5
/* OBSOLETE     fprintf_unfiltered (stream, " (%s),%s", */
/* OBSOLETE              REGISTER_NAME (op_1_regno), */
/* OBSOLETE              REGISTER_NAME (op_2_regno)); */
/* OBSOLETE     break; */
/* OBSOLETE      */
d293 10
a302 10
/* OBSOLETE     read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE     insn_size += 4; */
/* OBSOLETE     extra_1 = * ((int *) buffer); */
/* OBSOLETE     fprintf_unfiltered (stream, " 0x%0x(%s),%s", */
/* OBSOLETE              extra_1, */
/* OBSOLETE              REGISTER_NAME (op_1_regno), */
/* OBSOLETE              REGISTER_NAME (op_2_regno)); */
/* OBSOLETE     break; */
/* OBSOLETE      */
/* OBSOLETE     /* S1 destination mode *x/ */
d304 8
a311 8
/* OBSOLETE     fprintf_unfiltered (stream, */
/* OBSOLETE              ((index_reg_regno) ? "%s,(%s)[%s*%1d]" : "%s,(%s)"), */
/* OBSOLETE              REGISTER_NAME (op_1_regno), */
/* OBSOLETE              REGISTER_NAME (op_2_regno), */
/* OBSOLETE              REGISTER_NAME (index_reg_regno), */
/* OBSOLETE              index_multiplier); */
/* OBSOLETE     break; */
/* OBSOLETE      */
d313 9
a321 9
/* OBSOLETE     fprintf_unfiltered (stream, */
/* OBSOLETE              ((index_reg_regno) ? " $%#0x,(%s)[%s*%1d]" */
/* OBSOLETE               : " $%#0x,(%s)"), */
/* OBSOLETE              op_1_regno, */
/* OBSOLETE              REGISTER_NAME (op_2_regno), */
/* OBSOLETE              REGISTER_NAME (index_reg_regno), */
/* OBSOLETE              index_multiplier); */
/* OBSOLETE     break; */
/* OBSOLETE      */
d323 12
a334 12
/* OBSOLETE     read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE     insn_size += 4; */
/* OBSOLETE     extra_1 = * ((int *) buffer); */
/* OBSOLETE     fprintf_unfiltered (stream, */
/* OBSOLETE              ((index_reg_regno) ? " $%#0x,(%s)[%s*%1d]" */
/* OBSOLETE               : " $%#0x,(%s)"), */
/* OBSOLETE              extra_1, */
/* OBSOLETE              REGISTER_NAME (op_2_regno), */
/* OBSOLETE              REGISTER_NAME (index_reg_regno), */
/* OBSOLETE              index_multiplier); */
/* OBSOLETE     break; */
/* OBSOLETE      */
d336 8
a343 8
/* OBSOLETE     fprintf_unfiltered (stream, */
/* OBSOLETE              ((index_reg_regno) ? " (%s),(%s)[%s*%1d]" : " (%s),(%s)"), */
/* OBSOLETE              REGISTER_NAME (op_1_regno), */
/* OBSOLETE              REGISTER_NAME (op_2_regno), */
/* OBSOLETE              REGISTER_NAME (index_reg_regno), */
/* OBSOLETE              index_multiplier); */
/* OBSOLETE     break; */
/* OBSOLETE      */
d345 15
a359 15
/* OBSOLETE     read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE     insn_size += 4; */
/* OBSOLETE     extra_1 = * ((int *) buffer); */
/* OBSOLETE     fprintf_unfiltered (stream, */
/* OBSOLETE              ((index_reg_regno) */
/* OBSOLETE               ? "%#0x(%s),(%s)[%s*%1d]" */
/* OBSOLETE               : "%#0x(%s),(%s)"), */
/* OBSOLETE              extra_1, */
/* OBSOLETE              REGISTER_NAME (op_1_regno), */
/* OBSOLETE              REGISTER_NAME (op_2_regno), */
/* OBSOLETE              REGISTER_NAME (index_reg_regno), */
/* OBSOLETE              index_multiplier); */
/* OBSOLETE     break; */
/* OBSOLETE      */
/* OBSOLETE     /* S2 destination mode *x/ */
d361 11
a371 11
/* OBSOLETE     read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE     insn_size += 4; */
/* OBSOLETE     extra_1 = * ((int *) buffer); */
/* OBSOLETE     fprintf_unfiltered (stream, */
/* OBSOLETE              ((index_reg_regno) ? "%s,%#0x(%s)[%s*%1d]" : "%s,%#0x(%s)"), */
/* OBSOLETE              REGISTER_NAME (op_1_regno), */
/* OBSOLETE              extra_1, */
/* OBSOLETE              REGISTER_NAME (op_2_regno), */
/* OBSOLETE              REGISTER_NAME (index_reg_regno), */
/* OBSOLETE              index_multiplier); */
/* OBSOLETE     break; */
d373 12
a384 12
/* OBSOLETE     read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE     insn_size += 4; */
/* OBSOLETE     extra_1 = * ((int *) buffer); */
/* OBSOLETE     fprintf_unfiltered (stream, */
/* OBSOLETE              ((index_reg_regno) ? */
/* OBSOLETE               " $%#0x,%#0x(%s)[%s*%1d]" : " $%#0x,%#0x(%s)"), */
/* OBSOLETE              op_1_regno, */
/* OBSOLETE              extra_1, */
/* OBSOLETE              REGISTER_NAME (op_2_regno), */
/* OBSOLETE              REGISTER_NAME (index_reg_regno), */
/* OBSOLETE              index_multiplier); */
/* OBSOLETE     break; */
d386 16
a401 16
/* OBSOLETE     read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE     insn_size += 4; */
/* OBSOLETE     extra_1 = * ((int *) buffer); */
/* OBSOLETE     read_memory (memaddr+8, buffer, MAXLEN); */
/* OBSOLETE     insn_size += 4; */
/* OBSOLETE     extra_2 = * ((int *) buffer); */
/* OBSOLETE     fprintf_unfiltered (stream, */
/* OBSOLETE              ((index_reg_regno) ? */
/* OBSOLETE               " $%#0x,%#0x(%s)[%s*%1d]" : " $%#0x,%#0x(%s)"), */
/* OBSOLETE              extra_1, */
/* OBSOLETE              extra_2, */
/* OBSOLETE              REGISTER_NAME (op_2_regno), */
/* OBSOLETE              REGISTER_NAME (index_reg_regno), */
/* OBSOLETE              index_multiplier); */
/* OBSOLETE     break; */
/* OBSOLETE      */
d403 13
a415 13
/* OBSOLETE     read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE     insn_size += 4; */
/* OBSOLETE     extra_1 = * ((int *) buffer); */
/* OBSOLETE     fprintf_unfiltered (stream, */
/* OBSOLETE              ((index_reg_regno) */
/* OBSOLETE               ? " (%s),%#0x(%s)[%s*%1d]"  */
/* OBSOLETE               : " (%s),%#0x(%s)"), */
/* OBSOLETE              REGISTER_NAME (op_1_regno), */
/* OBSOLETE              extra_1, */
/* OBSOLETE              REGISTER_NAME (op_2_regno), */
/* OBSOLETE              REGISTER_NAME (index_reg_regno), */
/* OBSOLETE              index_multiplier); */
/* OBSOLETE     break; */
d417 17
a433 17
/* OBSOLETE     read_memory (memaddr+4, buffer, MAXLEN); */
/* OBSOLETE     insn_size += 4; */
/* OBSOLETE     extra_1 = * ((int *) buffer); */
/* OBSOLETE     read_memory (memaddr+8, buffer, MAXLEN); */
/* OBSOLETE     insn_size += 4; */
/* OBSOLETE     extra_2 = * ((int *) buffer); */
/* OBSOLETE     fprintf_unfiltered (stream, */
/* OBSOLETE              ((index_reg_regno) ? "%#0x(%s),%#0x(%s)[%s*%1d]" */
/* OBSOLETE               : "%#0x(%s),%#0x(%s) "), */
/* OBSOLETE              extra_1, */
/* OBSOLETE              REGISTER_NAME (op_1_regno), */
/* OBSOLETE              extra_2, */
/* OBSOLETE              REGISTER_NAME (op_2_regno), */
/* OBSOLETE              REGISTER_NAME (index_reg_regno), */
/* OBSOLETE              index_multiplier); */
/* OBSOLETE     break; */
/* OBSOLETE      */
d435 10
a444 10
/* OBSOLETE     fprintf_unfiltered (stream, */
/* OBSOLETE              ((index_reg_regno) ? "%s,%s [%s*%1d]" : "%s,%s"), */
/* OBSOLETE              REGISTER_NAME (op_1_regno), */
/* OBSOLETE              REGISTER_NAME (op_2_regno), */
/* OBSOLETE              REGISTER_NAME (index_reg_regno), */
/* OBSOLETE              index_multiplier); */
/* OBSOLETE     fprintf_unfiltered (stream, */
/* OBSOLETE              "\t\t# unknown mode in %08x", */
/* OBSOLETE              insn); */
/* OBSOLETE     break; */
@


1.1.1.4
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
/* OBSOLETE    Copyright (C) 1988, 1989, 1991, 2000 Free Software Foundation, Inc. */
d187 1
a187 1
/* OBSOLETE      struct ui_file *stream; */
@


