head	1.38;
access;
symbols
	gdb_6_3-20041109-release:1.37
	gdb_6_3-branch:1.37.0.2
	gdb_6_3-20041019-branchpoint:1.37
	drow_intercu-merge-20040921:1.35
	drow_intercu-merge-20040915:1.34
	jimb-gdb_6_2-e500-branch:1.32.0.6
	jimb-gdb_6_2-e500-branchpoint:1.32
	gdb_6_2-20040730-release:1.32
	gdb_6_2-branch:1.32.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.32
	gdb_6_1_1-20040616-release:1.29
	gdb_6_1-2004-04-05-release:1.29
	drow_intercu-merge-20040402:1.29
	drow_intercu-merge-20040327:1.29
	ezannoni_pie-20040323-branch:1.29.0.16
	ezannoni_pie-20040323-branchpoint:1.29
	cagney_tramp-20040321-mergepoint:1.29
	cagney_tramp-20040309-branch:1.29.0.14
	cagney_tramp-20040309-branchpoint:1.29
	gdb_6_1-branch:1.29.0.12
	gdb_6_1-2004-03-01-gmt-branchpoint:1.29
	drow_intercu-20040221-branch:1.29.0.10
	drow_intercu-20040221-branchpoint:1.29
	cagney_bfdfile-20040213-branch:1.29.0.8
	cagney_bfdfile-20040213-branchpoint:1.29
	drow-cplus-merge-20040208:1.29
	carlton_dictionary-20040126-merge:1.29
	cagney_bigcore-20040122-branch:1.29.0.6
	cagney_bigcore-20040122-branchpoint:1.29
	drow-cplus-merge-20040113:1.29
	drow-cplus-merge-20031224:1.29
	drow-cplus-merge-20031220:1.29
	carlton_dictionary-20031215-merge:1.29
	drow-cplus-merge-20031214:1.29
	carlton-dictionary-20031111-merge:1.29
	gdb_6_0-2003-10-04-release:1.28
	kettenis_sparc-20030918-branch:1.29.0.4
	kettenis_sparc-20030918-branchpoint:1.29
	carlton_dictionary-20030917-merge:1.29
	ezannoni_pie-20030916-branchpoint:1.29
	ezannoni_pie-20030916-branch:1.29.0.2
	cagney_x86i386-20030821-branch:1.28.0.4
	cagney_x86i386-20030821-branchpoint:1.28
	carlton_dictionary-20030805-merge:1.28
	carlton_dictionary-20030627-merge:1.28
	gdb_6_0-branch:1.28.0.2
	gdb_6_0-2003-06-23-branchpoint:1.28
	jimb-ppc64-linux-20030613-branch:1.27.0.18
	jimb-ppc64-linux-20030613-branchpoint:1.27
	cagney_convert-20030606-branch:1.27.0.16
	cagney_convert-20030606-branchpoint:1.27
	cagney_writestrings-20030508-branch:1.27.0.14
	cagney_writestrings-20030508-branchpoint:1.27
	jimb-ppc64-linux-20030528-branch:1.27.0.12
	jimb-ppc64-linux-20030528-branchpoint:1.27
	carlton_dictionary-20030523-merge:1.27
	cagney_fileio-20030521-branch:1.27.0.10
	cagney_fileio-20030521-branchpoint:1.27
	kettenis_i386newframe-20030517-mergepoint:1.27
	jimb-ppc64-linux-20030509-branch:1.27.0.8
	jimb-ppc64-linux-20030509-branchpoint:1.27
	kettenis_i386newframe-20030504-mergepoint:1.27
	carlton_dictionary-20030430-merge:1.27
	kettenis_i386newframe-20030419-branch:1.27.0.6
	kettenis_i386newframe-20030419-branchpoint:1.27
	carlton_dictionary-20030416-merge:1.27
	cagney_frameaddr-20030409-mergepoint:1.27
	kettenis_i386newframe-20030406-branch:1.27.0.4
	kettenis_i386newframe-20030406-branchpoint:1.27
	cagney_frameaddr-20030403-branchpoint:1.27
	cagney_frameaddr-20030403-branch:1.27.0.2
	cagney_framebase-20030330-mergepoint:1.27
	cagney_framebase-20030326-branch:1.25.0.10
	cagney_framebase-20030326-branchpoint:1.25
	cagney_lazyid-20030317-branch:1.25.0.8
	cagney_lazyid-20030317-branchpoint:1.25
	kettenis-i386newframe-20030316-mergepoint:1.25
	offbyone-20030313-branch:1.25.0.6
	offbyone-20030313-branchpoint:1.25
	kettenis-i386newframe-20030308-branch:1.25.0.4
	kettenis-i386newframe-20030308-branchpoint:1.25
	carlton_dictionary-20030305-merge:1.25
	cagney_offbyone-20030303-branch:1.25.0.2
	cagney_offbyone-20030303-branchpoint:1.25
	carlton_dictionary-20030207-merge:1.25
	interps-20030203-mergepoint:1.24
	interps-20030202-branch:1.24.0.4
	interps-20030202-branchpoint:1.24
	cagney-unwind-20030108-branch:1.24.0.2
	cagney-unwind-20030108-branchpoint:1.24
	carlton_dictionary-20021223-merge:1.24
	gdb_5_3-2002-12-12-release:1.19.14.1
	carlton_dictionary-20021115-merge:1.20
	kseitz_interps-20021105-merge:1.20
	kseitz_interps-20021103-merge:1.20
	drow-cplus-merge-20021020:1.20
	drow-cplus-merge-20021025:1.20
	carlton_dictionary-20021025-merge:1.20
	carlton_dictionary-20021011-merge:1.20
	drow-cplus-branch:1.20.0.4
	drow-cplus-branchpoint:1.20
	kseitz_interps-20020930-merge:1.20
	carlton_dictionary-20020927-merge:1.20
	carlton_dictionary-branch:1.20.0.2
	carlton_dictionary-20020920-branchpoint:1.20
	gdb_5_3-branch:1.19.0.14
	gdb_5_3-2002-09-04-branchpoint:1.19
	kseitz_interps-20020829-merge:1.19
	cagney_sysregs-20020825-branch:1.19.0.12
	cagney_sysregs-20020825-branchpoint:1.19
	readline_4_3-import-branch:1.19.0.10
	readline_4_3-import-branchpoint:1.19
	gdb_5_2_1-2002-07-23-release:1.19
	kseitz_interps-20020528-branch:1.19.0.8
	kseitz_interps-20020528-branchpoint:1.19
	cagney_regbuf-20020515-branch:1.19.0.6
	cagney_regbuf-20020515-branchpoint:1.19
	jimb-macro-020506-branch:1.19.0.4
	jimb-macro-020506-branchpoint:1.19
	gdb_5_2-2002-04-29-release:1.19
	gdb_5_2-branch:1.19.0.2
	gdb_5_2-2002-03-03-branchpoint:1.19
	gdb_5_1_1-2002-01-24-release:1.15
	gdb_5_1_0_1-2002-01-03-release:1.15
	cygnus_cvs_20020108_pre:1.17
	gdb_5_1_0_1-2002-01-03-branchpoint:1.15
	gdb_5_1_0_1-2002-01-03-branch:1.15.0.6
	gdb_5_1-2001-11-21-release:1.15
	gdb_s390-2001-09-26-branch:1.15.0.4
	gdb_s390-2001-09-26-branchpoint:1.15
	gdb_5_1-2001-07-29-branch:1.15.0.2
	gdb_5_1-2001-07-29-branchpoint:1.15
	dberlin-typesystem-branch:1.12.0.2
	dberlin-typesystem-branchpoint:1.12
	gdb-post-ptid_t-2001-05-03:1.12
	gdb-pre-ptid_t-2001-05-03:1.11
	insight-precleanup-2001-01-01:1.7
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.5
	gdb-1999-12-07:1.1.1.5
	gdb-1999-12-06:1.1.1.5
	gdb-1999-11-16:1.1.1.5
	gdb-1999-11-08:1.1.1.5
	gdb-1999-11-01:1.1.1.5
	gdb-1999-10-25:1.1.1.5
	gdb-1999-10-18:1.1.1.5
	gdb-1999-10-11:1.1.1.5
	gdb-1999-10-04:1.1.1.5
	gdb-1999-09-28:1.1.1.5
	gdb-1999-09-21:1.1.1.5
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.5
	gdb-1999-08-30:1.1.1.5
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.38
date	2004.12.18.17.36.32;	author kettenis;	state dead;
branches;
next	1.37;

1.37
date	2004.10.05.21.53.33;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2004.09.29.15.33.02;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2004.09.20.16.39.33;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2004.09.07.21.55.10;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2004.08.06.20.47.25;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.08.19.58.11;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.08.21.18.12;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.06.18.29.09;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.14.16.32.13;	author cagney;	state Exp;
branches
	1.29.10.1;
next	1.28;

1.28
date	2003.06.19.15.04.57;	author drow;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.30.14.52.42;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.29.23.29.47;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.06.17.58.01;	author fnf;	state Exp;
branches
	1.25.10.1;
next	1.24;

1.24
date	2002.12.12.01.39.34;	author drow;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.11.02.02.03;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.16.19.22.58;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.16.19.21.44;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.10.17.34.05;	author law;	state Exp;
branches
	1.20.2.1
	1.20.4.1;
next	1.19;

1.19
date	2002.01.21.01.27.01;	author cagney;	state Exp;
branches
	1.19.8.1
	1.19.14.1;
next	1.18;

1.18
date	2002.01.08.00.59.29;	author msnyder;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.19.19.16.50;	author law;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.27.13.31.45;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.28.22.44.53;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.26.02.23.57;	author drow;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.19.04.58.17;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.04.04.15.25;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.20.01.37.09;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.15.16.55.14;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.06.08.21.08;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.15.01.01.47;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.24.13.10.18;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.21.16.17.49;	author fnf;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.09.01.38.49;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.46;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.07.19;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.02.23.45.40;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.08.16.19.53.02;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.31.01.05.17;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.12.22.21.45.07;	author jsm;	state Exp;
branches;
next	;

1.19.8.1
date	2002.10.01.00.46.10;	author kseitz;	state Exp;
branches;
next	;

1.19.14.1
date	2002.09.15.19.09.05;	author ezannoni;	state Exp;
branches;
next	;

1.20.2.1
date	2002.12.23.19.38.32;	author carlton;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2003.02.07.19.17.50;	author carlton;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2003.04.16.19.56.53;	author carlton;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2003.06.27.21.50.04;	author carlton;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2003.09.17.21.28.22;	author carlton;	state Exp;
branches;
next	;

1.20.4.1
date	2003.12.14.20.27.19;	author drow;	state Exp;
branches;
next	;

1.25.10.1
date	2003.03.30.16.35.21;	author cagney;	state Exp;
branches;
next	;

1.29.10.1
date	2004.09.16.17.01.09;	author drow;	state Exp;
branches;
next	1.29.10.2;

1.29.10.2
date	2004.09.21.20.44.17;	author drow;	state Exp;
branches;
next	;


desc
@@


1.38
log
@* hppah-nat.c: Remove file.
* infttrace.h: Remove file.
* infttrace.c: Remove file.
* Makefile.in (ALLDEPFILES): Remove hppah-nat.c
(infttrace_h): Remove variable.
(hppah-nat.o, infttrace.o): Remove dependencies.
* configure.host (hppa*64*-*-hpux11*): Remove.
* config/pa/hpux11w.mh: Remove file.
* config/pa/nm-hppah.h: Remove file.
* config/pa/nm-hppah11.h: Remove file.
@
text
@/* Low level Unix child interface to ttrace, for GDB when running under HP-UX.

   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1998, 1999, 2000, 2001, 2003, 2004 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "target.h"
#include "gdb_string.h"
#include "gdb_wait.h"
#include "command.h"
#include "gdbthread.h"
#include "infttrace.h"

/* We need pstat functionality so that we can get the exec file
   for a process we attach to.

   According to HP, we should use the 64bit interfaces, so we
   define _PSTAT64 to achieve this.  */
#define _PSTAT64
#include <sys/pstat.h>

/* Some hackery to work around a use of the #define name NO_FLAGS
 * in both gdb and HPUX (bfd.h and /usr/include/machine/vmparam.h).
 */
#ifdef  NO_FLAGS
#define INFTTRACE_TEMP_HACK NO_FLAGS
#undef  NO_FLAGS
#endif

#include <sys/param.h>
#include <sys/dir.h>
#include <signal.h>
#include <sys/ioctl.h>

#include <sys/ttrace.h>
#include <sys/mman.h>

#ifndef NO_PTRACE_H
#ifdef PTRACE_IN_WRONG_PLACE
#include <ptrace.h>
#else
#include <sys/ptrace.h>
#endif
#endif /* NO_PTRACE_H */

/* Second half of the hackery above.  Non-ANSI C, so
 * we can't use "#error", alas.
 */
#ifdef NO_FLAGS
#if (NO_FLAGS != INFTTRACE_TEMP_HACK )
  /* #error "Hackery to remove warning didn't work right" */
#else
  /* Ok, new def'n of NO_FLAGS is same as old one; no action needed. */
#endif
#else
  /* #error "Didn't get expected re-definition of NO_FLAGS" */
#define NO_FLAGS INFTTRACE_TEMP_HACK
#endif

#if !defined (PT_SETTRC)
#define PT_SETTRC	0	/* Make process traceable by parent */
#endif
#if !defined (PT_READ_I)
#define PT_READ_I	1	/* Read word from text space */
#endif
#if !defined (PT_READ_D)
#define	PT_READ_D	2	/* Read word from data space */
#endif
#if !defined (PT_READ_U)
#define PT_READ_U	3	/* Read word from kernel user struct */
#endif
#if !defined (PT_WRITE_I)
#define PT_WRITE_I	4	/* Write word to text space */
#endif
#if !defined (PT_WRITE_D)
#define PT_WRITE_D	5	/* Write word to data space */
#endif
#if !defined (PT_WRITE_U)
#define PT_WRITE_U	6	/* Write word to kernel user struct */
#endif
#if !defined (PT_CONTINUE)
#define PT_CONTINUE	7	/* Continue after signal */
#endif
#if !defined (PT_STEP)
#define PT_STEP		9	/* Set flag for single stepping */
#endif
#if !defined (PT_KILL)
#define PT_KILL		8	/* Send child a SIGKILL signal */
#endif

#ifndef PT_ATTACH
#define PT_ATTACH PTRACE_ATTACH
#endif
#ifndef PT_DETACH
#define PT_DETACH PTRACE_DETACH
#endif

#include "gdbcore.h"
#ifdef	HAVE_SYS_FILE_H
#include <sys/file.h>
#endif

/* This semaphore is used to coordinate the child and parent processes
   after a fork(), and before an exec() by the child.  See parent_attach_all
   for details.
 */
typedef struct
  {
    int parent_channel[2];	/* Parent "talks" to [1], child "listens" to [0] */
    int child_channel[2];	/* Child "talks" to [1], parent "listens" to [0] */
  }
startup_semaphore_t;

#define SEM_TALK (1)
#define SEM_LISTEN (0)

static startup_semaphore_t startup_semaphore;

/* See can_touch_threads_of_process for details. */
static int vforking_child_pid = 0;
static int vfork_in_flight = 0;

/* 1 if ok as results of a ttrace or ttrace_wait call, 0 otherwise.
 */
#define TT_OK( _status, _errno ) \
    (((_status) == 1) && ((_errno) == 0))

#define TTRACE_ARG_TYPE uint64_t

/* When supplied as the "addr" operand, ttrace interprets this
   to mean, "from the current address".
 */
#define TT_USE_CURRENT_PC ((TTRACE_ARG_TYPE) TT_NOPC)

/* When supplied as the "addr", "data" or "addr2" operand for most
   requests, ttrace interprets this to mean, "pay no heed to this
   argument".
 */
#define TT_NIL ((TTRACE_ARG_TYPE) TT_NULLARG)

/* This is capable of holding the value of a 32-bit register.  The
   value is always left-aligned in the buffer; i.e., [0] contains
   the most-significant byte of the register's value, and [sizeof(reg)]
   contains the least-significant value.

   ??rehrauer: Yes, this assumes that an int is 32-bits on HP-UX, and
   that registers are 32-bits on HP-UX.  The latter assumption changes
   with PA2.0.
 */
typedef int register_value_t;

/********************************************************************

                 How this works:

   1.  Thread numbers

   The rest of GDB sees threads as being things with different
   "pid" (process id) values.  See "thread.c" for details.  The
   separate threads will be seen and reacted to if infttrace passes
   back different pid values (for _events_).  See wait_for_inferior
   in inftarg.c.

   So infttrace is going to use thread ids externally, pretending
   they are process ids, and keep track internally so that it can
   use the real process id (and thread id) when calling ttrace.

   The data structure that supports this is a linked list of the
   current threads.  Since at some date infttrace will have to
   deal with multiple processes, each list element records its
   corresponding pid, rather than having a single global.

   Note that the list is only approximately current; that's ok, as
   it's up to date when we need it (we hope!).  Also, it can contain
   dead threads, as there's no harm if it does.

   The approach taken here is to bury the translation from external
   to internal inside "call_ttrace" and a few other places.

   There are some wrinkles:

   o  When GDB forks itself to create the debug target process,
      there's only a pid of 0 around in the child, so the
      TT_PROC_SETTRC operation uses a more direct call to ttrace;
      Similiarly, the initial setting of the event mask happens
      early as  well, and so is also special-cased, and an attach
      uses a real pid;

   o  We define an unthreaded application as having a "pseudo"
      thread;

   o  To keep from confusing the rest of GDB, we don't switch
      the PID for the pseudo thread to a TID.  A table will help:

      Rest of GDB sees these PIDs:     pid   tid1  tid2  tid3 ...
                                        
      Our thread list stores:          pid   pid   pid   pid  ...
                                       tid0  tid1  tid2  tid3
      
      Ttrace sees these TIDS:          tid0  tid1  tid2  tid3 ...

      Both pid and tid0 will map to tid0, as there are infttrace.c-internal
      calls to ttrace using tid0.

   2. Step and Continue

   Since we're implementing the "stop the world" model, sub-model
   "other threads run during step", we have some stuff to do:

   o  User steps require continuing all threads other than the
      one the user is stepping;

   o  Internal debugger steps (such as over a breakpoint or watchpoint,
      but not out of a library load thunk) require stepping only
      the selected thread; this means that we have to report the
      step finish on that thread, which can lead to complications;

   o  When a thread is created, it is created running, rather
      than stopped--so we have to stop it.

   The OS doesn't guarantee the stopped thread list will be stable,
   no does it guarantee where on the stopped thread list a thread
   that is single-stepped will wind up: it's possible that it will
   be off the list for a while, it's possible the step will complete
   and it will be re-posted to the end...

   This means we have to scan the stopped thread list, build up
   a work-list, and then run down the work list; we can't do the
   step/continue during the scan.

   3. Buffering events

   Then there's the issue of waiting for an event.  We do this by
   noticing how many events are reported at the end of each wait.
   From then on, we "fake" all resumes and steps, returning instantly,
   and don't do another wait.  Once all pending events are reported,
   we can really resume again.

   To keep this hidden, all the routines which know about tids and
   pids or real events and simulated ones are static (file-local).

   This code can make lots of calls to ttrace, in particular it
   can spin down the list of thread states more than once.  If this
   becomes a performance hit, the spin could be done once and the
   various "tsp" blocks saved, keeping all later spins in this
   process.

   The O/S doesn't promise to keep the list straight, and so we must
   re-scan a lot.  By observation, it looks like a single-step/wait
   puts the stepped thread at the end of the list but doesn't change
   it otherwise.

****************************************************************
*/

/* Uncomment these to turn on various debugging output */
/* #define THREAD_DEBUG */
/* #define WAIT_BUFFER_DEBUG */
/* #define PARANOIA */


#define INFTTRACE_ALL_THREADS (-1)
#define INFTTRACE_STEP        (1)
#define INFTTRACE_CONTINUE    (0)

/* FIX: this is used in inftarg.c/child_wait, in a hack.
 */
extern int not_same_real_pid;

/* This is used to count buffered events.
 */
static unsigned int more_events_left = 0;

/* Process state.
 */
typedef enum process_state_enum
  {
    STOPPED,
    FAKE_STEPPING,
    FAKE_CONTINUE,		/* For later use */
    RUNNING,
    FORKING,
    VFORKING
  }
process_state_t;

static process_state_t process_state = STOPPED;

/* User-specified stepping modality.
 */
typedef enum stepping_mode_enum
  {
    DO_DEFAULT,			/* ...which is a continue! */
    DO_STEP,
    DO_CONTINUE
  }
stepping_mode_t;

/* Action to take on an attach, depends on
 * what kind (user command, fork, vfork).
 *
 * At the moment, this is either:
 *
 * o  continue with a SIGTRAP signal, or
 *
 * o  leave stopped.
 */
typedef enum attach_continue_enum
  {
    DO_ATTACH_CONTINUE,
    DONT_ATTACH_CONTINUE
  }
attach_continue_t;

/* This flag is true if we are doing a step-over-bpt
 * with buffered events.  We will have to be sure to
 * report the right thread, as otherwise the spaghetti
 * code in "infrun.c/wait_for_inferior" will get
 * confused.
 */
static int doing_fake_step = 0;
static lwpid_t fake_step_tid = 0;


/****************************************************
 * Thread information structure routines and types. *
 ****************************************************
 */
typedef
struct thread_info_struct
  {
    int am_pseudo;		/* This is a pseudo-thread for the process. */
    int pid;			/* Process ID */
    lwpid_t tid;		/* Thread  ID */
    int handled;		/* 1 if a buffered event was handled. */
    int seen;			/* 1 if this thread was seen on a traverse. */
    int terminated;		/* 1 if thread has terminated. */
    int have_signal;		/* 1 if signal to be sent */
    enum target_signal signal_value;	/* Signal to send */
    int have_start;		/* 1 if alternate starting address */
    stepping_mode_t stepping_mode;	/* Whether to step or continue */
    CORE_ADDR start;		/* Where to start */
    int have_state;		/* 1 if the event state has been set */
    ttstate_t last_stop_state;	/* The most recently-waited event for this thread. */
    struct thread_info_struct
     *next;			/* All threads are linked via this field. */
    struct thread_info_struct
     *next_pseudo;		/* All pseudo-threads are linked via this field. */
  }
thread_info;

typedef
struct thread_info_header_struct
  {
    int count;
    thread_info *head;
    thread_info *head_pseudo;

  }
thread_info_header;

static thread_info_header thread_head =
{0, NULL, NULL};
static thread_info_header deleted_threads =
{0, NULL, NULL};

static ptid_t saved_real_ptid;


/*************************************************
 *          Debugging support functions          *
 *************************************************
 */
CORE_ADDR
get_raw_pc (lwpid_t ttid)
{
  unsigned long pc_val;
  int offset;
  int res;

  offset = register_addr (PC_REGNUM, U_REGS_OFFSET);
  res = read_from_register_save_state (
					ttid,
					(TTRACE_ARG_TYPE) offset,
					(char *) &pc_val,
					sizeof (pc_val));
  if (res <= 0)
    {
      return (CORE_ADDR) pc_val;
    }
  else
    {
      return (CORE_ADDR) 0;
    }
}

static char *
get_printable_name_of_stepping_mode (stepping_mode_t mode)
{
  switch (mode)
    {
    case DO_DEFAULT:
      return "DO_DEFAULT";
    case DO_STEP:
      return "DO_STEP";
    case DO_CONTINUE:
      return "DO_CONTINUE";
    default:
      return "?unknown mode?";
    }
}

/* This function returns a pointer to a string describing the
 * ttrace event being reported.
 */
char *
get_printable_name_of_ttrace_event (ttevents_t event)
{
  /* This enumeration is "gappy", so don't use a table. */
  switch (event)
    {

    case TTEVT_NONE:
      return "TTEVT_NONE";
    case TTEVT_SIGNAL:
      return "TTEVT_SIGNAL";
    case TTEVT_FORK:
      return "TTEVT_FORK";
    case TTEVT_EXEC:
      return "TTEVT_EXEC";
    case TTEVT_EXIT:
      return "TTEVT_EXIT";
    case TTEVT_VFORK:
      return "TTEVT_VFORK";
    case TTEVT_SYSCALL_RETURN:
      return "TTEVT_SYSCALL_RETURN";
    case TTEVT_LWP_CREATE:
      return "TTEVT_LWP_CREATE";
    case TTEVT_LWP_TERMINATE:
      return "TTEVT_LWP_TERMINATE";
    case TTEVT_LWP_EXIT:
      return "TTEVT_LWP_EXIT";
    case TTEVT_LWP_ABORT_SYSCALL:
      return "TTEVT_LWP_ABORT_SYSCALL";
    case TTEVT_SYSCALL_ENTRY:
      return "TTEVT_SYSCALL_ENTRY";
    case TTEVT_SYSCALL_RESTART:
      return "TTEVT_SYSCALL_RESTART";
    default:
      return "?new event?";
    }
}


/* This function translates the ttrace request enumeration into
 * a character string that is its printable (aka "human readable")
 * name.
 */
char *
get_printable_name_of_ttrace_request (ttreq_t request)
{
  if (!IS_TTRACE_REQ (request))
    return "?bad req?";

  /* This enumeration is "gappy", so don't use a table. */
  switch (request)
    {
    case TT_PROC_SETTRC:
      return "TT_PROC_SETTRC";
    case TT_PROC_ATTACH:
      return "TT_PROC_ATTACH";
    case TT_PROC_DETACH:
      return "TT_PROC_DETACH";
    case TT_PROC_RDTEXT:
      return "TT_PROC_RDTEXT";
    case TT_PROC_WRTEXT:
      return "TT_PROC_WRTEXT";
    case TT_PROC_RDDATA:
      return "TT_PROC_RDDATA";
    case TT_PROC_WRDATA:
      return "TT_PROC_WRDATA";
    case TT_PROC_STOP:
      return "TT_PROC_STOP";
    case TT_PROC_CONTINUE:
      return "TT_PROC_CONTINUE";
    case TT_PROC_GET_PATHNAME:
      return "TT_PROC_GET_PATHNAME";
    case TT_PROC_GET_EVENT_MASK:
      return "TT_PROC_GET_EVENT_MASK";
    case TT_PROC_SET_EVENT_MASK:
      return "TT_PROC_SET_EVENT_MASK";
    case TT_PROC_GET_FIRST_LWP_STATE:
      return "TT_PROC_GET_FIRST_LWP_STATE";
    case TT_PROC_GET_NEXT_LWP_STATE:
      return "TT_PROC_GET_NEXT_LWP_STATE";
    case TT_PROC_EXIT:
      return "TT_PROC_EXIT";
    case TT_PROC_GET_MPROTECT:
      return "TT_PROC_GET_MPROTECT";
    case TT_PROC_SET_MPROTECT:
      return "TT_PROC_SET_MPROTECT";
    case TT_PROC_SET_SCBM:
      return "TT_PROC_SET_SCBM";
    case TT_LWP_STOP:
      return "TT_LWP_STOP";
    case TT_LWP_CONTINUE:
      return "TT_LWP_CONTINUE";
    case TT_LWP_SINGLE:
      return "TT_LWP_SINGLE";
    case TT_LWP_RUREGS:
      return "TT_LWP_RUREGS";
    case TT_LWP_WUREGS:
      return "TT_LWP_WUREGS";
    case TT_LWP_GET_EVENT_MASK:
      return "TT_LWP_GET_EVENT_MASK";
    case TT_LWP_SET_EVENT_MASK:
      return "TT_LWP_SET_EVENT_MASK";
    case TT_LWP_GET_STATE:
      return "TT_LWP_GET_STATE";
    default:
      return "?new req?";
    }
}


/* This function translates the process state enumeration into
 * a character string that is its printable (aka "human readable")
 * name.
 */
static char *
get_printable_name_of_process_state (process_state_t process_state)
{
  switch (process_state)
    {
    case STOPPED:
      return "STOPPED";
    case FAKE_STEPPING:
      return "FAKE_STEPPING";
    case RUNNING:
      return "RUNNING";
    case FORKING:
      return "FORKING";
    case VFORKING:
      return "VFORKING";
    default:
      return "?some unknown state?";
    }
}

/* Set a ttrace thread state to a safe, initial state.
 */
static void
clear_ttstate_t (ttstate_t *tts)
{
  tts->tts_pid = 0;
  tts->tts_lwpid = 0;
  tts->tts_user_tid = 0;
  tts->tts_event = TTEVT_NONE;
}

/* Copy ttrace thread state TTS_FROM into TTS_TO.
 */
static void
copy_ttstate_t (ttstate_t *tts_to, ttstate_t *tts_from)
{
  memcpy ((char *) tts_to, (char *) tts_from, sizeof (*tts_to));
}

/* Are there any live threads we know about?
 */
static int
any_thread_records (void)
{
  return (thread_head.count > 0);
}

/* Create, fill in and link in a thread descriptor.
 */
static thread_info *
create_thread_info (int pid, lwpid_t tid)
{
  thread_info *new_p;
  thread_info *p;
  int thread_count_of_pid;

  new_p = xmalloc (sizeof (thread_info));
  new_p->pid = pid;
  new_p->tid = tid;
  new_p->have_signal = 0;
  new_p->have_start = 0;
  new_p->have_state = 0;
  clear_ttstate_t (&new_p->last_stop_state);
  new_p->am_pseudo = 0;
  new_p->handled = 0;
  new_p->seen = 0;
  new_p->terminated = 0;
  new_p->next = NULL;
  new_p->next_pseudo = NULL;
  new_p->stepping_mode = DO_DEFAULT;

  if (0 == thread_head.count)
    {
#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("First thread, pid %d tid %d!\n", pid, tid);
#endif
      saved_real_ptid = inferior_ptid;
    }
  else
    {
#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("Subsequent thread, pid %d tid %d\n", pid, tid);
#endif
    }

  /* Another day, another thread...
   */
  thread_head.count++;

  /* The new thread always goes at the head of the list.
   */
  new_p->next = thread_head.head;
  thread_head.head = new_p;

  /* Is this the "pseudo" thread of a process?  It is if there's
   * no other thread for this process on the list.  (Note that this
   * accomodates multiple processes, such as we see even for simple
   * cases like forking "non-threaded" programs.)
   */
  p = thread_head.head;
  thread_count_of_pid = 0;
  while (p)
    {
      if (p->pid == new_p->pid)
	thread_count_of_pid++;
      p = p->next;
    }

  /* Did we see any other threads for this pid?  (Recall that we just
   * added this thread to the list...)
   */
  if (thread_count_of_pid == 1)
    {
      new_p->am_pseudo = 1;
      new_p->next_pseudo = thread_head.head_pseudo;
      thread_head.head_pseudo = new_p;
    }

  return new_p;
}

/* Get rid of our thread info.
 */
static void
clear_thread_info (void)
{
  thread_info *p;
  thread_info *q;

#ifdef THREAD_DEBUG
  if (debug_on)
    printf ("Clearing all thread info\n");
#endif

  p = thread_head.head;
  while (p)
    {
      q = p;
      p = p->next;
      xfree (q);
    }

  thread_head.head = NULL;
  thread_head.head_pseudo = NULL;
  thread_head.count = 0;

  p = deleted_threads.head;
  while (p)
    {
      q = p;
      p = p->next;
      xfree (q);
    }

  deleted_threads.head = NULL;
  deleted_threads.head_pseudo = NULL;
  deleted_threads.count = 0;

  /* No threads, so can't have pending events.
   */
  more_events_left = 0;
}

/* Given a tid, find the thread block for it.
 */
static thread_info *
find_thread_info (lwpid_t tid)
{
  thread_info *p;

  for (p = thread_head.head; p; p = p->next)
    {
      if (p->tid == tid)
	{
	  return p;
	}
    }

  for (p = deleted_threads.head; p; p = p->next)
    {
      if (p->tid == tid)
	{
	  return p;
	}
    }

  return NULL;
}

/* For any but the pseudo thread, this maps to the
 * thread ID.  For the pseudo thread, if you pass either
 * the thread id or the PID, you get the pseudo thread ID.
 *
 * We have to be prepared for core gdb to ask about
 * deleted threads.  We do the map, but we don't like it.
 */
static lwpid_t
map_from_gdb_tid (lwpid_t gdb_tid)
{
  thread_info *p;

  /* First assume gdb_tid really is a tid, and try to find a
   * matching entry on the threads list.
   */
  for (p = thread_head.head; p; p = p->next)
    {
      if (p->tid == gdb_tid)
	return gdb_tid;
    }

  /* It doesn't appear to be a tid; perhaps it's really a pid?
   * Try to find a "pseudo" thread entry on the threads list.
   */
  for (p = thread_head.head_pseudo; p != NULL; p = p->next_pseudo)
    {
      if (p->pid == gdb_tid)
	return p->tid;
    }

  /* Perhaps it's the tid of a deleted thread we may still
   * have some knowledge of?
   */
  for (p = deleted_threads.head; p; p = p->next)
    {
      if (p->tid == gdb_tid)
	return gdb_tid;
    }

  /* Or perhaps it's the pid of a deleted process we may still
   * have knowledge of?
   */
  for (p = deleted_threads.head_pseudo; p != NULL; p = p->next_pseudo)
    {
      if (p->pid == gdb_tid)
	return p->tid;
    }

  return 0;			/* Error? */
}

/* Map the other way: from a real tid to the
 * "pid" known by core gdb.  This tid may be
 * for a thread that just got deleted, so we
 * also need to consider deleted threads.
 */
static lwpid_t
map_to_gdb_tid (lwpid_t real_tid)
{
  thread_info *p;

  for (p = thread_head.head; p; p = p->next)
    {
      if (p->tid == real_tid)
	{
	  if (p->am_pseudo)
	    return p->pid;
	  else
	    return real_tid;
	}
    }

  for (p = deleted_threads.head; p; p = p->next)
    {
      if (p->tid == real_tid)
	if (p->am_pseudo)
	  return p->pid;	/* Error? */
	else
	  return real_tid;
    }

  return 0;			/* Error?  Never heard of this thread! */
}

/* Do any threads have saved signals?
 */
static int
saved_signals_exist (void)
{
  thread_info *p;

  for (p = thread_head.head; p; p = p->next)
    {
      if (p->have_signal)
	{
	  return 1;
	}
    }

  return 0;
}

/* Is this the tid for the zero-th thread?
 */
static int
is_pseudo_thread (lwpid_t tid)
{
  thread_info *p = find_thread_info (tid);
  if (NULL == p || p->terminated)
    return 0;
  else
    return p->am_pseudo;
}

/* Is this thread terminated?
 */
static int
is_terminated (lwpid_t tid)
{
  thread_info *p = find_thread_info (tid);

  if (NULL != p)
    return p->terminated;

  return 0;
}

/* Is this pid a real PID or a TID?
 */
static int
is_process_id (int pid)
{
  lwpid_t tid;
  thread_info *tinfo;
  pid_t this_pid;
  int this_pid_count;

  /* What does PID really represent?
   */
  tid = map_from_gdb_tid (pid);
  if (tid <= 0)
    return 0;			/* Actually, is probably an error... */

  tinfo = find_thread_info (tid);

  /* Does it appear to be a true thread?
   */
  if (!tinfo->am_pseudo)
    return 0;

  /* Else, it looks like it may be a process.  See if there's any other
   * threads with the same process ID, though.  If there are, then TID
   * just happens to be the first thread of several for this process.
   */
  this_pid = tinfo->pid;
  this_pid_count = 0;
  for (tinfo = thread_head.head; tinfo; tinfo = tinfo->next)
    {
      if (tinfo->pid == this_pid)
	this_pid_count++;
    }

  return (this_pid_count == 1);
}


/* Add a thread to our info.  Prevent duplicate entries.
 */
static thread_info *
add_tthread (int pid, lwpid_t tid)
{
  thread_info *p;

  p = find_thread_info (tid);
  if (NULL == p)
    p = create_thread_info (pid, tid);

  return p;
}

/* Notice that a thread was deleted.
 */
static void
del_tthread (lwpid_t tid)
{
  thread_info *p;
  thread_info *chase;

  if (thread_head.count <= 0)
    {
      error ("Internal error in thread database.");
      return;
    }

  chase = NULL;
  for (p = thread_head.head; p; p = p->next)
    {
      if (p->tid == tid)
	{

#ifdef THREAD_DEBUG
	  if (debug_on)
	    printf ("Delete here: %d \n", tid);
#endif

	  if (p->am_pseudo)
	    {
	      /*
	       * Deleting a main thread is ok if we're doing
	       * a parent-follow on a child; this is odd but
	       * not wrong.  It apparently _doesn't_ happen
	       * on the child-follow, as we don't just delete
	       * the pseudo while keeping the rest of the
	       * threads around--instead, we clear out the whole
	       * thread list at once.
	       */
	      thread_info *q;
	      thread_info *q_chase;

	      q_chase = NULL;
	      for (q = thread_head.head_pseudo; q; q = q->next)
		{
		  if (q == p)
		    {
		      /* Remove from pseudo list.
		       */
		      if (q_chase == NULL)
			thread_head.head_pseudo = p->next_pseudo;
		      else
			q_chase->next = p->next_pseudo;
		    }
		  else
		    q_chase = q;
		}
	    }

	  /* Remove from live list.
	   */
	  thread_head.count--;

	  if (NULL == chase)
	    thread_head.head = p->next;
	  else
	    chase->next = p->next;

	  /* Add to deleted thread list.
	   */
	  p->next = deleted_threads.head;
	  deleted_threads.head = p;
	  deleted_threads.count++;
	  if (p->am_pseudo)
	    {
	      p->next_pseudo = deleted_threads.head_pseudo;
	      deleted_threads.head_pseudo = p;
	    }
	  p->terminated = 1;

	  return;
	}

      else
	chase = p;
    }
}

/* Get the pid for this tid. (Has to be a real TID!).
 */
static int
get_pid_for (lwpid_t tid)
{
  thread_info *p;

  for (p = thread_head.head; p; p = p->next)
    {
      if (p->tid == tid)
	{
	  return p->pid;
	}
    }

  for (p = deleted_threads.head; p; p = p->next)
    {
      if (p->tid == tid)
	{
	  return p->pid;
	}
    }

  return 0;
}

/* Note that this thread's current event has been handled.
 */
static void
set_handled (int pid, lwpid_t tid)
{
  thread_info *p;

  p = find_thread_info (tid);
  if (NULL == p)
    p = add_tthread (pid, tid);

  p->handled = 1;
}

/* Was this thread's current event handled?
 */
static int
was_handled (lwpid_t tid)
{
  thread_info *p;

  p = find_thread_info (tid);
  if (NULL != p)
    return p->handled;

  return 0;			/* New threads have not been handled */
}

/* Set this thread to unhandled.
 */
static void
clear_handled (lwpid_t tid)
{
  thread_info *p;

#ifdef WAIT_BUFFER_DEBUG
  if (debug_on)
    printf ("clear_handled %d\n", (int) tid);
#endif

  p = find_thread_info (tid);
  if (p == NULL)
    error ("Internal error: No thread state to clear?");

  p->handled = 0;
}

/* Set all threads to unhandled.
 */
static void
clear_all_handled (void)
{
  thread_info *p;

#ifdef WAIT_BUFFER_DEBUG
  if (debug_on)
    printf ("clear_all_handled\n");
#endif

  for (p = thread_head.head; p; p = p->next)
    {
      p->handled = 0;
    }

  for (p = deleted_threads.head; p; p = p->next)
    {
      p->handled = 0;
    }
}

/* Set this thread to default stepping mode.
 */
static void
clear_stepping_mode (lwpid_t tid)
{
  thread_info *p;

#ifdef WAIT_BUFFER_DEBUG
  if (debug_on)
    printf ("clear_stepping_mode %d\n", (int) tid);
#endif

  p = find_thread_info (tid);
  if (p == NULL)
    error ("Internal error: No thread state to clear?");

  p->stepping_mode = DO_DEFAULT;
}

/* Set all threads to do default continue on resume.
 */
static void
clear_all_stepping_mode (void)
{
  thread_info *p;

#ifdef WAIT_BUFFER_DEBUG
  if (debug_on)
    printf ("clear_all_stepping_mode\n");
#endif

  for (p = thread_head.head; p; p = p->next)
    {
      p->stepping_mode = DO_DEFAULT;
    }

  for (p = deleted_threads.head; p; p = p->next)
    {
      p->stepping_mode = DO_DEFAULT;
    }
}

/* Set all threads to unseen on this pass.
 */
static void
set_all_unseen (void)
{
  thread_info *p;

  for (p = thread_head.head; p; p = p->next)
    {
      p->seen = 0;
    }
}

#if (defined( THREAD_DEBUG ) || defined( PARANOIA ))
/* debugging routine.
 */
static void
print_tthread (thread_info *p)
{
  printf (" Thread pid %d, tid %d", p->pid, p->tid);
  if (p->have_state)
    printf (", event is %s",
	 get_printable_name_of_ttrace_event (p->last_stop_state.tts_event));

  if (p->am_pseudo)
    printf (", pseudo thread");

  if (p->have_signal)
    printf (", have signal 0x%x", p->signal_value);

  if (p->have_start)
    printf (", have start at 0x%x", p->start);

  printf (", step is %s", get_printable_name_of_stepping_mode (p->stepping_mode));

  if (p->handled)
    printf (", handled");
  else
    printf (", not handled");

  if (p->seen)
    printf (", seen");
  else
    printf (", not seen");

  printf ("\n");
}

static void
print_tthreads (void)
{
  thread_info *p;

  if (thread_head.count == 0)
    printf ("Thread list is empty\n");
  else
    {
      printf ("Thread list has ");
      if (thread_head.count == 1)
	printf ("1 entry:\n");
      else
	printf ("%d entries:\n", thread_head.count);
      for (p = thread_head.head; p; p = p->next)
	{
	  print_tthread (p);
	}
    }

  if (deleted_threads.count == 0)
    printf ("Deleted thread list is empty\n");
  else
    {
      printf ("Deleted thread list has ");
      if (deleted_threads.count == 1)
	printf ("1 entry:\n");
      else
	printf ("%d entries:\n", deleted_threads.count);

      for (p = deleted_threads.head; p; p = p->next)
	{
	  print_tthread (p);
	}
    }
}
#endif

/* Update the thread list based on the "seen" bits.
 */
static void
update_thread_list (void)
{
  thread_info *p;
  thread_info *chase;

  chase = NULL;
  for (p = thread_head.head; p; p = p->next)
    {
      /* Is this an "unseen" thread which really happens to be a process?
         If so, is it inferior_ptid and is a vfork in flight?  If yes to
         all, then DON'T REMOVE IT!  We're in the midst of moving a vfork
         operation, which is a multiple step thing, to the point where we
         can touch the parent again.  We've most likely stopped to examine
         the child at a late stage in the vfork, and if we're not following
         the child, we'd best not treat the parent as a dead "thread"...
       */
      if ((!p->seen) && p->am_pseudo && vfork_in_flight
	  && (p->pid != vforking_child_pid))
	p->seen = 1;

      if (!p->seen)
	{
	  /* Remove this one
	   */

#ifdef THREAD_DEBUG
	  if (debug_on)
	    printf ("Delete unseen thread: %d \n", p->tid);
#endif
	  del_tthread (p->tid);
	}
    }
}



/************************************************
 *            O/S call wrappers                 *
 ************************************************
 */

/* This function simply calls ttrace with the given arguments.  
 * It exists so that all calls to ttrace are isolated.  All
 * parameters should be as specified by "man 2 ttrace".
 *
 * No other "raw" calls to ttrace should exist in this module.
 */
static int
call_real_ttrace (ttreq_t request, pid_t pid, lwpid_t tid, TTRACE_ARG_TYPE addr,
		  TTRACE_ARG_TYPE data, TTRACE_ARG_TYPE addr2)
{
  int tt_status;

  errno = 0;
  tt_status = ttrace (request, pid, tid, addr, data, addr2);

#ifdef THREAD_DEBUG
  if (errno)
    {
      /* Don't bother for a known benign error: if you ask for the
       * first thread state, but there is only one thread and it's
       * not stopped, ttrace complains.
       *
       * We have this inside the #ifdef because our caller will do
       * this check for real.
       */
      if (request != TT_PROC_GET_FIRST_LWP_STATE
	  || errno != EPROTO)
	{
	  if (debug_on)
	    printf ("TT fail for %s, with pid %d, tid %d, status %d \n",
		    get_printable_name_of_ttrace_request (request),
		    pid, tid, tt_status);
	}
    }
#endif

#if 0
  /* ??rehrauer: It would probably be most robust to catch and report
   * failed requests here.  However, some clients of this interface
   * seem to expect to catch & deal with them, so we'd best not.
   */
  if (errno)
    {
      strcpy (reason_for_failure, "ttrace (");
      strcat (reason_for_failure, get_printable_name_of_ttrace_request (request));
      strcat (reason_for_failure, ")");
      printf ("ttrace error, errno = %d\n", errno);
      perror_with_name (reason_for_failure);
    }
#endif

  return tt_status;
}


/* This function simply calls ttrace_wait with the given arguments.  
 * It exists so that all calls to ttrace_wait are isolated.
 *
 * No "raw" calls to ttrace_wait should exist elsewhere.
 */
static int
call_real_ttrace_wait (int pid, lwpid_t tid, ttwopt_t option, ttstate_t *tsp,
		       size_t tsp_size)
{
  int ttw_status;
  thread_info *tinfo = NULL;

  errno = 0;
  ttw_status = ttrace_wait (pid, tid, option, tsp, tsp_size);

  if (errno)
    {
#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("TW fail with pid %d, tid %d \n", pid, tid);
#endif

      perror_with_name ("ttrace wait");
    }

  return ttw_status;
}


/* A process may have one or more kernel threads, of which all or
   none may be stopped.  This function returns the ID of the first
   kernel thread in a stopped state, or 0 if none are stopped.

   This function can be used with get_process_next_stopped_thread_id
   to iterate over the IDs of all stopped threads of this process.
 */
static lwpid_t
get_process_first_stopped_thread_id (int pid, ttstate_t *thread_state)
{
  int tt_status;

  tt_status = call_real_ttrace (TT_PROC_GET_FIRST_LWP_STATE,
				(pid_t) pid,
				(lwpid_t) TT_NIL,
				(TTRACE_ARG_TYPE) thread_state,
				(TTRACE_ARG_TYPE) sizeof (*thread_state),
				TT_NIL);

  if (errno)
    {
      if (errno == EPROTO)
	{
	  /* This is an error we can handle: there isn't any stopped
	   * thread.  This happens when we're re-starting the application
	   * and it has only one thread.  GET_NEXT handles the case of
	   * no more stopped threads well; GET_FIRST doesn't.  (A ttrace
	   * "feature".)
	   */
	  tt_status = 1;
	  errno = 0;
	  return 0;
	}
      else
	perror_with_name ("ttrace");
    }

  if (tt_status < 0)
    /* Failed somehow.
     */
    return 0;

  return thread_state->tts_lwpid;
}


/* This function returns the ID of the "next" kernel thread in a
   stopped state, or 0 if there are none.  "Next" refers to the
   thread following that of the last successful call to this
   function or to get_process_first_stopped_thread_id, using
   the value of thread_state returned by that call.

   This function can be used with get_process_first_stopped_thread_id
   to iterate over the IDs of all stopped threads of this process.
 */
static lwpid_t
get_process_next_stopped_thread_id (int pid, ttstate_t *thread_state)
{
  int tt_status;

  tt_status = call_real_ttrace (
				 TT_PROC_GET_NEXT_LWP_STATE,
				 (pid_t) pid,
				 (lwpid_t) TT_NIL,
				 (TTRACE_ARG_TYPE) thread_state,
				 (TTRACE_ARG_TYPE) sizeof (*thread_state),
				 TT_NIL);
  if (errno)
    perror_with_name ("ttrace");

  if (tt_status < 0)
    /* Failed
     */
    return 0;

  else if (tt_status == 0)
    {
      /* End of list, no next state.  Don't return the
       * tts_lwpid, as it's a meaningless "240".
       *
       * This is an HPUX "feature".
       */
      return 0;
    }

  return thread_state->tts_lwpid;
}

/* ??rehrauer: Eventually this function perhaps should be calling
   pid_to_thread_id.  However, that function currently does nothing
   for HP-UX.  Even then, I'm not clear whether that function
   will return a "kernel" thread ID, or a "user" thread ID.  If
   the former, we can just call it here.  If the latter, we must
   map from the "user" tid to a "kernel" tid.

   NOTE: currently not called.
 */
static lwpid_t
get_active_tid_of_pid (int pid)
{
  ttstate_t thread_state;

  return get_process_first_stopped_thread_id (pid, &thread_state);
}

/* This function returns 1 if tt_request is a ttrace request that
 * operates upon all threads of a (i.e., the entire) process.
 */
int
is_process_ttrace_request (ttreq_t tt_request)
{
  return IS_TTRACE_PROCREQ (tt_request);
}


/* This function translates a thread ttrace request into
 * the equivalent process request for a one-thread process.
 */
static ttreq_t
make_process_version (ttreq_t request)
{
  if (!IS_TTRACE_REQ (request))
    {
      error ("Internal error, bad ttrace request made\n");
      return -1;
    }

  switch (request)
    {
    case TT_LWP_STOP:
      return TT_PROC_STOP;

    case TT_LWP_CONTINUE:
      return TT_PROC_CONTINUE;

    case TT_LWP_GET_EVENT_MASK:
      return TT_PROC_GET_EVENT_MASK;

    case TT_LWP_SET_EVENT_MASK:
      return TT_PROC_SET_EVENT_MASK;

    case TT_LWP_SINGLE:
    case TT_LWP_RUREGS:
    case TT_LWP_WUREGS:
    case TT_LWP_GET_STATE:
      return -1;		/* No equivalent */

    default:
      return request;
    }
}


/* This function translates the "pid" used by the rest of
 * gdb to a real pid and a tid.  It then calls "call_real_ttrace"
 * with the given arguments.
 *
 * In general, other parts of this module should call this
 * function when they are dealing with external users, who only
 * have tids to pass (but they call it "pid" for historical
 * reasons).
 */
static int
call_ttrace (ttreq_t request, int gdb_tid, TTRACE_ARG_TYPE addr,
	     TTRACE_ARG_TYPE data, TTRACE_ARG_TYPE addr2)
{
  lwpid_t real_tid;
  int real_pid;
  ttreq_t new_request;
  int tt_status;
  char reason_for_failure[100];	/* Arbitrary size, should be big enough. */

#ifdef THREAD_DEBUG
  int is_interesting = 0;

  if (TT_LWP_RUREGS == request)
    {
      is_interesting = 1;	/* Adjust code here as desired */
    }

  if (is_interesting && 0 && debug_on)
    {
      if (!is_process_ttrace_request (request))
	{
	  printf ("TT: Thread request, tid is %d", gdb_tid);
	  printf ("== SINGLE at %x", addr);
	}
      else
	{
	  printf ("TT: Process request, tid is %d\n", gdb_tid);
	  printf ("==! SINGLE at %x", addr);
	}
    }
#endif

  /* The initial SETTRC and SET_EVENT_MASK calls (and all others
   * which happen before any threads get set up) should go
   * directly to "call_real_ttrace", so they don't happen here.
   *
   * But hardware watchpoints do a SET_EVENT_MASK, so we can't
   * rule them out....
   */
#ifdef THREAD_DEBUG
  if (request == TT_PROC_SETTRC && debug_on)
    printf ("Unexpected call for TT_PROC_SETTRC\n");
#endif

  /* Sometimes we get called with a bogus tid (e.g., if a
   * thread has terminated, we return 0; inftarg later asks
   * whether the thread has exited/forked/vforked).
   */
  if (gdb_tid == 0)
    {
      errno = ESRCH;		/* ttrace's response would probably be "No such process". */
      return -1;
    }

  /* All other cases should be able to expect that there are
   * thread records.
   */
  if (!any_thread_records ())
    {
#ifdef THREAD_DEBUG
      if (debug_on)
	warning ("No thread records for ttrace call");
#endif
      errno = ESRCH;		/* ttrace's response would be "No such process". */
      return -1;
    }

  /* OK, now the task is to translate the incoming tid into
   * a pid/tid pair.
   */
  real_tid = map_from_gdb_tid (gdb_tid);
  real_pid = get_pid_for (real_tid);

  /* Now check the result.  "Real_pid" is NULL if our list
   * didn't find it.  We have some tricks we can play to fix
   * this, however.
   */
  if (0 == real_pid)
    {
      ttstate_t thread_state;

#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("No saved pid for tid %d\n", gdb_tid);
#endif

      if (is_process_ttrace_request (request))
	{

	  /* Ok, we couldn't get a tid.  Try to translate to
	   * the equivalent process operation.  We expect this
	   * NOT to happen, so this is a desparation-type
	   * move.  It can happen if there is an internal
	   * error and so no "wait()" call is ever done.
	   */
	  new_request = make_process_version (request);
	  if (new_request == -1)
	    {

#ifdef THREAD_DEBUG
	      if (debug_on)
		printf ("...and couldn't make process version of thread operation\n");
#endif

	      /* Use hacky saved pid, which won't always be correct
	       * in the multi-process future.  Use tid as thread,
	       * probably dooming this to failure.  FIX!
	       */
	      if (! ptid_equal (saved_real_ptid, null_ptid))
		{
#ifdef THREAD_DEBUG
		  if (debug_on)
		    printf ("...using saved pid %d\n",
		            PIDGET (saved_real_ptid));
#endif

		  real_pid = PIDGET (saved_real_ptid);
		  real_tid = gdb_tid;
		}

	      else
		error ("Unable to perform thread operation");
	    }

	  else
	    {
	      /* Sucessfully translated this to a process request,
	       * which needs no thread value.
	       */
	      real_pid = gdb_tid;
	      real_tid = 0;
	      request = new_request;

#ifdef THREAD_DEBUG
	      if (debug_on)
		{
		  printf ("Translated thread request to process request\n");
		  if (ptid_equal (saved_real_ptid, null_ptid))
		    printf ("...but there's no saved pid\n");

		  else
		    {
		      if (gdb_tid != PIDGET (saved_real_ptid))
			printf ("...but have the wrong pid (%d rather than %d)\n",
				gdb_tid, PIDGET (saved_real_ptid));
		    }
		}
#endif
	    }			/* Translated to a process request */
	}			/* Is a process request */

      else
	{
	  /* We have to have a thread.  Ooops.
	   */
	  error ("Thread request with no threads (%s)",
		 get_printable_name_of_ttrace_request (request));
	}
    }

  /* Ttrace doesn't like to see tid values on process requests,
   * even if we have the right one.
   */
  if (is_process_ttrace_request (request))
    {
      real_tid = 0;
    }

#ifdef THREAD_DEBUG
  if (is_interesting && 0 && debug_on)
    {
      printf ("    now tid %d, pid %d\n", real_tid, real_pid);
      printf ("    request is %s\n", get_printable_name_of_ttrace_request (request));
    }
#endif

  /* Finally, the (almost) real call.
   */
  tt_status = call_real_ttrace (request, real_pid, real_tid, addr, data, addr2);

#ifdef THREAD_DEBUG
  if (is_interesting && debug_on)
    {
      if (!TT_OK (tt_status, errno)
	  && !(tt_status == 0 & errno == 0))
	printf (" got error (errno==%d, status==%d)\n", errno, tt_status);
    }
#endif

  return tt_status;
}


/* Stop all the threads of a process.

 * NOTE: use of TT_PROC_STOP can cause a thread with a real event
 *       to get a TTEVT_NONE event, discarding the old event.  Be
 *       very careful, and only call TT_PROC_STOP when you mean it!
 */
static void
stop_all_threads_of_process (pid_t real_pid)
{
  int ttw_status;

  ttw_status = call_real_ttrace (TT_PROC_STOP,
				 (pid_t) real_pid,
				 (lwpid_t) TT_NIL,
				 (TTRACE_ARG_TYPE) TT_NIL,
				 (TTRACE_ARG_TYPE) TT_NIL,
				 TT_NIL);
  if (errno)
    perror_with_name ("ttrace stop of other threads");
}


/* Under some circumstances, it's unsafe to attempt to stop, or even
   query the state of, a process' threads.

   In ttrace-based HP-UX, an example is a vforking child process.  The
   vforking parent and child are somewhat fragile, w/r/t what we can do
   what we can do to them with ttrace, until after the child exits or
   execs, or until the parent's vfork event is delivered.  Until that
   time, we must not try to stop the process' threads, or inquire how
   many there are, or even alter its data segments, or it typically dies
   with a SIGILL.  Sigh.

   This function returns 1 if this stopped process, and the event that
   we're told was responsible for its current stopped state, cannot safely
   have its threads examined.
 */
#define CHILD_VFORKED(evt,pid) \
  (((evt) == TTEVT_VFORK) && ((pid) != PIDGET (inferior_ptid)))
#define CHILD_URPED(evt,pid) \
  ((((evt) == TTEVT_EXEC) || ((evt) == TTEVT_EXIT)) && ((pid) != vforking_child_pid))
#define PARENT_VFORKED(evt,pid) \
  (((evt) == TTEVT_VFORK) && ((pid) == PIDGET (inferior_ptid)))

static int
can_touch_threads_of_process (int pid, ttevents_t stopping_event)
{
  if (CHILD_VFORKED (stopping_event, pid))
    {
      vforking_child_pid = pid;
      vfork_in_flight = 1;
    }

  else if (vfork_in_flight &&
	   (PARENT_VFORKED (stopping_event, pid) ||
	    CHILD_URPED (stopping_event, pid)))
    {
      vfork_in_flight = 0;
      vforking_child_pid = 0;
    }

  return !vfork_in_flight;
}


/* If we can find an as-yet-unhandled thread state of a
 * stopped thread of this process return 1 and set "tsp".
 * Return 0 if we can't.
 *
 * If this function is used when the threads of PIS haven't
 * been stopped, undefined behaviour is guaranteed!
 */
static int
select_stopped_thread_of_process (int pid, ttstate_t *tsp)
{
  lwpid_t candidate_tid, tid;
  ttstate_t candidate_tstate, tstate;

  /* If we're not allowed to touch the process now, then just
   * return the current value of *TSP.
   *
   * This supports "vfork".  It's ok, really, to double the
   * current event (the child EXEC, we hope!).
   */
  if (!can_touch_threads_of_process (pid, tsp->tts_event))
    return 1;

  /* Decide which of (possibly more than one) events to
   * return as the first one.  We scan them all so that
   * we always return the result of a fake-step first.
   */
  candidate_tid = 0;
  for (tid = get_process_first_stopped_thread_id (pid, &tstate);
       tid != 0;
       tid = get_process_next_stopped_thread_id (pid, &tstate))
    {
      /* TTEVT_NONE events are uninteresting to our clients.  They're
       * an artifact of our "stop the world" model--the thread is
       * stopped because we stopped it.
       */
      if (tstate.tts_event == TTEVT_NONE)
	{
	  set_handled (pid, tstate.tts_lwpid);
	}

      /* Did we just single-step a single thread, without letting any
       * of the others run?  Is this an event for that thread?
       *
       * If so, we believe our client would prefer to see this event
       * over any others.  (Typically the client wants to just push
       * one thread a little farther forward, and then go around
       * checking for what all threads are doing.)
       */
      else if (doing_fake_step && (tstate.tts_lwpid == fake_step_tid))
	{
#ifdef WAIT_BUFFER_DEBUG
	  /* It's possible here to see either a SIGTRAP (due to
	   * successful completion of a step) or a SYSCALL_ENTRY
	   * (due to a step completion with active hardware
	   * watchpoints).
	   */
	  if (debug_on)
	    printf ("Ending fake step with tid %d, state %s\n",
		    tstate.tts_lwpid,
		    get_printable_name_of_ttrace_event (tstate.tts_event));
#endif

	  /* Remember this one, and throw away any previous
	   * candidate.
	   */
	  candidate_tid = tstate.tts_lwpid;
	  candidate_tstate = tstate;
	}

#ifdef FORGET_DELETED_BPTS

      /* We can't just do this, as if we do, and then wind
       * up the loop with no unhandled events, we need to
       * handle that case--the appropriate reaction is to
       * just continue, but there's no easy way to do that.
       *
       * Better to put this in the ttrace_wait call--if, when
       * we fake a wait, we update our events based on the
       * breakpoint_here_pc call and find there are no more events,
       * then we better continue and so on.
       *
       * Or we could put it in the next/continue fake.
       * But it has to go in the buffering code, not in the
       * real go/wait code.
       */
      else if ((TTEVT_SIGNAL == tstate.tts_event)
	       && (5 == tstate.tts_u.tts_signal.tts_signo)
	       && (0 != get_raw_pc (tstate.tts_lwpid))
	       && !breakpoint_here_p (get_raw_pc (tstate.tts_lwpid)))
	{
	  /*
	   * If the user deleted a breakpoint while this
	   * breakpoint-hit event was buffered, we can forget
	   * it now.
	   */
#ifdef WAIT_BUFFER_DEBUG
	  if (debug_on)
	    printf ("Forgetting deleted bp hit for thread %d\n",
		    tstate.tts_lwpid);
#endif

	  set_handled (pid, tstate.tts_lwpid);
	}
#endif

      /* Else, is this the first "unhandled" event?  If so,
       * we believe our client wants to see it (if we don't
       * see a fake-step later on in the scan).
       */
      else if (!was_handled (tstate.tts_lwpid) && candidate_tid == 0)
	{
	  candidate_tid = tstate.tts_lwpid;
	  candidate_tstate = tstate;
	}

      /* This is either an event that has already been "handled",
       * and thus we believe is uninteresting to our client, or we
       * already have a candidate event.  Ignore it...
       */
    }

  /* What do we report?
   */
  if (doing_fake_step)
    {
      if (candidate_tid == fake_step_tid)
	{
	  /* Fake step.
	   */
	  tstate = candidate_tstate;
	}
      else
	{
	  warning ("Internal error: fake-step failed to complete.");
	  return 0;
	}
    }
  else if (candidate_tid != 0)
    {
      /* Found a candidate unhandled event.
       */
      tstate = candidate_tstate;
    }
  else if (tid != 0)
    {
      warning ("Internal error in call of ttrace_wait.");
      return 0;
    }
  else
    {
      warning ("Internal error: no unhandled thread event to select");
      return 0;
    }

  copy_ttstate_t (tsp, &tstate);
  return 1;
}				/* End of select_stopped_thread_of_process */

#ifdef PARANOIA
/* Check our internal thread data against the real thing.
 */
static void
check_thread_consistency (pid_t real_pid)
{
  int tid;			/* really lwpid_t */
  ttstate_t tstate;
  thread_info *p;

  /* Spin down the O/S list of threads, checking that they
   * match what we've got.
   */
  for (tid = get_process_first_stopped_thread_id (real_pid, &tstate);
       tid != 0;
       tid = get_process_next_stopped_thread_id (real_pid, &tstate))
    {

      p = find_thread_info (tid);

      if (NULL == p)
	{
	  warning ("No internal thread data for thread %d.", tid);
	  continue;
	}

      if (!p->seen)
	{
	  warning ("Inconsistent internal thread data for thread %d.", tid);
	}

      if (p->terminated)
	{
	  warning ("Thread %d is not terminated, internal error.", tid);
	  continue;
	}


#define TT_COMPARE( fld ) \
            tstate.fld != p->last_stop_state.fld

      if (p->have_state)
	{
	  if (TT_COMPARE (tts_pid)
	      || TT_COMPARE (tts_lwpid)
	      || TT_COMPARE (tts_user_tid)
	      || TT_COMPARE (tts_event)
	      || TT_COMPARE (tts_flags)
	      || TT_COMPARE (tts_scno)
	      || TT_COMPARE (tts_scnargs))
	    {
	      warning ("Internal thread data for thread %d is wrong.", tid);
	      continue;
	    }
	}
    }
}
#endif /* PARANOIA */


/* This function wraps calls to "call_real_ttrace_wait" so
 * that a actual wait is only done when all pending events
 * have been reported.
 *
 * Note that typically it is called with a pid of "0", i.e. 
 * the "don't care" value.
 *
 * Return value is the status of the pseudo wait.
 */
static int
call_ttrace_wait (int pid, ttwopt_t option, ttstate_t *tsp, size_t tsp_size)
{
  /* This holds the actual, for-real, true process ID.
   */
  static int real_pid;

  /* As an argument to ttrace_wait, zero pid
   * means "Any process", and zero tid means
   * "Any thread of the specified process".
   */
  int wait_pid = 0;
  lwpid_t wait_tid = 0;
  lwpid_t real_tid;

  int ttw_status = 0;		/* To be returned */

  thread_info *tinfo = NULL;

  if (pid != 0)
    {
      /* Unexpected case.
       */
#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("TW: Pid to wait on is %d\n", pid);
#endif

      if (!any_thread_records ())
	error ("No thread records for ttrace call w. specific pid");

      /* OK, now the task is to translate the incoming tid into
       * a pid/tid pair.
       */
      real_tid = map_from_gdb_tid (pid);
      real_pid = get_pid_for (real_tid);
#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("==TW: real pid %d, real tid %d\n", real_pid, real_tid);
#endif
    }


  /* Sanity checks and set-up.
   *                             Process State
   *
   *                        Stopped   Running    Fake-step  (v)Fork
   *                      \________________________________________
   *                      |
   *  No buffered events  |  error     wait       wait      wait
   *                      |
   *  Buffered events     |  debuffer  error      wait      debuffer (?)
   *
   */
  if (more_events_left == 0)
    {

      if (process_state == RUNNING)
	{
	  /* OK--normal call of ttrace_wait with no buffered events.
	   */
	  ;
	}
      else if (process_state == FAKE_STEPPING)
	{
	  /* Ok--call of ttrace_wait to support
	   * fake stepping with no buffered events.
	   *
	   * But we better be fake-stepping!
	   */
	  if (!doing_fake_step)
	    {
	      warning ("Inconsistent thread state.");
	    }
	}
      else if ((process_state == FORKING)
	       || (process_state == VFORKING))
	{
	  /* Ok--there are two processes, so waiting
	   * for the second while the first is stopped
	   * is ok.  Handled bits stay as they were.
	   */
	  ;
	}
      else if (process_state == STOPPED)
	{
	  warning ("Process not running at wait call.");
	}
      else
	/* No known state.
	 */
	warning ("Inconsistent process state.");
    }

  else
    {
      /* More events left
       */
      if (process_state == STOPPED)
	{
	  /* OK--buffered events being unbuffered.
	   */
	  ;
	}
      else if (process_state == RUNNING)
	{
	  /* An error--shouldn't have buffered events
	   * when running.
	   */
	  warning ("Trying to continue with buffered events:");
	}
      else if (process_state == FAKE_STEPPING)
	{
	  /*
	   * Better be fake-stepping!
	   */
	  if (!doing_fake_step)
	    {
	      warning ("Losing buffered thread events!\n");
	    }
	}
      else if ((process_state == FORKING)
	       || (process_state == VFORKING))
	{
	  /* Ok--there are two processes, so waiting
	   * for the second while the first is stopped
	   * is ok.  Handled bits stay as they were.
	   */
	  ;
	}
      else
	warning ("Process in unknown state with buffered events.");
    }

  /* Sometimes we have to wait for a particular thread
   * (if we're stepping over a bpt).  In that case, we
   * _know_ it's going to complete the single-step we
   * asked for (because we're only doing the step under
   * certain very well-understood circumstances), so it
   * can't block.
   */
  if (doing_fake_step)
    {
      wait_tid = fake_step_tid;
      wait_pid = get_pid_for (fake_step_tid);

#ifdef WAIT_BUFFER_DEBUG
      if (debug_on)
	printf ("Doing a wait after a fake-step for %d, pid %d\n",
		wait_tid, wait_pid);
#endif
    }

  if (more_events_left == 0	/* No buffered events, need real ones. */
      || process_state != STOPPED)
    {
      /* If there are no buffered events, and so we need
       * real ones, or if we are FORKING, VFORKING, 
       * FAKE_STEPPING or RUNNING, and thus have to do
       * a real wait, then do a real wait.
       */

#ifdef WAIT_BUFFER_DEBUG
      /* Normal case... */
      if (debug_on)
	printf ("TW: do it for real; pid %d, tid %d\n", wait_pid, wait_tid);
#endif

      /* The actual wait call.
       */
      ttw_status = call_real_ttrace_wait (wait_pid, wait_tid, option, tsp, tsp_size);

      /* Note that the routines we'll call will be using "call_real_ttrace",
       * not "call_ttrace", and thus need the real pid rather than the pseudo-tid
       * the rest of the world uses (which is actually the tid).
       */
      real_pid = tsp->tts_pid;

      /* For most events: Stop the world!

       * It's sometimes not safe to stop all threads of a process.
       * Sometimes it's not even safe to ask for the thread state
       * of a process!
       */
      if (can_touch_threads_of_process (real_pid, tsp->tts_event))
	{
	  /* If we're really only stepping a single thread, then don't
	   * try to stop all the others -- we only do this single-stepping
	   * business when all others were already stopped...and the stop
	   * would mess up other threads' events.
	   *
	   * Similiarly, if there are other threads with events,
	   * don't do the stop.
	   */
	  if (!doing_fake_step)
	    {
	      if (more_events_left > 0)
		warning ("Internal error in stopping process");

	      stop_all_threads_of_process (real_pid);

	      /* At this point, we could scan and update_thread_list(),
	       * and only use the local list for the rest of the
	       * module! We'd get rid of the scans in the various
	       * continue routines (adding one in attach).  It'd
	       * be great--UPGRADE ME!
	       */
	    }
	}

#ifdef PARANOIA
      else if (debug_on)
	{
	  if (more_events_left > 0)
	    printf ("== Can't stop process; more events!\n");
	  else
	    printf ("== Can't stop process!\n");
	}
#endif

      process_state = STOPPED;

#ifdef WAIT_BUFFER_DEBUG
      if (debug_on)
	printf ("Process set to STOPPED\n");
#endif
    }

  else
    {
      /* Fake a call to ttrace_wait.  The process must be
       * STOPPED, as we aren't going to do any wait.
       */
#ifdef WAIT_BUFFER_DEBUG
      if (debug_on)
	printf ("TW: fake it\n");
#endif

      if (process_state != STOPPED)
	{
	  warning ("Process not stopped at wait call, in state '%s'.\n",
		   get_printable_name_of_process_state (process_state));
	}

      if (doing_fake_step)
	error ("Internal error in stepping over breakpoint");

      ttw_status = 0;		/* Faking it is always successful! */
    }				/* End of fake or not? if */

  /* Pick an event to pass to our caller.  Be paranoid.
   */
  if (!select_stopped_thread_of_process (real_pid, tsp))
    warning ("Can't find event, using previous event.");

  else if (tsp->tts_event == TTEVT_NONE)
    warning ("Internal error: no thread has a real event.");

  else if (doing_fake_step)
    {
      if (fake_step_tid != tsp->tts_lwpid)
	warning ("Internal error in stepping over breakpoint.");

      /* This wait clears the (current) fake-step if there was one.
       */
      doing_fake_step = 0;
      fake_step_tid = 0;
    }

  /* We now have a correct tsp and ttw_status for the thread
   * which we want to report.  So it's "handled"!  This call
   * will add it to our list if it's not there already.
   */
  set_handled (real_pid, tsp->tts_lwpid);

  /* Save a copy of the ttrace state of this thread, in our local
     thread descriptor.

     This caches the state.  The implementation of queries like
     hpux_has_execd can then use this cached state, rather than
     be forced to make an explicit ttrace call to get it.

     (Guard against the condition that this is the first time we've
     waited on, i.e., seen this thread, and so haven't yet entered
     it into our list of threads.)
   */
  tinfo = find_thread_info (tsp->tts_lwpid);
  if (tinfo != NULL)
    {
      copy_ttstate_t (&tinfo->last_stop_state, tsp);
      tinfo->have_state = 1;
    }

  return ttw_status;
}				/* call_ttrace_wait */

#if defined(CHILD_REPORTED_EXEC_EVENTS_PER_EXEC_CALL)
int
child_reported_exec_events_per_exec_call (void)
{
  return 1;			/* ttrace reports the event once per call. */
}
#endif



/* Our implementation of hardware watchpoints involves making memory
   pages write-protected.  We must remember a page's original permissions,
   and we must also know when it is appropriate to restore a page's
   permissions to its original state.

   We use a "dictionary" of hardware-watched pages to do this.  Each
   hardware-watched page is recorded in the dictionary.  Each page's
   dictionary entry contains the original permissions and a reference
   count.  Pages are hashed into the dictionary by their start address.

   When hardware watchpoint is set on page X for the first time, page X
   is added to the dictionary with a reference count of 1.  If other
   hardware watchpoints are subsequently set on page X, its reference
   count is incremented.  When hardware watchpoints are removed from
   page X, its reference count is decremented.  If a page's reference
   count drops to 0, it's permissions are restored and the page's entry
   is thrown out of the dictionary.
 */
typedef struct memory_page
{
  CORE_ADDR page_start;
  int reference_count;
  int original_permissions;
  struct memory_page *next;
  struct memory_page *previous;
}
memory_page_t;

#define MEMORY_PAGE_DICTIONARY_BUCKET_COUNT  128

static struct
  {
    LONGEST page_count;
    int page_size;
    int page_protections_allowed;
    /* These are just the heads of chains of actual page descriptors. */
    memory_page_t buckets[MEMORY_PAGE_DICTIONARY_BUCKET_COUNT];
  }
memory_page_dictionary;


static void
require_memory_page_dictionary (void)
{
  int i;

  /* Is the memory page dictionary ready for use?  If so, we're done. */
  if (memory_page_dictionary.page_count >= (LONGEST) 0)
    return;

  /* Else, initialize it. */
  memory_page_dictionary.page_count = (LONGEST) 0;

  for (i = 0; i < MEMORY_PAGE_DICTIONARY_BUCKET_COUNT; i++)
    {
      memory_page_dictionary.buckets[i].page_start = (CORE_ADDR) 0;
      memory_page_dictionary.buckets[i].reference_count = 0;
      memory_page_dictionary.buckets[i].next = NULL;
      memory_page_dictionary.buckets[i].previous = NULL;
    }
}


static void
retire_memory_page_dictionary (void)
{
  memory_page_dictionary.page_count = (LONGEST) - 1;
}


/* Write-protect the memory page that starts at this address.

   Returns the original permissions of the page.
 */
static int
write_protect_page (int pid, CORE_ADDR page_start)
{
  int tt_status;
  int original_permissions;
  int new_permissions;

  tt_status = call_ttrace (TT_PROC_GET_MPROTECT,
			   pid,
			   (TTRACE_ARG_TYPE) page_start,
			   TT_NIL,
			   (TTRACE_ARG_TYPE) & original_permissions);
  if (errno || (tt_status < 0))
    {
      return 0;			/* What else can we do? */
    }

  /* We'll also write-protect the page now, if that's allowed. */
  if (memory_page_dictionary.page_protections_allowed)
    {
      new_permissions = original_permissions & ~PROT_WRITE;
      tt_status = call_ttrace (TT_PROC_SET_MPROTECT,
			       pid,
			       (TTRACE_ARG_TYPE) page_start,
			 (TTRACE_ARG_TYPE) memory_page_dictionary.page_size,
			       (TTRACE_ARG_TYPE) new_permissions);
      if (errno || (tt_status < 0))
	{
	  return 0;		/* What else can we do? */
	}
    }

  return original_permissions;
}


/* Unwrite-protect the memory page that starts at this address, restoring
   (what we must assume are) its original permissions.
 */
static void
unwrite_protect_page (int pid, CORE_ADDR page_start, int original_permissions)
{
  int tt_status;

  tt_status = call_ttrace (TT_PROC_SET_MPROTECT,
			   pid,
			   (TTRACE_ARG_TYPE) page_start,
			 (TTRACE_ARG_TYPE) memory_page_dictionary.page_size,
			   (TTRACE_ARG_TYPE) original_permissions);
  if (errno || (tt_status < 0))
    {
      return;			/* What else can we do? */
    }
}


/* Memory page-protections are used to implement "hardware" watchpoints
   on HP-UX.

   For every memory page that is currently being watched (i.e., that
   presently should be write-protected), write-protect it.
 */
void
hppa_enable_page_protection_events (int pid)
{
  int bucket;

  memory_page_dictionary.page_protections_allowed = 1;

  for (bucket = 0; bucket < MEMORY_PAGE_DICTIONARY_BUCKET_COUNT; bucket++)
    {
      memory_page_t *page;

      page = memory_page_dictionary.buckets[bucket].next;
      while (page != NULL)
	{
	  page->original_permissions = write_protect_page (pid, page->page_start);
	  page = page->next;
	}
    }
}


/* Memory page-protections are used to implement "hardware" watchpoints
   on HP-UX.

   For every memory page that is currently being watched (i.e., that
   presently is or should be write-protected), un-write-protect it.
 */
void
hppa_disable_page_protection_events (int pid)
{
  int bucket;

  for (bucket = 0; bucket < MEMORY_PAGE_DICTIONARY_BUCKET_COUNT; bucket++)
    {
      memory_page_t *page;

      page = memory_page_dictionary.buckets[bucket].next;
      while (page != NULL)
	{
	  unwrite_protect_page (pid, page->page_start, page->original_permissions);
	  page = page->next;
	}
    }

  memory_page_dictionary.page_protections_allowed = 0;
}

/* Count the number of outstanding events.  At this
 * point, we have selected one thread and its event
 * as the one to be "reported" upwards to core gdb.
 * That thread is already marked as "handled".
 *
 * Note: we could just scan our own thread list.  FIXME!
 */
static int
count_unhandled_events (int real_pid, lwpid_t real_tid)
{
  ttstate_t tstate;
  lwpid_t ttid;
  int events_left;

  /* Ok, find out how many threads have real events to report.
   */
  events_left = 0;
  ttid = get_process_first_stopped_thread_id (real_pid, &tstate);

#ifdef THREAD_DEBUG
  if (debug_on)
    {
      if (ttid == 0)
	printf ("Process %d has no threads\n", real_pid);
      else
	printf ("Process %d has these threads:\n", real_pid);
    }
#endif

  while (ttid > 0)
    {
      if (tstate.tts_event != TTEVT_NONE
	  && !was_handled (ttid))
	{
	  /* TTEVT_NONE implies we just stopped it ourselves
	   * because we're the stop-the-world guys, so it's
	   * not an event from our point of view.
	   *
	   * If "was_handled" is true, this is an event we
	   * already handled, so don't count it.
	   *
	   * Note that we don't count the thread with the
	   * currently-reported event, as it's already marked
	   * as handled.
	   */
	  events_left++;
	}

#if defined( THREAD_DEBUG ) || defined( WAIT_BUFFER_DEBUG )
      if (debug_on)
	{
	  if (ttid == real_tid)
	    printf ("*");	/* Thread we're reporting */
	  else
	    printf (" ");

	  if (tstate.tts_event != TTEVT_NONE)
	    printf ("+");	/* Thread with a real event */
	  else
	    printf (" ");

	  if (was_handled (ttid))
	    printf ("h");	/* Thread has been handled */
	  else
	    printf (" ");

	  printf (" %d, with event %s", ttid,
		  get_printable_name_of_ttrace_event (tstate.tts_event));

	  if (tstate.tts_event == TTEVT_SIGNAL
	      && 5 == tstate.tts_u.tts_signal.tts_signo)
	    {
	      CORE_ADDR pc_val;

	      pc_val = get_raw_pc (ttid);

	      if (pc_val > 0)
		printf (" breakpoint at 0x%x\n", pc_val);
	      else
		printf (" bpt, can't fetch pc.\n");
	    }
	  else
	    printf ("\n");
	}
#endif

      ttid = get_process_next_stopped_thread_id (real_pid, &tstate);
    }

#if defined( THREAD_DEBUG ) || defined( WAIT_BUFFER_DEBUG )
  if (debug_on)
    if (events_left > 0)
      printf ("There are thus %d pending events\n", events_left);
#endif

  return events_left;
}

/* This function is provided as a sop to clients that are calling
 * ptrace_wait to wait for a process to stop.  (see the
 * implementation of child_wait.)  Return value is the pid for
 * the event that ended the wait.
 *
 * Note: used by core gdb and so uses the pseudo-pid (really tid).
 */
int
ptrace_wait (ptid_t ptid, int *status)
{
  ttstate_t tsp;
  int ttwait_return;
  int real_pid;
  ttstate_t state;
  lwpid_t real_tid;
  int return_pid;

  /* The ptrace implementation of this also ignores pid.
   */
  *status = 0;

  ttwait_return = call_ttrace_wait (0, TTRACE_WAITOK, &tsp, sizeof (tsp));
  if (ttwait_return < 0)
    {
      /* ??rehrauer: It appears that if our inferior exits and we
         haven't asked for exit events, that we're not getting any
         indication save a negative return from ttrace_wait and an
         errno set to ESRCH?
       */
      if (errno == ESRCH)
	{
	  *status = 0;		/* WIFEXITED */
	  return PIDGET (inferior_ptid);
	}

      warning ("Call of ttrace_wait returned with errno %d.",
	       errno);
      *status = ttwait_return;
      return PIDGET (inferior_ptid);
    }

  real_pid = tsp.tts_pid;
  real_tid = tsp.tts_lwpid;

  /* One complication is that the "tts_event" structure has
   * a set of flags, and more than one can be set.  So we
   * either have to force an order (as we do here), or handle
   * more than one flag at a time.
   */
  if (tsp.tts_event & TTEVT_LWP_CREATE)
    {

      /* Unlike what you might expect, this event is reported in
       * the _creating_ thread, and the _created_ thread (whose tid
       * we have) is still running.  So we have to stop it.  This
       * has already been done in "call_ttrace_wait", but should we
       * ever abandon the "stop-the-world" model, here's the command
       * to use:
       *
       *    call_ttrace( TT_LWP_STOP, real_tid, TT_NIL, TT_NIL, TT_NIL );
       *
       * Note that this would depend on being called _after_ "add_tthread"
       * below for the tid-to-pid translation to be done in "call_ttrace".
       */

#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("New thread: pid %d, tid %d, creator tid %d\n",
		real_pid, tsp.tts_u.tts_thread.tts_target_lwpid,
		real_tid);
#endif

      /* Now we have to return the tid of the created thread, not
       * the creating thread, or "wait_for_inferior" won't know we
       * have a new "process" (thread).  Plus we should record it
       * right, too.
       */
      real_tid = tsp.tts_u.tts_thread.tts_target_lwpid;

      add_tthread (real_pid, real_tid);
    }

  else if ((tsp.tts_event & TTEVT_LWP_TERMINATE)
	   || (tsp.tts_event & TTEVT_LWP_EXIT))
    {

#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("Thread dies: %d\n", real_tid);
#endif

      del_tthread (real_tid);
    }

  else if (tsp.tts_event & TTEVT_EXEC)
    {

#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("Pid %d has zero'th thread %d; inferior pid is %d\n",
		real_pid, real_tid, PIDGET (inferior_ptid));
#endif

      add_tthread (real_pid, real_tid);
    }

#ifdef THREAD_DEBUG
  else if (debug_on)
    {
      printf ("Process-level event %s, using tid %d\n",
	      get_printable_name_of_ttrace_event (tsp.tts_event),
	      real_tid);

      /* OK to do this, as "add_tthread" won't add
       * duplicate entries.  Also OK not to do it,
       * as this event isn't one which can change the
       * thread state.
       */
      add_tthread (real_pid, real_tid);
    }
#endif


  /* How many events are left to report later?
   * In a non-stop-the-world model, this isn't needed.
   *
   * Note that it's not always safe to query the thread state of a process,
   * which is what count_unhandled_events does.  (If unsafe, we're left with
   * no other resort than to assume that no more events remain...)
   */
  if (can_touch_threads_of_process (real_pid, tsp.tts_event))
    more_events_left = count_unhandled_events (real_pid, real_tid);

  else
    {
      if (more_events_left > 0)
	warning ("Vfork or fork causing loss of %d buffered events.",
		 more_events_left);

      more_events_left = 0;
    }

  /* Attempt to translate the ttrace_wait-returned status into the
     ptrace equivalent.

     ??rehrauer: This is somewhat fragile.  We really ought to rewrite
     clients that expect to pick apart a ptrace wait status, to use
     something a little more abstract.
   */
  if ((tsp.tts_event & TTEVT_EXEC)
      || (tsp.tts_event & TTEVT_FORK)
      || (tsp.tts_event & TTEVT_VFORK))
    {
      /* Forks come in pairs (parent and child), so core gdb
       * will do two waits.  Be ready to notice this.
       */
      if (tsp.tts_event & TTEVT_FORK)
	{
	  process_state = FORKING;

#ifdef WAIT_BUFFER_DEBUG
	  if (debug_on)
	    printf ("Process set to FORKING\n");
#endif
	}
      else if (tsp.tts_event & TTEVT_VFORK)
	{
	  process_state = VFORKING;

#ifdef WAIT_BUFFER_DEBUG
	  if (debug_on)
	    printf ("Process set to VFORKING\n");
#endif
	}

      /* Make an exec or fork look like a breakpoint.  Definitely a hack,
         but I don't think non HP-UX-specific clients really carefully
         inspect the first events they get after inferior startup, so
         it probably almost doesn't matter what we claim this is.
       */

#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("..a process 'event'\n");
#endif

      /* Also make fork and exec events look like bpts, so they can be caught.
       */
      *status = 0177 | (_SIGTRAP << 8);
    }

  /* Special-cases: We ask for syscall entry and exit events to implement
     "fast" (aka "hardware") watchpoints.

     When we get a syscall entry, we want to disable page-protections,
     and resume the inferior; this isn't an event we wish for
     wait_for_inferior to see.  Note that we must resume ONLY the
     thread that reported the syscall entry; we don't want to allow
     other threads to run with the page protections off, as they might
     then be able to write to watch memory without it being caught.

     When we get a syscall exit, we want to reenable page-protections,
     but we don't want to resume the inferior; this is an event we wish
     wait_for_inferior to see.  Make it look like the signal we normally
     get for a single-step completion.  This should cause wait_for_inferior
     to evaluate whether any watchpoint triggered.

     Or rather, that's what we'd LIKE to do for syscall exit; we can't,
     due to some HP-UX "features".  Some syscalls have problems with
     write-protections on some pages, and some syscalls seem to have
     pending writes to those pages at the time we're getting the return
     event.  So, we'll single-step the inferior to get out of the syscall,
     and then reenable protections.

     Note that we're intentionally allowing the syscall exit case to
     fall through into the succeeding cases, as sometimes we single-
     step out of one syscall only to immediately enter another...
   */
  else if ((tsp.tts_event & TTEVT_SYSCALL_ENTRY)
	   || (tsp.tts_event & TTEVT_SYSCALL_RETURN))
    {
      /* Make a syscall event look like a breakpoint.  Same comments
         as for exec & fork events.
       */
#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("..a syscall 'event'\n");
#endif

      /* Also make syscall events look like bpts, so they can be caught.
       */
      *status = 0177 | (_SIGTRAP << 8);
    }

  else if ((tsp.tts_event & TTEVT_LWP_CREATE)
	   || (tsp.tts_event & TTEVT_LWP_TERMINATE)
	   || (tsp.tts_event & TTEVT_LWP_EXIT))
    {
      /* Make a thread event look like a breakpoint.  Same comments
       * as for exec & fork events.
       */
#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("..a thread 'event'\n");
#endif

      /* Also make thread events look like bpts, so they can be caught.
       */
      *status = 0177 | (_SIGTRAP << 8);
    }

  else if ((tsp.tts_event & TTEVT_EXIT))
    {				/* WIFEXITED */

#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("..an exit\n");
#endif

      /* Prevent rest of gdb from thinking this is
       * a new thread if for some reason it's never
       * seen the main thread before.
       */
      inferior_ptid = pid_to_ptid (map_to_gdb_tid (real_tid));	/* HACK, FIX */

      *status = 0 | (tsp.tts_u.tts_exit.tts_exitcode);
    }

  else if (tsp.tts_event & TTEVT_SIGNAL)
    {				/* WIFSTOPPED */
#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("..a signal, %d\n", tsp.tts_u.tts_signal.tts_signo);
#endif

      *status = 0177 | (tsp.tts_u.tts_signal.tts_signo << 8);
    }

  else
    {				/* !WIFSTOPPED */

      /* This means the process or thread terminated.  But we should've
         caught an explicit exit/termination above.  So warn (this is
         really an internal error) and claim the process or thread
         terminated with a SIGTRAP.
       */

      warning ("process_wait: unknown process state");

#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("Process-level event %s, using tid %d\n",
		get_printable_name_of_ttrace_event (tsp.tts_event),
		real_tid);
#endif

      *status = _SIGTRAP;
    }

#ifdef THREAD_DEBUG
  if (debug_on)
    printf ("Done waiting, pid is %d, tid %d\n", real_pid, real_tid);
#endif

  /* All code external to this module uses the tid, but calls
   * it "pid".  There's some tweaking so that the outside sees
   * the first thread as having the same number as the starting
   * pid.
   */
  return_pid = map_to_gdb_tid (real_tid);

  if (real_tid == 0 || return_pid == 0)
    {
      warning ("Internal error: process-wait failed.");
    }

  return return_pid;
}


/* This function causes the caller's process to be traced by its
   parent.  This is intended to be called after GDB forks itself,
   and before the child execs the target.  Despite the name, it
   is called by the child.

   Note that HP-UX ttrace is rather funky in how this is done.
   If the parent wants to get the initial exec event of a child,
   it must set the ttrace event mask of the child to include execs.
   (The child cannot do this itself.)  This must be done after the
   child is forked, but before it execs.

   To coordinate the parent and child, we implement a semaphore using
   pipes.  After SETTRC'ing itself, the child tells the parent that
   it is now traceable by the parent, and waits for the parent's
   acknowledgement.  The parent can then set the child's event mask,
   and notify the child that it can now exec.

   (The acknowledgement by parent happens as a result of a call to
   child_acknowledge_created_inferior.)
 */
int
parent_attach_all (int p1, PTRACE_ARG3_TYPE p2, int p3)
{
  int tt_status;

  /* We need a memory home for a constant, to pass it to ttrace.
     The value of the constant is arbitrary, so long as both
     parent and child use the same value.  Might as well use the
     "magic" constant provided by ttrace...
   */
  uint64_t tc_magic_child = TT_VERSION;
  uint64_t tc_magic_parent = 0;

  tt_status = call_real_ttrace (
				 TT_PROC_SETTRC,
				 (int) TT_NIL,
				 (lwpid_t) TT_NIL,
				 TT_NIL,
				 (TTRACE_ARG_TYPE) TT_VERSION,
				 TT_NIL);

  if (tt_status < 0)
    return tt_status;

  /* Notify the parent that we're potentially ready to exec(). */
  write (startup_semaphore.child_channel[SEM_TALK],
	 &tc_magic_child,
	 sizeof (tc_magic_child));

  /* Wait for acknowledgement from the parent. */
  read (startup_semaphore.parent_channel[SEM_LISTEN],
	&tc_magic_parent,
	sizeof (tc_magic_parent));

  if (tc_magic_child != tc_magic_parent)
    warning ("mismatched semaphore magic");

  /* Discard our copy of the semaphore. */
  (void) close (startup_semaphore.parent_channel[SEM_LISTEN]);
  (void) close (startup_semaphore.parent_channel[SEM_TALK]);
  (void) close (startup_semaphore.child_channel[SEM_LISTEN]);
  (void) close (startup_semaphore.child_channel[SEM_TALK]);

  return tt_status;
}

/* Despite being file-local, this routine is dealing with
 * actual process IDs, not thread ids.  That's because it's
 * called before the first "wait" call, and there's no map
 * yet from tids to pids.
 *
 * When it is called, a forked child is running, but waiting on
 * the semaphore.  If you stop the child and re-start it,
 * things get confused, so don't do that!  An attached child is
 * stopped.
 *
 * Since this is called after either attach or run, we
 * have to be the common part of both.
 */
static void
require_notification_of_events (int real_pid)
{
  int tt_status;
  ttevent_t notifiable_events;

  lwpid_t tid;
  ttstate_t thread_state;

#ifdef THREAD_DEBUG
  if (debug_on)
    printf ("Require notif, pid is %d\n", real_pid);
#endif

  /* Temporary HACK: tell inftarg.c/child_wait to not
   * loop until pids are the same.
   */
  not_same_real_pid = 0;

  sigemptyset (&notifiable_events.tte_signals);
  notifiable_events.tte_opts = TTEO_NONE;

  /* This ensures that forked children inherit their parent's
   * event mask, which we're setting here.
   *
   * NOTE: if you debug gdb with itself, then the ultimate
   *       debuggee gets flags set by the outermost gdb, as
   *       a child of a child will still inherit.
   */
  notifiable_events.tte_opts |= TTEO_PROC_INHERIT;

  notifiable_events.tte_events = TTEVT_DEFAULT;
  notifiable_events.tte_events |= TTEVT_SIGNAL;
  notifiable_events.tte_events |= TTEVT_EXEC;
  notifiable_events.tte_events |= TTEVT_EXIT;
  notifiable_events.tte_events |= TTEVT_FORK;
  notifiable_events.tte_events |= TTEVT_VFORK;
  notifiable_events.tte_events |= TTEVT_LWP_CREATE;
  notifiable_events.tte_events |= TTEVT_LWP_EXIT;
  notifiable_events.tte_events |= TTEVT_LWP_TERMINATE;

  tt_status = call_real_ttrace (
				 TT_PROC_SET_EVENT_MASK,
				 real_pid,
				 (lwpid_t) TT_NIL,
				 (TTRACE_ARG_TYPE) & notifiable_events,
			       (TTRACE_ARG_TYPE) sizeof (notifiable_events),
				 TT_NIL);
}

static void
require_notification_of_exec_events (int real_pid)
{
  int tt_status;
  ttevent_t notifiable_events;

  lwpid_t tid;
  ttstate_t thread_state;

#ifdef THREAD_DEBUG
  if (debug_on)
    printf ("Require notif, pid is %d\n", real_pid);
#endif

  /* Temporary HACK: tell inftarg.c/child_wait to not
   * loop until pids are the same.
   */
  not_same_real_pid = 0;

  sigemptyset (&notifiable_events.tte_signals);
  notifiable_events.tte_opts = TTEO_NOSTRCCHLD;

  /* This ensures that forked children don't inherit their parent's
   * event mask, which we're setting here.
   */
  notifiable_events.tte_opts &= ~TTEO_PROC_INHERIT;

  notifiable_events.tte_events = TTEVT_DEFAULT;
  notifiable_events.tte_events |= TTEVT_EXEC;
  notifiable_events.tte_events |= TTEVT_EXIT;

  tt_status = call_real_ttrace (
				 TT_PROC_SET_EVENT_MASK,
				 real_pid,
				 (lwpid_t) TT_NIL,
				 (TTRACE_ARG_TYPE) & notifiable_events,
			       (TTRACE_ARG_TYPE) sizeof (notifiable_events),
				 TT_NIL);
}


/* This function is called by the parent process, with pid being the
 * ID of the child process, after the debugger has forked.
 */
void
child_acknowledge_created_inferior (int pid)
{
  /* We need a memory home for a constant, to pass it to ttrace.
     The value of the constant is arbitrary, so long as both
     parent and child use the same value.  Might as well use the
     "magic" constant provided by ttrace...
   */
  uint64_t tc_magic_parent = TT_VERSION;
  uint64_t tc_magic_child = 0;

  /* Wait for the child to tell us that it has forked. */
  read (startup_semaphore.child_channel[SEM_LISTEN],
	&tc_magic_child,
	sizeof (tc_magic_child));

  /* Clear thread info now.  We'd like to do this in
   * "require...", but that messes up attach.
   */
  clear_thread_info ();

  /* Tell the "rest of gdb" that the initial thread exists.
   * This isn't really a hack.  Other thread-based versions
   * of gdb (e.g. gnu-nat.c) seem to do the same thing.
   *
   * Q: Why don't we also add this thread to the local
   *    list via "add_tthread"?
   *
   * A: Because we don't know the tid, and can't stop the
   *    the process safely to ask what it is.  Anyway, we'll
   *    add it when it gets the EXEC event.
   */
  add_thread (pid_to_ptid (pid));		/* in thread.c */

  /* We can now set the child's ttrace event mask.
   */
  require_notification_of_exec_events (pid);

  /* Tell ourselves that the process is running.
   */
  process_state = RUNNING;

  /* Notify the child that it can exec. */
  write (startup_semaphore.parent_channel[SEM_TALK],
	 &tc_magic_parent,
	 sizeof (tc_magic_parent));

  /* Discard our copy of the semaphore. */
  (void) close (startup_semaphore.parent_channel[SEM_LISTEN]);
  (void) close (startup_semaphore.parent_channel[SEM_TALK]);
  (void) close (startup_semaphore.child_channel[SEM_LISTEN]);
  (void) close (startup_semaphore.child_channel[SEM_TALK]);
}


/*
 * arrange for notification of all events by
 * calling require_notification_of_events.
 */
void
child_post_startup_inferior (ptid_t ptid)
{
  require_notification_of_events (PIDGET (ptid));
}

/* From here on, we should expect tids rather than pids.
 */
static void
hppa_enable_catch_fork (int tid)
{
  int tt_status;
  ttevent_t ttrace_events;

  /* Get the set of events that are currently enabled.
   */
  tt_status = call_ttrace (TT_PROC_GET_EVENT_MASK,
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
  if (errno)
    perror_with_name ("ttrace");

  /* Add forks to that set. */
  ttrace_events.tte_events |= TTEVT_FORK;

#ifdef THREAD_DEBUG
  if (debug_on)
    printf ("enable fork, tid is %d\n", tid);
#endif

  tt_status = call_ttrace (TT_PROC_SET_EVENT_MASK,
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
  if (errno)
    perror_with_name ("ttrace");
}


static void
hppa_disable_catch_fork (int tid)
{
  int tt_status;
  ttevent_t ttrace_events;

  /* Get the set of events that are currently enabled.
   */
  tt_status = call_ttrace (TT_PROC_GET_EVENT_MASK,
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);

  if (errno)
    perror_with_name ("ttrace");

  /* Remove forks from that set. */
  ttrace_events.tte_events &= ~TTEVT_FORK;

#ifdef THREAD_DEBUG
  if (debug_on)
    printf ("disable fork, tid is %d\n", tid);
#endif

  tt_status = call_ttrace (TT_PROC_SET_EVENT_MASK,
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);

  if (errno)
    perror_with_name ("ttrace");
}


#if defined(CHILD_INSERT_FORK_CATCHPOINT)
int
child_insert_fork_catchpoint (int tid)
{
  /* Enable reporting of fork events from the kernel. */
  /* ??rehrauer: For the moment, we're always enabling these events,
     and just ignoring them if there's no catchpoint to catch them.
   */
  return 0;
}
#endif


#if defined(CHILD_REMOVE_FORK_CATCHPOINT)
int
child_remove_fork_catchpoint (int tid)
{
  /* Disable reporting of fork events from the kernel. */
  /* ??rehrauer: For the moment, we're always enabling these events,
     and just ignoring them if there's no catchpoint to catch them.
   */
  return 0;
}
#endif


static void
hppa_enable_catch_vfork (int tid)
{
  int tt_status;
  ttevent_t ttrace_events;

  /* Get the set of events that are currently enabled.
   */
  tt_status = call_ttrace (TT_PROC_GET_EVENT_MASK,
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);

  if (errno)
    perror_with_name ("ttrace");

  /* Add vforks to that set. */
  ttrace_events.tte_events |= TTEVT_VFORK;

#ifdef THREAD_DEBUG
  if (debug_on)
    printf ("enable vfork, tid is %d\n", tid);
#endif

  tt_status = call_ttrace (TT_PROC_SET_EVENT_MASK,
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);

  if (errno)
    perror_with_name ("ttrace");
}


static void
hppa_disable_catch_vfork (int tid)
{
  int tt_status;
  ttevent_t ttrace_events;

  /* Get the set of events that are currently enabled. */
  tt_status = call_ttrace (TT_PROC_GET_EVENT_MASK,
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);

  if (errno)
    perror_with_name ("ttrace");

  /* Remove vforks from that set. */
  ttrace_events.tte_events &= ~TTEVT_VFORK;

#ifdef THREAD_DEBUG
  if (debug_on)
    printf ("disable vfork, tid is %d\n", tid);
#endif
  tt_status = call_ttrace (TT_PROC_SET_EVENT_MASK,
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);

  if (errno)
    perror_with_name ("ttrace");
}


#if defined(CHILD_INSERT_VFORK_CATCHPOINT)
int
child_insert_vfork_catchpoint (int tid)
{
  /* Enable reporting of vfork events from the kernel. */
  /* ??rehrauer: For the moment, we're always enabling these events,
     and just ignoring them if there's no catchpoint to catch them.
   */
  return 0;
}
#endif


#if defined(CHILD_REMOVE_VFORK_CATCHPOINT)
int
child_remove_vfork_catchpoint (int tid)
{
  /* Disable reporting of vfork events from the kernel. */
  /* ??rehrauer: For the moment, we're always enabling these events,
     and just ignoring them if there's no catchpoint to catch them.
   */
  return 0;
}
#endif

/* Q: Do we need to map the returned process ID to a thread ID?

 * A: I don't think so--here we want a _real_ pid.  Any later
 *    operations will call "require_notification_of_events" and
 *    start the mapping.
 */
int
hpux_has_forked (int tid, int *childpid)
{
  int tt_status;
  ttstate_t ttrace_state;
  thread_info *tinfo;

  /* Do we have cached thread state that we can consult?  If so, use it. */
  tinfo = find_thread_info (map_from_gdb_tid (tid));
  if (tinfo != NULL)
    {
      copy_ttstate_t (&ttrace_state, &tinfo->last_stop_state);
    }

  /* Nope, must read the thread's current state */
  else
    {
      tt_status = call_ttrace (TT_LWP_GET_STATE,
			       tid,
			       (TTRACE_ARG_TYPE) & ttrace_state,
			       (TTRACE_ARG_TYPE) sizeof (ttrace_state),
			       TT_NIL);

      if (errno)
	perror_with_name ("ttrace");

      if (tt_status < 0)
	return 0;
    }

  if (ttrace_state.tts_event & TTEVT_FORK)
    {
      *childpid = ttrace_state.tts_u.tts_fork.tts_fpid;
      return 1;
    }

  return 0;
}

/* See hpux_has_forked for pid discussion.
 */
int
hpux_has_vforked (int tid, int *childpid)
{
  int tt_status;
  ttstate_t ttrace_state;
  thread_info *tinfo;

  /* Do we have cached thread state that we can consult?  If so, use it. */
  tinfo = find_thread_info (map_from_gdb_tid (tid));
  if (tinfo != NULL)
    copy_ttstate_t (&ttrace_state, &tinfo->last_stop_state);

  /* Nope, must read the thread's current state */
  else
    {
      tt_status = call_ttrace (TT_LWP_GET_STATE,
			       tid,
			       (TTRACE_ARG_TYPE) & ttrace_state,
			       (TTRACE_ARG_TYPE) sizeof (ttrace_state),
			       TT_NIL);

      if (errno)
	perror_with_name ("ttrace");

      if (tt_status < 0)
	return 0;
    }

  if (ttrace_state.tts_event & TTEVT_VFORK)
    {
      *childpid = ttrace_state.tts_u.tts_fork.tts_fpid;
      return 1;
    }

  return 0;
}


#if defined(CHILD_INSERT_EXEC_CATCHPOINT)
int
child_insert_exec_catchpoint (int tid)
{
  /* Enable reporting of exec events from the kernel. */
  /* ??rehrauer: For the moment, we're always enabling these events,
     and just ignoring them if there's no catchpoint to catch them.
   */
  return 0;
}
#endif


#if defined(CHILD_REMOVE_EXEC_CATCHPOINT)
int
child_remove_exec_catchpoint (int tid)
{
  /* Disable reporting of execevents from the kernel. */
  /* ??rehrauer: For the moment, we're always enabling these events,
     and just ignoring them if there's no catchpoint to catch them.
   */
  return 0;
}
#endif


int
hpux_has_execd (int tid, char **execd_pathname)
{
  int tt_status;
  ttstate_t ttrace_state;
  thread_info *tinfo;

  /* Do we have cached thread state that we can consult?  If so, use it. */
  tinfo = find_thread_info (map_from_gdb_tid (tid));
  if (tinfo != NULL)
    copy_ttstate_t (&ttrace_state, &tinfo->last_stop_state);

  /* Nope, must read the thread's current state */
  else
    {
      tt_status = call_ttrace (TT_LWP_GET_STATE,
			       tid,
			       (TTRACE_ARG_TYPE) & ttrace_state,
			       (TTRACE_ARG_TYPE) sizeof (ttrace_state),
			       TT_NIL);

      if (errno)
	perror_with_name ("ttrace");

      if (tt_status < 0)
	return 0;
    }

  if (ttrace_state.tts_event & TTEVT_EXEC)
    {
      /* See child_pid_to_exec_file in this file: this is a macro.
       */
      char *exec_file = target_pid_to_exec_file (tid);

      *execd_pathname = savestring (exec_file, strlen (exec_file));
      return 1;
    }

  return 0;
}


int
hpux_has_syscall_event (int pid, enum target_waitkind *kind, int *syscall_id)
{
  int tt_status;
  ttstate_t ttrace_state;
  thread_info *tinfo;

  /* Do we have cached thread state that we can consult?  If so, use it. */
  tinfo = find_thread_info (map_from_gdb_tid (pid));
  if (tinfo != NULL)
    copy_ttstate_t (&ttrace_state, &tinfo->last_stop_state);

  /* Nope, must read the thread's current state */
  else
    {
      tt_status = call_ttrace (TT_LWP_GET_STATE,
			       pid,
			       (TTRACE_ARG_TYPE) & ttrace_state,
			       (TTRACE_ARG_TYPE) sizeof (ttrace_state),
			       TT_NIL);

      if (errno)
	perror_with_name ("ttrace");

      if (tt_status < 0)
	return 0;
    }

  *kind = TARGET_WAITKIND_SPURIOUS;	/* Until proven otherwise... */
  *syscall_id = -1;

  if (ttrace_state.tts_event & TTEVT_SYSCALL_ENTRY)
    *kind = TARGET_WAITKIND_SYSCALL_ENTRY;
  else if (ttrace_state.tts_event & TTEVT_SYSCALL_RETURN)
    *kind = TARGET_WAITKIND_SYSCALL_RETURN;
  else
    return 0;

  *syscall_id = ttrace_state.tts_scno;
  return 1;
}



#if defined(CHILD_THREAD_ALIVE)

/* Check to see if the given thread is alive.

 * We'll trust the thread list, as the more correct
 * approach of stopping the process and spinning down
 * the OS's thread list is _very_ expensive.
 *
 * May need a FIXME for that reason.
 */
int
child_thread_alive (ptid_t ptid)
{
  lwpid_t gdb_tid = PIDGET (ptid);
  lwpid_t tid;

  /* This spins down the lists twice.
   * Possible peformance improvement here!
   */
  tid = map_from_gdb_tid (gdb_tid);
  return !is_terminated (tid);
}

#endif



/* This function attempts to read the specified number of bytes from the
   save_state_t that is our view into the hardware registers, starting at
   ss_offset, and ending at ss_offset + sizeof_buf - 1

   If this function succeeds, it deposits the fetched bytes into buf,
   and returns 0.

   If it fails, it returns a negative result.  The contents of buf are
   undefined it this function fails.
 */
int
read_from_register_save_state (int tid, TTRACE_ARG_TYPE ss_offset, char *buf,
			       int sizeof_buf)
{
  int tt_status;
  register_value_t register_value = 0;

  tt_status = call_ttrace (TT_LWP_RUREGS,
			   tid,
			   ss_offset,
			   (TTRACE_ARG_TYPE) sizeof_buf,
			   (TTRACE_ARG_TYPE) buf);

  if (tt_status == 1)
    /* Map ttrace's version of success to our version.
     * Sometime ttrace returns 0, but that's ok here.
     */
    return 0;

  return tt_status;
}


/* This function attempts to write the specified number of bytes to the
   save_state_t that is our view into the hardware registers, starting at
   ss_offset, and ending at ss_offset + sizeof_buf - 1

   If this function succeeds, it deposits the bytes in buf, and returns 0.

   If it fails, it returns a negative result.  The contents of the save_state_t
   are undefined it this function fails.
 */
int
write_to_register_save_state (int tid, TTRACE_ARG_TYPE ss_offset, char *buf,
			      int sizeof_buf)
{
  int tt_status;
  register_value_t register_value = 0;

  tt_status = call_ttrace (TT_LWP_WUREGS,
			   tid,
			   ss_offset,
			   (TTRACE_ARG_TYPE) sizeof_buf,
			   (TTRACE_ARG_TYPE) buf);
  return tt_status;
}


/* This function is a sop to the largeish number of direct calls
   to call_ptrace that exist in other files.  Rather than create
   functions whose name abstracts away from ptrace, and change all
   the present callers of call_ptrace, we'll do the expedient (and
   perhaps only practical) thing.

   Note HP-UX explicitly disallows a mix of ptrace & ttrace on a traced
   process.  Thus, we must translate all ptrace requests into their
   process-specific, ttrace equivalents.
 */
int
call_ptrace (int pt_request, int gdb_tid, PTRACE_ARG3_TYPE addr, int data)
{
  ttreq_t tt_request;
  TTRACE_ARG_TYPE tt_addr = (TTRACE_ARG_TYPE) addr;
  TTRACE_ARG_TYPE tt_data = (TTRACE_ARG_TYPE) data;
  TTRACE_ARG_TYPE tt_addr2 = TT_NIL;
  int tt_status;
  register_value_t register_value;
  int read_buf;

  /* Perform the necessary argument translation.  Note that some
     cases are funky enough in the ttrace realm that we handle them
     very specially.
   */
  switch (pt_request)
    {
      /* The following cases cannot conveniently be handled conveniently
         by merely adjusting the ptrace arguments and feeding into the
         generic call to ttrace at the bottom of this function.

         Note that because all branches of this switch end in "return",
         there's no need for any "break" statements.
       */
    case PT_SETTRC:
      return parent_attach_all (0, 0, 0);

    case PT_RUREGS:
      tt_status = read_from_register_save_state (gdb_tid,
						 tt_addr,
						 &register_value,
						 sizeof (register_value));
      if (tt_status < 0)
	return tt_status;
      return register_value;

    case PT_WUREGS:
      register_value = (int) tt_data;
      tt_status = write_to_register_save_state (gdb_tid,
						tt_addr,
						&register_value,
						sizeof (register_value));
      return tt_status;
      break;

    case PT_READ_I:
      tt_status = call_ttrace (TT_PROC_RDTEXT,	/* Implicit 4-byte xfer becomes block-xfer. */
			       gdb_tid,
			       tt_addr,
			       (TTRACE_ARG_TYPE) 4,
			       (TTRACE_ARG_TYPE) & read_buf);
      if (tt_status < 0)
	return tt_status;
      return read_buf;

    case PT_READ_D:
      tt_status = call_ttrace (TT_PROC_RDDATA,	/* Implicit 4-byte xfer becomes block-xfer. */
			       gdb_tid,
			       tt_addr,
			       (TTRACE_ARG_TYPE) 4,
			       (TTRACE_ARG_TYPE) & read_buf);
      if (tt_status < 0)
	return tt_status;
      return read_buf;

    case PT_ATTACH:
      tt_status = call_real_ttrace (TT_PROC_ATTACH,
				    map_from_gdb_tid (gdb_tid),
				    (lwpid_t) TT_NIL,
				    tt_addr,
				    (TTRACE_ARG_TYPE) TT_VERSION,
				    tt_addr2);
      if (tt_status < 0)
	return tt_status;
      return tt_status;

      /* The following cases are handled by merely adjusting the ptrace
         arguments and feeding into the generic call to ttrace.
       */
    case PT_DETACH:
      tt_request = TT_PROC_DETACH;
      break;

    case PT_WRITE_I:
      tt_request = TT_PROC_WRTEXT;	/* Translates 4-byte xfer to block-xfer. */
      tt_data = 4;		/* This many bytes. */
      tt_addr2 = (TTRACE_ARG_TYPE) & data;	/* Address of xfer source. */
      break;

    case PT_WRITE_D:
      tt_request = TT_PROC_WRDATA;	/* Translates 4-byte xfer to block-xfer. */
      tt_data = 4;		/* This many bytes. */
      tt_addr2 = (TTRACE_ARG_TYPE) & data;	/* Address of xfer source. */
      break;

    case PT_RDTEXT:
      tt_request = TT_PROC_RDTEXT;
      break;

    case PT_RDDATA:
      tt_request = TT_PROC_RDDATA;
      break;

    case PT_WRTEXT:
      tt_request = TT_PROC_WRTEXT;
      break;

    case PT_WRDATA:
      tt_request = TT_PROC_WRDATA;
      break;

    case PT_CONTINUE:
      tt_request = TT_PROC_CONTINUE;
      break;

    case PT_STEP:
      tt_request = TT_LWP_SINGLE;	/* Should not be making this request? */
      break;

    case PT_KILL:
      tt_request = TT_PROC_EXIT;
      break;

    case PT_GET_PROCESS_PATHNAME:
      tt_request = TT_PROC_GET_PATHNAME;
      break;

    default:
      tt_request = pt_request;	/* Let ttrace be the one to complain. */
      break;
    }

  return call_ttrace (tt_request,
		      gdb_tid,
		      tt_addr,
		      tt_data,
		      tt_addr2);
}

/* Kill that pesky process!
 */
void
kill_inferior (void)
{
  int tid;
  int wait_status;
  thread_info *t;
  thread_info **paranoia;
  int para_count, i;

  if (PIDGET (inferior_ptid) == 0)
    return;

  /* Walk the list of "threads", some of which are "pseudo threads",
     aka "processes".  For each that is NOT inferior_ptid, stop it,
     and detach it.

     You see, we may not have just a single process to kill.  If we're
     restarting or quitting or detaching just after the inferior has
     forked, then we've actually two processes to clean up.

     But we can't just call target_mourn_inferior() for each, since that
     zaps the target vector.
   */

  paranoia = (thread_info **) xmalloc (thread_head.count *
				       sizeof (thread_info *));
  para_count = 0;

  t = thread_head.head;
  while (t)
    {

      paranoia[para_count] = t;
      for (i = 0; i < para_count; i++)
	{
	  if (t->next == paranoia[i])
	    {
	      warning ("Bad data in gdb's thread data; repairing.");
	      t->next = 0;
	    }
	}
      para_count++;

      if (t->am_pseudo && (t->pid != PIDGET (inferior_ptid)))
	{
	  call_ttrace (TT_PROC_EXIT,
		       t->pid,
		       TT_NIL,
		       TT_NIL,
		       TT_NIL);
	}
      t = t->next;
    }

  xfree (paranoia);

  call_ttrace (TT_PROC_EXIT,
	       PIDGET (inferior_ptid),
	       TT_NIL,
	       TT_NIL,
	       TT_NIL);
  target_mourn_inferior ();
  clear_thread_info ();
}


#ifndef DEPRECATED_CHILD_RESUME

/* Sanity check a thread about to be continued.
 */
static void
thread_dropping_event_check (thread_info *p)
{
  if (!p->handled)
    {
      /*
       * This seems to happen when we "next" over a
       * "fork()" while following the parent.  If it's
       * the FORK event, that's ok.  If it's a SIGNAL
       * in the unfollowed child, that's ok to--but
       * how can we know that's what's going on?
       *
       * FIXME!
       */
      if (p->have_state)
	{
	  if (p->last_stop_state.tts_event == TTEVT_FORK)
	    {
	      /* Ok */
	      ;
	    }
	  else if (p->last_stop_state.tts_event == TTEVT_SIGNAL)
	    {
	      /* Ok, close eyes and let it happen.
	       */
	      ;
	    }
	  else
	    {
	      /* This shouldn't happen--we're dropping a
	       * real event.
	       */
	      warning ("About to continue process %d, thread %d with unhandled event %s.",
		       p->pid, p->tid,
		       get_printable_name_of_ttrace_event (
					     p->last_stop_state.tts_event));

#ifdef PARANOIA
	      if (debug_on)
		print_tthread (p);
#endif
	    }
	}
      else
	{
	  /* No saved state, have to assume it failed.
	   */
	  warning ("About to continue process %d, thread %d with unhandled event.",
		   p->pid, p->tid);
#ifdef PARANOIA
	  if (debug_on)
	    print_tthread (p);
#endif
	}
    }

}				/* thread_dropping_event_check */

/* Use a loop over the threads to continue all the threads but
 * the one specified, which is to be stepped.
 */
static void
threads_continue_all_but_one (lwpid_t gdb_tid, int signal)
{
  thread_info *p;
  int thread_signal;
  lwpid_t real_tid;
  lwpid_t scan_tid;
  ttstate_t state;
  int real_pid;

#ifdef THREAD_DEBUG
  if (debug_on)
    printf ("Using loop over threads to step/resume with signals\n");
#endif

  /* First update the thread list.
   */
  set_all_unseen ();
  real_tid = map_from_gdb_tid (gdb_tid);
  real_pid = get_pid_for (real_tid);

  scan_tid = get_process_first_stopped_thread_id (real_pid, &state);
  while (0 != scan_tid)
    {

#ifdef THREAD_DEBUG
      /* FIX: later should check state is stopped;
       * state.tts_flags & TTS_STATEMASK == TTS_WASSUSPENDED
       */
      if (debug_on)
 	if ((state.tts_flags & TTS_STATEMASK) != TTS_WASSUSPENDED)
	  printf ("About to continue non-stopped thread %d\n", scan_tid);
#endif

      p = find_thread_info (scan_tid);
      if (NULL == p)
	{
	  add_tthread (real_pid, scan_tid);
	  p = find_thread_info (scan_tid);

	  /* This is either a newly-created thread or the
	   * result of a fork; in either case there's no
	   * actual event to worry about.
	   */
	  p->handled = 1;

	  if (state.tts_event != TTEVT_NONE)
	    {
	      /* Oops, do need to worry!
	       */
	      warning ("Unexpected thread with \"%s\" event.",
		       get_printable_name_of_ttrace_event (state.tts_event));
	    }
	}
      else if (scan_tid != p->tid)
	error ("Bad data in thread database.");

#ifdef THREAD_DEBUG
      if (debug_on)
	if (p->terminated)
	  printf ("Why are we continuing a dead thread?\n");
#endif

      p->seen = 1;

      scan_tid = get_process_next_stopped_thread_id (real_pid, &state);
    }

  /* Remove unseen threads.
   */
  update_thread_list ();

  /* Now run down the thread list and continue or step.
   */
  for (p = thread_head.head; p; p = p->next)
    {

      /* Sanity check.
       */
      thread_dropping_event_check (p);

      /* Pass the correct signals along.
       */
      if (p->have_signal)
	{
	  thread_signal = p->signal_value;
	  p->have_signal = 0;
	}
      else
	thread_signal = 0;

      if (p->tid != real_tid)
	{
	  /*
	   * Not the thread of interest, so continue it
	   * as the user expects.
	   */
	  if (p->stepping_mode == DO_STEP)
	    {
	      /* Just step this thread.
	       */
	      call_ttrace (
			    TT_LWP_SINGLE,
			    p->tid,
			    TT_USE_CURRENT_PC,
			    (TTRACE_ARG_TYPE) target_signal_to_host (signal),
			    TT_NIL);
	    }
	  else
	    {
	      /* Regular continue (default case).
	       */
	      call_ttrace (
			    TT_LWP_CONTINUE,
			    p->tid,
			    TT_USE_CURRENT_PC,
		    (TTRACE_ARG_TYPE) target_signal_to_host (thread_signal),
			    TT_NIL);
	    }
	}
      else
	{
	  /* Step the thread of interest.
	   */
	  call_ttrace (
			TT_LWP_SINGLE,
			real_tid,
			TT_USE_CURRENT_PC,
			(TTRACE_ARG_TYPE) target_signal_to_host (signal),
			TT_NIL);
	}
    }				/* Loop over threads */
}				/* End threads_continue_all_but_one */

/* Use a loop over the threads to continue all the threads.
 * This is done when a signal must be sent to any of the threads.
 */
static void
threads_continue_all_with_signals (lwpid_t gdb_tid, int signal)
{
  thread_info *p;
  int thread_signal;
  lwpid_t real_tid;
  lwpid_t scan_tid;
  ttstate_t state;
  int real_pid;

#ifdef THREAD_DEBUG
  if (debug_on)
    printf ("Using loop over threads to resume with signals\n");
#endif

  /* Scan and update thread list.
   */
  set_all_unseen ();
  real_tid = map_from_gdb_tid (gdb_tid);
  real_pid = get_pid_for (real_tid);

  scan_tid = get_process_first_stopped_thread_id (real_pid, &state);
  while (0 != scan_tid)
    {

#ifdef THREAD_DEBUG
      if (debug_on)
	if ((state.tts_flags & TTS_STATEMASK) != TTS_WASSUSPENDED)
	  warning ("About to continue non-stopped thread %d\n", scan_tid);
#endif

      p = find_thread_info (scan_tid);
      if (NULL == p)
	{
	  add_tthread (real_pid, scan_tid);
	  p = find_thread_info (scan_tid);

	  /* This is either a newly-created thread or the
	   * result of a fork; in either case there's no
	   * actual event to worry about.
	   */
	  p->handled = 1;

	  if (state.tts_event != TTEVT_NONE)
	    {
	      /* Oops, do need to worry!
	       */
	      warning ("Unexpected thread with \"%s\" event.",
		       get_printable_name_of_ttrace_event (state.tts_event));
	    }
	}

#ifdef THREAD_DEBUG
      if (debug_on)
	if (p->terminated)
	  printf ("Why are we continuing a dead thread? (1)\n");
#endif

      p->seen = 1;

      scan_tid = get_process_next_stopped_thread_id (real_pid, &state);
    }

  /* Remove unseen threads from our list.
   */
  update_thread_list ();

  /* Continue the threads.
   */
  for (p = thread_head.head; p; p = p->next)
    {

      /* Sanity check.
       */
      thread_dropping_event_check (p);

      /* Pass the correct signals along.
       */
      if (p->tid == real_tid)
	{
	  thread_signal = signal;
	  p->have_signal = 0;
	}
      else if (p->have_signal)
	{
	  thread_signal = p->signal_value;
	  p->have_signal = 0;
	}
      else
	thread_signal = 0;

      if (p->stepping_mode == DO_STEP)
	{
	  call_ttrace (
			TT_LWP_SINGLE,
			p->tid,
			TT_USE_CURRENT_PC,
			(TTRACE_ARG_TYPE) target_signal_to_host (signal),
			TT_NIL);
	}
      else
	{
	  /* Continue this thread (default case).
	   */
	  call_ttrace (
			TT_LWP_CONTINUE,
			p->tid,
			TT_USE_CURRENT_PC,
		    (TTRACE_ARG_TYPE) target_signal_to_host (thread_signal),
			TT_NIL);
	}
    }
}				/* End threads_continue_all_with_signals */

/* Step one thread only.  
 */
static void
thread_fake_step (lwpid_t tid, enum target_signal signal)
{
  thread_info *p;

#ifdef THREAD_DEBUG
  if (debug_on)
    {
      printf ("Doing a fake-step over a bpt, etc. for %d\n", tid);

      if (is_terminated (tid))
	printf ("Why are we continuing a dead thread? (4)\n");
    }
#endif

  if (doing_fake_step)
    warning ("Step while step already in progress.");

  /* See if there's a saved signal value for this
   * thread to be passed on, but no current signal.
   */
  p = find_thread_info (tid);
  if (p != NULL)
    {
      if (p->have_signal && signal == TARGET_SIGNAL_0)
	{
	  /* Pass on a saved signal.
	   */
	  signal = p->signal_value;
	}

      p->have_signal = 0;
    }

  if (!p->handled)
    warning ("Internal error: continuing unhandled thread.");

  call_ttrace (TT_LWP_SINGLE,
	       tid,
	       TT_USE_CURRENT_PC,
	       (TTRACE_ARG_TYPE) target_signal_to_host (signal),
	       TT_NIL);

  /* Do bookkeeping so "call_ttrace_wait" knows it has to wait
   * for this thread only, and clear any saved signal info.
   */
  doing_fake_step = 1;
  fake_step_tid = tid;

}				/* End thread_fake_step */

/* Continue one thread when a signal must be sent to it.
 */
static void
threads_continue_one_with_signal (lwpid_t gdb_tid, int signal)
{
  thread_info *p;
  lwpid_t real_tid;
  int real_pid;

#ifdef THREAD_DEBUG
  if (debug_on)
    printf ("Continuing one thread with a signal\n");
#endif

  real_tid = map_from_gdb_tid (gdb_tid);
  real_pid = get_pid_for (real_tid);

  p = find_thread_info (real_tid);
  if (NULL == p)
    {
      add_tthread (real_pid, real_tid);
    }

#ifdef THREAD_DEBUG
  if (debug_on)
    if (p->terminated)
      printf ("Why are we continuing a dead thread? (2)\n");
#endif

  if (!p->handled)
    warning ("Internal error: continuing unhandled thread.");

  p->have_signal = 0;

  call_ttrace (TT_LWP_CONTINUE,
	       gdb_tid,
	       TT_USE_CURRENT_PC,
	       (TTRACE_ARG_TYPE) target_signal_to_host (signal),
	       TT_NIL);
}
#endif

#ifndef DEPRECATED_CHILD_RESUME

/* Resume execution of the inferior process.

 * This routine is in charge of setting the "handled" bits. 
 *
 *   If STEP is zero,      continue it.
 *   If STEP is nonzero,   single-step it.
 *   
 *   If SIGNAL is nonzero, give it that signal.
 *
 *   If TID is -1,         apply to all threads.
 *   If TID is not -1,     apply to specified thread.
 *   
 *           STEP
 *      \      !0                        0
 *  TID  \________________________________________________
 *       |
 *   -1  |   Step current            Continue all threads
 *       |   thread and              (but which gets any
 *       |   continue others         signal?--We look at
 *       |                           "inferior_ptid")
 *       |
 *    N  |   Step _this_ thread      Continue _this_ thread
 *       |   and leave others        and leave others 
 *       |   stopped; internally     stopped; used only for
 *       |   used by gdb, never      hardware watchpoints
 *       |   a user command.         and attach, never a
 *       |                           user command.
 */
void
child_resume (ptid_t ptid, int step, enum target_signal signal)
{
  int resume_all_threads;
  lwpid_t tid;
  process_state_t new_process_state;
  lwpid_t gdb_tid = PIDGET (ptid);

  resume_all_threads =
    (gdb_tid == INFTTRACE_ALL_THREADS) ||
    (vfork_in_flight);

  if (resume_all_threads)
    {
      /* Resume all threads, but first pick a tid value
       * so we can get the pid when in call_ttrace doing
       * the map.
       */
      if (vfork_in_flight)
	tid = vforking_child_pid;
      else
	tid = map_from_gdb_tid (PIDGET (inferior_ptid));
    }
  else
    tid = map_from_gdb_tid (gdb_tid);

#ifdef THREAD_DEBUG
  if (debug_on)
    {
      if (more_events_left)
	printf ("More events; ");

      if (signal != 0)
	printf ("Sending signal %d; ", signal);

      if (resume_all_threads)
	{
	  if (step == 0)
	    printf ("Continue process %d\n", tid);
	  else
	    printf ("Step/continue thread %d\n", tid);
	}
      else
	{
	  if (step == 0)
	    printf ("Continue thread %d\n", tid);
	  else
	    printf ("Step just thread %d\n", tid);
	}

      if (vfork_in_flight)
	printf ("Vfork in flight\n");
    }
#endif

  if (process_state == RUNNING)
    warning ("Internal error in resume logic; doing resume or step anyway.");

  if (!step			/* Asked to continue...       */
      && resume_all_threads	/* whole process..            */
      && signal != 0		/* with a signal...           */
      && more_events_left > 0)
    {				/* but we can't yet--save it! */

      /* Continue with signal means we have to set the pending
       * signal value for this thread.
       */
      thread_info *k;

#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("Saving signal %d for thread %d\n", signal, tid);
#endif

      k = find_thread_info (tid);
      if (k != NULL)
	{
	  k->have_signal = 1;
	  k->signal_value = signal;

#ifdef THREAD_DEBUG
	  if (debug_on)
	    if (k->terminated)
	      printf ("Why are we continuing a dead thread? (3)\n");
#endif

	}

#ifdef THREAD_DEBUG
      else if (debug_on)
	{
	  printf ("No thread info for tid %d\n", tid);
	}
#endif
    }

  /* Are we faking this "continue" or "step"?

   * We used to do steps by continuing all the threads for 
   * which the events had been handled already.  While
   * conceptually nicer (hides it all in a lower level), this
   * can lead to starvation and a hang (e.g. all but one thread
   * are unhandled at a breakpoint just before a "join" operation,
   * and one thread is in the join, and the user wants to step that
   * thread).
   */
  if (resume_all_threads	/* Whole process, therefore user command */
      && more_events_left > 0)
    {				/* But we can't do this yet--fake it! */
      thread_info *p;

      if (!step)
	{
	  /* No need to do any notes on a per-thread
	   * basis--we're done!
	   */
#ifdef WAIT_BUFFER_DEBUG
	  if (debug_on)
	    printf ("Faking a process resume.\n");
#endif

	  return;
	}
      else
	{

#ifdef WAIT_BUFFER_DEBUG
	  if (debug_on)
	    printf ("Faking a process step.\n");
#endif

	}

      p = find_thread_info (tid);
      if (p == NULL)
	{
	  warning ("No thread information for tid %d, 'next' command ignored.\n", tid);
	  return;
	}
      else
	{

#ifdef THREAD_DEBUG
	  if (debug_on)
	    if (p->terminated)
	      printf ("Why are we continuing a dead thread? (3.5)\n");
#endif

	  if (p->stepping_mode != DO_DEFAULT)
	    {
	      warning ("Step or continue command applied to thread which is already stepping or continuing; command ignored.");

	      return;
	    }

	  if (step)
	    p->stepping_mode = DO_STEP;
	  else
	    p->stepping_mode = DO_CONTINUE;

	  return;
	}			/* Have thread info */
    }				/* Must fake step or go */

  /* Execept for fake-steps, from here on we know we are
   * going to wind up with a running process which will
   * need a real wait.
   */
  new_process_state = RUNNING;

  /* An address of TT_USE_CURRENT_PC tells ttrace to continue from where
   * it was.  (If GDB wanted it to start some other way, we have already
   * written a new PC value to the child.)
   *
   * If this system does not support PT_STEP, a higher level function will
   * have called single_step() to transmute the step request into a
   * continue request (by setting breakpoints on all possible successor
   * instructions), so we don't have to worry about that here.
   */
  if (step)
    {
      if (resume_all_threads)
	{
	  /*
	   * Regular user step: other threads get a "continue".
	   */
	  threads_continue_all_but_one (tid, signal);
	  clear_all_handled ();
	  clear_all_stepping_mode ();
	}

      else
	{
	  /* "Fake step": gdb is stepping one thread over a
	   * breakpoint, watchpoint, or out of a library load
	   * event, etc.  The rest just stay where they are.
	   *
	   * Also used when there are pending events: we really
	   * step the current thread, but leave the rest stopped.
	   * Users can't request this, but "wait_for_inferior"
	   * does--a lot!
	   */
	  thread_fake_step (tid, signal);

	  /* Clear the "handled" state of this thread, because
	   * we'll soon get a new event for it.  Other events
	   * stay as they were.
	   */
	  clear_handled (tid);
	  clear_stepping_mode (tid);
	  new_process_state = FAKE_STEPPING;
	}
    }

  else
    {
      /* TT_LWP_CONTINUE can pass signals to threads, TT_PROC_CONTINUE can't.
	 Therefore, we really can't use TT_PROC_CONTINUE here.

	 Consider a process which stopped due to signal which gdb decides
	 to handle and not pass on to the inferior.  In that case we must
	 clear the pending signal by restarting the inferior using
	 TT_LWP_CONTINUE and pass zero as the signal number.  Else the
	 pending signal will be passed to the inferior.  interrupt.exp
	 in the testsuite does this precise thing and fails due to the
	 unwanted signal delivery to the inferior.  */
      /* drow/2002-12-05: However, note that we must use TT_PROC_CONTINUE
	 if we are tracing a vfork.  */
      if (vfork_in_flight)
	{
	  call_ttrace (TT_PROC_CONTINUE, tid, TT_NIL, TT_NIL, TT_NIL);
	  clear_all_handled ();
	  clear_all_stepping_mode ();
	}
      else if (resume_all_threads)
	{
#ifdef THREAD_DEBUG
	  if (debug_on)
	    printf ("Doing a continue by loop of all threads\n");
#endif

	  threads_continue_all_with_signals (tid, signal);

	  clear_all_handled ();
	  clear_all_stepping_mode ();
	}
      else
	{
#ifdef THREAD_DEBUG
	  printf ("Doing a continue w/signal of just thread %d\n", tid);
#endif

	  threads_continue_one_with_signal (tid, signal);

	  /* Clear the "handled" state of this thread, because we
	     will soon get a new event for it.  Other events can
	     stay as they were.  */
	  clear_handled (tid);
	  clear_stepping_mode (tid);
	}
    }

  process_state = new_process_state;

#ifdef WAIT_BUFFER_DEBUG
  if (debug_on)
    printf ("Process set to %s\n",
	    get_printable_name_of_process_state (process_state));
#endif

}
#endif /* DEPRECATED_CHILD_RESUME */

/*
 * Like it says.
 *
 * One worry is that we may not be attaching to "inferior_ptid"
 * and thus may not want to clear out our data.  FIXME?
 * 
 */
static void
update_thread_state_after_attach (int pid, attach_continue_t kind_of_go)
{
  int tt_status;
  ttstate_t thread_state;
  lwpid_t a_thread;
  lwpid_t tid;

  /* The process better be stopped.
   */
  if (process_state != STOPPED
      && process_state != VFORKING)
    warning ("Internal error attaching.");

  /* Clear out old tthread info and start over.  This has the
   * side effect of ensuring that the TRAP is reported as being
   * in the right thread (re-mapped from tid to pid).
   *
   * It's because we need to add the tthread _now_ that we
   * need to call "clear_thread_info" _now_, and that's why
   * "require_notification_of_events" doesn't clear the thread
   * info (it's called later than this routine).
   */
  clear_thread_info ();
  a_thread = 0;

  for (tid = get_process_first_stopped_thread_id (pid, &thread_state);
       tid != 0;
       tid = get_process_next_stopped_thread_id (pid, &thread_state))
    {
      thread_info *p;

      if (a_thread == 0)
	{
	  a_thread = tid;
#ifdef THREAD_DEBUG
	  if (debug_on)
	    printf ("Attaching to process %d, thread %d\n",
		    pid, a_thread);
#endif
	}

      /* Tell ourselves and the "rest of gdb" that this thread
       * exists.
       *
       * This isn't really a hack.  Other thread-based versions
       * of gdb (e.g. gnu-nat.c) seem to do the same thing.
       *
       * We don't need to do mapping here, as we know this
       * is the first thread and thus gets the real pid
       * (and is "inferior_ptid").
       *
       * NOTE: it probably isn't the originating thread,
       *       but that doesn't matter (we hope!).
       */
      add_tthread (pid, tid);
      p = find_thread_info (tid);
      if (NULL == p)		/* ?We just added it! */
	error ("Internal error adding a thread on attach.");

      copy_ttstate_t (&p->last_stop_state, &thread_state);
      p->have_state = 1;

      if (DO_ATTACH_CONTINUE == kind_of_go)
	{
	  /*
	   * If we are going to CONTINUE afterwards,
	   * raising a SIGTRAP, don't bother trying to
	   * handle this event.  But check first!
	   */
	  switch (p->last_stop_state.tts_event)
	    {

	    case TTEVT_NONE:
	      /* Ok to set this handled.
	       */
	      break;

	    default:
	      warning ("Internal error; skipping event %s on process %d, thread %d.",
		       get_printable_name_of_ttrace_event (
					      p->last_stop_state.tts_event),
		       p->pid, p->tid);
	    }

	  set_handled (pid, tid);

	}
      else
	{
	  /* There will be no "continue" opertion, so the
	   * process remains stopped.  Don't set any events
	   * handled except the "gimmies".
	   */
	  switch (p->last_stop_state.tts_event)
	    {

	    case TTEVT_NONE:
	      /* Ok to ignore this.
	       */
	      set_handled (pid, tid);
	      break;

	    case TTEVT_EXEC:
	    case TTEVT_FORK:
	      /* Expected "other" FORK or EXEC event from a
	       * fork or vfork.
	       */
	      break;

	    default:
	      printf ("Internal error: failed to handle event %s on process %d, thread %d.",
		      get_printable_name_of_ttrace_event (
					      p->last_stop_state.tts_event),
		      p->pid, p->tid);
	    }
	}

      add_thread (pid_to_ptid (pid));		/* in thread.c */
    }

#ifdef PARANOIA
  if (debug_on)
    print_tthreads ();
#endif

  /* One mustn't call ttrace_wait() after attaching via ttrace,
     'cause the process is stopped already.

     However, the upper layers of gdb's execution control will
     want to wait after attaching (but not after forks, in
     which case they will be doing a "target_resume", anticipating
     a later TTEVT_EXEC or TTEVT_FORK event).

     To make this attach() implementation more compatible with
     others, we'll make the attached-to process raise a SIGTRAP.

     Issue: this continues only one thread.  That could be
     dangerous if the thread is blocked--the process won't run
     and no trap will be raised.  FIX! (check state.tts_flags?
     need one that's either TTS_WASRUNNING--but we've stopped
     it and made it TTS_WASSUSPENDED.  Hum...FIXME!)
   */
  if (DO_ATTACH_CONTINUE == kind_of_go)
    {
      tt_status = call_real_ttrace (
				     TT_LWP_CONTINUE,
				     pid,
				     a_thread,
				     TT_USE_CURRENT_PC,
	       (TTRACE_ARG_TYPE) target_signal_to_host (TARGET_SIGNAL_TRAP),
				     TT_NIL);
      if (errno)
	perror_with_name ("ttrace");

      clear_handled (a_thread);	/* So TRAP will be reported. */

      /* Now running.
       */
      process_state = RUNNING;
    }

  attach_flag = 1;
}


/* Start debugging the process whose number is PID.
 * (A _real_ pid).
 */
int
attach (int pid)
{
  int tt_status;

  tt_status = call_real_ttrace (
				 TT_PROC_ATTACH,
				 pid,
				 (lwpid_t) TT_NIL,
				 TT_NIL,
				 (TTRACE_ARG_TYPE) TT_VERSION,
				 TT_NIL);
  if (errno)
    perror_with_name ("ttrace attach");

  /* If successful, the process is now stopped.
   */
  process_state = STOPPED;

  /* Our caller ("attach_command" in "infcmd.c")
   * expects to do a "wait_for_inferior" after
   * the attach, so make sure the inferior is
   * running when we're done.
   */
  update_thread_state_after_attach (pid, DO_ATTACH_CONTINUE);

  return pid;
}


#if defined(CHILD_POST_ATTACH)
void
child_post_attach (int pid)
{
#ifdef THREAD_DEBUG
  if (debug_on)
    printf ("child-post-attach call\n");
#endif

  require_notification_of_events (pid);
}
#endif


/* Stop debugging the process whose number is PID
   and continue it with signal number SIGNAL.
   SIGNAL = 0 means just continue it.
 */
void
detach (int signal)
{
  errno = 0;
  call_ttrace (TT_PROC_DETACH,
	       PIDGET (inferior_ptid),
	       TT_NIL,
	       (TTRACE_ARG_TYPE) signal,
	       TT_NIL);
  attach_flag = 0;

  clear_thread_info ();

  /* Process-state? */
}


/* Default the type of the ttrace transfer to int.  */
#ifndef TTRACE_XFER_TYPE
#define TTRACE_XFER_TYPE int
#endif

void
_initialize_kernel_u_addr (void)
{
}

#if !defined (CHILD_XFER_MEMORY)
/* NOTE! I tried using TTRACE_READDATA, etc., to read and write memory
   in the NEW_SUN_TTRACE case.
   It ought to be straightforward.  But it appears that writing did
   not write the data that I specified.  I cannot understand where
   it got the data that it actually did write.  */

/* Copy LEN bytes to or from inferior's memory starting at MEMADDR
   to debugger memory starting at MYADDR.   Copy to inferior if
   WRITE is nonzero.  TARGET is ignored.

   Returns the length copied, which is either the LEN argument or
   zero.  This xfer function does not do partial moves, since
   deprecated_child_ops doesn't allow memory operations to cross below
   us in the target stack anyway.  */

int
child_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		   struct mem_attrib *attrib,
		   struct target_ops *target)
{
  int i;
  /* Round starting address down to longword boundary.  */
  CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (TTRACE_XFER_TYPE);
  /* Round ending address up; get number of longwords that makes.  */
  int count
  = (((memaddr + len) - addr) + sizeof (TTRACE_XFER_TYPE) - 1)
  / sizeof (TTRACE_XFER_TYPE);
  /* Allocate buffer of that many longwords.  */
  /* FIXME (alloca): This code, cloned from infptrace.c, is unsafe
     because it uses alloca to allocate a buffer of arbitrary size.
     For very large xfers, this could crash GDB's stack.  */
  TTRACE_XFER_TYPE *buffer
    = (TTRACE_XFER_TYPE *) alloca (count * sizeof (TTRACE_XFER_TYPE));

  if (write)
    {
      /* Fill start and end extra bytes of buffer with existing memory data.  */

      if (addr != memaddr || len < (int) sizeof (TTRACE_XFER_TYPE))
	{
	  /* Need part of initial word -- fetch it.  */
	  buffer[0] = call_ttrace (TT_LWP_RDTEXT,
				   PIDGET (inferior_ptid),
				   (TTRACE_ARG_TYPE) addr,
				   TT_NIL,
				   TT_NIL);
	}

      if (count > 1)		/* FIXME, avoid if even boundary */
	{
	  buffer[count - 1] = call_ttrace (TT_LWP_RDTEXT,
					   PIDGET (inferior_ptid),
					   ((TTRACE_ARG_TYPE)
			  (addr + (count - 1) * sizeof (TTRACE_XFER_TYPE))),
					   TT_NIL,
					   TT_NIL);
	}

      /* Copy data to be written over corresponding part of buffer */

      memcpy ((char *) buffer + (memaddr & (sizeof (TTRACE_XFER_TYPE) - 1)),
	      myaddr,
	      len);

      /* Write the entire buffer.  */

      for (i = 0; i < count; i++, addr += sizeof (TTRACE_XFER_TYPE))
	{
	  errno = 0;
	  call_ttrace (TT_LWP_WRDATA,
		       PIDGET (inferior_ptid),
		       (TTRACE_ARG_TYPE) addr,
		       (TTRACE_ARG_TYPE) buffer[i],
		       TT_NIL);
	  if (errno)
	    {
	      /* Using the appropriate one (I or D) is necessary for
	         Gould NP1, at least.  */
	      errno = 0;
	      call_ttrace (TT_LWP_WRTEXT,
			   PIDGET (inferior_ptid),
			   (TTRACE_ARG_TYPE) addr,
			   (TTRACE_ARG_TYPE) buffer[i],
			   TT_NIL);
	    }
	  if (errno)
	    return 0;
	}
    }
  else
    {
      /* Read all the longwords */
      for (i = 0; i < count; i++, addr += sizeof (TTRACE_XFER_TYPE))
	{
	  errno = 0;
	  buffer[i] = call_ttrace (TT_LWP_RDTEXT,
				   PIDGET (inferior_ptid),
				   (TTRACE_ARG_TYPE) addr,
				   TT_NIL,
				   TT_NIL);
	  if (errno)
	    return 0;
	  QUIT;
	}

      /* Copy appropriate bytes out of the buffer.  */
      memcpy (myaddr,
	      (char *) buffer + (memaddr & (sizeof (TTRACE_XFER_TYPE) - 1)),
	      len);
    }
  return len;
}


static void
udot_info (void)
{
  int udot_off;			/* Offset into user struct */
  int udot_val;			/* Value from user struct at udot_off */
  char mess[128];		/* For messages */

  if (!target_has_execution)
    {
      error ("The program is not being run.");
    }

#if !defined (KERNEL_U_SIZE)

  /* Adding support for this command is easy.  Typically you just add a
     routine, called "kernel_u_size" that returns the size of the user
     struct, to the appropriate *-nat.c file and then add to the native
     config file "#define KERNEL_U_SIZE kernel_u_size()" */
  error ("Don't know how large ``struct user'' is in this version of gdb.");

#else

  for (udot_off = 0; udot_off < KERNEL_U_SIZE; udot_off += sizeof (udot_val))
    {
      if ((udot_off % 24) == 0)
	{
	  if (udot_off > 0)
	    {
	      printf_filtered ("\n");
	    }
	  printf_filtered ("%04x:", udot_off);
	}
      udot_val = call_ttrace (TT_LWP_RUREGS,
			      PIDGET (inferior_ptid),
			      (TTRACE_ARG_TYPE) udot_off,
			      TT_NIL,
			      TT_NIL);
      if (errno != 0)
	{
	  sprintf (mess, "\nreading user struct at offset 0x%x", udot_off);
	  perror_with_name (mess);
	}
      /* Avoid using nonportable (?) "*" in print specs */
      printf_filtered (sizeof (int) == 4 ? " 0x%08x" : " 0x%16x", udot_val);
    }
  printf_filtered ("\n");

#endif
}
#endif /* !defined (CHILD_XFER_MEMORY).  */


/* TTrace version of "target_pid_to_exec_file"
 */
char *
child_pid_to_exec_file (int tid)
{
  int tt_status;
  static char exec_file_buffer[1024];
  pid_t pid;
  static struct pst_status buf;

  /* On various versions of hpux11, this may fail due to a supposed
     kernel bug.  We have alternate methods to get this information
     (ie pstat).  */
  tt_status = call_ttrace (TT_PROC_GET_PATHNAME,
			   tid,
			   (uint64_t) exec_file_buffer,
			   sizeof (exec_file_buffer) - 1,
			   0);
  if (tt_status >= 0)
    return exec_file_buffer;

  /* Try to get process information via pstat and extract the filename
     from the pst_cmd field within the pst_status structure.  */
  if (pstat_getproc (&buf, sizeof (struct pst_status), 0, tid) != -1)
    {
      char *p = buf.pst_cmd;

      while (*p && *p != ' ')
	p++;
      *p = 0;

      return (buf.pst_cmd);
    }

  return (NULL);
}

void
pre_fork_inferior (void)
{
  int status;

  status = pipe (startup_semaphore.parent_channel);
  if (status < 0)
    {
      warning ("error getting parent pipe for startup semaphore");
      return;
    }

  status = pipe (startup_semaphore.child_channel);
  if (status < 0)
    {
      warning ("error getting child pipe for startup semaphore");
      return;
    }
}

/* Called from child_follow_fork in hppah-nat.c.
 *
 * This seems to be intended to attach after a fork or
 * vfork, while "attach" is used to attach to a pid
 * given by the user.  The check for an existing attach
 * seems odd--it always fails in our test system.
 */
int
hppa_require_attach (int pid)
{
  int tt_status;
  CORE_ADDR pc;
  CORE_ADDR pc_addr;
  unsigned int regs_offset;
  process_state_t old_process_state = process_state;

  /* Are we already attached?  There appears to be no explicit
   * way to answer this via ttrace, so we try something which
   * should be innocuous if we are attached.  If that fails,
   * then we assume we're not attached, and so attempt to make
   * it so.
   */
  errno = 0;
  tt_status = call_real_ttrace (TT_PROC_STOP,
				pid,
				(lwpid_t) TT_NIL,
				(TTRACE_ARG_TYPE) TT_NIL,
				(TTRACE_ARG_TYPE) TT_NIL,
				TT_NIL);

  if (errno)
    {
      /* No change to process-state!
       */
      errno = 0;
      pid = attach (pid);
    }
  else
    {
      /* If successful, the process is now stopped.  But if
       * we're VFORKING, the parent is still running, so don't
       * change the process state.
       */
      if (process_state != VFORKING)
	process_state = STOPPED;

      /* If we were already attached, you'd think that we
       * would need to start going again--but you'd be wrong,
       * as the fork-following code is actually in the middle
       * of the "resume" routine in in "infrun.c" and so
       * will (almost) immediately do a resume.
       *
       * On the other hand, if we are VFORKING, which means
       * that the child and the parent share a process for a
       * while, we know that "resume" won't be resuming
       * until the child EXEC event is seen.  But we still
       * don't want to continue, as the event is already
       * there waiting.
       */
      update_thread_state_after_attach (pid, DONT_ATTACH_CONTINUE);
    }				/* STOP succeeded */

  return pid;
}

int
hppa_require_detach (int pid, int signal)
{
  int tt_status;

  /* If signal is non-zero, we must pass the signal on to the active
     thread prior to detaching.  We do this by continuing the threads
     with the signal.
   */
  if (signal != 0)
    {
      errno = 0;
      threads_continue_all_with_signals (pid, signal);
    }

  errno = 0;
  tt_status = call_ttrace (TT_PROC_DETACH,
			   pid,
			   TT_NIL,
			   TT_NIL,
			   TT_NIL);

  errno = 0;			/* Ignore any errors. */

  /* process_state? */

  return pid;
}

/* Given the starting address of a memory page, hash it to a bucket in
   the memory page dictionary.
 */
static int
get_dictionary_bucket_of_page (CORE_ADDR page_start)
{
  int hash;

  hash = (page_start / memory_page_dictionary.page_size);
  hash = hash % MEMORY_PAGE_DICTIONARY_BUCKET_COUNT;

  return hash;
}


/* Given a memory page's starting address, get (i.e., find an existing
   or create a new) dictionary entry for the page.  The page will be
   write-protected when this function returns, but may have a reference
   count of 0 (if the page was newly-added to the dictionary).
 */
static memory_page_t *
get_dictionary_entry_of_page (int pid, CORE_ADDR page_start)
{
  int bucket;
  memory_page_t *page = NULL;
  memory_page_t *previous_page = NULL;

  /* We're going to be using the dictionary now, than-kew. */
  require_memory_page_dictionary ();

  /* Try to find an existing dictionary entry for this page.  Hash
     on the page's starting address.
   */
  bucket = get_dictionary_bucket_of_page (page_start);
  page = &memory_page_dictionary.buckets[bucket];
  while (page != NULL)
    {
      if (page->page_start == page_start)
	break;
      previous_page = page;
      page = page->next;
    }

  /* Did we find a dictionary entry for this page?  If not, then
     add it to the dictionary now.
   */
  if (page == NULL)
    {
      /* Create a new entry. */
      page = (memory_page_t *) xmalloc (sizeof (memory_page_t));
      page->page_start = page_start;
      page->reference_count = 0;
      page->next = NULL;
      page->previous = NULL;

      /* We'll write-protect the page now, if that's allowed. */
      page->original_permissions = write_protect_page (pid, page_start);

      /* Add the new entry to the dictionary. */
      page->previous = previous_page;
      previous_page->next = page;

      memory_page_dictionary.page_count++;
    }

  return page;
}


static void
remove_dictionary_entry_of_page (int pid, memory_page_t *page)
{
  /* Restore the page's original permissions. */
  unwrite_protect_page (pid, page->page_start, page->original_permissions);

  /* Kick the page out of the dictionary. */
  if (page->previous != NULL)
    page->previous->next = page->next;
  if (page->next != NULL)
    page->next->previous = page->previous;

  /* Just in case someone retains a handle to this after it's freed. */
  page->page_start = (CORE_ADDR) 0;

  memory_page_dictionary.page_count--;

  xfree (page);
}


static void
hppa_enable_syscall_events (int pid)
{
  int tt_status;
  ttevent_t ttrace_events;

  /* Get the set of events that are currently enabled. */
  tt_status = call_ttrace (TT_PROC_GET_EVENT_MASK,
			   pid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
  if (errno)
    perror_with_name ("ttrace");

  /* Add syscall events to that set. */
  ttrace_events.tte_events |= TTEVT_SYSCALL_ENTRY;
  ttrace_events.tte_events |= TTEVT_SYSCALL_RETURN;

  tt_status = call_ttrace (TT_PROC_SET_EVENT_MASK,
			   pid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
  if (errno)
    perror_with_name ("ttrace");
}


static void
hppa_disable_syscall_events (int pid)
{
  int tt_status;
  ttevent_t ttrace_events;

  /* Get the set of events that are currently enabled. */
  tt_status = call_ttrace (TT_PROC_GET_EVENT_MASK,
			   pid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
  if (errno)
    perror_with_name ("ttrace");

  /* Remove syscall events from that set. */
  ttrace_events.tte_events &= ~TTEVT_SYSCALL_ENTRY;
  ttrace_events.tte_events &= ~TTEVT_SYSCALL_RETURN;

  tt_status = call_ttrace (TT_PROC_SET_EVENT_MASK,
			   pid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
  if (errno)
    perror_with_name ("ttrace");
}


/* The address range beginning with START and ending with START+LEN-1
   (inclusive) is to be watched via page-protection by a new watchpoint.
   Set protection for all pages that overlap that range.

   Note that our caller sets TYPE to:
   0 for a bp_hardware_watchpoint,
   1 for a bp_read_watchpoint,
   2 for a bp_access_watchpoint

   (Yes, this is intentionally (though lord only knows why) different
   from the TYPE that is passed to hppa_remove_hw_watchpoint.)
 */
int
hppa_insert_hw_watchpoint (int pid, CORE_ADDR start, LONGEST len, int type)
{
  CORE_ADDR page_start;
  int dictionary_was_empty;
  int page_size;
  int page_id;
  LONGEST range_size_in_pages;

  if (type != 0)
    error ("read or access hardware watchpoints not supported on HP-UX");

  /* Examine all pages in the address range. */
  require_memory_page_dictionary ();

  dictionary_was_empty = (memory_page_dictionary.page_count == (LONGEST) 0);

  page_size = memory_page_dictionary.page_size;
  page_start = (start / page_size) * page_size;
  range_size_in_pages = ((LONGEST) len + (LONGEST) page_size - 1) / (LONGEST) page_size;

  for (page_id = 0; page_id < range_size_in_pages; page_id++, page_start += page_size)
    {
      memory_page_t *page;

      /* This gets the page entered into the dictionary if it was
         not already entered.
       */
      page = get_dictionary_entry_of_page (pid, page_start);
      page->reference_count++;
    }

  /* Our implementation depends on seeing calls to kernel code, for the
     following reason.  Here we ask to be notified of syscalls.

     When a protected page is accessed by user code, HP-UX raises a SIGBUS.
     Fine.

     But when kernel code accesses the page, it doesn't give a SIGBUS.
     Rather, the system call that touched the page fails, with errno=EFAULT.
     Not good for us.

     We could accomodate this "feature" by asking to be notified of syscall
     entries & exits; upon getting an entry event, disabling page-protections;
     upon getting an exit event, reenabling page-protections and then checking
     if any watchpoints triggered.

     However, this turns out to be a real performance loser.  syscalls are
     usually a frequent occurrence.  Having to unprotect-reprotect all watched
     pages, and also to then read all watched memory locations and compare for
     triggers, can be quite expensive.

     Instead, we'll only ask to be notified of syscall exits.  When we get
     one, we'll check whether errno is set.  If not, or if it's not EFAULT,
     we can just continue the inferior.

     If errno is set upon syscall exit to EFAULT, we must perform some fairly
     hackish stuff to determine whether the failure really was due to a
     page-protect trap on a watched location.
   */
  if (dictionary_was_empty)
    hppa_enable_syscall_events (pid);

  return 1;
}


/* The address range beginning with START and ending with START+LEN-1
   (inclusive) was being watched via page-protection by a watchpoint
   which has been removed.  Remove protection for all pages that
   overlap that range, which are not also being watched by other
   watchpoints.
 */
int
hppa_remove_hw_watchpoint (int pid, CORE_ADDR start, LONGEST len, int type)
{
  CORE_ADDR page_start;
  int dictionary_is_empty;
  int page_size;
  int page_id;
  LONGEST range_size_in_pages;

  if (type != 0)
    error ("read or access hardware watchpoints not supported on HP-UX");

  /* Examine all pages in the address range. */
  require_memory_page_dictionary ();

  page_size = memory_page_dictionary.page_size;
  page_start = (start / page_size) * page_size;
  range_size_in_pages = ((LONGEST) len + (LONGEST) page_size - 1) / (LONGEST) page_size;

  for (page_id = 0; page_id < range_size_in_pages; page_id++, page_start += page_size)
    {
      memory_page_t *page;

      page = get_dictionary_entry_of_page (pid, page_start);
      page->reference_count--;

      /* Was this the last reference of this page?  If so, then we
         must scrub the entry from the dictionary, and also restore
         the page's original permissions.
       */
      if (page->reference_count == 0)
	remove_dictionary_entry_of_page (pid, page);
    }

  dictionary_is_empty = (memory_page_dictionary.page_count == (LONGEST) 0);

  /* If write protections are currently disallowed, then that implies that
     wait_for_inferior believes that the inferior is within a system call.
     Since we want to see both syscall entry and return, it's clearly not
     good to disable syscall events in this state!

     ??rehrauer: Yeah, it'd be better if we had a specific flag that said,
     "inferior is between syscall events now".  Oh well.
   */
  if (dictionary_is_empty && memory_page_dictionary.page_protections_allowed)
    hppa_disable_syscall_events (pid);

  return 1;
}


/* Could we implement a watchpoint of this type via our available
   hardware support?

   This query does not consider whether a particular address range
   could be so watched, but just whether support is generally available
   for such things.  See hppa_range_profitable_for_hw_watchpoint for a
   query that answers whether a particular range should be watched via
   hardware support.
 */
int
hppa_can_use_hw_watchpoint (int type, int cnt, int ot)
{
  return (type == bp_hardware_watchpoint);
}


/* Assuming we could set a hardware watchpoint on this address, do
   we think it would be profitable ("a good idea") to do so?  If not,
   we can always set a regular (aka single-step & test) watchpoint
   on the address...
 */
int
hppa_range_profitable_for_hw_watchpoint (int pid, CORE_ADDR start, LONGEST len)
{
  int range_is_stack_based;
  int range_is_accessible;
  CORE_ADDR page_start;
  int page_size;
  int page;
  LONGEST range_size_in_pages;

  /* ??rehrauer: For now, say that all addresses are potentially
     profitable.  Possibly later we'll want to test the address
     for "stackness"?
   */
  range_is_stack_based = 0;

  /* If any page in the range is inaccessible, then we cannot
     really use hardware watchpointing, even though our client
     thinks we can.  In that case, it's actually an error to
     attempt to use hw watchpoints, so we'll tell our client
     that the range is "unprofitable", and hope that they listen...
   */
  range_is_accessible = 1;	/* Until proven otherwise. */

  /* Examine all pages in the address range. */
  errno = 0;
  page_size = sysconf (_SC_PAGE_SIZE);

  /* If we can't determine page size, we're hosed.  Tell our
     client it's unprofitable to use hw watchpoints for this
     range.
   */
  if (errno || (page_size <= 0))
    {
      errno = 0;
      return 0;
    }

  page_start = (start / page_size) * page_size;
  range_size_in_pages = len / (LONGEST) page_size;

  for (page = 0; page < range_size_in_pages; page++, page_start += page_size)
    {
      int tt_status;
      int page_permissions;

      /* Is this page accessible? */
      errno = 0;
      tt_status = call_ttrace (TT_PROC_GET_MPROTECT,
			       pid,
			       (TTRACE_ARG_TYPE) page_start,
			       TT_NIL,
			       (TTRACE_ARG_TYPE) & page_permissions);
      if (errno || (tt_status < 0))
	{
	  errno = 0;
	  range_is_accessible = 0;
	  break;
	}

      /* Yes, go for another... */
    }

  return (!range_is_stack_based && range_is_accessible);
}


char *
hppa_pid_or_tid_to_str (ptid_t ptid)
{
  static char buf[100];		/* Static because address returned. */
  pid_t id = PIDGET (ptid);

  /* Does this appear to be a process?  If so, print it that way. */
  if (is_process_id (id))
    return child_pid_to_str (ptid);

  /* Else, print both the GDB thread number and the system thread id. */
  sprintf (buf, "thread %d (", pid_to_thread_id (ptid));
  strcat (buf, hppa_tid_to_str (ptid));
  strcat (buf, ")\0");

  return buf;
}


void
hppa_ensure_vforking_parent_remains_stopped (int pid)
{
  /* Nothing to do when using ttrace.  Only the ptrace-based implementation
     must do real work.
   */
}


int
hppa_resume_execd_vforking_child_to_get_parent_vfork (void)
{
  return 0;			/* No, the parent vfork is available now. */
}


/* Write a register as a 64bit value.  This may be necessary if the
   native OS is too braindamaged to allow some (or all) registers to
   be written in 32bit hunks such as hpux11 and the PC queue registers.

   This is horribly gross and disgusting.  */
 
int
ttrace_write_reg_64 (int gdb_tid, CORE_ADDR dest_addr, CORE_ADDR src_addr)
{
  pid_t 	pid;
  lwpid_t 	tid;
  int  		tt_status;

  tid = map_from_gdb_tid (gdb_tid);
  pid = get_pid_for (tid);

  errno = 0;
  tt_status = ttrace (TT_LWP_WUREGS, 
		      pid, 
		      tid, 
		      (TTRACE_ARG_TYPE) dest_addr, 
		      8, 
		      (TTRACE_ARG_TYPE) src_addr );

#ifdef THREAD_DEBUG
  if (errno)
    {
      /* Don't bother for a known benign error: if you ask for the
         first thread state, but there is only one thread and it's
         not stopped, ttrace complains.
        
         We have this inside the #ifdef because our caller will do
         this check for real.  */
      if( request != TT_PROC_GET_FIRST_LWP_STATE
          ||  errno   != EPROTO )
        {
          if( debug_on )
            printf( "TT fail for %s, with pid %d, tid %d, status %d \n",
                    get_printable_name_of_ttrace_request (TT_LWP_WUREGS),
                    pid, tid, tt_status );
        }
    }
#endif

  return tt_status;
}

void
_initialize_infttrace (void)
{
  /* Initialize the ttrace-based hardware watchpoint implementation. */
  memory_page_dictionary.page_count = (LONGEST) - 1;
  memory_page_dictionary.page_protections_allowed = 1;

  errno = 0;
  memory_page_dictionary.page_size = sysconf (_SC_PAGE_SIZE);

  /* We do a lot of casts from pointers to TTRACE_ARG_TYPE; make sure
     this is okay.  */
  if (sizeof (TTRACE_ARG_TYPE) < sizeof (void *))
    internal_error (__FILE__, __LINE__, "failed internal consistency check");

  if (errno || (memory_page_dictionary.page_size <= 0))
    perror_with_name ("sysconf");
}
@


1.37
log
@2004-10-05  Andrew Cagney  <cagney@@gnu.org>

	* target.h (deprecated_child_ops): Rename child_ops.
	* wince.c: Update copyright.  Rename child_ops.
	* win32-nat.c: Rename child_ops.
	* target.c: Rename child_ops.
	* rs6000-nat.c: Rename child_ops.
	* linux-nat.c: Rename child_ops.
	* infttrace.c: Rename child_ops.
	* inftarg.c: Rename child_ops.
	* infptrace.c: Rename child_ops.
	* hppah-nat.c: Update copyright.  Rename child_ops.
	* hpux-thread.c: Update copyright.  Rename child_ops.
@
text
@@


1.36
log
@2004-09-29  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Delete field to_post_wait.
	(target_post_wait): Delete macro.
	(child_post_wait): Delete declaration.
	* target.c (update_current_target, update_current_target)
	(debug_to_post_wait, setup_target_debug): Delete functions and
	references.
	* infttrace.c (ptrace_wait): Delete call to target_post_wait.
	* inftarg.c (child_post_wait): Delete.
	(init_child_ops): Do not set to_post_wait.
	* infptrace.c (ptrace_wait): Delete call to target_post_wait.
	* inf-ptrace.c (inf_ptrace_wait): Delete call to target_post_wait.
	* inf-child.c (inf_child_post_wait): Delete.
	(inf_child_target): Do not set to_post_wait.
	* inf-ptrace.c (inf_ptrace_post_wait): Delete.
	(inf_ptrace_target): Do not set to_post_wait.
@
text
@d4818 4
a4821 4
   Returns the length copied, which is either the LEN argument or zero.
   This xfer function does not do partial moves, since child_ops
   doesn't allow memory operations to cross below us in the target stack
   anyway.  */
@


1.35
log
@2004-09-20  Andrew Cagney  <cagney@@gnu.org>

	* config/nm-lynx.h (DEPRECATED_CHILD_RESUME): Deprecate
	CHILD_RESUME.
	* config/i386/nm-linux.h (DEPRECATED_CHILD_RESUME): Ditto.
	* config/nm-linux.h (DEPRECATED_KILL_INFERIOR): Deprecate
	KILL_INFERIOR.
	* infptrace.c: Update.
@
text
@a2890 3
  target_post_wait (pid_to_ptid (tsp.tts_pid), *status);


@


1.34
log
@2004-09-07  Andrew Cagney  <cagney@@gnu.org>

	* vx-share/wait.h: Delete #ifdef USG.
	* utils.c (request_quit): Ditto.
	* tui/tui.c (tui_reset): Ditto.
	* remote.c: Ditto.
	* remote-sds.c: Ditto.
	* remote-rdi.c: Ditto.
	* mdebugread.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* infttrace.c: Ditto.
	* infptrace.c: Ditto.
	* i386v-nat.c: Ditto.
	* exec.c: Ditto.
	* dbxread.c: Ditto.
	* core-aout.c: Ditto.
@
text
@d3845 1
a3845 1
#ifndef CHILD_RESUME
d4256 1
a4256 1
#ifndef CHILD_RESUME
d4557 1
a4557 1
#endif /* CHILD_RESUME */
@


1.33
log
@* infptrace.c: Include <sys/file.h> if HAVE_SYS_FILE_H instead of
!NO_SYS_FILE.
[KERNEL_U_ADDR_BSD]: Don't include <a.out.h>.
[KERNEL_U_ADDR_BSD] (kernel_u_addr): Remove variable.
(_initialize_kernel_u_addr): Remove prototype and function.
* infttrace.c: Include <sys/file.h> if HAVE_SYS_FILE_H instead of
!NO_SYS_FILE.
* xcoffread.c: Likewise.
@
text
@a48 4
#ifdef USG
#include <sys/types.h>
#endif

@


1.32
log
@2004-06-08  Andrew Cagney  <cagney@@gnu.org>

	* infptrace.c [ATTACH_DETACH]: Remove #ifdef wrappers.
	(attach, detach): When neither PT_ATTACH / PT_DETACH nor
	PTRACE_ATTACH / PTRACE_DETACH available call error.
	(PT_ATTACH, PT_DETACH): Move definition to attach / detach.
	* infttrace.c (update_thread_state_after_attach, attach, detach):
	Remove #ifdef wrappers.
	* inftarg.c (child_attach, child_detach): Remove #ifdef wrappers.
	* gnu-nat.c [ATTACH_DETACH]: Remove #ifdef wrappers.
	* config/nm-bsd.h (ATTACH_DETACH): Delete.
	* config/nm-sysv4.h (ATTACH_DETACH): Delete.
	* config/nm-nbsd.h (ATTACH_DETACH): Delete.
	* config/nm-linux.h (ATTACH_DETACH): Delete.
	* config/rs6000/nm-rs6000.h (ATTACH_DETACH): Delete.
	* config/pa/nm-hppah.h (ATTACH_DETACH): Delete.
	* config/i386/nm-i386sco5.h (ATTACH_DETACH): Delete.
	* config/i386/nm-i386sco4.h (ATTACH_DETACH): Delete.
	* config/i386/nm-i386gnu.h (ATTACH_DETACH): Delete.

Index: doc/ChangeLog
2004-06-08  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Native Debugging): Delete documentation on
	ATTACH_DETACH.
@
text
@d122 1
a122 1
#ifndef	NO_SYS_FILE
@


1.31
log
@2004-04-08  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Declare.
	* hppa-hpux-tdep.c (initialize_hp_cxx_exception_support)
	(initialize_hp_cxx_exception_support)
	(child_enable_exception_callback): Update.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Rename
	deprecated_exception_catchpoints_are_fragile and
	deprecated_exception_support_initialized.
	(breakpoint_init_inferior, breakpoint_init_inferior): Update.

	* symtab.c (deprecated_hp_som_som_object_present): Rename
	hp_som_som_object_present.
	* symtab.h (deprecated_hp_som_som_object_present): Declare.
	* symfile.c (hp_som_som_object_present, RESET_HP_UX_GLOBALS):
	Update.  Delete extern declaration.
	* valops.c (hp_som_som_object_present): Ditto.
	* parse.c (deprecated_hp_som_som_object_present)
	(parse_nested_classes_for_hpacc): Ditto.
	* hpread.c (hp_som_som_object_present, hpread_expand_symtab): Ditto.
	* hppa-hpux-tdep.c (hp_som_som_object_present)
	(initialize_hp_cxx_exception_support): Ditto.
	* eval.c (hp_som_som_object_present, evaluate_subexp_standard): Ditto.
	* cp-valprint.c (hp_som_som_object_present)
	(cp_print_class_method): Ditto.
	* c-typeprint.c (hp_som_som_object_present):
	(c_type_print_base): Ditto.
	* c-exp.y (hp_som_som_object_present): Ditto.
@
text
@a4562 2

#ifdef ATTACH_DETACH
a4733 1
#endif /* ATTACH_DETACH */
a4735 1
#ifdef ATTACH_DETACH
a4801 1
#endif /* ATTACH_DETACH */
@


1.30
log
@2004-04-06  Andrew Cagney  <cagney@@redhat.com>

	* infttrace.c: Include "infttrace.h".
	* infttrace.h: Include "target.h".
	* Makefile.in (infttrace_h): Update.
	(infttrace.o): Update.
@
text
@d2 3
a4 3
   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998,
   1999, 2000, 2001, 2003
   Free Software Foundation, Inc.
@


1.29
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d31 1
@


1.29.10.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 3
a4 3

   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1998, 1999, 2000, 2001, 2003, 2004 Free Software Foundation, Inc.
a30 1
#include "infttrace.h"
d48 4
d121 1
a121 1
#ifdef	HAVE_SYS_FILE_H
d4562 2
d4735 1
d4738 1
d4805 1
@


1.29.10.2
log
@Merge from mainline.
@
text
@d3845 1
a3845 1
#ifndef DEPRECATED_CHILD_RESUME
d4256 1
a4256 1
#ifndef DEPRECATED_CHILD_RESUME
d4557 1
a4557 1
#endif /* DEPRECATED_CHILD_RESUME */
@


1.28
log
@	* arch-utils.c (default_prepare_to_proceed): Remove.
	(generic_prepare_to_proceed): Remove.
	* arch-utils.h (default_prepare_to_proceed): Remove prototype.
	(generic_prepare_to_proceed): Remove prototype.
	* gdbarch.sh (PREPARE_TO_PROCEED): Remove.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-tdep.c (hppa_prepare_to_proceed): Remove dangling prototype.
	* hppah-nat.c (hppa_switched_threads): Remove.
	* infrun.c (prepare_to_proceed): New static function, copied from
	generic_prepare_to_proceed.  Remove select_it argument.
	(proceed): Call prepare_to_proceed.
	* infttrace.c (old_gdb_pid, reported_pid, reported_bpt): Remove
	variables.
	(ptrace_wait): Don't set the removed variables.
	(hppa_switched_threads): Remove.
	* lin-lwp.c (lin_lwp_prepare_to_proceed): Remove.
	* config/nm-linux.h (PREPARE_TO_PROCEED): Don't define.
	(lin_lwp_prepare_to_proceed): Remove prototype.
	* config/i386/nm-x86-64linux.h (PREPARE_TO_PROCEED): Don't undefine.
	* config/pa/nm-hppah.h (PREPARE_TO_PROCEED): Don't define.
@
text
@d4839 1
a4839 1
  register int i;
d4841 1
a4841 1
  register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (TTRACE_XFER_TYPE);
d4843 1
a4843 1
  register int count
d4850 1
a4850 1
  register TTRACE_XFER_TYPE *buffer
@


1.27
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* infttrace.c: Include "gdbthread.h".
	(parent_attach_all): Fix function signature.
	(call_ptrace): Update call.
	* Makefile.in (infttrace.o): Update dependencies.
@
text
@a144 6
/* To support PREPARE_TO_PROCEED (hppa_prepare_to_proceed).
 */
static pid_t old_gdb_pid = 0;
static pid_t reported_pid = 0;
static int reported_bpt = 0;

a2908 6
  /* Remember this for later use in "hppa_prepare_to_proceed".
   */
  old_gdb_pid = PIDGET (inferior_ptid);
  reported_pid = return_pid;
  reported_bpt = ((tsp.tts_event & TTEVT_SIGNAL) && (5 == tsp.tts_u.tts_signal.tts_signo));

a5525 58

/* If the current pid is not the pid this module reported
 * from "ptrace_wait" with the most recent event, then the
 * user has switched threads.
 *
 * If the last reported event was a breakpoint, then return
 * the old thread id, else return 0.
 */
pid_t
hppa_switched_threads (pid_t gdb_pid)
{
  if (gdb_pid == old_gdb_pid)
    {
      /*
       * Core gdb is working with the same pid that it
       * was before we reported the last event.  This
       * is ok: e.g. we reported hitting a thread-specific
       * breakpoint, but we were reporting the wrong
       * thread, so the core just ignored the event.
       *
       * No thread switch has happened.
       */
      return (pid_t) 0;
    }
  else if (gdb_pid == reported_pid)
    {
      /*
       * Core gdb is working with the pid we reported, so
       * any continue or step will be able to figure out
       * that it needs to step over any hit breakpoints
       * without our (i.e. PREPARE_TO_PROCEED's) help.
       */
      return (pid_t) 0;
    }
  else if (!reported_bpt)
    {
      /*
       * The core switched, but we didn't just report a
       * breakpoint, so there's no just-hit breakpoint
       * instruction at "reported_pid"'s PC, and thus there
       * is no need to step over it.
       */
      return (pid_t) 0;
    }
  else
    {
      /* There's been a real switch, and we reported
       * a hit breakpoint.  Let "hppa_prepare_to_proceed"
       * know, so it can see whether the breakpoint is
       * still active.
       */
      return reported_pid;
    }

  /* Keep compiler happy with an obvious return at the end.
   */
  return (pid_t) 0;
}
@


1.26
log
@2003-03-29  Andrew Cagney  <cagney@@redhat.com>

	* infttrace.h: New file.
	* hpread.c: Include "gdb_assert.h" and "somsolib.h".
	(hpread_get_textlow): Detect an uninitialized dn_bufp.
	(hpread_read_doc_function_type): Detect an initialized type1.
	(hpread_quick_traverse): Initialize mod_name_string.
	* somsolib.h: Add #ifdef SOMSOLIB_H wrapper.
	(som_solib_get_solib_by_pc): Declare.
	(so_lib_thread_start_addr): Declare.
	(no_shared_libraries): Declare.
	* somread.c (init_import_symbols): Make static.  Add forward
	declaration.
	* config/pa/nm-hppah.h: Include "infttrace.h" for
	parent_attach_all.
	(hppa_insert_hw_watchpoint): Declare.
	(hppa_can_use_hw_watchpoint, hppa_remove_hw_watchpoint): Declare.
	* hppah-nat.c: Include "gdb_string.h".
	(parent_attach_all): Delete extern declaration, moved to
	"infttrace.h".
	(hppa_can_use_hw_watchpoint): Change type of "type" parameter to
	int.
	(hppa_remove_hw_watchpoint, hppa_insert_hw_watchpoint): Ditto.
	* Makefile.in (infttrace_h): Define.
	(hpread.o): Update dependencies.
	(hppah-nat.o, hppa-hpux-tdep.o, hppa-tdep.o): Ditto.
	* hppa-hpux-tdep.c: Include "gdb_string.h".
	* hppa-tdep.c (hppa_frame_saved_pc): Initialize "old_pc".
	* infrun.c (handle_inferior_event): Always initialize
	stepped_after_stopped_by_watchpoint.  Add default and remove
	fallthrough in switch statement.
	* infttrace.c (hppa_can_use_hw_watchpoint): Change type of "type"
	parameter to int.
	(hppa_remove_hw_watchpoint): Ditto.
@
text
@d30 1
d2951 1
a2951 1
parent_attach_all (void)
d3678 1
a3678 1
      return parent_attach_all ();
@


1.25
log
@Checked in as obvious fixes.  Also updated FSF copyright year to 2003
for remote-e7000.c and infttrace.c.

	2003-02-05  Fred Fish  <fnf@@intrinsity.com>
	* remote-e7000.c (e7000_drain_command): Fix precedence problem with
	'=' and '!='.
	* rdi-share/ardi.c (wait_for_debug_message): Fix precedence problem
	with '&' and '=='.
	(angel_RDI_info): Ditto.
	* infttrace.c (threads_continue_all_but_one): Fix precedence problem
	with '&' and '!='.
	(threads_continue_all_with_signals): Ditto.
@
text
@d5381 1
a5381 2
hppa_remove_hw_watchpoint (int pid, CORE_ADDR start, LONGEST len,
			   enum bptype type)
d5441 1
a5441 1
hppa_can_use_hw_watchpoint (enum bptype type, int cnt, enum bptype ot)
@


1.25.10.1
log
@Merge with mainline.
@
text
@a29 1
#include "gdbthread.h"
d2950 1
a2950 1
parent_attach_all (int p1, PTRACE_ARG3_TYPE p2, int p3)
d3677 1
a3677 1
      return parent_attach_all (0, 0, 0);
d5381 2
a5382 1
hppa_remove_hw_watchpoint (int pid, CORE_ADDR start, LONGEST len, int type)
d5442 1
a5442 1
hppa_can_use_hw_watchpoint (int type, int cnt, int ot)
@


1.24
log
@	* corelow.c (init_core_ops): Delete references to to_require_attach
	and to_require_detach.
	* exec.c (init_exec_ops): Likewise.
	* hppah-nat.c (child_follow_fork): Call hppa_require_attach and
	hppa_require_detach directly.
	* inferior.h (REQUIRE_ATTACH, REQUIRE_DETACH): Delete.
	* inftarg.c (child_detach): Remove.
	(child_detach_from_process): Rename to child_detach, remove
	after_fork argument.
	(child_attach): Remove.
	(child_attach_to_process): Rename to child_attach, remove after_fork
	argument.
	(init_child_ops): Delete references to to_require_attach
	and to_require_detach.
	* infttrace.c (hppa_require_attach): Update comment.
	* target.c (cleanup_target, update_current_target)
	(init_dummy_target, setup_target_debug): Delete references to
	to_require_attach and to_require_detach.
	(find_default_require_detach, find_default_require_attach)
	(debug_to_require_attach, debug_to_require_detach): Remove
	functions.
	* target.h (struct target_ops): Remove to_require_attach
	and to_require_detach.
	(target_require_attach, target_require_detach): Delete macros.
	(find_default_require_detach, find_default_require_attach): Delete
	prototypes.
	* config/pa/nm-hppah.h (REQUIRE_ATTACH, REQUIRE_DETACH): Delete.
@
text
@d3 1
a3 1
   1999, 2000, 2001
d3954 1
a3954 1
	if (state.tts_flags & TTS_STATEMASK != TTS_WASSUSPENDED)
d4088 1
a4088 1
	if (state.tts_flags & TTS_STATEMASK != TTS_WASSUSPENDED)
@


1.23
log
@	* hppah-nat.c (saved_child_execd_pathname, saved_vfork_state): New.
	(child_post_follow_vfork): Cancel pending exec event if we follow
	the parent.
	(child_wait): Only return TARGET_WAITKIND_VFORKED when all necessary
	events have been processed.  Return a fake TARGET_WAITKIND_EXECD
	event at the following wait call if necessary.
	* infrun.c (follow_vfork): Don't follow_exec here.
	(handle_inferior_event): Add comment to TARGET_WAITKIND_EXECD
	case about HP/UX 10.20.  Remove code pushed down to
	hppah-nat.c:child_wait.
	* infttrace.c (child_resume): Use TT_PROC_CONTINUE if
	vfork_in_flight is set.
@
text
@d5053 1
a5053 3
/* Called via #define REQUIRE_ATTACH from inftarg.c,
 * ultimately from "follow_inferior_fork" in infrun.c,
 * itself called from "resume".
@


1.22
log
@	* breakpoint.c (bpstat_stop_status): Call inferior_has_forked,
	inferior_has_vforked, and inferior_has_execd instead of
	target_has_forked, target_has_vforked, and target_has_execd.
	* config/pa/nm-hppah.h (CHILD_HAS_FORKED, CHILD_HAS_VFORKED)
	(CHILD_HAS_EXECD, CHILD_HAS_SYSCALL_EVENT): Don't define.
	(CHILD_WAIT): Define.
	(child_wait): Add prototype.
	* hppah-nat.c (hpux_has_forked): Rename from child_has_forked.
	Add prototype.
	(hpux_has_vforked): Likewise, from child_has_vforked.
	(hpux_has_execd): Likewise, from child_has_execd.
	(hpux_has_syscall_event): Likewise, from child_has_syscall_event.
	(not_same_real_pid, child_wait): New, copied from inftarg.c.
	Call hpux_has_forked, hpux_has_vforked, hpux_has_execd,
	and hpux_has_syscall_event instead of the target hooks.
	* infrun.c (inferior_has_forked, inferior_has_vforked)
	(inferior_has_execd): New functions.
	* inftarg.c (not_same_real_pid): Remove.
	(child_wait): Remove references to not_same_real_pid,
	target_has_forked, target_has_vforked, target_has_execd,
	and target_has_syscall_event.
	(child_has_forked, child_has_vforked, child_has_execd)
	(child_has_syscall_event): Remove.
	(init_child_ops): Remove references to child_has_forked,
	child_has_vforked, child_has_execd, and child_has_syscall_event.
	* infttrace.c (hpux_has_forked): Rename from child_has_forked.
	(hpux_has_vforked): Likewise, from child_has_vforked.
	(hpux_has_execd): Likewise, from child_has_execd.
	(hpux_has_syscall_event): Likewise, from child_has_syscall_event.
	* target.c (cleanup_target): Remove references to
	to_has_forked, to_has_vforked, to_has_execd, and
	to_has_syscall_event.
	(update_current_target): Likewise.
	(setup_target_debug): Likewise.
	(debug_to_has_forked): Remove.
	(debug_to_has_vforked): Remove.
	(debug_to_has_execd): Remove.
	(debug_to_has_syscall_event): Remove.
	* target.h (struct target_ops): Remove to_has_forked.
	to_has_vforked, to_has_execd, and to_has_syscall_event.
	(child_has_forked, child_has_vforked, child_has_execd)
	(child_has_syscall_event): Remove prototypes.
	(inferior_has_forked, inferior_has_vforked, inferior_has_execd): Add
	prototypes.
	(target_has_forked, target_has_vforked, target_has_execd)
	(target_has_syscall_event): Remove macros.
@
text
@d4526 9
a4534 1
      if (resume_all_threads)
@


1.21
log
@	* hppah-nat.c (child_can_follow_vfork_prior_to_exec): Remove.
	* inftarg.c (child_can_follow_vfork_prior_to_exec): Remove.
	(init_child_ops): Don't initialize to_can_follow_vfork_prior_to_exec.
	* infttrace.c (child_can_follow_vfork_prior_to_exec): Remove.
	* target.c (cleanup_target): Remove reference to
	to_can_follow_vfork_prior_to_exec.
	(update_current_target): Likewise.
	(debug_to_can_follow_vfork_prior_to_exec): Remove.
	(setup_target_debug): Remove reference to
	to_can_follow_vfork_prior_to_exec.
	* target.h (struct target_ops): Remove
	to_can_follow_vfork_prior_to_exec.
	(child_can_follow_vfork_prior_to_exec): Remove prototype.
	(target_can_follow_vfork_prior_to_exec): Remove definition.
	* config/pa/nm-hppah.h (CHILD_CAN_FOLLOW_VFORK_PRIOR_TO_EXEC): Don't
	define.
	* infrun.c (follow_vfork_when_exec): Remove.
	(follow_inferior_fork): Remove references to follow_vfork_when_exec.
	(follow_exec): Likewise.
	(handle_inferior_event): Likewise.
	(keep_going): Likewise.
@
text
@d2292 1
a2292 1
     target_has_execd can then use this cached state, rather than
a3359 2
#if defined(CHILD_HAS_FORKED)

d3367 1
a3367 1
child_has_forked (int tid, int *childpid)
a3403 4
#endif


#if defined(CHILD_HAS_VFORKED)
d3405 1
a3405 1
/* See child_has_forked for pid discussion.
d3408 1
a3408 1
child_has_vforked (int tid, int *childpid)
a3442 1
#endif
a3470 1
#if defined(CHILD_HAS_EXECD)
d3472 1
a3472 1
child_has_execd (int tid, char **execd_pathname)
a3510 1
#endif
a3512 1
#if defined(CHILD_HAS_SYSCALL_EVENT)
d3514 1
a3514 1
child_has_syscall_event (int pid, enum target_waitkind *kind, int *syscall_id)
a3553 1
#endif
@


1.20
log
@        * infttrace.c (child_resume): Simplify and rework to avoid
        TT_PROC_CONTINUE.
@
text
@a3451 15
#if defined(CHILD_CAN_FOLLOW_VFORK_PRIOR_TO_EXEC)
int
child_can_follow_vfork_prior_to_exec (void)
{
  /* ttrace does allow this.

     ??rehrauer: However, I had major-league problems trying to
     convince wait_for_inferior to handle that case.  Perhaps when
     it is rewritten to grok multiple processes in an explicit way...
   */
  return 0;
}
#endif


@


1.20.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2003
a29 1
#include "gdbthread.h"
d144 6
d2292 1
a2292 1
     hpux_has_execd can then use this cached state, rather than
d2914 6
d2950 1
a2950 1
parent_attach_all (int p1, PTRACE_ARG3_TYPE p2, int p3)
d3360 2
d3369 1
a3369 1
hpux_has_forked (int tid, int *childpid)
d3406 2
d3409 3
a3411 1
/* See hpux_has_forked for pid discussion.
d3414 1
a3414 1
hpux_has_vforked (int tid, int *childpid)
d3449 16
d3493 1
d3495 1
a3495 1
hpux_has_execd (int tid, char **execd_pathname)
d3534 1
d3537 1
d3539 1
a3539 1
hpux_has_syscall_event (int pid, enum target_waitkind *kind, int *syscall_id)
d3579 1
d3703 1
a3703 1
      return parent_attach_all (0, 0, 0);
d3980 1
a3980 1
 	if ((state.tts_flags & TTS_STATEMASK) != TTS_WASSUSPENDED)
d4114 1
a4114 1
	if ((state.tts_flags & TTS_STATEMASK) != TTS_WASSUSPENDED)
d4552 1
a4552 9
      /* drow/2002-12-05: However, note that we must use TT_PROC_CONTINUE
	 if we are tracing a vfork.  */
      if (vfork_in_flight)
	{
	  call_ttrace (TT_PROC_CONTINUE, tid, TT_NIL, TT_NIL, TT_NIL);
	  clear_all_handled ();
	  clear_all_stepping_mode ();
	}
      else if (resume_all_threads)
d4868 1
a4868 1
  int i;
d4870 1
a4870 1
  CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (TTRACE_XFER_TYPE);
d4872 1
a4872 1
  int count
d4879 1
a4879 1
  TTRACE_XFER_TYPE *buffer
d5071 3
a5073 1
/* Called from child_follow_fork in hppah-nat.c.
d5401 2
a5402 1
hppa_remove_hw_watchpoint (int pid, CORE_ADDR start, LONGEST len, int type)
d5462 1
a5462 1
hppa_can_use_hw_watchpoint (int type, int cnt, int ot)
d5558 58
@


1.20.2.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d2292 1
a2292 1
     hpux_has_execd can then use this cached state, rather than
d3360 2
d3369 1
a3369 1
hpux_has_forked (int tid, int *childpid)
d3406 2
d3409 3
a3411 1
/* See hpux_has_forked for pid discussion.
d3414 1
a3414 1
hpux_has_vforked (int tid, int *childpid)
d3449 16
d3493 1
d3495 1
a3495 1
hpux_has_execd (int tid, char **execd_pathname)
d3534 1
d3537 1
d3539 1
a3539 1
hpux_has_syscall_event (int pid, enum target_waitkind *kind, int *syscall_id)
d3579 1
d4552 1
a4552 9
      /* drow/2002-12-05: However, note that we must use TT_PROC_CONTINUE
	 if we are tracing a vfork.  */
      if (vfork_in_flight)
	{
	  call_ttrace (TT_PROC_CONTINUE, tid, TT_NIL, TT_NIL, TT_NIL);
	  clear_all_handled ();
	  clear_all_stepping_mode ();
	}
      else if (resume_all_threads)
d5071 3
a5073 1
/* Called from child_follow_fork in hppah-nat.c.
@


1.20.2.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2003
d3954 1
a3954 1
 	if ((state.tts_flags & TTS_STATEMASK) != TTS_WASSUSPENDED)
d4088 1
a4088 1
	if ((state.tts_flags & TTS_STATEMASK) != TTS_WASSUSPENDED)
@


1.20.2.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a29 1
#include "gdbthread.h"
d2950 1
a2950 1
parent_attach_all (int p1, PTRACE_ARG3_TYPE p2, int p3)
d3677 1
a3677 1
      return parent_attach_all (0, 0, 0);
d5381 2
a5382 1
hppa_remove_hw_watchpoint (int pid, CORE_ADDR start, LONGEST len, int type)
d5442 1
a5442 1
hppa_can_use_hw_watchpoint (int type, int cnt, int ot)
@


1.20.2.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d145 6
d2915 6
d5538 58
@


1.20.2.5
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d4839 1
a4839 1
  int i;
d4841 1
a4841 1
  CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (TTRACE_XFER_TYPE);
d4843 1
a4843 1
  int count
d4850 1
a4850 1
  TTRACE_XFER_TYPE *buffer
@


1.19
log
@* infttrace.c: Include <sys/pstat.h>.
(child_pid_to_exec_file): Revamp.  Use pstat call to get the
exec file if the ttrace equivalent fails.
@
text
@d4542 11
a4552 9
      /* TT_LWP_CONTINUE can pass signals to threads,
       * TT_PROC_CONTINUE can't.  So if there are any
       * signals to pass, we have to use the (slower)
       * loop over the stopped threads.
       *
       * Equally, if we have to not continue some threads,
       * due to saved events, we have to use the loop.
       */
      if ((signal != 0) || saved_signals_exist ())
a4553 16
	  if (resume_all_threads)
	    {

#ifdef THREAD_DEBUG
	      if (debug_on)
		printf ("Doing a continue by loop of all threads\n");
#endif

	      threads_continue_all_with_signals (tid, signal);

	      clear_all_handled ();
	      clear_all_stepping_mode ();
	    }

	  else
	    {
d4555 2
a4556 1
	      printf ("Doing a continue w/signal of just thread %d\n", tid);
d4559 1
a4559 1
	      threads_continue_one_with_signal (tid, signal);
d4561 2
a4562 7
	      /* Clear the "handled" state of this thread, because
	       * we'll soon get a new event for it.  Other events
	       * can stay as they were.
	       */
	      clear_handled (tid);
	      clear_stepping_mode (tid);
	    }
a4563 1

a4565 27
	  /* No signals to send.
	   */
	  if (resume_all_threads)
	    {
#ifdef THREAD_DEBUG
	      if (debug_on)
		printf ("Doing a continue by process of process %d\n", tid);
#endif

	      if (more_events_left > 0)
		{
		  warning ("Losing buffered events on continue.");
		  more_events_left = 0;
		}

	      call_ttrace (TT_PROC_CONTINUE,
			   tid,
			   TT_NIL,
			   TT_NIL,
			   TT_NIL);

	      clear_all_handled ();
	      clear_all_stepping_mode ();
	    }

	  else
	    {
d4567 1
a4567 6
	      if (debug_on)
		{
		  printf ("Doing a continue of just thread %d\n", tid);
		  if (is_terminated (tid))
		    printf ("Why are we continuing a dead thread? (5)\n");
		}
d4570 1
a4570 5
	      call_ttrace (TT_LWP_CONTINUE,
			   tid,
			   TT_NIL,
			   TT_NIL,
			   TT_NIL);
d4572 5
a4576 7
	      /* Clear the "handled" state of this thread, because
	       * we'll soon get a new event for it.  Other events
	       * can stay as they were.
	       */
	      clear_handled (tid);
	      clear_stepping_mode (tid);
	    }
@


1.19.8.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d4542 17
a4558 2
      /* TT_LWP_CONTINUE can pass signals to threads, TT_PROC_CONTINUE can't.
	 Therefore, we really can't use TT_PROC_CONTINUE here.
d4560 8
a4567 9
	 Consider a process which stopped due to signal which gdb decides
	 to handle and not pass on to the inferior.  In that case we must
	 clear the pending signal by restarting the inferior using
	 TT_LWP_CONTINUE and pass zero as the signal number.  Else the
	 pending signal will be passed to the inferior.  interrupt.exp
	 in the testsuite does this precise thing and fails due to the
	 unwanted signal delivery to the inferior.  */
      if (resume_all_threads)
	{
d4569 1
a4569 2
	  if (debug_on)
	    printf ("Doing a continue by loop of all threads\n");
d4572 1
a4572 1
	  threads_continue_all_with_signals (tid, signal);
d4574 7
a4580 2
	  clear_all_handled ();
	  clear_all_stepping_mode ();
d4582 1
d4585 27
d4613 6
a4618 1
	  printf ("Doing a continue w/signal of just thread %d\n", tid);
d4621 5
a4625 1
	  threads_continue_one_with_signal (tid, signal);
d4627 7
a4633 5
	  /* Clear the "handled" state of this thread, because we
	     will soon get a new event for it.  Other events can
	     stay as they were.  */
	  clear_handled (tid);
	  clear_stepping_mode (tid);
@


1.19.14.1
log
@2002-09-15  Elena Zannoni  <ezannoni@@redhat.com>

        From Jeff Law <law@@redhat.com>
        * infttrace.c (child_resume): Simplify and rework to avoid
        TT_PROC_CONTINUE.
@
text
@d4542 17
a4558 2
      /* TT_LWP_CONTINUE can pass signals to threads, TT_PROC_CONTINUE can't.
	 Therefore, we really can't use TT_PROC_CONTINUE here.
d4560 8
a4567 9
	 Consider a process which stopped due to signal which gdb decides
	 to handle and not pass on to the inferior.  In that case we must
	 clear the pending signal by restarting the inferior using
	 TT_LWP_CONTINUE and pass zero as the signal number.  Else the
	 pending signal will be passed to the inferior.  interrupt.exp
	 in the testsuite does this precise thing and fails due to the
	 unwanted signal delivery to the inferior.  */
      if (resume_all_threads)
	{
d4569 1
a4569 2
	  if (debug_on)
	    printf ("Doing a continue by loop of all threads\n");
d4572 1
a4572 1
	  threads_continue_all_with_signals (tid, signal);
d4574 7
a4580 2
	  clear_all_handled ();
	  clear_all_stepping_mode ();
d4582 1
d4585 27
d4613 6
a4618 1
	  printf ("Doing a continue w/signal of just thread %d\n", tid);
d4621 5
a4625 1
	  threads_continue_one_with_signal (tid, signal);
d4627 7
a4633 5
	  /* Clear the "handled" state of this thread, because we
	     will soon get a new event for it.  Other events can
	     stay as they were.  */
	  clear_handled (tid);
	  clear_stepping_mode (tid);
@


1.18
log
@2002-01-07  Michael Snyder  <msnyder@@redhat.com>

	* infptrace.c (GDB_MAX_ALLOCA): New define.
	(child_xfer_memory): Use xmalloc/xfree instead of alloca if the
	size of the buffer exceeds GDB_MAX_ALLOCA (default 1 megabyte,
	can be overridden with whatever value is appropriate to the host).
	* infttrace.c (child_xfer_memory): Add FIXME warning about use of
	alloca to allocate potentially large buffer.
	* rs6000-nat.c (child_xfer_memory): Ditto.
	* symm-nat.c (child_xfer_memory): Ditto.
	* x86-64-linux-nat.c (child_xfer_memory): Ditto.
@
text
@d31 8
d5070 1
d5076 1
d5078 2
a5079 7
  int tt_status;
  CORE_ADDR top_of_stack;
  char four_chars[4];
  int name_index;
  int i;
  int done;
  ptid_t saved_inferior_ptid;
d5081 3
a5083 3
  /* As of 10.x HP-UX, there's an explicit request to get the
   *pathname.
   */
d5086 3
a5088 3
			   (TTRACE_ARG_TYPE) exec_file_buffer,
			   (TTRACE_ARG_TYPE) sizeof (exec_file_buffer) - 1,
			   TT_NIL);
d5092 5
a5096 4
  /* ??rehrauer: The above request may or may not be broken.  It
     doesn't seem to work when I use it.  But, it may be designed
     to only work immediately after an exec event occurs.  (I'm
     waiting for COSL to explain.)
d5098 3
a5100 7
     In any case, if it fails, try a really, truly amazingly gross
     hack that DDE uses, of pawing through the process' data
     segment to find the pathname.
   */
  top_of_stack = (TARGET_PTR_BIT == 64 ? 0x800003ffff7f0000 : 0x7b03a000);
  name_index = 0;
  done = 0;
d5102 1
a5102 23
  /* On the chance that pid != inferior_ptid, set inferior_ptid
     to pid, so that (grrrr!) implicit uses of inferior_ptid get
     the right id.
   */
  saved_inferior_ptid = inferior_ptid;
  inferior_ptid = pid_to_ptid (tid);

  /* Try to grab a null-terminated string. */
  while (!done)
    {
      if (target_read_memory (top_of_stack, four_chars, 4) != 0)
	{
	  inferior_ptid = saved_inferior_ptid;
	  return NULL;
	}
      for (i = 0; i < 4; i++)
	{
	  exec_file_buffer[name_index++] = four_chars[i];
	  done = (four_chars[i] == '\0');
	  if (done)
	    break;
	}
      top_of_stack += 4;
d5105 1
a5105 8
  if (exec_file_buffer[0] == '\0')
    {
      inferior_ptid = saved_inferior_ptid;
      return NULL;
    }

  inferior_ptid = saved_inferior_ptid;
  return exec_file_buffer;
a5106 1

@


1.17
log
@        * infttrate.c (child_acknowledge_created_inferior): Pass
        correct argument to add_thread.
        (update_thread_state_after_attach): Likewise.
@
text
@d4925 3
d4929 1
a4929 1
  = (TTRACE_XFER_TYPE *) alloca (count * sizeof (TTRACE_XFER_TYPE));
@


1.16
log
@kill_inferior: Issue a TT_PROC_EXIT request rather than a TT_PROC_STOP
request to kill the inferior and its child processes. Otherwise, the
inferior is not killed on HPUX 11.0.  Removed the code that detaches the
child processes since we just killed them.
@
text
@d3126 1
a3126 1
  add_thread (pid);		/* in thread.c */
d4767 1
a4767 1
      add_thread (tid);		/* in thread.c */
@


1.15
log
@Fix some PID/TPID fallout for HP/UX.
From 2001-07-22 Rodney Brown <rbrown64@@csc.com.au>:
* infttrace.c (ptrace_wait): Match external declaration,
and match target_post_wait declaration.
@
text
@d3856 1
a3856 4
	  /* TT_PROC_STOP doesn't require a subsequent ttrace_wait, as it
	   * generates no event.
	   */
	  call_ttrace (TT_PROC_STOP,
a3860 6

	  call_ttrace (TT_PROC_DETACH,
		       t->pid,
		       TT_NIL,
		       (TTRACE_ARG_TYPE) TARGET_SIGNAL_0,
		       TT_NIL);
d3867 1
a3867 1
  call_ttrace (TT_PROC_STOP,
@


1.14
log
@        * infptrace.c (child_xfer_memory): Add cast to CORE_ADDR.
        * infttrace.c (child_xfer_memory): Likewise.
        * symm-nat.c (child_xfer_memory): Likewise.
        * gdbserver/low-hppabsd.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-linux.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-lynx.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-nbsd.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-sparc.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-sun3.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
@
text
@d2599 1
a2599 1
ptid_t
d2624 1
a2624 1
	  return inferior_ptid;
d2630 1
a2630 1
      return inferior_ptid;
d2891 1
a2891 1
  target_post_wait (tsp.tts_pid, *status);
d2917 1
a2917 1
  return pid_to_ptid (return_pid);
@


1.13
log
@From 2001-07-16 Rodney Brown <rbrown64@@csc.com.au>:
* infttrace.c (child_thread_alive): Fix gdb_tid typo.
* somsolib.c (no_shared_libraries): Provide stub.
* xcoffsolib.c (no_shared_libraries): Provide stub.
@
text
@d4928 1
a4928 1
  register CORE_ADDR addr = memaddr & -sizeof (TTRACE_XFER_TYPE);
@


1.12
log
@Phase 1 of the ptid_t changes.
@
text
@d3588 1
a3588 1
  lwpid_t gdp_tid = PIDGET (ptid);
@


1.11
log
@malloc() -> xmalloc.
Move malloc() decl to utils.c
@
text
@d386 1
a386 1
static saved_real_pid = 0;
d626 1
a626 1
      saved_real_pid = inferior_pid;
d1241 1
a1241 1
         If so, is it inferior_pid and is a vfork in flight?  If yes to
d1628 1
a1628 1
	      if (saved_real_pid != 0)
d1632 2
a1633 1
		    printf ("...using saved pid %d\n", saved_real_pid);
d1636 1
a1636 1
		  real_pid = saved_real_pid;
d1657 1
a1657 1
		  if (saved_real_pid == 0)
d1662 1
a1662 1
		      if (gdb_tid != saved_real_pid)
d1664 1
a1664 1
				gdb_tid, saved_real_pid);
d1751 1
a1751 1
  (((evt) == TTEVT_VFORK) && ((pid) != inferior_pid))
d1755 1
a1755 1
  (((evt) == TTEVT_VFORK) && ((pid) == inferior_pid))
d2599 2
a2600 2
int
ptrace_wait (int pid, int *status)
d2624 1
a2624 1
	  return inferior_pid;
d2630 1
a2630 1
      return inferior_pid;
d2692 1
a2692 1
		real_pid, real_tid, inferior_pid);
d2855 1
a2855 1
      inferior_pid = map_to_gdb_tid (real_tid);		/* HACK, FIX */
d2908 1
a2908 1
  old_gdb_pid = inferior_pid;
d2917 1
a2917 1
  return return_pid;
d3154 1
a3154 1
child_post_startup_inferior (int real_pid)
d3156 1
a3156 1
  require_notification_of_events (real_pid);
d3586 1
a3586 1
child_thread_alive (lwpid_t gdb_tid)
d3588 1
d3820 1
a3820 1
  if (inferior_pid == 0)
d3824 1
a3824 1
     aka "processes".  For each that is NOT inferior_pid, stop it,
d3854 1
a3854 1
      if (t->am_pseudo && (t->pid != inferior_pid))
d3877 1
a3877 1
	       inferior_pid,
d4318 1
a4318 1
 *       |                           "inferior_pid")
d4328 1
a4328 1
child_resume (lwpid_t gdb_tid, int step, enum target_signal signal)
d4333 1
d4348 1
a4348 1
	tid = map_from_gdb_tid (inferior_pid);
d4654 1
a4654 1
 * One worry is that we may not be attaching to "inferior_pid"
d4708 1
a4708 1
       * (and is "inferior_pid").
d4882 1
a4882 1
	       inferior_pid,
d4945 1
a4945 1
				   inferior_pid,
d4954 1
a4954 1
					   inferior_pid,
d4973 1
a4973 1
		       inferior_pid,
d4983 1
a4983 1
			   inferior_pid,
d4999 1
a4999 1
				   inferior_pid,
d5050 1
a5050 1
			      inferior_pid,
d5080 1
a5080 1
  int saved_inferior_pid;
d5106 2
a5107 2
  /* On the chance that pid != inferior_pid, set inferior_pid
     to pid, so that (grrrr!) implicit uses of inferior_pid get
d5110 2
a5111 2
  saved_inferior_pid = inferior_pid;
  inferior_pid = tid;
d5118 1
a5118 1
	  inferior_pid = saved_inferior_pid;
d5133 1
a5133 1
      inferior_pid = saved_inferior_pid;
d5137 1
a5137 1
  inferior_pid = saved_inferior_pid;
d5632 1
a5632 1
hppa_pid_or_tid_to_str (pid_t id)
d5635 1
d5639 1
a5639 1
    return child_pid_to_str (id);
d5642 2
a5643 2
  sprintf (buf, "thread %d (", pid_to_thread_id (id));
  strcat (buf, hppa_tid_to_str (id));
@


1.10
log
@Add ``attrib'' parameter to *xfer_memory() functions.
@
text
@d605 1
a605 1
  new_p = malloc (sizeof (thread_info));
d3833 2
a3834 2
  paranoia = (thread_info **) malloc (thread_head.count *
				      sizeof (thread_info *));
@


1.9
log
@Update/correct copyright notices.
@
text
@d4920 1
@


1.8
log
@Replace calls to abort() with calls to internal_error().
@
text
@d2 2
a3 1
   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996
@


1.7
log
@Replace free() with xfree().
@
text
@d5778 1
a5778 1
    abort ();
@


1.6
log
@From 2000-09-06 Angela Marie Thomas <angela@@cygnus.com>:
* infttrace.c (get_dictionary_entry_of_page): Function
require_memory_page_dictionary takes no args.
@
text
@d689 1
a689 1
      free (q);
d701 1
a701 1
      free (q);
d3871 1
a3871 1
  free (paranoia);
d5339 1
a5339 1
  free (page);
@


1.5
log
@	* infttrace.c (update_thread_state_after_attach): Pass address
	of ttstate_t object, not the object itself.
@
text
@d5281 1
a5281 1
  require_memory_page_dictionary (pid);
@


1.4
log
@Protoization.
@
text
@d4714 1
a4714 1
      copy_ttstate_t (&p->last_stop_state, thread_state);
@


1.3
log
@Protoization.
@
text
@d4910 1
a4910 1
   WRITE is nonzero.
d4918 2
a4919 6
child_xfer_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *target;	/* ignored */
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d393 1
a393 2
get_raw_pc (ttid)
     lwpid_t ttid;
d416 1
a416 2
get_printable_name_of_stepping_mode (mode)
     stepping_mode_t mode;
d435 1
a435 2
get_printable_name_of_ttrace_event (event)
     ttevents_t event;
d478 1
a478 2
get_printable_name_of_ttrace_request (request)
     ttreq_t request;
d549 1
a549 2
get_printable_name_of_process_state (process_state)
     process_state_t process_state;
d571 1
a571 2
clear_ttstate_t (tts)
     ttstate_t *tts;
d582 1
a582 3
copy_ttstate_t (tts_to, tts_from)
     ttstate_t *tts_to;
     ttstate_t *tts_from;
d590 1
a590 1
any_thread_records ()
d598 1
a598 3
create_thread_info (pid, tid)
     int pid;
     lwpid_t tid;
d674 1
a674 1
clear_thread_info ()
d716 1
a716 2
find_thread_info (tid)
     lwpid_t tid;
d747 1
a747 2
map_from_gdb_tid (gdb_tid)
     lwpid_t gdb_tid;
d796 1
a796 2
map_to_gdb_tid (real_tid)
     lwpid_t real_tid;
d826 1
a826 1
saved_signals_exist ()
d844 1
a844 2
is_pseudo_thread (tid)
     lwpid_t tid;
d856 1
a856 2
is_terminated (tid)
     lwpid_t tid;
d869 1
a869 2
is_process_id (pid)
     int pid;
d908 1
a908 3
add_tthread (pid, tid)
     int pid;
     lwpid_t tid;
d922 1
a922 2
del_tthread (tid)
     lwpid_t tid;
d1007 1
a1007 2
get_pid_for (tid)
     lwpid_t tid;
d1033 1
a1033 3
set_handled (pid, tid)
     int pid;
     lwpid_t tid;
d1047 1
a1047 2
was_handled (tid)
     lwpid_t tid;
d1061 1
a1061 2
clear_handled (tid)
     lwpid_t tid;
d1080 1
a1080 1
clear_all_handled ()
d1103 1
a1103 2
clear_stepping_mode (tid)
     lwpid_t tid;
d1122 1
a1122 1
clear_all_stepping_mode ()
d1145 1
a1145 1
set_all_unseen ()
d1159 1
a1159 2
print_tthread (p)
     thread_info *p;
d1191 1
a1191 1
print_tthreads ()
d1231 1
a1231 1
update_thread_list ()
d1279 2
a1280 5
call_real_ttrace (request, pid, tid, addr, data, addr2)
     ttreq_t request;
     pid_t pid;
     lwpid_t tid;
     TTRACE_ARG_TYPE addr, data, addr2;
d1333 2
a1334 6
call_real_ttrace_wait (pid, tid, option, tsp, tsp_size)
     int pid;
     lwpid_t tid;
     ttwopt_t option;
     ttstate_t *tsp;
     size_t tsp_size;
d1364 1
a1364 3
get_process_first_stopped_thread_id (pid, thread_state)
     int pid;
     ttstate_t *thread_state;
d1412 1
a1412 3
get_process_next_stopped_thread_id (pid, thread_state)
     int pid;
     ttstate_t *thread_state;
d1454 1
a1454 2
get_active_tid_of_pid (pid)
     int pid;
d1465 1
a1465 2
is_process_ttrace_request (tt_request)
     ttreq_t tt_request;
d1475 1
a1475 2
make_process_version (request)
     ttreq_t request;
d1519 2
a1520 4
call_ttrace (request, gdb_tid, addr, data, addr2)
     ttreq_t request;
     int gdb_tid;
     TTRACE_ARG_TYPE addr, data, addr2;
d1718 1
a1718 2
stop_all_threads_of_process (real_pid)
     pid_t real_pid;
d1756 1
a1756 3
can_touch_threads_of_process (pid, stopping_event)
     int pid;
     ttevents_t stopping_event;
d1784 1
a1784 3
select_stopped_thread_of_process (pid, tsp)
     int pid;
     ttstate_t *tsp;
d1938 1
a1938 2
check_thread_consistency (real_pid)
     pid_t real_pid;
d2004 1
a2004 5
call_ttrace_wait (pid, option, tsp, tsp_size)
     int pid;
     ttwopt_t option;
     ttstate_t *tsp;
     size_t tsp_size;
d2301 1
a2301 1
child_reported_exec_events_per_exec_call ()
d2351 1
a2351 1
require_memory_page_dictionary ()
d2373 1
a2373 1
retire_memory_page_dictionary ()
d2384 1
a2384 3
write_protect_page (pid, page_start)
     int pid;
     CORE_ADDR page_start;
d2423 1
a2423 4
unwrite_protect_page (pid, page_start, original_permissions)
     int pid;
     CORE_ADDR page_start;
     int original_permissions;
d2446 1
a2446 2
hppa_enable_page_protection_events (pid)
     int pid;
d2473 1
a2473 2
hppa_disable_page_protection_events (pid)
     int pid;
d2500 1
a2500 3
count_unhandled_events (real_pid, real_tid)
     int real_pid;
     lwpid_t real_tid;
d2598 1
a2598 3
ptrace_wait (pid, status)
     int pid;
     int *status;
d2940 1
a2940 1
parent_attach_all ()
d2999 1
a2999 2
require_notification_of_events (real_pid)
     int real_pid;
d3049 1
a3049 2
require_notification_of_exec_events (real_pid)
     int real_pid;
d3093 1
a3093 2
child_acknowledge_created_inferior (pid)
     int pid;
d3152 1
a3152 2
child_post_startup_inferior (real_pid)
     int real_pid;
d3160 1
a3160 2
hppa_enable_catch_fork (tid)
     int tid;
d3194 1
a3194 2
hppa_disable_catch_fork (tid)
     int tid;
d3231 1
a3231 2
child_insert_fork_catchpoint (tid)
     int tid;
d3244 1
a3244 2
child_remove_fork_catchpoint (tid)
     int tid;
d3256 1
a3256 2
hppa_enable_catch_vfork (tid)
     int tid;
d3292 1
a3292 2
hppa_disable_catch_vfork (tid)
     int tid;
d3327 1
a3327 2
child_insert_vfork_catchpoint (tid)
     int tid;
d3340 1
a3340 2
child_remove_vfork_catchpoint (tid)
     int tid;
d3359 1
a3359 3
child_has_forked (tid, childpid)
     int tid;
     int *childpid;
d3404 1
a3404 3
child_has_vforked (tid, childpid)
     int tid;
     int *childpid;
d3444 1
a3444 1
child_can_follow_vfork_prior_to_exec ()
d3459 1
a3459 2
child_insert_exec_catchpoint (tid)
     int tid;
d3472 1
a3472 2
child_remove_exec_catchpoint (tid)
     int tid;
d3485 1
a3485 3
child_has_execd (tid, execd_pathname)
     int tid;
     char **execd_pathname;
d3529 1
a3529 4
child_has_syscall_event (pid, kind, syscall_id)
     int pid;
     enum target_waitkind *kind;
     int *syscall_id;
d3584 1
a3584 2
child_thread_alive (gdb_tid)
     lwpid_t gdb_tid;
d3610 2
a3611 5
read_from_register_save_state (tid, ss_offset, buf, sizeof_buf)
     int tid;
     TTRACE_ARG_TYPE ss_offset;
     char *buf;
     int sizeof_buf;
d3642 2
a3643 5
write_to_register_save_state (tid, ss_offset, buf, sizeof_buf)
     int tid;
     TTRACE_ARG_TYPE ss_offset;
     char *buf;
     int sizeof_buf;
d3668 1
a3668 5
call_ptrace (pt_request, gdb_tid, addr, data)
     int pt_request;
     int gdb_tid;
     PTRACE_ARG3_TYPE addr;
     int data;
d3809 1
a3809 1
kill_inferior ()
d3888 1
a3888 2
thread_dropping_event_check (p)
     thread_info *p;
d3949 1
a3949 3
threads_continue_all_but_one (gdb_tid, signal)
     lwpid_t gdb_tid;
     int signal;
d4086 1
a4086 3
threads_continue_all_with_signals (gdb_tid, signal)
     lwpid_t gdb_tid;
     int signal;
d4202 1
a4202 3
thread_fake_step (tid, signal)
     lwpid_t tid;
     enum target_signal signal;
d4255 1
a4255 3
threads_continue_one_with_signal (gdb_tid, signal)
     lwpid_t gdb_tid;
     int signal;
d4325 1
a4325 4
child_resume (gdb_tid, step, signal)
     lwpid_t gdb_tid;
     int step;
     enum target_signal signal;
d4655 1
a4655 3
update_thread_state_after_attach (pid, kind_of_go)
     int pid;
     attach_continue_t kind_of_go;
d4826 1
a4826 2
attach (pid)
     int pid;
d4857 1
a4857 2
child_post_attach (pid)
     int pid;
d4874 1
a4874 2
detach (signal)
     int signal;
d4897 1
a4897 1
_initialize_kernel_u_addr ()
d5017 1
a5017 1
udot_info ()
d5070 1
a5070 2
child_pid_to_exec_file (tid)
     int tid;
d5142 1
a5142 1
pre_fork_inferior ()
d5171 1
a5171 2
hppa_require_attach (pid)
     int pid;
d5229 1
a5229 3
hppa_require_detach (pid, signal)
     int pid;
     int signal;
d5261 1
a5261 2
get_dictionary_bucket_of_page (page_start)
     CORE_ADDR page_start;
d5278 1
a5278 3
get_dictionary_entry_of_page (pid, page_start)
     int pid;
     CORE_ADDR page_start;
d5327 1
a5327 3
remove_dictionary_entry_of_page (pid, page)
     int pid;
     memory_page_t *page;
d5348 1
a5348 2
hppa_enable_syscall_events (pid)
     int pid;
d5377 1
a5377 2
hppa_disable_syscall_events (pid)
     int pid;
d5418 1
a5418 5
hppa_insert_hw_watchpoint (pid, start, len, type)
     int pid;
     CORE_ADDR start;
     LONGEST len;
     int type;
d5491 2
a5492 5
hppa_remove_hw_watchpoint (pid, start, len, type)
     int pid;
     CORE_ADDR start;
     LONGEST len;
     enum bptype type;
d5552 1
a5552 4
hppa_can_use_hw_watchpoint (type, cnt, ot)
     enum bptype type;
     int cnt;
     enum bptype ot;
d5564 1
a5564 4
hppa_range_profitable_for_hw_watchpoint (pid, start, len)
     int pid;
     CORE_ADDR start;
     LONGEST len;
d5631 1
a5631 2
hppa_pid_or_tid_to_str (id)
     pid_t id;
d5656 1
a5656 2
hppa_switched_threads (gdb_pid)
     pid_t gdb_pid;
d5707 1
a5707 2
hppa_ensure_vforking_parent_remains_stopped (pid)
     int pid;
d5716 1
a5716 1
hppa_resume_execd_vforking_child_to_get_parent_vfork ()
d5729 1
a5729 4
ttrace_write_reg_64 (gdb_tid, dest_addr, src_addr)
     int gdb_tid;
     CORE_ADDR dest_addr;
     CORE_ADDR src_addr;
d5770 1
a5770 1
_initialize_infttrace ()
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d27 1
a27 1
#include "wait.h"
a47 3
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
d118 7
a124 5
   */
typedef struct {
    int  parent_channel[2];  /* Parent "talks" to [1], child "listens" to [0] */
    int  child_channel[2];   /* Child "talks" to [1], parent "listens" to [0] */
} startup_semaphore_t;
d129 1
a129 1
static startup_semaphore_t  startup_semaphore;
d132 2
a133 2
static int  vforking_child_pid = 0;
static int  vfork_in_flight = 0;
d137 1
a137 1
static pid_t old_gdb_pid  = 0;
d150 1
a150 1
   */
d156 1
a156 1
   */
d167 2
a168 2
   */
typedef int  register_value_t;
d294 2
a295 1
typedef enum process_state_enum {
d298 1
a298 1
    FAKE_CONTINUE,   /* For later use */
d302 2
a303 1
} process_state_t;
d309 3
a311 2
typedef enum stepping_mode_enum {
    DO_DEFAULT,  /* ...which is a continue! */
d314 3
a316 2
} stepping_mode_t;
 
d326 6
a331 4
typedef enum attach_continue_enum {
   DO_ATTACH_CONTINUE,
   DONT_ATTACH_CONTINUE
} attach_continue_t;
d339 3
a341 2
static int doing_fake_step  = 0;
static lwpid_t  fake_step_tid    = 0;
a342 1

d347 1
a347 1
typedef 
d349 14
a362 14
{
    int			am_pseudo;      /* This is a pseudo-thread for the process. */
    int                 pid;            /* Process ID */
    lwpid_t             tid;            /* Thread  ID */
    int			handled;        /* 1 if a buffered event was handled. */
    int			seen;           /* 1 if this thread was seen on a traverse. */
    int			terminated;     /* 1 if thread has terminated. */
    int			have_signal;    /* 1 if signal to be sent */
    enum target_signal  signal_value;   /* Signal to send */
    int			have_start;     /* 1 if alternate starting address */
    stepping_mode_t     stepping_mode;  /* Whether to step or continue */
    CORE_ADDR           start;          /* Where to start */
    int			have_state;     /* 1 if the event state has been set */
    ttstate_t           last_stop_state;/* The most recently-waited event for this thread. */
d364 1
a364 1
                       *next;           /* All threads are linked via this field. */
d366 3
a368 2
                       *next_pseudo;    /* All pseudo-threads are linked via this field. */
} thread_info;
d372 2
a373 2
{
    int          count;
a375 2
    
} thread_info_header;
d377 7
a383 2
static thread_info_header thread_head     = { 0, NULL, NULL };
static thread_info_header deleted_threads = { 0, NULL, NULL };
d386 1
a387 1

d393 2
a394 2
get_raw_pc( ttid )
    lwpid_t ttid;
d396 13
a408 12
    unsigned long pc_val;
    int      offset;
    int      res;
 
    offset = register_addr( PC_REGNUM, U_REGS_OFFSET );
    res    = read_from_register_save_state(
                       ttid,
                       (TTRACE_ARG_TYPE) offset,
                       (char *) &pc_val,
                       sizeof( pc_val ));
    if( res <= 0 ) {
        return (CORE_ADDR) pc_val;
d410 3
a412 2
    else {
        return (CORE_ADDR) 0;
d414 1
a414 1
}                   
d417 2
a418 2
get_printable_name_of_stepping_mode( mode )
    stepping_mode_t mode;
d420 11
a430 6
  switch( mode ) {
    case DO_DEFAULT:  return "DO_DEFAULT";
    case DO_STEP:     return "DO_STEP";
    case DO_CONTINUE: return "DO_CONTINUE";
    default:          return "?unknown mode?";
  }
d438 1
a438 1
  ttevents_t event;
d441 2
a442 1
  switch (event) {
d445 1
a445 1
       return "TTEVT_NONE";
d447 1
a447 1
       return "TTEVT_SIGNAL";
d449 1
a449 1
       return "TTEVT_FORK";
d451 1
a451 1
       return "TTEVT_EXEC";
d453 1
a453 1
       return "TTEVT_EXIT";
d455 1
a455 1
       return "TTEVT_VFORK";
d457 1
a457 1
       return "TTEVT_SYSCALL_RETURN";
d459 1
a459 1
       return "TTEVT_LWP_CREATE";
d461 1
a461 1
       return "TTEVT_LWP_TERMINATE";
d463 1
a463 1
       return "TTEVT_LWP_EXIT";
d465 1
a465 1
       return "TTEVT_LWP_ABORT_SYSCALL";
d467 4
a470 4
       return "TTEVT_SYSCALL_ENTRY";
    case TTEVT_SYSCALL_RESTART:	
       return "TTEVT_SYSCALL_RESTART";
    default :
d472 1
a472 1
  }
d474 1
a475 1

d482 1
a482 1
  ttreq_t  request;
d488 3
a490 2
  switch (request) {
    case TT_PROC_SETTRC :
d492 1
a492 1
    case TT_PROC_ATTACH :
d494 1
a494 1
    case TT_PROC_DETACH :
d496 1
a496 1
    case TT_PROC_RDTEXT :
d498 1
a498 1
    case TT_PROC_WRTEXT :
d500 1
a500 1
    case TT_PROC_RDDATA :
d502 1
a502 1
    case TT_PROC_WRDATA :
d504 1
a504 1
    case TT_PROC_STOP :
d506 1
a506 1
    case TT_PROC_CONTINUE :
d508 1
a508 1
    case TT_PROC_GET_PATHNAME :
d510 1
a510 1
    case TT_PROC_GET_EVENT_MASK :
d512 1
a512 1
    case TT_PROC_SET_EVENT_MASK :
d514 1
a514 1
    case TT_PROC_GET_FIRST_LWP_STATE :
d516 1
a516 1
    case TT_PROC_GET_NEXT_LWP_STATE :
d518 1
a518 1
    case TT_PROC_EXIT :
d520 1
a520 1
    case TT_PROC_GET_MPROTECT :
d522 1
a522 1
    case TT_PROC_SET_MPROTECT :
d524 1
a524 1
    case TT_PROC_SET_SCBM :
d526 1
a526 1
    case TT_LWP_STOP :
d528 1
a528 1
    case TT_LWP_CONTINUE :
d530 1
a530 1
    case TT_LWP_SINGLE :
d532 1
a532 1
    case TT_LWP_RUREGS :
d534 1
a534 1
    case TT_LWP_WUREGS :
d536 1
a536 1
    case TT_LWP_GET_EVENT_MASK :
d538 1
a538 1
    case TT_LWP_SET_EVENT_MASK :
d540 1
a540 1
    case TT_LWP_GET_STATE	:
d542 1
a542 1
    default :
d544 1
a544 1
  }
d546 1
a547 1

d554 1
a554 1
  process_state_t  process_state;
d556 2
a557 1
  switch (process_state) {
d570 1
a570 1
  }
d577 1
a577 1
    ttstate_t *  tts;
d579 4
a582 4
    tts->tts_pid = 0;
    tts->tts_lwpid = 0;
    tts->tts_user_tid = 0;
    tts->tts_event = TTEVT_NONE;
d589 2
a590 2
    ttstate_t *  tts_to;
    ttstate_t *  tts_from;
d592 1
a592 1
    memcpy ((char *) tts_to, (char *) tts_from, sizeof (*tts_to));
d597 2
a598 2
static int 
any_thread_records()
d600 1
a600 1
    return( thread_head.count > 0 );
d607 2
a608 2
    int     pid;
    lwpid_t tid;
d610 18
a627 3
    thread_info *  new_p;
    thread_info *  p;
    int  thread_count_of_pid;
d629 2
a630 16
    new_p = malloc( sizeof( thread_info ));
    new_p->pid = pid;
    new_p->tid = tid;
    new_p->have_signal = 0;
    new_p->have_start  = 0;
    new_p->have_state  = 0;
    clear_ttstate_t( &new_p->last_stop_state );
    new_p->am_pseudo   = 0;
    new_p->handled     = 0;
    new_p->seen        = 0;
    new_p->terminated  = 0;
    new_p->next        = NULL;
    new_p->next_pseudo = NULL;
    new_p->stepping_mode = DO_DEFAULT;

    if( 0 == thread_head.count ) {
d632 2
a633 2
        if( debug_on )
            printf( "First thread, pid %d tid %d!\n", pid, tid );
d635 1
a635 1
        saved_real_pid = inferior_pid;
d637 2
a638 1
    else {
d640 2
a641 2
        if( debug_on )
            printf( "Subsequent thread, pid %d tid %d\n", pid, tid );
d645 8
a652 3
    /* Another day, another thread...
     */
    thread_head.count++;
d654 13
a666 4
    /* The new thread always goes at the head of the list.
     */
    new_p->next       = thread_head.head;
    thread_head.head  = new_p;
d668 9
a676 13
    /* Is this the "pseudo" thread of a process?  It is if there's
     * no other thread for this process on the list.  (Note that this
     * accomodates multiple processes, such as we see even for simple
     * cases like forking "non-threaded" programs.)
     */
    p = thread_head.head;
    thread_count_of_pid = 0;
    while (p)
      {
        if (p->pid == new_p->pid)
          thread_count_of_pid++;
        p = p->next;
      }
d678 1
a678 11
    /* Did we see any other threads for this pid?  (Recall that we just
     * added this thread to the list...)
     */
    if (thread_count_of_pid == 1)
      {
        new_p->am_pseudo        = 1;
        new_p->next_pseudo      = thread_head.head_pseudo;
        thread_head.head_pseudo = new_p;
      }
    
    return new_p;
d686 2
a687 2
    thread_info *p;
    thread_info *q;
d690 2
a691 2
    if( debug_on )
        printf( "Clearing all thread info\n" );
d694 6
a699 5
    p = thread_head.head;
    while( p ) {
        q = p;
        p = p->next;
        free( q );
d702 3
a704 3
    thread_head.head        = NULL;
    thread_head.head_pseudo = NULL;
    thread_head.count       = 0;
d706 6
a711 5
    p = deleted_threads.head;
    while( p ) {
        q = p;
        p = p->next;
        free( q );
d714 3
a716 3
    deleted_threads.head        = NULL;
    deleted_threads.head_pseudo = NULL;
    deleted_threads.count       = 0;
d718 3
a720 3
    /* No threads, so can't have pending events.
     */
    more_events_left = 0;   
d727 1
a727 1
    lwpid_t tid;
d729 1
a729 1
    thread_info *p;
d731 6
a736 4
    for( p = thread_head.head; p; p = p->next )  {
       if( p->tid == tid ) {
           return p;
       }
d739 6
a744 4
    for( p = deleted_threads.head; p; p = p->next )  {
       if( p->tid == tid ) {
           return p;
       }
d746 2
a747 2
    
    return NULL;  
d758 2
a759 2
map_from_gdb_tid( gdb_tid )
    lwpid_t gdb_tid;
d761 1
a761 1
    thread_info *p;
d763 7
a769 6
    /* First assume gdb_tid really is a tid, and try to find a
     * matching entry on the threads list.
     */
    for( p = thread_head.head; p; p = p->next )  {
        if( p->tid == gdb_tid )
            return gdb_tid;
d772 8
a779 8
    /* It doesn't appear to be a tid; perhaps it's really a pid?
     * Try to find a "pseudo" thread entry on the threads list.
     */
    for (p = thread_head.head_pseudo; p != NULL; p = p->next_pseudo)
      {
        if (p->pid == gdb_tid)
          return p->tid;
      }
d781 7
a787 6
    /* Perhaps it's the tid of a deleted thread we may still
     * have some knowledge of?
     */
    for( p = deleted_threads.head; p; p = p-> next ) {
        if( p->tid == gdb_tid )
            return gdb_tid;
d790 8
a797 8
    /* Or perhaps it's the pid of a deleted process we may still
     * have knowledge of?
     */
    for (p = deleted_threads.head_pseudo; p != NULL; p = p->next_pseudo)
      {
        if (p->pid == gdb_tid)
          return p->tid;
      }
d799 1
a799 1
    return 0;  /* Error? */
d808 2
a809 2
map_to_gdb_tid( real_tid )
    lwpid_t real_tid;
d811 1
a811 1
    thread_info *p;
d813 9
a821 7
    for( p = thread_head.head; p; p = p->next )  {
        if( p->tid == real_tid ) {
            if( p->am_pseudo )
                return p->pid;
            else 
                return real_tid;
       }
d824 7
a830 6
    for( p = deleted_threads.head; p; p = p-> next ) {
        if( p->tid == real_tid )
            if( p->am_pseudo )
                return p->pid;  /* Error? */
            else 
                return real_tid;
d833 1
a833 1
    return 0;  /* Error?  Never heard of this thread! */
d838 1
a838 1
static int 
d841 8
a848 6
    thread_info *p;
   
    for( p = thread_head.head; p; p = p->next )  {
       if( p->have_signal ) {
           return 1;
       }
d851 1
a851 1
    return 0;
d856 1
a856 1
static int 
d858 1
a858 1
    lwpid_t tid;
d860 5
a864 5
    thread_info *p = find_thread_info( tid );
    if( NULL == p || p->terminated )
        return 0;
    else
        return p->am_pseudo;
d869 1
a869 1
static int 
d871 1
a871 1
    lwpid_t tid;
d873 1
a873 1
    thread_info *p = find_thread_info( tid );
d875 2
a876 2
    if( NULL != p )
        return p->terminated;
d878 1
a878 1
    return 0;
d883 1
a883 1
static int 
d885 1
a885 1
  int  pid;
d887 4
a890 4
  lwpid_t  tid;
  thread_info *  tinfo;
  pid_t  this_pid;
  int  this_pid_count;
d896 1
a896 1
    return 0; /* Actually, is probably an error... */
d902 1
a902 1
  if (! tinfo->am_pseudo)
d914 1
a914 1
        this_pid_count++;
d925 2
a926 2
    int     pid;
    lwpid_t tid;
d928 1
a928 1
    thread_info *p;
d930 3
a932 3
    p = find_thread_info( tid );
    if( NULL == p )
        p = create_thread_info( pid, tid );
d934 1
a934 1
    return p;
d941 1
a941 1
    lwpid_t tid;
d943 2
a944 2
    thread_info *p;
    thread_info *chase;
d946 5
a950 64
    if( thread_head.count <= 0 ) {
        error( "Internal error in thread database." );
        return;
    }

    chase = NULL;
    for( p = thread_head.head; p; p = p->next )  {
       if( p->tid == tid ) {

#ifdef THREAD_DEBUG
           if( debug_on )
               printf( "Delete here: %d \n", tid );
#endif

           if( p->am_pseudo ) {
               /*
                * Deleting a main thread is ok if we're doing
                * a parent-follow on a child; this is odd but
                * not wrong.  It apparently _doesn't_ happen
                * on the child-follow, as we don't just delete
                * the pseudo while keeping the rest of the
                * threads around--instead, we clear out the whole
                * thread list at once.
                */
               thread_info *q;
               thread_info *q_chase;
               
               q_chase = NULL;
               for( q = thread_head.head_pseudo; q; q = q -> next ) {
                    if( q == p ) {
                        /* Remove from pseudo list.
                         */
                        if( q_chase == NULL )
                            thread_head.head_pseudo = p->next_pseudo;
                        else
                            q_chase-> next = p->next_pseudo;
                    }
                    else
                        q_chase = q;
               }
           }
           
           /* Remove from live list.
            */
           thread_head.count--;

           if( NULL == chase )
               thread_head.head = p->next;
           else
               chase->next      = p->next;

           /* Add to deleted thread list.
            */
           p->next = deleted_threads.head;
           deleted_threads.head = p;
           deleted_threads.count++;
           if( p->am_pseudo ) {
               p->next_pseudo              = deleted_threads.head_pseudo;
               deleted_threads.head_pseudo = p;
           }
           p->terminated = 1;
           
           return;
       }
d952 68
a1019 2
       else
           chase = p;
d1027 1
a1027 1
    lwpid_t tid;
d1029 1
a1029 1
    thread_info *p;
d1031 6
a1036 4
    for( p = thread_head.head; p; p = p->next ) {
        if( p->tid == tid ) {
            return p->pid;
        }
d1039 6
a1044 4
    for( p = deleted_threads.head; p; p = p->next ) {
        if( p->tid == tid ) {
            return p->pid;
        }
d1046 2
a1047 2
    
    return 0;
d1053 5
a1057 9
set_handled( pid, tid )
    int     pid;
    lwpid_t tid;
{
    thread_info *p;
    
    p = find_thread_info( tid );
    if( NULL == p )
        p = add_tthread( pid, tid );
d1059 5
a1063 1
    p->handled = 1;
d1068 5
a1072 9
static int 
was_handled( tid )
    lwpid_t tid;
{
    thread_info *p;
    
    p = find_thread_info( tid );
    if( NULL != p )
        return p->handled;
d1074 5
a1078 1
    return 0;  /* New threads have not been handled */
d1084 2
a1085 2
clear_handled( tid )
  lwpid_t  tid;
d1087 2
a1088 2
  thread_info *  p;
    
d1090 2
a1091 2
    if( debug_on )
        printf( "clear_handled %d\n", (int) tid );
d1106 1
a1106 1
    thread_info *p;
d1109 2
a1110 2
    if( debug_on )
        printf( "clear_all_handled\n" );
d1113 3
a1115 2
    for( p = thread_head.head; p; p = p->next ) {
        p->handled = 0;
d1118 3
a1120 2
    for( p = deleted_threads.head; p; p = p->next ) {
        p->handled = 0;
d1127 2
a1128 2
clear_stepping_mode( tid )
  lwpid_t  tid;
d1130 2
a1131 2
  thread_info *  p;
    
d1133 2
a1134 2
  if( debug_on )
       printf( "clear_stepping_mode %d\n", (int) tid );
d1149 1
a1149 1
    thread_info *p;
d1152 2
a1153 2
    if( debug_on )
        printf( "clear_all_stepping_mode\n" );
d1156 3
a1158 2
    for( p = thread_head.head; p; p = p->next ) {
        p->stepping_mode = DO_DEFAULT;
d1161 3
a1163 2
    for( p = deleted_threads.head; p; p = p->next ) {
        p->stepping_mode = DO_DEFAULT;
d1168 1
a1168 1
 */    
d1172 1
a1172 1
    thread_info *p;
d1174 3
a1176 2
    for( p = thread_head.head; p; p = p->next ) {
        p->seen = 0;
d1185 1
a1185 1
    thread_info *  p;
d1187 25
a1211 25
    printf( " Thread pid %d, tid %d", p->pid, p->tid );
    if( p->have_state ) 
        printf( ", event is %s",
            get_printable_name_of_ttrace_event( p->last_stop_state.tts_event ));
            
    if( p->am_pseudo )
        printf( ", pseudo thread" );
        
    if( p->have_signal )
        printf( ", have signal 0x%x", p->signal_value );
        
    if( p->have_start )
        printf( ", have start at 0x%x", p->start );
        
    printf( ", step is %s", get_printable_name_of_stepping_mode( p->stepping_mode ));
        
    if( p->handled )
        printf( ", handled" );
    else
        printf( ", not handled" );
        
    if( p->seen )
        printf( ", seen" );
    else
        printf( ", not seen" );
d1213 1
a1213 1
    printf( "\n" );
d1219 1
a1219 1
    thread_info *p;
d1221 13
a1233 11
    if( thread_head.count == 0 )
        printf( "Thread list is empty\n" );
    else {
        printf( "Thread list has " );
        if( thread_head.count == 1 )
            printf( "1 entry:\n" );
        else
            printf( "%d entries:\n", thread_head.count );
        for( p = thread_head.head; p; p = p->next ) {
            print_tthread (p);
        }
d1236 9
a1244 8
    if( deleted_threads.count == 0 )
        printf( "Deleted thread list is empty\n" );
    else {
        printf( "Deleted thread list has " );
        if( deleted_threads.count == 1 )
            printf( "1 entry:\n" );
        else
            printf( "%d entries:\n", deleted_threads.count );
d1246 4
a1249 3
        for( p = deleted_threads.head; p; p = p->next ) {
            print_tthread (p);
        }
d1259 2
a1260 2
    thread_info *p;
    thread_info *chase;
d1262 3
a1264 2
    chase = NULL;
    for( p = thread_head.head; p; p = p->next ) {
d1272 4
a1275 4
         */
        if( (!p->seen) && p->am_pseudo && vfork_in_flight
         && (p->pid != vforking_child_pid))
            p->seen = 1;
d1277 4
a1280 3
        if( !p->seen ) {
            /* Remove this one
             */
d1283 2
a1284 2
           if( debug_on )
               printf( "Delete unseen thread: %d \n", p->tid );
d1286 2
a1287 2
           del_tthread( p->tid );
       }
d1290 2
a1292 2
    

d1305 5
a1309 5
call_real_ttrace( request, pid, tid, addr, data, addr2 )
  ttreq_t          request;
  pid_t            pid;
  lwpid_t          tid;
  TTRACE_ARG_TYPE  addr, data, addr2;
d1311 1
a1311 1
  int  tt_status;
d1314 1
a1314 1
  tt_status = ttrace( request, pid, tid, addr, data, addr2 );
d1317 17
a1333 14
  if (errno) {
    /* Don't bother for a known benign error: if you ask for the
     * first thread state, but there is only one thread and it's
     * not stopped, ttrace complains.
     *
     * We have this inside the #ifdef because our caller will do
     * this check for real.
     */
    if( request != TT_PROC_GET_FIRST_LWP_STATE
    ||  errno   != EPROTO ) {
        if( debug_on )
            printf( "TT fail for %s, with pid %d, tid %d, status %d \n",
                    get_printable_name_of_ttrace_request (request),
                    pid, tid, tt_status );
a1334 1
  }
d1342 8
a1349 7
  if (errno) {
    strcpy (reason_for_failure, "ttrace (");
    strcat (reason_for_failure, get_printable_name_of_ttrace_request (request));
    strcat (reason_for_failure, ")");
    printf( "ttrace error, errno = %d\n", errno );
    perror_with_name (reason_for_failure);
  }
d1354 1
a1355 1

d1362 6
a1367 6
call_real_ttrace_wait( pid, tid, option, tsp, tsp_size )
  int        pid;
  lwpid_t    tid;
  ttwopt_t   option;
  ttstate_t *tsp;
  size_t     tsp_size;
d1369 2
a1370 2
  int        ttw_status;
  thread_info *  tinfo = NULL;
d1374 3
a1376 2
  
  if (errno) {
d1378 2
a1379 2
      if( debug_on )
          printf( "TW fail with pid %d, tid %d \n", pid, tid );
d1383 1
a1383 1
  }
d1387 1
a1388 1

d1398 2
a1399 2
  int  pid;
  ttstate_t *  thread_state;
d1401 1
a1401 1
  int  tt_status;
d1403 23
a1425 19
  tt_status = call_real_ttrace (
                      TT_PROC_GET_FIRST_LWP_STATE,
                      (pid_t) pid,
                      (lwpid_t) TT_NIL,
                      (TTRACE_ARG_TYPE) thread_state,
                      (TTRACE_ARG_TYPE) sizeof (*thread_state),
                      TT_NIL);
                      
  if (errno) {
    if( errno == EPROTO) {
        /* This is an error we can handle: there isn't any stopped
         * thread.  This happens when we're re-starting the application
         * and it has only one thread.  GET_NEXT handles the case of
         * no more stopped threads well; GET_FIRST doesn't.  (A ttrace
         * "feature".)
         */
        tt_status = 1;
        errno     = 0;
        return 0;
d1427 2
a1428 5
    else
        perror_with_name ("ttrace");
  }
  
  if( tt_status < 0 )
d1435 1
a1436 1

d1448 2
a1449 2
  int  pid;
  ttstate_t *  thread_state;
d1451 1
a1451 1
  int  tt_status;
d1454 6
a1459 6
                      TT_PROC_GET_NEXT_LWP_STATE,
                      (pid_t) pid,
                      (lwpid_t) TT_NIL,
                      (TTRACE_ARG_TYPE) thread_state,
                      (TTRACE_ARG_TYPE) sizeof (*thread_state),
                      TT_NIL);
d1468 10
a1477 9
  else if( tt_status == 0 ) {
    /* End of list, no next state.  Don't return the
     * tts_lwpid, as it's a meaningless "240".
     *
     * This is an HPUX "feature".
     */
    return 0;
  }
  
d1492 1
a1492 1
  int  pid;
d1494 1
a1494 1
  ttstate_t  thread_state;
d1504 1
a1504 1
  ttreq_t  tt_request;
d1508 1
a1509 1

d1514 2
a1515 2
make_process_version( request )
  ttreq_t request;
d1517 5
a1521 4
  if (!IS_TTRACE_REQ (request)) {
    error( "Internal error, bad ttrace request made\n" );
    return -1;
  }
d1523 3
a1525 2
  switch (request) {
    case TT_LWP_STOP :
d1528 1
a1528 1
    case TT_LWP_CONTINUE :
d1531 1
a1531 1
    case TT_LWP_GET_EVENT_MASK :
d1534 1
a1534 1
    case TT_LWP_SET_EVENT_MASK :
d1537 5
a1541 5
    case TT_LWP_SINGLE :
    case TT_LWP_RUREGS :
    case TT_LWP_WUREGS :
    case TT_LWP_GET_STATE	:
      return -1;       /* No equivalent */
d1543 1
a1543 1
    default :
d1545 1
a1545 1
  }
d1547 1
a1548 1

d1559 11
a1569 11
call_ttrace( request, gdb_tid, addr, data, addr2 )
  ttreq_t  request;
  int      gdb_tid;
  TTRACE_ARG_TYPE  addr, data, addr2;
{
  lwpid_t  real_tid;
  int      real_pid;
  ttreq_t  new_request;
  int      tt_status;
  char     reason_for_failure [100];  /* Arbitrary size, should be big enough. */
  
d1571 6
a1576 1
  int	is_interesting = 0;
d1578 13
a1590 14
  if( TT_LWP_RUREGS == request ) {
     is_interesting = 1;          /* Adjust code here as desired */
  }
  
  if( is_interesting && 0 && debug_on ) {
      if( !is_process_ttrace_request( request )) {
          printf( "TT: Thread request, tid is %d", gdb_tid );
          printf( "== SINGLE at %x", addr );
      }
      else {
          printf( "TT: Process request, tid is %d\n", gdb_tid );
          printf( "==! SINGLE at %x", addr );
      }
  }
d1601 2
a1602 2
  if( request == TT_PROC_SETTRC && debug_on )
      printf( "Unexpected call for TT_PROC_SETTRC\n" );
d1609 1
a1609 1
  if( gdb_tid == 0 )
d1611 1
a1611 1
      errno = ESRCH;  /* ttrace's response would probably be "No such process". */
d1618 2
a1619 1
  if( !any_thread_records()) {
d1621 2
a1622 2
      if( debug_on )
          warning ("No thread records for ttrace call");
d1624 1
a1624 1
      errno = ESRCH;  /* ttrace's response would be "No such process". */
d1626 1
a1626 1
  }
d1631 2
a1632 2
  real_tid = map_from_gdb_tid( gdb_tid );
  real_pid = get_pid_for( real_tid );
d1638 21
a1658 2
  if( 0 == real_pid ) {
    ttstate_t  thread_state;
d1661 2
a1662 2
    if( debug_on )
        printf( "No saved pid for tid %d\n", gdb_tid );
d1665 6
a1670 11
    if( is_process_ttrace_request( request )) {
     
        /* Ok, we couldn't get a tid.  Try to translate to
         * the equivalent process operation.  We expect this
         * NOT to happen, so this is a desparation-type
         * move.  It can happen if there is an internal
         * error and so no "wait()" call is ever done.
         */
        new_request = make_process_version( request );
        if( new_request == -1 ) {
        
d1672 35
a1706 2
            if( debug_on )
                printf( "...and couldn't make process version of thread operation\n" );
d1708 2
d1711 7
a1717 47
            /* Use hacky saved pid, which won't always be correct
             * in the multi-process future.  Use tid as thread,
             * probably dooming this to failure.  FIX!
             */
            if( saved_real_pid != 0 ) {
#ifdef THREAD_DEBUG
                if( debug_on )
                    printf( "...using saved pid %d\n", saved_real_pid );
#endif

                real_pid = saved_real_pid;
                real_tid = gdb_tid;
            }

            else
                error( "Unable to perform thread operation" );
        } 

        else {
            /* Sucessfully translated this to a process request,
             * which needs no thread value.
             */
            real_pid = gdb_tid;
            real_tid = 0;
            request  = new_request;

#ifdef THREAD_DEBUG
            if( debug_on ) {
                printf( "Translated thread request to process request\n" );
                if( saved_real_pid == 0 )
                    printf( "...but there's no saved pid\n" );
                
                else {
                    if( gdb_tid != saved_real_pid )
                        printf( "...but have the wrong pid (%d rather than %d)\n",
                                gdb_tid, saved_real_pid );
                }
            }
#endif
        } /* Translated to a process request */
    }     /* Is a process request */

    else {
        /* We have to have a thread.  Ooops.
         */
       error( "Thread request with no threads (%s)",
               get_printable_name_of_ttrace_request( request ));
a1718 1
  }
d1723 2
a1724 1
  if (is_process_ttrace_request (request)) {
d1726 2
a1727 2
  }
  
d1729 5
a1733 4
  if( is_interesting && 0 && debug_on ) {
    printf( "    now tid %d, pid %d\n", real_tid, real_pid );
    printf( "    request is %s\n", get_printable_name_of_ttrace_request (request));
  }
d1741 6
a1746 5
  if(is_interesting && debug_on ) {
    if( !TT_OK( tt_status, errno )
    &&  !(tt_status == 0 & errno == 0))
      printf( " got error (errno==%d, status==%d)\n", errno, tt_status );
  }
d1754 1
a1754 1
 *
d1760 2
a1761 2
stop_all_threads_of_process( real_pid )
  pid_t  real_pid;
d1763 1
a1763 1
  int  ttw_status;
d1766 5
a1770 5
                                 (pid_t) real_pid,
                                 (lwpid_t) TT_NIL,
                                 (TTRACE_ARG_TYPE) TT_NIL,
                                 (TTRACE_ARG_TYPE) TT_NIL,
                                 TT_NIL );
d1790 1
a1790 1
   */
d1800 2
a1801 2
  int  pid;
  ttevents_t  stopping_event;
d1810 2
a1811 2
           (PARENT_VFORKED (stopping_event, pid) ||
            CHILD_URPED (stopping_event, pid)))
d1817 1
a1817 1
  return ! vfork_in_flight;
d1828 1
a1828 1
static int 
d1830 2
a1831 2
  int  pid;
  ttstate_t *  tsp;
d1833 2
a1834 2
  lwpid_t    candidate_tid,    tid;
  ttstate_t  candidate_tstate, tstate;
d1842 1
a1842 1
  if (! can_touch_threads_of_process (pid, tsp->tts_event))
d1858 4
a1861 3
      if (tstate.tts_event == TTEVT_NONE) {
          set_handled( pid, tstate.tts_lwpid );
      }
d1872 1
a1872 1
        {
d1874 17
a1890 17
          /* It's possible here to see either a SIGTRAP (due to
           * successful completion of a step) or a SYSCALL_ENTRY
           * (due to a step completion with active hardware
           * watchpoints).
           */
           if( debug_on )
               printf( "Ending fake step with tid %d, state %s\n",
                       tstate.tts_lwpid,
                       get_printable_name_of_ttrace_event( tstate.tts_event ));
#endif 

          /* Remember this one, and throw away any previous
           * candidate.
           */
          candidate_tid    = tstate.tts_lwpid;
          candidate_tstate = tstate;
      }
d1908 10
a1917 9
      else if( (TTEVT_SIGNAL == tstate.tts_event)
            && (5 == tstate.tts_u.tts_signal.tts_signo)
            && (0 != get_raw_pc( tstate.tts_lwpid ))
            && ! breakpoint_here_p( get_raw_pc( tstate.tts_lwpid )) ) {
          /*
           * If the user deleted a breakpoint while this
           * breakpoint-hit event was buffered, we can forget
           * it now.
           */
d1919 4
a1922 4
           if( debug_on )
               printf( "Forgetting deleted bp hit for thread %d\n",
                       tstate.tts_lwpid );
#endif 
d1924 2
a1925 2
          set_handled( pid, tstate.tts_lwpid );
      }
d1932 5
a1936 4
      else if( !was_handled( tstate.tts_lwpid ) && candidate_tid == 0 ) {
          candidate_tid    = tstate.tts_lwpid;
          candidate_tstate = tstate;
      }
d1946 16
a1961 12
  if( doing_fake_step ) {
      if( candidate_tid == fake_step_tid ) {
          /* Fake step.
           */
          tstate = candidate_tstate;
      }
      else {
          warning( "Internal error: fake-step failed to complete." );
          return 0;
      }
  }
  else if( candidate_tid != 0 ) {
d1965 4
a1968 3
  }
  else if( tid != 0 ) {
      warning( "Internal error in call of ttrace_wait." );
d1970 3
a1972 2
  }
  else {
d1975 1
a1975 1
  }
d1979 1
a1979 1
} /* End of select_stopped_thread_of_process */
d1985 2
a1986 2
check_thread_consistency( real_pid )
    pid_t real_pid;
d1988 11
a1998 3
    int          tid;       /* really lwpid_t */
    ttstate_t    tstate;
    thread_info *p;
d2000 7
a2006 13
    /* Spin down the O/S list of threads, checking that they
     * match what we've got.
     */
    for (tid = get_process_first_stopped_thread_id( real_pid, &tstate );
         tid != 0;
         tid = get_process_next_stopped_thread_id(  real_pid, &tstate )) {
       
        p = find_thread_info( tid );
      
        if( NULL == p ) {
            warning( "No internal thread data for thread %d.", tid );
            continue;
        }
d2008 4
a2011 3
        if( !p->seen ) {
            warning( "Inconsistent internal thread data for thread %d.", tid );
        }
d2013 5
a2017 4
        if( p->terminated ) {
            warning( "Thread %d is not terminated, internal error.", tid );
            continue;
        }
d2022 15
a2036 13
            
        if( p->have_state ) {
            if( TT_COMPARE( tts_pid      )
             || TT_COMPARE( tts_lwpid    )
             || TT_COMPARE( tts_user_tid )
             || TT_COMPARE( tts_event    )
             || TT_COMPARE( tts_flags    )
             || TT_COMPARE( tts_scno     )
             || TT_COMPARE( tts_scnargs  )) {
                warning( "Internal thread data for thread %d is wrong.", tid );
                continue;
            }
        }
d2039 2
a2040 1
#endif  /* PARANOIA */
a2041 1

d2052 5
a2056 5
call_ttrace_wait( pid, option, tsp, tsp_size )
  int        pid;
  ttwopt_t   option;
  ttstate_t *tsp;
  size_t     tsp_size;
d2066 3
a2068 3
  int      wait_pid = 0;
  lwpid_t  wait_tid = 0;
  lwpid_t  real_tid;
d2070 1
a2070 1
  int       ttw_status = 0;   /* To be returned */
d2072 1
a2072 1
  thread_info *  tinfo = NULL;
d2074 2
a2075 1
  if( pid != 0 ) {
d2079 2
a2080 2
      if( debug_on )
          printf( "TW: Pid to wait on is %d\n", pid );
d2083 2
a2084 2
      if( !any_thread_records())
          error( "No thread records for ttrace call w. specific pid" );
d2089 2
a2090 2
      real_tid = map_from_gdb_tid( pid );
      real_pid = get_pid_for( real_tid );
d2092 2
a2093 2
      if( debug_on )
          printf( "==TW: real pid %d, real tid %d\n", real_pid, real_tid );
d2095 1
a2095 1
  }
d2109 2
a2110 1
  if( more_events_left == 0 ) {
d2112 31
a2142 26
      if( process_state == RUNNING ) {
          /* OK--normal call of ttrace_wait with no buffered events.
           */
          ;
      }
      else if( process_state == FAKE_STEPPING ) {
          /* Ok--call of ttrace_wait to support
           * fake stepping with no buffered events.
           *
           * But we better be fake-stepping!
           */
          if( !doing_fake_step ) {
              warning( "Inconsistent thread state." );
          }
      }
      else if( (process_state == FORKING)
            || (process_state == VFORKING)) {
          /* Ok--there are two processes, so waiting
           * for the second while the first is stopped
           * is ok.  Handled bits stay as they were.
           */
           ;
      }
      else if( process_state == STOPPED ) {
          warning( "Process not running at wait call." );
      }
d2144 7
a2150 6
          /* No known state.
           */
          warning( "Inconsistent process state." );
  }
  
  else {
d2153 32
a2184 27
      if( process_state == STOPPED ) {
          /* OK--buffered events being unbuffered.
           */
          ;
      }
      else if( process_state == RUNNING ) {
          /* An error--shouldn't have buffered events
           * when running.
           */
          warning( "Trying to continue with buffered events:" );
      }
      else if( process_state == FAKE_STEPPING ) {
          /*
           * Better be fake-stepping!
           */
          if( !doing_fake_step ) {
              warning( "Losing buffered thread events!\n" );
          }
      }
      else if( (process_state == FORKING)
            || (process_state == VFORKING)) {
          /* Ok--there are two processes, so waiting
           * for the second while the first is stopped
           * is ok.  Handled bits stay as they were.
           */
           ;
      }
d2186 2
a2187 2
          warning( "Process in unknown state with buffered events." );
  }
d2196 2
a2197 1
  if( doing_fake_step ) {
d2199 1
a2199 1
      wait_pid = get_pid_for( fake_step_tid );
d2202 3
a2204 3
      if( debug_on )
          printf( "Doing a wait after a fake-step for %d, pid %d\n",
                  wait_tid, wait_pid );
d2206 1
a2206 1
  }
d2208 3
a2210 2
  if( more_events_left == 0         /* No buffered events, need real ones. */
  ||  process_state != STOPPED ) {
d2219 2
a2220 2
      if( debug_on )
          printf( "TW: do it for real; pid %d, tid %d\n", wait_pid, wait_tid );
d2225 1
a2225 1
      ttw_status = call_real_ttrace_wait( wait_pid, wait_tid, option, tsp, tsp_size);
d2234 1
a2234 1
       *
d2240 25
a2264 24
        {
          /* If we're really only stepping a single thread, then don't
           * try to stop all the others -- we only do this single-stepping
           * business when all others were already stopped...and the stop
           * would mess up other threads' events.
           *
           * Similiarly, if there are other threads with events,
           * don't do the stop.
           */
          if( !doing_fake_step ) {
            if( more_events_left > 0 )
                warning( "Internal error in stopping process" );
                
            stop_all_threads_of_process (real_pid);

            /* At this point, we could scan and update_thread_list(),
             * and only use the local list for the rest of the
             * module! We'd get rid of the scans in the various
             * continue routines (adding one in attach).  It'd
             * be great--UPGRADE ME!
             */
            }
        }
        
d2266 7
a2272 6
      else if( debug_on ) {
          if( more_events_left > 0 )
              printf( "== Can't stop process; more events!\n" );
          else
              printf( "== Can't stop process!\n" );
      }
d2275 1
a2275 1
      process_state   = STOPPED;
d2278 2
a2279 2
      if( debug_on )
          printf( "Process set to STOPPED\n" );
d2281 4
a2284 3
  }
  
  else {
d2289 2
a2290 2
      if( debug_on )
          printf( "TW: fake it\n" );
d2293 8
a2300 7
      if( process_state != STOPPED ) {
          warning( "Process not stopped at wait call, in state '%s'.\n",
                   get_printable_name_of_process_state( process_state ));
      }
    
      if( doing_fake_step )
          error( "Internal error in stepping over breakpoint" );
d2302 2
a2303 2
      ttw_status = 0;  /* Faking it is always successful! */
  }   /* End of fake or not? if */
d2307 2
a2308 2
  if( !select_stopped_thread_of_process( real_pid, tsp ))
      warning( "Can't find event, using previous event." );
d2310 7
a2316 2
  else if( tsp->tts_event == TTEVT_NONE )
      warning( "Internal error: no thread has a real event." );
a2317 4
  else if( doing_fake_step ) {
      if( fake_step_tid != tsp->tts_lwpid )
          warning( "Internal error in stepping over breakpoint." );
          
d2321 2
a2322 2
      fake_step_tid   = 0;
  }
d2328 1
a2328 1
  set_handled( real_pid, tsp->tts_lwpid );
d2342 6
a2347 5
  if (tinfo != NULL) {
    copy_ttstate_t (&tinfo->last_stop_state, tsp);
    tinfo->have_state = 1;
  }
  
d2349 1
a2349 1
} /* call_ttrace_wait */
d2355 1
a2355 1
  return 1;  /* ttrace reports the event once per call. */
d2358 1
a2360 1

d2378 10
a2387 8
   */
typedef struct memory_page {
  CORE_ADDR  page_start;
  int  reference_count;
  int  original_permissions;
  struct memory_page *  next;
  struct memory_page *  previous;
} memory_page_t;
d2391 9
a2399 7
static struct {
  LONGEST  page_count;
  int  page_size;
  int  page_protections_allowed;
  /* These are just the heads of chains of actual page descriptors. */
  memory_page_t  buckets [MEMORY_PAGE_DICTIONARY_BUCKET_COUNT];
} memory_page_dictionary;
d2405 1
a2405 1
  int  i;
d2414 1
a2414 1
  for (i=0; i<MEMORY_PAGE_DICTIONARY_BUCKET_COUNT; i++)
d2427 1
a2427 1
  memory_page_dictionary.page_count = (LONGEST) -1;
d2437 2
a2438 2
  int       pid;
  CORE_ADDR page_start;
d2440 3
a2442 3
  int  tt_status;
  int  original_permissions;
  int  new_permissions;
d2445 4
a2448 4
                           pid,
                           (TTRACE_ARG_TYPE) page_start,
                           TT_NIL,
                           (TTRACE_ARG_TYPE) &original_permissions);
d2451 1
a2451 1
      return 0;  /* What else can we do? */
d2459 4
a2462 4
                               pid,
                               (TTRACE_ARG_TYPE) page_start,
                               (TTRACE_ARG_TYPE) memory_page_dictionary.page_size,
                               (TTRACE_ARG_TYPE) new_permissions);
d2464 3
a2466 3
        {
          return 0;  /* What else can we do? */
        }
d2475 1
a2475 1
   */
d2478 3
a2480 3
  int  pid;
  CORE_ADDR  page_start;
  int  original_permissions;
d2482 1
a2482 1
  int  tt_status;
d2485 4
a2488 4
                           pid,
                           (TTRACE_ARG_TYPE) page_start,
                           (TTRACE_ARG_TYPE) memory_page_dictionary.page_size,
                           (TTRACE_ARG_TYPE) original_permissions);
d2491 1
a2491 1
      return;  /* What else can we do? */
d2501 1
a2501 1
   */
d2504 1
a2504 1
  int  pid;
d2506 1
a2506 1
  int  bucket;
d2510 1
a2510 1
  for (bucket=0; bucket<MEMORY_PAGE_DICTIONARY_BUCKET_COUNT; bucket++)
d2512 1
a2512 1
      memory_page_t *  page;
d2516 4
a2519 4
        {
          page->original_permissions = write_protect_page (pid, page->page_start);
          page = page->next;
        }
d2529 1
a2529 1
   */
d2532 1
a2532 1
  int  pid;
d2534 1
a2534 1
  int  bucket;
d2536 1
a2536 1
  for (bucket=0; bucket<MEMORY_PAGE_DICTIONARY_BUCKET_COUNT; bucket++)
d2538 1
a2538 1
      memory_page_t *  page;
d2542 4
a2545 4
        {
          unwrite_protect_page (pid, page->page_start, page->original_permissions);
          page = page->next;
        }
d2559 8
a2566 8
count_unhandled_events( real_pid, real_tid )
  int     real_pid;
  lwpid_t real_tid;
{
  ttstate_t  tstate;
  lwpid_t    ttid;
  int        events_left;
  
d2570 1
a2570 1
  ttid = get_process_first_stopped_thread_id( real_pid, &tstate );
d2573 4
a2576 3
  if( debug_on ) {
      if( ttid == 0 )
          printf( "Process %d has no threads\n", real_pid );
d2578 2
a2579 2
          printf( "Process %d has these threads:\n", real_pid );
  }
d2582 19
a2600 17
  while (ttid > 0 ) {
      if( tstate.tts_event != TTEVT_NONE
      &&  !was_handled( ttid )) {
          /* TTEVT_NONE implies we just stopped it ourselves
           * because we're the stop-the-world guys, so it's
           * not an event from our point of view.
           *
           * If "was_handled" is true, this is an event we
           * already handled, so don't count it.
           *
           * Note that we don't count the thread with the
           * currently-reported event, as it's already marked
           * as handled.
           */
          events_left++;
      }
         
d2602 26
a2627 10
  if( debug_on ) {
      if( ttid == real_tid )
          printf( "*" );         /* Thread we're reporting */
      else
          printf( " " );
         
      if( tstate.tts_event != TTEVT_NONE )
          printf( "+" );         /* Thread with a real event */
      else
          printf( " " );
d2629 8
a2636 22
      if( was_handled( ttid ))
          printf( "h" );         /* Thread has been handled */
      else
          printf( " " );
         
      printf( " %d, with event %s", ttid,
              get_printable_name_of_ttrace_event( tstate.tts_event ));
              
      if( tstate.tts_event == TTEVT_SIGNAL
       && 5 == tstate.tts_u.tts_signal.tts_signo ) {
          CORE_ADDR pc_val;

          pc_val = get_raw_pc( ttid );

          if( pc_val > 0 )
              printf( " breakpoint at 0x%x\n", pc_val );
          else
              printf( " bpt, can't fetch pc.\n" );
      }
      else
          printf( "\n" );
  }
d2640 1
a2640 1
  }
d2643 3
a2645 3
  if( debug_on )
      if( events_left > 0 )
          printf( "There are thus %d pending events\n", events_left );
d2660 2
a2661 2
    int pid;
    int *status;
d2663 6
a2668 6
  ttstate_t  tsp;
  int        ttwait_return;
  int        real_pid;
  ttstate_t  state;
  lwpid_t    real_tid;
  int  return_pid;
d2674 1
a2674 1
  ttwait_return = call_ttrace_wait( 0, TTRACE_WAITOK, &tsp, sizeof (tsp) );
d2681 1
a2681 1
         */
d2683 4
a2686 4
        {
          *status = 0;  /* WIFEXITED */
          return inferior_pid;
        }
d2688 2
a2689 2
      warning( "Call of ttrace_wait returned with errno %d.",
               errno );
d2702 22
a2723 1
  if (tsp.tts_event & TTEVT_LWP_CREATE) {
d2725 5
a2729 25
     /* Unlike what you might expect, this event is reported in
      * the _creating_ thread, and the _created_ thread (whose tid
      * we have) is still running.  So we have to stop it.  This
      * has already been done in "call_ttrace_wait", but should we
      * ever abandon the "stop-the-world" model, here's the command
      * to use:
      *
      *    call_ttrace( TT_LWP_STOP, real_tid, TT_NIL, TT_NIL, TT_NIL );
      *
      * Note that this would depend on being called _after_ "add_tthread"
      * below for the tid-to-pid translation to be done in "call_ttrace".
      */

#ifdef THREAD_DEBUG
     if( debug_on )
         printf( "New thread: pid %d, tid %d, creator tid %d\n",
                 real_pid, tsp.tts_u.tts_thread.tts_target_lwpid,
                 real_tid );
#endif

     /* Now we have to return the tid of the created thread, not
      * the creating thread, or "wait_for_inferior" won't know we
      * have a new "process" (thread).  Plus we should record it
      * right, too.
      */
d2732 2
a2733 2
      add_tthread( real_pid, real_tid );
  }
d2735 3
a2737 2
  else if( (tsp.tts_event & TTEVT_LWP_TERMINATE )
        || (tsp.tts_event & TTEVT_LWP_EXIT) ) {
d2740 2
a2741 2
     if( debug_on )
         printf( "Thread dies: %d\n", real_tid );
d2744 2
a2745 2
     del_tthread( real_tid );
  }
d2747 2
a2748 1
  else if (tsp.tts_event & TTEVT_EXEC) {
d2750 4
a2753 4
#ifdef THREAD_DEBUG 
      if( debug_on )
          printf( "Pid %d has zero'th thread %d; inferior pid is %d\n",
                  real_pid, real_tid, inferior_pid );
d2756 2
a2757 2
     add_tthread( real_pid, real_tid );
  }
d2760 13
a2772 12
  else if( debug_on ) {
     printf( "Process-level event %s, using tid %d\n",
             get_printable_name_of_ttrace_event( tsp.tts_event ),
             real_tid );

     /* OK to do this, as "add_tthread" won't add
      * duplicate entries.  Also OK not to do it,
      * as this event isn't one which can change the
      * thread state.
      */
     add_tthread( real_pid, real_tid );
  }
d2784 8
a2791 7
      more_events_left = count_unhandled_events( real_pid, real_tid );
      
  else {
      if( more_events_left > 0 )
          warning( "Vfork or fork causing loss of %d buffered events.",
                   more_events_left );
          
d2793 1
a2793 1
  }
d2801 2
a2802 2
     */
  if (   (tsp.tts_event & TTEVT_EXEC)
d2810 3
a2812 3
        {
          process_state = FORKING;
          
d2814 2
a2815 2
          if( debug_on )
              printf( "Process set to FORKING\n" );
d2817 1
a2817 1
        }
d2819 3
a2821 3
        {
          process_state = VFORKING;
          
d2823 2
a2824 2
          if( debug_on )
              printf( "Process set to VFORKING\n" );
d2826 1
a2826 1
        }
d2832 1
a2832 1
         */
d2835 2
a2836 2
      if( debug_on )
          printf( "..a process 'event'\n" );
d2840 1
a2840 1
      */
d2872 1
a2872 1
        || (tsp.tts_event & TTEVT_SYSCALL_RETURN))
d2876 1
a2876 1
         */
d2878 2
a2879 2
      if( debug_on )
          printf( "..a syscall 'event'\n" );
d2883 1
a2883 1
      */
d2888 2
a2889 2
        || (tsp.tts_event & TTEVT_LWP_TERMINATE)
        || (tsp.tts_event & TTEVT_LWP_EXIT))
d2895 2
a2896 2
      if( debug_on )
          printf( "..a thread 'event'\n" );
d2900 1
a2900 1
      */
d2903 1
a2903 1
    
d2905 2
a2906 2
    {  /* WIFEXITED */
    
d2908 2
a2909 2
       if( debug_on )
           printf( "..an exit\n" );
d2916 2
a2917 2
      inferior_pid = map_to_gdb_tid( real_tid ); /* HACK, FIX */
      
d2920 1
a2920 1
    
d2922 1
a2922 1
    {  /* WIFSTOPPED */
d2924 2
a2925 2
       if( debug_on )
           printf( "..a signal, %d\n", tsp.tts_u.tts_signal.tts_signo );
d2932 1
a2932 1
    {  /* !WIFSTOPPED */
d2943 4
a2946 4
      if( debug_on )
          printf( "Process-level event %s, using tid %d\n",
                  get_printable_name_of_ttrace_event( tsp.tts_event ),
                  real_tid );
d2956 2
a2957 2
  if( debug_on )
      printf( "Done waiting, pid is %d, tid %d\n", real_pid, real_tid );
d2965 1
a2965 1
  return_pid = map_to_gdb_tid( real_tid );
d2969 1
a2969 1
  old_gdb_pid  = inferior_pid;
d2973 5
a2977 4
  if( real_tid == 0 || return_pid == 0 ) {
      warning( "Internal error: process-wait failed." );
  }
        
d2980 1
a2981 1

d3005 1
a3005 1
  int  tt_status;
d3012 2
a3013 2
  uint64_t  tc_magic_child = TT_VERSION;
  uint64_t  tc_magic_parent = 0;
d3016 6
a3021 6
                            TT_PROC_SETTRC,
                            (int)     TT_NIL,
                            (lwpid_t) TT_NIL,
                            TT_NIL,
                            (TTRACE_ARG_TYPE) TT_VERSION,
                            TT_NIL );
d3028 2
a3029 2
         &tc_magic_child,
         sizeof (tc_magic_child));
d3033 3
a3035 3
        &tc_magic_parent,
        sizeof (tc_magic_parent));
        
d3044 1
a3044 1
  
d3062 2
a3063 2
require_notification_of_events ( real_pid )
  int  real_pid;
d3065 2
a3066 2
  int  tt_status;
  ttevent_t  notifiable_events;
d3068 2
a3069 2
  lwpid_t    tid;
  ttstate_t  thread_state;
d3072 2
a3073 2
  if( debug_on )
      printf( "Require notif, pid is %d\n", real_pid );
d3093 1
a3093 1
  notifiable_events.tte_events  = TTEVT_DEFAULT;
d3104 6
a3109 6
                           TT_PROC_SET_EVENT_MASK,
                           real_pid,
                           (lwpid_t) TT_NIL,
                           (TTRACE_ARG_TYPE) &notifiable_events,
                           (TTRACE_ARG_TYPE) sizeof (notifiable_events),
                           TT_NIL);
d3113 2
a3114 2
require_notification_of_exec_events ( real_pid )
  int  real_pid;
d3116 2
a3117 2
  int  tt_status;
  ttevent_t  notifiable_events;
d3119 2
a3120 2
  lwpid_t    tid;
  ttstate_t  thread_state;
d3123 2
a3124 2
  if( debug_on )
      printf( "Require notif, pid is %d\n", real_pid );
d3140 1
a3140 1
  notifiable_events.tte_events  = TTEVT_DEFAULT;
d3145 6
a3150 6
                           TT_PROC_SET_EVENT_MASK,
                           real_pid,
                           (lwpid_t) TT_NIL,
                           (TTRACE_ARG_TYPE) &notifiable_events,
                           (TTRACE_ARG_TYPE) sizeof (notifiable_events),
                           TT_NIL);
d3152 1
a3153 1

d3159 1
a3159 1
    int  pid;
d3165 3
a3167 3
     */
  uint64_t  tc_magic_parent = TT_VERSION;
  uint64_t  tc_magic_child = 0;
d3171 2
a3172 2
        &tc_magic_child,
        sizeof(tc_magic_child));
d3177 1
a3177 1
  clear_thread_info();
d3190 1
a3190 1
  add_thread( pid );       /* in thread.c */
d3202 2
a3203 2
         &tc_magic_parent,
         sizeof (tc_magic_parent));
d3218 2
a3219 2
child_post_startup_inferior ( real_pid)
  int  real_pid;
d3228 1
a3228 1
  int  tid;
d3230 2
a3231 2
  int        tt_status;
  ttevent_t  ttrace_events;
d3236 4
a3239 4
                           tid,
                           (TTRACE_ARG_TYPE) &ttrace_events,
                           (TTRACE_ARG_TYPE) sizeof (ttrace_events),
                           TT_NIL );
d3247 2
a3248 2
  if( debug_on )
      printf( "enable fork, tid is %d\n", tid );
d3252 4
a3255 4
                           tid,
                           (TTRACE_ARG_TYPE) &ttrace_events,
                           (TTRACE_ARG_TYPE) sizeof (ttrace_events),
                           TT_NIL);
d3263 1
a3263 1
  int  tid;
d3265 2
a3266 2
  int        tt_status;
  ttevent_t  ttrace_events;
d3271 4
a3274 4
                           tid,
                           (TTRACE_ARG_TYPE) &ttrace_events,
                           (TTRACE_ARG_TYPE) sizeof (ttrace_events),
                           TT_NIL);
d3283 2
a3284 2
  if( debug_on )
      printf("disable fork, tid is %d\n", tid );
d3288 4
a3291 4
                           tid,
                           (TTRACE_ARG_TYPE) &ttrace_events,
                           (TTRACE_ARG_TYPE) sizeof (ttrace_events),
                           TT_NIL);
d3301 1
a3301 1
  int  tid;
d3306 1
a3306 1
     */
d3315 1
a3315 1
  int  tid;
d3320 1
a3320 1
     */
d3328 1
a3328 1
  int  tid;
d3330 2
a3331 2
  int  tt_status;
  ttevent_t  ttrace_events;
d3336 4
a3339 4
                           tid,
                           (TTRACE_ARG_TYPE) &ttrace_events,
                           (TTRACE_ARG_TYPE) sizeof (ttrace_events),
                           TT_NIL);
d3348 2
a3349 2
  if( debug_on )
      printf("enable vfork, tid is %d\n", tid );
d3353 4
a3356 4
                           tid,
                           (TTRACE_ARG_TYPE) &ttrace_events,
                           (TTRACE_ARG_TYPE) sizeof (ttrace_events),
                           TT_NIL);
d3365 1
a3365 1
  int  tid;
d3367 2
a3368 2
  int  tt_status;
  ttevent_t  ttrace_events;
d3372 4
a3375 4
                           tid,
                           (TTRACE_ARG_TYPE) &ttrace_events,
                           (TTRACE_ARG_TYPE) sizeof (ttrace_events),
                           TT_NIL);
d3384 2
a3385 2
  if( debug_on )
      printf("disable vfork, tid is %d\n", tid );
d3388 4
a3391 4
                           tid,
                           (TTRACE_ARG_TYPE) &ttrace_events,
                           (TTRACE_ARG_TYPE) sizeof (ttrace_events),
                           TT_NIL);
d3401 1
a3401 1
  int  tid;
d3406 1
a3406 1
     */
d3415 1
a3415 1
  int  tid;
d3420 1
a3420 1
     */
d3428 1
a3428 1
 *
d3435 2
a3436 2
  int  tid;
  int *childpid;
d3438 3
a3440 3
  int  tt_status;
  ttstate_t  ttrace_state;
  thread_info *  tinfo;
d3444 4
a3447 3
  if (tinfo != NULL) {
    copy_ttstate_t (&ttrace_state, &tinfo->last_stop_state);
  }
d3453 4
a3456 4
                               tid,
                               (TTRACE_ARG_TYPE) &ttrace_state,
                               (TTRACE_ARG_TYPE) sizeof (ttrace_state),
                               TT_NIL);
d3459 2
a3460 2
        perror_with_name ("ttrace");
    
d3462 1
a3462 1
        return 0;
d3482 2
a3483 2
  int  tid;
  int *  childpid;
d3485 3
a3487 3
  int  tt_status;
  ttstate_t  ttrace_state;
  thread_info *  tinfo;
d3498 4
a3501 4
                               tid,
                               (TTRACE_ARG_TYPE) &ttrace_state,
                               (TTRACE_ARG_TYPE) sizeof (ttrace_state),
                               TT_NIL);
d3504 2
a3505 2
        perror_with_name ("ttrace");
    
d3507 1
a3507 1
        return 0;
d3530 1
a3530 1
     */
d3539 1
a3539 1
  int  tid;
d3544 1
a3544 1
     */
d3553 1
a3553 1
  int  tid;
d3558 1
a3558 1
     */
d3567 2
a3568 2
  int  tid;
  char **  execd_pathname;
d3570 3
a3572 3
  int  tt_status;
  ttstate_t  ttrace_state;
  thread_info *  tinfo;
d3583 4
a3586 4
                               tid,
                               (TTRACE_ARG_TYPE) &ttrace_state,
                               (TTRACE_ARG_TYPE) sizeof (ttrace_state),
                               TT_NIL);
d3589 2
a3590 2
        perror_with_name ("ttrace");
    
d3592 1
a3592 1
        return 0;
d3599 2
a3600 2
      char *  exec_file = target_pid_to_exec_file (tid);
      
d3613 7
a3619 7
  int  pid;
  enum target_waitkind *  kind;
  int *  syscall_id;
{
  int  tt_status;
  ttstate_t  ttrace_state;
  thread_info *  tinfo;
d3629 5
a3633 5
    tt_status = call_ttrace (TT_LWP_GET_STATE,
                               pid,
                               (TTRACE_ARG_TYPE) &ttrace_state,
                               (TTRACE_ARG_TYPE) sizeof (ttrace_state),
                               TT_NIL);
d3636 2
a3637 2
        perror_with_name ("ttrace");
    
d3639 1
a3639 1
        return 0;
d3642 1
a3642 1
  *kind = TARGET_WAITKIND_SPURIOUS;  /* Until proven otherwise... */
d3656 1
a3658 1

d3662 1
a3662 1
 *
d3673 1
a3673 1
   lwpid_t  tid;
d3675 5
a3679 5
   /* This spins down the lists twice.
    * Possible peformance improvement here!
    */
   tid = map_from_gdb_tid( gdb_tid );
   return !is_terminated( tid );
d3683 1
a3685 1

d3695 1
a3695 1
   */
d3698 4
a3701 4
    int  tid;
    TTRACE_ARG_TYPE  ss_offset;
    char *  buf;
    int  sizeof_buf;
d3703 2
a3704 2
  int  tt_status;
  register_value_t  register_value = 0;
d3707 11
a3717 11
                           tid,
                           ss_offset,
                           (TTRACE_ARG_TYPE) sizeof_buf,
                           (TTRACE_ARG_TYPE) buf);

  if( tt_status == 1 )
      /* Map ttrace's version of success to our version.
       * Sometime ttrace returns 0, but that's ok here.
       */
      return 0;
      
d3720 1
a3721 1

d3730 1
a3730 1
   */
d3733 4
a3736 4
    int  tid;
    TTRACE_ARG_TYPE  ss_offset;
    char *  buf;
    int  sizeof_buf;
d3738 2
a3739 2
  int  tt_status;
  register_value_t  register_value = 0;
d3742 4
a3745 4
                           tid,
                           ss_offset,
                           (TTRACE_ARG_TYPE) sizeof_buf,
                           (TTRACE_ARG_TYPE) buf);
d3748 1
a3749 1

d3759 1
a3759 1
   */
d3762 12
a3773 12
     int               pt_request;
     int               gdb_tid;
     PTRACE_ARG3_TYPE  addr;
     int               data;
{
  ttreq_t           tt_request;
  TTRACE_ARG_TYPE   tt_addr = (TTRACE_ARG_TYPE) addr;
  TTRACE_ARG_TYPE   tt_data = (TTRACE_ARG_TYPE) data;
  TTRACE_ARG_TYPE   tt_addr2 = TT_NIL;
  int               tt_status;
  register_value_t  register_value;
  int               read_buf;
d3779 2
a3780 1
  switch (pt_request) {
d3787 52
a3838 52
         */
      case PT_SETTRC :
          return parent_attach_all ();
          
      case PT_RUREGS :
          tt_status = read_from_register_save_state (gdb_tid,
                                                     tt_addr,
                                                     &register_value,
                                                     sizeof (register_value));
          if (tt_status < 0)
            return tt_status;
          return register_value;

      case PT_WUREGS :
          register_value = (int) tt_data;
          tt_status = write_to_register_save_state (gdb_tid,
                                                    tt_addr,
                                                    &register_value,
                                                    sizeof (register_value));
          return tt_status;
          break;

      case PT_READ_I :
          tt_status = call_ttrace (TT_PROC_RDTEXT,  /* Implicit 4-byte xfer becomes block-xfer. */
                                   gdb_tid,
                                   tt_addr,
                                   (TTRACE_ARG_TYPE) 4,
                                   (TTRACE_ARG_TYPE) &read_buf);
          if (tt_status < 0)
            return tt_status;
          return read_buf;

      case PT_READ_D :
          tt_status = call_ttrace (TT_PROC_RDDATA,  /* Implicit 4-byte xfer becomes block-xfer. */
                                   gdb_tid,
                                   tt_addr,
                                   (TTRACE_ARG_TYPE) 4,
                                   (TTRACE_ARG_TYPE) &read_buf);
          if (tt_status < 0)
            return tt_status;
          return read_buf;

      case PT_ATTACH :
          tt_status = call_real_ttrace (TT_PROC_ATTACH,
                                        map_from_gdb_tid (gdb_tid),
                                        (lwpid_t) TT_NIL,
                                        tt_addr,
                                        (TTRACE_ARG_TYPE) TT_VERSION,
                                        tt_addr2);
          if (tt_status < 0)
            return tt_status;
          return tt_status;
d3842 53
a3894 53
         */
      case PT_DETACH :
          tt_request = TT_PROC_DETACH;
          break;

      case PT_WRITE_I :
          tt_request = TT_PROC_WRTEXT;  /* Translates 4-byte xfer to block-xfer. */
          tt_data = 4;                  /* This many bytes. */
          tt_addr2 = (TTRACE_ARG_TYPE) &data;  /* Address of xfer source. */
          break;

      case PT_WRITE_D :
          tt_request = TT_PROC_WRDATA;  /* Translates 4-byte xfer to block-xfer. */
          tt_data = 4;                  /* This many bytes. */
          tt_addr2 = (TTRACE_ARG_TYPE) &data;  /* Address of xfer source. */
          break;

      case PT_RDTEXT :
          tt_request = TT_PROC_RDTEXT;
          break;

      case PT_RDDATA :
          tt_request = TT_PROC_RDDATA;
          break;

      case PT_WRTEXT :
          tt_request = TT_PROC_WRTEXT;
          break;

      case PT_WRDATA :
          tt_request = TT_PROC_WRDATA;
          break;

      case PT_CONTINUE :
          tt_request = TT_PROC_CONTINUE;
          break;

      case PT_STEP :
          tt_request = TT_LWP_SINGLE;  /* Should not be making this request? */
          break;

      case PT_KILL :
          tt_request = TT_PROC_EXIT;
          break;

      case PT_GET_PROCESS_PATHNAME :
          tt_request = TT_PROC_GET_PATHNAME;
          break;

      default :
          tt_request = pt_request;  /* Let ttrace be the one to complain. */
          break;
  }
d3897 4
a3900 4
                      gdb_tid,
                      tt_addr,
                      tt_data,
                      tt_addr2);
d3908 3
a3910 3
  int  tid;
  int  wait_status;
  thread_info *  t;
d3912 1
a3912 1
  int           para_count, i;
d3927 1
a3927 1
     */
d3929 2
a3930 2
  paranoia = (thread_info **) malloc( thread_head.count *
                                      sizeof(thread_info *));
d3932 1
a3932 1
  
d3934 32
a3965 8
  while (t) {
  
    paranoia[ para_count ] = t;
    for( i = 0; i < para_count; i++ ){
        if( t->next == paranoia[i] ) {
            warning( "Bad data in gdb's thread data; repairing." );
            t->next = 0;
        }
a3966 1
    para_count++;
d3968 1
a3968 19
    if (t->am_pseudo && (t->pid != inferior_pid))
      {
        /* TT_PROC_STOP doesn't require a subsequent ttrace_wait, as it
         * generates no event.
         */
        call_ttrace (TT_PROC_STOP,
                     t->pid,
                     TT_NIL,
                     TT_NIL,
                     TT_NIL);

        call_ttrace (TT_PROC_DETACH,
                     t->pid,
                     TT_NIL,
                     (TTRACE_ARG_TYPE) TARGET_SIGNAL_0,
                     TT_NIL);
      }
    t = t->next;
  }
a3969 2
  free( paranoia );
  
d3971 4
a3974 4
               inferior_pid,
               TT_NIL,
               TT_NIL,
               TT_NIL);
d3976 1
a3976 1
  clear_thread_info();
d3985 2
a3986 2
thread_dropping_event_check( p )
    thread_info *p;
d3988 33
a4020 28
    if( !p->handled ) {
        /*
         * This seems to happen when we "next" over a
         * "fork()" while following the parent.  If it's
         * the FORK event, that's ok.  If it's a SIGNAL
         * in the unfollowed child, that's ok to--but
         * how can we know that's what's going on?
         *
         * FIXME!
         */
         if( p->have_state ) {
             if( p->last_stop_state.tts_event == TTEVT_FORK ) {
                 /* Ok */
                 ;
             }
             else if( p->last_stop_state.tts_event == TTEVT_SIGNAL ) {
                 /* Ok, close eyes and let it happen.
                  */
                 ;
             }
             else {
                 /* This shouldn't happen--we're dropping a
                  * real event.
                  */
                 warning( "About to continue process %d, thread %d with unhandled event %s.",
                         p->pid, p->tid,
                         get_printable_name_of_ttrace_event(
                                   p->last_stop_state.tts_event ));
d4023 2
a4024 2
                 if( debug_on )
                     print_tthread( p );
d4026 8
a4033 7
            }
        }
        else {
            /* No saved state, have to assume it failed.
             */
            warning( "About to continue process %d, thread %d with unhandled event.",
                     p->pid, p->tid );
d4035 2
a4036 2
            if( debug_on )
                print_tthread( p );
d4038 1
a4038 1
        }
d4040 2
a4041 2
    
}   /* thread_dropping_event_check */
d4047 26
a4072 11
threads_continue_all_but_one( gdb_tid, signal )
    lwpid_t gdb_tid;
    int     signal;
{
    thread_info  *p;
    int           thread_signal;
    lwpid_t       real_tid;
    lwpid_t       scan_tid;
    ttstate_t     state;
    int           real_pid;
    
d4074 6
a4079 2
    if( debug_on )
        printf( "Using loop over threads to step/resume with signals\n" );
d4082 22
a4103 38
    /* First update the thread list.
     */
    set_all_unseen();
    real_tid = map_from_gdb_tid( gdb_tid );
    real_pid = get_pid_for( real_tid );
    
    scan_tid = get_process_first_stopped_thread_id( real_pid, &state );
    while ( 0 != scan_tid ) {
    
#ifdef THREAD_DEBUG
        /* FIX: later should check state is stopped;
         * state.tts_flags & TTS_STATEMASK == TTS_WASSUSPENDED
         */
        if( debug_on )
            if( state.tts_flags & TTS_STATEMASK != TTS_WASSUSPENDED )
                printf( "About to continue non-stopped thread %d\n", scan_tid );
#endif

        p = find_thread_info( scan_tid );
        if( NULL == p ) {
            add_tthread( real_pid, scan_tid );
            p = find_thread_info( scan_tid );

            /* This is either a newly-created thread or the
             * result of a fork; in either case there's no
             * actual event to worry about.
             */
            p->handled = 1;

            if( state.tts_event != TTEVT_NONE ) {
                /* Oops, do need to worry!
                 */
                warning( "Unexpected thread with \"%s\" event.",
                    get_printable_name_of_ttrace_event( state.tts_event ));
            }
        }
        else if( scan_tid != p->tid )
            error( "Bad data in thread database." );
d4106 3
a4108 3
        if( debug_on )
            if( p->terminated )
                printf( "Why are we continuing a dead thread?\n" );
d4111 3
a4113 3
        p->seen = 1;
            
        scan_tid = get_process_next_stopped_thread_id( real_pid, &state );
d4116 12
a4127 3
    /* Remove unseen threads.
     */
    update_thread_list();
d4129 9
a4137 3
    /* Now run down the thread list and continue or step.
     */
    for( p = thread_head.head; p; p = p->next ) {
d4139 42
a4180 51
        /* Sanity check.
         */
        thread_dropping_event_check( p );

        /* Pass the correct signals along.
         */
        if( p->have_signal ) {
            thread_signal  = p->signal_value;
            p->have_signal = 0;
        }
        else
            thread_signal = 0;
             
        if( p->tid != real_tid ) {
            /*
             * Not the thread of interest, so continue it
             * as the user expects.
             */
            if( p->stepping_mode == DO_STEP ) {
                /* Just step this thread.
                 */
                call_ttrace(
                     TT_LWP_SINGLE,
                     p->tid,
                     TT_USE_CURRENT_PC,
                     (TTRACE_ARG_TYPE) target_signal_to_host( signal ),
                     TT_NIL );
            }
            else {
                /* Regular continue (default case).
                 */
                call_ttrace(
                         TT_LWP_CONTINUE,
                         p->tid,
                         TT_USE_CURRENT_PC,
                         (TTRACE_ARG_TYPE) target_signal_to_host( thread_signal ),
                         TT_NIL );
            }
        }
        else {
           /* Step the thread of interest.
            */
            call_ttrace(
                     TT_LWP_SINGLE,
                     real_tid,
                     TT_USE_CURRENT_PC,
                     (TTRACE_ARG_TYPE) target_signal_to_host( signal ),
                     TT_NIL );
        }   
    }   /* Loop over threads */
}   /* End threads_continue_all_but_one */
d4186 3
a4188 3
threads_continue_all_with_signals( gdb_tid, signal )
    lwpid_t gdb_tid;
    int     signal;
d4190 21
a4210 6
    thread_info  *p;
    int           thread_signal;
    lwpid_t       real_tid;
    lwpid_t       scan_tid;
    ttstate_t     state;
    int           real_pid;
d4213 3
a4215 2
    if( debug_on )
        printf( "Using loop over threads to resume with signals\n" );
d4218 20
a4237 33
    /* Scan and update thread list.
     */
    set_all_unseen();
    real_tid = map_from_gdb_tid( gdb_tid ); 
    real_pid = get_pid_for( real_tid );

    scan_tid = get_process_first_stopped_thread_id( real_pid, &state );
    while ( 0 != scan_tid ) {
    
#ifdef THREAD_DEBUG
        if( debug_on )
            if( state.tts_flags & TTS_STATEMASK != TTS_WASSUSPENDED )
                warning( "About to continue non-stopped thread %d\n", scan_tid );
#endif

        p = find_thread_info( scan_tid );
        if( NULL == p ) {
            add_tthread( real_pid, scan_tid );
            p = find_thread_info( scan_tid );

            /* This is either a newly-created thread or the
             * result of a fork; in either case there's no
             * actual event to worry about.
             */
            p->handled = 1;

            if( state.tts_event != TTEVT_NONE ) {
                /* Oops, do need to worry!
                 */
                warning( "Unexpected thread with \"%s\" event.",
                    get_printable_name_of_ttrace_event( state.tts_event ));
            }
        }
d4240 3
a4242 3
        if( debug_on )
            if( p->terminated )
                printf( "Why are we continuing a dead thread? (1)\n" );
d4245 1
a4245 1
        p->seen = 1;
d4247 1
a4247 1
        scan_tid = get_process_next_stopped_thread_id( real_pid, &state );
d4250 8
a4257 3
    /* Remove unseen threads from our list.
     */
    update_thread_list();
d4259 3
a4261 3
    /* Continue the threads.
     */
    for( p = thread_head.head; p; p = p->next ) {
d4263 14
a4276 16
        /* Sanity check.
         */
        thread_dropping_event_check( p );

        /* Pass the correct signals along.
         */
        if( p->tid == real_tid ) {
            thread_signal  = signal;
            p->have_signal = 0;
        }
        else if( p->have_signal ) {
            thread_signal  = p->signal_value;
            p->have_signal = 0;
        }
        else
            thread_signal  = 0;
d4278 20
a4297 18
        if( p->stepping_mode == DO_STEP ) {
            call_ttrace(
                     TT_LWP_SINGLE,
                     p->tid,
                     TT_USE_CURRENT_PC,
                     (TTRACE_ARG_TYPE) target_signal_to_host( signal ),
                     TT_NIL );
        }
        else {
            /* Continue this thread (default case).
             */
            call_ttrace(
                    TT_LWP_CONTINUE,
                    p->tid,
                    TT_USE_CURRENT_PC,
                    (TTRACE_ARG_TYPE) target_signal_to_host( thread_signal ),
                    TT_NIL );
        }
d4299 1
a4299 1
}   /* End threads_continue_all_with_signals */
d4304 3
a4306 3
thread_fake_step( tid, signal )
    lwpid_t            tid;
    enum target_signal signal;
d4308 1
a4308 1
    thread_info *p;
d4311 3
a4313 2
    if( debug_on ) {
        printf( "Doing a fake-step over a bpt, etc. for %d\n", tid );
d4315 2
a4316 2
        if( is_terminated( tid ))
            printf( "Why are we continuing a dead thread? (4)\n" );
a4318 3
          
    if( doing_fake_step )
        warning( "Step while step already in progress." );
d4320 17
a4336 12
    /* See if there's a saved signal value for this
     * thread to be passed on, but no current signal.
     */
    p = find_thread_info( tid );
    if( p != NULL ) {
        if( p->have_signal && signal == NULL ) {
            /* Pass on a saved signal.
             */
            signal = p->signal_value;
        }
        
        p->have_signal  = 0;
d4339 8
a4346 8
    if( !p->handled )
        warning( "Internal error: continuing unhandled thread." );
        
    call_ttrace( TT_LWP_SINGLE,
                 tid,
                 TT_USE_CURRENT_PC,
                 (TTRACE_ARG_TYPE) target_signal_to_host (signal),
                 TT_NIL );
d4348 5
a4352 5
    /* Do bookkeeping so "call_ttrace_wait" knows it has to wait
     * for this thread only, and clear any saved signal info.
     */
    doing_fake_step   = 1;
    fake_step_tid     = tid;
d4354 1
a4354 1
}   /* End thread_fake_step */
d4359 3
a4361 3
threads_continue_one_with_signal( gdb_tid, signal )
    lwpid_t gdb_tid;
    int     signal;
d4363 4
a4366 4
    thread_info  *p;
    lwpid_t       real_tid;
    int           real_pid;
    
d4368 2
a4369 2
    if( debug_on )
        printf( "Continuing one thread with a signal\n" );
d4372 2
a4373 2
    real_tid = map_from_gdb_tid( gdb_tid );
    real_pid = get_pid_for( real_tid );
d4375 4
a4378 3
    p = find_thread_info( real_tid );
    if( NULL == p ) {
        add_tthread( real_pid, real_tid );
d4382 3
a4384 3
    if( debug_on )
        if( p->terminated )
            printf( "Why are we continuing a dead thread? (2)\n" );
d4387 10
a4396 10
    if( !p->handled )
        warning( "Internal error: continuing unhandled thread." );
        
    p->have_signal = 0;
             
    call_ttrace( TT_LWP_CONTINUE,
                 gdb_tid,
                 TT_USE_CURRENT_PC,
                 (TTRACE_ARG_TYPE) target_signal_to_host( signal ),
                 TT_NIL );
d4403 1
a4403 1
 *
d4431 1
a4431 1
child_resume( gdb_tid, step, signal )
d4433 1
a4433 1
     int     step;
d4436 1
a4436 1
  int     resume_all_threads;
d4438 1
a4438 1
  process_state_t  new_process_state;
d4444 11
a4454 10
  if (resume_all_threads) {
    /* Resume all threads, but first pick a tid value
     * so we can get the pid when in call_ttrace doing
     * the map.
     */
    if (vfork_in_flight)
        tid = vforking_child_pid;
    else
        tid = map_from_gdb_tid( inferior_pid );
  }
d4456 1
a4456 1
      tid = map_from_gdb_tid( gdb_tid );
d4459 4
a4462 3
  if( debug_on ) {
      if( more_events_left )
          printf( "More events; " );
d4464 17
a4480 15
      if( signal != 0 )
          printf( "Sending signal %d; ", signal );
      
      if( resume_all_threads ) {
          if( step == 0 )
              printf( "Continue process %d\n", tid );
          else
              printf( "Step/continue thread %d\n", tid );
      }
      else {
          if( step == 0 )
              printf( "Continue thread %d\n", tid );
          else
              printf( "Step just thread %d\n", tid );
      }
d4482 3
a4484 3
      if( vfork_in_flight )
          printf( "Vfork in flight\n" );
  }
d4487 8
a4494 7
  if( process_state == RUNNING )
      warning( "Internal error in resume logic; doing resume or step anyway." );
      
  if(   !step                    /* Asked to continue...       */
     && resume_all_threads       /* whole process..            */
     && signal != 0              /* with a signal...           */
     && more_events_left > 0 ) { /* but we can't yet--save it! */
d4500 1
a4500 1
      
d4502 2
a4503 2
      if( debug_on )
           printf( "Saving signal %d for thread %d\n", signal, tid );
d4506 5
a4510 4
       k = find_thread_info( tid );
       if( k != NULL ) {
           k->have_signal  = 1;
           k->signal_value = signal;
d4513 3
a4515 3
           if( debug_on )
               if( k->terminated )
                   printf( "Why are we continuing a dead thread? (3)\n" );
d4518 1
a4518 1
       }
d4521 4
a4524 3
       else if( debug_on ) {
           printf( "No thread info for tid %d\n", tid );
       }
d4526 1
a4526 1
  }
d4529 1
a4529 1
   *
d4538 3
a4540 2
  if( resume_all_threads       /* Whole process, therefore user command */
   && more_events_left > 0 ) { /* But we can't do this yet--fake it! */
d4542 6
a4547 5
      
      if( !step ) {
          /* No need to do any notes on a per-thread
           * basis--we're done!
           */
d4549 2
a4550 2
          if( debug_on )
              printf( "Faking a process resume.\n" );
d4553 4
a4556 3
          return;
      }
      else {
d4559 2
a4560 2
          if( debug_on )
              printf( "Faking a process step.\n" );
d4563 10
a4572 8
      }
      
      p = find_thread_info( tid );
      if( p == NULL ) {
          warning( "No thread information for tid %d, 'next' command ignored.\n", tid );
          return;
      }
      else {
d4575 3
a4577 3
          if( debug_on )
              if( p->terminated )
                  printf( "Why are we continuing a dead thread? (3.5)\n" );
d4580 3
a4582 2
          if( p->stepping_mode != DO_DEFAULT ) {
              warning( "Step or continue command applied to thread which is already stepping or continuing; command ignored." );
d4584 2
a4585 7
              return;
          }

          if( step )
              p->stepping_mode = DO_STEP;
          else
              p->stepping_mode = DO_CONTINUE;
d4587 8
a4594 3
          return;
      }   /* Have thread info */
  }   /* Must fake step or go */
d4611 37
a4647 33
  if (step) {
      if( resume_all_threads ) {
          /*
           * Regular user step: other threads get a "continue".
           */
          threads_continue_all_but_one( tid, signal );
          clear_all_handled();
          clear_all_stepping_mode();
      }

      else {
          /* "Fake step": gdb is stepping one thread over a
           * breakpoint, watchpoint, or out of a library load
           * event, etc.  The rest just stay where they are.
           *
           * Also used when there are pending events: we really
           * step the current thread, but leave the rest stopped.
           * Users can't request this, but "wait_for_inferior"
           * does--a lot!
           */
          thread_fake_step( tid, signal );

          /* Clear the "handled" state of this thread, because
           * we'll soon get a new event for it.  Other events
           * stay as they were.
           */
          clear_handled( tid );
          clear_stepping_mode( tid );
          new_process_state = FAKE_STEPPING;
      }
  }
  
  else {
d4656 4
a4659 2
      if( (signal != 0) || saved_signals_exist()) {
          if( resume_all_threads ) {
d4662 2
a4663 2
              if( debug_on )
                  printf( "Doing a continue by loop of all threads\n" );
d4666 1
a4666 1
              threads_continue_all_with_signals( tid, signal );
d4668 3
a4670 3
              clear_all_handled();
              clear_all_stepping_mode();
          }
d4672 2
a4673 1
          else {
d4675 1
a4675 1
              printf( "Doing a continue w/signal of just thread %d\n", tid );
d4678 1
a4678 1
              threads_continue_one_with_signal( tid, signal );
d4680 8
a4687 8
              /* Clear the "handled" state of this thread, because
               * we'll soon get a new event for it.  Other events
               * can stay as they were.
               */
              clear_handled( tid );
              clear_stepping_mode( tid );
          }
      }
d4689 6
a4694 4
      else {
          /* No signals to send.
           */
          if( resume_all_threads ) {
d4696 2
a4697 2
              if( debug_on )
                  printf( "Doing a continue by process of process %d\n", tid );
d4700 11
a4710 4
              if( more_events_left > 0 ) {
                  warning( "Losing buffered events on continue." );
                  more_events_left = 0;
              }
d4712 3
a4714 5
              call_ttrace( TT_PROC_CONTINUE,
                           tid,
                           TT_NIL,
                           TT_NIL,
                           TT_NIL );
d4716 2
a4717 5
              clear_all_handled();
              clear_all_stepping_mode();
          }

          else {
d4719 23
a4741 22
              if( debug_on ) {
                  printf( "Doing a continue of just thread %d\n", tid );
                  if( is_terminated( tid ))
                       printf( "Why are we continuing a dead thread? (5)\n" );
              }
#endif

              call_ttrace( TT_LWP_CONTINUE,
                           tid,
                           TT_NIL,
                           TT_NIL,
                           TT_NIL );

              /* Clear the "handled" state of this thread, because
               * we'll soon get a new event for it.  Other events
               * can stay as they were.
               */
              clear_handled( tid );
              clear_stepping_mode( tid );
          }
      }
  }
d4746 3
a4748 3
  if( debug_on )
      printf( "Process set to %s\n",
              get_printable_name_of_process_state (process_state) );
d4753 1
a4754 1

d4764 8
a4771 8
update_thread_state_after_attach( pid, kind_of_go )
  int               pid;
  attach_continue_t kind_of_go;
{
  int        tt_status;
  ttstate_t  thread_state;
  lwpid_t    a_thread;
  lwpid_t    tid;
d4775 3
a4777 3
  if( process_state != STOPPED
   && process_state != VFORKING )
      warning( "Internal error attaching." );
d4788 1
a4788 1
  clear_thread_info();
d4796 1
a4796 1
    
d4798 2
a4799 2
        {
          a_thread = tid;
d4801 3
a4803 3
          if( debug_on )
              printf( "Attaching to process %d, thread %d\n",
                      pid, a_thread );
d4805 1
a4805 1
        }
d4820 6
a4825 6
      add_tthread( pid, tid );
      p = find_thread_info( tid );
      if( NULL == p ) /* ?We just added it! */
          error( "Internal error adding a thread on attach." );
          
      copy_ttstate_t( &p->last_stop_state, thread_state );
d4827 57
a4883 53
      
      if( DO_ATTACH_CONTINUE == kind_of_go ) {
          /*
           * If we are going to CONTINUE afterwards,
           * raising a SIGTRAP, don't bother trying to
           * handle this event.  But check first!
           */
          switch( p->last_stop_state.tts_event ) {

          case TTEVT_NONE:
             /* Ok to set this handled.
              */
              break;

          default:
              warning( "Internal error; skipping event %s on process %d, thread %d.",
                  get_printable_name_of_ttrace_event(
                       p->last_stop_state.tts_event ),
                  p->pid, p->tid);
          }

          set_handled( pid, tid );

      }
      else {
          /* There will be no "continue" opertion, so the
           * process remains stopped.  Don't set any events
           * handled except the "gimmies".
           */
          switch( p->last_stop_state.tts_event ) {

          case TTEVT_NONE:
              /* Ok to ignore this.
               */
              set_handled( pid, tid );
              break;

          case TTEVT_EXEC:
          case TTEVT_FORK:
              /* Expected "other" FORK or EXEC event from a
               * fork or vfork.
               */
              break;

          default:
              printf( "Internal error: failed to handle event %s on process %d, thread %d.",
                  get_printable_name_of_ttrace_event(
                       p->last_stop_state.tts_event ),
                  p->pid, p->tid);
          }
      }
      
      add_thread( tid );       /* in thread.c */
d4885 1
a4885 1
 
d4887 2
a4888 2
    if( debug_on )
        print_tthreads();
d4893 1
a4893 1
     
d4908 9
a4916 8
  if( DO_ATTACH_CONTINUE == kind_of_go ) {
      tt_status = call_real_ttrace(
                      TT_LWP_CONTINUE,
                      pid,
                      a_thread,
                      TT_USE_CURRENT_PC,
                      (TTRACE_ARG_TYPE) target_signal_to_host (TARGET_SIGNAL_TRAP),
                      TT_NIL);
d4918 1
a4918 1
          perror_with_name ("ttrace");
d4920 1
a4920 1
      clear_handled( a_thread );  /* So TRAP will be reported. */
d4925 1
a4925 1
  }
d4930 1
a4931 1

d4937 1
a4937 1
attach( pid )
d4940 2
a4941 2
  int       tt_status;
  
d4943 6
a4948 6
                           TT_PROC_ATTACH,
                           pid,
                           (lwpid_t) TT_NIL,
                           TT_NIL,
                           (TTRACE_ARG_TYPE) TT_VERSION,
                           TT_NIL);
d4961 1
a4961 1
  update_thread_state_after_attach( pid, DO_ATTACH_CONTINUE );
d4970 1
a4970 1
  int  pid;
d4973 2
a4974 2
  if( debug_on )
      printf( "child-post-attach call\n" );
d4987 1
a4987 1
detach( signal )
d4992 4
a4995 4
               inferior_pid,
               TT_NIL,
               (TTRACE_ARG_TYPE) signal,
               TT_NIL);
d4998 1
a4998 1
  clear_thread_info();
d5003 1
a5004 1

d5025 1
a5025 1
  
d5037 1
a5037 1
     struct target_ops *target;		/* ignored */
d5041 1
a5041 1
  register CORE_ADDR addr = memaddr & - sizeof (TTRACE_XFER_TYPE);
d5044 2
a5045 2
    = (((memaddr + len) - addr) + sizeof (TTRACE_XFER_TYPE) - 1)
      / sizeof (TTRACE_XFER_TYPE);
d5048 1
a5048 1
    = (TTRACE_XFER_TYPE *) alloca (count * sizeof (TTRACE_XFER_TYPE));
d5054 9
a5062 8
      if (addr != memaddr || len < (int) sizeof (TTRACE_XFER_TYPE)) {
	/* Need part of initial word -- fetch it.  */
        buffer[0] = call_ttrace (TT_LWP_RDTEXT,
                                 inferior_pid,
                                 (TTRACE_ARG_TYPE) addr,
                                 TT_NIL,
                                 TT_NIL);
      }
d5067 5
a5071 5
                                           inferior_pid,
                                           ((TTRACE_ARG_TYPE)
                                            (addr + (count - 1) * sizeof (TTRACE_XFER_TYPE))),
                                           TT_NIL,
                                           TT_NIL);
d5086 4
a5089 4
                       inferior_pid,
                       (TTRACE_ARG_TYPE) addr,
                       (TTRACE_ARG_TYPE) buffer[i],
                       TT_NIL);
d5093 1
a5093 1
		 Gould NP1, at least.  */
d5096 4
a5099 4
                           inferior_pid,
                           (TTRACE_ARG_TYPE) addr,
                           (TTRACE_ARG_TYPE) buffer[i],
                           TT_NIL);
d5112 4
a5115 4
                                   inferior_pid,
                                   (TTRACE_ARG_TYPE) addr,
                                   TT_NIL,
                                   TT_NIL);
d5128 1
a5129 1

d5133 8
a5140 8
  int udot_off;		/* Offset into user struct */
  int udot_val;		/* Value from user struct at udot_off */
  char mess[128];	/* For messages */

   if (!target_has_execution)
     {
       error ("The program is not being run.");
     }
d5163 4
a5166 4
                              inferior_pid,
                              (TTRACE_ARG_TYPE) udot_off,
                              TT_NIL,
                              TT_NIL);
d5185 1
a5185 1
    int  tid;
d5187 9
a5195 9
  static char  exec_file_buffer[1024];
  int  tt_status;
  CORE_ADDR  top_of_stack;
  char  four_chars[4];
  int  name_index;
  int  i;
  int  done;
  int  saved_inferior_pid;
  
d5200 4
a5203 4
                           tid,
                           (TTRACE_ARG_TYPE) exec_file_buffer,
                           (TTRACE_ARG_TYPE) sizeof (exec_file_buffer) - 1,
                           TT_NIL);
d5215 2
a5216 2
     */
  top_of_stack = 0x7b03a000;
d5223 1
a5223 1
     */
d5228 15
a5242 11
  while (! done) {
    if (target_read_memory (top_of_stack, four_chars, 4) != 0)
      {
        inferior_pid = saved_inferior_pid;
        return NULL;
      }
    for (i = 0; i < 4; i++) {
      exec_file_buffer[name_index++] = four_chars[i];
      done = (four_chars[i] == '\0');
      if (done)
        break;
a5243 2
    top_of_stack += 4;
  }
d5259 1
a5259 1
  int  status;
d5262 2
a5263 1
  if (status < 0) {
d5266 1
a5266 1
  }
d5269 2
a5270 1
  if (status < 0) {
d5273 1
a5273 1
  }
d5287 1
a5287 1
  int  pid;
d5289 4
a5292 4
  int             tt_status;
  CORE_ADDR       pc;
  CORE_ADDR       pc_addr;
  unsigned int    regs_offset;
d5294 1
a5294 1
  
d5303 6
a5308 6
                                pid,
                                (lwpid_t) TT_NIL,
                                (TTRACE_ARG_TYPE) TT_NIL,
                                (TTRACE_ARG_TYPE) TT_NIL,
                                TT_NIL);
  
d5314 1
a5314 1
      pid   = attach (pid);
d5318 23
a5340 23
     /* If successful, the process is now stopped.  But if
      * we're VFORKING, the parent is still running, so don't
      * change the process state.
      */
     if( process_state != VFORKING )
         process_state = STOPPED;

     /* If we were already attached, you'd think that we
      * would need to start going again--but you'd be wrong,
      * as the fork-following code is actually in the middle
      * of the "resume" routine in in "infrun.c" and so
      * will (almost) immediately do a resume.
      *
      * On the other hand, if we are VFORKING, which means
      * that the child and the parent share a process for a
      * while, we know that "resume" won't be resuming
      * until the child EXEC event is seen.  But we still
      * don't want to continue, as the event is already
      * there waiting.
      */
     update_thread_state_after_attach( pid, DONT_ATTACH_CONTINUE );
    }   /* STOP succeeded */
    
d5346 2
a5347 2
  int  pid;
  int  signal;
d5349 1
a5349 1
  int  tt_status;
d5358 1
a5358 1
      threads_continue_all_with_signals( pid, signal );
d5363 4
a5366 4
                           pid,
                           TT_NIL,
                           TT_NIL,
                           TT_NIL);
d5368 1
a5368 1
  errno = 0; /* Ignore any errors. */
d5371 1
a5371 1
  
d5377 1
a5377 1
   */
d5380 1
a5380 1
  CORE_ADDR  page_start;
d5382 1
a5382 1
  int  hash;
d5395 1
a5395 1
   */
d5398 2
a5399 2
  int  pid;
  CORE_ADDR  page_start;
d5401 3
a5403 3
  int  bucket;
  memory_page_t *  page = NULL;
  memory_page_t *  previous_page = NULL;
d5410 1
a5410 1
     */
d5416 1
a5416 1
        break;
d5423 1
a5423 1
     */
d5449 2
a5450 2
  int  pid;
  memory_page_t *  page;
d5472 1
a5472 1
  int  pid;
d5474 2
a5475 2
  int  tt_status;
  ttevent_t  ttrace_events;
d5479 4
a5482 4
                           pid,
                           (TTRACE_ARG_TYPE) &ttrace_events,
                           (TTRACE_ARG_TYPE) sizeof (ttrace_events),
                           TT_NIL);
d5491 4
a5494 4
                           pid,
                           (TTRACE_ARG_TYPE) &ttrace_events,
                           (TTRACE_ARG_TYPE) sizeof (ttrace_events),
                           TT_NIL);
d5502 1
a5502 1
  int  pid;
d5504 2
a5505 2
  int  tt_status;
  ttevent_t  ttrace_events;
d5509 4
a5512 4
                           pid,
                           (TTRACE_ARG_TYPE) &ttrace_events,
                           (TTRACE_ARG_TYPE) sizeof (ttrace_events),
                           TT_NIL);
d5521 4
a5524 4
                           pid,
                           (TTRACE_ARG_TYPE) &ttrace_events,
                           (TTRACE_ARG_TYPE) sizeof (ttrace_events),
                           TT_NIL);
d5535 3
a5537 3
     0 for a bp_hardware_watchpoint,
     1 for a bp_read_watchpoint,
     2 for a bp_access_watchpoint
d5541 1
a5541 1
   */
d5544 10
a5553 10
  int  pid;
  CORE_ADDR  start;
  LONGEST  len;
  int  type;
{
  CORE_ADDR  page_start;
  int  dictionary_was_empty;
  int  page_size;
  int  page_id;
  LONGEST  range_size_in_pages;
d5567 1
a5567 1
  for (page_id=0; page_id < range_size_in_pages; page_id++, page_start+=page_size)
d5569 1
a5569 1
      memory_page_t *  page;
d5573 1
a5573 1
         */
d5605 1
a5605 1
     */
d5618 1
a5618 1
   */
d5621 10
a5630 10
  int  pid;
  CORE_ADDR  start;
  LONGEST  len;
  enum bptype  type;
{
  CORE_ADDR  page_start;
  int  dictionary_is_empty;
  int  page_size;
  int  page_id;
  LONGEST  range_size_in_pages;
d5642 1
a5642 1
  for (page_id=0; page_id < range_size_in_pages; page_id++, page_start+=page_size)
d5644 1
a5644 1
      memory_page_t *  page;
d5652 1
a5652 1
         */
d5654 1
a5654 1
        remove_dictionary_entry_of_page (pid, page);
d5666 1
a5666 1
     */
d5682 1
a5682 1
   */
d5685 3
a5687 3
  enum bptype  type;
  int  cnt;
  enum bptype  ot;
d5697 1
a5697 1
   */
d5700 10
a5709 10
  int  pid;
  CORE_ADDR  start;
  LONGEST  len;
{
  int  range_is_stack_based;
  int  range_is_accessible;
  CORE_ADDR  page_start;
  int  page_size;
  int  page;
  LONGEST  range_size_in_pages;
d5714 1
a5714 1
     */
d5722 2
a5723 2
     */
  range_is_accessible = 1;  /* Until proven otherwise. */
d5732 1
a5732 1
     */
d5740 1
a5740 1
  range_size_in_pages = len / (LONGEST)page_size;
d5742 1
a5742 1
  for (page=0; page < range_size_in_pages; page++, page_start+=page_size)
d5744 2
a5745 2
      int  tt_status;
      int  page_permissions;
d5750 4
a5753 4
                               pid,
                               (TTRACE_ARG_TYPE) page_start,
                               TT_NIL,
                               (TTRACE_ARG_TYPE) &page_permissions);
d5755 5
a5759 5
        {
          errno = 0;
          range_is_accessible = 0;
          break;
        }
d5764 1
a5764 1
  return (! range_is_stack_based && range_is_accessible);
d5770 1
a5770 1
  pid_t  id;
d5772 1
a5772 1
  static char  buf[100]; /* Static because address returned. */
d5776 1
a5776 1
    return hppa_pid_to_str (id);
d5785 1
a5786 1

d5794 3
a5796 3
pid_t 
hppa_switched_threads( gdb_pid )
  pid_t gdb_pid;
d5798 2
a5799 1
  if( gdb_pid == old_gdb_pid ) {
d5810 3
a5812 2
  }
  else if( gdb_pid == reported_pid ) {
d5820 9
a5828 8
  }
  else if( !reported_bpt ) {
       /*
        * The core switched, but we didn't just report a
        * breakpoint, so there's no just-hit breakpoint
        * instruction at "reported_pid"'s PC, and thus there
        * is no need to step over it.
        */
d5830 10
a5839 9
  }
  else {
       /* There's been a real switch, and we reported
        * a hit breakpoint.  Let "hppa_prepare_to_proceed"
        * know, so it can see whether the breakpoint is
        * still active.
        */
       return reported_pid;
  }
d5843 1
a5843 1
  return (pid_t) 0;  
d5848 1
a5848 1
  int  pid;
d5859 1
a5859 1
  return 0;  /* No, the parent vfork is available now. */
d5861 48
d5910 2
a5912 1

d5917 1
a5917 1
  memory_page_dictionary.page_count = (LONGEST) -1;
d5923 5
a5930 1

@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d120 5
a124 7
 */
typedef struct
  {
    int parent_channel[2];	/* Parent "talks" to [1], child "listens" to [0] */
    int child_channel[2];	/* Child "talks" to [1], parent "listens" to [0] */
  }
startup_semaphore_t;
d129 1
a129 1
static startup_semaphore_t startup_semaphore;
d132 2
a133 2
static int vforking_child_pid = 0;
static int vfork_in_flight = 0;
d137 1
a137 1
static pid_t old_gdb_pid = 0;
d150 1
a150 1
 */
d156 1
a156 1
 */
d167 2
a168 2
 */
typedef int register_value_t;
d294 1
a294 2
typedef enum process_state_enum
  {
d297 1
a297 1
    FAKE_CONTINUE,		/* For later use */
d301 1
a301 2
  }
process_state_t;
d307 2
a308 3
typedef enum stepping_mode_enum
  {
    DO_DEFAULT,			/* ...which is a continue! */
d311 2
a312 3
  }
stepping_mode_t;

d322 4
a325 6
typedef enum attach_continue_enum
  {
    DO_ATTACH_CONTINUE,
    DONT_ATTACH_CONTINUE
  }
attach_continue_t;
d333 3
a335 2
static int doing_fake_step = 0;
static lwpid_t fake_step_tid = 0;
a336 1

d341 1
a341 1
typedef
d343 14
a356 14
  {
    int am_pseudo;		/* This is a pseudo-thread for the process. */
    int pid;			/* Process ID */
    lwpid_t tid;		/* Thread  ID */
    int handled;		/* 1 if a buffered event was handled. */
    int seen;			/* 1 if this thread was seen on a traverse. */
    int terminated;		/* 1 if thread has terminated. */
    int have_signal;		/* 1 if signal to be sent */
    enum target_signal signal_value;	/* Signal to send */
    int have_start;		/* 1 if alternate starting address */
    stepping_mode_t stepping_mode;	/* Whether to step or continue */
    CORE_ADDR start;		/* Where to start */
    int have_state;		/* 1 if the event state has been set */
    ttstate_t last_stop_state;	/* The most recently-waited event for this thread. */
d358 1
a358 1
     *next;			/* All threads are linked via this field. */
d360 2
a361 3
     *next_pseudo;		/* All pseudo-threads are linked via this field. */
  }
thread_info;
d365 2
a366 2
  {
    int count;
d369 2
d372 2
a373 2
  }
thread_info_header;
d375 1
a375 4
static thread_info_header thread_head =
{0, NULL, NULL};
static thread_info_header deleted_threads =
{0, NULL, NULL};
a376 1
static saved_real_pid = 0;
a377 1

d383 2
a384 2
get_raw_pc (ttid)
     lwpid_t ttid;
d386 12
a397 13
  unsigned long pc_val;
  int offset;
  int res;

  offset = register_addr (PC_REGNUM, U_REGS_OFFSET);
  res = read_from_register_save_state (
					ttid,
					(TTRACE_ARG_TYPE) offset,
					(char *) &pc_val,
					sizeof (pc_val));
  if (res <= 0)
    {
      return (CORE_ADDR) pc_val;
d399 2
a400 3
  else
    {
      return (CORE_ADDR) 0;
d402 1
a402 1
}
d405 2
a406 2
get_printable_name_of_stepping_mode (mode)
     stepping_mode_t mode;
d408 6
a413 11
  switch (mode)
    {
    case DO_DEFAULT:
      return "DO_DEFAULT";
    case DO_STEP:
      return "DO_STEP";
    case DO_CONTINUE:
      return "DO_CONTINUE";
    default:
      return "?unknown mode?";
    }
d421 1
a421 1
     ttevents_t event;
d424 1
a424 2
  switch (event)
    {
d427 1
a427 1
      return "TTEVT_NONE";
d429 1
a429 1
      return "TTEVT_SIGNAL";
d431 1
a431 1
      return "TTEVT_FORK";
d433 1
a433 1
      return "TTEVT_EXEC";
d435 1
a435 1
      return "TTEVT_EXIT";
d437 1
a437 1
      return "TTEVT_VFORK";
d439 1
a439 1
      return "TTEVT_SYSCALL_RETURN";
d441 1
a441 1
      return "TTEVT_LWP_CREATE";
d443 1
a443 1
      return "TTEVT_LWP_TERMINATE";
d445 1
a445 1
      return "TTEVT_LWP_EXIT";
d447 1
a447 1
      return "TTEVT_LWP_ABORT_SYSCALL";
d449 4
a452 4
      return "TTEVT_SYSCALL_ENTRY";
    case TTEVT_SYSCALL_RESTART:
      return "TTEVT_SYSCALL_RESTART";
    default:
d454 1
a454 1
    }
d456 1
a457 1

d464 1
a464 1
     ttreq_t request;
d470 2
a471 3
  switch (request)
    {
    case TT_PROC_SETTRC:
d473 1
a473 1
    case TT_PROC_ATTACH:
d475 1
a475 1
    case TT_PROC_DETACH:
d477 1
a477 1
    case TT_PROC_RDTEXT:
d479 1
a479 1
    case TT_PROC_WRTEXT:
d481 1
a481 1
    case TT_PROC_RDDATA:
d483 1
a483 1
    case TT_PROC_WRDATA:
d485 1
a485 1
    case TT_PROC_STOP:
d487 1
a487 1
    case TT_PROC_CONTINUE:
d489 1
a489 1
    case TT_PROC_GET_PATHNAME:
d491 1
a491 1
    case TT_PROC_GET_EVENT_MASK:
d493 1
a493 1
    case TT_PROC_SET_EVENT_MASK:
d495 1
a495 1
    case TT_PROC_GET_FIRST_LWP_STATE:
d497 1
a497 1
    case TT_PROC_GET_NEXT_LWP_STATE:
d499 1
a499 1
    case TT_PROC_EXIT:
d501 1
a501 1
    case TT_PROC_GET_MPROTECT:
d503 1
a503 1
    case TT_PROC_SET_MPROTECT:
d505 1
a505 1
    case TT_PROC_SET_SCBM:
d507 1
a507 1
    case TT_LWP_STOP:
d509 1
a509 1
    case TT_LWP_CONTINUE:
d511 1
a511 1
    case TT_LWP_SINGLE:
d513 1
a513 1
    case TT_LWP_RUREGS:
d515 1
a515 1
    case TT_LWP_WUREGS:
d517 1
a517 1
    case TT_LWP_GET_EVENT_MASK:
d519 1
a519 1
    case TT_LWP_SET_EVENT_MASK:
d521 1
a521 1
    case TT_LWP_GET_STATE:
d523 1
a523 1
    default:
d525 1
a525 1
    }
d527 1
a528 1

d535 1
a535 1
     process_state_t process_state;
d537 1
a537 2
  switch (process_state)
    {
d550 1
a550 1
    }
d557 1
a557 1
     ttstate_t *tts;
d559 4
a562 4
  tts->tts_pid = 0;
  tts->tts_lwpid = 0;
  tts->tts_user_tid = 0;
  tts->tts_event = TTEVT_NONE;
d569 2
a570 2
     ttstate_t *tts_to;
     ttstate_t *tts_from;
d572 1
a572 1
  memcpy ((char *) tts_to, (char *) tts_from, sizeof (*tts_to));
d577 2
a578 2
static int
any_thread_records ()
d580 1
a580 1
  return (thread_head.count > 0);
d587 2
a588 2
     int pid;
     lwpid_t tid;
d590 18
a607 18
  thread_info *new_p;
  thread_info *p;
  int thread_count_of_pid;

  new_p = malloc (sizeof (thread_info));
  new_p->pid = pid;
  new_p->tid = tid;
  new_p->have_signal = 0;
  new_p->have_start = 0;
  new_p->have_state = 0;
  clear_ttstate_t (&new_p->last_stop_state);
  new_p->am_pseudo = 0;
  new_p->handled = 0;
  new_p->seen = 0;
  new_p->terminated = 0;
  new_p->next = NULL;
  new_p->next_pseudo = NULL;
  new_p->stepping_mode = DO_DEFAULT;
d609 1
a609 2
  if (0 == thread_head.count)
    {
d611 2
a612 2
      if (debug_on)
	printf ("First thread, pid %d tid %d!\n", pid, tid);
d614 1
a614 1
      saved_real_pid = inferior_pid;
d616 1
a616 2
  else
    {
d618 2
a619 2
      if (debug_on)
	printf ("Subsequent thread, pid %d tid %d\n", pid, tid);
d623 3
a625 3
  /* Another day, another thread...
   */
  thread_head.count++;
d627 4
a630 4
  /* The new thread always goes at the head of the list.
   */
  new_p->next = thread_head.head;
  thread_head.head = new_p;
d632 13
a644 13
  /* Is this the "pseudo" thread of a process?  It is if there's
   * no other thread for this process on the list.  (Note that this
   * accomodates multiple processes, such as we see even for simple
   * cases like forking "non-threaded" programs.)
   */
  p = thread_head.head;
  thread_count_of_pid = 0;
  while (p)
    {
      if (p->pid == new_p->pid)
	thread_count_of_pid++;
      p = p->next;
    }
d646 11
a656 11
  /* Did we see any other threads for this pid?  (Recall that we just
   * added this thread to the list...)
   */
  if (thread_count_of_pid == 1)
    {
      new_p->am_pseudo = 1;
      new_p->next_pseudo = thread_head.head_pseudo;
      thread_head.head_pseudo = new_p;
    }

  return new_p;
d664 2
a665 2
  thread_info *p;
  thread_info *q;
d668 2
a669 2
  if (debug_on)
    printf ("Clearing all thread info\n");
d672 5
a676 6
  p = thread_head.head;
  while (p)
    {
      q = p;
      p = p->next;
      free (q);
d679 3
a681 3
  thread_head.head = NULL;
  thread_head.head_pseudo = NULL;
  thread_head.count = 0;
d683 5
a687 6
  p = deleted_threads.head;
  while (p)
    {
      q = p;
      p = p->next;
      free (q);
d690 3
a692 3
  deleted_threads.head = NULL;
  deleted_threads.head_pseudo = NULL;
  deleted_threads.count = 0;
d694 3
a696 3
  /* No threads, so can't have pending events.
   */
  more_events_left = 0;
d703 1
a703 1
     lwpid_t tid;
d705 1
a705 1
  thread_info *p;
d707 4
a710 6
  for (p = thread_head.head; p; p = p->next)
    {
      if (p->tid == tid)
	{
	  return p;
	}
d713 4
a716 6
  for (p = deleted_threads.head; p; p = p->next)
    {
      if (p->tid == tid)
	{
	  return p;
	}
d718 2
a719 2

  return NULL;
d730 2
a731 2
map_from_gdb_tid (gdb_tid)
     lwpid_t gdb_tid;
d733 1
a733 1
  thread_info *p;
d735 6
a740 7
  /* First assume gdb_tid really is a tid, and try to find a
   * matching entry on the threads list.
   */
  for (p = thread_head.head; p; p = p->next)
    {
      if (p->tid == gdb_tid)
	return gdb_tid;
d743 8
a750 8
  /* It doesn't appear to be a tid; perhaps it's really a pid?
   * Try to find a "pseudo" thread entry on the threads list.
   */
  for (p = thread_head.head_pseudo; p != NULL; p = p->next_pseudo)
    {
      if (p->pid == gdb_tid)
	return p->tid;
    }
d752 6
a757 7
  /* Perhaps it's the tid of a deleted thread we may still
   * have some knowledge of?
   */
  for (p = deleted_threads.head; p; p = p->next)
    {
      if (p->tid == gdb_tid)
	return gdb_tid;
d760 8
a767 8
  /* Or perhaps it's the pid of a deleted process we may still
   * have knowledge of?
   */
  for (p = deleted_threads.head_pseudo; p != NULL; p = p->next_pseudo)
    {
      if (p->pid == gdb_tid)
	return p->tid;
    }
d769 1
a769 1
  return 0;			/* Error? */
d778 2
a779 2
map_to_gdb_tid (real_tid)
     lwpid_t real_tid;
d781 1
a781 1
  thread_info *p;
d783 7
a789 9
  for (p = thread_head.head; p; p = p->next)
    {
      if (p->tid == real_tid)
	{
	  if (p->am_pseudo)
	    return p->pid;
	  else
	    return real_tid;
	}
d792 6
a797 7
  for (p = deleted_threads.head; p; p = p->next)
    {
      if (p->tid == real_tid)
	if (p->am_pseudo)
	  return p->pid;	/* Error? */
	else
	  return real_tid;
d800 1
a800 1
  return 0;			/* Error?  Never heard of this thread! */
d805 1
a805 1
static int
d808 6
a813 8
  thread_info *p;

  for (p = thread_head.head; p; p = p->next)
    {
      if (p->have_signal)
	{
	  return 1;
	}
d816 1
a816 1
  return 0;
d821 1
a821 1
static int
d823 1
a823 1
     lwpid_t tid;
d825 5
a829 5
  thread_info *p = find_thread_info (tid);
  if (NULL == p || p->terminated)
    return 0;
  else
    return p->am_pseudo;
d834 1
a834 1
static int
d836 1
a836 1
     lwpid_t tid;
d838 1
a838 1
  thread_info *p = find_thread_info (tid);
d840 2
a841 2
  if (NULL != p)
    return p->terminated;
d843 1
a843 1
  return 0;
d848 1
a848 1
static int
d850 1
a850 1
     int pid;
d852 4
a855 4
  lwpid_t tid;
  thread_info *tinfo;
  pid_t this_pid;
  int this_pid_count;
d861 1
a861 1
    return 0;			/* Actually, is probably an error... */
d867 1
a867 1
  if (!tinfo->am_pseudo)
d879 1
a879 1
	this_pid_count++;
d890 2
a891 2
     int pid;
     lwpid_t tid;
d893 1
a893 1
  thread_info *p;
d895 3
a897 3
  p = find_thread_info (tid);
  if (NULL == p)
    p = create_thread_info (pid, tid);
d899 1
a899 1
  return p;
d906 1
a906 1
     lwpid_t tid;
d908 2
a909 8
  thread_info *p;
  thread_info *chase;

  if (thread_head.count <= 0)
    {
      error ("Internal error in thread database.");
      return;
    }
d911 64
a974 5
  chase = NULL;
  for (p = thread_head.head; p; p = p->next)
    {
      if (p->tid == tid)
	{
d976 2
a977 62
#ifdef THREAD_DEBUG
	  if (debug_on)
	    printf ("Delete here: %d \n", tid);
#endif

	  if (p->am_pseudo)
	    {
	      /*
	       * Deleting a main thread is ok if we're doing
	       * a parent-follow on a child; this is odd but
	       * not wrong.  It apparently _doesn't_ happen
	       * on the child-follow, as we don't just delete
	       * the pseudo while keeping the rest of the
	       * threads around--instead, we clear out the whole
	       * thread list at once.
	       */
	      thread_info *q;
	      thread_info *q_chase;

	      q_chase = NULL;
	      for (q = thread_head.head_pseudo; q; q = q->next)
		{
		  if (q == p)
		    {
		      /* Remove from pseudo list.
		       */
		      if (q_chase == NULL)
			thread_head.head_pseudo = p->next_pseudo;
		      else
			q_chase->next = p->next_pseudo;
		    }
		  else
		    q_chase = q;
		}
	    }

	  /* Remove from live list.
	   */
	  thread_head.count--;

	  if (NULL == chase)
	    thread_head.head = p->next;
	  else
	    chase->next = p->next;

	  /* Add to deleted thread list.
	   */
	  p->next = deleted_threads.head;
	  deleted_threads.head = p;
	  deleted_threads.count++;
	  if (p->am_pseudo)
	    {
	      p->next_pseudo = deleted_threads.head_pseudo;
	      deleted_threads.head_pseudo = p;
	    }
	  p->terminated = 1;

	  return;
	}

      else
	chase = p;
d985 1
a985 1
     lwpid_t tid;
d987 1
a987 1
  thread_info *p;
d989 4
a992 6
  for (p = thread_head.head; p; p = p->next)
    {
      if (p->tid == tid)
	{
	  return p->pid;
	}
d995 4
a998 6
  for (p = deleted_threads.head; p; p = p->next)
    {
      if (p->tid == tid)
	{
	  return p->pid;
	}
d1000 2
a1001 2

  return 0;
d1007 9
a1015 9
set_handled (pid, tid)
     int pid;
     lwpid_t tid;
{
  thread_info *p;

  p = find_thread_info (tid);
  if (NULL == p)
    p = add_tthread (pid, tid);
d1017 1
a1017 1
  p->handled = 1;
d1022 9
a1030 5
static int
was_handled (tid)
     lwpid_t tid;
{
  thread_info *p;
d1032 1
a1032 5
  p = find_thread_info (tid);
  if (NULL != p)
    return p->handled;

  return 0;			/* New threads have not been handled */
d1038 2
a1039 2
clear_handled (tid)
     lwpid_t tid;
d1041 2
a1042 2
  thread_info *p;

d1044 2
a1045 2
  if (debug_on)
    printf ("clear_handled %d\n", (int) tid);
d1060 1
a1060 1
  thread_info *p;
d1063 2
a1064 2
  if (debug_on)
    printf ("clear_all_handled\n");
d1067 2
a1068 3
  for (p = thread_head.head; p; p = p->next)
    {
      p->handled = 0;
d1071 2
a1072 3
  for (p = deleted_threads.head; p; p = p->next)
    {
      p->handled = 0;
d1079 2
a1080 2
clear_stepping_mode (tid)
     lwpid_t tid;
d1082 2
a1083 2
  thread_info *p;

d1085 2
a1086 2
  if (debug_on)
    printf ("clear_stepping_mode %d\n", (int) tid);
d1101 1
a1101 1
  thread_info *p;
d1104 2
a1105 2
  if (debug_on)
    printf ("clear_all_stepping_mode\n");
d1108 2
a1109 3
  for (p = thread_head.head; p; p = p->next)
    {
      p->stepping_mode = DO_DEFAULT;
d1112 2
a1113 3
  for (p = deleted_threads.head; p; p = p->next)
    {
      p->stepping_mode = DO_DEFAULT;
d1118 1
a1118 1
 */
d1122 1
a1122 1
  thread_info *p;
d1124 2
a1125 3
  for (p = thread_head.head; p; p = p->next)
    {
      p->seen = 0;
d1134 1
a1134 1
     thread_info *p;
d1136 25
a1160 25
  printf (" Thread pid %d, tid %d", p->pid, p->tid);
  if (p->have_state)
    printf (", event is %s",
	 get_printable_name_of_ttrace_event (p->last_stop_state.tts_event));

  if (p->am_pseudo)
    printf (", pseudo thread");

  if (p->have_signal)
    printf (", have signal 0x%x", p->signal_value);

  if (p->have_start)
    printf (", have start at 0x%x", p->start);

  printf (", step is %s", get_printable_name_of_stepping_mode (p->stepping_mode));

  if (p->handled)
    printf (", handled");
  else
    printf (", not handled");

  if (p->seen)
    printf (", seen");
  else
    printf (", not seen");
d1162 1
a1162 1
  printf ("\n");
d1168 1
a1168 16
  thread_info *p;

  if (thread_head.count == 0)
    printf ("Thread list is empty\n");
  else
    {
      printf ("Thread list has ");
      if (thread_head.count == 1)
	printf ("1 entry:\n");
      else
	printf ("%d entries:\n", thread_head.count);
      for (p = thread_head.head; p; p = p->next)
	{
	  print_tthread (p);
	}
    }
d1170 25
a1194 14
  if (deleted_threads.count == 0)
    printf ("Deleted thread list is empty\n");
  else
    {
      printf ("Deleted thread list has ");
      if (deleted_threads.count == 1)
	printf ("1 entry:\n");
      else
	printf ("%d entries:\n", deleted_threads.count);

      for (p = deleted_threads.head; p; p = p->next)
	{
	  print_tthread (p);
	}
d1204 2
a1205 2
  thread_info *p;
  thread_info *chase;
d1207 2
a1208 3
  chase = NULL;
  for (p = thread_head.head; p; p = p->next)
    {
d1216 4
a1219 4
       */
      if ((!p->seen) && p->am_pseudo && vfork_in_flight
	  && (p->pid != vforking_child_pid))
	p->seen = 1;
d1221 3
a1223 4
      if (!p->seen)
	{
	  /* Remove this one
	   */
d1226 2
a1227 2
	  if (debug_on)
	    printf ("Delete unseen thread: %d \n", p->tid);
d1229 2
a1230 2
	  del_tthread (p->tid);
	}
d1233 2
a1235 2


d1248 5
a1252 5
call_real_ttrace (request, pid, tid, addr, data, addr2)
     ttreq_t request;
     pid_t pid;
     lwpid_t tid;
     TTRACE_ARG_TYPE addr, data, addr2;
d1254 1
a1254 1
  int tt_status;
d1257 1
a1257 1
  tt_status = ttrace (request, pid, tid, addr, data, addr2);
d1260 14
a1273 17
  if (errno)
    {
      /* Don't bother for a known benign error: if you ask for the
       * first thread state, but there is only one thread and it's
       * not stopped, ttrace complains.
       *
       * We have this inside the #ifdef because our caller will do
       * this check for real.
       */
      if (request != TT_PROC_GET_FIRST_LWP_STATE
	  || errno != EPROTO)
	{
	  if (debug_on)
	    printf ("TT fail for %s, with pid %d, tid %d, status %d \n",
		    get_printable_name_of_ttrace_request (request),
		    pid, tid, tt_status);
	}
d1275 1
d1283 7
a1289 8
  if (errno)
    {
      strcpy (reason_for_failure, "ttrace (");
      strcat (reason_for_failure, get_printable_name_of_ttrace_request (request));
      strcat (reason_for_failure, ")");
      printf ("ttrace error, errno = %d\n", errno);
      perror_with_name (reason_for_failure);
    }
d1294 1
a1295 1

d1302 6
a1307 6
call_real_ttrace_wait (pid, tid, option, tsp, tsp_size)
     int pid;
     lwpid_t tid;
     ttwopt_t option;
     ttstate_t *tsp;
     size_t tsp_size;
d1309 2
a1310 2
  int ttw_status;
  thread_info *tinfo = NULL;
d1314 2
a1315 3

  if (errno)
    {
d1317 2
a1318 2
      if (debug_on)
	printf ("TW fail with pid %d, tid %d \n", pid, tid);
d1322 1
a1322 1
    }
d1326 1
a1327 1

d1337 2
a1338 2
     int pid;
     ttstate_t *thread_state;
d1340 1
a1340 1
  int tt_status;
d1343 18
a1360 23
				 TT_PROC_GET_FIRST_LWP_STATE,
				 (pid_t) pid,
				 (lwpid_t) TT_NIL,
				 (TTRACE_ARG_TYPE) thread_state,
				 (TTRACE_ARG_TYPE) sizeof (*thread_state),
				 TT_NIL);

  if (errno)
    {
      if (errno == EPROTO)
	{
	  /* This is an error we can handle: there isn't any stopped
	   * thread.  This happens when we're re-starting the application
	   * and it has only one thread.  GET_NEXT handles the case of
	   * no more stopped threads well; GET_FIRST doesn't.  (A ttrace
	   * "feature".)
	   */
	  tt_status = 1;
	  errno = 0;
	  return 0;
	}
      else
	perror_with_name ("ttrace");
d1362 5
a1366 2

  if (tt_status < 0)
d1373 1
a1374 1

d1386 2
a1387 2
     int pid;
     ttstate_t *thread_state;
d1389 1
a1389 1
  int tt_status;
d1392 6
a1397 6
				 TT_PROC_GET_NEXT_LWP_STATE,
				 (pid_t) pid,
				 (lwpid_t) TT_NIL,
				 (TTRACE_ARG_TYPE) thread_state,
				 (TTRACE_ARG_TYPE) sizeof (*thread_state),
				 TT_NIL);
d1406 9
a1414 10
  else if (tt_status == 0)
    {
      /* End of list, no next state.  Don't return the
       * tts_lwpid, as it's a meaningless "240".
       *
       * This is an HPUX "feature".
       */
      return 0;
    }

d1429 1
a1429 1
     int pid;
d1431 1
a1431 1
  ttstate_t thread_state;
d1441 1
a1441 1
     ttreq_t tt_request;
d1445 1
a1446 1

d1451 2
a1452 2
make_process_version (request)
     ttreq_t request;
d1454 4
a1457 5
  if (!IS_TTRACE_REQ (request))
    {
      error ("Internal error, bad ttrace request made\n");
      return -1;
    }
d1459 2
a1460 3
  switch (request)
    {
    case TT_LWP_STOP:
d1463 1
a1463 1
    case TT_LWP_CONTINUE:
d1466 1
a1466 1
    case TT_LWP_GET_EVENT_MASK:
d1469 1
a1469 1
    case TT_LWP_SET_EVENT_MASK:
d1472 5
a1476 5
    case TT_LWP_SINGLE:
    case TT_LWP_RUREGS:
    case TT_LWP_WUREGS:
    case TT_LWP_GET_STATE:
      return -1;		/* No equivalent */
d1478 1
a1478 1
    default:
d1480 1
a1480 1
    }
d1482 1
a1483 1

d1494 11
a1504 11
call_ttrace (request, gdb_tid, addr, data, addr2)
     ttreq_t request;
     int gdb_tid;
     TTRACE_ARG_TYPE addr, data, addr2;
{
  lwpid_t real_tid;
  int real_pid;
  ttreq_t new_request;
  int tt_status;
  char reason_for_failure[100];	/* Arbitrary size, should be big enough. */

d1506 1
a1506 1
  int is_interesting = 0;
d1508 14
a1521 18
  if (TT_LWP_RUREGS == request)
    {
      is_interesting = 1;	/* Adjust code here as desired */
    }

  if (is_interesting && 0 && debug_on)
    {
      if (!is_process_ttrace_request (request))
	{
	  printf ("TT: Thread request, tid is %d", gdb_tid);
	  printf ("== SINGLE at %x", addr);
	}
      else
	{
	  printf ("TT: Process request, tid is %d\n", gdb_tid);
	  printf ("==! SINGLE at %x", addr);
	}
    }
d1532 2
a1533 2
  if (request == TT_PROC_SETTRC && debug_on)
    printf ("Unexpected call for TT_PROC_SETTRC\n");
d1540 1
a1540 1
  if (gdb_tid == 0)
d1542 1
a1542 1
      errno = ESRCH;		/* ttrace's response would probably be "No such process". */
d1549 1
a1549 2
  if (!any_thread_records ())
    {
d1551 2
a1552 2
      if (debug_on)
	warning ("No thread records for ttrace call");
d1554 1
a1554 1
      errno = ESRCH;		/* ttrace's response would be "No such process". */
d1556 1
a1556 1
    }
d1561 2
a1562 2
  real_tid = map_from_gdb_tid (gdb_tid);
  real_pid = get_pid_for (real_tid);
d1568 2
a1569 26
  if (0 == real_pid)
    {
      ttstate_t thread_state;

#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("No saved pid for tid %d\n", gdb_tid);
#endif

      if (is_process_ttrace_request (request))
	{

	  /* Ok, we couldn't get a tid.  Try to translate to
	   * the equivalent process operation.  We expect this
	   * NOT to happen, so this is a desparation-type
	   * move.  It can happen if there is an internal
	   * error and so no "wait()" call is ever done.
	   */
	  new_request = make_process_version (request);
	  if (new_request == -1)
	    {

#ifdef THREAD_DEBUG
	      if (debug_on)
		printf ("...and couldn't make process version of thread operation\n");
#endif
a1570 6
	      /* Use hacky saved pid, which won't always be correct
	       * in the multi-process future.  Use tid as thread,
	       * probably dooming this to failure.  FIX!
	       */
	      if (saved_real_pid != 0)
		{
d1572 2
a1573 35
		  if (debug_on)
		    printf ("...using saved pid %d\n", saved_real_pid);
#endif

		  real_pid = saved_real_pid;
		  real_tid = gdb_tid;
		}

	      else
		error ("Unable to perform thread operation");
	    }

	  else
	    {
	      /* Sucessfully translated this to a process request,
	       * which needs no thread value.
	       */
	      real_pid = gdb_tid;
	      real_tid = 0;
	      request = new_request;

#ifdef THREAD_DEBUG
	      if (debug_on)
		{
		  printf ("Translated thread request to process request\n");
		  if (saved_real_pid == 0)
		    printf ("...but there's no saved pid\n");

		  else
		    {
		      if (gdb_tid != saved_real_pid)
			printf ("...but have the wrong pid (%d rather than %d)\n",
				gdb_tid, saved_real_pid);
		    }
		}
a1574 2
	    }			/* Translated to a process request */
	}			/* Is a process request */
d1576 63
a1638 7
      else
	{
	  /* We have to have a thread.  Ooops.
	   */
	  error ("Thread request with no threads (%s)",
		 get_printable_name_of_ttrace_request (request));
	}
d1640 1
d1645 1
a1645 2
  if (is_process_ttrace_request (request))
    {
d1647 2
a1648 2
    }

d1650 4
a1653 5
  if (is_interesting && 0 && debug_on)
    {
      printf ("    now tid %d, pid %d\n", real_tid, real_pid);
      printf ("    request is %s\n", get_printable_name_of_ttrace_request (request));
    }
d1661 5
a1665 6
  if (is_interesting && debug_on)
    {
      if (!TT_OK (tt_status, errno)
	  && !(tt_status == 0 & errno == 0))
	printf (" got error (errno==%d, status==%d)\n", errno, tt_status);
    }
d1673 1
a1673 1

d1679 2
a1680 2
stop_all_threads_of_process (real_pid)
     pid_t real_pid;
d1682 1
a1682 1
  int ttw_status;
d1685 5
a1689 5
				 (pid_t) real_pid,
				 (lwpid_t) TT_NIL,
				 (TTRACE_ARG_TYPE) TT_NIL,
				 (TTRACE_ARG_TYPE) TT_NIL,
				 TT_NIL);
d1709 1
a1709 1
 */
d1719 2
a1720 2
     int pid;
     ttevents_t stopping_event;
d1729 2
a1730 2
	   (PARENT_VFORKED (stopping_event, pid) ||
	    CHILD_URPED (stopping_event, pid)))
d1736 1
a1736 1
  return !vfork_in_flight;
d1747 1
a1747 1
static int
d1749 2
a1750 2
     int pid;
     ttstate_t *tsp;
d1752 2
a1753 2
  lwpid_t candidate_tid, tid;
  ttstate_t candidate_tstate, tstate;
d1761 1
a1761 1
  if (!can_touch_threads_of_process (pid, tsp->tts_event))
d1777 3
a1779 4
      if (tstate.tts_event == TTEVT_NONE)
	{
	  set_handled (pid, tstate.tts_lwpid);
	}
d1790 1
a1790 1
	{
d1792 17
a1808 17
	  /* It's possible here to see either a SIGTRAP (due to
	   * successful completion of a step) or a SYSCALL_ENTRY
	   * (due to a step completion with active hardware
	   * watchpoints).
	   */
	  if (debug_on)
	    printf ("Ending fake step with tid %d, state %s\n",
		    tstate.tts_lwpid,
		    get_printable_name_of_ttrace_event (tstate.tts_event));
#endif

	  /* Remember this one, and throw away any previous
	   * candidate.
	   */
	  candidate_tid = tstate.tts_lwpid;
	  candidate_tstate = tstate;
	}
d1826 9
a1834 10
      else if ((TTEVT_SIGNAL == tstate.tts_event)
	       && (5 == tstate.tts_u.tts_signal.tts_signo)
	       && (0 != get_raw_pc (tstate.tts_lwpid))
	       && !breakpoint_here_p (get_raw_pc (tstate.tts_lwpid)))
	{
	  /*
	   * If the user deleted a breakpoint while this
	   * breakpoint-hit event was buffered, we can forget
	   * it now.
	   */
d1836 4
a1839 4
	  if (debug_on)
	    printf ("Forgetting deleted bp hit for thread %d\n",
		    tstate.tts_lwpid);
#endif
d1841 2
a1842 2
	  set_handled (pid, tstate.tts_lwpid);
	}
d1849 4
a1852 5
      else if (!was_handled (tstate.tts_lwpid) && candidate_tid == 0)
	{
	  candidate_tid = tstate.tts_lwpid;
	  candidate_tstate = tstate;
	}
d1862 12
a1873 16
  if (doing_fake_step)
    {
      if (candidate_tid == fake_step_tid)
	{
	  /* Fake step.
	   */
	  tstate = candidate_tstate;
	}
      else
	{
	  warning ("Internal error: fake-step failed to complete.");
	  return 0;
	}
    }
  else if (candidate_tid != 0)
    {
d1877 3
a1879 4
    }
  else if (tid != 0)
    {
      warning ("Internal error in call of ttrace_wait.");
d1881 2
a1882 3
    }
  else
    {
d1885 1
a1885 1
    }
d1889 1
a1889 1
}				/* End of select_stopped_thread_of_process */
d1895 2
a1896 2
check_thread_consistency (real_pid)
     pid_t real_pid;
d1898 3
a1900 3
  int tid;			/* really lwpid_t */
  ttstate_t tstate;
  thread_info *p;
d1902 22
a1923 26
  /* Spin down the O/S list of threads, checking that they
   * match what we've got.
   */
  for (tid = get_process_first_stopped_thread_id (real_pid, &tstate);
       tid != 0;
       tid = get_process_next_stopped_thread_id (real_pid, &tstate))
    {

      p = find_thread_info (tid);

      if (NULL == p)
	{
	  warning ("No internal thread data for thread %d.", tid);
	  continue;
	}

      if (!p->seen)
	{
	  warning ("Inconsistent internal thread data for thread %d.", tid);
	}

      if (p->terminated)
	{
	  warning ("Thread %d is not terminated, internal error.", tid);
	  continue;
	}
d1928 13
a1940 15

      if (p->have_state)
	{
	  if (TT_COMPARE (tts_pid)
	      || TT_COMPARE (tts_lwpid)
	      || TT_COMPARE (tts_user_tid)
	      || TT_COMPARE (tts_event)
	      || TT_COMPARE (tts_flags)
	      || TT_COMPARE (tts_scno)
	      || TT_COMPARE (tts_scnargs))
	    {
	      warning ("Internal thread data for thread %d is wrong.", tid);
	      continue;
	    }
	}
d1943 2
a1944 1
#endif /* PARANOIA */
a1945 1

d1956 5
a1960 5
call_ttrace_wait (pid, option, tsp, tsp_size)
     int pid;
     ttwopt_t option;
     ttstate_t *tsp;
     size_t tsp_size;
d1970 3
a1972 3
  int wait_pid = 0;
  lwpid_t wait_tid = 0;
  lwpid_t real_tid;
d1974 1
a1974 1
  int ttw_status = 0;		/* To be returned */
d1976 1
a1976 1
  thread_info *tinfo = NULL;
d1978 1
a1978 2
  if (pid != 0)
    {
d1982 2
a1983 2
      if (debug_on)
	printf ("TW: Pid to wait on is %d\n", pid);
d1986 2
a1987 2
      if (!any_thread_records ())
	error ("No thread records for ttrace call w. specific pid");
d1992 2
a1993 2
      real_tid = map_from_gdb_tid (pid);
      real_pid = get_pid_for (real_tid);
d1995 2
a1996 2
      if (debug_on)
	printf ("==TW: real pid %d, real tid %d\n", real_pid, real_tid);
d1998 1
a1998 1
    }
d2012 1
a2012 2
  if (more_events_left == 0)
    {
d2014 26
a2039 31
      if (process_state == RUNNING)
	{
	  /* OK--normal call of ttrace_wait with no buffered events.
	   */
	  ;
	}
      else if (process_state == FAKE_STEPPING)
	{
	  /* Ok--call of ttrace_wait to support
	   * fake stepping with no buffered events.
	   *
	   * But we better be fake-stepping!
	   */
	  if (!doing_fake_step)
	    {
	      warning ("Inconsistent thread state.");
	    }
	}
      else if ((process_state == FORKING)
	       || (process_state == VFORKING))
	{
	  /* Ok--there are two processes, so waiting
	   * for the second while the first is stopped
	   * is ok.  Handled bits stay as they were.
	   */
	  ;
	}
      else if (process_state == STOPPED)
	{
	  warning ("Process not running at wait call.");
	}
d2041 6
a2046 7
	/* No known state.
	 */
	warning ("Inconsistent process state.");
    }

  else
    {
d2049 27
a2075 32
      if (process_state == STOPPED)
	{
	  /* OK--buffered events being unbuffered.
	   */
	  ;
	}
      else if (process_state == RUNNING)
	{
	  /* An error--shouldn't have buffered events
	   * when running.
	   */
	  warning ("Trying to continue with buffered events:");
	}
      else if (process_state == FAKE_STEPPING)
	{
	  /*
	   * Better be fake-stepping!
	   */
	  if (!doing_fake_step)
	    {
	      warning ("Losing buffered thread events!\n");
	    }
	}
      else if ((process_state == FORKING)
	       || (process_state == VFORKING))
	{
	  /* Ok--there are two processes, so waiting
	   * for the second while the first is stopped
	   * is ok.  Handled bits stay as they were.
	   */
	  ;
	}
d2077 2
a2078 2
	warning ("Process in unknown state with buffered events.");
    }
d2087 1
a2087 2
  if (doing_fake_step)
    {
d2089 1
a2089 1
      wait_pid = get_pid_for (fake_step_tid);
d2092 3
a2094 3
      if (debug_on)
	printf ("Doing a wait after a fake-step for %d, pid %d\n",
		wait_tid, wait_pid);
d2096 1
a2096 1
    }
d2098 2
a2099 3
  if (more_events_left == 0	/* No buffered events, need real ones. */
      || process_state != STOPPED)
    {
d2108 2
a2109 2
      if (debug_on)
	printf ("TW: do it for real; pid %d, tid %d\n", wait_pid, wait_tid);
d2114 1
a2114 1
      ttw_status = call_real_ttrace_wait (wait_pid, wait_tid, option, tsp, tsp_size);
d2123 1
a2123 1

d2129 24
a2152 25
	{
	  /* If we're really only stepping a single thread, then don't
	   * try to stop all the others -- we only do this single-stepping
	   * business when all others were already stopped...and the stop
	   * would mess up other threads' events.
	   *
	   * Similiarly, if there are other threads with events,
	   * don't do the stop.
	   */
	  if (!doing_fake_step)
	    {
	      if (more_events_left > 0)
		warning ("Internal error in stopping process");

	      stop_all_threads_of_process (real_pid);

	      /* At this point, we could scan and update_thread_list(),
	       * and only use the local list for the rest of the
	       * module! We'd get rid of the scans in the various
	       * continue routines (adding one in attach).  It'd
	       * be great--UPGRADE ME!
	       */
	    }
	}

d2154 6
a2159 7
      else if (debug_on)
	{
	  if (more_events_left > 0)
	    printf ("== Can't stop process; more events!\n");
	  else
	    printf ("== Can't stop process!\n");
	}
d2162 1
a2162 1
      process_state = STOPPED;
d2165 2
a2166 2
      if (debug_on)
	printf ("Process set to STOPPED\n");
d2168 3
a2170 4
    }

  else
    {
d2175 2
a2176 2
      if (debug_on)
	printf ("TW: fake it\n");
d2179 7
a2185 8
      if (process_state != STOPPED)
	{
	  warning ("Process not stopped at wait call, in state '%s'.\n",
		   get_printable_name_of_process_state (process_state));
	}

      if (doing_fake_step)
	error ("Internal error in stepping over breakpoint");
d2187 2
a2188 2
      ttw_status = 0;		/* Faking it is always successful! */
    }				/* End of fake or not? if */
d2192 2
a2193 5
  if (!select_stopped_thread_of_process (real_pid, tsp))
    warning ("Can't find event, using previous event.");

  else if (tsp->tts_event == TTEVT_NONE)
    warning ("Internal error: no thread has a real event.");
d2195 2
a2196 4
  else if (doing_fake_step)
    {
      if (fake_step_tid != tsp->tts_lwpid)
	warning ("Internal error in stepping over breakpoint.");
d2198 4
d2205 2
a2206 2
      fake_step_tid = 0;
    }
d2212 1
a2212 1
  set_handled (real_pid, tsp->tts_lwpid);
d2226 5
a2230 6
  if (tinfo != NULL)
    {
      copy_ttstate_t (&tinfo->last_stop_state, tsp);
      tinfo->have_state = 1;
    }

d2232 1
a2232 1
}				/* call_ttrace_wait */
d2238 1
a2238 1
  return 1;			/* ttrace reports the event once per call. */
a2240 1

d2243 1
d2261 8
a2268 10
 */
typedef struct memory_page
{
  CORE_ADDR page_start;
  int reference_count;
  int original_permissions;
  struct memory_page *next;
  struct memory_page *previous;
}
memory_page_t;
d2272 7
a2278 9
static struct
  {
    LONGEST page_count;
    int page_size;
    int page_protections_allowed;
    /* These are just the heads of chains of actual page descriptors. */
    memory_page_t buckets[MEMORY_PAGE_DICTIONARY_BUCKET_COUNT];
  }
memory_page_dictionary;
d2284 1
a2284 1
  int i;
d2293 1
a2293 1
  for (i = 0; i < MEMORY_PAGE_DICTIONARY_BUCKET_COUNT; i++)
d2306 1
a2306 1
  memory_page_dictionary.page_count = (LONGEST) - 1;
d2316 2
a2317 2
     int pid;
     CORE_ADDR page_start;
d2319 3
a2321 3
  int tt_status;
  int original_permissions;
  int new_permissions;
d2324 4
a2327 4
			   pid,
			   (TTRACE_ARG_TYPE) page_start,
			   TT_NIL,
			   (TTRACE_ARG_TYPE) & original_permissions);
d2330 1
a2330 1
      return 0;			/* What else can we do? */
d2338 4
a2341 4
			       pid,
			       (TTRACE_ARG_TYPE) page_start,
			 (TTRACE_ARG_TYPE) memory_page_dictionary.page_size,
			       (TTRACE_ARG_TYPE) new_permissions);
d2343 3
a2345 3
	{
	  return 0;		/* What else can we do? */
	}
d2354 1
a2354 1
 */
d2357 3
a2359 3
     int pid;
     CORE_ADDR page_start;
     int original_permissions;
d2361 1
a2361 1
  int tt_status;
d2364 4
a2367 4
			   pid,
			   (TTRACE_ARG_TYPE) page_start,
			 (TTRACE_ARG_TYPE) memory_page_dictionary.page_size,
			   (TTRACE_ARG_TYPE) original_permissions);
d2370 1
a2370 1
      return;			/* What else can we do? */
d2380 1
a2380 1
 */
d2383 1
a2383 1
     int pid;
d2385 1
a2385 1
  int bucket;
d2389 1
a2389 1
  for (bucket = 0; bucket < MEMORY_PAGE_DICTIONARY_BUCKET_COUNT; bucket++)
d2391 1
a2391 1
      memory_page_t *page;
d2395 4
a2398 4
	{
	  page->original_permissions = write_protect_page (pid, page->page_start);
	  page = page->next;
	}
d2408 1
a2408 1
 */
d2411 1
a2411 1
     int pid;
d2413 1
a2413 1
  int bucket;
d2415 1
a2415 1
  for (bucket = 0; bucket < MEMORY_PAGE_DICTIONARY_BUCKET_COUNT; bucket++)
d2417 1
a2417 1
      memory_page_t *page;
d2421 4
a2424 4
	{
	  unwrite_protect_page (pid, page->page_start, page->original_permissions);
	  page = page->next;
	}
d2438 8
a2445 8
count_unhandled_events (real_pid, real_tid)
     int real_pid;
     lwpid_t real_tid;
{
  ttstate_t tstate;
  lwpid_t ttid;
  int events_left;

d2449 1
a2449 1
  ttid = get_process_first_stopped_thread_id (real_pid, &tstate);
d2452 3
a2454 4
  if (debug_on)
    {
      if (ttid == 0)
	printf ("Process %d has no threads\n", real_pid);
d2456 2
a2457 2
	printf ("Process %d has these threads:\n", real_pid);
    }
d2460 17
a2476 19
  while (ttid > 0)
    {
      if (tstate.tts_event != TTEVT_NONE
	  && !was_handled (ttid))
	{
	  /* TTEVT_NONE implies we just stopped it ourselves
	   * because we're the stop-the-world guys, so it's
	   * not an event from our point of view.
	   *
	   * If "was_handled" is true, this is an event we
	   * already handled, so don't count it.
	   *
	   * Note that we don't count the thread with the
	   * currently-reported event, as it's already marked
	   * as handled.
	   */
	  events_left++;
	}

d2478 10
a2487 16
      if (debug_on)
	{
	  if (ttid == real_tid)
	    printf ("*");	/* Thread we're reporting */
	  else
	    printf (" ");

	  if (tstate.tts_event != TTEVT_NONE)
	    printf ("+");	/* Thread with a real event */
	  else
	    printf (" ");

	  if (was_handled (ttid))
	    printf ("h");	/* Thread has been handled */
	  else
	    printf (" ");
d2489 22
a2510 18
	  printf (" %d, with event %s", ttid,
		  get_printable_name_of_ttrace_event (tstate.tts_event));

	  if (tstate.tts_event == TTEVT_SIGNAL
	      && 5 == tstate.tts_u.tts_signal.tts_signo)
	    {
	      CORE_ADDR pc_val;

	      pc_val = get_raw_pc (ttid);

	      if (pc_val > 0)
		printf (" breakpoint at 0x%x\n", pc_val);
	      else
		printf (" bpt, can't fetch pc.\n");
	    }
	  else
	    printf ("\n");
	}
d2514 1
a2514 1
    }
d2517 3
a2519 3
  if (debug_on)
    if (events_left > 0)
      printf ("There are thus %d pending events\n", events_left);
d2534 2
a2535 2
     int pid;
     int *status;
d2537 6
a2542 6
  ttstate_t tsp;
  int ttwait_return;
  int real_pid;
  ttstate_t state;
  lwpid_t real_tid;
  int return_pid;
d2548 1
a2548 1
  ttwait_return = call_ttrace_wait (0, TTRACE_WAITOK, &tsp, sizeof (tsp));
d2555 1
a2555 1
       */
d2557 4
a2560 4
	{
	  *status = 0;		/* WIFEXITED */
	  return inferior_pid;
	}
d2562 2
a2563 2
      warning ("Call of ttrace_wait returned with errno %d.",
	       errno);
d2576 1
a2576 22
  if (tsp.tts_event & TTEVT_LWP_CREATE)
    {

      /* Unlike what you might expect, this event is reported in
       * the _creating_ thread, and the _created_ thread (whose tid
       * we have) is still running.  So we have to stop it.  This
       * has already been done in "call_ttrace_wait", but should we
       * ever abandon the "stop-the-world" model, here's the command
       * to use:
       *
       *    call_ttrace( TT_LWP_STOP, real_tid, TT_NIL, TT_NIL, TT_NIL );
       *
       * Note that this would depend on being called _after_ "add_tthread"
       * below for the tid-to-pid translation to be done in "call_ttrace".
       */

#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("New thread: pid %d, tid %d, creator tid %d\n",
		real_pid, tsp.tts_u.tts_thread.tts_target_lwpid,
		real_tid);
#endif
d2578 25
a2602 5
      /* Now we have to return the tid of the created thread, not
       * the creating thread, or "wait_for_inferior" won't know we
       * have a new "process" (thread).  Plus we should record it
       * right, too.
       */
d2605 2
a2606 2
      add_tthread (real_pid, real_tid);
    }
d2608 2
a2609 3
  else if ((tsp.tts_event & TTEVT_LWP_TERMINATE)
	   || (tsp.tts_event & TTEVT_LWP_EXIT))
    {
d2612 2
a2613 2
      if (debug_on)
	printf ("Thread dies: %d\n", real_tid);
d2616 2
a2617 2
      del_tthread (real_tid);
    }
d2619 1
a2619 2
  else if (tsp.tts_event & TTEVT_EXEC)
    {
d2621 4
a2624 4
#ifdef THREAD_DEBUG
      if (debug_on)
	printf ("Pid %d has zero'th thread %d; inferior pid is %d\n",
		real_pid, real_tid, inferior_pid);
d2627 2
a2628 2
      add_tthread (real_pid, real_tid);
    }
d2631 12
a2642 13
  else if (debug_on)
    {
      printf ("Process-level event %s, using tid %d\n",
	      get_printable_name_of_ttrace_event (tsp.tts_event),
	      real_tid);

      /* OK to do this, as "add_tthread" won't add
       * duplicate entries.  Also OK not to do it,
       * as this event isn't one which can change the
       * thread state.
       */
      add_tthread (real_pid, real_tid);
    }
d2654 7
a2660 8
    more_events_left = count_unhandled_events (real_pid, real_tid);

  else
    {
      if (more_events_left > 0)
	warning ("Vfork or fork causing loss of %d buffered events.",
		 more_events_left);

d2662 1
a2662 1
    }
d2670 2
a2671 2
   */
  if ((tsp.tts_event & TTEVT_EXEC)
d2679 3
a2681 3
	{
	  process_state = FORKING;

d2683 2
a2684 2
	  if (debug_on)
	    printf ("Process set to FORKING\n");
d2686 1
a2686 1
	}
d2688 3
a2690 3
	{
	  process_state = VFORKING;

d2692 2
a2693 2
	  if (debug_on)
	    printf ("Process set to VFORKING\n");
d2695 1
a2695 1
	}
d2701 1
a2701 1
       */
d2704 2
a2705 2
      if (debug_on)
	printf ("..a process 'event'\n");
d2709 1
a2709 1
       */
d2741 1
a2741 1
	   || (tsp.tts_event & TTEVT_SYSCALL_RETURN))
d2745 1
a2745 1
       */
d2747 2
a2748 2
      if (debug_on)
	printf ("..a syscall 'event'\n");
d2752 1
a2752 1
       */
d2757 2
a2758 2
	   || (tsp.tts_event & TTEVT_LWP_TERMINATE)
	   || (tsp.tts_event & TTEVT_LWP_EXIT))
d2764 2
a2765 2
      if (debug_on)
	printf ("..a thread 'event'\n");
d2769 1
a2769 1
       */
d2772 1
a2772 1

d2774 2
a2775 2
    {				/* WIFEXITED */

d2777 2
a2778 2
      if (debug_on)
	printf ("..an exit\n");
d2785 2
a2786 2
      inferior_pid = map_to_gdb_tid (real_tid);		/* HACK, FIX */

d2789 1
a2789 1

d2791 1
a2791 1
    {				/* WIFSTOPPED */
d2793 2
a2794 2
      if (debug_on)
	printf ("..a signal, %d\n", tsp.tts_u.tts_signal.tts_signo);
d2801 1
a2801 1
    {				/* !WIFSTOPPED */
d2812 4
a2815 4
      if (debug_on)
	printf ("Process-level event %s, using tid %d\n",
		get_printable_name_of_ttrace_event (tsp.tts_event),
		real_tid);
d2825 2
a2826 2
  if (debug_on)
    printf ("Done waiting, pid is %d, tid %d\n", real_pid, real_tid);
d2834 1
a2834 1
  return_pid = map_to_gdb_tid (real_tid);
d2838 1
a2838 1
  old_gdb_pid = inferior_pid;
d2842 4
a2845 5
  if (real_tid == 0 || return_pid == 0)
    {
      warning ("Internal error: process-wait failed.");
    }

d2848 1
a2849 1

d2873 1
a2873 1
  int tt_status;
d2880 2
a2881 2
  uint64_t tc_magic_child = TT_VERSION;
  uint64_t tc_magic_parent = 0;
d2884 6
a2889 6
				 TT_PROC_SETTRC,
				 (int) TT_NIL,
				 (lwpid_t) TT_NIL,
				 TT_NIL,
				 (TTRACE_ARG_TYPE) TT_VERSION,
				 TT_NIL);
d2896 2
a2897 2
	 &tc_magic_child,
	 sizeof (tc_magic_child));
d2901 3
a2903 3
	&tc_magic_parent,
	sizeof (tc_magic_parent));

d2912 1
a2912 1

d2930 2
a2931 2
require_notification_of_events (real_pid)
     int real_pid;
d2933 2
a2934 2
  int tt_status;
  ttevent_t notifiable_events;
d2936 2
a2937 2
  lwpid_t tid;
  ttstate_t thread_state;
d2940 2
a2941 2
  if (debug_on)
    printf ("Require notif, pid is %d\n", real_pid);
d2961 1
a2961 1
  notifiable_events.tte_events = TTEVT_DEFAULT;
d2972 6
a2977 6
				 TT_PROC_SET_EVENT_MASK,
				 real_pid,
				 (lwpid_t) TT_NIL,
				 (TTRACE_ARG_TYPE) & notifiable_events,
			       (TTRACE_ARG_TYPE) sizeof (notifiable_events),
				 TT_NIL);
d2981 2
a2982 2
require_notification_of_exec_events (real_pid)
     int real_pid;
d2984 2
a2985 2
  int tt_status;
  ttevent_t notifiable_events;
d2987 2
a2988 2
  lwpid_t tid;
  ttstate_t thread_state;
d2991 2
a2992 2
  if (debug_on)
    printf ("Require notif, pid is %d\n", real_pid);
d3008 1
a3008 1
  notifiable_events.tte_events = TTEVT_DEFAULT;
d3013 6
a3018 6
				 TT_PROC_SET_EVENT_MASK,
				 real_pid,
				 (lwpid_t) TT_NIL,
				 (TTRACE_ARG_TYPE) & notifiable_events,
			       (TTRACE_ARG_TYPE) sizeof (notifiable_events),
				 TT_NIL);
d3020 1
a3021 1

d3027 1
a3027 1
     int pid;
d3033 3
a3035 3
   */
  uint64_t tc_magic_parent = TT_VERSION;
  uint64_t tc_magic_child = 0;
d3039 2
a3040 2
	&tc_magic_child,
	sizeof (tc_magic_child));
d3045 1
a3045 1
  clear_thread_info ();
d3058 1
a3058 1
  add_thread (pid);		/* in thread.c */
d3070 2
a3071 2
	 &tc_magic_parent,
	 sizeof (tc_magic_parent));
d3086 2
a3087 2
child_post_startup_inferior (real_pid)
     int real_pid;
d3096 1
a3096 1
     int tid;
d3098 2
a3099 2
  int tt_status;
  ttevent_t ttrace_events;
d3104 4
a3107 4
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
d3115 2
a3116 2
  if (debug_on)
    printf ("enable fork, tid is %d\n", tid);
d3120 4
a3123 4
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
d3131 1
a3131 1
     int tid;
d3133 2
a3134 2
  int tt_status;
  ttevent_t ttrace_events;
d3139 4
a3142 4
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
d3151 2
a3152 2
  if (debug_on)
    printf ("disable fork, tid is %d\n", tid);
d3156 4
a3159 4
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
d3169 1
a3169 1
     int tid;
d3174 1
a3174 1
   */
d3183 1
a3183 1
     int tid;
d3188 1
a3188 1
   */
d3196 1
a3196 1
     int tid;
d3198 2
a3199 2
  int tt_status;
  ttevent_t ttrace_events;
d3204 4
a3207 4
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
d3216 2
a3217 2
  if (debug_on)
    printf ("enable vfork, tid is %d\n", tid);
d3221 4
a3224 4
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
d3233 1
a3233 1
     int tid;
d3235 2
a3236 2
  int tt_status;
  ttevent_t ttrace_events;
d3240 4
a3243 4
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
d3252 2
a3253 2
  if (debug_on)
    printf ("disable vfork, tid is %d\n", tid);
d3256 4
a3259 4
			   tid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
d3269 1
a3269 1
     int tid;
d3274 1
a3274 1
   */
d3283 1
a3283 1
     int tid;
d3288 1
a3288 1
   */
d3296 1
a3296 1

d3303 2
a3304 2
     int tid;
     int *childpid;
d3306 3
a3308 3
  int tt_status;
  ttstate_t ttrace_state;
  thread_info *tinfo;
d3312 3
a3314 4
  if (tinfo != NULL)
    {
      copy_ttstate_t (&ttrace_state, &tinfo->last_stop_state);
    }
d3320 4
a3323 4
			       tid,
			       (TTRACE_ARG_TYPE) & ttrace_state,
			       (TTRACE_ARG_TYPE) sizeof (ttrace_state),
			       TT_NIL);
d3326 2
a3327 2
	perror_with_name ("ttrace");

d3329 1
a3329 1
	return 0;
d3349 2
a3350 2
     int tid;
     int *childpid;
d3352 3
a3354 3
  int tt_status;
  ttstate_t ttrace_state;
  thread_info *tinfo;
d3365 4
a3368 4
			       tid,
			       (TTRACE_ARG_TYPE) & ttrace_state,
			       (TTRACE_ARG_TYPE) sizeof (ttrace_state),
			       TT_NIL);
d3371 2
a3372 2
	perror_with_name ("ttrace");

d3374 1
a3374 1
	return 0;
d3397 1
a3397 1
   */
d3406 1
a3406 1
     int tid;
d3411 1
a3411 1
   */
d3420 1
a3420 1
     int tid;
d3425 1
a3425 1
   */
d3434 2
a3435 2
     int tid;
     char **execd_pathname;
d3437 3
a3439 3
  int tt_status;
  ttstate_t ttrace_state;
  thread_info *tinfo;
d3450 4
a3453 4
			       tid,
			       (TTRACE_ARG_TYPE) & ttrace_state,
			       (TTRACE_ARG_TYPE) sizeof (ttrace_state),
			       TT_NIL);
d3456 2
a3457 2
	perror_with_name ("ttrace");

d3459 1
a3459 1
	return 0;
d3466 2
a3467 2
      char *exec_file = target_pid_to_exec_file (tid);

d3480 7
a3486 7
     int pid;
     enum target_waitkind *kind;
     int *syscall_id;
{
  int tt_status;
  ttstate_t ttrace_state;
  thread_info *tinfo;
d3496 5
a3500 5
      tt_status = call_ttrace (TT_LWP_GET_STATE,
			       pid,
			       (TTRACE_ARG_TYPE) & ttrace_state,
			       (TTRACE_ARG_TYPE) sizeof (ttrace_state),
			       TT_NIL);
d3503 2
a3504 2
	perror_with_name ("ttrace");

d3506 1
a3506 1
	return 0;
d3509 1
a3509 1
  *kind = TARGET_WAITKIND_SPURIOUS;	/* Until proven otherwise... */
a3522 1

d3525 1
d3529 1
a3529 1

d3540 1
a3540 1
  lwpid_t tid;
d3542 5
a3546 5
  /* This spins down the lists twice.
   * Possible peformance improvement here!
   */
  tid = map_from_gdb_tid (gdb_tid);
  return !is_terminated (tid);
a3549 1

d3552 1
d3562 1
a3562 1
 */
d3565 4
a3568 4
     int tid;
     TTRACE_ARG_TYPE ss_offset;
     char *buf;
     int sizeof_buf;
d3570 2
a3571 2
  int tt_status;
  register_value_t register_value = 0;
d3574 11
a3584 11
			   tid,
			   ss_offset,
			   (TTRACE_ARG_TYPE) sizeof_buf,
			   (TTRACE_ARG_TYPE) buf);

  if (tt_status == 1)
    /* Map ttrace's version of success to our version.
     * Sometime ttrace returns 0, but that's ok here.
     */
    return 0;

d3587 1
a3588 1

d3597 1
a3597 1
 */
d3600 4
a3603 4
     int tid;
     TTRACE_ARG_TYPE ss_offset;
     char *buf;
     int sizeof_buf;
d3605 2
a3606 2
  int tt_status;
  register_value_t register_value = 0;
d3609 4
a3612 4
			   tid,
			   ss_offset,
			   (TTRACE_ARG_TYPE) sizeof_buf,
			   (TTRACE_ARG_TYPE) buf);
d3615 1
a3616 1

d3626 1
a3626 1
 */
d3629 12
a3640 12
     int pt_request;
     int gdb_tid;
     PTRACE_ARG3_TYPE addr;
     int data;
{
  ttreq_t tt_request;
  TTRACE_ARG_TYPE tt_addr = (TTRACE_ARG_TYPE) addr;
  TTRACE_ARG_TYPE tt_data = (TTRACE_ARG_TYPE) data;
  TTRACE_ARG_TYPE tt_addr2 = TT_NIL;
  int tt_status;
  register_value_t register_value;
  int read_buf;
d3646 1
a3646 2
  switch (pt_request)
    {
d3653 52
a3704 52
       */
    case PT_SETTRC:
      return parent_attach_all ();

    case PT_RUREGS:
      tt_status = read_from_register_save_state (gdb_tid,
						 tt_addr,
						 &register_value,
						 sizeof (register_value));
      if (tt_status < 0)
	return tt_status;
      return register_value;

    case PT_WUREGS:
      register_value = (int) tt_data;
      tt_status = write_to_register_save_state (gdb_tid,
						tt_addr,
						&register_value,
						sizeof (register_value));
      return tt_status;
      break;

    case PT_READ_I:
      tt_status = call_ttrace (TT_PROC_RDTEXT,	/* Implicit 4-byte xfer becomes block-xfer. */
			       gdb_tid,
			       tt_addr,
			       (TTRACE_ARG_TYPE) 4,
			       (TTRACE_ARG_TYPE) & read_buf);
      if (tt_status < 0)
	return tt_status;
      return read_buf;

    case PT_READ_D:
      tt_status = call_ttrace (TT_PROC_RDDATA,	/* Implicit 4-byte xfer becomes block-xfer. */
			       gdb_tid,
			       tt_addr,
			       (TTRACE_ARG_TYPE) 4,
			       (TTRACE_ARG_TYPE) & read_buf);
      if (tt_status < 0)
	return tt_status;
      return read_buf;

    case PT_ATTACH:
      tt_status = call_real_ttrace (TT_PROC_ATTACH,
				    map_from_gdb_tid (gdb_tid),
				    (lwpid_t) TT_NIL,
				    tt_addr,
				    (TTRACE_ARG_TYPE) TT_VERSION,
				    tt_addr2);
      if (tt_status < 0)
	return tt_status;
      return tt_status;
d3708 53
a3760 53
       */
    case PT_DETACH:
      tt_request = TT_PROC_DETACH;
      break;

    case PT_WRITE_I:
      tt_request = TT_PROC_WRTEXT;	/* Translates 4-byte xfer to block-xfer. */
      tt_data = 4;		/* This many bytes. */
      tt_addr2 = (TTRACE_ARG_TYPE) & data;	/* Address of xfer source. */
      break;

    case PT_WRITE_D:
      tt_request = TT_PROC_WRDATA;	/* Translates 4-byte xfer to block-xfer. */
      tt_data = 4;		/* This many bytes. */
      tt_addr2 = (TTRACE_ARG_TYPE) & data;	/* Address of xfer source. */
      break;

    case PT_RDTEXT:
      tt_request = TT_PROC_RDTEXT;
      break;

    case PT_RDDATA:
      tt_request = TT_PROC_RDDATA;
      break;

    case PT_WRTEXT:
      tt_request = TT_PROC_WRTEXT;
      break;

    case PT_WRDATA:
      tt_request = TT_PROC_WRDATA;
      break;

    case PT_CONTINUE:
      tt_request = TT_PROC_CONTINUE;
      break;

    case PT_STEP:
      tt_request = TT_LWP_SINGLE;	/* Should not be making this request? */
      break;

    case PT_KILL:
      tt_request = TT_PROC_EXIT;
      break;

    case PT_GET_PROCESS_PATHNAME:
      tt_request = TT_PROC_GET_PATHNAME;
      break;

    default:
      tt_request = pt_request;	/* Let ttrace be the one to complain. */
      break;
    }
d3763 4
a3766 4
		      gdb_tid,
		      tt_addr,
		      tt_data,
		      tt_addr2);
d3774 3
a3776 3
  int tid;
  int wait_status;
  thread_info *t;
d3778 1
a3778 1
  int para_count, i;
d3793 1
a3793 1
   */
d3795 2
a3796 2
  paranoia = (thread_info **) malloc (thread_head.count *
				      sizeof (thread_info *));
d3798 1
a3798 1

d3800 30
a3829 35
  while (t)
    {

      paranoia[para_count] = t;
      for (i = 0; i < para_count; i++)
	{
	  if (t->next == paranoia[i])
	    {
	      warning ("Bad data in gdb's thread data; repairing.");
	      t->next = 0;
	    }
	}
      para_count++;

      if (t->am_pseudo && (t->pid != inferior_pid))
	{
	  /* TT_PROC_STOP doesn't require a subsequent ttrace_wait, as it
	   * generates no event.
	   */
	  call_ttrace (TT_PROC_STOP,
		       t->pid,
		       TT_NIL,
		       TT_NIL,
		       TT_NIL);

	  call_ttrace (TT_PROC_DETACH,
		       t->pid,
		       TT_NIL,
		       (TTRACE_ARG_TYPE) TARGET_SIGNAL_0,
		       TT_NIL);
	}
      t = t->next;
    }

  free (paranoia);
d3831 2
d3834 4
a3837 4
	       inferior_pid,
	       TT_NIL,
	       TT_NIL,
	       TT_NIL);
d3839 1
a3839 1
  clear_thread_info ();
d3848 2
a3849 2
thread_dropping_event_check (p)
     thread_info *p;
d3851 28
a3878 33
  if (!p->handled)
    {
      /*
       * This seems to happen when we "next" over a
       * "fork()" while following the parent.  If it's
       * the FORK event, that's ok.  If it's a SIGNAL
       * in the unfollowed child, that's ok to--but
       * how can we know that's what's going on?
       *
       * FIXME!
       */
      if (p->have_state)
	{
	  if (p->last_stop_state.tts_event == TTEVT_FORK)
	    {
	      /* Ok */
	      ;
	    }
	  else if (p->last_stop_state.tts_event == TTEVT_SIGNAL)
	    {
	      /* Ok, close eyes and let it happen.
	       */
	      ;
	    }
	  else
	    {
	      /* This shouldn't happen--we're dropping a
	       * real event.
	       */
	      warning ("About to continue process %d, thread %d with unhandled event %s.",
		       p->pid, p->tid,
		       get_printable_name_of_ttrace_event (
					     p->last_stop_state.tts_event));
d3881 2
a3882 2
	      if (debug_on)
		print_tthread (p);
d3884 7
a3890 8
	    }
	}
      else
	{
	  /* No saved state, have to assume it failed.
	   */
	  warning ("About to continue process %d, thread %d with unhandled event.",
		   p->pid, p->tid);
d3892 2
a3893 2
	  if (debug_on)
	    print_tthread (p);
d3895 1
a3895 1
	}
d3897 2
a3898 2

}				/* thread_dropping_event_check */
d3904 11
a3914 11
threads_continue_all_but_one (gdb_tid, signal)
     lwpid_t gdb_tid;
     int signal;
{
  thread_info *p;
  int thread_signal;
  lwpid_t real_tid;
  lwpid_t scan_tid;
  ttstate_t state;
  int real_pid;

d3916 2
a3917 2
  if (debug_on)
    printf ("Using loop over threads to step/resume with signals\n");
d3920 48
a3967 51
  /* First update the thread list.
   */
  set_all_unseen ();
  real_tid = map_from_gdb_tid (gdb_tid);
  real_pid = get_pid_for (real_tid);

  scan_tid = get_process_first_stopped_thread_id (real_pid, &state);
  while (0 != scan_tid)
    {

#ifdef THREAD_DEBUG
      /* FIX: later should check state is stopped;
       * state.tts_flags & TTS_STATEMASK == TTS_WASSUSPENDED
       */
      if (debug_on)
	if (state.tts_flags & TTS_STATEMASK != TTS_WASSUSPENDED)
	  printf ("About to continue non-stopped thread %d\n", scan_tid);
#endif

      p = find_thread_info (scan_tid);
      if (NULL == p)
	{
	  add_tthread (real_pid, scan_tid);
	  p = find_thread_info (scan_tid);

	  /* This is either a newly-created thread or the
	   * result of a fork; in either case there's no
	   * actual event to worry about.
	   */
	  p->handled = 1;

	  if (state.tts_event != TTEVT_NONE)
	    {
	      /* Oops, do need to worry!
	       */
	      warning ("Unexpected thread with \"%s\" event.",
		       get_printable_name_of_ttrace_event (state.tts_event));
	    }
	}
      else if (scan_tid != p->tid)
	error ("Bad data in thread database.");

#ifdef THREAD_DEBUG
      if (debug_on)
	if (p->terminated)
	  printf ("Why are we continuing a dead thread?\n");
#endif

      p->seen = 1;

      scan_tid = get_process_next_stopped_thread_id (real_pid, &state);
d3970 3
a3972 3
  /* Remove unseen threads.
   */
  update_thread_list ();
d3974 3
a3976 18
  /* Now run down the thread list and continue or step.
   */
  for (p = thread_head.head; p; p = p->next)
    {

      /* Sanity check.
       */
      thread_dropping_event_check (p);

      /* Pass the correct signals along.
       */
      if (p->have_signal)
	{
	  thread_signal = p->signal_value;
	  p->have_signal = 0;
	}
      else
	thread_signal = 0;
d3978 51
a4028 42
      if (p->tid != real_tid)
	{
	  /*
	   * Not the thread of interest, so continue it
	   * as the user expects.
	   */
	  if (p->stepping_mode == DO_STEP)
	    {
	      /* Just step this thread.
	       */
	      call_ttrace (
			    TT_LWP_SINGLE,
			    p->tid,
			    TT_USE_CURRENT_PC,
			    (TTRACE_ARG_TYPE) target_signal_to_host (signal),
			    TT_NIL);
	    }
	  else
	    {
	      /* Regular continue (default case).
	       */
	      call_ttrace (
			    TT_LWP_CONTINUE,
			    p->tid,
			    TT_USE_CURRENT_PC,
		    (TTRACE_ARG_TYPE) target_signal_to_host (thread_signal),
			    TT_NIL);
	    }
	}
      else
	{
	  /* Step the thread of interest.
	   */
	  call_ttrace (
			TT_LWP_SINGLE,
			real_tid,
			TT_USE_CURRENT_PC,
			(TTRACE_ARG_TYPE) target_signal_to_host (signal),
			TT_NIL);
	}
    }				/* Loop over threads */
}				/* End threads_continue_all_but_one */
d4034 3
a4036 3
threads_continue_all_with_signals (gdb_tid, signal)
     lwpid_t gdb_tid;
     int signal;
d4038 6
a4043 6
  thread_info *p;
  int thread_signal;
  lwpid_t real_tid;
  lwpid_t scan_tid;
  ttstate_t state;
  int real_pid;
d4046 2
a4047 2
  if (debug_on)
    printf ("Using loop over threads to resume with signals\n");
d4050 5
a4054 9
  /* Scan and update thread list.
   */
  set_all_unseen ();
  real_tid = map_from_gdb_tid (gdb_tid);
  real_pid = get_pid_for (real_tid);

  scan_tid = get_process_first_stopped_thread_id (real_pid, &state);
  while (0 != scan_tid)
    {
d4056 3
d4060 3
a4062 3
      if (debug_on)
	if (state.tts_flags & TTS_STATEMASK != TTS_WASSUSPENDED)
	  warning ("About to continue non-stopped thread %d\n", scan_tid);
d4065 4
a4068 5
      p = find_thread_info (scan_tid);
      if (NULL == p)
	{
	  add_tthread (real_pid, scan_tid);
	  p = find_thread_info (scan_tid);
d4070 5
a4074 5
	  /* This is either a newly-created thread or the
	   * result of a fork; in either case there's no
	   * actual event to worry about.
	   */
	  p->handled = 1;
d4076 7
a4082 8
	  if (state.tts_event != TTEVT_NONE)
	    {
	      /* Oops, do need to worry!
	       */
	      warning ("Unexpected thread with \"%s\" event.",
		       get_printable_name_of_ttrace_event (state.tts_event));
	    }
	}
d4085 3
a4087 3
      if (debug_on)
	if (p->terminated)
	  printf ("Why are we continuing a dead thread? (1)\n");
d4090 1
a4090 8
      p->seen = 1;

      scan_tid = get_process_next_stopped_thread_id (real_pid, &state);
    }

  /* Remove unseen threads from our list.
   */
  update_thread_list ();
d4092 2
a4093 4
  /* Continue the threads.
   */
  for (p = thread_head.head; p; p = p->next)
    {
d4095 3
a4097 3
      /* Sanity check.
       */
      thread_dropping_event_check (p);
d4099 3
a4101 14
      /* Pass the correct signals along.
       */
      if (p->tid == real_tid)
	{
	  thread_signal = signal;
	  p->have_signal = 0;
	}
      else if (p->have_signal)
	{
	  thread_signal = p->signal_value;
	  p->have_signal = 0;
	}
      else
	thread_signal = 0;
d4103 35
a4137 20
      if (p->stepping_mode == DO_STEP)
	{
	  call_ttrace (
			TT_LWP_SINGLE,
			p->tid,
			TT_USE_CURRENT_PC,
			(TTRACE_ARG_TYPE) target_signal_to_host (signal),
			TT_NIL);
	}
      else
	{
	  /* Continue this thread (default case).
	   */
	  call_ttrace (
			TT_LWP_CONTINUE,
			p->tid,
			TT_USE_CURRENT_PC,
		    (TTRACE_ARG_TYPE) target_signal_to_host (thread_signal),
			TT_NIL);
	}
d4139 1
a4139 1
}				/* End threads_continue_all_with_signals */
d4144 3
a4146 3
thread_fake_step (tid, signal)
     lwpid_t tid;
     enum target_signal signal;
d4148 1
a4148 1
  thread_info *p;
d4151 2
a4152 3
  if (debug_on)
    {
      printf ("Doing a fake-step over a bpt, etc. for %d\n", tid);
d4154 2
a4155 2
      if (is_terminated (tid))
	printf ("Why are we continuing a dead thread? (4)\n");
d4158 3
d4162 22
a4183 2
  if (doing_fake_step)
    warning ("Step while step already in progress.");
d4185 5
a4189 30
  /* See if there's a saved signal value for this
   * thread to be passed on, but no current signal.
   */
  p = find_thread_info (tid);
  if (p != NULL)
    {
      if (p->have_signal && signal == NULL)
	{
	  /* Pass on a saved signal.
	   */
	  signal = p->signal_value;
	}

      p->have_signal = 0;
    }

  if (!p->handled)
    warning ("Internal error: continuing unhandled thread.");

  call_ttrace (TT_LWP_SINGLE,
	       tid,
	       TT_USE_CURRENT_PC,
	       (TTRACE_ARG_TYPE) target_signal_to_host (signal),
	       TT_NIL);

  /* Do bookkeeping so "call_ttrace_wait" knows it has to wait
   * for this thread only, and clear any saved signal info.
   */
  doing_fake_step = 1;
  fake_step_tid = tid;
d4191 1
a4191 1
}				/* End thread_fake_step */
d4196 3
a4198 3
threads_continue_one_with_signal (gdb_tid, signal)
     lwpid_t gdb_tid;
     int signal;
d4200 4
a4203 4
  thread_info *p;
  lwpid_t real_tid;
  int real_pid;

d4205 2
a4206 2
  if (debug_on)
    printf ("Continuing one thread with a signal\n");
d4209 2
a4210 2
  real_tid = map_from_gdb_tid (gdb_tid);
  real_pid = get_pid_for (real_tid);
d4212 3
a4214 4
  p = find_thread_info (real_tid);
  if (NULL == p)
    {
      add_tthread (real_pid, real_tid);
d4218 3
a4220 3
  if (debug_on)
    if (p->terminated)
      printf ("Why are we continuing a dead thread? (2)\n");
d4223 10
a4232 10
  if (!p->handled)
    warning ("Internal error: continuing unhandled thread.");

  p->have_signal = 0;

  call_ttrace (TT_LWP_CONTINUE,
	       gdb_tid,
	       TT_USE_CURRENT_PC,
	       (TTRACE_ARG_TYPE) target_signal_to_host (signal),
	       TT_NIL);
d4239 1
a4239 1

d4267 1
a4267 1
child_resume (gdb_tid, step, signal)
d4269 1
a4269 1
     int step;
d4272 1
a4272 1
  int resume_all_threads;
d4274 1
a4274 1
  process_state_t new_process_state;
d4280 10
a4289 11
  if (resume_all_threads)
    {
      /* Resume all threads, but first pick a tid value
       * so we can get the pid when in call_ttrace doing
       * the map.
       */
      if (vfork_in_flight)
	tid = vforking_child_pid;
      else
	tid = map_from_gdb_tid (inferior_pid);
    }
d4291 1
a4291 1
    tid = map_from_gdb_tid (gdb_tid);
d4294 3
a4296 4
  if (debug_on)
    {
      if (more_events_left)
	printf ("More events; ");
d4298 15
a4312 2
      if (signal != 0)
	printf ("Sending signal %d; ", signal);
d4314 3
a4316 18
      if (resume_all_threads)
	{
	  if (step == 0)
	    printf ("Continue process %d\n", tid);
	  else
	    printf ("Step/continue thread %d\n", tid);
	}
      else
	{
	  if (step == 0)
	    printf ("Continue thread %d\n", tid);
	  else
	    printf ("Step just thread %d\n", tid);
	}

      if (vfork_in_flight)
	printf ("Vfork in flight\n");
    }
d4319 7
a4325 8
  if (process_state == RUNNING)
    warning ("Internal error in resume logic; doing resume or step anyway.");

  if (!step			/* Asked to continue...       */
      && resume_all_threads	/* whole process..            */
      && signal != 0		/* with a signal...           */
      && more_events_left > 0)
    {				/* but we can't yet--save it! */
d4331 1
a4331 1

d4333 2
a4334 2
      if (debug_on)
	printf ("Saving signal %d for thread %d\n", signal, tid);
d4337 4
a4340 5
      k = find_thread_info (tid);
      if (k != NULL)
	{
	  k->have_signal = 1;
	  k->signal_value = signal;
d4343 3
a4345 3
	  if (debug_on)
	    if (k->terminated)
	      printf ("Why are we continuing a dead thread? (3)\n");
d4348 1
a4348 1
	}
d4351 3
a4353 4
      else if (debug_on)
	{
	  printf ("No thread info for tid %d\n", tid);
	}
d4355 1
a4355 1
    }
d4358 1
a4358 1

d4367 2
a4368 3
  if (resume_all_threads	/* Whole process, therefore user command */
      && more_events_left > 0)
    {				/* But we can't do this yet--fake it! */
d4370 5
a4374 6

      if (!step)
	{
	  /* No need to do any notes on a per-thread
	   * basis--we're done!
	   */
d4376 2
a4377 2
	  if (debug_on)
	    printf ("Faking a process resume.\n");
d4380 3
a4382 4
	  return;
	}
      else
	{
d4385 2
a4386 2
	  if (debug_on)
	    printf ("Faking a process step.\n");
d4389 8
a4396 10
	}

      p = find_thread_info (tid);
      if (p == NULL)
	{
	  warning ("No thread information for tid %d, 'next' command ignored.\n", tid);
	  return;
	}
      else
	{
d4399 3
a4401 3
	  if (debug_on)
	    if (p->terminated)
	      printf ("Why are we continuing a dead thread? (3.5)\n");
d4404 5
a4408 3
	  if (p->stepping_mode != DO_DEFAULT)
	    {
	      warning ("Step or continue command applied to thread which is already stepping or continuing; command ignored.");
d4410 4
a4413 2
	      return;
	    }
d4415 3
a4417 8
	  if (step)
	    p->stepping_mode = DO_STEP;
	  else
	    p->stepping_mode = DO_CONTINUE;

	  return;
	}			/* Have thread info */
    }				/* Must fake step or go */
d4434 33
a4466 37
  if (step)
    {
      if (resume_all_threads)
	{
	  /*
	   * Regular user step: other threads get a "continue".
	   */
	  threads_continue_all_but_one (tid, signal);
	  clear_all_handled ();
	  clear_all_stepping_mode ();
	}

      else
	{
	  /* "Fake step": gdb is stepping one thread over a
	   * breakpoint, watchpoint, or out of a library load
	   * event, etc.  The rest just stay where they are.
	   *
	   * Also used when there are pending events: we really
	   * step the current thread, but leave the rest stopped.
	   * Users can't request this, but "wait_for_inferior"
	   * does--a lot!
	   */
	  thread_fake_step (tid, signal);

	  /* Clear the "handled" state of this thread, because
	   * we'll soon get a new event for it.  Other events
	   * stay as they were.
	   */
	  clear_handled (tid);
	  clear_stepping_mode (tid);
	  new_process_state = FAKE_STEPPING;
	}
    }

  else
    {
d4475 2
a4476 4
      if ((signal != 0) || saved_signals_exist ())
	{
	  if (resume_all_threads)
	    {
d4479 2
a4480 2
	      if (debug_on)
		printf ("Doing a continue by loop of all threads\n");
d4483 1
a4483 1
	      threads_continue_all_with_signals (tid, signal);
d4485 3
a4487 3
	      clear_all_handled ();
	      clear_all_stepping_mode ();
	    }
d4489 1
a4489 2
	  else
	    {
d4491 1
a4491 1
	      printf ("Doing a continue w/signal of just thread %d\n", tid);
d4494 1
a4494 1
	      threads_continue_one_with_signal (tid, signal);
d4496 8
a4503 8
	      /* Clear the "handled" state of this thread, because
	       * we'll soon get a new event for it.  Other events
	       * can stay as they were.
	       */
	      clear_handled (tid);
	      clear_stepping_mode (tid);
	    }
	}
d4505 4
a4508 6
      else
	{
	  /* No signals to send.
	   */
	  if (resume_all_threads)
	    {
d4510 2
a4511 2
	      if (debug_on)
		printf ("Doing a continue by process of process %d\n", tid);
d4514 10
a4523 11
	      if (more_events_left > 0)
		{
		  warning ("Losing buffered events on continue.");
		  more_events_left = 0;
		}

	      call_ttrace (TT_PROC_CONTINUE,
			   tid,
			   TT_NIL,
			   TT_NIL,
			   TT_NIL);
d4525 3
a4527 3
	      clear_all_handled ();
	      clear_all_stepping_mode ();
	    }
d4529 1
a4529 2
	  else
	    {
d4531 22
a4552 23
	      if (debug_on)
		{
		  printf ("Doing a continue of just thread %d\n", tid);
		  if (is_terminated (tid))
		    printf ("Why are we continuing a dead thread? (5)\n");
		}
#endif

	      call_ttrace (TT_LWP_CONTINUE,
			   tid,
			   TT_NIL,
			   TT_NIL,
			   TT_NIL);

	      /* Clear the "handled" state of this thread, because
	       * we'll soon get a new event for it.  Other events
	       * can stay as they were.
	       */
	      clear_handled (tid);
	      clear_stepping_mode (tid);
	    }
	}
    }
d4557 3
a4559 3
  if (debug_on)
    printf ("Process set to %s\n",
	    get_printable_name_of_process_state (process_state));
d4564 1
a4565 1

d4575 8
a4582 8
update_thread_state_after_attach (pid, kind_of_go)
     int pid;
     attach_continue_t kind_of_go;
{
  int tt_status;
  ttstate_t thread_state;
  lwpid_t a_thread;
  lwpid_t tid;
d4586 3
a4588 3
  if (process_state != STOPPED
      && process_state != VFORKING)
    warning ("Internal error attaching.");
d4599 1
a4599 1
  clear_thread_info ();
d4607 1
a4607 1

d4609 2
a4610 2
	{
	  a_thread = tid;
d4612 3
a4614 3
	  if (debug_on)
	    printf ("Attaching to process %d, thread %d\n",
		    pid, a_thread);
d4616 1
a4616 1
	}
d4631 6
a4636 6
      add_tthread (pid, tid);
      p = find_thread_info (tid);
      if (NULL == p)		/* ?We just added it! */
	error ("Internal error adding a thread on attach.");

      copy_ttstate_t (&p->last_stop_state, thread_state);
d4638 53
a4690 57

      if (DO_ATTACH_CONTINUE == kind_of_go)
	{
	  /*
	   * If we are going to CONTINUE afterwards,
	   * raising a SIGTRAP, don't bother trying to
	   * handle this event.  But check first!
	   */
	  switch (p->last_stop_state.tts_event)
	    {

	    case TTEVT_NONE:
	      /* Ok to set this handled.
	       */
	      break;

	    default:
	      warning ("Internal error; skipping event %s on process %d, thread %d.",
		       get_printable_name_of_ttrace_event (
					      p->last_stop_state.tts_event),
		       p->pid, p->tid);
	    }

	  set_handled (pid, tid);

	}
      else
	{
	  /* There will be no "continue" opertion, so the
	   * process remains stopped.  Don't set any events
	   * handled except the "gimmies".
	   */
	  switch (p->last_stop_state.tts_event)
	    {

	    case TTEVT_NONE:
	      /* Ok to ignore this.
	       */
	      set_handled (pid, tid);
	      break;

	    case TTEVT_EXEC:
	    case TTEVT_FORK:
	      /* Expected "other" FORK or EXEC event from a
	       * fork or vfork.
	       */
	      break;

	    default:
	      printf ("Internal error: failed to handle event %s on process %d, thread %d.",
		      get_printable_name_of_ttrace_event (
					      p->last_stop_state.tts_event),
		      p->pid, p->tid);
	    }
	}

      add_thread (tid);		/* in thread.c */
d4692 1
a4692 1

d4694 2
a4695 2
  if (debug_on)
    print_tthreads ();
d4700 1
a4700 1

d4715 8
a4722 9
  if (DO_ATTACH_CONTINUE == kind_of_go)
    {
      tt_status = call_real_ttrace (
				     TT_LWP_CONTINUE,
				     pid,
				     a_thread,
				     TT_USE_CURRENT_PC,
	       (TTRACE_ARG_TYPE) target_signal_to_host (TARGET_SIGNAL_TRAP),
				     TT_NIL);
d4724 1
a4724 1
	perror_with_name ("ttrace");
d4726 1
a4726 1
      clear_handled (a_thread);	/* So TRAP will be reported. */
d4731 1
a4731 1
    }
d4736 1
a4737 1

d4743 1
a4743 1
attach (pid)
d4746 2
a4747 2
  int tt_status;

d4749 6
a4754 6
				 TT_PROC_ATTACH,
				 pid,
				 (lwpid_t) TT_NIL,
				 TT_NIL,
				 (TTRACE_ARG_TYPE) TT_VERSION,
				 TT_NIL);
d4767 1
a4767 1
  update_thread_state_after_attach (pid, DO_ATTACH_CONTINUE);
d4776 1
a4776 1
     int pid;
d4779 2
a4780 2
  if (debug_on)
    printf ("child-post-attach call\n");
d4793 1
a4793 1
detach (signal)
d4798 4
a4801 4
	       inferior_pid,
	       TT_NIL,
	       (TTRACE_ARG_TYPE) signal,
	       TT_NIL);
d4804 1
a4804 1
  clear_thread_info ();
d4809 1
a4810 1

d4831 1
a4831 1

d4843 1
a4843 1
     struct target_ops *target;	/* ignored */
d4847 1
a4847 1
  register CORE_ADDR addr = memaddr & -sizeof (TTRACE_XFER_TYPE);
d4850 2
a4851 2
  = (((memaddr + len) - addr) + sizeof (TTRACE_XFER_TYPE) - 1)
  / sizeof (TTRACE_XFER_TYPE);
d4854 1
a4854 1
  = (TTRACE_XFER_TYPE *) alloca (count * sizeof (TTRACE_XFER_TYPE));
d4860 8
a4867 9
      if (addr != memaddr || len < (int) sizeof (TTRACE_XFER_TYPE))
	{
	  /* Need part of initial word -- fetch it.  */
	  buffer[0] = call_ttrace (TT_LWP_RDTEXT,
				   inferior_pid,
				   (TTRACE_ARG_TYPE) addr,
				   TT_NIL,
				   TT_NIL);
	}
d4872 5
a4876 5
					   inferior_pid,
					   ((TTRACE_ARG_TYPE)
			  (addr + (count - 1) * sizeof (TTRACE_XFER_TYPE))),
					   TT_NIL,
					   TT_NIL);
d4891 4
a4894 4
		       inferior_pid,
		       (TTRACE_ARG_TYPE) addr,
		       (TTRACE_ARG_TYPE) buffer[i],
		       TT_NIL);
d4898 1
a4898 1
	         Gould NP1, at least.  */
d4901 4
a4904 4
			   inferior_pid,
			   (TTRACE_ARG_TYPE) addr,
			   (TTRACE_ARG_TYPE) buffer[i],
			   TT_NIL);
d4917 4
a4920 4
				   inferior_pid,
				   (TTRACE_ARG_TYPE) addr,
				   TT_NIL,
				   TT_NIL);
d4933 1
a4934 1

d4938 8
a4945 8
  int udot_off;			/* Offset into user struct */
  int udot_val;			/* Value from user struct at udot_off */
  char mess[128];		/* For messages */

  if (!target_has_execution)
    {
      error ("The program is not being run.");
    }
d4968 4
a4971 4
			      inferior_pid,
			      (TTRACE_ARG_TYPE) udot_off,
			      TT_NIL,
			      TT_NIL);
d4990 1
a4990 1
     int tid;
d4992 9
a5000 9
  static char exec_file_buffer[1024];
  int tt_status;
  CORE_ADDR top_of_stack;
  char four_chars[4];
  int name_index;
  int i;
  int done;
  int saved_inferior_pid;

d5005 4
a5008 4
			   tid,
			   (TTRACE_ARG_TYPE) exec_file_buffer,
			   (TTRACE_ARG_TYPE) sizeof (exec_file_buffer) - 1,
			   TT_NIL);
d5020 1
a5020 1
   */
d5028 1
a5028 1
   */
d5033 11
a5043 15
  while (!done)
    {
      if (target_read_memory (top_of_stack, four_chars, 4) != 0)
	{
	  inferior_pid = saved_inferior_pid;
	  return NULL;
	}
      for (i = 0; i < 4; i++)
	{
	  exec_file_buffer[name_index++] = four_chars[i];
	  done = (four_chars[i] == '\0');
	  if (done)
	    break;
	}
      top_of_stack += 4;
d5045 2
d5062 1
a5062 1
  int status;
d5065 1
a5065 2
  if (status < 0)
    {
d5068 1
a5068 1
    }
d5071 1
a5071 2
  if (status < 0)
    {
d5074 1
a5074 1
    }
d5088 1
a5088 1
     int pid;
d5090 4
a5093 4
  int tt_status;
  CORE_ADDR pc;
  CORE_ADDR pc_addr;
  unsigned int regs_offset;
d5095 1
a5095 1

d5104 6
a5109 6
				pid,
				(lwpid_t) TT_NIL,
				(TTRACE_ARG_TYPE) TT_NIL,
				(TTRACE_ARG_TYPE) TT_NIL,
				TT_NIL);

d5115 1
a5115 1
      pid = attach (pid);
d5119 23
a5141 23
      /* If successful, the process is now stopped.  But if
       * we're VFORKING, the parent is still running, so don't
       * change the process state.
       */
      if (process_state != VFORKING)
	process_state = STOPPED;

      /* If we were already attached, you'd think that we
       * would need to start going again--but you'd be wrong,
       * as the fork-following code is actually in the middle
       * of the "resume" routine in in "infrun.c" and so
       * will (almost) immediately do a resume.
       *
       * On the other hand, if we are VFORKING, which means
       * that the child and the parent share a process for a
       * while, we know that "resume" won't be resuming
       * until the child EXEC event is seen.  But we still
       * don't want to continue, as the event is already
       * there waiting.
       */
      update_thread_state_after_attach (pid, DONT_ATTACH_CONTINUE);
    }				/* STOP succeeded */

d5147 2
a5148 2
     int pid;
     int signal;
d5150 1
a5150 1
  int tt_status;
d5159 1
a5159 1
      threads_continue_all_with_signals (pid, signal);
d5164 4
a5167 4
			   pid,
			   TT_NIL,
			   TT_NIL,
			   TT_NIL);
d5169 1
a5169 1
  errno = 0;			/* Ignore any errors. */
d5172 1
a5172 1

d5178 1
a5178 1
 */
d5181 1
a5181 1
     CORE_ADDR page_start;
d5183 1
a5183 1
  int hash;
d5196 1
a5196 1
 */
d5199 2
a5200 2
     int pid;
     CORE_ADDR page_start;
d5202 3
a5204 3
  int bucket;
  memory_page_t *page = NULL;
  memory_page_t *previous_page = NULL;
d5211 1
a5211 1
   */
d5217 1
a5217 1
	break;
d5224 1
a5224 1
   */
d5250 2
a5251 2
     int pid;
     memory_page_t *page;
d5273 1
a5273 1
     int pid;
d5275 2
a5276 2
  int tt_status;
  ttevent_t ttrace_events;
d5280 4
a5283 4
			   pid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
d5292 4
a5295 4
			   pid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
d5303 1
a5303 1
     int pid;
d5305 2
a5306 2
  int tt_status;
  ttevent_t ttrace_events;
d5310 4
a5313 4
			   pid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
d5322 4
a5325 4
			   pid,
			   (TTRACE_ARG_TYPE) & ttrace_events,
			   (TTRACE_ARG_TYPE) sizeof (ttrace_events),
			   TT_NIL);
d5336 3
a5338 3
   0 for a bp_hardware_watchpoint,
   1 for a bp_read_watchpoint,
   2 for a bp_access_watchpoint
d5342 1
a5342 1
 */
d5345 10
a5354 10
     int pid;
     CORE_ADDR start;
     LONGEST len;
     int type;
{
  CORE_ADDR page_start;
  int dictionary_was_empty;
  int page_size;
  int page_id;
  LONGEST range_size_in_pages;
d5368 1
a5368 1
  for (page_id = 0; page_id < range_size_in_pages; page_id++, page_start += page_size)
d5370 1
a5370 1
      memory_page_t *page;
d5374 1
a5374 1
       */
d5406 1
a5406 1
   */
d5419 1
a5419 1
 */
d5422 10
a5431 10
     int pid;
     CORE_ADDR start;
     LONGEST len;
     enum bptype type;
{
  CORE_ADDR page_start;
  int dictionary_is_empty;
  int page_size;
  int page_id;
  LONGEST range_size_in_pages;
d5443 1
a5443 1
  for (page_id = 0; page_id < range_size_in_pages; page_id++, page_start += page_size)
d5445 1
a5445 1
      memory_page_t *page;
d5453 1
a5453 1
       */
d5455 1
a5455 1
	remove_dictionary_entry_of_page (pid, page);
d5467 1
a5467 1
   */
d5483 1
a5483 1
 */
d5486 3
a5488 3
     enum bptype type;
     int cnt;
     enum bptype ot;
d5498 1
a5498 1
 */
d5501 10
a5510 10
     int pid;
     CORE_ADDR start;
     LONGEST len;
{
  int range_is_stack_based;
  int range_is_accessible;
  CORE_ADDR page_start;
  int page_size;
  int page;
  LONGEST range_size_in_pages;
d5515 1
a5515 1
   */
d5523 2
a5524 2
   */
  range_is_accessible = 1;	/* Until proven otherwise. */
d5533 1
a5533 1
   */
d5541 1
a5541 1
  range_size_in_pages = len / (LONGEST) page_size;
d5543 1
a5543 1
  for (page = 0; page < range_size_in_pages; page++, page_start += page_size)
d5545 2
a5546 2
      int tt_status;
      int page_permissions;
d5551 4
a5554 4
			       pid,
			       (TTRACE_ARG_TYPE) page_start,
			       TT_NIL,
			       (TTRACE_ARG_TYPE) & page_permissions);
d5556 5
a5560 5
	{
	  errno = 0;
	  range_is_accessible = 0;
	  break;
	}
d5565 1
a5565 1
  return (!range_is_stack_based && range_is_accessible);
d5571 1
a5571 1
     pid_t id;
d5573 1
a5573 1
  static char buf[100];		/* Static because address returned. */
d5586 1
a5587 1

d5595 3
a5597 3
pid_t
hppa_switched_threads (gdb_pid)
     pid_t gdb_pid;
d5599 1
a5599 2
  if (gdb_pid == old_gdb_pid)
    {
d5610 2
a5611 3
    }
  else if (gdb_pid == reported_pid)
    {
d5619 8
a5626 9
    }
  else if (!reported_bpt)
    {
      /*
       * The core switched, but we didn't just report a
       * breakpoint, so there's no just-hit breakpoint
       * instruction at "reported_pid"'s PC, and thus there
       * is no need to step over it.
       */
d5628 9
a5636 10
    }
  else
    {
      /* There's been a real switch, and we reported
       * a hit breakpoint.  Let "hppa_prepare_to_proceed"
       * know, so it can see whether the breakpoint is
       * still active.
       */
      return reported_pid;
    }
d5640 1
a5640 1
  return (pid_t) 0;
d5645 1
a5645 1
     int pid;
d5656 1
a5656 1
  return 0;			/* No, the parent vfork is available now. */
a5657 1

d5660 1
d5665 1
a5665 1
  memory_page_dictionary.page_count = (LONGEST) - 1;
d5674 1
@


1.1.1.3
log
@import gdb-1999-08-02 snapshot
@
text
@d1406 7
a1412 6
  tt_status = call_real_ttrace (TT_PROC_GET_FIRST_LWP_STATE,
				(pid_t) pid,
				(lwpid_t) TT_NIL,
				(TTRACE_ARG_TYPE) thread_state,
				(TTRACE_ARG_TYPE) sizeof (*thread_state),
				TT_NIL);
d4333 1
a4333 1
      if (p->have_signal && signal == TARGET_SIGNAL_0)
a5876 5

  /* We do a lot of casts from pointers to TTRACE_ARG_TYPE; make sure
     this is okay.  */
  if (sizeof (TTRACE_ARG_TYPE) < sizeof (void *))
    abort ();
@


1.1.1.4
log
@import gdb-1999-08-16 snapshot
@
text
@a5865 49
/* Write a register as a 64bit value.  This may be necessary if the
   native OS is too braindamaged to allow some (or all) registers to
   be written in 32bit hunks such as hpux11 and the PC queue registers.

   This is horribly gross and disgusting.  */
 
int
ttrace_write_reg_64 (gdb_tid, dest_addr, src_addr)
     int gdb_tid;
     CORE_ADDR dest_addr;
     CORE_ADDR src_addr;
{
  pid_t 	pid;
  lwpid_t 	tid;
  int  		tt_status;

  tid = map_from_gdb_tid (gdb_tid);
  pid = get_pid_for (tid);

  errno = 0;
  tt_status = ttrace (TT_LWP_WUREGS, 
		      pid, 
		      tid, 
		      (TTRACE_ARG_TYPE) dest_addr, 
		      8, 
		      (TTRACE_ARG_TYPE) src_addr );

#ifdef THREAD_DEBUG
  if (errno)
    {
      /* Don't bother for a known benign error: if you ask for the
         first thread state, but there is only one thread and it's
         not stopped, ttrace complains.
        
         We have this inside the #ifdef because our caller will do
         this check for real.  */
      if( request != TT_PROC_GET_FIRST_LWP_STATE
          ||  errno   != EPROTO )
        {
          if( debug_on )
            printf( "TT fail for %s, with pid %d, tid %d, status %d \n",
                    get_printable_name_of_ttrace_request (TT_LWP_WUREGS),
                    pid, tid, tt_status );
        }
    }
#endif

  return tt_status;
}
@


1.1.1.5
log
@import gdb-1999-08-30 snapshot
@
text
@d48 3
d5219 1
a5219 1
  top_of_stack = (TARGET_PTR_BIT == 64 ? 0x800003ffff7f0000 : 0x7b03a000);
@


1.1.1.6
log
@import gdb-1999-12-21 snapshot
@
text
@d5776 1
a5776 1
    return child_pid_to_str (id);
@


