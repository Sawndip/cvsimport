head	1.8;
access;
symbols
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.8
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.6
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.4
	gdb_5_1-2001-07-29-branchpoint:1.7
	dberlin-typesystem-branch:1.7.0.2
	dberlin-typesystem-branchpoint:1.7
	gdb-post-ptid_t-2001-05-03:1.7
	gdb-pre-ptid_t-2001-05-03:1.6
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.3
	gdb-premipsmulti-2000-06-06-branch:1.1.1.3.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.3
	gdb-post-params-removal-2000-06-04:1.1.1.3
	gdb-pre-params-removal-2000-06-04:1.1.1.3
	gdb-post-params-removal-2000-05-28:1.1.1.3
	gdb-pre-params-removal-2000-05-28:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.8
date	2001.12.01.22.19.30;	author cagney;	state dead;
branches;
next	1.7;

1.7
date	2001.05.04.04.15.27;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.11.22.39.07;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.06.08.21.17;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.01.01.50;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.27;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.10.24;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Zap Sun's i386i.
@
text
@/* OBSOLETE /* Native support for Sun 386i's for GDB, the GNU debugger. */
/* OBSOLETE    Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1995, 1999, 2000, 2001 */
/* OBSOLETE    Free Software Foundation, Inc. */
/* OBSOLETE    Changes for sun386i by Jean Daniel Fekete (jdf@@litp.univ-p6-7.fr), */
/* OBSOLETE    C2V Paris, April 89. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "frame.h" */
/* OBSOLETE #include "inferior.h" */
/* OBSOLETE #include "gdbcore.h" */
/* OBSOLETE #include "regcache.h" */
/* OBSOLETE  */
/* OBSOLETE #include <sys/param.h> */
/* OBSOLETE #include <sys/dir.h> */
/* OBSOLETE #include <sys/user.h> */
/* OBSOLETE #include <signal.h> */
/* OBSOLETE #include <sys/ioctl.h> */
/* OBSOLETE #include <fcntl.h> */
/* OBSOLETE  */
/* OBSOLETE #include <sys/ptrace.h> */
/* OBSOLETE #include <machine/reg.h> */
/* OBSOLETE  */
/* OBSOLETE #include <sys/file.h> */
/* OBSOLETE #include "gdb_stat.h" */
/* OBSOLETE #include <sys/core.h> */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Machine-dependent code which would otherwise be in corefile.c */ */
/* OBSOLETE /* Work with core files, for GDB. */ */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE core_file_command (char *filename, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   int val; */
/* OBSOLETE  */
/* OBSOLETE   /* Discard all vestiges of any previous core file */
/* OBSOLETE      and mark data and stack spaces as empty.  */ */
/* OBSOLETE  */
/* OBSOLETE   if (corefile) */
/* OBSOLETE     xfree (corefile); */
/* OBSOLETE   corefile = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (corechan >= 0) */
/* OBSOLETE     close (corechan); */
/* OBSOLETE   corechan = -1; */
/* OBSOLETE  */
/* OBSOLETE   data_start = 0; */
/* OBSOLETE   data_end = 0; */
/* OBSOLETE   stack_start = STACK_END_ADDR; */
/* OBSOLETE   stack_end = STACK_END_ADDR; */
/* OBSOLETE  */
/* OBSOLETE   /* Now, if a new core file was specified, open it and digest it.  */ */
/* OBSOLETE  */
/* OBSOLETE   if (filename) */
/* OBSOLETE     { */
/* OBSOLETE       filename = tilde_expand (filename); */
/* OBSOLETE       make_cleanup (xfree, filename); */
/* OBSOLETE  */
/* OBSOLETE       if (have_inferior_p ()) */
/* OBSOLETE 	error ("To look at a core file, you must kill the program with \"kill\"."); */
/* OBSOLETE       corechan = open (filename, O_RDONLY, 0); */
/* OBSOLETE       if (corechan < 0) */
/* OBSOLETE 	perror_with_name (filename); */
/* OBSOLETE  */
/* OBSOLETE       { */
/* OBSOLETE 	struct core corestr; */
/* OBSOLETE  */
/* OBSOLETE 	val = myread (corechan, &corestr, sizeof corestr); */
/* OBSOLETE 	if (val < 0) */
/* OBSOLETE 	  perror_with_name (filename); */
/* OBSOLETE 	if (corestr.c_magic != CORE_MAGIC) */
/* OBSOLETE 	  error ("\"%s\" does not appear to be a core dump file (magic 0x%x, expected 0x%x)", */
/* OBSOLETE 		 filename, corestr.c_magic, (int) CORE_MAGIC); */
/* OBSOLETE 	else if (sizeof (struct core) != corestr.c_len) */
/* OBSOLETE 	    error ("\"%s\" has an invalid struct core length (%d, expected %d)", */
/* OBSOLETE 		   filename, corestr.c_len, (int) sizeof (struct core)); */
/* OBSOLETE  */
/* OBSOLETE 	data_start = exec_data_start; */
/* OBSOLETE 	data_end = data_start + corestr.c_dsize; */
/* OBSOLETE 	stack_start = stack_end - corestr.c_ssize; */
/* OBSOLETE 	data_offset = sizeof corestr; */
/* OBSOLETE 	stack_offset = sizeof corestr + corestr.c_dsize; */
/* OBSOLETE  */
/* OBSOLETE 	memcpy (registers, &corestr.c_regs, sizeof corestr.c_regs); */
/* OBSOLETE  */
/* OBSOLETE 	memcpy (&registers[REGISTER_BYTE (FP0_REGNUM)], */
/* OBSOLETE 		corestr.c_fpu.f_fpstatus.f_st, */
/* OBSOLETE 		sizeof corestr.c_fpu.f_fpstatus.f_st); */
/* OBSOLETE 	memcpy (&registers[REGISTER_BYTE (FPC_REGNUM)], */
/* OBSOLETE 		&corestr.c_fpu.f_fpstatus.f_ctrl, */
/* OBSOLETE 		sizeof corestr.c_fpu.f_fpstatus - */
/* OBSOLETE 		sizeof corestr.c_fpu.f_fpstatus.f_st); */
/* OBSOLETE  */
/* OBSOLETE 	/* the struct aouthdr of sun coff is not the struct exec stored */
/* OBSOLETE 	   in the core file. */ */
/* OBSOLETE 	memcpy (&core_aouthdr, &corestr.c_aouthdr, sizeof (struct exec)); */
/* OBSOLETE #ifndef COFF_ENCAPSULATE */
/* OBSOLETE 	core_aouthdr.magic = corestr.c_aouthdr.a_info; */
/* OBSOLETE 	core_aouthdr.vstamp = /*SUNVERSION */ 31252; */
/* OBSOLETE #endif */
/* OBSOLETE 	printf_unfiltered ("Core file is from \"%s\".\n", corestr.c_cmdname); */
/* OBSOLETE 	if (corestr.c_signo > 0) */
/* OBSOLETE 	  printf_unfiltered ("Program terminated with signal %d, %s.\n", */
/* OBSOLETE 			 corestr.c_signo, safe_strsignal (corestr.c_signo)); */
/* OBSOLETE       } */
/* OBSOLETE       if (filename[0] == '/') */
/* OBSOLETE 	corefile = savestring (filename, strlen (filename)); */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  corefile = concat (current_directory, "/", filename, NULL); */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       flush_cached_frames (); */
/* OBSOLETE       select_frame (get_current_frame (), 0); */
/* OBSOLETE  */
/* OBSOLETE       validate_files (); */
/* OBSOLETE     } */
/* OBSOLETE   else if (from_tty) */
/* OBSOLETE     printf_unfiltered ("No core file now.\n"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE i387_to_double (char *from, char *to) */
/* OBSOLETE { */
/* OBSOLETE   long *lp; */
/* OBSOLETE   /* push extended mode on 387 stack, then pop in double mode */
/* OBSOLETE  */
/* OBSOLETE    * first, set exception masks so no error is generated - */
/* OBSOLETE    * number will be rounded to inf or 0, if necessary  */
/* OBSOLETE    */ */
/* OBSOLETE   asm ("pushl %eax");		/* grab a stack slot */ */
/* OBSOLETE   asm ("fstcw (%esp)");		/* get 387 control word */ */
/* OBSOLETE   asm ("movl (%esp),%eax");	/* save old value */ */
/* OBSOLETE   asm ("orl $0x3f,%eax");	/* mask all exceptions */ */
/* OBSOLETE   asm ("pushl %eax"); */
/* OBSOLETE   asm ("fldcw (%esp)");		/* load new value into 387 */ */
/* OBSOLETE  */
/* OBSOLETE   asm ("movl 8(%ebp),%eax"); */
/* OBSOLETE   asm ("fldt (%eax)");		/* push extended number on 387 stack */ */
/* OBSOLETE   asm ("fwait"); */
/* OBSOLETE   asm ("movl 12(%ebp),%eax"); */
/* OBSOLETE   asm ("fstpl (%eax)");		/* pop double */ */
/* OBSOLETE   asm ("fwait"); */
/* OBSOLETE  */
/* OBSOLETE   asm ("popl %eax");		/* flush modified control word */ */
/* OBSOLETE   asm ("fnclex");		/* clear exceptions */ */
/* OBSOLETE   asm ("fldcw (%esp)");		/* restore original control word */ */
/* OBSOLETE   asm ("popl %eax");		/* flush saved copy */ */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE double_to_i387 (char *from, char *to) */
/* OBSOLETE { */
/* OBSOLETE   /* push double mode on 387 stack, then pop in extended mode */
/* OBSOLETE    * no errors are possible because every 64-bit pattern */
/* OBSOLETE    * can be converted to an extended */
/* OBSOLETE    */ */
/* OBSOLETE   asm ("movl 8(%ebp),%eax"); */
/* OBSOLETE   asm ("fldl (%eax)"); */
/* OBSOLETE   asm ("fwait"); */
/* OBSOLETE   asm ("movl 12(%ebp),%eax"); */
/* OBSOLETE   asm ("fstpt (%eax)"); */
/* OBSOLETE   asm ("fwait"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE fetch_inferior_registers (int regno) */
/* OBSOLETE { */
/* OBSOLETE   struct regs inferior_registers; */
/* OBSOLETE   struct fp_state inferior_fp_registers; */
/* OBSOLETE  */
/* OBSOLETE   registers_fetched (); */
/* OBSOLETE  */
/* OBSOLETE   ptrace (PTRACE_GETREGS, PIDGET (inferior_ptid), */
/* OBSOLETE 	  (PTRACE_ARG3_TYPE) & inferior_registers); */
/* OBSOLETE   ptrace (PTRACE_GETFPREGS, PIDGET (inferior_ptid), */
/* OBSOLETE 	  (PTRACE_ARG3_TYPE) & inferior_fp_registers); */
/* OBSOLETE  */
/* OBSOLETE   memcpy (registers, &inferior_registers, sizeof inferior_registers); */
/* OBSOLETE  */
/* OBSOLETE   memcpy (&registers[REGISTER_BYTE (FP0_REGNUM)], inferior_fp_registers.f_st, */
/* OBSOLETE 	  sizeof inferior_fp_registers.f_st); */
/* OBSOLETE   memcpy (&registers[REGISTER_BYTE (FPC_REGNUM)], */
/* OBSOLETE 	  &inferior_fp_registers.f_ctrl, */
/* OBSOLETE 	  sizeof inferior_fp_registers - sizeof inferior_fp_registers.f_st); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Store our register values back into the inferior. */
/* OBSOLETE    If REGNO is -1, do this for all registers. */
/* OBSOLETE    Otherwise, REGNO specifies which register (so we can save time).  */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE store_inferior_registers (int regno) */
/* OBSOLETE { */
/* OBSOLETE   struct regs inferior_registers; */
/* OBSOLETE   struct fp_state inferior_fp_registers; */
/* OBSOLETE  */
/* OBSOLETE   memcpy (&inferior_registers, registers, 20 * 4); */
/* OBSOLETE  */
/* OBSOLETE   memcpy (inferior_fp_registers.f_st, */
/* OBSOLETE 	  &registers[REGISTER_BYTE (FP0_REGNUM)], */
/* OBSOLETE 	  sizeof inferior_fp_registers.f_st); */
/* OBSOLETE   memcpy (&inferior_fp_registers.f_ctrl, */
/* OBSOLETE 	  &registers[REGISTER_BYTE (FPC_REGNUM)], */
/* OBSOLETE 	  sizeof inferior_fp_registers - sizeof inferior_fp_registers.f_st); */
/* OBSOLETE  */
/* OBSOLETE #ifdef PTRACE_FP_BUG */
/* OBSOLETE   if (regno == FP_REGNUM || regno == -1) */
/* OBSOLETE     /* Storing the frame pointer requires a gross hack, in which an */
/* OBSOLETE        instruction that moves eax into ebp gets single-stepped.  */ */
/* OBSOLETE     { */
/* OBSOLETE       int stack = inferior_registers.r_reg[SP_REGNUM]; */
/* OBSOLETE       int stuff = ptrace (PTRACE_PEEKDATA, PIDGET (inferior_ptid), */
/* OBSOLETE 			  (PTRACE_ARG3_TYPE) stack); */
/* OBSOLETE       int reg = inferior_registers.r_reg[EAX]; */
/* OBSOLETE       inferior_registers.r_reg[EAX] = */
/* OBSOLETE 	inferior_registers.r_reg[FP_REGNUM]; */
/* OBSOLETE       ptrace (PTRACE_SETREGS, PIDGET (inferior_ptid), */
/* OBSOLETE 	      (PTRACE_ARG3_TYPE) & inferior_registers); */
/* OBSOLETE       ptrace (PTRACE_POKEDATA, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) stack, */
/* OBSOLETE 	      0xc589); */
/* OBSOLETE       ptrace (PTRACE_SINGLESTEP, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) stack, */
/* OBSOLETE 	      0); */
/* OBSOLETE       wait (0); */
/* OBSOLETE       ptrace (PTRACE_POKEDATA, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) stack, */
/* OBSOLETE 	      stuff); */
/* OBSOLETE       inferior_registers.r_reg[EAX] = reg; */
/* OBSOLETE     } */
/* OBSOLETE #endif */
/* OBSOLETE   ptrace (PTRACE_SETREGS, PIDGET (inferior_ptid), */
/* OBSOLETE 	  (PTRACE_ARG3_TYPE) & inferior_registers); */
/* OBSOLETE   ptrace (PTRACE_SETFPREGS, PIDGET (inferior_ptid), */
/* OBSOLETE 	  (PTRACE_ARG3_TYPE) & inferior_fp_registers); */
/* OBSOLETE } */
@


1.7
log
@Phase 1 of the ptid_t changes.
@
text
@@


1.6
log
@Obsolete sun386i.
@
text
@d190 1
a190 1
/* OBSOLETE   ptrace (PTRACE_GETREGS, inferior_pid, */
d192 1
a192 1
/* OBSOLETE   ptrace (PTRACE_GETFPREGS, inferior_pid, */
d229 1
a229 1
/* OBSOLETE       int stuff = ptrace (PTRACE_PEEKDATA, inferior_pid, */
d234 1
a234 1
/* OBSOLETE       ptrace (PTRACE_SETREGS, inferior_pid, */
d236 1
a236 1
/* OBSOLETE       ptrace (PTRACE_POKEDATA, inferior_pid, (PTRACE_ARG3_TYPE) stack, */
d238 1
a238 1
/* OBSOLETE       ptrace (PTRACE_SINGLESTEP, inferior_pid, (PTRACE_ARG3_TYPE) stack, */
d241 1
a241 1
/* OBSOLETE       ptrace (PTRACE_POKEDATA, inferior_pid, (PTRACE_ARG3_TYPE) stack, */
d246 1
a246 1
/* OBSOLETE   ptrace (PTRACE_SETREGS, inferior_pid, */
d248 1
a248 1
/* OBSOLETE   ptrace (PTRACE_SETFPREGS, inferior_pid, */
@


1.5
log
@Update/correct copyright notices.
@
text
@d1 250
a250 250
/* Native support for Sun 386i's for GDB, the GNU debugger.
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1995, 1999, 2000, 2001
   Free Software Foundation, Inc.
   Changes for sun386i by Jean Daniel Fekete (jdf@@litp.univ-p6-7.fr),
   C2V Paris, April 89.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "gdbcore.h"
#include "regcache.h"

#include <sys/param.h>
#include <sys/dir.h>
#include <sys/user.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <fcntl.h>

#include <sys/ptrace.h>
#include <machine/reg.h>

#include <sys/file.h>
#include "gdb_stat.h"
#include <sys/core.h>


/* Machine-dependent code which would otherwise be in corefile.c */
/* Work with core files, for GDB. */


void
core_file_command (char *filename, int from_tty)
{
  int val;

  /* Discard all vestiges of any previous core file
     and mark data and stack spaces as empty.  */

  if (corefile)
    xfree (corefile);
  corefile = 0;

  if (corechan >= 0)
    close (corechan);
  corechan = -1;

  data_start = 0;
  data_end = 0;
  stack_start = STACK_END_ADDR;
  stack_end = STACK_END_ADDR;

  /* Now, if a new core file was specified, open it and digest it.  */

  if (filename)
    {
      filename = tilde_expand (filename);
      make_cleanup (xfree, filename);

      if (have_inferior_p ())
	error ("To look at a core file, you must kill the program with \"kill\".");
      corechan = open (filename, O_RDONLY, 0);
      if (corechan < 0)
	perror_with_name (filename);

      {
	struct core corestr;

	val = myread (corechan, &corestr, sizeof corestr);
	if (val < 0)
	  perror_with_name (filename);
	if (corestr.c_magic != CORE_MAGIC)
	  error ("\"%s\" does not appear to be a core dump file (magic 0x%x, expected 0x%x)",
		 filename, corestr.c_magic, (int) CORE_MAGIC);
	else if (sizeof (struct core) != corestr.c_len)
	    error ("\"%s\" has an invalid struct core length (%d, expected %d)",
		   filename, corestr.c_len, (int) sizeof (struct core));

	data_start = exec_data_start;
	data_end = data_start + corestr.c_dsize;
	stack_start = stack_end - corestr.c_ssize;
	data_offset = sizeof corestr;
	stack_offset = sizeof corestr + corestr.c_dsize;

	memcpy (registers, &corestr.c_regs, sizeof corestr.c_regs);

	memcpy (&registers[REGISTER_BYTE (FP0_REGNUM)],
		corestr.c_fpu.f_fpstatus.f_st,
		sizeof corestr.c_fpu.f_fpstatus.f_st);
	memcpy (&registers[REGISTER_BYTE (FPC_REGNUM)],
		&corestr.c_fpu.f_fpstatus.f_ctrl,
		sizeof corestr.c_fpu.f_fpstatus -
		sizeof corestr.c_fpu.f_fpstatus.f_st);

	/* the struct aouthdr of sun coff is not the struct exec stored
	   in the core file. */
	memcpy (&core_aouthdr, &corestr.c_aouthdr, sizeof (struct exec));
#ifndef COFF_ENCAPSULATE
	core_aouthdr.magic = corestr.c_aouthdr.a_info;
	core_aouthdr.vstamp = /*SUNVERSION */ 31252;
#endif
	printf_unfiltered ("Core file is from \"%s\".\n", corestr.c_cmdname);
	if (corestr.c_signo > 0)
	  printf_unfiltered ("Program terminated with signal %d, %s.\n",
			 corestr.c_signo, safe_strsignal (corestr.c_signo));
      }
      if (filename[0] == '/')
	corefile = savestring (filename, strlen (filename));
      else
	{
	  corefile = concat (current_directory, "/", filename, NULL);
	}

      flush_cached_frames ();
      select_frame (get_current_frame (), 0);

      validate_files ();
    }
  else if (from_tty)
    printf_unfiltered ("No core file now.\n");
}

i387_to_double (char *from, char *to)
{
  long *lp;
  /* push extended mode on 387 stack, then pop in double mode

   * first, set exception masks so no error is generated -
   * number will be rounded to inf or 0, if necessary 
   */
  asm ("pushl %eax");		/* grab a stack slot */
  asm ("fstcw (%esp)");		/* get 387 control word */
  asm ("movl (%esp),%eax");	/* save old value */
  asm ("orl $0x3f,%eax");	/* mask all exceptions */
  asm ("pushl %eax");
  asm ("fldcw (%esp)");		/* load new value into 387 */

  asm ("movl 8(%ebp),%eax");
  asm ("fldt (%eax)");		/* push extended number on 387 stack */
  asm ("fwait");
  asm ("movl 12(%ebp),%eax");
  asm ("fstpl (%eax)");		/* pop double */
  asm ("fwait");

  asm ("popl %eax");		/* flush modified control word */
  asm ("fnclex");		/* clear exceptions */
  asm ("fldcw (%esp)");		/* restore original control word */
  asm ("popl %eax");		/* flush saved copy */
}

double_to_i387 (char *from, char *to)
{
  /* push double mode on 387 stack, then pop in extended mode
   * no errors are possible because every 64-bit pattern
   * can be converted to an extended
   */
  asm ("movl 8(%ebp),%eax");
  asm ("fldl (%eax)");
  asm ("fwait");
  asm ("movl 12(%ebp),%eax");
  asm ("fstpt (%eax)");
  asm ("fwait");
}

void
fetch_inferior_registers (int regno)
{
  struct regs inferior_registers;
  struct fp_state inferior_fp_registers;

  registers_fetched ();

  ptrace (PTRACE_GETREGS, inferior_pid,
	  (PTRACE_ARG3_TYPE) & inferior_registers);
  ptrace (PTRACE_GETFPREGS, inferior_pid,
	  (PTRACE_ARG3_TYPE) & inferior_fp_registers);

  memcpy (registers, &inferior_registers, sizeof inferior_registers);

  memcpy (&registers[REGISTER_BYTE (FP0_REGNUM)], inferior_fp_registers.f_st,
	  sizeof inferior_fp_registers.f_st);
  memcpy (&registers[REGISTER_BYTE (FPC_REGNUM)],
	  &inferior_fp_registers.f_ctrl,
	  sizeof inferior_fp_registers - sizeof inferior_fp_registers.f_st);
}

/* Store our register values back into the inferior.
   If REGNO is -1, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time).  */

void
store_inferior_registers (int regno)
{
  struct regs inferior_registers;
  struct fp_state inferior_fp_registers;

  memcpy (&inferior_registers, registers, 20 * 4);

  memcpy (inferior_fp_registers.f_st,
	  &registers[REGISTER_BYTE (FP0_REGNUM)],
	  sizeof inferior_fp_registers.f_st);
  memcpy (&inferior_fp_registers.f_ctrl,
	  &registers[REGISTER_BYTE (FPC_REGNUM)],
	  sizeof inferior_fp_registers - sizeof inferior_fp_registers.f_st);

#ifdef PTRACE_FP_BUG
  if (regno == FP_REGNUM || regno == -1)
    /* Storing the frame pointer requires a gross hack, in which an
       instruction that moves eax into ebp gets single-stepped.  */
    {
      int stack = inferior_registers.r_reg[SP_REGNUM];
      int stuff = ptrace (PTRACE_PEEKDATA, inferior_pid,
			  (PTRACE_ARG3_TYPE) stack);
      int reg = inferior_registers.r_reg[EAX];
      inferior_registers.r_reg[EAX] =
	inferior_registers.r_reg[FP_REGNUM];
      ptrace (PTRACE_SETREGS, inferior_pid,
	      (PTRACE_ARG3_TYPE) & inferior_registers);
      ptrace (PTRACE_POKEDATA, inferior_pid, (PTRACE_ARG3_TYPE) stack,
	      0xc589);
      ptrace (PTRACE_SINGLESTEP, inferior_pid, (PTRACE_ARG3_TYPE) stack,
	      0);
      wait (0);
      ptrace (PTRACE_POKEDATA, inferior_pid, (PTRACE_ARG3_TYPE) stack,
	      stuff);
      inferior_registers.r_reg[EAX] = reg;
    }
#endif
  ptrace (PTRACE_SETREGS, inferior_pid,
	  (PTRACE_ARG3_TYPE) & inferior_registers);
  ptrace (PTRACE_SETFPREGS, inferior_pid,
	  (PTRACE_ARG3_TYPE) & inferior_fp_registers);
}
@


1.4
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1986, 1987, 1989, 1991, 1992, 2001 Free Software
   Foundation, Inc.
@


1.3
log
@Replace free() with xfree().
@
text
@d2 2
a3 1
   Copyright (C) 1986, 1987, 1989, 1991, 1992 Free Software Foundation, Inc.
d28 1
@


1.2
log
@Protoization.
@
text
@d56 1
a56 1
    free (corefile);
d73 1
a73 1
      make_cleanup (free, filename);
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
This file is part of GDB.
d8 14
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d41 1
a42 1

d45 1
a46 1

d48 1
a48 3
core_file_command (filename, from_tty)
     char *filename;
     int from_tty;
a50 1
  extern char registers[];
d74 1
a74 1
      
d91 2
a92 2
	  error ("\"%s\" has an invalid struct core length (%d, expected %d)",
		 filename, corestr.c_len, (int) sizeof (struct core));
d103 2
a104 2
	       corestr.c_fpu.f_fpstatus.f_st,
	       sizeof corestr.c_fpu.f_fpstatus.f_st);
d106 3
a108 3
	       &corestr.c_fpu.f_fpstatus.f_ctrl,
	       sizeof corestr.c_fpu.f_fpstatus -
	       sizeof corestr.c_fpu.f_fpstatus.f_st);
d115 1
a115 1
	core_aouthdr.vstamp = /*SUNVERSION*/ 31252;
d120 1
a120 1
		  corestr.c_signo, safe_strsignal (corestr.c_signo));
d138 1
a138 3
i387_to_double (from, to)
     char *from;
     char *to;
d142 1
a142 1
   *
d146 1
a146 1
  asm ("pushl %eax"); 		/* grab a stack slot */
d149 1
a149 1
  asm ("orl $0x3f,%eax");		/* mask all exceptions */
d152 1
a152 1
  
d159 1
a159 1
  
d161 1
a161 1
  asm ("fnclex");			/* clear exceptions */
d166 1
a166 3
double_to_i387 (from, to)
     char *from;
     char *to;
d181 1
a181 2
fetch_inferior_registers (regno)
     int regno;
a184 1
  extern char registers[];
d189 1
a189 1
	  (PTRACE_ARG3_TYPE) &inferior_registers);
d191 1
a191 1
	  (PTRACE_ARG3_TYPE) &inferior_fp_registers);
d195 2
a196 2
  memcpy (&registers[REGISTER_BYTE (FP0_REGNUM)],inferior_fp_registers.f_st,
	 sizeof inferior_fp_registers.f_st);
d198 2
a199 2
	 &inferior_fp_registers.f_ctrl,
	 sizeof inferior_fp_registers - sizeof inferior_fp_registers.f_st);
d207 1
a207 2
store_inferior_registers (regno)
     int regno;
a210 1
  extern char registers[];
d215 2
a216 2
	 &registers[REGISTER_BYTE (FP0_REGNUM)],
	 sizeof inferior_fp_registers.f_st);
d218 3
a220 3
	 &registers[REGISTER_BYTE (FPC_REGNUM)],
	 sizeof inferior_fp_registers - sizeof inferior_fp_registers.f_st);
  
d232 2
a233 2
      ptrace (PTRACE_SETREGS, inferior_pid, 
	      (PTRACE_ARG3_TYPE) &inferior_registers);
d245 1
a245 1
	  (PTRACE_ARG3_TYPE) &inferior_registers);
d247 1
a247 1
	  (PTRACE_ARG3_TYPE) &inferior_fp_registers);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d52 1
d192 1
d220 1
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d6 1
a6 1
   This file is part of GDB.
d8 13
a20 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d40 1
a41 1

d44 1
a45 1

d75 1
a75 1

d92 2
a93 2
	    error ("\"%s\" has an invalid struct core length (%d, expected %d)",
		   filename, corestr.c_len, (int) sizeof (struct core));
d104 2
a105 2
		corestr.c_fpu.f_fpstatus.f_st,
		sizeof corestr.c_fpu.f_fpstatus.f_st);
d107 3
a109 3
		&corestr.c_fpu.f_fpstatus.f_ctrl,
		sizeof corestr.c_fpu.f_fpstatus -
		sizeof corestr.c_fpu.f_fpstatus.f_st);
d116 1
a116 1
	core_aouthdr.vstamp = /*SUNVERSION */ 31252;
d121 1
a121 1
			 corestr.c_signo, safe_strsignal (corestr.c_signo));
d145 1
a145 1

d149 1
a149 1
  asm ("pushl %eax");		/* grab a stack slot */
d152 1
a152 1
  asm ("orl $0x3f,%eax");	/* mask all exceptions */
d155 1
a155 1

d162 1
a162 1

d164 1
a164 1
  asm ("fnclex");		/* clear exceptions */
d195 1
a195 1
	  (PTRACE_ARG3_TYPE) & inferior_registers);
d197 1
a197 1
	  (PTRACE_ARG3_TYPE) & inferior_fp_registers);
d201 2
a202 2
  memcpy (&registers[REGISTER_BYTE (FP0_REGNUM)], inferior_fp_registers.f_st,
	  sizeof inferior_fp_registers.f_st);
d204 2
a205 2
	  &inferior_fp_registers.f_ctrl,
	  sizeof inferior_fp_registers - sizeof inferior_fp_registers.f_st);
d222 2
a223 2
	  &registers[REGISTER_BYTE (FP0_REGNUM)],
	  sizeof inferior_fp_registers.f_st);
d225 3
a227 3
	  &registers[REGISTER_BYTE (FPC_REGNUM)],
	  sizeof inferior_fp_registers - sizeof inferior_fp_registers.f_st);

d239 2
a240 2
      ptrace (PTRACE_SETREGS, inferior_pid,
	      (PTRACE_ARG3_TYPE) & inferior_registers);
d252 1
a252 1
	  (PTRACE_ARG3_TYPE) & inferior_registers);
d254 1
a254 1
	  (PTRACE_ARG3_TYPE) & inferior_fp_registers);
@

