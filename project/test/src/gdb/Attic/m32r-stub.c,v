head	1.9;
access;
symbols
	gdb_7_4_1-2012-04-26-release:1.8
	gdb_7_4-2012-01-24-release:1.8
	gdb_7_4-branch:1.8.0.42
	gdb_7_4-2011-12-13-branchpoint:1.8
	gdb_7_3_1-2011-09-04-release:1.8
	gdb_7_3-2011-07-26-release:1.8
	gdb_7_3-branch:1.8.0.40
	gdb_7_3-2011-04-01-branchpoint:1.8
	gdb_7_2-2010-09-02-release:1.8
	gdb_7_2-branch:1.8.0.38
	gdb_7_2-2010-07-07-branchpoint:1.8
	gdb_7_1-2010-03-18-release:1.8
	gdb_7_1-branch:1.8.0.36
	gdb_7_1-2010-02-18-branchpoint:1.8
	gdb_7_0_1-2009-12-22-release:1.8
	gdb_7_0-2009-10-06-release:1.8
	gdb_7_0-branch:1.8.0.34
	gdb_7_0-2009-09-16-branchpoint:1.8
	arc-sim-20090309:1.8
	msnyder-checkpoint-072509-branch:1.8.0.32
	msnyder-checkpoint-072509-branchpoint:1.8
	arc-insight_6_8-branch:1.8.0.30
	arc-insight_6_8-branchpoint:1.8
	insight_6_8-branch:1.8.0.28
	insight_6_8-branchpoint:1.8
	reverse-20081226-branch:1.8.0.26
	reverse-20081226-branchpoint:1.8
	multiprocess-20081120-branch:1.8.0.24
	multiprocess-20081120-branchpoint:1.8
	reverse-20080930-branch:1.8.0.22
	reverse-20080930-branchpoint:1.8
	reverse-20080717-branch:1.8.0.20
	reverse-20080717-branchpoint:1.8
	msnyder-reverse-20080609-branch:1.8.0.18
	msnyder-reverse-20080609-branchpoint:1.8
	drow-reverse-20070409-branch:1.8.0.16
	drow-reverse-20070409-branchpoint:1.8
	gdb_6_8-2008-03-27-release:1.8
	gdb_6_8-branch:1.8.0.14
	gdb_6_8-2008-02-26-branchpoint:1.8
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	gdb_6_7-branch:1.8.0.12
	gdb_6_7-2007-09-07-branchpoint:1.8
	insight_6_6-20070208-release:1.8
	gdb_6_6-2006-12-18-release:1.8
	gdb_6_6-branch:1.8.0.10
	gdb_6_6-2006-11-15-branchpoint:1.8
	insight_6_5-20061003-release:1.8
	gdb-csl-symbian-6_4_50_20060226-12:1.7
	gdb-csl-sourcerygxx-3_4_4-25:1.7
	nickrob-async-20060828-mergepoint:1.8
	gdb-csl-symbian-6_4_50_20060226-11:1.7
	gdb-csl-sourcerygxx-4_1-17:1.7
	gdb-csl-20060226-branch-local-2:1.7
	gdb-csl-sourcerygxx-4_1-14:1.7
	gdb-csl-sourcerygxx-4_1-13:1.7
	gdb-csl-sourcerygxx-4_1-12:1.7
	gdb-csl-sourcerygxx-3_4_4-21:1.7
	gdb_6_5-20060621-release:1.8
	gdb-csl-sourcerygxx-4_1-9:1.7
	gdb-csl-sourcerygxx-4_1-8:1.7
	gdb-csl-sourcerygxx-4_1-7:1.7
	gdb-csl-arm-2006q1-6:1.7
	gdb-csl-sourcerygxx-4_1-6:1.7
	gdb-csl-symbian-6_4_50_20060226-10:1.7
	gdb-csl-symbian-6_4_50_20060226-9:1.7
	gdb-csl-symbian-6_4_50_20060226-8:1.7
	gdb-csl-coldfire-4_1-11:1.7
	gdb-csl-sourcerygxx-3_4_4-19:1.7
	gdb-csl-coldfire-4_1-10:1.7
	gdb_6_5-branch:1.8.0.8
	gdb_6_5-2006-05-14-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-5:1.7
	nickrob-async-20060513-branch:1.8.0.6
	nickrob-async-20060513-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-4:1.7
	msnyder-reverse-20060502-branch:1.8.0.4
	msnyder-reverse-20060502-branchpoint:1.8
	gdb-csl-morpho-4_1-4:1.7
	gdb-csl-sourcerygxx-3_4_4-17:1.7
	readline_5_1-import-branch:1.8.0.2
	readline_5_1-import-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.7
	gdb-csl-symbian-20060226-branch:1.7.0.44
	gdb-csl-symbian-20060226-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.7
	msnyder-reverse-20060331-branch:1.7.0.42
	msnyder-reverse-20060331-branchpoint:1.7
	gdb-csl-available-20060303-branch:1.7.0.40
	gdb-csl-available-20060303-branchpoint:1.7
	gdb-csl-20060226-branch:1.7.0.38
	gdb-csl-20060226-branchpoint:1.7
	gdb_6_4-20051202-release:1.7
	msnyder-fork-checkpoint-branch:1.7.0.36
	msnyder-fork-checkpoint-branchpoint:1.7
	gdb-csl-gxxpro-6_3-branch:1.7.0.34
	gdb-csl-gxxpro-6_3-branchpoint:1.7
	gdb_6_4-branch:1.7.0.32
	gdb_6_4-2005-11-01-branchpoint:1.7
	gdb-csl-arm-20051020-branch:1.7.0.30
	gdb-csl-arm-20051020-branchpoint:1.7
	msnyder-tracepoint-checkpoint-branch:1.7.0.28
	msnyder-tracepoint-checkpoint-branchpoint:1.7
	gdb-csl-arm-20050325-2005-q1b:1.7
	gdb-csl-arm-20050325-2005-q1a:1.7
	csl-arm-20050325-branch:1.7.0.26
	csl-arm-20050325-branchpoint:1.7
	gdb-post-i18n-errorwarning-20050211:1.7
	gdb-pre-i18n-errorwarning-20050211:1.7
	gdb_6_3-20041109-release:1.7
	gdb_6_3-branch:1.7.0.22
	gdb_6_3-20041019-branchpoint:1.7
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.7.0.24
	jimb-gdb_6_2-e500-branchpoint:1.7
	gdb_6_2-20040730-release:1.7
	gdb_6_2-branch:1.7.0.20
	gdb_6_2-2004-07-10-gmt-branchpoint:1.7
	gdb_6_1_1-20040616-release:1.7
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.18
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.16
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.14
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.12
	drow_intercu-20040221-branchpoint:1.7
	cagney_bfdfile-20040213-branch:1.7.0.10
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.7
	cagney_bigcore-20040122-branch:1.7.0.8
	cagney_bigcore-20040122-branchpoint:1.7
	drow-cplus-merge-20040113:1.7
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.7
	gdb_6_0-2003-10-04-release:1.6.30.1
	kettenis_sparc-20030918-branch:1.7.0.6
	kettenis_sparc-20030918-branchpoint:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.4
	cagney_x86i386-20030821-branch:1.7.0.2
	cagney_x86i386-20030821-branchpoint:1.7
	carlton_dictionary-20030805-merge:1.7
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.30
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.26
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.24
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.20
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.16
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.14
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.12
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.10
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.8
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.6
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.4
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.2
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030203-mergepoint:1.5
	interps-20030202-branch:1.5.0.6
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.4
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.2
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.2
	carlton_dictionary-20020920-branchpoint:1.4
	gdb_5_3-branch:1.3.0.22
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.20
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.18
	readline_4_3-import-branchpoint:1.3
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.3.0.16
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.14
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.12
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.10
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.8
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.6
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.4
	gdb_5_1-2001-07-29-branchpoint:1.3
	dberlin-typesystem-branch:1.3.0.2
	dberlin-typesystem-branchpoint:1.3
	gdb-post-ptid_t-2001-05-03:1.3
	gdb-pre-ptid_t-2001-05-03:1.3
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.6
	gdb-1999-11-16:1.1.1.6
	gdb-1999-11-08:1.1.1.6
	gdb-1999-11-01:1.1.1.6
	gdb-1999-10-25:1.1.1.6
	gdb-1999-10-18:1.1.1.6
	gdb-1999-10-11:1.1.1.6
	gdb-1999-10-04:1.1.1.6
	gdb-1999-09-28:1.1.1.6
	gdb-1999-09-21:1.1.1.5
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.5
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.9
date	2012.03.08.14.43.23;	author gingold;	state dead;
branches;
next	1.8;

1.8
date	2006.03.30.16.44.12;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.21.18.56.05;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.04.23.26.43;	author cagney;	state Exp;
branches
	1.6.30.1;
next	1.5;

1.5
date	2002.10.04.22.17.36;	author msnyder;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.09.17.22.58.01;	author msnyder;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches
	1.3.16.1;
next	1.2;

1.2
date	2000.02.09.03.06.33;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.41;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.23.22.35.22;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.08.31.01.05.27;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.09.08.23.59.19;	author shebs;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.09.28.21.52.18;	author jsm;	state Exp;
branches;
next	;

1.3.16.1
date	2002.10.01.00.46.10;	author kseitz;	state Exp;
branches;
next	1.3.16.2;

1.3.16.2
date	2002.11.04.00.17.32;	author ezannoni;	state Exp;
branches;
next	;

1.4.2.1
date	2002.10.11.22.22.55;	author carlton;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2003.02.07.19.17.50;	author carlton;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2003.08.05.17.13.10;	author carlton;	state Exp;
branches;
next	;

1.5.2.1
date	2003.12.14.20.27.20;	author drow;	state Exp;
branches;
next	;

1.6.30.1
date	2003.08.01.21.56.58;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.9
log
@gdb/
2012-03-08  Tristan Gingold  <gingold@@adacore.com>

	* sparc-stub.c: Move to stubs/
	* sh-stub.c: Likewise.
	* m68k-stub.c: Likewise.
	* m32r-stub.c: Likewise.
	* i386-stub.c: Likewise.

gdb/stubs/
2012-03-08  Tristan Gingold  <gingold@@adacore.com>

	* sparc-stub.c: Move from ..
	* sh-stub.c: Likewise.
	* m68k-stub.c: Likewise.
	* m32r-stub.c: Likewise.
	* i386-stub.c: Likewise.
@
text
@/****************************************************************************

		THIS SOFTWARE IS NOT COPYRIGHTED

   HP offers the following for use in the public domain.  HP makes no
   warranty with regard to the software or it's performance and the
   user accepts the software "AS IS" with all faults.

   HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD
   TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES
   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

****************************************************************************/

/****************************************************************************
 *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $
 *
 *  Module name: remcom.c $
 *  Revision: 1.34 $
 *  Date: 91/03/09 12:29:49 $
 *  Contributor:     Lake Stevens Instrument Division$
 *
 *  Description:     low level support for gdb debugger. $
 *
 *  Considerations:  only works on target hardware $
 *
 *  Written by:      Glenn Engel $
 *  ModuleState:     Experimental $
 *
 *  NOTES:           See Below $
 *
 *  Modified for M32R by Michael Snyder, Cygnus Support.
 *
 *  To enable debugger support, two things need to happen.  One, a
 *  call to set_debug_traps() is necessary in order to allow any breakpoints
 *  or error conditions to be properly intercepted and reported to gdb.
 *  Two, a breakpoint needs to be generated to begin communication.  This
 *  is most easily accomplished by a call to breakpoint().  Breakpoint()
 *  simulates a breakpoint by executing a trap #1.
 *
 *  The external function exceptionHandler() is
 *  used to attach a specific handler to a specific M32R vector number.
 *  It should use the same privilege level it runs at.  It should
 *  install it as an interrupt gate so that interrupts are masked
 *  while the handler runs.
 *
 *  Because gdb will sometimes write to the stack area to execute function
 *  calls, this program cannot rely on using the supervisor stack so it
 *  uses it's own stack area reserved in the int array remcomStack.
 *
 *************
 *
 *    The following gdb commands are supported:
 *
 * command          function                               Return value
 *
 *    g             return the value of the CPU registers  hex data or ENN
 *    G             set the value of the CPU registers     OK or ENN
 *
 *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN
 *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN
 *    XAA..AA,LLLL: Write LLLL binary bytes at address     OK or ENN
 *                  AA..AA
 *
 *    c             Resume at current address              SNN   ( signal NN)
 *    cAA..AA       Continue at address AA..AA             SNN
 *
 *    s             Step one instruction                   SNN
 *    sAA..AA       Step one instruction from AA..AA       SNN
 *
 *    k             kill
 *
 *    ?             What was the last sigval ?             SNN   (signal NN)
 *
 * All commands and responses are sent with a packet which includes a
 * checksum.  A packet consists of
 *
 * $<packet info>#<checksum>.
 *
 * where
 * <packet info> :: <characters representing the command or response>
 * <checksum>    :: <two hex digits computed as modulo 256 sum of <packetinfo>>
 *
 * When a packet is received, it is first acknowledged with either '+' or '-'.
 * '+' indicates a successful transfer.  '-' indicates a failed transfer.
 *
 * Example:
 *
 * Host:                  Reply:
 * $m0,10#2a               +$00010203040506070809101112131415#42
 *
 ****************************************************************************/


/************************************************************************
 *
 * external low-level support routines
 */
extern void putDebugChar ();	/* write a single character      */
extern int getDebugChar ();	/* read and return a single char */
extern void exceptionHandler ();	/* assign an exception handler   */

/*****************************************************************************
 * BUFMAX defines the maximum number of characters in inbound/outbound buffers
 * at least NUMREGBYTES*2 are needed for register packets 
 */
#define BUFMAX 400

static char initialized;	/* boolean flag. != 0 means we've been initialized */

int remote_debug;
/*  debug >  0 prints ill-formed commands in valid packets & checksum errors */

static const unsigned char hexchars[] = "0123456789abcdef";

#define NUMREGS 24

/* Number of bytes of registers.  */
#define NUMREGBYTES (NUMREGS * 4)
enum regnames
{ R0, R1, R2, R3, R4, R5, R6, R7,
  R8, R9, R10, R11, R12, R13, R14, R15,
  PSW, CBR, SPI, SPU, BPC, PC, ACCL, ACCH
};

enum SYS_calls
{
  SYS_null,
  SYS_exit,
  SYS_open,
  SYS_close,
  SYS_read,
  SYS_write,
  SYS_lseek,
  SYS_unlink,
  SYS_getpid,
  SYS_kill,
  SYS_fstat,
  SYS_sbrk,
  SYS_fork,
  SYS_execve,
  SYS_wait4,
  SYS_link,
  SYS_chdir,
  SYS_stat,
  SYS_utime,
  SYS_chown,
  SYS_chmod,
  SYS_time,
  SYS_pipe
};

static int registers[NUMREGS];

#define STACKSIZE 8096
static unsigned char remcomInBuffer[BUFMAX];
static unsigned char remcomOutBuffer[BUFMAX];
static int remcomStack[STACKSIZE / sizeof (int)];
static int *stackPtr = &remcomStack[STACKSIZE / sizeof (int) - 1];

static unsigned int save_vectors[18];	/* previous exception vectors */

/* Indicate to caller of mem2hex or hex2mem that there has been an error. */
static volatile int mem_err = 0;

/* Store the vector number here (since GDB only gets the signal
   number through the usual means, and that's not very specific).  */
int gdb_m32r_vector = -1;

#if 0
#include "syscall.h"		/* for SYS_exit, SYS_write etc. */
#endif

/* Global entry points:
 */

extern void handle_exception (int);
extern void set_debug_traps (void);
extern void breakpoint (void);

/* Local functions:
 */

static int computeSignal (int);
static void putpacket (unsigned char *);
static unsigned char *getpacket (void);

static unsigned char *mem2hex (unsigned char *, unsigned char *, int, int);
static unsigned char *hex2mem (unsigned char *, unsigned char *, int, int);
static int hexToInt (unsigned char **, int *);
static unsigned char *bin2mem (unsigned char *, unsigned char *, int, int);
static void stash_registers (void);
static void restore_registers (void);
static int prepare_to_step (int);
static int finish_from_step (void);
static unsigned long crc32 (unsigned char *, int, unsigned long);

static void gdb_error (char *, char *);
static int gdb_putchar (int), gdb_puts (char *), gdb_write (char *, int);

static unsigned char *strcpy (unsigned char *, const unsigned char *);
static int strlen (const unsigned char *);

/*
 * This function does all command procesing for interfacing to gdb.
 */

void
handle_exception (int exceptionVector)
{
  int sigval, stepping;
  int addr, length, i;
  unsigned char *ptr;
  unsigned char buf[16];
  int binary;

  if (!finish_from_step ())
    return;			/* "false step": let the target continue */

  gdb_m32r_vector = exceptionVector;

  if (remote_debug)
    {
      mem2hex ((unsigned char *) &exceptionVector, buf, 4, 0);
      gdb_error ("Handle exception %s, ", buf);
      mem2hex ((unsigned char *) &registers[PC], buf, 4, 0);
      gdb_error ("PC == 0x%s\n", buf);
    }

  /* reply to host that an exception has occurred */
  sigval = computeSignal (exceptionVector);

  ptr = remcomOutBuffer;

  *ptr++ = 'T';			/* notify gdb with signo, PC, FP and SP */
  *ptr++ = hexchars[sigval >> 4];
  *ptr++ = hexchars[sigval & 0xf];

  *ptr++ = hexchars[PC >> 4];
  *ptr++ = hexchars[PC & 0xf];
  *ptr++ = ':';
  ptr = mem2hex ((unsigned char *) &registers[PC], ptr, 4, 0);	/* PC */
  *ptr++ = ';';

  *ptr++ = hexchars[R13 >> 4];
  *ptr++ = hexchars[R13 & 0xf];
  *ptr++ = ':';
  ptr = mem2hex ((unsigned char *) &registers[R13], ptr, 4, 0);	/* FP */
  *ptr++ = ';';

  *ptr++ = hexchars[R15 >> 4];
  *ptr++ = hexchars[R15 & 0xf];
  *ptr++ = ':';
  ptr = mem2hex ((unsigned char *) &registers[R15], ptr, 4, 0);	/* SP */
  *ptr++ = ';';
  *ptr++ = 0;

  if (exceptionVector == 0)	/* simulated SYS call stuff */
    {
      mem2hex ((unsigned char *) &registers[PC], buf, 4, 0);
      switch (registers[R0])
	{
	case SYS_exit:
	  gdb_error ("Target program has exited at %s\n", buf);
	  ptr = remcomOutBuffer;
	  *ptr++ = 'W';
	  sigval = registers[R1] & 0xff;
	  *ptr++ = hexchars[sigval >> 4];
	  *ptr++ = hexchars[sigval & 0xf];
	  *ptr++ = 0;
	  break;
	case SYS_open:
	  gdb_error ("Target attempts SYS_open call at %s\n", buf);
	  break;
	case SYS_close:
	  gdb_error ("Target attempts SYS_close call at %s\n", buf);
	  break;
	case SYS_read:
	  gdb_error ("Target attempts SYS_read call at %s\n", buf);
	  break;
	case SYS_write:
	  if (registers[R1] == 1 ||	/* write to stdout  */
	      registers[R1] == 2)	/* write to stderr  */
	    {			/* (we can do that) */
	      registers[R0] =
		gdb_write ((void *) registers[R2], registers[R3]);
	      return;
	    }
	  else
	    gdb_error ("Target attempts SYS_write call at %s\n", buf);
	  break;
	case SYS_lseek:
	  gdb_error ("Target attempts SYS_lseek call at %s\n", buf);
	  break;
	case SYS_unlink:
	  gdb_error ("Target attempts SYS_unlink call at %s\n", buf);
	  break;
	case SYS_getpid:
	  gdb_error ("Target attempts SYS_getpid call at %s\n", buf);
	  break;
	case SYS_kill:
	  gdb_error ("Target attempts SYS_kill call at %s\n", buf);
	  break;
	case SYS_fstat:
	  gdb_error ("Target attempts SYS_fstat call at %s\n", buf);
	  break;
	default:
	  gdb_error ("Target attempts unknown SYS call at %s\n", buf);
	  break;
	}
    }

  putpacket (remcomOutBuffer);

  stepping = 0;

  while (1 == 1)
    {
      remcomOutBuffer[0] = 0;
      ptr = getpacket ();
      binary = 0;
      switch (*ptr++)
	{
	default:		/* Unknown code.  Return an empty reply message. */
	  break;
	case 'R':
	  if (hexToInt (&ptr, &addr))
	    registers[PC] = addr;
	  strcpy (remcomOutBuffer, "OK");
	  break;
	case '!':
	  strcpy (remcomOutBuffer, "OK");
	  break;
	case 'X':		/* XAA..AA,LLLL:<binary data>#cs */
	  binary = 1;
	case 'M':		/* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
	  /* TRY TO READ '%x,%x:'.  IF SUCCEED, SET PTR = 0 */
	  {
	    if (hexToInt (&ptr, &addr))
	      if (*(ptr++) == ',')
		if (hexToInt (&ptr, &length))
		  if (*(ptr++) == ':')
		    {
		      mem_err = 0;
		      if (binary)
			bin2mem (ptr, (unsigned char *) addr, length, 1);
		      else
			hex2mem (ptr, (unsigned char *) addr, length, 1);
		      if (mem_err)
			{
			  strcpy (remcomOutBuffer, "E03");
			  gdb_error ("memory fault", "");
			}
		      else
			{
			  strcpy (remcomOutBuffer, "OK");
			}
		      ptr = 0;
		    }
	    if (ptr)
	      {
		strcpy (remcomOutBuffer, "E02");
	      }
	  }
	  break;
	case 'm':		/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
	  /* TRY TO READ %x,%x.  IF SUCCEED, SET PTR = 0 */
	  if (hexToInt (&ptr, &addr))
	    if (*(ptr++) == ',')
	      if (hexToInt (&ptr, &length))
		{
		  ptr = 0;
		  mem_err = 0;
		  mem2hex ((unsigned char *) addr, remcomOutBuffer, length,
			   1);
		  if (mem_err)
		    {
		      strcpy (remcomOutBuffer, "E03");
		      gdb_error ("memory fault", "");
		    }
		}
	  if (ptr)
	    {
	      strcpy (remcomOutBuffer, "E01");
	    }
	  break;
	case '?':
	  remcomOutBuffer[0] = 'S';
	  remcomOutBuffer[1] = hexchars[sigval >> 4];
	  remcomOutBuffer[2] = hexchars[sigval % 16];
	  remcomOutBuffer[3] = 0;
	  break;
	case 'd':
	  remote_debug = !(remote_debug);	/* toggle debug flag */
	  break;
	case 'g':		/* return the value of the CPU registers */
	  mem2hex ((unsigned char *) registers, remcomOutBuffer, NUMREGBYTES,
		   0);
	  break;
	case 'P':		/* set the value of a single CPU register - return OK */
	  {
	    int regno;

	    if (hexToInt (&ptr, &regno) && *ptr++ == '=')
	      if (regno >= 0 && regno < NUMREGS)
		{
		  int stackmode;

		  hex2mem (ptr, (unsigned char *) &registers[regno], 4, 0);
		  /*
		   * Since we just changed a single CPU register, let's
		   * make sure to keep the several stack pointers consistant.
		   */
		  stackmode = registers[PSW] & 0x80;
		  if (regno == R15)	/* stack pointer changed */
		    {		/* need to change SPI or SPU */
		      if (stackmode == 0)
			registers[SPI] = registers[R15];
		      else
			registers[SPU] = registers[R15];
		    }
		  else if (regno == SPU)	/* "user" stack pointer changed */
		    {
		      if (stackmode != 0)	/* stack in user mode: copy SP */
			registers[R15] = registers[SPU];
		    }
		  else if (regno == SPI)	/* "interrupt" stack pointer changed */
		    {
		      if (stackmode == 0)	/* stack in interrupt mode: copy SP */
			registers[R15] = registers[SPI];
		    }
		  else if (regno == PSW)	/* stack mode may have changed! */
		    {		/* force SP to either SPU or SPI */
		      if (stackmode == 0)	/* stack in user mode */
			registers[R15] = registers[SPI];
		      else	/* stack in interrupt mode */
			registers[R15] = registers[SPU];
		    }
		  strcpy (remcomOutBuffer, "OK");
		  break;
		}
	    strcpy (remcomOutBuffer, "E01");
	    break;
	  }
	case 'G':		/* set the value of the CPU registers - return OK */
	  hex2mem (ptr, (unsigned char *) registers, NUMREGBYTES, 0);
	  strcpy (remcomOutBuffer, "OK");
	  break;
	case 's':		/* sAA..AA      Step one instruction from AA..AA(optional) */
	  stepping = 1;
	case 'c':		/* cAA..AA      Continue from address AA..AA(optional) */
	  /* try to read optional parameter, pc unchanged if no parm */
	  if (hexToInt (&ptr, &addr))
	    registers[PC] = addr;

	  if (stepping)		/* single-stepping */
	    {
	      if (!prepare_to_step (0))	/* set up for single-step */
		{
		  /* prepare_to_step has already emulated the target insn:
		     Send SIGTRAP to gdb, don't resume the target at all.  */
		  ptr = remcomOutBuffer;
		  *ptr++ = 'T';	/* Simulate stopping with SIGTRAP */
		  *ptr++ = '0';
		  *ptr++ = '5';

		  *ptr++ = hexchars[PC >> 4];	/* send PC */
		  *ptr++ = hexchars[PC & 0xf];
		  *ptr++ = ':';
		  ptr = mem2hex ((unsigned char *) &registers[PC], ptr, 4, 0);
		  *ptr++ = ';';

		  *ptr++ = hexchars[R13 >> 4];	/* send FP */
		  *ptr++ = hexchars[R13 & 0xf];
		  *ptr++ = ':';
		  ptr =
		    mem2hex ((unsigned char *) &registers[R13], ptr, 4, 0);
		  *ptr++ = ';';

		  *ptr++ = hexchars[R15 >> 4];	/* send SP */
		  *ptr++ = hexchars[R15 & 0xf];
		  *ptr++ = ':';
		  ptr =
		    mem2hex ((unsigned char *) &registers[R15], ptr, 4, 0);
		  *ptr++ = ';';
		  *ptr++ = 0;

		  break;
		}
	    }
	  else			/* continuing, not single-stepping */
	    {
	      /* OK, about to do a "continue".  First check to see if the 
	         target pc is on an odd boundary (second instruction in the 
	         word).  If so, we must do a single-step first, because 
	         ya can't jump or return back to an odd boundary!  */
	      if ((registers[PC] & 2) != 0)
		prepare_to_step (1);
	    }

	  return;

	case 'D':		/* Detach */
#if 0
	  /* I am interpreting this to mean, release the board from control 
	     by the remote stub.  To do this, I am restoring the original
	     (or at least previous) exception vectors.
	   */
	  for (i = 0; i < 18; i++)
	    exceptionHandler (i, save_vectors[i]);
	  putpacket ("OK");
	  return;		/* continue the inferior */
#else
	  strcpy (remcomOutBuffer, "OK");
	  break;
#endif
	case 'q':
	  if (*ptr++ == 'C' &&
	      *ptr++ == 'R' && *ptr++ == 'C' && *ptr++ == ':')
	    {
	      unsigned long start, len, our_crc;

	      if (hexToInt (&ptr, (int *) &start) &&
		  *ptr++ == ',' && hexToInt (&ptr, (int *) &len))
		{
		  remcomOutBuffer[0] = 'C';
		  our_crc = crc32 ((unsigned char *) start, len, 0xffffffff);
		  mem2hex ((char *) &our_crc,
			   &remcomOutBuffer[1], sizeof (long), 0);
		}		/* else do nothing */
	    }			/* else do nothing */
	  break;

	case 'k':		/* kill the program */
	  continue;
	}			/* switch */

      /* reply to the request */
      putpacket (remcomOutBuffer);
    }
}

/* qCRC support */

/* Table used by the crc32 function to calcuate the checksum. */
static unsigned long crc32_table[256] = { 0, 0 };

static unsigned long
crc32 (unsigned char *buf, int len, unsigned long crc)
{
  if (!crc32_table[1])
    {
      /* Initialize the CRC table and the decoding table. */
      int i, j;
      unsigned long c;

      for (i = 0; i < 256; i++)
	{
	  for (c = i << 24, j = 8; j > 0; --j)
	    c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : (c << 1);
	  crc32_table[i] = c;
	}
    }

  while (len--)
    {
      crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ *buf) & 255];
      buf++;
    }
  return crc;
}

static int
hex (unsigned char ch)
{
  if ((ch >= 'a') && (ch <= 'f'))
    return (ch - 'a' + 10);
  if ((ch >= '0') && (ch <= '9'))
    return (ch - '0');
  if ((ch >= 'A') && (ch <= 'F'))
    return (ch - 'A' + 10);
  return (-1);
}

/* scan for the sequence $<data>#<checksum>     */

unsigned char *
getpacket (void)
{
  unsigned char *buffer = &remcomInBuffer[0];
  unsigned char checksum;
  unsigned char xmitcsum;
  int count;
  char ch;

  while (1)
    {
      /* wait around for the start character, ignore all other characters */
      while ((ch = getDebugChar ()) != '$')
	;

    retry:
      checksum = 0;
      xmitcsum = -1;
      count = 0;

      /* now, read until a # or end of buffer is found */
      while (count < BUFMAX - 1)
	{
	  ch = getDebugChar ();
	  if (ch == '$')
	    goto retry;
	  if (ch == '#')
	    break;
	  checksum = checksum + ch;
	  buffer[count] = ch;
	  count = count + 1;
	}
      buffer[count] = 0;

      if (ch == '#')
	{
	  ch = getDebugChar ();
	  xmitcsum = hex (ch) << 4;
	  ch = getDebugChar ();
	  xmitcsum += hex (ch);

	  if (checksum != xmitcsum)
	    {
	      if (remote_debug)
		{
		  unsigned char buf[16];

		  mem2hex ((unsigned char *) &checksum, buf, 4, 0);
		  gdb_error ("Bad checksum: my count = %s, ", buf);
		  mem2hex ((unsigned char *) &xmitcsum, buf, 4, 0);
		  gdb_error ("sent count = %s\n", buf);
		  gdb_error (" -- Bad buffer: \"%s\"\n", buffer);
		}
	      putDebugChar ('-');	/* failed checksum */
	    }
	  else
	    {
	      putDebugChar ('+');	/* successful transfer */

	      /* if a sequence char is present, reply the sequence ID */
	      if (buffer[2] == ':')
		{
		  putDebugChar (buffer[0]);
		  putDebugChar (buffer[1]);

		  return &buffer[3];
		}

	      return &buffer[0];
	    }
	}
    }
}

/* send the packet in buffer.  */

static void
putpacket (unsigned char *buffer)
{
  unsigned char checksum;
  int count;
  char ch;

  /*  $<packet info>#<checksum>. */
  do
    {
      putDebugChar ('$');
      checksum = 0;
      count = 0;

      while (ch = buffer[count])
	{
	  putDebugChar (ch);
	  checksum += ch;
	  count += 1;
	}
      putDebugChar ('#');
      putDebugChar (hexchars[checksum >> 4]);
      putDebugChar (hexchars[checksum % 16]);
    }
  while (getDebugChar () != '+');
}

/* Address of a routine to RTE to if we get a memory fault.  */

static void (*volatile mem_fault_routine) () = 0;

static void
set_mem_err (void)
{
  mem_err = 1;
}

/* Check the address for safe access ranges.  As currently defined,
   this routine will reject the "expansion bus" address range(s).
   To make those ranges useable, someone must implement code to detect
   whether there's anything connected to the expansion bus. */

static int
mem_safe (unsigned char *addr)
{
#define BAD_RANGE_ONE_START	((unsigned char *) 0x600000)
#define BAD_RANGE_ONE_END	((unsigned char *) 0xa00000)
#define BAD_RANGE_TWO_START	((unsigned char *) 0xff680000)
#define BAD_RANGE_TWO_END	((unsigned char *) 0xff800000)

  if (addr < BAD_RANGE_ONE_START)
    return 1;			/* safe */
  if (addr < BAD_RANGE_ONE_END)
    return 0;			/* unsafe */
  if (addr < BAD_RANGE_TWO_START)
    return 1;			/* safe */
  if (addr < BAD_RANGE_TWO_END)
    return 0;			/* unsafe */
}

/* These are separate functions so that they are so short and sweet
   that the compiler won't save any registers (if there is a fault
   to mem_fault, they won't get restored, so there better not be any
   saved).  */
static int
get_char (unsigned char *addr)
{
#if 1
  if (mem_fault_routine && !mem_safe (addr))
    {
      mem_fault_routine ();
      return 0;
    }
#endif
  return *addr;
}

static void
set_char (unsigned char *addr, unsigned char val)
{
#if 1
  if (mem_fault_routine && !mem_safe (addr))
    {
      mem_fault_routine ();
      return;
    }
#endif
  *addr = val;
}

/* Convert the memory pointed to by mem into hex, placing result in buf.
   Return a pointer to the last char put in buf (null).
   If MAY_FAULT is non-zero, then we should set mem_err in response to
   a fault; if zero treat a fault like any other fault in the stub.  */

static unsigned char *
mem2hex (unsigned char *mem, unsigned char *buf, int count, int may_fault)
{
  int i;
  unsigned char ch;

  if (may_fault)
    mem_fault_routine = set_mem_err;
  for (i = 0; i < count; i++)
    {
      ch = get_char (mem++);
      if (may_fault && mem_err)
	return (buf);
      *buf++ = hexchars[ch >> 4];
      *buf++ = hexchars[ch % 16];
    }
  *buf = 0;
  if (may_fault)
    mem_fault_routine = 0;
  return (buf);
}

/* Convert the hex array pointed to by buf into binary to be placed in mem.
   Return a pointer to the character AFTER the last byte written. */

static unsigned char *
hex2mem (unsigned char *buf, unsigned char *mem, int count, int may_fault)
{
  int i;
  unsigned char ch;

  if (may_fault)
    mem_fault_routine = set_mem_err;
  for (i = 0; i < count; i++)
    {
      ch = hex (*buf++) << 4;
      ch = ch + hex (*buf++);
      set_char (mem++, ch);
      if (may_fault && mem_err)
	return (mem);
    }
  if (may_fault)
    mem_fault_routine = 0;
  return (mem);
}

/* Convert the binary stream in BUF to memory.

   Gdb will escape $, #, and the escape char (0x7d).
   COUNT is the total number of bytes to write into
   memory. */
static unsigned char *
bin2mem (unsigned char *buf, unsigned char *mem, int count, int may_fault)
{
  int i;
  unsigned char ch;

  if (may_fault)
    mem_fault_routine = set_mem_err;
  for (i = 0; i < count; i++)
    {
      /* Check for any escaped characters. Be paranoid and
         only unescape chars that should be escaped. */
      if (*buf == 0x7d)
	{
	  switch (*(buf + 1))
	    {
	    case 0x3:		/* # */
	    case 0x4:		/* $ */
	    case 0x5d:		/* escape char */
	      buf++;
	      *buf |= 0x20;
	      break;
	    default:
	      /* nothing */
	      break;
	    }
	}

      set_char (mem++, *buf++);

      if (may_fault && mem_err)
	return mem;
    }

  if (may_fault)
    mem_fault_routine = 0;
  return mem;
}

/* this function takes the m32r exception vector and attempts to
   translate this number into a unix compatible signal value */

static int
computeSignal (int exceptionVector)
{
  int sigval;
  switch (exceptionVector)
    {
    case 0:
      sigval = 23;
      break;			/* I/O trap                    */
    case 1:
      sigval = 5;
      break;			/* breakpoint                  */
    case 2:
      sigval = 5;
      break;			/* breakpoint                  */
    case 3:
      sigval = 5;
      break;			/* breakpoint                  */
    case 4:
      sigval = 5;
      break;			/* breakpoint                  */
    case 5:
      sigval = 5;
      break;			/* breakpoint                  */
    case 6:
      sigval = 5;
      break;			/* breakpoint                  */
    case 7:
      sigval = 5;
      break;			/* breakpoint                  */
    case 8:
      sigval = 5;
      break;			/* breakpoint                  */
    case 9:
      sigval = 5;
      break;			/* breakpoint                  */
    case 10:
      sigval = 5;
      break;			/* breakpoint                  */
    case 11:
      sigval = 5;
      break;			/* breakpoint                  */
    case 12:
      sigval = 5;
      break;			/* breakpoint                  */
    case 13:
      sigval = 5;
      break;			/* breakpoint                  */
    case 14:
      sigval = 5;
      break;			/* breakpoint                  */
    case 15:
      sigval = 5;
      break;			/* breakpoint                  */
    case 16:
      sigval = 10;
      break;			/* BUS ERROR (alignment)       */
    case 17:
      sigval = 2;
      break;			/* INTerrupt                   */
    default:
      sigval = 7;
      break;			/* "software generated"        */
    }
  return (sigval);
}

/**********************************************/
/* WHILE WE FIND NICE HEX CHARS, BUILD AN INT */
/* RETURN NUMBER OF CHARS PROCESSED           */
/**********************************************/
static int
hexToInt (unsigned char **ptr, int *intValue)
{
  int numChars = 0;
  int hexValue;

  *intValue = 0;
  while (**ptr)
    {
      hexValue = hex (**ptr);
      if (hexValue >= 0)
	{
	  *intValue = (*intValue << 4) | hexValue;
	  numChars++;
	}
      else
	break;
      (*ptr)++;
    }
  return (numChars);
}

/*
  Table of branch instructions:
  
  10B6		RTE	return from trap or exception
  1FCr		JMP	jump
  1ECr		JL	jump and link
  7Fxx		BRA	branch
  FFxxxxxx	BRA	branch (long)
  B09rxxxx	BNEZ	branch not-equal-zero
  Br1rxxxx	BNE	branch not-equal
  7Dxx		BNC	branch not-condition
  FDxxxxxx	BNC	branch not-condition (long)
  B0Arxxxx	BLTZ	branch less-than-zero
  B0Crxxxx	BLEZ	branch less-equal-zero
  7Exx		BL	branch and link
  FExxxxxx	BL	branch and link (long)
  B0Drxxxx	BGTZ	branch greater-than-zero
  B0Brxxxx	BGEZ	branch greater-equal-zero
  B08rxxxx	BEQZ	branch equal-zero
  Br0rxxxx	BEQ	branch equal
  7Cxx		BC	branch condition
  FCxxxxxx	BC	branch condition (long)
  */

static int
isShortBranch (unsigned char *instr)
{
  unsigned char instr0 = instr[0] & 0x7F;	/* mask off high bit */

  if (instr0 == 0x10 && instr[1] == 0xB6)	/* RTE */
    return 1;			/* return from trap or exception */

  if (instr0 == 0x1E || instr0 == 0x1F)	/* JL or JMP */
    if ((instr[1] & 0xF0) == 0xC0)
      return 2;			/* jump thru a register */

  if (instr0 == 0x7C || instr0 == 0x7D ||	/* BC, BNC, BL, BRA */
      instr0 == 0x7E || instr0 == 0x7F)
    return 3;			/* eight bit PC offset */

  return 0;
}

static int
isLongBranch (unsigned char *instr)
{
  if (instr[0] == 0xFC || instr[0] == 0xFD ||	/* BRA, BNC, BL, BC */
      instr[0] == 0xFE || instr[0] == 0xFF)	/* 24 bit relative */
    return 4;
  if ((instr[0] & 0xF0) == 0xB0)	/* 16 bit relative */
    {
      if ((instr[1] & 0xF0) == 0x00 ||	/* BNE, BEQ */
	  (instr[1] & 0xF0) == 0x10)
	return 5;
      if (instr[0] == 0xB0)	/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ, BEQZ */
	if ((instr[1] & 0xF0) == 0x80 || (instr[1] & 0xF0) == 0x90 ||
	    (instr[1] & 0xF0) == 0xA0 || (instr[1] & 0xF0) == 0xB0 ||
	    (instr[1] & 0xF0) == 0xC0 || (instr[1] & 0xF0) == 0xD0)
	  return 6;
    }
  return 0;
}

/* if address is NOT on a 4-byte boundary, or high-bit of instr is zero, 
   then it's a 2-byte instruction, else it's a 4-byte instruction.  */

#define INSTRUCTION_SIZE(addr) \
    ((((int) addr & 2) || (((unsigned char *) addr)[0] & 0x80) == 0) ? 2 : 4)

static int
isBranch (unsigned char *instr)
{
  if (INSTRUCTION_SIZE (instr) == 2)
    return isShortBranch (instr);
  else
    return isLongBranch (instr);
}

static int
willBranch (unsigned char *instr, int branchCode)
{
  switch (branchCode)
    {
    case 0:
      return 0;			/* not a branch */
    case 1:
      return 1;			/* RTE */
    case 2:
      return 1;			/* JL or JMP    */
    case 3:			/* BC, BNC, BL, BRA (short) */
    case 4:			/* BC, BNC, BL, BRA (long) */
      switch (instr[0] & 0x0F)
	{
	case 0xC:		/* Branch if Condition Register */
	  return (registers[CBR] != 0);
	case 0xD:		/* Branch if NOT Condition Register */
	  return (registers[CBR] == 0);
	case 0xE:		/* Branch and Link */
	case 0xF:		/* Branch (unconditional) */
	  return 1;
	default:		/* oops? */
	  return 0;
	}
    case 5:			/* BNE, BEQ */
      switch (instr[1] & 0xF0)
	{
	case 0x00:		/* Branch if r1 equal to r2 */
	  return (registers[instr[0] & 0x0F] == registers[instr[1] & 0x0F]);
	case 0x10:		/* Branch if r1 NOT equal to r2 */
	  return (registers[instr[0] & 0x0F] != registers[instr[1] & 0x0F]);
	default:		/* oops? */
	  return 0;
	}
    case 6:			/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ */
      switch (instr[1] & 0xF0)
	{
	case 0x80:		/* Branch if reg equal to zero */
	  return (registers[instr[1] & 0x0F] == 0);
	case 0x90:		/* Branch if reg NOT equal to zero */
	  return (registers[instr[1] & 0x0F] != 0);
	case 0xA0:		/* Branch if reg less than zero */
	  return (registers[instr[1] & 0x0F] < 0);
	case 0xB0:		/* Branch if reg greater or equal to zero */
	  return (registers[instr[1] & 0x0F] >= 0);
	case 0xC0:		/* Branch if reg less than or equal to zero */
	  return (registers[instr[1] & 0x0F] <= 0);
	case 0xD0:		/* Branch if reg greater than zero */
	  return (registers[instr[1] & 0x0F] > 0);
	default:		/* oops? */
	  return 0;
	}
    default:			/* oops? */
      return 0;
    }
}

static int
branchDestination (unsigned char *instr, int branchCode)
{
  switch (branchCode)
    {
    default:
    case 0:			/* not a branch */
      return 0;
    case 1:			/* RTE */
      return registers[BPC] & ~3;	/* pop BPC into PC */
    case 2:			/* JL or JMP */
      return registers[instr[1] & 0x0F] & ~3;	/* jump thru a register */
    case 3:			/* BC, BNC, BL, BRA (short, 8-bit relative offset) */
      return (((int) instr) & ~3) + ((char) instr[1] << 2);
    case 4:			/* BC, BNC, BL, BRA (long, 24-bit relative offset) */
      return ((int) instr +
	      ((((char) instr[1] << 16) | (instr[2] << 8) | (instr[3])) <<
	       2));
    case 5:			/* BNE, BEQ (16-bit relative offset) */
    case 6:			/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ (ditto) */
      return ((int) instr + ((((char) instr[2] << 8) | (instr[3])) << 2));
    }

  /* An explanatory note: in the last three return expressions, I have
     cast the most-significant byte of the return offset to char.
     What this accomplishes is sign extension.  If the other
     less-significant bytes were signed as well, they would get sign
     extended too and, if negative, their leading bits would clobber
     the bits of the more-significant bytes ahead of them.  There are
     other ways I could have done this, but sign extension from
     odd-sized integers is always a pain. */
}

static void
branchSideEffects (unsigned char *instr, int branchCode)
{
  switch (branchCode)
    {
    case 1:			/* RTE */
      return;			/* I <THINK> this is already handled... */
    case 2:			/* JL (or JMP) */
    case 3:			/* BL (or BC, BNC, BRA) */
    case 4:
      if ((instr[0] & 0x0F) == 0x0E)	/* branch/jump and link */
	registers[R14] = (registers[PC] & ~3) + 4;
      return;
    default:			/* any other branch has no side effects */
      return;
    }
}

static struct STEPPING_CONTEXT
{
  int stepping;			/* true when we've started a single-step */
  unsigned long target_addr;	/* the instr we're trying to execute */
  unsigned long target_size;	/* the size of the target instr */
  unsigned long noop_addr;	/* where we've inserted a no-op, if any */
  unsigned long trap1_addr;	/* the trap following the target instr */
  unsigned long trap2_addr;	/* the trap at a branch destination, if any */
  unsigned short noop_save;	/* instruction overwritten by our no-op */
  unsigned short trap1_save;	/* instruction overwritten by trap1 */
  unsigned short trap2_save;	/* instruction overwritten by trap2 */
  unsigned short continue_p;	/* true if NOT returning to gdb after step */
} stepping;

/* Function: prepare_to_step
   Called from handle_exception to prepare the user program to single-step.
   Places a trap instruction after the target instruction, with special 
   extra handling for branch instructions and for instructions in the 
   second half-word of a word.  

   Returns: True  if we should actually execute the instruction; 
	    False if we are going to emulate executing the instruction,
	    in which case we simply report to GDB that the instruction 
	    has already been executed.  */

#define TRAP1  0x10f1;		/* trap #1 instruction */
#define NOOP   0x7000;		/* noop    instruction */

static unsigned short trap1 = TRAP1;
static unsigned short noop = NOOP;

static int
prepare_to_step (continue_p)
     int continue_p;		/* if this isn't REALLY a single-step (see below) */
{
  unsigned long pc = registers[PC];
  int branchCode = isBranch ((unsigned char *) pc);
  unsigned char *p;

  /* zero out the stepping context 
     (paranoia -- it should already be zeroed) */
  for (p = (unsigned char *) &stepping;
       p < ((unsigned char *) &stepping) + sizeof (stepping); p++)
    *p = 0;

  if (branchCode != 0)		/* next instruction is a branch */
    {
      branchSideEffects ((unsigned char *) pc, branchCode);
      if (willBranch ((unsigned char *) pc, branchCode))
	registers[PC] = branchDestination ((unsigned char *) pc, branchCode);
      else
	registers[PC] = pc + INSTRUCTION_SIZE (pc);
      return 0;			/* branch "executed" -- just notify GDB */
    }
  else if (((int) pc & 2) != 0)	/* "second-slot" instruction */
    {
      /* insert no-op before pc */
      stepping.noop_addr = pc - 2;
      stepping.noop_save = *(unsigned short *) stepping.noop_addr;
      *(unsigned short *) stepping.noop_addr = noop;
      /* insert trap  after  pc */
      stepping.trap1_addr = pc + 2;
      stepping.trap1_save = *(unsigned short *) stepping.trap1_addr;
      *(unsigned short *) stepping.trap1_addr = trap1;
    }
  else				/* "first-slot" instruction */
    {
      /* insert trap  after  pc */
      stepping.trap1_addr = pc + INSTRUCTION_SIZE (pc);
      stepping.trap1_save = *(unsigned short *) stepping.trap1_addr;
      *(unsigned short *) stepping.trap1_addr = trap1;
    }
  /* "continue_p" means that we are actually doing a continue, and not 
     being requested to single-step by GDB.  Sometimes we have to do
     one single-step before continuing, because the PC is on a half-word
     boundary.  There's no way to simply resume at such an address.  */
  stepping.continue_p = continue_p;
  stepping.stepping = 1;	/* starting a single-step */
  return 1;
}

/* Function: finish_from_step
   Called from handle_exception to finish up when the user program 
   returns from a single-step.  Replaces the instructions that had
   been overwritten by traps or no-ops, 

   Returns: True  if we should notify GDB that the target stopped.
	    False if we only single-stepped because we had to before we
	    could continue (ie. we were trying to continue at a 
	    half-word boundary).  In that case don't notify GDB:
	    just "continue continuing".  */

static int
finish_from_step (void)
{
  if (stepping.stepping)	/* anything to do? */
    {
      int continue_p = stepping.continue_p;
      unsigned char *p;

      if (stepping.noop_addr)	/* replace instr "under" our no-op */
	*(unsigned short *) stepping.noop_addr = stepping.noop_save;
      if (stepping.trap1_addr)	/* replace instr "under" our trap  */
	*(unsigned short *) stepping.trap1_addr = stepping.trap1_save;
      if (stepping.trap2_addr)	/* ditto our other trap, if any    */
	*(unsigned short *) stepping.trap2_addr = stepping.trap2_save;

      for (p = (unsigned char *) &stepping;	/* zero out the stepping context */
	   p < ((unsigned char *) &stepping) + sizeof (stepping); p++)
	*p = 0;

      return !(continue_p);
    }
  else				/* we didn't single-step, therefore this must be a legitimate stop */
    return 1;
}

struct PSWreg
{				/* separate out the bit flags in the PSW register */
  int pad1:16;
  int bsm:1;
  int bie:1;
  int pad2:5;
  int bc:1;
  int sm:1;
  int ie:1;
  int pad3:5;
  int c:1;
} *psw;

/* Upon entry the value for LR to save has been pushed.
   We unpush that so that the value for the stack pointer saved is correct.
   Upon entry, all other registers are assumed to have not been modified
   since the interrupt/trap occured.  */

asm ("\n\
stash_registers:\n\
	push r0\n\
	push r1\n\
	seth r1, #shigh(registers)\n\
	add3 r1, r1, #low(registers)\n\
	pop r0		; r1\n\
	st r0, @@(4,r1)\n\
	pop r0		; r0\n\
	st r0, @@r1\n\
	addi r1, #4	; only add 4 as subsequent saves are `pre inc'\n\
	st r2, @@+r1\n\
	st r3, @@+r1\n\
	st r4, @@+r1\n\
	st r5, @@+r1\n\
	st r6, @@+r1\n\
	st r7, @@+r1\n\
	st r8, @@+r1\n\
	st r9, @@+r1\n\
	st r10, @@+r1\n\
	st r11, @@+r1\n\
	st r12, @@+r1\n\
	st r13, @@+r1    ; fp\n\
	pop r0		; lr (r14)\n\
	st r0, @@+r1\n\
	st sp, @@+r1	; sp contains right value at this point\n\
	mvfc r0, cr0\n\
	st r0, @@+r1	; cr0 == PSW\n\
	mvfc r0, cr1\n\
	st r0, @@+r1	; cr1 == CBR\n\
	mvfc r0, cr2\n\
	st r0, @@+r1	; cr2 == SPI\n\
	mvfc r0, cr3\n\
	st r0, @@+r1	; cr3 == SPU\n\
	mvfc r0, cr6\n\
	st r0, @@+r1	; cr6 == BPC\n\
	st r0, @@+r1	; PC  == BPC\n\
	mvfaclo r0\n\
	st r0, @@+r1	; ACCL\n\
	mvfachi r0\n\
	st r0, @@+r1	; ACCH\n\
	jmp lr");

/* C routine to clean up what stash_registers did.
   It is called after calling stash_registers.
   This is separate from stash_registers as we want to do this in C
   but doing stash_registers in C isn't straightforward.  */

static void
cleanup_stash (void)
{
  psw = (struct PSWreg *) &registers[PSW];	/* fields of PSW register */
  psw->sm = psw->bsm;		/* fix up pre-trap values of psw fields */
  psw->ie = psw->bie;
  psw->c = psw->bc;
  registers[CBR] = psw->bc;	/* fix up pre-trap "C" register */

#if 0				/* FIXME: Was in previous version.  Necessary?
				   (Remember that we use the "rte" insn to return from the
				   trap/interrupt so the values of bsm, bie, bc are important.  */
  psw->bsm = psw->bie = psw->bc = 0;	/* zero post-trap values */
#endif

  /* FIXME: Copied from previous version.  This can probably be deleted
     since methinks stash_registers has already done this.  */
  registers[PC] = registers[BPC];	/* pre-trap PC */

  /* FIXME: Copied from previous version.  Necessary?  */
  if (psw->sm)			/* copy R15 into (psw->sm ? SPU : SPI) */
    registers[SPU] = registers[R15];
  else
    registers[SPI] = registers[R15];
}

asm ("\n\
restore_and_return:\n\
	seth r0, #shigh(registers+8)\n\
	add3 r0, r0, #low(registers+8)\n\
	ld r2, @@r0+	; restore r2\n\
	ld r3, @@r0+	; restore r3\n\
	ld r4, @@r0+	; restore r4\n\
	ld r5, @@r0+	; restore r5\n\
	ld r6, @@r0+	; restore r6\n\
	ld r7, @@r0+	; restore r7\n\
	ld r8, @@r0+	; restore r8\n\
	ld r9, @@r0+	; restore r9\n\
	ld r10, @@r0+	; restore r10\n\
	ld r11, @@r0+	; restore r11\n\
	ld r12, @@r0+	; restore r12\n\
	ld r13, @@r0+	; restore r13\n\
	ld r14, @@r0+	; restore r14\n\
	ld r15, @@r0+	; restore r15\n\
	ld r1, @@r0+	; restore cr0 == PSW\n\
	mvtc r1, cr0\n\
	ld r1, @@r0+	; restore cr1 == CBR (no-op, because it's read only)\n\
	mvtc r1, cr1\n\
	ld r1, @@r0+	; restore cr2 == SPI\n\
	mvtc r1, cr2\n\
	ld r1, @@r0+	; restore cr3 == SPU\n\
	mvtc r1, cr3\n\
	addi r0, #4	; skip BPC\n\
	ld r1, @@r0+	; restore cr6 (BPC) == PC\n\
	mvtc r1, cr6\n\
	ld r1, @@r0+	; restore ACCL\n\
	mvtaclo r1\n\
	ld r1, @@r0+	; restore ACCH\n\
	mvtachi r1\n\
	seth r0, #shigh(registers)\n\
	add3 r0, r0, #low(registers)\n\
	ld r1, @@(4,r0)	; restore r1\n\
	ld r0, @@r0	; restore r0\n\
	rte");

/* General trap handler, called after the registers have been stashed.
   NUM is the trap/exception number.  */

static void
process_exception (int num)
{
  cleanup_stash ();
  asm volatile ("\n\
	seth r1, #shigh(stackPtr)\n\
	add3 r1, r1, #low(stackPtr)\n\
	ld r15, @@r1		; setup local stack (protect user stack)\n\
	mv r0, %0\n\
	bl handle_exception\n\
	bl restore_and_return"::"r" (num):"r0", "r1");
}

void _catchException0 ();

asm ("\n\
_catchException0:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #0\n\
	bl process_exception");

void _catchException1 ();

asm ("\n\
_catchException1:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	bl cleanup_stash\n\
	seth r1, #shigh(stackPtr)\n\
	add3 r1, r1, #low(stackPtr)\n\
	ld r15, @@r1		; setup local stack (protect user stack)\n\
	seth r1, #shigh(registers + 21*4) ; PC\n\
	add3 r1, r1, #low(registers + 21*4)\n\
	ld r0, @@r1\n\
	addi r0, #-4		; back up PC for breakpoint trap.\n\
	st r0, @@r1		; FIXME: what about bp in right slot?\n\
	ldi r0, #1\n\
	bl handle_exception\n\
	bl restore_and_return");

void _catchException2 ();

asm ("\n\
_catchException2:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #2\n\
	bl process_exception");

void _catchException3 ();

asm ("\n\
_catchException3:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #3\n\
	bl process_exception");

void _catchException4 ();

asm ("\n\
_catchException4:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #4\n\
	bl process_exception");

void _catchException5 ();

asm ("\n\
_catchException5:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #5\n\
	bl process_exception");

void _catchException6 ();

asm ("\n\
_catchException6:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #6\n\
	bl process_exception");

void _catchException7 ();

asm ("\n\
_catchException7:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #7\n\
	bl process_exception");

void _catchException8 ();

asm ("\n\
_catchException8:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #8\n\
	bl process_exception");

void _catchException9 ();

asm ("\n\
_catchException9:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #9\n\
	bl process_exception");

void _catchException10 ();

asm ("\n\
_catchException10:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #10\n\
	bl process_exception");

void _catchException11 ();

asm ("\n\
_catchException11:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #11\n\
	bl process_exception");

void _catchException12 ();

asm ("\n\
_catchException12:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #12\n\
	bl process_exception");

void _catchException13 ();

asm ("\n\
_catchException13:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #13\n\
	bl process_exception");

void _catchException14 ();

asm ("\n\
_catchException14:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #14\n\
	bl process_exception");

void _catchException15 ();

asm ("\n\
_catchException15:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #15\n\
	bl process_exception");

void _catchException16 ();

asm ("\n\
_catchException16:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #16\n\
	bl process_exception");

void _catchException17 ();

asm ("\n\
_catchException17:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #17\n\
	bl process_exception");


/* this function is used to set up exception handlers for tracing and
   breakpoints */
void
set_debug_traps (void)
{
  /*  extern void remcomHandler(); */
  int i;

  for (i = 0; i < 18; i++)	/* keep a copy of old vectors */
    if (save_vectors[i] == 0)	/* only copy them the first time */
      save_vectors[i] = getExceptionHandler (i);

  stackPtr = &remcomStack[STACKSIZE / sizeof (int) - 1];

  exceptionHandler (0, _catchException0);
  exceptionHandler (1, _catchException1);
  exceptionHandler (2, _catchException2);
  exceptionHandler (3, _catchException3);
  exceptionHandler (4, _catchException4);
  exceptionHandler (5, _catchException5);
  exceptionHandler (6, _catchException6);
  exceptionHandler (7, _catchException7);
  exceptionHandler (8, _catchException8);
  exceptionHandler (9, _catchException9);
  exceptionHandler (10, _catchException10);
  exceptionHandler (11, _catchException11);
  exceptionHandler (12, _catchException12);
  exceptionHandler (13, _catchException13);
  exceptionHandler (14, _catchException14);
  exceptionHandler (15, _catchException15);
  exceptionHandler (16, _catchException16);
  /*  exceptionHandler (17, _catchException17); */

  initialized = 1;
}

/* This function will generate a breakpoint exception.  It is used at the
   beginning of a program to sync up with a debugger and can be used
   otherwise as a quick means to stop program execution and "break" into
   the debugger. */

#define BREAKPOINT() asm volatile ("	trap #2");

void
breakpoint (void)
{
  if (initialized)
    BREAKPOINT ();
}

/* STDOUT section:
   Stuff pertaining to simulating stdout by sending chars to gdb to be echoed.
   Functions: gdb_putchar(char ch)
              gdb_puts(char *str)
              gdb_write(char *str, int len)
              gdb_error(char *format, char *parm)
	      */

/* Function: gdb_putchar(int)
   Make gdb write a char to stdout.
   Returns: the char */

static int
gdb_putchar (int ch)
{
  char buf[4];

  buf[0] = 'O';
  buf[1] = hexchars[ch >> 4];
  buf[2] = hexchars[ch & 0x0F];
  buf[3] = 0;
  putpacket (buf);
  return ch;
}

/* Function: gdb_write(char *, int)
   Make gdb write n bytes to stdout (not assumed to be null-terminated).
   Returns: number of bytes written */

static int
gdb_write (char *data, int len)
{
  char *buf, *cpy;
  int i;

  buf = remcomOutBuffer;
  buf[0] = 'O';
  i = 0;
  while (i < len)
    {
      for (cpy = buf + 1;
	   i < len && cpy < buf + sizeof (remcomOutBuffer) - 3; i++)
	{
	  *cpy++ = hexchars[data[i] >> 4];
	  *cpy++ = hexchars[data[i] & 0x0F];
	}
      *cpy = 0;
      putpacket (buf);
    }
  return len;
}

/* Function: gdb_puts(char *)
   Make gdb write a null-terminated string to stdout.
   Returns: the length of the string */

static int
gdb_puts (char *str)
{
  return gdb_write (str, strlen (str));
}

/* Function: gdb_error(char *, char *)
   Send an error message to gdb's stdout.
   First string may have 1 (one) optional "%s" in it, which
   will cause the optional second string to be inserted.  */

static void
gdb_error (char *format, char *parm)
{
  char buf[400], *cpy;
  int len;

  if (remote_debug)
    {
      if (format && *format)
	len = strlen (format);
      else
	return;			/* empty input */

      if (parm && *parm)
	len += strlen (parm);

      for (cpy = buf; *format;)
	{
	  if (format[0] == '%' && format[1] == 's')	/* include second string */
	    {
	      format += 2;	/* advance two chars instead of just one */
	      while (parm && *parm)
		*cpy++ = *parm++;
	    }
	  else
	    *cpy++ = *format++;
	}
      *cpy = '\0';
      gdb_puts (buf);
    }
}

static unsigned char *
strcpy (unsigned char *dest, const unsigned char *src)
{
  unsigned char *ret = dest;

  if (dest && src)
    {
      while (*src)
	*dest++ = *src++;
      *dest = 0;
    }
  return ret;
}

static int
strlen (const unsigned char *src)
{
  int ret;

  for (ret = 0; *src; src++)
    ret++;

  return ret;
}

#if 0
void
exit (code)
     int code;
{
  _exit (code);
}

int
atexit (void *p)
{
  return 0;
}

void
abort (void)
{
  _exit (1);
}
#endif
@


1.8
log
@	* i386-stub.c (getpacket): Fix array overflow.
	* m32r-stub.c (getpacket): Likewise.
	* m68k-stub.c (getpacket): Likewise.
	* sh-stub.c (getpacket): Likewise.
	* sparc-stub.c (getpacket): Likewise.
@
text
@@


1.7
log
@2003-07-21  Andrew Cagney  <cagney@@redhat.com>

	From 2003-07-04 Kei Sakamoto <sakamoto.kei@@renesas.com>:
	* m32r-tdep.c, m32r-stub.c, m32r-tdep.c: Rewrite.
@
text
@d608 1
a608 1
      while (count < BUFMAX)
@


1.6
log
@2003-02-04  Andrew Cagney  <ac131313@@redhat.com>

	* NEWS: Note that the m32r-*-elf* is obsolete.
	* monitor.c (monitor_expect): Obsolete reference to m32r.
	* configure.tgt: Mark m32r-*-elf* as obsolete.
	* MAINTAINERS: Mark m32k as obsolete.
	* m32r-rom.c: Obsolete file.
	* config/m32r/m32r.mt: Obsolete file.
	* config/m32r/tm-m32r.h: Obsolete file.
	* m32r-stub.c: Obsolete file.
	* m32r-tdep.c: Obsolete file.
@
text
@d1 1779
a1779 1718
// OBSOLETE /****************************************************************************
// OBSOLETE 
// OBSOLETE 		THIS SOFTWARE IS NOT COPYRIGHTED
// OBSOLETE 
// OBSOLETE    HP offers the following for use in the public domain.  HP makes no
// OBSOLETE    warranty with regard to the software or it's performance and the
// OBSOLETE    user accepts the software "AS IS" with all faults.
// OBSOLETE 
// OBSOLETE    HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD
// OBSOLETE    TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OBSOLETE    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
// OBSOLETE 
// OBSOLETE ****************************************************************************/
// OBSOLETE 
// OBSOLETE /****************************************************************************
// OBSOLETE  *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $
// OBSOLETE  *
// OBSOLETE  *  Module name: remcom.c $
// OBSOLETE  *  Revision: 1.34 $
// OBSOLETE  *  Date: 91/03/09 12:29:49 $
// OBSOLETE  *  Contributor:     Lake Stevens Instrument Division$
// OBSOLETE  *
// OBSOLETE  *  Description:     low level support for gdb debugger. $
// OBSOLETE  *
// OBSOLETE  *  Considerations:  only works on target hardware $
// OBSOLETE  *
// OBSOLETE  *  Written by:      Glenn Engel $
// OBSOLETE  *  ModuleState:     Experimental $
// OBSOLETE  *
// OBSOLETE  *  NOTES:           See Below $
// OBSOLETE  *
// OBSOLETE  *  Modified for M32R by Michael Snyder, Cygnus Support.
// OBSOLETE  *
// OBSOLETE  *  To enable debugger support, two things need to happen.  One, a
// OBSOLETE  *  call to set_debug_traps() is necessary in order to allow any breakpoints
// OBSOLETE  *  or error conditions to be properly intercepted and reported to gdb.
// OBSOLETE  *  Two, a breakpoint needs to be generated to begin communication.  This
// OBSOLETE  *  is most easily accomplished by a call to breakpoint().  Breakpoint()
// OBSOLETE  *  simulates a breakpoint by executing a trap #1.
// OBSOLETE  *
// OBSOLETE  *  The external function exceptionHandler() is
// OBSOLETE  *  used to attach a specific handler to a specific M32R vector number.
// OBSOLETE  *  It should use the same privilege level it runs at.  It should
// OBSOLETE  *  install it as an interrupt gate so that interrupts are masked
// OBSOLETE  *  while the handler runs.
// OBSOLETE  *
// OBSOLETE  *  Because gdb will sometimes write to the stack area to execute function
// OBSOLETE  *  calls, this program cannot rely on using the supervisor stack so it
// OBSOLETE  *  uses it's own stack area reserved in the int array remcomStack.
// OBSOLETE  *
// OBSOLETE  *************
// OBSOLETE  *
// OBSOLETE  *    The following gdb commands are supported:
// OBSOLETE  *
// OBSOLETE  * command          function                               Return value
// OBSOLETE  *
// OBSOLETE  *    g             return the value of the CPU registers  hex data or ENN
// OBSOLETE  *    G             set the value of the CPU registers     OK or ENN
// OBSOLETE  *
// OBSOLETE  *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN
// OBSOLETE  *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN
// OBSOLETE  *    XAA..AA,LLLL: Write LLLL binary bytes at address     OK or ENN
// OBSOLETE  *                  AA..AA
// OBSOLETE  *
// OBSOLETE  *    c             Resume at current address              SNN   ( signal NN)
// OBSOLETE  *    cAA..AA       Continue at address AA..AA             SNN
// OBSOLETE  *
// OBSOLETE  *    s             Step one instruction                   SNN
// OBSOLETE  *    sAA..AA       Step one instruction from AA..AA       SNN
// OBSOLETE  *
// OBSOLETE  *    k             kill
// OBSOLETE  *
// OBSOLETE  *    ?             What was the last sigval ?             SNN   (signal NN)
// OBSOLETE  *
// OBSOLETE  * All commands and responses are sent with a packet which includes a
// OBSOLETE  * checksum.  A packet consists of
// OBSOLETE  *
// OBSOLETE  * $<packet info>#<checksum>.
// OBSOLETE  *
// OBSOLETE  * where
// OBSOLETE  * <packet info> :: <characters representing the command or response>
// OBSOLETE  * <checksum>    :: <two hex digits computed as modulo 256 sum of <packetinfo>>
// OBSOLETE  *
// OBSOLETE  * When a packet is received, it is first acknowledged with either '+' or '-'.
// OBSOLETE  * '+' indicates a successful transfer.  '-' indicates a failed transfer.
// OBSOLETE  *
// OBSOLETE  * Example:
// OBSOLETE  *
// OBSOLETE  * Host:                  Reply:
// OBSOLETE  * $m0,10#2a               +$00010203040506070809101112131415#42
// OBSOLETE  *
// OBSOLETE  ****************************************************************************/
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /************************************************************************
// OBSOLETE  *
// OBSOLETE  * external low-level support routines
// OBSOLETE  */
// OBSOLETE extern void putDebugChar();	/* write a single character      */
// OBSOLETE extern int getDebugChar();	/* read and return a single char */
// OBSOLETE extern void exceptionHandler();	/* assign an exception handler   */
// OBSOLETE 
// OBSOLETE /*****************************************************************************
// OBSOLETE  * BUFMAX defines the maximum number of characters in inbound/outbound buffers
// OBSOLETE  * at least NUMREGBYTES*2 are needed for register packets 
// OBSOLETE  */
// OBSOLETE #define BUFMAX 400
// OBSOLETE 
// OBSOLETE static char initialized;  /* boolean flag. != 0 means we've been initialized */
// OBSOLETE 
// OBSOLETE int     remote_debug;
// OBSOLETE /*  debug >  0 prints ill-formed commands in valid packets & checksum errors */
// OBSOLETE 
// OBSOLETE static const unsigned char hexchars[]="0123456789abcdef";
// OBSOLETE 
// OBSOLETE #define NUMREGS 24
// OBSOLETE 
// OBSOLETE /* Number of bytes of registers.  */
// OBSOLETE #define NUMREGBYTES (NUMREGS * 4)
// OBSOLETE enum regnames { R0,  R1,  R2,  R3,  R4,  R5,  R6,   R7,
// OBSOLETE 		R8,  R9,  R10, R11, R12, R13, R14,  R15,
// OBSOLETE 		PSW, CBR, SPI, SPU, BPC, PC,  ACCL, ACCH };
// OBSOLETE 
// OBSOLETE enum SYS_calls {
// OBSOLETE   	SYS_null, 
// OBSOLETE 	SYS_exit,
// OBSOLETE 	SYS_open,
// OBSOLETE 	SYS_close,
// OBSOLETE 	SYS_read,
// OBSOLETE 	SYS_write,
// OBSOLETE 	SYS_lseek,
// OBSOLETE 	SYS_unlink,
// OBSOLETE 	SYS_getpid,
// OBSOLETE 	SYS_kill,
// OBSOLETE 	SYS_fstat,
// OBSOLETE 	SYS_sbrk,
// OBSOLETE 	SYS_fork,
// OBSOLETE 	SYS_execve,
// OBSOLETE 	SYS_wait4,
// OBSOLETE 	SYS_link,
// OBSOLETE 	SYS_chdir,
// OBSOLETE 	SYS_stat,
// OBSOLETE 	SYS_utime,
// OBSOLETE 	SYS_chown,
// OBSOLETE 	SYS_chmod,
// OBSOLETE 	SYS_time,
// OBSOLETE 	SYS_pipe };
// OBSOLETE 
// OBSOLETE static int registers[NUMREGS];
// OBSOLETE 
// OBSOLETE #define STACKSIZE 8096
// OBSOLETE static unsigned char remcomInBuffer[BUFMAX];
// OBSOLETE static unsigned char remcomOutBuffer[BUFMAX];
// OBSOLETE static int  remcomStack[STACKSIZE/sizeof(int)];
// OBSOLETE static int*  stackPtr = &remcomStack[STACKSIZE/sizeof(int) - 1];
// OBSOLETE 
// OBSOLETE static unsigned int save_vectors[18];	/* previous exception vectors */
// OBSOLETE 
// OBSOLETE /* Indicate to caller of mem2hex or hex2mem that there has been an error. */
// OBSOLETE static volatile int mem_err = 0;
// OBSOLETE 
// OBSOLETE /* Store the vector number here (since GDB only gets the signal
// OBSOLETE    number through the usual means, and that's not very specific).  */
// OBSOLETE int gdb_m32r_vector = -1;
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE #include "syscall.h" /* for SYS_exit, SYS_write etc. */
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /* Global entry points:
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE extern void handle_exception(int);
// OBSOLETE extern void set_debug_traps(void);
// OBSOLETE extern void breakpoint(void);
// OBSOLETE 
// OBSOLETE /* Local functions:
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static int  computeSignal(int);
// OBSOLETE static void putpacket(unsigned char *);
// OBSOLETE static unsigned char *getpacket(void);
// OBSOLETE 
// OBSOLETE static unsigned char *mem2hex(unsigned char *, unsigned char *, int, int);
// OBSOLETE static unsigned char *hex2mem(unsigned char *, unsigned char *, int, int);
// OBSOLETE static int  hexToInt(unsigned char **, int *);
// OBSOLETE static unsigned char *bin2mem(unsigned char *, unsigned char *, int, int);
// OBSOLETE static void stash_registers(void);
// OBSOLETE static void restore_registers(void);
// OBSOLETE static int  prepare_to_step(int);
// OBSOLETE static int  finish_from_step(void);
// OBSOLETE static unsigned long crc32 (unsigned char *, int, unsigned long);
// OBSOLETE 
// OBSOLETE static void gdb_error(char *, char *);
// OBSOLETE static int  gdb_putchar(int), gdb_puts(char *), gdb_write(char *, int);
// OBSOLETE 
// OBSOLETE static unsigned char *strcpy (unsigned char *, const unsigned char *);
// OBSOLETE static int   strlen (const unsigned char *);
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * This function does all command procesing for interfacing to gdb.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE void 
// OBSOLETE handle_exception(int exceptionVector)
// OBSOLETE {
// OBSOLETE   int    sigval, stepping;
// OBSOLETE   int    addr, length, i;
// OBSOLETE   unsigned char * ptr;
// OBSOLETE   unsigned char   buf[16];
// OBSOLETE   int binary;
// OBSOLETE 
// OBSOLETE   /* Do not call finish_from_step() if this is not a trap #1
// OBSOLETE    * (breakpoint trap).  Without this check, the finish_from_step()
// OBSOLETE    * might interpret a system call trap as a single step trap.  This
// OBSOLETE    * can happen if: the stub receives 's' and exits, but an interrupt
// OBSOLETE    * was pending; the interrupt is now handled and causes the stub to
// OBSOLETE    * be reentered because some function makes a system call.  
// OBSOLETE    */
// OBSOLETE   if (exceptionVector == 1)	/* Trap exception? */
// OBSOLETE     if (!finish_from_step())	/* Go see if stepping state needs update. */
// OBSOLETE       return;		/* "false step": let the target continue */
// OBSOLETE 
// OBSOLETE   gdb_m32r_vector = exceptionVector;
// OBSOLETE 
// OBSOLETE   if (remote_debug)
// OBSOLETE     {
// OBSOLETE       mem2hex((unsigned char *) &exceptionVector, buf, 4, 0);
// OBSOLETE       gdb_error("Handle exception %s, ", buf);
// OBSOLETE       mem2hex((unsigned char *) &registers[PC], buf, 4, 0);
// OBSOLETE       gdb_error("PC == 0x%s\n", buf);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* reply to host that an exception has occurred */
// OBSOLETE   sigval = computeSignal( exceptionVector );
// OBSOLETE 
// OBSOLETE   ptr = remcomOutBuffer;
// OBSOLETE  
// OBSOLETE   *ptr++ = 'T';         /* notify gdb with signo, PC, FP and SP */
// OBSOLETE   *ptr++ = hexchars[sigval >> 4];
// OBSOLETE   *ptr++ = hexchars[sigval & 0xf];
// OBSOLETE  
// OBSOLETE   *ptr++ = hexchars[PC >> 4];
// OBSOLETE   *ptr++ = hexchars[PC & 0xf];
// OBSOLETE   *ptr++ = ':';
// OBSOLETE   ptr = mem2hex((unsigned char *)&registers[PC], ptr, 4, 0);     /* PC */
// OBSOLETE   *ptr++ = ';';
// OBSOLETE  
// OBSOLETE   *ptr++ = hexchars[R13 >> 4];
// OBSOLETE   *ptr++ = hexchars[R13 & 0xf];
// OBSOLETE   *ptr++ = ':';
// OBSOLETE   ptr = mem2hex((unsigned char *)&registers[R13], ptr, 4, 0);    /* FP */
// OBSOLETE   *ptr++ = ';';
// OBSOLETE  
// OBSOLETE   *ptr++ = hexchars[R15 >> 4];
// OBSOLETE   *ptr++ = hexchars[R15 & 0xf];
// OBSOLETE   *ptr++ = ':';
// OBSOLETE   ptr = mem2hex((unsigned char *)&registers[R15], ptr, 4, 0);    /* SP */
// OBSOLETE   *ptr++ = ';';
// OBSOLETE   *ptr++ = 0;
// OBSOLETE  
// OBSOLETE   if (exceptionVector == 0)     /* simulated SYS call stuff */
// OBSOLETE     {
// OBSOLETE       mem2hex((unsigned char *) &registers[PC], buf, 4, 0);
// OBSOLETE       switch (registers[R0]) {
// OBSOLETE       case SYS_exit:
// OBSOLETE 	gdb_error("Target program has exited at %s\n", buf);
// OBSOLETE 	ptr = remcomOutBuffer;
// OBSOLETE 	*ptr++ = 'W';
// OBSOLETE 	sigval = registers[R1] & 0xff;
// OBSOLETE 	*ptr++ = hexchars[sigval >> 4];
// OBSOLETE 	*ptr++ = hexchars[sigval & 0xf];
// OBSOLETE 	*ptr++ = 0;
// OBSOLETE 	break;
// OBSOLETE       case SYS_open:
// OBSOLETE 	gdb_error("Target attempts SYS_open call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_close:
// OBSOLETE 	gdb_error("Target attempts SYS_close call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_read:
// OBSOLETE 	gdb_error("Target attempts SYS_read call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_write:
// OBSOLETE 	if (registers[R1] == 1 ||       /* write to stdout  */
// OBSOLETE 	    registers[R1] == 2)		/* write to stderr  */
// OBSOLETE 	  {				/* (we can do that) */
// OBSOLETE 	    registers[R0] = gdb_write((void *) registers[R2], registers[R3]);
// OBSOLETE 	    return;
// OBSOLETE 	  }
// OBSOLETE 	else
// OBSOLETE 	  gdb_error("Target attempts SYS_write call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_lseek:
// OBSOLETE 	gdb_error("Target attempts SYS_lseek call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_unlink:
// OBSOLETE 	gdb_error("Target attempts SYS_unlink call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_getpid:
// OBSOLETE 	gdb_error("Target attempts SYS_getpid call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_kill:
// OBSOLETE 	gdb_error("Target attempts SYS_kill call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_fstat:
// OBSOLETE 	gdb_error("Target attempts SYS_fstat call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       default:
// OBSOLETE 	gdb_error("Target attempts unknown SYS call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       }
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   putpacket(remcomOutBuffer);
// OBSOLETE 
// OBSOLETE   stepping = 0;
// OBSOLETE 
// OBSOLETE   while (1==1) {
// OBSOLETE     remcomOutBuffer[0] = 0;
// OBSOLETE     ptr = getpacket();
// OBSOLETE     binary = 0;
// OBSOLETE     switch (*ptr++) {
// OBSOLETE       default:	/* Unknown code.  Return an empty reply message. */
// OBSOLETE 	break;
// OBSOLETE       case 'R':
// OBSOLETE 	if (hexToInt (&ptr, &addr))
// OBSOLETE 	  registers[PC] = addr;
// OBSOLETE 	strcpy(remcomOutBuffer, "OK");
// OBSOLETE 	break;
// OBSOLETE       case '!':
// OBSOLETE 	strcpy(remcomOutBuffer, "OK");
// OBSOLETE 	break;
// OBSOLETE     case 'X': /* XAA..AA,LLLL:<binary data>#cs */
// OBSOLETE       binary = 1;
// OBSOLETE     case 'M': /* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
// OBSOLETE       /* TRY TO READ '%x,%x:'.  IF SUCCEED, SET PTR = 0 */
// OBSOLETE       {
// OBSOLETE         if (hexToInt(&ptr,&addr))
// OBSOLETE           if (*(ptr++) == ',')
// OBSOLETE             if (hexToInt(&ptr,&length))
// OBSOLETE               if (*(ptr++) == ':')
// OBSOLETE                 {
// OBSOLETE                   mem_err = 0;
// OBSOLETE                   if (binary)
// OBSOLETE                     bin2mem (ptr, (unsigned char *) addr, length, 1);
// OBSOLETE                   else
// OBSOLETE                     hex2mem(ptr, (unsigned char*) addr, length, 1);
// OBSOLETE                   if (mem_err) {
// OBSOLETE                     strcpy (remcomOutBuffer, "E03");
// OBSOLETE                     gdb_error ("memory fault", "");
// OBSOLETE                   } else {
// OBSOLETE                     strcpy(remcomOutBuffer,"OK");
// OBSOLETE                   }
// OBSOLETE                   ptr = 0;
// OBSOLETE                 }
// OBSOLETE         if (ptr)
// OBSOLETE           {
// OBSOLETE             strcpy(remcomOutBuffer,"E02");
// OBSOLETE           }
// OBSOLETE       }
// OBSOLETE 	break;
// OBSOLETE       case 'm': /* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
// OBSOLETE 		/* TRY TO READ %x,%x.  IF SUCCEED, SET PTR = 0 */
// OBSOLETE 	if (hexToInt(&ptr,&addr))
// OBSOLETE 	  if (*(ptr++) == ',')
// OBSOLETE 	    if (hexToInt(&ptr,&length))
// OBSOLETE 	      {
// OBSOLETE 		ptr = 0;
// OBSOLETE 		mem_err = 0;
// OBSOLETE 		mem2hex((unsigned char*) addr, remcomOutBuffer, length, 1);
// OBSOLETE 		if (mem_err) {
// OBSOLETE 		  strcpy (remcomOutBuffer, "E03");
// OBSOLETE 		  gdb_error ("memory fault", "");
// OBSOLETE 		}
// OBSOLETE 	      }
// OBSOLETE 	if (ptr)
// OBSOLETE 	  {
// OBSOLETE 	    strcpy(remcomOutBuffer,"E01");
// OBSOLETE 	  }
// OBSOLETE 	break;
// OBSOLETE       case '?': 
// OBSOLETE 	remcomOutBuffer[0] = 'S';
// OBSOLETE 	remcomOutBuffer[1] =  hexchars[sigval >> 4];
// OBSOLETE 	remcomOutBuffer[2] =  hexchars[sigval % 16];
// OBSOLETE 	remcomOutBuffer[3] = 0;
// OBSOLETE 	break;
// OBSOLETE       case 'd': 
// OBSOLETE 	remote_debug = !(remote_debug);  /* toggle debug flag */
// OBSOLETE 	break;
// OBSOLETE       case 'g': /* return the value of the CPU registers */
// OBSOLETE 	mem2hex((unsigned char*) registers, remcomOutBuffer, NUMREGBYTES, 0);
// OBSOLETE 	break;
// OBSOLETE       case 'P': /* set the value of a single CPU register - return OK */
// OBSOLETE 	{
// OBSOLETE 	  int regno;
// OBSOLETE 
// OBSOLETE 	  if (hexToInt (&ptr, &regno) && *ptr++ == '=')
// OBSOLETE 	    if (regno >= 0 && regno < NUMREGS)
// OBSOLETE 	      {
// OBSOLETE 		int stackmode;
// OBSOLETE 
// OBSOLETE 		hex2mem (ptr, (unsigned char *) &registers[regno], 4, 0);
// OBSOLETE 		/*
// OBSOLETE 		 * Since we just changed a single CPU register, let's
// OBSOLETE 		 * make sure to keep the several stack pointers consistant.
// OBSOLETE 		 */
// OBSOLETE 		stackmode = registers[PSW] & 0x80;
// OBSOLETE 		if (regno == R15)	/* stack pointer changed */
// OBSOLETE 		  {			/* need to change SPI or SPU */
// OBSOLETE 		    if (stackmode == 0)
// OBSOLETE 		      registers[SPI] = registers[R15];
// OBSOLETE 		    else
// OBSOLETE 		      registers[SPU] = registers[R15];
// OBSOLETE 		  }
// OBSOLETE 		else if (regno == SPU)	/* "user" stack pointer changed */
// OBSOLETE 		  {
// OBSOLETE 		    if (stackmode != 0)	/* stack in user mode: copy SP */
// OBSOLETE 		      registers[R15] = registers[SPU];
// OBSOLETE 		  }
// OBSOLETE 		else if (regno == SPI)	/* "interrupt" stack pointer changed */
// OBSOLETE 		  {
// OBSOLETE 		    if (stackmode == 0)	/* stack in interrupt mode: copy SP */
// OBSOLETE 		      registers[R15] = registers[SPI];
// OBSOLETE 		  }
// OBSOLETE 		else if (regno == PSW)	/* stack mode may have changed! */
// OBSOLETE 		  {			/* force SP to either SPU or SPI */
// OBSOLETE 		    if (stackmode == 0)	/* stack in user mode */
// OBSOLETE 		      registers[R15] = registers[SPI];
// OBSOLETE 		    else		/* stack in interrupt mode */
// OBSOLETE 		      registers[R15] = registers[SPU];
// OBSOLETE 		  }
// OBSOLETE 		strcpy (remcomOutBuffer, "OK");
// OBSOLETE 		break;
// OBSOLETE 	      }
// OBSOLETE 	  strcpy (remcomOutBuffer, "E01");
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       case 'G': /* set the value of the CPU registers - return OK */
// OBSOLETE 	hex2mem(ptr, (unsigned char*) registers, NUMREGBYTES, 0);
// OBSOLETE 	strcpy(remcomOutBuffer,"OK");
// OBSOLETE 	break;
// OBSOLETE       case 's': /* sAA..AA	Step one instruction from AA..AA(optional) */
// OBSOLETE 	stepping = 1;
// OBSOLETE       case 'c': /* cAA..AA	Continue from address AA..AA(optional) */
// OBSOLETE 		/* try to read optional parameter, pc unchanged if no parm */
// OBSOLETE 	if (hexToInt(&ptr,&addr))
// OBSOLETE 	  registers[ PC ] = addr;
// OBSOLETE 	
// OBSOLETE 	if (stepping)	/* single-stepping */
// OBSOLETE 	  {
// OBSOLETE 	    if (!prepare_to_step(0))	/* set up for single-step */
// OBSOLETE 	      {
// OBSOLETE 		/* prepare_to_step has already emulated the target insn:
// OBSOLETE 		   Send SIGTRAP to gdb, don't resume the target at all.  */
// OBSOLETE 		ptr = remcomOutBuffer;
// OBSOLETE 		*ptr++ = 'T';           /* Simulate stopping with SIGTRAP */
// OBSOLETE 		*ptr++ = '0';
// OBSOLETE 		*ptr++ = '5';
// OBSOLETE 
// OBSOLETE 		*ptr++ = hexchars[PC >> 4];     /* send PC */
// OBSOLETE 		*ptr++ = hexchars[PC & 0xf];
// OBSOLETE 		*ptr++ = ':';
// OBSOLETE 		ptr = mem2hex((unsigned char *)&registers[PC], ptr, 4, 0);
// OBSOLETE 		*ptr++ = ';';
// OBSOLETE 
// OBSOLETE 		*ptr++ = hexchars[R13 >> 4];    /* send FP */
// OBSOLETE 		*ptr++ = hexchars[R13 & 0xf];
// OBSOLETE 		*ptr++ = ':';
// OBSOLETE 		ptr = mem2hex((unsigned char *)&registers[R13], ptr, 4, 0);
// OBSOLETE 		*ptr++ = ';';
// OBSOLETE 
// OBSOLETE 		*ptr++ = hexchars[R15 >> 4];    /* send SP */
// OBSOLETE 		*ptr++ = hexchars[R15 & 0xf];
// OBSOLETE 		*ptr++ = ':';
// OBSOLETE 		ptr = mem2hex((unsigned char *)&registers[R15], ptr, 4, 0);
// OBSOLETE 		*ptr++ = ';';
// OBSOLETE 		*ptr++ = 0;
// OBSOLETE 
// OBSOLETE 		break;	
// OBSOLETE 	      }
// OBSOLETE 	  }
// OBSOLETE 	else	/* continuing, not single-stepping */
// OBSOLETE 	  {
// OBSOLETE 	    /* OK, about to do a "continue".  First check to see if the 
// OBSOLETE 	       target pc is on an odd boundary (second instruction in the 
// OBSOLETE 	       word).  If so, we must do a single-step first, because 
// OBSOLETE 	       ya can't jump or return back to an odd boundary!  */
// OBSOLETE 	    if ((registers[PC] & 2) != 0)
// OBSOLETE 	      prepare_to_step(1);
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE 	return;
// OBSOLETE 
// OBSOLETE       case 'D':	/* Detach */
// OBSOLETE #if 0
// OBSOLETE 	/* I am interpreting this to mean, release the board from control 
// OBSOLETE 	   by the remote stub.  To do this, I am restoring the original
// OBSOLETE 	   (or at least previous) exception vectors.
// OBSOLETE 	 */
// OBSOLETE 	for (i = 0; i < 18; i++)
// OBSOLETE 	  exceptionHandler (i, save_vectors[i]);
// OBSOLETE 	putpacket ("OK");
// OBSOLETE 	return;		/* continue the inferior */
// OBSOLETE #else
// OBSOLETE 	strcpy(remcomOutBuffer,"OK");
// OBSOLETE 	break;
// OBSOLETE #endif
// OBSOLETE     case 'q':
// OBSOLETE       if (*ptr++ == 'C' &&
// OBSOLETE 	  *ptr++ == 'R' &&
// OBSOLETE 	  *ptr++ == 'C' &&
// OBSOLETE 	  *ptr++ == ':')
// OBSOLETE 	{
// OBSOLETE 	  unsigned long start, len, our_crc;
// OBSOLETE 
// OBSOLETE 	  if (hexToInt (&ptr, (int *) &start) &&
// OBSOLETE 	      *ptr++ == ','                   &&
// OBSOLETE 	      hexToInt (&ptr, (int *) &len))
// OBSOLETE 	    {
// OBSOLETE 	      remcomOutBuffer[0] = 'C';
// OBSOLETE 	      our_crc = crc32 ((unsigned char *) start, len, 0xffffffff);
// OBSOLETE 	      mem2hex ((char *) &our_crc, 
// OBSOLETE 		       &remcomOutBuffer[1], 
// OBSOLETE 		       sizeof (long), 
// OBSOLETE 		       0); 
// OBSOLETE 	    } /* else do nothing */
// OBSOLETE 	} /* else do nothing */
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE       case 'k': /* kill the program */
// OBSOLETE 	continue;
// OBSOLETE       } /* switch */
// OBSOLETE 
// OBSOLETE     /* reply to the request */
// OBSOLETE     putpacket(remcomOutBuffer);
// OBSOLETE   }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* qCRC support */
// OBSOLETE 
// OBSOLETE /* Table used by the crc32 function to calcuate the checksum. */
// OBSOLETE static unsigned long crc32_table[256] = {0, 0};
// OBSOLETE 
// OBSOLETE static unsigned long
// OBSOLETE crc32 (unsigned char *buf, int len, unsigned long crc)
// OBSOLETE {
// OBSOLETE   if (! crc32_table[1])
// OBSOLETE     {
// OBSOLETE       /* Initialize the CRC table and the decoding table. */
// OBSOLETE       int i, j;
// OBSOLETE       unsigned long c;
// OBSOLETE 
// OBSOLETE       for (i = 0; i < 256; i++)
// OBSOLETE 	{
// OBSOLETE 	  for (c = i << 24, j = 8; j > 0; --j)
// OBSOLETE 	    c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : (c << 1);
// OBSOLETE 	  crc32_table[i] = c;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   while (len--)
// OBSOLETE     {
// OBSOLETE       crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ *buf) & 255];
// OBSOLETE       buf++;
// OBSOLETE     }
// OBSOLETE   return crc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int 
// OBSOLETE hex (unsigned char ch)
// OBSOLETE {
// OBSOLETE   if ((ch >= 'a') && (ch <= 'f')) return (ch-'a'+10);
// OBSOLETE   if ((ch >= '0') && (ch <= '9')) return (ch-'0');
// OBSOLETE   if ((ch >= 'A') && (ch <= 'F')) return (ch-'A'+10);
// OBSOLETE   return (-1);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* scan for the sequence $<data>#<checksum>     */
// OBSOLETE 
// OBSOLETE unsigned char *
// OBSOLETE getpacket (void)
// OBSOLETE {
// OBSOLETE   unsigned char *buffer = &remcomInBuffer[0];
// OBSOLETE   unsigned char checksum;
// OBSOLETE   unsigned char xmitcsum;
// OBSOLETE   int count;
// OBSOLETE   char ch;
// OBSOLETE 
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       /* wait around for the start character, ignore all other characters */
// OBSOLETE       while ((ch = getDebugChar ()) != '$')
// OBSOLETE 	;
// OBSOLETE 
// OBSOLETE retry:
// OBSOLETE       checksum = 0;
// OBSOLETE       xmitcsum = -1;
// OBSOLETE       count = 0;
// OBSOLETE 
// OBSOLETE       /* now, read until a # or end of buffer is found */
// OBSOLETE       while (count < BUFMAX)
// OBSOLETE 	{
// OBSOLETE 	  ch = getDebugChar ();
// OBSOLETE           if (ch == '$')
// OBSOLETE 	    goto retry;
// OBSOLETE 	  if (ch == '#')
// OBSOLETE 	    break;
// OBSOLETE 	  checksum = checksum + ch;
// OBSOLETE 	  buffer[count] = ch;
// OBSOLETE 	  count = count + 1;
// OBSOLETE 	}
// OBSOLETE       buffer[count] = 0;
// OBSOLETE 
// OBSOLETE       if (ch == '#')
// OBSOLETE 	{
// OBSOLETE 	  ch = getDebugChar ();
// OBSOLETE 	  xmitcsum = hex (ch) << 4;
// OBSOLETE 	  ch = getDebugChar ();
// OBSOLETE 	  xmitcsum += hex (ch);
// OBSOLETE 
// OBSOLETE 	  if (checksum != xmitcsum)
// OBSOLETE 	    {
// OBSOLETE 	      if (remote_debug)
// OBSOLETE 		{
// OBSOLETE 		  unsigned char buf[16];
// OBSOLETE 
// OBSOLETE 		  mem2hex((unsigned char *) &checksum, buf, 4, 0);
// OBSOLETE 		  gdb_error("Bad checksum: my count = %s, ", buf);
// OBSOLETE 		  mem2hex((unsigned char *) &xmitcsum, buf, 4, 0);
// OBSOLETE 		  gdb_error("sent count = %s\n", buf);
// OBSOLETE 		  gdb_error(" -- Bad buffer: \"%s\"\n", buffer); 
// OBSOLETE 		}
// OBSOLETE 	      putDebugChar ('-');	/* failed checksum */
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      putDebugChar ('+');	/* successful transfer */
// OBSOLETE 
// OBSOLETE 	      /* if a sequence char is present, reply the sequence ID */
// OBSOLETE 	      if (buffer[2] == ':')
// OBSOLETE 		{
// OBSOLETE 		  putDebugChar (buffer[0]);
// OBSOLETE 		  putDebugChar (buffer[1]);
// OBSOLETE 
// OBSOLETE 		  return &buffer[3];
// OBSOLETE 		}
// OBSOLETE 
// OBSOLETE 	      return &buffer[0];
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* send the packet in buffer.  */
// OBSOLETE 
// OBSOLETE static void 
// OBSOLETE putpacket (unsigned char *buffer)
// OBSOLETE {
// OBSOLETE   unsigned char checksum;
// OBSOLETE   int  count;
// OBSOLETE   char ch;
// OBSOLETE 
// OBSOLETE   /*  $<packet info>#<checksum>. */
// OBSOLETE   do {
// OBSOLETE     putDebugChar('$');
// OBSOLETE     checksum = 0;
// OBSOLETE     count    = 0;
// OBSOLETE 
// OBSOLETE     while (ch=buffer[count]) {
// OBSOLETE       putDebugChar(ch);
// OBSOLETE       checksum += ch;
// OBSOLETE       count += 1;
// OBSOLETE     }
// OBSOLETE     putDebugChar('#');
// OBSOLETE     putDebugChar(hexchars[checksum >> 4]);
// OBSOLETE     putDebugChar(hexchars[checksum % 16]);
// OBSOLETE   } while (getDebugChar() != '+');
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Address of a routine to RTE to if we get a memory fault.  */
// OBSOLETE 
// OBSOLETE static void (*volatile mem_fault_routine)() = 0;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE set_mem_err (void)
// OBSOLETE {
// OBSOLETE   mem_err = 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Check the address for safe access ranges.  As currently defined,
// OBSOLETE    this routine will reject the "expansion bus" address range(s).
// OBSOLETE    To make those ranges useable, someone must implement code to detect
// OBSOLETE    whether there's anything connected to the expansion bus. */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE mem_safe (unsigned char *addr)
// OBSOLETE {
// OBSOLETE #define BAD_RANGE_ONE_START	((unsigned char *) 0x600000)
// OBSOLETE #define BAD_RANGE_ONE_END	((unsigned char *) 0xa00000)
// OBSOLETE #define BAD_RANGE_TWO_START	((unsigned char *) 0xff680000)
// OBSOLETE #define BAD_RANGE_TWO_END	((unsigned char *) 0xff800000)
// OBSOLETE 
// OBSOLETE   if (addr < BAD_RANGE_ONE_START)	return 1;	/* safe */
// OBSOLETE   if (addr < BAD_RANGE_ONE_END)		return 0;	/* unsafe */
// OBSOLETE   if (addr < BAD_RANGE_TWO_START)	return 1;	/* safe */
// OBSOLETE   if (addr < BAD_RANGE_TWO_END)		return 0;	/* unsafe */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* These are separate functions so that they are so short and sweet
// OBSOLETE    that the compiler won't save any registers (if there is a fault
// OBSOLETE    to mem_fault, they won't get restored, so there better not be any
// OBSOLETE    saved).  */
// OBSOLETE static int
// OBSOLETE get_char (unsigned char *addr)
// OBSOLETE {
// OBSOLETE #if 1
// OBSOLETE   if (mem_fault_routine && !mem_safe(addr))
// OBSOLETE     {
// OBSOLETE       mem_fault_routine ();
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE #endif
// OBSOLETE   return *addr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE set_char (unsigned char *addr, unsigned char val)
// OBSOLETE {
// OBSOLETE #if 1
// OBSOLETE   if (mem_fault_routine && !mem_safe (addr))
// OBSOLETE     {
// OBSOLETE       mem_fault_routine ();
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE #endif
// OBSOLETE   *addr = val;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Convert the memory pointed to by mem into hex, placing result in buf.
// OBSOLETE    Return a pointer to the last char put in buf (null).
// OBSOLETE    If MAY_FAULT is non-zero, then we should set mem_err in response to
// OBSOLETE    a fault; if zero treat a fault like any other fault in the stub.  */
// OBSOLETE 
// OBSOLETE static unsigned char *
// OBSOLETE mem2hex (unsigned char *mem, unsigned char *buf, int count, int may_fault)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   unsigned char ch;
// OBSOLETE 
// OBSOLETE   if (may_fault)
// OBSOLETE     mem_fault_routine = set_mem_err;
// OBSOLETE   for (i=0;i<count;i++) {
// OBSOLETE     ch = get_char (mem++);
// OBSOLETE     if (may_fault && mem_err)
// OBSOLETE       return (buf);
// OBSOLETE     *buf++ = hexchars[ch >> 4];
// OBSOLETE     *buf++ = hexchars[ch % 16];
// OBSOLETE   }
// OBSOLETE   *buf = 0;
// OBSOLETE   if (may_fault)
// OBSOLETE     mem_fault_routine = 0;
// OBSOLETE   return(buf);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Convert the hex array pointed to by buf into binary to be placed in mem.
// OBSOLETE    Return a pointer to the character AFTER the last byte written. */
// OBSOLETE 
// OBSOLETE static unsigned char* 
// OBSOLETE hex2mem (unsigned char *buf, unsigned char *mem, int count, int may_fault)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   unsigned char ch;
// OBSOLETE 
// OBSOLETE   if (may_fault)
// OBSOLETE     mem_fault_routine = set_mem_err;
// OBSOLETE   for (i=0;i<count;i++) {
// OBSOLETE     ch = hex(*buf++) << 4;
// OBSOLETE     ch = ch + hex(*buf++);
// OBSOLETE     set_char (mem++, ch);
// OBSOLETE     if (may_fault && mem_err)
// OBSOLETE       return (mem);
// OBSOLETE   }
// OBSOLETE   if (may_fault)
// OBSOLETE     mem_fault_routine = 0;
// OBSOLETE   return(mem);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Convert the binary stream in BUF to memory.
// OBSOLETE 
// OBSOLETE    Gdb will escape $, #, and the escape char (0x7d).
// OBSOLETE    COUNT is the total number of bytes to write into
// OBSOLETE    memory. */
// OBSOLETE static unsigned char *
// OBSOLETE bin2mem (unsigned char *buf, unsigned char *mem, int count, int may_fault)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   unsigned char ch;
// OBSOLETE 
// OBSOLETE   if (may_fault)
// OBSOLETE     mem_fault_routine = set_mem_err;
// OBSOLETE   for (i = 0; i < count; i++)
// OBSOLETE     {
// OBSOLETE       /* Check for any escaped characters. Be paranoid and
// OBSOLETE          only unescape chars that should be escaped. */
// OBSOLETE       if (*buf == 0x7d)
// OBSOLETE         {
// OBSOLETE           switch (*(buf+1))
// OBSOLETE             {
// OBSOLETE             case 0x3:  /* # */
// OBSOLETE             case 0x4:  /* $ */
// OBSOLETE             case 0x5d: /* escape char */
// OBSOLETE               buf++;
// OBSOLETE               *buf |= 0x20;
// OBSOLETE               break;
// OBSOLETE             default:
// OBSOLETE               /* nothing */
// OBSOLETE               break;
// OBSOLETE             }
// OBSOLETE         }
// OBSOLETE 
// OBSOLETE       set_char (mem++, *buf++);
// OBSOLETE 
// OBSOLETE       if (may_fault && mem_err)
// OBSOLETE         return mem;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (may_fault)
// OBSOLETE     mem_fault_routine = 0;
// OBSOLETE   return mem;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* this function takes the m32r exception vector and attempts to
// OBSOLETE    translate this number into a unix compatible signal value */
// OBSOLETE 
// OBSOLETE static int 
// OBSOLETE computeSignal (int exceptionVector)
// OBSOLETE {
// OBSOLETE   int sigval;
// OBSOLETE   switch (exceptionVector) {
// OBSOLETE     case 0  : sigval = 23; break; /* I/O trap                    */
// OBSOLETE     case 1  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 2  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 3  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 4  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 5  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 6  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 7  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 8  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 9  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 10 : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 11 : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 12 : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 13 : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 14 : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 15 : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 16 : sigval = 10; break; /* BUS ERROR (alignment)       */
// OBSOLETE     case 17 : sigval = 2;  break; /* INTerrupt                   */
// OBSOLETE     default : sigval = 7;  break; /* "software generated"        */
// OBSOLETE   }
// OBSOLETE   return (sigval);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /**********************************************/
// OBSOLETE /* WHILE WE FIND NICE HEX CHARS, BUILD AN INT */
// OBSOLETE /* RETURN NUMBER OF CHARS PROCESSED           */
// OBSOLETE /**********************************************/
// OBSOLETE static int 
// OBSOLETE hexToInt (unsigned char **ptr, int *intValue)
// OBSOLETE {
// OBSOLETE   int numChars = 0;
// OBSOLETE   int hexValue;
// OBSOLETE 
// OBSOLETE   *intValue = 0;
// OBSOLETE   while (**ptr)
// OBSOLETE     {
// OBSOLETE       hexValue = hex(**ptr);
// OBSOLETE       if (hexValue >=0)
// OBSOLETE         {
// OBSOLETE 	  *intValue = (*intValue <<4) | hexValue;
// OBSOLETE 	  numChars ++;
// OBSOLETE         }
// OBSOLETE       else
// OBSOLETE 	break;
// OBSOLETE       (*ptr)++;
// OBSOLETE     }
// OBSOLETE   return (numChars);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE   Table of branch instructions:
// OBSOLETE   
// OBSOLETE   10B6		RTE	return from trap or exception
// OBSOLETE   1FCr		JMP	jump
// OBSOLETE   1ECr		JL	jump and link
// OBSOLETE   7Fxx		BRA	branch
// OBSOLETE   FFxxxxxx	BRA	branch (long)
// OBSOLETE   B09rxxxx	BNEZ	branch not-equal-zero
// OBSOLETE   Br1rxxxx	BNE	branch not-equal
// OBSOLETE   7Dxx		BNC	branch not-condition
// OBSOLETE   FDxxxxxx	BNC	branch not-condition (long)
// OBSOLETE   B0Arxxxx	BLTZ	branch less-than-zero
// OBSOLETE   B0Crxxxx	BLEZ	branch less-equal-zero
// OBSOLETE   7Exx		BL	branch and link
// OBSOLETE   FExxxxxx	BL	branch and link (long)
// OBSOLETE   B0Drxxxx	BGTZ	branch greater-than-zero
// OBSOLETE   B0Brxxxx	BGEZ	branch greater-equal-zero
// OBSOLETE   B08rxxxx	BEQZ	branch equal-zero
// OBSOLETE   Br0rxxxx	BEQ	branch equal
// OBSOLETE   7Cxx		BC	branch condition
// OBSOLETE   FCxxxxxx	BC	branch condition (long)
// OBSOLETE   */
// OBSOLETE 
// OBSOLETE static int 
// OBSOLETE isShortBranch (unsigned char *instr)
// OBSOLETE {
// OBSOLETE   unsigned char instr0 = instr[0] & 0x7F;		/* mask off high bit */
// OBSOLETE 
// OBSOLETE   if (instr0 == 0x10 && instr[1] == 0xB6)	/* RTE */
// OBSOLETE     return 1;		/* return from trap or exception */
// OBSOLETE 
// OBSOLETE   if (instr0 == 0x1E || instr0 == 0x1F)		/* JL or JMP */
// OBSOLETE     if ((instr[1] & 0xF0) == 0xC0)
// OBSOLETE       return 2;					/* jump thru a register */
// OBSOLETE 
// OBSOLETE   if (instr0 == 0x7C || instr0 == 0x7D || 	/* BC, BNC, BL, BRA */
// OBSOLETE       instr0 == 0x7E || instr0 == 0x7F)
// OBSOLETE     return 3;					/* eight bit PC offset */
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE isLongBranch (unsigned char *instr)
// OBSOLETE {
// OBSOLETE   if (instr[0] == 0xFC || instr[0] == 0xFD ||	/* BRA, BNC, BL, BC */
// OBSOLETE       instr[0] == 0xFE || instr[0] == 0xFF)	/* 24 bit relative */
// OBSOLETE     return 4;
// OBSOLETE   if ((instr[0] & 0xF0) == 0xB0)		/* 16 bit relative */
// OBSOLETE     {
// OBSOLETE       if ((instr[1] & 0xF0) == 0x00 || 		/* BNE, BEQ */
// OBSOLETE 	  (instr[1] & 0xF0) == 0x10)
// OBSOLETE 	return 5;
// OBSOLETE       if (instr[0] == 0xB0)	/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ, BEQZ */
// OBSOLETE 	if ((instr[1] & 0xF0) == 0x80 || (instr[1] & 0xF0) == 0x90 || 
// OBSOLETE 	    (instr[1] & 0xF0) == 0xA0 || (instr[1] & 0xF0) == 0xB0 ||
// OBSOLETE 	    (instr[1] & 0xF0) == 0xC0 || (instr[1] & 0xF0) == 0xD0)
// OBSOLETE 	  return 6;
// OBSOLETE     }
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* if address is NOT on a 4-byte boundary, or high-bit of instr is zero, 
// OBSOLETE    then it's a 2-byte instruction, else it's a 4-byte instruction.  */
// OBSOLETE 
// OBSOLETE #define INSTRUCTION_SIZE(addr) \
// OBSOLETE     ((((int) addr & 2) || (((unsigned char *) addr)[0] & 0x80) == 0) ? 2 : 4)
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE isBranch (unsigned char *instr)
// OBSOLETE {
// OBSOLETE   if (INSTRUCTION_SIZE(instr) == 2)
// OBSOLETE     return isShortBranch(instr);
// OBSOLETE   else
// OBSOLETE     return isLongBranch(instr);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE willBranch (unsigned char *instr, int branchCode)
// OBSOLETE {
// OBSOLETE   switch (branchCode) 
// OBSOLETE     {
// OBSOLETE     case 0:	return 0;	/* not a branch */
// OBSOLETE     case 1:	return 1;	/* RTE */
// OBSOLETE     case 2:	return 1;	/* JL or JMP    */
// OBSOLETE     case 3:			/* BC, BNC, BL, BRA (short) */
// OBSOLETE     case 4:			/* BC, BNC, BL, BRA (long) */
// OBSOLETE       switch (instr[0] & 0x0F) 
// OBSOLETE 	{
// OBSOLETE 	case 0xC:		/* Branch if Condition Register */
// OBSOLETE 	  return (registers[CBR] != 0);
// OBSOLETE 	case 0xD:		/* Branch if NOT Condition Register */
// OBSOLETE 	  return (registers[CBR] == 0);
// OBSOLETE 	case 0xE:		/* Branch and Link */
// OBSOLETE 	case 0xF:		/* Branch (unconditional) */
// OBSOLETE 	  return 1;
// OBSOLETE 	default:		/* oops? */
// OBSOLETE 	  return 0;
// OBSOLETE 	}
// OBSOLETE     case 5: 			/* BNE, BEQ */
// OBSOLETE       switch (instr[1] & 0xF0) 
// OBSOLETE 	{
// OBSOLETE 	case 0x00:		/* Branch if r1 equal to r2 */
// OBSOLETE 	  return (registers[instr[0] & 0x0F] == registers[instr[1] & 0x0F]);
// OBSOLETE 	case 0x10:		/* Branch if r1 NOT equal to r2 */
// OBSOLETE 	  return (registers[instr[0] & 0x0F] != registers[instr[1] & 0x0F]);
// OBSOLETE 	default:		/* oops? */
// OBSOLETE 	  return 0;
// OBSOLETE 	}
// OBSOLETE     case 6: 			/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ */
// OBSOLETE       switch (instr[1] & 0xF0) 
// OBSOLETE 	{
// OBSOLETE 	case 0x80:		/* Branch if reg equal to zero */
// OBSOLETE 	  return (registers[instr[1] & 0x0F] == 0);
// OBSOLETE 	case 0x90:		/* Branch if reg NOT equal to zero */
// OBSOLETE 	  return (registers[instr[1] & 0x0F] != 0);
// OBSOLETE 	case 0xA0:		/* Branch if reg less than zero */
// OBSOLETE 	  return (registers[instr[1] & 0x0F] < 0);
// OBSOLETE 	case 0xB0:		/* Branch if reg greater or equal to zero */
// OBSOLETE 	  return (registers[instr[1] & 0x0F] >= 0);
// OBSOLETE 	case 0xC0:		/* Branch if reg less than or equal to zero */
// OBSOLETE 	  return (registers[instr[1] & 0x0F] <= 0);
// OBSOLETE 	case 0xD0:		/* Branch if reg greater than zero */
// OBSOLETE 	  return (registers[instr[1] & 0x0F] > 0);
// OBSOLETE 	default:		/* oops? */
// OBSOLETE 	  return 0;
// OBSOLETE 	}
// OBSOLETE     default:			/* oops? */
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int 
// OBSOLETE branchDestination (unsigned char *instr, int branchCode)
// OBSOLETE { 
// OBSOLETE   switch (branchCode) { 
// OBSOLETE   default: 
// OBSOLETE   case 0:					/* not a branch */ 
// OBSOLETE     return 0;
// OBSOLETE   case 1:					/* RTE */ 
// OBSOLETE     return registers[BPC] & ~3; 		/* pop BPC into PC */
// OBSOLETE   case 2: 					/* JL or JMP */ 
// OBSOLETE     return registers[instr[1] & 0x0F] & ~3;	/* jump thru a register */ 
// OBSOLETE   case 3: 		/* BC, BNC, BL, BRA (short, 8-bit relative offset) */ 
// OBSOLETE     return (((int) instr) & ~3) + ((char) instr[1] << 2);
// OBSOLETE   case 4: 		/* BC, BNC, BL, BRA (long, 24-bit relative offset) */ 
// OBSOLETE     return ((int) instr + 
// OBSOLETE 	    ((((char) instr[1] << 16) | (instr[2] << 8) | (instr[3])) << 2)); 
// OBSOLETE   case 5: 		/* BNE, BEQ (16-bit relative offset) */ 
// OBSOLETE   case 6: 		/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ (ditto) */ 
// OBSOLETE     return ((int) instr + ((((char) instr[2] << 8) | (instr[3])) << 2)); 
// OBSOLETE   }
// OBSOLETE 
// OBSOLETE   /* An explanatory note: in the last three return expressions, I have
// OBSOLETE      cast the most-significant byte of the return offset to char.
// OBSOLETE      What this accomplishes is sign extension.  If the other
// OBSOLETE      less-significant bytes were signed as well, they would get sign
// OBSOLETE      extended too and, if negative, their leading bits would clobber
// OBSOLETE      the bits of the more-significant bytes ahead of them.  There are
// OBSOLETE      other ways I could have done this, but sign extension from
// OBSOLETE      odd-sized integers is always a pain. */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE branchSideEffects (unsigned char *instr, int branchCode)
// OBSOLETE {
// OBSOLETE   switch (branchCode)
// OBSOLETE     {
// OBSOLETE     case 1:			/* RTE */
// OBSOLETE       return;			/* I <THINK> this is already handled... */
// OBSOLETE     case 2:			/* JL (or JMP) */
// OBSOLETE     case 3:			/* BL (or BC, BNC, BRA) */
// OBSOLETE     case 4:
// OBSOLETE       if ((instr[0] & 0x0F) == 0x0E)		/* branch/jump and link */
// OBSOLETE 	registers[R14] = (registers[PC] & ~3) + 4;
// OBSOLETE       return;
// OBSOLETE     default:			/* any other branch has no side effects */
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct STEPPING_CONTEXT {
// OBSOLETE   int stepping;			/* true when we've started a single-step */
// OBSOLETE   unsigned long  target_addr;	/* the instr we're trying to execute */
// OBSOLETE   unsigned long  target_size;	/* the size of the target instr */
// OBSOLETE   unsigned long  noop_addr;	/* where we've inserted a no-op, if any */
// OBSOLETE   unsigned long  trap1_addr;	/* the trap following the target instr */
// OBSOLETE   unsigned long  trap2_addr;	/* the trap at a branch destination, if any */
// OBSOLETE   unsigned short noop_save;	/* instruction overwritten by our no-op */
// OBSOLETE   unsigned short trap1_save;	/* instruction overwritten by trap1 */
// OBSOLETE   unsigned short trap2_save;	/* instruction overwritten by trap2 */
// OBSOLETE   unsigned short continue_p;	/* true if NOT returning to gdb after step */
// OBSOLETE } stepping;
// OBSOLETE 
// OBSOLETE /* Function: prepare_to_step
// OBSOLETE    Called from handle_exception to prepare the user program to single-step.
// OBSOLETE    Places a trap instruction after the target instruction, with special 
// OBSOLETE    extra handling for branch instructions and for instructions in the 
// OBSOLETE    second half-word of a word.  
// OBSOLETE 
// OBSOLETE    Returns: True  if we should actually execute the instruction; 
// OBSOLETE 	    False if we are going to emulate executing the instruction,
// OBSOLETE 	    in which case we simply report to GDB that the instruction 
// OBSOLETE 	    has already been executed.  */
// OBSOLETE 
// OBSOLETE #define TRAP1  0x10f1;	/* trap #1 instruction */
// OBSOLETE #define NOOP   0x7000;  /* noop    instruction */
// OBSOLETE 
// OBSOLETE static unsigned short trap1 = TRAP1;
// OBSOLETE static unsigned short noop  = NOOP;
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE prepare_to_step(continue_p)
// OBSOLETE      int continue_p;	/* if this isn't REALLY a single-step (see below) */
// OBSOLETE {
// OBSOLETE   unsigned long pc = registers[PC];
// OBSOLETE   int branchCode   = isBranch((unsigned char *) pc);
// OBSOLETE   unsigned char *p;
// OBSOLETE 
// OBSOLETE   /* zero out the stepping context 
// OBSOLETE      (paranoia -- it should already be zeroed) */
// OBSOLETE   for (p = (unsigned char *) &stepping;
// OBSOLETE        p < ((unsigned char *) &stepping) + sizeof(stepping);
// OBSOLETE        p++)
// OBSOLETE     *p = 0;
// OBSOLETE 
// OBSOLETE   if (branchCode != 0)			/* next instruction is a branch */
// OBSOLETE     {
// OBSOLETE       branchSideEffects((unsigned char *) pc, branchCode);
// OBSOLETE       if (willBranch((unsigned char *)pc, branchCode))
// OBSOLETE 	registers[PC] = branchDestination((unsigned char *) pc, branchCode);
// OBSOLETE       else
// OBSOLETE 	registers[PC] = pc + INSTRUCTION_SIZE(pc);
// OBSOLETE       return 0;			/* branch "executed" -- just notify GDB */
// OBSOLETE     }
// OBSOLETE   else if (((int) pc & 2) != 0)		/* "second-slot" instruction */
// OBSOLETE     {
// OBSOLETE       /* insert no-op before pc */
// OBSOLETE       stepping.noop_addr  =  pc - 2;
// OBSOLETE       stepping.noop_save  = *(unsigned short *) stepping.noop_addr;
// OBSOLETE       *(unsigned short *) stepping.noop_addr  = noop;
// OBSOLETE       /* insert trap  after  pc */
// OBSOLETE       stepping.trap1_addr =  pc + 2;
// OBSOLETE       stepping.trap1_save = *(unsigned short *) stepping.trap1_addr;
// OBSOLETE       *(unsigned short *) stepping.trap1_addr = trap1;
// OBSOLETE     }
// OBSOLETE   else					/* "first-slot" instruction */
// OBSOLETE     {
// OBSOLETE       /* insert trap  after  pc */
// OBSOLETE       stepping.trap1_addr = pc + INSTRUCTION_SIZE(pc);	
// OBSOLETE       stepping.trap1_save = *(unsigned short *) stepping.trap1_addr;
// OBSOLETE       *(unsigned short *) stepping.trap1_addr = trap1;
// OBSOLETE     }
// OBSOLETE   /* "continue_p" means that we are actually doing a continue, and not 
// OBSOLETE      being requested to single-step by GDB.  Sometimes we have to do
// OBSOLETE      one single-step before continuing, because the PC is on a half-word
// OBSOLETE      boundary.  There's no way to simply resume at such an address.  */
// OBSOLETE   stepping.continue_p = continue_p;
// OBSOLETE   stepping.stepping = 1;		/* starting a single-step */
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: finish_from_step
// OBSOLETE    Called from handle_exception to finish up when the user program 
// OBSOLETE    returns from a single-step.  Replaces the instructions that had
// OBSOLETE    been overwritten by traps or no-ops, 
// OBSOLETE 
// OBSOLETE    Returns: True  if we should notify GDB that the target stopped.
// OBSOLETE 	    False if we only single-stepped because we had to before we
// OBSOLETE 	    could continue (ie. we were trying to continue at a 
// OBSOLETE 	    half-word boundary).  In that case don't notify GDB:
// OBSOLETE 	    just "continue continuing".  */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE finish_from_step (void)
// OBSOLETE {
// OBSOLETE   if (stepping.stepping)	/* anything to do? */
// OBSOLETE     {
// OBSOLETE       int continue_p = stepping.continue_p;
// OBSOLETE       unsigned char *p;
// OBSOLETE 
// OBSOLETE       if (stepping.noop_addr)	/* replace instr "under" our no-op */
// OBSOLETE 	*(unsigned short *) stepping.noop_addr  = stepping.noop_save;
// OBSOLETE       if (stepping.trap1_addr)	/* replace instr "under" our trap  */
// OBSOLETE 	*(unsigned short *) stepping.trap1_addr = stepping.trap1_save;
// OBSOLETE       if (stepping.trap2_addr)  /* ditto our other trap, if any    */
// OBSOLETE 	*(unsigned short *) stepping.trap2_addr = stepping.trap2_save;
// OBSOLETE 
// OBSOLETE       for (p = (unsigned char *) &stepping;	/* zero out the stepping context */
// OBSOLETE 	   p < ((unsigned char *) &stepping) + sizeof(stepping);
// OBSOLETE 	   p++)
// OBSOLETE 	*p = 0;
// OBSOLETE 
// OBSOLETE       return !(continue_p);
// OBSOLETE     }
// OBSOLETE   else 	/* we didn't single-step, therefore this must be a legitimate stop */
// OBSOLETE     return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE struct PSWreg {		/* separate out the bit flags in the PSW register */
// OBSOLETE   int pad1 : 16;
// OBSOLETE   int bsm  : 1;
// OBSOLETE   int bie  : 1;
// OBSOLETE   int pad2 : 5;
// OBSOLETE   int bc   : 1;
// OBSOLETE   int sm   : 1;
// OBSOLETE   int ie   : 1;
// OBSOLETE   int pad3 : 5;
// OBSOLETE   int c    : 1;
// OBSOLETE } *psw;
// OBSOLETE 
// OBSOLETE /* Upon entry the value for LR to save has been pushed.
// OBSOLETE    We unpush that so that the value for the stack pointer saved is correct.
// OBSOLETE    Upon entry, all other registers are assumed to have not been modified
// OBSOLETE    since the interrupt/trap occured.  */
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE stash_registers:
// OBSOLETE 	push r0
// OBSOLETE 	push r1
// OBSOLETE 	seth r1, #shigh(registers)
// OBSOLETE 	add3 r1, r1, #low(registers)
// OBSOLETE 	pop r0		; r1
// OBSOLETE 	st r0, @@(4,r1)
// OBSOLETE 	pop r0		; r0
// OBSOLETE 	st r0, @@r1
// OBSOLETE 	addi r1, #4	; only add 4 as subsequent saves are `pre inc'
// OBSOLETE 	st r2, @@+r1
// OBSOLETE 	st r3, @@+r1
// OBSOLETE 	st r4, @@+r1
// OBSOLETE 	st r5, @@+r1
// OBSOLETE 	st r6, @@+r1
// OBSOLETE 	st r7, @@+r1
// OBSOLETE 	st r8, @@+r1
// OBSOLETE 	st r9, @@+r1
// OBSOLETE 	st r10, @@+r1
// OBSOLETE 	st r11, @@+r1
// OBSOLETE 	st r12, @@+r1
// OBSOLETE 	st r13, @@+r1    ; fp
// OBSOLETE 	pop r0		; lr (r14)
// OBSOLETE 	st r0, @@+r1
// OBSOLETE 	st sp, @@+r1	; sp contains right value at this point
// OBSOLETE 	mvfc r0, cr0
// OBSOLETE 	st r0, @@+r1	; cr0 == PSW
// OBSOLETE 	mvfc r0, cr1
// OBSOLETE 	st r0, @@+r1	; cr1 == CBR
// OBSOLETE 	mvfc r0, cr2
// OBSOLETE 	st r0, @@+r1	; cr2 == SPI
// OBSOLETE 	mvfc r0, cr3
// OBSOLETE 	st r0, @@+r1	; cr3 == SPU
// OBSOLETE 	mvfc r0, cr6
// OBSOLETE 	st r0, @@+r1	; cr6 == BPC
// OBSOLETE 	st r0, @@+r1	; PC  == BPC
// OBSOLETE 	mvfaclo r0
// OBSOLETE 	st r0, @@+r1	; ACCL
// OBSOLETE 	mvfachi r0
// OBSOLETE 	st r0, @@+r1	; ACCH
// OBSOLETE 	jmp lr");
// OBSOLETE 
// OBSOLETE /* C routine to clean up what stash_registers did.
// OBSOLETE    It is called after calling stash_registers.
// OBSOLETE    This is separate from stash_registers as we want to do this in C
// OBSOLETE    but doing stash_registers in C isn't straightforward.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE cleanup_stash (void)
// OBSOLETE {
// OBSOLETE   psw = (struct PSWreg *) &registers[PSW];	/* fields of PSW register */
// OBSOLETE   psw->sm = psw->bsm;		/* fix up pre-trap values of psw fields */
// OBSOLETE   psw->ie = psw->bie;
// OBSOLETE   psw->c  = psw->bc;
// OBSOLETE   registers[CBR] = psw->bc;		/* fix up pre-trap "C" register */
// OBSOLETE 
// OBSOLETE #if 0 /* FIXME: Was in previous version.  Necessary?
// OBSOLETE 	 (Remember that we use the "rte" insn to return from the
// OBSOLETE 	 trap/interrupt so the values of bsm, bie, bc are important.  */
// OBSOLETE   psw->bsm = psw->bie = psw->bc = 0;	/* zero post-trap values */
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   /* FIXME: Copied from previous version.  This can probably be deleted
// OBSOLETE      since methinks stash_registers has already done this.  */
// OBSOLETE   registers[PC] = registers[BPC];	/* pre-trap PC */
// OBSOLETE 
// OBSOLETE   /* FIXME: Copied from previous version.  Necessary?  */
// OBSOLETE   if (psw->sm)			/* copy R15 into (psw->sm ? SPU : SPI) */
// OBSOLETE     registers[SPU] = registers[R15];
// OBSOLETE   else
// OBSOLETE     registers[SPI] = registers[R15];
// OBSOLETE }
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE restore_and_return:
// OBSOLETE 	seth r0, #shigh(registers+8)
// OBSOLETE 	add3 r0, r0, #low(registers+8)
// OBSOLETE 	ld r2, @@r0+	; restore r2
// OBSOLETE 	ld r3, @@r0+	; restore r3
// OBSOLETE 	ld r4, @@r0+	; restore r4
// OBSOLETE 	ld r5, @@r0+	; restore r5
// OBSOLETE 	ld r6, @@r0+	; restore r6
// OBSOLETE 	ld r7, @@r0+	; restore r7
// OBSOLETE 	ld r8, @@r0+	; restore r8
// OBSOLETE 	ld r9, @@r0+	; restore r9
// OBSOLETE 	ld r10, @@r0+	; restore r10
// OBSOLETE 	ld r11, @@r0+	; restore r11
// OBSOLETE 	ld r12, @@r0+	; restore r12
// OBSOLETE 	ld r13, @@r0+	; restore r13
// OBSOLETE 	ld r14, @@r0+	; restore r14
// OBSOLETE 	ld r15, @@r0+	; restore r15
// OBSOLETE 	addi r0, #4	; don't restore PSW (rte will do it)
// OBSOLETE 	ld r1, @@r0+	; restore cr1 == CBR (no-op, because it's read only)
// OBSOLETE 	mvtc r1, cr1
// OBSOLETE 	ld r1, @@r0+	; restore cr2 == SPI
// OBSOLETE 	mvtc r1, cr2
// OBSOLETE 	ld r1, @@r0+	; restore cr3 == SPU
// OBSOLETE 	mvtc r1, cr3
// OBSOLETE 	addi r0, #4	; skip BPC
// OBSOLETE 	ld r1, @@r0+	; restore cr6 (BPC) == PC
// OBSOLETE 	mvtc r1, cr6
// OBSOLETE 	ld r1, @@r0+	; restore ACCL
// OBSOLETE 	mvtaclo r1
// OBSOLETE 	ld r1, @@r0+	; restore ACCH
// OBSOLETE 	mvtachi r1
// OBSOLETE 	seth r0, #shigh(registers)
// OBSOLETE 	add3 r0, r0, #low(registers)
// OBSOLETE 	ld r1, @@(4,r0)	; restore r1
// OBSOLETE 	ld r0, @@r0	; restore r0
// OBSOLETE 	rte");
// OBSOLETE 
// OBSOLETE /* General trap handler, called after the registers have been stashed.
// OBSOLETE    NUM is the trap/exception number.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE process_exception (int num)
// OBSOLETE {
// OBSOLETE   cleanup_stash ();
// OBSOLETE   asm volatile ("
// OBSOLETE 	seth r1, #shigh(stackPtr)
// OBSOLETE 	add3 r1, r1, #low(stackPtr)
// OBSOLETE 	ld r15, @@r1		; setup local stack (protect user stack)
// OBSOLETE 	mv r0, %0
// OBSOLETE 	bl handle_exception
// OBSOLETE 	bl restore_and_return"
// OBSOLETE 		: : "r" (num) : "r0", "r1");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void _catchException0 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException0:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #0
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException1 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException1:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	bl cleanup_stash
// OBSOLETE 	seth r1, #shigh(stackPtr)
// OBSOLETE 	add3 r1, r1, #low(stackPtr)
// OBSOLETE 	ld r15, @@r1		; setup local stack (protect user stack)
// OBSOLETE 	seth r1, #shigh(registers + 21*4) ; PC
// OBSOLETE 	add3 r1, r1, #low(registers + 21*4)
// OBSOLETE 	ld r0, @@r1
// OBSOLETE 	addi r0, #-4		; back up PC for breakpoint trap.
// OBSOLETE 	st r0, @@r1		; FIXME: what about bp in right slot?
// OBSOLETE 	ldi r0, #1
// OBSOLETE 	bl handle_exception
// OBSOLETE 	bl restore_and_return");
// OBSOLETE 
// OBSOLETE void _catchException2 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException2:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #2
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException3 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException3:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #3
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException4 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException4:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #4
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException5 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException5:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #5
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException6 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException6:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #6
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException7 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException7:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #7
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException8 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException8:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #8
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException9 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException9:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #9
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException10 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException10:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #10
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException11 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException11:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #11
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException12 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException12:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #12
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException13 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException13:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #13
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException14 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException14:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #14
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException15 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException15:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #15
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException16 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException16:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #16
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException17 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException17:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #17
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* this function is used to set up exception handlers for tracing and
// OBSOLETE    breakpoints */
// OBSOLETE void 
// OBSOLETE set_debug_traps (void)
// OBSOLETE {
// OBSOLETE   /*  extern void remcomHandler(); */
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   for (i = 0; i < 18; i++)		/* keep a copy of old vectors */
// OBSOLETE     if (save_vectors[i] == 0)		/* only copy them the first time */
// OBSOLETE       save_vectors[i] = getExceptionHandler (i);
// OBSOLETE 
// OBSOLETE   stackPtr  = &remcomStack[STACKSIZE/sizeof(int) - 1];
// OBSOLETE 
// OBSOLETE   exceptionHandler (0, _catchException0);
// OBSOLETE   exceptionHandler (1, _catchException1);
// OBSOLETE   exceptionHandler (2, _catchException2);
// OBSOLETE   exceptionHandler (3, _catchException3);
// OBSOLETE   exceptionHandler (4, _catchException4);
// OBSOLETE   exceptionHandler (5, _catchException5);
// OBSOLETE   exceptionHandler (6, _catchException6);
// OBSOLETE   exceptionHandler (7, _catchException7);
// OBSOLETE   exceptionHandler (8, _catchException8);
// OBSOLETE   exceptionHandler (9, _catchException9);
// OBSOLETE   exceptionHandler (10, _catchException10);
// OBSOLETE   exceptionHandler (11, _catchException11);
// OBSOLETE   exceptionHandler (12, _catchException12);
// OBSOLETE   exceptionHandler (13, _catchException13);
// OBSOLETE   exceptionHandler (14, _catchException14);
// OBSOLETE   exceptionHandler (15, _catchException15);
// OBSOLETE   exceptionHandler (16, _catchException16);
// OBSOLETE   /*  exceptionHandler (17, _catchException17); */
// OBSOLETE 
// OBSOLETE   initialized = 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* This function will generate a breakpoint exception.  It is used at the
// OBSOLETE    beginning of a program to sync up with a debugger and can be used
// OBSOLETE    otherwise as a quick means to stop program execution and "break" into
// OBSOLETE    the debugger. */
// OBSOLETE 
// OBSOLETE #define BREAKPOINT() asm volatile ("	trap #2");
// OBSOLETE 
// OBSOLETE void 
// OBSOLETE breakpoint (void)
// OBSOLETE {
// OBSOLETE   if (initialized)
// OBSOLETE     BREAKPOINT();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* STDOUT section:
// OBSOLETE    Stuff pertaining to simulating stdout by sending chars to gdb to be echoed.
// OBSOLETE    Functions: gdb_putchar(char ch)
// OBSOLETE               gdb_puts(char *str)
// OBSOLETE               gdb_write(char *str, int len)
// OBSOLETE               gdb_error(char *format, char *parm)
// OBSOLETE 	      */
// OBSOLETE  
// OBSOLETE /* Function: gdb_putchar(int)
// OBSOLETE    Make gdb write a char to stdout.
// OBSOLETE    Returns: the char */
// OBSOLETE  
// OBSOLETE static int
// OBSOLETE gdb_putchar (int ch)
// OBSOLETE {
// OBSOLETE   char buf[4];
// OBSOLETE  
// OBSOLETE   buf[0] = 'O';
// OBSOLETE   buf[1] = hexchars[ch >> 4];
// OBSOLETE   buf[2] = hexchars[ch & 0x0F];
// OBSOLETE   buf[3] = 0;
// OBSOLETE   putpacket(buf);
// OBSOLETE   return ch;
// OBSOLETE }
// OBSOLETE  
// OBSOLETE /* Function: gdb_write(char *, int)
// OBSOLETE    Make gdb write n bytes to stdout (not assumed to be null-terminated).
// OBSOLETE    Returns: number of bytes written */
// OBSOLETE  
// OBSOLETE static int
// OBSOLETE gdb_write (char *data, int len)
// OBSOLETE {
// OBSOLETE   char *buf, *cpy;
// OBSOLETE   int i;
// OBSOLETE  
// OBSOLETE   buf = remcomOutBuffer;
// OBSOLETE   buf[0] = 'O';
// OBSOLETE   i = 0;
// OBSOLETE   while (i < len)
// OBSOLETE     {
// OBSOLETE       for (cpy = buf+1; 
// OBSOLETE 	   i < len && cpy < buf + sizeof(remcomOutBuffer) - 3; 
// OBSOLETE 	   i++)
// OBSOLETE 	{
// OBSOLETE 	  *cpy++ = hexchars[data[i] >> 4];
// OBSOLETE 	  *cpy++ = hexchars[data[i] & 0x0F];
// OBSOLETE 	}
// OBSOLETE       *cpy = 0;
// OBSOLETE       putpacket(buf);
// OBSOLETE     }
// OBSOLETE   return len;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: gdb_puts(char *)
// OBSOLETE    Make gdb write a null-terminated string to stdout.
// OBSOLETE    Returns: the length of the string */
// OBSOLETE  
// OBSOLETE static int
// OBSOLETE gdb_puts (char *str)
// OBSOLETE {
// OBSOLETE   return gdb_write(str, strlen(str));
// OBSOLETE }
// OBSOLETE  
// OBSOLETE /* Function: gdb_error(char *, char *)
// OBSOLETE    Send an error message to gdb's stdout.
// OBSOLETE    First string may have 1 (one) optional "%s" in it, which
// OBSOLETE    will cause the optional second string to be inserted.  */
// OBSOLETE  
// OBSOLETE static void
// OBSOLETE gdb_error (char *format, char *parm)
// OBSOLETE {
// OBSOLETE   char buf[400], *cpy;
// OBSOLETE   int len;
// OBSOLETE  
// OBSOLETE   if (remote_debug)
// OBSOLETE     {
// OBSOLETE       if (format && *format)
// OBSOLETE 	len = strlen(format);
// OBSOLETE       else
// OBSOLETE 	return;             /* empty input */
// OBSOLETE 
// OBSOLETE       if (parm && *parm)
// OBSOLETE 	len += strlen(parm);
// OBSOLETE  
// OBSOLETE       for (cpy = buf; *format; )
// OBSOLETE 	{
// OBSOLETE 	  if (format[0] == '%' && format[1] == 's') /* include second string */
// OBSOLETE 	    {
// OBSOLETE 	      format += 2;          /* advance two chars instead of just one */
// OBSOLETE 	      while (parm && *parm)
// OBSOLETE 		*cpy++ = *parm++;
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    *cpy++ = *format++;
// OBSOLETE 	}
// OBSOLETE       *cpy = '\0';
// OBSOLETE       gdb_puts(buf);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE  
// OBSOLETE static unsigned char *
// OBSOLETE strcpy (unsigned char *dest, const unsigned char *src)
// OBSOLETE {
// OBSOLETE   unsigned char *ret = dest;
// OBSOLETE 
// OBSOLETE   if (dest && src)
// OBSOLETE     {
// OBSOLETE       while (*src)
// OBSOLETE 	*dest++ = *src++;
// OBSOLETE       *dest = 0;
// OBSOLETE     }
// OBSOLETE   return ret;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE strlen (const unsigned char *src)
// OBSOLETE {
// OBSOLETE   int ret;
// OBSOLETE 
// OBSOLETE   for (ret = 0; *src; src++)
// OBSOLETE     ret++;
// OBSOLETE 
// OBSOLETE   return ret;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE void exit (code)
// OBSOLETE      int code;
// OBSOLETE {
// OBSOLETE   _exit (code);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int atexit (void *p)
// OBSOLETE {
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void abort (void)
// OBSOLETE {
// OBSOLETE   _exit (1);
// OBSOLETE }
// OBSOLETE #endif
@


1.6.30.1
log
@2003-08-01  Andrew Cagney  <cagney@@redhat.com>

	Import mainline multi-arch changes from Kei Sakamoto.
	* gdb/NEWS: Mention that m32r is multi-arch.
	* configure.tgt: Recognize m32r-*-*.
	* config/m32r/m32r.mt: New file.
	* m32r-rom.c, m32r-stub.c, m32r-tdep.c: Import
@
text
@d1 1718
a1718 1779
/****************************************************************************

		THIS SOFTWARE IS NOT COPYRIGHTED

   HP offers the following for use in the public domain.  HP makes no
   warranty with regard to the software or it's performance and the
   user accepts the software "AS IS" with all faults.

   HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD
   TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES
   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

****************************************************************************/

/****************************************************************************
 *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $
 *
 *  Module name: remcom.c $
 *  Revision: 1.34 $
 *  Date: 91/03/09 12:29:49 $
 *  Contributor:     Lake Stevens Instrument Division$
 *
 *  Description:     low level support for gdb debugger. $
 *
 *  Considerations:  only works on target hardware $
 *
 *  Written by:      Glenn Engel $
 *  ModuleState:     Experimental $
 *
 *  NOTES:           See Below $
 *
 *  Modified for M32R by Michael Snyder, Cygnus Support.
 *
 *  To enable debugger support, two things need to happen.  One, a
 *  call to set_debug_traps() is necessary in order to allow any breakpoints
 *  or error conditions to be properly intercepted and reported to gdb.
 *  Two, a breakpoint needs to be generated to begin communication.  This
 *  is most easily accomplished by a call to breakpoint().  Breakpoint()
 *  simulates a breakpoint by executing a trap #1.
 *
 *  The external function exceptionHandler() is
 *  used to attach a specific handler to a specific M32R vector number.
 *  It should use the same privilege level it runs at.  It should
 *  install it as an interrupt gate so that interrupts are masked
 *  while the handler runs.
 *
 *  Because gdb will sometimes write to the stack area to execute function
 *  calls, this program cannot rely on using the supervisor stack so it
 *  uses it's own stack area reserved in the int array remcomStack.
 *
 *************
 *
 *    The following gdb commands are supported:
 *
 * command          function                               Return value
 *
 *    g             return the value of the CPU registers  hex data or ENN
 *    G             set the value of the CPU registers     OK or ENN
 *
 *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN
 *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN
 *    XAA..AA,LLLL: Write LLLL binary bytes at address     OK or ENN
 *                  AA..AA
 *
 *    c             Resume at current address              SNN   ( signal NN)
 *    cAA..AA       Continue at address AA..AA             SNN
 *
 *    s             Step one instruction                   SNN
 *    sAA..AA       Step one instruction from AA..AA       SNN
 *
 *    k             kill
 *
 *    ?             What was the last sigval ?             SNN   (signal NN)
 *
 * All commands and responses are sent with a packet which includes a
 * checksum.  A packet consists of
 *
 * $<packet info>#<checksum>.
 *
 * where
 * <packet info> :: <characters representing the command or response>
 * <checksum>    :: <two hex digits computed as modulo 256 sum of <packetinfo>>
 *
 * When a packet is received, it is first acknowledged with either '+' or '-'.
 * '+' indicates a successful transfer.  '-' indicates a failed transfer.
 *
 * Example:
 *
 * Host:                  Reply:
 * $m0,10#2a               +$00010203040506070809101112131415#42
 *
 ****************************************************************************/


/************************************************************************
 *
 * external low-level support routines
 */
extern void putDebugChar ();	/* write a single character      */
extern int getDebugChar ();	/* read and return a single char */
extern void exceptionHandler ();	/* assign an exception handler   */

/*****************************************************************************
 * BUFMAX defines the maximum number of characters in inbound/outbound buffers
 * at least NUMREGBYTES*2 are needed for register packets 
 */
#define BUFMAX 400

static char initialized;	/* boolean flag. != 0 means we've been initialized */

int remote_debug;
/*  debug >  0 prints ill-formed commands in valid packets & checksum errors */

static const unsigned char hexchars[] = "0123456789abcdef";

#define NUMREGS 24

/* Number of bytes of registers.  */
#define NUMREGBYTES (NUMREGS * 4)
enum regnames
{ R0, R1, R2, R3, R4, R5, R6, R7,
  R8, R9, R10, R11, R12, R13, R14, R15,
  PSW, CBR, SPI, SPU, BPC, PC, ACCL, ACCH
};

enum SYS_calls
{
  SYS_null,
  SYS_exit,
  SYS_open,
  SYS_close,
  SYS_read,
  SYS_write,
  SYS_lseek,
  SYS_unlink,
  SYS_getpid,
  SYS_kill,
  SYS_fstat,
  SYS_sbrk,
  SYS_fork,
  SYS_execve,
  SYS_wait4,
  SYS_link,
  SYS_chdir,
  SYS_stat,
  SYS_utime,
  SYS_chown,
  SYS_chmod,
  SYS_time,
  SYS_pipe
};

static int registers[NUMREGS];

#define STACKSIZE 8096
static unsigned char remcomInBuffer[BUFMAX];
static unsigned char remcomOutBuffer[BUFMAX];
static int remcomStack[STACKSIZE / sizeof (int)];
static int *stackPtr = &remcomStack[STACKSIZE / sizeof (int) - 1];

static unsigned int save_vectors[18];	/* previous exception vectors */

/* Indicate to caller of mem2hex or hex2mem that there has been an error. */
static volatile int mem_err = 0;

/* Store the vector number here (since GDB only gets the signal
   number through the usual means, and that's not very specific).  */
int gdb_m32r_vector = -1;

#if 0
#include "syscall.h"		/* for SYS_exit, SYS_write etc. */
#endif

/* Global entry points:
 */

extern void handle_exception (int);
extern void set_debug_traps (void);
extern void breakpoint (void);

/* Local functions:
 */

static int computeSignal (int);
static void putpacket (unsigned char *);
static unsigned char *getpacket (void);

static unsigned char *mem2hex (unsigned char *, unsigned char *, int, int);
static unsigned char *hex2mem (unsigned char *, unsigned char *, int, int);
static int hexToInt (unsigned char **, int *);
static unsigned char *bin2mem (unsigned char *, unsigned char *, int, int);
static void stash_registers (void);
static void restore_registers (void);
static int prepare_to_step (int);
static int finish_from_step (void);
static unsigned long crc32 (unsigned char *, int, unsigned long);

static void gdb_error (char *, char *);
static int gdb_putchar (int), gdb_puts (char *), gdb_write (char *, int);

static unsigned char *strcpy (unsigned char *, const unsigned char *);
static int strlen (const unsigned char *);

/*
 * This function does all command procesing for interfacing to gdb.
 */

void
handle_exception (int exceptionVector)
{
  int sigval, stepping;
  int addr, length, i;
  unsigned char *ptr;
  unsigned char buf[16];
  int binary;

  if (!finish_from_step ())
    return;			/* "false step": let the target continue */

  gdb_m32r_vector = exceptionVector;

  if (remote_debug)
    {
      mem2hex ((unsigned char *) &exceptionVector, buf, 4, 0);
      gdb_error ("Handle exception %s, ", buf);
      mem2hex ((unsigned char *) &registers[PC], buf, 4, 0);
      gdb_error ("PC == 0x%s\n", buf);
    }

  /* reply to host that an exception has occurred */
  sigval = computeSignal (exceptionVector);

  ptr = remcomOutBuffer;

  *ptr++ = 'T';			/* notify gdb with signo, PC, FP and SP */
  *ptr++ = hexchars[sigval >> 4];
  *ptr++ = hexchars[sigval & 0xf];

  *ptr++ = hexchars[PC >> 4];
  *ptr++ = hexchars[PC & 0xf];
  *ptr++ = ':';
  ptr = mem2hex ((unsigned char *) &registers[PC], ptr, 4, 0);	/* PC */
  *ptr++ = ';';

  *ptr++ = hexchars[R13 >> 4];
  *ptr++ = hexchars[R13 & 0xf];
  *ptr++ = ':';
  ptr = mem2hex ((unsigned char *) &registers[R13], ptr, 4, 0);	/* FP */
  *ptr++ = ';';

  *ptr++ = hexchars[R15 >> 4];
  *ptr++ = hexchars[R15 & 0xf];
  *ptr++ = ':';
  ptr = mem2hex ((unsigned char *) &registers[R15], ptr, 4, 0);	/* SP */
  *ptr++ = ';';
  *ptr++ = 0;

  if (exceptionVector == 0)	/* simulated SYS call stuff */
    {
      mem2hex ((unsigned char *) &registers[PC], buf, 4, 0);
      switch (registers[R0])
	{
	case SYS_exit:
	  gdb_error ("Target program has exited at %s\n", buf);
	  ptr = remcomOutBuffer;
	  *ptr++ = 'W';
	  sigval = registers[R1] & 0xff;
	  *ptr++ = hexchars[sigval >> 4];
	  *ptr++ = hexchars[sigval & 0xf];
	  *ptr++ = 0;
	  break;
	case SYS_open:
	  gdb_error ("Target attempts SYS_open call at %s\n", buf);
	  break;
	case SYS_close:
	  gdb_error ("Target attempts SYS_close call at %s\n", buf);
	  break;
	case SYS_read:
	  gdb_error ("Target attempts SYS_read call at %s\n", buf);
	  break;
	case SYS_write:
	  if (registers[R1] == 1 ||	/* write to stdout  */
	      registers[R1] == 2)	/* write to stderr  */
	    {			/* (we can do that) */
	      registers[R0] =
		gdb_write ((void *) registers[R2], registers[R3]);
	      return;
	    }
	  else
	    gdb_error ("Target attempts SYS_write call at %s\n", buf);
	  break;
	case SYS_lseek:
	  gdb_error ("Target attempts SYS_lseek call at %s\n", buf);
	  break;
	case SYS_unlink:
	  gdb_error ("Target attempts SYS_unlink call at %s\n", buf);
	  break;
	case SYS_getpid:
	  gdb_error ("Target attempts SYS_getpid call at %s\n", buf);
	  break;
	case SYS_kill:
	  gdb_error ("Target attempts SYS_kill call at %s\n", buf);
	  break;
	case SYS_fstat:
	  gdb_error ("Target attempts SYS_fstat call at %s\n", buf);
	  break;
	default:
	  gdb_error ("Target attempts unknown SYS call at %s\n", buf);
	  break;
	}
    }

  putpacket (remcomOutBuffer);

  stepping = 0;

  while (1 == 1)
    {
      remcomOutBuffer[0] = 0;
      ptr = getpacket ();
      binary = 0;
      switch (*ptr++)
	{
	default:		/* Unknown code.  Return an empty reply message. */
	  break;
	case 'R':
	  if (hexToInt (&ptr, &addr))
	    registers[PC] = addr;
	  strcpy (remcomOutBuffer, "OK");
	  break;
	case '!':
	  strcpy (remcomOutBuffer, "OK");
	  break;
	case 'X':		/* XAA..AA,LLLL:<binary data>#cs */
	  binary = 1;
	case 'M':		/* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
	  /* TRY TO READ '%x,%x:'.  IF SUCCEED, SET PTR = 0 */
	  {
	    if (hexToInt (&ptr, &addr))
	      if (*(ptr++) == ',')
		if (hexToInt (&ptr, &length))
		  if (*(ptr++) == ':')
		    {
		      mem_err = 0;
		      if (binary)
			bin2mem (ptr, (unsigned char *) addr, length, 1);
		      else
			hex2mem (ptr, (unsigned char *) addr, length, 1);
		      if (mem_err)
			{
			  strcpy (remcomOutBuffer, "E03");
			  gdb_error ("memory fault", "");
			}
		      else
			{
			  strcpy (remcomOutBuffer, "OK");
			}
		      ptr = 0;
		    }
	    if (ptr)
	      {
		strcpy (remcomOutBuffer, "E02");
	      }
	  }
	  break;
	case 'm':		/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
	  /* TRY TO READ %x,%x.  IF SUCCEED, SET PTR = 0 */
	  if (hexToInt (&ptr, &addr))
	    if (*(ptr++) == ',')
	      if (hexToInt (&ptr, &length))
		{
		  ptr = 0;
		  mem_err = 0;
		  mem2hex ((unsigned char *) addr, remcomOutBuffer, length,
			   1);
		  if (mem_err)
		    {
		      strcpy (remcomOutBuffer, "E03");
		      gdb_error ("memory fault", "");
		    }
		}
	  if (ptr)
	    {
	      strcpy (remcomOutBuffer, "E01");
	    }
	  break;
	case '?':
	  remcomOutBuffer[0] = 'S';
	  remcomOutBuffer[1] = hexchars[sigval >> 4];
	  remcomOutBuffer[2] = hexchars[sigval % 16];
	  remcomOutBuffer[3] = 0;
	  break;
	case 'd':
	  remote_debug = !(remote_debug);	/* toggle debug flag */
	  break;
	case 'g':		/* return the value of the CPU registers */
	  mem2hex ((unsigned char *) registers, remcomOutBuffer, NUMREGBYTES,
		   0);
	  break;
	case 'P':		/* set the value of a single CPU register - return OK */
	  {
	    int regno;

	    if (hexToInt (&ptr, &regno) && *ptr++ == '=')
	      if (regno >= 0 && regno < NUMREGS)
		{
		  int stackmode;

		  hex2mem (ptr, (unsigned char *) &registers[regno], 4, 0);
		  /*
		   * Since we just changed a single CPU register, let's
		   * make sure to keep the several stack pointers consistant.
		   */
		  stackmode = registers[PSW] & 0x80;
		  if (regno == R15)	/* stack pointer changed */
		    {		/* need to change SPI or SPU */
		      if (stackmode == 0)
			registers[SPI] = registers[R15];
		      else
			registers[SPU] = registers[R15];
		    }
		  else if (regno == SPU)	/* "user" stack pointer changed */
		    {
		      if (stackmode != 0)	/* stack in user mode: copy SP */
			registers[R15] = registers[SPU];
		    }
		  else if (regno == SPI)	/* "interrupt" stack pointer changed */
		    {
		      if (stackmode == 0)	/* stack in interrupt mode: copy SP */
			registers[R15] = registers[SPI];
		    }
		  else if (regno == PSW)	/* stack mode may have changed! */
		    {		/* force SP to either SPU or SPI */
		      if (stackmode == 0)	/* stack in user mode */
			registers[R15] = registers[SPI];
		      else	/* stack in interrupt mode */
			registers[R15] = registers[SPU];
		    }
		  strcpy (remcomOutBuffer, "OK");
		  break;
		}
	    strcpy (remcomOutBuffer, "E01");
	    break;
	  }
	case 'G':		/* set the value of the CPU registers - return OK */
	  hex2mem (ptr, (unsigned char *) registers, NUMREGBYTES, 0);
	  strcpy (remcomOutBuffer, "OK");
	  break;
	case 's':		/* sAA..AA      Step one instruction from AA..AA(optional) */
	  stepping = 1;
	case 'c':		/* cAA..AA      Continue from address AA..AA(optional) */
	  /* try to read optional parameter, pc unchanged if no parm */
	  if (hexToInt (&ptr, &addr))
	    registers[PC] = addr;

	  if (stepping)		/* single-stepping */
	    {
	      if (!prepare_to_step (0))	/* set up for single-step */
		{
		  /* prepare_to_step has already emulated the target insn:
		     Send SIGTRAP to gdb, don't resume the target at all.  */
		  ptr = remcomOutBuffer;
		  *ptr++ = 'T';	/* Simulate stopping with SIGTRAP */
		  *ptr++ = '0';
		  *ptr++ = '5';

		  *ptr++ = hexchars[PC >> 4];	/* send PC */
		  *ptr++ = hexchars[PC & 0xf];
		  *ptr++ = ':';
		  ptr = mem2hex ((unsigned char *) &registers[PC], ptr, 4, 0);
		  *ptr++ = ';';

		  *ptr++ = hexchars[R13 >> 4];	/* send FP */
		  *ptr++ = hexchars[R13 & 0xf];
		  *ptr++ = ':';
		  ptr =
		    mem2hex ((unsigned char *) &registers[R13], ptr, 4, 0);
		  *ptr++ = ';';

		  *ptr++ = hexchars[R15 >> 4];	/* send SP */
		  *ptr++ = hexchars[R15 & 0xf];
		  *ptr++ = ':';
		  ptr =
		    mem2hex ((unsigned char *) &registers[R15], ptr, 4, 0);
		  *ptr++ = ';';
		  *ptr++ = 0;

		  break;
		}
	    }
	  else			/* continuing, not single-stepping */
	    {
	      /* OK, about to do a "continue".  First check to see if the 
	         target pc is on an odd boundary (second instruction in the 
	         word).  If so, we must do a single-step first, because 
	         ya can't jump or return back to an odd boundary!  */
	      if ((registers[PC] & 2) != 0)
		prepare_to_step (1);
	    }

	  return;

	case 'D':		/* Detach */
#if 0
	  /* I am interpreting this to mean, release the board from control 
	     by the remote stub.  To do this, I am restoring the original
	     (or at least previous) exception vectors.
	   */
	  for (i = 0; i < 18; i++)
	    exceptionHandler (i, save_vectors[i]);
	  putpacket ("OK");
	  return;		/* continue the inferior */
#else
	  strcpy (remcomOutBuffer, "OK");
	  break;
#endif
	case 'q':
	  if (*ptr++ == 'C' &&
	      *ptr++ == 'R' && *ptr++ == 'C' && *ptr++ == ':')
	    {
	      unsigned long start, len, our_crc;

	      if (hexToInt (&ptr, (int *) &start) &&
		  *ptr++ == ',' && hexToInt (&ptr, (int *) &len))
		{
		  remcomOutBuffer[0] = 'C';
		  our_crc = crc32 ((unsigned char *) start, len, 0xffffffff);
		  mem2hex ((char *) &our_crc,
			   &remcomOutBuffer[1], sizeof (long), 0);
		}		/* else do nothing */
	    }			/* else do nothing */
	  break;

	case 'k':		/* kill the program */
	  continue;
	}			/* switch */

      /* reply to the request */
      putpacket (remcomOutBuffer);
    }
}

/* qCRC support */

/* Table used by the crc32 function to calcuate the checksum. */
static unsigned long crc32_table[256] = { 0, 0 };

static unsigned long
crc32 (unsigned char *buf, int len, unsigned long crc)
{
  if (!crc32_table[1])
    {
      /* Initialize the CRC table and the decoding table. */
      int i, j;
      unsigned long c;

      for (i = 0; i < 256; i++)
	{
	  for (c = i << 24, j = 8; j > 0; --j)
	    c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : (c << 1);
	  crc32_table[i] = c;
	}
    }

  while (len--)
    {
      crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ *buf) & 255];
      buf++;
    }
  return crc;
}

static int
hex (unsigned char ch)
{
  if ((ch >= 'a') && (ch <= 'f'))
    return (ch - 'a' + 10);
  if ((ch >= '0') && (ch <= '9'))
    return (ch - '0');
  if ((ch >= 'A') && (ch <= 'F'))
    return (ch - 'A' + 10);
  return (-1);
}

/* scan for the sequence $<data>#<checksum>     */

unsigned char *
getpacket (void)
{
  unsigned char *buffer = &remcomInBuffer[0];
  unsigned char checksum;
  unsigned char xmitcsum;
  int count;
  char ch;

  while (1)
    {
      /* wait around for the start character, ignore all other characters */
      while ((ch = getDebugChar ()) != '$')
	;

    retry:
      checksum = 0;
      xmitcsum = -1;
      count = 0;

      /* now, read until a # or end of buffer is found */
      while (count < BUFMAX)
	{
	  ch = getDebugChar ();
	  if (ch == '$')
	    goto retry;
	  if (ch == '#')
	    break;
	  checksum = checksum + ch;
	  buffer[count] = ch;
	  count = count + 1;
	}
      buffer[count] = 0;

      if (ch == '#')
	{
	  ch = getDebugChar ();
	  xmitcsum = hex (ch) << 4;
	  ch = getDebugChar ();
	  xmitcsum += hex (ch);

	  if (checksum != xmitcsum)
	    {
	      if (remote_debug)
		{
		  unsigned char buf[16];

		  mem2hex ((unsigned char *) &checksum, buf, 4, 0);
		  gdb_error ("Bad checksum: my count = %s, ", buf);
		  mem2hex ((unsigned char *) &xmitcsum, buf, 4, 0);
		  gdb_error ("sent count = %s\n", buf);
		  gdb_error (" -- Bad buffer: \"%s\"\n", buffer);
		}
	      putDebugChar ('-');	/* failed checksum */
	    }
	  else
	    {
	      putDebugChar ('+');	/* successful transfer */

	      /* if a sequence char is present, reply the sequence ID */
	      if (buffer[2] == ':')
		{
		  putDebugChar (buffer[0]);
		  putDebugChar (buffer[1]);

		  return &buffer[3];
		}

	      return &buffer[0];
	    }
	}
    }
}

/* send the packet in buffer.  */

static void
putpacket (unsigned char *buffer)
{
  unsigned char checksum;
  int count;
  char ch;

  /*  $<packet info>#<checksum>. */
  do
    {
      putDebugChar ('$');
      checksum = 0;
      count = 0;

      while (ch = buffer[count])
	{
	  putDebugChar (ch);
	  checksum += ch;
	  count += 1;
	}
      putDebugChar ('#');
      putDebugChar (hexchars[checksum >> 4]);
      putDebugChar (hexchars[checksum % 16]);
    }
  while (getDebugChar () != '+');
}

/* Address of a routine to RTE to if we get a memory fault.  */

static void (*volatile mem_fault_routine) () = 0;

static void
set_mem_err (void)
{
  mem_err = 1;
}

/* Check the address for safe access ranges.  As currently defined,
   this routine will reject the "expansion bus" address range(s).
   To make those ranges useable, someone must implement code to detect
   whether there's anything connected to the expansion bus. */

static int
mem_safe (unsigned char *addr)
{
#define BAD_RANGE_ONE_START	((unsigned char *) 0x600000)
#define BAD_RANGE_ONE_END	((unsigned char *) 0xa00000)
#define BAD_RANGE_TWO_START	((unsigned char *) 0xff680000)
#define BAD_RANGE_TWO_END	((unsigned char *) 0xff800000)

  if (addr < BAD_RANGE_ONE_START)
    return 1;			/* safe */
  if (addr < BAD_RANGE_ONE_END)
    return 0;			/* unsafe */
  if (addr < BAD_RANGE_TWO_START)
    return 1;			/* safe */
  if (addr < BAD_RANGE_TWO_END)
    return 0;			/* unsafe */
}

/* These are separate functions so that they are so short and sweet
   that the compiler won't save any registers (if there is a fault
   to mem_fault, they won't get restored, so there better not be any
   saved).  */
static int
get_char (unsigned char *addr)
{
#if 1
  if (mem_fault_routine && !mem_safe (addr))
    {
      mem_fault_routine ();
      return 0;
    }
#endif
  return *addr;
}

static void
set_char (unsigned char *addr, unsigned char val)
{
#if 1
  if (mem_fault_routine && !mem_safe (addr))
    {
      mem_fault_routine ();
      return;
    }
#endif
  *addr = val;
}

/* Convert the memory pointed to by mem into hex, placing result in buf.
   Return a pointer to the last char put in buf (null).
   If MAY_FAULT is non-zero, then we should set mem_err in response to
   a fault; if zero treat a fault like any other fault in the stub.  */

static unsigned char *
mem2hex (unsigned char *mem, unsigned char *buf, int count, int may_fault)
{
  int i;
  unsigned char ch;

  if (may_fault)
    mem_fault_routine = set_mem_err;
  for (i = 0; i < count; i++)
    {
      ch = get_char (mem++);
      if (may_fault && mem_err)
	return (buf);
      *buf++ = hexchars[ch >> 4];
      *buf++ = hexchars[ch % 16];
    }
  *buf = 0;
  if (may_fault)
    mem_fault_routine = 0;
  return (buf);
}

/* Convert the hex array pointed to by buf into binary to be placed in mem.
   Return a pointer to the character AFTER the last byte written. */

static unsigned char *
hex2mem (unsigned char *buf, unsigned char *mem, int count, int may_fault)
{
  int i;
  unsigned char ch;

  if (may_fault)
    mem_fault_routine = set_mem_err;
  for (i = 0; i < count; i++)
    {
      ch = hex (*buf++) << 4;
      ch = ch + hex (*buf++);
      set_char (mem++, ch);
      if (may_fault && mem_err)
	return (mem);
    }
  if (may_fault)
    mem_fault_routine = 0;
  return (mem);
}

/* Convert the binary stream in BUF to memory.

   Gdb will escape $, #, and the escape char (0x7d).
   COUNT is the total number of bytes to write into
   memory. */
static unsigned char *
bin2mem (unsigned char *buf, unsigned char *mem, int count, int may_fault)
{
  int i;
  unsigned char ch;

  if (may_fault)
    mem_fault_routine = set_mem_err;
  for (i = 0; i < count; i++)
    {
      /* Check for any escaped characters. Be paranoid and
         only unescape chars that should be escaped. */
      if (*buf == 0x7d)
	{
	  switch (*(buf + 1))
	    {
	    case 0x3:		/* # */
	    case 0x4:		/* $ */
	    case 0x5d:		/* escape char */
	      buf++;
	      *buf |= 0x20;
	      break;
	    default:
	      /* nothing */
	      break;
	    }
	}

      set_char (mem++, *buf++);

      if (may_fault && mem_err)
	return mem;
    }

  if (may_fault)
    mem_fault_routine = 0;
  return mem;
}

/* this function takes the m32r exception vector and attempts to
   translate this number into a unix compatible signal value */

static int
computeSignal (int exceptionVector)
{
  int sigval;
  switch (exceptionVector)
    {
    case 0:
      sigval = 23;
      break;			/* I/O trap                    */
    case 1:
      sigval = 5;
      break;			/* breakpoint                  */
    case 2:
      sigval = 5;
      break;			/* breakpoint                  */
    case 3:
      sigval = 5;
      break;			/* breakpoint                  */
    case 4:
      sigval = 5;
      break;			/* breakpoint                  */
    case 5:
      sigval = 5;
      break;			/* breakpoint                  */
    case 6:
      sigval = 5;
      break;			/* breakpoint                  */
    case 7:
      sigval = 5;
      break;			/* breakpoint                  */
    case 8:
      sigval = 5;
      break;			/* breakpoint                  */
    case 9:
      sigval = 5;
      break;			/* breakpoint                  */
    case 10:
      sigval = 5;
      break;			/* breakpoint                  */
    case 11:
      sigval = 5;
      break;			/* breakpoint                  */
    case 12:
      sigval = 5;
      break;			/* breakpoint                  */
    case 13:
      sigval = 5;
      break;			/* breakpoint                  */
    case 14:
      sigval = 5;
      break;			/* breakpoint                  */
    case 15:
      sigval = 5;
      break;			/* breakpoint                  */
    case 16:
      sigval = 10;
      break;			/* BUS ERROR (alignment)       */
    case 17:
      sigval = 2;
      break;			/* INTerrupt                   */
    default:
      sigval = 7;
      break;			/* "software generated"        */
    }
  return (sigval);
}

/**********************************************/
/* WHILE WE FIND NICE HEX CHARS, BUILD AN INT */
/* RETURN NUMBER OF CHARS PROCESSED           */
/**********************************************/
static int
hexToInt (unsigned char **ptr, int *intValue)
{
  int numChars = 0;
  int hexValue;

  *intValue = 0;
  while (**ptr)
    {
      hexValue = hex (**ptr);
      if (hexValue >= 0)
	{
	  *intValue = (*intValue << 4) | hexValue;
	  numChars++;
	}
      else
	break;
      (*ptr)++;
    }
  return (numChars);
}

/*
  Table of branch instructions:
  
  10B6		RTE	return from trap or exception
  1FCr		JMP	jump
  1ECr		JL	jump and link
  7Fxx		BRA	branch
  FFxxxxxx	BRA	branch (long)
  B09rxxxx	BNEZ	branch not-equal-zero
  Br1rxxxx	BNE	branch not-equal
  7Dxx		BNC	branch not-condition
  FDxxxxxx	BNC	branch not-condition (long)
  B0Arxxxx	BLTZ	branch less-than-zero
  B0Crxxxx	BLEZ	branch less-equal-zero
  7Exx		BL	branch and link
  FExxxxxx	BL	branch and link (long)
  B0Drxxxx	BGTZ	branch greater-than-zero
  B0Brxxxx	BGEZ	branch greater-equal-zero
  B08rxxxx	BEQZ	branch equal-zero
  Br0rxxxx	BEQ	branch equal
  7Cxx		BC	branch condition
  FCxxxxxx	BC	branch condition (long)
  */

static int
isShortBranch (unsigned char *instr)
{
  unsigned char instr0 = instr[0] & 0x7F;	/* mask off high bit */

  if (instr0 == 0x10 && instr[1] == 0xB6)	/* RTE */
    return 1;			/* return from trap or exception */

  if (instr0 == 0x1E || instr0 == 0x1F)	/* JL or JMP */
    if ((instr[1] & 0xF0) == 0xC0)
      return 2;			/* jump thru a register */

  if (instr0 == 0x7C || instr0 == 0x7D ||	/* BC, BNC, BL, BRA */
      instr0 == 0x7E || instr0 == 0x7F)
    return 3;			/* eight bit PC offset */

  return 0;
}

static int
isLongBranch (unsigned char *instr)
{
  if (instr[0] == 0xFC || instr[0] == 0xFD ||	/* BRA, BNC, BL, BC */
      instr[0] == 0xFE || instr[0] == 0xFF)	/* 24 bit relative */
    return 4;
  if ((instr[0] & 0xF0) == 0xB0)	/* 16 bit relative */
    {
      if ((instr[1] & 0xF0) == 0x00 ||	/* BNE, BEQ */
	  (instr[1] & 0xF0) == 0x10)
	return 5;
      if (instr[0] == 0xB0)	/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ, BEQZ */
	if ((instr[1] & 0xF0) == 0x80 || (instr[1] & 0xF0) == 0x90 ||
	    (instr[1] & 0xF0) == 0xA0 || (instr[1] & 0xF0) == 0xB0 ||
	    (instr[1] & 0xF0) == 0xC0 || (instr[1] & 0xF0) == 0xD0)
	  return 6;
    }
  return 0;
}

/* if address is NOT on a 4-byte boundary, or high-bit of instr is zero, 
   then it's a 2-byte instruction, else it's a 4-byte instruction.  */

#define INSTRUCTION_SIZE(addr) \
    ((((int) addr & 2) || (((unsigned char *) addr)[0] & 0x80) == 0) ? 2 : 4)

static int
isBranch (unsigned char *instr)
{
  if (INSTRUCTION_SIZE (instr) == 2)
    return isShortBranch (instr);
  else
    return isLongBranch (instr);
}

static int
willBranch (unsigned char *instr, int branchCode)
{
  switch (branchCode)
    {
    case 0:
      return 0;			/* not a branch */
    case 1:
      return 1;			/* RTE */
    case 2:
      return 1;			/* JL or JMP    */
    case 3:			/* BC, BNC, BL, BRA (short) */
    case 4:			/* BC, BNC, BL, BRA (long) */
      switch (instr[0] & 0x0F)
	{
	case 0xC:		/* Branch if Condition Register */
	  return (registers[CBR] != 0);
	case 0xD:		/* Branch if NOT Condition Register */
	  return (registers[CBR] == 0);
	case 0xE:		/* Branch and Link */
	case 0xF:		/* Branch (unconditional) */
	  return 1;
	default:		/* oops? */
	  return 0;
	}
    case 5:			/* BNE, BEQ */
      switch (instr[1] & 0xF0)
	{
	case 0x00:		/* Branch if r1 equal to r2 */
	  return (registers[instr[0] & 0x0F] == registers[instr[1] & 0x0F]);
	case 0x10:		/* Branch if r1 NOT equal to r2 */
	  return (registers[instr[0] & 0x0F] != registers[instr[1] & 0x0F]);
	default:		/* oops? */
	  return 0;
	}
    case 6:			/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ */
      switch (instr[1] & 0xF0)
	{
	case 0x80:		/* Branch if reg equal to zero */
	  return (registers[instr[1] & 0x0F] == 0);
	case 0x90:		/* Branch if reg NOT equal to zero */
	  return (registers[instr[1] & 0x0F] != 0);
	case 0xA0:		/* Branch if reg less than zero */
	  return (registers[instr[1] & 0x0F] < 0);
	case 0xB0:		/* Branch if reg greater or equal to zero */
	  return (registers[instr[1] & 0x0F] >= 0);
	case 0xC0:		/* Branch if reg less than or equal to zero */
	  return (registers[instr[1] & 0x0F] <= 0);
	case 0xD0:		/* Branch if reg greater than zero */
	  return (registers[instr[1] & 0x0F] > 0);
	default:		/* oops? */
	  return 0;
	}
    default:			/* oops? */
      return 0;
    }
}

static int
branchDestination (unsigned char *instr, int branchCode)
{
  switch (branchCode)
    {
    default:
    case 0:			/* not a branch */
      return 0;
    case 1:			/* RTE */
      return registers[BPC] & ~3;	/* pop BPC into PC */
    case 2:			/* JL or JMP */
      return registers[instr[1] & 0x0F] & ~3;	/* jump thru a register */
    case 3:			/* BC, BNC, BL, BRA (short, 8-bit relative offset) */
      return (((int) instr) & ~3) + ((char) instr[1] << 2);
    case 4:			/* BC, BNC, BL, BRA (long, 24-bit relative offset) */
      return ((int) instr +
	      ((((char) instr[1] << 16) | (instr[2] << 8) | (instr[3])) <<
	       2));
    case 5:			/* BNE, BEQ (16-bit relative offset) */
    case 6:			/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ (ditto) */
      return ((int) instr + ((((char) instr[2] << 8) | (instr[3])) << 2));
    }

  /* An explanatory note: in the last three return expressions, I have
     cast the most-significant byte of the return offset to char.
     What this accomplishes is sign extension.  If the other
     less-significant bytes were signed as well, they would get sign
     extended too and, if negative, their leading bits would clobber
     the bits of the more-significant bytes ahead of them.  There are
     other ways I could have done this, but sign extension from
     odd-sized integers is always a pain. */
}

static void
branchSideEffects (unsigned char *instr, int branchCode)
{
  switch (branchCode)
    {
    case 1:			/* RTE */
      return;			/* I <THINK> this is already handled... */
    case 2:			/* JL (or JMP) */
    case 3:			/* BL (or BC, BNC, BRA) */
    case 4:
      if ((instr[0] & 0x0F) == 0x0E)	/* branch/jump and link */
	registers[R14] = (registers[PC] & ~3) + 4;
      return;
    default:			/* any other branch has no side effects */
      return;
    }
}

static struct STEPPING_CONTEXT
{
  int stepping;			/* true when we've started a single-step */
  unsigned long target_addr;	/* the instr we're trying to execute */
  unsigned long target_size;	/* the size of the target instr */
  unsigned long noop_addr;	/* where we've inserted a no-op, if any */
  unsigned long trap1_addr;	/* the trap following the target instr */
  unsigned long trap2_addr;	/* the trap at a branch destination, if any */
  unsigned short noop_save;	/* instruction overwritten by our no-op */
  unsigned short trap1_save;	/* instruction overwritten by trap1 */
  unsigned short trap2_save;	/* instruction overwritten by trap2 */
  unsigned short continue_p;	/* true if NOT returning to gdb after step */
} stepping;

/* Function: prepare_to_step
   Called from handle_exception to prepare the user program to single-step.
   Places a trap instruction after the target instruction, with special 
   extra handling for branch instructions and for instructions in the 
   second half-word of a word.  

   Returns: True  if we should actually execute the instruction; 
	    False if we are going to emulate executing the instruction,
	    in which case we simply report to GDB that the instruction 
	    has already been executed.  */

#define TRAP1  0x10f1;		/* trap #1 instruction */
#define NOOP   0x7000;		/* noop    instruction */

static unsigned short trap1 = TRAP1;
static unsigned short noop = NOOP;

static int
prepare_to_step (continue_p)
     int continue_p;		/* if this isn't REALLY a single-step (see below) */
{
  unsigned long pc = registers[PC];
  int branchCode = isBranch ((unsigned char *) pc);
  unsigned char *p;

  /* zero out the stepping context 
     (paranoia -- it should already be zeroed) */
  for (p = (unsigned char *) &stepping;
       p < ((unsigned char *) &stepping) + sizeof (stepping); p++)
    *p = 0;

  if (branchCode != 0)		/* next instruction is a branch */
    {
      branchSideEffects ((unsigned char *) pc, branchCode);
      if (willBranch ((unsigned char *) pc, branchCode))
	registers[PC] = branchDestination ((unsigned char *) pc, branchCode);
      else
	registers[PC] = pc + INSTRUCTION_SIZE (pc);
      return 0;			/* branch "executed" -- just notify GDB */
    }
  else if (((int) pc & 2) != 0)	/* "second-slot" instruction */
    {
      /* insert no-op before pc */
      stepping.noop_addr = pc - 2;
      stepping.noop_save = *(unsigned short *) stepping.noop_addr;
      *(unsigned short *) stepping.noop_addr = noop;
      /* insert trap  after  pc */
      stepping.trap1_addr = pc + 2;
      stepping.trap1_save = *(unsigned short *) stepping.trap1_addr;
      *(unsigned short *) stepping.trap1_addr = trap1;
    }
  else				/* "first-slot" instruction */
    {
      /* insert trap  after  pc */
      stepping.trap1_addr = pc + INSTRUCTION_SIZE (pc);
      stepping.trap1_save = *(unsigned short *) stepping.trap1_addr;
      *(unsigned short *) stepping.trap1_addr = trap1;
    }
  /* "continue_p" means that we are actually doing a continue, and not 
     being requested to single-step by GDB.  Sometimes we have to do
     one single-step before continuing, because the PC is on a half-word
     boundary.  There's no way to simply resume at such an address.  */
  stepping.continue_p = continue_p;
  stepping.stepping = 1;	/* starting a single-step */
  return 1;
}

/* Function: finish_from_step
   Called from handle_exception to finish up when the user program 
   returns from a single-step.  Replaces the instructions that had
   been overwritten by traps or no-ops, 

   Returns: True  if we should notify GDB that the target stopped.
	    False if we only single-stepped because we had to before we
	    could continue (ie. we were trying to continue at a 
	    half-word boundary).  In that case don't notify GDB:
	    just "continue continuing".  */

static int
finish_from_step (void)
{
  if (stepping.stepping)	/* anything to do? */
    {
      int continue_p = stepping.continue_p;
      unsigned char *p;

      if (stepping.noop_addr)	/* replace instr "under" our no-op */
	*(unsigned short *) stepping.noop_addr = stepping.noop_save;
      if (stepping.trap1_addr)	/* replace instr "under" our trap  */
	*(unsigned short *) stepping.trap1_addr = stepping.trap1_save;
      if (stepping.trap2_addr)	/* ditto our other trap, if any    */
	*(unsigned short *) stepping.trap2_addr = stepping.trap2_save;

      for (p = (unsigned char *) &stepping;	/* zero out the stepping context */
	   p < ((unsigned char *) &stepping) + sizeof (stepping); p++)
	*p = 0;

      return !(continue_p);
    }
  else				/* we didn't single-step, therefore this must be a legitimate stop */
    return 1;
}

struct PSWreg
{				/* separate out the bit flags in the PSW register */
  int pad1:16;
  int bsm:1;
  int bie:1;
  int pad2:5;
  int bc:1;
  int sm:1;
  int ie:1;
  int pad3:5;
  int c:1;
} *psw;

/* Upon entry the value for LR to save has been pushed.
   We unpush that so that the value for the stack pointer saved is correct.
   Upon entry, all other registers are assumed to have not been modified
   since the interrupt/trap occured.  */

asm ("\n\
stash_registers:\n\
	push r0\n\
	push r1\n\
	seth r1, #shigh(registers)\n\
	add3 r1, r1, #low(registers)\n\
	pop r0		; r1\n\
	st r0, @@(4,r1)\n\
	pop r0		; r0\n\
	st r0, @@r1\n\
	addi r1, #4	; only add 4 as subsequent saves are `pre inc'\n\
	st r2, @@+r1\n\
	st r3, @@+r1\n\
	st r4, @@+r1\n\
	st r5, @@+r1\n\
	st r6, @@+r1\n\
	st r7, @@+r1\n\
	st r8, @@+r1\n\
	st r9, @@+r1\n\
	st r10, @@+r1\n\
	st r11, @@+r1\n\
	st r12, @@+r1\n\
	st r13, @@+r1    ; fp\n\
	pop r0		; lr (r14)\n\
	st r0, @@+r1\n\
	st sp, @@+r1	; sp contains right value at this point\n\
	mvfc r0, cr0\n\
	st r0, @@+r1	; cr0 == PSW\n\
	mvfc r0, cr1\n\
	st r0, @@+r1	; cr1 == CBR\n\
	mvfc r0, cr2\n\
	st r0, @@+r1	; cr2 == SPI\n\
	mvfc r0, cr3\n\
	st r0, @@+r1	; cr3 == SPU\n\
	mvfc r0, cr6\n\
	st r0, @@+r1	; cr6 == BPC\n\
	st r0, @@+r1	; PC  == BPC\n\
	mvfaclo r0\n\
	st r0, @@+r1	; ACCL\n\
	mvfachi r0\n\
	st r0, @@+r1	; ACCH\n\
	jmp lr");

/* C routine to clean up what stash_registers did.
   It is called after calling stash_registers.
   This is separate from stash_registers as we want to do this in C
   but doing stash_registers in C isn't straightforward.  */

static void
cleanup_stash (void)
{
  psw = (struct PSWreg *) &registers[PSW];	/* fields of PSW register */
  psw->sm = psw->bsm;		/* fix up pre-trap values of psw fields */
  psw->ie = psw->bie;
  psw->c = psw->bc;
  registers[CBR] = psw->bc;	/* fix up pre-trap "C" register */

#if 0				/* FIXME: Was in previous version.  Necessary?
				   (Remember that we use the "rte" insn to return from the
				   trap/interrupt so the values of bsm, bie, bc are important.  */
  psw->bsm = psw->bie = psw->bc = 0;	/* zero post-trap values */
#endif

  /* FIXME: Copied from previous version.  This can probably be deleted
     since methinks stash_registers has already done this.  */
  registers[PC] = registers[BPC];	/* pre-trap PC */

  /* FIXME: Copied from previous version.  Necessary?  */
  if (psw->sm)			/* copy R15 into (psw->sm ? SPU : SPI) */
    registers[SPU] = registers[R15];
  else
    registers[SPI] = registers[R15];
}

asm ("\n\
restore_and_return:\n\
	seth r0, #shigh(registers+8)\n\
	add3 r0, r0, #low(registers+8)\n\
	ld r2, @@r0+	; restore r2\n\
	ld r3, @@r0+	; restore r3\n\
	ld r4, @@r0+	; restore r4\n\
	ld r5, @@r0+	; restore r5\n\
	ld r6, @@r0+	; restore r6\n\
	ld r7, @@r0+	; restore r7\n\
	ld r8, @@r0+	; restore r8\n\
	ld r9, @@r0+	; restore r9\n\
	ld r10, @@r0+	; restore r10\n\
	ld r11, @@r0+	; restore r11\n\
	ld r12, @@r0+	; restore r12\n\
	ld r13, @@r0+	; restore r13\n\
	ld r14, @@r0+	; restore r14\n\
	ld r15, @@r0+	; restore r15\n\
	ld r1, @@r0+	; restore cr0 == PSW\n\
	mvtc r1, cr0\n\
	ld r1, @@r0+	; restore cr1 == CBR (no-op, because it's read only)\n\
	mvtc r1, cr1\n\
	ld r1, @@r0+	; restore cr2 == SPI\n\
	mvtc r1, cr2\n\
	ld r1, @@r0+	; restore cr3 == SPU\n\
	mvtc r1, cr3\n\
	addi r0, #4	; skip BPC\n\
	ld r1, @@r0+	; restore cr6 (BPC) == PC\n\
	mvtc r1, cr6\n\
	ld r1, @@r0+	; restore ACCL\n\
	mvtaclo r1\n\
	ld r1, @@r0+	; restore ACCH\n\
	mvtachi r1\n\
	seth r0, #shigh(registers)\n\
	add3 r0, r0, #low(registers)\n\
	ld r1, @@(4,r0)	; restore r1\n\
	ld r0, @@r0	; restore r0\n\
	rte");

/* General trap handler, called after the registers have been stashed.
   NUM is the trap/exception number.  */

static void
process_exception (int num)
{
  cleanup_stash ();
  asm volatile ("\n\
	seth r1, #shigh(stackPtr)\n\
	add3 r1, r1, #low(stackPtr)\n\
	ld r15, @@r1		; setup local stack (protect user stack)\n\
	mv r0, %0\n\
	bl handle_exception\n\
	bl restore_and_return"::"r" (num):"r0", "r1");
}

void _catchException0 ();

asm ("\n\
_catchException0:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #0\n\
	bl process_exception");

void _catchException1 ();

asm ("\n\
_catchException1:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	bl cleanup_stash\n\
	seth r1, #shigh(stackPtr)\n\
	add3 r1, r1, #low(stackPtr)\n\
	ld r15, @@r1		; setup local stack (protect user stack)\n\
	seth r1, #shigh(registers + 21*4) ; PC\n\
	add3 r1, r1, #low(registers + 21*4)\n\
	ld r0, @@r1\n\
	addi r0, #-4		; back up PC for breakpoint trap.\n\
	st r0, @@r1		; FIXME: what about bp in right slot?\n\
	ldi r0, #1\n\
	bl handle_exception\n\
	bl restore_and_return");

void _catchException2 ();

asm ("\n\
_catchException2:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #2\n\
	bl process_exception");

void _catchException3 ();

asm ("\n\
_catchException3:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #3\n\
	bl process_exception");

void _catchException4 ();

asm ("\n\
_catchException4:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #4\n\
	bl process_exception");

void _catchException5 ();

asm ("\n\
_catchException5:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #5\n\
	bl process_exception");

void _catchException6 ();

asm ("\n\
_catchException6:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #6\n\
	bl process_exception");

void _catchException7 ();

asm ("\n\
_catchException7:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #7\n\
	bl process_exception");

void _catchException8 ();

asm ("\n\
_catchException8:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #8\n\
	bl process_exception");

void _catchException9 ();

asm ("\n\
_catchException9:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #9\n\
	bl process_exception");

void _catchException10 ();

asm ("\n\
_catchException10:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #10\n\
	bl process_exception");

void _catchException11 ();

asm ("\n\
_catchException11:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #11\n\
	bl process_exception");

void _catchException12 ();

asm ("\n\
_catchException12:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #12\n\
	bl process_exception");

void _catchException13 ();

asm ("\n\
_catchException13:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #13\n\
	bl process_exception");

void _catchException14 ();

asm ("\n\
_catchException14:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #14\n\
	bl process_exception");

void _catchException15 ();

asm ("\n\
_catchException15:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #15\n\
	bl process_exception");

void _catchException16 ();

asm ("\n\
_catchException16:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #16\n\
	bl process_exception");

void _catchException17 ();

asm ("\n\
_catchException17:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #17\n\
	bl process_exception");


/* this function is used to set up exception handlers for tracing and
   breakpoints */
void
set_debug_traps (void)
{
  /*  extern void remcomHandler(); */
  int i;

  for (i = 0; i < 18; i++)	/* keep a copy of old vectors */
    if (save_vectors[i] == 0)	/* only copy them the first time */
      save_vectors[i] = getExceptionHandler (i);

  stackPtr = &remcomStack[STACKSIZE / sizeof (int) - 1];

  exceptionHandler (0, _catchException0);
  exceptionHandler (1, _catchException1);
  exceptionHandler (2, _catchException2);
  exceptionHandler (3, _catchException3);
  exceptionHandler (4, _catchException4);
  exceptionHandler (5, _catchException5);
  exceptionHandler (6, _catchException6);
  exceptionHandler (7, _catchException7);
  exceptionHandler (8, _catchException8);
  exceptionHandler (9, _catchException9);
  exceptionHandler (10, _catchException10);
  exceptionHandler (11, _catchException11);
  exceptionHandler (12, _catchException12);
  exceptionHandler (13, _catchException13);
  exceptionHandler (14, _catchException14);
  exceptionHandler (15, _catchException15);
  exceptionHandler (16, _catchException16);
  /*  exceptionHandler (17, _catchException17); */

  initialized = 1;
}

/* This function will generate a breakpoint exception.  It is used at the
   beginning of a program to sync up with a debugger and can be used
   otherwise as a quick means to stop program execution and "break" into
   the debugger. */

#define BREAKPOINT() asm volatile ("	trap #2");

void
breakpoint (void)
{
  if (initialized)
    BREAKPOINT ();
}

/* STDOUT section:
   Stuff pertaining to simulating stdout by sending chars to gdb to be echoed.
   Functions: gdb_putchar(char ch)
              gdb_puts(char *str)
              gdb_write(char *str, int len)
              gdb_error(char *format, char *parm)
	      */

/* Function: gdb_putchar(int)
   Make gdb write a char to stdout.
   Returns: the char */

static int
gdb_putchar (int ch)
{
  char buf[4];

  buf[0] = 'O';
  buf[1] = hexchars[ch >> 4];
  buf[2] = hexchars[ch & 0x0F];
  buf[3] = 0;
  putpacket (buf);
  return ch;
}

/* Function: gdb_write(char *, int)
   Make gdb write n bytes to stdout (not assumed to be null-terminated).
   Returns: number of bytes written */

static int
gdb_write (char *data, int len)
{
  char *buf, *cpy;
  int i;

  buf = remcomOutBuffer;
  buf[0] = 'O';
  i = 0;
  while (i < len)
    {
      for (cpy = buf + 1;
	   i < len && cpy < buf + sizeof (remcomOutBuffer) - 3; i++)
	{
	  *cpy++ = hexchars[data[i] >> 4];
	  *cpy++ = hexchars[data[i] & 0x0F];
	}
      *cpy = 0;
      putpacket (buf);
    }
  return len;
}

/* Function: gdb_puts(char *)
   Make gdb write a null-terminated string to stdout.
   Returns: the length of the string */

static int
gdb_puts (char *str)
{
  return gdb_write (str, strlen (str));
}

/* Function: gdb_error(char *, char *)
   Send an error message to gdb's stdout.
   First string may have 1 (one) optional "%s" in it, which
   will cause the optional second string to be inserted.  */

static void
gdb_error (char *format, char *parm)
{
  char buf[400], *cpy;
  int len;

  if (remote_debug)
    {
      if (format && *format)
	len = strlen (format);
      else
	return;			/* empty input */

      if (parm && *parm)
	len += strlen (parm);

      for (cpy = buf; *format;)
	{
	  if (format[0] == '%' && format[1] == 's')	/* include second string */
	    {
	      format += 2;	/* advance two chars instead of just one */
	      while (parm && *parm)
		*cpy++ = *parm++;
	    }
	  else
	    *cpy++ = *format++;
	}
      *cpy = '\0';
      gdb_puts (buf);
    }
}

static unsigned char *
strcpy (unsigned char *dest, const unsigned char *src)
{
  unsigned char *ret = dest;

  if (dest && src)
    {
      while (*src)
	*dest++ = *src++;
      *dest = 0;
    }
  return ret;
}

static int
strlen (const unsigned char *src)
{
  int ret;

  for (ret = 0; *src; src++)
    ret++;

  return ret;
}

#if 0
void
exit (code)
     int code;
{
  _exit (code);
}

int
atexit (void *p)
{
  return 0;
}

void
abort (void)
{
  _exit (1);
}
#endif
@


1.5
log
@2002-10-04  Michael Snyder  <msnyder@@redhat.com>

	* m32r-stub.c (handle_exception): Make sure exception is "trap"
	before treating it as a single-step event.
@
text
@d1 1718
a1718 1718
/****************************************************************************

		THIS SOFTWARE IS NOT COPYRIGHTED

   HP offers the following for use in the public domain.  HP makes no
   warranty with regard to the software or it's performance and the
   user accepts the software "AS IS" with all faults.

   HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD
   TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES
   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

****************************************************************************/

/****************************************************************************
 *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $
 *
 *  Module name: remcom.c $
 *  Revision: 1.34 $
 *  Date: 91/03/09 12:29:49 $
 *  Contributor:     Lake Stevens Instrument Division$
 *
 *  Description:     low level support for gdb debugger. $
 *
 *  Considerations:  only works on target hardware $
 *
 *  Written by:      Glenn Engel $
 *  ModuleState:     Experimental $
 *
 *  NOTES:           See Below $
 *
 *  Modified for M32R by Michael Snyder, Cygnus Support.
 *
 *  To enable debugger support, two things need to happen.  One, a
 *  call to set_debug_traps() is necessary in order to allow any breakpoints
 *  or error conditions to be properly intercepted and reported to gdb.
 *  Two, a breakpoint needs to be generated to begin communication.  This
 *  is most easily accomplished by a call to breakpoint().  Breakpoint()
 *  simulates a breakpoint by executing a trap #1.
 *
 *  The external function exceptionHandler() is
 *  used to attach a specific handler to a specific M32R vector number.
 *  It should use the same privilege level it runs at.  It should
 *  install it as an interrupt gate so that interrupts are masked
 *  while the handler runs.
 *
 *  Because gdb will sometimes write to the stack area to execute function
 *  calls, this program cannot rely on using the supervisor stack so it
 *  uses it's own stack area reserved in the int array remcomStack.
 *
 *************
 *
 *    The following gdb commands are supported:
 *
 * command          function                               Return value
 *
 *    g             return the value of the CPU registers  hex data or ENN
 *    G             set the value of the CPU registers     OK or ENN
 *
 *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN
 *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN
 *    XAA..AA,LLLL: Write LLLL binary bytes at address     OK or ENN
 *                  AA..AA
 *
 *    c             Resume at current address              SNN   ( signal NN)
 *    cAA..AA       Continue at address AA..AA             SNN
 *
 *    s             Step one instruction                   SNN
 *    sAA..AA       Step one instruction from AA..AA       SNN
 *
 *    k             kill
 *
 *    ?             What was the last sigval ?             SNN   (signal NN)
 *
 * All commands and responses are sent with a packet which includes a
 * checksum.  A packet consists of
 *
 * $<packet info>#<checksum>.
 *
 * where
 * <packet info> :: <characters representing the command or response>
 * <checksum>    :: <two hex digits computed as modulo 256 sum of <packetinfo>>
 *
 * When a packet is received, it is first acknowledged with either '+' or '-'.
 * '+' indicates a successful transfer.  '-' indicates a failed transfer.
 *
 * Example:
 *
 * Host:                  Reply:
 * $m0,10#2a               +$00010203040506070809101112131415#42
 *
 ****************************************************************************/


/************************************************************************
 *
 * external low-level support routines
 */
extern void putDebugChar();	/* write a single character      */
extern int getDebugChar();	/* read and return a single char */
extern void exceptionHandler();	/* assign an exception handler   */

/*****************************************************************************
 * BUFMAX defines the maximum number of characters in inbound/outbound buffers
 * at least NUMREGBYTES*2 are needed for register packets 
 */
#define BUFMAX 400

static char initialized;  /* boolean flag. != 0 means we've been initialized */

int     remote_debug;
/*  debug >  0 prints ill-formed commands in valid packets & checksum errors */

static const unsigned char hexchars[]="0123456789abcdef";

#define NUMREGS 24

/* Number of bytes of registers.  */
#define NUMREGBYTES (NUMREGS * 4)
enum regnames { R0,  R1,  R2,  R3,  R4,  R5,  R6,   R7,
		R8,  R9,  R10, R11, R12, R13, R14,  R15,
		PSW, CBR, SPI, SPU, BPC, PC,  ACCL, ACCH };

enum SYS_calls {
  	SYS_null, 
	SYS_exit,
	SYS_open,
	SYS_close,
	SYS_read,
	SYS_write,
	SYS_lseek,
	SYS_unlink,
	SYS_getpid,
	SYS_kill,
	SYS_fstat,
	SYS_sbrk,
	SYS_fork,
	SYS_execve,
	SYS_wait4,
	SYS_link,
	SYS_chdir,
	SYS_stat,
	SYS_utime,
	SYS_chown,
	SYS_chmod,
	SYS_time,
	SYS_pipe };

static int registers[NUMREGS];

#define STACKSIZE 8096
static unsigned char remcomInBuffer[BUFMAX];
static unsigned char remcomOutBuffer[BUFMAX];
static int  remcomStack[STACKSIZE/sizeof(int)];
static int*  stackPtr = &remcomStack[STACKSIZE/sizeof(int) - 1];

static unsigned int save_vectors[18];	/* previous exception vectors */

/* Indicate to caller of mem2hex or hex2mem that there has been an error. */
static volatile int mem_err = 0;

/* Store the vector number here (since GDB only gets the signal
   number through the usual means, and that's not very specific).  */
int gdb_m32r_vector = -1;

#if 0
#include "syscall.h" /* for SYS_exit, SYS_write etc. */
#endif

/* Global entry points:
 */

extern void handle_exception(int);
extern void set_debug_traps(void);
extern void breakpoint(void);

/* Local functions:
 */

static int  computeSignal(int);
static void putpacket(unsigned char *);
static unsigned char *getpacket(void);

static unsigned char *mem2hex(unsigned char *, unsigned char *, int, int);
static unsigned char *hex2mem(unsigned char *, unsigned char *, int, int);
static int  hexToInt(unsigned char **, int *);
static unsigned char *bin2mem(unsigned char *, unsigned char *, int, int);
static void stash_registers(void);
static void restore_registers(void);
static int  prepare_to_step(int);
static int  finish_from_step(void);
static unsigned long crc32 (unsigned char *, int, unsigned long);

static void gdb_error(char *, char *);
static int  gdb_putchar(int), gdb_puts(char *), gdb_write(char *, int);

static unsigned char *strcpy (unsigned char *, const unsigned char *);
static int   strlen (const unsigned char *);

/*
 * This function does all command procesing for interfacing to gdb.
 */

void 
handle_exception(int exceptionVector)
{
  int    sigval, stepping;
  int    addr, length, i;
  unsigned char * ptr;
  unsigned char   buf[16];
  int binary;

  /* Do not call finish_from_step() if this is not a trap #1
   * (breakpoint trap).  Without this check, the finish_from_step()
   * might interpret a system call trap as a single step trap.  This
   * can happen if: the stub receives 's' and exits, but an interrupt
   * was pending; the interrupt is now handled and causes the stub to
   * be reentered because some function makes a system call.  
   */
  if (exceptionVector == 1)	/* Trap exception? */
    if (!finish_from_step())	/* Go see if stepping state needs update. */
      return;		/* "false step": let the target continue */

  gdb_m32r_vector = exceptionVector;

  if (remote_debug)
    {
      mem2hex((unsigned char *) &exceptionVector, buf, 4, 0);
      gdb_error("Handle exception %s, ", buf);
      mem2hex((unsigned char *) &registers[PC], buf, 4, 0);
      gdb_error("PC == 0x%s\n", buf);
    }

  /* reply to host that an exception has occurred */
  sigval = computeSignal( exceptionVector );

  ptr = remcomOutBuffer;
 
  *ptr++ = 'T';         /* notify gdb with signo, PC, FP and SP */
  *ptr++ = hexchars[sigval >> 4];
  *ptr++ = hexchars[sigval & 0xf];
 
  *ptr++ = hexchars[PC >> 4];
  *ptr++ = hexchars[PC & 0xf];
  *ptr++ = ':';
  ptr = mem2hex((unsigned char *)&registers[PC], ptr, 4, 0);     /* PC */
  *ptr++ = ';';
 
  *ptr++ = hexchars[R13 >> 4];
  *ptr++ = hexchars[R13 & 0xf];
  *ptr++ = ':';
  ptr = mem2hex((unsigned char *)&registers[R13], ptr, 4, 0);    /* FP */
  *ptr++ = ';';
 
  *ptr++ = hexchars[R15 >> 4];
  *ptr++ = hexchars[R15 & 0xf];
  *ptr++ = ':';
  ptr = mem2hex((unsigned char *)&registers[R15], ptr, 4, 0);    /* SP */
  *ptr++ = ';';
  *ptr++ = 0;
 
  if (exceptionVector == 0)     /* simulated SYS call stuff */
    {
      mem2hex((unsigned char *) &registers[PC], buf, 4, 0);
      switch (registers[R0]) {
      case SYS_exit:
	gdb_error("Target program has exited at %s\n", buf);
	ptr = remcomOutBuffer;
	*ptr++ = 'W';
	sigval = registers[R1] & 0xff;
	*ptr++ = hexchars[sigval >> 4];
	*ptr++ = hexchars[sigval & 0xf];
	*ptr++ = 0;
	break;
      case SYS_open:
	gdb_error("Target attempts SYS_open call at %s\n", buf);
	break;
      case SYS_close:
	gdb_error("Target attempts SYS_close call at %s\n", buf);
	break;
      case SYS_read:
	gdb_error("Target attempts SYS_read call at %s\n", buf);
	break;
      case SYS_write:
	if (registers[R1] == 1 ||       /* write to stdout  */
	    registers[R1] == 2)		/* write to stderr  */
	  {				/* (we can do that) */
	    registers[R0] = gdb_write((void *) registers[R2], registers[R3]);
	    return;
	  }
	else
	  gdb_error("Target attempts SYS_write call at %s\n", buf);
	break;
      case SYS_lseek:
	gdb_error("Target attempts SYS_lseek call at %s\n", buf);
	break;
      case SYS_unlink:
	gdb_error("Target attempts SYS_unlink call at %s\n", buf);
	break;
      case SYS_getpid:
	gdb_error("Target attempts SYS_getpid call at %s\n", buf);
	break;
      case SYS_kill:
	gdb_error("Target attempts SYS_kill call at %s\n", buf);
	break;
      case SYS_fstat:
	gdb_error("Target attempts SYS_fstat call at %s\n", buf);
	break;
      default:
	gdb_error("Target attempts unknown SYS call at %s\n", buf);
	break;
      }
    }

  putpacket(remcomOutBuffer);

  stepping = 0;

  while (1==1) {
    remcomOutBuffer[0] = 0;
    ptr = getpacket();
    binary = 0;
    switch (*ptr++) {
      default:	/* Unknown code.  Return an empty reply message. */
	break;
      case 'R':
	if (hexToInt (&ptr, &addr))
	  registers[PC] = addr;
	strcpy(remcomOutBuffer, "OK");
	break;
      case '!':
	strcpy(remcomOutBuffer, "OK");
	break;
    case 'X': /* XAA..AA,LLLL:<binary data>#cs */
      binary = 1;
    case 'M': /* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
      /* TRY TO READ '%x,%x:'.  IF SUCCEED, SET PTR = 0 */
      {
        if (hexToInt(&ptr,&addr))
          if (*(ptr++) == ',')
            if (hexToInt(&ptr,&length))
              if (*(ptr++) == ':')
                {
                  mem_err = 0;
                  if (binary)
                    bin2mem (ptr, (unsigned char *) addr, length, 1);
                  else
                    hex2mem(ptr, (unsigned char*) addr, length, 1);
                  if (mem_err) {
                    strcpy (remcomOutBuffer, "E03");
                    gdb_error ("memory fault", "");
                  } else {
                    strcpy(remcomOutBuffer,"OK");
                  }
                  ptr = 0;
                }
        if (ptr)
          {
            strcpy(remcomOutBuffer,"E02");
          }
      }
	break;
      case 'm': /* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
		/* TRY TO READ %x,%x.  IF SUCCEED, SET PTR = 0 */
	if (hexToInt(&ptr,&addr))
	  if (*(ptr++) == ',')
	    if (hexToInt(&ptr,&length))
	      {
		ptr = 0;
		mem_err = 0;
		mem2hex((unsigned char*) addr, remcomOutBuffer, length, 1);
		if (mem_err) {
		  strcpy (remcomOutBuffer, "E03");
		  gdb_error ("memory fault", "");
		}
	      }
	if (ptr)
	  {
	    strcpy(remcomOutBuffer,"E01");
	  }
	break;
      case '?': 
	remcomOutBuffer[0] = 'S';
	remcomOutBuffer[1] =  hexchars[sigval >> 4];
	remcomOutBuffer[2] =  hexchars[sigval % 16];
	remcomOutBuffer[3] = 0;
	break;
      case 'd': 
	remote_debug = !(remote_debug);  /* toggle debug flag */
	break;
      case 'g': /* return the value of the CPU registers */
	mem2hex((unsigned char*) registers, remcomOutBuffer, NUMREGBYTES, 0);
	break;
      case 'P': /* set the value of a single CPU register - return OK */
	{
	  int regno;

	  if (hexToInt (&ptr, &regno) && *ptr++ == '=')
	    if (regno >= 0 && regno < NUMREGS)
	      {
		int stackmode;

		hex2mem (ptr, (unsigned char *) &registers[regno], 4, 0);
		/*
		 * Since we just changed a single CPU register, let's
		 * make sure to keep the several stack pointers consistant.
		 */
		stackmode = registers[PSW] & 0x80;
		if (regno == R15)	/* stack pointer changed */
		  {			/* need to change SPI or SPU */
		    if (stackmode == 0)
		      registers[SPI] = registers[R15];
		    else
		      registers[SPU] = registers[R15];
		  }
		else if (regno == SPU)	/* "user" stack pointer changed */
		  {
		    if (stackmode != 0)	/* stack in user mode: copy SP */
		      registers[R15] = registers[SPU];
		  }
		else if (regno == SPI)	/* "interrupt" stack pointer changed */
		  {
		    if (stackmode == 0)	/* stack in interrupt mode: copy SP */
		      registers[R15] = registers[SPI];
		  }
		else if (regno == PSW)	/* stack mode may have changed! */
		  {			/* force SP to either SPU or SPI */
		    if (stackmode == 0)	/* stack in user mode */
		      registers[R15] = registers[SPI];
		    else		/* stack in interrupt mode */
		      registers[R15] = registers[SPU];
		  }
		strcpy (remcomOutBuffer, "OK");
		break;
	      }
	  strcpy (remcomOutBuffer, "E01");
	  break;
	}
      case 'G': /* set the value of the CPU registers - return OK */
	hex2mem(ptr, (unsigned char*) registers, NUMREGBYTES, 0);
	strcpy(remcomOutBuffer,"OK");
	break;
      case 's': /* sAA..AA	Step one instruction from AA..AA(optional) */
	stepping = 1;
      case 'c': /* cAA..AA	Continue from address AA..AA(optional) */
		/* try to read optional parameter, pc unchanged if no parm */
	if (hexToInt(&ptr,&addr))
	  registers[ PC ] = addr;
	
	if (stepping)	/* single-stepping */
	  {
	    if (!prepare_to_step(0))	/* set up for single-step */
	      {
		/* prepare_to_step has already emulated the target insn:
		   Send SIGTRAP to gdb, don't resume the target at all.  */
		ptr = remcomOutBuffer;
		*ptr++ = 'T';           /* Simulate stopping with SIGTRAP */
		*ptr++ = '0';
		*ptr++ = '5';

		*ptr++ = hexchars[PC >> 4];     /* send PC */
		*ptr++ = hexchars[PC & 0xf];
		*ptr++ = ':';
		ptr = mem2hex((unsigned char *)&registers[PC], ptr, 4, 0);
		*ptr++ = ';';

		*ptr++ = hexchars[R13 >> 4];    /* send FP */
		*ptr++ = hexchars[R13 & 0xf];
		*ptr++ = ':';
		ptr = mem2hex((unsigned char *)&registers[R13], ptr, 4, 0);
		*ptr++ = ';';

		*ptr++ = hexchars[R15 >> 4];    /* send SP */
		*ptr++ = hexchars[R15 & 0xf];
		*ptr++ = ':';
		ptr = mem2hex((unsigned char *)&registers[R15], ptr, 4, 0);
		*ptr++ = ';';
		*ptr++ = 0;

		break;	
	      }
	  }
	else	/* continuing, not single-stepping */
	  {
	    /* OK, about to do a "continue".  First check to see if the 
	       target pc is on an odd boundary (second instruction in the 
	       word).  If so, we must do a single-step first, because 
	       ya can't jump or return back to an odd boundary!  */
	    if ((registers[PC] & 2) != 0)
	      prepare_to_step(1);
	  }

	return;

      case 'D':	/* Detach */
#if 0
	/* I am interpreting this to mean, release the board from control 
	   by the remote stub.  To do this, I am restoring the original
	   (or at least previous) exception vectors.
	 */
	for (i = 0; i < 18; i++)
	  exceptionHandler (i, save_vectors[i]);
	putpacket ("OK");
	return;		/* continue the inferior */
#else
	strcpy(remcomOutBuffer,"OK");
	break;
#endif
    case 'q':
      if (*ptr++ == 'C' &&
	  *ptr++ == 'R' &&
	  *ptr++ == 'C' &&
	  *ptr++ == ':')
	{
	  unsigned long start, len, our_crc;

	  if (hexToInt (&ptr, (int *) &start) &&
	      *ptr++ == ','                   &&
	      hexToInt (&ptr, (int *) &len))
	    {
	      remcomOutBuffer[0] = 'C';
	      our_crc = crc32 ((unsigned char *) start, len, 0xffffffff);
	      mem2hex ((char *) &our_crc, 
		       &remcomOutBuffer[1], 
		       sizeof (long), 
		       0); 
	    } /* else do nothing */
	} /* else do nothing */
      break;

      case 'k': /* kill the program */
	continue;
      } /* switch */

    /* reply to the request */
    putpacket(remcomOutBuffer);
  }
}

/* qCRC support */

/* Table used by the crc32 function to calcuate the checksum. */
static unsigned long crc32_table[256] = {0, 0};

static unsigned long
crc32 (unsigned char *buf, int len, unsigned long crc)
{
  if (! crc32_table[1])
    {
      /* Initialize the CRC table and the decoding table. */
      int i, j;
      unsigned long c;

      for (i = 0; i < 256; i++)
	{
	  for (c = i << 24, j = 8; j > 0; --j)
	    c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : (c << 1);
	  crc32_table[i] = c;
	}
    }

  while (len--)
    {
      crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ *buf) & 255];
      buf++;
    }
  return crc;
}

static int 
hex (unsigned char ch)
{
  if ((ch >= 'a') && (ch <= 'f')) return (ch-'a'+10);
  if ((ch >= '0') && (ch <= '9')) return (ch-'0');
  if ((ch >= 'A') && (ch <= 'F')) return (ch-'A'+10);
  return (-1);
}

/* scan for the sequence $<data>#<checksum>     */

unsigned char *
getpacket (void)
{
  unsigned char *buffer = &remcomInBuffer[0];
  unsigned char checksum;
  unsigned char xmitcsum;
  int count;
  char ch;

  while (1)
    {
      /* wait around for the start character, ignore all other characters */
      while ((ch = getDebugChar ()) != '$')
	;

retry:
      checksum = 0;
      xmitcsum = -1;
      count = 0;

      /* now, read until a # or end of buffer is found */
      while (count < BUFMAX)
	{
	  ch = getDebugChar ();
          if (ch == '$')
	    goto retry;
	  if (ch == '#')
	    break;
	  checksum = checksum + ch;
	  buffer[count] = ch;
	  count = count + 1;
	}
      buffer[count] = 0;

      if (ch == '#')
	{
	  ch = getDebugChar ();
	  xmitcsum = hex (ch) << 4;
	  ch = getDebugChar ();
	  xmitcsum += hex (ch);

	  if (checksum != xmitcsum)
	    {
	      if (remote_debug)
		{
		  unsigned char buf[16];

		  mem2hex((unsigned char *) &checksum, buf, 4, 0);
		  gdb_error("Bad checksum: my count = %s, ", buf);
		  mem2hex((unsigned char *) &xmitcsum, buf, 4, 0);
		  gdb_error("sent count = %s\n", buf);
		  gdb_error(" -- Bad buffer: \"%s\"\n", buffer); 
		}
	      putDebugChar ('-');	/* failed checksum */
	    }
	  else
	    {
	      putDebugChar ('+');	/* successful transfer */

	      /* if a sequence char is present, reply the sequence ID */
	      if (buffer[2] == ':')
		{
		  putDebugChar (buffer[0]);
		  putDebugChar (buffer[1]);

		  return &buffer[3];
		}

	      return &buffer[0];
	    }
	}
    }
}

/* send the packet in buffer.  */

static void 
putpacket (unsigned char *buffer)
{
  unsigned char checksum;
  int  count;
  char ch;

  /*  $<packet info>#<checksum>. */
  do {
    putDebugChar('$');
    checksum = 0;
    count    = 0;

    while (ch=buffer[count]) {
      putDebugChar(ch);
      checksum += ch;
      count += 1;
    }
    putDebugChar('#');
    putDebugChar(hexchars[checksum >> 4]);
    putDebugChar(hexchars[checksum % 16]);
  } while (getDebugChar() != '+');
}

/* Address of a routine to RTE to if we get a memory fault.  */

static void (*volatile mem_fault_routine)() = 0;

static void
set_mem_err (void)
{
  mem_err = 1;
}

/* Check the address for safe access ranges.  As currently defined,
   this routine will reject the "expansion bus" address range(s).
   To make those ranges useable, someone must implement code to detect
   whether there's anything connected to the expansion bus. */

static int
mem_safe (unsigned char *addr)
{
#define BAD_RANGE_ONE_START	((unsigned char *) 0x600000)
#define BAD_RANGE_ONE_END	((unsigned char *) 0xa00000)
#define BAD_RANGE_TWO_START	((unsigned char *) 0xff680000)
#define BAD_RANGE_TWO_END	((unsigned char *) 0xff800000)

  if (addr < BAD_RANGE_ONE_START)	return 1;	/* safe */
  if (addr < BAD_RANGE_ONE_END)		return 0;	/* unsafe */
  if (addr < BAD_RANGE_TWO_START)	return 1;	/* safe */
  if (addr < BAD_RANGE_TWO_END)		return 0;	/* unsafe */
}

/* These are separate functions so that they are so short and sweet
   that the compiler won't save any registers (if there is a fault
   to mem_fault, they won't get restored, so there better not be any
   saved).  */
static int
get_char (unsigned char *addr)
{
#if 1
  if (mem_fault_routine && !mem_safe(addr))
    {
      mem_fault_routine ();
      return 0;
    }
#endif
  return *addr;
}

static void
set_char (unsigned char *addr, unsigned char val)
{
#if 1
  if (mem_fault_routine && !mem_safe (addr))
    {
      mem_fault_routine ();
      return;
    }
#endif
  *addr = val;
}

/* Convert the memory pointed to by mem into hex, placing result in buf.
   Return a pointer to the last char put in buf (null).
   If MAY_FAULT is non-zero, then we should set mem_err in response to
   a fault; if zero treat a fault like any other fault in the stub.  */

static unsigned char *
mem2hex (unsigned char *mem, unsigned char *buf, int count, int may_fault)
{
  int i;
  unsigned char ch;

  if (may_fault)
    mem_fault_routine = set_mem_err;
  for (i=0;i<count;i++) {
    ch = get_char (mem++);
    if (may_fault && mem_err)
      return (buf);
    *buf++ = hexchars[ch >> 4];
    *buf++ = hexchars[ch % 16];
  }
  *buf = 0;
  if (may_fault)
    mem_fault_routine = 0;
  return(buf);
}

/* Convert the hex array pointed to by buf into binary to be placed in mem.
   Return a pointer to the character AFTER the last byte written. */

static unsigned char* 
hex2mem (unsigned char *buf, unsigned char *mem, int count, int may_fault)
{
  int i;
  unsigned char ch;

  if (may_fault)
    mem_fault_routine = set_mem_err;
  for (i=0;i<count;i++) {
    ch = hex(*buf++) << 4;
    ch = ch + hex(*buf++);
    set_char (mem++, ch);
    if (may_fault && mem_err)
      return (mem);
  }
  if (may_fault)
    mem_fault_routine = 0;
  return(mem);
}

/* Convert the binary stream in BUF to memory.

   Gdb will escape $, #, and the escape char (0x7d).
   COUNT is the total number of bytes to write into
   memory. */
static unsigned char *
bin2mem (unsigned char *buf, unsigned char *mem, int count, int may_fault)
{
  int i;
  unsigned char ch;

  if (may_fault)
    mem_fault_routine = set_mem_err;
  for (i = 0; i < count; i++)
    {
      /* Check for any escaped characters. Be paranoid and
         only unescape chars that should be escaped. */
      if (*buf == 0x7d)
        {
          switch (*(buf+1))
            {
            case 0x3:  /* # */
            case 0x4:  /* $ */
            case 0x5d: /* escape char */
              buf++;
              *buf |= 0x20;
              break;
            default:
              /* nothing */
              break;
            }
        }

      set_char (mem++, *buf++);

      if (may_fault && mem_err)
        return mem;
    }

  if (may_fault)
    mem_fault_routine = 0;
  return mem;
}

/* this function takes the m32r exception vector and attempts to
   translate this number into a unix compatible signal value */

static int 
computeSignal (int exceptionVector)
{
  int sigval;
  switch (exceptionVector) {
    case 0  : sigval = 23; break; /* I/O trap                    */
    case 1  : sigval = 5;  break; /* breakpoint                  */
    case 2  : sigval = 5;  break; /* breakpoint                  */
    case 3  : sigval = 5;  break; /* breakpoint                  */
    case 4  : sigval = 5;  break; /* breakpoint                  */
    case 5  : sigval = 5;  break; /* breakpoint                  */
    case 6  : sigval = 5;  break; /* breakpoint                  */
    case 7  : sigval = 5;  break; /* breakpoint                  */
    case 8  : sigval = 5;  break; /* breakpoint                  */
    case 9  : sigval = 5;  break; /* breakpoint                  */
    case 10 : sigval = 5;  break; /* breakpoint                  */
    case 11 : sigval = 5;  break; /* breakpoint                  */
    case 12 : sigval = 5;  break; /* breakpoint                  */
    case 13 : sigval = 5;  break; /* breakpoint                  */
    case 14 : sigval = 5;  break; /* breakpoint                  */
    case 15 : sigval = 5;  break; /* breakpoint                  */
    case 16 : sigval = 10; break; /* BUS ERROR (alignment)       */
    case 17 : sigval = 2;  break; /* INTerrupt                   */
    default : sigval = 7;  break; /* "software generated"        */
  }
  return (sigval);
}

/**********************************************/
/* WHILE WE FIND NICE HEX CHARS, BUILD AN INT */
/* RETURN NUMBER OF CHARS PROCESSED           */
/**********************************************/
static int 
hexToInt (unsigned char **ptr, int *intValue)
{
  int numChars = 0;
  int hexValue;

  *intValue = 0;
  while (**ptr)
    {
      hexValue = hex(**ptr);
      if (hexValue >=0)
        {
	  *intValue = (*intValue <<4) | hexValue;
	  numChars ++;
        }
      else
	break;
      (*ptr)++;
    }
  return (numChars);
}

/*
  Table of branch instructions:
  
  10B6		RTE	return from trap or exception
  1FCr		JMP	jump
  1ECr		JL	jump and link
  7Fxx		BRA	branch
  FFxxxxxx	BRA	branch (long)
  B09rxxxx	BNEZ	branch not-equal-zero
  Br1rxxxx	BNE	branch not-equal
  7Dxx		BNC	branch not-condition
  FDxxxxxx	BNC	branch not-condition (long)
  B0Arxxxx	BLTZ	branch less-than-zero
  B0Crxxxx	BLEZ	branch less-equal-zero
  7Exx		BL	branch and link
  FExxxxxx	BL	branch and link (long)
  B0Drxxxx	BGTZ	branch greater-than-zero
  B0Brxxxx	BGEZ	branch greater-equal-zero
  B08rxxxx	BEQZ	branch equal-zero
  Br0rxxxx	BEQ	branch equal
  7Cxx		BC	branch condition
  FCxxxxxx	BC	branch condition (long)
  */

static int 
isShortBranch (unsigned char *instr)
{
  unsigned char instr0 = instr[0] & 0x7F;		/* mask off high bit */

  if (instr0 == 0x10 && instr[1] == 0xB6)	/* RTE */
    return 1;		/* return from trap or exception */

  if (instr0 == 0x1E || instr0 == 0x1F)		/* JL or JMP */
    if ((instr[1] & 0xF0) == 0xC0)
      return 2;					/* jump thru a register */

  if (instr0 == 0x7C || instr0 == 0x7D || 	/* BC, BNC, BL, BRA */
      instr0 == 0x7E || instr0 == 0x7F)
    return 3;					/* eight bit PC offset */

  return 0;
}

static int
isLongBranch (unsigned char *instr)
{
  if (instr[0] == 0xFC || instr[0] == 0xFD ||	/* BRA, BNC, BL, BC */
      instr[0] == 0xFE || instr[0] == 0xFF)	/* 24 bit relative */
    return 4;
  if ((instr[0] & 0xF0) == 0xB0)		/* 16 bit relative */
    {
      if ((instr[1] & 0xF0) == 0x00 || 		/* BNE, BEQ */
	  (instr[1] & 0xF0) == 0x10)
	return 5;
      if (instr[0] == 0xB0)	/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ, BEQZ */
	if ((instr[1] & 0xF0) == 0x80 || (instr[1] & 0xF0) == 0x90 || 
	    (instr[1] & 0xF0) == 0xA0 || (instr[1] & 0xF0) == 0xB0 ||
	    (instr[1] & 0xF0) == 0xC0 || (instr[1] & 0xF0) == 0xD0)
	  return 6;
    }
  return 0;
}

/* if address is NOT on a 4-byte boundary, or high-bit of instr is zero, 
   then it's a 2-byte instruction, else it's a 4-byte instruction.  */

#define INSTRUCTION_SIZE(addr) \
    ((((int) addr & 2) || (((unsigned char *) addr)[0] & 0x80) == 0) ? 2 : 4)

static int
isBranch (unsigned char *instr)
{
  if (INSTRUCTION_SIZE(instr) == 2)
    return isShortBranch(instr);
  else
    return isLongBranch(instr);
}

static int
willBranch (unsigned char *instr, int branchCode)
{
  switch (branchCode) 
    {
    case 0:	return 0;	/* not a branch */
    case 1:	return 1;	/* RTE */
    case 2:	return 1;	/* JL or JMP    */
    case 3:			/* BC, BNC, BL, BRA (short) */
    case 4:			/* BC, BNC, BL, BRA (long) */
      switch (instr[0] & 0x0F) 
	{
	case 0xC:		/* Branch if Condition Register */
	  return (registers[CBR] != 0);
	case 0xD:		/* Branch if NOT Condition Register */
	  return (registers[CBR] == 0);
	case 0xE:		/* Branch and Link */
	case 0xF:		/* Branch (unconditional) */
	  return 1;
	default:		/* oops? */
	  return 0;
	}
    case 5: 			/* BNE, BEQ */
      switch (instr[1] & 0xF0) 
	{
	case 0x00:		/* Branch if r1 equal to r2 */
	  return (registers[instr[0] & 0x0F] == registers[instr[1] & 0x0F]);
	case 0x10:		/* Branch if r1 NOT equal to r2 */
	  return (registers[instr[0] & 0x0F] != registers[instr[1] & 0x0F]);
	default:		/* oops? */
	  return 0;
	}
    case 6: 			/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ */
      switch (instr[1] & 0xF0) 
	{
	case 0x80:		/* Branch if reg equal to zero */
	  return (registers[instr[1] & 0x0F] == 0);
	case 0x90:		/* Branch if reg NOT equal to zero */
	  return (registers[instr[1] & 0x0F] != 0);
	case 0xA0:		/* Branch if reg less than zero */
	  return (registers[instr[1] & 0x0F] < 0);
	case 0xB0:		/* Branch if reg greater or equal to zero */
	  return (registers[instr[1] & 0x0F] >= 0);
	case 0xC0:		/* Branch if reg less than or equal to zero */
	  return (registers[instr[1] & 0x0F] <= 0);
	case 0xD0:		/* Branch if reg greater than zero */
	  return (registers[instr[1] & 0x0F] > 0);
	default:		/* oops? */
	  return 0;
	}
    default:			/* oops? */
      return 0;
    }
}

static int 
branchDestination (unsigned char *instr, int branchCode)
{ 
  switch (branchCode) { 
  default: 
  case 0:					/* not a branch */ 
    return 0;
  case 1:					/* RTE */ 
    return registers[BPC] & ~3; 		/* pop BPC into PC */
  case 2: 					/* JL or JMP */ 
    return registers[instr[1] & 0x0F] & ~3;	/* jump thru a register */ 
  case 3: 		/* BC, BNC, BL, BRA (short, 8-bit relative offset) */ 
    return (((int) instr) & ~3) + ((char) instr[1] << 2);
  case 4: 		/* BC, BNC, BL, BRA (long, 24-bit relative offset) */ 
    return ((int) instr + 
	    ((((char) instr[1] << 16) | (instr[2] << 8) | (instr[3])) << 2)); 
  case 5: 		/* BNE, BEQ (16-bit relative offset) */ 
  case 6: 		/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ (ditto) */ 
    return ((int) instr + ((((char) instr[2] << 8) | (instr[3])) << 2)); 
  }

  /* An explanatory note: in the last three return expressions, I have
     cast the most-significant byte of the return offset to char.
     What this accomplishes is sign extension.  If the other
     less-significant bytes were signed as well, they would get sign
     extended too and, if negative, their leading bits would clobber
     the bits of the more-significant bytes ahead of them.  There are
     other ways I could have done this, but sign extension from
     odd-sized integers is always a pain. */
}

static void
branchSideEffects (unsigned char *instr, int branchCode)
{
  switch (branchCode)
    {
    case 1:			/* RTE */
      return;			/* I <THINK> this is already handled... */
    case 2:			/* JL (or JMP) */
    case 3:			/* BL (or BC, BNC, BRA) */
    case 4:
      if ((instr[0] & 0x0F) == 0x0E)		/* branch/jump and link */
	registers[R14] = (registers[PC] & ~3) + 4;
      return;
    default:			/* any other branch has no side effects */
      return;
    }
}

static struct STEPPING_CONTEXT {
  int stepping;			/* true when we've started a single-step */
  unsigned long  target_addr;	/* the instr we're trying to execute */
  unsigned long  target_size;	/* the size of the target instr */
  unsigned long  noop_addr;	/* where we've inserted a no-op, if any */
  unsigned long  trap1_addr;	/* the trap following the target instr */
  unsigned long  trap2_addr;	/* the trap at a branch destination, if any */
  unsigned short noop_save;	/* instruction overwritten by our no-op */
  unsigned short trap1_save;	/* instruction overwritten by trap1 */
  unsigned short trap2_save;	/* instruction overwritten by trap2 */
  unsigned short continue_p;	/* true if NOT returning to gdb after step */
} stepping;

/* Function: prepare_to_step
   Called from handle_exception to prepare the user program to single-step.
   Places a trap instruction after the target instruction, with special 
   extra handling for branch instructions and for instructions in the 
   second half-word of a word.  

   Returns: True  if we should actually execute the instruction; 
	    False if we are going to emulate executing the instruction,
	    in which case we simply report to GDB that the instruction 
	    has already been executed.  */

#define TRAP1  0x10f1;	/* trap #1 instruction */
#define NOOP   0x7000;  /* noop    instruction */

static unsigned short trap1 = TRAP1;
static unsigned short noop  = NOOP;

static int
prepare_to_step(continue_p)
     int continue_p;	/* if this isn't REALLY a single-step (see below) */
{
  unsigned long pc = registers[PC];
  int branchCode   = isBranch((unsigned char *) pc);
  unsigned char *p;

  /* zero out the stepping context 
     (paranoia -- it should already be zeroed) */
  for (p = (unsigned char *) &stepping;
       p < ((unsigned char *) &stepping) + sizeof(stepping);
       p++)
    *p = 0;

  if (branchCode != 0)			/* next instruction is a branch */
    {
      branchSideEffects((unsigned char *) pc, branchCode);
      if (willBranch((unsigned char *)pc, branchCode))
	registers[PC] = branchDestination((unsigned char *) pc, branchCode);
      else
	registers[PC] = pc + INSTRUCTION_SIZE(pc);
      return 0;			/* branch "executed" -- just notify GDB */
    }
  else if (((int) pc & 2) != 0)		/* "second-slot" instruction */
    {
      /* insert no-op before pc */
      stepping.noop_addr  =  pc - 2;
      stepping.noop_save  = *(unsigned short *) stepping.noop_addr;
      *(unsigned short *) stepping.noop_addr  = noop;
      /* insert trap  after  pc */
      stepping.trap1_addr =  pc + 2;
      stepping.trap1_save = *(unsigned short *) stepping.trap1_addr;
      *(unsigned short *) stepping.trap1_addr = trap1;
    }
  else					/* "first-slot" instruction */
    {
      /* insert trap  after  pc */
      stepping.trap1_addr = pc + INSTRUCTION_SIZE(pc);	
      stepping.trap1_save = *(unsigned short *) stepping.trap1_addr;
      *(unsigned short *) stepping.trap1_addr = trap1;
    }
  /* "continue_p" means that we are actually doing a continue, and not 
     being requested to single-step by GDB.  Sometimes we have to do
     one single-step before continuing, because the PC is on a half-word
     boundary.  There's no way to simply resume at such an address.  */
  stepping.continue_p = continue_p;
  stepping.stepping = 1;		/* starting a single-step */
  return 1;
}

/* Function: finish_from_step
   Called from handle_exception to finish up when the user program 
   returns from a single-step.  Replaces the instructions that had
   been overwritten by traps or no-ops, 

   Returns: True  if we should notify GDB that the target stopped.
	    False if we only single-stepped because we had to before we
	    could continue (ie. we were trying to continue at a 
	    half-word boundary).  In that case don't notify GDB:
	    just "continue continuing".  */

static int
finish_from_step (void)
{
  if (stepping.stepping)	/* anything to do? */
    {
      int continue_p = stepping.continue_p;
      unsigned char *p;

      if (stepping.noop_addr)	/* replace instr "under" our no-op */
	*(unsigned short *) stepping.noop_addr  = stepping.noop_save;
      if (stepping.trap1_addr)	/* replace instr "under" our trap  */
	*(unsigned short *) stepping.trap1_addr = stepping.trap1_save;
      if (stepping.trap2_addr)  /* ditto our other trap, if any    */
	*(unsigned short *) stepping.trap2_addr = stepping.trap2_save;

      for (p = (unsigned char *) &stepping;	/* zero out the stepping context */
	   p < ((unsigned char *) &stepping) + sizeof(stepping);
	   p++)
	*p = 0;

      return !(continue_p);
    }
  else 	/* we didn't single-step, therefore this must be a legitimate stop */
    return 1;
}

struct PSWreg {		/* separate out the bit flags in the PSW register */
  int pad1 : 16;
  int bsm  : 1;
  int bie  : 1;
  int pad2 : 5;
  int bc   : 1;
  int sm   : 1;
  int ie   : 1;
  int pad3 : 5;
  int c    : 1;
} *psw;

/* Upon entry the value for LR to save has been pushed.
   We unpush that so that the value for the stack pointer saved is correct.
   Upon entry, all other registers are assumed to have not been modified
   since the interrupt/trap occured.  */

asm ("
stash_registers:
	push r0
	push r1
	seth r1, #shigh(registers)
	add3 r1, r1, #low(registers)
	pop r0		; r1
	st r0, @@(4,r1)
	pop r0		; r0
	st r0, @@r1
	addi r1, #4	; only add 4 as subsequent saves are `pre inc'
	st r2, @@+r1
	st r3, @@+r1
	st r4, @@+r1
	st r5, @@+r1
	st r6, @@+r1
	st r7, @@+r1
	st r8, @@+r1
	st r9, @@+r1
	st r10, @@+r1
	st r11, @@+r1
	st r12, @@+r1
	st r13, @@+r1    ; fp
	pop r0		; lr (r14)
	st r0, @@+r1
	st sp, @@+r1	; sp contains right value at this point
	mvfc r0, cr0
	st r0, @@+r1	; cr0 == PSW
	mvfc r0, cr1
	st r0, @@+r1	; cr1 == CBR
	mvfc r0, cr2
	st r0, @@+r1	; cr2 == SPI
	mvfc r0, cr3
	st r0, @@+r1	; cr3 == SPU
	mvfc r0, cr6
	st r0, @@+r1	; cr6 == BPC
	st r0, @@+r1	; PC  == BPC
	mvfaclo r0
	st r0, @@+r1	; ACCL
	mvfachi r0
	st r0, @@+r1	; ACCH
	jmp lr");

/* C routine to clean up what stash_registers did.
   It is called after calling stash_registers.
   This is separate from stash_registers as we want to do this in C
   but doing stash_registers in C isn't straightforward.  */

static void
cleanup_stash (void)
{
  psw = (struct PSWreg *) &registers[PSW];	/* fields of PSW register */
  psw->sm = psw->bsm;		/* fix up pre-trap values of psw fields */
  psw->ie = psw->bie;
  psw->c  = psw->bc;
  registers[CBR] = psw->bc;		/* fix up pre-trap "C" register */

#if 0 /* FIXME: Was in previous version.  Necessary?
	 (Remember that we use the "rte" insn to return from the
	 trap/interrupt so the values of bsm, bie, bc are important.  */
  psw->bsm = psw->bie = psw->bc = 0;	/* zero post-trap values */
#endif

  /* FIXME: Copied from previous version.  This can probably be deleted
     since methinks stash_registers has already done this.  */
  registers[PC] = registers[BPC];	/* pre-trap PC */

  /* FIXME: Copied from previous version.  Necessary?  */
  if (psw->sm)			/* copy R15 into (psw->sm ? SPU : SPI) */
    registers[SPU] = registers[R15];
  else
    registers[SPI] = registers[R15];
}

asm ("
restore_and_return:
	seth r0, #shigh(registers+8)
	add3 r0, r0, #low(registers+8)
	ld r2, @@r0+	; restore r2
	ld r3, @@r0+	; restore r3
	ld r4, @@r0+	; restore r4
	ld r5, @@r0+	; restore r5
	ld r6, @@r0+	; restore r6
	ld r7, @@r0+	; restore r7
	ld r8, @@r0+	; restore r8
	ld r9, @@r0+	; restore r9
	ld r10, @@r0+	; restore r10
	ld r11, @@r0+	; restore r11
	ld r12, @@r0+	; restore r12
	ld r13, @@r0+	; restore r13
	ld r14, @@r0+	; restore r14
	ld r15, @@r0+	; restore r15
	addi r0, #4	; don't restore PSW (rte will do it)
	ld r1, @@r0+	; restore cr1 == CBR (no-op, because it's read only)
	mvtc r1, cr1
	ld r1, @@r0+	; restore cr2 == SPI
	mvtc r1, cr2
	ld r1, @@r0+	; restore cr3 == SPU
	mvtc r1, cr3
	addi r0, #4	; skip BPC
	ld r1, @@r0+	; restore cr6 (BPC) == PC
	mvtc r1, cr6
	ld r1, @@r0+	; restore ACCL
	mvtaclo r1
	ld r1, @@r0+	; restore ACCH
	mvtachi r1
	seth r0, #shigh(registers)
	add3 r0, r0, #low(registers)
	ld r1, @@(4,r0)	; restore r1
	ld r0, @@r0	; restore r0
	rte");

/* General trap handler, called after the registers have been stashed.
   NUM is the trap/exception number.  */

static void
process_exception (int num)
{
  cleanup_stash ();
  asm volatile ("
	seth r1, #shigh(stackPtr)
	add3 r1, r1, #low(stackPtr)
	ld r15, @@r1		; setup local stack (protect user stack)
	mv r0, %0
	bl handle_exception
	bl restore_and_return"
		: : "r" (num) : "r0", "r1");
}

void _catchException0 ();

asm ("
_catchException0:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #0
	bl process_exception");

void _catchException1 ();

asm ("
_catchException1:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	bl cleanup_stash
	seth r1, #shigh(stackPtr)
	add3 r1, r1, #low(stackPtr)
	ld r15, @@r1		; setup local stack (protect user stack)
	seth r1, #shigh(registers + 21*4) ; PC
	add3 r1, r1, #low(registers + 21*4)
	ld r0, @@r1
	addi r0, #-4		; back up PC for breakpoint trap.
	st r0, @@r1		; FIXME: what about bp in right slot?
	ldi r0, #1
	bl handle_exception
	bl restore_and_return");

void _catchException2 ();

asm ("
_catchException2:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #2
	bl process_exception");

void _catchException3 ();

asm ("
_catchException3:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #3
	bl process_exception");

void _catchException4 ();

asm ("
_catchException4:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #4
	bl process_exception");

void _catchException5 ();

asm ("
_catchException5:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #5
	bl process_exception");

void _catchException6 ();

asm ("
_catchException6:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #6
	bl process_exception");

void _catchException7 ();

asm ("
_catchException7:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #7
	bl process_exception");

void _catchException8 ();

asm ("
_catchException8:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #8
	bl process_exception");

void _catchException9 ();

asm ("
_catchException9:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #9
	bl process_exception");

void _catchException10 ();

asm ("
_catchException10:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #10
	bl process_exception");

void _catchException11 ();

asm ("
_catchException11:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #11
	bl process_exception");

void _catchException12 ();

asm ("
_catchException12:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #12
	bl process_exception");

void _catchException13 ();

asm ("
_catchException13:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #13
	bl process_exception");

void _catchException14 ();

asm ("
_catchException14:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #14
	bl process_exception");

void _catchException15 ();

asm ("
_catchException15:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #15
	bl process_exception");

void _catchException16 ();

asm ("
_catchException16:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #16
	bl process_exception");

void _catchException17 ();

asm ("
_catchException17:
	push lr
	bl stash_registers
	; Note that at this point the pushed value of `lr' has been popped
	ldi r0, #17
	bl process_exception");


/* this function is used to set up exception handlers for tracing and
   breakpoints */
void 
set_debug_traps (void)
{
  /*  extern void remcomHandler(); */
  int i;

  for (i = 0; i < 18; i++)		/* keep a copy of old vectors */
    if (save_vectors[i] == 0)		/* only copy them the first time */
      save_vectors[i] = getExceptionHandler (i);

  stackPtr  = &remcomStack[STACKSIZE/sizeof(int) - 1];

  exceptionHandler (0, _catchException0);
  exceptionHandler (1, _catchException1);
  exceptionHandler (2, _catchException2);
  exceptionHandler (3, _catchException3);
  exceptionHandler (4, _catchException4);
  exceptionHandler (5, _catchException5);
  exceptionHandler (6, _catchException6);
  exceptionHandler (7, _catchException7);
  exceptionHandler (8, _catchException8);
  exceptionHandler (9, _catchException9);
  exceptionHandler (10, _catchException10);
  exceptionHandler (11, _catchException11);
  exceptionHandler (12, _catchException12);
  exceptionHandler (13, _catchException13);
  exceptionHandler (14, _catchException14);
  exceptionHandler (15, _catchException15);
  exceptionHandler (16, _catchException16);
  /*  exceptionHandler (17, _catchException17); */

  initialized = 1;
}

/* This function will generate a breakpoint exception.  It is used at the
   beginning of a program to sync up with a debugger and can be used
   otherwise as a quick means to stop program execution and "break" into
   the debugger. */

#define BREAKPOINT() asm volatile ("	trap #2");

void 
breakpoint (void)
{
  if (initialized)
    BREAKPOINT();
}

/* STDOUT section:
   Stuff pertaining to simulating stdout by sending chars to gdb to be echoed.
   Functions: gdb_putchar(char ch)
              gdb_puts(char *str)
              gdb_write(char *str, int len)
              gdb_error(char *format, char *parm)
	      */
 
/* Function: gdb_putchar(int)
   Make gdb write a char to stdout.
   Returns: the char */
 
static int
gdb_putchar (int ch)
{
  char buf[4];
 
  buf[0] = 'O';
  buf[1] = hexchars[ch >> 4];
  buf[2] = hexchars[ch & 0x0F];
  buf[3] = 0;
  putpacket(buf);
  return ch;
}
 
/* Function: gdb_write(char *, int)
   Make gdb write n bytes to stdout (not assumed to be null-terminated).
   Returns: number of bytes written */
 
static int
gdb_write (char *data, int len)
{
  char *buf, *cpy;
  int i;
 
  buf = remcomOutBuffer;
  buf[0] = 'O';
  i = 0;
  while (i < len)
    {
      for (cpy = buf+1; 
	   i < len && cpy < buf + sizeof(remcomOutBuffer) - 3; 
	   i++)
	{
	  *cpy++ = hexchars[data[i] >> 4];
	  *cpy++ = hexchars[data[i] & 0x0F];
	}
      *cpy = 0;
      putpacket(buf);
    }
  return len;
}

/* Function: gdb_puts(char *)
   Make gdb write a null-terminated string to stdout.
   Returns: the length of the string */
 
static int
gdb_puts (char *str)
{
  return gdb_write(str, strlen(str));
}
 
/* Function: gdb_error(char *, char *)
   Send an error message to gdb's stdout.
   First string may have 1 (one) optional "%s" in it, which
   will cause the optional second string to be inserted.  */
 
static void
gdb_error (char *format, char *parm)
{
  char buf[400], *cpy;
  int len;
 
  if (remote_debug)
    {
      if (format && *format)
	len = strlen(format);
      else
	return;             /* empty input */

      if (parm && *parm)
	len += strlen(parm);
 
      for (cpy = buf; *format; )
	{
	  if (format[0] == '%' && format[1] == 's') /* include second string */
	    {
	      format += 2;          /* advance two chars instead of just one */
	      while (parm && *parm)
		*cpy++ = *parm++;
	    }
	  else
	    *cpy++ = *format++;
	}
      *cpy = '\0';
      gdb_puts(buf);
    }
}
 
static unsigned char *
strcpy (unsigned char *dest, const unsigned char *src)
{
  unsigned char *ret = dest;

  if (dest && src)
    {
      while (*src)
	*dest++ = *src++;
      *dest = 0;
    }
  return ret;
}

static int
strlen (const unsigned char *src)
{
  int ret;

  for (ret = 0; *src; src++)
    ret++;

  return ret;
}

#if 0
void exit (code)
     int code;
{
  _exit (code);
}

int atexit (void *p)
{
  return 0;
}

void abort (void)
{
  _exit (1);
}
#endif
@


1.5.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d99 3
a101 3
extern void putDebugChar ();	/* write a single character      */
extern int getDebugChar ();	/* read and return a single char */
extern void exceptionHandler ();	/* assign an exception handler   */
d109 1
a109 1
static char initialized;	/* boolean flag. != 0 means we've been initialized */
d111 1
a111 1
int remote_debug;
d114 1
a114 1
static const unsigned char hexchars[] = "0123456789abcdef";
d120 28
a147 32
enum regnames
{ R0, R1, R2, R3, R4, R5, R6, R7,
  R8, R9, R10, R11, R12, R13, R14, R15,
  PSW, CBR, SPI, SPU, BPC, PC, ACCL, ACCH
};

enum SYS_calls
{
  SYS_null,
  SYS_exit,
  SYS_open,
  SYS_close,
  SYS_read,
  SYS_write,
  SYS_lseek,
  SYS_unlink,
  SYS_getpid,
  SYS_kill,
  SYS_fstat,
  SYS_sbrk,
  SYS_fork,
  SYS_execve,
  SYS_wait4,
  SYS_link,
  SYS_chdir,
  SYS_stat,
  SYS_utime,
  SYS_chown,
  SYS_chmod,
  SYS_time,
  SYS_pipe
};
d154 2
a155 2
static int remcomStack[STACKSIZE / sizeof (int)];
static int *stackPtr = &remcomStack[STACKSIZE / sizeof (int) - 1];
d167 1
a167 1
#include "syscall.h"		/* for SYS_exit, SYS_write etc. */
d173 3
a175 3
extern void handle_exception (int);
extern void set_debug_traps (void);
extern void breakpoint (void);
d180 12
a191 12
static int computeSignal (int);
static void putpacket (unsigned char *);
static unsigned char *getpacket (void);

static unsigned char *mem2hex (unsigned char *, unsigned char *, int, int);
static unsigned char *hex2mem (unsigned char *, unsigned char *, int, int);
static int hexToInt (unsigned char **, int *);
static unsigned char *bin2mem (unsigned char *, unsigned char *, int, int);
static void stash_registers (void);
static void restore_registers (void);
static int prepare_to_step (int);
static int finish_from_step (void);
d194 2
a195 2
static void gdb_error (char *, char *);
static int gdb_putchar (int), gdb_puts (char *), gdb_write (char *, int);
d198 1
a198 1
static int strlen (const unsigned char *);
d204 2
a205 2
void
handle_exception (int exceptionVector)
d207 4
a210 4
  int sigval, stepping;
  int addr, length, i;
  unsigned char *ptr;
  unsigned char buf[16];
d213 10
a222 2
  if (!finish_from_step ())
    return;			/* "false step": let the target continue */
d228 4
a231 4
      mem2hex ((unsigned char *) &exceptionVector, buf, 4, 0);
      gdb_error ("Handle exception %s, ", buf);
      mem2hex ((unsigned char *) &registers[PC], buf, 4, 0);
      gdb_error ("PC == 0x%s\n", buf);
d235 1
a235 1
  sigval = computeSignal (exceptionVector);
d238 2
a239 2

  *ptr++ = 'T';			/* notify gdb with signo, PC, FP and SP */
d242 1
a242 1

d246 1
a246 1
  ptr = mem2hex ((unsigned char *) &registers[PC], ptr, 4, 0);	/* PC */
d248 1
a248 1

d252 1
a252 1
  ptr = mem2hex ((unsigned char *) &registers[R13], ptr, 4, 0);	/* FP */
d254 1
a254 1

d258 1
a258 1
  ptr = mem2hex ((unsigned char *) &registers[R15], ptr, 4, 0);	/* SP */
d261 2
a262 2

  if (exceptionVector == 0)	/* simulated SYS call stuff */
d264 49
a312 51
      mem2hex ((unsigned char *) &registers[PC], buf, 4, 0);
      switch (registers[R0])
	{
	case SYS_exit:
	  gdb_error ("Target program has exited at %s\n", buf);
	  ptr = remcomOutBuffer;
	  *ptr++ = 'W';
	  sigval = registers[R1] & 0xff;
	  *ptr++ = hexchars[sigval >> 4];
	  *ptr++ = hexchars[sigval & 0xf];
	  *ptr++ = 0;
	  break;
	case SYS_open:
	  gdb_error ("Target attempts SYS_open call at %s\n", buf);
	  break;
	case SYS_close:
	  gdb_error ("Target attempts SYS_close call at %s\n", buf);
	  break;
	case SYS_read:
	  gdb_error ("Target attempts SYS_read call at %s\n", buf);
	  break;
	case SYS_write:
	  if (registers[R1] == 1 ||	/* write to stdout  */
	      registers[R1] == 2)	/* write to stderr  */
	    {			/* (we can do that) */
	      registers[R0] =
		gdb_write ((void *) registers[R2], registers[R3]);
	      return;
	    }
	  else
	    gdb_error ("Target attempts SYS_write call at %s\n", buf);
	  break;
	case SYS_lseek:
	  gdb_error ("Target attempts SYS_lseek call at %s\n", buf);
	  break;
	case SYS_unlink:
	  gdb_error ("Target attempts SYS_unlink call at %s\n", buf);
	  break;
	case SYS_getpid:
	  gdb_error ("Target attempts SYS_getpid call at %s\n", buf);
	  break;
	case SYS_kill:
	  gdb_error ("Target attempts SYS_kill call at %s\n", buf);
	  break;
	case SYS_fstat:
	  gdb_error ("Target attempts SYS_fstat call at %s\n", buf);
	  break;
	default:
	  gdb_error ("Target attempts unknown SYS call at %s\n", buf);
	  break;
	}
d315 1
a315 1
  putpacket (remcomOutBuffer);
d319 76
a394 6
  while (1 == 1)
    {
      remcomOutBuffer[0] = 0;
      ptr = getpacket ();
      binary = 0;
      switch (*ptr++)
d396 41
a436 1
	default:		/* Unknown code.  Return an empty reply message. */
d438 13
a450 12
	case 'R':
	  if (hexToInt (&ptr, &addr))
	    registers[PC] = addr;
	  strcpy (remcomOutBuffer, "OK");
	  break;
	case '!':
	  strcpy (remcomOutBuffer, "OK");
	  break;
	case 'X':		/* XAA..AA,LLLL:<binary data>#cs */
	  binary = 1;
	case 'M':		/* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
	  /* TRY TO READ '%x,%x:'.  IF SUCCEED, SET PTR = 0 */
d452 1
a452 22
	    if (hexToInt (&ptr, &addr))
	      if (*(ptr++) == ',')
		if (hexToInt (&ptr, &length))
		  if (*(ptr++) == ':')
		    {
		      mem_err = 0;
		      if (binary)
			bin2mem (ptr, (unsigned char *) addr, length, 1);
		      else
			hex2mem (ptr, (unsigned char *) addr, length, 1);
		      if (mem_err)
			{
			  strcpy (remcomOutBuffer, "E03");
			  gdb_error ("memory fault", "");
			}
		      else
			{
			  strcpy (remcomOutBuffer, "OK");
			}
		      ptr = 0;
		    }
	    if (ptr)
d454 27
a480 1
		strcpy (remcomOutBuffer, "E02");
d483 1
a483 36
	  break;
	case 'm':		/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
	  /* TRY TO READ %x,%x.  IF SUCCEED, SET PTR = 0 */
	  if (hexToInt (&ptr, &addr))
	    if (*(ptr++) == ',')
	      if (hexToInt (&ptr, &length))
		{
		  ptr = 0;
		  mem_err = 0;
		  mem2hex ((unsigned char *) addr, remcomOutBuffer, length,
			   1);
		  if (mem_err)
		    {
		      strcpy (remcomOutBuffer, "E03");
		      gdb_error ("memory fault", "");
		    }
		}
	  if (ptr)
	    {
	      strcpy (remcomOutBuffer, "E01");
	    }
	  break;
	case '?':
	  remcomOutBuffer[0] = 'S';
	  remcomOutBuffer[1] = hexchars[sigval >> 4];
	  remcomOutBuffer[2] = hexchars[sigval % 16];
	  remcomOutBuffer[3] = 0;
	  break;
	case 'd':
	  remote_debug = !(remote_debug);	/* toggle debug flag */
	  break;
	case 'g':		/* return the value of the CPU registers */
	  mem2hex ((unsigned char *) registers, remcomOutBuffer, NUMREGBYTES,
		   0);
	  break;
	case 'P':		/* set the value of a single CPU register - return OK */
d485 6
a490 42
	    int regno;

	    if (hexToInt (&ptr, &regno) && *ptr++ == '=')
	      if (regno >= 0 && regno < NUMREGS)
		{
		  int stackmode;

		  hex2mem (ptr, (unsigned char *) &registers[regno], 4, 0);
		  /*
		   * Since we just changed a single CPU register, let's
		   * make sure to keep the several stack pointers consistant.
		   */
		  stackmode = registers[PSW] & 0x80;
		  if (regno == R15)	/* stack pointer changed */
		    {		/* need to change SPI or SPU */
		      if (stackmode == 0)
			registers[SPI] = registers[R15];
		      else
			registers[SPU] = registers[R15];
		    }
		  else if (regno == SPU)	/* "user" stack pointer changed */
		    {
		      if (stackmode != 0)	/* stack in user mode: copy SP */
			registers[R15] = registers[SPU];
		    }
		  else if (regno == SPI)	/* "interrupt" stack pointer changed */
		    {
		      if (stackmode == 0)	/* stack in interrupt mode: copy SP */
			registers[R15] = registers[SPI];
		    }
		  else if (regno == PSW)	/* stack mode may have changed! */
		    {		/* force SP to either SPU or SPI */
		      if (stackmode == 0)	/* stack in user mode */
			registers[R15] = registers[SPI];
		      else	/* stack in interrupt mode */
			registers[R15] = registers[SPU];
		    }
		  strcpy (remcomOutBuffer, "OK");
		  break;
		}
	    strcpy (remcomOutBuffer, "E01");
	    break;
a491 10
	case 'G':		/* set the value of the CPU registers - return OK */
	  hex2mem (ptr, (unsigned char *) registers, NUMREGBYTES, 0);
	  strcpy (remcomOutBuffer, "OK");
	  break;
	case 's':		/* sAA..AA      Step one instruction from AA..AA(optional) */
	  stepping = 1;
	case 'c':		/* cAA..AA      Continue from address AA..AA(optional) */
	  /* try to read optional parameter, pc unchanged if no parm */
	  if (hexToInt (&ptr, &addr))
	    registers[PC] = addr;
d493 1
a493 31
	  if (stepping)		/* single-stepping */
	    {
	      if (!prepare_to_step (0))	/* set up for single-step */
		{
		  /* prepare_to_step has already emulated the target insn:
		     Send SIGTRAP to gdb, don't resume the target at all.  */
		  ptr = remcomOutBuffer;
		  *ptr++ = 'T';	/* Simulate stopping with SIGTRAP */
		  *ptr++ = '0';
		  *ptr++ = '5';

		  *ptr++ = hexchars[PC >> 4];	/* send PC */
		  *ptr++ = hexchars[PC & 0xf];
		  *ptr++ = ':';
		  ptr = mem2hex ((unsigned char *) &registers[PC], ptr, 4, 0);
		  *ptr++ = ';';

		  *ptr++ = hexchars[R13 >> 4];	/* send FP */
		  *ptr++ = hexchars[R13 & 0xf];
		  *ptr++ = ':';
		  ptr =
		    mem2hex ((unsigned char *) &registers[R13], ptr, 4, 0);
		  *ptr++ = ';';

		  *ptr++ = hexchars[R15 >> 4];	/* send SP */
		  *ptr++ = hexchars[R15 & 0xf];
		  *ptr++ = ':';
		  ptr =
		    mem2hex ((unsigned char *) &registers[R15], ptr, 4, 0);
		  *ptr++ = ';';
		  *ptr++ = 0;
d495 1
a495 16
		  break;
		}
	    }
	  else			/* continuing, not single-stepping */
	    {
	      /* OK, about to do a "continue".  First check to see if the 
	         target pc is on an odd boundary (second instruction in the 
	         word).  If so, we must do a single-step first, because 
	         ya can't jump or return back to an odd boundary!  */
	      if ((registers[PC] & 2) != 0)
		prepare_to_step (1);
	    }

	  return;

	case 'D':		/* Detach */
d497 8
a504 8
	  /* I am interpreting this to mean, release the board from control 
	     by the remote stub.  To do this, I am restoring the original
	     (or at least previous) exception vectors.
	   */
	  for (i = 0; i < 18; i++)
	    exceptionHandler (i, save_vectors[i]);
	  putpacket ("OK");
	  return;		/* continue the inferior */
d506 2
a507 2
	  strcpy (remcomOutBuffer, "OK");
	  break;
d509 11
a519 3
	case 'q':
	  if (*ptr++ == 'C' &&
	      *ptr++ == 'R' && *ptr++ == 'C' && *ptr++ == ':')
d521 17
a537 20
	      unsigned long start, len, our_crc;

	      if (hexToInt (&ptr, (int *) &start) &&
		  *ptr++ == ',' && hexToInt (&ptr, (int *) &len))
		{
		  remcomOutBuffer[0] = 'C';
		  our_crc = crc32 ((unsigned char *) start, len, 0xffffffff);
		  mem2hex ((char *) &our_crc,
			   &remcomOutBuffer[1], sizeof (long), 0);
		}		/* else do nothing */
	    }			/* else do nothing */
	  break;

	case 'k':		/* kill the program */
	  continue;
	}			/* switch */

      /* reply to the request */
      putpacket (remcomOutBuffer);
    }
d543 1
a543 1
static unsigned long crc32_table[256] = { 0, 0 };
d548 1
a548 1
  if (!crc32_table[1])
d570 1
a570 1
static int
d573 3
a575 6
  if ((ch >= 'a') && (ch <= 'f'))
    return (ch - 'a' + 10);
  if ((ch >= '0') && (ch <= '9'))
    return (ch - '0');
  if ((ch >= 'A') && (ch <= 'F'))
    return (ch - 'A' + 10);
d596 1
a596 1
    retry:
d605 1
a605 1
	  if (ch == '$')
d628 5
a632 5
		  mem2hex ((unsigned char *) &checksum, buf, 4, 0);
		  gdb_error ("Bad checksum: my count = %s, ", buf);
		  mem2hex ((unsigned char *) &xmitcsum, buf, 4, 0);
		  gdb_error ("sent count = %s\n", buf);
		  gdb_error (" -- Bad buffer: \"%s\"\n", buffer);
d657 1
a657 1
static void
d661 1
a661 1
  int count;
d665 14
a678 17
  do
    {
      putDebugChar ('$');
      checksum = 0;
      count = 0;

      while (ch = buffer[count])
	{
	  putDebugChar (ch);
	  checksum += ch;
	  count += 1;
	}
      putDebugChar ('#');
      putDebugChar (hexchars[checksum >> 4]);
      putDebugChar (hexchars[checksum % 16]);
    }
  while (getDebugChar () != '+');
d683 1
a683 1
static void (*volatile mem_fault_routine) () = 0;
d704 4
a707 8
  if (addr < BAD_RANGE_ONE_START)
    return 1;			/* safe */
  if (addr < BAD_RANGE_ONE_END)
    return 0;			/* unsafe */
  if (addr < BAD_RANGE_TWO_START)
    return 1;			/* safe */
  if (addr < BAD_RANGE_TWO_END)
    return 0;			/* unsafe */
d718 1
a718 1
  if (mem_fault_routine && !mem_safe (addr))
d753 7
a759 8
  for (i = 0; i < count; i++)
    {
      ch = get_char (mem++);
      if (may_fault && mem_err)
	return (buf);
      *buf++ = hexchars[ch >> 4];
      *buf++ = hexchars[ch % 16];
    }
d763 1
a763 1
  return (buf);
d769 1
a769 1
static unsigned char *
d777 7
a783 8
  for (i = 0; i < count; i++)
    {
      ch = hex (*buf++) << 4;
      ch = ch + hex (*buf++);
      set_char (mem++, ch);
      if (may_fault && mem_err)
	return (mem);
    }
d786 1
a786 1
  return (mem);
d807 14
a820 14
	{
	  switch (*(buf + 1))
	    {
	    case 0x3:		/* # */
	    case 0x4:		/* $ */
	    case 0x5d:		/* escape char */
	      buf++;
	      *buf |= 0x20;
	      break;
	    default:
	      /* nothing */
	      break;
	    }
	}
d825 1
a825 1
	return mem;
d836 1
a836 1
static int
d840 21
a860 60
  switch (exceptionVector)
    {
    case 0:
      sigval = 23;
      break;			/* I/O trap                    */
    case 1:
      sigval = 5;
      break;			/* breakpoint                  */
    case 2:
      sigval = 5;
      break;			/* breakpoint                  */
    case 3:
      sigval = 5;
      break;			/* breakpoint                  */
    case 4:
      sigval = 5;
      break;			/* breakpoint                  */
    case 5:
      sigval = 5;
      break;			/* breakpoint                  */
    case 6:
      sigval = 5;
      break;			/* breakpoint                  */
    case 7:
      sigval = 5;
      break;			/* breakpoint                  */
    case 8:
      sigval = 5;
      break;			/* breakpoint                  */
    case 9:
      sigval = 5;
      break;			/* breakpoint                  */
    case 10:
      sigval = 5;
      break;			/* breakpoint                  */
    case 11:
      sigval = 5;
      break;			/* breakpoint                  */
    case 12:
      sigval = 5;
      break;			/* breakpoint                  */
    case 13:
      sigval = 5;
      break;			/* breakpoint                  */
    case 14:
      sigval = 5;
      break;			/* breakpoint                  */
    case 15:
      sigval = 5;
      break;			/* breakpoint                  */
    case 16:
      sigval = 10;
      break;			/* BUS ERROR (alignment)       */
    case 17:
      sigval = 2;
      break;			/* INTerrupt                   */
    default:
      sigval = 7;
      break;			/* "software generated"        */
    }
d868 1
a868 1
static int
d877 6
a882 6
      hexValue = hex (**ptr);
      if (hexValue >= 0)
	{
	  *intValue = (*intValue << 4) | hexValue;
	  numChars++;
	}
d914 1
a914 1
static int
d917 1
a917 1
  unsigned char instr0 = instr[0] & 0x7F;	/* mask off high bit */
d920 1
a920 1
    return 1;			/* return from trap or exception */
d922 1
a922 1
  if (instr0 == 0x1E || instr0 == 0x1F)	/* JL or JMP */
d924 1
a924 1
      return 2;			/* jump thru a register */
d926 1
a926 1
  if (instr0 == 0x7C || instr0 == 0x7D ||	/* BC, BNC, BL, BRA */
d928 1
a928 1
    return 3;			/* eight bit PC offset */
d939 1
a939 1
  if ((instr[0] & 0xF0) == 0xB0)	/* 16 bit relative */
d941 1
a941 1
      if ((instr[1] & 0xF0) == 0x00 ||	/* BNE, BEQ */
d945 1
a945 1
	if ((instr[1] & 0xF0) == 0x80 || (instr[1] & 0xF0) == 0x90 ||
d962 2
a963 2
  if (INSTRUCTION_SIZE (instr) == 2)
    return isShortBranch (instr);
d965 1
a965 1
    return isLongBranch (instr);
d971 1
a971 1
  switch (branchCode)
d973 3
a975 6
    case 0:
      return 0;			/* not a branch */
    case 1:
      return 1;			/* RTE */
    case 2:
      return 1;			/* JL or JMP    */
d978 1
a978 1
      switch (instr[0] & 0x0F)
d990 2
a991 2
    case 5:			/* BNE, BEQ */
      switch (instr[1] & 0xF0)
d1000 2
a1001 2
    case 6:			/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ */
      switch (instr[1] & 0xF0)
d1023 1
a1023 1
static int
d1025 18
a1042 20
{
  switch (branchCode)
    {
    default:
    case 0:			/* not a branch */
      return 0;
    case 1:			/* RTE */
      return registers[BPC] & ~3;	/* pop BPC into PC */
    case 2:			/* JL or JMP */
      return registers[instr[1] & 0x0F] & ~3;	/* jump thru a register */
    case 3:			/* BC, BNC, BL, BRA (short, 8-bit relative offset) */
      return (((int) instr) & ~3) + ((char) instr[1] << 2);
    case 4:			/* BC, BNC, BL, BRA (long, 24-bit relative offset) */
      return ((int) instr +
	      ((((char) instr[1] << 16) | (instr[2] << 8) | (instr[3])) <<
	       2));
    case 5:			/* BNE, BEQ (16-bit relative offset) */
    case 6:			/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ (ditto) */
      return ((int) instr + ((((char) instr[2] << 8) | (instr[3])) << 2));
    }
d1064 1
a1064 1
      if ((instr[0] & 0x0F) == 0x0E)	/* branch/jump and link */
d1072 1
a1072 2
static struct STEPPING_CONTEXT
{
d1074 5
a1078 5
  unsigned long target_addr;	/* the instr we're trying to execute */
  unsigned long target_size;	/* the size of the target instr */
  unsigned long noop_addr;	/* where we've inserted a no-op, if any */
  unsigned long trap1_addr;	/* the trap following the target instr */
  unsigned long trap2_addr;	/* the trap at a branch destination, if any */
d1096 2
a1097 2
#define TRAP1  0x10f1;		/* trap #1 instruction */
#define NOOP   0x7000;		/* noop    instruction */
d1100 1
a1100 1
static unsigned short noop = NOOP;
d1103 2
a1104 2
prepare_to_step (continue_p)
     int continue_p;		/* if this isn't REALLY a single-step (see below) */
d1107 1
a1107 1
  int branchCode = isBranch ((unsigned char *) pc);
d1113 2
a1114 1
       p < ((unsigned char *) &stepping) + sizeof (stepping); p++)
d1117 1
a1117 1
  if (branchCode != 0)		/* next instruction is a branch */
d1119 3
a1121 3
      branchSideEffects ((unsigned char *) pc, branchCode);
      if (willBranch ((unsigned char *) pc, branchCode))
	registers[PC] = branchDestination ((unsigned char *) pc, branchCode);
d1123 1
a1123 1
	registers[PC] = pc + INSTRUCTION_SIZE (pc);
d1126 1
a1126 1
  else if (((int) pc & 2) != 0)	/* "second-slot" instruction */
d1129 3
a1131 3
      stepping.noop_addr = pc - 2;
      stepping.noop_save = *(unsigned short *) stepping.noop_addr;
      *(unsigned short *) stepping.noop_addr = noop;
d1133 1
a1133 1
      stepping.trap1_addr = pc + 2;
d1137 1
a1137 1
  else				/* "first-slot" instruction */
d1140 1
a1140 1
      stepping.trap1_addr = pc + INSTRUCTION_SIZE (pc);
d1149 1
a1149 1
  stepping.stepping = 1;	/* starting a single-step */
d1173 1
a1173 1
	*(unsigned short *) stepping.noop_addr = stepping.noop_save;
d1176 1
a1176 1
      if (stepping.trap2_addr)	/* ditto our other trap, if any    */
d1180 2
a1181 1
	   p < ((unsigned char *) &stepping) + sizeof (stepping); p++)
d1186 1
a1186 1
  else				/* we didn't single-step, therefore this must be a legitimate stop */
d1190 10
a1199 11
struct PSWreg
{				/* separate out the bit flags in the PSW register */
  int pad1:16;
  int bsm:1;
  int bie:1;
  int pad2:5;
  int bc:1;
  int sm:1;
  int ie:1;
  int pad3:5;
  int c:1;
d1207 41
a1247 41
asm ("\n\
stash_registers:\n\
	push r0\n\
	push r1\n\
	seth r1, #shigh(registers)\n\
	add3 r1, r1, #low(registers)\n\
	pop r0		; r1\n\
	st r0, @@(4,r1)\n\
	pop r0		; r0\n\
	st r0, @@r1\n\
	addi r1, #4	; only add 4 as subsequent saves are `pre inc'\n\
	st r2, @@+r1\n\
	st r3, @@+r1\n\
	st r4, @@+r1\n\
	st r5, @@+r1\n\
	st r6, @@+r1\n\
	st r7, @@+r1\n\
	st r8, @@+r1\n\
	st r9, @@+r1\n\
	st r10, @@+r1\n\
	st r11, @@+r1\n\
	st r12, @@+r1\n\
	st r13, @@+r1    ; fp\n\
	pop r0		; lr (r14)\n\
	st r0, @@+r1\n\
	st sp, @@+r1	; sp contains right value at this point\n\
	mvfc r0, cr0\n\
	st r0, @@+r1	; cr0 == PSW\n\
	mvfc r0, cr1\n\
	st r0, @@+r1	; cr1 == CBR\n\
	mvfc r0, cr2\n\
	st r0, @@+r1	; cr2 == SPI\n\
	mvfc r0, cr3\n\
	st r0, @@+r1	; cr3 == SPU\n\
	mvfc r0, cr6\n\
	st r0, @@+r1	; cr6 == BPC\n\
	st r0, @@+r1	; PC  == BPC\n\
	mvfaclo r0\n\
	st r0, @@+r1	; ACCL\n\
	mvfachi r0\n\
	st r0, @@+r1	; ACCH\n\
d1261 2
a1262 2
  psw->c = psw->bc;
  registers[CBR] = psw->bc;	/* fix up pre-trap "C" register */
d1264 3
a1266 3
#if 0				/* FIXME: Was in previous version.  Necessary?
				   (Remember that we use the "rte" insn to return from the
				   trap/interrupt so the values of bsm, bie, bc are important.  */
d1281 36
a1316 37
asm ("\n\
restore_and_return:\n\
	seth r0, #shigh(registers+8)\n\
	add3 r0, r0, #low(registers+8)\n\
	ld r2, @@r0+	; restore r2\n\
	ld r3, @@r0+	; restore r3\n\
	ld r4, @@r0+	; restore r4\n\
	ld r5, @@r0+	; restore r5\n\
	ld r6, @@r0+	; restore r6\n\
	ld r7, @@r0+	; restore r7\n\
	ld r8, @@r0+	; restore r8\n\
	ld r9, @@r0+	; restore r9\n\
	ld r10, @@r0+	; restore r10\n\
	ld r11, @@r0+	; restore r11\n\
	ld r12, @@r0+	; restore r12\n\
	ld r13, @@r0+	; restore r13\n\
	ld r14, @@r0+	; restore r14\n\
	ld r15, @@r0+	; restore r15\n\
	ld r1, @@r0+	; restore cr0 == PSW\n\
	mvtc r1, cr0\n\
	ld r1, @@r0+	; restore cr1 == CBR (no-op, because it's read only)\n\
	mvtc r1, cr1\n\
	ld r1, @@r0+	; restore cr2 == SPI\n\
	mvtc r1, cr2\n\
	ld r1, @@r0+	; restore cr3 == SPU\n\
	mvtc r1, cr3\n\
	addi r0, #4	; skip BPC\n\
	ld r1, @@r0+	; restore cr6 (BPC) == PC\n\
	mvtc r1, cr6\n\
	ld r1, @@r0+	; restore ACCL\n\
	mvtaclo r1\n\
	ld r1, @@r0+	; restore ACCH\n\
	mvtachi r1\n\
	seth r0, #shigh(registers)\n\
	add3 r0, r0, #low(registers)\n\
	ld r1, @@(4,r0)	; restore r1\n\
	ld r0, @@r0	; restore r0\n\
d1326 8
a1333 7
  asm volatile ("\n\
	seth r1, #shigh(stackPtr)\n\
	add3 r1, r1, #low(stackPtr)\n\
	ld r15, @@r1		; setup local stack (protect user stack)\n\
	mv r0, %0\n\
	bl handle_exception\n\
	bl restore_and_return"::"r" (num):"r0", "r1");
d1338 6
a1343 6
asm ("\n\
_catchException0:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #0\n\
d1348 16
a1363 16
asm ("\n\
_catchException1:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	bl cleanup_stash\n\
	seth r1, #shigh(stackPtr)\n\
	add3 r1, r1, #low(stackPtr)\n\
	ld r15, @@r1		; setup local stack (protect user stack)\n\
	seth r1, #shigh(registers + 21*4) ; PC\n\
	add3 r1, r1, #low(registers + 21*4)\n\
	ld r0, @@r1\n\
	addi r0, #-4		; back up PC for breakpoint trap.\n\
	st r0, @@r1		; FIXME: what about bp in right slot?\n\
	ldi r0, #1\n\
	bl handle_exception\n\
d1368 6
a1373 6
asm ("\n\
_catchException2:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #2\n\
d1378 6
a1383 6
asm ("\n\
_catchException3:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #3\n\
d1388 6
a1393 6
asm ("\n\
_catchException4:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #4\n\
d1398 6
a1403 6
asm ("\n\
_catchException5:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #5\n\
d1408 6
a1413 6
asm ("\n\
_catchException6:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #6\n\
d1418 6
a1423 6
asm ("\n\
_catchException7:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #7\n\
d1428 6
a1433 6
asm ("\n\
_catchException8:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #8\n\
d1438 6
a1443 6
asm ("\n\
_catchException9:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #9\n\
d1448 6
a1453 6
asm ("\n\
_catchException10:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #10\n\
d1458 6
a1463 6
asm ("\n\
_catchException11:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #11\n\
d1468 6
a1473 6
asm ("\n\
_catchException12:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #12\n\
d1478 6
a1483 6
asm ("\n\
_catchException13:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #13\n\
d1488 6
a1493 6
asm ("\n\
_catchException14:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #14\n\
d1498 6
a1503 6
asm ("\n\
_catchException15:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #15\n\
d1508 6
a1513 6
asm ("\n\
_catchException16:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #16\n\
d1518 6
a1523 6
asm ("\n\
_catchException17:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #17\n\
d1529 1
a1529 1
void
d1535 2
a1536 2
  for (i = 0; i < 18; i++)	/* keep a copy of old vectors */
    if (save_vectors[i] == 0)	/* only copy them the first time */
d1539 1
a1539 1
  stackPtr = &remcomStack[STACKSIZE / sizeof (int) - 1];
d1570 1
a1570 1
void
d1574 1
a1574 1
    BREAKPOINT ();
d1584 1
a1584 1

d1588 1
a1588 1

d1593 1
a1593 1

d1598 1
a1598 1
  putpacket (buf);
d1601 1
a1601 1

d1605 1
a1605 1

d1611 1
a1611 1

d1617 3
a1619 2
      for (cpy = buf + 1;
	   i < len && cpy < buf + sizeof (remcomOutBuffer) - 3; i++)
d1625 1
a1625 1
      putpacket (buf);
d1633 1
a1633 1

d1637 1
a1637 1
  return gdb_write (str, strlen (str));
d1639 1
a1639 1

d1644 1
a1644 1

d1650 1
a1650 1

d1654 1
a1654 1
	len = strlen (format);
d1656 1
a1656 1
	return;			/* empty input */
d1659 3
a1661 3
	len += strlen (parm);

      for (cpy = buf; *format;)
d1663 1
a1663 1
	  if (format[0] == '%' && format[1] == 's')	/* include second string */
d1665 1
a1665 1
	      format += 2;	/* advance two chars instead of just one */
d1673 1
a1673 1
      gdb_puts (buf);
d1676 1
a1676 1

d1703 1
a1703 2
void
exit (code)
d1709 1
a1709 2
int
atexit (void *p)
d1714 1
a1714 2
void
abort (void)
@


1.4
log
@2002-09-17  Michael Snyder  <msnyder@@redhat.com>

	* mips-stub.c (restore_and_return): Postpone restoring of PSW.
        RTE will take care of it.
@
text
@d213 10
a222 2
  if (!finish_from_step())
    return;		/* "false step": let the target continue */
@


1.4.2.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d213 2
a214 10
  /* Do not call finish_from_step() if this is not a trap #1
   * (breakpoint trap).  Without this check, the finish_from_step()
   * might interpret a system call trap as a single step trap.  This
   * can happen if: the stub receives 's' and exits, but an interrupt
   * was pending; the interrupt is now handled and causes the stub to
   * be reentered because some function makes a system call.  
   */
  if (exceptionVector == 1)	/* Trap exception? */
    if (!finish_from_step())	/* Go see if stepping state needs update. */
      return;		/* "false step": let the target continue */
@


1.4.2.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d1 1718
a1718 1718
// OBSOLETE /****************************************************************************
// OBSOLETE 
// OBSOLETE 		THIS SOFTWARE IS NOT COPYRIGHTED
// OBSOLETE 
// OBSOLETE    HP offers the following for use in the public domain.  HP makes no
// OBSOLETE    warranty with regard to the software or it's performance and the
// OBSOLETE    user accepts the software "AS IS" with all faults.
// OBSOLETE 
// OBSOLETE    HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD
// OBSOLETE    TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OBSOLETE    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
// OBSOLETE 
// OBSOLETE ****************************************************************************/
// OBSOLETE 
// OBSOLETE /****************************************************************************
// OBSOLETE  *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $
// OBSOLETE  *
// OBSOLETE  *  Module name: remcom.c $
// OBSOLETE  *  Revision: 1.34 $
// OBSOLETE  *  Date: 91/03/09 12:29:49 $
// OBSOLETE  *  Contributor:     Lake Stevens Instrument Division$
// OBSOLETE  *
// OBSOLETE  *  Description:     low level support for gdb debugger. $
// OBSOLETE  *
// OBSOLETE  *  Considerations:  only works on target hardware $
// OBSOLETE  *
// OBSOLETE  *  Written by:      Glenn Engel $
// OBSOLETE  *  ModuleState:     Experimental $
// OBSOLETE  *
// OBSOLETE  *  NOTES:           See Below $
// OBSOLETE  *
// OBSOLETE  *  Modified for M32R by Michael Snyder, Cygnus Support.
// OBSOLETE  *
// OBSOLETE  *  To enable debugger support, two things need to happen.  One, a
// OBSOLETE  *  call to set_debug_traps() is necessary in order to allow any breakpoints
// OBSOLETE  *  or error conditions to be properly intercepted and reported to gdb.
// OBSOLETE  *  Two, a breakpoint needs to be generated to begin communication.  This
// OBSOLETE  *  is most easily accomplished by a call to breakpoint().  Breakpoint()
// OBSOLETE  *  simulates a breakpoint by executing a trap #1.
// OBSOLETE  *
// OBSOLETE  *  The external function exceptionHandler() is
// OBSOLETE  *  used to attach a specific handler to a specific M32R vector number.
// OBSOLETE  *  It should use the same privilege level it runs at.  It should
// OBSOLETE  *  install it as an interrupt gate so that interrupts are masked
// OBSOLETE  *  while the handler runs.
// OBSOLETE  *
// OBSOLETE  *  Because gdb will sometimes write to the stack area to execute function
// OBSOLETE  *  calls, this program cannot rely on using the supervisor stack so it
// OBSOLETE  *  uses it's own stack area reserved in the int array remcomStack.
// OBSOLETE  *
// OBSOLETE  *************
// OBSOLETE  *
// OBSOLETE  *    The following gdb commands are supported:
// OBSOLETE  *
// OBSOLETE  * command          function                               Return value
// OBSOLETE  *
// OBSOLETE  *    g             return the value of the CPU registers  hex data or ENN
// OBSOLETE  *    G             set the value of the CPU registers     OK or ENN
// OBSOLETE  *
// OBSOLETE  *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN
// OBSOLETE  *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN
// OBSOLETE  *    XAA..AA,LLLL: Write LLLL binary bytes at address     OK or ENN
// OBSOLETE  *                  AA..AA
// OBSOLETE  *
// OBSOLETE  *    c             Resume at current address              SNN   ( signal NN)
// OBSOLETE  *    cAA..AA       Continue at address AA..AA             SNN
// OBSOLETE  *
// OBSOLETE  *    s             Step one instruction                   SNN
// OBSOLETE  *    sAA..AA       Step one instruction from AA..AA       SNN
// OBSOLETE  *
// OBSOLETE  *    k             kill
// OBSOLETE  *
// OBSOLETE  *    ?             What was the last sigval ?             SNN   (signal NN)
// OBSOLETE  *
// OBSOLETE  * All commands and responses are sent with a packet which includes a
// OBSOLETE  * checksum.  A packet consists of
// OBSOLETE  *
// OBSOLETE  * $<packet info>#<checksum>.
// OBSOLETE  *
// OBSOLETE  * where
// OBSOLETE  * <packet info> :: <characters representing the command or response>
// OBSOLETE  * <checksum>    :: <two hex digits computed as modulo 256 sum of <packetinfo>>
// OBSOLETE  *
// OBSOLETE  * When a packet is received, it is first acknowledged with either '+' or '-'.
// OBSOLETE  * '+' indicates a successful transfer.  '-' indicates a failed transfer.
// OBSOLETE  *
// OBSOLETE  * Example:
// OBSOLETE  *
// OBSOLETE  * Host:                  Reply:
// OBSOLETE  * $m0,10#2a               +$00010203040506070809101112131415#42
// OBSOLETE  *
// OBSOLETE  ****************************************************************************/
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /************************************************************************
// OBSOLETE  *
// OBSOLETE  * external low-level support routines
// OBSOLETE  */
// OBSOLETE extern void putDebugChar();	/* write a single character      */
// OBSOLETE extern int getDebugChar();	/* read and return a single char */
// OBSOLETE extern void exceptionHandler();	/* assign an exception handler   */
// OBSOLETE 
// OBSOLETE /*****************************************************************************
// OBSOLETE  * BUFMAX defines the maximum number of characters in inbound/outbound buffers
// OBSOLETE  * at least NUMREGBYTES*2 are needed for register packets 
// OBSOLETE  */
// OBSOLETE #define BUFMAX 400
// OBSOLETE 
// OBSOLETE static char initialized;  /* boolean flag. != 0 means we've been initialized */
// OBSOLETE 
// OBSOLETE int     remote_debug;
// OBSOLETE /*  debug >  0 prints ill-formed commands in valid packets & checksum errors */
// OBSOLETE 
// OBSOLETE static const unsigned char hexchars[]="0123456789abcdef";
// OBSOLETE 
// OBSOLETE #define NUMREGS 24
// OBSOLETE 
// OBSOLETE /* Number of bytes of registers.  */
// OBSOLETE #define NUMREGBYTES (NUMREGS * 4)
// OBSOLETE enum regnames { R0,  R1,  R2,  R3,  R4,  R5,  R6,   R7,
// OBSOLETE 		R8,  R9,  R10, R11, R12, R13, R14,  R15,
// OBSOLETE 		PSW, CBR, SPI, SPU, BPC, PC,  ACCL, ACCH };
// OBSOLETE 
// OBSOLETE enum SYS_calls {
// OBSOLETE   	SYS_null, 
// OBSOLETE 	SYS_exit,
// OBSOLETE 	SYS_open,
// OBSOLETE 	SYS_close,
// OBSOLETE 	SYS_read,
// OBSOLETE 	SYS_write,
// OBSOLETE 	SYS_lseek,
// OBSOLETE 	SYS_unlink,
// OBSOLETE 	SYS_getpid,
// OBSOLETE 	SYS_kill,
// OBSOLETE 	SYS_fstat,
// OBSOLETE 	SYS_sbrk,
// OBSOLETE 	SYS_fork,
// OBSOLETE 	SYS_execve,
// OBSOLETE 	SYS_wait4,
// OBSOLETE 	SYS_link,
// OBSOLETE 	SYS_chdir,
// OBSOLETE 	SYS_stat,
// OBSOLETE 	SYS_utime,
// OBSOLETE 	SYS_chown,
// OBSOLETE 	SYS_chmod,
// OBSOLETE 	SYS_time,
// OBSOLETE 	SYS_pipe };
// OBSOLETE 
// OBSOLETE static int registers[NUMREGS];
// OBSOLETE 
// OBSOLETE #define STACKSIZE 8096
// OBSOLETE static unsigned char remcomInBuffer[BUFMAX];
// OBSOLETE static unsigned char remcomOutBuffer[BUFMAX];
// OBSOLETE static int  remcomStack[STACKSIZE/sizeof(int)];
// OBSOLETE static int*  stackPtr = &remcomStack[STACKSIZE/sizeof(int) - 1];
// OBSOLETE 
// OBSOLETE static unsigned int save_vectors[18];	/* previous exception vectors */
// OBSOLETE 
// OBSOLETE /* Indicate to caller of mem2hex or hex2mem that there has been an error. */
// OBSOLETE static volatile int mem_err = 0;
// OBSOLETE 
// OBSOLETE /* Store the vector number here (since GDB only gets the signal
// OBSOLETE    number through the usual means, and that's not very specific).  */
// OBSOLETE int gdb_m32r_vector = -1;
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE #include "syscall.h" /* for SYS_exit, SYS_write etc. */
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /* Global entry points:
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE extern void handle_exception(int);
// OBSOLETE extern void set_debug_traps(void);
// OBSOLETE extern void breakpoint(void);
// OBSOLETE 
// OBSOLETE /* Local functions:
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static int  computeSignal(int);
// OBSOLETE static void putpacket(unsigned char *);
// OBSOLETE static unsigned char *getpacket(void);
// OBSOLETE 
// OBSOLETE static unsigned char *mem2hex(unsigned char *, unsigned char *, int, int);
// OBSOLETE static unsigned char *hex2mem(unsigned char *, unsigned char *, int, int);
// OBSOLETE static int  hexToInt(unsigned char **, int *);
// OBSOLETE static unsigned char *bin2mem(unsigned char *, unsigned char *, int, int);
// OBSOLETE static void stash_registers(void);
// OBSOLETE static void restore_registers(void);
// OBSOLETE static int  prepare_to_step(int);
// OBSOLETE static int  finish_from_step(void);
// OBSOLETE static unsigned long crc32 (unsigned char *, int, unsigned long);
// OBSOLETE 
// OBSOLETE static void gdb_error(char *, char *);
// OBSOLETE static int  gdb_putchar(int), gdb_puts(char *), gdb_write(char *, int);
// OBSOLETE 
// OBSOLETE static unsigned char *strcpy (unsigned char *, const unsigned char *);
// OBSOLETE static int   strlen (const unsigned char *);
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * This function does all command procesing for interfacing to gdb.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE void 
// OBSOLETE handle_exception(int exceptionVector)
// OBSOLETE {
// OBSOLETE   int    sigval, stepping;
// OBSOLETE   int    addr, length, i;
// OBSOLETE   unsigned char * ptr;
// OBSOLETE   unsigned char   buf[16];
// OBSOLETE   int binary;
// OBSOLETE 
// OBSOLETE   /* Do not call finish_from_step() if this is not a trap #1
// OBSOLETE    * (breakpoint trap).  Without this check, the finish_from_step()
// OBSOLETE    * might interpret a system call trap as a single step trap.  This
// OBSOLETE    * can happen if: the stub receives 's' and exits, but an interrupt
// OBSOLETE    * was pending; the interrupt is now handled and causes the stub to
// OBSOLETE    * be reentered because some function makes a system call.  
// OBSOLETE    */
// OBSOLETE   if (exceptionVector == 1)	/* Trap exception? */
// OBSOLETE     if (!finish_from_step())	/* Go see if stepping state needs update. */
// OBSOLETE       return;		/* "false step": let the target continue */
// OBSOLETE 
// OBSOLETE   gdb_m32r_vector = exceptionVector;
// OBSOLETE 
// OBSOLETE   if (remote_debug)
// OBSOLETE     {
// OBSOLETE       mem2hex((unsigned char *) &exceptionVector, buf, 4, 0);
// OBSOLETE       gdb_error("Handle exception %s, ", buf);
// OBSOLETE       mem2hex((unsigned char *) &registers[PC], buf, 4, 0);
// OBSOLETE       gdb_error("PC == 0x%s\n", buf);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* reply to host that an exception has occurred */
// OBSOLETE   sigval = computeSignal( exceptionVector );
// OBSOLETE 
// OBSOLETE   ptr = remcomOutBuffer;
// OBSOLETE  
// OBSOLETE   *ptr++ = 'T';         /* notify gdb with signo, PC, FP and SP */
// OBSOLETE   *ptr++ = hexchars[sigval >> 4];
// OBSOLETE   *ptr++ = hexchars[sigval & 0xf];
// OBSOLETE  
// OBSOLETE   *ptr++ = hexchars[PC >> 4];
// OBSOLETE   *ptr++ = hexchars[PC & 0xf];
// OBSOLETE   *ptr++ = ':';
// OBSOLETE   ptr = mem2hex((unsigned char *)&registers[PC], ptr, 4, 0);     /* PC */
// OBSOLETE   *ptr++ = ';';
// OBSOLETE  
// OBSOLETE   *ptr++ = hexchars[R13 >> 4];
// OBSOLETE   *ptr++ = hexchars[R13 & 0xf];
// OBSOLETE   *ptr++ = ':';
// OBSOLETE   ptr = mem2hex((unsigned char *)&registers[R13], ptr, 4, 0);    /* FP */
// OBSOLETE   *ptr++ = ';';
// OBSOLETE  
// OBSOLETE   *ptr++ = hexchars[R15 >> 4];
// OBSOLETE   *ptr++ = hexchars[R15 & 0xf];
// OBSOLETE   *ptr++ = ':';
// OBSOLETE   ptr = mem2hex((unsigned char *)&registers[R15], ptr, 4, 0);    /* SP */
// OBSOLETE   *ptr++ = ';';
// OBSOLETE   *ptr++ = 0;
// OBSOLETE  
// OBSOLETE   if (exceptionVector == 0)     /* simulated SYS call stuff */
// OBSOLETE     {
// OBSOLETE       mem2hex((unsigned char *) &registers[PC], buf, 4, 0);
// OBSOLETE       switch (registers[R0]) {
// OBSOLETE       case SYS_exit:
// OBSOLETE 	gdb_error("Target program has exited at %s\n", buf);
// OBSOLETE 	ptr = remcomOutBuffer;
// OBSOLETE 	*ptr++ = 'W';
// OBSOLETE 	sigval = registers[R1] & 0xff;
// OBSOLETE 	*ptr++ = hexchars[sigval >> 4];
// OBSOLETE 	*ptr++ = hexchars[sigval & 0xf];
// OBSOLETE 	*ptr++ = 0;
// OBSOLETE 	break;
// OBSOLETE       case SYS_open:
// OBSOLETE 	gdb_error("Target attempts SYS_open call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_close:
// OBSOLETE 	gdb_error("Target attempts SYS_close call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_read:
// OBSOLETE 	gdb_error("Target attempts SYS_read call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_write:
// OBSOLETE 	if (registers[R1] == 1 ||       /* write to stdout  */
// OBSOLETE 	    registers[R1] == 2)		/* write to stderr  */
// OBSOLETE 	  {				/* (we can do that) */
// OBSOLETE 	    registers[R0] = gdb_write((void *) registers[R2], registers[R3]);
// OBSOLETE 	    return;
// OBSOLETE 	  }
// OBSOLETE 	else
// OBSOLETE 	  gdb_error("Target attempts SYS_write call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_lseek:
// OBSOLETE 	gdb_error("Target attempts SYS_lseek call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_unlink:
// OBSOLETE 	gdb_error("Target attempts SYS_unlink call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_getpid:
// OBSOLETE 	gdb_error("Target attempts SYS_getpid call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_kill:
// OBSOLETE 	gdb_error("Target attempts SYS_kill call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       case SYS_fstat:
// OBSOLETE 	gdb_error("Target attempts SYS_fstat call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       default:
// OBSOLETE 	gdb_error("Target attempts unknown SYS call at %s\n", buf);
// OBSOLETE 	break;
// OBSOLETE       }
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   putpacket(remcomOutBuffer);
// OBSOLETE 
// OBSOLETE   stepping = 0;
// OBSOLETE 
// OBSOLETE   while (1==1) {
// OBSOLETE     remcomOutBuffer[0] = 0;
// OBSOLETE     ptr = getpacket();
// OBSOLETE     binary = 0;
// OBSOLETE     switch (*ptr++) {
// OBSOLETE       default:	/* Unknown code.  Return an empty reply message. */
// OBSOLETE 	break;
// OBSOLETE       case 'R':
// OBSOLETE 	if (hexToInt (&ptr, &addr))
// OBSOLETE 	  registers[PC] = addr;
// OBSOLETE 	strcpy(remcomOutBuffer, "OK");
// OBSOLETE 	break;
// OBSOLETE       case '!':
// OBSOLETE 	strcpy(remcomOutBuffer, "OK");
// OBSOLETE 	break;
// OBSOLETE     case 'X': /* XAA..AA,LLLL:<binary data>#cs */
// OBSOLETE       binary = 1;
// OBSOLETE     case 'M': /* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
// OBSOLETE       /* TRY TO READ '%x,%x:'.  IF SUCCEED, SET PTR = 0 */
// OBSOLETE       {
// OBSOLETE         if (hexToInt(&ptr,&addr))
// OBSOLETE           if (*(ptr++) == ',')
// OBSOLETE             if (hexToInt(&ptr,&length))
// OBSOLETE               if (*(ptr++) == ':')
// OBSOLETE                 {
// OBSOLETE                   mem_err = 0;
// OBSOLETE                   if (binary)
// OBSOLETE                     bin2mem (ptr, (unsigned char *) addr, length, 1);
// OBSOLETE                   else
// OBSOLETE                     hex2mem(ptr, (unsigned char*) addr, length, 1);
// OBSOLETE                   if (mem_err) {
// OBSOLETE                     strcpy (remcomOutBuffer, "E03");
// OBSOLETE                     gdb_error ("memory fault", "");
// OBSOLETE                   } else {
// OBSOLETE                     strcpy(remcomOutBuffer,"OK");
// OBSOLETE                   }
// OBSOLETE                   ptr = 0;
// OBSOLETE                 }
// OBSOLETE         if (ptr)
// OBSOLETE           {
// OBSOLETE             strcpy(remcomOutBuffer,"E02");
// OBSOLETE           }
// OBSOLETE       }
// OBSOLETE 	break;
// OBSOLETE       case 'm': /* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
// OBSOLETE 		/* TRY TO READ %x,%x.  IF SUCCEED, SET PTR = 0 */
// OBSOLETE 	if (hexToInt(&ptr,&addr))
// OBSOLETE 	  if (*(ptr++) == ',')
// OBSOLETE 	    if (hexToInt(&ptr,&length))
// OBSOLETE 	      {
// OBSOLETE 		ptr = 0;
// OBSOLETE 		mem_err = 0;
// OBSOLETE 		mem2hex((unsigned char*) addr, remcomOutBuffer, length, 1);
// OBSOLETE 		if (mem_err) {
// OBSOLETE 		  strcpy (remcomOutBuffer, "E03");
// OBSOLETE 		  gdb_error ("memory fault", "");
// OBSOLETE 		}
// OBSOLETE 	      }
// OBSOLETE 	if (ptr)
// OBSOLETE 	  {
// OBSOLETE 	    strcpy(remcomOutBuffer,"E01");
// OBSOLETE 	  }
// OBSOLETE 	break;
// OBSOLETE       case '?': 
// OBSOLETE 	remcomOutBuffer[0] = 'S';
// OBSOLETE 	remcomOutBuffer[1] =  hexchars[sigval >> 4];
// OBSOLETE 	remcomOutBuffer[2] =  hexchars[sigval % 16];
// OBSOLETE 	remcomOutBuffer[3] = 0;
// OBSOLETE 	break;
// OBSOLETE       case 'd': 
// OBSOLETE 	remote_debug = !(remote_debug);  /* toggle debug flag */
// OBSOLETE 	break;
// OBSOLETE       case 'g': /* return the value of the CPU registers */
// OBSOLETE 	mem2hex((unsigned char*) registers, remcomOutBuffer, NUMREGBYTES, 0);
// OBSOLETE 	break;
// OBSOLETE       case 'P': /* set the value of a single CPU register - return OK */
// OBSOLETE 	{
// OBSOLETE 	  int regno;
// OBSOLETE 
// OBSOLETE 	  if (hexToInt (&ptr, &regno) && *ptr++ == '=')
// OBSOLETE 	    if (regno >= 0 && regno < NUMREGS)
// OBSOLETE 	      {
// OBSOLETE 		int stackmode;
// OBSOLETE 
// OBSOLETE 		hex2mem (ptr, (unsigned char *) &registers[regno], 4, 0);
// OBSOLETE 		/*
// OBSOLETE 		 * Since we just changed a single CPU register, let's
// OBSOLETE 		 * make sure to keep the several stack pointers consistant.
// OBSOLETE 		 */
// OBSOLETE 		stackmode = registers[PSW] & 0x80;
// OBSOLETE 		if (regno == R15)	/* stack pointer changed */
// OBSOLETE 		  {			/* need to change SPI or SPU */
// OBSOLETE 		    if (stackmode == 0)
// OBSOLETE 		      registers[SPI] = registers[R15];
// OBSOLETE 		    else
// OBSOLETE 		      registers[SPU] = registers[R15];
// OBSOLETE 		  }
// OBSOLETE 		else if (regno == SPU)	/* "user" stack pointer changed */
// OBSOLETE 		  {
// OBSOLETE 		    if (stackmode != 0)	/* stack in user mode: copy SP */
// OBSOLETE 		      registers[R15] = registers[SPU];
// OBSOLETE 		  }
// OBSOLETE 		else if (regno == SPI)	/* "interrupt" stack pointer changed */
// OBSOLETE 		  {
// OBSOLETE 		    if (stackmode == 0)	/* stack in interrupt mode: copy SP */
// OBSOLETE 		      registers[R15] = registers[SPI];
// OBSOLETE 		  }
// OBSOLETE 		else if (regno == PSW)	/* stack mode may have changed! */
// OBSOLETE 		  {			/* force SP to either SPU or SPI */
// OBSOLETE 		    if (stackmode == 0)	/* stack in user mode */
// OBSOLETE 		      registers[R15] = registers[SPI];
// OBSOLETE 		    else		/* stack in interrupt mode */
// OBSOLETE 		      registers[R15] = registers[SPU];
// OBSOLETE 		  }
// OBSOLETE 		strcpy (remcomOutBuffer, "OK");
// OBSOLETE 		break;
// OBSOLETE 	      }
// OBSOLETE 	  strcpy (remcomOutBuffer, "E01");
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       case 'G': /* set the value of the CPU registers - return OK */
// OBSOLETE 	hex2mem(ptr, (unsigned char*) registers, NUMREGBYTES, 0);
// OBSOLETE 	strcpy(remcomOutBuffer,"OK");
// OBSOLETE 	break;
// OBSOLETE       case 's': /* sAA..AA	Step one instruction from AA..AA(optional) */
// OBSOLETE 	stepping = 1;
// OBSOLETE       case 'c': /* cAA..AA	Continue from address AA..AA(optional) */
// OBSOLETE 		/* try to read optional parameter, pc unchanged if no parm */
// OBSOLETE 	if (hexToInt(&ptr,&addr))
// OBSOLETE 	  registers[ PC ] = addr;
// OBSOLETE 	
// OBSOLETE 	if (stepping)	/* single-stepping */
// OBSOLETE 	  {
// OBSOLETE 	    if (!prepare_to_step(0))	/* set up for single-step */
// OBSOLETE 	      {
// OBSOLETE 		/* prepare_to_step has already emulated the target insn:
// OBSOLETE 		   Send SIGTRAP to gdb, don't resume the target at all.  */
// OBSOLETE 		ptr = remcomOutBuffer;
// OBSOLETE 		*ptr++ = 'T';           /* Simulate stopping with SIGTRAP */
// OBSOLETE 		*ptr++ = '0';
// OBSOLETE 		*ptr++ = '5';
// OBSOLETE 
// OBSOLETE 		*ptr++ = hexchars[PC >> 4];     /* send PC */
// OBSOLETE 		*ptr++ = hexchars[PC & 0xf];
// OBSOLETE 		*ptr++ = ':';
// OBSOLETE 		ptr = mem2hex((unsigned char *)&registers[PC], ptr, 4, 0);
// OBSOLETE 		*ptr++ = ';';
// OBSOLETE 
// OBSOLETE 		*ptr++ = hexchars[R13 >> 4];    /* send FP */
// OBSOLETE 		*ptr++ = hexchars[R13 & 0xf];
// OBSOLETE 		*ptr++ = ':';
// OBSOLETE 		ptr = mem2hex((unsigned char *)&registers[R13], ptr, 4, 0);
// OBSOLETE 		*ptr++ = ';';
// OBSOLETE 
// OBSOLETE 		*ptr++ = hexchars[R15 >> 4];    /* send SP */
// OBSOLETE 		*ptr++ = hexchars[R15 & 0xf];
// OBSOLETE 		*ptr++ = ':';
// OBSOLETE 		ptr = mem2hex((unsigned char *)&registers[R15], ptr, 4, 0);
// OBSOLETE 		*ptr++ = ';';
// OBSOLETE 		*ptr++ = 0;
// OBSOLETE 
// OBSOLETE 		break;	
// OBSOLETE 	      }
// OBSOLETE 	  }
// OBSOLETE 	else	/* continuing, not single-stepping */
// OBSOLETE 	  {
// OBSOLETE 	    /* OK, about to do a "continue".  First check to see if the 
// OBSOLETE 	       target pc is on an odd boundary (second instruction in the 
// OBSOLETE 	       word).  If so, we must do a single-step first, because 
// OBSOLETE 	       ya can't jump or return back to an odd boundary!  */
// OBSOLETE 	    if ((registers[PC] & 2) != 0)
// OBSOLETE 	      prepare_to_step(1);
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE 	return;
// OBSOLETE 
// OBSOLETE       case 'D':	/* Detach */
// OBSOLETE #if 0
// OBSOLETE 	/* I am interpreting this to mean, release the board from control 
// OBSOLETE 	   by the remote stub.  To do this, I am restoring the original
// OBSOLETE 	   (or at least previous) exception vectors.
// OBSOLETE 	 */
// OBSOLETE 	for (i = 0; i < 18; i++)
// OBSOLETE 	  exceptionHandler (i, save_vectors[i]);
// OBSOLETE 	putpacket ("OK");
// OBSOLETE 	return;		/* continue the inferior */
// OBSOLETE #else
// OBSOLETE 	strcpy(remcomOutBuffer,"OK");
// OBSOLETE 	break;
// OBSOLETE #endif
// OBSOLETE     case 'q':
// OBSOLETE       if (*ptr++ == 'C' &&
// OBSOLETE 	  *ptr++ == 'R' &&
// OBSOLETE 	  *ptr++ == 'C' &&
// OBSOLETE 	  *ptr++ == ':')
// OBSOLETE 	{
// OBSOLETE 	  unsigned long start, len, our_crc;
// OBSOLETE 
// OBSOLETE 	  if (hexToInt (&ptr, (int *) &start) &&
// OBSOLETE 	      *ptr++ == ','                   &&
// OBSOLETE 	      hexToInt (&ptr, (int *) &len))
// OBSOLETE 	    {
// OBSOLETE 	      remcomOutBuffer[0] = 'C';
// OBSOLETE 	      our_crc = crc32 ((unsigned char *) start, len, 0xffffffff);
// OBSOLETE 	      mem2hex ((char *) &our_crc, 
// OBSOLETE 		       &remcomOutBuffer[1], 
// OBSOLETE 		       sizeof (long), 
// OBSOLETE 		       0); 
// OBSOLETE 	    } /* else do nothing */
// OBSOLETE 	} /* else do nothing */
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE       case 'k': /* kill the program */
// OBSOLETE 	continue;
// OBSOLETE       } /* switch */
// OBSOLETE 
// OBSOLETE     /* reply to the request */
// OBSOLETE     putpacket(remcomOutBuffer);
// OBSOLETE   }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* qCRC support */
// OBSOLETE 
// OBSOLETE /* Table used by the crc32 function to calcuate the checksum. */
// OBSOLETE static unsigned long crc32_table[256] = {0, 0};
// OBSOLETE 
// OBSOLETE static unsigned long
// OBSOLETE crc32 (unsigned char *buf, int len, unsigned long crc)
// OBSOLETE {
// OBSOLETE   if (! crc32_table[1])
// OBSOLETE     {
// OBSOLETE       /* Initialize the CRC table and the decoding table. */
// OBSOLETE       int i, j;
// OBSOLETE       unsigned long c;
// OBSOLETE 
// OBSOLETE       for (i = 0; i < 256; i++)
// OBSOLETE 	{
// OBSOLETE 	  for (c = i << 24, j = 8; j > 0; --j)
// OBSOLETE 	    c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : (c << 1);
// OBSOLETE 	  crc32_table[i] = c;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   while (len--)
// OBSOLETE     {
// OBSOLETE       crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ *buf) & 255];
// OBSOLETE       buf++;
// OBSOLETE     }
// OBSOLETE   return crc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int 
// OBSOLETE hex (unsigned char ch)
// OBSOLETE {
// OBSOLETE   if ((ch >= 'a') && (ch <= 'f')) return (ch-'a'+10);
// OBSOLETE   if ((ch >= '0') && (ch <= '9')) return (ch-'0');
// OBSOLETE   if ((ch >= 'A') && (ch <= 'F')) return (ch-'A'+10);
// OBSOLETE   return (-1);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* scan for the sequence $<data>#<checksum>     */
// OBSOLETE 
// OBSOLETE unsigned char *
// OBSOLETE getpacket (void)
// OBSOLETE {
// OBSOLETE   unsigned char *buffer = &remcomInBuffer[0];
// OBSOLETE   unsigned char checksum;
// OBSOLETE   unsigned char xmitcsum;
// OBSOLETE   int count;
// OBSOLETE   char ch;
// OBSOLETE 
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       /* wait around for the start character, ignore all other characters */
// OBSOLETE       while ((ch = getDebugChar ()) != '$')
// OBSOLETE 	;
// OBSOLETE 
// OBSOLETE retry:
// OBSOLETE       checksum = 0;
// OBSOLETE       xmitcsum = -1;
// OBSOLETE       count = 0;
// OBSOLETE 
// OBSOLETE       /* now, read until a # or end of buffer is found */
// OBSOLETE       while (count < BUFMAX)
// OBSOLETE 	{
// OBSOLETE 	  ch = getDebugChar ();
// OBSOLETE           if (ch == '$')
// OBSOLETE 	    goto retry;
// OBSOLETE 	  if (ch == '#')
// OBSOLETE 	    break;
// OBSOLETE 	  checksum = checksum + ch;
// OBSOLETE 	  buffer[count] = ch;
// OBSOLETE 	  count = count + 1;
// OBSOLETE 	}
// OBSOLETE       buffer[count] = 0;
// OBSOLETE 
// OBSOLETE       if (ch == '#')
// OBSOLETE 	{
// OBSOLETE 	  ch = getDebugChar ();
// OBSOLETE 	  xmitcsum = hex (ch) << 4;
// OBSOLETE 	  ch = getDebugChar ();
// OBSOLETE 	  xmitcsum += hex (ch);
// OBSOLETE 
// OBSOLETE 	  if (checksum != xmitcsum)
// OBSOLETE 	    {
// OBSOLETE 	      if (remote_debug)
// OBSOLETE 		{
// OBSOLETE 		  unsigned char buf[16];
// OBSOLETE 
// OBSOLETE 		  mem2hex((unsigned char *) &checksum, buf, 4, 0);
// OBSOLETE 		  gdb_error("Bad checksum: my count = %s, ", buf);
// OBSOLETE 		  mem2hex((unsigned char *) &xmitcsum, buf, 4, 0);
// OBSOLETE 		  gdb_error("sent count = %s\n", buf);
// OBSOLETE 		  gdb_error(" -- Bad buffer: \"%s\"\n", buffer); 
// OBSOLETE 		}
// OBSOLETE 	      putDebugChar ('-');	/* failed checksum */
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      putDebugChar ('+');	/* successful transfer */
// OBSOLETE 
// OBSOLETE 	      /* if a sequence char is present, reply the sequence ID */
// OBSOLETE 	      if (buffer[2] == ':')
// OBSOLETE 		{
// OBSOLETE 		  putDebugChar (buffer[0]);
// OBSOLETE 		  putDebugChar (buffer[1]);
// OBSOLETE 
// OBSOLETE 		  return &buffer[3];
// OBSOLETE 		}
// OBSOLETE 
// OBSOLETE 	      return &buffer[0];
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* send the packet in buffer.  */
// OBSOLETE 
// OBSOLETE static void 
// OBSOLETE putpacket (unsigned char *buffer)
// OBSOLETE {
// OBSOLETE   unsigned char checksum;
// OBSOLETE   int  count;
// OBSOLETE   char ch;
// OBSOLETE 
// OBSOLETE   /*  $<packet info>#<checksum>. */
// OBSOLETE   do {
// OBSOLETE     putDebugChar('$');
// OBSOLETE     checksum = 0;
// OBSOLETE     count    = 0;
// OBSOLETE 
// OBSOLETE     while (ch=buffer[count]) {
// OBSOLETE       putDebugChar(ch);
// OBSOLETE       checksum += ch;
// OBSOLETE       count += 1;
// OBSOLETE     }
// OBSOLETE     putDebugChar('#');
// OBSOLETE     putDebugChar(hexchars[checksum >> 4]);
// OBSOLETE     putDebugChar(hexchars[checksum % 16]);
// OBSOLETE   } while (getDebugChar() != '+');
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Address of a routine to RTE to if we get a memory fault.  */
// OBSOLETE 
// OBSOLETE static void (*volatile mem_fault_routine)() = 0;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE set_mem_err (void)
// OBSOLETE {
// OBSOLETE   mem_err = 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Check the address for safe access ranges.  As currently defined,
// OBSOLETE    this routine will reject the "expansion bus" address range(s).
// OBSOLETE    To make those ranges useable, someone must implement code to detect
// OBSOLETE    whether there's anything connected to the expansion bus. */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE mem_safe (unsigned char *addr)
// OBSOLETE {
// OBSOLETE #define BAD_RANGE_ONE_START	((unsigned char *) 0x600000)
// OBSOLETE #define BAD_RANGE_ONE_END	((unsigned char *) 0xa00000)
// OBSOLETE #define BAD_RANGE_TWO_START	((unsigned char *) 0xff680000)
// OBSOLETE #define BAD_RANGE_TWO_END	((unsigned char *) 0xff800000)
// OBSOLETE 
// OBSOLETE   if (addr < BAD_RANGE_ONE_START)	return 1;	/* safe */
// OBSOLETE   if (addr < BAD_RANGE_ONE_END)		return 0;	/* unsafe */
// OBSOLETE   if (addr < BAD_RANGE_TWO_START)	return 1;	/* safe */
// OBSOLETE   if (addr < BAD_RANGE_TWO_END)		return 0;	/* unsafe */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* These are separate functions so that they are so short and sweet
// OBSOLETE    that the compiler won't save any registers (if there is a fault
// OBSOLETE    to mem_fault, they won't get restored, so there better not be any
// OBSOLETE    saved).  */
// OBSOLETE static int
// OBSOLETE get_char (unsigned char *addr)
// OBSOLETE {
// OBSOLETE #if 1
// OBSOLETE   if (mem_fault_routine && !mem_safe(addr))
// OBSOLETE     {
// OBSOLETE       mem_fault_routine ();
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE #endif
// OBSOLETE   return *addr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE set_char (unsigned char *addr, unsigned char val)
// OBSOLETE {
// OBSOLETE #if 1
// OBSOLETE   if (mem_fault_routine && !mem_safe (addr))
// OBSOLETE     {
// OBSOLETE       mem_fault_routine ();
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE #endif
// OBSOLETE   *addr = val;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Convert the memory pointed to by mem into hex, placing result in buf.
// OBSOLETE    Return a pointer to the last char put in buf (null).
// OBSOLETE    If MAY_FAULT is non-zero, then we should set mem_err in response to
// OBSOLETE    a fault; if zero treat a fault like any other fault in the stub.  */
// OBSOLETE 
// OBSOLETE static unsigned char *
// OBSOLETE mem2hex (unsigned char *mem, unsigned char *buf, int count, int may_fault)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   unsigned char ch;
// OBSOLETE 
// OBSOLETE   if (may_fault)
// OBSOLETE     mem_fault_routine = set_mem_err;
// OBSOLETE   for (i=0;i<count;i++) {
// OBSOLETE     ch = get_char (mem++);
// OBSOLETE     if (may_fault && mem_err)
// OBSOLETE       return (buf);
// OBSOLETE     *buf++ = hexchars[ch >> 4];
// OBSOLETE     *buf++ = hexchars[ch % 16];
// OBSOLETE   }
// OBSOLETE   *buf = 0;
// OBSOLETE   if (may_fault)
// OBSOLETE     mem_fault_routine = 0;
// OBSOLETE   return(buf);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Convert the hex array pointed to by buf into binary to be placed in mem.
// OBSOLETE    Return a pointer to the character AFTER the last byte written. */
// OBSOLETE 
// OBSOLETE static unsigned char* 
// OBSOLETE hex2mem (unsigned char *buf, unsigned char *mem, int count, int may_fault)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   unsigned char ch;
// OBSOLETE 
// OBSOLETE   if (may_fault)
// OBSOLETE     mem_fault_routine = set_mem_err;
// OBSOLETE   for (i=0;i<count;i++) {
// OBSOLETE     ch = hex(*buf++) << 4;
// OBSOLETE     ch = ch + hex(*buf++);
// OBSOLETE     set_char (mem++, ch);
// OBSOLETE     if (may_fault && mem_err)
// OBSOLETE       return (mem);
// OBSOLETE   }
// OBSOLETE   if (may_fault)
// OBSOLETE     mem_fault_routine = 0;
// OBSOLETE   return(mem);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Convert the binary stream in BUF to memory.
// OBSOLETE 
// OBSOLETE    Gdb will escape $, #, and the escape char (0x7d).
// OBSOLETE    COUNT is the total number of bytes to write into
// OBSOLETE    memory. */
// OBSOLETE static unsigned char *
// OBSOLETE bin2mem (unsigned char *buf, unsigned char *mem, int count, int may_fault)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   unsigned char ch;
// OBSOLETE 
// OBSOLETE   if (may_fault)
// OBSOLETE     mem_fault_routine = set_mem_err;
// OBSOLETE   for (i = 0; i < count; i++)
// OBSOLETE     {
// OBSOLETE       /* Check for any escaped characters. Be paranoid and
// OBSOLETE          only unescape chars that should be escaped. */
// OBSOLETE       if (*buf == 0x7d)
// OBSOLETE         {
// OBSOLETE           switch (*(buf+1))
// OBSOLETE             {
// OBSOLETE             case 0x3:  /* # */
// OBSOLETE             case 0x4:  /* $ */
// OBSOLETE             case 0x5d: /* escape char */
// OBSOLETE               buf++;
// OBSOLETE               *buf |= 0x20;
// OBSOLETE               break;
// OBSOLETE             default:
// OBSOLETE               /* nothing */
// OBSOLETE               break;
// OBSOLETE             }
// OBSOLETE         }
// OBSOLETE 
// OBSOLETE       set_char (mem++, *buf++);
// OBSOLETE 
// OBSOLETE       if (may_fault && mem_err)
// OBSOLETE         return mem;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (may_fault)
// OBSOLETE     mem_fault_routine = 0;
// OBSOLETE   return mem;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* this function takes the m32r exception vector and attempts to
// OBSOLETE    translate this number into a unix compatible signal value */
// OBSOLETE 
// OBSOLETE static int 
// OBSOLETE computeSignal (int exceptionVector)
// OBSOLETE {
// OBSOLETE   int sigval;
// OBSOLETE   switch (exceptionVector) {
// OBSOLETE     case 0  : sigval = 23; break; /* I/O trap                    */
// OBSOLETE     case 1  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 2  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 3  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 4  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 5  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 6  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 7  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 8  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 9  : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 10 : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 11 : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 12 : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 13 : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 14 : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 15 : sigval = 5;  break; /* breakpoint                  */
// OBSOLETE     case 16 : sigval = 10; break; /* BUS ERROR (alignment)       */
// OBSOLETE     case 17 : sigval = 2;  break; /* INTerrupt                   */
// OBSOLETE     default : sigval = 7;  break; /* "software generated"        */
// OBSOLETE   }
// OBSOLETE   return (sigval);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /**********************************************/
// OBSOLETE /* WHILE WE FIND NICE HEX CHARS, BUILD AN INT */
// OBSOLETE /* RETURN NUMBER OF CHARS PROCESSED           */
// OBSOLETE /**********************************************/
// OBSOLETE static int 
// OBSOLETE hexToInt (unsigned char **ptr, int *intValue)
// OBSOLETE {
// OBSOLETE   int numChars = 0;
// OBSOLETE   int hexValue;
// OBSOLETE 
// OBSOLETE   *intValue = 0;
// OBSOLETE   while (**ptr)
// OBSOLETE     {
// OBSOLETE       hexValue = hex(**ptr);
// OBSOLETE       if (hexValue >=0)
// OBSOLETE         {
// OBSOLETE 	  *intValue = (*intValue <<4) | hexValue;
// OBSOLETE 	  numChars ++;
// OBSOLETE         }
// OBSOLETE       else
// OBSOLETE 	break;
// OBSOLETE       (*ptr)++;
// OBSOLETE     }
// OBSOLETE   return (numChars);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE   Table of branch instructions:
// OBSOLETE   
// OBSOLETE   10B6		RTE	return from trap or exception
// OBSOLETE   1FCr		JMP	jump
// OBSOLETE   1ECr		JL	jump and link
// OBSOLETE   7Fxx		BRA	branch
// OBSOLETE   FFxxxxxx	BRA	branch (long)
// OBSOLETE   B09rxxxx	BNEZ	branch not-equal-zero
// OBSOLETE   Br1rxxxx	BNE	branch not-equal
// OBSOLETE   7Dxx		BNC	branch not-condition
// OBSOLETE   FDxxxxxx	BNC	branch not-condition (long)
// OBSOLETE   B0Arxxxx	BLTZ	branch less-than-zero
// OBSOLETE   B0Crxxxx	BLEZ	branch less-equal-zero
// OBSOLETE   7Exx		BL	branch and link
// OBSOLETE   FExxxxxx	BL	branch and link (long)
// OBSOLETE   B0Drxxxx	BGTZ	branch greater-than-zero
// OBSOLETE   B0Brxxxx	BGEZ	branch greater-equal-zero
// OBSOLETE   B08rxxxx	BEQZ	branch equal-zero
// OBSOLETE   Br0rxxxx	BEQ	branch equal
// OBSOLETE   7Cxx		BC	branch condition
// OBSOLETE   FCxxxxxx	BC	branch condition (long)
// OBSOLETE   */
// OBSOLETE 
// OBSOLETE static int 
// OBSOLETE isShortBranch (unsigned char *instr)
// OBSOLETE {
// OBSOLETE   unsigned char instr0 = instr[0] & 0x7F;		/* mask off high bit */
// OBSOLETE 
// OBSOLETE   if (instr0 == 0x10 && instr[1] == 0xB6)	/* RTE */
// OBSOLETE     return 1;		/* return from trap or exception */
// OBSOLETE 
// OBSOLETE   if (instr0 == 0x1E || instr0 == 0x1F)		/* JL or JMP */
// OBSOLETE     if ((instr[1] & 0xF0) == 0xC0)
// OBSOLETE       return 2;					/* jump thru a register */
// OBSOLETE 
// OBSOLETE   if (instr0 == 0x7C || instr0 == 0x7D || 	/* BC, BNC, BL, BRA */
// OBSOLETE       instr0 == 0x7E || instr0 == 0x7F)
// OBSOLETE     return 3;					/* eight bit PC offset */
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE isLongBranch (unsigned char *instr)
// OBSOLETE {
// OBSOLETE   if (instr[0] == 0xFC || instr[0] == 0xFD ||	/* BRA, BNC, BL, BC */
// OBSOLETE       instr[0] == 0xFE || instr[0] == 0xFF)	/* 24 bit relative */
// OBSOLETE     return 4;
// OBSOLETE   if ((instr[0] & 0xF0) == 0xB0)		/* 16 bit relative */
// OBSOLETE     {
// OBSOLETE       if ((instr[1] & 0xF0) == 0x00 || 		/* BNE, BEQ */
// OBSOLETE 	  (instr[1] & 0xF0) == 0x10)
// OBSOLETE 	return 5;
// OBSOLETE       if (instr[0] == 0xB0)	/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ, BEQZ */
// OBSOLETE 	if ((instr[1] & 0xF0) == 0x80 || (instr[1] & 0xF0) == 0x90 || 
// OBSOLETE 	    (instr[1] & 0xF0) == 0xA0 || (instr[1] & 0xF0) == 0xB0 ||
// OBSOLETE 	    (instr[1] & 0xF0) == 0xC0 || (instr[1] & 0xF0) == 0xD0)
// OBSOLETE 	  return 6;
// OBSOLETE     }
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* if address is NOT on a 4-byte boundary, or high-bit of instr is zero, 
// OBSOLETE    then it's a 2-byte instruction, else it's a 4-byte instruction.  */
// OBSOLETE 
// OBSOLETE #define INSTRUCTION_SIZE(addr) \
// OBSOLETE     ((((int) addr & 2) || (((unsigned char *) addr)[0] & 0x80) == 0) ? 2 : 4)
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE isBranch (unsigned char *instr)
// OBSOLETE {
// OBSOLETE   if (INSTRUCTION_SIZE(instr) == 2)
// OBSOLETE     return isShortBranch(instr);
// OBSOLETE   else
// OBSOLETE     return isLongBranch(instr);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE willBranch (unsigned char *instr, int branchCode)
// OBSOLETE {
// OBSOLETE   switch (branchCode) 
// OBSOLETE     {
// OBSOLETE     case 0:	return 0;	/* not a branch */
// OBSOLETE     case 1:	return 1;	/* RTE */
// OBSOLETE     case 2:	return 1;	/* JL or JMP    */
// OBSOLETE     case 3:			/* BC, BNC, BL, BRA (short) */
// OBSOLETE     case 4:			/* BC, BNC, BL, BRA (long) */
// OBSOLETE       switch (instr[0] & 0x0F) 
// OBSOLETE 	{
// OBSOLETE 	case 0xC:		/* Branch if Condition Register */
// OBSOLETE 	  return (registers[CBR] != 0);
// OBSOLETE 	case 0xD:		/* Branch if NOT Condition Register */
// OBSOLETE 	  return (registers[CBR] == 0);
// OBSOLETE 	case 0xE:		/* Branch and Link */
// OBSOLETE 	case 0xF:		/* Branch (unconditional) */
// OBSOLETE 	  return 1;
// OBSOLETE 	default:		/* oops? */
// OBSOLETE 	  return 0;
// OBSOLETE 	}
// OBSOLETE     case 5: 			/* BNE, BEQ */
// OBSOLETE       switch (instr[1] & 0xF0) 
// OBSOLETE 	{
// OBSOLETE 	case 0x00:		/* Branch if r1 equal to r2 */
// OBSOLETE 	  return (registers[instr[0] & 0x0F] == registers[instr[1] & 0x0F]);
// OBSOLETE 	case 0x10:		/* Branch if r1 NOT equal to r2 */
// OBSOLETE 	  return (registers[instr[0] & 0x0F] != registers[instr[1] & 0x0F]);
// OBSOLETE 	default:		/* oops? */
// OBSOLETE 	  return 0;
// OBSOLETE 	}
// OBSOLETE     case 6: 			/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ */
// OBSOLETE       switch (instr[1] & 0xF0) 
// OBSOLETE 	{
// OBSOLETE 	case 0x80:		/* Branch if reg equal to zero */
// OBSOLETE 	  return (registers[instr[1] & 0x0F] == 0);
// OBSOLETE 	case 0x90:		/* Branch if reg NOT equal to zero */
// OBSOLETE 	  return (registers[instr[1] & 0x0F] != 0);
// OBSOLETE 	case 0xA0:		/* Branch if reg less than zero */
// OBSOLETE 	  return (registers[instr[1] & 0x0F] < 0);
// OBSOLETE 	case 0xB0:		/* Branch if reg greater or equal to zero */
// OBSOLETE 	  return (registers[instr[1] & 0x0F] >= 0);
// OBSOLETE 	case 0xC0:		/* Branch if reg less than or equal to zero */
// OBSOLETE 	  return (registers[instr[1] & 0x0F] <= 0);
// OBSOLETE 	case 0xD0:		/* Branch if reg greater than zero */
// OBSOLETE 	  return (registers[instr[1] & 0x0F] > 0);
// OBSOLETE 	default:		/* oops? */
// OBSOLETE 	  return 0;
// OBSOLETE 	}
// OBSOLETE     default:			/* oops? */
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int 
// OBSOLETE branchDestination (unsigned char *instr, int branchCode)
// OBSOLETE { 
// OBSOLETE   switch (branchCode) { 
// OBSOLETE   default: 
// OBSOLETE   case 0:					/* not a branch */ 
// OBSOLETE     return 0;
// OBSOLETE   case 1:					/* RTE */ 
// OBSOLETE     return registers[BPC] & ~3; 		/* pop BPC into PC */
// OBSOLETE   case 2: 					/* JL or JMP */ 
// OBSOLETE     return registers[instr[1] & 0x0F] & ~3;	/* jump thru a register */ 
// OBSOLETE   case 3: 		/* BC, BNC, BL, BRA (short, 8-bit relative offset) */ 
// OBSOLETE     return (((int) instr) & ~3) + ((char) instr[1] << 2);
// OBSOLETE   case 4: 		/* BC, BNC, BL, BRA (long, 24-bit relative offset) */ 
// OBSOLETE     return ((int) instr + 
// OBSOLETE 	    ((((char) instr[1] << 16) | (instr[2] << 8) | (instr[3])) << 2)); 
// OBSOLETE   case 5: 		/* BNE, BEQ (16-bit relative offset) */ 
// OBSOLETE   case 6: 		/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ (ditto) */ 
// OBSOLETE     return ((int) instr + ((((char) instr[2] << 8) | (instr[3])) << 2)); 
// OBSOLETE   }
// OBSOLETE 
// OBSOLETE   /* An explanatory note: in the last three return expressions, I have
// OBSOLETE      cast the most-significant byte of the return offset to char.
// OBSOLETE      What this accomplishes is sign extension.  If the other
// OBSOLETE      less-significant bytes were signed as well, they would get sign
// OBSOLETE      extended too and, if negative, their leading bits would clobber
// OBSOLETE      the bits of the more-significant bytes ahead of them.  There are
// OBSOLETE      other ways I could have done this, but sign extension from
// OBSOLETE      odd-sized integers is always a pain. */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE branchSideEffects (unsigned char *instr, int branchCode)
// OBSOLETE {
// OBSOLETE   switch (branchCode)
// OBSOLETE     {
// OBSOLETE     case 1:			/* RTE */
// OBSOLETE       return;			/* I <THINK> this is already handled... */
// OBSOLETE     case 2:			/* JL (or JMP) */
// OBSOLETE     case 3:			/* BL (or BC, BNC, BRA) */
// OBSOLETE     case 4:
// OBSOLETE       if ((instr[0] & 0x0F) == 0x0E)		/* branch/jump and link */
// OBSOLETE 	registers[R14] = (registers[PC] & ~3) + 4;
// OBSOLETE       return;
// OBSOLETE     default:			/* any other branch has no side effects */
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct STEPPING_CONTEXT {
// OBSOLETE   int stepping;			/* true when we've started a single-step */
// OBSOLETE   unsigned long  target_addr;	/* the instr we're trying to execute */
// OBSOLETE   unsigned long  target_size;	/* the size of the target instr */
// OBSOLETE   unsigned long  noop_addr;	/* where we've inserted a no-op, if any */
// OBSOLETE   unsigned long  trap1_addr;	/* the trap following the target instr */
// OBSOLETE   unsigned long  trap2_addr;	/* the trap at a branch destination, if any */
// OBSOLETE   unsigned short noop_save;	/* instruction overwritten by our no-op */
// OBSOLETE   unsigned short trap1_save;	/* instruction overwritten by trap1 */
// OBSOLETE   unsigned short trap2_save;	/* instruction overwritten by trap2 */
// OBSOLETE   unsigned short continue_p;	/* true if NOT returning to gdb after step */
// OBSOLETE } stepping;
// OBSOLETE 
// OBSOLETE /* Function: prepare_to_step
// OBSOLETE    Called from handle_exception to prepare the user program to single-step.
// OBSOLETE    Places a trap instruction after the target instruction, with special 
// OBSOLETE    extra handling for branch instructions and for instructions in the 
// OBSOLETE    second half-word of a word.  
// OBSOLETE 
// OBSOLETE    Returns: True  if we should actually execute the instruction; 
// OBSOLETE 	    False if we are going to emulate executing the instruction,
// OBSOLETE 	    in which case we simply report to GDB that the instruction 
// OBSOLETE 	    has already been executed.  */
// OBSOLETE 
// OBSOLETE #define TRAP1  0x10f1;	/* trap #1 instruction */
// OBSOLETE #define NOOP   0x7000;  /* noop    instruction */
// OBSOLETE 
// OBSOLETE static unsigned short trap1 = TRAP1;
// OBSOLETE static unsigned short noop  = NOOP;
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE prepare_to_step(continue_p)
// OBSOLETE      int continue_p;	/* if this isn't REALLY a single-step (see below) */
// OBSOLETE {
// OBSOLETE   unsigned long pc = registers[PC];
// OBSOLETE   int branchCode   = isBranch((unsigned char *) pc);
// OBSOLETE   unsigned char *p;
// OBSOLETE 
// OBSOLETE   /* zero out the stepping context 
// OBSOLETE      (paranoia -- it should already be zeroed) */
// OBSOLETE   for (p = (unsigned char *) &stepping;
// OBSOLETE        p < ((unsigned char *) &stepping) + sizeof(stepping);
// OBSOLETE        p++)
// OBSOLETE     *p = 0;
// OBSOLETE 
// OBSOLETE   if (branchCode != 0)			/* next instruction is a branch */
// OBSOLETE     {
// OBSOLETE       branchSideEffects((unsigned char *) pc, branchCode);
// OBSOLETE       if (willBranch((unsigned char *)pc, branchCode))
// OBSOLETE 	registers[PC] = branchDestination((unsigned char *) pc, branchCode);
// OBSOLETE       else
// OBSOLETE 	registers[PC] = pc + INSTRUCTION_SIZE(pc);
// OBSOLETE       return 0;			/* branch "executed" -- just notify GDB */
// OBSOLETE     }
// OBSOLETE   else if (((int) pc & 2) != 0)		/* "second-slot" instruction */
// OBSOLETE     {
// OBSOLETE       /* insert no-op before pc */
// OBSOLETE       stepping.noop_addr  =  pc - 2;
// OBSOLETE       stepping.noop_save  = *(unsigned short *) stepping.noop_addr;
// OBSOLETE       *(unsigned short *) stepping.noop_addr  = noop;
// OBSOLETE       /* insert trap  after  pc */
// OBSOLETE       stepping.trap1_addr =  pc + 2;
// OBSOLETE       stepping.trap1_save = *(unsigned short *) stepping.trap1_addr;
// OBSOLETE       *(unsigned short *) stepping.trap1_addr = trap1;
// OBSOLETE     }
// OBSOLETE   else					/* "first-slot" instruction */
// OBSOLETE     {
// OBSOLETE       /* insert trap  after  pc */
// OBSOLETE       stepping.trap1_addr = pc + INSTRUCTION_SIZE(pc);	
// OBSOLETE       stepping.trap1_save = *(unsigned short *) stepping.trap1_addr;
// OBSOLETE       *(unsigned short *) stepping.trap1_addr = trap1;
// OBSOLETE     }
// OBSOLETE   /* "continue_p" means that we are actually doing a continue, and not 
// OBSOLETE      being requested to single-step by GDB.  Sometimes we have to do
// OBSOLETE      one single-step before continuing, because the PC is on a half-word
// OBSOLETE      boundary.  There's no way to simply resume at such an address.  */
// OBSOLETE   stepping.continue_p = continue_p;
// OBSOLETE   stepping.stepping = 1;		/* starting a single-step */
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: finish_from_step
// OBSOLETE    Called from handle_exception to finish up when the user program 
// OBSOLETE    returns from a single-step.  Replaces the instructions that had
// OBSOLETE    been overwritten by traps or no-ops, 
// OBSOLETE 
// OBSOLETE    Returns: True  if we should notify GDB that the target stopped.
// OBSOLETE 	    False if we only single-stepped because we had to before we
// OBSOLETE 	    could continue (ie. we were trying to continue at a 
// OBSOLETE 	    half-word boundary).  In that case don't notify GDB:
// OBSOLETE 	    just "continue continuing".  */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE finish_from_step (void)
// OBSOLETE {
// OBSOLETE   if (stepping.stepping)	/* anything to do? */
// OBSOLETE     {
// OBSOLETE       int continue_p = stepping.continue_p;
// OBSOLETE       unsigned char *p;
// OBSOLETE 
// OBSOLETE       if (stepping.noop_addr)	/* replace instr "under" our no-op */
// OBSOLETE 	*(unsigned short *) stepping.noop_addr  = stepping.noop_save;
// OBSOLETE       if (stepping.trap1_addr)	/* replace instr "under" our trap  */
// OBSOLETE 	*(unsigned short *) stepping.trap1_addr = stepping.trap1_save;
// OBSOLETE       if (stepping.trap2_addr)  /* ditto our other trap, if any    */
// OBSOLETE 	*(unsigned short *) stepping.trap2_addr = stepping.trap2_save;
// OBSOLETE 
// OBSOLETE       for (p = (unsigned char *) &stepping;	/* zero out the stepping context */
// OBSOLETE 	   p < ((unsigned char *) &stepping) + sizeof(stepping);
// OBSOLETE 	   p++)
// OBSOLETE 	*p = 0;
// OBSOLETE 
// OBSOLETE       return !(continue_p);
// OBSOLETE     }
// OBSOLETE   else 	/* we didn't single-step, therefore this must be a legitimate stop */
// OBSOLETE     return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE struct PSWreg {		/* separate out the bit flags in the PSW register */
// OBSOLETE   int pad1 : 16;
// OBSOLETE   int bsm  : 1;
// OBSOLETE   int bie  : 1;
// OBSOLETE   int pad2 : 5;
// OBSOLETE   int bc   : 1;
// OBSOLETE   int sm   : 1;
// OBSOLETE   int ie   : 1;
// OBSOLETE   int pad3 : 5;
// OBSOLETE   int c    : 1;
// OBSOLETE } *psw;
// OBSOLETE 
// OBSOLETE /* Upon entry the value for LR to save has been pushed.
// OBSOLETE    We unpush that so that the value for the stack pointer saved is correct.
// OBSOLETE    Upon entry, all other registers are assumed to have not been modified
// OBSOLETE    since the interrupt/trap occured.  */
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE stash_registers:
// OBSOLETE 	push r0
// OBSOLETE 	push r1
// OBSOLETE 	seth r1, #shigh(registers)
// OBSOLETE 	add3 r1, r1, #low(registers)
// OBSOLETE 	pop r0		; r1
// OBSOLETE 	st r0, @@(4,r1)
// OBSOLETE 	pop r0		; r0
// OBSOLETE 	st r0, @@r1
// OBSOLETE 	addi r1, #4	; only add 4 as subsequent saves are `pre inc'
// OBSOLETE 	st r2, @@+r1
// OBSOLETE 	st r3, @@+r1
// OBSOLETE 	st r4, @@+r1
// OBSOLETE 	st r5, @@+r1
// OBSOLETE 	st r6, @@+r1
// OBSOLETE 	st r7, @@+r1
// OBSOLETE 	st r8, @@+r1
// OBSOLETE 	st r9, @@+r1
// OBSOLETE 	st r10, @@+r1
// OBSOLETE 	st r11, @@+r1
// OBSOLETE 	st r12, @@+r1
// OBSOLETE 	st r13, @@+r1    ; fp
// OBSOLETE 	pop r0		; lr (r14)
// OBSOLETE 	st r0, @@+r1
// OBSOLETE 	st sp, @@+r1	; sp contains right value at this point
// OBSOLETE 	mvfc r0, cr0
// OBSOLETE 	st r0, @@+r1	; cr0 == PSW
// OBSOLETE 	mvfc r0, cr1
// OBSOLETE 	st r0, @@+r1	; cr1 == CBR
// OBSOLETE 	mvfc r0, cr2
// OBSOLETE 	st r0, @@+r1	; cr2 == SPI
// OBSOLETE 	mvfc r0, cr3
// OBSOLETE 	st r0, @@+r1	; cr3 == SPU
// OBSOLETE 	mvfc r0, cr6
// OBSOLETE 	st r0, @@+r1	; cr6 == BPC
// OBSOLETE 	st r0, @@+r1	; PC  == BPC
// OBSOLETE 	mvfaclo r0
// OBSOLETE 	st r0, @@+r1	; ACCL
// OBSOLETE 	mvfachi r0
// OBSOLETE 	st r0, @@+r1	; ACCH
// OBSOLETE 	jmp lr");
// OBSOLETE 
// OBSOLETE /* C routine to clean up what stash_registers did.
// OBSOLETE    It is called after calling stash_registers.
// OBSOLETE    This is separate from stash_registers as we want to do this in C
// OBSOLETE    but doing stash_registers in C isn't straightforward.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE cleanup_stash (void)
// OBSOLETE {
// OBSOLETE   psw = (struct PSWreg *) &registers[PSW];	/* fields of PSW register */
// OBSOLETE   psw->sm = psw->bsm;		/* fix up pre-trap values of psw fields */
// OBSOLETE   psw->ie = psw->bie;
// OBSOLETE   psw->c  = psw->bc;
// OBSOLETE   registers[CBR] = psw->bc;		/* fix up pre-trap "C" register */
// OBSOLETE 
// OBSOLETE #if 0 /* FIXME: Was in previous version.  Necessary?
// OBSOLETE 	 (Remember that we use the "rte" insn to return from the
// OBSOLETE 	 trap/interrupt so the values of bsm, bie, bc are important.  */
// OBSOLETE   psw->bsm = psw->bie = psw->bc = 0;	/* zero post-trap values */
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   /* FIXME: Copied from previous version.  This can probably be deleted
// OBSOLETE      since methinks stash_registers has already done this.  */
// OBSOLETE   registers[PC] = registers[BPC];	/* pre-trap PC */
// OBSOLETE 
// OBSOLETE   /* FIXME: Copied from previous version.  Necessary?  */
// OBSOLETE   if (psw->sm)			/* copy R15 into (psw->sm ? SPU : SPI) */
// OBSOLETE     registers[SPU] = registers[R15];
// OBSOLETE   else
// OBSOLETE     registers[SPI] = registers[R15];
// OBSOLETE }
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE restore_and_return:
// OBSOLETE 	seth r0, #shigh(registers+8)
// OBSOLETE 	add3 r0, r0, #low(registers+8)
// OBSOLETE 	ld r2, @@r0+	; restore r2
// OBSOLETE 	ld r3, @@r0+	; restore r3
// OBSOLETE 	ld r4, @@r0+	; restore r4
// OBSOLETE 	ld r5, @@r0+	; restore r5
// OBSOLETE 	ld r6, @@r0+	; restore r6
// OBSOLETE 	ld r7, @@r0+	; restore r7
// OBSOLETE 	ld r8, @@r0+	; restore r8
// OBSOLETE 	ld r9, @@r0+	; restore r9
// OBSOLETE 	ld r10, @@r0+	; restore r10
// OBSOLETE 	ld r11, @@r0+	; restore r11
// OBSOLETE 	ld r12, @@r0+	; restore r12
// OBSOLETE 	ld r13, @@r0+	; restore r13
// OBSOLETE 	ld r14, @@r0+	; restore r14
// OBSOLETE 	ld r15, @@r0+	; restore r15
// OBSOLETE 	addi r0, #4	; don't restore PSW (rte will do it)
// OBSOLETE 	ld r1, @@r0+	; restore cr1 == CBR (no-op, because it's read only)
// OBSOLETE 	mvtc r1, cr1
// OBSOLETE 	ld r1, @@r0+	; restore cr2 == SPI
// OBSOLETE 	mvtc r1, cr2
// OBSOLETE 	ld r1, @@r0+	; restore cr3 == SPU
// OBSOLETE 	mvtc r1, cr3
// OBSOLETE 	addi r0, #4	; skip BPC
// OBSOLETE 	ld r1, @@r0+	; restore cr6 (BPC) == PC
// OBSOLETE 	mvtc r1, cr6
// OBSOLETE 	ld r1, @@r0+	; restore ACCL
// OBSOLETE 	mvtaclo r1
// OBSOLETE 	ld r1, @@r0+	; restore ACCH
// OBSOLETE 	mvtachi r1
// OBSOLETE 	seth r0, #shigh(registers)
// OBSOLETE 	add3 r0, r0, #low(registers)
// OBSOLETE 	ld r1, @@(4,r0)	; restore r1
// OBSOLETE 	ld r0, @@r0	; restore r0
// OBSOLETE 	rte");
// OBSOLETE 
// OBSOLETE /* General trap handler, called after the registers have been stashed.
// OBSOLETE    NUM is the trap/exception number.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE process_exception (int num)
// OBSOLETE {
// OBSOLETE   cleanup_stash ();
// OBSOLETE   asm volatile ("
// OBSOLETE 	seth r1, #shigh(stackPtr)
// OBSOLETE 	add3 r1, r1, #low(stackPtr)
// OBSOLETE 	ld r15, @@r1		; setup local stack (protect user stack)
// OBSOLETE 	mv r0, %0
// OBSOLETE 	bl handle_exception
// OBSOLETE 	bl restore_and_return"
// OBSOLETE 		: : "r" (num) : "r0", "r1");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void _catchException0 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException0:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #0
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException1 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException1:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	bl cleanup_stash
// OBSOLETE 	seth r1, #shigh(stackPtr)
// OBSOLETE 	add3 r1, r1, #low(stackPtr)
// OBSOLETE 	ld r15, @@r1		; setup local stack (protect user stack)
// OBSOLETE 	seth r1, #shigh(registers + 21*4) ; PC
// OBSOLETE 	add3 r1, r1, #low(registers + 21*4)
// OBSOLETE 	ld r0, @@r1
// OBSOLETE 	addi r0, #-4		; back up PC for breakpoint trap.
// OBSOLETE 	st r0, @@r1		; FIXME: what about bp in right slot?
// OBSOLETE 	ldi r0, #1
// OBSOLETE 	bl handle_exception
// OBSOLETE 	bl restore_and_return");
// OBSOLETE 
// OBSOLETE void _catchException2 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException2:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #2
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException3 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException3:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #3
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException4 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException4:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #4
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException5 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException5:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #5
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException6 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException6:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #6
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException7 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException7:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #7
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException8 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException8:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #8
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException9 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException9:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #9
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException10 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException10:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #10
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException11 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException11:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #11
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException12 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException12:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #12
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException13 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException13:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #13
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException14 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException14:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #14
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException15 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException15:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #15
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException16 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException16:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #16
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE void _catchException17 ();
// OBSOLETE 
// OBSOLETE asm ("
// OBSOLETE _catchException17:
// OBSOLETE 	push lr
// OBSOLETE 	bl stash_registers
// OBSOLETE 	; Note that at this point the pushed value of `lr' has been popped
// OBSOLETE 	ldi r0, #17
// OBSOLETE 	bl process_exception");
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* this function is used to set up exception handlers for tracing and
// OBSOLETE    breakpoints */
// OBSOLETE void 
// OBSOLETE set_debug_traps (void)
// OBSOLETE {
// OBSOLETE   /*  extern void remcomHandler(); */
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   for (i = 0; i < 18; i++)		/* keep a copy of old vectors */
// OBSOLETE     if (save_vectors[i] == 0)		/* only copy them the first time */
// OBSOLETE       save_vectors[i] = getExceptionHandler (i);
// OBSOLETE 
// OBSOLETE   stackPtr  = &remcomStack[STACKSIZE/sizeof(int) - 1];
// OBSOLETE 
// OBSOLETE   exceptionHandler (0, _catchException0);
// OBSOLETE   exceptionHandler (1, _catchException1);
// OBSOLETE   exceptionHandler (2, _catchException2);
// OBSOLETE   exceptionHandler (3, _catchException3);
// OBSOLETE   exceptionHandler (4, _catchException4);
// OBSOLETE   exceptionHandler (5, _catchException5);
// OBSOLETE   exceptionHandler (6, _catchException6);
// OBSOLETE   exceptionHandler (7, _catchException7);
// OBSOLETE   exceptionHandler (8, _catchException8);
// OBSOLETE   exceptionHandler (9, _catchException9);
// OBSOLETE   exceptionHandler (10, _catchException10);
// OBSOLETE   exceptionHandler (11, _catchException11);
// OBSOLETE   exceptionHandler (12, _catchException12);
// OBSOLETE   exceptionHandler (13, _catchException13);
// OBSOLETE   exceptionHandler (14, _catchException14);
// OBSOLETE   exceptionHandler (15, _catchException15);
// OBSOLETE   exceptionHandler (16, _catchException16);
// OBSOLETE   /*  exceptionHandler (17, _catchException17); */
// OBSOLETE 
// OBSOLETE   initialized = 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* This function will generate a breakpoint exception.  It is used at the
// OBSOLETE    beginning of a program to sync up with a debugger and can be used
// OBSOLETE    otherwise as a quick means to stop program execution and "break" into
// OBSOLETE    the debugger. */
// OBSOLETE 
// OBSOLETE #define BREAKPOINT() asm volatile ("	trap #2");
// OBSOLETE 
// OBSOLETE void 
// OBSOLETE breakpoint (void)
// OBSOLETE {
// OBSOLETE   if (initialized)
// OBSOLETE     BREAKPOINT();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* STDOUT section:
// OBSOLETE    Stuff pertaining to simulating stdout by sending chars to gdb to be echoed.
// OBSOLETE    Functions: gdb_putchar(char ch)
// OBSOLETE               gdb_puts(char *str)
// OBSOLETE               gdb_write(char *str, int len)
// OBSOLETE               gdb_error(char *format, char *parm)
// OBSOLETE 	      */
// OBSOLETE  
// OBSOLETE /* Function: gdb_putchar(int)
// OBSOLETE    Make gdb write a char to stdout.
// OBSOLETE    Returns: the char */
// OBSOLETE  
// OBSOLETE static int
// OBSOLETE gdb_putchar (int ch)
// OBSOLETE {
// OBSOLETE   char buf[4];
// OBSOLETE  
// OBSOLETE   buf[0] = 'O';
// OBSOLETE   buf[1] = hexchars[ch >> 4];
// OBSOLETE   buf[2] = hexchars[ch & 0x0F];
// OBSOLETE   buf[3] = 0;
// OBSOLETE   putpacket(buf);
// OBSOLETE   return ch;
// OBSOLETE }
// OBSOLETE  
// OBSOLETE /* Function: gdb_write(char *, int)
// OBSOLETE    Make gdb write n bytes to stdout (not assumed to be null-terminated).
// OBSOLETE    Returns: number of bytes written */
// OBSOLETE  
// OBSOLETE static int
// OBSOLETE gdb_write (char *data, int len)
// OBSOLETE {
// OBSOLETE   char *buf, *cpy;
// OBSOLETE   int i;
// OBSOLETE  
// OBSOLETE   buf = remcomOutBuffer;
// OBSOLETE   buf[0] = 'O';
// OBSOLETE   i = 0;
// OBSOLETE   while (i < len)
// OBSOLETE     {
// OBSOLETE       for (cpy = buf+1; 
// OBSOLETE 	   i < len && cpy < buf + sizeof(remcomOutBuffer) - 3; 
// OBSOLETE 	   i++)
// OBSOLETE 	{
// OBSOLETE 	  *cpy++ = hexchars[data[i] >> 4];
// OBSOLETE 	  *cpy++ = hexchars[data[i] & 0x0F];
// OBSOLETE 	}
// OBSOLETE       *cpy = 0;
// OBSOLETE       putpacket(buf);
// OBSOLETE     }
// OBSOLETE   return len;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: gdb_puts(char *)
// OBSOLETE    Make gdb write a null-terminated string to stdout.
// OBSOLETE    Returns: the length of the string */
// OBSOLETE  
// OBSOLETE static int
// OBSOLETE gdb_puts (char *str)
// OBSOLETE {
// OBSOLETE   return gdb_write(str, strlen(str));
// OBSOLETE }
// OBSOLETE  
// OBSOLETE /* Function: gdb_error(char *, char *)
// OBSOLETE    Send an error message to gdb's stdout.
// OBSOLETE    First string may have 1 (one) optional "%s" in it, which
// OBSOLETE    will cause the optional second string to be inserted.  */
// OBSOLETE  
// OBSOLETE static void
// OBSOLETE gdb_error (char *format, char *parm)
// OBSOLETE {
// OBSOLETE   char buf[400], *cpy;
// OBSOLETE   int len;
// OBSOLETE  
// OBSOLETE   if (remote_debug)
// OBSOLETE     {
// OBSOLETE       if (format && *format)
// OBSOLETE 	len = strlen(format);
// OBSOLETE       else
// OBSOLETE 	return;             /* empty input */
// OBSOLETE 
// OBSOLETE       if (parm && *parm)
// OBSOLETE 	len += strlen(parm);
// OBSOLETE  
// OBSOLETE       for (cpy = buf; *format; )
// OBSOLETE 	{
// OBSOLETE 	  if (format[0] == '%' && format[1] == 's') /* include second string */
// OBSOLETE 	    {
// OBSOLETE 	      format += 2;          /* advance two chars instead of just one */
// OBSOLETE 	      while (parm && *parm)
// OBSOLETE 		*cpy++ = *parm++;
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    *cpy++ = *format++;
// OBSOLETE 	}
// OBSOLETE       *cpy = '\0';
// OBSOLETE       gdb_puts(buf);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE  
// OBSOLETE static unsigned char *
// OBSOLETE strcpy (unsigned char *dest, const unsigned char *src)
// OBSOLETE {
// OBSOLETE   unsigned char *ret = dest;
// OBSOLETE 
// OBSOLETE   if (dest && src)
// OBSOLETE     {
// OBSOLETE       while (*src)
// OBSOLETE 	*dest++ = *src++;
// OBSOLETE       *dest = 0;
// OBSOLETE     }
// OBSOLETE   return ret;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE strlen (const unsigned char *src)
// OBSOLETE {
// OBSOLETE   int ret;
// OBSOLETE 
// OBSOLETE   for (ret = 0; *src; src++)
// OBSOLETE     ret++;
// OBSOLETE 
// OBSOLETE   return ret;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE void exit (code)
// OBSOLETE      int code;
// OBSOLETE {
// OBSOLETE   _exit (code);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int atexit (void *p)
// OBSOLETE {
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void abort (void)
// OBSOLETE {
// OBSOLETE   _exit (1);
// OBSOLETE }
// OBSOLETE #endif
@


1.4.2.3
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d1 1718
a1718 1779
/****************************************************************************

		THIS SOFTWARE IS NOT COPYRIGHTED

   HP offers the following for use in the public domain.  HP makes no
   warranty with regard to the software or it's performance and the
   user accepts the software "AS IS" with all faults.

   HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD
   TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES
   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

****************************************************************************/

/****************************************************************************
 *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $
 *
 *  Module name: remcom.c $
 *  Revision: 1.34 $
 *  Date: 91/03/09 12:29:49 $
 *  Contributor:     Lake Stevens Instrument Division$
 *
 *  Description:     low level support for gdb debugger. $
 *
 *  Considerations:  only works on target hardware $
 *
 *  Written by:      Glenn Engel $
 *  ModuleState:     Experimental $
 *
 *  NOTES:           See Below $
 *
 *  Modified for M32R by Michael Snyder, Cygnus Support.
 *
 *  To enable debugger support, two things need to happen.  One, a
 *  call to set_debug_traps() is necessary in order to allow any breakpoints
 *  or error conditions to be properly intercepted and reported to gdb.
 *  Two, a breakpoint needs to be generated to begin communication.  This
 *  is most easily accomplished by a call to breakpoint().  Breakpoint()
 *  simulates a breakpoint by executing a trap #1.
 *
 *  The external function exceptionHandler() is
 *  used to attach a specific handler to a specific M32R vector number.
 *  It should use the same privilege level it runs at.  It should
 *  install it as an interrupt gate so that interrupts are masked
 *  while the handler runs.
 *
 *  Because gdb will sometimes write to the stack area to execute function
 *  calls, this program cannot rely on using the supervisor stack so it
 *  uses it's own stack area reserved in the int array remcomStack.
 *
 *************
 *
 *    The following gdb commands are supported:
 *
 * command          function                               Return value
 *
 *    g             return the value of the CPU registers  hex data or ENN
 *    G             set the value of the CPU registers     OK or ENN
 *
 *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN
 *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN
 *    XAA..AA,LLLL: Write LLLL binary bytes at address     OK or ENN
 *                  AA..AA
 *
 *    c             Resume at current address              SNN   ( signal NN)
 *    cAA..AA       Continue at address AA..AA             SNN
 *
 *    s             Step one instruction                   SNN
 *    sAA..AA       Step one instruction from AA..AA       SNN
 *
 *    k             kill
 *
 *    ?             What was the last sigval ?             SNN   (signal NN)
 *
 * All commands and responses are sent with a packet which includes a
 * checksum.  A packet consists of
 *
 * $<packet info>#<checksum>.
 *
 * where
 * <packet info> :: <characters representing the command or response>
 * <checksum>    :: <two hex digits computed as modulo 256 sum of <packetinfo>>
 *
 * When a packet is received, it is first acknowledged with either '+' or '-'.
 * '+' indicates a successful transfer.  '-' indicates a failed transfer.
 *
 * Example:
 *
 * Host:                  Reply:
 * $m0,10#2a               +$00010203040506070809101112131415#42
 *
 ****************************************************************************/


/************************************************************************
 *
 * external low-level support routines
 */
extern void putDebugChar ();	/* write a single character      */
extern int getDebugChar ();	/* read and return a single char */
extern void exceptionHandler ();	/* assign an exception handler   */

/*****************************************************************************
 * BUFMAX defines the maximum number of characters in inbound/outbound buffers
 * at least NUMREGBYTES*2 are needed for register packets 
 */
#define BUFMAX 400

static char initialized;	/* boolean flag. != 0 means we've been initialized */

int remote_debug;
/*  debug >  0 prints ill-formed commands in valid packets & checksum errors */

static const unsigned char hexchars[] = "0123456789abcdef";

#define NUMREGS 24

/* Number of bytes of registers.  */
#define NUMREGBYTES (NUMREGS * 4)
enum regnames
{ R0, R1, R2, R3, R4, R5, R6, R7,
  R8, R9, R10, R11, R12, R13, R14, R15,
  PSW, CBR, SPI, SPU, BPC, PC, ACCL, ACCH
};

enum SYS_calls
{
  SYS_null,
  SYS_exit,
  SYS_open,
  SYS_close,
  SYS_read,
  SYS_write,
  SYS_lseek,
  SYS_unlink,
  SYS_getpid,
  SYS_kill,
  SYS_fstat,
  SYS_sbrk,
  SYS_fork,
  SYS_execve,
  SYS_wait4,
  SYS_link,
  SYS_chdir,
  SYS_stat,
  SYS_utime,
  SYS_chown,
  SYS_chmod,
  SYS_time,
  SYS_pipe
};

static int registers[NUMREGS];

#define STACKSIZE 8096
static unsigned char remcomInBuffer[BUFMAX];
static unsigned char remcomOutBuffer[BUFMAX];
static int remcomStack[STACKSIZE / sizeof (int)];
static int *stackPtr = &remcomStack[STACKSIZE / sizeof (int) - 1];

static unsigned int save_vectors[18];	/* previous exception vectors */

/* Indicate to caller of mem2hex or hex2mem that there has been an error. */
static volatile int mem_err = 0;

/* Store the vector number here (since GDB only gets the signal
   number through the usual means, and that's not very specific).  */
int gdb_m32r_vector = -1;

#if 0
#include "syscall.h"		/* for SYS_exit, SYS_write etc. */
#endif

/* Global entry points:
 */

extern void handle_exception (int);
extern void set_debug_traps (void);
extern void breakpoint (void);

/* Local functions:
 */

static int computeSignal (int);
static void putpacket (unsigned char *);
static unsigned char *getpacket (void);

static unsigned char *mem2hex (unsigned char *, unsigned char *, int, int);
static unsigned char *hex2mem (unsigned char *, unsigned char *, int, int);
static int hexToInt (unsigned char **, int *);
static unsigned char *bin2mem (unsigned char *, unsigned char *, int, int);
static void stash_registers (void);
static void restore_registers (void);
static int prepare_to_step (int);
static int finish_from_step (void);
static unsigned long crc32 (unsigned char *, int, unsigned long);

static void gdb_error (char *, char *);
static int gdb_putchar (int), gdb_puts (char *), gdb_write (char *, int);

static unsigned char *strcpy (unsigned char *, const unsigned char *);
static int strlen (const unsigned char *);

/*
 * This function does all command procesing for interfacing to gdb.
 */

void
handle_exception (int exceptionVector)
{
  int sigval, stepping;
  int addr, length, i;
  unsigned char *ptr;
  unsigned char buf[16];
  int binary;

  if (!finish_from_step ())
    return;			/* "false step": let the target continue */

  gdb_m32r_vector = exceptionVector;

  if (remote_debug)
    {
      mem2hex ((unsigned char *) &exceptionVector, buf, 4, 0);
      gdb_error ("Handle exception %s, ", buf);
      mem2hex ((unsigned char *) &registers[PC], buf, 4, 0);
      gdb_error ("PC == 0x%s\n", buf);
    }

  /* reply to host that an exception has occurred */
  sigval = computeSignal (exceptionVector);

  ptr = remcomOutBuffer;

  *ptr++ = 'T';			/* notify gdb with signo, PC, FP and SP */
  *ptr++ = hexchars[sigval >> 4];
  *ptr++ = hexchars[sigval & 0xf];

  *ptr++ = hexchars[PC >> 4];
  *ptr++ = hexchars[PC & 0xf];
  *ptr++ = ':';
  ptr = mem2hex ((unsigned char *) &registers[PC], ptr, 4, 0);	/* PC */
  *ptr++ = ';';

  *ptr++ = hexchars[R13 >> 4];
  *ptr++ = hexchars[R13 & 0xf];
  *ptr++ = ':';
  ptr = mem2hex ((unsigned char *) &registers[R13], ptr, 4, 0);	/* FP */
  *ptr++ = ';';

  *ptr++ = hexchars[R15 >> 4];
  *ptr++ = hexchars[R15 & 0xf];
  *ptr++ = ':';
  ptr = mem2hex ((unsigned char *) &registers[R15], ptr, 4, 0);	/* SP */
  *ptr++ = ';';
  *ptr++ = 0;

  if (exceptionVector == 0)	/* simulated SYS call stuff */
    {
      mem2hex ((unsigned char *) &registers[PC], buf, 4, 0);
      switch (registers[R0])
	{
	case SYS_exit:
	  gdb_error ("Target program has exited at %s\n", buf);
	  ptr = remcomOutBuffer;
	  *ptr++ = 'W';
	  sigval = registers[R1] & 0xff;
	  *ptr++ = hexchars[sigval >> 4];
	  *ptr++ = hexchars[sigval & 0xf];
	  *ptr++ = 0;
	  break;
	case SYS_open:
	  gdb_error ("Target attempts SYS_open call at %s\n", buf);
	  break;
	case SYS_close:
	  gdb_error ("Target attempts SYS_close call at %s\n", buf);
	  break;
	case SYS_read:
	  gdb_error ("Target attempts SYS_read call at %s\n", buf);
	  break;
	case SYS_write:
	  if (registers[R1] == 1 ||	/* write to stdout  */
	      registers[R1] == 2)	/* write to stderr  */
	    {			/* (we can do that) */
	      registers[R0] =
		gdb_write ((void *) registers[R2], registers[R3]);
	      return;
	    }
	  else
	    gdb_error ("Target attempts SYS_write call at %s\n", buf);
	  break;
	case SYS_lseek:
	  gdb_error ("Target attempts SYS_lseek call at %s\n", buf);
	  break;
	case SYS_unlink:
	  gdb_error ("Target attempts SYS_unlink call at %s\n", buf);
	  break;
	case SYS_getpid:
	  gdb_error ("Target attempts SYS_getpid call at %s\n", buf);
	  break;
	case SYS_kill:
	  gdb_error ("Target attempts SYS_kill call at %s\n", buf);
	  break;
	case SYS_fstat:
	  gdb_error ("Target attempts SYS_fstat call at %s\n", buf);
	  break;
	default:
	  gdb_error ("Target attempts unknown SYS call at %s\n", buf);
	  break;
	}
    }

  putpacket (remcomOutBuffer);

  stepping = 0;

  while (1 == 1)
    {
      remcomOutBuffer[0] = 0;
      ptr = getpacket ();
      binary = 0;
      switch (*ptr++)
	{
	default:		/* Unknown code.  Return an empty reply message. */
	  break;
	case 'R':
	  if (hexToInt (&ptr, &addr))
	    registers[PC] = addr;
	  strcpy (remcomOutBuffer, "OK");
	  break;
	case '!':
	  strcpy (remcomOutBuffer, "OK");
	  break;
	case 'X':		/* XAA..AA,LLLL:<binary data>#cs */
	  binary = 1;
	case 'M':		/* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
	  /* TRY TO READ '%x,%x:'.  IF SUCCEED, SET PTR = 0 */
	  {
	    if (hexToInt (&ptr, &addr))
	      if (*(ptr++) == ',')
		if (hexToInt (&ptr, &length))
		  if (*(ptr++) == ':')
		    {
		      mem_err = 0;
		      if (binary)
			bin2mem (ptr, (unsigned char *) addr, length, 1);
		      else
			hex2mem (ptr, (unsigned char *) addr, length, 1);
		      if (mem_err)
			{
			  strcpy (remcomOutBuffer, "E03");
			  gdb_error ("memory fault", "");
			}
		      else
			{
			  strcpy (remcomOutBuffer, "OK");
			}
		      ptr = 0;
		    }
	    if (ptr)
	      {
		strcpy (remcomOutBuffer, "E02");
	      }
	  }
	  break;
	case 'm':		/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
	  /* TRY TO READ %x,%x.  IF SUCCEED, SET PTR = 0 */
	  if (hexToInt (&ptr, &addr))
	    if (*(ptr++) == ',')
	      if (hexToInt (&ptr, &length))
		{
		  ptr = 0;
		  mem_err = 0;
		  mem2hex ((unsigned char *) addr, remcomOutBuffer, length,
			   1);
		  if (mem_err)
		    {
		      strcpy (remcomOutBuffer, "E03");
		      gdb_error ("memory fault", "");
		    }
		}
	  if (ptr)
	    {
	      strcpy (remcomOutBuffer, "E01");
	    }
	  break;
	case '?':
	  remcomOutBuffer[0] = 'S';
	  remcomOutBuffer[1] = hexchars[sigval >> 4];
	  remcomOutBuffer[2] = hexchars[sigval % 16];
	  remcomOutBuffer[3] = 0;
	  break;
	case 'd':
	  remote_debug = !(remote_debug);	/* toggle debug flag */
	  break;
	case 'g':		/* return the value of the CPU registers */
	  mem2hex ((unsigned char *) registers, remcomOutBuffer, NUMREGBYTES,
		   0);
	  break;
	case 'P':		/* set the value of a single CPU register - return OK */
	  {
	    int regno;

	    if (hexToInt (&ptr, &regno) && *ptr++ == '=')
	      if (regno >= 0 && regno < NUMREGS)
		{
		  int stackmode;

		  hex2mem (ptr, (unsigned char *) &registers[regno], 4, 0);
		  /*
		   * Since we just changed a single CPU register, let's
		   * make sure to keep the several stack pointers consistant.
		   */
		  stackmode = registers[PSW] & 0x80;
		  if (regno == R15)	/* stack pointer changed */
		    {		/* need to change SPI or SPU */
		      if (stackmode == 0)
			registers[SPI] = registers[R15];
		      else
			registers[SPU] = registers[R15];
		    }
		  else if (regno == SPU)	/* "user" stack pointer changed */
		    {
		      if (stackmode != 0)	/* stack in user mode: copy SP */
			registers[R15] = registers[SPU];
		    }
		  else if (regno == SPI)	/* "interrupt" stack pointer changed */
		    {
		      if (stackmode == 0)	/* stack in interrupt mode: copy SP */
			registers[R15] = registers[SPI];
		    }
		  else if (regno == PSW)	/* stack mode may have changed! */
		    {		/* force SP to either SPU or SPI */
		      if (stackmode == 0)	/* stack in user mode */
			registers[R15] = registers[SPI];
		      else	/* stack in interrupt mode */
			registers[R15] = registers[SPU];
		    }
		  strcpy (remcomOutBuffer, "OK");
		  break;
		}
	    strcpy (remcomOutBuffer, "E01");
	    break;
	  }
	case 'G':		/* set the value of the CPU registers - return OK */
	  hex2mem (ptr, (unsigned char *) registers, NUMREGBYTES, 0);
	  strcpy (remcomOutBuffer, "OK");
	  break;
	case 's':		/* sAA..AA      Step one instruction from AA..AA(optional) */
	  stepping = 1;
	case 'c':		/* cAA..AA      Continue from address AA..AA(optional) */
	  /* try to read optional parameter, pc unchanged if no parm */
	  if (hexToInt (&ptr, &addr))
	    registers[PC] = addr;

	  if (stepping)		/* single-stepping */
	    {
	      if (!prepare_to_step (0))	/* set up for single-step */
		{
		  /* prepare_to_step has already emulated the target insn:
		     Send SIGTRAP to gdb, don't resume the target at all.  */
		  ptr = remcomOutBuffer;
		  *ptr++ = 'T';	/* Simulate stopping with SIGTRAP */
		  *ptr++ = '0';
		  *ptr++ = '5';

		  *ptr++ = hexchars[PC >> 4];	/* send PC */
		  *ptr++ = hexchars[PC & 0xf];
		  *ptr++ = ':';
		  ptr = mem2hex ((unsigned char *) &registers[PC], ptr, 4, 0);
		  *ptr++ = ';';

		  *ptr++ = hexchars[R13 >> 4];	/* send FP */
		  *ptr++ = hexchars[R13 & 0xf];
		  *ptr++ = ':';
		  ptr =
		    mem2hex ((unsigned char *) &registers[R13], ptr, 4, 0);
		  *ptr++ = ';';

		  *ptr++ = hexchars[R15 >> 4];	/* send SP */
		  *ptr++ = hexchars[R15 & 0xf];
		  *ptr++ = ':';
		  ptr =
		    mem2hex ((unsigned char *) &registers[R15], ptr, 4, 0);
		  *ptr++ = ';';
		  *ptr++ = 0;

		  break;
		}
	    }
	  else			/* continuing, not single-stepping */
	    {
	      /* OK, about to do a "continue".  First check to see if the 
	         target pc is on an odd boundary (second instruction in the 
	         word).  If so, we must do a single-step first, because 
	         ya can't jump or return back to an odd boundary!  */
	      if ((registers[PC] & 2) != 0)
		prepare_to_step (1);
	    }

	  return;

	case 'D':		/* Detach */
#if 0
	  /* I am interpreting this to mean, release the board from control 
	     by the remote stub.  To do this, I am restoring the original
	     (or at least previous) exception vectors.
	   */
	  for (i = 0; i < 18; i++)
	    exceptionHandler (i, save_vectors[i]);
	  putpacket ("OK");
	  return;		/* continue the inferior */
#else
	  strcpy (remcomOutBuffer, "OK");
	  break;
#endif
	case 'q':
	  if (*ptr++ == 'C' &&
	      *ptr++ == 'R' && *ptr++ == 'C' && *ptr++ == ':')
	    {
	      unsigned long start, len, our_crc;

	      if (hexToInt (&ptr, (int *) &start) &&
		  *ptr++ == ',' && hexToInt (&ptr, (int *) &len))
		{
		  remcomOutBuffer[0] = 'C';
		  our_crc = crc32 ((unsigned char *) start, len, 0xffffffff);
		  mem2hex ((char *) &our_crc,
			   &remcomOutBuffer[1], sizeof (long), 0);
		}		/* else do nothing */
	    }			/* else do nothing */
	  break;

	case 'k':		/* kill the program */
	  continue;
	}			/* switch */

      /* reply to the request */
      putpacket (remcomOutBuffer);
    }
}

/* qCRC support */

/* Table used by the crc32 function to calcuate the checksum. */
static unsigned long crc32_table[256] = { 0, 0 };

static unsigned long
crc32 (unsigned char *buf, int len, unsigned long crc)
{
  if (!crc32_table[1])
    {
      /* Initialize the CRC table and the decoding table. */
      int i, j;
      unsigned long c;

      for (i = 0; i < 256; i++)
	{
	  for (c = i << 24, j = 8; j > 0; --j)
	    c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : (c << 1);
	  crc32_table[i] = c;
	}
    }

  while (len--)
    {
      crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ *buf) & 255];
      buf++;
    }
  return crc;
}

static int
hex (unsigned char ch)
{
  if ((ch >= 'a') && (ch <= 'f'))
    return (ch - 'a' + 10);
  if ((ch >= '0') && (ch <= '9'))
    return (ch - '0');
  if ((ch >= 'A') && (ch <= 'F'))
    return (ch - 'A' + 10);
  return (-1);
}

/* scan for the sequence $<data>#<checksum>     */

unsigned char *
getpacket (void)
{
  unsigned char *buffer = &remcomInBuffer[0];
  unsigned char checksum;
  unsigned char xmitcsum;
  int count;
  char ch;

  while (1)
    {
      /* wait around for the start character, ignore all other characters */
      while ((ch = getDebugChar ()) != '$')
	;

    retry:
      checksum = 0;
      xmitcsum = -1;
      count = 0;

      /* now, read until a # or end of buffer is found */
      while (count < BUFMAX)
	{
	  ch = getDebugChar ();
	  if (ch == '$')
	    goto retry;
	  if (ch == '#')
	    break;
	  checksum = checksum + ch;
	  buffer[count] = ch;
	  count = count + 1;
	}
      buffer[count] = 0;

      if (ch == '#')
	{
	  ch = getDebugChar ();
	  xmitcsum = hex (ch) << 4;
	  ch = getDebugChar ();
	  xmitcsum += hex (ch);

	  if (checksum != xmitcsum)
	    {
	      if (remote_debug)
		{
		  unsigned char buf[16];

		  mem2hex ((unsigned char *) &checksum, buf, 4, 0);
		  gdb_error ("Bad checksum: my count = %s, ", buf);
		  mem2hex ((unsigned char *) &xmitcsum, buf, 4, 0);
		  gdb_error ("sent count = %s\n", buf);
		  gdb_error (" -- Bad buffer: \"%s\"\n", buffer);
		}
	      putDebugChar ('-');	/* failed checksum */
	    }
	  else
	    {
	      putDebugChar ('+');	/* successful transfer */

	      /* if a sequence char is present, reply the sequence ID */
	      if (buffer[2] == ':')
		{
		  putDebugChar (buffer[0]);
		  putDebugChar (buffer[1]);

		  return &buffer[3];
		}

	      return &buffer[0];
	    }
	}
    }
}

/* send the packet in buffer.  */

static void
putpacket (unsigned char *buffer)
{
  unsigned char checksum;
  int count;
  char ch;

  /*  $<packet info>#<checksum>. */
  do
    {
      putDebugChar ('$');
      checksum = 0;
      count = 0;

      while (ch = buffer[count])
	{
	  putDebugChar (ch);
	  checksum += ch;
	  count += 1;
	}
      putDebugChar ('#');
      putDebugChar (hexchars[checksum >> 4]);
      putDebugChar (hexchars[checksum % 16]);
    }
  while (getDebugChar () != '+');
}

/* Address of a routine to RTE to if we get a memory fault.  */

static void (*volatile mem_fault_routine) () = 0;

static void
set_mem_err (void)
{
  mem_err = 1;
}

/* Check the address for safe access ranges.  As currently defined,
   this routine will reject the "expansion bus" address range(s).
   To make those ranges useable, someone must implement code to detect
   whether there's anything connected to the expansion bus. */

static int
mem_safe (unsigned char *addr)
{
#define BAD_RANGE_ONE_START	((unsigned char *) 0x600000)
#define BAD_RANGE_ONE_END	((unsigned char *) 0xa00000)
#define BAD_RANGE_TWO_START	((unsigned char *) 0xff680000)
#define BAD_RANGE_TWO_END	((unsigned char *) 0xff800000)

  if (addr < BAD_RANGE_ONE_START)
    return 1;			/* safe */
  if (addr < BAD_RANGE_ONE_END)
    return 0;			/* unsafe */
  if (addr < BAD_RANGE_TWO_START)
    return 1;			/* safe */
  if (addr < BAD_RANGE_TWO_END)
    return 0;			/* unsafe */
}

/* These are separate functions so that they are so short and sweet
   that the compiler won't save any registers (if there is a fault
   to mem_fault, they won't get restored, so there better not be any
   saved).  */
static int
get_char (unsigned char *addr)
{
#if 1
  if (mem_fault_routine && !mem_safe (addr))
    {
      mem_fault_routine ();
      return 0;
    }
#endif
  return *addr;
}

static void
set_char (unsigned char *addr, unsigned char val)
{
#if 1
  if (mem_fault_routine && !mem_safe (addr))
    {
      mem_fault_routine ();
      return;
    }
#endif
  *addr = val;
}

/* Convert the memory pointed to by mem into hex, placing result in buf.
   Return a pointer to the last char put in buf (null).
   If MAY_FAULT is non-zero, then we should set mem_err in response to
   a fault; if zero treat a fault like any other fault in the stub.  */

static unsigned char *
mem2hex (unsigned char *mem, unsigned char *buf, int count, int may_fault)
{
  int i;
  unsigned char ch;

  if (may_fault)
    mem_fault_routine = set_mem_err;
  for (i = 0; i < count; i++)
    {
      ch = get_char (mem++);
      if (may_fault && mem_err)
	return (buf);
      *buf++ = hexchars[ch >> 4];
      *buf++ = hexchars[ch % 16];
    }
  *buf = 0;
  if (may_fault)
    mem_fault_routine = 0;
  return (buf);
}

/* Convert the hex array pointed to by buf into binary to be placed in mem.
   Return a pointer to the character AFTER the last byte written. */

static unsigned char *
hex2mem (unsigned char *buf, unsigned char *mem, int count, int may_fault)
{
  int i;
  unsigned char ch;

  if (may_fault)
    mem_fault_routine = set_mem_err;
  for (i = 0; i < count; i++)
    {
      ch = hex (*buf++) << 4;
      ch = ch + hex (*buf++);
      set_char (mem++, ch);
      if (may_fault && mem_err)
	return (mem);
    }
  if (may_fault)
    mem_fault_routine = 0;
  return (mem);
}

/* Convert the binary stream in BUF to memory.

   Gdb will escape $, #, and the escape char (0x7d).
   COUNT is the total number of bytes to write into
   memory. */
static unsigned char *
bin2mem (unsigned char *buf, unsigned char *mem, int count, int may_fault)
{
  int i;
  unsigned char ch;

  if (may_fault)
    mem_fault_routine = set_mem_err;
  for (i = 0; i < count; i++)
    {
      /* Check for any escaped characters. Be paranoid and
         only unescape chars that should be escaped. */
      if (*buf == 0x7d)
	{
	  switch (*(buf + 1))
	    {
	    case 0x3:		/* # */
	    case 0x4:		/* $ */
	    case 0x5d:		/* escape char */
	      buf++;
	      *buf |= 0x20;
	      break;
	    default:
	      /* nothing */
	      break;
	    }
	}

      set_char (mem++, *buf++);

      if (may_fault && mem_err)
	return mem;
    }

  if (may_fault)
    mem_fault_routine = 0;
  return mem;
}

/* this function takes the m32r exception vector and attempts to
   translate this number into a unix compatible signal value */

static int
computeSignal (int exceptionVector)
{
  int sigval;
  switch (exceptionVector)
    {
    case 0:
      sigval = 23;
      break;			/* I/O trap                    */
    case 1:
      sigval = 5;
      break;			/* breakpoint                  */
    case 2:
      sigval = 5;
      break;			/* breakpoint                  */
    case 3:
      sigval = 5;
      break;			/* breakpoint                  */
    case 4:
      sigval = 5;
      break;			/* breakpoint                  */
    case 5:
      sigval = 5;
      break;			/* breakpoint                  */
    case 6:
      sigval = 5;
      break;			/* breakpoint                  */
    case 7:
      sigval = 5;
      break;			/* breakpoint                  */
    case 8:
      sigval = 5;
      break;			/* breakpoint                  */
    case 9:
      sigval = 5;
      break;			/* breakpoint                  */
    case 10:
      sigval = 5;
      break;			/* breakpoint                  */
    case 11:
      sigval = 5;
      break;			/* breakpoint                  */
    case 12:
      sigval = 5;
      break;			/* breakpoint                  */
    case 13:
      sigval = 5;
      break;			/* breakpoint                  */
    case 14:
      sigval = 5;
      break;			/* breakpoint                  */
    case 15:
      sigval = 5;
      break;			/* breakpoint                  */
    case 16:
      sigval = 10;
      break;			/* BUS ERROR (alignment)       */
    case 17:
      sigval = 2;
      break;			/* INTerrupt                   */
    default:
      sigval = 7;
      break;			/* "software generated"        */
    }
  return (sigval);
}

/**********************************************/
/* WHILE WE FIND NICE HEX CHARS, BUILD AN INT */
/* RETURN NUMBER OF CHARS PROCESSED           */
/**********************************************/
static int
hexToInt (unsigned char **ptr, int *intValue)
{
  int numChars = 0;
  int hexValue;

  *intValue = 0;
  while (**ptr)
    {
      hexValue = hex (**ptr);
      if (hexValue >= 0)
	{
	  *intValue = (*intValue << 4) | hexValue;
	  numChars++;
	}
      else
	break;
      (*ptr)++;
    }
  return (numChars);
}

/*
  Table of branch instructions:
  
  10B6		RTE	return from trap or exception
  1FCr		JMP	jump
  1ECr		JL	jump and link
  7Fxx		BRA	branch
  FFxxxxxx	BRA	branch (long)
  B09rxxxx	BNEZ	branch not-equal-zero
  Br1rxxxx	BNE	branch not-equal
  7Dxx		BNC	branch not-condition
  FDxxxxxx	BNC	branch not-condition (long)
  B0Arxxxx	BLTZ	branch less-than-zero
  B0Crxxxx	BLEZ	branch less-equal-zero
  7Exx		BL	branch and link
  FExxxxxx	BL	branch and link (long)
  B0Drxxxx	BGTZ	branch greater-than-zero
  B0Brxxxx	BGEZ	branch greater-equal-zero
  B08rxxxx	BEQZ	branch equal-zero
  Br0rxxxx	BEQ	branch equal
  7Cxx		BC	branch condition
  FCxxxxxx	BC	branch condition (long)
  */

static int
isShortBranch (unsigned char *instr)
{
  unsigned char instr0 = instr[0] & 0x7F;	/* mask off high bit */

  if (instr0 == 0x10 && instr[1] == 0xB6)	/* RTE */
    return 1;			/* return from trap or exception */

  if (instr0 == 0x1E || instr0 == 0x1F)	/* JL or JMP */
    if ((instr[1] & 0xF0) == 0xC0)
      return 2;			/* jump thru a register */

  if (instr0 == 0x7C || instr0 == 0x7D ||	/* BC, BNC, BL, BRA */
      instr0 == 0x7E || instr0 == 0x7F)
    return 3;			/* eight bit PC offset */

  return 0;
}

static int
isLongBranch (unsigned char *instr)
{
  if (instr[0] == 0xFC || instr[0] == 0xFD ||	/* BRA, BNC, BL, BC */
      instr[0] == 0xFE || instr[0] == 0xFF)	/* 24 bit relative */
    return 4;
  if ((instr[0] & 0xF0) == 0xB0)	/* 16 bit relative */
    {
      if ((instr[1] & 0xF0) == 0x00 ||	/* BNE, BEQ */
	  (instr[1] & 0xF0) == 0x10)
	return 5;
      if (instr[0] == 0xB0)	/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ, BEQZ */
	if ((instr[1] & 0xF0) == 0x80 || (instr[1] & 0xF0) == 0x90 ||
	    (instr[1] & 0xF0) == 0xA0 || (instr[1] & 0xF0) == 0xB0 ||
	    (instr[1] & 0xF0) == 0xC0 || (instr[1] & 0xF0) == 0xD0)
	  return 6;
    }
  return 0;
}

/* if address is NOT on a 4-byte boundary, or high-bit of instr is zero, 
   then it's a 2-byte instruction, else it's a 4-byte instruction.  */

#define INSTRUCTION_SIZE(addr) \
    ((((int) addr & 2) || (((unsigned char *) addr)[0] & 0x80) == 0) ? 2 : 4)

static int
isBranch (unsigned char *instr)
{
  if (INSTRUCTION_SIZE (instr) == 2)
    return isShortBranch (instr);
  else
    return isLongBranch (instr);
}

static int
willBranch (unsigned char *instr, int branchCode)
{
  switch (branchCode)
    {
    case 0:
      return 0;			/* not a branch */
    case 1:
      return 1;			/* RTE */
    case 2:
      return 1;			/* JL or JMP    */
    case 3:			/* BC, BNC, BL, BRA (short) */
    case 4:			/* BC, BNC, BL, BRA (long) */
      switch (instr[0] & 0x0F)
	{
	case 0xC:		/* Branch if Condition Register */
	  return (registers[CBR] != 0);
	case 0xD:		/* Branch if NOT Condition Register */
	  return (registers[CBR] == 0);
	case 0xE:		/* Branch and Link */
	case 0xF:		/* Branch (unconditional) */
	  return 1;
	default:		/* oops? */
	  return 0;
	}
    case 5:			/* BNE, BEQ */
      switch (instr[1] & 0xF0)
	{
	case 0x00:		/* Branch if r1 equal to r2 */
	  return (registers[instr[0] & 0x0F] == registers[instr[1] & 0x0F]);
	case 0x10:		/* Branch if r1 NOT equal to r2 */
	  return (registers[instr[0] & 0x0F] != registers[instr[1] & 0x0F]);
	default:		/* oops? */
	  return 0;
	}
    case 6:			/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ */
      switch (instr[1] & 0xF0)
	{
	case 0x80:		/* Branch if reg equal to zero */
	  return (registers[instr[1] & 0x0F] == 0);
	case 0x90:		/* Branch if reg NOT equal to zero */
	  return (registers[instr[1] & 0x0F] != 0);
	case 0xA0:		/* Branch if reg less than zero */
	  return (registers[instr[1] & 0x0F] < 0);
	case 0xB0:		/* Branch if reg greater or equal to zero */
	  return (registers[instr[1] & 0x0F] >= 0);
	case 0xC0:		/* Branch if reg less than or equal to zero */
	  return (registers[instr[1] & 0x0F] <= 0);
	case 0xD0:		/* Branch if reg greater than zero */
	  return (registers[instr[1] & 0x0F] > 0);
	default:		/* oops? */
	  return 0;
	}
    default:			/* oops? */
      return 0;
    }
}

static int
branchDestination (unsigned char *instr, int branchCode)
{
  switch (branchCode)
    {
    default:
    case 0:			/* not a branch */
      return 0;
    case 1:			/* RTE */
      return registers[BPC] & ~3;	/* pop BPC into PC */
    case 2:			/* JL or JMP */
      return registers[instr[1] & 0x0F] & ~3;	/* jump thru a register */
    case 3:			/* BC, BNC, BL, BRA (short, 8-bit relative offset) */
      return (((int) instr) & ~3) + ((char) instr[1] << 2);
    case 4:			/* BC, BNC, BL, BRA (long, 24-bit relative offset) */
      return ((int) instr +
	      ((((char) instr[1] << 16) | (instr[2] << 8) | (instr[3])) <<
	       2));
    case 5:			/* BNE, BEQ (16-bit relative offset) */
    case 6:			/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ (ditto) */
      return ((int) instr + ((((char) instr[2] << 8) | (instr[3])) << 2));
    }

  /* An explanatory note: in the last three return expressions, I have
     cast the most-significant byte of the return offset to char.
     What this accomplishes is sign extension.  If the other
     less-significant bytes were signed as well, they would get sign
     extended too and, if negative, their leading bits would clobber
     the bits of the more-significant bytes ahead of them.  There are
     other ways I could have done this, but sign extension from
     odd-sized integers is always a pain. */
}

static void
branchSideEffects (unsigned char *instr, int branchCode)
{
  switch (branchCode)
    {
    case 1:			/* RTE */
      return;			/* I <THINK> this is already handled... */
    case 2:			/* JL (or JMP) */
    case 3:			/* BL (or BC, BNC, BRA) */
    case 4:
      if ((instr[0] & 0x0F) == 0x0E)	/* branch/jump and link */
	registers[R14] = (registers[PC] & ~3) + 4;
      return;
    default:			/* any other branch has no side effects */
      return;
    }
}

static struct STEPPING_CONTEXT
{
  int stepping;			/* true when we've started a single-step */
  unsigned long target_addr;	/* the instr we're trying to execute */
  unsigned long target_size;	/* the size of the target instr */
  unsigned long noop_addr;	/* where we've inserted a no-op, if any */
  unsigned long trap1_addr;	/* the trap following the target instr */
  unsigned long trap2_addr;	/* the trap at a branch destination, if any */
  unsigned short noop_save;	/* instruction overwritten by our no-op */
  unsigned short trap1_save;	/* instruction overwritten by trap1 */
  unsigned short trap2_save;	/* instruction overwritten by trap2 */
  unsigned short continue_p;	/* true if NOT returning to gdb after step */
} stepping;

/* Function: prepare_to_step
   Called from handle_exception to prepare the user program to single-step.
   Places a trap instruction after the target instruction, with special 
   extra handling for branch instructions and for instructions in the 
   second half-word of a word.  

   Returns: True  if we should actually execute the instruction; 
	    False if we are going to emulate executing the instruction,
	    in which case we simply report to GDB that the instruction 
	    has already been executed.  */

#define TRAP1  0x10f1;		/* trap #1 instruction */
#define NOOP   0x7000;		/* noop    instruction */

static unsigned short trap1 = TRAP1;
static unsigned short noop = NOOP;

static int
prepare_to_step (continue_p)
     int continue_p;		/* if this isn't REALLY a single-step (see below) */
{
  unsigned long pc = registers[PC];
  int branchCode = isBranch ((unsigned char *) pc);
  unsigned char *p;

  /* zero out the stepping context 
     (paranoia -- it should already be zeroed) */
  for (p = (unsigned char *) &stepping;
       p < ((unsigned char *) &stepping) + sizeof (stepping); p++)
    *p = 0;

  if (branchCode != 0)		/* next instruction is a branch */
    {
      branchSideEffects ((unsigned char *) pc, branchCode);
      if (willBranch ((unsigned char *) pc, branchCode))
	registers[PC] = branchDestination ((unsigned char *) pc, branchCode);
      else
	registers[PC] = pc + INSTRUCTION_SIZE (pc);
      return 0;			/* branch "executed" -- just notify GDB */
    }
  else if (((int) pc & 2) != 0)	/* "second-slot" instruction */
    {
      /* insert no-op before pc */
      stepping.noop_addr = pc - 2;
      stepping.noop_save = *(unsigned short *) stepping.noop_addr;
      *(unsigned short *) stepping.noop_addr = noop;
      /* insert trap  after  pc */
      stepping.trap1_addr = pc + 2;
      stepping.trap1_save = *(unsigned short *) stepping.trap1_addr;
      *(unsigned short *) stepping.trap1_addr = trap1;
    }
  else				/* "first-slot" instruction */
    {
      /* insert trap  after  pc */
      stepping.trap1_addr = pc + INSTRUCTION_SIZE (pc);
      stepping.trap1_save = *(unsigned short *) stepping.trap1_addr;
      *(unsigned short *) stepping.trap1_addr = trap1;
    }
  /* "continue_p" means that we are actually doing a continue, and not 
     being requested to single-step by GDB.  Sometimes we have to do
     one single-step before continuing, because the PC is on a half-word
     boundary.  There's no way to simply resume at such an address.  */
  stepping.continue_p = continue_p;
  stepping.stepping = 1;	/* starting a single-step */
  return 1;
}

/* Function: finish_from_step
   Called from handle_exception to finish up when the user program 
   returns from a single-step.  Replaces the instructions that had
   been overwritten by traps or no-ops, 

   Returns: True  if we should notify GDB that the target stopped.
	    False if we only single-stepped because we had to before we
	    could continue (ie. we were trying to continue at a 
	    half-word boundary).  In that case don't notify GDB:
	    just "continue continuing".  */

static int
finish_from_step (void)
{
  if (stepping.stepping)	/* anything to do? */
    {
      int continue_p = stepping.continue_p;
      unsigned char *p;

      if (stepping.noop_addr)	/* replace instr "under" our no-op */
	*(unsigned short *) stepping.noop_addr = stepping.noop_save;
      if (stepping.trap1_addr)	/* replace instr "under" our trap  */
	*(unsigned short *) stepping.trap1_addr = stepping.trap1_save;
      if (stepping.trap2_addr)	/* ditto our other trap, if any    */
	*(unsigned short *) stepping.trap2_addr = stepping.trap2_save;

      for (p = (unsigned char *) &stepping;	/* zero out the stepping context */
	   p < ((unsigned char *) &stepping) + sizeof (stepping); p++)
	*p = 0;

      return !(continue_p);
    }
  else				/* we didn't single-step, therefore this must be a legitimate stop */
    return 1;
}

struct PSWreg
{				/* separate out the bit flags in the PSW register */
  int pad1:16;
  int bsm:1;
  int bie:1;
  int pad2:5;
  int bc:1;
  int sm:1;
  int ie:1;
  int pad3:5;
  int c:1;
} *psw;

/* Upon entry the value for LR to save has been pushed.
   We unpush that so that the value for the stack pointer saved is correct.
   Upon entry, all other registers are assumed to have not been modified
   since the interrupt/trap occured.  */

asm ("\n\
stash_registers:\n\
	push r0\n\
	push r1\n\
	seth r1, #shigh(registers)\n\
	add3 r1, r1, #low(registers)\n\
	pop r0		; r1\n\
	st r0, @@(4,r1)\n\
	pop r0		; r0\n\
	st r0, @@r1\n\
	addi r1, #4	; only add 4 as subsequent saves are `pre inc'\n\
	st r2, @@+r1\n\
	st r3, @@+r1\n\
	st r4, @@+r1\n\
	st r5, @@+r1\n\
	st r6, @@+r1\n\
	st r7, @@+r1\n\
	st r8, @@+r1\n\
	st r9, @@+r1\n\
	st r10, @@+r1\n\
	st r11, @@+r1\n\
	st r12, @@+r1\n\
	st r13, @@+r1    ; fp\n\
	pop r0		; lr (r14)\n\
	st r0, @@+r1\n\
	st sp, @@+r1	; sp contains right value at this point\n\
	mvfc r0, cr0\n\
	st r0, @@+r1	; cr0 == PSW\n\
	mvfc r0, cr1\n\
	st r0, @@+r1	; cr1 == CBR\n\
	mvfc r0, cr2\n\
	st r0, @@+r1	; cr2 == SPI\n\
	mvfc r0, cr3\n\
	st r0, @@+r1	; cr3 == SPU\n\
	mvfc r0, cr6\n\
	st r0, @@+r1	; cr6 == BPC\n\
	st r0, @@+r1	; PC  == BPC\n\
	mvfaclo r0\n\
	st r0, @@+r1	; ACCL\n\
	mvfachi r0\n\
	st r0, @@+r1	; ACCH\n\
	jmp lr");

/* C routine to clean up what stash_registers did.
   It is called after calling stash_registers.
   This is separate from stash_registers as we want to do this in C
   but doing stash_registers in C isn't straightforward.  */

static void
cleanup_stash (void)
{
  psw = (struct PSWreg *) &registers[PSW];	/* fields of PSW register */
  psw->sm = psw->bsm;		/* fix up pre-trap values of psw fields */
  psw->ie = psw->bie;
  psw->c = psw->bc;
  registers[CBR] = psw->bc;	/* fix up pre-trap "C" register */

#if 0				/* FIXME: Was in previous version.  Necessary?
				   (Remember that we use the "rte" insn to return from the
				   trap/interrupt so the values of bsm, bie, bc are important.  */
  psw->bsm = psw->bie = psw->bc = 0;	/* zero post-trap values */
#endif

  /* FIXME: Copied from previous version.  This can probably be deleted
     since methinks stash_registers has already done this.  */
  registers[PC] = registers[BPC];	/* pre-trap PC */

  /* FIXME: Copied from previous version.  Necessary?  */
  if (psw->sm)			/* copy R15 into (psw->sm ? SPU : SPI) */
    registers[SPU] = registers[R15];
  else
    registers[SPI] = registers[R15];
}

asm ("\n\
restore_and_return:\n\
	seth r0, #shigh(registers+8)\n\
	add3 r0, r0, #low(registers+8)\n\
	ld r2, @@r0+	; restore r2\n\
	ld r3, @@r0+	; restore r3\n\
	ld r4, @@r0+	; restore r4\n\
	ld r5, @@r0+	; restore r5\n\
	ld r6, @@r0+	; restore r6\n\
	ld r7, @@r0+	; restore r7\n\
	ld r8, @@r0+	; restore r8\n\
	ld r9, @@r0+	; restore r9\n\
	ld r10, @@r0+	; restore r10\n\
	ld r11, @@r0+	; restore r11\n\
	ld r12, @@r0+	; restore r12\n\
	ld r13, @@r0+	; restore r13\n\
	ld r14, @@r0+	; restore r14\n\
	ld r15, @@r0+	; restore r15\n\
	ld r1, @@r0+	; restore cr0 == PSW\n\
	mvtc r1, cr0\n\
	ld r1, @@r0+	; restore cr1 == CBR (no-op, because it's read only)\n\
	mvtc r1, cr1\n\
	ld r1, @@r0+	; restore cr2 == SPI\n\
	mvtc r1, cr2\n\
	ld r1, @@r0+	; restore cr3 == SPU\n\
	mvtc r1, cr3\n\
	addi r0, #4	; skip BPC\n\
	ld r1, @@r0+	; restore cr6 (BPC) == PC\n\
	mvtc r1, cr6\n\
	ld r1, @@r0+	; restore ACCL\n\
	mvtaclo r1\n\
	ld r1, @@r0+	; restore ACCH\n\
	mvtachi r1\n\
	seth r0, #shigh(registers)\n\
	add3 r0, r0, #low(registers)\n\
	ld r1, @@(4,r0)	; restore r1\n\
	ld r0, @@r0	; restore r0\n\
	rte");

/* General trap handler, called after the registers have been stashed.
   NUM is the trap/exception number.  */

static void
process_exception (int num)
{
  cleanup_stash ();
  asm volatile ("\n\
	seth r1, #shigh(stackPtr)\n\
	add3 r1, r1, #low(stackPtr)\n\
	ld r15, @@r1		; setup local stack (protect user stack)\n\
	mv r0, %0\n\
	bl handle_exception\n\
	bl restore_and_return"::"r" (num):"r0", "r1");
}

void _catchException0 ();

asm ("\n\
_catchException0:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #0\n\
	bl process_exception");

void _catchException1 ();

asm ("\n\
_catchException1:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	bl cleanup_stash\n\
	seth r1, #shigh(stackPtr)\n\
	add3 r1, r1, #low(stackPtr)\n\
	ld r15, @@r1		; setup local stack (protect user stack)\n\
	seth r1, #shigh(registers + 21*4) ; PC\n\
	add3 r1, r1, #low(registers + 21*4)\n\
	ld r0, @@r1\n\
	addi r0, #-4		; back up PC for breakpoint trap.\n\
	st r0, @@r1		; FIXME: what about bp in right slot?\n\
	ldi r0, #1\n\
	bl handle_exception\n\
	bl restore_and_return");

void _catchException2 ();

asm ("\n\
_catchException2:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #2\n\
	bl process_exception");

void _catchException3 ();

asm ("\n\
_catchException3:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #3\n\
	bl process_exception");

void _catchException4 ();

asm ("\n\
_catchException4:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #4\n\
	bl process_exception");

void _catchException5 ();

asm ("\n\
_catchException5:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #5\n\
	bl process_exception");

void _catchException6 ();

asm ("\n\
_catchException6:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #6\n\
	bl process_exception");

void _catchException7 ();

asm ("\n\
_catchException7:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #7\n\
	bl process_exception");

void _catchException8 ();

asm ("\n\
_catchException8:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #8\n\
	bl process_exception");

void _catchException9 ();

asm ("\n\
_catchException9:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #9\n\
	bl process_exception");

void _catchException10 ();

asm ("\n\
_catchException10:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #10\n\
	bl process_exception");

void _catchException11 ();

asm ("\n\
_catchException11:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #11\n\
	bl process_exception");

void _catchException12 ();

asm ("\n\
_catchException12:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #12\n\
	bl process_exception");

void _catchException13 ();

asm ("\n\
_catchException13:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #13\n\
	bl process_exception");

void _catchException14 ();

asm ("\n\
_catchException14:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #14\n\
	bl process_exception");

void _catchException15 ();

asm ("\n\
_catchException15:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #15\n\
	bl process_exception");

void _catchException16 ();

asm ("\n\
_catchException16:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #16\n\
	bl process_exception");

void _catchException17 ();

asm ("\n\
_catchException17:\n\
	push lr\n\
	bl stash_registers\n\
	; Note that at this point the pushed value of `lr' has been popped\n\
	ldi r0, #17\n\
	bl process_exception");


/* this function is used to set up exception handlers for tracing and
   breakpoints */
void
set_debug_traps (void)
{
  /*  extern void remcomHandler(); */
  int i;

  for (i = 0; i < 18; i++)	/* keep a copy of old vectors */
    if (save_vectors[i] == 0)	/* only copy them the first time */
      save_vectors[i] = getExceptionHandler (i);

  stackPtr = &remcomStack[STACKSIZE / sizeof (int) - 1];

  exceptionHandler (0, _catchException0);
  exceptionHandler (1, _catchException1);
  exceptionHandler (2, _catchException2);
  exceptionHandler (3, _catchException3);
  exceptionHandler (4, _catchException4);
  exceptionHandler (5, _catchException5);
  exceptionHandler (6, _catchException6);
  exceptionHandler (7, _catchException7);
  exceptionHandler (8, _catchException8);
  exceptionHandler (9, _catchException9);
  exceptionHandler (10, _catchException10);
  exceptionHandler (11, _catchException11);
  exceptionHandler (12, _catchException12);
  exceptionHandler (13, _catchException13);
  exceptionHandler (14, _catchException14);
  exceptionHandler (15, _catchException15);
  exceptionHandler (16, _catchException16);
  /*  exceptionHandler (17, _catchException17); */

  initialized = 1;
}

/* This function will generate a breakpoint exception.  It is used at the
   beginning of a program to sync up with a debugger and can be used
   otherwise as a quick means to stop program execution and "break" into
   the debugger. */

#define BREAKPOINT() asm volatile ("	trap #2");

void
breakpoint (void)
{
  if (initialized)
    BREAKPOINT ();
}

/* STDOUT section:
   Stuff pertaining to simulating stdout by sending chars to gdb to be echoed.
   Functions: gdb_putchar(char ch)
              gdb_puts(char *str)
              gdb_write(char *str, int len)
              gdb_error(char *format, char *parm)
	      */

/* Function: gdb_putchar(int)
   Make gdb write a char to stdout.
   Returns: the char */

static int
gdb_putchar (int ch)
{
  char buf[4];

  buf[0] = 'O';
  buf[1] = hexchars[ch >> 4];
  buf[2] = hexchars[ch & 0x0F];
  buf[3] = 0;
  putpacket (buf);
  return ch;
}

/* Function: gdb_write(char *, int)
   Make gdb write n bytes to stdout (not assumed to be null-terminated).
   Returns: number of bytes written */

static int
gdb_write (char *data, int len)
{
  char *buf, *cpy;
  int i;

  buf = remcomOutBuffer;
  buf[0] = 'O';
  i = 0;
  while (i < len)
    {
      for (cpy = buf + 1;
	   i < len && cpy < buf + sizeof (remcomOutBuffer) - 3; i++)
	{
	  *cpy++ = hexchars[data[i] >> 4];
	  *cpy++ = hexchars[data[i] & 0x0F];
	}
      *cpy = 0;
      putpacket (buf);
    }
  return len;
}

/* Function: gdb_puts(char *)
   Make gdb write a null-terminated string to stdout.
   Returns: the length of the string */

static int
gdb_puts (char *str)
{
  return gdb_write (str, strlen (str));
}

/* Function: gdb_error(char *, char *)
   Send an error message to gdb's stdout.
   First string may have 1 (one) optional "%s" in it, which
   will cause the optional second string to be inserted.  */

static void
gdb_error (char *format, char *parm)
{
  char buf[400], *cpy;
  int len;

  if (remote_debug)
    {
      if (format && *format)
	len = strlen (format);
      else
	return;			/* empty input */

      if (parm && *parm)
	len += strlen (parm);

      for (cpy = buf; *format;)
	{
	  if (format[0] == '%' && format[1] == 's')	/* include second string */
	    {
	      format += 2;	/* advance two chars instead of just one */
	      while (parm && *parm)
		*cpy++ = *parm++;
	    }
	  else
	    *cpy++ = *format++;
	}
      *cpy = '\0';
      gdb_puts (buf);
    }
}

static unsigned char *
strcpy (unsigned char *dest, const unsigned char *src)
{
  unsigned char *ret = dest;

  if (dest && src)
    {
      while (*src)
	*dest++ = *src++;
      *dest = 0;
    }
  return ret;
}

static int
strlen (const unsigned char *src)
{
  int ret;

  for (ret = 0; *src; src++)
    ret++;

  return ret;
}

#if 0
void
exit (code)
     int code;
{
  _exit (code);
}

int
atexit (void *p)
{
  return 0;
}

void
abort (void)
{
  _exit (1);
}
#endif
@


1.3
log
@Protoization.
@
text
@d1291 1
a1291 2
	ld r1, @@r0+	; restore cr0 == PSW
	mvtc r1, cr0
@


1.3.16.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d1291 2
a1292 1
	addi r0, #4	; don't restore PSW (rte will do it)
@


1.3.16.2
log
@merge from mainline
@
text
@d213 2
a214 10
  /* Do not call finish_from_step() if this is not a trap #1
   * (breakpoint trap).  Without this check, the finish_from_step()
   * might interpret a system call trap as a single step trap.  This
   * can happen if: the stub receives 's' and exits, but an interrupt
   * was pending; the interrupt is now handled and causes the stub to
   * be reentered because some function makes a system call.  
   */
  if (exceptionVector == 1)	/* Trap exception? */
    if (!finish_from_step())	/* Go see if stepping state needs update. */
      return;		/* "false step": let the target continue */
@


1.2
log
@From JTC: m32r-stub.c, sparcl-stub.c, sparclet-stub.c
(handle_exception): Return E01 instead of P01 when 'P' command fails.
@
text
@d538 1
a538 4
crc32 (buf, len, crc)
     unsigned char *buf;
     int len;
     unsigned long crc;
d563 1
a563 2
hex(ch)
     unsigned char ch;
d574 1
a574 1
getpacket ()
d650 1
a650 2
putpacket(buffer)
     unsigned char *buffer;
d678 1
a678 1
set_mem_err ()
d689 1
a689 2
mem_safe (addr)
     unsigned char *addr;
d707 1
a707 2
get_char (addr)
     unsigned char *addr;
d720 1
a720 3
set_char (addr, val)
     unsigned char *addr;
     unsigned char val;
d738 1
a738 5
mem2hex(mem, buf, count, may_fault)
     unsigned char* mem;
     unsigned char* buf;
     int   count;
     int   may_fault;
d762 1
a762 5
hex2mem(buf, mem, count, may_fault)
     unsigned char* buf;
     unsigned char* mem;
     int   count;
     int   may_fault;
d787 1
a787 5
bin2mem (buf, mem, count, may_fault)
     unsigned char *buf;
     unsigned char *mem;
     int   count;
     int   may_fault;
d829 1
a829 2
computeSignal(exceptionVector)
     int exceptionVector;
d861 1
a861 3
hexToInt(ptr, intValue)
     unsigned char **ptr;
     int *intValue;
d907 1
a907 2
isShortBranch(instr)
     unsigned char *instr;
d926 1
a926 2
isLongBranch(instr)
     unsigned char *instr;
d952 1
a952 2
isBranch(instr)
     unsigned char *instr;
d961 1
a961 2
willBranch(instr, branchCode)
     unsigned char *instr;
d1016 1
a1016 2
branchDestination(instr, branchCode) 
     unsigned char *instr;
d1047 1
a1047 3
branchSideEffects(instr, branchCode)
     unsigned char *instr;
     int branchCode;
d1157 1
a1157 1
finish_from_step()
d1248 1
a1248 1
cleanup_stash ()
d1316 1
a1316 2
process_exception (num)
     int num;
d1523 1
a1523 1
set_debug_traps()
d1564 1
a1564 1
breakpoint()
d1583 1
a1583 2
gdb_putchar(ch)
     int ch;
d1600 1
a1600 3
gdb_write(data, len)
     char *data;
     int len;
d1628 1
a1628 2
gdb_puts(str)
     char *str;
d1639 1
a1639 3
gdb_error(format, parm)
     char * format;
     char * parm;
@


1.1
log
@Initial revision
@
text
@d182 1
a182 1
static void getpacket(unsigned char *);
d192 1
d207 1
a207 1
  int    sigval;
d309 2
d313 1
a313 1
    getpacket(remcomInBuffer);
d315 1
a315 1
    switch (remcomInBuffer[0]) {
a318 1
	ptr = &remcomInBuffer[1];
a330 1
        ptr = &remcomInBuffer[1];
a351 2
            gdb_error("malformed write memory command: %s",
                      remcomInBuffer);
a356 1
	ptr = &remcomInBuffer[1];
a371 2
	    gdb_error("malformed read memory command: %s",
			remcomInBuffer);
a389 1
	  ptr = &remcomInBuffer[1];
d428 1
a428 1
	  strcpy (remcomOutBuffer, "P01");
d432 1
a432 1
	hex2mem(&remcomInBuffer[1], (unsigned char*) registers, NUMREGBYTES, 0);
d436 1
a438 1
	ptr = &remcomInBuffer[1];
d442 1
a442 1
	if (remcomInBuffer[0] == 's')	/* single-stepping */
d484 1
d488 1
d497 25
d532 33
d577 2
a578 3
static void 
getpacket(buffer)
     unsigned char * buffer;
d580 1
d583 2
a584 3
  int  i;
  int  count;
  unsigned char ch;
d586 10
a595 5
  do {
    /* wait around for the start character, ignore all other characters */
    while ((ch = getDebugChar()) != '$');
    checksum = 0;
    xmitcsum = -1;
d597 13
a609 1
    count = 0;
d611 30
a640 12
    /* now, read until a # or end of buffer is found */
    while (count < BUFMAX) {
      ch = getDebugChar();
      
      if (ch == '#' && (count == 0 || buffer[count-1] != 0x7d))
        break;

      checksum = checksum + ch;
      buffer[count] = ch;
      count = count + 1;
      }
    buffer[count] = 0;
d642 2
a643 13
    if (ch == '#') {
      xmitcsum = hex(getDebugChar()) << 4;
      xmitcsum += hex(getDebugChar());
      if (checksum != xmitcsum) {
        if (remote_debug) {
          unsigned char buf[16];

          mem2hex((unsigned char *) &checksum, buf, 4, 0);
          gdb_error("Bad checksum: my count = %s, ", buf);
          mem2hex((unsigned char *) &xmitcsum, buf, 4, 0);
          gdb_error("sent count = %s\n", buf);
          gdb_error(" -- Bad buffer: \"%s\"\n", buffer); 
        }
d645 2
a646 10
        putDebugChar('-');  /* failed checksum */
      } else {
	putDebugChar('+');  /* successful transfer */
	/* if a sequence char is present, reply the sequence ID */
	if (buffer[2] == ':') {
	  putDebugChar( buffer[0] );
	  putDebugChar( buffer[1] );
	  /* remove sequence chars from buffer */
	  count = strlen(buffer);
	  for (i=3; i <= count; i++) buffer[i-3] = buffer[i];
a647 1
      }
a648 1
  } while (checksum != xmitcsum);
d827 1
a827 1
              *buf += 0x20;
d1056 1
a1056 1
    return (((int) instr) & ~3) + ((unsigned char) instr[1] << 2);
d1059 1
a1059 1
	    ((((unsigned char) instr[1] << 16) | (instr[2] << 8) | (instr[3])) << 2)); 
d1062 1
a1062 1
    return ((int) instr + ((((unsigned char) instr[2] << 8) | (instr[3])) << 2)); 
a1583 4

  /* In case GDB is started before us, ack any packets (presumably
     "$?#xx") sitting there.  */
  putDebugChar ('+');
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a191 1
static unsigned long crc32 (unsigned char *, int, unsigned long);
a488 1

a491 1
#if 0
a499 26
#else
	strcpy(remcomOutBuffer,"OK");
	break;
#endif
    case 'q':
      ptr = &remcomInBuffer[1];
      if (*ptr++ == 'C' &&
	  *ptr++ == 'R' &&
	  *ptr++ == 'C' &&
	  *ptr++ == ':')
	{
	  unsigned long start, len, our_crc;

	  if (hexToInt (&ptr, (int *) &start) &&
	      *ptr++ == ','                   &&
	      hexToInt (&ptr, (int *) &len))
	    {
	      remcomOutBuffer[0] = 'C';
	      our_crc = crc32 ((unsigned char *) start, len, 0xffffffff);
	      mem2hex ((char *) &our_crc, 
		       &remcomOutBuffer[1], 
		       sizeof (long), 
		       0); 
	    } /* else do nothing */
	} /* else do nothing */
      break;
a509 33
/* qCRC support */

/* Table used by the crc32 function to calcuate the checksum. */
static unsigned long crc32_table[256] = {0, 0};

static unsigned long
crc32 (buf, len, crc)
     unsigned char *buf;
     int len;
     unsigned long crc;
{
  if (! crc32_table[1])
    {
      /* Initialize the CRC table and the decoding table. */
      int i, j;
      unsigned long c;

      for (i = 0; i < 256; i++)
	{
	  for (c = i << 24, j = 8; j > 0; --j)
	    c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : (c << 1);
	  crc32_table[i] = c;
	}
    }

  while (len--)
    {
      crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ *buf) & 255];
      buf++;
    }
  return crc;
}

d759 1
a759 1
              *buf |= 0x20;
d988 1
a988 1
    return (((int) instr) & ~3) + ((char) instr[1] << 2);
d991 1
a991 1
	    ((((char) instr[1] << 16) | (instr[2] << 8) | (instr[3])) << 2)); 
d994 1
a994 1
    return ((int) instr + ((((char) instr[2] << 8) | (instr[3])) << 2)); 
@


1.1.1.3
log
@import gdb-1999-08-23 snapshot
@
text
@d1579 4
@


1.1.1.4
log
@import gdb-1999-08-30 snapshot
@
text
@d182 1
a182 1
static unsigned char *getpacket(unsigned char *);
d207 1
a207 1
  int    sigval, stepping;
a308 2
  stepping = 0;

d311 1
a311 1
    ptr = getpacket(remcomInBuffer);
d313 1
a313 1
    switch (*ptr++) {
d317 1
d330 1
d352 2
d359 1
d375 2
d395 1
d438 1
a438 1
	hex2mem(&ptr, (unsigned char*) registers, NUMREGBYTES, 0);
a441 1
	stepping = 1;
d444 1
d448 1
a448 1
	if (stepping)	/* single-stepping */
d508 1
d584 3
a586 3
unsigned char *
getpacket (buffer)
     unsigned char *buffer;
d590 24
a613 2
  int count;
  char ch;
d615 24
a638 61
  while (1)
    {
      /* wait around for the start character, ignore all other characters */
      while ((ch = getDebugChar ()) != '$')
	;

retry:
      checksum = 0;
      xmitcsum = -1;
      count = 0;

      /* now, read until a # or end of buffer is found */
      while (count < BUFMAX)
	{
	  ch = getDebugChar ();
          if (ch == '$')
	    goto retry;
	  if (ch == '#')
	    break;
	  checksum = checksum + ch;
	  buffer[count] = ch;
	  count = count + 1;
	}
      buffer[count] = 0;

      if (ch == '#')
	{
	  ch = getDebugChar ();
	  xmitcsum = hex (ch) << 4;
	  ch = getDebugChar ();
	  xmitcsum += hex (ch);

	  if (checksum != xmitcsum)
	    {
	      if (remote_debug)
		{
		  unsigned char buf[16];

		  mem2hex((unsigned char *) &checksum, buf, 4, 0);
		  gdb_error("Bad checksum: my count = %s, ", buf);
		  mem2hex((unsigned char *) &xmitcsum, buf, 4, 0);
		  gdb_error("sent count = %s\n", buf);
		  gdb_error(" -- Bad buffer: \"%s\"\n", buffer); 
		}
	      putDebugChar ('-');	/* failed checksum */
	    }
	  else
	    {
	      putDebugChar ('+');	/* successful transfer */

	      /* if a sequence char is present, reply the sequence ID */
	      if (buffer[2] == ':')
		{
		  putDebugChar (buffer[0]);
		  putDebugChar (buffer[1]);

		  return &buffer[3];
		}

	      return &buffer[0];
	    }
d640 1
d642 1
@


1.1.1.5
log
@import gdb-1999-09-08 snapshot
@
text
@d182 1
a182 1
static unsigned char *getpacket(void);
d313 1
a313 1
    ptr = getpacket();
d578 2
a579 1
getpacket ()
a580 1
  unsigned char *buffer = &remcomInBuffer[0];
@


1.1.1.6
log
@import gdb-1999-09-28 snapshot
@
text
@d432 1
a432 1
	hex2mem(ptr, (unsigned char*) registers, NUMREGBYTES, 0);
@


