head	1.22;
access;
symbols
	drow_intercu-merge-20040921:1.21
	drow_intercu-merge-20040915:1.21
	jimb-gdb_6_2-e500-branch:1.21.0.16
	jimb-gdb_6_2-e500-branchpoint:1.21
	gdb_6_2-20040730-release:1.21
	gdb_6_2-branch:1.21.0.12
	gdb_6_2-2004-07-10-gmt-branchpoint:1.21
	gdb_6_1_1-20040616-release:1.21
	gdb_6_1-2004-04-05-release:1.21
	drow_intercu-merge-20040402:1.21
	drow_intercu-merge-20040327:1.21
	ezannoni_pie-20040323-branch:1.21.0.10
	ezannoni_pie-20040323-branchpoint:1.21
	cagney_tramp-20040321-mergepoint:1.21
	cagney_tramp-20040309-branch:1.21.0.8
	cagney_tramp-20040309-branchpoint:1.21
	gdb_6_1-branch:1.21.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.21
	drow_intercu-20040221-branch:1.21.0.4
	drow_intercu-20040221-branchpoint:1.21
	cagney_bfdfile-20040213-branch:1.21.0.2
	cagney_bfdfile-20040213-branchpoint:1.21
	drow-cplus-merge-20040208:1.21
	carlton_dictionary-20040126-merge:1.20
	cagney_bigcore-20040122-branch:1.20.0.2
	cagney_bigcore-20040122-branchpoint:1.20
	drow-cplus-merge-20040113:1.20
	drow-cplus-merge-20031224:1.20
	drow-cplus-merge-20031220:1.20
	carlton_dictionary-20031215-merge:1.20
	drow-cplus-merge-20031214:1.20
	carlton-dictionary-20031111-merge:1.20
	gdb_6_0-2003-10-04-release:1.15
	kettenis_sparc-20030918-branch:1.19.0.4
	kettenis_sparc-20030918-branchpoint:1.19
	carlton_dictionary-20030917-merge:1.19
	ezannoni_pie-20030916-branchpoint:1.19
	ezannoni_pie-20030916-branch:1.19.0.2
	cagney_x86i386-20030821-branch:1.16.0.2
	cagney_x86i386-20030821-branchpoint:1.16
	carlton_dictionary-20030805-merge:1.16
	carlton_dictionary-20030627-merge:1.15
	gdb_6_0-branch:1.15.0.2
	gdb_6_0-2003-06-23-branchpoint:1.15
	jimb-ppc64-linux-20030613-branch:1.14.0.18
	jimb-ppc64-linux-20030613-branchpoint:1.14
	cagney_convert-20030606-branch:1.14.0.16
	cagney_convert-20030606-branchpoint:1.14
	cagney_writestrings-20030508-branch:1.14.0.14
	cagney_writestrings-20030508-branchpoint:1.14
	jimb-ppc64-linux-20030528-branch:1.14.0.12
	jimb-ppc64-linux-20030528-branchpoint:1.14
	carlton_dictionary-20030523-merge:1.14
	cagney_fileio-20030521-branch:1.14.0.10
	cagney_fileio-20030521-branchpoint:1.14
	kettenis_i386newframe-20030517-mergepoint:1.14
	jimb-ppc64-linux-20030509-branch:1.14.0.8
	jimb-ppc64-linux-20030509-branchpoint:1.14
	kettenis_i386newframe-20030504-mergepoint:1.14
	carlton_dictionary-20030430-merge:1.14
	kettenis_i386newframe-20030419-branch:1.14.0.6
	kettenis_i386newframe-20030419-branchpoint:1.14
	carlton_dictionary-20030416-merge:1.14
	cagney_frameaddr-20030409-mergepoint:1.14
	kettenis_i386newframe-20030406-branch:1.14.0.4
	kettenis_i386newframe-20030406-branchpoint:1.14
	cagney_frameaddr-20030403-branchpoint:1.14
	cagney_frameaddr-20030403-branch:1.14.0.2
	cagney_framebase-20030330-mergepoint:1.14
	cagney_framebase-20030326-branch:1.13.0.10
	cagney_framebase-20030326-branchpoint:1.13
	cagney_lazyid-20030317-branch:1.13.0.8
	cagney_lazyid-20030317-branchpoint:1.13
	kettenis-i386newframe-20030316-mergepoint:1.13
	offbyone-20030313-branch:1.13.0.6
	offbyone-20030313-branchpoint:1.13
	kettenis-i386newframe-20030308-branch:1.13.0.4
	kettenis-i386newframe-20030308-branchpoint:1.13
	carlton_dictionary-20030305-merge:1.13
	cagney_offbyone-20030303-branch:1.13.0.2
	cagney_offbyone-20030303-branchpoint:1.13
	carlton_dictionary-20030207-merge:1.13
	interps-20030203-mergepoint:1.12
	interps-20030202-branch:1.12.0.4
	interps-20030202-branchpoint:1.12
	cagney-unwind-20030108-branch:1.12.0.2
	cagney-unwind-20030108-branchpoint:1.12
	carlton_dictionary-20021223-merge:1.12
	gdb_5_3-2002-12-12-release:1.11.6.1
	carlton_dictionary-20021115-merge:1.11
	kseitz_interps-20021105-merge:1.11
	kseitz_interps-20021103-merge:1.11
	drow-cplus-merge-20021020:1.11
	drow-cplus-merge-20021025:1.11
	carlton_dictionary-20021025-merge:1.11
	carlton_dictionary-20021011-merge:1.11
	drow-cplus-branch:1.11.0.10
	drow-cplus-branchpoint:1.11
	kseitz_interps-20020930-merge:1.11
	carlton_dictionary-20020927-merge:1.11
	carlton_dictionary-branch:1.11.0.8
	carlton_dictionary-20020920-branchpoint:1.11
	gdb_5_3-branch:1.11.0.6
	gdb_5_3-2002-09-04-branchpoint:1.11
	kseitz_interps-20020829-merge:1.11
	cagney_sysregs-20020825-branch:1.11.0.4
	cagney_sysregs-20020825-branchpoint:1.11
	readline_4_3-import-branch:1.11.0.2
	readline_4_3-import-branchpoint:1.11
	gdb_5_2_1-2002-07-23-release:1.7
	kseitz_interps-20020528-branch:1.9.0.6
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.4
	cagney_regbuf-20020515-branchpoint:1.9
	jimb-macro-020506-branch:1.9.0.2
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.7
	gdb_5_2-branch:1.7.0.2
	gdb_5_2-2002-03-03-branchpoint:1.7;
locks; strict;
comment	@ * @;


1.22
date	2004.09.28.17.29.07;	author cagney;	state dead;
branches;
next	1.21;

1.21
date	2004.02.01.22.35.15;	author roland;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.01.20.36.56;	author ezannoni;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.07.18.49.44;	author drow;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2003.08.27.15.41.41;	author carlton;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.24.13.34.01;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.04.17.08.22;	author carlton;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.19.22.52.03;	author msnyder;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.28.21.42.41;	author jjohnstn;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.07.00.27.30;	author cagney;	state Exp;
branches
	1.13.10.1;
next	1.12;

1.12
date	2002.11.26.01.23.46;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.23.19.06.05;	author kettenis;	state Exp;
branches
	1.11.6.1
	1.11.8.1
	1.11.10.1;
next	1.10;

1.10
date	2002.08.01.22.55.36;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.24.22.09.56;	author drow;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	2002.03.25.19.47.41;	author msnyder;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.24.22.31.19;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.13.20.47.17;	author ezannoni;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.15.20.10.55;	author msnyder;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.14.20.00.47;	author msnyder;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.09.02.21.25;	author msnyder;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.09.00.36.57;	author msnyder;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.08.22.09.46;	author msnyder;	state Exp;
branches;
next	;

1.9.6.1
date	2002.08.09.18.34.25;	author kseitz;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2002.08.30.22.52.44;	author kseitz;	state Exp;
branches;
next	;

1.11.6.1
date	2002.11.26.01.32.21;	author drow;	state Exp;
branches;
next	;

1.11.8.1
date	2002.12.23.19.38.33;	author carlton;	state Exp;
branches;
next	1.11.8.2;

1.11.8.2
date	2003.02.07.19.17.50;	author carlton;	state Exp;
branches;
next	1.11.8.3;

1.11.8.3
date	2003.04.16.19.56.53;	author carlton;	state Exp;
branches;
next	1.11.8.4;

1.11.8.4
date	2003.06.27.21.50.05;	author carlton;	state Exp;
branches;
next	1.11.8.5;

1.11.8.5
date	2003.08.05.17.13.10;	author carlton;	state Exp;
branches;
next	1.11.8.6;

1.11.8.6
date	2003.09.17.21.28.24;	author carlton;	state Exp;
branches;
next	1.11.8.7;

1.11.8.7
date	2003.11.11.23.50.48;	author carlton;	state Exp;
branches;
next	;

1.11.10.1
date	2003.12.14.20.27.20;	author drow;	state Exp;
branches;
next	1.11.10.2;

1.11.10.2
date	2004.02.09.19.43.42;	author drow;	state Exp;
branches;
next	;

1.13.10.1
date	2003.03.30.16.35.21;	author cagney;	state Exp;
branches;
next	;

1.19.2.1
date	2003.09.29.22.40.19;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.22
log
@2004-09-28  Andrew Cagney  <cagney@@gnu.org>

	* linux-proc.c: Delete file.
	* Makefile.in: Update.
	* config/sparc/linux64.mh (NATDEPFILES):
	* config/sparc/linux.mh (NATDEPFILES): Update.
	* config/s390/s390.mh (NATDEPFILES): Update.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Update.
	* config/powerpc/linux.mh (NATDEPFILES): Update.
	* config/pa/linux.mh (NATDEPFILES): Update.
	* config/mips/linux.mh (NATDEPFILES): Update.
	* config/m68k/linux.mh (NATDEPFILES): Update.
	* config/ia64/linux.mh (NATDEPFILES): Update.
	* config/i386/linux64.mh (NATDEPFILES): Update.
	* config/i386/linux.mh (NATDEPFILES): Update.
	* config/arm/linux.mh (NATDEPFILES): Update.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Update.
	* linux-nat.c: Update copyright.  Include <sys/param.h>,
	<sys/procfs.h>, "elf-bfd.h", "gregset.h", <ctype.h>,
	"gdbthread.h", "gdb_stat.h", <fcntl.h>.
	(O_LARGEFILE): Possibly define.
	(_initialize_linux_nat, linux_proc_pending_signals)
	(add_line_to_sigset, linux_proc_xfer_memory)
	(linux_nat_info_proc_cmd, linux_nat_make_corefile_notes)
	(linux_nat_do_registers, linux_nat_corefile_thread_callback)
	(struct linux_corefile_thread_data)
	(linux_nat_do_thread_registers, linux_nat_find_memory_regions)
	(child_pid_to_exec_file): Insert code previously in linux-proc.c.
@
text
@/* GNU/Linux specific methods for using the /proc file system.

   Copyright 2001, 2002 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "inferior.h"
#include <sys/param.h>		/* for MAXPATHLEN */
#include <sys/procfs.h>		/* for elf_gregset etc. */
#include "gdb_stat.h"		/* for struct stat */
#include <ctype.h>		/* for isdigit */
#include <unistd.h>		/* for open, pread64 */
#include <fcntl.h>		/* for O_RDONLY */
#include "regcache.h"		/* for registers_changed */
#include "gregset.h"		/* for gregset */
#include "gdbcore.h"		/* for get_exec_file */
#include "gdbthread.h"		/* for struct thread_info etc. */
#include "elf-bfd.h"		/* for elfcore_write_* */
#include "cli/cli-decode.h"	/* for add_info */
#include "gdb_string.h"

#include <signal.h>

#include "linux-nat.h"

#ifndef O_LARGEFILE
#define O_LARGEFILE 0
#endif

/* Function: child_pid_to_exec_file
 *
 * Accepts an integer pid
 * Returns a string representing a file that can be opened
 * to get the symbols for the child process.
 */

char *
child_pid_to_exec_file (int pid)
{
  char *name1, *name2;

  name1 = xmalloc (MAXPATHLEN);
  name2 = xmalloc (MAXPATHLEN);
  make_cleanup (xfree, name1);
  make_cleanup (xfree, name2);
  memset (name2, 0, MAXPATHLEN);

  sprintf (name1, "/proc/%d/exe", pid);
  if (readlink (name1, name2, MAXPATHLEN) > 0)
    return name2;
  else
    return name1;
}

/* Function: read_mappings
 *
 * Service function for corefiles and info proc.
 */

static int
read_mapping (FILE *mapfile,
	      long long *addr,
	      long long *endaddr,
	      char *permissions,
	      long long *offset,
	      char *device, long long *inode, char *filename)
{
  int ret = fscanf (mapfile, "%llx-%llx %s %llx %s %llx",
		    addr, endaddr, permissions, offset, device, inode);

  if (ret > 0 && ret != EOF && *inode != 0)
    {
      /* Eat everything up to EOL for the filename.  This will prevent
         weird filenames (such as one with embedded whitespace) from
         confusing this code.  It also makes this code more robust
         in respect to annotations the kernel may add after the
         filename.

         Note the filename is used for informational purposes only.  */
      ret += fscanf (mapfile, "%[^\n]\n", filename);
    }
  else
    {
      filename[0] = '\0';	/* no filename */
      fscanf (mapfile, "\n");
    }
  return (ret != 0 && ret != EOF);
}

/* Function: linux_find_memory_regions
 *
 * Fills the "to_find_memory_regions" target vector.
 * Lists the memory regions in the inferior for a corefile.
 */

static int
linux_find_memory_regions (int (*func) (CORE_ADDR,
					unsigned long,
					int, int, int, void *), void *obfd)
{
  long long pid = PIDGET (inferior_ptid);
  char mapsfilename[MAXPATHLEN];
  FILE *mapsfile;
  long long addr, endaddr, size, offset, inode;
  char permissions[8], device[8], filename[MAXPATHLEN];
  int read, write, exec;
  int ret;

  /* Compose the filename for the /proc memory map, and open it. */
  sprintf (mapsfilename, "/proc/%lld/maps", pid);
  if ((mapsfile = fopen (mapsfilename, "r")) == NULL)
    error ("Could not open %s\n", mapsfilename);

  if (info_verbose)
    fprintf_filtered (gdb_stdout,
		      "Reading memory regions from %s\n", mapsfilename);

  /* Now iterate until end-of-file. */
  while (read_mapping (mapsfile, &addr, &endaddr, &permissions[0],
		       &offset, &device[0], &inode, &filename[0]))
    {
      size = endaddr - addr;

      /* Get the segment's permissions.  */
      read = (strchr (permissions, 'r') != 0);
      write = (strchr (permissions, 'w') != 0);
      exec = (strchr (permissions, 'x') != 0);

      if (info_verbose)
	{
	  fprintf_filtered (gdb_stdout,
			    "Save segment, %lld bytes at 0x%s (%c%c%c)",
			    size, paddr_nz (addr),
			    read ? 'r' : ' ',
			    write ? 'w' : ' ', exec ? 'x' : ' ');
	  if (filename && filename[0])
	    fprintf_filtered (gdb_stdout, " for %s", filename);
	  fprintf_filtered (gdb_stdout, "\n");
	}

      /* Invoke the callback function to create the corefile segment. */
      func (addr, size, read, write, exec, obfd);
    }
  fclose (mapsfile);
  return 0;
}

/* Function: linux_do_thread_registers
 *
 * Records the thread's register state for the corefile note section.
 */

static char *
linux_do_thread_registers (bfd *obfd, ptid_t ptid,
			   char *note_data, int *note_size)
{
  gdb_gregset_t gregs;
  gdb_fpregset_t fpregs;
#ifdef FILL_FPXREGSET
  gdb_fpxregset_t fpxregs;
#endif
  unsigned long lwp = ptid_get_lwp (ptid);

  fill_gregset (&gregs, -1);
  note_data = (char *) elfcore_write_prstatus (obfd,
					       note_data,
					       note_size,
					       lwp,
					       stop_signal, &gregs);

  fill_fpregset (&fpregs, -1);
  note_data = (char *) elfcore_write_prfpreg (obfd,
					      note_data,
					      note_size,
					      &fpregs, sizeof (fpregs));
#ifdef FILL_FPXREGSET
  fill_fpxregset (&fpxregs, -1);
  note_data = (char *) elfcore_write_prxfpreg (obfd,
					       note_data,
					       note_size,
					       &fpxregs, sizeof (fpxregs));
#endif
  return note_data;
}

struct linux_corefile_thread_data
{
  bfd *obfd;
  char *note_data;
  int *note_size;
  int num_notes;
};

/* Function: linux_corefile_thread_callback
 *
 * Called by gdbthread.c once per thread.
 * Records the thread's register state for the corefile note section.
 */

static int
linux_corefile_thread_callback (struct lwp_info *ti, void *data)
{
  struct linux_corefile_thread_data *args = data;
  ptid_t saved_ptid = inferior_ptid;

  inferior_ptid = ti->ptid;
  registers_changed ();
  target_fetch_registers (-1);	/* FIXME should not be necessary;
				   fill_gregset should do it automatically. */
  args->note_data = linux_do_thread_registers (args->obfd,
					       ti->ptid,
					       args->note_data,
					       args->note_size);
  args->num_notes++;
  inferior_ptid = saved_ptid;
  registers_changed ();
  target_fetch_registers (-1);	/* FIXME should not be necessary;
				   fill_gregset should do it automatically. */
  return 0;
}

/* Function: linux_do_registers
 *
 * Records the register state for the corefile note section.
 */

static char *
linux_do_registers (bfd *obfd, ptid_t ptid,
		    char *note_data, int *note_size)
{
  registers_changed ();
  target_fetch_registers (-1);	/* FIXME should not be necessary;
				   fill_gregset should do it automatically. */
  return linux_do_thread_registers (obfd,
				    ptid_build (ptid_get_pid (inferior_ptid),
						ptid_get_pid (inferior_ptid),
						0),
				    note_data, note_size);
  return note_data;
}

/* Function: linux_make_note_section
 *
 * Fills the "to_make_corefile_note" target vector.
 * Builds the note section for a corefile, and returns it
 * in a malloc buffer.
 */

static char *
linux_make_note_section (bfd *obfd, int *note_size)
{
  struct linux_corefile_thread_data thread_args;
  struct cleanup *old_chain;
  char fname[16] = { '\0' };
  char psargs[80] = { '\0' };
  char *note_data = NULL;
  ptid_t current_ptid = inferior_ptid;
  char *auxv;
  int auxv_len;

  if (get_exec_file (0))
    {
      strncpy (fname, strrchr (get_exec_file (0), '/') + 1, sizeof (fname));
      strncpy (psargs, get_exec_file (0), sizeof (psargs));
      if (get_inferior_args ())
	{
	  strncat (psargs, " ", sizeof (psargs) - strlen (psargs));
	  strncat (psargs, get_inferior_args (),
		   sizeof (psargs) - strlen (psargs));
	}
      note_data = (char *) elfcore_write_prpsinfo (obfd,
						   note_data,
						   note_size, fname, psargs);
    }

  /* Dump information for threads.  */
  thread_args.obfd = obfd;
  thread_args.note_data = note_data;
  thread_args.note_size = note_size;
  thread_args.num_notes = 0;
  iterate_over_lwps (linux_corefile_thread_callback, &thread_args);
  if (thread_args.num_notes == 0)
    {
      /* iterate_over_threads didn't come up with any threads;
         just use inferior_ptid.  */
      note_data = linux_do_registers (obfd, inferior_ptid,
				      note_data, note_size);
    }
  else
    {
      note_data = thread_args.note_data;
    }

  auxv_len = target_auxv_read (&current_target, &auxv);
  if (auxv_len > 0)
    {
      note_data = elfcore_write_note (obfd, note_data, note_size,
				      "CORE", NT_AUXV, auxv, auxv_len);
      xfree (auxv);
    }

  make_cleanup (xfree, note_data);
  return note_data;
}

/*
 * Function: linux_info_proc_cmd
 *
 * Implement the "info proc" command.
 */

static void
linux_info_proc_cmd (char *args, int from_tty)
{
  long long pid = PIDGET (inferior_ptid);
  FILE *procfile;
  char **argv = NULL;
  char buffer[MAXPATHLEN];
  char fname1[MAXPATHLEN], fname2[MAXPATHLEN];
  int cmdline_f = 1;
  int cwd_f = 1;
  int exe_f = 1;
  int mappings_f = 0;
  int environ_f = 0;
  int status_f = 0;
  int stat_f = 0;
  int all = 0;
  struct stat dummy;

  if (args)
    {
      /* Break up 'args' into an argv array. */
      if ((argv = buildargv (args)) == NULL)
	nomem (0);
      else
	make_cleanup_freeargv (argv);
    }
  while (argv != NULL && *argv != NULL)
    {
      if (isdigit (argv[0][0]))
	{
	  pid = strtoul (argv[0], NULL, 10);
	}
      else if (strncmp (argv[0], "mappings", strlen (argv[0])) == 0)
	{
	  mappings_f = 1;
	}
      else if (strcmp (argv[0], "status") == 0)
	{
	  status_f = 1;
	}
      else if (strcmp (argv[0], "stat") == 0)
	{
	  stat_f = 1;
	}
      else if (strcmp (argv[0], "cmd") == 0)
	{
	  cmdline_f = 1;
	}
      else if (strncmp (argv[0], "exe", strlen (argv[0])) == 0)
	{
	  exe_f = 1;
	}
      else if (strcmp (argv[0], "cwd") == 0)
	{
	  cwd_f = 1;
	}
      else if (strncmp (argv[0], "all", strlen (argv[0])) == 0)
	{
	  all = 1;
	}
      else
	{
	  /* [...] (future options here) */
	}
      argv++;
    }
  if (pid == 0)
    error ("No current process: you must name one.");

  sprintf (fname1, "/proc/%lld", pid);
  if (stat (fname1, &dummy) != 0)
    error ("No /proc directory: '%s'", fname1);

  printf_filtered ("process %lld\n", pid);
  if (cmdline_f || all)
    {
      sprintf (fname1, "/proc/%lld/cmdline", pid);
      if ((procfile = fopen (fname1, "r")) > 0)
	{
	  fgets (buffer, sizeof (buffer), procfile);
	  printf_filtered ("cmdline = '%s'\n", buffer);
	  fclose (procfile);
	}
      else
	warning ("unable to open /proc file '%s'", fname1);
    }
  if (cwd_f || all)
    {
      sprintf (fname1, "/proc/%lld/cwd", pid);
      memset (fname2, 0, sizeof (fname2));
      if (readlink (fname1, fname2, sizeof (fname2)) > 0)
	printf_filtered ("cwd = '%s'\n", fname2);
      else
	warning ("unable to read link '%s'", fname1);
    }
  if (exe_f || all)
    {
      sprintf (fname1, "/proc/%lld/exe", pid);
      memset (fname2, 0, sizeof (fname2));
      if (readlink (fname1, fname2, sizeof (fname2)) > 0)
	printf_filtered ("exe = '%s'\n", fname2);
      else
	warning ("unable to read link '%s'", fname1);
    }
  if (mappings_f || all)
    {
      sprintf (fname1, "/proc/%lld/maps", pid);
      if ((procfile = fopen (fname1, "r")) > 0)
	{
	  long long addr, endaddr, size, offset, inode;
	  char permissions[8], device[8], filename[MAXPATHLEN];

	  printf_filtered ("Mapped address spaces:\n\n");
	  if (TARGET_ADDR_BIT == 32)
	    {
	      printf_filtered ("\t%10s %10s %10s %10s %7s\n",
			   "Start Addr",
			   "  End Addr",
			   "      Size", "    Offset", "objfile");
            }
	  else
            {
	      printf_filtered ("  %18s %18s %10s %10s %7s\n",
			   "Start Addr",
			   "  End Addr",
			   "      Size", "    Offset", "objfile");
	    }

	  while (read_mapping (procfile, &addr, &endaddr, &permissions[0],
			       &offset, &device[0], &inode, &filename[0]))
	    {
	      size = endaddr - addr;

	      /* FIXME: carlton/2003-08-27: Maybe the printf_filtered
		 calls here (and possibly above) should be abstracted
		 out into their own functions?  Andrew suggests using
		 a generic local_address_string instead to print out
		 the addresses; that makes sense to me, too.  */

	      if (TARGET_ADDR_BIT == 32)
	        {
	          printf_filtered ("\t%#10lx %#10lx %#10x %#10x %7s\n",
			       (unsigned long) addr,	/* FIXME: pr_addr */
			       (unsigned long) endaddr,
			       (int) size,
			       (unsigned int) offset,
			       filename[0] ? filename : "");
		}
	      else
	        {
	          printf_filtered ("  %#18lx %#18lx %#10x %#10x %7s\n",
			       (unsigned long) addr,	/* FIXME: pr_addr */
			       (unsigned long) endaddr,
			       (int) size,
			       (unsigned int) offset,
			       filename[0] ? filename : "");
	        }
	    }

	  fclose (procfile);
	}
      else
	warning ("unable to open /proc file '%s'", fname1);
    }
  if (status_f || all)
    {
      sprintf (fname1, "/proc/%lld/status", pid);
      if ((procfile = fopen (fname1, "r")) > 0)
	{
	  while (fgets (buffer, sizeof (buffer), procfile) != NULL)
	    puts_filtered (buffer);
	  fclose (procfile);
	}
      else
	warning ("unable to open /proc file '%s'", fname1);
    }
  if (stat_f || all)
    {
      sprintf (fname1, "/proc/%lld/stat", pid);
      if ((procfile = fopen (fname1, "r")) > 0)
	{
	  int itmp;
	  char ctmp;

	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("Process: %d\n", itmp);
	  if (fscanf (procfile, "%s ", &buffer[0]) > 0)
	    printf_filtered ("Exec file: %s\n", buffer);
	  if (fscanf (procfile, "%c ", &ctmp) > 0)
	    printf_filtered ("State: %c\n", ctmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("Parent process: %d\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("Process group: %d\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("Session id: %d\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("TTY: %d\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("TTY owner process group: %d\n", itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered ("Flags: 0x%x\n", itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered ("Minor faults (no memory page): %u\n",
			     (unsigned int) itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered ("Minor faults, children: %u\n",
			     (unsigned int) itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered ("Major faults (memory page faults): %u\n",
			     (unsigned int) itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered ("Major faults, children: %u\n",
			     (unsigned int) itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("utime: %d\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("stime: %d\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("utime, children: %d\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("stime, children: %d\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("jiffies remaining in current time slice: %d\n",
			     itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("'nice' value: %d\n", itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered ("jiffies until next timeout: %u\n",
			     (unsigned int) itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered ("jiffies until next SIGALRM: %u\n",
			     (unsigned int) itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("start time (jiffies since system boot): %d\n",
			     itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered ("Virtual memory size: %u\n",
			     (unsigned int) itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered ("Resident set size: %u\n", (unsigned int) itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered ("rlim: %u\n", (unsigned int) itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered ("Start of text: 0x%x\n", itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered ("End of text: 0x%x\n", itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)
	    printf_filtered ("Start of stack: 0x%x\n", itmp);
#if 0				/* Don't know how architecture-dependent the rest is...
				   Anyway the signal bitmap info is available from "status".  */
	  if (fscanf (procfile, "%u ", &itmp) > 0)	/* FIXME arch? */
	    printf_filtered ("Kernel stack pointer: 0x%x\n", itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)	/* FIXME arch? */
	    printf_filtered ("Kernel instr pointer: 0x%x\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("Pending signals bitmap: 0x%x\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("Blocked signals bitmap: 0x%x\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("Ignored signals bitmap: 0x%x\n", itmp);
	  if (fscanf (procfile, "%d ", &itmp) > 0)
	    printf_filtered ("Catched signals bitmap: 0x%x\n", itmp);
	  if (fscanf (procfile, "%u ", &itmp) > 0)	/* FIXME arch? */
	    printf_filtered ("wchan (system call): 0x%x\n", itmp);
#endif
	  fclose (procfile);
	}
      else
	warning ("unable to open /proc file '%s'", fname1);
    }
}

void
_initialize_linux_proc (void)
{
  extern void inftarg_set_find_memory_regions ();
  extern void inftarg_set_make_corefile_notes ();

  inftarg_set_find_memory_regions (linux_find_memory_regions);
  inftarg_set_make_corefile_notes (linux_make_note_section);

  add_info ("proc", linux_info_proc_cmd,
	    "Show /proc process information about any running process.\n\
Specify any process id, or use the program being debugged by default.\n\
Specify any of the following keywords for detailed info:\n\
  mappings -- list of mapped memory regions.\n\
  stat     -- list a bunch of random process info.\n\
  status   -- list a different bunch of random process info.\n\
  all      -- list all available /proc info.");
}

int
linux_proc_xfer_memory (CORE_ADDR addr, char *myaddr, int len, int write,
			struct mem_attrib *attrib, struct target_ops *target)
{
  int fd, ret;
  char filename[64];

  if (write)
    return 0;

  /* Don't bother for one word.  */
  if (len < 3 * sizeof (long))
    return 0;

  /* We could keep this file open and cache it - possibly one
     per thread.  That requires some juggling, but is even faster.  */
  sprintf (filename, "/proc/%d/mem", PIDGET (inferior_ptid));
  fd = open (filename, O_RDONLY | O_LARGEFILE);
  if (fd == -1)
    return 0;

  /* If pread64 is available, use it.  It's faster if the kernel
     supports it (only one syscall), and it's 64-bit safe even
     on 32-bit platforms (for instance, SPARC debugging a SPARC64
     application).  */
#ifdef HAVE_PREAD64
  if (pread64 (fd, myaddr, len, addr) != len)
#else
  if (lseek (fd, addr, SEEK_SET) == -1 || read (fd, myaddr, len) != len)
#endif
    ret = 0;
  else
    ret = len;

  close (fd);
  return ret;
}

/* Parse LINE as a signal set and add its set bits to SIGS.  */

static void
linux_proc_add_line_to_sigset (const char *line, sigset_t *sigs)
{
  int len = strlen (line) - 1;
  const char *p;
  int signum;

  if (line[len] != '\n')
    error ("Could not parse signal set: %s", line);

  p = line;
  signum = len * 4;
  while (len-- > 0)
    {
      int digit;

      if (*p >= '0' && *p <= '9')
	digit = *p - '0';
      else if (*p >= 'a' && *p <= 'f')
	digit = *p - 'a' + 10;
      else
	error ("Could not parse signal set: %s", line);

      signum -= 4;

      if (digit & 1)
	sigaddset (sigs, signum + 1);
      if (digit & 2)
	sigaddset (sigs, signum + 2);
      if (digit & 4)
	sigaddset (sigs, signum + 3);
      if (digit & 8)
	sigaddset (sigs, signum + 4);

      p++;
    }
}

/* Find process PID's pending signals from /proc/pid/status and set SIGS
   to match.  */

void
linux_proc_pending_signals (int pid, sigset_t *pending, sigset_t *blocked, sigset_t *ignored)
{
  FILE *procfile;
  char buffer[MAXPATHLEN], fname[MAXPATHLEN];
  int signum;

  sigemptyset (pending);
  sigemptyset (blocked);
  sigemptyset (ignored);
  sprintf (fname, "/proc/%d/status", pid);
  procfile = fopen (fname, "r");
  if (procfile == NULL)
    error ("Could not open %s", fname);

  while (fgets (buffer, MAXPATHLEN, procfile) != NULL)
    {
      /* Normal queued signals are on the SigPnd line in the status
	 file.  However, 2.6 kernels also have a "shared" pending queue
	 for delivering signals to a thread group, so check for a ShdPnd
	 line also.

	 Unfortunately some Red Hat kernels include the shared pending queue
	 but not the ShdPnd status field.  */

      if (strncmp (buffer, "SigPnd:\t", 8) == 0)
	linux_proc_add_line_to_sigset (buffer + 8, pending);
      else if (strncmp (buffer, "ShdPnd:\t", 8) == 0)
	linux_proc_add_line_to_sigset (buffer + 8, pending);
      else if (strncmp (buffer, "SigBlk:\t", 8) == 0)
	linux_proc_add_line_to_sigset (buffer + 8, blocked);
      else if (strncmp (buffer, "SigIgn:\t", 8) == 0)
	linux_proc_add_line_to_sigset (buffer + 8, ignored);
    }

  fclose (procfile);
}
@


1.21
log
@2004-01-28  Roland McGrath  <roland@@redhat.com>

	* procfs.c (procfs_make_note_section): If we can read
	TARGET_OBJECT_AUXV data, add an NT_AUXV note containing it.
	* linux-proc.c (linux_make_note_section): Likewise.
@
text
@@


1.20
log
@2003-09-24  Elena Zannoni  <ezannoni@@redhat.com>

	* linux-proc.c (linux_do_registers): New function.
	(linux_make_note_section): Use linux_do_registers in case of
	single threaded inferior programs.
@
text
@d211 1
a211 1
 * 
d224 1
a224 1
  target_fetch_registers (-1);	/* FIXME should not be necessary; 
d233 1
a233 1
  target_fetch_registers (-1);	/* FIXME should not be necessary; 
d239 1
a239 1
 * 
d248 1
a248 1
  target_fetch_registers (-1);	/* FIXME should not be necessary; 
d261 2
a262 2
 * Builds the note section for a corefile, and returns it 
 * in a malloc buffer. 
d274 2
d310 8
d577 1
a577 1
#if 0				/* Don't know how architecture-dependent the rest is... 
@


1.19
log
@	* lin-lwp.c (detach_callback): Don't call stop_wait_callback.
	(stop_wait_callback): Handle !lp->signalled also.
	(lin_lwp_has_pending, flush_callback): New functions.
	(lin_lwp_wait): Call flush_callback.
	* linux-proc.c (linux_proc_add_line_to_sigset): New function.
	(linux_proc_pending_signals): New function.
	* linux-nat.h (linux_proc_pending_signals): Add prototype.
@
text
@d238 20
d300 2
a301 2
      note_data = linux_do_thread_registers (obfd, inferior_ptid,
					     note_data, note_size);
@


1.19.2.1
log
@2003-09-29  Elena Zannoni  <ezannoni@@redhat.com>

	* exec.c (exec_set_find_memory_regions): Update parameter list.
	* defs.h (exec_set_find_memory_regions): Update parameter list.
	* fbsd-proc.c (fbsd_find_memory_regions): Likewise. Update call to
	function parameter.
	* gcore.c (gcore_create_callback): Update paramter list.
	(objfile_find_memory_regions): Update parameter list. Update calls
	to function parameter.
	* gnu-nat.c (gnu_find_memory_regions): Update parameter
	list. Update calls to function parameter.
	* inftarg.c (inftarg_set_find_memory_regions): Update parameter
	list.
	* linux-proc.c (read_mapping): Prune the leading whitespaces in
	the filename.
	(linux_find_memory_regions): Update parameter list. Update call to
	function parameter.
	* procfs.c (find_memory_regions_callback): Update paremeters and
	calls.
	(proc_find_memory_regions): Update parameters.
	* sol-thread.c (sol_find_memory_regions): Update parameter list.
	* target.h (struct target_ops): Update definition of
	to_find_memory_regions field.
@
text
@a83 2
  char tmp_filename[MAXPATHLEN];
  char *p;
d96 1
a96 7
      ret += fscanf (mapfile, "%[^\n]\n", tmp_filename);

      /* Skip the spaces at the beginning of the filename.  */
      p = tmp_filename;
      while (*p == ' ')
        p++;
      strcpy (filename, p);
d115 1
a115 2
					int, int, int, char *, void *),
			   void *obfd)
d158 1
a158 1
      func (addr, size, read, write, exec, filename, obfd);
@


1.18
log
@2003-08-27  David Carlton  <carlton@@kealia.com>

	From Randolph Chung  <tausq@@debian.org>:
	* linux-proc.c (linux_info_proc_cmd): rework the code so that it
	compiles with -Wformat-nonliteral -Werror.
@
text
@d38 2
d626 81
@


1.17
log
@* linux-proc.c (linux_proc_xfer_memory): Remove comment about
CFLAGS games to reflect reality.
@
text
@a406 1
	  char *header_fmt_string, *data_fmt_string;
d408 1
d411 5
a415 3
	      header_fmt_string = "\t%10s %10s %10s %10s %7s\n";
	      data_fmt_string = "\t%#10lx %#10lx %#10x %#10x %7s\n";
	    }
d417 2
a418 7
	    {
	      header_fmt_string = "  %18s %18s %10s %10s %7s\n";
	      data_fmt_string = "  %#18lx %#18lx %#10x %#10x %7s\n";
	    }

	  printf_filtered ("Mapped address spaces:\n\n");
	  printf_filtered (header_fmt_string,
d422 1
d428 20
a447 1
	      printf_filtered (data_fmt_string, (unsigned long) addr,	/* FIXME: pr_addr */
d452 1
a452 1

@


1.16
log
@2003-08-04  David Carlton  <carlton@@kealia.com>

	* charset.c (cached_iconv_convert): Add __FILE__ and __LINE__ args
	to internal_error call.
	* source.c (forward_search_command): Add "%s" format argument.
	(reverse_search_command): Ditto.
	* top.c (quit_confirm): Ditto.
	* cli/cli-setshow.c (do_setshow_command): Ditto.
	* cp-valprint.c (cp_print_class_method): Replace
	{f,}printf_{un,}filtered by {f,}puts_{un,}filtered.
	(cp_print_class_member): Ditto.
	* event-top.c (command_line_handler): Ditto.
	* linux-proc.c (linux_info_proc_cmd): Ditto.
	* p-typeprint.c (pascal_type_print_base): Ditto.
	* p-valprint.c (pascal_object_print_class_method): Ditto.
	(pascal_object_print_class_member): Ditto.
	* printcmd.c (print_scalar_formatted,printf_command): Ditto.
	* remote.c (remote_cisco_section_offsets): Ditto.
	* top.c (command_line_input): Ditto.
	* utils.c (vwarning,error_stream,quit): Ditto.
	* valprint.c (print_floating,print_binary_chars)
	(print_octal_chars,print_decimal_chars,print_hex_chars): Ditto.

2003-08-04  David Carlton  <carlton@@kealia.com>

	* mi-main.c (mi_error_last_message): Add "%s" second argument to
	xasprintf call.

2003-08-04  David Carlton  <carlton@@kealia.com>

	* generic/gdbtk.c (gdbtk_source_start_file): Add "%s" first
	argument to error call.
	(tk_command): Ditto.
	(view_command): Ditto.
@
text
@d595 1
a595 5
     application).

     We play some autoconf and CFLAGS games to get this declaration
     exposed: -D_XOPEN_SOURCE=500 -D_LARGEFILE64_SOURCE.  And then
     a -D_BSD_SOURCE to counteract the defaults for _XOPEN_SOURCE.  */
@


1.15
log
@2003-06-19  Michael Snyder  <msnyder@@redhat.com>

	* linux-nat.h: New file.
	* linux-nat.c: Include linux-nat.h.
	* lin-lwp.c: Include linux-nat.h.
	Move struct lwp_info def to linux-nat.h.
	* linux-proc.c: Include linux-nat.h.
	(linux_make_note_section): Iterate over lwps instead of threads.
	(linux_do_thread_registers): Use lwp instead of merged pid.
	* config/nm-linux.h: Move miscelaneous def'ns to linux-nat.h.
	* Makefile.in (lin-lwp.o, linux-proc.o, linux-nat.o):
	Add dependency on linux_nat_h.
@
text
@d449 1
a449 1
	    printf_filtered (buffer);
@


1.14
log
@
2003-03-28  Jeff Johnston  <jjohnstn@@redhat.com>

        * thread.c: Reindented.
        * lin-lwp.c: Ditto.
        * linux-proc.c: Ditto.
@
text
@d38 2
d176 1
a176 1
  unsigned long merged_pid = ptid_get_tid (ptid) << 16 | ptid_get_pid (ptid);
d182 1
a182 1
					       merged_pid,
d215 1
a215 1
linux_corefile_thread_callback (struct thread_info *ti, void *data)
d273 1
a273 1
  iterate_over_threads (linux_corefile_thread_callback, &thread_args);
@


1.13
log
@2003-02-06  Andrew Cagney  <ac131313@@redhat.com>

	* linux-proc.c: Include "gdb_stat.h" instead of <sys/stat.h>.
	* cp-valprint.c (cp_print_value_fields): Eliminate STREQN.
	* jv-typeprint.c (java_type_print_base): Ditto.
	* typeprint.c (typedef_print): Eliminate STREQ.
	* cli/cli-script.c (define_command, define_command): Ditto.
	* main.c (captured_main): Ditto.
	* values.c (lookup_internalvar): Ditto.
	* utils.c (safe_strerror, parse_escape): Eliminate assignment
	within `if' conditional.
	* linespec.c (decode_line_2): Ditto.
	* cli/cli-dump.c (bfd_openr_with_cleanup): Ditto.
	(bfd_openw_with_cleanup): Ditto.

Index: mi/ChangeLog
2003-02-06  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Include "gdb_stat.h" instead of <sys/stat.h>.
@
text
@d24 11
a34 11
#include <sys/param.h>	/* for MAXPATHLEN */
#include <sys/procfs.h>	/* for elf_gregset etc. */
#include "gdb_stat.h"	/* for struct stat */
#include <ctype.h>	/* for isdigit */
#include <unistd.h>	/* for open, pread64 */
#include <fcntl.h>	/* for O_RDONLY */
#include "regcache.h"	/* for registers_changed */
#include "gregset.h"	/* for gregset */
#include "gdbcore.h"	/* for get_exec_file */
#include "gdbthread.h"	/* for struct thread_info etc. */
#include "elf-bfd.h"	/* for elfcore_write_* */
d72 7
a78 9
static int 
read_mapping (FILE *mapfile, 
	      long long *addr, 
	      long long *endaddr, 
	      char *permissions, 
	      long long *offset, 
	      char *device, 
	      long long *inode, 
	      char *filename)
d80 1
a80 1
  int ret = fscanf (mapfile,  "%llx-%llx %s %llx %s %llx", 
d86 4
a89 4
       weird filenames (such as one with embedded whitespace) from
       confusing this code.  It also makes this code more robust
       in respect to annotations the kernel may add after the
       filename.
d91 1
a91 1
       Note the filename is used for informational purposes only.  */
d109 1
a109 1
linux_find_memory_regions (int (*func) (CORE_ADDR, 
d111 1
a111 3
					int, int, int,
					void *), 
			   void *obfd)
d127 1
a127 1
    fprintf_filtered (gdb_stdout, 
d131 1
a131 1
  while (read_mapping (mapsfile, &addr, &endaddr, &permissions[0], 
d137 1
a137 1
      read  = (strchr (permissions, 'r') != 0);
d139 1
a139 1
      exec  = (strchr (permissions, 'x') != 0);
d143 5
a147 6
	  fprintf_filtered (gdb_stdout, 
			    "Save segment, %lld bytes at 0x%s (%c%c%c)", 
			    size, paddr_nz (addr), 
			    read  ? 'r' : ' ', 
			    write ? 'w' : ' ',
			    exec  ? 'x' : ' ');
d149 1
a149 2
	    fprintf_filtered (gdb_stdout, 
			      " for %s", filename);
d166 1
a166 1
linux_do_thread_registers (bfd *obfd, ptid_t ptid, 
d177 5
a181 6
  note_data = (char *) elfcore_write_prstatus (obfd, 
					       note_data, 
					       note_size, 
					       merged_pid, 
					       stop_signal, 
					       &gregs);
d184 4
a187 5
  note_data = (char *) elfcore_write_prfpreg (obfd, 
					      note_data, 
					      note_size, 
					      &fpregs, 
					      sizeof (fpregs));
d190 4
a193 5
  note_data = (char *) elfcore_write_prxfpreg (obfd, 
					       note_data, 
					       note_size, 
					       &fpxregs, 
					       sizeof (fpxregs));
d222 3
a224 3
  args->note_data = linux_do_thread_registers (args->obfd, 
					       ti->ptid, 
					       args->note_data, 
d246 2
a247 2
  char fname[16] = {'\0'};
  char psargs[80] = {'\0'};
d254 1
a254 2
      strncpy (psargs, get_exec_file (0), 
	       sizeof (psargs));
d257 2
a258 3
	  strncat (psargs, " ", 
		   sizeof (psargs) - strlen (psargs));
	  strncat (psargs, get_inferior_args (), 
d261 3
a263 5
      note_data = (char *) elfcore_write_prpsinfo (obfd, 
						   note_data, 
						   note_size, 
						   fname, 
						   psargs);
d275 2
a276 2
	 just use inferior_ptid.  */
      note_data = linux_do_thread_registers (obfd, inferior_ptid, 
d410 1
a410 1
	      data_fmt_string   = "\t%#10lx %#10lx %#10x %#10x %7s\n";
d415 1
a415 1
	      data_fmt_string   = "  %#18lx %#18lx %#10x %#10x %7s\n";
d419 1
a419 1
	  printf_filtered (header_fmt_string, 
d422 3
a424 5
			   "      Size",
			   "    Offset",
			   "objfile");
	  
	  while (read_mapping (procfile, &addr, &endaddr, &permissions[0], 
d428 4
a431 5
	      printf_filtered (data_fmt_string, 
			       (unsigned long) addr, /* FIXME: pr_addr */
			       (unsigned long) endaddr, 
			       (int) size, 
			       (unsigned int) offset, 
d433 1
a433 1
	      
d450 1
a450 1
      else 
d480 1
a480 1
	    printf_filtered ("Minor faults (no memory page): %u\n", 
d483 1
a483 1
	    printf_filtered ("Minor faults, children: %u\n", 
d486 1
a486 1
	    printf_filtered ("Major faults (memory page faults): %u\n", 
d489 1
a489 1
	    printf_filtered ("Major faults, children: %u\n", 
d500 1
a500 1
	    printf_filtered ("jiffies remaining in current time slice: %d\n", 
d505 1
a505 1
	    printf_filtered ("jiffies until next timeout: %u\n", 
d508 1
a508 1
	    printf_filtered ("jiffies until next SIGALRM: %u\n", 
d511 1
a511 1
	    printf_filtered ("start time (jiffies since system boot): %d\n", 
d514 1
a514 1
	    printf_filtered ("Virtual memory size: %u\n", 
d517 1
a517 2
	    printf_filtered ("Resident set size: %u\n", 
			     (unsigned int) itmp);
d519 1
a519 2
	    printf_filtered ("rlim: %u\n", 
			     (unsigned int) itmp);
d526 2
a527 2
#if 0	/* Don't know how architecture-dependent the rest is... 
	   Anyway the signal bitmap info is available from "status".  */
d559 1
a559 1
  add_info ("proc", linux_info_proc_cmd, 
d569 3
a571 3
int linux_proc_xfer_memory (CORE_ADDR addr, char *myaddr, int len, int write,
			    struct mem_attrib *attrib,
			    struct target_ops *target)
d601 1
a601 2
  if (lseek (fd, addr, SEEK_SET) == -1
      || read (fd, myaddr, len) != len)
@


1.13.10.1
log
@Merge with mainline.
@
text
@d24 11
a34 11
#include <sys/param.h>		/* for MAXPATHLEN */
#include <sys/procfs.h>		/* for elf_gregset etc. */
#include "gdb_stat.h"		/* for struct stat */
#include <ctype.h>		/* for isdigit */
#include <unistd.h>		/* for open, pread64 */
#include <fcntl.h>		/* for O_RDONLY */
#include "regcache.h"		/* for registers_changed */
#include "gregset.h"		/* for gregset */
#include "gdbcore.h"		/* for get_exec_file */
#include "gdbthread.h"		/* for struct thread_info etc. */
#include "elf-bfd.h"		/* for elfcore_write_* */
d72 9
a80 7
static int
read_mapping (FILE *mapfile,
	      long long *addr,
	      long long *endaddr,
	      char *permissions,
	      long long *offset,
	      char *device, long long *inode, char *filename)
d82 1
a82 1
  int ret = fscanf (mapfile, "%llx-%llx %s %llx %s %llx",
d88 4
a91 4
         weird filenames (such as one with embedded whitespace) from
         confusing this code.  It also makes this code more robust
         in respect to annotations the kernel may add after the
         filename.
d93 1
a93 1
         Note the filename is used for informational purposes only.  */
d111 1
a111 1
linux_find_memory_regions (int (*func) (CORE_ADDR,
d113 3
a115 1
					int, int, int, void *), void *obfd)
d131 1
a131 1
    fprintf_filtered (gdb_stdout,
d135 1
a135 1
  while (read_mapping (mapsfile, &addr, &endaddr, &permissions[0],
d141 1
a141 1
      read = (strchr (permissions, 'r') != 0);
d143 1
a143 1
      exec = (strchr (permissions, 'x') != 0);
d147 6
a152 5
	  fprintf_filtered (gdb_stdout,
			    "Save segment, %lld bytes at 0x%s (%c%c%c)",
			    size, paddr_nz (addr),
			    read ? 'r' : ' ',
			    write ? 'w' : ' ', exec ? 'x' : ' ');
d154 2
a155 1
	    fprintf_filtered (gdb_stdout, " for %s", filename);
d172 1
a172 1
linux_do_thread_registers (bfd *obfd, ptid_t ptid,
d183 6
a188 5
  note_data = (char *) elfcore_write_prstatus (obfd,
					       note_data,
					       note_size,
					       merged_pid,
					       stop_signal, &gregs);
d191 5
a195 4
  note_data = (char *) elfcore_write_prfpreg (obfd,
					      note_data,
					      note_size,
					      &fpregs, sizeof (fpregs));
d198 5
a202 4
  note_data = (char *) elfcore_write_prxfpreg (obfd,
					       note_data,
					       note_size,
					       &fpxregs, sizeof (fpxregs));
d231 3
a233 3
  args->note_data = linux_do_thread_registers (args->obfd,
					       ti->ptid,
					       args->note_data,
d255 2
a256 2
  char fname[16] = { '\0' };
  char psargs[80] = { '\0' };
d263 2
a264 1
      strncpy (psargs, get_exec_file (0), sizeof (psargs));
d267 3
a269 2
	  strncat (psargs, " ", sizeof (psargs) - strlen (psargs));
	  strncat (psargs, get_inferior_args (),
d272 5
a276 3
      note_data = (char *) elfcore_write_prpsinfo (obfd,
						   note_data,
						   note_size, fname, psargs);
d288 2
a289 2
         just use inferior_ptid.  */
      note_data = linux_do_thread_registers (obfd, inferior_ptid,
d423 1
a423 1
	      data_fmt_string = "\t%#10lx %#10lx %#10x %#10x %7s\n";
d428 1
a428 1
	      data_fmt_string = "  %#18lx %#18lx %#10x %#10x %7s\n";
d432 1
a432 1
	  printf_filtered (header_fmt_string,
d435 5
a439 3
			   "      Size", "    Offset", "objfile");

	  while (read_mapping (procfile, &addr, &endaddr, &permissions[0],
d443 5
a447 4
	      printf_filtered (data_fmt_string, (unsigned long) addr,	/* FIXME: pr_addr */
			       (unsigned long) endaddr,
			       (int) size,
			       (unsigned int) offset,
d449 1
a449 1

d466 1
a466 1
      else
d496 1
a496 1
	    printf_filtered ("Minor faults (no memory page): %u\n",
d499 1
a499 1
	    printf_filtered ("Minor faults, children: %u\n",
d502 1
a502 1
	    printf_filtered ("Major faults (memory page faults): %u\n",
d505 1
a505 1
	    printf_filtered ("Major faults, children: %u\n",
d516 1
a516 1
	    printf_filtered ("jiffies remaining in current time slice: %d\n",
d521 1
a521 1
	    printf_filtered ("jiffies until next timeout: %u\n",
d524 1
a524 1
	    printf_filtered ("jiffies until next SIGALRM: %u\n",
d527 1
a527 1
	    printf_filtered ("start time (jiffies since system boot): %d\n",
d530 1
a530 1
	    printf_filtered ("Virtual memory size: %u\n",
d533 2
a534 1
	    printf_filtered ("Resident set size: %u\n", (unsigned int) itmp);
d536 2
a537 1
	    printf_filtered ("rlim: %u\n", (unsigned int) itmp);
d544 2
a545 2
#if 0				/* Don't know how architecture-dependent the rest is... 
				   Anyway the signal bitmap info is available from "status".  */
d577 1
a577 1
  add_info ("proc", linux_info_proc_cmd,
d587 3
a589 3
int
linux_proc_xfer_memory (CORE_ADDR addr, char *myaddr, int len, int write,
			struct mem_attrib *attrib, struct target_ops *target)
d619 2
a620 1
  if (lseek (fd, addr, SEEK_SET) == -1 || read (fd, myaddr, len) != len)
@


1.12
log
@	* acconfig.h (HAVE_PREAD64): Add.
	* configure.in: Check for pread64.
	* config.in: Regenerated.
	* configure: Regenerated.
	* lin-lwp.c (lin_lwp_xfer_memory): Call linux_proc_xfer_memory.
	* linux-proc.c (linux_proc_xfer_memory): New function.
	* config/nm-linux.h (linux_proc_xfer_memory): Add prototype.
@
text
@d26 1
a26 1
#include <sys/stat.h>	/* for struct stat */
@


1.11
log
@* linux-proc.c (struct linux_corefile_thread_data): Add num_notes
member.
(linux_corefile_thread_callback): Increase args->num_notes.
(linux_make_note_section): Initialize thread_args.num_notes, and
use it to determine whether notes for any threads were created.
@
text
@d28 2
d38 4
d585 43
@


1.11.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d24 9
a32 11
#include <sys/param.h>		/* for MAXPATHLEN */
#include <sys/procfs.h>		/* for elf_gregset etc. */
#include "gdb_stat.h"		/* for struct stat */
#include <ctype.h>		/* for isdigit */
#include <unistd.h>		/* for open, pread64 */
#include <fcntl.h>		/* for O_RDONLY */
#include "regcache.h"		/* for registers_changed */
#include "gregset.h"		/* for gregset */
#include "gdbcore.h"		/* for get_exec_file */
#include "gdbthread.h"		/* for struct thread_info etc. */
#include "elf-bfd.h"		/* for elfcore_write_* */
a35 8
#include <signal.h>

#include "linux-nat.h"

#ifndef O_LARGEFILE
#define O_LARGEFILE 0
#endif

d66 9
a74 7
static int
read_mapping (FILE *mapfile,
	      long long *addr,
	      long long *endaddr,
	      char *permissions,
	      long long *offset,
	      char *device, long long *inode, char *filename)
d76 1
a76 1
  int ret = fscanf (mapfile, "%llx-%llx %s %llx %s %llx",
d82 4
a85 4
         weird filenames (such as one with embedded whitespace) from
         confusing this code.  It also makes this code more robust
         in respect to annotations the kernel may add after the
         filename.
d87 1
a87 1
         Note the filename is used for informational purposes only.  */
d105 1
a105 1
linux_find_memory_regions (int (*func) (CORE_ADDR,
d107 3
a109 1
					int, int, int, void *), void *obfd)
d125 1
a125 1
    fprintf_filtered (gdb_stdout,
d129 1
a129 1
  while (read_mapping (mapsfile, &addr, &endaddr, &permissions[0],
d135 1
a135 1
      read = (strchr (permissions, 'r') != 0);
d137 1
a137 1
      exec = (strchr (permissions, 'x') != 0);
d141 6
a146 5
	  fprintf_filtered (gdb_stdout,
			    "Save segment, %lld bytes at 0x%s (%c%c%c)",
			    size, paddr_nz (addr),
			    read ? 'r' : ' ',
			    write ? 'w' : ' ', exec ? 'x' : ' ');
d148 2
a149 1
	    fprintf_filtered (gdb_stdout, " for %s", filename);
d166 1
a166 1
linux_do_thread_registers (bfd *obfd, ptid_t ptid,
d174 1
a174 1
  unsigned long lwp = ptid_get_lwp (ptid);
d177 6
a182 5
  note_data = (char *) elfcore_write_prstatus (obfd,
					       note_data,
					       note_size,
					       lwp,
					       stop_signal, &gregs);
d185 5
a189 4
  note_data = (char *) elfcore_write_prfpreg (obfd,
					      note_data,
					      note_size,
					      &fpregs, sizeof (fpregs));
d192 5
a196 4
  note_data = (char *) elfcore_write_prxfpreg (obfd,
					       note_data,
					       note_size,
					       &fpxregs, sizeof (fpxregs));
d216 1
a216 1
linux_corefile_thread_callback (struct lwp_info *ti, void *data)
d225 3
a227 3
  args->note_data = linux_do_thread_registers (args->obfd,
					       ti->ptid,
					       args->note_data,
a236 20
/* Function: linux_do_registers
 * 
 * Records the register state for the corefile note section.
 */

static char *
linux_do_registers (bfd *obfd, ptid_t ptid,
		    char *note_data, int *note_size)
{
  registers_changed ();
  target_fetch_registers (-1);	/* FIXME should not be necessary; 
				   fill_gregset should do it automatically. */
  return linux_do_thread_registers (obfd,
				    ptid_build (ptid_get_pid (inferior_ptid),
						ptid_get_pid (inferior_ptid),
						0),
				    note_data, note_size);
  return note_data;
}

d249 2
a250 2
  char fname[16] = { '\0' };
  char psargs[80] = { '\0' };
d257 2
a258 1
      strncpy (psargs, get_exec_file (0), sizeof (psargs));
d261 3
a263 2
	  strncat (psargs, " ", sizeof (psargs) - strlen (psargs));
	  strncat (psargs, get_inferior_args (),
d266 5
a270 3
      note_data = (char *) elfcore_write_prpsinfo (obfd,
						   note_data,
						   note_size, fname, psargs);
d278 1
a278 1
  iterate_over_lwps (linux_corefile_thread_callback, &thread_args);
d282 3
a284 3
         just use inferior_ptid.  */
      note_data = linux_do_registers (obfd, inferior_ptid,
				      note_data, note_size);
d412 1
a413 1
	  printf_filtered ("Mapped address spaces:\n\n");
d416 3
a418 5
	      printf_filtered ("\t%10s %10s %10s %10s %7s\n",
			   "Start Addr",
			   "  End Addr",
			   "      Size", "    Offset", "objfile");
            }
d420 7
a426 2
            {
	      printf_filtered ("  %18s %18s %10s %10s %7s\n",
d429 5
a433 4
			   "      Size", "    Offset", "objfile");
	    }

	  while (read_mapping (procfile, &addr, &endaddr, &permissions[0],
d437 5
a441 23

	      /* FIXME: carlton/2003-08-27: Maybe the printf_filtered
		 calls here (and possibly above) should be abstracted
		 out into their own functions?  Andrew suggests using
		 a generic local_address_string instead to print out
		 the addresses; that makes sense to me, too.  */

	      if (TARGET_ADDR_BIT == 32)
	        {
	          printf_filtered ("\t%#10lx %#10lx %#10x %#10x %7s\n",
			       (unsigned long) addr,	/* FIXME: pr_addr */
			       (unsigned long) endaddr,
			       (int) size,
			       (unsigned int) offset,
			       filename[0] ? filename : "");
		}
	      else
	        {
	          printf_filtered ("  %#18lx %#18lx %#10x %#10x %7s\n",
			       (unsigned long) addr,	/* FIXME: pr_addr */
			       (unsigned long) endaddr,
			       (int) size,
			       (unsigned int) offset,
d443 1
a443 1
	        }
d457 1
a457 1
	    puts_filtered (buffer);
d460 1
a460 1
      else
d490 1
a490 1
	    printf_filtered ("Minor faults (no memory page): %u\n",
d493 1
a493 1
	    printf_filtered ("Minor faults, children: %u\n",
d496 1
a496 1
	    printf_filtered ("Major faults (memory page faults): %u\n",
d499 1
a499 1
	    printf_filtered ("Major faults, children: %u\n",
d510 1
a510 1
	    printf_filtered ("jiffies remaining in current time slice: %d\n",
d515 1
a515 1
	    printf_filtered ("jiffies until next timeout: %u\n",
d518 1
a518 1
	    printf_filtered ("jiffies until next SIGALRM: %u\n",
d521 1
a521 1
	    printf_filtered ("start time (jiffies since system boot): %d\n",
d524 1
a524 1
	    printf_filtered ("Virtual memory size: %u\n",
d527 2
a528 1
	    printf_filtered ("Resident set size: %u\n", (unsigned int) itmp);
d530 2
a531 1
	    printf_filtered ("rlim: %u\n", (unsigned int) itmp);
d538 2
a539 2
#if 0				/* Don't know how architecture-dependent the rest is... 
				   Anyway the signal bitmap info is available from "status".  */
d571 1
a571 1
  add_info ("proc", linux_info_proc_cmd,
a578 119
}

int
linux_proc_xfer_memory (CORE_ADDR addr, char *myaddr, int len, int write,
			struct mem_attrib *attrib, struct target_ops *target)
{
  int fd, ret;
  char filename[64];

  if (write)
    return 0;

  /* Don't bother for one word.  */
  if (len < 3 * sizeof (long))
    return 0;

  /* We could keep this file open and cache it - possibly one
     per thread.  That requires some juggling, but is even faster.  */
  sprintf (filename, "/proc/%d/mem", PIDGET (inferior_ptid));
  fd = open (filename, O_RDONLY | O_LARGEFILE);
  if (fd == -1)
    return 0;

  /* If pread64 is available, use it.  It's faster if the kernel
     supports it (only one syscall), and it's 64-bit safe even
     on 32-bit platforms (for instance, SPARC debugging a SPARC64
     application).  */
#ifdef HAVE_PREAD64
  if (pread64 (fd, myaddr, len, addr) != len)
#else
  if (lseek (fd, addr, SEEK_SET) == -1 || read (fd, myaddr, len) != len)
#endif
    ret = 0;
  else
    ret = len;

  close (fd);
  return ret;
}

/* Parse LINE as a signal set and add its set bits to SIGS.  */

static void
linux_proc_add_line_to_sigset (const char *line, sigset_t *sigs)
{
  int len = strlen (line) - 1;
  const char *p;
  int signum;

  if (line[len] != '\n')
    error ("Could not parse signal set: %s", line);

  p = line;
  signum = len * 4;
  while (len-- > 0)
    {
      int digit;

      if (*p >= '0' && *p <= '9')
	digit = *p - '0';
      else if (*p >= 'a' && *p <= 'f')
	digit = *p - 'a' + 10;
      else
	error ("Could not parse signal set: %s", line);

      signum -= 4;

      if (digit & 1)
	sigaddset (sigs, signum + 1);
      if (digit & 2)
	sigaddset (sigs, signum + 2);
      if (digit & 4)
	sigaddset (sigs, signum + 3);
      if (digit & 8)
	sigaddset (sigs, signum + 4);

      p++;
    }
}

/* Find process PID's pending signals from /proc/pid/status and set SIGS
   to match.  */

void
linux_proc_pending_signals (int pid, sigset_t *pending, sigset_t *blocked, sigset_t *ignored)
{
  FILE *procfile;
  char buffer[MAXPATHLEN], fname[MAXPATHLEN];
  int signum;

  sigemptyset (pending);
  sigemptyset (blocked);
  sigemptyset (ignored);
  sprintf (fname, "/proc/%d/status", pid);
  procfile = fopen (fname, "r");
  if (procfile == NULL)
    error ("Could not open %s", fname);

  while (fgets (buffer, MAXPATHLEN, procfile) != NULL)
    {
      /* Normal queued signals are on the SigPnd line in the status
	 file.  However, 2.6 kernels also have a "shared" pending queue
	 for delivering signals to a thread group, so check for a ShdPnd
	 line also.

	 Unfortunately some Red Hat kernels include the shared pending queue
	 but not the ShdPnd status field.  */

      if (strncmp (buffer, "SigPnd:\t", 8) == 0)
	linux_proc_add_line_to_sigset (buffer + 8, pending);
      else if (strncmp (buffer, "ShdPnd:\t", 8) == 0)
	linux_proc_add_line_to_sigset (buffer + 8, pending);
      else if (strncmp (buffer, "SigBlk:\t", 8) == 0)
	linux_proc_add_line_to_sigset (buffer + 8, blocked);
      else if (strncmp (buffer, "SigIgn:\t", 8) == 0)
	linux_proc_add_line_to_sigset (buffer + 8, ignored);
    }

  fclose (procfile);
@


1.11.10.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d211 1
a211 1
 *
d224 1
a224 1
  target_fetch_registers (-1);	/* FIXME should not be necessary;
d233 1
a233 1
  target_fetch_registers (-1);	/* FIXME should not be necessary;
d239 1
a239 1
 *
d248 1
a248 1
  target_fetch_registers (-1);	/* FIXME should not be necessary;
d261 2
a262 2
 * Builds the note section for a corefile, and returns it
 * in a malloc buffer.
a273 2
  char *auxv;
  int auxv_len;
a307 8
  auxv_len = target_auxv_read (&current_target, &auxv);
  if (auxv_len > 0)
    {
      note_data = elfcore_write_note (obfd, note_data, note_size,
				      "CORE", NT_AUXV, auxv, auxv_len);
      xfree (auxv);
    }

d567 1
a567 1
#if 0				/* Don't know how architecture-dependent the rest is...
@


1.11.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a27 2
#include <unistd.h>	/* for open, pread64 */
#include <fcntl.h>	/* for O_RDONLY */
a35 4
#ifndef O_LARGEFILE
#define O_LARGEFILE 0
#endif

a578 43
}

int linux_proc_xfer_memory (CORE_ADDR addr, char *myaddr, int len, int write,
			    struct mem_attrib *attrib,
			    struct target_ops *target)
{
  int fd, ret;
  char filename[64];

  if (write)
    return 0;

  /* Don't bother for one word.  */
  if (len < 3 * sizeof (long))
    return 0;

  /* We could keep this file open and cache it - possibly one
     per thread.  That requires some juggling, but is even faster.  */
  sprintf (filename, "/proc/%d/mem", PIDGET (inferior_ptid));
  fd = open (filename, O_RDONLY | O_LARGEFILE);
  if (fd == -1)
    return 0;

  /* If pread64 is available, use it.  It's faster if the kernel
     supports it (only one syscall), and it's 64-bit safe even
     on 32-bit platforms (for instance, SPARC debugging a SPARC64
     application).

     We play some autoconf and CFLAGS games to get this declaration
     exposed: -D_XOPEN_SOURCE=500 -D_LARGEFILE64_SOURCE.  And then
     a -D_BSD_SOURCE to counteract the defaults for _XOPEN_SOURCE.  */
#ifdef HAVE_PREAD64
  if (pread64 (fd, myaddr, len, addr) != len)
#else
  if (lseek (fd, addr, SEEK_SET) == -1
      || read (fd, myaddr, len) != len)
#endif
    ret = 0;
  else
    ret = len;

  close (fd);
  return ret;
@


1.11.8.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d26 1
a26 1
#include "gdb_stat.h"	/* for struct stat */
@


1.11.8.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d24 11
a34 11
#include <sys/param.h>		/* for MAXPATHLEN */
#include <sys/procfs.h>		/* for elf_gregset etc. */
#include "gdb_stat.h"		/* for struct stat */
#include <ctype.h>		/* for isdigit */
#include <unistd.h>		/* for open, pread64 */
#include <fcntl.h>		/* for O_RDONLY */
#include "regcache.h"		/* for registers_changed */
#include "gregset.h"		/* for gregset */
#include "gdbcore.h"		/* for get_exec_file */
#include "gdbthread.h"		/* for struct thread_info etc. */
#include "elf-bfd.h"		/* for elfcore_write_* */
d72 9
a80 7
static int
read_mapping (FILE *mapfile,
	      long long *addr,
	      long long *endaddr,
	      char *permissions,
	      long long *offset,
	      char *device, long long *inode, char *filename)
d82 1
a82 1
  int ret = fscanf (mapfile, "%llx-%llx %s %llx %s %llx",
d88 4
a91 4
         weird filenames (such as one with embedded whitespace) from
         confusing this code.  It also makes this code more robust
         in respect to annotations the kernel may add after the
         filename.
d93 1
a93 1
         Note the filename is used for informational purposes only.  */
d111 1
a111 1
linux_find_memory_regions (int (*func) (CORE_ADDR,
d113 3
a115 1
					int, int, int, void *), void *obfd)
d131 1
a131 1
    fprintf_filtered (gdb_stdout,
d135 1
a135 1
  while (read_mapping (mapsfile, &addr, &endaddr, &permissions[0],
d141 1
a141 1
      read = (strchr (permissions, 'r') != 0);
d143 1
a143 1
      exec = (strchr (permissions, 'x') != 0);
d147 6
a152 5
	  fprintf_filtered (gdb_stdout,
			    "Save segment, %lld bytes at 0x%s (%c%c%c)",
			    size, paddr_nz (addr),
			    read ? 'r' : ' ',
			    write ? 'w' : ' ', exec ? 'x' : ' ');
d154 2
a155 1
	    fprintf_filtered (gdb_stdout, " for %s", filename);
d172 1
a172 1
linux_do_thread_registers (bfd *obfd, ptid_t ptid,
d183 6
a188 5
  note_data = (char *) elfcore_write_prstatus (obfd,
					       note_data,
					       note_size,
					       merged_pid,
					       stop_signal, &gregs);
d191 5
a195 4
  note_data = (char *) elfcore_write_prfpreg (obfd,
					      note_data,
					      note_size,
					      &fpregs, sizeof (fpregs));
d198 5
a202 4
  note_data = (char *) elfcore_write_prxfpreg (obfd,
					       note_data,
					       note_size,
					       &fpxregs, sizeof (fpxregs));
d231 3
a233 3
  args->note_data = linux_do_thread_registers (args->obfd,
					       ti->ptid,
					       args->note_data,
d255 2
a256 2
  char fname[16] = { '\0' };
  char psargs[80] = { '\0' };
d263 2
a264 1
      strncpy (psargs, get_exec_file (0), sizeof (psargs));
d267 3
a269 2
	  strncat (psargs, " ", sizeof (psargs) - strlen (psargs));
	  strncat (psargs, get_inferior_args (),
d272 5
a276 3
      note_data = (char *) elfcore_write_prpsinfo (obfd,
						   note_data,
						   note_size, fname, psargs);
d288 2
a289 2
         just use inferior_ptid.  */
      note_data = linux_do_thread_registers (obfd, inferior_ptid,
d423 1
a423 1
	      data_fmt_string = "\t%#10lx %#10lx %#10x %#10x %7s\n";
d428 1
a428 1
	      data_fmt_string = "  %#18lx %#18lx %#10x %#10x %7s\n";
d432 1
a432 1
	  printf_filtered (header_fmt_string,
d435 5
a439 3
			   "      Size", "    Offset", "objfile");

	  while (read_mapping (procfile, &addr, &endaddr, &permissions[0],
d443 5
a447 4
	      printf_filtered (data_fmt_string, (unsigned long) addr,	/* FIXME: pr_addr */
			       (unsigned long) endaddr,
			       (int) size,
			       (unsigned int) offset,
d449 1
a449 1

d466 1
a466 1
      else
d496 1
a496 1
	    printf_filtered ("Minor faults (no memory page): %u\n",
d499 1
a499 1
	    printf_filtered ("Minor faults, children: %u\n",
d502 1
a502 1
	    printf_filtered ("Major faults (memory page faults): %u\n",
d505 1
a505 1
	    printf_filtered ("Major faults, children: %u\n",
d516 1
a516 1
	    printf_filtered ("jiffies remaining in current time slice: %d\n",
d521 1
a521 1
	    printf_filtered ("jiffies until next timeout: %u\n",
d524 1
a524 1
	    printf_filtered ("jiffies until next SIGALRM: %u\n",
d527 1
a527 1
	    printf_filtered ("start time (jiffies since system boot): %d\n",
d530 1
a530 1
	    printf_filtered ("Virtual memory size: %u\n",
d533 2
a534 1
	    printf_filtered ("Resident set size: %u\n", (unsigned int) itmp);
d536 2
a537 1
	    printf_filtered ("rlim: %u\n", (unsigned int) itmp);
d544 2
a545 2
#if 0				/* Don't know how architecture-dependent the rest is... 
				   Anyway the signal bitmap info is available from "status".  */
d577 1
a577 1
  add_info ("proc", linux_info_proc_cmd,
d587 3
a589 3
int
linux_proc_xfer_memory (CORE_ADDR addr, char *myaddr, int len, int write,
			struct mem_attrib *attrib, struct target_ops *target)
d619 2
a620 1
  if (lseek (fd, addr, SEEK_SET) == -1 || read (fd, myaddr, len) != len)
@


1.11.8.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a37 2
#include "linux-nat.h"

d174 1
a174 1
  unsigned long lwp = ptid_get_lwp (ptid);
d180 1
a180 1
					       lwp,
d213 1
a213 1
linux_corefile_thread_callback (struct lwp_info *ti, void *data)
d271 1
a271 1
  iterate_over_lwps (linux_corefile_thread_callback, &thread_args);
@


1.11.8.5
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d449 1
a449 1
	    puts_filtered (buffer);
@


1.11.8.6
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a37 2
#include <signal.h>

d407 1
a408 1
	  printf_filtered ("Mapped address spaces:\n\n");
d411 3
a413 5
	      printf_filtered ("\t%10s %10s %10s %10s %7s\n",
			   "Start Addr",
			   "  End Addr",
			   "      Size", "    Offset", "objfile");
            }
d415 7
a421 2
            {
	      printf_filtered ("  %18s %18s %10s %10s %7s\n",
a424 1
	    }
d430 1
a430 11

	      /* FIXME: carlton/2003-08-27: Maybe the printf_filtered
		 calls here (and possibly above) should be abstracted
		 out into their own functions?  Andrew suggests using
		 a generic local_address_string instead to print out
		 the addresses; that makes sense to me, too.  */

	      if (TARGET_ADDR_BIT == 32)
	        {
	          printf_filtered ("\t%#10lx %#10lx %#10x %#10x %7s\n",
			       (unsigned long) addr,	/* FIXME: pr_addr */
d435 1
a435 10
		}
	      else
	        {
	          printf_filtered ("  %#18lx %#18lx %#10x %#10x %7s\n",
			       (unsigned long) addr,	/* FIXME: pr_addr */
			       (unsigned long) endaddr,
			       (int) size,
			       (unsigned int) offset,
			       filename[0] ? filename : "");
	        }
d595 5
a599 1
     application).  */
a610 81
}

/* Parse LINE as a signal set and add its set bits to SIGS.  */

static void
linux_proc_add_line_to_sigset (const char *line, sigset_t *sigs)
{
  int len = strlen (line) - 1;
  const char *p;
  int signum;

  if (line[len] != '\n')
    error ("Could not parse signal set: %s", line);

  p = line;
  signum = len * 4;
  while (len-- > 0)
    {
      int digit;

      if (*p >= '0' && *p <= '9')
	digit = *p - '0';
      else if (*p >= 'a' && *p <= 'f')
	digit = *p - 'a' + 10;
      else
	error ("Could not parse signal set: %s", line);

      signum -= 4;

      if (digit & 1)
	sigaddset (sigs, signum + 1);
      if (digit & 2)
	sigaddset (sigs, signum + 2);
      if (digit & 4)
	sigaddset (sigs, signum + 3);
      if (digit & 8)
	sigaddset (sigs, signum + 4);

      p++;
    }
}

/* Find process PID's pending signals from /proc/pid/status and set SIGS
   to match.  */

void
linux_proc_pending_signals (int pid, sigset_t *pending, sigset_t *blocked, sigset_t *ignored)
{
  FILE *procfile;
  char buffer[MAXPATHLEN], fname[MAXPATHLEN];
  int signum;

  sigemptyset (pending);
  sigemptyset (blocked);
  sigemptyset (ignored);
  sprintf (fname, "/proc/%d/status", pid);
  procfile = fopen (fname, "r");
  if (procfile == NULL)
    error ("Could not open %s", fname);

  while (fgets (buffer, MAXPATHLEN, procfile) != NULL)
    {
      /* Normal queued signals are on the SigPnd line in the status
	 file.  However, 2.6 kernels also have a "shared" pending queue
	 for delivering signals to a thread group, so check for a ShdPnd
	 line also.

	 Unfortunately some Red Hat kernels include the shared pending queue
	 but not the ShdPnd status field.  */

      if (strncmp (buffer, "SigPnd:\t", 8) == 0)
	linux_proc_add_line_to_sigset (buffer + 8, pending);
      else if (strncmp (buffer, "ShdPnd:\t", 8) == 0)
	linux_proc_add_line_to_sigset (buffer + 8, pending);
      else if (strncmp (buffer, "SigBlk:\t", 8) == 0)
	linux_proc_add_line_to_sigset (buffer + 8, blocked);
      else if (strncmp (buffer, "SigIgn:\t", 8) == 0)
	linux_proc_add_line_to_sigset (buffer + 8, ignored);
    }

  fclose (procfile);
@


1.11.8.7
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a237 20
/* Function: linux_do_registers
 * 
 * Records the register state for the corefile note section.
 */

static char *
linux_do_registers (bfd *obfd, ptid_t ptid,
		    char *note_data, int *note_size)
{
  registers_changed ();
  target_fetch_registers (-1);	/* FIXME should not be necessary; 
				   fill_gregset should do it automatically. */
  return linux_do_thread_registers (obfd,
				    ptid_build (ptid_get_pid (inferior_ptid),
						ptid_get_pid (inferior_ptid),
						0),
				    note_data, note_size);
  return note_data;
}

d280 2
a281 2
      note_data = linux_do_registers (obfd, inferior_ptid,
				      note_data, note_size);
@


1.11.6.1
log
@	* acconfig.h (HAVE_PREAD64): Add.
	* configure.in: Check for pread64.
	* config.in: Regenerated.
	* configure: Regenerated.
	* lin-lwp.c (lin_lwp_xfer_memory): Call linux_proc_xfer_memory.
	* linux-proc.c (linux_proc_xfer_memory): New function.
	* config/nm-linux.h (linux_proc_xfer_memory): Add prototype.
@
text
@a27 2
#include <unistd.h>	/* for open, pread64 */
#include <fcntl.h>	/* for O_RDONLY */
a35 4
#ifndef O_LARGEFILE
#define O_LARGEFILE 0
#endif

a578 43
}

int linux_proc_xfer_memory (CORE_ADDR addr, char *myaddr, int len, int write,
			    struct mem_attrib *attrib,
			    struct target_ops *target)
{
  int fd, ret;
  char filename[64];

  if (write)
    return 0;

  /* Don't bother for one word.  */
  if (len < 3 * sizeof (long))
    return 0;

  /* We could keep this file open and cache it - possibly one
     per thread.  That requires some juggling, but is even faster.  */
  sprintf (filename, "/proc/%d/mem", PIDGET (inferior_ptid));
  fd = open (filename, O_RDONLY | O_LARGEFILE);
  if (fd == -1)
    return 0;

  /* If pread64 is available, use it.  It's faster if the kernel
     supports it (only one syscall), and it's 64-bit safe even
     on 32-bit platforms (for instance, SPARC debugging a SPARC64
     application).

     We play some autoconf and CFLAGS games to get this declaration
     exposed: -D_XOPEN_SOURCE=500 -D_LARGEFILE64_SOURCE.  And then
     a -D_BSD_SOURCE to counteract the defaults for _XOPEN_SOURCE.  */
#ifdef HAVE_PREAD64
  if (pread64 (fd, myaddr, len, addr) != len)
#else
  if (lseek (fd, addr, SEEK_SET) == -1
      || read (fd, myaddr, len) != len)
#endif
    ret = 0;
  else
    ret = len;

  close (fd);
  return ret;
@


1.10
log
@* linux-proc.c: Include "gdb_string.h".
* Makefile.in (linux-proc.o): Update dependency list.
@
text
@d201 3
a203 2
struct linux_corefile_thread_data {
  bfd  *obfd;
d205 2
a206 1
  int  *note_size;
d229 1
d277 1
d279 1
a279 1
  if (thread_args.note_data == note_data)
d282 1
a282 1
	 just use inferior_ptid. */
@


1.9
log
@2002-04-24  Daniel Jacobowitz  <drow@@mvista.com>

        * config/i386/tm-linux.h: Define FILL_FPXREGSET.
        * gregset.h: If FILL_FPXREGSET is defined, provide
        gdb_fpxregset_t, supply_fpxregset, and fill_fpxregset.
        * linux-proc.c (linux_do_thread_registers): If FILL_FPXREGSET
        is defined, call fill_fpxregset.
@
text
@d34 1
@


1.9.6.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a33 1
#include "gdb_string.h"
@


1.9.6.2
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d201 2
a202 3
struct linux_corefile_thread_data
{
  bfd *obfd;
d204 1
a204 2
  int *note_size;
  int num_notes;
a226 1
  args->num_notes++;
a273 1
  thread_args.num_notes = 0;
d275 1
a275 1
  if (thread_args.num_notes == 0)
d278 1
a278 1
	 just use inferior_ptid.  */
@


1.8
log
@2002-03-25  Jeff Law (law@@redhat.com)

	* linux-proc.c (read_mapping): Scan up to end of line for filename.
@
text
@d170 3
d189 8
@


1.7
log
@s/Linux/.../
Fix PR gdb/378.
@
text
@d80 8
a87 1
      ret += fscanf (mapfile, "%s\n", filename);
@


1.6
log
@2002-02-13  Elena Zannoni  <ezannoni@@redhat.com>

	* linux-proc.c: Add include of regcache.h.
	* Makefile.in (linux-proc.o): Add dependency on regcache.h.
@
text
@d1 2
a2 1
/* Linux-specific methods for using the /proc file system.
@


1.5
log
@2002-01-10  Michael Snyder  <msnyder@@redhat.com>

	* linux-proc.c: Add "info proc" command, a la procfs.c.
	(read_mapping): New function, abstract and re-use code.
	(linux_find_memory_regions): Use new func read_mapping.
	(linux_info_proc_cmd): New function, implement "info proc".
	(_initialize_linux_proc): Add new command "info proc".
@
text
@d27 1
@


1.4
log
@2002-01-14  Michael Snyder  <msnyder@@redhat.com>

	* linux-proc.c (linux_do_thread_registers): Ignore fpxregs
	until we can resolve portability issues.
	* gregset.h: Remove references to fpxregs.
	* gcore.c (gcore_command): Initialize note_sec to NULL.
@
text
@d24 3
a26 1
#include <sys/procfs.h>
d30 2
a31 1
#include "elf-bfd.h"
d58 30
d102 2
a103 2
  char procfilename[MAXPATHLEN];
  FILE *procfile;
d105 1
a105 1
  char perms[8], dev[8], filename[MAXPATHLEN];
d110 3
a112 3
  sprintf (procfilename, "/proc/%lld/maps", pid);
  if ((procfile = fopen (procfilename, "r")) == NULL)
    error ("Could not open %s\n", procfilename);
d116 1
a116 12
		      "Reading memory regions from %s\n", procfilename);

  /* Read the first memory segment descriptor from the maps file.  */
  ret = fscanf (procfile, "%llx-%llx %s %llx %s %llx", 
		&addr, &endaddr, perms, &offset, dev, &inode);
  if (inode)
    fscanf (procfile, " %s\n", filename);
  else
    {
      filename[0] = '\0';
      fscanf (procfile, "\n");
    }
d119 2
a120 1
  while (ret > 0 && ret != EOF)
d125 3
a127 3
      read  = (strchr (perms, 'r') != 0);
      write = (strchr (perms, 'w') != 0);
      exec  = (strchr (perms, 'x') != 0);
a144 12

      /* Read the next memory region.  */
      filename[0] = '\0';
      ret = fscanf (procfile, "%llx-%llx %s %llx %s %llx", 
		    &addr, &endaddr, perms, &offset, dev, &inode);
      if (inode)
	fscanf (procfile, " %s\n", filename);
      else
	{
	  filename[0] = '\0';
	  fscanf (procfile, "\n");
	}
d146 1
a146 2

  fclose (procfile);
d270 267
d545 9
@


1.3
log
@2002-01-08  Michael Snyder  <msnyder@@redhat.com>

	* linux-proc.c (child_pid_to_exec_file): Use readlink to get the
	real name of the executable, rather than the /proc name.
@
text
@a150 3
#ifdef HAVE_PTRACE_GETFPXREGS
  gdb_fpxregset_t fpxregs;
#endif
a166 8
#ifdef HAVE_PTRACE_GETFPXREGS
  fill_fpxregset (&fpxregs, -1);
  note_data = (char *) elfcore_write_prxfpreg (obfd, 
					       note_data, 
					       note_size, 
					       &fpxregs, 
					       sizeof (fpxregs));
#endif
@


1.2
log
@2002-01-03  Michael Snyder  <msnyder@@redhat.com>

	Implement a "generate-core-file" command in gdb, save target state.
	* gcore.c: New file.  Implement new command 'generate-core-file'.
	Save a corefile image of the current state of the inferior.
	* linux-proc.c: Add linux-specific code for saving corefiles.
	* target.h (struct target_ops): Add new target vectors for saving
	corefiles; to_find_memory_regions and to_make_corefile_notes.
	(target_find_memory_regions): New macro.
	(target_make_corefile_notes): New macro.
	* target.c (update_current_target): Inherit new target methods.
	(dummy_find_memory_regions): New place-holder method.
	(dummy_make_corefile_notes): New place-holder method.
	(init_dummy_target): Initialize new dummy target vectors.
	* exec.c (exec_set_find_memory_regions): New function.
	Allow the exec_ops vector for memory regions to be taken over.
	(exec_make_note_section): New function, target vector method.
	* defs.h (exec_set_find_memory_regions): Export prototype.
	* procfs.c (proc_find_memory_regions): New function, corefile method.
	(procfs_make_note_section): New function, corefile method.
	(init_procfs_ops): Set new target vector pointers.
	(find_memory_regions_callback): New function.
	(procfs_do_thread_registers): New function.
	(procfs_corefile_thread_callback): New function.
	* sol-thread.c (sol_find_memory_regions): New function.
	(sol_make_note_section): New function.
	(init_sol_thread_ops): Initialize new target vectors.
	* inftarg.c (inftarg_set_find_memory_regions): New function.
	Allow to_find_memory_regions vector to be taken over.
	(inftarg_set_make_corefile_notes): New function.
	Allow to_make_corefile_notes vector to be taken over.
	* thread-db.c (thread_db_new_objfile): Don't activate thread-db
	interface layer if not target_has_execution (may be a corefile).
	* config/i386/linux.mh: Add gcore.o to NATDEPFILES.
	* config/sparc/sun4sol2.mh: Ditto.
	* config/alpha/alpha-linux.mh: Ditto.
	* config/arm/linux.mh: Ditto.
	* config/i386/x86-64linux.mh: Ditto.
	* config/ia64/linux.mh: Ditto.
	* config/m68k/linux.mh: Ditto.
	* config/mips/linux.mh: Ditto.
	* config/powerpc/linux.mh: Ditto.
	* config/sparc/linux.mh: Ditto.
@
text
@d40 1
a40 1
  static char fname[MAXPATHLEN];
d42 11
a52 3
  sprintf (fname, "/proc/%d/exe", pid);
  /* FIXME use readlink to get the real name. */
  return fname;
@


1.1
log
@2002-01-07  Michael Snyder  <msnyder@@redhat.com>

	* linux-proc.c: New file.  Implement child_pid_to_exec_file,
	so that attaching to a pid will automatically read the process's
	symbol file and shlibs.
	* Makefile.in: Add rule for linux-proc.o.
	* config/nm-linux.h: Define CHILD_PID_TO_EXEC_FILE.
	* config/alpha/alpha-linux.mh: Add linux-proc.o to NATDEPFILES.
	* config/arm/linux.mh: Ditto.
	* config/i386/linux.mh: Ditto.
	* config/i386/x86-64linux.mh: Ditto.
	* config/ia64/linux.mh: Ditto.
	* config/m68k/linux.mh: Ditto.
	* config/mips/linux.mh: Ditto.
	* config/powerpc/linux.mh: Ditto.
	* config/sparc/linux.mh: Ditto.
@
text
@d1 2
a2 2
/* Generate a core file for the inferior process -- Linux version.
   Copyright 2001 Free Software Foundation, Inc.
d22 1
d24 12
d45 226
@

