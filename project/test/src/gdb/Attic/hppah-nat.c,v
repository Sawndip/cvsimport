head	1.37;
access;
symbols
	gdb_6_3-20041109-release:1.34
	gdb_6_3-branch:1.34.0.2
	gdb_6_3-20041019-branchpoint:1.34
	drow_intercu-merge-20040921:1.33
	drow_intercu-merge-20040915:1.33
	jimb-gdb_6_2-e500-branch:1.31.0.6
	jimb-gdb_6_2-e500-branchpoint:1.31
	gdb_6_2-20040730-release:1.31
	gdb_6_2-branch:1.31.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.31
	gdb_6_1_1-20040616-release:1.29
	gdb_6_1-2004-04-05-release:1.29
	drow_intercu-merge-20040402:1.29
	drow_intercu-merge-20040327:1.29
	ezannoni_pie-20040323-branch:1.29.0.12
	ezannoni_pie-20040323-branchpoint:1.29
	cagney_tramp-20040321-mergepoint:1.29
	cagney_tramp-20040309-branch:1.29.0.10
	cagney_tramp-20040309-branchpoint:1.29
	gdb_6_1-branch:1.29.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.29
	drow_intercu-20040221-branch:1.29.0.6
	drow_intercu-20040221-branchpoint:1.29
	cagney_bfdfile-20040213-branch:1.29.0.4
	cagney_bfdfile-20040213-branchpoint:1.29
	drow-cplus-merge-20040208:1.29
	carlton_dictionary-20040126-merge:1.29
	cagney_bigcore-20040122-branch:1.29.0.2
	cagney_bigcore-20040122-branchpoint:1.29
	drow-cplus-merge-20040113:1.29
	drow-cplus-merge-20031224:1.29
	drow-cplus-merge-20031220:1.29
	carlton_dictionary-20031215-merge:1.29
	drow-cplus-merge-20031214:1.29
	carlton-dictionary-20031111-merge:1.29
	gdb_6_0-2003-10-04-release:1.25
	kettenis_sparc-20030918-branch:1.27.0.2
	kettenis_sparc-20030918-branchpoint:1.27
	carlton_dictionary-20030917-merge:1.27
	ezannoni_pie-20030916-branchpoint:1.26
	ezannoni_pie-20030916-branch:1.26.0.2
	cagney_x86i386-20030821-branch:1.25.0.4
	cagney_x86i386-20030821-branchpoint:1.25
	carlton_dictionary-20030805-merge:1.25
	carlton_dictionary-20030627-merge:1.25
	gdb_6_0-branch:1.25.0.2
	gdb_6_0-2003-06-23-branchpoint:1.25
	jimb-ppc64-linux-20030613-branch:1.24.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.24
	cagney_convert-20030606-branch:1.24.0.10
	cagney_convert-20030606-branchpoint:1.24
	cagney_writestrings-20030508-branch:1.24.0.8
	cagney_writestrings-20030508-branchpoint:1.24
	jimb-ppc64-linux-20030528-branch:1.24.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.24
	carlton_dictionary-20030523-merge:1.24
	cagney_fileio-20030521-branch:1.24.0.4
	cagney_fileio-20030521-branchpoint:1.24
	kettenis_i386newframe-20030517-mergepoint:1.24
	jimb-ppc64-linux-20030509-branch:1.24.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.24
	kettenis_i386newframe-20030504-mergepoint:1.23
	carlton_dictionary-20030430-merge:1.23
	kettenis_i386newframe-20030419-branch:1.23.0.6
	kettenis_i386newframe-20030419-branchpoint:1.23
	carlton_dictionary-20030416-merge:1.23
	cagney_frameaddr-20030409-mergepoint:1.23
	kettenis_i386newframe-20030406-branch:1.23.0.4
	kettenis_i386newframe-20030406-branchpoint:1.23
	cagney_frameaddr-20030403-branchpoint:1.23
	cagney_frameaddr-20030403-branch:1.23.0.2
	cagney_framebase-20030330-mergepoint:1.23
	cagney_framebase-20030326-branch:1.22.0.12
	cagney_framebase-20030326-branchpoint:1.22
	cagney_lazyid-20030317-branch:1.22.0.10
	cagney_lazyid-20030317-branchpoint:1.22
	kettenis-i386newframe-20030316-mergepoint:1.22
	offbyone-20030313-branch:1.22.0.8
	offbyone-20030313-branchpoint:1.22
	kettenis-i386newframe-20030308-branch:1.22.0.6
	kettenis-i386newframe-20030308-branchpoint:1.22
	carlton_dictionary-20030305-merge:1.22
	cagney_offbyone-20030303-branch:1.22.0.4
	cagney_offbyone-20030303-branchpoint:1.22
	carlton_dictionary-20030207-merge:1.22
	interps-20030203-mergepoint:1.22
	interps-20030202-branch:1.22.0.2
	interps-20030202-branchpoint:1.22
	cagney-unwind-20030108-branch:1.20.0.2
	cagney-unwind-20030108-branchpoint:1.20
	carlton_dictionary-20021223-merge:1.20
	gdb_5_3-2002-12-12-release:1.12
	carlton_dictionary-20021115-merge:1.13
	kseitz_interps-20021105-merge:1.12
	kseitz_interps-20021103-merge:1.12
	drow-cplus-merge-20021020:1.12
	drow-cplus-merge-20021025:1.12
	carlton_dictionary-20021025-merge:1.12
	carlton_dictionary-20021011-merge:1.12
	drow-cplus-branch:1.12.0.18
	drow-cplus-branchpoint:1.12
	kseitz_interps-20020930-merge:1.12
	carlton_dictionary-20020927-merge:1.12
	carlton_dictionary-branch:1.12.0.16
	carlton_dictionary-20020920-branchpoint:1.12
	gdb_5_3-branch:1.12.0.14
	gdb_5_3-2002-09-04-branchpoint:1.12
	kseitz_interps-20020829-merge:1.12
	cagney_sysregs-20020825-branch:1.12.0.12
	cagney_sysregs-20020825-branchpoint:1.12
	readline_4_3-import-branch:1.12.0.10
	readline_4_3-import-branchpoint:1.12
	gdb_5_2_1-2002-07-23-release:1.12
	kseitz_interps-20020528-branch:1.12.0.8
	kseitz_interps-20020528-branchpoint:1.12
	cagney_regbuf-20020515-branch:1.12.0.6
	cagney_regbuf-20020515-branchpoint:1.12
	jimb-macro-020506-branch:1.12.0.4
	jimb-macro-020506-branchpoint:1.12
	gdb_5_2-2002-04-29-release:1.12
	gdb_5_2-branch:1.12.0.2
	gdb_5_2-2002-03-03-branchpoint:1.12
	gdb_5_1_1-2002-01-24-release:1.11
	gdb_5_1_0_1-2002-01-03-release:1.11
	cygnus_cvs_20020108_pre:1.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.11
	gdb_5_1_0_1-2002-01-03-branch:1.11.0.8
	gdb_5_1-2001-11-21-release:1.11
	gdb_s390-2001-09-26-branch:1.11.0.6
	gdb_s390-2001-09-26-branchpoint:1.11
	gdb_5_1-2001-07-29-branch:1.11.0.4
	gdb_5_1-2001-07-29-branchpoint:1.11
	dberlin-typesystem-branch:1.11.0.2
	dberlin-typesystem-branchpoint:1.11
	gdb-post-ptid_t-2001-05-03:1.11
	gdb-pre-ptid_t-2001-05-03:1.10
	insight-precleanup-2001-01-01:1.6
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.11
	insight-2000-02-04:1.1.1.11
	gdb-2000-02-04:1.1.1.11
	gdb-2000-02-02:1.1.1.11
	gdb-2000-02-01:1.1.1.11
	gdb-2000-01-31:1.1.1.11
	gdb-2000-01-26:1.1.1.11
	gdb-2000-01-24:1.1.1.11
	gdb-2000-01-17:1.1.1.11
	gdb-2000-01-10:1.1.1.11
	gdb-2000-01-05:1.1.1.11
	gdb-1999-12-21:1.1.1.11
	gdb-1999-12-13:1.1.1.10
	gdb-1999-12-07:1.1.1.10
	gdb-1999-12-06:1.1.1.10
	gdb-1999-11-16:1.1.1.9
	gdb-1999-11-08:1.1.1.9
	gdb-1999-11-01:1.1.1.9
	gdb-1999-10-25:1.1.1.9
	gdb-1999-10-18:1.1.1.9
	gdb-1999-10-11:1.1.1.9
	gdb-1999-10-04:1.1.1.9
	gdb-1999-09-28:1.1.1.9
	gdb-1999-09-21:1.1.1.9
	gdb-1999-09-13:1.1.1.9
	gdb-1999-09-08:1.1.1.9
	gdb-1999-08-30:1.1.1.9
	gdb-1999-08-23:1.1.1.9
	gdb-1999-08-16:1.1.1.8
	gdb-1999-08-09:1.1.1.7
	gdb-1999-08-02:1.1.1.6
	gdb-1999-07-26:1.1.1.5
	gdb-1999-07-19:1.1.1.5
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.3
	gdb-1999-05-10:1.1.1.3
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.37
date	2004.12.18.17.36.32;	author kettenis;	state dead;
branches;
next	1.36;

1.36
date	2004.12.06.03.36.38;	author tausq;	state Exp;
branches;
next	1.35;

1.35
date	2004.11.20.23.56.18;	author danglin;	state Exp;
branches;
next	1.34;

1.34
date	2004.10.05.21.53.33;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2004.08.03.00.57.25;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2004.07.22.01.31.48;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.07.05.48.49;	author tausq;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.06.17.56.01;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.02.20.28.29;	author cagney;	state Exp;
branches
	1.29.6.1;
next	1.28;

1.28
date	2003.09.19.20.09.44;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.17.14.24.30;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2003.09.14.16.32.12;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.19.15.04.57;	author drow;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.08.22.33.14;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.29.23.29.47;	author cagney;	state Exp;
branches
	1.23.6.1;
next	1.22;

1.22
date	2003.02.02.05.46.14;	author cagney;	state Exp;
branches
	1.22.12.1;
next	1.21;

1.21
date	2003.01.29.15.56.11;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.12.01.39.34;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.11.02.04.44;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.11.02.02.02;	author drow;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.11.01.25.19;	author drow;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.16.19.23.52;	author drow;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.16.19.22.58;	author drow;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.16.19.21.43;	author drow;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.14.20.37.28;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.24.02.53.48;	author cagney;	state Exp;
branches
	1.12.16.1
	1.12.18.1;
next	1.11;

1.11
date	2001.05.04.04.15.25;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.06.08.21.08;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.05.21.09.21;	author chastain;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.15.01.01.47;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.02.00.07.32;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.28.01.12.27;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.24.08.55.15;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.01;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.01;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.24;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.42.33;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.06.48;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.19.23.27.57;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.02.23.45.34;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.08.09.21.33.32;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.08.16.19.52.50;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.08.23.22.35.07;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.12.07.03.56.01;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.12.22.21.45.06;	author jsm;	state Exp;
branches;
next	;

1.12.16.1
date	2002.11.15.19.18.45;	author carlton;	state Exp;
branches;
next	1.12.16.2;

1.12.16.2
date	2002.12.23.19.38.27;	author carlton;	state Exp;
branches;
next	1.12.16.3;

1.12.16.3
date	2003.02.07.19.17.49;	author carlton;	state Exp;
branches;
next	1.12.16.4;

1.12.16.4
date	2003.04.16.19.56.52;	author carlton;	state Exp;
branches;
next	1.12.16.5;

1.12.16.5
date	2003.05.23.18.40.39;	author carlton;	state Exp;
branches;
next	1.12.16.6;

1.12.16.6
date	2003.06.27.21.49.57;	author carlton;	state Exp;
branches;
next	1.12.16.7;

1.12.16.7
date	2003.09.17.21.28.21;	author carlton;	state Exp;
branches;
next	1.12.16.8;

1.12.16.8
date	2003.11.11.23.50.45;	author carlton;	state Exp;
branches;
next	;

1.12.18.1
date	2003.12.14.20.27.16;	author drow;	state Exp;
branches;
next	;

1.22.12.1
date	2003.03.30.16.35.20;	author cagney;	state Exp;
branches;
next	;

1.23.6.1
date	2003.05.18.09.44.11;	author kettenis;	state Exp;
branches;
next	;

1.29.6.1
date	2004.09.16.17.01.07;	author drow;	state Exp;
branches;
next	;


desc
@@


1.37
log
@* hppah-nat.c: Remove file.
* infttrace.h: Remove file.
* infttrace.c: Remove file.
* Makefile.in (ALLDEPFILES): Remove hppah-nat.c
(infttrace_h): Remove variable.
(hppah-nat.o, infttrace.o): Remove dependencies.
* configure.host (hppa*64*-*-hpux11*): Remove.
* config/pa/hpux11w.mh: Remove file.
* config/pa/nm-hppah.h: Remove file.
* config/pa/nm-hppah11.h: Remove file.
@
text
@/* Native support code for HPUX PA-RISC, for GDB the GNU debugger.

   Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1998, 1999, 2000, 2001, 2004 Free Software Foundation, Inc.

   Contributed by the Center for Software Science at the
   University of Utah (pa-gdb-bugs@@cs.utah.edu).

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */


#include "defs.h"
#include "inferior.h"
#include "target.h"
#include <sys/ptrace.h>
#include "gdbcore.h"
#include "gdb_wait.h"
#include "regcache.h"
#include "gdb_string.h"
#include "infttrace.h"
#include <signal.h>

#include "hppa-tdep.h"

static CORE_ADDR text_end;

void
deprecated_hpux_text_end (struct target_ops *exec_ops)
{
  struct section_table *p;

  /* Set text_end to the highest address of the end of any readonly
     code section.  */
  /* FIXME: The comment above does not match the code.  The code
     checks for sections with are either code *or* readonly.  */
  text_end = (CORE_ADDR) 0;
  for (p = exec_ops->to_sections; p < exec_ops->to_sections_end; p++)
    if (bfd_get_section_flags (p->bfd, p->the_bfd_section)
	& (SEC_CODE | SEC_READONLY))
      {
	if (text_end < p->endaddr)
	  text_end = p->endaddr;
      }
}


static void fetch_register (int);

void
fetch_inferior_registers (int regno)
{
  if (regno == -1)
    for (regno = 0; regno < NUM_REGS; regno++)
      fetch_register (regno);
  else
    fetch_register (regno);
}

/* Our own version of the offsetof macro, since we can't assume ANSI C.  */
#define HPPAH_OFFSETOF(type, member) ((int) (&((type *) 0)->member))

/* Store our register values back into the inferior.
   If REGNO is -1, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time).  */

void
store_inferior_registers (int regno)
{
  unsigned int regaddr;
  char buf[80];
  int i;
  unsigned int offset = U_REGS_OFFSET;
  int scratch;

  if (regno >= 0)
    {
      unsigned int addr, len, offset;

      if (CANNOT_STORE_REGISTER (regno))
	return;

      offset = 0;
      len = register_size (current_gdbarch, regno);

      /* Requests for register zero actually want the save_state's
	 ss_flags member.  As RM says: "Oh, what a hack!"  */
      if (regno == 0)
	{
	  save_state_t ss;
	  addr = HPPAH_OFFSETOF (save_state_t, ss_flags);
	  len = sizeof (ss.ss_flags);

	  /* Note that ss_flags is always an int, no matter what
	     register_size (0) says.  Assuming all HP-UX PA machines
	     are big-endian, put it at the least significant end of
	     the value, and zap the rest of the buffer.  */
	  offset = register_size (current_gdbarch, 0) - len;
	}

      /* Floating-point registers come from the ss_fpblock area.  */
      else if (regno >= HPPA_FP0_REGNUM)
	addr = HPPAH_OFFSETOF (save_state_t, ss_fpblock) 
	       + ((regno - HPPA_FP0_REGNUM) 
	          * register_size (current_gdbarch, regno));

      /* Wide registers come from the ss_wide area.
	 I think it's more PC to test (ss_flags & SS_WIDEREGS) to select
	 between ss_wide and ss_narrow than to use the raw register size.
	 But checking ss_flags would require an extra ptrace call for
	 every register reference.  Bleah.  */
      else if (len == 8)
	addr = HPPAH_OFFSETOF (save_state_t, ss_wide) 
	       + regno * 8;

      /* Narrow registers come from the ss_narrow area.  Note that
	 ss_narrow starts with gr1, not gr0.  */
      else if (len == 4)
	addr = HPPAH_OFFSETOF (save_state_t, ss_narrow)
	       + (regno - 1) * 4;
      else
	internal_error (__FILE__, __LINE__,
			"hppah-nat.c (write_register): unexpected register size");

#ifdef GDB_TARGET_IS_HPPA_20W
      /* Unbelieveable.  The PC head and tail must be written in 64bit hunks
	 or we will get an error.  Worse yet, the oddball ptrace/ttrace
	 layering will not allow us to perform a 64bit register store.

	 What a crock.  */
      if ((regno == HPPA_PCOQ_HEAD_REGNUM || regno == HPPA_PCOQ_TAIL_REGNUM) && len == 8)
	{
	  CORE_ADDR temp;

	  regcache_raw_read (current_regcache, regno, &temp);

	  /* Set the priv level (stored in the low two bits of the PC.  */
	  temp |= 0x3;

	  ttrace_write_reg_64 (PIDGET (inferior_ptid), (CORE_ADDR)addr,
	                       (CORE_ADDR)&temp);

	  /* If we fail to write the PC, give a true error instead of
	     just a warning.  */
          if (errno != 0)
	    {
	      char *err = safe_strerror (errno);
	      char *msg = alloca (strlen (err) + 128);
	      sprintf (msg, "writing `%s' register: %s",
		        REGISTER_NAME (regno), err);
	      perror_with_name (msg);
	    }
	  return;
	}

      /* Another crock.  HPUX complains if you write a nonzero value to
	 the high part of IPSW.  What will it take for HP to catch a
	 clue about building sensible interfaces?  */
     if (regno == HPPA_IPSW_REGNUM && len == 8)
	{
	  int temp = 0;

	  regcache_raw_write_part (current_regcache, regno, 0,
				   sizeof (int), &temp);
	}
#endif

      for (i = 0; i < len; i += sizeof (int))
	{
	  int temp;

	  errno = 0;
	  regcache_raw_read_part (current_regcache, regno, i,
				  sizeof (int), &temp);
	  call_ptrace (PT_WUREGS, PIDGET (inferior_ptid),
	               (PTRACE_ARG3_TYPE) addr + i,
		       temp);
	  if (errno != 0)
	    {
	      /* Warning, not error, in case we are attached; sometimes
		 the kernel doesn't let us at the registers. */
	      char *err = safe_strerror (errno);
	      char *msg = alloca (strlen (err) + 128);
	      sprintf (msg, "writing `%s' register: %s",
		        REGISTER_NAME (regno), err);
	      /* If we fail to write the PC, give a true error instead of
		 just a warning.  */
	      if (regno == HPPA_PCOQ_HEAD_REGNUM || regno == HPPA_PCOQ_TAIL_REGNUM)
		perror_with_name (msg);
	      else
		warning (msg);
	      return;
	    }
	}
    }
  else
    for (regno = 0; regno < NUM_REGS; regno++)
      store_inferior_registers (regno);
}


/* Fetch a register's value from the process's U area.  */
static void
fetch_register (int regno)
{
  char buf[MAX_REGISTER_SIZE];
  unsigned int addr, len, offset;
  int i;

  offset = 0;
  len = register_size (current_gdbarch, regno);

  /* Requests for register zero actually want the save_state's
     ss_flags member.  As RM says: "Oh, what a hack!"  */
  if (regno == 0)
    {
      save_state_t ss;
      addr = HPPAH_OFFSETOF (save_state_t, ss_flags);
      len = sizeof (ss.ss_flags);

      /* Note that ss_flags is always an int, no matter what
	 register_size (0) says.  Assuming all HP-UX PA machines are
	 big-endian, put it at the least significant end of the value,
	 and zap the rest of the buffer.  */
      offset = register_size (current_gdbarch, 0) - len;
      memset (buf, 0, sizeof (buf));
    }

  /* Floating-point registers come from the ss_fpblock area.  */
  else if (regno >= HPPA_FP0_REGNUM)
    addr = (HPPAH_OFFSETOF (save_state_t, ss_fpblock) 
	    + (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (HPPA_FP0_REGNUM)));

  /* Wide registers come from the ss_wide area.
     I think it's more PC to test (ss_flags & SS_WIDEREGS) to select
     between ss_wide and ss_narrow than to use the raw register size.
     But checking ss_flags would require an extra ptrace call for
     every register reference.  Bleah.  */
  else if (len == 8)
    addr = (HPPAH_OFFSETOF (save_state_t, ss_wide) 
	    + DEPRECATED_REGISTER_BYTE (regno));

  /* Narrow registers come from the ss_narrow area.  Note that
     ss_narrow starts with gr1, not gr0.  */
  else if (len == 4)
    addr = (HPPAH_OFFSETOF (save_state_t, ss_narrow)
	    + (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (1)));

  else
    internal_error (__FILE__, __LINE__,
		    "hppa-nat.c (fetch_register): unexpected register size");

  for (i = 0; i < len; i += sizeof (int))
    {
      errno = 0;
      /* Copy an int from the U area to buf.  Fill the least
         significant end if len != raw_size.  */
      * (int *) &buf[offset + i] =
	  call_ptrace (PT_RUREGS, PIDGET (inferior_ptid),
		       (PTRACE_ARG3_TYPE) addr + i, 0);
      if (errno != 0)
	{
	  /* Warning, not error, in case we are attached; sometimes
	     the kernel doesn't let us at the registers. */
	  char *err = safe_strerror (errno);
	  char *msg = alloca (strlen (err) + 128);
	  sprintf (msg, "reading `%s' register: %s",
		   REGISTER_NAME (regno), err);
	  warning (msg);
	  return;
	}
    }

  /* If we're reading an address from the instruction address queue,
     mask out the bottom two bits --- they contain the privilege
     level.  */
  if (regno == HPPA_PCOQ_HEAD_REGNUM || regno == HPPA_PCOQ_TAIL_REGNUM)
    buf[len - 1] &= ~0x3;

  regcache_raw_supply (current_regcache, regno, buf);
}


/* Copy LEN bytes to or from inferior's memory starting at MEMADDR
   to debugger memory starting at MYADDR.   Copy to inferior if
   WRITE is nonzero.

   Returns the length copied, which is either the LEN argument or
   zero.  This xfer function does not do partial moves, since
   deprecated_child_ops doesn't allow memory operations to cross below
   us in the target stack anyway.  TARGET is ignored.  */

int
child_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		   struct mem_attrib *mem,
		   struct target_ops *target)
{
  int i;
  /* Round starting address down to longword boundary.  */
  CORE_ADDR addr = memaddr & - (CORE_ADDR)(sizeof (int));
  /* Round ending address up; get number of longwords that makes.  */
  int count
  = (((memaddr + len) - addr) + sizeof (int) - 1) / sizeof (int);

  /* Allocate buffer of that many longwords.
     Note -- do not use alloca to allocate this buffer since there is no
     guarantee of when the buffer will actually be deallocated.

     This routine can be called over and over with the same call chain;
     this (in effect) would pile up all those alloca requests until a call
     to alloca was made from a point higher than this routine in the
     call chain.  */
  int *buffer = (int *) xmalloc (count * sizeof (int));

  if (write)
    {
      /* Fill start and end extra bytes of buffer with existing memory data.  */
      if (addr != memaddr || len < (int) sizeof (int))
	{
	  /* Need part of initial word -- fetch it.  */
	  buffer[0] = call_ptrace (addr < text_end ? PT_RIUSER : PT_RDUSER,
				   PIDGET (inferior_ptid),
				   (PTRACE_ARG3_TYPE) addr, 0);
	}

      if (count > 1)		/* FIXME, avoid if even boundary */
	{
	  buffer[count - 1]
	    = call_ptrace (addr < text_end ? PT_RIUSER : PT_RDUSER,
			   PIDGET (inferior_ptid),
			   (PTRACE_ARG3_TYPE) (addr
					       + (count - 1) * sizeof (int)),
			   0);
	}

      /* Copy data to be written over corresponding part of buffer */
      memcpy ((char *) buffer + (memaddr & (sizeof (int) - 1)), myaddr, len);

      /* Write the entire buffer.  */
      for (i = 0; i < count; i++, addr += sizeof (int))
	{
	  int pt_status;
	  int pt_request;
	  /* The HP-UX kernel crashes if you use PT_WDUSER to write into the
	     text segment.  FIXME -- does it work to write into the data
	     segment using WIUSER, or do these idiots really expect us to
	     figure out which segment the address is in, so we can use a
	     separate system call for it??!  */
	  errno = 0;
	  pt_request = (addr < text_end) ? PT_WIUSER : PT_WDUSER;
	  pt_status = call_ptrace (pt_request,
				   PIDGET (inferior_ptid),
				   (PTRACE_ARG3_TYPE) addr,
				   buffer[i]);

	  /* Did we fail?  Might we've guessed wrong about which
	     segment this address resides in?  Try the other request,
	     and see if that works...  */
	  if ((pt_status == -1) && errno)
	    {
	      errno = 0;
	      pt_request = (pt_request == PT_WIUSER) ? PT_WDUSER : PT_WIUSER;
	      pt_status = call_ptrace (pt_request,
				       PIDGET (inferior_ptid),
				       (PTRACE_ARG3_TYPE) addr,
				       buffer[i]);

	      /* No, we still fail.  Okay, time to punt. */
	      if ((pt_status == -1) && errno)
		{
		  xfree (buffer);
		  return 0;
		}
	    }
	}
    }
  else
    {
      /* Read all the longwords */
      for (i = 0; i < count; i++, addr += sizeof (int))
	{
	  errno = 0;
	  buffer[i] = call_ptrace (addr < text_end ? PT_RIUSER : PT_RDUSER,
				   PIDGET (inferior_ptid),
				   (PTRACE_ARG3_TYPE) addr, 0);
	  if (errno)
	    {
	      xfree (buffer);
	      return 0;
	    }
	  QUIT;
	}

      /* Copy appropriate bytes out of the buffer.  */
      memcpy (myaddr, (char *) buffer + (memaddr & (sizeof (int) - 1)), len);
    }
  xfree (buffer);
  return len;
}

char *saved_child_execd_pathname = NULL;
int saved_vfork_pid;
enum {
  STATE_NONE,
  STATE_GOT_CHILD,
  STATE_GOT_EXEC,
  STATE_GOT_PARENT,
  STATE_FAKE_EXEC
} saved_vfork_state = STATE_NONE;

int
child_follow_fork (int follow_child)
{
  ptid_t last_ptid;
  struct target_waitstatus last_status;
  int has_vforked;
  int parent_pid, child_pid;

  get_last_target_status (&last_ptid, &last_status);
  has_vforked = (last_status.kind == TARGET_WAITKIND_VFORKED);
  parent_pid = ptid_get_pid (last_ptid);
  child_pid = last_status.value.related_pid;

  /* At this point, if we are vforking, breakpoints were already
     detached from the child in child_wait; and the child has already
     called execve().  If we are forking, both the parent and child
     have breakpoints inserted.  */

  if (! follow_child)
    {
      if (! has_vforked)
	{
	  detach_breakpoints (child_pid);
#ifdef SOLIB_REMOVE_INFERIOR_HOOK
	  SOLIB_REMOVE_INFERIOR_HOOK (child_pid);
#endif
	}

      /* Detach from the child. */
      printf_unfiltered ("Detaching after fork from %s\n",
			 target_pid_to_str (pid_to_ptid (child_pid)));
      hppa_require_detach (child_pid, 0);

      /* The parent and child of a vfork share the same address space.
	 Also, on some targets the order in which vfork and exec events
	 are received for parent in child requires some delicate handling
	 of the events.

	 For instance, on ptrace-based HPUX we receive the child's vfork
	 event first, at which time the parent has been suspended by the
	 OS and is essentially untouchable until the child's exit or second
	 exec event arrives.  At that time, the parent's vfork event is
	 delivered to us, and that's when we see and decide how to follow
	 the vfork.  But to get to that point, we must continue the child
	 until it execs or exits.  To do that smoothly, all breakpoints
	 must be removed from the child, in case there are any set between
	 the vfork() and exec() calls.  But removing them from the child
	 also removes them from the parent, due to the shared-address-space
	 nature of a vfork'd parent and child.  On HPUX, therefore, we must
	 take care to restore the bp's to the parent before we continue it.
	 Else, it's likely that we may not stop in the expected place.  (The
	 worst scenario is when the user tries to step over a vfork() call;
	 the step-resume bp must be restored for the step to properly stop
	 in the parent after the call completes!)

	 Sequence of events, as reported to gdb from HPUX:

	 Parent        Child           Action for gdb to take
	 -------------------------------------------------------
	 1                VFORK               Continue child
	 2                EXEC
	 3                EXEC or EXIT
	 4  VFORK

	 Now that the child has safely exec'd or exited, we must restore
	 the parent's breakpoints before we continue it.  Else, we may
	 cause it run past expected stopping points.  */

      if (has_vforked)
	reattach_breakpoints (parent_pid);
    }
  else
    {
      /* Needed to keep the breakpoint lists in sync.  */
      if (! has_vforked)
	detach_breakpoints (child_pid);

      /* Before detaching from the parent, remove all breakpoints from it. */
      remove_breakpoints ();

      /* Also reset the solib inferior hook from the parent. */
#ifdef SOLIB_REMOVE_INFERIOR_HOOK
      SOLIB_REMOVE_INFERIOR_HOOK (PIDGET (inferior_ptid));
#endif

      /* Detach from the parent. */
      target_detach (NULL, 1);

      /* Attach to the child. */
      printf_unfiltered ("Attaching after fork to %s\n",
			 target_pid_to_str (pid_to_ptid (child_pid)));
      hppa_require_attach (child_pid);
      inferior_ptid = pid_to_ptid (child_pid);

      /* If we vforked, then we've also execed by now.  The exec will be
	 reported momentarily.  follow_exec () will handle breakpoints, so
	 we don't have to..  */
      if (!has_vforked)
	follow_inferior_reset_breakpoints ();
    }

  if (has_vforked)
    {
      /* If we followed the parent, don't try to follow the child's exec.  */
      if (saved_vfork_state != STATE_GOT_PARENT
	  && saved_vfork_state != STATE_FAKE_EXEC)
	fprintf_unfiltered (gdb_stdout,
			    "hppa: post follow vfork: confused state\n");

      if (! follow_child || saved_vfork_state == STATE_GOT_PARENT)
	saved_vfork_state = STATE_NONE;
      else
	return 1;
    }
  return 0;
}

/* Format a process id, given PID.  Be sure to terminate
   this with a null--it's going to be printed via a "%s".  */
char *
child_pid_to_str (ptid_t ptid)
{
  /* Static because address returned */
  static char buf[30];
  pid_t pid = PIDGET (ptid);

  /* Extra NUL for paranoia's sake */
  sprintf (buf, "process %d%c", pid, '\0');

  return buf;
}

/* Format a thread id, given TID.  Be sure to terminate
   this with a null--it's going to be printed via a "%s".

   Note: This is a core-gdb tid, not the actual system tid.
   See infttrace.c for details.  */
char *
hppa_tid_to_str (ptid_t ptid)
{
  /* Static because address returned */
  static char buf[30];
  /* This seems strange, but when I did the ptid conversion, it looked
     as though a pid was always being passed.  - Kevin Buettner  */
  pid_t tid = PIDGET (ptid);

  /* Extra NULLs for paranoia's sake */
  sprintf (buf, "system thread %d%c", tid, '\0');

  return buf;
}

/*## */
/* Enable HACK for ttrace work.  In
 * infttrace.c/require_notification_of_events,
 * this is set to 0 so that the loop in child_wait
 * won't loop.
 */
int not_same_real_pid = 1;
/*## */

/* Wait for child to do something.  Return pid of child, or -1 in case
   of error; store status through argument pointer OURSTATUS.  */

ptid_t
child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  int save_errno;
  int status;
  char *execd_pathname = NULL;
  int exit_status;
  int related_pid;
  int syscall_id;
  enum target_waitkind kind;
  int pid;

  if (saved_vfork_state == STATE_FAKE_EXEC)
    {
      saved_vfork_state = STATE_NONE;
      ourstatus->kind = TARGET_WAITKIND_EXECD;
      ourstatus->value.execd_pathname = saved_child_execd_pathname;
      return inferior_ptid;
    }

  do
    {
      set_sigint_trap ();	/* Causes SIGINT to be passed on to the
				   attached process. */
      set_sigio_trap ();

      pid = ptrace_wait (inferior_ptid, &status);

      save_errno = errno;

      clear_sigio_trap ();

      clear_sigint_trap ();

      if (pid == -1)
	{
	  if (save_errno == EINTR)
	    continue;

	  fprintf_unfiltered (gdb_stderr, "Child process unexpectedly missing: %s.\n",
			      safe_strerror (save_errno));

	  /* Claim it exited with unknown signal.  */
	  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
	  ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
	  return pid_to_ptid (-1);
	}

      /* Did it exit?
       */
      if (target_has_exited (pid, status, &exit_status))
	{
	  /* ??rehrauer: For now, ignore this. */
	  continue;
	}

      if (!target_thread_alive (pid_to_ptid (pid)))
	{
	  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;
	  return pid_to_ptid (pid);
	}

      if (hpux_has_forked (pid, &related_pid))
	{
	  /* Ignore the parent's fork event.  */
	  if (pid == PIDGET (inferior_ptid))
	    {
	      ourstatus->kind = TARGET_WAITKIND_IGNORE;
	      return inferior_ptid;
	    }

	  /* If this is the child's fork event, report that the
	     process has forked.  */
	  if (related_pid == PIDGET (inferior_ptid))
	    {
	      ourstatus->kind = TARGET_WAITKIND_FORKED;
	      ourstatus->value.related_pid = pid;
	      return inferior_ptid;
	    }
	}

      if (hpux_has_vforked (pid, &related_pid))
	{
	  if (pid == PIDGET (inferior_ptid))
	    {
	      if (saved_vfork_state == STATE_GOT_CHILD)
		saved_vfork_state = STATE_GOT_PARENT;
	      else if (saved_vfork_state == STATE_GOT_EXEC)
		saved_vfork_state = STATE_FAKE_EXEC;
	      else
		fprintf_unfiltered (gdb_stdout,
				    "hppah: parent vfork: confused\n");
	    }
	  else if (related_pid == PIDGET (inferior_ptid))
	    {
	      if (saved_vfork_state == STATE_NONE)
		saved_vfork_state = STATE_GOT_CHILD;
	      else
		fprintf_unfiltered (gdb_stdout,
				    "hppah: child vfork: confused\n");
	    }
	  else
	    fprintf_unfiltered (gdb_stdout,
				"hppah: unknown vfork: confused\n");

	  if (saved_vfork_state == STATE_GOT_CHILD)
	    {
	      child_post_startup_inferior (pid_to_ptid (pid));
	      detach_breakpoints (pid);
#ifdef SOLIB_REMOVE_INFERIOR_HOOK
	      SOLIB_REMOVE_INFERIOR_HOOK (pid);
#endif
	      child_resume (pid_to_ptid (pid), 0, TARGET_SIGNAL_0);
	      ourstatus->kind = TARGET_WAITKIND_IGNORE;
	      return pid_to_ptid (related_pid);
	    }
	  else if (saved_vfork_state == STATE_FAKE_EXEC)
	    {
	      ourstatus->kind = TARGET_WAITKIND_VFORKED;
	      ourstatus->value.related_pid = related_pid;
	      return pid_to_ptid (pid);
	    }
	  else
	    {
	      /* We saw the parent's vfork, but we haven't seen the exec yet.
		 Wait for it, for simplicity's sake.  It should be pending.  */
	      saved_vfork_pid = related_pid;
	      ourstatus->kind = TARGET_WAITKIND_IGNORE;
	      return pid_to_ptid (pid);
	    }
	}

      if (hpux_has_execd (pid, &execd_pathname))
	{
	  /* On HP-UX, events associated with a vforking inferior come in
	     threes: a vfork event for the child (always first), followed
	     a vfork event for the parent and an exec event for the child.
	     The latter two can come in either order.  Make sure we get
	     both.  */
	  if (saved_vfork_state != STATE_NONE)
	    {
	      if (saved_vfork_state == STATE_GOT_CHILD)
		{
		  saved_vfork_state = STATE_GOT_EXEC;
		  /* On HP/UX with ptrace, the child must be resumed before
		     the parent vfork event is delivered.  A single-step
		     suffices.  */
		  if (RESUME_EXECD_VFORKING_CHILD_TO_GET_PARENT_VFORK ())
		    target_resume (pid_to_ptid (pid), 1, TARGET_SIGNAL_0);
		  ourstatus->kind = TARGET_WAITKIND_IGNORE;
		}
	      else if (saved_vfork_state == STATE_GOT_PARENT)
		{
		  saved_vfork_state = STATE_FAKE_EXEC;
		  ourstatus->kind = TARGET_WAITKIND_VFORKED;
		  ourstatus->value.related_pid = saved_vfork_pid;
		}
	      else
		fprintf_unfiltered (gdb_stdout,
				    "hppa: exec: unexpected state\n");

	      saved_child_execd_pathname = execd_pathname;

	      return inferior_ptid;
	    }
	  
	  /* Are we ignoring initial exec events?  (This is likely because
	     we're in the process of starting up the inferior, and another
	     (older) mechanism handles those.)  If so, we'll report this
	     as a regular stop, not an exec.
	   */
	  if (inferior_ignoring_startup_exec_events)
	    {
	      inferior_ignoring_startup_exec_events--;
	    }
	  else
	    {
	      ourstatus->kind = TARGET_WAITKIND_EXECD;
	      ourstatus->value.execd_pathname = execd_pathname;
	      return pid_to_ptid (pid);
	    }
	}

      /* All we must do with these is communicate their occurrence
         to wait_for_inferior...
       */
      if (hpux_has_syscall_event (pid, &kind, &syscall_id))
	{
	  ourstatus->kind = kind;
	  ourstatus->value.syscall_id = syscall_id;
	  return pid_to_ptid (pid);
	}

      /*##  } while (pid != PIDGET (inferior_ptid)); ## *//* Some other child died or stopped */
/* hack for thread testing */
    }
  while ((pid != PIDGET (inferior_ptid)) && not_same_real_pid);
/*## */

  store_waitstatus (ourstatus, status);
  return pid_to_ptid (pid);
}

#if !defined (GDB_NATIVE_HPUX_11)

/* The following code is a substitute for the infttrace.c versions used
   with ttrace() in HPUX 11.  */

/* This value is an arbitrary integer. */
#define PT_VERSION 123456

/* This semaphore is used to coordinate the child and parent processes
   after a fork(), and before an exec() by the child.  See
   parent_attach_all for details.  */

typedef struct
{
  int parent_channel[2];	/* Parent "talks" to [1], child "listens" to [0] */
  int child_channel[2];		/* Child "talks" to [1], parent "listens" to [0] */
}
startup_semaphore_t;

#define SEM_TALK (1)
#define SEM_LISTEN (0)

static startup_semaphore_t startup_semaphore;

#ifdef PT_SETTRC
/* This function causes the caller's process to be traced by its
   parent.  This is intended to be called after GDB forks itself,
   and before the child execs the target.

   Note that HP-UX ptrace is rather funky in how this is done.
   If the parent wants to get the initial exec event of a child,
   it must set the ptrace event mask of the child to include execs.
   (The child cannot do this itself.)  This must be done after the
   child is forked, but before it execs.

   To coordinate the parent and child, we implement a semaphore using
   pipes.  After SETTRC'ing itself, the child tells the parent that
   it is now traceable by the parent, and waits for the parent's
   acknowledgement.  The parent can then set the child's event mask,
   and notify the child that it can now exec.

   (The acknowledgement by parent happens as a result of a call to
   child_acknowledge_created_inferior.)  */

int
parent_attach_all (int pid, PTRACE_ARG3_TYPE addr, int data)
{
  int pt_status = 0;

  /* We need a memory home for a constant.  */
  int tc_magic_child = PT_VERSION;
  int tc_magic_parent = 0;

  /* The remainder of this function is only useful for HPUX 10.0 and
     later, as it depends upon the ability to request notification
     of specific kinds of events by the kernel.  */
#if defined(PT_SET_EVENT_MASK)

  /* Notify the parent that we're potentially ready to exec(). */
  write (startup_semaphore.child_channel[SEM_TALK],
	 &tc_magic_child,
	 sizeof (tc_magic_child));

  /* Wait for acknowledgement from the parent. */
  read (startup_semaphore.parent_channel[SEM_LISTEN],
	&tc_magic_parent,
	sizeof (tc_magic_parent));
  if (tc_magic_child != tc_magic_parent)
    warning ("mismatched semaphore magic");

  /* Discard our copy of the semaphore. */
  (void) close (startup_semaphore.parent_channel[SEM_LISTEN]);
  (void) close (startup_semaphore.parent_channel[SEM_TALK]);
  (void) close (startup_semaphore.child_channel[SEM_LISTEN]);
  (void) close (startup_semaphore.child_channel[SEM_TALK]);
#endif

  return 0;
}
#endif

int
hppa_require_attach (int pid)
{
  int pt_status;
  CORE_ADDR pc;
  CORE_ADDR pc_addr;
  unsigned int regs_offset;

  /* Are we already attached?  There appears to be no explicit way to
     answer this via ptrace, so we try something which should be
     innocuous if we are attached.  If that fails, then we assume
     we're not attached, and so attempt to make it so. */

  errno = 0;
  regs_offset = U_REGS_OFFSET;
  pc_addr = register_addr (PC_REGNUM, regs_offset);
  pc = call_ptrace (PT_READ_U, pid, (PTRACE_ARG3_TYPE) pc_addr, 0);

  if (errno)
    {
      errno = 0;
      pt_status = call_ptrace (PT_ATTACH, pid, (PTRACE_ARG3_TYPE) 0, 0);

      if (errno)
	return -1;

      /* Now we really are attached. */
      errno = 0;
    }
  attach_flag = 1;
  return pid;
}

int
hppa_require_detach (int pid, int signal)
{
  errno = 0;
  call_ptrace (PT_DETACH, pid, (PTRACE_ARG3_TYPE) 1, signal);
  errno = 0;			/* Ignore any errors. */
  return pid;
}

/* Since ptrace doesn't support memory page-protection events, which
   are used to implement "hardware" watchpoints on HP-UX, these are
   dummy versions, which perform no useful work.  */

void
hppa_enable_page_protection_events (int pid)
{
}

void
hppa_disable_page_protection_events (int pid)
{
}

int
hppa_insert_hw_watchpoint (int pid, CORE_ADDR start, LONGEST len, int type)
{
  error ("Hardware watchpoints not implemented on this platform.");
}

int
hppa_remove_hw_watchpoint (int pid, CORE_ADDR start, LONGEST len, int type)
{
  error ("Hardware watchpoints not implemented on this platform.");
}

int
hppa_can_use_hw_watchpoint (int type, int cnt, int ot)
{
  return 0;
}

int
hppa_range_profitable_for_hw_watchpoint (int pid, CORE_ADDR start, LONGEST len)
{
  error ("Hardware watchpoints not implemented on this platform.");
}

char *
hppa_pid_or_tid_to_str (ptid_t id)
{
  /* In the ptrace world, there are only processes. */
  return child_pid_to_str (id);
}

void
hppa_ensure_vforking_parent_remains_stopped (int pid)
{
  /* This assumes that the vforked parent is presently stopped, and
     that the vforked child has just delivered its first exec event.
     Calling kill() this way will cause the SIGTRAP to be delivered as
     soon as the parent is resumed, which happens as soon as the
     vforked child is resumed.  See wait_for_inferior for the use of
     this function.  */
  kill (pid, SIGTRAP);
}

int
hppa_resume_execd_vforking_child_to_get_parent_vfork (void)
{
  return 1;			/* Yes, the child must be resumed. */
}

void
require_notification_of_events (int pid)
{
#if defined(PT_SET_EVENT_MASK)
  int pt_status;
  ptrace_event_t ptrace_events;
  int nsigs;
  int signum;

  /* Instruct the kernel as to the set of events we wish to be
     informed of.  (This support does not exist before HPUX 10.0.
     We'll assume if PT_SET_EVENT_MASK has not been defined by
     <sys/ptrace.h>, then we're being built on pre-10.0.)  */
  memset (&ptrace_events, 0, sizeof (ptrace_events));

  /* Note: By default, all signals are visible to us.  If we wish
     the kernel to keep certain signals hidden from us, we do it
     by calling sigdelset (ptrace_events.pe_signals, signal) for
     each such signal here, before doing PT_SET_EVENT_MASK.  */
  /* RM: The above comment is no longer true. We start with ignoring
     all signals, and then add the ones we are interested in. We could
     do it the other way: start by looking at all signals and then
     deleting the ones that we aren't interested in, except that
     multiple gdb signals may be mapped to the same host signal
     (eg. TARGET_SIGNAL_IO and TARGET_SIGNAL_POLL both get mapped to
     signal 22 on HPUX 10.20) We want to be notified if we are
     interested in either signal.  */
  sigfillset (&ptrace_events.pe_signals);

  /* RM: Let's not bother with signals we don't care about */
  nsigs = (int) TARGET_SIGNAL_LAST;
  for (signum = nsigs; signum > 0; signum--)
    {
      if ((signal_stop_state (signum)) ||
	  (signal_print_state (signum)) ||
	  (!signal_pass_state (signum)))
	{
	  if (target_signal_to_host_p (signum))
	    sigdelset (&ptrace_events.pe_signals,
		       target_signal_to_host (signum));
	}
    }

  ptrace_events.pe_set_event = 0;

  ptrace_events.pe_set_event |= PTRACE_SIGNAL;
  ptrace_events.pe_set_event |= PTRACE_EXEC;
  ptrace_events.pe_set_event |= PTRACE_FORK;
  ptrace_events.pe_set_event |= PTRACE_VFORK;
  /* ??rehrauer: Add this one when we're prepared to catch it...
     ptrace_events.pe_set_event |= PTRACE_EXIT;
   */

  errno = 0;
  pt_status = call_ptrace (PT_SET_EVENT_MASK,
			   pid,
			   (PTRACE_ARG3_TYPE) & ptrace_events,
			   sizeof (ptrace_events));
  if (errno)
    perror_with_name ("ptrace");
  if (pt_status < 0)
    return;
#endif
}

void
require_notification_of_exec_events (int pid)
{
#if defined(PT_SET_EVENT_MASK)
  int pt_status;
  ptrace_event_t ptrace_events;

  /* Instruct the kernel as to the set of events we wish to be
     informed of.  (This support does not exist before HPUX 10.0.
     We'll assume if PT_SET_EVENT_MASK has not been defined by
     <sys/ptrace.h>, then we're being built on pre-10.0.)  */
  memset (&ptrace_events, 0, sizeof (ptrace_events));

  /* Note: By default, all signals are visible to us.  If we wish
     the kernel to keep certain signals hidden from us, we do it
     by calling sigdelset (ptrace_events.pe_signals, signal) for
     each such signal here, before doing PT_SET_EVENT_MASK.  */
  sigemptyset (&ptrace_events.pe_signals);

  ptrace_events.pe_set_event = 0;

  ptrace_events.pe_set_event |= PTRACE_EXEC;
  /* ??rehrauer: Add this one when we're prepared to catch it...
     ptrace_events.pe_set_event |= PTRACE_EXIT;
   */

  errno = 0;
  pt_status = call_ptrace (PT_SET_EVENT_MASK,
			   pid,
			   (PTRACE_ARG3_TYPE) & ptrace_events,
			   sizeof (ptrace_events));
  if (errno)
    perror_with_name ("ptrace");
  if (pt_status < 0)
    return;
#endif
}

/* This function is called by the parent process, with pid being the
   ID of the child process, after the debugger has forked.  */

void
child_acknowledge_created_inferior (int pid)
{
  /* We need a memory home for a constant.  */
  int tc_magic_parent = PT_VERSION;
  int tc_magic_child = 0;

  /* The remainder of this function is only useful for HPUX 10.0 and
     later, as it depends upon the ability to request notification
     of specific kinds of events by the kernel.  */
#if defined(PT_SET_EVENT_MASK)
  /* Wait for the child to tell us that it has forked. */
  read (startup_semaphore.child_channel[SEM_LISTEN],
	&tc_magic_child,
	sizeof (tc_magic_child));

  /* Notify the child that it can exec.

     In the infttrace.c variant of this function, we set the child's
     event mask after the fork but before the exec.  In the ptrace
     world, it seems we can't set the event mask until after the exec.  */
  write (startup_semaphore.parent_channel[SEM_TALK],
	 &tc_magic_parent,
	 sizeof (tc_magic_parent));

  /* We'd better pause a bit before trying to set the event mask,
     though, to ensure that the exec has happened.  We don't want to
     wait() on the child, because that'll screw up the upper layers
     of gdb's execution control that expect to see the exec event.

     After an exec, the child is no longer executing gdb code.  Hence,
     we can't have yet another synchronization via the pipes.  We'll
     just sleep for a second, and hope that's enough delay...  */
  sleep (1);

  /* Instruct the kernel as to the set of events we wish to be
     informed of.  */
  require_notification_of_exec_events (pid);

  /* Discard our copy of the semaphore. */
  (void) close (startup_semaphore.parent_channel[SEM_LISTEN]);
  (void) close (startup_semaphore.parent_channel[SEM_TALK]);
  (void) close (startup_semaphore.child_channel[SEM_LISTEN]);
  (void) close (startup_semaphore.child_channel[SEM_TALK]);
#endif
}

void
child_post_startup_inferior (ptid_t ptid)
{
  require_notification_of_events (PIDGET (ptid));
}

void
child_post_attach (int pid)
{
  require_notification_of_events (pid);
}

int
child_insert_fork_catchpoint (int pid)
{
  /* This request is only available on HPUX 10.0 and later.  */
#if !defined(PT_SET_EVENT_MASK)
  error ("Unable to catch forks prior to HPUX 10.0");
#else
  /* Enable reporting of fork events from the kernel. */
  /* ??rehrauer: For the moment, we're always enabling these events,
     and just ignoring them if there's no catchpoint to catch them.  */
  return 0;
#endif
}

int
child_remove_fork_catchpoint (int pid)
{
  /* This request is only available on HPUX 10.0 and later.  */
#if !defined(PT_SET_EVENT_MASK)
  error ("Unable to catch forks prior to HPUX 10.0");
#else
  /* Disable reporting of fork events from the kernel. */
  /* ??rehrauer: For the moment, we're always enabling these events,
     and just ignoring them if there's no catchpoint to catch them.  */
  return 0;
#endif
}

int
child_insert_vfork_catchpoint (int pid)
{
  /* This request is only available on HPUX 10.0 and later.  */
#if !defined(PT_SET_EVENT_MASK)
  error ("Unable to catch vforks prior to HPUX 10.0");
#else
  /* Enable reporting of vfork events from the kernel. */
  /* ??rehrauer: For the moment, we're always enabling these events,
     and just ignoring them if there's no catchpoint to catch them.  */
  return 0;
#endif
}

int
child_remove_vfork_catchpoint (int pid)
{
  /* This request is only available on HPUX 10.0 and later.  */
#if !defined(PT_SET_EVENT_MASK)
  error ("Unable to catch vforks prior to HPUX 10.0");
#else
  /* Disable reporting of vfork events from the kernel. */
  /* ??rehrauer: For the moment, we're always enabling these events,
     and just ignoring them if there's no catchpoint to catch them.  */
  return 0;
#endif
}

int
hpux_has_forked (int pid, int *childpid)
{
  /* This request is only available on HPUX 10.0 and later.  */
#if !defined(PT_GET_PROCESS_STATE)
  *childpid = 0;
  return 0;
#else
  int pt_status;
  ptrace_state_t ptrace_state;

  errno = 0;
  pt_status = call_ptrace (PT_GET_PROCESS_STATE,
			   pid,
			   (PTRACE_ARG3_TYPE) & ptrace_state,
			   sizeof (ptrace_state));
  if (errno)
    perror_with_name ("ptrace");
  if (pt_status < 0)
    return 0;

  if (ptrace_state.pe_report_event & PTRACE_FORK)
    {
      *childpid = ptrace_state.pe_other_pid;
      return 1;
    }

  return 0;
#endif
}

int
hpux_has_vforked (int pid, int *childpid)
{
  /* This request is only available on HPUX 10.0 and later.  */
#if !defined(PT_GET_PROCESS_STATE)
  *childpid = 0;
  return 0;

#else
  int pt_status;
  ptrace_state_t ptrace_state;

  errno = 0;
  pt_status = call_ptrace (PT_GET_PROCESS_STATE,
			   pid,
			   (PTRACE_ARG3_TYPE) & ptrace_state,
			   sizeof (ptrace_state));
  if (errno)
    perror_with_name ("ptrace");
  if (pt_status < 0)
    return 0;

  if (ptrace_state.pe_report_event & PTRACE_VFORK)
    {
      *childpid = ptrace_state.pe_other_pid;
      return 1;
    }

  return 0;
#endif
}

int
child_insert_exec_catchpoint (int pid)
{
  /* This request is only available on HPUX 10.0 and later.   */
#if !defined(PT_SET_EVENT_MASK)
  error ("Unable to catch execs prior to HPUX 10.0");

#else
  /* Enable reporting of exec events from the kernel.  */
  /* ??rehrauer: For the moment, we're always enabling these events,
     and just ignoring them if there's no catchpoint to catch them.  */
  return 0;
#endif
}

int
child_remove_exec_catchpoint (int pid)
{
  /* This request is only available on HPUX 10.0 and later.  */
#if !defined(PT_SET_EVENT_MASK)
  error ("Unable to catch execs prior to HPUX 10.0");

#else
  /* Disable reporting of exec events from the kernel. */
  /* ??rehrauer: For the moment, we're always enabling these events,
     and just ignoring them if there's no catchpoint to catch them.  */
  return 0;
#endif
}

int
hpux_has_execd (int pid, char **execd_pathname)
{
  /* This request is only available on HPUX 10.0 and later.  */
#if !defined(PT_GET_PROCESS_STATE)
  *execd_pathname = NULL;
  return 0;

#else
  int pt_status;
  ptrace_state_t ptrace_state;

  errno = 0;
  pt_status = call_ptrace (PT_GET_PROCESS_STATE,
			   pid,
			   (PTRACE_ARG3_TYPE) & ptrace_state,
			   sizeof (ptrace_state));
  if (errno)
    perror_with_name ("ptrace");
  if (pt_status < 0)
    return 0;

  if (ptrace_state.pe_report_event & PTRACE_EXEC)
    {
      char *exec_file = target_pid_to_exec_file (pid);
      *execd_pathname = savestring (exec_file, strlen (exec_file));
      return 1;
    }

  return 0;
#endif
}

int
child_reported_exec_events_per_exec_call (void)
{
  return 2;			/* ptrace reports the event twice per call. */
}

int
hpux_has_syscall_event (int pid, enum target_waitkind *kind, int *syscall_id)
{
  /* This request is only available on HPUX 10.30 and later, via
     the ttrace interface.  */

  *kind = TARGET_WAITKIND_SPURIOUS;
  *syscall_id = -1;
  return 0;
}

char *
child_pid_to_exec_file (int pid)
{
  static char exec_file_buffer[1024];
  int pt_status;
  CORE_ADDR top_of_stack;
  char four_chars[4];
  int name_index;
  int i;
  ptid_t saved_inferior_ptid;
  int done;

#ifdef PT_GET_PROCESS_PATHNAME
  /* As of 10.x HP-UX, there's an explicit request to get the pathname. */
  pt_status = call_ptrace (PT_GET_PROCESS_PATHNAME,
			   pid,
			   (PTRACE_ARG3_TYPE) exec_file_buffer,
			   sizeof (exec_file_buffer) - 1);
  if (pt_status == 0)
    return exec_file_buffer;
#endif

  /* It appears that this request is broken prior to 10.30.
     If it fails, try a really, truly amazingly gross hack
     that DDE uses, of pawing through the process' data
     segment to find the pathname.  */

  top_of_stack = 0x7b03a000;
  name_index = 0;
  done = 0;

  /* On the chance that pid != inferior_ptid, set inferior_ptid
     to pid, so that (grrrr!) implicit uses of inferior_ptid get
     the right id.  */

  saved_inferior_ptid = inferior_ptid;
  inferior_ptid = pid_to_ptid (pid);

  /* Try to grab a null-terminated string. */
  while (!done)
    {
      if (target_read_memory (top_of_stack, four_chars, 4) != 0)
	{
	  inferior_ptid = saved_inferior_ptid;
	  return NULL;
	}
      for (i = 0; i < 4; i++)
	{
	  exec_file_buffer[name_index++] = four_chars[i];
	  done = (four_chars[i] == '\0');
	  if (done)
	    break;
	}
      top_of_stack += 4;
    }

  if (exec_file_buffer[0] == '\0')
    {
      inferior_ptid = saved_inferior_ptid;
      return NULL;
    }

  inferior_ptid = saved_inferior_ptid;
  return exec_file_buffer;
}

void
pre_fork_inferior (void)
{
  int status;

  status = pipe (startup_semaphore.parent_channel);
  if (status < 0)
    {
      warning ("error getting parent pipe for startup semaphore");
      return;
    }

  status = pipe (startup_semaphore.child_channel);
  if (status < 0)
    {
      warning ("error getting child pipe for startup semaphore");
      return;
    }
}


/* Check to see if the given thread is alive.

   This is a no-op, as ptrace doesn't support threads, so we just
   return "TRUE".  */

int
child_thread_alive (ptid_t ptid)
{
  return 1;
}

#endif /* ! GDB_NATIVE_HPUX_11 */
@


1.36
log
@2004-12-05  Randolph Chung  <tausq@@debian.org>

	* hppah-nat.c (store_inferior_registers): Rewrite logic to not use
	DEPRECATED_REGISTER_BYTE.
@
text
@@


1.35
log
@	* infttrace.h (ttrace_write_reg_64): Add prototype.
	* hppah-nat.c (store_inferior_registers): Fix warning from ambiguous
	expression.
	(store_inferior_registers): Correct formatting.  Replace uses of
	deprecated_registers with calls to regcache_raw_read,
	regcache_raw_write_part and regcache_raw_read_part.
@
text
@d117 3
a119 2
	addr = (HPPAH_OFFSETOF (save_state_t, ss_fpblock) 
		+ (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (HPPA_FP0_REGNUM)));
d127 2
a128 2
	addr = (HPPAH_OFFSETOF (save_state_t, ss_wide) 
		+ DEPRECATED_REGISTER_BYTE (regno));
d133 2
a134 2
	addr = (HPPAH_OFFSETOF (save_state_t, ss_narrow)
		+ (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (1)));
@


1.34
log
@2004-10-05  Andrew Cagney  <cagney@@gnu.org>

	* target.h (deprecated_child_ops): Rename child_ops.
	* wince.c: Update copyright.  Rename child_ops.
	* win32-nat.c: Rename child_ops.
	* target.c: Rename child_ops.
	* rs6000-nat.c: Rename child_ops.
	* linux-nat.c: Rename child_ops.
	* infttrace.c: Rename child_ops.
	* inftarg.c: Rename child_ops.
	* infptrace.c: Rename child_ops.
	* hppah-nat.c: Update copyright.  Rename child_ops.
	* hpux-thread.c: Update copyright.  Rename child_ops.
@
text
@d144 1
a144 1
      if (regno == HPPA_PCOQ_HEAD_REGNUM || regno == HPPA_PCOQ_TAIL_REGNUM && len == 8)
d148 1
a148 1
	  temp = *(CORE_ADDR *)&deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)];
d158 1
a158 1
	  if (errno != 0)
d173 6
a178 1
	*(int *)&deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)] = 0;
d183 2
d186 2
d190 1
a190 1
		       *(int *) &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno) + i]);
@


1.33
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d1 4
a4 4
/* Native support code for HPUX PA-RISC.
   Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d292 4
a295 4
   Returns the length copied, which is either the LEN argument or zero.
   This xfer function does not do partial moves, since child_ops
   doesn't allow memory operations to cross below us in the target stack
   anyway.  TARGET is ignored.  */
@


1.32
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d98 1
a98 1
      len = DEPRECATED_REGISTER_RAW_SIZE (regno);
d109 4
a112 5
	     DEPRECATED_REGISTER_RAW_SIZE(0) says.  Assuming all HP-UX
	     PA machines are big-endian, put it at the least
	     significant end of the value, and zap the rest of the
	     buffer.  */
	  offset = DEPRECATED_REGISTER_RAW_SIZE (0) - len;
d215 1
a215 1
  len = DEPRECATED_REGISTER_RAW_SIZE (regno);
d226 4
a229 4
	 DEPRECATED_REGISTER_RAW_SIZE(0) says.  Assuming all HP-UX PA
	 machines are big-endian, put it at the least significant end
	 of the value, and zap the rest of the buffer.  */
      offset = DEPRECATED_REGISTER_RAW_SIZE (0) - len;
@


1.31
log
@2004-05-06  Randolph Chung  <tausq@@debian.org>

	* config/pa/tm-hppa.h (RO_REGNUM, FLAGS_REGNUM, RP_REGNUM)
	(HPPA_FP_REGNUM, HPPA_SP_REGNUM, SAR_REGNUM, IPSW_REGNUM)
	(PCOQ_HEAD_REGNUM, PCSQ_HEAD_REGNUM, PCOQ_TAIL_REGNUM, PCSQ_TAIL_REGNUM)
	(EIEM_REGNUM, IIR_REGNUM, ISR_REGNUM, IOR_REGNUM, SR4_REGNUM)
	(RCR_REGNUM, PID0_REGNUM, PID1_REGNUM, PID2_REGNUM, PID3_REGNUM)
	(CCR_REGNUM, TR0_REGNUM, CR27_REGNUM, HPPA_FP0_REGNUM, FP4_REGNUM)
	(ARG0_REGNUM, ARG1_REGNUM, ARG2_REGNUM, ARG3_REGNUM): Move *_REGNUM
	definitions ...
	* hppa-tdep.h: ... to here, with HPPA_ prefix.
	* Makefile.in (hppah-nat.o): Add $(hppa_tdep_h)
	* hppa-hpux-tdep.c (hppa32_hpux_frame_find_saved_regs_in_sig)
	(hppa64_hpux_frame_find_saved_regs_in_sig)
	(child_get_current_exception_event): Add HPPA_ prefix to *_REGNUM usage.
	* hppa-linux-nat.c (GR_REGNUM, TR_REGNUM, greg_map): Likewise.
	* hppa-linux-tdep.c (hppa_dwarf_reg_to_regnum)
	(hppa_linux_target_write_pc, hppa_linux_sigtramp_frame_unwind_cache)
	(hppa_linux_sigtramp_frame_prev_register): Likewise.
	* hppa-tdep.c (hppa32_return_value, hppa64_return_value)
	(hppa32_push_dummy_call, hppa64_push_dummy_call, hppa64_frame_align)
	(hppa_target_read_pc, hppa_target_write_pc, hppa_frame_cache)
	(hppa_frame_prev_register, hppa_stub_frame_unwind_cache)
	(hppa_stub_frame_prev_register, hppa_unwind_dummy_id)
	(hppa_skip_permanent_breakpoint, hppa_instruction_nullified)
	(hppa32_register_type, hppa_cannot_store_register)
	(hppa_fetch_pointer_argument, hppa_pseudo_register_read): Likewise.
	* hppah-nat.c (store_inferior_registers, fetch_register): Likewise.
	* hpread.c (hpread_process_one_debug_symbol): Likewise.
	* pa64solib.c (pa64_solib_have_load_event)
	(pa64_solib_have_unload_event, pa64_solib_loaded_library_pathname)
	(pa64_solib_unloaded_library_pathname): Likewise.
	* somsolib.c (som_solib_have_load_event, som_solib_have_unload_event)
	(som_solib_library_pathname): Likewise.
@
text
@d285 1
a285 1
  supply_register (regno, buf);
@


1.30
log
@2004-04-06  Andrew Cagney  <cagney@@redhat.com>

	* hppah-nat.c (hpux_has_forked, hpux_has_vforked)
	(hpux_has_execd, hpux_has_syscall_event): Include "infttrace.h",
	move extern declarations from here ...
	* infttrace.h: ... to here.
	* Makefile.in (hppah-nat.o): Update dependencies.
@
text
@d38 1
d117 1
a117 1
      else if (regno >= FP0_REGNUM)
d119 1
a119 1
		+ (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (FP0_REGNUM)));
d145 1
a145 1
      if (regno == PCOQ_HEAD_REGNUM || regno == PCOQ_TAIL_REGNUM && len == 8)
d173 1
a173 1
     if (regno == IPSW_REGNUM && len == 8)
d193 1
a193 1
	      if (regno == PCOQ_HEAD_REGNUM || regno == PCOQ_TAIL_REGNUM)
d235 1
a235 1
  else if (regno >= FP0_REGNUM)
d237 1
a237 1
	    + (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (FP0_REGNUM)));
d282 1
a282 1
  if (regno == PCOQ_HEAD_REGNUM || regno == PCOQ_TAIL_REGNUM)
@


1.29
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d35 1
a37 5
extern int hpux_has_forked (int pid, int *childpid);
extern int hpux_has_vforked (int pid, int *childpid);
extern int hpux_has_execd (int pid, char **execd_pathname);
extern int hpux_has_syscall_event (int pid, enum target_waitkind *kind,
				   int *syscall_id);
@


1.29.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a34 1
#include "infttrace.h"
d37 5
a41 1
#include "hppa-tdep.h"
d101 1
a101 1
      len = register_size (current_gdbarch, regno);
d112 5
a116 4
	     register_size (0) says.  Assuming all HP-UX PA machines
	     are big-endian, put it at the least significant end of
	     the value, and zap the rest of the buffer.  */
	  offset = register_size (current_gdbarch, 0) - len;
d120 1
a120 1
      else if (regno >= HPPA_FP0_REGNUM)
d122 1
a122 1
		+ (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (HPPA_FP0_REGNUM)));
d148 1
a148 1
      if (regno == HPPA_PCOQ_HEAD_REGNUM || regno == HPPA_PCOQ_TAIL_REGNUM && len == 8)
d176 1
a176 1
     if (regno == HPPA_IPSW_REGNUM && len == 8)
d196 1
a196 1
	      if (regno == HPPA_PCOQ_HEAD_REGNUM || regno == HPPA_PCOQ_TAIL_REGNUM)
d219 1
a219 1
  len = register_size (current_gdbarch, regno);
d230 4
a233 4
	 register_size (0) says.  Assuming all HP-UX PA machines are
	 big-endian, put it at the least significant end of the value,
	 and zap the rest of the buffer.  */
      offset = register_size (current_gdbarch, 0) - len;
d238 1
a238 1
  else if (regno >= HPPA_FP0_REGNUM)
d240 1
a240 1
	    + (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (HPPA_FP0_REGNUM)));
d285 1
a285 1
  if (regno == HPPA_PCOQ_HEAD_REGNUM || regno == HPPA_PCOQ_TAIL_REGNUM)
d288 1
a288 1
  regcache_raw_supply (current_regcache, regno, buf);
@


1.28
log
@2003-09-19  Andrew Cagney  <cagney@@redhat.com>

	* config/pa/nm-hppah.h (NEED_TEXT_START_END): Delete.
	(DEPRECATED_HPUX_TEXT_END): Define.
	(deprecated_hpux_text_end): Declare.
	(struct target_ops): Declare opaque.
	* hppah-nat.c (text_end): Make static.
	(deprecated_hpux_text_end): New function.
	* exec.c (text_end): Delete global variable.
	(NEED_TEXT_START_END): Do not define.
	(exec_file_attach): Replace code computing "text_end" code with
	call to DEPRECATED_HPUX_TEXT_END.

2003-09-19  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	documentation for NEED_TEXT_START_END.
@
text
@d101 1
a101 1
      len = REGISTER_RAW_SIZE (regno);
d112 5
a116 4
	     REGISTER_RAW_SIZE(0) says.  Assuming all HP-UX PA machines
	     are big-endian, put it at the least significant end of the
	     value, and zap the rest of the buffer.  */
	  offset = REGISTER_RAW_SIZE (0) - len;
d219 1
a219 1
  len = REGISTER_RAW_SIZE (regno);
d230 4
a233 4
	 REGISTER_RAW_SIZE(0) says.  Assuming all HP-UX PA machines
	 are big-endian, put it at the least significant end of the
	 value, and zap the rest of the buffer.  */
      offset = REGISTER_RAW_SIZE (0) - len;
@


1.27
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTE): Rename REGISTER_BYTE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-linux-tdep.c, core-sol2.c, cris-tdep.c: Update.
	* d10v-tdep.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, irix5-nat.c, lynx-nat.c, m68knbsd-nat.c: Update.
	* mcore-tdep.c, mips-linux-tdep.c, mips-tdep.c: Update.
	* mipsv4-nat.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* ns32knbsd-nat.c, ppc-bdm.c, regcache.c, remote-sds.c: Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh64-tdep.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, v850-tdep.c: Update.
	* v850ice.c, vax-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-cisco.h, config/m68k/tm-delta68.h: Update.
	* config/pa/nm-hppah.h: Update.

2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* mi/mi-main.c: Rename REGISTER_BYTE to DEPRECATED_REGISTER_BYTE.
@
text
@a36 2
extern CORE_ADDR text_end;

d42 22
@


1.26
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d101 1
a101 1
		+ (REGISTER_BYTE (regno) - REGISTER_BYTE (FP0_REGNUM)));
d110 1
a110 1
		+ REGISTER_BYTE (regno));
d116 1
a116 1
		+ (REGISTER_BYTE (regno) - REGISTER_BYTE (1)));
d131 1
a131 1
	  temp = *(CORE_ADDR *)&deprecated_registers[REGISTER_BYTE (regno)];
d156 1
a156 1
	*(int *)&deprecated_registers[REGISTER_BYTE (regno)] = 0;
d164 1
a164 1
		       *(int *) &deprecated_registers[REGISTER_BYTE (regno) + i]);
d219 1
a219 1
	    + (REGISTER_BYTE (regno) - REGISTER_BYTE (FP0_REGNUM)));
d228 1
a228 1
	    + REGISTER_BYTE (regno));
d234 1
a234 1
	    + (REGISTER_BYTE (regno) - REGISTER_BYTE (1)));
@


1.25
log
@	* arch-utils.c (default_prepare_to_proceed): Remove.
	(generic_prepare_to_proceed): Remove.
	* arch-utils.h (default_prepare_to_proceed): Remove prototype.
	(generic_prepare_to_proceed): Remove prototype.
	* gdbarch.sh (PREPARE_TO_PROCEED): Remove.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-tdep.c (hppa_prepare_to_proceed): Remove dangling prototype.
	* hppah-nat.c (hppa_switched_threads): Remove.
	* infrun.c (prepare_to_proceed): New static function, copied from
	generic_prepare_to_proceed.  Remove select_it argument.
	(proceed): Call prepare_to_proceed.
	* infttrace.c (old_gdb_pid, reported_pid, reported_bpt): Remove
	variables.
	(ptrace_wait): Don't set the removed variables.
	(hppa_switched_threads): Remove.
	* lin-lwp.c (lin_lwp_prepare_to_proceed): Remove.
	* config/nm-linux.h (PREPARE_TO_PROCEED): Don't define.
	(lin_lwp_prepare_to_proceed): Remove prototype.
	* config/i386/nm-x86-64linux.h (PREPARE_TO_PROCEED): Don't undefine.
	* config/pa/nm-hppah.h (PREPARE_TO_PROCEED): Don't define.
@
text
@d67 1
a67 1
  register unsigned int regaddr;
d69 1
a69 1
  register int i;
d285 1
a285 1
  register int i;
d287 1
a287 1
  register CORE_ADDR addr = memaddr & - (CORE_ADDR)(sizeof (int));
d289 1
a289 1
  register int count
d300 1
a300 1
  register int *buffer = (int *) xmalloc (count * sizeof (int));
@


1.24
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (max_register_size): Delete declaration.
	* regcache.c (max_register_size): Delete function.
	(struct regcache_descr): Delete field "max_register_size".
	(init_regcache_descr, init_legacy_regcache_descr): Assert that all
	registers fit in MAX_REGISTER_SIZE.
	(regcache_save): Replace max_register_size with MAX_REGISTER_SIZE.
	(regcache_restore, regcache_xfer_part, regcache_dump): Ditto.
	* thread-db.c: Replace max_register_size with MAX_REGISTER_SIZE.
	* sh-tdep.c, rom68k-rom.c, remote-sim.c, remote-mips.c: Ditto.
	* remote-e7000.c, monitor.c, mipsv4-nat.c, mips-nat.c: Ditto.
	* m68klinux-nat.c, lynx-nat.c, irix4-nat.c: Ditto.
	* hpux-thread.c, hppah-nat.c, hppab-nat.c, hppa-tdep.c: Ditto.
	* dve3900-rom.c, hppa-tdep.c: Ditto.
@
text
@a932 10
/* This function has no meaning in a non-threaded world.  Thus, we
   return 0 (FALSE).  See the use of "hppa_prepare_to_proceed" in
   hppa-tdep.c. */

pid_t
hppa_switched_threads (pid_t pid)
{
  return (pid_t) 0;
}

@


1.23
log
@2003-03-29  Andrew Cagney  <cagney@@redhat.com>

	* infttrace.h: New file.
	* hpread.c: Include "gdb_assert.h" and "somsolib.h".
	(hpread_get_textlow): Detect an uninitialized dn_bufp.
	(hpread_read_doc_function_type): Detect an initialized type1.
	(hpread_quick_traverse): Initialize mod_name_string.
	* somsolib.h: Add #ifdef SOMSOLIB_H wrapper.
	(som_solib_get_solib_by_pc): Declare.
	(so_lib_thread_start_addr): Declare.
	(no_shared_libraries): Declare.
	* somread.c (init_import_symbols): Make static.  Add forward
	declaration.
	* config/pa/nm-hppah.h: Include "infttrace.h" for
	parent_attach_all.
	(hppa_insert_hw_watchpoint): Declare.
	(hppa_can_use_hw_watchpoint, hppa_remove_hw_watchpoint): Declare.
	* hppah-nat.c: Include "gdb_string.h".
	(parent_attach_all): Delete extern declaration, moved to
	"infttrace.h".
	(hppa_can_use_hw_watchpoint): Change type of "type" parameter to
	int.
	(hppa_remove_hw_watchpoint, hppa_insert_hw_watchpoint): Ditto.
	* Makefile.in (infttrace_h): Define.
	(hpread.o): Update dependencies.
	(hppah-nat.o, hppa-hpux-tdep.o, hppa-tdep.o): Ditto.
	* hppa-hpux-tdep.c: Include "gdb_string.h".
	* hppa-tdep.c (hppa_frame_saved_pc): Initialize "old_pc".
	* infrun.c (handle_inferior_event): Always initialize
	stepped_after_stopped_by_watchpoint.  Add default and remove
	fallthrough in switch statement.
	* infttrace.c (hppa_can_use_hw_watchpoint): Change type of "type"
	parameter to int.
	(hppa_remove_hw_watchpoint): Ditto.
@
text
@d193 1
a193 1
  char *buf = alloca (max_register_size (current_gdbarch));
@


1.23.6.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d193 1
a193 1
  char buf[MAX_REGISTER_SIZE];
@


1.22
log
@2003-02-02  Andrew Cagney  <ac131313@@redhat.com>

	* mips-nat.c (zerobuf): Delete.
	(fetch_inferior_registers): Alloc local zerobuf.
	(fetch_core_registers): Alloc local zerobuf.
	* d10v-tdep.c (show_regs): Don't allocate a dynamic array using
	MAX_REGISTER_RAW_SIZE or MAX_REGISTER_VIRTUAL_SIZE.
	* thread-db.c (thread_db_store_registers): Ditto.
	* sh-tdep.c (sh_do_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote-sim.c (gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* monitor.c (monitor_supply_register): Ditto.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	* m68klinux-nat.c (fetch_register): Ditto.
	* lynx-nat.c (fetch_inferior_registers): Ditto.
	(fetch_inferior_registers): Ditto.
	* irix4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (fetch_register): Ditto.
	* hppab-nat.c (fetch_register): Ditto.
	* hppa-tdep.c (pa_register_look_aside): Ditto.
	(pa_print_fp_reg, pa_strcat_fp_reg): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register): Ditto.
@
text
@d34 1
a788 2
extern int parent_attach_all (int, PTRACE_ARG3_TYPE, int);

d909 1
a909 2
hppa_remove_hw_watchpoint (int pid, CORE_ADDR start, LONGEST len,
			   enum bptype type)
d915 1
a915 1
hppa_can_use_hw_watchpoint (enum bptype type, int cnt, enum bptype ot)
@


1.22.12.1
log
@Merge with mainline.
@
text
@a33 1
#include "gdb_string.h"
d788 2
d910 2
a911 1
hppa_remove_hw_watchpoint (int pid, CORE_ADDR start, LONGEST len, int type)
d917 1
a917 1
hppa_can_use_hw_watchpoint (int type, int cnt, int ot)
@


1.21
log
@2003-01-28  Andrew Cagney  <ac131313@@redhat.com>

	* hppah-nat.c (child_pid_to_exec_file): Don't use boolean.
@
text
@d192 1
a192 1
  char buf[MAX_REGISTER_RAW_SIZE];
@


1.20
log
@	* corelow.c (init_core_ops): Delete references to to_require_attach
	and to_require_detach.
	* exec.c (init_exec_ops): Likewise.
	* hppah-nat.c (child_follow_fork): Call hppa_require_attach and
	hppa_require_detach directly.
	* inferior.h (REQUIRE_ATTACH, REQUIRE_DETACH): Delete.
	* inftarg.c (child_detach): Remove.
	(child_detach_from_process): Rename to child_detach, remove
	after_fork argument.
	(child_attach): Remove.
	(child_attach_to_process): Rename to child_attach, remove after_fork
	argument.
	(init_child_ops): Delete references to to_require_attach
	and to_require_detach.
	* infttrace.c (hppa_require_attach): Update comment.
	* target.c (cleanup_target, update_current_target)
	(init_dummy_target, setup_target_debug): Delete references to
	to_require_attach and to_require_detach.
	(find_default_require_detach, find_default_require_attach)
	(debug_to_require_attach, debug_to_require_detach): Remove
	functions.
	* target.h (struct target_ops): Remove to_require_attach
	and to_require_detach.
	(target_require_attach, target_require_detach): Delete macros.
	(find_default_require_detach, find_default_require_attach): Delete
	prototypes.
	* config/pa/nm-hppah.h (REQUIRE_ATTACH, REQUIRE_DETACH): Delete.
@
text
@d1337 1
a1337 1
  boolean done;
@


1.19
log
@	* config/pa/nm-hppah.h (CHILD_POST_FOLLOW_VFORK): Change to
	CHILD_FOLLOW_FORK.
	* hppah-nat.c (saved_vfork_pid): Add.
	(child_post_follow_vfork): Remove.
	(child_follow_fork): New function.
	(child_wait): Call detach_breakpoints after receiving the child vfork.
	Call child_resume directly instead of going through resume ().
	Make sure we have the exec before reporting the vfork.
	* inferior.h (follow_inferior_reset_breakpoints): Add prototype.
	* infrun.c (follow_fork, follow_vfork, follow_inferior_fork): Remove.
	(follow_fork): New function.  Call target_follow_fork.
	(follow_inferior_reset_breakpoints): New function broken out from
	old follow_inferior_fork.
	(resume): Remove hack to follow exec after vfork.
	* inftarg.c (child_post_follow_vfork): Remove.
	(child_follow_fork): New function.
	(init_child_ops): Replace to_post_follow_vfork with to_follow_fork.
	* target.c (cleanup_target): Replace to_post_follow_vfork with
	to_follow_fork.
	(update_current_target): Likewise.
	(setup_target_debug): Likewise.
	(debug_to_post_follow_vfork): Remove.
	(debug_to_follow_fork): New function.
	* target.h (struct target_ops): Replace to_post_folow_vfork with
	to_follow_fork.
	(child_post_follow_vfork): Remove prototype.
	(child_follow_fork): Add prototype.
	(target_post_follow_vfork): Remove macro.
	(target_follow_fork): Add macro.

testsuite/
	* gdb.base/foll-vfork.exp: Re-enable test on HP/UX.
@
text
@d426 3
a428 1
      target_require_detach (child_pid, "", 1);
a469 2
      char child_pid_spelling[40];

d486 3
a489 3
      sprintf (child_pid_spelling, "%d", child_pid);

      target_require_attach (child_pid_spelling, 1);
@


1.18
log
@	* hppah-nat.c (saved_child_execd_pathname, saved_vfork_state): New.
	(child_post_follow_vfork): Cancel pending exec event if we follow
	the parent.
	(child_wait): Only return TARGET_WAITKIND_VFORKED when all necessary
	events have been processed.  Return a fake TARGET_WAITKIND_EXECD
	event at the following wait call if necessary.
	* infrun.c (follow_vfork): Don't follow_exec here.
	(handle_inferior_event): Add comment to TARGET_WAITKIND_EXECD
	case about HP/UX 10.20.  Remove code pushed down to
	hppah-nat.c:child_wait.
	* infttrace.c (child_resume): Use TT_PROC_CONTINUE if
	vfork_in_flight is set.
@
text
@d388 1
d397 2
a398 3
void
child_post_follow_vfork (int parent_pid, int followed_parent, int child_pid,
			 int followed_child)
d400 16
a415 17
  /* Are we a debugger that followed the parent of a vfork?  If so,
     then recall that the child's vfork event was delivered to us
     first.  And, that the parent was suspended by the OS until the
     child's exec or exit events were received.

     Upon receiving that child vfork, then, we were forced to remove
     all breakpoints in the child and continue it so that it could
     reach the exec or exit point.

     But also recall that the parent and child of a vfork share the
     same address space.  Thus, removing bp's in the child also
     removed them from the parent.

     Now that the child has safely exec'd or exited, we must restore
     the parent's breakpoints before we continue it.  Else, we may
     cause it run past expected stopping points. */
  if (followed_parent)
d417 48
a464 1
      reattach_breakpoints (parent_pid);
d466 3
d470 29
a498 11
  /* If we followed the parent, don't try to follow the child's exec.  */
  if (saved_vfork_state != STATE_GOT_PARENT && saved_vfork_state != STATE_FAKE_EXEC)
    fprintf_unfiltered (gdb_stdout, "hppa: post follow vfork: confused state\n");

  if (followed_parent || saved_vfork_state == STATE_GOT_PARENT)
    saved_vfork_state = STATE_NONE;

  /* Are we a debugger that followed the child of a vfork?  If so,
     then recall that we don't actually acquire control of the child
     until after it has exec'd or exited.  */
  if (followed_child)
d500 10
a509 4
      /* If the child has exited, then there's nothing for us to do.
         In the case of an exec event, we'll let that be handled by
         the normal mechanism that notices and handles exec events, in
         resume(). */
d511 1
d669 12
a680 1
	      ourstatus->kind = TARGET_WAITKIND_SPURIOUS;
d685 4
a688 2
	      ourstatus->kind = TARGET_WAITKIND_VFORKED;
	      ourstatus->value.related_pid = related_pid;
d698 23
a720 1
	     The latter two can come in either order.
a721 9
	     If we get the parent vfork event first, life's good: We follow
	     either the parent or child, and then the child's exec event is
	     a "don't care".

	     But if we get the child's exec event first, then we delay
	     responding to it until we handle the parent's vfork.  Because,
	     otherwise we can't satisfy a "catch vfork".  */
	  if (saved_vfork_state == STATE_GOT_CHILD)
	    {
a722 7
	      saved_vfork_state = STATE_GOT_EXEC;

	      /* On HP/UX with ptrace, the child must be resumed before
		 the parent vfork event is delivered.  A single-step
		 suffices.  */
	      if (RESUME_EXECD_VFORKING_CHILD_TO_GET_PARENT_VFORK ())
		target_resume (pid_to_ptid (pid), 1, TARGET_SIGNAL_0);
a723 1
	      ourstatus->kind = TARGET_WAITKIND_IGNORE;
@


1.17
log
@	* hppah-nat.c (child_wait): Return TARGET_WAITKIND_IGNORE
	for the parent's fork event.
	* infrun.c (handle_inferior_event): Only expect one fork event.
	Call prepare_to_wait for TARGET_WAITKIND_IGNORE.  Update comment.
	* target.h: Update comment for TARGET_WAITKIND_IGNORE.
@
text
@d387 8
d421 7
a483 1

d499 8
d568 1
a568 3
      if (hpux_has_vforked (pid, &related_pid)
	  && ((pid == PIDGET (inferior_ptid))
	      || (related_pid == PIDGET (inferior_ptid))))
d570 34
a603 3
	  ourstatus->kind = TARGET_WAITKIND_VFORKED;
	  ourstatus->value.related_pid = related_pid;
	  return pid_to_ptid (pid);
d608 27
@


1.16
log
@	* config/pa/nm-hppah.h (CHILD_POST_FOLLOW_INFERIOR_BY_CLONE): Don't
	define.
	(struct target_waitstatus): Add opaque definition.
	* corelow.c (init_core_ops): Don't set to_clone_and_follow_inferior.
	* exec.c (init_exec_ops): Likewise.
	* fork-child.c (clone_and_follow_inferior): Remove.
	* hppah-nat.c (child_post_follow_inferior_by_clone): Remove.
	* inferior.h (clone_and_follow_inferior): Remove prototype.
	* infrun.c (follow_fork_mode_both): Remove.
	(follow_fork_mode_kind_names): Remove commented out "both".
	(follow_inferior_fork): Remove follow_fork_mode_both support.
	* inftarg.c (child_clone_and_follow_inferior): Remove.
	(child_post_follow_inferior_by_clone): Remove.
	(init_child_ops): Don't set to_clone_and_follow_inferior
	or to_post_follow_inferior_by_clone.
	* target.c (default_clone_and_follow_inferior): Remove.
	(cleanup_target): Don't set to_clone_and_follow_inferior
	or to_post_follow_inferior_by_clone.
	(find_default_clone_and_follow_inferior): Remove.
	(init_dummy_target): Don't set to_clone_and_follow_inferior.
	(debug_to_clone_and_follow_inferior): Remove.
	(debug_to_post_follow_inferior_by_clone): Remove.
	(setup_target_debug): Don't set to_clone_and_follow_inferior
	or to_post_follow_inferior_by_clone.
	* target.h (struct target_ops): Remove to_clone_and_follow_inferior
	and to_post_follow_inferior_by_clone.
	(child_clone_and_follow_inferior): Remove prototype.
	(child_post_follow_inferior_by_clone): Remove prototype.
	(target_clone_and_follow_inferior): Remove macro.
	(target_post_follow_inferior_by_clone): Remove macro.
	(find_default_clone_and_follow_inferior): Remove prototype.
@
text
@d527 1
a527 3
      if (hpux_has_forked (pid, &related_pid)
	  && ((pid == PIDGET (inferior_ptid)) 
	      || (related_pid == PIDGET (inferior_ptid))))
d529 15
a543 3
	  ourstatus->kind = TARGET_WAITKIND_FORKED;
	  ourstatus->value.related_pid = related_pid;
	  return pid_to_ptid (pid);
@


1.15
log
@	* breakpoint.c (bpstat_stop_status): Call inferior_has_forked,
	inferior_has_vforked, and inferior_has_execd instead of
	target_has_forked, target_has_vforked, and target_has_execd.
	* config/pa/nm-hppah.h (CHILD_HAS_FORKED, CHILD_HAS_VFORKED)
	(CHILD_HAS_EXECD, CHILD_HAS_SYSCALL_EVENT): Don't define.
	(CHILD_WAIT): Define.
	(child_wait): Add prototype.
	* hppah-nat.c (hpux_has_forked): Rename from child_has_forked.
	Add prototype.
	(hpux_has_vforked): Likewise, from child_has_vforked.
	(hpux_has_execd): Likewise, from child_has_execd.
	(hpux_has_syscall_event): Likewise, from child_has_syscall_event.
	(not_same_real_pid, child_wait): New, copied from inftarg.c.
	Call hpux_has_forked, hpux_has_vforked, hpux_has_execd,
	and hpux_has_syscall_event instead of the target hooks.
	* infrun.c (inferior_has_forked, inferior_has_vforked)
	(inferior_has_execd): New functions.
	* inftarg.c (not_same_real_pid): Remove.
	(child_wait): Remove references to not_same_real_pid,
	target_has_forked, target_has_vforked, target_has_execd,
	and target_has_syscall_event.
	(child_has_forked, child_has_vforked, child_has_execd)
	(child_has_syscall_event): Remove.
	(init_child_ops): Remove references to child_has_forked,
	child_has_vforked, child_has_execd, and child_has_syscall_event.
	* infttrace.c (hpux_has_forked): Rename from child_has_forked.
	(hpux_has_vforked): Likewise, from child_has_vforked.
	(hpux_has_execd): Likewise, from child_has_execd.
	(hpux_has_syscall_event): Likewise, from child_has_syscall_event.
	* target.c (cleanup_target): Remove references to
	to_has_forked, to_has_vforked, to_has_execd, and
	to_has_syscall_event.
	(update_current_target): Likewise.
	(setup_target_debug): Likewise.
	(debug_to_has_forked): Remove.
	(debug_to_has_vforked): Remove.
	(debug_to_has_execd): Remove.
	(debug_to_has_syscall_event): Remove.
	* target.h (struct target_ops): Remove to_has_forked.
	to_has_vforked, to_has_execd, and to_has_syscall_event.
	(child_has_forked, child_has_vforked, child_has_execd)
	(child_has_syscall_event): Remove prototypes.
	(inferior_has_forked, inferior_has_vforked, inferior_has_execd): Add
	prototypes.
	(target_has_forked, target_has_vforked, target_has_execd)
	(target_has_syscall_event): Remove macros.
@
text
@a388 18
child_post_follow_inferior_by_clone (void)
{
  int status;

  /* This function is used when following both the parent and child
     of a fork.  In this case, the debugger clones itself.  The original
     debugger follows the parent, the clone follows the child.  The
     original detaches from the child, delivering a SIGSTOP to it to
     keep it from running away until the clone can attach itself.

     At this point, the clone has attached to the child.  Because of
     the SIGSTOP, we must now deliver a SIGCONT to the child, or it
     won't behave properly. */
  status = kill (PIDGET (inferior_ptid), SIGCONT);
}


void
@


1.14
log
@	* hppah-nat.c (child_can_follow_vfork_prior_to_exec): Remove.
	* inftarg.c (child_can_follow_vfork_prior_to_exec): Remove.
	(init_child_ops): Don't initialize to_can_follow_vfork_prior_to_exec.
	* infttrace.c (child_can_follow_vfork_prior_to_exec): Remove.
	* target.c (cleanup_target): Remove reference to
	to_can_follow_vfork_prior_to_exec.
	(update_current_target): Likewise.
	(debug_to_can_follow_vfork_prior_to_exec): Remove.
	(setup_target_debug): Remove reference to
	to_can_follow_vfork_prior_to_exec.
	* target.h (struct target_ops): Remove
	to_can_follow_vfork_prior_to_exec.
	(child_can_follow_vfork_prior_to_exec): Remove prototype.
	(target_can_follow_vfork_prior_to_exec): Remove definition.
	* config/pa/nm-hppah.h (CHILD_CAN_FOLLOW_VFORK_PRIOR_TO_EXEC): Don't
	define.
	* infrun.c (follow_vfork_when_exec): Remove.
	(follow_inferior_fork): Remove references to follow_vfork_when_exec.
	(follow_exec): Likewise.
	(handle_inferior_event): Likewise.
	(keep_going): Likewise.
@
text
@d38 6
d478 124
d1023 1
a1023 1
child_has_forked (int pid, int *childpid)
d1054 1
a1054 1
child_has_vforked (int pid, int *childpid)
d1116 1
a1116 1
child_has_execd (int pid, char **execd_pathname)
d1155 1
a1155 1
child_has_syscall_event (int pid, enum target_waitkind *kind, int *syscall_id)
@


1.13
log
@2002-11-14  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_registers): Rename registers.
	* a68v-nat.c, alpha-nat.c, arch-utils.c, core-sol2.c: Update.
	* hp300ux-nat.c, hppab-nat.c, hppah-nat.c: Update.
	* hppam3-nat.c, hpux-thread.c, i386gnu-nat.c: Update.
	* ia64-aix-nat.c, ia64-linux-nat.c, ia64-tdep.c: Update.
	* irix4-nat.c, irix5-nat.c, lynx-nat.c, m68k-tdep.c: Update.
	* m68knbsd-nat.c, mips-linux-tdep.c, mipsm3-nat.c: Update.
	* mipsv4-nat.c, ns32knbsd-nat.c, ppc-bdm.c: Update.
	* ppc-sysv-tdep.c, ptx4-nat.c, regcache.c, remote-es.c: Update.
	* remote-sds.c, remote-vx68.c, remote-vxmips.c: Update.
	* remote-vxsparc.c, rs6000-tdep.c, sol-thread.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, symm-nat.c: Update.
	* v850ice.c: Update.
@
text
@a955 7
child_can_follow_vfork_prior_to_exec (void)
{
  /* ptrace doesn't allow this. */
  return 0;
}

int
@


1.12
log
@Fix -Wformat for hpux.
@
text
@d124 1
a124 1
	  temp = *(CORE_ADDR *)&registers[REGISTER_BYTE (regno)];
d149 1
a149 1
	*(int *)&registers[REGISTER_BYTE (regno)] = 0;
d157 1
a157 1
		       *(int *) &registers[REGISTER_BYTE (regno) + i]);
@


1.12.18.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a33 1
#include "gdb_string.h"
d36 1
a36 27
extern int hpux_has_forked (int pid, int *childpid);
extern int hpux_has_vforked (int pid, int *childpid);
extern int hpux_has_execd (int pid, char **execd_pathname);
extern int hpux_has_syscall_event (int pid, enum target_waitkind *kind,
				   int *syscall_id);

static CORE_ADDR text_end;

void
deprecated_hpux_text_end (struct target_ops *exec_ops)
{
  struct section_table *p;

  /* Set text_end to the highest address of the end of any readonly
     code section.  */
  /* FIXME: The comment above does not match the code.  The code
     checks for sections with are either code *or* readonly.  */
  text_end = (CORE_ADDR) 0;
  for (p = exec_ops->to_sections; p < exec_ops->to_sections_end; p++)
    if (bfd_get_section_flags (p->bfd, p->the_bfd_section)
	& (SEC_CODE | SEC_READONLY))
      {
	if (text_end < p->endaddr)
	  text_end = p->endaddr;
      }
}

d60 1
a60 1
  unsigned int regaddr;
d62 1
a62 1
  int i;
d74 1
a74 1
      len = DEPRECATED_REGISTER_RAW_SIZE (regno);
d85 4
a88 5
	     DEPRECATED_REGISTER_RAW_SIZE(0) says.  Assuming all HP-UX
	     PA machines are big-endian, put it at the least
	     significant end of the value, and zap the rest of the
	     buffer.  */
	  offset = DEPRECATED_REGISTER_RAW_SIZE (0) - len;
d94 1
a94 1
		+ (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (FP0_REGNUM)));
d103 1
a103 1
		+ DEPRECATED_REGISTER_BYTE (regno));
d109 1
a109 1
		+ (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (1)));
d124 1
a124 1
	  temp = *(CORE_ADDR *)&deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)];
d149 1
a149 1
	*(int *)&deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)] = 0;
d157 1
a157 1
		       *(int *) &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno) + i]);
d186 1
a186 1
  char buf[MAX_REGISTER_SIZE];
d191 1
a191 1
  len = DEPRECATED_REGISTER_RAW_SIZE (regno);
d202 4
a205 4
	 DEPRECATED_REGISTER_RAW_SIZE(0) says.  Assuming all HP-UX PA
	 machines are big-endian, put it at the least significant end
	 of the value, and zap the rest of the buffer.  */
      offset = DEPRECATED_REGISTER_RAW_SIZE (0) - len;
d212 1
a212 1
	    + (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (FP0_REGNUM)));
d221 1
a221 1
	    + DEPRECATED_REGISTER_BYTE (regno));
d227 1
a227 1
	    + (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (1)));
d278 1
a278 1
  int i;
d280 1
a280 1
  CORE_ADDR addr = memaddr & - (CORE_ADDR)(sizeof (int));
d282 1
a282 1
  int count
d293 1
a293 1
  int *buffer = (int *) xmalloc (count * sizeof (int));
a380 27
char *saved_child_execd_pathname = NULL;
int saved_vfork_pid;
enum {
  STATE_NONE,
  STATE_GOT_CHILD,
  STATE_GOT_EXEC,
  STATE_GOT_PARENT,
  STATE_FAKE_EXEC
} saved_vfork_state = STATE_NONE;

int
child_follow_fork (int follow_child)
{
  ptid_t last_ptid;
  struct target_waitstatus last_status;
  int has_vforked;
  int parent_pid, child_pid;

  get_last_target_status (&last_ptid, &last_status);
  has_vforked = (last_status.kind == TARGET_WAITKIND_VFORKED);
  parent_pid = ptid_get_pid (last_ptid);
  child_pid = last_status.value.related_pid;

  /* At this point, if we are vforking, breakpoints were already
     detached from the child in child_wait; and the child has already
     called execve().  If we are forking, both the parent and child
     have breakpoints inserted.  */
d382 17
a398 9
  if (! follow_child)
    {
      if (! has_vforked)
	{
	  detach_breakpoints (child_pid);
#ifdef SOLIB_REMOVE_INFERIOR_HOOK
	  SOLIB_REMOVE_INFERIOR_HOOK (child_pid);
#endif
	}
d400 8
a407 39
      /* Detach from the child. */
      printf_unfiltered ("Detaching after fork from %s\n",
			 target_pid_to_str (pid_to_ptid (child_pid)));
      hppa_require_detach (child_pid, 0);

      /* The parent and child of a vfork share the same address space.
	 Also, on some targets the order in which vfork and exec events
	 are received for parent in child requires some delicate handling
	 of the events.

	 For instance, on ptrace-based HPUX we receive the child's vfork
	 event first, at which time the parent has been suspended by the
	 OS and is essentially untouchable until the child's exit or second
	 exec event arrives.  At that time, the parent's vfork event is
	 delivered to us, and that's when we see and decide how to follow
	 the vfork.  But to get to that point, we must continue the child
	 until it execs or exits.  To do that smoothly, all breakpoints
	 must be removed from the child, in case there are any set between
	 the vfork() and exec() calls.  But removing them from the child
	 also removes them from the parent, due to the shared-address-space
	 nature of a vfork'd parent and child.  On HPUX, therefore, we must
	 take care to restore the bp's to the parent before we continue it.
	 Else, it's likely that we may not stop in the expected place.  (The
	 worst scenario is when the user tries to step over a vfork() call;
	 the step-resume bp must be restored for the step to properly stop
	 in the parent after the call completes!)

	 Sequence of events, as reported to gdb from HPUX:

	 Parent        Child           Action for gdb to take
	 -------------------------------------------------------
	 1                VFORK               Continue child
	 2                EXEC
	 3                EXEC or EXIT
	 4  VFORK

	 Now that the child has safely exec'd or exited, we must restore
	 the parent's breakpoints before we continue it.  Else, we may
	 cause it run past expected stopping points.  */
d409 3
a411 16
      if (has_vforked)
	reattach_breakpoints (parent_pid);
    }
  else
    {
      /* Needed to keep the breakpoint lists in sync.  */
      if (! has_vforked)
	detach_breakpoints (child_pid);

      /* Before detaching from the parent, remove all breakpoints from it. */
      remove_breakpoints ();

      /* Also reset the solib inferior hook from the parent. */
#ifdef SOLIB_REMOVE_INFERIOR_HOOK
      SOLIB_REMOVE_INFERIOR_HOOK (PIDGET (inferior_ptid));
#endif
d413 3
a415 2
      /* Detach from the parent. */
      target_detach (NULL, 1);
d417 6
a422 11
      /* Attach to the child. */
      printf_unfiltered ("Attaching after fork to %s\n",
			 target_pid_to_str (pid_to_ptid (child_pid)));
      hppa_require_attach (child_pid);
      inferior_ptid = pid_to_ptid (child_pid);

      /* If we vforked, then we've also execed by now.  The exec will be
	 reported momentarily.  follow_exec () will handle breakpoints, so
	 we don't have to..  */
      if (!has_vforked)
	follow_inferior_reset_breakpoints ();
d425 4
a428 1
  if (has_vforked)
d430 4
a433 10
      /* If we followed the parent, don't try to follow the child's exec.  */
      if (saved_vfork_state != STATE_GOT_PARENT
	  && saved_vfork_state != STATE_FAKE_EXEC)
	fprintf_unfiltered (gdb_stdout,
			    "hppa: post follow vfork: confused state\n");

      if (! follow_child || saved_vfork_state == STATE_GOT_PARENT)
	saved_vfork_state = STATE_NONE;
      else
	return 1;
a434 1
  return 0;
a471 215
/*## */
/* Enable HACK for ttrace work.  In
 * infttrace.c/require_notification_of_events,
 * this is set to 0 so that the loop in child_wait
 * won't loop.
 */
int not_same_real_pid = 1;
/*## */

/* Wait for child to do something.  Return pid of child, or -1 in case
   of error; store status through argument pointer OURSTATUS.  */

ptid_t
child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  int save_errno;
  int status;
  char *execd_pathname = NULL;
  int exit_status;
  int related_pid;
  int syscall_id;
  enum target_waitkind kind;
  int pid;

  if (saved_vfork_state == STATE_FAKE_EXEC)
    {
      saved_vfork_state = STATE_NONE;
      ourstatus->kind = TARGET_WAITKIND_EXECD;
      ourstatus->value.execd_pathname = saved_child_execd_pathname;
      return inferior_ptid;
    }

  do
    {
      set_sigint_trap ();	/* Causes SIGINT to be passed on to the
				   attached process. */
      set_sigio_trap ();

      pid = ptrace_wait (inferior_ptid, &status);

      save_errno = errno;

      clear_sigio_trap ();

      clear_sigint_trap ();

      if (pid == -1)
	{
	  if (save_errno == EINTR)
	    continue;

	  fprintf_unfiltered (gdb_stderr, "Child process unexpectedly missing: %s.\n",
			      safe_strerror (save_errno));

	  /* Claim it exited with unknown signal.  */
	  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
	  ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
	  return pid_to_ptid (-1);
	}

      /* Did it exit?
       */
      if (target_has_exited (pid, status, &exit_status))
	{
	  /* ??rehrauer: For now, ignore this. */
	  continue;
	}

      if (!target_thread_alive (pid_to_ptid (pid)))
	{
	  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;
	  return pid_to_ptid (pid);
	}

      if (hpux_has_forked (pid, &related_pid))
	{
	  /* Ignore the parent's fork event.  */
	  if (pid == PIDGET (inferior_ptid))
	    {
	      ourstatus->kind = TARGET_WAITKIND_IGNORE;
	      return inferior_ptid;
	    }

	  /* If this is the child's fork event, report that the
	     process has forked.  */
	  if (related_pid == PIDGET (inferior_ptid))
	    {
	      ourstatus->kind = TARGET_WAITKIND_FORKED;
	      ourstatus->value.related_pid = pid;
	      return inferior_ptid;
	    }
	}

      if (hpux_has_vforked (pid, &related_pid))
	{
	  if (pid == PIDGET (inferior_ptid))
	    {
	      if (saved_vfork_state == STATE_GOT_CHILD)
		saved_vfork_state = STATE_GOT_PARENT;
	      else if (saved_vfork_state == STATE_GOT_EXEC)
		saved_vfork_state = STATE_FAKE_EXEC;
	      else
		fprintf_unfiltered (gdb_stdout,
				    "hppah: parent vfork: confused\n");
	    }
	  else if (related_pid == PIDGET (inferior_ptid))
	    {
	      if (saved_vfork_state == STATE_NONE)
		saved_vfork_state = STATE_GOT_CHILD;
	      else
		fprintf_unfiltered (gdb_stdout,
				    "hppah: child vfork: confused\n");
	    }
	  else
	    fprintf_unfiltered (gdb_stdout,
				"hppah: unknown vfork: confused\n");

	  if (saved_vfork_state == STATE_GOT_CHILD)
	    {
	      child_post_startup_inferior (pid_to_ptid (pid));
	      detach_breakpoints (pid);
#ifdef SOLIB_REMOVE_INFERIOR_HOOK
	      SOLIB_REMOVE_INFERIOR_HOOK (pid);
#endif
	      child_resume (pid_to_ptid (pid), 0, TARGET_SIGNAL_0);
	      ourstatus->kind = TARGET_WAITKIND_IGNORE;
	      return pid_to_ptid (related_pid);
	    }
	  else if (saved_vfork_state == STATE_FAKE_EXEC)
	    {
	      ourstatus->kind = TARGET_WAITKIND_VFORKED;
	      ourstatus->value.related_pid = related_pid;
	      return pid_to_ptid (pid);
	    }
	  else
	    {
	      /* We saw the parent's vfork, but we haven't seen the exec yet.
		 Wait for it, for simplicity's sake.  It should be pending.  */
	      saved_vfork_pid = related_pid;
	      ourstatus->kind = TARGET_WAITKIND_IGNORE;
	      return pid_to_ptid (pid);
	    }
	}

      if (hpux_has_execd (pid, &execd_pathname))
	{
	  /* On HP-UX, events associated with a vforking inferior come in
	     threes: a vfork event for the child (always first), followed
	     a vfork event for the parent and an exec event for the child.
	     The latter two can come in either order.  Make sure we get
	     both.  */
	  if (saved_vfork_state != STATE_NONE)
	    {
	      if (saved_vfork_state == STATE_GOT_CHILD)
		{
		  saved_vfork_state = STATE_GOT_EXEC;
		  /* On HP/UX with ptrace, the child must be resumed before
		     the parent vfork event is delivered.  A single-step
		     suffices.  */
		  if (RESUME_EXECD_VFORKING_CHILD_TO_GET_PARENT_VFORK ())
		    target_resume (pid_to_ptid (pid), 1, TARGET_SIGNAL_0);
		  ourstatus->kind = TARGET_WAITKIND_IGNORE;
		}
	      else if (saved_vfork_state == STATE_GOT_PARENT)
		{
		  saved_vfork_state = STATE_FAKE_EXEC;
		  ourstatus->kind = TARGET_WAITKIND_VFORKED;
		  ourstatus->value.related_pid = saved_vfork_pid;
		}
	      else
		fprintf_unfiltered (gdb_stdout,
				    "hppa: exec: unexpected state\n");

	      saved_child_execd_pathname = execd_pathname;

	      return inferior_ptid;
	    }
	  
	  /* Are we ignoring initial exec events?  (This is likely because
	     we're in the process of starting up the inferior, and another
	     (older) mechanism handles those.)  If so, we'll report this
	     as a regular stop, not an exec.
	   */
	  if (inferior_ignoring_startup_exec_events)
	    {
	      inferior_ignoring_startup_exec_events--;
	    }
	  else
	    {
	      ourstatus->kind = TARGET_WAITKIND_EXECD;
	      ourstatus->value.execd_pathname = execd_pathname;
	      return pid_to_ptid (pid);
	    }
	}

      /* All we must do with these is communicate their occurrence
         to wait_for_inferior...
       */
      if (hpux_has_syscall_event (pid, &kind, &syscall_id))
	{
	  ourstatus->kind = kind;
	  ourstatus->value.syscall_id = syscall_id;
	  return pid_to_ptid (pid);
	}

      /*##  } while (pid != PIDGET (inferior_ptid)); ## *//* Some other child died or stopped */
/* hack for thread testing */
    }
  while ((pid != PIDGET (inferior_ptid)) && not_same_real_pid);
/*## */

  store_waitstatus (ourstatus, status);
  return pid_to_ptid (pid);
}

d496 2
d618 2
a619 1
hppa_remove_hw_watchpoint (int pid, CORE_ADDR start, LONGEST len, int type)
d625 1
a625 1
hppa_can_use_hw_watchpoint (int type, int cnt, int ot)
d643 10
d893 1
a893 1
hpux_has_forked (int pid, int *childpid)
d924 1
a924 1
hpux_has_vforked (int pid, int *childpid)
d956 7
d993 1
a993 1
hpux_has_execd (int pid, char **execd_pathname)
d1032 1
a1032 1
hpux_has_syscall_event (int pid, enum target_waitkind *kind, int *syscall_id)
d1052 1
a1052 1
  int done;
@


1.12.16.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d124 1
a124 1
	  temp = *(CORE_ADDR *)&deprecated_registers[REGISTER_BYTE (regno)];
d149 1
a149 1
	*(int *)&deprecated_registers[REGISTER_BYTE (regno)] = 0;
d157 1
a157 1
		       *(int *) &deprecated_registers[REGISTER_BYTE (regno) + i]);
@


1.12.16.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a37 6
extern int hpux_has_forked (int pid, int *childpid);
extern int hpux_has_vforked (int pid, int *childpid);
extern int hpux_has_execd (int pid, char **execd_pathname);
extern int hpux_has_syscall_event (int pid, enum target_waitkind *kind,
				   int *syscall_id);

a380 27
char *saved_child_execd_pathname = NULL;
int saved_vfork_pid;
enum {
  STATE_NONE,
  STATE_GOT_CHILD,
  STATE_GOT_EXEC,
  STATE_GOT_PARENT,
  STATE_FAKE_EXEC
} saved_vfork_state = STATE_NONE;

int
child_follow_fork (int follow_child)
{
  ptid_t last_ptid;
  struct target_waitstatus last_status;
  int has_vforked;
  int parent_pid, child_pid;

  get_last_target_status (&last_ptid, &last_status);
  has_vforked = (last_status.kind == TARGET_WAITKIND_VFORKED);
  parent_pid = ptid_get_pid (last_ptid);
  child_pid = last_status.value.related_pid;

  /* At this point, if we are vforking, breakpoints were already
     detached from the child in child_wait; and the child has already
     called execve().  If we are forking, both the parent and child
     have breakpoints inserted.  */
d382 4
a385 9
  if (! follow_child)
    {
      if (! has_vforked)
	{
	  detach_breakpoints (child_pid);
#ifdef SOLIB_REMOVE_INFERIOR_HOOK
	  SOLIB_REMOVE_INFERIOR_HOOK (child_pid);
#endif
	}
d387 11
a397 39
      /* Detach from the child. */
      printf_unfiltered ("Detaching after fork from %s\n",
			 target_pid_to_str (pid_to_ptid (child_pid)));
      hppa_require_detach (child_pid, 0);

      /* The parent and child of a vfork share the same address space.
	 Also, on some targets the order in which vfork and exec events
	 are received for parent in child requires some delicate handling
	 of the events.

	 For instance, on ptrace-based HPUX we receive the child's vfork
	 event first, at which time the parent has been suspended by the
	 OS and is essentially untouchable until the child's exit or second
	 exec event arrives.  At that time, the parent's vfork event is
	 delivered to us, and that's when we see and decide how to follow
	 the vfork.  But to get to that point, we must continue the child
	 until it execs or exits.  To do that smoothly, all breakpoints
	 must be removed from the child, in case there are any set between
	 the vfork() and exec() calls.  But removing them from the child
	 also removes them from the parent, due to the shared-address-space
	 nature of a vfork'd parent and child.  On HPUX, therefore, we must
	 take care to restore the bp's to the parent before we continue it.
	 Else, it's likely that we may not stop in the expected place.  (The
	 worst scenario is when the user tries to step over a vfork() call;
	 the step-resume bp must be restored for the step to properly stop
	 in the parent after the call completes!)

	 Sequence of events, as reported to gdb from HPUX:

	 Parent        Child           Action for gdb to take
	 -------------------------------------------------------
	 1                VFORK               Continue child
	 2                EXEC
	 3                EXEC or EXIT
	 4  VFORK

	 Now that the child has safely exec'd or exited, we must restore
	 the parent's breakpoints before we continue it.  Else, we may
	 cause it run past expected stopping points.  */
a398 16
      if (has_vforked)
	reattach_breakpoints (parent_pid);
    }
  else
    {
      /* Needed to keep the breakpoint lists in sync.  */
      if (! has_vforked)
	detach_breakpoints (child_pid);

      /* Before detaching from the parent, remove all breakpoints from it. */
      remove_breakpoints ();

      /* Also reset the solib inferior hook from the parent. */
#ifdef SOLIB_REMOVE_INFERIOR_HOOK
      SOLIB_REMOVE_INFERIOR_HOOK (PIDGET (inferior_ptid));
#endif
d400 34
a433 28
      /* Detach from the parent. */
      target_detach (NULL, 1);

      /* Attach to the child. */
      printf_unfiltered ("Attaching after fork to %s\n",
			 target_pid_to_str (pid_to_ptid (child_pid)));
      hppa_require_attach (child_pid);
      inferior_ptid = pid_to_ptid (child_pid);

      /* If we vforked, then we've also execed by now.  The exec will be
	 reported momentarily.  follow_exec () will handle breakpoints, so
	 we don't have to..  */
      if (!has_vforked)
	follow_inferior_reset_breakpoints ();
    }

  if (has_vforked)
    {
      /* If we followed the parent, don't try to follow the child's exec.  */
      if (saved_vfork_state != STATE_GOT_PARENT
	  && saved_vfork_state != STATE_FAKE_EXEC)
	fprintf_unfiltered (gdb_stdout,
			    "hppa: post follow vfork: confused state\n");

      if (! follow_child || saved_vfork_state == STATE_GOT_PARENT)
	saved_vfork_state = STATE_NONE;
      else
	return 1;
a434 1
  return 0;
a471 215
/*## */
/* Enable HACK for ttrace work.  In
 * infttrace.c/require_notification_of_events,
 * this is set to 0 so that the loop in child_wait
 * won't loop.
 */
int not_same_real_pid = 1;
/*## */

/* Wait for child to do something.  Return pid of child, or -1 in case
   of error; store status through argument pointer OURSTATUS.  */

ptid_t
child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  int save_errno;
  int status;
  char *execd_pathname = NULL;
  int exit_status;
  int related_pid;
  int syscall_id;
  enum target_waitkind kind;
  int pid;

  if (saved_vfork_state == STATE_FAKE_EXEC)
    {
      saved_vfork_state = STATE_NONE;
      ourstatus->kind = TARGET_WAITKIND_EXECD;
      ourstatus->value.execd_pathname = saved_child_execd_pathname;
      return inferior_ptid;
    }

  do
    {
      set_sigint_trap ();	/* Causes SIGINT to be passed on to the
				   attached process. */
      set_sigio_trap ();

      pid = ptrace_wait (inferior_ptid, &status);

      save_errno = errno;

      clear_sigio_trap ();

      clear_sigint_trap ();

      if (pid == -1)
	{
	  if (save_errno == EINTR)
	    continue;

	  fprintf_unfiltered (gdb_stderr, "Child process unexpectedly missing: %s.\n",
			      safe_strerror (save_errno));

	  /* Claim it exited with unknown signal.  */
	  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
	  ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
	  return pid_to_ptid (-1);
	}

      /* Did it exit?
       */
      if (target_has_exited (pid, status, &exit_status))
	{
	  /* ??rehrauer: For now, ignore this. */
	  continue;
	}

      if (!target_thread_alive (pid_to_ptid (pid)))
	{
	  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;
	  return pid_to_ptid (pid);
	}

      if (hpux_has_forked (pid, &related_pid))
	{
	  /* Ignore the parent's fork event.  */
	  if (pid == PIDGET (inferior_ptid))
	    {
	      ourstatus->kind = TARGET_WAITKIND_IGNORE;
	      return inferior_ptid;
	    }

	  /* If this is the child's fork event, report that the
	     process has forked.  */
	  if (related_pid == PIDGET (inferior_ptid))
	    {
	      ourstatus->kind = TARGET_WAITKIND_FORKED;
	      ourstatus->value.related_pid = pid;
	      return inferior_ptid;
	    }
	}

      if (hpux_has_vforked (pid, &related_pid))
	{
	  if (pid == PIDGET (inferior_ptid))
	    {
	      if (saved_vfork_state == STATE_GOT_CHILD)
		saved_vfork_state = STATE_GOT_PARENT;
	      else if (saved_vfork_state == STATE_GOT_EXEC)
		saved_vfork_state = STATE_FAKE_EXEC;
	      else
		fprintf_unfiltered (gdb_stdout,
				    "hppah: parent vfork: confused\n");
	    }
	  else if (related_pid == PIDGET (inferior_ptid))
	    {
	      if (saved_vfork_state == STATE_NONE)
		saved_vfork_state = STATE_GOT_CHILD;
	      else
		fprintf_unfiltered (gdb_stdout,
				    "hppah: child vfork: confused\n");
	    }
	  else
	    fprintf_unfiltered (gdb_stdout,
				"hppah: unknown vfork: confused\n");

	  if (saved_vfork_state == STATE_GOT_CHILD)
	    {
	      child_post_startup_inferior (pid_to_ptid (pid));
	      detach_breakpoints (pid);
#ifdef SOLIB_REMOVE_INFERIOR_HOOK
	      SOLIB_REMOVE_INFERIOR_HOOK (pid);
#endif
	      child_resume (pid_to_ptid (pid), 0, TARGET_SIGNAL_0);
	      ourstatus->kind = TARGET_WAITKIND_IGNORE;
	      return pid_to_ptid (related_pid);
	    }
	  else if (saved_vfork_state == STATE_FAKE_EXEC)
	    {
	      ourstatus->kind = TARGET_WAITKIND_VFORKED;
	      ourstatus->value.related_pid = related_pid;
	      return pid_to_ptid (pid);
	    }
	  else
	    {
	      /* We saw the parent's vfork, but we haven't seen the exec yet.
		 Wait for it, for simplicity's sake.  It should be pending.  */
	      saved_vfork_pid = related_pid;
	      ourstatus->kind = TARGET_WAITKIND_IGNORE;
	      return pid_to_ptid (pid);
	    }
	}

      if (hpux_has_execd (pid, &execd_pathname))
	{
	  /* On HP-UX, events associated with a vforking inferior come in
	     threes: a vfork event for the child (always first), followed
	     a vfork event for the parent and an exec event for the child.
	     The latter two can come in either order.  Make sure we get
	     both.  */
	  if (saved_vfork_state != STATE_NONE)
	    {
	      if (saved_vfork_state == STATE_GOT_CHILD)
		{
		  saved_vfork_state = STATE_GOT_EXEC;
		  /* On HP/UX with ptrace, the child must be resumed before
		     the parent vfork event is delivered.  A single-step
		     suffices.  */
		  if (RESUME_EXECD_VFORKING_CHILD_TO_GET_PARENT_VFORK ())
		    target_resume (pid_to_ptid (pid), 1, TARGET_SIGNAL_0);
		  ourstatus->kind = TARGET_WAITKIND_IGNORE;
		}
	      else if (saved_vfork_state == STATE_GOT_PARENT)
		{
		  saved_vfork_state = STATE_FAKE_EXEC;
		  ourstatus->kind = TARGET_WAITKIND_VFORKED;
		  ourstatus->value.related_pid = saved_vfork_pid;
		}
	      else
		fprintf_unfiltered (gdb_stdout,
				    "hppa: exec: unexpected state\n");

	      saved_child_execd_pathname = execd_pathname;

	      return inferior_ptid;
	    }
	  
	  /* Are we ignoring initial exec events?  (This is likely because
	     we're in the process of starting up the inferior, and another
	     (older) mechanism handles those.)  If so, we'll report this
	     as a regular stop, not an exec.
	   */
	  if (inferior_ignoring_startup_exec_events)
	    {
	      inferior_ignoring_startup_exec_events--;
	    }
	  else
	    {
	      ourstatus->kind = TARGET_WAITKIND_EXECD;
	      ourstatus->value.execd_pathname = execd_pathname;
	      return pid_to_ptid (pid);
	    }
	}

      /* All we must do with these is communicate their occurrence
         to wait_for_inferior...
       */
      if (hpux_has_syscall_event (pid, &kind, &syscall_id))
	{
	  ourstatus->kind = kind;
	  ourstatus->value.syscall_id = syscall_id;
	  return pid_to_ptid (pid);
	}

      /*##  } while (pid != PIDGET (inferior_ptid)); ## *//* Some other child died or stopped */
/* hack for thread testing */
    }
  while ((pid != PIDGET (inferior_ptid)) && not_same_real_pid);
/*## */

  store_waitstatus (ourstatus, status);
  return pid_to_ptid (pid);
}

d893 1
a893 1
hpux_has_forked (int pid, int *childpid)
d924 1
a924 1
hpux_has_vforked (int pid, int *childpid)
d956 7
d993 1
a993 1
hpux_has_execd (int pid, char **execd_pathname)
d1032 1
a1032 1
hpux_has_syscall_event (int pid, enum target_waitkind *kind, int *syscall_id)
@


1.12.16.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d192 1
a192 1
  char *buf = alloca (max_register_size (current_gdbarch));
d1337 1
a1337 1
  int done;
@


1.12.16.4
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a33 1
#include "gdb_string.h"
d788 2
d910 2
a911 1
hppa_remove_hw_watchpoint (int pid, CORE_ADDR start, LONGEST len, int type)
d917 1
a917 1
hppa_can_use_hw_watchpoint (int type, int cnt, int ot)
@


1.12.16.5
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d193 1
a193 1
  char buf[MAX_REGISTER_SIZE];
@


1.12.16.6
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d933 10
@


1.12.16.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d67 1
a67 1
  unsigned int regaddr;
d69 1
a69 1
  int i;
d101 1
a101 1
		+ (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (FP0_REGNUM)));
d110 1
a110 1
		+ DEPRECATED_REGISTER_BYTE (regno));
d116 1
a116 1
		+ (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (1)));
d131 1
a131 1
	  temp = *(CORE_ADDR *)&deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)];
d156 1
a156 1
	*(int *)&deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)] = 0;
d164 1
a164 1
		       *(int *) &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno) + i]);
d219 1
a219 1
	    + (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (FP0_REGNUM)));
d228 1
a228 1
	    + DEPRECATED_REGISTER_BYTE (regno));
d234 1
a234 1
	    + (DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (1)));
d285 1
a285 1
  int i;
d287 1
a287 1
  CORE_ADDR addr = memaddr & - (CORE_ADDR)(sizeof (int));
d289 1
a289 1
  int count
d300 1
a300 1
  int *buffer = (int *) xmalloc (count * sizeof (int));
@


1.12.16.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d37 2
a44 22
static CORE_ADDR text_end;

void
deprecated_hpux_text_end (struct target_ops *exec_ops)
{
  struct section_table *p;

  /* Set text_end to the highest address of the end of any readonly
     code section.  */
  /* FIXME: The comment above does not match the code.  The code
     checks for sections with are either code *or* readonly.  */
  text_end = (CORE_ADDR) 0;
  for (p = exec_ops->to_sections; p < exec_ops->to_sections_end; p++)
    if (bfd_get_section_flags (p->bfd, p->the_bfd_section)
	& (SEC_CODE | SEC_READONLY))
      {
	if (text_end < p->endaddr)
	  text_end = p->endaddr;
      }
}


d81 1
a81 1
      len = DEPRECATED_REGISTER_RAW_SIZE (regno);
d92 4
a95 5
	     DEPRECATED_REGISTER_RAW_SIZE(0) says.  Assuming all HP-UX
	     PA machines are big-endian, put it at the least
	     significant end of the value, and zap the rest of the
	     buffer.  */
	  offset = DEPRECATED_REGISTER_RAW_SIZE (0) - len;
d198 1
a198 1
  len = DEPRECATED_REGISTER_RAW_SIZE (regno);
d209 4
a212 4
	 DEPRECATED_REGISTER_RAW_SIZE(0) says.  Assuming all HP-UX PA
	 machines are big-endian, put it at the least significant end
	 of the value, and zap the rest of the buffer.  */
      offset = DEPRECATED_REGISTER_RAW_SIZE (0) - len;
@


1.11
log
@Phase 1 of the ptid_t changes.
@
text
@d446 2
a447 2
  /* Extra NULLs for paranoia's sake */
  sprintf (buf, "process %d\0\0\0\0", pid);
d467 1
a467 1
  sprintf (buf, "system thread %d\0\0\0\0", tid);
@


1.10
log
@Update/correct copyright notices.
@
text
@d129 2
a130 1
	  ttrace_write_reg_64 (inferior_pid, (CORE_ADDR)addr, (CORE_ADDR)&temp);
d155 2
a156 1
	  call_ptrace (PT_WUREGS, inferior_pid, (PTRACE_ARG3_TYPE) addr + i,
d239 1
a239 1
	  call_ptrace (PT_RUREGS, inferior_pid,
d302 2
a303 1
				   inferior_pid, (PTRACE_ARG3_TYPE) addr, 0);
d310 1
a310 1
			   inferior_pid,
d332 1
a332 1
				   inferior_pid,
d344 1
a344 1
				       inferior_pid,
d364 2
a365 1
				   inferior_pid, (PTRACE_ARG3_TYPE) addr, 0);
d396 1
a396 1
  status = kill (inferior_pid, SIGCONT);
d440 1
a440 1
child_pid_to_str (pid_t pid)
d444 1
d458 1
a458 1
hppa_tid_to_str (pid_t tid)
d462 3
d637 1
a637 1
hppa_pid_or_tid_to_str (pid_t id)
d825 1
a825 1
child_post_startup_inferior (int pid)
d827 1
a827 1
  require_notification_of_events (pid);
d1051 1
a1051 1
  int saved_inferior_pid;
d1073 2
a1074 2
  /* On the chance that pid != inferior_pid, set inferior_pid
     to pid, so that (grrrr!) implicit uses of inferior_pid get
d1077 2
a1078 2
  saved_inferior_pid = inferior_pid;
  inferior_pid = pid;
d1085 1
a1085 1
	  inferior_pid = saved_inferior_pid;
d1100 1
a1100 1
      inferior_pid = saved_inferior_pid;
d1104 1
a1104 1
  inferior_pid = saved_inferior_pid;
d1135 1
a1135 1
child_thread_alive (int pid)
@


1.9
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1998, 1999,
   2001
@


1.8
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d33 1
@


1.7
log
@2001-02-05  Michael Chastain  <chastain@@redhat.com>

	* hppah-nat.c (child_xfer_memory): Add parameter 'struct mem_attrib *'
	to conform with interface change.
@
text
@d2 2
a3 1
   Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1998, 1999
d110 2
a111 1
	internal_error ("hppah-nat.c (write_register): unexpected register size");
d227 2
a228 1
    internal_error ("hppa-nat.c (fetch_register): unexpected register size");
@


1.6
log
@Replace free() with xfree().
@
text
@d269 1
@


1.5
log
@Protoization.
@
text
@d343 1
a343 1
		  free (buffer);
d359 1
a359 1
	      free (buffer);
d368 1
a368 1
  free (buffer);
@


1.4
log
@Protoization.
@
text
@d265 1
a265 1
   anyway.  */
d268 2
a269 6
child_xfer_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *target;	/* ignored */
@


1.3
log
@PARAMS removal.
@
text
@d39 1
a39 2
fetch_inferior_registers (regno)
     int regno;
d56 1
a56 2
store_inferior_registers (regno)
     int regno;
d179 1
a179 2
fetch_register (regno)
     int regno;
d378 1
a378 1
child_post_follow_inferior_by_clone ()
d396 2
a397 5
child_post_follow_vfork (parent_pid, followed_parent, child_pid, followed_child)
     int parent_pid;
     int followed_parent;
     int child_pid;
     int followed_child;
d435 1
a435 2
child_pid_to_str (pid)
     pid_t pid;
d452 1
a452 2
hppa_tid_to_str (tid)
     pid_t tid;
d510 1
a510 4
parent_attach_all (pid, addr, data)
     int pid;
     PTRACE_ARG3_TYPE addr;
     int data;
d547 1
a547 2
hppa_require_attach (pid)
     int pid;
d580 1
a580 3
hppa_require_detach (pid, signal)
     int pid;
     int signal;
d593 1
a593 2
hppa_enable_page_protection_events (pid)
     int pid;
d598 1
a598 2
hppa_disable_page_protection_events (pid)
     int pid;
d603 1
a603 5
hppa_insert_hw_watchpoint (pid, start, len, type)
     int pid;
     CORE_ADDR start;
     LONGEST len;
     int type;
d609 2
a610 5
hppa_remove_hw_watchpoint (pid, start, len, type)
     int pid;
     CORE_ADDR start;
     LONGEST len;
     enum bptype type;
d616 1
a616 4
hppa_can_use_hw_watchpoint (type, cnt, ot)
     enum bptype type;
     int cnt;
     enum bptype ot;
d622 1
a622 4
hppa_range_profitable_for_hw_watchpoint (pid, start, len)
     int pid;
     CORE_ADDR start;
     LONGEST len;
d628 1
a628 2
hppa_pid_or_tid_to_str (id)
     pid_t id;
d639 1
a639 2
hppa_switched_threads (pid)
     pid_t pid;
d645 1
a645 2
hppa_ensure_vforking_parent_remains_stopped (pid)
     int pid;
d657 1
a657 1
hppa_resume_execd_vforking_child_to_get_parent_vfork ()
d663 1
a663 2
require_notification_of_events (pid)
     int pid;
d728 1
a728 2
require_notification_of_exec_events (pid)
     int pid;
d769 1
a769 2
child_acknowledge_created_inferior (pid)
     int pid;
d816 1
a816 2
child_post_startup_inferior (pid)
     int pid;
d822 1
a822 2
child_post_attach (pid)
     int pid;
d828 1
a828 2
child_insert_fork_catchpoint (pid)
     int pid;
d842 1
a842 2
child_remove_fork_catchpoint (pid)
     int pid;
d856 1
a856 2
child_insert_vfork_catchpoint (pid)
     int pid;
d870 1
a870 2
child_remove_vfork_catchpoint (pid)
     int pid;
d884 1
a884 3
child_has_forked (pid, childpid)
     int pid;
     int *childpid;
d915 1
a915 3
child_has_vforked (pid, childpid)
     int pid;
     int *childpid;
d947 1
a947 1
child_can_follow_vfork_prior_to_exec ()
d954 1
a954 2
child_insert_exec_catchpoint (pid)
     int pid;
d969 1
a969 2
child_remove_exec_catchpoint (pid)
     int pid;
d984 1
a984 3
child_has_execd (pid, execd_pathname)
     int pid;
     char **execd_pathname;
d1017 1
a1017 1
child_reported_exec_events_per_exec_call ()
d1023 1
a1023 4
child_has_syscall_event (pid, kind, syscall_id)
     int pid;
     enum target_waitkind *kind;
     int *syscall_id;
d1034 1
a1034 2
child_pid_to_exec_file (pid)
     int pid;
d1100 1
a1100 1
pre_fork_inferior ()
d1126 1
a1126 2
child_thread_alive (pid)
     int pid;
@


1.2
log
@Include "gdb_wait.h" instead of <wait.h>.
@
text
@d36 1
a36 1
static void fetch_register PARAMS ((int));
d495 1
a495 1
extern int parent_attach_all PARAMS ((int, PTRACE_ARG3_TYPE, int));
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1998
d8 1
a8 1
This file is part of GDB.
d10 14
a23 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 1
a31 1
#include <wait.h>
d49 3
a61 1
  extern char registers[];
d68 2
d72 38
a109 15
      regaddr = register_addr (regno, offset);
      errno = 0;
      if (regno == PCOQ_HEAD_REGNUM || regno == PCOQ_TAIL_REGNUM)
        {
          scratch = *(int *) &registers[REGISTER_BYTE (regno)] | 0x3;
          call_ptrace (PT_WUREGS, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
                  scratch);
          if (errno != 0)
            {
	      /* Error, even if attached.  Failing to write these two
		 registers is pretty serious.  */
              sprintf (buf, "writing register number %d", regno);
              perror_with_name (buf);
            }
        }
d111 57
a167 13
	for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof(int))
	  {
	    errno = 0;
	    call_ptrace (PT_WUREGS, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
		    *(int *) &registers[REGISTER_BYTE (regno) + i]);
	    if (errno != 0)
	      {
		/* Warning, not error, in case we are attached; sometimes the
		   kernel doesn't let us at the registers.  */
		char *err = safe_strerror (errno);
		char *msg = alloca (strlen (err) + 128);
		sprintf (msg, "writing register %s: %s",
			 REGISTER_NAME (regno), err);
d169 3
a171 4
		return;
	      }
	    regaddr += sizeof(int);
	  }
a177 1
/* Fetch one register.  */
d179 1
a183 1
  register unsigned int regaddr;
d185 21
a205 1
  register int i;
d207 19
a225 2
  /* Offset of registers within the u area.  */
  unsigned int offset;
d227 2
a228 1
  offset = U_REGS_OFFSET;
d230 1
a230 2
  regaddr = register_addr (regno, offset);
  for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
d233 5
a237 3
      *(int *) &buf[i] = call_ptrace (PT_RUREGS, inferior_pid,
				 (PTRACE_ARG3_TYPE) regaddr, 0);
      regaddr += sizeof (int);
d240 2
a241 3
	  /* Warning, not error, in case we are attached; sometimes the
	   * kernel doesn't let us at the registers.
	   */
d244 2
a245 1
	  sprintf (msg, "reading register %s: %s", REGISTER_NAME (regno), err);
d247 1
a247 1
	  goto error_exit;
d250 4
d255 2
a256 1
    buf[3] &= ~0x3;
a257 1
 error_exit:;
d260 1
d264 1
a264 1
  
d276 1
a276 1
     struct target_ops *target;		/* ignored */
d280 1
a280 1
  register CORE_ADDR addr = memaddr & - sizeof (int);
d283 1
a283 1
    = (((memaddr + len) - addr) + sizeof (int) - 1) / sizeof (int);
d285 8
a292 11
  /* Allocate buffer of that many longwords.  */
  /* Note (RT) - This code formerly used alloca, which I have
   * replaced with xmalloc and a matching free() at the end.
   * The problem with alloca() is that there is no guarantee of
   * when it'll be freed, and we were seeing cases of memory
   * leaks on:
   * (gdb) watch x
   * (gdb) cont
   * where the piled-up alloca's for the child_xfer_memory buffers
   * were not getting freed.
   */
d298 6
a303 6

      if (addr != memaddr || len < (int)sizeof (int)) {
	/* Need part of initial word -- fetch it.  */
        buffer[0] = call_ptrace (addr < text_end ? PT_RIUSER : PT_RDUSER, 
			    inferior_pid, (PTRACE_ARG3_TYPE) addr, 0);
      }
d308 5
a312 3
	    = call_ptrace (addr < text_end ? PT_RIUSER : PT_RDUSER, inferior_pid,
		      (PTRACE_ARG3_TYPE) (addr + (count - 1) * sizeof (int)),
		      0);
a315 1

a318 1

d321 7
a327 6
          int  pt_status;
          int  pt_request;
	  /* The HP-UX kernel crashes if you use PT_WDUSER to write into the text
	     segment.  FIXME -- does it work to write into the data segment using
	     WIUSER, or do these idiots really expect us to figure out which segment
	     the address is in, so we can use a separate system call for it??!  */
d329 1
a329 1
          pt_request = (addr < text_end) ? PT_WIUSER : PT_WDUSER;
d331 23
a353 23
                                   inferior_pid, 
                                   (PTRACE_ARG3_TYPE) addr,
                                   buffer[i]);

          /* Did we fail?  Might we've guessed wrong about which
             segment this address resides in?  Try the other request,
             and see if that works...
             */
	  if ((pt_status == -1) && errno) {
            errno = 0;
            pt_request = (pt_request == PT_WIUSER) ? PT_WDUSER : PT_WIUSER;
            pt_status = call_ptrace (pt_request,
                                     inferior_pid, 
                                     (PTRACE_ARG3_TYPE) addr,
                                     buffer[i]);

            /* No, we still fail.  Okay, time to punt. */
            if ((pt_status == -1) && errno)
              {
                free(buffer);
                return 0;
              }
	  }
d362 7
a368 6
	  buffer[i] = call_ptrace (addr < text_end ? PT_RIUSER : PT_RDUSER, 
			      inferior_pid, (PTRACE_ARG3_TYPE) addr, 0);
	  if (errno) {
	    free(buffer);
	    return 0;
	  }
d375 1
a375 1
  free(buffer);
d383 1
a383 1
  int  status;
d400 4
a403 4
     int  parent_pid;
     int  followed_parent;
     int  child_pid;
     int  followed_child;
a404 1

d428 1
a428 2
     until after it has exec'd or exited.
     */
a434 1

d438 2
a439 3
/* Format a process id, given a pid.  Be sure to terminate
 * this with a null--it's going to be printed via a "%s".
 */
d441 2
a442 2
hppa_pid_to_str( pid )
    pid_t pid;
d444 8
a451 1
    static char buf[30]; /* Static because address returned */
d453 5
a457 12
    sprintf( buf, "process %d\0\0\0\0", pid );
             /* Extra NULLs for paranoia's sake */
             
    return buf;
}

/* Format a thread id, given a tid.  Be sure to terminate
 * this with a null--it's going to be printed via a "%s".
 *
 * Note: This is a core-gdb tid, not the actual system tid.
 *       See infttrace.c for details.
 */
d459 2
a460 2
hppa_tid_to_str( tid )
    pid_t tid;
d462 5
a466 1
    static char buf[30]; /* Static because address returned */
d468 1
a468 4
    sprintf( buf, "system thread %d\0\0\0\0", tid );
             /* Extra NULLs for paranoia's sake */
             
    return buf;
d483 6
a488 4
typedef struct {
    int parent_channel[2];  /* Parent "talks" to [1], child "listens" to [0] */
    int child_channel[2];   /* Child "talks" to [1], parent "listens" to [0] */
} startup_semaphore_t;
d493 1
a493 1
static startup_semaphore_t  startup_semaphore;
d536 2
a537 2
         &tc_magic_child,
         sizeof (tc_magic_child));
d541 2
a542 2
        &tc_magic_parent,
        sizeof (tc_magic_parent));
d544 1
a544 1
      warning ("mismatched semaphore magic");
d552 1
a552 1
  
d562 2
a563 2
  CORE_ADDR  pc;
  CORE_ADDR  pc_addr;
d582 1
a582 1
        return -1;
d593 2
a594 2
  int pid;
  int signal;
d598 1
a598 1
  errno = 0;  /* Ignore any errors. */
d661 1
a661 1
  return hppa_pid_to_str (id);
d691 1
a691 1
  return 1;  /* Yes, the child must be resumed. */
d696 1
a696 1
  int pid;
d701 2
d707 1
a707 2
     <sys/ptrace.h>, then we're being built on pre-10.0.)
     */
d713 24
a736 3
     each such signal here, before doing PT_SET_EVENT_MASK.
     */
  sigemptyset (&ptrace_events.pe_signals);
d745 2
a746 2
  ptrace_events.pe_set_event |= PTRACE_EXIT;
  */
d750 3
a752 3
                      pid,
                      (PTRACE_ARG3_TYPE) &ptrace_events,
                      sizeof (ptrace_events));
d762 1
a762 1
  int pid;
d771 1
a771 2
     <sys/ptrace.h>, then we're being built on pre-10.0.)
     */
d777 1
a777 2
     each such signal here, before doing PT_SET_EVENT_MASK.
     */
d784 2
a785 2
  ptrace_events.pe_set_event |= PTRACE_EXIT;
  */
d789 3
a791 3
                      pid,
                      (PTRACE_ARG3_TYPE) &ptrace_events,
                      sizeof (ptrace_events));
d804 1
a804 1
    int pid;
d810 4
d816 2
a817 2
        &tc_magic_child,
        sizeof(tc_magic_child));
a823 1

d825 2
a826 2
         &tc_magic_parent,
         sizeof (tc_magic_parent));
a835 1

a839 1

d847 1
d852 1
a852 2
  int pid;

d859 1
a859 1
  int pid;
d866 1
a866 1
  int pid;
d874 1
a874 2
     and just ignoring them if there's no catchpoint to catch them.
     */
d881 1
a881 1
  int pid;
d896 1
a896 1
  int pid;
d911 1
a911 1
  int pid;
d926 2
a927 2
  int pid;
  int *  childpid;
d935 1
a935 1
  ptrace_state_t  ptrace_state;
d939 3
a941 3
                      pid,
                      (PTRACE_ARG3_TYPE) &ptrace_state,
                      sizeof (ptrace_state));
d959 2
a960 2
  int pid;
  int * childpid;
d969 1
a969 1
  ptrace_state_t  ptrace_state;
d973 3
a975 3
                      pid,
                      (PTRACE_ARG3_TYPE) &ptrace_state,
                      sizeof (ptrace_state));
d1000 1
a1000 1
  int pid;
d1002 1
a1002 2
  /* This request is only available on HPUX 10.0 and later.
     */
d1007 1
a1007 1
  /* Enable reporting of exec events from the kernel. */
d1009 1
a1009 2
     and just ignoring them if there's no catchpoint to catch them.
     */
d1016 1
a1016 1
  int pid;
d1018 1
a1018 2
  /* This request is only available on HPUX 10.0 and later.
     */
d1025 1
a1025 2
     and just ignoring them if there's no catchpoint to catch them.
     */
d1032 2
a1033 2
  int pid;
  char **  execd_pathname;
d1035 1
a1035 3

  /* This request is only available on HPUX 10.0 and later.
     */
d1042 1
a1042 1
  ptrace_state_t  ptrace_state;
d1046 3
a1048 3
                      pid,
                      (PTRACE_ARG3_TYPE) &ptrace_state,
                      sizeof (ptrace_state));
d1056 1
a1056 1
      char *  exec_file = target_pid_to_exec_file (pid);
d1068 1
a1068 1
  return 2;  /* ptrace reports the event twice per call. */
d1087 1
a1087 1
    int pid;
d1089 1
a1089 1
  static char  exec_file_buffer[1024];
d1091 2
a1092 2
  CORE_ADDR  top_of_stack;
  char  four_chars[4];
d1096 2
a1097 2
  boolean  done;
  
d1101 3
a1103 3
                           pid,
                           (PTRACE_ARG3_TYPE) exec_file_buffer,
                           sizeof (exec_file_buffer) - 1);
d1125 1
a1125 1
  while (! done)
d1171 1
a1172 1

d1182 1
a1182 1
   return 1;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d58 1
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@d2 1
a2 1
   Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1998, 1999
d69 6
a74 6
	{
	  scratch = *(int *) &registers[REGISTER_BYTE (regno)] | 0x3;
	  call_ptrace (PT_WUREGS, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
		       scratch);
	  if (errno != 0)
	    {
d77 4
a80 4
	      sprintf (buf, "writing register number %d", regno);
	      perror_with_name (buf);
	    }
	}
d86 1
a86 1
			 *(int *) &registers[REGISTER_BYTE (regno) + i]);
d126 1
a126 1
				      (PTRACE_ARG3_TYPE) regaddr, 0);
d131 2
a132 1
	     kernel doesn't let us at the registers.  */
d170 11
a180 8
  /* Allocate buffer of that many longwords.
     Note -- do not use alloca to allocate this buffer since there is no
     guarantee of when the buffer will actually be deallocated.

     This routine can be called over and over with the same call chain;
     this (in effect) would pile up all those alloca requests until a call
     to alloca was made from a point higher than this routine in the
     call chain.  */
d186 6
a191 6
      if (addr != memaddr || len < (int)sizeof (int))
	{
	  /* Need part of initial word -- fetch it.  */
	  buffer[0] = call_ptrace (addr < text_end ? PT_RIUSER : PT_RDUSER, 
				   inferior_pid, (PTRACE_ARG3_TYPE) addr, 0);
	}
d196 3
a198 5
	    = call_ptrace (addr < text_end ? PT_RIUSER : PT_RDUSER,
			   inferior_pid,
			   (PTRACE_ARG3_TYPE) (addr
					       + (count - 1) * sizeof (int)),
			   0);
d202 1
d206 1
d209 6
a214 7
	  int pt_status;
	  int pt_request;
	  /* The HP-UX kernel crashes if you use PT_WDUSER to write into the
	     text segment.  FIXME -- does it work to write into the data
	     segment using WIUSER, or do these idiots really expect us to
	     figure out which segment the address is in, so we can use a
	     separate system call for it??!  */
d216 1
a216 1
	  pt_request = (addr < text_end) ? PT_WIUSER : PT_WDUSER;
d218 23
a240 23
				   inferior_pid, 
				   (PTRACE_ARG3_TYPE) addr,
				   buffer[i]);

	  /* Did we fail?  Might we've guessed wrong about which
	     segment this address resides in?  Try the other request,
	     and see if that works...  */
	  if ((pt_status == -1) && errno)
	    {
	      errno = 0;
	      pt_request = (pt_request == PT_WIUSER) ? PT_WDUSER : PT_WIUSER;
	      pt_status = call_ptrace (pt_request,
				       inferior_pid, 
				       (PTRACE_ARG3_TYPE) addr,
				       buffer[i]);

	      /* No, we still fail.  Okay, time to punt. */
	      if ((pt_status == -1) && errno)
		{
		  free(buffer);
		  return 0;
		}
	    }
d250 5
a254 6
				   inferior_pid, (PTRACE_ARG3_TYPE) addr, 0);
	  if (errno)
	    {
	      free(buffer);
	      return 0;
	    }
d269 1
a269 1
  int status;
d286 4
a289 4
     int parent_pid;
     int followed_parent;
     int child_pid;
     int followed_child;
d291 1
d315 2
a316 1
     until after it has exec'd or exited.  */
d320 4
a323 3
	 In the case of an exec event, we'll let that be handled by
	 the normal mechanism that notices and handles exec events, in
	 resume(). */
d327 3
a329 2
/* Format a process id, given PID.  Be sure to terminate
   this with a null--it's going to be printed via a "%s".  */
d331 1
a331 1
hppa_pid_to_str (pid)
d334 1
a334 2
    /* Static because address returned */
    static char buf[30];
d336 3
a338 3
    /* Extra NULLs for paranoia's sake */
    sprintf (buf, "process %d\0\0\0\0", pid);
	     
d342 6
a347 5
/* Format a thread id, given TID.  Be sure to terminate
   this with a null--it's going to be printed via a "%s".

   Note: This is a core-gdb tid, not the actual system tid.
         See infttrace.c for details.  */
d349 1
a349 1
hppa_tid_to_str (tid)
d352 1
a352 2
    /* Static because address returned */
    static char buf[30];
d354 3
a356 3
    /* Extra NULLs for paranoia's sake */
    sprintf (buf, "system thread %d\0\0\0\0", tid);
	     
d423 2
a424 2
	 &tc_magic_child,
	 sizeof (tc_magic_child));
d428 2
a429 2
	&tc_magic_parent,
	sizeof (tc_magic_parent));
d449 2
a450 2
  CORE_ADDR pc;
  CORE_ADDR pc_addr;
d469 1
a469 1
	return -1;
d583 1
a583 1
     int pid;
d592 2
a593 1
     <sys/ptrace.h>, then we're being built on pre-10.0.)  */
d599 2
a600 1
     each such signal here, before doing PT_SET_EVENT_MASK.  */
d615 3
a617 3
		      pid,
		      (PTRACE_ARG3_TYPE) &ptrace_events,
		      sizeof (ptrace_events));
d627 1
a627 1
     int pid;
d636 2
a637 1
     <sys/ptrace.h>, then we're being built on pre-10.0.)  */
d643 2
a644 1
     each such signal here, before doing PT_SET_EVENT_MASK.  */
d656 3
a658 3
		      pid,
		      (PTRACE_ARG3_TYPE) &ptrace_events,
		      sizeof (ptrace_events));
d671 1
a671 1
     int pid;
a676 4
  /* The remainder of this function is only useful for HPUX 10.0 and
     later, as it depends upon the ability to request notification
     of specific kinds of events by the kernel.  */
#if defined(PT_SET_EVENT_MASK)
d679 2
a680 2
	&tc_magic_child,
	sizeof(tc_magic_child));
d687 1
d689 2
a690 2
	 &tc_magic_parent,
	 sizeof (tc_magic_parent));
d700 1
d705 1
a712 1
#endif
d717 2
a718 1
     int pid;
d725 1
a725 1
     int pid;
d732 1
a732 1
     int pid;
d740 2
a741 1
     and just ignoring them if there's no catchpoint to catch them.  */
d748 1
a748 1
     int pid;
d763 1
a763 1
     int pid;
d778 1
a778 1
     int pid;
d793 2
a794 2
     int pid;
     int *childpid;
d806 3
a808 3
			   pid,
			   (PTRACE_ARG3_TYPE) &ptrace_state,
			   sizeof (ptrace_state));
d826 2
a827 2
     int pid;
     int *childpid;
d840 3
a842 3
			   pid,
			   (PTRACE_ARG3_TYPE) &ptrace_state,
			   sizeof (ptrace_state));
d867 1
a867 1
     int pid;
d869 2
a870 1
  /* This request is only available on HPUX 10.0 and later.   */
d875 1
a875 1
  /* Enable reporting of exec events from the kernel.  */
d877 2
a878 1
     and just ignoring them if there's no catchpoint to catch them.  */
d885 1
a885 1
     int pid;
d887 2
a888 1
  /* This request is only available on HPUX 10.0 and later.  */
d895 2
a896 1
     and just ignoring them if there's no catchpoint to catch them.  */
d903 2
a904 2
     int pid;
     char **execd_pathname;
d906 3
a908 1
  /* This request is only available on HPUX 10.0 and later.  */
d919 3
a921 3
			   pid,
			   (PTRACE_ARG3_TYPE) &ptrace_state,
			   sizeof (ptrace_state));
d960 1
a960 1
     int pid;
d962 1
a962 1
  static char exec_file_buffer[1024];
d964 2
a965 2
  CORE_ADDR top_of_stack;
  char four_chars[4];
d969 1
a969 1
  boolean done;
d974 3
a976 3
			   pid,
			   (PTRACE_ARG3_TYPE) exec_file_buffer,
			   sizeof (exec_file_buffer) - 1);
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d8 1
a8 1
   This file is part of GDB.
d10 13
a22 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d76 1
a76 1
	         registers is pretty serious.  */
d82 1
a82 1
	for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
d98 1
a98 1
	    regaddr += sizeof (int);
d142 1
a142 1
error_exit:;
d148 1
a148 1

d160 1
a160 1
     struct target_ops *target;	/* ignored */
d164 1
a164 1
  register CORE_ADDR addr = memaddr & -sizeof (int);
d167 1
a167 1
  = (((memaddr + len) - addr) + sizeof (int) - 1) / sizeof (int);
d182 1
a182 1
      if (addr != memaddr || len < (int) sizeof (int))
d185 1
a185 1
	  buffer[0] = call_ptrace (addr < text_end ? PT_RIUSER : PT_RDUSER,
d215 1
a215 1
				   inferior_pid,
d227 1
a227 1
				       inferior_pid,
d234 1
a234 1
		  free (buffer);
d246 1
a246 1
	  buffer[i] = call_ptrace (addr < text_end ? PT_RIUSER : PT_RDUSER,
d250 1
a250 1
	      free (buffer);
d259 1
a259 1
  free (buffer);
d316 3
a318 3
         In the case of an exec event, we'll let that be handled by
         the normal mechanism that notices and handles exec events, in
         resume(). */
d326 1
a326 1
     pid_t pid;
d328 2
a329 2
  /* Static because address returned */
  static char buf[30];
d331 4
a334 4
  /* Extra NULLs for paranoia's sake */
  sprintf (buf, "process %d\0\0\0\0", pid);

  return buf;
d341 1
a341 1
   See infttrace.c for details.  */
d344 1
a344 1
     pid_t tid;
d346 2
a347 5
  /* Static because address returned */
  static char buf[30];

  /* Extra NULLs for paranoia's sake */
  sprintf (buf, "system thread %d\0\0\0\0", tid);
d349 4
a352 1
  return buf;
d367 4
a370 6
typedef struct
{
  int parent_channel[2];	/* Parent "talks" to [1], child "listens" to [0] */
  int child_channel[2];		/* Child "talks" to [1], parent "listens" to [0] */
}
startup_semaphore_t;
d375 1
a375 1
static startup_semaphore_t startup_semaphore;
d426 1
a426 1
    warning ("mismatched semaphore magic");
d434 1
a434 1

d475 2
a476 2
     int pid;
     int signal;
d480 1
a480 1
  errno = 0;			/* Ignore any errors. */
d573 1
a573 1
  return 1;			/* Yes, the child must be resumed. */
d603 2
a604 2
     ptrace_events.pe_set_event |= PTRACE_EXIT;
   */
d608 3
a610 3
			   pid,
			   (PTRACE_ARG3_TYPE) & ptrace_events,
			   sizeof (ptrace_events));
d642 2
a643 2
     ptrace_events.pe_set_event |= PTRACE_EXIT;
   */
d647 3
a649 3
			   pid,
			   (PTRACE_ARG3_TYPE) & ptrace_events,
			   sizeof (ptrace_events));
d675 1
a675 1
	sizeof (tc_magic_child));
d793 1
a793 1
  ptrace_state_t ptrace_state;
d798 1
a798 1
			   (PTRACE_ARG3_TYPE) & ptrace_state,
d827 1
a827 1
  ptrace_state_t ptrace_state;
d832 1
a832 1
			   (PTRACE_ARG3_TYPE) & ptrace_state,
d900 1
a900 1
  ptrace_state_t ptrace_state;
d905 1
a905 1
			   (PTRACE_ARG3_TYPE) & ptrace_state,
d914 1
a914 1
      char *exec_file = target_pid_to_exec_file (pid);
d926 1
a926 1
  return 2;			/* ptrace reports the event twice per call. */
d955 1
a955 1

d983 1
a983 1
  while (!done)
d1029 1
a1030 1

d1040 1
a1040 1
  return 1;
@


1.1.1.5
log
@import gdb-1999-07-19 snapshot
@
text
@d107 1
a108 4
/* Our own version of the offsetof macro, since we can't assume ANSI C.  */
#define HPPAH_OFFSETOF(type, member) ((int) (&((type *) 0)->member))

/* Fetch a register's value from the process's U area.  */
d113 1
d115 1
a115 21
  unsigned int addr, len, offset;
  int i;

  offset = 0;
  len = REGISTER_RAW_SIZE (regno);

  /* Requests for register zero actually want the save_state's
     ss_flags member.  As RM says: "Oh, what a hack!"  */
  if (regno == 0)
    {
      save_state_t ss;
      addr = HPPAH_OFFSETOF (save_state_t, ss_flags);
      len = sizeof (ss.ss_flags);

      /* Note that ss_flags is always an int, no matter what
	 REGISTER_RAW_SIZE(0) says.  Assuming all HP-UX PA machines
	 are big-endian, put it at the least significant end of the
	 value, and zap the rest of the buffer.  */
      offset = REGISTER_RAW_SIZE (0) - len;
      memset (buf, 0, sizeof (buf));
    }
d117 2
a118 4
  /* Floating-point registers come from the ss_fpblock area.  */
  else if (regno >= FP0_REGNUM)
    addr = (HPPAH_OFFSETOF (save_state_t, ss_fpblock) 
	    + (REGISTER_BYTE (regno) - REGISTER_BYTE (FP0_REGNUM)));
d120 1
a120 8
  /* Wide registers come from the ss_wide area.
     I think it's more PC to test (ss_flags & SS_WIDEREGS) to select
     between ss_wide and ss_narrow than to use the raw register size.
     But checking ss_flags would require an extra ptrace call for
     every register reference.  Bleah.  */
  else if (len == 8)
    addr = (HPPAH_OFFSETOF (save_state_t, ss_wide) 
	    + REGISTER_BYTE (regno));
d122 2
a123 10
  /* Narrow registers come from the ss_narrow area.  Note that
     ss_narrow starts with gr1, not gr0.  */
  else if (len == 4)
    addr = (HPPAH_OFFSETOF (save_state_t, ss_narrow)
	    + (REGISTER_BYTE (regno) - REGISTER_BYTE (1)));

  else
    fatal ("hppa-nat.c (fetch_register): unexpected register size");

  for (i = 0; i < len; i += sizeof (int))
d126 3
a128 5
      /* Copy an int from the U area to buf.  Fill the least
         significant end if len != raw_size.  */
      * (int *) &buf[offset + i] =
	  call_ptrace (PT_RUREGS, inferior_pid,
		       (PTRACE_ARG3_TYPE) addr + i, 0);
d131 2
a132 2
	  /* Warning, not error, in case we are attached; sometimes
	     the kernel doesn't let us at the registers. */
d135 1
a135 2
	  sprintf (msg, "reading `%s' register: %s",
		   REGISTER_NAME (regno), err);
d137 1
a137 1
	  return;
a139 4

  /* If we're reading an address from the instruction address queue,
     mask out the bottom two bits --- they contain the privilege
     level.  */
d141 1
a141 2
    buf[len - 1] &= ~0x3;

d143 1
a144 1

@


1.1.1.6
log
@import gdb-1999-08-02 snapshot
@
text
@d212 1
a212 1
  register CORE_ADDR addr = memaddr & - (CORE_ADDR)(sizeof (int));
@


1.1.1.7
log
@import gdb-1999-08-09 snapshot
@
text
@d160 1
a160 1
    internal_error ("hppa-nat.c (fetch_register): unexpected register size");
@


1.1.1.8
log
@import gdb-1999-08-16 snapshot
@
text
@a48 3
/* Our own version of the offsetof macro, since we can't assume ANSI C.  */
#define HPPAH_OFFSETOF(type, member) ((int) (&((type *) 0)->member))

a64 2
      unsigned int addr, len, offset;

d67 3
a69 48

      offset = 0;
      len = REGISTER_RAW_SIZE (regno);

      /* Requests for register zero actually want the save_state's
	 ss_flags member.  As RM says: "Oh, what a hack!"  */
      if (regno == 0)
	{
	  save_state_t ss;
	  addr = HPPAH_OFFSETOF (save_state_t, ss_flags);
	  len = sizeof (ss.ss_flags);

	  /* Note that ss_flags is always an int, no matter what
	     REGISTER_RAW_SIZE(0) says.  Assuming all HP-UX PA machines
	     are big-endian, put it at the least significant end of the
	     value, and zap the rest of the buffer.  */
	  offset = REGISTER_RAW_SIZE (0) - len;
	}

      /* Floating-point registers come from the ss_fpblock area.  */
      else if (regno >= FP0_REGNUM)
	addr = (HPPAH_OFFSETOF (save_state_t, ss_fpblock) 
		+ (REGISTER_BYTE (regno) - REGISTER_BYTE (FP0_REGNUM)));

      /* Wide registers come from the ss_wide area.
	 I think it's more PC to test (ss_flags & SS_WIDEREGS) to select
	 between ss_wide and ss_narrow than to use the raw register size.
	 But checking ss_flags would require an extra ptrace call for
	 every register reference.  Bleah.  */
      else if (len == 8)
	addr = (HPPAH_OFFSETOF (save_state_t, ss_wide) 
		+ REGISTER_BYTE (regno));

      /* Narrow registers come from the ss_narrow area.  Note that
	 ss_narrow starts with gr1, not gr0.  */
      else if (len == 4)
	addr = (HPPAH_OFFSETOF (save_state_t, ss_narrow)
		+ (REGISTER_BYTE (regno) - REGISTER_BYTE (1)));
      else
	internal_error ("hppah-nat.c (write_register): unexpected register size");

#ifdef GDB_TARGET_IS_HPPA_20W
      /* Unbelieveable.  The PC head and tail must be written in 64bit hunks
	 or we will get an error.  Worse yet, the oddball ptrace/ttrace
	 layering will not allow us to perform a 64bit register store.

	 What a crock.  */
      if (regno == PCOQ_HEAD_REGNUM || regno == PCOQ_TAIL_REGNUM && len == 8)
d71 3
a73 11
	  CORE_ADDR temp;

	  temp = *(CORE_ADDR *)&registers[REGISTER_BYTE (regno)];

	  /* Set the priv level (stored in the low two bits of the PC.  */
	  temp |= 0x3;

	  ttrace_write_reg_64 (inferior_pid, (CORE_ADDR)addr, (CORE_ADDR)&temp);

	  /* If we fail to write the PC, give a true error instead of
	     just a warning.  */
d76 4
a79 5
	      char *err = safe_strerror (errno);
	      char *msg = alloca (strlen (err) + 128);
	      sprintf (msg, "writing `%s' register: %s",
		        REGISTER_NAME (regno), err);
	      perror_with_name (msg);
a80 1
	  return;
d82 14
a95 20
#endif

      for (i = 0; i < len; i += sizeof (int))
	{
	  errno = 0;
	  call_ptrace (PT_WUREGS, inferior_pid, (PTRACE_ARG3_TYPE) addr + i,
		       *(int *) &registers[REGISTER_BYTE (regno) + i]);
	  if (errno != 0)
	    {
	      /* Warning, not error, in case we are attached; sometimes
		 the kernel doesn't let us at the registers. */
	      char *err = safe_strerror (errno);
	      char *msg = alloca (strlen (err) + 128);
	      sprintf (msg, "reading `%s' register: %s",
		        REGISTER_NAME (regno), err);
	      /* If we fail to write the PC, give a true error instead of
		 just a warning.  */
	      if (regno == PCOQ_HEAD_REGNUM || regno == PCOQ_TAIL_REGNUM)
		perror_with_name (msg);
	      else
d97 4
a100 3
	      return;
	    }
	}
d107 3
@


1.1.1.9
log
@import gdb-1999-08-23 snapshot
@
text
@a141 6

      /* Another crock.  HPUX complains if you write a nonzero value to
	 the high part of IPSW.  What will it take for HP to catch a
	 clue about building sensible interfaces?  */
     if (regno == IPSW_REGNUM && len == 8)
	*(int *)&registers[REGISTER_BYTE (regno)] = 0;
d155 1
a155 1
	      sprintf (msg, "writing `%s' register: %s",
@


1.1.1.10
log
@import gdb-1999-12-06 snapshot
@
text
@a700 2
  int nsigs;
  int signum;
d712 1
a712 23
  /* RM: The above comment is no longer true. We start with ignoring
     all signals, and then add the ones we are interested in. We could
     do it the other way: start by looking at all signals and then
     deleting the ones that we aren't interested in, except that
     multiple gdb signals may be mapped to the same host signal
     (eg. TARGET_SIGNAL_IO and TARGET_SIGNAL_POLL both get mapped to
     signal 22 on HPUX 10.20) We want to be notified if we are
     interested in either signal.  */
  sigfillset (&ptrace_events.pe_signals);

  /* RM: Let's not bother with signals we don't care about */
  nsigs = (int) TARGET_SIGNAL_LAST;
  for (signum = nsigs; signum > 0; signum--)
    {
      if ((signal_stop_state (signum)) ||
	  (signal_print_state (signum)) ||
	  (!signal_pass_state (signum)))
	{
	  if (target_signal_to_host_p (signum))
	    sigdelset (&ptrace_events.pe_signals,
		       target_signal_to_host (signum));
	}
    }
@


1.1.1.11
log
@import gdb-1999-12-21 snapshot
@
text
@d441 1
a441 1
child_pid_to_str (pid)
d661 1
a661 1
  return child_pid_to_str (id);
@


