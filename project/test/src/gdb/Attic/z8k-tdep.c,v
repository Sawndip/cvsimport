head	1.19;
access;
symbols
	gdb_6_0-2003-10-04-release:1.18
	kettenis_sparc-20030918-branch:1.18.0.36
	kettenis_sparc-20030918-branchpoint:1.18
	carlton_dictionary-20030917-merge:1.18
	ezannoni_pie-20030916-branchpoint:1.18
	ezannoni_pie-20030916-branch:1.18.0.34
	cagney_x86i386-20030821-branch:1.18.0.32
	cagney_x86i386-20030821-branchpoint:1.18
	carlton_dictionary-20030805-merge:1.18
	carlton_dictionary-20030627-merge:1.18
	gdb_6_0-branch:1.18.0.30
	gdb_6_0-2003-06-23-branchpoint:1.18
	jimb-ppc64-linux-20030613-branch:1.18.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.18
	cagney_convert-20030606-branch:1.18.0.26
	cagney_convert-20030606-branchpoint:1.18
	cagney_writestrings-20030508-branch:1.18.0.24
	cagney_writestrings-20030508-branchpoint:1.18
	jimb-ppc64-linux-20030528-branch:1.18.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.18
	carlton_dictionary-20030523-merge:1.18
	cagney_fileio-20030521-branch:1.18.0.20
	cagney_fileio-20030521-branchpoint:1.18
	kettenis_i386newframe-20030517-mergepoint:1.18
	jimb-ppc64-linux-20030509-branch:1.18.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.18
	kettenis_i386newframe-20030504-mergepoint:1.18
	carlton_dictionary-20030430-merge:1.18
	kettenis_i386newframe-20030419-branch:1.18.0.16
	kettenis_i386newframe-20030419-branchpoint:1.18
	carlton_dictionary-20030416-merge:1.18
	cagney_frameaddr-20030409-mergepoint:1.18
	kettenis_i386newframe-20030406-branch:1.18.0.14
	kettenis_i386newframe-20030406-branchpoint:1.18
	cagney_frameaddr-20030403-branchpoint:1.18
	cagney_frameaddr-20030403-branch:1.18.0.12
	cagney_framebase-20030330-mergepoint:1.18
	cagney_framebase-20030326-branch:1.18.0.10
	cagney_framebase-20030326-branchpoint:1.18
	cagney_lazyid-20030317-branch:1.18.0.8
	cagney_lazyid-20030317-branchpoint:1.18
	kettenis-i386newframe-20030316-mergepoint:1.18
	offbyone-20030313-branch:1.18.0.6
	offbyone-20030313-branchpoint:1.18
	kettenis-i386newframe-20030308-branch:1.18.0.4
	kettenis-i386newframe-20030308-branchpoint:1.18
	carlton_dictionary-20030305-merge:1.18
	cagney_offbyone-20030303-branch:1.18.0.2
	cagney_offbyone-20030303-branchpoint:1.18
	carlton_dictionary-20030207-merge:1.18
	interps-20030203-mergepoint:1.17
	interps-20030202-branch:1.17.0.2
	interps-20030202-branchpoint:1.17
	cagney-unwind-20030108-branch:1.16.0.2
	cagney-unwind-20030108-branchpoint:1.16
	carlton_dictionary-20021223-merge:1.15
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.12
	kseitz_interps-20021105-merge:1.11
	kseitz_interps-20021103-merge:1.11
	drow-cplus-merge-20021020:1.10
	drow-cplus-merge-20021025:1.10
	carlton_dictionary-20021025-merge:1.10
	carlton_dictionary-20021011-merge:1.10
	drow-cplus-branch:1.10.0.10
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.8
	carlton_dictionary-20020920-branchpoint:1.10
	gdb_5_3-branch:1.10.0.6
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.4
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.2
	readline_4_3-import-branchpoint:1.10
	gdb_5_2_1-2002-07-23-release:1.6
	kseitz_interps-20020528-branch:1.8.0.6
	kseitz_interps-20020528-branchpoint:1.8
	cagney_regbuf-20020515-branch:1.8.0.4
	cagney_regbuf-20020515-branchpoint:1.8
	jimb-macro-020506-branch:1.8.0.2
	jimb-macro-020506-branchpoint:1.8
	gdb_5_2-2002-04-29-release:1.6
	gdb_5_2-branch:1.6.0.10
	gdb_5_2-2002-03-03-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.6
	gdb_5_1_0_1-2002-01-03-release:1.6
	cygnus_cvs_20020108_pre:1.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.8
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.6
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.4
	gdb_5_1-2001-07-29-branchpoint:1.6
	dberlin-typesystem-branch:1.6.0.2
	dberlin-typesystem-branchpoint:1.6
	gdb-post-ptid_t-2001-05-03:1.6
	gdb-pre-ptid_t-2001-05-03:1.6
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.19
date	2003.10.06.19.10.44;	author cagney;	state dead;
branches;
next	1.18;

1.18
date	2003.02.04.23.22.24;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.14.00.49.04;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.02.22.20.47;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.09.02.04.16;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.29.19.15.15;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.24.19.48.13;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.14.00.25.03;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.31.19.14.07;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.29.16.34.07;	author cagney;	state Exp;
branches
	1.10.8.1
	1.10.10.1;
next	1.9;

1.9
date	2002.06.02.15.37.55;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.20.03.09.28;	author cagney;	state Exp;
branches
	1.8.4.1
	1.8.6.1;
next	1.7;

1.7
date	2002.04.12.18.18.57;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.06.08.21.18;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.01.01.39.22;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.28;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.33;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.11.22;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.09.08.23.59.41;	author shebs;	state Exp;
branches;
next	;

1.8.4.1
date	2002.06.15.16.42.55;	author cagney;	state Exp;
branches;
next	;

1.8.6.1
date	2002.06.20.01.33.21;	author kseitz;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2002.08.09.18.34.28;	author kseitz;	state Exp;
branches;
next	1.8.6.3;

1.8.6.3
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.10.8.1
date	2002.11.15.19.19.01;	author carlton;	state Exp;
branches;
next	1.10.8.2;

1.10.8.2
date	2002.12.23.19.38.50;	author carlton;	state Exp;
branches;
next	1.10.8.3;

1.10.8.3
date	2003.02.07.19.17.54;	author carlton;	state Exp;
branches;
next	1.10.8.4;

1.10.8.4
date	2003.11.11.23.51.02;	author carlton;	state dead;
branches;
next	;

1.10.10.1
date	2003.12.14.20.27.34;	author drow;	state dead;
branches;
next	;


desc
@@


1.19
log
@2003-10-06  Andrew Cagney  <cagney@@redhat.com>

	* z8k-tdep.c, symm-tdep.c, symm-nat.c: Delete obsolete file.
	* sparclet-stub.c, sparclet-rom.c: Delete obsolete file.
	* sparcl-tdep.c, sparcl-stub.c, h8500-tdep.c: Delete obsolete file.
	* m3-nat.c, mipsm3-nat.c, mn10200-tdep.c: Delete obsolete file.
@
text
@// OBSOLETE /* Target-machine dependent code for Zilog Z8000, for GDB.
// OBSOLETE 
// OBSOLETE    Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
// OBSOLETE    2002, 2003 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE    Contributed by Steve Chamberlain
// OBSOLETE    sac@@cygnus.com
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "gdbcmd.h"
// OBSOLETE #include "gdbtypes.h"
// OBSOLETE #include "dis-asm.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #include "value.h" /* For read_register() */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static int read_memory_pointer (CORE_ADDR x);
// OBSOLETE 
// OBSOLETE /* Return the saved PC from this frame.
// OBSOLETE 
// OBSOLETE    If the frame has a memory copy of SRP_REGNUM, use that.  If not,
// OBSOLETE    just use the register SRP_REGNUM itself.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE z8k_frame_saved_pc (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   return read_memory_pointer (frame->frame + (BIG ? 4 : 2));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #define IS_PUSHL(x) (BIG ? ((x & 0xfff0) == 0x91e0):((x & 0xfff0) == 0x91F0))
// OBSOLETE #define IS_PUSHW(x) (BIG ? ((x & 0xfff0) == 0x93e0):((x & 0xfff0)==0x93f0))
// OBSOLETE #define IS_MOVE_FP(x) (BIG ? x == 0xa1ea : x == 0xa1fa)
// OBSOLETE #define IS_MOV_SP_FP(x) (BIG ? x == 0x94ea : x == 0x0d76)
// OBSOLETE #define IS_SUB2_SP(x) (x==0x1b87)
// OBSOLETE #define IS_MOVK_R5(x) (x==0x7905)
// OBSOLETE #define IS_SUB_SP(x) ((x & 0xffff) == 0x020f)
// OBSOLETE #define IS_PUSH_FP(x) (BIG ? (x == 0x93ea) : (x == 0x93fa))
// OBSOLETE 
// OBSOLETE /* work out how much local space is on the stack and
// OBSOLETE    return the pc pointing to the first push */
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE skip_adjust (CORE_ADDR pc, int *size)
// OBSOLETE {
// OBSOLETE   *size = 0;
// OBSOLETE 
// OBSOLETE   if (IS_PUSH_FP (read_memory_short (pc))
// OBSOLETE       && IS_MOV_SP_FP (read_memory_short (pc + 2)))
// OBSOLETE     {
// OBSOLETE       /* This is a function with an explict frame pointer */
// OBSOLETE       pc += 4;
// OBSOLETE       *size += 2;		/* remember the frame pointer */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* remember any stack adjustment */
// OBSOLETE   if (IS_SUB_SP (read_memory_short (pc)))
// OBSOLETE     {
// OBSOLETE       *size += read_memory_short (pc + 2);
// OBSOLETE       pc += 4;
// OBSOLETE     }
// OBSOLETE   return pc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static CORE_ADDR examine_frame (CORE_ADDR, CORE_ADDR * regs, CORE_ADDR);
// OBSOLETE static CORE_ADDR
// OBSOLETE examine_frame (CORE_ADDR pc, CORE_ADDR *regs, CORE_ADDR sp)
// OBSOLETE {
// OBSOLETE   int w = read_memory_short (pc);
// OBSOLETE   int offset = 0;
// OBSOLETE   int regno;
// OBSOLETE 
// OBSOLETE   for (regno = 0; regno < NUM_REGS; regno++)
// OBSOLETE     regs[regno] = 0;
// OBSOLETE 
// OBSOLETE   while (IS_PUSHW (w) || IS_PUSHL (w))
// OBSOLETE     {
// OBSOLETE       /* work out which register is being pushed to where */
// OBSOLETE       if (IS_PUSHL (w))
// OBSOLETE 	{
// OBSOLETE 	  regs[w & 0xf] = offset;
// OBSOLETE 	  regs[(w & 0xf) + 1] = offset + 2;
// OBSOLETE 	  offset += 4;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  regs[w & 0xf] = offset;
// OBSOLETE 	  offset += 2;
// OBSOLETE 	}
// OBSOLETE       pc += 2;
// OBSOLETE       w = read_memory_short (pc);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (IS_MOVE_FP (w))
// OBSOLETE     {
// OBSOLETE       /* We know the fp */
// OBSOLETE 
// OBSOLETE     }
// OBSOLETE   else if (IS_SUB_SP (w))
// OBSOLETE     {
// OBSOLETE       /* Subtracting a value from the sp, so were in a function
// OBSOLETE          which needs stack space for locals, but has no fp.  We fake up
// OBSOLETE          the values as if we had an fp */
// OBSOLETE       regs[FP_REGNUM] = sp;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* This one didn't have an fp, we'll fake it up */
// OBSOLETE       regs[SP_REGNUM] = sp;
// OBSOLETE     }
// OBSOLETE   /* stack pointer contains address of next frame */
// OBSOLETE   /*  regs[fp_regnum()] = fp; */
// OBSOLETE   regs[SP_REGNUM] = sp;
// OBSOLETE   return pc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE z8k_skip_prologue (CORE_ADDR start_pc)
// OBSOLETE {
// OBSOLETE   CORE_ADDR dummy[NUM_REGS];
// OBSOLETE 
// OBSOLETE   return examine_frame (start_pc, dummy, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE z8k_addr_bits_remove (CORE_ADDR addr)
// OBSOLETE {
// OBSOLETE   return (addr & PTR_MASK);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE read_memory_pointer (CORE_ADDR x)
// OBSOLETE {
// OBSOLETE   return read_memory_integer (ADDR_BITS_REMOVE (x), BIG ? 4 : 2);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE z8k_frame_chain (struct frame_info *thisframe)
// OBSOLETE {
// OBSOLETE   if (!inside_entry_file (get_frame_pc (thisframe)))
// OBSOLETE     {
// OBSOLETE       return read_memory_pointer (thisframe->frame);
// OBSOLETE     }
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Put here the code to store, into a struct frame_saved_regs,
// OBSOLETE    the addresses of the saved registers of frame described by FRAME_INFO.
// OBSOLETE    This includes special registers such as pc and fp saved in special
// OBSOLETE    ways in the stack frame.  sp is even more special:
// OBSOLETE    the address we return for it IS the sp for the next frame.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE z8k_frame_init_saved_regs (struct frame_info *frame_info)
// OBSOLETE {
// OBSOLETE   CORE_ADDR pc;
// OBSOLETE   int w;
// OBSOLETE 
// OBSOLETE   frame_saved_regs_zalloc (frame_info);
// OBSOLETE   pc = get_pc_function_start (get_frame_pc (frame_info));
// OBSOLETE 
// OBSOLETE   /* wander down the instruction stream */
// OBSOLETE   examine_frame (pc, frame_info->saved_regs, frame_info->frame);
// OBSOLETE 
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE z8k_push_dummy_frame (void)
// OBSOLETE {
// OBSOLETE   internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE gdb_print_insn_z8k (bfd_vma memaddr, disassemble_info *info)
// OBSOLETE {
// OBSOLETE   if (BIG)
// OBSOLETE     return print_insn_z8001 (memaddr, info);
// OBSOLETE   else
// OBSOLETE     return print_insn_z8002 (memaddr, info);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or
// OBSOLETE    is not the address of a valid instruction, the address of the next
// OBSOLETE    instruction beyond ADDR otherwise.  *PWORD1 receives the first word
// OBSOLETE    of the instruction. */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE NEXT_PROLOGUE_INSN (CORE_ADDR addr, CORE_ADDR lim, short *pword1)
// OBSOLETE {
// OBSOLETE   char buf[2];
// OBSOLETE   if (addr < lim + 8)
// OBSOLETE     {
// OBSOLETE       read_memory (addr, buf, 2);
// OBSOLETE       *pword1 = extract_signed_integer (buf, 2);
// OBSOLETE 
// OBSOLETE       return addr + 2;
// OBSOLETE     }
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE /* Put here the code to store, into a struct frame_saved_regs,
// OBSOLETE    the addresses of the saved registers of frame described by FRAME_INFO.
// OBSOLETE    This includes special registers such as pc and fp saved in special
// OBSOLETE    ways in the stack frame.  sp is even more special:
// OBSOLETE    the address we return for it IS the sp for the next frame.
// OBSOLETE 
// OBSOLETE    We cache the result of doing this in the frame_cache_obstack, since
// OBSOLETE    it is fairly expensive.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE frame_find_saved_regs (struct frame_info *fip, struct frame_saved_regs *fsrp)
// OBSOLETE {
// OBSOLETE   int locals;
// OBSOLETE   CORE_ADDR pc;
// OBSOLETE   CORE_ADDR adr;
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   memset (fsrp, 0, sizeof *fsrp);
// OBSOLETE 
// OBSOLETE   pc = skip_adjust (get_pc_function_start (get_frame_pc (fip)), &locals);
// OBSOLETE 
// OBSOLETE   {
// OBSOLETE     adr = get_frame_base (fip) - locals;
// OBSOLETE     for (i = 0; i < 8; i++)
// OBSOLETE       {
// OBSOLETE 	int word = read_memory_short (pc);
// OBSOLETE 
// OBSOLETE 	pc += 2;
// OBSOLETE 	if (IS_PUSHL (word))
// OBSOLETE 	  {
// OBSOLETE 	    fsrp->regs[word & 0xf] = adr;
// OBSOLETE 	    fsrp->regs[(word & 0xf) + 1] = adr - 2;
// OBSOLETE 	    adr -= 4;
// OBSOLETE 	  }
// OBSOLETE 	else if (IS_PUSHW (word))
// OBSOLETE 	  {
// OBSOLETE 	    fsrp->regs[word & 0xf] = adr;
// OBSOLETE 	    adr -= 2;
// OBSOLETE 	  }
// OBSOLETE 	else
// OBSOLETE 	  break;
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE   }
// OBSOLETE 
// OBSOLETE   fsrp->regs[PC_REGNUM] = fip->frame + 4;
// OBSOLETE   fsrp->regs[FP_REGNUM] = fip->frame;
// OBSOLETE 
// OBSOLETE }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE int
// OBSOLETE z8k_saved_pc_after_call (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   return ADDR_BITS_REMOVE
// OBSOLETE     (read_memory_integer (read_register (SP_REGNUM), PTR_SIZE));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE void
// OBSOLETE extract_return_value (struct type *type, char *regbuf, char *valbuf)
// OBSOLETE {
// OBSOLETE   int b;
// OBSOLETE   int len = TYPE_LENGTH (type);
// OBSOLETE 
// OBSOLETE   for (b = 0; b < len; b += 2)
// OBSOLETE     {
// OBSOLETE       int todo = len - b;
// OBSOLETE 
// OBSOLETE       if (todo > 2)
// OBSOLETE 	todo = 2;
// OBSOLETE       memcpy (valbuf + b, regbuf + b, todo);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE write_return_value (struct type *type, char *valbuf)
// OBSOLETE {
// OBSOLETE   int reg;
// OBSOLETE   int len;
// OBSOLETE 
// OBSOLETE   for (len = 0; len < TYPE_LENGTH (type); len += 2)
// OBSOLETE     deprecated_write_register_bytes (REGISTER_BYTE (len / 2 + 2),
// OBSOLETE 				     valbuf + len, 2);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
// OBSOLETE {
// OBSOLETE   write_register (2, addr);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE z8k_print_register_hook (int regno)
// OBSOLETE {
// OBSOLETE   if ((regno & 1) == 0 && regno < 16)
// OBSOLETE     {
// OBSOLETE       unsigned char l[4];
// OBSOLETE 
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno, l + 0);
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno + 1, l + 2);
// OBSOLETE       printf_unfiltered ("\t");
// OBSOLETE       printf_unfiltered ("0x%02x%02x%02x%02x", l[0], l[1], l[2], l[3]);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if ((regno & 3) == 0 && regno < 16)
// OBSOLETE     {
// OBSOLETE       unsigned char l[8];
// OBSOLETE 
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno, l + 0);
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno + 1, l + 2);
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno + 2, l + 4);
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno + 3, l + 6);
// OBSOLETE 
// OBSOLETE       printf_unfiltered ("\t");
// OBSOLETE       printf_unfiltered ("0x%02x%02x%02x%02x%02x%02x%02x%02x",
// OBSOLETE                          l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7]);
// OBSOLETE     }
// OBSOLETE   if (regno == 15)
// OBSOLETE     {
// OBSOLETE       unsigned short rval;
// OBSOLETE       int i;
// OBSOLETE 
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno, (char *) (&rval));
// OBSOLETE 
// OBSOLETE       printf_unfiltered ("\n");
// OBSOLETE       for (i = 0; i < 10; i += 2)
// OBSOLETE 	{
// OBSOLETE 	  printf_unfiltered ("(sp+%d=%04x)", i,
// OBSOLETE 			     (unsigned int)read_memory_short (rval + i));
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE z8k_print_registers_info (struct gdbarch *gdbarch,
// OBSOLETE 			  struct ui_file *file,
// OBSOLETE 			  struct frame_info *frame,
// OBSOLETE 			  int regnum, int print_all)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   const int numregs = NUM_REGS + NUM_PSEUDO_REGS;
// OBSOLETE   char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
// OBSOLETE   char *virtual_buffer = alloca (MAX_REGISTER_VIRTUAL_SIZE);
// OBSOLETE 
// OBSOLETE   for (i = 0; i < numregs; i++)
// OBSOLETE     {
// OBSOLETE       /* Decide between printing all regs, non-float / vector regs, or
// OBSOLETE          specific reg.  */
// OBSOLETE       if (regnum == -1)
// OBSOLETE 	{
// OBSOLETE 	  if (!print_all)
// OBSOLETE 	    {
// OBSOLETE 	      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
// OBSOLETE 		continue;
// OBSOLETE 	      if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)))
// OBSOLETE 		continue;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (i != regnum)
// OBSOLETE 	    continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* If the register name is empty, it is undefined for this
// OBSOLETE          processor, so don't display anything.  */
// OBSOLETE       if (REGISTER_NAME (i) == NULL || *(REGISTER_NAME (i)) == '\0')
// OBSOLETE 	continue;
// OBSOLETE 
// OBSOLETE       fputs_filtered (REGISTER_NAME (i), file);
// OBSOLETE       print_spaces_filtered (15 - strlen (REGISTER_NAME (i)), file);
// OBSOLETE 
// OBSOLETE       /* Get the data in raw format.  */
// OBSOLETE       if (! frame_register_read (frame, i, raw_buffer))
// OBSOLETE 	{
// OBSOLETE 	  fprintf_filtered (file, "*value not available*\n");
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* FIXME: cagney/2002-08-03: This code shouldn't be necessary.
// OBSOLETE          The function frame_register_read() should have returned the
// OBSOLETE          pre-cooked register so no conversion is necessary.  */
// OBSOLETE       /* Convert raw data to virtual format if necessary.  */
// OBSOLETE       if (REGISTER_CONVERTIBLE (i))
// OBSOLETE 	{
// OBSOLETE 	  REGISTER_CONVERT_TO_VIRTUAL (i, REGISTER_VIRTUAL_TYPE (i),
// OBSOLETE 				       raw_buffer, virtual_buffer);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  memcpy (virtual_buffer, raw_buffer,
// OBSOLETE 		  REGISTER_VIRTUAL_SIZE (i));
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* If virtual format is floating, print it that way, and in raw
// OBSOLETE          hex.  */
// OBSOLETE       if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
// OBSOLETE 	{
// OBSOLETE 	  int j;
// OBSOLETE 
// OBSOLETE 	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
// OBSOLETE 		     file, 0, 1, 0, Val_pretty_default);
// OBSOLETE 
// OBSOLETE 	  fprintf_filtered (file, "\t(raw 0x");
// OBSOLETE 	  for (j = 0; j < REGISTER_RAW_SIZE (i); j++)
// OBSOLETE 	    {
// OBSOLETE 	      int idx;
// OBSOLETE 	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
// OBSOLETE 		idx = j;
// OBSOLETE 	      else
// OBSOLETE 		idx = REGISTER_RAW_SIZE (i) - 1 - j;
// OBSOLETE 	      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
// OBSOLETE 	    }
// OBSOLETE 	  fprintf_filtered (file, ")");
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* Print the register in hex.  */
// OBSOLETE 	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
// OBSOLETE 		     file, 'x', 1, 0, Val_pretty_default);
// OBSOLETE           /* If not a vector register, print it also according to its
// OBSOLETE              natural format.  */
// OBSOLETE 	  if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)) == 0)
// OBSOLETE 	    {
// OBSOLETE 	      fprintf_filtered (file, "\t");
// OBSOLETE 	      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
// OBSOLETE 			 file, 0, 1, 0, Val_pretty_default);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Some z8k specific info.  */
// OBSOLETE       z8k_print_register_hook (i);
// OBSOLETE 
// OBSOLETE       fprintf_filtered (file, "\n");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE z8k_do_registers_info (int regnum, int all)
// OBSOLETE {
// OBSOLETE   z8k_print_registers_info (current_gdbarch, gdb_stdout,
// OBSOLETE 			    deprecated_selected_frame, regnum, all);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE z8k_pop_frame (void)
// OBSOLETE {
// OBSOLETE }
// OBSOLETE 
// OBSOLETE struct cmd_list_element *setmemorylist;
// OBSOLETE 
// OBSOLETE void
// OBSOLETE z8k_set_pointer_size (int newsize)
// OBSOLETE {
// OBSOLETE   static int oldsize = 0;
// OBSOLETE 
// OBSOLETE   if (oldsize != newsize)
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("pointer size set to %d bits\n", newsize);
// OBSOLETE       oldsize = newsize;
// OBSOLETE       if (newsize == 32)
// OBSOLETE 	{
// OBSOLETE 	  BIG = 1;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  BIG = 0;
// OBSOLETE 	}
// OBSOLETE       /* FIXME: This code should be using the GDBARCH framework to
// OBSOLETE          handle changed type sizes.  If this problem is ever fixed
// OBSOLETE          (the direct reference to _initialize_gdbtypes() below
// OBSOLETE          eliminated) then Makefile.in should be updated so that
// OBSOLETE          z8k-tdep.c is again compiled with -Werror. */
// OBSOLETE       _initialize_gdbtypes ();
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE segmented_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   z8k_set_pointer_size (32);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE unsegmented_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   z8k_set_pointer_size (16);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE set_memory (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   printf_unfiltered ("\"set memory\" must be followed by the name of a memory subcommand.\n");
// OBSOLETE   help_list (setmemorylist, "set memory ", -1, gdb_stdout);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_z8ktdep (void)
// OBSOLETE {
// OBSOLETE   tm_print_insn = gdb_print_insn_z8k;
// OBSOLETE 
// OBSOLETE   add_prefix_cmd ("memory", no_class, set_memory,
// OBSOLETE 		  "set the memory model", &setmemorylist, "set memory ", 0,
// OBSOLETE 		  &setlist);
// OBSOLETE   add_cmd ("segmented", class_support, segmented_command,
// OBSOLETE 	   "Set segmented memory model.", &setmemorylist);
// OBSOLETE   add_cmd ("unsegmented", class_support, unsegmented_command,
// OBSOLETE 	   "Set unsegmented memory model.", &setmemorylist);
// OBSOLETE 
// OBSOLETE }
@


1.18
log
@2003-02-04  Andrew Cagney  <ac131313@@redhat.com>

	* NEWS: Mention that the z8k-zilog-none is obsolete.
	* MAINTAINERS: Mark z8k as obsolete.
	* configure.tgt: Obsolete the z8k-*-coff* target.
	* config/z8k/z8k.mt: Obsolete file.
	* config/z8k/tm-z8k.h: Obsolete file.
	* z8k-tdep.c: Obsolete file.
@
text
@@


1.17
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@d1 535
a535 535
/* Target-machine dependent code for Zilog Z8000, for GDB.

   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
   2002, 2003 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/*
   Contributed by Steve Chamberlain
   sac@@cygnus.com
 */

#include "defs.h"
#include "frame.h"
#include "symtab.h"
#include "gdbcmd.h"
#include "gdbtypes.h"
#include "dis-asm.h"
#include "gdbcore.h"
#include "regcache.h"

#include "value.h" /* For read_register() */


static int read_memory_pointer (CORE_ADDR x);

/* Return the saved PC from this frame.

   If the frame has a memory copy of SRP_REGNUM, use that.  If not,
   just use the register SRP_REGNUM itself.  */

CORE_ADDR
z8k_frame_saved_pc (struct frame_info *frame)
{
  return read_memory_pointer (frame->frame + (BIG ? 4 : 2));
}

#define IS_PUSHL(x) (BIG ? ((x & 0xfff0) == 0x91e0):((x & 0xfff0) == 0x91F0))
#define IS_PUSHW(x) (BIG ? ((x & 0xfff0) == 0x93e0):((x & 0xfff0)==0x93f0))
#define IS_MOVE_FP(x) (BIG ? x == 0xa1ea : x == 0xa1fa)
#define IS_MOV_SP_FP(x) (BIG ? x == 0x94ea : x == 0x0d76)
#define IS_SUB2_SP(x) (x==0x1b87)
#define IS_MOVK_R5(x) (x==0x7905)
#define IS_SUB_SP(x) ((x & 0xffff) == 0x020f)
#define IS_PUSH_FP(x) (BIG ? (x == 0x93ea) : (x == 0x93fa))

/* work out how much local space is on the stack and
   return the pc pointing to the first push */

static CORE_ADDR
skip_adjust (CORE_ADDR pc, int *size)
{
  *size = 0;

  if (IS_PUSH_FP (read_memory_short (pc))
      && IS_MOV_SP_FP (read_memory_short (pc + 2)))
    {
      /* This is a function with an explict frame pointer */
      pc += 4;
      *size += 2;		/* remember the frame pointer */
    }

  /* remember any stack adjustment */
  if (IS_SUB_SP (read_memory_short (pc)))
    {
      *size += read_memory_short (pc + 2);
      pc += 4;
    }
  return pc;
}

static CORE_ADDR examine_frame (CORE_ADDR, CORE_ADDR * regs, CORE_ADDR);
static CORE_ADDR
examine_frame (CORE_ADDR pc, CORE_ADDR *regs, CORE_ADDR sp)
{
  int w = read_memory_short (pc);
  int offset = 0;
  int regno;

  for (regno = 0; regno < NUM_REGS; regno++)
    regs[regno] = 0;

  while (IS_PUSHW (w) || IS_PUSHL (w))
    {
      /* work out which register is being pushed to where */
      if (IS_PUSHL (w))
	{
	  regs[w & 0xf] = offset;
	  regs[(w & 0xf) + 1] = offset + 2;
	  offset += 4;
	}
      else
	{
	  regs[w & 0xf] = offset;
	  offset += 2;
	}
      pc += 2;
      w = read_memory_short (pc);
    }

  if (IS_MOVE_FP (w))
    {
      /* We know the fp */

    }
  else if (IS_SUB_SP (w))
    {
      /* Subtracting a value from the sp, so were in a function
         which needs stack space for locals, but has no fp.  We fake up
         the values as if we had an fp */
      regs[FP_REGNUM] = sp;
    }
  else
    {
      /* This one didn't have an fp, we'll fake it up */
      regs[SP_REGNUM] = sp;
    }
  /* stack pointer contains address of next frame */
  /*  regs[fp_regnum()] = fp; */
  regs[SP_REGNUM] = sp;
  return pc;
}

CORE_ADDR
z8k_skip_prologue (CORE_ADDR start_pc)
{
  CORE_ADDR dummy[NUM_REGS];

  return examine_frame (start_pc, dummy, 0);
}

CORE_ADDR
z8k_addr_bits_remove (CORE_ADDR addr)
{
  return (addr & PTR_MASK);
}

static int
read_memory_pointer (CORE_ADDR x)
{
  return read_memory_integer (ADDR_BITS_REMOVE (x), BIG ? 4 : 2);
}

CORE_ADDR
z8k_frame_chain (struct frame_info *thisframe)
{
  if (!inside_entry_file (get_frame_pc (thisframe)))
    {
      return read_memory_pointer (thisframe->frame);
    }
  return 0;
}

/* Put here the code to store, into a struct frame_saved_regs,
   the addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.  */

void
z8k_frame_init_saved_regs (struct frame_info *frame_info)
{
  CORE_ADDR pc;
  int w;

  frame_saved_regs_zalloc (frame_info);
  pc = get_pc_function_start (get_frame_pc (frame_info));

  /* wander down the instruction stream */
  examine_frame (pc, frame_info->saved_regs, frame_info->frame);

}

void
z8k_push_dummy_frame (void)
{
  internal_error (__FILE__, __LINE__, "failed internal consistency check");
}

int
gdb_print_insn_z8k (bfd_vma memaddr, disassemble_info *info)
{
  if (BIG)
    return print_insn_z8001 (memaddr, info);
  else
    return print_insn_z8002 (memaddr, info);
}

/* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or
   is not the address of a valid instruction, the address of the next
   instruction beyond ADDR otherwise.  *PWORD1 receives the first word
   of the instruction. */

CORE_ADDR
NEXT_PROLOGUE_INSN (CORE_ADDR addr, CORE_ADDR lim, short *pword1)
{
  char buf[2];
  if (addr < lim + 8)
    {
      read_memory (addr, buf, 2);
      *pword1 = extract_signed_integer (buf, 2);

      return addr + 2;
    }
  return 0;
}

#if 0
/* Put here the code to store, into a struct frame_saved_regs,
   the addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.

   We cache the result of doing this in the frame_cache_obstack, since
   it is fairly expensive.  */

void
frame_find_saved_regs (struct frame_info *fip, struct frame_saved_regs *fsrp)
{
  int locals;
  CORE_ADDR pc;
  CORE_ADDR adr;
  int i;

  memset (fsrp, 0, sizeof *fsrp);

  pc = skip_adjust (get_pc_function_start (get_frame_pc (fip)), &locals);

  {
    adr = get_frame_base (fip) - locals;
    for (i = 0; i < 8; i++)
      {
	int word = read_memory_short (pc);

	pc += 2;
	if (IS_PUSHL (word))
	  {
	    fsrp->regs[word & 0xf] = adr;
	    fsrp->regs[(word & 0xf) + 1] = adr - 2;
	    adr -= 4;
	  }
	else if (IS_PUSHW (word))
	  {
	    fsrp->regs[word & 0xf] = adr;
	    adr -= 2;
	  }
	else
	  break;
      }

  }

  fsrp->regs[PC_REGNUM] = fip->frame + 4;
  fsrp->regs[FP_REGNUM] = fip->frame;

}
#endif

int
z8k_saved_pc_after_call (struct frame_info *frame)
{
  return ADDR_BITS_REMOVE
    (read_memory_integer (read_register (SP_REGNUM), PTR_SIZE));
}


void
extract_return_value (struct type *type, char *regbuf, char *valbuf)
{
  int b;
  int len = TYPE_LENGTH (type);

  for (b = 0; b < len; b += 2)
    {
      int todo = len - b;

      if (todo > 2)
	todo = 2;
      memcpy (valbuf + b, regbuf + b, todo);
    }
}

void
write_return_value (struct type *type, char *valbuf)
{
  int reg;
  int len;

  for (len = 0; len < TYPE_LENGTH (type); len += 2)
    deprecated_write_register_bytes (REGISTER_BYTE (len / 2 + 2),
				     valbuf + len, 2);
}

void
store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  write_register (2, addr);
}


static void
z8k_print_register_hook (int regno)
{
  if ((regno & 1) == 0 && regno < 16)
    {
      unsigned char l[4];

      frame_register_read (deprecated_selected_frame, regno, l + 0);
      frame_register_read (deprecated_selected_frame, regno + 1, l + 2);
      printf_unfiltered ("\t");
      printf_unfiltered ("0x%02x%02x%02x%02x", l[0], l[1], l[2], l[3]);
    }

  if ((regno & 3) == 0 && regno < 16)
    {
      unsigned char l[8];

      frame_register_read (deprecated_selected_frame, regno, l + 0);
      frame_register_read (deprecated_selected_frame, regno + 1, l + 2);
      frame_register_read (deprecated_selected_frame, regno + 2, l + 4);
      frame_register_read (deprecated_selected_frame, regno + 3, l + 6);

      printf_unfiltered ("\t");
      printf_unfiltered ("0x%02x%02x%02x%02x%02x%02x%02x%02x",
                         l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7]);
    }
  if (regno == 15)
    {
      unsigned short rval;
      int i;

      frame_register_read (deprecated_selected_frame, regno, (char *) (&rval));

      printf_unfiltered ("\n");
      for (i = 0; i < 10; i += 2)
	{
	  printf_unfiltered ("(sp+%d=%04x)", i,
			     (unsigned int)read_memory_short (rval + i));
	}
    }
}

static void
z8k_print_registers_info (struct gdbarch *gdbarch,
			  struct ui_file *file,
			  struct frame_info *frame,
			  int regnum, int print_all)
{
  int i;
  const int numregs = NUM_REGS + NUM_PSEUDO_REGS;
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
  char *virtual_buffer = alloca (MAX_REGISTER_VIRTUAL_SIZE);

  for (i = 0; i < numregs; i++)
    {
      /* Decide between printing all regs, non-float / vector regs, or
         specific reg.  */
      if (regnum == -1)
	{
	  if (!print_all)
	    {
	      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
		continue;
	      if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)))
		continue;
	    }
	}
      else
	{
	  if (i != regnum)
	    continue;
	}

      /* If the register name is empty, it is undefined for this
         processor, so don't display anything.  */
      if (REGISTER_NAME (i) == NULL || *(REGISTER_NAME (i)) == '\0')
	continue;

      fputs_filtered (REGISTER_NAME (i), file);
      print_spaces_filtered (15 - strlen (REGISTER_NAME (i)), file);

      /* Get the data in raw format.  */
      if (! frame_register_read (frame, i, raw_buffer))
	{
	  fprintf_filtered (file, "*value not available*\n");
	  continue;
	}

      /* FIXME: cagney/2002-08-03: This code shouldn't be necessary.
         The function frame_register_read() should have returned the
         pre-cooked register so no conversion is necessary.  */
      /* Convert raw data to virtual format if necessary.  */
      if (REGISTER_CONVERTIBLE (i))
	{
	  REGISTER_CONVERT_TO_VIRTUAL (i, REGISTER_VIRTUAL_TYPE (i),
				       raw_buffer, virtual_buffer);
	}
      else
	{
	  memcpy (virtual_buffer, raw_buffer,
		  REGISTER_VIRTUAL_SIZE (i));
	}

      /* If virtual format is floating, print it that way, and in raw
         hex.  */
      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
	{
	  int j;

	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 0, 1, 0, Val_pretty_default);

	  fprintf_filtered (file, "\t(raw 0x");
	  for (j = 0; j < REGISTER_RAW_SIZE (i); j++)
	    {
	      int idx;
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		idx = j;
	      else
		idx = REGISTER_RAW_SIZE (i) - 1 - j;
	      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
	    }
	  fprintf_filtered (file, ")");
	}
      else
	{
	  /* Print the register in hex.  */
	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 'x', 1, 0, Val_pretty_default);
          /* If not a vector register, print it also according to its
             natural format.  */
	  if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)) == 0)
	    {
	      fprintf_filtered (file, "\t");
	      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
			 file, 0, 1, 0, Val_pretty_default);
	    }
	}

      /* Some z8k specific info.  */
      z8k_print_register_hook (i);

      fprintf_filtered (file, "\n");
    }
}

void
z8k_do_registers_info (int regnum, int all)
{
  z8k_print_registers_info (current_gdbarch, gdb_stdout,
			    deprecated_selected_frame, regnum, all);
}

void
z8k_pop_frame (void)
{
}

struct cmd_list_element *setmemorylist;

void
z8k_set_pointer_size (int newsize)
{
  static int oldsize = 0;

  if (oldsize != newsize)
    {
      printf_unfiltered ("pointer size set to %d bits\n", newsize);
      oldsize = newsize;
      if (newsize == 32)
	{
	  BIG = 1;
	}
      else
	{
	  BIG = 0;
	}
      /* FIXME: This code should be using the GDBARCH framework to
         handle changed type sizes.  If this problem is ever fixed
         (the direct reference to _initialize_gdbtypes() below
         eliminated) then Makefile.in should be updated so that
         z8k-tdep.c is again compiled with -Werror. */
      _initialize_gdbtypes ();
    }
}

static void
segmented_command (char *args, int from_tty)
{
  z8k_set_pointer_size (32);
}

static void
unsegmented_command (char *args, int from_tty)
{
  z8k_set_pointer_size (16);
}

static void
set_memory (char *args, int from_tty)
{
  printf_unfiltered ("\"set memory\" must be followed by the name of a memory subcommand.\n");
  help_list (setmemorylist, "set memory ", -1, gdb_stdout);
}

void
_initialize_z8ktdep (void)
{
  tm_print_insn = gdb_print_insn_z8k;

  add_prefix_cmd ("memory", no_class, set_memory,
		  "set the memory model", &setmemorylist, "set memory ", 0,
		  &setlist);
  add_cmd ("segmented", class_support, segmented_command,
	   "Set segmented memory model.", &setmemorylist);
  add_cmd ("unsegmented", class_support, unsegmented_command,
	   "Set unsegmented memory model.", &setmemorylist);

}
@


1.16
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c: Use get_frame_pc and deprecated_update_frame_pc_hack
	frame accessor methods.
	* alpha-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Ditto.
	* s390-tdep.c, sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* z8k-tdep.c: Ditto.
@
text
@d4 1
a4 1
   2002 Free Software Foundation, Inc.
@


1.15
log
@2002-12-08  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (INIT_FRAME_PC_FIRST, INIT_FRAME_PC_DEFAULT): Convert
	to pure functions.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Explictly assign prev's pc with value
	returned by INIT_FRAME_PC_FIRST and INIT_EXTRA_FRAME_INFO.

	* arch-utils.h (init_frame_pc_default, init_frame_pc_noop): Change
	declaration to a function returning a CORE_ADDR.
	* x86-64-tdep.h (x86_64_init_frame_pc): Ditto.
	* arch-utils.c (init_frame_pc_noop): Return the PC value.
	(init_frame_pc_default): Ditto.
	* x86-64-linux-tdep.c (x86_64_init_frame_pc): Ditto.
	* s390-tdep.c (s390_init_frame_pc_first): Ditto.
	* mips-tdep.c (mips_init_frame_pc_first): Ditto.
	* dwarf2cfi.h (cfi_init_frame_pc): Ditto.
	* dwarf2cfi.c (cfi_init_frame_pc): Ditto.
	* alpha-tdep.c (alpha_init_frame_pc_first): Ditto.

	* i386-interix-tdep.c (i386_interix_init_abi): Set init_frame_pc
	to init_frame_pc_noop.
	(i386_interix_init_frame_pc): Delete function.
	* z8k-tdep.c (init_frame_pc): Delete function.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC): Define as init_frame_pc_noop.
	(INIT_FRAME_PC_FIRST): Ditto.
	* config/mn10200/tm-mn10200.h (INIT_FRAME_PC): Ditto.
	(INIT_FRAME_PC_FIRST): Ditto.
	* config/sparc/tm-sparc.h (INIT_FRAME_PC): Ditto.
	* config/rs6000/tm-rs6000.h (INIT_FRAME_PC): Redefine as
	init_frame_pc_noop.
	(INIT_FRAME_PC_FIRST): Convert to an expression.
	* config/sparc/tm-sparc.h (INIT_FRAME_PC_FIRST): Ditto.
@
text
@d162 1
a162 1
  if (!inside_entry_file (thisframe->pc))
d182 1
a182 1
  pc = get_pc_function_start (frame_info->pc);
d243 1
a243 1
  pc = skip_adjust (get_pc_function_start (fip->pc), &locals);
@


1.14
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@a168 6
void
init_frame_pc (void)
{
  internal_error (__FILE__, __LINE__, "failed internal consistency check");
}

@


1.13
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@d330 2
a331 2
      frame_register_read (selected_frame, regno, l + 0);
      frame_register_read (selected_frame, regno + 1, l + 2);
d340 4
a343 4
      frame_register_read (selected_frame, regno, l + 0);
      frame_register_read (selected_frame, regno + 1, l + 2);
      frame_register_read (selected_frame, regno + 2, l + 4);
      frame_register_read (selected_frame, regno + 3, l + 6);
d354 1
a354 1
      frame_register_read (selected_frame, regno, (char *) (&rval));
d472 2
a473 2
  z8k_print_registers_info (current_gdbarch, gdb_stdout, selected_frame,
			    regnum, all);
@


1.12
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@d252 1
a252 1
    adr = FRAME_FP (fip) - locals;
@


1.11
log
@2002-10-31  Andrew Cagney  <cagney@@redhat.com>

	* z8k-tdep.c (z8k_print_register_hook): Make static.
	(z8k_print_registers_info): New static function, clone of
	infcmd.c's default_print_registers_info.
	(z8k_do_registers_info): New function.  Wrap
	z8k_print_registers_info.
	* config/z8k/tm-z8k.h: Update copyright.
	(PRINT_REGISTER_HOOK): Delete macro.
	(z8k_print_register_hook): Delete declaration.
	(DEPRECATED_DO_REGISTERS_INFO): Define.
	(z8k_do_registers_info): Declare.
@
text
@d312 2
a313 1
    write_register_bytes (REGISTER_BYTE (len / 2 + 2), valbuf + len, 2);
@


1.10
log
@2002-07-26  Andrew Cagney  <ac131313@@redhat.com>

* z8k-tdep.c: Do not include "obstack.h".
* h8300-tdep.c, h8500-tdep.c: Ditto.
* m68hc11-tdep.c, sh-tdep.c: Ditto.
* valprint.c, v850-tdep.c: Ditto.
* d10v-tdep.c, mn10300-tdep.c: Ditto.
* mn10200-tdep.c: Ditto.

* Makefile.in (z8k-tdep.o): Update dependencies.
(m68hc11-tdep.o, valprint.o): Ditto.
(v850-tdep.o, d10v-tdep.o): Ditto.
(mn10300-tdep.o, sparc-tdep.o): Ditto.
(sh-tdep.o, h8500-tdep.o, h8300-tdep.o): Ditto.
(m32r-tdep.o, mn10200-tdep.o): Specify dependencies.
(sh_opc_h, gdb_sim_sh_h): Define.
(elf_sh_h, elf_bfd_h): Define.
(opcode_m68hc11_h): Define.
(OPCODES_SRC, OPCODES_DIR): define.
(OPCODES): Use $(OPCODES_DIR).
(gdb_sim_d10v_h): Rename sim_d10v_h.
(gdb_sim_arm_h): Rename sim_arm_h.
@
text
@d322 1
a322 1
void
d362 47
d410 63
@


1.10.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.10.8.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d312 1
a312 2
    deprecated_write_register_bytes (REGISTER_BYTE (len / 2 + 2),
				     valbuf + len, 2);
d322 1
a322 1
static void
a361 1
}
a362 109
static void
z8k_print_registers_info (struct gdbarch *gdbarch,
			  struct ui_file *file,
			  struct frame_info *frame,
			  int regnum, int print_all)
{
  int i;
  const int numregs = NUM_REGS + NUM_PSEUDO_REGS;
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
  char *virtual_buffer = alloca (MAX_REGISTER_VIRTUAL_SIZE);

  for (i = 0; i < numregs; i++)
    {
      /* Decide between printing all regs, non-float / vector regs, or
         specific reg.  */
      if (regnum == -1)
	{
	  if (!print_all)
	    {
	      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
		continue;
	      if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)))
		continue;
	    }
	}
      else
	{
	  if (i != regnum)
	    continue;
	}

      /* If the register name is empty, it is undefined for this
         processor, so don't display anything.  */
      if (REGISTER_NAME (i) == NULL || *(REGISTER_NAME (i)) == '\0')
	continue;

      fputs_filtered (REGISTER_NAME (i), file);
      print_spaces_filtered (15 - strlen (REGISTER_NAME (i)), file);

      /* Get the data in raw format.  */
      if (! frame_register_read (frame, i, raw_buffer))
	{
	  fprintf_filtered (file, "*value not available*\n");
	  continue;
	}

      /* FIXME: cagney/2002-08-03: This code shouldn't be necessary.
         The function frame_register_read() should have returned the
         pre-cooked register so no conversion is necessary.  */
      /* Convert raw data to virtual format if necessary.  */
      if (REGISTER_CONVERTIBLE (i))
	{
	  REGISTER_CONVERT_TO_VIRTUAL (i, REGISTER_VIRTUAL_TYPE (i),
				       raw_buffer, virtual_buffer);
	}
      else
	{
	  memcpy (virtual_buffer, raw_buffer,
		  REGISTER_VIRTUAL_SIZE (i));
	}

      /* If virtual format is floating, print it that way, and in raw
         hex.  */
      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
	{
	  int j;

	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 0, 1, 0, Val_pretty_default);

	  fprintf_filtered (file, "\t(raw 0x");
	  for (j = 0; j < REGISTER_RAW_SIZE (i); j++)
	    {
	      int idx;
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		idx = j;
	      else
		idx = REGISTER_RAW_SIZE (i) - 1 - j;
	      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
	    }
	  fprintf_filtered (file, ")");
	}
      else
	{
	  /* Print the register in hex.  */
	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 'x', 1, 0, Val_pretty_default);
          /* If not a vector register, print it also according to its
             natural format.  */
	  if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)) == 0)
	    {
	      fprintf_filtered (file, "\t");
	      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
			 file, 0, 1, 0, Val_pretty_default);
	    }
	}

      /* Some z8k specific info.  */
      z8k_print_register_hook (i);

      fprintf_filtered (file, "\n");
    }
}

void
z8k_do_registers_info (int regnum, int all)
{
  z8k_print_registers_info (current_gdbarch, gdb_stdout, selected_frame,
			    regnum, all);
@


1.10.8.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d169 6
d252 1
a252 1
    adr = get_frame_base (fip) - locals;
d330 2
a331 2
      frame_register_read (deprecated_selected_frame, regno, l + 0);
      frame_register_read (deprecated_selected_frame, regno + 1, l + 2);
d340 4
a343 4
      frame_register_read (deprecated_selected_frame, regno, l + 0);
      frame_register_read (deprecated_selected_frame, regno + 1, l + 2);
      frame_register_read (deprecated_selected_frame, regno + 2, l + 4);
      frame_register_read (deprecated_selected_frame, regno + 3, l + 6);
d354 1
a354 1
      frame_register_read (deprecated_selected_frame, regno, (char *) (&rval));
d472 2
a473 2
  z8k_print_registers_info (current_gdbarch, gdb_stdout,
			    deprecated_selected_frame, regnum, all);
@


1.10.8.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d1 535
a535 535
// OBSOLETE /* Target-machine dependent code for Zilog Z8000, for GDB.
// OBSOLETE 
// OBSOLETE    Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
// OBSOLETE    2002, 2003 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE    Contributed by Steve Chamberlain
// OBSOLETE    sac@@cygnus.com
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "gdbcmd.h"
// OBSOLETE #include "gdbtypes.h"
// OBSOLETE #include "dis-asm.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #include "value.h" /* For read_register() */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static int read_memory_pointer (CORE_ADDR x);
// OBSOLETE 
// OBSOLETE /* Return the saved PC from this frame.
// OBSOLETE 
// OBSOLETE    If the frame has a memory copy of SRP_REGNUM, use that.  If not,
// OBSOLETE    just use the register SRP_REGNUM itself.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE z8k_frame_saved_pc (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   return read_memory_pointer (frame->frame + (BIG ? 4 : 2));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #define IS_PUSHL(x) (BIG ? ((x & 0xfff0) == 0x91e0):((x & 0xfff0) == 0x91F0))
// OBSOLETE #define IS_PUSHW(x) (BIG ? ((x & 0xfff0) == 0x93e0):((x & 0xfff0)==0x93f0))
// OBSOLETE #define IS_MOVE_FP(x) (BIG ? x == 0xa1ea : x == 0xa1fa)
// OBSOLETE #define IS_MOV_SP_FP(x) (BIG ? x == 0x94ea : x == 0x0d76)
// OBSOLETE #define IS_SUB2_SP(x) (x==0x1b87)
// OBSOLETE #define IS_MOVK_R5(x) (x==0x7905)
// OBSOLETE #define IS_SUB_SP(x) ((x & 0xffff) == 0x020f)
// OBSOLETE #define IS_PUSH_FP(x) (BIG ? (x == 0x93ea) : (x == 0x93fa))
// OBSOLETE 
// OBSOLETE /* work out how much local space is on the stack and
// OBSOLETE    return the pc pointing to the first push */
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE skip_adjust (CORE_ADDR pc, int *size)
// OBSOLETE {
// OBSOLETE   *size = 0;
// OBSOLETE 
// OBSOLETE   if (IS_PUSH_FP (read_memory_short (pc))
// OBSOLETE       && IS_MOV_SP_FP (read_memory_short (pc + 2)))
// OBSOLETE     {
// OBSOLETE       /* This is a function with an explict frame pointer */
// OBSOLETE       pc += 4;
// OBSOLETE       *size += 2;		/* remember the frame pointer */
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* remember any stack adjustment */
// OBSOLETE   if (IS_SUB_SP (read_memory_short (pc)))
// OBSOLETE     {
// OBSOLETE       *size += read_memory_short (pc + 2);
// OBSOLETE       pc += 4;
// OBSOLETE     }
// OBSOLETE   return pc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static CORE_ADDR examine_frame (CORE_ADDR, CORE_ADDR * regs, CORE_ADDR);
// OBSOLETE static CORE_ADDR
// OBSOLETE examine_frame (CORE_ADDR pc, CORE_ADDR *regs, CORE_ADDR sp)
// OBSOLETE {
// OBSOLETE   int w = read_memory_short (pc);
// OBSOLETE   int offset = 0;
// OBSOLETE   int regno;
// OBSOLETE 
// OBSOLETE   for (regno = 0; regno < NUM_REGS; regno++)
// OBSOLETE     regs[regno] = 0;
// OBSOLETE 
// OBSOLETE   while (IS_PUSHW (w) || IS_PUSHL (w))
// OBSOLETE     {
// OBSOLETE       /* work out which register is being pushed to where */
// OBSOLETE       if (IS_PUSHL (w))
// OBSOLETE 	{
// OBSOLETE 	  regs[w & 0xf] = offset;
// OBSOLETE 	  regs[(w & 0xf) + 1] = offset + 2;
// OBSOLETE 	  offset += 4;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  regs[w & 0xf] = offset;
// OBSOLETE 	  offset += 2;
// OBSOLETE 	}
// OBSOLETE       pc += 2;
// OBSOLETE       w = read_memory_short (pc);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (IS_MOVE_FP (w))
// OBSOLETE     {
// OBSOLETE       /* We know the fp */
// OBSOLETE 
// OBSOLETE     }
// OBSOLETE   else if (IS_SUB_SP (w))
// OBSOLETE     {
// OBSOLETE       /* Subtracting a value from the sp, so were in a function
// OBSOLETE          which needs stack space for locals, but has no fp.  We fake up
// OBSOLETE          the values as if we had an fp */
// OBSOLETE       regs[FP_REGNUM] = sp;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* This one didn't have an fp, we'll fake it up */
// OBSOLETE       regs[SP_REGNUM] = sp;
// OBSOLETE     }
// OBSOLETE   /* stack pointer contains address of next frame */
// OBSOLETE   /*  regs[fp_regnum()] = fp; */
// OBSOLETE   regs[SP_REGNUM] = sp;
// OBSOLETE   return pc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE z8k_skip_prologue (CORE_ADDR start_pc)
// OBSOLETE {
// OBSOLETE   CORE_ADDR dummy[NUM_REGS];
// OBSOLETE 
// OBSOLETE   return examine_frame (start_pc, dummy, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE z8k_addr_bits_remove (CORE_ADDR addr)
// OBSOLETE {
// OBSOLETE   return (addr & PTR_MASK);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE read_memory_pointer (CORE_ADDR x)
// OBSOLETE {
// OBSOLETE   return read_memory_integer (ADDR_BITS_REMOVE (x), BIG ? 4 : 2);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE z8k_frame_chain (struct frame_info *thisframe)
// OBSOLETE {
// OBSOLETE   if (!inside_entry_file (get_frame_pc (thisframe)))
// OBSOLETE     {
// OBSOLETE       return read_memory_pointer (thisframe->frame);
// OBSOLETE     }
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Put here the code to store, into a struct frame_saved_regs,
// OBSOLETE    the addresses of the saved registers of frame described by FRAME_INFO.
// OBSOLETE    This includes special registers such as pc and fp saved in special
// OBSOLETE    ways in the stack frame.  sp is even more special:
// OBSOLETE    the address we return for it IS the sp for the next frame.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE z8k_frame_init_saved_regs (struct frame_info *frame_info)
// OBSOLETE {
// OBSOLETE   CORE_ADDR pc;
// OBSOLETE   int w;
// OBSOLETE 
// OBSOLETE   frame_saved_regs_zalloc (frame_info);
// OBSOLETE   pc = get_pc_function_start (get_frame_pc (frame_info));
// OBSOLETE 
// OBSOLETE   /* wander down the instruction stream */
// OBSOLETE   examine_frame (pc, frame_info->saved_regs, frame_info->frame);
// OBSOLETE 
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE z8k_push_dummy_frame (void)
// OBSOLETE {
// OBSOLETE   internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE gdb_print_insn_z8k (bfd_vma memaddr, disassemble_info *info)
// OBSOLETE {
// OBSOLETE   if (BIG)
// OBSOLETE     return print_insn_z8001 (memaddr, info);
// OBSOLETE   else
// OBSOLETE     return print_insn_z8002 (memaddr, info);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or
// OBSOLETE    is not the address of a valid instruction, the address of the next
// OBSOLETE    instruction beyond ADDR otherwise.  *PWORD1 receives the first word
// OBSOLETE    of the instruction. */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE NEXT_PROLOGUE_INSN (CORE_ADDR addr, CORE_ADDR lim, short *pword1)
// OBSOLETE {
// OBSOLETE   char buf[2];
// OBSOLETE   if (addr < lim + 8)
// OBSOLETE     {
// OBSOLETE       read_memory (addr, buf, 2);
// OBSOLETE       *pword1 = extract_signed_integer (buf, 2);
// OBSOLETE 
// OBSOLETE       return addr + 2;
// OBSOLETE     }
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE /* Put here the code to store, into a struct frame_saved_regs,
// OBSOLETE    the addresses of the saved registers of frame described by FRAME_INFO.
// OBSOLETE    This includes special registers such as pc and fp saved in special
// OBSOLETE    ways in the stack frame.  sp is even more special:
// OBSOLETE    the address we return for it IS the sp for the next frame.
// OBSOLETE 
// OBSOLETE    We cache the result of doing this in the frame_cache_obstack, since
// OBSOLETE    it is fairly expensive.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE frame_find_saved_regs (struct frame_info *fip, struct frame_saved_regs *fsrp)
// OBSOLETE {
// OBSOLETE   int locals;
// OBSOLETE   CORE_ADDR pc;
// OBSOLETE   CORE_ADDR adr;
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   memset (fsrp, 0, sizeof *fsrp);
// OBSOLETE 
// OBSOLETE   pc = skip_adjust (get_pc_function_start (get_frame_pc (fip)), &locals);
// OBSOLETE 
// OBSOLETE   {
// OBSOLETE     adr = get_frame_base (fip) - locals;
// OBSOLETE     for (i = 0; i < 8; i++)
// OBSOLETE       {
// OBSOLETE 	int word = read_memory_short (pc);
// OBSOLETE 
// OBSOLETE 	pc += 2;
// OBSOLETE 	if (IS_PUSHL (word))
// OBSOLETE 	  {
// OBSOLETE 	    fsrp->regs[word & 0xf] = adr;
// OBSOLETE 	    fsrp->regs[(word & 0xf) + 1] = adr - 2;
// OBSOLETE 	    adr -= 4;
// OBSOLETE 	  }
// OBSOLETE 	else if (IS_PUSHW (word))
// OBSOLETE 	  {
// OBSOLETE 	    fsrp->regs[word & 0xf] = adr;
// OBSOLETE 	    adr -= 2;
// OBSOLETE 	  }
// OBSOLETE 	else
// OBSOLETE 	  break;
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE   }
// OBSOLETE 
// OBSOLETE   fsrp->regs[PC_REGNUM] = fip->frame + 4;
// OBSOLETE   fsrp->regs[FP_REGNUM] = fip->frame;
// OBSOLETE 
// OBSOLETE }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE int
// OBSOLETE z8k_saved_pc_after_call (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   return ADDR_BITS_REMOVE
// OBSOLETE     (read_memory_integer (read_register (SP_REGNUM), PTR_SIZE));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE void
// OBSOLETE extract_return_value (struct type *type, char *regbuf, char *valbuf)
// OBSOLETE {
// OBSOLETE   int b;
// OBSOLETE   int len = TYPE_LENGTH (type);
// OBSOLETE 
// OBSOLETE   for (b = 0; b < len; b += 2)
// OBSOLETE     {
// OBSOLETE       int todo = len - b;
// OBSOLETE 
// OBSOLETE       if (todo > 2)
// OBSOLETE 	todo = 2;
// OBSOLETE       memcpy (valbuf + b, regbuf + b, todo);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE write_return_value (struct type *type, char *valbuf)
// OBSOLETE {
// OBSOLETE   int reg;
// OBSOLETE   int len;
// OBSOLETE 
// OBSOLETE   for (len = 0; len < TYPE_LENGTH (type); len += 2)
// OBSOLETE     deprecated_write_register_bytes (REGISTER_BYTE (len / 2 + 2),
// OBSOLETE 				     valbuf + len, 2);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
// OBSOLETE {
// OBSOLETE   write_register (2, addr);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE z8k_print_register_hook (int regno)
// OBSOLETE {
// OBSOLETE   if ((regno & 1) == 0 && regno < 16)
// OBSOLETE     {
// OBSOLETE       unsigned char l[4];
// OBSOLETE 
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno, l + 0);
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno + 1, l + 2);
// OBSOLETE       printf_unfiltered ("\t");
// OBSOLETE       printf_unfiltered ("0x%02x%02x%02x%02x", l[0], l[1], l[2], l[3]);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if ((regno & 3) == 0 && regno < 16)
// OBSOLETE     {
// OBSOLETE       unsigned char l[8];
// OBSOLETE 
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno, l + 0);
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno + 1, l + 2);
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno + 2, l + 4);
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno + 3, l + 6);
// OBSOLETE 
// OBSOLETE       printf_unfiltered ("\t");
// OBSOLETE       printf_unfiltered ("0x%02x%02x%02x%02x%02x%02x%02x%02x",
// OBSOLETE                          l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7]);
// OBSOLETE     }
// OBSOLETE   if (regno == 15)
// OBSOLETE     {
// OBSOLETE       unsigned short rval;
// OBSOLETE       int i;
// OBSOLETE 
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno, (char *) (&rval));
// OBSOLETE 
// OBSOLETE       printf_unfiltered ("\n");
// OBSOLETE       for (i = 0; i < 10; i += 2)
// OBSOLETE 	{
// OBSOLETE 	  printf_unfiltered ("(sp+%d=%04x)", i,
// OBSOLETE 			     (unsigned int)read_memory_short (rval + i));
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE z8k_print_registers_info (struct gdbarch *gdbarch,
// OBSOLETE 			  struct ui_file *file,
// OBSOLETE 			  struct frame_info *frame,
// OBSOLETE 			  int regnum, int print_all)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   const int numregs = NUM_REGS + NUM_PSEUDO_REGS;
// OBSOLETE   char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
// OBSOLETE   char *virtual_buffer = alloca (MAX_REGISTER_VIRTUAL_SIZE);
// OBSOLETE 
// OBSOLETE   for (i = 0; i < numregs; i++)
// OBSOLETE     {
// OBSOLETE       /* Decide between printing all regs, non-float / vector regs, or
// OBSOLETE          specific reg.  */
// OBSOLETE       if (regnum == -1)
// OBSOLETE 	{
// OBSOLETE 	  if (!print_all)
// OBSOLETE 	    {
// OBSOLETE 	      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
// OBSOLETE 		continue;
// OBSOLETE 	      if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)))
// OBSOLETE 		continue;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (i != regnum)
// OBSOLETE 	    continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* If the register name is empty, it is undefined for this
// OBSOLETE          processor, so don't display anything.  */
// OBSOLETE       if (REGISTER_NAME (i) == NULL || *(REGISTER_NAME (i)) == '\0')
// OBSOLETE 	continue;
// OBSOLETE 
// OBSOLETE       fputs_filtered (REGISTER_NAME (i), file);
// OBSOLETE       print_spaces_filtered (15 - strlen (REGISTER_NAME (i)), file);
// OBSOLETE 
// OBSOLETE       /* Get the data in raw format.  */
// OBSOLETE       if (! frame_register_read (frame, i, raw_buffer))
// OBSOLETE 	{
// OBSOLETE 	  fprintf_filtered (file, "*value not available*\n");
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* FIXME: cagney/2002-08-03: This code shouldn't be necessary.
// OBSOLETE          The function frame_register_read() should have returned the
// OBSOLETE          pre-cooked register so no conversion is necessary.  */
// OBSOLETE       /* Convert raw data to virtual format if necessary.  */
// OBSOLETE       if (REGISTER_CONVERTIBLE (i))
// OBSOLETE 	{
// OBSOLETE 	  REGISTER_CONVERT_TO_VIRTUAL (i, REGISTER_VIRTUAL_TYPE (i),
// OBSOLETE 				       raw_buffer, virtual_buffer);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  memcpy (virtual_buffer, raw_buffer,
// OBSOLETE 		  REGISTER_VIRTUAL_SIZE (i));
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* If virtual format is floating, print it that way, and in raw
// OBSOLETE          hex.  */
// OBSOLETE       if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
// OBSOLETE 	{
// OBSOLETE 	  int j;
// OBSOLETE 
// OBSOLETE 	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
// OBSOLETE 		     file, 0, 1, 0, Val_pretty_default);
// OBSOLETE 
// OBSOLETE 	  fprintf_filtered (file, "\t(raw 0x");
// OBSOLETE 	  for (j = 0; j < REGISTER_RAW_SIZE (i); j++)
// OBSOLETE 	    {
// OBSOLETE 	      int idx;
// OBSOLETE 	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
// OBSOLETE 		idx = j;
// OBSOLETE 	      else
// OBSOLETE 		idx = REGISTER_RAW_SIZE (i) - 1 - j;
// OBSOLETE 	      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
// OBSOLETE 	    }
// OBSOLETE 	  fprintf_filtered (file, ")");
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* Print the register in hex.  */
// OBSOLETE 	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
// OBSOLETE 		     file, 'x', 1, 0, Val_pretty_default);
// OBSOLETE           /* If not a vector register, print it also according to its
// OBSOLETE              natural format.  */
// OBSOLETE 	  if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)) == 0)
// OBSOLETE 	    {
// OBSOLETE 	      fprintf_filtered (file, "\t");
// OBSOLETE 	      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
// OBSOLETE 			 file, 0, 1, 0, Val_pretty_default);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Some z8k specific info.  */
// OBSOLETE       z8k_print_register_hook (i);
// OBSOLETE 
// OBSOLETE       fprintf_filtered (file, "\n");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE z8k_do_registers_info (int regnum, int all)
// OBSOLETE {
// OBSOLETE   z8k_print_registers_info (current_gdbarch, gdb_stdout,
// OBSOLETE 			    deprecated_selected_frame, regnum, all);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE z8k_pop_frame (void)
// OBSOLETE {
// OBSOLETE }
// OBSOLETE 
// OBSOLETE struct cmd_list_element *setmemorylist;
// OBSOLETE 
// OBSOLETE void
// OBSOLETE z8k_set_pointer_size (int newsize)
// OBSOLETE {
// OBSOLETE   static int oldsize = 0;
// OBSOLETE 
// OBSOLETE   if (oldsize != newsize)
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("pointer size set to %d bits\n", newsize);
// OBSOLETE       oldsize = newsize;
// OBSOLETE       if (newsize == 32)
// OBSOLETE 	{
// OBSOLETE 	  BIG = 1;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  BIG = 0;
// OBSOLETE 	}
// OBSOLETE       /* FIXME: This code should be using the GDBARCH framework to
// OBSOLETE          handle changed type sizes.  If this problem is ever fixed
// OBSOLETE          (the direct reference to _initialize_gdbtypes() below
// OBSOLETE          eliminated) then Makefile.in should be updated so that
// OBSOLETE          z8k-tdep.c is again compiled with -Werror. */
// OBSOLETE       _initialize_gdbtypes ();
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE segmented_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   z8k_set_pointer_size (32);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE unsegmented_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   z8k_set_pointer_size (16);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE set_memory (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   printf_unfiltered ("\"set memory\" must be followed by the name of a memory subcommand.\n");
// OBSOLETE   help_list (setmemorylist, "set memory ", -1, gdb_stdout);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_z8ktdep (void)
// OBSOLETE {
// OBSOLETE   tm_print_insn = gdb_print_insn_z8k;
// OBSOLETE 
// OBSOLETE   add_prefix_cmd ("memory", no_class, set_memory,
// OBSOLETE 		  "set the memory model", &setmemorylist, "set memory ", 0,
// OBSOLETE 		  &setlist);
// OBSOLETE   add_cmd ("segmented", class_support, segmented_command,
// OBSOLETE 	   "Set segmented memory model.", &setmemorylist);
// OBSOLETE   add_cmd ("unsegmented", class_support, unsegmented_command,
// OBSOLETE 	   "Set unsegmented memory model.", &setmemorylist);
// OBSOLETE 
// OBSOLETE }
@


1.10.8.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@@


1.9
log
@Output tweaks.
@
text
@a29 1
#include "obstack.h"
@


1.8
log
@* sparc-tdep.c (sparc_get_saved_register): Use get_prev_frame
instead of ->prev.
* z8k-tdep.c (z8k_frame_chain): Do not use ->prev.
* s390-tdep.c (s390_frame_chain): Do not use ->prev.
* rs6000-tdep.c (frame_get_saved_regs): Use rs6000_frame_chain()
instead of ->prev.
@
text
@d328 1
a328 1
      unsigned short l[2];
d330 2
a331 2
      frame_register_read (selected_frame, regno, (char *) (l + 0));
      frame_register_read (selected_frame, regno + 1, (char *) (l + 1));
d333 1
a333 1
      printf_unfiltered ("%04x%04x", l[0], l[1]);
d338 1
a338 1
      unsigned short l[4];
d340 4
a343 4
      frame_register_read (selected_frame, regno, (char *) (l + 0));
      frame_register_read (selected_frame, regno + 1, (char *) (l + 1));
      frame_register_read (selected_frame, regno + 2, (char *) (l + 2));
      frame_register_read (selected_frame, regno + 3, (char *) (l + 3));
d346 2
a347 1
      printf_unfiltered ("%04x%04x%04x%04x", l[0], l[1], l[2], l[3]);
@


1.8.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d328 1
a328 1
      unsigned char l[4];
d330 2
a331 2
      frame_register_read (selected_frame, regno, l + 0);
      frame_register_read (selected_frame, regno + 1, l + 2);
d333 1
a333 1
      printf_unfiltered ("0x%02x%02x%02x%02x", l[0], l[1], l[2], l[3]);
d338 1
a338 1
      unsigned char l[8];
d340 4
a343 4
      frame_register_read (selected_frame, regno, l + 0);
      frame_register_read (selected_frame, regno + 1, l + 2);
      frame_register_read (selected_frame, regno + 2, l + 4);
      frame_register_read (selected_frame, regno + 3, l + 6);
d346 1
a346 2
      printf_unfiltered ("0x%02x%02x%02x%02x%02x%02x%02x%02x",
                         l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7]);
@


1.8.6.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d30 1
@


1.8.6.3
log
@merge from mainline
@
text
@d322 1
a322 1
static void
a361 47
}

static void
z8k_print_registers_info (struct gdbarch *gdbarch,
			  struct ui_file *file,
			  struct frame_info *frame,
			  int regnum, int print_all)
{
  int i;
  const int numregs = NUM_REGS + NUM_PSEUDO_REGS;
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
  char *virtual_buffer = alloca (MAX_REGISTER_VIRTUAL_SIZE);

  for (i = 0; i < numregs; i++)
    {
      /* Decide between printing all regs, non-float / vector regs, or
         specific reg.  */
      if (regnum == -1)
	{
	  if (!print_all)
	    {
	      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
		continue;
	      if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)))
		continue;
	    }
	}
      else
	{
	  if (i != regnum)
	    continue;
	}

      /* If the register name is empty, it is undefined for this
         processor, so don't display anything.  */
      if (REGISTER_NAME (i) == NULL || *(REGISTER_NAME (i)) == '\0')
	continue;

      fputs_filtered (REGISTER_NAME (i), file);
      print_spaces_filtered (15 - strlen (REGISTER_NAME (i)), file);

      /* Get the data in raw format.  */
      if (! frame_register_read (frame, i, raw_buffer))
	{
	  fprintf_filtered (file, "*value not available*\n");
	  continue;
	}
a362 63
      /* FIXME: cagney/2002-08-03: This code shouldn't be necessary.
         The function frame_register_read() should have returned the
         pre-cooked register so no conversion is necessary.  */
      /* Convert raw data to virtual format if necessary.  */
      if (REGISTER_CONVERTIBLE (i))
	{
	  REGISTER_CONVERT_TO_VIRTUAL (i, REGISTER_VIRTUAL_TYPE (i),
				       raw_buffer, virtual_buffer);
	}
      else
	{
	  memcpy (virtual_buffer, raw_buffer,
		  REGISTER_VIRTUAL_SIZE (i));
	}

      /* If virtual format is floating, print it that way, and in raw
         hex.  */
      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
	{
	  int j;

	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 0, 1, 0, Val_pretty_default);

	  fprintf_filtered (file, "\t(raw 0x");
	  for (j = 0; j < REGISTER_RAW_SIZE (i); j++)
	    {
	      int idx;
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		idx = j;
	      else
		idx = REGISTER_RAW_SIZE (i) - 1 - j;
	      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
	    }
	  fprintf_filtered (file, ")");
	}
      else
	{
	  /* Print the register in hex.  */
	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 'x', 1, 0, Val_pretty_default);
          /* If not a vector register, print it also according to its
             natural format.  */
	  if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)) == 0)
	    {
	      fprintf_filtered (file, "\t");
	      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
			 file, 0, 1, 0, Val_pretty_default);
	    }
	}

      /* Some z8k specific info.  */
      z8k_print_register_hook (i);

      fprintf_filtered (file, "\n");
    }
}

void
z8k_do_registers_info (int regnum, int all)
{
  z8k_print_registers_info (current_gdbarch, gdb_stdout, selected_frame,
			    regnum, all);
@


1.8.4.1
log
@merge from trunk
@
text
@d328 1
a328 1
      unsigned char l[4];
d330 2
a331 2
      frame_register_read (selected_frame, regno, l + 0);
      frame_register_read (selected_frame, regno + 1, l + 2);
d333 1
a333 1
      printf_unfiltered ("0x%02x%02x%02x%02x", l[0], l[1], l[2], l[3]);
d338 1
a338 1
      unsigned char l[8];
d340 4
a343 4
      frame_register_read (selected_frame, regno, l + 0);
      frame_register_read (selected_frame, regno + 1, l + 2);
      frame_register_read (selected_frame, regno + 2, l + 4);
      frame_register_read (selected_frame, regno + 3, l + 6);
d346 1
a346 2
      printf_unfiltered ("0x%02x%02x%02x%02x%02x%02x%02x%02x",
                         l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7]);
@


1.7
log
@* defs.h (read_relative_register_raw_bytes): Delete declaration.
* frame.c (frame_register_read): New function.  Return non-zero on
success.
(read_relative_register_raw_bytes_for_frame): Delete.
(read_relative_register_raw_bytes): Delete.
* frame.h (frame_register_read): Declare.
* d30v-tdep.c: Update Copyright.  Use frame_register_read.
* sh-tdep.c: Ditto.
* infcmd.c (do_registers_info): Ditto.
* hppa-tdep.c: Ditto.
* rs6000-tdep.c: Ditto.
* h8500-tdep.c: Ditto.
* mips-tdep.c: Ditto.
* h8300-tdep.c: Ditto.
* z8k-tdep.c: Ditto.
@
text
@a162 4
  if (thisframe->prev == 0)
    {
      /* This is the top of the stack, let's get the sp for real */
    }
@


1.6
log
@Update/correct copyright notices.
@
text
@d2 3
a4 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d334 2
a335 2
      read_relative_register_raw_bytes (regno, (char *) (l + 0));
      read_relative_register_raw_bytes (regno + 1, (char *) (l + 1));
d344 4
a347 4
      read_relative_register_raw_bytes (regno, (char *) (l + 0));
      read_relative_register_raw_bytes (regno + 1, (char *) (l + 1));
      read_relative_register_raw_bytes (regno + 2, (char *) (l + 2));
      read_relative_register_raw_bytes (regno + 3, (char *) (l + 3));
d357 1
a357 1
      read_relative_register_raw_bytes (regno, (char *) (&rval));
@


1.5
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright (C) 1992, 1993, 1994, 2001 Free Software Foundation, Inc.
@


1.4
log
@Replace calls to abort() with calls to internal_error().
@
text
@d2 1
a2 1
   Copyright (C) 1992, 1993, 1994 Free Software Foundation, Inc.
d34 1
@


1.3
log
@Protoization.
@
text
@d174 1
a174 1
  abort ();
d200 1
a200 1
  abort ();
@


1.2
log
@PARAMS removal.
@
text
@d46 1
a46 2
z8k_frame_saved_pc (frame)
     struct frame_info *frame;
d64 1
a64 3
skip_adjust (pc, size)
     CORE_ADDR pc;
     int *size;
d87 1
a87 4
examine_frame (pc, regs, sp)
     CORE_ADDR pc;
     CORE_ADDR *regs;
     CORE_ADDR sp;
d138 1
a138 2
z8k_skip_prologue (start_pc)
     CORE_ADDR start_pc;
d146 1
a146 2
z8k_addr_bits_remove (addr)
     CORE_ADDR addr;
d158 1
a158 2
z8k_frame_chain (thisframe)
     struct frame_info *thisframe;
d172 1
a172 1
init_frame_pc ()
d184 1
a184 2
z8k_frame_init_saved_regs (frame_info)
     struct frame_info *frame_info;
d198 1
a198 1
z8k_push_dummy_frame ()
d204 1
a204 3
gdb_print_insn_z8k (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
d218 1
a218 4
NEXT_PROLOGUE_INSN (addr, lim, pword1)
     CORE_ADDR addr;
     CORE_ADDR lim;
     short *pword1;
d242 1
a242 3
frame_find_saved_regs (fip, fsrp)
     struct frame_info *fip;
     struct frame_saved_regs *fsrp;
d292 1
a292 4
extract_return_value (type, regbuf, valbuf)
     struct type *type;
     char *regbuf;
     char *valbuf;
d308 1
a308 3
write_return_value (type, valbuf)
     struct type *type;
     char *valbuf;
d318 1
a318 3
store_struct_return (addr, sp)
     CORE_ADDR addr;
     CORE_ADDR sp;
d325 1
a325 2
z8k_print_register_hook (regno)
     int regno;
d367 1
a367 1
z8k_pop_frame ()
d374 1
a374 2
z8k_set_pointer_size (newsize)
     int newsize;
d400 1
a400 3
segmented_command (args, from_tty)
     char *args;
     int from_tty;
d406 1
a406 3
unsegmented_command (args, from_tty)
     char *args;
     int from_tty;
d412 1
a412 3
set_memory (args, from_tty)
     char *args;
     int from_tty;
d419 1
a419 1
_initialize_z8ktdep ()
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 2
a23 2
 Contributed by Steve Chamberlain
                sac@@cygnus.com
d35 4
d46 1
a46 1
frame_saved_pc (frame)
d88 1
a88 1
static CORE_ADDR examine_frame PARAMS ((CORE_ADDR, CORE_ADDR *regs, CORE_ADDR));
d128 2
a129 2
       which needs stack space for locals, but has no fp.  We fake up
       the values as if we had an fp */
d138 1
a138 1
  /*  regs[fp_regnum()] = fp;*/
d159 2
a160 3
int
read_memory_pointer (x)
     CORE_ADDR x;
d166 1
a166 1
frame_chain (thisframe)
d227 1
a227 1
   of the instruction.*/
d301 1
a301 1
saved_pc_after_call ()
d303 1
a303 1
  return ADDR_BITS_REMOVE 
d336 1
a336 1
    write_register_bytes (REGISTER_BYTE (len / 2  + 2), valbuf + len, 2);
d349 1
a349 1
print_register_hook (regno)
d384 2
a385 1
	  printf_unfiltered ("(sp+%d=%04x)", i, read_memory_short (rval + i));
d416 5
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d21 2
a22 2
   Contributed by Steve Chamberlain
   sac@@cygnus.com
d83 1
a83 1
static CORE_ADDR examine_frame PARAMS ((CORE_ADDR, CORE_ADDR * regs, CORE_ADDR));
d123 2
a124 2
         which needs stack space for locals, but has no fp.  We fake up
         the values as if we had an fp */
d133 1
a133 1
  /*  regs[fp_regnum()] = fp; */
d223 1
a223 1
   of the instruction. */
d299 1
a299 1
  return ADDR_BITS_REMOVE
d332 1
a332 1
    write_register_bytes (REGISTER_BYTE (len / 2 + 2), valbuf + len, 2);
@


1.1.1.3
log
@import gdb-1999-09-08 snapshot
@
text
@a34 4
#include "value.h" /* For read_register() */


static int read_memory_pointer (CORE_ADDR x);
d42 1
a42 1
z8k_frame_saved_pc (frame)
d155 3
a157 2
static int
read_memory_pointer (CORE_ADDR x)
d163 1
a163 1
z8k_frame_chain (thisframe)
d298 1
a298 1
z8k_saved_pc_after_call (struct frame_info *frame)
d346 1
a346 1
z8k_print_register_hook (regno)
d381 1
a381 2
	  printf_unfiltered ("(sp+%d=%04x)", i,
			     (unsigned int)read_memory_short (rval + i));
a411 5
      /* FIXME: This code should be using the GDBARCH framework to
         handle changed type sizes.  If this problem is ever fixed
         (the direct reference to _initialize_gdbtypes() below
         eliminated) then Makefile.in should be updated so that
         z8k-tdep.c is again compiled with -Werror. */
@


