head	1.11;
access;
symbols
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.10
	kseitz_interps-20021105-merge:1.10
	kseitz_interps-20021103-merge:1.10
	drow-cplus-merge-20021020:1.10
	drow-cplus-merge-20021025:1.10
	carlton_dictionary-20021025-merge:1.10
	carlton_dictionary-20021011-merge:1.10
	drow-cplus-branch:1.10.0.10
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.8
	carlton_dictionary-20020920-branchpoint:1.10
	gdb_5_3-branch:1.10.0.6
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.4
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.2
	readline_4_3-import-branchpoint:1.10
	gdb_5_2_1-2002-07-23-release:1.9
	kseitz_interps-20020528-branch:1.9.0.16
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.14
	cagney_regbuf-20020515-branchpoint:1.9
	jimb-macro-020506-branch:1.9.0.12
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	gdb_5_2-branch:1.9.0.10
	gdb_5_2-2002-03-03-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.9
	gdb_5_1_0_1-2002-01-03-release:1.9
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.8
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.6
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.4
	gdb_5_1-2001-07-29-branchpoint:1.9
	dberlin-typesystem-branch:1.9.0.2
	dberlin-typesystem-branchpoint:1.9
	gdb-post-ptid_t-2001-05-03:1.9
	gdb-pre-ptid_t-2001-05-03:1.8
	insight-precleanup-2001-01-01:1.6
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.1.1.5
	gdb_4_18_2-2000-05-18-release:1.1.1.5
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.5
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.5
	gdb_5_0-2000-04-10-branch:1.1.1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.5
	repo-unification-2000-02-06:1.1.1.5
	insight-2000-02-04:1.1.1.5
	gdb-2000-02-04:1.1.1.5
	gdb-2000-02-02:1.1.1.5
	gdb-2000-02-01:1.1.1.5
	gdb-2000-01-31:1.1.1.5
	gdb-2000-01-26:1.1.1.5
	gdb-2000-01-24:1.1.1.5
	gdb-2000-01-17:1.1.1.5
	gdb-2000-01-10:1.1.1.5
	gdb-2000-01-05:1.1.1.5
	gdb-1999-12-21:1.1.1.5
	gdb-1999-12-13:1.1.1.5
	gdb-1999-12-07:1.1.1.5
	gdb-1999-12-06:1.1.1.5
	gdb-1999-11-16:1.1.1.5
	gdb-1999-11-08:1.1.1.5
	gdb-1999-11-01:1.1.1.5
	gdb-1999-10-25:1.1.1.5
	gdb-1999-10-18:1.1.1.5
	gdb-1999-10-11:1.1.1.5
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.11
date	2002.12.16.20.39.02;	author cagney;	state dead;
branches;
next	1.10;

1.10
date	2002.07.24.23.51.35;	author cagney;	state Exp;
branches
	1.10.8.1
	1.10.10.1;
next	1.9;

1.9
date	2001.05.04.04.15.24;	author kevinb;	state Exp;
branches
	1.9.16.1;
next	1.8;

1.8
date	2001.03.06.08.21.06;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.15.01.01.46;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.13.01.22.17;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.26.23.22.40;	author msnyder;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.27.15.11.13;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.23.57;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.05.23;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.10.05.23.08.07;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.10.12.04.37.19;	author jsm;	state Exp;
branches;
next	;

1.9.16.1
date	2002.08.09.18.34.23;	author kseitz;	state Exp;
branches;
next	;

1.10.8.1
date	2002.12.23.19.38.18;	author carlton;	state dead;
branches;
next	;

1.10.10.1
date	2003.12.14.20.27.10;	author drow;	state dead;
branches;
next	;


desc
@@


1.11
log
@2002-12-16  Andrew Cagney  <ac131313@@redhat.com>

	* config/arc/arc.mt, config/arc/tm-arc.h: Delete.
	* config/d30v/d30v.mt, config/d30v/tm-d30v.h: Delete.
	* config/fr30/fr30.mt, config/fr30/tm-fr30.h: Delete.
	* config/i386/i386aix.mh, config/i386/i386aix.mt: Delete.
	* config/i386/i386m3.mh, config/i386/i386m3.mt: Delete.
	* config/i386/i386mach.mh, config/i386/i386os9k.mt: Delete.
	* config/i386/nm-i386aix.h, config/i386/nm-i386mach.h: Delete.
	* config/i386/nm-m3.h, config/i386/tm-i386aix.h: Delete.
	* config/i386/tm-i386m3.h, config/i386/tm-i386mk.h: Delete.
	* config/i386/xm-i386aix.h, config/i386/xm-i386m3.h: Delete.
	* config/i386/xm-i386mach.h, config/i386/xm-i386mk.h: Delete.
	* config/i960/mon960.mt, config/i960/nindy960.mt: Delete.
	* config/i960/tm-i960.h, config/i960/tm-mon960.h: Delete.
	* config/i960/tm-nindy960.h, config/i960/tm-vx960.h: Delete.
	* config/i960/vxworks960.mt, config/m68k/apollo68b.mh: Delete.
	* config/m68k/apollo68b.mt, config/m68k/apollo68v.mh: Delete.
	* config/m68k/hp300bsd.mh, config/m68k/hp300bsd.mt: Delete.
	* config/m68k/hp300hpux.mh, config/m68k/hp300hpux.mt: Delete.
	* config/m88k/delta88.mh, config/m88k/delta88.mt: Delete.
	* config/m88k/delta88v4.mh, config/m88k/delta88v4.mt: Delete.
	* config/m88k/m88k.mh, config/m88k/m88k.mt: Delete.
	* config/m88k/nm-delta88v4.h, config/m88k/nm-m88k.h: Delete.
	* config/m88k/tm-delta88.h, config/m88k/tm-delta88v4.h: Delete.
	* config/m88k/tm-m88k.h, config/m88k/xm-delta88.h: Delete.
	* config/m88k/xm-dgux.h: Delete.
	* fr30-tdep.c, i386aix-nat.c, i386m3-nat.c: Delete.
	* i386mach-nat.c, i960-tdep.c, m88k-nat.c: Delete.
	* os9kread.c, remote-bug.c, remote-nindy.c: Delete.
	* remote-nrom.c, remote-os9k.c, remote-vx960.c: Delete.
	* d30v-tdep.c, arc-tdep.c, cxux-nat.c, dst.h, dstread.c: Delete.
	* ch-exp.c, ch-lang.c, ch-lang.h, ch-typeprint.c: Delete.
	* ch-valprint.c: Delete.
@
text
@// OBSOLETE /* Native support for Motorola 88k running Harris CX/UX.
// OBSOLETE    Copyright 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000,
// OBSOLETE    2001 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE 
// OBSOLETE #include <sys/types.h>
// OBSOLETE #include <sys/param.h>
// OBSOLETE #include <sys/dir.h>
// OBSOLETE #include <signal.h>
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include <sys/user.h>
// OBSOLETE 
// OBSOLETE #include "bfd.h"
// OBSOLETE #include "symfile.h"
// OBSOLETE #include "objfiles.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #ifndef USER			/* added to support BCS ptrace_user */
// OBSOLETE #define USER ptrace_user
// OBSOLETE #endif
// OBSOLETE #include <sys/ioctl.h>
// OBSOLETE #include <fcntl.h>
// OBSOLETE #include <sys/file.h>
// OBSOLETE #include "gdb_stat.h"
// OBSOLETE 
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "setjmp.h"
// OBSOLETE #include "value.h"
// OBSOLETE 
// OBSOLETE #include <sys/ptrace.h>
// OBSOLETE 
// OBSOLETE /* CX/UX provides them already, but as word offsets instead of char offsets */
// OBSOLETE #define SXIP_OFFSET (PT_SXIP * 4)
// OBSOLETE #define SNIP_OFFSET (PT_SNIP * 4)
// OBSOLETE #define SFIP_OFFSET (PT_SFIP * 4)
// OBSOLETE #define PSR_OFFSET  (PT_PSR  * sizeof(int))
// OBSOLETE #define FPSR_OFFSET (PT_FPSR * sizeof(int))
// OBSOLETE #define FPCR_OFFSET (PT_FPCR * sizeof(int))
// OBSOLETE 
// OBSOLETE #define XREGADDR(r) (((char *)&u.pt_x0-(char *)&u) + \
// OBSOLETE                      ((r)-X0_REGNUM)*sizeof(X_REGISTER_RAW_TYPE))
// OBSOLETE 
// OBSOLETE extern int have_symbol_file_p ();
// OBSOLETE 
// OBSOLETE extern jmp_buf stack_jmp;
// OBSOLETE 
// OBSOLETE extern int errno;
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fetch_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   register unsigned int regaddr;
// OBSOLETE   char buf[MAX_REGISTER_RAW_SIZE];
// OBSOLETE   register int i;
// OBSOLETE 
// OBSOLETE   struct USER u;
// OBSOLETE   unsigned int offset;
// OBSOLETE 
// OBSOLETE   offset = (char *) &u.pt_r0 - (char *) &u;
// OBSOLETE   regaddr = offset;		/* byte offset to r0; */
// OBSOLETE 
// OBSOLETE /*  offset = ptrace (3, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) offset, 0) - KERNEL_U_ADDR; */
// OBSOLETE   for (regno = 0; regno < PC_REGNUM; regno++)
// OBSOLETE     {
// OBSOLETE       /*regaddr = register_addr (regno, offset); */
// OBSOLETE       /* 88k enhancement  */
// OBSOLETE 
// OBSOLETE       for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
// OBSOLETE 	{
// OBSOLETE 	  *(int *) &buf[i] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 				     (PTRACE_ARG3_TYPE) regaddr, 0);
// OBSOLETE 	  regaddr += sizeof (int);
// OBSOLETE 	}
// OBSOLETE       supply_register (regno, buf);
// OBSOLETE     }
// OBSOLETE   /* now load up registers 32-37; special pc registers */
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) PSR_OFFSET, 0);
// OBSOLETE   supply_register (PSR_REGNUM, buf);
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) FPSR_OFFSET, 0);
// OBSOLETE   supply_register (FPSR_REGNUM, buf);
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) FPCR_OFFSET, 0);
// OBSOLETE   supply_register (FPCR_REGNUM, buf);
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) SXIP_OFFSET, 0);
// OBSOLETE   supply_register (SXIP_REGNUM, buf);
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) SNIP_OFFSET, 0);
// OBSOLETE   supply_register (SNIP_REGNUM, buf);
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) SFIP_OFFSET, 0);
// OBSOLETE   supply_register (SFIP_REGNUM, buf);
// OBSOLETE 
// OBSOLETE   if (target_is_m88110)
// OBSOLETE     {
// OBSOLETE       for (regaddr = XREGADDR (X0_REGNUM), regno = X0_REGNUM;
// OBSOLETE 	   regno < NUM_REGS;
// OBSOLETE 	   regno++, regaddr += 16)
// OBSOLETE 	{
// OBSOLETE 	  X_REGISTER_RAW_TYPE xval;
// OBSOLETE 
// OBSOLETE 	  *(int *) &xval.w1 = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 				      (PTRACE_ARG3_TYPE) regaddr, 0);
// OBSOLETE 	  *(int *) &xval.w2 = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 				      (PTRACE_ARG3_TYPE) (regaddr + 4), 0);
// OBSOLETE 	  *(int *) &xval.w3 = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 				      (PTRACE_ARG3_TYPE) (regaddr + 8), 0);
// OBSOLETE 	  *(int *) &xval.w4 = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 				      (PTRACE_ARG3_TYPE) (regaddr + 12), 0);
// OBSOLETE 	  supply_register (regno, (void *) &xval);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store our register values back into the inferior.
// OBSOLETE    If REGNO is -1, do this for all registers.
// OBSOLETE    Otherwise, REGNO specifies which register (so we can save time).  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE store_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   register unsigned int regaddr;
// OBSOLETE   char buf[80];
// OBSOLETE 
// OBSOLETE   struct USER u;
// OBSOLETE 
// OBSOLETE   unsigned int offset = (char *) &u.pt_r0 - (char *) &u;
// OBSOLETE 
// OBSOLETE   regaddr = offset;
// OBSOLETE 
// OBSOLETE   /* Don't try to deal with EXIP_REGNUM or ENIP_REGNUM, because I think either
// OBSOLETE      svr3 doesn't run on an 88110, or the kernel isolates the different (not
// OBSOLETE      completely sure this is true, but seems to be.  */
// OBSOLETE   if (regno >= 0)
// OBSOLETE     {
// OBSOLETE       /*      regaddr = register_addr (regno, offset); */
// OBSOLETE       if (regno < PC_REGNUM)
// OBSOLETE 	{
// OBSOLETE 	  regaddr = offset + regno * sizeof (int);
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		  (PTRACE_ARG3_TYPE) regaddr, read_register (regno));
// OBSOLETE 	  if (errno != 0)
// OBSOLETE 	    {
// OBSOLETE 	      sprintf (buf, "writing register number %d", regno);
// OBSOLETE 	      perror_with_name (buf);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       else if (regno == PSR_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) PSR_OFFSET, read_register (regno));
// OBSOLETE       else if (regno == FPSR_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) FPSR_OFFSET, read_register (regno));
// OBSOLETE       else if (regno == FPCR_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) FPCR_OFFSET, read_register (regno));
// OBSOLETE       else if (regno == SXIP_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (regno));
// OBSOLETE       else if (regno == SNIP_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (regno));
// OBSOLETE       else if (regno == SFIP_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (regno));
// OBSOLETE       else if (target_is_m88110 && regno < NUM_REGS)
// OBSOLETE 	{
// OBSOLETE 	  X_REGISTER_RAW_TYPE xval;
// OBSOLETE 
// OBSOLETE 	  read_register_bytes (REGISTER_BYTE (regno), (char *) &xval,
// OBSOLETE 			       sizeof (X_REGISTER_RAW_TYPE));
// OBSOLETE 	  regaddr = XREGADDR (regno);
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) regaddr, xval.w1);
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) regaddr + 4, xval.w2);
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) regaddr + 8, xval.w3);
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) regaddr + 12, xval.w4);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	printf_unfiltered ("Bad register number for store_inferior routine\n");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       for (regno = 0; regno < PC_REGNUM; regno++)
// OBSOLETE 	{
// OBSOLETE 	  /*      regaddr = register_addr (regno, offset); */
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  regaddr = offset + regno * sizeof (int);
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		  (PTRACE_ARG3_TYPE) regaddr, read_register (regno));
// OBSOLETE 	  if (errno != 0)
// OBSOLETE 	    {
// OBSOLETE 	      sprintf (buf, "writing register number %d", regno);
// OBSOLETE 	      perror_with_name (buf);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) PSR_OFFSET, read_register (regno));
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) FPSR_OFFSET, read_register (regno));
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) FPCR_OFFSET, read_register (regno));
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (SXIP_REGNUM));
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (SNIP_REGNUM));
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (SFIP_REGNUM));
// OBSOLETE       if (target_is_m88110)
// OBSOLETE 	{
// OBSOLETE 	  for (regno = X0_REGNUM; regno < NUM_REGS; regno++)
// OBSOLETE 	    {
// OBSOLETE 	      X_REGISTER_RAW_TYPE xval;
// OBSOLETE 
// OBSOLETE 	      read_register_bytes (REGISTER_BYTE (regno), (char *) &xval,
// OBSOLETE 				   sizeof (X_REGISTER_RAW_TYPE));
// OBSOLETE 	      regaddr = XREGADDR (regno);
// OBSOLETE 	      ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) regaddr, xval.w1);
// OBSOLETE 	      ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) (regaddr + 4), xval.w2);
// OBSOLETE 	      ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) (regaddr + 8), xval.w3);
// OBSOLETE 	      ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) (regaddr + 12), xval.w4);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* blockend is the address of the end of the user structure */
// OBSOLETE 
// OBSOLETE m88k_register_u_addr (int blockend, int regnum)
// OBSOLETE {
// OBSOLETE   struct USER u;
// OBSOLETE   int ustart = blockend - sizeof (struct USER);
// OBSOLETE 
// OBSOLETE   if (regnum < PSR_REGNUM)
// OBSOLETE     return (ustart + ((int) &u.pt_r0 - (int) &u) +
// OBSOLETE 	    REGISTER_SIZE * regnum);
// OBSOLETE   else if (regnum == PSR_REGNUM)
// OBSOLETE     return (ustart + ((int) &u.pt_psr) - (int) &u);
// OBSOLETE   else if (regnum == FPSR_REGNUM)
// OBSOLETE     return (ustart + ((int) &u.pt_fpsr) - (int) &u);
// OBSOLETE   else if (regnum == FPCR_REGNUM)
// OBSOLETE     return (ustart + ((int) &u.pt_fpcr) - (int) &u);
// OBSOLETE   else if (regnum == SXIP_REGNUM)
// OBSOLETE     return (ustart + SXIP_OFFSET);
// OBSOLETE   else if (regnum == SNIP_REGNUM)
// OBSOLETE     return (ustart + SNIP_OFFSET);
// OBSOLETE   else if (regnum == SFIP_REGNUM)
// OBSOLETE     return (ustart + SFIP_OFFSET);
// OBSOLETE   else if (target_is_m88110)
// OBSOLETE     return (ustart + ((int) &u.pt_x0 - (int) &u) +	/* Must be X register */
// OBSOLETE 	    sizeof (u.pt_x0) * (regnum - X0_REGNUM));
// OBSOLETE   else
// OBSOLETE     return (blockend + REGISTER_SIZE * regnum);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef USE_PROC_FS
// OBSOLETE 
// OBSOLETE #include <sys/procfs.h>
// OBSOLETE 
// OBSOLETE /* Prototypes for supply_gregset etc. */
// OBSOLETE #include "gregset.h"
// OBSOLETE 
// OBSOLETE /*  Given a pointer to a general register set in /proc format (gregset_t *),
// OBSOLETE    unpack the register contents and supply them as gdb's idea of the current
// OBSOLETE    register values. */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE supply_gregset (gregset_t *gregsetp)
// OBSOLETE {
// OBSOLETE   register int regi;
// OBSOLETE   register greg_t *regp = (greg_t *) gregsetp;
// OBSOLETE 
// OBSOLETE   for (regi = 0; regi <= SP_REGNUM; regi++)
// OBSOLETE     supply_register (regi, (char *) (regp + regi));
// OBSOLETE 
// OBSOLETE   supply_register (SXIP_REGNUM, (char *) (regp + R_XIP));
// OBSOLETE   supply_register (SNIP_REGNUM, (char *) (regp + R_NIP));
// OBSOLETE   supply_register (SFIP_REGNUM, (char *) (regp + R_FIP));
// OBSOLETE   supply_register (PSR_REGNUM, (char *) (regp + R_PSR));
// OBSOLETE   supply_register (FPSR_REGNUM, (char *) (regp + R_FPSR));
// OBSOLETE   supply_register (FPCR_REGNUM, (char *) (regp + R_FPCR));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fill_gregset (gregset_t *gregsetp, int regno)
// OBSOLETE {
// OBSOLETE   int regi;
// OBSOLETE   register greg_t *regp = (greg_t *) gregsetp;
// OBSOLETE 
// OBSOLETE   for (regi = 0; regi <= R_R31; regi++)
// OBSOLETE     if ((regno == -1) || (regno == regi))
// OBSOLETE       *(regp + regi) = *(int *) &registers[REGISTER_BYTE (regi)];
// OBSOLETE 
// OBSOLETE   if ((regno == -1) || (regno == SXIP_REGNUM))
// OBSOLETE     *(regp + R_XIP) = *(int *) &registers[REGISTER_BYTE (SXIP_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == SNIP_REGNUM))
// OBSOLETE     *(regp + R_NIP) = *(int *) &registers[REGISTER_BYTE (SNIP_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == SFIP_REGNUM))
// OBSOLETE     *(regp + R_FIP) = *(int *) &registers[REGISTER_BYTE (SFIP_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == PSR_REGNUM))
// OBSOLETE     *(regp + R_PSR) = *(int *) &registers[REGISTER_BYTE (PSR_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == FPSR_REGNUM))
// OBSOLETE     *(regp + R_FPSR) = *(int *) &registers[REGISTER_BYTE (FPSR_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == FPCR_REGNUM))
// OBSOLETE     *(regp + R_FPCR) = *(int *) &registers[REGISTER_BYTE (FPCR_REGNUM)];
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* USE_PROC_FS */
// OBSOLETE 
// OBSOLETE /* This support adds the equivalent of adb's % command.  When
// OBSOLETE    the `add-shared-symbol-files' command is given, this routine scans 
// OBSOLETE    the dynamic linker's link map and reads the minimal symbols
// OBSOLETE    from each shared object file listed in the map. */
// OBSOLETE 
// OBSOLETE struct link_map
// OBSOLETE {
// OBSOLETE   unsigned long l_addr;		/* address at which object is mapped */
// OBSOLETE   char *l_name;			/* full name of loaded object */
// OBSOLETE   void *l_ld;			/* dynamic structure of object */
// OBSOLETE   struct link_map *l_next;	/* next link object */
// OBSOLETE   struct link_map *l_prev;	/* previous link object */
// OBSOLETE };
// OBSOLETE 
// OBSOLETE #define LINKS_MAP_POINTER "_ld_tail"
// OBSOLETE #define LIBC_FILE "/usr/lib/libc.so.1"
// OBSOLETE #define SHARED_OFFSET 0xf0001000
// OBSOLETE 
// OBSOLETE #ifndef PATH_MAX
// OBSOLETE #define PATH_MAX 1023		/* maximum size of path name on OS */
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE void
// OBSOLETE add_shared_symbol_files (void)
// OBSOLETE {
// OBSOLETE   void *desc;
// OBSOLETE   struct link_map *ld_map, *lm, lms;
// OBSOLETE   struct minimal_symbol *minsym;
// OBSOLETE   struct objfile *objfile;
// OBSOLETE   char *path_name;
// OBSOLETE 
// OBSOLETE   if (ptid_equal (inferior_ptid, null_ptid))
// OBSOLETE     {
// OBSOLETE       warning ("The program has not yet been started.");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   objfile = symbol_file_add (LIBC_FILE, 0, NULL, 0, OBJF_READNOW);
// OBSOLETE   minsym = lookup_minimal_symbol (LINKS_MAP_POINTER, objfile);
// OBSOLETE 
// OBSOLETE   ld_map = (struct link_map *)
// OBSOLETE     read_memory_integer (((int) SYMBOL_VALUE_ADDRESS (minsym) + SHARED_OFFSET), 4);
// OBSOLETE   lm = ld_map;
// OBSOLETE   while (lm)
// OBSOLETE     {
// OBSOLETE       int local_errno = 0;
// OBSOLETE 
// OBSOLETE       read_memory ((CORE_ADDR) lm, (char *) &lms, sizeof (struct link_map));
// OBSOLETE       if (lms.l_name)
// OBSOLETE 	{
// OBSOLETE 	  if (target_read_string ((CORE_ADDR) lms.l_name, &path_name,
// OBSOLETE 				  PATH_MAX, &local_errno))
// OBSOLETE 	    {
// OBSOLETE 	      struct section_addr_info section_addrs;
// OBSOLETE 	      memset (&section_addrs, 0, sizeof (section_addrs));
// OBSOLETE 	      section_addrs.other[0].addr = lms.l_addr;
// OBSOLETE               section_addrs.other[0].name = ".text";
// OBSOLETE 	      symbol_file_add (path_name, 1, &section_addrs, 0, 0);
// OBSOLETE 	      xfree (path_name);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       /* traverse links in reverse order so that we get the
// OBSOLETE          the symbols the user actually gets. */
// OBSOLETE       lm = lms.l_prev;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Getting new symbols may change our opinion about what is
// OBSOLETE      frameless.  */
// OBSOLETE   reinit_frame_cache ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if defined(_ES_MP)
// OBSOLETE 
// OBSOLETE #include <sys/regset.h>
// OBSOLETE 
// OBSOLETE unsigned int
// OBSOLETE m88k_harris_core_register_addr (int regno, int reg_ptr)
// OBSOLETE {
// OBSOLETE   unsigned int word_offset;
// OBSOLETE 
// OBSOLETE   switch (regno)
// OBSOLETE     {
// OBSOLETE     case PSR_REGNUM:
// OBSOLETE       word_offset = R_EPSR;
// OBSOLETE       break;
// OBSOLETE     case FPSR_REGNUM:
// OBSOLETE       word_offset = R_FPSR;
// OBSOLETE       break;
// OBSOLETE     case FPCR_REGNUM:
// OBSOLETE       word_offset = R_FPCR;
// OBSOLETE       break;
// OBSOLETE     case SXIP_REGNUM:
// OBSOLETE       word_offset = R_EXIP;
// OBSOLETE       break;
// OBSOLETE     case SNIP_REGNUM:
// OBSOLETE       word_offset = R_ENIP;
// OBSOLETE       break;
// OBSOLETE     case SFIP_REGNUM:
// OBSOLETE       word_offset = R_EFIP;
// OBSOLETE       break;
// OBSOLETE     default:
// OBSOLETE       if (regno <= FP_REGNUM)
// OBSOLETE 	word_offset = regno;
// OBSOLETE       else
// OBSOLETE 	word_offset = ((regno - X0_REGNUM) * 4);
// OBSOLETE     }
// OBSOLETE   return (word_offset * 4);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* _ES_MP */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_m88k_nat (void)
// OBSOLETE {
// OBSOLETE #ifdef _ES_MP
// OBSOLETE   /* Enable 88110 support, as we don't support the 88100 under ES/MP.  */
// OBSOLETE 
// OBSOLETE   target_is_m88110 = 1;
// OBSOLETE #elif defined(_CX_UX)
// OBSOLETE   /* Determine whether we're running on an 88100 or an 88110.  */
// OBSOLETE   target_is_m88110 = (sinfo (SYSMACHINE, 0) == SYS5800);
// OBSOLETE #endif /* _CX_UX */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef _ES_MP
// OBSOLETE /* Given a pointer to a general register set in /proc format (gregset_t *),
// OBSOLETE    unpack the register contents and supply them as gdb's idea of the current
// OBSOLETE    register values. */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE supply_gregset (gregset_t *gregsetp)
// OBSOLETE {
// OBSOLETE   register int regi;
// OBSOLETE   register greg_t *regp = (greg_t *) gregsetp;
// OBSOLETE 
// OBSOLETE   for (regi = 0; regi < R_R31; regi++)
// OBSOLETE     {
// OBSOLETE       supply_register (regi, (char *) (regp + regi));
// OBSOLETE     }
// OBSOLETE   supply_register (PSR_REGNUM, (char *) (regp + R_EPSR));
// OBSOLETE   supply_register (FPSR_REGNUM, (char *) (regp + R_FPSR));
// OBSOLETE   supply_register (FPCR_REGNUM, (char *) (regp + R_FPCR));
// OBSOLETE   supply_register (SXIP_REGNUM, (char *) (regp + R_EXIP));
// OBSOLETE   supply_register (SNIP_REGNUM, (char *) (regp + R_ENIP));
// OBSOLETE   supply_register (SFIP_REGNUM, (char *) (regp + R_EFIP));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Given a pointer to a floating point register set in /proc format
// OBSOLETE    (fpregset_t *), unpack the register contents and supply them as gdb's
// OBSOLETE    idea of the current floating point register values.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE supply_fpregset (fpregset_t *fpregsetp)
// OBSOLETE {
// OBSOLETE   register int regi;
// OBSOLETE   char *from;
// OBSOLETE 
// OBSOLETE   for (regi = FP0_REGNUM; regi <= FPLAST_REGNUM; regi++)
// OBSOLETE     {
// OBSOLETE       from = (char *) &((*fpregsetp)[regi - FP0_REGNUM]);
// OBSOLETE       supply_register (regi, from);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* _ES_MP */
// OBSOLETE 
// OBSOLETE #ifdef _CX_UX
// OBSOLETE 
// OBSOLETE #include <sys/regset.h>
// OBSOLETE 
// OBSOLETE unsigned int
// OBSOLETE m88k_harris_core_register_addr (int regno, int reg_ptr)
// OBSOLETE {
// OBSOLETE   unsigned int word_offset;
// OBSOLETE 
// OBSOLETE   switch (regno)
// OBSOLETE     {
// OBSOLETE     case PSR_REGNUM:
// OBSOLETE       word_offset = R_PSR;
// OBSOLETE       break;
// OBSOLETE     case FPSR_REGNUM:
// OBSOLETE       word_offset = R_FPSR;
// OBSOLETE       break;
// OBSOLETE     case FPCR_REGNUM:
// OBSOLETE       word_offset = R_FPCR;
// OBSOLETE       break;
// OBSOLETE     case SXIP_REGNUM:
// OBSOLETE       word_offset = R_XIP;
// OBSOLETE       break;
// OBSOLETE     case SNIP_REGNUM:
// OBSOLETE       word_offset = R_NIP;
// OBSOLETE       break;
// OBSOLETE     case SFIP_REGNUM:
// OBSOLETE       word_offset = R_FIP;
// OBSOLETE       break;
// OBSOLETE     default:
// OBSOLETE       if (regno <= FP_REGNUM)
// OBSOLETE 	word_offset = regno;
// OBSOLETE       else
// OBSOLETE 	word_offset = ((regno - X0_REGNUM) * 4) + R_X0;
// OBSOLETE     }
// OBSOLETE   return (word_offset * 4);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* _CX_UX */
@


1.10
log
@Obsolete m88k.
@
text
@@


1.10.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.10.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.9
log
@Phase 1 of the ptid_t changes.
@
text
@d1 537
a537 537
/* Native support for Motorola 88k running Harris CX/UX.
   Copyright 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000,
   2001 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"
#include "inferior.h"

#include <sys/types.h>
#include <sys/param.h>
#include <sys/dir.h>
#include <signal.h>
#include "gdbcore.h"
#include <sys/user.h>

#include "bfd.h"
#include "symfile.h"
#include "objfiles.h"
#include "symtab.h"
#include "regcache.h"

#ifndef USER			/* added to support BCS ptrace_user */
#define USER ptrace_user
#endif
#include <sys/ioctl.h>
#include <fcntl.h>
#include <sys/file.h>
#include "gdb_stat.h"

#include "symtab.h"
#include "setjmp.h"
#include "value.h"

#include <sys/ptrace.h>

/* CX/UX provides them already, but as word offsets instead of char offsets */
#define SXIP_OFFSET (PT_SXIP * 4)
#define SNIP_OFFSET (PT_SNIP * 4)
#define SFIP_OFFSET (PT_SFIP * 4)
#define PSR_OFFSET  (PT_PSR  * sizeof(int))
#define FPSR_OFFSET (PT_FPSR * sizeof(int))
#define FPCR_OFFSET (PT_FPCR * sizeof(int))

#define XREGADDR(r) (((char *)&u.pt_x0-(char *)&u) + \
                     ((r)-X0_REGNUM)*sizeof(X_REGISTER_RAW_TYPE))

extern int have_symbol_file_p ();

extern jmp_buf stack_jmp;

extern int errno;

void
fetch_inferior_registers (int regno)
{
  register unsigned int regaddr;
  char buf[MAX_REGISTER_RAW_SIZE];
  register int i;

  struct USER u;
  unsigned int offset;

  offset = (char *) &u.pt_r0 - (char *) &u;
  regaddr = offset;		/* byte offset to r0; */

/*  offset = ptrace (3, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) offset, 0) - KERNEL_U_ADDR; */
  for (regno = 0; regno < PC_REGNUM; regno++)
    {
      /*regaddr = register_addr (regno, offset); */
      /* 88k enhancement  */

      for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
	{
	  *(int *) &buf[i] = ptrace (3, PIDGET (inferior_ptid),
				     (PTRACE_ARG3_TYPE) regaddr, 0);
	  regaddr += sizeof (int);
	}
      supply_register (regno, buf);
    }
  /* now load up registers 32-37; special pc registers */
  *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
			     (PTRACE_ARG3_TYPE) PSR_OFFSET, 0);
  supply_register (PSR_REGNUM, buf);
  *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
			     (PTRACE_ARG3_TYPE) FPSR_OFFSET, 0);
  supply_register (FPSR_REGNUM, buf);
  *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
			     (PTRACE_ARG3_TYPE) FPCR_OFFSET, 0);
  supply_register (FPCR_REGNUM, buf);
  *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
			     (PTRACE_ARG3_TYPE) SXIP_OFFSET, 0);
  supply_register (SXIP_REGNUM, buf);
  *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
			     (PTRACE_ARG3_TYPE) SNIP_OFFSET, 0);
  supply_register (SNIP_REGNUM, buf);
  *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
			     (PTRACE_ARG3_TYPE) SFIP_OFFSET, 0);
  supply_register (SFIP_REGNUM, buf);

  if (target_is_m88110)
    {
      for (regaddr = XREGADDR (X0_REGNUM), regno = X0_REGNUM;
	   regno < NUM_REGS;
	   regno++, regaddr += 16)
	{
	  X_REGISTER_RAW_TYPE xval;

	  *(int *) &xval.w1 = ptrace (3, PIDGET (inferior_ptid),
				      (PTRACE_ARG3_TYPE) regaddr, 0);
	  *(int *) &xval.w2 = ptrace (3, PIDGET (inferior_ptid),
				      (PTRACE_ARG3_TYPE) (regaddr + 4), 0);
	  *(int *) &xval.w3 = ptrace (3, PIDGET (inferior_ptid),
				      (PTRACE_ARG3_TYPE) (regaddr + 8), 0);
	  *(int *) &xval.w4 = ptrace (3, PIDGET (inferior_ptid),
				      (PTRACE_ARG3_TYPE) (regaddr + 12), 0);
	  supply_register (regno, (void *) &xval);
	}
    }
}

/* Store our register values back into the inferior.
   If REGNO is -1, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time).  */

void
store_inferior_registers (int regno)
{
  register unsigned int regaddr;
  char buf[80];

  struct USER u;

  unsigned int offset = (char *) &u.pt_r0 - (char *) &u;

  regaddr = offset;

  /* Don't try to deal with EXIP_REGNUM or ENIP_REGNUM, because I think either
     svr3 doesn't run on an 88110, or the kernel isolates the different (not
     completely sure this is true, but seems to be.  */
  if (regno >= 0)
    {
      /*      regaddr = register_addr (regno, offset); */
      if (regno < PC_REGNUM)
	{
	  regaddr = offset + regno * sizeof (int);
	  errno = 0;
	  ptrace (6, PIDGET (inferior_ptid),
		  (PTRACE_ARG3_TYPE) regaddr, read_register (regno));
	  if (errno != 0)
	    {
	      sprintf (buf, "writing register number %d", regno);
	      perror_with_name (buf);
	    }
	}
      else if (regno == PSR_REGNUM)
	ptrace (6, PIDGET (inferior_ptid),
		(PTRACE_ARG3_TYPE) PSR_OFFSET, read_register (regno));
      else if (regno == FPSR_REGNUM)
	ptrace (6, PIDGET (inferior_ptid),
		(PTRACE_ARG3_TYPE) FPSR_OFFSET, read_register (regno));
      else if (regno == FPCR_REGNUM)
	ptrace (6, PIDGET (inferior_ptid),
		(PTRACE_ARG3_TYPE) FPCR_OFFSET, read_register (regno));
      else if (regno == SXIP_REGNUM)
	ptrace (6, PIDGET (inferior_ptid),
		(PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (regno));
      else if (regno == SNIP_REGNUM)
	ptrace (6, PIDGET (inferior_ptid),
		(PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (regno));
      else if (regno == SFIP_REGNUM)
	ptrace (6, PIDGET (inferior_ptid),
		(PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (regno));
      else if (target_is_m88110 && regno < NUM_REGS)
	{
	  X_REGISTER_RAW_TYPE xval;

	  read_register_bytes (REGISTER_BYTE (regno), (char *) &xval,
			       sizeof (X_REGISTER_RAW_TYPE));
	  regaddr = XREGADDR (regno);
	  ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) regaddr, xval.w1);
	  ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) regaddr + 4, xval.w2);
	  ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) regaddr + 8, xval.w3);
	  ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) regaddr + 12, xval.w4);
	}
      else
	printf_unfiltered ("Bad register number for store_inferior routine\n");
    }
  else
    {
      for (regno = 0; regno < PC_REGNUM; regno++)
	{
	  /*      regaddr = register_addr (regno, offset); */
	  errno = 0;
	  regaddr = offset + regno * sizeof (int);
	  ptrace (6, PIDGET (inferior_ptid),
		  (PTRACE_ARG3_TYPE) regaddr, read_register (regno));
	  if (errno != 0)
	    {
	      sprintf (buf, "writing register number %d", regno);
	      perror_with_name (buf);
	    }
	}
      ptrace (6, PIDGET (inferior_ptid),
	      (PTRACE_ARG3_TYPE) PSR_OFFSET, read_register (regno));
      ptrace (6, PIDGET (inferior_ptid),
	      (PTRACE_ARG3_TYPE) FPSR_OFFSET, read_register (regno));
      ptrace (6, PIDGET (inferior_ptid),
	      (PTRACE_ARG3_TYPE) FPCR_OFFSET, read_register (regno));
      ptrace (6, PIDGET (inferior_ptid),
	      (PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (SXIP_REGNUM));
      ptrace (6, PIDGET (inferior_ptid),
	      (PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (SNIP_REGNUM));
      ptrace (6, PIDGET (inferior_ptid),
	      (PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (SFIP_REGNUM));
      if (target_is_m88110)
	{
	  for (regno = X0_REGNUM; regno < NUM_REGS; regno++)
	    {
	      X_REGISTER_RAW_TYPE xval;

	      read_register_bytes (REGISTER_BYTE (regno), (char *) &xval,
				   sizeof (X_REGISTER_RAW_TYPE));
	      regaddr = XREGADDR (regno);
	      ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) regaddr, xval.w1);
	      ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) (regaddr + 4), xval.w2);
	      ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) (regaddr + 8), xval.w3);
	      ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) (regaddr + 12), xval.w4);
	    }
	}
    }
}

/* blockend is the address of the end of the user structure */

m88k_register_u_addr (int blockend, int regnum)
{
  struct USER u;
  int ustart = blockend - sizeof (struct USER);

  if (regnum < PSR_REGNUM)
    return (ustart + ((int) &u.pt_r0 - (int) &u) +
	    REGISTER_SIZE * regnum);
  else if (regnum == PSR_REGNUM)
    return (ustart + ((int) &u.pt_psr) - (int) &u);
  else if (regnum == FPSR_REGNUM)
    return (ustart + ((int) &u.pt_fpsr) - (int) &u);
  else if (regnum == FPCR_REGNUM)
    return (ustart + ((int) &u.pt_fpcr) - (int) &u);
  else if (regnum == SXIP_REGNUM)
    return (ustart + SXIP_OFFSET);
  else if (regnum == SNIP_REGNUM)
    return (ustart + SNIP_OFFSET);
  else if (regnum == SFIP_REGNUM)
    return (ustart + SFIP_OFFSET);
  else if (target_is_m88110)
    return (ustart + ((int) &u.pt_x0 - (int) &u) +	/* Must be X register */
	    sizeof (u.pt_x0) * (regnum - X0_REGNUM));
  else
    return (blockend + REGISTER_SIZE * regnum);
}

#ifdef USE_PROC_FS

#include <sys/procfs.h>

/* Prototypes for supply_gregset etc. */
#include "gregset.h"

/*  Given a pointer to a general register set in /proc format (gregset_t *),
   unpack the register contents and supply them as gdb's idea of the current
   register values. */

void
supply_gregset (gregset_t *gregsetp)
{
  register int regi;
  register greg_t *regp = (greg_t *) gregsetp;

  for (regi = 0; regi <= SP_REGNUM; regi++)
    supply_register (regi, (char *) (regp + regi));

  supply_register (SXIP_REGNUM, (char *) (regp + R_XIP));
  supply_register (SNIP_REGNUM, (char *) (regp + R_NIP));
  supply_register (SFIP_REGNUM, (char *) (regp + R_FIP));
  supply_register (PSR_REGNUM, (char *) (regp + R_PSR));
  supply_register (FPSR_REGNUM, (char *) (regp + R_FPSR));
  supply_register (FPCR_REGNUM, (char *) (regp + R_FPCR));
}

void
fill_gregset (gregset_t *gregsetp, int regno)
{
  int regi;
  register greg_t *regp = (greg_t *) gregsetp;

  for (regi = 0; regi <= R_R31; regi++)
    if ((regno == -1) || (regno == regi))
      *(regp + regi) = *(int *) &registers[REGISTER_BYTE (regi)];

  if ((regno == -1) || (regno == SXIP_REGNUM))
    *(regp + R_XIP) = *(int *) &registers[REGISTER_BYTE (SXIP_REGNUM)];
  if ((regno == -1) || (regno == SNIP_REGNUM))
    *(regp + R_NIP) = *(int *) &registers[REGISTER_BYTE (SNIP_REGNUM)];
  if ((regno == -1) || (regno == SFIP_REGNUM))
    *(regp + R_FIP) = *(int *) &registers[REGISTER_BYTE (SFIP_REGNUM)];
  if ((regno == -1) || (regno == PSR_REGNUM))
    *(regp + R_PSR) = *(int *) &registers[REGISTER_BYTE (PSR_REGNUM)];
  if ((regno == -1) || (regno == FPSR_REGNUM))
    *(regp + R_FPSR) = *(int *) &registers[REGISTER_BYTE (FPSR_REGNUM)];
  if ((regno == -1) || (regno == FPCR_REGNUM))
    *(regp + R_FPCR) = *(int *) &registers[REGISTER_BYTE (FPCR_REGNUM)];
}

#endif /* USE_PROC_FS */

/* This support adds the equivalent of adb's % command.  When
   the `add-shared-symbol-files' command is given, this routine scans 
   the dynamic linker's link map and reads the minimal symbols
   from each shared object file listed in the map. */

struct link_map
{
  unsigned long l_addr;		/* address at which object is mapped */
  char *l_name;			/* full name of loaded object */
  void *l_ld;			/* dynamic structure of object */
  struct link_map *l_next;	/* next link object */
  struct link_map *l_prev;	/* previous link object */
};

#define LINKS_MAP_POINTER "_ld_tail"
#define LIBC_FILE "/usr/lib/libc.so.1"
#define SHARED_OFFSET 0xf0001000

#ifndef PATH_MAX
#define PATH_MAX 1023		/* maximum size of path name on OS */
#endif

void
add_shared_symbol_files (void)
{
  void *desc;
  struct link_map *ld_map, *lm, lms;
  struct minimal_symbol *minsym;
  struct objfile *objfile;
  char *path_name;

  if (ptid_equal (inferior_ptid, null_ptid))
    {
      warning ("The program has not yet been started.");
      return;
    }

  objfile = symbol_file_add (LIBC_FILE, 0, NULL, 0, OBJF_READNOW);
  minsym = lookup_minimal_symbol (LINKS_MAP_POINTER, objfile);

  ld_map = (struct link_map *)
    read_memory_integer (((int) SYMBOL_VALUE_ADDRESS (minsym) + SHARED_OFFSET), 4);
  lm = ld_map;
  while (lm)
    {
      int local_errno = 0;

      read_memory ((CORE_ADDR) lm, (char *) &lms, sizeof (struct link_map));
      if (lms.l_name)
	{
	  if (target_read_string ((CORE_ADDR) lms.l_name, &path_name,
				  PATH_MAX, &local_errno))
	    {
	      struct section_addr_info section_addrs;
	      memset (&section_addrs, 0, sizeof (section_addrs));
	      section_addrs.other[0].addr = lms.l_addr;
              section_addrs.other[0].name = ".text";
	      symbol_file_add (path_name, 1, &section_addrs, 0, 0);
	      xfree (path_name);
	    }
	}
      /* traverse links in reverse order so that we get the
         the symbols the user actually gets. */
      lm = lms.l_prev;
    }

  /* Getting new symbols may change our opinion about what is
     frameless.  */
  reinit_frame_cache ();
}

#if defined(_ES_MP)

#include <sys/regset.h>

unsigned int
m88k_harris_core_register_addr (int regno, int reg_ptr)
{
  unsigned int word_offset;

  switch (regno)
    {
    case PSR_REGNUM:
      word_offset = R_EPSR;
      break;
    case FPSR_REGNUM:
      word_offset = R_FPSR;
      break;
    case FPCR_REGNUM:
      word_offset = R_FPCR;
      break;
    case SXIP_REGNUM:
      word_offset = R_EXIP;
      break;
    case SNIP_REGNUM:
      word_offset = R_ENIP;
      break;
    case SFIP_REGNUM:
      word_offset = R_EFIP;
      break;
    default:
      if (regno <= FP_REGNUM)
	word_offset = regno;
      else
	word_offset = ((regno - X0_REGNUM) * 4);
    }
  return (word_offset * 4);
}

#endif /* _ES_MP */

void
_initialize_m88k_nat (void)
{
#ifdef _ES_MP
  /* Enable 88110 support, as we don't support the 88100 under ES/MP.  */

  target_is_m88110 = 1;
#elif defined(_CX_UX)
  /* Determine whether we're running on an 88100 or an 88110.  */
  target_is_m88110 = (sinfo (SYSMACHINE, 0) == SYS5800);
#endif /* _CX_UX */
}

#ifdef _ES_MP
/* Given a pointer to a general register set in /proc format (gregset_t *),
   unpack the register contents and supply them as gdb's idea of the current
   register values. */

void
supply_gregset (gregset_t *gregsetp)
{
  register int regi;
  register greg_t *regp = (greg_t *) gregsetp;

  for (regi = 0; regi < R_R31; regi++)
    {
      supply_register (regi, (char *) (regp + regi));
    }
  supply_register (PSR_REGNUM, (char *) (regp + R_EPSR));
  supply_register (FPSR_REGNUM, (char *) (regp + R_FPSR));
  supply_register (FPCR_REGNUM, (char *) (regp + R_FPCR));
  supply_register (SXIP_REGNUM, (char *) (regp + R_EXIP));
  supply_register (SNIP_REGNUM, (char *) (regp + R_ENIP));
  supply_register (SFIP_REGNUM, (char *) (regp + R_EFIP));
}

/* Given a pointer to a floating point register set in /proc format
   (fpregset_t *), unpack the register contents and supply them as gdb's
   idea of the current floating point register values.  */

void
supply_fpregset (fpregset_t *fpregsetp)
{
  register int regi;
  char *from;

  for (regi = FP0_REGNUM; regi <= FPLAST_REGNUM; regi++)
    {
      from = (char *) &((*fpregsetp)[regi - FP0_REGNUM]);
      supply_register (regi, from);
    }
}

#endif /* _ES_MP */

#ifdef _CX_UX

#include <sys/regset.h>

unsigned int
m88k_harris_core_register_addr (int regno, int reg_ptr)
{
  unsigned int word_offset;

  switch (regno)
    {
    case PSR_REGNUM:
      word_offset = R_PSR;
      break;
    case FPSR_REGNUM:
      word_offset = R_FPSR;
      break;
    case FPCR_REGNUM:
      word_offset = R_FPCR;
      break;
    case SXIP_REGNUM:
      word_offset = R_XIP;
      break;
    case SNIP_REGNUM:
      word_offset = R_NIP;
      break;
    case SFIP_REGNUM:
      word_offset = R_FIP;
      break;
    default:
      if (regno <= FP_REGNUM)
	word_offset = regno;
      else
	word_offset = ((regno - X0_REGNUM) * 4) + R_X0;
    }
  return (word_offset * 4);
}

#endif /* _CX_UX */
@


1.9.16.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d1 537
a537 537
// OBSOLETE /* Native support for Motorola 88k running Harris CX/UX.
// OBSOLETE    Copyright 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000,
// OBSOLETE    2001 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE 
// OBSOLETE #include <sys/types.h>
// OBSOLETE #include <sys/param.h>
// OBSOLETE #include <sys/dir.h>
// OBSOLETE #include <signal.h>
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include <sys/user.h>
// OBSOLETE 
// OBSOLETE #include "bfd.h"
// OBSOLETE #include "symfile.h"
// OBSOLETE #include "objfiles.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #ifndef USER			/* added to support BCS ptrace_user */
// OBSOLETE #define USER ptrace_user
// OBSOLETE #endif
// OBSOLETE #include <sys/ioctl.h>
// OBSOLETE #include <fcntl.h>
// OBSOLETE #include <sys/file.h>
// OBSOLETE #include "gdb_stat.h"
// OBSOLETE 
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "setjmp.h"
// OBSOLETE #include "value.h"
// OBSOLETE 
// OBSOLETE #include <sys/ptrace.h>
// OBSOLETE 
// OBSOLETE /* CX/UX provides them already, but as word offsets instead of char offsets */
// OBSOLETE #define SXIP_OFFSET (PT_SXIP * 4)
// OBSOLETE #define SNIP_OFFSET (PT_SNIP * 4)
// OBSOLETE #define SFIP_OFFSET (PT_SFIP * 4)
// OBSOLETE #define PSR_OFFSET  (PT_PSR  * sizeof(int))
// OBSOLETE #define FPSR_OFFSET (PT_FPSR * sizeof(int))
// OBSOLETE #define FPCR_OFFSET (PT_FPCR * sizeof(int))
// OBSOLETE 
// OBSOLETE #define XREGADDR(r) (((char *)&u.pt_x0-(char *)&u) + \
// OBSOLETE                      ((r)-X0_REGNUM)*sizeof(X_REGISTER_RAW_TYPE))
// OBSOLETE 
// OBSOLETE extern int have_symbol_file_p ();
// OBSOLETE 
// OBSOLETE extern jmp_buf stack_jmp;
// OBSOLETE 
// OBSOLETE extern int errno;
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fetch_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   register unsigned int regaddr;
// OBSOLETE   char buf[MAX_REGISTER_RAW_SIZE];
// OBSOLETE   register int i;
// OBSOLETE 
// OBSOLETE   struct USER u;
// OBSOLETE   unsigned int offset;
// OBSOLETE 
// OBSOLETE   offset = (char *) &u.pt_r0 - (char *) &u;
// OBSOLETE   regaddr = offset;		/* byte offset to r0; */
// OBSOLETE 
// OBSOLETE /*  offset = ptrace (3, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) offset, 0) - KERNEL_U_ADDR; */
// OBSOLETE   for (regno = 0; regno < PC_REGNUM; regno++)
// OBSOLETE     {
// OBSOLETE       /*regaddr = register_addr (regno, offset); */
// OBSOLETE       /* 88k enhancement  */
// OBSOLETE 
// OBSOLETE       for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
// OBSOLETE 	{
// OBSOLETE 	  *(int *) &buf[i] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 				     (PTRACE_ARG3_TYPE) regaddr, 0);
// OBSOLETE 	  regaddr += sizeof (int);
// OBSOLETE 	}
// OBSOLETE       supply_register (regno, buf);
// OBSOLETE     }
// OBSOLETE   /* now load up registers 32-37; special pc registers */
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) PSR_OFFSET, 0);
// OBSOLETE   supply_register (PSR_REGNUM, buf);
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) FPSR_OFFSET, 0);
// OBSOLETE   supply_register (FPSR_REGNUM, buf);
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) FPCR_OFFSET, 0);
// OBSOLETE   supply_register (FPCR_REGNUM, buf);
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) SXIP_OFFSET, 0);
// OBSOLETE   supply_register (SXIP_REGNUM, buf);
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) SNIP_OFFSET, 0);
// OBSOLETE   supply_register (SNIP_REGNUM, buf);
// OBSOLETE   *(int *) &buf[0] = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 			     (PTRACE_ARG3_TYPE) SFIP_OFFSET, 0);
// OBSOLETE   supply_register (SFIP_REGNUM, buf);
// OBSOLETE 
// OBSOLETE   if (target_is_m88110)
// OBSOLETE     {
// OBSOLETE       for (regaddr = XREGADDR (X0_REGNUM), regno = X0_REGNUM;
// OBSOLETE 	   regno < NUM_REGS;
// OBSOLETE 	   regno++, regaddr += 16)
// OBSOLETE 	{
// OBSOLETE 	  X_REGISTER_RAW_TYPE xval;
// OBSOLETE 
// OBSOLETE 	  *(int *) &xval.w1 = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 				      (PTRACE_ARG3_TYPE) regaddr, 0);
// OBSOLETE 	  *(int *) &xval.w2 = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 				      (PTRACE_ARG3_TYPE) (regaddr + 4), 0);
// OBSOLETE 	  *(int *) &xval.w3 = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 				      (PTRACE_ARG3_TYPE) (regaddr + 8), 0);
// OBSOLETE 	  *(int *) &xval.w4 = ptrace (3, PIDGET (inferior_ptid),
// OBSOLETE 				      (PTRACE_ARG3_TYPE) (regaddr + 12), 0);
// OBSOLETE 	  supply_register (regno, (void *) &xval);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store our register values back into the inferior.
// OBSOLETE    If REGNO is -1, do this for all registers.
// OBSOLETE    Otherwise, REGNO specifies which register (so we can save time).  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE store_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   register unsigned int regaddr;
// OBSOLETE   char buf[80];
// OBSOLETE 
// OBSOLETE   struct USER u;
// OBSOLETE 
// OBSOLETE   unsigned int offset = (char *) &u.pt_r0 - (char *) &u;
// OBSOLETE 
// OBSOLETE   regaddr = offset;
// OBSOLETE 
// OBSOLETE   /* Don't try to deal with EXIP_REGNUM or ENIP_REGNUM, because I think either
// OBSOLETE      svr3 doesn't run on an 88110, or the kernel isolates the different (not
// OBSOLETE      completely sure this is true, but seems to be.  */
// OBSOLETE   if (regno >= 0)
// OBSOLETE     {
// OBSOLETE       /*      regaddr = register_addr (regno, offset); */
// OBSOLETE       if (regno < PC_REGNUM)
// OBSOLETE 	{
// OBSOLETE 	  regaddr = offset + regno * sizeof (int);
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		  (PTRACE_ARG3_TYPE) regaddr, read_register (regno));
// OBSOLETE 	  if (errno != 0)
// OBSOLETE 	    {
// OBSOLETE 	      sprintf (buf, "writing register number %d", regno);
// OBSOLETE 	      perror_with_name (buf);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       else if (regno == PSR_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) PSR_OFFSET, read_register (regno));
// OBSOLETE       else if (regno == FPSR_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) FPSR_OFFSET, read_register (regno));
// OBSOLETE       else if (regno == FPCR_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) FPCR_OFFSET, read_register (regno));
// OBSOLETE       else if (regno == SXIP_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (regno));
// OBSOLETE       else if (regno == SNIP_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (regno));
// OBSOLETE       else if (regno == SFIP_REGNUM)
// OBSOLETE 	ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		(PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (regno));
// OBSOLETE       else if (target_is_m88110 && regno < NUM_REGS)
// OBSOLETE 	{
// OBSOLETE 	  X_REGISTER_RAW_TYPE xval;
// OBSOLETE 
// OBSOLETE 	  read_register_bytes (REGISTER_BYTE (regno), (char *) &xval,
// OBSOLETE 			       sizeof (X_REGISTER_RAW_TYPE));
// OBSOLETE 	  regaddr = XREGADDR (regno);
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) regaddr, xval.w1);
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) regaddr + 4, xval.w2);
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) regaddr + 8, xval.w3);
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) regaddr + 12, xval.w4);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	printf_unfiltered ("Bad register number for store_inferior routine\n");
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       for (regno = 0; regno < PC_REGNUM; regno++)
// OBSOLETE 	{
// OBSOLETE 	  /*      regaddr = register_addr (regno, offset); */
// OBSOLETE 	  errno = 0;
// OBSOLETE 	  regaddr = offset + regno * sizeof (int);
// OBSOLETE 	  ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 		  (PTRACE_ARG3_TYPE) regaddr, read_register (regno));
// OBSOLETE 	  if (errno != 0)
// OBSOLETE 	    {
// OBSOLETE 	      sprintf (buf, "writing register number %d", regno);
// OBSOLETE 	      perror_with_name (buf);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) PSR_OFFSET, read_register (regno));
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) FPSR_OFFSET, read_register (regno));
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) FPCR_OFFSET, read_register (regno));
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (SXIP_REGNUM));
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (SNIP_REGNUM));
// OBSOLETE       ptrace (6, PIDGET (inferior_ptid),
// OBSOLETE 	      (PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (SFIP_REGNUM));
// OBSOLETE       if (target_is_m88110)
// OBSOLETE 	{
// OBSOLETE 	  for (regno = X0_REGNUM; regno < NUM_REGS; regno++)
// OBSOLETE 	    {
// OBSOLETE 	      X_REGISTER_RAW_TYPE xval;
// OBSOLETE 
// OBSOLETE 	      read_register_bytes (REGISTER_BYTE (regno), (char *) &xval,
// OBSOLETE 				   sizeof (X_REGISTER_RAW_TYPE));
// OBSOLETE 	      regaddr = XREGADDR (regno);
// OBSOLETE 	      ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) regaddr, xval.w1);
// OBSOLETE 	      ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) (regaddr + 4), xval.w2);
// OBSOLETE 	      ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) (regaddr + 8), xval.w3);
// OBSOLETE 	      ptrace (6, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) (regaddr + 12), xval.w4);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* blockend is the address of the end of the user structure */
// OBSOLETE 
// OBSOLETE m88k_register_u_addr (int blockend, int regnum)
// OBSOLETE {
// OBSOLETE   struct USER u;
// OBSOLETE   int ustart = blockend - sizeof (struct USER);
// OBSOLETE 
// OBSOLETE   if (regnum < PSR_REGNUM)
// OBSOLETE     return (ustart + ((int) &u.pt_r0 - (int) &u) +
// OBSOLETE 	    REGISTER_SIZE * regnum);
// OBSOLETE   else if (regnum == PSR_REGNUM)
// OBSOLETE     return (ustart + ((int) &u.pt_psr) - (int) &u);
// OBSOLETE   else if (regnum == FPSR_REGNUM)
// OBSOLETE     return (ustart + ((int) &u.pt_fpsr) - (int) &u);
// OBSOLETE   else if (regnum == FPCR_REGNUM)
// OBSOLETE     return (ustart + ((int) &u.pt_fpcr) - (int) &u);
// OBSOLETE   else if (regnum == SXIP_REGNUM)
// OBSOLETE     return (ustart + SXIP_OFFSET);
// OBSOLETE   else if (regnum == SNIP_REGNUM)
// OBSOLETE     return (ustart + SNIP_OFFSET);
// OBSOLETE   else if (regnum == SFIP_REGNUM)
// OBSOLETE     return (ustart + SFIP_OFFSET);
// OBSOLETE   else if (target_is_m88110)
// OBSOLETE     return (ustart + ((int) &u.pt_x0 - (int) &u) +	/* Must be X register */
// OBSOLETE 	    sizeof (u.pt_x0) * (regnum - X0_REGNUM));
// OBSOLETE   else
// OBSOLETE     return (blockend + REGISTER_SIZE * regnum);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef USE_PROC_FS
// OBSOLETE 
// OBSOLETE #include <sys/procfs.h>
// OBSOLETE 
// OBSOLETE /* Prototypes for supply_gregset etc. */
// OBSOLETE #include "gregset.h"
// OBSOLETE 
// OBSOLETE /*  Given a pointer to a general register set in /proc format (gregset_t *),
// OBSOLETE    unpack the register contents and supply them as gdb's idea of the current
// OBSOLETE    register values. */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE supply_gregset (gregset_t *gregsetp)
// OBSOLETE {
// OBSOLETE   register int regi;
// OBSOLETE   register greg_t *regp = (greg_t *) gregsetp;
// OBSOLETE 
// OBSOLETE   for (regi = 0; regi <= SP_REGNUM; regi++)
// OBSOLETE     supply_register (regi, (char *) (regp + regi));
// OBSOLETE 
// OBSOLETE   supply_register (SXIP_REGNUM, (char *) (regp + R_XIP));
// OBSOLETE   supply_register (SNIP_REGNUM, (char *) (regp + R_NIP));
// OBSOLETE   supply_register (SFIP_REGNUM, (char *) (regp + R_FIP));
// OBSOLETE   supply_register (PSR_REGNUM, (char *) (regp + R_PSR));
// OBSOLETE   supply_register (FPSR_REGNUM, (char *) (regp + R_FPSR));
// OBSOLETE   supply_register (FPCR_REGNUM, (char *) (regp + R_FPCR));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fill_gregset (gregset_t *gregsetp, int regno)
// OBSOLETE {
// OBSOLETE   int regi;
// OBSOLETE   register greg_t *regp = (greg_t *) gregsetp;
// OBSOLETE 
// OBSOLETE   for (regi = 0; regi <= R_R31; regi++)
// OBSOLETE     if ((regno == -1) || (regno == regi))
// OBSOLETE       *(regp + regi) = *(int *) &registers[REGISTER_BYTE (regi)];
// OBSOLETE 
// OBSOLETE   if ((regno == -1) || (regno == SXIP_REGNUM))
// OBSOLETE     *(regp + R_XIP) = *(int *) &registers[REGISTER_BYTE (SXIP_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == SNIP_REGNUM))
// OBSOLETE     *(regp + R_NIP) = *(int *) &registers[REGISTER_BYTE (SNIP_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == SFIP_REGNUM))
// OBSOLETE     *(regp + R_FIP) = *(int *) &registers[REGISTER_BYTE (SFIP_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == PSR_REGNUM))
// OBSOLETE     *(regp + R_PSR) = *(int *) &registers[REGISTER_BYTE (PSR_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == FPSR_REGNUM))
// OBSOLETE     *(regp + R_FPSR) = *(int *) &registers[REGISTER_BYTE (FPSR_REGNUM)];
// OBSOLETE   if ((regno == -1) || (regno == FPCR_REGNUM))
// OBSOLETE     *(regp + R_FPCR) = *(int *) &registers[REGISTER_BYTE (FPCR_REGNUM)];
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* USE_PROC_FS */
// OBSOLETE 
// OBSOLETE /* This support adds the equivalent of adb's % command.  When
// OBSOLETE    the `add-shared-symbol-files' command is given, this routine scans 
// OBSOLETE    the dynamic linker's link map and reads the minimal symbols
// OBSOLETE    from each shared object file listed in the map. */
// OBSOLETE 
// OBSOLETE struct link_map
// OBSOLETE {
// OBSOLETE   unsigned long l_addr;		/* address at which object is mapped */
// OBSOLETE   char *l_name;			/* full name of loaded object */
// OBSOLETE   void *l_ld;			/* dynamic structure of object */
// OBSOLETE   struct link_map *l_next;	/* next link object */
// OBSOLETE   struct link_map *l_prev;	/* previous link object */
// OBSOLETE };
// OBSOLETE 
// OBSOLETE #define LINKS_MAP_POINTER "_ld_tail"
// OBSOLETE #define LIBC_FILE "/usr/lib/libc.so.1"
// OBSOLETE #define SHARED_OFFSET 0xf0001000
// OBSOLETE 
// OBSOLETE #ifndef PATH_MAX
// OBSOLETE #define PATH_MAX 1023		/* maximum size of path name on OS */
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE void
// OBSOLETE add_shared_symbol_files (void)
// OBSOLETE {
// OBSOLETE   void *desc;
// OBSOLETE   struct link_map *ld_map, *lm, lms;
// OBSOLETE   struct minimal_symbol *minsym;
// OBSOLETE   struct objfile *objfile;
// OBSOLETE   char *path_name;
// OBSOLETE 
// OBSOLETE   if (ptid_equal (inferior_ptid, null_ptid))
// OBSOLETE     {
// OBSOLETE       warning ("The program has not yet been started.");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   objfile = symbol_file_add (LIBC_FILE, 0, NULL, 0, OBJF_READNOW);
// OBSOLETE   minsym = lookup_minimal_symbol (LINKS_MAP_POINTER, objfile);
// OBSOLETE 
// OBSOLETE   ld_map = (struct link_map *)
// OBSOLETE     read_memory_integer (((int) SYMBOL_VALUE_ADDRESS (minsym) + SHARED_OFFSET), 4);
// OBSOLETE   lm = ld_map;
// OBSOLETE   while (lm)
// OBSOLETE     {
// OBSOLETE       int local_errno = 0;
// OBSOLETE 
// OBSOLETE       read_memory ((CORE_ADDR) lm, (char *) &lms, sizeof (struct link_map));
// OBSOLETE       if (lms.l_name)
// OBSOLETE 	{
// OBSOLETE 	  if (target_read_string ((CORE_ADDR) lms.l_name, &path_name,
// OBSOLETE 				  PATH_MAX, &local_errno))
// OBSOLETE 	    {
// OBSOLETE 	      struct section_addr_info section_addrs;
// OBSOLETE 	      memset (&section_addrs, 0, sizeof (section_addrs));
// OBSOLETE 	      section_addrs.other[0].addr = lms.l_addr;
// OBSOLETE               section_addrs.other[0].name = ".text";
// OBSOLETE 	      symbol_file_add (path_name, 1, &section_addrs, 0, 0);
// OBSOLETE 	      xfree (path_name);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       /* traverse links in reverse order so that we get the
// OBSOLETE          the symbols the user actually gets. */
// OBSOLETE       lm = lms.l_prev;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Getting new symbols may change our opinion about what is
// OBSOLETE      frameless.  */
// OBSOLETE   reinit_frame_cache ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if defined(_ES_MP)
// OBSOLETE 
// OBSOLETE #include <sys/regset.h>
// OBSOLETE 
// OBSOLETE unsigned int
// OBSOLETE m88k_harris_core_register_addr (int regno, int reg_ptr)
// OBSOLETE {
// OBSOLETE   unsigned int word_offset;
// OBSOLETE 
// OBSOLETE   switch (regno)
// OBSOLETE     {
// OBSOLETE     case PSR_REGNUM:
// OBSOLETE       word_offset = R_EPSR;
// OBSOLETE       break;
// OBSOLETE     case FPSR_REGNUM:
// OBSOLETE       word_offset = R_FPSR;
// OBSOLETE       break;
// OBSOLETE     case FPCR_REGNUM:
// OBSOLETE       word_offset = R_FPCR;
// OBSOLETE       break;
// OBSOLETE     case SXIP_REGNUM:
// OBSOLETE       word_offset = R_EXIP;
// OBSOLETE       break;
// OBSOLETE     case SNIP_REGNUM:
// OBSOLETE       word_offset = R_ENIP;
// OBSOLETE       break;
// OBSOLETE     case SFIP_REGNUM:
// OBSOLETE       word_offset = R_EFIP;
// OBSOLETE       break;
// OBSOLETE     default:
// OBSOLETE       if (regno <= FP_REGNUM)
// OBSOLETE 	word_offset = regno;
// OBSOLETE       else
// OBSOLETE 	word_offset = ((regno - X0_REGNUM) * 4);
// OBSOLETE     }
// OBSOLETE   return (word_offset * 4);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* _ES_MP */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_m88k_nat (void)
// OBSOLETE {
// OBSOLETE #ifdef _ES_MP
// OBSOLETE   /* Enable 88110 support, as we don't support the 88100 under ES/MP.  */
// OBSOLETE 
// OBSOLETE   target_is_m88110 = 1;
// OBSOLETE #elif defined(_CX_UX)
// OBSOLETE   /* Determine whether we're running on an 88100 or an 88110.  */
// OBSOLETE   target_is_m88110 = (sinfo (SYSMACHINE, 0) == SYS5800);
// OBSOLETE #endif /* _CX_UX */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifdef _ES_MP
// OBSOLETE /* Given a pointer to a general register set in /proc format (gregset_t *),
// OBSOLETE    unpack the register contents and supply them as gdb's idea of the current
// OBSOLETE    register values. */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE supply_gregset (gregset_t *gregsetp)
// OBSOLETE {
// OBSOLETE   register int regi;
// OBSOLETE   register greg_t *regp = (greg_t *) gregsetp;
// OBSOLETE 
// OBSOLETE   for (regi = 0; regi < R_R31; regi++)
// OBSOLETE     {
// OBSOLETE       supply_register (regi, (char *) (regp + regi));
// OBSOLETE     }
// OBSOLETE   supply_register (PSR_REGNUM, (char *) (regp + R_EPSR));
// OBSOLETE   supply_register (FPSR_REGNUM, (char *) (regp + R_FPSR));
// OBSOLETE   supply_register (FPCR_REGNUM, (char *) (regp + R_FPCR));
// OBSOLETE   supply_register (SXIP_REGNUM, (char *) (regp + R_EXIP));
// OBSOLETE   supply_register (SNIP_REGNUM, (char *) (regp + R_ENIP));
// OBSOLETE   supply_register (SFIP_REGNUM, (char *) (regp + R_EFIP));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Given a pointer to a floating point register set in /proc format
// OBSOLETE    (fpregset_t *), unpack the register contents and supply them as gdb's
// OBSOLETE    idea of the current floating point register values.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE supply_fpregset (fpregset_t *fpregsetp)
// OBSOLETE {
// OBSOLETE   register int regi;
// OBSOLETE   char *from;
// OBSOLETE 
// OBSOLETE   for (regi = FP0_REGNUM; regi <= FPLAST_REGNUM; regi++)
// OBSOLETE     {
// OBSOLETE       from = (char *) &((*fpregsetp)[regi - FP0_REGNUM]);
// OBSOLETE       supply_register (regi, from);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* _ES_MP */
// OBSOLETE 
// OBSOLETE #ifdef _CX_UX
// OBSOLETE 
// OBSOLETE #include <sys/regset.h>
// OBSOLETE 
// OBSOLETE unsigned int
// OBSOLETE m88k_harris_core_register_addr (int regno, int reg_ptr)
// OBSOLETE {
// OBSOLETE   unsigned int word_offset;
// OBSOLETE 
// OBSOLETE   switch (regno)
// OBSOLETE     {
// OBSOLETE     case PSR_REGNUM:
// OBSOLETE       word_offset = R_PSR;
// OBSOLETE       break;
// OBSOLETE     case FPSR_REGNUM:
// OBSOLETE       word_offset = R_FPSR;
// OBSOLETE       break;
// OBSOLETE     case FPCR_REGNUM:
// OBSOLETE       word_offset = R_FPCR;
// OBSOLETE       break;
// OBSOLETE     case SXIP_REGNUM:
// OBSOLETE       word_offset = R_XIP;
// OBSOLETE       break;
// OBSOLETE     case SNIP_REGNUM:
// OBSOLETE       word_offset = R_NIP;
// OBSOLETE       break;
// OBSOLETE     case SFIP_REGNUM:
// OBSOLETE       word_offset = R_FIP;
// OBSOLETE       break;
// OBSOLETE     default:
// OBSOLETE       if (regno <= FP_REGNUM)
// OBSOLETE 	word_offset = regno;
// OBSOLETE       else
// OBSOLETE 	word_offset = ((regno - X0_REGNUM) * 4) + R_X0;
// OBSOLETE     }
// OBSOLETE   return (word_offset * 4);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* _CX_UX */
@


1.8
log
@Update/correct copyright notices.
@
text
@d83 1
a83 1
/*  offset = ptrace (3, inferior_pid, (PTRACE_ARG3_TYPE) offset, 0) - KERNEL_U_ADDR; */
d91 1
a91 1
	  *(int *) &buf[i] = ptrace (3, inferior_pid,
d98 1
a98 1
  *(int *) &buf[0] = ptrace (3, inferior_pid,
d101 1
a101 1
  *(int *) &buf[0] = ptrace (3, inferior_pid,
d104 1
a104 1
  *(int *) &buf[0] = ptrace (3, inferior_pid,
d107 1
a107 1
  *(int *) &buf[0] = ptrace (3, inferior_pid,
d110 1
a110 1
  *(int *) &buf[0] = ptrace (3, inferior_pid,
d113 1
a113 1
  *(int *) &buf[0] = ptrace (3, inferior_pid,
d125 1
a125 1
	  *(int *) &xval.w1 = ptrace (3, inferior_pid,
d127 1
a127 1
	  *(int *) &xval.w2 = ptrace (3, inferior_pid,
d129 1
a129 1
	  *(int *) &xval.w3 = ptrace (3, inferior_pid,
d131 1
a131 1
	  *(int *) &xval.w4 = ptrace (3, inferior_pid,
d164 1
a164 1
	  ptrace (6, inferior_pid,
d173 1
a173 1
	ptrace (6, inferior_pid,
d176 1
a176 1
	ptrace (6, inferior_pid,
d179 1
a179 1
	ptrace (6, inferior_pid,
d182 1
a182 1
	ptrace (6, inferior_pid,
d185 1
a185 1
	ptrace (6, inferior_pid,
d188 1
a188 1
	ptrace (6, inferior_pid,
d197 4
a200 4
	  ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, xval.w1);
	  ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr + 4, xval.w2);
	  ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr + 8, xval.w3);
	  ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr + 12, xval.w4);
d212 1
a212 1
	  ptrace (6, inferior_pid,
d220 1
a220 1
      ptrace (6, inferior_pid,
d222 1
a222 1
      ptrace (6, inferior_pid,
d224 1
a224 1
      ptrace (6, inferior_pid,
d226 1
a226 1
      ptrace (6, inferior_pid,
d228 1
a228 1
      ptrace (6, inferior_pid,
d230 1
a230 1
      ptrace (6, inferior_pid,
d241 4
a244 4
	      ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, xval.w1);
	      ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) (regaddr + 4), xval.w2);
	      ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) (regaddr + 8), xval.w3);
	      ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) (regaddr + 12), xval.w4);
d364 1
a364 1
  if (!inferior_pid)
@


1.7
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1988, 1990, 1991, 1992, 1993, 1994, 2001 Free Software
   Foundation, Inc.
@


1.6
log
@Replace free() with xfree().
@
text
@d2 2
a3 1
   Copyright 1988, 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
d37 1
@


1.5
log
@Protoization.
@
text
@d389 1
a389 1
	      free (path_name);
@


1.4
log
@Protoization.
@
text
@d69 1
a69 2
fetch_inferior_registers (regno)
     int regno;			/* Original value discarded */
@


1.3
log
@2000-05-26  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * gregset.h: New file.  Typedefs for gdb_gregset_t and
        gdb_fpregset_t, prototypes for supply_gregset and friends.
        * procfs.c: Include gregset.h.  Delete local prototypes for
        supply_gregset etc., and local typedef gdb_gregset_t etc.
        * sol-thread.c: Include gregset.h, delete local prototypes,
        add appropriate casts to gdb_gregset_t.
        * uw-thread.c, lin-thread.c, core-sol2.c, core-regset.c,
        sparc-tdep.c, ptx4-nat.c, ppc-linux-nat.c, mipsv4-nat.c,
        m88k-nat.c, m68klinux-nat.c, m68k-tdep.c, irix5-nat.c,
        irix4-nat.c, ia64-linux-nat.c, i386v4-nat.c, cxux-nat.c,
        arm-linux-nat.c, alpha-nat.c: Include gregset.h.
        * config/nm-linux.h: Define GDB_GREGSET_T, GDB_FPREGET_T.
        * config/sparc/tm-sun4sol2.h: Ditto.
@
text
@d142 1
a142 2
store_inferior_registers (regno)
     int regno;
d251 1
a251 2
m88k_register_u_addr (blockend, regnum)
     int blockend, regnum;
d290 1
a290 2
supply_gregset (gregsetp)
     gregset_t *gregsetp;
d307 1
a307 3
fill_gregset (gregsetp, regno)
     gregset_t *gregsetp;
     int regno;
d355 1
a355 1
add_shared_symbol_files ()
d408 1
a408 2
m88k_harris_core_register_addr (regno, reg_ptr)
     int regno, reg_ptr;
d444 1
a444 1
_initialize_m88k_nat ()
d462 1
a462 2
supply_gregset (gregsetp)
     gregset_t *gregsetp;
d484 1
a484 2
supply_fpregset (fpregsetp)
     fpregset_t *fpregsetp;
@


1.2
log
@2000-04-27  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* cxux-nat.c (add_shared_symbol_files): Don't treat .text section
 	as special in the section_addr_info structure.
	* pa64solib.c (pa64_solib_add_solib_objfile): Ditto.
	* osfsolib.c (symbol_add_stub): Ditto.
	* irix5-nat.c (symbol_add_stub): Ditto.
@
text
@d284 3
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d62 1
a62 1
extern int have_symbol_file_p();
a66 1
extern char registers[REGISTER_BYTES];
d70 1
a70 1
     int regno;		/* Original value discarded */
d79 2
a80 2
  offset = (char *) &u.pt_r0 - (char *) &u; 
  regaddr = offset; /* byte offset to r0;*/
d85 3
a87 3
      /*regaddr = register_addr (regno, offset);*/
	/* 88k enhancement  */
        
d89 2
a90 2
 	{
 	  *(int *) &buf[i] = ptrace (3, inferior_pid,
d92 2
a93 2
 	  regaddr += sizeof (int);
 	}
d96 39
a134 39
    /* now load up registers 32-37; special pc registers */
    *(int *) &buf[0] = ptrace (3, inferior_pid,
			       (PTRACE_ARG3_TYPE) PSR_OFFSET,0);
    supply_register (PSR_REGNUM, buf);
    *(int *) &buf[0] = ptrace (3, inferior_pid,
			       (PTRACE_ARG3_TYPE) FPSR_OFFSET,0);
    supply_register (FPSR_REGNUM, buf);
    *(int *) &buf[0] = ptrace (3, inferior_pid,
			       (PTRACE_ARG3_TYPE) FPCR_OFFSET,0);
    supply_register (FPCR_REGNUM, buf);
    *(int *) &buf[0] = ptrace (3,inferior_pid,
			       (PTRACE_ARG3_TYPE) SXIP_OFFSET ,0);
    supply_register (SXIP_REGNUM, buf);
    *(int *) &buf[0] = ptrace (3, inferior_pid,
			       (PTRACE_ARG3_TYPE) SNIP_OFFSET,0);
    supply_register (SNIP_REGNUM, buf);
    *(int *) &buf[0] = ptrace (3, inferior_pid,
			       (PTRACE_ARG3_TYPE) SFIP_OFFSET,0);
    supply_register (SFIP_REGNUM, buf);

    if (target_is_m88110) 
      {
        for (regaddr = XREGADDR(X0_REGNUM), regno = X0_REGNUM;
             regno < NUM_REGS; 
             regno++, regaddr += 16)
          {
            X_REGISTER_RAW_TYPE xval;

            *(int *) &xval.w1 = ptrace (3, inferior_pid,
                                        (PTRACE_ARG3_TYPE) regaddr, 0);
            *(int *) &xval.w2 = ptrace (3, inferior_pid,
                                        (PTRACE_ARG3_TYPE) (regaddr+4), 0);
            *(int *) &xval.w3 = ptrace (3, inferior_pid,
                                        (PTRACE_ARG3_TYPE) (regaddr+8), 0);
            *(int *) &xval.w4 = ptrace (3, inferior_pid,
                                        (PTRACE_ARG3_TYPE) (regaddr+12), 0);
            supply_register(regno, (void *)&xval);
          }
      }
d161 1
a161 1
	{ 
d173 2
a174 2
        ptrace (6, inferior_pid,
		(PTRACE_ARG3_TYPE) PSR_OFFSET, read_register(regno));
d176 2
a177 2
        ptrace (6, inferior_pid,
		(PTRACE_ARG3_TYPE) FPSR_OFFSET, read_register(regno));
d179 2
a180 2
        ptrace (6, inferior_pid,
	        (PTRACE_ARG3_TYPE) FPCR_OFFSET, read_register(regno));
d183 1
a183 1
		(PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register(regno));
d186 1
a186 1
		(PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register(regno));
d189 1
a189 1
		(PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register(regno));
d191 11
a201 11
        {
          X_REGISTER_RAW_TYPE xval;
          
          read_register_bytes(REGISTER_BYTE(regno), (char *)&xval, 
                              sizeof(X_REGISTER_RAW_TYPE));
          regaddr = XREGADDR(regno);
          ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, xval.w1);
          ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr+4, xval.w2);
          ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr+8, xval.w3);
          ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr+12, xval.w4);
        }
d206 1
a206 1
    { 
d221 1
a221 1
              (PTRACE_ARG3_TYPE) PSR_OFFSET, read_register(regno));
d223 1
a223 1
              (PTRACE_ARG3_TYPE) FPSR_OFFSET,read_register(regno));
d225 7
a231 7
              (PTRACE_ARG3_TYPE) FPCR_OFFSET,read_register(regno));
      ptrace (6,inferior_pid,
	      (PTRACE_ARG3_TYPE) SXIP_OFFSET,read_register(SXIP_REGNUM));
      ptrace (6,inferior_pid,
	      (PTRACE_ARG3_TYPE) SNIP_OFFSET,read_register(SNIP_REGNUM));
      ptrace (6,inferior_pid,
	      (PTRACE_ARG3_TYPE) SFIP_OFFSET,read_register(SFIP_REGNUM));
d233 14
a246 14
        {
          for (regno = X0_REGNUM; regno < NUM_REGS; regno++) 
            {
              X_REGISTER_RAW_TYPE xval;
     
              read_register_bytes(REGISTER_BYTE(regno), (char *)&xval, 
                                  sizeof(X_REGISTER_RAW_TYPE));
              regaddr = XREGADDR(regno);
              ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, xval.w1);
              ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) (regaddr+4), xval.w2);
              ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) (regaddr+8), xval.w3);
              ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) (regaddr+12), xval.w4);
            }
        }
d259 2
a260 2
      return (ustart + ((int) &u.pt_r0 - (int) &u) +
              REGISTER_SIZE * regnum);
d262 1
a262 1
      return (ustart + ((int) &u.pt_psr) - (int) &u);
d264 1
a264 1
      return (ustart + ((int) &u.pt_fpsr) - (int) &u);
d266 1
a266 1
      return (ustart + ((int) &u.pt_fpcr) - (int) &u);
d268 1
a268 1
      return (ustart + SXIP_OFFSET);
d270 1
a270 1
      return (ustart + SNIP_OFFSET);
d272 4
a275 4
      return (ustart + SFIP_OFFSET);
  else if (target_is_m88110) 
      return (ustart + ((int) &u.pt_x0 - (int) &u) +   /* Must be X register */
               sizeof(u.pt_x0) * (regnum - X0_REGNUM));
d277 1
a277 1
      return (blockend + REGISTER_SIZE * regnum);
d285 2
a286 2
    unpack the register contents and supply them as gdb's idea of the current
    register values. */
d292 2
a293 2
    register int regi;
    register greg_t *regp = (greg_t *) gregsetp;
d295 2
a296 2
    for (regi=0; regi <= SP_REGNUM; regi++)
	supply_register (regi, (char *) (regp + regi));
d298 6
a303 6
    supply_register (SXIP_REGNUM, (char *) (regp + R_XIP));
    supply_register (SNIP_REGNUM, (char *) (regp + R_NIP));
    supply_register (SFIP_REGNUM, (char *) (regp + R_FIP));
    supply_register (PSR_REGNUM, (char *) (regp + R_PSR));
    supply_register (FPSR_REGNUM, (char *) (regp + R_FPSR));
    supply_register (FPCR_REGNUM, (char *) (regp + R_FPCR));
d311 19
a329 20
    int regi;
    register greg_t *regp = (greg_t *) gregsetp;
    extern char registers[];

    for (regi = 0 ; regi <= R_R31 ; regi++)
	if ((regno == -1) || (regno == regi))
	    *(regp + regi) = *(int *) &registers[REGISTER_BYTE(regi)];

    if ((regno == -1) || (regno == SXIP_REGNUM))
	*(regp + R_XIP) = *(int *) &registers[REGISTER_BYTE(SXIP_REGNUM)];
    if ((regno == -1) || (regno == SNIP_REGNUM))
	*(regp + R_NIP) = *(int *) &registers[REGISTER_BYTE(SNIP_REGNUM)];
    if ((regno == -1) || (regno == SFIP_REGNUM))
	*(regp + R_FIP) = *(int *) &registers[REGISTER_BYTE(SFIP_REGNUM)];
    if ((regno == -1) || (regno == PSR_REGNUM))
	*(regp + R_PSR) = *(int *) &registers[REGISTER_BYTE(PSR_REGNUM)];
    if ((regno == -1) || (regno == FPSR_REGNUM))
	*(regp + R_FPSR) = *(int *) &registers[REGISTER_BYTE(FPSR_REGNUM)];
    if ((regno == -1) || (regno == FPCR_REGNUM))
	*(regp + R_FPCR) = *(int *) &registers[REGISTER_BYTE(FPCR_REGNUM)];
d339 2
a340 1
struct link_map {
d361 1
a361 1
  struct minimal_symbol *minsym; 
d365 1
a365 1
  if (! inferior_pid)
d371 1
a371 1
  objfile = symbol_file_add (LIBC_FILE, 0, 0, 0, 0, 1, 0, 0);
d375 1
a375 1
    read_memory_integer (((int)SYMBOL_VALUE_ADDRESS(minsym) + SHARED_OFFSET), 4);
d381 1
a381 1
      read_memory ((CORE_ADDR)lm, (char*)&lms, sizeof (struct link_map));
d384 2
a385 2
	  if (target_read_string ((CORE_ADDR)lms.l_name, &path_name, 
                                  PATH_MAX, &local_errno))
d387 6
a392 2
	      symbol_file_add (path_name, 1, lms.l_addr, 0, 0, 0, 0, 0);
              free(path_name);
d396 1
a396 1
	 the symbols the user actually gets. */
d413 1
a413 1
   unsigned int word_offset;
d415 27
a441 27
   switch (regno)
     {
     case PSR_REGNUM:
       word_offset = R_EPSR;
       break;
     case FPSR_REGNUM:
       word_offset = R_FPSR;
       break;
     case FPCR_REGNUM:
       word_offset = R_FPCR;
       break;
     case SXIP_REGNUM:
       word_offset = R_EXIP;
       break;
     case SNIP_REGNUM:
       word_offset = R_ENIP;
       break;
     case SFIP_REGNUM:
       word_offset = R_EFIP;
       break;
     default:
       if (regno <= FP_REGNUM) 
	 word_offset = regno;
       else 
	 word_offset = ((regno - X0_REGNUM) * 4);
     }
   return (word_offset * 4);
d447 1
a447 1
_initialize_m88k_nat()
d450 1
a450 1
   /* Enable 88110 support, as we don't support the 88100 under ES/MP.  */
d452 1
a452 1
   target_is_m88110 = 1;
d454 2
a455 2
   /* Determine whether we're running on an 88100 or an 88110.  */
   target_is_m88110 = (sinfo(SYSMACHINE,0) == SYS5800);
d471 1
a471 1
  for (regi = 0 ; regi < R_R31 ; regi++)
d475 1
a475 1
  supply_register (PSR_REGNUM,  (char *) (regp + R_EPSR));
d487 1
a487 1
void 
d493 2
a494 2
  
  for (regi = FP0_REGNUM ; regi <= FPLAST_REGNUM ; regi++)
d496 1
a496 1
      from = (char *) &((*fpregsetp)[regi-FP0_REGNUM]);
d507 2
a508 1
unsigned int m88k_harris_core_register_addr(int regno, int reg_ptr)
d510 1
a510 1
   unsigned int word_offset;
d512 27
a538 14
   switch (regno) {
    case PSR_REGNUM  : word_offset = R_PSR;  break;
    case FPSR_REGNUM : word_offset = R_FPSR; break;
    case FPCR_REGNUM : word_offset = R_FPCR; break;
    case SXIP_REGNUM : word_offset = R_XIP;  break;
    case SNIP_REGNUM : word_offset = R_NIP;  break;
    case SFIP_REGNUM : word_offset = R_FIP;  break;
    default :
      if (regno <= FP_REGNUM) 
            word_offset = regno;
      else 
            word_offset = ((regno - X0_REGNUM) * 4) + R_X0;
   }
   return (word_offset * 4);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d66 1
d313 1
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d61 1
a61 1
extern int have_symbol_file_p ();
d69 1
a69 1
     int regno;			/* Original value discarded */
d78 2
a79 2
  offset = (char *) &u.pt_r0 - (char *) &u;
  regaddr = offset;		/* byte offset to r0; */
d84 3
a86 3
      /*regaddr = register_addr (regno, offset); */
      /* 88k enhancement  */

d88 2
a89 2
	{
	  *(int *) &buf[i] = ptrace (3, inferior_pid,
d91 2
a92 2
	  regaddr += sizeof (int);
	}
d95 39
a133 39
  /* now load up registers 32-37; special pc registers */
  *(int *) &buf[0] = ptrace (3, inferior_pid,
			     (PTRACE_ARG3_TYPE) PSR_OFFSET, 0);
  supply_register (PSR_REGNUM, buf);
  *(int *) &buf[0] = ptrace (3, inferior_pid,
			     (PTRACE_ARG3_TYPE) FPSR_OFFSET, 0);
  supply_register (FPSR_REGNUM, buf);
  *(int *) &buf[0] = ptrace (3, inferior_pid,
			     (PTRACE_ARG3_TYPE) FPCR_OFFSET, 0);
  supply_register (FPCR_REGNUM, buf);
  *(int *) &buf[0] = ptrace (3, inferior_pid,
			     (PTRACE_ARG3_TYPE) SXIP_OFFSET, 0);
  supply_register (SXIP_REGNUM, buf);
  *(int *) &buf[0] = ptrace (3, inferior_pid,
			     (PTRACE_ARG3_TYPE) SNIP_OFFSET, 0);
  supply_register (SNIP_REGNUM, buf);
  *(int *) &buf[0] = ptrace (3, inferior_pid,
			     (PTRACE_ARG3_TYPE) SFIP_OFFSET, 0);
  supply_register (SFIP_REGNUM, buf);

  if (target_is_m88110)
    {
      for (regaddr = XREGADDR (X0_REGNUM), regno = X0_REGNUM;
	   regno < NUM_REGS;
	   regno++, regaddr += 16)
	{
	  X_REGISTER_RAW_TYPE xval;

	  *(int *) &xval.w1 = ptrace (3, inferior_pid,
				      (PTRACE_ARG3_TYPE) regaddr, 0);
	  *(int *) &xval.w2 = ptrace (3, inferior_pid,
				      (PTRACE_ARG3_TYPE) (regaddr + 4), 0);
	  *(int *) &xval.w3 = ptrace (3, inferior_pid,
				      (PTRACE_ARG3_TYPE) (regaddr + 8), 0);
	  *(int *) &xval.w4 = ptrace (3, inferior_pid,
				      (PTRACE_ARG3_TYPE) (regaddr + 12), 0);
	  supply_register (regno, (void *) &xval);
	}
    }
d160 1
a160 1
	{
d172 2
a173 2
	ptrace (6, inferior_pid,
		(PTRACE_ARG3_TYPE) PSR_OFFSET, read_register (regno));
d175 2
a176 2
	ptrace (6, inferior_pid,
		(PTRACE_ARG3_TYPE) FPSR_OFFSET, read_register (regno));
d178 2
a179 2
	ptrace (6, inferior_pid,
		(PTRACE_ARG3_TYPE) FPCR_OFFSET, read_register (regno));
d182 1
a182 1
		(PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (regno));
d185 1
a185 1
		(PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (regno));
d188 1
a188 1
		(PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (regno));
d190 11
a200 11
	{
	  X_REGISTER_RAW_TYPE xval;

	  read_register_bytes (REGISTER_BYTE (regno), (char *) &xval,
			       sizeof (X_REGISTER_RAW_TYPE));
	  regaddr = XREGADDR (regno);
	  ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, xval.w1);
	  ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr + 4, xval.w2);
	  ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr + 8, xval.w3);
	  ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr + 12, xval.w4);
	}
d205 1
a205 1
    {
d220 1
a220 5
	      (PTRACE_ARG3_TYPE) PSR_OFFSET, read_register (regno));
      ptrace (6, inferior_pid,
	      (PTRACE_ARG3_TYPE) FPSR_OFFSET, read_register (regno));
      ptrace (6, inferior_pid,
	      (PTRACE_ARG3_TYPE) FPCR_OFFSET, read_register (regno));
d222 1
a222 1
	      (PTRACE_ARG3_TYPE) SXIP_OFFSET, read_register (SXIP_REGNUM));
d224 7
a230 3
	      (PTRACE_ARG3_TYPE) SNIP_OFFSET, read_register (SNIP_REGNUM));
      ptrace (6, inferior_pid,
	      (PTRACE_ARG3_TYPE) SFIP_OFFSET, read_register (SFIP_REGNUM));
d232 14
a245 14
	{
	  for (regno = X0_REGNUM; regno < NUM_REGS; regno++)
	    {
	      X_REGISTER_RAW_TYPE xval;

	      read_register_bytes (REGISTER_BYTE (regno), (char *) &xval,
				   sizeof (X_REGISTER_RAW_TYPE));
	      regaddr = XREGADDR (regno);
	      ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, xval.w1);
	      ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) (regaddr + 4), xval.w2);
	      ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) (regaddr + 8), xval.w3);
	      ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) (regaddr + 12), xval.w4);
	    }
	}
d258 2
a259 2
    return (ustart + ((int) &u.pt_r0 - (int) &u) +
	    REGISTER_SIZE * regnum);
d261 1
a261 1
    return (ustart + ((int) &u.pt_psr) - (int) &u);
d263 1
a263 1
    return (ustart + ((int) &u.pt_fpsr) - (int) &u);
d265 1
a265 1
    return (ustart + ((int) &u.pt_fpcr) - (int) &u);
d267 1
a267 1
    return (ustart + SXIP_OFFSET);
d269 1
a269 1
    return (ustart + SNIP_OFFSET);
d271 4
a274 4
    return (ustart + SFIP_OFFSET);
  else if (target_is_m88110)
    return (ustart + ((int) &u.pt_x0 - (int) &u) +	/* Must be X register */
	    sizeof (u.pt_x0) * (regnum - X0_REGNUM));
d276 1
a276 1
    return (blockend + REGISTER_SIZE * regnum);
d284 2
a285 2
   unpack the register contents and supply them as gdb's idea of the current
   register values. */
d291 2
a292 2
  register int regi;
  register greg_t *regp = (greg_t *) gregsetp;
d294 2
a295 2
  for (regi = 0; regi <= SP_REGNUM; regi++)
    supply_register (regi, (char *) (regp + regi));
d297 6
a302 6
  supply_register (SXIP_REGNUM, (char *) (regp + R_XIP));
  supply_register (SNIP_REGNUM, (char *) (regp + R_NIP));
  supply_register (SFIP_REGNUM, (char *) (regp + R_FIP));
  supply_register (PSR_REGNUM, (char *) (regp + R_PSR));
  supply_register (FPSR_REGNUM, (char *) (regp + R_FPSR));
  supply_register (FPCR_REGNUM, (char *) (regp + R_FPCR));
d310 2
a311 2
  int regi;
  register greg_t *regp = (greg_t *) gregsetp;
d313 16
a328 16
  for (regi = 0; regi <= R_R31; regi++)
    if ((regno == -1) || (regno == regi))
      *(regp + regi) = *(int *) &registers[REGISTER_BYTE (regi)];

  if ((regno == -1) || (regno == SXIP_REGNUM))
    *(regp + R_XIP) = *(int *) &registers[REGISTER_BYTE (SXIP_REGNUM)];
  if ((regno == -1) || (regno == SNIP_REGNUM))
    *(regp + R_NIP) = *(int *) &registers[REGISTER_BYTE (SNIP_REGNUM)];
  if ((regno == -1) || (regno == SFIP_REGNUM))
    *(regp + R_FIP) = *(int *) &registers[REGISTER_BYTE (SFIP_REGNUM)];
  if ((regno == -1) || (regno == PSR_REGNUM))
    *(regp + R_PSR) = *(int *) &registers[REGISTER_BYTE (PSR_REGNUM)];
  if ((regno == -1) || (regno == FPSR_REGNUM))
    *(regp + R_FPSR) = *(int *) &registers[REGISTER_BYTE (FPSR_REGNUM)];
  if ((regno == -1) || (regno == FPCR_REGNUM))
    *(regp + R_FPCR) = *(int *) &registers[REGISTER_BYTE (FPCR_REGNUM)];
d338 1
a338 2
struct link_map
{
d359 1
a359 1
  struct minimal_symbol *minsym;
d363 1
a363 1
  if (!inferior_pid)
d373 1
a373 1
    read_memory_integer (((int) SYMBOL_VALUE_ADDRESS (minsym) + SHARED_OFFSET), 4);
d379 1
a379 1
      read_memory ((CORE_ADDR) lm, (char *) &lms, sizeof (struct link_map));
d382 2
a383 2
	  if (target_read_string ((CORE_ADDR) lms.l_name, &path_name,
				  PATH_MAX, &local_errno))
d386 1
a386 1
	      free (path_name);
d390 1
a390 1
         the symbols the user actually gets. */
d407 1
a407 1
  unsigned int word_offset;
d409 27
a435 27
  switch (regno)
    {
    case PSR_REGNUM:
      word_offset = R_EPSR;
      break;
    case FPSR_REGNUM:
      word_offset = R_FPSR;
      break;
    case FPCR_REGNUM:
      word_offset = R_FPCR;
      break;
    case SXIP_REGNUM:
      word_offset = R_EXIP;
      break;
    case SNIP_REGNUM:
      word_offset = R_ENIP;
      break;
    case SFIP_REGNUM:
      word_offset = R_EFIP;
      break;
    default:
      if (regno <= FP_REGNUM)
	word_offset = regno;
      else
	word_offset = ((regno - X0_REGNUM) * 4);
    }
  return (word_offset * 4);
d441 1
a441 1
_initialize_m88k_nat ()
d444 1
a444 1
  /* Enable 88110 support, as we don't support the 88100 under ES/MP.  */
d446 1
a446 1
  target_is_m88110 = 1;
d448 2
a449 2
  /* Determine whether we're running on an 88100 or an 88110.  */
  target_is_m88110 = (sinfo (SYSMACHINE, 0) == SYS5800);
d465 1
a465 1
  for (regi = 0; regi < R_R31; regi++)
d469 1
a469 1
  supply_register (PSR_REGNUM, (char *) (regp + R_EPSR));
d481 1
a481 1
void
d487 2
a488 2

  for (regi = FP0_REGNUM; regi <= FPLAST_REGNUM; regi++)
d490 1
a490 1
      from = (char *) &((*fpregsetp)[regi - FP0_REGNUM]);
d501 1
a501 2
unsigned int
m88k_harris_core_register_addr (int regno, int reg_ptr)
d503 1
a503 1
  unsigned int word_offset;
d505 14
a518 27
  switch (regno)
    {
    case PSR_REGNUM:
      word_offset = R_PSR;
      break;
    case FPSR_REGNUM:
      word_offset = R_FPSR;
      break;
    case FPCR_REGNUM:
      word_offset = R_FPCR;
      break;
    case SXIP_REGNUM:
      word_offset = R_XIP;
      break;
    case SNIP_REGNUM:
      word_offset = R_NIP;
      break;
    case SFIP_REGNUM:
      word_offset = R_FIP;
      break;
    default:
      if (regno <= FP_REGNUM)
	word_offset = regno;
      else
	word_offset = ((regno - X0_REGNUM) * 4) + R_X0;
    }
  return (word_offset * 4);
@


1.1.1.4
log
@import gdb-1999-10-04 snapshot
@
text
@d371 1
a371 1
  objfile = symbol_file_add (LIBC_FILE, 0, NULL, 0, OBJF_READNOW, 0, 0);
d387 1
a387 4
	      struct section_addr_info section_addrs;
	      memset (&section_addrs, 0, sizeof (section_addrs));
	      section_addrs.text_addr = lms.l_addr;
	      symbol_file_add (path_name, 1, &section_addrs, 0, 0, 0, 0);
@


1.1.1.5
log
@import gdb-1999-10-11 snapshot
@
text
@d371 1
a371 1
  objfile = symbol_file_add (LIBC_FILE, 0, NULL, 0, OBJF_READNOW);
d390 1
a390 1
	      symbol_file_add (path_name, 1, &section_addrs, 0, 0);
@


