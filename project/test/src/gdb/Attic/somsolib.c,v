head	1.46;
access;
symbols
	gdb-csl-arm-20050325-2005-q1b:1.45
	gdb-csl-arm-20050325-2005-q1a:1.45
	csl-arm-20050325-branch:1.45.0.2
	csl-arm-20050325-branchpoint:1.45
	gdb-post-i18n-errorwarning-20050211:1.41
	gdb-pre-i18n-errorwarning-20050211:1.40
	gdb_6_3-20041109-release:1.37
	gdb_6_3-branch:1.37.0.2
	gdb_6_3-20041019-branchpoint:1.37
	drow_intercu-merge-20040921:1.37
	drow_intercu-merge-20040915:1.37
	jimb-gdb_6_2-e500-branch:1.34.0.6
	jimb-gdb_6_2-e500-branchpoint:1.34
	gdb_6_2-20040730-release:1.34
	gdb_6_2-branch:1.34.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.34
	gdb_6_1_1-20040616-release:1.30.6.1
	gdb_6_1-2004-04-05-release:1.30
	drow_intercu-merge-20040402:1.30
	drow_intercu-merge-20040327:1.30
	ezannoni_pie-20040323-branch:1.30.0.10
	ezannoni_pie-20040323-branchpoint:1.30
	cagney_tramp-20040321-mergepoint:1.30
	cagney_tramp-20040309-branch:1.30.0.8
	cagney_tramp-20040309-branchpoint:1.30
	gdb_6_1-branch:1.30.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.30
	drow_intercu-20040221-branch:1.30.0.4
	drow_intercu-20040221-branchpoint:1.30
	cagney_bfdfile-20040213-branch:1.30.0.2
	cagney_bfdfile-20040213-branchpoint:1.30
	drow-cplus-merge-20040208:1.30
	carlton_dictionary-20040126-merge:1.28
	cagney_bigcore-20040122-branch:1.28.0.2
	cagney_bigcore-20040122-branchpoint:1.28
	drow-cplus-merge-20040113:1.28
	drow-cplus-merge-20031224:1.28
	drow-cplus-merge-20031220:1.28
	carlton_dictionary-20031215-merge:1.28
	drow-cplus-merge-20031214:1.28
	carlton-dictionary-20031111-merge:1.28
	gdb_6_0-2003-10-04-release:1.25
	kettenis_sparc-20030918-branch:1.26.0.4
	kettenis_sparc-20030918-branchpoint:1.26
	carlton_dictionary-20030917-merge:1.26
	ezannoni_pie-20030916-branchpoint:1.26
	ezannoni_pie-20030916-branch:1.26.0.2
	cagney_x86i386-20030821-branch:1.25.0.24
	cagney_x86i386-20030821-branchpoint:1.25
	carlton_dictionary-20030805-merge:1.25
	carlton_dictionary-20030627-merge:1.25
	gdb_6_0-branch:1.25.0.22
	gdb_6_0-2003-06-23-branchpoint:1.25
	jimb-ppc64-linux-20030613-branch:1.25.0.20
	jimb-ppc64-linux-20030613-branchpoint:1.25
	cagney_convert-20030606-branch:1.25.0.18
	cagney_convert-20030606-branchpoint:1.25
	cagney_writestrings-20030508-branch:1.25.0.16
	cagney_writestrings-20030508-branchpoint:1.25
	jimb-ppc64-linux-20030528-branch:1.25.0.14
	jimb-ppc64-linux-20030528-branchpoint:1.25
	carlton_dictionary-20030523-merge:1.25
	cagney_fileio-20030521-branch:1.25.0.12
	cagney_fileio-20030521-branchpoint:1.25
	kettenis_i386newframe-20030517-mergepoint:1.25
	jimb-ppc64-linux-20030509-branch:1.25.0.10
	jimb-ppc64-linux-20030509-branchpoint:1.25
	kettenis_i386newframe-20030504-mergepoint:1.25
	carlton_dictionary-20030430-merge:1.25
	kettenis_i386newframe-20030419-branch:1.25.0.8
	kettenis_i386newframe-20030419-branchpoint:1.25
	carlton_dictionary-20030416-merge:1.25
	cagney_frameaddr-20030409-mergepoint:1.25
	kettenis_i386newframe-20030406-branch:1.25.0.6
	kettenis_i386newframe-20030406-branchpoint:1.25
	cagney_frameaddr-20030403-branchpoint:1.25
	cagney_frameaddr-20030403-branch:1.25.0.4
	cagney_framebase-20030330-mergepoint:1.25
	cagney_framebase-20030326-branch:1.25.0.2
	cagney_framebase-20030326-branchpoint:1.25
	cagney_lazyid-20030317-branch:1.24.0.8
	cagney_lazyid-20030317-branchpoint:1.24
	kettenis-i386newframe-20030316-mergepoint:1.24
	offbyone-20030313-branch:1.24.0.6
	offbyone-20030313-branchpoint:1.24
	kettenis-i386newframe-20030308-branch:1.24.0.4
	kettenis-i386newframe-20030308-branchpoint:1.24
	carlton_dictionary-20030305-merge:1.24
	cagney_offbyone-20030303-branch:1.24.0.2
	cagney_offbyone-20030303-branchpoint:1.24
	carlton_dictionary-20030207-merge:1.23
	interps-20030203-mergepoint:1.23
	interps-20030202-branch:1.23.0.2
	interps-20030202-branchpoint:1.23
	cagney-unwind-20030108-branch:1.21.0.2
	cagney-unwind-20030108-branchpoint:1.21
	carlton_dictionary-20021223-merge:1.20
	gdb_5_3-2002-12-12-release:1.19
	carlton_dictionary-20021115-merge:1.19
	kseitz_interps-20021105-merge:1.19
	kseitz_interps-20021103-merge:1.19
	drow-cplus-merge-20021020:1.19
	drow-cplus-merge-20021025:1.19
	carlton_dictionary-20021025-merge:1.19
	carlton_dictionary-20021011-merge:1.19
	drow-cplus-branch:1.19.0.10
	drow-cplus-branchpoint:1.19
	kseitz_interps-20020930-merge:1.19
	carlton_dictionary-20020927-merge:1.19
	carlton_dictionary-branch:1.19.0.8
	carlton_dictionary-20020920-branchpoint:1.19
	gdb_5_3-branch:1.19.0.6
	gdb_5_3-2002-09-04-branchpoint:1.19
	kseitz_interps-20020829-merge:1.19
	cagney_sysregs-20020825-branch:1.19.0.4
	cagney_sysregs-20020825-branchpoint:1.19
	readline_4_3-import-branch:1.19.0.2
	readline_4_3-import-branchpoint:1.19
	gdb_5_2_1-2002-07-23-release:1.18
	kseitz_interps-20020528-branch:1.18.0.8
	kseitz_interps-20020528-branchpoint:1.18
	cagney_regbuf-20020515-branch:1.18.0.6
	cagney_regbuf-20020515-branchpoint:1.18
	jimb-macro-020506-branch:1.18.0.4
	jimb-macro-020506-branchpoint:1.18
	gdb_5_2-2002-04-29-release:1.18
	gdb_5_2-branch:1.18.0.2
	gdb_5_2-2002-03-03-branchpoint:1.18
	gdb_5_1_1-2002-01-24-release:1.13
	gdb_5_1_0_1-2002-01-03-release:1.13
	cygnus_cvs_20020108_pre:1.18
	gdb_5_1_0_1-2002-01-03-branchpoint:1.13
	gdb_5_1_0_1-2002-01-03-branch:1.13.0.6
	gdb_5_1-2001-11-21-release:1.13
	gdb_s390-2001-09-26-branch:1.13.0.4
	gdb_s390-2001-09-26-branchpoint:1.13
	gdb_5_1-2001-07-29-branch:1.13.0.2
	gdb_5_1-2001-07-29-branchpoint:1.13
	dberlin-typesystem-branch:1.12.0.2
	dberlin-typesystem-branchpoint:1.12
	gdb-post-ptid_t-2001-05-03:1.11
	gdb-pre-ptid_t-2001-05-03:1.10
	insight-precleanup-2001-01-01:1.7
	gdb-post-protoization-2000-07-29:1.5
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb-post-params-removal-2000-06-04:1.4
	gdb-pre-params-removal-2000-06-04:1.4
	gdb-post-params-removal-2000-05-28:1.4
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.1.1.6
	gdb_4_18_2-2000-05-18-release:1.1.1.6
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.6
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.6
	gdb_5_0-2000-04-10-branch:1.1.1.6.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.6
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.6
	gdb-1999-11-16:1.1.1.6
	gdb-1999-11-08:1.1.1.5
	gdb-1999-11-01:1.1.1.5
	gdb-1999-10-25:1.1.1.5
	gdb-1999-10-18:1.1.1.5
	gdb-1999-10-11:1.1.1.5
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.46
date	2005.05.01.16.04.24;	author kettenis;	state dead;
branches;
next	1.45;

1.45
date	2005.02.18.18.58.56;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2005.02.18.15.25.28;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2005.02.15.15.49.20;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2005.02.12.00.39.21;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2005.02.11.04.06.05;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2005.01.14.03.12.43;	author msnyder;	state Exp;
branches;
next	1.39;

1.39
date	2004.12.05.19.41.37;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2004.11.13.02.19.03;	author tausq;	state Exp;
branches;
next	1.37;

1.37
date	2004.09.11.10.24.51;	author hilfingr;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.30.19.17.19;	author eliz;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.26.14.53.05;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.19.02.45.24;	author tausq;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.16.04.33.41;	author tausq;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.07.05.48.49;	author tausq;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.17.17.19.28;	author tausq;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.07.23.13.47;	author ezannoni;	state Exp;
branches
	1.30.4.1
	1.30.6.1;
next	1.29;

1.29
date	2004.02.07.18.29.54;	author ezannoni;	state Exp;
branches;
next	1.28;

1.28
date	2003.10.23.03.01.55;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.16.16.35.27;	author ezannoni;	state Exp;
branches;
next	1.26;

1.26
date	2003.09.01.02.11.07;	author chastain;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.17.23.25.08;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.25.21.36.19;	author carlton;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.01.23.34.05;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2003.01.14.00.49.04;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.09.18.30.32;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.03.00.13.45;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.08.20.02.51;	author cagney;	state Exp;
branches
	1.19.8.1
	1.19.10.1;
next	1.18;

1.18
date	2001.12.20.23.40.15;	author law;	state Exp;
branches
	1.18.6.1
	1.18.8.1;
next	1.17;

1.17
date	2001.11.01.16.17.08;	author fnf;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.30.17.34.30;	author fnf;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.30.04.05.34;	author fnf;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.24.01.19.12;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.19.04.58.17;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.06.22.22.03;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.04.04.15.27;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.06.08.21.17;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.16.18.03.22;	author chastain;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.15.01.01.49;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.27.22.30.29;	author ezannoni;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.04.16.52.34;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.21.14.24.45;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.10.03;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.09.28.21.52.32;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.10.05.23.08.49;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.10.12.04.37.24;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.11.17.02.30.29;	author jsm;	state Exp;
branches;
next	;

1.18.6.1
date	2002.06.15.16.42.55;	author cagney;	state Exp;
branches;
next	;

1.18.8.1
date	2002.06.20.01.33.01;	author kseitz;	state Exp;
branches;
next	;

1.19.8.1
date	2002.12.23.19.38.43;	author carlton;	state Exp;
branches;
next	1.19.8.2;

1.19.8.2
date	2003.02.07.19.17.52;	author carlton;	state Exp;
branches;
next	1.19.8.3;

1.19.8.3
date	2003.03.06.00.56.32;	author carlton;	state Exp;
branches;
next	1.19.8.4;

1.19.8.4
date	2003.04.16.19.56.54;	author carlton;	state Exp;
branches;
next	1.19.8.5;

1.19.8.5
date	2003.09.17.21.28.31;	author carlton;	state Exp;
branches;
next	1.19.8.6;

1.19.8.6
date	2003.11.11.23.50.55;	author carlton;	state Exp;
branches;
next	;

1.19.10.1
date	2003.12.14.20.27.30;	author drow;	state Exp;
branches;
next	1.19.10.2;

1.19.10.2
date	2004.02.09.19.43.48;	author drow;	state Exp;
branches;
next	;

1.30.4.1
date	2004.09.16.17.01.20;	author drow;	state Exp;
branches;
next	;

1.30.6.1
date	2004.06.04.17.03.25;	author tausq;	state Exp;
branches;
next	;


desc
@@


1.46
log
@* somsolib.c, somsolib.h: Remove files.
* Makefile.in (somsolib_h): Remove.
(somsolib.o): Remove dependency.
@
text
@/* Handle HP SOM shared libraries for GDB, the GNU Debugger.

   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002,
   2003, 2004 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.

   Written by the Center for Software Science at the Univerity of Utah
   and by Cygnus Support.  */


#include "defs.h"

#include "frame.h"
#include "bfd.h"
#include "som.h"
#include "libhppa.h"
#include "gdbcore.h"
#include "symtab.h"
#include "breakpoint.h"
#include "symfile.h"
#include "objfiles.h"
#include "inferior.h"
#include "gdb-stabs.h"
#include "gdb_stat.h"
#include "gdbcmd.h"
#include "language.h"
#include "regcache.h"
#include "gdb_assert.h"
#include "exec.h"
#include "hppa-tdep.h"

#include <fcntl.h>

#ifndef O_BINARY
#define O_BINARY 0
#endif

#ifndef SHL_LOAD
#define SHL_LOAD   	4
#endif

#ifndef SHL_UNLOAD
#define SHL_UNLOAD	8
#endif

/* Uncomment this to turn on some debugging output.
 */

/* #define SOLIB_DEBUG
 */

/* This lives in hppa-tdep.c. */
extern struct unwind_table_entry *find_unwind_entry (CORE_ADDR pc);

/* These ought to be defined in some public interface, but aren't.  They
   define the meaning of the various bits in the distinguished __dld_flags
   variable that is declared in every debuggable a.out on HP-UX, and that
   is shared between the debugger and the dynamic linker.
 */
#define DLD_FLAGS_MAPPRIVATE    0x1
#define DLD_FLAGS_HOOKVALID     0x2
#define DLD_FLAGS_LISTVALID     0x4
#define DLD_FLAGS_BOR_ENABLE    0x8

/* TODO:

   * Support for hpux8 dynamic linker.  */

/* The basic structure which describes a dynamically loaded object.  This
   data structure is private to the dynamic linker and isn't found in
   any HPUX include file.  */

struct som_solib_mapped_entry
  {
    /* The name of the library.  */
    char *name;

    /* Version of this structure (it is expected to change again in hpux10).  */
    unsigned char struct_version;

    /* Binding mode for this library.  */
    unsigned char bind_mode;

    /* Version of this library.  */
    short library_version;

    /* Start of text address,
     * link-time text location (length of text area),
     * end of text address.  */
    CORE_ADDR text_addr;
    CORE_ADDR text_link_addr;
    CORE_ADDR text_end;

    /* Start of data, start of bss and end of data.  */
    CORE_ADDR data_start;
    CORE_ADDR bss_start;
    CORE_ADDR data_end;

    /* Value of linkage pointer (%r19).  */
    CORE_ADDR got_value;

    /* Next entry.  */
    struct som_solib_mapped_entry *next;

    /* There are other fields, but I don't have information as to what is
       contained in them.  */

    /* For versions from HPUX-10.30 and up */

    /* Address in target of offset from thread-local register of
     * start of this thread's data.  I.e., the first thread-local
     * variable in this shared library starts at *(tsd_start_addr)
     * from that area pointed to by cr27 (mpsfu_hi).
     *
     * We do the indirection as soon as we read it, so from then
     * on it's the offset itself.
     */
    CORE_ADDR tsd_start_addr;

    /* Following this are longwords holding:

     * ?, ?, ?, ptr to -1, ptr to-1, ptr to lib name (leaf name),
     * ptr to __data_start, ptr to __data_end
     */


  };

/* A structure to keep track of all the known shared objects.  */
struct so_list
  {
    struct som_solib_mapped_entry som_solib;
    struct objfile *objfile;
    bfd *abfd;
    struct section_table *sections;
    struct section_table *sections_end;
/* elz: added this field to store the address in target space (in the
   library) of the library descriptor (handle) which we read into
   som_solib_mapped_entry structure */
    CORE_ADDR solib_addr;
    struct so_list *next;

  };

static struct so_list *so_list_head;


/* This is the cumulative size in bytes of the symbol tables of all
   shared objects on the so_list_head list.  (When we say size, here
   we mean of the information before it is brought into memory and
   potentially expanded by GDB.)  When adding a new shlib, this value
   is compared against the threshold size, held by auto_solib_limit
   (in megabytes).  If adding symbols for the new shlib would cause
   the total size to exceed the threshold, then the new shlib's
   symbols are not loaded.  */
static LONGEST som_solib_total_st_size;

/* When the threshold is reached for any shlib, we refuse to add
   symbols for subsequent shlibs, even if those shlibs' symbols would
   be small enough to fit under the threshold.  (Although this may
   result in one, early large shlib preventing the loading of later,
   smalller shlibs' symbols, it allows us to issue one informational
   message.  The alternative, to issue a message for each shlib whose
   symbols aren't loaded, could be a big annoyance where the threshold
   is exceeded due to a very large number of shlibs.)
 */
static int som_solib_st_size_threshold_exceeded;

/* These addresses should be filled in by som_solib_create_inferior_hook.
   They are also used elsewhere in this module.
 */
typedef struct
  {
    CORE_ADDR address;
    struct unwind_table_entry *unwind;
  }
addr_and_unwind_t;

/* When adding fields, be sure to clear them in _initialize_som_solib. */
static struct
  {
    int is_valid;
    addr_and_unwind_t hook;
    addr_and_unwind_t hook_stub;
    addr_and_unwind_t load;
    addr_and_unwind_t load_stub;
    addr_and_unwind_t unload;
    addr_and_unwind_t unload2;
    addr_and_unwind_t unload_stub;
  }
dld_cache;



static void som_sharedlibrary_info_command (char *, int);

static void som_solib_sharedlibrary_command (char *, int);

static LONGEST
som_solib_sizeof_symbol_table (char *filename)
{
  bfd *abfd;
  int desc;
  char *absolute_name;
  LONGEST st_size = (LONGEST) 0;
  asection *sect;

  /* We believe that filename was handed to us by the dynamic linker, and
     is therefore always an absolute path.
   */
  desc = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, filename,
		O_RDONLY | O_BINARY, 0, &absolute_name);
  if (desc < 0)
    {
      perror_with_name (filename);
    }
  filename = absolute_name;

  abfd = bfd_fdopenr (filename, gnutarget, desc);
  if (!abfd)
    {
      close (desc);
      make_cleanup (xfree, filename);
      error (_("\"%s\": can't open to read symbols: %s."), filename,
	     bfd_errmsg (bfd_get_error ()));
    }

  if (!bfd_check_format (abfd, bfd_object))	/* Reads in section info */
    {
      bfd_close (abfd);		/* This also closes desc */
      make_cleanup (xfree, filename);
      error (_("\"%s\": can't read symbols: %s."), filename,
	     bfd_errmsg (bfd_get_error ()));
    }

  /* Sum the sizes of the various sections that compose debug info. */

  /* This contains non-DOC information. */
  sect = bfd_get_section_by_name (abfd, "$DEBUG$");
  if (sect)
    st_size += (LONGEST) bfd_section_size (abfd, sect);

  /* This contains DOC information. */
  sect = bfd_get_section_by_name (abfd, "$PINFO$");
  if (sect)
    st_size += (LONGEST) bfd_section_size (abfd, sect);

  bfd_close (abfd);		/* This also closes desc */
  xfree (filename);

  /* Unfortunately, just summing the sizes of various debug info
     sections isn't a very accurate measurement of how much heap
     space the debugger will need to hold them.  It also doesn't
     account for space needed by linker (aka "minimal") symbols.

     Anecdotal evidence suggests that just summing the sizes of
     debug-info-related sections understates the heap space needed
     to represent it internally by about an order of magnitude.

     Since it's not exactly brain surgery we're doing here, rather
     than attempt to more accurately measure the size of a shlib's
     symbol table in GDB's heap, we'll just apply a 10x fudge-
     factor to the debug info sections' size-sum.  No, this doesn't
     account for minimal symbols in non-debuggable shlibs.  But it
     all roughly washes out in the end.
   */
  return st_size * (LONGEST) 10;
}


static void
som_solib_add_solib_objfile (struct so_list *so, char *name, int from_tty,
			     CORE_ADDR text_addr)
{
  struct hppa_objfile_private *obj_private;
  struct obj_section *s;

  so->objfile = symbol_file_add (name, from_tty, NULL, 0, OBJF_SHARED);
  so->abfd = so->objfile->obfd;

  /* syms_from_objfile has bizarre section offset code,
     so I do my own right here.  */
  for (s = so->objfile->sections; s < so->objfile->sections_end; s++)
    {
      flagword aflag = bfd_get_section_flags(so->abfd, s->the_bfd_section);
      if (aflag & SEC_CODE)
	{
	  s->addr    += so->som_solib.text_addr - so->som_solib.text_link_addr;
	  s->endaddr += so->som_solib.text_addr - so->som_solib.text_link_addr;
	}
      else if (aflag & SEC_DATA)
	{
	  s->addr    += so->som_solib.data_start;
	  s->endaddr += so->som_solib.data_start;
	}
      else
	;
    }
   
  /* Mark this as a shared library and save private data.
   */
  so->objfile->flags |= OBJF_SHARED;

  obj_private = (struct hppa_objfile_private *)
	        objfile_data (so->objfile, hppa_objfile_priv_data);
  if (obj_private == NULL)
    {
      obj_private = (struct hppa_objfile_private *)
	obstack_alloc (&so->objfile->objfile_obstack,
		       sizeof (struct hppa_objfile_private));
      set_objfile_data (so->objfile, hppa_objfile_priv_data, obj_private);
      obj_private->unwind_info = NULL;
      obj_private->so_info = NULL;
    }

  obj_private->so_info = so;

  if (!bfd_check_format (so->abfd, bfd_object))
    {
      error (_("\"%s\": not in executable format: %s."),
	     name, bfd_errmsg (bfd_get_error ()));
    }
}


static void
som_solib_load_symbols (struct so_list *so, char *name, int from_tty,
			CORE_ADDR text_addr, struct target_ops *target)
{
  struct section_table *p;
  int status;
  char buf[4];
  CORE_ADDR presumed_data_start;

#ifdef SOLIB_DEBUG
  printf ("--Adding symbols for shared library \"%s\"\n", name);
#endif

  som_solib_add_solib_objfile (so, name, from_tty, text_addr);

  /* Now we need to build a section table for this library since
     we might be debugging a core file from a dynamically linked
     executable in which the libraries were not privately mapped.  */
  if (build_section_table (so->abfd,
			   &so->sections,
			   &so->sections_end))
    {
      error (_("Unable to build section table for shared library\n."));
      return;
    }

  /* Relocate all the sections based on where they got loaded.  */
  for (p = so->sections; p < so->sections_end; p++)
    {
      if (p->the_bfd_section->flags & SEC_CODE)
	{
	  p->addr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_TEXT (so->objfile));
	  p->endaddr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_TEXT (so->objfile));
	}
      else if (p->the_bfd_section->flags & SEC_DATA)
	{
	  p->addr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_DATA (so->objfile));
	  p->endaddr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_DATA (so->objfile));
	}
    }

  /* Now see if we need to map in the text and data for this shared
     library (for example debugging a core file which does not use
     private shared libraries.). 

     Carefully peek at the first text address in the library.  If the
     read succeeds, then the libraries were privately mapped and were
     included in the core dump file.

     If the peek failed, then the libraries were not privately mapped
     and are not in the core file, we'll have to read them in ourselves.  */
  status = target_read_memory (text_addr, buf, 4);
  if (status != 0)
    {
      int old, new;

      new = so->sections_end - so->sections;
      
      old = target_resize_to_sections (target, new);
      
      /* Copy over the old data before it gets clobbered.  */
      memcpy ((char *) (target->to_sections + old),
	      so->sections,
	      ((sizeof (struct section_table)) * new));
    }
}


/* FIXME: cagney/2003-02-01: This just isn't right.  Given an address
   within the target's address space, this converts the value into an
   address within the host's (i.e., GDB's) address space.  Given that
   the host/target address spaces are separate, this can't be right.  */

static void *
hpux_address_to_host_pointer_hack (CORE_ADDR addr)
{
  void *ptr;

  gdb_assert (sizeof (ptr) == TYPE_LENGTH (builtin_type_void_data_ptr));
  ADDRESS_TO_POINTER (builtin_type_void_data_ptr, &ptr, addr);
  return ptr;
}

/* Add symbols from shared libraries into the symtab list, unless the
   size threshold specified by auto_solib_limit (in megabytes) would
   be exceeded.  */

void
som_solib_add (char *arg_string, int from_tty, struct target_ops *target, int readsyms)
{
  struct minimal_symbol *msymbol;
  struct so_list *so_list_tail;
  CORE_ADDR addr;
  asection *shlib_info;
  int status;
  unsigned int dld_flags;
  char buf[4], *re_err;
  int threshold_warning_given = 0;

  /* First validate our arguments.  */
  re_err = re_comp (arg_string ? arg_string : ".");
  if (re_err != NULL)
    {
      error (_("Invalid regexp: %s"), re_err);
    }

  /* If we're debugging a core file, or have attached to a running
     process, then som_solib_create_inferior_hook will not have been
     called.

     We need to first determine if we're dealing with a dynamically
     linked executable.  If not, then return without an error or warning.

     We also need to examine __dld_flags to determine if the shared library
     list is valid and to determine if the libraries have been privately
     mapped.  */
  if (symfile_objfile == NULL)
    return;

  /* First see if the objfile was dynamically linked.  */
  shlib_info = bfd_get_section_by_name (symfile_objfile->obfd, "$SHLIB_INFO$");
  if (!shlib_info)
    return;

  /* It's got a $SHLIB_INFO$ section, make sure it's not empty.  */
  if (bfd_section_size (symfile_objfile->obfd, shlib_info) == 0)
    return;

  msymbol = lookup_minimal_symbol ("__dld_flags", NULL, NULL);
  if (msymbol == NULL)
    error (_("Unable to find __dld_flags symbol in object file."));

  addr = SYMBOL_VALUE_ADDRESS (msymbol);
  /* Read the current contents.  */
  status = target_read_memory (addr, buf, 4);
  if (status != 0)
    error (_("Unable to read __dld_flags."));
  dld_flags = extract_unsigned_integer (buf, 4);

  /* __dld_list may not be valid.  If not, then we punt, warning the user if
     we were called as a result of the add-symfile command.
   */
  if ((dld_flags & DLD_FLAGS_LISTVALID) == 0)
    {
      if (from_tty)
	error (_("__dld_list is not valid according to __dld_flags."));
      return;
    }

  /* If the libraries were not mapped private, warn the user.  */
  if ((dld_flags & DLD_FLAGS_MAPPRIVATE) == 0)
    warning (_("\
The shared libraries were not privately mapped; setting a breakpoint\n\
in a shared library will not work until you rerun the program."));

  msymbol = lookup_minimal_symbol ("__dld_list", NULL, NULL);
  if (!msymbol)
    {
      /* Older crt0.o files (hpux8) don't have __dld_list as a symbol,
         but the data is still available if you know where to look.  */
      msymbol = lookup_minimal_symbol ("__dld_flags", NULL, NULL);
      if (!msymbol)
	error (_("Unable to find dynamic library list."));
      addr = SYMBOL_VALUE_ADDRESS (msymbol) - 8;
    }
  else
    addr = SYMBOL_VALUE_ADDRESS (msymbol);

  status = target_read_memory (addr, buf, 4);
  if (status != 0)
    error (_("Unable to find dynamic library list."));

  addr = extract_unsigned_integer (buf, 4);

  /* If addr is zero, then we're using an old dynamic loader which
     doesn't maintain __dld_list.  We'll have to use a completely
     different approach to get shared library information.  */
  if (addr == 0)
    goto old_dld;

  /* Using the information in __dld_list is the preferred method
     to get at shared library information.  It doesn't depend on
     any functions in /opt/langtools/lib/end.o and has a chance of working
     with hpux10 when it is released.  */
  status = target_read_memory (addr, buf, 4);
  if (status != 0)
    error (_("Unable to find dynamic library list."));

  /* addr now holds the address of the first entry in the dynamic
     library list.  */
  addr = extract_unsigned_integer (buf, 4);

  /* Now that we have a pointer to the dynamic library list, walk
     through it and add the symbols for each library.  */

  so_list_tail = so_list_head;
  /* Find the end of the list of shared objects.  */
  while (so_list_tail && so_list_tail->next)
    so_list_tail = so_list_tail->next;

#ifdef SOLIB_DEBUG
  printf ("--About to read shared library list data\n");
#endif

  /* "addr" will always point to the base of the
   * current data entry describing the current
   * shared library.
   */
  while (1)
    {
      CORE_ADDR name_addr, text_addr;
      unsigned int name_len;
      char *name;
      struct so_list *new_so;
      struct so_list *so_list = so_list_head;
      struct stat statbuf;
      LONGEST st_size;
      int is_main_program;

      if (addr == 0)
	break;

      /* Get a pointer to the name of this library.  */
      status = target_read_memory (addr, buf, 4);
      if (status != 0)
	goto err;

      name_addr = extract_unsigned_integer (buf, 4);
      name_len = 0;
      while (1)
	{
	  target_read_memory (name_addr + name_len, buf, 1);
	  if (status != 0)
	    goto err;

	  name_len++;
	  if (*buf == '\0')
	    break;
	}
      name = alloca (name_len);
      status = target_read_memory (name_addr, name, name_len);
      if (status != 0)
	goto err;

      /* See if we've already loaded something with this name.  */
      while (so_list)
	{
	  if (!strcmp (so_list->som_solib.name, name))
	    break;
	  so_list = so_list->next;
	}

      /* See if the file exists.  If not, give a warning, but don't
         die.  */
      status = stat (name, &statbuf);
      if (status == -1)
	{
	  warning (_("Can't find file %s referenced in dld_list."), name);

	  status = target_read_memory (addr + 36, buf, 4);
	  if (status != 0)
	    goto err;

	  addr = (CORE_ADDR) extract_unsigned_integer (buf, 4);
	  continue;
	}

      /* If we've already loaded this one or it's the main program, skip it.  */
      is_main_program = (strcmp (name, symfile_objfile->name) == 0);
      if (so_list || is_main_program)
	{
	  /* This is the "next" pointer in the strcuture.
	   */
	  status = target_read_memory (addr + 36, buf, 4);
	  if (status != 0)
	    goto err;

	  addr = (CORE_ADDR) extract_unsigned_integer (buf, 4);

	  /* Record the main program's symbol table size. */
	  if (is_main_program && !so_list)
	    {
	      st_size = som_solib_sizeof_symbol_table (name);
	      som_solib_total_st_size += st_size;
	    }

	  /* Was this a shlib that we noted but didn't load the symbols for?
	     If so, were we invoked this time from the command-line, via
	     a 'sharedlibrary' or 'add-symbol-file' command?  If yes to
	     both, we'd better load the symbols this time.
	   */
	  if (from_tty && so_list && !is_main_program && (so_list->objfile == NULL))
	    som_solib_load_symbols (so_list,
				    name,
				    from_tty,
				    so_list->som_solib.text_addr,
				    target);

	  continue;
	}

      name = obsavestring (name, name_len - 1,
			   &symfile_objfile->objfile_obstack);

      status = target_read_memory (addr + 8, buf, 4);
      if (status != 0)
	goto err;

      text_addr = extract_unsigned_integer (buf, 4);

      new_so = (struct so_list *) xmalloc (sizeof (struct so_list));
      memset ((char *) new_so, 0, sizeof (struct so_list));
      if (so_list_head == NULL)
	{
	  so_list_head = new_so;
	  so_list_tail = new_so;
	}
      else
	{
	  so_list_tail->next = new_so;
	  so_list_tail = new_so;
	}

      /* Fill in all the entries in GDB's shared library list.
       */

      new_so->solib_addr = addr;
      new_so->som_solib.name = name;
      status = target_read_memory (addr + 4, buf, 4);
      if (status != 0)
	goto err;

      new_so->som_solib.struct_version = extract_unsigned_integer (buf + 3, 1);
      new_so->som_solib.bind_mode = extract_unsigned_integer (buf + 2, 1);
      /* Following is "high water mark", highest version number
       * seen, rather than plain version number.
       */
      new_so->som_solib.library_version = extract_unsigned_integer (buf, 2);
      new_so->som_solib.text_addr = text_addr;

      /* Q: What about longword at "addr + 8"?
       * A: It's read above, out of order, into "text_addr".
       */

      status = target_read_memory (addr + 12, buf, 4);
      if (status != 0)
	goto err;

      new_so->som_solib.text_link_addr = extract_unsigned_integer (buf, 4);

      status = target_read_memory (addr + 16, buf, 4);
      if (status != 0)
	goto err;

      new_so->som_solib.text_end = extract_unsigned_integer (buf, 4);

      status = target_read_memory (addr + 20, buf, 4);
      if (status != 0)
	goto err;

      new_so->som_solib.data_start = extract_unsigned_integer (buf, 4);

      status = target_read_memory (addr + 24, buf, 4);
      if (status != 0)
	goto err;

      new_so->som_solib.bss_start = extract_unsigned_integer (buf, 4);

      status = target_read_memory (addr + 28, buf, 4);
      if (status != 0)
	goto err;

      new_so->som_solib.data_end = extract_unsigned_integer (buf, 4);

      status = target_read_memory (addr + 32, buf, 4);
      if (status != 0)
	goto err;

      new_so->som_solib.got_value = extract_unsigned_integer (buf, 4);

      status = target_read_memory (addr + 36, buf, 4);
      if (status != 0)
	goto err;

      /* FIXME: cagney/2003-02-01: I think som_solib.next should be a
         CORE_ADDR.  */
      new_so->som_solib.next =
	hpux_address_to_host_pointer_hack (extract_unsigned_integer (buf, 4));

      /* Note that we don't re-set "addr" to the next pointer
       * until after we've read the trailing data.
       */

      status = target_read_memory (addr + 40, buf, 4);
      new_so->som_solib.tsd_start_addr = extract_unsigned_integer (buf, 4);
      if (status != 0)
	goto err;

      /* Now indirect via that value!
       */
      status = target_read_memory (new_so->som_solib.tsd_start_addr, buf, 4);
      new_so->som_solib.tsd_start_addr = extract_unsigned_integer (buf, 4);
      if (status != 0)
	goto err;
#ifdef SOLIB_DEBUG
      printf ("\n+ library \"%s\" is described at 0x%x\n", name, addr);
      printf ("  'version' is %d\n", new_so->som_solib.struct_version);
      printf ("  'bind_mode' is %d\n", new_so->som_solib.bind_mode);
      printf ("  'library_version' is %d\n", new_so->som_solib.library_version);
      printf ("  'text_addr' is 0x%x\n", new_so->som_solib.text_addr);
      printf ("  'text_link_addr' is 0x%x\n", new_so->som_solib.text_link_addr);
      printf ("  'text_end' is 0x%x\n", new_so->som_solib.text_end);
      printf ("  'data_start' is 0x%x\n", new_so->som_solib.data_start);
      printf ("  'bss_start' is 0x%x\n", new_so->som_solib.bss_start);
      printf ("  'data_end' is 0x%x\n", new_so->som_solib.data_end);
      printf ("  'got_value' is %x\n", new_so->som_solib.got_value);
      printf ("  'next' is 0x%x\n", new_so->som_solib.next);
      printf ("  'tsd_start_addr' is 0x%x\n", new_so->som_solib.tsd_start_addr);
#endif

      /* Go on to the next shared library descriptor.
       */
      addr = (CORE_ADDR) new_so->som_solib.next;



      /* At this point, we have essentially hooked the shlib into the
         "info share" command.  However, we haven't yet loaded its
         symbol table.  We must now decide whether we ought to, i.e.,
         whether doing so would exceed the symbol table size threshold.

         If the threshold has just now been exceeded, then we'll issue
         a warning message (which explains how to load symbols manually,
         if the user so desires).

         If the threshold has just now or previously been exceeded,
         we'll just add the shlib to the list of object files, but won't
         actually load its symbols.  (This is more useful than it might
         sound, for it allows us to e.g., still load and use the shlibs'
         unwind information for stack tracebacks.)
       */

      /* Note that we DON'T want to preclude the user from using the
         add-symbol-file command!  Thus, we only worry about the threshold
         when we're invoked for other reasons.
       */
      st_size = som_solib_sizeof_symbol_table (name);
      som_solib_st_size_threshold_exceeded =
	!from_tty &&
	auto_solib_limit > 0 &&
	readsyms &&
	((st_size + som_solib_total_st_size) > (auto_solib_limit * (LONGEST) (1024 * 1024)));

      if (som_solib_st_size_threshold_exceeded)
	{
	  if (!threshold_warning_given)
	    warning (_("\
Symbols for some libraries have not been loaded, because doing so would\n\
exceed the size threshold specified by auto-solib-limit.\n\
To manually load symbols, use the 'sharedlibrary' command.\n\
To raise the threshold, set auto-solib-limit to a larger value and rerun\n\
the program."));
	  threshold_warning_given = 1;

	  /* We'll still make note of this shlib, even if we don't
	     read its symbols.  This allows us to use its unwind
	     information well enough to know how to e.g., correctly
	     do a traceback from a PC within the shlib, even if we
	     can't symbolize those PCs...
	   */
	  som_solib_add_solib_objfile (new_so, name, from_tty, text_addr);
	  continue;
	}

      som_solib_total_st_size += st_size;

      /* This fills in new_so->objfile, among others. */
      som_solib_load_symbols (new_so, name, from_tty, text_addr, target);
    }

#ifdef SOLIB_DEBUG
  printf ("--Done reading shared library data\n");
#endif

  /* Getting new symbols may change our opinion about what is
     frameless.  */
  reinit_frame_cache ();
  return;

old_dld:
  error (_("Debugging dynamic executables loaded via the hpux8 dld.sl is not supported."));

err:
  error (_("Error while reading dynamic library list."));
}


/* This hook gets called just before the first instruction in the
   inferior process is executed.

   This is our opportunity to set magic flags in the inferior so
   that GDB can be notified when a shared library is mapped in and
   to tell the dynamic linker that a private copy of the library is
   needed (so GDB can set breakpoints in the library).

   __dld_flags is the location of the magic flags; as of this implementation
   there are 3 flags of interest:

   bit 0 when set indicates that private copies of the libraries are needed
   bit 1 when set indicates that the callback hook routine is valid
   bit 2 when set indicates that the dynamic linker should maintain the
   __dld_list structure when loading/unloading libraries.

   Note that shared libraries are not mapped in at this time, so we have
   run the inferior until the libraries are mapped in.  Typically this
   means running until the "_start" is called.  */

void
som_solib_create_inferior_hook (void)
{
  struct minimal_symbol *msymbol;
  unsigned int dld_flags, status, have_endo;
  asection *shlib_info;
  char buf[4];
  struct objfile *objfile;
  CORE_ADDR anaddr;

  /* First, remove all the solib event breakpoints.  Their addresses
     may have changed since the last time we ran the program.  */
  remove_solib_event_breakpoints ();

  if (symfile_objfile == NULL)
    return;

  /* First see if the objfile was dynamically linked.  */
  shlib_info = bfd_get_section_by_name (symfile_objfile->obfd, "$SHLIB_INFO$");
  if (!shlib_info)
    return;

  /* It's got a $SHLIB_INFO$ section, make sure it's not empty.  */
  if (bfd_section_size (symfile_objfile->obfd, shlib_info) == 0)
    return;

  have_endo = 0;
  /* Slam the pid of the process into __d_pid.

     We used to warn when this failed, but that warning is only useful
     on very old HP systems (hpux9 and older).  The warnings are an
     annoyance to users of modern systems and foul up the testsuite as
     well.  As a result, the warnings have been disabled.  */
  msymbol = lookup_minimal_symbol ("__d_pid", NULL, symfile_objfile);
  if (msymbol == NULL)
    goto keep_going;

  anaddr = SYMBOL_VALUE_ADDRESS (msymbol);
  store_unsigned_integer (buf, 4, PIDGET (inferior_ptid));
  status = target_write_memory (anaddr, buf, 4);
  if (status != 0)
    {
      warning (_("Unable to write __d_pid"));
      warning (_("Suggest linking with /opt/langtools/lib/end.o."));
      warning (_("GDB will be unable to track shl_load/shl_unload calls"));
      goto keep_going;
    }

  /* Get the value of _DLD_HOOK (an export stub) and put it in __dld_hook;
     This will force the dynamic linker to call __d_trap when significant
     events occur.

     Note that the above is the pre-HP-UX 9.0 behaviour.  At 9.0 and above,
     the dld provides an export stub named "__d_trap" as well as the
     function named "__d_trap" itself, but doesn't provide "_DLD_HOOK".
     We'll look first for the old flavor and then the new.
   */
  msymbol = lookup_minimal_symbol ("_DLD_HOOK", NULL, symfile_objfile);
  if (msymbol == NULL)
    msymbol = lookup_minimal_symbol ("__d_trap", NULL, symfile_objfile);
  if (msymbol == NULL)
    {
      warning (_("Unable to find _DLD_HOOK symbol in object file."));
      warning (_("Suggest linking with /opt/langtools/lib/end.o."));
      warning (_("GDB will be unable to track shl_load/shl_unload calls"));
      goto keep_going;
    }
  anaddr = SYMBOL_VALUE_ADDRESS (msymbol);
  dld_cache.hook.address = anaddr;

  /* Grrr, this might not be an export symbol!  We have to find the
     export stub.  */
  ALL_OBJFILES (objfile)
  {
    struct unwind_table_entry *u;
    struct minimal_symbol *msymbol2;

    /* What a crock.  */
    msymbol2 = lookup_minimal_symbol_solib_trampoline (DEPRECATED_SYMBOL_NAME (msymbol),
						       objfile);
    /* Found a symbol with the right name.  */
    if (msymbol2)
      {
	struct unwind_table_entry *u;
	/* It must be a shared library trampoline.  */
	if (SYMBOL_TYPE (msymbol2) != mst_solib_trampoline)
	  continue;

	/* It must also be an export stub.  */
	u = find_unwind_entry (SYMBOL_VALUE (msymbol2));
	if (!u || u->stub_unwind.stub_type != EXPORT)
	  continue;

	/* OK.  Looks like the correct import stub.  */
	anaddr = SYMBOL_VALUE (msymbol2);
	dld_cache.hook_stub.address = anaddr;
      }
  }
  store_unsigned_integer (buf, 4, anaddr);

  msymbol = lookup_minimal_symbol ("__dld_hook", NULL, symfile_objfile);
  if (msymbol == NULL)
    {
      warning (_("Unable to find __dld_hook symbol in object file."));
      warning (_("Suggest linking with /opt/langtools/lib/end.o."));
      warning (_("GDB will be unable to track shl_load/shl_unload calls"));
      goto keep_going;
    }
  anaddr = SYMBOL_VALUE_ADDRESS (msymbol);
  status = target_write_memory (anaddr, buf, 4);

  /* Now set a shlib_event breakpoint at __d_trap so we can track
     significant shared library events.  */
  msymbol = lookup_minimal_symbol ("__d_trap", NULL, symfile_objfile);
  if (msymbol == NULL)
    {
      warning (_("Unable to find __dld_d_trap symbol in object file."));
      warning (_("Suggest linking with /opt/langtools/lib/end.o."));
      warning (_("GDB will be unable to track shl_load/shl_unload calls"));
      goto keep_going;
    }
  create_solib_event_breakpoint (SYMBOL_VALUE_ADDRESS (msymbol));

  /* We have all the support usually found in end.o, so we can track
     shl_load and shl_unload calls.  */
  have_endo = 1;

keep_going:

  /* Get the address of __dld_flags, if no such symbol exists, then we can
     not debug the shared code.  */
  msymbol = lookup_minimal_symbol ("__dld_flags", NULL, NULL);
  if (msymbol == NULL)
    error (_("Unable to find __dld_flags symbol in object file."));

  anaddr = SYMBOL_VALUE_ADDRESS (msymbol);

  /* Read the current contents.  */
  status = target_read_memory (anaddr, buf, 4);
  if (status != 0)
    error (_("Unable to read __dld_flags."));
  dld_flags = extract_unsigned_integer (buf, 4);

  /* Turn on the flags we care about.  */
  dld_flags |= DLD_FLAGS_MAPPRIVATE;
  if (have_endo)
    dld_flags |= DLD_FLAGS_HOOKVALID;
  store_unsigned_integer (buf, 4, dld_flags);
  status = target_write_memory (anaddr, buf, 4);
  if (status != 0)
    error (_("Unable to write __dld_flags."));

  /* Now find the address of _start and set a breakpoint there. 
     We still need this code for two reasons:

     * Not all sites have /opt/langtools/lib/end.o, so it's not always
     possible to track the dynamic linker's events.

     * At this time no events are triggered for shared libraries
     loaded at startup time (what a crock).  */

  msymbol = lookup_minimal_symbol ("_start", NULL, symfile_objfile);
  if (msymbol == NULL)
    error (_("Unable to find _start symbol in object file."));

  anaddr = SYMBOL_VALUE_ADDRESS (msymbol);

  /* Make the breakpoint at "_start" a shared library event breakpoint.  */
  create_solib_event_breakpoint (anaddr);

  /* Wipe out all knowledge of old shared libraries since their
     mapping can change from one exec to another!  */
  while (so_list_head)
    {
      struct so_list *temp;

      temp = so_list_head;
      xfree (so_list_head);
      so_list_head = temp->next;
    }
  clear_symtab_users ();
}

/* This operation removes the "hook" between GDB and the dynamic linker,
   which causes the dld to notify GDB of shared library events.

   After this operation completes, the dld will no longer notify GDB of
   shared library events.  To resume notifications, GDB must call
   som_solib_create_inferior_hook.

   This operation does not remove any knowledge of shared libraries 
   of which GDB may already have been notified.
 */
void
som_solib_remove_inferior_hook (int pid)
{
  CORE_ADDR addr;
  struct minimal_symbol *msymbol;
  int status;
  char dld_flags_buffer[4];
  unsigned int dld_flags_value;
  struct cleanup *old_cleanups = save_inferior_ptid ();

  /* Ensure that we're really operating on the specified process. */
  inferior_ptid = pid_to_ptid (pid);

  /* We won't bother to remove the solib breakpoints from this process.

     In fact, on PA64 the breakpoint is hard-coded into the dld callback,
     and thus we're not supposed to remove it.

     Rather, we'll merely clear the dld_flags bit that enables callbacks.
   */
  msymbol = lookup_minimal_symbol ("__dld_flags", NULL, NULL);

  addr = SYMBOL_VALUE_ADDRESS (msymbol);
  status = target_read_memory (addr, dld_flags_buffer, 4);

  dld_flags_value = extract_unsigned_integer (dld_flags_buffer, 4);

  dld_flags_value &= ~DLD_FLAGS_HOOKVALID;
  store_unsigned_integer (dld_flags_buffer, 4, dld_flags_value);
  status = target_write_memory (addr, dld_flags_buffer, 4);

  do_cleanups (old_cleanups);
}


/* This function creates a breakpoint on the dynamic linker hook, which
   is called when e.g., a shl_load or shl_unload call is made.  This
   breakpoint will only trigger when a shl_load call is made.

   If filename is NULL, then loads of any dll will be caught.  Else,
   only loads of the file whose pathname is the string contained by
   filename will be caught.

   Undefined behaviour is guaranteed if this function is called before
   som_solib_create_inferior_hook.
 */
void
som_solib_create_catch_load_hook (int pid, int tempflag, char *filename,
				  char *cond_string)
{
  create_solib_load_event_breakpoint ("__d_trap", tempflag, 
				      filename, cond_string);
}

/* This function creates a breakpoint on the dynamic linker hook, which
   is called when e.g., a shl_load or shl_unload call is made.  This
   breakpoint will only trigger when a shl_unload call is made.

   If filename is NULL, then unloads of any dll will be caught.  Else,
   only unloads of the file whose pathname is the string contained by
   filename will be caught.

   Undefined behaviour is guaranteed if this function is called before
   som_solib_create_inferior_hook.
 */
void
som_solib_create_catch_unload_hook (int pid, int tempflag, char *filename,
				    char *cond_string)
{
  create_solib_unload_event_breakpoint ("__d_trap", tempflag, 
					filename, cond_string);
}

int
som_solib_have_load_event (int pid)
{
  CORE_ADDR event_kind;

  event_kind = read_register (HPPA_ARG0_REGNUM);
  return (event_kind == SHL_LOAD);
}

int
som_solib_have_unload_event (int pid)
{
  CORE_ADDR event_kind;

  event_kind = read_register (HPPA_ARG0_REGNUM);
  return (event_kind == SHL_UNLOAD);
}

static char *
som_solib_library_pathname (int pid)
{
  CORE_ADDR dll_handle_address;
  CORE_ADDR dll_pathname_address;
  struct som_solib_mapped_entry dll_descriptor;
  char *p;
  static char dll_pathname[1024];

  /* Read the descriptor of this newly-loaded library. */
  dll_handle_address = read_register (HPPA_ARG1_REGNUM);
  read_memory (dll_handle_address, (char *) &dll_descriptor, sizeof (dll_descriptor));

  /* We can find a pointer to the dll's pathname within the descriptor. */
  dll_pathname_address = (CORE_ADDR) dll_descriptor.name;

  /* Read the pathname, one byte at a time. */
  p = dll_pathname;
  for (;;)
    {
      char b;
      read_memory (dll_pathname_address++, (char *) &b, 1);
      *p++ = b;
      if (b == '\0')
	break;
    }

  return dll_pathname;
}

char *
som_solib_loaded_library_pathname (int pid)
{
  if (!som_solib_have_load_event (pid))
    error (_("Must have a load event to use this query"));

  return som_solib_library_pathname (pid);
}

char *
som_solib_unloaded_library_pathname (int pid)
{
  if (!som_solib_have_unload_event (pid))
    error (_("Must have an unload event to use this query"));

  return som_solib_library_pathname (pid);
}

static void
som_solib_desire_dynamic_linker_symbols (void)
{
  struct objfile *objfile;
  struct unwind_table_entry *u;
  struct minimal_symbol *dld_msymbol;

  /* Do we already know the value of these symbols?  If so, then
     we've no work to do.

     (If you add clauses to this test, be sure to likewise update the
     test within the loop.)
   */
  if (dld_cache.is_valid)
    return;

  ALL_OBJFILES (objfile)
  {
    dld_msymbol = lookup_minimal_symbol ("shl_load", NULL, objfile);
    if (dld_msymbol != NULL)
      {
	dld_cache.load.address = SYMBOL_VALUE (dld_msymbol);
	dld_cache.load.unwind = find_unwind_entry (dld_cache.load.address);
      }

    dld_msymbol = lookup_minimal_symbol_solib_trampoline ("shl_load",
							  objfile);
    if (dld_msymbol != NULL)
      {
	if (SYMBOL_TYPE (dld_msymbol) == mst_solib_trampoline)
	  {
	    u = find_unwind_entry (SYMBOL_VALUE (dld_msymbol));
	    if ((u != NULL) && (u->stub_unwind.stub_type == EXPORT))
	      {
		dld_cache.load_stub.address = SYMBOL_VALUE (dld_msymbol);
		dld_cache.load_stub.unwind = u;
	      }
	  }
      }

    dld_msymbol = lookup_minimal_symbol ("shl_unload", NULL, objfile);
    if (dld_msymbol != NULL)
      {
	dld_cache.unload.address = SYMBOL_VALUE (dld_msymbol);
	dld_cache.unload.unwind = find_unwind_entry (dld_cache.unload.address);

	/* ??rehrauer: I'm not sure exactly what this is, but it appears
	   that on some HPUX 10.x versions, there's two unwind regions to
	   cover the body of "shl_unload", the second being 4 bytes past
	   the end of the first.  This is a large hack to handle that
	   case, but since I don't seem to have any legitimate way to
	   look for this thing via the symbol table...
	 */
	if (dld_cache.unload.unwind != NULL)
	  {
	    u = find_unwind_entry (dld_cache.unload.unwind->region_end + 4);
	    if (u != NULL)
	      {
		dld_cache.unload2.address = u->region_start;
		dld_cache.unload2.unwind = u;
	      }
	  }
      }

    dld_msymbol = lookup_minimal_symbol_solib_trampoline ("shl_unload",
							  objfile);
    if (dld_msymbol != NULL)
      {
	if (SYMBOL_TYPE (dld_msymbol) == mst_solib_trampoline)
	  {
	    u = find_unwind_entry (SYMBOL_VALUE (dld_msymbol));
	    if ((u != NULL) && (u->stub_unwind.stub_type == EXPORT))
	      {
		dld_cache.unload_stub.address = SYMBOL_VALUE (dld_msymbol);
		dld_cache.unload_stub.unwind = u;
	      }
	  }
      }

    /* Did we find everything we were looking for?  If so, stop. */
    if ((dld_cache.load.address != 0)
	&& (dld_cache.load_stub.address != 0)
	&& (dld_cache.unload.address != 0)
	&& (dld_cache.unload_stub.address != 0))
      {
	dld_cache.is_valid = 1;
	break;
      }
  }

  dld_cache.hook.unwind = find_unwind_entry (dld_cache.hook.address);
  dld_cache.hook_stub.unwind = find_unwind_entry (dld_cache.hook_stub.address);

  /* We're prepared not to find some of these symbols, which is why
     this function is a "desire" operation, and not a "require".
   */
}

int
som_solib_in_dynamic_linker (int pid, CORE_ADDR pc)
{
  struct unwind_table_entry *u_pc;

  /* Are we in the dld itself?

     ??rehrauer: Large hack -- We'll assume that any address in a
     shared text region is the dld's text.  This would obviously
     fall down if the user attached to a process, whose shlibs
     weren't mapped to a (writeable) private region.  However, in
     that case the debugger probably isn't able to set the fundamental
     breakpoint in the dld callback anyways, so this hack should be
     safe.
   */
  if ((pc & (CORE_ADDR) 0xc0000000) == (CORE_ADDR) 0xc0000000)
    return 1;

  /* Cache the address of some symbols that are part of the dynamic
     linker, if not already known.
   */
  som_solib_desire_dynamic_linker_symbols ();

  /* Are we in the dld callback?  Or its export stub? */
  u_pc = find_unwind_entry (pc);
  if (u_pc == NULL)
    return 0;

  if ((u_pc == dld_cache.hook.unwind) || (u_pc == dld_cache.hook_stub.unwind))
    return 1;

  /* Or the interface of the dld (i.e., "shl_load" or friends)? */
  if ((u_pc == dld_cache.load.unwind)
      || (u_pc == dld_cache.unload.unwind)
      || (u_pc == dld_cache.unload2.unwind)
      || (u_pc == dld_cache.load_stub.unwind)
      || (u_pc == dld_cache.unload_stub.unwind))
    return 1;

  /* Apparently this address isn't part of the dld's text. */
  return 0;
}


/* Return the GOT value for the shared library in which ADDR belongs.  If
   ADDR isn't in any known shared library, return zero.  */

CORE_ADDR
som_solib_get_got_by_pc (CORE_ADDR addr)
{
  struct so_list *so_list = so_list_head;
  CORE_ADDR got_value = 0;

  while (so_list)
    {
      if (so_list->som_solib.text_addr <= addr
	  && so_list->som_solib.text_end > addr)
	{
	  got_value = so_list->som_solib.got_value;
	  break;
	}
      so_list = so_list->next;
    }
  return got_value;
}

/*  elz:
   Return the address of the handle of the shared library
   in which ADDR belongs.  If
   ADDR isn't in any known shared library, return zero.  */
/* this function is used in hppa_fix_call_dummy in hppa-tdep.c */

CORE_ADDR
som_solib_get_solib_by_pc (CORE_ADDR addr)
{
  struct so_list *so_list = so_list_head;

  while (so_list)
    {
      if (so_list->som_solib.text_addr <= addr
	  && so_list->som_solib.text_end > addr)
	{
	  break;
	}
      so_list = so_list->next;
    }
  if (so_list)
    return so_list->solib_addr;
  else
    return 0;
}


int
som_solib_section_offsets (struct objfile *objfile,
			   struct section_offsets *offsets)
{
  struct so_list *so_list = so_list_head;

  while (so_list)
    {
      /* Oh what a pain!  We need the offsets before so_list->objfile
         is valid.  The BFDs will never match.  Make a best guess.  */
      if (strstr (objfile->name, so_list->som_solib.name))
	{
	  asection *private_section;

	  /* The text offset is easy.  */
	  offsets->offsets[SECT_OFF_TEXT (objfile)]
	    = (so_list->som_solib.text_addr
	       - so_list->som_solib.text_link_addr);
	  offsets->offsets[SECT_OFF_RODATA (objfile)]
	    = ANOFFSET (offsets, SECT_OFF_TEXT (objfile));

	  /* We should look at presumed_dp in the SOM header, but
	     that's not easily available.  This should be OK though.  */
	  private_section = bfd_get_section_by_name (objfile->obfd,
						     "$PRIVATE$");
	  if (!private_section)
	    {
	      warning (_("Unable to find $PRIVATE$ in shared library!"));
	      offsets->offsets[SECT_OFF_DATA (objfile)] = 0;
	      offsets->offsets[SECT_OFF_BSS (objfile)] = 0;
	      return 1;
	    }
	  offsets->offsets[SECT_OFF_DATA (objfile)]
	    = (so_list->som_solib.data_start - private_section->vma);
	  offsets->offsets[SECT_OFF_BSS (objfile)]
	    = ANOFFSET (offsets, SECT_OFF_DATA (objfile));
	  return 1;
	}
      so_list = so_list->next;
    }
  return 0;
}

/* Dump information about all the currently loaded shared libraries.  */

static void
som_sharedlibrary_info_command (char *ignore, int from_tty)
{
  struct so_list *so_list = so_list_head;

  if (exec_bfd == NULL)
    {
      printf_unfiltered ("No executable file.\n");
      return;
    }

  if (so_list == NULL)
    {
      printf_unfiltered ("No shared libraries loaded at this time.\n");
      return;
    }

  printf_unfiltered ("Shared Object Libraries\n");
  printf_unfiltered ("    %-12s%-12s%-12s%-12s%-12s%-12s\n",
	 "  flags", "  tstart", "   tend", "  dstart", "   dend", "   dlt");
  while (so_list)
    {
      unsigned int flags;

      flags = so_list->som_solib.struct_version << 24;
      flags |= so_list->som_solib.bind_mode << 16;
      flags |= so_list->som_solib.library_version;
      printf_unfiltered ("%s", so_list->som_solib.name);
      if (so_list->objfile == NULL)
	printf_unfiltered ("  (symbols not loaded)");
      printf_unfiltered ("\n");
      printf_unfiltered ("    %-12s", hex_string_custom (flags, 8));
      printf_unfiltered ("%-12s",
			 hex_string_custom (so_list->som_solib.text_addr, 8));
      printf_unfiltered ("%-12s",
			 hex_string_custom (so_list->som_solib.text_end, 8));
      printf_unfiltered ("%-12s",
			 hex_string_custom (so_list->som_solib.data_start, 8));
      printf_unfiltered ("%-12s",
			 hex_string_custom (so_list->som_solib.data_end, 8));
      printf_unfiltered ("%-12s\n",
			 hex_string_custom (so_list->som_solib.got_value, 8));
      so_list = so_list->next;
    }
}

static void
som_solib_sharedlibrary_command (char *args, int from_tty)
{
  dont_repeat ();
  som_solib_add (args, from_tty, (struct target_ops *) 0, 1);
}



char *
som_solib_address (CORE_ADDR addr)
{
  struct so_list *so = so_list_head;

  while (so)
    {
      /* Is this address within this shlib's text range?  If so,
         return the shlib's name.
       */
      if ((addr >= so->som_solib.text_addr) && (addr <= so->som_solib.text_end))
	return so->som_solib.name;

      /* Nope, keep looking... */
      so = so->next;
    }

  /* No, we couldn't prove that the address is within a shlib. */
  return NULL;
}


void
som_solib_restart (void)
{
  struct so_list *sl = so_list_head;

  /* Before the shlib info vanishes, use it to disable any breakpoints
     that may still be active in those shlibs.
   */
  disable_breakpoints_in_shlibs (0);

  /* Discard all the shlib descriptors.
   */
  while (sl)
    {
      struct so_list *next_sl = sl->next;
      xfree (sl);
      sl = next_sl;
    }
  so_list_head = NULL;

  som_solib_total_st_size = (LONGEST) 0;
  som_solib_st_size_threshold_exceeded = 0;

  dld_cache.is_valid = 0;

  dld_cache.hook.address = 0;
  dld_cache.hook.unwind = NULL;

  dld_cache.hook_stub.address = 0;
  dld_cache.hook_stub.unwind = NULL;

  dld_cache.load.address = 0;
  dld_cache.load.unwind = NULL;

  dld_cache.load_stub.address = 0;
  dld_cache.load_stub.unwind = NULL;

  dld_cache.unload.address = 0;
  dld_cache.unload.unwind = NULL;

  dld_cache.unload2.address = 0;
  dld_cache.unload2.unwind = NULL;

  dld_cache.unload_stub.address = 0;
  dld_cache.unload_stub.unwind = NULL;
}


void
_initialize_som_solib (void)
{
  add_com ("sharedlibrary", class_files, som_solib_sharedlibrary_command,
	   _("Load shared object library symbols for files matching REGEXP."));
  add_info ("sharedlibrary", som_sharedlibrary_info_command,
	    _("Status of loaded shared object libraries."));

  add_setshow_boolean_cmd ("auto-solib-add", class_support,
			   &auto_solib_add, _("\
Set autoloading of shared library symbols."), _("\
Show autoloading of shared library symbols."), _("\
If \"on\", symbols from all shared object libraries will be loaded\n\
automatically when the inferior begins execution, when the dynamic linker\n\
informs gdb that a new library has been loaded, or when attaching to the\n\
inferior.  Otherwise, symbols must be loaded manually, using `sharedlibrary'."),
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_zinteger_cmd ("auto-solib-limit", class_support,
			    &auto_solib_limit, _("\
Set threshold (in Mb) for autoloading shared library symbols."), _("\
Show threshold (in Mb) for autoloading shared library symbols."), _("\
When shared library autoloading is enabled, new libraries will be loaded\n\
only until the total size of shared library symbols exceeds this\n\
threshold in megabytes.  Is ignored when using `sharedlibrary'."),
			    NULL,
			    NULL, /* FIXME: i18n: */
			    &setlist, &showlist);

  /* ??rehrauer: On HP-UX, the kernel parameter MAXDSIZ limits how
     much data space a process can use.  We ought to be reading
     MAXDSIZ and setting auto_solib_limit to some large fraction of
     that value.  If not that, we maybe ought to be setting it smaller
     than the default for MAXDSIZ (that being 64Mb, I believe).
     However, [1] this threshold is only crudely approximated rather
     than actually measured, and [2] 50 Mbytes is too small for
     debugging gdb itself.  Thus, the arbitrary 100 figure.  */
  auto_solib_limit = 100;	/* Megabytes */

  som_solib_restart ();
}

/* Get some HPUX-specific data from a shared lib.
 */
CORE_ADDR
som_solib_thread_start_addr (struct so_list *so)
{
  return so->som_solib.tsd_start_addr;
}

#ifdef PA_SOM_ONLY
void
no_shared_libraries (char *ignored, int from_tty)
{
}
#endif
@


1.45
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_zinteger_cmd through out.  Re-sync gdbarch.sh
	and gdbarch.c.
	* breakpoint.c, frame.c, gdb-events.sh, gdbarch.sh: Update.
	* gdbtypes.c, infrun.c, linux-nat.c, maint.c, monitor.c: Update.
	* pa64solib.c, parse.c, remote-mips.c, ser-go32.c: Update.
	* serial.c, solib-frv.c, somsolib.c, target.c, top.c: Update.
	* varobj.c, cli/cli-cmds.c: Update.
	* gdbarch.c, gdb-events.c: Regenerate.
@
text
@@


1.44
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_boolean_command through out.  Delete #ifdef 0'ed
	code adding set/show boolean commands.
	* cp-valprint.c, dcache.c, exec.c, gdbtypes.c, infrun.c: Update.
	* monitor.c, p-valprint.c, pa64solib.c, printcmd.c: Update.
	* proc-api.c, remote-mips.c, remote.c, solib.c: Update.
	* somsolib.c, symfile.c, top.c, utils.c, valops.c: Update.
	* valprint.c, win32-nat.c, wince.c, xcoffsolib.c: Update.
	* cli/cli-cmds.c: Update.
@
text
@d1572 4
a1575 4
  deprecated_add_show_from_set
    (add_set_cmd ("auto-solib-limit", class_support, var_zinteger,
		  (char *) &auto_solib_limit,
		  "Set threshold (in Mb) for autoloading shared library symbols.\n\
d1578 4
a1581 3
threshold in megabytes.  Is ignored when using `sharedlibrary'.",
		  &setlist),
     &showlist);
@


1.43
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d1560 4
a1563 4
  deprecated_add_show_from_set
    (add_set_cmd ("auto-solib-add", class_support, var_boolean,
		  (char *) &auto_solib_add,
		  "Set autoloading of shared library symbols.\n\
d1567 4
a1570 3
inferior.  Otherwise, symbols must be loaded manually, using `sharedlibrary'.",
		  &setlist),
     &showlist);
@


1.42
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d1556 1
a1556 1
	   "Load shared object library symbols for files matching REGEXP.");
d1558 1
a1558 1
	    "Status of loaded shared object libraries.");
@


1.41
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d832 1
a832 1
  error (_("Debugging dynamic executables loaded via the hpux8 dld.sl is not supported.));
@


1.40
log
@2005-01-13  Michael Snyder  <msnyder@@redhat.com>

	* somsolib.[ch]: Whitespace tweaks.
@
text
@d240 1
a240 1
      error ("\"%s\": can't open to read symbols: %s.", filename,
d248 1
a248 1
      error ("\"%s\": can't read symbols: %s.", filename,
d336 1
a336 1
      error ("\"%s\": not in executable format: %s.",
d364 1
a364 1
      error ("Unable to build section table for shared library\n.");
d445 1
a445 1
      error ("Invalid regexp: %s", re_err);
d472 1
a472 4
    {
      error ("Unable to find __dld_flags symbol in object file.\n");
      return;
    }
d478 1
a478 4
    {
      error ("Unable to read __dld_flags\n");
      return;
    }
d487 1
a487 1
	error ("__dld_list is not valid according to __dld_flags.\n");
d493 3
a495 1
    warning ("The shared libraries were not privately mapped; setting a\nbreakpoint in a shared library will not work until you rerun the program.\n");
d504 1
a504 4
	{
	  error ("Unable to find dynamic library list.\n");
	  return;
	}
d512 1
a512 4
    {
      error ("Unable to find dynamic library list.\n");
      return;
    }
d528 1
a528 4
    {
      error ("Unable to find dynamic library list.\n");
      return;
    }
d599 1
a599 1
	  warning ("Can't find file %s referenced in dld_list.", name);
d798 6
a803 1
	    warning ("Symbols for some libraries have not been loaded, because\ndoing so would exceed the size threshold specified by auto-solib-limit.\nTo manually load symbols, use the 'sharedlibrary' command.\nTo raise the threshold, set auto-solib-limit to a larger value and rerun\nthe program.\n");
d832 1
a832 2
  error ("Debugging dynamic executables loaded via the hpux8 dld.sl is not supported.\n");
  return;
d835 1
a835 2
  error ("Error while reading dynamic library list.\n");
  return;
d901 3
a903 3
      warning ("Unable to write __d_pid");
      warning ("Suggest linking with /opt/langtools/lib/end.o.");
      warning ("GDB will be unable to track shl_load/shl_unload calls");
d921 3
a923 3
      warning ("Unable to find _DLD_HOOK symbol in object file.");
      warning ("Suggest linking with /opt/langtools/lib/end.o.");
      warning ("GDB will be unable to track shl_load/shl_unload calls");
d962 3
a964 3
      warning ("Unable to find __dld_hook symbol in object file.");
      warning ("Suggest linking with /opt/langtools/lib/end.o.");
      warning ("GDB will be unable to track shl_load/shl_unload calls");
d975 3
a977 3
      warning ("Unable to find __dld_d_trap symbol in object file.");
      warning ("Suggest linking with /opt/langtools/lib/end.o.");
      warning ("GDB will be unable to track shl_load/shl_unload calls");
d992 1
a992 3
    {
      error ("Unable to find __dld_flags symbol in object file.\n");
    }
d999 1
a999 3
    {
      error ("Unable to read __dld_flags\n");
    }
d1009 1
a1009 3
    {
      error ("Unable to write __dld_flags\n");
    }
d1022 1
a1022 3
    {
      error ("Unable to find _start symbol in object file.\n");
    }
d1177 1
a1177 1
    error ("Must have a load event to use this query");
d1186 1
a1186 1
    error ("Must have an unload event to use this query");
d1409 1
a1409 1
	      warning ("Unable to find $PRIVATE$ in shared library!");
@


1.39
log
@* somsolib.c [PA_SOM_ONLY] (no_shared_libraries): New function.
* config/pa/hppahpux.mt (TDEPFILES): Remove solib.o.
@
text
@d1067 2
a1068 2
   This operation does not remove any knowledge of shared libraries which
   GDB may already have been notified of.
d1120 2
a1121 1
  create_solib_load_event_breakpoint ("__d_trap", tempflag, filename, cond_string);
d1139 2
a1140 1
  create_solib_unload_event_breakpoint ("__d_trap", tempflag, filename, cond_string);
@


1.38
log
@2004-11-12  Randolph Chung  <tausq@@debian.org>

	* pa64solib.c (pa64_solib_thread_start_addr): Rename from
	so_lib_thread_start_addr.
	* pa64solib.h (so_list): Forward declare.
	(pa64_solib_thread_start_addr): Prototype.
	* somsolib.c (SHL_LOAD, SHL_UNLOAD): Define if not already defined.
	(no_shared_libraries): Remove.
	(som_solib_thread_start_addr): Rename from so_lib_thread_start_addr.
	* somsolib.h (som_solib_thread_start_addr): Likewise; prototype.
	* hpread.c (hpread_process_one_debug_symbol): Use either the som or
	the elf solib handler to find the start address.

	* config/pa/hppahpux.mh (NATDEPFILES): Move target-specific support
	files to the target makefile.
	* config/pa/hpux1020.mh (NATDEPFILES):  Likewise.
	* config/pa/hpux11.mh (NATDEPFILES): Likewise.
	* config/pa/hpux11w.mh (NATDEPFILES): Likewise.

	* config/pa/hppa64.mt (TDEPFILES): Put target-specific support
    files for symbol reading and shared library handling here.
	* config/pa/hppahpux.mt (TDEPFILES): Likewise.
    (PA_SOM_ONLY): Define so we can build a 32-bit SOM only target
    without bringing in 64-bit support.
@
text
@d1617 7
@


1.37
log
@* language.c (local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string, use C format, and move to
utils.c
(local_hex_string_custom): Rename to hex_string_custom and change
interface.  Now uses C format.  Move to utils.c
(local_octal_format_custom): Remove.
(local_decimal_format_custom): Remove.
(unknown_language_defn): Remove language-specific number
formatting entries.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* language.h (struct language_format_info): Delete declaration.
(struct language_defn): Remove language_format_info fields
la_binary_format, la_octal_format, la_decimal_format, la_hex_format.
(local_binary_format): Remove macro.
(local_binary_format_prefix): Remove macro.
(local_binary_format_specifier): Remove macro.
(local_binary_format_suffix): Remove macro.
(local_octal_format): Remove macro.
(local_octal_format_prefix): Remove macro.
(local_octal_format_specifier): Remove macro.
(local_octal_format_suffix): Remove macro.
(local_decimal_format): Remove macro.
(local_decimal_format_prefix): Remove macro.
(local_decimal_format_specifier): Remove macro.
(local_decimal_format_suffix): Remove macro.
(local_hex_format): Remove macro.
(local_hex_format_prefix): Remove macro.
(local_hex_format_specifier): Remove macro.
(local_hex_format_suffix): Remove macro.
(local_decimal_format_custom): Remove.
(local_octal_format_custom): Remove.
(local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string and move to defs.h.
(local_hex_string_custom): Rename to hex_string_custom, change
interface, and move to defs.h.
* utils.c: (int_string): New function.
(hex_string): New function (from language.c).
(hex_string_custom): New function (from language.c).
(octal2str): New function.
(decimal2str): Add width parameter.
(paddr_u): Use new decimal2str interface.
(paddr_d): Ditto.
* defs.h (hex_string): Declare.
(hex_string_custom): Declare.
(int_string): Declare.
* printcmd.c (print_scalar_formatted): Remove localized binary
formatting.
* valprint.c (print_longest): Use int_string.
(print_floating): Use C hex format.
(print_hex_chars): Ditto.
(print_binary_chars): Remove language-specific formatting.
(print_octal_chars): Use C octal format.
(print_decimal_chars): Delocalize format.
(print_decimal): Remove.
* ada-lang.c (ada_language_defn): Remove language-specific number
formatting entries.
* p-lang.c (pascal_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.
* memattr.c (mem_info_command): Use renamed hex_string_custom with
new interface.
* pa64solib.c (pa64_sharedlibrary_info_command): Ditto.
* ui-out.c (ui_out_field_core_addr): Ditto.
* breakpoint.c (breakpoint_adjustment_warning): Ditto.
* exec.c (print_section_info): Ditto.
* i387-tdep.c (print_i387_status_word): Ditto.
(print_i387_control_word): Ditto.
(i387_print_float_info): Ditto.
* maint.c (maint_print_section_info): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* somsolib.c (som_sharedlibrary_info_command): Ditto.
* symtab.c (print_msymbol_info): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* solib-frv.c (lm_base): Ditto.
(frv_current_sos): Ditto.
(enable_break2): Ditto.
(enable_break): Ditto.
* dbxread.c (read_dbx_symtab): Use renamed hex_string.
(process_one_symbol): Ditto.
* infcmd.c (program_info): Ditto.
* mdebugread.c (parse_partial_symbols): Ditto.
* symfile.c (add_symbol_file_command): Ditto.
* cli/cli-cmds.c (edit_command): Ditto.
(list_command): Ditto.
* infcall.c (call_function_by_hand): Ditto.
* remote-vx.c (vx_run_files_info): Ditto.
(vx_wait): Ditto.
(vx_attach): Ditto.
(vx_detach): Ditto.
(vx_kill): Ditto.
* aix-thread.c (pdc_symbol_addrs): Ditto.
(pdc_read_regs): Ditto.
(pdc_write_regs): Ditto.
(pdc_read_data): Ditto.
(pdc_write_data): Ditto.
* d10v-tdep.c (display_trace): Ditto.
* rs6000-nat.c (find_toc_address): Ditto.
* aix-thread.c: Don't include language.h.
* buildsym.c: Ditto.
* dbxread.c: Ditto.
* mdebugread.c: Ditto.
* rs6000-nat.c: Ditto.
* buildsym.c (make_blockvector): Use renamed hex_string.
@
text
@d54 8
a1567 19
/* LOCAL FUNCTION

   no_shared_libraries -- handle command to explicitly discard symbols
   from shared libraries.

   DESCRIPTION

   Implements the command "nosharedlibrary", which discards symbols
   that have been auto-loaded from shared libraries.  Symbols from
   shared libraries that were added by explicit request of the user
   are not discarded.  Also called from remote.c.  */

void
no_shared_libraries (char *ignored, int from_tty)
{
  /* FIXME */
}


d1613 1
a1613 1
so_lib_thread_start_addr (struct so_list *so)
@


1.36
log
@	* defs.h (OPF_TRY_CWD_FIRST, OPF_SEARCH_IN_PATH): New macros.

	* exec.c (exec_file_attach):
	* nto-tdep.c (nto_find_and_open_solib):
	* pa64solib.c (pa64_solib_sizeof_symbol_table):
	* solib.c (solib_open):
	* somsolib.c (som_solib_sizeof_symbol_table):
	* source.c (is_regular_file, openp, open_source_file):
	* symfile.c (symfile_bfd_open):
	* wince.c (upload_to_device): Differentiate between the search for
	binary and source files.
@
text
@d1466 1
a1466 1
      printf_unfiltered ("    %-12s", local_hex_string_custom (flags, "08l"));
d1468 1
a1468 1
	     local_hex_string_custom (so_list->som_solib.text_addr, "08l"));
d1470 1
a1470 1
	      local_hex_string_custom (so_list->som_solib.text_end, "08l"));
d1472 1
a1472 1
	    local_hex_string_custom (so_list->som_solib.data_start, "08l"));
d1474 1
a1474 1
	      local_hex_string_custom (so_list->som_solib.data_end, "08l"));
d1476 1
a1476 1
	     local_hex_string_custom (so_list->som_solib.got_value, "08l"));
@


1.35
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d219 2
a220 1
  desc = openp (getenv ("PATH"), 1, filename, O_RDONLY | O_BINARY, 0, &absolute_name);
@


1.34
log
@2004-05-18  Randolph Chung  <tausq@@debian.org>

	* somsolib.c (som_solib_remove_inferior_hook): Make all the size
	references to dld_flags_buffer consistent.
@
text
@d1586 1
a1586 1
  add_show_from_set
d1597 1
a1597 1
  add_show_from_set
@


1.33
log
@2004-05-15  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.h (hppa_frame_prev_register_helper): Pass save_regs
	as pointer instead of array reference since HPUX compiler does
	not accept unsized array arguments.
	* somsolib.c (dld_flags_buffer): Use constant array size.
@
text
@d1084 1
a1084 1
  status = target_read_memory (addr, dld_flags_buffer, TARGET_INT_BIT / TARGET_CHAR_BIT);
d1086 1
a1086 2
  dld_flags_value = extract_unsigned_integer (dld_flags_buffer,
					      sizeof (dld_flags_value));
d1089 2
a1090 4
  store_unsigned_integer (dld_flags_buffer,
			  sizeof (dld_flags_value),
			  dld_flags_value);
  status = target_write_memory (addr, dld_flags_buffer, TARGET_INT_BIT / TARGET_CHAR_BIT);
@


1.32
log
@2004-05-06  Randolph Chung  <tausq@@debian.org>

	* config/pa/tm-hppa.h (RO_REGNUM, FLAGS_REGNUM, RP_REGNUM)
	(HPPA_FP_REGNUM, HPPA_SP_REGNUM, SAR_REGNUM, IPSW_REGNUM)
	(PCOQ_HEAD_REGNUM, PCSQ_HEAD_REGNUM, PCOQ_TAIL_REGNUM, PCSQ_TAIL_REGNUM)
	(EIEM_REGNUM, IIR_REGNUM, ISR_REGNUM, IOR_REGNUM, SR4_REGNUM)
	(RCR_REGNUM, PID0_REGNUM, PID1_REGNUM, PID2_REGNUM, PID3_REGNUM)
	(CCR_REGNUM, TR0_REGNUM, CR27_REGNUM, HPPA_FP0_REGNUM, FP4_REGNUM)
	(ARG0_REGNUM, ARG1_REGNUM, ARG2_REGNUM, ARG3_REGNUM): Move *_REGNUM
	definitions ...
	* hppa-tdep.h: ... to here, with HPPA_ prefix.
	* Makefile.in (hppah-nat.o): Add $(hppa_tdep_h)
	* hppa-hpux-tdep.c (hppa32_hpux_frame_find_saved_regs_in_sig)
	(hppa64_hpux_frame_find_saved_regs_in_sig)
	(child_get_current_exception_event): Add HPPA_ prefix to *_REGNUM usage.
	* hppa-linux-nat.c (GR_REGNUM, TR_REGNUM, greg_map): Likewise.
	* hppa-linux-tdep.c (hppa_dwarf_reg_to_regnum)
	(hppa_linux_target_write_pc, hppa_linux_sigtramp_frame_unwind_cache)
	(hppa_linux_sigtramp_frame_prev_register): Likewise.
	* hppa-tdep.c (hppa32_return_value, hppa64_return_value)
	(hppa32_push_dummy_call, hppa64_push_dummy_call, hppa64_frame_align)
	(hppa_target_read_pc, hppa_target_write_pc, hppa_frame_cache)
	(hppa_frame_prev_register, hppa_stub_frame_unwind_cache)
	(hppa_stub_frame_prev_register, hppa_unwind_dummy_id)
	(hppa_skip_permanent_breakpoint, hppa_instruction_nullified)
	(hppa32_register_type, hppa_cannot_store_register)
	(hppa_fetch_pointer_argument, hppa_pseudo_register_read): Likewise.
	* hppah-nat.c (store_inferior_registers, fetch_register): Likewise.
	* hpread.c (hpread_process_one_debug_symbol): Likewise.
	* pa64solib.c (pa64_solib_have_load_event)
	(pa64_solib_have_unload_event, pa64_solib_loaded_library_pathname)
	(pa64_solib_unloaded_library_pathname): Likewise.
	* somsolib.c (som_solib_have_load_event, som_solib_have_unload_event)
	(som_solib_library_pathname): Likewise.
@
text
@d1067 1
a1067 1
  char dld_flags_buffer[TARGET_INT_BIT / TARGET_CHAR_BIT];
@


1.31
log
@2004-04-17  Randolph Chung  <tausq@@debian.org>

	* Makefile.in (hpread.o, pa64solib.o, somsolib.o): Add $(hppa_tdep_h)
	* hppa-tdep.c (hppa_objfile_priv_data): New.
	(SR4EXPORT_LDIL_OFFSET, SR4EXPORT_LDO_OFFSET): Use
	HPPA_INSTRUCTION_SIZE.
	(read_unwind_info): Use objfile_data to reference unwind info.
	(find_unwind_entry): Likewise.
	(hpread_adjust_stack_address): Move to hpread.c.
	(_initialize_hppa_tdep): Register hppa objfile data.
	* hppa-tdep.h (HPPA_INSTRUCTION_SIZE): Define.
	(unwind_table_entry, unwind_stub_types): Move from tm-hppa.h.
	(obj_unwind_info, obj_private_struct): Move from tm-hppa.h, and rename
	with hppa_ prefix.
	* hpread.c (hppa-tdep.h): Include.
	(hpread_adjust_stack_address): Move from hppa-tdep.c.
	(hpread_read_function_type, hpread_read_doc_function_type)
	(hpread_process_one_debug_symbol): Call hpread_adjust_stack_address
	directly. Use objfile_data to access solib data.
	* pa64solib.c (hppa-tdep.h): Include.
	(pa64_solib_add_solib_objfile): Use objfile_data to access solib data.
	* somsolib.c (hppa-tdep.h): Include.
	(som_solib_add_solib_objfile): Use objfile_data to access solib data.
	* config/pa/tm-hppa.h (frame_info, frame_saved_regs, value, type)
	(inferior_status): Remove unused forward declarations.
	(INSTRUCTION_SIZE): Move to hppa-tdep.c.
	(unwind_table_entry, unwind_stub_types, obj_unwind_info)
	(obj_private_struct): Move to hppa-tdep.h.
	(HPREAD_ADJUST_STACK_ADDRESS): Remove.
@
text
@d1140 1
a1140 1
  event_kind = read_register (ARG0_REGNUM);
d1149 1
a1149 1
  event_kind = read_register (ARG0_REGNUM);
d1163 1
a1163 1
  dll_handle_address = read_register (ARG1_REGNUM);
@


1.30
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* buildsym.c (free_pending_blocks, finish_block)
	(record_pending_block, make_blockvector, end_symtab): Replace
	symbol_obstack with objfile_obstack.
	* coffread.c (process_coff_symbol, coff_read_struct_type)
	(coff_read_enum_type): Ditto.
	* cp-namespace.c (initialize_namespace_symtab)
	(check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol, dwarf2_const_value, macro_start_file)
	(dwarf2_symbol_mark_computed): Ditto.
	* dwarfread.c (enum_type, new_symbol, synthesize_typedef): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* hpread.c (hpread_symfile_init, hpread_symfile_init)
	(hpread_read_enum_type, hpread_read_function_type)
	(hpread_read_doc_function_type, hpread_process_one_debug_symbol):
	Ditto.
	* jv-lang.c (get_java_class_symtab, add_class_symbol)
	(java_link_class_type): Ditto.
	* mdebugread.c (parse_symbol, psymtab_to_symtab_1, new_symtab)
	(new_symbol): Ditto.
	* minsyms.c (install_minimal_symbols): Ditto.
	* objfiles.c (allocate_objfile): Remove init of symbol_obstack.
	(terminate_minimal_symbol_table): Replace symbol_obstack with
	objfile_obstack.
	(free_objfile): Remove freeing of symbol_obstack.
	* objfiles.h: Remove symbol_obstack field.
	* pa64solib.c (add_to_solist): Replace symbol_obstack with
	objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
	symbol_obstack.
	(solib_add_common_symbols): Replace symbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add): Ditto.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_start, common_block_end): Ditto.
	* symfile.c (reread_symbols): Remove freeing and init of
	symbol_obstack.
	(allocate_symtab): Rename symbol_obstack to objfile_obstack.
	* symfile.h: Update comment.
	* symmisc.c (print_objfile_statistics): Remove symbol_obstack
	stats printing.
	* symtab.c (symbol_set_names): Replace symbol_obstack with
	objfile_obstack.
	* symtab.h (struct general_symbol_info, struct minimal_symbol):
	Update comments.
	* xcoffread.c (read_xcoff_symtab, SYMBOL_DUP, SYMNAME_ALLOC)
	(init_stringtab, xcoff_initial_scan): Replace symbol_obstack with
	objfile_obstack.
@
text
@d46 1
d282 1
a282 1
  obj_private_data_t *obj_private;
d311 3
a313 1
  if (so->objfile->obj_private == NULL)
d315 1
a315 1
      obj_private = (obj_private_data_t *)
d317 2
a318 1
		       sizeof (obj_private_data_t));
a320 1
      so->objfile->obj_private = obj_private;
a322 1
  obj_private = (obj_private_data_t *) so->objfile->obj_private;
@


1.30.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a45 1
#include "hppa-tdep.h"
d218 1
a218 2
  desc = openp (getenv ("PATH"), OPF_TRY_CWD_FIRST, filename,
		O_RDONLY | O_BINARY, 0, &absolute_name);
d281 1
a281 1
  struct hppa_objfile_private *obj_private;
d310 1
a310 3
  obj_private = (struct hppa_objfile_private *)
	        objfile_data (so->objfile, hppa_objfile_priv_data);
  if (obj_private == NULL)
d312 1
a312 1
      obj_private = (struct hppa_objfile_private *)
d314 1
a314 2
		       sizeof (struct hppa_objfile_private));
      set_objfile_data (so->objfile, hppa_objfile_priv_data, obj_private);
d317 1
d320 1
d1065 1
a1065 1
  char dld_flags_buffer[4];
d1082 1
a1082 1
  status = target_read_memory (addr, dld_flags_buffer, 4);
d1084 2
a1085 1
  dld_flags_value = extract_unsigned_integer (dld_flags_buffer, 4);
d1088 4
a1091 2
  store_unsigned_integer (dld_flags_buffer, 4, dld_flags_value);
  status = target_write_memory (addr, dld_flags_buffer, 4);
d1138 1
a1138 1
  event_kind = read_register (HPPA_ARG0_REGNUM);
d1147 1
a1147 1
  event_kind = read_register (HPPA_ARG0_REGNUM);
d1161 1
a1161 1
  dll_handle_address = read_register (HPPA_ARG1_REGNUM);
d1466 1
a1466 1
      printf_unfiltered ("    %-12s", hex_string_custom (flags, 8));
d1468 1
a1468 1
			 hex_string_custom (so_list->som_solib.text_addr, 8));
d1470 1
a1470 1
			 hex_string_custom (so_list->som_solib.text_end, 8));
d1472 1
a1472 1
			 hex_string_custom (so_list->som_solib.data_start, 8));
d1474 1
a1474 1
			 hex_string_custom (so_list->som_solib.data_end, 8));
d1476 1
a1476 1
			 hex_string_custom (so_list->som_solib.got_value, 8));
d1587 1
a1587 1
  deprecated_add_show_from_set
d1598 1
a1598 1
  deprecated_add_show_from_set
@


1.30.6.1
log
@2004-06-03  Randolph Chung  <tausq@@debian.org>

	Fix PR build/1458 (partial)
	* somsolib.c (som_solib_remove_inferior_hook): Use constant array size
	for dld_flags_buffer and make all size references consistent.
	* NEWS: Mention this fix.
@
text
@d1065 1
a1065 1
  char dld_flags_buffer[4];
d1082 1
a1082 1
  status = target_read_memory (addr, dld_flags_buffer, 4);
d1084 2
a1085 1
  dld_flags_value = extract_unsigned_integer (dld_flags_buffer, 4);
d1088 4
a1091 2
  store_unsigned_integer (dld_flags_buffer, 4, dld_flags_value);
  status = target_write_memory (addr, dld_flags_buffer, 4);
@


1.29
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* dbxread.c (dbx_symfile_init, start_psymtab, end_psymtab,
	coffstab_build_psymtabs, elfstab_build_psymtabs)
	(stabsect_build_psymtabs): Replace psymbol_obstack with
	objfile_obstack.
	* dwarf2-frame.c (decode_frame_entry_1): Ditto.
	* dwarf2read.c (dwarf2_build_psymtabs_hard, dwarf2_read_section):
	Ditto.
	* dwarfread.c (scan_compilation_units): Ditto.
	* elfread.c (elfstab_offset_sections): Ditto.
	* hppa-tdep.c (read_unwind_info): Ditto.
	* hpread.c (hpread_build_psymtabs, hpread_start_psymtab)
	(hpread_end_psymtab): Ditto.
	* mdebugread.c (mdebug_build_psymtabs, add_pending)
	(parse_partial_symbols, new_psymtab, elfmdebug_build_psymtabs):
	Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* objfiles.c (add_to_objfile_sections)
	(build_objfile_section_table): Ditto.
	(allocate_objfile): Remove init of psymbol_obstack.
	(free_objfile): Remove freeing of psymbol_obstack.
	* objfiles.h (struct objfile): Remove field
	psymbol_obstack. Update comments.
	* pa64solib.c (pa64_solib_add_solib_objfile): Replace
	psymbol_obstack with objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
        psymbol_obstack.
	* somread.c (som_symfile_offsets, init_import_symbols)
	(init_export_symbols): Replace psymbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
	* symfile.c (default_symfile_offsets, syms_from_objfile)
	(reread_symbols): Remove freeing and init of psymbol_obstack.
	(cashier_psymtab): Update comment.
	* symmisc.c (print_objfile_statistics): Don't report stats for
	psymbol obstack.
	* symtab.h (struct general_symbol_info, struct partial_symtab):
	Update comments.
	* xcoffread.c (xcoff_start_psymtab, xcoff_end_psymtab, swap_sym)
	(xcoff_symfile_offsets): Replace psymbol_obstack with
	objfile_obstack.
@
text
@d646 1
a646 1
			   &symfile_objfile->symbol_obstack);
@


1.28
log
@2003-10-22  Andrew Cagney  <cagney@@redhat.com>

	* exec.h: New file.
	* win32-nat.c: Include "exec.h".
	* solib.c: Include "exec.h".
	* target.h (build_section_table): Delete declaration.
	* somsolib.c: Include "exec.h".
	(exec_ops): Delete extern declaration.
	* rs6000-nat.c: Update copyright.  Include "exec.h".
	(exec_ops): Delete extern declaration.
	* pa64solib.c: Update copyright.  Include "exec.h".
	(exec_ops): Delete extern declaration.
	* exec.c: Update copyright.  Include "exec.h".
	* corelow.c: Update dependencies.  Include "exec.h".
	* Makefile.in (exec_h): Define.
	(exec.o, somsolib.o): Update dependencies.
	(pa64solib.o, corelow.o): Update dependencies.
@
text
@d4 1
a4 1
   2003 Free Software Foundation, Inc.
d313 1
a313 1
	obstack_alloc (&so->objfile->psymbol_obstack,
@


1.27
log
@2003-10-16  Elena Zannoni  <ezannoni@@redhat.com>

	* minsyms.c (lookup_minimal_symbol_solib_trampoline): Remove
	second parameter, which is always null. Remove
	SOFUN_ADDRESS_MAYBE_MISSING ifdeffed code.
	* symtab.h (lookup_minimal_symbol_solib_trampoline): Update
	accordingly.
	* somsolib.c (som_solib_create_inferior_hook,
	som_solib_desire_dynamic_linker_symbols): Update callers.
	* hppa-tdep.c (hppa_fix_call_dummy): Ditto.
@
text
@d45 1
a57 4

/* Defined in exec.c; used to prevent dangling pointer bug.
 */
extern struct target_ops exec_ops;
@


1.26
log
@2003-08-30  Michael Chastain  <mec@@shout.net>

	* Makefile.in: Remove tm-hp300bsd.h, tm-hp300hpux.h.
	* config/m68k/nm-hp300hpux.h: Delete.
	* config/m68k/tm-hp300hpux.h: Delete.
	* config/m68k/xm-hp300hpux.h: Delete.
	* config/m68k/xm-hp300bsd.h: Delete.
	* config/djgpp/fnchange.lst: Remove nm-hp300hpux.h,
	tm-hp300hpux.h, xm-hp300hpux.h.
	* somsolib.c: Remove comment about hp300 shared libraries.
@
text
@d940 1
a940 1
						       NULL, objfile);
a1227 1
							  NULL,
a1266 1
							  NULL,
@


1.25
log
@        * hppa-tdep.c (gdb_assert.h): Add missing #include.
        * somsolib.c (gdb_assert.h): Likewise.
        * Makefile.in (hppa-tdep.o): Add dependency on gdb_assert.h.
        (somsolib.o): Likewise.
@
text
@a76 3
   * Most of this code should work for hp300 shared libraries.  Does
   anyone care enough to weed out any SOM-isms.

@


1.24
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d44 1
@


1.23
log
@2003-02-01  Andrew Cagney  <ac131313@@redhat.com>

	* defs.h (host_pointer_to_address): Delete declaration.
	(address_to_host_pointer): Delete declaration.
	* utils.c (host_pointer_to_address): Delete function.
	(address_to_host_pointer): Delete function.
	* procfs.c (procfs_address_to_host_pointer): New function.
	* procfs.c (proc_set_watchpoint): Use.
	(procfs_can_use_hw_breakpoint): Update comments.
	* somsolib.c (hpux_address_to_host_pointer_hack): New function.
	(som_solib_add): Use.
	* hppa-tdep.c (hppa_pointer_to_address_hack): New function.
	* hppa-tdep.c (unwind_command): Use.
@
text
@d941 1
a941 1
    msymbol2 = lookup_minimal_symbol_solib_trampoline (SYMBOL_NAME (msymbol),
@


1.22
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@d404 15
d733 2
d736 1
a736 1
	address_to_host_pointer (extract_unsigned_integer (buf, 4));
@


1.21
log
@2003-01-09  Andrew Cagney  <ac131313@@redhat.com>

	* somsolib.h: Fix function indentation.
	* disasm.c, buildsym.c, buildsym.h: Eliminate PTR.
	* gnu-v2-abi.c, f-typeprint.c, x86-64-linux-tdep.c: Eliminate STREQ.
	* demangle.c, ax-gdb.c, c-valprint.c: Eliminate STREQ.
	* alpha-osf1-tdep.c, corefile.c: Eliminate STREQ.
	* somsolib.c, inftarg.c: Remove assignment in if conditional.
@
text
@d3 2
a4 2
   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002 Free
   Software Foundation, Inc.
@


1.20
log
@       * somsolib.c (dld_cache): Replace boolean by int for field is_valid.
       Fixes a build failure on HP/UX.

       * hpread.c (told_objfile): Replace boolean type by int. Fixes a build
       failure on HP/UX.
       (hpread_has_name): Advance declaration to avoid a compilation warning.
       (pst_syms_count): Add missing variable type. By change, the compiler
       was defaulting to int, which seems a good choice. Fixes a compilation
       warning.
       (pst_syms_size): Likewise.
@
text
@d421 2
a422 1
  if ((re_err = re_comp (arg_string ? arg_string : ".")) != NULL)
@


1.19
log
@* objfiles.h: Change type of obj_private to void pointer.
* pa64solib.c: Update copyright.  Don't include "assert.h", use
strcmp instead of STREQ, use LONGEST, do not use PTR
* somsolib.c: Ditto.
@
text
@d194 1
a194 1
    boolean is_valid;
@


1.19.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 2
a4 2
   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
a43 2
#include "gdb_assert.h"
#include "exec.h"
d57 4
d76 3
d194 1
a194 1
    int is_valid;
a403 15
/* FIXME: cagney/2003-02-01: This just isn't right.  Given an address
   within the target's address space, this converts the value into an
   address within the host's (i.e., GDB's) address space.  Given that
   the host/target address spaces are separate, this can't be right.  */

static void *
hpux_address_to_host_pointer_hack (CORE_ADDR addr)
{
  void *ptr;

  gdb_assert (sizeof (ptr) == TYPE_LENGTH (builtin_type_void_data_ptr));
  ADDRESS_TO_POINTER (builtin_type_void_data_ptr, &ptr, addr);
  return ptr;
}

d421 1
a421 2
  re_err = re_comp (arg_string ? arg_string : ".");
  if (re_err != NULL)
a716 2
      /* FIXME: cagney/2003-02-01: I think som_solib.next should be a
         CORE_ADDR.  */
d718 1
a718 1
	hpux_address_to_host_pointer_hack (extract_unsigned_integer (buf, 4));
d923 2
a924 2
    msymbol2 = lookup_minimal_symbol_solib_trampoline (DEPRECATED_SYMBOL_NAME (msymbol),
						       objfile);
d1212 1
d1252 1
@


1.19.10.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d4 1
a4 1
   2003, 2004 Free Software Foundation, Inc.
d313 1
a313 1
	obstack_alloc (&so->objfile->objfile_obstack,
d646 1
a646 1
			   &symfile_objfile->objfile_obstack);
@


1.19.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d194 1
a194 1
    int is_valid;
@


1.19.8.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 2
a4 2
   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
a403 15
/* FIXME: cagney/2003-02-01: This just isn't right.  Given an address
   within the target's address space, this converts the value into an
   address within the host's (i.e., GDB's) address space.  Given that
   the host/target address spaces are separate, this can't be right.  */

static void *
hpux_address_to_host_pointer_hack (CORE_ADDR addr)
{
  void *ptr;

  gdb_assert (sizeof (ptr) == TYPE_LENGTH (builtin_type_void_data_ptr));
  ADDRESS_TO_POINTER (builtin_type_void_data_ptr, &ptr, addr);
  return ptr;
}

d421 1
a421 2
  re_err = re_comp (arg_string ? arg_string : ".");
  if (re_err != NULL)
a716 2
      /* FIXME: cagney/2003-02-01: I think som_solib.next should be a
         CORE_ADDR.  */
d718 1
a718 1
	hpux_address_to_host_pointer_hack (extract_unsigned_integer (buf, 4));
@


1.19.8.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d941 1
a941 1
    msymbol2 = lookup_minimal_symbol_solib_trampoline (DEPRECATED_SYMBOL_NAME (msymbol),
@


1.19.8.4
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a43 1
#include "gdb_assert.h"
@


1.19.8.5
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d77 3
@


1.19.8.6
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a44 1
#include "exec.h"
d58 4
d940 1
a940 1
						       objfile);
d1228 1
d1268 1
@


1.18
log
@        * somsolib.c (som_solib_add): Ignore the solib limit threshhold
        if AUTO_SOLIB_LIMIT is not greater than zero.

        * somsolib.c (som_solib_create_inferior_hook): No longer warn
        about missing __d_pid symbol.
@
text
@d2 3
a4 2
   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
a41 1
#include "assert.h"
d322 1
a322 1
      so->objfile->obj_private = (PTR) obj_private;
@


1.18.8.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d2 2
a3 3

   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002 Free
   Software Foundation, Inc.
d41 1
d322 1
a322 1
      so->objfile->obj_private = obj_private;
@


1.18.6.1
log
@merge from trunk
@
text
@d2 2
a3 3

   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002 Free
   Software Foundation, Inc.
d41 1
d322 1
a322 1
      so->objfile->obj_private = obj_private;
@


1.17
log
@Approved by kev@@cygnus.com
ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* coff-solib.c (coff_solib_add): Add new readsyms arg.
	* irix5-nat.c (solib_add): Ditto.
	* osfsolib.c (solib_add): Ditto.
	* pa64solib.c (pa64_solib_add): Ditto.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* solib.c (solib_add): Ditto.
	* somsolib.c (som_solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* coff-solib.h (coff_solib_add): Add new readsyms arg to prototype.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* pa64solib.h (pa64_solib_add): Ditto.
	* solib.h (solib_add): Ditto.
	* somsolib.h (som_solib_add): Ditto.
	* config/i386/tm-cygwin.h (child_solib_add): Ditto.

	* coff-solib.c (coff_solib_add):  If readsyms is zero don't read
	symbols but do any other needed work for shared libs.
	* irix5-nat.c: Ditto.
	* osfsolib.c (solib_add): Ditto.
	* solib.c (solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* irix5-nat.c (sharedlibrary_command): Pass 1 as readsyms to
	solib_add to force reading of shared library symbols.
	* osfsolib.c (sharedlibrary_command;): Ditto.
	* pa64solib.c (pa64_solib_sharedlibrary_command): Ditto.
	* solib.c (sharedlibrary_command): Ditto.
	* somsolib.c (som_solib_sharedlibrary_command): Ditto.
	* xcoffsolib.c (sharedlibrary_command): Ditto.

	* coff-solib.c (coff_solib_create_inferior_hook): Call solib_add
	unconditionally with auto_solib_add.
	* irix5-nat.c (solib_create_inferior_hook): Ditto.
	* osfsolib.c (solib_create_inferior_hook): Ditto.
	* solib.c (solib_create_inferior_hook): Ditto.
	* solib-osf.c (osf_solib_create_inferior_hook): Ditto.
	* solib-svr4.c (enable_break): Ditto.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Ditto.

	* corelow.c (solib_add_stub): Add auto_solib_add to args passed
	via SOLIB_ADD.
	* sol-thread.c (sol_thread_attach): Ditto.
	* config/rs6000/nm-rs6000.h (SOLIB_ADD): Ditto.

	* infcmd.c (attach_command): Remove auto_solib_add decl.
	Call SOLIB_ADD directly with auto_solib_add.
	* infrun.c (handle_inferior_event): Ditto.

	* coff-solib.h (SOLIB_ADD): Add readsyms arg.
	* pa64solib.h (SOLIB_ADD): Ditto.
	* solib.h (SOLIB_ADD): Ditto.
	* somsolib.h (SOLIB_ADD): Ditto.
	* config/i386/tm-cygwin.h (SOLIB_ADD): Ditto.

	* fork-child.c (clone_and_follow_inferior): Remove unused
	auto_solib_add decl.

	* pa64solib.c (pa64_solib_add): Call add_to_solist with readsyms.
	(read_dld_descriptor): Ditto.
	(pa64_solib_add): Call read_dld_descriptor with	readsyms.
	(pa64_solib_in_dynamic_linker): Ditto.

	* corelow.c (symfile.h): Need this for auto_solib_add declaration.
	* sol-thread.c (symfile.h): Ditto.

Approved by eliz@@is.elta.co.il
doc/ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* gdbint.texinfo (SOLIB_ADD): Document additional new
	"readsyms" arg.
@
text
@d780 1
d872 6
a877 1
  /* Slam the pid of the process into __d_pid; failing is only a warning!  */
d880 1
a880 6
    {
      warning ("Unable to find __d_pid symbol in object file.");
      warning ("Suggest linking with /opt/langtools/lib/end.o.");
      warning ("GDB will be unable to track shl_load/shl_unload calls");
      goto keep_going;
    }
@


1.16
log
@	2001-10-30  Fred Fish  <fnf@@redhat.com>
	* somsolib.c (som_solib_add): A megabyte is 1024*1024 bytes.
	* pa64solib.c (add_to_solist): Ditto.
	* win32-nat.c (_initialize_inftarg): Remove unnecessary
	initialization of auto_solib_add, it defaults to 1.
@
text
@d409 1
a409 1
som_solib_add (char *arg_string, int from_tty, struct target_ops *target)
d780 1
a780 1
	auto_solib_add &&
d1473 1
a1473 1
  som_solib_add (args, from_tty, (struct target_ops *) 0);
@


1.15
log
@Changes approved by kev@@cygnus.com, ezannoni@@cygnus.com, eliz@@is.elta.co.il.

  Changelog:

	2001-10-27  Fred Fish  <fnf@@redhat.com>

	* symfile.c (auto_solib_add): Update comment to note that
	this variable is now just used as a boolean to control shlib
	autoloading, and clarify when it is used.
	* symfile.h (auto_solib_add): Ditto.

	* symfile.c (auto_solib_limit): New variable that holds the
	autoloading threshold instead of overloading auto_solib_add.
	* symfile.h (auto_solib_limit): Ditto.

	* irix5-nat.c (_initialize_solib): Change auto-solib-add
	variable from var_zinteger to var_boolean and update help.
	* osfsolib.c (_initialize_solib): Ditto.
	* pa64solib.c (_initialize_pa64_solib): Ditto.
	* solib.c (_initialize_solib): Ditto.
	* somsolib.c (_initialize_som_solib): Ditto.
	* xcoffsolib.c (_initialize_solib): Ditto.

	* pa64solib.c (pa64_solib_total_st_size): Update comment to
	note that the new auto_solib_limit variable is used instead
	of overloading auto_solib_add variable.
	(_initialize_pa64_solib): Ditto.
	* somsolib.c (som_solib_total_st_size): Ditto.
	(_initialize_som_solib): Ditto.

	* pa64solib.c (_initialize_pa64_solib): Add new set/show
	commands for auto-solib-limit variable.
	* somsolib.c (_initialize_som_solib): Ditto

	* pa64solib.c (add_to_solist): Check that auto_solib_add is
	set and use auto_solib_limit as the threshold size instead
	of auto_solib_add.
	* somsolib.c (som_solib_add): Ditto, and also change warning
	text about size threshold exceeded.

  doc/ChangeLog:

	2001-10-28  Fred Fish  <fnf@@redhat.com>

	* gdb.texinfo (auto-solib-add): Change docs to match
	implementation change.
	(auto-solib-limit): Add docs for new variable.
@
text
@d781 1
a781 1
	((st_size + som_solib_total_st_size) > (auto_solib_limit * (LONGEST) 1000000));
@


1.14
log
@Tweeks for HP/UX and -Werror.
@
text
@d164 1
a164 1
   is compared against the threshold size, held by auto_solib_add
d166 2
a167 3
   the total size to exceed the threshold, then the new shlib's symbols
   are not loaded.
 */
d405 1
a405 1
   size threshold (specified by auto_solib_add, in megabytes) would
d780 2
a781 1
	((st_size + som_solib_total_st_size) > (auto_solib_add * (LONGEST) 1000000));
d786 1
a786 1
	    warning ("Symbols for some libraries have not been loaded, because\ndoing so would exceed the size threshold specified by auto-solib-add.\nTo manually load symbols, use the 'sharedlibrary' command.\nTo raise the threshold, set auto-solib-add to a larger value and rerun\nthe program.\n");
d1574 1
d1576 1
a1576 1
    (add_set_cmd ("auto-solib-add", class_support, var_zinteger,
d1578 5
a1582 6
		  "Set autoloading size threshold (in megabytes) of shared library symbols.\n\
If nonzero, symbols from all shared object libraries will be loaded\n\
automatically when the inferior begins execution or when the dynamic linker\n\
informs gdb that a new library has been loaded, until the symbol table\n\
of the program and libraries exceeds this threshold.\n\
Otherwise, symbols must be loaded manually, using `sharedlibrary'.",
d1586 19
a1604 10
  /* ??rehrauer: On HP-UX, the kernel parameter MAXDSIZ limits how much
     data space a process can use.  We ought to be reading MAXDSIZ and
     setting auto_solib_add to some large fraction of that value.  If
     not that, we maybe ought to be setting it smaller than the default
     for MAXDSIZ (that being 64Mb, I believe).  However, [1] this threshold
     is only crudely approximated rather than actually measured, and [2]
     50 Mbytes is too small for debugging gdb itself.  Thus, the arbitrary
     100 figure.
   */
  auto_solib_add = 100;		/* Megabytes */
@


1.13
log
@From 2001-07-16 Rodney Brown <rbrown64@@csc.com.au>:
* infttrace.c (child_thread_alive): Fix gdb_tid typo.
* somsolib.c (no_shared_libraries): Provide stub.
* xcoffsolib.c (no_shared_libraries): Provide stub.
@
text
@d718 2
a719 1
      new_so->som_solib.next = (void *) extract_unsigned_integer (buf, 4);
d1267 4
a1270 2
    if ((dld_cache.load.address != NULL) && (dld_cache.load_stub.address != NULL)
	&& (dld_cache.unload.address != NULL) && (dld_cache.unload_stub.address != NULL))
@


1.12
log
@Consolidate save_inferior_ptid/restore_inferior_ptid implementation to
one source file.
@
text
@d1545 18
@


1.11
log
@Phase 1 of the ptid_t changes.
@
text
@a1033 8

static void
reset_inferior_ptid (int saved_inferior_ptid)
{
  inferior_ptid = saved_inferior_ptid;
}


d1052 1
a1052 2
  int saved_inferior_ptid = inferior_ptid;
  struct cleanup *old_cleanups = make_cleanup (reset_inferior_ptid, saved_inferior_ptid);
@


1.10
log
@Update/correct copyright notices.
@
text
@d881 1
a881 1
  store_unsigned_integer (buf, 4, inferior_pid);
d1036 1
a1036 1
reset_inferior_pid (int saved_inferior_pid)
d1038 1
a1038 1
  inferior_pid = saved_inferior_pid;
d1060 2
a1061 2
  int saved_inferior_pid = inferior_pid;
  struct cleanup *old_cleanups = make_cleanup (reset_inferior_pid, saved_inferior_pid);
d1064 1
a1064 1
  inferior_pid = pid;
@


1.9
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1993, 1996, 1999, 2001 Free Software Foundation, Inc.
@


1.8
log
@2001-02-12  Michael Chastain  <chastain@@redhat.com>

	* gdb/somsolib.c (som_solib_add_solib_objfile): Do not use
	section relocation feature of syms_from_objfile.  Do my own
	section relocation, offsetting each section of the som by
	either text_addr - text_link_addr or data_start.
@
text
@d42 1
@


1.7
log
@Replace free() with xfree().
@
text
@d2 1
a2 1
   Copyright 1993, 1996, 1999 Free Software Foundation, Inc.
d286 1
a286 1
  struct section_addr_info section_addrs;
d288 1
a288 4
  memset (&section_addrs, 0, sizeof (section_addrs));
  section_addrs.other[0].name = ".text";
  section_addrs.other[0].addr = text_addr;
  so->objfile = symbol_file_add (name, from_tty, &section_addrs, 0, OBJF_SHARED);
d291 19
@


1.6
log
@2000-08-27  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* pa64solib.c (pa64_solib_load_symbols): Don't use ANOFFSET as an
 	lvalue.
	* xcoffread.c (xcoff_symfile_offsets): Ditto
	* somsolib.c (som_solib_section_offsets): Ditto.
	* somread.c (som_symfile_offsets): Ditto.
	* rs6000-nat.c (vmap_symtab): Ditto.
	* remote-vx.c (vx_add_symbols): Ditto.
	* remote-os9k.c (rombug_wait): Ditto.
@
text
@d233 1
a233 1
      make_cleanup (free, filename);
d241 1
a241 1
      make_cleanup (free, filename);
d259 1
a259 1
  free (filename);
d1010 1
a1010 1
      free (so_list_head);
d1503 1
a1503 1
      free (sl);
@


1.5
log
@Protoization.
@
text
@d1381 1
a1381 1
	  ANOFFSET (offsets, SECT_OFF_TEXT (objfile))
d1384 1
a1384 1
	  ANOFFSET (offsets, SECT_OFF_RODATA (objfile))
d1394 2
a1395 2
	      ANOFFSET (offsets, SECT_OFF_DATA (objfile)) = 0;
	      ANOFFSET (offsets, SECT_OFF_BSS (objfile)) = 0;
d1398 1
a1398 1
	  ANOFFSET (offsets, SECT_OFF_DATA (objfile))
d1400 1
a1400 1
	  ANOFFSET (offsets, SECT_OFF_BSS (objfile))
@


1.4
log
@PARAMS removal.
@
text
@d211 1
a211 2
som_solib_sizeof_symbol_table (filename)
     char *filename;
d282 2
a283 5
som_solib_add_solib_objfile (so, name, from_tty, text_addr)
     struct so_list *so;
     char *name;
     int from_tty;
     CORE_ADDR text_addr;
d320 2
a321 6
som_solib_load_symbols (so, name, from_tty, text_addr, target)
     struct so_list *so;
     char *name;
     int from_tty;
     CORE_ADDR text_addr;
     struct target_ops *target;
d392 1
a392 4
som_solib_add (arg_string, from_tty, target)
     char *arg_string;
     int from_tty;
     struct target_ops *target;
d826 1
a826 1
som_solib_create_inferior_hook ()
d1018 1
a1018 2
reset_inferior_pid (saved_inferior_pid)
     int saved_inferior_pid;
d1035 1
a1035 2
som_solib_remove_inferior_hook (pid)
     int pid;
d1085 2
a1086 5
som_solib_create_catch_load_hook (pid, tempflag, filename, cond_string)
     int pid;
     int tempflag;
     char *filename;
     char *cond_string;
d1103 2
a1104 5
som_solib_create_catch_unload_hook (pid, tempflag, filename, cond_string)
     int pid;
     int tempflag;
     char *filename;
     char *cond_string;
d1110 1
a1110 2
som_solib_have_load_event (pid)
     int pid;
d1119 1
a1119 2
som_solib_have_unload_event (pid)
     int pid;
d1128 1
a1128 2
som_solib_library_pathname (pid)
     int pid;
d1158 1
a1158 2
som_solib_loaded_library_pathname (pid)
     int pid;
d1167 1
a1167 2
som_solib_unloaded_library_pathname (pid)
     int pid;
d1176 1
a1176 1
som_solib_desire_dynamic_linker_symbols ()
d1274 1
a1274 3
som_solib_in_dynamic_linker (pid, pc)
     int pid;
     CORE_ADDR pc;
d1321 1
a1321 2
som_solib_get_got_by_pc (addr)
     CORE_ADDR addr;
d1346 1
a1346 2
som_solib_get_solib_by_pc (addr)
     CORE_ADDR addr;
d1367 2
a1368 3
som_solib_section_offsets (objfile, offsets)
     struct objfile *objfile;
     struct section_offsets *offsets;
d1412 1
a1412 3
som_sharedlibrary_info_command (ignore, from_tty)
     char *ignore;
     int from_tty;
d1458 1
a1458 3
som_solib_sharedlibrary_command (args, from_tty)
     char *args;
     int from_tty;
d1467 1
a1467 2
som_solib_address (addr)
     CORE_ADDR addr;
d1489 1
a1489 1
som_solib_restart ()
d1538 1
a1538 1
_initialize_som_solib ()
d1573 1
a1573 2
so_lib_thread_start_addr (so)
     struct so_list *so;
@


1.3
log
@Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * objfiles.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Define as functions of OBJFILE.  Add
        sect_index_text, sect_index_data, sect_index_rodata,
        sect_index_bss to objfile structure.
        * gdb-stabs.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Remove.
        * objfiles.c (allocate_objfile): Initialize
        sect_index_{text,data,bss,rodata} to -1, for error detection.

        * symfile.c (default_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata} from bfd information.
        * xcoffread.c (xcoff_symfile_offsets): Ditto.
        * somread.c (som_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata}.

        * coffread.c, dbxread.c, elfread.c, hp-psymtab-read.c,
        hp-symtab-read.c, hpread.c, mdebugread.c, minsyms.c,
        mipsread.c, objfiles.c, os9kread.c, pa64solib.c, partial-stab.h,
        remote-os9k.c, remote-vx.c, remote.c, rs6000-nat.c, somsolib.c,
        stabsread.c, symfile.c, xcoffread.c:
        Update use of SECT_OFF_{TEXT,DATA,BSS,RODATA} to depend on the
        current objfile.

        * xcoffread.c: Add new field objfile to find_targ_sec_arg.
@
text
@d60 1
a60 1
extern struct unwind_table_entry *find_unwind_entry PARAMS ((CORE_ADDR pc));
d206 1
a206 1
static void som_sharedlibrary_info_command PARAMS ((char *, int));
d208 1
a208 1
static void som_solib_sharedlibrary_command PARAMS ((char *, int));
@


1.2
log
@2000-04-21  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* win32-nat.c  (handle_load_dll): Don't treat .text as a special
 	section anymore.
	* somread.c (som_symfile_offsets): Ditto.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
@
text
@d358 2
a359 2
	  p->addr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_TEXT);
	  p->endaddr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_TEXT);
d363 2
a364 2
	  p->addr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_DATA);
	  p->endaddr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_DATA);
d1410 1
a1410 1
	  ANOFFSET (offsets, SECT_OFF_TEXT)
d1413 2
a1414 2
	  ANOFFSET (offsets, SECT_OFF_RODATA)
	    = ANOFFSET (offsets, SECT_OFF_TEXT);
d1423 2
a1424 2
	      ANOFFSET (offsets, SECT_OFF_DATA) = 0;
	      ANOFFSET (offsets, SECT_OFF_BSS) = 0;
d1427 1
a1427 1
	  ANOFFSET (offsets, SECT_OFF_DATA)
d1429 2
a1430 2
	  ANOFFSET (offsets, SECT_OFF_BSS)
	    = ANOFFSET (offsets, SECT_OFF_DATA);
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
d21 2
a22 2
Written by the Center for Software Science at the Univerity of Utah
and by Cygnus Support.  */
d54 1
a54 1
 
d66 1
a66 1
   */
d84 45
a128 3
{
  /* The name of the library.  */
  char *name;
d130 1
a130 2
  /* Version of this structure (it is expected to change again in hpux10).  */
  unsigned char struct_version;
d132 3
a134 38
  /* Binding mode for this library.  */
  unsigned char bind_mode;

  /* Version of this library.  */
  short library_version;

  /* Start of text address,
   * link-time text location (length of text area),
   * end of text address.  */
  CORE_ADDR text_addr;
  CORE_ADDR text_link_addr;
  CORE_ADDR text_end;

  /* Start of data, start of bss and end of data.  */
  CORE_ADDR data_start;
  CORE_ADDR bss_start;
  CORE_ADDR data_end;

  /* Value of linkage pointer (%r19).  */
  CORE_ADDR got_value;

  /* Next entry.  */
  struct som_solib_mapped_entry *next;

  /* There are other fields, but I don't have information as to what is
     contained in them.  */

  /* For versions from HPUX-10.30 and up */

  /* Address in target of offset from thread-local register of
   * start of this thread's data.  I.e., the first thread-local
   * variable in this shared library starts at *(tsd_start_addr)
   * from that area pointed to by cr27 (mpsfu_hi).
   *
   * We do the indirection as soon as we read it, so from then
   * on it's the offset itself.
   */
  CORE_ADDR tsd_start_addr;
a135 5
  /* Following this are longwords holding:
   *
   * ?, ?, ?, ptr to -1, ptr to-1, ptr to lib name (leaf name),
   * ptr to __data_start, ptr to __data_end
   */
d137 1
a137 2
  
};
d141 6
a146 6
{
  struct som_solib_mapped_entry som_solib;
  struct objfile *objfile;
  bfd *abfd;
  struct section_table *sections;
  struct section_table *sections_end;
d149 5
a153 5
   som_solib_mapped_entry structure*/
  CORE_ADDR solib_addr;
  struct so_list *next;
  
};
d166 2
a167 2
   */
static LONGEST  som_solib_total_st_size;
d177 2
a178 2
   */
static int  som_solib_st_size_threshold_exceeded;
d182 7
a188 5
   */
typedef struct {
  CORE_ADDR  address;
  struct unwind_table_entry *  unwind;
} addr_and_unwind_t;
d191 12
a202 10
static struct {
  boolean  is_valid;
  addr_and_unwind_t  hook;
  addr_and_unwind_t  hook_stub;
  addr_and_unwind_t  load;
  addr_and_unwind_t  load_stub;
  addr_and_unwind_t  unload;
  addr_and_unwind_t  unload2;
  addr_and_unwind_t  unload_stub;
} dld_cache;
d212 1
a212 1
  char *  filename;
d214 5
a218 5
  bfd *  abfd;
  int  desc;
  char *  absolute_name;
  LONGEST  st_size = (LONGEST) 0;
  asection *  sect;
d222 1
a222 1
     */
d231 1
a231 1
  if (! abfd)
d238 2
a239 2
  
  if (!bfd_check_format (abfd, bfd_object))   /* Reads in section info */
d241 1
a241 1
      bfd_close (abfd);	/* This also closes desc */
d259 1
a259 1
  bfd_close (abfd);	/* This also closes desc */
d277 1
a277 1
     */
d284 4
a287 4
  struct so_list *  so;
  char *  name;
  int  from_tty;
  CORE_ADDR  text_addr;
d290 6
a295 2
  
  so->objfile = symbol_file_add (name, from_tty, text_addr, 0, 0, 0, 0, 1);
d302 1
a302 1
  if( so->objfile->obj_private == NULL )
d305 2
a306 2
                        obstack_alloc( &so->objfile->psymbol_obstack,
                                       sizeof( obj_private_data_t ));
d308 1
a308 1
      obj_private->so_info     = NULL;
d310 1
a310 1
   }
d318 1
a318 1
             name, bfd_errmsg (bfd_get_error ()));
d325 10
a334 10
  struct so_list *  so;
  char *  name;
  int  from_tty;
  CORE_ADDR  text_addr;
  struct target_ops *  target;
{
  struct section_table *  p;
  int  status;
  char  buf[4];
  CORE_ADDR  presumed_data_start;
d337 1
a337 1
  printf( "--Adding symbols for shared library \"%s\"\n", name );
d346 2
a347 2
                           &so->sections,
                           &so->sections_end))
d357 4
a360 4
        {
          p->addr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_TEXT);
          p->endaddr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_TEXT);
        }
d362 4
a365 4
        {
          p->addr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_DATA);
          p->endaddr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_DATA);
        }
a381 11
      int update_coreops;
      int update_execops;

      /* We must update the to_sections field in the core_ops structure
         here, otherwise we dereference a potential dangling pointer
         for each call to target_read/write_memory within this routine.  */
      update_coreops = core_ops.to_sections == target->to_sections;

      /* Ditto exec_ops (this was a bug).
       */
      update_execops = exec_ops.to_sections == target->to_sections;
d384 3
a386 30
      /* Add sections from the shared library to the core target.  */
      if (target->to_sections)
        {
          old = target->to_sections_end - target->to_sections;
          target->to_sections = (struct section_table *)
            xrealloc ((char *)target->to_sections,
                      ((sizeof (struct section_table)) * (old + new)));
        }
      else
        {
          old = 0;
          target->to_sections = (struct section_table *)
            xmalloc ((sizeof (struct section_table)) * new);
        }
      target->to_sections_end = (target->to_sections + old + new);

      /* Update the to_sections field in the core_ops structure
         if needed, ditto exec_ops.  */
      if (update_coreops)
        {
          core_ops.to_sections = target->to_sections;
          core_ops.to_sections_end = target->to_sections_end;
        }

      if (update_execops)
        {
          exec_ops.to_sections = target->to_sections;
          exec_ops.to_sections_end = target->to_sections_end;
        }

d388 3
a390 3
      memcpy ((char *)(target->to_sections + old),
              so->sections,
              ((sizeof (struct section_table)) * new));
d412 1
a412 1
  int  threshold_warning_given = 0;
d461 1
a461 1
     */
d465 1
a465 1
        error ("__dld_list is not valid according to __dld_flags.\n");
d477 1
a477 1
	 but the data is still available if you know where to look.  */
d528 1
a528 1
  printf( "--About to read shared library list data\n" );
d543 2
a544 2
      LONGEST  st_size;
      int  is_main_program;
d580 1
a580 1
	 die.  */
d590 1
a590 1
	  addr = (CORE_ADDR) extract_unsigned_integer (buf, 4);          
d598 2
a599 2
          /* This is the "next" pointer in the strcuture.
           */
d606 18
a623 18
          /* Record the main program's symbol table size. */
          if (is_main_program && !so_list)
            {
              st_size = som_solib_sizeof_symbol_table (name);
              som_solib_total_st_size += st_size;
            }

          /* Was this a shlib that we noted but didn't load the symbols for?
             If so, were we invoked this time from the command-line, via
             a 'sharedlibrary' or 'add-symbol-file' command?  If yes to
             both, we'd better load the symbols this time.
             */
          if (from_tty && so_list && !is_main_program && (so_list->objfile == NULL))
            som_solib_load_symbols (so_list,
                                    name,
                                    from_tty,
                                    so_list->som_solib.text_addr,
                                    target);
d638 1
a638 1
      memset ((char *)new_so, 0, sizeof (struct so_list));
d652 1
a652 1
       
d661 3
a663 3
        /* Following is "high water mark", highest version number
         * seen, rather than plain version number.
         */
d667 3
a669 3
        /* Q: What about longword at "addr + 8"?
         * A: It's read above, out of order, into "text_addr".
         */
d711 1
a711 1
      new_so->som_solib.next = (void *)extract_unsigned_integer (buf, 4);
d720 1
a720 1
        goto err;
d727 1
a727 1
        goto err;
d729 13
a741 13
      printf( "\n+ library \"%s\" is described at 0x%x\n", name, addr );
      printf( "  'version' is %d\n",          new_so->som_solib.struct_version );
      printf( "  'bind_mode' is %d\n",        new_so->som_solib.bind_mode );
      printf( "  'library_version' is %d\n",  new_so->som_solib.library_version );
      printf( "  'text_addr' is 0x%x\n",      new_so->som_solib.text_addr );
      printf( "  'text_link_addr' is 0x%x\n", new_so->som_solib.text_link_addr );
      printf( "  'text_end' is 0x%x\n",       new_so->som_solib.text_end );
      printf( "  'data_start' is 0x%x\n",     new_so->som_solib.data_start );
      printf( "  'bss_start' is 0x%x\n",      new_so->som_solib.bss_start );
      printf( "  'data_end' is 0x%x\n",       new_so->som_solib.data_end );
      printf( "  'got_value' is %x\n",        new_so->som_solib.got_value );
      printf( "  'next' is 0x%x\n",           new_so->som_solib.next );
      printf( "  'tsd_start_addr' is 0x%x\n", new_so->som_solib.tsd_start_addr );
d746 1
a746 1
      addr = (CORE_ADDR)new_so->som_solib.next;
d764 1
a764 1
         */
d769 1
a769 1
         */
d772 2
a773 2
        !from_tty &&
        ((st_size + som_solib_total_st_size) > (auto_solib_add * (LONGEST)1000000));
d776 14
a789 14
        {
          if (! threshold_warning_given)
            warning ("Symbols for some libraries have not been loaded, because\ndoing so would exceed the size threshold specified by auto-solib-add.\nTo manually load symbols, use the 'sharedlibrary' command.\nTo raise the threshold, set auto-solib-add to a larger value and rerun\nthe program.\n");
          threshold_warning_given = 1;

          /* We'll still make note of this shlib, even if we don't
             read its symbols.  This allows us to use its unwind
             information well enough to know how to e.g., correctly
             do a traceback from a PC within the shlib, even if we
             can't symbolize those PCs...
             */
          som_solib_add_solib_objfile (new_so, name, from_tty, text_addr);
          continue;
        }
d798 1
a798 1
    printf( "--Done reading shared library data\n" );
d830 1
a830 1
         __dld_list structure when loading/unloading libraries.
d837 1
a837 1
som_solib_create_inferior_hook()
d851 1
a851 1
    return; 
d892 1
a892 1
     */
d895 1
a895 1
      msymbol = lookup_minimal_symbol ("__d_trap", NULL, symfile_objfile);
d909 19
a927 3
    {
      struct unwind_table_entry *u;
      struct minimal_symbol *msymbol2;
d929 5
a933 21
      /* What a crock.  */
      msymbol2 = lookup_minimal_symbol_solib_trampoline (SYMBOL_NAME (msymbol),
							 NULL, objfile);
      /* Found a symbol with the right name.  */
      if (msymbol2)
	{
	  struct unwind_table_entry *u;
	  /* It must be a shared library trampoline.  */
	  if (SYMBOL_TYPE (msymbol2) != mst_solib_trampoline)
	    continue;

	  /* It must also be an export stub.  */
	  u = find_unwind_entry (SYMBOL_VALUE (msymbol2));
	  if (!u || u->stub_unwind.stub_type != EXPORT)
	    continue;

	  /* OK.  Looks like the correct import stub.  */
	  anaddr = SYMBOL_VALUE (msymbol2);
          dld_cache.hook_stub.address = anaddr;
	}
    }
d946 1
a946 1
  
d997 5
a1001 2
	* Not all sites have /opt/langtools/lib/end.o, so it's not always
	possible to track the dynamic linker's events.
a1002 3
	* At this time no events are triggered for shared libraries
	loaded at startup time (what a crock).  */
	
d1030 1
a1030 1
  int  saved_inferior_pid;
d1045 1
a1045 1
   */
d1048 1
a1048 1
  int  pid;
d1050 7
a1056 7
  CORE_ADDR  addr;
  struct minimal_symbol *  msymbol;
  int  status;
  char  dld_flags_buffer [TARGET_INT_BIT/TARGET_CHAR_BIT];
  unsigned int  dld_flags_value;
  int  saved_inferior_pid = inferior_pid;
  struct cleanup *  old_cleanups = make_cleanup (reset_inferior_pid, saved_inferior_pid);
d1067 1
a1067 1
     */
d1071 1
a1071 1
  status = target_read_memory (addr, dld_flags_buffer, TARGET_INT_BIT/TARGET_CHAR_BIT);
d1074 1
a1074 1
                                              sizeof (dld_flags_value));
d1078 3
a1080 3
                          sizeof (dld_flags_value),
                          dld_flags_value);
  status = target_write_memory (addr, dld_flags_buffer, TARGET_INT_BIT/TARGET_CHAR_BIT);
d1096 1
a1096 1
   */
d1099 4
a1102 4
  int  pid;
  int  tempflag;
  char *  filename;
  char *  cond_string;
d1117 1
a1117 1
   */
d1120 4
a1123 4
  int  pid;
  int  tempflag;
  char *  filename;
  char *  cond_string;
d1130 1
a1130 1
  int  pid;
d1132 1
a1132 1
  CORE_ADDR  event_kind;
d1140 1
a1140 1
  int  pid;
d1142 1
a1142 1
  CORE_ADDR  event_kind;
d1150 1
a1150 1
  int  pid;
d1152 5
a1156 5
  CORE_ADDR  dll_handle_address;
  CORE_ADDR  dll_pathname_address;
  struct som_solib_mapped_entry  dll_descriptor;
  char *  p;
  static char  dll_pathname [1024];
d1164 1
a1164 1
  
d1169 1
a1169 1
      char  b;
d1173 1
a1173 1
        break;
d1181 1
a1181 1
  int  pid;
d1183 1
a1183 1
  if (! som_solib_have_load_event (pid))
d1191 1
a1191 1
  int  pid;
d1193 1
a1193 1
  if (! som_solib_have_unload_event (pid))
d1204 1
a1204 1
  struct minimal_symbol *  dld_msymbol;
d1211 1
a1211 1
     */
d1216 72
a1287 72
    {
      dld_msymbol = lookup_minimal_symbol ("shl_load", NULL, objfile);
      if (dld_msymbol != NULL)
        {
          dld_cache.load.address = SYMBOL_VALUE (dld_msymbol);
          dld_cache.load.unwind = find_unwind_entry (dld_cache.load.address);
        }

      dld_msymbol = lookup_minimal_symbol_solib_trampoline ("shl_load",
                                                            NULL,
                                                            objfile);
      if (dld_msymbol != NULL)
        {
          if (SYMBOL_TYPE (dld_msymbol) == mst_solib_trampoline)
            {
              u = find_unwind_entry (SYMBOL_VALUE (dld_msymbol));
              if ((u != NULL) && (u->stub_unwind.stub_type == EXPORT))
                {
                  dld_cache.load_stub.address = SYMBOL_VALUE (dld_msymbol);
                  dld_cache.load_stub.unwind = u;
                }
            }
        }

      dld_msymbol = lookup_minimal_symbol ("shl_unload", NULL, objfile);
      if (dld_msymbol != NULL)
        {
          dld_cache.unload.address = SYMBOL_VALUE (dld_msymbol);
          dld_cache.unload.unwind = find_unwind_entry (dld_cache.unload.address);

          /* ??rehrauer: I'm not sure exactly what this is, but it appears
             that on some HPUX 10.x versions, there's two unwind regions to
             cover the body of "shl_unload", the second being 4 bytes past
             the end of the first.  This is a large hack to handle that
             case, but since I don't seem to have any legitimate way to
             look for this thing via the symbol table...
             */
          if (dld_cache.unload.unwind != NULL)
            {
              u = find_unwind_entry (dld_cache.unload.unwind->region_end + 4);
              if (u != NULL)
                {
                  dld_cache.unload2.address = u->region_start;
                  dld_cache.unload2.unwind = u;
                }
            }
        }

      dld_msymbol = lookup_minimal_symbol_solib_trampoline ("shl_unload",
                                                            NULL,
                                                            objfile);
      if (dld_msymbol != NULL)
        {
          if (SYMBOL_TYPE (dld_msymbol) == mst_solib_trampoline)
            {
              u = find_unwind_entry (SYMBOL_VALUE (dld_msymbol));
              if ((u != NULL) && (u->stub_unwind.stub_type == EXPORT))
                {
                  dld_cache.unload_stub.address = SYMBOL_VALUE (dld_msymbol);
                  dld_cache.unload_stub.unwind = u;
                }
            }
        }

      /* Did we find everything we were looking for?  If so, stop. */
      if ((dld_cache.load.address != NULL) && (dld_cache.load_stub.address != NULL)
          && (dld_cache.unload.address != NULL) && (dld_cache.unload_stub.address != NULL))
        {
          dld_cache.is_valid = 1;
          break;
        }
    }
d1294 1
a1294 1
     */
d1299 2
a1300 2
  int  pid;
  CORE_ADDR  pc;
d1302 1
a1302 1
  struct unwind_table_entry *  u_pc;
d1313 1
a1313 1
     */
d1319 1
a1319 1
     */
d1370 1
a1370 1
/* this function is used in hppa_fix_call_dummy in hppa-tdep.c*/
d1382 1
a1382 1
        {
d1384 1
a1384 1
        }
d1388 1
a1388 1
   return so_list->solib_addr;
d1390 1
a1390 1
   return 0;
d1404 1
a1404 1
	 is valid.  The BFDs will never match.  Make a best guess.  */
d1449 1
a1449 1
      printf_unfiltered ("no exec file.\n");
d1461 1
a1461 1
		     "  flags", "  tstart", "   tend", "  dstart", "   dend", "   dlt");
d1471 1
a1471 1
        printf_unfiltered ("  (symbols not loaded)");
d1475 1
a1475 1
	      local_hex_string_custom (so_list->som_solib.text_addr, "08l"));
d1479 1
a1479 1
	      local_hex_string_custom (so_list->som_solib.data_start, "08l"));
d1483 1
a1483 1
	      local_hex_string_custom (so_list->som_solib.got_value, "08l"));
d1501 1
a1501 1
  CORE_ADDR  addr;
d1503 1
a1503 1
  struct so_list *  so = so_list_head;
d1509 1
a1509 1
         */
d1511 1
a1511 1
        return so->som_solib.name;
d1525 1
a1525 1
  struct so_list *  sl = so_list_head;
d1529 1
a1529 1
     */
d1533 1
a1533 1
     */
d1536 1
a1536 1
      struct so_list *  next_sl = sl->next;
d1575 1
a1575 1
           "Load shared object library symbols for files matching REGEXP.");
d1598 2
a1599 2
     */
  auto_solib_add = 100; /* Megabytes */
d1607 2
a1608 2
so_lib_thread_start_addr( so )
    struct so_list *so;
d1610 1
a1610 1
    return so->som_solib.tsd_start_addr;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.
d20 2
a21 2
   Written by the Center for Software Science at the Univerity of Utah
   and by Cygnus Support.  */
d53 1
a53 1

d65 1
a65 1
 */
d83 6
a88 45
  {
    /* The name of the library.  */
    char *name;

    /* Version of this structure (it is expected to change again in hpux10).  */
    unsigned char struct_version;

    /* Binding mode for this library.  */
    unsigned char bind_mode;

    /* Version of this library.  */
    short library_version;

    /* Start of text address,
     * link-time text location (length of text area),
     * end of text address.  */
    CORE_ADDR text_addr;
    CORE_ADDR text_link_addr;
    CORE_ADDR text_end;

    /* Start of data, start of bss and end of data.  */
    CORE_ADDR data_start;
    CORE_ADDR bss_start;
    CORE_ADDR data_end;

    /* Value of linkage pointer (%r19).  */
    CORE_ADDR got_value;

    /* Next entry.  */
    struct som_solib_mapped_entry *next;

    /* There are other fields, but I don't have information as to what is
       contained in them.  */

    /* For versions from HPUX-10.30 and up */

    /* Address in target of offset from thread-local register of
     * start of this thread's data.  I.e., the first thread-local
     * variable in this shared library starts at *(tsd_start_addr)
     * from that area pointed to by cr27 (mpsfu_hi).
     *
     * We do the indirection as soon as we read it, so from then
     * on it's the offset itself.
     */
    CORE_ADDR tsd_start_addr;
d90 2
a91 1
    /* Following this are longwords holding:
d93 35
a127 3
     * ?, ?, ?, ptr to -1, ptr to-1, ptr to lib name (leaf name),
     * ptr to __data_start, ptr to __data_end
     */
d129 5
d135 2
a136 1
  };
d140 6
a145 6
  {
    struct som_solib_mapped_entry som_solib;
    struct objfile *objfile;
    bfd *abfd;
    struct section_table *sections;
    struct section_table *sections_end;
d148 5
a152 5
   som_solib_mapped_entry structure */
    CORE_ADDR solib_addr;
    struct so_list *next;

  };
d165 2
a166 2
 */
static LONGEST som_solib_total_st_size;
d176 2
a177 2
 */
static int som_solib_st_size_threshold_exceeded;
d181 5
a185 7
 */
typedef struct
  {
    CORE_ADDR address;
    struct unwind_table_entry *unwind;
  }
addr_and_unwind_t;
d188 10
a197 12
static struct
  {
    boolean is_valid;
    addr_and_unwind_t hook;
    addr_and_unwind_t hook_stub;
    addr_and_unwind_t load;
    addr_and_unwind_t load_stub;
    addr_and_unwind_t unload;
    addr_and_unwind_t unload2;
    addr_and_unwind_t unload_stub;
  }
dld_cache;
d207 1
a207 1
     char *filename;
d209 5
a213 5
  bfd *abfd;
  int desc;
  char *absolute_name;
  LONGEST st_size = (LONGEST) 0;
  asection *sect;
d217 1
a217 1
   */
d226 1
a226 1
  if (!abfd)
d233 2
a234 2

  if (!bfd_check_format (abfd, bfd_object))	/* Reads in section info */
d236 1
a236 1
      bfd_close (abfd);		/* This also closes desc */
d254 1
a254 1
  bfd_close (abfd);		/* This also closes desc */
d272 1
a272 1
   */
d279 4
a282 4
     struct so_list *so;
     char *name;
     int from_tty;
     CORE_ADDR text_addr;
d285 1
a285 1

d293 1
a293 1
  if (so->objfile->obj_private == NULL)
d296 2
a297 2
	obstack_alloc (&so->objfile->psymbol_obstack,
		       sizeof (obj_private_data_t));
d299 1
a299 1
      obj_private->so_info = NULL;
d301 1
a301 1
    }
d309 1
a309 1
	     name, bfd_errmsg (bfd_get_error ()));
d316 10
a325 10
     struct so_list *so;
     char *name;
     int from_tty;
     CORE_ADDR text_addr;
     struct target_ops *target;
{
  struct section_table *p;
  int status;
  char buf[4];
  CORE_ADDR presumed_data_start;
d328 1
a328 1
  printf ("--Adding symbols for shared library \"%s\"\n", name);
d337 2
a338 2
			   &so->sections,
			   &so->sections_end))
d348 4
a351 4
	{
	  p->addr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_TEXT);
	  p->endaddr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_TEXT);
	}
d353 4
a356 4
	{
	  p->addr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_DATA);
	  p->endaddr += ANOFFSET (so->objfile->section_offsets, SECT_OFF_DATA);
	}
d388 6
a393 6
	{
	  old = target->to_sections_end - target->to_sections;
	  target->to_sections = (struct section_table *)
	    xrealloc ((char *) target->to_sections,
		      ((sizeof (struct section_table)) * (old + new)));
	}
d395 5
a399 5
	{
	  old = 0;
	  target->to_sections = (struct section_table *)
	    xmalloc ((sizeof (struct section_table)) * new);
	}
d405 4
a408 4
	{
	  core_ops.to_sections = target->to_sections;
	  core_ops.to_sections_end = target->to_sections_end;
	}
d411 4
a414 4
	{
	  exec_ops.to_sections = target->to_sections;
	  exec_ops.to_sections_end = target->to_sections_end;
	}
d417 3
a419 3
      memcpy ((char *) (target->to_sections + old),
	      so->sections,
	      ((sizeof (struct section_table)) * new));
d441 1
a441 1
  int threshold_warning_given = 0;
d490 1
a490 1
   */
d494 1
a494 1
	error ("__dld_list is not valid according to __dld_flags.\n");
d506 1
a506 1
         but the data is still available if you know where to look.  */
d557 1
a557 1
  printf ("--About to read shared library list data\n");
d572 2
a573 2
      LONGEST st_size;
      int is_main_program;
d609 1
a609 1
         die.  */
d619 1
a619 1
	  addr = (CORE_ADDR) extract_unsigned_integer (buf, 4);
d627 2
a628 2
	  /* This is the "next" pointer in the strcuture.
	   */
d635 18
a652 18
	  /* Record the main program's symbol table size. */
	  if (is_main_program && !so_list)
	    {
	      st_size = som_solib_sizeof_symbol_table (name);
	      som_solib_total_st_size += st_size;
	    }

	  /* Was this a shlib that we noted but didn't load the symbols for?
	     If so, were we invoked this time from the command-line, via
	     a 'sharedlibrary' or 'add-symbol-file' command?  If yes to
	     both, we'd better load the symbols this time.
	   */
	  if (from_tty && so_list && !is_main_program && (so_list->objfile == NULL))
	    som_solib_load_symbols (so_list,
				    name,
				    from_tty,
				    so_list->som_solib.text_addr,
				    target);
d667 1
a667 1
      memset ((char *) new_so, 0, sizeof (struct so_list));
d681 1
a681 1

d690 3
a692 3
      /* Following is "high water mark", highest version number
       * seen, rather than plain version number.
       */
d696 3
a698 3
      /* Q: What about longword at "addr + 8"?
       * A: It's read above, out of order, into "text_addr".
       */
d740 1
a740 1
      new_so->som_solib.next = (void *) extract_unsigned_integer (buf, 4);
d749 1
a749 1
	goto err;
d756 1
a756 1
	goto err;
d758 13
a770 13
      printf ("\n+ library \"%s\" is described at 0x%x\n", name, addr);
      printf ("  'version' is %d\n", new_so->som_solib.struct_version);
      printf ("  'bind_mode' is %d\n", new_so->som_solib.bind_mode);
      printf ("  'library_version' is %d\n", new_so->som_solib.library_version);
      printf ("  'text_addr' is 0x%x\n", new_so->som_solib.text_addr);
      printf ("  'text_link_addr' is 0x%x\n", new_so->som_solib.text_link_addr);
      printf ("  'text_end' is 0x%x\n", new_so->som_solib.text_end);
      printf ("  'data_start' is 0x%x\n", new_so->som_solib.data_start);
      printf ("  'bss_start' is 0x%x\n", new_so->som_solib.bss_start);
      printf ("  'data_end' is 0x%x\n", new_so->som_solib.data_end);
      printf ("  'got_value' is %x\n", new_so->som_solib.got_value);
      printf ("  'next' is 0x%x\n", new_so->som_solib.next);
      printf ("  'tsd_start_addr' is 0x%x\n", new_so->som_solib.tsd_start_addr);
d775 1
a775 1
      addr = (CORE_ADDR) new_so->som_solib.next;
d793 1
a793 1
       */
d798 1
a798 1
       */
d801 2
a802 2
	!from_tty &&
	((st_size + som_solib_total_st_size) > (auto_solib_add * (LONGEST) 1000000));
d805 14
a818 14
	{
	  if (!threshold_warning_given)
	    warning ("Symbols for some libraries have not been loaded, because\ndoing so would exceed the size threshold specified by auto-solib-add.\nTo manually load symbols, use the 'sharedlibrary' command.\nTo raise the threshold, set auto-solib-add to a larger value and rerun\nthe program.\n");
	  threshold_warning_given = 1;

	  /* We'll still make note of this shlib, even if we don't
	     read its symbols.  This allows us to use its unwind
	     information well enough to know how to e.g., correctly
	     do a traceback from a PC within the shlib, even if we
	     can't symbolize those PCs...
	   */
	  som_solib_add_solib_objfile (new_so, name, from_tty, text_addr);
	  continue;
	}
d827 1
a827 1
  printf ("--Done reading shared library data\n");
d859 1
a859 1
   __dld_list structure when loading/unloading libraries.
d866 1
a866 1
som_solib_create_inferior_hook ()
d880 1
a880 1
    return;
d921 1
a921 1
   */
d924 1
a924 1
    msymbol = lookup_minimal_symbol ("__d_trap", NULL, symfile_objfile);
d938 3
a940 14
  {
    struct unwind_table_entry *u;
    struct minimal_symbol *msymbol2;

    /* What a crock.  */
    msymbol2 = lookup_minimal_symbol_solib_trampoline (SYMBOL_NAME (msymbol),
						       NULL, objfile);
    /* Found a symbol with the right name.  */
    if (msymbol2)
      {
	struct unwind_table_entry *u;
	/* It must be a shared library trampoline.  */
	if (SYMBOL_TYPE (msymbol2) != mst_solib_trampoline)
	  continue;
d942 21
a962 10
	/* It must also be an export stub.  */
	u = find_unwind_entry (SYMBOL_VALUE (msymbol2));
	if (!u || u->stub_unwind.stub_type != EXPORT)
	  continue;

	/* OK.  Looks like the correct import stub.  */
	anaddr = SYMBOL_VALUE (msymbol2);
	dld_cache.hook_stub.address = anaddr;
      }
  }
d975 1
a975 1

d1026 2
a1027 5
     * Not all sites have /opt/langtools/lib/end.o, so it's not always
     possible to track the dynamic linker's events.

     * At this time no events are triggered for shared libraries
     loaded at startup time (what a crock).  */
d1029 3
d1059 1
a1059 1
     int saved_inferior_pid;
d1074 1
a1074 1
 */
d1077 1
a1077 1
     int pid;
d1079 7
a1085 7
  CORE_ADDR addr;
  struct minimal_symbol *msymbol;
  int status;
  char dld_flags_buffer[TARGET_INT_BIT / TARGET_CHAR_BIT];
  unsigned int dld_flags_value;
  int saved_inferior_pid = inferior_pid;
  struct cleanup *old_cleanups = make_cleanup (reset_inferior_pid, saved_inferior_pid);
d1096 1
a1096 1
   */
d1100 1
a1100 1
  status = target_read_memory (addr, dld_flags_buffer, TARGET_INT_BIT / TARGET_CHAR_BIT);
d1103 1
a1103 1
					      sizeof (dld_flags_value));
d1107 3
a1109 3
			  sizeof (dld_flags_value),
			  dld_flags_value);
  status = target_write_memory (addr, dld_flags_buffer, TARGET_INT_BIT / TARGET_CHAR_BIT);
d1125 1
a1125 1
 */
d1128 4
a1131 4
     int pid;
     int tempflag;
     char *filename;
     char *cond_string;
d1146 1
a1146 1
 */
d1149 4
a1152 4
     int pid;
     int tempflag;
     char *filename;
     char *cond_string;
d1159 1
a1159 1
     int pid;
d1161 1
a1161 1
  CORE_ADDR event_kind;
d1169 1
a1169 1
     int pid;
d1171 1
a1171 1
  CORE_ADDR event_kind;
d1179 1
a1179 1
     int pid;
d1181 5
a1185 5
  CORE_ADDR dll_handle_address;
  CORE_ADDR dll_pathname_address;
  struct som_solib_mapped_entry dll_descriptor;
  char *p;
  static char dll_pathname[1024];
d1193 1
a1193 1

d1198 1
a1198 1
      char b;
d1202 1
a1202 1
	break;
d1210 1
a1210 1
     int pid;
d1212 1
a1212 1
  if (!som_solib_have_load_event (pid))
d1220 1
a1220 1
     int pid;
d1222 1
a1222 1
  if (!som_solib_have_unload_event (pid))
d1233 1
a1233 1
  struct minimal_symbol *dld_msymbol;
d1240 1
a1240 1
   */
d1245 72
a1316 72
  {
    dld_msymbol = lookup_minimal_symbol ("shl_load", NULL, objfile);
    if (dld_msymbol != NULL)
      {
	dld_cache.load.address = SYMBOL_VALUE (dld_msymbol);
	dld_cache.load.unwind = find_unwind_entry (dld_cache.load.address);
      }

    dld_msymbol = lookup_minimal_symbol_solib_trampoline ("shl_load",
							  NULL,
							  objfile);
    if (dld_msymbol != NULL)
      {
	if (SYMBOL_TYPE (dld_msymbol) == mst_solib_trampoline)
	  {
	    u = find_unwind_entry (SYMBOL_VALUE (dld_msymbol));
	    if ((u != NULL) && (u->stub_unwind.stub_type == EXPORT))
	      {
		dld_cache.load_stub.address = SYMBOL_VALUE (dld_msymbol);
		dld_cache.load_stub.unwind = u;
	      }
	  }
      }

    dld_msymbol = lookup_minimal_symbol ("shl_unload", NULL, objfile);
    if (dld_msymbol != NULL)
      {
	dld_cache.unload.address = SYMBOL_VALUE (dld_msymbol);
	dld_cache.unload.unwind = find_unwind_entry (dld_cache.unload.address);

	/* ??rehrauer: I'm not sure exactly what this is, but it appears
	   that on some HPUX 10.x versions, there's two unwind regions to
	   cover the body of "shl_unload", the second being 4 bytes past
	   the end of the first.  This is a large hack to handle that
	   case, but since I don't seem to have any legitimate way to
	   look for this thing via the symbol table...
	 */
	if (dld_cache.unload.unwind != NULL)
	  {
	    u = find_unwind_entry (dld_cache.unload.unwind->region_end + 4);
	    if (u != NULL)
	      {
		dld_cache.unload2.address = u->region_start;
		dld_cache.unload2.unwind = u;
	      }
	  }
      }

    dld_msymbol = lookup_minimal_symbol_solib_trampoline ("shl_unload",
							  NULL,
							  objfile);
    if (dld_msymbol != NULL)
      {
	if (SYMBOL_TYPE (dld_msymbol) == mst_solib_trampoline)
	  {
	    u = find_unwind_entry (SYMBOL_VALUE (dld_msymbol));
	    if ((u != NULL) && (u->stub_unwind.stub_type == EXPORT))
	      {
		dld_cache.unload_stub.address = SYMBOL_VALUE (dld_msymbol);
		dld_cache.unload_stub.unwind = u;
	      }
	  }
      }

    /* Did we find everything we were looking for?  If so, stop. */
    if ((dld_cache.load.address != NULL) && (dld_cache.load_stub.address != NULL)
	&& (dld_cache.unload.address != NULL) && (dld_cache.unload_stub.address != NULL))
      {
	dld_cache.is_valid = 1;
	break;
      }
  }
d1323 1
a1323 1
   */
d1328 2
a1329 2
     int pid;
     CORE_ADDR pc;
d1331 1
a1331 1
  struct unwind_table_entry *u_pc;
d1342 1
a1342 1
   */
d1348 1
a1348 1
   */
d1399 1
a1399 1
/* this function is used in hppa_fix_call_dummy in hppa-tdep.c */
d1411 1
a1411 1
	{
d1413 1
a1413 1
	}
d1417 1
a1417 1
    return so_list->solib_addr;
d1419 1
a1419 1
    return 0;
d1433 1
a1433 1
         is valid.  The BFDs will never match.  Make a best guess.  */
d1490 1
a1490 1
	 "  flags", "  tstart", "   tend", "  dstart", "   dend", "   dlt");
d1500 1
a1500 1
	printf_unfiltered ("  (symbols not loaded)");
d1504 1
a1504 1
	     local_hex_string_custom (so_list->som_solib.text_addr, "08l"));
d1508 1
a1508 1
	    local_hex_string_custom (so_list->som_solib.data_start, "08l"));
d1512 1
a1512 1
	     local_hex_string_custom (so_list->som_solib.got_value, "08l"));
d1530 1
a1530 1
     CORE_ADDR addr;
d1532 1
a1532 1
  struct so_list *so = so_list_head;
d1538 1
a1538 1
       */
d1540 1
a1540 1
	return so->som_solib.name;
d1554 1
a1554 1
  struct so_list *sl = so_list_head;
d1558 1
a1558 1
   */
d1562 1
a1562 1
   */
d1565 1
a1565 1
      struct so_list *next_sl = sl->next;
d1604 1
a1604 1
	   "Load shared object library symbols for files matching REGEXP.");
d1627 2
a1628 2
   */
  auto_solib_add = 100;		/* Megabytes */
d1636 2
a1637 2
so_lib_thread_start_addr (so)
     struct so_list *so;
d1639 1
a1639 1
  return so->som_solib.tsd_start_addr;
@


1.1.1.3
log
@import gdb-1999-09-28 snapshot
@
text
@d378 11
d391 30
a420 3
      
      old = target_resize_to_sections (target, new);
      
@


1.1.1.4
log
@import gdb-1999-10-04 snapshot
@
text
@a289 1
  struct section_addr_info section_addrs;
d291 1
a291 3
  memset (&section_addrs, 0, sizeof (section_addrs));
  section_addrs.text_addr = text_addr;
  so->objfile = symbol_file_add (name, from_tty, &section_addrs, 0, 0, 0, 1);
@


1.1.1.5
log
@import gdb-1999-10-11 snapshot
@
text
@d294 1
a294 1
  so->objfile = symbol_file_add (name, from_tty, &section_addrs, 0, OBJF_SHARED);
@


1.1.1.6
log
@import gdb-1999-11-16 snapshot
@
text
@d1448 1
a1448 1
      printf_unfiltered ("No executable file.\n");
@


