head	1.24;
access;
symbols
	insight_6_6-20070208-release:1.22
	gdb_6_6-2006-12-18-release:1.22
	gdb_6_6-branch:1.22.0.18
	gdb_6_6-2006-11-15-branchpoint:1.22
	insight_6_5-20061003-release:1.22
	gdb-csl-symbian-6_4_50_20060226-12:1.22
	gdb-csl-sourcerygxx-3_4_4-25:1.21
	nickrob-async-20060828-mergepoint:1.22
	gdb-csl-symbian-6_4_50_20060226-11:1.22
	gdb-csl-sourcerygxx-4_1-17:1.22
	gdb-csl-20060226-branch-local-2:1.22
	gdb-csl-sourcerygxx-4_1-14:1.22
	gdb-csl-sourcerygxx-4_1-13:1.22
	gdb-csl-sourcerygxx-4_1-12:1.22
	gdb-csl-sourcerygxx-3_4_4-21:1.22
	gdb_6_5-20060621-release:1.22
	gdb-csl-sourcerygxx-4_1-9:1.22
	gdb-csl-sourcerygxx-4_1-8:1.22
	gdb-csl-sourcerygxx-4_1-7:1.22
	gdb-csl-arm-2006q1-6:1.22
	gdb-csl-sourcerygxx-4_1-6:1.22
	gdb-csl-symbian-6_4_50_20060226-10:1.22
	gdb-csl-symbian-6_4_50_20060226-9:1.22
	gdb-csl-symbian-6_4_50_20060226-8:1.22
	gdb-csl-coldfire-4_1-11:1.22
	gdb-csl-sourcerygxx-3_4_4-19:1.22
	gdb-csl-coldfire-4_1-10:1.22
	gdb_6_5-branch:1.22.0.16
	gdb_6_5-2006-05-14-branchpoint:1.22
	gdb-csl-sourcerygxx-4_1-5:1.22
	nickrob-async-20060513-branch:1.22.0.14
	nickrob-async-20060513-branchpoint:1.22
	gdb-csl-sourcerygxx-4_1-4:1.22
	msnyder-reverse-20060502-branch:1.22.0.12
	msnyder-reverse-20060502-branchpoint:1.22
	gdb-csl-morpho-4_1-4:1.22
	gdb-csl-sourcerygxx-3_4_4-17:1.22
	readline_5_1-import-branch:1.22.0.10
	readline_5_1-import-branchpoint:1.22
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.22
	gdb-csl-symbian-20060226-branch:1.22.0.8
	gdb-csl-symbian-20060226-branchpoint:1.22
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.22
	msnyder-reverse-20060331-branch:1.22.0.6
	msnyder-reverse-20060331-branchpoint:1.22
	gdb-csl-available-20060303-branch:1.22.0.4
	gdb-csl-available-20060303-branchpoint:1.22
	gdb-csl-20060226-branch:1.22.0.2
	gdb-csl-20060226-branchpoint:1.22
	gdb_6_4-20051202-release:1.21
	msnyder-fork-checkpoint-branch:1.21.0.14
	msnyder-fork-checkpoint-branchpoint:1.21
	gdb-csl-gxxpro-6_3-branch:1.21.0.12
	gdb-csl-gxxpro-6_3-branchpoint:1.21
	gdb_6_4-branch:1.21.0.10
	gdb_6_4-2005-11-01-branchpoint:1.21
	gdb-csl-arm-20051020-branch:1.21.0.8
	gdb-csl-arm-20051020-branchpoint:1.21
	msnyder-tracepoint-checkpoint-branch:1.21.0.6
	msnyder-tracepoint-checkpoint-branchpoint:1.21
	gdb-csl-arm-20050325-2005-q1b:1.21
	gdb-csl-arm-20050325-2005-q1a:1.21
	csl-arm-20050325-branch:1.21.0.4
	csl-arm-20050325-branchpoint:1.21
	gdb-post-i18n-errorwarning-20050211:1.21
	gdb-pre-i18n-errorwarning-20050211:1.21
	gdb_6_3-20041109-release:1.21
	gdb_6_3-branch:1.21.0.2
	gdb_6_3-20041019-branchpoint:1.21
	drow_intercu-merge-20040921:1.21
	drow_intercu-merge-20040915:1.21
	jimb-gdb_6_2-e500-branch:1.19.0.6
	jimb-gdb_6_2-e500-branchpoint:1.19
	gdb_6_2-20040730-release:1.19
	gdb_6_2-branch:1.19.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.19
	gdb_6_1_1-20040616-release:1.18
	gdb_6_1-2004-04-05-release:1.18
	drow_intercu-merge-20040402:1.18
	drow_intercu-merge-20040327:1.18
	ezannoni_pie-20040323-branch:1.18.0.12
	ezannoni_pie-20040323-branchpoint:1.18
	cagney_tramp-20040321-mergepoint:1.18
	cagney_tramp-20040309-branch:1.18.0.10
	cagney_tramp-20040309-branchpoint:1.18
	gdb_6_1-branch:1.18.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.18
	drow_intercu-20040221-branch:1.18.0.6
	drow_intercu-20040221-branchpoint:1.18
	cagney_bfdfile-20040213-branch:1.18.0.4
	cagney_bfdfile-20040213-branchpoint:1.18
	drow-cplus-merge-20040208:1.18
	carlton_dictionary-20040126-merge:1.18
	cagney_bigcore-20040122-branch:1.18.0.2
	cagney_bigcore-20040122-branchpoint:1.18
	drow-cplus-merge-20040113:1.17
	drow-cplus-merge-20031224:1.17
	drow-cplus-merge-20031220:1.17
	carlton_dictionary-20031215-merge:1.17
	drow-cplus-merge-20031214:1.17
	carlton-dictionary-20031111-merge:1.17
	gdb_6_0-2003-10-04-release:1.14
	kettenis_sparc-20030918-branch:1.16.0.2
	kettenis_sparc-20030918-branchpoint:1.16
	carlton_dictionary-20030917-merge:1.16
	ezannoni_pie-20030916-branchpoint:1.14
	ezannoni_pie-20030916-branch:1.14.0.18
	cagney_x86i386-20030821-branch:1.14.0.16
	cagney_x86i386-20030821-branchpoint:1.14
	carlton_dictionary-20030805-merge:1.14
	carlton_dictionary-20030627-merge:1.14
	gdb_6_0-branch:1.14.0.14
	gdb_6_0-2003-06-23-branchpoint:1.14
	jimb-ppc64-linux-20030613-branch:1.14.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.14
	cagney_convert-20030606-branch:1.14.0.10
	cagney_convert-20030606-branchpoint:1.14
	cagney_writestrings-20030508-branch:1.14.0.8
	cagney_writestrings-20030508-branchpoint:1.14
	jimb-ppc64-linux-20030528-branch:1.14.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.14
	carlton_dictionary-20030523-merge:1.14
	cagney_fileio-20030521-branch:1.14.0.4
	cagney_fileio-20030521-branchpoint:1.14
	kettenis_i386newframe-20030517-mergepoint:1.14
	jimb-ppc64-linux-20030509-branch:1.14.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.14
	kettenis_i386newframe-20030504-mergepoint:1.13
	carlton_dictionary-20030430-merge:1.13
	kettenis_i386newframe-20030419-branch:1.13.0.16
	kettenis_i386newframe-20030419-branchpoint:1.13
	carlton_dictionary-20030416-merge:1.13
	cagney_frameaddr-20030409-mergepoint:1.13
	kettenis_i386newframe-20030406-branch:1.13.0.14
	kettenis_i386newframe-20030406-branchpoint:1.13
	cagney_frameaddr-20030403-branchpoint:1.13
	cagney_frameaddr-20030403-branch:1.13.0.12
	cagney_framebase-20030330-mergepoint:1.13
	cagney_framebase-20030326-branch:1.13.0.10
	cagney_framebase-20030326-branchpoint:1.13
	cagney_lazyid-20030317-branch:1.13.0.8
	cagney_lazyid-20030317-branchpoint:1.13
	kettenis-i386newframe-20030316-mergepoint:1.13
	offbyone-20030313-branch:1.13.0.6
	offbyone-20030313-branchpoint:1.13
	kettenis-i386newframe-20030308-branch:1.13.0.4
	kettenis-i386newframe-20030308-branchpoint:1.13
	carlton_dictionary-20030305-merge:1.13
	cagney_offbyone-20030303-branch:1.13.0.2
	cagney_offbyone-20030303-branchpoint:1.13
	carlton_dictionary-20030207-merge:1.13
	interps-20030203-mergepoint:1.12
	interps-20030202-branch:1.12.0.2
	interps-20030202-branchpoint:1.12
	cagney-unwind-20030108-branch:1.11.0.2
	cagney-unwind-20030108-branchpoint:1.11
	carlton_dictionary-20021223-merge:1.11
	gdb_5_3-2002-12-12-release:1.9
	carlton_dictionary-20021115-merge:1.11
	kseitz_interps-20021105-merge:1.9
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.9
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.26
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.24
	carlton_dictionary-20020920-branchpoint:1.9
	gdb_5_3-branch:1.9.0.22
	gdb_5_3-2002-09-04-branchpoint:1.9
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.20
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.18
	readline_4_3-import-branchpoint:1.9
	gdb_5_2_1-2002-07-23-release:1.9
	kseitz_interps-20020528-branch:1.9.0.16
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.14
	cagney_regbuf-20020515-branchpoint:1.9
	jimb-macro-020506-branch:1.9.0.12
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	gdb_5_2-branch:1.9.0.10
	gdb_5_2-2002-03-03-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.9
	gdb_5_1_0_1-2002-01-03-release:1.9
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.8
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.6
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.4
	gdb_5_1-2001-07-29-branchpoint:1.9
	dberlin-typesystem-branch:1.9.0.2
	dberlin-typesystem-branchpoint:1.9
	gdb-post-ptid_t-2001-05-03:1.8
	gdb-pre-ptid_t-2001-05-03:1.7
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.5
	insight-2000-02-04:1.1.1.5
	gdb-2000-02-04:1.1.1.5
	gdb-2000-02-02:1.1.1.5
	gdb-2000-02-01:1.1.1.5
	gdb-2000-01-31:1.1.1.5
	gdb-2000-01-26:1.1.1.5
	gdb-2000-01-24:1.1.1.5
	gdb-2000-01-17:1.1.1.5
	gdb-2000-01-10:1.1.1.5
	gdb-2000-01-05:1.1.1.5
	gdb-1999-12-21:1.1.1.5
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.4
	gdb-1999-10-25:1.1.1.4
	gdb-1999-10-18:1.1.1.4
	gdb-1999-10-11:1.1.1.4
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.24
date	2007.03.29.19.58.29;	author drow;	state dead;
branches;
next	1.23;

1.23
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.21;

1.21
date	2004.08.03.00.57.26;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.22.01.31.49;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.21.17.47.10;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.17.18.24.15;	author cagney;	state Exp;
branches
	1.18.6.1;
next	1.17;

1.17
date	2003.10.02.20.28.29;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.17.15.42.18;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.17.14.24.30;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.08.22.33.14;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.07.04.49.34;	author cagney;	state Exp;
branches
	1.13.16.1;
next	1.12;

1.12
date	2003.02.02.05.46.14;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.14.20.37.28;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.07.02.40.28;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.15.23.50.46;	author cagney;	state Exp;
branches
	1.9.24.1
	1.9.26.1;
next	1.8;

1.8
date	2001.05.04.04.15.25;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.06.08.21.09;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.28.01.12.28;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.09.13.29.52;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.17.21.57;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.07.36;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.10.05.23.08.26;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.12.22.21.45.07;	author jsm;	state Exp;
branches;
next	;

1.9.24.1
date	2002.11.15.19.18.50;	author carlton;	state Exp;
branches;
next	1.9.24.2;

1.9.24.2
date	2003.02.07.19.17.50;	author carlton;	state Exp;
branches;
next	1.9.24.3;

1.9.24.3
date	2003.05.23.18.40.41;	author carlton;	state Exp;
branches;
next	1.9.24.4;

1.9.24.4
date	2003.09.17.21.28.24;	author carlton;	state Exp;
branches;
next	1.9.24.5;

1.9.24.5
date	2003.11.11.23.50.48;	author carlton;	state Exp;
branches;
next	1.9.24.6;

1.9.24.6
date	2004.01.26.19.11.27;	author carlton;	state Exp;
branches;
next	;

1.9.26.1
date	2003.12.14.20.27.20;	author drow;	state Exp;
branches;
next	1.9.26.2;

1.9.26.2
date	2004.02.09.19.43.43;	author drow;	state Exp;
branches;
next	;

1.13.16.1
date	2003.05.18.09.44.15;	author kettenis;	state Exp;
branches;
next	;

1.18.6.1
date	2004.09.16.17.01.12;	author drow;	state Exp;
branches;
next	;


desc
@@


1.24
log
@	* Makefile.in (coff_solib_h, coff-solib.o, i386v-nat.o, lynx-nat.o)
	(remote-st.o, uw-thread.o): Delete.
	(HFILES_NO_SRCDIR, ALLDEPFILES): Update.
	* configure.host: Move hppa*-*-hiux*, i[34567]86-ncr-*,
	i[34567]86-*-dgux*, i[34567]86-*-lynxos*, i[34567]86-*-sco3.2v5*,
	i[34567]86-*-sco3.2v4*, i[34567]86-*-sco*, i[34567]86-*-sysv4.2*,
	i[34567]86-*-sysv4*, i[34567]86-*-sysv5*, i[34567]86-*-unixware2*,
	i[34567]86-*-unixware*, i[34567]86-*-sysv*, i[34567]86-*-isc*, and
	rs6000-*-lynxos* to an obsoletion stanza.
	* configure.tgt: Move hppa*-*-hiux*, i[34567]86-ncr-*,
	i[34567]86-*-lynxos*, m68*-cisco*-*, m68*-tandem-*, m68*-*-os68k*,
	and rs6000-*-lynxos* to an obsoletion stanza.  Do not mention
	i[34567]86-*-netware*.
	* NEWS: Mention deleted targets.

	* coff-solib.c, coff-solib.h, i386v-nat.c, lynx-nat.c, remote-st.c,
	uw-thread.c, config/nm-lynx.h, config/i386/i386sco.mh,
	config/i386/i386sco4.mh, config/i386/i386sco5.mh, config/i386/i386v.mh,
	config/i386/i386v4.mh, config/i386/i386v42mp.mh,
	config/i386/ncr3000.mh, config/i386/ncr3000.mt,
	config/i386/nm-i386sco.h, config/i386/nm-i386sco4.h,
	config/i386/nm-i386sco5.h, config/i386/nm-i386v.h,
	config/i386/nm-i386v4.h, config/i386/nm-i386v42mp.h,
	config/m68k/cisco.mt, config/m68k/os68k.mt, config/m68k/st2000.mt,
	config/m68k/tm-cisco.h, config/m68k/tm-os68k.h,
	config/rs6000/rs6000lynx.mh, config/rs6000/rs6000lynx.mt,
	config/rs6000/tm-rs6000ly.h: Delete files.
@
text
@/* Native-dependent code for LynxOS.

   Copyright (C) 1993, 1994, 1995, 1996, 1999, 2000, 2001, 2003, 2007
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "target.h"
#include "gdbcore.h"
#include "regcache.h"

#include <sys/ptrace.h>
#Include "gdb_wait.h"
#include <sys/fpp.h>

static unsigned long registers_addr (int pid);
static void fetch_core_registers (char *, unsigned, int, CORE_ADDR);

#define X(ENTRY)(offsetof(struct econtext, ENTRY))

#ifdef I386
/* Mappings from tm-i386v.h */

static int regmap[] =
{
  X (eax),
  X (ecx),
  X (edx),
  X (ebx),
  X (esp),			/* sp */
  X (ebp),			/* fp */
  X (esi),
  X (edi),
  X (eip),			/* pc */
  X (flags),			/* ps */
  X (cs),
  X (ss),
  X (ds),
  X (es),
  X (ecode),			/* Lynx doesn't give us either fs or gs, so */
  X (fault),			/* we just substitute these two in the hopes
				   that they are useful. */
};
#endif /* I386 */

#ifdef M68K
/* Mappings from tm-m68k.h */

static int regmap[] =
{
  X (regs[0]),			/* d0 */
  X (regs[1]),			/* d1 */
  X (regs[2]),			/* d2 */
  X (regs[3]),			/* d3 */
  X (regs[4]),			/* d4 */
  X (regs[5]),			/* d5 */
  X (regs[6]),			/* d6 */
  X (regs[7]),			/* d7 */
  X (regs[8]),			/* a0 */
  X (regs[9]),			/* a1 */
  X (regs[10]),			/* a2 */
  X (regs[11]),			/* a3 */
  X (regs[12]),			/* a4 */
  X (regs[13]),			/* a5 */
  X (regs[14]),			/* fp */
  offsetof (st_t, usp) - offsetof (st_t, ec),	/* sp */
  X (status),			/* ps */
  X (pc),

  X (fregs[0 * 3]),		/* fp0 */
  X (fregs[1 * 3]),		/* fp1 */
  X (fregs[2 * 3]),		/* fp2 */
  X (fregs[3 * 3]),		/* fp3 */
  X (fregs[4 * 3]),		/* fp4 */
  X (fregs[5 * 3]),		/* fp5 */
  X (fregs[6 * 3]),		/* fp6 */
  X (fregs[7 * 3]),		/* fp7 */

  X (fcregs[0]),		/* fpcontrol */
  X (fcregs[1]),		/* fpstatus */
  X (fcregs[2]),		/* fpiaddr */
  X (ssw),			/* fpcode */
  X (fault),			/* fpflags */
};
#endif /* M68K */

#ifdef SPARC
/* Mappings from tm-sparc.h */

#define FX(ENTRY)(offsetof(struct fcontext, ENTRY))

static int regmap[] =
{
  -1,				/* g0 */
  X (g1),
  X (g2),
  X (g3),
  X (g4),
  -1,				/* g5->g7 aren't saved by Lynx */
  -1,
  -1,

  X (o[0]),
  X (o[1]),
  X (o[2]),
  X (o[3]),
  X (o[4]),
  X (o[5]),
  X (o[6]),			/* sp */
  X (o[7]),			/* ra */

  -1, -1, -1, -1, -1, -1, -1, -1,	/* l0 -> l7 */

  -1, -1, -1, -1, -1, -1, -1, -1,	/* i0 -> i7 */

  FX (f.fregs[0]),		/* f0 */
  FX (f.fregs[1]),
  FX (f.fregs[2]),
  FX (f.fregs[3]),
  FX (f.fregs[4]),
  FX (f.fregs[5]),
  FX (f.fregs[6]),
  FX (f.fregs[7]),
  FX (f.fregs[8]),
  FX (f.fregs[9]),
  FX (f.fregs[10]),
  FX (f.fregs[11]),
  FX (f.fregs[12]),
  FX (f.fregs[13]),
  FX (f.fregs[14]),
  FX (f.fregs[15]),
  FX (f.fregs[16]),
  FX (f.fregs[17]),
  FX (f.fregs[18]),
  FX (f.fregs[19]),
  FX (f.fregs[20]),
  FX (f.fregs[21]),
  FX (f.fregs[22]),
  FX (f.fregs[23]),
  FX (f.fregs[24]),
  FX (f.fregs[25]),
  FX (f.fregs[26]),
  FX (f.fregs[27]),
  FX (f.fregs[28]),
  FX (f.fregs[29]),
  FX (f.fregs[30]),
  FX (f.fregs[31]),

  X (y),
  X (psr),
  X (wim),
  X (tbr),
  X (pc),
  X (npc),
  FX (fsr),			/* fpsr */
  -1,				/* cpsr */
};
#endif /* SPARC */

#ifdef rs6000

static int regmap[] =
{
  X (iregs[0]),			/* r0 */
  X (iregs[1]),
  X (iregs[2]),
  X (iregs[3]),
  X (iregs[4]),
  X (iregs[5]),
  X (iregs[6]),
  X (iregs[7]),
  X (iregs[8]),
  X (iregs[9]),
  X (iregs[10]),
  X (iregs[11]),
  X (iregs[12]),
  X (iregs[13]),
  X (iregs[14]),
  X (iregs[15]),
  X (iregs[16]),
  X (iregs[17]),
  X (iregs[18]),
  X (iregs[19]),
  X (iregs[20]),
  X (iregs[21]),
  X (iregs[22]),
  X (iregs[23]),
  X (iregs[24]),
  X (iregs[25]),
  X (iregs[26]),
  X (iregs[27]),
  X (iregs[28]),
  X (iregs[29]),
  X (iregs[30]),
  X (iregs[31]),

  X (fregs[0]),			/* f0 */
  X (fregs[1]),
  X (fregs[2]),
  X (fregs[3]),
  X (fregs[4]),
  X (fregs[5]),
  X (fregs[6]),
  X (fregs[7]),
  X (fregs[8]),
  X (fregs[9]),
  X (fregs[10]),
  X (fregs[11]),
  X (fregs[12]),
  X (fregs[13]),
  X (fregs[14]),
  X (fregs[15]),
  X (fregs[16]),
  X (fregs[17]),
  X (fregs[18]),
  X (fregs[19]),
  X (fregs[20]),
  X (fregs[21]),
  X (fregs[22]),
  X (fregs[23]),
  X (fregs[24]),
  X (fregs[25]),
  X (fregs[26]),
  X (fregs[27]),
  X (fregs[28]),
  X (fregs[29]),
  X (fregs[30]),
  X (fregs[31]),

  X (srr0),			/* IAR (PC) */
  X (srr1),			/* MSR (PS) */
  X (cr),			/* CR */
  X (lr),			/* LR */
  X (ctr),			/* CTR */
  X (xer),			/* XER */
  X (mq)			/* MQ */
};

#endif /* rs6000 */

#if defined (I386) || defined (M68K) || defined (rs6000)

/* Return the offset relative to the start of the per-thread data to the
   saved context block.  */

static unsigned long
registers_addr (int pid)
{
  CORE_ADDR stblock;
  int ecpoff = offsetof (st_t, ecp);
  CORE_ADDR ecp;

  errno = 0;
  stblock = (CORE_ADDR) ptrace (PTRACE_THREADUSER, pid, (PTRACE_ARG3_TYPE) 0,
				0);
  if (errno)
    perror_with_name ("ptrace(PTRACE_THREADUSER)");

  ecp = (CORE_ADDR) ptrace (PTRACE_PEEKTHREAD, pid, (PTRACE_ARG3_TYPE) ecpoff,
			    0);
  if (errno)
    perror_with_name ("ptrace(PTRACE_PEEKTHREAD)");

  return ecp - stblock;
}

/* Fetch one or more registers from the inferior.  REGNO == -1 to get
   them all.  We actually fetch more than requested, when convenient,
   marking them as valid so we won't fetch them again.  */

void
fetch_inferior_registers (int regno)
{
  int reglo, reghi;
  int i;
  unsigned long ecp;

  if (regno == -1)
    {
      reglo = 0;
      reghi = NUM_REGS - 1;
    }
  else
    reglo = reghi = regno;

  ecp = registers_addr (PIDGET (inferior_ptid));

  {
    char buf[MAX_REGISTER_SIZE];
    for (regno = reglo; regno <= reghi; regno++)
      {
	int ptrace_fun = PTRACE_PEEKTHREAD;
	
#ifdef M68K
	ptrace_fun = regno == SP_REGNUM ? PTRACE_PEEKUSP : PTRACE_PEEKTHREAD;
#endif
	
	for (i = 0; i < register_size (current_gdbarch, regno); i += sizeof (int))
	  {
	    unsigned int reg;
	    
	    errno = 0;
	    reg = ptrace (ptrace_fun, PIDGET (inferior_ptid),
			  (PTRACE_ARG3_TYPE) (ecp + regmap[regno] + i), 0);
	    if (errno)
	      perror_with_name ("ptrace(PTRACE_PEEKUSP)");
	    
	    *(int *) &buf[i] = reg;
	  }
	regcache_raw_supply (current_regcache, regno, buf);
      }
  }
}

/* Store our register values back into the inferior.
   If REGNO is -1, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time).  */

void
store_inferior_registers (int regno)
{
  int reglo, reghi;
  int i;
  unsigned long ecp;

  if (regno == -1)
    {
      reglo = 0;
      reghi = NUM_REGS - 1;
    }
  else
    reglo = reghi = regno;

  ecp = registers_addr (PIDGET (inferior_ptid));

  for (regno = reglo; regno <= reghi; regno++)
    {
      int ptrace_fun = PTRACE_POKEUSER;

      if (CANNOT_STORE_REGISTER (regno))
	continue;

#ifdef M68K
      ptrace_fun = regno == SP_REGNUM ? PTRACE_POKEUSP : PTRACE_POKEUSER;
#endif

      for (i = 0; i < register_size (current_gdbarch, regno); i += sizeof (int))
	{
	  unsigned int reg;

	  reg = *(unsigned int *) &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno) + i];

	  errno = 0;
	  ptrace (ptrace_fun, PIDGET (inferior_ptid),
		  (PTRACE_ARG3_TYPE) (ecp + regmap[regno] + i), reg);
	  if (errno)
	    perror_with_name ("ptrace(PTRACE_POKEUSP)");
	}
    }
}
#endif /* defined (I386) || defined (M68K) || defined (rs6000) */

/* Wait for child to do something.  Return pid of child, or -1 in case
   of error; store status through argument pointer OURSTATUS.  */

ptid_t
child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  int save_errno;
  int thread;
  union wait status;
  int pid;

  while (1)
    {
      int sig;

      set_sigint_trap ();	/* Causes SIGINT to be passed on to the
				   attached process. */
      pid = wait (&status);

      save_errno = errno;

      clear_sigint_trap ();

      if (pid == -1)
	{
	  if (save_errno == EINTR)
	    continue;
	  fprintf_unfiltered (gdb_stderr, "Child process unexpectedly missing: %s.\n",
			      safe_strerror (save_errno));
	  /* Claim it exited with unknown signal.  */
	  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
	  ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
	  return -1;
	}

      if (pid != PIDGET (inferior_ptid))	/* Some other process?!? */
	continue;

      thread = status.w_tid;	/* Get thread id from status */

      /* Initial thread value can only be acquired via wait, so we have to
         resort to this hack.  */

      if (TIDGET (inferior_ptid) == 0 && thread != 0)
	{
	  inferior_ptid = MERGEPID (PIDGET (inferior_ptid), thread);
	  add_thread (inferior_ptid);
	}

      ptid = BUILDPID (pid, thread);

      /* We've become a single threaded process again.  */
      if (thread == 0)
	inferior_ptid = ptid;

      /* Check for thread creation.  */
      if (WIFSTOPPED (status)
	  && WSTOPSIG (status) == SIGTRAP
	  && !in_thread_list (ptid))
	{
	  int realsig;

	  realsig = ptrace (PTRACE_GETTRACESIG, PIDGET (ptid),
	                    (PTRACE_ARG3_TYPE) 0, 0);

	  if (realsig == SIGNEWTHREAD)
	    {
	      /* It's a new thread notification.  We don't want to much with
	         realsig -- the code in wait_for_inferior expects SIGTRAP. */
	      ourstatus->kind = TARGET_WAITKIND_SPURIOUS;
	      ourstatus->value.sig = TARGET_SIGNAL_0;
	      return ptid;
	    }
	  else
	    error ("Signal for unknown thread was not SIGNEWTHREAD");
	}

      /* Check for thread termination.  */
      else if (WIFSTOPPED (status)
	       && WSTOPSIG (status) == SIGTRAP
	       && in_thread_list (ptid))
	{
	  int realsig;

	  realsig = ptrace (PTRACE_GETTRACESIG, PIDGET (ptid),
	                    (PTRACE_ARG3_TYPE) 0, 0);

	  if (realsig == SIGTHREADEXIT)
	    {
	      ptrace (PTRACE_CONT, PIDGET (ptid), (PTRACE_ARG3_TYPE) 0, 0);
	      continue;
	    }
	}

#ifdef SPARC
      /* SPARC Lynx uses an byte reversed wait status; we must use the
         host macros to access it.  These lines just a copy of
         store_waitstatus.  We can't use CHILD_SPECIAL_WAITSTATUS
         because target.c can't include the Lynx <sys/wait.h>.  */
      if (WIFEXITED (status))
	{
	  ourstatus->kind = TARGET_WAITKIND_EXITED;
	  ourstatus->value.integer = WEXITSTATUS (status);
	}
      else if (!WIFSTOPPED (status))
	{
	  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
	  ourstatus->value.sig =
	    target_signal_from_host (WTERMSIG (status));
	}
      else
	{
	  ourstatus->kind = TARGET_WAITKIND_STOPPED;
	  ourstatus->value.sig =
	    target_signal_from_host (WSTOPSIG (status));
	}
#else
      store_waitstatus (ourstatus, status.w_status);
#endif

      return ptid;
    }
}

/* Return nonzero if the given thread is still alive.  */
int
child_thread_alive (ptid_t ptid)
{
  int pid = PIDGET (ptid);

  /* Arggh.  Apparently pthread_kill only works for threads within
     the process that calls pthread_kill.

     We want to avoid the lynx signal extensions as they simply don't
     map well to the generic gdb interface we want to keep.

     All we want to do is determine if a particular thread is alive;
     it appears as if we can just make a harmless thread specific
     ptrace call to do that.  */
  return (ptrace (PTRACE_THREADUSER, pid, 0, 0) != -1);
}

/* Resume execution of the inferior process.
   If STEP is nonzero, single-step it.
   If SIGNAL is nonzero, give it that signal.  */

void
child_resume (ptid_t ptid, int step, enum target_signal signal)
{
  int func;
  int pid = PIDGET (ptid);

  errno = 0;

  /* If pid == -1, then we want to step/continue all threads, else
     we only want to step/continue a single thread.  */
  if (pid == -1)
    {
      pid = PIDGET (inferior_ptid);
      func = step ? PTRACE_SINGLESTEP : PTRACE_CONT;
    }
  else
    func = step ? PTRACE_SINGLESTEP_ONE : PTRACE_CONT_ONE;


  /* An address of (PTRACE_ARG3_TYPE)1 tells ptrace to continue from where
     it was.  (If GDB wanted it to start some other way, we have already
     written a new PC value to the child.)

     If this system does not support PT_STEP, a higher level function will
     have called single_step() to transmute the step request into a
     continue request (by setting breakpoints on all possible successor
     instructions), so we don't have to worry about that here.  */

  ptrace (func, pid, (PTRACE_ARG3_TYPE) 1, target_signal_to_host (signal));

  if (errno)
    perror_with_name ("ptrace");
}

/* Convert a Lynx process ID to a string.  Returns the string in a static
   buffer.  */

char *
child_pid_to_str (ptid_t ptid)
{
  static char buf[40];

  sprintf (buf, "process %d thread %d", PIDGET (ptid), TIDGET (ptid));

  return buf;
}

/* Extract the register values out of the core file and store
   them where `read_register' will find them.

   CORE_REG_SECT points to the register values themselves, read into memory.
   CORE_REG_SIZE is the size of that area.
   WHICH says which set of registers we are handling (0 = int, 2 = float
   on machines where they are discontiguous).
   REG_ADDR is the offset from u.u_ar0 to the register values relative to
   core_reg_sect.  This is used with old-fashioned core files to
   locate the registers in a large upage-plus-stack ".reg" section.
   Original upage address X is at location core_reg_sect+x+reg_addr.
 */

static void
fetch_core_registers (char *core_reg_sect, unsigned core_reg_size, int which,
		      CORE_ADDR reg_addr)
{
  struct st_entry s;
  unsigned int regno;

  for (regno = 0; regno < NUM_REGS; regno++)
    if (regmap[regno] != -1)
      regcache_raw_supply (current_regcache, regno,
			   core_reg_sect + offsetof (st_t, ec) + regmap[regno]);

#ifdef SPARC
/* Fetching this register causes all of the I & L regs to be read from the
   stack and validated.  */

  fetch_inferior_registers (I0_REGNUM);
#endif
}


/* Register that we are able to handle lynx core file formats.
   FIXME: is this really bfd_target_unknown_flavour? */

static struct core_fns lynx_core_fns =
{
  bfd_target_unknown_flavour,		/* core_flavour */
  default_check_format,			/* check_format */
  default_core_sniffer,			/* core_sniffer */
  fetch_core_registers,			/* core_read_registers */
  NULL					/* next */
};

void
_initialize_core_lynx (void)
{
  deprecated_add_core_fns (&lynx_core_fns);
}
@


1.23
log
@Copyright updates for 2007.
@
text
@@


1.22
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 2
a4 2
   Copyright (C) 1993, 1994, 1995, 1996, 1999, 2000, 2001, 2003 Free
   Software Foundation, Inc.
@


1.21
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d3 1
a3 1
   Copyright 1993, 1994, 1995, 1996, 1999, 2000, 2001, 2003 Free
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.20
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d316 1
a316 1
	for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (int))
d365 1
a365 1
      for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (int))
@


1.19
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* gdbcore.h: Update copyright.
	(deprecated_add_core_fns): Rename add_core_fns.
	* win32-nat.c (_initialize_core_win32): Update.
	* sun3-nat.c (_initialize_core_sun3): Update.
	* shnbsd-tdep.c (_initialize_shnbsd_tdep): Update.
	* rs6000-nat.c (_initialize_core_rs6000): Update.
	* ppcnbsd-tdep.c (_initialize_ppcnbsd_tdep): Update.
	* nto-tdep.c (_initialize_nto_tdep): Update.
	* ns32knbsd-nat.c (_initialize_ns32knbsd_nat): Update.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Update.
	* mips-nat.c (_initialize_core_mips): Update.
	* mips-linux-tdep.c (_initialize_mips_linux_tdep): Update.
	* m68knbsd-nat.c (_initialize_m68knbsd_nat): Update.
	* m68klinux-nat.c (_initialize_m68k_linux_nat): Update.
	* lynx-nat.c (_initialize_core_lynx): Update.
	* irix5-nat.c (_initialize_core_irix5): Update.
	* i386-interix-nat.c (_initialize_core_interix): Update.
	* cris-tdep.c (_initialize_cris_tdep): Update.
	* corelow.c (deprecated_add_core_fns): Update.
	* core-regset.c (_initialize_core_regset): Update.
	* core-aout.c (_initialize_core_aout): Update.
	* armnbsd-nat.c (_initialize_arm_netbsd_nat): Update.
	* alphanbsd-tdep.c (_initialize_alphanbsd_tdep): Update.
	* alpha-nat.c (_initialize_core_alpha): Update.
@
text
@d328 1
a328 1
	supply_register (regno, buf);
d596 2
a597 2
      supply_register (regno, core_reg_sect + offsetof (st_t, ec)
		       + regmap[regno]);
@


1.18
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_NPC_REGNUM): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* procfs.c (procfs_fetch_registers): Delete reference to
	DEPRECATED_NPC_REGNUM.
	(procfs_store_registers): Ditto.
	* regcache.c (generic_target_write_pc): Simplify.
	* lynx-nat.c: Delete #ifdef SPARC code.  Not used.

Index: doc/ChangeLog
2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	documentation on DEPRECATED_NPC_REGNUM.
@
text
@d623 1
a623 1
  add_core_fns (&lynx_core_fns);
@


1.18.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d316 1
a316 1
	for (i = 0; i < register_size (current_gdbarch, regno); i += sizeof (int))
d328 1
a328 1
	regcache_raw_supply (current_regcache, regno, buf);
d365 1
a365 1
      for (i = 0; i < register_size (current_gdbarch, regno); i += sizeof (int))
d596 2
a597 2
      regcache_raw_supply (current_regcache, regno,
			   core_reg_sect + offsetof (st_t, ec) + regmap[regno]);
d623 1
a623 1
  deprecated_add_core_fns (&lynx_core_fns);
@


1.17
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@a258 208
#ifdef SPARC

/* This routine handles some oddball cases for Sparc registers and LynxOS.
   In partucular, it causes refs to G0, g5->7, and all fp regs to return zero.
   It also handles knows where to find the I & L regs on the stack.  */

void
fetch_inferior_registers (int regno)
{
  int whatregs = 0;

#define WHATREGS_FLOAT 1
#define WHATREGS_GEN 2
#define WHATREGS_STACK 4

  if (regno == -1)
    whatregs = WHATREGS_FLOAT | WHATREGS_GEN | WHATREGS_STACK;
  else if (regno >= L0_REGNUM && regno <= I7_REGNUM)
    whatregs = WHATREGS_STACK;
  else if (regno >= FP0_REGNUM && regno < FP0_REGNUM + 32)
    whatregs = WHATREGS_FLOAT;
  else
    whatregs = WHATREGS_GEN;

  if (whatregs & WHATREGS_GEN)
    {
      struct econtext ec;	/* general regs */
      char buf[MAX_REGISTER_SIZE];
      int retval;
      int i;

      errno = 0;
      retval = ptrace (PTRACE_GETREGS, PIDGET (inferior_ptid),
                       (PTRACE_ARG3_TYPE) & ec, 0);
      if (errno)
	perror_with_name ("ptrace(PTRACE_GETREGS)");

      memset (buf, 0, DEPRECATED_REGISTER_RAW_SIZE (G0_REGNUM));
      supply_register (G0_REGNUM, buf);
      supply_register (TBR_REGNUM, (char *) &ec.tbr);

      memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (G1_REGNUM)], &ec.g1,
	      4 * DEPRECATED_REGISTER_RAW_SIZE (G1_REGNUM));
      for (i = G1_REGNUM; i <= G1_REGNUM + 3; i++)
	deprecated_register_valid[i] = 1;

      supply_register (PS_REGNUM, (char *) &ec.psr);
      supply_register (Y_REGNUM, (char *) &ec.y);
      supply_register (PC_REGNUM, (char *) &ec.pc);
      supply_register (DEPRECATED_NPC_REGNUM, (char *) &ec.npc);
      supply_register (WIM_REGNUM, (char *) &ec.wim);

      memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (O0_REGNUM)], ec.o,
	      8 * DEPRECATED_REGISTER_RAW_SIZE (O0_REGNUM));
      for (i = O0_REGNUM; i <= O0_REGNUM + 7; i++)
	deprecated_register_valid[i] = 1;
    }

  if (whatregs & WHATREGS_STACK)
    {
      CORE_ADDR sp;
      int i;

      sp = read_register (SP_REGNUM);

      target_read_memory (sp + FRAME_SAVED_I0,
			  &deprecated_registers[DEPRECATED_REGISTER_BYTE (I0_REGNUM)],
			  8 * DEPRECATED_REGISTER_RAW_SIZE (I0_REGNUM));
      for (i = I0_REGNUM; i <= I7_REGNUM; i++)
	deprecated_register_valid[i] = 1;

      target_read_memory (sp + FRAME_SAVED_L0,
			  &deprecated_registers[DEPRECATED_REGISTER_BYTE (L0_REGNUM)],
			  8 * DEPRECATED_REGISTER_RAW_SIZE (L0_REGNUM));
      for (i = L0_REGNUM; i <= L0_REGNUM + 7; i++)
	deprecated_register_valid[i] = 1;
    }

  if (whatregs & WHATREGS_FLOAT)
    {
      struct fcontext fc;	/* fp regs */
      int retval;
      int i;

      errno = 0;
      retval = ptrace (PTRACE_GETFPREGS, PIDGET (inferior_ptid),
                       (PTRACE_ARG3_TYPE) & fc, 0);
      if (errno)
	perror_with_name ("ptrace(PTRACE_GETFPREGS)");

      memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (FP0_REGNUM)], fc.f.fregs,
	      32 * DEPRECATED_REGISTER_RAW_SIZE (FP0_REGNUM));
      for (i = FP0_REGNUM; i <= FP0_REGNUM + 31; i++)
	deprecated_register_valid[i] = 1;

      supply_register (FPS_REGNUM, (char *) &fc.fsr);
    }
}

/* This routine handles storing of the I & L regs for the Sparc.  The trick
   here is that they actually live on the stack.  The really tricky part is
   that when changing the stack pointer, the I & L regs must be written to
   where the new SP points, otherwise the regs will be incorrect when the
   process is started up again.   We assume that the I & L regs are valid at
   this point.  */

void
store_inferior_registers (int regno)
{
  int whatregs = 0;

  if (regno == -1)
    whatregs = WHATREGS_FLOAT | WHATREGS_GEN | WHATREGS_STACK;
  else if (regno >= L0_REGNUM && regno <= I7_REGNUM)
    whatregs = WHATREGS_STACK;
  else if (regno >= FP0_REGNUM && regno < FP0_REGNUM + 32)
    whatregs = WHATREGS_FLOAT;
  else if (regno == SP_REGNUM)
    whatregs = WHATREGS_STACK | WHATREGS_GEN;
  else
    whatregs = WHATREGS_GEN;

  if (whatregs & WHATREGS_GEN)
    {
      struct econtext ec;	/* general regs */
      int retval;

      ec.tbr = read_register (TBR_REGNUM);
      memcpy (&ec.g1, &deprecated_registers[DEPRECATED_REGISTER_BYTE (G1_REGNUM)],
	      4 * DEPRECATED_REGISTER_RAW_SIZE (G1_REGNUM));

      ec.psr = read_register (PS_REGNUM);
      ec.y = read_register (Y_REGNUM);
      ec.pc = read_register (PC_REGNUM);
      ec.npc = read_register (DEPRECATED_NPC_REGNUM);
      ec.wim = read_register (WIM_REGNUM);

      memcpy (ec.o, &deprecated_registers[DEPRECATED_REGISTER_BYTE (O0_REGNUM)],
	      8 * DEPRECATED_REGISTER_RAW_SIZE (O0_REGNUM));

      errno = 0;
      retval = ptrace (PTRACE_SETREGS, PIDGET (inferior_ptid),
                       (PTRACE_ARG3_TYPE) & ec, 0);
      if (errno)
	perror_with_name ("ptrace(PTRACE_SETREGS)");
    }

  if (whatregs & WHATREGS_STACK)
    {
      int regoffset;
      CORE_ADDR sp;

      sp = read_register (SP_REGNUM);

      if (regno == -1 || regno == SP_REGNUM)
	{
	  if (!deprecated_register_valid[L0_REGNUM + 5])
	    internal_error (__FILE__, __LINE__, "failed internal consistency check");
	  target_write_memory (sp + FRAME_SAVED_I0,
			      &deprecated_registers[DEPRECATED_REGISTER_BYTE (I0_REGNUM)],
			      8 * DEPRECATED_REGISTER_RAW_SIZE (I0_REGNUM));

	  target_write_memory (sp + FRAME_SAVED_L0,
			      &deprecated_registers[DEPRECATED_REGISTER_BYTE (L0_REGNUM)],
			      8 * DEPRECATED_REGISTER_RAW_SIZE (L0_REGNUM));
	}
      else if (regno >= L0_REGNUM && regno <= I7_REGNUM)
	{
	  if (!deprecated_register_valid[regno])
	    internal_error (__FILE__, __LINE__, "failed internal consistency check");
	  if (regno >= L0_REGNUM && regno <= L0_REGNUM + 7)
	    regoffset = DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (L0_REGNUM)
	      + FRAME_SAVED_L0;
	  else
	    regoffset = DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (I0_REGNUM)
	      + FRAME_SAVED_I0;
	  target_write_memory (sp + regoffset, 
			      &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],
			      DEPRECATED_REGISTER_RAW_SIZE (regno));
	}
    }

  if (whatregs & WHATREGS_FLOAT)
    {
      struct fcontext fc;	/* fp regs */
      int retval;

/* We read fcontext first so that we can get good values for fq_t... */
      errno = 0;
      retval = ptrace (PTRACE_GETFPREGS, PIDGET (inferior_ptid),
                       (PTRACE_ARG3_TYPE) & fc, 0);
      if (errno)
	perror_with_name ("ptrace(PTRACE_GETFPREGS)");

      memcpy (fc.f.fregs, &deprecated_registers[DEPRECATED_REGISTER_BYTE (FP0_REGNUM)],
	      32 * DEPRECATED_REGISTER_RAW_SIZE (FP0_REGNUM));

      fc.fsr = read_register (FPS_REGNUM);

      errno = 0;
      retval = ptrace (PTRACE_SETFPREGS, PIDGET (inferior_ptid),
                       (PTRACE_ARG3_TYPE) & fc, 0);
      if (errno)
	perror_with_name ("ptrace(PTRACE_SETFPREGS)");
    }
}
#endif /* SPARC */

@


1.16
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_NPC_REGNUM): Deprecate NPC_REGNUM.
	* gdbarch.h, gdbarch.c: Regenerate.
	* core-sol2.c, hppa-tdep.c, lynx-nat.c, procfs.c: Update.
	* regcache.c, remote-vxsparc.c, sparc-linux-nat.c: Update.
	* sparc-nat.c, sparc-tdep.c, sparc64-tdep.c: Update.
	* sparcnbsd-tdep.c: Update.
@
text
@d296 1
a296 1
      memset (buf, 0, REGISTER_RAW_SIZE (G0_REGNUM));
d301 1
a301 1
	      4 * REGISTER_RAW_SIZE (G1_REGNUM));
d312 1
a312 1
	      8 * REGISTER_RAW_SIZE (O0_REGNUM));
d326 1
a326 1
			  8 * REGISTER_RAW_SIZE (I0_REGNUM));
d332 1
a332 1
			  8 * REGISTER_RAW_SIZE (L0_REGNUM));
d350 1
a350 1
	      32 * REGISTER_RAW_SIZE (FP0_REGNUM));
d388 1
a388 1
	      4 * REGISTER_RAW_SIZE (G1_REGNUM));
d397 1
a397 1
	      8 * REGISTER_RAW_SIZE (O0_REGNUM));
d419 1
a419 1
			      8 * REGISTER_RAW_SIZE (I0_REGNUM));
d423 1
a423 1
			      8 * REGISTER_RAW_SIZE (L0_REGNUM));
d437 1
a437 1
			      REGISTER_RAW_SIZE (regno));
d454 1
a454 1
	      32 * REGISTER_RAW_SIZE (FP0_REGNUM));
d524 1
a524 1
	for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
d573 1
a573 1
      for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
@


1.15
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTE): Rename REGISTER_BYTE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-linux-tdep.c, core-sol2.c, cris-tdep.c: Update.
	* d10v-tdep.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, irix5-nat.c, lynx-nat.c, m68knbsd-nat.c: Update.
	* mcore-tdep.c, mips-linux-tdep.c, mips-tdep.c: Update.
	* mipsv4-nat.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* ns32knbsd-nat.c, ppc-bdm.c, regcache.c, remote-sds.c: Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh64-tdep.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, v850-tdep.c: Update.
	* v850ice.c, vax-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-cisco.h, config/m68k/tm-delta68.h: Update.
	* config/pa/nm-hppah.h: Update.

2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* mi/mi-main.c: Rename REGISTER_BYTE to DEPRECATED_REGISTER_BYTE.
@
text
@d308 1
a308 1
      supply_register (NPC_REGNUM, (char *) &ec.npc);
d393 1
a393 1
      ec.npc = read_register (NPC_REGNUM);
@


1.14
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (max_register_size): Delete declaration.
	* regcache.c (max_register_size): Delete function.
	(struct regcache_descr): Delete field "max_register_size".
	(init_regcache_descr, init_legacy_regcache_descr): Assert that all
	registers fit in MAX_REGISTER_SIZE.
	(regcache_save): Replace max_register_size with MAX_REGISTER_SIZE.
	(regcache_restore, regcache_xfer_part, regcache_dump): Ditto.
	* thread-db.c: Replace max_register_size with MAX_REGISTER_SIZE.
	* sh-tdep.c, rom68k-rom.c, remote-sim.c, remote-mips.c: Ditto.
	* remote-e7000.c, monitor.c, mipsv4-nat.c, mips-nat.c: Ditto.
	* m68klinux-nat.c, lynx-nat.c, irix4-nat.c: Ditto.
	* hpux-thread.c, hppah-nat.c, hppab-nat.c, hppa-tdep.c: Ditto.
	* dve3900-rom.c, hppa-tdep.c: Ditto.
@
text
@d300 1
a300 1
      memcpy (&deprecated_registers[REGISTER_BYTE (G1_REGNUM)], &ec.g1,
d311 1
a311 1
      memcpy (&deprecated_registers[REGISTER_BYTE (O0_REGNUM)], ec.o,
d325 1
a325 1
			  &deprecated_registers[REGISTER_BYTE (I0_REGNUM)],
d331 1
a331 1
			  &deprecated_registers[REGISTER_BYTE (L0_REGNUM)],
d349 1
a349 1
      memcpy (&deprecated_registers[REGISTER_BYTE (FP0_REGNUM)], fc.f.fregs,
d387 1
a387 1
      memcpy (&ec.g1, &deprecated_registers[REGISTER_BYTE (G1_REGNUM)],
d396 1
a396 1
      memcpy (ec.o, &deprecated_registers[REGISTER_BYTE (O0_REGNUM)],
d418 1
a418 1
			      &deprecated_registers[REGISTER_BYTE (I0_REGNUM)],
d422 1
a422 1
			      &deprecated_registers[REGISTER_BYTE (L0_REGNUM)],
d430 1
a430 1
	    regoffset = REGISTER_BYTE (regno) - REGISTER_BYTE (L0_REGNUM)
d433 1
a433 1
	    regoffset = REGISTER_BYTE (regno) - REGISTER_BYTE (I0_REGNUM)
d436 1
a436 1
			      &deprecated_registers[REGISTER_BYTE (regno)],
d453 1
a453 1
      memcpy (fc.f.fregs, &deprecated_registers[REGISTER_BYTE (FP0_REGNUM)],
d577 1
a577 1
	  reg = *(unsigned int *) &deprecated_registers[REGISTER_BYTE (regno) + i];
@


1.13
log
@2003-02-06  Andrew Cagney  <ac131313@@redhat.com>

	* Makefile.in (symm-nat.o): Update dependencies.
	(sparc-nat.o, procfs.o, proc-api.o, ppc-linux-nat.o): Ditto.
	(lynx-nat.o, ia64-linux-nat.): Ditto.
	* symm-nat.c, sparc-nat.c, procfs.c, proc-api.c: Include
	"gdb_wait.h" instead of <wait.h> or <sys/wait.h>.
	* ppc-linux-nat.c, lynx-nat.c, ia64-linux-nat.c: Ditto.
@
text
@d286 1
a286 1
      char *buf = alloca (max_register_size (current_gdbarch));
d515 1
a515 1
    char *buf = alloca (max_register_size (current_gdbarch));
@


1.13.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d286 1
a286 1
      char buf[MAX_REGISTER_SIZE];
d515 1
a515 1
    char buf[MAX_REGISTER_SIZE];
@


1.12
log
@2003-02-02  Andrew Cagney  <ac131313@@redhat.com>

	* mips-nat.c (zerobuf): Delete.
	(fetch_inferior_registers): Alloc local zerobuf.
	(fetch_core_registers): Alloc local zerobuf.
	* d10v-tdep.c (show_regs): Don't allocate a dynamic array using
	MAX_REGISTER_RAW_SIZE or MAX_REGISTER_VIRTUAL_SIZE.
	* thread-db.c (thread_db_store_registers): Ditto.
	* sh-tdep.c (sh_do_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote-sim.c (gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* monitor.c (monitor_supply_register): Ditto.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	* m68klinux-nat.c (fetch_register): Ditto.
	* lynx-nat.c (fetch_inferior_registers): Ditto.
	(fetch_inferior_registers): Ditto.
	* irix4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (fetch_register): Ditto.
	* hppab-nat.c (fetch_register): Ditto.
	* hppa-tdep.c (pa_register_look_aside): Ditto.
	(pa_print_fp_reg, pa_strcat_fp_reg): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register): Ditto.
@
text
@d2 3
a4 2
   Copyright 1993, 1994, 1995, 1996, 1999, 2000, 2001
   Free Software Foundation, Inc.
d31 1
a31 1
#include <sys/wait.h>
@


1.11
log
@2002-11-14  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_registers): Rename registers.
	* a68v-nat.c, alpha-nat.c, arch-utils.c, core-sol2.c: Update.
	* hp300ux-nat.c, hppab-nat.c, hppah-nat.c: Update.
	* hppam3-nat.c, hpux-thread.c, i386gnu-nat.c: Update.
	* ia64-aix-nat.c, ia64-linux-nat.c, ia64-tdep.c: Update.
	* irix4-nat.c, irix5-nat.c, lynx-nat.c, m68k-tdep.c: Update.
	* m68knbsd-nat.c, mips-linux-tdep.c, mipsm3-nat.c: Update.
	* mipsv4-nat.c, ns32knbsd-nat.c, ppc-bdm.c: Update.
	* ppc-sysv-tdep.c, ptx4-nat.c, regcache.c, remote-es.c: Update.
	* remote-sds.c, remote-vx68.c, remote-vxmips.c: Update.
	* remote-vxsparc.c, rs6000-tdep.c, sol-thread.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, symm-nat.c: Update.
	* v850ice.c: Update.
@
text
@d285 1
a285 1
      char buf[MAX_REGISTER_RAW_SIZE];
d513 6
a518 5
  for (regno = reglo; regno <= reghi; regno++)
    {
      char buf[MAX_REGISTER_RAW_SIZE];
      int ptrace_fun = PTRACE_PEEKTHREAD;

d520 1
a520 1
      ptrace_fun = regno == SP_REGNUM ? PTRACE_PEEKUSP : PTRACE_PEEKTHREAD;
d522 16
a537 15

      for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
	{
	  unsigned int reg;

	  errno = 0;
	  reg = ptrace (ptrace_fun, PIDGET (inferior_ptid),
			(PTRACE_ARG3_TYPE) (ecp + regmap[regno] + i), 0);
	  if (errno)
	    perror_with_name ("ptrace(PTRACE_PEEKUSP)");

	  *(int *) &buf[i] = reg;
	}
      supply_register (regno, buf);
    }
@


1.10
log
@2002-11-06  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_register_valid): Rename register_valid.
	* regcache.c: Update.
	* ia64-aix-nat.c: Update.
	* i386gnu-nat.c: Update.
	* alpha-nat.c: Update.
	* sparc-nat.c: Update.
	* lynx-nat.c: Update.
	* remote-mips.c: Update.
@
text
@d299 1
a299 1
      memcpy (&registers[REGISTER_BYTE (G1_REGNUM)], &ec.g1,
d310 1
a310 1
      memcpy (&registers[REGISTER_BYTE (O0_REGNUM)], ec.o,
d324 1
a324 1
			  &registers[REGISTER_BYTE (I0_REGNUM)],
d330 1
a330 1
			  &registers[REGISTER_BYTE (L0_REGNUM)],
d348 1
a348 1
      memcpy (&registers[REGISTER_BYTE (FP0_REGNUM)], fc.f.fregs,
d386 1
a386 1
      memcpy (&ec.g1, &registers[REGISTER_BYTE (G1_REGNUM)],
d395 1
a395 1
      memcpy (ec.o, &registers[REGISTER_BYTE (O0_REGNUM)],
d417 1
a417 1
			      &registers[REGISTER_BYTE (I0_REGNUM)],
d421 1
a421 1
			      &registers[REGISTER_BYTE (L0_REGNUM)],
d435 1
a435 1
			      &registers[REGISTER_BYTE (regno)],
d452 1
a452 1
      memcpy (fc.f.fregs, &registers[REGISTER_BYTE (FP0_REGNUM)],
d574 1
a574 1
	  reg = *(unsigned int *) &registers[REGISTER_BYTE (regno) + i];
@


1.9
log
@Multi-arch CANNOT_FETCH_REGISTER() and CANNOT_STORE_REGISTER().
@
text
@d302 1
a302 1
	register_valid[i] = 1;
d313 1
a313 1
	register_valid[i] = 1;
d327 1
a327 1
	register_valid[i] = 1;
d333 1
a333 1
	register_valid[i] = 1;
d351 1
a351 1
	register_valid[i] = 1;
d414 1
a414 1
	  if (!register_valid[L0_REGNUM + 5])
d426 1
a426 1
	  if (!register_valid[regno])
@


1.9.26.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 2
a3 3

   Copyright 1993, 1994, 1995, 1996, 1999, 2000, 2001, 2003 Free
   Software Foundation, Inc.
d30 1
a30 1
#Include "gdb_wait.h"
d285 1
a285 1
      char buf[MAX_REGISTER_SIZE];
d295 1
a295 1
      memset (buf, 0, DEPRECATED_REGISTER_RAW_SIZE (G0_REGNUM));
d299 2
a300 2
      memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (G1_REGNUM)], &ec.g1,
	      4 * DEPRECATED_REGISTER_RAW_SIZE (G1_REGNUM));
d302 1
a302 1
	deprecated_register_valid[i] = 1;
d307 1
a307 1
      supply_register (DEPRECATED_NPC_REGNUM, (char *) &ec.npc);
d310 2
a311 2
      memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (O0_REGNUM)], ec.o,
	      8 * DEPRECATED_REGISTER_RAW_SIZE (O0_REGNUM));
d313 1
a313 1
	deprecated_register_valid[i] = 1;
d324 2
a325 2
			  &deprecated_registers[DEPRECATED_REGISTER_BYTE (I0_REGNUM)],
			  8 * DEPRECATED_REGISTER_RAW_SIZE (I0_REGNUM));
d327 1
a327 1
	deprecated_register_valid[i] = 1;
d330 2
a331 2
			  &deprecated_registers[DEPRECATED_REGISTER_BYTE (L0_REGNUM)],
			  8 * DEPRECATED_REGISTER_RAW_SIZE (L0_REGNUM));
d333 1
a333 1
	deprecated_register_valid[i] = 1;
d348 2
a349 2
      memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (FP0_REGNUM)], fc.f.fregs,
	      32 * DEPRECATED_REGISTER_RAW_SIZE (FP0_REGNUM));
d351 1
a351 1
	deprecated_register_valid[i] = 1;
d386 2
a387 2
      memcpy (&ec.g1, &deprecated_registers[DEPRECATED_REGISTER_BYTE (G1_REGNUM)],
	      4 * DEPRECATED_REGISTER_RAW_SIZE (G1_REGNUM));
d392 1
a392 1
      ec.npc = read_register (DEPRECATED_NPC_REGNUM);
d395 2
a396 2
      memcpy (ec.o, &deprecated_registers[DEPRECATED_REGISTER_BYTE (O0_REGNUM)],
	      8 * DEPRECATED_REGISTER_RAW_SIZE (O0_REGNUM));
d414 1
a414 1
	  if (!deprecated_register_valid[L0_REGNUM + 5])
d417 2
a418 2
			      &deprecated_registers[DEPRECATED_REGISTER_BYTE (I0_REGNUM)],
			      8 * DEPRECATED_REGISTER_RAW_SIZE (I0_REGNUM));
d421 2
a422 2
			      &deprecated_registers[DEPRECATED_REGISTER_BYTE (L0_REGNUM)],
			      8 * DEPRECATED_REGISTER_RAW_SIZE (L0_REGNUM));
d426 1
a426 1
	  if (!deprecated_register_valid[regno])
d429 1
a429 1
	    regoffset = DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (L0_REGNUM)
d432 1
a432 1
	    regoffset = DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (I0_REGNUM)
d435 2
a436 2
			      &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],
			      DEPRECATED_REGISTER_RAW_SIZE (regno));
d452 2
a453 2
      memcpy (fc.f.fregs, &deprecated_registers[DEPRECATED_REGISTER_BYTE (FP0_REGNUM)],
	      32 * DEPRECATED_REGISTER_RAW_SIZE (FP0_REGNUM));
d513 5
a517 6
  {
    char buf[MAX_REGISTER_SIZE];
    for (regno = reglo; regno <= reghi; regno++)
      {
	int ptrace_fun = PTRACE_PEEKTHREAD;
	
d519 1
a519 1
	ptrace_fun = regno == SP_REGNUM ? PTRACE_PEEKUSP : PTRACE_PEEKTHREAD;
d521 15
a535 16
	
	for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (int))
	  {
	    unsigned int reg;
	    
	    errno = 0;
	    reg = ptrace (ptrace_fun, PIDGET (inferior_ptid),
			  (PTRACE_ARG3_TYPE) (ecp + regmap[regno] + i), 0);
	    if (errno)
	      perror_with_name ("ptrace(PTRACE_PEEKUSP)");
	    
	    *(int *) &buf[i] = reg;
	  }
	supply_register (regno, buf);
      }
  }
d570 1
a570 1
      for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (int))
d574 1
a574 1
	  reg = *(unsigned int *) &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno) + i];
@


1.9.26.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d259 208
@


1.9.24.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d299 1
a299 1
      memcpy (&deprecated_registers[REGISTER_BYTE (G1_REGNUM)], &ec.g1,
d302 1
a302 1
	deprecated_register_valid[i] = 1;
d310 1
a310 1
      memcpy (&deprecated_registers[REGISTER_BYTE (O0_REGNUM)], ec.o,
d313 1
a313 1
	deprecated_register_valid[i] = 1;
d324 1
a324 1
			  &deprecated_registers[REGISTER_BYTE (I0_REGNUM)],
d327 1
a327 1
	deprecated_register_valid[i] = 1;
d330 1
a330 1
			  &deprecated_registers[REGISTER_BYTE (L0_REGNUM)],
d333 1
a333 1
	deprecated_register_valid[i] = 1;
d348 1
a348 1
      memcpy (&deprecated_registers[REGISTER_BYTE (FP0_REGNUM)], fc.f.fregs,
d351 1
a351 1
	deprecated_register_valid[i] = 1;
d386 1
a386 1
      memcpy (&ec.g1, &deprecated_registers[REGISTER_BYTE (G1_REGNUM)],
d395 1
a395 1
      memcpy (ec.o, &deprecated_registers[REGISTER_BYTE (O0_REGNUM)],
d414 1
a414 1
	  if (!deprecated_register_valid[L0_REGNUM + 5])
d417 1
a417 1
			      &deprecated_registers[REGISTER_BYTE (I0_REGNUM)],
d421 1
a421 1
			      &deprecated_registers[REGISTER_BYTE (L0_REGNUM)],
d426 1
a426 1
	  if (!deprecated_register_valid[regno])
d435 1
a435 1
			      &deprecated_registers[REGISTER_BYTE (regno)],
d452 1
a452 1
      memcpy (fc.f.fregs, &deprecated_registers[REGISTER_BYTE (FP0_REGNUM)],
d574 1
a574 1
	  reg = *(unsigned int *) &deprecated_registers[REGISTER_BYTE (regno) + i];
@


1.9.24.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 2
a3 3

   Copyright 1993, 1994, 1995, 1996, 1999, 2000, 2001, 2003 Free
   Software Foundation, Inc.
d30 1
a30 1
#Include "gdb_wait.h"
d285 1
a285 1
      char *buf = alloca (max_register_size (current_gdbarch));
d513 5
a517 6
  {
    char *buf = alloca (max_register_size (current_gdbarch));
    for (regno = reglo; regno <= reghi; regno++)
      {
	int ptrace_fun = PTRACE_PEEKTHREAD;
	
d519 1
a519 1
	ptrace_fun = regno == SP_REGNUM ? PTRACE_PEEKUSP : PTRACE_PEEKTHREAD;
d521 15
a535 16
	
	for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
	  {
	    unsigned int reg;
	    
	    errno = 0;
	    reg = ptrace (ptrace_fun, PIDGET (inferior_ptid),
			  (PTRACE_ARG3_TYPE) (ecp + regmap[regno] + i), 0);
	    if (errno)
	      perror_with_name ("ptrace(PTRACE_PEEKUSP)");
	    
	    *(int *) &buf[i] = reg;
	  }
	supply_register (regno, buf);
      }
  }
@


1.9.24.3
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d286 1
a286 1
      char buf[MAX_REGISTER_SIZE];
d515 1
a515 1
    char buf[MAX_REGISTER_SIZE];
@


1.9.24.4
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d300 1
a300 1
      memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (G1_REGNUM)], &ec.g1,
d308 1
a308 1
      supply_register (DEPRECATED_NPC_REGNUM, (char *) &ec.npc);
d311 1
a311 1
      memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (O0_REGNUM)], ec.o,
d325 1
a325 1
			  &deprecated_registers[DEPRECATED_REGISTER_BYTE (I0_REGNUM)],
d331 1
a331 1
			  &deprecated_registers[DEPRECATED_REGISTER_BYTE (L0_REGNUM)],
d349 1
a349 1
      memcpy (&deprecated_registers[DEPRECATED_REGISTER_BYTE (FP0_REGNUM)], fc.f.fregs,
d387 1
a387 1
      memcpy (&ec.g1, &deprecated_registers[DEPRECATED_REGISTER_BYTE (G1_REGNUM)],
d393 1
a393 1
      ec.npc = read_register (DEPRECATED_NPC_REGNUM);
d396 1
a396 1
      memcpy (ec.o, &deprecated_registers[DEPRECATED_REGISTER_BYTE (O0_REGNUM)],
d418 1
a418 1
			      &deprecated_registers[DEPRECATED_REGISTER_BYTE (I0_REGNUM)],
d422 1
a422 1
			      &deprecated_registers[DEPRECATED_REGISTER_BYTE (L0_REGNUM)],
d430 1
a430 1
	    regoffset = DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (L0_REGNUM)
d433 1
a433 1
	    regoffset = DEPRECATED_REGISTER_BYTE (regno) - DEPRECATED_REGISTER_BYTE (I0_REGNUM)
d436 1
a436 1
			      &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno)],
d453 1
a453 1
      memcpy (fc.f.fregs, &deprecated_registers[DEPRECATED_REGISTER_BYTE (FP0_REGNUM)],
d577 1
a577 1
	  reg = *(unsigned int *) &deprecated_registers[DEPRECATED_REGISTER_BYTE (regno) + i];
@


1.9.24.5
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d296 1
a296 1
      memset (buf, 0, DEPRECATED_REGISTER_RAW_SIZE (G0_REGNUM));
d301 1
a301 1
	      4 * DEPRECATED_REGISTER_RAW_SIZE (G1_REGNUM));
d312 1
a312 1
	      8 * DEPRECATED_REGISTER_RAW_SIZE (O0_REGNUM));
d326 1
a326 1
			  8 * DEPRECATED_REGISTER_RAW_SIZE (I0_REGNUM));
d332 1
a332 1
			  8 * DEPRECATED_REGISTER_RAW_SIZE (L0_REGNUM));
d350 1
a350 1
	      32 * DEPRECATED_REGISTER_RAW_SIZE (FP0_REGNUM));
d388 1
a388 1
	      4 * DEPRECATED_REGISTER_RAW_SIZE (G1_REGNUM));
d397 1
a397 1
	      8 * DEPRECATED_REGISTER_RAW_SIZE (O0_REGNUM));
d419 1
a419 1
			      8 * DEPRECATED_REGISTER_RAW_SIZE (I0_REGNUM));
d423 1
a423 1
			      8 * DEPRECATED_REGISTER_RAW_SIZE (L0_REGNUM));
d437 1
a437 1
			      DEPRECATED_REGISTER_RAW_SIZE (regno));
d454 1
a454 1
	      32 * DEPRECATED_REGISTER_RAW_SIZE (FP0_REGNUM));
d524 1
a524 1
	for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (int))
d573 1
a573 1
      for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (int))
@


1.9.24.6
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d259 208
@


1.8
log
@Phase 1 of the ptid_t changes.
@
text
@a541 5
/* Registers we shouldn't try to store.  */
#if !defined (CANNOT_STORE_REGISTER)
#define CANNOT_STORE_REGISTER(regno) 0
#endif

@


1.7
log
@Update/correct copyright notices.
@
text
@d290 2
a291 2
      retval = ptrace (PTRACE_GETREGS, inferior_pid, (PTRACE_ARG3_TYPE) & ec,
		       0);
d343 2
a344 2
      retval = ptrace (PTRACE_GETFPREGS, inferior_pid, (PTRACE_ARG3_TYPE) & fc,
		       0);
d399 2
a400 2
      retval = ptrace (PTRACE_SETREGS, inferior_pid, (PTRACE_ARG3_TYPE) & ec,
		       0);
d447 2
a448 2
      retval = ptrace (PTRACE_GETFPREGS, inferior_pid, (PTRACE_ARG3_TYPE) & fc,
		       0);
d458 2
a459 2
      retval = ptrace (PTRACE_SETFPREGS, inferior_pid, (PTRACE_ARG3_TYPE) & fc,
		       0);
d511 1
a511 1
  ecp = registers_addr (inferior_pid);
d527 1
a527 1
	  reg = ptrace (ptrace_fun, inferior_pid,
d562 1
a562 1
  ecp = registers_addr (inferior_pid);
d582 1
a582 1
	  ptrace (ptrace_fun, inferior_pid,
d594 2
a595 2
int
child_wait (int pid, struct target_waitstatus *ourstatus)
d600 1
d626 1
a626 1
      if (pid != PIDGET (inferior_pid))		/* Some other process?!? */
d634 1
a634 1
      if (TIDGET (inferior_pid) == 0 && thread != 0)
d636 2
a637 2
	  inferior_pid = BUILDPID (inferior_pid, thread);
	  add_thread (inferior_pid);
d640 1
a640 1
      pid = BUILDPID (pid, thread);
d644 1
a644 1
	inferior_pid = pid;
d649 1
a649 1
	  && !in_thread_list (pid))
d653 2
a654 1
	  realsig = ptrace (PTRACE_GETTRACESIG, pid, (PTRACE_ARG3_TYPE) 0, 0);
d662 1
a662 1
	      return pid;
d671 1
a671 1
	       && in_thread_list (pid))
d675 2
a676 1
	  realsig = ptrace (PTRACE_GETTRACESIG, pid, (PTRACE_ARG3_TYPE) 0, 0);
d680 1
a680 1
	      ptrace (PTRACE_CONT, PIDGET (pid), (PTRACE_ARG3_TYPE) 0, 0);
d711 1
a711 1
      return pid;
d717 1
a717 1
child_thread_alive (int pid)
d719 2
d738 1
a738 1
child_resume (int pid, int step, enum target_signal signal)
d741 1
d749 1
a749 1
      pid = inferior_pid;
d775 1
a775 1
child_pid_to_str (int pid)
d779 1
a779 1
  sprintf (buf, "process %d thread %d", PIDGET (pid), TIDGET (pid));
@


1.6
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1993, 1994, 2001 Free Software Foundation, Inc.
@


1.5
log
@Replace calls to abort() with calls to internal_error().
@
text
@d2 1
a2 1
   Copyright 1993, 1994 Free Software Foundation, Inc.
d26 1
@


1.4
log
@Protoization.
@
text
@d413 1
a413 1
	    abort ();
d425 1
a425 1
	    abort ();
@


1.3
log
@PARAMS removal.
@
text
@d263 1
a263 2
fetch_inferior_registers (regno)
     int regno;
d363 1
a363 2
store_inferior_registers (regno)
     int regno;
d470 1
a470 2
registers_addr (pid)
     int pid;
d495 1
a495 2
fetch_inferior_registers (regno)
     int regno;
d546 1
a546 2
store_inferior_registers (regno)
     int regno;
d593 1
a593 3
child_wait (pid, ourstatus)
     int pid;
     struct target_waitstatus *ourstatus;
d712 1
a712 2
child_thread_alive (pid)
     int pid;
d731 1
a731 4
child_resume (pid, step, signal)
     int pid;
     int step;
     enum target_signal signal;
d767 1
a767 2
child_pid_to_str (pid)
     int pid;
d790 2
a791 5
fetch_core_registers (core_reg_sect, core_reg_size, which, reg_addr)
     char *core_reg_sect;
     unsigned core_reg_size;
     int which;
     CORE_ADDR reg_addr;
d823 1
a823 1
_initialize_core_lynx ()
@


1.2
log
@2000-04-07 J.T. Conklin <jtc@@redback.com>: lynx-nat.c
(fetch_inferior_registers, store_inferior_registers): replace calls to
target_xfer_memory() with target_read_memory() and
target_write_memory().
@
text
@d31 2
a32 2
static unsigned long registers_addr PARAMS ((int pid));
static void fetch_core_registers PARAMS ((char *, unsigned, int, CORE_ADDR));
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d32 1
a32 1
static void fetch_core_registers PARAMS ((char *, unsigned, int, CORE_ADDR);
d41 16
a56 16
  X(eax),
  X(ecx),
  X(edx),
  X(ebx),
  X(esp),			/* sp */
  X(ebp),			/* fp */
  X(esi),
  X(edi),
  X(eip),			/* pc */
  X(flags),			/* ps */
  X(cs),
  X(ss),
  X(ds),
  X(es),
  X(ecode),			/* Lynx doesn't give us either fs or gs, so */
  X(fault),			/* we just substitute these two in the hopes
d66 33
a98 33
  X(regs[0]),			/* d0 */
  X(regs[1]),			/* d1 */
  X(regs[2]),			/* d2 */
  X(regs[3]),			/* d3 */
  X(regs[4]),			/* d4 */
  X(regs[5]),			/* d5 */
  X(regs[6]),			/* d6 */
  X(regs[7]),			/* d7 */
  X(regs[8]),			/* a0 */
  X(regs[9]),			/* a1 */
  X(regs[10]),			/* a2 */
  X(regs[11]),			/* a3 */
  X(regs[12]),			/* a4 */
  X(regs[13]),			/* a5 */
  X(regs[14]),			/* fp */
  offsetof (st_t, usp) - offsetof (st_t, ec), /* sp */
  X(status),			/* ps */
  X(pc),

  X(fregs[0*3]),		/* fp0 */
  X(fregs[1*3]),		/* fp1 */
  X(fregs[2*3]),		/* fp2 */
  X(fregs[3*3]),		/* fp3 */
  X(fregs[4*3]),		/* fp4 */
  X(fregs[5*3]),		/* fp5 */
  X(fregs[6*3]),		/* fp6 */
  X(fregs[7*3]),		/* fp7 */

  X(fcregs[0]),			/* fpcontrol */
  X(fcregs[1]),			/* fpstatus */
  X(fcregs[2]),			/* fpiaddr */
  X(ssw),			/* fpcode */
  X(fault),			/* fpflags */
d110 4
a113 4
  X(g1),
  X(g2),
  X(g3),
  X(g4),
d118 53
a170 53
  X(o[0]),
  X(o[1]),
  X(o[2]),
  X(o[3]),
  X(o[4]),
  X(o[5]),
  X(o[6]),			/* sp */
  X(o[7]),			/* ra */

  -1,-1,-1,-1,-1,-1,-1,-1,	/* l0 -> l7 */

  -1,-1,-1,-1,-1,-1,-1,-1,	/* i0 -> i7 */

  FX(f.fregs[0]),		/* f0 */
  FX(f.fregs[1]),
  FX(f.fregs[2]),
  FX(f.fregs[3]),
  FX(f.fregs[4]),
  FX(f.fregs[5]),
  FX(f.fregs[6]),
  FX(f.fregs[7]),
  FX(f.fregs[8]),
  FX(f.fregs[9]),
  FX(f.fregs[10]),
  FX(f.fregs[11]),
  FX(f.fregs[12]),
  FX(f.fregs[13]),
  FX(f.fregs[14]),
  FX(f.fregs[15]),
  FX(f.fregs[16]),
  FX(f.fregs[17]),
  FX(f.fregs[18]),
  FX(f.fregs[19]),
  FX(f.fregs[20]),
  FX(f.fregs[21]),
  FX(f.fregs[22]),
  FX(f.fregs[23]),
  FX(f.fregs[24]),
  FX(f.fregs[25]),
  FX(f.fregs[26]),
  FX(f.fregs[27]),
  FX(f.fregs[28]),
  FX(f.fregs[29]),
  FX(f.fregs[30]),
  FX(f.fregs[31]),

  X(y),
  X(psr),
  X(wim),
  X(tbr),
  X(pc),
  X(npc),
  FX(fsr),			/* fpsr */
d179 73
a251 73
  X(iregs[0]),			/* r0 */
  X(iregs[1]),
  X(iregs[2]),
  X(iregs[3]),
  X(iregs[4]),
  X(iregs[5]),
  X(iregs[6]),
  X(iregs[7]),
  X(iregs[8]),
  X(iregs[9]),
  X(iregs[10]),
  X(iregs[11]),
  X(iregs[12]),
  X(iregs[13]),
  X(iregs[14]),
  X(iregs[15]),
  X(iregs[16]),
  X(iregs[17]),
  X(iregs[18]),
  X(iregs[19]),
  X(iregs[20]),
  X(iregs[21]),
  X(iregs[22]),
  X(iregs[23]),
  X(iregs[24]),
  X(iregs[25]),
  X(iregs[26]),
  X(iregs[27]),
  X(iregs[28]),
  X(iregs[29]),
  X(iregs[30]),
  X(iregs[31]),

  X(fregs[0]),			/* f0 */
  X(fregs[1]),
  X(fregs[2]),
  X(fregs[3]),
  X(fregs[4]),
  X(fregs[5]),
  X(fregs[6]),
  X(fregs[7]),
  X(fregs[8]),
  X(fregs[9]),
  X(fregs[10]),
  X(fregs[11]),
  X(fregs[12]),
  X(fregs[13]),
  X(fregs[14]),
  X(fregs[15]),
  X(fregs[16]),
  X(fregs[17]),
  X(fregs[18]),
  X(fregs[19]),
  X(fregs[20]),
  X(fregs[21]),
  X(fregs[22]),
  X(fregs[23]),
  X(fregs[24]),
  X(fregs[25]),
  X(fregs[26]),
  X(fregs[27]),
  X(fregs[28]),
  X(fregs[29]),
  X(fregs[30]),
  X(fregs[31]),

  X(srr0),			/* IAR (PC) */
  X(srr1),			/* MSR (PS) */
  X(cr),			/* CR */
  X(lr),			/* LR */
  X(ctr),			/* CTR */
  X(xer),			/* XER */
  X(mq)				/* MQ */
d283 1
a283 1
      struct econtext ec;		/* general regs */
d289 1
a289 1
      retval = ptrace (PTRACE_GETREGS, inferior_pid, (PTRACE_ARG3_TYPE) &ec,
d293 1
a293 1
  
d296 1
a296 1
      supply_register (TBR_REGNUM, (char *)&ec.tbr);
d303 5
a307 5
      supply_register (PS_REGNUM, (char *)&ec.psr);
      supply_register (Y_REGNUM, (char *)&ec.y);
      supply_register (PC_REGNUM, (char *)&ec.pc);
      supply_register (NPC_REGNUM, (char *)&ec.npc);
      supply_register (WIM_REGNUM, (char *)&ec.wim);
d322 3
a324 3
      target_xfer_memory (sp + FRAME_SAVED_I0,
			  &registers[REGISTER_BYTE(I0_REGNUM)],
			  8 * REGISTER_RAW_SIZE (I0_REGNUM), 0);
d328 3
a330 3
      target_xfer_memory (sp + FRAME_SAVED_L0,
			  &registers[REGISTER_BYTE(L0_REGNUM)],
			  8 * REGISTER_RAW_SIZE (L0_REGNUM), 0);
d337 1
a337 1
      struct fcontext fc;		/* fp regs */
d342 1
a342 1
      retval = ptrace (PTRACE_GETFPREGS, inferior_pid, (PTRACE_ARG3_TYPE) &fc,
d346 1
a346 1
  
d352 1
a352 1
      supply_register (FPS_REGNUM, (char *)&fc.fsr);
d382 1
a382 1
      struct econtext ec;		/* general regs */
d399 1
a399 1
      retval = ptrace (PTRACE_SETREGS, inferior_pid, (PTRACE_ARG3_TYPE) &ec,
d414 3
a416 3
	  if (!register_valid[L0_REGNUM+5])
	    abort();
	  target_xfer_memory (sp + FRAME_SAVED_I0,
d418 1
a418 1
			      8 * REGISTER_RAW_SIZE (I0_REGNUM), 1);
d420 1
a420 1
	  target_xfer_memory (sp + FRAME_SAVED_L0,
d422 1
a422 1
			      8 * REGISTER_RAW_SIZE (L0_REGNUM), 1);
d427 1
a427 1
	    abort();
d434 3
a436 2
	  target_xfer_memory (sp + regoffset, &registers[REGISTER_BYTE (regno)],
			      REGISTER_RAW_SIZE (regno), 1);
d442 1
a442 1
      struct fcontext fc;		/* fp regs */
d447 1
a447 1
      retval = ptrace (PTRACE_GETFPREGS, inferior_pid, (PTRACE_ARG3_TYPE) &fc,
d451 1
a451 1
  
d458 1
a458 1
      retval = ptrace (PTRACE_SETFPREGS, inferior_pid, (PTRACE_ARG3_TYPE) &fc,
d462 1
a462 1
      }
d472 1
a472 1
registers_addr(pid)
d476 1
a476 1
  int ecpoff = offsetof(st_t, ecp);
d480 1
a480 1
  stblock = (CORE_ADDR) ptrace (PTRACE_THREADUSER, pid, (PTRACE_ARG3_TYPE)0,
d485 1
a485 1
  ecp = (CORE_ADDR) ptrace (PTRACE_PEEKTHREAD, pid, (PTRACE_ARG3_TYPE)ecpoff,
d533 2
a534 2
  
	  *(int *)&buf[i] = reg;
d582 1
a582 1
	  reg = *(unsigned int *)&registers[REGISTER_BYTE (regno) + i];
d610 1
a610 1
      set_sigint_trap();	/* Causes SIGINT to be passed on to the
d616 1
a616 1
      clear_sigint_trap();
d623 1
a623 1
		   safe_strerror (save_errno));
d630 1
a630 1
      if (pid != PIDGET (inferior_pid))	/* Some other process?!? */
d636 1
a636 1
	 resort to this hack.  */
d651 2
a652 2
      if (WIFSTOPPED(status)
	  && WSTOPSIG(status) == SIGTRAP
d657 1
a657 1
	  realsig = ptrace (PTRACE_GETTRACESIG, pid, (PTRACE_ARG3_TYPE)0, 0);
d662 1
a662 1
		 realsig -- the code in wait_for_inferior expects SIGTRAP. */
d672 2
a673 2
      else if (WIFSTOPPED(status)
	       && WSTOPSIG(status) == SIGTRAP
d678 1
a678 1
	  realsig = ptrace (PTRACE_GETTRACESIG, pid, (PTRACE_ARG3_TYPE)0, 0);
d682 1
a682 1
	      ptrace (PTRACE_CONT, PIDGET (pid), (PTRACE_ARG3_TYPE)0, 0);
d689 3
a691 3
	 host macros to access it.  These lines just a copy of
	 store_waitstatus.  We can't use CHILD_SPECIAL_WAITSTATUS
	 because target.c can't include the Lynx <sys/wait.h>.  */
d778 1
a778 1
lynx_pid_to_str (pid)
d794 1
a794 1
         on machines where they are discontiguous).
d796 3
a798 3
            core_reg_sect.  This is used with old-fashioned core files to
	    locate the registers in a large upage-plus-stack ".reg" section.
	    Original upage address X is at location core_reg_sect+x+reg_addr.
d823 1
a824 1

d830 5
a834 3
  bfd_target_unknown_flavour,
  fetch_core_registers,
  NULL
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 pre reformat
@
text
@d31 1
a31 1
static void fetch_core_registers PARAMS ((char *, unsigned, int, CORE_ADDR));
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d40 16
a55 16
  X (eax),
  X (ecx),
  X (edx),
  X (ebx),
  X (esp),			/* sp */
  X (ebp),			/* fp */
  X (esi),
  X (edi),
  X (eip),			/* pc */
  X (flags),			/* ps */
  X (cs),
  X (ss),
  X (ds),
  X (es),
  X (ecode),			/* Lynx doesn't give us either fs or gs, so */
  X (fault),			/* we just substitute these two in the hopes
d65 33
a97 33
  X (regs[0]),			/* d0 */
  X (regs[1]),			/* d1 */
  X (regs[2]),			/* d2 */
  X (regs[3]),			/* d3 */
  X (regs[4]),			/* d4 */
  X (regs[5]),			/* d5 */
  X (regs[6]),			/* d6 */
  X (regs[7]),			/* d7 */
  X (regs[8]),			/* a0 */
  X (regs[9]),			/* a1 */
  X (regs[10]),			/* a2 */
  X (regs[11]),			/* a3 */
  X (regs[12]),			/* a4 */
  X (regs[13]),			/* a5 */
  X (regs[14]),			/* fp */
  offsetof (st_t, usp) - offsetof (st_t, ec),	/* sp */
  X (status),			/* ps */
  X (pc),

  X (fregs[0 * 3]),		/* fp0 */
  X (fregs[1 * 3]),		/* fp1 */
  X (fregs[2 * 3]),		/* fp2 */
  X (fregs[3 * 3]),		/* fp3 */
  X (fregs[4 * 3]),		/* fp4 */
  X (fregs[5 * 3]),		/* fp5 */
  X (fregs[6 * 3]),		/* fp6 */
  X (fregs[7 * 3]),		/* fp7 */

  X (fcregs[0]),		/* fpcontrol */
  X (fcregs[1]),		/* fpstatus */
  X (fcregs[2]),		/* fpiaddr */
  X (ssw),			/* fpcode */
  X (fault),			/* fpflags */
d109 4
a112 4
  X (g1),
  X (g2),
  X (g3),
  X (g4),
d117 53
a169 53
  X (o[0]),
  X (o[1]),
  X (o[2]),
  X (o[3]),
  X (o[4]),
  X (o[5]),
  X (o[6]),			/* sp */
  X (o[7]),			/* ra */

  -1, -1, -1, -1, -1, -1, -1, -1,	/* l0 -> l7 */

  -1, -1, -1, -1, -1, -1, -1, -1,	/* i0 -> i7 */

  FX (f.fregs[0]),		/* f0 */
  FX (f.fregs[1]),
  FX (f.fregs[2]),
  FX (f.fregs[3]),
  FX (f.fregs[4]),
  FX (f.fregs[5]),
  FX (f.fregs[6]),
  FX (f.fregs[7]),
  FX (f.fregs[8]),
  FX (f.fregs[9]),
  FX (f.fregs[10]),
  FX (f.fregs[11]),
  FX (f.fregs[12]),
  FX (f.fregs[13]),
  FX (f.fregs[14]),
  FX (f.fregs[15]),
  FX (f.fregs[16]),
  FX (f.fregs[17]),
  FX (f.fregs[18]),
  FX (f.fregs[19]),
  FX (f.fregs[20]),
  FX (f.fregs[21]),
  FX (f.fregs[22]),
  FX (f.fregs[23]),
  FX (f.fregs[24]),
  FX (f.fregs[25]),
  FX (f.fregs[26]),
  FX (f.fregs[27]),
  FX (f.fregs[28]),
  FX (f.fregs[29]),
  FX (f.fregs[30]),
  FX (f.fregs[31]),

  X (y),
  X (psr),
  X (wim),
  X (tbr),
  X (pc),
  X (npc),
  FX (fsr),			/* fpsr */
d178 73
a250 73
  X (iregs[0]),			/* r0 */
  X (iregs[1]),
  X (iregs[2]),
  X (iregs[3]),
  X (iregs[4]),
  X (iregs[5]),
  X (iregs[6]),
  X (iregs[7]),
  X (iregs[8]),
  X (iregs[9]),
  X (iregs[10]),
  X (iregs[11]),
  X (iregs[12]),
  X (iregs[13]),
  X (iregs[14]),
  X (iregs[15]),
  X (iregs[16]),
  X (iregs[17]),
  X (iregs[18]),
  X (iregs[19]),
  X (iregs[20]),
  X (iregs[21]),
  X (iregs[22]),
  X (iregs[23]),
  X (iregs[24]),
  X (iregs[25]),
  X (iregs[26]),
  X (iregs[27]),
  X (iregs[28]),
  X (iregs[29]),
  X (iregs[30]),
  X (iregs[31]),

  X (fregs[0]),			/* f0 */
  X (fregs[1]),
  X (fregs[2]),
  X (fregs[3]),
  X (fregs[4]),
  X (fregs[5]),
  X (fregs[6]),
  X (fregs[7]),
  X (fregs[8]),
  X (fregs[9]),
  X (fregs[10]),
  X (fregs[11]),
  X (fregs[12]),
  X (fregs[13]),
  X (fregs[14]),
  X (fregs[15]),
  X (fregs[16]),
  X (fregs[17]),
  X (fregs[18]),
  X (fregs[19]),
  X (fregs[20]),
  X (fregs[21]),
  X (fregs[22]),
  X (fregs[23]),
  X (fregs[24]),
  X (fregs[25]),
  X (fregs[26]),
  X (fregs[27]),
  X (fregs[28]),
  X (fregs[29]),
  X (fregs[30]),
  X (fregs[31]),

  X (srr0),			/* IAR (PC) */
  X (srr1),			/* MSR (PS) */
  X (cr),			/* CR */
  X (lr),			/* LR */
  X (ctr),			/* CTR */
  X (xer),			/* XER */
  X (mq)			/* MQ */
d282 1
a282 1
      struct econtext ec;	/* general regs */
d288 1
a288 1
      retval = ptrace (PTRACE_GETREGS, inferior_pid, (PTRACE_ARG3_TYPE) & ec,
d292 1
a292 1

d295 1
a295 1
      supply_register (TBR_REGNUM, (char *) &ec.tbr);
d302 5
a306 5
      supply_register (PS_REGNUM, (char *) &ec.psr);
      supply_register (Y_REGNUM, (char *) &ec.y);
      supply_register (PC_REGNUM, (char *) &ec.pc);
      supply_register (NPC_REGNUM, (char *) &ec.npc);
      supply_register (WIM_REGNUM, (char *) &ec.wim);
d322 1
a322 1
			  &registers[REGISTER_BYTE (I0_REGNUM)],
d328 1
a328 1
			  &registers[REGISTER_BYTE (L0_REGNUM)],
d336 1
a336 1
      struct fcontext fc;	/* fp regs */
d341 1
a341 1
      retval = ptrace (PTRACE_GETFPREGS, inferior_pid, (PTRACE_ARG3_TYPE) & fc,
d345 1
a345 1

d351 1
a351 1
      supply_register (FPS_REGNUM, (char *) &fc.fsr);
d381 1
a381 1
      struct econtext ec;	/* general regs */
d398 1
a398 1
      retval = ptrace (PTRACE_SETREGS, inferior_pid, (PTRACE_ARG3_TYPE) & ec,
d413 2
a414 2
	  if (!register_valid[L0_REGNUM + 5])
	    abort ();
d426 1
a426 1
	    abort ();
d440 1
a440 1
      struct fcontext fc;	/* fp regs */
d445 1
a445 1
      retval = ptrace (PTRACE_GETFPREGS, inferior_pid, (PTRACE_ARG3_TYPE) & fc,
d449 1
a449 1

d456 1
a456 1
      retval = ptrace (PTRACE_SETFPREGS, inferior_pid, (PTRACE_ARG3_TYPE) & fc,
d460 1
a460 1
    }
d470 1
a470 1
registers_addr (pid)
d474 1
a474 1
  int ecpoff = offsetof (st_t, ecp);
d478 1
a478 1
  stblock = (CORE_ADDR) ptrace (PTRACE_THREADUSER, pid, (PTRACE_ARG3_TYPE) 0,
d483 1
a483 1
  ecp = (CORE_ADDR) ptrace (PTRACE_PEEKTHREAD, pid, (PTRACE_ARG3_TYPE) ecpoff,
d531 2
a532 2

	  *(int *) &buf[i] = reg;
d580 1
a580 1
	  reg = *(unsigned int *) &registers[REGISTER_BYTE (regno) + i];
d608 1
a608 1
      set_sigint_trap ();	/* Causes SIGINT to be passed on to the
d614 1
a614 1
      clear_sigint_trap ();
d621 1
a621 1
			      safe_strerror (save_errno));
d628 1
a628 1
      if (pid != PIDGET (inferior_pid))		/* Some other process?!? */
d634 1
a634 1
         resort to this hack.  */
d649 2
a650 2
      if (WIFSTOPPED (status)
	  && WSTOPSIG (status) == SIGTRAP
d655 1
a655 1
	  realsig = ptrace (PTRACE_GETTRACESIG, pid, (PTRACE_ARG3_TYPE) 0, 0);
d660 1
a660 1
	         realsig -- the code in wait_for_inferior expects SIGTRAP. */
d670 2
a671 2
      else if (WIFSTOPPED (status)
	       && WSTOPSIG (status) == SIGTRAP
d676 1
a676 1
	  realsig = ptrace (PTRACE_GETTRACESIG, pid, (PTRACE_ARG3_TYPE) 0, 0);
d680 1
a680 1
	      ptrace (PTRACE_CONT, PIDGET (pid), (PTRACE_ARG3_TYPE) 0, 0);
d687 3
a689 3
         host macros to access it.  These lines just a copy of
         store_waitstatus.  We can't use CHILD_SPECIAL_WAITSTATUS
         because target.c can't include the Lynx <sys/wait.h>.  */
d792 1
a792 1
   on machines where they are discontiguous).
d794 3
a796 3
   core_reg_sect.  This is used with old-fashioned core files to
   locate the registers in a large upage-plus-stack ".reg" section.
   Original upage address X is at location core_reg_sect+x+reg_addr.
d821 1
a822 1

@


1.1.1.4
log
@import gdb-1999-10-04 snapshot
@
text
@d829 3
a831 5
  bfd_target_unknown_flavour,		/* core_flavour */
  default_check_format,			/* check_format */
  default_core_sniffer,			/* core_sniffer */
  fetch_core_registers,			/* core_read_registers */
  NULL					/* next */
@


1.1.1.5
log
@import gdb-1999-12-21 snapshot
@
text
@d777 1
a777 1
child_pid_to_str (pid)
@


