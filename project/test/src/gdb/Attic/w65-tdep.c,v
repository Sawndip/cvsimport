head	1.7;
access;
symbols
	gdb_5_1_1-2002-01-24-release:1.6
	gdb_5_1_0_1-2002-01-03-release:1.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.8
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.6
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.4
	gdb_5_1-2001-07-29-branchpoint:1.6
	dberlin-typesystem-branch:1.6.0.2
	dberlin-typesystem-branchpoint:1.6
	gdb-post-ptid_t-2001-05-03:1.6
	gdb-pre-ptid_t-2001-05-03:1.6
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb-post-params-removal-2000-06-04:1.1.1.2
	gdb-pre-params-removal-2000-06-04:1.1.1.2
	gdb-post-params-removal-2000-05-28:1.1.1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.7
date	2001.12.01.19.34.37;	author cagney;	state dead;
branches;
next	1.6;

1.6
date	2001.04.03.21.56.01;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.06.08.21.18;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.01.01.39.22;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.28;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.11.11;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Zap a29k.
@
text
@/* OBSOLETE /* Target-machine dependent code for WDC-65816, for GDB. */
/* OBSOLETE    Copyright 1995, 1996, 2000, 2001 Free Software Foundation, Inc. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE /* */
/* OBSOLETE    Contributed by Steve Chamberlain */
/* OBSOLETE    sac@@cygnus.com */
/* OBSOLETE  */ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "frame.h" */
/* OBSOLETE #include "obstack.h" */
/* OBSOLETE #include "symtab.h" */
/* OBSOLETE #include "gdbcmd.h" */
/* OBSOLETE #include "gdbtypes.h" */
/* OBSOLETE #include "dis-asm.h" */
/* OBSOLETE #include "gdbcore.h" */
/* OBSOLETE #include "regcache.h" */
/* OBSOLETE  */
/* OBSOLETE /* Return the saved PC from this frame. */ */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE w65_frame_saved_pc (struct frame_info *frame) */
/* OBSOLETE { */
/* OBSOLETE   return (read_memory_integer (frame->frame + 2, 4) & 0xffffff); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE w65_addr_bits_remove (CORE_ADDR addr) */
/* OBSOLETE { */
/* OBSOLETE   return ((addr) & 0xffffff); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE read_memory_pointer (CORE_ADDR x) */
/* OBSOLETE { */
/* OBSOLETE   return read_memory_integer (ADDR_BITS_REMOVE (x), 4); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE init_frame_pc (void) */
/* OBSOLETE { */
/* OBSOLETE   internal_error (__FILE__, __LINE__, "failed internal consistency check"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE w65_push_dummy_frame (void) */
/* OBSOLETE { */
/* OBSOLETE   internal_error (__FILE__, __LINE__, "failed internal consistency check"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Put here the code to store, into a struct frame_saved_regs, */
/* OBSOLETE    the addresses of the saved registers of frame described by FRAME_INFO. */
/* OBSOLETE    This includes special registers such as pc and fp saved in special */
/* OBSOLETE    ways in the stack frame.  sp is even more special: */
/* OBSOLETE    the address we return for it IS the sp for the next frame. */
/* OBSOLETE  */
/* OBSOLETE    We cache the result of doing this in the frame_cache_obstack, since */
/* OBSOLETE    it is fairly expensive.  */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE frame_find_saved_regs (struct frame_info *fip, struct frame_saved_regs *fsrp) */
/* OBSOLETE { */
/* OBSOLETE   int locals; */
/* OBSOLETE   CORE_ADDR pc; */
/* OBSOLETE   CORE_ADDR adr; */
/* OBSOLETE   int i; */
/* OBSOLETE  */
/* OBSOLETE   memset (fsrp, 0, sizeof *fsrp); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE saved_pc_after_call (void) */
/* OBSOLETE { */
/* OBSOLETE   int sp = read_register (SP_REGNUM); */
/* OBSOLETE   int val = read_memory_integer (sp + 1, 4); */
/* OBSOLETE   return ADDR_BITS_REMOVE (val); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE extract_return_value (struct type *type, char *regbuf, char *valbuf) */
/* OBSOLETE { */
/* OBSOLETE   int b; */
/* OBSOLETE   int len = TYPE_LENGTH (type); */
/* OBSOLETE  */
/* OBSOLETE   for (b = 0; b < len; b += 2) */
/* OBSOLETE     { */
/* OBSOLETE       int todo = len - b; */
/* OBSOLETE       if (todo > 2) */
/* OBSOLETE 	todo = 2; */
/* OBSOLETE       memcpy (valbuf + b, regbuf + b, todo); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE write_return_value (struct type *type, char *valbuf) */
/* OBSOLETE { */
/* OBSOLETE   int reg; */
/* OBSOLETE   int len; */
/* OBSOLETE   for (len = 0; len < TYPE_LENGTH (type); len += 2) */
/* OBSOLETE     { */
/* OBSOLETE       write_register_bytes (REGISTER_BYTE (len / 2 + 2), valbuf + len, 2); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE store_struct_return (CORE_ADDR addr, CORE_ADDR sp) */
/* OBSOLETE { */
/* OBSOLETE   write_register (2, addr); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE w65_pop_frame (void) */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE init_extra_frame_info (void) */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE pop_frame (void) */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE w65_frame_chain (struct frame_info *thisframe) */
/* OBSOLETE { */
/* OBSOLETE   return 0xffff & read_memory_integer ((thisframe)->frame, 2); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE gb (int x) */
/* OBSOLETE { */
/* OBSOLETE   return read_memory_integer (x, 1) & 0xff; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE extern CORE_ADDR */
/* OBSOLETE w65_skip_prologue (CORE_ADDR pc) */
/* OBSOLETE { */
/* OBSOLETE   CORE_ADDR too_far = pc + 20; */
/* OBSOLETE  */
/* OBSOLETE   /* looking for bits of the prologue, we can expect to */
/* OBSOLETE      see this in a frameful function: */
/* OBSOLETE  */
/* OBSOLETE      stack adjust: */
/* OBSOLETE  */
/* OBSOLETE      3B                 tsc */
/* OBSOLETE      1A                 inc a */
/* OBSOLETE      18                 clc */
/* OBSOLETE      69E2FF             adc     #0xffe2 */
/* OBSOLETE      3A                 dec a */
/* OBSOLETE      1B                 tcs */
/* OBSOLETE      1A                 inc a */
/* OBSOLETE  */
/* OBSOLETE      link: */
/* OBSOLETE  */
/* OBSOLETE      A500               lda     <r15 */
/* OBSOLETE      48                 pha */
/* OBSOLETE      3B                 tsc */
/* OBSOLETE      1a                 inc     a */
/* OBSOLETE      8500               sta     <r15 */
/* OBSOLETE  */
/* OBSOLETE    */ */
/* OBSOLETE  */
/* OBSOLETE #define TSC  0x3b */
/* OBSOLETE #define TCS  0x1b */
/* OBSOLETE #define INCA 0x1a */
/* OBSOLETE #define PHA  0x48 */
/* OBSOLETE #define LDADIR 0xa5 */
/* OBSOLETE #define STADIR 0x85 */
/* OBSOLETE  */
/* OBSOLETE   /* Skip a stack adjust - any area between a tsc and tcs */ */
/* OBSOLETE   if (gb (pc) == TSC) */
/* OBSOLETE     { */
/* OBSOLETE       while (pc < too_far && gb (pc) != TCS) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  pc++; */
/* OBSOLETE 	} */
/* OBSOLETE       pc++; */
/* OBSOLETE       /* Skip a stupid inc a */ */
/* OBSOLETE       if (gb (pc) == INCA) */
/* OBSOLETE 	pc++; */
/* OBSOLETE  */
/* OBSOLETE     } */
/* OBSOLETE   /* Stack adjust can also be done with n pha's */ */
/* OBSOLETE   while (gb (pc) == PHA) */
/* OBSOLETE     pc++; */
/* OBSOLETE  */
/* OBSOLETE   /* Skip a link - that's a ld/ph/tsc/inc/sta */ */
/* OBSOLETE  */
/* OBSOLETE   if (gb (pc) == LDADIR */
/* OBSOLETE       && gb (pc + 5) == STADIR */
/* OBSOLETE       && gb (pc + 1) == gb (pc + 6) */
/* OBSOLETE       && gb (pc + 2) == PHA */
/* OBSOLETE       && gb (pc + 3) == TSC */
/* OBSOLETE       && gb (pc + 4) == INCA) */
/* OBSOLETE     { */
/* OBSOLETE       pc += 7; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   return pc; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE register_raw_size (int n) */
/* OBSOLETE { */
/* OBSOLETE   return sim_reg_size (n); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE print_register_hook (int regno) */
/* OBSOLETE { */
/* OBSOLETE   if (regno == P_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       /* CCR register */ */
/* OBSOLETE  */
/* OBSOLETE       int C, Z, N, V, I, D, X, M; */
/* OBSOLETE       unsigned char b[1]; */
/* OBSOLETE       unsigned char l; */
/* OBSOLETE  */
/* OBSOLETE       read_relative_register_raw_bytes (regno, b); */
/* OBSOLETE       l = b[0]; */
/* OBSOLETE       printf_unfiltered ("\t"); */
/* OBSOLETE       C = (l & 0x1) != 0; */
/* OBSOLETE       Z = (l & 0x2) != 0; */
/* OBSOLETE       I = (l & 0x4) != 0; */
/* OBSOLETE       D = (l & 0x8) != 0; */
/* OBSOLETE       X = (l & 0x10) != 0; */
/* OBSOLETE       M = (l & 0x20) != 0; */
/* OBSOLETE       V = (l & 0x40) != 0; */
/* OBSOLETE       N = (l & 0x80) != 0; */
/* OBSOLETE  */
/* OBSOLETE       printf_unfiltered ("N-%d ", N); */
/* OBSOLETE       printf_unfiltered ("V-%d ", V); */
/* OBSOLETE       printf_unfiltered ("M-%d ", M); */
/* OBSOLETE       printf_unfiltered ("X-%d ", X); */
/* OBSOLETE       printf_unfiltered ("D-%d ", D); */
/* OBSOLETE       printf_unfiltered ("I-%d ", I); */
/* OBSOLETE       printf_unfiltered ("Z-%d ", Z); */
/* OBSOLETE       printf_unfiltered ("C-%d ", C); */
/* OBSOLETE       if ((C | Z) == 0) */
/* OBSOLETE 	printf_unfiltered ("u> "); */
/* OBSOLETE       if ((C | Z) == 1) */
/* OBSOLETE 	printf_unfiltered ("u<= "); */
/* OBSOLETE       if ((C == 0)) */
/* OBSOLETE 	printf_unfiltered ("u>= "); */
/* OBSOLETE       if (C == 1) */
/* OBSOLETE 	printf_unfiltered ("u< "); */
/* OBSOLETE       if (Z == 0) */
/* OBSOLETE 	printf_unfiltered ("!= "); */
/* OBSOLETE       if (Z == 1) */
/* OBSOLETE 	printf_unfiltered ("== "); */
/* OBSOLETE       if ((N ^ V) == 0) */
/* OBSOLETE 	printf_unfiltered (">= "); */
/* OBSOLETE       if ((N ^ V) == 1) */
/* OBSOLETE 	printf_unfiltered ("< "); */
/* OBSOLETE       if ((Z | (N ^ V)) == 0) */
/* OBSOLETE 	printf_unfiltered ("> "); */
/* OBSOLETE       if ((Z | (N ^ V)) == 1) */
/* OBSOLETE 	printf_unfiltered ("<= "); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE _initialize_w65_tdep (void) */
/* OBSOLETE { */
/* OBSOLETE   tm_print_insn = print_insn_w65; */
/* OBSOLETE } */
@


1.6
log
@Obsolete w65-*-* target.
@
text
@@


1.5
log
@Update/correct copyright notices.
@
text
@d1 283
a283 283
/* Target-machine dependent code for WDC-65816, for GDB.
   Copyright 1995, 1996, 2000, 2001 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/*
   Contributed by Steve Chamberlain
   sac@@cygnus.com
 */

#include "defs.h"
#include "frame.h"
#include "obstack.h"
#include "symtab.h"
#include "gdbcmd.h"
#include "gdbtypes.h"
#include "dis-asm.h"
#include "gdbcore.h"
#include "regcache.h"

/* Return the saved PC from this frame. */


CORE_ADDR
w65_frame_saved_pc (struct frame_info *frame)
{
  return (read_memory_integer (frame->frame + 2, 4) & 0xffffff);
}

CORE_ADDR
w65_addr_bits_remove (CORE_ADDR addr)
{
  return ((addr) & 0xffffff);
}

read_memory_pointer (CORE_ADDR x)
{
  return read_memory_integer (ADDR_BITS_REMOVE (x), 4);
}

init_frame_pc (void)
{
  internal_error (__FILE__, __LINE__, "failed internal consistency check");
}

void
w65_push_dummy_frame (void)
{
  internal_error (__FILE__, __LINE__, "failed internal consistency check");
}

/* Put here the code to store, into a struct frame_saved_regs,
   the addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.

   We cache the result of doing this in the frame_cache_obstack, since
   it is fairly expensive.  */

void
frame_find_saved_regs (struct frame_info *fip, struct frame_saved_regs *fsrp)
{
  int locals;
  CORE_ADDR pc;
  CORE_ADDR adr;
  int i;

  memset (fsrp, 0, sizeof *fsrp);
}

int
saved_pc_after_call (void)
{
  int sp = read_register (SP_REGNUM);
  int val = read_memory_integer (sp + 1, 4);
  return ADDR_BITS_REMOVE (val);
}


extract_return_value (struct type *type, char *regbuf, char *valbuf)
{
  int b;
  int len = TYPE_LENGTH (type);

  for (b = 0; b < len; b += 2)
    {
      int todo = len - b;
      if (todo > 2)
	todo = 2;
      memcpy (valbuf + b, regbuf + b, todo);
    }
}

void
write_return_value (struct type *type, char *valbuf)
{
  int reg;
  int len;
  for (len = 0; len < TYPE_LENGTH (type); len += 2)
    {
      write_register_bytes (REGISTER_BYTE (len / 2 + 2), valbuf + len, 2);
    }
}

void
store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  write_register (2, addr);
}

void
w65_pop_frame (void)
{
}

init_extra_frame_info (void)
{
}

pop_frame (void)
{
}

w65_frame_chain (struct frame_info *thisframe)
{
  return 0xffff & read_memory_integer ((thisframe)->frame, 2);
}

static int
gb (int x)
{
  return read_memory_integer (x, 1) & 0xff;
}

extern CORE_ADDR
w65_skip_prologue (CORE_ADDR pc)
{
  CORE_ADDR too_far = pc + 20;

  /* looking for bits of the prologue, we can expect to
     see this in a frameful function:

     stack adjust:

     3B                 tsc
     1A                 inc a
     18                 clc
     69E2FF             adc     #0xffe2
     3A                 dec a
     1B                 tcs
     1A                 inc a

     link:

     A500               lda     <r15
     48                 pha
     3B                 tsc
     1a                 inc     a
     8500               sta     <r15

   */

#define TSC  0x3b
#define TCS  0x1b
#define INCA 0x1a
#define PHA  0x48
#define LDADIR 0xa5
#define STADIR 0x85

  /* Skip a stack adjust - any area between a tsc and tcs */
  if (gb (pc) == TSC)
    {
      while (pc < too_far && gb (pc) != TCS)
	{
	  pc++;
	}
      pc++;
      /* Skip a stupid inc a */
      if (gb (pc) == INCA)
	pc++;

    }
  /* Stack adjust can also be done with n pha's */
  while (gb (pc) == PHA)
    pc++;

  /* Skip a link - that's a ld/ph/tsc/inc/sta */

  if (gb (pc) == LDADIR
      && gb (pc + 5) == STADIR
      && gb (pc + 1) == gb (pc + 6)
      && gb (pc + 2) == PHA
      && gb (pc + 3) == TSC
      && gb (pc + 4) == INCA)
    {
      pc += 7;
    }

  return pc;
}


register_raw_size (int n)
{
  return sim_reg_size (n);
}


void
print_register_hook (int regno)
{
  if (regno == P_REGNUM)
    {
      /* CCR register */

      int C, Z, N, V, I, D, X, M;
      unsigned char b[1];
      unsigned char l;

      read_relative_register_raw_bytes (regno, b);
      l = b[0];
      printf_unfiltered ("\t");
      C = (l & 0x1) != 0;
      Z = (l & 0x2) != 0;
      I = (l & 0x4) != 0;
      D = (l & 0x8) != 0;
      X = (l & 0x10) != 0;
      M = (l & 0x20) != 0;
      V = (l & 0x40) != 0;
      N = (l & 0x80) != 0;

      printf_unfiltered ("N-%d ", N);
      printf_unfiltered ("V-%d ", V);
      printf_unfiltered ("M-%d ", M);
      printf_unfiltered ("X-%d ", X);
      printf_unfiltered ("D-%d ", D);
      printf_unfiltered ("I-%d ", I);
      printf_unfiltered ("Z-%d ", Z);
      printf_unfiltered ("C-%d ", C);
      if ((C | Z) == 0)
	printf_unfiltered ("u> ");
      if ((C | Z) == 1)
	printf_unfiltered ("u<= ");
      if ((C == 0))
	printf_unfiltered ("u>= ");
      if (C == 1)
	printf_unfiltered ("u< ");
      if (Z == 0)
	printf_unfiltered ("!= ");
      if (Z == 1)
	printf_unfiltered ("== ");
      if ((N ^ V) == 0)
	printf_unfiltered (">= ");
      if ((N ^ V) == 1)
	printf_unfiltered ("< ");
      if ((Z | (N ^ V)) == 0)
	printf_unfiltered ("> ");
      if ((Z | (N ^ V)) == 1)
	printf_unfiltered ("<= ");
    }
}

void
_initialize_w65_tdep (void)
{
  tm_print_insn = print_insn_w65;
}
@


1.4
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 1
a2 1
   Copyright 1995, 2001 Free Software Foundation, Inc.
@


1.3
log
@Replace calls to abort() with calls to internal_error().
@
text
@d2 1
a2 1
   Copyright (C) 1995 Free Software Foundation, Inc.
d34 1
@


1.2
log
@Protoization.
@
text
@d57 1
a57 1
  abort ();
d63 1
a63 1
  abort ();
@


1.1
log
@Initial revision
@
text
@d18 2
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d39 1
a39 2
w65_frame_saved_pc (frame)
     struct frame_info *frame;
d45 1
a45 2
w65_addr_bits_remove (addr)
     CORE_ADDR addr;
d50 1
a50 2
read_memory_pointer (x)
     CORE_ADDR x;
d55 1
a55 1
init_frame_pc ()
d61 1
a61 1
w65_push_dummy_frame ()
d76 1
a76 3
frame_find_saved_regs (fip, fsrp)
     struct frame_info *fip;
     struct frame_saved_regs *fsrp;
d87 1
a87 1
saved_pc_after_call ()
d95 1
a95 4
extract_return_value (type, regbuf, valbuf)
     struct type *type;
     char *regbuf;
     char *valbuf;
d110 1
a110 3
write_return_value (type, valbuf)
     struct type *type;
     char *valbuf;
d121 1
a121 3
store_struct_return (addr, sp)
     CORE_ADDR addr;
     CORE_ADDR sp;
d127 1
a127 1
w65_pop_frame ()
d131 1
a131 1
init_extra_frame_info ()
d135 1
a135 1
pop_frame ()
d139 1
a139 2
w65_frame_chain (thisframe)
     struct frame_info *thisframe;
d145 1
a145 1
gb (x)
d150 2
a151 3
extern CORE_ADDR 
w65_skip_prologue (pc)
     CORE_ADDR pc;
d218 1
a218 1
register_raw_size (n)
d225 1
a225 1
print_register_hook (regno)
d279 1
a279 1
_initialize_w65_tdep ()
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d18 1
a18 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d162 1
a162 1
extern CORE_ADDR
@

