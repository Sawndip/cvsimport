head	1.9;
access;
symbols
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.10
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.8
	carlton_dictionary-20020920-branchpoint:1.8
	gdb_5_3-branch:1.8.0.6
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.4
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.2
	readline_4_3-import-branchpoint:1.8
	gdb_5_2_1-2002-07-23-release:1.7
	kseitz_interps-20020528-branch:1.7.0.16
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.7.0.14
	cagney_regbuf-20020515-branchpoint:1.7
	jimb-macro-020506-branch:1.7.0.12
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.7
	gdb_5_2-branch:1.7.0.10
	gdb_5_2-2002-03-03-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.8
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.6
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.4
	gdb_5_1-2001-07-29-branchpoint:1.7
	dberlin-typesystem-branch:1.7.0.2
	dberlin-typesystem-branchpoint:1.7
	gdb-post-ptid_t-2001-05-03:1.7
	gdb-pre-ptid_t-2001-05-03:1.6
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.4
	gdb-1999-10-25:1.1.1.4
	gdb-1999-10-18:1.1.1.4
	gdb-1999-10-11:1.1.1.4
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.9
date	2002.12.16.20.39.05;	author cagney;	state dead;
branches;
next	1.8;

1.8
date	2002.08.15.22.51.40;	author kettenis;	state Exp;
branches
	1.8.8.1
	1.8.10.1;
next	1.7;

1.7
date	2001.05.04.04.15.25;	author kevinb;	state Exp;
branches
	1.7.16.1;
next	1.6;

1.6
date	2001.03.06.08.21.08;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.05.22.46.57;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.27;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.26;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.06.57;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.10.05.23.08.20;	author jsm;	state Exp;
branches;
next	;

1.7.16.1
date	2002.08.30.22.52.44;	author kseitz;	state Exp;
branches;
next	;

1.8.8.1
date	2002.12.23.19.38.29;	author carlton;	state dead;
branches;
next	;

1.8.10.1
date	2003.12.14.20.27.17;	author drow;	state dead;
branches;
next	;


desc
@@


1.9
log
@2002-12-16  Andrew Cagney  <ac131313@@redhat.com>

	* config/arc/arc.mt, config/arc/tm-arc.h: Delete.
	* config/d30v/d30v.mt, config/d30v/tm-d30v.h: Delete.
	* config/fr30/fr30.mt, config/fr30/tm-fr30.h: Delete.
	* config/i386/i386aix.mh, config/i386/i386aix.mt: Delete.
	* config/i386/i386m3.mh, config/i386/i386m3.mt: Delete.
	* config/i386/i386mach.mh, config/i386/i386os9k.mt: Delete.
	* config/i386/nm-i386aix.h, config/i386/nm-i386mach.h: Delete.
	* config/i386/nm-m3.h, config/i386/tm-i386aix.h: Delete.
	* config/i386/tm-i386m3.h, config/i386/tm-i386mk.h: Delete.
	* config/i386/xm-i386aix.h, config/i386/xm-i386m3.h: Delete.
	* config/i386/xm-i386mach.h, config/i386/xm-i386mk.h: Delete.
	* config/i960/mon960.mt, config/i960/nindy960.mt: Delete.
	* config/i960/tm-i960.h, config/i960/tm-mon960.h: Delete.
	* config/i960/tm-nindy960.h, config/i960/tm-vx960.h: Delete.
	* config/i960/vxworks960.mt, config/m68k/apollo68b.mh: Delete.
	* config/m68k/apollo68b.mt, config/m68k/apollo68v.mh: Delete.
	* config/m68k/hp300bsd.mh, config/m68k/hp300bsd.mt: Delete.
	* config/m68k/hp300hpux.mh, config/m68k/hp300hpux.mt: Delete.
	* config/m88k/delta88.mh, config/m88k/delta88.mt: Delete.
	* config/m88k/delta88v4.mh, config/m88k/delta88v4.mt: Delete.
	* config/m88k/m88k.mh, config/m88k/m88k.mt: Delete.
	* config/m88k/nm-delta88v4.h, config/m88k/nm-m88k.h: Delete.
	* config/m88k/tm-delta88.h, config/m88k/tm-delta88v4.h: Delete.
	* config/m88k/tm-m88k.h, config/m88k/xm-delta88.h: Delete.
	* config/m88k/xm-dgux.h: Delete.
	* fr30-tdep.c, i386aix-nat.c, i386m3-nat.c: Delete.
	* i386mach-nat.c, i960-tdep.c, m88k-nat.c: Delete.
	* os9kread.c, remote-bug.c, remote-nindy.c: Delete.
	* remote-nrom.c, remote-os9k.c, remote-vx960.c: Delete.
	* d30v-tdep.c, arc-tdep.c, cxux-nat.c, dst.h, dstread.c: Delete.
	* ch-exp.c, ch-lang.c, ch-lang.h, ch-typeprint.c: Delete.
	* ch-valprint.c: Delete.
@
text
@// OBSOLETE /* Intel 386 native support.
// OBSOLETE    Copyright 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
// OBSOLETE    2000, 2001 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "language.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #ifdef USG
// OBSOLETE #include <sys/types.h>
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE #include <sys/param.h>
// OBSOLETE #include <sys/dir.h>
// OBSOLETE #include <signal.h>
// OBSOLETE #include <sys/user.h>
// OBSOLETE #include <sys/ioctl.h>
// OBSOLETE #include <fcntl.h>
// OBSOLETE 
// OBSOLETE #include <sys/file.h>
// OBSOLETE #include "gdb_stat.h"
// OBSOLETE 
// OBSOLETE #include <stddef.h>
// OBSOLETE #include <sys/ptrace.h>
// OBSOLETE 
// OBSOLETE /* Does AIX define this in <errno.h>?  */
// OBSOLETE extern int errno;
// OBSOLETE 
// OBSOLETE #ifdef HAVE_SYS_REG_H
// OBSOLETE #include <sys/reg.h>
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE #include "floatformat.h"
// OBSOLETE 
// OBSOLETE #include "target.h"
// OBSOLETE 
// OBSOLETE static void fetch_core_registers (char *, unsigned, int, CORE_ADDR);
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* this table must line up with REGISTER_NAMES in tm-i386v.h */
// OBSOLETE /* symbols like 'EAX' come from <sys/reg.h> */
// OBSOLETE static int regmap[] =
// OBSOLETE {
// OBSOLETE   EAX, ECX, EDX, EBX,
// OBSOLETE   USP, EBP, ESI, EDI,
// OBSOLETE   EIP, EFL, CS, SS,
// OBSOLETE   DS, ES, FS, GS,
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* blockend is the value of u.u_ar0, and points to the
// OBSOLETE  * place where GS is stored
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE i386_register_u_addr (int blockend, int regnum)
// OBSOLETE {
// OBSOLETE #if 0
// OBSOLETE   /* this will be needed if fp registers are reinstated */
// OBSOLETE   /* for now, you can look at them with 'info float'
// OBSOLETE    * sys5 wont let you change them with ptrace anyway
// OBSOLETE    */
// OBSOLETE   if (regnum >= FP0_REGNUM && regnum <= FP7_REGNUM)
// OBSOLETE     {
// OBSOLETE       int ubase, fpstate;
// OBSOLETE       struct user u;
// OBSOLETE       ubase = blockend + 4 * (SS + 1) - KSTKSZ;
// OBSOLETE       fpstate = ubase + ((char *) &u.u_fpstate - (char *) &u);
// OBSOLETE       return (fpstate + 0x1c + 10 * (regnum - FP0_REGNUM));
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE #endif
// OBSOLETE     return (blockend + 4 * regmap[regnum]);
// OBSOLETE 
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* The code below only work on the aix ps/2 (i386-ibm-aix) -
// OBSOLETE  * mtranle@@paris - Sat Apr 11 10:34:12 1992
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE struct env387
// OBSOLETE {
// OBSOLETE   unsigned short control;
// OBSOLETE   unsigned short r0;
// OBSOLETE   unsigned short status;
// OBSOLETE   unsigned short r1;
// OBSOLETE   unsigned short tag;
// OBSOLETE   unsigned short r2;
// OBSOLETE   unsigned long eip;
// OBSOLETE   unsigned short code_seg;
// OBSOLETE   unsigned short opcode;
// OBSOLETE   unsigned long operand;
// OBSOLETE   unsigned short operand_seg;
// OBSOLETE   unsigned short r3;
// OBSOLETE   unsigned char regs[8][10];
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static
// OBSOLETE print_387_status (unsigned short status, struct env387 *ep)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   int bothstatus;
// OBSOLETE   int top;
// OBSOLETE   int fpreg;
// OBSOLETE   unsigned char *p;
// OBSOLETE 
// OBSOLETE   bothstatus = ((status != 0) && (ep->status != 0));
// OBSOLETE   if (status != 0)
// OBSOLETE     {
// OBSOLETE       if (bothstatus)
// OBSOLETE 	printf_unfiltered ("u: ");
// OBSOLETE       print_387_status_word (status);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (ep->status != 0)
// OBSOLETE     {
// OBSOLETE       if (bothstatus)
// OBSOLETE 	printf_unfiltered ("e: ");
// OBSOLETE       print_387_status_word (ep->status);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   print_387_control_word (ep->control);
// OBSOLETE   printf_unfiltered ("last exception: ");
// OBSOLETE   printf_unfiltered ("opcode %s; ", local_hex_string (ep->opcode));
// OBSOLETE   printf_unfiltered ("pc %s:", local_hex_string (ep->code_seg));
// OBSOLETE   printf_unfiltered ("%s; ", local_hex_string (ep->eip));
// OBSOLETE   printf_unfiltered ("operand %s", local_hex_string (ep->operand_seg));
// OBSOLETE   printf_unfiltered (":%s\n", local_hex_string (ep->operand));
// OBSOLETE 
// OBSOLETE   top = ((ep->status >> 11) & 7);
// OBSOLETE 
// OBSOLETE   printf_unfiltered ("regno  tag  msb              lsb  value\n");
// OBSOLETE   for (fpreg = 7; fpreg >= 0; fpreg--)
// OBSOLETE     {
// OBSOLETE       double val;
// OBSOLETE 
// OBSOLETE       printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg);
// OBSOLETE 
// OBSOLETE       switch ((ep->tag >> ((7 - fpreg) * 2)) & 3)
// OBSOLETE 	{
// OBSOLETE 	case 0:
// OBSOLETE 	  printf_unfiltered ("valid ");
// OBSOLETE 	  break;
// OBSOLETE 	case 1:
// OBSOLETE 	  printf_unfiltered ("zero  ");
// OBSOLETE 	  break;
// OBSOLETE 	case 2:
// OBSOLETE 	  printf_unfiltered ("trap  ");
// OBSOLETE 	  break;
// OBSOLETE 	case 3:
// OBSOLETE 	  printf_unfiltered ("empty ");
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       for (i = 9; i >= 0; i--)
// OBSOLETE 	printf_unfiltered ("%02x", ep->regs[fpreg][i]);
// OBSOLETE 
// OBSOLETE       i387_to_double ((char *) ep->regs[fpreg], (char *) &val);
// OBSOLETE       printf_unfiltered ("  %#g\n", val);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct env387 core_env387;
// OBSOLETE 
// OBSOLETE void
// OBSOLETE i386_float_info (void)
// OBSOLETE {
// OBSOLETE   struct env387 fps;
// OBSOLETE   int fpsaved = 0;
// OBSOLETE   /* We need to reverse the order of the registers.  Apparently AIX stores
// OBSOLETE      the highest-numbered ones first.  */
// OBSOLETE   struct env387 fps_fixed;
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   if (! ptid_equal (inferior_ptid, null_ptid))
// OBSOLETE     {
// OBSOLETE       char buf[10];
// OBSOLETE       unsigned short status;
// OBSOLETE 
// OBSOLETE       ptrace (PT_READ_FPR, PIDGET (inferior_ptid), buf,
// OBSOLETE               offsetof (struct env387, status));
// OBSOLETE       memcpy (&status, buf, sizeof (status));
// OBSOLETE       fpsaved = status;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if ((fpsaved = core_env387.status) != 0)
// OBSOLETE 	memcpy (&fps, &core_env387, sizeof (fps));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (fpsaved == 0)
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("no floating point status saved\n");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (! ptid_equal (inferior_ptid, null_ptid))
// OBSOLETE     {
// OBSOLETE       int offset;
// OBSOLETE       for (offset = 0; offset < sizeof (fps); offset += 10)
// OBSOLETE 	{
// OBSOLETE 	  char buf[10];
// OBSOLETE 	  ptrace (PT_READ_FPR, PIDGET (inferior_ptid), buf, offset);
// OBSOLETE 	  memcpy ((char *) &fps.control + offset, buf,
// OBSOLETE 		  MIN (10, sizeof (fps) - offset));
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   fps_fixed = fps;
// OBSOLETE   for (i = 0; i < 8; ++i)
// OBSOLETE     memcpy (fps_fixed.regs[i], fps.regs[7 - i], 10);
// OBSOLETE   print_387_status (0, &fps_fixed);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Fetch one register.  */
// OBSOLETE static void
// OBSOLETE fetch_register (int regno)
// OBSOLETE {
// OBSOLETE   char buf[MAX_REGISTER_RAW_SIZE];
// OBSOLETE   if (regno < FP0_REGNUM)
// OBSOLETE     *(int *) buf = ptrace (PT_READ_GPR, PIDGET (inferior_ptid),
// OBSOLETE 			   PT_REG (regmap[regno]), 0, 0);
// OBSOLETE   else
// OBSOLETE     ptrace (PT_READ_FPR, PIDGET (inferior_ptid), buf,
// OBSOLETE 	    (regno - FP0_REGNUM) * 10 + offsetof (struct env387, regs));
// OBSOLETE   supply_register (regno, buf);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fetch_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   if (regno < 0)
// OBSOLETE     for (regno = 0; regno < NUM_REGS; regno++)
// OBSOLETE       fetch_register (regno);
// OBSOLETE   else
// OBSOLETE     fetch_register (regno);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* store one register */
// OBSOLETE static void
// OBSOLETE store_register (int regno)
// OBSOLETE {
// OBSOLETE   char buf[80];
// OBSOLETE   errno = 0;
// OBSOLETE   if (regno < FP0_REGNUM)
// OBSOLETE     ptrace (PT_WRITE_GPR, PIDGET (inferior_ptid), PT_REG (regmap[regno]),
// OBSOLETE 	    *(int *) &registers[REGISTER_BYTE (regno)], 0);
// OBSOLETE   else
// OBSOLETE     ptrace (PT_WRITE_FPR, PIDGET (inferior_ptid),
// OBSOLETE             &registers[REGISTER_BYTE (regno)],
// OBSOLETE 	    (regno - FP0_REGNUM) * 10 + offsetof (struct env387, regs));
// OBSOLETE 
// OBSOLETE   if (errno != 0)
// OBSOLETE     {
// OBSOLETE       sprintf (buf, "writing register number %d", regno);
// OBSOLETE       perror_with_name (buf);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store our register values back into the inferior.
// OBSOLETE    If REGNO is -1, do this for all registers.
// OBSOLETE    Otherwise, REGNO specifies which register (so we can save time).  */
// OBSOLETE void
// OBSOLETE store_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   if (regno < 0)
// OBSOLETE     for (regno = 0; regno < NUM_REGS; regno++)
// OBSOLETE       store_register (regno);
// OBSOLETE   else
// OBSOLETE     store_register (regno);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifndef CD_AX			/* defined in sys/i386/coredump.h */
// OBSOLETE #define CD_AX	0
// OBSOLETE #define CD_BX	1
// OBSOLETE #define CD_CX	2
// OBSOLETE #define CD_DX	3
// OBSOLETE #define CD_SI	4
// OBSOLETE #define CD_DI	5
// OBSOLETE #define CD_BP	6
// OBSOLETE #define CD_SP	7
// OBSOLETE #define CD_FL	8
// OBSOLETE #define CD_IP	9
// OBSOLETE #define CD_CS	10
// OBSOLETE #define CD_DS	11
// OBSOLETE #define CD_ES	12
// OBSOLETE #define CD_FS	13
// OBSOLETE #define CD_GS	14
// OBSOLETE #define CD_SS	15
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * The order here in core_regmap[] has to be the same as in 
// OBSOLETE  * regmap[] above.
// OBSOLETE  */
// OBSOLETE static int core_regmap[] =
// OBSOLETE {
// OBSOLETE   CD_AX, CD_CX, CD_DX, CD_BX,
// OBSOLETE   CD_SP, CD_BP, CD_SI, CD_DI,
// OBSOLETE   CD_IP, CD_FL, CD_CS, CD_SS,
// OBSOLETE   CD_DS, CD_ES, CD_FS, CD_GS,
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* Provide registers to GDB from a core file.
// OBSOLETE 
// OBSOLETE    CORE_REG_SECT points to an array of bytes, which were obtained from
// OBSOLETE    a core file which BFD thinks might contain register contents. 
// OBSOLETE    CORE_REG_SIZE is its size.
// OBSOLETE 
// OBSOLETE    WHICH says which register set corelow suspects this is:
// OBSOLETE      0 --- the general-purpose register set
// OBSOLETE      2 --- the floating-point register set
// OBSOLETE 
// OBSOLETE    REG_ADDR isn't used.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE fetch_core_registers (char *core_reg_sect, unsigned core_reg_size,
// OBSOLETE 		      int which, CORE_ADDR reg_addr)
// OBSOLETE {
// OBSOLETE 
// OBSOLETE   if (which == 0)
// OBSOLETE     {
// OBSOLETE       /* Integer registers */
// OBSOLETE 
// OBSOLETE #define cd_regs(n) ((int *)core_reg_sect)[n]
// OBSOLETE #define regs(n) *((int *) &registers[REGISTER_BYTE (n)])
// OBSOLETE 
// OBSOLETE       int i;
// OBSOLETE       for (i = 0; i < FP0_REGNUM; i++)
// OBSOLETE 	regs (i) = cd_regs (core_regmap[i]);
// OBSOLETE     }
// OBSOLETE   else if (which == 2)
// OBSOLETE     {
// OBSOLETE       /* Floating point registers */
// OBSOLETE 
// OBSOLETE       if (core_reg_size >= sizeof (core_env387))
// OBSOLETE 	memcpy (&core_env387, core_reg_sect, core_reg_size);
// OBSOLETE       else
// OBSOLETE 	fprintf_unfiltered (gdb_stderr, "Couldn't read float regs from core file\n");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Register that we are able to handle i386aix core file formats.
// OBSOLETE    FIXME: is this really bfd_target_unknown_flavour? */
// OBSOLETE 
// OBSOLETE static struct core_fns i386aix_core_fns =
// OBSOLETE {
// OBSOLETE   bfd_target_unknown_flavour,		/* core_flavour */
// OBSOLETE   default_check_format,			/* check_format */
// OBSOLETE   default_core_sniffer,			/* core_sniffer */
// OBSOLETE   fetch_core_registers,			/* core_read_registers */
// OBSOLETE   NULL					/* next */
// OBSOLETE };
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_core_i386aix (void)
// OBSOLETE {
// OBSOLETE   add_core_fns (&i386aix_core_fns);
// OBSOLETE }
@


1.8
log
@* NEWS: Mention that the i[3456]-*-aix target has been made obsolete.
* configure.host: Make i[3456]86-*-aix host obsolete.
* configure.tgt: Make i[3456]86-*-aix target obsolete.
* config/i386/i386aix.mh, config/i386/i386aix.mt,
config/i386/nm-i386aix.h, condig/i386/tm-i386aix.h,
config/i386/xm-i386aix.h: Make files obsolete.
* i386aix-nat.c: Make file obsolete.
* Makefile.in (ALLDEPFILES): Remove i386aix-nat.c.
(i386aix-nat.o): Make target obsolete.
@
text
@@


1.8.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.8.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.7
log
@Phase 1 of the ptid_t changes.
@
text
@d1 377
a377 377
/* Intel 386 native support.
   Copyright 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
   2000, 2001 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "language.h"
#include "gdbcore.h"
#include "regcache.h"

#ifdef USG
#include <sys/types.h>
#endif

#include <sys/param.h>
#include <sys/dir.h>
#include <signal.h>
#include <sys/user.h>
#include <sys/ioctl.h>
#include <fcntl.h>

#include <sys/file.h>
#include "gdb_stat.h"

#include <stddef.h>
#include <sys/ptrace.h>

/* Does AIX define this in <errno.h>?  */
extern int errno;

#ifdef HAVE_SYS_REG_H
#include <sys/reg.h>
#endif

#include "floatformat.h"

#include "target.h"

static void fetch_core_registers (char *, unsigned, int, CORE_ADDR);


/* this table must line up with REGISTER_NAMES in tm-i386v.h */
/* symbols like 'EAX' come from <sys/reg.h> */
static int regmap[] =
{
  EAX, ECX, EDX, EBX,
  USP, EBP, ESI, EDI,
  EIP, EFL, CS, SS,
  DS, ES, FS, GS,
};

/* blockend is the value of u.u_ar0, and points to the
 * place where GS is stored
 */

int
i386_register_u_addr (int blockend, int regnum)
{
#if 0
  /* this will be needed if fp registers are reinstated */
  /* for now, you can look at them with 'info float'
   * sys5 wont let you change them with ptrace anyway
   */
  if (regnum >= FP0_REGNUM && regnum <= FP7_REGNUM)
    {
      int ubase, fpstate;
      struct user u;
      ubase = blockend + 4 * (SS + 1) - KSTKSZ;
      fpstate = ubase + ((char *) &u.u_fpstate - (char *) &u);
      return (fpstate + 0x1c + 10 * (regnum - FP0_REGNUM));
    }
  else
#endif
    return (blockend + 4 * regmap[regnum]);

}

/* The code below only work on the aix ps/2 (i386-ibm-aix) -
 * mtranle@@paris - Sat Apr 11 10:34:12 1992
 */

struct env387
{
  unsigned short control;
  unsigned short r0;
  unsigned short status;
  unsigned short r1;
  unsigned short tag;
  unsigned short r2;
  unsigned long eip;
  unsigned short code_seg;
  unsigned short opcode;
  unsigned long operand;
  unsigned short operand_seg;
  unsigned short r3;
  unsigned char regs[8][10];
};

static
print_387_status (unsigned short status, struct env387 *ep)
{
  int i;
  int bothstatus;
  int top;
  int fpreg;
  unsigned char *p;

  bothstatus = ((status != 0) && (ep->status != 0));
  if (status != 0)
    {
      if (bothstatus)
	printf_unfiltered ("u: ");
      print_387_status_word (status);
    }

  if (ep->status != 0)
    {
      if (bothstatus)
	printf_unfiltered ("e: ");
      print_387_status_word (ep->status);
    }

  print_387_control_word (ep->control);
  printf_unfiltered ("last exception: ");
  printf_unfiltered ("opcode %s; ", local_hex_string (ep->opcode));
  printf_unfiltered ("pc %s:", local_hex_string (ep->code_seg));
  printf_unfiltered ("%s; ", local_hex_string (ep->eip));
  printf_unfiltered ("operand %s", local_hex_string (ep->operand_seg));
  printf_unfiltered (":%s\n", local_hex_string (ep->operand));

  top = ((ep->status >> 11) & 7);

  printf_unfiltered ("regno  tag  msb              lsb  value\n");
  for (fpreg = 7; fpreg >= 0; fpreg--)
    {
      double val;

      printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg);

      switch ((ep->tag >> ((7 - fpreg) * 2)) & 3)
	{
	case 0:
	  printf_unfiltered ("valid ");
	  break;
	case 1:
	  printf_unfiltered ("zero  ");
	  break;
	case 2:
	  printf_unfiltered ("trap  ");
	  break;
	case 3:
	  printf_unfiltered ("empty ");
	  break;
	}
      for (i = 9; i >= 0; i--)
	printf_unfiltered ("%02x", ep->regs[fpreg][i]);

      i387_to_double ((char *) ep->regs[fpreg], (char *) &val);
      printf_unfiltered ("  %#g\n", val);
    }
}

static struct env387 core_env387;

void
i386_float_info (void)
{
  struct env387 fps;
  int fpsaved = 0;
  /* We need to reverse the order of the registers.  Apparently AIX stores
     the highest-numbered ones first.  */
  struct env387 fps_fixed;
  int i;

  if (! ptid_equal (inferior_ptid, null_ptid))
    {
      char buf[10];
      unsigned short status;

      ptrace (PT_READ_FPR, PIDGET (inferior_ptid), buf,
              offsetof (struct env387, status));
      memcpy (&status, buf, sizeof (status));
      fpsaved = status;
    }
  else
    {
      if ((fpsaved = core_env387.status) != 0)
	memcpy (&fps, &core_env387, sizeof (fps));
    }

  if (fpsaved == 0)
    {
      printf_unfiltered ("no floating point status saved\n");
      return;
    }

  if (! ptid_equal (inferior_ptid, null_ptid))
    {
      int offset;
      for (offset = 0; offset < sizeof (fps); offset += 10)
	{
	  char buf[10];
	  ptrace (PT_READ_FPR, PIDGET (inferior_ptid), buf, offset);
	  memcpy ((char *) &fps.control + offset, buf,
		  MIN (10, sizeof (fps) - offset));
	}
    }
  fps_fixed = fps;
  for (i = 0; i < 8; ++i)
    memcpy (fps_fixed.regs[i], fps.regs[7 - i], 10);
  print_387_status (0, &fps_fixed);
}

/* Fetch one register.  */
static void
fetch_register (int regno)
{
  char buf[MAX_REGISTER_RAW_SIZE];
  if (regno < FP0_REGNUM)
    *(int *) buf = ptrace (PT_READ_GPR, PIDGET (inferior_ptid),
			   PT_REG (regmap[regno]), 0, 0);
  else
    ptrace (PT_READ_FPR, PIDGET (inferior_ptid), buf,
	    (regno - FP0_REGNUM) * 10 + offsetof (struct env387, regs));
  supply_register (regno, buf);
}

void
fetch_inferior_registers (int regno)
{
  if (regno < 0)
    for (regno = 0; regno < NUM_REGS; regno++)
      fetch_register (regno);
  else
    fetch_register (regno);
}

/* store one register */
static void
store_register (int regno)
{
  char buf[80];
  errno = 0;
  if (regno < FP0_REGNUM)
    ptrace (PT_WRITE_GPR, PIDGET (inferior_ptid), PT_REG (regmap[regno]),
	    *(int *) &registers[REGISTER_BYTE (regno)], 0);
  else
    ptrace (PT_WRITE_FPR, PIDGET (inferior_ptid),
            &registers[REGISTER_BYTE (regno)],
	    (regno - FP0_REGNUM) * 10 + offsetof (struct env387, regs));

  if (errno != 0)
    {
      sprintf (buf, "writing register number %d", regno);
      perror_with_name (buf);
    }
}

/* Store our register values back into the inferior.
   If REGNO is -1, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time).  */
void
store_inferior_registers (int regno)
{
  if (regno < 0)
    for (regno = 0; regno < NUM_REGS; regno++)
      store_register (regno);
  else
    store_register (regno);
}

#ifndef CD_AX			/* defined in sys/i386/coredump.h */
#define CD_AX	0
#define CD_BX	1
#define CD_CX	2
#define CD_DX	3
#define CD_SI	4
#define CD_DI	5
#define CD_BP	6
#define CD_SP	7
#define CD_FL	8
#define CD_IP	9
#define CD_CS	10
#define CD_DS	11
#define CD_ES	12
#define CD_FS	13
#define CD_GS	14
#define CD_SS	15
#endif

/*
 * The order here in core_regmap[] has to be the same as in 
 * regmap[] above.
 */
static int core_regmap[] =
{
  CD_AX, CD_CX, CD_DX, CD_BX,
  CD_SP, CD_BP, CD_SI, CD_DI,
  CD_IP, CD_FL, CD_CS, CD_SS,
  CD_DS, CD_ES, CD_FS, CD_GS,
};

/* Provide registers to GDB from a core file.

   CORE_REG_SECT points to an array of bytes, which were obtained from
   a core file which BFD thinks might contain register contents. 
   CORE_REG_SIZE is its size.

   WHICH says which register set corelow suspects this is:
     0 --- the general-purpose register set
     2 --- the floating-point register set

   REG_ADDR isn't used.  */

static void
fetch_core_registers (char *core_reg_sect, unsigned core_reg_size,
		      int which, CORE_ADDR reg_addr)
{

  if (which == 0)
    {
      /* Integer registers */

#define cd_regs(n) ((int *)core_reg_sect)[n]
#define regs(n) *((int *) &registers[REGISTER_BYTE (n)])

      int i;
      for (i = 0; i < FP0_REGNUM; i++)
	regs (i) = cd_regs (core_regmap[i]);
    }
  else if (which == 2)
    {
      /* Floating point registers */

      if (core_reg_size >= sizeof (core_env387))
	memcpy (&core_env387, core_reg_sect, core_reg_size);
      else
	fprintf_unfiltered (gdb_stderr, "Couldn't read float regs from core file\n");
    }
}


/* Register that we are able to handle i386aix core file formats.
   FIXME: is this really bfd_target_unknown_flavour? */

static struct core_fns i386aix_core_fns =
{
  bfd_target_unknown_flavour,		/* core_flavour */
  default_check_format,			/* check_format */
  default_core_sniffer,			/* core_sniffer */
  fetch_core_registers,			/* core_read_registers */
  NULL					/* next */
};

void
_initialize_core_i386aix (void)
{
  add_core_fns (&i386aix_core_fns);
}
@


1.7.16.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d1 377
a377 377
// OBSOLETE /* Intel 386 native support.
// OBSOLETE    Copyright 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
// OBSOLETE    2000, 2001 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "language.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #ifdef USG
// OBSOLETE #include <sys/types.h>
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE #include <sys/param.h>
// OBSOLETE #include <sys/dir.h>
// OBSOLETE #include <signal.h>
// OBSOLETE #include <sys/user.h>
// OBSOLETE #include <sys/ioctl.h>
// OBSOLETE #include <fcntl.h>
// OBSOLETE 
// OBSOLETE #include <sys/file.h>
// OBSOLETE #include "gdb_stat.h"
// OBSOLETE 
// OBSOLETE #include <stddef.h>
// OBSOLETE #include <sys/ptrace.h>
// OBSOLETE 
// OBSOLETE /* Does AIX define this in <errno.h>?  */
// OBSOLETE extern int errno;
// OBSOLETE 
// OBSOLETE #ifdef HAVE_SYS_REG_H
// OBSOLETE #include <sys/reg.h>
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE #include "floatformat.h"
// OBSOLETE 
// OBSOLETE #include "target.h"
// OBSOLETE 
// OBSOLETE static void fetch_core_registers (char *, unsigned, int, CORE_ADDR);
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* this table must line up with REGISTER_NAMES in tm-i386v.h */
// OBSOLETE /* symbols like 'EAX' come from <sys/reg.h> */
// OBSOLETE static int regmap[] =
// OBSOLETE {
// OBSOLETE   EAX, ECX, EDX, EBX,
// OBSOLETE   USP, EBP, ESI, EDI,
// OBSOLETE   EIP, EFL, CS, SS,
// OBSOLETE   DS, ES, FS, GS,
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* blockend is the value of u.u_ar0, and points to the
// OBSOLETE  * place where GS is stored
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE i386_register_u_addr (int blockend, int regnum)
// OBSOLETE {
// OBSOLETE #if 0
// OBSOLETE   /* this will be needed if fp registers are reinstated */
// OBSOLETE   /* for now, you can look at them with 'info float'
// OBSOLETE    * sys5 wont let you change them with ptrace anyway
// OBSOLETE    */
// OBSOLETE   if (regnum >= FP0_REGNUM && regnum <= FP7_REGNUM)
// OBSOLETE     {
// OBSOLETE       int ubase, fpstate;
// OBSOLETE       struct user u;
// OBSOLETE       ubase = blockend + 4 * (SS + 1) - KSTKSZ;
// OBSOLETE       fpstate = ubase + ((char *) &u.u_fpstate - (char *) &u);
// OBSOLETE       return (fpstate + 0x1c + 10 * (regnum - FP0_REGNUM));
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE #endif
// OBSOLETE     return (blockend + 4 * regmap[regnum]);
// OBSOLETE 
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* The code below only work on the aix ps/2 (i386-ibm-aix) -
// OBSOLETE  * mtranle@@paris - Sat Apr 11 10:34:12 1992
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE struct env387
// OBSOLETE {
// OBSOLETE   unsigned short control;
// OBSOLETE   unsigned short r0;
// OBSOLETE   unsigned short status;
// OBSOLETE   unsigned short r1;
// OBSOLETE   unsigned short tag;
// OBSOLETE   unsigned short r2;
// OBSOLETE   unsigned long eip;
// OBSOLETE   unsigned short code_seg;
// OBSOLETE   unsigned short opcode;
// OBSOLETE   unsigned long operand;
// OBSOLETE   unsigned short operand_seg;
// OBSOLETE   unsigned short r3;
// OBSOLETE   unsigned char regs[8][10];
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static
// OBSOLETE print_387_status (unsigned short status, struct env387 *ep)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   int bothstatus;
// OBSOLETE   int top;
// OBSOLETE   int fpreg;
// OBSOLETE   unsigned char *p;
// OBSOLETE 
// OBSOLETE   bothstatus = ((status != 0) && (ep->status != 0));
// OBSOLETE   if (status != 0)
// OBSOLETE     {
// OBSOLETE       if (bothstatus)
// OBSOLETE 	printf_unfiltered ("u: ");
// OBSOLETE       print_387_status_word (status);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (ep->status != 0)
// OBSOLETE     {
// OBSOLETE       if (bothstatus)
// OBSOLETE 	printf_unfiltered ("e: ");
// OBSOLETE       print_387_status_word (ep->status);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   print_387_control_word (ep->control);
// OBSOLETE   printf_unfiltered ("last exception: ");
// OBSOLETE   printf_unfiltered ("opcode %s; ", local_hex_string (ep->opcode));
// OBSOLETE   printf_unfiltered ("pc %s:", local_hex_string (ep->code_seg));
// OBSOLETE   printf_unfiltered ("%s; ", local_hex_string (ep->eip));
// OBSOLETE   printf_unfiltered ("operand %s", local_hex_string (ep->operand_seg));
// OBSOLETE   printf_unfiltered (":%s\n", local_hex_string (ep->operand));
// OBSOLETE 
// OBSOLETE   top = ((ep->status >> 11) & 7);
// OBSOLETE 
// OBSOLETE   printf_unfiltered ("regno  tag  msb              lsb  value\n");
// OBSOLETE   for (fpreg = 7; fpreg >= 0; fpreg--)
// OBSOLETE     {
// OBSOLETE       double val;
// OBSOLETE 
// OBSOLETE       printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg);
// OBSOLETE 
// OBSOLETE       switch ((ep->tag >> ((7 - fpreg) * 2)) & 3)
// OBSOLETE 	{
// OBSOLETE 	case 0:
// OBSOLETE 	  printf_unfiltered ("valid ");
// OBSOLETE 	  break;
// OBSOLETE 	case 1:
// OBSOLETE 	  printf_unfiltered ("zero  ");
// OBSOLETE 	  break;
// OBSOLETE 	case 2:
// OBSOLETE 	  printf_unfiltered ("trap  ");
// OBSOLETE 	  break;
// OBSOLETE 	case 3:
// OBSOLETE 	  printf_unfiltered ("empty ");
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE       for (i = 9; i >= 0; i--)
// OBSOLETE 	printf_unfiltered ("%02x", ep->regs[fpreg][i]);
// OBSOLETE 
// OBSOLETE       i387_to_double ((char *) ep->regs[fpreg], (char *) &val);
// OBSOLETE       printf_unfiltered ("  %#g\n", val);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct env387 core_env387;
// OBSOLETE 
// OBSOLETE void
// OBSOLETE i386_float_info (void)
// OBSOLETE {
// OBSOLETE   struct env387 fps;
// OBSOLETE   int fpsaved = 0;
// OBSOLETE   /* We need to reverse the order of the registers.  Apparently AIX stores
// OBSOLETE      the highest-numbered ones first.  */
// OBSOLETE   struct env387 fps_fixed;
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   if (! ptid_equal (inferior_ptid, null_ptid))
// OBSOLETE     {
// OBSOLETE       char buf[10];
// OBSOLETE       unsigned short status;
// OBSOLETE 
// OBSOLETE       ptrace (PT_READ_FPR, PIDGET (inferior_ptid), buf,
// OBSOLETE               offsetof (struct env387, status));
// OBSOLETE       memcpy (&status, buf, sizeof (status));
// OBSOLETE       fpsaved = status;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       if ((fpsaved = core_env387.status) != 0)
// OBSOLETE 	memcpy (&fps, &core_env387, sizeof (fps));
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (fpsaved == 0)
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("no floating point status saved\n");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (! ptid_equal (inferior_ptid, null_ptid))
// OBSOLETE     {
// OBSOLETE       int offset;
// OBSOLETE       for (offset = 0; offset < sizeof (fps); offset += 10)
// OBSOLETE 	{
// OBSOLETE 	  char buf[10];
// OBSOLETE 	  ptrace (PT_READ_FPR, PIDGET (inferior_ptid), buf, offset);
// OBSOLETE 	  memcpy ((char *) &fps.control + offset, buf,
// OBSOLETE 		  MIN (10, sizeof (fps) - offset));
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   fps_fixed = fps;
// OBSOLETE   for (i = 0; i < 8; ++i)
// OBSOLETE     memcpy (fps_fixed.regs[i], fps.regs[7 - i], 10);
// OBSOLETE   print_387_status (0, &fps_fixed);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Fetch one register.  */
// OBSOLETE static void
// OBSOLETE fetch_register (int regno)
// OBSOLETE {
// OBSOLETE   char buf[MAX_REGISTER_RAW_SIZE];
// OBSOLETE   if (regno < FP0_REGNUM)
// OBSOLETE     *(int *) buf = ptrace (PT_READ_GPR, PIDGET (inferior_ptid),
// OBSOLETE 			   PT_REG (regmap[regno]), 0, 0);
// OBSOLETE   else
// OBSOLETE     ptrace (PT_READ_FPR, PIDGET (inferior_ptid), buf,
// OBSOLETE 	    (regno - FP0_REGNUM) * 10 + offsetof (struct env387, regs));
// OBSOLETE   supply_register (regno, buf);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fetch_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   if (regno < 0)
// OBSOLETE     for (regno = 0; regno < NUM_REGS; regno++)
// OBSOLETE       fetch_register (regno);
// OBSOLETE   else
// OBSOLETE     fetch_register (regno);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* store one register */
// OBSOLETE static void
// OBSOLETE store_register (int regno)
// OBSOLETE {
// OBSOLETE   char buf[80];
// OBSOLETE   errno = 0;
// OBSOLETE   if (regno < FP0_REGNUM)
// OBSOLETE     ptrace (PT_WRITE_GPR, PIDGET (inferior_ptid), PT_REG (regmap[regno]),
// OBSOLETE 	    *(int *) &registers[REGISTER_BYTE (regno)], 0);
// OBSOLETE   else
// OBSOLETE     ptrace (PT_WRITE_FPR, PIDGET (inferior_ptid),
// OBSOLETE             &registers[REGISTER_BYTE (regno)],
// OBSOLETE 	    (regno - FP0_REGNUM) * 10 + offsetof (struct env387, regs));
// OBSOLETE 
// OBSOLETE   if (errno != 0)
// OBSOLETE     {
// OBSOLETE       sprintf (buf, "writing register number %d", regno);
// OBSOLETE       perror_with_name (buf);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Store our register values back into the inferior.
// OBSOLETE    If REGNO is -1, do this for all registers.
// OBSOLETE    Otherwise, REGNO specifies which register (so we can save time).  */
// OBSOLETE void
// OBSOLETE store_inferior_registers (int regno)
// OBSOLETE {
// OBSOLETE   if (regno < 0)
// OBSOLETE     for (regno = 0; regno < NUM_REGS; regno++)
// OBSOLETE       store_register (regno);
// OBSOLETE   else
// OBSOLETE     store_register (regno);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #ifndef CD_AX			/* defined in sys/i386/coredump.h */
// OBSOLETE #define CD_AX	0
// OBSOLETE #define CD_BX	1
// OBSOLETE #define CD_CX	2
// OBSOLETE #define CD_DX	3
// OBSOLETE #define CD_SI	4
// OBSOLETE #define CD_DI	5
// OBSOLETE #define CD_BP	6
// OBSOLETE #define CD_SP	7
// OBSOLETE #define CD_FL	8
// OBSOLETE #define CD_IP	9
// OBSOLETE #define CD_CS	10
// OBSOLETE #define CD_DS	11
// OBSOLETE #define CD_ES	12
// OBSOLETE #define CD_FS	13
// OBSOLETE #define CD_GS	14
// OBSOLETE #define CD_SS	15
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * The order here in core_regmap[] has to be the same as in 
// OBSOLETE  * regmap[] above.
// OBSOLETE  */
// OBSOLETE static int core_regmap[] =
// OBSOLETE {
// OBSOLETE   CD_AX, CD_CX, CD_DX, CD_BX,
// OBSOLETE   CD_SP, CD_BP, CD_SI, CD_DI,
// OBSOLETE   CD_IP, CD_FL, CD_CS, CD_SS,
// OBSOLETE   CD_DS, CD_ES, CD_FS, CD_GS,
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* Provide registers to GDB from a core file.
// OBSOLETE 
// OBSOLETE    CORE_REG_SECT points to an array of bytes, which were obtained from
// OBSOLETE    a core file which BFD thinks might contain register contents. 
// OBSOLETE    CORE_REG_SIZE is its size.
// OBSOLETE 
// OBSOLETE    WHICH says which register set corelow suspects this is:
// OBSOLETE      0 --- the general-purpose register set
// OBSOLETE      2 --- the floating-point register set
// OBSOLETE 
// OBSOLETE    REG_ADDR isn't used.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE fetch_core_registers (char *core_reg_sect, unsigned core_reg_size,
// OBSOLETE 		      int which, CORE_ADDR reg_addr)
// OBSOLETE {
// OBSOLETE 
// OBSOLETE   if (which == 0)
// OBSOLETE     {
// OBSOLETE       /* Integer registers */
// OBSOLETE 
// OBSOLETE #define cd_regs(n) ((int *)core_reg_sect)[n]
// OBSOLETE #define regs(n) *((int *) &registers[REGISTER_BYTE (n)])
// OBSOLETE 
// OBSOLETE       int i;
// OBSOLETE       for (i = 0; i < FP0_REGNUM; i++)
// OBSOLETE 	regs (i) = cd_regs (core_regmap[i]);
// OBSOLETE     }
// OBSOLETE   else if (which == 2)
// OBSOLETE     {
// OBSOLETE       /* Floating point registers */
// OBSOLETE 
// OBSOLETE       if (core_reg_size >= sizeof (core_env387))
// OBSOLETE 	memcpy (&core_env387, core_reg_sect, core_reg_size);
// OBSOLETE       else
// OBSOLETE 	fprintf_unfiltered (gdb_stderr, "Couldn't read float regs from core file\n");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Register that we are able to handle i386aix core file formats.
// OBSOLETE    FIXME: is this really bfd_target_unknown_flavour? */
// OBSOLETE 
// OBSOLETE static struct core_fns i386aix_core_fns =
// OBSOLETE {
// OBSOLETE   bfd_target_unknown_flavour,		/* core_flavour */
// OBSOLETE   default_check_format,			/* check_format */
// OBSOLETE   default_core_sniffer,			/* core_sniffer */
// OBSOLETE   fetch_core_registers,			/* core_read_registers */
// OBSOLETE   NULL					/* next */
// OBSOLETE };
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_core_i386aix (void)
// OBSOLETE {
// OBSOLETE   add_core_fns (&i386aix_core_fns);
// OBSOLETE }
@


1.6
log
@Update/correct copyright notices.
@
text
@d193 1
a193 1
  if (inferior_pid)
d198 2
a199 1
      ptrace (PT_READ_FPR, inferior_pid, buf, offsetof (struct env387, status));
d215 1
a215 1
  if (inferior_pid)
d221 1
a221 1
	  ptrace (PT_READ_FPR, inferior_pid, buf, offset);
d238 1
a238 1
    *(int *) buf = ptrace (PT_READ_GPR, inferior_pid,
d241 1
a241 1
    ptrace (PT_READ_FPR, inferior_pid, buf,
d263 1
a263 1
    ptrace (PT_WRITE_GPR, inferior_pid, PT_REG (regmap[regno]),
d266 2
a267 1
    ptrace (PT_WRITE_FPR, inferior_pid, &registers[REGISTER_BYTE (regno)],
@


1.5
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1988, 1989, 1991, 1992, 2001 Free Software Foundation,
   Inc.
@


1.4
log
@Protoization.
@
text
@d2 2
a3 1
   Copyright (C) 1988, 1989, 1991, 1992 Free Software Foundation, Inc.
d27 1
@


1.3
log
@Protoization.
@
text
@d317 12
d330 2
a331 5
fetch_core_registers (core_reg_sect, core_reg_size, which, reg_addr)
     char *core_reg_sect;
     unsigned core_reg_size;
     int which;
     CORE_ADDR reg_addr;	/* ignored */
@


1.2
log
@PARAMS removal.
@
text
@d73 1
a73 3
i386_register_u_addr (blockend, regnum)
     int blockend;
     int regnum;
d116 1
a116 3
print_387_status (status, ep)
     unsigned short status;
     struct env387 *ep;
d182 1
a182 1
i386_float_info ()
d231 1
a231 2
fetch_register (regno)
     int regno;
d244 1
a244 2
fetch_inferior_registers (regno)
     int regno;
d255 1
a255 2
store_register (regno)
     int regno;
d277 1
a277 2
store_inferior_registers (regno)
     int regno;
d361 1
a361 1
_initialize_core_i386aix ()
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d55 2
a56 1
static void fetch_core_registers PARAMS ((char *, unsigned, int, CORE_ADDR));
a57 1

d60 1
a60 1
static int regmap[] = 
d82 1
a82 1
  if (regnum >= FP0_REGNUM && regnum <= FP7_REGNUM) 
d87 1
a87 1
      fpstate = ubase + ((char *)&u.u_fpstate - (char *)&u);
d89 1
a89 1
    } 
d93 1
a93 1
  
d100 1
a100 1
struct env387 
d127 1
a127 1
  
d129 1
a129 1
  if (status != 0) 
d135 2
a136 2
  
  if (ep->status != 0) 
d142 1
a142 1
  
d145 5
a149 5
  printf_unfiltered ("opcode %s; ", local_hex_string(ep->opcode));
  printf_unfiltered ("pc %s:", local_hex_string(ep->code_seg));
  printf_unfiltered ("%s; ", local_hex_string(ep->eip));
  printf_unfiltered ("operand %s", local_hex_string(ep->operand_seg));
  printf_unfiltered (":%s\n", local_hex_string(ep->operand));
d154 1
a154 1
  for (fpreg = 7; fpreg >= 0; fpreg--) 
d160 1
a160 1
      switch ((ep->tag >> ((7 - fpreg) * 2)) & 3) 
d162 12
a173 4
	case 0: printf_unfiltered ("valid "); break;
	case 1: printf_unfiltered ("zero  "); break;
	case 2: printf_unfiltered ("trap  "); break;
	case 3: printf_unfiltered ("empty "); break;
d177 2
a178 2
      
      i387_to_double ((char *)ep->regs[fpreg], (char *)&val);
d200 1
a200 1
      ptrace (PT_READ_FPR, inferior_pid, buf, offsetof(struct env387, status));
d207 1
a207 1
	memcpy(&fps, &core_env387, sizeof(fps));
d209 2
a210 2
  
  if (fpsaved == 0) 
d219 1
a219 1
      for (offset = 0; offset < sizeof(fps); offset += 10)
d223 2
a224 2
	  memcpy ((char *)&fps.control + offset, buf,
		  MIN(10, sizeof(fps) - offset));
d226 1
a226 1
    } 
d240 2
a241 2
    *(int *)buf = ptrace (PT_READ_GPR, inferior_pid,
			  PT_REG(regmap[regno]), 0, 0);
d244 1
a244 1
	    (regno - FP0_REGNUM)*10 + offsetof(struct env387, regs));
a264 1
  extern char registers[];
d267 1
a267 1
    ptrace (PT_WRITE_GPR, inferior_pid, PT_REG(regmap[regno]),
d271 1
a271 1
	    (regno - FP0_REGNUM)*10 + offsetof(struct env387, regs));
d295 16
a310 16
# define CD_AX	0
# define CD_BX	1
# define CD_CX	2
# define CD_DX	3
# define CD_SI	4
# define CD_DI	5
# define CD_BP	6
# define CD_SP	7
# define CD_FL	8
# define CD_IP	9
# define CD_CS	10
# define CD_DS	11
# define CD_ES	12
# define CD_FS	13
# define CD_GS	14
# define CD_SS	15
d317 1
a317 1
static int core_regmap[] = 
d342 1
a342 1
	regs(i) = cd_regs(core_regmap[i]);
d354 1
a355 1

d361 5
a365 3
  bfd_target_unknown_flavour,
  fetch_core_registers,
  NULL
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d256 1
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d55 1
a56 1

d59 1
a59 1
static int regmap[] =
d81 1
a81 1
  if (regnum >= FP0_REGNUM && regnum <= FP7_REGNUM)
d86 1
a86 1
      fpstate = ubase + ((char *) &u.u_fpstate - (char *) &u);
d88 1
a88 1
    }
d92 1
a92 1

d99 1
a99 1
struct env387
d126 1
a126 1

d128 1
a128 1
  if (status != 0)
d134 2
a135 2

  if (ep->status != 0)
d141 1
a141 1

d144 5
a148 5
  printf_unfiltered ("opcode %s; ", local_hex_string (ep->opcode));
  printf_unfiltered ("pc %s:", local_hex_string (ep->code_seg));
  printf_unfiltered ("%s; ", local_hex_string (ep->eip));
  printf_unfiltered ("operand %s", local_hex_string (ep->operand_seg));
  printf_unfiltered (":%s\n", local_hex_string (ep->operand));
d153 1
a153 1
  for (fpreg = 7; fpreg >= 0; fpreg--)
d159 1
a159 1
      switch ((ep->tag >> ((7 - fpreg) * 2)) & 3)
d161 4
a164 12
	case 0:
	  printf_unfiltered ("valid ");
	  break;
	case 1:
	  printf_unfiltered ("zero  ");
	  break;
	case 2:
	  printf_unfiltered ("trap  ");
	  break;
	case 3:
	  printf_unfiltered ("empty ");
	  break;
d168 2
a169 2

      i387_to_double ((char *) ep->regs[fpreg], (char *) &val);
d191 1
a191 1
      ptrace (PT_READ_FPR, inferior_pid, buf, offsetof (struct env387, status));
d198 1
a198 1
	memcpy (&fps, &core_env387, sizeof (fps));
d200 2
a201 2

  if (fpsaved == 0)
d210 1
a210 1
      for (offset = 0; offset < sizeof (fps); offset += 10)
d214 2
a215 2
	  memcpy ((char *) &fps.control + offset, buf,
		  MIN (10, sizeof (fps) - offset));
d217 1
a217 1
    }
d231 2
a232 2
    *(int *) buf = ptrace (PT_READ_GPR, inferior_pid,
			   PT_REG (regmap[regno]), 0, 0);
d235 1
a235 1
	    (regno - FP0_REGNUM) * 10 + offsetof (struct env387, regs));
d258 1
a258 1
    ptrace (PT_WRITE_GPR, inferior_pid, PT_REG (regmap[regno]),
d262 1
a262 1
	    (regno - FP0_REGNUM) * 10 + offsetof (struct env387, regs));
d286 16
a301 16
#define CD_AX	0
#define CD_BX	1
#define CD_CX	2
#define CD_DX	3
#define CD_SI	4
#define CD_DI	5
#define CD_BP	6
#define CD_SP	7
#define CD_FL	8
#define CD_IP	9
#define CD_CS	10
#define CD_DS	11
#define CD_ES	12
#define CD_FS	13
#define CD_GS	14
#define CD_SS	15
d308 1
a308 1
static int core_regmap[] =
d333 1
a333 1
	regs (i) = cd_regs (core_regmap[i]);
d345 1
a346 1

@


1.1.1.4
log
@import gdb-1999-10-04 snapshot
@
text
@d361 3
a363 5
  bfd_target_unknown_flavour,		/* core_flavour */
  default_check_format,			/* check_format */
  default_core_sniffer,			/* core_sniffer */
  fetch_core_registers,			/* core_read_registers */
  NULL					/* next */
@


