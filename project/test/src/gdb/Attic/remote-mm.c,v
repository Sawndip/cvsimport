head	1.14;
access;
symbols
	gdb_5_2_1-2002-07-23-release:1.13
	gdb_5_2-2002-04-29-release:1.13
	gdb_5_2-branch:1.13.0.2
	gdb_5_2-2002-03-03-branchpoint:1.13
	gdb_5_1_1-2002-01-24-release:1.12
	gdb_5_1_0_1-2002-01-03-release:1.12
	cygnus_cvs_20020108_pre:1.13
	gdb_5_1_0_1-2002-01-03-branchpoint:1.12
	gdb_5_1_0_1-2002-01-03-branch:1.12.0.8
	gdb_5_1-2001-11-21-release:1.12
	gdb_s390-2001-09-26-branch:1.12.0.6
	gdb_s390-2001-09-26-branchpoint:1.12
	gdb_5_1-2001-07-29-branch:1.12.0.4
	gdb_5_1-2001-07-29-branchpoint:1.12
	dberlin-typesystem-branch:1.12.0.2
	dberlin-typesystem-branchpoint:1.12
	gdb-post-ptid_t-2001-05-03:1.12
	gdb-pre-ptid_t-2001-05-03:1.11
	insight-precleanup-2001-01-01:1.5
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.14
date	2002.05.04.15.52.38;	author cagney;	state dead;
branches;
next	1.13;

1.13
date	2002.01.06.15.02.01;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.04.04.15.26;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.14.19.23.02;	author jtc;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.14.16.42.30;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.06.08.21.12;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.02.19.14.33;	author jtc;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.23.22.48.55;	author jtc;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.01.01.48;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.06.21.50.56;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.47;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.09.08;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.10.12.04.37.24;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.14
log
@* MAINTAINERS: Mark a29k as deleted.
* NEWS: Mention that a29k was removed.  Add OBSOLETE section.
Move new configurations to the top.
* configure.tgt: Remove a29k.
* config/a29k/tm-vx29k.h: Delete.
* config/a29k/vx29k.mt: Delete.
* config/a29k/tm-a29k.h: Delete.
* config/a29k/a29k-udi.mt: Delete.
* config/a29k/a29k.mt: Delete.
* a29k-tdep.c: Delete.
* remote-udi.c: Delete.
* remote-mm.c: Delete.
* remote-eb.c: Delete.
* remote-adapt.c: Delete.
* Makefile.in: Remove obsolete code.
* gdbserver/Makefile.in: Ditto.
* config/s390/s390x.mt: Ditto.
* config/s390/s390.mt: Ditto.
* config/sparc/sparclynx.mh: Ditto.
* config/sparc/linux.mh: Ditto.
* config/pa/hppaosf.mh: Ditto.
* config/pa/hppabsd.mh: Ditto.
* config/ns32k/nbsd.mt: Ditto.
* config/mips/vr5000.mt: Ditto.
* config/m68k/sun3os4.mh: Ditto.
* config/m68k/nbsd.mt: Ditto.
* config/m68k/m68klynx.mh: Ditto.
* config/m32r/m32r.mt: Ditto.
* config/i386/x86-64linux.mt: Ditto.
* config/i386/nbsdelf.mt: Ditto.
* config/i386/nbsd.mt: Ditto.
* config/i386/i386lynx.mh: Ditto.
@
text
@/* OBSOLETE /* Remote debugging interface for Am290*0 running MiniMON monitor, for GDB. */
/* OBSOLETE    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, */
/* OBSOLETE    2001 Free Software Foundation, Inc. */
/* OBSOLETE    Originally written by Daniel Mann at AMD. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE /* This is like remote.c but ecpects MiniMON to be running on the Am29000  */
/* OBSOLETE    target hardware. */
/* OBSOLETE    - David Wood (wood@@lab.ultra.nyu.edu) at New York University adapted this */
/* OBSOLETE    file to gdb 3.95.  I was unable to get this working on sun3os4 */
/* OBSOLETE    with termio, only with sgtty.  Because we are only attempting to */
/* OBSOLETE    use this module to debug our kernel, which is already loaded when */
/* OBSOLETE    gdb is started up, I did not code up the file downloading facilities.   */
/* OBSOLETE    As a result this module has only the stubs to download files.  */
/* OBSOLETE    You should get tagged at compile time if you need to make any  */
/* OBSOLETE    changes/additions.  */ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "inferior.h" */
/* OBSOLETE #include "value.h" */
/* OBSOLETE #include <ctype.h> */
/* OBSOLETE #include <fcntl.h> */
/* OBSOLETE #include <signal.h> */
/* OBSOLETE #include <errno.h> */
/* OBSOLETE #include "gdb_string.h" */
/* OBSOLETE #include "terminal.h" */
/* OBSOLETE #include "minimon.h" */
/* OBSOLETE #include "target.h" */
/* OBSOLETE #include "regcache.h" */
/* OBSOLETE  */
/* OBSOLETE /* Offset of member MEMBER in a struct of type TYPE.  */ */
/* OBSOLETE #define offsetof(TYPE, MEMBER) ((int) &((TYPE *)0)->MEMBER) */
/* OBSOLETE  */
/* OBSOLETE #define DRAIN_INPUT()	(msg_recv_serial((union msg_t*)0)) */
/* OBSOLETE  */
/* OBSOLETE extern int stop_soon_quietly;	/* for wait_for_inferior */ */
/* OBSOLETE  */
/* OBSOLETE static void mm_resume (ptid_t ptid, int step, enum target_signal sig) */
/* OBSOLETE static void mm_fetch_registers (); */
/* OBSOLETE static int fetch_register (); */
/* OBSOLETE static void mm_store_registers (); */
/* OBSOLETE static int store_register (); */
/* OBSOLETE static int regnum_to_srnum (); */
/* OBSOLETE static void mm_close (); */
/* OBSOLETE static char *msg_str (); */
/* OBSOLETE static char *error_msg_str (); */
/* OBSOLETE static int expect_msg (); */
/* OBSOLETE static void init_target_mm (); */
/* OBSOLETE static int mm_memory_space (); */
/* OBSOLETE  */
/* OBSOLETE #define FREEZE_MODE     (read_register(CPS_REGNUM) && 0x400) */
/* OBSOLETE #define USE_SHADOW_PC	((processor_type == a29k_freeze_mode) && FREEZE_MODE) */
/* OBSOLETE  */
/* OBSOLETE /* FIXME: Replace with `set remotedebug'.  */ */
/* OBSOLETE #define LLOG_FILE "minimon.log" */
/* OBSOLETE #if defined (LOG_FILE) */
/* OBSOLETE FILE *log_file; */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE /*   */
/* OBSOLETE  * Size of message buffers.  I couldn't get memory reads to work when */
/* OBSOLETE  * the byte_count was larger than 512 (it may be a baud rate problem). */
/* OBSOLETE  */ */
/* OBSOLETE #define BUFER_SIZE  512 */
/* OBSOLETE /*  */
/* OBSOLETE  * Size of data area in message buffer on the TARGET (remote system). */
/* OBSOLETE  */ */
/* OBSOLETE #define MAXDATA_T  (target_config.max_msg_size - \ */
/* OBSOLETE 			offsetof(struct write_r_msg_t,data[0])) */
/* OBSOLETE /*                */
/* OBSOLETE  * Size of data area in message buffer on the HOST (gdb).  */
/* OBSOLETE  */ */
/* OBSOLETE #define MAXDATA_H  (BUFER_SIZE - offsetof(struct write_r_msg_t,data[0])) */
/* OBSOLETE /*  */
/* OBSOLETE  * Defined as the minimum size of data areas of the two message buffers  */
/* OBSOLETE  */ */
/* OBSOLETE #define MAXDATA	   (MAXDATA_H < MAXDATA_T ? MAXDATA_H : MAXDATA_T) */
/* OBSOLETE  */
/* OBSOLETE static char out_buf[BUFER_SIZE]; */
/* OBSOLETE static char in_buf[BUFER_SIZE]; */
/* OBSOLETE  */
/* OBSOLETE int msg_recv_serial (); */
/* OBSOLETE int msg_send_serial (); */
/* OBSOLETE  */
/* OBSOLETE #define MAX_RETRIES 5000 */
/* OBSOLETE extern struct target_ops mm_ops;	/* Forward declaration */ */
/* OBSOLETE struct config_msg_t target_config;	/* HIF needs this */ */
/* OBSOLETE union msg_t *out_msg_buf = (union msg_t *) out_buf; */
/* OBSOLETE union msg_t *in_msg_buf = (union msg_t *) in_buf; */
/* OBSOLETE  */
/* OBSOLETE static int timeout = 5; */
/* OBSOLETE  */
/* OBSOLETE /* Descriptor for I/O to remote machine.  Initialize it to -1 so that */
/* OBSOLETE    mm_open knows that we don't have a file open when the program */
/* OBSOLETE    starts.  */ */
/* OBSOLETE int mm_desc = -1; */
/* OBSOLETE  */
/* OBSOLETE /* stream which is fdopen'd from mm_desc.  Only valid when */
/* OBSOLETE    mm_desc != -1.  */ */
/* OBSOLETE FILE *mm_stream; */
/* OBSOLETE  */
/* OBSOLETE /* Called when SIGALRM signal sent due to alarm() timeout.  */ */
/* OBSOLETE #ifndef HAVE_TERMIO */
/* OBSOLETE  */
/* OBSOLETE volatile int n_alarms; */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE mm_timer (void) */
/* OBSOLETE { */
/* OBSOLETE #if 0 */
/* OBSOLETE   if (kiodebug) */
/* OBSOLETE     printf ("mm_timer called\n"); */
/* OBSOLETE #endif */
/* OBSOLETE   n_alarms++; */
/* OBSOLETE } */
/* OBSOLETE #endif	/* HAVE_TERMIO */ */
/* OBSOLETE  */
/* OBSOLETE /* malloc'd name of the program on the remote system.  */ */
/* OBSOLETE static char *prog_name = NULL; */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Number of SIGTRAPs we need to simulate.  That is, the next */
/* OBSOLETE    NEED_ARTIFICIAL_TRAP calls to mm_wait should just return */
/* OBSOLETE    SIGTRAP without actually waiting for anything.  */ */
/* OBSOLETE  */
/* OBSOLETE /**************************************************** REMOTE_CREATE_INFERIOR */ */
/* OBSOLETE /* This is called not only when we first attach, but also when the */
/* OBSOLETE    user types "run" after having attached.  */ */
/* OBSOLETE static void */
/* OBSOLETE mm_create_inferior (char *execfile, char *args, char **env) */
/* OBSOLETE { */
/* OBSOLETE #define MAX_TOKENS 25 */
/* OBSOLETE #define BUFFER_SIZE 256 */
/* OBSOLETE   int token_count; */
/* OBSOLETE   int result; */
/* OBSOLETE   char *token[MAX_TOKENS]; */
/* OBSOLETE   char cmd_line[BUFFER_SIZE]; */
/* OBSOLETE  */
/* OBSOLETE   if (args && *args) */
/* OBSOLETE     error ("Can't pass arguments to remote mm process (yet)."); */
/* OBSOLETE  */
/* OBSOLETE   if (execfile == 0 /* || exec_bfd == 0 */ ) */
/* OBSOLETE     error ("No executable file specified"); */
/* OBSOLETE  */
/* OBSOLETE   if (!mm_stream) */
/* OBSOLETE     { */
/* OBSOLETE       printf ("Minimon not open yet.\n"); */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* On ultra3 (NYU) we assume the kernel is already running so there is */
/* OBSOLETE      no file to download. */
/* OBSOLETE      FIXME: Fixed required here -> load your program, possibly with mm_load(). */
/* OBSOLETE    */ */
/* OBSOLETE   printf_filtered ("\n\ */
/* OBSOLETE Assuming you are at NYU debuging a kernel, i.e., no need to download.\n\n"); */
/* OBSOLETE  */
/* OBSOLETE   /* We will get a task spawn event immediately.  */ */
/* OBSOLETE   init_wait_for_inferior (); */
/* OBSOLETE   clear_proceed_status (); */
/* OBSOLETE   stop_soon_quietly = 1; */
/* OBSOLETE   proceed (-1, TARGET_SIGNAL_DEFAULT, 0); */
/* OBSOLETE   normal_stop (); */
/* OBSOLETE } */
/* OBSOLETE /**************************************************** REMOTE_MOURN_INFERIOR */ */
/* OBSOLETE static void */
/* OBSOLETE mm_mourn (void) */
/* OBSOLETE { */
/* OBSOLETE   pop_target ();		/* Pop back to no-child state */ */
/* OBSOLETE   generic_mourn_inferior (); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /********************************************************************** damn_b */
/* OBSOLETE */ */
/* OBSOLETE /* Translate baud rates from integers to damn B_codes.  Unix should */
/* OBSOLETE    have outgrown this crap years ago, but even POSIX wouldn't buck it.  */ */
/* OBSOLETE  */
/* OBSOLETE #ifndef B19200 */
/* OBSOLETE #define B19200 EXTA */
/* OBSOLETE #endif */
/* OBSOLETE #ifndef B38400 */
/* OBSOLETE #define B38400 EXTB */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE static struct */
/* OBSOLETE { */
/* OBSOLETE   int rate, damn_b; */
/* OBSOLETE } */
/* OBSOLETE baudtab[] = */
/* OBSOLETE { */
/* OBSOLETE   { */
/* OBSOLETE     0, B0 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     50, B50 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     75, B75 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     110, B110 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     134, B134 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     150, B150 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     200, B200 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     300, B300 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     600, B600 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     1200, B1200 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     1800, B1800 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     2400, B2400 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     4800, B4800 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     9600, B9600 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     19200, B19200 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     38400, B38400 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     -1, -1 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE damn_b (int rate) */
/* OBSOLETE { */
/* OBSOLETE   int i; */
/* OBSOLETE  */
/* OBSOLETE   for (i = 0; baudtab[i].rate != -1; i++) */
/* OBSOLETE     if (rate == baudtab[i].rate) */
/* OBSOLETE       return baudtab[i].damn_b; */
/* OBSOLETE   return B38400;		/* Random */ */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /***************************************************************** REMOTE_OPEN */
/* OBSOLETE ** Open a connection to remote minimon. */
/* OBSOLETE    NAME is the filename used for communication, then a space, */
/* OBSOLETE    then the baud rate. */
/* OBSOLETE    'target adapt /dev/ttya 9600 [prognam]' for example. */
/* OBSOLETE  */ */
/* OBSOLETE  */
/* OBSOLETE static char *dev_name; */
/* OBSOLETE int baudrate = 9600; */
/* OBSOLETE static void */
/* OBSOLETE mm_open (char *name, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   TERMINAL sg; */
/* OBSOLETE   unsigned int prl; */
/* OBSOLETE   char *p; */
/* OBSOLETE  */
/* OBSOLETE   /* Find the first whitespace character, it separates dev_name from */
/* OBSOLETE      prog_name.  */ */
/* OBSOLETE   for (p = name; */
/* OBSOLETE        p && *p && !isspace (*p); p++) */
/* OBSOLETE     ; */
/* OBSOLETE   if (p == 0 || *p == '\0') */
/* OBSOLETE   erroid: */
/* OBSOLETE     error ("Usage : <command> <serial-device> <baud-rate> [progname]"); */
/* OBSOLETE   dev_name = (char *) xmalloc (p - name + 1); */
/* OBSOLETE   strncpy (dev_name, name, p - name); */
/* OBSOLETE   dev_name[p - name] = '\0'; */
/* OBSOLETE  */
/* OBSOLETE   /* Skip over the whitespace after dev_name */ */
/* OBSOLETE   for (; isspace (*p); p++) */
/* OBSOLETE     /*EMPTY */ ; */
/* OBSOLETE  */
/* OBSOLETE   if (1 != sscanf (p, "%d ", &baudrate)) */
/* OBSOLETE     goto erroid; */
/* OBSOLETE  */
/* OBSOLETE   /* Skip the number and then the spaces */ */
/* OBSOLETE   for (; isdigit (*p); p++) */
/* OBSOLETE     /*EMPTY */ ; */
/* OBSOLETE   for (; isspace (*p); p++) */
/* OBSOLETE     /*EMPTY */ ; */
/* OBSOLETE  */
/* OBSOLETE   if (prog_name != NULL) */
/* OBSOLETE     xfree (prog_name); */
/* OBSOLETE   prog_name = savestring (p, strlen (p)); */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE   if (mm_desc >= 0) */
/* OBSOLETE     close (mm_desc); */
/* OBSOLETE  */
/* OBSOLETE   mm_desc = open (dev_name, O_RDWR); */
/* OBSOLETE   if (mm_desc < 0) */
/* OBSOLETE     perror_with_name (dev_name); */
/* OBSOLETE   ioctl (mm_desc, TIOCGETP, &sg); */
/* OBSOLETE #ifdef HAVE_TERMIO */
/* OBSOLETE   sg.c_cc[VMIN] = 0;		/* read with timeout.  */ */
/* OBSOLETE   sg.c_cc[VTIME] = timeout * 10; */
/* OBSOLETE   sg.c_lflag &= ~(ICANON | ECHO); */
/* OBSOLETE   sg.c_cflag = (sg.c_cflag & ~CBAUD) | damn_b (baudrate); */
/* OBSOLETE #else */
/* OBSOLETE   sg.sg_ispeed = damn_b (baudrate); */
/* OBSOLETE   sg.sg_ospeed = damn_b (baudrate); */
/* OBSOLETE   sg.sg_flags |= RAW; */
/* OBSOLETE   sg.sg_flags |= ANYP; */
/* OBSOLETE   sg.sg_flags &= ~ECHO; */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE   ioctl (mm_desc, TIOCSETP, &sg); */
/* OBSOLETE   mm_stream = fdopen (mm_desc, "r+"); */
/* OBSOLETE  */
/* OBSOLETE   push_target (&mm_ops); */
/* OBSOLETE  */
/* OBSOLETE #ifndef HAVE_TERMIO */
/* OBSOLETE #ifndef NO_SIGINTERRUPT */
/* OBSOLETE   /* Cause SIGALRM's to make reads fail with EINTR instead of resuming */
/* OBSOLETE      the read.  */ */
/* OBSOLETE   if (siginterrupt (SIGALRM, 1) != 0) */
/* OBSOLETE     perror ("mm_open: error in siginterrupt"); */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE   /* Set up read timeout timer.  */ */
/* OBSOLETE   if ((void (*)) signal (SIGALRM, mm_timer) == (void (*)) -1) */
/* OBSOLETE     perror ("mm_open: error in signal"); */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE #if defined (LOG_FILE) */
/* OBSOLETE   log_file = fopen (LOG_FILE, "w"); */
/* OBSOLETE   if (log_file == NULL) */
/* OBSOLETE     perror_with_name (LOG_FILE); */
/* OBSOLETE #endif */
/* OBSOLETE   /* */
/* OBSOLETE      ** Initialize target configuration structure (global) */
/* OBSOLETE    */ */
/* OBSOLETE   DRAIN_INPUT (); */
/* OBSOLETE   out_msg_buf->config_req_msg.code = CONFIG_REQ; */
/* OBSOLETE   out_msg_buf->config_req_msg.length = 4 * 0; */
/* OBSOLETE   msg_send_serial (out_msg_buf);	/* send config request message */ */
/* OBSOLETE  */
/* OBSOLETE   expect_msg (CONFIG, in_msg_buf, 1); */
/* OBSOLETE  */
/* OBSOLETE   a29k_get_processor_type (); */
/* OBSOLETE  */
/* OBSOLETE   /* Print out some stuff, letting the user now what's going on */ */
/* OBSOLETE   printf_filtered ("Connected to MiniMon via %s.\n", dev_name); */
/* OBSOLETE   /* FIXME: can this restriction be removed? */ */
/* OBSOLETE   printf_filtered ("Remote debugging using virtual addresses works only\n"); */
/* OBSOLETE   printf_filtered ("\twhen virtual addresses map 1:1 to physical addresses.\n") */
/* OBSOLETE     ; */
/* OBSOLETE   if (processor_type != a29k_freeze_mode) */
/* OBSOLETE     { */
/* OBSOLETE       fprintf_filtered (gdb_stderr, */
/* OBSOLETE 			"Freeze-mode debugging not available, and can only be done on an A29050.\n"); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   target_config.code = CONFIG; */
/* OBSOLETE   target_config.length = 0; */
/* OBSOLETE   target_config.processor_id = in_msg_buf->config_msg.processor_id; */
/* OBSOLETE   target_config.version = in_msg_buf->config_msg.version; */
/* OBSOLETE   target_config.I_mem_start = in_msg_buf->config_msg.I_mem_start; */
/* OBSOLETE   target_config.I_mem_size = in_msg_buf->config_msg.I_mem_size; */
/* OBSOLETE   target_config.D_mem_start = in_msg_buf->config_msg.D_mem_start; */
/* OBSOLETE   target_config.D_mem_size = in_msg_buf->config_msg.D_mem_size; */
/* OBSOLETE   target_config.ROM_start = in_msg_buf->config_msg.ROM_start; */
/* OBSOLETE   target_config.ROM_size = in_msg_buf->config_msg.ROM_size; */
/* OBSOLETE   target_config.max_msg_size = in_msg_buf->config_msg.max_msg_size; */
/* OBSOLETE   target_config.max_bkpts = in_msg_buf->config_msg.max_bkpts; */
/* OBSOLETE   target_config.coprocessor = in_msg_buf->config_msg.coprocessor; */
/* OBSOLETE   target_config.reserved = in_msg_buf->config_msg.reserved; */
/* OBSOLETE   if (from_tty) */
/* OBSOLETE     { */
/* OBSOLETE       printf ("Connected to MiniMON :\n"); */
/* OBSOLETE       printf ("    Debugcore version            %d.%d\n", */
/* OBSOLETE 	      0x0f & (target_config.version >> 4), */
/* OBSOLETE 	      0x0f & (target_config.version)); */
/* OBSOLETE       printf ("    Configuration version        %d.%d\n", */
/* OBSOLETE 	      0x0f & (target_config.version >> 12), */
/* OBSOLETE 	      0x0f & (target_config.version >> 8)); */
/* OBSOLETE       printf ("    Message system version       %d.%d\n", */
/* OBSOLETE 	      0x0f & (target_config.version >> 20), */
/* OBSOLETE 	      0x0f & (target_config.version >> 16)); */
/* OBSOLETE       printf ("    Communication driver version %d.%d\n", */
/* OBSOLETE 	      0x0f & (target_config.version >> 28), */
/* OBSOLETE 	      0x0f & (target_config.version >> 24)); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Leave the target running...  */
/* OBSOLETE    * The above message stopped the target in the dbg core (MiniMon),   */
/* OBSOLETE    * so restart the target out of MiniMon,  */
/* OBSOLETE    */ */
/* OBSOLETE   out_msg_buf->go_msg.code = GO; */
/* OBSOLETE   out_msg_buf->go_msg.length = 0; */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   /* No message to expect after a GO */ */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /**************************************************************** REMOTE_CLOSE */
/* OBSOLETE ** Close the open connection to the minimon debugger. */
/* OBSOLETE    Use this when you want to detach and do something else */
/* OBSOLETE    with your gdb.  */ */
/* OBSOLETE static void */
/* OBSOLETE mm_close (			/*FIXME: how is quitting used */ */
/* OBSOLETE 	   int quitting) */
/* OBSOLETE { */
/* OBSOLETE   if (mm_desc < 0) */
/* OBSOLETE     error ("Can't close remote connection: not debugging remotely."); */
/* OBSOLETE  */
/* OBSOLETE   /* We should never get here if there isn't something valid in */
/* OBSOLETE      mm_desc and mm_stream.   */
/* OBSOLETE  */
/* OBSOLETE      Due to a bug in Unix, fclose closes not only the stdio stream, */
/* OBSOLETE      but also the file descriptor.  So we don't actually close */
/* OBSOLETE      mm_desc.  */ */
/* OBSOLETE   DRAIN_INPUT (); */
/* OBSOLETE   fclose (mm_stream); */
/* OBSOLETE   /* close (mm_desc); */ */
/* OBSOLETE  */
/* OBSOLETE   /* Do not try to close mm_desc again, later in the program.  */ */
/* OBSOLETE   mm_stream = NULL; */
/* OBSOLETE   mm_desc = -1; */
/* OBSOLETE  */
/* OBSOLETE #if defined (LOG_FILE) */
/* OBSOLETE   if (ferror (log_file)) */
/* OBSOLETE     printf ("Error writing log file.\n"); */
/* OBSOLETE   if (fclose (log_file) != 0) */
/* OBSOLETE     printf ("Error closing log file.\n"); */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE   printf ("Ending remote debugging\n"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /************************************************************* REMOTE_ATACH */ */
/* OBSOLETE /* Attach to a program that is already loaded and running  */
/* OBSOLETE  * Upon exiting the process's execution is stopped. */
/* OBSOLETE  */ */
/* OBSOLETE static void */
/* OBSOLETE mm_attach (char *args, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE  */
/* OBSOLETE   if (!mm_stream) */
/* OBSOLETE     error ("MiniMon not opened yet, use the 'target minimon' command.\n"); */
/* OBSOLETE  */
/* OBSOLETE   if (from_tty) */
/* OBSOLETE     printf ("Attaching to remote program %s...\n", prog_name); */
/* OBSOLETE  */
/* OBSOLETE   /* Make sure the target is currently running, it is supposed to be. */ */
/* OBSOLETE   /* FIXME: is it ok to send MiniMon a BREAK if it is already stopped in  */
/* OBSOLETE    *  the dbg core.  If so, we don't need to send this GO. */
/* OBSOLETE    */ */
/* OBSOLETE   out_msg_buf->go_msg.code = GO; */
/* OBSOLETE   out_msg_buf->go_msg.length = 0; */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   sleep (2);			/* At the worst it will stop, receive a message, continue */ */
/* OBSOLETE  */
/* OBSOLETE   /* Send the mm a break. */ */
/* OBSOLETE   out_msg_buf->break_msg.code = BREAK; */
/* OBSOLETE   out_msg_buf->break_msg.length = 0; */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE } */
/* OBSOLETE /********************************************************** REMOTE_DETACH */ */
/* OBSOLETE /* Terminate the open connection to the remote debugger. */
/* OBSOLETE    Use this when you want to detach and do something else */
/* OBSOLETE    with your gdb.  Leave remote process running (with no breakpoints set). */ */
/* OBSOLETE static void */
/* OBSOLETE mm_detach (char *args, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   remove_breakpoints ();	/* Just in case there were any left in */ */
/* OBSOLETE   out_msg_buf->go_msg.code = GO; */
/* OBSOLETE   out_msg_buf->go_msg.length = 0; */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   pop_target ();		/* calls mm_close to do the real work */ */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /*************************************************************** REMOTE_RESUME */
/* OBSOLETE ** Tell the remote machine to resume.  */ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE mm_resume (ptid_t ptid, int step, enum target_signal sig) */
/* OBSOLETE { */
/* OBSOLETE   if (sig != TARGET_SIGNAL_0) */
/* OBSOLETE     warning ("Can't send signals to a remote MiniMon system."); */
/* OBSOLETE  */
/* OBSOLETE   if (step) */
/* OBSOLETE     { */
/* OBSOLETE       out_msg_buf->step_msg.code = STEP; */
/* OBSOLETE       out_msg_buf->step_msg.length = 1 * 4; */
/* OBSOLETE       out_msg_buf->step_msg.count = 1;	/* step 1 instruction */ */
/* OBSOLETE       msg_send_serial (out_msg_buf); */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       out_msg_buf->go_msg.code = GO; */
/* OBSOLETE       out_msg_buf->go_msg.length = 0; */
/* OBSOLETE       msg_send_serial (out_msg_buf); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /***************************************************************** REMOTE_WAIT */
/* OBSOLETE ** Wait until the remote machine stops, then return, */
/* OBSOLETE    storing status in STATUS just as `wait' would.  */ */
/* OBSOLETE  */
/* OBSOLETE static ptid_t */
/* OBSOLETE mm_wait (ptid_t ptid, struct target_waitstatus *status) */
/* OBSOLETE { */
/* OBSOLETE   int i, result; */
/* OBSOLETE   int old_timeout = timeout; */
/* OBSOLETE   int old_immediate_quit = immediate_quit; */
/* OBSOLETE  */
/* OBSOLETE   status->kind = TARGET_WAITKIND_EXITED; */
/* OBSOLETE   status->value.integer = 0; */
/* OBSOLETE  */
/* OBSOLETE /* wait for message to arrive. It should be: */
/* OBSOLETE    - A HIF service request. */
/* OBSOLETE    - A HIF exit service request. */
/* OBSOLETE    - A CHANNEL0_ACK. */
/* OBSOLETE    - A CHANNEL1 request. */
/* OBSOLETE    - a debugcore HALT message. */
/* OBSOLETE    HIF services must be responded too, and while-looping continued. */
/* OBSOLETE    If the target stops executing, mm_wait() should return. */
/* OBSOLETE  */ */
/* OBSOLETE   timeout = 0;			/* Wait indefinetly for a message */ */
/* OBSOLETE   immediate_quit = 1;		/* Helps ability to QUIT */ */
/* OBSOLETE   while (1) */
/* OBSOLETE     { */
/* OBSOLETE       while (msg_recv_serial (in_msg_buf)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  QUIT;			/* Let user quit if they want */ */
/* OBSOLETE 	} */
/* OBSOLETE       switch (in_msg_buf->halt_msg.code) */
/* OBSOLETE 	{ */
/* OBSOLETE 	case HIF_CALL: */
/* OBSOLETE 	  i = in_msg_buf->hif_call_rtn_msg.service_number; */
/* OBSOLETE 	  result = service_HIF (in_msg_buf); */
/* OBSOLETE 	  if (i == 1)		/* EXIT */ */
/* OBSOLETE 	    goto exit; */
/* OBSOLETE 	  if (result) */
/* OBSOLETE 	    printf ("Warning: failure during HIF service %d\n", i); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case CHANNEL0_ACK: */
/* OBSOLETE 	  service_HIF (in_msg_buf); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case CHANNEL1: */
/* OBSOLETE 	  i = in_msg_buf->channel1_msg.length; */
/* OBSOLETE 	  in_msg_buf->channel1_msg.data[i] = '\0'; */
/* OBSOLETE 	  printf ("%s", in_msg_buf->channel1_msg.data); */
/* OBSOLETE 	  gdb_flush (gdb_stdout); */
/* OBSOLETE 	  /* Send CHANNEL1_ACK message */ */
/* OBSOLETE 	  out_msg_buf->channel1_ack_msg.code = CHANNEL1_ACK; */
/* OBSOLETE 	  out_msg_buf->channel1_ack_msg.length = 0; */
/* OBSOLETE 	  result = msg_send_serial (out_msg_buf); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case HALT: */
/* OBSOLETE 	  goto halted; */
/* OBSOLETE 	default: */
/* OBSOLETE 	  goto halted; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE halted: */
/* OBSOLETE   /* FIXME, these printfs should not be here.  This is a source level  */
/* OBSOLETE      debugger, guys!  */ */
/* OBSOLETE   if (in_msg_buf->halt_msg.trap_number == 0) */
/* OBSOLETE     { */
/* OBSOLETE       printf ("Am290*0 received vector number %d (break point)\n", */
/* OBSOLETE 	      in_msg_buf->halt_msg.trap_number); */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_TRAP; */
/* OBSOLETE     } */
/* OBSOLETE   else if (in_msg_buf->halt_msg.trap_number == 1) */
/* OBSOLETE     { */
/* OBSOLETE       printf ("Am290*0 received vector number %d\n", */
/* OBSOLETE 	      in_msg_buf->halt_msg.trap_number); */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_BUS; */
/* OBSOLETE     } */
/* OBSOLETE   else if (in_msg_buf->halt_msg.trap_number == 3 */
/* OBSOLETE 	   || in_msg_buf->halt_msg.trap_number == 4) */
/* OBSOLETE     { */
/* OBSOLETE       printf ("Am290*0 received vector number %d\n", */
/* OBSOLETE 	      in_msg_buf->halt_msg.trap_number); */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_FPE; */
/* OBSOLETE     } */
/* OBSOLETE   else if (in_msg_buf->halt_msg.trap_number == 5) */
/* OBSOLETE     { */
/* OBSOLETE       printf ("Am290*0 received vector number %d\n", */
/* OBSOLETE 	      in_msg_buf->halt_msg.trap_number); */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_ILL; */
/* OBSOLETE     } */
/* OBSOLETE   else if (in_msg_buf->halt_msg.trap_number >= 6 */
/* OBSOLETE 	   && in_msg_buf->halt_msg.trap_number <= 11) */
/* OBSOLETE     { */
/* OBSOLETE       printf ("Am290*0 received vector number %d\n", */
/* OBSOLETE 	      in_msg_buf->halt_msg.trap_number); */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_SEGV; */
/* OBSOLETE     } */
/* OBSOLETE   else if (in_msg_buf->halt_msg.trap_number == 12 */
/* OBSOLETE 	   || in_msg_buf->halt_msg.trap_number == 13) */
/* OBSOLETE     { */
/* OBSOLETE       printf ("Am290*0 received vector number %d\n", */
/* OBSOLETE 	      in_msg_buf->halt_msg.trap_number); */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_ILL; */
/* OBSOLETE     } */
/* OBSOLETE   else if (in_msg_buf->halt_msg.trap_number == 14) */
/* OBSOLETE     { */
/* OBSOLETE       printf ("Am290*0 received vector number %d\n", */
/* OBSOLETE 	      in_msg_buf->halt_msg.trap_number); */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_ALRM; */
/* OBSOLETE     } */
/* OBSOLETE   else if (in_msg_buf->halt_msg.trap_number == 15) */
/* OBSOLETE     { */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_TRAP; */
/* OBSOLETE     } */
/* OBSOLETE   else if (in_msg_buf->halt_msg.trap_number >= 16 */
/* OBSOLETE 	   && in_msg_buf->halt_msg.trap_number <= 21) */
/* OBSOLETE     { */
/* OBSOLETE       printf ("Am290*0 received vector number %d\n", */
/* OBSOLETE 	      in_msg_buf->halt_msg.trap_number); */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_INT; */
/* OBSOLETE     } */
/* OBSOLETE   else if (in_msg_buf->halt_msg.trap_number == 22) */
/* OBSOLETE     { */
/* OBSOLETE       printf ("Am290*0 received vector number %d\n", */
/* OBSOLETE 	      in_msg_buf->halt_msg.trap_number); */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_ILL; */
/* OBSOLETE     }				/* BREAK message was sent */ */
/* OBSOLETE   else if (in_msg_buf->halt_msg.trap_number == 75) */
/* OBSOLETE     { */
/* OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED; */
/* OBSOLETE       status->value.sig = TARGET_SIGNAL_TRAP; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE   exit: */
/* OBSOLETE     { */
/* OBSOLETE       status->kind = TARGET_WAITKIND_EXITED; */
/* OBSOLETE       status->value.integer = 0; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   timeout = old_timeout;	/* Restore original timeout value */ */
/* OBSOLETE   immediate_quit = old_immediate_quit; */
/* OBSOLETE   return inferior_ptid; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /******************************************************* REMOTE_FETCH_REGISTERS */
/* OBSOLETE  * Read a remote register 'regno'.  */
/* OBSOLETE  * If regno==-1 then read all the registers. */
/* OBSOLETE  */ */
/* OBSOLETE static void */
/* OBSOLETE mm_fetch_registers (int regno) */
/* OBSOLETE { */
/* OBSOLETE   INT32 *data_p; */
/* OBSOLETE  */
/* OBSOLETE   if (regno >= 0) */
/* OBSOLETE     { */
/* OBSOLETE       fetch_register (regno); */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE /* Gr1/rsp */ */
/* OBSOLETE   out_msg_buf->read_req_msg.byte_count = 4 * 1; */
/* OBSOLETE   out_msg_buf->read_req_msg.memory_space = GLOBAL_REG; */
/* OBSOLETE   out_msg_buf->read_req_msg.address = 1; */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   expect_msg (READ_ACK, in_msg_buf, 1); */
/* OBSOLETE   data_p = &(in_msg_buf->read_r_ack_msg.data[0]); */
/* OBSOLETE   supply_register (GR1_REGNUM, data_p); */
/* OBSOLETE  */
/* OBSOLETE #if defined(GR64_REGNUM)	/* Read gr64-127 */ */
/* OBSOLETE /* Global Registers gr64-gr95 */ */
/* OBSOLETE   out_msg_buf->read_req_msg.code = READ_REQ; */
/* OBSOLETE   out_msg_buf->read_req_msg.length = 4 * 3; */
/* OBSOLETE   out_msg_buf->read_req_msg.byte_count = 4 * 32; */
/* OBSOLETE   out_msg_buf->read_req_msg.memory_space = GLOBAL_REG; */
/* OBSOLETE   out_msg_buf->read_req_msg.address = 64; */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   expect_msg (READ_ACK, in_msg_buf, 1); */
/* OBSOLETE   data_p = &(in_msg_buf->read_r_ack_msg.data[0]); */
/* OBSOLETE  */
/* OBSOLETE   for (regno = GR64_REGNUM; regno < GR64_REGNUM + 32; regno++) */
/* OBSOLETE     { */
/* OBSOLETE       supply_register (regno, data_p++); */
/* OBSOLETE     } */
/* OBSOLETE #endif /*  GR64_REGNUM */ */
/* OBSOLETE  */
/* OBSOLETE /* Global Registers gr96-gr127 */ */
/* OBSOLETE   out_msg_buf->read_req_msg.code = READ_REQ; */
/* OBSOLETE   out_msg_buf->read_req_msg.length = 4 * 3; */
/* OBSOLETE   out_msg_buf->read_req_msg.byte_count = 4 * 32; */
/* OBSOLETE   out_msg_buf->read_req_msg.memory_space = GLOBAL_REG; */
/* OBSOLETE   out_msg_buf->read_req_msg.address = 96; */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   expect_msg (READ_ACK, in_msg_buf, 1); */
/* OBSOLETE   data_p = &(in_msg_buf->read_r_ack_msg.data[0]); */
/* OBSOLETE  */
/* OBSOLETE   for (regno = GR96_REGNUM; regno < GR96_REGNUM + 32; regno++) */
/* OBSOLETE     { */
/* OBSOLETE       supply_register (regno, data_p++); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE /* Local Registers */ */
/* OBSOLETE   out_msg_buf->read_req_msg.byte_count = 4 * (128); */
/* OBSOLETE   out_msg_buf->read_req_msg.memory_space = LOCAL_REG; */
/* OBSOLETE   out_msg_buf->read_req_msg.address = 0; */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   expect_msg (READ_ACK, in_msg_buf, 1); */
/* OBSOLETE   data_p = &(in_msg_buf->read_r_ack_msg.data[0]); */
/* OBSOLETE  */
/* OBSOLETE   for (regno = LR0_REGNUM; regno < LR0_REGNUM + 128; regno++) */
/* OBSOLETE     { */
/* OBSOLETE       supply_register (regno, data_p++); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE /* Protected Special Registers */ */
/* OBSOLETE   out_msg_buf->read_req_msg.byte_count = 4 * 15; */
/* OBSOLETE   out_msg_buf->read_req_msg.memory_space = SPECIAL_REG; */
/* OBSOLETE   out_msg_buf->read_req_msg.address = 0; */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   expect_msg (READ_ACK, in_msg_buf, 1); */
/* OBSOLETE   data_p = &(in_msg_buf->read_r_ack_msg.data[0]); */
/* OBSOLETE  */
/* OBSOLETE   for (regno = 0; regno <= 14; regno++) */
/* OBSOLETE     { */
/* OBSOLETE       supply_register (SR_REGNUM (regno), data_p++); */
/* OBSOLETE     } */
/* OBSOLETE   if (USE_SHADOW_PC) */
/* OBSOLETE     {				/* Let regno_to_srnum() handle the register number */ */
/* OBSOLETE       fetch_register (NPC_REGNUM); */
/* OBSOLETE       fetch_register (PC_REGNUM); */
/* OBSOLETE       fetch_register (PC2_REGNUM); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE /* Unprotected Special Registers */ */
/* OBSOLETE   out_msg_buf->read_req_msg.byte_count = 4 * 8; */
/* OBSOLETE   out_msg_buf->read_req_msg.memory_space = SPECIAL_REG; */
/* OBSOLETE   out_msg_buf->read_req_msg.address = 128; */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   expect_msg (READ_ACK, in_msg_buf, 1); */
/* OBSOLETE   data_p = &(in_msg_buf->read_r_ack_msg.data[0]); */
/* OBSOLETE  */
/* OBSOLETE   for (regno = 128; regno <= 135; regno++) */
/* OBSOLETE     { */
/* OBSOLETE       supply_register (SR_REGNUM (regno), data_p++); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* There doesn't seem to be any way to get these.  */ */
/* OBSOLETE   { */
/* OBSOLETE     int val = -1; */
/* OBSOLETE     supply_register (FPE_REGNUM, &val); */
/* OBSOLETE     supply_register (INTE_REGNUM, &val); */
/* OBSOLETE     supply_register (FPS_REGNUM, &val); */
/* OBSOLETE     supply_register (EXO_REGNUM, &val); */
/* OBSOLETE   } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /****************************************************** REMOTE_STORE_REGISTERS */
/* OBSOLETE  * Store register regno into the target.   */
/* OBSOLETE  * If regno==-1 then store all the registers. */
/* OBSOLETE  * Result is 0 for success, -1 for failure. */
/* OBSOLETE  */ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE mm_store_registers (int regno) */
/* OBSOLETE { */
/* OBSOLETE   int result; */
/* OBSOLETE  */
/* OBSOLETE   if (regno >= 0) */
/* OBSOLETE     { */
/* OBSOLETE       store_register (regno); */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   result = 0; */
/* OBSOLETE  */
/* OBSOLETE   out_msg_buf->write_r_msg.code = WRITE_REQ; */
/* OBSOLETE  */
/* OBSOLETE /* Gr1/rsp */ */
/* OBSOLETE   out_msg_buf->write_r_msg.byte_count = 4 * 1; */
/* OBSOLETE   out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count; */
/* OBSOLETE   out_msg_buf->write_r_msg.memory_space = GLOBAL_REG; */
/* OBSOLETE   out_msg_buf->write_r_msg.address = 1; */
/* OBSOLETE   out_msg_buf->write_r_msg.data[0] = read_register (GR1_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   if (!expect_msg (WRITE_ACK, in_msg_buf, 1)) */
/* OBSOLETE     { */
/* OBSOLETE       result = -1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE #if defined(GR64_REGNUM) */
/* OBSOLETE /* Global registers gr64-gr95 */ */
/* OBSOLETE   out_msg_buf->write_r_msg.byte_count = 4 * (32); */
/* OBSOLETE   out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count; */
/* OBSOLETE   out_msg_buf->write_r_msg.address = 64; */
/* OBSOLETE  */
/* OBSOLETE   for (regno = GR64_REGNUM; regno < GR64_REGNUM + 32; regno++) */
/* OBSOLETE     { */
/* OBSOLETE       out_msg_buf->write_r_msg.data[regno - GR64_REGNUM] = read_register (regno); */
/* OBSOLETE     } */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   if (!expect_msg (WRITE_ACK, in_msg_buf, 1)) */
/* OBSOLETE     { */
/* OBSOLETE       result = -1; */
/* OBSOLETE     } */
/* OBSOLETE #endif /* GR64_REGNUM */ */
/* OBSOLETE  */
/* OBSOLETE /* Global registers gr96-gr127 */ */
/* OBSOLETE   out_msg_buf->write_r_msg.byte_count = 4 * (32); */
/* OBSOLETE   out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count; */
/* OBSOLETE   out_msg_buf->write_r_msg.address = 96; */
/* OBSOLETE   for (regno = GR96_REGNUM; regno < GR96_REGNUM + 32; regno++) */
/* OBSOLETE     { */
/* OBSOLETE       out_msg_buf->write_r_msg.data[regno - GR96_REGNUM] = read_register (regno); */
/* OBSOLETE     } */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   if (!expect_msg (WRITE_ACK, in_msg_buf, 1)) */
/* OBSOLETE     { */
/* OBSOLETE       result = -1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE /* Local Registers */ */
/* OBSOLETE   out_msg_buf->write_r_msg.memory_space = LOCAL_REG; */
/* OBSOLETE   out_msg_buf->write_r_msg.byte_count = 4 * 128; */
/* OBSOLETE   out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count; */
/* OBSOLETE   out_msg_buf->write_r_msg.address = 0; */
/* OBSOLETE  */
/* OBSOLETE   for (regno = LR0_REGNUM; regno < LR0_REGNUM + 128; regno++) */
/* OBSOLETE     { */
/* OBSOLETE       out_msg_buf->write_r_msg.data[regno - LR0_REGNUM] = read_register (regno); */
/* OBSOLETE     } */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   if (!expect_msg (WRITE_ACK, in_msg_buf, 1)) */
/* OBSOLETE     { */
/* OBSOLETE       result = -1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE /* Protected Special Registers */ */
/* OBSOLETE   /* VAB through TMR */ */
/* OBSOLETE   out_msg_buf->write_r_msg.memory_space = SPECIAL_REG; */
/* OBSOLETE   out_msg_buf->write_r_msg.byte_count = 4 * 10; */
/* OBSOLETE   out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count; */
/* OBSOLETE   out_msg_buf->write_r_msg.address = 0; */
/* OBSOLETE   for (regno = 0; regno <= 9; regno++)	/* VAB through TMR */ */
/* OBSOLETE     out_msg_buf->write_r_msg.data[regno] = read_register (SR_REGNUM (regno)); */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   if (!expect_msg (WRITE_ACK, in_msg_buf, 1)) */
/* OBSOLETE     { */
/* OBSOLETE       result = -1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* PC0, PC1, PC2 possibly as shadow registers */ */
/* OBSOLETE   out_msg_buf->write_r_msg.byte_count = 4 * 3; */
/* OBSOLETE   out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count; */
/* OBSOLETE   for (regno = 10; regno <= 12; regno++)	/* LRU and MMU */ */
/* OBSOLETE     out_msg_buf->write_r_msg.data[regno - 10] = read_register (SR_REGNUM (regno)); */
/* OBSOLETE   if (USE_SHADOW_PC) */
/* OBSOLETE     out_msg_buf->write_r_msg.address = 20;	/* SPC0 */ */
/* OBSOLETE   else */
/* OBSOLETE     out_msg_buf->write_r_msg.address = 10;	/* PC0 */ */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   if (!expect_msg (WRITE_ACK, in_msg_buf, 1)) */
/* OBSOLETE     { */
/* OBSOLETE       result = -1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* LRU and MMU */ */
/* OBSOLETE   out_msg_buf->write_r_msg.byte_count = 4 * 2; */
/* OBSOLETE   out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count; */
/* OBSOLETE   out_msg_buf->write_r_msg.address = 13; */
/* OBSOLETE   for (regno = 13; regno <= 14; regno++)	/* LRU and MMU */ */
/* OBSOLETE     out_msg_buf->write_r_msg.data[regno - 13] = read_register (SR_REGNUM (regno)); */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   if (!expect_msg (WRITE_ACK, in_msg_buf, 1)) */
/* OBSOLETE     { */
/* OBSOLETE       result = -1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE /* Unprotected Special Registers */ */
/* OBSOLETE   out_msg_buf->write_r_msg.byte_count = 4 * 8; */
/* OBSOLETE   out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count; */
/* OBSOLETE   out_msg_buf->write_r_msg.address = 128; */
/* OBSOLETE   for (regno = 128; regno <= 135; regno++) */
/* OBSOLETE     out_msg_buf->write_r_msg.data[regno - 128] = read_register (SR_REGNUM (regno)); */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   if (!expect_msg (WRITE_ACK, in_msg_buf, 1)) */
/* OBSOLETE     { */
/* OBSOLETE       result = -1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   registers_changed (); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /*************************************************** REMOTE_PREPARE_TO_STORE */ */
/* OBSOLETE /* Get ready to modify the registers array.  On machines which store */
/* OBSOLETE    individual registers, this doesn't need to do anything.  On machines */
/* OBSOLETE    which store all the registers in one fell swoop, this makes sure */
/* OBSOLETE    that registers contains all the registers from the program being */
/* OBSOLETE    debugged.  */ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE mm_prepare_to_store (void) */
/* OBSOLETE { */
/* OBSOLETE   /* Do nothing, since we can store individual regs */ */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /******************************************************* REMOTE_XFER_MEMORY */ */
/* OBSOLETE static CORE_ADDR */
/* OBSOLETE translate_addr (CORE_ADDR addr) */
/* OBSOLETE { */
/* OBSOLETE #if defined(KERNEL_DEBUGGING) */
/* OBSOLETE   /* Check for a virtual address in the kernel */ */
/* OBSOLETE   /* Assume physical address of ublock is in  paddr_u register */ */
/* OBSOLETE   /* FIXME: doesn't work for user virtual addresses */ */
/* OBSOLETE   if (addr >= UVADDR) */
/* OBSOLETE     { */
/* OBSOLETE       /* PADDR_U register holds the physical address of the ublock */ */
/* OBSOLETE       CORE_ADDR i = (CORE_ADDR) read_register (PADDR_U_REGNUM); */
/* OBSOLETE       return (i + addr - (CORE_ADDR) UVADDR); */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       return (addr); */
/* OBSOLETE     } */
/* OBSOLETE #else */
/* OBSOLETE   return (addr); */
/* OBSOLETE #endif */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /******************************************************* REMOTE_FILES_INFO */ */
/* OBSOLETE static void */
/* OBSOLETE mm_files_info (void) */
/* OBSOLETE { */
/* OBSOLETE   printf ("\tAttached to %s at %d baud and running program %s.\n", */
/* OBSOLETE 	  dev_name, baudrate, prog_name); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /************************************************* REMOTE_INSERT_BREAKPOINT */ */
/* OBSOLETE static int */
/* OBSOLETE mm_insert_breakpoint (CORE_ADDR addr, char *contents_cache) */
/* OBSOLETE { */
/* OBSOLETE   out_msg_buf->bkpt_set_msg.code = BKPT_SET; */
/* OBSOLETE   out_msg_buf->bkpt_set_msg.length = 4 * 4; */
/* OBSOLETE   out_msg_buf->bkpt_set_msg.memory_space = I_MEM; */
/* OBSOLETE   out_msg_buf->bkpt_set_msg.bkpt_addr = (ADDR32) addr; */
/* OBSOLETE   out_msg_buf->bkpt_set_msg.pass_count = 1; */
/* OBSOLETE   out_msg_buf->bkpt_set_msg.bkpt_type = -1;	/* use illop for 29000 */ */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   if (expect_msg (BKPT_SET_ACK, in_msg_buf, 1)) */
/* OBSOLETE     { */
/* OBSOLETE       return 0;			/* Success */ */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       return 1;			/* Failure */ */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /************************************************* REMOTE_DELETE_BREAKPOINT */ */
/* OBSOLETE static int */
/* OBSOLETE mm_remove_breakpoint (CORE_ADDR addr, char *contents_cache) */
/* OBSOLETE { */
/* OBSOLETE   out_msg_buf->bkpt_rm_msg.code = BKPT_RM; */
/* OBSOLETE   out_msg_buf->bkpt_rm_msg.length = 4 * 3; */
/* OBSOLETE   out_msg_buf->bkpt_rm_msg.memory_space = I_MEM; */
/* OBSOLETE   out_msg_buf->bkpt_rm_msg.bkpt_addr = (ADDR32) addr; */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   if (expect_msg (BKPT_RM_ACK, in_msg_buf, 1)) */
/* OBSOLETE     { */
/* OBSOLETE       return 0;			/* Success */ */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       return 1;			/* Failure */ */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /******************************************************* REMOTE_KILL */ */
/* OBSOLETE static void */
/* OBSOLETE mm_kill (char *arg, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   char buf[4]; */
/* OBSOLETE  */
/* OBSOLETE #if defined(KERNEL_DEBUGGING) */
/* OBSOLETE   /* We don't ever kill the kernel */ */
/* OBSOLETE   if (from_tty) */
/* OBSOLETE     { */
/* OBSOLETE       printf ("Kernel not killed, but left in current state.\n"); */
/* OBSOLETE       printf ("Use detach to leave kernel running.\n"); */
/* OBSOLETE     } */
/* OBSOLETE #else */
/* OBSOLETE   out_msg_buf->break_msg.code = BREAK; */
/* OBSOLETE   out_msg_buf->bkpt_set_msg.length = 4 * 0; */
/* OBSOLETE   expect_msg (HALT, in_msg_buf, from_tty); */
/* OBSOLETE   if (from_tty) */
/* OBSOLETE     { */
/* OBSOLETE       printf ("Target has been stopped."); */
/* OBSOLETE       printf ("Would you like to do a hardware reset (y/n) [n] "); */
/* OBSOLETE       fgets (buf, 3, stdin); */
/* OBSOLETE       if (buf[0] == 'y') */
/* OBSOLETE 	{ */
/* OBSOLETE 	  out_msg_buf->reset_msg.code = RESET; */
/* OBSOLETE 	  out_msg_buf->bkpt_set_msg.length = 4 * 0; */
/* OBSOLETE 	  expect_msg (RESET_ACK, in_msg_buf, from_tty); */
/* OBSOLETE 	  printf ("Target has been reset."); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   pop_target (); */
/* OBSOLETE #endif */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /***************************************************************************/ */
/* OBSOLETE /*  */
/* OBSOLETE  * Load a program into the target. */
/* OBSOLETE  */ */
/* OBSOLETE static void */
/* OBSOLETE mm_load (char *arg_string, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   dont_repeat (); */
/* OBSOLETE  */
/* OBSOLETE #if defined(KERNEL_DEBUGGING) */
/* OBSOLETE   printf ("The kernel had better be loaded already!  Loading not done.\n"); */
/* OBSOLETE #else */
/* OBSOLETE   if (arg_string == 0) */
/* OBSOLETE     error ("The load command takes a file name"); */
/* OBSOLETE  */
/* OBSOLETE   arg_string = tilde_expand (arg_string); */
/* OBSOLETE   make_cleanup (xfree, arg_string); */
/* OBSOLETE   QUIT; */
/* OBSOLETE   immediate_quit++; */
/* OBSOLETE   error ("File loading is not yet supported for MiniMon."); */
/* OBSOLETE   /* FIXME, code to load your file here... */ */
/* OBSOLETE   /* You may need to do an init_target_mm() */ */
/* OBSOLETE   /* init_target_mm(?,?,?,?,?,?,?,?); */ */
/* OBSOLETE   immediate_quit--; */
/* OBSOLETE   /* symbol_file_add (arg_string, from_tty, text_addr, 0, 0); */ */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /************************************************ REMOTE_WRITE_INFERIOR_MEMORY */
/* OBSOLETE ** Copy LEN bytes of data from debugger memory at MYADDR */
/* OBSOLETE    to inferior's memory at MEMADDR.  Returns number of bytes written.  */ */
/* OBSOLETE static int */
/* OBSOLETE mm_write_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len) */
/* OBSOLETE { */
/* OBSOLETE   int i, nwritten; */
/* OBSOLETE  */
/* OBSOLETE   out_msg_buf->write_req_msg.code = WRITE_REQ; */
/* OBSOLETE   out_msg_buf->write_req_msg.memory_space = mm_memory_space (memaddr); */
/* OBSOLETE  */
/* OBSOLETE   nwritten = 0; */
/* OBSOLETE   while (nwritten < len) */
/* OBSOLETE     { */
/* OBSOLETE       int num_to_write = len - nwritten; */
/* OBSOLETE       if (num_to_write > MAXDATA) */
/* OBSOLETE 	num_to_write = MAXDATA; */
/* OBSOLETE       for (i = 0; i < num_to_write; i++) */
/* OBSOLETE 	out_msg_buf->write_req_msg.data[i] = myaddr[i + nwritten]; */
/* OBSOLETE       out_msg_buf->write_req_msg.byte_count = num_to_write; */
/* OBSOLETE       out_msg_buf->write_req_msg.length = 3 * 4 + num_to_write; */
/* OBSOLETE       out_msg_buf->write_req_msg.address = memaddr + nwritten; */
/* OBSOLETE       msg_send_serial (out_msg_buf); */
/* OBSOLETE  */
/* OBSOLETE       if (expect_msg (WRITE_ACK, in_msg_buf, 1)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  nwritten += in_msg_buf->write_ack_msg.byte_count; */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  break; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   return (nwritten); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /************************************************* REMOTE_READ_INFERIOR_MEMORY */
/* OBSOLETE ** Read LEN bytes from inferior memory at MEMADDR.  Put the result */
/* OBSOLETE    at debugger address MYADDR.  Returns number of bytes read.  */ */
/* OBSOLETE static int */
/* OBSOLETE mm_read_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len) */
/* OBSOLETE { */
/* OBSOLETE   int i, nread; */
/* OBSOLETE  */
/* OBSOLETE   out_msg_buf->read_req_msg.code = READ_REQ; */
/* OBSOLETE   out_msg_buf->read_req_msg.memory_space = mm_memory_space (memaddr); */
/* OBSOLETE  */
/* OBSOLETE   nread = 0; */
/* OBSOLETE   while (nread < len) */
/* OBSOLETE     { */
/* OBSOLETE       int num_to_read = (len - nread); */
/* OBSOLETE       if (num_to_read > MAXDATA) */
/* OBSOLETE 	num_to_read = MAXDATA; */
/* OBSOLETE       out_msg_buf->read_req_msg.byte_count = num_to_read; */
/* OBSOLETE       out_msg_buf->read_req_msg.length = 3 * 4 + num_to_read; */
/* OBSOLETE       out_msg_buf->read_req_msg.address = memaddr + nread; */
/* OBSOLETE       msg_send_serial (out_msg_buf); */
/* OBSOLETE  */
/* OBSOLETE       if (expect_msg (READ_ACK, in_msg_buf, 1)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  for (i = 0; i < in_msg_buf->read_ack_msg.byte_count; i++) */
/* OBSOLETE 	    myaddr[i + nread] = in_msg_buf->read_ack_msg.data[i]; */
/* OBSOLETE 	  nread += in_msg_buf->read_ack_msg.byte_count; */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  break; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   return (nread); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* FIXME!  Merge these two.  */ */
/* OBSOLETE static int */
/* OBSOLETE mm_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len, int write, */
/* OBSOLETE 			 struct mem_attrib *attrib ATTRIBUTE_UNUSED, */
/* OBSOLETE 			 struct target_ops *target ATTRIBUTE_UNUSED) */
/* OBSOLETE { */
/* OBSOLETE  */
/* OBSOLETE   memaddr = translate_addr (memaddr); */
/* OBSOLETE  */
/* OBSOLETE   if (write) */
/* OBSOLETE     return mm_write_inferior_memory (memaddr, myaddr, len); */
/* OBSOLETE   else */
/* OBSOLETE     return mm_read_inferior_memory (memaddr, myaddr, len); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /********************************************************** MSG_SEND_SERIAL */
/* OBSOLETE ** This function is used to send a message over the */
/* OBSOLETE ** serial line. */
/* OBSOLETE ** */
/* OBSOLETE ** If the message is successfully sent, a zero is */
/* OBSOLETE ** returned.  If the message was not sendable, a -1 */
/* OBSOLETE ** is returned.  This function blocks.  That is, it */
/* OBSOLETE ** does not return until the message is completely */
/* OBSOLETE ** sent, or until an error is encountered. */
/* OBSOLETE ** */
/* OBSOLETE */ */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE msg_send_serial (union msg_t *msg_ptr) */
/* OBSOLETE { */
/* OBSOLETE   INT32 message_size; */
/* OBSOLETE   int byte_count; */
/* OBSOLETE   int result; */
/* OBSOLETE   char c; */
/* OBSOLETE  */
/* OBSOLETE   /* Send message header */ */
/* OBSOLETE   byte_count = 0; */
/* OBSOLETE   message_size = msg_ptr->generic_msg.length + (2 * sizeof (INT32)); */
/* OBSOLETE   do */
/* OBSOLETE     { */
/* OBSOLETE       c = *((char *) msg_ptr + byte_count); */
/* OBSOLETE       result = write (mm_desc, &c, 1); */
/* OBSOLETE       if (result == 1) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  byte_count = byte_count + 1; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   while ((byte_count < message_size)); */
/* OBSOLETE  */
/* OBSOLETE   return (0); */
/* OBSOLETE }				/* end msg_send_serial() */ */
/* OBSOLETE  */
/* OBSOLETE /********************************************************** MSG_RECV_SERIAL */
/* OBSOLETE ** This function is used to receive a message over a */
/* OBSOLETE ** serial line. */
/* OBSOLETE ** */
/* OBSOLETE ** If the message is waiting in the buffer, a zero is */
/* OBSOLETE ** returned and the buffer pointed to by msg_ptr is filled */
/* OBSOLETE ** in.  If no message was available, a -1 is returned. */
/* OBSOLETE ** If timeout==0, wait indefinetly for a character. */
/* OBSOLETE ** */
/* OBSOLETE */ */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE msg_recv_serial (union msg_t *msg_ptr) */
/* OBSOLETE { */
/* OBSOLETE   static INT32 length = 0; */
/* OBSOLETE   static INT32 byte_count = 0; */
/* OBSOLETE   int result; */
/* OBSOLETE   char c; */
/* OBSOLETE   if (msg_ptr == 0)		/* re-sync request */ */
/* OBSOLETE     { */
/* OBSOLETE       length = 0; */
/* OBSOLETE       byte_count = 0; */
/* OBSOLETE #ifdef HAVE_TERMIO */
/* OBSOLETE       /* The timeout here is the prevailing timeout set with VTIME */ */
/* OBSOLETE       ->"timeout==0 semantics not supported" */
/* OBSOLETE 	read (mm_desc, in_buf, BUFER_SIZE); */
/* OBSOLETE #else */
/* OBSOLETE       alarm (1); */
/* OBSOLETE       read (mm_desc, in_buf, BUFER_SIZE); */
/* OBSOLETE       alarm (0); */
/* OBSOLETE #endif */
/* OBSOLETE       return (0); */
/* OBSOLETE     } */
/* OBSOLETE   /* Receive message */ */
/* OBSOLETE #ifdef HAVE_TERMIO */
/* OBSOLETE /* Timeout==0, help support the mm_wait() routine */ */
/* OBSOLETE   ->"timeout==0 semantics not supported (and its nice if they are)" */
/* OBSOLETE     result = read (mm_desc, &c, 1); */
/* OBSOLETE #else */
/* OBSOLETE   alarm (timeout); */
/* OBSOLETE   result = read (mm_desc, &c, 1); */
/* OBSOLETE   alarm (0); */
/* OBSOLETE #endif */
/* OBSOLETE   if (result < 0) */
/* OBSOLETE     { */
/* OBSOLETE       if (errno == EINTR) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  error ("Timeout reading from remote system."); */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	perror_with_name ("remote"); */
/* OBSOLETE     } */
/* OBSOLETE   else if (result == 1) */
/* OBSOLETE     { */
/* OBSOLETE       *((char *) msg_ptr + byte_count) = c; */
/* OBSOLETE       byte_count = byte_count + 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Message header received.  Save message length. */ */
/* OBSOLETE   if (byte_count == (2 * sizeof (INT32))) */
/* OBSOLETE     length = msg_ptr->generic_msg.length; */
/* OBSOLETE  */
/* OBSOLETE   if (byte_count >= (length + (2 * sizeof (INT32)))) */
/* OBSOLETE     { */
/* OBSOLETE       /* Message received */ */
/* OBSOLETE       byte_count = 0; */
/* OBSOLETE       return (0); */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     return (-1); */
/* OBSOLETE  */
/* OBSOLETE }				/* end msg_recv_serial() */ */
/* OBSOLETE  */
/* OBSOLETE /********************************************************************* KBD_RAW */
/* OBSOLETE ** This function is used to put the keyboard in "raw" */
/* OBSOLETE ** mode for BSD Unix.  The original status is saved */
/* OBSOLETE ** so that it may be restored later. */
/* OBSOLETE */ */
/* OBSOLETE TERMINAL kbd_tbuf; */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE kbd_raw (void) */
/* OBSOLETE { */
/* OBSOLETE   int result; */
/* OBSOLETE   TERMINAL tbuf; */
/* OBSOLETE  */
/* OBSOLETE   /* Get keyboard termio (to save to restore original modes) */ */
/* OBSOLETE #ifdef HAVE_TERMIO */
/* OBSOLETE   result = ioctl (0, TCGETA, &kbd_tbuf); */
/* OBSOLETE #else */
/* OBSOLETE   result = ioctl (0, TIOCGETP, &kbd_tbuf); */
/* OBSOLETE #endif */
/* OBSOLETE   if (result == -1) */
/* OBSOLETE     return (errno); */
/* OBSOLETE  */
/* OBSOLETE   /* Get keyboard TERMINAL (for modification) */ */
/* OBSOLETE #ifdef HAVE_TERMIO */
/* OBSOLETE   result = ioctl (0, TCGETA, &tbuf); */
/* OBSOLETE #else */
/* OBSOLETE   result = ioctl (0, TIOCGETP, &tbuf); */
/* OBSOLETE #endif */
/* OBSOLETE   if (result == -1) */
/* OBSOLETE     return (errno); */
/* OBSOLETE  */
/* OBSOLETE   /* Set up new parameters */ */
/* OBSOLETE #ifdef HAVE_TERMIO */
/* OBSOLETE   tbuf.c_iflag = tbuf.c_iflag & */
/* OBSOLETE     ~(INLCR | ICRNL | IUCLC | ISTRIP | IXON | BRKINT); */
/* OBSOLETE   tbuf.c_lflag = tbuf.c_lflag & ~(ICANON | ISIG | ECHO); */
/* OBSOLETE   tbuf.c_cc[4] = 0;		/* MIN */ */
/* OBSOLETE   tbuf.c_cc[5] = 0;		/* TIME */ */
/* OBSOLETE #else */
/* OBSOLETE   /* FIXME: not sure if this is correct (matches HAVE_TERMIO). */ */
/* OBSOLETE   tbuf.sg_flags |= RAW; */
/* OBSOLETE   tbuf.sg_flags |= ANYP; */
/* OBSOLETE   tbuf.sg_flags &= ~ECHO; */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE   /* Set keyboard termio to new mode (RAW) */ */
/* OBSOLETE #ifdef HAVE_TERMIO */
/* OBSOLETE   result = ioctl (0, TCSETAF, &tbuf); */
/* OBSOLETE #else */
/* OBSOLETE   result = ioctl (0, TIOCSETP, &tbuf); */
/* OBSOLETE #endif */
/* OBSOLETE   if (result == -1) */
/* OBSOLETE     return (errno); */
/* OBSOLETE  */
/* OBSOLETE   return (0); */
/* OBSOLETE }				/* end kbd_raw() */ */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /***************************************************************** KBD_RESTORE */
/* OBSOLETE ** This function is used to put the keyboard back in the */
/* OBSOLETE ** mode it was in before kbk_raw was called.  Note that */
/* OBSOLETE ** kbk_raw() must have been called at least once before */
/* OBSOLETE ** kbd_restore() is called. */
/* OBSOLETE */ */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE kbd_restore (void) */
/* OBSOLETE { */
/* OBSOLETE   int result; */
/* OBSOLETE  */
/* OBSOLETE   /* Set keyboard termio to original mode */ */
/* OBSOLETE #ifdef HAVE_TERMIO */
/* OBSOLETE   result = ioctl (0, TCSETAF, &kbd_tbuf); */
/* OBSOLETE #else */
/* OBSOLETE   result = ioctl (0, TIOCGETP, &kbd_tbuf); */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE   if (result == -1) */
/* OBSOLETE     return (errno); */
/* OBSOLETE  */
/* OBSOLETE   return (0); */
/* OBSOLETE }				/* end kbd_cooked() */ */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /*****************************************************************************/ */
/* OBSOLETE /* Fetch a single register indicatated by 'regno'.  */
/* OBSOLETE  * Returns 0/-1 on success/failure.   */
/* OBSOLETE  */ */
/* OBSOLETE static int */
/* OBSOLETE fetch_register (int regno) */
/* OBSOLETE { */
/* OBSOLETE   int result; */
/* OBSOLETE   out_msg_buf->read_req_msg.code = READ_REQ; */
/* OBSOLETE   out_msg_buf->read_req_msg.length = 4 * 3; */
/* OBSOLETE   out_msg_buf->read_req_msg.byte_count = 4; */
/* OBSOLETE  */
/* OBSOLETE   if (regno == GR1_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       out_msg_buf->read_req_msg.memory_space = GLOBAL_REG; */
/* OBSOLETE       out_msg_buf->read_req_msg.address = 1; */
/* OBSOLETE     } */
/* OBSOLETE   else if (regno >= GR96_REGNUM && regno < GR96_REGNUM + 32) */
/* OBSOLETE     { */
/* OBSOLETE       out_msg_buf->read_req_msg.memory_space = GLOBAL_REG; */
/* OBSOLETE       out_msg_buf->read_req_msg.address = (regno - GR96_REGNUM) + 96; */
/* OBSOLETE     } */
/* OBSOLETE #if defined(GR64_REGNUM) */
/* OBSOLETE   else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32) */
/* OBSOLETE     { */
/* OBSOLETE       out_msg_buf->read_req_msg.memory_space = GLOBAL_REG; */
/* OBSOLETE       out_msg_buf->read_req_msg.address = (regno - GR64_REGNUM) + 64; */
/* OBSOLETE     } */
/* OBSOLETE #endif /* GR64_REGNUM */ */
/* OBSOLETE   else if (regno >= LR0_REGNUM && regno < LR0_REGNUM + 128) */
/* OBSOLETE     { */
/* OBSOLETE       out_msg_buf->read_req_msg.memory_space = LOCAL_REG; */
/* OBSOLETE       out_msg_buf->read_req_msg.address = (regno - LR0_REGNUM); */
/* OBSOLETE     } */
/* OBSOLETE   else if (regno >= FPE_REGNUM && regno <= EXO_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       int val = -1; */
/* OBSOLETE       supply_register (160 + (regno - FPE_REGNUM), &val); */
/* OBSOLETE       return 0;			/* Pretend Success */ */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       out_msg_buf->read_req_msg.memory_space = SPECIAL_REG; */
/* OBSOLETE       out_msg_buf->read_req_msg.address = regnum_to_srnum (regno); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE  */
/* OBSOLETE   if (expect_msg (READ_ACK, in_msg_buf, 1)) */
/* OBSOLETE     { */
/* OBSOLETE       supply_register (regno, &(in_msg_buf->read_r_ack_msg.data[0])); */
/* OBSOLETE       result = 0; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       result = -1; */
/* OBSOLETE     } */
/* OBSOLETE   return result; */
/* OBSOLETE } */
/* OBSOLETE /*****************************************************************************/ */
/* OBSOLETE /* Store a single register indicated by 'regno'.  */
/* OBSOLETE  * Returns 0/-1 on success/failure.   */
/* OBSOLETE  */ */
/* OBSOLETE static int */
/* OBSOLETE store_register (int regno) */
/* OBSOLETE { */
/* OBSOLETE   int result; */
/* OBSOLETE  */
/* OBSOLETE   out_msg_buf->write_req_msg.code = WRITE_REQ; */
/* OBSOLETE   out_msg_buf->write_req_msg.length = 4 * 4; */
/* OBSOLETE   out_msg_buf->write_req_msg.byte_count = 4; */
/* OBSOLETE   out_msg_buf->write_r_msg.data[0] = read_register (regno); */
/* OBSOLETE  */
/* OBSOLETE   if (regno == GR1_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       out_msg_buf->write_req_msg.memory_space = GLOBAL_REG; */
/* OBSOLETE       out_msg_buf->write_req_msg.address = 1; */
/* OBSOLETE       /* Setting GR1 changes the numbers of all the locals, so invalidate the  */
/* OBSOLETE        * register cache.  Do this *after* calling read_register, because we want  */
/* OBSOLETE        * read_register to return the value that write_register has just stuffed  */
/* OBSOLETE        * into the registers array, not the value of the register fetched from  */
/* OBSOLETE        * the inferior.   */
/* OBSOLETE        */ */
/* OBSOLETE       registers_changed (); */
/* OBSOLETE     } */
/* OBSOLETE #if defined(GR64_REGNUM) */
/* OBSOLETE   else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32) */
/* OBSOLETE     { */
/* OBSOLETE       out_msg_buf->write_req_msg.memory_space = GLOBAL_REG; */
/* OBSOLETE       out_msg_buf->write_req_msg.address = (regno - GR64_REGNUM) + 64; */
/* OBSOLETE     } */
/* OBSOLETE #endif /* GR64_REGNUM */ */
/* OBSOLETE   else if (regno >= GR96_REGNUM && regno < GR96_REGNUM + 32) */
/* OBSOLETE     { */
/* OBSOLETE       out_msg_buf->write_req_msg.memory_space = GLOBAL_REG; */
/* OBSOLETE       out_msg_buf->write_req_msg.address = (regno - GR96_REGNUM) + 96; */
/* OBSOLETE     } */
/* OBSOLETE   else if (regno >= LR0_REGNUM && regno < LR0_REGNUM + 128) */
/* OBSOLETE     { */
/* OBSOLETE       out_msg_buf->write_req_msg.memory_space = LOCAL_REG; */
/* OBSOLETE       out_msg_buf->write_req_msg.address = (regno - LR0_REGNUM); */
/* OBSOLETE     } */
/* OBSOLETE   else if (regno >= FPE_REGNUM && regno <= EXO_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       return 0;			/* Pretend Success */ */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     /* An unprotected or protected special register */ */
/* OBSOLETE     { */
/* OBSOLETE       out_msg_buf->write_req_msg.memory_space = SPECIAL_REG; */
/* OBSOLETE       out_msg_buf->write_req_msg.address = regnum_to_srnum (regno); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE  */
/* OBSOLETE   if (expect_msg (WRITE_ACK, in_msg_buf, 1)) */
/* OBSOLETE     { */
/* OBSOLETE       result = 0; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       result = -1; */
/* OBSOLETE     } */
/* OBSOLETE   return result; */
/* OBSOLETE } */
/* OBSOLETE /****************************************************************************/ */
/* OBSOLETE /*  */
/* OBSOLETE  * Convert a gdb special register number to a 29000 special register number. */
/* OBSOLETE  */ */
/* OBSOLETE static int */
/* OBSOLETE regnum_to_srnum (int regno) */
/* OBSOLETE { */
/* OBSOLETE   switch (regno) */
/* OBSOLETE     { */
/* OBSOLETE     case VAB_REGNUM: */
/* OBSOLETE       return (0); */
/* OBSOLETE     case OPS_REGNUM: */
/* OBSOLETE       return (1); */
/* OBSOLETE     case CPS_REGNUM: */
/* OBSOLETE       return (2); */
/* OBSOLETE     case CFG_REGNUM: */
/* OBSOLETE       return (3); */
/* OBSOLETE     case CHA_REGNUM: */
/* OBSOLETE       return (4); */
/* OBSOLETE     case CHD_REGNUM: */
/* OBSOLETE       return (5); */
/* OBSOLETE     case CHC_REGNUM: */
/* OBSOLETE       return (6); */
/* OBSOLETE     case RBP_REGNUM: */
/* OBSOLETE       return (7); */
/* OBSOLETE     case TMC_REGNUM: */
/* OBSOLETE       return (8); */
/* OBSOLETE     case TMR_REGNUM: */
/* OBSOLETE       return (9); */
/* OBSOLETE     case NPC_REGNUM: */
/* OBSOLETE       return (USE_SHADOW_PC ? (20) : (10)); */
/* OBSOLETE     case PC_REGNUM: */
/* OBSOLETE       return (USE_SHADOW_PC ? (21) : (11)); */
/* OBSOLETE     case PC2_REGNUM: */
/* OBSOLETE       return (USE_SHADOW_PC ? (22) : (12)); */
/* OBSOLETE     case MMU_REGNUM: */
/* OBSOLETE       return (13); */
/* OBSOLETE     case LRU_REGNUM: */
/* OBSOLETE       return (14); */
/* OBSOLETE     case IPC_REGNUM: */
/* OBSOLETE       return (128); */
/* OBSOLETE     case IPA_REGNUM: */
/* OBSOLETE       return (129); */
/* OBSOLETE     case IPB_REGNUM: */
/* OBSOLETE       return (130); */
/* OBSOLETE     case Q_REGNUM: */
/* OBSOLETE       return (131); */
/* OBSOLETE     case ALU_REGNUM: */
/* OBSOLETE       return (132); */
/* OBSOLETE     case BP_REGNUM: */
/* OBSOLETE       return (133); */
/* OBSOLETE     case FC_REGNUM: */
/* OBSOLETE       return (134); */
/* OBSOLETE     case CR_REGNUM: */
/* OBSOLETE       return (135); */
/* OBSOLETE     case FPE_REGNUM: */
/* OBSOLETE       return (160); */
/* OBSOLETE     case INTE_REGNUM: */
/* OBSOLETE       return (161); */
/* OBSOLETE     case FPS_REGNUM: */
/* OBSOLETE       return (162); */
/* OBSOLETE     case EXO_REGNUM: */
/* OBSOLETE       return (164); */
/* OBSOLETE     default: */
/* OBSOLETE       return (255);		/* Failure ? */ */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE /****************************************************************************/ */
/* OBSOLETE /*  */
/* OBSOLETE  * Initialize the target debugger (minimon only). */
/* OBSOLETE  */ */
/* OBSOLETE static void */
/* OBSOLETE init_target_mm (ADDR32 tstart, ADDR32 tend, ADDR32 dstart, ADDR32 dend, */
/* OBSOLETE 		ADDR32 entry, INT32 ms_size, INT32 rs_size, ADDR32 arg_start) */
/* OBSOLETE { */
/* OBSOLETE   out_msg_buf->init_msg.code = INIT; */
/* OBSOLETE   out_msg_buf->init_msg.length = sizeof (struct init_msg_t) - 2 * sizeof (INT32); */
/* OBSOLETE   out_msg_buf->init_msg.text_start = tstart; */
/* OBSOLETE   out_msg_buf->init_msg.text_end = tend; */
/* OBSOLETE   out_msg_buf->init_msg.data_start = dstart; */
/* OBSOLETE   out_msg_buf->init_msg.data_end = dend; */
/* OBSOLETE   out_msg_buf->init_msg.entry_point = entry; */
/* OBSOLETE   out_msg_buf->init_msg.mem_stack_size = ms_size; */
/* OBSOLETE   out_msg_buf->init_msg.reg_stack_size = rs_size; */
/* OBSOLETE   out_msg_buf->init_msg.arg_start = arg_start; */
/* OBSOLETE   msg_send_serial (out_msg_buf); */
/* OBSOLETE   expect_msg (INIT_ACK, in_msg_buf, 1); */
/* OBSOLETE } */
/* OBSOLETE /****************************************************************************/ */
/* OBSOLETE /*  */
/* OBSOLETE  * Return a pointer to a string representing the given message code. */
/* OBSOLETE  * Not all messages are represented here, only the ones that we expect */
/* OBSOLETE  * to be called with. */
/* OBSOLETE  */ */
/* OBSOLETE static char * */
/* OBSOLETE msg_str (INT32 code) */
/* OBSOLETE { */
/* OBSOLETE   static char cbuf[32]; */
/* OBSOLETE  */
/* OBSOLETE   switch (code) */
/* OBSOLETE     { */
/* OBSOLETE     case BKPT_SET_ACK: */
/* OBSOLETE       sprintf (cbuf, "%s (%d)", "BKPT_SET_ACK", code); */
/* OBSOLETE       break; */
/* OBSOLETE     case BKPT_RM_ACK: */
/* OBSOLETE       sprintf (cbuf, "%s (%d)", "BKPT_RM_ACK", code); */
/* OBSOLETE       break; */
/* OBSOLETE     case INIT_ACK: */
/* OBSOLETE       sprintf (cbuf, "%s (%d)", "INIT_ACK", code); */
/* OBSOLETE       break; */
/* OBSOLETE     case READ_ACK: */
/* OBSOLETE       sprintf (cbuf, "%s (%d)", "READ_ACK", code); */
/* OBSOLETE       break; */
/* OBSOLETE     case WRITE_ACK: */
/* OBSOLETE       sprintf (cbuf, "%s (%d)", "WRITE_ACK", code); */
/* OBSOLETE       break; */
/* OBSOLETE     case ERROR: */
/* OBSOLETE       sprintf (cbuf, "%s (%d)", "ERROR", code); */
/* OBSOLETE       break; */
/* OBSOLETE     case HALT: */
/* OBSOLETE       sprintf (cbuf, "%s (%d)", "HALT", code); */
/* OBSOLETE       break; */
/* OBSOLETE     default: */
/* OBSOLETE       sprintf (cbuf, "UNKNOWN (%d)", code); */
/* OBSOLETE       break; */
/* OBSOLETE     } */
/* OBSOLETE   return (cbuf); */
/* OBSOLETE } */
/* OBSOLETE /****************************************************************************/ */
/* OBSOLETE /* */
/* OBSOLETE  * Selected (not all of them) error codes that we might get. */
/* OBSOLETE  */ */
/* OBSOLETE static char * */
/* OBSOLETE error_msg_str (INT32 code) */
/* OBSOLETE { */
/* OBSOLETE   static char cbuf[50]; */
/* OBSOLETE  */
/* OBSOLETE   switch (code) */
/* OBSOLETE     { */
/* OBSOLETE     case EMFAIL: */
/* OBSOLETE       return ("EMFAIL: unrecoverable error"); */
/* OBSOLETE     case EMBADADDR: */
/* OBSOLETE       return ("EMBADADDR: Illegal address"); */
/* OBSOLETE     case EMBADREG: */
/* OBSOLETE       return ("EMBADREG: Illegal register "); */
/* OBSOLETE     case EMACCESS: */
/* OBSOLETE       return ("EMACCESS: Could not access memory"); */
/* OBSOLETE     case EMBADMSG: */
/* OBSOLETE       return ("EMBADMSG: Unknown message type"); */
/* OBSOLETE     case EMMSG2BIG: */
/* OBSOLETE       return ("EMMSG2BIG: Message to large"); */
/* OBSOLETE     case EMNOSEND: */
/* OBSOLETE       return ("EMNOSEND: Could not send message"); */
/* OBSOLETE     case EMNORECV: */
/* OBSOLETE       return ("EMNORECV: Could not recv message"); */
/* OBSOLETE     case EMRESET: */
/* OBSOLETE       return ("EMRESET: Could not RESET target"); */
/* OBSOLETE     case EMCONFIG: */
/* OBSOLETE       return ("EMCONFIG: Could not get target CONFIG"); */
/* OBSOLETE     case EMSTATUS: */
/* OBSOLETE       return ("EMSTATUS: Could not get target STATUS"); */
/* OBSOLETE     case EMREAD: */
/* OBSOLETE       return ("EMREAD: Could not READ target memory"); */
/* OBSOLETE     case EMWRITE: */
/* OBSOLETE       return ("EMWRITE: Could not WRITE target memory"); */
/* OBSOLETE     case EMBKPTSET: */
/* OBSOLETE       return ("EMBKPTSET: Could not set breakpoint"); */
/* OBSOLETE     case EMBKPTRM: */
/* OBSOLETE       return ("EMBKPTRM: Could not remove breakpoint"); */
/* OBSOLETE     case EMBKPTSTAT: */
/* OBSOLETE       return ("EMBKPTSTAT: Could not get breakpoint status"); */
/* OBSOLETE     case EMBKPTNONE: */
/* OBSOLETE       return ("EMBKPTNONE: All breakpoints in use"); */
/* OBSOLETE     case EMBKPTUSED: */
/* OBSOLETE       return ("EMBKPTUSED: Breakpoints already in use"); */
/* OBSOLETE     case EMINIT: */
/* OBSOLETE       return ("EMINIT: Could not init target memory"); */
/* OBSOLETE     case EMGO: */
/* OBSOLETE       return ("EMGO: Could not start execution"); */
/* OBSOLETE     case EMSTEP: */
/* OBSOLETE       return ("EMSTEP: Could not single step"); */
/* OBSOLETE     case EMBREAK: */
/* OBSOLETE       return ("EMBREAK: Could not BREAK"); */
/* OBSOLETE     case EMCOMMERR: */
/* OBSOLETE       return ("EMCOMMERR: Communication error"); */
/* OBSOLETE     default: */
/* OBSOLETE       sprintf (cbuf, "error number %d", code); */
/* OBSOLETE       break; */
/* OBSOLETE     }				/* end switch */ */
/* OBSOLETE  */
/* OBSOLETE   return (cbuf); */
/* OBSOLETE } */
/* OBSOLETE /****************************************************************************/ */
/* OBSOLETE  */
/* OBSOLETE /* Receive a message, placing it in MSG_BUF, and expect it to be of */
/* OBSOLETE    type MSGCODE.  If an error occurs, a non-zero FROM_TTY indicates */
/* OBSOLETE    that the message should be printed. */
/* OBSOLETE     */
/* OBSOLETE    Return 0 for failure, 1 for success.  */ */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE expect_msg (INT32 msgcode, union msg_t *msg_buf, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   int retries = 0; */
/* OBSOLETE   while (msg_recv_serial (msg_buf) && (retries++ < MAX_RETRIES)); */
/* OBSOLETE   if (retries >= MAX_RETRIES) */
/* OBSOLETE     { */
/* OBSOLETE       printf ("Expected msg %s, ", msg_str (msgcode)); */
/* OBSOLETE       printf ("no message received!\n"); */
/* OBSOLETE       return (0);		/* Failure */ */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   if (msg_buf->generic_msg.code != msgcode) */
/* OBSOLETE     { */
/* OBSOLETE       if (from_tty) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  printf ("Expected msg %s, ", msg_str (msgcode)); */
/* OBSOLETE 	  printf ("got msg %s\n", msg_str (msg_buf->generic_msg.code)); */
/* OBSOLETE 	  if (msg_buf->generic_msg.code == ERROR) */
/* OBSOLETE 	    printf ("%s\n", error_msg_str (msg_buf->error_msg.error_code)); */
/* OBSOLETE 	} */
/* OBSOLETE       return (0);		/* Failure */ */
/* OBSOLETE     } */
/* OBSOLETE   return (1);			/* Success */ */
/* OBSOLETE } */
/* OBSOLETE /****************************************************************************/ */
/* OBSOLETE /* */
/* OBSOLETE  * Determine the MiniMon memory space qualifier based on the addr.  */
/* OBSOLETE  * FIXME: Can't distinguis I_ROM/D_ROM.   */
/* OBSOLETE  * FIXME: Doesn't know anything about I_CACHE/D_CACHE. */
/* OBSOLETE  */ */
/* OBSOLETE static int */
/* OBSOLETE mm_memory_space (CORE_ADDR *addr) */
/* OBSOLETE { */
/* OBSOLETE   ADDR32 tstart = target_config.I_mem_start; */
/* OBSOLETE   ADDR32 tend = tstart + target_config.I_mem_size; */
/* OBSOLETE   ADDR32 dstart = target_config.D_mem_start; */
/* OBSOLETE   ADDR32 dend = tstart + target_config.D_mem_size; */
/* OBSOLETE   ADDR32 rstart = target_config.ROM_start; */
/* OBSOLETE   ADDR32 rend = tstart + target_config.ROM_size; */
/* OBSOLETE  */
/* OBSOLETE   if (((ADDR32) addr >= tstart) && ((ADDR32) addr < tend)) */
/* OBSOLETE     { */
/* OBSOLETE       return I_MEM; */
/* OBSOLETE     } */
/* OBSOLETE   else if (((ADDR32) addr >= dstart) && ((ADDR32) addr < dend)) */
/* OBSOLETE     { */
/* OBSOLETE       return D_MEM; */
/* OBSOLETE     } */
/* OBSOLETE   else if (((ADDR32) addr >= rstart) && ((ADDR32) addr < rend)) */
/* OBSOLETE     { */
/* OBSOLETE       /* FIXME: how do we determine between D_ROM and I_ROM */ */
/* OBSOLETE       return D_ROM; */
/* OBSOLETE     } */
/* OBSOLETE   else				/* FIXME: what do me do now? */ */
/* OBSOLETE     return D_MEM;		/* Hmmm! */ */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /****************************************************************************/ */
/* OBSOLETE /*  */
/* OBSOLETE  *  Define the target subroutine names */
/* OBSOLETE  */ */
/* OBSOLETE struct target_ops mm_ops; */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE init_mm_ops (void) */
/* OBSOLETE { */
/* OBSOLETE   mm_ops.to_shortname = "minimon"; */
/* OBSOLETE   mm_ops.to_longname = "Remote AMD/Minimon target"; */
/* OBSOLETE   mm_ops.to_doc = "Remote debug an AMD 290*0 using the MiniMon dbg core on the target"; */
/* OBSOLETE   mm_ops.to_open = mm_open; */
/* OBSOLETE   mm_ops.to_close = mm_close; */
/* OBSOLETE   mm_ops.to_attach = mm_attach; */
/* OBSOLETE   mm_ops.to_post_attach = NULL; */
/* OBSOLETE   mm_ops.to_require_attach = NULL; */
/* OBSOLETE   mm_ops.to_detach = mm_detach; */
/* OBSOLETE   mm_ops.to_require_detach = NULL; */
/* OBSOLETE   mm_ops.to_resume = mm_resume; */
/* OBSOLETE   mm_ops.to_wait = mm_wait; */
/* OBSOLETE   mm_ops.to_post_wait = NULL; */
/* OBSOLETE   mm_ops.to_fetch_registers = mm_fetch_registers; */
/* OBSOLETE   mm_ops.to_store_registers = mm_store_registers; */
/* OBSOLETE   mm_ops.to_prepare_to_store = mm_prepare_to_store; */
/* OBSOLETE   mm_ops.to_xfer_memory = mm_xfer_inferior_memory; */
/* OBSOLETE   mm_ops.to_files_info = mm_files_info; */
/* OBSOLETE   mm_ops.to_insert_breakpoint = mm_insert_breakpoint; */
/* OBSOLETE   mm_ops.to_remove_breakpoint = mm_remove_breakpoint; */
/* OBSOLETE   mm_ops.to_terminal_init = 0; */
/* OBSOLETE   mm_ops.to_terminal_inferior = 0; */
/* OBSOLETE   mm_ops.to_terminal_ours_for_output = 0; */
/* OBSOLETE   mm_ops.to_terminal_ours = 0; */
/* OBSOLETE   mm_ops.to_terminal_info = 0; */
/* OBSOLETE   mm_ops.to_kill = mm_kill; */
/* OBSOLETE   mm_ops.to_load = mm_load; */
/* OBSOLETE   mm_ops.to_lookup_symbol = 0; */
/* OBSOLETE   mm_ops.to_create_inferior = mm_create_inferior; */
/* OBSOLETE   mm_ops.to_post_startup_inferior = NULL; */
/* OBSOLETE   mm_ops.to_acknowledge_created_inferior = NULL; */
/* OBSOLETE   mm_ops.to_clone_and_follow_inferior = NULL; */
/* OBSOLETE   mm_ops.to_post_follow_inferior_by_clone = NULL; */
/* OBSOLETE   mm_ops.to_insert_fork_catchpoint = NULL; */
/* OBSOLETE   mm_ops.to_remove_fork_catchpoint = NULL; */
/* OBSOLETE   mm_ops.to_insert_vfork_catchpoint = NULL; */
/* OBSOLETE   mm_ops.to_remove_vfork_catchpoint = NULL; */
/* OBSOLETE   mm_ops.to_has_forked = NULL; */
/* OBSOLETE   mm_ops.to_has_vforked = NULL; */
/* OBSOLETE   mm_ops.to_can_follow_vfork_prior_to_exec = NULL; */
/* OBSOLETE   mm_ops.to_post_follow_vfork = NULL; */
/* OBSOLETE   mm_ops.to_insert_exec_catchpoint = NULL; */
/* OBSOLETE   mm_ops.to_remove_exec_catchpoint = NULL; */
/* OBSOLETE   mm_ops.to_has_execd = NULL; */
/* OBSOLETE   mm_ops.to_reported_exec_events_per_exec_call = NULL; */
/* OBSOLETE   mm_ops.to_has_exited = NULL; */
/* OBSOLETE   mm_ops.to_mourn_inferior = mm_mourn; */
/* OBSOLETE   mm_ops.to_can_run = 0; */
/* OBSOLETE   mm_ops.to_notice_signals = 0; */
/* OBSOLETE   mm_ops.to_thread_alive = 0; */
/* OBSOLETE   mm_ops.to_stop = 0; */
/* OBSOLETE   mm_ops.to_pid_to_exec_file = NULL; */
/* OBSOLETE   mm_ops.to_stratum = process_stratum; */
/* OBSOLETE   mm_ops.DONT_USE = 0; */
/* OBSOLETE   mm_ops.to_has_all_memory = 1; */
/* OBSOLETE   mm_ops.to_has_memory = 1; */
/* OBSOLETE   mm_ops.to_has_stack = 1; */
/* OBSOLETE   mm_ops.to_has_registers = 1; */
/* OBSOLETE   mm_ops.to_has_execution = 1; */
/* OBSOLETE   mm_ops.to_sections = 0; */
/* OBSOLETE   mm_ops.to_sections_end = 0; */
/* OBSOLETE   mm_ops.to_magic = OPS_MAGIC; */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE _initialize_remote_mm (void) */
/* OBSOLETE { */
/* OBSOLETE   init_mm_ops (); */
/* OBSOLETE   add_target (&mm_ops); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #ifdef NO_HIF_SUPPORT */
/* OBSOLETE service_HIF (union msg_t *msg) */
/* OBSOLETE { */
/* OBSOLETE   return (0);			/* Emulate a failure */ */
/* OBSOLETE } */
/* OBSOLETE #endif */
@


1.13
log
@* MAINTAINERS: Mark a29k target as obsolete.
* Makefile.in (a29k-tdep.o, remote-adapt.o, remote-eb.o)
(remote-mm.o, remote-udi.o): Obsolete.  Remove references in
comments.
* NEWS: Note that a29k targets are obsolete.
* a29k-tdep.c: Mark as obsolete.
* configure.tgt: Mark a29k-*-aout*, a29k-*-coff*, a29k-*-elf*,
a29k-*-ebmon*, a29k-*-kern*, a29k-*-none*, a29k-*-udi* and
a29k-*-vxworks* targets as obsolete.
* remote-adapt.c: Obsolete.
* remote-eb.c: Obsolete.
* remote-mm.c: Obsolete.
* remote-udi.c: Obsolete.
* config/a29k/a29k-udi.mt: Obsolete.
* config/a29k/a29k.mt: Obsolete.
* config/a29k/tm-a29k.h: Obsolete.
* config/a29k/tm-vx29k.h: Obsolete.
* config/a29k/vx29k.mt: Obsolete.
@
text
@@


1.12
log
@Phase 1 of the ptid_t changes.
@
text
@d1 1848
a1848 1848
/* Remote debugging interface for Am290*0 running MiniMON monitor, for GDB.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2001 Free Software Foundation, Inc.
   Originally written by Daniel Mann at AMD.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* This is like remote.c but ecpects MiniMON to be running on the Am29000 
   target hardware.
   - David Wood (wood@@lab.ultra.nyu.edu) at New York University adapted this
   file to gdb 3.95.  I was unable to get this working on sun3os4
   with termio, only with sgtty.  Because we are only attempting to
   use this module to debug our kernel, which is already loaded when
   gdb is started up, I did not code up the file downloading facilities.  
   As a result this module has only the stubs to download files. 
   You should get tagged at compile time if you need to make any 
   changes/additions.  */

#include "defs.h"
#include "inferior.h"
#include "value.h"
#include <ctype.h>
#include <fcntl.h>
#include <signal.h>
#include <errno.h>
#include "gdb_string.h"
#include "terminal.h"
#include "minimon.h"
#include "target.h"
#include "regcache.h"

/* Offset of member MEMBER in a struct of type TYPE.  */
#define offsetof(TYPE, MEMBER) ((int) &((TYPE *)0)->MEMBER)

#define DRAIN_INPUT()	(msg_recv_serial((union msg_t*)0))

extern int stop_soon_quietly;	/* for wait_for_inferior */

static void mm_resume (ptid_t ptid, int step, enum target_signal sig)
static void mm_fetch_registers ();
static int fetch_register ();
static void mm_store_registers ();
static int store_register ();
static int regnum_to_srnum ();
static void mm_close ();
static char *msg_str ();
static char *error_msg_str ();
static int expect_msg ();
static void init_target_mm ();
static int mm_memory_space ();

#define FREEZE_MODE     (read_register(CPS_REGNUM) && 0x400)
#define USE_SHADOW_PC	((processor_type == a29k_freeze_mode) && FREEZE_MODE)

/* FIXME: Replace with `set remotedebug'.  */
#define LLOG_FILE "minimon.log"
#if defined (LOG_FILE)
FILE *log_file;
#endif

/*  
 * Size of message buffers.  I couldn't get memory reads to work when
 * the byte_count was larger than 512 (it may be a baud rate problem).
 */
#define BUFER_SIZE  512
/* 
 * Size of data area in message buffer on the TARGET (remote system).
 */
#define MAXDATA_T  (target_config.max_msg_size - \
			offsetof(struct write_r_msg_t,data[0]))
/*               
 * Size of data area in message buffer on the HOST (gdb). 
 */
#define MAXDATA_H  (BUFER_SIZE - offsetof(struct write_r_msg_t,data[0]))
/* 
 * Defined as the minimum size of data areas of the two message buffers 
 */
#define MAXDATA	   (MAXDATA_H < MAXDATA_T ? MAXDATA_H : MAXDATA_T)

static char out_buf[BUFER_SIZE];
static char in_buf[BUFER_SIZE];

int msg_recv_serial ();
int msg_send_serial ();

#define MAX_RETRIES 5000
extern struct target_ops mm_ops;	/* Forward declaration */
struct config_msg_t target_config;	/* HIF needs this */
union msg_t *out_msg_buf = (union msg_t *) out_buf;
union msg_t *in_msg_buf = (union msg_t *) in_buf;

static int timeout = 5;

/* Descriptor for I/O to remote machine.  Initialize it to -1 so that
   mm_open knows that we don't have a file open when the program
   starts.  */
int mm_desc = -1;

/* stream which is fdopen'd from mm_desc.  Only valid when
   mm_desc != -1.  */
FILE *mm_stream;

/* Called when SIGALRM signal sent due to alarm() timeout.  */
#ifndef HAVE_TERMIO

volatile int n_alarms;

static void
mm_timer (void)
{
#if 0
  if (kiodebug)
    printf ("mm_timer called\n");
#endif
  n_alarms++;
}
#endif	/* HAVE_TERMIO */

/* malloc'd name of the program on the remote system.  */
static char *prog_name = NULL;


/* Number of SIGTRAPs we need to simulate.  That is, the next
   NEED_ARTIFICIAL_TRAP calls to mm_wait should just return
   SIGTRAP without actually waiting for anything.  */

/**************************************************** REMOTE_CREATE_INFERIOR */
/* This is called not only when we first attach, but also when the
   user types "run" after having attached.  */
static void
mm_create_inferior (char *execfile, char *args, char **env)
{
#define MAX_TOKENS 25
#define BUFFER_SIZE 256
  int token_count;
  int result;
  char *token[MAX_TOKENS];
  char cmd_line[BUFFER_SIZE];

  if (args && *args)
    error ("Can't pass arguments to remote mm process (yet).");

  if (execfile == 0 /* || exec_bfd == 0 */ )
    error ("No executable file specified");

  if (!mm_stream)
    {
      printf ("Minimon not open yet.\n");
      return;
    }

  /* On ultra3 (NYU) we assume the kernel is already running so there is
     no file to download.
     FIXME: Fixed required here -> load your program, possibly with mm_load().
   */
  printf_filtered ("\n\
Assuming you are at NYU debuging a kernel, i.e., no need to download.\n\n");

  /* We will get a task spawn event immediately.  */
  init_wait_for_inferior ();
  clear_proceed_status ();
  stop_soon_quietly = 1;
  proceed (-1, TARGET_SIGNAL_DEFAULT, 0);
  normal_stop ();
}
/**************************************************** REMOTE_MOURN_INFERIOR */
static void
mm_mourn (void)
{
  pop_target ();		/* Pop back to no-child state */
  generic_mourn_inferior ();
}

/********************************************************************** damn_b
*/
/* Translate baud rates from integers to damn B_codes.  Unix should
   have outgrown this crap years ago, but even POSIX wouldn't buck it.  */

#ifndef B19200
#define B19200 EXTA
#endif
#ifndef B38400
#define B38400 EXTB
#endif

static struct
{
  int rate, damn_b;
}
baudtab[] =
{
  {
    0, B0
  }
  ,
  {
    50, B50
  }
  ,
  {
    75, B75
  }
  ,
  {
    110, B110
  }
  ,
  {
    134, B134
  }
  ,
  {
    150, B150
  }
  ,
  {
    200, B200
  }
  ,
  {
    300, B300
  }
  ,
  {
    600, B600
  }
  ,
  {
    1200, B1200
  }
  ,
  {
    1800, B1800
  }
  ,
  {
    2400, B2400
  }
  ,
  {
    4800, B4800
  }
  ,
  {
    9600, B9600
  }
  ,
  {
    19200, B19200
  }
  ,
  {
    38400, B38400
  }
  ,
  {
    -1, -1
  }
  ,
};

static int
damn_b (int rate)
{
  int i;

  for (i = 0; baudtab[i].rate != -1; i++)
    if (rate == baudtab[i].rate)
      return baudtab[i].damn_b;
  return B38400;		/* Random */
}


/***************************************************************** REMOTE_OPEN
** Open a connection to remote minimon.
   NAME is the filename used for communication, then a space,
   then the baud rate.
   'target adapt /dev/ttya 9600 [prognam]' for example.
 */

static char *dev_name;
int baudrate = 9600;
static void
mm_open (char *name, int from_tty)
{
  TERMINAL sg;
  unsigned int prl;
  char *p;

  /* Find the first whitespace character, it separates dev_name from
     prog_name.  */
  for (p = name;
       p && *p && !isspace (*p); p++)
    ;
  if (p == 0 || *p == '\0')
  erroid:
    error ("Usage : <command> <serial-device> <baud-rate> [progname]");
  dev_name = (char *) xmalloc (p - name + 1);
  strncpy (dev_name, name, p - name);
  dev_name[p - name] = '\0';

  /* Skip over the whitespace after dev_name */
  for (; isspace (*p); p++)
    /*EMPTY */ ;

  if (1 != sscanf (p, "%d ", &baudrate))
    goto erroid;

  /* Skip the number and then the spaces */
  for (; isdigit (*p); p++)
    /*EMPTY */ ;
  for (; isspace (*p); p++)
    /*EMPTY */ ;

  if (prog_name != NULL)
    xfree (prog_name);
  prog_name = savestring (p, strlen (p));


  if (mm_desc >= 0)
    close (mm_desc);

  mm_desc = open (dev_name, O_RDWR);
  if (mm_desc < 0)
    perror_with_name (dev_name);
  ioctl (mm_desc, TIOCGETP, &sg);
#ifdef HAVE_TERMIO
  sg.c_cc[VMIN] = 0;		/* read with timeout.  */
  sg.c_cc[VTIME] = timeout * 10;
  sg.c_lflag &= ~(ICANON | ECHO);
  sg.c_cflag = (sg.c_cflag & ~CBAUD) | damn_b (baudrate);
#else
  sg.sg_ispeed = damn_b (baudrate);
  sg.sg_ospeed = damn_b (baudrate);
  sg.sg_flags |= RAW;
  sg.sg_flags |= ANYP;
  sg.sg_flags &= ~ECHO;
#endif


  ioctl (mm_desc, TIOCSETP, &sg);
  mm_stream = fdopen (mm_desc, "r+");

  push_target (&mm_ops);

#ifndef HAVE_TERMIO
#ifndef NO_SIGINTERRUPT
  /* Cause SIGALRM's to make reads fail with EINTR instead of resuming
     the read.  */
  if (siginterrupt (SIGALRM, 1) != 0)
    perror ("mm_open: error in siginterrupt");
#endif

  /* Set up read timeout timer.  */
  if ((void (*)) signal (SIGALRM, mm_timer) == (void (*)) -1)
    perror ("mm_open: error in signal");
#endif

#if defined (LOG_FILE)
  log_file = fopen (LOG_FILE, "w");
  if (log_file == NULL)
    perror_with_name (LOG_FILE);
#endif
  /*
     ** Initialize target configuration structure (global)
   */
  DRAIN_INPUT ();
  out_msg_buf->config_req_msg.code = CONFIG_REQ;
  out_msg_buf->config_req_msg.length = 4 * 0;
  msg_send_serial (out_msg_buf);	/* send config request message */

  expect_msg (CONFIG, in_msg_buf, 1);

  a29k_get_processor_type ();

  /* Print out some stuff, letting the user now what's going on */
  printf_filtered ("Connected to MiniMon via %s.\n", dev_name);
  /* FIXME: can this restriction be removed? */
  printf_filtered ("Remote debugging using virtual addresses works only\n");
  printf_filtered ("\twhen virtual addresses map 1:1 to physical addresses.\n")
    ;
  if (processor_type != a29k_freeze_mode)
    {
      fprintf_filtered (gdb_stderr,
			"Freeze-mode debugging not available, and can only be done on an A29050.\n");
    }

  target_config.code = CONFIG;
  target_config.length = 0;
  target_config.processor_id = in_msg_buf->config_msg.processor_id;
  target_config.version = in_msg_buf->config_msg.version;
  target_config.I_mem_start = in_msg_buf->config_msg.I_mem_start;
  target_config.I_mem_size = in_msg_buf->config_msg.I_mem_size;
  target_config.D_mem_start = in_msg_buf->config_msg.D_mem_start;
  target_config.D_mem_size = in_msg_buf->config_msg.D_mem_size;
  target_config.ROM_start = in_msg_buf->config_msg.ROM_start;
  target_config.ROM_size = in_msg_buf->config_msg.ROM_size;
  target_config.max_msg_size = in_msg_buf->config_msg.max_msg_size;
  target_config.max_bkpts = in_msg_buf->config_msg.max_bkpts;
  target_config.coprocessor = in_msg_buf->config_msg.coprocessor;
  target_config.reserved = in_msg_buf->config_msg.reserved;
  if (from_tty)
    {
      printf ("Connected to MiniMON :\n");
      printf ("    Debugcore version            %d.%d\n",
	      0x0f & (target_config.version >> 4),
	      0x0f & (target_config.version));
      printf ("    Configuration version        %d.%d\n",
	      0x0f & (target_config.version >> 12),
	      0x0f & (target_config.version >> 8));
      printf ("    Message system version       %d.%d\n",
	      0x0f & (target_config.version >> 20),
	      0x0f & (target_config.version >> 16));
      printf ("    Communication driver version %d.%d\n",
	      0x0f & (target_config.version >> 28),
	      0x0f & (target_config.version >> 24));
    }

  /* Leave the target running... 
   * The above message stopped the target in the dbg core (MiniMon),  
   * so restart the target out of MiniMon, 
   */
  out_msg_buf->go_msg.code = GO;
  out_msg_buf->go_msg.length = 0;
  msg_send_serial (out_msg_buf);
  /* No message to expect after a GO */
}

/**************************************************************** REMOTE_CLOSE
** Close the open connection to the minimon debugger.
   Use this when you want to detach and do something else
   with your gdb.  */
static void
mm_close (			/*FIXME: how is quitting used */
	   int quitting)
{
  if (mm_desc < 0)
    error ("Can't close remote connection: not debugging remotely.");

  /* We should never get here if there isn't something valid in
     mm_desc and mm_stream.  

     Due to a bug in Unix, fclose closes not only the stdio stream,
     but also the file descriptor.  So we don't actually close
     mm_desc.  */
  DRAIN_INPUT ();
  fclose (mm_stream);
  /* close (mm_desc); */

  /* Do not try to close mm_desc again, later in the program.  */
  mm_stream = NULL;
  mm_desc = -1;

#if defined (LOG_FILE)
  if (ferror (log_file))
    printf ("Error writing log file.\n");
  if (fclose (log_file) != 0)
    printf ("Error closing log file.\n");
#endif

  printf ("Ending remote debugging\n");
}

/************************************************************* REMOTE_ATACH */
/* Attach to a program that is already loaded and running 
 * Upon exiting the process's execution is stopped.
 */
static void
mm_attach (char *args, int from_tty)
{

  if (!mm_stream)
    error ("MiniMon not opened yet, use the 'target minimon' command.\n");

  if (from_tty)
    printf ("Attaching to remote program %s...\n", prog_name);

  /* Make sure the target is currently running, it is supposed to be. */
  /* FIXME: is it ok to send MiniMon a BREAK if it is already stopped in 
   *  the dbg core.  If so, we don't need to send this GO.
   */
  out_msg_buf->go_msg.code = GO;
  out_msg_buf->go_msg.length = 0;
  msg_send_serial (out_msg_buf);
  sleep (2);			/* At the worst it will stop, receive a message, continue */

  /* Send the mm a break. */
  out_msg_buf->break_msg.code = BREAK;
  out_msg_buf->break_msg.length = 0;
  msg_send_serial (out_msg_buf);
}
/********************************************************** REMOTE_DETACH */
/* Terminate the open connection to the remote debugger.
   Use this when you want to detach and do something else
   with your gdb.  Leave remote process running (with no breakpoints set). */
static void
mm_detach (char *args, int from_tty)
{
  remove_breakpoints ();	/* Just in case there were any left in */
  out_msg_buf->go_msg.code = GO;
  out_msg_buf->go_msg.length = 0;
  msg_send_serial (out_msg_buf);
  pop_target ();		/* calls mm_close to do the real work */
}


/*************************************************************** REMOTE_RESUME
** Tell the remote machine to resume.  */

static void
mm_resume (ptid_t ptid, int step, enum target_signal sig)
{
  if (sig != TARGET_SIGNAL_0)
    warning ("Can't send signals to a remote MiniMon system.");

  if (step)
    {
      out_msg_buf->step_msg.code = STEP;
      out_msg_buf->step_msg.length = 1 * 4;
      out_msg_buf->step_msg.count = 1;	/* step 1 instruction */
      msg_send_serial (out_msg_buf);
    }
  else
    {
      out_msg_buf->go_msg.code = GO;
      out_msg_buf->go_msg.length = 0;
      msg_send_serial (out_msg_buf);
    }
}

/***************************************************************** REMOTE_WAIT
** Wait until the remote machine stops, then return,
   storing status in STATUS just as `wait' would.  */

static ptid_t
mm_wait (ptid_t ptid, struct target_waitstatus *status)
{
  int i, result;
  int old_timeout = timeout;
  int old_immediate_quit = immediate_quit;

  status->kind = TARGET_WAITKIND_EXITED;
  status->value.integer = 0;

/* wait for message to arrive. It should be:
   - A HIF service request.
   - A HIF exit service request.
   - A CHANNEL0_ACK.
   - A CHANNEL1 request.
   - a debugcore HALT message.
   HIF services must be responded too, and while-looping continued.
   If the target stops executing, mm_wait() should return.
 */
  timeout = 0;			/* Wait indefinetly for a message */
  immediate_quit = 1;		/* Helps ability to QUIT */
  while (1)
    {
      while (msg_recv_serial (in_msg_buf))
	{
	  QUIT;			/* Let user quit if they want */
	}
      switch (in_msg_buf->halt_msg.code)
	{
	case HIF_CALL:
	  i = in_msg_buf->hif_call_rtn_msg.service_number;
	  result = service_HIF (in_msg_buf);
	  if (i == 1)		/* EXIT */
	    goto exit;
	  if (result)
	    printf ("Warning: failure during HIF service %d\n", i);
	  break;
	case CHANNEL0_ACK:
	  service_HIF (in_msg_buf);
	  break;
	case CHANNEL1:
	  i = in_msg_buf->channel1_msg.length;
	  in_msg_buf->channel1_msg.data[i] = '\0';
	  printf ("%s", in_msg_buf->channel1_msg.data);
	  gdb_flush (gdb_stdout);
	  /* Send CHANNEL1_ACK message */
	  out_msg_buf->channel1_ack_msg.code = CHANNEL1_ACK;
	  out_msg_buf->channel1_ack_msg.length = 0;
	  result = msg_send_serial (out_msg_buf);
	  break;
	case HALT:
	  goto halted;
	default:
	  goto halted;
	}
    }
halted:
  /* FIXME, these printfs should not be here.  This is a source level 
     debugger, guys!  */
  if (in_msg_buf->halt_msg.trap_number == 0)
    {
      printf ("Am290*0 received vector number %d (break point)\n",
	      in_msg_buf->halt_msg.trap_number);
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_TRAP;
    }
  else if (in_msg_buf->halt_msg.trap_number == 1)
    {
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_BUS;
    }
  else if (in_msg_buf->halt_msg.trap_number == 3
	   || in_msg_buf->halt_msg.trap_number == 4)
    {
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_FPE;
    }
  else if (in_msg_buf->halt_msg.trap_number == 5)
    {
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_ILL;
    }
  else if (in_msg_buf->halt_msg.trap_number >= 6
	   && in_msg_buf->halt_msg.trap_number <= 11)
    {
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_SEGV;
    }
  else if (in_msg_buf->halt_msg.trap_number == 12
	   || in_msg_buf->halt_msg.trap_number == 13)
    {
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_ILL;
    }
  else if (in_msg_buf->halt_msg.trap_number == 14)
    {
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_ALRM;
    }
  else if (in_msg_buf->halt_msg.trap_number == 15)
    {
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_TRAP;
    }
  else if (in_msg_buf->halt_msg.trap_number >= 16
	   && in_msg_buf->halt_msg.trap_number <= 21)
    {
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_INT;
    }
  else if (in_msg_buf->halt_msg.trap_number == 22)
    {
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_ILL;
    }				/* BREAK message was sent */
  else if (in_msg_buf->halt_msg.trap_number == 75)
    {
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_TRAP;
    }
  else
  exit:
    {
      status->kind = TARGET_WAITKIND_EXITED;
      status->value.integer = 0;
    }

  timeout = old_timeout;	/* Restore original timeout value */
  immediate_quit = old_immediate_quit;
  return inferior_ptid;
}

/******************************************************* REMOTE_FETCH_REGISTERS
 * Read a remote register 'regno'. 
 * If regno==-1 then read all the registers.
 */
static void
mm_fetch_registers (int regno)
{
  INT32 *data_p;

  if (regno >= 0)
    {
      fetch_register (regno);
      return;
    }

/* Gr1/rsp */
  out_msg_buf->read_req_msg.byte_count = 4 * 1;
  out_msg_buf->read_req_msg.memory_space = GLOBAL_REG;
  out_msg_buf->read_req_msg.address = 1;
  msg_send_serial (out_msg_buf);
  expect_msg (READ_ACK, in_msg_buf, 1);
  data_p = &(in_msg_buf->read_r_ack_msg.data[0]);
  supply_register (GR1_REGNUM, data_p);

#if defined(GR64_REGNUM)	/* Read gr64-127 */
/* Global Registers gr64-gr95 */
  out_msg_buf->read_req_msg.code = READ_REQ;
  out_msg_buf->read_req_msg.length = 4 * 3;
  out_msg_buf->read_req_msg.byte_count = 4 * 32;
  out_msg_buf->read_req_msg.memory_space = GLOBAL_REG;
  out_msg_buf->read_req_msg.address = 64;
  msg_send_serial (out_msg_buf);
  expect_msg (READ_ACK, in_msg_buf, 1);
  data_p = &(in_msg_buf->read_r_ack_msg.data[0]);

  for (regno = GR64_REGNUM; regno < GR64_REGNUM + 32; regno++)
    {
      supply_register (regno, data_p++);
    }
#endif /*  GR64_REGNUM */

/* Global Registers gr96-gr127 */
  out_msg_buf->read_req_msg.code = READ_REQ;
  out_msg_buf->read_req_msg.length = 4 * 3;
  out_msg_buf->read_req_msg.byte_count = 4 * 32;
  out_msg_buf->read_req_msg.memory_space = GLOBAL_REG;
  out_msg_buf->read_req_msg.address = 96;
  msg_send_serial (out_msg_buf);
  expect_msg (READ_ACK, in_msg_buf, 1);
  data_p = &(in_msg_buf->read_r_ack_msg.data[0]);

  for (regno = GR96_REGNUM; regno < GR96_REGNUM + 32; regno++)
    {
      supply_register (regno, data_p++);
    }

/* Local Registers */
  out_msg_buf->read_req_msg.byte_count = 4 * (128);
  out_msg_buf->read_req_msg.memory_space = LOCAL_REG;
  out_msg_buf->read_req_msg.address = 0;
  msg_send_serial (out_msg_buf);
  expect_msg (READ_ACK, in_msg_buf, 1);
  data_p = &(in_msg_buf->read_r_ack_msg.data[0]);

  for (regno = LR0_REGNUM; regno < LR0_REGNUM + 128; regno++)
    {
      supply_register (regno, data_p++);
    }

/* Protected Special Registers */
  out_msg_buf->read_req_msg.byte_count = 4 * 15;
  out_msg_buf->read_req_msg.memory_space = SPECIAL_REG;
  out_msg_buf->read_req_msg.address = 0;
  msg_send_serial (out_msg_buf);
  expect_msg (READ_ACK, in_msg_buf, 1);
  data_p = &(in_msg_buf->read_r_ack_msg.data[0]);

  for (regno = 0; regno <= 14; regno++)
    {
      supply_register (SR_REGNUM (regno), data_p++);
    }
  if (USE_SHADOW_PC)
    {				/* Let regno_to_srnum() handle the register number */
      fetch_register (NPC_REGNUM);
      fetch_register (PC_REGNUM);
      fetch_register (PC2_REGNUM);
    }

/* Unprotected Special Registers */
  out_msg_buf->read_req_msg.byte_count = 4 * 8;
  out_msg_buf->read_req_msg.memory_space = SPECIAL_REG;
  out_msg_buf->read_req_msg.address = 128;
  msg_send_serial (out_msg_buf);
  expect_msg (READ_ACK, in_msg_buf, 1);
  data_p = &(in_msg_buf->read_r_ack_msg.data[0]);

  for (regno = 128; regno <= 135; regno++)
    {
      supply_register (SR_REGNUM (regno), data_p++);
    }

  /* There doesn't seem to be any way to get these.  */
  {
    int val = -1;
    supply_register (FPE_REGNUM, &val);
    supply_register (INTE_REGNUM, &val);
    supply_register (FPS_REGNUM, &val);
    supply_register (EXO_REGNUM, &val);
  }
}


/****************************************************** REMOTE_STORE_REGISTERS
 * Store register regno into the target.  
 * If regno==-1 then store all the registers.
 * Result is 0 for success, -1 for failure.
 */

static void
mm_store_registers (int regno)
{
  int result;

  if (regno >= 0)
    {
      store_register (regno);
      return;
    }

  result = 0;

  out_msg_buf->write_r_msg.code = WRITE_REQ;

/* Gr1/rsp */
  out_msg_buf->write_r_msg.byte_count = 4 * 1;
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
  out_msg_buf->write_r_msg.memory_space = GLOBAL_REG;
  out_msg_buf->write_r_msg.address = 1;
  out_msg_buf->write_r_msg.data[0] = read_register (GR1_REGNUM);

  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
    }

#if defined(GR64_REGNUM)
/* Global registers gr64-gr95 */
  out_msg_buf->write_r_msg.byte_count = 4 * (32);
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
  out_msg_buf->write_r_msg.address = 64;

  for (regno = GR64_REGNUM; regno < GR64_REGNUM + 32; regno++)
    {
      out_msg_buf->write_r_msg.data[regno - GR64_REGNUM] = read_register (regno);
    }
  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
    }
#endif /* GR64_REGNUM */

/* Global registers gr96-gr127 */
  out_msg_buf->write_r_msg.byte_count = 4 * (32);
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
  out_msg_buf->write_r_msg.address = 96;
  for (regno = GR96_REGNUM; regno < GR96_REGNUM + 32; regno++)
    {
      out_msg_buf->write_r_msg.data[regno - GR96_REGNUM] = read_register (regno);
    }
  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
    }

/* Local Registers */
  out_msg_buf->write_r_msg.memory_space = LOCAL_REG;
  out_msg_buf->write_r_msg.byte_count = 4 * 128;
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
  out_msg_buf->write_r_msg.address = 0;

  for (regno = LR0_REGNUM; regno < LR0_REGNUM + 128; regno++)
    {
      out_msg_buf->write_r_msg.data[regno - LR0_REGNUM] = read_register (regno);
    }
  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
    }

/* Protected Special Registers */
  /* VAB through TMR */
  out_msg_buf->write_r_msg.memory_space = SPECIAL_REG;
  out_msg_buf->write_r_msg.byte_count = 4 * 10;
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
  out_msg_buf->write_r_msg.address = 0;
  for (regno = 0; regno <= 9; regno++)	/* VAB through TMR */
    out_msg_buf->write_r_msg.data[regno] = read_register (SR_REGNUM (regno));
  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
    }

  /* PC0, PC1, PC2 possibly as shadow registers */
  out_msg_buf->write_r_msg.byte_count = 4 * 3;
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
  for (regno = 10; regno <= 12; regno++)	/* LRU and MMU */
    out_msg_buf->write_r_msg.data[regno - 10] = read_register (SR_REGNUM (regno));
  if (USE_SHADOW_PC)
    out_msg_buf->write_r_msg.address = 20;	/* SPC0 */
  else
    out_msg_buf->write_r_msg.address = 10;	/* PC0 */
  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
    }

  /* LRU and MMU */
  out_msg_buf->write_r_msg.byte_count = 4 * 2;
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
  out_msg_buf->write_r_msg.address = 13;
  for (regno = 13; regno <= 14; regno++)	/* LRU and MMU */
    out_msg_buf->write_r_msg.data[regno - 13] = read_register (SR_REGNUM (regno));
  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
    }

/* Unprotected Special Registers */
  out_msg_buf->write_r_msg.byte_count = 4 * 8;
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
  out_msg_buf->write_r_msg.address = 128;
  for (regno = 128; regno <= 135; regno++)
    out_msg_buf->write_r_msg.data[regno - 128] = read_register (SR_REGNUM (regno));
  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
    }

  registers_changed ();
}

/*************************************************** REMOTE_PREPARE_TO_STORE */
/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
mm_prepare_to_store (void)
{
  /* Do nothing, since we can store individual regs */
}

/******************************************************* REMOTE_XFER_MEMORY */
static CORE_ADDR
translate_addr (CORE_ADDR addr)
{
#if defined(KERNEL_DEBUGGING)
  /* Check for a virtual address in the kernel */
  /* Assume physical address of ublock is in  paddr_u register */
  /* FIXME: doesn't work for user virtual addresses */
  if (addr >= UVADDR)
    {
      /* PADDR_U register holds the physical address of the ublock */
      CORE_ADDR i = (CORE_ADDR) read_register (PADDR_U_REGNUM);
      return (i + addr - (CORE_ADDR) UVADDR);
    }
  else
    {
      return (addr);
    }
#else
  return (addr);
#endif
}

/******************************************************* REMOTE_FILES_INFO */
static void
mm_files_info (void)
{
  printf ("\tAttached to %s at %d baud and running program %s.\n",
	  dev_name, baudrate, prog_name);
}

/************************************************* REMOTE_INSERT_BREAKPOINT */
static int
mm_insert_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  out_msg_buf->bkpt_set_msg.code = BKPT_SET;
  out_msg_buf->bkpt_set_msg.length = 4 * 4;
  out_msg_buf->bkpt_set_msg.memory_space = I_MEM;
  out_msg_buf->bkpt_set_msg.bkpt_addr = (ADDR32) addr;
  out_msg_buf->bkpt_set_msg.pass_count = 1;
  out_msg_buf->bkpt_set_msg.bkpt_type = -1;	/* use illop for 29000 */
  msg_send_serial (out_msg_buf);
  if (expect_msg (BKPT_SET_ACK, in_msg_buf, 1))
    {
      return 0;			/* Success */
    }
  else
    {
      return 1;			/* Failure */
    }
}

/************************************************* REMOTE_DELETE_BREAKPOINT */
static int
mm_remove_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  out_msg_buf->bkpt_rm_msg.code = BKPT_RM;
  out_msg_buf->bkpt_rm_msg.length = 4 * 3;
  out_msg_buf->bkpt_rm_msg.memory_space = I_MEM;
  out_msg_buf->bkpt_rm_msg.bkpt_addr = (ADDR32) addr;
  msg_send_serial (out_msg_buf);
  if (expect_msg (BKPT_RM_ACK, in_msg_buf, 1))
    {
      return 0;			/* Success */
    }
  else
    {
      return 1;			/* Failure */
    }
}


/******************************************************* REMOTE_KILL */
static void
mm_kill (char *arg, int from_tty)
{
  char buf[4];

#if defined(KERNEL_DEBUGGING)
  /* We don't ever kill the kernel */
  if (from_tty)
    {
      printf ("Kernel not killed, but left in current state.\n");
      printf ("Use detach to leave kernel running.\n");
    }
#else
  out_msg_buf->break_msg.code = BREAK;
  out_msg_buf->bkpt_set_msg.length = 4 * 0;
  expect_msg (HALT, in_msg_buf, from_tty);
  if (from_tty)
    {
      printf ("Target has been stopped.");
      printf ("Would you like to do a hardware reset (y/n) [n] ");
      fgets (buf, 3, stdin);
      if (buf[0] == 'y')
	{
	  out_msg_buf->reset_msg.code = RESET;
	  out_msg_buf->bkpt_set_msg.length = 4 * 0;
	  expect_msg (RESET_ACK, in_msg_buf, from_tty);
	  printf ("Target has been reset.");
	}
    }
  pop_target ();
#endif
}



/***************************************************************************/
/* 
 * Load a program into the target.
 */
static void
mm_load (char *arg_string, int from_tty)
{
  dont_repeat ();

#if defined(KERNEL_DEBUGGING)
  printf ("The kernel had better be loaded already!  Loading not done.\n");
#else
  if (arg_string == 0)
    error ("The load command takes a file name");

  arg_string = tilde_expand (arg_string);
  make_cleanup (xfree, arg_string);
  QUIT;
  immediate_quit++;
  error ("File loading is not yet supported for MiniMon.");
  /* FIXME, code to load your file here... */
  /* You may need to do an init_target_mm() */
  /* init_target_mm(?,?,?,?,?,?,?,?); */
  immediate_quit--;
  /* symbol_file_add (arg_string, from_tty, text_addr, 0, 0); */
#endif

}

/************************************************ REMOTE_WRITE_INFERIOR_MEMORY
** Copy LEN bytes of data from debugger memory at MYADDR
   to inferior's memory at MEMADDR.  Returns number of bytes written.  */
static int
mm_write_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  int i, nwritten;

  out_msg_buf->write_req_msg.code = WRITE_REQ;
  out_msg_buf->write_req_msg.memory_space = mm_memory_space (memaddr);

  nwritten = 0;
  while (nwritten < len)
    {
      int num_to_write = len - nwritten;
      if (num_to_write > MAXDATA)
	num_to_write = MAXDATA;
      for (i = 0; i < num_to_write; i++)
	out_msg_buf->write_req_msg.data[i] = myaddr[i + nwritten];
      out_msg_buf->write_req_msg.byte_count = num_to_write;
      out_msg_buf->write_req_msg.length = 3 * 4 + num_to_write;
      out_msg_buf->write_req_msg.address = memaddr + nwritten;
      msg_send_serial (out_msg_buf);

      if (expect_msg (WRITE_ACK, in_msg_buf, 1))
	{
	  nwritten += in_msg_buf->write_ack_msg.byte_count;
	}
      else
	{
	  break;
	}
    }
  return (nwritten);
}

/************************************************* REMOTE_READ_INFERIOR_MEMORY
** Read LEN bytes from inferior memory at MEMADDR.  Put the result
   at debugger address MYADDR.  Returns number of bytes read.  */
static int
mm_read_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  int i, nread;

  out_msg_buf->read_req_msg.code = READ_REQ;
  out_msg_buf->read_req_msg.memory_space = mm_memory_space (memaddr);

  nread = 0;
  while (nread < len)
    {
      int num_to_read = (len - nread);
      if (num_to_read > MAXDATA)
	num_to_read = MAXDATA;
      out_msg_buf->read_req_msg.byte_count = num_to_read;
      out_msg_buf->read_req_msg.length = 3 * 4 + num_to_read;
      out_msg_buf->read_req_msg.address = memaddr + nread;
      msg_send_serial (out_msg_buf);

      if (expect_msg (READ_ACK, in_msg_buf, 1))
	{
	  for (i = 0; i < in_msg_buf->read_ack_msg.byte_count; i++)
	    myaddr[i + nread] = in_msg_buf->read_ack_msg.data[i];
	  nread += in_msg_buf->read_ack_msg.byte_count;
	}
      else
	{
	  break;
	}
    }
  return (nread);
}

/* FIXME!  Merge these two.  */
static int
mm_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
			 struct mem_attrib *attrib ATTRIBUTE_UNUSED,
			 struct target_ops *target ATTRIBUTE_UNUSED)
{

  memaddr = translate_addr (memaddr);

  if (write)
    return mm_write_inferior_memory (memaddr, myaddr, len);
  else
    return mm_read_inferior_memory (memaddr, myaddr, len);
}


/********************************************************** MSG_SEND_SERIAL
** This function is used to send a message over the
** serial line.
**
** If the message is successfully sent, a zero is
** returned.  If the message was not sendable, a -1
** is returned.  This function blocks.  That is, it
** does not return until the message is completely
** sent, or until an error is encountered.
**
*/

int
msg_send_serial (union msg_t *msg_ptr)
{
  INT32 message_size;
  int byte_count;
  int result;
  char c;

  /* Send message header */
  byte_count = 0;
  message_size = msg_ptr->generic_msg.length + (2 * sizeof (INT32));
  do
    {
      c = *((char *) msg_ptr + byte_count);
      result = write (mm_desc, &c, 1);
      if (result == 1)
	{
	  byte_count = byte_count + 1;
	}
    }
  while ((byte_count < message_size));

  return (0);
}				/* end msg_send_serial() */

/********************************************************** MSG_RECV_SERIAL
** This function is used to receive a message over a
** serial line.
**
** If the message is waiting in the buffer, a zero is
** returned and the buffer pointed to by msg_ptr is filled
** in.  If no message was available, a -1 is returned.
** If timeout==0, wait indefinetly for a character.
**
*/

int
msg_recv_serial (union msg_t *msg_ptr)
{
  static INT32 length = 0;
  static INT32 byte_count = 0;
  int result;
  char c;
  if (msg_ptr == 0)		/* re-sync request */
    {
      length = 0;
      byte_count = 0;
#ifdef HAVE_TERMIO
      /* The timeout here is the prevailing timeout set with VTIME */
      ->"timeout==0 semantics not supported"
	read (mm_desc, in_buf, BUFER_SIZE);
#else
      alarm (1);
      read (mm_desc, in_buf, BUFER_SIZE);
      alarm (0);
#endif
      return (0);
    }
  /* Receive message */
#ifdef HAVE_TERMIO
/* Timeout==0, help support the mm_wait() routine */
  ->"timeout==0 semantics not supported (and its nice if they are)"
    result = read (mm_desc, &c, 1);
#else
  alarm (timeout);
  result = read (mm_desc, &c, 1);
  alarm (0);
#endif
  if (result < 0)
    {
      if (errno == EINTR)
	{
	  error ("Timeout reading from remote system.");
	}
      else
	perror_with_name ("remote");
    }
  else if (result == 1)
    {
      *((char *) msg_ptr + byte_count) = c;
      byte_count = byte_count + 1;
    }

  /* Message header received.  Save message length. */
  if (byte_count == (2 * sizeof (INT32)))
    length = msg_ptr->generic_msg.length;

  if (byte_count >= (length + (2 * sizeof (INT32))))
    {
      /* Message received */
      byte_count = 0;
      return (0);
    }
  else
    return (-1);

}				/* end msg_recv_serial() */

/********************************************************************* KBD_RAW
** This function is used to put the keyboard in "raw"
** mode for BSD Unix.  The original status is saved
** so that it may be restored later.
*/
TERMINAL kbd_tbuf;

int
kbd_raw (void)
{
  int result;
  TERMINAL tbuf;

  /* Get keyboard termio (to save to restore original modes) */
#ifdef HAVE_TERMIO
  result = ioctl (0, TCGETA, &kbd_tbuf);
#else
  result = ioctl (0, TIOCGETP, &kbd_tbuf);
#endif
  if (result == -1)
    return (errno);

  /* Get keyboard TERMINAL (for modification) */
#ifdef HAVE_TERMIO
  result = ioctl (0, TCGETA, &tbuf);
#else
  result = ioctl (0, TIOCGETP, &tbuf);
#endif
  if (result == -1)
    return (errno);

  /* Set up new parameters */
#ifdef HAVE_TERMIO
  tbuf.c_iflag = tbuf.c_iflag &
    ~(INLCR | ICRNL | IUCLC | ISTRIP | IXON | BRKINT);
  tbuf.c_lflag = tbuf.c_lflag & ~(ICANON | ISIG | ECHO);
  tbuf.c_cc[4] = 0;		/* MIN */
  tbuf.c_cc[5] = 0;		/* TIME */
#else
  /* FIXME: not sure if this is correct (matches HAVE_TERMIO). */
  tbuf.sg_flags |= RAW;
  tbuf.sg_flags |= ANYP;
  tbuf.sg_flags &= ~ECHO;
#endif

  /* Set keyboard termio to new mode (RAW) */
#ifdef HAVE_TERMIO
  result = ioctl (0, TCSETAF, &tbuf);
#else
  result = ioctl (0, TIOCSETP, &tbuf);
#endif
  if (result == -1)
    return (errno);

  return (0);
}				/* end kbd_raw() */



/***************************************************************** KBD_RESTORE
** This function is used to put the keyboard back in the
** mode it was in before kbk_raw was called.  Note that
** kbk_raw() must have been called at least once before
** kbd_restore() is called.
*/

int
kbd_restore (void)
{
  int result;

  /* Set keyboard termio to original mode */
#ifdef HAVE_TERMIO
  result = ioctl (0, TCSETAF, &kbd_tbuf);
#else
  result = ioctl (0, TIOCGETP, &kbd_tbuf);
#endif

  if (result == -1)
    return (errno);

  return (0);
}				/* end kbd_cooked() */


/*****************************************************************************/
/* Fetch a single register indicatated by 'regno'. 
 * Returns 0/-1 on success/failure.  
 */
static int
fetch_register (int regno)
{
  int result;
  out_msg_buf->read_req_msg.code = READ_REQ;
  out_msg_buf->read_req_msg.length = 4 * 3;
  out_msg_buf->read_req_msg.byte_count = 4;

  if (regno == GR1_REGNUM)
    {
      out_msg_buf->read_req_msg.memory_space = GLOBAL_REG;
      out_msg_buf->read_req_msg.address = 1;
    }
  else if (regno >= GR96_REGNUM && regno < GR96_REGNUM + 32)
    {
      out_msg_buf->read_req_msg.memory_space = GLOBAL_REG;
      out_msg_buf->read_req_msg.address = (regno - GR96_REGNUM) + 96;
    }
#if defined(GR64_REGNUM)
  else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32)
    {
      out_msg_buf->read_req_msg.memory_space = GLOBAL_REG;
      out_msg_buf->read_req_msg.address = (regno - GR64_REGNUM) + 64;
    }
#endif /* GR64_REGNUM */
  else if (regno >= LR0_REGNUM && regno < LR0_REGNUM + 128)
    {
      out_msg_buf->read_req_msg.memory_space = LOCAL_REG;
      out_msg_buf->read_req_msg.address = (regno - LR0_REGNUM);
    }
  else if (regno >= FPE_REGNUM && regno <= EXO_REGNUM)
    {
      int val = -1;
      supply_register (160 + (regno - FPE_REGNUM), &val);
      return 0;			/* Pretend Success */
    }
  else
    {
      out_msg_buf->read_req_msg.memory_space = SPECIAL_REG;
      out_msg_buf->read_req_msg.address = regnum_to_srnum (regno);
    }

  msg_send_serial (out_msg_buf);

  if (expect_msg (READ_ACK, in_msg_buf, 1))
    {
      supply_register (regno, &(in_msg_buf->read_r_ack_msg.data[0]));
      result = 0;
    }
  else
    {
      result = -1;
    }
  return result;
}
/*****************************************************************************/
/* Store a single register indicated by 'regno'. 
 * Returns 0/-1 on success/failure.  
 */
static int
store_register (int regno)
{
  int result;

  out_msg_buf->write_req_msg.code = WRITE_REQ;
  out_msg_buf->write_req_msg.length = 4 * 4;
  out_msg_buf->write_req_msg.byte_count = 4;
  out_msg_buf->write_r_msg.data[0] = read_register (regno);

  if (regno == GR1_REGNUM)
    {
      out_msg_buf->write_req_msg.memory_space = GLOBAL_REG;
      out_msg_buf->write_req_msg.address = 1;
      /* Setting GR1 changes the numbers of all the locals, so invalidate the 
       * register cache.  Do this *after* calling read_register, because we want 
       * read_register to return the value that write_register has just stuffed 
       * into the registers array, not the value of the register fetched from 
       * the inferior.  
       */
      registers_changed ();
    }
#if defined(GR64_REGNUM)
  else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32)
    {
      out_msg_buf->write_req_msg.memory_space = GLOBAL_REG;
      out_msg_buf->write_req_msg.address = (regno - GR64_REGNUM) + 64;
    }
#endif /* GR64_REGNUM */
  else if (regno >= GR96_REGNUM && regno < GR96_REGNUM + 32)
    {
      out_msg_buf->write_req_msg.memory_space = GLOBAL_REG;
      out_msg_buf->write_req_msg.address = (regno - GR96_REGNUM) + 96;
    }
  else if (regno >= LR0_REGNUM && regno < LR0_REGNUM + 128)
    {
      out_msg_buf->write_req_msg.memory_space = LOCAL_REG;
      out_msg_buf->write_req_msg.address = (regno - LR0_REGNUM);
    }
  else if (regno >= FPE_REGNUM && regno <= EXO_REGNUM)
    {
      return 0;			/* Pretend Success */
    }
  else
    /* An unprotected or protected special register */
    {
      out_msg_buf->write_req_msg.memory_space = SPECIAL_REG;
      out_msg_buf->write_req_msg.address = regnum_to_srnum (regno);
    }

  msg_send_serial (out_msg_buf);

  if (expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = 0;
    }
  else
    {
      result = -1;
    }
  return result;
}
/****************************************************************************/
/* 
 * Convert a gdb special register number to a 29000 special register number.
 */
static int
regnum_to_srnum (int regno)
{
  switch (regno)
    {
    case VAB_REGNUM:
      return (0);
    case OPS_REGNUM:
      return (1);
    case CPS_REGNUM:
      return (2);
    case CFG_REGNUM:
      return (3);
    case CHA_REGNUM:
      return (4);
    case CHD_REGNUM:
      return (5);
    case CHC_REGNUM:
      return (6);
    case RBP_REGNUM:
      return (7);
    case TMC_REGNUM:
      return (8);
    case TMR_REGNUM:
      return (9);
    case NPC_REGNUM:
      return (USE_SHADOW_PC ? (20) : (10));
    case PC_REGNUM:
      return (USE_SHADOW_PC ? (21) : (11));
    case PC2_REGNUM:
      return (USE_SHADOW_PC ? (22) : (12));
    case MMU_REGNUM:
      return (13);
    case LRU_REGNUM:
      return (14);
    case IPC_REGNUM:
      return (128);
    case IPA_REGNUM:
      return (129);
    case IPB_REGNUM:
      return (130);
    case Q_REGNUM:
      return (131);
    case ALU_REGNUM:
      return (132);
    case BP_REGNUM:
      return (133);
    case FC_REGNUM:
      return (134);
    case CR_REGNUM:
      return (135);
    case FPE_REGNUM:
      return (160);
    case INTE_REGNUM:
      return (161);
    case FPS_REGNUM:
      return (162);
    case EXO_REGNUM:
      return (164);
    default:
      return (255);		/* Failure ? */
    }
}
/****************************************************************************/
/* 
 * Initialize the target debugger (minimon only).
 */
static void
init_target_mm (ADDR32 tstart, ADDR32 tend, ADDR32 dstart, ADDR32 dend,
		ADDR32 entry, INT32 ms_size, INT32 rs_size, ADDR32 arg_start)
{
  out_msg_buf->init_msg.code = INIT;
  out_msg_buf->init_msg.length = sizeof (struct init_msg_t) - 2 * sizeof (INT32);
  out_msg_buf->init_msg.text_start = tstart;
  out_msg_buf->init_msg.text_end = tend;
  out_msg_buf->init_msg.data_start = dstart;
  out_msg_buf->init_msg.data_end = dend;
  out_msg_buf->init_msg.entry_point = entry;
  out_msg_buf->init_msg.mem_stack_size = ms_size;
  out_msg_buf->init_msg.reg_stack_size = rs_size;
  out_msg_buf->init_msg.arg_start = arg_start;
  msg_send_serial (out_msg_buf);
  expect_msg (INIT_ACK, in_msg_buf, 1);
}
/****************************************************************************/
/* 
 * Return a pointer to a string representing the given message code.
 * Not all messages are represented here, only the ones that we expect
 * to be called with.
 */
static char *
msg_str (INT32 code)
{
  static char cbuf[32];

  switch (code)
    {
    case BKPT_SET_ACK:
      sprintf (cbuf, "%s (%d)", "BKPT_SET_ACK", code);
      break;
    case BKPT_RM_ACK:
      sprintf (cbuf, "%s (%d)", "BKPT_RM_ACK", code);
      break;
    case INIT_ACK:
      sprintf (cbuf, "%s (%d)", "INIT_ACK", code);
      break;
    case READ_ACK:
      sprintf (cbuf, "%s (%d)", "READ_ACK", code);
      break;
    case WRITE_ACK:
      sprintf (cbuf, "%s (%d)", "WRITE_ACK", code);
      break;
    case ERROR:
      sprintf (cbuf, "%s (%d)", "ERROR", code);
      break;
    case HALT:
      sprintf (cbuf, "%s (%d)", "HALT", code);
      break;
    default:
      sprintf (cbuf, "UNKNOWN (%d)", code);
      break;
    }
  return (cbuf);
}
/****************************************************************************/
/*
 * Selected (not all of them) error codes that we might get.
 */
static char *
error_msg_str (INT32 code)
{
  static char cbuf[50];

  switch (code)
    {
    case EMFAIL:
      return ("EMFAIL: unrecoverable error");
    case EMBADADDR:
      return ("EMBADADDR: Illegal address");
    case EMBADREG:
      return ("EMBADREG: Illegal register ");
    case EMACCESS:
      return ("EMACCESS: Could not access memory");
    case EMBADMSG:
      return ("EMBADMSG: Unknown message type");
    case EMMSG2BIG:
      return ("EMMSG2BIG: Message to large");
    case EMNOSEND:
      return ("EMNOSEND: Could not send message");
    case EMNORECV:
      return ("EMNORECV: Could not recv message");
    case EMRESET:
      return ("EMRESET: Could not RESET target");
    case EMCONFIG:
      return ("EMCONFIG: Could not get target CONFIG");
    case EMSTATUS:
      return ("EMSTATUS: Could not get target STATUS");
    case EMREAD:
      return ("EMREAD: Could not READ target memory");
    case EMWRITE:
      return ("EMWRITE: Could not WRITE target memory");
    case EMBKPTSET:
      return ("EMBKPTSET: Could not set breakpoint");
    case EMBKPTRM:
      return ("EMBKPTRM: Could not remove breakpoint");
    case EMBKPTSTAT:
      return ("EMBKPTSTAT: Could not get breakpoint status");
    case EMBKPTNONE:
      return ("EMBKPTNONE: All breakpoints in use");
    case EMBKPTUSED:
      return ("EMBKPTUSED: Breakpoints already in use");
    case EMINIT:
      return ("EMINIT: Could not init target memory");
    case EMGO:
      return ("EMGO: Could not start execution");
    case EMSTEP:
      return ("EMSTEP: Could not single step");
    case EMBREAK:
      return ("EMBREAK: Could not BREAK");
    case EMCOMMERR:
      return ("EMCOMMERR: Communication error");
    default:
      sprintf (cbuf, "error number %d", code);
      break;
    }				/* end switch */

  return (cbuf);
}
/****************************************************************************/

/* Receive a message, placing it in MSG_BUF, and expect it to be of
   type MSGCODE.  If an error occurs, a non-zero FROM_TTY indicates
   that the message should be printed.
   
   Return 0 for failure, 1 for success.  */

static int
expect_msg (INT32 msgcode, union msg_t *msg_buf, int from_tty)
{
  int retries = 0;
  while (msg_recv_serial (msg_buf) && (retries++ < MAX_RETRIES));
  if (retries >= MAX_RETRIES)
    {
      printf ("Expected msg %s, ", msg_str (msgcode));
      printf ("no message received!\n");
      return (0);		/* Failure */
    }

  if (msg_buf->generic_msg.code != msgcode)
    {
      if (from_tty)
	{
	  printf ("Expected msg %s, ", msg_str (msgcode));
	  printf ("got msg %s\n", msg_str (msg_buf->generic_msg.code));
	  if (msg_buf->generic_msg.code == ERROR)
	    printf ("%s\n", error_msg_str (msg_buf->error_msg.error_code));
	}
      return (0);		/* Failure */
    }
  return (1);			/* Success */
}
/****************************************************************************/
/*
 * Determine the MiniMon memory space qualifier based on the addr. 
 * FIXME: Can't distinguis I_ROM/D_ROM.  
 * FIXME: Doesn't know anything about I_CACHE/D_CACHE.
 */
static int
mm_memory_space (CORE_ADDR *addr)
{
  ADDR32 tstart = target_config.I_mem_start;
  ADDR32 tend = tstart + target_config.I_mem_size;
  ADDR32 dstart = target_config.D_mem_start;
  ADDR32 dend = tstart + target_config.D_mem_size;
  ADDR32 rstart = target_config.ROM_start;
  ADDR32 rend = tstart + target_config.ROM_size;

  if (((ADDR32) addr >= tstart) && ((ADDR32) addr < tend))
    {
      return I_MEM;
    }
  else if (((ADDR32) addr >= dstart) && ((ADDR32) addr < dend))
    {
      return D_MEM;
    }
  else if (((ADDR32) addr >= rstart) && ((ADDR32) addr < rend))
    {
      /* FIXME: how do we determine between D_ROM and I_ROM */
      return D_ROM;
    }
  else				/* FIXME: what do me do now? */
    return D_MEM;		/* Hmmm! */
}

/****************************************************************************/
/* 
 *  Define the target subroutine names
 */
struct target_ops mm_ops;

static void
init_mm_ops (void)
{
  mm_ops.to_shortname = "minimon";
  mm_ops.to_longname = "Remote AMD/Minimon target";
  mm_ops.to_doc = "Remote debug an AMD 290*0 using the MiniMon dbg core on the target";
  mm_ops.to_open = mm_open;
  mm_ops.to_close = mm_close;
  mm_ops.to_attach = mm_attach;
  mm_ops.to_post_attach = NULL;
  mm_ops.to_require_attach = NULL;
  mm_ops.to_detach = mm_detach;
  mm_ops.to_require_detach = NULL;
  mm_ops.to_resume = mm_resume;
  mm_ops.to_wait = mm_wait;
  mm_ops.to_post_wait = NULL;
  mm_ops.to_fetch_registers = mm_fetch_registers;
  mm_ops.to_store_registers = mm_store_registers;
  mm_ops.to_prepare_to_store = mm_prepare_to_store;
  mm_ops.to_xfer_memory = mm_xfer_inferior_memory;
  mm_ops.to_files_info = mm_files_info;
  mm_ops.to_insert_breakpoint = mm_insert_breakpoint;
  mm_ops.to_remove_breakpoint = mm_remove_breakpoint;
  mm_ops.to_terminal_init = 0;
  mm_ops.to_terminal_inferior = 0;
  mm_ops.to_terminal_ours_for_output = 0;
  mm_ops.to_terminal_ours = 0;
  mm_ops.to_terminal_info = 0;
  mm_ops.to_kill = mm_kill;
  mm_ops.to_load = mm_load;
  mm_ops.to_lookup_symbol = 0;
  mm_ops.to_create_inferior = mm_create_inferior;
  mm_ops.to_post_startup_inferior = NULL;
  mm_ops.to_acknowledge_created_inferior = NULL;
  mm_ops.to_clone_and_follow_inferior = NULL;
  mm_ops.to_post_follow_inferior_by_clone = NULL;
  mm_ops.to_insert_fork_catchpoint = NULL;
  mm_ops.to_remove_fork_catchpoint = NULL;
  mm_ops.to_insert_vfork_catchpoint = NULL;
  mm_ops.to_remove_vfork_catchpoint = NULL;
  mm_ops.to_has_forked = NULL;
  mm_ops.to_has_vforked = NULL;
  mm_ops.to_can_follow_vfork_prior_to_exec = NULL;
  mm_ops.to_post_follow_vfork = NULL;
  mm_ops.to_insert_exec_catchpoint = NULL;
  mm_ops.to_remove_exec_catchpoint = NULL;
  mm_ops.to_has_execd = NULL;
  mm_ops.to_reported_exec_events_per_exec_call = NULL;
  mm_ops.to_has_exited = NULL;
  mm_ops.to_mourn_inferior = mm_mourn;
  mm_ops.to_can_run = 0;
  mm_ops.to_notice_signals = 0;
  mm_ops.to_thread_alive = 0;
  mm_ops.to_stop = 0;
  mm_ops.to_pid_to_exec_file = NULL;
  mm_ops.to_stratum = process_stratum;
  mm_ops.DONT_USE = 0;
  mm_ops.to_has_all_memory = 1;
  mm_ops.to_has_memory = 1;
  mm_ops.to_has_stack = 1;
  mm_ops.to_has_registers = 1;
  mm_ops.to_has_execution = 1;
  mm_ops.to_sections = 0;
  mm_ops.to_sections_end = 0;
  mm_ops.to_magic = OPS_MAGIC;
};

void
_initialize_remote_mm (void)
{
  init_mm_ops ();
  add_target (&mm_ops);
}

#ifdef NO_HIF_SUPPORT
service_HIF (union msg_t *msg)
{
  return (0);			/* Emulate a failure */
}
#endif
@


1.11
log
@* target.h (target_ops): Removed to_core_file_to_sym_file vector
function.
* corelow.c (core_ops): Updated for above change.
* gnu-nat.c (core_ops): Likewise.
* inftarg.c (child_ops): Likewise.
* monitor.c (monitor_ops): Likewise.
* ppc-bdm.c (bdm_ppc_ops): Likewise.
* remote-adapt.c (adapt_ops): Likewise.
* remote-bug.c (bug_ops): Likewise.
* remote-e7000.c (e7000_ops): Likewise.
* remote-eb.c (eb_ops): Likewise.
* remote-es.c (es1800_ops, es1800_child_ops): Likewise.
* remote-mm.c (mm_ops): Likewise.
* remote-nindy.c (nindy_ops): Likewise.
* remote-nrom.c (nrom_ops): Likewise.
* remote-os9k.c (rombug_ops): Likewise.
* remote-rdp.c (remote_rdp_ops): Likewise.
* remote-sim.c (gdbsim_ops): Likewise.
* remote-st.c (st2000_ops): Likewise.
* v850ice.c (v850ice_ops): Likewise.
* target.c (cleanup_target): Likewise
(update_current_target): Likewise.
(setup_target_debug): Likewise
(debug_to_core_file_to_sym_file): Removed.

* corefile.c (core_file_command) [HPUXHPPA]: Removed code that
sets symbol file from information obtained from the core file.
* corelow.c (core_file_to_sym_file): Removed.
@
text
@d54 1
a54 1
static void mm_resume ();
d526 1
a526 1
mm_resume (int pid, int step, enum target_signal sig)
d550 2
a551 2
static int
mm_wait (struct target_waitstatus *status)
d695 1
a695 1
  return 0;
@


1.10
log
@Eliminate some uses of __STDC__.
@
text
@a1823 1
  mm_ops.to_core_file_to_sym_file = NULL;
@


1.9
log
@Update/correct copyright notices.
@
text
@a120 6
#ifndef __STDC__
#ifndef volatile
#define volatile
/**/
# endif
#endif
@


1.8
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 2001 Free Software Foundation, Inc.
@


1.7
log
@* monitor.c (#include "gdb_wait.h"): Removed.
* ocd.c: Likewise.
* ppc-bdm.c: Likewise.
* remote-adapt.c: Likewise.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-eb.c: Likewise.
* remote-es.c: Likewise.
* remote-mips.c: Likewise.
* remote-mm.c: Likewise.
* remote-nindy.c: Likewise.
* remote-os9k.c: Likewise.
* remote-rdi.c: Likewise.
* remote-rdp.c: Likewise.
* remote-sds.c: Likewise.
* remote-sim.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
* remote.c: Likewise.
* ser-pipe.c: Likewise.
* ser-unix.c: Likewise.
* Makefile.in: Updated dependencies.
-------------------------------------------------------------------
@
text
@d44 1
@


1.6
log
@* exec.c (xfer_memory): Add attrib argument.
* infptrace.c (child_xfer_memory): Likewise.
* monitor.c (monitor_xfer_memory): Likewise.
* remote-adapt.c (adapt_xfer_inferior_memory): Likewise.
* remote-array.c (array_xfer_memory): Likewise.
* remote-bug.c (bug_xfer_memory): Likewise.
* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
* remote-eb.c (eb_xfer_inferior_memory): Likewise.
* remote-es.c (es1800_xfer_inferior_memory): Likewise.
* remote-mips.c (mips_xfer_memory): Likewise.
* remote-mm.c (mm_xfer_inferior_memory): Likewise.
* remote-nindy.c (nindy_xfer_inferior_memory): Likewise.
* remote-os9k.c (rombug_xfer_inferior_memory): Likewise.
* remote-rdi.c (arm_rdi_xfer_memory): Likewise.
* remote-rdp.c (remote_rdp_xfer_inferior_memory): Likewise.
* remote-sds.c (sds_xfer_memory): Likewise.
* remote-sim.c (gdbsim_xfer_inferior_memory): Likewise.
* remote-st.c (st2000_xfer_inferior_memory): Likewise.
* remote-udi.c (udi_xfer_inferior_memory): Likewise.
* remote-vx.c (vx_xfer_memory): Likewise.
* remote.c (remote_xfer_memory): Likewise.
* target.c (debug_to_xfer_memory, do_xfer_memory): Likewise.
* target.h (child_xfer_memory, do_xfer_memory, xfer_memory): Likewise.

* target.h (#include "memattr.h"): Added.
(target_ops.to_xfer_memory): Add attrib argument.

* wince.c (_initialize_inftarg): Removed call to set_dcache_state.
* dcache.h (set_dcache_state): Removed declaration.
* dcache.c (set_dcache_state): Removed definition

* dcache.c: Update module comment, as dcache is now enabled and
disabled with memory region attributes instead of by the global
variable "remotecache".  Add comment describing the interaction
between dcache and memory region attributes.
(dcache_xfer_memory): Add comment describing benefits of moving
cache writeback to a higher level.
(dcache_struct): Removed cache_has_stuff field.  This was used to
record whether the cache had been accessed in order to invalidate
it when it was disabled.  However, this is not needed because the
cache is write through and the code that enables, disables, and
deletes memory regions invalidate the cache.  Add comment which
suggests that we could be more selective and only invalidate those
cache lines containing data from those memory regions.
(dcache_invalidate): Updated.
(dcache_xfer_memory): Updated.

(dcache_alloc): Don't abort() if dcache_enabled_p is clear.
(dcache_xfer_memory): Removed code that called do_xfer_memory() to
perform a uncached transfer if dcache_enabled_p was clear.  This
function is now only called if caching is enabled for the memory
region.
(dcache_info): Always print cache info.

* target.c (do_xfer_memory): Add attrib argument.
(target_xfer_memory, target_xfer_memory_partial): Break transfer
into chunks defined by memory regions, pass region attributes to
do_xfer_memory().
* dcache.c (dcache_read_line, dcache_write_line): Likewise.

* Makefile.in (SFILES): Add memattr.c.
(COMMON_OBS): Add memattr.o.
(dcache.o): Add target.h to dependencies.
* memattr.c: New file.
* memattr.h: Likewise.
@
text
@a34 1
#include "gdb_wait.h"
@


1.5
log
@Replace free() with xfree().
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992 Free Software Foundation, Inc.
d1176 3
a1178 1
mm_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len, int write)
@


1.4
log
@Protoization.
@
text
@d336 1
a336 1
    free (prog_name);
d1089 1
a1089 1
  make_cleanup (free, arg_string);
@


1.3
log
@Protoization.
@
text
@d1701 7
a1707 4
/* 
 *  Receive a message and expect it to be of type msgcode.
 *  Returns 0/1 on failure/success.
 */
d1709 1
a1709 4
expect_msg (msgcode, msg_buf, from_tty)
     INT32 msgcode;		/* Msg code we expect */
     union msg_t *msg_buf;	/* Where to put  the message received */
     int from_tty;		/* Print message on error if non-zero */
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d129 1
a129 1
mm_timer ()
d151 1
a151 4
mm_create_inferior (execfile, args, env)
     char *execfile;
     char *args;
     char **env;
d188 1
a188 1
mm_mourn ()
d283 1
a283 2
damn_b (rate)
     int rate;
d304 1
a304 3
mm_open (name, from_tty)
     char *name;
     int from_tty;
d454 2
a455 2
mm_close (quitting)		/*FIXME: how is quitting used */
     int quitting;
d489 1
a489 3
mm_attach (args, from_tty)
     char *args;
     int from_tty;
d517 1
a517 3
mm_detach (args, from_tty)
     char *args;
     int from_tty;
d531 1
a531 3
mm_resume (pid, step, sig)
     int pid, step;
     enum target_signal sig;
d556 1
a556 2
mm_wait (status)
     struct target_waitstatus *status;
d708 1
a708 2
mm_fetch_registers (regno)
     int regno;
d822 1
a822 2
mm_store_registers (regno)
     int regno;
d960 1
a960 1
mm_prepare_to_store ()
d967 1
a967 2
translate_addr (addr)
     CORE_ADDR addr;
d990 1
a990 1
mm_files_info ()
d998 1
a998 3
mm_insert_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d1019 1
a1019 3
mm_remove_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d1039 1
a1039 3
mm_kill (arg, from_tty)
     char *arg;
     int from_tty;
d1078 1
a1078 3
mm_load (arg_string, from_tty)
     char *arg_string;
     int from_tty;
d1106 1
a1106 4
mm_write_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d1142 1
a1142 4
mm_read_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d1176 1
a1176 5
mm_xfer_inferior_memory (memaddr, myaddr, len, write)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
d1201 1
a1201 2
msg_send_serial (msg_ptr)
     union msg_t *msg_ptr;
d1237 1
a1237 2
msg_recv_serial (msg_ptr)
     union msg_t *msg_ptr;
d1306 1
a1306 1
kbd_raw ()
d1365 1
a1365 1
kbd_restore ()
d1388 1
a1388 2
fetch_register (regno)
     int regno;
d1447 1
a1447 2
store_register (regno)
     int regno;
d1513 1
a1513 2
regnum_to_srnum (regno)
     int regno;
d1580 2
a1581 4
init_target_mm (tstart, tend, dstart, dend, entry, ms_size, rs_size, arg_start)
     ADDR32 tstart, tend, dstart, dend, entry;
     INT32 ms_size, rs_size;
     ADDR32 arg_start;
d1603 1
a1603 2
msg_str (code)
     INT32 code;
d1641 1
a1641 2
error_msg_str (code)
     INT32 code;
d1740 1
a1740 2
mm_memory_space (addr)
     CORE_ADDR *addr;
d1841 1
a1841 1
_initialize_remote_mm ()
d1848 1
a1848 2
service_HIF (msg)
     union msg_t *msg;
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d24 9
a32 9
 - David Wood (wood@@lab.ultra.nyu.edu) at New York University adapted this
	file to gdb 3.95.  I was unable to get this working on sun3os4
	with termio, only with sgtty.  Because we are only attempting to
	use this module to debug our kernel, which is already loaded when
	gdb is started up, I did not code up the file downloading facilities.  
	As a result this module has only the stubs to download files. 
	You should get tagged at compile time if you need to make any 
	changes/additions.  */
 
d35 1
a35 1
#include "wait.h"
d51 1
a51 1
extern int stop_soon_quietly;           /* for wait_for_inferior */
d53 1
a53 1
static void mm_resume();
d58 7
a64 7
static int regnum_to_srnum();
static void  mm_close ();
static char* msg_str();
static char* error_msg_str();
static int expect_msg();
static void init_target_mm();
static int mm_memory_space();
d79 1
a79 1
#define BUFER_SIZE  512		
d85 1
a85 1
/*		 
d95 1
a95 1
static char  in_buf[BUFER_SIZE];
d97 2
a98 2
int msg_recv_serial();
int msg_send_serial();
d101 4
a104 4
extern struct target_ops mm_ops;             /* Forward declaration */
struct config_msg_t  target_config;	/* HIF needs this */
union msg_t  *out_msg_buf = (union msg_t*)out_buf;
union msg_t  *in_msg_buf  = (union msg_t*)in_buf;
d121 3
a123 2
# ifndef volatile
#  define volatile /**/
d158 4
a161 4
   int	token_count;
   int	result;
   char	*token[MAX_TOKENS];
   char	cmd_line[BUFFER_SIZE];
d169 5
a173 4
  if (!mm_stream) {
        printf("Minimon not open yet.\n");
	return;
  }
d178 1
a178 1
     */
d191 1
a191 1
mm_mourn()
d193 2
a194 2
        pop_target ();                /* Pop back to no-child state */
        generic_mourn_inferior ();
d209 74
a282 18
static struct {int rate, damn_b;} baudtab[] = {
	{0, B0},
	{50, B50},
	{75, B75},
	{110, B110},
	{134, B134},
	{150, B150},
	{200, B200},
	{300, B300},
	{600, B600},
	{1200, B1200},
	{1800, B1800},
	{2400, B2400},
	{4800, B4800},
	{9600, B9600},
	{19200, B19200},
	{38400, B38400},
	{-1, -1},
d285 2
a286 1
static int damn_b (rate)
d292 3
a294 2
    if (rate == baudtab[i].rate) return baudtab[i].damn_b;
  return B38400;	/* Random */
d322 1
a322 1
erroid:
d324 1
a324 1
  dev_name = (char*)xmalloc (p - name + 1);
d330 2
a331 2
    /*EMPTY*/;
  
d337 1
a337 1
    /*EMPTY*/;
d339 2
a340 2
    /*EMPTY*/;
  
d390 2
a391 2
   /*
   ** Initialize target configuration structure (global)
d393 4
a396 4
   DRAIN_INPUT();
   out_msg_buf->config_req_msg.code = CONFIG_REQ;
   out_msg_buf->config_req_msg.length = 4*0;
   msg_send_serial(out_msg_buf); /* send config request message */
d398 1
a398 1
   expect_msg(CONFIG,in_msg_buf,1);
d403 10
a412 9
  printf_filtered("Connected to MiniMon via %s.\n", dev_name);
    /* FIXME: can this restriction be removed? */
  printf_filtered("Remote debugging using virtual addresses works only\n");
  printf_filtered("\twhen virtual addresses map 1:1 to physical addresses.\n")
;
  if (processor_type != a29k_freeze_mode) {
        fprintf_filtered(gdb_stderr,
        "Freeze-mode debugging not available, and can only be done on an A29050.\n");
  }
d414 30
a443 29
   target_config.code = CONFIG;
   target_config.length = 0;
   target_config.processor_id = in_msg_buf->config_msg.processor_id;
   target_config.version = in_msg_buf->config_msg.version;
   target_config.I_mem_start = in_msg_buf->config_msg.I_mem_start;
   target_config.I_mem_size = in_msg_buf->config_msg.I_mem_size;
   target_config.D_mem_start = in_msg_buf->config_msg.D_mem_start;
   target_config.D_mem_size = in_msg_buf->config_msg.D_mem_size;
   target_config.ROM_start = in_msg_buf->config_msg.ROM_start;
   target_config.ROM_size =  in_msg_buf->config_msg.ROM_size;
   target_config.max_msg_size = in_msg_buf->config_msg.max_msg_size;
   target_config.max_bkpts = in_msg_buf->config_msg.max_bkpts;
   target_config.coprocessor = in_msg_buf->config_msg.coprocessor;
   target_config.reserved = in_msg_buf->config_msg.reserved;
   if (from_tty) {
   	printf("Connected to MiniMON :\n");
	printf("    Debugcore version            %d.%d\n",
		0x0f & (target_config.version >> 4),
		0x0f & (target_config.version ) );
	printf("    Configuration version        %d.%d\n",
		0x0f & (target_config.version >> 12),
		0x0f & (target_config.version >>  8) );
	printf("    Message system version       %d.%d\n",
		0x0f & (target_config.version >> 20),
		0x0f & (target_config.version >> 16) );
	printf("    Communication driver version %d.%d\n",
		0x0f & (target_config.version >> 28),
		0x0f & (target_config.version >> 24) );
   }
d451 1
a451 1
  msg_send_serial(out_msg_buf);
d460 1
a460 1
mm_close (quitting)	/*FIXME: how is quitting used */
d472 2
a473 2
  DRAIN_INPUT();
  fclose (mm_stream);	
d488 1
a488 1
} 
d501 2
a502 2
      error ("MiniMon not opened yet, use the 'target minimon' command.\n");
	
d504 1
a504 1
      printf ("Attaching to remote program %s...\n", prog_name);
d508 1
a508 1
   * 	the dbg core.  If so, we don't need to send this GO.
d512 4
a515 4
  msg_send_serial(out_msg_buf);
  sleep(2);	/* At the worst it will stop, receive a message, continue */
 
  /* Send the mm a break. */ 
d518 1
a518 1
  msg_send_serial(out_msg_buf);
d525 1
a525 1
mm_detach (args,from_tty)
d529 1
a529 1
  remove_breakpoints();		/* Just in case there were any left in */
d532 2
a533 2
  msg_send_serial(out_msg_buf);
  pop_target();         	/* calls mm_close to do the real work */
d548 10
a557 7
  if (step) {
      out_msg_buf->step_msg.code= STEP;
      out_msg_buf->step_msg.length = 1*4;
      out_msg_buf->step_msg.count = 1;		/* step 1 instruction */
      msg_send_serial(out_msg_buf);
  } else {
      out_msg_buf->go_msg.code= GO;
d559 2
a560 2
      msg_send_serial(out_msg_buf);
  }
d579 11
a589 16
	- A HIF service request.
	- A HIF exit service request.
	- A CHANNEL0_ACK.
	- A CHANNEL1 request.
	- a debugcore HALT message.
  HIF services must be responded too, and while-looping continued.
  If the target stops executing, mm_wait() should return.
*/
  timeout = 0;	/* Wait indefinetly for a message */
  immediate_quit = 1;   /* Helps ability to QUIT */
  while(1)
  {
    while(msg_recv_serial(in_msg_buf)) {
    	QUIT;	/* Let user quit if they want */
    }
    switch (in_msg_buf->halt_msg.code)
d591 10
a600 4
    case HIF_CALL:
	i = in_msg_buf->hif_call_rtn_msg.service_number;
	result=service_HIF(in_msg_buf);
   	if(i == 1) /* EXIT */
d602 21
a622 20
	if(result)
	    printf("Warning: failure during HIF service %d\n", i);
	break;
    case CHANNEL0_ACK:
	service_HIF(in_msg_buf);
	break;
    case CHANNEL1:
        i=in_msg_buf->channel1_msg.length;
        in_msg_buf->channel1_msg.data[i] = '\0';
        printf("%s", in_msg_buf->channel1_msg.data);
	gdb_flush(gdb_stdout);
        /* Send CHANNEL1_ACK message */
        out_msg_buf->channel1_ack_msg.code = CHANNEL1_ACK;
        out_msg_buf->channel1_ack_msg.length = 0;
        result = msg_send_serial(out_msg_buf);
	break;
    case HALT:
	goto halted;
    default:
	goto halted;
a623 1
  }
d627 8
a634 7
  if (in_msg_buf->halt_msg.trap_number== 0)
  { printf("Am290*0 received vector number %d (break point)\n",
	in_msg_buf->halt_msg.trap_number);
    status->kind = TARGET_WAITKIND_STOPPED;
    status->value.sig = TARGET_SIGNAL_TRAP;
  }
  else if (in_msg_buf->halt_msg.trap_number== 1)
d636 2
a637 2
      printf("Am290*0 received vector number %d\n",
	     in_msg_buf->halt_msg.trap_number);
d641 5
a645 4
  else if (in_msg_buf->halt_msg.trap_number== 3
        || in_msg_buf->halt_msg.trap_number== 4)
  { printf("Am290*0 received vector number %d\n",
	in_msg_buf->halt_msg.trap_number);
d648 5
a652 4
  }
  else if (in_msg_buf->halt_msg.trap_number== 5)
  { printf("Am290*0 received vector number %d\n",
	in_msg_buf->halt_msg.trap_number);
d655 1
a655 1
  }
d657 4
a660 3
        && in_msg_buf->halt_msg.trap_number <= 11)
  { printf("Am290*0 received vector number %d\n",
	in_msg_buf->halt_msg.trap_number);
d663 6
a668 5
  }
  else if (in_msg_buf->halt_msg.trap_number== 12
        || in_msg_buf->halt_msg.trap_number== 13)
  { printf("Am290*0 received vector number %d\n",
	in_msg_buf->halt_msg.trap_number);
d671 5
a675 4
  }
  else if (in_msg_buf->halt_msg.trap_number== 14)
  { printf("Am290*0 received vector number %d\n",
	in_msg_buf->halt_msg.trap_number);
d678 2
a679 2
  }
  else if (in_msg_buf->halt_msg.trap_number== 15)
d685 4
a688 3
        && in_msg_buf->halt_msg.trap_number <= 21)
  { printf("Am290*0 received vector number %d\n",
	in_msg_buf->halt_msg.trap_number);
d691 5
a695 4
  }
  else if (in_msg_buf->halt_msg.trap_number== 22)
  { printf("Am290*0 received vector number %d\n",
	in_msg_buf->halt_msg.trap_number);
d698 2
a699 2
  } /* BREAK message was sent */
  else if (in_msg_buf->halt_msg.trap_number== 75)
d705 1
a705 1
exit:
d720 1
a720 1
static void 
d722 1
a722 1
int	regno;
d726 5
a730 4
  if (regno >= 0)  {
	fetch_register(regno);
	return;
  }
d733 1
a733 1
  out_msg_buf->read_req_msg.byte_count = 4*1;
d736 2
a737 2
  msg_send_serial(out_msg_buf);
  expect_msg(READ_ACK,in_msg_buf,1);
d739 1
a739 1
  supply_register (GR1_REGNUM , data_p);
d742 4
a745 4
/* Global Registers gr64-gr95 */ 
  out_msg_buf->read_req_msg.code= READ_REQ;
  out_msg_buf->read_req_msg.length = 4*3;
  out_msg_buf->read_req_msg.byte_count = 4*32;
d748 2
a749 2
  msg_send_serial(out_msg_buf);
  expect_msg(READ_ACK,in_msg_buf,1);
d752 2
a753 1
  for (regno=GR64_REGNUM; regno<GR64_REGNUM+32; regno++) {
d755 2
a756 2
  }
#endif	/*  GR64_REGNUM */
d758 3
a760 3
/* Global Registers gr96-gr127 */ 
  out_msg_buf->read_req_msg.code= READ_REQ;
  out_msg_buf->read_req_msg.length = 4*3;
d764 2
a765 2
  msg_send_serial(out_msg_buf);
  expect_msg(READ_ACK,in_msg_buf,1);
d768 2
a769 1
  for (regno=GR96_REGNUM; regno<GR96_REGNUM+32; regno++) {
d771 1
a771 1
  }
d773 1
a773 1
/* Local Registers */ 
d777 2
a778 2
  msg_send_serial(out_msg_buf);
  expect_msg(READ_ACK,in_msg_buf,1);
d781 2
a782 1
  for (regno=LR0_REGNUM; regno<LR0_REGNUM+128; regno++) {
d784 1
a784 1
  }
d786 2
a787 2
/* Protected Special Registers */ 
  out_msg_buf->read_req_msg.byte_count = 4*15;
d790 2
a791 2
  msg_send_serial( out_msg_buf);
  expect_msg(READ_ACK,in_msg_buf,1);
d794 10
a803 8
  for (regno=0; regno<=14; regno++) {
      supply_register (SR_REGNUM(regno), data_p++);
  }
  if (USE_SHADOW_PC) {	/* Let regno_to_srnum() handle the register number */
	fetch_register(NPC_REGNUM);
	fetch_register(PC_REGNUM);
	fetch_register(PC2_REGNUM);
  }
d805 2
a806 2
/* Unprotected Special Registers */ 
  out_msg_buf->read_req_msg.byte_count = 4*8;
d809 2
a810 2
  msg_send_serial( out_msg_buf);
  expect_msg(READ_ACK,in_msg_buf,1);
d813 4
a816 3
  for (regno=128; regno<=135; regno++) {
      supply_register (SR_REGNUM(regno), data_p++);
  }
d837 1
a837 1
int regno;
d840 6
a845 5
  
  if (regno >= 0) {
    store_register(regno);
    return;
  }
d849 1
a849 1
  out_msg_buf->write_r_msg.code= WRITE_REQ;
d852 2
a853 2
  out_msg_buf->write_r_msg.byte_count = 4*1;
  out_msg_buf->write_r_msg.length = 3*4 + out_msg_buf->write_r_msg.byte_count;
d858 5
a862 4
  msg_send_serial( out_msg_buf);
  if (!expect_msg(WRITE_ACK,in_msg_buf,1)) {
	result = -1;
  }
d866 2
a867 2
  out_msg_buf->write_r_msg.byte_count = 4* (32);
  out_msg_buf->write_r_msg.length = 3*4 + out_msg_buf->write_r_msg.byte_count;
d870 1
a870 1
  for (regno=GR64_REGNUM ; regno<GR64_REGNUM+32 ; regno++)
d872 1
a872 1
      out_msg_buf->write_r_msg.data[regno-GR64_REGNUM] = read_register (regno);
d874 6
a879 5
  msg_send_serial(out_msg_buf);
  if (!expect_msg(WRITE_ACK,in_msg_buf,1)) {
	result = -1;
  }
#endif	/* GR64_REGNUM */
d882 2
a883 2
  out_msg_buf->write_r_msg.byte_count = 4* (32);
  out_msg_buf->write_r_msg.length = 3*4 + out_msg_buf->write_r_msg.byte_count;
d885 1
a885 1
  for (regno=GR96_REGNUM ; regno<GR96_REGNUM+32 ; regno++)
d887 6
a892 1
      out_msg_buf->write_r_msg.data[regno-GR96_REGNUM] = read_register (regno);
a893 4
  msg_send_serial( out_msg_buf);
  if (!expect_msg(WRITE_ACK,in_msg_buf,1)) {
	result = -1;
  }
d897 2
a898 2
  out_msg_buf->write_r_msg.byte_count = 4*128;
  out_msg_buf->write_r_msg.length = 3*4 + out_msg_buf->write_r_msg.byte_count;
d901 1
a901 1
  for (regno = LR0_REGNUM ; regno < LR0_REGNUM+128 ; regno++)
d903 6
a908 1
      out_msg_buf->write_r_msg.data[regno-LR0_REGNUM] = read_register (regno);
a909 4
  msg_send_serial( out_msg_buf);
  if (!expect_msg(WRITE_ACK,in_msg_buf,1)) {
	result = -1;
  }
d911 1
a911 1
/* Protected Special Registers */ 
d914 2
a915 2
  out_msg_buf->write_r_msg.byte_count = 4* 10;
  out_msg_buf->write_r_msg.length = 3*4 + out_msg_buf->write_r_msg.byte_count;
d917 7
a923 6
  for (regno = 0 ; regno<=9 ; regno++)	/* VAB through TMR */
    out_msg_buf->write_r_msg.data[regno] = read_register (SR_REGNUM(regno));
  msg_send_serial( out_msg_buf);
  if (!expect_msg(WRITE_ACK,in_msg_buf,1)) {
	result = -1;
  }
d926 5
a930 5
  out_msg_buf->write_r_msg.byte_count = 4* 3;
  out_msg_buf->write_r_msg.length = 3*4 + out_msg_buf->write_r_msg.byte_count;
  for (regno=10 ; regno<=12 ; regno++)	/* LRU and MMU */
    out_msg_buf->write_r_msg.data[regno-10] = read_register (SR_REGNUM(regno));
  if (USE_SHADOW_PC) 
d932 1
a932 1
  else 
d934 5
a938 4
  msg_send_serial( out_msg_buf);
  if (!expect_msg(WRITE_ACK,in_msg_buf,1)) {
	result = -1;
  }
d941 2
a942 2
  out_msg_buf->write_r_msg.byte_count = 4* 2;
  out_msg_buf->write_r_msg.length = 3*4 + out_msg_buf->write_r_msg.byte_count;
d944 7
a950 6
  for (regno=13 ; regno<=14 ; regno++)	/* LRU and MMU */
    out_msg_buf->write_r_msg.data[regno-13] = read_register (SR_REGNUM(regno));
  msg_send_serial( out_msg_buf);
  if (!expect_msg(WRITE_ACK,in_msg_buf,1)) {
	result = -1;
  }
d952 3
a954 3
/* Unprotected Special Registers */ 
  out_msg_buf->write_r_msg.byte_count = 4*8;
  out_msg_buf->write_r_msg.length = 3*4 + out_msg_buf->write_r_msg.byte_count;
d956 8
a963 7
  for (regno = 128 ; regno<=135 ; regno++)
    out_msg_buf->write_r_msg.data[regno-128] = read_register(SR_REGNUM(regno));
  msg_send_serial( out_msg_buf);
  if (!expect_msg(WRITE_ACK,in_msg_buf,1)) {
	result = -1;
  }
 
d982 2
a983 2
translate_addr(addr)
CORE_ADDR addr;
d986 13
a998 10
        /* Check for a virtual address in the kernel */
        /* Assume physical address of ublock is in  paddr_u register */
	/* FIXME: doesn't work for user virtual addresses */
        if (addr >= UVADDR) {
                /* PADDR_U register holds the physical address of the ublock */
                CORE_ADDR i = (CORE_ADDR)read_register(PADDR_U_REGNUM);
                return(i + addr - (CORE_ADDR)UVADDR);
        } else {
        	return(addr);
        }
d1000 1
a1000 1
        return(addr);
d1009 1
a1009 1
          dev_name, baudrate, prog_name);
d1019 1
a1019 1
  out_msg_buf->bkpt_set_msg.length = 4*4;
d1024 9
a1032 6
  msg_send_serial( out_msg_buf);
  if (expect_msg(BKPT_SET_ACK,in_msg_buf,1)) {
	return 0;		/* Success */
  } else {
	return 1;		/* Failure */
  }
d1042 1
a1042 1
  out_msg_buf->bkpt_rm_msg.length = 4*3;
d1045 9
a1053 6
  msg_send_serial( out_msg_buf);
  if (expect_msg(BKPT_RM_ACK,in_msg_buf,1)) {
	return 0;		/* Success */
  } else {
	return 1;		/* Failure */
  }
d1059 3
a1061 3
mm_kill(arg,from_tty)
char    *arg;
int     from_tty;
d1063 1
a1063 1
	char	buf[4];
d1066 6
a1071 5
	/* We don't ever kill the kernel */
	if (from_tty) {
		printf("Kernel not killed, but left in current state.\n");
	 	printf("Use detach to leave kernel running.\n");
	}
d1073 14
a1086 13
  	out_msg_buf->break_msg.code = BREAK;
  	out_msg_buf->bkpt_set_msg.length = 4*0;
	expect_msg(HALT,in_msg_buf,from_tty);
	if (from_tty) {
		printf("Target has been stopped.");
		printf("Would you like to do a hardware reset (y/n) [n] ");
		fgets(buf,3,stdin);	
		if (buf[0] == 'y') {
			out_msg_buf->reset_msg.code = RESET;
			out_msg_buf->bkpt_set_msg.length = 4*0;
			expect_msg(RESET_ACK,in_msg_buf,from_tty);
			printf("Target has been reset.");
		}
d1088 3
a1090 2
	pop_target();
#endif 
d1100 3
a1102 3
mm_load(arg_string,from_tty)
char	*arg_string;
int	from_tty;
d1107 1
a1107 1
  printf("The kernel had better be loaded already!  Loading not done.\n");
d1116 1
a1116 1
  error("File loading is not yet supported for MiniMon.");
d1121 1
a1121 1
  /* symbol_file_add (arg_string, from_tty, text_addr, 0, 0, 0, 0); */
d1135 1
a1135 1
  int i,nwritten;
d1137 2
a1138 2
  out_msg_buf->write_req_msg.code= WRITE_REQ;
  out_msg_buf->write_req_msg.memory_space = mm_memory_space(memaddr);	
d1140 23
a1162 18
  nwritten=0;
  while (nwritten < len) {
	int num_to_write = len - nwritten;
	if (num_to_write > MAXDATA) num_to_write = MAXDATA;
  	for (i=0 ; i < num_to_write ; i++)
      		out_msg_buf->write_req_msg.data[i] = myaddr[i+nwritten];
  	out_msg_buf->write_req_msg.byte_count = num_to_write;
  	out_msg_buf->write_req_msg.length = 3*4 + num_to_write; 
  	out_msg_buf->write_req_msg.address = memaddr + nwritten;
  	msg_send_serial(out_msg_buf);

  	if (expect_msg(WRITE_ACK,in_msg_buf,1)) {
  		nwritten += in_msg_buf->write_ack_msg.byte_count;
  	} else {
		break;	
  	}
  }
  return(nwritten);
d1169 1
a1169 1
mm_read_inferior_memory(memaddr, myaddr, len)
d1174 1
a1174 1
  int i,nread;
d1176 2
a1177 2
  out_msg_buf->read_req_msg.code= READ_REQ;
  out_msg_buf->read_req_msg.memory_space = mm_memory_space(memaddr);
d1179 23
a1201 18
  nread=0;
  while (nread < len) {
	int num_to_read = (len - nread);
	if (num_to_read > MAXDATA) num_to_read = MAXDATA;
  	out_msg_buf->read_req_msg.byte_count = num_to_read; 
  	out_msg_buf->read_req_msg.length = 3*4 + num_to_read; 
  	out_msg_buf->read_req_msg.address = memaddr + nread;
  	msg_send_serial(out_msg_buf);

  	if (expect_msg(READ_ACK,in_msg_buf,1)) {
  		for (i=0 ; i<in_msg_buf->read_ack_msg.byte_count ; i++)
      			myaddr[i+nread] = in_msg_buf->read_ack_msg.data[i];
  		nread += in_msg_buf->read_ack_msg.byte_count;
  	} else {
		break;	
  	}
  }
  return(nread);
d1213 1
a1213 1
  memaddr = translate_addr(memaddr);
d1235 2
a1236 2
msg_send_serial(msg_ptr)
   union  msg_t  *msg_ptr;
d1238 18
a1255 15
   INT32  message_size;
   int    byte_count;
   int    result;
   char   c;

   /* Send message header */
   byte_count = 0;
   message_size = msg_ptr->generic_msg.length + (2 * sizeof(INT32));
   do {
      c = *((char *)msg_ptr+byte_count);
      result = write(mm_desc, &c, 1);
      if (result == 1) {
         byte_count = byte_count + 1;
      }
   } while ((byte_count < message_size) );
d1257 2
a1258 2
   return(0);
}  /* end msg_send_serial() */
d1272 2
a1273 2
msg_recv_serial(msg_ptr)
union  msg_t  *msg_ptr;
d1275 8
a1282 7
   static INT32  length=0;
   static INT32  byte_count=0;
   int    result;
   char   c;
  if(msg_ptr == 0)		/* re-sync request */
  {  length=0;
     byte_count=0;
d1284 3
a1286 3
     /* The timeout here is the prevailing timeout set with VTIME */
     ->"timeout==0 semantics not supported"
     read(mm_desc, in_buf, BUFER_SIZE);
d1288 3
a1290 3
     alarm (1);
     read(mm_desc, in_buf, BUFER_SIZE);
     alarm (0);
d1292 3
a1294 3
     return(0);
  }
   /* Receive message */
d1297 2
a1298 2
   ->"timeout==0 semantics not supported (and its nice if they are)"
   result = read(mm_desc, &c, 1);
d1300 2
a1301 2
  alarm(timeout);
  result = read(mm_desc, &c, 1);
d1304 7
a1310 4
  if ( result < 0) {
      if (errno == EINTR) {
      	error ("Timeout reading from remote system.");
      } else
d1312 4
a1315 2
  } else if (result == 1) {
      *((char *)msg_ptr+byte_count) = c;
d1317 1
a1317 1
  }
d1319 3
a1321 3
   /* Message header received.  Save message length. */
  if (byte_count == (2 * sizeof(INT32)))
      length = msg_ptr->generic_msg.length;
d1323 2
a1324 1
  if (byte_count >= (length + (2 * sizeof(INT32)))) {
d1327 4
a1330 3
      return(0);
  } else
      return (-1);
d1332 1
a1332 1
}  /* end msg_recv_serial() */
d1342 4
a1345 3
kbd_raw() {
   int    result;
   TERMINAL tbuf;
d1347 1
a1347 1
   /* Get keyboard termio (to save to restore original modes) */
d1349 1
a1349 1
   result = ioctl(0, TCGETA, &kbd_tbuf);
d1351 1
a1351 1
   result = ioctl(0, TIOCGETP, &kbd_tbuf);
d1353 2
a1354 2
   if (result == -1)
      return (errno);
d1356 1
a1356 1
   /* Get keyboard TERMINAL (for modification) */
d1358 1
a1358 1
   result = ioctl(0, TCGETA, &tbuf);
d1360 1
a1360 1
   result = ioctl(0, TIOCGETP, &tbuf);
d1362 2
a1363 2
   if (result == -1)
      return (errno);
d1365 1
a1365 1
   /* Set up new parameters */
d1367 5
a1371 5
   tbuf.c_iflag = tbuf.c_iflag &
      ~(INLCR | ICRNL | IUCLC | ISTRIP | IXON | BRKINT);
   tbuf.c_lflag = tbuf.c_lflag & ~(ICANON | ISIG | ECHO);
   tbuf.c_cc[4] = 0;  /* MIN */
   tbuf.c_cc[5] = 0;  /* TIME */
d1373 4
a1376 4
   /* FIXME: not sure if this is correct (matches HAVE_TERMIO). */
   tbuf.sg_flags |= RAW;
   tbuf.sg_flags |= ANYP;
   tbuf.sg_flags &= ~ECHO;
d1379 1
a1379 1
   /* Set keyboard termio to new mode (RAW) */
d1381 1
a1381 1
   result = ioctl(0, TCSETAF, &tbuf);
d1383 4
a1386 4
   result = ioctl(0, TIOCSETP, &tbuf);
#endif 
   if (result == -1)
      return (errno);
d1388 2
a1389 2
   return (0);
}  /* end kbd_raw() */
d1401 3
a1403 2
kbd_restore() {
   int result;
d1405 1
a1405 1
   /* Set keyboard termio to original mode */
d1407 1
a1407 1
   result = ioctl(0, TCSETAF, &kbd_tbuf);
d1409 1
a1409 1
   result = ioctl(0, TIOCGETP, &kbd_tbuf);
d1412 2
a1413 2
   if (result == -1)
      return (errno);
d1415 2
a1416 2
   return(0);
}  /* end kbd_cooked() */
d1419 1
a1419 1
/*****************************************************************************/ 
d1427 3
a1429 3
     int  result;
  out_msg_buf->read_req_msg.code= READ_REQ;
  out_msg_buf->read_req_msg.length = 4*3;
d1433 4
a1436 3
  { out_msg_buf->read_req_msg.memory_space = GLOBAL_REG;
    out_msg_buf->read_req_msg.address = 1;
  }
d1438 4
a1441 3
  { out_msg_buf->read_req_msg.memory_space = GLOBAL_REG;
    out_msg_buf->read_req_msg.address = (regno - GR96_REGNUM) + 96;
  }
d1443 6
a1448 5
  else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32 )
  { out_msg_buf->read_req_msg.memory_space = GLOBAL_REG;
    out_msg_buf->read_req_msg.address = (regno - GR64_REGNUM) + 64;
  }
#endif	/* GR64_REGNUM */
d1450 27
a1476 21
  { out_msg_buf->read_req_msg.memory_space = LOCAL_REG;
    out_msg_buf->read_req_msg.address = (regno - LR0_REGNUM);
  }
  else if (regno>=FPE_REGNUM && regno<=EXO_REGNUM)  
  { int val = -1;
    supply_register(160 + (regno - FPE_REGNUM),&val);
    return 0;		/* Pretend Success */
  }
  else 
  { out_msg_buf->read_req_msg.memory_space = SPECIAL_REG;
    out_msg_buf->read_req_msg.address = regnum_to_srnum(regno); 
  } 

  msg_send_serial(out_msg_buf);

  if (expect_msg(READ_ACK,in_msg_buf,1)) {
  	supply_register (regno, &(in_msg_buf->read_r_ack_msg.data[0]));
	result = 0;
  } else {
	result = -1;
  }
d1479 1
a1479 1
/*****************************************************************************/ 
d1487 1
a1487 1
     int  result;
d1489 2
a1490 2
  out_msg_buf->write_req_msg.code= WRITE_REQ;
  out_msg_buf->write_req_msg.length = 4*4;
d1495 11
a1505 10
  { out_msg_buf->write_req_msg.memory_space = GLOBAL_REG;
    out_msg_buf->write_req_msg.address = 1;
    /* Setting GR1 changes the numbers of all the locals, so invalidate the 
     * register cache.  Do this *after* calling read_register, because we want 
     * read_register to return the value that write_register has just stuffed 
     * into the registers array, not the value of the register fetched from 
     * the inferior.  
     */
    registers_changed ();
  }
d1507 6
a1512 5
  else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32 )
  { out_msg_buf->write_req_msg.memory_space = GLOBAL_REG;
    out_msg_buf->write_req_msg.address = (regno - GR64_REGNUM) + 64;
  }
#endif	/* GR64_REGNUM */
d1514 4
a1517 3
  { out_msg_buf->write_req_msg.memory_space = GLOBAL_REG;
    out_msg_buf->write_req_msg.address = (regno - GR96_REGNUM) + 96;
  }
d1519 25
a1543 19
  { out_msg_buf->write_req_msg.memory_space = LOCAL_REG;
    out_msg_buf->write_req_msg.address = (regno - LR0_REGNUM);
  }
  else if (regno>=FPE_REGNUM && regno<=EXO_REGNUM)  
  { 
    return 0;		/* Pretend Success */
  }
  else 	/* An unprotected or protected special register */
  { out_msg_buf->write_req_msg.memory_space = SPECIAL_REG;
    out_msg_buf->write_req_msg.address = regnum_to_srnum(regno); 
  } 

  msg_send_serial(out_msg_buf);

  if (expect_msg(WRITE_ACK,in_msg_buf,1)) {
	result = 0;
  } else {
	result = -1;
  }
d1551 2
a1552 2
regnum_to_srnum(regno)
int	regno;
d1554 59
a1612 31
	switch(regno) {
		case VAB_REGNUM: return(0); 
		case OPS_REGNUM: return(1); 
		case CPS_REGNUM: return(2); 
		case CFG_REGNUM: return(3); 
		case CHA_REGNUM: return(4); 
		case CHD_REGNUM: return(5); 
		case CHC_REGNUM: return(6); 
		case RBP_REGNUM: return(7); 
		case TMC_REGNUM: return(8); 
		case TMR_REGNUM: return(9); 
		case NPC_REGNUM: return(USE_SHADOW_PC ? (20) : (10));
		case PC_REGNUM:  return(USE_SHADOW_PC ? (21) : (11));
		case PC2_REGNUM: return(USE_SHADOW_PC ? (22) : (12));
		case MMU_REGNUM: return(13); 
		case LRU_REGNUM: return(14); 
		case IPC_REGNUM: return(128); 
		case IPA_REGNUM: return(129); 
		case IPB_REGNUM: return(130); 
		case Q_REGNUM:   return(131); 
		case ALU_REGNUM: return(132); 
		case BP_REGNUM:  return(133); 
		case FC_REGNUM:  return(134); 
		case CR_REGNUM:  return(135); 
		case FPE_REGNUM: return(160); 
		case INTE_REGNUM: return(161); 
		case FPS_REGNUM: return(162); 
		case EXO_REGNUM:return(164); 
		default:
			return(255);	/* Failure ? */
	}
d1619 17
a1635 17
init_target_mm(tstart,tend,dstart,dend,entry,ms_size,rs_size,arg_start)
ADDR32	tstart,tend,dstart,dend,entry;
INT32	ms_size,rs_size;
ADDR32	arg_start;
{
	out_msg_buf->init_msg.code = INIT;
	out_msg_buf->init_msg.length= sizeof(struct init_msg_t)-2*sizeof(INT32);
	out_msg_buf->init_msg.text_start = tstart;
	out_msg_buf->init_msg.text_end = tend;
	out_msg_buf->init_msg.data_start = dstart;
	out_msg_buf->init_msg.data_end = dend;
	out_msg_buf->init_msg.entry_point = entry;
	out_msg_buf->init_msg.mem_stack_size = ms_size;
	out_msg_buf->init_msg.reg_stack_size = rs_size;
	out_msg_buf->init_msg.arg_start = arg_start;
	msg_send_serial(out_msg_buf);
	expect_msg(INIT_ACK,in_msg_buf,1);
d1643 34
a1676 17
static char*
msg_str(code)
INT32	code;
{
	static char cbuf[32];

	switch (code) {
	case BKPT_SET_ACK: sprintf(cbuf,"%s (%d)","BKPT_SET_ACK",code); break; 
	case BKPT_RM_ACK: sprintf(cbuf,"%s (%d)","BKPT_RM_ACK",code); break; 
	case INIT_ACK: 	  sprintf(cbuf,"%s (%d)","INIT_ACK",code); break; 
	case READ_ACK: 	  sprintf(cbuf,"%s (%d)","READ_ACK",code); break; 
	case WRITE_ACK:	  sprintf(cbuf,"%s (%d)","WRITE_ACK",code); break; 
	case ERROR:       sprintf(cbuf,"%s (%d)","ERROR",code); break; 
	case HALT: 	sprintf(cbuf,"%s (%d)","HALT",code); break; 
	default:	sprintf(cbuf,"UNKNOWN (%d)",code); break; 
	}
	return(cbuf);
d1682 5
a1686 32
static char* 
error_msg_str(code)
INT32	code;
{
	static char cbuf[50];

	switch (code) {
	case EMFAIL: 	return("EMFAIL: unrecoverable error"); 
	case EMBADADDR: return("EMBADADDR: Illegal address"); 
	case EMBADREG: 	return("EMBADREG: Illegal register "); 
	case EMACCESS: 	return("EMACCESS: Could not access memory");
	case EMBADMSG: 	return("EMBADMSG: Unknown message type"); 
	case EMMSG2BIG: return("EMMSG2BIG: Message to large"); 
	case EMNOSEND: 	return("EMNOSEND: Could not send message"); 
	case EMNORECV: 	return("EMNORECV: Could not recv message"); 
	case EMRESET: 	return("EMRESET: Could not RESET target"); 
	case EMCONFIG: 	return("EMCONFIG: Could not get target CONFIG"); 
	case EMSTATUS: 	return("EMSTATUS: Could not get target STATUS"); 
	case EMREAD: 	return("EMREAD: Could not READ target memory"); 
	case EMWRITE: 	return("EMWRITE: Could not WRITE target memory"); 
	case EMBKPTSET: return("EMBKPTSET: Could not set breakpoint"); 
	case EMBKPTRM:	return("EMBKPTRM: Could not remove breakpoint"); 
	case EMBKPTSTAT:return("EMBKPTSTAT: Could not get breakpoint status"); 
	case EMBKPTNONE:return("EMBKPTNONE: All breakpoints in use"); 
	case EMBKPTUSED:return("EMBKPTUSED: Breakpoints already in use"); 
	case EMINIT: 	return("EMINIT: Could not init target memory"); 
	case EMGO: 	return("EMGO: Could not start execution"); 
	case EMSTEP: 	return("EMSTEP: Could not single step"); 
	case EMBREAK: 	return("EMBREAK: Could not BREAK"); 
	case EMCOMMERR: return("EMCOMMERR: Communication error"); 
	default:     	sprintf(cbuf,"error number %d",code); break;
	} /* end switch */
d1688 54
a1741 1
	return (cbuf);
d1749 13
a1761 12
expect_msg(msgcode,msg_buf,from_tty)
INT32	msgcode;		/* Msg code we expect */
union msg_t *msg_buf;		/* Where to put  the message received */
int	from_tty;		/* Print message on error if non-zero */
{
  int	retries=0;
  while(msg_recv_serial(msg_buf) && (retries++<MAX_RETRIES)); 
  if (retries >= MAX_RETRIES) {
	printf("Expected msg %s, ",msg_str(msgcode));
	printf("no message received!\n");
        return(0);		/* Failure */
  }
d1763 13
a1775 11
  if (msg_buf->generic_msg.code != msgcode) {
     if (from_tty) {
	printf("Expected msg %s, ",msg_str(msgcode));
	printf("got msg %s\n",msg_str(msg_buf->generic_msg.code));
        if (msg_buf->generic_msg.code == ERROR) 
		printf("%s\n",error_msg_str(msg_buf->error_msg.error_code));
     }
     return(0);			/* Failure */
  }
  return(1);			/* Success */
}	
d1783 2
a1784 2
mm_memory_space(addr)
CORE_ADDR	*addr;
d1786 22
a1807 16
	ADDR32 tstart = target_config.I_mem_start;
	ADDR32 tend   = tstart + target_config.I_mem_size;  
	ADDR32 dstart = target_config.D_mem_start;
	ADDR32 dend   = tstart + target_config.D_mem_size;  
	ADDR32 rstart = target_config.ROM_start;
	ADDR32 rend   = tstart + target_config.ROM_size;  

	if (((ADDR32)addr >= tstart) && ((ADDR32)addr < tend)) { 
		return I_MEM;
	} else if (((ADDR32)addr >= dstart) && ((ADDR32)addr < dend)) { 
		return D_MEM;
	} else if (((ADDR32)addr >= rstart) && ((ADDR32)addr < rend)) {
		/* FIXME: how do we determine between D_ROM and I_ROM */
		return D_ROM;
	} else	/* FIXME: what do me do now? */
		return D_MEM;	/* Hmmm! */
d1814 1
a1814 1
struct target_ops mm_ops ;
d1816 2
a1817 2
static void 
init_mm_ops(void)
d1819 6
a1824 6
  mm_ops.to_shortname =   "minimon";
  mm_ops.to_longname =   "Remote AMD/Minimon target";
  mm_ops.to_doc =   "Remote debug an AMD 290*0 using the MiniMon dbg core on the target";
  mm_ops.to_open =   mm_open;
  mm_ops.to_close =   mm_close;
  mm_ops.to_attach =   mm_attach;
d1827 1
a1827 1
  mm_ops.to_detach =   mm_detach;
d1829 2
a1830 2
  mm_ops.to_resume =   mm_resume;
  mm_ops.to_wait  =   mm_wait;
d1832 16
a1847 16
  mm_ops.to_fetch_registers  =   mm_fetch_registers;
  mm_ops.to_store_registers  =   mm_store_registers;
  mm_ops.to_prepare_to_store =   mm_prepare_to_store;
  mm_ops.to_xfer_memory  =   mm_xfer_inferior_memory;
  mm_ops.to_files_info  =   mm_files_info;
  mm_ops.to_insert_breakpoint =   mm_insert_breakpoint;
  mm_ops.to_remove_breakpoint =   mm_remove_breakpoint;
  mm_ops.to_terminal_init  =   0;
  mm_ops.to_terminal_inferior =   0;
  mm_ops.to_terminal_ours_for_output =   0;
  mm_ops.to_terminal_ours  =   0;
  mm_ops.to_terminal_info  =   0;        
  mm_ops.to_kill  =   mm_kill;           
  mm_ops.to_load  =   mm_load;
  mm_ops.to_lookup_symbol =   0;           
  mm_ops.to_create_inferior =   mm_create_inferior;
d1859 1
a1859 1
  mm_ops.to_post_follow_vfork = NULL; 
d1865 5
a1869 5
  mm_ops.to_mourn_inferior =   mm_mourn; 
  mm_ops.to_can_run  =   0;	
  mm_ops.to_notice_signals =   0;
  mm_ops.to_thread_alive  =   0;
  mm_ops.to_stop  =   0;		
d1872 10
a1881 10
  mm_ops.to_stratum =   process_stratum;
  mm_ops.DONT_USE =   0; 
  mm_ops.to_has_all_memory =   1;
  mm_ops.to_has_memory =   1;
  mm_ops.to_has_stack =   1;
  mm_ops.to_has_registers =   1;
  mm_ops.to_has_execution =   1; 
  mm_ops.to_sections =   0;
  mm_ops.to_sections_end =   0;	
  mm_ops.to_magic =   OPS_MAGIC;    
d1885 1
a1885 1
_initialize_remote_mm()
d1887 1
a1887 1
  init_mm_ops() ;
d1892 2
a1893 2
service_HIF(msg)
union msg_t	*msg;
d1895 1
a1895 1
	return(0);	/* Emulate a failure */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d23 9
a31 9
   - David Wood (wood@@lab.ultra.nyu.edu) at New York University adapted this
   file to gdb 3.95.  I was unable to get this working on sun3os4
   with termio, only with sgtty.  Because we are only attempting to
   use this module to debug our kernel, which is already loaded when
   gdb is started up, I did not code up the file downloading facilities.  
   As a result this module has only the stubs to download files. 
   You should get tagged at compile time if you need to make any 
   changes/additions.  */

d50 1
a50 1
extern int stop_soon_quietly;	/* for wait_for_inferior */
d52 1
a52 1
static void mm_resume ();
d57 7
a63 7
static int regnum_to_srnum ();
static void mm_close ();
static char *msg_str ();
static char *error_msg_str ();
static int expect_msg ();
static void init_target_mm ();
static int mm_memory_space ();
d78 1
a78 1
#define BUFER_SIZE  512
d84 1
a84 1
/*               
d94 1
a94 1
static char in_buf[BUFER_SIZE];
d96 2
a97 2
int msg_recv_serial ();
int msg_send_serial ();
d100 4
a103 4
extern struct target_ops mm_ops;	/* Forward declaration */
struct config_msg_t target_config;	/* HIF needs this */
union msg_t *out_msg_buf = (union msg_t *) out_buf;
union msg_t *in_msg_buf = (union msg_t *) in_buf;
d120 2
a121 3
#ifndef volatile
#define volatile
/**/
d156 4
a159 4
  int token_count;
  int result;
  char *token[MAX_TOKENS];
  char cmd_line[BUFFER_SIZE];
d167 4
a170 5
  if (!mm_stream)
    {
      printf ("Minimon not open yet.\n");
      return;
    }
d175 1
a175 1
   */
d188 1
a188 1
mm_mourn ()
d190 2
a191 2
  pop_target ();		/* Pop back to no-child state */
  generic_mourn_inferior ();
d206 18
a223 74
static struct
{
  int rate, damn_b;
}
baudtab[] =
{
  {
    0, B0
  }
  ,
  {
    50, B50
  }
  ,
  {
    75, B75
  }
  ,
  {
    110, B110
  }
  ,
  {
    134, B134
  }
  ,
  {
    150, B150
  }
  ,
  {
    200, B200
  }
  ,
  {
    300, B300
  }
  ,
  {
    600, B600
  }
  ,
  {
    1200, B1200
  }
  ,
  {
    1800, B1800
  }
  ,
  {
    2400, B2400
  }
  ,
  {
    4800, B4800
  }
  ,
  {
    9600, B9600
  }
  ,
  {
    19200, B19200
  }
  ,
  {
    38400, B38400
  }
  ,
  {
    -1, -1
  }
  ,
d226 1
a226 2
static int
damn_b (rate)
d232 2
a233 3
    if (rate == baudtab[i].rate)
      return baudtab[i].damn_b;
  return B38400;		/* Random */
d261 1
a261 1
  erroid:
d263 1
a263 1
  dev_name = (char *) xmalloc (p - name + 1);
d269 2
a270 2
    /*EMPTY */ ;

d276 1
a276 1
    /*EMPTY */ ;
d278 2
a279 2
    /*EMPTY */ ;

d329 2
a330 2
  /*
     ** Initialize target configuration structure (global)
d332 4
a335 4
  DRAIN_INPUT ();
  out_msg_buf->config_req_msg.code = CONFIG_REQ;
  out_msg_buf->config_req_msg.length = 4 * 0;
  msg_send_serial (out_msg_buf);	/* send config request message */
d337 1
a337 1
  expect_msg (CONFIG, in_msg_buf, 1);
d342 9
a350 10
  printf_filtered ("Connected to MiniMon via %s.\n", dev_name);
  /* FIXME: can this restriction be removed? */
  printf_filtered ("Remote debugging using virtual addresses works only\n");
  printf_filtered ("\twhen virtual addresses map 1:1 to physical addresses.\n")
    ;
  if (processor_type != a29k_freeze_mode)
    {
      fprintf_filtered (gdb_stderr,
			"Freeze-mode debugging not available, and can only be done on an A29050.\n");
    }
d352 29
a380 30
  target_config.code = CONFIG;
  target_config.length = 0;
  target_config.processor_id = in_msg_buf->config_msg.processor_id;
  target_config.version = in_msg_buf->config_msg.version;
  target_config.I_mem_start = in_msg_buf->config_msg.I_mem_start;
  target_config.I_mem_size = in_msg_buf->config_msg.I_mem_size;
  target_config.D_mem_start = in_msg_buf->config_msg.D_mem_start;
  target_config.D_mem_size = in_msg_buf->config_msg.D_mem_size;
  target_config.ROM_start = in_msg_buf->config_msg.ROM_start;
  target_config.ROM_size = in_msg_buf->config_msg.ROM_size;
  target_config.max_msg_size = in_msg_buf->config_msg.max_msg_size;
  target_config.max_bkpts = in_msg_buf->config_msg.max_bkpts;
  target_config.coprocessor = in_msg_buf->config_msg.coprocessor;
  target_config.reserved = in_msg_buf->config_msg.reserved;
  if (from_tty)
    {
      printf ("Connected to MiniMON :\n");
      printf ("    Debugcore version            %d.%d\n",
	      0x0f & (target_config.version >> 4),
	      0x0f & (target_config.version));
      printf ("    Configuration version        %d.%d\n",
	      0x0f & (target_config.version >> 12),
	      0x0f & (target_config.version >> 8));
      printf ("    Message system version       %d.%d\n",
	      0x0f & (target_config.version >> 20),
	      0x0f & (target_config.version >> 16));
      printf ("    Communication driver version %d.%d\n",
	      0x0f & (target_config.version >> 28),
	      0x0f & (target_config.version >> 24));
    }
d388 1
a388 1
  msg_send_serial (out_msg_buf);
d397 1
a397 1
mm_close (quitting)		/*FIXME: how is quitting used */
d409 2
a410 2
  DRAIN_INPUT ();
  fclose (mm_stream);
d425 1
a425 1
}
d438 2
a439 2
    error ("MiniMon not opened yet, use the 'target minimon' command.\n");

d441 1
a441 1
    printf ("Attaching to remote program %s...\n", prog_name);
d445 1
a445 1
   *  the dbg core.  If so, we don't need to send this GO.
d449 4
a452 4
  msg_send_serial (out_msg_buf);
  sleep (2);			/* At the worst it will stop, receive a message, continue */

  /* Send the mm a break. */
d455 1
a455 1
  msg_send_serial (out_msg_buf);
d462 1
a462 1
mm_detach (args, from_tty)
d466 1
a466 1
  remove_breakpoints ();	/* Just in case there were any left in */
d469 2
a470 2
  msg_send_serial (out_msg_buf);
  pop_target ();		/* calls mm_close to do the real work */
d485 7
a491 10
  if (step)
    {
      out_msg_buf->step_msg.code = STEP;
      out_msg_buf->step_msg.length = 1 * 4;
      out_msg_buf->step_msg.count = 1;	/* step 1 instruction */
      msg_send_serial (out_msg_buf);
    }
  else
    {
      out_msg_buf->go_msg.code = GO;
d493 2
a494 2
      msg_send_serial (out_msg_buf);
    }
d513 16
a528 11
   - A HIF service request.
   - A HIF exit service request.
   - A CHANNEL0_ACK.
   - A CHANNEL1 request.
   - a debugcore HALT message.
   HIF services must be responded too, and while-looping continued.
   If the target stops executing, mm_wait() should return.
 */
  timeout = 0;			/* Wait indefinetly for a message */
  immediate_quit = 1;		/* Helps ability to QUIT */
  while (1)
d530 4
a533 10
      while (msg_recv_serial (in_msg_buf))
	{
	  QUIT;			/* Let user quit if they want */
	}
      switch (in_msg_buf->halt_msg.code)
	{
	case HIF_CALL:
	  i = in_msg_buf->hif_call_rtn_msg.service_number;
	  result = service_HIF (in_msg_buf);
	  if (i == 1)		/* EXIT */
d535 20
a554 21
	  if (result)
	    printf ("Warning: failure during HIF service %d\n", i);
	  break;
	case CHANNEL0_ACK:
	  service_HIF (in_msg_buf);
	  break;
	case CHANNEL1:
	  i = in_msg_buf->channel1_msg.length;
	  in_msg_buf->channel1_msg.data[i] = '\0';
	  printf ("%s", in_msg_buf->channel1_msg.data);
	  gdb_flush (gdb_stdout);
	  /* Send CHANNEL1_ACK message */
	  out_msg_buf->channel1_ack_msg.code = CHANNEL1_ACK;
	  out_msg_buf->channel1_ack_msg.length = 0;
	  result = msg_send_serial (out_msg_buf);
	  break;
	case HALT:
	  goto halted;
	default:
	  goto halted;
	}
d556 1
d560 7
a566 8
  if (in_msg_buf->halt_msg.trap_number == 0)
    {
      printf ("Am290*0 received vector number %d (break point)\n",
	      in_msg_buf->halt_msg.trap_number);
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = TARGET_SIGNAL_TRAP;
    }
  else if (in_msg_buf->halt_msg.trap_number == 1)
d568 2
a569 2
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
d573 4
a576 5
  else if (in_msg_buf->halt_msg.trap_number == 3
	   || in_msg_buf->halt_msg.trap_number == 4)
    {
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
d579 4
a582 5
    }
  else if (in_msg_buf->halt_msg.trap_number == 5)
    {
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
d585 1
a585 1
    }
d587 3
a589 4
	   && in_msg_buf->halt_msg.trap_number <= 11)
    {
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
d592 5
a596 6
    }
  else if (in_msg_buf->halt_msg.trap_number == 12
	   || in_msg_buf->halt_msg.trap_number == 13)
    {
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
d599 4
a602 5
    }
  else if (in_msg_buf->halt_msg.trap_number == 14)
    {
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
d605 2
a606 2
    }
  else if (in_msg_buf->halt_msg.trap_number == 15)
d612 3
a614 4
	   && in_msg_buf->halt_msg.trap_number <= 21)
    {
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
d617 4
a620 5
    }
  else if (in_msg_buf->halt_msg.trap_number == 22)
    {
      printf ("Am290*0 received vector number %d\n",
	      in_msg_buf->halt_msg.trap_number);
d623 2
a624 2
    }				/* BREAK message was sent */
  else if (in_msg_buf->halt_msg.trap_number == 75)
d630 1
a630 1
  exit:
d645 1
a645 1
static void
d647 1
a647 1
     int regno;
d651 4
a654 5
  if (regno >= 0)
    {
      fetch_register (regno);
      return;
    }
d657 1
a657 1
  out_msg_buf->read_req_msg.byte_count = 4 * 1;
d660 2
a661 2
  msg_send_serial (out_msg_buf);
  expect_msg (READ_ACK, in_msg_buf, 1);
d663 1
a663 1
  supply_register (GR1_REGNUM, data_p);
d666 4
a669 4
/* Global Registers gr64-gr95 */
  out_msg_buf->read_req_msg.code = READ_REQ;
  out_msg_buf->read_req_msg.length = 4 * 3;
  out_msg_buf->read_req_msg.byte_count = 4 * 32;
d672 2
a673 2
  msg_send_serial (out_msg_buf);
  expect_msg (READ_ACK, in_msg_buf, 1);
d676 1
a676 2
  for (regno = GR64_REGNUM; regno < GR64_REGNUM + 32; regno++)
    {
d678 2
a679 2
    }
#endif /*  GR64_REGNUM */
d681 3
a683 3
/* Global Registers gr96-gr127 */
  out_msg_buf->read_req_msg.code = READ_REQ;
  out_msg_buf->read_req_msg.length = 4 * 3;
d687 2
a688 2
  msg_send_serial (out_msg_buf);
  expect_msg (READ_ACK, in_msg_buf, 1);
d691 1
a691 2
  for (regno = GR96_REGNUM; regno < GR96_REGNUM + 32; regno++)
    {
d693 1
a693 1
    }
d695 1
a695 1
/* Local Registers */
d699 2
a700 2
  msg_send_serial (out_msg_buf);
  expect_msg (READ_ACK, in_msg_buf, 1);
d703 1
a703 2
  for (regno = LR0_REGNUM; regno < LR0_REGNUM + 128; regno++)
    {
d705 1
a705 1
    }
d707 2
a708 2
/* Protected Special Registers */
  out_msg_buf->read_req_msg.byte_count = 4 * 15;
d711 2
a712 2
  msg_send_serial (out_msg_buf);
  expect_msg (READ_ACK, in_msg_buf, 1);
d715 8
a722 10
  for (regno = 0; regno <= 14; regno++)
    {
      supply_register (SR_REGNUM (regno), data_p++);
    }
  if (USE_SHADOW_PC)
    {				/* Let regno_to_srnum() handle the register number */
      fetch_register (NPC_REGNUM);
      fetch_register (PC_REGNUM);
      fetch_register (PC2_REGNUM);
    }
d724 2
a725 2
/* Unprotected Special Registers */
  out_msg_buf->read_req_msg.byte_count = 4 * 8;
d728 2
a729 2
  msg_send_serial (out_msg_buf);
  expect_msg (READ_ACK, in_msg_buf, 1);
d732 3
a734 4
  for (regno = 128; regno <= 135; regno++)
    {
      supply_register (SR_REGNUM (regno), data_p++);
    }
d755 1
a755 1
     int regno;
d758 5
a762 6

  if (regno >= 0)
    {
      store_register (regno);
      return;
    }
d766 1
a766 1
  out_msg_buf->write_r_msg.code = WRITE_REQ;
d769 2
a770 2
  out_msg_buf->write_r_msg.byte_count = 4 * 1;
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
d775 4
a778 5
  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
    }
d782 2
a783 2
  out_msg_buf->write_r_msg.byte_count = 4 * (32);
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
d786 1
a786 1
  for (regno = GR64_REGNUM; regno < GR64_REGNUM + 32; regno++)
d788 1
a788 1
      out_msg_buf->write_r_msg.data[regno - GR64_REGNUM] = read_register (regno);
d790 5
a794 6
  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
    }
#endif /* GR64_REGNUM */
d797 2
a798 2
  out_msg_buf->write_r_msg.byte_count = 4 * (32);
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
d800 1
a800 1
  for (regno = GR96_REGNUM; regno < GR96_REGNUM + 32; regno++)
d802 1
a802 6
      out_msg_buf->write_r_msg.data[regno - GR96_REGNUM] = read_register (regno);
    }
  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
d804 4
d811 2
a812 2
  out_msg_buf->write_r_msg.byte_count = 4 * 128;
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
d815 1
a815 1
  for (regno = LR0_REGNUM; regno < LR0_REGNUM + 128; regno++)
d817 1
a817 6
      out_msg_buf->write_r_msg.data[regno - LR0_REGNUM] = read_register (regno);
    }
  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
d819 4
d824 1
a824 1
/* Protected Special Registers */
d827 2
a828 2
  out_msg_buf->write_r_msg.byte_count = 4 * 10;
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
d830 6
a835 7
  for (regno = 0; regno <= 9; regno++)	/* VAB through TMR */
    out_msg_buf->write_r_msg.data[regno] = read_register (SR_REGNUM (regno));
  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
    }
d838 5
a842 5
  out_msg_buf->write_r_msg.byte_count = 4 * 3;
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
  for (regno = 10; regno <= 12; regno++)	/* LRU and MMU */
    out_msg_buf->write_r_msg.data[regno - 10] = read_register (SR_REGNUM (regno));
  if (USE_SHADOW_PC)
d844 1
a844 1
  else
d846 4
a849 5
  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
    }
d852 2
a853 2
  out_msg_buf->write_r_msg.byte_count = 4 * 2;
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
d855 6
a860 7
  for (regno = 13; regno <= 14; regno++)	/* LRU and MMU */
    out_msg_buf->write_r_msg.data[regno - 13] = read_register (SR_REGNUM (regno));
  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
    }
d862 3
a864 3
/* Unprotected Special Registers */
  out_msg_buf->write_r_msg.byte_count = 4 * 8;
  out_msg_buf->write_r_msg.length = 3 * 4 + out_msg_buf->write_r_msg.byte_count;
d866 7
a872 8
  for (regno = 128; regno <= 135; regno++)
    out_msg_buf->write_r_msg.data[regno - 128] = read_register (SR_REGNUM (regno));
  msg_send_serial (out_msg_buf);
  if (!expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = -1;
    }

d891 2
a892 2
translate_addr (addr)
     CORE_ADDR addr;
d895 10
a904 13
  /* Check for a virtual address in the kernel */
  /* Assume physical address of ublock is in  paddr_u register */
  /* FIXME: doesn't work for user virtual addresses */
  if (addr >= UVADDR)
    {
      /* PADDR_U register holds the physical address of the ublock */
      CORE_ADDR i = (CORE_ADDR) read_register (PADDR_U_REGNUM);
      return (i + addr - (CORE_ADDR) UVADDR);
    }
  else
    {
      return (addr);
    }
d906 1
a906 1
  return (addr);
d915 1
a915 1
	  dev_name, baudrate, prog_name);
d925 1
a925 1
  out_msg_buf->bkpt_set_msg.length = 4 * 4;
d930 6
a935 9
  msg_send_serial (out_msg_buf);
  if (expect_msg (BKPT_SET_ACK, in_msg_buf, 1))
    {
      return 0;			/* Success */
    }
  else
    {
      return 1;			/* Failure */
    }
d945 1
a945 1
  out_msg_buf->bkpt_rm_msg.length = 4 * 3;
d948 6
a953 9
  msg_send_serial (out_msg_buf);
  if (expect_msg (BKPT_RM_ACK, in_msg_buf, 1))
    {
      return 0;			/* Success */
    }
  else
    {
      return 1;			/* Failure */
    }
d959 3
a961 3
mm_kill (arg, from_tty)
     char *arg;
     int from_tty;
d963 1
a963 1
  char buf[4];
d966 5
a970 6
  /* We don't ever kill the kernel */
  if (from_tty)
    {
      printf ("Kernel not killed, but left in current state.\n");
      printf ("Use detach to leave kernel running.\n");
    }
d972 13
a984 14
  out_msg_buf->break_msg.code = BREAK;
  out_msg_buf->bkpt_set_msg.length = 4 * 0;
  expect_msg (HALT, in_msg_buf, from_tty);
  if (from_tty)
    {
      printf ("Target has been stopped.");
      printf ("Would you like to do a hardware reset (y/n) [n] ");
      fgets (buf, 3, stdin);
      if (buf[0] == 'y')
	{
	  out_msg_buf->reset_msg.code = RESET;
	  out_msg_buf->bkpt_set_msg.length = 4 * 0;
	  expect_msg (RESET_ACK, in_msg_buf, from_tty);
	  printf ("Target has been reset.");
d986 2
a987 3
    }
  pop_target ();
#endif
d997 3
a999 3
mm_load (arg_string, from_tty)
     char *arg_string;
     int from_tty;
d1004 1
a1004 1
  printf ("The kernel had better be loaded already!  Loading not done.\n");
d1013 1
a1013 1
  error ("File loading is not yet supported for MiniMon.");
d1032 1
a1032 1
  int i, nwritten;
d1034 2
a1035 2
  out_msg_buf->write_req_msg.code = WRITE_REQ;
  out_msg_buf->write_req_msg.memory_space = mm_memory_space (memaddr);
d1037 18
a1054 23
  nwritten = 0;
  while (nwritten < len)
    {
      int num_to_write = len - nwritten;
      if (num_to_write > MAXDATA)
	num_to_write = MAXDATA;
      for (i = 0; i < num_to_write; i++)
	out_msg_buf->write_req_msg.data[i] = myaddr[i + nwritten];
      out_msg_buf->write_req_msg.byte_count = num_to_write;
      out_msg_buf->write_req_msg.length = 3 * 4 + num_to_write;
      out_msg_buf->write_req_msg.address = memaddr + nwritten;
      msg_send_serial (out_msg_buf);

      if (expect_msg (WRITE_ACK, in_msg_buf, 1))
	{
	  nwritten += in_msg_buf->write_ack_msg.byte_count;
	}
      else
	{
	  break;
	}
    }
  return (nwritten);
d1061 1
a1061 1
mm_read_inferior_memory (memaddr, myaddr, len)
d1066 1
a1066 1
  int i, nread;
d1068 2
a1069 2
  out_msg_buf->read_req_msg.code = READ_REQ;
  out_msg_buf->read_req_msg.memory_space = mm_memory_space (memaddr);
d1071 18
a1088 23
  nread = 0;
  while (nread < len)
    {
      int num_to_read = (len - nread);
      if (num_to_read > MAXDATA)
	num_to_read = MAXDATA;
      out_msg_buf->read_req_msg.byte_count = num_to_read;
      out_msg_buf->read_req_msg.length = 3 * 4 + num_to_read;
      out_msg_buf->read_req_msg.address = memaddr + nread;
      msg_send_serial (out_msg_buf);

      if (expect_msg (READ_ACK, in_msg_buf, 1))
	{
	  for (i = 0; i < in_msg_buf->read_ack_msg.byte_count; i++)
	    myaddr[i + nread] = in_msg_buf->read_ack_msg.data[i];
	  nread += in_msg_buf->read_ack_msg.byte_count;
	}
      else
	{
	  break;
	}
    }
  return (nread);
d1100 1
a1100 1
  memaddr = translate_addr (memaddr);
d1122 2
a1123 2
msg_send_serial (msg_ptr)
     union msg_t *msg_ptr;
d1125 15
a1139 18
  INT32 message_size;
  int byte_count;
  int result;
  char c;

  /* Send message header */
  byte_count = 0;
  message_size = msg_ptr->generic_msg.length + (2 * sizeof (INT32));
  do
    {
      c = *((char *) msg_ptr + byte_count);
      result = write (mm_desc, &c, 1);
      if (result == 1)
	{
	  byte_count = byte_count + 1;
	}
    }
  while ((byte_count < message_size));
d1141 2
a1142 2
  return (0);
}				/* end msg_send_serial() */
d1156 2
a1157 2
msg_recv_serial (msg_ptr)
     union msg_t *msg_ptr;
d1159 7
a1165 8
  static INT32 length = 0;
  static INT32 byte_count = 0;
  int result;
  char c;
  if (msg_ptr == 0)		/* re-sync request */
    {
      length = 0;
      byte_count = 0;
d1167 3
a1169 3
      /* The timeout here is the prevailing timeout set with VTIME */
      ->"timeout==0 semantics not supported"
	read (mm_desc, in_buf, BUFER_SIZE);
d1171 3
a1173 3
      alarm (1);
      read (mm_desc, in_buf, BUFER_SIZE);
      alarm (0);
d1175 3
a1177 3
      return (0);
    }
  /* Receive message */
d1180 2
a1181 2
  ->"timeout==0 semantics not supported (and its nice if they are)"
    result = read (mm_desc, &c, 1);
d1183 2
a1184 2
  alarm (timeout);
  result = read (mm_desc, &c, 1);
d1187 4
a1190 7
  if (result < 0)
    {
      if (errno == EINTR)
	{
	  error ("Timeout reading from remote system.");
	}
      else
d1192 2
a1193 4
    }
  else if (result == 1)
    {
      *((char *) msg_ptr + byte_count) = c;
d1195 1
a1195 1
    }
d1197 3
a1199 3
  /* Message header received.  Save message length. */
  if (byte_count == (2 * sizeof (INT32)))
    length = msg_ptr->generic_msg.length;
d1201 1
a1201 2
  if (byte_count >= (length + (2 * sizeof (INT32))))
    {
d1204 3
a1206 4
      return (0);
    }
  else
    return (-1);
d1208 1
a1208 1
}				/* end msg_recv_serial() */
d1218 3
a1220 4
kbd_raw ()
{
  int result;
  TERMINAL tbuf;
d1222 1
a1222 1
  /* Get keyboard termio (to save to restore original modes) */
d1224 1
a1224 1
  result = ioctl (0, TCGETA, &kbd_tbuf);
d1226 1
a1226 1
  result = ioctl (0, TIOCGETP, &kbd_tbuf);
d1228 2
a1229 2
  if (result == -1)
    return (errno);
d1231 1
a1231 1
  /* Get keyboard TERMINAL (for modification) */
d1233 1
a1233 1
  result = ioctl (0, TCGETA, &tbuf);
d1235 1
a1235 1
  result = ioctl (0, TIOCGETP, &tbuf);
d1237 2
a1238 2
  if (result == -1)
    return (errno);
d1240 1
a1240 1
  /* Set up new parameters */
d1242 5
a1246 5
  tbuf.c_iflag = tbuf.c_iflag &
    ~(INLCR | ICRNL | IUCLC | ISTRIP | IXON | BRKINT);
  tbuf.c_lflag = tbuf.c_lflag & ~(ICANON | ISIG | ECHO);
  tbuf.c_cc[4] = 0;		/* MIN */
  tbuf.c_cc[5] = 0;		/* TIME */
d1248 4
a1251 4
  /* FIXME: not sure if this is correct (matches HAVE_TERMIO). */
  tbuf.sg_flags |= RAW;
  tbuf.sg_flags |= ANYP;
  tbuf.sg_flags &= ~ECHO;
d1254 1
a1254 1
  /* Set keyboard termio to new mode (RAW) */
d1256 1
a1256 1
  result = ioctl (0, TCSETAF, &tbuf);
d1258 4
a1261 4
  result = ioctl (0, TIOCSETP, &tbuf);
#endif
  if (result == -1)
    return (errno);
d1263 2
a1264 2
  return (0);
}				/* end kbd_raw() */
d1276 2
a1277 3
kbd_restore ()
{
  int result;
d1279 1
a1279 1
  /* Set keyboard termio to original mode */
d1281 1
a1281 1
  result = ioctl (0, TCSETAF, &kbd_tbuf);
d1283 1
a1283 1
  result = ioctl (0, TIOCGETP, &kbd_tbuf);
d1286 2
a1287 2
  if (result == -1)
    return (errno);
d1289 2
a1290 2
  return (0);
}				/* end kbd_cooked() */
d1293 1
a1293 1
/*****************************************************************************/
d1301 3
a1303 3
  int result;
  out_msg_buf->read_req_msg.code = READ_REQ;
  out_msg_buf->read_req_msg.length = 4 * 3;
d1307 3
a1309 4
    {
      out_msg_buf->read_req_msg.memory_space = GLOBAL_REG;
      out_msg_buf->read_req_msg.address = 1;
    }
d1311 3
a1313 4
    {
      out_msg_buf->read_req_msg.memory_space = GLOBAL_REG;
      out_msg_buf->read_req_msg.address = (regno - GR96_REGNUM) + 96;
    }
d1315 5
a1319 6
  else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32)
    {
      out_msg_buf->read_req_msg.memory_space = GLOBAL_REG;
      out_msg_buf->read_req_msg.address = (regno - GR64_REGNUM) + 64;
    }
#endif /* GR64_REGNUM */
d1321 21
a1341 27
    {
      out_msg_buf->read_req_msg.memory_space = LOCAL_REG;
      out_msg_buf->read_req_msg.address = (regno - LR0_REGNUM);
    }
  else if (regno >= FPE_REGNUM && regno <= EXO_REGNUM)
    {
      int val = -1;
      supply_register (160 + (regno - FPE_REGNUM), &val);
      return 0;			/* Pretend Success */
    }
  else
    {
      out_msg_buf->read_req_msg.memory_space = SPECIAL_REG;
      out_msg_buf->read_req_msg.address = regnum_to_srnum (regno);
    }

  msg_send_serial (out_msg_buf);

  if (expect_msg (READ_ACK, in_msg_buf, 1))
    {
      supply_register (regno, &(in_msg_buf->read_r_ack_msg.data[0]));
      result = 0;
    }
  else
    {
      result = -1;
    }
d1344 1
a1344 1
/*****************************************************************************/
d1352 1
a1352 1
  int result;
d1354 2
a1355 2
  out_msg_buf->write_req_msg.code = WRITE_REQ;
  out_msg_buf->write_req_msg.length = 4 * 4;
d1360 10
a1369 11
    {
      out_msg_buf->write_req_msg.memory_space = GLOBAL_REG;
      out_msg_buf->write_req_msg.address = 1;
      /* Setting GR1 changes the numbers of all the locals, so invalidate the 
       * register cache.  Do this *after* calling read_register, because we want 
       * read_register to return the value that write_register has just stuffed 
       * into the registers array, not the value of the register fetched from 
       * the inferior.  
       */
      registers_changed ();
    }
d1371 5
a1375 6
  else if (regno >= GR64_REGNUM && regno < GR64_REGNUM + 32)
    {
      out_msg_buf->write_req_msg.memory_space = GLOBAL_REG;
      out_msg_buf->write_req_msg.address = (regno - GR64_REGNUM) + 64;
    }
#endif /* GR64_REGNUM */
d1377 3
a1379 4
    {
      out_msg_buf->write_req_msg.memory_space = GLOBAL_REG;
      out_msg_buf->write_req_msg.address = (regno - GR96_REGNUM) + 96;
    }
d1381 19
a1399 25
    {
      out_msg_buf->write_req_msg.memory_space = LOCAL_REG;
      out_msg_buf->write_req_msg.address = (regno - LR0_REGNUM);
    }
  else if (regno >= FPE_REGNUM && regno <= EXO_REGNUM)
    {
      return 0;			/* Pretend Success */
    }
  else
    /* An unprotected or protected special register */
    {
      out_msg_buf->write_req_msg.memory_space = SPECIAL_REG;
      out_msg_buf->write_req_msg.address = regnum_to_srnum (regno);
    }

  msg_send_serial (out_msg_buf);

  if (expect_msg (WRITE_ACK, in_msg_buf, 1))
    {
      result = 0;
    }
  else
    {
      result = -1;
    }
d1407 2
a1408 2
regnum_to_srnum (regno)
     int regno;
d1410 31
a1440 59
  switch (regno)
    {
    case VAB_REGNUM:
      return (0);
    case OPS_REGNUM:
      return (1);
    case CPS_REGNUM:
      return (2);
    case CFG_REGNUM:
      return (3);
    case CHA_REGNUM:
      return (4);
    case CHD_REGNUM:
      return (5);
    case CHC_REGNUM:
      return (6);
    case RBP_REGNUM:
      return (7);
    case TMC_REGNUM:
      return (8);
    case TMR_REGNUM:
      return (9);
    case NPC_REGNUM:
      return (USE_SHADOW_PC ? (20) : (10));
    case PC_REGNUM:
      return (USE_SHADOW_PC ? (21) : (11));
    case PC2_REGNUM:
      return (USE_SHADOW_PC ? (22) : (12));
    case MMU_REGNUM:
      return (13);
    case LRU_REGNUM:
      return (14);
    case IPC_REGNUM:
      return (128);
    case IPA_REGNUM:
      return (129);
    case IPB_REGNUM:
      return (130);
    case Q_REGNUM:
      return (131);
    case ALU_REGNUM:
      return (132);
    case BP_REGNUM:
      return (133);
    case FC_REGNUM:
      return (134);
    case CR_REGNUM:
      return (135);
    case FPE_REGNUM:
      return (160);
    case INTE_REGNUM:
      return (161);
    case FPS_REGNUM:
      return (162);
    case EXO_REGNUM:
      return (164);
    default:
      return (255);		/* Failure ? */
    }
d1447 17
a1463 17
init_target_mm (tstart, tend, dstart, dend, entry, ms_size, rs_size, arg_start)
     ADDR32 tstart, tend, dstart, dend, entry;
     INT32 ms_size, rs_size;
     ADDR32 arg_start;
{
  out_msg_buf->init_msg.code = INIT;
  out_msg_buf->init_msg.length = sizeof (struct init_msg_t) - 2 * sizeof (INT32);
  out_msg_buf->init_msg.text_start = tstart;
  out_msg_buf->init_msg.text_end = tend;
  out_msg_buf->init_msg.data_start = dstart;
  out_msg_buf->init_msg.data_end = dend;
  out_msg_buf->init_msg.entry_point = entry;
  out_msg_buf->init_msg.mem_stack_size = ms_size;
  out_msg_buf->init_msg.reg_stack_size = rs_size;
  out_msg_buf->init_msg.arg_start = arg_start;
  msg_send_serial (out_msg_buf);
  expect_msg (INIT_ACK, in_msg_buf, 1);
d1471 17
a1487 34
static char *
msg_str (code)
     INT32 code;
{
  static char cbuf[32];

  switch (code)
    {
    case BKPT_SET_ACK:
      sprintf (cbuf, "%s (%d)", "BKPT_SET_ACK", code);
      break;
    case BKPT_RM_ACK:
      sprintf (cbuf, "%s (%d)", "BKPT_RM_ACK", code);
      break;
    case INIT_ACK:
      sprintf (cbuf, "%s (%d)", "INIT_ACK", code);
      break;
    case READ_ACK:
      sprintf (cbuf, "%s (%d)", "READ_ACK", code);
      break;
    case WRITE_ACK:
      sprintf (cbuf, "%s (%d)", "WRITE_ACK", code);
      break;
    case ERROR:
      sprintf (cbuf, "%s (%d)", "ERROR", code);
      break;
    case HALT:
      sprintf (cbuf, "%s (%d)", "HALT", code);
      break;
    default:
      sprintf (cbuf, "UNKNOWN (%d)", code);
      break;
    }
  return (cbuf);
d1493 32
a1524 5
static char *
error_msg_str (code)
     INT32 code;
{
  static char cbuf[50];
d1526 1
a1526 54
  switch (code)
    {
    case EMFAIL:
      return ("EMFAIL: unrecoverable error");
    case EMBADADDR:
      return ("EMBADADDR: Illegal address");
    case EMBADREG:
      return ("EMBADREG: Illegal register ");
    case EMACCESS:
      return ("EMACCESS: Could not access memory");
    case EMBADMSG:
      return ("EMBADMSG: Unknown message type");
    case EMMSG2BIG:
      return ("EMMSG2BIG: Message to large");
    case EMNOSEND:
      return ("EMNOSEND: Could not send message");
    case EMNORECV:
      return ("EMNORECV: Could not recv message");
    case EMRESET:
      return ("EMRESET: Could not RESET target");
    case EMCONFIG:
      return ("EMCONFIG: Could not get target CONFIG");
    case EMSTATUS:
      return ("EMSTATUS: Could not get target STATUS");
    case EMREAD:
      return ("EMREAD: Could not READ target memory");
    case EMWRITE:
      return ("EMWRITE: Could not WRITE target memory");
    case EMBKPTSET:
      return ("EMBKPTSET: Could not set breakpoint");
    case EMBKPTRM:
      return ("EMBKPTRM: Could not remove breakpoint");
    case EMBKPTSTAT:
      return ("EMBKPTSTAT: Could not get breakpoint status");
    case EMBKPTNONE:
      return ("EMBKPTNONE: All breakpoints in use");
    case EMBKPTUSED:
      return ("EMBKPTUSED: Breakpoints already in use");
    case EMINIT:
      return ("EMINIT: Could not init target memory");
    case EMGO:
      return ("EMGO: Could not start execution");
    case EMSTEP:
      return ("EMSTEP: Could not single step");
    case EMBREAK:
      return ("EMBREAK: Could not BREAK");
    case EMCOMMERR:
      return ("EMCOMMERR: Communication error");
    default:
      sprintf (cbuf, "error number %d", code);
      break;
    }				/* end switch */

  return (cbuf);
d1534 12
a1545 13
expect_msg (msgcode, msg_buf, from_tty)
     INT32 msgcode;		/* Msg code we expect */
     union msg_t *msg_buf;	/* Where to put  the message received */
     int from_tty;		/* Print message on error if non-zero */
{
  int retries = 0;
  while (msg_recv_serial (msg_buf) && (retries++ < MAX_RETRIES));
  if (retries >= MAX_RETRIES)
    {
      printf ("Expected msg %s, ", msg_str (msgcode));
      printf ("no message received!\n");
      return (0);		/* Failure */
    }
d1547 11
a1557 13
  if (msg_buf->generic_msg.code != msgcode)
    {
      if (from_tty)
	{
	  printf ("Expected msg %s, ", msg_str (msgcode));
	  printf ("got msg %s\n", msg_str (msg_buf->generic_msg.code));
	  if (msg_buf->generic_msg.code == ERROR)
	    printf ("%s\n", error_msg_str (msg_buf->error_msg.error_code));
	}
      return (0);		/* Failure */
    }
  return (1);			/* Success */
}
d1565 2
a1566 2
mm_memory_space (addr)
     CORE_ADDR *addr;
d1568 16
a1583 22
  ADDR32 tstart = target_config.I_mem_start;
  ADDR32 tend = tstart + target_config.I_mem_size;
  ADDR32 dstart = target_config.D_mem_start;
  ADDR32 dend = tstart + target_config.D_mem_size;
  ADDR32 rstart = target_config.ROM_start;
  ADDR32 rend = tstart + target_config.ROM_size;

  if (((ADDR32) addr >= tstart) && ((ADDR32) addr < tend))
    {
      return I_MEM;
    }
  else if (((ADDR32) addr >= dstart) && ((ADDR32) addr < dend))
    {
      return D_MEM;
    }
  else if (((ADDR32) addr >= rstart) && ((ADDR32) addr < rend))
    {
      /* FIXME: how do we determine between D_ROM and I_ROM */
      return D_ROM;
    }
  else				/* FIXME: what do me do now? */
    return D_MEM;		/* Hmmm! */
d1590 1
a1590 1
struct target_ops mm_ops;
d1592 2
a1593 2
static void
init_mm_ops (void)
d1595 6
a1600 6
  mm_ops.to_shortname = "minimon";
  mm_ops.to_longname = "Remote AMD/Minimon target";
  mm_ops.to_doc = "Remote debug an AMD 290*0 using the MiniMon dbg core on the target";
  mm_ops.to_open = mm_open;
  mm_ops.to_close = mm_close;
  mm_ops.to_attach = mm_attach;
d1603 1
a1603 1
  mm_ops.to_detach = mm_detach;
d1605 2
a1606 2
  mm_ops.to_resume = mm_resume;
  mm_ops.to_wait = mm_wait;
d1608 16
a1623 16
  mm_ops.to_fetch_registers = mm_fetch_registers;
  mm_ops.to_store_registers = mm_store_registers;
  mm_ops.to_prepare_to_store = mm_prepare_to_store;
  mm_ops.to_xfer_memory = mm_xfer_inferior_memory;
  mm_ops.to_files_info = mm_files_info;
  mm_ops.to_insert_breakpoint = mm_insert_breakpoint;
  mm_ops.to_remove_breakpoint = mm_remove_breakpoint;
  mm_ops.to_terminal_init = 0;
  mm_ops.to_terminal_inferior = 0;
  mm_ops.to_terminal_ours_for_output = 0;
  mm_ops.to_terminal_ours = 0;
  mm_ops.to_terminal_info = 0;
  mm_ops.to_kill = mm_kill;
  mm_ops.to_load = mm_load;
  mm_ops.to_lookup_symbol = 0;
  mm_ops.to_create_inferior = mm_create_inferior;
d1635 1
a1635 1
  mm_ops.to_post_follow_vfork = NULL;
d1641 5
a1645 5
  mm_ops.to_mourn_inferior = mm_mourn;
  mm_ops.to_can_run = 0;
  mm_ops.to_notice_signals = 0;
  mm_ops.to_thread_alive = 0;
  mm_ops.to_stop = 0;
d1648 10
a1657 10
  mm_ops.to_stratum = process_stratum;
  mm_ops.DONT_USE = 0;
  mm_ops.to_has_all_memory = 1;
  mm_ops.to_has_memory = 1;
  mm_ops.to_has_stack = 1;
  mm_ops.to_has_registers = 1;
  mm_ops.to_has_execution = 1;
  mm_ops.to_sections = 0;
  mm_ops.to_sections_end = 0;
  mm_ops.to_magic = OPS_MAGIC;
d1661 1
a1661 1
_initialize_remote_mm ()
d1663 1
a1663 1
  init_mm_ops ();
d1668 2
a1669 2
service_HIF (msg)
     union msg_t *msg;
d1671 1
a1671 1
  return (0);			/* Emulate a failure */
@


1.1.1.3
log
@import gdb-1999-10-11 snapshot
@
text
@d1121 1
a1121 1
  /* symbol_file_add (arg_string, from_tty, text_addr, 0, 0); */
@


