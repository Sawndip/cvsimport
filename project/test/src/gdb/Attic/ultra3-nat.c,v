head	1.10;
access;
symbols
	gdb_5_1_1-2002-01-24-release:1.8
	gdb_5_1_0_1-2002-01-03-release:1.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.8
	gdb_5_1_0_1-2002-01-03-branch:1.8.0.8
	gdb_5_1-2001-11-21-release:1.8
	gdb_s390-2001-09-26-branch:1.8.0.6
	gdb_s390-2001-09-26-branchpoint:1.8
	gdb_5_1-2001-07-29-branch:1.8.0.4
	gdb_5_1-2001-07-29-branchpoint:1.8
	dberlin-typesystem-branch:1.8.0.2
	dberlin-typesystem-branchpoint:1.8
	gdb-post-ptid_t-2001-05-03:1.8
	gdb-pre-ptid_t-2001-05-03:1.7
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.10
date	2001.12.01.22.02.02;	author cagney;	state dead;
branches;
next	1.9;

1.9
date	2001.09.20.03.03.40;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.04.04.15.28;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.05.14.49.28;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.06.08.21.18;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.01.01.39.22;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.02.03.18.49;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.33;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.10.53;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.10.05.23.08.59;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Zap all but ns32k-netbsd NS32k targets and hosts.
@
text
@/* OBSOLETE /* Native-dependent code for GDB, for NYU Ultra3 running Sym1 OS. */
/* OBSOLETE    Copyright 1988, 1989, 1991, 1992, 1995, 1996, 1999, 2000, 2001 */
/* OBSOLETE    Free Software Foundation, Inc. */
/* OBSOLETE    Contributed by David Wood (wood@@nyu.edu) at New York University. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE #define DEBUG */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "frame.h" */
/* OBSOLETE #include "inferior.h" */
/* OBSOLETE #include "symtab.h" */
/* OBSOLETE #include "value.h" */
/* OBSOLETE #include "regcache.h" */
/* OBSOLETE  */
/* OBSOLETE #include <sys/types.h> */
/* OBSOLETE #include <sys/param.h> */
/* OBSOLETE #include <signal.h> */
/* OBSOLETE #include <sys/ioctl.h> */
/* OBSOLETE #include <fcntl.h> */
/* OBSOLETE  */
/* OBSOLETE #include "gdbcore.h" */
/* OBSOLETE  */
/* OBSOLETE #include <sys/file.h> */
/* OBSOLETE #include "gdb_stat.h" */
/* OBSOLETE  */
/* OBSOLETE static void fetch_core_registers (char *, unsigned, int, CORE_ADDR); */
/* OBSOLETE  */
/* OBSOLETE /* Assumes support for AMD's Binary Compatibility Standard */
/* OBSOLETE    for ptrace().  If you define ULTRA3, the ultra3 extensions to */
/* OBSOLETE    ptrace() are used allowing the reading of more than one register */
/* OBSOLETE    at a time.  */
/* OBSOLETE  */
/* OBSOLETE    This file assumes KERNEL_DEBUGGING is turned off.  This means */
/* OBSOLETE    that if the user/gdb tries to read gr64-gr95 or any of the  */
/* OBSOLETE    protected special registers we silently return -1 (see the */
/* OBSOLETE    CANNOT_STORE/FETCH_REGISTER macros).  */ */
/* OBSOLETE #define	ULTRA3 */
/* OBSOLETE  */
/* OBSOLETE #if !defined (offsetof) */
/* OBSOLETE #define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER) */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE extern int errno; */
/* OBSOLETE struct ptrace_user pt_struct; */
/* OBSOLETE  */
/* OBSOLETE /* Get all available registers from the inferior.  Registers that are */
/* OBSOLETE  * defined in REGISTER_NAMES, but not available to the user/gdb are */
/* OBSOLETE  * supplied as -1.  This may include gr64-gr95 and the protected special */
/* OBSOLETE  * purpose registers. */
/* OBSOLETE  */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE fetch_inferior_registers (int regno) */
/* OBSOLETE { */
/* OBSOLETE   register int i, j, ret_val = 0; */
/* OBSOLETE   char buf[128]; */
/* OBSOLETE  */
/* OBSOLETE   if (regno != -1) */
/* OBSOLETE     { */
/* OBSOLETE       fetch_register (regno); */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE /* Global Registers */ */
/* OBSOLETE #ifdef ULTRA3 */
/* OBSOLETE   errno = 0; */
/* OBSOLETE   ptrace (PT_READ_STRUCT, PIDGET (inferior_ptid), */
/* OBSOLETE 	  (PTRACE_ARG3_TYPE) register_addr (GR96_REGNUM, 0), */
/* OBSOLETE 	  (int) &pt_struct.pt_gr[0], 32 * 4); */
/* OBSOLETE   if (errno != 0) */
/* OBSOLETE     { */
/* OBSOLETE       perror_with_name ("reading global registers"); */
/* OBSOLETE       ret_val = -1; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     for (regno = GR96_REGNUM, j = 0; j < 32; regno++, j++) */
/* OBSOLETE       { */
/* OBSOLETE 	supply_register (regno, &pt_struct.pt_gr[j]); */
/* OBSOLETE       } */
/* OBSOLETE #else */
/* OBSOLETE   for (regno = GR96_REGNUM; !ret_val && regno < GR96_REGNUM + 32; regno++) */
/* OBSOLETE     fetch_register (regno); */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE /* Local Registers */ */
/* OBSOLETE #ifdef ULTRA3 */
/* OBSOLETE   errno = 0; */
/* OBSOLETE   ptrace (PT_READ_STRUCT, PIDGET (inferior_ptid), */
/* OBSOLETE 	  (PTRACE_ARG3_TYPE) register_addr (LR0_REGNUM, 0), */
/* OBSOLETE 	  (int) &pt_struct.pt_lr[0], 128 * 4); */
/* OBSOLETE   if (errno != 0) */
/* OBSOLETE     { */
/* OBSOLETE       perror_with_name ("reading local registers"); */
/* OBSOLETE       ret_val = -1; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     for (regno = LR0_REGNUM, j = 0; j < 128; regno++, j++) */
/* OBSOLETE       { */
/* OBSOLETE 	supply_register (regno, &pt_struct.pt_lr[j]); */
/* OBSOLETE       } */
/* OBSOLETE #else */
/* OBSOLETE   for (regno = LR0_REGNUM; !ret_val && regno < LR0_REGNUM + 128; regno++) */
/* OBSOLETE     fetch_register (regno); */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE /* Special Registers */ */
/* OBSOLETE   fetch_register (GR1_REGNUM); */
/* OBSOLETE   fetch_register (CPS_REGNUM); */
/* OBSOLETE   fetch_register (PC_REGNUM); */
/* OBSOLETE   fetch_register (NPC_REGNUM); */
/* OBSOLETE   fetch_register (PC2_REGNUM); */
/* OBSOLETE   fetch_register (IPC_REGNUM); */
/* OBSOLETE   fetch_register (IPA_REGNUM); */
/* OBSOLETE   fetch_register (IPB_REGNUM); */
/* OBSOLETE   fetch_register (Q_REGNUM); */
/* OBSOLETE   fetch_register (BP_REGNUM); */
/* OBSOLETE   fetch_register (FC_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE /* Fake any registers that are in REGISTER_NAMES, but not available to gdb */ */
/* OBSOLETE   registers_fetched (); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Store our register values back into the inferior. */
/* OBSOLETE  * If REGNO is -1, do this for all registers. */
/* OBSOLETE  * Otherwise, REGNO specifies which register (so we can save time).   */
/* OBSOLETE  * NOTE: Assumes AMD's binary compatibility standard.  */
/* OBSOLETE  */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE store_inferior_registers (int regno) */
/* OBSOLETE { */
/* OBSOLETE   register unsigned int regaddr; */
/* OBSOLETE   char buf[80]; */
/* OBSOLETE  */
/* OBSOLETE   if (regno >= 0) */
/* OBSOLETE     { */
/* OBSOLETE       if (CANNOT_STORE_REGISTER (regno)) */
/* OBSOLETE 	return; */
/* OBSOLETE       regaddr = register_addr (regno, 0); */
/* OBSOLETE       errno = 0; */
/* OBSOLETE       ptrace (PT_WRITE_U, PIDGET (inferior_ptid), */
/* OBSOLETE 	      (PTRACE_ARG3_TYPE) regaddr, read_register (regno)); */
/* OBSOLETE       if (errno != 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  sprintf (buf, "writing register %s (#%d)", REGISTER_NAME (regno), regno); */
/* OBSOLETE 	  perror_with_name (buf); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE #ifdef ULTRA3 */
/* OBSOLETE       pt_struct.pt_gr1 = read_register (GR1_REGNUM); */
/* OBSOLETE       for (regno = GR96_REGNUM; regno < GR96_REGNUM + 32; regno++) */
/* OBSOLETE 	pt_struct.pt_gr[regno] = read_register (regno); */
/* OBSOLETE       for (regno = LR0_REGNUM; regno < LR0_REGNUM + 128; regno++) */
/* OBSOLETE 	pt_struct.pt_gr[regno] = read_register (regno); */
/* OBSOLETE       errno = 0; */
/* OBSOLETE       ptrace (PT_WRITE_STRUCT, PIDGET (inferior_ptid), */
/* OBSOLETE 	      (PTRACE_ARG3_TYPE) register_addr (GR1_REGNUM, 0), */
/* OBSOLETE 	      (int) &pt_struct.pt_gr1, (1 * 32 * 128) * 4); */
/* OBSOLETE       if (errno != 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  sprintf (buf, "writing all local/global registers"); */
/* OBSOLETE 	  perror_with_name (buf); */
/* OBSOLETE 	} */
/* OBSOLETE       pt_struct.pt_psr = read_register (CPS_REGNUM); */
/* OBSOLETE       pt_struct.pt_pc0 = read_register (NPC_REGNUM); */
/* OBSOLETE       pt_struct.pt_pc1 = read_register (PC_REGNUM); */
/* OBSOLETE       pt_struct.pt_pc2 = read_register (PC2_REGNUM); */
/* OBSOLETE       pt_struct.pt_ipc = read_register (IPC_REGNUM); */
/* OBSOLETE       pt_struct.pt_ipa = read_register (IPA_REGNUM); */
/* OBSOLETE       pt_struct.pt_ipb = read_register (IPB_REGNUM); */
/* OBSOLETE       pt_struct.pt_q = read_register (Q_REGNUM); */
/* OBSOLETE       pt_struct.pt_bp = read_register (BP_REGNUM); */
/* OBSOLETE       pt_struct.pt_fc = read_register (FC_REGNUM); */
/* OBSOLETE       errno = 0; */
/* OBSOLETE       ptrace (PT_WRITE_STRUCT, PIDGET (inferior_ptid), */
/* OBSOLETE 	      (PTRACE_ARG3_TYPE) register_addr (CPS_REGNUM, 0), */
/* OBSOLETE 	      (int) &pt_struct.pt_psr, (10) * 4); */
/* OBSOLETE       if (errno != 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  sprintf (buf, "writing all special registers"); */
/* OBSOLETE 	  perror_with_name (buf); */
/* OBSOLETE 	  return; */
/* OBSOLETE 	} */
/* OBSOLETE #else */
/* OBSOLETE       store_inferior_registers (GR1_REGNUM); */
/* OBSOLETE       for (regno = GR96_REGNUM; regno < GR96_REGNUM + 32; regno++) */
/* OBSOLETE 	store_inferior_registers (regno); */
/* OBSOLETE       for (regno = LR0_REGNUM; regno < LR0_REGNUM + 128; regno++) */
/* OBSOLETE 	store_inferior_registers (regno); */
/* OBSOLETE       store_inferior_registers (CPS_REGNUM); */
/* OBSOLETE       store_inferior_registers (PC_REGNUM); */
/* OBSOLETE       store_inferior_registers (NPC_REGNUM); */
/* OBSOLETE       store_inferior_registers (PC2_REGNUM); */
/* OBSOLETE       store_inferior_registers (IPC_REGNUM); */
/* OBSOLETE       store_inferior_registers (IPA_REGNUM); */
/* OBSOLETE       store_inferior_registers (IPB_REGNUM); */
/* OBSOLETE       store_inferior_registers (Q_REGNUM); */
/* OBSOLETE       store_inferior_registers (BP_REGNUM); */
/* OBSOLETE       store_inferior_registers (FC_REGNUM); */
/* OBSOLETE #endif /* ULTRA3 */ */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /*  */
/* OBSOLETE  * Fetch an individual register (and supply it). */
/* OBSOLETE  * return 0 on success, -1 on failure. */
/* OBSOLETE  * NOTE: Assumes AMD's Binary Compatibility Standard for ptrace(). */
/* OBSOLETE  */ */
/* OBSOLETE static void */
/* OBSOLETE fetch_register (int regno) */
/* OBSOLETE { */
/* OBSOLETE   char buf[128]; */
/* OBSOLETE   int val; */
/* OBSOLETE  */
/* OBSOLETE   if (CANNOT_FETCH_REGISTER (regno)) */
/* OBSOLETE     { */
/* OBSOLETE       val = -1; */
/* OBSOLETE       supply_register (regno, &val); */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       errno = 0; */
/* OBSOLETE       val = ptrace (PT_READ_U, PIDGET (inferior_ptid), */
/* OBSOLETE 		    (PTRACE_ARG3_TYPE) register_addr (regno, 0), 0); */
/* OBSOLETE       if (errno != 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  sprintf (buf, "reading register %s (#%d)", REGISTER_NAME (regno), regno); */
/* OBSOLETE 	  perror_with_name (buf); */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  supply_register (regno, &val); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /*  */
/* OBSOLETE  * Read AMD's Binary Compatibilty Standard conforming core file. */
/* OBSOLETE  * struct ptrace_user is the first thing in the core file */
/* OBSOLETE  * */
/* OBSOLETE  * CORE_REG_SECT, CORE_REG_SIZE, WHICH, and REG_ADDR are all ignored. */
/* OBSOLETE  */ */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE fetch_core_registers (char *core_reg_sect, unsigned core_reg_size, */
/* OBSOLETE 		      int which, CORE_ADDR reg_addr) */
/* OBSOLETE { */
/* OBSOLETE   register int regno; */
/* OBSOLETE   int val; */
/* OBSOLETE   char buf[4]; */
/* OBSOLETE  */
/* OBSOLETE   for (regno = 0; regno < NUM_REGS; regno++) */
/* OBSOLETE     { */
/* OBSOLETE       if (!CANNOT_FETCH_REGISTER (regno)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  val = bfd_seek (core_bfd, (file_ptr) register_addr (regno, 0), SEEK_SET); */
/* OBSOLETE 	  if (val != 0 || (val = bfd_bread (buf, sizeof buf, core_bfd)) != sizeof buf) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      char *buffer = (char *) alloca (strlen (REGISTER_NAME (regno)) + 35); */
/* OBSOLETE 	      strcpy (buffer, "Reading core register "); */
/* OBSOLETE 	      strcat (buffer, REGISTER_NAME (regno)); */
/* OBSOLETE 	      perror_with_name (buffer); */
/* OBSOLETE 	    } */
/* OBSOLETE 	  supply_register (regno, buf); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Fake any registers that are in REGISTER_NAMES, but not available to gdb */ */
/* OBSOLETE   registers_fetched (); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /*   */
/* OBSOLETE  * Takes a register number as defined in tm.h via REGISTER_NAMES, and maps */
/* OBSOLETE  * it to an offset in a struct ptrace_user defined by AMD's BCS. */
/* OBSOLETE  * That is, it defines the mapping between gdb register numbers and items in */
/* OBSOLETE  * a struct ptrace_user. */
/* OBSOLETE  * A register protection scheme is set up here.  If a register not */
/* OBSOLETE  * available to the user is specified in 'regno', then an address that */
/* OBSOLETE  * will cause ptrace() to fail is returned. */
/* OBSOLETE  */ */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE register_addr (int regno, CORE_ADDR blockend) */
/* OBSOLETE { */
/* OBSOLETE   if ((regno >= LR0_REGNUM) && (regno < LR0_REGNUM + 128)) */
/* OBSOLETE     { */
/* OBSOLETE       return (offsetof (struct ptrace_user, pt_lr[regno - LR0_REGNUM])); */
/* OBSOLETE     } */
/* OBSOLETE   else if ((regno >= GR96_REGNUM) && (regno < GR96_REGNUM + 32)) */
/* OBSOLETE     { */
/* OBSOLETE       return (offsetof (struct ptrace_user, pt_gr[regno - GR96_REGNUM])); */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       switch (regno) */
/* OBSOLETE 	{ */
/* OBSOLETE 	case GR1_REGNUM: */
/* OBSOLETE 	  return (offsetof (struct ptrace_user, pt_gr1)); */
/* OBSOLETE 	case CPS_REGNUM: */
/* OBSOLETE 	  return (offsetof (struct ptrace_user, pt_psr)); */
/* OBSOLETE 	case NPC_REGNUM: */
/* OBSOLETE 	  return (offsetof (struct ptrace_user, pt_pc0)); */
/* OBSOLETE 	case PC_REGNUM: */
/* OBSOLETE 	  return (offsetof (struct ptrace_user, pt_pc1)); */
/* OBSOLETE 	case PC2_REGNUM: */
/* OBSOLETE 	  return (offsetof (struct ptrace_user, pt_pc2)); */
/* OBSOLETE 	case IPC_REGNUM: */
/* OBSOLETE 	  return (offsetof (struct ptrace_user, pt_ipc)); */
/* OBSOLETE 	case IPA_REGNUM: */
/* OBSOLETE 	  return (offsetof (struct ptrace_user, pt_ipa)); */
/* OBSOLETE 	case IPB_REGNUM: */
/* OBSOLETE 	  return (offsetof (struct ptrace_user, pt_ipb)); */
/* OBSOLETE 	case Q_REGNUM: */
/* OBSOLETE 	  return (offsetof (struct ptrace_user, pt_q)); */
/* OBSOLETE 	case BP_REGNUM: */
/* OBSOLETE 	  return (offsetof (struct ptrace_user, pt_bp)); */
/* OBSOLETE 	case FC_REGNUM: */
/* OBSOLETE 	  return (offsetof (struct ptrace_user, pt_fc)); */
/* OBSOLETE 	default: */
/* OBSOLETE 	  fprintf_filtered (gdb_stderr, "register_addr():Bad register %s (%d)\n", */
/* OBSOLETE 			    REGISTER_NAME (regno), regno); */
/* OBSOLETE 	  return (0xffffffff);	/* Should make ptrace() fail */ */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Register that we are able to handle ultra3 core file formats. */
/* OBSOLETE    FIXME: is this really bfd_target_unknown_flavour? */ */
/* OBSOLETE  */
/* OBSOLETE static struct core_fns ultra3_core_fns = */
/* OBSOLETE { */
/* OBSOLETE   bfd_target_unknown_flavour,		/* core_flavour */ */
/* OBSOLETE   default_check_format,			/* check_format */ */
/* OBSOLETE   default_core_sniffer,			/* core_sniffer */ */
/* OBSOLETE   fetch_core_registers,			/* core_read_registers */ */
/* OBSOLETE   NULL					/* next */ */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE _initialize_core_ultra3 (void) */
/* OBSOLETE { */
/* OBSOLETE   add_core_fns (&ultra3_core_fns); */
/* OBSOLETE } */
@


1.9
log
@	* coffread.c: Replace all occurrences of bfd_read with bfd_bread.
	* dbxread.c: Likewise.
	* dwarf2read.c: Likewise.
	* dwarfread.c: Likewise.
	* somread.c: Likewise.
	* ultra3-nat.c: Likewise.
	* xcoffread.c: Likewise.
@
text
@@


1.8
log
@Phase 1 of the ptid_t changes.
@
text
@d276 1
a276 1
/* OBSOLETE 	  if (val < 0 || (val = bfd_read (buf, sizeof buf, 1, core_bfd)) < 0) */
@


1.7
log
@Obsolete a29k-*-* host and a29k-*-sym1* and a29k-*-kern* targets.
@
text
@d83 1
a83 1
/* OBSOLETE   ptrace (PT_READ_STRUCT, inferior_pid, */
d104 1
a104 1
/* OBSOLETE   ptrace (PT_READ_STRUCT, inferior_pid, */
d157 1
a157 1
/* OBSOLETE       ptrace (PT_WRITE_U, inferior_pid, */
d174 1
a174 1
/* OBSOLETE       ptrace (PT_WRITE_STRUCT, inferior_pid, */
d193 1
a193 1
/* OBSOLETE       ptrace (PT_WRITE_STRUCT, inferior_pid, */
d241 1
a241 1
/* OBSOLETE       val = ptrace (PT_READ_U, inferior_pid, */
@


1.6
log
@Update/correct copyright notices.
@
text
@d1 363
a363 363
/* Native-dependent code for GDB, for NYU Ultra3 running Sym1 OS.
   Copyright 1988, 1989, 1991, 1992, 1995, 1996, 1999, 2000, 2001
   Free Software Foundation, Inc.
   Contributed by David Wood (wood@@nyu.edu) at New York University.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#define DEBUG
#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "symtab.h"
#include "value.h"
#include "regcache.h"

#include <sys/types.h>
#include <sys/param.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <fcntl.h>

#include "gdbcore.h"

#include <sys/file.h>
#include "gdb_stat.h"

static void fetch_core_registers (char *, unsigned, int, CORE_ADDR);

/* Assumes support for AMD's Binary Compatibility Standard
   for ptrace().  If you define ULTRA3, the ultra3 extensions to
   ptrace() are used allowing the reading of more than one register
   at a time. 

   This file assumes KERNEL_DEBUGGING is turned off.  This means
   that if the user/gdb tries to read gr64-gr95 or any of the 
   protected special registers we silently return -1 (see the
   CANNOT_STORE/FETCH_REGISTER macros).  */
#define	ULTRA3

#if !defined (offsetof)
#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
#endif

extern int errno;
struct ptrace_user pt_struct;

/* Get all available registers from the inferior.  Registers that are
 * defined in REGISTER_NAMES, but not available to the user/gdb are
 * supplied as -1.  This may include gr64-gr95 and the protected special
 * purpose registers.
 */

void
fetch_inferior_registers (int regno)
{
  register int i, j, ret_val = 0;
  char buf[128];

  if (regno != -1)
    {
      fetch_register (regno);
      return;
    }

/* Global Registers */
#ifdef ULTRA3
  errno = 0;
  ptrace (PT_READ_STRUCT, inferior_pid,
	  (PTRACE_ARG3_TYPE) register_addr (GR96_REGNUM, 0),
	  (int) &pt_struct.pt_gr[0], 32 * 4);
  if (errno != 0)
    {
      perror_with_name ("reading global registers");
      ret_val = -1;
    }
  else
    for (regno = GR96_REGNUM, j = 0; j < 32; regno++, j++)
      {
	supply_register (regno, &pt_struct.pt_gr[j]);
      }
#else
  for (regno = GR96_REGNUM; !ret_val && regno < GR96_REGNUM + 32; regno++)
    fetch_register (regno);
#endif

/* Local Registers */
#ifdef ULTRA3
  errno = 0;
  ptrace (PT_READ_STRUCT, inferior_pid,
	  (PTRACE_ARG3_TYPE) register_addr (LR0_REGNUM, 0),
	  (int) &pt_struct.pt_lr[0], 128 * 4);
  if (errno != 0)
    {
      perror_with_name ("reading local registers");
      ret_val = -1;
    }
  else
    for (regno = LR0_REGNUM, j = 0; j < 128; regno++, j++)
      {
	supply_register (regno, &pt_struct.pt_lr[j]);
      }
#else
  for (regno = LR0_REGNUM; !ret_val && regno < LR0_REGNUM + 128; regno++)
    fetch_register (regno);
#endif

/* Special Registers */
  fetch_register (GR1_REGNUM);
  fetch_register (CPS_REGNUM);
  fetch_register (PC_REGNUM);
  fetch_register (NPC_REGNUM);
  fetch_register (PC2_REGNUM);
  fetch_register (IPC_REGNUM);
  fetch_register (IPA_REGNUM);
  fetch_register (IPB_REGNUM);
  fetch_register (Q_REGNUM);
  fetch_register (BP_REGNUM);
  fetch_register (FC_REGNUM);

/* Fake any registers that are in REGISTER_NAMES, but not available to gdb */
  registers_fetched ();
}

/* Store our register values back into the inferior.
 * If REGNO is -1, do this for all registers.
 * Otherwise, REGNO specifies which register (so we can save time).  
 * NOTE: Assumes AMD's binary compatibility standard. 
 */

void
store_inferior_registers (int regno)
{
  register unsigned int regaddr;
  char buf[80];

  if (regno >= 0)
    {
      if (CANNOT_STORE_REGISTER (regno))
	return;
      regaddr = register_addr (regno, 0);
      errno = 0;
      ptrace (PT_WRITE_U, inferior_pid,
	      (PTRACE_ARG3_TYPE) regaddr, read_register (regno));
      if (errno != 0)
	{
	  sprintf (buf, "writing register %s (#%d)", REGISTER_NAME (regno), regno);
	  perror_with_name (buf);
	}
    }
  else
    {
#ifdef ULTRA3
      pt_struct.pt_gr1 = read_register (GR1_REGNUM);
      for (regno = GR96_REGNUM; regno < GR96_REGNUM + 32; regno++)
	pt_struct.pt_gr[regno] = read_register (regno);
      for (regno = LR0_REGNUM; regno < LR0_REGNUM + 128; regno++)
	pt_struct.pt_gr[regno] = read_register (regno);
      errno = 0;
      ptrace (PT_WRITE_STRUCT, inferior_pid,
	      (PTRACE_ARG3_TYPE) register_addr (GR1_REGNUM, 0),
	      (int) &pt_struct.pt_gr1, (1 * 32 * 128) * 4);
      if (errno != 0)
	{
	  sprintf (buf, "writing all local/global registers");
	  perror_with_name (buf);
	}
      pt_struct.pt_psr = read_register (CPS_REGNUM);
      pt_struct.pt_pc0 = read_register (NPC_REGNUM);
      pt_struct.pt_pc1 = read_register (PC_REGNUM);
      pt_struct.pt_pc2 = read_register (PC2_REGNUM);
      pt_struct.pt_ipc = read_register (IPC_REGNUM);
      pt_struct.pt_ipa = read_register (IPA_REGNUM);
      pt_struct.pt_ipb = read_register (IPB_REGNUM);
      pt_struct.pt_q = read_register (Q_REGNUM);
      pt_struct.pt_bp = read_register (BP_REGNUM);
      pt_struct.pt_fc = read_register (FC_REGNUM);
      errno = 0;
      ptrace (PT_WRITE_STRUCT, inferior_pid,
	      (PTRACE_ARG3_TYPE) register_addr (CPS_REGNUM, 0),
	      (int) &pt_struct.pt_psr, (10) * 4);
      if (errno != 0)
	{
	  sprintf (buf, "writing all special registers");
	  perror_with_name (buf);
	  return;
	}
#else
      store_inferior_registers (GR1_REGNUM);
      for (regno = GR96_REGNUM; regno < GR96_REGNUM + 32; regno++)
	store_inferior_registers (regno);
      for (regno = LR0_REGNUM; regno < LR0_REGNUM + 128; regno++)
	store_inferior_registers (regno);
      store_inferior_registers (CPS_REGNUM);
      store_inferior_registers (PC_REGNUM);
      store_inferior_registers (NPC_REGNUM);
      store_inferior_registers (PC2_REGNUM);
      store_inferior_registers (IPC_REGNUM);
      store_inferior_registers (IPA_REGNUM);
      store_inferior_registers (IPB_REGNUM);
      store_inferior_registers (Q_REGNUM);
      store_inferior_registers (BP_REGNUM);
      store_inferior_registers (FC_REGNUM);
#endif /* ULTRA3 */
    }
}

/* 
 * Fetch an individual register (and supply it).
 * return 0 on success, -1 on failure.
 * NOTE: Assumes AMD's Binary Compatibility Standard for ptrace().
 */
static void
fetch_register (int regno)
{
  char buf[128];
  int val;

  if (CANNOT_FETCH_REGISTER (regno))
    {
      val = -1;
      supply_register (regno, &val);
    }
  else
    {
      errno = 0;
      val = ptrace (PT_READ_U, inferior_pid,
		    (PTRACE_ARG3_TYPE) register_addr (regno, 0), 0);
      if (errno != 0)
	{
	  sprintf (buf, "reading register %s (#%d)", REGISTER_NAME (regno), regno);
	  perror_with_name (buf);
	}
      else
	{
	  supply_register (regno, &val);
	}
    }
}


/* 
 * Read AMD's Binary Compatibilty Standard conforming core file.
 * struct ptrace_user is the first thing in the core file
 *
 * CORE_REG_SECT, CORE_REG_SIZE, WHICH, and REG_ADDR are all ignored.
 */

static void
fetch_core_registers (char *core_reg_sect, unsigned core_reg_size,
		      int which, CORE_ADDR reg_addr)
{
  register int regno;
  int val;
  char buf[4];

  for (regno = 0; regno < NUM_REGS; regno++)
    {
      if (!CANNOT_FETCH_REGISTER (regno))
	{
	  val = bfd_seek (core_bfd, (file_ptr) register_addr (regno, 0), SEEK_SET);
	  if (val < 0 || (val = bfd_read (buf, sizeof buf, 1, core_bfd)) < 0)
	    {
	      char *buffer = (char *) alloca (strlen (REGISTER_NAME (regno)) + 35);
	      strcpy (buffer, "Reading core register ");
	      strcat (buffer, REGISTER_NAME (regno));
	      perror_with_name (buffer);
	    }
	  supply_register (regno, buf);
	}
    }

  /* Fake any registers that are in REGISTER_NAMES, but not available to gdb */
  registers_fetched ();
}


/*  
 * Takes a register number as defined in tm.h via REGISTER_NAMES, and maps
 * it to an offset in a struct ptrace_user defined by AMD's BCS.
 * That is, it defines the mapping between gdb register numbers and items in
 * a struct ptrace_user.
 * A register protection scheme is set up here.  If a register not
 * available to the user is specified in 'regno', then an address that
 * will cause ptrace() to fail is returned.
 */
CORE_ADDR
register_addr (int regno, CORE_ADDR blockend)
{
  if ((regno >= LR0_REGNUM) && (regno < LR0_REGNUM + 128))
    {
      return (offsetof (struct ptrace_user, pt_lr[regno - LR0_REGNUM]));
    }
  else if ((regno >= GR96_REGNUM) && (regno < GR96_REGNUM + 32))
    {
      return (offsetof (struct ptrace_user, pt_gr[regno - GR96_REGNUM]));
    }
  else
    {
      switch (regno)
	{
	case GR1_REGNUM:
	  return (offsetof (struct ptrace_user, pt_gr1));
	case CPS_REGNUM:
	  return (offsetof (struct ptrace_user, pt_psr));
	case NPC_REGNUM:
	  return (offsetof (struct ptrace_user, pt_pc0));
	case PC_REGNUM:
	  return (offsetof (struct ptrace_user, pt_pc1));
	case PC2_REGNUM:
	  return (offsetof (struct ptrace_user, pt_pc2));
	case IPC_REGNUM:
	  return (offsetof (struct ptrace_user, pt_ipc));
	case IPA_REGNUM:
	  return (offsetof (struct ptrace_user, pt_ipa));
	case IPB_REGNUM:
	  return (offsetof (struct ptrace_user, pt_ipb));
	case Q_REGNUM:
	  return (offsetof (struct ptrace_user, pt_q));
	case BP_REGNUM:
	  return (offsetof (struct ptrace_user, pt_bp));
	case FC_REGNUM:
	  return (offsetof (struct ptrace_user, pt_fc));
	default:
	  fprintf_filtered (gdb_stderr, "register_addr():Bad register %s (%d)\n",
			    REGISTER_NAME (regno), regno);
	  return (0xffffffff);	/* Should make ptrace() fail */
	}
    }
}


/* Register that we are able to handle ultra3 core file formats.
   FIXME: is this really bfd_target_unknown_flavour? */

static struct core_fns ultra3_core_fns =
{
  bfd_target_unknown_flavour,		/* core_flavour */
  default_check_format,			/* check_format */
  default_core_sniffer,			/* core_sniffer */
  fetch_core_registers,			/* core_read_registers */
  NULL					/* next */
};

void
_initialize_core_ultra3 (void)
{
  add_core_fns (&ultra3_core_fns);
}
@


1.5
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1988, 1989, 1991, 1992, 2001 Free Software Foundation,
   Inc.
@


1.4
log
@Protoization.
@
text
@d2 2
a3 1
   Copyright (C) 1988, 1989, 1991, 1992 Free Software Foundation, Inc.
d29 1
@


1.3
log
@Protoization.
@
text
@d257 2
d262 2
a263 5
fetch_core_registers (core_reg_sect, core_reg_size, which, reg_addr)
     char *core_reg_sect;	/* Unused in this version */
     unsigned core_reg_size;	/* Unused in this version */
     int which;			/* Unused in this version */
     CORE_ADDR reg_addr;	/* Unused in this version */
@


1.2
log
@PARAMS removal.
@
text
@d67 1
a67 2
fetch_inferior_registers (regno)
     int regno;
d144 1
a144 2
store_inferior_registers (regno)
     int regno;
d226 1
a226 2
fetch_register (regno)
     int regno;
d301 1
a301 3
register_addr (regno, blockend)
     int regno;
     CORE_ADDR blockend;
d359 1
a359 1
_initialize_core_ultra3 ()
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d33 1
a33 1
#include <fcntl.h>  
d40 1
a40 1
static void fetch_core_registers PARAMS ((char *, unsigned, int, CORE_ADDR));
d54 1
a54 1
# define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
d68 1
a68 1
  int regno;
d70 1
a70 1
  register int i,j,ret_val=0;
d73 5
a77 4
  if (regno != -1) {
    fetch_register (regno);
    return;
  }
d83 4
a86 3
	  (PTRACE_ARG3_TYPE) register_addr(GR96_REGNUM,0), 
	  (int)&pt_struct.pt_gr[0], 32*4);
  if (errno != 0) {
d89 6
a94 3
  } else for (regno=GR96_REGNUM, j=0 ; j<32 ; regno++, j++)  {
      supply_register (regno, &pt_struct.pt_gr[j]);
  }
d96 2
a97 2
  for (regno=GR96_REGNUM ; !ret_val && regno < GR96_REGNUM+32 ; regno++)
    fetch_register(regno);
d104 4
a107 3
	  (PTRACE_ARG3_TYPE) register_addr(LR0_REGNUM,0), 
	  (int)&pt_struct.pt_lr[0], 128*4);
  if (errno != 0) {
d110 6
a115 3
  } else for (regno=LR0_REGNUM, j=0 ; j<128 ; regno++, j++)  {
      supply_register (regno, &pt_struct.pt_lr[j]);
  }
d117 2
a118 2
  for (regno=LR0_REGNUM ; !ret_val && regno < LR0_REGNUM+128 ; regno++)
    fetch_register(regno);
d122 11
a132 11
  fetch_register(GR1_REGNUM);
  fetch_register(CPS_REGNUM);
  fetch_register(PC_REGNUM);
  fetch_register(NPC_REGNUM);
  fetch_register(PC2_REGNUM);
  fetch_register(IPC_REGNUM);
  fetch_register(IPA_REGNUM);
  fetch_register(IPB_REGNUM);
  fetch_register(Q_REGNUM);
  fetch_register(BP_REGNUM);
  fetch_register(FC_REGNUM);
d134 2
a135 2
/* Fake any registers that are in REGISTER_NAMES, but not available to gdb */ 
  registers_fetched();
d153 1
a153 1
      if (CANNOT_STORE_REGISTER(regno)) 
d158 1
a158 1
	      (PTRACE_ARG3_TYPE) regaddr, read_register(regno));
d168 5
a172 5
      pt_struct.pt_gr1 = read_register(GR1_REGNUM);
      for (regno = GR96_REGNUM; regno < GR96_REGNUM+32; regno++)
	pt_struct.pt_gr[regno] = read_register(regno);
      for (regno = LR0_REGNUM; regno < LR0_REGNUM+128; regno++)
	pt_struct.pt_gr[regno] = read_register(regno);
d175 2
a176 2
	      (PTRACE_ARG3_TYPE) register_addr(GR1_REGNUM,0), 
	      (int)&pt_struct.pt_gr1,(1*32*128)*4);
d179 2
a180 2
	   sprintf (buf, "writing all local/global registers");
	   perror_with_name (buf);
d182 10
a191 10
      pt_struct.pt_psr = read_register(CPS_REGNUM);
      pt_struct.pt_pc0 = read_register(NPC_REGNUM);
      pt_struct.pt_pc1 = read_register(PC_REGNUM);
      pt_struct.pt_pc2 = read_register(PC2_REGNUM);
      pt_struct.pt_ipc = read_register(IPC_REGNUM);
      pt_struct.pt_ipa = read_register(IPA_REGNUM);
      pt_struct.pt_ipb = read_register(IPB_REGNUM);
      pt_struct.pt_q   = read_register(Q_REGNUM);
      pt_struct.pt_bp  = read_register(BP_REGNUM);
      pt_struct.pt_fc  = read_register(FC_REGNUM);
d194 2
a195 2
	      (PTRACE_ARG3_TYPE) register_addr(CPS_REGNUM,0), 
	      (int)&pt_struct.pt_psr,(10)*4);
d198 3
a200 3
	   sprintf (buf, "writing all special registers");
	   perror_with_name (buf);
	   return;
d203 16
a218 16
      store_inferior_registers(GR1_REGNUM);
      for (regno=GR96_REGNUM ; regno<GR96_REGNUM+32 ; regno++)
	store_inferior_registers(regno);
      for (regno=LR0_REGNUM ; regno<LR0_REGNUM+128 ; regno++)
	store_inferior_registers(regno);
      store_inferior_registers(CPS_REGNUM);
      store_inferior_registers(PC_REGNUM);
      store_inferior_registers(NPC_REGNUM);
      store_inferior_registers(PC2_REGNUM);
      store_inferior_registers(IPC_REGNUM);
      store_inferior_registers(IPA_REGNUM);
      store_inferior_registers(IPB_REGNUM);
      store_inferior_registers(Q_REGNUM);
      store_inferior_registers(BP_REGNUM);
      store_inferior_registers(FC_REGNUM);
#endif	/* ULTRA3 */
d232 1
a232 1
  int	val;
d234 3
a236 11
  if (CANNOT_FETCH_REGISTER(regno)) {
    val = -1;
    supply_register (regno, &val);
  } else {
    errno = 0;
    val = ptrace (PT_READ_U, inferior_pid,
		  (PTRACE_ARG3_TYPE) register_addr(regno,0), 0);
    if (errno != 0) {
      sprintf(buf,"reading register %s (#%d)",REGISTER_NAME (regno), regno);
      perror_with_name (buf);
    } else {
d239 15
a253 1
  }
d270 2
a271 2
  int	val;
  char	buf[4];
d273 14
a286 10
  for (regno = 0 ; regno < NUM_REGS; regno++) {
    if (!CANNOT_FETCH_REGISTER(regno)) {
      val = bfd_seek (core_bfd, (file_ptr) register_addr (regno, 0), SEEK_SET);
      if (val < 0 || (val = bfd_read (buf, sizeof buf, 1, core_bfd)) < 0) {
        char * buffer = (char *) alloca (strlen (REGISTER_NAME (regno)) + 35);
        strcpy (buffer, "Reading core register ");
        strcat (buffer, REGISTER_NAME (regno));
        perror_with_name (buffer);
      }
      supply_register (regno, buf);
a287 1
  }
d289 2
a290 2
  /* Fake any registers that are in REGISTER_NAMES, but not available to gdb */ 
  registers_fetched();
d304 3
a306 3
register_addr (regno,blockend)
     int	regno;
     CORE_ADDR	blockend;
d308 34
a341 17
  if ((regno >= LR0_REGNUM) && (regno < LR0_REGNUM + 128)) {
    return(offsetof(struct ptrace_user,pt_lr[regno-LR0_REGNUM]));
  } else if ((regno >= GR96_REGNUM) && (regno < GR96_REGNUM + 32)) {
    return(offsetof(struct ptrace_user,pt_gr[regno-GR96_REGNUM]));
  } else {
    switch (regno) {
	case GR1_REGNUM: return(offsetof(struct ptrace_user,pt_gr1));
	case CPS_REGNUM: return(offsetof(struct ptrace_user,pt_psr));
	case NPC_REGNUM: return(offsetof(struct ptrace_user,pt_pc0));
	case PC_REGNUM:  return(offsetof(struct ptrace_user,pt_pc1));
	case PC2_REGNUM: return(offsetof(struct ptrace_user,pt_pc2));
	case IPC_REGNUM: return(offsetof(struct ptrace_user,pt_ipc));
	case IPA_REGNUM: return(offsetof(struct ptrace_user,pt_ipa));
	case IPB_REGNUM: return(offsetof(struct ptrace_user,pt_ipb));
	case Q_REGNUM:   return(offsetof(struct ptrace_user,pt_q));
	case BP_REGNUM:  return(offsetof(struct ptrace_user,pt_bp));
	case FC_REGNUM:  return(offsetof(struct ptrace_user,pt_fc));
d343 4
a346 3
	     fprintf_filtered(gdb_stderr,"register_addr():Bad register %s (%d)\n", 
			      REGISTER_NAME (regno), regno);
	     return(0xffffffff);	/* Should make ptrace() fail */
a347 1
  }
d349 1
a350 1

d356 5
a360 3
  bfd_target_unknown_flavour,
  fetch_core_registers,
  NULL
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d32 1
a32 1
#include <fcntl.h>
d53 1
a53 1
#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
d67 1
a67 1
     int regno;
d69 1
a69 1
  register int i, j, ret_val = 0;
d72 4
a75 5
  if (regno != -1)
    {
      fetch_register (regno);
      return;
    }
d81 3
a83 4
	  (PTRACE_ARG3_TYPE) register_addr (GR96_REGNUM, 0),
	  (int) &pt_struct.pt_gr[0], 32 * 4);
  if (errno != 0)
    {
d86 3
a88 6
    }
  else
    for (regno = GR96_REGNUM, j = 0; j < 32; regno++, j++)
      {
	supply_register (regno, &pt_struct.pt_gr[j]);
      }
d90 2
a91 2
  for (regno = GR96_REGNUM; !ret_val && regno < GR96_REGNUM + 32; regno++)
    fetch_register (regno);
d98 3
a100 4
	  (PTRACE_ARG3_TYPE) register_addr (LR0_REGNUM, 0),
	  (int) &pt_struct.pt_lr[0], 128 * 4);
  if (errno != 0)
    {
d103 3
a105 6
    }
  else
    for (regno = LR0_REGNUM, j = 0; j < 128; regno++, j++)
      {
	supply_register (regno, &pt_struct.pt_lr[j]);
      }
d107 2
a108 2
  for (regno = LR0_REGNUM; !ret_val && regno < LR0_REGNUM + 128; regno++)
    fetch_register (regno);
d112 11
a122 11
  fetch_register (GR1_REGNUM);
  fetch_register (CPS_REGNUM);
  fetch_register (PC_REGNUM);
  fetch_register (NPC_REGNUM);
  fetch_register (PC2_REGNUM);
  fetch_register (IPC_REGNUM);
  fetch_register (IPA_REGNUM);
  fetch_register (IPB_REGNUM);
  fetch_register (Q_REGNUM);
  fetch_register (BP_REGNUM);
  fetch_register (FC_REGNUM);
d124 2
a125 2
/* Fake any registers that are in REGISTER_NAMES, but not available to gdb */
  registers_fetched ();
d143 1
a143 1
      if (CANNOT_STORE_REGISTER (regno))
d148 1
a148 1
	      (PTRACE_ARG3_TYPE) regaddr, read_register (regno));
d158 5
a162 5
      pt_struct.pt_gr1 = read_register (GR1_REGNUM);
      for (regno = GR96_REGNUM; regno < GR96_REGNUM + 32; regno++)
	pt_struct.pt_gr[regno] = read_register (regno);
      for (regno = LR0_REGNUM; regno < LR0_REGNUM + 128; regno++)
	pt_struct.pt_gr[regno] = read_register (regno);
d165 2
a166 2
	      (PTRACE_ARG3_TYPE) register_addr (GR1_REGNUM, 0),
	      (int) &pt_struct.pt_gr1, (1 * 32 * 128) * 4);
d169 2
a170 2
	  sprintf (buf, "writing all local/global registers");
	  perror_with_name (buf);
d172 10
a181 10
      pt_struct.pt_psr = read_register (CPS_REGNUM);
      pt_struct.pt_pc0 = read_register (NPC_REGNUM);
      pt_struct.pt_pc1 = read_register (PC_REGNUM);
      pt_struct.pt_pc2 = read_register (PC2_REGNUM);
      pt_struct.pt_ipc = read_register (IPC_REGNUM);
      pt_struct.pt_ipa = read_register (IPA_REGNUM);
      pt_struct.pt_ipb = read_register (IPB_REGNUM);
      pt_struct.pt_q = read_register (Q_REGNUM);
      pt_struct.pt_bp = read_register (BP_REGNUM);
      pt_struct.pt_fc = read_register (FC_REGNUM);
d184 2
a185 2
	      (PTRACE_ARG3_TYPE) register_addr (CPS_REGNUM, 0),
	      (int) &pt_struct.pt_psr, (10) * 4);
d188 3
a190 3
	  sprintf (buf, "writing all special registers");
	  perror_with_name (buf);
	  return;
d193 16
a208 16
      store_inferior_registers (GR1_REGNUM);
      for (regno = GR96_REGNUM; regno < GR96_REGNUM + 32; regno++)
	store_inferior_registers (regno);
      for (regno = LR0_REGNUM; regno < LR0_REGNUM + 128; regno++)
	store_inferior_registers (regno);
      store_inferior_registers (CPS_REGNUM);
      store_inferior_registers (PC_REGNUM);
      store_inferior_registers (NPC_REGNUM);
      store_inferior_registers (PC2_REGNUM);
      store_inferior_registers (IPC_REGNUM);
      store_inferior_registers (IPA_REGNUM);
      store_inferior_registers (IPB_REGNUM);
      store_inferior_registers (Q_REGNUM);
      store_inferior_registers (BP_REGNUM);
      store_inferior_registers (FC_REGNUM);
#endif /* ULTRA3 */
d222 1
a222 1
  int val;
d224 11
a234 3
  if (CANNOT_FETCH_REGISTER (regno))
    {
      val = -1;
d237 1
a237 15
  else
    {
      errno = 0;
      val = ptrace (PT_READ_U, inferior_pid,
		    (PTRACE_ARG3_TYPE) register_addr (regno, 0), 0);
      if (errno != 0)
	{
	  sprintf (buf, "reading register %s (#%d)", REGISTER_NAME (regno), regno);
	  perror_with_name (buf);
	}
      else
	{
	  supply_register (regno, &val);
	}
    }
d254 2
a255 2
  int val;
  char buf[4];
d257 10
a266 14
  for (regno = 0; regno < NUM_REGS; regno++)
    {
      if (!CANNOT_FETCH_REGISTER (regno))
	{
	  val = bfd_seek (core_bfd, (file_ptr) register_addr (regno, 0), SEEK_SET);
	  if (val < 0 || (val = bfd_read (buf, sizeof buf, 1, core_bfd)) < 0)
	    {
	      char *buffer = (char *) alloca (strlen (REGISTER_NAME (regno)) + 35);
	      strcpy (buffer, "Reading core register ");
	      strcat (buffer, REGISTER_NAME (regno));
	      perror_with_name (buffer);
	    }
	  supply_register (regno, buf);
	}
d268 1
d270 2
a271 2
  /* Fake any registers that are in REGISTER_NAMES, but not available to gdb */
  registers_fetched ();
d285 3
a287 3
register_addr (regno, blockend)
     int regno;
     CORE_ADDR blockend;
d289 17
a305 34
  if ((regno >= LR0_REGNUM) && (regno < LR0_REGNUM + 128))
    {
      return (offsetof (struct ptrace_user, pt_lr[regno - LR0_REGNUM]));
    }
  else if ((regno >= GR96_REGNUM) && (regno < GR96_REGNUM + 32))
    {
      return (offsetof (struct ptrace_user, pt_gr[regno - GR96_REGNUM]));
    }
  else
    {
      switch (regno)
	{
	case GR1_REGNUM:
	  return (offsetof (struct ptrace_user, pt_gr1));
	case CPS_REGNUM:
	  return (offsetof (struct ptrace_user, pt_psr));
	case NPC_REGNUM:
	  return (offsetof (struct ptrace_user, pt_pc0));
	case PC_REGNUM:
	  return (offsetof (struct ptrace_user, pt_pc1));
	case PC2_REGNUM:
	  return (offsetof (struct ptrace_user, pt_pc2));
	case IPC_REGNUM:
	  return (offsetof (struct ptrace_user, pt_ipc));
	case IPA_REGNUM:
	  return (offsetof (struct ptrace_user, pt_ipa));
	case IPB_REGNUM:
	  return (offsetof (struct ptrace_user, pt_ipb));
	case Q_REGNUM:
	  return (offsetof (struct ptrace_user, pt_q));
	case BP_REGNUM:
	  return (offsetof (struct ptrace_user, pt_bp));
	case FC_REGNUM:
	  return (offsetof (struct ptrace_user, pt_fc));
d307 3
a309 4
	  fprintf_filtered (gdb_stderr, "register_addr():Bad register %s (%d)\n",
			    REGISTER_NAME (regno), regno);
	  return (0xffffffff);	/* Should make ptrace() fail */
	}
d311 1
d313 1
a314 1

@


1.1.1.3
log
@import gdb-1999-10-04 snapshot
@
text
@d356 3
a358 5
  bfd_target_unknown_flavour,		/* core_flavour */
  default_check_format,			/* check_format */
  default_core_sniffer,			/* core_sniffer */
  fetch_core_registers,			/* core_read_registers */
  NULL					/* next */
@


