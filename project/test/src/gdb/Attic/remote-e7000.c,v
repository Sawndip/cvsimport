head	1.61;
access;
symbols
	drow-reverse-20070409-branch:1.60.0.2
	drow-reverse-20070409-branchpoint:1.60
	insight_6_6-20070208-release:1.58
	gdb_6_6-2006-12-18-release:1.58
	gdb_6_6-branch:1.58.0.10
	gdb_6_6-2006-11-15-branchpoint:1.58
	insight_6_5-20061003-release:1.58
	gdb-csl-symbian-6_4_50_20060226-12:1.57.8.1
	gdb-csl-sourcerygxx-3_4_4-25:1.55.2.1
	nickrob-async-20060828-mergepoint:1.58
	gdb-csl-symbian-6_4_50_20060226-11:1.57.8.1
	gdb-csl-sourcerygxx-4_1-17:1.57
	gdb-csl-20060226-branch-local-2:1.57
	gdb-csl-sourcerygxx-4_1-14:1.57
	gdb-csl-sourcerygxx-4_1-13:1.57
	gdb-csl-sourcerygxx-4_1-12:1.57
	gdb-csl-sourcerygxx-3_4_4-21:1.57
	gdb_6_5-20060621-release:1.58
	gdb-csl-sourcerygxx-4_1-9:1.57
	gdb-csl-sourcerygxx-4_1-8:1.57
	gdb-csl-sourcerygxx-4_1-7:1.57
	gdb-csl-arm-2006q1-6:1.57
	gdb-csl-sourcerygxx-4_1-6:1.57
	gdb-csl-symbian-6_4_50_20060226-10:1.57.8.1
	gdb-csl-symbian-6_4_50_20060226-9:1.57.8.1
	gdb-csl-symbian-6_4_50_20060226-8:1.57.8.1
	gdb-csl-coldfire-4_1-11:1.57
	gdb-csl-sourcerygxx-3_4_4-19:1.57
	gdb-csl-coldfire-4_1-10:1.57
	gdb_6_5-branch:1.58.0.8
	gdb_6_5-2006-05-14-branchpoint:1.58
	gdb-csl-sourcerygxx-4_1-5:1.57
	nickrob-async-20060513-branch:1.58.0.6
	nickrob-async-20060513-branchpoint:1.58
	gdb-csl-sourcerygxx-4_1-4:1.57
	msnyder-reverse-20060502-branch:1.58.0.4
	msnyder-reverse-20060502-branchpoint:1.58
	gdb-csl-morpho-4_1-4:1.57
	gdb-csl-sourcerygxx-3_4_4-17:1.57
	readline_5_1-import-branch:1.58.0.2
	readline_5_1-import-branchpoint:1.58
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.57
	gdb-csl-symbian-20060226-branch:1.57.0.8
	gdb-csl-symbian-20060226-branchpoint:1.57
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.57
	msnyder-reverse-20060331-branch:1.57.0.6
	msnyder-reverse-20060331-branchpoint:1.57
	gdb-csl-available-20060303-branch:1.57.0.4
	gdb-csl-available-20060303-branchpoint:1.57
	gdb-csl-20060226-branch:1.57.0.2
	gdb-csl-20060226-branchpoint:1.57
	gdb_6_4-20051202-release:1.54
	msnyder-fork-checkpoint-branch:1.55.0.4
	msnyder-fork-checkpoint-branchpoint:1.55
	gdb-csl-gxxpro-6_3-branch:1.55.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.55
	gdb_6_4-branch:1.54.0.6
	gdb_6_4-2005-11-01-branchpoint:1.54
	gdb-csl-arm-20051020-branch:1.54.0.4
	gdb-csl-arm-20051020-branchpoint:1.54
	msnyder-tracepoint-checkpoint-branch:1.54.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.54
	gdb-csl-arm-20050325-2005-q1b:1.53
	gdb-csl-arm-20050325-2005-q1a:1.53
	csl-arm-20050325-branch:1.53.0.2
	csl-arm-20050325-branchpoint:1.53
	gdb-post-i18n-errorwarning-20050211:1.49
	gdb-pre-i18n-errorwarning-20050211:1.48
	gdb_6_3-20041109-release:1.46
	gdb_6_3-branch:1.46.0.2
	gdb_6_3-20041019-branchpoint:1.46
	drow_intercu-merge-20040921:1.45
	drow_intercu-merge-20040915:1.45
	jimb-gdb_6_2-e500-branch:1.42.0.6
	jimb-gdb_6_2-e500-branchpoint:1.42
	gdb_6_2-20040730-release:1.42
	gdb_6_2-branch:1.42.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.42
	gdb_6_1_1-20040616-release:1.39
	gdb_6_1-2004-04-05-release:1.39
	drow_intercu-merge-20040402:1.39
	drow_intercu-merge-20040327:1.39
	ezannoni_pie-20040323-branch:1.39.0.12
	ezannoni_pie-20040323-branchpoint:1.39
	cagney_tramp-20040321-mergepoint:1.39
	cagney_tramp-20040309-branch:1.39.0.10
	cagney_tramp-20040309-branchpoint:1.39
	gdb_6_1-branch:1.39.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.39
	drow_intercu-20040221-branch:1.39.0.6
	drow_intercu-20040221-branchpoint:1.39
	cagney_bfdfile-20040213-branch:1.39.0.4
	cagney_bfdfile-20040213-branchpoint:1.39
	drow-cplus-merge-20040208:1.39
	carlton_dictionary-20040126-merge:1.39
	cagney_bigcore-20040122-branch:1.39.0.2
	cagney_bigcore-20040122-branchpoint:1.39
	drow-cplus-merge-20040113:1.39
	drow-cplus-merge-20031224:1.39
	drow-cplus-merge-20031220:1.39
	carlton_dictionary-20031215-merge:1.39
	drow-cplus-merge-20031214:1.39
	carlton-dictionary-20031111-merge:1.38
	gdb_6_0-2003-10-04-release:1.36
	kettenis_sparc-20030918-branch:1.36.0.10
	kettenis_sparc-20030918-branchpoint:1.36
	carlton_dictionary-20030917-merge:1.36
	ezannoni_pie-20030916-branchpoint:1.36
	ezannoni_pie-20030916-branch:1.36.0.8
	cagney_x86i386-20030821-branch:1.36.0.6
	cagney_x86i386-20030821-branchpoint:1.36
	carlton_dictionary-20030805-merge:1.36
	carlton_dictionary-20030627-merge:1.36
	gdb_6_0-branch:1.36.0.4
	gdb_6_0-2003-06-23-branchpoint:1.36
	jimb-ppc64-linux-20030613-branch:1.36.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.36
	cagney_convert-20030606-branch:1.35.0.10
	cagney_convert-20030606-branchpoint:1.35
	cagney_writestrings-20030508-branch:1.35.0.8
	cagney_writestrings-20030508-branchpoint:1.35
	jimb-ppc64-linux-20030528-branch:1.35.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.35
	carlton_dictionary-20030523-merge:1.35
	cagney_fileio-20030521-branch:1.35.0.4
	cagney_fileio-20030521-branchpoint:1.35
	kettenis_i386newframe-20030517-mergepoint:1.35
	jimb-ppc64-linux-20030509-branch:1.35.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.35
	kettenis_i386newframe-20030504-mergepoint:1.34
	carlton_dictionary-20030430-merge:1.34
	kettenis_i386newframe-20030419-branch:1.33.0.16
	kettenis_i386newframe-20030419-branchpoint:1.33
	carlton_dictionary-20030416-merge:1.33
	cagney_frameaddr-20030409-mergepoint:1.33
	kettenis_i386newframe-20030406-branch:1.33.0.14
	kettenis_i386newframe-20030406-branchpoint:1.33
	cagney_frameaddr-20030403-branchpoint:1.33
	cagney_frameaddr-20030403-branch:1.33.0.12
	cagney_framebase-20030330-mergepoint:1.33
	cagney_framebase-20030326-branch:1.33.0.10
	cagney_framebase-20030326-branchpoint:1.33
	cagney_lazyid-20030317-branch:1.33.0.8
	cagney_lazyid-20030317-branchpoint:1.33
	kettenis-i386newframe-20030316-mergepoint:1.33
	offbyone-20030313-branch:1.33.0.6
	offbyone-20030313-branchpoint:1.33
	kettenis-i386newframe-20030308-branch:1.33.0.4
	kettenis-i386newframe-20030308-branchpoint:1.33
	carlton_dictionary-20030305-merge:1.33
	cagney_offbyone-20030303-branch:1.33.0.2
	cagney_offbyone-20030303-branchpoint:1.33
	carlton_dictionary-20030207-merge:1.33
	interps-20030203-mergepoint:1.32
	interps-20030202-branch:1.32.0.2
	interps-20030202-branchpoint:1.32
	cagney-unwind-20030108-branch:1.31.0.2
	cagney-unwind-20030108-branchpoint:1.31
	carlton_dictionary-20021223-merge:1.31
	gdb_5_3-2002-12-12-release:1.28
	carlton_dictionary-20021115-merge:1.29
	kseitz_interps-20021105-merge:1.28
	kseitz_interps-20021103-merge:1.28
	drow-cplus-merge-20021020:1.28
	drow-cplus-merge-20021025:1.28
	carlton_dictionary-20021025-merge:1.28
	carlton_dictionary-20021011-merge:1.28
	drow-cplus-branch:1.28.0.16
	drow-cplus-branchpoint:1.28
	kseitz_interps-20020930-merge:1.28
	carlton_dictionary-20020927-merge:1.28
	carlton_dictionary-branch:1.28.0.14
	carlton_dictionary-20020920-branchpoint:1.28
	gdb_5_3-branch:1.28.0.12
	gdb_5_3-2002-09-04-branchpoint:1.28
	kseitz_interps-20020829-merge:1.28
	cagney_sysregs-20020825-branch:1.28.0.10
	cagney_sysregs-20020825-branchpoint:1.28
	readline_4_3-import-branch:1.28.0.8
	readline_4_3-import-branchpoint:1.28
	gdb_5_2_1-2002-07-23-release:1.26.2.1
	kseitz_interps-20020528-branch:1.28.0.6
	kseitz_interps-20020528-branchpoint:1.28
	cagney_regbuf-20020515-branch:1.28.0.4
	cagney_regbuf-20020515-branchpoint:1.28
	jimb-macro-020506-branch:1.28.0.2
	jimb-macro-020506-branchpoint:1.28
	gdb_5_2-2002-04-29-release:1.26.2.1
	gdb_5_2-branch:1.26.0.2
	gdb_5_2-2002-03-03-branchpoint:1.26
	gdb_5_1_1-2002-01-24-release:1.25
	gdb_5_1_0_1-2002-01-03-release:1.25
	cygnus_cvs_20020108_pre:1.25
	gdb_5_1_0_1-2002-01-03-branchpoint:1.25
	gdb_5_1_0_1-2002-01-03-branch:1.25.0.6
	gdb_5_1-2001-11-21-release:1.25
	gdb_s390-2001-09-26-branch:1.25.0.4
	gdb_s390-2001-09-26-branchpoint:1.25
	gdb_5_1-2001-07-29-branch:1.25.0.2
	gdb_5_1-2001-07-29-branchpoint:1.25
	dberlin-typesystem-branch:1.22.0.2
	dberlin-typesystem-branchpoint:1.22
	gdb-post-ptid_t-2001-05-03:1.20
	gdb-pre-ptid_t-2001-05-03:1.19
	insight-precleanup-2001-01-01:1.11
	gdb-post-protoization-2000-07-29:1.6
	gdb-pre-protoization-2000-07-29:1.5
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb-post-params-removal-2000-06-04:1.4
	gdb-pre-params-removal-2000-06-04:1.4
	gdb-post-params-removal-2000-05-28:1.4
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.61
date	2007.04.13.14.25.11;	author drow;	state dead;
branches;
next	1.60;

1.60
date	2007.02.28.17.35.01;	author drow;	state Exp;
branches;
next	1.59;

1.59
date	2007.01.09.17.58.56;	author drow;	state Exp;
branches;
next	1.58;

1.58
date	2006.04.18.19.20.06;	author drow;	state Exp;
branches;
next	1.57;

1.57
date	2006.01.24.22.09.28;	author drow;	state Exp;
branches
	1.57.8.1;
next	1.56;

1.56
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.55;

1.55
date	2005.11.02.15.22.24;	author ams;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2005.05.01.19.58.54;	author cagney;	state Exp;
branches
	1.54.4.1;
next	1.53;

1.53
date	2005.02.21.06.21.08;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2005.02.16.03.21.03;	author ysato;	state Exp;
branches;
next	1.51;

1.51
date	2005.02.15.15.49.15;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2005.02.11.18.13.52;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2005.02.11.04.06.02;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2005.01.12.18.31.32;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2004.10.29.20.23.10;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2004.10.08.20.29.54;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2004.08.03.00.57.26;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2004.07.26.14.53.04;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2004.07.22.01.31.49;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.15.01.04.19;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.25.14.58.30;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.28.16.36.25;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.11.06.21.12;	author drd;	state Exp;
branches
	1.39.6.1;
next	1.38;

1.38
date	2003.10.10.07.13.10;	author ksakamot;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.02.20.28.30;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.11.13.16.28;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2003.05.08.22.33.14;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2003.04.29.01.49.47;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2003.02.06.17.58.01;	author fnf;	state Exp;
branches
	1.33.16.1;
next	1.32;

1.32
date	2003.02.02.05.46.14;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.29.19.40.30;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.29.19.15.15;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.12.21.43.55;	author drow;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.05.01.15.13;	author cagney;	state Exp;
branches
	1.28.14.1
	1.28.16.1;
next	1.27;

1.27
date	2002.04.07.23.32.40;	author ezannoni;	state Exp;
branches;
next	1.26;

1.26
date	2002.01.19.03.32.37;	author cagney;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2001.07.15.20.34.13;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2001.07.13.20.03.52;	author ezannoni;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.11.17.52.32;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.10.16.25.51;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.12.21.05.59;	author fnasser;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.04.04.15.26;	author kevinb;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.14.19.23.02;	author jtc;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.05.02.02.13;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.06.08.21.12;	author kevinb;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.02.23.04.14;	author jtc;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.02.19.14.32;	author jtc;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.23.22.48.55;	author jtc;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.02.11.37.15;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.30.21.50.57;	author jtc;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.03.22.42.32;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.01.00.12.10;	author jtc;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.31.16.25.36;	author ezannoni;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.19.14.11.41;	author ezannoni;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.16.02.43.39;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.46;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.02;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.08.58;	author jsm;	state Exp;
branches;
next	;

1.26.2.1
date	2002.04.15.01.50.45;	author ezannoni;	state Exp;
branches;
next	;

1.28.14.1
date	2002.11.15.19.18.53;	author carlton;	state Exp;
branches;
next	1.28.14.2;

1.28.14.2
date	2002.12.23.19.38.39;	author carlton;	state Exp;
branches;
next	1.28.14.3;

1.28.14.3
date	2003.02.07.19.17.51;	author carlton;	state Exp;
branches;
next	1.28.14.4;

1.28.14.4
date	2003.05.01.00.46.52;	author carlton;	state Exp;
branches;
next	1.28.14.5;

1.28.14.5
date	2003.05.23.18.40.43;	author carlton;	state Exp;
branches;
next	1.28.14.6;

1.28.14.6
date	2003.06.27.21.50.07;	author carlton;	state Exp;
branches;
next	1.28.14.7;

1.28.14.7
date	2003.11.11.23.50.52;	author carlton;	state Exp;
branches;
next	1.28.14.8;

1.28.14.8
date	2003.12.16.00.00.46;	author carlton;	state Exp;
branches;
next	;

1.28.16.1
date	2003.12.14.20.27.28;	author drow;	state Exp;
branches;
next	;

1.33.16.1
date	2003.05.04.11.37.45;	author kettenis;	state Exp;
branches;
next	1.33.16.2;

1.33.16.2
date	2003.05.18.09.44.19;	author kettenis;	state Exp;
branches;
next	;

1.39.6.1
date	2004.09.16.17.01.17;	author drow;	state Exp;
branches;
next	;

1.54.4.1
date	2006.01.26.18.05.55;	author drow;	state Exp;
branches;
next	;

1.55.2.1
date	2006.01.26.18.10.22;	author drow;	state Exp;
branches;
next	;

1.57.8.1
date	2006.04.11.21.58.24;	author drow;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Delete files for last commit.
@
text
@/* Remote debugging interface for Renesas E7000 ICE, for GDB

   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2006, 2007 Free Software Foundation, Inc.

   Contributed by Cygnus Support. 

   Written by Steve Chamberlain for Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

/* The E7000 is an in-circuit emulator for the Renesas H8/300-H and
   Renesas-SH processor.  It has serial port and a lan port.  

   The monitor command set makes it difficult to load large ammounts of
   data over the lan without using ftp - so try not to issue load
   commands when communicating over ethernet; use the ftpload command.

   The monitor pauses for a second when dumping srecords to the serial
   line too, so we use a slower per byte mechanism but without the
   startup overhead.  Even so, it's pretty slow... */

#include "defs.h"
#include "gdbcore.h"
#include "gdbarch.h"
#include "inferior.h"
#include "target.h"
#include "value.h"
#include "command.h"
#include "gdb_string.h"
#include "exceptions.h"
#include "gdbcmd.h"
#include <sys/types.h>
#include "serial.h"
#include "remote-utils.h"
#include "symfile.h"
#include "regcache.h"
#include <time.h>
#include <ctype.h>


#if 1
#define HARD_BREAKPOINTS	/* Now handled by set option. */
#define BC_BREAKPOINTS use_hard_breakpoints
#endif

#define CTRLC 0x03
#define ENQ  0x05
#define ACK  0x06
#define CTRLZ 0x1a

/* This file is used by 2 different targets, sh-elf and h8300. The
   h8300 is not multiarched and doesn't use the registers defined in
   tm-sh.h. To avoid using a macro GDB_TARGET_IS_SH, we do runtime check
   of the target, which requires that these namse below are always
   defined also in the h8300 case. */

#if !defined (PR_REGNUM)
#define PR_REGNUM 	-1
#endif
#if !defined (GBR_REGNUM)
#define GBR_REGNUM 	-1
#endif
#if !defined (VBR_REGNUM)
#define VBR_REGNUM 	-1
#endif
#if !defined (MACH_REGNUM)
#define MACH_REGNUM 	-1
#endif
#if !defined (MACL_REGNUM)
#define MACL_REGNUM 	-1
#endif
#if !defined (SR_REGNUM)
#define SR_REGNUM 	-1
#endif

extern void report_transfer_performance (unsigned long, time_t, time_t);

extern char *sh_processor_type;

/* Local function declarations.  */

static void e7000_close (int);

static void e7000_fetch_register (int);

static void e7000_store_register (int);

static void e7000_command (char *, int);

static void e7000_login_command (char *, int);

static void e7000_ftp_command (char *, int);

static void e7000_drain_command (char *, int);

static void expect (char *);

static void expect_full_prompt (void);

static void expect_prompt (void);

static int e7000_parse_device (char *args, char *dev_name, int baudrate);
/* Variables. */

static struct serial *e7000_desc;

/* Allow user to chose between using hardware breakpoints or memory. */
static int use_hard_breakpoints = 0;	/* use sw breakpoints by default */

/* Nonzero if using the tcp serial driver.  */

static int using_tcp;		/* direct tcp connection to target */
static int using_tcp_remote;	/* indirect connection to target 
				   via tcp to controller */

/* Nonzero if using the pc isa card.  */

static int using_pc;

extern struct target_ops e7000_ops;	/* Forward declaration */

char *ENQSTRING = "\005";

/* Nonzero if some routine (as opposed to the user) wants echoing.
   FIXME: Do this reentrantly with an extra parameter.  */

static int echo;

static int ctrl_c;

static int timeout = 20;

/* Send data to e7000debug.  */

static void
puts_e7000debug (char *buf)
{
  if (!e7000_desc)
    error (_("Use \"target e7000 ...\" first."));

  if (remote_debug)
    printf_unfiltered ("Sending %s\n", buf);

  if (serial_write (e7000_desc, buf, strlen (buf)))
    fprintf_unfiltered (gdb_stderr, "serial_write failed: %s\n", safe_strerror (errno));

  /* And expect to see it echoed, unless using the pc interface */
#if 0
  if (!using_pc)
#endif
    expect (buf);
}

static void
putchar_e7000 (int x)
{
  char b[1];

  b[0] = x;
  serial_write (e7000_desc, b, 1);
}

static void
write_e7000 (char *s)
{
  serial_write (e7000_desc, s, strlen (s));
}

static int
normal (int x)
{
  if (x == '\n')
    return '\r';
  return x;
}

/* Read a character from the remote system, doing all the fancy timeout
   stuff.  Handles serial errors and EOF.  If TIMEOUT == 0, and no chars,
   returns -1, else returns next char.  Discards chars > 127.  */

static int
readchar (int timeout)
{
  int c;

  do
    {
      c = serial_readchar (e7000_desc, timeout);
    }
  while (c > 127);

  if (c == SERIAL_TIMEOUT)
    {
      if (timeout == 0)
	return -1;
      echo = 0;
      error (_("Timeout reading from remote system."));
    }
  else if (c < 0)
    error (_("Serial communication error"));

  if (remote_debug)
    {
      putchar_unfiltered (c);
      gdb_flush (gdb_stdout);
    }

  return normal (c);
}

#if 0
char *
tl (int x)
{
  static char b[8][10];
  static int p;

  p++;
  p &= 7;
  if (x >= ' ')
    {
      b[p][0] = x;
      b[p][1] = 0;
    }
  else
    {
      sprintf (b[p], "<%d>", x);
    }

  return b[p];
}
#endif

/* Scan input from the remote system, until STRING is found.  If
   DISCARD is non-zero, then discard non-matching input, else print it
   out.  Let the user break out immediately.  */

static void
expect (char *string)
{
  char *p = string;
  int c;
  int nl = 0;

  while (1)
    {
      c = readchar (timeout);

      if (echo)
	{
	  if (c == '\r' || c == '\n')
	    {
	      if (!nl)
		putchar_unfiltered ('\n');
	      nl = 1;
	    }
	  else
	    {
	      nl = 0;
	      putchar_unfiltered (c);
	    }
	  gdb_flush (gdb_stdout);
	}
      if (normal (c) == normal (*p++))
	{
	  if (*p == '\0')
	    return;
	}
      else
	{
	  p = string;

	  if (normal (c) == normal (string[0]))
	    p++;
	}
    }
}

/* Keep discarding input until we see the e7000 prompt.

   The convention for dealing with the prompt is that you
   o give your command
   o *then* wait for the prompt.

   Thus the last thing that a procedure does with the serial line will
   be an expect_prompt().  Exception: e7000_resume does not wait for
   the prompt, because the terminal is being handed over to the
   inferior.  However, the next thing which happens after that is a
   e7000_wait which does wait for the prompt.  Note that this includes
   abnormal exit, e.g. error().  This is necessary to prevent getting
   into states from which we can't recover.  */

static void
expect_prompt (void)
{
  expect (":");
}

static void
expect_full_prompt (void)
{
  expect ("\r:");
}

static int
convert_hex_digit (int ch)
{
  if (ch >= '0' && ch <= '9')
    return ch - '0';
  else if (ch >= 'A' && ch <= 'F')
    return ch - 'A' + 10;
  else if (ch >= 'a' && ch <= 'f')
    return ch - 'a' + 10;
  return -1;
}

static int
get_hex (int *start)
{
  int value = convert_hex_digit (*start);
  int try;

  *start = readchar (timeout);
  while ((try = convert_hex_digit (*start)) >= 0)
    {
      value <<= 4;
      value += try;
      *start = readchar (timeout);
    }
  return value;
}

#if 0
/* Get N 32-bit words from remote, each preceded by a space, and put
   them in registers starting at REGNO.  */

static void
get_hex_regs (int n, int regno)
{
  long val;
  int i;

  for (i = 0; i < n; i++)
    {
      int j;

      val = 0;
      for (j = 0; j < 8; j++)
	val = (val << 4) + get_hex_digit (j == 0);
      regcache_raw_supply (current_regcache, regno++, (char *) &val);
    }
}
#endif

/* This is called not only when we first attach, but also when the
   user types "run" after having attached.  */

static void
e7000_create_inferior (char *execfile, char *args, char **env,
		       int from_tty)
{
  int entry_pt;

  if (args && *args)
    error (_("Can't pass arguments to remote E7000DEBUG process"));

  if (execfile == 0 || exec_bfd == 0)
    error (_("No executable file specified"));

  entry_pt = (int) bfd_get_start_address (exec_bfd);

#ifdef CREATE_INFERIOR_HOOK
  CREATE_INFERIOR_HOOK (0);	/* No process-ID */
#endif

  /* The "process" (board) is already stopped awaiting our commands, and
     the program is already downloaded.  We just set its PC and go.  */

  clear_proceed_status ();

  /* Tell wait_for_inferior that we've started a new process.  */
  init_wait_for_inferior ();

  /* Set up the "saved terminal modes" of the inferior
     based on what modes we are starting it with.  */
  target_terminal_init ();

  /* Install inferior's terminal modes.  */
  target_terminal_inferior ();

  /* insert_step_breakpoint ();  FIXME, do we need this?  */
  write_pc ((CORE_ADDR) entry_pt);
}

/* Open a connection to a remote debugger.  NAME is the filename used
   for communication.  */

static int baudrate = 9600;
static char dev_name[100];

static char *machine = "";
static char *user = "";
static char *passwd = "";
static char *dir = "";

/* Grab the next token and buy some space for it */

static char *
next (char **ptr)
{
  char *p = *ptr;
  char *s;
  char *r;
  int l = 0;

  while (*p && *p == ' ')
    p++;
  s = p;
  while (*p && (*p != ' ' && *p != '\t'))
    {
      l++;
      p++;
    }
  r = xmalloc (l + 1);
  memcpy (r, s, l);
  r[l] = 0;
  *ptr = p;
  return r;
}

static void
e7000_login_command (char *args, int from_tty)
{
  if (args)
    {
      machine = next (&args);
      user = next (&args);
      passwd = next (&args);
      dir = next (&args);
      if (from_tty)
	{
	  printf_unfiltered ("Set info to %s %s %s %s\n", machine, user, passwd, dir);
	}
    }
  else
    {
      error (_("Syntax is ftplogin <machine> <user> <passwd> <directory>"));
    }
}

/* Start an ftp transfer from the E7000 to a host */

static void
e7000_ftp_command (char *args, int from_tty)
{
  /* FIXME: arbitrary limit on machine names and such.  */
  char buf[200];

  int oldtimeout = timeout;
  timeout = remote_timeout;

  sprintf (buf, "ftp %s\r", machine);
  puts_e7000debug (buf);
  expect (" Username : ");
  sprintf (buf, "%s\r", user);
  puts_e7000debug (buf);
  expect (" Password : ");
  write_e7000 (passwd);
  write_e7000 ("\r");
  expect ("success\r");
  expect ("FTP>");
  sprintf (buf, "cd %s\r", dir);
  puts_e7000debug (buf);
  expect ("FTP>");
  sprintf (buf, "ll 0;s:%s\r", args);
  puts_e7000debug (buf);
  expect ("FTP>");
  puts_e7000debug ("bye\r");
  expect (":");
  timeout = oldtimeout;
}

static int
e7000_parse_device (char *args, char *dev_name, int baudrate)
{
  char junk[128];
  int n = 0;
  if (args && strcasecmp (args, "pc") == 0)
    {
      strcpy (dev_name, args);
      using_pc = 1;
    }
  else
    {
      /* FIXME! temp hack to allow use with port master -
         target tcp_remote <device> */
      if (args && strncmp (args, "tcp", 10) == 0)
	{
	  char com_type[128];
	  n = sscanf (args, " %s %s %d %s", com_type, dev_name, &baudrate, junk);
	  using_tcp_remote = 1;
	  n--;
	}
      else if (args)
	{
	  n = sscanf (args, " %s %d %s", dev_name, &baudrate, junk);
	}

      if (n != 1 && n != 2)
	{
	  error (_("Bad arguments.  Usage:\ttarget e7000 <device> <speed>\n\
or \t\ttarget e7000 <host>[:<port>]\n\
or \t\ttarget e7000 tcp_remote <host>[:<port>]\n\
or \t\ttarget e7000 pc\n"));
	}

#if !defined(__GO32__) && !defined(_WIN32) && !defined(__CYGWIN__)
      /* FIXME!  test for ':' is ambiguous */
      if (n == 1 && strchr (dev_name, ':') == 0)
	{
	  /* Default to normal telnet port */
	  /* serial_open will use this to determine tcp communication */
	  strcat (dev_name, ":23");
	}
#endif
      if (!using_tcp_remote && strchr (dev_name, ':'))
	using_tcp = 1;
    }

  return n;
}

/* Stub for catch_errors.  */

static int
e7000_start_remote (void *dummy)
{
  int loop;
  int sync;
  int try;
  int quit_trying;

  immediate_quit++;		/* Allow user to interrupt it */

  /* Hello?  Are you there?  */
  sync = 0;
  loop = 0;
  try = 0;
  quit_trying = 20;
  putchar_e7000 (CTRLC);
  while (!sync && ++try <= quit_trying)
    {
      int c;

      printf_unfiltered ("[waiting for e7000...]\n");

      write_e7000 ("\r");
      c = readchar (1);

      /* FIXME!  this didn't seem right->  while (c != SERIAL_TIMEOUT)
       * we get stuck in this loop ...
       * We may never timeout, and never sync up :-(
       */
      while (!sync && c != -1)
	{
	  /* Dont echo cr's */
	  if (c != '\r')
	    {
	      putchar_unfiltered (c);
	      gdb_flush (gdb_stdout);
	    }
	  /* Shouldn't we either break here, or check for sync in inner loop? */
	  if (c == ':')
	    sync = 1;

	  if (loop++ == 20)
	    {
	      putchar_e7000 (CTRLC);
	      loop = 0;
	    }

	  QUIT;

	  if (quit_flag)
	    {
	      putchar_e7000 (CTRLC);
	      /* Was-> quit_flag = 0; */
	      c = -1;
	      quit_trying = try + 1;	/* we don't want to try anymore */
	    }
	  else
	    {
	      c = readchar (1);
	    }
	}
    }

  if (!sync)
    {
      fprintf_unfiltered (gdb_stderr, "Giving up after %d tries...\n", try);
      error (_("Unable to synchronize with target."));
    }

  puts_e7000debug ("\r");
  expect_prompt ();
  puts_e7000debug ("b -\r");	/* Clear breakpoints */
  expect_prompt ();

  immediate_quit--;

/* This is really the job of start_remote however, that makes an assumption
   that the target is about to print out a status message of some sort.  That
   doesn't happen here. */

  reinit_frame_cache ();
  registers_changed ();
  stop_pc = read_pc ();
  print_stack_frame (get_selected_frame (NULL), 0, SRC_AND_LOC);

  return 1;
}

static void
e7000_open (char *args, int from_tty)
{
  int n;

  target_preopen (from_tty);

  n = e7000_parse_device (args, dev_name, baudrate);

  push_target (&e7000_ops);

  e7000_desc = serial_open (dev_name);

  if (!e7000_desc)
    perror_with_name (dev_name);

  if (serial_setbaudrate (e7000_desc, baudrate))
    {
      serial_close (e7000_desc);
      perror_with_name (dev_name);
    }
  serial_raw (e7000_desc);

  /* Start the remote connection; if error (0), discard this target.
     In particular, if the user quits, be sure to discard it
     (we'd be in an inconsistent state otherwise).  */
  if (!catch_errors (e7000_start_remote, (char *) 0,
       "Couldn't establish connection to remote target\n", RETURN_MASK_ALL))
    if (from_tty)
      printf_filtered ("Remote target %s connected to %s\n", target_shortname,
		       dev_name);
}

/* Close out all files and local state before this target loses control. */

static void
e7000_close (int quitting)
{
  if (e7000_desc)
    {
      serial_close (e7000_desc);
      e7000_desc = 0;
    }
}

/* Terminate the open connection to the remote debugger.  Use this
   when you want to detach and do something else with your gdb.  */

static void
e7000_detach (char *arg, int from_tty)
{
  pop_target ();		/* calls e7000_close to do the real work */
  if (from_tty)
    printf_unfiltered ("Ending remote %s debugging\n", target_shortname);
}

/* Tell the remote machine to resume.  */

static void
e7000_resume (ptid_t ptid, int step, enum target_signal sigal)
{
  if (step)
    puts_e7000debug ("S\r");
  else
    puts_e7000debug ("G\r");
}

/* Read the remote registers into the block REGS.  

   For the H8/300 a register dump looks like:

   PC=00021A  CCR=80:I*******
   ER0 - ER3  0000000A 0000002E 0000002E 00000000
   ER4 - ER7  00000000 00000000 00000000 00FFEFF6
   000218           MOV.B     R1L,R2L
   STEP NORMAL END or
   BREAK POINT
 */

char *want_h8300h = "PC=%p CCR=%c\n\
 ER0 - ER3  %0 %1 %2 %3\n\
 ER4 - ER7  %4 %5 %6 %7\n";

char *want_nopc_h8300h = "%p CCR=%c\n\
 ER0 - ER3  %0 %1 %2 %3\n\
 ER4 - ER7  %4 %5 %6 %7";

char *want_h8300s = "PC=%p CCR=%c\n\
 MACH=\n\
 ER0 - ER3  %0 %1 %2 %3\n\
 ER4 - ER7  %4 %5 %6 %7\n";

char *want_nopc_h8300s = "%p CCR=%c EXR=%9\n\
 ER0 - ER3  %0 %1 %2 %3\n\
 ER4 - ER7  %4 %5 %6 %7";

char *want_sh = "PC=%16 SR=%22\n\
PR=%17 GBR=%18 VBR=%19\n\
MACH=%20 MACL=%21\n\
R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n";

char *want_nopc_sh = "%16 SR=%22\n\
 PR=%17 GBR=%18 VBR=%19\n\
 MACH=%20 MACL=%21\n\
 R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
 R8-15 %8 %9 %10 %11 %12 %13 %14 %15";

char *want_sh3 = "PC=%16 SR=%22\n\
PR=%17 GBR=%18 VBR=%19\n\
MACH=%20 MACL=%21 SSR=%23 SPC=%24\n\
R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n\
R0_BANK0-R3_BANK0 %25 %26 %27 %28\n\
R4_BANK0-R7_BANK0 %29 %30 %31 %32\n\
R0_BANK1-R3_BANK1 %33 %34 %35 %36\n\
R4_BANK1-R7_BANK1 %37 %38 %39 %40";

char *want_nopc_sh3 = "%16 SR=%22\n\
 PR=%17 GBR=%18 VBR=%19\n\
 MACH=%20 MACL=%21 SSR=%22 SPC=%23\n\
 R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\
 R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n\
 R0_BANK0-R3_BANK0 %25 %26 %27 %28\n\
 R4_BANK0-R7_BANK0 %29 %30 %31 %32\n\
 R0_BANK1-R3_BANK1 %33 %34 %35 %36\n\
 R4_BANK1-R7_BANK1 %37 %38 %39 %40";

static int
gch (void)
{
  return readchar (timeout);
}

static unsigned int
gbyte (void)
{
  int high = convert_hex_digit (gch ());
  int low = convert_hex_digit (gch ());

  return (high << 4) + low;
}

static void
fetch_regs_from_dump (int (*nextchar) (), char *want)
{
  int regno;
  char buf[MAX_REGISTER_SIZE];

  int thischar = nextchar ();

  if (want == NULL)
    internal_error (__FILE__, __LINE__, _("Register set not selected."));

  while (*want)
    {
      switch (*want)
	{
	case '\n':
	  /* Skip to end of line and then eat all new line type stuff */
	  while (thischar != '\n' && thischar != '\r')
	    thischar = nextchar ();
	  while (thischar == '\n' || thischar == '\r')
	    thischar = nextchar ();
	  want++;
	  break;

	case ' ':
	  while (thischar == ' '
		 || thischar == '\t'
		 || thischar == '\r'
		 || thischar == '\n')
	    thischar = nextchar ();
	  want++;
	  break;

	default:
	  if (*want == thischar)
	    {
	      want++;
	      if (*want)
		thischar = nextchar ();

	    }
	  else if (thischar == ' ' || thischar == '\n' || thischar == '\r')
	    {
	      thischar = nextchar ();
	    }
	  else
	    {
	      error (_("out of sync in fetch registers wanted <%s>, got <%c 0x%x>"),
		     want, thischar, thischar);
	    }

	  break;
	case '%':
	  /* Got a register command */
	  want++;
	  switch (*want)
	    {
#ifdef PC_REGNUM
	    case 'p':
	      regno = PC_REGNUM;
	      want++;
	      break;
#endif
#ifdef CCR_REGNUM
	    case 'c':
	      regno = CCR_REGNUM;
	      want++;
	      break;
#endif
#ifdef SP_REGNUM
	    case 's':
	      regno = SP_REGNUM;
	      want++;
	      break;
#endif
#ifdef DEPRECATED_FP_REGNUM
	    case 'f':
	      regno = DEPRECATED_FP_REGNUM;
	      want++;
	      break;
#endif

	    default:
	      if (isdigit (want[0]))
		{
		  if (isdigit (want[1]))
		    {
		      regno = (want[0] - '0') * 10 + want[1] - '0';
		      want += 2;
		    }
		  else
		    {
		      regno = want[0] - '0';
		      want++;
		    }
		}

	      else
		internal_error (__FILE__, __LINE__, _("failed internal consistency check"));
	    }
	  store_signed_integer (buf,
				register_size (current_gdbarch, regno),
				(LONGEST) get_hex (&thischar));
	  regcache_raw_supply (current_regcache, regno, buf);
	  break;
	}
    }
}

static void
e7000_fetch_registers (void)
{
  int regno;
  char *wanted = NULL;
  int realregs = 0;

  puts_e7000debug ("R\r");

  if (TARGET_ARCHITECTURE->arch == bfd_arch_sh)
    {
      wanted = want_sh;
      realregs = 59;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_sh3:
	case bfd_mach_sh3e:
	case bfd_mach_sh4:
	  wanted = want_sh3;
	}
    }
  if (TARGET_ARCHITECTURE->arch == bfd_arch_h8300)
    {
      wanted = want_h8300h;
      realregs = 10;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_h8300s:
	case bfd_mach_h8300sn:
	case bfd_mach_h8300sx:
	case bfd_mach_h8300sxn:
	  wanted = want_h8300s;
	  realregs = 11;
	}
    }

  fetch_regs_from_dump (gch, wanted);

  /* And supply the extra ones the simulator uses */
  for (regno = realregs; regno < NUM_REGS; regno++)
    {
      int buf = 0;

      regcache_raw_supply (current_regcache, regno, (char *) (&buf));
    }
}

/* Fetch register REGNO, or all registers if REGNO is -1.  Returns
   errno value.  */

static void
e7000_fetch_register (int regno)
{
  e7000_fetch_registers ();
}

/* Store the remote registers from the contents of the block REGS.  */

static void
e7000_store_registers (void)
{
  int regno;
  int realregs = 0;

  if (TARGET_ARCHITECTURE->arch == bfd_arch_sh)
    realregs = 59;
  if (TARGET_ARCHITECTURE->arch == bfd_arch_h8300) {
    realregs = ((TARGET_ARCHITECTURE->mach == bfd_mach_h8300s ||
		 TARGET_ARCHITECTURE->mach == bfd_mach_h8300sn ||
		 TARGET_ARCHITECTURE->mach == bfd_mach_h8300sx ||
		 TARGET_ARCHITECTURE->mach == bfd_mach_h8300sxn) ? 11 : 10);
  }

  for (regno = 0; regno < realregs; regno++)
    e7000_store_register (regno);

  registers_changed ();
}

/* Store register REGNO, or all if REGNO == 0.  Return errno value.  */

static void
e7000_store_register (int regno)
{
  char buf[200];

  if (regno == -1)
    {
      e7000_store_registers ();
      return;
    }

  if (TARGET_ARCHITECTURE->arch == bfd_arch_h8300)
    {
      if (regno <= 7)
	{
	  sprintf (buf, ".ER%d %s\r", regno, phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}
      else if (regno == PC_REGNUM)
	{
	  sprintf (buf, ".PC %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}
#ifdef CCR_REGNUM
      else if (regno == CCR_REGNUM)
	{
	  sprintf (buf, ".CCR %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}
#endif
    }

  else if (TARGET_ARCHITECTURE->arch == bfd_arch_sh)
    {
      if (regno == PC_REGNUM)
	{
	  sprintf (buf, ".PC %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno == SR_REGNUM)
	{
	  sprintf (buf, ".SR %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno ==  PR_REGNUM)
	{
	  sprintf (buf, ".PR %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno == GBR_REGNUM)
	{
	  sprintf (buf, ".GBR %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno == VBR_REGNUM)
	{
	  sprintf (buf, ".VBR %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno == MACH_REGNUM)
	{
	  sprintf (buf, ".MACH %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}

      else if (regno == MACL_REGNUM)
	{
	  sprintf (buf, ".MACL %s\r", phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}
      else
	{
	  sprintf (buf, ".R%d %s\r", regno, phex_nz (read_register (regno), 0));
	  puts_e7000debug (buf);
	}
    }

  expect_prompt ();
}

/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
e7000_prepare_to_store (void)
{
  /* Do nothing, since we can store individual regs */
}

static void
e7000_files_info (struct target_ops *ops)
{
  printf_unfiltered ("\tAttached to %s at %d baud.\n", dev_name, baudrate);
}

static int
stickbyte (char *where, unsigned int what)
{
  static CONST char digs[] = "0123456789ABCDEF";

  where[0] = digs[(what >> 4) & 0xf];
  where[1] = digs[(what & 0xf) & 0xf];

  return what;
}

/* Write a small ammount of memory. */

static int
write_small (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  int i;
  char buf[200];

  for (i = 0; i < len; i++)
    {
      if (((memaddr + i) & 3) == 0 && (i + 3 < len))
	{
	  /* Can be done with a long word */
	  sprintf (buf, "m %s %x%02x%02x%02x;l\r",
		   paddr_nz (memaddr + i),
		   myaddr[i], myaddr[i + 1], myaddr[i + 2], myaddr[i + 3]);
	  puts_e7000debug (buf);
	  i += 3;
	}
      else
	{
	  sprintf (buf, "m %s %x\r", paddr_nz (memaddr + i), myaddr[i]);
	  puts_e7000debug (buf);
	}
    }

  expect_prompt ();

  return len;
}

/* Write a large ammount of memory, this only works with the serial
   mode enabled.  Command is sent as

   il ;s:s\r     ->
   <- il ;s:s\r
   <-   ENQ
   ACK          ->
   <- LO s\r
   Srecords...
   ^Z           ->
   <-   ENQ
   ACK          ->  
   <-   :       
 */

static int
write_large (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  int i;
#define maxstride  128
  int stride;

  puts_e7000debug ("IL ;S:FK\r");
  expect (ENQSTRING);
  putchar_e7000 (ACK);
  expect ("LO FK\r");

  for (i = 0; i < len; i += stride)
    {
      char compose[maxstride * 2 + 50];
      int address = i + memaddr;
      int j;
      int check_sum;
      int where = 0;
      int alen;

      stride = len - i;
      if (stride > maxstride)
	stride = maxstride;

      compose[where++] = 'S';
      check_sum = 0;
      if (address >= 0xffffff)
	alen = 4;
      else if (address >= 0xffff)
	alen = 3;
      else
	alen = 2;
      /* Insert type. */
      compose[where++] = alen - 1 + '0';
      /* Insert length. */
      check_sum += stickbyte (compose + where, alen + stride + 1);
      where += 2;
      while (alen > 0)
	{
	  alen--;
	  check_sum += stickbyte (compose + where, address >> (8 * (alen)));
	  where += 2;
	}

      for (j = 0; j < stride; j++)
	{
	  check_sum += stickbyte (compose + where, myaddr[i + j]);
	  where += 2;
	}
      stickbyte (compose + where, ~check_sum);
      where += 2;
      compose[where++] = '\r';
      compose[where++] = '\n';
      compose[where++] = 0;

      serial_write (e7000_desc, compose, where);
      j = readchar (0);
      if (j == -1)
	{
	  /* This is ok - nothing there */
	}
      else if (j == ENQ)
	{
	  /* Hmm, it's trying to tell us something */
	  expect (":");
	  error (_("Error writing memory"));
	}
      else
	{
	  printf_unfiltered ("@@%d}@@", j);
	  while ((j = readchar (0)) > 0)
	    {
	      printf_unfiltered ("@@{%d}@@", j);
	    }
	}
    }

  /* Send the trailer record */
  write_e7000 ("S70500000000FA\r");
  putchar_e7000 (CTRLZ);
  expect (ENQSTRING);
  putchar_e7000 (ACK);
  expect (":");

  return len;
}

/* Copy LEN bytes of data from debugger memory at MYADDR to inferior's
   memory at MEMADDR.  Returns length moved.

   Can't use the Srecord load over ethernet, so don't use fast method
   then.  */

static int
e7000_write_inferior_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  if (len < 16 || using_tcp || using_pc)
    return write_small (memaddr, myaddr, len);
  else
    return write_large (memaddr, myaddr, len);
}

/* Read LEN bytes from inferior memory at MEMADDR.  Put the result
   at debugger address MYADDR.  Returns length moved. 

   Small transactions we send
   m <addr>;l
   and receive
   00000000 12345678 ?
 */

static int
e7000_read_inferior_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  int count;
  int c;
  int i;
  char buf[200];
  /* Starting address of this pass.  */

/*  printf("READ INF %x %x %d\n", memaddr, myaddr, len); */
  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }

  sprintf (buf, "m %s;l\r", paddr_nz (memaddr));
  puts_e7000debug (buf);

  for (count = 0; count < len; count += 4)
    {
      /* Suck away the address */
      c = gch ();
      while (c != ' ')
	c = gch ();
      c = gch ();
      if (c == '*')
	{			/* Some kind of error */
	  puts_e7000debug (".\r");	/* Some errors leave us in memory input mode */
	  expect_full_prompt ();
	  return -1;
	}
      while (c != ' ')
	c = gch ();

      /* Now read in the data */
      for (i = 0; i < 4; i++)
	{
	  int b = gbyte ();
	  if (count + i < len)
	    {
	      myaddr[count + i] = b;
	    }
	}

      /* Skip the trailing ? and send a . to end and a cr for more */
      gch ();
      gch ();
      if (count + 4 >= len)
	puts_e7000debug (".\r");
      else
	puts_e7000debug ("\r");

    }
  expect_prompt ();
  return len;
}



/*
   For large transfers we used to send


   d <addr> <endaddr>\r

   and receive
   <ADDRESS>           <    D   A   T   A    >               <   ASCII CODE   >
   00000000 5F FD FD FF DF 7F DF FF  01 00 01 00 02 00 08 04  "_..............."
   00000010 FF D7 FF 7F D7 F1 7F FF  00 05 00 00 08 00 40 00  "..............@@."
   00000020 7F FD FF F7 7F FF FF F7  00 00 00 00 00 00 00 00  "................"

   A cost in chars for each transaction of 80 + 5*n-bytes. 

   Large transactions could be done with the srecord load code, but
   there is a pause for a second before dumping starts, which slows the
   average rate down!
 */

static int
e7000_read_inferior_memory_large (CORE_ADDR memaddr, unsigned char *myaddr,
				  int len)
{
  int count;
  int c;
  char buf[200];

  /* Starting address of this pass.  */

  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }

  sprintf (buf, "d %s %s\r", paddr_nz (memaddr), paddr_nz (memaddr + len - 1));
  puts_e7000debug (buf);

  count = 0;
  c = gch ();

  /* skip down to the first ">" */
  while (c != '>')
    c = gch ();
  /* now skip to the end of that line */
  while (c != '\r')
    c = gch ();
  c = gch ();

  while (count < len)
    {
      /* get rid of any white space before the address */
      while (c <= ' ')
	c = gch ();

      /* Skip the address */
      get_hex (&c);

      /* read in the bytes on the line */
      while (c != '"' && count < len)
	{
	  if (c == ' ')
	    c = gch ();
	  else
	    {
	      myaddr[count++] = get_hex (&c);
	    }
	}
      /* throw out the rest of the line */
      while (c != '\r')
	c = gch ();
    }

  /* wait for the ":" prompt */
  while (c != ':')
    c = gch ();

  return len;
}

#if 0

static int
fast_but_for_the_pause_e7000_read_inferior_memory (CORE_ADDR memaddr,
						   char *myaddr, int len)
{
  int loop;
  int c;
  char buf[200];

  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }

  sprintf (buf, "is %x@@%x:s\r", memaddr, len);
  puts_e7000debug (buf);
  gch ();
  c = gch ();
  if (c != ENQ)
    {
      /* Got an error */
      error (_("Memory read error"));
    }
  putchar_e7000 (ACK);
  expect ("SV s");
  loop = 1;
  while (loop)
    {
      int type;
      int length;
      int addr;
      int i;

      c = gch ();
      switch (c)
	{
	case ENQ:		/* ENQ, at the end */
	  loop = 0;
	  break;
	case 'S':
	  /* Start of an Srecord */
	  type = gch ();
	  length = gbyte ();
	  switch (type)
	    {
	    case '7':		/* Termination record, ignore */
	    case '0':
	    case '8':
	    case '9':
	      /* Header record - ignore it */
	      while (length--)
		{
		  gbyte ();
		}
	      break;
	    case '1':
	    case '2':
	    case '3':
	      {
		int alen;

		alen = type - '0' + 1;
		addr = 0;
		while (alen--)
		  {
		    addr = (addr << 8) + gbyte ();
		    length--;
		  }

		for (i = 0; i < length - 1; i++)
		  myaddr[i + addr - memaddr] = gbyte ();

		gbyte ();	/* Ignore checksum */
	      }
	    }
	}
    }

  putchar_e7000 (ACK);
  expect ("TOP ADDRESS =");
  expect ("END ADDRESS =");
  expect (":");

  return len;
}

#endif

/* Transfer LEN bytes between GDB address MYADDR and target address
   MEMADDR.  If WRITE is non-zero, transfer them to the target,
   otherwise transfer them from the target.  TARGET is unused.

   Returns the number of bytes transferred. */

static int
e7000_xfer_inferior_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len,
			    int write, struct mem_attrib *attrib,
			    struct target_ops *target)
{
  if (write)
    return e7000_write_inferior_memory (memaddr, myaddr, len);
  else if (len < 16)
    return e7000_read_inferior_memory (memaddr, myaddr, len);
  else
    return e7000_read_inferior_memory_large (memaddr, myaddr, len);
}

static void
e7000_kill (void)
{
}

static void
e7000_load (char *args, int from_tty)
{
  struct cleanup *old_chain;
  asection *section;
  bfd *pbfd;
  bfd_vma entry;
#define WRITESIZE 0x1000
  char buf[2 + 4 + 4 + WRITESIZE];	/* `DT' + <addr> + <len> + <data> */
  char *filename;
  int quiet;
  int nostart;
  time_t start_time, end_time;	/* Start and end times of download */
  unsigned long data_count;	/* Number of bytes transferred to memory */
  int oldtimeout = timeout;

  timeout = remote_timeout;


  /* FIXME! change test to test for type of download */
  if (!using_tcp)
    {
      generic_load (args, from_tty);
      return;
    }

  /* for direct tcp connections, we can do a fast binary download */
  buf[0] = 'D';
  buf[1] = 'T';
  quiet = 0;
  nostart = 0;
  filename = NULL;

  while (*args != '\000')
    {
      char *arg;

      while (isspace (*args))
	args++;

      arg = args;

      while ((*args != '\000') && !isspace (*args))
	args++;

      if (*args != '\000')
	*args++ = '\000';

      if (*arg != '-')
	filename = arg;
      else if (strncmp (arg, "-quiet", strlen (arg)) == 0)
	quiet = 1;
      else if (strncmp (arg, "-nostart", strlen (arg)) == 0)
	nostart = 1;
      else
	error (_("unknown option `%s'"), arg);
    }

  if (!filename)
    filename = get_exec_file (1);

  pbfd = bfd_openr (filename, gnutarget);
  if (pbfd == NULL)
    {
      perror_with_name (filename);
      return;
    }
  old_chain = make_cleanup_bfd_close (pbfd);

  if (!bfd_check_format (pbfd, bfd_object))
    error (_("\"%s\" is not an object file: %s"), filename,
	   bfd_errmsg (bfd_get_error ()));

  start_time = time (NULL);
  data_count = 0;

  puts_e7000debug ("mw\r");

  expect ("\nOK");

  for (section = pbfd->sections; section; section = section->next)
    {
      if (bfd_get_section_flags (pbfd, section) & SEC_LOAD)
	{
	  bfd_vma section_address;
	  bfd_size_type section_size;
	  file_ptr fptr;

	  section_address = bfd_get_section_vma (pbfd, section);
	  section_size = bfd_get_section_size (section);

	  if (!quiet)
	    printf_filtered ("[Loading section %s at 0x%s (%s bytes)]\n",
			     bfd_get_section_name (pbfd, section),
			     paddr_nz (section_address),
			     paddr_u (section_size));

	  fptr = 0;

	  data_count += section_size;

	  while (section_size > 0)
	    {
	      int count;
	      static char inds[] = "|/-\\";
	      static int k = 0;

	      QUIT;

	      count = min (section_size, WRITESIZE);

	      buf[2] = section_address >> 24;
	      buf[3] = section_address >> 16;
	      buf[4] = section_address >> 8;
	      buf[5] = section_address;

	      buf[6] = count >> 24;
	      buf[7] = count >> 16;
	      buf[8] = count >> 8;
	      buf[9] = count;

	      bfd_get_section_contents (pbfd, section, buf + 10, fptr, count);

	      if (serial_write (e7000_desc, buf, count + 10))
		fprintf_unfiltered (gdb_stderr,
				    "e7000_load: serial_write failed: %s\n",
				    safe_strerror (errno));

	      expect ("OK");

	      if (!quiet)
		{
		  printf_unfiltered ("\r%c", inds[k++ % 4]);
		  gdb_flush (gdb_stdout);
		}

	      section_address += count;
	      fptr += count;
	      section_size -= count;
	    }
	}
    }

  write_e7000 ("ED");

  expect_prompt ();

  end_time = time (NULL);

/* Finally, make the PC point at the start address */

  if (exec_bfd)
    write_pc (bfd_get_start_address (exec_bfd));

  inferior_ptid = null_ptid;	/* No process now */

/* This is necessary because many things were based on the PC at the time that
   we attached to the monitor, which is no longer valid now that we have loaded
   new code (and just changed the PC).  Another way to do this might be to call
   normal_stop, except that the stack may not be valid, and things would get
   horribly confused... */

  clear_symtab_users ();

  if (!nostart)
    {
      entry = bfd_get_start_address (pbfd);

      if (!quiet)
	printf_unfiltered ("[Starting %s at 0x%s]\n", filename, paddr_nz (entry));

/*      start_routine (entry); */
    }

  report_transfer_performance (data_count, start_time, end_time);

  do_cleanups (old_chain);
  timeout = oldtimeout;
}

/* Clean up when a program exits.

   The program actually lives on in the remote processor's RAM, and may be
   run again without a download.  Don't leave it full of breakpoint
   instructions.  */

static void
e7000_mourn_inferior (void)
{
  remove_breakpoints ();
  unpush_target (&e7000_ops);
  generic_mourn_inferior ();	/* Do all the proper things now */
}

#define MAX_BREAKPOINTS 200
#ifdef  HARD_BREAKPOINTS
#define MAX_E7000DEBUG_BREAKPOINTS (BC_BREAKPOINTS ? 5 :  MAX_BREAKPOINTS)
#else
#define MAX_E7000DEBUG_BREAKPOINTS MAX_BREAKPOINTS
#endif

/* Since we can change to soft breakpoints dynamically, we must define 
   more than enough.  Was breakaddr[MAX_E7000DEBUG_BREAKPOINTS]. */
static CORE_ADDR breakaddr[MAX_BREAKPOINTS] =
{0};

static int
e7000_insert_breakpoint (struct bp_target_info *bp_tgt)
{
  CORE_ADDR addr = bp_tgt->placed_address;
  int i;
  char buf[200];
#if 0
  static char nop[2] = NOP;
#endif

  for (i = 0; i <= MAX_E7000DEBUG_BREAKPOINTS; i++)
    if (breakaddr[i] == 0)
      {
	breakaddr[i] = addr;
	/* Save old contents, and insert a nop in the space */
#ifdef HARD_BREAKPOINTS
	if (BC_BREAKPOINTS)
	  {
	    sprintf (buf, "BC%d A=%s\r", i + 1, paddr_nz (addr));
	    puts_e7000debug (buf);
	  }
	else
	  {
	    sprintf (buf, "B %s\r", paddr_nz (addr));
	    puts_e7000debug (buf);
	  }
#else
#if 0
	bp_tgt->shadow_len = 2;
	e7000_read_inferior_memory (addr, bp_tgt->shadow_contents, 2);
	e7000_write_inferior_memory (addr, nop, 2);
#endif

	sprintf (buf, "B %x\r", addr);
	puts_e7000debug (buf);
#endif
	expect_prompt ();
	return 0;
      }

  error (_("Too many breakpoints ( > %d) for the E7000."),
	 MAX_E7000DEBUG_BREAKPOINTS);
  return 1;
}

static int
e7000_remove_breakpoint (struct bp_target_info *bp_tgt)
{
  CORE_ADDR addr = bp_tgt->placed_address;
  int i;
  char buf[200];

  for (i = 0; i < MAX_E7000DEBUG_BREAKPOINTS; i++)
    if (breakaddr[i] == addr)
      {
	breakaddr[i] = 0;
#ifdef HARD_BREAKPOINTS
	if (BC_BREAKPOINTS)
	  {
	    sprintf (buf, "BC%d - \r", i + 1);
	    puts_e7000debug (buf);
	  }
	else
	  {
	    sprintf (buf, "B - %s\r", paddr_nz (addr));
	    puts_e7000debug (buf);
	  }
	expect_prompt ();
#else
	sprintf (buf, "B - %s\r", paddr_nz (addr));
	puts_e7000debug (buf);
	expect_prompt ();

#if 0
	/* Replace the insn under the break */
	e7000_write_inferior_memory (addr, bp_tgt->shadow_contents,
				     bp_tgt->shadow_len);
#endif
#endif

	return 0;
      }
 
  warning (_("Can't find breakpoint associated with 0x%s."), paddr_nz (addr));
  return 1;
}

/* Put a command string, in args, out to STDBUG.  Output from STDBUG
   is placed on the users terminal until the prompt is seen. */

static void
e7000_command (char *args, int fromtty)
{
  /* FIXME: arbitrary limit on length of args.  */
  char buf[200];

  echo = 0;

  if (!e7000_desc)
    error (_("e7000 target not open."));
  if (!args)
    {
      puts_e7000debug ("\r");
    }
  else
    {
      sprintf (buf, "%s\r", args);
      puts_e7000debug (buf);
    }

  echo++;
  ctrl_c = 2;
  expect_full_prompt ();
  echo--;
  ctrl_c = 0;
  printf_unfiltered ("\n");

  /* Who knows what the command did... */
  registers_changed ();
}


static void
e7000_drain_command (char *args, int fromtty)
{
  int c;

  puts_e7000debug ("end\r");
  putchar_e7000 (CTRLC);

  while ((c = readchar (1)) != -1)
    {
      if (quit_flag)
	{
	  putchar_e7000 (CTRLC);
	  quit_flag = 0;
	}
      if (c > ' ' && c < 127)
	printf_unfiltered ("%c", c & 0xff);
      else
	printf_unfiltered ("<%x>", c & 0xff);
    }
}

#define NITEMS 7

static int
why_stop (void)
{
  static char *strings[NITEMS] =
  {
    "STEP NORMAL",
    "BREAK POINT",
    "BREAK KEY",
    "BREAK CONDI",
    "CYCLE ACCESS",
    "ILLEGAL INSTRUCTION",
    "WRITE PROTECT",
  };
  char *p[NITEMS];
  int c;
  int i;

  for (i = 0; i < NITEMS; ++i)
    p[i] = strings[i];

  c = gch ();
  while (1)
    {
      for (i = 0; i < NITEMS; i++)
	{
	  if (c == *(p[i]))
	    {
	      p[i]++;
	      if (*(p[i]) == 0)
		{
		  /* found one of the choices */
		  return i;
		}
	    }
	  else
	    p[i] = strings[i];
	}

      c = gch ();
    }
}

/* Suck characters, if a string match, then return the strings index
   otherwise echo them.  */

static int
expect_n (char **strings)
{
  char *(ptr[10]);
  int n;
  int c;
  char saveaway[100];
  char *buffer = saveaway;
  /* Count number of expect strings  */

  for (n = 0; strings[n]; n++)
    {
      ptr[n] = strings[n];
    }

  while (1)
    {
      int i;
      int gotone = 0;

      c = readchar (1);
      if (c == -1)
	{
	  printf_unfiltered ("[waiting for e7000...]\n");
	}
#ifdef __GO32__
      if (kbhit ())
	{
	  int k = getkey ();

	  if (k == 1)
	    quit_flag = 1;
	}
#endif
      if (quit_flag)
	{
	  putchar_e7000 (CTRLC);	/* interrupt the running program */
	  quit_flag = 0;
	}

      for (i = 0; i < n; i++)
	{
	  if (c == ptr[i][0])
	    {
	      ptr[i]++;
	      if (ptr[i][0] == 0)
		{
		  /* Gone all the way */
		  return i;
		}
	      gotone = 1;
	    }
	  else
	    {
	      ptr[i] = strings[i];
	    }
	}

      if (gotone)
	{
	  /* Save it up incase we find that there was no match */
	  *buffer++ = c;
	}
      else
	{
	  if (buffer != saveaway)
	    {
	      *buffer++ = 0;
	      printf_unfiltered ("%s", buffer);
	      buffer = saveaway;
	    }
	  if (c != -1)
	    {
	      putchar_unfiltered (c);
	      gdb_flush (gdb_stdout);
	    }
	}
    }
}

/* We subtract two from the pc here rather than use
   DECR_PC_AFTER_BREAK since the e7000 doesn't always add two to the
   pc, and the simulators never do. */

static void
sub2_from_pc (void)
{
  char buf[4];
  char buf2[200];

  store_signed_integer (buf,
			register_size (current_gdbarch, PC_REGNUM),
			read_register (PC_REGNUM) - 2);
  regcache_raw_supply (current_regcache, PC_REGNUM, buf);
  sprintf (buf2, ".PC %s\r", phex_nz (read_register (PC_REGNUM), 0));
  puts_e7000debug (buf2);
}

#define WAS_SLEEP 0
#define WAS_INT 1
#define WAS_RUNNING 2
#define WAS_OTHER 3

static char *estrings[] =
{
  "** SLEEP",
  "BREAK !",
  "** PC",
  "PC",
  NULL
};

/* Wait until the remote machine stops, then return, storing status in
   STATUS just as `wait' would.  */

static ptid_t
e7000_wait (ptid_t ptid, struct target_waitstatus *status)
{
  int stop_reason;
  int regno;
  int running_count = 0;
  int had_sleep = 0;
  int loop = 1;
  char *wanted_nopc = NULL;
  int realregs = 0;

  /* Then echo chars until PC= string seen */
  gch ();			/* Drop cr */
  gch ();			/* and space */

  while (loop)
    {
      switch (expect_n (estrings))
	{
	case WAS_OTHER:
	  /* how did this happen ? */
	  loop = 0;
	  break;
	case WAS_SLEEP:
	  had_sleep = 1;
	  putchar_e7000 (CTRLC);
	  loop = 0;
	  break;
	case WAS_INT:
	  loop = 0;
	  break;
	case WAS_RUNNING:
	  running_count++;
	  if (running_count == 20)
	    {
	      printf_unfiltered ("[running...]\n");
	      running_count = 0;
	    }
	  break;
	default:
	  /* error? */
	  break;
	}
    }

  /* Skip till the PC= */
  expect ("=");

  if (TARGET_ARCHITECTURE->arch == bfd_arch_sh)
    {
      wanted_nopc = want_nopc_sh;
      realregs = 59;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_sh3:
	case bfd_mach_sh3e:
	case bfd_mach_sh4:
	  wanted_nopc = want_nopc_sh3;
	}
    }
  if (TARGET_ARCHITECTURE->arch == bfd_arch_h8300)
    {
      wanted_nopc = want_nopc_h8300h;
      realregs = 10;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_h8300s:
	case bfd_mach_h8300sn:
	case bfd_mach_h8300sx:
	case bfd_mach_h8300sxn:
	  wanted_nopc = want_nopc_h8300s;
	  realregs = 11;
	}
    }
  fetch_regs_from_dump (gch, wanted_nopc);

  /* And supply the extra ones the simulator uses */
  for (regno = realregs; regno < NUM_REGS; regno++)
    {
      int buf = 0;
      regcache_raw_supply (current_regcache, regno, (char *) &buf);
    }

  stop_reason = why_stop ();
  expect_full_prompt ();

  status->kind = TARGET_WAITKIND_STOPPED;
  status->value.sig = TARGET_SIGNAL_TRAP;

  switch (stop_reason)
    {
    case 1:			/* Breakpoint */
      write_pc (read_pc ());	/* PC is always off by 2 for breakpoints */
      status->value.sig = TARGET_SIGNAL_TRAP;
      break;
    case 0:			/* Single step */
      status->value.sig = TARGET_SIGNAL_TRAP;
      break;
    case 2:			/* Interrupt */
      if (had_sleep)
	{
	  status->value.sig = TARGET_SIGNAL_TRAP;
	  sub2_from_pc ();
	}
      else
	{
	  status->value.sig = TARGET_SIGNAL_INT;
	}
      break;
    case 3:
      break;
    case 4:
      printf_unfiltered ("a cycle address error?\n");
      status->value.sig = TARGET_SIGNAL_UNKNOWN;
      break;
    case 5:
      status->value.sig = TARGET_SIGNAL_ILL;
      break;
    case 6:
      status->value.sig = TARGET_SIGNAL_SEGV;
      break;
    case 7:			/* Anything else (NITEMS + 1) */
      printf_unfiltered ("a write protect error?\n");
      status->value.sig = TARGET_SIGNAL_UNKNOWN;
      break;
    default:
      /* Get the user's attention - this should never happen. */
      internal_error (__FILE__, __LINE__, _("failed internal consistency check"));
    }

  return inferior_ptid;
}

/* Stop the running program.  */

static void
e7000_stop (void)
{
  /* Sending a ^C is supposed to stop the running program.  */
  putchar_e7000 (CTRLC);
}

/* Define the target subroutine names. */

struct target_ops e7000_ops;

static void
init_e7000_ops (void)
{
  e7000_ops.to_shortname = "e7000";
  e7000_ops.to_longname = "Remote Renesas e7000 target";
  e7000_ops.to_doc = "Use a remote Renesas e7000 ICE connected by a serial line;\n\
or a network connection.\n\
Arguments are the name of the device for the serial line,\n\
the speed to connect at in bits per second.\n\
eg\n\
target e7000 /dev/ttya 9600\n\
target e7000 foobar";
  e7000_ops.to_open = e7000_open;
  e7000_ops.to_close = e7000_close;
  e7000_ops.to_detach = e7000_detach;
  e7000_ops.to_resume = e7000_resume;
  e7000_ops.to_wait = e7000_wait;
  e7000_ops.to_fetch_registers = e7000_fetch_register;
  e7000_ops.to_store_registers = e7000_store_register;
  e7000_ops.to_prepare_to_store = e7000_prepare_to_store;
  e7000_ops.deprecated_xfer_memory = e7000_xfer_inferior_memory;
  e7000_ops.to_files_info = e7000_files_info;
  e7000_ops.to_insert_breakpoint = e7000_insert_breakpoint;
  e7000_ops.to_remove_breakpoint = e7000_remove_breakpoint;
  e7000_ops.to_kill = e7000_kill;
  e7000_ops.to_load = e7000_load;
  e7000_ops.to_create_inferior = e7000_create_inferior;
  e7000_ops.to_mourn_inferior = e7000_mourn_inferior;
  e7000_ops.to_stop = e7000_stop;
  e7000_ops.to_stratum = process_stratum;
  e7000_ops.to_has_all_memory = 1;
  e7000_ops.to_has_memory = 1;
  e7000_ops.to_has_stack = 1;
  e7000_ops.to_has_registers = 1;
  e7000_ops.to_has_execution = 1;
  e7000_ops.to_magic = OPS_MAGIC;
};

extern initialize_file_ftype _initialize_remote_e7000; /* -Wmissing-prototypes */

void
_initialize_remote_e7000 (void)
{
  init_e7000_ops ();
  add_target (&e7000_ops);

  add_com ("e7000", class_obscure, e7000_command,
	   _("Send a command to the e7000 monitor."));

  add_com ("ftplogin", class_obscure, e7000_login_command,
	   _("Login to machine and change to directory."));

  add_com ("ftpload", class_obscure, e7000_ftp_command,
	   _("Fetch and load a file from previously described place."));

  add_com ("drain", class_obscure, e7000_drain_command,
	   _("Drain pending e7000 text buffers."));

  add_setshow_integer_cmd ("usehardbreakpoints", no_class,
			   &use_hard_breakpoints, _("\
Set use of hardware breakpoints for all breakpoints."), _("\
Show use of hardware breakpoints for all breakpoints."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);
}
@


1.60
log
@	* frame.c (frame_pop, frame_observer_target_changed): Call
	reinit_frame_cache.
	(flush_cached_frames): Rename to reinit_frame_cache and delete
	old implementation.
	* frame.h (flush_cached_frames): Delete prototype and update comment.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Call
	reinit_frame_cache instead of flush_cached_frames.  Do not call
	select_frame after reinit_frame_cache.
	* corelow.c (core_open): Likewise.
	* gdbarch.sh (deprecated_current_gdbarch_select_hack): Likewise.
	* infrun.c (prepare_to_proceed, context_switch)
	(handle_inferior_event): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* ocd.c (ocd_start_remote): Likewise.
	* remote-e7000.c (e7000_start_remote): Likewise.
	* remote-mips.c (device): Likewise.
	* thread.c (switch_to_thread): Likewise.
	* tracepoint.c (finish_tfind_command): Likewise.
	* gdbarch.c: Regenerated.
@
text
@@


1.59
log
@Copyright updates for 2007.
@
text
@d631 1
a631 1
  flush_cached_frames ();
@


1.58
log
@gdb/
	* breakpoint.c (deprecated_read_memory_nobpt): Update to use
	shadow_len.
	(insert_bp_location, reattach_breakpoints, remove_breakpoint)
	(delete_breakpoint): Update calls to changed methods.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(single_step_breakpoints, insert_single_step_breakpoint)
	(remove_single_step_breakpoints): New.
	* breakpoint.h (struct bp_target_info): New.
	(struct bp_location): Replace shadow_contents with
	target_info and overlay_target_info.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(insert_single_step_breakpoint, remove_single_step_breakpoints): New
	prototypes.
	* gdbarch.sh: Forward declare struct bp_target_info in gdbarch.h.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update second
	argument.
	* mem-break.c (default_memory_insert_breakpoint): Update.  Set
	placed_address, placed_size, and shadow_len.
	(default_memory_remove_breakpoint): Update.  Don't use
	BREAKPOINT_FROM_PC.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update.
	* target.c (update_current_target): Update prototypes for changed
	functions.
	(debug_to_insert_breakpoint, debug_to_remove_breakpoint)
	(debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint):
	Update.
	* target.h: Forward declare struct bp_target_info.
	(struct target_ops): Use a bp_target_info argument for
	to_insert_breakpoint, to_remove_breakpoint,
	to_insert_hw_breakpoint, and to_remove_hw_breakpoint.
	(target_insert_breakpoint, target_remove_breakpoint)
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint)
	(memory_insert_breakpoint, memory_remove_breakpoint)
	(default_memory_insert_breakpoint, default_memory_remove_breakpoint):
	Update.
	* config/i386/nm-i386.h: Forward declare struct bp_target_info.
	(i386_insert_hw_breakpoint, i386_remove_hw_breakpoint): Update.
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint): Likewise.

	* gdbarch.c, gdbarch.h: Regenerated.

	* alpha-tdep.c (alpha_software_single_step): Use
	insert_single_step_breakpoint and remove_single_step_breakpoints.
	Remove unused statics.
	* arm-tdep.c (arm_software_single_step): Likewise.  Add a note.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* wince.c (struct thread_info_struct): Remove step_prev.
	(undoSStep): Use remove_single_step_breakpoints.
	(wince_software_single_step): Use insert_single_step_breakpoint.

	* corelow.c (ignore): Remove unneeded prototype.  Update arguments.
	* exec.c (ignore): Likewise.
	* sol-thread.c (ignore): Likewise.

	* procfs.c (dbx_link_shadow_contents): Delete.
	(dbx_link_bpt): New.
	(procfs_mourn_inferior): Remove it if necessary.
	(remove_dbx_link_breakpoint): Use it.
	(insert_dbx_link_bpt_in_file): Set it.
	(procfs_init_inferior): Don't update dbx_link_bpt_addr.
	* rs6000-nat.c (exec_one_dummy_insn): Use
	deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* solib-irix.c (shadow_contents, breakpoint_addr): Delete.
	(base_breakpoint): New.
	(disable_break): Use it.
	(enable_break): Set it.

	* i386-nat.c (i386_insert_hw_breakpoint, i386_remove_hw_breakpoint):
	Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
	* monitor.c (monitor_insert_breakpoint, monitor_remove_breakpoint):
	Likewise.  Remove unnecessary prototypes.  Use placed_address
	and placed_size.  Removed useless read from memory.
	* nto-procfs.c (procfs_insert_breakpoint)
	(procfs_remove_breakpoint, procfs_insert_hw_breakpoint)
	(procfs_remove_hw_breakpoint): Update.
	* ocd.c (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ocd.h (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Likewise.
	* remote-m32r-sdi.c (m32r_insert_breakpoint)
	(m32r_remove_breakpoint): Likewise.
	* remote-mips.c (mips_insert_breakpoint)
	(mips_remove_breakpoint): Likewise.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Likewise.
	(rdp_step): Use deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* remote-sds.c (sds_insert_breakpoint, sds_remove_breakpoint):
	Update.
	* remote-sim.c (gdbsim_insert_breakpoint, gdbsim_remove_breakpoint):
	Delete.
	(init_gdbsim_ops): Use memory_insert_breakpoint and
	memory_remove_breakpoint.
	* remote-st.c (st2000_insert_breakpoint)
	(st2000_remove_breakpoint): Update.  Remove unused
	BREAKPOINT_FROM_PC.
	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint):
	Update.  Use placed_address and placed_size.
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Likewise.
gdb/doc/
	* gdbint.texinfo (x86 Watchpoints, Target Conditionals): Update insert
	and remove breakpoint prototypes.
	(Watchpoints): Move description of target_insert_hw_breakpoint and
	target_remove_hw_breakpoint ...
	(Breakpoints): ... to here.  Document target_insert_breakpoint and
	target_remove_breakpoint.
@
text
@d3 2
a4 2
   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2006 Free Software Foundation, Inc.
@


1.57
log
@	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.

	* gnu-nat.c (gnu_create_inferior): Don't call proceed.
	* go32-nat.c (go32_create_inferior): Likewise.
	* nto-procfs.c (procfs_create_inferior): Likewise.
	* procfs.c (procfs_create_inferior): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Likewise.
	* remote.c (extended_remote_create_inferior)
	(extended_remote_async_create_inferior): Likewise.
	* win32-nat.c (win32_create_inferior): Likewise.
	* wince.c (child_create_inferior): Likewise.

	* monitor.c (monitor_create_inferior): Don't call proceed.
	Set the PC manually.
	* ocd.c (ocd_create_inferior): Likewise.
	* remote-e7000.c (e7000_create_inferior): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior): Likewise.
	* remote-mips.c (mips_create_inferior): Likewise.
	* remote-rdp.c (remote_rdp_create_inferior): Likewise.
	* remote-sds.c (sds_create_inferior): Likewise.
	* remote-st.c (st2000_create_inferior): Likewise.

	* inf-ptrace.c (inf_ptrace_create_inferior): Don't call
	proceed or observer_notify_inferior_created.
	* inf-ttrace.c (inf_ttrace_create_inferior): Likewise.
	* inftarg.c (child_create_inferior): Likewise.
@
text
@d1705 1
a1705 1
e7000_insert_breakpoint (CORE_ADDR addr, bfd_byte *shadow)
d1707 1
d1732 2
a1733 1
	e7000_read_inferior_memory (addr, shadow, 2);
d1750 1
a1750 1
e7000_remove_breakpoint (CORE_ADDR addr, bfd_byte *shadow)
d1752 1
d1779 2
a1780 1
	e7000_write_inferior_memory (addr, shadow, 2);
@


1.57.8.1
log
@Merge to branch:
  http://sourceware.org/ml/gdb-patches/2006-04/msg00139.html
@
text
@d1705 1
a1705 1
e7000_insert_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
d1731 1
a1731 1
	e7000_read_inferior_memory (addr, bpt->shadow_contents, 2);
d1748 1
a1748 1
e7000_remove_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
d1776 1
a1776 1
	e7000_write_inferior_memory (addr, bpt->shadow_contents, 2);
@


1.56
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d4 1
a4 1
   2002, 2003, 2004 Free Software Foundation, Inc.
d408 1
a408 1
  proceed ((CORE_ADDR) entry_pt, -1, 0);	/* Let 'er rip... */
@


1.55
log
@2005-11-02  Andrew Stubbs  <andrew.stubbs@@st.com>

	* monitor.c (monitor_xfer_memory): Change char to gdb_byte.
	(monitor_insert_breakpoint): Likewise.
	(monitor_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Change void to gdb_byte.
	(sh_return_value_fpu): Likewise.
	(sh_pseudo_register_read): Likewise.
	(sh_pseudo_register_write): Likewise.
	(sh_frame_prev_register): Likewise.
	* sh64-tdep.c (sh64_extract_return_value): Change char to gdb_byte.
	(sh64_return_value): Change void to gdb_byte.
	(sh64_pseudo_register_read): Likewise.
	(sh64_pseudo_register_write): Likewise.
	(sh64_frame_prev_register): Likewise.
@
text
@d3 1
a3 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
d24 2
a25 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.55.2.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d408 1
a408 1
  write_pc ((CORE_ADDR) entry_pt);
@


1.54
log
@2005-05-01  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_extract_return_value)
	(breakpoint_from_pc, deprecated_store_return_value)
	(memory_insert_breakpoint, memory_remove_breakpoint): Change type
	of buffer to a bfd_byte pointer.
	* gdbarch.h, gdbarch.c: Re-generate.
	* mem-break.c (memory_insert_breakpoint)
	(memory_remove_breakpoint, default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Update.
	* target.h (memory_insert_breakpoint)
	(memory_remove_breakpoint, default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Update declarations.
	(struct target_ops): Update to_insert_breakpoint and
	to_remove_breakpoint.
	* target.c (debug_to_remove_breakpoint)
	(debug_to_insert_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_remove_breakpoint)
	(m32r_insert_breakpoint): Update.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Update.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Update.
	* remote-rdi.c (arm_rdi_insert_breakpoint)
	(arm_rdi_remove_breakpoint): Update.
	* remote-sim.c (gdbsim_insert_breakpoint)
	(gdbsim_remove_breakpoint): Update.
	* exec.c (ignore): Update.
	* rs6000-tdep.c (rs6000_extract_return_value): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Update.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Update.
@
text
@d1481 1
a1481 1
e7000_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len,
@


1.54.4.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d408 1
a408 1
  write_pc ((CORE_ADDR) entry_pt);
@


1.53
log
@2005-02-21  Andrew Cagney  <cagney@@gnu.org>

	Add more uses of add_setshow_string_cmd, add_setshow_integer_cmd,
	and add_setshow_string_noescape_cmd.
	* cli/cli-setshow.c (deprecated_show_value_hack): Do not print a
	NULL command's value.
	* kod.c, language.c, ocd.c, remote-e7000.c, remote-mips.c: Update.
	* remote-sds.c, remote.c, symfile.c, top.c: Update.
@
text
@d1705 1
a1705 1
e7000_insert_breakpoint (CORE_ADDR addr, char *shadow)
d1748 1
a1748 1
e7000_remove_breakpoint (CORE_ADDR addr, char *shadow)
@


1.52
log
@* remote-e7000.c: unuse TM_FILE defined macro.
(e7000_fetch_registers)
(e7000_store_registers)
(e7000_wait): delete NUM_REALREGS.
* remote-hms.c: move TM_FILE macro.
(CCR_REGNO): move define from tm-h8300.h.
@
text
@d2210 7
a2216 5
  deprecated_add_show_from_set
    (add_set_cmd ("usehardbreakpoints", no_class,
		  var_integer, (char *) &use_hard_breakpoints, "\
Set use of hardware breakpoints for all breakpoints.\n", &setlist),
     &showlist);
@


1.51
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d896 1
d903 1
d915 1
d923 1
d930 1
a930 1
  for (regno = NUM_REALREGS; regno < NUM_REGS; regno++)
d953 1
d955 10
a964 1
  for (regno = 0; regno < NUM_REALREGS; regno++)
d2015 1
d2057 1
d2069 1
d2077 1
d2083 1
a2083 1
  for (regno = NUM_REALREGS; regno < NUM_REGS; regno++)
@


1.50
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d2181 1
a2181 1
	   "Send a command to the e7000 monitor.");
d2184 1
a2184 1
	   "Login to machine and change to directory.");
d2187 1
a2187 1
	   "Fetch and load a file from previously described place.");
d2190 1
a2190 1
	   "Drain pending e7000 text buffers.");
@


1.49
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d791 1
a791 1
    internal_error (__FILE__, __LINE__, "Register set not selected.");
d880 1
a880 1
		internal_error (__FILE__, __LINE__, "failed internal consistency check");
d2115 1
a2115 1
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
@


1.48
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d155 1
a155 1
    error ("Use \"target e7000 ...\" first.");
d213 1
a213 1
      error ("Timeout reading from remote system.");
d216 1
a216 1
    error ("Serial communication error");
d381 1
a381 1
    error ("Can't pass arguments to remote E7000DEBUG process");
d384 1
a384 1
    error ("No executable file specified");
d463 1
a463 1
      error ("Syntax is ftplogin <machine> <user> <passwd> <directory>");
d527 1
a527 1
	  error ("Bad arguments.  Usage:\ttarget e7000 <device> <speed>\n\
d530 1
a530 1
or \t\ttarget e7000 pc\n");
d617 1
a617 1
      error ("Unable to synchronize with target.\n");
d829 1
a829 1
	      error ("out of sync in fetch registers wanted <%s>, got <%c 0x%x>",
d1184 1
a1184 1
	  error ("Error writing memory");
d1393 1
a1393 1
      error ("Memory read error");
d1539 1
a1539 1
	error ("unknown option `%s'", arg);
d1554 1
a1554 1
    error ("\"%s\" is not an object file: %s", filename,
d1728 1
a1728 1
  error ("Too many breakpoints ( > %d) for the E7000\n",
d1769 1
a1769 1
  warning ("Can't find breakpoint associated with 0x%s\n", paddr_nz (addr));
d1785 1
a1785 1
    error ("e7000 target not open.");
@


1.47
log
@2004-10-29  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (get_selected_frame): Add message parameter.
	* frame.c (get_selected_frame): Add and use message parameter.
	* stack.c (current_frame_command, return_command, locals_info)
	(catch_info, args_info, up_silently_base, down_silently_base): Use
	get_selected_frame with an explicit message.
	* thread.c, stack.c, sh-tdep.c, sh64-tdep.c: Update.
	* remote-rdp.c, remote-mips.c, remote-e7000.c: Update.
	* ocd.c, mi/mi-main.c, mi/mi-cmd-stack.c: Update.
	* infrun.c, inflow.c, infcmd.c, frame.c: Update.
	* findvar.c, eval.c, corelow.c, bsd-kvm.c: Update.
	* breakpoint.c: Update.
@
text
@d46 1
@


1.46
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@d633 1
a633 1
  print_stack_frame (get_selected_frame (), 0, SRC_AND_LOC);
@


1.45
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d2153 1
a2153 1
  e7000_ops.to_xfer_memory = e7000_xfer_inferior_memory;
@


1.44
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d882 1
a882 1
				DEPRECATED_REGISTER_RAW_SIZE (regno),
d1967 1
a1967 1
			DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM),
@


1.43
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d2191 5
a2195 4
  add_show_from_set (add_set_cmd ("usehardbreakpoints", no_class,
				var_integer, (char *) &use_hard_breakpoints,
	"Set use of hardware breakpoints for all breakpoints.\n", &setlist),
		     &showlist);
@


1.42
log
@	* dsrec.c (load_srec, make_srec): Use bfd_get_section_size instead of
	bfd_get_section_size_before_reloc or _raw_size.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2read.c (dwarf2_locate_sections): Likewise.
	(dwarf2_read_section): Likewise.
	* elfread.c (elf_locate_sections): Likewise.
	* gcore.c (derive_heap_segment): Likewise.
	* mipsread.c (read_alphacoff_dynamic_symtab): Likewise.
	* remote-e7000.c (e7000_load): Likewise.
	* remote-m32r-sdi.c (m32r_load): Likewise.
	* remote-mips.c (mips_load_srec): Likewise.
	(pmon_load_fast): Likewise.
	* remote.c (compare_sections_command): Likewise.
	* symfile.c (add_section_size_callback): Likewise.
	(load_section_callback): Likewise.
	(pc_in_unmapped_range): Likewise.
	(pc_in_mapped_range): Likewise.
	(sections_overlap): Likewise.
	(list_overlays_command): Likewise.
	(simple_overlay_update_1): Likewise.
	(simple_overlay_update): Likewise.
	* tracepoint.c (remote_set_transparent_ranges): Likewise.
	* win32-nat.c (core_section_load_dll_symbols): Likewise.
@
text
@d365 1
a365 1
      supply_register (regno++, (char *) &val);
d884 1
a884 1
	  supply_register (regno, buf);
d929 1
a929 1
      supply_register (regno, (char *) (&buf));
d1969 1
a1969 1
  supply_register (PC_REGNUM, buf);
d2067 1
a2067 1
      supply_register (regno, (char *) &buf);
@


1.41
log
@2004-05-25  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Add from_tty to
	to_create_inferior.
	(target_create_inferior, find_default_create_inferior): Update.
	* infcmd.c (run_command): Update.
	* wince.c (child_create_inferior): Update.
	* win32-nat.c (child_create_inferior): Update.
	* uw-thread.c (uw_thread_create_inferior): Update.
	* thread-db.c (thread_db_create_inferior): Update.
	* target.c (debug_to_create_inferior)
	(find_default_create_inferior): Update.
	(maybe_kill_then_create_inferior): Update.
	* sol-thread.c (sol_thread_create_inferior): Update.
	* remote.c (extended_remote_async_create_inferior)
	(extended_remote_create_inferior): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* remote-st.c (st2000_create_inferior): Update.
	* remote-sim.c (gdbsim_create_inferior): Update.
	* remote-sds.c (sds_create_inferior): Update.
	* remote-rdp.c (remote_rdp_create_inferior): Update.
	* remote-rdi.c (arm_rdi_create_inferior): Update.
	* remote-m32r-sdi.c (m32r_create_inferior): Update.
	* remote-e7000.c (e7000_create_inferior): Update.
	* procfs.c (procfs_create_inferior): Update.
	* ocd.c (ocd_create_inferior): Update.
	* ocd.h (ocd_create_inferior): Update.
	* nto-procfs.c (procfs_create_inferior): Update.
	* monitor.c (monitor_create_inferior): Update.
	* lin-lwp.c (lin_lwp_create_inferior): Update.
	* inftarg.c (child_create_inferior): Update.
	* hpux-thread.c (hpux_thread_create_inferior): Update.
	* gnu-nat.c (gnu_create_inferior): Update.
@
text
@d4 1
a4 1
   2002, 2003 Free Software Foundation, Inc.
d1572 1
a1572 1
	  section_size = bfd_get_section_size_before_reloc (section);
@


1.40
log
@2004-04-28  Andrew Cagney  <cagney@@redhat.com>

	* stack.c (print_stack_frame_stub): Delete declaration.
	(struct print_stack_frame_args, print_stack_frame)
	(print_frame_info, print_frame): Replace "source" with print what.
	Replace "print" with "print_level".  Replace "args" with
	"print_args".
	* frame.h (show_and_print_stack_frame, print_stack_frame)
	(print_frame_info): Update declarations.
	* stack.c (select_and_print_frame, frame_command)
	(current_frame_command, up_command, down_command): Update calls -
	use get_selected_frame, pass "enum print_what" for source, do not
	call frame_relative_level.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames): Ditto.
	* remote-rdp.c (remote_rdp_open): Ditto.
	* remote-mips.c (common_open): Ditto.
	* remote-e7000.c (e7000_start_remote): Ditto.
	* ocd.c (ocd_start_remote): Ditto.
	* mi/mi-main.c (mi_cmd_exec_return): Ditto.
	* infrun.c (normal_stop): Ditto.
	* inflow.c (kill_command): Ditto.
	* infcmd.c (finish_command): Ditto.
	* corelow.c (core_open): Ditto.
	* tracepoint.c (finish_tfind_command): Ditto.
	* thread.c (info_threads_command, info_threads_command)
	(restore_current_thread, do_captured_thread_select): Ditto.
	* ada-tasks.c (task_command): Ditto.
@
text
@d374 2
a375 1
e7000_create_inferior (char *execfile, char *args, char **env)
@


1.39
log
@ Fix GDB crash problem when object file of different H8 cpu is loaded
@
text
@d632 1
a632 1
  print_stack_frame (get_selected_frame (), -1, 1);
@


1.39.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d4 1
a4 1
   2002, 2003, 2004 Free Software Foundation, Inc.
d365 1
a365 1
      regcache_raw_supply (current_regcache, regno++, (char *) &val);
d374 1
a374 2
e7000_create_inferior (char *execfile, char *args, char **env,
		       int from_tty)
d632 1
a632 1
  print_stack_frame (get_selected_frame (), 0, SRC_AND_LOC);
d881 1
a881 1
				register_size (current_gdbarch, regno),
d883 1
a883 1
	  regcache_raw_supply (current_regcache, regno, buf);
d928 1
a928 1
      regcache_raw_supply (current_regcache, regno, (char *) (&buf));
d1571 1
a1571 1
	  section_size = bfd_get_section_size (section);
d1966 1
a1966 1
			register_size (current_gdbarch, PC_REGNUM),
d1968 1
a1968 1
  regcache_raw_supply (current_regcache, PC_REGNUM, buf);
d2066 1
a2066 1
      regcache_raw_supply (current_regcache, regno, (char *) &buf);
d2190 4
a2193 5
  deprecated_add_show_from_set
    (add_set_cmd ("usehardbreakpoints", no_class,
		  var_integer, (char *) &use_hard_breakpoints, "\
Set use of hardware breakpoints for all breakpoints.\n", &setlist),
     &showlist);
@


1.38
log
@2003-10-10  Kei Sakamoto  <sakamoto.kei@@renesas.com>

	* NEWS: Replace "Hitachi" and "Mitsubishi" with "Renesas".
	* README: Ditto.
	* d10v-tdep.c: Ditto.
	* h8300-tdep.c: Ditto.
	* remote-e7000.c: Ditto.
	* remote-hms.c: Ditto.
	* ser-e7kpc.c: Ditto.
	* sh-stub.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* sh3-rom.c: Ditto.
	* sh64-tdep.c: Ditto.
	* top.c: Ditto.
	* wince.c: Ditto.
	* config/d10v/d10v.mt: Ditto.
	* config/sh/embed.mt: Ditto.
	* config/sh/linux.mt: Ditto.
	* config/sh/tm-linux.h: Ditto.
	* config/sh/tm-sh.h: Ditto.
	* config/sh/wince.mt: Ditto.
@
text
@a659 4
#ifdef GDB_TARGET_IS_H8300
  h8300hmode = 1;
#endif

a907 1
#ifdef GDB_TARGET_IS_H8300
d910 9
a918 4
      if (h8300smode)
	wanted = want_h8300s;
      else
	wanted = want_h8300h;
a919 1
#endif
a2047 1
#ifdef GDB_TARGET_IS_H8300
d2050 9
a2058 4
      if (h8300smode)
	wanted_nopc = want_nopc_h8300s;
      else
	wanted_nopc = want_nopc_h8300h;
a2059 1
#endif
@


1.37
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d1 1
a1 1
/* Remote debugging interface for Hitachi E7000 ICE, for GDB
d27 2
a28 2
/* The E7000 is an in-circuit emulator for the Hitachi H8/300-H and
   Hitachi-SH processor.  It has serial port and a lan port.  
d2134 2
a2135 2
  e7000_ops.to_longname = "Remote Hitachi e7000 target";
  e7000_ops.to_doc = "Use a remote Hitachi e7000 ICE connected by a serial line;\n\
@


1.36
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_push_return_address): Make static.
	(xstormy16_save_dummy_frame_tos): Make static.
	(_initialize_xstormy16_tdep): Add declaration.
	* vax-tdep.c (_initialize_vax_tdep): Add declaration.
	* v850-tdep.c: Make local functions static.
	(_initialize_v850_tdep): Add declaration.
	* sparc-tdep.c: Make local functions static.
	(_initialize_sparc_tdep): Add declaration.
	* sh-tdep.c: Make local functions static.
	(_initialize_sh_tdep): Add declaration.
	* sh3-rom.c (_initialize_sh3_rom): Add declaration.
	* s390-tdep.c: Make local functions static.
	(_initialize_s390_tdep): Add declaration.
	* dbxread.c (find_stab_function_addr): Make static.
	* ppc-bdm.c (_initialize_bdm_ppc): Add declaration.
	* ocd.c (_initialize_remote_ocd): Add declaration.
	* dink32-rom.c (_initialize_dink32_rom): Add declaration.
	* ppcbug-rom.c (_initialize_ppcbug_rom): Add declaration.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Add declaration.
	* ns32knbsd-tdep.c (_initialize_ns32knbsd_tdep): Add declaration.
	* mips-tdep.c (_initialize_mips_tdep): Add declaration.
	* remote-array.c (_initialize_array): Add declaration.
	(_initialize_remote_monitors): Add declaration.
	* remote-mips.c: Make local functions static.
	(_initialize_remote_mips): Add declaration.
	* mcore-tdep.c: Make all local functions static.
	(_initialize_mcore_tdep): Add declaration.
	* dbug-rom.c (_initialize_dbug_rom): Add declaration.
	* abug-rom.c (_initialize_abug_rom): Add declaration.
	* rom68k-rom.c (_initialize_rom68k): Add declaration.
	* cpu32bug-rom.c (_initialize_cpu32bug_rom): Add declaration.
	* m68k-tdep.c (_initialize_m68k_tdep): Add declaration.
	* remote-est.c (_initialize_est): Add declaration.
	* m68hc11-tdep.c (_initialize_m68hc11_tdep): Add declaration.
	(m68hc11_call_dummy_address): Make static.
	* ia64-tdep.c: Make local functions static.
	(_initialize_ia64_tdep): Add declaration.
	* solib-legacy.c (_initialize_svr4_lm): Add declaration.
	* monitor.c (monitor_wait_filter): Make static.
	(_initialize_remote_monitors): Add declaration.
	* remote-hms.c (_initialize_remote_hms): Add declaration.
	* remote-e7000.c (fetch_regs_from_dump): Make static.
	(expect_n): Make static.
	(_initialize_remote_e7000): Add declaration.
	* ser-e7kpc.c: Always include "defs.h".
	(_initialize_ser_e7000pc): Add declaration.
	* h8300-tdep.c (_initialize_h8300_tdep): Add declaration.
	* cris-tdep.c: Make all but one function static.
	(_initialize_cris_tdep): Add declaration.
	* solib-svr4.c (_initialize_svr4_solib): Add declaration.
	* solib.c (update_solib_list): Make static.
	(_initialize_solib): Add declaration.
	* avr-tdep.c (avr_breakpoint_from_pc): Make static.
	(_initialize_avr_tdep): Add declaration.
	* remote-rdi.c (voiddummy): Make static.
	(_initialize_remote_rdi): Add declaration.
	* arm-tdep.c (_initialize_arm_tdep): Add declaration.
	* remote-rdp.c (send_rdp): Make static.
	(_initialize_remote_rdp): Add declaration.
	* alpha-tdep.c (_initialize_alpha_tdep): Add declaration.
@
text
@d885 1
a885 1
				REGISTER_RAW_SIZE (regno),
d1967 1
a1967 1
			REGISTER_RAW_SIZE (PC_REGNUM),
@


1.35
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (max_register_size): Delete declaration.
	* regcache.c (max_register_size): Delete function.
	(struct regcache_descr): Delete field "max_register_size".
	(init_regcache_descr, init_legacy_regcache_descr): Assert that all
	registers fit in MAX_REGISTER_SIZE.
	(regcache_save): Replace max_register_size with MAX_REGISTER_SIZE.
	(regcache_restore, regcache_xfer_part, regcache_dump): Ditto.
	* thread-db.c: Replace max_register_size with MAX_REGISTER_SIZE.
	* sh-tdep.c, rom68k-rom.c, remote-sim.c, remote-mips.c: Ditto.
	* remote-e7000.c, monitor.c, mipsv4-nat.c, mips-nat.c: Ditto.
	* m68klinux-nat.c, lynx-nat.c, irix4-nat.c: Ditto.
	* hpux-thread.c, hppah-nat.c, hppab-nat.c, hppa-tdep.c: Ditto.
	* dve3900-rom.c, hppa-tdep.c: Ditto.
@
text
@d784 1
a784 1
void
d1876 1
a1876 1
int
d2167 2
@


1.34
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d788 1
a788 1
  char *buf = alloca (max_register_size (current_gdbarch));
@


1.33
log
@Checked in as obvious fixes.  Also updated FSF copyright year to 2003
for remote-e7000.c and infttrace.c.

	2003-02-05  Fred Fish  <fnf@@intrinsity.com>
	* remote-e7000.c (e7000_drain_command): Fix precedence problem with
	'=' and '!='.
	* rdi-share/ardi.c (wait_for_debug_message): Fix precedence problem
	with '&' and '=='.
	(angel_RDI_info): Ditto.
	* infttrace.c (threads_continue_all_but_one): Fix precedence problem
	with '&' and '!='.
	(threads_continue_all_with_signals): Ditto.
@
text
@d859 1
a859 1
#ifdef FP_REGNUM
d861 1
a861 1
	      regno = FP_REGNUM;
@


1.33.16.1
log
@Merge from mainline.
@
text
@d859 1
a859 1
#ifdef DEPRECATED_FP_REGNUM
d861 1
a861 1
	      regno = DEPRECATED_FP_REGNUM;
@


1.33.16.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d788 1
a788 1
  char buf[MAX_REGISTER_SIZE];
@


1.32
log
@2003-02-02  Andrew Cagney  <ac131313@@redhat.com>

	* mips-nat.c (zerobuf): Delete.
	(fetch_inferior_registers): Alloc local zerobuf.
	(fetch_core_registers): Alloc local zerobuf.
	* d10v-tdep.c (show_regs): Don't allocate a dynamic array using
	MAX_REGISTER_RAW_SIZE or MAX_REGISTER_VIRTUAL_SIZE.
	* thread-db.c (thread_db_store_registers): Ditto.
	* sh-tdep.c (sh_do_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote-sim.c (gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* monitor.c (monitor_supply_register): Ditto.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	* m68klinux-nat.c (fetch_register): Ditto.
	* lynx-nat.c (fetch_inferior_registers): Ditto.
	(fetch_inferior_registers): Ditto.
	* irix4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (fetch_register): Ditto.
	* hppab-nat.c (fetch_register): Ditto.
	* hppa-tdep.c (pa_register_look_aside): Ditto.
	(pa_print_fp_reg, pa_strcat_fp_reg): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register): Ditto.
@
text
@d4 1
a4 1
   2002 Free Software Foundation, Inc.
d1815 1
a1815 1
  while ((c = readchar (1) != -1))
@


1.31
log
@2002-11-29  Andrew Cagney  <cagney@@redhat.com>

	* remote-mips.c (mips_initialize): Force a selected frame rebuild
	by calling get_selected_frame.
	* ocd.c (ocd_start_remote): Use get_selected frame instead of
	set_current_frame, create_new_frame, select_frame and
	get_current_frame.
	* remote-e7000.c (e7000_start_remote): Ditto.
	* remote-mips.c (common_open): Ditto
	* remote-rdp.c (remote_rdp_open): Ditto.
@
text
@d788 1
a788 1
  char buf[MAX_REGISTER_RAW_SIZE];
@


1.30
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d632 1
a632 3
  set_current_frame (create_new_frame (read_fp (), stop_pc));
  select_frame (get_current_frame ());
  print_stack_frame (deprecated_selected_frame, -1, 1);
@


1.29
log
@	* gnu-nat.c (init_gnu_ops): Remove NULL initializations.
	* monitor.c (init_base_monitor_ops): Likewise.
	* ppc-bdm.c (init_bdm_ppc_ops): Likewise.
	* remote-array.c (init_array_ops): Likewise.
	* remote-e7000.c (init_e7000_ops): Likewise.
	* remote-es.c (init_es1800_ops): Likewise.
	(init_es1800_child_ops): Likewise.
	* remote-rdp.c (init_remote_rdp_ops): Likewise.
	* remote-sim.c (init_gdbsim_ops): Likewise.
	* remote-st.c (init_st2000_ops): Likewise.
	* sol-thread.c (init_sol_core_ops): Likewise.
	(init_sol_thread_ops): Likewise.
	* v850ice.c (init_850ice_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
@
text
@d634 1
a634 1
  print_stack_frame (selected_frame, -1, 1);
@


1.28
log
@* frame.h (select_frame): Delete level parameter.
* stack.c (select_frame): Update.  Use frame_relative_level to
obtain the frame's level.
(select_and_print_frame): Update call.
(select_frame_command): Ditto.
(up_silently_base): Ditto.
(down_silently_base): Ditto.
* ocd.c (ocd_start_remote): Ditto.
* remote-rdp.c (remote_rdp_open): Ditto.
* remote-mips.c (mips_initialize): Ditto.
(common_open): Ditto.
* remote-e7000.c (e7000_start_remote): Ditto.
* m3-nat.c (select_thread): Ditto.
* hppa-tdep.c (child_get_current_exception_event): Ditto.
(child_get_current_exception_event): Ditto.
* varobj.c (varobj_create): Ditto.
(varobj_update): Ditto.
(c_value_of_root): Ditto.
* tracepoint.c (finish_tfind_command): Ditto.
* corelow.c (core_open): Ditto.
* arch-utils.c (generic_prepare_to_proceed): Ditto.
* thread.c (info_threads_command): Ditto.
(switch_to_thread): Ditto.
* infrun.c (normal_stop): Ditto.
(restore_selected_frame): Ditto.
(restore_inferior_status): Ditto.
* breakpoint.c (insert_breakpoints): Ditto.
(watchpoint_check): Ditto.
(bpstat_stop_status): Ditto.
(do_enable_breakpoint): Ditto.
* blockframe.c (flush_cached_frames): Ditto.
(reinit_frame_cache): Ditto.
@
text
@a2145 3
  e7000_ops.to_attach = 0;
  e7000_ops.to_post_attach = NULL;
  e7000_ops.to_require_attach = NULL;
a2146 1
  e7000_ops.to_require_detach = NULL;
a2148 1
  e7000_ops.to_post_wait = NULL;
a2155 5
  e7000_ops.to_terminal_init = 0;
  e7000_ops.to_terminal_inferior = 0;
  e7000_ops.to_terminal_ours_for_output = 0;
  e7000_ops.to_terminal_ours = 0;
  e7000_ops.to_terminal_info = 0;
a2157 1
  e7000_ops.to_lookup_symbol = 0;
a2158 17
  e7000_ops.to_post_startup_inferior = NULL;
  e7000_ops.to_acknowledge_created_inferior = NULL;
  e7000_ops.to_clone_and_follow_inferior = NULL;
  e7000_ops.to_post_follow_inferior_by_clone = NULL;
  e7000_ops.to_insert_fork_catchpoint = NULL;
  e7000_ops.to_remove_fork_catchpoint = NULL;
  e7000_ops.to_insert_vfork_catchpoint = NULL;
  e7000_ops.to_remove_vfork_catchpoint = NULL;
  e7000_ops.to_has_forked = NULL;
  e7000_ops.to_has_vforked = NULL;
  e7000_ops.to_can_follow_vfork_prior_to_exec = NULL;
  e7000_ops.to_post_follow_vfork = NULL;
  e7000_ops.to_insert_exec_catchpoint = NULL;
  e7000_ops.to_remove_exec_catchpoint = NULL;
  e7000_ops.to_has_execd = NULL;
  e7000_ops.to_reported_exec_events_per_exec_call = NULL;
  e7000_ops.to_has_exited = NULL;
a2159 3
  e7000_ops.to_can_run = 0;
  e7000_ops.to_notice_signals = 0;
  e7000_ops.to_thread_alive = 0;
a2160 1
  e7000_ops.to_pid_to_exec_file = NULL;
a2161 1
  e7000_ops.DONT_USE = 0;
a2166 2
  e7000_ops.to_sections = 0;
  e7000_ops.to_sections_end = 0;
@


1.28.16.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 1
a1 1
/* Remote debugging interface for Renesas E7000 ICE, for GDB
d4 1
a4 1
   2002, 2003 Free Software Foundation, Inc.
d27 2
a28 2
/* The E7000 is an in-circuit emulator for the Renesas H8/300-H and
   Renesas-SH processor.  It has serial port and a lan port.  
d632 3
a634 1
  print_stack_frame (get_selected_frame (), -1, 1);
d662 4
d786 1
a786 1
static void
d790 1
a790 1
  char buf[MAX_REGISTER_SIZE];
d861 1
a861 1
#ifdef DEPRECATED_FP_REGNUM
d863 1
a863 1
	      regno = DEPRECATED_FP_REGNUM;
d887 1
a887 1
				DEPRECATED_REGISTER_RAW_SIZE (regno),
d914 1
d917 4
a920 9
      wanted = want_h8300h;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_h8300s:
	case bfd_mach_h8300sn:
	case bfd_mach_h8300sx:
	case bfd_mach_h8300sxn:
	  wanted = want_h8300s;
	}
d922 1
d1817 1
a1817 1
  while ((c = readchar (1)) != -1)
d1878 1
a1878 1
static int
d1969 1
a1969 1
			DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM),
d2051 1
d2054 4
a2057 9
      wanted_nopc = want_nopc_h8300h;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_h8300s:
	case bfd_mach_h8300sn:
	case bfd_mach_h8300sx:
	case bfd_mach_h8300sxn:
	  wanted_nopc = want_nopc_h8300s;
	}
d2059 1
d2136 2
a2137 2
  e7000_ops.to_longname = "Remote Renesas e7000 target";
  e7000_ops.to_doc = "Use a remote Renesas e7000 ICE connected by a serial line;\n\
d2146 3
d2150 1
d2153 1
d2161 5
d2168 1
d2170 17
d2188 3
d2192 1
d2194 1
d2200 2
a2203 2

extern initialize_file_ftype _initialize_remote_e7000; /* -Wmissing-prototypes */
@


1.28.14.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d2146 3
d2150 1
d2153 1
d2161 5
d2168 1
d2170 17
d2188 3
d2192 1
d2194 1
d2200 2
@


1.28.14.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d632 3
a634 1
  print_stack_frame (get_selected_frame (), -1, 1);
@


1.28.14.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d4 1
a4 1
   2002, 2003 Free Software Foundation, Inc.
d788 1
a788 1
  char *buf = alloca (max_register_size (current_gdbarch));
d1815 1
a1815 1
  while ((c = readchar (1)) != -1)
@


1.28.14.4
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d859 1
a859 1
#ifdef DEPRECATED_FP_REGNUM
d861 1
a861 1
	      regno = DEPRECATED_FP_REGNUM;
@


1.28.14.5
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d788 1
a788 1
  char buf[MAX_REGISTER_SIZE];
@


1.28.14.6
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d784 1
a784 1
static void
d1876 1
a1876 1
static int
a2166 2

extern initialize_file_ftype _initialize_remote_e7000; /* -Wmissing-prototypes */
@


1.28.14.7
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1 1
a1 1
/* Remote debugging interface for Renesas E7000 ICE, for GDB
d27 2
a28 2
/* The E7000 is an in-circuit emulator for the Renesas H8/300-H and
   Renesas-SH processor.  It has serial port and a lan port.  
d885 1
a885 1
				DEPRECATED_REGISTER_RAW_SIZE (regno),
d1967 1
a1967 1
			DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM),
d2134 2
a2135 2
  e7000_ops.to_longname = "Remote Renesas e7000 target";
  e7000_ops.to_doc = "Use a remote Renesas e7000 ICE connected by a serial line;\n\
@


1.28.14.8
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d660 4
d912 1
d915 4
a918 9
      wanted = want_h8300h;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_h8300s:
	case bfd_mach_h8300sn:
	case bfd_mach_h8300sx:
	case bfd_mach_h8300sxn:
	  wanted = want_h8300s;
	}
d920 1
d2049 1
d2052 4
a2055 9
      wanted_nopc = want_nopc_h8300h;
      switch (TARGET_ARCHITECTURE->mach)
	{
	case bfd_mach_h8300s:
	case bfd_mach_h8300sn:
	case bfd_mach_h8300sx:
	case bfd_mach_h8300sxn:
	  wanted_nopc = want_nopc_h8300s;
	}
d2057 1
@


1.27
log
@2002-04-07  Elena Zannoni  <ezannoni@@redhat.com>

	* remote-e7000.c (write_small, e7000_read_inferior_memory,
	e7000_read_inferior_memory_large, e7000_insert_breakpoint,
	e7000_remove_breakpoint): Use paddr_nz() to print addresses.
@
text
@d633 1
a633 1
  select_frame (get_current_frame (), 0);
@


1.26
log
@Remove ATTRIBUTE_UNUSED.  Update (C).
@
text
@d1086 2
a1087 2
	  sprintf (buf, "m %lx %x%02x%02x%02x;l\r",
		   memaddr + i,
d1094 1
a1094 1
	  sprintf (buf, "m %lx %x\r", memaddr + i, myaddr[i]);
d1247 1
a1247 1
  sprintf (buf, "m %lx;l\r", memaddr);
d1326 1
a1326 1
  sprintf (buf, "d %lx %lx\r", memaddr, memaddr + len - 1);
d1708 1
a1708 1
	    sprintf (buf, "BC%d A=%lx\r", i + 1, addr);
d1713 1
a1713 1
	    sprintf (buf, "B %lx\r", addr);
d1752 1
a1752 1
	    sprintf (buf, "B - %lx\r", addr);
d1757 1
a1757 1
	sprintf (buf, "B - %lx\r", addr);
d1769 2
a1770 2

  warning ("Can't find breakpoint associated with 0x%lx\n", addr);
@


1.26.2.1
log
@2002-04-07  Elena Zannoni  <ezannoni@@redhat.com>

        * remote-e7000.c (write_small, e7000_read_inferior_memory,
        e7000_read_inferior_memory_large, e7000_insert_breakpoint,
        e7000_remove_breakpoint): Use paddr_nz() to print addresses.
@
text
@d1086 2
a1087 2
	  sprintf (buf, "m %s %x%02x%02x%02x;l\r",
		   paddr_nz (memaddr + i),
d1094 1
a1094 1
	  sprintf (buf, "m %s %x\r", paddr_nz (memaddr + i), myaddr[i]);
d1247 1
a1247 1
  sprintf (buf, "m %s;l\r", paddr_nz (memaddr));
d1326 1
a1326 1
  sprintf (buf, "d %s %s\r", paddr_nz (memaddr), paddr_nz (memaddr + len - 1));
d1708 1
a1708 1
	    sprintf (buf, "BC%d A=%s\r", i + 1, paddr_nz (addr));
d1713 1
a1713 1
	    sprintf (buf, "B %s\r", paddr_nz (addr));
d1752 1
a1752 1
	    sprintf (buf, "B - %s\r", paddr_nz (addr));
d1757 1
a1757 1
	sprintf (buf, "B - %s\r", paddr_nz (addr));
d1769 2
a1770 2
 
  warning ("Can't find breakpoint associated with 0x%s\n", paddr_nz (addr));
@


1.25
log
@* serial.h (SERIAL_ASYNC): Delete.
(DEPRECATED_SERIAL_FD): Delete.
(SERIAL_DEBUG): Delete.
(SERIAL_DEBUG_P): Delete.
(SERIAL_DRAIN_OUTPUT): Delete.
(SERIAL_FLUSH_OUTPUT): Delete.
(SERIAL_FLUSH_INPUT): Delete.
(SERIAL_SEND_BREAK): Delete.
(SERIAL_RAW): Delete.
(SERIAL_GET_TTY_STATE): Delete.
(SERIAL_SET_TTY_STATE): Delete.
(SERIAL_PRINT_TTY_STATE): Delete.
(SERIAL_NOFLUSH_SET_TTY_STATE): Delete.
(SERIAL_SETBAUDRATE): Delete.
(SERIAL_SETSTOPBITS): Delete.
(SERIAL_CAN_ASYNC_P): Delete.
(SERIAL_IS_ASYNC_P): Delete.
(SERIAL_UN_FDOPEN): Delete.
(SERIAL_READCHAR): Delete.
(SERIAL_CLOSE): Delete.
(SERIAL_FDOPEN): Delete.
(SERIAL_OPEN): Delete.
@
text
@d2 4
a5 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d1468 3
a1470 4
e7000_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr,
			    int len, int write, 
			    struct mem_attrib *attrib ATTRIBUTE_UNUSED,
			    struct target_ops *target ATTRIBUTE_UNUSED)
@


1.24
log
@2001-07-13  Elena Zannoni  <ezannoni@@redhat.com>

	* remote-e7000.c (fetch_regs_from_dump): If register set is null,
	generate an internal error.
	(e7000_fetch_registers): Initialize variable 'wanted'.
	(e7000_wait): Initialize variable 'wanted_nopc'.
	(e7000_store_register): Fix sprintf compiler warnings.
	(sub2_from_pc): Ditto.
	(e7000_open): Close the descriptor, not the name.
	(e7000_load): Fix compiler warnings.
	(sub2_from_pc): Ditto.
	* Makefile.in (remote-e7000.o): Can now compile with -Werror.
@
text
@d157 2
a158 2
  if (SERIAL_WRITE (e7000_desc, buf, strlen (buf)))
    fprintf_unfiltered (gdb_stderr, "SERIAL_WRITE failed: %s\n", safe_strerror (errno));
d173 1
a173 1
  SERIAL_WRITE (e7000_desc, b, 1);
d179 1
a179 1
  SERIAL_WRITE (e7000_desc, s, strlen (s));
d201 1
a201 1
      c = SERIAL_READCHAR (e7000_desc, timeout);
d648 1
a648 1
  e7000_desc = SERIAL_OPEN (dev_name);
d653 1
a653 1
  if (SERIAL_SETBAUDRATE (e7000_desc, baudrate))
d655 1
a655 1
      SERIAL_CLOSE (e7000_desc);
d658 1
a658 1
  SERIAL_RAW (e7000_desc);
d681 1
a681 1
      SERIAL_CLOSE (e7000_desc);
d1173 1
a1173 1
      SERIAL_WRITE (e7000_desc, compose, where);
d1607 1
a1607 1
	      if (SERIAL_WRITE (e7000_desc, buf, count + 10))
d1609 1
a1609 1
				    "e7000_load: SERIAL_WRITE failed: %s\n",
@


1.23
log
@s/typedef serial_t/struct serial */
@
text
@d655 1
a655 1
      SERIAL_CLOSE (dev_name);
d792 3
d897 1
a897 1
  char *wanted;
d972 1
a972 1
	  sprintf (buf, ".ER%d %lx\r", regno, read_register (regno));
d977 1
a977 1
	  sprintf (buf, ".PC %lx\r", read_register (regno));
d983 1
a983 1
	  sprintf (buf, ".CCR %lx\r", read_register (regno));
d993 1
a993 1
	  sprintf (buf, ".PC %lx\r", read_register (regno));
d999 1
a999 1
	  sprintf (buf, ".SR %lx\r", read_register (regno));
d1005 1
a1005 1
	  sprintf (buf, ".PR %lx\r", read_register (regno));
d1011 1
a1011 1
	  sprintf (buf, ".GBR %lx\r", read_register (regno));
d1017 1
a1017 1
	  sprintf (buf, ".VBR %lx\r", read_register (regno));
d1023 1
a1023 1
	  sprintf (buf, ".MACH %lx\r", read_register (regno));
d1029 1
a1029 1
	  sprintf (buf, ".MACL %lx\r", read_register (regno));
d1034 1
a1034 1
	  sprintf (buf, ".R%d %lx\r", regno, read_register (regno));
d1576 1
a1576 1
	    printf_filtered ("[Loading section %s at 0x%x (%ud bytes)]\n",
d1578 2
a1579 2
			     section_address,
			     section_size);
d1653 1
a1653 1
	printf_unfiltered ("[Starting %s at 0x%x]\n", filename, entry);
d1971 1
a1971 1
  sprintf (buf2, ".PC %lx\r", read_register (PC_REGNUM));
d2000 1
a2000 1
  char *wanted_nopc;
@


1.22
log
@* gnu-regex.c: Eliminate obsolete check for _MSC_VER.
* utils.c (notice_quit): Remove dummy function only used for _MSC_VER.
* values.c (unpack_double): Remove obsolete check for _MSC_VER.
* defs.h: Ditto.
* m32r-rom.c: Ditto.
* p-exp.y: Ditto.
* ser-e7kpc.c: Ditto.  Define WIN32_LEAN_AND_MEAN under _WIN32, for faster
compilation.
(get_ds_base): Remove _MSC_VER version of this function.
* nindy-share/ttyflush.c: Ditto.  X
* rdi-share/host.h: Ditto.  X
* ser-go32.c (dos_readchar): Remove call to obsolete function.
* remote-sim.c (gdb_os_poll_quit): Ditto.
* remote-e7000.c (expect): Remove obsolete #if 0'ed code.
* main.c (captured_main): Eliminate special Cygwin checks.
* ser-tcp.c: Remove unneeded __CYGWIN__ guard against system include.
@
text
@d118 1
a118 1
static serial_t e7000_desc;
@


1.21
log
@2001-05-12  Fernando Nasser  <fnasser@@redhat.com>

	* remote-e7000.c (e7000_open): Check for bad baud rate.
	* remote-st.c (st2000_open): Ditto.
@
text
@a88 2
extern void notice_quit (void);

a260 15
#if 0
      notice_quit ();
      if (quit_flag == 1)
	{
	  if (ctrl_c)
	    {
	      putchar_e7000 (CTRLC);
	      --ctrl_c;
	    }
	  else
	    {
	      quit ();
	    }
	}
#endif
@


1.20
log
@Phase 1 of the ptid_t changes.
@
text
@d670 5
a674 1
  SERIAL_SETBAUDRATE (e7000_desc, baudrate);
@


1.19
log
@* target.h (target_ops): Removed to_core_file_to_sym_file vector
function.
* corelow.c (core_ops): Updated for above change.
* gnu-nat.c (core_ops): Likewise.
* inftarg.c (child_ops): Likewise.
* monitor.c (monitor_ops): Likewise.
* ppc-bdm.c (bdm_ppc_ops): Likewise.
* remote-adapt.c (adapt_ops): Likewise.
* remote-bug.c (bug_ops): Likewise.
* remote-e7000.c (e7000_ops): Likewise.
* remote-eb.c (eb_ops): Likewise.
* remote-es.c (es1800_ops, es1800_child_ops): Likewise.
* remote-mm.c (mm_ops): Likewise.
* remote-nindy.c (nindy_ops): Likewise.
* remote-nrom.c (nrom_ops): Likewise.
* remote-os9k.c (rombug_ops): Likewise.
* remote-rdp.c (remote_rdp_ops): Likewise.
* remote-sim.c (gdbsim_ops): Likewise.
* remote-st.c (st2000_ops): Likewise.
* v850ice.c (v850ice_ops): Likewise.
* target.c (cleanup_target): Likewise
(update_current_target): Likewise.
(setup_target_debug): Likewise
(debug_to_core_file_to_sym_file): Removed.

* corefile.c (core_file_command) [HPUXHPPA]: Removed code that
sets symbol file from information obtained from the core file.
* corelow.c (core_file_to_sym_file): Removed.
@
text
@d713 1
a713 1
e7000_resume (int pid, int step, enum target_signal sigal)
d1648 1
a1648 1
  inferior_pid = 0;		/* No process now */
d2002 2
a2003 2
static int
e7000_wait (int pid, struct target_waitstatus *status)
d2125 1
a2125 1
  return 0;
@


1.18
log
@* main.c: Remove windows.h use.
(gdbtk_test): Use PATH_MAX for home var calculation.
* remote-e7000.c (e7000_parse_device): Accomodate Cygwin as well as Win32 in
test.
* ser-tcp.c: Use modern __CYGWIN__ conditional.
* source.c (mod_path): Add __CYGWIN__ conditional to WIN32 test.
(openp): Ditto.
* symfile.c (symfile_bfd_open): Ditto.
* gdbtk/generic/gdbtk.c: Ditto.
@
text
@a2201 1
  e7000_ops.to_core_file_to_sym_file = NULL;
@


1.17
log
@Update/correct copyright notices.
@
text
@d546 1
a546 1
#if !defined(__GO32__) && !defined(_WIN32)
@


1.16
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1993, 1994, 1996, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
@


1.15
log
@Replace calls to abort() with calls to internal_error().
@
text
@d48 1
@


1.14
log
@* ppc-bdm.c (#include <signal.h>): Removed.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-mips.c: Likewise.
* remote-os9k.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
@
text
@d890 1
a890 1
		abort ();
d2120 1
a2120 1
      abort ();
@


1.13
log
@* monitor.c (#include "gdb_wait.h"): Removed.
* ocd.c: Likewise.
* ppc-bdm.c: Likewise.
* remote-adapt.c: Likewise.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-eb.c: Likewise.
* remote-es.c: Likewise.
* remote-mips.c: Likewise.
* remote-mm.c: Likewise.
* remote-nindy.c: Likewise.
* remote-os9k.c: Likewise.
* remote-rdi.c: Likewise.
* remote-rdp.c: Likewise.
* remote-sds.c: Likewise.
* remote-sim.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
* remote.c: Likewise.
* ser-pipe.c: Likewise.
* ser-unix.c: Likewise.
* Makefile.in: Updated dependencies.
-------------------------------------------------------------------
@
text
@a41 1
#include <signal.h>
@


1.12
log
@* exec.c (xfer_memory): Add attrib argument.
* infptrace.c (child_xfer_memory): Likewise.
* monitor.c (monitor_xfer_memory): Likewise.
* remote-adapt.c (adapt_xfer_inferior_memory): Likewise.
* remote-array.c (array_xfer_memory): Likewise.
* remote-bug.c (bug_xfer_memory): Likewise.
* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
* remote-eb.c (eb_xfer_inferior_memory): Likewise.
* remote-es.c (es1800_xfer_inferior_memory): Likewise.
* remote-mips.c (mips_xfer_memory): Likewise.
* remote-mm.c (mm_xfer_inferior_memory): Likewise.
* remote-nindy.c (nindy_xfer_inferior_memory): Likewise.
* remote-os9k.c (rombug_xfer_inferior_memory): Likewise.
* remote-rdi.c (arm_rdi_xfer_memory): Likewise.
* remote-rdp.c (remote_rdp_xfer_inferior_memory): Likewise.
* remote-sds.c (sds_xfer_memory): Likewise.
* remote-sim.c (gdbsim_xfer_inferior_memory): Likewise.
* remote-st.c (st2000_xfer_inferior_memory): Likewise.
* remote-udi.c (udi_xfer_inferior_memory): Likewise.
* remote-vx.c (vx_xfer_memory): Likewise.
* remote.c (remote_xfer_memory): Likewise.
* target.c (debug_to_xfer_memory, do_xfer_memory): Likewise.
* target.h (child_xfer_memory, do_xfer_memory, xfer_memory): Likewise.

* target.h (#include "memattr.h"): Added.
(target_ops.to_xfer_memory): Add attrib argument.

* wince.c (_initialize_inftarg): Removed call to set_dcache_state.
* dcache.h (set_dcache_state): Removed declaration.
* dcache.c (set_dcache_state): Removed definition

* dcache.c: Update module comment, as dcache is now enabled and
disabled with memory region attributes instead of by the global
variable "remotecache".  Add comment describing the interaction
between dcache and memory region attributes.
(dcache_xfer_memory): Add comment describing benefits of moving
cache writeback to a higher level.
(dcache_struct): Removed cache_has_stuff field.  This was used to
record whether the cache had been accessed in order to invalidate
it when it was disabled.  However, this is not needed because the
cache is write through and the code that enables, disables, and
deletes memory regions invalidate the cache.  Add comment which
suggests that we could be more selective and only invalidate those
cache lines containing data from those memory regions.
(dcache_invalidate): Updated.
(dcache_xfer_memory): Updated.

(dcache_alloc): Don't abort() if dcache_enabled_p is clear.
(dcache_xfer_memory): Removed code that called do_xfer_memory() to
perform a uncached transfer if dcache_enabled_p was clear.  This
function is now only called if caching is enabled for the memory
region.
(dcache_info): Always print cache info.

* target.c (do_xfer_memory): Add attrib argument.
(target_xfer_memory, target_xfer_memory_partial): Break transfer
into chunks defined by memory regions, pass region attributes to
do_xfer_memory().
* dcache.c (dcache_read_line, dcache_write_line): Likewise.

* Makefile.in (SFILES): Add memattr.c.
(COMMON_OBS): Add memattr.o.
(dcache.o): Add target.h to dependencies.
* memattr.c: New file.
* memattr.h: Likewise.
@
text
@a39 1
#include "gdb_wait.h"
@


1.11
log
@* ser-e7kpc.c (e7000pc_setstopbits): New function.
(e7000pc_ops): Add e7000pc_setstopbits.

* remote-e7000.c (e7000_detach, e7000_resume,
e7000_xfer_inferior_memory, e7000_files_info, e7000_files_info,
e7000_insert_breakpoint, e7000_remove_breakpoint, e7000_kill):
Update function signature to match target vector.

* h8300-tdep.c (h8300_command, h8300h_command, h8300s_command):
h8500-tdep.c (small_command, big_command, medium_command,
compact_command): Update function signature to match add_cmd.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
d1477 3
a1479 1
			    int len, int write, struct target_ops *target)
@


1.10
log
@* gdbarch.sh, hp-psymtab-read.c, hpread.c, m3-nat.c, mcore-tdep.c,
mips-tdep.c, monitor.c, regcache.c, remote-es.c, ser-unix.c,
somread.c, tracepoint.c: Fix spelling errors in comments.
* gdbarch.c: Regenerate.

* gnu-nat.c (S_exception_raise_request): Fix typos and spelling
errors in strings.
* m3-nat.c (intercept_exec_calls, mach_thread_parse_id): Likewise.
* mcore-tdep.c (mcore_analyze_prologue): Likewise.
* mips-tdep.c (mips16_next_pc, _initialize_mips_tdep): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-rdp.c (handle_swi): Likewise.
* remote-vx.c (vx_load_command): Likewise.
* sh-tdep.c (sh_do_pseudo_register): Likewise.
* sol-thread.c (td_err_string): Likewise.
* symtab.c (decode_line_2): Likewise.
-------------------------------------------------------------------
@
text
@d703 1
a703 1
e7000_detach (int from_tty)
d713 1
a713 1
e7000_resume (int pid, int step, int sig)
d1065 1
a1065 1
e7000_files_info (void)
d1476 1
a1476 1
e7000_xfer_inferior_memory (CORE_ADDR memaddr, unsigned char *myaddr,
d1488 1
a1488 1
e7000_kill (char *args, int from_tty)
d1699 1
a1699 1
e7000_insert_breakpoint (CORE_ADDR addr, unsigned char *shadow)
d1742 1
a1742 1
e7000_remove_breakpoint (CORE_ADDR addr, unsigned char *shadow)
@


1.9
log
@Protoization.
@
text
@d630 1
a630 1
      error ("Unable to syncronize with target.\n");
@


1.8
log
@* dcache.c (dcache_info): Output a cache line's state vector so it
lines up under the data vector.

* dcache.c (dcache_read_line): New function.
(dcache_peek_byte): Use it.
(dcache_alloc): Return NULL if write of reclaimed cache line fails.
(dcache_peek_byte, dcache_poke_byte): Return failure if
dcache_alloc() returns a NULL data block pointer.
(dcache_xfer_memory): Don't force writeback unless we were writing.

* monitor.c (monitor_expect): Change places where immediate_quit
is set to 1 or 0 to increments and decrements respectively.  This
allows such changes to nest properly.
* ocd.c (ocd_start_remote): Likewise.
* remote-adapt.c (expect): Likewise.
* remote-array.c (expect): Likewise.
* remote-eb.c (expect): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-mips.c (mips_expect_timeout, mips_getstring): Likewise.
* remote-nrom.c (expect): Likewise.
* remote-os9k.c (expect): Likewise.
* remote-sds.c (sds_start_remote): Likewise.
* remote-st.c (expect): Likewise.
* remote-utils.c (sr_expect): Likewise.
* remote.c (remote_start_remote): Likewise.
* tracepoint.c (read_actions): Likewise.

* remote-mips.c (mips_getstring): Balance changes to immediate_quit.
@
text
@d798 1
a798 3
fetch_regs_from_dump (nextchar, want)
     int (*nextchar) ();
     char *want;
d1469 6
d1476 2
a1477 6
e7000_xfer_inferior_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
     int write;
     struct target_ops *target;	/* ignored */
@


1.7
log
@2000-07-31  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* sh-tdep.c (sh_push_arguments): Make header match prototype.

	* remote-e7000.c (e7000_start_remote): Use void *, not char * as
 	parameter to avoid compiler warning.
	(fetch_regs_from_dump): Call get_hex() with the correct number of
 	parameters.
@
text
@d572 1
a572 1
  immediate_quit = 1;		/* Allow user to interrupt it */
d638 1
a638 1
  immediate_quit = 0;
@


1.6
log
@Protoization.
@
text
@d565 1
a565 1
e7000_start_remote (char *dummy)
d898 1
a898 1
				(LONGEST) get_hex (&thischar, nextchar));
@


1.5
log
@2000-07-19  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        Multiarch the sh target.
	* sh-tdep.c:
	(sh_generic_reg_names, sh_reg_names,sh3_reg_names, sh3e_reg_names,
 	sh_dsp_reg_names, sh3_dsp_reg_names, sh_processor_type_table):
 	Remove.
	(XMALLOC): Define.
	(struct frame_extra_info): Define.
	(sh_register_raw_size, sh_register_virtual_size,
 	sh_register_virtual_type, sh_register_byte, sh_breakpoint_from_pc,
 	sh_frame_saved_pc, sh_skip_prologue,
 	sh_nofp_frame_init_saved_regs, sh_fp_frame_init_saved_regs,
 	sh_extract_struct_value_address, sh_use_struct_convention,
 	sh_store_struct_return, sh_push_arguments, sh_push_return_address,
 	sh_saved_pc_after_call, sh_generic_register_name,
 	sh_sh_register_name, sh_sh3_register_name, sh_sh3e_register_name,
 	sh_sh_dsp_register_name, sh_sh3_dsp_register_name,
 	sh_frame_args_address, sh_frame_locals_address,
 	sh_coerce_float_to_double, sh_default_store_return_value,
 	sh3e_sh4_store_return_value, sh_generic_show_regs,
 	sh3_show_regs,sh3e_show_regs, sh3_dsp_show_regs, sh4_show_regs,
 	sh_dsp_show_regs, sh_register_byte, sh_register_raw_size,
 	sh_register_virtual_size, sh_sh3e_register_virtual_type,
 	sh_default_register_virtual_type, sh_gdbarch_init): New functions.
	(sh_target_architecture_hook, sh_frame_find_saved_regs,
 	sh_show_regs): Delete functions.
	(sh_frame_chain, sh_find_callers_reg, sh_init_extra_frame_info,
 	sh_pop_frame, sh_extract_return_value): Update

	* config/sh/tm-sh.h (GDB_MULTI_ARCH): Define to 1.
	(struct gdbarch_tdep): Define.
	Remove all unnecessary defines.

	* remote-e7000.c ({PR,GBR,SR,MACL,VBR,MACH}_REGNUM): Define to -1,
 	for h8300 case.
	(want_sh,want_nopc_sh,want_nopc_sh3): Make nomenclature
 	consistent.
	(e7000_fetch_registers): Remove ifdef GDB_TARGET_IS_SH, use
 	runtime check instead.
	(e7000_wait): Ditto.

	* sh3-rom.c (sh3_supply_register): Use gdbarch_tdep to get the SSR
 	and SPC register numbers.
	(sh3_regnames, sh3e_regnames): Don't specify a size.

	* config/h8300/tm-h8300.h: Add comment.
@
text
@d151 1
a151 2
puts_e7000debug (buf)
     char *buf;
d170 1
a170 2
putchar_e7000 (x)
     int x;
d179 1
a179 2
write_e7000 (s)
     char *s;
d185 1
a185 2
normal (x)
     int x;
d197 1
a197 2
readchar (timeout)
     int timeout;
d228 1
a228 1
tl (x)
d254 1
a254 2
expect (string)
     char *string;
d324 1
a324 1
expect_prompt ()
d330 1
a330 1
expect_full_prompt ()
d336 1
a336 2
convert_hex_digit (ch)
     int ch;
d348 1
a348 2
get_hex (start)
     int *start;
d368 1
a368 3
get_hex_regs (n, regno)
     int n;
     int regno;
d389 1
a389 4
e7000_create_inferior (execfile, args, env)
     char *execfile;
     char *args;
     char **env;
d438 1
a438 2
next (ptr)
     char **ptr;
d461 1
a461 3
e7000_login_command (args, from_tty)
     char *args;
     int from_tty;
d483 1
a483 3
e7000_ftp_command (args, from_tty)
     char *args;
     int from_tty;
d513 1
a513 4
e7000_parse_device (args, dev_name, baudrate)
     char *args;
     char *dev_name;
     int baudrate;
d565 1
a565 2
e7000_start_remote (dummy)
     char *dummy;
d655 1
a655 3
e7000_open (args, from_tty)
     char *args;
     int from_tty;
d690 1
a690 2
e7000_close (quitting)
     int quitting;
d703 1
a703 2
e7000_detach (from_tty)
     int from_tty;
d713 1
a713 2
e7000_resume (pid, step, sig)
     int pid, step, sig;
d783 1
a783 1
gch ()
d789 1
a789 1
gbyte ()
d906 1
a906 1
e7000_fetch_registers ()
d949 1
a949 2
e7000_fetch_register (regno)
     int regno;
d957 1
a957 1
e7000_store_registers ()
d970 1
a970 2
e7000_store_register (regno)
     int regno;
d1061 1
a1061 1
e7000_prepare_to_store ()
d1067 1
a1067 1
e7000_files_info ()
d1073 1
a1073 3
stickbyte (where, what)
     char *where;
     unsigned int what;
d1086 1
a1086 4
write_small (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
d1130 1
a1130 4
write_large (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
d1224 1
a1224 4
e7000_write_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
d1242 1
a1242 4
e7000_read_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
d1321 2
a1322 4
e7000_read_inferior_memory_large (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
d1384 2
a1385 4
fast_but_for_the_pause_e7000_read_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d1488 1
a1488 3
e7000_kill (args, from_tty)
     char *args;
     int from_tty;
d1493 1
a1493 3
e7000_load (args, from_tty)
     char *args;
     int from_tty;
d1679 1
a1679 1
e7000_mourn_inferior ()
d1699 1
a1699 3
e7000_insert_breakpoint (addr, shadow)
     CORE_ADDR addr;
     unsigned char *shadow;
d1742 1
a1742 3
e7000_remove_breakpoint (addr, shadow)
     CORE_ADDR addr;
     unsigned char *shadow;
d1785 1
a1785 3
e7000_command (args, fromtty)
     char *args;
     int fromtty;
d1817 1
a1817 4
e7000_drain_command (args, fromtty)
     char *args;
     int fromtty;

d1841 1
a1841 1
why_stop ()
d1886 1
a1886 2
expect_n (strings)
     char **strings;
d1970 1
a1970 1
sub2_from_pc ()
d2001 1
a2001 3
e7000_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d2129 1
a2129 1
e7000_stop ()
d2214 1
a2214 1
_initialize_remote_e7000 ()
@


1.4
log
@PARAMS removal.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1996, 1997, 1998 Free Software Foundation, Inc.
d64 25
a759 2
#ifdef GDB_TARGET_IS_H8300

d777 1
a777 5
#endif

#ifdef GDB_TARGET_IS_SH

char *want = "PC=%16 SR=%22\n\
d783 1
a783 1
char *want_nopc = "%16 SR=%22\n\
d799 1
a799 1
char *want_sh3_nopc = "%16 SR=%22\n\
a808 2
#endif

a939 2
#ifdef GDB_TARGET_IS_SH
  wanted = want;
d941 18
a958 12
    switch (TARGET_ARCHITECTURE->mach)
      {
      case bfd_mach_sh3:
      case bfd_mach_sh3e:
      case bfd_mach_sh4:
	wanted = want_sh3;
      }
#else
  if (h8300smode)
    wanted = want_h8300s;
  else
    wanted = want_h8300h;
d960 1
d1009 1
a1009 2
#ifdef GDB_TARGET_IS_H8300
  if (regno <= 7)
d1011 17
a1027 12
      sprintf (buf, ".ER%d %x\r", regno, read_register (regno));
      puts_e7000debug (buf);
    }
  else if (regno == PC_REGNUM)
    {
      sprintf (buf, ".PC %x\r", read_register (regno));
      puts_e7000debug (buf);
    }
  else if (regno == CCR_REGNUM)
    {
      sprintf (buf, ".CCR %x\r", read_register (regno));
      puts_e7000debug (buf);
a1028 1
#endif /* GDB_TARGET_IS_H8300 */
d1030 1
a1030 2
#ifdef  GDB_TARGET_IS_SH
  switch (regno)
d1032 5
a1036 4
    default:
      sprintf (buf, ".R%d %x\r", regno, read_register (regno));
      puts_e7000debug (buf);
      break;
d1038 5
a1042 4
    case PC_REGNUM:
      sprintf (buf, ".PC %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;
d1044 5
a1048 4
    case SR_REGNUM:
      sprintf (buf, ".SR %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;
d1050 5
a1054 4
    case PR_REGNUM:
      sprintf (buf, ".PR %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;
d1056 5
a1060 4
    case GBR_REGNUM:
      sprintf (buf, ".GBR %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;
d1062 5
a1066 4
    case VBR_REGNUM:
      sprintf (buf, ".VBR %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;
d1068 10
a1077 9
    case MACH_REGNUM:
      sprintf (buf, ".MACH %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;

    case MACL_REGNUM:
      sprintf (buf, ".MACL %x\r", read_register (regno));
      puts_e7000debug (buf);
      break;
a1079 2
#endif /* GDB_TARGET_IS_SH */

d1130 1
a1130 1
	  sprintf (buf, "m %x %x%02x%02x%02x;l\r",
d1138 1
a1138 1
	  sprintf (buf, "m %x %x\r", memaddr + i, myaddr[i]);
d1300 1
a1300 1
  sprintf (buf, "m %x;l\r", memaddr);
d1381 1
a1381 1
  sprintf (buf, "d %x %x\r", memaddr, memaddr + len - 1);
d1635 1
a1635 1
	    printf_filtered ("[Loading section %s at 0x%x (%d bytes)]\n",
d1768 1
a1768 1
	    sprintf (buf, "BC%d A=%x\r", i + 1, addr);
d1773 1
a1773 1
	    sprintf (buf, "B %x\r", addr);
d1814 1
a1814 1
	    sprintf (buf, "B - %x\r", addr);
d1819 1
a1819 1
	sprintf (buf, "B - %x\r", addr);
d1832 1
a1832 1
  warning ("Can't find breakpoint associated with 0x%x\n", addr);
d2040 1
a2040 1
  sprintf (buf2, ".PC %x\r", read_register (PC_REGNUM));
a2109 2
#ifdef GDB_TARGET_IS_SH
  wanted_nopc = want_nopc;
d2111 18
a2128 12
    switch (TARGET_ARCHITECTURE->mach)
      {
      case bfd_mach_sh3:
      case bfd_mach_sh3e:
      case bfd_mach_sh4:
	wanted_nopc = want_sh3_nopc;
      }
#else
  if (h8300smode)
    wanted_nopc = want_nopc_h8300s;
  else
    wanted_nopc = want_nopc_h8300h;
@


1.3
log
@Cleanup bfd_close() cleanups.
@
text
@d64 1
a64 1
extern void notice_quit PARAMS ((void));
d66 1
a66 2
extern void report_transfer_performance PARAMS ((unsigned long,
						 time_t, time_t));
d72 1
a72 1
static void e7000_close PARAMS ((int));
d74 1
a74 1
static void e7000_fetch_register PARAMS ((int));
d76 1
a76 1
static void e7000_store_register PARAMS ((int));
d78 1
a78 1
static void e7000_command PARAMS ((char *, int));
d80 1
a80 1
static void e7000_login_command PARAMS ((char *, int));
d82 1
a82 1
static void e7000_ftp_command PARAMS ((char *, int));
d84 1
a84 1
static void e7000_drain_command PARAMS ((char *, int));
d86 1
a86 1
static void expect PARAMS ((char *));
d88 1
a88 1
static void expect_full_prompt PARAMS ((void));
d90 1
a90 1
static void expect_prompt PARAMS ((void));
d92 1
a92 2
static int e7000_parse_device PARAMS ((char *args, char *dev_name,
				       int baudrate));
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d1583 1
a1583 1
  old_chain = make_cleanup ((make_cleanup_func) bfd_close, pbfd);
@


1.1
log
@Initial revision
@
text
@d21 2
a22 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d40 1
a40 1
#include "wait.h"
d100 1
a100 1
static int use_hard_breakpoints = 0; /* use sw breakpoints by default */
d104 1
a104 1
static int using_tcp;	/* direct tcp connection to target */
d199 1
a199 1
  if (remote_debug) 
d217 2
a218 2
  if (x >= ' ') 
    { 
d224 1
a224 1
      sprintf(b[p], "<%d>", x);
d248 1
a248 1
      if (quit_flag == 1) 
d252 1
a252 1
	      putchar_e7000(CTRLC);
d255 1
a255 1
	  else 
d261 1
a261 1
      
d507 5
a511 5
static int 
e7000_parse_device (args, dev_name, baudrate) 
    char *args;
    char *dev_name;
    int baudrate;
d520 1
a520 1
  else 
d523 3
a525 3
	     target tcp_remote <device> */
      if (args && strncmp (args, "tcp", 10) == 0) 
        {
d528 1
a528 1
	  using_tcp_remote=1;
d530 2
a531 2
        }
      else if (args) 
d554 1
a554 1
        using_tcp = 1;
d575 1
a575 1
  loop =  0;
d604 1
a604 1
	  if (loop++ == 20) 
d610 1
a610 1
	  QUIT ;
d617 1
a617 1
	      quit_trying = try+1;  /* we don't want to try anymore */
d628 1
a628 1
      fprintf_unfiltered (gdb_stderr, "Giving up after %d tries...\n",try);
d681 5
a685 5
  if (!catch_errors (e7000_start_remote, (char *)0, 
		     "Couldn't establish connection to remote target\n", RETURN_MASK_ALL))
  if (from_tty)
    printf_filtered ("Remote target %s connected to %s\n", target_shortname,
		     dev_name);
d735 1
a735 1
   */
d811 1
a811 1
     int (*nextchar)();
d825 1
a825 1
	  while (thischar != '\n' && thischar != '\r') 
d827 1
a827 1
	  while (thischar == '\n' || thischar == '\r') 
d840 1
a840 1
	  
d847 1
a847 1
	      
d853 6
a858 5
	  else {
	    error ("out of sync in fetch registers wanted <%s>, got <%c 0x%x>",
		   want, thischar, thischar);
	  }
    
d891 1
a891 1
	      if (isdigit (want[0])) 
d898 1
a898 1
		  else 
d904 1
a904 1
	      
d909 1
a909 1
				REGISTER_RAW_SIZE(regno),
d932 1
d1124 11
a1134 11
	il ;s:s\r	 ->
			<- il ;s:s\r
			<-  	ENQ
	ACK		->
			<- LO s\r
	Srecords...
	^Z		->
			<-	ENQ
	ACK		->  
			<-	:   	
  */
d1210 1
a1210 1
	  while ((j = readchar (0)) > 0) 
d1212 1
a1212 1
	      printf_unfiltered ("@@{%d}@@",j);
d1248 4
a1251 4
  Small transactions we send
  m <addr>;l
  and receive
    00000000 12345678 ?
d1266 1
a1266 1
/*  printf("READ INF %x %x %d\n", memaddr, myaddr, len);*/
d1276 1
a1276 1
  for (count = 0; count < len; count += 4) 
d1279 1
a1279 1
      c = gch ();	
d1281 1
a1281 1
	c = gch ();	
d1283 1
a1283 1
      if (c == '*') 
d1285 2
a1286 2
	  puts_e7000debug (".\r"); /* Some errors leave us in memory input mode */
	  expect_full_prompt();
d1290 1
a1290 1
	c = gch ();	
d1293 1
a1293 1
      for (i = 0; i < 4; i++) 
d1295 5
a1299 4
	  int b = gbyte();
	  if (count + i < len) {
	    myaddr[count + i] = b;
	  }
d1303 1
a1303 1
      gch ();	
d1306 1
a1306 1
	puts_e7000debug(".\r");
d1308 1
a1308 1
	puts_e7000debug("\r");
d1311 1
a1311 1
  expect_prompt();
d1318 1
a1318 1
  For large transfers we used to send
d1321 1
a1321 1
  d <addr> <endaddr>\r
d1323 1
a1323 1
  and receive
d1329 1
a1329 1
  A cost in chars for each transaction of 80 + 5*n-bytes. 
d1331 4
a1334 4
  Large transactions could be done with the srecord load code, but
  there is a pause for a second before dumping starts, which slows the
  average rate down!
*/
d1359 1
a1359 1
  
d1361 1
a1361 1
  while( c != '>' )
d1364 1
a1364 1
  while( c != '\r' )
d1388 1
a1388 1
      while( c != '\r' )
d1500 5
a1504 6
    return e7000_write_inferior_memory( memaddr, myaddr, len);
  else 
    if( len < 16 )
      return e7000_read_inferior_memory( memaddr, myaddr, len);
    else
      return e7000_read_inferior_memory_large( memaddr, myaddr, len);
d1524 1
a1524 1
  char buf[2 + 4 + 4 + WRITESIZE]; /* `DT' + <addr> + <len> + <data> */
d1530 1
a1530 1
  int oldtimeout = timeout;	
d1553 2
a1554 1
      while (isspace (*args)) args++;
d1558 2
a1559 1
      while ((*args != '\000') && !isspace (*args)) args++;
d1585 1
a1585 1
  if (!bfd_check_format (pbfd, bfd_object)) 
d1596 1
a1596 1
  for (section = pbfd->sections; section; section = section->next) 
d1614 1
a1614 1
	  
d1642 1
a1642 1
				    safe_strerror(errno));
d1687 1
a1687 1
/*      start_routine (entry);*/
d1719 2
a1720 1
static CORE_ADDR breakaddr[MAX_BREAKPOINTS] = {0};
d1739 1
a1739 1
	if (BC_BREAKPOINTS) 
d1741 1
a1741 1
	    sprintf (buf, "BC%d A=%x\r", i+1, addr);
d1744 1
a1744 1
	else 
d1780 1
a1780 1
	if (BC_BREAKPOINTS) 
d1782 1
a1782 1
	    sprintf (buf, "BC%d - \r",  i+1);
d1785 1
a1785 1
	else 
d1787 1
a1787 1
	    sprintf (buf, "B - %x\r",  addr);
d1854 1
a1854 1
  puts_e7000debug("end\r");
d1861 1
a1861 1
	  putchar_e7000(CTRLC);
d1876 2
a1877 1
  static  char *strings[NITEMS] = {
d1892 1
a1892 1
  
d1898 1
a1898 1
	  if (c == *(p[i])) 
d1901 2
a1902 2
	      if (*(p[i]) == 0) 
		{ 
d1920 1
a1920 1
char **strings;
d1923 1
a1923 1
  int n; 
d1929 1
a1929 1
  for (n = 0; strings[n]; n++) 
d1947 1
a1947 1
	  int k = getkey();
d1961 1
a1961 1
	  if (c == ptr[i][0]) 
d1976 1
a1976 1
    
d1980 1
a1980 1
	  *buffer ++ = c;
d1984 1
a1984 1
	  if (buffer != saveaway) 
d2010 2
a2011 2
			REGISTER_RAW_SIZE(PC_REGNUM), 
			read_register (PC_REGNUM) -2);
d2022 2
a2023 1
static char *estrings[] = {
d2053 1
a2053 1
	{	 
d2090 1
d2117 2
a2118 2
      write_pc (read_pc ()); /* PC is always off by 2 for breakpoints */
      status->value.sig = TARGET_SIGNAL_TRAP;      
d2121 1
a2121 1
      status->value.sig = TARGET_SIGNAL_TRAP;      
d2126 1
a2126 1
	  status->value.sig = TARGET_SIGNAL_TRAP;      
d2131 1
a2131 1
	  status->value.sig = TARGET_SIGNAL_INT;      
d2138 1
a2138 1
      status->value.sig = TARGET_SIGNAL_UNKNOWN;      
d2141 1
a2141 1
      status->value.sig = TARGET_SIGNAL_ILL;      
d2144 1
a2144 1
      status->value.sig = TARGET_SIGNAL_SEGV;      
d2148 1
a2148 1
      status->value.sig = TARGET_SIGNAL_UNKNOWN;      
d2161 1
a2161 1
e7000_stop ()  
d2169 1
a2169 1
struct target_ops e7000_ops ;
d2171 2
a2172 2
static void 
init_e7000_ops(void)
d2174 3
a2176 3
  e7000_ops.to_shortname =   "e7000";
  e7000_ops.to_longname =   "Remote Hitachi e7000 target";
  e7000_ops.to_doc =   "Use a remote Hitachi e7000 ICE connected by a serial line;\n\
d2182 4
a2185 4
target e7000 foobar" ;
  e7000_ops.to_open =   e7000_open;	
  e7000_ops.to_close =   e7000_close;	
  e7000_ops.to_attach =   0;
d2187 22
a2208 22
  e7000_ops.to_require_attach = NULL;	
  e7000_ops.to_detach =   e7000_detach;
  e7000_ops.to_require_detach = NULL;	
  e7000_ops.to_resume =   e7000_resume;	
  e7000_ops.to_wait  =   e7000_wait;
  e7000_ops.to_post_wait = NULL;	
  e7000_ops.to_fetch_registers  =   e7000_fetch_register;
  e7000_ops.to_store_registers  =   e7000_store_register;
  e7000_ops.to_prepare_to_store =   e7000_prepare_to_store;
  e7000_ops.to_xfer_memory  =   e7000_xfer_inferior_memory;
  e7000_ops.to_files_info  =   e7000_files_info;		
  e7000_ops.to_insert_breakpoint =   e7000_insert_breakpoint;	
  e7000_ops.to_remove_breakpoint =   e7000_remove_breakpoint;	
  e7000_ops.to_terminal_init  =   0;				
  e7000_ops.to_terminal_inferior =   0;				
  e7000_ops.to_terminal_ours_for_output =   0;			
  e7000_ops.to_terminal_ours  =   0;				
  e7000_ops.to_terminal_info  =   0;				
  e7000_ops.to_kill  =   e7000_kill;		
  e7000_ops.to_load  =   e7000_load;		
  e7000_ops.to_lookup_symbol =   0;		
  e7000_ops.to_create_inferior =   e7000_create_inferior;
d2211 2
a2212 2
  e7000_ops.to_clone_and_follow_inferior = NULL;          
  e7000_ops.to_post_follow_inferior_by_clone = NULL;  
d2216 1
a2216 1
  e7000_ops.to_remove_vfork_catchpoint = NULL;                      
d2219 1
a2219 1
  e7000_ops.to_can_follow_vfork_prior_to_exec = NULL;                        
d2226 6
a2231 6
  e7000_ops.to_mourn_inferior =   e7000_mourn_inferior;		
  e7000_ops.to_can_run  =   0;			
  e7000_ops.to_notice_signals =   0;		
  e7000_ops.to_thread_alive  =   0;		
  e7000_ops.to_stop  =   e7000_stop;
  e7000_ops.to_pid_to_exec_file = NULL;	
d2233 10
a2242 10
  e7000_ops.to_stratum =   process_stratum;	
  e7000_ops.DONT_USE =   0;			
  e7000_ops.to_has_all_memory =   1;		
  e7000_ops.to_has_memory =   1;		
  e7000_ops.to_has_stack =   1;			
  e7000_ops.to_has_registers =   1;		
  e7000_ops.to_has_execution =   1;		
  e7000_ops.to_sections =   0;			
  e7000_ops.to_sections_end =   0;		
  e7000_ops.to_magic =   OPS_MAGIC;		
d2248 1
a2248 1
  init_e7000_ops() ;
d2264 2
a2265 2
				  var_integer, (char *)&use_hard_breakpoints,
				  "Set use of hardware breakpoints for all breakpoints.\n", &setlist),
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a929 1
      case bfd_mach_sh4:
a2081 1
      case bfd_mach_sh4:
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d21 1
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d99 1
a99 1
static int use_hard_breakpoints = 0;	/* use sw breakpoints by default */
d103 1
a103 1
static int using_tcp;		/* direct tcp connection to target */
d198 1
a198 1
  if (remote_debug)
d216 2
a217 2
  if (x >= ' ')
    {
d223 1
a223 1
      sprintf (b[p], "<%d>", x);
d247 1
a247 1
      if (quit_flag == 1)
d251 1
a251 1
	      putchar_e7000 (CTRLC);
d254 1
a254 1
	  else
d260 1
a260 1

d506 5
a510 5
static int
e7000_parse_device (args, dev_name, baudrate)
     char *args;
     char *dev_name;
     int baudrate;
d519 1
a519 1
  else
d522 3
a524 3
         target tcp_remote <device> */
      if (args && strncmp (args, "tcp", 10) == 0)
	{
d527 1
a527 1
	  using_tcp_remote = 1;
d529 2
a530 2
	}
      else if (args)
d553 1
a553 1
	using_tcp = 1;
d574 1
a574 1
  loop = 0;
d603 1
a603 1
	  if (loop++ == 20)
d609 1
a609 1
	  QUIT;
d616 1
a616 1
	      quit_trying = try + 1;	/* we don't want to try anymore */
d627 1
a627 1
      fprintf_unfiltered (gdb_stderr, "Giving up after %d tries...\n", try);
d680 5
a684 5
  if (!catch_errors (e7000_start_remote, (char *) 0,
       "Couldn't establish connection to remote target\n", RETURN_MASK_ALL))
    if (from_tty)
      printf_filtered ("Remote target %s connected to %s\n", target_shortname,
		       dev_name);
d734 1
a734 1
 */
d810 1
a810 1
     int (*nextchar) ();
d824 1
a824 1
	  while (thischar != '\n' && thischar != '\r')
d826 1
a826 1
	  while (thischar == '\n' || thischar == '\r')
d839 1
a839 1

d846 1
a846 1

d852 5
a856 6
	  else
	    {
	      error ("out of sync in fetch registers wanted <%s>, got <%c 0x%x>",
		     want, thischar, thischar);
	    }

d889 1
a889 1
	      if (isdigit (want[0]))
d896 1
a896 1
		  else
d902 1
a902 1

d907 1
a907 1
				REGISTER_RAW_SIZE (regno),
d1122 11
a1132 11
   il ;s:s\r     ->
   <- il ;s:s\r
   <-   ENQ
   ACK          ->
   <- LO s\r
   Srecords...
   ^Z           ->
   <-   ENQ
   ACK          ->  
   <-   :       
 */
d1208 1
a1208 1
	  while ((j = readchar (0)) > 0)
d1210 1
a1210 1
	      printf_unfiltered ("@@{%d}@@", j);
d1246 4
a1249 4
   Small transactions we send
   m <addr>;l
   and receive
   00000000 12345678 ?
d1264 1
a1264 1
/*  printf("READ INF %x %x %d\n", memaddr, myaddr, len); */
d1274 1
a1274 1
  for (count = 0; count < len; count += 4)
d1277 1
a1277 1
      c = gch ();
d1279 1
a1279 1
	c = gch ();
d1281 1
a1281 1
      if (c == '*')
d1283 2
a1284 2
	  puts_e7000debug (".\r");	/* Some errors leave us in memory input mode */
	  expect_full_prompt ();
d1288 1
a1288 1
	c = gch ();
d1291 1
a1291 1
      for (i = 0; i < 4; i++)
d1293 4
a1296 5
	  int b = gbyte ();
	  if (count + i < len)
	    {
	      myaddr[count + i] = b;
	    }
d1300 1
a1300 1
      gch ();
d1303 1
a1303 1
	puts_e7000debug (".\r");
d1305 1
a1305 1
	puts_e7000debug ("\r");
d1308 1
a1308 1
  expect_prompt ();
d1315 1
a1315 1
   For large transfers we used to send
d1318 1
a1318 1
   d <addr> <endaddr>\r
d1320 1
a1320 1
   and receive
d1326 1
a1326 1
   A cost in chars for each transaction of 80 + 5*n-bytes. 
d1328 4
a1331 4
   Large transactions could be done with the srecord load code, but
   there is a pause for a second before dumping starts, which slows the
   average rate down!
 */
d1356 1
a1356 1

d1358 1
a1358 1
  while (c != '>')
d1361 1
a1361 1
  while (c != '\r')
d1385 1
a1385 1
      while (c != '\r')
d1497 6
a1502 5
    return e7000_write_inferior_memory (memaddr, myaddr, len);
  else if (len < 16)
    return e7000_read_inferior_memory (memaddr, myaddr, len);
  else
    return e7000_read_inferior_memory_large (memaddr, myaddr, len);
d1522 1
a1522 1
  char buf[2 + 4 + 4 + WRITESIZE];	/* `DT' + <addr> + <len> + <data> */
d1528 1
a1528 1
  int oldtimeout = timeout;
d1551 1
a1551 2
      while (isspace (*args))
	args++;
d1555 1
a1555 2
      while ((*args != '\000') && !isspace (*args))
	args++;
d1581 1
a1581 1
  if (!bfd_check_format (pbfd, bfd_object))
d1592 1
a1592 1
  for (section = pbfd->sections; section; section = section->next)
d1610 1
a1610 1

d1638 1
a1638 1
				    safe_strerror (errno));
d1683 1
a1683 1
/*      start_routine (entry); */
d1715 1
a1715 2
static CORE_ADDR breakaddr[MAX_BREAKPOINTS] =
{0};
d1734 1
a1734 1
	if (BC_BREAKPOINTS)
d1736 1
a1736 1
	    sprintf (buf, "BC%d A=%x\r", i + 1, addr);
d1739 1
a1739 1
	else
d1775 1
a1775 1
	if (BC_BREAKPOINTS)
d1777 1
a1777 1
	    sprintf (buf, "BC%d - \r", i + 1);
d1780 1
a1780 1
	else
d1782 1
a1782 1
	    sprintf (buf, "B - %x\r", addr);
d1849 1
a1849 1
  puts_e7000debug ("end\r");
d1856 1
a1856 1
	  putchar_e7000 (CTRLC);
d1871 1
a1871 2
  static char *strings[NITEMS] =
  {
d1886 1
a1886 1

d1892 1
a1892 1
	  if (c == *(p[i]))
d1895 2
a1896 2
	      if (*(p[i]) == 0)
		{
d1914 1
a1914 1
     char **strings;
d1917 1
a1917 1
  int n;
d1923 1
a1923 1
  for (n = 0; strings[n]; n++)
d1941 1
a1941 1
	  int k = getkey ();
d1955 1
a1955 1
	  if (c == ptr[i][0])
d1970 1
a1970 1

d1974 1
a1974 1
	  *buffer++ = c;
d1978 1
a1978 1
	  if (buffer != saveaway)
d2004 2
a2005 2
			REGISTER_RAW_SIZE (PC_REGNUM),
			read_register (PC_REGNUM) - 2);
d2016 1
a2016 2
static char *estrings[] =
{
d2046 1
a2046 1
	{
d2110 2
a2111 2
      write_pc (read_pc ());	/* PC is always off by 2 for breakpoints */
      status->value.sig = TARGET_SIGNAL_TRAP;
d2114 1
a2114 1
      status->value.sig = TARGET_SIGNAL_TRAP;
d2119 1
a2119 1
	  status->value.sig = TARGET_SIGNAL_TRAP;
d2124 1
a2124 1
	  status->value.sig = TARGET_SIGNAL_INT;
d2131 1
a2131 1
      status->value.sig = TARGET_SIGNAL_UNKNOWN;
d2134 1
a2134 1
      status->value.sig = TARGET_SIGNAL_ILL;
d2137 1
a2137 1
      status->value.sig = TARGET_SIGNAL_SEGV;
d2141 1
a2141 1
      status->value.sig = TARGET_SIGNAL_UNKNOWN;
d2154 1
a2154 1
e7000_stop ()
d2162 1
a2162 1
struct target_ops e7000_ops;
d2164 2
a2165 2
static void
init_e7000_ops (void)
d2167 3
a2169 3
  e7000_ops.to_shortname = "e7000";
  e7000_ops.to_longname = "Remote Hitachi e7000 target";
  e7000_ops.to_doc = "Use a remote Hitachi e7000 ICE connected by a serial line;\n\
d2175 4
a2178 4
target e7000 foobar";
  e7000_ops.to_open = e7000_open;
  e7000_ops.to_close = e7000_close;
  e7000_ops.to_attach = 0;
d2180 22
a2201 22
  e7000_ops.to_require_attach = NULL;
  e7000_ops.to_detach = e7000_detach;
  e7000_ops.to_require_detach = NULL;
  e7000_ops.to_resume = e7000_resume;
  e7000_ops.to_wait = e7000_wait;
  e7000_ops.to_post_wait = NULL;
  e7000_ops.to_fetch_registers = e7000_fetch_register;
  e7000_ops.to_store_registers = e7000_store_register;
  e7000_ops.to_prepare_to_store = e7000_prepare_to_store;
  e7000_ops.to_xfer_memory = e7000_xfer_inferior_memory;
  e7000_ops.to_files_info = e7000_files_info;
  e7000_ops.to_insert_breakpoint = e7000_insert_breakpoint;
  e7000_ops.to_remove_breakpoint = e7000_remove_breakpoint;
  e7000_ops.to_terminal_init = 0;
  e7000_ops.to_terminal_inferior = 0;
  e7000_ops.to_terminal_ours_for_output = 0;
  e7000_ops.to_terminal_ours = 0;
  e7000_ops.to_terminal_info = 0;
  e7000_ops.to_kill = e7000_kill;
  e7000_ops.to_load = e7000_load;
  e7000_ops.to_lookup_symbol = 0;
  e7000_ops.to_create_inferior = e7000_create_inferior;
d2204 2
a2205 2
  e7000_ops.to_clone_and_follow_inferior = NULL;
  e7000_ops.to_post_follow_inferior_by_clone = NULL;
d2209 1
a2209 1
  e7000_ops.to_remove_vfork_catchpoint = NULL;
d2212 1
a2212 1
  e7000_ops.to_can_follow_vfork_prior_to_exec = NULL;
d2219 6
a2224 6
  e7000_ops.to_mourn_inferior = e7000_mourn_inferior;
  e7000_ops.to_can_run = 0;
  e7000_ops.to_notice_signals = 0;
  e7000_ops.to_thread_alive = 0;
  e7000_ops.to_stop = e7000_stop;
  e7000_ops.to_pid_to_exec_file = NULL;
d2226 10
a2235 10
  e7000_ops.to_stratum = process_stratum;
  e7000_ops.DONT_USE = 0;
  e7000_ops.to_has_all_memory = 1;
  e7000_ops.to_has_memory = 1;
  e7000_ops.to_has_stack = 1;
  e7000_ops.to_has_registers = 1;
  e7000_ops.to_has_execution = 1;
  e7000_ops.to_sections = 0;
  e7000_ops.to_sections_end = 0;
  e7000_ops.to_magic = OPS_MAGIC;
d2241 1
a2241 1
  init_e7000_ops ();
d2257 2
a2258 2
				var_integer, (char *) &use_hard_breakpoints,
	"Set use of hardware breakpoints for all breakpoints.\n", &setlist),
@

