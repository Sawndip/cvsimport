head	1.11;
access;
symbols
	gdb_6_0-2003-10-04-release:1.10
	kettenis_sparc-20030918-branch:1.10.0.22
	kettenis_sparc-20030918-branchpoint:1.10
	carlton_dictionary-20030917-merge:1.10
	ezannoni_pie-20030916-branchpoint:1.10
	ezannoni_pie-20030916-branch:1.10.0.20
	cagney_x86i386-20030821-branch:1.10.0.18
	cagney_x86i386-20030821-branchpoint:1.10
	carlton_dictionary-20030805-merge:1.10
	carlton_dictionary-20030627-merge:1.10
	gdb_6_0-branch:1.10.0.16
	gdb_6_0-2003-06-23-branchpoint:1.10
	jimb-ppc64-linux-20030613-branch:1.10.0.14
	jimb-ppc64-linux-20030613-branchpoint:1.10
	cagney_convert-20030606-branch:1.10.0.12
	cagney_convert-20030606-branchpoint:1.10
	cagney_writestrings-20030508-branch:1.10.0.10
	cagney_writestrings-20030508-branchpoint:1.10
	jimb-ppc64-linux-20030528-branch:1.10.0.8
	jimb-ppc64-linux-20030528-branchpoint:1.10
	carlton_dictionary-20030523-merge:1.10
	cagney_fileio-20030521-branch:1.10.0.6
	cagney_fileio-20030521-branchpoint:1.10
	kettenis_i386newframe-20030517-mergepoint:1.10
	jimb-ppc64-linux-20030509-branch:1.10.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.10
	kettenis_i386newframe-20030504-mergepoint:1.10
	carlton_dictionary-20030430-merge:1.10
	kettenis_i386newframe-20030419-branch:1.10.0.2
	kettenis_i386newframe-20030419-branchpoint:1.10
	carlton_dictionary-20030416-merge:1.10
	cagney_frameaddr-20030409-mergepoint:1.9
	kettenis_i386newframe-20030406-branch:1.9.0.36
	kettenis_i386newframe-20030406-branchpoint:1.9
	cagney_frameaddr-20030403-branchpoint:1.9
	cagney_frameaddr-20030403-branch:1.9.0.34
	cagney_framebase-20030330-mergepoint:1.9
	cagney_framebase-20030326-branch:1.9.0.32
	cagney_framebase-20030326-branchpoint:1.9
	cagney_lazyid-20030317-branch:1.9.0.30
	cagney_lazyid-20030317-branchpoint:1.9
	kettenis-i386newframe-20030316-mergepoint:1.9
	offbyone-20030313-branch:1.9.0.28
	offbyone-20030313-branchpoint:1.9
	kettenis-i386newframe-20030308-branch:1.9.0.26
	kettenis-i386newframe-20030308-branchpoint:1.9
	carlton_dictionary-20030305-merge:1.9
	cagney_offbyone-20030303-branch:1.9.0.24
	cagney_offbyone-20030303-branchpoint:1.9
	carlton_dictionary-20030207-merge:1.9
	interps-20030203-mergepoint:1.9
	interps-20030202-branch:1.9.0.22
	interps-20030202-branchpoint:1.9
	cagney-unwind-20030108-branch:1.9.0.20
	cagney-unwind-20030108-branchpoint:1.9
	carlton_dictionary-20021223-merge:1.9
	gdb_5_3-2002-12-12-release:1.9
	carlton_dictionary-20021115-merge:1.9
	kseitz_interps-20021105-merge:1.9
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.9
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.18
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.16
	carlton_dictionary-20020920-branchpoint:1.9
	gdb_5_3-branch:1.9.0.14
	gdb_5_3-2002-09-04-branchpoint:1.9
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.12
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.10
	readline_4_3-import-branchpoint:1.9
	gdb_5_2_1-2002-07-23-release:1.9
	kseitz_interps-20020528-branch:1.9.0.8
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.6
	cagney_regbuf-20020515-branchpoint:1.9
	jimb-macro-020506-branch:1.9.0.4
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	gdb_5_2-branch:1.9.0.2
	gdb_5_2-2002-03-03-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.8
	gdb_5_1_0_1-2002-01-03-release:1.8
	cygnus_cvs_20020108_pre:1.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.8
	gdb_5_1_0_1-2002-01-03-branch:1.8.0.6
	gdb_5_1-2001-11-21-release:1.8
	gdb_s390-2001-09-26-branch:1.8.0.4
	gdb_s390-2001-09-26-branchpoint:1.8
	gdb_5_1-2001-07-29-branch:1.8.0.2
	gdb_5_1-2001-07-29-branchpoint:1.8
	dberlin-typesystem-branch:1.6.0.2
	dberlin-typesystem-branchpoint:1.6
	gdb-post-ptid_t-2001-05-03:1.6
	gdb-pre-ptid_t-2001-05-03:1.6
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.11
date	2003.10.06.19.10.44;	author cagney;	state dead;
branches;
next	1.10;

1.10
date	2003.04.16.14.32.21;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.10.04.08.42;	author cagney;	state Exp;
branches
	1.9.16.1
	1.9.18.1;
next	1.8;

1.8
date	2001.07.15.20.34.14;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.11.17.52.32;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.06.08.21.17;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.10.20.07.24;	author msnyder;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.05;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.05;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.10.12;	author jsm;	state Exp;
branches;
next	;

1.9.16.1
date	2003.04.16.19.56.54;	author carlton;	state Exp;
branches;
next	1.9.16.2;

1.9.16.2
date	2003.11.11.23.50.57;	author carlton;	state dead;
branches;
next	;

1.9.18.1
date	2003.12.14.20.27.30;	author drow;	state dead;
branches;
next	;


desc
@@


1.11
log
@2003-10-06  Andrew Cagney  <cagney@@redhat.com>

	* z8k-tdep.c, symm-tdep.c, symm-nat.c: Delete obsolete file.
	* sparclet-stub.c, sparclet-rom.c: Delete obsolete file.
	* sparcl-tdep.c, sparcl-stub.c, h8500-tdep.c: Delete obsolete file.
	* m3-nat.c, mipsm3-nat.c, mn10200-tdep.c: Delete obsolete file.
@
text
@// OBSOLETE /* Remote target glue for the SPARC Sparclet ROM monitor.
// OBSOLETE 
// OBSOLETE    Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free
// OBSOLETE    Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "monitor.h"
// OBSOLETE #include "serial.h"
// OBSOLETE #include "srec.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "symfile.h"		/* for generic_load */
// OBSOLETE #include "regcache.h"
// OBSOLETE #include <time.h>
// OBSOLETE 
// OBSOLETE extern void report_transfer_performance (unsigned long, time_t, time_t);
// OBSOLETE 
// OBSOLETE static struct target_ops sparclet_ops;
// OBSOLETE 
// OBSOLETE static void sparclet_open (char *args, int from_tty);
// OBSOLETE 
// OBSOLETE /* This array of registers need to match the indexes used by GDB.
// OBSOLETE    This exists because the various ROM monitors use different strings
// OBSOLETE    than does GDB, and don't necessarily support all the registers
// OBSOLETE    either. So, typing "info reg sp" becomes a "r30".  */
// OBSOLETE 
// OBSOLETE /*PSR 0x00000080  impl ver icc AW LE EE EC EF PIL S PS ET CWP  WIM
// OBSOLETE    0x0  0x0 0x0  0  0  0  0  0 0x0 1  0  0 0x00 0x2
// OBSOLETE    0000010
// OBSOLETE    INS        LOCALS       OUTS      GLOBALS
// OBSOLETE    0  0x00000000  0x00000000  0x00000000  0x00000000
// OBSOLETE    1  0x00000000  0x00000000  0x00000000  0x00000000
// OBSOLETE    2  0x00000000  0x00000000  0x00000000  0x00000000
// OBSOLETE    3  0x00000000  0x00000000  0x00000000  0x00000000
// OBSOLETE    4  0x00000000  0x00000000  0x00000000  0x00000000
// OBSOLETE    5  0x00000000  0x00001000  0x00000000  0x00000000
// OBSOLETE    6  0x00000000  0x00000000  0x123f0000  0x00000000
// OBSOLETE    7  0x00000000  0x00000000  0x00000000  0x00000000
// OBSOLETE    pc:  0x12010000 0x00000000    unimp
// OBSOLETE    npc: 0x12010004 0x00001000    unimp     0x1000
// OBSOLETE    tbr: 0x00000000
// OBSOLETE    y:   0x00000000
// OBSOLETE  */
// OBSOLETE /* these correspond to the offsets from tm-* files from config directories */
// OBSOLETE 
// OBSOLETE /* is wim part of psr?? */
// OBSOLETE /* monitor wants lower case */
// OBSOLETE static char *sparclet_regnames[] = {
// OBSOLETE   "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7", 
// OBSOLETE   "o0", "o1", "o2", "o3", "o4", "o5", "o6", "o7", 
// OBSOLETE   "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7", 
// OBSOLETE   "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", 
// OBSOLETE 
// OBSOLETE   "", "", "", "", "", "", "", "", /* no FPU regs */
// OBSOLETE   "", "", "", "", "", "", "", "", 
// OBSOLETE   "", "", "", "", "", "", "", "", 
// OBSOLETE   "", "", "", "", "", "", "", "", 
// OBSOLETE 				  /* no CPSR, FPSR */
// OBSOLETE   "y", "psr", "wim", "tbr", "pc", "npc", "", "", 
// OBSOLETE 
// OBSOLETE   "ccsr", "ccpr", "cccrcr", "ccor", "ccobr", "ccibr", "ccir", "", 
// OBSOLETE 
// OBSOLETE   /*       ASR15                 ASR19 (don't display them) */  
// OBSOLETE   "asr1",  "", "asr17", "asr18", "", "asr20", "asr21", "asr22", 
// OBSOLETE /*
// OBSOLETE   "awr0",  "awr1",  "awr2",  "awr3",  "awr4",  "awr5",  "awr6",  "awr7",  
// OBSOLETE   "awr8",  "awr9",  "awr10", "awr11", "awr12", "awr13", "awr14", "awr15", 
// OBSOLETE   "awr16", "awr17", "awr18", "awr19", "awr20", "awr21", "awr22", "awr23", 
// OBSOLETE   "awr24", "awr25", "awr26", "awr27", "awr28", "awr29", "awr30", "awr31", 
// OBSOLETE   "apsr",
// OBSOLETE  */
// OBSOLETE };
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Function: sparclet_supply_register
// OBSOLETE    Just returns with no action.
// OBSOLETE    This function is required, because parse_register_dump (monitor.c)
// OBSOLETE    expects to be able to call it.  If we don't supply something, it will
// OBSOLETE    call a null pointer and core-dump.  Since this function does not 
// OBSOLETE    actually do anything, GDB will request the registers individually.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclet_supply_register (char *regname, int regnamelen, char *val, int vallen)
// OBSOLETE {
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclet_load (struct serial *desc, char *file, int hashmark)
// OBSOLETE {
// OBSOLETE   bfd *abfd;
// OBSOLETE   asection *s;
// OBSOLETE   int i;
// OBSOLETE   CORE_ADDR load_offset;
// OBSOLETE   time_t start_time, end_time;
// OBSOLETE   unsigned long data_count = 0;
// OBSOLETE 
// OBSOLETE   /* enable user to specify address for downloading as 2nd arg to load */
// OBSOLETE 
// OBSOLETE   i = sscanf (file, "%*s 0x%lx", &load_offset);
// OBSOLETE   if (i >= 1)
// OBSOLETE     {
// OBSOLETE       char *p;
// OBSOLETE 
// OBSOLETE       for (p = file; *p != '\000' && !isspace (*p); p++);
// OBSOLETE 
// OBSOLETE       *p = '\000';
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     load_offset = 0;
// OBSOLETE 
// OBSOLETE   abfd = bfd_openr (file, 0);
// OBSOLETE   if (!abfd)
// OBSOLETE     {
// OBSOLETE       printf_filtered ("Unable to open file %s\n", file);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (bfd_check_format (abfd, bfd_object) == 0)
// OBSOLETE     {
// OBSOLETE       printf_filtered ("File is not an object file\n");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   start_time = time (NULL);
// OBSOLETE 
// OBSOLETE   for (s = abfd->sections; s; s = s->next)
// OBSOLETE     if (s->flags & SEC_LOAD)
// OBSOLETE       {
// OBSOLETE 	bfd_size_type section_size;
// OBSOLETE 	bfd_vma vma;
// OBSOLETE 
// OBSOLETE 	vma = bfd_get_section_vma (abfd, s) + load_offset;
// OBSOLETE 	section_size = bfd_section_size (abfd, s);
// OBSOLETE 
// OBSOLETE 	data_count += section_size;
// OBSOLETE 
// OBSOLETE 	printf_filtered ("%s\t: 0x%4x .. 0x%4x  ",
// OBSOLETE 			 bfd_get_section_name (abfd, s), vma,
// OBSOLETE 			 vma + section_size);
// OBSOLETE 	gdb_flush (gdb_stdout);
// OBSOLETE 
// OBSOLETE 	monitor_printf ("load c r %x %x\r", vma, section_size);
// OBSOLETE 
// OBSOLETE 	monitor_expect ("load: loading ", NULL, 0);
// OBSOLETE 	monitor_expect ("\r", NULL, 0);
// OBSOLETE 
// OBSOLETE 	for (i = 0; i < section_size; i += 2048)
// OBSOLETE 	  {
// OBSOLETE 	    int numbytes;
// OBSOLETE 	    char buf[2048];
// OBSOLETE 
// OBSOLETE 	    numbytes = min (sizeof buf, section_size - i);
// OBSOLETE 
// OBSOLETE 	    bfd_get_section_contents (abfd, s, buf, i, numbytes);
// OBSOLETE 
// OBSOLETE 	    serial_write (desc, buf, numbytes);
// OBSOLETE 
// OBSOLETE 	    if (hashmark)
// OBSOLETE 	      {
// OBSOLETE 		putchar_unfiltered ('#');
// OBSOLETE 		gdb_flush (gdb_stdout);
// OBSOLETE 	      }
// OBSOLETE 	  }			/* Per-packet (or S-record) loop */
// OBSOLETE 
// OBSOLETE 	monitor_expect_prompt (NULL, 0);
// OBSOLETE 
// OBSOLETE 	putchar_unfiltered ('\n');
// OBSOLETE       }				/* Loadable sections */
// OBSOLETE 
// OBSOLETE   monitor_printf ("reg pc %x\r", bfd_get_start_address (abfd));
// OBSOLETE   monitor_expect_prompt (NULL, 0);
// OBSOLETE   monitor_printf ("reg npc %x\r", bfd_get_start_address (abfd) + 4);
// OBSOLETE   monitor_expect_prompt (NULL, 0);
// OBSOLETE 
// OBSOLETE   monitor_printf ("run\r");
// OBSOLETE 
// OBSOLETE   end_time = time (NULL);
// OBSOLETE 
// OBSOLETE   if (hashmark)
// OBSOLETE     putchar_unfiltered ('\n');
// OBSOLETE 
// OBSOLETE   report_transfer_performance (data_count, start_time, end_time);
// OBSOLETE 
// OBSOLETE   pop_target ();
// OBSOLETE   push_remote_target (monitor_get_dev_name (), 1);
// OBSOLETE 
// OBSOLETE   throw_exception (RETURN_QUIT);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Define the monitor command strings. Since these are passed directly
// OBSOLETE    through to a printf style function, we may include formatting
// OBSOLETE    strings. We also need a CR or LF on the end.  */
// OBSOLETE 
// OBSOLETE /* need to pause the monitor for timing reasons, so slow it down */
// OBSOLETE 
// OBSOLETE static char *sparclet_inits[] =
// OBSOLETE {"\n\r\r\n", NULL};
// OBSOLETE 
// OBSOLETE static struct monitor_ops sparclet_cmds;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_sparclet_cmds (void)
// OBSOLETE {
// OBSOLETE   sparclet_cmds.flags = MO_CLR_BREAK_USES_ADDR |
// OBSOLETE     MO_HEX_PREFIX |
// OBSOLETE     MO_NO_ECHO_ON_OPEN |
// OBSOLETE     MO_NO_ECHO_ON_SETMEM |
// OBSOLETE     MO_RUN_FIRST_TIME |
// OBSOLETE     MO_GETMEM_READ_SINGLE;	/* flags */
// OBSOLETE   sparclet_cmds.init = sparclet_inits;	/* Init strings */
// OBSOLETE   sparclet_cmds.cont = "cont\r";	/* continue command */
// OBSOLETE   sparclet_cmds.step = "step\r";	/* single step */
// OBSOLETE   sparclet_cmds.stop = "\r";	/* break interrupts the program */
// OBSOLETE   sparclet_cmds.set_break = "+bp %x\r";		/* set a breakpoint */
// OBSOLETE   sparclet_cmds.clr_break = "-bp %x\r";		/* can't use "br" because only 2 hw bps are supported */
// OBSOLETE   sparclet_cmds.clr_all_break = "-bp %x\r";	/* clear a breakpoint */
// OBSOLETE   "-bp\r";			/* clear all breakpoints */
// OBSOLETE   sparclet_cmds.fill = "fill %x -n %x -v %x -b\r";	/* fill (start length val) */
// OBSOLETE   /* can't use "fi" because it takes words, not bytes */
// OBSOLETE   /* ex [addr] [-n count] [-b|-s|-l]          default: ex cur -n 1 -b */
// OBSOLETE   sparclet_cmds.setmem.cmdb = "ex %x -b\r%x\rq\r";	/* setmem.cmdb (addr, value) */
// OBSOLETE   sparclet_cmds.setmem.cmdw = "ex %x -s\r%x\rq\r";	/* setmem.cmdw (addr, value) */
// OBSOLETE   sparclet_cmds.setmem.cmdl = "ex %x -l\r%x\rq\r";	/* setmem.cmdl (addr, value) */
// OBSOLETE   sparclet_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
// OBSOLETE   sparclet_cmds.setmem.resp_delim = NULL;	/*": " *//* setmem.resp_delim */
// OBSOLETE   sparclet_cmds.setmem.term = NULL;	/*"? " *//* setmem.term */
// OBSOLETE   sparclet_cmds.setmem.term_cmd = NULL;		/*"q\r" *//* setmem.term_cmd */
// OBSOLETE   /* since the parsing of multiple bytes is difficult due to
// OBSOLETE      interspersed addresses, we'll only read 1 value at a time,
// OBSOLETE      even tho these can handle a count */
// OBSOLETE   /* we can use -n to set count to read, but may have to parse? */
// OBSOLETE   sparclet_cmds.getmem.cmdb = "ex %x -n 1 -b\r";	/* getmem.cmdb (addr, #bytes) */
// OBSOLETE   sparclet_cmds.getmem.cmdw = "ex %x -n 1 -s\r";	/* getmem.cmdw (addr, #swords) */
// OBSOLETE   sparclet_cmds.getmem.cmdl = "ex %x -n 1 -l\r";	/* getmem.cmdl (addr, #words) */
// OBSOLETE   sparclet_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, #dwords) */
// OBSOLETE   sparclet_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
// OBSOLETE   sparclet_cmds.getmem.term = NULL;	/* getmem.term */
// OBSOLETE   sparclet_cmds.getmem.term_cmd = NULL;		/* getmem.term_cmd */
// OBSOLETE   sparclet_cmds.setreg.cmd = "reg %s 0x%x\r";	/* setreg.cmd (name, value) */
// OBSOLETE   sparclet_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
// OBSOLETE   sparclet_cmds.setreg.term = NULL;	/* setreg.term */
// OBSOLETE   sparclet_cmds.setreg.term_cmd = NULL;		/* setreg.term_cmd */
// OBSOLETE   sparclet_cmds.getreg.cmd = "reg %s\r";	/* getreg.cmd (name) */
// OBSOLETE   sparclet_cmds.getreg.resp_delim = " ";	/* getreg.resp_delim */
// OBSOLETE   sparclet_cmds.getreg.term = NULL;	/* getreg.term */
// OBSOLETE   sparclet_cmds.getreg.term_cmd = NULL;		/* getreg.term_cmd */
// OBSOLETE   sparclet_cmds.dump_registers = "reg\r";	/* dump_registers */
// OBSOLETE   sparclet_cmds.register_pattern = "\\(\\w+\\)=\\([0-9a-fA-F]+\\)";	/* register_pattern */
// OBSOLETE   sparclet_cmds.supply_register = sparclet_supply_register;	/* supply_register */
// OBSOLETE   sparclet_cmds.load_routine = sparclet_load;	/* load_routine */
// OBSOLETE   sparclet_cmds.load = NULL;	/* download command (srecs on console) */
// OBSOLETE   sparclet_cmds.loadresp = NULL;	/* load response */
// OBSOLETE   sparclet_cmds.prompt = "monitor>";	/* monitor command prompt */
// OBSOLETE   /* yikes!  gdb core dumps without this delimitor!! */
// OBSOLETE   sparclet_cmds.line_term = "\r";	/* end-of-command delimitor */
// OBSOLETE   sparclet_cmds.cmd_end = NULL;	/* optional command terminator */
// OBSOLETE   sparclet_cmds.target = &sparclet_ops;		/* target operations */
// OBSOLETE   sparclet_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
// OBSOLETE   sparclet_cmds.regnames = sparclet_regnames;	/* registers names */
// OBSOLETE   sparclet_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclet_open (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   monitor_open (args, &sparclet_cmds, from_tty);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_sparclet (void)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   init_sparclet_cmds ();
// OBSOLETE 
// OBSOLETE   for (i = 0; i < NUM_REGS; i++)
// OBSOLETE     if (sparclet_regnames[i][0] == 'c' ||
// OBSOLETE 	sparclet_regnames[i][0] == 'a')
// OBSOLETE       sparclet_regnames[i] = 0;	/* mon can't report c* or a* regs */
// OBSOLETE 
// OBSOLETE   sparclet_regnames[0] = 0;	/* mon won't report %G0 */
// OBSOLETE 
// OBSOLETE   init_monitor_ops (&sparclet_ops);
// OBSOLETE   sparclet_ops.to_shortname = "sparclet";	/* for the target command */
// OBSOLETE   sparclet_ops.to_longname = "SPARC Sparclet monitor";
// OBSOLETE   /* use SW breaks; target only supports 2 HW breakpoints */
// OBSOLETE   sparclet_ops.to_insert_breakpoint = memory_insert_breakpoint;
// OBSOLETE   sparclet_ops.to_remove_breakpoint = memory_remove_breakpoint;
// OBSOLETE 
// OBSOLETE   sparclet_ops.to_doc =
// OBSOLETE     "Use a board running the Sparclet debug monitor.\n\
// OBSOLETE Specify the serial device it is connected to (e.g. /dev/ttya).";
// OBSOLETE 
// OBSOLETE   sparclet_ops.to_open = sparclet_open;
// OBSOLETE   add_target (&sparclet_ops);
// OBSOLETE }
@


1.10
log
@2003-04-16  Andrew Cagney  <cagney@@redhat.com>

	* NEWS: Mention that sparclet-*-* and sparclite-*-* have been made
	obsolete.
	* sparc-tdep.c: Obsolete SPARCLET and SPARCLITE code.
	* sparcl-stub.c: Obsolete file.
	* config/sparc/tm-sparclet.h: Obsolete file.
	* sparclet-stub.c: Obsolete file.
	* sparclet-rom.c: Obsolete file.
	* sparcl-tdep.c: Obsolete file.
	* config/sparc/tm-sparclite.h: Obsolete file.
	* config/sparc/sparclite.mt: Obsolete file.
	* config/sparc/sparclet.mt: Obsolete file.
	* configure.tgt: Make sparclet-*-*, sparclite-*-*, and
	sparc86x-*-* obsolete.
@
text
@@


1.9
log
@* defs.h (throw_exception): Rename return_to_top_level.  Update
comments.
* utils.c (error_stream, internal_verror, quit): Ditto.
* top.c (throw_exception, catcher): Ditto.
* sparclet-rom.c (sparclet_load): Ditto.
* remote.c (interrupt_query, minitelnet): Ditto.
* remote-sds.c (interrupt_query): Ditto.
* remote-mips.c (mips_error, mips_kill): Ditto.
* ocd.c (interrupt_query): Ditto.
* monitor.c (monitor_interrupt_query): Ditto.
* m3-nat.c (suspend_all_threads, thread_resume_command): Ditto.
* target.h: Update comment.

* m3-nat.c, ocd.c, sparclet-rom.c: Update copyright.
@
text
@d1 316
a316 316
/* Remote target glue for the SPARC Sparclet ROM monitor.

   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free
   Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */


#include "defs.h"
#include "gdbcore.h"
#include "target.h"
#include "monitor.h"
#include "serial.h"
#include "srec.h"
#include "symtab.h"
#include "symfile.h"		/* for generic_load */
#include "regcache.h"
#include <time.h>

extern void report_transfer_performance (unsigned long, time_t, time_t);

static struct target_ops sparclet_ops;

static void sparclet_open (char *args, int from_tty);

/* This array of registers need to match the indexes used by GDB.
   This exists because the various ROM monitors use different strings
   than does GDB, and don't necessarily support all the registers
   either. So, typing "info reg sp" becomes a "r30".  */

/*PSR 0x00000080  impl ver icc AW LE EE EC EF PIL S PS ET CWP  WIM
   0x0  0x0 0x0  0  0  0  0  0 0x0 1  0  0 0x00 0x2
   0000010
   INS        LOCALS       OUTS      GLOBALS
   0  0x00000000  0x00000000  0x00000000  0x00000000
   1  0x00000000  0x00000000  0x00000000  0x00000000
   2  0x00000000  0x00000000  0x00000000  0x00000000
   3  0x00000000  0x00000000  0x00000000  0x00000000
   4  0x00000000  0x00000000  0x00000000  0x00000000
   5  0x00000000  0x00001000  0x00000000  0x00000000
   6  0x00000000  0x00000000  0x123f0000  0x00000000
   7  0x00000000  0x00000000  0x00000000  0x00000000
   pc:  0x12010000 0x00000000    unimp
   npc: 0x12010004 0x00001000    unimp     0x1000
   tbr: 0x00000000
   y:   0x00000000
 */
/* these correspond to the offsets from tm-* files from config directories */

/* is wim part of psr?? */
/* monitor wants lower case */
static char *sparclet_regnames[] = {
  "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7", 
  "o0", "o1", "o2", "o3", "o4", "o5", "o6", "o7", 
  "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7", 
  "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", 

  "", "", "", "", "", "", "", "", /* no FPU regs */
  "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", 
				  /* no CPSR, FPSR */
  "y", "psr", "wim", "tbr", "pc", "npc", "", "", 

  "ccsr", "ccpr", "cccrcr", "ccor", "ccobr", "ccibr", "ccir", "", 

  /*       ASR15                 ASR19 (don't display them) */  
  "asr1",  "", "asr17", "asr18", "", "asr20", "asr21", "asr22", 
/*
  "awr0",  "awr1",  "awr2",  "awr3",  "awr4",  "awr5",  "awr6",  "awr7",  
  "awr8",  "awr9",  "awr10", "awr11", "awr12", "awr13", "awr14", "awr15", 
  "awr16", "awr17", "awr18", "awr19", "awr20", "awr21", "awr22", "awr23", 
  "awr24", "awr25", "awr26", "awr27", "awr28", "awr29", "awr30", "awr31", 
  "apsr",
 */
};



/* Function: sparclet_supply_register
   Just returns with no action.
   This function is required, because parse_register_dump (monitor.c)
   expects to be able to call it.  If we don't supply something, it will
   call a null pointer and core-dump.  Since this function does not 
   actually do anything, GDB will request the registers individually.  */

static void
sparclet_supply_register (char *regname, int regnamelen, char *val, int vallen)
{
  return;
}

static void
sparclet_load (struct serial *desc, char *file, int hashmark)
{
  bfd *abfd;
  asection *s;
  int i;
  CORE_ADDR load_offset;
  time_t start_time, end_time;
  unsigned long data_count = 0;

  /* enable user to specify address for downloading as 2nd arg to load */

  i = sscanf (file, "%*s 0x%lx", &load_offset);
  if (i >= 1)
    {
      char *p;

      for (p = file; *p != '\000' && !isspace (*p); p++);

      *p = '\000';
    }
  else
    load_offset = 0;

  abfd = bfd_openr (file, 0);
  if (!abfd)
    {
      printf_filtered ("Unable to open file %s\n", file);
      return;
    }

  if (bfd_check_format (abfd, bfd_object) == 0)
    {
      printf_filtered ("File is not an object file\n");
      return;
    }

  start_time = time (NULL);

  for (s = abfd->sections; s; s = s->next)
    if (s->flags & SEC_LOAD)
      {
	bfd_size_type section_size;
	bfd_vma vma;

	vma = bfd_get_section_vma (abfd, s) + load_offset;
	section_size = bfd_section_size (abfd, s);

	data_count += section_size;

	printf_filtered ("%s\t: 0x%4x .. 0x%4x  ",
			 bfd_get_section_name (abfd, s), vma,
			 vma + section_size);
	gdb_flush (gdb_stdout);

	monitor_printf ("load c r %x %x\r", vma, section_size);

	monitor_expect ("load: loading ", NULL, 0);
	monitor_expect ("\r", NULL, 0);

	for (i = 0; i < section_size; i += 2048)
	  {
	    int numbytes;
	    char buf[2048];

	    numbytes = min (sizeof buf, section_size - i);

	    bfd_get_section_contents (abfd, s, buf, i, numbytes);

	    serial_write (desc, buf, numbytes);

	    if (hashmark)
	      {
		putchar_unfiltered ('#');
		gdb_flush (gdb_stdout);
	      }
	  }			/* Per-packet (or S-record) loop */

	monitor_expect_prompt (NULL, 0);

	putchar_unfiltered ('\n');
      }				/* Loadable sections */

  monitor_printf ("reg pc %x\r", bfd_get_start_address (abfd));
  monitor_expect_prompt (NULL, 0);
  monitor_printf ("reg npc %x\r", bfd_get_start_address (abfd) + 4);
  monitor_expect_prompt (NULL, 0);

  monitor_printf ("run\r");

  end_time = time (NULL);

  if (hashmark)
    putchar_unfiltered ('\n');

  report_transfer_performance (data_count, start_time, end_time);

  pop_target ();
  push_remote_target (monitor_get_dev_name (), 1);

  throw_exception (RETURN_QUIT);
}

/* Define the monitor command strings. Since these are passed directly
   through to a printf style function, we may include formatting
   strings. We also need a CR or LF on the end.  */

/* need to pause the monitor for timing reasons, so slow it down */

static char *sparclet_inits[] =
{"\n\r\r\n", NULL};

static struct monitor_ops sparclet_cmds;

static void
init_sparclet_cmds (void)
{
  sparclet_cmds.flags = MO_CLR_BREAK_USES_ADDR |
    MO_HEX_PREFIX |
    MO_NO_ECHO_ON_OPEN |
    MO_NO_ECHO_ON_SETMEM |
    MO_RUN_FIRST_TIME |
    MO_GETMEM_READ_SINGLE;	/* flags */
  sparclet_cmds.init = sparclet_inits;	/* Init strings */
  sparclet_cmds.cont = "cont\r";	/* continue command */
  sparclet_cmds.step = "step\r";	/* single step */
  sparclet_cmds.stop = "\r";	/* break interrupts the program */
  sparclet_cmds.set_break = "+bp %x\r";		/* set a breakpoint */
  sparclet_cmds.clr_break = "-bp %x\r";		/* can't use "br" because only 2 hw bps are supported */
  sparclet_cmds.clr_all_break = "-bp %x\r";	/* clear a breakpoint */
  "-bp\r";			/* clear all breakpoints */
  sparclet_cmds.fill = "fill %x -n %x -v %x -b\r";	/* fill (start length val) */
  /* can't use "fi" because it takes words, not bytes */
  /* ex [addr] [-n count] [-b|-s|-l]          default: ex cur -n 1 -b */
  sparclet_cmds.setmem.cmdb = "ex %x -b\r%x\rq\r";	/* setmem.cmdb (addr, value) */
  sparclet_cmds.setmem.cmdw = "ex %x -s\r%x\rq\r";	/* setmem.cmdw (addr, value) */
  sparclet_cmds.setmem.cmdl = "ex %x -l\r%x\rq\r";	/* setmem.cmdl (addr, value) */
  sparclet_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
  sparclet_cmds.setmem.resp_delim = NULL;	/*": " *//* setmem.resp_delim */
  sparclet_cmds.setmem.term = NULL;	/*"? " *//* setmem.term */
  sparclet_cmds.setmem.term_cmd = NULL;		/*"q\r" *//* setmem.term_cmd */
  /* since the parsing of multiple bytes is difficult due to
     interspersed addresses, we'll only read 1 value at a time,
     even tho these can handle a count */
  /* we can use -n to set count to read, but may have to parse? */
  sparclet_cmds.getmem.cmdb = "ex %x -n 1 -b\r";	/* getmem.cmdb (addr, #bytes) */
  sparclet_cmds.getmem.cmdw = "ex %x -n 1 -s\r";	/* getmem.cmdw (addr, #swords) */
  sparclet_cmds.getmem.cmdl = "ex %x -n 1 -l\r";	/* getmem.cmdl (addr, #words) */
  sparclet_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, #dwords) */
  sparclet_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
  sparclet_cmds.getmem.term = NULL;	/* getmem.term */
  sparclet_cmds.getmem.term_cmd = NULL;		/* getmem.term_cmd */
  sparclet_cmds.setreg.cmd = "reg %s 0x%x\r";	/* setreg.cmd (name, value) */
  sparclet_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
  sparclet_cmds.setreg.term = NULL;	/* setreg.term */
  sparclet_cmds.setreg.term_cmd = NULL;		/* setreg.term_cmd */
  sparclet_cmds.getreg.cmd = "reg %s\r";	/* getreg.cmd (name) */
  sparclet_cmds.getreg.resp_delim = " ";	/* getreg.resp_delim */
  sparclet_cmds.getreg.term = NULL;	/* getreg.term */
  sparclet_cmds.getreg.term_cmd = NULL;		/* getreg.term_cmd */
  sparclet_cmds.dump_registers = "reg\r";	/* dump_registers */
  sparclet_cmds.register_pattern = "\\(\\w+\\)=\\([0-9a-fA-F]+\\)";	/* register_pattern */
  sparclet_cmds.supply_register = sparclet_supply_register;	/* supply_register */
  sparclet_cmds.load_routine = sparclet_load;	/* load_routine */
  sparclet_cmds.load = NULL;	/* download command (srecs on console) */
  sparclet_cmds.loadresp = NULL;	/* load response */
  sparclet_cmds.prompt = "monitor>";	/* monitor command prompt */
  /* yikes!  gdb core dumps without this delimitor!! */
  sparclet_cmds.line_term = "\r";	/* end-of-command delimitor */
  sparclet_cmds.cmd_end = NULL;	/* optional command terminator */
  sparclet_cmds.target = &sparclet_ops;		/* target operations */
  sparclet_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
  sparclet_cmds.regnames = sparclet_regnames;	/* registers names */
  sparclet_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
};

static void
sparclet_open (char *args, int from_tty)
{
  monitor_open (args, &sparclet_cmds, from_tty);
}

void
_initialize_sparclet (void)
{
  int i;
  init_sparclet_cmds ();

  for (i = 0; i < NUM_REGS; i++)
    if (sparclet_regnames[i][0] == 'c' ||
	sparclet_regnames[i][0] == 'a')
      sparclet_regnames[i] = 0;	/* mon can't report c* or a* regs */

  sparclet_regnames[0] = 0;	/* mon won't report %G0 */

  init_monitor_ops (&sparclet_ops);
  sparclet_ops.to_shortname = "sparclet";	/* for the target command */
  sparclet_ops.to_longname = "SPARC Sparclet monitor";
  /* use SW breaks; target only supports 2 HW breakpoints */
  sparclet_ops.to_insert_breakpoint = memory_insert_breakpoint;
  sparclet_ops.to_remove_breakpoint = memory_remove_breakpoint;

  sparclet_ops.to_doc =
    "Use a board running the Sparclet debug monitor.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";

  sparclet_ops.to_open = sparclet_open;
  add_target (&sparclet_ops);
}
@


1.9.18.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.9.16.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d1 316
a316 316
// OBSOLETE /* Remote target glue for the SPARC Sparclet ROM monitor.
// OBSOLETE 
// OBSOLETE    Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free
// OBSOLETE    Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "monitor.h"
// OBSOLETE #include "serial.h"
// OBSOLETE #include "srec.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "symfile.h"		/* for generic_load */
// OBSOLETE #include "regcache.h"
// OBSOLETE #include <time.h>
// OBSOLETE 
// OBSOLETE extern void report_transfer_performance (unsigned long, time_t, time_t);
// OBSOLETE 
// OBSOLETE static struct target_ops sparclet_ops;
// OBSOLETE 
// OBSOLETE static void sparclet_open (char *args, int from_tty);
// OBSOLETE 
// OBSOLETE /* This array of registers need to match the indexes used by GDB.
// OBSOLETE    This exists because the various ROM monitors use different strings
// OBSOLETE    than does GDB, and don't necessarily support all the registers
// OBSOLETE    either. So, typing "info reg sp" becomes a "r30".  */
// OBSOLETE 
// OBSOLETE /*PSR 0x00000080  impl ver icc AW LE EE EC EF PIL S PS ET CWP  WIM
// OBSOLETE    0x0  0x0 0x0  0  0  0  0  0 0x0 1  0  0 0x00 0x2
// OBSOLETE    0000010
// OBSOLETE    INS        LOCALS       OUTS      GLOBALS
// OBSOLETE    0  0x00000000  0x00000000  0x00000000  0x00000000
// OBSOLETE    1  0x00000000  0x00000000  0x00000000  0x00000000
// OBSOLETE    2  0x00000000  0x00000000  0x00000000  0x00000000
// OBSOLETE    3  0x00000000  0x00000000  0x00000000  0x00000000
// OBSOLETE    4  0x00000000  0x00000000  0x00000000  0x00000000
// OBSOLETE    5  0x00000000  0x00001000  0x00000000  0x00000000
// OBSOLETE    6  0x00000000  0x00000000  0x123f0000  0x00000000
// OBSOLETE    7  0x00000000  0x00000000  0x00000000  0x00000000
// OBSOLETE    pc:  0x12010000 0x00000000    unimp
// OBSOLETE    npc: 0x12010004 0x00001000    unimp     0x1000
// OBSOLETE    tbr: 0x00000000
// OBSOLETE    y:   0x00000000
// OBSOLETE  */
// OBSOLETE /* these correspond to the offsets from tm-* files from config directories */
// OBSOLETE 
// OBSOLETE /* is wim part of psr?? */
// OBSOLETE /* monitor wants lower case */
// OBSOLETE static char *sparclet_regnames[] = {
// OBSOLETE   "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7", 
// OBSOLETE   "o0", "o1", "o2", "o3", "o4", "o5", "o6", "o7", 
// OBSOLETE   "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7", 
// OBSOLETE   "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", 
// OBSOLETE 
// OBSOLETE   "", "", "", "", "", "", "", "", /* no FPU regs */
// OBSOLETE   "", "", "", "", "", "", "", "", 
// OBSOLETE   "", "", "", "", "", "", "", "", 
// OBSOLETE   "", "", "", "", "", "", "", "", 
// OBSOLETE 				  /* no CPSR, FPSR */
// OBSOLETE   "y", "psr", "wim", "tbr", "pc", "npc", "", "", 
// OBSOLETE 
// OBSOLETE   "ccsr", "ccpr", "cccrcr", "ccor", "ccobr", "ccibr", "ccir", "", 
// OBSOLETE 
// OBSOLETE   /*       ASR15                 ASR19 (don't display them) */  
// OBSOLETE   "asr1",  "", "asr17", "asr18", "", "asr20", "asr21", "asr22", 
// OBSOLETE /*
// OBSOLETE   "awr0",  "awr1",  "awr2",  "awr3",  "awr4",  "awr5",  "awr6",  "awr7",  
// OBSOLETE   "awr8",  "awr9",  "awr10", "awr11", "awr12", "awr13", "awr14", "awr15", 
// OBSOLETE   "awr16", "awr17", "awr18", "awr19", "awr20", "awr21", "awr22", "awr23", 
// OBSOLETE   "awr24", "awr25", "awr26", "awr27", "awr28", "awr29", "awr30", "awr31", 
// OBSOLETE   "apsr",
// OBSOLETE  */
// OBSOLETE };
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Function: sparclet_supply_register
// OBSOLETE    Just returns with no action.
// OBSOLETE    This function is required, because parse_register_dump (monitor.c)
// OBSOLETE    expects to be able to call it.  If we don't supply something, it will
// OBSOLETE    call a null pointer and core-dump.  Since this function does not 
// OBSOLETE    actually do anything, GDB will request the registers individually.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclet_supply_register (char *regname, int regnamelen, char *val, int vallen)
// OBSOLETE {
// OBSOLETE   return;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclet_load (struct serial *desc, char *file, int hashmark)
// OBSOLETE {
// OBSOLETE   bfd *abfd;
// OBSOLETE   asection *s;
// OBSOLETE   int i;
// OBSOLETE   CORE_ADDR load_offset;
// OBSOLETE   time_t start_time, end_time;
// OBSOLETE   unsigned long data_count = 0;
// OBSOLETE 
// OBSOLETE   /* enable user to specify address for downloading as 2nd arg to load */
// OBSOLETE 
// OBSOLETE   i = sscanf (file, "%*s 0x%lx", &load_offset);
// OBSOLETE   if (i >= 1)
// OBSOLETE     {
// OBSOLETE       char *p;
// OBSOLETE 
// OBSOLETE       for (p = file; *p != '\000' && !isspace (*p); p++);
// OBSOLETE 
// OBSOLETE       *p = '\000';
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     load_offset = 0;
// OBSOLETE 
// OBSOLETE   abfd = bfd_openr (file, 0);
// OBSOLETE   if (!abfd)
// OBSOLETE     {
// OBSOLETE       printf_filtered ("Unable to open file %s\n", file);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (bfd_check_format (abfd, bfd_object) == 0)
// OBSOLETE     {
// OBSOLETE       printf_filtered ("File is not an object file\n");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   start_time = time (NULL);
// OBSOLETE 
// OBSOLETE   for (s = abfd->sections; s; s = s->next)
// OBSOLETE     if (s->flags & SEC_LOAD)
// OBSOLETE       {
// OBSOLETE 	bfd_size_type section_size;
// OBSOLETE 	bfd_vma vma;
// OBSOLETE 
// OBSOLETE 	vma = bfd_get_section_vma (abfd, s) + load_offset;
// OBSOLETE 	section_size = bfd_section_size (abfd, s);
// OBSOLETE 
// OBSOLETE 	data_count += section_size;
// OBSOLETE 
// OBSOLETE 	printf_filtered ("%s\t: 0x%4x .. 0x%4x  ",
// OBSOLETE 			 bfd_get_section_name (abfd, s), vma,
// OBSOLETE 			 vma + section_size);
// OBSOLETE 	gdb_flush (gdb_stdout);
// OBSOLETE 
// OBSOLETE 	monitor_printf ("load c r %x %x\r", vma, section_size);
// OBSOLETE 
// OBSOLETE 	monitor_expect ("load: loading ", NULL, 0);
// OBSOLETE 	monitor_expect ("\r", NULL, 0);
// OBSOLETE 
// OBSOLETE 	for (i = 0; i < section_size; i += 2048)
// OBSOLETE 	  {
// OBSOLETE 	    int numbytes;
// OBSOLETE 	    char buf[2048];
// OBSOLETE 
// OBSOLETE 	    numbytes = min (sizeof buf, section_size - i);
// OBSOLETE 
// OBSOLETE 	    bfd_get_section_contents (abfd, s, buf, i, numbytes);
// OBSOLETE 
// OBSOLETE 	    serial_write (desc, buf, numbytes);
// OBSOLETE 
// OBSOLETE 	    if (hashmark)
// OBSOLETE 	      {
// OBSOLETE 		putchar_unfiltered ('#');
// OBSOLETE 		gdb_flush (gdb_stdout);
// OBSOLETE 	      }
// OBSOLETE 	  }			/* Per-packet (or S-record) loop */
// OBSOLETE 
// OBSOLETE 	monitor_expect_prompt (NULL, 0);
// OBSOLETE 
// OBSOLETE 	putchar_unfiltered ('\n');
// OBSOLETE       }				/* Loadable sections */
// OBSOLETE 
// OBSOLETE   monitor_printf ("reg pc %x\r", bfd_get_start_address (abfd));
// OBSOLETE   monitor_expect_prompt (NULL, 0);
// OBSOLETE   monitor_printf ("reg npc %x\r", bfd_get_start_address (abfd) + 4);
// OBSOLETE   monitor_expect_prompt (NULL, 0);
// OBSOLETE 
// OBSOLETE   monitor_printf ("run\r");
// OBSOLETE 
// OBSOLETE   end_time = time (NULL);
// OBSOLETE 
// OBSOLETE   if (hashmark)
// OBSOLETE     putchar_unfiltered ('\n');
// OBSOLETE 
// OBSOLETE   report_transfer_performance (data_count, start_time, end_time);
// OBSOLETE 
// OBSOLETE   pop_target ();
// OBSOLETE   push_remote_target (monitor_get_dev_name (), 1);
// OBSOLETE 
// OBSOLETE   throw_exception (RETURN_QUIT);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Define the monitor command strings. Since these are passed directly
// OBSOLETE    through to a printf style function, we may include formatting
// OBSOLETE    strings. We also need a CR or LF on the end.  */
// OBSOLETE 
// OBSOLETE /* need to pause the monitor for timing reasons, so slow it down */
// OBSOLETE 
// OBSOLETE static char *sparclet_inits[] =
// OBSOLETE {"\n\r\r\n", NULL};
// OBSOLETE 
// OBSOLETE static struct monitor_ops sparclet_cmds;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_sparclet_cmds (void)
// OBSOLETE {
// OBSOLETE   sparclet_cmds.flags = MO_CLR_BREAK_USES_ADDR |
// OBSOLETE     MO_HEX_PREFIX |
// OBSOLETE     MO_NO_ECHO_ON_OPEN |
// OBSOLETE     MO_NO_ECHO_ON_SETMEM |
// OBSOLETE     MO_RUN_FIRST_TIME |
// OBSOLETE     MO_GETMEM_READ_SINGLE;	/* flags */
// OBSOLETE   sparclet_cmds.init = sparclet_inits;	/* Init strings */
// OBSOLETE   sparclet_cmds.cont = "cont\r";	/* continue command */
// OBSOLETE   sparclet_cmds.step = "step\r";	/* single step */
// OBSOLETE   sparclet_cmds.stop = "\r";	/* break interrupts the program */
// OBSOLETE   sparclet_cmds.set_break = "+bp %x\r";		/* set a breakpoint */
// OBSOLETE   sparclet_cmds.clr_break = "-bp %x\r";		/* can't use "br" because only 2 hw bps are supported */
// OBSOLETE   sparclet_cmds.clr_all_break = "-bp %x\r";	/* clear a breakpoint */
// OBSOLETE   "-bp\r";			/* clear all breakpoints */
// OBSOLETE   sparclet_cmds.fill = "fill %x -n %x -v %x -b\r";	/* fill (start length val) */
// OBSOLETE   /* can't use "fi" because it takes words, not bytes */
// OBSOLETE   /* ex [addr] [-n count] [-b|-s|-l]          default: ex cur -n 1 -b */
// OBSOLETE   sparclet_cmds.setmem.cmdb = "ex %x -b\r%x\rq\r";	/* setmem.cmdb (addr, value) */
// OBSOLETE   sparclet_cmds.setmem.cmdw = "ex %x -s\r%x\rq\r";	/* setmem.cmdw (addr, value) */
// OBSOLETE   sparclet_cmds.setmem.cmdl = "ex %x -l\r%x\rq\r";	/* setmem.cmdl (addr, value) */
// OBSOLETE   sparclet_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
// OBSOLETE   sparclet_cmds.setmem.resp_delim = NULL;	/*": " *//* setmem.resp_delim */
// OBSOLETE   sparclet_cmds.setmem.term = NULL;	/*"? " *//* setmem.term */
// OBSOLETE   sparclet_cmds.setmem.term_cmd = NULL;		/*"q\r" *//* setmem.term_cmd */
// OBSOLETE   /* since the parsing of multiple bytes is difficult due to
// OBSOLETE      interspersed addresses, we'll only read 1 value at a time,
// OBSOLETE      even tho these can handle a count */
// OBSOLETE   /* we can use -n to set count to read, but may have to parse? */
// OBSOLETE   sparclet_cmds.getmem.cmdb = "ex %x -n 1 -b\r";	/* getmem.cmdb (addr, #bytes) */
// OBSOLETE   sparclet_cmds.getmem.cmdw = "ex %x -n 1 -s\r";	/* getmem.cmdw (addr, #swords) */
// OBSOLETE   sparclet_cmds.getmem.cmdl = "ex %x -n 1 -l\r";	/* getmem.cmdl (addr, #words) */
// OBSOLETE   sparclet_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, #dwords) */
// OBSOLETE   sparclet_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
// OBSOLETE   sparclet_cmds.getmem.term = NULL;	/* getmem.term */
// OBSOLETE   sparclet_cmds.getmem.term_cmd = NULL;		/* getmem.term_cmd */
// OBSOLETE   sparclet_cmds.setreg.cmd = "reg %s 0x%x\r";	/* setreg.cmd (name, value) */
// OBSOLETE   sparclet_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
// OBSOLETE   sparclet_cmds.setreg.term = NULL;	/* setreg.term */
// OBSOLETE   sparclet_cmds.setreg.term_cmd = NULL;		/* setreg.term_cmd */
// OBSOLETE   sparclet_cmds.getreg.cmd = "reg %s\r";	/* getreg.cmd (name) */
// OBSOLETE   sparclet_cmds.getreg.resp_delim = " ";	/* getreg.resp_delim */
// OBSOLETE   sparclet_cmds.getreg.term = NULL;	/* getreg.term */
// OBSOLETE   sparclet_cmds.getreg.term_cmd = NULL;		/* getreg.term_cmd */
// OBSOLETE   sparclet_cmds.dump_registers = "reg\r";	/* dump_registers */
// OBSOLETE   sparclet_cmds.register_pattern = "\\(\\w+\\)=\\([0-9a-fA-F]+\\)";	/* register_pattern */
// OBSOLETE   sparclet_cmds.supply_register = sparclet_supply_register;	/* supply_register */
// OBSOLETE   sparclet_cmds.load_routine = sparclet_load;	/* load_routine */
// OBSOLETE   sparclet_cmds.load = NULL;	/* download command (srecs on console) */
// OBSOLETE   sparclet_cmds.loadresp = NULL;	/* load response */
// OBSOLETE   sparclet_cmds.prompt = "monitor>";	/* monitor command prompt */
// OBSOLETE   /* yikes!  gdb core dumps without this delimitor!! */
// OBSOLETE   sparclet_cmds.line_term = "\r";	/* end-of-command delimitor */
// OBSOLETE   sparclet_cmds.cmd_end = NULL;	/* optional command terminator */
// OBSOLETE   sparclet_cmds.target = &sparclet_ops;		/* target operations */
// OBSOLETE   sparclet_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
// OBSOLETE   sparclet_cmds.regnames = sparclet_regnames;	/* registers names */
// OBSOLETE   sparclet_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE sparclet_open (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   monitor_open (args, &sparclet_cmds, from_tty);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_sparclet (void)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   init_sparclet_cmds ();
// OBSOLETE 
// OBSOLETE   for (i = 0; i < NUM_REGS; i++)
// OBSOLETE     if (sparclet_regnames[i][0] == 'c' ||
// OBSOLETE 	sparclet_regnames[i][0] == 'a')
// OBSOLETE       sparclet_regnames[i] = 0;	/* mon can't report c* or a* regs */
// OBSOLETE 
// OBSOLETE   sparclet_regnames[0] = 0;	/* mon won't report %G0 */
// OBSOLETE 
// OBSOLETE   init_monitor_ops (&sparclet_ops);
// OBSOLETE   sparclet_ops.to_shortname = "sparclet";	/* for the target command */
// OBSOLETE   sparclet_ops.to_longname = "SPARC Sparclet monitor";
// OBSOLETE   /* use SW breaks; target only supports 2 HW breakpoints */
// OBSOLETE   sparclet_ops.to_insert_breakpoint = memory_insert_breakpoint;
// OBSOLETE   sparclet_ops.to_remove_breakpoint = memory_remove_breakpoint;
// OBSOLETE 
// OBSOLETE   sparclet_ops.to_doc =
// OBSOLETE     "Use a board running the Sparclet debug monitor.\n\
// OBSOLETE Specify the serial device it is connected to (e.g. /dev/ttya).";
// OBSOLETE 
// OBSOLETE   sparclet_ops.to_open = sparclet_open;
// OBSOLETE   add_target (&sparclet_ops);
// OBSOLETE }
@


1.9.16.2
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@@


1.8
log
@* serial.h (SERIAL_ASYNC): Delete.
(DEPRECATED_SERIAL_FD): Delete.
(SERIAL_DEBUG): Delete.
(SERIAL_DEBUG_P): Delete.
(SERIAL_DRAIN_OUTPUT): Delete.
(SERIAL_FLUSH_OUTPUT): Delete.
(SERIAL_FLUSH_INPUT): Delete.
(SERIAL_SEND_BREAK): Delete.
(SERIAL_RAW): Delete.
(SERIAL_GET_TTY_STATE): Delete.
(SERIAL_SET_TTY_STATE): Delete.
(SERIAL_PRINT_TTY_STATE): Delete.
(SERIAL_NOFLUSH_SET_TTY_STATE): Delete.
(SERIAL_SETBAUDRATE): Delete.
(SERIAL_SETSTOPBITS): Delete.
(SERIAL_CAN_ASYNC_P): Delete.
(SERIAL_IS_ASYNC_P): Delete.
(SERIAL_UN_FDOPEN): Delete.
(SERIAL_READCHAR): Delete.
(SERIAL_CLOSE): Delete.
(SERIAL_FDOPEN): Delete.
(SERIAL_OPEN): Delete.
@
text
@d2 3
a4 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d208 1
a208 1
  return_to_top_level (RETURN_QUIT);
@


1.7
log
@s/typedef serial_t/struct serial */
@
text
@d176 1
a176 1
	    SERIAL_WRITE (desc, buf, numbytes);
@


1.6
log
@Update/correct copyright notices.
@
text
@d108 1
a108 1
sparclet_load (serial_t desc, char *file, int hashmark)
@


1.5
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1995, 1996, 2001 Free Software Foundation, Inc.
@


1.4
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright 1995, 1996 Free Software Foundation, Inc.
d30 1
@


1.3
log
@PARAMS removal.
@
text
@d100 1
a100 5
sparclet_supply_register (regname, regnamelen, val, vallen)
     char *regname;
     int regnamelen;
     char *val;
     int vallen;
d106 1
a106 4
sparclet_load (desc, file, hashmark)
     serial_t desc;
     char *file;
     int hashmark;
d282 1
a282 3
sparclet_open (args, from_tty)
     char *args;
     int from_tty;
d288 1
a288 1
_initialize_sparclet ()
@


1.2
log
@2000-05-10  Michael Snyder  <msnyder@@seadog.cygnus.com>
	Make Sparc a Multi-Arch target.  Discard PARAMS macro (require ANSI).
	* sparc-tdep.c: include arch-utils.h.
	(SPARC_HAS_FPU, FP_REGISTER_BYTES, FP_MAX_REG NUM, SPARC_INTREG_SIZE,
	DUMMY_REG_SAVE_OFFSET): provide multi-arch-compatible definitions.
	(GDB_TARGET_IS_SPARC64): make into a runtime test.
	(struct frame_extra_info): Define, use instead of the macro.
	(Many places): Use alloca instead of statically allocated buffers
	that depend on a multi-arch variable such as MAX_REGISTER_RAW_SIZE.
	(sparc_extract_struct_value_address): Accept a pointer arg instead
	of an array sized by REGISTER_BYTES.
	(examine_prologue): Accept a pointer to an array of CORE_ADDR,
	instead of the defunct struct frame_saved_regs.  Recognize new
	Sparc64 store instructions as part of the prologue.  Ignore the
	destination of a frame store when parsing the prologue (so long
	as it's on the stack).
	(sparc_push_dummy_frame): Fix incorrect buffer offset for PSTATE.
	(sparc_frame_find_saved_regs): Accept a ptr to an array of CORE_ADDR
	instead of the defunct struct frame_saved_regs.
	(supply_gregset): Discard unnecessary 'zerobuf': just send NULL to
	supply_register.  Provide 4-byte offset to compensate for diff
	between size of the prgreg_t elements on a 64-bit host and size
	of the registers for a 32-bit target.  Fill all inaccessible regs
	with zero so they won't keep being requested again and again.
	(fill_gregset): Handle 32/64 size difference between registers
	and prgreg_t.  Handle as many new 64-bit regs as possible.
	(supply_fpregset, fill_fpregset): Attempt to handle 64-bit world.
	(sparc_push_arguments): Rename to sparc32_push_arguments.
	Copy arguments into registers as well as onto stack, so that the
	CALL_DUMMY (code pushed onto the target stack) is not required.
	(sparc_extract_return_value): Rename to sparc32_extract_return_value.
	(sparc_store_return_value): Use memset instead of bzero.
	Use write_register_gen instead of write_register_bytes.
	(sparclet_store_return_value): New function.
	(_initialize_sparc_tdep): Call register_gdbarch_init to activate
	the gdbarch multi-architecture system.
	(sp64_push_arguments): Rename to sparc64_push_arguments.
	Extend to store arguments in general registers as well as on stack.
	(sparc64_extract_return_value): Rename to sp64_extract_return_value.
	Use as a private function, to be called by the new external function
	sparc64_extract_return_value.
	(sparclet_extract_return_value): New function.
	(sparc32_stack_align, sparc64_stack_align, sparc32_register_name,
	sparc64_register_name, sparc_print_extra_frame_info,
	sparclite_register_name, sparclet_register_name,
	sparc_push_return_address, sparc64_use_struct_convention,
	sparc32_store_struct_return, sparc64_store_struct_return,
	sparc32_register_virtual_type, sparc64_register_virtual_type,
	sparc32_register_size, sparc64_register_size,
	sparc32_register_byte, sparc64_register_byte,
	sparc_gdbarch_skip_prologue, sparc_convert_to_virtual,
	sparc_convert_to_raw, sparc_frame_init_saved_regs,
	sparc_frame_address, sparc_gdbarch_fix_call_dummy,
	sparc_coerce_float_to_double, sparc_call_dummy_address,
	sparc_y_regnum, sparc_reg_struct_has_addr, sparc_intreg_size,
	sparc_return_value_on_stack): New functions supporting multi-arch.
	(sparc_gdbarch_init): New function; initialize multi-arch.
	(struct gdbarch_tdep): Define, use for private multi-arch data.
	* config/sparc/tm-sparc.h: Move definitions around, enclose with
	#ifdef GDB_MULTI_ARCH tests, provide some multi-arch alternate
	definitions.  Add enums for register names, to help debugging gdb.
	This header file must work for non-multi-arch and for multi-arch.
	* config/sparc/tm-sp64.h: Add GDB_MULTI_ARCH configuration.  Also add
	AT_ENTRY_POINT definitions for CALL_DUMMY, for non-multi-arch case.
	Define GDB_MULTI_ARCH.
	* config/sparc/tm-sparclet.h: Add GDB_MULTI_ARCH configuration.
	Do not define GDB_MULTI_ARCH (bfd does not correctly identify target).
	* config/sparc/tm-sparclite.h: Ditto.
	* config/sparc/tm-sun4sol2.h: Define GDB_MULTI_ARCH.
	* sparclet-rom.c (sparclet_regnames): Initialize explicitly, to
	avoid using deprecated REGISTER_NAMES macro.
	* Makefile.in: Let sparc-tdep.c depend on arch-utils.h.
@
text
@d32 1
a32 1
extern void report_transfer_performance PARAMS ((unsigned long, time_t, time_t));
d36 1
a36 1
static void sparclet_open PARAMS ((char *args, int from_tty));
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d29 1
a29 1
#include "symfile.h" /* for generic_load */
d44 16
a59 16
                0x0  0x0 0x0  0  0  0  0  0 0x0 1  0  0 0x00 0x2
                                                             0000010
       INS        LOCALS       OUTS      GLOBALS
 0  0x00000000  0x00000000  0x00000000  0x00000000
 1  0x00000000  0x00000000  0x00000000  0x00000000
 2  0x00000000  0x00000000  0x00000000  0x00000000
 3  0x00000000  0x00000000  0x00000000  0x00000000
 4  0x00000000  0x00000000  0x00000000  0x00000000
 5  0x00000000  0x00001000  0x00000000  0x00000000
 6  0x00000000  0x00000000  0x123f0000  0x00000000
 7  0x00000000  0x00000000  0x00000000  0x00000000
pc:  0x12010000 0x00000000    unimp
npc: 0x12010004 0x00001000    unimp     0x1000
tbr: 0x00000000
y:   0x00000000
*/
d64 26
a89 1
static char *sparclet_regnames[NUM_REGS] = REGISTER_NAMES;
d124 2
a125 2
  i = sscanf(file, "%*s 0x%lx", &load_offset);
  if (i >= 1 ) 
d148 1
a148 1
  
d204 1
a204 1
  if (hashmark) 
d221 2
a222 1
static char *sparclet_inits[] = {"\n\r\r\n", NULL};
d224 1
a224 1
static struct monitor_ops sparclet_cmds ;
d226 2
a227 2
static void 
init_sparclet_cmds(void)
d229 15
a243 15
  sparclet_cmds.flags =   MO_CLR_BREAK_USES_ADDR |
    MO_HEX_PREFIX          |
    MO_NO_ECHO_ON_OPEN     |
    MO_NO_ECHO_ON_SETMEM   |
    MO_RUN_FIRST_TIME      |
    MO_GETMEM_READ_SINGLE ;	/* flags */
  sparclet_cmds.init =   sparclet_inits;		/* Init strings */
  sparclet_cmds.cont =   "cont\r";			/* continue command */
  sparclet_cmds.step =   "step\r";			/* single step */
  sparclet_cmds.stop =   "\r";				/* break interrupts the program */
  sparclet_cmds.set_break =   "+bp %x\r";		/* set a breakpoint */
  sparclet_cmds.clr_break =  "-bp %x\r" ;		/* can't use "br" because only 2 hw bps are supported */
  sparclet_cmds.clr_all_break =   "-bp %x\r";		/* clear a breakpoint */
  "-bp\r" ;			/* clear all breakpoints */
  sparclet_cmds.fill =   "fill %x -n %x -v %x -b\r";	/* fill (start length val) */
d246 7
a252 7
  sparclet_cmds.setmem.cmdb =     "ex %x -b\r%x\rq\r";	/* setmem.cmdb (addr, value) */
  sparclet_cmds.setmem.cmdw =     "ex %x -s\r%x\rq\r";	/* setmem.cmdw (addr, value) */
  sparclet_cmds.setmem.cmdl =     "ex %x -l\r%x\rq\r";  /* setmem.cmdl (addr, value) */
  sparclet_cmds.setmem.cmdll =     NULL;		/* setmem.cmdll (addr, value) */
  sparclet_cmds.setmem.resp_delim =     NULL; /*": " */	/* setmem.resp_delim */
  sparclet_cmds.setmem.term =     NULL; /*"? " */	/* setmem.term */
  sparclet_cmds.setmem.term_cmd =     NULL; /*"q\r" */	/* setmem.term_cmd */
d257 22
a278 22
  sparclet_cmds.getmem.cmdb =     "ex %x -n 1 -b\r";	/* getmem.cmdb (addr, #bytes) */
  sparclet_cmds.getmem.cmdw =     "ex %x -n 1 -s\r";	/* getmem.cmdw (addr, #swords) */
  sparclet_cmds.getmem.cmdl =     "ex %x -n 1 -l\r";	/* getmem.cmdl (addr, #words) */
  sparclet_cmds.getmem.cmdll =     NULL;		/* getmem.cmdll (addr, #dwords) */
  sparclet_cmds.getmem.resp_delim =     ": ";		/* getmem.resp_delim */
  sparclet_cmds.getmem.term =     NULL;			/* getmem.term */
  sparclet_cmds.getmem.term_cmd =     NULL;		/* getmem.term_cmd */
  sparclet_cmds.setreg.cmd =     "reg %s 0x%x\r";	/* setreg.cmd (name, value) */
  sparclet_cmds.setreg.resp_delim =     NULL;		/* setreg.resp_delim */
  sparclet_cmds.setreg.term =     NULL;			/* setreg.term */
  sparclet_cmds.setreg.term_cmd =  NULL ;		/* setreg.term_cmd */
  sparclet_cmds.getreg.cmd =     "reg %s\r";		/* getreg.cmd (name) */
  sparclet_cmds.getreg.resp_delim =     " ";		/* getreg.resp_delim */
  sparclet_cmds.getreg.term =     NULL;			/* getreg.term */
  sparclet_cmds.getreg.term_cmd =     NULL;		/* getreg.term_cmd */
  sparclet_cmds.dump_registers =   "reg\r";		/* dump_registers */
  sparclet_cmds.register_pattern =   "\\(\\w+\\)=\\([0-9a-fA-F]+\\)";	/* register_pattern */
  sparclet_cmds.supply_register =   sparclet_supply_register;	/* supply_register */
  sparclet_cmds.load_routine =   sparclet_load;		/* load_routine */
  sparclet_cmds.load =   NULL;				/* download command (srecs on console) */
  sparclet_cmds.loadresp =   NULL;			/* load response */
  sparclet_cmds.prompt =   "monitor>";			/* monitor command prompt */
d280 6
a285 6
  sparclet_cmds.line_term =   "\r";			/* end-of-command delimitor */
  sparclet_cmds.cmd_end =   NULL;			/* optional command terminator */
  sparclet_cmds.target =   &sparclet_ops;		/* target operations */
  sparclet_cmds.stopbits =   SERIAL_1_STOPBITS;		/* number of stop bits */
  sparclet_cmds.regnames =   sparclet_regnames;		/* registers names */
  sparclet_cmds.magic =   MONITOR_OPS_MAGIC ;	/* magic */
d300 1
a300 1
  init_sparclet_cmds() ;
d305 1
a305 1
      sparclet_regnames[i] = 0;		/* mon can't report c* or a* regs */
d307 1
a307 1
  sparclet_regnames[0] = 0;		/* mon won't report %G0 */
d310 1
a310 1
  sparclet_ops.to_shortname = "sparclet"; /* for the target command */
d313 2
a314 2
  sparclet_ops.to_insert_breakpoint = memory_insert_breakpoint; 
  sparclet_ops.to_remove_breakpoint = memory_remove_breakpoint; 
d316 1
a316 1
  sparclet_ops.to_doc = 
a322 1

@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d28 1
a28 1
#include "symfile.h"		/* for generic_load */
d43 16
a58 16
   0x0  0x0 0x0  0  0  0  0  0 0x0 1  0  0 0x00 0x2
   0000010
   INS        LOCALS       OUTS      GLOBALS
   0  0x00000000  0x00000000  0x00000000  0x00000000
   1  0x00000000  0x00000000  0x00000000  0x00000000
   2  0x00000000  0x00000000  0x00000000  0x00000000
   3  0x00000000  0x00000000  0x00000000  0x00000000
   4  0x00000000  0x00000000  0x00000000  0x00000000
   5  0x00000000  0x00001000  0x00000000  0x00000000
   6  0x00000000  0x00000000  0x123f0000  0x00000000
   7  0x00000000  0x00000000  0x00000000  0x00000000
   pc:  0x12010000 0x00000000    unimp
   npc: 0x12010004 0x00001000    unimp     0x1000
   tbr: 0x00000000
   y:   0x00000000
 */
d98 2
a99 2
  i = sscanf (file, "%*s 0x%lx", &load_offset);
  if (i >= 1)
d122 1
a122 1

d178 1
a178 1
  if (hashmark)
d195 1
a195 2
static char *sparclet_inits[] =
{"\n\r\r\n", NULL};
d197 1
a197 1
static struct monitor_ops sparclet_cmds;
d199 2
a200 2
static void
init_sparclet_cmds (void)
d202 15
a216 15
  sparclet_cmds.flags = MO_CLR_BREAK_USES_ADDR |
    MO_HEX_PREFIX |
    MO_NO_ECHO_ON_OPEN |
    MO_NO_ECHO_ON_SETMEM |
    MO_RUN_FIRST_TIME |
    MO_GETMEM_READ_SINGLE;	/* flags */
  sparclet_cmds.init = sparclet_inits;	/* Init strings */
  sparclet_cmds.cont = "cont\r";	/* continue command */
  sparclet_cmds.step = "step\r";	/* single step */
  sparclet_cmds.stop = "\r";	/* break interrupts the program */
  sparclet_cmds.set_break = "+bp %x\r";		/* set a breakpoint */
  sparclet_cmds.clr_break = "-bp %x\r";		/* can't use "br" because only 2 hw bps are supported */
  sparclet_cmds.clr_all_break = "-bp %x\r";	/* clear a breakpoint */
  "-bp\r";			/* clear all breakpoints */
  sparclet_cmds.fill = "fill %x -n %x -v %x -b\r";	/* fill (start length val) */
d219 7
a225 7
  sparclet_cmds.setmem.cmdb = "ex %x -b\r%x\rq\r";	/* setmem.cmdb (addr, value) */
  sparclet_cmds.setmem.cmdw = "ex %x -s\r%x\rq\r";	/* setmem.cmdw (addr, value) */
  sparclet_cmds.setmem.cmdl = "ex %x -l\r%x\rq\r";	/* setmem.cmdl (addr, value) */
  sparclet_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
  sparclet_cmds.setmem.resp_delim = NULL;	/*": " *//* setmem.resp_delim */
  sparclet_cmds.setmem.term = NULL;	/*"? " *//* setmem.term */
  sparclet_cmds.setmem.term_cmd = NULL;		/*"q\r" *//* setmem.term_cmd */
d230 22
a251 22
  sparclet_cmds.getmem.cmdb = "ex %x -n 1 -b\r";	/* getmem.cmdb (addr, #bytes) */
  sparclet_cmds.getmem.cmdw = "ex %x -n 1 -s\r";	/* getmem.cmdw (addr, #swords) */
  sparclet_cmds.getmem.cmdl = "ex %x -n 1 -l\r";	/* getmem.cmdl (addr, #words) */
  sparclet_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, #dwords) */
  sparclet_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
  sparclet_cmds.getmem.term = NULL;	/* getmem.term */
  sparclet_cmds.getmem.term_cmd = NULL;		/* getmem.term_cmd */
  sparclet_cmds.setreg.cmd = "reg %s 0x%x\r";	/* setreg.cmd (name, value) */
  sparclet_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
  sparclet_cmds.setreg.term = NULL;	/* setreg.term */
  sparclet_cmds.setreg.term_cmd = NULL;		/* setreg.term_cmd */
  sparclet_cmds.getreg.cmd = "reg %s\r";	/* getreg.cmd (name) */
  sparclet_cmds.getreg.resp_delim = " ";	/* getreg.resp_delim */
  sparclet_cmds.getreg.term = NULL;	/* getreg.term */
  sparclet_cmds.getreg.term_cmd = NULL;		/* getreg.term_cmd */
  sparclet_cmds.dump_registers = "reg\r";	/* dump_registers */
  sparclet_cmds.register_pattern = "\\(\\w+\\)=\\([0-9a-fA-F]+\\)";	/* register_pattern */
  sparclet_cmds.supply_register = sparclet_supply_register;	/* supply_register */
  sparclet_cmds.load_routine = sparclet_load;	/* load_routine */
  sparclet_cmds.load = NULL;	/* download command (srecs on console) */
  sparclet_cmds.loadresp = NULL;	/* load response */
  sparclet_cmds.prompt = "monitor>";	/* monitor command prompt */
d253 6
a258 6
  sparclet_cmds.line_term = "\r";	/* end-of-command delimitor */
  sparclet_cmds.cmd_end = NULL;	/* optional command terminator */
  sparclet_cmds.target = &sparclet_ops;		/* target operations */
  sparclet_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
  sparclet_cmds.regnames = sparclet_regnames;	/* registers names */
  sparclet_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
d273 1
a273 1
  init_sparclet_cmds ();
d278 1
a278 1
      sparclet_regnames[i] = 0;	/* mon can't report c* or a* regs */
d280 1
a280 1
  sparclet_regnames[0] = 0;	/* mon won't report %G0 */
d283 1
a283 1
  sparclet_ops.to_shortname = "sparclet";	/* for the target command */
d286 2
a287 2
  sparclet_ops.to_insert_breakpoint = memory_insert_breakpoint;
  sparclet_ops.to_remove_breakpoint = memory_remove_breakpoint;
d289 1
a289 1
  sparclet_ops.to_doc =
d296 1
@

