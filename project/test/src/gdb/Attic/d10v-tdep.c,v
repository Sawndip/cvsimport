head	1.152;
access;
symbols
	insight_6_6-20070208-release:1.151
	gdb_6_6-2006-12-18-release:1.151
	gdb_6_6-branch:1.151.0.18
	gdb_6_6-2006-11-15-branchpoint:1.151
	insight_6_5-20061003-release:1.151
	gdb-csl-symbian-6_4_50_20060226-12:1.151
	gdb-csl-sourcerygxx-3_4_4-25:1.150
	nickrob-async-20060828-mergepoint:1.151
	gdb-csl-symbian-6_4_50_20060226-11:1.151
	gdb-csl-sourcerygxx-4_1-17:1.151
	gdb-csl-20060226-branch-local-2:1.151
	gdb-csl-sourcerygxx-4_1-14:1.151
	gdb-csl-sourcerygxx-4_1-13:1.151
	gdb-csl-sourcerygxx-4_1-12:1.151
	gdb-csl-sourcerygxx-3_4_4-21:1.151
	gdb_6_5-20060621-release:1.151
	gdb-csl-sourcerygxx-4_1-9:1.151
	gdb-csl-sourcerygxx-4_1-8:1.151
	gdb-csl-sourcerygxx-4_1-7:1.151
	gdb-csl-arm-2006q1-6:1.151
	gdb-csl-sourcerygxx-4_1-6:1.151
	gdb-csl-symbian-6_4_50_20060226-10:1.151
	gdb-csl-symbian-6_4_50_20060226-9:1.151
	gdb-csl-symbian-6_4_50_20060226-8:1.151
	gdb-csl-coldfire-4_1-11:1.151
	gdb-csl-sourcerygxx-3_4_4-19:1.151
	gdb-csl-coldfire-4_1-10:1.151
	gdb_6_5-branch:1.151.0.16
	gdb_6_5-2006-05-14-branchpoint:1.151
	gdb-csl-sourcerygxx-4_1-5:1.151
	nickrob-async-20060513-branch:1.151.0.14
	nickrob-async-20060513-branchpoint:1.151
	gdb-csl-sourcerygxx-4_1-4:1.151
	msnyder-reverse-20060502-branch:1.151.0.12
	msnyder-reverse-20060502-branchpoint:1.151
	gdb-csl-morpho-4_1-4:1.151
	gdb-csl-sourcerygxx-3_4_4-17:1.151
	readline_5_1-import-branch:1.151.0.10
	readline_5_1-import-branchpoint:1.151
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.151
	gdb-csl-symbian-20060226-branch:1.151.0.8
	gdb-csl-symbian-20060226-branchpoint:1.151
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.151
	msnyder-reverse-20060331-branch:1.151.0.6
	msnyder-reverse-20060331-branchpoint:1.151
	gdb-csl-available-20060303-branch:1.151.0.4
	gdb-csl-available-20060303-branchpoint:1.151
	gdb-csl-20060226-branch:1.151.0.2
	gdb-csl-20060226-branchpoint:1.151
	gdb_6_4-20051202-release:1.150
	msnyder-fork-checkpoint-branch:1.150.0.12
	msnyder-fork-checkpoint-branchpoint:1.150
	gdb-csl-gxxpro-6_3-branch:1.150.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.150
	gdb_6_4-branch:1.150.0.8
	gdb_6_4-2005-11-01-branchpoint:1.150
	gdb-csl-arm-20051020-branch:1.150.0.6
	gdb-csl-arm-20051020-branchpoint:1.150
	msnyder-tracepoint-checkpoint-branch:1.150.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.150
	gdb-csl-arm-20050325-2005-q1b:1.150
	gdb-csl-arm-20050325-2005-q1a:1.150
	csl-arm-20050325-branch:1.150.0.2
	csl-arm-20050325-branchpoint:1.150
	gdb-post-i18n-errorwarning-20050211:1.150
	gdb-pre-i18n-errorwarning-20050211:1.150
	gdb_6_3-20041109-release:1.149
	gdb_6_3-branch:1.149.0.2
	gdb_6_3-20041019-branchpoint:1.149
	drow_intercu-merge-20040921:1.149
	drow_intercu-merge-20040915:1.149
	jimb-gdb_6_2-e500-branch:1.144.0.6
	jimb-gdb_6_2-e500-branchpoint:1.144
	gdb_6_2-20040730-release:1.144
	gdb_6_2-branch:1.144.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.144
	gdb_6_1_1-20040616-release:1.142
	gdb_6_1-2004-04-05-release:1.142
	drow_intercu-merge-20040402:1.142
	drow_intercu-merge-20040327:1.142
	ezannoni_pie-20040323-branch:1.142.0.8
	ezannoni_pie-20040323-branchpoint:1.142
	cagney_tramp-20040321-mergepoint:1.142
	cagney_tramp-20040309-branch:1.142.0.6
	cagney_tramp-20040309-branchpoint:1.142
	gdb_6_1-branch:1.142.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.142
	drow_intercu-20040221-branch:1.142.0.2
	drow_intercu-20040221-branchpoint:1.142
	cagney_bfdfile-20040213-branch:1.141.0.2
	cagney_bfdfile-20040213-branchpoint:1.141
	drow-cplus-merge-20040208:1.140
	carlton_dictionary-20040126-merge:1.140
	cagney_bigcore-20040122-branch:1.140.0.2
	cagney_bigcore-20040122-branchpoint:1.140
	drow-cplus-merge-20040113:1.138
	drow-cplus-merge-20031224:1.138
	drow-cplus-merge-20031220:1.138
	carlton_dictionary-20031215-merge:1.138
	drow-cplus-merge-20031214:1.138
	carlton-dictionary-20031111-merge:1.138
	gdb_6_0-2003-10-04-release:1.125.4.2
	kettenis_sparc-20030918-branch:1.131.0.2
	kettenis_sparc-20030918-branchpoint:1.131
	carlton_dictionary-20030917-merge:1.131
	ezannoni_pie-20030916-branchpoint:1.130
	ezannoni_pie-20030916-branch:1.130.0.2
	cagney_x86i386-20030821-branch:1.129.0.2
	cagney_x86i386-20030821-branchpoint:1.129
	carlton_dictionary-20030805-merge:1.129
	carlton_dictionary-20030627-merge:1.125
	gdb_6_0-branch:1.125.0.4
	gdb_6_0-2003-06-23-branchpoint:1.125
	jimb-ppc64-linux-20030613-branch:1.125.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.125
	cagney_convert-20030606-branch:1.118.0.2
	cagney_convert-20030606-branchpoint:1.118
	cagney_writestrings-20030508-branch:1.116.0.8
	cagney_writestrings-20030508-branchpoint:1.116
	jimb-ppc64-linux-20030528-branch:1.116.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.116
	carlton_dictionary-20030523-merge:1.116
	cagney_fileio-20030521-branch:1.116.0.4
	cagney_fileio-20030521-branchpoint:1.116
	kettenis_i386newframe-20030517-mergepoint:1.116
	jimb-ppc64-linux-20030509-branch:1.116.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.116
	kettenis_i386newframe-20030504-mergepoint:1.114
	carlton_dictionary-20030430-merge:1.110
	kettenis_i386newframe-20030419-branch:1.106.0.2
	kettenis_i386newframe-20030419-branchpoint:1.106
	carlton_dictionary-20030416-merge:1.106
	cagney_frameaddr-20030409-mergepoint:1.105
	kettenis_i386newframe-20030406-branch:1.104.0.2
	kettenis_i386newframe-20030406-branchpoint:1.104
	cagney_frameaddr-20030403-branchpoint:1.101
	cagney_frameaddr-20030403-branch:1.101.0.2
	cagney_framebase-20030330-mergepoint:1.94
	cagney_framebase-20030326-branch:1.90.0.2
	cagney_framebase-20030326-branchpoint:1.90
	cagney_lazyid-20030317-branch:1.87.0.2
	cagney_lazyid-20030317-branchpoint:1.87
	kettenis-i386newframe-20030316-mergepoint:1.86
	offbyone-20030313-branch:1.86.0.2
	offbyone-20030313-branchpoint:1.86
	kettenis-i386newframe-20030308-branch:1.83.0.2
	kettenis-i386newframe-20030308-branchpoint:1.83
	carlton_dictionary-20030305-merge:1.81
	cagney_offbyone-20030303-branch:1.80.0.2
	cagney_offbyone-20030303-branchpoint:1.80
	carlton_dictionary-20030207-merge:1.76
	interps-20030203-mergepoint:1.76
	interps-20030202-branch:1.76.0.2
	interps-20030202-branchpoint:1.76
	cagney-unwind-20030108-branch:1.69.0.2
	cagney-unwind-20030108-branchpoint:1.69
	carlton_dictionary-20021223-merge:1.60
	gdb_5_3-2002-12-12-release:1.51
	carlton_dictionary-20021115-merge:1.54
	kseitz_interps-20021105-merge:1.53
	kseitz_interps-20021103-merge:1.53
	drow-cplus-merge-20021020:1.52
	drow-cplus-merge-20021025:1.52
	carlton_dictionary-20021025-merge:1.52
	carlton_dictionary-20021011-merge:1.52
	drow-cplus-branch:1.52.0.4
	drow-cplus-branchpoint:1.52
	kseitz_interps-20020930-merge:1.52
	carlton_dictionary-20020927-merge:1.52
	carlton_dictionary-branch:1.52.0.2
	carlton_dictionary-20020920-branchpoint:1.52
	gdb_5_3-branch:1.51.0.6
	gdb_5_3-2002-09-04-branchpoint:1.51
	kseitz_interps-20020829-merge:1.51
	cagney_sysregs-20020825-branch:1.51.0.4
	cagney_sysregs-20020825-branchpoint:1.51
	readline_4_3-import-branch:1.51.0.2
	readline_4_3-import-branchpoint:1.51
	gdb_5_2_1-2002-07-23-release:1.33
	kseitz_interps-20020528-branch:1.42.0.2
	kseitz_interps-20020528-branchpoint:1.42
	cagney_regbuf-20020515-branch:1.39.0.2
	cagney_regbuf-20020515-branchpoint:1.39
	jimb-macro-020506-branch:1.37.0.2
	jimb-macro-020506-branchpoint:1.37
	gdb_5_2-2002-04-29-release:1.33
	gdb_5_2-branch:1.33.0.2
	gdb_5_2-2002-03-03-branchpoint:1.33
	gdb_5_1_1-2002-01-24-release:1.23
	gdb_5_1_0_1-2002-01-03-release:1.23
	cygnus_cvs_20020108_pre:1.32
	gdb_5_1_0_1-2002-01-03-branchpoint:1.23
	gdb_5_1_0_1-2002-01-03-branch:1.23.0.6
	gdb_5_1-2001-11-21-release:1.23
	gdb_s390-2001-09-26-branch:1.23.0.4
	gdb_s390-2001-09-26-branchpoint:1.23
	gdb_5_1-2001-07-29-branch:1.23.0.2
	gdb_5_1-2001-07-29-branchpoint:1.23
	dberlin-typesystem-branch:1.21.0.2
	dberlin-typesystem-branchpoint:1.21
	gdb-post-ptid_t-2001-05-03:1.18
	gdb-pre-ptid_t-2001-05-03:1.17
	insight-precleanup-2001-01-01:1.13
	gdb-post-protoization-2000-07-29:1.8
	gdb-pre-protoization-2000-07-29:1.7
	gdb-premipsmulti-2000-06-06-branch:1.7.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.7
	gdb-post-params-removal-2000-06-04:1.7
	gdb-pre-params-removal-2000-06-04:1.6
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.4
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.14
	insight-2000-02-04:1.1.1.14
	gdb-2000-02-04:1.1.1.14
	gdb-2000-02-02:1.1.1.14
	gdb-2000-02-01:1.1.1.14
	gdb-2000-01-31:1.1.1.13
	gdb-2000-01-26:1.1.1.13
	gdb-2000-01-24:1.1.1.13
	gdb-2000-01-17:1.1.1.13
	gdb-2000-01-10:1.1.1.13
	gdb-2000-01-05:1.1.1.13
	gdb-1999-12-21:1.1.1.13
	gdb-1999-12-13:1.1.1.13
	gdb-1999-12-07:1.1.1.13
	gdb-1999-12-06:1.1.1.13
	gdb-1999-11-16:1.1.1.13
	gdb-1999-11-08:1.1.1.12
	gdb-1999-11-01:1.1.1.11
	gdb-1999-10-25:1.1.1.11
	gdb-1999-10-18:1.1.1.11
	gdb-1999-10-11:1.1.1.11
	gdb-1999-10-04:1.1.1.11
	gdb-1999-09-28:1.1.1.11
	gdb-1999-09-21:1.1.1.11
	gdb-1999-09-13:1.1.1.10
	gdb-1999-09-08:1.1.1.9
	gdb-1999-08-30:1.1.1.8
	gdb-1999-08-23:1.1.1.7
	gdb-1999-08-16:1.1.1.7
	gdb-1999-08-09:1.1.1.7
	gdb-1999-08-02:1.1.1.7
	gdb-1999-07-26:1.1.1.7
	gdb-1999-07-19:1.1.1.7
	gdb-1999-07-12:1.1.1.7
	gdb-post-reformat-19990707:1.1.1.7
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.7
	gdb-pre-reformat-19990707:1.1.1.6
	gdb-1999-07-07:1.1.1.6
	gdb-1999-07-05:1.1.1.6
	gdb-1999-06-28:1.1.1.6
	gdb-1999-06-21:1.1.1.6
	gdb-1999-06-14:1.1.1.6
	gdb-1999-06-07:1.1.1.5
	gdb-1999-06-01:1.1.1.4
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.152
date	2007.03.30.17.21.47;	author drow;	state dead;
branches;
next	1.151;

1.151
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.150;

1.150
date	2004.11.01.14.44.57;	author cagney;	state Exp;
branches;
next	1.149;

1.149
date	2004.09.11.10.24.45;	author hilfingr;	state Exp;
branches;
next	1.148;

1.148
date	2004.08.07.19.25.58;	author cagney;	state Exp;
branches;
next	1.147;

1.147
date	2004.07.31.21.53.17;	author cagney;	state Exp;
branches;
next	1.146;

1.146
date	2004.07.28.17.26.26;	author cagney;	state Exp;
branches;
next	1.145;

1.145
date	2004.07.28.02.03.51;	author cagney;	state Exp;
branches;
next	1.144;

1.144
date	2004.06.07.02.02.46;	author tausq;	state Exp;
branches;
next	1.143;

1.143
date	2004.04.21.23.52.20;	author cagney;	state Exp;
branches;
next	1.142;

1.142
date	2004.02.16.21.49.21;	author cagney;	state Exp;
branches
	1.142.2.1;
next	1.141;

1.141
date	2004.02.11.15.40.27;	author cagney;	state Exp;
branches;
next	1.140;

1.140
date	2004.01.21.15.37.11;	author cagney;	state Exp;
branches;
next	1.139;

1.139
date	2004.01.13.21.38.45;	author cagney;	state Exp;
branches;
next	1.138;

1.138
date	2003.11.10.22.47.28;	author cagney;	state Exp;
branches;
next	1.137;

1.137
date	2003.11.09.14.20.55;	author cagney;	state Exp;
branches;
next	1.136;

1.136
date	2003.10.31.23.47.17;	author cagney;	state Exp;
branches;
next	1.135;

1.135
date	2003.10.10.21.59.05;	author msnyder;	state Exp;
branches;
next	1.134;

1.134
date	2003.10.10.07.13.10;	author ksakamot;	state Exp;
branches;
next	1.133;

1.133
date	2003.10.10.00.25.42;	author msnyder;	state Exp;
branches;
next	1.132;

1.132
date	2003.09.28.22.32.19;	author cagney;	state Exp;
branches;
next	1.131;

1.131
date	2003.09.17.14.24.29;	author cagney;	state Exp;
branches;
next	1.130;

1.130
date	2003.09.12.18.40.16;	author cagney;	state Exp;
branches;
next	1.129;

1.129
date	2003.07.16.22.29.13;	author cagney;	state Exp;
branches;
next	1.128;

1.128
date	2003.07.15.17.23.31;	author cagney;	state Exp;
branches;
next	1.127;

1.127
date	2003.07.07.14.36.57;	author cagney;	state Exp;
branches;
next	1.126;

1.126
date	2003.07.01.13.25.19;	author cagney;	state Exp;
branches;
next	1.125;

1.125
date	2003.06.13.20.37.27;	author cagney;	state Exp;
branches
	1.125.4.1;
next	1.124;

1.124
date	2003.06.09.17.35.56;	author cagney;	state Exp;
branches;
next	1.123;

1.123
date	2003.06.09.01.02.06;	author cagney;	state Exp;
branches;
next	1.122;

1.122
date	2003.06.08.22.10.12;	author cagney;	state Exp;
branches;
next	1.121;

1.121
date	2003.06.08.18.27.13;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2003.06.08.16.09.45;	author cagney;	state Exp;
branches;
next	1.119;

1.119
date	2003.06.06.21.27.35;	author cagney;	state Exp;
branches;
next	1.118;

1.118
date	2003.06.03.18.53.37;	author cagney;	state Exp;
branches;
next	1.117;

1.117
date	2003.05.31.14.20.31;	author cagney;	state Exp;
branches;
next	1.116;

1.116
date	2003.05.08.18.46.47;	author cagney;	state Exp;
branches;
next	1.115;

1.115
date	2003.05.07.19.21.11;	author cagney;	state Exp;
branches;
next	1.114;

1.114
date	2003.05.03.19.39.23;	author cagney;	state Exp;
branches;
next	1.113;

1.113
date	2003.05.03.19.13.03;	author cagney;	state Exp;
branches;
next	1.112;

1.112
date	2003.05.02.23.56.11;	author cagney;	state Exp;
branches;
next	1.111;

1.111
date	2003.05.01.15.37.45;	author cagney;	state Exp;
branches;
next	1.110;

1.110
date	2003.04.30.22.01.37;	author cagney;	state Exp;
branches;
next	1.109;

1.109
date	2003.04.29.01.49.46;	author cagney;	state Exp;
branches;
next	1.108;

1.108
date	2003.04.25.22.14.05;	author cagney;	state Exp;
branches;
next	1.107;

1.107
date	2003.04.25.21.20.57;	author cagney;	state Exp;
branches;
next	1.106;

1.106
date	2003.04.11.03.12.58;	author cagney;	state Exp;
branches
	1.106.2.1;
next	1.105;

1.105
date	2003.04.08.21.56.09;	author cagney;	state Exp;
branches;
next	1.104;

1.104
date	2003.04.05.18.54.38;	author cagney;	state Exp;
branches;
next	1.103;

1.103
date	2003.04.05.03.55.59;	author cagney;	state Exp;
branches;
next	1.102;

1.102
date	2003.04.04.21.04.33;	author cagney;	state Exp;
branches;
next	1.101;

1.101
date	2003.04.01.19.55.03;	author cagney;	state Exp;
branches
	1.101.2.1;
next	1.100;

1.100
date	2003.04.01.17.17.27;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2003.04.01.14.38.48;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2003.03.31.23.52.37;	author cagney;	state Exp;
branches;
next	1.97;

1.97
date	2003.03.31.21.58.21;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2003.03.31.19.01.19;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2003.03.31.02.36.59;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2003.03.30.00.09.40;	author cagney;	state Exp;
branches;
next	1.93;

1.93
date	2003.03.29.01.40.00;	author cagney;	state Exp;
branches;
next	1.92;

1.92
date	2003.03.27.15.09.48;	author cagney;	state Exp;
branches;
next	1.91;

1.91
date	2003.03.26.22.39.52;	author cagney;	state Exp;
branches;
next	1.90;

1.90
date	2003.03.25.22.56.39;	author cagney;	state Exp;
branches
	1.90.2.1;
next	1.89;

1.89
date	2003.03.25.20.38.44;	author cagney;	state Exp;
branches;
next	1.88;

1.88
date	2003.03.25.18.54.14;	author cagney;	state Exp;
branches;
next	1.87;

1.87
date	2003.03.17.14.23.49;	author cagney;	state Exp;
branches;
next	1.86;

1.86
date	2003.03.12.15.39.30;	author cagney;	state Exp;
branches
	1.86.2.1;
next	1.85;

1.85
date	2003.03.10.15.28.40;	author cagney;	state Exp;
branches;
next	1.84;

1.84
date	2003.03.10.14.43.15;	author cagney;	state Exp;
branches;
next	1.83;

1.83
date	2003.03.05.23.14.17;	author cagney;	state Exp;
branches
	1.83.2.1;
next	1.82;

1.82
date	2003.03.05.22.54.22;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2003.03.05.20.57.28;	author cagney;	state Exp;
branches;
next	1.80;

1.80
date	2003.03.03.20.50.17;	author cagney;	state Exp;
branches
	1.80.2.1;
next	1.79;

1.79
date	2003.03.01.17.59.12;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2003.02.28.17.47.42;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2003.02.27.17.48.46;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2003.02.02.20.31.42;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2003.02.02.18.53.22;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2003.02.02.05.46.14;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2003.01.30.15.11.20;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2003.01.19.22.24.50;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2003.01.12.19.25.39;	author cagney;	state Exp;
branches;
next	1.70;

1.70
date	2003.01.12.18.59.53;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2003.01.08.18.04.06;	author cagney;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2003.01.08.17.21.28;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2003.01.08.15.56.36;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2003.01.08.01.53.37;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2003.01.07.14.51.10;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2003.01.06.18.49.08;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2003.01.05.01.39.54;	author drow;	state Exp;
branches;
next	1.62;

1.62
date	2003.01.03.23.53.47;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2003.01.02.22.20.46;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2002.12.11.02.26.35;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2002.12.01.19.07.14;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2002.11.28.18.15.57;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2002.11.24.19.48.12;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2002.11.23.01.39.25;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2002.11.16.01.00.06;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2002.11.14.00.25.02;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2002.09.17.20.42.01;	author cagney;	state Exp;
branches
	1.52.2.1
	1.52.4.1;
next	1.51;

1.51
date	2002.08.24.00.21.34;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2002.08.05.17.12.56;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2002.07.29.16.34.06;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.17.23.32.27;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.14.22.55.40;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.06.18.57.08;	author msnyder;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.06.18.47.35;	author msnyder;	state Exp;
branches;
next	1.44;

1.44
date	2002.06.06.16.35.37;	author ezannoni;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.29.01.51.16;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.24.00.12.16;	author cagney;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2002.05.23.23.53.56;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2002.05.23.15.52.01;	author msnyder;	state Exp;
branches;
next	1.39;

1.39
date	2002.05.13.14.00.35;	author drow;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2002.05.12.02.16.03;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2002.04.18.18.08.59;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2002.04.12.22.50.42;	author msnyder;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.06.00.02.50;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2002.03.19.02.51.04;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2002.01.31.04.10.51;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.07.20.43.46;	author jsmith;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.05.04.30.16;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.15.16.53.22;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.12.02.11.51;	author fnf;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.11.22.16.48;	author msnyder;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.05.02.05.04;	author jsmith;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.15.02.18.46;	author msnyder;	state Exp;
branches;
next	1.25;

1.25
date	2001.10.15.18.18.29;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.05.23.44.43;	author ezannoni;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.15.20.10.02;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.10.21.24.48;	author jimb;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.05.21.26.29;	author jimb;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.06.28.23.12.18;	author jimb;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.28.22.10.41;	author jimb;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.04.04.15.24;	author kevinb;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.06.08.21.06;	author kevinb;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.08.06.03.52;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.02.20.21.53;	author msnyder;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.15.01.01.46;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2000.09.01.23.45.13;	author davea;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.13.01.22.17;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.04.03.17.57;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.02.11.05.50;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.02.01.59.13;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.28.01.12.26;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.27.04.25.45;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.21.04.21.21;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.04.46.47;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.23.58;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.25.18.01.34;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.06.01.15.39.50;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.06.07.19.17.14;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.06.14.18.07.20;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.07.07.20.05.24;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.08.31.01.04.45;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.09.08.23.59.06;	author shebs;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.09.13.21.37.19;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.09.22.03.24.23;	author jsm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.11.09.01.23.02;	author jsm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.11.17.02.30.22;	author jsm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2000.02.02.00.21.05;	author jsm;	state Exp;
branches;
next	;

1.21.2.1
date	2001.07.06.19.16.58;	author dberlin;	state Exp;
branches;
next	;

1.39.2.1
date	2002.06.15.16.42.51;	author cagney;	state Exp;
branches;
next	1.39.2.2;

1.39.2.2
date	2002.06.21.16.19.23;	author cagney;	state Exp;
branches;
next	;

1.42.2.1
date	2002.06.20.01.32.17;	author kseitz;	state Exp;
branches;
next	1.42.2.2;

1.42.2.2
date	2002.08.09.18.34.23;	author kseitz;	state Exp;
branches;
next	1.42.2.3;

1.42.2.3
date	2002.08.30.22.52.43;	author kseitz;	state Exp;
branches;
next	1.42.2.4;

1.42.2.4
date	2002.10.01.00.46.06;	author kseitz;	state Exp;
branches;
next	1.42.2.5;

1.42.2.5
date	2002.11.04.00.17.30;	author ezannoni;	state Exp;
branches;
next	;

1.52.2.1
date	2002.11.15.19.18.41;	author carlton;	state Exp;
branches;
next	1.52.2.2;

1.52.2.2
date	2002.12.23.19.38.18;	author carlton;	state Exp;
branches;
next	1.52.2.3;

1.52.2.3
date	2003.02.07.19.17.47;	author carlton;	state Exp;
branches;
next	1.52.2.4;

1.52.2.4
date	2003.03.06.00.56.26;	author carlton;	state Exp;
branches;
next	1.52.2.5;

1.52.2.5
date	2003.04.16.19.56.51;	author carlton;	state Exp;
branches;
next	1.52.2.6;

1.52.2.6
date	2003.05.01.00.46.47;	author carlton;	state Exp;
branches;
next	1.52.2.7;

1.52.2.7
date	2003.05.23.18.40.36;	author carlton;	state Exp;
branches;
next	1.52.2.8;

1.52.2.8
date	2003.06.27.21.49.51;	author carlton;	state Exp;
branches;
next	1.52.2.9;

1.52.2.9
date	2003.08.05.17.13.05;	author carlton;	state Exp;
branches;
next	1.52.2.10;

1.52.2.10
date	2003.09.17.21.28.13;	author carlton;	state Exp;
branches;
next	1.52.2.11;

1.52.2.11
date	2003.11.11.23.50.39;	author carlton;	state Exp;
branches;
next	1.52.2.12;

1.52.2.12
date	2004.01.26.19.11.22;	author carlton;	state Exp;
branches;
next	;

1.52.4.1
date	2003.12.14.20.27.10;	author drow;	state Exp;
branches;
next	1.52.4.2;

1.52.4.2
date	2004.02.09.19.43.35;	author drow;	state Exp;
branches;
next	;

1.69.2.1
date	2003.01.12.20.07.36;	author cagney;	state Exp;
branches;
next	1.69.2.2;

1.69.2.2
date	2003.01.13.17.03.53;	author cagney;	state Exp;
branches;
next	1.69.2.3;

1.69.2.3
date	2003.01.19.18.56.32;	author cagney;	state Exp;
branches;
next	1.69.2.4;

1.69.2.4
date	2003.01.20.00.38.14;	author cagney;	state Exp;
branches;
next	;

1.80.2.1
date	2003.03.04.23.15.23;	author cagney;	state Exp;
branches;
next	1.80.2.2;

1.80.2.2
date	2003.03.05.05.00.03;	author cagney;	state Exp;
branches;
next	1.80.2.3;

1.80.2.3
date	2003.03.06.19.21.30;	author cagney;	state Exp;
branches;
next	1.80.2.4;

1.80.2.4
date	2003.03.07.14.24.29;	author cagney;	state Exp;
branches;
next	;

1.83.2.1
date	2003.03.16.14.01.48;	author kettenis;	state Exp;
branches;
next	;

1.86.2.1
date	2003.03.13.17.33.51;	author cagney;	state Exp;
branches;
next	;

1.90.2.1
date	2003.03.26.20.33.47;	author cagney;	state Exp;
branches;
next	1.90.2.2;

1.90.2.2
date	2003.03.30.16.35.20;	author cagney;	state Exp;
branches;
next	;

1.101.2.1
date	2003.04.03.17.01.48;	author cagney;	state Exp;
branches;
next	1.101.2.2;

1.101.2.2
date	2003.04.10.21.33.47;	author cagney;	state Exp;
branches;
next	;

1.106.2.1
date	2003.05.04.11.37.40;	author kettenis;	state Exp;
branches;
next	1.106.2.2;

1.106.2.2
date	2003.05.18.09.44.01;	author kettenis;	state Exp;
branches;
next	;

1.125.4.1
date	2003.07.01.21.44.24;	author cagney;	state Exp;
branches;
next	1.125.4.2;

1.125.4.2
date	2003.07.15.17.32.13;	author cagney;	state Exp;
branches;
next	;

1.142.2.1
date	2004.09.16.17.01.01;	author drow;	state Exp;
branches;
next	;


desc
@@


1.152
log
@	* MAINTAINERS: Remove d10v entry.
	* Makefile.in (SFILES): Remove dwarfread.c.
	(COMMON_OBS): Remove dwarfread.o.
	(gdb_sim_d10v_h, abug-rom.o, cpu32bug-rom.o, d10v-tdep.o, dwarfread.o)
	(remote-est.o, rom68k-rom.o): Delete.
	* NEWS: Mention removal of d10v, target abug, target cpu32bug,
	target est, target rom68k, and DWARF 1.
	* configure.tgt: Mark d10v as removed.
	* dwarf2read.c: Doc update.
	* elfread.c (struct elfinfo): Remove dboffset, dbsize, lnoffset,
	and lnsize.
	(elf_locate_sections): Do not set them.
	(elf_symfile_read): Do not call dwarf_build_psymtabs.
	* symfile.h (dwarf_build_psymtabs): Delete prototype.
	* config/m68k/monitor.mt (TDEPFILES): Prune.
	* abug-rom.c, cpu32bug-rom.c, d10v-tdep.c, dwarfread.c,
	remote-est.c, rom68k-rom.c, config/d10v/d10v.mt: Delete.

	* gdb.texinfo (M68K): Remove obsolete ROM monitors.
	* gdbint.texinfo (DWARF 1): Delete section and other dwarfread.c
	references.

	* gdb.asm/asm-source.exp: Remove d10v case.
	* lib/gdb.exp (skip_cplus_tests): Likewise.
	* gdb.asm/d10v.inc: Deleted.
@
text
@// OBSOLETE /* Target-dependent code for Renesas D10V, for GDB.
// OBSOLETE 
// OBSOLETE    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
// OBSOLETE    Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 51 Franklin Street, Fifth Floor,
// OBSOLETE    Boston, MA 02110-1301, USA.  */
// OBSOLETE 
// OBSOLETE /*  Contributed by Martin Hunt, hunt@@cygnus.com */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "frame-unwind.h"
// OBSOLETE #include "frame-base.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "gdbtypes.h"
// OBSOLETE #include "gdbcmd.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "gdb_string.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "dis-asm.h"
// OBSOLETE #include "symfile.h"
// OBSOLETE #include "objfiles.h"
// OBSOLETE #include "language.h"
// OBSOLETE #include "arch-utils.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE #include "remote.h"
// OBSOLETE #include "floatformat.h"
// OBSOLETE #include "gdb/sim-d10v.h"
// OBSOLETE #include "sim-regno.h"
// OBSOLETE #include "disasm.h"
// OBSOLETE #include "trad-frame.h"
// OBSOLETE 
// OBSOLETE #include "gdb_assert.h"
// OBSOLETE 
// OBSOLETE struct gdbarch_tdep
// OBSOLETE   {
// OBSOLETE     int a0_regnum;
// OBSOLETE     int nr_dmap_regs;
// OBSOLETE     unsigned long (*dmap_register) (void *regcache, int nr);
// OBSOLETE     unsigned long (*imap_register) (void *regcache, int nr);
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE /* These are the addresses the D10V-EVA board maps data and
// OBSOLETE    instruction memory to.  */
// OBSOLETE 
// OBSOLETE enum memspace {
// OBSOLETE   DMEM_START  = 0x2000000,
// OBSOLETE   IMEM_START  = 0x1000000,
// OBSOLETE   STACK_START = 0x200bffe
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* d10v register names.  */
// OBSOLETE 
// OBSOLETE enum
// OBSOLETE   {
// OBSOLETE     R0_REGNUM = 0,
// OBSOLETE     R3_REGNUM = 3,
// OBSOLETE     D10V_FP_REGNUM = 11,
// OBSOLETE     LR_REGNUM = 13,
// OBSOLETE     D10V_SP_REGNUM = 15,
// OBSOLETE     PSW_REGNUM = 16,
// OBSOLETE     D10V_PC_REGNUM = 18,
// OBSOLETE     NR_IMAP_REGS = 2,
// OBSOLETE     NR_A_REGS = 2,
// OBSOLETE     TS2_NUM_REGS = 37,
// OBSOLETE     TS3_NUM_REGS = 42,
// OBSOLETE     /* d10v calling convention.  */
// OBSOLETE     ARG1_REGNUM = R0_REGNUM,
// OBSOLETE     ARGN_REGNUM = R3_REGNUM
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE nr_dmap_regs (struct gdbarch *gdbarch)
// OBSOLETE {
// OBSOLETE   return gdbarch_tdep (gdbarch)->nr_dmap_regs;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE a0_regnum (struct gdbarch *gdbarch)
// OBSOLETE {
// OBSOLETE   return gdbarch_tdep (gdbarch)->a0_regnum;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Local functions */
// OBSOLETE 
// OBSOLETE extern void _initialize_d10v_tdep (void);
// OBSOLETE 
// OBSOLETE static void d10v_eva_prepare_to_trace (void);
// OBSOLETE 
// OBSOLETE static void d10v_eva_get_trace_data (void);
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE d10v_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
// OBSOLETE {
// OBSOLETE   /* Align to the size of an instruction (so that they can safely be
// OBSOLETE      pushed onto the stack.  */
// OBSOLETE   return sp & ~3;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static const unsigned char *
// OBSOLETE d10v_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
// OBSOLETE {
// OBSOLETE   static unsigned char breakpoint[] =
// OBSOLETE   {0x2f, 0x90, 0x5e, 0x00};
// OBSOLETE   *lenptr = sizeof (breakpoint);
// OBSOLETE   return breakpoint;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Map the REG_NR onto an ascii name.  Return NULL or an empty string
// OBSOLETE    when the reg_nr isn't valid.  */
// OBSOLETE 
// OBSOLETE enum ts2_regnums
// OBSOLETE   {
// OBSOLETE     TS2_IMAP0_REGNUM = 32,
// OBSOLETE     TS2_DMAP_REGNUM = 34,
// OBSOLETE     TS2_NR_DMAP_REGS = 1,
// OBSOLETE     TS2_A0_REGNUM = 35
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE static const char *
// OBSOLETE d10v_ts2_register_name (int reg_nr)
// OBSOLETE {
// OBSOLETE   static char *register_names[] =
// OBSOLETE   {
// OBSOLETE     "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
// OBSOLETE     "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
// OBSOLETE     "psw", "bpsw", "pc", "bpc", "cr4", "cr5", "cr6", "rpt_c",
// OBSOLETE     "rpt_s", "rpt_e", "mod_s", "mod_e", "cr12", "cr13", "iba", "cr15",
// OBSOLETE     "imap0", "imap1", "dmap", "a0", "a1"
// OBSOLETE   };
// OBSOLETE   if (reg_nr < 0)
// OBSOLETE     return NULL;
// OBSOLETE   if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
// OBSOLETE     return NULL;
// OBSOLETE   return register_names[reg_nr];
// OBSOLETE }
// OBSOLETE 
// OBSOLETE enum ts3_regnums
// OBSOLETE   {
// OBSOLETE     TS3_IMAP0_REGNUM = 36,
// OBSOLETE     TS3_DMAP0_REGNUM = 38,
// OBSOLETE     TS3_NR_DMAP_REGS = 4,
// OBSOLETE     TS3_A0_REGNUM = 32
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE static const char *
// OBSOLETE d10v_ts3_register_name (int reg_nr)
// OBSOLETE {
// OBSOLETE   static char *register_names[] =
// OBSOLETE   {
// OBSOLETE     "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
// OBSOLETE     "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
// OBSOLETE     "psw", "bpsw", "pc", "bpc", "cr4", "cr5", "cr6", "rpt_c",
// OBSOLETE     "rpt_s", "rpt_e", "mod_s", "mod_e", "cr12", "cr13", "iba", "cr15",
// OBSOLETE     "a0", "a1",
// OBSOLETE     "spi", "spu",
// OBSOLETE     "imap0", "imap1",
// OBSOLETE     "dmap0", "dmap1", "dmap2", "dmap3"
// OBSOLETE   };
// OBSOLETE   if (reg_nr < 0)
// OBSOLETE     return NULL;
// OBSOLETE   if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
// OBSOLETE     return NULL;
// OBSOLETE   return register_names[reg_nr];
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Access the DMAP/IMAP registers in a target independent way.
// OBSOLETE 
// OBSOLETE    Divide the D10V's 64k data space into four 16k segments:
// OBSOLETE    0x0000 -- 0x3fff, 0x4000 -- 0x7fff, 0x8000 -- 0xbfff, and 
// OBSOLETE    0xc000 -- 0xffff.
// OBSOLETE 
// OBSOLETE    On the TS2, the first two segments (0x0000 -- 0x3fff, 0x4000 --
// OBSOLETE    0x7fff) always map to the on-chip data RAM, and the fourth always
// OBSOLETE    maps to I/O space.  The third (0x8000 - 0xbfff) can be mapped into
// OBSOLETE    unified memory or instruction memory, under the control of the
// OBSOLETE    single DMAP register.
// OBSOLETE 
// OBSOLETE    On the TS3, there are four DMAP registers, each of which controls
// OBSOLETE    one of the segments.  */
// OBSOLETE 
// OBSOLETE static unsigned long
// OBSOLETE d10v_ts2_dmap_register (void *regcache, int reg_nr)
// OBSOLETE {
// OBSOLETE   switch (reg_nr)
// OBSOLETE     {
// OBSOLETE     case 0:
// OBSOLETE     case 1:
// OBSOLETE       return 0x2000;
// OBSOLETE     case 2:
// OBSOLETE       {
// OBSOLETE 	ULONGEST reg;
// OBSOLETE 	regcache_cooked_read_unsigned (regcache, TS2_DMAP_REGNUM, &reg);
// OBSOLETE 	return reg;
// OBSOLETE       }
// OBSOLETE     default:
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static unsigned long
// OBSOLETE d10v_ts3_dmap_register (void *regcache, int reg_nr)
// OBSOLETE {
// OBSOLETE   ULONGEST reg;
// OBSOLETE   regcache_cooked_read_unsigned (regcache, TS3_DMAP0_REGNUM + reg_nr, &reg);
// OBSOLETE   return reg;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static unsigned long
// OBSOLETE d10v_ts2_imap_register (void *regcache, int reg_nr)
// OBSOLETE {
// OBSOLETE   ULONGEST reg;
// OBSOLETE   regcache_cooked_read_unsigned (regcache, TS2_IMAP0_REGNUM + reg_nr, &reg);
// OBSOLETE   return reg;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static unsigned long
// OBSOLETE d10v_ts3_imap_register (void *regcache, int reg_nr)
// OBSOLETE {
// OBSOLETE   ULONGEST reg;
// OBSOLETE   regcache_cooked_read_unsigned (regcache, TS3_IMAP0_REGNUM + reg_nr, &reg);
// OBSOLETE   return reg;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* MAP GDB's internal register numbering (determined by the layout
// OBSOLETE    from the DEPRECATED_REGISTER_BYTE array) onto the simulator's
// OBSOLETE    register numbering.  */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE d10v_ts2_register_sim_regno (int nr)
// OBSOLETE {
// OBSOLETE   /* Only makes sense to supply raw registers.  */
// OBSOLETE   gdb_assert (nr >= 0 && nr < NUM_REGS);
// OBSOLETE   if (nr >= TS2_IMAP0_REGNUM
// OBSOLETE       && nr < TS2_IMAP0_REGNUM + NR_IMAP_REGS)
// OBSOLETE     return nr - TS2_IMAP0_REGNUM + SIM_D10V_IMAP0_REGNUM;
// OBSOLETE   if (nr == TS2_DMAP_REGNUM)
// OBSOLETE     return nr - TS2_DMAP_REGNUM + SIM_D10V_TS2_DMAP_REGNUM;
// OBSOLETE   if (nr >= TS2_A0_REGNUM
// OBSOLETE       && nr < TS2_A0_REGNUM + NR_A_REGS)
// OBSOLETE     return nr - TS2_A0_REGNUM + SIM_D10V_A0_REGNUM;
// OBSOLETE   return nr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE d10v_ts3_register_sim_regno (int nr)
// OBSOLETE {
// OBSOLETE   /* Only makes sense to supply raw registers.  */
// OBSOLETE   gdb_assert (nr >= 0 && nr < NUM_REGS);
// OBSOLETE   if (nr >= TS3_IMAP0_REGNUM
// OBSOLETE       && nr < TS3_IMAP0_REGNUM + NR_IMAP_REGS)
// OBSOLETE     return nr - TS3_IMAP0_REGNUM + SIM_D10V_IMAP0_REGNUM;
// OBSOLETE   if (nr >= TS3_DMAP0_REGNUM
// OBSOLETE       && nr < TS3_DMAP0_REGNUM + TS3_NR_DMAP_REGS)
// OBSOLETE     return nr - TS3_DMAP0_REGNUM + SIM_D10V_DMAP0_REGNUM;
// OBSOLETE   if (nr >= TS3_A0_REGNUM
// OBSOLETE       && nr < TS3_A0_REGNUM + NR_A_REGS)
// OBSOLETE     return nr - TS3_A0_REGNUM + SIM_D10V_A0_REGNUM;
// OBSOLETE   return nr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the GDB type object for the "standard" data type
// OBSOLETE    of data in register N.  */
// OBSOLETE 
// OBSOLETE static struct type *
// OBSOLETE d10v_register_type (struct gdbarch *gdbarch, int reg_nr)
// OBSOLETE {
// OBSOLETE   if (reg_nr == D10V_PC_REGNUM)
// OBSOLETE     return builtin_type (gdbarch)->builtin_func_ptr;
// OBSOLETE   if (reg_nr == D10V_SP_REGNUM || reg_nr == D10V_FP_REGNUM)
// OBSOLETE     return builtin_type (gdbarch)->builtin_data_ptr;
// OBSOLETE   else if (reg_nr >= a0_regnum (gdbarch)
// OBSOLETE 	   && reg_nr < (a0_regnum (gdbarch) + NR_A_REGS))
// OBSOLETE     return builtin_type_int64;
// OBSOLETE   else
// OBSOLETE     return builtin_type_int16;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE d10v_iaddr_p (CORE_ADDR x)
// OBSOLETE {
// OBSOLETE   return (((x) & 0x3000000) == IMEM_START);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE d10v_make_daddr (CORE_ADDR x)
// OBSOLETE {
// OBSOLETE   return ((x) | DMEM_START);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE d10v_make_iaddr (CORE_ADDR x)
// OBSOLETE {
// OBSOLETE   if (d10v_iaddr_p (x))
// OBSOLETE     return x;	/* Idempotency -- x is already in the IMEM space.  */
// OBSOLETE   else
// OBSOLETE     return (((x) << 2) | IMEM_START);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE d10v_convert_iaddr_to_raw (CORE_ADDR x)
// OBSOLETE {
// OBSOLETE   return (((x) >> 2) & 0xffff);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE d10v_convert_daddr_to_raw (CORE_ADDR x)
// OBSOLETE {
// OBSOLETE   return ((x) & 0xffff);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE d10v_address_to_pointer (struct type *type, void *buf, CORE_ADDR addr)
// OBSOLETE {
// OBSOLETE   /* Is it a code address?  */
// OBSOLETE   if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC
// OBSOLETE       || TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_METHOD)
// OBSOLETE     {
// OBSOLETE       store_unsigned_integer (buf, TYPE_LENGTH (type), 
// OBSOLETE                               d10v_convert_iaddr_to_raw (addr));
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* Strip off any upper segment bits.  */
// OBSOLETE       store_unsigned_integer (buf, TYPE_LENGTH (type), 
// OBSOLETE                               d10v_convert_daddr_to_raw (addr));
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE d10v_pointer_to_address (struct type *type, const void *buf)
// OBSOLETE {
// OBSOLETE   CORE_ADDR addr = extract_unsigned_integer (buf, TYPE_LENGTH (type));
// OBSOLETE   /* Is it a code address?  */
// OBSOLETE   if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC
// OBSOLETE       || TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_METHOD
// OBSOLETE       || TYPE_CODE_SPACE (TYPE_TARGET_TYPE (type)))
// OBSOLETE     return d10v_make_iaddr (addr);
// OBSOLETE   else
// OBSOLETE     return d10v_make_daddr (addr);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Don't do anything if we have an integer, this way users can type 'x
// OBSOLETE    <addr>' w/o having gdb outsmart them.  The internal gdb conversions
// OBSOLETE    to the correct space are taken care of in the pointer_to_address
// OBSOLETE    function.  If we don't do this, 'x $fp' wouldn't work.  */
// OBSOLETE static CORE_ADDR
// OBSOLETE d10v_integer_to_address (struct type *type, void *buf)
// OBSOLETE {
// OBSOLETE   LONGEST val;
// OBSOLETE   val = unpack_long (type, buf);
// OBSOLETE   return val;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Handle the d10v's return_value convention.  */
// OBSOLETE 
// OBSOLETE static enum return_value_convention
// OBSOLETE d10v_return_value (struct gdbarch *gdbarch, struct type *valtype,
// OBSOLETE 		   struct regcache *regcache, void *readbuf,
// OBSOLETE 		   const void *writebuf)
// OBSOLETE {
// OBSOLETE   if (TYPE_LENGTH (valtype) > 8)
// OBSOLETE     /* Anything larger than 8 bytes (4 registers) goes on the stack.  */
// OBSOLETE     return RETURN_VALUE_STRUCT_CONVENTION;
// OBSOLETE   if (TYPE_LENGTH (valtype) == 5
// OBSOLETE       || TYPE_LENGTH (valtype) == 6)
// OBSOLETE     /* Anything 5 or 6 bytes in size goes in memory.  Contents don't
// OBSOLETE        appear to matter.  Note that 7 and 8 byte objects do end up in
// OBSOLETE        registers!  */
// OBSOLETE     return RETURN_VALUE_STRUCT_CONVENTION;
// OBSOLETE   if (TYPE_LENGTH (valtype) == 1)
// OBSOLETE     {
// OBSOLETE       /* All single byte values go in a register stored right-aligned.
// OBSOLETE          Note: 2 byte integer values are handled further down.  */
// OBSOLETE       if (readbuf)
// OBSOLETE 	{
// OBSOLETE 	  /* Since TYPE is smaller than the register, there isn't a
// OBSOLETE              sign extension problem.  Let the extraction truncate the
// OBSOLETE              register value.  */
// OBSOLETE 	  ULONGEST regval;
// OBSOLETE 	  regcache_cooked_read_unsigned (regcache, R0_REGNUM,
// OBSOLETE 					 &regval);
// OBSOLETE 	  store_unsigned_integer (readbuf, TYPE_LENGTH (valtype), regval);
// OBSOLETE 
// OBSOLETE 	}
// OBSOLETE       if (writebuf)
// OBSOLETE 	{
// OBSOLETE 	  ULONGEST regval;
// OBSOLETE 	  if (TYPE_CODE (valtype) == TYPE_CODE_INT)
// OBSOLETE 	    /* Some sort of integer value stored in R0.  Use
// OBSOLETE 	       unpack_long since that should handle any required sign
// OBSOLETE 	       extension.  */
// OBSOLETE 	    regval = unpack_long (valtype, writebuf);
// OBSOLETE 	  else
// OBSOLETE 	    /* Some other type.  Don't sign-extend the value when
// OBSOLETE                storing it in the register.  */
// OBSOLETE 	    regval = extract_unsigned_integer (writebuf, 1);
// OBSOLETE 	  regcache_cooked_write_unsigned (regcache, R0_REGNUM, regval);
// OBSOLETE 	}
// OBSOLETE       return RETURN_VALUE_REGISTER_CONVENTION;
// OBSOLETE     }
// OBSOLETE   if ((TYPE_CODE (valtype) == TYPE_CODE_STRUCT
// OBSOLETE        || TYPE_CODE (valtype) == TYPE_CODE_UNION)
// OBSOLETE       && TYPE_NFIELDS (valtype) > 1
// OBSOLETE       && TYPE_FIELD_BITPOS (valtype, 1) == 8)
// OBSOLETE     /* If a composite is 8 bit aligned (determined by looking at the
// OBSOLETE        start address of the second field), put it in memory.  */
// OBSOLETE     return RETURN_VALUE_STRUCT_CONVENTION;
// OBSOLETE   /* Assume it is in registers.  */
// OBSOLETE   if (writebuf || readbuf)
// OBSOLETE     {
// OBSOLETE       int reg;
// OBSOLETE       /* Per above, the value is never more than 8 bytes long.  */
// OBSOLETE       gdb_assert (TYPE_LENGTH (valtype) <= 8);
// OBSOLETE       /* Xfer 2 bytes at a time.  */
// OBSOLETE       for (reg = 0; (reg * 2) + 1 < TYPE_LENGTH (valtype); reg++)
// OBSOLETE 	{
// OBSOLETE 	  if (readbuf)
// OBSOLETE 	    regcache_cooked_read (regcache, R0_REGNUM + reg,
// OBSOLETE 				  (bfd_byte *) readbuf + reg * 2);
// OBSOLETE 	  if (writebuf)
// OBSOLETE 	    regcache_cooked_write (regcache, R0_REGNUM + reg,
// OBSOLETE 				   (bfd_byte *) writebuf + reg * 2);
// OBSOLETE 	}
// OBSOLETE       /* Any trailing byte ends up _left_ aligned.  */
// OBSOLETE       if ((reg * 2) < TYPE_LENGTH (valtype))
// OBSOLETE 	{
// OBSOLETE 	  if (readbuf)
// OBSOLETE 	    regcache_cooked_read_part (regcache, R0_REGNUM + reg,
// OBSOLETE 				       0, 1, (bfd_byte *) readbuf + reg * 2);
// OBSOLETE 	  if (writebuf)
// OBSOLETE 	    regcache_cooked_write_part (regcache, R0_REGNUM + reg,
// OBSOLETE 					0, 1, (bfd_byte *) writebuf + reg * 2);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   return RETURN_VALUE_REGISTER_CONVENTION;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE check_prologue (unsigned short op)
// OBSOLETE {
// OBSOLETE   /* st  rn, @@-sp */
// OBSOLETE   if ((op & 0x7E1F) == 0x6C1F)
// OBSOLETE     return 1;
// OBSOLETE 
// OBSOLETE   /* st2w  rn, @@-sp */
// OBSOLETE   if ((op & 0x7E3F) == 0x6E1F)
// OBSOLETE     return 1;
// OBSOLETE 
// OBSOLETE   /* subi  sp, n */
// OBSOLETE   if ((op & 0x7FE1) == 0x01E1)
// OBSOLETE     return 1;
// OBSOLETE 
// OBSOLETE   /* mv  r11, sp */
// OBSOLETE   if (op == 0x417E)
// OBSOLETE     return 1;
// OBSOLETE 
// OBSOLETE   /* nop */
// OBSOLETE   if (op == 0x5E00)
// OBSOLETE     return 1;
// OBSOLETE 
// OBSOLETE   /* st  rn, @@sp */
// OBSOLETE   if ((op & 0x7E1F) == 0x681E)
// OBSOLETE     return 1;
// OBSOLETE 
// OBSOLETE   /* st2w  rn, @@sp */
// OBSOLETE   if ((op & 0x7E3F) == 0x3A1E)
// OBSOLETE     return 1;
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE d10v_skip_prologue (CORE_ADDR pc)
// OBSOLETE {
// OBSOLETE   unsigned long op;
// OBSOLETE   unsigned short op1, op2;
// OBSOLETE   CORE_ADDR func_addr, func_end;
// OBSOLETE   struct symtab_and_line sal;
// OBSOLETE 
// OBSOLETE   /* If we have line debugging information, then the end of the prologue 
// OBSOLETE      should be the first assembly instruction of the first source line.  */
// OBSOLETE   if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
// OBSOLETE     {
// OBSOLETE       sal = find_pc_line (func_addr, 0);
// OBSOLETE       if (sal.end && sal.end < func_end)
// OBSOLETE 	return sal.end;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (target_read_memory (pc, (char *) &op, 4))
// OBSOLETE     return pc;			/* Can't access it -- assume no prologue.  */
// OBSOLETE 
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       op = (unsigned long) read_memory_integer (pc, 4);
// OBSOLETE       if ((op & 0xC0000000) == 0xC0000000)
// OBSOLETE 	{
// OBSOLETE 	  /* long instruction */
// OBSOLETE 	  if (((op & 0x3FFF0000) != 0x01FF0000) &&	/* add3 sp,sp,n */
// OBSOLETE 	      ((op & 0x3F0F0000) != 0x340F0000) &&	/* st  rn, @@(offset,sp) */
// OBSOLETE 	      ((op & 0x3F1F0000) != 0x350F0000))	/* st2w  rn, @@(offset,sp) */
// OBSOLETE 	    break;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* short instructions */
// OBSOLETE 	  if ((op & 0xC0000000) == 0x80000000)
// OBSOLETE 	    {
// OBSOLETE 	      op2 = (op & 0x3FFF8000) >> 15;
// OBSOLETE 	      op1 = op & 0x7FFF;
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      op1 = (op & 0x3FFF8000) >> 15;
// OBSOLETE 	      op2 = op & 0x7FFF;
// OBSOLETE 	    }
// OBSOLETE 	  if (check_prologue (op1))
// OBSOLETE 	    {
// OBSOLETE 	      if (!check_prologue (op2))
// OBSOLETE 		{
// OBSOLETE 		  /* If the previous opcode was really part of the
// OBSOLETE 		     prologue and not just a NOP, then we want to
// OBSOLETE 		     break after both instructions.  */
// OBSOLETE 		  if (op1 != 0x5E00)
// OBSOLETE 		    pc += 4;
// OBSOLETE 		  break;
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    break;
// OBSOLETE 	}
// OBSOLETE       pc += 4;
// OBSOLETE     }
// OBSOLETE   return pc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE struct d10v_unwind_cache
// OBSOLETE {
// OBSOLETE   /* The previous frame's inner most stack address.  Used as this
// OBSOLETE      frame ID's stack_addr.  */
// OBSOLETE   CORE_ADDR prev_sp;
// OBSOLETE   /* The frame's base, optionally used by the high-level debug info.  */
// OBSOLETE   CORE_ADDR base;
// OBSOLETE   int size;
// OBSOLETE   /* How far the SP and r11 (FP) have been offset from the start of
// OBSOLETE      the stack frame (as defined by the previous frame's stack
// OBSOLETE      pointer).  */
// OBSOLETE   LONGEST sp_offset;
// OBSOLETE   LONGEST r11_offset;
// OBSOLETE   int uses_frame;
// OBSOLETE   /* Table indicating the location of each and every register.  */
// OBSOLETE   struct trad_frame_saved_reg *saved_regs;
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE prologue_find_regs (struct d10v_unwind_cache *info, unsigned short op,
// OBSOLETE 		    CORE_ADDR addr)
// OBSOLETE {
// OBSOLETE   int n;
// OBSOLETE 
// OBSOLETE   /* st  rn, @@-sp */
// OBSOLETE   if ((op & 0x7E1F) == 0x6C1F)
// OBSOLETE     {
// OBSOLETE       n = (op & 0x1E0) >> 5;
// OBSOLETE       info->sp_offset -= 2;
// OBSOLETE       info->saved_regs[n].addr = info->sp_offset;
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* st2w  rn, @@-sp */
// OBSOLETE   else if ((op & 0x7E3F) == 0x6E1F)
// OBSOLETE     {
// OBSOLETE       n = (op & 0x1E0) >> 5;
// OBSOLETE       info->sp_offset -= 4;
// OBSOLETE       info->saved_regs[n + 0].addr = info->sp_offset + 0;
// OBSOLETE       info->saved_regs[n + 1].addr = info->sp_offset + 2;
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* subi  sp, n */
// OBSOLETE   if ((op & 0x7FE1) == 0x01E1)
// OBSOLETE     {
// OBSOLETE       n = (op & 0x1E) >> 1;
// OBSOLETE       if (n == 0)
// OBSOLETE 	n = 16;
// OBSOLETE       info->sp_offset -= n;
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* mv  r11, sp */
// OBSOLETE   if (op == 0x417E)
// OBSOLETE     {
// OBSOLETE       info->uses_frame = 1;
// OBSOLETE       info->r11_offset = info->sp_offset;
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* st  rn, @@r11 */
// OBSOLETE   if ((op & 0x7E1F) == 0x6816)
// OBSOLETE     {
// OBSOLETE       n = (op & 0x1E0) >> 5;
// OBSOLETE       info->saved_regs[n].addr = info->r11_offset;
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* nop */
// OBSOLETE   if (op == 0x5E00)
// OBSOLETE     return 1;
// OBSOLETE 
// OBSOLETE   /* st  rn, @@sp */
// OBSOLETE   if ((op & 0x7E1F) == 0x681E)
// OBSOLETE     {
// OBSOLETE       n = (op & 0x1E0) >> 5;
// OBSOLETE       info->saved_regs[n].addr = info->sp_offset;
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* st2w  rn, @@sp */
// OBSOLETE   if ((op & 0x7E3F) == 0x3A1E)
// OBSOLETE     {
// OBSOLETE       n = (op & 0x1E0) >> 5;
// OBSOLETE       info->saved_regs[n + 0].addr = info->sp_offset + 0;
// OBSOLETE       info->saved_regs[n + 1].addr = info->sp_offset + 2;
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Put here the code to store, into fi->saved_regs, the addresses of
// OBSOLETE    the saved registers of frame described by FRAME_INFO.  This
// OBSOLETE    includes special registers such as pc and fp saved in special ways
// OBSOLETE    in the stack frame.  sp is even more special: the address we return
// OBSOLETE    for it IS the sp for the next frame.  */
// OBSOLETE 
// OBSOLETE static struct d10v_unwind_cache *
// OBSOLETE d10v_frame_unwind_cache (struct frame_info *next_frame,
// OBSOLETE 			 void **this_prologue_cache)
// OBSOLETE {
// OBSOLETE   struct gdbarch *gdbarch = get_frame_arch (next_frame);
// OBSOLETE   CORE_ADDR pc;
// OBSOLETE   ULONGEST prev_sp;
// OBSOLETE   ULONGEST this_base;
// OBSOLETE   unsigned long op;
// OBSOLETE   unsigned short op1, op2;
// OBSOLETE   int i;
// OBSOLETE   struct d10v_unwind_cache *info;
// OBSOLETE 
// OBSOLETE   if ((*this_prologue_cache))
// OBSOLETE     return (*this_prologue_cache);
// OBSOLETE 
// OBSOLETE   info = FRAME_OBSTACK_ZALLOC (struct d10v_unwind_cache);
// OBSOLETE   (*this_prologue_cache) = info;
// OBSOLETE   info->saved_regs = trad_frame_alloc_saved_regs (next_frame);
// OBSOLETE 
// OBSOLETE   info->size = 0;
// OBSOLETE   info->sp_offset = 0;
// OBSOLETE 
// OBSOLETE   info->uses_frame = 0;
// OBSOLETE   for (pc = frame_func_unwind (next_frame);
// OBSOLETE        pc > 0 && pc < frame_pc_unwind (next_frame);
// OBSOLETE        pc += 4)
// OBSOLETE     {
// OBSOLETE       op = get_frame_memory_unsigned (next_frame, pc, 4);
// OBSOLETE       if ((op & 0xC0000000) == 0xC0000000)
// OBSOLETE 	{
// OBSOLETE 	  /* long instruction */
// OBSOLETE 	  if ((op & 0x3FFF0000) == 0x01FF0000)
// OBSOLETE 	    {
// OBSOLETE 	      /* add3 sp,sp,n */
// OBSOLETE 	      short n = op & 0xFFFF;
// OBSOLETE 	      info->sp_offset += n;
// OBSOLETE 	    }
// OBSOLETE 	  else if ((op & 0x3F0F0000) == 0x340F0000)
// OBSOLETE 	    {
// OBSOLETE 	      /* st  rn, @@(offset,sp) */
// OBSOLETE 	      short offset = op & 0xFFFF;
// OBSOLETE 	      short n = (op >> 20) & 0xF;
// OBSOLETE 	      info->saved_regs[n].addr = info->sp_offset + offset;
// OBSOLETE 	    }
// OBSOLETE 	  else if ((op & 0x3F1F0000) == 0x350F0000)
// OBSOLETE 	    {
// OBSOLETE 	      /* st2w  rn, @@(offset,sp) */
// OBSOLETE 	      short offset = op & 0xFFFF;
// OBSOLETE 	      short n = (op >> 20) & 0xF;
// OBSOLETE 	      info->saved_regs[n + 0].addr = info->sp_offset + offset + 0;
// OBSOLETE 	      info->saved_regs[n + 1].addr = info->sp_offset + offset + 2;
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    break;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* short instructions */
// OBSOLETE 	  if ((op & 0xC0000000) == 0x80000000)
// OBSOLETE 	    {
// OBSOLETE 	      op2 = (op & 0x3FFF8000) >> 15;
// OBSOLETE 	      op1 = op & 0x7FFF;
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      op1 = (op & 0x3FFF8000) >> 15;
// OBSOLETE 	      op2 = op & 0x7FFF;
// OBSOLETE 	    }
// OBSOLETE 	  if (!prologue_find_regs (info, op1, pc) 
// OBSOLETE 	      || !prologue_find_regs (info, op2, pc))
// OBSOLETE 	    break;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   info->size = -info->sp_offset;
// OBSOLETE 
// OBSOLETE   /* Compute the previous frame's stack pointer (which is also the
// OBSOLETE      frame's ID's stack address), and this frame's base pointer.  */
// OBSOLETE   if (info->uses_frame)
// OBSOLETE     {
// OBSOLETE       /* The SP was moved to the FP.  This indicates that a new frame
// OBSOLETE          was created.  Get THIS frame's FP value by unwinding it from
// OBSOLETE          the next frame.  */
// OBSOLETE       frame_unwind_unsigned_register (next_frame, D10V_FP_REGNUM, &this_base);
// OBSOLETE       /* The FP points at the last saved register.  Adjust the FP back
// OBSOLETE          to before the first saved register giving the SP.  */
// OBSOLETE       prev_sp = this_base + info->size;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* Assume that the FP is this frame's SP but with that pushed
// OBSOLETE          stack space added back.  */
// OBSOLETE       frame_unwind_unsigned_register (next_frame, D10V_SP_REGNUM, &this_base);
// OBSOLETE       prev_sp = this_base + info->size;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Convert that SP/BASE into real addresses.  */
// OBSOLETE   info->prev_sp =  d10v_make_daddr (prev_sp);
// OBSOLETE   info->base = d10v_make_daddr (this_base);
// OBSOLETE 
// OBSOLETE   /* Adjust all the saved registers so that they contain addresses and
// OBSOLETE      not offsets.  */
// OBSOLETE   for (i = 0; i < NUM_REGS - 1; i++)
// OBSOLETE     if (trad_frame_addr_p (info->saved_regs, i))
// OBSOLETE       {
// OBSOLETE 	info->saved_regs[i].addr = (info->prev_sp + info->saved_regs[i].addr);
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE   /* The call instruction moves the caller's PC in the callee's LR.
// OBSOLETE      Since this is an unwind, do the reverse.  Copy the location of LR
// OBSOLETE      into PC (the address / regnum) so that a request for PC will be
// OBSOLETE      converted into a request for the LR.  */
// OBSOLETE   info->saved_regs[D10V_PC_REGNUM] = info->saved_regs[LR_REGNUM];
// OBSOLETE 
// OBSOLETE   /* The previous frame's SP needed to be computed.  Save the computed
// OBSOLETE      value.  */
// OBSOLETE   trad_frame_set_value (info->saved_regs, D10V_SP_REGNUM,
// OBSOLETE 			d10v_make_daddr (prev_sp));
// OBSOLETE 
// OBSOLETE   return info;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE d10v_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file,
// OBSOLETE 			   struct frame_info *frame, int regnum, int all)
// OBSOLETE {
// OBSOLETE   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
// OBSOLETE   if (regnum >= 0)
// OBSOLETE     {
// OBSOLETE       default_print_registers_info (gdbarch, file, frame, regnum, all);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   {
// OBSOLETE     ULONGEST pc, psw, rpt_s, rpt_e, rpt_c;
// OBSOLETE     pc = get_frame_register_unsigned (frame, D10V_PC_REGNUM);
// OBSOLETE     psw = get_frame_register_unsigned (frame, PSW_REGNUM);
// OBSOLETE     rpt_s = get_frame_register_unsigned (frame, frame_map_name_to_regnum (frame, "rpt_s", -1));
// OBSOLETE     rpt_e = get_frame_register_unsigned (frame, frame_map_name_to_regnum (frame, "rpt_e", -1));
// OBSOLETE     rpt_c = get_frame_register_unsigned (frame, frame_map_name_to_regnum (frame, "rpt_c", -1));
// OBSOLETE     fprintf_filtered (file, "PC=%04lx (0x%lx) PSW=%04lx RPT_S=%04lx RPT_E=%04lx RPT_C=%04lx\n",
// OBSOLETE 		     (long) pc, (long) d10v_make_iaddr (pc), (long) psw,
// OBSOLETE 		     (long) rpt_s, (long) rpt_e, (long) rpt_c);
// OBSOLETE   }
// OBSOLETE 
// OBSOLETE   {
// OBSOLETE     int group;
// OBSOLETE     for (group = 0; group < 16; group += 8)
// OBSOLETE       {
// OBSOLETE 	int r;
// OBSOLETE 	fprintf_filtered (file, "R%d-R%-2d", group, group + 7);
// OBSOLETE 	for (r = group; r < group + 8; r++)
// OBSOLETE 	  {
// OBSOLETE 	    ULONGEST tmp;
// OBSOLETE 	    tmp = get_frame_register_unsigned (frame, r);
// OBSOLETE 	    fprintf_filtered (file, " %04lx", (long) tmp);
// OBSOLETE 	  }
// OBSOLETE 	fprintf_filtered (file, "\n");
// OBSOLETE       }
// OBSOLETE   }
// OBSOLETE 
// OBSOLETE   /* Note: The IMAP/DMAP registers don't participate in function
// OBSOLETE      calls.  Don't bother trying to unwind them.  */
// OBSOLETE 
// OBSOLETE   {
// OBSOLETE     int a;
// OBSOLETE     for (a = 0; a < NR_IMAP_REGS; a++)
// OBSOLETE       {
// OBSOLETE 	if (a > 0)
// OBSOLETE 	  fprintf_filtered (file, "    ");
// OBSOLETE 	fprintf_filtered (file, "IMAP%d %04lx", a,
// OBSOLETE 			  tdep->imap_register (current_regcache, a));
// OBSOLETE       }
// OBSOLETE     if (nr_dmap_regs (gdbarch) == 1)
// OBSOLETE       /* Registers DMAP0 and DMAP1 are constant.  Just return dmap2.  */
// OBSOLETE       fprintf_filtered (file, "    DMAP %04lx\n",
// OBSOLETE 			tdep->dmap_register (current_regcache, 2));
// OBSOLETE     else
// OBSOLETE       {
// OBSOLETE 	for (a = 0; a < nr_dmap_regs (gdbarch); a++)
// OBSOLETE 	  {
// OBSOLETE 	    fprintf_filtered (file, "    DMAP%d %04lx", a,
// OBSOLETE 			      tdep->dmap_register (current_regcache, a));
// OBSOLETE 	  }
// OBSOLETE 	fprintf_filtered (file, "\n");
// OBSOLETE       }
// OBSOLETE   }
// OBSOLETE 
// OBSOLETE   {
// OBSOLETE     char num[MAX_REGISTER_SIZE];
// OBSOLETE     int a;
// OBSOLETE     fprintf_filtered (file, "A0-A%d", NR_A_REGS - 1);
// OBSOLETE     for (a = a0_regnum (gdbarch); a < a0_regnum (gdbarch) + NR_A_REGS; a++)
// OBSOLETE       {
// OBSOLETE 	int i;
// OBSOLETE 	fprintf_filtered (file, "  ");
// OBSOLETE 	get_frame_register (frame, a, num);
// OBSOLETE 	for (i = 0; i < register_size (gdbarch, a); i++)
// OBSOLETE 	  {
// OBSOLETE 	    fprintf_filtered (file, "%02x", (num[i] & 0xff));
// OBSOLETE 	  }
// OBSOLETE       }
// OBSOLETE   }
// OBSOLETE   fprintf_filtered (file, "\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE show_regs (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   d10v_print_registers_info (current_gdbarch, gdb_stdout,
// OBSOLETE 			     get_current_frame (), -1, 1);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE d10v_read_pc (ptid_t ptid)
// OBSOLETE {
// OBSOLETE   ptid_t save_ptid;
// OBSOLETE   CORE_ADDR pc;
// OBSOLETE   CORE_ADDR retval;
// OBSOLETE 
// OBSOLETE   save_ptid = inferior_ptid;
// OBSOLETE   inferior_ptid = ptid;
// OBSOLETE   pc = (int) read_register (D10V_PC_REGNUM);
// OBSOLETE   inferior_ptid = save_ptid;
// OBSOLETE   retval = d10v_make_iaddr (pc);
// OBSOLETE   return retval;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE d10v_write_pc (CORE_ADDR val, ptid_t ptid)
// OBSOLETE {
// OBSOLETE   ptid_t save_ptid;
// OBSOLETE 
// OBSOLETE   save_ptid = inferior_ptid;
// OBSOLETE   inferior_ptid = ptid;
// OBSOLETE   write_register (D10V_PC_REGNUM, d10v_convert_iaddr_to_raw (val));
// OBSOLETE   inferior_ptid = save_ptid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE d10v_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
// OBSOLETE {
// OBSOLETE   ULONGEST sp;
// OBSOLETE   frame_unwind_unsigned_register (next_frame, D10V_SP_REGNUM, &sp);
// OBSOLETE   return d10v_make_daddr (sp);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* When arguments must be pushed onto the stack, they go on in reverse
// OBSOLETE    order.  The below implements a FILO (stack) to do this.  */
// OBSOLETE 
// OBSOLETE struct stack_item
// OBSOLETE {
// OBSOLETE   int len;
// OBSOLETE   struct stack_item *prev;
// OBSOLETE   void *data;
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static struct stack_item *push_stack_item (struct stack_item *prev,
// OBSOLETE 					   void *contents, int len);
// OBSOLETE static struct stack_item *
// OBSOLETE push_stack_item (struct stack_item *prev, void *contents, int len)
// OBSOLETE {
// OBSOLETE   struct stack_item *si;
// OBSOLETE   si = xmalloc (sizeof (struct stack_item));
// OBSOLETE   si->data = xmalloc (len);
// OBSOLETE   si->len = len;
// OBSOLETE   si->prev = prev;
// OBSOLETE   memcpy (si->data, contents, len);
// OBSOLETE   return si;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct stack_item *pop_stack_item (struct stack_item *si);
// OBSOLETE static struct stack_item *
// OBSOLETE pop_stack_item (struct stack_item *si)
// OBSOLETE {
// OBSOLETE   struct stack_item *dead = si;
// OBSOLETE   si = si->prev;
// OBSOLETE   xfree (dead->data);
// OBSOLETE   xfree (dead);
// OBSOLETE   return si;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE d10v_push_dummy_code (struct gdbarch *gdbarch,
// OBSOLETE 		      CORE_ADDR sp, CORE_ADDR funaddr, int using_gcc,
// OBSOLETE 		      struct value **args, int nargs,
// OBSOLETE 		      struct type *value_type,
// OBSOLETE 		      CORE_ADDR *real_pc, CORE_ADDR *bp_addr)
// OBSOLETE {
// OBSOLETE   /* Allocate space sufficient for a breakpoint.  */
// OBSOLETE   sp = (sp - 4) & ~3;
// OBSOLETE   /* Store the address of that breakpoint taking care to first convert
// OBSOLETE      it into a code (IADDR) address from a stack (DADDR) address.
// OBSOLETE      This of course assumes that the two virtual addresses map onto
// OBSOLETE      the same real address.  */
// OBSOLETE   (*bp_addr) = d10v_make_iaddr (d10v_convert_iaddr_to_raw (sp));
// OBSOLETE   /* d10v always starts the call at the callee's entry point.  */
// OBSOLETE   (*real_pc) = funaddr;
// OBSOLETE   return sp;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE d10v_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
// OBSOLETE 		      struct regcache *regcache, CORE_ADDR bp_addr,
// OBSOLETE 		      int nargs, struct value **args, CORE_ADDR sp, 
// OBSOLETE 		      int struct_return, CORE_ADDR struct_addr)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   int regnum = ARG1_REGNUM;
// OBSOLETE   struct stack_item *si = NULL;
// OBSOLETE   long val;
// OBSOLETE 
// OBSOLETE   /* Set the return address.  For the d10v, the return breakpoint is
// OBSOLETE      always at BP_ADDR.  */
// OBSOLETE   regcache_cooked_write_unsigned (regcache, LR_REGNUM,
// OBSOLETE 				  d10v_convert_iaddr_to_raw (bp_addr));
// OBSOLETE 
// OBSOLETE   /* If STRUCT_RETURN is true, then the struct return address (in
// OBSOLETE      STRUCT_ADDR) will consume the first argument-passing register.
// OBSOLETE      Both adjust the register count and store that value.  */
// OBSOLETE   if (struct_return)
// OBSOLETE     {
// OBSOLETE       regcache_cooked_write_unsigned (regcache, regnum, struct_addr);
// OBSOLETE       regnum++;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Fill in registers and arg lists */
// OBSOLETE   for (i = 0; i < nargs; i++)
// OBSOLETE     {
// OBSOLETE       struct value *arg = args[i];
// OBSOLETE       struct type *type = check_typedef (VALUE_TYPE (arg));
// OBSOLETE       char *contents = VALUE_CONTENTS (arg);
// OBSOLETE       int len = TYPE_LENGTH (type);
// OBSOLETE       int aligned_regnum = (regnum + 1) & ~1;
// OBSOLETE 
// OBSOLETE       /* printf ("push: type=%d len=%d\n", TYPE_CODE (type), len); */
// OBSOLETE       if (len <= 2 && regnum <= ARGN_REGNUM)
// OBSOLETE 	/* fits in a single register, do not align */
// OBSOLETE 	{
// OBSOLETE 	  val = extract_unsigned_integer (contents, len);
// OBSOLETE 	  regcache_cooked_write_unsigned (regcache, regnum++, val);
// OBSOLETE 	}
// OBSOLETE       else if (len <= (ARGN_REGNUM - aligned_regnum + 1) * 2)
// OBSOLETE 	/* value fits in remaining registers, store keeping left
// OBSOLETE 	   aligned */
// OBSOLETE 	{
// OBSOLETE 	  int b;
// OBSOLETE 	  regnum = aligned_regnum;
// OBSOLETE 	  for (b = 0; b < (len & ~1); b += 2)
// OBSOLETE 	    {
// OBSOLETE 	      val = extract_unsigned_integer (&contents[b], 2);
// OBSOLETE 	      regcache_cooked_write_unsigned (regcache, regnum++, val);
// OBSOLETE 	    }
// OBSOLETE 	  if (b < len)
// OBSOLETE 	    {
// OBSOLETE 	      val = extract_unsigned_integer (&contents[b], 1);
// OBSOLETE 	      regcache_cooked_write_unsigned (regcache, regnum++, (val << 8));
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* arg will go onto stack */
// OBSOLETE 	  regnum = ARGN_REGNUM + 1;
// OBSOLETE 	  si = push_stack_item (si, contents, len);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   while (si)
// OBSOLETE     {
// OBSOLETE       sp = (sp - si->len) & ~1;
// OBSOLETE       write_memory (sp, si->data, si->len);
// OBSOLETE       si = pop_stack_item (si);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Finally, update the SP register.  */
// OBSOLETE   regcache_cooked_write_unsigned (regcache, D10V_SP_REGNUM,
// OBSOLETE 				  d10v_convert_daddr_to_raw (sp));
// OBSOLETE 
// OBSOLETE   return sp;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Translate a GDB virtual ADDR/LEN into a format the remote target
// OBSOLETE    understands.  Returns number of bytes that can be transfered
// OBSOLETE    starting at TARG_ADDR.  Return ZERO if no bytes can be transfered
// OBSOLETE    (segmentation fault).  Since the simulator knows all about how the
// OBSOLETE    VM system works, we just call that to do the translation.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE remote_d10v_translate_xfer_address (struct gdbarch *gdbarch,
// OBSOLETE 				    struct regcache *regcache,
// OBSOLETE 				    CORE_ADDR memaddr, int nr_bytes,
// OBSOLETE 				    CORE_ADDR *targ_addr, int *targ_len)
// OBSOLETE {
// OBSOLETE   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
// OBSOLETE   long out_addr;
// OBSOLETE   long out_len;
// OBSOLETE   out_len = sim_d10v_translate_addr (memaddr, nr_bytes, &out_addr, regcache,
// OBSOLETE 				     tdep->dmap_register, tdep->imap_register);
// OBSOLETE   *targ_addr = out_addr;
// OBSOLETE   *targ_len = out_len;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* The following code implements access to, and display of, the D10V's
// OBSOLETE    instruction trace buffer.  The buffer consists of 64K or more
// OBSOLETE    4-byte words of data, of which each words includes an 8-bit count,
// OBSOLETE    an 8-bit segment number, and a 16-bit instruction address.
// OBSOLETE 
// OBSOLETE    In theory, the trace buffer is continuously capturing instruction
// OBSOLETE    data that the CPU presents on its "debug bus", but in practice, the
// OBSOLETE    ROMified GDB stub only enables tracing when it continues or steps
// OBSOLETE    the program, and stops tracing when the program stops; so it
// OBSOLETE    actually works for GDB to read the buffer counter out of memory and
// OBSOLETE    then read each trace word.  The counter records where the tracing
// OBSOLETE    stops, but there is no record of where it started, so we remember
// OBSOLETE    the PC when we resumed and then search backwards in the trace
// OBSOLETE    buffer for a word that includes that address.  This is not perfect,
// OBSOLETE    because you will miss trace data if the resumption PC is the target
// OBSOLETE    of a branch.  (The value of the buffer counter is semi-random, any
// OBSOLETE    trace data from a previous program stop is gone.)  */
// OBSOLETE 
// OBSOLETE /* The address of the last word recorded in the trace buffer.  */
// OBSOLETE 
// OBSOLETE #define DBBC_ADDR (0xd80000)
// OBSOLETE 
// OBSOLETE /* The base of the trace buffer, at least for the "Board_0".  */
// OBSOLETE 
// OBSOLETE #define TRACE_BUFFER_BASE (0xf40000)
// OBSOLETE 
// OBSOLETE static void trace_command (char *, int);
// OBSOLETE 
// OBSOLETE static void untrace_command (char *, int);
// OBSOLETE 
// OBSOLETE static void trace_info (char *, int);
// OBSOLETE 
// OBSOLETE static void tdisassemble_command (char *, int);
// OBSOLETE 
// OBSOLETE static void display_trace (int, int);
// OBSOLETE 
// OBSOLETE /* True when instruction traces are being collected.  */
// OBSOLETE 
// OBSOLETE static int tracing;
// OBSOLETE 
// OBSOLETE /* Remembered PC.  */
// OBSOLETE 
// OBSOLETE static CORE_ADDR last_pc;
// OBSOLETE 
// OBSOLETE /* True when trace output should be displayed whenever program stops.  */
// OBSOLETE 
// OBSOLETE static int trace_display;
// OBSOLETE 
// OBSOLETE /* True when trace listing should include source lines.  */
// OBSOLETE 
// OBSOLETE static int default_trace_show_source = 1;
// OBSOLETE 
// OBSOLETE struct trace_buffer
// OBSOLETE   {
// OBSOLETE     int size;
// OBSOLETE     short *counts;
// OBSOLETE     CORE_ADDR *addrs;
// OBSOLETE   }
// OBSOLETE trace_data;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE trace_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   /* Clear the host-side trace buffer, allocating space if needed.  */
// OBSOLETE   trace_data.size = 0;
// OBSOLETE   if (trace_data.counts == NULL)
// OBSOLETE     trace_data.counts = XCALLOC (65536, short);
// OBSOLETE   if (trace_data.addrs == NULL)
// OBSOLETE     trace_data.addrs = XCALLOC (65536, CORE_ADDR);
// OBSOLETE 
// OBSOLETE   tracing = 1;
// OBSOLETE 
// OBSOLETE   printf_filtered ("Tracing is now on.\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE untrace_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   tracing = 0;
// OBSOLETE 
// OBSOLETE   printf_filtered ("Tracing is now off.\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE trace_info (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   if (trace_data.size)
// OBSOLETE     {
// OBSOLETE       printf_filtered ("%d entries in trace buffer:\n", trace_data.size);
// OBSOLETE 
// OBSOLETE       for (i = 0; i < trace_data.size; ++i)
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered ("%d: %d instruction%s at 0x%s\n",
// OBSOLETE 			   i,
// OBSOLETE 			   trace_data.counts[i],
// OBSOLETE 			   (trace_data.counts[i] == 1 ? "" : "s"),
// OBSOLETE 			   paddr_nz (trace_data.addrs[i]));
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     printf_filtered ("No entries in trace buffer.\n");
// OBSOLETE 
// OBSOLETE   printf_filtered ("Tracing is currently %s.\n", (tracing ? "on" : "off"));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE d10v_eva_prepare_to_trace (void)
// OBSOLETE {
// OBSOLETE   if (!tracing)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   last_pc = read_register (D10V_PC_REGNUM);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Collect trace data from the target board and format it into a form
// OBSOLETE    more useful for display.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE d10v_eva_get_trace_data (void)
// OBSOLETE {
// OBSOLETE   int count, i, j, oldsize;
// OBSOLETE   int trace_addr, trace_seg, trace_cnt, next_cnt;
// OBSOLETE   unsigned int last_trace, trace_word, next_word;
// OBSOLETE   unsigned int *tmpspace;
// OBSOLETE 
// OBSOLETE   if (!tracing)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   tmpspace = xmalloc (65536 * sizeof (unsigned int));
// OBSOLETE 
// OBSOLETE   last_trace = read_memory_unsigned_integer (DBBC_ADDR, 2) << 2;
// OBSOLETE 
// OBSOLETE   /* Collect buffer contents from the target, stopping when we reach
// OBSOLETE      the word recorded when execution resumed.  */
// OBSOLETE 
// OBSOLETE   count = 0;
// OBSOLETE   while (last_trace > 0)
// OBSOLETE     {
// OBSOLETE       QUIT;
// OBSOLETE       trace_word =
// OBSOLETE 	read_memory_unsigned_integer (TRACE_BUFFER_BASE + last_trace, 4);
// OBSOLETE       trace_addr = trace_word & 0xffff;
// OBSOLETE       last_trace -= 4;
// OBSOLETE       /* Ignore an apparently nonsensical entry.  */
// OBSOLETE       if (trace_addr == 0xffd5)
// OBSOLETE 	continue;
// OBSOLETE       tmpspace[count++] = trace_word;
// OBSOLETE       if (trace_addr == last_pc)
// OBSOLETE 	break;
// OBSOLETE       if (count > 65535)
// OBSOLETE 	break;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Move the data to the host-side trace buffer, adjusting counts to
// OBSOLETE      include the last instruction executed and transforming the address
// OBSOLETE      into something that GDB likes.  */
// OBSOLETE 
// OBSOLETE   for (i = 0; i < count; ++i)
// OBSOLETE     {
// OBSOLETE       trace_word = tmpspace[i];
// OBSOLETE       next_word = ((i == 0) ? 0 : tmpspace[i - 1]);
// OBSOLETE       trace_addr = trace_word & 0xffff;
// OBSOLETE       next_cnt = (next_word >> 24) & 0xff;
// OBSOLETE       j = trace_data.size + count - i - 1;
// OBSOLETE       trace_data.addrs[j] = (trace_addr << 2) + 0x1000000;
// OBSOLETE       trace_data.counts[j] = next_cnt + 1;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   oldsize = trace_data.size;
// OBSOLETE   trace_data.size += count;
// OBSOLETE 
// OBSOLETE   xfree (tmpspace);
// OBSOLETE 
// OBSOLETE   if (trace_display)
// OBSOLETE     display_trace (oldsize, trace_data.size);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE tdisassemble_command (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   int i, count;
// OBSOLETE   CORE_ADDR low, high;
// OBSOLETE 
// OBSOLETE   if (!arg)
// OBSOLETE     {
// OBSOLETE       low = 0;
// OBSOLETE       high = trace_data.size;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     { 
// OBSOLETE       char *space_index = strchr (arg, ' ');
// OBSOLETE       if (space_index == NULL)
// OBSOLETE 	{
// OBSOLETE 	  low = parse_and_eval_address (arg);
// OBSOLETE 	  high = low + 5;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* Two arguments.  */
// OBSOLETE 	  *space_index = '\0';
// OBSOLETE 	  low = parse_and_eval_address (arg);
// OBSOLETE 	  high = parse_and_eval_address (space_index + 1);
// OBSOLETE 	  if (high < low)
// OBSOLETE 	    high = low;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   printf_filtered ("Dump of trace from %s to %s:\n", 
// OBSOLETE 		   paddr_u (low), paddr_u (high));
// OBSOLETE 
// OBSOLETE   display_trace (low, high);
// OBSOLETE 
// OBSOLETE   printf_filtered ("End of trace dump.\n");
// OBSOLETE   gdb_flush (gdb_stdout);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE display_trace (int low, int high)
// OBSOLETE {
// OBSOLETE   int i, count, trace_show_source, first, suppress;
// OBSOLETE   CORE_ADDR next_address;
// OBSOLETE 
// OBSOLETE   trace_show_source = default_trace_show_source;
// OBSOLETE   if (!have_full_symbols () && !have_partial_symbols ())
// OBSOLETE     {
// OBSOLETE       trace_show_source = 0;
// OBSOLETE       printf_filtered ("No symbol table is loaded.  Use the \"file\" command.\n");
// OBSOLETE       printf_filtered ("Trace will not display any source.\n");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   first = 1;
// OBSOLETE   suppress = 0;
// OBSOLETE   for (i = low; i < high; ++i)
// OBSOLETE     {
// OBSOLETE       next_address = trace_data.addrs[i];
// OBSOLETE       count = trace_data.counts[i];
// OBSOLETE       while (count-- > 0)
// OBSOLETE 	{
// OBSOLETE 	  QUIT;
// OBSOLETE 	  if (trace_show_source)
// OBSOLETE 	    {
// OBSOLETE 	      struct symtab_and_line sal, sal_prev;
// OBSOLETE 
// OBSOLETE 	      sal_prev = find_pc_line (next_address - 4, 0);
// OBSOLETE 	      sal = find_pc_line (next_address, 0);
// OBSOLETE 
// OBSOLETE 	      if (sal.symtab)
// OBSOLETE 		{
// OBSOLETE 		  if (first || sal.line != sal_prev.line)
// OBSOLETE 		    print_source_lines (sal.symtab, sal.line, sal.line + 1, 0);
// OBSOLETE 		  suppress = 0;
// OBSOLETE 		}
// OBSOLETE 	      else
// OBSOLETE 		{
// OBSOLETE 		  if (!suppress)
// OBSOLETE 		    /* FIXME-32x64--assumes sal.pc fits in long.  */
// OBSOLETE 		    printf_filtered ("No source file for address %s.\n",
// OBSOLETE 				     hex_string ((unsigned long) sal.pc));
// OBSOLETE 		  suppress = 1;
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	  first = 0;
// OBSOLETE 	  print_address (next_address, gdb_stdout);
// OBSOLETE 	  printf_filtered (":");
// OBSOLETE 	  printf_filtered ("\t");
// OBSOLETE 	  wrap_here ("    ");
// OBSOLETE 	  next_address += gdb_print_insn (next_address, gdb_stdout);
// OBSOLETE 	  printf_filtered ("\n");
// OBSOLETE 	  gdb_flush (gdb_stdout);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE d10v_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
// OBSOLETE {
// OBSOLETE   ULONGEST pc;
// OBSOLETE   frame_unwind_unsigned_register (next_frame, D10V_PC_REGNUM, &pc);
// OBSOLETE   return d10v_make_iaddr (pc);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Given a GDB frame, determine the address of the calling function's
// OBSOLETE    frame.  This will be used to create a new GDB frame struct.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE d10v_frame_this_id (struct frame_info *next_frame,
// OBSOLETE 		    void **this_prologue_cache,
// OBSOLETE 		    struct frame_id *this_id)
// OBSOLETE {
// OBSOLETE   struct d10v_unwind_cache *info
// OBSOLETE     = d10v_frame_unwind_cache (next_frame, this_prologue_cache);
// OBSOLETE   CORE_ADDR base;
// OBSOLETE   CORE_ADDR func;
// OBSOLETE   struct frame_id id;
// OBSOLETE 
// OBSOLETE   /* The FUNC is easy.  */
// OBSOLETE   func = frame_func_unwind (next_frame);
// OBSOLETE 
// OBSOLETE   /* Hopefully the prologue analysis either correctly determined the
// OBSOLETE      frame's base (which is the SP from the previous frame), or set
// OBSOLETE      that base to "NULL".  */
// OBSOLETE   base = info->prev_sp;
// OBSOLETE   if (base == STACK_START || base == 0)
// OBSOLETE     return;
// OBSOLETE 
// OBSOLETE   id = frame_id_build (base, func);
// OBSOLETE 
// OBSOLETE   (*this_id) = id;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE d10v_frame_prev_register (struct frame_info *next_frame,
// OBSOLETE 			  void **this_prologue_cache,
// OBSOLETE 			  int regnum, int *optimizedp,
// OBSOLETE 			  enum lval_type *lvalp, CORE_ADDR *addrp,
// OBSOLETE 			  int *realnump, void *bufferp)
// OBSOLETE {
// OBSOLETE   struct d10v_unwind_cache *info
// OBSOLETE     = d10v_frame_unwind_cache (next_frame, this_prologue_cache);
// OBSOLETE   trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
// OBSOLETE 				optimizedp, lvalp, addrp, realnump, bufferp);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static const struct frame_unwind d10v_frame_unwind = {
// OBSOLETE   NORMAL_FRAME,
// OBSOLETE   d10v_frame_this_id,
// OBSOLETE   d10v_frame_prev_register
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static const struct frame_unwind *
// OBSOLETE d10v_frame_sniffer (struct frame_info *next_frame)
// OBSOLETE {
// OBSOLETE   return &d10v_frame_unwind;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE d10v_frame_base_address (struct frame_info *next_frame, void **this_cache)
// OBSOLETE {
// OBSOLETE   struct d10v_unwind_cache *info
// OBSOLETE     = d10v_frame_unwind_cache (next_frame, this_cache);
// OBSOLETE   return info->base;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static const struct frame_base d10v_frame_base = {
// OBSOLETE   &d10v_frame_unwind,
// OBSOLETE   d10v_frame_base_address,
// OBSOLETE   d10v_frame_base_address,
// OBSOLETE   d10v_frame_base_address
// OBSOLETE };
// OBSOLETE 
// OBSOLETE /* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
// OBSOLETE    dummy frame.  The frame ID's base needs to match the TOS value
// OBSOLETE    saved by save_dummy_frame_tos(), and the PC match the dummy frame's
// OBSOLETE    breakpoint.  */
// OBSOLETE 
// OBSOLETE static struct frame_id
// OBSOLETE d10v_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
// OBSOLETE {
// OBSOLETE   return frame_id_build (d10v_unwind_sp (gdbarch, next_frame),
// OBSOLETE 			 frame_pc_unwind (next_frame));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static gdbarch_init_ftype d10v_gdbarch_init;
// OBSOLETE 
// OBSOLETE static struct gdbarch *
// OBSOLETE d10v_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
// OBSOLETE {
// OBSOLETE   struct gdbarch *gdbarch;
// OBSOLETE   int d10v_num_regs;
// OBSOLETE   struct gdbarch_tdep *tdep;
// OBSOLETE   gdbarch_register_name_ftype *d10v_register_name;
// OBSOLETE   gdbarch_register_sim_regno_ftype *d10v_register_sim_regno;
// OBSOLETE 
// OBSOLETE   /* Find a candidate among the list of pre-declared architectures.  */
// OBSOLETE   arches = gdbarch_list_lookup_by_info (arches, &info);
// OBSOLETE   if (arches != NULL)
// OBSOLETE     return arches->gdbarch;
// OBSOLETE 
// OBSOLETE   /* None found, create a new architecture from the information
// OBSOLETE      provided.  */
// OBSOLETE   tdep = XMALLOC (struct gdbarch_tdep);
// OBSOLETE   gdbarch = gdbarch_alloc (&info, tdep);
// OBSOLETE 
// OBSOLETE   switch (info.bfd_arch_info->mach)
// OBSOLETE     {
// OBSOLETE     case bfd_mach_d10v_ts2:
// OBSOLETE       d10v_num_regs = 37;
// OBSOLETE       d10v_register_name = d10v_ts2_register_name;
// OBSOLETE       d10v_register_sim_regno = d10v_ts2_register_sim_regno;
// OBSOLETE       tdep->a0_regnum = TS2_A0_REGNUM;
// OBSOLETE       tdep->nr_dmap_regs = TS2_NR_DMAP_REGS;
// OBSOLETE       tdep->dmap_register = d10v_ts2_dmap_register;
// OBSOLETE       tdep->imap_register = d10v_ts2_imap_register;
// OBSOLETE       break;
// OBSOLETE     default:
// OBSOLETE     case bfd_mach_d10v_ts3:
// OBSOLETE       d10v_num_regs = 42;
// OBSOLETE       d10v_register_name = d10v_ts3_register_name;
// OBSOLETE       d10v_register_sim_regno = d10v_ts3_register_sim_regno;
// OBSOLETE       tdep->a0_regnum = TS3_A0_REGNUM;
// OBSOLETE       tdep->nr_dmap_regs = TS3_NR_DMAP_REGS;
// OBSOLETE       tdep->dmap_register = d10v_ts3_dmap_register;
// OBSOLETE       tdep->imap_register = d10v_ts3_imap_register;
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   set_gdbarch_read_pc (gdbarch, d10v_read_pc);
// OBSOLETE   set_gdbarch_write_pc (gdbarch, d10v_write_pc);
// OBSOLETE   set_gdbarch_unwind_sp (gdbarch, d10v_unwind_sp);
// OBSOLETE 
// OBSOLETE   set_gdbarch_num_regs (gdbarch, d10v_num_regs);
// OBSOLETE   set_gdbarch_sp_regnum (gdbarch, D10V_SP_REGNUM);
// OBSOLETE   set_gdbarch_register_name (gdbarch, d10v_register_name);
// OBSOLETE   set_gdbarch_register_type (gdbarch, d10v_register_type);
// OBSOLETE 
// OBSOLETE   set_gdbarch_ptr_bit (gdbarch, 2 * TARGET_CHAR_BIT);
// OBSOLETE   set_gdbarch_addr_bit (gdbarch, 32);
// OBSOLETE   set_gdbarch_address_to_pointer (gdbarch, d10v_address_to_pointer);
// OBSOLETE   set_gdbarch_pointer_to_address (gdbarch, d10v_pointer_to_address);
// OBSOLETE   set_gdbarch_integer_to_address (gdbarch, d10v_integer_to_address);
// OBSOLETE   set_gdbarch_short_bit (gdbarch, 2 * TARGET_CHAR_BIT);
// OBSOLETE   set_gdbarch_int_bit (gdbarch, 2 * TARGET_CHAR_BIT);
// OBSOLETE   set_gdbarch_long_bit (gdbarch, 4 * TARGET_CHAR_BIT);
// OBSOLETE   set_gdbarch_long_long_bit (gdbarch, 8 * TARGET_CHAR_BIT);
// OBSOLETE   /* NOTE: The d10v as a 32 bit ``float'' and ``double''. ``long
// OBSOLETE      double'' is 64 bits.  */
// OBSOLETE   set_gdbarch_float_bit (gdbarch, 4 * TARGET_CHAR_BIT);
// OBSOLETE   set_gdbarch_double_bit (gdbarch, 4 * TARGET_CHAR_BIT);
// OBSOLETE   set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
// OBSOLETE   switch (info.byte_order)
// OBSOLETE     {
// OBSOLETE     case BFD_ENDIAN_BIG:
// OBSOLETE       set_gdbarch_float_format (gdbarch, &floatformat_ieee_single_big);
// OBSOLETE       set_gdbarch_double_format (gdbarch, &floatformat_ieee_single_big);
// OBSOLETE       set_gdbarch_long_double_format (gdbarch, &floatformat_ieee_double_big);
// OBSOLETE       break;
// OBSOLETE     case BFD_ENDIAN_LITTLE:
// OBSOLETE       set_gdbarch_float_format (gdbarch, &floatformat_ieee_single_little);
// OBSOLETE       set_gdbarch_double_format (gdbarch, &floatformat_ieee_single_little);
// OBSOLETE       set_gdbarch_long_double_format (gdbarch, 
// OBSOLETE 				      &floatformat_ieee_double_little);
// OBSOLETE       break;
// OBSOLETE     default:
// OBSOLETE       internal_error (__FILE__, __LINE__,
// OBSOLETE 		      "d10v_gdbarch_init: bad byte order for float format");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   set_gdbarch_return_value (gdbarch, d10v_return_value);
// OBSOLETE   set_gdbarch_push_dummy_code (gdbarch, d10v_push_dummy_code);
// OBSOLETE   set_gdbarch_push_dummy_call (gdbarch, d10v_push_dummy_call);
// OBSOLETE 
// OBSOLETE   set_gdbarch_skip_prologue (gdbarch, d10v_skip_prologue);
// OBSOLETE   set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
// OBSOLETE   set_gdbarch_decr_pc_after_break (gdbarch, 4);
// OBSOLETE   set_gdbarch_breakpoint_from_pc (gdbarch, d10v_breakpoint_from_pc);
// OBSOLETE 
// OBSOLETE   set_gdbarch_remote_translate_xfer_address (gdbarch, 
// OBSOLETE 					     remote_d10v_translate_xfer_address);
// OBSOLETE 
// OBSOLETE   set_gdbarch_frame_align (gdbarch, d10v_frame_align);
// OBSOLETE 
// OBSOLETE   set_gdbarch_register_sim_regno (gdbarch, d10v_register_sim_regno);
// OBSOLETE 
// OBSOLETE   set_gdbarch_print_registers_info (gdbarch, d10v_print_registers_info);
// OBSOLETE 
// OBSOLETE   frame_unwind_append_sniffer (gdbarch, d10v_frame_sniffer);
// OBSOLETE   frame_base_set_default (gdbarch, &d10v_frame_base);
// OBSOLETE 
// OBSOLETE   /* Methods for saving / extracting a dummy frame's ID.  The ID's
// OBSOLETE      stack address must match the SP value returned by
// OBSOLETE      PUSH_DUMMY_CALL, and saved by generic_save_dummy_frame_tos.  */
// OBSOLETE   set_gdbarch_unwind_dummy_id (gdbarch, d10v_unwind_dummy_id);
// OBSOLETE 
// OBSOLETE   /* Return the unwound PC value.  */
// OBSOLETE   set_gdbarch_unwind_pc (gdbarch, d10v_unwind_pc);
// OBSOLETE 
// OBSOLETE   set_gdbarch_print_insn (gdbarch, print_insn_d10v);
// OBSOLETE 
// OBSOLETE   return gdbarch;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_d10v_tdep (void)
// OBSOLETE {
// OBSOLETE   register_gdbarch_init (bfd_arch_d10v, d10v_gdbarch_init);
// OBSOLETE 
// OBSOLETE   deprecated_target_resume_hook = d10v_eva_prepare_to_trace;
// OBSOLETE   deprecated_target_wait_loop_hook = d10v_eva_get_trace_data;
// OBSOLETE 
// OBSOLETE   deprecate_cmd (add_com ("regs", class_vars, show_regs, 
// OBSOLETE 			  "Print all registers"),
// OBSOLETE 		 "info registers");
// OBSOLETE 
// OBSOLETE   add_com ("itrace", class_support, trace_command,
// OBSOLETE 	   "Enable tracing of instruction execution.");
// OBSOLETE 
// OBSOLETE   add_com ("iuntrace", class_support, untrace_command,
// OBSOLETE 	   "Disable tracing of instruction execution.");
// OBSOLETE 
// OBSOLETE   add_com ("itdisassemble", class_vars, tdisassemble_command,
// OBSOLETE 	   "Disassemble the trace buffer.\n\
// OBSOLETE Two optional arguments specify a range of trace buffer entries\n\
// OBSOLETE as reported by info trace (NOT addresses!).");
// OBSOLETE 
// OBSOLETE   add_info ("itrace", trace_info,
// OBSOLETE 	    "Display info about the trace data buffer.");
// OBSOLETE 
// OBSOLETE   add_setshow_boolean_cmd ("itracedisplay", no_class, &trace_display, "\
// OBSOLETE Set automatic display of trace.", "\
// OBSOLETE Show automatic display of trace.", "\
// OBSOLETE Controls the display of d10v specific instruction trace information.", "\
// OBSOLETE Automatic display of trace is %s.",
// OBSOLETE 			   NULL, NULL, &setlist, &showlist);
// OBSOLETE   add_setshow_boolean_cmd ("itracesource", no_class,
// OBSOLETE 			   &default_trace_show_source, "\
// OBSOLETE Set display of source code with trace.", "\
// OBSOLETE Show display of source code with trace.", "\
// OBSOLETE When on source code is included in the d10v instruction trace display.", "\
// OBSOLETE Display of source code with trace is %s.",
// OBSOLETE 			   NULL, NULL, &setlist, &showlist);
// OBSOLETE }
@


1.151
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@@


1.150
log
@2004-11-01  Andrew Cagney  <cagney@@gnu.org>

	* configure.tgt: Mark d10v-*-* as obsolete.
	* config/d10v/d10v.mt, d10v-tdep.c: Obsolete files.
@
text
@d3 1
a3 1
// OBSOLETE    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
d20 2
a21 2
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
@


1.149
log
@* language.c (local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string, use C format, and move to
utils.c
(local_hex_string_custom): Rename to hex_string_custom and change
interface.  Now uses C format.  Move to utils.c
(local_octal_format_custom): Remove.
(local_decimal_format_custom): Remove.
(unknown_language_defn): Remove language-specific number
formatting entries.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* language.h (struct language_format_info): Delete declaration.
(struct language_defn): Remove language_format_info fields
la_binary_format, la_octal_format, la_decimal_format, la_hex_format.
(local_binary_format): Remove macro.
(local_binary_format_prefix): Remove macro.
(local_binary_format_specifier): Remove macro.
(local_binary_format_suffix): Remove macro.
(local_octal_format): Remove macro.
(local_octal_format_prefix): Remove macro.
(local_octal_format_specifier): Remove macro.
(local_octal_format_suffix): Remove macro.
(local_decimal_format): Remove macro.
(local_decimal_format_prefix): Remove macro.
(local_decimal_format_specifier): Remove macro.
(local_decimal_format_suffix): Remove macro.
(local_hex_format): Remove macro.
(local_hex_format_prefix): Remove macro.
(local_hex_format_specifier): Remove macro.
(local_hex_format_suffix): Remove macro.
(local_decimal_format_custom): Remove.
(local_octal_format_custom): Remove.
(local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string and move to defs.h.
(local_hex_string_custom): Rename to hex_string_custom, change
interface, and move to defs.h.
* utils.c: (int_string): New function.
(hex_string): New function (from language.c).
(hex_string_custom): New function (from language.c).
(octal2str): New function.
(decimal2str): Add width parameter.
(paddr_u): Use new decimal2str interface.
(paddr_d): Ditto.
* defs.h (hex_string): Declare.
(hex_string_custom): Declare.
(int_string): Declare.
* printcmd.c (print_scalar_formatted): Remove localized binary
formatting.
* valprint.c (print_longest): Use int_string.
(print_floating): Use C hex format.
(print_hex_chars): Ditto.
(print_binary_chars): Remove language-specific formatting.
(print_octal_chars): Use C octal format.
(print_decimal_chars): Delocalize format.
(print_decimal): Remove.
* ada-lang.c (ada_language_defn): Remove language-specific number
formatting entries.
* p-lang.c (pascal_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.
* memattr.c (mem_info_command): Use renamed hex_string_custom with
new interface.
* pa64solib.c (pa64_sharedlibrary_info_command): Ditto.
* ui-out.c (ui_out_field_core_addr): Ditto.
* breakpoint.c (breakpoint_adjustment_warning): Ditto.
* exec.c (print_section_info): Ditto.
* i387-tdep.c (print_i387_status_word): Ditto.
(print_i387_control_word): Ditto.
(i387_print_float_info): Ditto.
* maint.c (maint_print_section_info): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* somsolib.c (som_sharedlibrary_info_command): Ditto.
* symtab.c (print_msymbol_info): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* solib-frv.c (lm_base): Ditto.
(frv_current_sos): Ditto.
(enable_break2): Ditto.
(enable_break): Ditto.
* dbxread.c (read_dbx_symtab): Use renamed hex_string.
(process_one_symbol): Ditto.
* infcmd.c (program_info): Ditto.
* mdebugread.c (parse_partial_symbols): Ditto.
* symfile.c (add_symbol_file_command): Ditto.
* cli/cli-cmds.c (edit_command): Ditto.
(list_command): Ditto.
* infcall.c (call_function_by_hand): Ditto.
* remote-vx.c (vx_run_files_info): Ditto.
(vx_wait): Ditto.
(vx_attach): Ditto.
(vx_detach): Ditto.
(vx_kill): Ditto.
* aix-thread.c (pdc_symbol_addrs): Ditto.
(pdc_read_regs): Ditto.
(pdc_write_regs): Ditto.
(pdc_read_data): Ditto.
(pdc_write_data): Ditto.
* d10v-tdep.c (display_trace): Ditto.
* rs6000-nat.c (find_toc_address): Ditto.
* aix-thread.c: Don't include language.h.
* buildsym.c: Ditto.
* dbxread.c: Ditto.
* mdebugread.c: Ditto.
* rs6000-nat.c: Ditto.
* buildsym.c (make_blockvector): Use renamed hex_string.
@
text
@d1 1579
a1579 1579
/* Target-dependent code for Renesas D10V, for GDB.

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
   Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/*  Contributed by Martin Hunt, hunt@@cygnus.com */

#include "defs.h"
#include "frame.h"
#include "frame-unwind.h"
#include "frame-base.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "gdb_string.h"
#include "value.h"
#include "inferior.h"
#include "dis-asm.h"
#include "symfile.h"
#include "objfiles.h"
#include "language.h"
#include "arch-utils.h"
#include "regcache.h"
#include "remote.h"
#include "floatformat.h"
#include "gdb/sim-d10v.h"
#include "sim-regno.h"
#include "disasm.h"
#include "trad-frame.h"

#include "gdb_assert.h"

struct gdbarch_tdep
  {
    int a0_regnum;
    int nr_dmap_regs;
    unsigned long (*dmap_register) (void *regcache, int nr);
    unsigned long (*imap_register) (void *regcache, int nr);
  };

/* These are the addresses the D10V-EVA board maps data and
   instruction memory to.  */

enum memspace {
  DMEM_START  = 0x2000000,
  IMEM_START  = 0x1000000,
  STACK_START = 0x200bffe
};

/* d10v register names.  */

enum
  {
    R0_REGNUM = 0,
    R3_REGNUM = 3,
    D10V_FP_REGNUM = 11,
    LR_REGNUM = 13,
    D10V_SP_REGNUM = 15,
    PSW_REGNUM = 16,
    D10V_PC_REGNUM = 18,
    NR_IMAP_REGS = 2,
    NR_A_REGS = 2,
    TS2_NUM_REGS = 37,
    TS3_NUM_REGS = 42,
    /* d10v calling convention.  */
    ARG1_REGNUM = R0_REGNUM,
    ARGN_REGNUM = R3_REGNUM
  };

static int
nr_dmap_regs (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->nr_dmap_regs;
}

static int
a0_regnum (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->a0_regnum;
}

/* Local functions */

extern void _initialize_d10v_tdep (void);

static void d10v_eva_prepare_to_trace (void);

static void d10v_eva_get_trace_data (void);

static CORE_ADDR
d10v_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  /* Align to the size of an instruction (so that they can safely be
     pushed onto the stack.  */
  return sp & ~3;
}

static const unsigned char *
d10v_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
{
  static unsigned char breakpoint[] =
  {0x2f, 0x90, 0x5e, 0x00};
  *lenptr = sizeof (breakpoint);
  return breakpoint;
}

/* Map the REG_NR onto an ascii name.  Return NULL or an empty string
   when the reg_nr isn't valid.  */

enum ts2_regnums
  {
    TS2_IMAP0_REGNUM = 32,
    TS2_DMAP_REGNUM = 34,
    TS2_NR_DMAP_REGS = 1,
    TS2_A0_REGNUM = 35
  };

static const char *
d10v_ts2_register_name (int reg_nr)
{
  static char *register_names[] =
  {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "psw", "bpsw", "pc", "bpc", "cr4", "cr5", "cr6", "rpt_c",
    "rpt_s", "rpt_e", "mod_s", "mod_e", "cr12", "cr13", "iba", "cr15",
    "imap0", "imap1", "dmap", "a0", "a1"
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

enum ts3_regnums
  {
    TS3_IMAP0_REGNUM = 36,
    TS3_DMAP0_REGNUM = 38,
    TS3_NR_DMAP_REGS = 4,
    TS3_A0_REGNUM = 32
  };

static const char *
d10v_ts3_register_name (int reg_nr)
{
  static char *register_names[] =
  {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "psw", "bpsw", "pc", "bpc", "cr4", "cr5", "cr6", "rpt_c",
    "rpt_s", "rpt_e", "mod_s", "mod_e", "cr12", "cr13", "iba", "cr15",
    "a0", "a1",
    "spi", "spu",
    "imap0", "imap1",
    "dmap0", "dmap1", "dmap2", "dmap3"
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

/* Access the DMAP/IMAP registers in a target independent way.

   Divide the D10V's 64k data space into four 16k segments:
   0x0000 -- 0x3fff, 0x4000 -- 0x7fff, 0x8000 -- 0xbfff, and 
   0xc000 -- 0xffff.

   On the TS2, the first two segments (0x0000 -- 0x3fff, 0x4000 --
   0x7fff) always map to the on-chip data RAM, and the fourth always
   maps to I/O space.  The third (0x8000 - 0xbfff) can be mapped into
   unified memory or instruction memory, under the control of the
   single DMAP register.

   On the TS3, there are four DMAP registers, each of which controls
   one of the segments.  */

static unsigned long
d10v_ts2_dmap_register (void *regcache, int reg_nr)
{
  switch (reg_nr)
    {
    case 0:
    case 1:
      return 0x2000;
    case 2:
      {
	ULONGEST reg;
	regcache_cooked_read_unsigned (regcache, TS2_DMAP_REGNUM, &reg);
	return reg;
      }
    default:
      return 0;
    }
}

static unsigned long
d10v_ts3_dmap_register (void *regcache, int reg_nr)
{
  ULONGEST reg;
  regcache_cooked_read_unsigned (regcache, TS3_DMAP0_REGNUM + reg_nr, &reg);
  return reg;
}

static unsigned long
d10v_ts2_imap_register (void *regcache, int reg_nr)
{
  ULONGEST reg;
  regcache_cooked_read_unsigned (regcache, TS2_IMAP0_REGNUM + reg_nr, &reg);
  return reg;
}

static unsigned long
d10v_ts3_imap_register (void *regcache, int reg_nr)
{
  ULONGEST reg;
  regcache_cooked_read_unsigned (regcache, TS3_IMAP0_REGNUM + reg_nr, &reg);
  return reg;
}

/* MAP GDB's internal register numbering (determined by the layout
   from the DEPRECATED_REGISTER_BYTE array) onto the simulator's
   register numbering.  */

static int
d10v_ts2_register_sim_regno (int nr)
{
  /* Only makes sense to supply raw registers.  */
  gdb_assert (nr >= 0 && nr < NUM_REGS);
  if (nr >= TS2_IMAP0_REGNUM
      && nr < TS2_IMAP0_REGNUM + NR_IMAP_REGS)
    return nr - TS2_IMAP0_REGNUM + SIM_D10V_IMAP0_REGNUM;
  if (nr == TS2_DMAP_REGNUM)
    return nr - TS2_DMAP_REGNUM + SIM_D10V_TS2_DMAP_REGNUM;
  if (nr >= TS2_A0_REGNUM
      && nr < TS2_A0_REGNUM + NR_A_REGS)
    return nr - TS2_A0_REGNUM + SIM_D10V_A0_REGNUM;
  return nr;
}

static int
d10v_ts3_register_sim_regno (int nr)
{
  /* Only makes sense to supply raw registers.  */
  gdb_assert (nr >= 0 && nr < NUM_REGS);
  if (nr >= TS3_IMAP0_REGNUM
      && nr < TS3_IMAP0_REGNUM + NR_IMAP_REGS)
    return nr - TS3_IMAP0_REGNUM + SIM_D10V_IMAP0_REGNUM;
  if (nr >= TS3_DMAP0_REGNUM
      && nr < TS3_DMAP0_REGNUM + TS3_NR_DMAP_REGS)
    return nr - TS3_DMAP0_REGNUM + SIM_D10V_DMAP0_REGNUM;
  if (nr >= TS3_A0_REGNUM
      && nr < TS3_A0_REGNUM + NR_A_REGS)
    return nr - TS3_A0_REGNUM + SIM_D10V_A0_REGNUM;
  return nr;
}

/* Return the GDB type object for the "standard" data type
   of data in register N.  */

static struct type *
d10v_register_type (struct gdbarch *gdbarch, int reg_nr)
{
  if (reg_nr == D10V_PC_REGNUM)
    return builtin_type (gdbarch)->builtin_func_ptr;
  if (reg_nr == D10V_SP_REGNUM || reg_nr == D10V_FP_REGNUM)
    return builtin_type (gdbarch)->builtin_data_ptr;
  else if (reg_nr >= a0_regnum (gdbarch)
	   && reg_nr < (a0_regnum (gdbarch) + NR_A_REGS))
    return builtin_type_int64;
  else
    return builtin_type_int16;
}

static int
d10v_iaddr_p (CORE_ADDR x)
{
  return (((x) & 0x3000000) == IMEM_START);
}

static CORE_ADDR
d10v_make_daddr (CORE_ADDR x)
{
  return ((x) | DMEM_START);
}

static CORE_ADDR
d10v_make_iaddr (CORE_ADDR x)
{
  if (d10v_iaddr_p (x))
    return x;	/* Idempotency -- x is already in the IMEM space.  */
  else
    return (((x) << 2) | IMEM_START);
}

static CORE_ADDR
d10v_convert_iaddr_to_raw (CORE_ADDR x)
{
  return (((x) >> 2) & 0xffff);
}

static CORE_ADDR
d10v_convert_daddr_to_raw (CORE_ADDR x)
{
  return ((x) & 0xffff);
}

static void
d10v_address_to_pointer (struct type *type, void *buf, CORE_ADDR addr)
{
  /* Is it a code address?  */
  if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC
      || TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_METHOD)
    {
      store_unsigned_integer (buf, TYPE_LENGTH (type), 
                              d10v_convert_iaddr_to_raw (addr));
    }
  else
    {
      /* Strip off any upper segment bits.  */
      store_unsigned_integer (buf, TYPE_LENGTH (type), 
                              d10v_convert_daddr_to_raw (addr));
    }
}

static CORE_ADDR
d10v_pointer_to_address (struct type *type, const void *buf)
{
  CORE_ADDR addr = extract_unsigned_integer (buf, TYPE_LENGTH (type));
  /* Is it a code address?  */
  if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC
      || TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_METHOD
      || TYPE_CODE_SPACE (TYPE_TARGET_TYPE (type)))
    return d10v_make_iaddr (addr);
  else
    return d10v_make_daddr (addr);
}

/* Don't do anything if we have an integer, this way users can type 'x
   <addr>' w/o having gdb outsmart them.  The internal gdb conversions
   to the correct space are taken care of in the pointer_to_address
   function.  If we don't do this, 'x $fp' wouldn't work.  */
static CORE_ADDR
d10v_integer_to_address (struct type *type, void *buf)
{
  LONGEST val;
  val = unpack_long (type, buf);
  return val;
}

/* Handle the d10v's return_value convention.  */

static enum return_value_convention
d10v_return_value (struct gdbarch *gdbarch, struct type *valtype,
		   struct regcache *regcache, void *readbuf,
		   const void *writebuf)
{
  if (TYPE_LENGTH (valtype) > 8)
    /* Anything larger than 8 bytes (4 registers) goes on the stack.  */
    return RETURN_VALUE_STRUCT_CONVENTION;
  if (TYPE_LENGTH (valtype) == 5
      || TYPE_LENGTH (valtype) == 6)
    /* Anything 5 or 6 bytes in size goes in memory.  Contents don't
       appear to matter.  Note that 7 and 8 byte objects do end up in
       registers!  */
    return RETURN_VALUE_STRUCT_CONVENTION;
  if (TYPE_LENGTH (valtype) == 1)
    {
      /* All single byte values go in a register stored right-aligned.
         Note: 2 byte integer values are handled further down.  */
      if (readbuf)
	{
	  /* Since TYPE is smaller than the register, there isn't a
             sign extension problem.  Let the extraction truncate the
             register value.  */
	  ULONGEST regval;
	  regcache_cooked_read_unsigned (regcache, R0_REGNUM,
					 &regval);
	  store_unsigned_integer (readbuf, TYPE_LENGTH (valtype), regval);

	}
      if (writebuf)
	{
	  ULONGEST regval;
	  if (TYPE_CODE (valtype) == TYPE_CODE_INT)
	    /* Some sort of integer value stored in R0.  Use
	       unpack_long since that should handle any required sign
	       extension.  */
	    regval = unpack_long (valtype, writebuf);
	  else
	    /* Some other type.  Don't sign-extend the value when
               storing it in the register.  */
	    regval = extract_unsigned_integer (writebuf, 1);
	  regcache_cooked_write_unsigned (regcache, R0_REGNUM, regval);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if ((TYPE_CODE (valtype) == TYPE_CODE_STRUCT
       || TYPE_CODE (valtype) == TYPE_CODE_UNION)
      && TYPE_NFIELDS (valtype) > 1
      && TYPE_FIELD_BITPOS (valtype, 1) == 8)
    /* If a composite is 8 bit aligned (determined by looking at the
       start address of the second field), put it in memory.  */
    return RETURN_VALUE_STRUCT_CONVENTION;
  /* Assume it is in registers.  */
  if (writebuf || readbuf)
    {
      int reg;
      /* Per above, the value is never more than 8 bytes long.  */
      gdb_assert (TYPE_LENGTH (valtype) <= 8);
      /* Xfer 2 bytes at a time.  */
      for (reg = 0; (reg * 2) + 1 < TYPE_LENGTH (valtype); reg++)
	{
	  if (readbuf)
	    regcache_cooked_read (regcache, R0_REGNUM + reg,
				  (bfd_byte *) readbuf + reg * 2);
	  if (writebuf)
	    regcache_cooked_write (regcache, R0_REGNUM + reg,
				   (bfd_byte *) writebuf + reg * 2);
	}
      /* Any trailing byte ends up _left_ aligned.  */
      if ((reg * 2) < TYPE_LENGTH (valtype))
	{
	  if (readbuf)
	    regcache_cooked_read_part (regcache, R0_REGNUM + reg,
				       0, 1, (bfd_byte *) readbuf + reg * 2);
	  if (writebuf)
	    regcache_cooked_write_part (regcache, R0_REGNUM + reg,
					0, 1, (bfd_byte *) writebuf + reg * 2);
	}
    }
  return RETURN_VALUE_REGISTER_CONVENTION;
}

static int
check_prologue (unsigned short op)
{
  /* st  rn, @@-sp */
  if ((op & 0x7E1F) == 0x6C1F)
    return 1;

  /* st2w  rn, @@-sp */
  if ((op & 0x7E3F) == 0x6E1F)
    return 1;

  /* subi  sp, n */
  if ((op & 0x7FE1) == 0x01E1)
    return 1;

  /* mv  r11, sp */
  if (op == 0x417E)
    return 1;

  /* nop */
  if (op == 0x5E00)
    return 1;

  /* st  rn, @@sp */
  if ((op & 0x7E1F) == 0x681E)
    return 1;

  /* st2w  rn, @@sp */
  if ((op & 0x7E3F) == 0x3A1E)
    return 1;

  return 0;
}

static CORE_ADDR
d10v_skip_prologue (CORE_ADDR pc)
{
  unsigned long op;
  unsigned short op1, op2;
  CORE_ADDR func_addr, func_end;
  struct symtab_and_line sal;

  /* If we have line debugging information, then the end of the prologue 
     should be the first assembly instruction of the first source line.  */
  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    {
      sal = find_pc_line (func_addr, 0);
      if (sal.end && sal.end < func_end)
	return sal.end;
    }

  if (target_read_memory (pc, (char *) &op, 4))
    return pc;			/* Can't access it -- assume no prologue.  */

  while (1)
    {
      op = (unsigned long) read_memory_integer (pc, 4);
      if ((op & 0xC0000000) == 0xC0000000)
	{
	  /* long instruction */
	  if (((op & 0x3FFF0000) != 0x01FF0000) &&	/* add3 sp,sp,n */
	      ((op & 0x3F0F0000) != 0x340F0000) &&	/* st  rn, @@(offset,sp) */
	      ((op & 0x3F1F0000) != 0x350F0000))	/* st2w  rn, @@(offset,sp) */
	    break;
	}
      else
	{
	  /* short instructions */
	  if ((op & 0xC0000000) == 0x80000000)
	    {
	      op2 = (op & 0x3FFF8000) >> 15;
	      op1 = op & 0x7FFF;
	    }
	  else
	    {
	      op1 = (op & 0x3FFF8000) >> 15;
	      op2 = op & 0x7FFF;
	    }
	  if (check_prologue (op1))
	    {
	      if (!check_prologue (op2))
		{
		  /* If the previous opcode was really part of the
		     prologue and not just a NOP, then we want to
		     break after both instructions.  */
		  if (op1 != 0x5E00)
		    pc += 4;
		  break;
		}
	    }
	  else
	    break;
	}
      pc += 4;
    }
  return pc;
}

struct d10v_unwind_cache
{
  /* The previous frame's inner most stack address.  Used as this
     frame ID's stack_addr.  */
  CORE_ADDR prev_sp;
  /* The frame's base, optionally used by the high-level debug info.  */
  CORE_ADDR base;
  int size;
  /* How far the SP and r11 (FP) have been offset from the start of
     the stack frame (as defined by the previous frame's stack
     pointer).  */
  LONGEST sp_offset;
  LONGEST r11_offset;
  int uses_frame;
  /* Table indicating the location of each and every register.  */
  struct trad_frame_saved_reg *saved_regs;
};

static int
prologue_find_regs (struct d10v_unwind_cache *info, unsigned short op,
		    CORE_ADDR addr)
{
  int n;

  /* st  rn, @@-sp */
  if ((op & 0x7E1F) == 0x6C1F)
    {
      n = (op & 0x1E0) >> 5;
      info->sp_offset -= 2;
      info->saved_regs[n].addr = info->sp_offset;
      return 1;
    }

  /* st2w  rn, @@-sp */
  else if ((op & 0x7E3F) == 0x6E1F)
    {
      n = (op & 0x1E0) >> 5;
      info->sp_offset -= 4;
      info->saved_regs[n + 0].addr = info->sp_offset + 0;
      info->saved_regs[n + 1].addr = info->sp_offset + 2;
      return 1;
    }

  /* subi  sp, n */
  if ((op & 0x7FE1) == 0x01E1)
    {
      n = (op & 0x1E) >> 1;
      if (n == 0)
	n = 16;
      info->sp_offset -= n;
      return 1;
    }

  /* mv  r11, sp */
  if (op == 0x417E)
    {
      info->uses_frame = 1;
      info->r11_offset = info->sp_offset;
      return 1;
    }

  /* st  rn, @@r11 */
  if ((op & 0x7E1F) == 0x6816)
    {
      n = (op & 0x1E0) >> 5;
      info->saved_regs[n].addr = info->r11_offset;
      return 1;
    }

  /* nop */
  if (op == 0x5E00)
    return 1;

  /* st  rn, @@sp */
  if ((op & 0x7E1F) == 0x681E)
    {
      n = (op & 0x1E0) >> 5;
      info->saved_regs[n].addr = info->sp_offset;
      return 1;
    }

  /* st2w  rn, @@sp */
  if ((op & 0x7E3F) == 0x3A1E)
    {
      n = (op & 0x1E0) >> 5;
      info->saved_regs[n + 0].addr = info->sp_offset + 0;
      info->saved_regs[n + 1].addr = info->sp_offset + 2;
      return 1;
    }

  return 0;
}

/* Put here the code to store, into fi->saved_regs, the addresses of
   the saved registers of frame described by FRAME_INFO.  This
   includes special registers such as pc and fp saved in special ways
   in the stack frame.  sp is even more special: the address we return
   for it IS the sp for the next frame.  */

static struct d10v_unwind_cache *
d10v_frame_unwind_cache (struct frame_info *next_frame,
			 void **this_prologue_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  CORE_ADDR pc;
  ULONGEST prev_sp;
  ULONGEST this_base;
  unsigned long op;
  unsigned short op1, op2;
  int i;
  struct d10v_unwind_cache *info;

  if ((*this_prologue_cache))
    return (*this_prologue_cache);

  info = FRAME_OBSTACK_ZALLOC (struct d10v_unwind_cache);
  (*this_prologue_cache) = info;
  info->saved_regs = trad_frame_alloc_saved_regs (next_frame);

  info->size = 0;
  info->sp_offset = 0;

  info->uses_frame = 0;
  for (pc = frame_func_unwind (next_frame);
       pc > 0 && pc < frame_pc_unwind (next_frame);
       pc += 4)
    {
      op = get_frame_memory_unsigned (next_frame, pc, 4);
      if ((op & 0xC0000000) == 0xC0000000)
	{
	  /* long instruction */
	  if ((op & 0x3FFF0000) == 0x01FF0000)
	    {
	      /* add3 sp,sp,n */
	      short n = op & 0xFFFF;
	      info->sp_offset += n;
	    }
	  else if ((op & 0x3F0F0000) == 0x340F0000)
	    {
	      /* st  rn, @@(offset,sp) */
	      short offset = op & 0xFFFF;
	      short n = (op >> 20) & 0xF;
	      info->saved_regs[n].addr = info->sp_offset + offset;
	    }
	  else if ((op & 0x3F1F0000) == 0x350F0000)
	    {
	      /* st2w  rn, @@(offset,sp) */
	      short offset = op & 0xFFFF;
	      short n = (op >> 20) & 0xF;
	      info->saved_regs[n + 0].addr = info->sp_offset + offset + 0;
	      info->saved_regs[n + 1].addr = info->sp_offset + offset + 2;
	    }
	  else
	    break;
	}
      else
	{
	  /* short instructions */
	  if ((op & 0xC0000000) == 0x80000000)
	    {
	      op2 = (op & 0x3FFF8000) >> 15;
	      op1 = op & 0x7FFF;
	    }
	  else
	    {
	      op1 = (op & 0x3FFF8000) >> 15;
	      op2 = op & 0x7FFF;
	    }
	  if (!prologue_find_regs (info, op1, pc) 
	      || !prologue_find_regs (info, op2, pc))
	    break;
	}
    }

  info->size = -info->sp_offset;

  /* Compute the previous frame's stack pointer (which is also the
     frame's ID's stack address), and this frame's base pointer.  */
  if (info->uses_frame)
    {
      /* The SP was moved to the FP.  This indicates that a new frame
         was created.  Get THIS frame's FP value by unwinding it from
         the next frame.  */
      frame_unwind_unsigned_register (next_frame, D10V_FP_REGNUM, &this_base);
      /* The FP points at the last saved register.  Adjust the FP back
         to before the first saved register giving the SP.  */
      prev_sp = this_base + info->size;
    }
  else
    {
      /* Assume that the FP is this frame's SP but with that pushed
         stack space added back.  */
      frame_unwind_unsigned_register (next_frame, D10V_SP_REGNUM, &this_base);
      prev_sp = this_base + info->size;
    }

  /* Convert that SP/BASE into real addresses.  */
  info->prev_sp =  d10v_make_daddr (prev_sp);
  info->base = d10v_make_daddr (this_base);

  /* Adjust all the saved registers so that they contain addresses and
     not offsets.  */
  for (i = 0; i < NUM_REGS - 1; i++)
    if (trad_frame_addr_p (info->saved_regs, i))
      {
	info->saved_regs[i].addr = (info->prev_sp + info->saved_regs[i].addr);
      }

  /* The call instruction moves the caller's PC in the callee's LR.
     Since this is an unwind, do the reverse.  Copy the location of LR
     into PC (the address / regnum) so that a request for PC will be
     converted into a request for the LR.  */
  info->saved_regs[D10V_PC_REGNUM] = info->saved_regs[LR_REGNUM];

  /* The previous frame's SP needed to be computed.  Save the computed
     value.  */
  trad_frame_set_value (info->saved_regs, D10V_SP_REGNUM,
			d10v_make_daddr (prev_sp));

  return info;
}

static void
d10v_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file,
			   struct frame_info *frame, int regnum, int all)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  if (regnum >= 0)
    {
      default_print_registers_info (gdbarch, file, frame, regnum, all);
      return;
    }

  {
    ULONGEST pc, psw, rpt_s, rpt_e, rpt_c;
    pc = get_frame_register_unsigned (frame, D10V_PC_REGNUM);
    psw = get_frame_register_unsigned (frame, PSW_REGNUM);
    rpt_s = get_frame_register_unsigned (frame, frame_map_name_to_regnum (frame, "rpt_s", -1));
    rpt_e = get_frame_register_unsigned (frame, frame_map_name_to_regnum (frame, "rpt_e", -1));
    rpt_c = get_frame_register_unsigned (frame, frame_map_name_to_regnum (frame, "rpt_c", -1));
    fprintf_filtered (file, "PC=%04lx (0x%lx) PSW=%04lx RPT_S=%04lx RPT_E=%04lx RPT_C=%04lx\n",
		     (long) pc, (long) d10v_make_iaddr (pc), (long) psw,
		     (long) rpt_s, (long) rpt_e, (long) rpt_c);
  }

  {
    int group;
    for (group = 0; group < 16; group += 8)
      {
	int r;
	fprintf_filtered (file, "R%d-R%-2d", group, group + 7);
	for (r = group; r < group + 8; r++)
	  {
	    ULONGEST tmp;
	    tmp = get_frame_register_unsigned (frame, r);
	    fprintf_filtered (file, " %04lx", (long) tmp);
	  }
	fprintf_filtered (file, "\n");
      }
  }

  /* Note: The IMAP/DMAP registers don't participate in function
     calls.  Don't bother trying to unwind them.  */

  {
    int a;
    for (a = 0; a < NR_IMAP_REGS; a++)
      {
	if (a > 0)
	  fprintf_filtered (file, "    ");
	fprintf_filtered (file, "IMAP%d %04lx", a,
			  tdep->imap_register (current_regcache, a));
      }
    if (nr_dmap_regs (gdbarch) == 1)
      /* Registers DMAP0 and DMAP1 are constant.  Just return dmap2.  */
      fprintf_filtered (file, "    DMAP %04lx\n",
			tdep->dmap_register (current_regcache, 2));
    else
      {
	for (a = 0; a < nr_dmap_regs (gdbarch); a++)
	  {
	    fprintf_filtered (file, "    DMAP%d %04lx", a,
			      tdep->dmap_register (current_regcache, a));
	  }
	fprintf_filtered (file, "\n");
      }
  }

  {
    char num[MAX_REGISTER_SIZE];
    int a;
    fprintf_filtered (file, "A0-A%d", NR_A_REGS - 1);
    for (a = a0_regnum (gdbarch); a < a0_regnum (gdbarch) + NR_A_REGS; a++)
      {
	int i;
	fprintf_filtered (file, "  ");
	get_frame_register (frame, a, num);
	for (i = 0; i < register_size (gdbarch, a); i++)
	  {
	    fprintf_filtered (file, "%02x", (num[i] & 0xff));
	  }
      }
  }
  fprintf_filtered (file, "\n");
}

static void
show_regs (char *args, int from_tty)
{
  d10v_print_registers_info (current_gdbarch, gdb_stdout,
			     get_current_frame (), -1, 1);
}

static CORE_ADDR
d10v_read_pc (ptid_t ptid)
{
  ptid_t save_ptid;
  CORE_ADDR pc;
  CORE_ADDR retval;

  save_ptid = inferior_ptid;
  inferior_ptid = ptid;
  pc = (int) read_register (D10V_PC_REGNUM);
  inferior_ptid = save_ptid;
  retval = d10v_make_iaddr (pc);
  return retval;
}

static void
d10v_write_pc (CORE_ADDR val, ptid_t ptid)
{
  ptid_t save_ptid;

  save_ptid = inferior_ptid;
  inferior_ptid = ptid;
  write_register (D10V_PC_REGNUM, d10v_convert_iaddr_to_raw (val));
  inferior_ptid = save_ptid;
}

static CORE_ADDR
d10v_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  ULONGEST sp;
  frame_unwind_unsigned_register (next_frame, D10V_SP_REGNUM, &sp);
  return d10v_make_daddr (sp);
}

/* When arguments must be pushed onto the stack, they go on in reverse
   order.  The below implements a FILO (stack) to do this.  */

struct stack_item
{
  int len;
  struct stack_item *prev;
  void *data;
};

static struct stack_item *push_stack_item (struct stack_item *prev,
					   void *contents, int len);
static struct stack_item *
push_stack_item (struct stack_item *prev, void *contents, int len)
{
  struct stack_item *si;
  si = xmalloc (sizeof (struct stack_item));
  si->data = xmalloc (len);
  si->len = len;
  si->prev = prev;
  memcpy (si->data, contents, len);
  return si;
}

static struct stack_item *pop_stack_item (struct stack_item *si);
static struct stack_item *
pop_stack_item (struct stack_item *si)
{
  struct stack_item *dead = si;
  si = si->prev;
  xfree (dead->data);
  xfree (dead);
  return si;
}


static CORE_ADDR
d10v_push_dummy_code (struct gdbarch *gdbarch,
		      CORE_ADDR sp, CORE_ADDR funaddr, int using_gcc,
		      struct value **args, int nargs,
		      struct type *value_type,
		      CORE_ADDR *real_pc, CORE_ADDR *bp_addr)
{
  /* Allocate space sufficient for a breakpoint.  */
  sp = (sp - 4) & ~3;
  /* Store the address of that breakpoint taking care to first convert
     it into a code (IADDR) address from a stack (DADDR) address.
     This of course assumes that the two virtual addresses map onto
     the same real address.  */
  (*bp_addr) = d10v_make_iaddr (d10v_convert_iaddr_to_raw (sp));
  /* d10v always starts the call at the callee's entry point.  */
  (*real_pc) = funaddr;
  return sp;
}

static CORE_ADDR
d10v_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
		      struct regcache *regcache, CORE_ADDR bp_addr,
		      int nargs, struct value **args, CORE_ADDR sp, 
		      int struct_return, CORE_ADDR struct_addr)
{
  int i;
  int regnum = ARG1_REGNUM;
  struct stack_item *si = NULL;
  long val;

  /* Set the return address.  For the d10v, the return breakpoint is
     always at BP_ADDR.  */
  regcache_cooked_write_unsigned (regcache, LR_REGNUM,
				  d10v_convert_iaddr_to_raw (bp_addr));

  /* If STRUCT_RETURN is true, then the struct return address (in
     STRUCT_ADDR) will consume the first argument-passing register.
     Both adjust the register count and store that value.  */
  if (struct_return)
    {
      regcache_cooked_write_unsigned (regcache, regnum, struct_addr);
      regnum++;
    }

  /* Fill in registers and arg lists */
  for (i = 0; i < nargs; i++)
    {
      struct value *arg = args[i];
      struct type *type = check_typedef (VALUE_TYPE (arg));
      char *contents = VALUE_CONTENTS (arg);
      int len = TYPE_LENGTH (type);
      int aligned_regnum = (regnum + 1) & ~1;

      /* printf ("push: type=%d len=%d\n", TYPE_CODE (type), len); */
      if (len <= 2 && regnum <= ARGN_REGNUM)
	/* fits in a single register, do not align */
	{
	  val = extract_unsigned_integer (contents, len);
	  regcache_cooked_write_unsigned (regcache, regnum++, val);
	}
      else if (len <= (ARGN_REGNUM - aligned_regnum + 1) * 2)
	/* value fits in remaining registers, store keeping left
	   aligned */
	{
	  int b;
	  regnum = aligned_regnum;
	  for (b = 0; b < (len & ~1); b += 2)
	    {
	      val = extract_unsigned_integer (&contents[b], 2);
	      regcache_cooked_write_unsigned (regcache, regnum++, val);
	    }
	  if (b < len)
	    {
	      val = extract_unsigned_integer (&contents[b], 1);
	      regcache_cooked_write_unsigned (regcache, regnum++, (val << 8));
	    }
	}
      else
	{
	  /* arg will go onto stack */
	  regnum = ARGN_REGNUM + 1;
	  si = push_stack_item (si, contents, len);
	}
    }

  while (si)
    {
      sp = (sp - si->len) & ~1;
      write_memory (sp, si->data, si->len);
      si = pop_stack_item (si);
    }

  /* Finally, update the SP register.  */
  regcache_cooked_write_unsigned (regcache, D10V_SP_REGNUM,
				  d10v_convert_daddr_to_raw (sp));

  return sp;
}

/* Translate a GDB virtual ADDR/LEN into a format the remote target
   understands.  Returns number of bytes that can be transfered
   starting at TARG_ADDR.  Return ZERO if no bytes can be transfered
   (segmentation fault).  Since the simulator knows all about how the
   VM system works, we just call that to do the translation.  */

static void
remote_d10v_translate_xfer_address (struct gdbarch *gdbarch,
				    struct regcache *regcache,
				    CORE_ADDR memaddr, int nr_bytes,
				    CORE_ADDR *targ_addr, int *targ_len)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  long out_addr;
  long out_len;
  out_len = sim_d10v_translate_addr (memaddr, nr_bytes, &out_addr, regcache,
				     tdep->dmap_register, tdep->imap_register);
  *targ_addr = out_addr;
  *targ_len = out_len;
}


/* The following code implements access to, and display of, the D10V's
   instruction trace buffer.  The buffer consists of 64K or more
   4-byte words of data, of which each words includes an 8-bit count,
   an 8-bit segment number, and a 16-bit instruction address.

   In theory, the trace buffer is continuously capturing instruction
   data that the CPU presents on its "debug bus", but in practice, the
   ROMified GDB stub only enables tracing when it continues or steps
   the program, and stops tracing when the program stops; so it
   actually works for GDB to read the buffer counter out of memory and
   then read each trace word.  The counter records where the tracing
   stops, but there is no record of where it started, so we remember
   the PC when we resumed and then search backwards in the trace
   buffer for a word that includes that address.  This is not perfect,
   because you will miss trace data if the resumption PC is the target
   of a branch.  (The value of the buffer counter is semi-random, any
   trace data from a previous program stop is gone.)  */

/* The address of the last word recorded in the trace buffer.  */

#define DBBC_ADDR (0xd80000)

/* The base of the trace buffer, at least for the "Board_0".  */

#define TRACE_BUFFER_BASE (0xf40000)

static void trace_command (char *, int);

static void untrace_command (char *, int);

static void trace_info (char *, int);

static void tdisassemble_command (char *, int);

static void display_trace (int, int);

/* True when instruction traces are being collected.  */

static int tracing;

/* Remembered PC.  */

static CORE_ADDR last_pc;

/* True when trace output should be displayed whenever program stops.  */

static int trace_display;

/* True when trace listing should include source lines.  */

static int default_trace_show_source = 1;

struct trace_buffer
  {
    int size;
    short *counts;
    CORE_ADDR *addrs;
  }
trace_data;

static void
trace_command (char *args, int from_tty)
{
  /* Clear the host-side trace buffer, allocating space if needed.  */
  trace_data.size = 0;
  if (trace_data.counts == NULL)
    trace_data.counts = XCALLOC (65536, short);
  if (trace_data.addrs == NULL)
    trace_data.addrs = XCALLOC (65536, CORE_ADDR);

  tracing = 1;

  printf_filtered ("Tracing is now on.\n");
}

static void
untrace_command (char *args, int from_tty)
{
  tracing = 0;

  printf_filtered ("Tracing is now off.\n");
}

static void
trace_info (char *args, int from_tty)
{
  int i;

  if (trace_data.size)
    {
      printf_filtered ("%d entries in trace buffer:\n", trace_data.size);

      for (i = 0; i < trace_data.size; ++i)
	{
	  printf_filtered ("%d: %d instruction%s at 0x%s\n",
			   i,
			   trace_data.counts[i],
			   (trace_data.counts[i] == 1 ? "" : "s"),
			   paddr_nz (trace_data.addrs[i]));
	}
    }
  else
    printf_filtered ("No entries in trace buffer.\n");

  printf_filtered ("Tracing is currently %s.\n", (tracing ? "on" : "off"));
}

static void
d10v_eva_prepare_to_trace (void)
{
  if (!tracing)
    return;

  last_pc = read_register (D10V_PC_REGNUM);
}

/* Collect trace data from the target board and format it into a form
   more useful for display.  */

static void
d10v_eva_get_trace_data (void)
{
  int count, i, j, oldsize;
  int trace_addr, trace_seg, trace_cnt, next_cnt;
  unsigned int last_trace, trace_word, next_word;
  unsigned int *tmpspace;

  if (!tracing)
    return;

  tmpspace = xmalloc (65536 * sizeof (unsigned int));

  last_trace = read_memory_unsigned_integer (DBBC_ADDR, 2) << 2;

  /* Collect buffer contents from the target, stopping when we reach
     the word recorded when execution resumed.  */

  count = 0;
  while (last_trace > 0)
    {
      QUIT;
      trace_word =
	read_memory_unsigned_integer (TRACE_BUFFER_BASE + last_trace, 4);
      trace_addr = trace_word & 0xffff;
      last_trace -= 4;
      /* Ignore an apparently nonsensical entry.  */
      if (trace_addr == 0xffd5)
	continue;
      tmpspace[count++] = trace_word;
      if (trace_addr == last_pc)
	break;
      if (count > 65535)
	break;
    }

  /* Move the data to the host-side trace buffer, adjusting counts to
     include the last instruction executed and transforming the address
     into something that GDB likes.  */

  for (i = 0; i < count; ++i)
    {
      trace_word = tmpspace[i];
      next_word = ((i == 0) ? 0 : tmpspace[i - 1]);
      trace_addr = trace_word & 0xffff;
      next_cnt = (next_word >> 24) & 0xff;
      j = trace_data.size + count - i - 1;
      trace_data.addrs[j] = (trace_addr << 2) + 0x1000000;
      trace_data.counts[j] = next_cnt + 1;
    }

  oldsize = trace_data.size;
  trace_data.size += count;

  xfree (tmpspace);

  if (trace_display)
    display_trace (oldsize, trace_data.size);
}

static void
tdisassemble_command (char *arg, int from_tty)
{
  int i, count;
  CORE_ADDR low, high;

  if (!arg)
    {
      low = 0;
      high = trace_data.size;
    }
  else
    { 
      char *space_index = strchr (arg, ' ');
      if (space_index == NULL)
	{
	  low = parse_and_eval_address (arg);
	  high = low + 5;
	}
      else
	{
	  /* Two arguments.  */
	  *space_index = '\0';
	  low = parse_and_eval_address (arg);
	  high = parse_and_eval_address (space_index + 1);
	  if (high < low)
	    high = low;
	}
    }

  printf_filtered ("Dump of trace from %s to %s:\n", 
		   paddr_u (low), paddr_u (high));

  display_trace (low, high);

  printf_filtered ("End of trace dump.\n");
  gdb_flush (gdb_stdout);
}

static void
display_trace (int low, int high)
{
  int i, count, trace_show_source, first, suppress;
  CORE_ADDR next_address;

  trace_show_source = default_trace_show_source;
  if (!have_full_symbols () && !have_partial_symbols ())
    {
      trace_show_source = 0;
      printf_filtered ("No symbol table is loaded.  Use the \"file\" command.\n");
      printf_filtered ("Trace will not display any source.\n");
    }

  first = 1;
  suppress = 0;
  for (i = low; i < high; ++i)
    {
      next_address = trace_data.addrs[i];
      count = trace_data.counts[i];
      while (count-- > 0)
	{
	  QUIT;
	  if (trace_show_source)
	    {
	      struct symtab_and_line sal, sal_prev;

	      sal_prev = find_pc_line (next_address - 4, 0);
	      sal = find_pc_line (next_address, 0);

	      if (sal.symtab)
		{
		  if (first || sal.line != sal_prev.line)
		    print_source_lines (sal.symtab, sal.line, sal.line + 1, 0);
		  suppress = 0;
		}
	      else
		{
		  if (!suppress)
		    /* FIXME-32x64--assumes sal.pc fits in long.  */
		    printf_filtered ("No source file for address %s.\n",
				     hex_string ((unsigned long) sal.pc));
		  suppress = 1;
		}
	    }
	  first = 0;
	  print_address (next_address, gdb_stdout);
	  printf_filtered (":");
	  printf_filtered ("\t");
	  wrap_here ("    ");
	  next_address += gdb_print_insn (next_address, gdb_stdout);
	  printf_filtered ("\n");
	  gdb_flush (gdb_stdout);
	}
    }
}

static CORE_ADDR
d10v_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  ULONGEST pc;
  frame_unwind_unsigned_register (next_frame, D10V_PC_REGNUM, &pc);
  return d10v_make_iaddr (pc);
}

/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct.  */

static void
d10v_frame_this_id (struct frame_info *next_frame,
		    void **this_prologue_cache,
		    struct frame_id *this_id)
{
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_prologue_cache);
  CORE_ADDR base;
  CORE_ADDR func;
  struct frame_id id;

  /* The FUNC is easy.  */
  func = frame_func_unwind (next_frame);

  /* Hopefully the prologue analysis either correctly determined the
     frame's base (which is the SP from the previous frame), or set
     that base to "NULL".  */
  base = info->prev_sp;
  if (base == STACK_START || base == 0)
    return;

  id = frame_id_build (base, func);

  (*this_id) = id;
}

static void
d10v_frame_prev_register (struct frame_info *next_frame,
			  void **this_prologue_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *bufferp)
{
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_prologue_cache);
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, bufferp);
}

static const struct frame_unwind d10v_frame_unwind = {
  NORMAL_FRAME,
  d10v_frame_this_id,
  d10v_frame_prev_register
};

static const struct frame_unwind *
d10v_frame_sniffer (struct frame_info *next_frame)
{
  return &d10v_frame_unwind;
}

static CORE_ADDR
d10v_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_cache);
  return info->base;
}

static const struct frame_base d10v_frame_base = {
  &d10v_frame_unwind,
  d10v_frame_base_address,
  d10v_frame_base_address,
  d10v_frame_base_address
};

/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
   dummy frame.  The frame ID's base needs to match the TOS value
   saved by save_dummy_frame_tos(), and the PC match the dummy frame's
   breakpoint.  */

static struct frame_id
d10v_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_id_build (d10v_unwind_sp (gdbarch, next_frame),
			 frame_pc_unwind (next_frame));
}

static gdbarch_init_ftype d10v_gdbarch_init;

static struct gdbarch *
d10v_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;
  int d10v_num_regs;
  struct gdbarch_tdep *tdep;
  gdbarch_register_name_ftype *d10v_register_name;
  gdbarch_register_sim_regno_ftype *d10v_register_sim_regno;

  /* Find a candidate among the list of pre-declared architectures.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* None found, create a new architecture from the information
     provided.  */
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  switch (info.bfd_arch_info->mach)
    {
    case bfd_mach_d10v_ts2:
      d10v_num_regs = 37;
      d10v_register_name = d10v_ts2_register_name;
      d10v_register_sim_regno = d10v_ts2_register_sim_regno;
      tdep->a0_regnum = TS2_A0_REGNUM;
      tdep->nr_dmap_regs = TS2_NR_DMAP_REGS;
      tdep->dmap_register = d10v_ts2_dmap_register;
      tdep->imap_register = d10v_ts2_imap_register;
      break;
    default:
    case bfd_mach_d10v_ts3:
      d10v_num_regs = 42;
      d10v_register_name = d10v_ts3_register_name;
      d10v_register_sim_regno = d10v_ts3_register_sim_regno;
      tdep->a0_regnum = TS3_A0_REGNUM;
      tdep->nr_dmap_regs = TS3_NR_DMAP_REGS;
      tdep->dmap_register = d10v_ts3_dmap_register;
      tdep->imap_register = d10v_ts3_imap_register;
      break;
    }

  set_gdbarch_read_pc (gdbarch, d10v_read_pc);
  set_gdbarch_write_pc (gdbarch, d10v_write_pc);
  set_gdbarch_unwind_sp (gdbarch, d10v_unwind_sp);

  set_gdbarch_num_regs (gdbarch, d10v_num_regs);
  set_gdbarch_sp_regnum (gdbarch, D10V_SP_REGNUM);
  set_gdbarch_register_name (gdbarch, d10v_register_name);
  set_gdbarch_register_type (gdbarch, d10v_register_type);

  set_gdbarch_ptr_bit (gdbarch, 2 * TARGET_CHAR_BIT);
  set_gdbarch_addr_bit (gdbarch, 32);
  set_gdbarch_address_to_pointer (gdbarch, d10v_address_to_pointer);
  set_gdbarch_pointer_to_address (gdbarch, d10v_pointer_to_address);
  set_gdbarch_integer_to_address (gdbarch, d10v_integer_to_address);
  set_gdbarch_short_bit (gdbarch, 2 * TARGET_CHAR_BIT);
  set_gdbarch_int_bit (gdbarch, 2 * TARGET_CHAR_BIT);
  set_gdbarch_long_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_long_bit (gdbarch, 8 * TARGET_CHAR_BIT);
  /* NOTE: The d10v as a 32 bit ``float'' and ``double''. ``long
     double'' is 64 bits.  */
  set_gdbarch_float_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_double_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
  switch (info.byte_order)
    {
    case BFD_ENDIAN_BIG:
      set_gdbarch_float_format (gdbarch, &floatformat_ieee_single_big);
      set_gdbarch_double_format (gdbarch, &floatformat_ieee_single_big);
      set_gdbarch_long_double_format (gdbarch, &floatformat_ieee_double_big);
      break;
    case BFD_ENDIAN_LITTLE:
      set_gdbarch_float_format (gdbarch, &floatformat_ieee_single_little);
      set_gdbarch_double_format (gdbarch, &floatformat_ieee_single_little);
      set_gdbarch_long_double_format (gdbarch, 
				      &floatformat_ieee_double_little);
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      "d10v_gdbarch_init: bad byte order for float format");
    }

  set_gdbarch_return_value (gdbarch, d10v_return_value);
  set_gdbarch_push_dummy_code (gdbarch, d10v_push_dummy_code);
  set_gdbarch_push_dummy_call (gdbarch, d10v_push_dummy_call);

  set_gdbarch_skip_prologue (gdbarch, d10v_skip_prologue);
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_decr_pc_after_break (gdbarch, 4);
  set_gdbarch_breakpoint_from_pc (gdbarch, d10v_breakpoint_from_pc);

  set_gdbarch_remote_translate_xfer_address (gdbarch, 
					     remote_d10v_translate_xfer_address);

  set_gdbarch_frame_align (gdbarch, d10v_frame_align);

  set_gdbarch_register_sim_regno (gdbarch, d10v_register_sim_regno);

  set_gdbarch_print_registers_info (gdbarch, d10v_print_registers_info);

  frame_unwind_append_sniffer (gdbarch, d10v_frame_sniffer);
  frame_base_set_default (gdbarch, &d10v_frame_base);

  /* Methods for saving / extracting a dummy frame's ID.  The ID's
     stack address must match the SP value returned by
     PUSH_DUMMY_CALL, and saved by generic_save_dummy_frame_tos.  */
  set_gdbarch_unwind_dummy_id (gdbarch, d10v_unwind_dummy_id);

  /* Return the unwound PC value.  */
  set_gdbarch_unwind_pc (gdbarch, d10v_unwind_pc);

  set_gdbarch_print_insn (gdbarch, print_insn_d10v);

  return gdbarch;
}

void
_initialize_d10v_tdep (void)
{
  register_gdbarch_init (bfd_arch_d10v, d10v_gdbarch_init);

  deprecated_target_resume_hook = d10v_eva_prepare_to_trace;
  deprecated_target_wait_loop_hook = d10v_eva_get_trace_data;

  deprecate_cmd (add_com ("regs", class_vars, show_regs, 
			  "Print all registers"),
		 "info registers");

  add_com ("itrace", class_support, trace_command,
	   "Enable tracing of instruction execution.");

  add_com ("iuntrace", class_support, untrace_command,
	   "Disable tracing of instruction execution.");

  add_com ("itdisassemble", class_vars, tdisassemble_command,
	   "Disassemble the trace buffer.\n\
Two optional arguments specify a range of trace buffer entries\n\
as reported by info trace (NOT addresses!).");

  add_info ("itrace", trace_info,
	    "Display info about the trace data buffer.");

  add_setshow_boolean_cmd ("itracedisplay", no_class, &trace_display, "\
Set automatic display of trace.", "\
Show automatic display of trace.", "\
Controls the display of d10v specific instruction trace information.", "\
Automatic display of trace is %s.",
			   NULL, NULL, &setlist, &showlist);
  add_setshow_boolean_cmd ("itracesource", no_class,
			   &default_trace_show_source, "\
Set display of source code with trace.", "\
Show display of source code with trace.", "\
When on source code is included in the d10v instruction trace display.", "\
Display of source code with trace is %s.",
			   NULL, NULL, &setlist, &showlist);
}
@


1.148
log
@2004-08-07  Andrew Cagney  <cagney@@gnu.org>

	* gdbtypes.h (struct builtin_type): Delete builtin_int0 through to
	builtin_uint128.
	* gdbtypes.c (gdbtypes_post_init): Update.
	(build_gdbtypes): Move initialization of builtin_type_int0
	through to builtin_type_uint128 from here ...
	(_initialize_gdbtypes): ... to here.
	* d10v-tdep.c (d10v_register_type): Update.
@
text
@d1316 1
a1316 1
				 local_hex_string ((unsigned long) sal.pc));
@


1.147
log
@2004-07-31  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Rename
	trad_frame_get_prev_register.
	* vax-tdep.c (vax_frame_prev_register): Update.
	* trad-frame.h: Update.
	* trad-frame.c (trad_frame_get_register): Update.
	* sparcobsd-tdep.c (sparc32obsd_frame_prev_register): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64obsd-tdep.c (sparc64obsd_frame_prev_register): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_prev_register):
	Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-linux-tdep.c (sparc32_linux_sigtramp_frame_prev_register):
	Update.
	* s390-tdep.c (s390_frame_prev_register)
	(s390_stub_frame_prev_register)
	(s390_sigtramp_frame_prev_register): Update.
	* rs6000-tdep.c (rs6000_frame_prev_register): Update.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_prev_register): Update.
	* mips-tdep.c (mips_mdebug_frame_prev_register): Update.
	* m88k-tdep.c (m88k_frame_prev_register)
	* m68hc11-tdep.c (m68hc11_frame_prev_register)
	* m32r-tdep.c (m32r_frame_prev_register): Update.
	* hppa-tdep.c (hppa_frame_prev_register_helper)
	* frv-tdep.c (frv_frame_prev_register): Update.
	* d10v-tdep.c (d10v_frame_prev_register): Update.
	* cris-tdep.c (cris_frame_prev_register): Update.
	* avr-tdep.c (avr_frame_prev_register): Update.
	* arm-tdep.c (arm_prologue_prev_register)
	(arm_sigtramp_prev_register): Update.
@
text
@d290 1
a290 1
    return builtin_type (gdbarch)->builtin_int64;
d292 1
a292 1
    return builtin_type (gdbarch)->builtin_int16;
@


1.146
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_zinteger_cmd)
	(add_setshow_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_cmd_full): Add help_doc and
	print parameters.  Make string parameters constant.
	* command.h: Update.  Update copyright.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* complaints.c (_initialize_complaints): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* target.c (initialize_targets): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* d10v-tdep.c (_initialize_d10v_tdep): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
@
text
@d1378 2
a1379 2
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, bufferp);
@


1.145
log
@2004-07-27  Andrew Cagney  <cagney@@gnu.org>

	* gdbtypes.h (struct builtin_type): Declare.
	(builtin_type): Declare.
	* d10v-tdep.c (d10v_register_type): Use builtin_type.
	* gdbtypes.c (_initialize_gdbtypes): Register gdbtypes_post_init.
	(gdbtypes_post_init): New function.
	(builtin_type): New function.
@
text
@d1566 5
a1570 3
  add_setshow_boolean_cmd ("itracedisplay", no_class, &trace_display,
			   "Set automatic display of trace.\n",
			   "Show automatic display of trace.\n",
d1573 5
a1577 3
			   &default_trace_show_source,
			   "Set display of source code with trace.\n",
			   "Show display of source code with trace.\n",
@


1.144
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@d285 1
a285 1
    return builtin_type_void_func_ptr;
d287 1
a287 1
    return builtin_type_void_data_ptr;
d290 1
a290 1
    return builtin_type_int64;
d292 1
a292 1
    return builtin_type_int16;
@


1.143
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d956 1
a956 1
d10v_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
@


1.142
log
@2004-02-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAMELESS_FUNCTION_INVOCATION): Predicate
	and function replacing FRAMELESS_FUNCTION_INVOCATION.
	* blockframe.c (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* frame.h (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	(delta68_frame_args_address): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	(frv_frameless_function_invocation): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	(cris_frameless_function_invocation): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* stack.c (frame_info): Update, call predicate.
	* rs6000-tdep.c (rs6000_frame_chain): Update, call predicate..
	* frame.c (legacy_get_prev_frame): Update, call predicate..
	* arch-utils.c (generic_frameless_function_invocation_not): Delete.
	* arch-utils.h (generic_frameless_function_invocation_not): Delete.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set frameless function
	invocation.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
@
text
@d1545 2
a1546 2
  target_resume_hook = d10v_eva_prepare_to_trace;
  target_wait_loop_hook = d10v_eva_get_trace_data;
@


1.142.2.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d285 1
a285 1
    return builtin_type (gdbarch)->builtin_func_ptr;
d287 1
a287 1
    return builtin_type (gdbarch)->builtin_data_ptr;
d956 1
a956 1
d10v_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
d1316 1
a1316 1
				     hex_string ((unsigned long) sal.pc));
d1378 2
a1379 2
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, bufferp);
d1545 2
a1546 2
  deprecated_target_resume_hook = d10v_eva_prepare_to_trace;
  deprecated_target_wait_loop_hook = d10v_eva_get_trace_data;
d1566 3
a1568 5
  add_setshow_boolean_cmd ("itracedisplay", no_class, &trace_display, "\
Set automatic display of trace.", "\
Show automatic display of trace.", "\
Controls the display of d10v specific instruction trace information.", "\
Automatic display of trace is %s.",
d1571 3
a1573 5
			   &default_trace_show_source, "\
Set display of source code with trace.", "\
Show display of source code with trace.", "\
When on source code is included in the d10v instruction trace display.", "\
Display of source code with trace is %s.",
@


1.141
log
@2004-02-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_SKIP): Default to 0.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@a1517 3
  set_gdbarch_frameless_function_invocation (gdbarch, 
					     frameless_look_for_prologue);

@


1.140
log
@2004-01-20  Andrew Cagney  <cagney@@redhat.com>

	* ax-gdb.c (print_axs_value): Delete unused function.
	* jv-lang.c (java_lookup_type): Delete unused function.
	* cli/cli-dump.c (dump_filetype): Delete unused function.
	* remote-mips.c (remote_mips_insert_hw_breakpoint)
	(remote_mips_remove_hw_breakpoint): Delete unused functions.
	(mips_getstring): Delete unused function.
	(pmon_insert_breakpoint): Delete #if0ed function.
	(PMON_MAX_BP): Delete #if0ed MACRO.
	(mips_pmon_bp_info): Delete #if0ed variable.
	(pmon_remove_breakpoint): Delete #if0ed function.
	* monitor.c (monitor_write_even_block): Delete unused function.
	(monitor_write_memory_block): Delete #if0ed code.
	* dink32-rom.c (dink32_load): Delete unused function.
	(_initialize_dink32_rom): Delete #if0ed code.
	* d10v-tdep.c (d10v_daddr_p): Delete unused function.
@
text
@a1517 1
  set_gdbarch_frame_args_skip (gdbarch, 0);
@


1.139
log
@2004-01-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FUNCTION_START_OFFSET): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	FUNCTION_START_OFFSET.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@a295 6
d10v_daddr_p (CORE_ADDR x)
{
  return (((x) & 0x3000000) == DMEM_START);
}

static int
@


1.138
log
@2003-11-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (return_value): Replace "inval" and "outval" with
	"readbuf" and "writebuf".
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* d10v-tdep.c (d10v_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-sysv-tdep.c (do_ppc_sysv_return_value): Ditto.
	(ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* values.c (register_value_being_returned): Update call.
	* stack.c (return_command): Update call.
	* gdbarch.h, gdbarch.c: Re-generate.

Index: gdb/doc/ChangeLog
2003-11-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace the
	return_value method's "inval" and "outval" parameters with
	"readbuf" and "writebuf".
@
text
@a1518 1
  set_gdbarch_function_start_offset (gdbarch, 0);
@


1.137
log
@2003-11-09  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_return_value): New function.
	(d10v_use_struct_convention): Delete function.
	(d10v_store_return_value): Delete function.
	(d10v_extract_struct_value_address): Delete function.
	(d10v_gdbarch_init): Set "return_value" instead of
	"extract_return_value", "store_return_value",
	"extract_struct_value_address", and "use_struct_convention".
	(RET1_REGNUM): Delete const.
@
text
@d381 2
a382 2
		   struct regcache *regcache, const void *writebuf,
		   void *readbuf)
@


1.136
log
@2003-10-31  Andrew Cagney  <cagney@@redhat.com>

	* avr-tdep.c (avr_frame_this_id): Do not call
	deprecated_inside_entry_file.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Ditto.
	* m32r-tdep.c (m32r_frame_this_id): Ditto.
	* d10v-tdep.c (d10v_frame_this_id): Ditto.
	* arm-tdep.c (arm_prologue_this_id): Ditto.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Ditto.
@
text
@d85 1
a85 2
    ARGN_REGNUM = R3_REGNUM,
    RET1_REGNUM = R0_REGNUM,
a115 38
/* Should we use EXTRACT_STRUCT_VALUE_ADDRESS instead of
   EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc
   and TYPE is the type (which is known to be struct, union or array).

   The d10v returns anything less than 8 bytes in size in
   registers.  */

static int
d10v_use_struct_convention (int gcc_p, struct type *type)
{
  long alignment;
  int i;
  /* The d10v only passes a struct in a register when that structure
     has an alignment that matches the size of a register.  */
  /* If the structure doesn't fit in 4 registers, put it on the
     stack.  */
  if (TYPE_LENGTH (type) > 8)
    return 1;
  /* If the struct contains only one field, don't put it on the stack
     - gcc can fit it in one or more registers.  */
  if (TYPE_NFIELDS (type) == 1)
    return 0;
  alignment = TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0));
  for (i = 1; i < TYPE_NFIELDS (type); i++)
    {
      /* If the alignment changes, just assume it goes on the
         stack.  */
      if (TYPE_LENGTH (TYPE_FIELD_TYPE (type, i)) != alignment)
	return 1;
    }
  /* If the alignment is suitable for the d10v's 16 bit registers,
     don't put it on the stack.  */
  if (alignment == 2 || alignment == 4)
    return 0;
  return 1;
}


d377 1
a377 2
/* Write into appropriate registers a function return value
   of type TYPE, given in virtual format.  
d379 27
a405 1
   Things always get returned in RET1_REGNUM, RET2_REGNUM, ... */
d407 16
a422 12
static void
d10v_store_return_value (struct type *type, struct regcache *regcache,
			 const void *valbuf)
{
  /* Only char return values need to be shifted right within the first
     regnum.  */
  if (TYPE_LENGTH (type) == 1
      && TYPE_CODE (type) == TYPE_CODE_INT)
    {
      bfd_byte tmp[2];
      tmp[1] = *(bfd_byte *)valbuf;
      regcache_cooked_write (regcache, RET1_REGNUM, tmp);
d424 9
a432 1
  else
d435 4
a438 6
      /* A structure is never more than 8 bytes long.  See
         use_struct_convention().  */
      gdb_assert (TYPE_LENGTH (type) <= 8);
      /* Write out most registers, stop loop before trying to write
         out any dangling byte at the end of the buffer.  */
      for (reg = 0; (reg * 2) + 1 < TYPE_LENGTH (type); reg++)
d440 16
a455 2
	  regcache_cooked_write (regcache, RET1_REGNUM + reg,
				 (bfd_byte *) valbuf + reg * 2);
a456 4
      /* Write out any dangling byte at the end of the buffer.  */
      if ((reg * 2) + 1 == TYPE_LENGTH (type))
	regcache_cooked_write_part (regcache, reg, 0, 1,
				    (bfd_byte *) valbuf + reg * 2);
d458 1
a458 12
}

/* Extract from an array REGBUF containing the (raw) register state
   the address in which a function should return its structure value,
   as a CORE_ADDR (or an expression that can be used as one).  */

static CORE_ADDR
d10v_extract_struct_value_address (struct regcache *regcache)
{
  ULONGEST addr;
  regcache_cooked_read_unsigned (regcache, ARG1_REGNUM, &addr);
  return (addr | DMEM_START);
a1040 40

/* Given a return value in `regbuf' with a type `valtype', 
   extract and copy its value into `valbuf'.  */

static void
d10v_extract_return_value (struct type *type, struct regcache *regcache,
			   void *valbuf)
{
  int len;
  if (TYPE_LENGTH (type) == 1)
    {
      ULONGEST c;
      regcache_cooked_read_unsigned (regcache, RET1_REGNUM, &c);
      store_unsigned_integer (valbuf, 1, c);
    }
  else
    {
      /* For return values of odd size, the first byte is in the
	 least significant part of the first register.  The
	 remaining bytes in remaining registers. Interestingly, when
	 such values are passed in, the last byte is in the most
	 significant byte of that same register - wierd.  */
      int reg = RET1_REGNUM;
      int off = 0;
      if (TYPE_LENGTH (type) & 1)
	{
	  regcache_cooked_read_part (regcache, RET1_REGNUM, 1, 1,
				     (bfd_byte *)valbuf + off);
	  off++;
	  reg++;
	}
      /* Transfer the remaining registers.  */
      for (; off < TYPE_LENGTH (type); reg++, off += 2)
	{
	  regcache_cooked_read (regcache, RET1_REGNUM + reg,
				(bfd_byte *) valbuf + off);
	}
    }
}

d1512 1
a1512 1
  set_gdbarch_extract_return_value (gdbarch, d10v_extract_return_value);
a1514 4
  set_gdbarch_store_return_value (gdbarch, d10v_store_return_value);
  set_gdbarch_extract_struct_value_address (gdbarch, 
					    d10v_extract_struct_value_address);
  set_gdbarch_use_struct_convention (gdbarch, d10v_use_struct_convention);
@


1.135
log
@2003-10-10  Michael Snyder  <msnyder@@redhat.com>

        * d10v-tdep.c: Fix typo in comment.
@
text
@a1407 5
  /* This is meant to halt the backtrace at "_start".  Make sure we
     don't halt it at a generic dummy frame.  */
  if (func <= IMEM_START || deprecated_inside_entry_file (func))
    return;

@


1.134
log
@2003-10-10  Kei Sakamoto  <sakamoto.kei@@renesas.com>

	* NEWS: Replace "Hitachi" and "Mitsubishi" with "Renesas".
	* README: Ditto.
	* d10v-tdep.c: Ditto.
	* h8300-tdep.c: Ditto.
	* remote-e7000.c: Ditto.
	* remote-hms.c: Ditto.
	* ser-e7kpc.c: Ditto.
	* sh-stub.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* sh3-rom.c: Ditto.
	* sh64-tdep.c: Ditto.
	* top.c: Ditto.
	* wince.c: Ditto.
	* config/d10v/d10v.mt: Ditto.
	* config/sh/embed.mt: Ditto.
	* config/sh/linux.mt: Ditto.
	* config/sh/tm-linux.h: Ditto.
	* config/sh/tm-sh.h: Ditto.
	* config/sh/wince.mt: Ditto.
@
text
@d509 1
a509 1
     should the first assembly instruction of the first source line */
@


1.133
log
@2003-10-09  Michael Snyder  <msnyder@@redhat.com>

        * d10v-tdep.c: Random whitespace/comment tweaks.
@
text
@d1 1
a1 1
/* Target-dependent code for Mitsubishi D10V, for GDB.
@


1.132
log
@2003-09-28  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_read_unsigned_register): Delete function.
	* frame.h (frame_read_unsigned_register): Delete declaration.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	get_frame_register_unsigned.
	(sparc_frame_saved_pc, sparc_pop_frame): Ditto.
	* m68hc11-tdep.c (m68hc11_print_register): Ditto.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.

	* frame.h (frame_read_register): Delete declaration.
	* frame.c (frame_read_register): Delete function.
	* arch-utils.c (legacy_register_to_value): Use get_frame_register.
	* sparc-tdep.c (sparc_fetch_pointer_argument): Ditto.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* hppa-tdep.c (hppa_fetch_pointer_argument): Ditto.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.

	* frame.c (frame_read_signed_register): Delete function.
	(frame_read_unsigned_register): Update comments.
	* frame.h (frame_read_signed_register): Delete declaration.
	* h8300-tdep.c (h8300_print_register): Use
	get_frame_register_signed.
	* m68hc11-tdep.c (m68hc11_print_register): Ditto.
@
text
@d60 1
a60 1
   instruction memory to. */
d68 1
a68 1
/* d10v register names. */
d83 1
a83 1
    /* d10v calling convention. */
d122 1
a122 1
   registers. */
d130 1
a130 1
     has an alignment that matches the size of a register. */
d132 1
a132 1
     stack. */
d136 1
a136 1
     - gcc can fit it in one or more registers. */
d143 1
a143 1
         stack. */
d148 1
a148 1
     don't put it on the stack. */
d165 1
a165 1
   when the reg_nr isn't valid. */
d282 1
a282 1
   register numbering. */
d356 1
a356 1
    return x;	/* Idempotency -- x is already in the IMEM space. */
d508 2
a509 2
  /* If we have line debugging information, then the end of the */
  /* prologue should the first assembly instruction of  the first source line */
d518 1
a518 1
    return pc;			/* Can't access it -- assume no prologue. */
d548 3
a550 2
		  /* if the previous opcode was really part of the prologue */
		  /* and not just a NOP, then we want to break after both instructions */
d661 1
a661 1
   for it IS the sp for the next frame. */
d912 1
a912 1
   order.  The below implements a FILO (stack) to do this. */
d969 2
a970 2
		      int nargs, struct value **args, CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
d1067 1
a1067 1
	 significant byte of that same register - wierd. */
d1090 1
a1090 1
   VM system works, we just call that to do the translation. */
d1317 2
a1318 1
  printf_filtered ("Dump of trace from %s to %s:\n", paddr_u (low), paddr_u (high));
d1409 1
a1409 1
     don't halt it at a generic dummy frame. */
d1488 1
a1488 1
  /* Find a candidate among the list of pre-declared architectures. */
d1494 1
a1494 1
     provided. */
d1540 1
a1540 1
     double'' is 64 bits. */
d1554 2
a1555 1
      set_gdbarch_long_double_format (gdbarch, &floatformat_ieee_double_little);
d1566 2
a1567 1
  set_gdbarch_extract_struct_value_address (gdbarch, d10v_extract_struct_value_address);
d1576 2
a1577 1
  set_gdbarch_remote_translate_xfer_address (gdbarch, remote_d10v_translate_xfer_address);
d1580 2
a1581 1
  set_gdbarch_frameless_function_invocation (gdbarch, frameless_look_for_prologue);
d1613 2
a1614 1
  deprecate_cmd (add_com ("regs", class_vars, show_regs, "Print all registers"),
@


1.131
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTE): Rename REGISTER_BYTE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-linux-tdep.c, core-sol2.c, cris-tdep.c: Update.
	* d10v-tdep.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, irix5-nat.c, lynx-nat.c, m68knbsd-nat.c: Update.
	* mcore-tdep.c, mips-linux-tdep.c, mips-tdep.c: Update.
	* mipsv4-nat.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* ns32knbsd-nat.c, ppc-bdm.c, regcache.c, remote-sds.c: Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh64-tdep.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, v850-tdep.c: Update.
	* v850ice.c, vax-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-cisco.h, config/m68k/tm-delta68.h: Update.
	* config/pa/nm-hppah.h: Update.

2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* mi/mi-main.c: Rename REGISTER_BYTE to DEPRECATED_REGISTER_BYTE.
@
text
@d798 5
a802 5
    frame_read_unsigned_register (frame, D10V_PC_REGNUM, &pc);
    frame_read_unsigned_register (frame, PSW_REGNUM, &psw);
    frame_read_unsigned_register (frame, frame_map_name_to_regnum (frame, "rpt_s", -1), &rpt_s);
    frame_read_unsigned_register (frame, frame_map_name_to_regnum (frame, "rpt_e", -1), &rpt_e);
    frame_read_unsigned_register (frame, frame_map_name_to_regnum (frame, "rpt_c", -1), &rpt_c);
d817 1
a817 1
	    frame_read_unsigned_register (frame, r, &tmp);
d859 1
a859 1
	frame_read_register (frame, a, num);
@


1.130
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Deprecate "entry_file_lowpc" and
	"entry_file_highpc".  Update comments.
	* defs.h (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* blockframe.c (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* frame.c (get_prev_frame): Update.  Use if 0 instead of #if 0.
	* vax-tdep.c (vax_frame_chain): Update.
	* sh64-tdep.c (sh64_frame_chain): Update.
	* sh-tdep.c (sh_frame_chain): Update.
	* rs6000-tdep.c (rs6000_frame_chain): Update.
	* ns32k-tdep.c (ns32k_frame_chain): Update.
	* mips-tdep.c (mips_frame_chain): Update.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Update.
	* m32r-tdep.c (m32r_frame_this_id): Update.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Update.
	* frv-tdep.c (frv_frame_this_id): Update.
	* d10v-tdep.c (d10v_frame_this_id): Update.
	* cris-tdep.c (cris_frame_chain): Update.
	* blockframe.c (legacy_frame_chain_valid): Update.
	* avr-tdep.c (avr_frame_this_id): Update.
	* arm-tdep.c (arm_prologue_this_id): Update.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Update.
	* objfiles.c (objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	(mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab): Update.
	(read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d280 3
a282 3
/* MAP GDB's internal register numbering (determined by the layout fo
   the REGISTER_BYTE array) onto the simulator's register
   numbering. */
@


1.129
log
@2003-07-16  Andrew Cagney  <cagney@@redhat.com>

	* frame-base.h (frame_base_p_ftype): Delete definition.
	(frame_base_append_predicate): Delete declaration.
	* frame-unwind.h (frame_unwind_p_ftype): Delete definition.
	(frame_unwind_append_predicate): Delete declaration.
	* frame-unwind.c (struct frame_unwind_table): Delete field "p".
	(append_predicate): Delete parameter "p".
	(frame_unwind_append_predicate): Delete function.
	(frame_unwind_append_sniffer): Update call to append_predicate.
	(frame_unwind_free): Delete function.
	(_initialize_frame_unwind): Pass NULL as "free" to
	register_gdbarch_data.
	(frame_unwind_init): Append the dummy_frame_sniffer.
	(frame_unwind_find_by_frame): Simplify.
	* frame-base.c (struct frame_base_table): Delete field "p".
	(append_predicate): Delete parameter "p".
	(frame_base_append_predicate): Delete function.
	(frame_base_append_sniffer): Update call to append_predicate.
	(frame_base_free): Delete function.
	(frame_base_find_by_frame): Simplify.
	(_initialize_frame_base): Pass NULL as "free" to
	register_gdbarch_data.
	* x86-64-tdep.c (x86_64_frame_sniffer): Replace "x86_64_frame_p".
	(x86_64_sigtramp_frame_sniffer): Replace
	"x86_64_sigtramp_frame_p".
	(x86_64_init_abi): Set the frame unwind sniffers.
	* m68k-tdep.c (m68k_frame_sniffer): Replace "m68k_frame_p".
	(m68k_sigtramp_frame_sniffer): Replace "m68k_sigtramp_frame_p"
	(m68k_gdbarch_init): Set the frame unwind sniffers.
	* i386-tdep.c (i386_sigtramp_frame_sniffer): Replace
	"i386_sigtramp_frame_p".
	(i386_frame_sniffer): Replace "i386_frame_p".
	(i386_gdbarch_init): Set the frame unwind sniffers.
	* avr-tdep.c (avr_frame_sniffer): Replace "avr_frame_sniffer".
	(avr_gdbarch_init): Set the frame unwind sniffers.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Replace
	"alpha_sigtramp_frame_p"
	(alpha_heuristic_frame_sniffer): Replace
	"alpha_heuristic_frame_p".
	(alpha_gdbarch_init): Set the frame unwind sniffers.
	(alpha_dwarf2_init_abi): Ditto.
	* alpha-mdebug-tdep.c (alpha_mdebug_frame_sniffer): Replace
	"alpha_debug_frame_p".
	(alpha_mdebug_frame_base_sniffer): Replace
	"alpha_mdebug_frame_base_p".
	(alpha_mdebug_init_abi): Set the frame unwind sniffers.
	* d10v-tdep.c (d10v_frame_sniffer): Replace "d10v_frame_p".
	(d10v_gdbarch_init): Set the frame unwind sniffer.
	* dwarf2-frame.c (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	(dwarf2_frame_base_sniffer): Replace "dwarf2_frame_base_p".
	* dwarf2-frame.h (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	(dwarf2_frame_base_sniffer): Replace "dwarf2_frame_base_p".
	* dummy-frame.c (dummy_frame_sniffer): Replace "dummy_frame_p".
	* dummy-frame.h (dummy_frame_sniffer): Replace "dummy_frame_p".
@
text
@d1408 1
a1408 1
  if (func <= IMEM_START || inside_entry_file (func))
@


1.128
log
@2003-07-15  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame): Move disabled inside_entry_func to
	before code inhibiting repeated unwind attempts.  Add to
	commentary on that test's problems.
	* blockframe.c (inside_main_func): Look for "main" in the minimal
	symbol table.
	* d10v-tdep.c (d10v_frame_this_id): Delete check that frames are
	identical.

Index: testsuite/ChangeLog
2003-07-15  Andrew Cagney  <cagney@@redhat.com>

	* gdb.asm/asm-source.exp: Do not allow "start" in the backtrace.
@
text
@d1443 1
a1443 1
d10v_frame_p (CORE_ADDR pc)
d1583 1
a1583 1
  frame_unwind_append_predicate (gdbarch, d10v_frame_p);
@


1.127
log
@2003-07-07  Andrew Cagney  <cagney@@redhat.com>

	* expprint.c: Include "user-regs.h" instead of "frame.h".
	(print_subexp): Use user_reg_map_regnum_to_name, instead of
	frame_map_regnum_to_name.
	* frame.c: Include "user-regs.h" instead of "builtin-regs.h".
	(frame_map_name_to_regnum): Simplify, call
	user_reg_map_name_to_regnum.
	(frame_map_regnum_to_name): Simplify, call
	user_reg_map_regnum_to_name.
	(frame_register_unwind): Update.
	* std-regs.c: Include "user-regs.h" instead of "builtin-regs.h".
	(_initialize_frame_reg): Call user_reg_add_builtin.
	* findvar.c: Include "user-regs.h" instead of "builtin-regs.h".
	(value_of_register): Use value_of_user_reg.
	* eval.c (evaluate_subexp_standard): Update.
	* parse.c (write_dollar_variable): Update.
	* d10v-tdep.c (d10v_print_registers_info): Update.
	* infcmd.c (registers_info): Update.
	* Makefile.in (SFILES): Delete "builtin-regs.c", add "user-regs.c".
	(builtin_regs_h): Delete macro.
	(user_regs_h): Define.
	(COMMON_OBS): Delete "builtin-regs.o", add "user-regs.o".
	(builtin-regs.o): Delete target.
	(user-regs.o): Specify dependencies.
	(expprint.o): Update dependencies.
	(findvar.o): Update dependencies.
	(frame.o): Update dependencies.
	(std-regs.o): Update dependencies.
@
text
@a1419 9
  /* Check that we're not going round in circles with the same frame
     ID (but avoid applying the test to sentinel frames which do go
     round in circles).  Can't use frame_id_eq() as that doesn't yet
     compare the frame's PC value.  */
  if (frame_relative_level (next_frame) >= 0
      && get_frame_type (next_frame) != DUMMY_FRAME
      && frame_id_eq (get_frame_id (next_frame), id))
    return;

@


1.126
log
@2003-07-01  Andrew Cagney  <cagney@@redhat.com>

	* trad-frame.h: Update comments, a -1 .addr is reserved.
	(trad_frame_value_p, trad_frame_addr_p): Declare.
	(trad_frame_reg_p): Declare.
	(trad_frame_set_value): Rename trad_frame_register_value.
	(trad_frame_set_unknown): Declare.
	* trad-frame.c (trad_frame_realreg_p): New function.
	(trad_frame_addr_p, trad_frame_value_p): New function.
	(trad_frame_set_unknown): New function.
	(trad_frame_alloc_saved_regs): Initialize .addr to -1, not zero.
	(trad_frame_prev_register): Use trad_frame_realreg_p,
	trad_frame_addr_p and trad_frame_value_p.
	(trad_frame_set_value): Rename trad_frame_register_value.
	* d10v-tdep.c (d10v_frame_unwind_cache): Use trad_frame_addr_p
	and trad_frame_set_value.
@
text
@d800 3
a802 3
    frame_read_unsigned_register (frame, frame_map_name_to_regnum ("rpt_s", -1), &rpt_s);
    frame_read_unsigned_register (frame, frame_map_name_to_regnum ("rpt_e", -1), &rpt_e);
    frame_read_unsigned_register (frame, frame_map_name_to_regnum ("rpt_c", -1), &rpt_c);
@


1.125
log
@2003-06-13  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c (call_function_by_hand): When UNWIND_DUMMY_ID is
	available, do not use the FP register, and always save the TOS.
	* dummy-frame.c (dummy_frame_this_id): Do not assert
	SAVE_DUMMY_FRAME_TOS.
	* i386-tdep.c (i386_save_dummy_frame_tos): Delete function.
	(i386_gdbarch_init): Do not set save_dummy_frame_tos.
	(i386_push_dummy_call): Add 8 to the returned SP.
	* frame.c (legacy_frame_p): Do not require SAVE_DUMMY_FRAME_TOS.
	* d10v-tdep.c (d10v_unwind_dummy_id): Use d10v_unwind_sp.
	(d10v_gdbarch_init): Do not set save_dummy_frame_tos.
	* x86-64-tdep.c (x86_64_save_dummy_frame_tos): Delete function.
	(x86_64_push_dummy_call): Return "sp + 16".
	(x86_64_init_abi): Do not set save_dummy_frame_tos.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set
	save_dummy_frame_tos.
@
text
@d766 1
a766 1
    if (info->saved_regs[i].addr)
d779 2
a780 2
  trad_frame_register_value (info->saved_regs, D10V_SP_REGNUM,
			     d10v_make_daddr (prev_sp));
@


1.125.4.1
log
@2003-07-01  Andrew Cagney  <cagney@@redhat.com>

	* trad-frame.h: Update comments, a -1 .addr is reserved.
	(trad_frame_value_p, trad_frame_addr_p): Declare.
	(trad_frame_reg_p): Declare.
	(trad_frame_set_value): Rename trad_frame_register_value.
	(trad_frame_set_unknown): Declare.
	* trad-frame.c (trad_frame_realreg_p): New function.
	(trad_frame_addr_p, trad_frame_value_p): New function.
	(trad_frame_set_unknown): New function.
	(trad_frame_alloc_saved_regs): Initialize .addr to -1, not zero.
	(trad_frame_prev_register): Use trad_frame_realreg_p,
	trad_frame_addr_p and trad_frame_value_p.
	(trad_frame_set_value): Rename trad_frame_register_value.
	* d10v-tdep.c (d10v_frame_unwind_cache): Use trad_frame_addr_p
	and trad_frame_set_value.
@
text
@d766 1
a766 1
    if (trad_frame_addr_p (info->saved_regs, i))
d779 2
a780 2
  trad_frame_set_value (info->saved_regs, D10V_SP_REGNUM,
			d10v_make_daddr (prev_sp));
@


1.125.4.2
log
@2003-07-15  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame): Move disabled inside_entry_func to
	before code inhibiting repeated unwind attempts.  Add to
	commentary on that test's problems.
	* blockframe.c (inside_main_func): Look for "main" in the minimal
	symbol table.
	* d10v-tdep.c (d10v_frame_this_id): Delete check that frames are
	identical.

Index: testsuite/ChangeLog
2003-07-15  Andrew Cagney  <cagney@@redhat.com>

	* gdb.asm/asm-source.exp: Do not allow "start" in the backtrace.
@
text
@d1420 9
@


1.124
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_NUM_ARGS): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (frame_num_args_unknown): Delete both declarations.
	* arch-utils.c (frame_num_args_unknown): Delete function.
	* stack.c (print_args_stub): Use FRAME_NUM_ARGS_P.
	(frame_info): Use FRAME_NUM_ARGS_P.
	* arm-tdep.c (arm_frame_num_args): Delete function.
	(arm_gdbarch_init): Do not set frame_num_args.
	* config/pa/tm-hppa64.h (FRAME_NUM_ARGS): Delete.
	* hppa-tdep.c (hppa_frame_num_args): Delete function.
	(hppa_gdbarch_init): Do not set frame_num_args.
	* config/sparc/tm-sparc.h (FRAME_NUM_ARGS): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	frame_num_args to default frame_num_args_unknown.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d1480 2
a1481 3
  ULONGEST base;
  frame_unwind_unsigned_register (next_frame, D10V_SP_REGNUM, &base);
  return frame_id_build (d10v_make_daddr (base), frame_pc_unwind (next_frame));
d1595 3
a1597 1
  /* Methods for saving / extracting a dummy frame's ID.  */
a1598 1
  set_gdbarch_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
@


1.123
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (UNWIND_SP): Add.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (frame_sp_unwind): New function.
	(get_frame_sp): New function.
	* frame.h (get_frame_sp, frame_sp_unwind): Declare.
	* regcache.c (read_sp): Rewrite, try each of TARGET_READ_SP,
	gdbarch_unwind_sp and SP_REGNUM when looking for the SP register
	value.
	* d10v-tdep.c (d10v_unwind_sp): Replace d10v_read_sp.
	(d10v_gdbarch_init): Set unwind_sp instead of read_sp.

2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Document
	"unwind_sp".  Cross reference "unwind_sp" and TARGET_READ_SP.
@
text
@a1586 1
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
@


1.122
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* trad-frame.h (struct trad_frame_saved_reg): Rename "struct
	trad_frame".  Update comments.
	* d10v-tdep.c (struct d10v_unwind_cache): Update.
	* trad-frame.c (trad_frame_alloc_saved_regs): Update.
	(trad_frame_register_value, trad_frame_prev_register): Update.
@
text
@a104 2
static CORE_ADDR d10v_read_sp (void);

d903 1
a903 1
d10v_read_sp (void)
d905 3
a907 1
  return (d10v_make_daddr (read_register (D10V_SP_REGNUM)));
d1531 1
a1531 1
  set_gdbarch_read_sp (gdbarch, d10v_read_sp);
@


1.121
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* acinclude.m4 (gcc_AC_CHECK_DECL, (gcc_AC_CHECK_DECL): Stolen
	from GCC's acinclude.m4.
	* configure.in: Check for getopt's delcaration.
	* aclocal.m4, config.in, configure: Re-generate.
	* main.c (error_init): Delete declaration.
	* defs.h (error_init): Declare.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Make static.
	(rs6000_convert_from_func_ptr_addr): Make static.
	(_initialize_rs6000_tdep): Add declaration.
	* cli/cli-cmds.c (dont_repeat): Delete declaration.
	(show_commands, set_verbose, show_history): Delete declaration.
	* top.h (set_verbose): Add declaration.
	(show_history, set_history, show_commands): Add declaration.
	(do_restore_instream_cleanup): Add declaration.
	* objc-lang.c (specialcmp): Make static.
	(print_object_command): Make static.
	(find_objc_msgsend): Make static.
	(find_objc_msgcall_submethod_helper): Make static.
	(find_objc_msgcall_submethod): Make static.
	(_initialize_objc_language): Add declaration.
	(find_implementation_from_class): Make static.
	(find_implementation): Make static.
	* objc-exp.y (yylex): Delete lookup_struct_typedef declaration.
	* objc-lang.h (lookup_struct_typedef): Add declaration.
	* cli/cli-interp.c (_initialize_cli_interp): Add declaration.
	* cli/cli-script.c (clear_hook_in_cleanup): Make static.
	(do_restore_user_call_depth): Make static.
	(do_restore_instream_cleanup): Delete declaration.
	(dont_repeat): Delete declaration.
	* cli/cli-decode.c (add_abbrev_cmd): Delete function.
	* cli/cli-dump.c (_initialize_cli_dump): Add declaration.
	* reggroups.c (_initialize_reggroup): Add declaration.
	* cp-support.c (_initialize_cp_support): Add declaration.
	* cp-abi.c (_initialize_cp_abi): Add declaration.
	* hpacc-abi.c (_initialize_hpacc_abi): Add declaration.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Make static.
	(_initialize_gnu_v3_abi): Add declaration.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Make static.
	(_initialize_gnu_v2_abi): Add declaration.
	* frame-base.c (_initialize_frame_base): Add declaration.
	* doublest.c (floatformat_from_length): Make static.
	* frame-unwind.c (_initialize_frame_unwind): Add declaration.
	* frame.c (create_sentinel_frame): Make static.
	(_initialize_frame): Add declaration.
	* top.c (do_catch_errors): Make static.
	(gdb_rl_operate_and_get_next_completion): Make static.
	* typeprint.c: Include "typeprint.h".
	* sentinel-frame.c (sentinel_frame_prev_register): Make static.
	(sentinel_frame_this_id): Make static.
	* p-valprint.c (_initialize_pascal_valprint): Add declaration.
	* ui-out.c (make_cleanup_ui_out_begin_end): Delete function.
	* dwarf2-frame.c (dwarf2_frame_cache): Make static.
	* p-exp.y (push_current_type, pop_current_type): ISO C declaration.
	* dwarf2expr.h (dwarf_expr_context): ISO C declaration.
	* maint.c (maintenance_print_architecture): Make static.
	* signals/signals.c (_initialize_signals): Add declaration.
	* std-regs.c (_initialize_frame_reg): Add declaration.
	* jv-exp.y (push_variable): ISO C definition.
	(push_qualified_expression_name): Ditto.
	* memattr.c (_initialize_mem): Add declaration.
	* remote.c (remote_check_watch_resources): Make static.
	(remote_stopped_by_watchpoint): Make static.
	(remote_stopped_data_address): Make static.
	* d10v-tdep.c (nr_dmap_regs): Make static.
	(a0_regnum): Make static.
	(d10v_frame_unwind_cache): Make static.
	(d10v_frame_p): Make static.
	* osabi.c (show_osabi): Make static.
	(_initialize_gdb_osabi): Add extern declaration.
	* gdbtypes.c (make_qualified_type): Make static.
	(safe_parse_type): Make static.
	* macrocmd.c (_initialize_macrocmd): Add extern declaration.
	* macrotab.c (macro_bcache_free): Make static.
	* interps.c (interp_set_quiet): Make static.
	(interpreter_exec_cmd): Make static.
	* stack.h (select_frame_command): New file.
	* stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete function.
	(select_frame_command): Make global.
	* infcall.c: Include "infcall.h".
	* linespec.c: Include "linespec.h".
	* symfile.c (sections_overlap): Make static.
	* cp-support.h (cp_initialize_namespace): ISO C declaration.
	* charset.c (_initialize_charset): Add missing prototype.
	* regcache.c (init_legacy_regcache_descr): Make static.
	(do_regcache_xfree): Make static.
	(regcache_xfer_part): Make static.
	(_initialize_regcache): Add missing prototype.
	* breakpoint.c (parse_breakpoint_sals): Make static.
	(breakpoint_sals_to_pc): Make static.
	* interps.h (clear_interpreter_hooks): ISO C declaration.
	* Makefile.in (stack_h): Define.
	(stack.o, typeprint.o, mi-main.o): Update dependencies.
	(mi-cmd-stack.o, infcall.o, linespec.o): Update dependencies.

Index: mi/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-parse.c (_initialize_mi_parse): Delete function.
	* mi-main.c: Include "mi-main.h".
	* mi-interp.c (_initialize_mi_interp): Add declaration.
	* mi-cmd-stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete extern declaration.
	(mi_cmd_stack_select_frame): Replace select_frame_command_wrapper
	with select_frame_command.
@
text
@d580 1
a580 1
  struct trad_frame *saved_regs;
@


1.120
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (d10v-tdep.o): Update dependencies.
	(SFILES): Add trad-frame.c.
	(trad_frame_h): Define.
	(COMMON_OBS): Add trad-frame.o.
	(trad-frame.o): Specify dependencies.
	* d10v-tdep.c: Include "trad-frame.h".
	(saved_regs_unwinder): Delete function.
	(d10v_frame_prev_register): Use trad_frame_prev_register.
	(struct d10v_unwind_cache): Change type of "saved_regs" to "struct
	trad_frame", delete "regs" and "prev_sp".
	(prologue_find_regs): Use trad-frame.
	* trad-frame.h, trad-frame.c: New files.
@
text
@d89 1
a89 1
int
d95 1
a95 1
int
d664 1
a664 1
struct d10v_unwind_cache *
d1451 1
a1451 1
const struct frame_unwind *
@


1.119
log
@2003-06-06  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (struct d10v_unwind_cache): Delete "return_pc".
	(d10v_frame_unwind_cache): Do not set "return_pc".
@
text
@d47 1
a572 1
  CORE_ADDR *saved_regs;
d579 2
a580 1
  void **regs;
d594 1
a594 1
      info->saved_regs[n] = info->sp_offset;
d603 2
a604 2
      info->saved_regs[n] = info->sp_offset;
      info->saved_regs[n + 1] = info->sp_offset + 2;
d630 1
a630 1
      info->saved_regs[n] = info->r11_offset;
d642 1
a642 1
      info->saved_regs[n] = info->sp_offset;
d650 2
a651 2
      info->saved_regs[n] = info->sp_offset;
      info->saved_regs[n + 1] = info->sp_offset + 2;
d682 1
a682 1
  info->saved_regs = FRAME_OBSTACK_CALLOC (NUM_REGS, CORE_ADDR);
d707 1
a707 1
	      info->saved_regs[n] = info->sp_offset + offset;
d714 2
a715 2
	      info->saved_regs[n] = info->sp_offset + offset;
	      info->saved_regs[n + 1] = info->sp_offset + offset + 2;
d741 2
a742 1
  /* Compute the frame's base, and the previous frame's SP.  */
a752 10
  else if (info->saved_regs[D10V_SP_REGNUM])
    {
      /* The SP was saved (which is very unusual), the frame base is
	 just the PREV's frame's TOP-OF-STACK.  */
      this_base
	= get_frame_memory_unsigned (next_frame,
				     info->saved_regs[D10V_SP_REGNUM], 
				     register_size (gdbarch, D10V_SP_REGNUM));
      prev_sp = this_base;
    }
d761 2
a763 1
  info->prev_sp = d10v_make_daddr (prev_sp);
d768 1
a768 1
    if (info->saved_regs[i])
d770 1
a770 1
	info->saved_regs[i] = (info->prev_sp + info->saved_regs[i]);
d773 10
a782 3
  /* The D10V_SP_REGNUM is special.  Instead of the address of the SP, the
     previous frame's SP value is saved.  */
  info->saved_regs[D10V_SP_REGNUM] = info->prev_sp;
a1432 49
saved_regs_unwinder (struct frame_info *next_frame,
		     CORE_ADDR *this_saved_regs,
		     int regnum, int *optimizedp,
		     enum lval_type *lvalp, CORE_ADDR *addrp,
		     int *realnump, void *bufferp)
{
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  if (this_saved_regs[regnum] != 0)
    {
      if (regnum == D10V_SP_REGNUM)
	{
	  /* SP register treated specially.  */
	  *optimizedp = 0;
	  *lvalp = not_lval;
	  *addrp = 0;
	  *realnump = -1;
	  if (bufferp != NULL)
	    store_unsigned_integer (bufferp,
				    register_size (gdbarch, regnum),
				    this_saved_regs[regnum]);
	}
      else
	{
	  /* Any other register is saved in memory, fetch it but cache
	     a local copy of its value.  */
	  *optimizedp = 0;
	  *lvalp = lval_memory;
	  *addrp = this_saved_regs[regnum];
	  *realnump = -1;
	  if (bufferp != NULL)
	    {
	      /* Read the value in from memory.  */
	      get_frame_memory (next_frame, this_saved_regs[regnum], bufferp,
				register_size (gdbarch, regnum));
	    }
	}
      return;
    }

  /* No luck, assume this and the next frame have the same register
     value.  If a value is needed, pass the request on down the chain;
     otherwise just return an indication that the value is in the same
     register as the next frame.  */
  frame_register_unwind (next_frame, regnum, optimizedp, lvalp, addrp,
			 realnump, bufferp);
}


static void
d1441 2
a1442 13
  if (regnum == D10V_PC_REGNUM)
    {
      /* The call instruction saves the caller's PC in LR.  The
	 function prologue of the callee may then save the LR on the
	 stack.  Find that possibly saved LR value and return it.  */
      saved_regs_unwinder (next_frame, info->saved_regs, LR_REGNUM, optimizedp,
			   lvalp, addrp, realnump, bufferp);
    }
  else
    {
      saved_regs_unwinder (next_frame, info->saved_regs, regnum, optimizedp,
			   lvalp, addrp, realnump, bufferp);
    }
@


1.118
log
@2003-06-03  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_frame_memory_signed): New function.
	(get_frame_memory, get_frame_memory_unsigned): New function.
	(get_frame_arch): New function.
	* frame.h (get_frame_signed_memory, get_frame_arch): Declare.
	(get_frame_memory, get_frame_unsigned_memory): Declare.
	* d10v-tdep.c (d10v_frame_unwind_cache): Use
	get_frame_memory_unsigned and get_frame_arch.
	(d10v_frame_unwind_cache, saved_regs_unwinder): Ditto.
@
text
@a565 1
  CORE_ADDR return_pc;
a683 1
  info->return_pc = 0;
a778 14

  if (info->saved_regs[LR_REGNUM])
    {
      CORE_ADDR return_pc
	= get_frame_memory_unsigned (next_frame, info->saved_regs[LR_REGNUM], 
				     register_size (gdbarch, LR_REGNUM));
      info->return_pc = d10v_make_iaddr (return_pc);
    }
  else
    {
      ULONGEST return_pc;
      frame_unwind_unsigned_register (next_frame, LR_REGNUM, &return_pc);
      info->return_pc = d10v_make_iaddr (return_pc);
    }
@


1.117
log
@2003-05-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PUSH_DUMMY_CALL): Add "func_addr" parameter.  Rename
	"dummy_addr" to "bp_addr".
	* infcall.c (call_function_by_hand): Pass "funaddr" to
	gdbarch_push_dummy_call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* i386-tdep.c (i386_push_dummy_call): Update.
	* arm-tdep.c (arm_push_dummy_call): Update.
	* d10v-tdep.c (d10v_push_dummy_call): Update.
@
text
@d668 1
d693 1
a693 1
      op = (unsigned long) read_memory_integer (pc, 4);
d757 4
a760 3
      this_base = read_memory_unsigned_integer (info->saved_regs[D10V_SP_REGNUM], 
						register_size (current_gdbarch,
							       D10V_SP_REGNUM));
d784 3
a786 3
      CORE_ADDR return_pc 
	= read_memory_unsigned_integer (info->saved_regs[LR_REGNUM], 
					register_size (current_gdbarch, LR_REGNUM));
d878 1
a878 1
	for (i = 0; i < register_size (current_gdbarch, a); i++)
d1455 1
d1467 1
a1467 1
				    register_size (current_gdbarch, regnum),
d1481 2
a1482 2
	      read_memory (this_saved_regs[regnum], bufferp,
			   register_size (current_gdbarch, regnum));
@


1.116
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Add comments on MAX_REGISTER_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Delete macro.
	(legacy_max_register_virtual_size): Delete declaration.
	* infcmd.c (default_print_registers_info): Use MAX_REGISTER_SIZE.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.
	* tracepoint.c (memrange_sortmerge): Ditto.
	* sparc-tdep.c (sparc_print_registers): Ditto.
	* regcache.c (legacy_max_register_virtual_size): Delete function.
@
text
@d980 4
a983 3
d10v_push_dummy_call (struct gdbarch *gdbarch, struct regcache *regcache,
		      CORE_ADDR dummy_addr, int nargs, struct value **args,
		      CORE_ADDR sp, int struct_return, CORE_ADDR struct_addr)
d991 1
a991 1
     always at DUMMY_ADDR.  */
d993 1
a993 1
				  d10v_convert_iaddr_to_raw (dummy_addr));
@


1.115
log
@Index: gdb/ChangeLog
2003-05-07  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (remote_d10v_translate_xfer_address): Add
	"regcache".
	(d10v_print_registers_info): Update.
	(d10v_dmap_register, d10v_imap_register): Delete functions.
	(struct gdbarch_tdep): Add "regcache" parameter to "dmap_register"
	and "imap_register".
	(d10v_ts2_dmap_register, d10v_ts2_imap_register): Add "regcache".
	(d10v_ts3_dmap_register, d10v_ts3_imap_register): Add "regcache".
	* arch-utils.c (generic_remote_translate_xfer_address): Add
	"regcache" and "gdbarch" parameters.
	* gdbarch.sh (REMOTE_TRANSLATE_XFER_ADDRESS): Add "regcache"
	parameter.  Change class to multi-arch.
	* gdbarch.h, gdbarch.c: Re-generate.
	* remote.c (remote_xfer_memory): Use
	gdbarch_remote_translate_xfer_address.

Index: include/gdb/ChangeLog
2003-05-07  Andrew Cagney  <cagney@@redhat.com>

	* sim-d10v.h (sim_d10v_translate_addr): Add regcache parameter.
	(sim_d10v_translate_imap_addr): Add regcache parameter.
	(sim_d10v_translate_dmap_addr): Ditto.

Index: sim/d10v/ChangeLog
2003-05-07  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_d10v_translate_addr): Add "regcache" parameter.
	(sim_d10v_translate_imap_addr): Ditto.
	(sim_d10v_translate_dmap_addr): Ditto.
	(xfer_mem): Pass NULL regcache to sim_d10v_translate_addr.
	(dmem_addr): Pass NULL regcache to sim_d10v_translate_dmap_addr.
	(dmap_register, imap_register): Add "regcache" parameter.
	(imem_addr): Pass NULL regcache to sim_d10v_translate_imap_addr.
	(sim_fetch_register): Pass NULL regcache to imap_register and
	dmap_register.
@
text
@d868 1
a868 1
    char *num = alloca (max_register_size (gdbarch));
@


1.114
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PUSH_DUMMY_CODE): New architecture method, add
	comments noteing that it replaces the old FIX_CALL_DUMMY code.
	* gdbarch.h, gdbarch.c: Re-generate.
	* d10v-tdep.c (d10v_push_dummy_code): New function.
	(d10v_gdbarch_init): Set push_dummy_code.
	* infcall.c (legacy_push_dummy_code): New function.
	(generic_push_dummy_code): New function.
	(push_dummy_code): New function.
	(call_function_by_hand): Call push_dummy_code.  Pass bp_addr,
	instead of dummy_addr, to push_dummy_call.  Move call to
	generic_save_call_dummy_addr to outside of CALL_DUMMY_LOCATION
	switch.
	* sparc-tdep.c (sparc_gdbarch_init): Mention push_dummy_code.

2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Document
	push_dummy_code.  Add cross references.
@
text
@d54 2
a55 2
    unsigned long (*dmap_register) (int nr);
    unsigned long (*imap_register) (int nr);
d239 1
a239 1
d10v_ts2_dmap_register (int reg_nr)
d247 5
a251 1
      return read_register (TS2_DMAP_REGNUM);
d258 1
a258 13
d10v_ts3_dmap_register (int reg_nr)
{
  return read_register (TS3_DMAP0_REGNUM + reg_nr);
}

static unsigned long
d10v_dmap_register (int reg_nr)
{
  return gdbarch_tdep (current_gdbarch)->dmap_register (reg_nr);
}

static unsigned long
d10v_ts2_imap_register (int reg_nr)
d260 3
a262 1
  return read_register (TS2_IMAP0_REGNUM + reg_nr);
d266 1
a266 1
d10v_ts3_imap_register (int reg_nr)
d268 3
a270 1
  return read_register (TS3_IMAP0_REGNUM + reg_nr);
d274 1
a274 1
d10v_imap_register (int reg_nr)
d276 3
a278 1
  return gdbarch_tdep (current_gdbarch)->imap_register (reg_nr);
d805 1
d849 2
a850 1
	fprintf_filtered (file, "IMAP%d %04lx", a, d10v_imap_register (a));
d854 2
a855 1
      fprintf_filtered (file, "    DMAP %04lx\n", d10v_dmap_register (2));
d860 2
a861 1
	    fprintf_filtered (file, "    DMAP%d %04lx", a, d10v_dmap_register (a));
d1105 3
a1107 1
remote_d10v_translate_xfer_address (CORE_ADDR memaddr, int nr_bytes,
d1110 1
d1113 2
a1114 4
  out_len = sim_d10v_translate_addr (memaddr, nr_bytes,
				     &out_addr,
				     d10v_dmap_register,
				     d10v_imap_register);
@


1.113
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* disasm.h (print_insn): Declare.
	* disasm.c (init_gdb_disassemble_info): New function.
	(gdb_disassembly): Call init_gdb_disassemble_info.
	(gdb_print_insn): New function.
	* v850-tdep.c (v850_scan_prologue): Call gdb_print_insn, instead
	of TARGET_PRINT_INSN.  Send debug info to "gdb_stdlog".
	* mcore-tdep.c: Include "disasm.h"
	(mcore_dump_insn): Call gdb_print_insn, instead of TARGET_PRINT_INSN.
	* d10v-tdep.c: Include "disasm.h".
	(display_trace): Call gdb_print_insn, instead of print_insn.
	(print_insn): Delete function.
	* printcmd.c: Include "disasm.h".
	(print_insn): Delete function.
	(print_formatted): Call gdb_print_insn, instead of print_insn.
	* Makefile.in (printcmd.o): Update dependencies.
	(mcore-tdep.o, d10v-tdep.o): Ditto.

2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* tuiDisassem.c (tui_disassemble): Call gdb_print_insn, instead of
	TARGET_PRINT_INSN.  Do not initialize a disassemble_info object.
@
text
@d959 19
d1639 1
@


1.112
log
@2003-05-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (REGISTER_SIZE, REGISTER_BYTES): Make optional.
	* gdbarch.h, gdbarch.c: Re-generate.
	* d10v-tdep.c (d10v_gdbarch_init): Do not set register_size,
	register_virtual_size, pc_regnum, or register_bytes.
	(D10V_PC_REGNUM): Rename _PC_REGNUM.
	(d10v_register_type): Use D10V_PC_REGNUM.
	(d10v_print_registers_info, d10v_read_pc): Ditto.
	(d10v_write_pc, d10v_eva_prepare_to_trace): Ditto.
	(d10v_unwind_pc, d10v_frame_prev_register): Ditto.
@
text
@d46 1
d1365 1
a1365 2
	  next_address += TARGET_PRINT_INSN (next_address,
					     &deprecated_tm_print_insn_info);
@


1.111
log
@2003-05-01  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_frame_align): Replace d10v_stack_align.
	(d10v_gdbarch_init): Set frame_align instead of stack_align.
@
text
@d76 1
a76 1
    _PC_REGNUM = 18,
d325 1
a325 1
  if (reg_nr == PC_REGNUM)
d814 1
a814 1
    frame_read_unsigned_register (frame, PC_REGNUM, &pc);
d898 1
a898 1
  pc = (int) read_register (PC_REGNUM);
d911 1
a911 1
  write_register (PC_REGNUM, d10v_convert_iaddr_to_raw (val));
d1210 1
a1210 1
  last_pc = read_register (PC_REGNUM);
d1376 1
a1376 1
  frame_unwind_unsigned_register (next_frame, PC_REGNUM, &pc);
d1480 1
a1480 1
  if (regnum == PC_REGNUM)
a1584 1
  set_gdbarch_pc_regnum (gdbarch, 18);
a1585 3
  set_gdbarch_register_size (gdbarch, 2);
  set_gdbarch_register_bytes (gdbarch, (d10v_num_regs - 2) * 2 + 16);
  set_gdbarch_register_virtual_size (gdbarch, generic_register_size);
@


1.110
log
@2003-04-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_tm_print_insn_info): Rename
	"tm_print_insn_info".
	(TARGET_PRINT_INSN_INFO): Delete macro.
	(dis_asm_read_memory): Delete function declaration.
	(dis_asm_memory_error, dis_asm_print_address): Ditto.
	(tm_print_insn_info): Delete variable definition.
	(_initialize_gdbarch): Do not initialize "tm_print_insn_info".
	* gdbarch.h, gdbarch.c: Re-generate.
	* d10v-tdep.c (display_trace): Replace "tm_print_insn_info" with
	"deprecated_tm_print_insn_info".
	* mcore-tdep.c (mcore_dump_insn): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* sparc-tdep.c (_initialize_sparc_tdep): Ditto.
	* v850-tdep.c (v850_scan_prologue, v850_gdbarch_init): Ditto.
	* ia64-tdep.c (_initialize_ia64_tdep): Ditto.
	* printcmd.c (print_insn): Use "deprecated_tm_print_insn_info"
	instead of TARGET_PRINT_INSN_INFO, add comment.
	* s390-tdep.c (s390_get_frame_info): Instead of
	"dis_asm_read_memory", use "deprecated_tm_print_insn_info".
	(s390_check_function_end, s390_is_sigreturn): Ditto.
	* corefile.c (dis_asm_read_memory): Move to "disasm.c".
	(dis_asm_memory_error, dis_asm_print_address): Ditto.
	* disasm.c: Include "gdbcore.h".
	(_initialize_disasm): New function, initialize
	"deprecated_tm_print_insn_info".
	(deprecated_tm_print_insn_info): New variable.
	(dis_asm_read_memory): Moved from "corefile.c", made static.
	(dis_asm_print_address, dis_asm_memory_error): Ditto.
	* Makefile.in (disasm.o): Update dependencies.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d110 1
a110 1
d10v_stack_align (CORE_ADDR len)
d112 3
a114 1
  return (len + 1) & ~1;
d1641 1
a1641 1
  set_gdbarch_stack_align (gdbarch, d10v_stack_align);
@


1.109
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d1363 1
a1363 1
					     &tm_print_insn_info);
@


1.108
log
@2003-04-25  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (print_insn): Delete function.
	(display_trace): Use TARGET_PRINT_INSN.
	(_initialize_d10v_tdep): Do not set tm_print_insn.
	(d10v_gdbarch_init): Set print_insn.
@
text
@a104 2
static CORE_ADDR d10v_read_fp (void);

a918 6
static CORE_ADDR
d10v_read_fp (void)
{
  return (d10v_make_daddr (read_register (D10V_FP_REGNUM)));
}

a1578 1
  set_gdbarch_read_fp (gdbarch, d10v_read_fp);
@


1.107
log
@2003-04-25  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_extract_return_value): Delete call to printf.
	(_initialize_d10v_tdep): Use add_setshow_boolean_cmd.
	(d10v_frame_unwind_cache): Use FRAME_OBSTACK_CALLOC.
	(NR_DMAP_REGS, A0_REGNUM): Delete, replaced by ...
	(nr_dmap_regs, a0_regnum): ... new functions.
	(d10v_print_registers_info): Use a0_regnum, use register_size.
	(d10v_register_byte): Delete function.
	(d10v_register_raw_size): Delete function.
	(d10v_register_type): Use a0_regnum.
	(d10v_print_registers_info): Use a0_regnum.
	(D10V_SP_REGNUM): Rename _SP_REGNUM, replace it and SP_REGNUM.
	(d10v_gdbarch_init): Do not set register_byte or
	register_raw_size, use D10V_SP_REGNUM to set sp_regnum.
	(d10v_pointer_to_address): Use extract_unsigned_integer instead of
	extract_address.
	(trace_command): Use XCALLOC.
	(print_insn): Delete reference to tm_print_insn.
	(saved_regs_unwinder): Use store_unsigned_integer instead of
	store_address.
	* frame.h (FRAME_OBSTACK_CALLOC): Define
@
text
@a1209 13
/* Print the instruction at address MEMADDR in debugged memory,
   on STREAM.  Returns length of the instruction, in bytes.  */

static int
print_insn (CORE_ADDR memaddr, struct ui_file *stream)
{
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    tm_print_insn_info.endian = BFD_ENDIAN_BIG;
  else
    tm_print_insn_info.endian = BFD_ENDIAN_LITTLE;
  return TARGET_PRINT_INSN (memaddr, &tm_print_insn_info);
}

d1370 2
a1371 1
	  next_address = next_address + print_insn (next_address, gdb_stdout);
d1664 2
a1672 2

  tm_print_insn = print_insn_d10v;
@


1.106
log
@2003-04-10  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_frame_this_id): Set the code addr to the
	frame's function's address.  Simplify.
	(d10v_frame_unwind_cache): Check that the frame's function is
	non-zero.
@
text
@d74 1
a74 1
    _SP_REGNUM = 15,
d87 11
a97 2
#define NR_DMAP_REGS (gdbarch_tdep (current_gdbarch)->nr_dmap_regs)
#define A0_REGNUM (gdbarch_tdep (current_gdbarch)->a0_regnum)
a318 31
/* Index within `registers' of the first byte of the space for
   register REG_NR.  */

static int
d10v_register_byte (int reg_nr)
{
  if (reg_nr < A0_REGNUM)
    return (reg_nr * 2);
  else if (reg_nr < (A0_REGNUM + NR_A_REGS))
    return (A0_REGNUM * 2
	    + (reg_nr - A0_REGNUM) * 8);
  else
    return (A0_REGNUM * 2
	    + NR_A_REGS * 8
	    + (reg_nr - A0_REGNUM - NR_A_REGS) * 2);
}

/* Number of bytes of storage in the actual machine representation for
   register REG_NR.  */

static int
d10v_register_raw_size (int reg_nr)
{
  if (reg_nr < A0_REGNUM)
    return 2;
  else if (reg_nr < (A0_REGNUM + NR_A_REGS))
    return 8;
  else
    return 2;
}

d327 1
a327 1
  if (reg_nr == _SP_REGNUM || reg_nr == D10V_FP_REGNUM)
d329 2
a330 2
  else if (reg_nr >= A0_REGNUM
      && reg_nr < (A0_REGNUM + NR_A_REGS))
d396 1
a396 2
  CORE_ADDR addr = extract_address (buf, TYPE_LENGTH (type));

d682 1
a682 1
  info->saved_regs = frame_obstack_zalloc (SIZEOF_FRAME_SAVED_REGS);
d753 1
a753 1
  else if (info->saved_regs[SP_REGNUM])
d757 1
a757 1
      this_base = read_memory_unsigned_integer (info->saved_regs[SP_REGNUM], 
d759 1
a759 1
							       SP_REGNUM));
d766 1
a766 1
      frame_unwind_unsigned_register (next_frame, SP_REGNUM, &this_base);
d795 1
a795 1
  /* The SP_REGNUM is special.  Instead of the address of the SP, the
d797 1
a797 1
  info->saved_regs[SP_REGNUM] = info->prev_sp;
d851 1
a851 1
    if (NR_DMAP_REGS == 1)
d856 1
a856 1
	for (a = 0; a < NR_DMAP_REGS; a++)
d868 1
a868 1
    for (a = A0_REGNUM; a < A0_REGNUM + NR_A_REGS; a++)
d872 2
a873 2
	frame_register_read (frame, a, num);
	for (i = 0; i < max_register_size (current_gdbarch); i++)
d918 1
a918 1
  return (d10v_make_daddr (read_register (SP_REGNUM)));
d1036 1
a1036 1
  regcache_cooked_write_unsigned (regcache, SP_REGNUM,
a1050 6
#if 0
  printf("RET: TYPE=%d len=%d r%d=0x%x\n", TYPE_CODE (type), 
	 TYPE_LENGTH (type), RET1_REGNUM - R0_REGNUM, 
	 (int) extract_unsigned_integer (regbuf + REGISTER_BYTE(RET1_REGNUM), 
					 register_size (current_gdbarch, RET1_REGNUM)));
#endif
d1169 1
a1169 1
    trace_data.counts = (short *) xmalloc (65536 * sizeof (short));
d1171 1
a1171 1
    trace_data.addrs = (CORE_ADDR *) xmalloc (65536 * sizeof (CORE_ADDR));
a1215 5
  /* If there's no disassembler, something is very wrong.  */
  if (tm_print_insn == NULL)
    internal_error (__FILE__, __LINE__,
		    "print_insn: no disassembler");

d1450 1
a1450 1
      if (regnum == SP_REGNUM)
d1458 3
a1460 2
	    store_address (bufferp, register_size (current_gdbarch, regnum),
			   this_saved_regs[regnum]);
d1549 1
a1549 1
  frame_unwind_unsigned_register (next_frame, SP_REGNUM, &base);
d1603 1
a1603 1
  set_gdbarch_sp_regnum (gdbarch, 15);
a1607 2
  set_gdbarch_register_byte (gdbarch, d10v_register_byte);
  set_gdbarch_register_raw_size (gdbarch, d10v_register_raw_size);
d1706 9
a1714 9
  add_show_from_set (add_set_cmd ("itracedisplay", no_class,
				  var_integer, (char *) &trace_display,
			     "Set automatic display of trace.\n", &setlist),
		     &showlist);
  add_show_from_set (add_set_cmd ("itracesource", no_class,
			   var_integer, (char *) &default_trace_show_source,
		      "Set display of source code with trace.\n", &setlist),
		     &showlist);

@


1.106.2.1
log
@Merge from mainline.
@
text
@a45 1
#include "disasm.h"
d74 1
a74 1
    D10V_SP_REGNUM = 15,
d76 1
a76 1
    D10V_PC_REGNUM = 18,
d87 2
a88 11
int
nr_dmap_regs (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->nr_dmap_regs;
}

int
a0_regnum (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->a0_regnum;
}
d96 2
d103 1
a103 1
d10v_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
d105 1
a105 3
  /* Align to the size of an instruction (so that they can safely be
     pushed onto the stack.  */
  return sp & ~3;
d310 31
d347 1
a347 1
  if (reg_nr == D10V_PC_REGNUM)
d349 1
a349 1
  if (reg_nr == D10V_SP_REGNUM || reg_nr == D10V_FP_REGNUM)
d351 2
a352 2
  else if (reg_nr >= a0_regnum (gdbarch)
	   && reg_nr < (a0_regnum (gdbarch) + NR_A_REGS))
d418 2
a419 1
  CORE_ADDR addr = extract_unsigned_integer (buf, TYPE_LENGTH (type));
d705 1
a705 1
  info->saved_regs = FRAME_OBSTACK_CALLOC (NUM_REGS, CORE_ADDR);
d776 1
a776 1
  else if (info->saved_regs[D10V_SP_REGNUM])
d780 1
a780 1
      this_base = read_memory_unsigned_integer (info->saved_regs[D10V_SP_REGNUM], 
d782 1
a782 1
							       D10V_SP_REGNUM));
d789 1
a789 1
      frame_unwind_unsigned_register (next_frame, D10V_SP_REGNUM, &this_base);
d818 1
a818 1
  /* The D10V_SP_REGNUM is special.  Instead of the address of the SP, the
d820 1
a820 1
  info->saved_regs[D10V_SP_REGNUM] = info->prev_sp;
d837 1
a837 1
    frame_read_unsigned_register (frame, D10V_PC_REGNUM, &pc);
d874 1
a874 1
    if (nr_dmap_regs (gdbarch) == 1)
d879 1
a879 1
	for (a = 0; a < nr_dmap_regs (gdbarch); a++)
d891 1
a891 1
    for (a = a0_regnum (gdbarch); a < a0_regnum (gdbarch) + NR_A_REGS; a++)
d895 2
a896 2
	frame_read_register (frame, a, num);
	for (i = 0; i < register_size (current_gdbarch, a); i++)
d921 1
a921 1
  pc = (int) read_register (D10V_PC_REGNUM);
d934 1
a934 1
  write_register (D10V_PC_REGNUM, d10v_convert_iaddr_to_raw (val));
d941 7
a947 1
  return (d10v_make_daddr (read_register (D10V_SP_REGNUM)));
a986 19
d10v_push_dummy_code (struct gdbarch *gdbarch,
		      CORE_ADDR sp, CORE_ADDR funaddr, int using_gcc,
		      struct value **args, int nargs,
		      struct type *value_type,
		      CORE_ADDR *real_pc, CORE_ADDR *bp_addr)
{
  /* Allocate space sufficient for a breakpoint.  */
  sp = (sp - 4) & ~3;
  /* Store the address of that breakpoint taking care to first convert
     it into a code (IADDR) address from a stack (DADDR) address.
     This of course assumes that the two virtual addresses map onto
     the same real address.  */
  (*bp_addr) = d10v_make_iaddr (d10v_convert_iaddr_to_raw (sp));
  /* d10v always starts the call at the callee's entry point.  */
  (*real_pc) = funaddr;
  return sp;
}

static CORE_ADDR
d1059 1
a1059 1
  regcache_cooked_write_unsigned (regcache, D10V_SP_REGNUM,
d1074 6
d1198 1
a1198 1
    trace_data.counts = XCALLOC (65536, short);
d1200 1
a1200 1
    trace_data.addrs = XCALLOC (65536, CORE_ADDR);
d1239 18
d1263 1
a1263 1
  last_pc = read_register (D10V_PC_REGNUM);
d1417 1
a1417 1
	  next_address += gdb_print_insn (next_address, gdb_stdout);
d1428 1
a1428 1
  frame_unwind_unsigned_register (next_frame, D10V_PC_REGNUM, &pc);
d1484 1
a1484 1
      if (regnum == D10V_SP_REGNUM)
d1492 2
a1493 3
	    store_unsigned_integer (bufferp,
				    register_size (current_gdbarch, regnum),
				    this_saved_regs[regnum]);
d1531 1
a1531 1
  if (regnum == D10V_PC_REGNUM)
d1582 1
a1582 1
  frame_unwind_unsigned_register (next_frame, D10V_SP_REGNUM, &base);
d1632 1
d1636 2
a1637 1
  set_gdbarch_sp_regnum (gdbarch, D10V_SP_REGNUM);
d1639 5
a1677 1
  set_gdbarch_push_dummy_code (gdbarch, d10v_push_dummy_code);
d1695 1
a1695 1
  set_gdbarch_frame_align (gdbarch, d10v_frame_align);
a1710 2
  set_gdbarch_print_insn (gdbarch, print_insn_d10v);

d1719 2
d1741 9
a1749 9
  add_setshow_boolean_cmd ("itracedisplay", no_class, &trace_display,
			   "Set automatic display of trace.\n",
			   "Show automatic display of trace.\n",
			   NULL, NULL, &setlist, &showlist);
  add_setshow_boolean_cmd ("itracesource", no_class,
			   &default_trace_show_source,
			   "Set display of source code with trace.\n",
			   "Show display of source code with trace.\n",
			   NULL, NULL, &setlist, &showlist);
@


1.106.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d54 2
a55 2
    unsigned long (*dmap_register) (void *regcache, int nr);
    unsigned long (*imap_register) (void *regcache, int nr);
d239 1
a239 1
d10v_ts2_dmap_register (void *regcache, int reg_nr)
d247 1
a247 5
      {
	ULONGEST reg;
	regcache_cooked_read_unsigned (regcache, TS2_DMAP_REGNUM, &reg);
	return reg;
      }
d254 13
a266 1
d10v_ts3_dmap_register (void *regcache, int reg_nr)
d268 1
a268 3
  ULONGEST reg;
  regcache_cooked_read_unsigned (regcache, TS3_DMAP0_REGNUM + reg_nr, &reg);
  return reg;
d272 1
a272 1
d10v_ts2_imap_register (void *regcache, int reg_nr)
d274 1
a274 3
  ULONGEST reg;
  regcache_cooked_read_unsigned (regcache, TS2_IMAP0_REGNUM + reg_nr, &reg);
  return reg;
d278 1
a278 1
d10v_ts3_imap_register (void *regcache, int reg_nr)
d280 1
a280 3
  ULONGEST reg;
  regcache_cooked_read_unsigned (regcache, TS3_IMAP0_REGNUM + reg_nr, &reg);
  return reg;
a806 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d850 1
a850 2
	fprintf_filtered (file, "IMAP%d %04lx", a,
			  tdep->imap_register (current_regcache, a));
d854 1
a854 2
      fprintf_filtered (file, "    DMAP %04lx\n",
			tdep->dmap_register (current_regcache, 2));
d859 1
a859 2
	    fprintf_filtered (file, "    DMAP%d %04lx", a,
			      tdep->dmap_register (current_regcache, a));
d866 1
a866 1
    char num[MAX_REGISTER_SIZE];
d1103 1
a1103 3
remote_d10v_translate_xfer_address (struct gdbarch *gdbarch,
				    struct regcache *regcache,
				    CORE_ADDR memaddr, int nr_bytes,
a1105 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1108 4
a1111 2
  out_len = sim_d10v_translate_addr (memaddr, nr_bytes, &out_addr, regcache,
				     tdep->dmap_register, tdep->imap_register);
@


1.105
log
@2003-04-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (SAVED_PC_AFTER_CALL): Add a predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* d10v-tdep.c (d10v_saved_pc_after_call): Delete function.
	(d10v_gdbarch_init): Do not set saved_pc_after_call.
	* infrun.c (step_over_function): Call SAVED_PC_AFTER_CALL_P
	conditionally, use frame_pc_unwind as an alternative.  Add
	comments.
	* arch-utils.c (init_frame_pc_default): Only call
	SAVED_PC_AFTER_CALL when available.
@
text
@d713 1
a713 1
       pc < frame_pc_unwind (next_frame);
d1443 2
a1444 1
  CORE_ADDR pc;
d1446 2
a1447 2
  /* The PC is easy.  */
  pc = frame_pc_unwind (next_frame);
d1451 1
a1451 1
  if (pc == IMEM_START || pc <= IMEM_START || inside_entry_file (pc))
d1461 2
d1469 1
a1469 2
      && get_frame_pc (next_frame) == pc
      && get_frame_base (next_frame) == base)
d1472 1
a1472 1
  (*this_id) = frame_id_build (base, pc);
@


1.104
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_func_unwind, get_frame_func): New functions.
	* frame.h (get_frame_func, frame_func_unwind): Declare.
	(struct frame_info): Add field "prev_func" for caching the
	previous frame's function address.
	* arm-tdep.c (arm_frameless_function_invocation): Combine
	get_pc_function_start and get_frame_pc into get_frame_func.
	* sh-tdep.c (sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	* s390-tdep.c (s390_function_start): Ditto.
	* rs6000-tdep.c (rs6000_pop_frame): Ditto.
	(rs6000_frameless_function_invocation): Ditto.
	(rs6000_frame_saved_pc): Ditto.
	* m68k-tdep.c (m68k_frame_init_saved_regs): Ditto.
	* ia64-tdep.c (ia64_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frameless_signal_p): Ditto.
	(i386_frame_init_saved_regs): Ditto.
	* hppa-tdep.c (hppa_frame_find_saved_regs): Ditto.
	* d10v-tdep.c (d10v_frame_unwind_cache): Combine
	get_pc_function_start and frame_pc_unwind into frame_func_unwind.
	* cris-tdep.c (cris_frame_init_saved_regs): Ditto.
	* blockframe.c (frameless_look_for_prologue): Ditto.
@
text
@a490 11
/* Immediately after a function call, return the saved pc.  We can't
   use frame->return_pc beause that is determined by reading R13 off
   the stack and that may not be written yet. */

static CORE_ADDR
d10v_saved_pc_after_call (struct frame_info *frame)
{
  return ((read_register (LR_REGNUM) << 2)
	  | IMEM_START);
}

a1691 1
  set_gdbarch_saved_pc_after_call (gdbarch, d10v_saved_pc_after_call);
@


1.103
log
@2003-04-04  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame): Do not call frame_type_from_pc.  Set
	the frame's type from the unwinder.
	(get_frame_type): Map UNKNOWN_FRAME onto NORMAL_FRAME.
	(create_new_frame, legacy_get_prev_frame): When the unwinder's
	type isn't UNKNOWN_FRAME, initalize "type" from the unwinder.
	(get_frame_base_address): Use get_frame_type.
	(get_frame_locals_address, get_frame_args_address): Ditto.
	(legacy_saved_regs_unwinder): Set the type to UNKNOWN_TYPE.
	* frame.h (enum frame_type): Add UNKNOWN_FRAME.
	(struct frame_info): Add comment explaining why the frame contains
	a "type" field.
	* dummy-frame.c (dummy_frame_unwind): Set the type to DUMMY_FRAME.
	* d10v-tdep.c (d10v_frame_unwind): Set the type to NORMAL_FRAME.
	* sentinel-frame.c (sentinel_frame_unwinder): Set the type to
	NORMAL_FRAME.
	* frame-unwind.h: Include "frame.h".
	(struct frame_unwind): Add "type" field.
	* Makefile.in (frame_unwind_h): Add $(frame_h).
@
text
@d723 1
a723 1
  for (pc = get_pc_function_start (frame_pc_unwind (next_frame));
@


1.102
log
@2003-04-04  Andrew Cagney  <cagney@@redhat.com>

	* x86-64-tdep.c (x86_64_unwind_dummy_id): Use frame_id_build.
	* dummy-frame.c (dummy_frame_this_id): Use frame_id_build.
	* d10v-tdep.c (d10v_frame_this_id): Use get_frame_pc and
	get_frame_base.
	(d10v_unwind_dummy_id): Use frame_id_build.
	* frame.c (find_frame_sal): Use get_frame_pc.
	(create_new_frame): Use deprecated_update_frame_pc_hack and
	deprecated_update_frame_base_hack.
	(create_sentinel_frame): Add comment about ->pc going away.
	(get_prev_frame): Add comment about ->pc going away.
	(legacy_get_prev_frame): Use get_frame_base, get_frame_pc,
	frame_id_build, deprecated_update_frame_pc_hack and
	deprecated_update_frame_base_hack.
	(select_frame): Use get_frame_pc.
	(legacy_saved_regs_this_id): Use frame_id_build.
@
text
@d1556 1
@


1.101
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (d10v-tdep.o): Update dependencies.
	* d10v-tdep.c: Include "frame-base.h".
	(d10v_frame_unwind): Make constant.
	(d10v_frame_base_address): New function.
	(d10v_frame_base): New variable.
	(d10v_gdbarch_init): Set frame_base default.
	(struct d10v_unwind_cache): Add the field "prev_sp".  Update
	comment for base.
	(d10v_frame_unwind_cache): Set and use "prev_sp".
	(d10v_frame_this_id): Use the previous frame's inner most stack
	address and this frame's func address for the frame ID.  Use
	frame_id_build.  Don't analyze beyond the current instruction.
@
text
@d1477 2
a1478 2
      && get_frame_id (next_frame).pc == pc
      && get_frame_id (next_frame).base == base)
a1589 2
  struct frame_id id;
  id.pc = frame_pc_unwind (next_frame);
d1591 1
a1591 2
  id.base = d10v_make_daddr (base);
  return id;
@


1.101.2.1
log
@2003-04-03  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_id_eq): Update.  Compare function addresses.
	(get_frame_func): New function.
	(frame_func_unwind): New function.
	(legacy_get_prev_frame): Move linking of prev to next to the start
	of the function.
	(frame_id_p): Update.
	(get_frame_id): Return the frame's "id".  Do not set "frame".
	(frame_id_build): Update.
	(frame_id_inner): Update.
	(create_sentinel_frame): Do not set the "pc".
	(select_frame): Use get_frame_pc.
	(legacy_saved_regs_this_id): Use frame_id_build.
	(create_new_frame): Set the frame's ID.  Store the PC in the
	sentinel frame's PC unwind cache.
	(legacy_get_prev_frame): Do not set "pc" or "frame".  Instead use
	frame_pc_unwind, frame_id_build, deprecated_update_frame_pc_hack,
	and deprecated_update_frame_base_hack.
	(get_prev_frame): Do not set "pc" or "frame", instead use
	frame_pc_unwind.
	(get_frame_pc): Use frame_pc_unwind.
	(find_frame_sal): Use get_frame_pc.
	(get_frame_base): Return the frame ID's stack address.
	(deprecated_update_frame_base_hack): Set the frame ID's stack
	address.
	(frame_id_eq, frame_id_p, frame_id_inner, get_frame_id): Add debug
	print statements.

	* d10v-tdep.c (d10v_frame_unwind_cache): Use frame_func_unwind.
	(d10v_frame_this_id): Get the frame's function.
	(d10v_frame_this_id): Use frame_id_eq.
	(d10v_unwind_dummy_id): Use frame_id_build.

	* stack.c (print_frame_info): Use get_frame_pc.

	* dummy-frame.c (dummy_frame_this_id): Use frame_id_build.  Update
	parameter to find_dummy_frame.

	* breakpoint.c (print_one_breakpoint): Update.

	* frame.h (struct frame_id): Rename "base" to "stack_addr",
	replace "pc" with "func_addr".
	(frame_id_build): Update parameter names and comment.
	(struct frame_info): Delete "frame" and "pc" fields.
	(frame_func_unwind): Declare.
	(get_frame_func): Declare.
	(struct frame_info): Add field "func".
@
text
@d723 2
a724 2
  for (pc = frame_func_unwind (next_frame);
       pc > 0 && pc < frame_pc_unwind (next_frame);
d1456 2
a1457 2
  /* The PC/FUNC is easy.  */
  pc = frame_func_unwind (next_frame);
d1477 2
a1478 2
      && frame_id_eq (get_frame_id (next_frame),
		      frame_id_build (base, pc)))
d1591 1
d1593 2
a1594 1
  return frame_id_build (d10v_make_daddr (base), frame_pc_unwind (next_frame));
@


1.101.2.2
log
@Merge with mainline.
@
text
@d491 11
a1555 1
  NORMAL_FRAME,
d1590 1
d1703 1
@


1.100
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_START_OFFSET): Default to zero.
	CALL_DUMMY_LENGTH): Ditto.
	* gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_START_OFFSET): Delete macro.
	(CALL_DUMMY_LENGTH): Delete macro.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set above when zero.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@d28 1
d602 4
a605 1
  /* The frame's base.  Used when constructing a frame ID.  */
a721 2
  pc = get_pc_function_start (frame_pc_unwind (next_frame));

d723 3
a725 1
  while (1)
a771 1
      pc += 4;
d805 1
a805 1
  prev_sp = d10v_make_daddr (prev_sp);
d812 1
a812 1
	info->saved_regs[i] = (prev_sp + info->saved_regs[i]);
d831 1
a831 1
  info->saved_regs[SP_REGNUM] = prev_sp;
a1455 3
  /* Start with a NULL frame ID.  */
  (*this_id) = null_frame_id;

d1467 1
a1467 1
  base = info->base;
d1481 1
a1481 2
  this_id->base = base;
  this_id->pc = pc;
d1555 1
a1555 2

static struct frame_unwind d10v_frame_unwind = {
d1566 15
d1714 1
@


1.99
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_BREAKPOINT_OFFSET): Default to zero.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sp64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* config/pa/tm-hppa64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* inferior.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET): Delete.
	* infcmd.c (run_stack_dummy): Simplify assuming
	CALL_DUMMY_BREAKPOINT_OFFSET_P.
	* infrun.c (handle_inferior_event): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set
	call_dummy_breakpoint_offset or call_dummy_breakpoint_offset_p.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@a1674 3
  set_gdbarch_call_dummy_length (gdbarch, 0);
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);

@


1.98
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FIX_CALL_DUMMY): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Regenerate.
	* inferior.h (FIX_CALL_DUMMY): Delete macro.
	* valops.c (hand_function_call): Only call FIX_CALL_DUMMY when
	available.
	* frame.h (generic_fix_call_dummy): Delete declaration.
	* dummy-frame.h: Update comment.
	* dummy-frame.c (generic_fix_call_dummy): Delete function.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	fix_call_dummy.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@a1675 2
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
@


1.97
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Include "symfile.h".
	(CALL_DUMMY_ADDRESS): Default to entry_point_address.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_ADDRESS): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_address, the default is at entry_point_address.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@a1678 1
  set_gdbarch_fix_call_dummy (gdbarch, generic_fix_call_dummy);
@


1.96
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_P): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* dummy-frame.c (dummy_frame_this_id): Update comments.
	* rs6000-tdep.c (rs6000_extract_struct_value_address): Ditto.
	* frame.c (legacy_get_prev_frame): Ditto.
	* valops.c (call_function_by_hand): Delete function.
	(hand_function_call): Rename to call_function_by_hand

2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to CALL_DUMMY_P.
@
text
@a1675 1
  set_gdbarch_call_dummy_address (gdbarch, entry_point_address);
@


1.95
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c: Replace _FP_REGNUM and FP_REGNUM with
	D10V_FP_REGNUM.
	(d10v_gdbarch_init): Do not set fp_regnum.
@
text
@a1679 1
  set_gdbarch_call_dummy_p (gdbarch, 1);
@


1.94
log
@2003-03-29  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_gdbarch_init): Do not set call_dummy_words or
	sizeof_call_dummy_words.
	* gdbarch.sh (CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS): Always
	define.
	* gdbarch.h: Regenerate.
@
text
@d71 1
a71 1
    _FP_REGNUM = 11,
d348 1
a348 1
  if (reg_nr == _SP_REGNUM || reg_nr == _FP_REGNUM)
d779 1
a779 1
      frame_unwind_unsigned_register (next_frame, FP_REGNUM, &this_base);
d955 1
a955 1
  return (d10v_make_daddr (read_register (FP_REGNUM)));
a1634 1
  set_gdbarch_fp_regnum (gdbarch, 11);
@


1.93
log
@2003-03-28  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (d10v-tdep.o): Update dependencies.
	* remote.h (target_resume_hook, target_wait_loop_hook): Declare.
	* d10v-tdep.c: Include "remote.h".
	(target_resume_hook): Delete extern declaration.
	(target_wait_loop_hook): Ditto.
	(tdisassemble_command): Eliminate assignment in "if" conditional.
	(d10v_ts2_register_sim_regno): Eliminate call to
	legacy_register_sim_regno.
	(d10v_ts3_register_sim_regno): Ditto.
@
text
@a1588 2
  static LONGEST d10v_call_dummy_words[] =
  {0};
a1680 2
  set_gdbarch_call_dummy_words (gdbarch, d10v_call_dummy_words);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, sizeof (d10v_call_dummy_words));
@


1.92
log
@2003-03-27  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_gdbarch_init): Set push_dummy_call instead of
	push_arguments.  Don't set push_return_address or write_sp.
	(d10v_push_dummy_call): Replace d10v_push_arguments.
	(d10v_push_return_address, d10v_write_sp): Delete function,
	handled by push_dummy_call.
@
text
@d41 1
a41 1

d279 2
a280 2
  if (legacy_register_sim_regno (nr) < 0)
    return legacy_register_sim_regno (nr);
d295 2
a296 2
  if (legacy_register_sim_regno (nr) < 0)
    return legacy_register_sim_regno (nr);
a1341 1
  char *space_index;
a1347 5
  else if (!(space_index = (char *) strchr (arg, ' ')))
    {
      low = parse_and_eval_address (arg);
      high = low + 5;
    }
d1349 16
a1364 7
    {
      /* Two arguments.  */
      *space_index = '\0';
      low = parse_and_eval_address (arg);
      high = parse_and_eval_address (space_index + 1);
      if (high < low)
	high = low;
a1723 4


extern void (*target_resume_hook) (void);
extern void (*target_wait_loop_hook) (void);
@


1.91
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_ARGUMENTS): Rename PUSH_ARGUMENTS.
	(push_dummy_call): New pure multi-arch replacement with gdbarch,
	regcache and dummy_addr parameters.
	* gdbarch.h, gdbarch.c: Re-generate.
	* valops.c (hand_function_call): Use gdbarch_push_dummy_call when
	available; assume it will handle stack alignment and return
	address issues.  Fall back to DEPRECATED_PUSH_ARGUMENTS and
	legacy_push_arguments.
	(legacy_push_arguments): Rename default_push_arguments.
	* value.h (legacy_push_arguments): Rename default_push_arguments.
	* i386-tdep.c (i386_push_arguments): Call legacy_push_arguments.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/i386/tm-symmetry.h: Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* arm-linux-tdep.c (arm_linux_init_abi): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	PUSH_ARGUMENTS with push_dummy_call, add gdbarch, regcache and
	dummy_addr parameters.
@
text
@a951 6
static void
d10v_write_sp (CORE_ADDR val)
{
  write_register (SP_REGNUM, d10v_convert_daddr_to_raw (val));
}

a957 12
/* Function: push_return_address (pc)
   Set up the return address for the inferior function call.
   Needed for targets where we don't actually execute a JSR/BSR instruction */

static CORE_ADDR
d10v_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
{
  write_register (LR_REGNUM, d10v_convert_iaddr_to_raw (CALL_DUMMY_ADDRESS ()));
  return sp;
}


d995 3
a997 2
d10v_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		     int struct_return, CORE_ADDR struct_addr)
d1004 5
d1014 1
a1014 1
      write_register (regnum, struct_addr);
d1032 1
a1032 1
	  write_register (regnum++, val);
d1043 1
a1043 1
	      write_register (regnum++, val);
d1048 1
a1048 1
	      write_register (regnum++, (val << 8));
d1066 4
a1630 1
  set_gdbarch_write_sp (gdbarch, d10v_write_sp);
d1686 1
a1686 3
  set_gdbarch_deprecated_push_arguments (gdbarch, d10v_push_arguments);
  set_gdbarch_push_return_address (gdbarch, d10v_push_return_address);

@


1.90
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_EXTRA_STACK_ALIGNMENT_NEEDED): Replace
	EXTRA_STACK_ALIGNMENT_NEEDED.  Default to 0 not 1.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h
	(DEPRECATED_EXTRA_STACK_ALIGNMENT_NEEDED): Define.
	* sparc-tdep.c (sparc_gdbarch_init): Set
	deprecated_extra_stack_alignment_needed.
	* config/pa/tm-hppa.h (EXTRA_STACK_ALIGNMENT_NEEDED): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not clear
	extra_stack_alignment_needed.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
@
text
@d1695 1
a1695 1
  set_gdbarch_push_arguments (gdbarch, d10v_push_arguments);
@


1.90.2.1
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	Add frame debug info addresses:
	* frame-base.c: New file.
	* frame-base.h: New file.
	* frame.h (struct frame_base): Add opaque declaration.
	(get_frame_base): Update comment.
	(get_frame_base_address): Declare.
	(get_frame_locals_address): Declare.
	(get_frame_args_address): Declare.
	(struct frame_info): Add "base" and "base_cache".  Update
	comments on the unwinder.
	* frame.c: Include "frame-base.h".
	(get_frame_locals_address): New function.
	(get_frame_base_address): New function.
	(get_frame_args_address): New function.
	* findvar.c (read_var_value): Use get_frame_locals_address.
	* stack.c (frame_info): Use get_frame_locals_address and
	get_frame_args_address.
	(FRAME_ARGS_ADDRESS_CORRECT): Delete conditionally defined macro,
	moved to "frame-base.c".
	* Makefile.in (frame_base_h): Define.
	(frame.o): Update dependencies.
	(d10v-tdep.o): Update dependencies.
	(frame-base.o): Add dependencies.
	(SFILES): Add frame-base.c.
	(COMMON_OBS): Add frame-base.o.
	* printcmd.c (print_frame_nameless_args): Ditto.
	* symtab.h (address_class): Update comments.
	* dwarf2loc.c (dwarf_expr_frame_base): Add note about
	get_frame_base_address.
	* dwarf2expr.c (execute_stack_op): Ditto.
	* d10v-tdep.c: Include "frame-base.h".
	(d10v_frame_unwind): Make constant.
	(d10v_frame_base_address): New function.
	(d10v_frame_base): New variable.
	(d10v_gdbarch_init): Set frame_base default.
@
text
@a27 1
#include "frame-base.h"
d1561 2
a1562 1
static const struct frame_unwind d10v_frame_unwind = {
a1572 15
static CORE_ADDR
d10v_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_cache);
  return info->base;
}

static const struct frame_base d10v_frame_base = {
  &d10v_frame_unwind,
  d10v_frame_base_address,
  d10v_frame_base_address,
  d10v_frame_base_address
};

a1721 1
  frame_base_set_default (gdbarch, &d10v_frame_base);
@


1.90.2.2
log
@Merge with mainline.
@
text
@d42 1
a42 1
#include "remote.h"
d280 2
a281 2
  /* Only makes sense to supply raw registers.  */
  gdb_assert (nr >= 0 && nr < NUM_REGS);
d296 2
a297 2
  /* Only makes sense to supply raw registers.  */
  gdb_assert (nr >= 0 && nr < NUM_REGS);
d953 6
d965 12
d1014 2
a1015 3
d10v_push_dummy_call (struct gdbarch *gdbarch, struct regcache *regcache,
		      CORE_ADDR dummy_addr, int nargs, struct value **args,
		      CORE_ADDR sp, int struct_return, CORE_ADDR struct_addr)
a1021 5
  /* Set the return address.  For the d10v, the return breakpoint is
     always at DUMMY_ADDR.  */
  regcache_cooked_write_unsigned (regcache, LR_REGNUM,
				  d10v_convert_iaddr_to_raw (dummy_addr));

d1027 1
a1027 1
      regcache_cooked_write_unsigned (regcache, regnum, struct_addr);
d1045 1
a1045 1
	  regcache_cooked_write_unsigned (regcache, regnum++, val);
d1056 1
a1056 1
	      regcache_cooked_write_unsigned (regcache, regnum++, val);
d1061 1
a1061 1
	      regcache_cooked_write_unsigned (regcache, regnum++, (val << 8));
a1078 4
  /* Finally, update the SP register.  */
  regcache_cooked_write_unsigned (regcache, SP_REGNUM,
				  d10v_convert_daddr_to_raw (sp));

d1351 1
d1358 5
d1364 7
a1370 16
    { 
      char *space_index = strchr (arg, ' ');
      if (space_index == NULL)
	{
	  low = parse_and_eval_address (arg);
	  high = low + 5;
	}
      else
	{
	  /* Two arguments.  */
	  *space_index = '\0';
	  low = parse_and_eval_address (arg);
	  high = parse_and_eval_address (space_index + 1);
	  if (high < low)
	    high = low;
	}
d1609 2
d1654 1
d1704 2
d1710 3
a1712 1
  set_gdbarch_push_dummy_call (gdbarch, d10v_push_dummy_call);
d1748 4
@


1.89
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STORE_STRUCT_RETURN): Replace
	STORE_STRUCT_RETURN.
	* gdbarch.h, gdbarch.c: Regenerate.
	* d10v-tdep.c (d10v_store_struct_return): Delete function.
	(d10v_push_arguments): Set the struct return register.
	(d10v_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@a1717 1
  set_gdbarch_extra_stack_alignment_needed (gdbarch, 0);
@


1.88
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_STACK_ADJUST_P): Delete.
	(DEPRECATED_CALL_DUMMY_STACK_ADJUST): Replace
	CALL_DUMMY_STACK_ADJUST with a predicate variable.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_stack_adjust_p.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sparc.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.  Do not set
	call_dummy_stack_adjust_p.
	* inferior.h (CALL_DUMMY_STACK_ADJUST_P): Delete macro.
	(CALL_DUMMY_STACK_ADJUST): Delete macro.
	* sparc-tdep.c (sparc32_push_arguments): Update.
	* valops.c (hand_function_call): Update.

2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	reference to CALL_DUMMY_STACK_ADJUST_P.  Rename
	CALL_DUMMY_STACK_ADJUST to DEPRECATED_CALL_DUMMY_STACK_ADJUST.
	Add reference to PUSH_ARGUMENTS.
@
text
@a439 12
/* Store the address of the place in which to copy the structure the
   subroutine will return.  This is called from call_function. 

   We store structs through a pointer passed in the first Argument
   register. */

static void
d10v_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  write_register (ARG1_REGNUM, (addr));
}

d1021 3
a1023 5
  /* If struct_return is true, then the struct return address will
     consume one argument-passing register.  No need to actually 
     write the value to the register -- that's done by 
     d10v_store_struct_return().  */

d1025 4
a1028 1
    regnum++;
a1697 1
  set_gdbarch_store_struct_return (gdbarch, d10v_store_struct_return);
@


1.87
log
@2003-03-17  Andrew Cagney  <cagney@@redhat.com>

	Fix frame off-by-one bug.
	* frame-unwind.h (frame_this_id_ftype): Replace
	frame_unwind_id_ftype.
	(frame_prev_register_ftype): Replace frame_unwind_reg_ftype.
	(struct frame_unwind): Replace "id" with "this_id".  Replace "reg"
	with "prev_register".
	* frame-unwind.c (frame_unwind_find_by_pc): Return
	legacy_saved_regs_unwind instead of trad_frame_unwind.  Update
	comment.
	* dummy-frame.c (cached_find_dummy_frame): Delete function.
	(dummy_frame_this_id): Replace dummy_frame_id_unwind.
	(dummy_frame_prev_register): Replace dummy_frame_register_unwind.
	(dummy_frame_unwind): Update.
	* sentinel-frame.c (sentinel_frame_prev_register): Replace
	sentinel_frame_register_unwind.
	(sentinel_frame_this_id): Replace sentinel_frame_id_unwind.
	(sentinel_frame_unwinder): Update.
	* frame.h (legacy_saved_regs_unwind): Replace trad_frame_unwind.
	(struct frame_info): Rename "unwind_cache" to "prologue_cache".
	* frame.c (create_sentinel_frame): Update. Initialize
	"prologue_cache" instead of "unwind_cache".
	(frame_register_unwind): Call this frame's prev_register with the
	next frame and this frame's prologue cache.
	(get_prev_frame): Simplify.  Always call prev frame's this_id with
	this frame and prev frame's prologue cache.  Document that this
	call is shifted one to the left when compared to the
	frame_register_unwind call.
	(legacy_saved_regs_prev_register): Replace
	frame_saved_regs_register_unwind.
	(legacy_saved_regs_this_id): Replace frame_saved_regs_id_unwind.
	(legacy_saved_regs_unwinder): Replace trad_frame_unwinder.
	(legacy_saved_regs_unwind): Replace trad_frame_unwind.
	* d10v-tdep.c (d10v_frame_this_id): Replace d10v_frame_id_unwind.
	(d10v_frame_unwind): Update.
	(d10v_frame_prev_register): Replace d10v_frame_register_unwind.
	(d10v_frame_unwind_cache): Replace this "fi" with "next_frame".
	(saved_regs_unwinder): Replace this "frame" with "next_frame", and
	"saved_regs" with "this_saved_regs".
@
text
@a1702 1
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
@


1.86
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	Eliminate the need for POP_FRAME.
	* frame.c (do_frame_unwind_register): New function.
	(frame_pop): When no POP_FRAME, pop the frame using register
	unwind and a scratch regcache.
	(frame_saved_regs_pop): Delete function.
	(trad_frame_unwinder): Update.
	* d10v-tdep.c (d10v_frame_pop): Delete function.
	(d10v_frame_unwind): Update.
	* sentinel-frame.c (sentinel_frame_pop): Delete function.
	(sentinel_frame_unwinder): Update.
	* dummy-frame.c (dummy_frame_pop): Delete function.
	(dummy_frame_unwind): Update.
	* frame-unwind.h (frame_unwind_pop_ftype): Delete definition.
	(struct frame_unwind): Update.
@
text
@d708 2
a709 2
d10v_frame_unwind_cache (struct frame_info *fi,
			 void **cache)
d719 2
a720 2
  if ((*cache))
    return (*cache);
d723 1
a723 1
  (*cache) = info;
d730 1
a730 1
  pc = get_pc_function_start (get_frame_pc (fi));
d791 1
a791 1
      frame_read_unsigned_register (fi, FP_REGNUM, &this_base);
d809 1
a809 1
      frame_read_unsigned_register (fi, SP_REGNUM, &this_base);
d834 1
a834 1
      frame_read_unsigned_register (fi, LR_REGNUM, &return_pc);
d1460 8
a1467 6
d10v_frame_id_unwind (struct frame_info *frame,
		      void **cache,
		      struct frame_id *id)
{
  struct d10v_unwind_cache *info = d10v_frame_unwind_cache (frame, cache);
  CORE_ADDR addr;
d1470 1
a1470 1
  (*id) = null_frame_id;
d1472 2
a1473 8
  if (info->return_pc == IMEM_START
      || info->return_pc <= IMEM_START
      || inside_entry_file (info->return_pc))
    {
      /* This is meant to halt the backtrace at "_start".
	 Make sure we don't halt it at a generic dummy frame. */
      return;
    }
d1475 4
a1478 5
  if (!info->saved_regs[FP_REGNUM])
    {
      if (!info->saved_regs[SP_REGNUM]
	  || info->saved_regs[SP_REGNUM] == STACK_START)
	return;
d1480 6
a1485 3
      id->base = info->saved_regs[SP_REGNUM];
      id->pc = info->return_pc;
    }
d1487 8
a1494 3
  addr = read_memory_unsigned_integer (info->saved_regs[FP_REGNUM],
				       register_size (current_gdbarch, FP_REGNUM));
  if (addr == 0)
d1497 2
a1498 2
  id->base = d10v_make_daddr (addr);
  id->pc = info->return_pc;
d1502 2
a1503 2
saved_regs_unwinder (struct frame_info *frame,
		     CORE_ADDR *saved_regs,
d1508 1
a1508 7
  /* If we're using generic dummy frames, we'd better not be in a call
     dummy.  (generic_call_dummy_register_unwind ought to have been called
     instead.)  */
  gdb_assert (!(DEPRECATED_USE_GENERIC_DUMMY_FRAMES
		&& (get_frame_type (frame) == DUMMY_FRAME)));

  if (saved_regs[regnum] != 0)
d1519 1
a1519 1
			   saved_regs[regnum]);
d1527 1
a1527 1
	  *addrp = saved_regs[regnum];
d1532 1
a1532 1
	      read_memory (saved_regs[regnum], bufferp,
d1543 2
a1544 2
  frame_register (frame, regnum, optimizedp, lvalp, addrp,
		  realnump, bufferp);
d1549 5
a1553 5
d10v_frame_register_unwind (struct frame_info *frame,
			    void **cache,
			    int regnum, int *optimizedp,
			    enum lval_type *lvalp, CORE_ADDR *addrp,
			    int *realnump, void *bufferp)
d1555 2
a1556 1
  struct d10v_unwind_cache *info = d10v_frame_unwind_cache (frame, cache);
d1562 1
a1562 1
      saved_regs_unwinder (frame, info->saved_regs, LR_REGNUM, optimizedp,
d1567 1
a1567 1
      saved_regs_unwinder (frame, info->saved_regs, regnum, optimizedp,
d1574 2
a1575 2
  d10v_frame_id_unwind,
  d10v_frame_register_unwind
@


1.86.2.1
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_frame_this_id): Replace d10v_frame_id_unwind.
	(d10v_frame_unwind): Update.
	(d10v_frame_prev_register): Replace d10v_frame_register_unwind.
	(d10v_frame_unwind_cache): Replace this "fi" with "next_frame".
	(saved_regs_unwinder): Replace this "frame" with "next_frame", and
	"saved_regs" with "this_saved_regs".

	* dummy-frame.c (dummy_frame_unwind): Update.
	(cached_find_dummy_frame): Delete.

	* frame.c (legacy_frame_p): New function.
	(get_prev_frame): Call legacy_frame_p.
	* frame.h (legacy_frame_p): Declare.

	* dummy-frame.c (dummy_frame_prev_register): Rename
	dummy_frame_register_unwind.
	(dummy_frame_this_id): Replace dummy_frame_id_unwind.


	* sentinel-frame.c (sentinel_frame_prev_register): Replace
	sentinel_frame_register_unwind.
	(sentinel_frame_this_id): Replace sentinel_frame_id_unwind.
	(sentinel_frame_unwinder): Update.

	* frame-unwind.c (frame_unwind_find_by_pc): Return
	legacy_saved_regs_unwind instead of trad_frame_unwind.  Update
	comment.

	* frame.c (create_sentinel_frame): Initialize prologue_cache.
	(frame_register_unwind): Call this frame's prev_register with the
	next frame and this frame's prologue cache.  Add commented out
	code to cache the value.
	(get_prev_frame): Call prev frame's this_id with this frame and
	prev frame's prologue cache.  Document that this call is shifted
	one to the left when compared to the frame_register_unwind call.
	(legacy_saved_regs_prev_register): Replace
	frame_saved_regs_register_unwind.
	(legacy_saved_regs_this_id): Replace frame_saved_regs_id_unwind.
	(legacy_saved_regs_unwinder): Replace trad_frame_unwinder.
	(legacy_saved_regs_unwind): Replace trad_frame_unwind.

	* frame.h (legacy_saved_regs_unwind): Replace trad_frame_unwind.
	(struct frame_info): Rename "unwind_cache" to "prolog_cache".

	* frame-unwind.h (frame_this_id_ftype): Replace
	frame_unwind_id_ftype.
	(frame_prev_register_ftype): Replace frame_unwind_reg_ftype.
	(struct frame_unwind): Update.  Rename "id" to "this_id".  Rename
	"reg" to "prev_register".
@
text
@d708 2
a709 2
d10v_frame_unwind_cache (struct frame_info *next_frame,
			 void **this_prologue_cache)
d719 2
a720 2
  if ((*this_prologue_cache))
    return (*this_prologue_cache);
d723 1
a723 1
  (*this_prologue_cache) = info;
d730 1
a730 1
  pc = get_pc_function_start (frame_pc_unwind (next_frame));
d791 1
a791 1
      frame_unwind_unsigned_register (next_frame, FP_REGNUM, &this_base);
d809 1
a809 1
      frame_unwind_unsigned_register (next_frame, SP_REGNUM, &this_base);
d834 1
a834 1
      frame_unwind_unsigned_register (next_frame, LR_REGNUM, &return_pc);
d1460 6
a1465 8
d10v_frame_this_id (struct frame_info *next_frame,
		    void **this_prologue_cache,
		    struct frame_id *this_id)
{
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_prologue_cache);
  CORE_ADDR base;
  CORE_ADDR pc;
d1468 1
a1468 1
  (*this_id) = null_frame_id;
d1470 8
a1477 2
  /* The PC is easy.  */
  pc = frame_pc_unwind (next_frame);
d1479 5
a1483 4
  /* This is meant to halt the backtrace at "_start".  Make sure we
     don't halt it at a generic dummy frame. */
  if (pc == IMEM_START || pc <= IMEM_START || inside_entry_file (pc))
    return;
d1485 3
a1487 6
  /* Hopefully the prologue analysis either correctly determined the
     frame's base (which is the SP from the previous frame), or set
     that base to "NULL".  */
  base = info->base;
  if (base == STACK_START || base == 0)
    return;
d1489 3
a1491 8
  /* Check that we're not going round in circles with the same frame
     ID (but avoid applying the test to sentinel frames which do go
     round in circles).  Can't use frame_id_eq() as that doesn't yet
     compare the frame's PC value.  */
  if (frame_relative_level (next_frame) >= 0
      && get_frame_type (next_frame) != DUMMY_FRAME
      && get_frame_id (next_frame).pc == pc
      && get_frame_id (next_frame).base == base)
d1494 2
a1495 2
  this_id->base = base;
  this_id->pc = pc;
d1499 2
a1500 2
saved_regs_unwinder (struct frame_info *next_frame,
		     CORE_ADDR *this_saved_regs,
d1505 7
a1511 1
  if (this_saved_regs[regnum] != 0)
d1522 1
a1522 1
			   this_saved_regs[regnum]);
d1530 1
a1530 1
	  *addrp = this_saved_regs[regnum];
d1535 1
a1535 1
	      read_memory (this_saved_regs[regnum], bufferp,
d1546 2
a1547 2
  frame_register_unwind (next_frame, regnum, optimizedp, lvalp, addrp,
			 realnump, bufferp);
d1552 5
a1556 5
d10v_frame_prev_register (struct frame_info *next_frame,
			  void **this_prologue_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *bufferp)
d1558 1
a1558 2
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_prologue_cache);
d1564 1
a1564 1
      saved_regs_unwinder (next_frame, info->saved_regs, LR_REGNUM, optimizedp,
d1569 1
a1569 1
      saved_regs_unwinder (next_frame, info->saved_regs, regnum, optimizedp,
d1576 2
a1577 2
  d10v_frame_this_id,
  d10v_frame_prev_register
@


1.85
log
@2003-03-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (gdbarch_unwind_pc): New method.
	* gdbarch.h, gdbarch.c: Regenerate.
	* frame.c (frame_pc_unwind): Rewrite.  Prefer gdbarch_unwind_pc,
	but use read_pc and FRAME_SAVED_PC as fall backs.
	(frame_saved_regs_pc_unwind): Delete function.
	(trad_frame_unwinder): Update.
	* frame-unwind.h (frame_unwind_pc_ftype): Delete declaration.
	(struct frame_unwind): Update.
	* dummy-frame.c (dummy_frame_pc_unwind): Delete function.
	(dummy_frame_unwind): Update.
	* sentinel-frame.c (sentinel_frame_pc_unwind): Delete function.
	(sentinel_frame_unwinder): Update.
	* d10v-tdep.c (d10v_frame_pc_unwind): Delete function.
	(d10v_frame_unwind): Update.
	(d10v_unwind_pc): New function.
	(d10v_gdbarch_init): Set unwind_pc.

Index: doc/ChangeLog
2003-03-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Cross reference
	FRAME_SAVED_PC to unwind_pc.  Document unwind_pc.
@
text
@a1574 37
static void
d10v_frame_pop (struct frame_info *fi, void **unwind_cache,
		struct regcache *regcache)
{
  struct d10v_unwind_cache *info = d10v_frame_unwind_cache (fi, unwind_cache);
  CORE_ADDR fp;
  int regnum;
  char raw_buffer[8];

  fp = get_frame_base (fi);

  /* now update the current registers with the old values */
  for (regnum = A0_REGNUM; regnum < A0_REGNUM + NR_A_REGS; regnum++)
    {
      frame_unwind_register (fi, regnum, raw_buffer);
      regcache_cooked_write (regcache, regnum, raw_buffer);
    }
  for (regnum = 0; regnum < SP_REGNUM; regnum++)
    {
      frame_unwind_register (fi, regnum, raw_buffer);
      regcache_cooked_write (regcache, regnum, raw_buffer);
    }
  frame_unwind_register (fi, PSW_REGNUM, raw_buffer);
  regcache_cooked_write (regcache, PSW_REGNUM, raw_buffer);

  frame_unwind_register (fi, PC_REGNUM, raw_buffer);
  regcache_cooked_write (regcache, PC_REGNUM, raw_buffer);

  store_unsigned_integer (raw_buffer,
			  register_size (current_gdbarch, SP_REGNUM),
			  fp + info->size);
  regcache_cooked_write (regcache, SP_REGNUM, raw_buffer);

  target_store_registers (-1);
  flush_cached_frames ();
}

a1575 1
  d10v_frame_pop,
@


1.84
log
@2003-03-10  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_frame_register_unwind): Correctly unwind the
	PC.
	(d10v_frame_pop): Unwind the PC, and not the LR, when restoring
	the PC register.
@
text
@a1447 1

d1449 1
a1449 2
d10v_frame_pc_unwind (struct frame_info *frame,
		      void **cache)
d1451 3
a1453 2
  struct d10v_unwind_cache *info = d10v_frame_unwind_cache (frame, cache);
  return info->return_pc;
a1613 1
  d10v_frame_pc_unwind,
d1780 3
@


1.83
log
@2003-03-05  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_unwind_dummy_id): New function.
	(d10v_gdbarch_init): Set unwind_dummy_id and save_dummy_frame_tos.
	* frame.c (get_prev_frame): Restructure the frame ID unwind code
	to use unwind_dummy_id when a dummy frame.
	* gdbarch.sh (unwind_dummy_id): New multi-arch method with
	predicate.
	* gdbarch.h, gdbarch.c: Regneerate.

Index: doc/ChangeLog
2003-03-05  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Document
	unwind_dummy_id.  Cross reference unwind_dummy_id and
	SAVE_DUMMY_FRAME_TOS.
@
text
@d1560 13
a1572 2
  saved_regs_unwinder (frame, info->saved_regs, regnum, optimizedp,
		       lvalp, addrp, realnump, bufferp);
d1601 1
a1601 1
  frame_unwind_register (fi, LR_REGNUM, raw_buffer);
@


1.83.2.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d1448 1
d1450 2
a1451 1
d10v_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
d1453 2
a1454 3
  ULONGEST pc;
  frame_unwind_unsigned_register (next_frame, PC_REGNUM, &pc);
  return d10v_make_iaddr (pc);
d1560 18
a1577 1
  if (regnum == PC_REGNUM)
d1579 2
a1580 5
      /* The call instruction saves the caller's PC in LR.  The
	 function prologue of the callee may then save the LR on the
	 stack.  Find that possibly saved LR value and return it.  */
      saved_regs_unwinder (frame, info->saved_regs, LR_REGNUM, optimizedp,
			   lvalp, addrp, realnump, bufferp);
d1582 1
a1582 1
  else
d1584 2
a1585 2
      saved_regs_unwinder (frame, info->saved_regs, regnum, optimizedp,
			   lvalp, addrp, realnump, bufferp);
d1587 13
a1601 1

d1603 2
a1770 3

  /* Return the unwound PC value.  */
  set_gdbarch_unwind_pc (gdbarch, d10v_unwind_pc);
@


1.82
log
@2003-03-05  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (struct d10v_unwind_cache): Add field "base".
	(d10v_frame_unwind_cache): Rewrite code computing the base and SP.
	Do not use d10v_read_sp or d10v_read_fp when obtaining register
	values.
@
text
@d1615 16
d1767 4
@


1.81
log
@2003-03-05  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (struct frame_extra_info): Delete unused structure.
	(struct d10v_unwind_cache): Delete field "frameless".  Replace
	"next_addr" with "sp_offset".  Add "r11_offset".
	(d10v_frame_unwind_cache): Update.
	(prologue_find_regs): Update.  When "mv r11, sp", save the
	"sp_offset" in "r11_offset".  Recognize "st rn, @@r11", note that
	RN was saved in r11_offset.
@
text
@d613 2
d711 3
a713 1
  CORE_ADDR fp, pc;
a727 2

  fp = get_frame_base (fi);
d785 30
a814 2
  if (!(fp & 0xffff))
    fp = d10v_read_sp ();
d816 2
d821 1
a821 1
	info->saved_regs[i] = fp - (info->sp_offset - info->saved_regs[i]);
d838 3
a840 14
  /* The SP is not normally (ever?) saved, but check anyway */
  if (!info->saved_regs[SP_REGNUM])
    {
      /* if the FP was saved, that means the current FP is valid, */
      /* otherwise, it isn't being used, so we use the SP instead */
      if (info->uses_frame)
	info->saved_regs[SP_REGNUM] 
	  = d10v_read_fp () + info->size;
      else
	{
	  info->saved_regs[SP_REGNUM] = fp + info->size;
	  info->saved_regs[FP_REGNUM] = 0;
	}
    }
@


1.80
log
@2003-03-03  Andrew Cagney  <cagney@@redhat.com>

	Make MAX_REGISTER_RAW_SIZE and MAX_REGISTER_VIRTUAL_SIZE optional.
	* gdbarch.sh (DEPRECATED_MAX_REGISTER_RAW_SIZE): Variable with
	predicate.  Replace MAX_REGISTER_RAW_SIZE.
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto for
	MAX_REGISTER_VIRTUAL_SIZE.
	* regcache.c (legacy_max_register_raw_size): New function.
	(legacy_max_register_virtual_size): New function.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Define.
	(MAX_REGISTER_RAW_SIZE): Define.
	(legacy_max_register_raw_size): Declare.
	(legacy_max_register_virtual_size): Declare.
	* config/sparc/tm-sparc.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/i386/tm-ptx.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Do not set
	max_register_raw_size or max_register_virtual_size.
@
text
@a47 7
struct frame_extra_info
  {
    CORE_ADDR return_pc;
    int frameless;
    int size;
  };

a612 1
  int frameless;
d615 5
a619 1
  CORE_ADDR next_addr;
d634 2
a635 2
      info->next_addr -= 2;
      info->saved_regs[n] = info->next_addr;
d643 3
a645 3
      info->next_addr -= 4;
      info->saved_regs[n] = info->next_addr;
      info->saved_regs[n + 1] = info->next_addr + 2;
d655 1
a655 1
      info->next_addr -= n;
d663 9
d683 1
a683 1
      info->saved_regs[n] = info->next_addr;
d691 2
a692 2
      info->saved_regs[n] = info->next_addr;
      info->saved_regs[n + 1] = info->next_addr + 2;
a721 1
  info->frameless = 0;
d726 1
a726 1
  info->next_addr = 0;
d741 1
a741 1
	      info->next_addr += n;
d748 1
a748 1
	      info->saved_regs[n] = info->next_addr + offset;
d755 2
a756 2
	      info->saved_regs[n] = info->next_addr + offset;
	      info->saved_regs[n + 1] = info->next_addr + offset + 2;
d781 1
a781 1
  info->size = -info->next_addr;
d789 1
a789 1
	info->saved_regs[i] = fp - (info->next_addr - info->saved_regs[i]);
a816 1
	  info->frameless = 1;
@


1.80.2.1
log
@2003-03-04  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_frame_unwind_cache): Update to work with
	NEXT_FRAME and THIS_CACHE.
	(d10v_frame_pc_unwind): Ditto.
	(d10v_frame_id_unwind): Ditto.
	(saved_regs_unwinder): Ditto.
	(d10v_frame_register_unwind): Ditto.
	* dummy-frame.c (dummy_frame_register_unwind): Ditto.
	(dummy_frame_pc_unwind): Ditto.
	(cached_find_dummy_frame): Ditto.
	(dummy_frame_id_unwind): Ditto.
	(dummy_frame_pop): Ditto.
	* sentinel-frame.c (sentinel_frame_register_unwind): Ditto.
	(sentinel_frame_pc_unwind): Ditto.
	(sentinel_frame_id_unwind): Ditto.
	(sentinel_frame_pop): Ditto.
	* frame.c (frame_id_unwind): Reinstate function.
	* frame.h (frame_id_unwind): Reinstate declaration.
	* frame.c (frame_pc_unwind): Pass frame->next to the PC's unwind
	method.
	(frame_pop, frame_register_unwind): Ditto.
	* frame-unwind.h (frame_unwind_id_ftype, frame_unwind_reg_ftype)
	(frame_unwind_pc_ftype, frame_unwind_pop_ftype): Re-specify
	behavior in terms of PREV_REGNUM, THIS_CACHE and NEXT_FRAME.
@
text
@a47 8
static void d10v_frame_register_unwind (struct frame_info *next_frame,
					void **this_cache,
					int prev_regnum, int *optimizedp,
					enum lval_type *lvalp,
					CORE_ADDR *addrp,
					int *realnump, void *bufferp);


d619 1
a619 1
  CORE_ADDR base;
d701 2
a702 2
d10v_frame_unwind_cache (struct frame_info *next_frame,
			 void **this_cache)
d704 1
a704 3
  CORE_ADDR pc;
  ULONGEST sp;
  ULONGEST base;
d710 2
a711 2
  if ((*this_cache))
    return (*this_cache);
d714 1
a714 1
  (*this_cache) = info;
d719 1
d721 1
d724 1
a724 1
  pc = get_pc_function_start (frame_pc_unwind (next_frame));
d779 2
a780 3
  /* Start out with the frame's stack top.  */
  frame_unwind_unsigned_register (next_frame, SP_REGNUM, &sp);
  sp = d10v_make_daddr (sp);
d785 1
a785 1
	info->saved_regs[i] = sp - (info->next_addr - info->saved_regs[i]);
d788 1
a788 2
  /* Compute the frame's base.  */
  if (info->saved_regs[FP_REGNUM])
d790 4
a793 12
      /* The FP was saved, which means that the current FP is live.
         Unwind its value from the NEXT frame.  */
      frame_unwind_unsigned_register (next_frame, FP_REGNUM, &base);
    }
  else if (info->saved_regs[SP_REGNUM])
    {
      /* The SP was saved (this is very unusual), the frame base is
	 just the PREV's frame's TOP-OF-STACK.  */
      base = read_memory_unsigned_integer (info->saved_regs[SP_REGNUM], 
					   register_size (current_gdbarch,
							  SP_REGNUM));
      info->frameless = 1;
d797 3
a799 4
      /* Assume that the FP is this frame's SP but with that pushed
         stack space added back.  */
      frame_unwind_unsigned_register (next_frame, SP_REGNUM, &base);
      base += info->size;
d801 17
a817 1
  info->base = d10v_make_daddr (base);
d1426 2
a1427 2
d10v_frame_pc_unwind (struct frame_info *next_frame,
		      void **this_cache)
d1429 2
a1430 15
  /* FIXME: This shouldn't be needed.  Instead a per-architecture
     method should be called.  */
  int optimized;
  enum lval_type lval;
  CORE_ADDR addr;
  int realnum;
  ULONGEST lr;
  void *buffer = alloca (max_register_size (current_gdbarch));
  d10v_frame_register_unwind (next_frame, this_cache, LR_REGNUM, 
			      &optimized, &lval, &addr, &realnum,
			      buffer);
  lr = extract_unsigned_integer (buffer, register_size (current_gdbarch,
							LR_REGNUM));
  return d10v_make_iaddr (lr);
			
d1433 1
a1433 1
/* Given the next frame, determine the address of this function's
d1437 6
a1442 8
d10v_frame_id_unwind (struct frame_info *next_frame,
		      void **this_cache,
		      struct frame_id *this_id)
{
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_cache);
  CORE_ADDR base;
  CORE_ADDR pc;
d1445 1
a1445 4
  (*this_id) = null_frame_id;

  /* The PC is easy.  */
  pc = frame_pc_unwind (next_frame);
d1447 3
a1449 3
  /* This is meant to halt the backtrace at "_start".  Make sure we
     don't halt it at a generic dummy frame. */
  if (pc == IMEM_START || pc <= IMEM_START || inside_entry_file (pc))
d1451 2
a1455 1
#if 0
d1462 2
a1463 2
      this_id->base = info->saved_regs[SP_REGNUM];
      this_id->pc = info->return_pc;
a1469 1
#endif
d1471 2
a1472 4
  /* Hopefully the prolog analysis has correctly determined the
     frame's base.  */
  this_id->base = info->base;
  this_id->pc = pc;
d1476 1
a1476 1
saved_regs_unwinder (struct frame_info *next_frame,
d1478 1
a1478 1
		     int prev_regnum, int *optimizedp,
d1482 7
a1488 1
  if (saved_regs[prev_regnum] != 0)
d1490 1
a1490 5
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = saved_regs[prev_regnum];
      *realnump = -1;
      if (bufferp != NULL)
d1492 23
a1514 3
	  /* Read the value in from memory.  */
	  read_memory (saved_regs[prev_regnum], bufferp,
		       register_size (current_gdbarch, prev_regnum));
d1523 2
a1524 2
  frame_register_unwind (next_frame, prev_regnum, optimizedp, lvalp, addrp,
			 realnump, bufferp);
d1529 3
a1531 3
d10v_frame_register_unwind (struct frame_info *next_frame,
			    void **this_cache,
			    int prev_regnum, int *optimizedp,
d1535 2
a1536 5
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_cache);
  if (prev_regnum == PC_REGNUM)
    prev_regnum = LR_REGNUM;
  saved_regs_unwinder (next_frame, info->saved_regs, prev_regnum, optimizedp,
@


1.80.2.2
log
@2003-03-04  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (struct d10v_unwind_cache): Add field "r11_addr",
	change type of "next_addr" to LONGEST.  Delete member "frameless".
	(prologue_find_regs): Parse "st rn, @@r11", save r11's offset.
	(d10v_frame_unwind_cache): Compute both the frame base and the
	previous stack pointer.  Store the previous SP's value in the
	saved_regs array.
	(d10v_frame_id_unwind): Remove commented out code.  Check for
	circular stack.
	(saved_regs_unwinder): When SP_REGNUM, extract the value from the
	saved_regs array.
	(d10v_unwind_dummy_id): New function.
	(d10v_gdbarch_init): Initialize d10v_unwind_dummy_id and
	save_dummy_frame_tos.
	(struct frame_extra_info): Delete.
	(saved_regs_unwind): New function.
	(d10v_frame_pop): Update to match current code.
	(d10v_frame_register_unwind): Don't unwind LR_REGNUM.  Unwind the
	PC_REGNUM by returning the saved LR_REGNUM.
	* frame.c (get_prev_frame): Store this frame's ID in the next
	frame's unwound ID cache.
	(deprecated_update_frame_pc_hack): Update the cached value in NEXT
	as well.

	2003-02-27  Andrew Cagney  <cagney@@redhat.com>
	* frame.c (get_prev_frame): Rewrite the frame ID unwind code to
	use unwind_dummy_id when available.
	* gdbarch.sh (get_dummy_frame_id): New multi-arch method with
	predicate.
	* gdbarch.h, gdbarch.c: Regneerate.
@
text
@d48 14
a61 3
static void saved_regs_unwind (struct frame_info *next_frame,
			       CORE_ADDR *saved_regs, int prev_regnum,
			       void *bufferp);
d628 1
d631 1
a631 2
  LONGEST next_addr;
  LONGEST r11_addr;
a674 9
      info->r11_addr = info->next_addr;
      return 1;
    }

  /* st  rn, @@r11 */
  if ((op & 0x7E1F) == 0x6816)
    {
      n = (op & 0x1E0) >> 5;
      info->saved_regs[n] = info->r11_addr;
d727 1
d787 10
d798 1
a798 1
  if (info->uses_frame)
d800 2
a801 3
      /* The SP was moved into the FP.  This indicates that a new
         frame was created.  Get THIS frame's FP value by unwinding it
         from the next frame.  */
a802 3
      /* The FP points at the last saved register.  Adjust the FP back
         to before the first saved register giving the SP.  */
      sp = base + info->size;
d806 1
a806 1
      /* The SP was saved (which is very unusual), the frame base is
d811 1
a811 1
      sp = base;
d818 1
a818 1
      sp = base + info->size;
a819 1

a820 16
  sp = d10v_make_daddr (sp);

  /* Adjust all the saved registers so that they contain addresses and
     not offsets.  */
  for (i = 0; i < NUM_REGS - 1; i++)
    {
      if (info->saved_regs[i])
	{
	  info->saved_regs[i] = (sp + info->saved_regs[i]);
	}
    }

  /* The SP_REGNUM is special.  Instead of the address of the SP, the
     previous frame's SP value is saved.  */
  info->saved_regs[SP_REGNUM] = sp;

d1432 7
a1438 5
  /* FIXME: This shouldn't be needed.  Instead single per-architecture
     method should be called for all frames.  */
  CORE_ADDR lr;
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_cache);
d1440 3
a1442 1
  saved_regs_unwind (next_frame, info->saved_regs, LR_REGNUM, buffer);
d1475 10
a1484 6
  /* Hopefully the prologue analysis either correctly determined the
     frame's base (which is the SP from the previous frame), or set
     that base to "NULL".  */
  base = info->base;
  if (base == STACK_START || base == 0)
    return;
d1486 3
a1488 8
  /* Check that we're not going round in circles on the same frame ID.
     Be careful to avoid applying the test to sentinel frames (which
     do go round in circles).  Can't use ID_EQ as that doesn't yet
     compare PC values.  */
  if (frame_relative_level (next_frame) >= 0
      && get_frame_type (next_frame) != DUMMY_FRAME
      && get_frame_id (next_frame).pc == pc
      && get_frame_id (next_frame).base == base)
d1490 1
d1492 3
a1494 1
  this_id->base = base;
d1507 5
a1511 13
      if (prev_regnum == SP_REGNUM)
	{
	  /* SP register treated specially.  */
	  *optimizedp = 0;
	  *lvalp = not_lval;
	  *addrp = 0;
	  *realnump = -1;
	  if (bufferp != NULL)
	    store_address (bufferp,
			   register_size (current_gdbarch, SP_REGNUM),
			   saved_regs[SP_REGNUM]);
	}
      else
d1513 3
a1515 10
	  *optimizedp = 0;
	  *lvalp = lval_memory;
	  *addrp = saved_regs[prev_regnum];
	  *realnump = -1;
	  if (bufferp != NULL)
	    {
	      /* Read the value in from memory.  */
	      read_memory (saved_regs[prev_regnum], bufferp,
			   register_size (current_gdbarch, prev_regnum));
	    }
a1527 14
/* Wrapper so that local code can unwind register values.  */

static void
saved_regs_unwind (struct frame_info *next_frame, CORE_ADDR *saved_regs,
		   int prev_regnum, void *bufferp)
{
  int optimized;
  enum lval_type lval;
  CORE_ADDR addr;
  int realnum;
  saved_regs_unwinder (next_frame, saved_regs, prev_regnum,
		       &optimized, &lval, &addr, &realnum, bufferp);
}

d1538 4
a1541 19
  if (prev_regnum == LR_REGNUM)
    /* Unwinding the LR isn't possible.  It's value is trashed by the
       call instruction.  Mark the value as optimized away.  */
    {
      *optimizedp = 1;
      *lvalp = lval_register;
      *addrp = 0;
      *realnump = LR_REGNUM;
      if (bufferp != NULL)
	memset (bufferp, 0, register_size (current_gdbarch, LR_REGNUM));
    }
  else if (prev_regnum == PC_REGNUM)
    /* The caller's PC is saved in LR_REGNUM.  Find/return the
       LR_REGNUM.  */
    saved_regs_unwinder (next_frame, info->saved_regs, LR_REGNUM, optimizedp,
			 lvalp, addrp, realnump, bufferp);
  else
    saved_regs_unwinder (next_frame, info->saved_regs, prev_regnum, optimizedp,
			 lvalp, addrp, realnump, bufferp);
a1544 11
static struct frame_id
d10v_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  ULONGEST base;
  struct frame_id id;
  id.pc = frame_pc_unwind (next_frame);
  frame_unwind_unsigned_register (next_frame, SP_REGNUM, &base);
  id.base = d10v_make_daddr (base);
  return id;
}

d1546 1
a1546 1
d10v_frame_pop (struct frame_info *next_frame, void **this_cache,
d1549 1
a1549 2
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_cache);
d1554 2
d1559 1
a1559 1
      saved_regs_unwind (next_frame, info->saved_regs, regnum, raw_buffer);
d1564 1
a1564 1
      saved_regs_unwind (next_frame, info->saved_regs, regnum, raw_buffer);
d1567 1
a1567 1
  saved_regs_unwind (next_frame, info->saved_regs, PSW_REGNUM, raw_buffer);
d1570 1
a1570 1
  saved_regs_unwind (next_frame, info->saved_regs, LR_REGNUM, raw_buffer);
d1573 3
a1575 1
  saved_regs_unwind (next_frame, info->saved_regs, SP_REGNUM, raw_buffer);
a1730 2
  set_gdbarch_unwind_dummy_id (gdbarch, d10v_unwind_dummy_id);
  set_gdbarch_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
@


1.80.2.3
log
@2003-03-06  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (gdbarch_unwind_pc): New method.
	* gdbarch.h, gdbarch.c: Regenerate.
	* frame.c (frame_pc_unwind): Rewrite.  Prefer gdbarch_unwind_pc,
	but use read_pc and FRAME_SAVED_PC as fall backs.
	(frame_saved_regs_pc_unwind): Delete function.
	(trad_frame_unwinder): Update.
	* frame-unwind.h (frame_unwind_pc_ftype): Delete declaration.
	(struct frame_unwind): Update.
	* dummy-frame.c (dummy_frame_pc_unwind): Delete function.
	(dummy_frame_unwind): Update.
	* sentinel-frame.c (sentinel_frame_pc_unwind): Delete function.
	(sentinel_frame_unwinder): Update.
	* d10v-tdep.c (d10v_frame_pc_unwind): Delete function.
	(d10v_frame_unwind): Update.
	(d10v_unwind_pc): New function.
	(d10v_gdbarch_init): Set unwind_pc.

2003-03-05  Andrew Cagney  <cagney@@redhat.com>

	* dummy-frame.c (dummy_frame_id_unwind): Abort if called.
	(cached_find_dummy_frame): Add hack to obtain this thread's id
	without calling id unwind.
	* frame.h: Merge with mainline.
	* d10v-tdep.c: Merge with mainline.
	* frame.c: Merge with mainline.
@
text
@d619 2
a620 5
  /* How far the SP and r11 (FP) have been offset from the start of
     the stack frame (as defined by the previous frame's stack
     pointer).  */
  LONGEST sp_offset;
  LONGEST r11_offset;
d635 2
a636 2
      info->sp_offset -= 2;
      info->saved_regs[n] = info->sp_offset;
d644 3
a646 3
      info->sp_offset -= 4;
      info->saved_regs[n] = info->sp_offset;
      info->saved_regs[n + 1] = info->sp_offset + 2;
d656 1
a656 1
      info->sp_offset -= n;
d664 1
a664 1
      info->r11_offset = info->sp_offset;
d672 1
a672 1
      info->saved_regs[n] = info->r11_offset;
d684 1
a684 1
      info->saved_regs[n] = info->sp_offset;
d692 2
a693 2
      info->saved_regs[n] = info->sp_offset;
      info->saved_regs[n + 1] = info->sp_offset + 2;
d711 2
a712 2
  ULONGEST prev_sp;
  ULONGEST this_base;
d727 1
a727 1
  info->sp_offset = 0;
d742 1
a742 1
	      info->sp_offset += n;
d749 1
a749 1
	      info->saved_regs[n] = info->sp_offset + offset;
d756 2
a757 2
	      info->saved_regs[n] = info->sp_offset + offset;
	      info->saved_regs[n + 1] = info->sp_offset + offset + 2;
d782 1
a782 1
  info->size = -info->sp_offset;
d784 1
a784 1
  /* Compute the frame's base, and the previous frame's SP.  */
d787 4
a790 4
      /* The SP was moved to the FP.  This indicates that a new frame
         was created.  Get THIS frame's FP value by unwinding it from
         the next frame.  */
      frame_unwind_unsigned_register (next_frame, FP_REGNUM, &this_base);
d793 1
a793 1
      prev_sp = this_base + info->size;
d799 4
a802 4
      this_base = read_memory_unsigned_integer (info->saved_regs[SP_REGNUM], 
						register_size (current_gdbarch,
							       SP_REGNUM));
      prev_sp = this_base;
d808 2
a809 2
      frame_unwind_unsigned_register (next_frame, SP_REGNUM, &this_base);
      prev_sp = this_base + info->size;
d812 2
a813 2
  info->base = d10v_make_daddr (this_base);
  prev_sp = d10v_make_daddr (prev_sp);
d818 6
a823 4
    if (info->saved_regs[i])
      {
	info->saved_regs[i] = (prev_sp + info->saved_regs[i]);
      }
d827 1
a827 1
  info->saved_regs[SP_REGNUM] = prev_sp;
d1435 1
d1437 2
a1438 1
d10v_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
d1440 11
a1450 3
  ULONGEST pc;
  frame_unwind_unsigned_register (next_frame, PC_REGNUM, &pc);
  return d10v_make_iaddr (pc);
d1590 12
d1638 1
a1648 16
/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
   dummy frame.  The frame ID's base needs to match the TOS value
   saved by save_dummy_frame_tos(), and the PC match the dummy frame's
   breakpoint.  */

static struct frame_id
d10v_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  ULONGEST base;
  struct frame_id id;
  id.pc = frame_pc_unwind (next_frame);
  frame_unwind_unsigned_register (next_frame, SP_REGNUM, &base);
  id.base = d10v_make_daddr (base);
  return id;
}

a1784 2

  /* Methods for saving / extracting a dummy frame's ID.  */
a1786 3

  /* Return the unwound PC value.  */
  set_gdbarch_unwind_pc (gdbarch, d10v_unwind_pc);
@


1.80.2.4
log
@2003-03-06  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_frame_pop): Delete function.
	(d10v_frame_unwind): Update.
	* frame.c: Include "reggroups.h".
	* regcache.c (regcache_raw_write): Allow writes to a readonly
	regcache.
	* frame.c (frame_saved_regs_pop): Delete function.
	(trad_frame_unwinder): Update
	(frame_pop): Rewrite.
	* sentinel-frame.c (sentinel_frame_pop): Delete function.
	(sentinel_frame_unwinder): Update.
	* dummy-frame.c (dummy_frame_pop): Delete function.
	(dummy_frame_unwind): Update.
	* frame-unwind.h (frame_unwind_pop_ftype): Delete definition.
	(struct frame_unwind): Update.
@
text
@d1581 34
d1616 1
@


1.79
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (register_type): New function with predicate.
	(REGISTER_VIRTUAL_TYPE): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.c (generic_register_byte): Use generic_register_size.
	(generic_register_size): When available, use
	gdbarch_register_type.
	* regcache.c (init_regcache_descr): When available, initialize the
	register type array using gdbarch_register_type.  If the
	architecture supplies gdbarch_register_type, do not use the legacy
	regcache layout.
	* d10v-tdep.c (d10v_register_type): Replace
	d10v_register_virtual_type.
	(d10v_gdbarch_init): Set register_type instead of
	register_virtual_type.
@
text
@a1651 1
  set_gdbarch_max_register_raw_size (gdbarch, 8);
a1652 1
  set_gdbarch_max_register_virtual_size (gdbarch, 8);
@


1.78
log
@2003-02-28  Andrew Cagney  <cagney@@redhat.com>

	* regcache.c (register_size): New function.
	* regcache.h (register_size): Declare
	* d10v-tdep.c: Use register_size instead of REGISTER_RAW_SIZE, use
	max_register_size instead of MAX_REGISTER_RAW_SIZE.
@
text
@d351 1
a351 1
d10v_register_virtual_type (int reg_nr)
d1655 1
a1655 1
  set_gdbarch_register_virtual_type (gdbarch, d10v_register_virtual_type);
@


1.77
log
@2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_DUMMY_FRAME): Procedure with
	predicate.  Replaces PUSH_DUMMY_FRAME.
	* gdbarch.h, gdbarch.c: Regnerate.
	* valops.c (hand_function_call): Update.  Call
	generic_push_dummy_frame directly.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* inferior.h (PUSH_DUMMY_FRAME): Delete definition.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Don't set
	push_dummy_frame to generic_push_dummy_frame.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@d792 1
a792 1
					REGISTER_RAW_SIZE (LR_REGNUM));
d892 1
a892 1
	for (i = 0; i < MAX_REGISTER_RAW_SIZE; i++)
d1081 1
a1081 1
					 REGISTER_RAW_SIZE (RET1_REGNUM)));
d1467 1
a1467 1
				       REGISTER_RAW_SIZE (FP_REGNUM));
d1498 1
a1498 1
	    store_address (bufferp, REGISTER_RAW_SIZE (regnum),
d1513 1
a1513 1
			   REGISTER_RAW_SIZE (regnum));
d1569 2
a1570 1
  store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (SP_REGNUM),
@


1.76
log
@2003-02-02  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (frame_unwind_register): New function.
	(frame_unwind_unsigned_register): Use.
	(frame_unwind_signed_register): Use.
	(frame_read_register): New function.
	* frame.h (frame_unwind_register): Declare.
	(frame_read_register): Declare.

	* d10v-tdep.c (d10v_frame_pop): Rewrite. Use regcache_cooked_write
	and frame_unwind_register instead of read_memory, write_register and
	deprecated_write_register_bytes.
@
text
@a1699 1
  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);
@


1.75
log
@2003-02-02  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h: Note that namelen can be negative.
	* frame.c (frame_map_name_to_regnum): When LEN is negative, use
	NAME's length.

	* NEWS: Mention that the d10v's `regs' command is deprecated.
	* d10v-tdep.c (d10v_gdbarch_init): Set print_registers_info.
	(d10v_print_registers_info): New function.
	(show_regs): Call d10v_print_registers_info.
	(_initialize_d10v_tdep): Mark "show regs" command as deprecated.
@
text
@d1555 2
a1556 6
      if (info->saved_regs[regnum])
	{
	  read_memory (info->saved_regs[regnum], raw_buffer, REGISTER_RAW_SIZE (regnum));
	  deprecated_write_register_bytes (REGISTER_BYTE (regnum), raw_buffer,
					   REGISTER_RAW_SIZE (regnum));
	}
d1560 2
a1561 8
      if (info->saved_regs[regnum])
	{
	  write_register (regnum, read_memory_unsigned_integer (info->saved_regs[regnum], REGISTER_RAW_SIZE (regnum)));
	}
    }
  if (info->saved_regs[PSW_REGNUM])
    {
      write_register (PSW_REGNUM, read_memory_unsigned_integer (info->saved_regs[PSW_REGNUM], REGISTER_RAW_SIZE (PSW_REGNUM)));
d1563 9
a1572 2
  write_register (PC_REGNUM, read_register (LR_REGNUM));
  write_register (SP_REGNUM, fp + info->size);
@


1.74
log
@2003-02-02  Andrew Cagney  <ac131313@@redhat.com>

	* mips-nat.c (zerobuf): Delete.
	(fetch_inferior_registers): Alloc local zerobuf.
	(fetch_core_registers): Alloc local zerobuf.
	* d10v-tdep.c (show_regs): Don't allocate a dynamic array using
	MAX_REGISTER_RAW_SIZE or MAX_REGISTER_VIRTUAL_SIZE.
	* thread-db.c (thread_db_store_registers): Ditto.
	* sh-tdep.c (sh_do_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote-sim.c (gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* monitor.c (monitor_supply_register): Ditto.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	* m68klinux-nat.c (fetch_register): Ditto.
	* lynx-nat.c (fetch_inferior_registers): Ditto.
	(fetch_inferior_registers): Ditto.
	* irix4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (fetch_register): Ditto.
	* hppab-nat.c (fetch_register): Ditto.
	* hppa-tdep.c (pa_register_look_aside): Ditto.
	(pa_print_fp_reg, pa_strcat_fp_reg): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register): Ditto.
@
text
@d822 2
a823 1
show_regs (char *args, int from_tty)
d825 1
a825 35
  int a;
  printf_filtered ("PC=%04lx (0x%lx) PSW=%04lx RPT_S=%04lx RPT_E=%04lx RPT_C=%04lx\n",
		   (long) read_register (PC_REGNUM),
		   (long) d10v_make_iaddr (read_register (PC_REGNUM)),
		   (long) read_register (PSW_REGNUM),
		   (long) read_register (24),
		   (long) read_register (25),
		   (long) read_register (23));
  printf_filtered ("R0-R7  %04lx %04lx %04lx %04lx %04lx %04lx %04lx %04lx\n",
		   (long) read_register (0),
		   (long) read_register (1),
		   (long) read_register (2),
		   (long) read_register (3),
		   (long) read_register (4),
		   (long) read_register (5),
		   (long) read_register (6),
		   (long) read_register (7));
  printf_filtered ("R8-R15 %04lx %04lx %04lx %04lx %04lx %04lx %04lx %04lx\n",
		   (long) read_register (8),
		   (long) read_register (9),
		   (long) read_register (10),
		   (long) read_register (11),
		   (long) read_register (12),
		   (long) read_register (13),
		   (long) read_register (14),
		   (long) read_register (15));
  for (a = 0; a < NR_IMAP_REGS; a++)
    {
      if (a > 0)
	printf_filtered ("    ");
      printf_filtered ("IMAP%d %04lx", a, d10v_imap_register (a));
    }
  if (NR_DMAP_REGS == 1)
    printf_filtered ("    DMAP %04lx\n", d10v_dmap_register (2));
  else
d827 2
a828 5
      for (a = 0; a < NR_DMAP_REGS; a++)
	{
	  printf_filtered ("    DMAP%d %04lx", a, d10v_dmap_register (a));
	}
      printf_filtered ("\n");
d830 1
a830 1
  printf_filtered ("A0-A%d", NR_A_REGS - 1);
d832 55
a886 1
    char *num = alloca (max_register_size (current_gdbarch));
d890 2
a891 2
	printf_filtered ("  ");
	deprecated_read_register_gen (a, (char *) &num);
d894 1
a894 1
	    printf_filtered ("%02x", (num[i] & 0xff));
d898 8
a905 1
  printf_filtered ("\n");
d1729 2
d1750 2
a1751 1
  add_com ("regs", class_vars, show_regs, "Print all registers");
@


1.73
log
@2003-01-30  Andrew Cagney  <ac131313@@redhat.com>

	* d10v-tdep.c: Include "frame-unwind.h".
	(d10v_gdbarch_init): Append d10v_frame_p to the unwind predicate
	list.
	(next_addr, uses_frame): Delete.
	(struct d10v_unwind_cache): Define.
	(prologue_find_regs): Add struct d10v_unwind_cache info parameter.
	Use info instead of next_addr and uses_frame globals.
	(d10v_frame_init_saved_regs): Delete function.
	(d10v_init_extra_frame_info): Delete function.
	(d10v_gdbarch_init): Do not initialize init_extra_frame_info,
	frame_init_saved_regs or pop_frame, frame_chain, frame_chain_valid,
	init_frame_pc or frame_saved_pc.
	(d10v_pop_frame): Delete function.
	(do_d10v_pop_frame): Delete function.
	(d10v_frame_chain): Delete function.
	(d10v_frame_chain_valid): Delete function.
	(d10v_frame_pc_unwind): New function.
	(d10v_frame_id_unwind): New function.
	(saved_regs_unwinder): New function.
	(d10v_frame_register_unwind): New function.
	(d10v_frame_pop): New function.
	(d10v_frame_unwind): New variable.
	(d10v_frame_p): New function.
	(d10v_frame_saved_pc): Delete function.
	* Makefile.in (d10v-tdep.o): Update dependencies.
@
text
@d867 13
a879 11
  for (a = A0_REGNUM; a < A0_REGNUM + NR_A_REGS; a++)
    {
      char num[MAX_REGISTER_RAW_SIZE];
      int i;
      printf_filtered ("  ");
      deprecated_read_register_gen (a, (char *) &num);
      for (i = 0; i < MAX_REGISTER_RAW_SIZE; i++)
	{
	  printf_filtered ("%02x", (num[i] & 0xff));
	}
    }
@


1.72
log
@2003-01-19  Andrew Cagney  <ac131313@@redhat.com>

	* d10v-tdep.c (d10v_frame_saved_pc, d10v_frame_chain): Restore
	code handling dummy frames.
@
text
@d27 1
a107 13
static int prologue_find_regs (unsigned short op, struct frame_info *fi,
			       CORE_ADDR addr);

static void d10v_frame_init_saved_regs (struct frame_info *);

static void do_d10v_pop_frame (struct frame_info *fi);

static int
d10v_frame_chain_valid (CORE_ADDR chain, struct frame_info *frame)
{
    return (get_frame_pc (frame) > IMEM_START);
}

a508 11
static CORE_ADDR
d10v_frame_saved_pc (struct frame_info *frame)
{
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, 0, 0))
    return d10v_make_iaddr (deprecated_read_register_dummy (frame->pc, 
							    frame->frame, 
							    PC_REGNUM));
  else
    return ((frame)->extra_info->return_pc);
}

a519 49
/* Discard from the stack the innermost frame, restoring all saved
   registers.  */

static void
d10v_pop_frame (void)
{
  generic_pop_current_frame (do_d10v_pop_frame);
}

static void
do_d10v_pop_frame (struct frame_info *fi)
{
  CORE_ADDR fp;
  int regnum;
  char raw_buffer[8];

  fp = get_frame_base (fi);
  /* fill out fsr with the address of where each */
  /* register was stored in the frame */
  d10v_frame_init_saved_regs (fi);

  /* now update the current registers with the old values */
  for (regnum = A0_REGNUM; regnum < A0_REGNUM + NR_A_REGS; regnum++)
    {
      if (get_frame_saved_regs (fi)[regnum])
	{
	  read_memory (get_frame_saved_regs (fi)[regnum], raw_buffer, REGISTER_RAW_SIZE (regnum));
	  deprecated_write_register_bytes (REGISTER_BYTE (regnum), raw_buffer,
					   REGISTER_RAW_SIZE (regnum));
	}
    }
  for (regnum = 0; regnum < SP_REGNUM; regnum++)
    {
      if (get_frame_saved_regs (fi)[regnum])
	{
	  write_register (regnum, read_memory_unsigned_integer (get_frame_saved_regs (fi)[regnum], REGISTER_RAW_SIZE (regnum)));
	}
    }
  if (get_frame_saved_regs (fi)[PSW_REGNUM])
    {
      write_register (PSW_REGNUM, read_memory_unsigned_integer (get_frame_saved_regs (fi)[PSW_REGNUM], REGISTER_RAW_SIZE (PSW_REGNUM)));
    }

  write_register (PC_REGNUM, read_register (LR_REGNUM));
  write_register (SP_REGNUM, fp + get_frame_extra_info (fi)->size);
  target_store_registers (-1);
  flush_cached_frames ();
}

d617 1
a617 7
/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct, and
   then INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC will be
   called for the new frame.  */

static CORE_ADDR
d10v_frame_chain (struct frame_info *fi)
d619 8
a626 34
  CORE_ADDR addr;

  /* A generic call dummy's frame is the same as caller's.  */
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, 0, 0))
    return fi->frame;

  d10v_frame_init_saved_regs (fi);
  
  if (get_frame_extra_info (fi)->return_pc == IMEM_START
      || inside_entry_file (get_frame_extra_info (fi)->return_pc))
    {
      /* This is meant to halt the backtrace at "_start".
	 Make sure we don't halt it at a generic dummy frame. */
      return (CORE_ADDR) 0;
    }

  if (!get_frame_saved_regs (fi)[FP_REGNUM])
    {
      if (!get_frame_saved_regs (fi)[SP_REGNUM]
	  || get_frame_saved_regs (fi)[SP_REGNUM] == STACK_START)
	return (CORE_ADDR) 0;

      return get_frame_saved_regs (fi)[SP_REGNUM];
    }

  addr = read_memory_unsigned_integer (get_frame_saved_regs (fi)[FP_REGNUM],
				       REGISTER_RAW_SIZE (FP_REGNUM));
  if (addr == 0)
    return (CORE_ADDR) 0;

  return d10v_make_daddr (addr);
}

static int next_addr, uses_frame;
d629 2
a630 1
prologue_find_regs (unsigned short op, struct frame_info *fi, CORE_ADDR addr)
d638 2
a639 2
      next_addr -= 2;
      get_frame_saved_regs (fi)[n] = next_addr;
d647 3
a649 3
      next_addr -= 4;
      get_frame_saved_regs (fi)[n] = next_addr;
      get_frame_saved_regs (fi)[n + 1] = next_addr + 2;
d659 1
a659 1
      next_addr -= n;
d666 1
a666 1
      uses_frame = 1;
d678 1
a678 1
      get_frame_saved_regs (fi)[n] = next_addr;
d686 2
a687 2
      get_frame_saved_regs (fi)[n] = next_addr;
      get_frame_saved_regs (fi)[n + 1] = next_addr + 2;
d700 3
a702 2
static void
d10v_frame_init_saved_regs (struct frame_info *fi)
d708 12
d722 1
a722 2
  memset (get_frame_saved_regs (fi), 0, SIZEOF_FRAME_SAVED_REGS);
  next_addr = 0;
d726 1
a726 1
  uses_frame = 0;
d737 1
a737 1
	      next_addr += n;
d744 1
a744 1
	      get_frame_saved_regs (fi)[n] = next_addr + offset;
d751 2
a752 2
	      get_frame_saved_regs (fi)[n] = next_addr + offset;
	      get_frame_saved_regs (fi)[n + 1] = next_addr + offset + 2;
d770 2
a771 2
	  if (!prologue_find_regs (op1, fi, pc) 
	      || !prologue_find_regs (op2, fi, pc))
d777 1
a777 1
  get_frame_extra_info (fi)->size = -next_addr;
d783 1
a783 1
    if (get_frame_saved_regs (fi)[i])
d785 1
a785 1
	get_frame_saved_regs (fi)[i] = fp - (next_addr - get_frame_saved_regs (fi)[i]);
d788 1
a788 1
  if (get_frame_saved_regs (fi)[LR_REGNUM])
d791 1
a791 1
	= read_memory_unsigned_integer (get_frame_saved_regs (fi)[LR_REGNUM], 
d793 1
a793 1
      get_frame_extra_info (fi)->return_pc = d10v_make_iaddr (return_pc);
d797 3
a799 1
      get_frame_extra_info (fi)->return_pc = d10v_make_iaddr (read_register (LR_REGNUM));
d803 1
a803 1
  if (!get_frame_saved_regs (fi)[SP_REGNUM])
d807 3
a809 3
      if (uses_frame)
	get_frame_saved_regs (fi)[SP_REGNUM] 
	  = d10v_read_fp () + get_frame_extra_info (fi)->size;
d812 3
a814 3
	  get_frame_saved_regs (fi)[SP_REGNUM] = fp + get_frame_extra_info (fi)->size;
	  get_frame_extra_info (fi)->frameless = 1;
	  get_frame_saved_regs (fi)[FP_REGNUM] = 0;
a816 1
}
d818 1
a818 20
static void
d10v_init_extra_frame_info (int fromleaf, struct frame_info *fi)
{
  frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));
  frame_saved_regs_zalloc (fi);

  get_frame_extra_info (fi)->frameless = 0;
  get_frame_extra_info (fi)->size = 0;
  get_frame_extra_info (fi)->return_pc = 0;

  /* If get_frame_pc (fi) is zero, but this is not the outermost frame, 
     then let's snatch the return_pc from the callee, so that
     DEPRECATED_PC_IN_CALL_DUMMY will work.  */
  if (get_frame_pc (fi) == 0
      && frame_relative_level (fi) != 0 && get_next_frame (fi) != NULL)
    deprecated_update_frame_pc_hack (fi, d10v_frame_saved_pc (get_next_frame (fi)));

  /* The call dummy doesn't save any registers on the stack, so we can
     return now.  */
  d10v_frame_init_saved_regs (fi);
d1398 168
a1588 4
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_default);

a1683 5
  set_gdbarch_frame_init_saved_regs (gdbarch, d10v_frame_init_saved_regs);
  set_gdbarch_init_extra_frame_info (gdbarch, d10v_init_extra_frame_info);

  set_gdbarch_pop_frame (gdbarch, d10v_pop_frame);

a1693 3
  set_gdbarch_frame_chain (gdbarch, d10v_frame_chain);
  set_gdbarch_frame_chain_valid (gdbarch, d10v_frame_chain_valid);
  set_gdbarch_frame_saved_pc (gdbarch, d10v_frame_saved_pc);
d1701 2
@


1.71
log
@2003-01-12  Andrew Cagney  <ac131313@@redhat.com>

	* d10v-tdep.c (d10v_init_extra_frame_info): Remove checks for a
	dummy frame.
	(d10v_frame_saved_pc, d10v_frame_chain): Ditto.
@
text
@d524 6
a529 1
  return (get_frame_extra_info (frame)->return_pc);
d700 3
a703 1

@


1.70
log
@2003-01-12  Andrew Cagney  <ac131313@@redhat.com>

	* d10v-tdep.c: Include "gdb_assert.h".
	(d10v_store_return_value): Rewrite to match current interface.
	(d10v_extract_struct_value_address): Ditto.
	(d10v_extract_return_value): Ditto.
	(d10v_gdbarch_init): Set store_restore_value,
	extract_struct_value_address and extract_return_value.
@
text
@d524 1
a524 8
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
    return d10v_make_iaddr (deprecated_read_register_dummy (get_frame_pc (frame), 
							    get_frame_base (frame), 
							    PC_REGNUM));
  else
    return (get_frame_extra_info (frame)->return_pc);
a694 4
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), get_frame_base (fi),
				   get_frame_base (fi)))
    return get_frame_base (fi);

d703 1
a703 2
      if (!DEPRECATED_PC_IN_CALL_DUMMY (get_frame_extra_info (fi)->return_pc, 0, 0))
	return (CORE_ADDR) 0;
d920 1
a920 9
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), get_frame_base (fi),
				   get_frame_base (fi)))
    {
      return;
    }
  else
    {
      d10v_frame_init_saved_regs (fi);
    }
@


1.69
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_init_extra_frame_info): Use
	frame_relative_level.
@
text
@d45 2
d477 2
a478 1
d10v_store_return_value (struct type *type, char *valbuf)
d480 2
a481 2
  char tmp = 0;
  /* Only char return values need to be shifted right within R0.  */
d485 3
a487 5
      /* zero the high byte */
      deprecated_write_register_bytes (REGISTER_BYTE (RET1_REGNUM), &tmp, 1);
      /* copy the low byte */
      deprecated_write_register_bytes (REGISTER_BYTE (RET1_REGNUM) + 1,
				       valbuf, 1);
d490 17
a506 2
    deprecated_write_register_bytes (REGISTER_BYTE (RET1_REGNUM),
				     valbuf, TYPE_LENGTH (type));
d514 1
a514 1
d10v_extract_struct_value_address (char *regbuf)
d516 3
a518 3
  return (extract_address ((regbuf) + REGISTER_BYTE (ARG1_REGNUM),
			   REGISTER_RAW_SIZE (ARG1_REGNUM))
	  | DMEM_START);
d1168 2
a1169 2
d10v_extract_return_value (struct type *type, char regbuf[REGISTER_BYTES],
			   char *valbuf)
d1178 1
a1178 2
  len = TYPE_LENGTH (type);
  if (len == 1)
d1180 2
a1181 4
      unsigned short c;

      c = extract_unsigned_integer (regbuf + REGISTER_BYTE (RET1_REGNUM), 
				    REGISTER_RAW_SIZE (RET1_REGNUM));
a1183 2
  else if ((len & 1) == 0)
    memcpy (valbuf, regbuf + REGISTER_BYTE (RET1_REGNUM), len);
d1188 18
a1205 4
	 remaining bytes in remaining registers. Interestingly,
	 when such values are passed in, the last byte is in the
	 most significant byte of that same register - wierd. */
      memcpy (valbuf, regbuf + REGISTER_BYTE (RET1_REGNUM) + 1, len);
d1632 1
a1632 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, d10v_extract_return_value);
d1638 2
a1639 2
  set_gdbarch_deprecated_store_return_value (gdbarch, d10v_store_return_value);
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, d10v_extract_struct_value_address);
@


1.69.2.1
log
@Import latest changes from mainline.
@
text
@a44 2
#include "gdb_assert.h"

d475 1
a475 2
d10v_store_return_value (struct type *type, struct regcache *regcache,
			 const void *valbuf)
d477 2
a478 2
  /* Only char return values need to be shifted right within the first
     regnum.  */
d482 5
a486 3
      bfd_byte tmp[2];
      tmp[1] = *(bfd_byte *)valbuf;
      regcache_cooked_write (regcache, RET1_REGNUM, tmp);
d489 2
a490 17
    {
      int reg;
      /* A structure is never more than 8 bytes long.  See
         use_struct_convention().  */
      gdb_assert (TYPE_LENGTH (type) <= 8);
      /* Write out most registers, stop loop before trying to write
         out any dangling byte at the end of the buffer.  */
      for (reg = 0; (reg * 2) + 1 < TYPE_LENGTH (type); reg++)
	{
	  regcache_cooked_write (regcache, RET1_REGNUM + reg,
				 (bfd_byte *) valbuf + reg * 2);
	}
      /* Write out any dangling byte at the end of the buffer.  */
      if ((reg * 2) + 1 == TYPE_LENGTH (type))
	regcache_cooked_write_part (regcache, reg, 0, 1,
				    (bfd_byte *) valbuf + reg * 2);
    }
d498 1
a498 1
d10v_extract_struct_value_address (struct regcache *regcache)
d500 3
a502 3
  ULONGEST addr;
  regcache_cooked_read_unsigned (regcache, ARG1_REGNUM, &addr);
  return (addr | DMEM_START);
d508 8
a515 1
  return (get_frame_extra_info (frame)->return_pc);
d686 4
d698 2
a699 1
      return (CORE_ADDR) 0;
d916 9
a924 1
  d10v_frame_init_saved_regs (fi);
d1152 2
a1153 2
d10v_extract_return_value (struct type *type, struct regcache *regcache,
			   void *valbuf)
d1162 2
a1163 1
  if (TYPE_LENGTH (type) == 1)
d1165 4
a1168 2
      ULONGEST c;
      regcache_cooked_read_unsigned (regcache, RET1_REGNUM, &c);
d1171 2
d1177 4
a1180 18
	 remaining bytes in remaining registers. Interestingly, when
	 such values are passed in, the last byte is in the most
	 significant byte of that same register - wierd. */
      int reg = RET1_REGNUM;
      int off = 0;
      if (TYPE_LENGTH (type) & 1)
	{
	  regcache_cooked_read_part (regcache, RET1_REGNUM, 1, 1,
				     (bfd_byte *)valbuf + off);
	  off++;
	  reg++;
	}
      /* Transfer the remaining registers.  */
      for (; off < TYPE_LENGTH (type); reg++, off += 2)
	{
	  regcache_cooked_read (regcache, RET1_REGNUM + reg,
				(bfd_byte *) valbuf + off);
	}
d1607 1
a1607 1
  set_gdbarch_extract_return_value (gdbarch, d10v_extract_return_value);
d1613 2
a1614 2
  set_gdbarch_store_return_value (gdbarch, d10v_store_return_value);
  set_gdbarch_extract_struct_value_address (gdbarch, d10v_extract_struct_value_address);
@


1.69.2.2
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* d10v-tdep.c: Include "d10v-tdep.h".  Update to use D10V_
	prefixed enums.
	(do_d10v_pop_frame): Delete.  Use version in d10v-frame.c.

	* frame.c (frame_read_unsigned_register): Do not use
	get_next_frame.
	(frame_read_signed_register): Do not use get_next_frame.
	(get_frame_base): Use frame_id_unwind.

	* d10v-tdep.h: New file.
	* d10v-frame.h: New file.
	* d10v-frame.c: New file.

	* frame.c (frame_id_unwind): Update.
	(create_sentinel_frame): Update.
	(legacy_get_prev_frame): Use frame_unwind_find_by_pc.
	(get_prev_frame): Ditto.

	* frame.h (struct frame_info): Replace pc_unwind, id_unwind and
	register_unwind with unwind structure.

	* frame.c (set_unwind_by_pc): Delete function.
	(create_new_frame): Use frame_unwind_find_by_pc;

	* Makefile.in (frame_h): Add $(frame_unwind_h).
	* frame.h: Include "frame-unwind.h".
	(frame_register_unwind_ftype): Delete.
	(frame_id_unwind_ftype): Delete.
	(frame_pc_unwind_ftype): Delete.

	* Makefile.in (dummy-frame.o): Update dependencies.
	(legacy-frame.o): Update dependencies.

	* dummy-frame.c: Include "frame-unwind.h".
	(dummy_frame_unwind): New static variable.
	(dummy_frame_p): New function.
	* legacy-frame.c: Include "frame-unwind.h".
	(legacy_frame_unwind): New static variable.
	(legacy_frame_p): New function.
	* legacy-frame.h (legacy_frame_p): Declare.
	* dummy-frame.h (dummy_frame_p): Declare.

	* Makefile.in (frame_unwind_h): Define.
	* frame-unwind.h: New file.
	* frame-unwind.c: New file.
@
text
@a40 1
#include "d10v-tdep.h"
a44 3
#include "frame-unwind.h"
#include "d10v-frame.h"

d62 30
d93 1
a93 6

int
d10v_a0_regnum (struct gdbarch *gdbarch)
{
  return (gdbarch_tdep (current_gdbarch)->a0_regnum);
}
d99 4
d112 1
a112 1
void do_d10v_pop_frame (struct frame_info *fi);
d117 1
a117 1
    return (get_frame_pc (frame) > D10V_IMEM_START);
d301 1
a301 1
      && nr < TS2_IMAP0_REGNUM + D10V_NR_IMAP_REGS)
d306 1
a306 1
      && nr < TS2_A0_REGNUM + D10V_NR_A_REGS)
d317 1
a317 1
      && nr < TS3_IMAP0_REGNUM + D10V_NR_IMAP_REGS)
d323 1
a323 1
      && nr < TS3_A0_REGNUM + D10V_NR_A_REGS)
d334 1
a334 1
  if (reg_nr < d10v_a0_regnum (current_gdbarch))
d336 3
a338 3
  else if (reg_nr < (d10v_a0_regnum (current_gdbarch) + D10V_NR_A_REGS))
    return (d10v_a0_regnum (current_gdbarch) * 2
	    + (reg_nr - d10v_a0_regnum (current_gdbarch)) * 8);
d340 3
a342 3
    return (d10v_a0_regnum (current_gdbarch) * 2
	    + D10V_NR_A_REGS * 8
	    + (reg_nr - d10v_a0_regnum (current_gdbarch) - D10V_NR_A_REGS) * 2);
d351 1
a351 1
  if (reg_nr < d10v_a0_regnum (current_gdbarch))
d353 1
a353 1
  else if (reg_nr < (d10v_a0_regnum (current_gdbarch) + D10V_NR_A_REGS))
d365 1
a365 1
  if (reg_nr == D10V_PC_REGNUM)
d367 1
a367 1
  if (reg_nr == D10V_SP_REGNUM || reg_nr == D10V_FP_REGNUM)
d369 2
a370 2
  else if (reg_nr >= d10v_a0_regnum (current_gdbarch)
      && reg_nr < (d10v_a0_regnum (current_gdbarch) + D10V_NR_A_REGS))
d379 1
a379 1
  return (((x) & 0x3000000) == D10V_DMEM_START);
d385 1
a385 1
  return (((x) & 0x3000000) == D10V_IMEM_START);
d388 1
a388 1
CORE_ADDR
d391 1
a391 1
  return ((x) | D10V_DMEM_START);
d394 1
a394 1
CORE_ADDR
d400 1
a400 1
    return (((x) << 2) | D10V_IMEM_START);
d468 1
a468 1
  write_register (D10V_ARG1_REGNUM, (addr));
d534 2
a535 2
  return ((read_register (D10V_LR_REGNUM) << 2)
	  | D10V_IMEM_START);
d547 40
d698 1
a698 1
  if (get_frame_extra_info (fi)->return_pc == D10V_IMEM_START
d706 1
a706 1
  if (!get_frame_saved_regs (fi)[D10V_FP_REGNUM])
d708 2
a709 2
      if (!get_frame_saved_regs (fi)[D10V_SP_REGNUM]
	  || get_frame_saved_regs (fi)[D10V_SP_REGNUM] == D10V_STACK_START)
d712 1
a712 1
      return get_frame_saved_regs (fi)[D10V_SP_REGNUM];
d715 2
a716 2
  addr = read_memory_unsigned_integer (get_frame_saved_regs (fi)[D10V_FP_REGNUM],
				       REGISTER_RAW_SIZE (D10V_FP_REGNUM));
d872 1
a872 1
  if (get_frame_saved_regs (fi)[D10V_LR_REGNUM])
d875 2
a876 2
	= read_memory_unsigned_integer (get_frame_saved_regs (fi)[D10V_LR_REGNUM], 
					REGISTER_RAW_SIZE (D10V_LR_REGNUM));
d881 1
a881 1
      get_frame_extra_info (fi)->return_pc = d10v_make_iaddr (read_register (D10V_LR_REGNUM));
d885 1
a885 1
  if (!get_frame_saved_regs (fi)[D10V_SP_REGNUM])
d890 1
a890 1
	get_frame_saved_regs (fi)[D10V_SP_REGNUM] 
d894 1
a894 1
	  get_frame_saved_regs (fi)[D10V_SP_REGNUM] = fp + get_frame_extra_info (fi)->size;
d896 1
a896 1
	  get_frame_saved_regs (fi)[D10V_FP_REGNUM] = 0;
d928 3
a930 3
		   (long) read_register (D10V_PC_REGNUM),
		   (long) d10v_make_iaddr (read_register (D10V_PC_REGNUM)),
		   (long) read_register (D10V_PSW_REGNUM),
d952 1
a952 1
  for (a = 0; a < D10V_NR_IMAP_REGS; a++)
d968 2
a969 2
  printf_filtered ("A0-A%d", D10V_NR_A_REGS - 1);
  for (a = d10v_a0_regnum (current_gdbarch); a < d10v_a0_regnum (current_gdbarch) + D10V_NR_A_REGS; a++)
d992 1
a992 1
  pc = (int) read_register (D10V_PC_REGNUM);
d1005 1
a1005 1
  write_register (D10V_PC_REGNUM, d10v_convert_iaddr_to_raw (val));
d1009 1
a1009 1
CORE_ADDR
d1012 1
a1012 1
  return (d10v_make_daddr (read_register (D10V_SP_REGNUM)));
d1018 1
a1018 1
  write_register (D10V_SP_REGNUM, d10v_convert_daddr_to_raw (val));
d1021 1
a1021 1
CORE_ADDR
d1024 1
a1024 1
  return (d10v_make_daddr (read_register (D10V_FP_REGNUM)));
d1034 1
a1034 1
  write_register (D10V_LR_REGNUM, d10v_convert_iaddr_to_raw (CALL_DUMMY_ADDRESS ()));
d1080 1
a1080 1
  int regnum = D10V_ARG1_REGNUM;
d1102 1
a1102 1
      if (len <= 2 && regnum <= D10V_ARGN_REGNUM)
d1108 1
a1108 1
      else if (len <= (D10V_ARGN_REGNUM - aligned_regnum + 1) * 2)
d1128 1
a1128 1
	  regnum = D10V_ARGN_REGNUM + 1;
d1154 3
a1156 3
	 TYPE_LENGTH (type), D10V_RET1_REGNUM - R0_REGNUM, 
	 (int) extract_unsigned_integer (regbuf + REGISTER_BYTE(D10V_RET1_REGNUM), 
					 REGISTER_RAW_SIZE (D10V_RET1_REGNUM)));
d1341 1
a1341 1
  last_pc = read_register (D10V_PC_REGNUM);
d1523 4
d1623 1
a1646 2

  frame_unwind_append_predicate (gdbarch, d10v_frame_p);
@


1.69.2.3
log
@2003-01-19  Andrew Cagney  <ac131313@@redhat.com>

	* d10v-frame.c: Use D10V_RET1_REGNUM.
	(saved_regs_unwinder): Don't use get_frame_saved_regs.
	* frame.c (get_prev_frame): Always initialize frame.frame.
	(get_frame_base): Return frame.frame.
@
text
@d462 1
a462 1
      regcache_cooked_write (regcache, D10V_RET1_REGNUM, tmp);
d474 1
a474 1
	  regcache_cooked_write (regcache, D10V_RET1_REGNUM + reg,
d492 2
a493 2
  regcache_cooked_read_unsigned (regcache, D10V_ARG1_REGNUM, &addr);
  return (addr | D10V_DMEM_START);
d1096 1
a1096 1
      regcache_cooked_read_unsigned (regcache, D10V_RET1_REGNUM, &c);
d1106 1
a1106 1
      int reg = D10V_RET1_REGNUM;
d1110 1
a1110 1
	  regcache_cooked_read_part (regcache, D10V_RET1_REGNUM, 1, 1,
d1118 1
a1118 1
	  regcache_cooked_read (regcache, D10V_RET1_REGNUM + reg,
@


1.69.2.4
log
@Merge branch with mainline:
POP_FRAME_P;
frame-unwind.h.
@
text
@d87 2
d513 9
d1554 2
@


1.68
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_extra_info.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, ia64-tdep.c, m68hc11-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10300-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, xstormy16-tdep.c: Ditto.
@
text
@d910 2
a911 1
  if (get_frame_pc (fi) == 0 && fi->level != 0 && get_next_frame (fi) != NULL)
@


1.67
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_next_frame.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10200-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, sparc-tdep.c: Ditto.
	* v850-tdep.c, vax-tdep.c, x86-64-linux-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
@
text
@d515 1
a515 1
    return ((frame)->extra_info->return_pc);
d573 1
a573 1
  write_register (SP_REGNUM, fp + fi->extra_info->size);
d693 2
a694 2
  if (fi->extra_info->return_pc == IMEM_START
      || inside_entry_file (fi->extra_info->return_pc))
d698 1
a698 1
      if (!DEPRECATED_PC_IN_CALL_DUMMY (fi->extra_info->return_pc, 0, 0))
d857 1
a857 1
  fi->extra_info->size = -next_addr;
d873 1
a873 1
      fi->extra_info->return_pc = d10v_make_iaddr (return_pc);
d877 1
a877 1
      fi->extra_info->return_pc = d10v_make_iaddr (read_register (LR_REGNUM));
d887 1
a887 1
	  = d10v_read_fp () + fi->extra_info->size;
d890 2
a891 2
	  get_frame_saved_regs (fi)[SP_REGNUM] = fp + fi->extra_info->size;
	  fi->extra_info->frameless = 1;
d903 3
a905 3
  fi->extra_info->frameless = 0;
  fi->extra_info->size = 0;
  fi->extra_info->return_pc = 0;
@


1.66
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_base.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10200-tdep.c: Ditto.
	* mn10300-tdep.c, ns32k-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c: Ditto.
	* x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* config/h8500/tm-h8500.h, config/mn10200/tm-mn10200.h: Ditto.
	* config/sparc/tm-sparc.h: Ditto.
@
text
@d910 2
a911 2
  if (get_frame_pc (fi) == 0 && fi->level != 0 && fi->next != NULL)
    deprecated_update_frame_pc_hack (fi, d10v_frame_saved_pc (fi->next));
@


1.65
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_init_extra_frame_info): Allocate
	extra_info using frame_extra_info_zalloc.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	* sh-tdep.c (sh_init_extra_frame_info): Ditto.
	(sh64_init_extra_frame_info): Ditto.
	* mn10300-tdep.c (mn10300_init_extra_frame_info): Ditto.
	* s390-tdep.c (s390_init_extra_frame_info): Ditto.
	* mips-tdep.c (mips_init_extra_frame_info): Ditto.
	* mcore-tdep.c (mcore_init_extra_frame_info): Ditto.
	* frv-tdep.c (frv_init_extra_frame_info): Ditto.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Ditto.
	* ia64-tdep.c (ia64_init_extra_frame_info): Ditto.
	* h8300-tdep.c (h8300_init_extra_frame_info): Ditto.
	* d10v-tdep.c (d10v_init_extra_frame_info): Ditto.
	* cris-tdep.c (cris_init_extra_frame_info): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.
	* alpha-tdep.c (alpha_init_extra_frame_info): Ditto.

	* mn10300-tdep.c (analyze_dummy_frame): Use
	deprecated_set_frame_extra_info_hack.
	* mcore-tdep.c (analyze_dummy_frame): Ditto.
@
text
@d508 3
a510 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), frame->frame, frame->frame))
d512 1
a512 1
							    frame->frame, 
d686 3
a688 2
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), fi->frame, fi->frame))
    return fi->frame;
d800 1
a800 1
  fp = fi->frame;
d915 2
a916 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), fi->frame, fi->frame))
@


1.64
log
@2003-01-06  Andrew Cagney  <cagney@@redhat.com>

	* MAINTAINERS (Target Instruction Set Architectures): Update
	arm-elf.  Can be built with -Werror, has been multiarched.

	* value.h (unpack_long): Make buffer parameter constant.
	(unpack_double, unpack_pointer, unpack_field_as_long): Ditto.
	* scm-lang.h (scm_parse): Ditto.
	* defs.h (extract_typed_address, extract_address): Ditto.
	(extract_long_unsigned_integer): Ditto.
	* inferior.h (unsigned_pointer_to_address): Ditto.
	(signed_pointer_to_address): Ditto.
	* gdbarch.sh (POINTER_TO_ADDRESS): Ditto.
	* gdbarch.h, gdbarch.c: Regenerate.
	* findvar.c (extract_long_unsigned_integer): Update.
	(extract_address): Update.
	(extract_typed_address): Update.
	(unsigned_pointer_to_address): Update.
	* values.c (unpack_long): Update.
	(unpack_double): Update.
	(unpack_pointer): Update.
	(unpack_field_as_long): Update.
	* d10v-tdep.c (d10v_pointer_to_address): Update.
	* avr-tdep.c (avr_pointer_to_address): Update.
	* scm-lang.c (scm_unpack): Update.
	* findvar.c (signed_pointer_to_address): Update.
@
text
@d897 1
a897 2
  fi->extra_info = (struct frame_extra_info *)
    frame_obstack_alloc (sizeof (struct frame_extra_info));
@


1.63
log
@	* arm-tdep.c (arm_frame_chain_valid):  Remove unnecessary test.
	* d10v-tdep.c (d10v_frame_chain_valid): Remove unnecessary tests.
	* hppa-tdep.c (hppa_frame_chain_valid): Remove unnecessary test.

	* blockframe.c: Include "gdbcmd.h" and "command.h".
	(backtrace_below_main): New variable.
	(file_frame_chain_valid, func_frame_chain_valid)
	(nonnull_frame_chain_valid, generic_file_frame_chain_valid)
	(generic_func_frame_chain_valid): Remove functions.
	(frame_chain_valid, do_flush_frames_sfunc): New functions.
	(_initialize_blockframe): New function.
	* Makefile.in (blockframe.o): Update dependencies.
	* frame.c (frame_saved_regs_id_unwind, get_prev_frame): Remove FIXME
	comment.  Call frame_chain_valid ().
	* frame.h: Remove old prototypes.  Add prototype for
	frame_chain_valid and update comments to match.
	* gdbarch.sh: Change FRAME_CHAIN_VALID into a predicated function.
	Remove old comment.
	* gdbarch.h: Regenerated.
	* gdbarch.c: Regenerated.

Plus updates to all other targets not to provide a FRAME_CHAIN_VALID.
@
text
@d432 1
a432 1
d10v_pointer_to_address (struct type *type, void *buf)
@


1.62
log
@2003-01-03  Andrew Cagney  <ac131313@@redhat.com>

	* alpha-tdep.c: Use get_frame_saved_regs.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, xstormy16-tdep.c: Ditto.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software
d115 1
a115 8
  if (chain != 0 && frame != NULL)
    {
      if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), frame->frame, frame->frame))
	return 1;	/* Path back from a call dummy must be valid. */
      return (get_frame_pc (frame) > IMEM_START
	      && !inside_main_func (get_frame_pc (frame)));
    }
  else return 0;
@


1.61
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c: Use get_frame_pc and deprecated_update_frame_pc_hack
	frame accessor methods.
	* alpha-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Ditto.
	* s390-tdep.c, sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* z8k-tdep.c: Ditto.
@
text
@d558 1
a558 1
      if (fi->saved_regs[regnum])
d560 1
a560 1
	  read_memory (fi->saved_regs[regnum], raw_buffer, REGISTER_RAW_SIZE (regnum));
d567 1
a567 1
      if (fi->saved_regs[regnum])
d569 1
a569 1
	  write_register (regnum, read_memory_unsigned_integer (fi->saved_regs[regnum], REGISTER_RAW_SIZE (regnum)));
d572 1
a572 1
  if (fi->saved_regs[PSW_REGNUM])
d574 1
a574 1
      write_register (PSW_REGNUM, read_memory_unsigned_integer (fi->saved_regs[PSW_REGNUM], REGISTER_RAW_SIZE (PSW_REGNUM)));
d706 1
a706 1
  if (!fi->saved_regs[FP_REGNUM])
d708 2
a709 2
      if (!fi->saved_regs[SP_REGNUM]
	  || fi->saved_regs[SP_REGNUM] == STACK_START)
d712 1
a712 1
      return fi->saved_regs[SP_REGNUM];
d715 1
a715 1
  addr = read_memory_unsigned_integer (fi->saved_regs[FP_REGNUM],
d735 1
a735 1
      fi->saved_regs[n] = next_addr;
d744 2
a745 2
      fi->saved_regs[n] = next_addr;
      fi->saved_regs[n + 1] = next_addr + 2;
d774 1
a774 1
      fi->saved_regs[n] = next_addr;
d782 2
a783 2
      fi->saved_regs[n] = next_addr;
      fi->saved_regs[n + 1] = next_addr + 2;
d805 1
a805 1
  memset (fi->saved_regs, 0, SIZEOF_FRAME_SAVED_REGS);
d828 1
a828 1
	      fi->saved_regs[n] = next_addr + offset;
d835 2
a836 2
	      fi->saved_regs[n] = next_addr + offset;
	      fi->saved_regs[n + 1] = next_addr + offset + 2;
d867 1
a867 1
    if (fi->saved_regs[i])
d869 1
a869 1
	fi->saved_regs[i] = fp - (next_addr - fi->saved_regs[i]);
d872 1
a872 1
  if (fi->saved_regs[LR_REGNUM])
d875 1
a875 1
	= read_memory_unsigned_integer (fi->saved_regs[LR_REGNUM], 
d885 1
a885 1
  if (!fi->saved_regs[SP_REGNUM])
d890 1
a890 1
	fi->saved_regs[SP_REGNUM] 
d894 1
a894 1
	  fi->saved_regs[SP_REGNUM] = fp + fi->extra_info->size;
d896 1
a896 1
	  fi->saved_regs[FP_REGNUM] = 0;
@


1.60
log
@2002-12-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
	Change to a function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Update.  Test
	DEPRECATED_INIT_FRAME_PC_P.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/mn10200/tm-mn10200.h (DEPRECATED_INIT_FRAME_PC): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* arm-tdep.c: Update comments.
	* h8300-tdep.c (h8300_gdbarch_init): Explicitly set init_frame_pc.
	* config/m32r/tm-m32r.h (DEPRECATED_INIT_FRAME_PC): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC_FIRST): Delete macro.
	(DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
@
text
@d117 1
a117 1
      if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d119 2
a120 2
      return ((frame)->pc > IMEM_START
	      && !inside_main_func (frame->pc));
d515 2
a516 2
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
    return d10v_make_iaddr (deprecated_read_register_dummy (frame->pc, 
d691 1
a691 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d808 1
a808 1
  pc = get_pc_function_start (fi->pc);
d912 1
a912 1
  /* If fi->pc is zero, but this is not the outermost frame, 
d915 2
a916 2
  if (fi->pc == 0 && fi->level != 0 && fi->next != NULL)
    fi->pc = d10v_frame_saved_pc (fi->next);
d920 1
a920 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
@


1.59
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d680 4
a683 4
/* Given a GDB frame, determine the address of the calling function's frame.
   This will be used to create a new GDB frame struct, and then
   INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.
 */
d1520 4
@


1.58
log
@2002-11-27  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_LOCATION): Default to AT_ENTRY_POINT.
	(USE_GENERIC_DUMMY_FRAMES): Default to true.
	(PC_IN_CALL_DUMMY): Default to generic_pc_in_call_dummy.
	* gdbarch.c, gdbarch.h: Re-generate.
	* inferior.h (USE_GENERIC_DUMMY_FRAMES): Delete macro definition.
	(CALL_DUMMY_LOCATION): Delete macro definition.
	(PC_IN_CALL_DUMMY): Delete macro definitions.

	* arm-tdep.c (arm_gdbarch_init): Do not set pc_in_call_dummy,
	default is already generic_pc_in_call_dummy.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* arm-tdep.c (arm_gdbarch_init): Do not set
	use_generic_dummy_frames, default is already 1.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_location, default is already AT_ENTRY_POINT.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d117 1
a117 1
      if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d515 1
a515 1
  if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d691 1
a691 1
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d702 1
a702 1
      if (!PC_IN_CALL_DUMMY (fi->extra_info->return_pc, 0, 0))
d914 1
a914 1
     PC_IN_CALL_DUMMY will work.  */
d920 1
a920 1
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
@


1.57
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@a1594 1
  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);
a1595 1
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
a1599 1
  set_gdbarch_pc_in_call_dummy (gdbarch, generic_pc_in_call_dummy);
@


1.56
log
@2002-11-22  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_ADDRESS, FRAME_LOCALS_ADDRESS): Default
	to default_frame_address.
	* gdbarch.h, gdbarch.c: Re-generate.

	* d10v-tdep.c (d10v_gdbarch_init): Do not set frame_args_address
	or frame_locals_address to default_frame_address.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.

	* cris-tdep.c (cris_frame_args_address): Delete function.
	(cris_frame_locals_address): Delete function.
	(cris_gdbarch_init): Do not set frame_args_address or
	frame_locals_address.
@
text
@d550 1
a550 1
  fp = FRAME_FP (fi);
@


1.55
log
@2002-11-15  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (generic_unwind_get_saved_register): Make static.
	* frame.h (generic_unwind_get_saved_register): Delete declaration.
	* avr-tdep.c (avr_gdbarch_init): Do not set get_saved_register,
	defaults to generic_unwind_get_saved_register.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* config/mn10200/tm-mn10200.h (GET_SAVED_REGISTER): Delete macro.
@
text
@d1637 1
a1637 2
  set_gdbarch_frame_args_address (gdbarch, default_frame_address);
  set_gdbarch_frame_locals_address (gdbarch, default_frame_address);
@


1.54
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@a1606 1
  set_gdbarch_get_saved_register (gdbarch, generic_unwind_get_saved_register);
@


1.53
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@d489 5
a493 4
      write_register_bytes (REGISTER_BYTE (RET1_REGNUM),
			    &tmp, 1);	/* zero the high byte */
      write_register_bytes (REGISTER_BYTE (RET1_REGNUM) + 1,
			    valbuf, 1);	/* copy the low byte */
d496 2
a497 3
    write_register_bytes (REGISTER_BYTE (RET1_REGNUM),
			  valbuf,
			  TYPE_LENGTH (type));
d561 2
a562 1
	  write_register_bytes (REGISTER_BYTE (regnum), raw_buffer, REGISTER_RAW_SIZE (regnum));
@


1.52
log
@2002-09-17  Andrew Cagney  <cagney@@redhat.com>

	* h8300-tdep.c (h8300_frame_chain):
	(h8300_frame_saved_pc):

	* blockframe.c (deprecated_read_register_dummy): Rename
	generic_read_register_dummy.
	* frame.c (frame_unwind_signed_register): New function.
	(frame_unwind_unsigned_register): New function.
	* frame.h (frame_unwind_signed_register): Declare.
	(frame_unwind_unsigned_register): Declare.
	(deprecated_read_register_dummy): Rename
	generic_read_register_dummy.

	* xstormy16-tdep.c (xstormy16_frame_saved_pc): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	* s390-tdep.c (s390_frame_saved_pc_nofix): Update.
	(s390_frame_chain): Update.
	* v850-tdep.c (v850_find_callers_reg): Update.
	(v850_frame_saved_pc): Update.
	* m32r-tdep.c (m32r_init_extra_frame_info): Update.
	(m32r_find_callers_reg): Update.
	(m32r_frame_saved_pc): Update.
	* sh-tdep.c (sh_find_callers_reg): Update.
	(sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info): Update.
	(sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* mcore-tdep.c (mcore_find_callers_reg): Update.
	(mcore_frame_saved_pc): Update.
	(mcore_init_extra_frame_info): Update.
	* i386-tdep.c (i386_frame_saved_pc): Update.
	* ia64-tdep.c (ia64_frame_saved_pc): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_init_extra_frame_info): Update.
	* d10v-tdep.c (d10v_frame_saved_pc): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_frame_chain): Update.
	(avr_init_extra_frame_info): Update.
	(avr_frame_saved_pc): Update.
	* arm-tdep.c (arm_find_callers_reg): Update.
	(arm_init_extra_frame_info): Update.
	(arm_frame_saved_pc): Update.
@
text
@d980 1
a980 1
      read_register_gen (a, (char *) &num);
@


1.52.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 1
a1 1
/* Target-dependent code for Renesas D10V, for GDB.
d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
a26 2
#include "frame-unwind.h"
#include "frame-base.h"
d40 1
a40 1
#include "remote.h"
a43 2
#include "disasm.h"
#include "trad-frame.h"
d45 6
a50 1
#include "gdb_assert.h"
d56 2
a57 2
    unsigned long (*dmap_register) (void *regcache, int nr);
    unsigned long (*imap_register) (void *regcache, int nr);
d61 1
a61 1
   instruction memory to.  */
d69 1
a69 1
/* d10v register names.  */
d75 1
a75 1
    D10V_FP_REGNUM = 11,
d77 1
a77 1
    D10V_SP_REGNUM = 15,
d79 1
a79 1
    D10V_PC_REGNUM = 18,
d84 1
a84 1
    /* d10v calling convention.  */
d86 2
a87 1
    ARGN_REGNUM = R3_REGNUM
d90 2
a91 11
static int
nr_dmap_regs (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->nr_dmap_regs;
}

static int
a0_regnum (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->a0_regnum;
}
d97 4
d105 20
d126 14
a139 1
d10v_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
d141 25
a165 3
  /* Align to the size of an instruction (so that they can safely be
     pushed onto the stack.  */
  return sp & ~3;
d168 1
d179 1
a179 1
   when the reg_nr isn't valid.  */
d252 1
a252 1
d10v_ts2_dmap_register (void *regcache, int reg_nr)
d260 1
a260 5
      {
	ULONGEST reg;
	regcache_cooked_read_unsigned (regcache, TS2_DMAP_REGNUM, &reg);
	return reg;
      }
d267 1
a267 1
d10v_ts3_dmap_register (void *regcache, int reg_nr)
d269 1
a269 3
  ULONGEST reg;
  regcache_cooked_read_unsigned (regcache, TS3_DMAP0_REGNUM + reg_nr, &reg);
  return reg;
d273 1
a273 1
d10v_ts2_imap_register (void *regcache, int reg_nr)
d275 1
a275 3
  ULONGEST reg;
  regcache_cooked_read_unsigned (regcache, TS2_IMAP0_REGNUM + reg_nr, &reg);
  return reg;
d279 1
a279 1
d10v_ts3_imap_register (void *regcache, int reg_nr)
d281 1
a281 3
  ULONGEST reg;
  regcache_cooked_read_unsigned (regcache, TS3_IMAP0_REGNUM + reg_nr, &reg);
  return reg;
d284 15
a298 3
/* MAP GDB's internal register numbering (determined by the layout
   from the DEPRECATED_REGISTER_BYTE array) onto the simulator's
   register numbering.  */
d303 2
a304 2
  /* Only makes sense to supply raw registers.  */
  gdb_assert (nr >= 0 && nr < NUM_REGS);
d319 2
a320 2
  /* Only makes sense to supply raw registers.  */
  gdb_assert (nr >= 0 && nr < NUM_REGS);
d333 31
d368 1
a368 1
d10v_register_type (struct gdbarch *gdbarch, int reg_nr)
d370 1
a370 1
  if (reg_nr == D10V_PC_REGNUM)
d372 1
a372 1
  if (reg_nr == D10V_SP_REGNUM || reg_nr == D10V_FP_REGNUM)
d374 2
a375 2
  else if (reg_nr >= a0_regnum (gdbarch)
	   && reg_nr < (a0_regnum (gdbarch) + NR_A_REGS))
d403 1
a403 1
    return x;	/* Idempotency -- x is already in the IMEM space.  */
d439 1
a439 1
d10v_pointer_to_address (struct type *type, const void *buf)
d441 2
a442 1
  CORE_ADDR addr = extract_unsigned_integer (buf, TYPE_LENGTH (type));
d464 72
a535 1
/* Handle the d10v's return_value convention.  */
d537 17
a553 27
static enum return_value_convention
d10v_return_value (struct gdbarch *gdbarch, struct type *valtype,
		   struct regcache *regcache, void *readbuf,
		   const void *writebuf)
{
  if (TYPE_LENGTH (valtype) > 8)
    /* Anything larger than 8 bytes (4 registers) goes on the stack.  */
    return RETURN_VALUE_STRUCT_CONVENTION;
  if (TYPE_LENGTH (valtype) == 5
      || TYPE_LENGTH (valtype) == 6)
    /* Anything 5 or 6 bytes in size goes in memory.  Contents don't
       appear to matter.  Note that 7 and 8 byte objects do end up in
       registers!  */
    return RETURN_VALUE_STRUCT_CONVENTION;
  if (TYPE_LENGTH (valtype) == 1)
    {
      /* All single byte values go in a register stored right-aligned.
         Note: 2 byte integer values are handled further down.  */
      if (readbuf)
	{
	  /* Since TYPE is smaller than the register, there isn't a
             sign extension problem.  Let the extraction truncate the
             register value.  */
	  ULONGEST regval;
	  regcache_cooked_read_unsigned (regcache, R0_REGNUM,
					 &regval);
	  store_unsigned_integer (readbuf, TYPE_LENGTH (valtype), regval);
d555 4
a558 2
	}
      if (writebuf)
d560 2
a561 11
	  ULONGEST regval;
	  if (TYPE_CODE (valtype) == TYPE_CODE_INT)
	    /* Some sort of integer value stored in R0.  Use
	       unpack_long since that should handle any required sign
	       extension.  */
	    regval = unpack_long (valtype, writebuf);
	  else
	    /* Some other type.  Don't sign-extend the value when
               storing it in the register.  */
	    regval = extract_unsigned_integer (writebuf, 1);
	  regcache_cooked_write_unsigned (regcache, R0_REGNUM, regval);
a562 1
      return RETURN_VALUE_REGISTER_CONVENTION;
d564 3
a566 15
  if ((TYPE_CODE (valtype) == TYPE_CODE_STRUCT
       || TYPE_CODE (valtype) == TYPE_CODE_UNION)
      && TYPE_NFIELDS (valtype) > 1
      && TYPE_FIELD_BITPOS (valtype, 1) == 8)
    /* If a composite is 8 bit aligned (determined by looking at the
       start address of the second field), put it in memory.  */
    return RETURN_VALUE_STRUCT_CONVENTION;
  /* Assume it is in registers.  */
  if (writebuf || readbuf)
    {
      int reg;
      /* Per above, the value is never more than 8 bytes long.  */
      gdb_assert (TYPE_LENGTH (valtype) <= 8);
      /* Xfer 2 bytes at a time.  */
      for (reg = 0; (reg * 2) + 1 < TYPE_LENGTH (valtype); reg++)
d568 1
a568 16
	  if (readbuf)
	    regcache_cooked_read (regcache, R0_REGNUM + reg,
				  (bfd_byte *) readbuf + reg * 2);
	  if (writebuf)
	    regcache_cooked_write (regcache, R0_REGNUM + reg,
				   (bfd_byte *) writebuf + reg * 2);
	}
      /* Any trailing byte ends up _left_ aligned.  */
      if ((reg * 2) < TYPE_LENGTH (valtype))
	{
	  if (readbuf)
	    regcache_cooked_read_part (regcache, R0_REGNUM + reg,
				       0, 1, (bfd_byte *) readbuf + reg * 2);
	  if (writebuf)
	    regcache_cooked_write_part (regcache, R0_REGNUM + reg,
					0, 1, (bfd_byte *) writebuf + reg * 2);
d571 9
a579 1
  return RETURN_VALUE_REGISTER_CONVENTION;
d624 2
a625 2
  /* If we have line debugging information, then the end of the prologue 
     should be the first assembly instruction of the first source line.  */
d634 1
a634 1
    return pc;			/* Can't access it -- assume no prologue.  */
d664 2
a665 3
		  /* If the previous opcode was really part of the
		     prologue and not just a NOP, then we want to
		     break after both instructions.  */
d679 7
a685 1
struct d10v_unwind_cache
d687 36
a722 15
  /* The previous frame's inner most stack address.  Used as this
     frame ID's stack_addr.  */
  CORE_ADDR prev_sp;
  /* The frame's base, optionally used by the high-level debug info.  */
  CORE_ADDR base;
  int size;
  /* How far the SP and r11 (FP) have been offset from the start of
     the stack frame (as defined by the previous frame's stack
     pointer).  */
  LONGEST sp_offset;
  LONGEST r11_offset;
  int uses_frame;
  /* Table indicating the location of each and every register.  */
  struct trad_frame_saved_reg *saved_regs;
};
d725 1
a725 2
prologue_find_regs (struct d10v_unwind_cache *info, unsigned short op,
		    CORE_ADDR addr)
d733 2
a734 2
      info->sp_offset -= 2;
      info->saved_regs[n].addr = info->sp_offset;
d742 3
a744 3
      info->sp_offset -= 4;
      info->saved_regs[n + 0].addr = info->sp_offset + 0;
      info->saved_regs[n + 1].addr = info->sp_offset + 2;
d754 1
a754 1
      info->sp_offset -= n;
d761 1
a761 10
      info->uses_frame = 1;
      info->r11_offset = info->sp_offset;
      return 1;
    }

  /* st  rn, @@r11 */
  if ((op & 0x7E1F) == 0x6816)
    {
      n = (op & 0x1E0) >> 5;
      info->saved_regs[n].addr = info->r11_offset;
d773 1
a773 1
      info->saved_regs[n].addr = info->sp_offset;
d781 2
a782 2
      info->saved_regs[n + 0].addr = info->sp_offset + 0;
      info->saved_regs[n + 1].addr = info->sp_offset + 2;
d793 1
a793 1
   for it IS the sp for the next frame.  */
d795 2
a796 3
static struct d10v_unwind_cache *
d10v_frame_unwind_cache (struct frame_info *next_frame,
			 void **this_prologue_cache)
d798 1
a798 4
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  CORE_ADDR pc;
  ULONGEST prev_sp;
  ULONGEST this_base;
a801 1
  struct d10v_unwind_cache *info;
d803 3
a805 2
  if ((*this_prologue_cache))
    return (*this_prologue_cache);
d807 1
a807 3
  info = FRAME_OBSTACK_ZALLOC (struct d10v_unwind_cache);
  (*this_prologue_cache) = info;
  info->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d809 2
a810 7
  info->size = 0;
  info->sp_offset = 0;

  info->uses_frame = 0;
  for (pc = frame_func_unwind (next_frame);
       pc > 0 && pc < frame_pc_unwind (next_frame);
       pc += 4)
d812 1
a812 1
      op = get_frame_memory_unsigned (next_frame, pc, 4);
d820 1
a820 1
	      info->sp_offset += n;
d827 1
a827 1
	      info->saved_regs[n].addr = info->sp_offset + offset;
d834 2
a835 2
	      info->saved_regs[n + 0].addr = info->sp_offset + offset + 0;
	      info->saved_regs[n + 1].addr = info->sp_offset + offset + 2;
d853 2
a854 2
	  if (!prologue_find_regs (info, op1, pc) 
	      || !prologue_find_regs (info, op2, pc))
d857 1
d860 1
a860 21
  info->size = -info->sp_offset;

  /* Compute the previous frame's stack pointer (which is also the
     frame's ID's stack address), and this frame's base pointer.  */
  if (info->uses_frame)
    {
      /* The SP was moved to the FP.  This indicates that a new frame
         was created.  Get THIS frame's FP value by unwinding it from
         the next frame.  */
      frame_unwind_unsigned_register (next_frame, D10V_FP_REGNUM, &this_base);
      /* The FP points at the last saved register.  Adjust the FP back
         to before the first saved register giving the SP.  */
      prev_sp = this_base + info->size;
    }
  else
    {
      /* Assume that the FP is this frame's SP but with that pushed
         stack space added back.  */
      frame_unwind_unsigned_register (next_frame, D10V_SP_REGNUM, &this_base);
      prev_sp = this_base + info->size;
    }
d862 2
a863 3
  /* Convert that SP/BASE into real addresses.  */
  info->prev_sp =  d10v_make_daddr (prev_sp);
  info->base = d10v_make_daddr (this_base);
a864 2
  /* Adjust all the saved registers so that they contain addresses and
     not offsets.  */
d866 1
a866 1
    if (trad_frame_addr_p (info->saved_regs, i))
d868 1
a868 1
	info->saved_regs[i].addr = (info->prev_sp + info->saved_regs[i].addr);
d871 11
a881 10
  /* The call instruction moves the caller's PC in the callee's LR.
     Since this is an unwind, do the reverse.  Copy the location of LR
     into PC (the address / regnum) so that a request for PC will be
     converted into a request for the LR.  */
  info->saved_regs[D10V_PC_REGNUM] = info->saved_regs[LR_REGNUM];

  /* The previous frame's SP needed to be computed.  Save the computed
     value.  */
  trad_frame_set_value (info->saved_regs, D10V_SP_REGNUM,
			d10v_make_daddr (prev_sp));
d883 15
a897 1
  return info;
d901 1
a901 2
d10v_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file,
			   struct frame_info *frame, int regnum, int all)
d903 17
a919 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  if (regnum >= 0)
a920 1
      default_print_registers_info (gdbarch, file, frame, regnum, all);
d923 4
a926 72

  {
    ULONGEST pc, psw, rpt_s, rpt_e, rpt_c;
    pc = get_frame_register_unsigned (frame, D10V_PC_REGNUM);
    psw = get_frame_register_unsigned (frame, PSW_REGNUM);
    rpt_s = get_frame_register_unsigned (frame, frame_map_name_to_regnum (frame, "rpt_s", -1));
    rpt_e = get_frame_register_unsigned (frame, frame_map_name_to_regnum (frame, "rpt_e", -1));
    rpt_c = get_frame_register_unsigned (frame, frame_map_name_to_regnum (frame, "rpt_c", -1));
    fprintf_filtered (file, "PC=%04lx (0x%lx) PSW=%04lx RPT_S=%04lx RPT_E=%04lx RPT_C=%04lx\n",
		     (long) pc, (long) d10v_make_iaddr (pc), (long) psw,
		     (long) rpt_s, (long) rpt_e, (long) rpt_c);
  }

  {
    int group;
    for (group = 0; group < 16; group += 8)
      {
	int r;
	fprintf_filtered (file, "R%d-R%-2d", group, group + 7);
	for (r = group; r < group + 8; r++)
	  {
	    ULONGEST tmp;
	    tmp = get_frame_register_unsigned (frame, r);
	    fprintf_filtered (file, " %04lx", (long) tmp);
	  }
	fprintf_filtered (file, "\n");
      }
  }

  /* Note: The IMAP/DMAP registers don't participate in function
     calls.  Don't bother trying to unwind them.  */

  {
    int a;
    for (a = 0; a < NR_IMAP_REGS; a++)
      {
	if (a > 0)
	  fprintf_filtered (file, "    ");
	fprintf_filtered (file, "IMAP%d %04lx", a,
			  tdep->imap_register (current_regcache, a));
      }
    if (nr_dmap_regs (gdbarch) == 1)
      /* Registers DMAP0 and DMAP1 are constant.  Just return dmap2.  */
      fprintf_filtered (file, "    DMAP %04lx\n",
			tdep->dmap_register (current_regcache, 2));
    else
      {
	for (a = 0; a < nr_dmap_regs (gdbarch); a++)
	  {
	    fprintf_filtered (file, "    DMAP%d %04lx", a,
			      tdep->dmap_register (current_regcache, a));
	  }
	fprintf_filtered (file, "\n");
      }
  }

  {
    char num[MAX_REGISTER_SIZE];
    int a;
    fprintf_filtered (file, "A0-A%d", NR_A_REGS - 1);
    for (a = a0_regnum (gdbarch); a < a0_regnum (gdbarch) + NR_A_REGS; a++)
      {
	int i;
	fprintf_filtered (file, "  ");
	get_frame_register (frame, a, num);
	for (i = 0; i < register_size (gdbarch, a); i++)
	  {
	    fprintf_filtered (file, "%02x", (num[i] & 0xff));
	  }
      }
  }
  fprintf_filtered (file, "\n");
d932 55
a986 2
  d10v_print_registers_info (current_gdbarch, gdb_stdout,
			     get_current_frame (), -1, 1);
d998 1
a998 1
  pc = (int) read_register (D10V_PC_REGNUM);
d1011 1
a1011 1
  write_register (D10V_PC_REGNUM, d10v_convert_iaddr_to_raw (val));
d1016 7
a1022 1
d10v_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
d1024 1
a1024 3
  ULONGEST sp;
  frame_unwind_unsigned_register (next_frame, D10V_SP_REGNUM, &sp);
  return d10v_make_daddr (sp);
d1027 18
d1046 1
a1046 1
   order.  The below implements a FILO (stack) to do this.  */
d1082 2
a1083 23
d10v_push_dummy_code (struct gdbarch *gdbarch,
		      CORE_ADDR sp, CORE_ADDR funaddr, int using_gcc,
		      struct value **args, int nargs,
		      struct type *value_type,
		      CORE_ADDR *real_pc, CORE_ADDR *bp_addr)
{
  /* Allocate space sufficient for a breakpoint.  */
  sp = (sp - 4) & ~3;
  /* Store the address of that breakpoint taking care to first convert
     it into a code (IADDR) address from a stack (DADDR) address.
     This of course assumes that the two virtual addresses map onto
     the same real address.  */
  (*bp_addr) = d10v_make_iaddr (d10v_convert_iaddr_to_raw (sp));
  /* d10v always starts the call at the callee's entry point.  */
  (*real_pc) = funaddr;
  return sp;
}

static CORE_ADDR
d10v_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		      struct regcache *regcache, CORE_ADDR bp_addr,
		      int nargs, struct value **args, CORE_ADDR sp, 
		      int struct_return, CORE_ADDR struct_addr)
d1090 5
a1094 8
  /* Set the return address.  For the d10v, the return breakpoint is
     always at BP_ADDR.  */
  regcache_cooked_write_unsigned (regcache, LR_REGNUM,
				  d10v_convert_iaddr_to_raw (bp_addr));

  /* If STRUCT_RETURN is true, then the struct return address (in
     STRUCT_ADDR) will consume the first argument-passing register.
     Both adjust the register count and store that value.  */
d1096 1
a1096 4
    {
      regcache_cooked_write_unsigned (regcache, regnum, struct_addr);
      regnum++;
    }
d1112 1
a1112 1
	  regcache_cooked_write_unsigned (regcache, regnum++, val);
d1123 1
a1123 1
	      regcache_cooked_write_unsigned (regcache, regnum++, val);
d1128 1
a1128 1
	      regcache_cooked_write_unsigned (regcache, regnum++, (val << 8));
d1146 3
a1148 3
  /* Finally, update the SP register.  */
  regcache_cooked_write_unsigned (regcache, D10V_SP_REGNUM,
				  d10v_convert_daddr_to_raw (sp));
d1150 34
a1183 1
  return sp;
d1190 1
a1190 1
   VM system works, we just call that to do the translation.  */
d1193 1
a1193 3
remote_d10v_translate_xfer_address (struct gdbarch *gdbarch,
				    struct regcache *regcache,
				    CORE_ADDR memaddr, int nr_bytes,
a1195 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1198 4
a1201 2
  out_len = sim_d10v_translate_addr (memaddr, nr_bytes, &out_addr, regcache,
				     tdep->dmap_register, tdep->imap_register);
d1273 1
a1273 1
    trace_data.counts = XCALLOC (65536, short);
d1275 1
a1275 1
    trace_data.addrs = XCALLOC (65536, CORE_ADDR);
d1314 18
d1338 1
a1338 1
  last_pc = read_register (D10V_PC_REGNUM);
d1409 1
d1416 5
d1422 7
a1428 16
    { 
      char *space_index = strchr (arg, ' ');
      if (space_index == NULL)
	{
	  low = parse_and_eval_address (arg);
	  high = low + 5;
	}
      else
	{
	  /* Two arguments.  */
	  *space_index = '\0';
	  low = parse_and_eval_address (arg);
	  high = parse_and_eval_address (space_index + 1);
	  if (high < low)
	    high = low;
	}
d1431 1
a1431 2
  printf_filtered ("Dump of trace from %s to %s:\n", 
		   paddr_u (low), paddr_u (high));
d1489 1
a1489 1
	  next_address += gdb_print_insn (next_address, gdb_stdout);
a1495 88
static CORE_ADDR
d10v_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  ULONGEST pc;
  frame_unwind_unsigned_register (next_frame, D10V_PC_REGNUM, &pc);
  return d10v_make_iaddr (pc);
}

/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct.  */

static void
d10v_frame_this_id (struct frame_info *next_frame,
		    void **this_prologue_cache,
		    struct frame_id *this_id)
{
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_prologue_cache);
  CORE_ADDR base;
  CORE_ADDR func;
  struct frame_id id;

  /* The FUNC is easy.  */
  func = frame_func_unwind (next_frame);

  /* Hopefully the prologue analysis either correctly determined the
     frame's base (which is the SP from the previous frame), or set
     that base to "NULL".  */
  base = info->prev_sp;
  if (base == STACK_START || base == 0)
    return;

  id = frame_id_build (base, func);

  (*this_id) = id;
}

static void
d10v_frame_prev_register (struct frame_info *next_frame,
			  void **this_prologue_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *bufferp)
{
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_prologue_cache);
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, bufferp);
}

static const struct frame_unwind d10v_frame_unwind = {
  NORMAL_FRAME,
  d10v_frame_this_id,
  d10v_frame_prev_register
};

static const struct frame_unwind *
d10v_frame_sniffer (struct frame_info *next_frame)
{
  return &d10v_frame_unwind;
}

static CORE_ADDR
d10v_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_cache);
  return info->base;
}

static const struct frame_base d10v_frame_base = {
  &d10v_frame_unwind,
  d10v_frame_base_address,
  d10v_frame_base_address,
  d10v_frame_base_address
};

/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
   dummy frame.  The frame ID's base needs to match the TOS value
   saved by save_dummy_frame_tos(), and the PC match the dummy frame's
   breakpoint.  */

static struct frame_id
d10v_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_id_build (d10v_unwind_sp (gdbarch, next_frame),
			 frame_pc_unwind (next_frame));
}
d1502 2
d1510 1
a1510 1
  /* Find a candidate among the list of pre-declared architectures.  */
d1516 1
a1516 1
     provided.  */
d1545 3
a1547 1
  set_gdbarch_unwind_sp (gdbarch, d10v_unwind_sp);
d1550 3
a1552 1
  set_gdbarch_sp_regnum (gdbarch, D10V_SP_REGNUM);
d1554 8
a1561 1
  set_gdbarch_register_type (gdbarch, d10v_register_type);
d1573 1
a1573 1
     double'' is 64 bits.  */
d1587 1
a1587 2
      set_gdbarch_long_double_format (gdbarch, 
				      &floatformat_ieee_double_little);
d1594 29
a1622 3
  set_gdbarch_return_value (gdbarch, d10v_return_value);
  set_gdbarch_push_dummy_code (gdbarch, d10v_push_dummy_code);
  set_gdbarch_push_dummy_call (gdbarch, d10v_push_dummy_call);
d1630 1
a1630 2
  set_gdbarch_remote_translate_xfer_address (gdbarch, 
					     remote_d10v_translate_xfer_address);
d1633 9
a1641 4
  set_gdbarch_frameless_function_invocation (gdbarch, 
					     frameless_look_for_prologue);

  set_gdbarch_frame_align (gdbarch, d10v_frame_align);
d1644 1
d1646 2
a1647 12
  set_gdbarch_print_registers_info (gdbarch, d10v_print_registers_info);

  frame_unwind_append_sniffer (gdbarch, d10v_frame_sniffer);
  frame_base_set_default (gdbarch, &d10v_frame_base);

  /* Methods for saving / extracting a dummy frame's ID.  The ID's
     stack address must match the SP value returned by
     PUSH_DUMMY_CALL, and saved by generic_save_dummy_frame_tos.  */
  set_gdbarch_unwind_dummy_id (gdbarch, d10v_unwind_dummy_id);

  /* Return the unwound PC value.  */
  set_gdbarch_unwind_pc (gdbarch, d10v_unwind_pc);
a1648 1
  set_gdbarch_print_insn (gdbarch, print_insn_d10v);
d1650 2
a1651 2
  return gdbarch;
}
d1658 2
d1663 1
a1663 3
  deprecate_cmd (add_com ("regs", class_vars, show_regs, 
			  "Print all registers"),
		 "info registers");
d1679 9
a1687 9
  add_setshow_boolean_cmd ("itracedisplay", no_class, &trace_display,
			   "Set automatic display of trace.\n",
			   "Show automatic display of trace.\n",
			   NULL, NULL, &setlist, &showlist);
  add_setshow_boolean_cmd ("itracesource", no_class,
			   &default_trace_show_source,
			   "Set display of source code with trace.\n",
			   "Show display of source code with trace.\n",
			   NULL, NULL, &setlist, &showlist);
@


1.52.4.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d296 6
d1519 1
@


1.52.2.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d489 4
a492 5
      /* zero the high byte */
      deprecated_write_register_bytes (REGISTER_BYTE (RET1_REGNUM), &tmp, 1);
      /* copy the low byte */
      deprecated_write_register_bytes (REGISTER_BYTE (RET1_REGNUM) + 1,
				       valbuf, 1);
d495 3
a497 2
    deprecated_write_register_bytes (REGISTER_BYTE (RET1_REGNUM),
				     valbuf, TYPE_LENGTH (type));
d561 1
a561 2
	  deprecated_write_register_bytes (REGISTER_BYTE (regnum), raw_buffer,
					   REGISTER_RAW_SIZE (regnum));
d980 1
a980 1
      deprecated_read_register_gen (a, (char *) &num);
@


1.52.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d117 1
a117 1
      if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d515 1
a515 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d550 1
a550 1
  fp = get_frame_base (fi);
d680 4
a683 4
/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct, and
   then INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC will be
   called for the new frame.  */
d691 1
a691 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d702 1
a702 1
      if (!DEPRECATED_PC_IN_CALL_DUMMY (fi->extra_info->return_pc, 0, 0))
d914 1
a914 1
     DEPRECATED_PC_IN_CALL_DUMMY will work.  */
d920 1
a920 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
a1520 4
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_default);

d1595 1
d1597 1
d1602 1
d1607 1
d1638 2
a1639 1

@


1.52.2.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
a26 1
#include "frame-unwind.h"
a44 2
#include "gdb_assert.h"

d105 20
d439 1
a439 1
d10v_pointer_to_address (struct type *type, const void *buf)
d482 1
a482 2
d10v_store_return_value (struct type *type, struct regcache *regcache,
			 const void *valbuf)
d484 2
a485 2
  /* Only char return values need to be shifted right within the first
     regnum.  */
d489 5
a493 3
      bfd_byte tmp[2];
      tmp[1] = *(bfd_byte *)valbuf;
      regcache_cooked_write (regcache, RET1_REGNUM, tmp);
d496 2
a497 17
    {
      int reg;
      /* A structure is never more than 8 bytes long.  See
         use_struct_convention().  */
      gdb_assert (TYPE_LENGTH (type) <= 8);
      /* Write out most registers, stop loop before trying to write
         out any dangling byte at the end of the buffer.  */
      for (reg = 0; (reg * 2) + 1 < TYPE_LENGTH (type); reg++)
	{
	  regcache_cooked_write (regcache, RET1_REGNUM + reg,
				 (bfd_byte *) valbuf + reg * 2);
	}
      /* Write out any dangling byte at the end of the buffer.  */
      if ((reg * 2) + 1 == TYPE_LENGTH (type))
	regcache_cooked_write_part (regcache, reg, 0, 1,
				    (bfd_byte *) valbuf + reg * 2);
    }
d505 9
a513 1
d10v_extract_struct_value_address (struct regcache *regcache)
d515 6
a520 3
  ULONGEST addr;
  regcache_cooked_read_unsigned (regcache, ARG1_REGNUM, &addr);
  return (addr | DMEM_START);
d534 49
d680 7
a686 1
struct d10v_unwind_cache
d688 36
a723 8
  CORE_ADDR return_pc;
  int frameless;
  int size;
  CORE_ADDR *saved_regs;
  CORE_ADDR next_addr;
  int uses_frame;
  void **regs;
};
d726 1
a726 2
prologue_find_regs (struct d10v_unwind_cache *info, unsigned short op,
		    CORE_ADDR addr)
d734 2
a735 2
      info->next_addr -= 2;
      info->saved_regs[n] = info->next_addr;
d743 3
a745 3
      info->next_addr -= 4;
      info->saved_regs[n] = info->next_addr;
      info->saved_regs[n + 1] = info->next_addr + 2;
d755 1
a755 1
      info->next_addr -= n;
d762 1
a762 1
      info->uses_frame = 1;
d774 1
a774 1
      info->saved_regs[n] = info->next_addr;
d782 2
a783 2
      info->saved_regs[n] = info->next_addr;
      info->saved_regs[n + 1] = info->next_addr + 2;
d796 2
a797 3
struct d10v_unwind_cache *
d10v_frame_unwind_cache (struct frame_info *fi,
			 void **cache)
a802 12
  struct d10v_unwind_cache *info;

  if ((*cache))
    return (*cache);

  info = FRAME_OBSTACK_ZALLOC (struct d10v_unwind_cache);
  (*cache) = info;
  info->saved_regs = frame_obstack_zalloc (SIZEOF_FRAME_SAVED_REGS);

  info->frameless = 0;
  info->size = 0;
  info->return_pc = 0;
d804 3
a806 2
  fp = get_frame_base (fi);
  info->next_addr = 0;
d808 1
a808 1
  pc = get_pc_function_start (get_frame_pc (fi));
d810 1
a810 1
  info->uses_frame = 0;
d821 1
a821 1
	      info->next_addr += n;
d828 1
a828 1
	      info->saved_regs[n] = info->next_addr + offset;
d835 2
a836 2
	      info->saved_regs[n] = info->next_addr + offset;
	      info->saved_regs[n + 1] = info->next_addr + offset + 2;
d854 2
a855 2
	  if (!prologue_find_regs (info, op1, pc) 
	      || !prologue_find_regs (info, op2, pc))
d861 1
a861 1
  info->size = -info->next_addr;
d867 1
a867 1
    if (info->saved_regs[i])
d869 1
a869 1
	info->saved_regs[i] = fp - (info->next_addr - info->saved_regs[i]);
d872 1
a872 1
  if (info->saved_regs[LR_REGNUM])
d875 1
a875 1
	= read_memory_unsigned_integer (info->saved_regs[LR_REGNUM], 
d877 1
a877 1
      info->return_pc = d10v_make_iaddr (return_pc);
d881 1
a881 3
      ULONGEST return_pc;
      frame_read_unsigned_register (fi, LR_REGNUM, &return_pc);
      info->return_pc = d10v_make_iaddr (return_pc);
d885 1
a885 1
  if (!info->saved_regs[SP_REGNUM])
d889 3
a891 3
      if (info->uses_frame)
	info->saved_regs[SP_REGNUM] 
	  = d10v_read_fp () + info->size;
d894 3
a896 3
	  info->saved_regs[SP_REGNUM] = fp + info->size;
	  info->frameless = 1;
	  info->saved_regs[FP_REGNUM] = 0;
a898 2

  return info;
d902 1
a902 2
d10v_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file,
			   struct frame_info *frame, int regnum, int all)
d904 17
a920 1
  if (regnum >= 0)
a921 1
      default_print_registers_info (gdbarch, file, frame, regnum, all);
d924 4
a927 69

  {
    ULONGEST pc, psw, rpt_s, rpt_e, rpt_c;
    frame_read_unsigned_register (frame, PC_REGNUM, &pc);
    frame_read_unsigned_register (frame, PSW_REGNUM, &psw);
    frame_read_unsigned_register (frame, frame_map_name_to_regnum ("rpt_s", -1), &rpt_s);
    frame_read_unsigned_register (frame, frame_map_name_to_regnum ("rpt_e", -1), &rpt_e);
    frame_read_unsigned_register (frame, frame_map_name_to_regnum ("rpt_c", -1), &rpt_c);
    fprintf_filtered (file, "PC=%04lx (0x%lx) PSW=%04lx RPT_S=%04lx RPT_E=%04lx RPT_C=%04lx\n",
		     (long) pc, (long) d10v_make_iaddr (pc), (long) psw,
		     (long) rpt_s, (long) rpt_e, (long) rpt_c);
  }

  {
    int group;
    for (group = 0; group < 16; group += 8)
      {
	int r;
	fprintf_filtered (file, "R%d-R%-2d", group, group + 7);
	for (r = group; r < group + 8; r++)
	  {
	    ULONGEST tmp;
	    frame_read_unsigned_register (frame, r, &tmp);
	    fprintf_filtered (file, " %04lx", (long) tmp);
	  }
	fprintf_filtered (file, "\n");
      }
  }

  /* Note: The IMAP/DMAP registers don't participate in function
     calls.  Don't bother trying to unwind them.  */

  {
    int a;
    for (a = 0; a < NR_IMAP_REGS; a++)
      {
	if (a > 0)
	  fprintf_filtered (file, "    ");
	fprintf_filtered (file, "IMAP%d %04lx", a, d10v_imap_register (a));
      }
    if (NR_DMAP_REGS == 1)
      /* Registers DMAP0 and DMAP1 are constant.  Just return dmap2.  */
      fprintf_filtered (file, "    DMAP %04lx\n", d10v_dmap_register (2));
    else
      {
	for (a = 0; a < NR_DMAP_REGS; a++)
	  {
	    fprintf_filtered (file, "    DMAP%d %04lx", a, d10v_dmap_register (a));
	  }
	fprintf_filtered (file, "\n");
      }
  }

  {
    char *num = alloca (max_register_size (gdbarch));
    int a;
    fprintf_filtered (file, "A0-A%d", NR_A_REGS - 1);
    for (a = A0_REGNUM; a < A0_REGNUM + NR_A_REGS; a++)
      {
	int i;
	fprintf_filtered (file, "  ");
	frame_register_read (frame, a, num);
	for (i = 0; i < MAX_REGISTER_RAW_SIZE; i++)
	  {
	    fprintf_filtered (file, "%02x", (num[i] & 0xff));
	  }
      }
  }
  fprintf_filtered (file, "\n");
d933 55
a987 2
  d10v_print_registers_info (current_gdbarch, gdb_stdout,
			     get_current_frame (), -1, 1);
d1155 2
a1156 2
d10v_extract_return_value (struct type *type, struct regcache *regcache,
			   void *valbuf)
d1165 2
a1166 1
  if (TYPE_LENGTH (type) == 1)
d1168 4
a1171 2
      ULONGEST c;
      regcache_cooked_read_unsigned (regcache, RET1_REGNUM, &c);
d1174 2
d1180 4
a1183 18
	 remaining bytes in remaining registers. Interestingly, when
	 such values are passed in, the last byte is in the most
	 significant byte of that same register - wierd. */
      int reg = RET1_REGNUM;
      int off = 0;
      if (TYPE_LENGTH (type) & 1)
	{
	  regcache_cooked_read_part (regcache, RET1_REGNUM, 1, 1,
				     (bfd_byte *)valbuf + off);
	  off++;
	  reg++;
	}
      /* Transfer the remaining registers.  */
      for (; off < TYPE_LENGTH (type); reg++, off += 2)
	{
	  regcache_cooked_read (regcache, RET1_REGNUM + reg,
				(bfd_byte *) valbuf + off);
	}
a1497 165
static CORE_ADDR
d10v_frame_pc_unwind (struct frame_info *frame,
		      void **cache)
{
  struct d10v_unwind_cache *info = d10v_frame_unwind_cache (frame, cache);
  return info->return_pc;
}

/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct.  */

static void
d10v_frame_id_unwind (struct frame_info *frame,
		      void **cache,
		      struct frame_id *id)
{
  struct d10v_unwind_cache *info = d10v_frame_unwind_cache (frame, cache);
  CORE_ADDR addr;

  /* Start with a NULL frame ID.  */
  (*id) = null_frame_id;

  if (info->return_pc == IMEM_START
      || info->return_pc <= IMEM_START
      || inside_entry_file (info->return_pc))
    {
      /* This is meant to halt the backtrace at "_start".
	 Make sure we don't halt it at a generic dummy frame. */
      return;
    }

  if (!info->saved_regs[FP_REGNUM])
    {
      if (!info->saved_regs[SP_REGNUM]
	  || info->saved_regs[SP_REGNUM] == STACK_START)
	return;

      id->base = info->saved_regs[SP_REGNUM];
      id->pc = info->return_pc;
    }

  addr = read_memory_unsigned_integer (info->saved_regs[FP_REGNUM],
				       REGISTER_RAW_SIZE (FP_REGNUM));
  if (addr == 0)
    return;

  id->base = d10v_make_daddr (addr);
  id->pc = info->return_pc;
}

static void
saved_regs_unwinder (struct frame_info *frame,
		     CORE_ADDR *saved_regs,
		     int regnum, int *optimizedp,
		     enum lval_type *lvalp, CORE_ADDR *addrp,
		     int *realnump, void *bufferp)
{
  /* If we're using generic dummy frames, we'd better not be in a call
     dummy.  (generic_call_dummy_register_unwind ought to have been called
     instead.)  */
  gdb_assert (!(DEPRECATED_USE_GENERIC_DUMMY_FRAMES
		&& (get_frame_type (frame) == DUMMY_FRAME)));

  if (saved_regs[regnum] != 0)
    {
      if (regnum == SP_REGNUM)
	{
	  /* SP register treated specially.  */
	  *optimizedp = 0;
	  *lvalp = not_lval;
	  *addrp = 0;
	  *realnump = -1;
	  if (bufferp != NULL)
	    store_address (bufferp, REGISTER_RAW_SIZE (regnum),
			   saved_regs[regnum]);
	}
      else
	{
	  /* Any other register is saved in memory, fetch it but cache
	     a local copy of its value.  */
	  *optimizedp = 0;
	  *lvalp = lval_memory;
	  *addrp = saved_regs[regnum];
	  *realnump = -1;
	  if (bufferp != NULL)
	    {
	      /* Read the value in from memory.  */
	      read_memory (saved_regs[regnum], bufferp,
			   REGISTER_RAW_SIZE (regnum));
	    }
	}
      return;
    }

  /* No luck, assume this and the next frame have the same register
     value.  If a value is needed, pass the request on down the chain;
     otherwise just return an indication that the value is in the same
     register as the next frame.  */
  frame_register (frame, regnum, optimizedp, lvalp, addrp,
		  realnump, bufferp);
}


static void
d10v_frame_register_unwind (struct frame_info *frame,
			    void **cache,
			    int regnum, int *optimizedp,
			    enum lval_type *lvalp, CORE_ADDR *addrp,
			    int *realnump, void *bufferp)
{
  struct d10v_unwind_cache *info = d10v_frame_unwind_cache (frame, cache);
  saved_regs_unwinder (frame, info->saved_regs, regnum, optimizedp,
		       lvalp, addrp, realnump, bufferp);
}


static void
d10v_frame_pop (struct frame_info *fi, void **unwind_cache,
		struct regcache *regcache)
{
  struct d10v_unwind_cache *info = d10v_frame_unwind_cache (fi, unwind_cache);
  CORE_ADDR fp;
  int regnum;
  char raw_buffer[8];

  fp = get_frame_base (fi);

  /* now update the current registers with the old values */
  for (regnum = A0_REGNUM; regnum < A0_REGNUM + NR_A_REGS; regnum++)
    {
      frame_unwind_register (fi, regnum, raw_buffer);
      regcache_cooked_write (regcache, regnum, raw_buffer);
    }
  for (regnum = 0; regnum < SP_REGNUM; regnum++)
    {
      frame_unwind_register (fi, regnum, raw_buffer);
      regcache_cooked_write (regcache, regnum, raw_buffer);
    }
  frame_unwind_register (fi, PSW_REGNUM, raw_buffer);
  regcache_cooked_write (regcache, PSW_REGNUM, raw_buffer);

  frame_unwind_register (fi, LR_REGNUM, raw_buffer);
  regcache_cooked_write (regcache, PC_REGNUM, raw_buffer);

  store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (SP_REGNUM),
			  fp + info->size);
  regcache_cooked_write (regcache, SP_REGNUM, raw_buffer);

  target_store_registers (-1);
  flush_cached_frames ();
}

static struct frame_unwind d10v_frame_unwind = {
  d10v_frame_pop,
  d10v_frame_pc_unwind,
  d10v_frame_id_unwind,
  d10v_frame_register_unwind
};

const struct frame_unwind *
d10v_frame_p (CORE_ADDR pc)
{
  return &d10v_frame_unwind;
}

d1521 4
d1610 1
a1610 1
  set_gdbarch_extract_return_value (gdbarch, d10v_extract_return_value);
d1616 2
a1617 2
  set_gdbarch_store_return_value (gdbarch, d10v_store_return_value);
  set_gdbarch_extract_struct_value_address (gdbarch, d10v_extract_struct_value_address);
d1620 5
d1635 3
a1645 4
  set_gdbarch_print_registers_info (gdbarch, d10v_print_registers_info);

  frame_unwind_append_predicate (gdbarch, d10v_frame_p);

d1663 1
a1663 2
  deprecate_cmd (add_com ("regs", class_vars, show_regs, "Print all registers"),
		 "info registers");
@


1.52.2.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d48 7
d351 1
a351 1
d10v_register_type (struct gdbarch *gdbarch, int reg_nr)
d620 1
d623 1
a623 5
  /* How far the SP and r11 (FP) have been offset from the start of
     the stack frame (as defined by the previous frame's stack
     pointer).  */
  LONGEST sp_offset;
  LONGEST r11_offset;
d638 2
a639 2
      info->sp_offset -= 2;
      info->saved_regs[n] = info->sp_offset;
d647 3
a649 3
      info->sp_offset -= 4;
      info->saved_regs[n] = info->sp_offset;
      info->saved_regs[n + 1] = info->sp_offset + 2;
d659 1
a659 1
      info->sp_offset -= n;
a666 9
      info->r11_offset = info->sp_offset;
      return 1;
    }

  /* st  rn, @@r11 */
  if ((op & 0x7E1F) == 0x6816)
    {
      n = (op & 0x1E0) >> 5;
      info->saved_regs[n] = info->r11_offset;
d678 1
a678 1
      info->saved_regs[n] = info->sp_offset;
d686 2
a687 2
      info->saved_regs[n] = info->sp_offset;
      info->saved_regs[n + 1] = info->sp_offset + 2;
d717 1
d722 1
a722 1
  info->sp_offset = 0;
d737 1
a737 1
	      info->sp_offset += n;
d744 1
a744 1
	      info->saved_regs[n] = info->sp_offset + offset;
d751 2
a752 2
	      info->saved_regs[n] = info->sp_offset + offset;
	      info->saved_regs[n + 1] = info->sp_offset + offset + 2;
d777 1
a777 1
  info->size = -info->sp_offset;
d785 1
a785 1
	info->saved_regs[i] = fp - (info->sp_offset - info->saved_regs[i]);
d792 1
a792 1
					register_size (current_gdbarch, LR_REGNUM));
d813 1
d892 1
a892 1
	for (i = 0; i < max_register_size (current_gdbarch); i++)
d1081 1
a1081 1
					 register_size (current_gdbarch, RET1_REGNUM)));
d1467 1
a1467 1
				       register_size (current_gdbarch, FP_REGNUM));
d1498 1
a1498 1
	    store_address (bufferp, register_size (current_gdbarch, regnum),
d1513 1
a1513 1
			   register_size (current_gdbarch, regnum));
d1569 1
a1569 2
  store_unsigned_integer (raw_buffer,
			  register_size (current_gdbarch, SP_REGNUM),
d1651 1
d1653 2
a1654 1
  set_gdbarch_register_type (gdbarch, d10v_register_type);
d1700 1
@


1.52.2.5
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a27 1
#include "frame-base.h"
d41 1
a41 1
#include "remote.h"
d71 1
a71 1
    D10V_FP_REGNUM = 11,
d279 2
a280 2
  /* Only makes sense to supply raw registers.  */
  gdb_assert (nr >= 0 && nr < NUM_REGS);
d295 2
a296 2
  /* Only makes sense to supply raw registers.  */
  gdb_assert (nr >= 0 && nr < NUM_REGS);
d348 1
a348 1
  if (reg_nr == _SP_REGNUM || reg_nr == D10V_FP_REGNUM)
d440 12
d502 11
a612 5
  /* The previous frame's inner most stack address.  Used as this
     frame ID's stack_addr.  */
  CORE_ADDR prev_sp;
  /* The frame's base, optionally used by the high-level debug info.  */
  CORE_ADDR base;
d706 2
a707 2
d10v_frame_unwind_cache (struct frame_info *next_frame,
			 void **this_prologue_cache)
d709 1
a709 3
  CORE_ADDR pc;
  ULONGEST prev_sp;
  ULONGEST this_base;
d715 2
a716 2
  if ((*this_prologue_cache))
    return (*this_prologue_cache);
d719 1
a719 1
  (*this_prologue_cache) = info;
d724 2
d728 2
d731 1
a731 3
  for (pc = frame_func_unwind (next_frame);
       pc > 0 && pc < frame_pc_unwind (next_frame);
       pc += 4)
d778 1
d783 2
a784 27
  /* Compute the frame's base, and the previous frame's SP.  */
  if (info->uses_frame)
    {
      /* The SP was moved to the FP.  This indicates that a new frame
         was created.  Get THIS frame's FP value by unwinding it from
         the next frame.  */
      frame_unwind_unsigned_register (next_frame, D10V_FP_REGNUM, &this_base);
      /* The FP points at the last saved register.  Adjust the FP back
         to before the first saved register giving the SP.  */
      prev_sp = this_base + info->size;
    }
  else if (info->saved_regs[SP_REGNUM])
    {
      /* The SP was saved (which is very unusual), the frame base is
	 just the PREV's frame's TOP-OF-STACK.  */
      this_base = read_memory_unsigned_integer (info->saved_regs[SP_REGNUM], 
						register_size (current_gdbarch,
							       SP_REGNUM));
      prev_sp = this_base;
    }
  else
    {
      /* Assume that the FP is this frame's SP but with that pushed
         stack space added back.  */
      frame_unwind_unsigned_register (next_frame, SP_REGNUM, &this_base);
      prev_sp = this_base + info->size;
    }
a785 5
  info->base = d10v_make_daddr (this_base);
  info->prev_sp = d10v_make_daddr (prev_sp);

  /* Adjust all the saved registers so that they contain addresses and
     not offsets.  */
d789 1
a789 1
	info->saved_regs[i] = (info->prev_sp + info->saved_regs[i]);
d802 1
a802 1
      frame_unwind_unsigned_register (next_frame, LR_REGNUM, &return_pc);
d806 14
a819 3
  /* The SP_REGNUM is special.  Instead of the address of the SP, the
     previous frame's SP value is saved.  */
  info->saved_regs[SP_REGNUM] = info->prev_sp;
d943 6
d952 1
a952 1
  return (d10v_make_daddr (read_register (D10V_FP_REGNUM)));
d955 12
d1004 2
a1005 3
d10v_push_dummy_call (struct gdbarch *gdbarch, struct regcache *regcache,
		      CORE_ADDR dummy_addr, int nargs, struct value **args,
		      CORE_ADDR sp, int struct_return, CORE_ADDR struct_addr)
d1012 5
a1016 8
  /* Set the return address.  For the d10v, the return breakpoint is
     always at DUMMY_ADDR.  */
  regcache_cooked_write_unsigned (regcache, LR_REGNUM,
				  d10v_convert_iaddr_to_raw (dummy_addr));

  /* If STRUCT_RETURN is true, then the struct return address (in
     STRUCT_ADDR) will consume the first argument-passing register.
     Both adjust the register count and store that value.  */
d1018 1
a1018 4
    {
      regcache_cooked_write_unsigned (regcache, regnum, struct_addr);
      regnum++;
    }
d1034 1
a1034 1
	  regcache_cooked_write_unsigned (regcache, regnum++, val);
d1045 1
a1045 1
	      regcache_cooked_write_unsigned (regcache, regnum++, val);
d1050 1
a1050 1
	      regcache_cooked_write_unsigned (regcache, regnum++, (val << 8));
a1067 4
  /* Finally, update the SP register.  */
  regcache_cooked_write_unsigned (regcache, SP_REGNUM,
				  d10v_convert_daddr_to_raw (sp));

d1340 1
d1347 5
d1353 7
a1359 16
    { 
      char *space_index = strchr (arg, ' ');
      if (space_index == NULL)
	{
	  low = parse_and_eval_address (arg);
	  high = low + 5;
	}
      else
	{
	  /* Two arguments.  */
	  *space_index = '\0';
	  low = parse_and_eval_address (arg);
	  high = parse_and_eval_address (space_index + 1);
	  if (high < low)
	    high = low;
	}
d1427 1
d1429 2
a1430 1
d10v_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
d1432 2
a1433 3
  ULONGEST pc;
  frame_unwind_unsigned_register (next_frame, PC_REGNUM, &pc);
  return d10v_make_iaddr (pc);
d1440 18
a1457 17
d10v_frame_this_id (struct frame_info *next_frame,
		    void **this_prologue_cache,
		    struct frame_id *this_id)
{
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_prologue_cache);
  CORE_ADDR base;
  CORE_ADDR func;
  struct frame_id id;

  /* The FUNC is easy.  */
  func = frame_func_unwind (next_frame);

  /* This is meant to halt the backtrace at "_start".  Make sure we
     don't halt it at a generic dummy frame. */
  if (func <= IMEM_START || inside_entry_file (func))
    return;
d1459 5
a1463 6
  /* Hopefully the prologue analysis either correctly determined the
     frame's base (which is the SP from the previous frame), or set
     that base to "NULL".  */
  base = info->prev_sp;
  if (base == STACK_START || base == 0)
    return;
d1465 3
a1467 1
  id = frame_id_build (base, func);
d1469 3
a1471 7
  /* Check that we're not going round in circles with the same frame
     ID (but avoid applying the test to sentinel frames which do go
     round in circles).  Can't use frame_id_eq() as that doesn't yet
     compare the frame's PC value.  */
  if (frame_relative_level (next_frame) >= 0
      && get_frame_type (next_frame) != DUMMY_FRAME
      && frame_id_eq (get_frame_id (next_frame), id))
d1474 2
a1475 1
  (*this_id) = id;
d1479 2
a1480 2
saved_regs_unwinder (struct frame_info *next_frame,
		     CORE_ADDR *this_saved_regs,
d1485 7
a1491 1
  if (this_saved_regs[regnum] != 0)
d1502 1
a1502 1
			   this_saved_regs[regnum]);
d1510 1
a1510 1
	  *addrp = this_saved_regs[regnum];
d1515 1
a1515 1
	      read_memory (this_saved_regs[regnum], bufferp,
d1526 2
a1527 2
  frame_register_unwind (next_frame, regnum, optimizedp, lvalp, addrp,
			 realnump, bufferp);
d1532 28
a1559 15
d10v_frame_prev_register (struct frame_info *next_frame,
			  void **this_prologue_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *bufferp)
{
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_prologue_cache);
  if (regnum == PC_REGNUM)
    {
      /* The call instruction saves the caller's PC in LR.  The
	 function prologue of the callee may then save the LR on the
	 stack.  Find that possibly saved LR value and return it.  */
      saved_regs_unwinder (next_frame, info->saved_regs, LR_REGNUM, optimizedp,
			   lvalp, addrp, realnump, bufferp);
d1561 1
a1561 1
  else
d1563 2
a1564 2
      saved_regs_unwinder (next_frame, info->saved_regs, regnum, optimizedp,
			   lvalp, addrp, realnump, bufferp);
d1566 13
d1581 5
a1585 4
static const struct frame_unwind d10v_frame_unwind = {
  NORMAL_FRAME,
  d10v_frame_this_id,
  d10v_frame_prev_register
a1593 28
static CORE_ADDR
d10v_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct d10v_unwind_cache *info
    = d10v_frame_unwind_cache (next_frame, this_cache);
  return info->base;
}

static const struct frame_base d10v_frame_base = {
  &d10v_frame_unwind,
  d10v_frame_base_address,
  d10v_frame_base_address,
  d10v_frame_base_address
};

/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
   dummy frame.  The frame ID's base needs to match the TOS value
   saved by save_dummy_frame_tos(), and the PC match the dummy frame's
   breakpoint.  */

static struct frame_id
d10v_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  ULONGEST base;
  frame_unwind_unsigned_register (next_frame, SP_REGNUM, &base);
  return frame_id_build (d10v_make_daddr (base), frame_pc_unwind (next_frame));
}

d1599 2
d1644 1
d1648 1
d1689 11
d1701 4
a1704 1
  set_gdbarch_push_dummy_call (gdbarch, d10v_push_dummy_call);
d1720 1
d1725 1
a1729 1
  frame_base_set_default (gdbarch, &d10v_frame_base);
d1731 2
a1732 3
  /* Methods for saving / extracting a dummy frame's ID.  */
  set_gdbarch_unwind_dummy_id (gdbarch, d10v_unwind_dummy_id);
  set_gdbarch_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
a1733 2
  /* Return the unwound PC value.  */
  set_gdbarch_unwind_pc (gdbarch, d10v_unwind_pc);
d1735 2
a1736 2
  return gdbarch;
}
@


1.52.2.6
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d74 1
a74 1
    D10V_SP_REGNUM = 15,
d87 2
a88 11
int
nr_dmap_regs (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->nr_dmap_regs;
}

int
a0_regnum (struct gdbarch *gdbarch)
{
  return gdbarch_tdep (gdbarch)->a0_regnum;
}
d96 2
d310 31
d349 1
a349 1
  if (reg_nr == D10V_SP_REGNUM || reg_nr == D10V_FP_REGNUM)
d351 2
a352 2
  else if (reg_nr >= a0_regnum (gdbarch)
	   && reg_nr < (a0_regnum (gdbarch) + NR_A_REGS))
d418 2
a419 1
  CORE_ADDR addr = extract_unsigned_integer (buf, TYPE_LENGTH (type));
d705 1
a705 1
  info->saved_regs = FRAME_OBSTACK_CALLOC (NUM_REGS, CORE_ADDR);
d776 1
a776 1
  else if (info->saved_regs[D10V_SP_REGNUM])
d780 1
a780 1
      this_base = read_memory_unsigned_integer (info->saved_regs[D10V_SP_REGNUM], 
d782 1
a782 1
							       D10V_SP_REGNUM));
d789 1
a789 1
      frame_unwind_unsigned_register (next_frame, D10V_SP_REGNUM, &this_base);
d818 1
a818 1
  /* The D10V_SP_REGNUM is special.  Instead of the address of the SP, the
d820 1
a820 1
  info->saved_regs[D10V_SP_REGNUM] = info->prev_sp;
d874 1
a874 1
    if (nr_dmap_regs (gdbarch) == 1)
d879 1
a879 1
	for (a = 0; a < nr_dmap_regs (gdbarch); a++)
d891 1
a891 1
    for (a = a0_regnum (gdbarch); a < a0_regnum (gdbarch) + NR_A_REGS; a++)
d895 2
a896 2
	frame_read_register (frame, a, num);
	for (i = 0; i < register_size (current_gdbarch, a); i++)
d941 7
a947 1
  return (d10v_make_daddr (read_register (D10V_SP_REGNUM)));
d1059 1
a1059 1
  regcache_cooked_write_unsigned (regcache, D10V_SP_REGNUM,
d1074 6
d1198 1
a1198 1
    trace_data.counts = XCALLOC (65536, short);
d1200 1
a1200 1
    trace_data.addrs = XCALLOC (65536, CORE_ADDR);
d1239 18
d1417 1
a1417 2
	  next_address += TARGET_PRINT_INSN (next_address,
					     &deprecated_tm_print_insn_info);
d1484 1
a1484 1
      if (regnum == D10V_SP_REGNUM)
d1492 2
a1493 3
	    store_unsigned_integer (bufferp,
				    register_size (current_gdbarch, regnum),
				    this_saved_regs[regnum]);
d1582 1
a1582 1
  frame_unwind_unsigned_register (next_frame, D10V_SP_REGNUM, &base);
d1632 1
d1636 1
a1636 1
  set_gdbarch_sp_regnum (gdbarch, D10V_SP_REGNUM);
d1641 2
a1710 2
  set_gdbarch_print_insn (gdbarch, print_insn_d10v);

d1719 2
d1741 9
a1749 9
  add_setshow_boolean_cmd ("itracedisplay", no_class, &trace_display,
			   "Set automatic display of trace.\n",
			   "Show automatic display of trace.\n",
			   NULL, NULL, &setlist, &showlist);
  add_setshow_boolean_cmd ("itracesource", no_class,
			   &default_trace_show_source,
			   "Set display of source code with trace.\n",
			   "Show display of source code with trace.\n",
			   NULL, NULL, &setlist, &showlist);
@


1.52.2.7
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@a45 1
#include "disasm.h"
d53 2
a54 2
    unsigned long (*dmap_register) (void *regcache, int nr);
    unsigned long (*imap_register) (void *regcache, int nr);
d76 1
a76 1
    D10V_PC_REGNUM = 18,
d110 1
a110 1
d10v_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
d112 1
a112 3
  /* Align to the size of an instruction (so that they can safely be
     pushed onto the stack.  */
  return sp & ~3;
d236 1
a236 1
d10v_ts2_dmap_register (void *regcache, int reg_nr)
d244 1
a244 5
      {
	ULONGEST reg;
	regcache_cooked_read_unsigned (regcache, TS2_DMAP_REGNUM, &reg);
	return reg;
      }
d251 13
a263 1
d10v_ts3_dmap_register (void *regcache, int reg_nr)
d265 1
a265 3
  ULONGEST reg;
  regcache_cooked_read_unsigned (regcache, TS3_DMAP0_REGNUM + reg_nr, &reg);
  return reg;
d269 1
a269 1
d10v_ts2_imap_register (void *regcache, int reg_nr)
d271 1
a271 3
  ULONGEST reg;
  regcache_cooked_read_unsigned (regcache, TS2_IMAP0_REGNUM + reg_nr, &reg);
  return reg;
d275 1
a275 1
d10v_ts3_imap_register (void *regcache, int reg_nr)
d277 1
a277 3
  ULONGEST reg;
  regcache_cooked_read_unsigned (regcache, TS3_IMAP0_REGNUM + reg_nr, &reg);
  return reg;
d323 1
a323 1
  if (reg_nr == D10V_PC_REGNUM)
a803 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d812 1
a812 1
    frame_read_unsigned_register (frame, D10V_PC_REGNUM, &pc);
d847 1
a847 2
	fprintf_filtered (file, "IMAP%d %04lx", a,
			  tdep->imap_register (current_regcache, a));
d851 1
a851 2
      fprintf_filtered (file, "    DMAP %04lx\n",
			tdep->dmap_register (current_regcache, 2));
d856 1
a856 2
	    fprintf_filtered (file, "    DMAP%d %04lx", a,
			      tdep->dmap_register (current_regcache, a));
d863 1
a863 1
    char num[MAX_REGISTER_SIZE];
d896 1
a896 1
  pc = (int) read_register (D10V_PC_REGNUM);
d909 1
a909 1
  write_register (D10V_PC_REGNUM, d10v_convert_iaddr_to_raw (val));
a955 19
d10v_push_dummy_code (struct gdbarch *gdbarch,
		      CORE_ADDR sp, CORE_ADDR funaddr, int using_gcc,
		      struct value **args, int nargs,
		      struct type *value_type,
		      CORE_ADDR *real_pc, CORE_ADDR *bp_addr)
{
  /* Allocate space sufficient for a breakpoint.  */
  sp = (sp - 4) & ~3;
  /* Store the address of that breakpoint taking care to first convert
     it into a code (IADDR) address from a stack (DADDR) address.
     This of course assumes that the two virtual addresses map onto
     the same real address.  */
  (*bp_addr) = d10v_make_iaddr (d10v_convert_iaddr_to_raw (sp));
  /* d10v always starts the call at the callee's entry point.  */
  (*real_pc) = funaddr;
  return sp;
}

static CORE_ADDR
d1081 1
a1081 3
remote_d10v_translate_xfer_address (struct gdbarch *gdbarch,
				    struct regcache *regcache,
				    CORE_ADDR memaddr, int nr_bytes,
a1083 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1086 4
a1089 2
  out_len = sim_d10v_translate_addr (memaddr, nr_bytes, &out_addr, regcache,
				     tdep->dmap_register, tdep->imap_register);
d1208 1
a1208 1
  last_pc = read_register (D10V_PC_REGNUM);
d1362 2
a1363 1
	  next_address += gdb_print_insn (next_address, gdb_stdout);
d1374 1
a1374 1
  frame_unwind_unsigned_register (next_frame, D10V_PC_REGNUM, &pc);
d1478 1
a1478 1
  if (regnum == D10V_PC_REGNUM)
d1583 1
d1585 3
a1621 1
  set_gdbarch_push_dummy_code (gdbarch, d10v_push_dummy_code);
d1639 1
a1639 1
  set_gdbarch_frame_align (gdbarch, d10v_frame_align);
@


1.52.2.8
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a46 1
#include "trad-frame.h"
d88 1
a88 1
static int
d94 1
a94 1
static int
d104 2
d566 1
d573 1
d580 1
a580 2
  /* Table indicating the location of each and every register.  */
  struct trad_frame_saved_reg *saved_regs;
d594 1
a594 1
      info->saved_regs[n].addr = info->sp_offset;
d603 2
a604 2
      info->saved_regs[n + 0].addr = info->sp_offset + 0;
      info->saved_regs[n + 1].addr = info->sp_offset + 2;
d630 1
a630 1
      info->saved_regs[n].addr = info->r11_offset;
d642 1
a642 1
      info->saved_regs[n].addr = info->sp_offset;
d650 2
a651 2
      info->saved_regs[n + 0].addr = info->sp_offset + 0;
      info->saved_regs[n + 1].addr = info->sp_offset + 2;
d664 1
a664 1
static struct d10v_unwind_cache *
a667 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d681 1
a681 1
  info->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d684 1
d692 1
a692 1
      op = get_frame_memory_unsigned (next_frame, pc, 4);
d707 1
a707 1
	      info->saved_regs[n].addr = info->sp_offset + offset;
d714 2
a715 2
	      info->saved_regs[n + 0].addr = info->sp_offset + offset + 0;
	      info->saved_regs[n + 1].addr = info->sp_offset + offset + 2;
d741 1
a741 2
  /* Compute the previous frame's stack pointer (which is also the
     frame's ID's stack address), and this frame's base pointer.  */
d752 9
a768 2
  /* Convert that SP/BASE into real addresses.  */
  info->prev_sp =  d10v_make_daddr (prev_sp);
d770 1
d775 1
a775 1
    if (info->saved_regs[i].addr)
d777 1
a777 1
	info->saved_regs[i].addr = (info->prev_sp + info->saved_regs[i].addr);
d780 17
a796 10
  /* The call instruction moves the caller's PC in the callee's LR.
     Since this is an unwind, do the reverse.  Copy the location of LR
     into PC (the address / regnum) so that a request for PC will be
     converted into a request for the LR.  */
  info->saved_regs[D10V_PC_REGNUM] = info->saved_regs[LR_REGNUM];

  /* The previous frame's SP needed to be computed.  Save the computed
     value.  */
  trad_frame_register_value (info->saved_regs, D10V_SP_REGNUM,
			     d10v_make_daddr (prev_sp));
d876 1
a876 1
	for (i = 0; i < register_size (gdbarch, a); i++)
d919 1
a919 1
d10v_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
d921 1
a921 3
  ULONGEST sp;
  frame_unwind_unsigned_register (next_frame, D10V_SP_REGNUM, &sp);
  return d10v_make_daddr (sp);
d980 3
a982 4
d10v_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		      struct regcache *regcache, CORE_ADDR bp_addr,
		      int nargs, struct value **args, CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
d990 1
a990 1
     always at BP_ADDR.  */
d992 1
a992 1
				  d10v_convert_iaddr_to_raw (bp_addr));
d1446 48
d1502 13
a1514 2
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, bufferp);
d1523 1
a1523 1
static const struct frame_unwind *
d1552 3
a1554 2
  return frame_id_build (d10v_unwind_sp (gdbarch, next_frame),
			 frame_pc_unwind (next_frame));
d1603 1
a1603 1
  set_gdbarch_unwind_sp (gdbarch, d10v_unwind_sp);
d1659 1
d1669 1
a1669 3
  /* Methods for saving / extracting a dummy frame's ID.  The ID's
     stack address must match the SP value returned by
     PUSH_DUMMY_CALL, and saved by generic_save_dummy_frame_tos.  */
d1671 1
@


1.52.2.9
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d766 1
a766 1
    if (trad_frame_addr_p (info->saved_regs, i))
d779 2
a780 2
  trad_frame_set_value (info->saved_regs, D10V_SP_REGNUM,
			d10v_make_daddr (prev_sp));
d800 3
a802 3
    frame_read_unsigned_register (frame, frame_map_name_to_regnum (frame, "rpt_s", -1), &rpt_s);
    frame_read_unsigned_register (frame, frame_map_name_to_regnum (frame, "rpt_e", -1), &rpt_e);
    frame_read_unsigned_register (frame, frame_map_name_to_regnum (frame, "rpt_c", -1), &rpt_c);
d1420 9
d1452 1
a1452 1
d10v_frame_sniffer (struct frame_info *next_frame)
d1592 1
a1592 1
  frame_unwind_append_sniffer (gdbarch, d10v_frame_sniffer);
@


1.52.2.10
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d280 3
a282 3
/* MAP GDB's internal register numbering (determined by the layout
   from the DEPRECATED_REGISTER_BYTE array) onto the simulator's
   register numbering. */
d1408 1
a1408 1
  if (func <= IMEM_START || deprecated_inside_entry_file (func))
@


1.52.2.11
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1 1
a1 1
/* Target-dependent code for Renesas D10V, for GDB.
d60 1
a60 1
   instruction memory to.  */
d68 1
a68 1
/* d10v register names.  */
d83 1
a83 1
    /* d10v calling convention.  */
d85 2
a86 1
    ARGN_REGNUM = R3_REGNUM
d117 38
d165 1
a165 1
   when the reg_nr isn't valid.  */
d282 1
a282 1
   register numbering.  */
d356 1
a356 1
    return x;	/* Idempotency -- x is already in the IMEM space.  */
d416 2
a417 1
/* Handle the d10v's return_value convention.  */
d419 1
a419 27
static enum return_value_convention
d10v_return_value (struct gdbarch *gdbarch, struct type *valtype,
		   struct regcache *regcache, void *readbuf,
		   const void *writebuf)
{
  if (TYPE_LENGTH (valtype) > 8)
    /* Anything larger than 8 bytes (4 registers) goes on the stack.  */
    return RETURN_VALUE_STRUCT_CONVENTION;
  if (TYPE_LENGTH (valtype) == 5
      || TYPE_LENGTH (valtype) == 6)
    /* Anything 5 or 6 bytes in size goes in memory.  Contents don't
       appear to matter.  Note that 7 and 8 byte objects do end up in
       registers!  */
    return RETURN_VALUE_STRUCT_CONVENTION;
  if (TYPE_LENGTH (valtype) == 1)
    {
      /* All single byte values go in a register stored right-aligned.
         Note: 2 byte integer values are handled further down.  */
      if (readbuf)
	{
	  /* Since TYPE is smaller than the register, there isn't a
             sign extension problem.  Let the extraction truncate the
             register value.  */
	  ULONGEST regval;
	  regcache_cooked_read_unsigned (regcache, R0_REGNUM,
					 &regval);
	  store_unsigned_integer (readbuf, TYPE_LENGTH (valtype), regval);
d421 12
a432 16
	}
      if (writebuf)
	{
	  ULONGEST regval;
	  if (TYPE_CODE (valtype) == TYPE_CODE_INT)
	    /* Some sort of integer value stored in R0.  Use
	       unpack_long since that should handle any required sign
	       extension.  */
	    regval = unpack_long (valtype, writebuf);
	  else
	    /* Some other type.  Don't sign-extend the value when
               storing it in the register.  */
	    regval = extract_unsigned_integer (writebuf, 1);
	  regcache_cooked_write_unsigned (regcache, R0_REGNUM, regval);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
d434 1
a434 9
  if ((TYPE_CODE (valtype) == TYPE_CODE_STRUCT
       || TYPE_CODE (valtype) == TYPE_CODE_UNION)
      && TYPE_NFIELDS (valtype) > 1
      && TYPE_FIELD_BITPOS (valtype, 1) == 8)
    /* If a composite is 8 bit aligned (determined by looking at the
       start address of the second field), put it in memory.  */
    return RETURN_VALUE_STRUCT_CONVENTION;
  /* Assume it is in registers.  */
  if (writebuf || readbuf)
d437 6
a442 14
      /* Per above, the value is never more than 8 bytes long.  */
      gdb_assert (TYPE_LENGTH (valtype) <= 8);
      /* Xfer 2 bytes at a time.  */
      for (reg = 0; (reg * 2) + 1 < TYPE_LENGTH (valtype); reg++)
	{
	  if (readbuf)
	    regcache_cooked_read (regcache, R0_REGNUM + reg,
				  (bfd_byte *) readbuf + reg * 2);
	  if (writebuf)
	    regcache_cooked_write (regcache, R0_REGNUM + reg,
				   (bfd_byte *) writebuf + reg * 2);
	}
      /* Any trailing byte ends up _left_ aligned.  */
      if ((reg * 2) < TYPE_LENGTH (valtype))
d444 2
a445 6
	  if (readbuf)
	    regcache_cooked_read_part (regcache, R0_REGNUM + reg,
				       0, 1, (bfd_byte *) readbuf + reg * 2);
	  if (writebuf)
	    regcache_cooked_write_part (regcache, R0_REGNUM + reg,
					0, 1, (bfd_byte *) writebuf + reg * 2);
d447 4
d452 12
a463 1
  return RETURN_VALUE_REGISTER_CONVENTION;
d508 2
a509 2
  /* If we have line debugging information, then the end of the prologue 
     should be the first assembly instruction of the first source line.  */
d518 1
a518 1
    return pc;			/* Can't access it -- assume no prologue.  */
d548 2
a549 3
		  /* If the previous opcode was really part of the
		     prologue and not just a NOP, then we want to
		     break after both instructions.  */
d660 1
a660 1
   for it IS the sp for the next frame.  */
d798 5
a802 5
    pc = get_frame_register_unsigned (frame, D10V_PC_REGNUM);
    psw = get_frame_register_unsigned (frame, PSW_REGNUM);
    rpt_s = get_frame_register_unsigned (frame, frame_map_name_to_regnum (frame, "rpt_s", -1));
    rpt_e = get_frame_register_unsigned (frame, frame_map_name_to_regnum (frame, "rpt_e", -1));
    rpt_c = get_frame_register_unsigned (frame, frame_map_name_to_regnum (frame, "rpt_c", -1));
d817 1
a817 1
	    tmp = get_frame_register_unsigned (frame, r);
d859 1
a859 1
	get_frame_register (frame, a, num);
d911 1
a911 1
   order.  The below implements a FILO (stack) to do this.  */
d968 2
a969 2
		      int nargs, struct value **args, CORE_ADDR sp, 
		      int struct_return, CORE_ADDR struct_addr)
d1045 40
d1089 1
a1089 1
   VM system works, we just call that to do the translation.  */
d1316 1
a1316 2
  printf_filtered ("Dump of trace from %s to %s:\n", 
		   paddr_u (low), paddr_u (high));
d1406 5
d1486 1
a1486 1
  /* Find a candidate among the list of pre-declared architectures.  */
d1492 1
a1492 1
     provided.  */
d1538 1
a1538 1
     double'' is 64 bits.  */
d1552 1
a1552 2
      set_gdbarch_long_double_format (gdbarch, 
				      &floatformat_ieee_double_little);
d1559 1
a1559 1
  set_gdbarch_return_value (gdbarch, d10v_return_value);
d1562 3
d1572 1
a1572 2
  set_gdbarch_remote_translate_xfer_address (gdbarch, 
					     remote_d10v_translate_xfer_address);
d1575 1
a1575 2
  set_gdbarch_frameless_function_invocation (gdbarch, 
					     frameless_look_for_prologue);
d1607 1
a1607 2
  deprecate_cmd (add_com ("regs", class_vars, show_regs, 
			  "Print all registers"),
@


1.52.2.12
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d296 6
d1519 1
@


1.51
log
@Index: ChangeLog
===================================================================
RCS file: /cvs/src/src/gdb/ChangeLog,v
retrieving revision 1.3144
diff -u -r1.3144 ChangeLog
--- ChangeLog	23 Aug 2002 23:05:38 -0000	1.3144
+++ ChangeLog	23 Aug 2002 23:14:45 -0000
@@@@ -1,3 +1,53 @@@@
2002-08-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (STORE_RETURN_VALUE): Add regcache parameter.
	(DEPRECATED_STORE_RETURN_VALUE): New method.
	(EXTRACT_RETURN_VALUE): Make buffer parameter a void pointer.
	* gdbarch.h, gdbarch.c: Re-generate.

	* values.c (set_return_value): Pass current_regcache to
	STORE_RETURN_VALUE.
	* arch-utils.h (legacy_store_return_value): Declare.
	* arch-utils.c (legacy_store_return_value): New function.
	(legacy_extract_return_value): Update parameters.

	* config/pa/tm-hppa.h (DEPRECATED_STORE_RETURN_VALUE): Rename
	STORE_RETURN_VALUE.
	* config/pa/tm-hppa64.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/z8k/tm-z8k.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparclet.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/mn10200/tm-mn10200.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-linux.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m32r/tm-m32r.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8500/tm-h8500.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8300/tm-h8300.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.

	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* i386-tdep.c (i386_extract_return_value): Update.
	* arch-utils.c (legacy_extract_return_value): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.

Index: doc/ChangeLog
2002-08-21  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Update
	STORE_RETURN_VALUE, mention regcache.
@
text
@d516 3
a518 3
    return d10v_make_iaddr (generic_read_register_dummy (frame->pc, 
							 frame->frame, 
							 PC_REGNUM));
@


1.50
log
@2002-08-05  Andrew Cagney  <ac131313@@redhat.com>
* mcore-tdep.c (mcore_gdbarch_init): Use
generic_unwind_get_saved_register instead of
generic_get_saved_register.
* v850-tdep.c (v850_gdbarch_init): Ditto.
* frv-tdep.c (frv_gdbarch_init): Ditto.
* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
* s390-tdep.c (s390_gdbarch_init): Ditto.
* d10v-tdep.c (d10v_gdbarch_init): Ditto.
* config/mn10200/tm-mn10200.h (GET_SAVED_REGISTER): Ditto.
* config/h8300/tm-h8300.h (GET_SAVED_REGISTER): Ditto.
@
text
@d1615 1
a1615 1
  set_gdbarch_store_return_value (gdbarch, d10v_store_return_value);
@


1.49
log
@2002-07-26  Andrew Cagney  <ac131313@@redhat.com>

* z8k-tdep.c: Do not include "obstack.h".
* h8300-tdep.c, h8500-tdep.c: Ditto.
* m68hc11-tdep.c, sh-tdep.c: Ditto.
* valprint.c, v850-tdep.c: Ditto.
* d10v-tdep.c, mn10300-tdep.c: Ditto.
* mn10200-tdep.c: Ditto.

* Makefile.in (z8k-tdep.o): Update dependencies.
(m68hc11-tdep.o, valprint.o): Ditto.
(v850-tdep.o, d10v-tdep.o): Ditto.
(mn10300-tdep.o, sparc-tdep.o): Ditto.
(sh-tdep.o, h8500-tdep.o, h8300-tdep.o): Ditto.
(m32r-tdep.o, mn10200-tdep.o): Specify dependencies.
(sh_opc_h, gdb_sim_sh_h): Define.
(elf_sh_h, elf_bfd_h): Define.
(opcode_m68hc11_h): Define.
(OPCODES_SRC, OPCODES_DIR): define.
(OPCODES): Use $(OPCODES_DIR).
(gdb_sim_d10v_h): Rename sim_d10v_h.
(gdb_sim_arm_h): Rename sim_arm_h.
@
text
@d1606 1
a1606 1
  set_gdbarch_get_saved_register (gdbarch, generic_get_saved_register);
@


1.48
log
@* gdbarch.sh (REGISTER_NAME): Change return type a constant string
pointer.
* gdbarch.h, gdbarch.c: Regenerate.
* config/mips/tm-mips.h (mips_register_name): Update.
* i386-tdep.h (i386_register_name): Update.
* mips-tdep.c (mips_register_name): Update
* alpha-tdep.c (alpha_register_name): Update.
* arch-utils.c (legacy_register_name): Update.
* arch-utils.h (legacy_register_name): Update.
* avr-tdep.c (avr_register_name): Update.
* ia64-tdep.c (ia64_register_name): Update.
* i386-tdep.c (i386_register_name): Update.
* sparc-tdep.c (sparc32_register_name): Update.
(sparc64_register_name): Update.
(sparclite_register_name): Update.
(sparclet_register_name):
* sh-tdep.c (sh_generic_register_name): Update.
(sh_sh_register_name): Update.
(sh_sh3_register_name): Update.
(sh_sh3e_register_name): Update.
(sh_sh_dsp_register_name): Update.
(sh_sh3_dsp_register_name): Update.
(sh_sh4_register_name): Update.
(sh_sh64_register_name): Update.
* s390-tdep.c (s390_register_name): Update.
* rs6000-tdep.c (rs6000_register_name): Update.
* ns32k-tdep.c (ns32k_register_name_32082): Update.
(ns32k_register_name_32382): Update.
* d10v-tdep.c (d10v_ts2_register_name): Update.
(d10v_ts3_register_name): Update.
* xstormy16-tdep.c (xstormy16_register_name): Update.
* vax-tdep.c (vax_register_name): Update.
* v850-tdep.c (v850_register_name): Update.
* m68hc11-tdep.c (m68hc11_register_name): Update.
* mn10300-tdep.c (mn10300_generic_register_name): Update.
(am33_register_name): Update.
@
text
@a26 1
#include "obstack.h"
@


1.47
log
@+	* gdbarch.sh (DEPRECATED_EXTRACT_RETURN_VALUE): Rename
+	EXTRACT_RETURN_VALUE.
+	(DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Rename
+	EXTRACT_STRUCT_VALUE_ADDRESS.
+	* gdbarch.h, gdbarch.c: Regenerate.
+
+	* values.c (value_being_returned): Handle
+	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
+	(EXTRACT_RETURN_VALUE): Define as DEPRECATED_EXTRACT_RETURN_VALUE.
+
+	* arm-linux-tdep.c (arm_linux_init_abi): Update.
+	* arm-tdep.c (arm_gdbarch_init): Update.
+	* avr-tdep.c (avr_gdbarch_init): Update.
+	* cris-tdep.c (cris_gdbarch_init): Update.
+	* d10v-tdep.c (d10v_gdbarch_init): Update.
+	* ia64-tdep.c (ia64_gdbarch_init): Update.
+	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
+	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sh-tdep.c (sh_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sparc-tdep.c (sparc_gdbarch_init): Update.
+	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
+	* v850-tdep.c (v850_gdbarch_init): Update.
+	* vax-tdep.c (vax_gdbarch_init): Update.
+	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
+	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
+
+	* config/arc/tm-arc.h: Update.
+	* config/d30v/tm-d30v.h: Update.
+	* config/fr30/tm-fr30.h: Update.
+	* config/h8300/tm-h8300.h: Update.
* config/h8500/tm-h8500.h: Update.
* config/i386/tm-i386.h: Update.
* config/i386/tm-ptx.h: Update.
* config/i386/tm-symmetry.h: Update.
* config/i960/tm-i960.h: Update.
* config/m32r/tm-m32r.h: Update.
* config/m68k/tm-delta68.h: Update.
* config/m68k/tm-linux.h: Update.
* config/m68k/tm-m68k.h: Update.
* config/m88k/tm-m88k.h: Update.
* config/mcore/tm-mcore.h: Update.
* config/mips/tm-mips.h: Update.
* config/mn10200/tm-mn10200.h: Update.
* config/pa/tm-hppa.h: Update.
* config/pa/tm-hppa64.h: Update.
* config/sparc/tm-sp64.h: Update.
* config/sparc/tm-sparc.h: Update.
* config/sparc/tm-sparclet.h: Update.
* config/z8k/tm-z8k.h: Update.
@
text
@d190 1
a190 1
static char *
d216 1
a216 1
static char *
@


1.46
log
@2002-06-06  Michael Snyder  <msnyder@@redhat.com>

        * d10v-tdep.c (d10v_push_arguments): Handle struct_return.
        Delete extra braces and re-indent.
@
text
@d1610 1
a1610 1
  set_gdbarch_extract_return_value (gdbarch, d10v_extract_return_value);
d1617 1
a1617 1
  set_gdbarch_extract_struct_value_address (gdbarch, d10v_extract_struct_value_address);
@


1.45
log
@2002-06-06  Michael Snyder  <msnyder@@redhat.com>

        * d10v-tdep.c (d10v_store_return_value): Char return values
	must be shifted over by one byte in R0.
        (d10v_extract_return_value): Delete extra braces, re-indent.
@
text
@d1089 9
d1106 2
d1109 9
d1119 3
a1121 3
	  int aligned_regnum = (regnum + 1) & ~1;
	  if (len <= 2 && regnum <= ARGN_REGNUM)
	    /* fits in a single register, do not align */
d1123 1
a1123 1
	      long val = extract_unsigned_integer (contents, len);
d1126 1
a1126 3
	  else if (len <= (ARGN_REGNUM - aligned_regnum + 1) * 2)
	    /* value fits in remaining registers, store keeping left
	       aligned */
d1128 2
a1129 18
	      int b;
	      regnum = aligned_regnum;
	      for (b = 0; b < (len & ~1); b += 2)
		{
		  long val = extract_unsigned_integer (&contents[b], 2);
		  write_register (regnum++, val);
		}
	      if (b < len)
		{
		  long val = extract_unsigned_integer (&contents[b], 1);
		  write_register (regnum++, (val << 8));
		}
	    }
	  else
	    {
	      /* arg will go onto stack */
	      regnum = ARGN_REGNUM + 1;
	      si = push_stack_item (si, contents, len);
d1131 6
@


1.44
log
@2002-06-06  Elena Zannoni  <ezannoni@@redhat.com>

        * d10v-tdep.c (d10v_read_sp, d10v_read_fp): Add prototype.
        (d10v_register_virtual_type): Make $fp and $sp be pointer to data.
        (d10v_integer_to_address): Rewrite.
        (d10v_frame_init_saved_regs): When reading fp and sp registers use
        the d10v specific functions which take care of converting to the
        correct space.
@
text
@d485 14
a498 3
  write_register_bytes (REGISTER_BYTE (RET1_REGNUM),
			valbuf,
			TYPE_LENGTH (type));
d1151 18
a1168 1
  /*    printf("RET: TYPE=%d len=%d r%d=0x%x\n", TYPE_CODE (type), TYPE_LENGTH (type), RET1_REGNUM - R0_REGNUM, (int) extract_unsigned_integer (regbuf + REGISTER_BYTE(RET1_REGNUM), REGISTER_RAW_SIZE (RET1_REGNUM)));  */
d1170 6
a1175 17
      len = TYPE_LENGTH (type);
      if (len == 1)
	{
	  unsigned short c = extract_unsigned_integer (regbuf + REGISTER_BYTE (RET1_REGNUM), REGISTER_RAW_SIZE (RET1_REGNUM));
	  store_unsigned_integer (valbuf, 1, c);
	}
      else if ((len & 1) == 0)
	memcpy (valbuf, regbuf + REGISTER_BYTE (RET1_REGNUM), len);
      else
	{
	  /* For return values of odd size, the first byte is in the
	     least significant part of the first register.  The
	     remaining bytes in remaining registers. Interestingly,
	     when such values are passed in, the last byte is in the
	     most significant byte of that same register - wierd. */
	  memcpy (valbuf, regbuf + REGISTER_BYTE (RET1_REGNUM) + 1, len);
	}
@


1.43
log
@* sim-regno.h: New file.
* Makefile.in (sim_regno_h): Define.
(d10v-tdep.o, remote-sim.o): Add dependency on $(sim_regno_h).
* remote-sim.c: Include "sim-regno.h" and "gdb_assert.h".
(legacy_register_sim_regno): New function.
(one2one_register_sim_regno): New function.
(gdbsim_fetch_register): Rewrite.
(gdbsim_store_register): Only store a register when
REGISTER_SIM_REGNO is valid.
* d10v-tdep.c: Include "sim-regno.h".
(d10v_ts2_register_sim_regno): Add legacy_regiter_sim_regno check.
(d10v_ts3_register_sim_regno): Ditto.
* gdbarch.sh: Include "sim-regno.h".
(REGISTER_SIM_REGNO): Set default to legacy_register_sim_regno.
* gdbarch.h, gdbarch.c: Regenerate.
* arch-utils.h (default_register_sim_regno): Delete declaration.
* arch-utils.c (default_register_sim_regno): Delete function.
@
text
@d98 4
d373 2
d453 4
d462 1
a462 9
  if (TYPE_CODE (type) == TYPE_CODE_INT
      && TYPE_LENGTH (type) <= TYPE_LENGTH (builtin_type_void_data_ptr))
    /* Convert small integers that would would be directly copied into
       a pointer variable into an address pointing into data space.  */
    return d10v_make_daddr (val & 0xffff);
  else
    /* The value is too large to fit in a pointer.  Assume this was
       intentional and that the user in fact specified a raw address.  */
    return val;
d853 1
a853 1
    fp = d10v_make_daddr (read_register (SP_REGNUM));
d880 1
a880 1
	  = read_register (FP_REGNUM) + fi->extra_info->size;
@


1.42
log
@* sim-d10v.h: Delete file.  Moved to include/gdb/.

* sim-d10v.h: New file.  Moved from include/sim-d10v.h.

* Makefile.in (INCLUDE): Add "gdb/sim-d10v.h".
* interp.c: Include "gdb/sim-d10v.h" instead of "sim-d10v.h".

* d10v-tdep.c: Include "gdb/sim-d10v.h" instead of "sim-d10v.h".
* Makefile.in (sim_d10v_h): Update definition.
@
text
@d44 1
d300 2
d316 2
@


1.42.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a43 1
#include "sim-regno.h"
a96 4
static CORE_ADDR d10v_read_sp (void);

static CORE_ADDR d10v_read_fp (void);

d185 1
a185 1
static const char *
d211 1
a211 1
static const char *
a298 2
  if (legacy_register_sim_regno (nr) < 0)
    return legacy_register_sim_regno (nr);
a312 2
  if (legacy_register_sim_regno (nr) < 0)
    return legacy_register_sim_regno (nr);
a363 2
  if (reg_nr == _SP_REGNUM || reg_nr == _FP_REGNUM)
    return builtin_type_void_data_ptr;
a441 4
/* Don't do anything if we have an integer, this way users can type 'x
   <addr>' w/o having gdb outsmart them.  The internal gdb conversions
   to the correct space are taken care of in the pointer_to_address
   function.  If we don't do this, 'x $fp' wouldn't work.  */
d447 9
a455 1
  return val;
d478 3
a480 14
  char tmp = 0;
  /* Only char return values need to be shifted right within R0.  */
  if (TYPE_LENGTH (type) == 1
      && TYPE_CODE (type) == TYPE_CODE_INT)
    {
      write_register_bytes (REGISTER_BYTE (RET1_REGNUM),
			    &tmp, 1);	/* zero the high byte */
      write_register_bytes (REGISTER_BYTE (RET1_REGNUM) + 1,
			    valbuf, 1);	/* copy the low byte */
    }
  else
    write_register_bytes (REGISTER_BYTE (RET1_REGNUM),
			  valbuf,
			  TYPE_LENGTH (type));
d846 1
a846 1
    fp = d10v_read_sp ();
d873 1
a873 1
	  = d10v_read_fp () + fi->extra_info->size;
a1070 9
  long val;

  /* If struct_return is true, then the struct return address will
     consume one argument-passing register.  No need to actually 
     write the value to the register -- that's done by 
     d10v_store_struct_return().  */

  if (struct_return)
    regnum++;
a1078 2
      int aligned_regnum = (regnum + 1) & ~1;

a1079 9
      if (len <= 2 && regnum <= ARGN_REGNUM)
	/* fits in a single register, do not align */
	{
	  val = extract_unsigned_integer (contents, len);
	  write_register (regnum++, val);
	}
      else if (len <= (ARGN_REGNUM - aligned_regnum + 1) * 2)
	/* value fits in remaining registers, store keeping left
	   aligned */
d1081 3
a1083 3
	  int b;
	  regnum = aligned_regnum;
	  for (b = 0; b < (len & ~1); b += 2)
d1085 1
a1085 1
	      val = extract_unsigned_integer (&contents[b], 2);
d1088 3
a1090 1
	  if (b < len)
d1092 18
a1109 2
	      val = extract_unsigned_integer (&contents[b], 1);
	      write_register (regnum++, (val << 8));
a1111 6
      else
	{
	  /* arg will go onto stack */
	  regnum = ARGN_REGNUM + 1;
	  si = push_stack_item (si, contents, len);
	}
d1133 1
a1133 18
#if 0
  printf("RET: TYPE=%d len=%d r%d=0x%x\n", TYPE_CODE (type), 
	 TYPE_LENGTH (type), RET1_REGNUM - R0_REGNUM, 
	 (int) extract_unsigned_integer (regbuf + REGISTER_BYTE(RET1_REGNUM), 
					 REGISTER_RAW_SIZE (RET1_REGNUM)));
#endif
  len = TYPE_LENGTH (type);
  if (len == 1)
    {
      unsigned short c;

      c = extract_unsigned_integer (regbuf + REGISTER_BYTE (RET1_REGNUM), 
				    REGISTER_RAW_SIZE (RET1_REGNUM));
      store_unsigned_integer (valbuf, 1, c);
    }
  else if ((len & 1) == 0)
    memcpy (valbuf, regbuf + REGISTER_BYTE (RET1_REGNUM), len);
  else
d1135 17
a1151 6
      /* For return values of odd size, the first byte is in the
	 least significant part of the first register.  The
	 remaining bytes in remaining registers. Interestingly,
	 when such values are passed in, the last byte is in the
	 most significant byte of that same register - wierd. */
      memcpy (valbuf, regbuf + REGISTER_BYTE (RET1_REGNUM) + 1, len);
d1578 1
a1578 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, d10v_extract_return_value);
d1585 1
a1585 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, d10v_extract_struct_value_address);
@


1.42.2.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d27 1
d1607 1
a1607 1
  set_gdbarch_get_saved_register (gdbarch, generic_unwind_get_saved_register);
@


1.42.2.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d1615 1
a1615 1
  set_gdbarch_deprecated_store_return_value (gdbarch, d10v_store_return_value);
@


1.42.2.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d516 3
a518 3
    return d10v_make_iaddr (deprecated_read_register_dummy (frame->pc, 
							    frame->frame, 
							    PC_REGNUM));
@


1.42.2.5
log
@merge from mainline
@
text
@d980 1
a980 1
      deprecated_read_register_gen (a, (char *) &num);
@


1.41
log
@* d10v-tdep.c (d10v_gdbarch_init): Revert old code included in
change `2002-05-22 Michael Snyder' below.
(d10v_push_arguments): Ditto.
(d10v_extract_return_value): Ditto.
@
text
@d43 1
a43 1
#include "sim-d10v.h"
@


1.40
log
@2002-05-22  Michael Snyder  <msnyder@@redhat.com>

        * d10v-tdep.c: Change a few macros to enums for ease of debugging.
        (d10v_frame_chain_valid): Add PC_IN_CALL_DUMMY clause.
        (d10v_frame_saved_pc): Add PC_IN_CALL_DUMMY clause.
        (d10v_frame_chain): Bail immediately if PC_IN_CALL_DUMMY.
        Don't bail if return_pc is PC_IN_CALL_DUMMY.
        Add a temp variable to save a call (and a memory read).
        (d10v_init_extra_frame_info): Get fi->pc from callee's return_pc
        if possible (so that PC_IN_CALL_DUMMY will work).
@
text
@d1079 1
a1079 1
      /* printf ("push: type=%d len=%d\n", type->code, len); */
d1133 1
a1133 1
  /*    printf("RET: TYPE=%d len=%d r%d=0x%x\n",type->code, TYPE_LENGTH (type), RET1_REGNUM - R0_REGNUM, (int) extract_unsigned_integer (regbuf + REGISTER_BYTE(RET1_REGNUM), REGISTER_RAW_SIZE (RET1_REGNUM)));  */
d1528 1
a1528 1
  set_gdbarch_register_virtual_size (gdbarch, generic_register_virtual_size);
@


1.39
log
@2002-05-13  Daniel Jacobowitz  <drow@@mvista.com>

        * ax-gdb.c (gen_sign_extend, gen_fetch, gen_usual_unary)
        (gen_cast, gen_scale, gen_add, gen_sub, gen_binop, gen_deref)
        (gen_address_of, gen_struct_ref, gen_repeat): Use type
        access macros.
        * c-typeprint.c (cp_type_print_method_args): Likewise.
        (c_type_print_args): Likewise.
        * d10v-tdep.c (d10v_push_arguments): Likewise.
        (d10v_extract_return_value): Likewise.
        * expprint.c (print_subexp): Likewise.
        * gdbtypes.c (lookup_primitive_typename): Likewise.
        (lookup_template_type, add_mangled_type, print_arg_types): Likewise.
        * gdbtypes.h (TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB)
        (TYPE_TARGET_STUB, TYPE_STATIC, TYPE_CONST, TYPE_VOLATILE)
        (TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_CODE_SPACE, TYPE_VARARGS)
        (TYPE_VECTOR): Likewise.
        * hpread.c (hpread_read_struct_type)
        (fix_static_member_physnames, fixup_class_method_type)
        (hpread_type_lookup): Likewise.
        * mdebugread.c (parse_symbol, parse_type): Likewise.
        * p-lang.c (is_pascal_string_type): Likewise.
        * valops.c (hand_function_call): Likewise.
        * x86-64-tdep.c (classify_argument): Likewise.

        * hpread.c (hpread_read_function_type)
        (hpread_read_doc_function_type): Call replace_type.
        * dstread.c (create_new_type): Delete.
        (decode_dst_structure, process_dst_function): Call alloc_type.
        Use type access macros.
@
text
@d63 5
a67 3
#define DMEM_START	0x2000000
#define IMEM_START	0x1000000
#define STACK_START	0x200bffe
d74 2
d77 1
d79 1
d81 7
a87 1
    NR_A_REGS = 2
d89 1
a92 6
/* d10v calling convention. */

#define ARG1_REGNUM R0_REGNUM
#define ARGN_REGNUM 3
#define RET1_REGNUM R0_REGNUM

d111 8
a118 3
  return ((chain) != 0 && (frame) != 0
	  && (frame)->pc > IMEM_START
	  && !inside_entry_file (FRAME_SAVED_PC (frame)));
d498 6
a503 1
  return ((frame)->extra_info->return_pc);
d670 6
d678 1
d681 6
a686 1
    return (CORE_ADDR) 0;
d697 3
a699 2
  if (!read_memory_unsigned_integer (fi->saved_regs[FP_REGNUM],
				     REGISTER_RAW_SIZE (FP_REGNUM)))
d702 1
a702 2
  return d10v_make_daddr (read_memory_unsigned_integer (fi->saved_regs[FP_REGNUM],
					    REGISTER_RAW_SIZE (FP_REGNUM)));
d836 2
a837 1
	  if (!prologue_find_regs (op1, fi, pc) || !prologue_find_regs (op2, fi, pc))
d856 3
a858 1
      CORE_ADDR return_pc = read_memory_unsigned_integer (fi->saved_regs[LR_REGNUM], REGISTER_RAW_SIZE (LR_REGNUM));
d866 1
a866 1
  /* th SP is not normally (ever?) saved, but check anyway */
d872 2
a873 1
	fi->saved_regs[SP_REGNUM] = read_register (FP_REGNUM) + fi->extra_info->size;
d894 6
d1079 1
a1079 1
      /* printf ("push: type=%d len=%d\n", TYPE_CODE (type), len); */
d1133 1
a1133 1
  /*    printf("RET: TYPE=%d len=%d r%d=0x%x\n", TYPE_CODE (type), TYPE_LENGTH (type), RET1_REGNUM - R0_REGNUM, (int) extract_unsigned_integer (regbuf + REGISTER_BYTE(RET1_REGNUM), REGISTER_RAW_SIZE (RET1_REGNUM)));  */
d1528 1
a1528 1
  set_gdbarch_register_virtual_size (gdbarch, generic_register_size);
@


1.39.2.1
log
@merge from trunk
@
text
@d43 1
a43 2
#include "gdb/sim-d10v.h"
#include "sim-regno.h"
d63 3
a65 5
enum memspace {
  DMEM_START  = 0x2000000,
  IMEM_START  = 0x1000000,
  STACK_START = 0x200bffe
};
a71 2
    R3_REGNUM = 3,
    _FP_REGNUM = 11,
a72 1
    _SP_REGNUM = 15,
a73 1
    _PC_REGNUM = 18,
d75 1
a75 7
    NR_A_REGS = 2,
    TS2_NUM_REGS = 37,
    TS3_NUM_REGS = 42,
    /* d10v calling convention. */
    ARG1_REGNUM = R0_REGNUM,
    ARGN_REGNUM = R3_REGNUM,
    RET1_REGNUM = R0_REGNUM,
a76 1

d80 6
a89 4
static CORE_ADDR d10v_read_sp (void);

static CORE_ADDR d10v_read_fp (void);

d104 3
a106 8
  if (chain != 0 && frame != NULL)
    {
      if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
	return 1;	/* Path back from a call dummy must be valid. */
      return ((frame)->pc > IMEM_START
	      && !inside_main_func (frame->pc));
    }
  else return 0;
a286 2
  if (legacy_register_sim_regno (nr) < 0)
    return legacy_register_sim_regno (nr);
a300 2
  if (legacy_register_sim_regno (nr) < 0)
    return legacy_register_sim_regno (nr);
a351 2
  if (reg_nr == _SP_REGNUM || reg_nr == _FP_REGNUM)
    return builtin_type_void_data_ptr;
a429 4
/* Don't do anything if we have an integer, this way users can type 'x
   <addr>' w/o having gdb outsmart them.  The internal gdb conversions
   to the correct space are taken care of in the pointer_to_address
   function.  If we don't do this, 'x $fp' wouldn't work.  */
d435 9
a443 1
  return val;
d466 3
a468 14
  char tmp = 0;
  /* Only char return values need to be shifted right within R0.  */
  if (TYPE_LENGTH (type) == 1
      && TYPE_CODE (type) == TYPE_CODE_INT)
    {
      write_register_bytes (REGISTER_BYTE (RET1_REGNUM),
			    &tmp, 1);	/* zero the high byte */
      write_register_bytes (REGISTER_BYTE (RET1_REGNUM) + 1,
			    valbuf, 1);	/* copy the low byte */
    }
  else
    write_register_bytes (REGISTER_BYTE (RET1_REGNUM),
			  valbuf,
			  TYPE_LENGTH (type));
d486 1
a486 6
  if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
    return d10v_make_iaddr (generic_read_register_dummy (frame->pc, 
							 frame->frame, 
							 PC_REGNUM));
  else
    return ((frame)->extra_info->return_pc);
a652 6
  CORE_ADDR addr;

  /* A generic call dummy's frame is the same as caller's.  */
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
    return fi->frame;

a654 1
  
d657 1
a657 6
    {
      /* This is meant to halt the backtrace at "_start".
	 Make sure we don't halt it at a generic dummy frame. */
      if (!PC_IN_CALL_DUMMY (fi->extra_info->return_pc, 0, 0))
	return (CORE_ADDR) 0;
    }
d668 2
a669 3
  addr = read_memory_unsigned_integer (fi->saved_regs[FP_REGNUM],
				       REGISTER_RAW_SIZE (FP_REGNUM));
  if (addr == 0)
d672 2
a673 1
  return d10v_make_daddr (addr);
d807 1
a807 2
	  if (!prologue_find_regs (op1, fi, pc) 
	      || !prologue_find_regs (op2, fi, pc))
d816 1
a816 1
    fp = d10v_read_sp ();
d826 1
a826 3
      CORE_ADDR return_pc 
	= read_memory_unsigned_integer (fi->saved_regs[LR_REGNUM], 
					REGISTER_RAW_SIZE (LR_REGNUM));
d834 1
a834 1
  /* The SP is not normally (ever?) saved, but check anyway */
d840 1
a840 2
	fi->saved_regs[SP_REGNUM] 
	  = d10v_read_fp () + fi->extra_info->size;
a860 6
  /* If fi->pc is zero, but this is not the outermost frame, 
     then let's snatch the return_pc from the callee, so that
     PC_IN_CALL_DUMMY will work.  */
  if (fi->pc == 0 && fi->level != 0 && fi->next != NULL)
    fi->pc = d10v_frame_saved_pc (fi->next);

a1031 9
  long val;

  /* If struct_return is true, then the struct return address will
     consume one argument-passing register.  No need to actually 
     write the value to the register -- that's done by 
     d10v_store_struct_return().  */

  if (struct_return)
    regnum++;
a1039 2
      int aligned_regnum = (regnum + 1) & ~1;

a1040 9
      if (len <= 2 && regnum <= ARGN_REGNUM)
	/* fits in a single register, do not align */
	{
	  val = extract_unsigned_integer (contents, len);
	  write_register (regnum++, val);
	}
      else if (len <= (ARGN_REGNUM - aligned_regnum + 1) * 2)
	/* value fits in remaining registers, store keeping left
	   aligned */
d1042 3
a1044 3
	  int b;
	  regnum = aligned_regnum;
	  for (b = 0; b < (len & ~1); b += 2)
d1046 1
a1046 1
	      val = extract_unsigned_integer (&contents[b], 2);
d1049 18
a1066 1
	  if (b < len)
d1068 3
a1070 2
	      val = extract_unsigned_integer (&contents[b], 1);
	      write_register (regnum++, (val << 8));
a1072 6
      else
	{
	  /* arg will go onto stack */
	  regnum = ARGN_REGNUM + 1;
	  si = push_stack_item (si, contents, len);
	}
d1094 1
a1094 18
#if 0
  printf("RET: TYPE=%d len=%d r%d=0x%x\n", TYPE_CODE (type), 
	 TYPE_LENGTH (type), RET1_REGNUM - R0_REGNUM, 
	 (int) extract_unsigned_integer (regbuf + REGISTER_BYTE(RET1_REGNUM), 
					 REGISTER_RAW_SIZE (RET1_REGNUM)));
#endif
  len = TYPE_LENGTH (type);
  if (len == 1)
    {
      unsigned short c;

      c = extract_unsigned_integer (regbuf + REGISTER_BYTE (RET1_REGNUM), 
				    REGISTER_RAW_SIZE (RET1_REGNUM));
      store_unsigned_integer (valbuf, 1, c);
    }
  else if ((len & 1) == 0)
    memcpy (valbuf, regbuf + REGISTER_BYTE (RET1_REGNUM), len);
  else
d1096 17
a1112 6
      /* For return values of odd size, the first byte is in the
	 least significant part of the first register.  The
	 remaining bytes in remaining registers. Interestingly,
	 when such values are passed in, the last byte is in the
	 most significant byte of that same register - wierd. */
      memcpy (valbuf, regbuf + REGISTER_BYTE (RET1_REGNUM) + 1, len);
d1539 1
a1539 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, d10v_extract_return_value);
d1546 1
a1546 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, d10v_extract_struct_value_address);
@


1.39.2.2
log
@Merge with trunk.
@
text
@d190 1
a190 1
static const char *
d216 1
a216 1
static const char *
@


1.38
log
@* arch-utils.h (generic_register_size): Declare.
(generic_register_raw_size, generic_register_virtual_size): Delete
declarations.
* arch-utils.c (generic_register_raw_size): Delete.
(generic_register_size): New function.
(generic_register_virtual_size): Delete.

* gdbarch.sh (REGISTER_RAW_SIZE, REGISTER_VIRTUAL_SIZE): Make
default generic_register_size.
* gdbarch.h, gdbarch.c: Re-generate.

* d10v-tdep.c (d10v_gdbarch_init): Use generic_register_size for
register_virtual_size.
* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.

* gdbint.texinfo (Target Architecture Definition): Mention
defaults for REGISTER_VIRTUAL_SIZE and REGISTER_RAW_SIZE.
(Target Architecture Definition): Mention same.  Add references to
web pages.
@
text
@d1040 1
a1040 1
      /* printf ("push: type=%d len=%d\n", type->code, len); */
d1094 1
a1094 1
  /*    printf("RET: TYPE=%d len=%d r%d=0x%x\n",type->code, TYPE_LENGTH (type), RET1_REGNUM - R0_REGNUM, (int) extract_unsigned_integer (regbuf + REGISTER_BYTE(RET1_REGNUM), REGISTER_RAW_SIZE (RET1_REGNUM)));  */
@


1.37
log
@* gdbarch.sh (BREAKPOINT_FROM_PC): Return a const buffer.
* gdbarch.h, gdbarch.c: Regenerate.

* defs.h (breakpoint_from_pc_fn): Delete type definition.
* target.h (memory_breakpoint_from_pc): Update declaration.
* config/mcore/tm-mcore.h (mcore_breakpoint_from_p): Ditto.

* arch-utils.c (legacy_breakpoint_from_pc): Update return type.
* mcore-tdep.c (mcore_breakpoint_from_pc): Ditto.
* mem-break.c (memory_breakpoint_from_pc): Ditto.
* rs6000-tdep.c (rs6000_breakpoint_from_pc): Ditto.
* s390-tdep.c (s390_breakpoint_from_pc): Ditto
* xstormy16-tdep.c (xstormy16_breakpoint_from_pc): Ditto.
* mn10300-tdep.c (mn10300_breakpoint_from_pc): Ditto.
* mips-tdep.c (mips_breakpoint_from_pc): Ditto.
* m68hc11-tdep.c (m68hc11_breakpoint_from_pc): Ditto.
* ia64-tdep.c (ia64_breakpoint_from_pc): Ditto.
* d10v-tdep.c (d10v_breakpoint_from_pc): Ditto.
* arch-utils.c (legacy_breakpoint_from_pc): Ditto..

* mem-break.c (default_memory_insert_breakpoint): Make `bp' a
const pointer.
* monitor.c (monitor_insert_breakpoint): Ditto.
* rs6000-tdep.c (rs6000_software_single_step): Ditto for `breakp'.

* config/mcore/tm-mcore.h: Update copyright.
* mem-break.c: Ditto.
* xstormy16-tdep.c: Ditto.
@
text
@d1489 1
a1489 1
  set_gdbarch_register_virtual_size (gdbarch, generic_register_virtual_size);
@


1.36
log
@2002-04-12  Michael Snyder  <msnyder@@redhat.com>

	* d10v-tdep.c (d10v_make_iaddr): Make it idempotent,
	in case it gets applied to an address that is already
	in the instruction space.
@
text
@d153 1
a153 1
static unsigned char *
@


1.35
log
@* h8500-tdep.c (h8500_write_fp): Delete function.
* dwarf2cfi.c (cfi_write_fp): Document as not used.
* mips-tdep.c (mips_gdbarch_init): Do not set write_fp.
* ia64-tdep.c (ia64_gdbarch_init): Do not set write_fp.
* m68hc11-tdep.c (m68hc11_gdbarch_init): Do not set write_fp.
* rs6000-tdep.c (rs6000_gdbarch_init): Do not set write_fp.
* s390-tdep.c (s390_gdbarch_init): Do not set write_fp.
(s390_write_fp):
* sh-tdep.c (sh_gdbarch_init): Do not set write_fp.
* x86-64-tdep.c (i386_gdbarch_init): Do not set write_fp.
* d10v-tdep.c (d10v_gdbarch_init): Do not set write_fp.
(d10v_write_fp): Delete function.
* inferior.h (write_fp, generic_target_write_fp): Delete
declarations.
* regcache.c (generic_target_write_fp): Delete function.
(write_fp): Delete function.
* gdbarch.sh (TARGET_WRITE_FP): Delete.
* gdbarch.h, gdbarch.c: Regenerate.
* config/v850/tm-v850.h (TARGET_WRITE_FP): Delete macro.
* config/sparc/tm-sp64.h (TARGET_WRITE_FP): Delete macro.
(sparc64_write_fp): Delete declaration.
* config/h8500/tm-h8500.h (TARGET_WRITE_FP): Delete macro.
(h8500_write_fp): Delete declaration.
@
text
@a358 12
static CORE_ADDR
d10v_make_daddr (CORE_ADDR x)
{
  return ((x) | DMEM_START);
}

static CORE_ADDR
d10v_make_iaddr (CORE_ADDR x)
{
  return (((x) << 2) | IMEM_START);
}

d371 14
@


1.34
log
@* defs.h (XMALLOC): Define.
* gdb-events.sh (XMALLOC): Delete macro.
* gdb-events.c, gdb-events.h: Regenerate.
* gdbarch.sh (XMALLOC): Delete macro.
* gdbarch.c: Regenerate.
* serial.c (XMALLOC): Delete macro.
* ui-file.c (XMALLOC): Ditto.
* ser-unix.h (XMALLOC): Ditto.
* sh-tdep.c (XMALLOC): Ditto.
* ui-out.c (XMALLOC): Ditto.
* utils.c (XMALLOC): Ditto.
* i386-tdep.c (XMALLOC): Ditto.
* gdb-events.c (XMALLOC): Ditto.
* d10v-tdep.c (XMALLOC): Ditto.
* cli-out.c (XMALLOC): Ditto.

* cli-out.c, d10v-tdep.c, gdb-events.c: Update copyright.
* gdb-events.sh, i386-tdep.c, ser-unix.h, serial.c: Ditto.
* ui-file.c, ui-out.c: Ditto.
@
text
@a968 6
static void
d10v_write_fp (CORE_ADDR val)
{
  write_register (FP_REGNUM, d10v_convert_daddr_to_raw (val));
}

a1473 1
  set_gdbarch_write_fp (gdbarch, d10v_write_fp);
@


1.33
log
@* defs.h (vwarning): Declare.
(warning_begin): Delete declaration.
* utils.c (vwarning): New function.
(warning): Call vwarning.
(warning_begin): Delete function.

* rs6000-nat.c (vmap_ldinfo): Use the function warning to print
the warning message.
* d10v-tdep.c (d10v_address_to_pointer) [0]: Delete call to
warning_begin.
@
text
@d2 3
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
a43 3

#undef XMALLOC
#define XMALLOC(TYPE) ((TYPE*) xmalloc (sizeof (TYPE)))
@


1.32
log
@2002-01-07  Jackie Smith Cashion  <jsmith@@redhat.com>

	From Nick Clifton  <nickc@@redhat.com>
	* d10v-tdep.c: Set STACK_START to 0x200bffe.
@
text
@a404 10
#if 0
      if (! d10v_iaddr_p (addr))
        {
          warning_begin ();
          fprintf_unfiltered (gdb_stderr, "address `");
          print_address_numeric (addr, 1, gdb_stderr);
          fprintf_unfiltered (gdb_stderr, "' is not a code address\n");
        }
#endif

@


1.31
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d67 1
a67 1
#define STACK_START	0x0007ffe
@


1.30
log
@LITTLE_ENDIAN -> BFD_ENDIAN_LITTLE
@
text
@d1271 1
a1271 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d1526 1
a1526 1
    case BIG_ENDIAN:
@


1.29
log
@Approved by Jim Blandy:

	2001-12-11  Fred Fish  <fnf@@redhat.com>
	* c-typeprint.c (c_type_print_base): Use type flags access macros
	to test bits.
	* ch-typeprint.c (chill_type_print_base): Ditto.
	* ch-valprint.c (chill_val_print): Ditto.
	* d10v-tdep.c (d10v_pointer_to_address): Ditto.
	* dwarf2read.c (dwarf2_add_member_fn): Ditto.
	* dwarfread.c (read_structure_scope): Ditto.
	* gdbtypes.c (create_range_type): Dittol
	(create_set_type): Ditto.
	(check_typedef): Ditto.
	* jv-typeprint.c (java_type_print_base): Ditto.
	* p-typeprint.c (pascal_type_print_base): Ditto
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (read_cfront_member_functions): Ditto.
	(read_member_functions): Ditto.
	(cleanup_undefined_types): Ditto.
	* valprint.c (val_print): Ditto.
	* valops.c (hand_function_call): Remove is_prototyped
	variable and just use type flag test macro directly.
@
text
@d1531 1
a1531 1
    case LITTLE_ENDIAN:
@


1.28
log
@2001-12-11  Michael Snyder  <msnyder@@redhat.com>

	* d10v-tdep.c (d10v_register_virtual_size): Delete.
	(d10v_gdbarch_init): Use generic_register_virtual_size.
	* rs6000-tdep.c (rs6000_register_virtual_size): Delete.
	(rs6000_gdbarch_init): Use generic_register_virtual_size.
	* x86-64-tdep.c (x86_64_register_virtual_size): Delete.
	(i386_gdbarch_init): Use generic_register_virtual_size.
@
text
@d433 2
a434 2
      || TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_METHOD ||
      (TYPE_FLAGS (TYPE_TARGET_TYPE (type)) & TYPE_FLAG_CODE_SPACE) != 0)
@


1.27
log
@2001-12-04  Jackie Smith Cashion  <jsmith@@redhat.com>

	* MAINTAINERS (write-after-approval): Add self.

	* d10v-tdep.c (d10v_gdbarch_init): Change size of long long to 8 bytes.

	From Andrew Cagney  <cagney@@redhat.com>:
        * d10v-tdep.c (d10v_frame_chain_valid): Check if the caller's PC
        is in the entry function.
        (d10v_use_struct_convention): Store multi-field struct and union
        return values on the stack.
@
text
@a345 9
/* Number of bytes of storage in the program's representation
   for register N.  */

static int
d10v_register_virtual_size (int reg_nr)
{
  return TYPE_LENGTH (REGISTER_VIRTUAL_TYPE (reg_nr));
}

d1506 1
a1506 1
  set_gdbarch_register_virtual_size (gdbarch, d10v_register_virtual_size);
@


1.26
log
@2001-11-14  Michael Snyder  <msnyder@@redhat.com>

        * d10v-tdep.c (d10v_pointer_to_address): Use new type flag
	TYPE_FLAG_CODE_SPACE to recognize a pointer that has been cast
	into the instruction address space.
	* Makefile.in (doublest.o): Add dependency on gdbtypes.h.
@
text
@d106 3
a108 1
  return ((chain) != 0 && (frame) != 0 && (frame)->pc > IMEM_START);
d127 25
a151 1
  return (TYPE_LENGTH (type) > 8);
d1527 1
a1527 1
  set_gdbarch_long_long_bit (gdbarch, 4 * TARGET_CHAR_BIT);
@


1.25
log
@Add INTEGER_TO_ADDRESS to hadle nasty harvard architectures that do
funnies to integer to address conversions.
@
text
@d416 2
a417 1
      || TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_METHOD)
@


1.24
log
@2001-09-05  Elena Zannoni  <ezannoni@@redhat.com>

        * gdbarch.sh: Move include of dis-asm.h so it is generated earlier
        in gdbarch.h.
        (TARGET_PRINT_INSN): Multiarch.
        * gdbarch.h: Regenerate.
        * gdbarch.c: Regenerate.

        * arch-utils.c (legacy_print_insn): New function.
        * arch-utils.h (legacy_print_insn): Export.

        * cris-tdep.c (cris_delayed_get_disassembler): Use
        TARGET_PRINT_INSN, instead of tm_print_insn.
        * d10v-tdep.c (print_insn): Ditto.
        * d30v-tdep.c (print_insn): Ditto.
        * m32r-tdep.c (dump_insn): Ditto.
        * v850-tdep.c (v850_scan_prologue): Ditto.
        * mcore-tdep.c (mcore_dump_insn): Ditto.
        * sh-tdep.c (sh_gdbarch_init): Set print_insn gdbarch field.
@
text
@d422 15
d1496 1
@


1.23
log
@s/value_ptr/struct value */
@
text
@d1242 1
a1242 1
  return (*tm_print_insn) (memaddr, &tm_print_insn_info);
@


1.22
log
@Clean up the D10V port so that GDB and the target program no
longer disagree on how big pointers are.
* findvar.c (value_from_register): Remove special case code for D10V.
* printcmd.c (print_frame_args): Same.
* valops.c (value_at, value_fetch_lazy): Same.
* values.c (unpack_long): Same.
* gdbarch.sh: Changes to effect the following:
* gdbarch.h (GDB_TARGET_IS_D10V, D10V_MAKE_DADDR,
gdbarch_d10v_make_daddr_ftype, gdbarch_d10v_make_daddr,
set_gdbarch_d10v_make_daddr, D10V_MAKE_IADDR,
gdbarch_d10v_make_iaddr_ftype, gdbarch_d10v_make_iaddr,
set_gdbarch_d10v_make_iaddr, D10V_DADDR_P,
gdbarch_d10v_daddr_p_ftype, gdbarch_d10v_daddr_p,
set_gdbarch_d10v_daddr_p, D10V_IADDR_P,
gdbarch_d10v_iaddr_p_ftype, gdbarch_d10v_iaddr_p,
set_gdbarch_d10v_iaddr_p, D10V_CONVERT_DADDR_TO_RAW,
gdbarch_d10v_convert_daddr_to_raw_ftype,
gdbarch_d10v_convert_daddr_to_raw,
set_gdbarch_d10v_convert_daddr_to_raw, D10V_CONVERT_IADDR_TO_RAW,
gdbarch_d10v_convert_iaddr_to_raw_ftype,
gdbarch_d10v_convert_iaddr_to_raw,
set_gdbarch_d10v_convert_iaddr_to_raw): Delete declarations.
* gdbarch.c: Delete the corresponding definitions.
(struct gdbarch): Delete members d10v_make_daddr,
d10v_make_iaddr, d10v_daddr_p, d10v_iaddr_p,
d10v_convert_daddr_to_raw, and d10v_convert_iaddr_to_raw.
(startup_gdbarch): Remove initializers for the above.
(verify_gdbarch, gdbarch_dump): Don't verify or dump them any
more.
* d10v-tdep.c (d10v_register_virtual_type): Rather that
claiming the stack pointer and PC are 32 bits long (which they
aren't), say that the stack pointer is an int16_t, and the
program counter is a function pointer.  This allows the rest
of GDB to make the appropriate conversions between the code
pointer format and real addresses.
(d10v_register_convertible, d10v_register_convert_to_virtual,
d10v_register_convert_to_raw): Delete function; no registers
are convertible now, so we use
generic_register_convertible_not instead.
(d10v_address_to_pointer, d10v_pointer_to_address): New gdbarch
methods.
(d10v_push_arguments, d10v_extract_return_value): Remove special
cases for code and data pointers.
(d10v_gdbarch_init): Set gdbarch_ptr_bit to 16, so that GDB and
the target agree on how large pointers are.  Say that addresses
are 32 bits long.  Register the address_to_pointer and
pointer_to_address conversion functions.  Since no registers are
convertible now, register generic_register_convertible_not as the
gdbarch_register_convertible method instead of
d10v_register_convertible.  Remove registrations for
d10v_register_convert_to_virtual,
d10v_register_convert_to_raw, gdbarch_d10v_make_daddr,
gdbarch_d10v_make_iaddr, gdbarch_d10v_daddr_p,
gdbarch_d10v_iaddr_p, gdbarch_d10v_convert_daddr_to_raw, and
gdbarch_d10v_convert_iaddr_to_raw.
@
text
@d1009 1
a1009 1
d10v_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
d1019 1
a1019 1
      value_ptr arg = args[i];
@


1.21
log
@* d10v-tdep.c (d10v_frame_chain, d10v_frame_init_saved_regs,
show_regs, d10v_read_pc, d10v_write_pc, d10v_read_sp,
d10v_write_sp, d10v_write_fp, d10v_read_fp,
d10v_push_return_address): Call the functions d10v_make_daddr,
d10v_make_iaddr, d10v_convert_iaddr_to_raw, and
d10v_convert_daddr_to_raw, not the global macros D10V_MAKE_DADDR,
D10V_MAKE_IADDR, D10V_CONVERT_IADDR_TO_RAW, and
D10V_CONVERT_DADDR_TO_RAW.
@
text
@d335 3
a337 1
  if (reg_nr >= A0_REGNUM
a339 3
  else if (reg_nr == PC_REGNUM
	   || reg_nr == SP_REGNUM)
    return builtin_type_int32;
a343 31
/* convert $pc and $sp to/from virtual addresses */
static int
d10v_register_convertible (int nr)
{
  return ((nr) == PC_REGNUM || (nr) == SP_REGNUM);
}

static void
d10v_register_convert_to_virtual (int regnum, struct type *type, char *from,
				  char *to)
{
  ULONGEST x = extract_unsigned_integer (from, REGISTER_RAW_SIZE (regnum));
  if (regnum == PC_REGNUM)
    x = (x << 2) | IMEM_START;
  else
    x |= DMEM_START;
  store_unsigned_integer (to, TYPE_LENGTH (type), x);
}

static void
d10v_register_convert_to_raw (struct type *type, int regnum, char *from,
			      char *to)
{
  ULONGEST x = extract_unsigned_integer (from, TYPE_LENGTH (type));
  x &= 0x3ffff;
  if (regnum == PC_REGNUM)
    x >>= 2;
  store_unsigned_integer (to, 2, x);
}


d381 42
a1023 33
      if (TYPE_CODE (type) == TYPE_CODE_PTR)
	{
	  /* pointers require special handling - first convert and
	     then store */
	  long val = extract_signed_integer (contents, len);
	  len = 2;
	  if (TYPE_TARGET_TYPE (type)
	      && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC))
	    {
	      /* function pointer */
	      val = d10v_convert_iaddr_to_raw (val);
	    }
	  else if (d10v_iaddr_p (val))
	    {
	      /* also function pointer! */
	      val = d10v_convert_daddr_to_raw (val);
	    }
	  else
	    {
	      /* data pointer */
	      val &= 0xFFFF;
	    }
	  if (regnum <= ARGN_REGNUM)
	    write_register (regnum++, val & 0xffff);
	  else
	    {
	      char ptr[2];
	      /* arg will go onto stack */
	      store_address (ptr, 2, val & 0xffff);
	      si = push_stack_item (si, ptr, 2);
	    }
	}
      else
a1077 19
  if (TYPE_CODE (type) == TYPE_CODE_PTR
      && TYPE_TARGET_TYPE (type)
      && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC))
    {
      /* pointer to function */
      int num;
      short snum;
      snum = extract_address (regbuf + REGISTER_BYTE (RET1_REGNUM), REGISTER_RAW_SIZE (RET1_REGNUM));
      store_address (valbuf, 4, d10v_make_iaddr (snum));
    }
  else if (TYPE_CODE (type) == TYPE_CODE_PTR)
    {
      /* pointer to data */
      int num;
      short snum;
      snum = extract_address (regbuf + REGISTER_BYTE (RET1_REGNUM), REGISTER_RAW_SIZE (RET1_REGNUM));
      store_address (valbuf, 4, d10v_make_daddr (snum));
    }
  else
d1477 4
a1480 1
  set_gdbarch_ptr_bit (gdbarch, 4 * TARGET_CHAR_BIT);
a1521 4
  set_gdbarch_register_convertible (gdbarch, d10v_register_convertible);
  set_gdbarch_register_convert_to_virtual (gdbarch, d10v_register_convert_to_virtual);
  set_gdbarch_register_convert_to_raw (gdbarch, d10v_register_convert_to_raw);

a1525 7

  set_gdbarch_d10v_make_daddr (gdbarch, d10v_make_daddr);
  set_gdbarch_d10v_make_iaddr (gdbarch, d10v_make_iaddr);
  set_gdbarch_d10v_daddr_p (gdbarch, d10v_daddr_p);
  set_gdbarch_d10v_iaddr_p (gdbarch, d10v_iaddr_p);
  set_gdbarch_d10v_convert_daddr_to_raw (gdbarch, d10v_convert_daddr_to_raw);
  set_gdbarch_d10v_convert_iaddr_to_raw (gdbarch, d10v_convert_iaddr_to_raw);
@


1.21.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d1020 2
a1021 2
	  if (POINTER_TARGET_TYPE (type)
	      && (TYPE_CODE (POINTER_TARGET_TYPE (type)) == TYPE_CODE_FUNC))
d1102 2
a1103 2
      && POINTER_TARGET_TYPE (type)
      && (TYPE_CODE (POINTER_TARGET_TYPE (type)) == TYPE_CODE_FUNC))
@


1.20
log
@* d10v-tdep.c (d10v_ts2_dmap_register): Doc fix.
@
text
@d639 1
a639 1
  return D10V_MAKE_DADDR (read_memory_unsigned_integer (fi->saved_regs[FP_REGNUM],
d783 1
a783 1
    fp = D10V_MAKE_DADDR (read_register (SP_REGNUM));
d794 1
a794 1
      fi->extra_info->return_pc = D10V_MAKE_IADDR (return_pc);
d798 1
a798 1
      fi->extra_info->return_pc = D10V_MAKE_IADDR (read_register (LR_REGNUM));
d846 1
a846 1
		   (long) D10V_MAKE_IADDR (read_register (PC_REGNUM)),
d911 1
a911 1
  retval = D10V_MAKE_IADDR (pc);
d922 1
a922 1
  write_register (PC_REGNUM, D10V_CONVERT_IADDR_TO_RAW (val));
d929 1
a929 1
  return (D10V_MAKE_DADDR (read_register (SP_REGNUM)));
d935 1
a935 1
  write_register (SP_REGNUM, D10V_CONVERT_DADDR_TO_RAW (val));
d941 1
a941 1
  write_register (FP_REGNUM, D10V_CONVERT_DADDR_TO_RAW (val));
d947 1
a947 1
  return (D10V_MAKE_DADDR (read_register (FP_REGNUM)));
d957 1
a957 1
  write_register (LR_REGNUM, D10V_CONVERT_IADDR_TO_RAW (CALL_DUMMY_ADDRESS ()));
d1024 1
a1024 1
	      val = D10V_CONVERT_IADDR_TO_RAW (val);
d1026 1
a1026 1
	  else if (D10V_IADDR_P (val))
d1029 1
a1029 1
	      val = D10V_CONVERT_DADDR_TO_RAW (val);
d1109 1
a1109 1
      store_address (valbuf, 4, D10V_MAKE_IADDR (snum));
d1117 1
a1117 1
      store_address (valbuf, 4, D10V_MAKE_DADDR (snum));
@


1.19
log
@* d10v-tdep.c (10v_frame_chain_valid, d10v_use_struct_convention,
d10v_breakpoint_from_pc, d10v_register_byte,
d10v_register_raw_size, d10v_register_virtual_size,
d10v_register_virtual_type, d10v_register_convertible,
d10v_register_convert_to_virtual, d10v_register_convert_to_raw,
d10v_make_daddr, d10v_make_iaddr, d10v_daddr_p, d10v_iaddr_p,
d10v_convert_iaddr_to_raw, d10v_convert_daddr_to_raw,
d10v_store_struct_return, d10v_store_return_value,
d10v_extract_struct_value_address, d10v_frame_saved_pc,
d10v_saved_pc_after_call, d10v_pop_frame, d10v_skip_prologue,
d10v_frame_chain, d10v_frame_init_saved_regs,
d10v_init_extra_frame_info, d10v_read_pc, d10v_write_pc,
d10v_read_sp, d10v_write_sp, d10v_write_fp, d10v_read_fp,
d10v_push_return_address, d10v_push_arguments,
d10v_extract_return_value): Make these functions static.
@
text
@d196 14
a209 1
/* Access the DMAP/IMAP registers in a target independent way. */
@


1.18
log
@Phase 1 of the ptid_t changes.
@
text
@d99 1
a99 1
extern void d10v_frame_init_saved_regs (struct frame_info *);
d103 1
a103 1
int
d122 1
a122 1
int
d129 1
a129 1
unsigned char *
d279 1
a279 1
int
d296 1
a296 1
int
d310 1
a310 1
int
d319 1
a319 1
struct type *
d333 1
a333 1
int
d339 1
a339 1
void
d351 1
a351 1
void
d363 1
a363 1
CORE_ADDR
d369 1
a369 1
CORE_ADDR
d375 1
a375 1
int
d381 1
a381 1
int
d388 1
a388 1
CORE_ADDR
d394 1
a394 1
CORE_ADDR
d406 1
a406 1
void
d417 1
a417 1
void
d429 1
a429 1
CORE_ADDR
d437 1
a437 1
CORE_ADDR
d447 1
a447 1
CORE_ADDR
d457 1
a457 1
void
d536 1
a536 1
CORE_ADDR
d604 1
a604 1
CORE_ADDR
d703 1
a703 1
void
d804 1
a804 1
void
d887 1
a887 1
CORE_ADDR
d902 1
a902 1
void
d913 1
a913 1
CORE_ADDR
d919 1
a919 1
void
d925 1
a925 1
void
d931 1
a931 1
CORE_ADDR
d941 1
a941 1
CORE_ADDR
d985 1
a985 1
CORE_ADDR
d1082 1
a1082 1
void
@


1.17
log
@Update/correct copyright notices.
@
text
@d888 1
a888 1
d10v_read_pc (int pid)
d890 1
a890 1
  int save_pid;
d894 2
a895 2
  save_pid = inferior_pid;
  inferior_pid = pid;
d897 1
a897 1
  inferior_pid = save_pid;
d903 1
a903 1
d10v_write_pc (CORE_ADDR val, int pid)
d905 1
a905 1
  int save_pid;
d907 2
a908 2
  save_pid = inferior_pid;
  inferior_pid = pid;
d910 1
a910 1
  inferior_pid = save_pid;
@


1.16
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright (C) 1996, 1997, 2000, 2001 Free Software Foundation, Inc.
@


1.15
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d38 1
@


1.14
log
@2000-12-20  Michael Snyder  <msnyder@@mvstp600e.cygnus.com>

        * arch-utils.c (default_frame_address): New function.  Default
        implementation of frame_args_address and frame_locals_address.
        * arch-utils.h (default_frame_address): Export.
        * d10v-tdep.c (d10v_gdbarch_init): Use default_frame_address.
        (d10v_frame_args_address, d10v_frame_locals_address): Delete.
        * sh-tdep.c (sh_gdbarch_init): Use default_frame_address.
        (sh_frame_args_address, sh_frame_locals_address): Delete.
        * sparc-tdep.c (sparc_gdbarch_init): Use default_frame_address.
        (sparc_frame_address): Delete.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 2000 Free Software Foundation, Inc.
d1262 2
a1263 1
    internal_error ("print_insn: no disassembler");
d1527 2
a1528 1
      internal_error ("d10v_gdbarch_init: bad byte order for float format");
@


1.13
log
@Replace free() with xfree().
@
text
@a440 12
CORE_ADDR
d10v_frame_args_address (struct frame_info *fi)
{
  return (fi)->frame;
}

CORE_ADDR
d10v_frame_locals_address (struct frame_info *fi)
{
  return (fi)->frame;
}

d1583 2
a1584 2
  set_gdbarch_frame_args_address (gdbarch, d10v_frame_args_address);
  set_gdbarch_frame_locals_address (gdbarch, d10v_frame_locals_address);
@


1.12
log
@
Spelling correction in comment:  dependant->dependent
@
text
@d989 2
a990 2
  free (dead->data);
  free (dead);
d1349 1
a1349 1
  free (tmpspace);
@


1.11
log
@Protoization.
@
text
@d194 1
a194 1
/* Access the DMAP/IMAP registers in a target independant way. */
@


1.10
log
@Multi-arch EXTRA_STACK_ALIGNMENT_NEEDED (nee NO_EXTRA_ALIGNMENT_NEEDED).
@
text
@d102 1
a102 3
d10v_frame_chain_valid (chain, frame)
     CORE_ADDR chain;
     struct frame_info *frame;	/* not used here */
d1093 2
a1094 4
d10v_extract_return_value (type, regbuf, valbuf)
     struct type *type;
     char regbuf[REGISTER_BYTES];
     char *valbuf;
@


1.9
log
@Multi-arch REGISTER_SIM_REGNO. Update d10v.
@
text
@d1606 1
@


1.8
log
@Protoization.
@
text
@a57 1
    int (*register_sim_regno) (int nr);
a275 6
int
d10v_register_sim_regno (int nr)
{
  return gdbarch_tdep (current_gdbarch)->register_sim_regno (nr);
}

d1463 1
d1480 1
a1482 1
      tdep->register_sim_regno = d10v_ts2_register_sim_regno;
d1490 1
a1492 1
      tdep->register_sim_regno = d10v_ts3_register_sim_regno;
d1604 2
@


1.7
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d124 1
a124 3
d10v_use_struct_convention (gcc_p, type)
     int gcc_p;
     struct type *type;
d131 1
a131 3
d10v_breakpoint_from_pc (pcptr, lenptr)
     CORE_ADDR *pcptr;
     int *lenptr;
d287 1
a287 2
d10v_register_byte (reg_nr)
     int reg_nr;
d304 1
a304 2
d10v_register_raw_size (reg_nr)
     int reg_nr;
d318 1
a318 2
d10v_register_virtual_size (reg_nr)
     int reg_nr;
d327 1
a327 2
d10v_register_virtual_type (reg_nr)
     int reg_nr;
d341 1
a341 2
d10v_register_convertible (nr)
     int nr;
d347 2
a348 5
d10v_register_convert_to_virtual (regnum, type, from, to)
     int regnum;
     struct type *type;
     char *from;
     char *to;
d359 2
a360 5
d10v_register_convert_to_raw (type, regnum, from, to)
     struct type *type;
     int regnum;
     char *from;
     char *to;
d371 1
a371 2
d10v_make_daddr (x)
     CORE_ADDR x;
d377 1
a377 2
d10v_make_iaddr (x)
     CORE_ADDR x;
d383 1
a383 2
d10v_daddr_p (x)
     CORE_ADDR x;
d389 1
a389 2
d10v_iaddr_p (x)
     CORE_ADDR x;
d396 1
a396 2
d10v_convert_iaddr_to_raw (x)
     CORE_ADDR x;
d402 1
a402 2
d10v_convert_daddr_to_raw (x)
     CORE_ADDR x;
d414 1
a414 3
d10v_store_struct_return (addr, sp)
     CORE_ADDR addr;
     CORE_ADDR sp;
d425 1
a425 3
d10v_store_return_value (type, valbuf)
     struct type *type;
     char *valbuf;
d437 1
a437 2
d10v_extract_struct_value_address (regbuf)
     char *regbuf;
d445 1
a445 2
d10v_frame_saved_pc (frame)
     struct frame_info *frame;
d451 1
a451 2
d10v_frame_args_address (fi)
     struct frame_info *fi;
d457 1
a457 2
d10v_frame_locals_address (fi)
     struct frame_info *fi;
d467 1
a467 2
d10v_saved_pc_after_call (frame)
     struct frame_info *frame;
d477 1
a477 1
d10v_pop_frame ()
d483 1
a483 2
do_d10v_pop_frame (fi)
     struct frame_info *fi;
d522 1
a522 2
check_prologue (op)
     unsigned short op;
d556 1
a556 2
d10v_skip_prologue (pc)
     CORE_ADDR pc;
d624 1
a624 2
d10v_frame_chain (fi)
     struct frame_info *fi;
d652 1
a652 4
prologue_find_regs (op, fi, addr)
     unsigned short op;
     struct frame_info *fi;
     CORE_ADDR addr;
d723 1
a723 2
d10v_frame_init_saved_regs (fi)
     struct frame_info *fi;
d824 1
a824 3
d10v_init_extra_frame_info (fromleaf, fi)
     int fromleaf;
     struct frame_info *fi;
d847 1
a847 3
show_regs (args, from_tty)
     char *args;
     int from_tty;
d907 1
a907 2
d10v_read_pc (pid)
     int pid;
d922 1
a922 3
d10v_write_pc (val, pid)
     CORE_ADDR val;
     int pid;
d933 1
a933 1
d10v_read_sp ()
d939 1
a939 2
d10v_write_sp (val)
     CORE_ADDR val;
d945 1
a945 2
d10v_write_fp (val)
     CORE_ADDR val;
d951 1
a951 1
d10v_read_fp ()
d961 1
a961 3
d10v_push_return_address (pc, sp)
     CORE_ADDR pc;
     CORE_ADDR sp;
d981 1
a981 4
push_stack_item (prev, contents, len)
     struct stack_item *prev;
     void *contents;
     int len;
d994 1
a994 2
pop_stack_item (si)
     struct stack_item *si;
d1005 2
a1006 6
d10v_push_arguments (nargs, args, sp, struct_return, struct_addr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     int struct_return;
     CORE_ADDR struct_addr;
d1231 1
a1231 3
trace_command (args, from_tty)
     char *args;
     int from_tty;
d1246 1
a1246 3
untrace_command (args, from_tty)
     char *args;
     int from_tty;
d1254 1
a1254 3
trace_info (args, from_tty)
     char *args;
     int from_tty;
d1281 1
a1281 3
print_insn (memaddr, stream)
     CORE_ADDR memaddr;
     struct ui_file *stream;
d1295 1
a1295 1
d10v_eva_prepare_to_trace ()
d1307 1
a1307 1
d10v_eva_get_trace_data ()
d1367 1
a1367 3
tdisassemble_command (arg, from_tty)
     char *arg;
     int from_tty;
d1402 1
a1402 2
display_trace (low, high)
     int low, high;
d1462 1
a1462 3
d10v_gdbarch_init (info, arches)
     struct gdbarch_info info;
     struct gdbarch_list *arches;
d1619 1
a1619 1
_initialize_d10v_tdep ()
@


1.6
log
@Multiarch TARGET_FLOAT_FORMAT, TARGET_DOUBLE_FORMAT,
TARGET_LONG_DOUBLE_FORMAT.  Update d10v.
@
text
@d1685 2
a1686 2
extern void (*target_resume_hook) PARAMS ((void));
extern void (*target_wait_loop_hook) PARAMS ((void));
@


1.5
log
@PARAMS removal.
@
text
@d39 1
d1600 2
d1605 15
@


1.4
log
@Include "arch-utils.h".
@
text
@d88 1
a88 1
extern void _initialize_d10v_tdep PARAMS ((void));
d90 1
a90 1
static void d10v_eva_prepare_to_trace PARAMS ((void));
d92 1
a92 1
static void d10v_eva_get_trace_data PARAMS ((void));
d94 2
a95 1
static int prologue_find_regs PARAMS ((unsigned short op, struct frame_info * fi, CORE_ADDR addr));
d97 1
a97 1
extern void d10v_frame_init_saved_regs PARAMS ((struct frame_info *));
d99 1
a99 1
static void do_d10v_pop_frame PARAMS ((struct frame_info * fi));
d1026 2
a1027 1
static struct stack_item *push_stack_item PARAMS ((struct stack_item * prev, void *contents, int len));
d1043 1
a1043 1
static struct stack_item *pop_stack_item PARAMS ((struct stack_item * si));
d1252 1
a1252 1
static void trace_command PARAMS ((char *, int));
d1254 1
a1254 1
static void untrace_command PARAMS ((char *, int));
d1256 1
a1256 1
static void trace_info PARAMS ((char *, int));
d1258 1
a1258 1
static void tdisassemble_command PARAMS ((char *, int));
d1260 1
a1260 1
static void display_trace PARAMS ((int, int));
@


1.3
log
@* d10v-tdep.c (d10v_gdbarch_init): Initialize stack_align.
(d10v_stack_align): Make static.
* config/d10v/tm-d10v.h (STACK_ALIGN): Delete.
@
text
@d37 1
@


1.2
log
@Stop GDB mis-aligning the stack when doing inferior function calls.
@
text
@d107 1
a107 1
CORE_ADDR
d1658 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997 Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d33 1
a33 1
#include "dis-asm.h"  
d36 1
d38 60
a97 2
void d10v_frame_find_saved_regs PARAMS ((struct frame_info *fi,
					 struct frame_saved_regs *fsr));
d102 1
a102 1
     struct frame_info *frame;      /* not used here */
d107 5
d129 371
d504 8
a511 2
d10v_pop_frame (frame)
     struct frame_info *frame;
a514 1
  struct frame_saved_regs fsr;
d517 1
a517 1
  fp = FRAME_FP (frame);
d520 2
a521 2
  get_frame_saved_regs (frame, &fsr);
  
d523 1
a523 1
  for (regnum = A0_REGNUM; regnum < A0_REGNUM+2 ; regnum++)
d525 1
a525 1
      if (fsr.regs[regnum])
d527 2
a528 2
	  read_memory (fsr.regs[regnum], raw_buffer,  REGISTER_RAW_SIZE(regnum));
	  write_register_bytes (REGISTER_BYTE (regnum), raw_buffer,  REGISTER_RAW_SIZE(regnum));
d533 1
a533 1
      if (fsr.regs[regnum])
d535 1
a535 1
	  write_register (regnum, read_memory_unsigned_integer (fsr.regs[regnum], REGISTER_RAW_SIZE(regnum)));
d538 1
a538 1
  if (fsr.regs[PSW_REGNUM])
d540 1
a540 1
      write_register (PSW_REGNUM, read_memory_unsigned_integer (fsr.regs[PSW_REGNUM], REGISTER_RAW_SIZE(PSW_REGNUM)));
d544 1
a544 1
  write_register (SP_REGNUM, fp + frame->size);
d549 1
a549 1
static int 
d578 2
a579 2
 if ((op & 0x7E3F) == 0x3A1E)
   return 1;
d598 1
a598 1
      if ( sal.end && sal.end < func_end)
d601 2
a602 2
  
  if (target_read_memory (pc, (char *)&op, 4))
d607 1
a607 1
      op = (unsigned long)read_memory_integer (pc, 4);
d611 3
a613 3
	  if ( ((op & 0x3FFF0000) != 0x01FF0000) &&   /* add3 sp,sp,n */
	       ((op & 0x3F0F0000) != 0x340F0000) &&   /* st  rn, @@(offset,sp) */
 	       ((op & 0x3F1F0000) != 0x350F0000))     /* st2w  rn, @@(offset,sp) */
d623 2
a624 2
	    } 
	  else 
d629 1
a629 1
	  if (check_prologue(op1))
d631 1
a631 1
	      if (!check_prologue(op2))
d651 1
a651 1
*/
d654 2
a655 2
d10v_frame_chain (frame)
     struct frame_info *frame;
d657 1
a657 1
  struct frame_saved_regs fsr;
d659 3
a661 1
  d10v_frame_find_saved_regs (frame, &fsr);
d663 5
a667 2
  if (frame->return_pc == IMEM_START || inside_entry_file(frame->return_pc))
    return (CORE_ADDR)0;
d669 1
a669 6
  if (!fsr.regs[FP_REGNUM])
    {
      if (!fsr.regs[SP_REGNUM] || fsr.regs[SP_REGNUM] == STACK_START)
	return (CORE_ADDR)0;
      
      return fsr.regs[SP_REGNUM];
d672 3
a674 2
  if (!read_memory_unsigned_integer(fsr.regs[FP_REGNUM], REGISTER_RAW_SIZE(FP_REGNUM)))
    return (CORE_ADDR)0;
d676 3
a678 2
  return D10V_MAKE_DADDR (read_memory_unsigned_integer (fsr.regs[FP_REGNUM], REGISTER_RAW_SIZE (FP_REGNUM)));
}  
d682 2
a683 2
static int 
prologue_find_regs (op, fsr, addr)
d685 1
a685 1
     struct frame_saved_regs *fsr;
d695 1
a695 1
      fsr->regs[n] = next_addr;
d704 2
a705 2
      fsr->regs[n] = next_addr;
      fsr->regs[n+1] = next_addr+2;
d734 1
a734 1
      fsr->regs[n] = next_addr;
d742 2
a743 2
      fsr->regs[n] = next_addr;
      fsr->regs[n+1] = next_addr+2;
d750 6
a755 5
/* Put here the code to store, into a struct frame_saved_regs, the
   addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special: the address we
   return for it IS the sp for the next frame. */
d757 1
a757 1
d10v_frame_find_saved_regs (fi, fsr)
a758 1
     struct frame_saved_regs *fsr;
d766 1
a766 1
  memset (fsr, 0, sizeof (*fsr));
d774 1
a774 1
      op = (unsigned long)read_memory_integer (pc, 4);
d789 1
a789 1
	      fsr->regs[n] = next_addr + offset;
d796 2
a797 2
	      fsr->regs[n] = next_addr + offset;
	      fsr->regs[n+1] = next_addr + offset + 2;
d809 2
a810 2
	    } 
	  else 
d815 1
a815 1
	  if (!prologue_find_regs(op1,fsr,pc) || !prologue_find_regs(op2,fsr,pc))
d820 2
a821 2
  
  fi->size = -next_addr;
d824 1
a824 1
    fp = D10V_MAKE_DADDR (read_register(SP_REGNUM));
d826 2
a827 2
  for (i=0; i<NUM_REGS-1; i++)
    if (fsr->regs[i])
d829 1
a829 1
	fsr->regs[i] = fp - (next_addr - fsr->regs[i]); 
d832 1
a832 1
  if (fsr->regs[LR_REGNUM])
d834 2
a835 2
      CORE_ADDR return_pc = read_memory_unsigned_integer (fsr->regs[LR_REGNUM], REGISTER_RAW_SIZE (LR_REGNUM));
      fi->return_pc = D10V_MAKE_IADDR (return_pc);
d839 1
a839 1
      fi->return_pc = D10V_MAKE_IADDR (read_register(LR_REGNUM));
d841 1
a841 1
  
d843 1
a843 1
  if (!fsr->regs[SP_REGNUM])
d848 1
a848 1
	fsr->regs[SP_REGNUM] = read_register(FP_REGNUM) + fi->size;
d851 3
a853 3
	  fsr->regs[SP_REGNUM] = fp + fi->size;
	  fi->frameless = 1;
	  fsr->regs[FP_REGNUM] = 0;
d863 7
a869 3
  fi->frameless = 0;
  fi->size = 0;
  fi->return_pc = 0;
d879 1
a879 2
      struct frame_saved_regs dummy;
      d10v_frame_find_saved_regs (fi, &dummy);
d889 43
a931 30
  printf_filtered ("PC=%04x (0x%x) PSW=%04x RPT_S=%04x RPT_E=%04x RPT_C=%04x\n",
                   read_register (PC_REGNUM), D10V_MAKE_IADDR (read_register (PC_REGNUM)),
                   read_register (PSW_REGNUM),
                   read_register (24),
                   read_register (25),
                   read_register (23));
  printf_filtered ("R0-R7  %04x %04x %04x %04x %04x %04x %04x %04x\n",
                   read_register (0),
                   read_register (1),
                   read_register (2),
                   read_register (3),
                   read_register (4),
                   read_register (5),
                   read_register (6),
                   read_register (7));
  printf_filtered ("R8-R15 %04x %04x %04x %04x %04x %04x %04x %04x\n",
                   read_register (8), 
                   read_register (9),
                   read_register (10),
                   read_register (11),
                   read_register (12),
                   read_register (13),
                   read_register (14),
                   read_register (15));
  printf_filtered ("IMAP0 %04x    IMAP1 %04x    DMAP %04x\n",
                   read_register (IMAP0_REGNUM),
                   read_register (IMAP1_REGNUM),
                   read_register (DMAP_REGNUM));
  printf_filtered ("A0-A1");
  for (a = A0_REGNUM; a <= A0_REGNUM + 1; a++)
d936 1
a936 1
      read_register_gen (a, (char *)&num);
d997 1
a997 1
  return (D10V_MAKE_DADDR (read_register(FP_REGNUM)));
d1003 1
a1003 1
 
d1012 40
a1051 1
 
d1063 2
a1064 1
  
d1100 3
a1102 3
	      sp -= 2;
	      store_address (ptr, val & 0xffff, 2);
	      write_memory (sp, ptr, 2);
d1116 1
a1116 1
               aligned */
d1133 1
a1133 1
	      /* arg goes straight on stack */
d1135 1
a1135 2
	      sp = (sp - len) & ~1;
	      write_memory (sp, contents, len);
d1139 8
d1170 1
a1170 1
      store_address ( valbuf, 4, D10V_MAKE_IADDR(snum));
d1172 1
a1172 1
  else if (TYPE_CODE(type) == TYPE_CODE_PTR)
d1178 1
a1178 1
      store_address ( valbuf, 4, D10V_MAKE_DADDR(snum));
d1193 4
a1196 4
             least significant part of the first register.  The
             remaining bytes in remaining registers. Interestingly,
             when such values are passed in, the last byte is in the
             most significant byte of that same register - wierd. */
d1202 21
d1275 7
a1281 5
struct trace_buffer {
  int size;
  short *counts;
  CORE_ADDR *addrs;
} trace_data;
d1291 1
a1291 1
    trace_data.counts = (short *) xmalloc (65536 * sizeof(short));
d1293 1
a1293 1
    trace_data.addrs = (CORE_ADDR *) xmalloc (65536 * sizeof(CORE_ADDR));
d1323 3
a1325 2
	  printf_filtered ("%d: %d instruction%s at 0x%x\n",
			   i, trace_data.counts[i],
d1327 1
a1327 1
			   trace_data.addrs[i]);
d1342 1
a1342 1
     GDB_FILE *stream;
d1346 1
a1346 1
    abort ();
d1355 1
a1355 1
void
d1367 1
a1367 1
void
d1378 1
a1378 1
  tmpspace = xmalloc (65536 * sizeof(unsigned int));
d1456 1
a1456 1
  printf_filtered ("Dump of trace from %d to %d:\n", low, high);
d1472 1
a1472 1
  if (!have_full_symbols () && !have_partial_symbols())
d1484 1
a1484 1
      count = trace_data.counts[i]; 
d1506 1
a1506 1
				     local_hex_string((unsigned long) sal.pc));
d1522 141
d1669 2
d1678 1
a1678 1
  add_com ("trace", class_support, trace_command,
d1681 1
a1681 1
  add_com ("untrace", class_support, untrace_command,
d1684 1
a1684 1
  add_com ("tdisassemble", class_vars, tdisassemble_command,
d1689 1
a1689 1
  add_info ("trace", trace_info,
d1692 3
a1694 3
  add_show_from_set (add_set_cmd ("tracedisplay", no_class,
				  var_integer, (char *)&trace_display,
				  "Set automatic display of trace.\n", &setlist),
d1696 3
a1698 3
  add_show_from_set (add_set_cmd ("tracesource", no_class,
				  var_integer, (char *)&default_trace_show_source,
				  "Set display of source code with trace.\n", &setlist),
d1701 1
a1701 1
} 
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a554 39
/* When arguments must be pushed onto the stack, they go on in reverse
   order.  The below implements a FILO (stack) to do this. */

struct stack_item
{
  int len;
  struct stack_item *prev;
  void *data;
};

static struct stack_item *push_stack_item PARAMS ((struct stack_item *prev, void *contents, int len));
static struct stack_item *
push_stack_item (prev, contents, len)
     struct stack_item *prev;
     void *contents;
     int len;
{
  struct stack_item *si;
  si = xmalloc (sizeof (struct stack_item));
  si->data = xmalloc (len);
  si->len = len;
  si->prev = prev;
  memcpy (si->data, contents, len);
  return si;
}

static struct stack_item *pop_stack_item PARAMS ((struct stack_item *si));
static struct stack_item *
pop_stack_item (si)
     struct stack_item *si;
{
  struct stack_item *dead = si;
  si = si->prev;
  free (dead->data);
  free (dead);
  return si;
}


a564 1
  struct stack_item *si = NULL;
d601 1
a601 1
	      /* arg will go onto stack */
d603 1
a603 1
	      si = push_stack_item (si, ptr, 2);
d634 4
a637 3
	      /* arg will go onto stack */
	      regnum = ARGN_REGNUM + 1; 
	      si = push_stack_item (si, contents, len);
a640 8

  while (si)
    {
      sp = (sp - si->len) & ~1;
      write_memory (sp, si->data, si->len);
      si = pop_stack_item (si);
    }
  
@


1.1.1.3
log
@import gdb-1999-05-25 snapshot
@
text
@d36 2
a37 7
/* Local functions */

extern void _initialize_d10v_tdep PARAMS ((void));

static void d10v_eva_prepare_to_trace PARAMS ((void));

static void d10v_eva_get_trace_data PARAMS ((void));
a63 222
unsigned char *
d10v_breakpoint_from_pc (pcptr, lenptr)
     CORE_ADDR *pcptr;
     int *lenptr;
{
  static unsigned char breakpoint [] = {0x2f, 0x90, 0x5e, 0x00};
  *lenptr = sizeof (breakpoint);
  return breakpoint;
}

char *
d10v_register_name (reg_nr)
     int reg_nr;
{
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5",  "r6", "r7",
    "r8", "r9", "r10","r11","r12", "r13", "r14","r15",
    "psw","bpsw","pc","bpc", "cr4", "cr5", "cr6", "rpt_c",
    "rpt_s","rpt_e", "mod_s", "mod_e", "cr12", "cr13", "iba", "cr15",
    "imap0","imap1","dmap","a0", "a1"
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names [reg_nr];
}


/* Index within `registers' of the first byte of the space for
   register REG_NR.  */

int
d10v_register_byte (reg_nr)
     int reg_nr;
{
  if (reg_nr > A0_REGNUM)
    return ((reg_nr - A0_REGNUM) * 8 + (A0_REGNUM * 2));
  else
    return (reg_nr * 2);
}

/* Number of bytes of storage in the actual machine representation for
   register REG_NR.  */

int
d10v_register_raw_size (reg_nr)
     int reg_nr;
{
  if (reg_nr >= A0_REGNUM)
    return 8;
  else
    return 2;
}

/* Number of bytes of storage in the program's representation
   for register N.  */

int
d10v_register_virtual_size (reg_nr)
     int reg_nr;
{
  if (reg_nr >= A0_REGNUM)
    return 8;
  else if (reg_nr == PC_REGNUM || reg_nr == SP_REGNUM)
    return 4;
  else
    return 2;
}

/* Return the GDB type object for the "standard" data type
   of data in register N.  */

struct type *
d10v_register_virtual_type (reg_nr)
     int reg_nr;
{
  if (reg_nr >= A0_REGNUM)
    return builtin_type_long_long;
  else if (reg_nr == PC_REGNUM || reg_nr == SP_REGNUM)
    return builtin_type_long;
  else
    return builtin_type_short;
}

#if 0
/* convert $pc and $sp to/from virtual addresses */
#define REGISTER_CONVERTIBLE(N) ((N) == PC_REGNUM || (N) == SP_REGNUM)
#define REGISTER_CONVERT_TO_VIRTUAL(REGNUM,TYPE,FROM,TO) \
{ \
    ULONGEST x = extract_unsigned_integer ((FROM), REGISTER_RAW_SIZE (REGNUM)); \
    if (REGNUM == PC_REGNUM) x = (x << 2) | IMEM_START; \
    else x |= DMEM_START; \
    store_unsigned_integer ((TO), TYPE_LENGTH(TYPE), x); \
}
#define REGISTER_CONVERT_TO_RAW(TYPE,REGNUM,FROM,TO) \
{ \
    ULONGEST x = extract_unsigned_integer ((FROM), TYPE_LENGTH(TYPE)); \
    x &= 0x3ffff; \
    if (REGNUM == PC_REGNUM) x >>= 2; \
    store_unsigned_integer ((TO), 2, x); \
}
#endif

CORE_ADDR
d10v_make_daddr (x)
     CORE_ADDR x;
{
  return ((x) | DMEM_START);
}

CORE_ADDR
d10v_make_iaddr (x)
     CORE_ADDR x;
{
  return (((x) << 2) | IMEM_START);
}

int
d10v_daddr_p (x)
     CORE_ADDR x;
{
  return (((x) & 0x3000000) == DMEM_START);
}

int
d10v_iaddr_p (x)
     CORE_ADDR x;
{
  return (((x) & 0x3000000) == IMEM_START);
}


CORE_ADDR
d10v_convert_iaddr_to_raw (x)
     CORE_ADDR x;
{
  return (((x) >> 2) & 0xffff);
}

CORE_ADDR
d10v_convert_daddr_to_raw(x)
     CORE_ADDR x;
{
  return ((x) & 0xffff);
}

/* Store the address of the place in which to copy the structure the
   subroutine will return.  This is called from call_function. 

   We store structs through a pointer passed in the first Argument
   register. */

void
d10v_store_struct_return (addr, sp)
     CORE_ADDR addr;
     CORE_ADDR sp;
{
  write_register (ARG1_REGNUM, (addr));
}

/* Write into appropriate registers a function return value
   of type TYPE, given in virtual format.  

   Things always get returned in RET1_REGNUM, RET2_REGNUM, ... */

void
d10v_store_return_value (type,valbuf)
     struct type *type;
     char *valbuf;
{
  write_register_bytes (REGISTER_BYTE (RET1_REGNUM),
			valbuf,
			TYPE_LENGTH (type));
}

/* Extract from an array REGBUF containing the (raw) register state
   the address in which a function should return its structure value,
   as a CORE_ADDR (or an expression that can be used as one).  */

CORE_ADDR
d10v_extract_struct_value_address (regbuf)
     char *regbuf;
{
  return (extract_address ((regbuf) + REGISTER_BYTE (ARG1_REGNUM),
			   REGISTER_RAW_SIZE (ARG1_REGNUM))
	  | DMEM_START);
}

CORE_ADDR
d10v_frame_saved_pc (frame)
     struct frame_info *frame;
{
  return ((frame)->return_pc);
}

CORE_ADDR
d10v_frame_args_address (fi)
     struct frame_info *fi;
{
  return (fi)->frame;
}

CORE_ADDR
d10v_frame_locals_address (fi)
     struct frame_info *fi;
{
  return (fi)->frame;
}

/* Immediately after a function call, return the saved pc.  We can't
   use frame->return_pc beause that is determined by reading R13 off
   the stack and that may not be written yet. */

CORE_ADDR
d10v_saved_pc_after_call (frame)
     struct frame_info *frame;
{
  return ((read_register(LR_REGNUM) << 2)
	  | IMEM_START);
}

d872 1
a872 1
static void
d884 1
a884 1
static void
@


1.1.1.4
log
@import gdb-1999-06-01 snapshot
@
text
@d154 1
d156 14
a169 20
int
d10v_register_convertible (nr)
     int nr;
{
  return ((nr) == PC_REGNUM || (nr) == SP_REGNUM);
}

void
d10v_register_convert_to_virtual (regnum, type, from, to)
     int regnum;
     struct type *type;
     char *from;
     char *to;
{
  ULONGEST x = extract_unsigned_integer (from, REGISTER_RAW_SIZE (regnum));
  if (regnum == PC_REGNUM)
    x = (x << 2) | IMEM_START;
  else
    x |= DMEM_START;
  store_unsigned_integer (to, TYPE_LENGTH (type), x);
d171 1
a171 15

void
d10v_register_convert_to_raw (type, regnum, from, to)
     struct type *type;
     int regnum;
     char *from;
     char *to;
{
  ULONGEST x = extract_unsigned_integer (from, TYPE_LENGTH (type));
  x &= 0x3ffff;
  if (regnum == PC_REGNUM)
    x >>= 2;
  store_unsigned_integer (to, 2, x);
}

a1264 1

@


1.1.1.5
log
@import gdb-1999-06-07 snapshot
@
text
@a35 20
struct frame_extra_info
{
  CORE_ADDR return_pc;
  int frameless;
  int size;
};

/* these are the addresses the D10V-EVA board maps data */
/* and instruction memory to. */

#define DMEM_START	0x0000000
#define IMEM_START	0x1000000
#define STACK_START	0x0007ffe

/* d10v register naming conventions */

#define ARG1_REGNUM R0_REGNUM
#define ARGN_REGNUM 3
#define RET1_REGNUM R0_REGNUM

a43 9
static int prologue_find_regs PARAMS ((unsigned short op, struct frame_info *fi, CORE_ADDR addr));

extern void d10v_frame_init_saved_regs PARAMS ((struct frame_info *));

static void do_d10v_pop_frame PARAMS ((struct frame_info *fi));

/* FIXME */
extern void remote_d10v_translate_xfer_address PARAMS ((CORE_ADDR gdb_addr, int gdb_len, CORE_ADDR *rem_addr, int *rem_len));

d281 1
a281 1
  return ((frame)->extra_info->return_pc);
d314 2
a315 8
d10v_pop_frame ()
{
  generic_pop_current_frame (do_d10v_pop_frame);
}

static void
do_d10v_pop_frame (fi)
     struct frame_info *fi;
d319 1
d322 1
a322 1
  fp = FRAME_FP (fi);
d325 1
a325 1
  d10v_frame_init_saved_regs (fi);
d330 1
a330 1
      if (fi->saved_regs[regnum])
d332 1
a332 1
	  read_memory (fi->saved_regs[regnum], raw_buffer,  REGISTER_RAW_SIZE(regnum));
d338 1
a338 1
      if (fi->saved_regs[regnum])
d340 1
a340 1
	  write_register (regnum, read_memory_unsigned_integer (fi->saved_regs[regnum], REGISTER_RAW_SIZE(regnum)));
d343 1
a343 1
  if (fi->saved_regs[PSW_REGNUM])
d345 1
a345 1
      write_register (PSW_REGNUM, read_memory_unsigned_integer (fi->saved_regs[PSW_REGNUM], REGISTER_RAW_SIZE(PSW_REGNUM)));
d349 1
a349 1
  write_register (SP_REGNUM, fp + fi->extra_info->size);
d459 2
a460 2
d10v_frame_chain (fi)
     struct frame_info *fi;
d462 3
a464 1
  d10v_frame_init_saved_regs (fi);
d466 1
a466 2
  if (fi->extra_info->return_pc == IMEM_START
      || inside_entry_file (fi->extra_info->return_pc))
d469 1
a469 1
  if (!fi->saved_regs[FP_REGNUM])
d471 1
a471 2
      if (!fi->saved_regs[SP_REGNUM]
	  || fi->saved_regs[SP_REGNUM] == STACK_START)
d474 1
a474 1
      return fi->saved_regs[SP_REGNUM];
d477 1
a477 2
  if (!read_memory_unsigned_integer(fi->saved_regs[FP_REGNUM],
				    REGISTER_RAW_SIZE(FP_REGNUM)))
d480 1
a480 2
  return D10V_MAKE_DADDR (read_memory_unsigned_integer (fi->saved_regs[FP_REGNUM],
							REGISTER_RAW_SIZE (FP_REGNUM)));
d486 1
a486 1
prologue_find_regs (op, fi, addr)
d488 1
a488 1
     struct frame_info *fi;
d498 1
a498 1
      fi->saved_regs[n] = next_addr;
d507 2
a508 2
      fi->saved_regs[n] = next_addr;
      fi->saved_regs[n+1] = next_addr+2;
d537 1
a537 1
      fi->saved_regs[n] = next_addr;
d545 2
a546 2
      fi->saved_regs[n] = next_addr;
      fi->saved_regs[n+1] = next_addr+2;
d553 5
a557 6
/* Put here the code to store, into fi->saved_regs, the addresses of
   the saved registers of frame described by FRAME_INFO.  This
   includes special registers such as pc and fp saved in special ways
   in the stack frame.  sp is even more special: the address we return
   for it IS the sp for the next frame. */

d559 1
a559 1
d10v_frame_init_saved_regs (fi)
d561 1
d569 1
a569 1
  memset (fi->saved_regs, 0, SIZEOF_FRAME_SAVED_REGS);
d592 1
a592 1
	      fi->saved_regs[n] = next_addr + offset;
d599 2
a600 2
	      fi->saved_regs[n] = next_addr + offset;
	      fi->saved_regs[n+1] = next_addr + offset + 2;
d618 1
a618 1
	  if (!prologue_find_regs(op1, fi, pc) || !prologue_find_regs(op2, fi, pc))
d624 1
a624 1
  fi->extra_info->size = -next_addr;
d630 1
a630 1
    if (fi->saved_regs[i])
d632 1
a632 1
	fi->saved_regs[i] = fp - (next_addr - fi->saved_regs[i]); 
d635 1
a635 1
  if (fi->saved_regs[LR_REGNUM])
d637 2
a638 2
      CORE_ADDR return_pc = read_memory_unsigned_integer (fi->saved_regs[LR_REGNUM], REGISTER_RAW_SIZE (LR_REGNUM));
      fi->extra_info->return_pc = D10V_MAKE_IADDR (return_pc);
d642 1
a642 1
      fi->extra_info->return_pc = D10V_MAKE_IADDR (read_register(LR_REGNUM));
d646 1
a646 1
  if (!fi->saved_regs[SP_REGNUM])
d651 1
a651 1
	fi->saved_regs[SP_REGNUM] = read_register(FP_REGNUM) + fi->extra_info->size;
d654 3
a656 3
	  fi->saved_regs[SP_REGNUM] = fp + fi->extra_info->size;
	  fi->extra_info->frameless = 1;
	  fi->saved_regs[FP_REGNUM] = 0;
d666 3
a668 7
  fi->extra_info = (struct frame_extra_info *)
    frame_obstack_alloc (sizeof (struct frame_extra_info));
  frame_saved_regs_zalloc (fi);

  fi->extra_info->frameless = 0;
  fi->extra_info->size = 0;
  fi->extra_info->return_pc = 0;
d678 2
a679 1
      d10v_frame_init_saved_regs (fi);
@


1.1.1.6
log
@import gdb-1999-06-14 snapshot
@
text
@d927 1
a927 1
	      store_address (ptr, 2, val & 0xffff);
a1324 108
static gdbarch_init_ftype d10v_gdbarch_init;
static struct gdbarch *
d10v_gdbarch_init (info, arches)
     struct gdbarch_info info;
     struct gdbarch_list *arches;
{
  static LONGEST d10v_call_dummy_words[] = { 0 };
  struct gdbarch *gdbarch;
  int d10v_num_regs = 37;

  /* there is only one d10v architecture */
  if (arches != NULL)
    return arches->gdbarch;
  gdbarch = gdbarch_alloc (&info, NULL);

  set_gdbarch_read_pc (gdbarch, d10v_read_pc);
  set_gdbarch_write_pc (gdbarch, d10v_write_pc);
  set_gdbarch_read_fp (gdbarch, d10v_read_fp);
  set_gdbarch_write_fp (gdbarch, d10v_write_fp);
  set_gdbarch_read_sp (gdbarch, d10v_read_sp);
  set_gdbarch_write_sp (gdbarch, d10v_write_sp);

  set_gdbarch_num_regs (gdbarch, d10v_num_regs);
  set_gdbarch_sp_regnum (gdbarch, 15);
  set_gdbarch_fp_regnum (gdbarch, 11);
  set_gdbarch_pc_regnum (gdbarch, 18);
  set_gdbarch_register_name (gdbarch, d10v_register_name);
  set_gdbarch_register_size (gdbarch, 2);
  set_gdbarch_register_bytes (gdbarch, (d10v_num_regs - 2) * 2 + 16);
  set_gdbarch_register_byte (gdbarch, d10v_register_byte);
  set_gdbarch_register_raw_size (gdbarch, d10v_register_raw_size);
  set_gdbarch_max_register_raw_size (gdbarch, 8);
  set_gdbarch_register_virtual_size (gdbarch, d10v_register_virtual_size);
  set_gdbarch_max_register_virtual_size (gdbarch, 8);
  set_gdbarch_register_virtual_type (gdbarch, d10v_register_virtual_type);

  set_gdbarch_ptr_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_short_bit (gdbarch, 2 * TARGET_CHAR_BIT);
  set_gdbarch_int_bit (gdbarch, 2 * TARGET_CHAR_BIT);
  set_gdbarch_long_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_long_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_float_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_double_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);

  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);
  set_gdbarch_call_dummy_length (gdbarch, 0);
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
  set_gdbarch_call_dummy_address (gdbarch, entry_point_address);
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
  set_gdbarch_pc_in_call_dummy (gdbarch, generic_pc_in_call_dummy);
  set_gdbarch_call_dummy_words (gdbarch, d10v_call_dummy_words);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, sizeof (d10v_call_dummy_words));
  set_gdbarch_call_dummy_p (gdbarch, 1);
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
  set_gdbarch_get_saved_register (gdbarch, generic_get_saved_register);
  set_gdbarch_fix_call_dummy (gdbarch, generic_fix_call_dummy);

  set_gdbarch_register_convertible (gdbarch, d10v_register_convertible);
  set_gdbarch_register_convert_to_virtual (gdbarch, d10v_register_convert_to_virtual);
  set_gdbarch_register_convert_to_raw (gdbarch, d10v_register_convert_to_raw);

  set_gdbarch_extract_return_value (gdbarch, d10v_extract_return_value);
  set_gdbarch_push_arguments (gdbarch, d10v_push_arguments);
  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);
  set_gdbarch_push_return_address (gdbarch, d10v_push_return_address);

  set_gdbarch_d10v_make_daddr (gdbarch, d10v_make_daddr);
  set_gdbarch_d10v_make_iaddr (gdbarch, d10v_make_iaddr);
  set_gdbarch_d10v_daddr_p (gdbarch, d10v_daddr_p);
  set_gdbarch_d10v_iaddr_p (gdbarch, d10v_iaddr_p);
  set_gdbarch_d10v_convert_daddr_to_raw (gdbarch, d10v_convert_daddr_to_raw);
  set_gdbarch_d10v_convert_iaddr_to_raw (gdbarch, d10v_convert_iaddr_to_raw);

  set_gdbarch_store_struct_return (gdbarch, d10v_store_struct_return);
  set_gdbarch_store_return_value (gdbarch, d10v_store_return_value);
  set_gdbarch_extract_struct_value_address (gdbarch, d10v_extract_struct_value_address);
  set_gdbarch_use_struct_convention (gdbarch, d10v_use_struct_convention);

  set_gdbarch_frame_init_saved_regs (gdbarch, d10v_frame_init_saved_regs);
  set_gdbarch_init_extra_frame_info (gdbarch, d10v_init_extra_frame_info);

  set_gdbarch_pop_frame (gdbarch, d10v_pop_frame);

  set_gdbarch_skip_prologue (gdbarch, d10v_skip_prologue);
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_decr_pc_after_break (gdbarch, 4);
  set_gdbarch_function_start_offset (gdbarch, 0);
  set_gdbarch_breakpoint_from_pc (gdbarch, d10v_breakpoint_from_pc);

  set_gdbarch_remote_translate_xfer_address (gdbarch, remote_d10v_translate_xfer_address);

  set_gdbarch_frame_args_skip (gdbarch, 0);
  set_gdbarch_frameless_function_invocation (gdbarch, frameless_look_for_prologue);
  set_gdbarch_frame_chain (gdbarch, d10v_frame_chain);
  set_gdbarch_frame_chain_valid (gdbarch, d10v_frame_chain_valid);
  set_gdbarch_frame_saved_pc (gdbarch, d10v_frame_saved_pc);
  set_gdbarch_frame_args_address (gdbarch, d10v_frame_args_address);
  set_gdbarch_frame_locals_address (gdbarch, d10v_frame_locals_address);
  set_gdbarch_saved_pc_after_call (gdbarch, d10v_saved_pc_after_call);
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);

  return gdbarch;
}


a1330 2
  register_gdbarch_init (bfd_arch_d10v, d10v_gdbarch_init);

@


1.1.1.7
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d32 1
a32 1
#include "dis-asm.h"
d37 5
a41 5
  {
    CORE_ADDR return_pc;
    int frameless;
    int size;
  };
d64 1
a64 1
static int prologue_find_regs PARAMS ((unsigned short op, struct frame_info * fi, CORE_ADDR addr));
d68 1
a68 1
static void do_d10v_pop_frame PARAMS ((struct frame_info * fi));
d71 1
a71 1
extern void remote_d10v_translate_xfer_address PARAMS ((CORE_ADDR gdb_addr, int gdb_len, CORE_ADDR * rem_addr, int *rem_len));
d76 1
a76 1
     struct frame_info *frame;	/* not used here */
d103 1
a103 2
  static unsigned char breakpoint[] =
  {0x2f, 0x90, 0x5e, 0x00};
d112 6
a117 7
  static char *register_names[] =
  {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "psw", "bpsw", "pc", "bpc", "cr4", "cr5", "cr6", "rpt_c",
    "rpt_s", "rpt_e", "mod_s", "mod_e", "cr12", "cr13", "iba", "cr15",
    "imap0", "imap1", "dmap", "a0", "a1"
d123 1
a123 1
  return register_names[reg_nr];
d258 1
a258 1
d10v_convert_daddr_to_raw (x)
d284 1
a284 1
d10v_store_return_value (type, valbuf)
d335 1
a335 1
  return ((read_register (LR_REGNUM) << 2)
d360 1
a360 1

d362 1
a362 1
  for (regnum = A0_REGNUM; regnum < A0_REGNUM + 2; regnum++)
d366 2
a367 2
	  read_memory (fi->saved_regs[regnum], raw_buffer, REGISTER_RAW_SIZE (regnum));
	  write_register_bytes (REGISTER_BYTE (regnum), raw_buffer, REGISTER_RAW_SIZE (regnum));
d374 1
a374 1
	  write_register (regnum, read_memory_unsigned_integer (fi->saved_regs[regnum], REGISTER_RAW_SIZE (regnum)));
d379 1
a379 1
      write_register (PSW_REGNUM, read_memory_unsigned_integer (fi->saved_regs[PSW_REGNUM], REGISTER_RAW_SIZE (PSW_REGNUM)));
d388 1
a388 1
static int
d417 2
a418 2
  if ((op & 0x7E3F) == 0x3A1E)
    return 1;
d437 1
a437 1
      if (sal.end && sal.end < func_end)
d440 2
a441 2

  if (target_read_memory (pc, (char *) &op, 4))
d446 1
a446 1
      op = (unsigned long) read_memory_integer (pc, 4);
d450 3
a452 3
	  if (((op & 0x3FFF0000) != 0x01FF0000) &&	/* add3 sp,sp,n */
	      ((op & 0x3F0F0000) != 0x340F0000) &&	/* st  rn, @@(offset,sp) */
	      ((op & 0x3F1F0000) != 0x350F0000))	/* st2w  rn, @@(offset,sp) */
d462 2
a463 2
	    }
	  else
d468 1
a468 1
	  if (check_prologue (op1))
d470 1
a470 1
	      if (!check_prologue (op2))
d490 1
a490 1
 */
d500 1
a500 1
    return (CORE_ADDR) 0;
d506 2
a507 2
	return (CORE_ADDR) 0;

d511 3
a513 3
  if (!read_memory_unsigned_integer (fi->saved_regs[FP_REGNUM],
				     REGISTER_RAW_SIZE (FP_REGNUM)))
    return (CORE_ADDR) 0;
d516 2
a517 2
					    REGISTER_RAW_SIZE (FP_REGNUM)));
}
d521 1
a521 1
static int
d544 1
a544 1
      fi->saved_regs[n + 1] = next_addr + 2;
d582 1
a582 1
      fi->saved_regs[n + 1] = next_addr + 2;
d613 1
a613 1
      op = (unsigned long) read_memory_integer (pc, 4);
d636 1
a636 1
	      fi->saved_regs[n + 1] = next_addr + offset + 2;
d648 2
a649 2
	    }
	  else
d654 1
a654 1
	  if (!prologue_find_regs (op1, fi, pc) || !prologue_find_regs (op2, fi, pc))
d659 1
a659 1

d663 1
a663 1
    fp = D10V_MAKE_DADDR (read_register (SP_REGNUM));
d665 1
a665 1
  for (i = 0; i < NUM_REGS - 1; i++)
d668 1
a668 1
	fi->saved_regs[i] = fp - (next_addr - fi->saved_regs[i]);
d678 1
a678 1
      fi->extra_info->return_pc = D10V_MAKE_IADDR (read_register (LR_REGNUM));
d680 1
a680 1

d687 1
a687 1
	fi->saved_regs[SP_REGNUM] = read_register (FP_REGNUM) + fi->extra_info->size;
d729 5
a733 5
     read_register (PC_REGNUM), D10V_MAKE_IADDR (read_register (PC_REGNUM)),
		   read_register (PSW_REGNUM),
		   read_register (24),
		   read_register (25),
		   read_register (23));
d735 8
a742 8
		   read_register (0),
		   read_register (1),
		   read_register (2),
		   read_register (3),
		   read_register (4),
		   read_register (5),
		   read_register (6),
		   read_register (7));
d744 8
a751 8
		   read_register (8),
		   read_register (9),
		   read_register (10),
		   read_register (11),
		   read_register (12),
		   read_register (13),
		   read_register (14),
		   read_register (15));
d753 3
a755 3
		   read_register (IMAP0_REGNUM),
		   read_register (IMAP1_REGNUM),
		   read_register (DMAP_REGNUM));
d762 1
a762 1
      read_register_gen (a, (char *) &num);
d823 1
a823 1
  return (D10V_MAKE_DADDR (read_register (FP_REGNUM)));
d829 1
a829 1

d838 1
a838 1

d850 1
a850 1
static struct stack_item *push_stack_item PARAMS ((struct stack_item * prev, void *contents, int len));
d866 1
a866 1
static struct stack_item *pop_stack_item PARAMS ((struct stack_item * si));
d890 1
a890 1

d942 1
a942 1
	       aligned */
d960 1
a960 1
	      regnum = ARGN_REGNUM + 1;
d972 1
a972 1

d996 1
a996 1
      store_address (valbuf, 4, D10V_MAKE_IADDR (snum));
d998 1
a998 1
  else if (TYPE_CODE (type) == TYPE_CODE_PTR)
d1004 1
a1004 1
      store_address (valbuf, 4, D10V_MAKE_DADDR (snum));
d1019 4
a1022 4
	     least significant part of the first register.  The
	     remaining bytes in remaining registers. Interestingly,
	     when such values are passed in, the last byte is in the
	     most significant byte of that same register - wierd. */
d1080 5
a1084 7
struct trace_buffer
  {
    int size;
    short *counts;
    CORE_ADDR *addrs;
  }
trace_data;
d1094 1
a1094 1
    trace_data.counts = (short *) xmalloc (65536 * sizeof (short));
d1096 1
a1096 1
    trace_data.addrs = (CORE_ADDR *) xmalloc (65536 * sizeof (CORE_ADDR));
d1180 1
a1180 1
  tmpspace = xmalloc (65536 * sizeof (unsigned int));
d1274 1
a1274 1
  if (!have_full_symbols () && !have_partial_symbols ())
d1286 1
a1286 1
      count = trace_data.counts[i];
d1308 1
a1308 1
				 local_hex_string ((unsigned long) sal.pc));
d1331 1
a1331 2
  static LONGEST d10v_call_dummy_words[] =
  {0};
d1463 2
a1464 2
				  var_integer, (char *) &trace_display,
			     "Set automatic display of trace.\n", &setlist),
d1467 2
a1468 2
			   var_integer, (char *) &default_trace_show_source,
		      "Set display of source code with trace.\n", &setlist),
d1471 1
a1471 1
}
@


1.1.1.8
log
@import gdb-1999-08-30 snapshot
@
text
@a35 1
#include "language.h"
@


1.1.1.9
log
@import gdb-1999-09-08 snapshot
@
text
@d732 28
a759 29
  printf_filtered ("PC=%04lx (0x%lx) PSW=%04lx RPT_S=%04lx RPT_E=%04lx RPT_C=%04lx\n",
		   (long) read_register (PC_REGNUM),
		   (long) D10V_MAKE_IADDR (read_register (PC_REGNUM)),
		   (long) read_register (PSW_REGNUM),
		   (long) read_register (24),
		   (long) read_register (25),
		   (long) read_register (23));
  printf_filtered ("R0-R7  %04lx %04lx %04lx %04lx %04lx %04lx %04lx %04lx\n",
		   (long) read_register (0),
		   (long) read_register (1),
		   (long) read_register (2),
		   (long) read_register (3),
		   (long) read_register (4),
		   (long) read_register (5),
		   (long) read_register (6),
		   (long) read_register (7));
  printf_filtered ("R8-R15 %04lx %04lx %04lx %04lx %04lx %04lx %04lx %04lx\n",
		   (long) read_register (8),
		   (long) read_register (9),
		   (long) read_register (10),
		   (long) read_register (11),
		   (long) read_register (12),
		   (long) read_register (13),
		   (long) read_register (14),
		   (long) read_register (15));
  printf_filtered ("IMAP0 %04lx    IMAP1 %04lx    DMAP %04lx\n",
		   (long) read_register (IMAP0_REGNUM),
		   (long) read_register (IMAP1_REGNUM),
		   (long) read_register (DMAP_REGNUM));
d1132 2
a1133 3
	  printf_filtered ("%d: %d instruction%s at 0x%s\n",
			   i,
			   trace_data.counts[i],
d1135 1
a1135 1
			   paddr_nz (trace_data.addrs[i]));
d1264 1
a1264 1
  printf_filtered ("Dump of trace from %s to %s:\n", paddr_u (low), paddr_u (high));
@


1.1.1.10
log
@import gdb-1999-09-13 snapshot
@
text
@d48 1
a48 1
#define DMEM_START	0x2000000
d1457 1
a1457 1
  add_com ("itrace", class_support, trace_command,
d1460 1
a1460 1
  add_com ("iuntrace", class_support, untrace_command,
d1463 1
a1463 1
  add_com ("itdisassemble", class_vars, tdisassemble_command,
d1468 1
a1468 1
  add_info ("itrace", trace_info,
d1471 1
a1471 1
  add_show_from_set (add_set_cmd ("itracedisplay", no_class,
d1475 1
a1475 1
  add_show_from_set (add_set_cmd ("itracesource", no_class,
@


1.1.1.11
log
@import gdb-1999-09-21
@
text
@a1032 159
/* Translate a GDB virtual ADDR/LEN into a format the remote target
   understands.  Returns number of bytes that can be transfered
   starting at taddr, ZERO if no bytes can be transfered.  */

void
remote_d10v_translate_xfer_address (CORE_ADDR memaddr, int nr_bytes,
				    CORE_ADDR *targ_addr, int *targ_len)
{
  CORE_ADDR phys;
  CORE_ADDR seg;
  CORE_ADDR off;
  char *from = "unknown";
  char *to = "unknown";

  /* GDB interprets addresses as:

     0x00xxxxxx: Physical unified memory segment     (Unified memory)
     0x01xxxxxx: Physical instruction memory segment (On-chip insn memory)
     0x02xxxxxx: Physical data memory segment        (On-chip data memory)
     0x10xxxxxx: Logical data address segment        (DMAP translated memory)
     0x11xxxxxx: Logical instruction address segment (IMAP translated memory)

     The remote d10v board interprets addresses as:

     0x00xxxxxx: Physical unified memory segment     (Unified memory)
     0x01xxxxxx: Physical instruction memory segment (On-chip insn memory)
     0x02xxxxxx: Physical data memory segment        (On-chip data memory)

     Translate according to current IMAP/dmap registers */

  enum
    {
      targ_unified = 0x00000000,
      targ_insn = 0x01000000,
      targ_data = 0x02000000,
    };

  seg = (memaddr >> 24);
  off = (memaddr & 0xffffffL);

  switch (seg)
    {
    case 0x00:			/* Physical unified memory */
      from = "phys-unified";
      phys = targ_unified | off;
      to = "unified";
      break;

    case 0x01:			/* Physical instruction memory */
      from = "phys-insn";
      phys = targ_insn | off;
      to = "chip-insn";
      break;

    case 0x02:			/* Physical data memory segment */
      from = "phys-data";
      phys = targ_data | off;
      to = "chip-data";
      break;

    case 0x10:			/* in logical data address segment */
      {
	from = "logical-data";
	if (off <= 0x7fffL)
	  {
	    /* On chip data */
	    phys = targ_data + off;
	    if (off + nr_bytes > 0x7fffL)
	      /* don't cross VM boundary */
	      nr_bytes = 0x7fffL - off + 1;
	    to = "chip-data";
	  }
	else if (off <= 0xbfffL)
	  {
	    unsigned short dmap = read_register (DMAP_REGNUM);
	    short map = dmap;

	    if (map & 0x1000)
	      {
		/* Instruction memory */
		phys = targ_insn | ((map & 0xf) << 14) | (off & 0x3fff);
		to = "chip-insn";
	      }
	    else
	      {
		/* Unified memory */
		phys = targ_unified | ((map & 0x3ff) << 14) | (off & 0x3fff);
		to = "unified";
	      }
	    if (off + nr_bytes > 0xbfffL)
	      /* don't cross VM boundary */
	      nr_bytes = (0xbfffL - off + 1);
	  }
	else
	  {
	    /* Logical address out side of data segments, not supported */
	    *targ_len = 0;
	    return;
	  }
	break;
      }

    case 0x11:			/* in logical instruction address segment */
      {
	short map;
	unsigned short imap0 = read_register (IMAP0_REGNUM);
	unsigned short imap1 = read_register (IMAP1_REGNUM);

	from = "logical-insn";
	if (off <= 0x1ffffL)
	  {
	    map = imap0;
	  }
	else if (off <= 0x3ffffL)
	  {
	    map = imap1;
	  }
	else
	  {
	    /* Logical address outside of IMAP[01] segment, not
	       supported */
	    *targ_len = 0;
	    return;
	  }
	if ((off & 0x1ffff) + nr_bytes > 0x1ffffL)
	  {
	    /* don't cross VM boundary */
	    nr_bytes = 0x1ffffL - (off & 0x1ffffL) + 1;
	  }
	if (map & 0x1000)
	  /* Instruction memory */
	  {
	    phys = targ_insn | off;
	    to = "chip-insn";
	  }
	else
	  {
	    phys = ((map & 0x7fL) << 17) + (off & 0x1ffffL);
	    if (phys > 0xffffffL)
	      {
		/* Address outside of unified address segment */
		*targ_len = 0;
		return;
	      }
	    phys |= targ_unified;
	    to = "unified";
	  }
	break;
      }

    default:
      *targ_len = 0;
      return;
    }

  *targ_addr = phys;
  *targ_len = nr_bytes;
}

@


1.1.1.12
log
@import gdb-1999-11-08 snapshot
@
text
@d1315 1
a1315 1
    internal_error ("print_insn: no disassembler");
@


1.1.1.13
log
@import gdb-1999-11-16 snapshot
@
text
@a37 5
#include "sim-d10v.h"

#undef XMALLOC
#define XMALLOC(TYPE) ((TYPE*) xmalloc (sizeof (TYPE)))

d45 2
a46 11
struct gdbarch_tdep
  {
    int a0_regnum;
    int nr_dmap_regs;
    unsigned long (*dmap_register) (int nr);
    unsigned long (*imap_register) (int nr);
    int (*register_sim_regno) (int nr);
  };

/* These are the addresses the D10V-EVA board maps data and
   instruction memory to. */
d52 1
a52 14
/* d10v register names. */

enum
  {
    R0_REGNUM = 0,
    LR_REGNUM = 13,
    PSW_REGNUM = 16,
    NR_IMAP_REGS = 2,
    NR_A_REGS = 2
  };
#define NR_DMAP_REGS (gdbarch_tdep (current_gdbarch)->nr_dmap_regs)
#define A0_REGNUM (gdbarch_tdep (current_gdbarch)->a0_regnum)

/* d10v calling convention. */
d72 3
d111 3
a113 13
/* Map the REG_NR onto an ascii name.  Return NULL or an empty string
   when the reg_nr isn't valid. */

enum ts2_regnums
  {
    TS2_IMAP0_REGNUM = 32,
    TS2_DMAP_REGNUM = 34,
    TS2_NR_DMAP_REGS = 1,
    TS2_A0_REGNUM = 35
  };

static char *
d10v_ts2_register_name (int reg_nr)
a129 114
enum ts3_regnums
  {
    TS3_IMAP0_REGNUM = 36,
    TS3_DMAP0_REGNUM = 38,
    TS3_NR_DMAP_REGS = 4,
    TS3_A0_REGNUM = 32
  };

static char *
d10v_ts3_register_name (int reg_nr)
{
  static char *register_names[] =
  {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "psw", "bpsw", "pc", "bpc", "cr4", "cr5", "cr6", "rpt_c",
    "rpt_s", "rpt_e", "mod_s", "mod_e", "cr12", "cr13", "iba", "cr15",
    "a0", "a1",
    "spi", "spu",
    "imap0", "imap1",
    "dmap0", "dmap1", "dmap2", "dmap3"
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

/* Access the DMAP/IMAP registers in a target independant way. */

static unsigned long
d10v_ts2_dmap_register (int reg_nr)
{
  switch (reg_nr)
    {
    case 0:
    case 1:
      return 0x2000;
    case 2:
      return read_register (TS2_DMAP_REGNUM);
    default:
      return 0;
    }
}

static unsigned long
d10v_ts3_dmap_register (int reg_nr)
{
  return read_register (TS3_DMAP0_REGNUM + reg_nr);
}

static unsigned long
d10v_dmap_register (int reg_nr)
{
  return gdbarch_tdep (current_gdbarch)->dmap_register (reg_nr);
}

static unsigned long
d10v_ts2_imap_register (int reg_nr)
{
  return read_register (TS2_IMAP0_REGNUM + reg_nr);
}

static unsigned long
d10v_ts3_imap_register (int reg_nr)
{
  return read_register (TS3_IMAP0_REGNUM + reg_nr);
}

static unsigned long
d10v_imap_register (int reg_nr)
{
  return gdbarch_tdep (current_gdbarch)->imap_register (reg_nr);
}

/* MAP GDB's internal register numbering (determined by the layout fo
   the REGISTER_BYTE array) onto the simulator's register
   numbering. */

static int
d10v_ts2_register_sim_regno (int nr)
{
  if (nr >= TS2_IMAP0_REGNUM
      && nr < TS2_IMAP0_REGNUM + NR_IMAP_REGS)
    return nr - TS2_IMAP0_REGNUM + SIM_D10V_IMAP0_REGNUM;
  if (nr == TS2_DMAP_REGNUM)
    return nr - TS2_DMAP_REGNUM + SIM_D10V_TS2_DMAP_REGNUM;
  if (nr >= TS2_A0_REGNUM
      && nr < TS2_A0_REGNUM + NR_A_REGS)
    return nr - TS2_A0_REGNUM + SIM_D10V_A0_REGNUM;
  return nr;
}

static int
d10v_ts3_register_sim_regno (int nr)
{
  if (nr >= TS3_IMAP0_REGNUM
      && nr < TS3_IMAP0_REGNUM + NR_IMAP_REGS)
    return nr - TS3_IMAP0_REGNUM + SIM_D10V_IMAP0_REGNUM;
  if (nr >= TS3_DMAP0_REGNUM
      && nr < TS3_DMAP0_REGNUM + TS3_NR_DMAP_REGS)
    return nr - TS3_DMAP0_REGNUM + SIM_D10V_DMAP0_REGNUM;
  if (nr >= TS3_A0_REGNUM
      && nr < TS3_A0_REGNUM + NR_A_REGS)
    return nr - TS3_A0_REGNUM + SIM_D10V_A0_REGNUM;
  return nr;
}

int
d10v_register_sim_regno (int nr)
{
  return gdbarch_tdep (current_gdbarch)->register_sim_regno (nr);
}
d138 3
a140 1
  if (reg_nr < A0_REGNUM)
a141 7
  else if (reg_nr < (A0_REGNUM + NR_A_REGS))
    return (A0_REGNUM * 2
	    + (reg_nr - A0_REGNUM) * 8);
  else
    return (A0_REGNUM * 2
	    + NR_A_REGS * 8
	    + (reg_nr - A0_REGNUM - NR_A_REGS) * 2);
d151 1
a151 3
  if (reg_nr < A0_REGNUM)
    return 2;
  else if (reg_nr < (A0_REGNUM + NR_A_REGS))
d164 6
a169 1
  return TYPE_LENGTH (REGISTER_VIRTUAL_TYPE (reg_nr));
d179 4
a182 6
  if (reg_nr >= A0_REGNUM
      && reg_nr < (A0_REGNUM + NR_A_REGS))
    return builtin_type_int64;
  else if (reg_nr == PC_REGNUM
	   || reg_nr == SP_REGNUM)
    return builtin_type_int32;
d184 1
a184 1
    return builtin_type_int16;
d366 1
a366 1
  for (regnum = A0_REGNUM; regnum < A0_REGNUM + NR_A_REGS; regnum++)
d757 6
a762 18
  for (a = 0; a < NR_IMAP_REGS; a++)
    {
      if (a > 0)
	printf_filtered ("    ");
      printf_filtered ("IMAP%d %04lx", a, d10v_imap_register (a));
    }
  if (NR_DMAP_REGS == 1)
    printf_filtered ("    DMAP %04lx\n", d10v_dmap_register (2));
  else
    {
      for (a = 0; a < NR_DMAP_REGS; a++)
	{
	  printf_filtered ("    DMAP%d %04lx", a, d10v_dmap_register (a));
	}
      printf_filtered ("\n");
    }
  printf_filtered ("A0-A%d", NR_A_REGS - 1);
  for (a = A0_REGNUM; a < A0_REGNUM + NR_A_REGS; a++)
d1035 1
a1035 3
   starting at TARG_ADDR.  Return ZERO if no bytes can be transfered
   (segmentation fault).  Since the simulator knows all about how the
   VM system works, we just call that to do the translation. */
d1037 1
a1037 1
static void
d1041 149
a1189 8
  long out_addr;
  long out_len;
  out_len = sim_d10v_translate_addr (memaddr, nr_bytes,
				     &out_addr,
				     d10v_dmap_register,
				     d10v_imap_register);
  *targ_addr = out_addr;
  *targ_len = out_len;
a1191 1

a1492 1

d1501 1
a1501 3
  int d10v_num_regs;
  struct gdbarch_tdep *tdep;
  gdbarch_register_name_ftype *d10v_register_name;
d1503 1
a1503 2
  /* Find a candidate among the list of pre-declared architectures. */
  arches = gdbarch_list_lookup_by_info (arches, &info);
d1506 1
a1506 28

  /* None found, create a new architecture from the information
     provided. */
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  switch (info.bfd_arch_info->mach)
    {
    case bfd_mach_d10v_ts2:
      d10v_num_regs = 37;
      d10v_register_name = d10v_ts2_register_name;
      tdep->a0_regnum = TS2_A0_REGNUM;
      tdep->nr_dmap_regs = TS2_NR_DMAP_REGS;
      tdep->register_sim_regno = d10v_ts2_register_sim_regno;
      tdep->dmap_register = d10v_ts2_dmap_register;
      tdep->imap_register = d10v_ts2_imap_register;
      break;
    default:
    case bfd_mach_d10v_ts3:
      d10v_num_regs = 42;
      d10v_register_name = d10v_ts3_register_name;
      tdep->a0_regnum = TS3_A0_REGNUM;
      tdep->nr_dmap_regs = TS3_NR_DMAP_REGS;
      tdep->register_sim_regno = d10v_ts3_register_sim_regno;
      tdep->dmap_register = d10v_ts3_dmap_register;
      tdep->imap_register = d10v_ts3_imap_register;
      break;
    }
@


1.1.1.14
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 2000 Free Software Foundation, Inc.
d1337 1
a1337 1
     struct ui_file *stream;
@


