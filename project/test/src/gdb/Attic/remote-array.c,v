head	1.23;
access;
symbols
	jimb-ppc64-linux-20030613-branch:1.22.0.8
	jimb-ppc64-linux-20030613-branchpoint:1.22
	cagney_convert-20030606-branch:1.22.0.6
	cagney_convert-20030606-branchpoint:1.22
	cagney_writestrings-20030508-branch:1.21.0.4
	cagney_writestrings-20030508-branchpoint:1.21
	jimb-ppc64-linux-20030528-branch:1.22.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.22
	carlton_dictionary-20030523-merge:1.22
	cagney_fileio-20030521-branch:1.22.0.2
	cagney_fileio-20030521-branchpoint:1.22
	kettenis_i386newframe-20030517-mergepoint:1.22
	jimb-ppc64-linux-20030509-branch:1.21.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.21
	kettenis_i386newframe-20030504-mergepoint:1.20
	carlton_dictionary-20030430-merge:1.20
	kettenis_i386newframe-20030419-branch:1.20.0.20
	kettenis_i386newframe-20030419-branchpoint:1.20
	carlton_dictionary-20030416-merge:1.20
	cagney_frameaddr-20030409-mergepoint:1.20
	kettenis_i386newframe-20030406-branch:1.20.0.18
	kettenis_i386newframe-20030406-branchpoint:1.20
	cagney_frameaddr-20030403-branchpoint:1.20
	cagney_frameaddr-20030403-branch:1.20.0.16
	cagney_framebase-20030330-mergepoint:1.20
	cagney_framebase-20030326-branch:1.20.0.14
	cagney_framebase-20030326-branchpoint:1.20
	cagney_lazyid-20030317-branch:1.20.0.12
	cagney_lazyid-20030317-branchpoint:1.20
	kettenis-i386newframe-20030316-mergepoint:1.20
	offbyone-20030313-branch:1.20.0.10
	offbyone-20030313-branchpoint:1.20
	kettenis-i386newframe-20030308-branch:1.20.0.8
	kettenis-i386newframe-20030308-branchpoint:1.20
	carlton_dictionary-20030305-merge:1.20
	cagney_offbyone-20030303-branch:1.20.0.6
	cagney_offbyone-20030303-branchpoint:1.20
	carlton_dictionary-20030207-merge:1.20
	interps-20030203-mergepoint:1.20
	interps-20030202-branch:1.20.0.4
	interps-20030202-branchpoint:1.20
	cagney-unwind-20030108-branch:1.20.0.2
	cagney-unwind-20030108-branchpoint:1.20
	carlton_dictionary-20021223-merge:1.20
	gdb_5_3-2002-12-12-release:1.19
	carlton_dictionary-20021115-merge:1.20
	kseitz_interps-20021105-merge:1.19
	kseitz_interps-20021103-merge:1.19
	drow-cplus-merge-20021020:1.19
	drow-cplus-merge-20021025:1.19
	carlton_dictionary-20021025-merge:1.19
	carlton_dictionary-20021011-merge:1.19
	drow-cplus-branch:1.19.0.16
	drow-cplus-branchpoint:1.19
	kseitz_interps-20020930-merge:1.19
	carlton_dictionary-20020927-merge:1.19
	carlton_dictionary-branch:1.19.0.14
	carlton_dictionary-20020920-branchpoint:1.19
	gdb_5_3-branch:1.19.0.12
	gdb_5_3-2002-09-04-branchpoint:1.19
	kseitz_interps-20020829-merge:1.19
	cagney_sysregs-20020825-branch:1.19.0.10
	cagney_sysregs-20020825-branchpoint:1.19
	readline_4_3-import-branch:1.19.0.8
	readline_4_3-import-branchpoint:1.19
	gdb_5_2_1-2002-07-23-release:1.18
	kseitz_interps-20020528-branch:1.19.0.6
	kseitz_interps-20020528-branchpoint:1.19
	cagney_regbuf-20020515-branch:1.19.0.4
	cagney_regbuf-20020515-branchpoint:1.19
	jimb-macro-020506-branch:1.19.0.2
	jimb-macro-020506-branchpoint:1.19
	gdb_5_2-2002-04-29-release:1.18
	gdb_5_2-branch:1.18.0.2
	gdb_5_2-2002-03-03-branchpoint:1.18
	gdb_5_1_1-2002-01-24-release:1.17
	gdb_5_1_0_1-2002-01-03-release:1.17
	cygnus_cvs_20020108_pre:1.17
	gdb_5_1_0_1-2002-01-03-branchpoint:1.17
	gdb_5_1_0_1-2002-01-03-branch:1.17.0.6
	gdb_5_1-2001-11-21-release:1.17
	gdb_s390-2001-09-26-branch:1.17.0.4
	gdb_s390-2001-09-26-branchpoint:1.17
	gdb_5_1-2001-07-29-branch:1.17.0.2
	gdb_5_1-2001-07-29-branchpoint:1.17
	dberlin-typesystem-branch:1.15.0.2
	dberlin-typesystem-branchpoint:1.15
	gdb-post-ptid_t-2001-05-03:1.14
	gdb-pre-ptid_t-2001-05-03:1.13
	insight-precleanup-2001-01-01:1.7
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.4
	gdb-1999-10-25:1.1.1.4
	gdb-1999-10-18:1.1.1.4
	gdb-1999-10-11:1.1.1.4
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.4
	gdb-1999-09-13:1.1.1.4
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.23
date	2003.06.14.23.43.15;	author cagney;	state dead;
branches;
next	1.22;

1.22
date	2003.05.17.05.59.58;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.08.20.52.48;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.12.21.43.55;	author drow;	state Exp;
branches
	1.20.20.1;
next	1.19;

1.19
date	2002.04.29.11.01.13;	author muller;	state Exp;
branches
	1.19.14.1
	1.19.16.1;
next	1.18;

1.18
date	2002.01.19.03.32.37;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.15.20.34.13;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.11.17.52.32;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.29.04.41.20;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.04.04.15.26;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.14.19.23.02;	author jtc;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.06.08.21.12;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.02.23.04.14;	author jtc;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.02.19.14.32;	author jtc;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.23.22.48.55;	author jtc;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.02.00.49.55;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.01.00.12.10;	author jtc;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.18.22.02.43;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.46;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.08.54;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.09.21.33.46;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.09.08.23.59.25;	author shebs;	state Exp;
branches;
next	;

1.19.14.1
date	2002.11.15.19.18.53;	author carlton;	state Exp;
branches;
next	1.19.14.2;

1.19.14.2
date	2003.05.23.18.40.43;	author carlton;	state Exp;
branches;
next	1.19.14.3;

1.19.14.3
date	2003.06.27.21.50.07;	author carlton;	state dead;
branches;
next	;

1.19.16.1
date	2003.12.14.20.27.28;	author drow;	state dead;
branches;
next	;

1.20.20.1
date	2003.05.18.09.44.19;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.23
log
@2003-06-14  Andrew Cagney  <cagney@@redhat.com>

	* config/mips/embedl64.mt (TDEPFILES): Delete "remote-array.o".
	* config/mips/embedl.mt (TDEPFILES): Delete "remote-array.o".
	* config/mips/embed64.mt (TDEPFILES): Delete "remote-array.o".
	* config/djgpp/fnchange.lst: Delete "remote-array.c".
	* README: Delete reference to remote-array.
	* Makefile.in (ALLDEPFILES): Remove "remote-array.c".
	(remote-array.o): Delete target.
	* config/mips/embed.mt (TDEPFILES): Delete "remote-array.o".
	* remote-array.c: Delete file.
@
text
@/* Remote debugging interface for Array Tech RAID controller..

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002 Free Software Foundation, Inc.

   Contributed by Cygnus Support. Written by Rob Savoye for Cygnus.

   This module talks to a debug monitor called 'MONITOR', which
   We communicate with MONITOR via either a direct serial line, or a TCP
   (or possibly TELNET) stream to a terminal multiplexor,
   which in turn talks to the target board.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "gdbcore.h"
#include "target.h"
#include <ctype.h>
#include <sys/types.h>
#include "gdb_string.h"
#include "command.h"
#include "serial.h"
#include "monitor.h"
#include "remote-utils.h"
#include "inferior.h"
#include "version.h"
#include "regcache.h"

extern int baud_rate;

#define ARRAY_PROMPT ">> "

static void debuglogs (int, char *, ...);
static void array_open ();
static void array_close ();
static void array_detach ();
static void array_attach ();
static void array_resume (ptid_t ptid, int step, enum target_signal sig);
static void array_fetch_register ();
static void array_store_register ();
static void array_fetch_registers ();
static void array_store_registers ();
static void array_prepare_to_store ();
static void array_files_info ();
static void array_kill ();
static void array_create_inferior ();
static void array_mourn_inferior ();
static void make_gdb_packet ();
static int array_xfer_memory ();
static ptid_t array_wait (ptid_t ptid,
                                 struct target_waitstatus *status);
static int array_insert_breakpoint ();
static int array_remove_breakpoint ();
static int tohex ();
static int to_hex ();
static int from_hex ();
static int array_send_packet ();
static int array_get_packet ();
static unsigned long ascii2hexword ();
static void hexword2ascii ();

#define LOG_FILE "monitor.log"
#if defined (LOG_FILE)
FILE *log_file;
#endif

static int timeout = 30;
/* Having this larger than 400 causes us to be incompatible with
   m68k-stub.c and i386-stub.c.  Normally, no one would notice because
   it only matters for writing large chunks of memory (e.g. in
   downloads).  Also, this needs to be more than 400 if required to
   hold the registers (see below, where we round it up based on
   DEPRECATED_REGISTER_BYTES).  */
#define PBUFSIZ 400

/* 
 * Descriptor for I/O to remote machine.  Initialize it to NULL so that
 * array_open knows that we don't have a file open when the program starts.
 */
struct serial *array_desc = NULL;

/*
 * this array of registers need to match the indexes used by GDB. The
 * whole reason this exists is cause the various ROM monitors use
 * different strings than GDB does, and doesn't support all the
 * registers either. So, typing "info reg sp" becomes a "r30".
 */
extern char *tmp_mips_processor_type;
extern int mips_set_processor_type ();

static struct target_ops array_ops;

static void
init_array_ops (void)
{
  array_ops.to_shortname = "array";
  array_ops.to_longname =
    "Debug using the standard GDB remote protocol for the Array Tech target.",
    array_ops.to_doc =
    "Debug using the standard GDB remote protocol for the Array Tech target.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  array_ops.to_open = array_open;
  array_ops.to_close = array_close;
  array_ops.to_detach = array_detach;
  array_ops.to_resume = array_resume;
  array_ops.to_wait = array_wait;
  array_ops.to_fetch_registers = array_fetch_registers;
  array_ops.to_store_registers = array_store_registers;
  array_ops.to_prepare_to_store = array_prepare_to_store;
  array_ops.to_xfer_memory = array_xfer_memory;
  array_ops.to_files_info = array_files_info;
  array_ops.to_insert_breakpoint = array_insert_breakpoint;
  array_ops.to_remove_breakpoint = array_remove_breakpoint;
  array_ops.to_kill = array_kill;
  array_ops.to_create_inferior = array_create_inferior;
  array_ops.to_mourn_inferior = array_mourn_inferior;
  array_ops.to_stratum = process_stratum;
  array_ops.to_has_all_memory = 1;
  array_ops.to_has_memory = 1;
  array_ops.to_has_stack = 1;
  array_ops.to_has_registers = 1;
  array_ops.to_has_execution = 1;
  array_ops.to_magic = OPS_MAGIC;
};

/*
 * printf_monitor -- send data to monitor.  Works just like printf.
 */
static void
printf_monitor (char *pattern,...)
{
  va_list args;
  char buf[PBUFSIZ];
  int i;

  va_start (args, pattern);

  vsprintf (buf, pattern, args);

  debuglogs (1, "printf_monitor(), Sending: \"%s\".", buf);

  if (strlen (buf) > PBUFSIZ)
    error ("printf_monitor(): string too long");
  if (serial_write (array_desc, buf, strlen (buf)))
    fprintf_unfiltered (gdb_stderr, "serial_write failed: %s\n", 
			safe_strerror (errno));
}
/*
 * write_monitor -- send raw data to monitor.
 */
static void
write_monitor (char data[], int len)
{
  if (serial_write (array_desc, data, len))
    fprintf_unfiltered (gdb_stderr, "serial_write failed: %s\n",
			safe_strerror (errno));

  *(data + len + 1) = '\0';
  debuglogs (1, "write_monitor(), Sending: \"%s\".", data);

}

/*
 * debuglogs -- deal with debugging info to multiple sources. This takes
 *      two real args, the first one is the level to be compared against 
 *      the sr_get_debug() value, the second arg is a printf buffer and args
 *      to be formatted and printed. A CR is added after each string is printed.
 */
static void
debuglogs (int level, char *pattern,...)
{
  va_list args;
  char *p;
  unsigned char buf[PBUFSIZ];
  char newbuf[PBUFSIZ];
  int i;

  va_start (args, pattern);

  if ((level < 0) || (level > 100))
    {
      error ("Bad argument passed to debuglogs(), needs debug level");
      return;
    }

  vsprintf (buf, pattern, args);	/* format the string */

  /* convert some characters so it'll look right in the log */
  p = newbuf;
  for (i = 0; buf[i] != '\0'; i++)
    {
      if (i > PBUFSIZ)
	error ("Debug message too long");
      switch (buf[i])
	{
	case '\n':		/* newlines */
	  *p++ = '\\';
	  *p++ = 'n';
	  continue;
	case '\r':		/* carriage returns */
	  *p++ = '\\';
	  *p++ = 'r';
	  continue;
	case '\033':		/* escape */
	  *p++ = '\\';
	  *p++ = 'e';
	  continue;
	case '\t':		/* tab */
	  *p++ = '\\';
	  *p++ = 't';
	  continue;
	case '\b':		/* backspace */
	  *p++ = '\\';
	  *p++ = 'b';
	  continue;
	default:		/* no change */
	  *p++ = buf[i];
	}

      if (buf[i] < 26)
	{			/* modify control characters */
	  *p++ = '^';
	  *p++ = buf[i] + 'A';
	  continue;
	}
      if (buf[i] >= 128)
	{			/* modify control characters */
	  *p++ = '!';
	  *p++ = buf[i] + 'A';
	  continue;
	}
    }
  *p = '\0';			/* terminate the string */

  if (sr_get_debug () > level)
    printf_unfiltered ("%s\n", newbuf);

#ifdef LOG_FILE			/* write to the monitor log */
  if (log_file != 0x0)
    {
      fputs (newbuf, log_file);
      fputc ('\n', log_file);
      fflush (log_file);
    }
#endif
}

/* readchar -- read a character from the remote system, doing all the fancy
 *    timeout stuff.
 */
static int
readchar (int timeout)
{
  int c;

  c = serial_readchar (array_desc, abs (timeout));

  if (sr_get_debug () > 5)
    {
      putchar (c & 0x7f);
      debuglogs (5, "readchar: timeout = %d\n", timeout);
    }

#ifdef LOG_FILE
  if (isascii (c))
    putc (c & 0x7f, log_file);
#endif

  if (c >= 0)
    return c & 0x7f;

  if (c == SERIAL_TIMEOUT)
    {
      if (timeout <= 0)
	return c;		/* Polls shouldn't generate timeout errors */
      error ("Timeout reading from remote system.");
#ifdef LOG_FILE
      fputs ("ERROR: Timeout reading from remote system", log_file);
#endif
    }
  perror_with_name ("readchar");
}

/* 
 * expect --  scan input from the remote system, until STRING is found.
 *      If DISCARD is non-zero, then discard non-matching input, else print
 *      it out. Let the user break out immediately.
 */
static void
expect (char *string, int discard)
{
  char *p = string;
  int c;


  debuglogs (1, "Expecting \"%s\".", string);

  immediate_quit++;
  while (1)
    {
      c = readchar (timeout);
      if (!isascii (c))
	continue;
      if (c == *p++)
	{
	  if (*p == '\0')
	    {
	      immediate_quit--;
	      debuglogs (4, "Matched");
	      return;
	    }
	}
      else
	{
	  if (!discard)
	    {
	      fputc_unfiltered (c, gdb_stdout);
	    }
	  p = string;
	}
    }
}

/* Keep discarding input until we see the MONITOR array_cmds->prompt.

   The convention for dealing with the expect_prompt is that you
   o give your command
   o *then* wait for the expect_prompt.

   Thus the last thing that a procedure does with the serial line
   will be an expect_prompt().  Exception:  array_resume does not
   wait for the expect_prompt, because the terminal is being handed over
   to the inferior.  However, the next thing which happens after that
   is a array_wait which does wait for the expect_prompt.
   Note that this includes abnormal exit, e.g. error().  This is
   necessary to prevent getting into states from which we can't
   recover.  */
static void
expect_prompt (int discard)
{
  expect (ARRAY_PROMPT, discard);
}

/*
 * junk -- ignore junk characters. Returns a 1 if junk, 0 otherwise
 */
static int
junk (char ch)
{
  switch (ch)
    {
    case '\0':
    case ' ':
    case '-':
    case '\t':
    case '\r':
    case '\n':
      if (sr_get_debug () > 5)
	debuglogs (5, "Ignoring \'%c\'.", ch);
      return 1;
    default:
      if (sr_get_debug () > 5)
	debuglogs (5, "Accepting \'%c\'.", ch);
      return 0;
    }
}

/* 
 *  get_hex_digit -- Get a hex digit from the remote system & return its value.
 *              If ignore is nonzero, ignore spaces, newline & tabs.
 */
static int
get_hex_digit (int ignore)
{
  static int ch;
  while (1)
    {
      ch = readchar (timeout);
      if (junk (ch))
	continue;
      if (sr_get_debug () > 4)
	{
	  debuglogs (4, "get_hex_digit() got a 0x%x(%c)", ch, ch);
	}
      else
	{
#ifdef LOG_FILE			/* write to the monitor log */
	  if (log_file != 0x0)
	    {
	      fputs ("get_hex_digit() got a 0x", log_file);
	      fputc (ch, log_file);
	      fputc ('\n', log_file);
	      fflush (log_file);
	    }
#endif
	}

      if (ch >= '0' && ch <= '9')
	return ch - '0';
      else if (ch >= 'A' && ch <= 'F')
	return ch - 'A' + 10;
      else if (ch >= 'a' && ch <= 'f')
	return ch - 'a' + 10;
      else if (ch == ' ' && ignore)
	;
      else
	{
	  expect_prompt (1);
	  debuglogs (4, "Invalid hex digit from remote system. (0x%x)", ch);
	  error ("Invalid hex digit from remote system. (0x%x)", ch);
	}
    }
}

/* get_hex_byte -- Get a byte from monitor and put it in *BYT. 
 *    Accept any number leading spaces.
 */
static void
get_hex_byte (char *byt)
{
  int val;

  val = get_hex_digit (1) << 4;
  debuglogs (4, "get_hex_byte() -- Read first nibble 0x%x", val);

  val |= get_hex_digit (0);
  debuglogs (4, "get_hex_byte() -- Read second nibble 0x%x", val);
  *byt = val;

  debuglogs (4, "get_hex_byte() -- Read a 0x%x", val);
}

/* 
 * get_hex_word --  Get N 32-bit words from remote, each preceded by a space,
 *      and put them in registers starting at REGNO.
 */
static int
get_hex_word (void)
{
  long val, newval;
  int i;

  val = 0;

  for (i = 0; i < 8; i++)
    val = (val << 4) + get_hex_digit (i == 0);

  debuglogs (4, "get_hex_word() got a 0x%x.", val);

  return val;
}

/* This is called not only when we first attach, but also when the
   user types "run" after having attached.  */
static void
array_create_inferior (char *execfile, char *args, char **env)
{
  int entry_pt;

  if (args && *args)
    error ("Can't pass arguments to remote MONITOR process");

  if (execfile == 0 || exec_bfd == 0)
    error ("No executable file specified");

  entry_pt = (int) bfd_get_start_address (exec_bfd);

/* The "process" (board) is already stopped awaiting our commands, and
   the program is already downloaded.  We just set its PC and go.  */

  clear_proceed_status ();

  /* Tell wait_for_inferior that we've started a new process.  */
  init_wait_for_inferior ();

  /* Set up the "saved terminal modes" of the inferior
     based on what modes we are starting it with.  */
  target_terminal_init ();

  /* Install inferior's terminal modes.  */
  target_terminal_inferior ();

  /* insert_step_breakpoint ();  FIXME, do we need this?  */

  /* Let 'er rip... */
  proceed ((CORE_ADDR) entry_pt, TARGET_SIGNAL_DEFAULT, 0);
}

/*
 * array_open -- open a connection to a remote debugger.
 *      NAME is the filename used for communication.
 */
static int baudrate = 9600;
static char dev_name[100];

static void
array_open (char *args, char *name, int from_tty)
{
  char packet[PBUFSIZ];

  if (args == NULL)
    error ("Use `target %s DEVICE-NAME' to use a serial port, or \n\
`target %s HOST-NAME:PORT-NUMBER' to use a network connection.", name, name);

/*  if (is_open) */
  array_close (0);

  target_preopen (from_tty);
  unpush_target (&array_ops);

  tmp_mips_processor_type = "lsi33k";	/* change the default from r3051 */
  mips_set_processor_type_command ("lsi33k", 0);

  strcpy (dev_name, args);
  array_desc = serial_open (dev_name);

  if (array_desc == NULL)
    perror_with_name (dev_name);

  if (baud_rate != -1)
    {
      if (serial_setbaudrate (array_desc, baud_rate))
	{
	  serial_close (array_desc);
	  perror_with_name (name);
	}
    }

  serial_raw (array_desc);

#if defined (LOG_FILE)
  log_file = fopen (LOG_FILE, "w");
  if (log_file == NULL)
    perror_with_name (LOG_FILE);
  fprintf (log_file, "GDB %s (%s", version, host_name);
  fprintf (log_file, " --target %s)\n", array_ops.to_shortname);
  fprintf (log_file, "Remote target %s connected to %s\n\n", array_ops.to_shortname, dev_name);
#endif

  /* see if the target is alive. For a ROM monitor, we can just try to force the
     expect_prompt to print a few times. For the GDB remote protocol, the application
     being debugged is sitting at a breakpoint and waiting for GDB to initialize
     the connection. We force it to give us an empty packet to see if it's alive.
   */
  debuglogs (3, "Trying to ACK the target's debug stub");
  /* unless your are on the new hardware, the old board won't initialize
     because the '@@' doesn't flush output like it does on the new ROMS.
   */
  printf_monitor ("@@");		/* ask for the last signal */
  expect_prompt (1);		/* See if we get a expect_prompt */
#ifdef TEST_ARRAY		/* skip packet for testing */
  make_gdb_packet (packet, "?");	/* ask for a bogus packet */
  if (array_send_packet (packet) == 0)
    error ("Couldn't transmit packet\n");
  printf_monitor ("@@\n");	/* force it to flush stdout */
  expect_prompt (1);		/* See if we get a expect_prompt */
#endif
  push_target (&array_ops);
  if (from_tty)
    printf ("Remote target %s connected to %s\n", array_ops.to_shortname, dev_name);
}

/*
 * array_close -- Close out all files and local state before this
 *      target loses control.
 */

static void
array_close (int quitting)
{
  serial_close (array_desc);
  array_desc = NULL;

  debuglogs (1, "array_close (quitting=%d)", quitting);

#if defined (LOG_FILE)
  if (log_file)
    {
      if (ferror (log_file))
	printf_filtered ("Error writing log file.\n");
      if (fclose (log_file) != 0)
	printf_filtered ("Error closing log file.\n");
    }
#endif
}

/* 
 * array_detach -- terminate the open connection to the remote
 *      debugger. Use this when you want to detach and do something
 *      else with your gdb.
 */
static void
array_detach (int from_tty)
{

  debuglogs (1, "array_detach ()");

  pop_target ();		/* calls array_close to do the real work */
  if (from_tty)
    printf ("Ending remote %s debugging\n", target_shortname);
}

/*
 * array_attach -- attach GDB to the target.
 */
static void
array_attach (char *args, int from_tty)
{
  if (from_tty)
    printf ("Starting remote %s debugging\n", target_shortname);

  debuglogs (1, "array_attach (args=%s)", args);

  printf_monitor ("go %x\n");
  /* swallow the echo.  */
  expect ("go %x\n", 1);
}

/*
 * array_resume -- Tell the remote machine to resume.
 */
static void
array_resume (ptid_t ptid, int step, enum target_signal sig)
{
  debuglogs (1, "array_resume (step=%d, sig=%d)", step, sig);

  if (step)
    {
      printf_monitor ("s\n");
    }
  else
    {
      printf_monitor ("go\n");
    }
}

#define TMPBUFSIZ 5

/*
 * array_wait -- Wait until the remote machine stops, then return,
 *          storing status in status just as `wait' would.
 */
static ptid_t
array_wait (ptid_t ptid, struct target_waitstatus *status)
{
  int old_timeout = timeout;
  int result, i;
  char c;
  struct serial *tty_desc;
  serial_ttystate ttystate;

  debuglogs (1, "array_wait (), printing extraneous text.");

  status->kind = TARGET_WAITKIND_EXITED;
  status->value.integer = 0;

  timeout = 0;			/* Don't time out -- user program is running. */

#if !defined(__GO32__) && !defined(__MSDOS__) && !defined(_WIN32)
  tty_desc = serial_fdopen (0);
  ttystate = serial_get_tty_state (tty_desc);
  serial_raw (tty_desc);

  i = 0;
  /* poll on the serial port and the keyboard. */
  while (1)
    {
      c = readchar (timeout);
      if (c > 0)
	{
	  if (c == *(ARRAY_PROMPT + i))
	    {
	      if (++i >= strlen (ARRAY_PROMPT))
		{		/* matched the prompt */
		  debuglogs (4, "array_wait(), got the expect_prompt.");
		  break;
		}
	    }
	  else
	    {			/* not the prompt */
	      i = 0;
	    }
	  fputc_unfiltered (c, gdb_stdout);
	  gdb_flush (gdb_stdout);
	}
      c = serial_readchar (tty_desc, timeout);
      if (c > 0)
	{
	  serial_write (array_desc, &c, 1);
	  /* do this so it looks like there's keyboard echo */
	  if (c == 3)		/* exit on Control-C */
	    break;
#if 0
	  fputc_unfiltered (c, gdb_stdout);
	  gdb_flush (gdb_stdout);
#endif
	}
    }
  serial_set_tty_state (tty_desc, ttystate);
#else
  expect_prompt (1);
  debuglogs (4, "array_wait(), got the expect_prompt.");
#endif

  status->kind = TARGET_WAITKIND_STOPPED;
  status->value.sig = TARGET_SIGNAL_TRAP;

  timeout = old_timeout;

  return inferior_ptid;
}

/*
 * array_fetch_registers -- read the remote registers into the
 *      block regs.
 */
static void
array_fetch_registers (int ignored)
{
  char reg[MAX_REGISTER_SIZE];
  int regno;
  char *p;
  char *packet = alloca (PBUFSIZ);

  debuglogs (1, "array_fetch_registers (ignored=%d)\n", ignored);

  memset (packet, 0, PBUFSIZ);
  make_gdb_packet (packet, "g");
  if (array_send_packet (packet) == 0)
    error ("Couldn't transmit packet\n");
  if (array_get_packet (packet) == 0)
    error ("Couldn't receive packet\n");
  /* FIXME: read bytes from packet */
  debuglogs (4, "array_fetch_registers: Got a \"%s\" back\n", packet);
  for (regno = 0; regno <= PC_REGNUM + 4; regno++)
    {
      /* supply register stores in target byte order, so swap here */
      /* FIXME: convert from ASCII hex to raw bytes */
      LONGEST i = ascii2hexword (packet + (regno * 8));
      debuglogs (5, "Adding register %d = %x\n", regno, i);
      store_unsigned_integer (&reg, REGISTER_RAW_SIZE (regno), i);
      supply_register (regno, (char *) &reg);
    }
}

/* 
 * This is unused by targets like this one that use a
 * protocol based on GDB's remote protocol.
 */
static void
array_fetch_register (int ignored)
{
  array_fetch_registers (0 /* ignored */);
}

/*
 * Get all the registers from the targets. They come back in a large array.
 */
static void
array_store_registers (int ignored)
{
  int regno;
  unsigned long i;
  char packet[PBUFSIZ];
  char buf[PBUFSIZ];
  char num[9];

  debuglogs (1, "array_store_registers()");

  memset (packet, 0, PBUFSIZ);
  memset (buf, 0, PBUFSIZ);
  buf[0] = 'G';

  /* Unimplemented registers read as all bits zero.  */
  /* FIXME: read bytes from packet */
  for (regno = 0; regno < 41; regno++)
    {				/* FIXME */
      /* supply register stores in target byte order, so swap here */
      /* FIXME: convert from ASCII hex to raw bytes */
      i = (unsigned long) read_register (regno);
      hexword2ascii (num, i);
      strcpy (buf + (regno * 8) + 1, num);
    }
  *(buf + (regno * 8) + 2) = 0;
  make_gdb_packet (packet, buf);
  if (array_send_packet (packet) == 0)
    error ("Couldn't transmit packet\n");
  if (array_get_packet (packet) == 0)
    error ("Couldn't receive packet\n");

  registers_changed ();
}

/* 
 * This is unused by targets like this one that use a
 * protocol based on GDB's remote protocol.
 */
static void
array_store_register (int ignored)
{
  array_store_registers (0 /* ignored */);
}

/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */

static void
array_prepare_to_store (void)
{
  /* Do nothing, since we can store individual regs */
}

static void
array_files_info (void)
{
  printf ("\tAttached to %s at %d baud.\n",
	  dev_name, baudrate);
}

/*
 * array_write_inferior_memory -- Copy LEN bytes of data from debugger
 *      memory at MYADDR to inferior's memory at MEMADDR.  Returns length moved.
 */
static int
array_write_inferior_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  unsigned long i;
  int j;
  char packet[PBUFSIZ];
  char buf[PBUFSIZ];
  char num[9];
  char *p;

  debuglogs (1, "array_write_inferior_memory (memaddr=0x%x, myaddr=0x%x, len=%d)", memaddr, myaddr, len);
  memset (buf, '\0', PBUFSIZ);	/* this also sets the string terminator */
  p = buf;

  *p++ = 'M';			/* The command to write memory */
  hexword2ascii (num, memaddr);	/* convert the address */
  strcpy (p, num);		/* copy the address */
  p += 8;
  *p++ = ',';			/* add comma delimeter */
  hexword2ascii (num, len);	/* Get the length as a 4 digit number */
  *p++ = num[4];
  *p++ = num[5];
  *p++ = num[6];
  *p++ = num[7];
  *p++ = ':';			/* add the colon delimeter */
  for (j = 0; j < len; j++)
    {				/* copy the data in after converting it */
      *p++ = tohex ((myaddr[j] >> 4) & 0xf);
      *p++ = tohex (myaddr[j] & 0xf);
    }

  make_gdb_packet (packet, buf);
  if (array_send_packet (packet) == 0)
    error ("Couldn't transmit packet\n");
  if (array_get_packet (packet) == 0)
    error ("Couldn't receive packet\n");

  return len;
}

/*
 * array_read_inferior_memory -- read LEN bytes from inferior memory
 *      at MEMADDR.  Put the result at debugger address MYADDR.  Returns
 *      length moved.
 */
static int
array_read_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  int j;
  char buf[20];
  char packet[PBUFSIZ];
  int count;			/* Number of bytes read so far.  */
  unsigned long startaddr;	/* Starting address of this pass.  */
  int len_this_pass;		/* Number of bytes to read in this pass.  */

  debuglogs (1, "array_read_inferior_memory (memaddr=0x%x, myaddr=0x%x, len=%d)", memaddr, myaddr, len);

  /* Note that this code works correctly if startaddr is just less
     than UINT_MAX (well, really CORE_ADDR_MAX if there was such a
     thing).  That is, something like
     array_read_bytes (CORE_ADDR_MAX - 4, foo, 4)
     works--it never adds len To memaddr and gets 0.  */
  /* However, something like
     array_read_bytes (CORE_ADDR_MAX - 3, foo, 4)
     doesn't need to work.  Detect it and give up if there's an attempt
     to do that.  */
  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }

  for (count = 0, startaddr = memaddr; count < len; startaddr += len_this_pass)
    {
      /* Try to align to 16 byte boundry (why?) */
      len_this_pass = 16;
      if ((startaddr % 16) != 0)
	{
	  len_this_pass -= startaddr % 16;
	}
      /* Only transfer bytes we need */
      if (len_this_pass > (len - count))
	{
	  len_this_pass = (len - count);
	}
      /* Fetch the bytes */
      debuglogs (3, "read %d bytes from inferior address %x", len_this_pass,
		 startaddr);
      sprintf (buf, "m%08lx,%04x", startaddr, len_this_pass);
      make_gdb_packet (packet, buf);
      if (array_send_packet (packet) == 0)
	{
	  error ("Couldn't transmit packet\n");
	}
      if (array_get_packet (packet) == 0)
	{
	  error ("Couldn't receive packet\n");
	}
      if (*packet == 0)
	{
	  error ("Got no data in the GDB packet\n");
	}
      /* Pick packet apart and xfer bytes to myaddr */
      debuglogs (4, "array_read_inferior_memory: Got a \"%s\" back\n", packet);
      for (j = 0; j < len_this_pass; j++)
	{
	  /* extract the byte values */
	  myaddr[count++] = from_hex (*(packet + (j * 2))) * 16 + from_hex (*(packet + (j * 2) + 1));
	  debuglogs (5, "myaddr[%d] set to %x\n", count - 1, myaddr[count - 1]);
	}
    }
  return (count);
}

/* Transfer LEN bytes between GDB address MYADDR and target address
   MEMADDR.  If WRITE is non-zero, transfer them to the target,
   otherwise transfer them from the target.  TARGET is unused.

   Returns the number of bytes transferred. */

static int
array_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		   struct mem_attrib *attrib, struct target_ops *target)
{
  if (write)
    return array_write_inferior_memory (memaddr, myaddr, len);
  else
    return array_read_inferior_memory (memaddr, myaddr, len);
}

static void
array_kill (char *args, int from_tty)
{
  return;			/* ignore attempts to kill target system */
}

/* Clean up when a program exits.
   The program actually lives on in the remote processor's RAM, and may be
   run again without a download.  Don't leave it full of breakpoint
   instructions.  */

static void
array_mourn_inferior (void)
{
  remove_breakpoints ();
  generic_mourn_inferior ();	/* Do all the proper things now */
}

#define MAX_ARRAY_BREAKPOINTS 16

static CORE_ADDR breakaddr[MAX_ARRAY_BREAKPOINTS] =
{0};

/*
 * array_insert_breakpoint -- add a breakpoint
 */
static int
array_insert_breakpoint (CORE_ADDR addr, char *shadow)
{
  int i;
  int bp_size = 0;
  CORE_ADDR bp_addr = addr;

  debuglogs (1, "array_insert_breakpoint() addr = 0x%x", addr);
  BREAKPOINT_FROM_PC (&bp_addr, &bp_size);

  for (i = 0; i <= MAX_ARRAY_BREAKPOINTS; i++)
    {
      if (breakaddr[i] == 0)
	{
	  breakaddr[i] = addr;
	  if (sr_get_debug () > 4)
	    printf ("Breakpoint at %s\n", paddr_nz (addr));
	  array_read_inferior_memory (bp_addr, shadow, bp_size);
	  printf_monitor ("b 0x%x\n", addr);
	  expect_prompt (1);
	  return 0;
	}
    }

  fprintf_unfiltered (gdb_stderr, "Too many breakpoints (> 16) for monitor\n");
  return 1;
}

/*
 * _remove_breakpoint -- Tell the monitor to remove a breakpoint
 */
static int
array_remove_breakpoint (CORE_ADDR addr, char *shadow)
{
  int i;

  debuglogs (1, "array_remove_breakpoint() addr = 0x%x", addr);

  for (i = 0; i < MAX_ARRAY_BREAKPOINTS; i++)
    {
      if (breakaddr[i] == addr)
	{
	  breakaddr[i] = 0;
	  /* some monitors remove breakpoints based on the address */
	  printf_monitor ("bd %x\n", i);
	  expect_prompt (1);
	  return 0;
	}
    }
  fprintf_unfiltered (gdb_stderr,
		      "Can't find breakpoint associated with 0x%s\n",
		      paddr_nz (addr));
  return 1;
}

static void
array_stop (void)
{
  debuglogs (1, "array_stop()");
  printf_monitor ("\003");
  expect_prompt (1);
}

/* 
 * array_command -- put a command string, in args, out to MONITOR.
 *      Output from MONITOR is placed on the users terminal until the
 *      expect_prompt is seen. FIXME
 */
static void
monitor_command (char *args, int fromtty)
{
  debuglogs (1, "monitor_command (args=%s)", args);

  if (array_desc == NULL)
    error ("monitor target not open.");

  if (!args)
    error ("Missing command.");

  printf_monitor ("%s\n", args);
  expect_prompt (0);
}

/*
 * make_gdb_packet -- make a GDB packet. The data is always ASCII.
 *       A debug packet whose contents are <data>
 *       is encapsulated for transmission in the form:
 *
 *              $ <data> # CSUM1 CSUM2
 *
 *       <data> must be ASCII alphanumeric and cannot include characters
 *       '$' or '#'.  If <data> starts with two characters followed by
 *       ':', then the existing stubs interpret this as a sequence number.
 *
 *       CSUM1 and CSUM2 are ascii hex representation of an 8-bit 
 *       checksum of <data>, the most significant nibble is sent first.
 *       the hex digits 0-9,a-f are used.
 *
 */
static void
make_gdb_packet (char *buf, char *data)
{
  int i;
  unsigned char csum = 0;
  int cnt;
  char *p;

  debuglogs (3, "make_gdb_packet(%s)\n", data);
  cnt = strlen (data);
  if (cnt > PBUFSIZ)
    error ("make_gdb_packet(): to much data\n");

  /* start with the packet header */
  p = buf;
  *p++ = '$';

  /* calculate the checksum */
  for (i = 0; i < cnt; i++)
    {
      csum += data[i];
      *p++ = data[i];
    }

  /* terminate the data with a '#' */
  *p++ = '#';

  /* add the checksum as two ascii digits */
  *p++ = tohex ((csum >> 4) & 0xf);
  *p++ = tohex (csum & 0xf);
  *p = 0x0;			/* Null terminator on string */
}

/*
 * array_send_packet -- send a GDB packet to the target with error handling. We
 *              get a '+' (ACK) back if the packet is received and the checksum
 *              matches. Otherwise a '-' (NAK) is returned. It returns a 1 for a
 *              successful transmition, or a 0 for a failure.
 */
static int
array_send_packet (char *packet)
{
  int c, retries, i;
  char junk[PBUFSIZ];

  retries = 0;

#if 0
  /* scan the packet to make sure it only contains valid characters.
     this may sound silly, but sometimes a garbled packet will hang
     the target board. We scan the whole thing, then print the error
     message.
   */
  for (i = 0; i < strlen (packet); i++)
    {
      debuglogs (5, "array_send_packet(): Scanning \'%c\'\n", packet[i]);
      /* legit hex numbers or command */
      if ((isxdigit (packet[i])) || (isalpha (packet[i])))
	continue;
      switch (packet[i])
	{
	case '+':		/* ACK */
	case '-':		/* NAK */
	case '#':		/* end of packet */
	case '$':		/* start of packet */
	  continue;
	default:		/* bogus character */
	  retries++;
	  debuglogs (4, "array_send_packet(): Found a non-ascii digit \'%c\' in the packet.\n", packet[i]);
	}
    }
#endif

  if (retries > 0)
    error ("Can't send packet, found %d non-ascii characters", retries);

  /* ok, try to send the packet */
  retries = 0;
  while (retries++ <= 10)
    {
      printf_monitor ("%s", packet);

      /* read until either a timeout occurs (-2) or '+' is read */
      while (retries <= 10)
	{
	  c = readchar (-timeout);
	  debuglogs (3, "Reading a GDB protocol packet... Got a '%c'\n", c);
	  switch (c)
	    {
	    case '+':
	      debuglogs (3, "Got Ack\n");
	      return 1;
	    case SERIAL_TIMEOUT:
	      debuglogs (3, "Timed out reading serial port\n");
	      printf_monitor ("@@");	/* resync with the monitor */
	      expect_prompt (1);	/* See if we get a expect_prompt */
	      break;		/* Retransmit buffer */
	    case '-':
	      debuglogs (3, "Got NAK\n");
	      printf_monitor ("@@");	/* resync with the monitor */
	      expect_prompt (1);	/* See if we get a expect_prompt */
	      break;
	    case '$':
	      /* it's probably an old response, or the echo of our command.
	       * just gobble up the packet and ignore it.
	       */
	      debuglogs (3, "Got a junk packet\n");
	      i = 0;
	      do
		{
		  c = readchar (timeout);
		  junk[i++] = c;
		}
	      while (c != '#');
	      c = readchar (timeout);
	      junk[i++] = c;
	      c = readchar (timeout);
	      junk[i++] = c;
	      junk[i++] = '\0';
	      debuglogs (3, "Reading a junk packet, got a \"%s\"\n", junk);
	      continue;		/* Now, go look for next packet */
	    default:
	      continue;
	    }
	  retries++;
	  debuglogs (3, "Retransmitting packet \"%s\"\n", packet);
	  break;		/* Here to retransmit */
	}
    }				/* outer while */
  return 0;
}

/*
 * array_get_packet -- get a GDB packet from the target. Basically we read till we
 *              see a '#', then check the checksum. It returns a 1 if it's gotten a
 *              packet, or a 0 it the packet wasn't transmitted correctly.
 */
static int
array_get_packet (char *packet)
{
  int c;
  int retries;
  unsigned char csum;
  unsigned char pktcsum;
  char *bp;

  csum = 0;
  bp = packet;

  memset (packet, 1, PBUFSIZ);
  retries = 0;
  while (retries <= 10)
    {
      do
	{
	  c = readchar (timeout);
	  if (c == SERIAL_TIMEOUT)
	    {
	      debuglogs (3, "array_get_packet: got time out from serial port.\n");
	    }
	  debuglogs (3, "Waiting for a '$', got a %c\n", c);
	}
      while (c != '$');

      retries = 0;
      while (retries <= 10)
	{
	  c = readchar (timeout);
	  debuglogs (3, "array_get_packet: got a '%c'\n", c);
	  switch (c)
	    {
	    case SERIAL_TIMEOUT:
	      debuglogs (3, "Timeout in mid-packet, retrying\n");
	      return 0;
	    case '$':
	      debuglogs (3, "Saw new packet start in middle of old one\n");
	      return 0;		/* Start a new packet, count retries */
	    case '#':
	      *bp = '\0';
	      pktcsum = from_hex (readchar (timeout)) << 4;
	      pktcsum |= from_hex (readchar (timeout));
	      if (csum == 0)
		debuglogs (3, "\nGDB packet checksum zero, must be a bogus packet\n");
	      if (csum == pktcsum)
		{
		  debuglogs (3, "\nGDB packet checksum correct, packet data is \"%s\",\n", packet);
		  printf_monitor ("@@");
		  expect_prompt (1);
		  return 1;
		}
	      debuglogs (3, "Bad checksum, sentsum=0x%x, csum=0x%x\n", pktcsum, csum);
	      return 0;
	    case '*':		/* Run length encoding */
	      debuglogs (5, "Run length encoding in packet\n");
	      csum += c;
	      c = readchar (timeout);
	      csum += c;
	      c = c - ' ' + 3;	/* Compute repeat count */

	      if (c > 0 && c < 255 && bp + c - 1 < packet + PBUFSIZ - 1)
		{
		  memset (bp, *(bp - 1), c);
		  bp += c;
		  continue;
		}
	      *bp = '\0';
	      printf_filtered ("Repeat count %d too large for buffer.\n", c);
	      return 0;

	    default:
	      if ((!isxdigit (c)) && (!ispunct (c)))
		debuglogs (4, "Got a non-ascii digit \'%c\'.\\n", c);
	      if (bp < packet + PBUFSIZ - 1)
		{
		  *bp++ = c;
		  csum += c;
		  continue;
		}

	      *bp = '\0';
	      puts_filtered ("Remote packet too long.\n");
	      return 0;
	    }
	}
    }
  return 0;			/* exceeded retries */
}

/*
 * ascii2hexword -- convert an ascii number represented by 8 digits to a hex value.
 */
static unsigned long
ascii2hexword (unsigned char *mem)
{
  unsigned long val;
  int i;
  char buf[9];

  val = 0;
  for (i = 0; i < 8; i++)
    {
      val <<= 4;
      if (mem[i] >= 'A' && mem[i] <= 'F')
	val = val + mem[i] - 'A' + 10;
      if (mem[i] >= 'a' && mem[i] <= 'f')
	val = val + mem[i] - 'a' + 10;
      if (mem[i] >= '0' && mem[i] <= '9')
	val = val + mem[i] - '0';
      buf[i] = mem[i];
    }
  buf[8] = '\0';
  debuglogs (4, "ascii2hexword() got a 0x%x from %s(%x).\n", val, buf, mem);
  return val;
}

/*
 * ascii2hexword -- convert a hex value to an ascii number represented by 8
 *      digits.
 */
static void
hexword2ascii (unsigned char *mem, unsigned long num)
{
  int i;
  unsigned char ch;

  debuglogs (4, "hexword2ascii() converting %x ", num);
  for (i = 7; i >= 0; i--)
    {
      mem[i] = tohex ((num >> 4) & 0xf);
      mem[i] = tohex (num & 0xf);
      num = num >> 4;
    }
  mem[8] = '\0';
  debuglogs (4, "\tto a %s", mem);
}

/* Convert hex digit A to a number.  */
static int
from_hex (int a)
{
  if (a == 0)
    return 0;

  debuglogs (4, "from_hex got a 0x%x(%c)\n", a, a);
  if (a >= '0' && a <= '9')
    return a - '0';
  if (a >= 'a' && a <= 'f')
    return a - 'a' + 10;
  if (a >= 'A' && a <= 'F')
    return a - 'A' + 10;
  else
    {
      error ("Reply contains invalid hex digit 0x%x", a);
    }
}

/* Convert number NIB to a hex digit.  */
static int
tohex (int nib)
{
  if (nib < 10)
    return '0' + nib;
  else
    return 'a' + nib - 10;
}

/*
 * _initialize_remote_monitors -- setup a few addtitional commands that
 *              are usually only used by monitors.
 */
void
_initialize_remote_monitors (void)
{
  /* generic monitor command */
  add_com ("monitor", class_obscure, monitor_command,
	   "Send a command to the debug monitor.");

}

/*
 * _initialize_array -- do any special init stuff for the target.
 */
void
_initialize_array (void)
{
  init_array_ops ();
  add_target (&array_ops);
}
@


1.22
log
@2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTES): Rename REGISTER_BYTES.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_extract_return_value): Delete reference.
	* TODO (REGISTER_BYTES): Delete reference.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	(ns32k_gdbarch_init_32382): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* sparc-tdep.c (sparc_pop_frame): Update.
	* rs6000-tdep.c (rs6000_pop_frame): Update.
	* remote.c (init_remote_state): Update.
	(remote_prepare_to_store): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	(sds_prepare_to_store): Update.
	* remote-array.c: Update.
	* regcache.c (init_legacy_regcache_descr): Update.
	(init_regcache_descr): Update.
	* mips-tdep.c (mips_eabi_extract_return_value): Update.
	(mips_o64_extract_return_value): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* irix4-nat.c (fetch_core_registers): Update.
	* i386-tdep.h: Update.
	* hppa-tdep.c (pa_do_registers_info): Update.
	(pa_do_strcat_registers_info): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/sparc/nm-sun4sol2.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-sun4os4.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-nbsd.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/s390/tm-s390.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-mips.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/m68k/tm-sun3.h (DEPRECATED_REGISTER_BYTES): Update.
	(REGISTER_BYTES_OK): Update.
	* config/m68k/nm-sun3.h (CHILD_PREPARE_TO_STORE): Update.
	* config/ia64/tm-ia64.h (DEPRECATED_REGISTER_BYTES): Update.

Index: doc/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	REGISTER_BYTES with DEPRECATED_REGISTER_BYTES.  Fix typo,
	DEPRECATED_REGISTER_SIZE instead of REGISTER_BYTE.

Index: mi/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_setup_architecture_data):
@
text
@@


1.21
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@d83 6
a88 5
/* Having this larger than 400 causes us to be incompatible with m68k-stub.c
   and i386-stub.c.  Normally, no one would notice because it only matters
   for writing large chunks of memory (e.g. in downloads).  Also, this needs
   to be more than 400 if required to hold the registers (see below, where
   we round it up based on REGISTER_BYTES).  */
@


1.20
log
@	* gnu-nat.c (init_gnu_ops): Remove NULL initializations.
	* monitor.c (init_base_monitor_ops): Likewise.
	* ppc-bdm.c (init_bdm_ppc_ops): Likewise.
	* remote-array.c (init_array_ops): Likewise.
	* remote-e7000.c (init_e7000_ops): Likewise.
	* remote-es.c (init_es1800_ops): Likewise.
	(init_es1800_child_ops): Likewise.
	* remote-rdp.c (init_remote_rdp_ops): Likewise.
	* remote-sim.c (init_gdbsim_ops): Likewise.
	* remote-st.c (init_st2000_ops): Likewise.
	* sol-thread.c (init_sol_core_ops): Likewise.
	(init_sol_thread_ops): Likewise.
	* v850ice.c (init_850ice_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
@
text
@d734 1
a734 1
  char *reg = alloca (MAX_REGISTER_RAW_SIZE);
@


1.20.20.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d83 5
a87 6
/* Having this larger than 400 causes us to be incompatible with
   m68k-stub.c and i386-stub.c.  Normally, no one would notice because
   it only matters for writing large chunks of memory (e.g. in
   downloads).  Also, this needs to be more than 400 if required to
   hold the registers (see below, where we round it up based on
   DEPRECATED_REGISTER_BYTES).  */
d734 1
a734 1
  char reg[MAX_REGISTER_SIZE];
@


1.19
log
@2002-04-24  Pierre Muller  <ics.u-strasbg.fr>

	* remote-array.c (printf_monitor, write_monitor,
	array_insert_breakpoint, array_remove_breakpoint ):
	Replace fprintf (stderr,...
	with fprintf_unfiltered (gdb_stderr,....
	* remote-es.c: Likewise.
	* remote-os9k.c: Likewise.
	* remote-st.c: Likewise.
@
text
@a117 3
  array_ops.to_attach = NULL;
  array_ops.to_post_attach = NULL;
  array_ops.to_require_attach = NULL;
a118 1
  array_ops.to_require_detach = NULL;
a120 1
  array_ops.to_post_wait = NULL;
a127 5
  array_ops.to_terminal_init = 0;
  array_ops.to_terminal_inferior = 0;
  array_ops.to_terminal_ours_for_output = 0;
  array_ops.to_terminal_ours = 0;
  array_ops.to_terminal_info = 0;
a128 2
  array_ops.to_load = 0;
  array_ops.to_lookup_symbol = 0;
a129 17
  array_ops.to_post_startup_inferior = NULL;
  array_ops.to_acknowledge_created_inferior = NULL;
  array_ops.to_clone_and_follow_inferior = NULL;
  array_ops.to_post_follow_inferior_by_clone = NULL;
  array_ops.to_insert_fork_catchpoint = NULL;
  array_ops.to_remove_fork_catchpoint = NULL;
  array_ops.to_insert_vfork_catchpoint = NULL;
  array_ops.to_remove_vfork_catchpoint = NULL;
  array_ops.to_has_forked = NULL;
  array_ops.to_has_vforked = NULL;
  array_ops.to_can_follow_vfork_prior_to_exec = NULL;
  array_ops.to_post_follow_vfork = NULL;
  array_ops.to_insert_exec_catchpoint = NULL;
  array_ops.to_remove_exec_catchpoint = NULL;
  array_ops.to_has_execd = NULL;
  array_ops.to_reported_exec_events_per_exec_call = NULL;
  array_ops.to_has_exited = NULL;
a130 5
  array_ops.to_can_run = 0;
  array_ops.to_notice_signals = 0;
  array_ops.to_thread_alive = 0;
  array_ops.to_stop = 0;
  array_ops.to_pid_to_exec_file = NULL;
a131 1
  array_ops.DONT_USE = 0;
a136 2
  array_ops.to_sections = 0;
  array_ops.to_sections_end = 0;
@


1.19.16.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.19.14.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d118 3
d122 1
d125 1
d133 5
d139 2
d142 17
d160 5
d166 1
d172 2
@


1.19.14.2
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d83 5
a87 6
/* Having this larger than 400 causes us to be incompatible with
   m68k-stub.c and i386-stub.c.  Normally, no one would notice because
   it only matters for writing large chunks of memory (e.g. in
   downloads).  Also, this needs to be more than 400 if required to
   hold the registers (see below, where we round it up based on
   DEPRECATED_REGISTER_BYTES).  */
d734 1
a734 1
  char reg[MAX_REGISTER_SIZE];
@


1.19.14.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@@


1.18
log
@Remove ATTRIBUTE_UNUSED.  Update (C).
@
text
@d196 2
a197 1
    fprintf (stderr, "serial_write failed: %s\n", safe_strerror (errno));
d206 2
a207 1
    fprintf (stderr, "serial_write failed: %s\n", safe_strerror (errno));
d1058 1
a1058 1
  fprintf (stderr, "Too many breakpoints (> 16) for monitor\n");
d1083 3
a1085 2
  fprintf (stderr, "Can't find breakpoint associated with 0x%s\n",
	   paddr_nz (addr));
@


1.17
log
@* serial.h (SERIAL_ASYNC): Delete.
(DEPRECATED_SERIAL_FD): Delete.
(SERIAL_DEBUG): Delete.
(SERIAL_DEBUG_P): Delete.
(SERIAL_DRAIN_OUTPUT): Delete.
(SERIAL_FLUSH_OUTPUT): Delete.
(SERIAL_FLUSH_INPUT): Delete.
(SERIAL_SEND_BREAK): Delete.
(SERIAL_RAW): Delete.
(SERIAL_GET_TTY_STATE): Delete.
(SERIAL_SET_TTY_STATE): Delete.
(SERIAL_PRINT_TTY_STATE): Delete.
(SERIAL_NOFLUSH_SET_TTY_STATE): Delete.
(SERIAL_SETBAUDRATE): Delete.
(SERIAL_SETSTOPBITS): Delete.
(SERIAL_CAN_ASYNC_P): Delete.
(SERIAL_IS_ASYNC_P): Delete.
(SERIAL_UN_FDOPEN): Delete.
(SERIAL_READCHAR): Delete.
(SERIAL_CLOSE): Delete.
(SERIAL_FDOPEN): Delete.
(SERIAL_OPEN): Delete.
@
text
@d2 4
a5 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001 Free Software Foundation, Inc.
d28 1
a28 2
   Boston, MA 02111-1307, USA.
 */
d998 1
a998 2
		   struct mem_attrib *attrib ATTRIBUTE_UNUSED,
		   struct target_ops *target ATTRIBUTE_UNUSED)
@


1.16
log
@s/typedef serial_t/struct serial */
@
text
@d194 2
a195 2
  if (SERIAL_WRITE (array_desc, buf, strlen (buf)))
    fprintf (stderr, "SERIAL_WRITE failed: %s\n", safe_strerror (errno));
d203 2
a204 2
  if (SERIAL_WRITE (array_desc, data, len))
    fprintf (stderr, "SERIAL_WRITE failed: %s\n", safe_strerror (errno));
d304 1
a304 1
  c = SERIAL_READCHAR (array_desc, abs (timeout));
d563 1
a563 1
  array_desc = SERIAL_OPEN (dev_name);
d570 1
a570 1
      if (SERIAL_SETBAUDRATE (array_desc, baud_rate))
d572 1
a572 1
	  SERIAL_CLOSE (array_desc);
d577 1
a577 1
  SERIAL_RAW (array_desc);
d619 1
a619 1
  SERIAL_CLOSE (array_desc);
d708 3
a710 3
  tty_desc = SERIAL_FDOPEN (0);
  ttystate = SERIAL_GET_TTY_STATE (tty_desc);
  SERIAL_RAW (tty_desc);
d734 1
a734 1
      c = SERIAL_READCHAR (tty_desc, timeout);
d737 1
a737 1
	  SERIAL_WRITE (array_desc, &c, 1);
d747 1
a747 1
  SERIAL_SET_TTY_STATE (tty_desc, ttystate);
@


1.15
log
@* remote-array.c (SWAP_TARGET_AND_HOST): Delete macro.
(get_hex_word): Don't use HOST_BYTE_ORDER.
(array_fetch_registers): Add variable ``reg''.  Use
store_unsigned_integer to byte-swap the register.  Delete unused
local ``regs''.
@
text
@d93 1
a93 1
serial_t array_desc = NULL;
d697 1
a697 1
  serial_t tty_desc;
@


1.14
log
@Phase 1 of the ptid_t changes.
@
text
@a46 18
#define SWAP_TARGET_AND_HOST(buffer,len) 				\
  do									\
    {									\
      if (TARGET_BYTE_ORDER != HOST_BYTE_ORDER)				\
	{								\
	  char tmp;							\
	  char *p = (char *)(buffer);					\
	  char *q = ((char *)(buffer)) + len - 1;		   	\
	  for (; p < q; p++, q--)				 	\
	    {								\
	      tmp = *q;							\
	      *q = *p;							\
	      *p = tmp;							\
	    }								\
	}								\
    }									\
  while (0)

d493 2
a494 14
#if 0
  if (HOST_BYTE_ORDER == BIG_ENDIAN)
    {
#endif
      for (i = 0; i < 8; i++)
	val = (val << 4) + get_hex_digit (i == 0);
#if 0
    }
  else
    {
      for (i = 7; i >= 0; i--)
	val = (val << 4) + get_hex_digit (i == 0);
    }
#endif
d496 1
a496 1
  debuglogs (4, "get_hex_word() got a 0x%x for a %s host.", val, (HOST_BYTE_ORDER == BIG_ENDIAN) ? "big endian" : "little endian");
d768 2
a769 1
  int regno, i;
d771 1
a771 2
  unsigned char packet[PBUFSIZ];
  char regs[REGISTER_BYTES];
a775 2
  /* Unimplemented registers read as all bits zero.  */
  memset (regs, 0, REGISTER_BYTES);
d787 1
a787 1
      i = ascii2hexword (packet + (regno * 8));
d789 2
a790 2
      SWAP_TARGET_AND_HOST (&i, 4);
      supply_register (regno, (char *) &i);
@


1.13
log
@* target.h (target_ops): Removed to_core_file_to_sym_file vector
function.
* corelow.c (core_ops): Updated for above change.
* gnu-nat.c (core_ops): Likewise.
* inftarg.c (child_ops): Likewise.
* monitor.c (monitor_ops): Likewise.
* ppc-bdm.c (bdm_ppc_ops): Likewise.
* remote-adapt.c (adapt_ops): Likewise.
* remote-bug.c (bug_ops): Likewise.
* remote-e7000.c (e7000_ops): Likewise.
* remote-eb.c (eb_ops): Likewise.
* remote-es.c (es1800_ops, es1800_child_ops): Likewise.
* remote-mm.c (mm_ops): Likewise.
* remote-nindy.c (nindy_ops): Likewise.
* remote-nrom.c (nrom_ops): Likewise.
* remote-os9k.c (rombug_ops): Likewise.
* remote-rdp.c (remote_rdp_ops): Likewise.
* remote-sim.c (gdbsim_ops): Likewise.
* remote-st.c (st2000_ops): Likewise.
* v850ice.c (v850ice_ops): Likewise.
* target.c (cleanup_target): Likewise
(update_current_target): Likewise.
(setup_target_debug): Likewise
(debug_to_core_file_to_sym_file): Removed.

* corefile.c (core_file_command) [HPUXHPPA]: Removed code that
sets symbol file from information obtained from the core file.
* corelow.c (core_file_to_sym_file): Removed.
@
text
@d70 1
a70 1
static void array_resume ();
d82 2
a83 1
static int array_wait ();
d701 1
a701 1
array_resume (int pid, int step, enum target_signal sig)
d721 2
a722 2
static int
array_wait (int pid, struct target_waitstatus *status)
d788 1
a788 1
  return 0;
@


1.12
log
@Update/correct copyright notices.
@
text
@a180 1
  array_ops.to_core_file_to_sym_file = NULL;
@


1.11
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 90, 91, 92, 93, 94, 1995, 1998, 2001  Free Software Foundation, Inc.
@


1.10
log
@* ppc-bdm.c (#include <signal.h>): Removed.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-mips.c: Likewise.
* remote-os9k.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
@
text
@d40 1
@


1.9
log
@* monitor.c (#include "gdb_wait.h"): Removed.
* ocd.c: Likewise.
* ppc-bdm.c: Likewise.
* remote-adapt.c: Likewise.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-eb.c: Likewise.
* remote-es.c: Likewise.
* remote-mips.c: Likewise.
* remote-mm.c: Likewise.
* remote-nindy.c: Likewise.
* remote-os9k.c: Likewise.
* remote-rdi.c: Likewise.
* remote-rdp.c: Likewise.
* remote-sds.c: Likewise.
* remote-sim.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
* remote.c: Likewise.
* ser-pipe.c: Likewise.
* ser-unix.c: Likewise.
* Makefile.in: Updated dependencies.
-------------------------------------------------------------------
@
text
@a31 1
#include <signal.h>
@


1.8
log
@* exec.c (xfer_memory): Add attrib argument.
* infptrace.c (child_xfer_memory): Likewise.
* monitor.c (monitor_xfer_memory): Likewise.
* remote-adapt.c (adapt_xfer_inferior_memory): Likewise.
* remote-array.c (array_xfer_memory): Likewise.
* remote-bug.c (bug_xfer_memory): Likewise.
* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
* remote-eb.c (eb_xfer_inferior_memory): Likewise.
* remote-es.c (es1800_xfer_inferior_memory): Likewise.
* remote-mips.c (mips_xfer_memory): Likewise.
* remote-mm.c (mm_xfer_inferior_memory): Likewise.
* remote-nindy.c (nindy_xfer_inferior_memory): Likewise.
* remote-os9k.c (rombug_xfer_inferior_memory): Likewise.
* remote-rdi.c (arm_rdi_xfer_memory): Likewise.
* remote-rdp.c (remote_rdp_xfer_inferior_memory): Likewise.
* remote-sds.c (sds_xfer_memory): Likewise.
* remote-sim.c (gdbsim_xfer_inferior_memory): Likewise.
* remote-st.c (st2000_xfer_inferior_memory): Likewise.
* remote-udi.c (udi_xfer_inferior_memory): Likewise.
* remote-vx.c (vx_xfer_memory): Likewise.
* remote.c (remote_xfer_memory): Likewise.
* target.c (debug_to_xfer_memory, do_xfer_memory): Likewise.
* target.h (child_xfer_memory, do_xfer_memory, xfer_memory): Likewise.

* target.h (#include "memattr.h"): Added.
(target_ops.to_xfer_memory): Add attrib argument.

* wince.c (_initialize_inftarg): Removed call to set_dcache_state.
* dcache.h (set_dcache_state): Removed declaration.
* dcache.c (set_dcache_state): Removed definition

* dcache.c: Update module comment, as dcache is now enabled and
disabled with memory region attributes instead of by the global
variable "remotecache".  Add comment describing the interaction
between dcache and memory region attributes.
(dcache_xfer_memory): Add comment describing benefits of moving
cache writeback to a higher level.
(dcache_struct): Removed cache_has_stuff field.  This was used to
record whether the cache had been accessed in order to invalidate
it when it was disabled.  However, this is not needed because the
cache is write through and the code that enables, disables, and
deletes memory regions invalidate the cache.  Add comment which
suggests that we could be more selective and only invalidate those
cache lines containing data from those memory regions.
(dcache_invalidate): Updated.
(dcache_xfer_memory): Updated.

(dcache_alloc): Don't abort() if dcache_enabled_p is clear.
(dcache_xfer_memory): Removed code that called do_xfer_memory() to
perform a uncached transfer if dcache_enabled_p was clear.  This
function is now only called if caching is enabled for the memory
region.
(dcache_info): Always print cache info.

* target.c (do_xfer_memory): Add attrib argument.
(target_xfer_memory, target_xfer_memory_partial): Break transfer
into chunks defined by memory regions, pass region attributes to
do_xfer_memory().
* dcache.c (dcache_read_line, dcache_write_line): Likewise.

* Makefile.in (SFILES): Add memattr.c.
(COMMON_OBS): Add memattr.o.
(dcache.o): Add target.h to dependencies.
* memattr.c: New file.
* memattr.h: Likewise.
@
text
@a30 1
#include "gdb_wait.h"
@


1.7
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright 90, 91, 92, 93, 94, 1995, 1998  Free Software Foundation, Inc.
d1029 2
a1030 1
		   struct target_ops *target)
@


1.6
log
@* dcache.c (dcache_info): Output a cache line's state vector so it
lines up under the data vector.

* dcache.c (dcache_read_line): New function.
(dcache_peek_byte): Use it.
(dcache_alloc): Return NULL if write of reclaimed cache line fails.
(dcache_peek_byte, dcache_poke_byte): Return failure if
dcache_alloc() returns a NULL data block pointer.
(dcache_xfer_memory): Don't force writeback unless we were writing.

* monitor.c (monitor_expect): Change places where immediate_quit
is set to 1 or 0 to increments and decrements respectively.  This
allows such changes to nest properly.
* ocd.c (ocd_start_remote): Likewise.
* remote-adapt.c (expect): Likewise.
* remote-array.c (expect): Likewise.
* remote-eb.c (expect): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-mips.c (mips_expect_timeout, mips_getstring): Likewise.
* remote-nrom.c (expect): Likewise.
* remote-os9k.c (expect): Likewise.
* remote-sds.c (sds_start_remote): Likewise.
* remote-st.c (expect): Likewise.
* remote-utils.c (sr_expect): Likewise.
* remote.c (remote_start_remote): Likewise.
* tracepoint.c (read_actions): Likewise.

* remote-mips.c (mips_getstring): Balance changes to immediate_quit.
@
text
@d219 1
a219 3
write_monitor (data, len)
     char data[];
     int len;
d1021 6
a1026 1
/* FIXME-someday!  merge these two.  */
d1028 2
a1029 6
array_xfer_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *target;	/* ignored */
@


1.5
log
@Add dummy params where needed.
@
text
@d366 1
a366 1
  immediate_quit = 1;
d376 1
a376 1
	      immediate_quit = 0;
@


1.4
log
@Protoization.
@
text
@d835 1
a835 1
  array_fetch_registers ();
d883 1
a883 1
  array_store_registers ();
@


1.3
log
@PARAMS removal.
@
text
@d320 1
a320 2
readchar (timeout)
     int timeout;
d358 1
a358 3
expect (string, discard)
     char *string;
     int discard;
d407 1
a407 2
expect_prompt (discard)
     int discard;
d416 1
a416 2
junk (ch)
     char ch;
d441 1
a441 2
get_hex_digit (ignore)
     int ignore;
d487 1
a487 2
get_hex_byte (byt)
     char *byt;
d506 1
a506 1
get_hex_word ()
d536 1
a536 4
array_create_inferior (execfile, args, env)
     char *execfile;
     char *args;
     char **env;
d577 1
a577 4
array_open (args, name, from_tty)
     char *args;
     char *name;
     int from_tty;
d649 1
a649 2
array_close (quitting)
     int quitting;
d673 1
a673 2
array_detach (from_tty)
     int from_tty;
d687 1
a687 3
array_attach (args, from_tty)
     char *args;
     int from_tty;
d703 1
a703 3
array_resume (pid, step, sig)
     int pid, step;
     enum target_signal sig;
d724 1
a724 3
array_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d798 1
a798 2
array_fetch_registers (ignored)
     int ignored;
d833 1
a833 2
array_fetch_register (ignored)
     int ignored;
d842 1
a842 2
array_store_registers (ignored)
     int ignored;
d881 1
a881 2
array_store_register (ignored)
     int ignored;
d893 1
a893 1
array_prepare_to_store ()
d899 1
a899 1
array_files_info ()
d910 1
a910 4
array_write_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
d955 1
a955 4
array_read_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d1039 1
a1039 3
array_kill (args, from_tty)
     char *args;
     int from_tty;
d1050 1
a1050 1
array_mourn_inferior ()
d1065 1
a1065 3
array_insert_breakpoint (addr, shadow)
     CORE_ADDR addr;
     char *shadow;
d1096 1
a1096 3
array_remove_breakpoint (addr, shadow)
     CORE_ADDR addr;
     char *shadow;
d1119 1
a1119 1
array_stop ()
d1132 1
a1132 3
monitor_command (args, fromtty)
     char *args;
     int fromtty;
d1163 1
a1163 2
make_gdb_packet (buf, data)
     char *buf, *data;
d1202 1
a1202 2
array_send_packet (packet)
     char *packet;
d1300 1
a1300 2
array_get_packet (packet)
     char *packet;
d1394 1
a1394 2
ascii2hexword (mem)
     unsigned char *mem;
d1422 1
a1422 3
hexword2ascii (mem, num)
     unsigned char *mem;
     unsigned long num;
d1440 1
a1440 2
from_hex (a)
     int a;
d1460 1
a1460 2
tohex (nib)
     int nib;
d1473 1
a1473 1
_initialize_remote_monitors ()
d1485 1
a1485 1
_initialize_array ()
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d65 1
a65 1
static void debuglogs PARAMS ((int, char *,...));
@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
  This file is part of GDB.
d12 14
a25 13
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
d31 1
a31 6
#include "wait.h"
#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif
d40 2
d65 27
a91 29
static void debuglogs PARAMS((int, char *, ...));
static void array_open();
static void array_close();
static void array_detach();
static void array_attach();
static void array_resume();
static void array_fetch_register();
static void array_store_register();
static void array_fetch_registers();
static void array_store_registers();
static void array_prepare_to_store();
static void array_files_info();
static void array_kill();
static void array_create_inferior();
static void array_mourn_inferior();
static void make_gdb_packet();
static int array_xfer_memory();
static int array_wait();
static int array_insert_breakpoint();
static int array_remove_breakpoint();
static int tohex();
static int to_hex();
static int from_hex();
static int array_send_packet();
static int array_get_packet();
static unsigned long ascii2hexword();
static void hexword2ascii();

extern char *version;
d119 1
a119 1
extern int mips_set_processor_type();
d121 1
a121 1
static struct target_ops array_ops ;
d123 2
a124 2
static void 
init_array_ops(void)
d126 2
a127 2
  array_ops.to_shortname =   "array";	
  array_ops.to_longname = 		
d129 1
a129 1
    array_ops.to_doc = 			
d131 5
a135 5
Specify the serial device it is connected to (e.g. /dev/ttya)." ;
  array_ops.to_open =   array_open;	
  array_ops.to_close =   array_close;	
  array_ops.to_attach =   NULL;
  array_ops.to_post_attach = NULL;		
d137 1
a137 1
  array_ops.to_detach =   array_detach;	
d139 2
a140 2
  array_ops.to_resume =   array_resume;	
  array_ops.to_wait  =   array_wait;	
d142 16
a157 16
  array_ops.to_fetch_registers  =   array_fetch_registers;
  array_ops.to_store_registers  =   array_store_registers;
  array_ops.to_prepare_to_store =   array_prepare_to_store;
  array_ops.to_xfer_memory  =   array_xfer_memory;		
  array_ops.to_files_info  =   array_files_info;		
  array_ops.to_insert_breakpoint =   array_insert_breakpoint;	
  array_ops.to_remove_breakpoint =   array_remove_breakpoint;	
  array_ops.to_terminal_init  =   0;				
  array_ops.to_terminal_inferior =   0;				
  array_ops.to_terminal_ours_for_output =   0;			
  array_ops.to_terminal_ours  =   0;				
  array_ops.to_terminal_info  =   0;				
  array_ops.to_kill  =   array_kill;		
  array_ops.to_load  =   0;			
  array_ops.to_lookup_symbol =   0;		
  array_ops.to_create_inferior =   array_create_inferior;	
d160 2
a161 2
  array_ops.to_clone_and_follow_inferior = NULL;          
  array_ops.to_post_follow_inferior_by_clone = NULL;  
d165 1
a165 1
  array_ops.to_remove_vfork_catchpoint = NULL;                      
d167 2
a168 2
  array_ops.to_has_vforked = NULL;            
  array_ops.to_can_follow_vfork_prior_to_exec = NULL;            
d175 5
a179 5
  array_ops.to_mourn_inferior =   array_mourn_inferior;		
  array_ops.to_can_run  =   0;		
  array_ops.to_notice_signals =   0; 	
  array_ops.to_thread_alive  =   0;	
  array_ops.to_stop  =   0;
d181 11
a191 11
  array_ops.to_core_file_to_sym_file = NULL;         
  array_ops.to_stratum =   process_stratum;	
  array_ops.DONT_USE =   0;			
  array_ops.to_has_all_memory =   1;		
  array_ops.to_has_memory =   1;		
  array_ops.to_has_stack =   1;			
  array_ops.to_has_registers =   1;		
  array_ops.to_has_execution =   1;		
  array_ops.to_sections =   0;			
  array_ops.to_sections_end =   0;		
  array_ops.to_magic =   OPS_MAGIC;		
d198 1
a198 6
#ifdef ANSI_PROTOTYPES
printf_monitor(char *pattern, ...)
#else
printf_monitor(va_alist)
     va_dcl
#endif
d204 1
a204 7
#ifdef ANSI_PROTOTYPES
  va_start(args, pattern);
#else
  char *pattern;
  va_start(args);
  pattern = va_arg(args, char *);
#endif
d206 1
a206 1
  vsprintf(buf, pattern, args);
d210 1
a210 1
  if (strlen(buf) > PBUFSIZ)
d212 2
a213 2
  if (SERIAL_WRITE(array_desc, buf, strlen(buf)))
    fprintf(stderr, "SERIAL_WRITE failed: %s\n", safe_strerror(errno));
d219 1
a219 1
write_monitor(data, len)
d223 4
a226 4
  if (SERIAL_WRITE(array_desc, data, len))
    fprintf(stderr, "SERIAL_WRITE failed: %s\n", safe_strerror(errno));
 
  *(data + len+1) = '\0';
d233 3
a235 3
 *	two real args, the first one is the level to be compared against 
 *	the sr_get_debug() value, the second arg is a printf buffer and args
 *	to be formatted and printed. A CR is added after each string is printed.
d238 1
a238 6
#ifdef ANSI_PROTOTYPES
debuglogs(int level, char *pattern, ...)
#else
debuglogs(va_alist)
     va_dcl
#endif
d246 9
a254 9
#ifdef ANSI_PROTOTYPES
  va_start(args, pattern);
#else
  char *pattern;
  int level;
  va_start(args);
  level = va_arg(args, int);			/* get the debug level */
  pattern = va_arg(args, char *);		/* get the printf style pattern */
#endif
a255 7
  if ((level <0) || (level > 100)) {
    error ("Bad argument passed to debuglogs(), needs debug level");
    return;
  }
      
  vsprintf(buf, pattern, args);			/* format the string */
  
d258 42
a299 37
  for (i = 0 ; buf[i] != '\0'; i++) {
    if (i > PBUFSIZ)
      error ("Debug message too long");
    switch (buf[i]) {
    case '\n':					/* newlines */
      *p++ = '\\';
      *p++ = 'n';
      continue;
    case '\r':					/* carriage returns */
      *p++ = '\\';
      *p++ = 'r';
      continue;
    case '\033':				/* escape */
      *p++ = '\\';
      *p++ = 'e';
      continue;
    case '\t':					/* tab */
      *p++ = '\\';
      *p++ = 't';
      continue;
    case '\b':					/* backspace */
      *p++ = '\\';
      *p++ = 'b';
      continue;
    default:					/* no change */
      *p++ = buf[i];
    }

    if (buf[i] < 26) {				/* modify control characters */
      *p++ = '^';
      *p++ = buf[i] + 'A';
      continue;
    }
     if (buf[i] >= 128) {			/* modify control characters */
      *p++ = '!';
      *p++ = buf[i] + 'A';
      continue;
d301 1
a301 2
 }
  *p = '\0';					/* terminate the string */
d303 1
a303 1
  if (sr_get_debug() > level)
d306 7
a312 6
#ifdef LOG_FILE					/* write to the monitor log */
  if (log_file != 0x0) {
    fputs (newbuf, log_file);
    fputc ('\n', log_file);
    fflush (log_file);
  }
d317 1
a317 1
 *	timeout stuff.
d320 1
a320 1
readchar(timeout)
d325 1
a325 1
  c = SERIAL_READCHAR(array_desc, abs(timeout));
d327 5
a331 4
  if (sr_get_debug() > 5) {
    putchar(c & 0x7f);
    debuglogs (5, "readchar: timeout = %d\n", timeout);
  }
d335 1
a335 1
    putc(c & 0x7f, log_file);
d341 5
a345 4
  if (c == SERIAL_TIMEOUT) {
    if (timeout <= 0)
      return c;		/* Polls shouldn't generate timeout errors */
    error("Timeout reading from remote system.");
d349 2
a350 2
  }
  perror_with_name("readchar");
d355 2
a356 2
 *	If DISCARD is non-zero, then discard non-matching input, else print
 *	it out. Let the user break out immediately.
d370 22
a391 15
  while (1) {
    c = readchar(timeout);
    if (!isascii (c))
      continue;
    if (c == *p++) {
      if (*p == '\0') {
	immediate_quit = 0;
	debuglogs (4, "Matched");
	return;
      }
    } else {
      if (!discard) {
	fputc_unfiltered (c, gdb_stdout);
      }
      p = string;
a392 1
  }
d410 1
a410 1
expect_prompt(discard)
d420 1
a420 1
junk(ch)
d423 16
a438 15
  switch (ch) {
  case '\0':
  case ' ':
  case '-':
  case '\t':
  case '\r':
  case '\n':
    if (sr_get_debug() > 5)
      debuglogs (5, "Ignoring \'%c\'.", ch);
    return 1;
  default:
    if (sr_get_debug() > 5)
      debuglogs (5, "Accepting \'%c\'.", ch);
    return 0;
  }
d443 1
a443 1
 *		If ignore is nonzero, ignore spaces, newline & tabs.
d446 1
a446 1
get_hex_digit(ignore)
d450 19
a468 14
  while (1) {
    ch = readchar(timeout);
    if (junk(ch))
      continue;
    if (sr_get_debug() > 4) {
      debuglogs (4, "get_hex_digit() got a 0x%x(%c)", ch, ch);
    } else {
#ifdef LOG_FILE					/* write to the monitor log */
      if (log_file != 0x0) {
	fputs ("get_hex_digit() got a 0x", log_file);
	fputc (ch, log_file);
	fputc ('\n', log_file);
	fflush (log_file);
      }
d470 1
a470 1
    }
d472 14
a485 12
    if (ch >= '0' && ch <= '9')
      return ch - '0';
    else if (ch >= 'A' && ch <= 'F')
      return ch - 'A' + 10;
    else if (ch >= 'a' && ch <= 'f')
      return ch - 'a' + 10;
    else if (ch == ' ' && ignore)
      ;
    else {
     expect_prompt(1);
      debuglogs (4, "Invalid hex digit from remote system. (0x%x)", ch);
      error("Invalid hex digit from remote system. (0x%x)", ch);
a486 1
  }
d490 1
a490 1
 *	Accept any number leading spaces.
d500 1
a500 1
 
d504 1
a504 1
  
d510 1
a510 1
 *	and put them in registers starting at REGNO.
d521 2
a522 1
  if (HOST_BYTE_ORDER == BIG_ENDIAN) {
d524 2
a525 2
    for (i = 0; i < 8; i++)
      val = (val << 4) + get_hex_digit (i == 0);
d527 6
a532 4
  } else {
    for (i = 7; i >= 0; i--)
      val = (val << 4) + get_hex_digit (i == 0);
  }
d551 1
a551 1
    error("Can't pass arguments to remote MONITOR process");
d554 1
a554 1
    error("No executable file specified");
d576 1
a576 1
  proceed ((CORE_ADDR)entry_pt, TARGET_SIGNAL_DEFAULT, 0);
d581 1
a581 1
 *	NAME is the filename used for communication.
d587 1
a587 1
array_open(args, name, from_tty)
d599 1
a599 1
    array_close(0);
d607 2
a608 2
  strcpy(dev_name, args);
  array_desc = SERIAL_OPEN(dev_name);
d611 10
a620 1
    perror_with_name(dev_name);
d622 1
a622 8
  if (baud_rate != -1) {
    if (SERIAL_SETBAUDRATE (array_desc, baud_rate)) {
      SERIAL_CLOSE (array_desc);
      perror_with_name (name);
    }
  }
  
  SERIAL_RAW(array_desc);
d628 1
a628 1
  fprintf (log_file, "GDB %s (%s", version);
d637 7
a643 7
     */
    debuglogs (3, "Trying to ACK the target's debug stub");
    /* unless your are on the new hardware, the old board won't initialize
       because the '@@' doesn't flush output like it does on the new ROMS.
     */
    printf_monitor ("@@");	/* ask for the last signal */
    expect_prompt(1);		/* See if we get a expect_prompt */
d645 5
a649 5
    make_gdb_packet (packet, "?");	/* ask for a bogus packet */
    if (array_send_packet (packet) == 0)
      error ("Couldn't transmit packet\n");
    printf_monitor ("@@\n");	/* force it to flush stdout */
   expect_prompt(1);		/* See if we get a expect_prompt */
d653 1
a653 1
    printf("Remote target %s connected to %s\n", array_ops.to_shortname, dev_name);
d658 1
a658 1
 *	target loses control.
d665 1
a665 1
  SERIAL_CLOSE(array_desc);
d671 7
a677 6
  if (log_file) {
    if (ferror(log_file))
      printf_filtered ("Error writing log file.\n");
    if (fclose(log_file) != 0)
      printf_filtered ("Error closing log file.\n");
  }
d683 2
a684 2
 *	debugger. Use this when you want to detach and do something
 *	else with your gdb.
d693 1
a693 1
  pop_target();		/* calls array_close to do the real work */
d708 1
a708 1
 
d710 1
a710 1
  
d715 1
a715 1
  
d726 8
a733 5
  if (step) {
    printf_monitor ("s\n");
  } else {
    printf_monitor ("go\n");
  }
d753 2
a754 2
  debuglogs(1, "array_wait (), printing extraneous text.");
  
d758 2
a759 2
  timeout = 0;		/* Don't time out -- user program is running. */
 
d767 27
a793 20
  while (1) {
    c = readchar(timeout);
    if (c > 0) {
      if (c == *(ARRAY_PROMPT + i)) {
	if (++i >= strlen (ARRAY_PROMPT)) { /* matched the prompt */
	  debuglogs (4, "array_wait(), got the expect_prompt.");
	  break;
	}
      } else {		/* not the prompt */
	i = 0;
      }
      fputc_unfiltered (c, gdb_stdout);
      gdb_flush (gdb_stdout);
    }
    c = SERIAL_READCHAR(tty_desc, timeout);
    if (c > 0) {
      SERIAL_WRITE(array_desc, &c, 1);
      /* do this so it looks like there's keyboard echo */
      if (c == 3)		/* exit on Control-C */
	break;
d795 2
a796 2
      fputc_unfiltered (c, gdb_stdout);
      gdb_flush (gdb_stdout);
d798 1
a799 1
  }
d802 1
a802 1
  expect_prompt(1);
d816 1
a816 1
 *	block regs.
d836 1
a836 1
    error ("Couldn't receive packet\n");  
d839 9
a847 8
  for (regno = 0; regno <= PC_REGNUM+4; regno++) {
    /* supply register stores in target byte order, so swap here */
    /* FIXME: convert from ASCII hex to raw bytes */
    i = ascii2hexword (packet + (regno * 8));
    debuglogs (5, "Adding register %d = %x\n", regno, i);
    SWAP_TARGET_AND_HOST (&i, 4);
    supply_register (regno, (char *)&i);
  }
d873 1
a873 1
  
d882 8
a889 7
  for (regno = 0; regno < 41; regno++) { /* FIXME */
    /* supply register stores in target byte order, so swap here */
    /* FIXME: convert from ASCII hex to raw bytes */
    i = (unsigned long)read_register (regno);
    hexword2ascii (num, i);
    strcpy (buf+(regno * 8)+1, num);
  }
d895 2
a896 2
    error ("Couldn't receive packet\n");  
  
d932 1
a932 1
 *	memory at MYADDR to inferior's memory at MEMADDR.  Returns length moved.
d946 1
a946 1
  
d948 1
a948 1
  memset (buf, '\0', PBUFSIZ);		/* this also sets the string terminator */
d951 1
a951 1
  *p++ = 'M';				/* The command to write memory */
d953 1
a953 1
  strcpy (p, num);			/* copy the address */
d955 2
a956 2
  *p++ = ',';				/* add comma delimeter */
  hexword2ascii (num, len);		/* Get the length as a 4 digit number */
d961 7
a967 6
  *p++ = ':';				/* add the colon delimeter */
  for (j = 0; j < len; j++) {		/* copy the data in after converting it */
    *p++ = tohex ((myaddr[j] >> 4) & 0xf);
    *p++ = tohex  (myaddr[j] & 0xf);
  }
  
d972 1
a972 1
    error ("Couldn't receive packet\n");  
d979 2
a980 2
 *	at MEMADDR.  Put the result at debugger address MYADDR.  Returns
 *	length moved.
d983 1
a983 1
array_read_inferior_memory(memaddr, myaddr, len)
d1006 6
a1011 5
  if (((memaddr - 1) + len) < memaddr) {
    errno = EIO;
    return 0;
  }
  
d1028 1
a1028 1
      sprintf (buf, "m%08x,%04x", startaddr, len_this_pass);
d1036 1
a1036 1
	  error ("Couldn't receive packet\n");  
d1044 1
a1044 1
      for (j = 0; j < len_this_pass ; j++)
d1047 2
a1048 2
	  myaddr[count++] = from_hex (*(packet+(j*2))) * 16 + from_hex (*(packet+(j*2)+1));
	  debuglogs (5, "myaddr[%d] set to %x\n", count-1, myaddr[count-1]);
d1061 1
a1061 1
     struct target_ops *target;		/* ignored */
d1074 1
a1074 1
  return;		/* ignore attempts to kill target system */
d1091 2
a1092 1
static CORE_ADDR breakaddr[MAX_ARRAY_BREAKPOINTS] = {0};
d1109 12
a1120 9
  for (i = 0; i <= MAX_ARRAY_BREAKPOINTS; i++) {
    if (breakaddr[i] == 0) {
      breakaddr[i] = addr;
      if (sr_get_debug() > 4)
	printf ("Breakpoint at %x\n", addr);
      array_read_inferior_memory (bp_addr, shadow, bp_size);
      printf_monitor("b 0x%x\n", addr);
      expect_prompt(1);
      return 0;
a1121 1
  }
d1123 1
a1123 1
  fprintf(stderr, "Too many breakpoints (> 16) for monitor\n");
d1139 10
a1148 7
  for (i = 0; i < MAX_ARRAY_BREAKPOINTS; i++) {
    if (breakaddr[i] == addr) {
      breakaddr[i] = 0;
      /* some monitors remove breakpoints based on the address */
      printf_monitor("bd %x\n", i);
      expect_prompt(1);
      return 0;
d1150 2
a1151 2
  }
  fprintf(stderr, "Can't find breakpoint associated with 0x%x\n", addr);
d1159 2
a1160 2
  printf_monitor("\003");
 expect_prompt(1);
d1165 2
a1166 2
 *	Output from MONITOR is placed on the users terminal until the
 *	expect_prompt is seen. FIXME
d1170 2
a1171 2
     char	*args;
     int	fromtty;
d1176 1
a1176 1
    error("monitor target not open.");
d1179 2
a1180 2
    error("Missing command.");
	
d1182 1
a1182 1
  expect_prompt(0);
d1187 2
a1188 2
 *	 A debug packet whose contents are <data>
 *	 is encapsulated for transmission in the form:
d1190 1
a1190 1
 *		$ <data> # CSUM1 CSUM2
d1211 1
a1211 1
  cnt  = strlen (data);
d1220 5
a1224 4
  for (i = 0; i < cnt; i++) {
    csum += data[i];
    *p++ = data[i];
  }
d1228 1
a1228 1
  
d1232 1
a1232 1
  *p  = 0x0;			/* Null terminator on string */
d1237 3
a1239 3
 *		get a '+' (ACK) back if the packet is received and the checksum
 *		matches. Otherwise a '-' (NAK) is returned. It returns a 1 for a
 *		successful transmition, or a 0 for a failure.
d1255 18
a1272 15
     */
  for (i = 0; i < strlen(packet); i++) {
    debuglogs (5, "array_send_packet(): Scanning \'%c\'\n", packet[i]);
    /* legit hex numbers or command */
    if ((isxdigit(packet[i])) || (isalpha(packet[i])))
      continue;
    switch (packet[i]) {
    case '+':			/* ACK */
    case '-':			/* NAK */
    case '#':			/* end of packet */
    case '$':			/* start of packet */
      continue;
    default:			/* bogus character */
      retries++;
      debuglogs (4, "array_send_packet(): Found a non-ascii digit \'%c\' in the packet.\n", packet[i]);
d1274 1
a1274 2
  }
#endif  
d1281 51
a1331 46
  while (retries++ <= 10) {
    printf_monitor ("%s", packet);
    
    /* read until either a timeout occurs (-2) or '+' is read */
    while (retries <= 10) {
      c = readchar (-timeout);
      debuglogs (3, "Reading a GDB protocol packet... Got a '%c'\n", c);
      switch (c) {
      case '+':
	debuglogs (3, "Got Ack\n");
	return 1;
      case SERIAL_TIMEOUT:
	debuglogs (3, "Timed out reading serial port\n");
	printf_monitor("@@");		/* resync with the monitor */
       expect_prompt(1);		/* See if we get a expect_prompt */   
	break;            /* Retransmit buffer */
      case '-':
	debuglogs (3, "Got NAK\n");
	printf_monitor("@@");		/* resync with the monitor */
       expect_prompt(1);		/* See if we get a expect_prompt */   
	break;
      case '$':
	/* it's probably an old response, or the echo of our command.
	 * just gobble up the packet and ignore it.
	 */
	debuglogs (3, "Got a junk packet\n");
	i = 0;
	do {
	  c = readchar (timeout);
	  junk[i++] = c;
	} while (c != '#');
	c = readchar (timeout);
	junk[i++] = c;
	c = readchar (timeout);
	junk[i++] = c;
	junk[i++] = '\0';
	debuglogs (3, "Reading a junk packet, got a \"%s\"\n", junk);
	continue;               /* Now, go look for next packet */
      default:
	continue;
      }
      retries++;
      debuglogs (3, "Retransmitting packet \"%s\"\n", packet);
      break;                /* Here to retransmit */
    }
  } /* outer while */
d1337 2
a1338 2
 *		see a '#', then check the checksum. It returns a 1 if it's gotten a
 *		packet, or a 0 it the packet wasn't transmitted correctly.
d1355 10
a1364 45
  while (retries <= 10) {
    do {
      c = readchar (timeout);
      if (c == SERIAL_TIMEOUT) {
	debuglogs (3, "array_get_packet: got time out from serial port.\n");
      }
      debuglogs (3, "Waiting for a '$', got a %c\n", c);
    } while (c != '$');
    
    retries = 0;
    while (retries <= 10) {
      c = readchar (timeout);
      debuglogs (3, "array_get_packet: got a '%c'\n", c);
      switch (c) {
      case SERIAL_TIMEOUT:
	debuglogs (3, "Timeout in mid-packet, retrying\n");
	return 0;
      case '$':
	debuglogs (3, "Saw new packet start in middle of old one\n");
	return 0;             /* Start a new packet, count retries */
      case '#':	
	*bp = '\0';
	pktcsum = from_hex (readchar (timeout)) << 4;
	pktcsum |= from_hex (readchar (timeout));
	if (csum == 0)
	  debuglogs (3, "\nGDB packet checksum zero, must be a bogus packet\n");
	if (csum == pktcsum) {
	  debuglogs (3, "\nGDB packet checksum correct, packet data is \"%s\",\n", packet);
	  printf_monitor ("@@");
	 expect_prompt (1);
	  return 1;
	}
	debuglogs (3, "Bad checksum, sentsum=0x%x, csum=0x%x\n", pktcsum, csum);
	return 0;
      case '*':               /* Run length encoding */
	debuglogs (5, "Run length encoding in packet\n");
	csum += c;
	c = readchar (timeout);
	csum += c;
	c = c - ' ' + 3;      /* Compute repeat count */
	
	if (c > 0 && c < 255 && bp + c - 1 < packet + PBUFSIZ - 1) {
	  memset (bp, *(bp - 1), c);
	  bp += c;
	  continue;
d1366 61
a1426 11
	*bp = '\0';
	printf_filtered ("Repeat count %d too large for buffer.\n", c);
	return 0;
	
      default:
	if ((!isxdigit(c)) && (!ispunct(c)))
	  debuglogs (4, "Got a non-ascii digit \'%c\'.\\n", c);
	if (bp < packet + PBUFSIZ - 1) {
	  *bp++ = c;
	  csum += c;
	  continue;
a1427 5
	
	*bp = '\0';
	puts_filtered ("Remote packet too long.\n");
	return 0;
      }
d1429 1
a1429 2
  }
  return 0; /* exceeded retries */
d1444 11
a1454 10
  for (i = 0; i < 8; i++) {
    val <<= 4;
    if (mem[i] >= 'A' && mem[i] <= 'F')
      val = val + mem[i] - 'A' + 10;      
    if (mem[i] >= 'a' && mem[i] <= 'f')
      val = val + mem[i] - 'a' + 10;
    if (mem[i] >= '0' && mem[i] <= '9')
      val = val + mem[i] - '0';
    buf[i] = mem[i];
  }
d1462 1
a1462 1
 *	digits.
d1471 1
a1471 1
  
d1473 6
a1478 5
  for (i = 7; i >= 0; i--) {    
    mem[i] = tohex ((num >> 4) & 0xf);
    mem[i] = tohex (num & 0xf);
    num = num >> 4;
  }
d1487 1
a1487 1
{  
d1491 1
a1491 1
  debuglogs (4, "from_hex got a 0x%x(%c)\n",a,a);
d1498 4
a1501 3
  else {
    error ("Reply contains invalid hex digit 0x%x", a);
  }
d1510 1
a1510 1
    return '0'+nib;
d1512 1
a1512 1
    return 'a'+nib-10;
d1517 1
a1517 1
 *		are usually only used by monitors.
d1524 1
a1524 1
	   "Send a command to the debug monitor."); 
d1534 1
a1534 1
  init_array_ops() ;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d10 1
a10 1
   This file is part of GDB.
d12 13
a24 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.
d67 27
a93 27
static void debuglogs PARAMS ((int, char *,...));
static void array_open ();
static void array_close ();
static void array_detach ();
static void array_attach ();
static void array_resume ();
static void array_fetch_register ();
static void array_store_register ();
static void array_fetch_registers ();
static void array_store_registers ();
static void array_prepare_to_store ();
static void array_files_info ();
static void array_kill ();
static void array_create_inferior ();
static void array_mourn_inferior ();
static void make_gdb_packet ();
static int array_xfer_memory ();
static int array_wait ();
static int array_insert_breakpoint ();
static int array_remove_breakpoint ();
static int tohex ();
static int to_hex ();
static int from_hex ();
static int array_send_packet ();
static int array_get_packet ();
static unsigned long ascii2hexword ();
static void hexword2ascii ();
d123 1
a123 1
extern int mips_set_processor_type ();
d125 1
a125 1
static struct target_ops array_ops;
d127 2
a128 2
static void
init_array_ops (void)
d130 2
a131 2
  array_ops.to_shortname = "array";
  array_ops.to_longname =
d133 1
a133 1
    array_ops.to_doc =
d135 5
a139 5
Specify the serial device it is connected to (e.g. /dev/ttya).";
  array_ops.to_open = array_open;
  array_ops.to_close = array_close;
  array_ops.to_attach = NULL;
  array_ops.to_post_attach = NULL;
d141 1
a141 1
  array_ops.to_detach = array_detach;
d143 2
a144 2
  array_ops.to_resume = array_resume;
  array_ops.to_wait = array_wait;
d146 16
a161 16
  array_ops.to_fetch_registers = array_fetch_registers;
  array_ops.to_store_registers = array_store_registers;
  array_ops.to_prepare_to_store = array_prepare_to_store;
  array_ops.to_xfer_memory = array_xfer_memory;
  array_ops.to_files_info = array_files_info;
  array_ops.to_insert_breakpoint = array_insert_breakpoint;
  array_ops.to_remove_breakpoint = array_remove_breakpoint;
  array_ops.to_terminal_init = 0;
  array_ops.to_terminal_inferior = 0;
  array_ops.to_terminal_ours_for_output = 0;
  array_ops.to_terminal_ours = 0;
  array_ops.to_terminal_info = 0;
  array_ops.to_kill = array_kill;
  array_ops.to_load = 0;
  array_ops.to_lookup_symbol = 0;
  array_ops.to_create_inferior = array_create_inferior;
d164 2
a165 2
  array_ops.to_clone_and_follow_inferior = NULL;
  array_ops.to_post_follow_inferior_by_clone = NULL;
d169 1
a169 1
  array_ops.to_remove_vfork_catchpoint = NULL;
d171 2
a172 2
  array_ops.to_has_vforked = NULL;
  array_ops.to_can_follow_vfork_prior_to_exec = NULL;
d179 5
a183 5
  array_ops.to_mourn_inferior = array_mourn_inferior;
  array_ops.to_can_run = 0;
  array_ops.to_notice_signals = 0;
  array_ops.to_thread_alive = 0;
  array_ops.to_stop = 0;
d185 11
a195 11
  array_ops.to_core_file_to_sym_file = NULL;
  array_ops.to_stratum = process_stratum;
  array_ops.DONT_USE = 0;
  array_ops.to_has_all_memory = 1;
  array_ops.to_has_memory = 1;
  array_ops.to_has_stack = 1;
  array_ops.to_has_registers = 1;
  array_ops.to_has_execution = 1;
  array_ops.to_sections = 0;
  array_ops.to_sections_end = 0;
  array_ops.to_magic = OPS_MAGIC;
d203 1
a203 1
printf_monitor (char *pattern,...)
d205 1
a205 1
printf_monitor (va_alist)
d214 1
a214 1
  va_start (args, pattern);
d217 2
a218 2
  va_start (args);
  pattern = va_arg (args, char *);
d221 1
a221 1
  vsprintf (buf, pattern, args);
d225 1
a225 1
  if (strlen (buf) > PBUFSIZ)
d227 2
a228 2
  if (SERIAL_WRITE (array_desc, buf, strlen (buf)))
    fprintf (stderr, "SERIAL_WRITE failed: %s\n", safe_strerror (errno));
d234 1
a234 1
write_monitor (data, len)
d238 4
a241 4
  if (SERIAL_WRITE (array_desc, data, len))
    fprintf (stderr, "SERIAL_WRITE failed: %s\n", safe_strerror (errno));

  *(data + len + 1) = '\0';
d248 3
a250 3
 *      two real args, the first one is the level to be compared against 
 *      the sr_get_debug() value, the second arg is a printf buffer and args
 *      to be formatted and printed. A CR is added after each string is printed.
d254 1
a254 1
debuglogs (int level, char *pattern,...)
d256 1
a256 1
debuglogs (va_alist)
d267 1
a267 1
  va_start (args, pattern);
d271 3
a273 3
  va_start (args);
  level = va_arg (args, int);	/* get the debug level */
  pattern = va_arg (args, char *);	/* get the printf style pattern */
d276 7
a282 8
  if ((level < 0) || (level > 100))
    {
      error ("Bad argument passed to debuglogs(), needs debug level");
      return;
    }

  vsprintf (buf, pattern, args);	/* format the string */

d285 37
a321 42
  for (i = 0; buf[i] != '\0'; i++)
    {
      if (i > PBUFSIZ)
	error ("Debug message too long");
      switch (buf[i])
	{
	case '\n':		/* newlines */
	  *p++ = '\\';
	  *p++ = 'n';
	  continue;
	case '\r':		/* carriage returns */
	  *p++ = '\\';
	  *p++ = 'r';
	  continue;
	case '\033':		/* escape */
	  *p++ = '\\';
	  *p++ = 'e';
	  continue;
	case '\t':		/* tab */
	  *p++ = '\\';
	  *p++ = 't';
	  continue;
	case '\b':		/* backspace */
	  *p++ = '\\';
	  *p++ = 'b';
	  continue;
	default:		/* no change */
	  *p++ = buf[i];
	}

      if (buf[i] < 26)
	{			/* modify control characters */
	  *p++ = '^';
	  *p++ = buf[i] + 'A';
	  continue;
	}
      if (buf[i] >= 128)
	{			/* modify control characters */
	  *p++ = '!';
	  *p++ = buf[i] + 'A';
	  continue;
	}
d323 2
a324 1
  *p = '\0';			/* terminate the string */
d326 1
a326 1
  if (sr_get_debug () > level)
d329 6
a334 7
#ifdef LOG_FILE			/* write to the monitor log */
  if (log_file != 0x0)
    {
      fputs (newbuf, log_file);
      fputc ('\n', log_file);
      fflush (log_file);
    }
d339 1
a339 1
 *    timeout stuff.
d342 1
a342 1
readchar (timeout)
d347 1
a347 1
  c = SERIAL_READCHAR (array_desc, abs (timeout));
d349 4
a352 5
  if (sr_get_debug () > 5)
    {
      putchar (c & 0x7f);
      debuglogs (5, "readchar: timeout = %d\n", timeout);
    }
d356 1
a356 1
    putc (c & 0x7f, log_file);
d362 4
a365 5
  if (c == SERIAL_TIMEOUT)
    {
      if (timeout <= 0)
	return c;		/* Polls shouldn't generate timeout errors */
      error ("Timeout reading from remote system.");
d369 2
a370 2
    }
  perror_with_name ("readchar");
d375 2
a376 2
 *      If DISCARD is non-zero, then discard non-matching input, else print
 *      it out. Let the user break out immediately.
d390 15
a404 22
  while (1)
    {
      c = readchar (timeout);
      if (!isascii (c))
	continue;
      if (c == *p++)
	{
	  if (*p == '\0')
	    {
	      immediate_quit = 0;
	      debuglogs (4, "Matched");
	      return;
	    }
	}
      else
	{
	  if (!discard)
	    {
	      fputc_unfiltered (c, gdb_stdout);
	    }
	  p = string;
	}
d406 1
d424 1
a424 1
expect_prompt (discard)
d434 1
a434 1
junk (ch)
d437 15
a451 16
  switch (ch)
    {
    case '\0':
    case ' ':
    case '-':
    case '\t':
    case '\r':
    case '\n':
      if (sr_get_debug () > 5)
	debuglogs (5, "Ignoring \'%c\'.", ch);
      return 1;
    default:
      if (sr_get_debug () > 5)
	debuglogs (5, "Accepting \'%c\'.", ch);
      return 0;
    }
d456 1
a456 1
 *              If ignore is nonzero, ignore spaces, newline & tabs.
d459 1
a459 1
get_hex_digit (ignore)
d463 14
a476 19
  while (1)
    {
      ch = readchar (timeout);
      if (junk (ch))
	continue;
      if (sr_get_debug () > 4)
	{
	  debuglogs (4, "get_hex_digit() got a 0x%x(%c)", ch, ch);
	}
      else
	{
#ifdef LOG_FILE			/* write to the monitor log */
	  if (log_file != 0x0)
	    {
	      fputs ("get_hex_digit() got a 0x", log_file);
	      fputc (ch, log_file);
	      fputc ('\n', log_file);
	      fflush (log_file);
	    }
d478 1
a478 1
	}
d480 12
a491 14
      if (ch >= '0' && ch <= '9')
	return ch - '0';
      else if (ch >= 'A' && ch <= 'F')
	return ch - 'A' + 10;
      else if (ch >= 'a' && ch <= 'f')
	return ch - 'a' + 10;
      else if (ch == ' ' && ignore)
	;
      else
	{
	  expect_prompt (1);
	  debuglogs (4, "Invalid hex digit from remote system. (0x%x)", ch);
	  error ("Invalid hex digit from remote system. (0x%x)", ch);
	}
d493 1
d497 1
a497 1
 *    Accept any number leading spaces.
d507 1
a507 1

d511 1
a511 1

d517 1
a517 1
 *      and put them in registers starting at REGNO.
d528 1
a528 2
  if (HOST_BYTE_ORDER == BIG_ENDIAN)
    {
d530 2
a531 2
      for (i = 0; i < 8; i++)
	val = (val << 4) + get_hex_digit (i == 0);
d533 4
a536 6
    }
  else
    {
      for (i = 7; i >= 0; i--)
	val = (val << 4) + get_hex_digit (i == 0);
    }
d555 1
a555 1
    error ("Can't pass arguments to remote MONITOR process");
d558 1
a558 1
    error ("No executable file specified");
d580 1
a580 1
  proceed ((CORE_ADDR) entry_pt, TARGET_SIGNAL_DEFAULT, 0);
d585 1
a585 1
 *      NAME is the filename used for communication.
d591 1
a591 1
array_open (args, name, from_tty)
d603 1
a603 1
  array_close (0);
d611 2
a612 2
  strcpy (dev_name, args);
  array_desc = SERIAL_OPEN (dev_name);
d615 1
a615 1
    perror_with_name (dev_name);
d617 8
a624 10
  if (baud_rate != -1)
    {
      if (SERIAL_SETBAUDRATE (array_desc, baud_rate))
	{
	  SERIAL_CLOSE (array_desc);
	  perror_with_name (name);
	}
    }

  SERIAL_RAW (array_desc);
d639 7
a645 7
   */
  debuglogs (3, "Trying to ACK the target's debug stub");
  /* unless your are on the new hardware, the old board won't initialize
     because the '@@' doesn't flush output like it does on the new ROMS.
   */
  printf_monitor ("@@");		/* ask for the last signal */
  expect_prompt (1);		/* See if we get a expect_prompt */
d647 5
a651 5
  make_gdb_packet (packet, "?");	/* ask for a bogus packet */
  if (array_send_packet (packet) == 0)
    error ("Couldn't transmit packet\n");
  printf_monitor ("@@\n");	/* force it to flush stdout */
  expect_prompt (1);		/* See if we get a expect_prompt */
d655 1
a655 1
    printf ("Remote target %s connected to %s\n", array_ops.to_shortname, dev_name);
d660 1
a660 1
 *      target loses control.
d667 1
a667 1
  SERIAL_CLOSE (array_desc);
d673 6
a678 7
  if (log_file)
    {
      if (ferror (log_file))
	printf_filtered ("Error writing log file.\n");
      if (fclose (log_file) != 0)
	printf_filtered ("Error closing log file.\n");
    }
d684 2
a685 2
 *      debugger. Use this when you want to detach and do something
 *      else with your gdb.
d694 1
a694 1
  pop_target ();		/* calls array_close to do the real work */
d709 1
a709 1

d711 1
a711 1

d716 1
a716 1

d727 5
a731 8
  if (step)
    {
      printf_monitor ("s\n");
    }
  else
    {
      printf_monitor ("go\n");
    }
d751 2
a752 2
  debuglogs (1, "array_wait (), printing extraneous text.");

d756 2
a757 2
  timeout = 0;			/* Don't time out -- user program is running. */

d765 20
a784 27
  while (1)
    {
      c = readchar (timeout);
      if (c > 0)
	{
	  if (c == *(ARRAY_PROMPT + i))
	    {
	      if (++i >= strlen (ARRAY_PROMPT))
		{		/* matched the prompt */
		  debuglogs (4, "array_wait(), got the expect_prompt.");
		  break;
		}
	    }
	  else
	    {			/* not the prompt */
	      i = 0;
	    }
	  fputc_unfiltered (c, gdb_stdout);
	  gdb_flush (gdb_stdout);
	}
      c = SERIAL_READCHAR (tty_desc, timeout);
      if (c > 0)
	{
	  SERIAL_WRITE (array_desc, &c, 1);
	  /* do this so it looks like there's keyboard echo */
	  if (c == 3)		/* exit on Control-C */
	    break;
d786 2
a787 2
	  fputc_unfiltered (c, gdb_stdout);
	  gdb_flush (gdb_stdout);
a788 1
	}
d790 1
d793 1
a793 1
  expect_prompt (1);
d807 1
a807 1
 *      block regs.
d827 1
a827 1
    error ("Couldn't receive packet\n");
d830 8
a837 9
  for (regno = 0; regno <= PC_REGNUM + 4; regno++)
    {
      /* supply register stores in target byte order, so swap here */
      /* FIXME: convert from ASCII hex to raw bytes */
      i = ascii2hexword (packet + (regno * 8));
      debuglogs (5, "Adding register %d = %x\n", regno, i);
      SWAP_TARGET_AND_HOST (&i, 4);
      supply_register (regno, (char *) &i);
    }
d863 1
a863 1

d872 7
a878 8
  for (regno = 0; regno < 41; regno++)
    {				/* FIXME */
      /* supply register stores in target byte order, so swap here */
      /* FIXME: convert from ASCII hex to raw bytes */
      i = (unsigned long) read_register (regno);
      hexword2ascii (num, i);
      strcpy (buf + (regno * 8) + 1, num);
    }
d884 2
a885 2
    error ("Couldn't receive packet\n");

d921 1
a921 1
 *      memory at MYADDR to inferior's memory at MEMADDR.  Returns length moved.
d935 1
a935 1

d937 1
a937 1
  memset (buf, '\0', PBUFSIZ);	/* this also sets the string terminator */
d940 1
a940 1
  *p++ = 'M';			/* The command to write memory */
d942 1
a942 1
  strcpy (p, num);		/* copy the address */
d944 2
a945 2
  *p++ = ',';			/* add comma delimeter */
  hexword2ascii (num, len);	/* Get the length as a 4 digit number */
d950 6
a955 7
  *p++ = ':';			/* add the colon delimeter */
  for (j = 0; j < len; j++)
    {				/* copy the data in after converting it */
      *p++ = tohex ((myaddr[j] >> 4) & 0xf);
      *p++ = tohex (myaddr[j] & 0xf);
    }

d960 1
a960 1
    error ("Couldn't receive packet\n");
d967 2
a968 2
 *      at MEMADDR.  Put the result at debugger address MYADDR.  Returns
 *      length moved.
d971 1
a971 1
array_read_inferior_memory (memaddr, myaddr, len)
d994 5
a998 6
  if (((memaddr - 1) + len) < memaddr)
    {
      errno = EIO;
      return 0;
    }

d1023 1
a1023 1
	  error ("Couldn't receive packet\n");
d1031 1
a1031 1
      for (j = 0; j < len_this_pass; j++)
d1034 2
a1035 2
	  myaddr[count++] = from_hex (*(packet + (j * 2))) * 16 + from_hex (*(packet + (j * 2) + 1));
	  debuglogs (5, "myaddr[%d] set to %x\n", count - 1, myaddr[count - 1]);
d1048 1
a1048 1
     struct target_ops *target;	/* ignored */
d1061 1
a1061 1
  return;			/* ignore attempts to kill target system */
d1078 1
a1078 2
static CORE_ADDR breakaddr[MAX_ARRAY_BREAKPOINTS] =
{0};
d1095 9
a1103 12
  for (i = 0; i <= MAX_ARRAY_BREAKPOINTS; i++)
    {
      if (breakaddr[i] == 0)
	{
	  breakaddr[i] = addr;
	  if (sr_get_debug () > 4)
	    printf ("Breakpoint at %x\n", addr);
	  array_read_inferior_memory (bp_addr, shadow, bp_size);
	  printf_monitor ("b 0x%x\n", addr);
	  expect_prompt (1);
	  return 0;
	}
d1105 1
d1107 1
a1107 1
  fprintf (stderr, "Too many breakpoints (> 16) for monitor\n");
d1123 7
a1129 10
  for (i = 0; i < MAX_ARRAY_BREAKPOINTS; i++)
    {
      if (breakaddr[i] == addr)
	{
	  breakaddr[i] = 0;
	  /* some monitors remove breakpoints based on the address */
	  printf_monitor ("bd %x\n", i);
	  expect_prompt (1);
	  return 0;
	}
d1131 2
a1132 1
  fprintf (stderr, "Can't find breakpoint associated with 0x%x\n", addr);
d1140 2
a1141 2
  printf_monitor ("\003");
  expect_prompt (1);
d1146 2
a1147 2
 *      Output from MONITOR is placed on the users terminal until the
 *      expect_prompt is seen. FIXME
d1151 2
a1152 2
     char *args;
     int fromtty;
d1157 1
a1157 1
    error ("monitor target not open.");
d1160 2
a1161 2
    error ("Missing command.");

d1163 1
a1163 1
  expect_prompt (0);
d1168 2
a1169 2
 *       A debug packet whose contents are <data>
 *       is encapsulated for transmission in the form:
d1171 1
a1171 1
 *              $ <data> # CSUM1 CSUM2
d1192 1
a1192 1
  cnt = strlen (data);
d1201 4
a1204 5
  for (i = 0; i < cnt; i++)
    {
      csum += data[i];
      *p++ = data[i];
    }
d1208 1
a1208 1

d1212 1
a1212 1
  *p = 0x0;			/* Null terminator on string */
d1217 3
a1219 3
 *              get a '+' (ACK) back if the packet is received and the checksum
 *              matches. Otherwise a '-' (NAK) is returned. It returns a 1 for a
 *              successful transmition, or a 0 for a failure.
d1235 15
a1249 18
   */
  for (i = 0; i < strlen (packet); i++)
    {
      debuglogs (5, "array_send_packet(): Scanning \'%c\'\n", packet[i]);
      /* legit hex numbers or command */
      if ((isxdigit (packet[i])) || (isalpha (packet[i])))
	continue;
      switch (packet[i])
	{
	case '+':		/* ACK */
	case '-':		/* NAK */
	case '#':		/* end of packet */
	case '$':		/* start of packet */
	  continue;
	default:		/* bogus character */
	  retries++;
	  debuglogs (4, "array_send_packet(): Found a non-ascii digit \'%c\' in the packet.\n", packet[i]);
	}
d1251 2
a1252 1
#endif
d1259 46
a1304 51
  while (retries++ <= 10)
    {
      printf_monitor ("%s", packet);

      /* read until either a timeout occurs (-2) or '+' is read */
      while (retries <= 10)
	{
	  c = readchar (-timeout);
	  debuglogs (3, "Reading a GDB protocol packet... Got a '%c'\n", c);
	  switch (c)
	    {
	    case '+':
	      debuglogs (3, "Got Ack\n");
	      return 1;
	    case SERIAL_TIMEOUT:
	      debuglogs (3, "Timed out reading serial port\n");
	      printf_monitor ("@@");	/* resync with the monitor */
	      expect_prompt (1);	/* See if we get a expect_prompt */
	      break;		/* Retransmit buffer */
	    case '-':
	      debuglogs (3, "Got NAK\n");
	      printf_monitor ("@@");	/* resync with the monitor */
	      expect_prompt (1);	/* See if we get a expect_prompt */
	      break;
	    case '$':
	      /* it's probably an old response, or the echo of our command.
	       * just gobble up the packet and ignore it.
	       */
	      debuglogs (3, "Got a junk packet\n");
	      i = 0;
	      do
		{
		  c = readchar (timeout);
		  junk[i++] = c;
		}
	      while (c != '#');
	      c = readchar (timeout);
	      junk[i++] = c;
	      c = readchar (timeout);
	      junk[i++] = c;
	      junk[i++] = '\0';
	      debuglogs (3, "Reading a junk packet, got a \"%s\"\n", junk);
	      continue;		/* Now, go look for next packet */
	    default:
	      continue;
	    }
	  retries++;
	  debuglogs (3, "Retransmitting packet \"%s\"\n", packet);
	  break;		/* Here to retransmit */
	}
    }				/* outer while */
d1310 2
a1311 2
 *              see a '#', then check the checksum. It returns a 1 if it's gotten a
 *              packet, or a 0 it the packet wasn't transmitted correctly.
d1328 45
a1372 10
  while (retries <= 10)
    {
      do
	{
	  c = readchar (timeout);
	  if (c == SERIAL_TIMEOUT)
	    {
	      debuglogs (3, "array_get_packet: got time out from serial port.\n");
	    }
	  debuglogs (3, "Waiting for a '$', got a %c\n", c);
d1374 11
a1384 61
      while (c != '$');

      retries = 0;
      while (retries <= 10)
	{
	  c = readchar (timeout);
	  debuglogs (3, "array_get_packet: got a '%c'\n", c);
	  switch (c)
	    {
	    case SERIAL_TIMEOUT:
	      debuglogs (3, "Timeout in mid-packet, retrying\n");
	      return 0;
	    case '$':
	      debuglogs (3, "Saw new packet start in middle of old one\n");
	      return 0;		/* Start a new packet, count retries */
	    case '#':
	      *bp = '\0';
	      pktcsum = from_hex (readchar (timeout)) << 4;
	      pktcsum |= from_hex (readchar (timeout));
	      if (csum == 0)
		debuglogs (3, "\nGDB packet checksum zero, must be a bogus packet\n");
	      if (csum == pktcsum)
		{
		  debuglogs (3, "\nGDB packet checksum correct, packet data is \"%s\",\n", packet);
		  printf_monitor ("@@");
		  expect_prompt (1);
		  return 1;
		}
	      debuglogs (3, "Bad checksum, sentsum=0x%x, csum=0x%x\n", pktcsum, csum);
	      return 0;
	    case '*':		/* Run length encoding */
	      debuglogs (5, "Run length encoding in packet\n");
	      csum += c;
	      c = readchar (timeout);
	      csum += c;
	      c = c - ' ' + 3;	/* Compute repeat count */

	      if (c > 0 && c < 255 && bp + c - 1 < packet + PBUFSIZ - 1)
		{
		  memset (bp, *(bp - 1), c);
		  bp += c;
		  continue;
		}
	      *bp = '\0';
	      printf_filtered ("Repeat count %d too large for buffer.\n", c);
	      return 0;

	    default:
	      if ((!isxdigit (c)) && (!ispunct (c)))
		debuglogs (4, "Got a non-ascii digit \'%c\'.\\n", c);
	      if (bp < packet + PBUFSIZ - 1)
		{
		  *bp++ = c;
		  csum += c;
		  continue;
		}

	      *bp = '\0';
	      puts_filtered ("Remote packet too long.\n");
	      return 0;
	    }
d1386 5
d1392 2
a1393 1
  return 0;			/* exceeded retries */
d1408 10
a1417 11
  for (i = 0; i < 8; i++)
    {
      val <<= 4;
      if (mem[i] >= 'A' && mem[i] <= 'F')
	val = val + mem[i] - 'A' + 10;
      if (mem[i] >= 'a' && mem[i] <= 'f')
	val = val + mem[i] - 'a' + 10;
      if (mem[i] >= '0' && mem[i] <= '9')
	val = val + mem[i] - '0';
      buf[i] = mem[i];
    }
d1425 1
a1425 1
 *      digits.
d1434 1
a1434 1

d1436 5
a1440 6
  for (i = 7; i >= 0; i--)
    {
      mem[i] = tohex ((num >> 4) & 0xf);
      mem[i] = tohex (num & 0xf);
      num = num >> 4;
    }
d1449 1
a1449 1
{
d1453 1
a1453 1
  debuglogs (4, "from_hex got a 0x%x(%c)\n", a, a);
d1460 3
a1462 4
  else
    {
      error ("Reply contains invalid hex digit 0x%x", a);
    }
d1471 1
a1471 1
    return '0' + nib;
d1473 1
a1473 1
    return 'a' + nib - 10;
d1478 1
a1478 1
 *              are usually only used by monitors.
d1485 1
a1485 1
	   "Send a command to the debug monitor.");
d1495 1
a1495 1
  init_array_ops ();
@


1.1.1.3
log
@import gdb-1999-08-09 snapshot
@
text
@d32 5
d203 1
d205 4
d214 1
d216 5
d254 1
d256 4
d267 1
d269 7
@


1.1.1.4
log
@import gdb-1999-09-08 snapshot
@
text
@a39 2
#include "inferior.h"
#include "version.h"
d91 2
d628 1
a628 1
  fprintf (log_file, "GDB %s (%s", version, host_name);
d1028 1
a1028 1
      sprintf (buf, "m%08lx,%04x", startaddr, len_this_pass);
d1115 1
a1115 1
	    printf ("Breakpoint at %s\n", paddr_nz (addr));
d1150 1
a1150 2
  fprintf (stderr, "Can't find breakpoint associated with 0x%s\n",
	   paddr_nz (addr));
@


