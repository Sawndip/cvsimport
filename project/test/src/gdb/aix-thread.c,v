head	1.90;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.85
	gdb_7_6-2013-04-26-release:1.85
	gdb_7_6-branch:1.85.0.2
	gdb_7_6-2013-03-12-branchpoint:1.85
	gdb_7_5_1-2012-11-29-release:1.82
	gdb_7_5-2012-08-17-release:1.82
	gdb_7_5-branch:1.82.0.2
	gdb_7_5-2012-07-18-branchpoint:1.82
	gdb_7_4_1-2012-04-26-release:1.76.4.1
	gdb_7_4-2012-01-24-release:1.76.4.1
	gdb_7_4-branch:1.76.0.4
	gdb_7_4-2011-12-13-branchpoint:1.76
	gdb_7_3_1-2011-09-04-release:1.76
	gdb_7_3-2011-07-26-release:1.76
	gdb_7_3-branch:1.76.0.2
	gdb_7_3-2011-04-01-branchpoint:1.76
	gdb_7_2-2010-09-02-release:1.72
	gdb_7_2-branch:1.72.0.4
	gdb_7_2-2010-07-07-branchpoint:1.72
	gdb_7_1-2010-03-18-release:1.72
	gdb_7_1-branch:1.72.0.2
	gdb_7_1-2010-02-18-branchpoint:1.72
	gdb_7_0_1-2009-12-22-release:1.70
	gdb_7_0-2009-10-06-release:1.70
	gdb_7_0-branch:1.70.0.2
	gdb_7_0-2009-09-16-branchpoint:1.70
	arc-sim-20090309:1.54.2.1
	msnyder-checkpoint-072509-branch:1.69.0.2
	msnyder-checkpoint-072509-branchpoint:1.69
	arc-insight_6_8-branch:1.54.2.1.0.4
	arc-insight_6_8-branchpoint:1.54.2.1
	insight_6_8-branch:1.54.2.1.0.2
	insight_6_8-branchpoint:1.54.2.1
	reverse-20081226-branch:1.58.0.4
	reverse-20081226-branchpoint:1.58
	multiprocess-20081120-branch:1.58.0.2
	multiprocess-20081120-branchpoint:1.58
	reverse-20080930-branch:1.57.0.6
	reverse-20080930-branchpoint:1.57
	reverse-20080717-branch:1.57.0.4
	reverse-20080717-branchpoint:1.57
	msnyder-reverse-20080609-branch:1.57.0.2
	msnyder-reverse-20080609-branchpoint:1.57
	drow-reverse-20070409-branch:1.43.0.2
	drow-reverse-20070409-branchpoint:1.43
	gdb_6_8-2008-03-27-release:1.54.2.1
	gdb_6_8-branch:1.54.0.2
	gdb_6_8-2008-02-26-branchpoint:1.54
	gdb_6_7_1-2007-10-29-release:1.51
	gdb_6_7-2007-10-10-release:1.51
	gdb_6_7-branch:1.51.0.2
	gdb_6_7-2007-09-07-branchpoint:1.51
	insight_6_6-20070208-release:1.42
	gdb_6_6-2006-12-18-release:1.42
	gdb_6_6-branch:1.42.0.18
	gdb_6_6-2006-11-15-branchpoint:1.42
	insight_6_5-20061003-release:1.42
	gdb-csl-symbian-6_4_50_20060226-12:1.42
	gdb-csl-sourcerygxx-3_4_4-25:1.40
	nickrob-async-20060828-mergepoint:1.42
	gdb-csl-symbian-6_4_50_20060226-11:1.42
	gdb-csl-sourcerygxx-4_1-17:1.42
	gdb-csl-20060226-branch-local-2:1.42
	gdb-csl-sourcerygxx-4_1-14:1.42
	gdb-csl-sourcerygxx-4_1-13:1.42
	gdb-csl-sourcerygxx-4_1-12:1.42
	gdb-csl-sourcerygxx-3_4_4-21:1.42
	gdb_6_5-20060621-release:1.42
	gdb-csl-sourcerygxx-4_1-9:1.42
	gdb-csl-sourcerygxx-4_1-8:1.42
	gdb-csl-sourcerygxx-4_1-7:1.42
	gdb-csl-arm-2006q1-6:1.42
	gdb-csl-sourcerygxx-4_1-6:1.42
	gdb-csl-symbian-6_4_50_20060226-10:1.42
	gdb-csl-symbian-6_4_50_20060226-9:1.42
	gdb-csl-symbian-6_4_50_20060226-8:1.42
	gdb-csl-coldfire-4_1-11:1.42
	gdb-csl-sourcerygxx-3_4_4-19:1.42
	gdb-csl-coldfire-4_1-10:1.42
	gdb_6_5-branch:1.42.0.16
	gdb_6_5-2006-05-14-branchpoint:1.42
	gdb-csl-sourcerygxx-4_1-5:1.42
	nickrob-async-20060513-branch:1.42.0.14
	nickrob-async-20060513-branchpoint:1.42
	gdb-csl-sourcerygxx-4_1-4:1.42
	msnyder-reverse-20060502-branch:1.42.0.12
	msnyder-reverse-20060502-branchpoint:1.42
	gdb-csl-morpho-4_1-4:1.42
	gdb-csl-sourcerygxx-3_4_4-17:1.42
	readline_5_1-import-branch:1.42.0.10
	readline_5_1-import-branchpoint:1.42
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.42
	gdb-csl-symbian-20060226-branch:1.42.0.8
	gdb-csl-symbian-20060226-branchpoint:1.42
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.42
	msnyder-reverse-20060331-branch:1.42.0.6
	msnyder-reverse-20060331-branchpoint:1.42
	gdb-csl-available-20060303-branch:1.42.0.4
	gdb-csl-available-20060303-branchpoint:1.42
	gdb-csl-20060226-branch:1.42.0.2
	gdb-csl-20060226-branchpoint:1.42
	gdb_6_4-20051202-release:1.40
	msnyder-fork-checkpoint-branch:1.40.0.12
	msnyder-fork-checkpoint-branchpoint:1.40
	gdb-csl-gxxpro-6_3-branch:1.40.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.40
	gdb_6_4-branch:1.40.0.8
	gdb_6_4-2005-11-01-branchpoint:1.40
	gdb-csl-arm-20051020-branch:1.40.0.6
	gdb-csl-arm-20051020-branchpoint:1.40
	msnyder-tracepoint-checkpoint-branch:1.40.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.40
	gdb-csl-arm-20050325-2005-q1b:1.40
	gdb-csl-arm-20050325-2005-q1a:1.40
	csl-arm-20050325-branch:1.40.0.2
	csl-arm-20050325-branchpoint:1.40
	gdb-post-i18n-errorwarning-20050211:1.38
	gdb-pre-i18n-errorwarning-20050211:1.38
	gdb_6_3-20041109-release:1.37
	gdb_6_3-branch:1.37.0.2
	gdb_6_3-20041019-branchpoint:1.37
	drow_intercu-merge-20040921:1.35
	drow_intercu-merge-20040915:1.35
	jimb-gdb_6_2-e500-branch:1.29.0.6
	jimb-gdb_6_2-e500-branchpoint:1.29
	gdb_6_2-20040730-release:1.29
	gdb_6_2-branch:1.29.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.29
	gdb_6_1_1-20040616-release:1.15
	gdb_6_1-2004-04-05-release:1.15
	drow_intercu-merge-20040402:1.15
	drow_intercu-merge-20040327:1.15
	ezannoni_pie-20040323-branch:1.15.0.12
	ezannoni_pie-20040323-branchpoint:1.15
	cagney_tramp-20040321-mergepoint:1.15
	cagney_tramp-20040309-branch:1.15.0.10
	cagney_tramp-20040309-branchpoint:1.15
	gdb_6_1-branch:1.15.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.15
	drow_intercu-20040221-branch:1.15.0.6
	drow_intercu-20040221-branchpoint:1.15
	cagney_bfdfile-20040213-branch:1.15.0.4
	cagney_bfdfile-20040213-branchpoint:1.15
	drow-cplus-merge-20040208:1.15
	carlton_dictionary-20040126-merge:1.15
	cagney_bigcore-20040122-branch:1.15.0.2
	cagney_bigcore-20040122-branchpoint:1.15
	drow-cplus-merge-20040113:1.15
	drow-cplus-merge-20031224:1.15
	drow-cplus-merge-20031220:1.15
	carlton_dictionary-20031215-merge:1.15
	drow-cplus-merge-20031214:1.15
	carlton-dictionary-20031111-merge:1.15
	gdb_6_0-2003-10-04-release:1.14
	kettenis_sparc-20030918-branch:1.14.0.50
	kettenis_sparc-20030918-branchpoint:1.14
	carlton_dictionary-20030917-merge:1.14
	ezannoni_pie-20030916-branchpoint:1.14
	ezannoni_pie-20030916-branch:1.14.0.48
	cagney_x86i386-20030821-branch:1.14.0.46
	cagney_x86i386-20030821-branchpoint:1.14
	carlton_dictionary-20030805-merge:1.14
	carlton_dictionary-20030627-merge:1.14
	gdb_6_0-branch:1.14.0.44
	gdb_6_0-2003-06-23-branchpoint:1.14
	jimb-ppc64-linux-20030613-branch:1.14.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.14
	cagney_convert-20030606-branch:1.14.0.40
	cagney_convert-20030606-branchpoint:1.14
	cagney_writestrings-20030508-branch:1.14.0.38
	cagney_writestrings-20030508-branchpoint:1.14
	jimb-ppc64-linux-20030528-branch:1.14.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.14
	carlton_dictionary-20030523-merge:1.14
	cagney_fileio-20030521-branch:1.14.0.34
	cagney_fileio-20030521-branchpoint:1.14
	kettenis_i386newframe-20030517-mergepoint:1.14
	jimb-ppc64-linux-20030509-branch:1.14.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.14
	kettenis_i386newframe-20030504-mergepoint:1.14
	carlton_dictionary-20030430-merge:1.14
	kettenis_i386newframe-20030419-branch:1.14.0.30
	kettenis_i386newframe-20030419-branchpoint:1.14
	carlton_dictionary-20030416-merge:1.14
	cagney_frameaddr-20030409-mergepoint:1.14
	kettenis_i386newframe-20030406-branch:1.14.0.28
	kettenis_i386newframe-20030406-branchpoint:1.14
	cagney_frameaddr-20030403-branchpoint:1.14
	cagney_frameaddr-20030403-branch:1.14.0.26
	cagney_framebase-20030330-mergepoint:1.14
	cagney_framebase-20030326-branch:1.14.0.24
	cagney_framebase-20030326-branchpoint:1.14
	cagney_lazyid-20030317-branch:1.14.0.22
	cagney_lazyid-20030317-branchpoint:1.14
	kettenis-i386newframe-20030316-mergepoint:1.14
	offbyone-20030313-branch:1.14.0.20
	offbyone-20030313-branchpoint:1.14
	kettenis-i386newframe-20030308-branch:1.14.0.18
	kettenis-i386newframe-20030308-branchpoint:1.14
	carlton_dictionary-20030305-merge:1.14
	cagney_offbyone-20030303-branch:1.14.0.16
	cagney_offbyone-20030303-branchpoint:1.14
	carlton_dictionary-20030207-merge:1.14
	interps-20030203-mergepoint:1.14
	interps-20030202-branch:1.14.0.14
	interps-20030202-branchpoint:1.14
	cagney-unwind-20030108-branch:1.14.0.12
	cagney-unwind-20030108-branchpoint:1.14
	carlton_dictionary-20021223-merge:1.14
	gdb_5_3-2002-12-12-release:1.14
	carlton_dictionary-20021115-merge:1.14
	kseitz_interps-20021105-merge:1.14
	kseitz_interps-20021103-merge:1.14
	drow-cplus-merge-20021020:1.14
	drow-cplus-merge-20021025:1.14
	carlton_dictionary-20021025-merge:1.14
	carlton_dictionary-20021011-merge:1.14
	drow-cplus-branch:1.14.0.10
	drow-cplus-branchpoint:1.14
	kseitz_interps-20020930-merge:1.14
	carlton_dictionary-20020927-merge:1.14
	carlton_dictionary-branch:1.14.0.8
	carlton_dictionary-20020920-branchpoint:1.14
	gdb_5_3-branch:1.14.0.6
	gdb_5_3-2002-09-04-branchpoint:1.14
	kseitz_interps-20020829-merge:1.14
	cagney_sysregs-20020825-branch:1.14.0.4
	cagney_sysregs-20020825-branchpoint:1.14
	readline_4_3-import-branch:1.14.0.2
	readline_4_3-import-branchpoint:1.14
	kseitz_interps-20020528-branch:1.8.0.2;
locks; strict;
comment	@ * @;


1.90
date	2013.10.04.08.56.09;	author brobecke;	state Exp;
branches;
next	1.89;

1.89
date	2013.10.04.08.52.24;	author brobecke;	state Exp;
branches;
next	1.88;

1.88
date	2013.09.30.11.50.10;	author luisgpm;	state Exp;
branches;
next	1.87;

1.87
date	2013.08.07.13.24.26;	author uweigand;	state Exp;
branches;
next	1.86;

1.86
date	2013.08.05.16.54.27;	author tromey;	state Exp;
branches;
next	1.85;

1.85
date	2013.01.01.06.32.37;	author brobecke;	state Exp;
branches;
next	1.84;

1.84
date	2012.12.06.04.57.09;	author brobecke;	state Exp;
branches;
next	1.83;

1.83
date	2012.11.09.19.57.57;	author tromey;	state Exp;
branches;
next	1.82;

1.82
date	2012.05.24.16.51.34;	author palves;	state Exp;
branches;
next	1.81;

1.81
date	2012.05.24.16.39.06;	author palves;	state Exp;
branches;
next	1.80;

1.80
date	2012.03.13.22.29.45;	author brobecke;	state Exp;
branches;
next	1.79;

1.79
date	2012.03.13.22.27.12;	author brobecke;	state Exp;
branches;
next	1.78;

1.78
date	2012.03.12.15.57.19;	author brobecke;	state Exp;
branches;
next	1.77;

1.77
date	2012.01.04.08.16.55;	author brobecke;	state Exp;
branches;
next	1.76;

1.76
date	2011.03.17.13.19.08;	author brobecke;	state Exp;
branches
	1.76.4.1;
next	1.75;

1.75
date	2011.01.30.23.16.32;	author qiyao;	state Exp;
branches;
next	1.74;

1.74
date	2011.01.07.19.36.15;	author msnyder;	state Exp;
branches;
next	1.73;

1.73
date	2011.01.01.15.32.56;	author brobecke;	state Exp;
branches;
next	1.72;

1.72
date	2010.01.01.07.31.29;	author brobecke;	state Exp;
branches;
next	1.71;

1.71
date	2009.10.06.21.27.59;	author muller;	state Exp;
branches;
next	1.70;

1.70
date	2009.08.14.00.32.31;	author palves;	state Exp;
branches;
next	1.69;

1.69
date	2009.07.02.17.12.23;	author uweigand;	state Exp;
branches;
next	1.68;

1.68
date	2009.06.17.18.44.23;	author uweigand;	state Exp;
branches;
next	1.67;

1.67
date	2009.05.24.21.06.53;	author devans;	state Exp;
branches;
next	1.66;

1.66
date	2009.05.21.23.19.50;	author palves;	state Exp;
branches;
next	1.65;

1.65
date	2009.05.21.22.33.46;	author brobecke;	state Exp;
branches;
next	1.64;

1.64
date	2009.05.20.18.21.20;	author brobecke;	state Exp;
branches;
next	1.63;

1.63
date	2009.03.15.21.05.41;	author brobecke;	state Exp;
branches;
next	1.62;

1.62
date	2009.03.15.19.38.42;	author brobecke;	state Exp;
branches;
next	1.61;

1.61
date	2009.03.12.17.44.28;	author brobecke;	state Exp;
branches;
next	1.60;

1.60
date	2009.02.06.22.21.26;	author palves;	state Exp;
branches;
next	1.59;

1.59
date	2009.01.03.05.57.50;	author brobecke;	state Exp;
branches;
next	1.58;

1.58
date	2008.11.09.11.27.17;	author vprus;	state Exp;
branches;
next	1.57;

1.57
date	2008.05.04.14.12.33;	author uweigand;	state Exp;
branches;
next	1.56;

1.56
date	2008.03.21.20.06.58;	author brobecke;	state Exp;
branches;
next	1.55;

1.55
date	2008.03.17.19.00.30;	author brobecke;	state Exp;
branches;
next	1.54;

1.54
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2007.11.07.06.53.41;	author deuling;	state Exp;
branches;
next	1.52;

1.52
date	2007.10.08.12.58.04;	author uweigand;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.23.18.08.25;	author brobecke;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.09.13.55.50;	author uweigand;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.11.19.55.19;	author uweigand;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.06.14.34.36;	author uweigand;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.06.14.11.24;	author uweigand;	state Exp;
branches;
next	1.45;

1.45
date	2007.04.27.13.22.18;	author uweigand;	state Exp;
branches;
next	1.44;

1.44
date	2007.04.27.13.17.27;	author uweigand;	state Exp;
branches;
next	1.43;

1.43
date	2007.01.09.17.58.49;	author drow;	state Exp;
branches;
next	1.42;

1.42
date	2006.02.10.19.47.45;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.40;

1.40
date	2005.02.17.13.49.47;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2005.02.14.16.18.38;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.05.15.43.42;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2004.10.08.20.29.45;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2004.10.05.21.53.33;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2004.09.11.10.24.44;	author hilfingr;	state Exp;
branches;
next	1.34;

1.34
date	2004.08.06.16.33.17;	author brobecke;	state Exp;
branches;
next	1.33;

1.33
date	2004.08.03.00.57.25;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2004.07.26.14.52.58;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2004.07.24.01.00.19;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2004.07.22.01.31.48;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.28.23.59.27;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.13.22.55.32;	author brobecke;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.13.22.31.53;	author brobecke;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.13.22.26.38;	author brobecke;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.13.19.36.05;	author jimb;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.13.19.27.07;	author jimb;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.11.04.55.31;	author jimb;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.10.18.58.44;	author jimb;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.10.17.07.02;	author jimb;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.07.20.50.37;	author jimb;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.05.01.46.55;	author jimb;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.04.17.43.52;	author jimb;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.04.17.40.40;	author jimb;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.21.23.52.19;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.02.20.28.28;	author cagney;	state Exp;
branches
	1.15.6.1;
next	1.14;

1.14
date	2002.08.22.15.27.16;	author corinna;	state Exp;
branches
	1.14.8.1
	1.14.10.1;
next	1.13;

1.13
date	2002.07.27.00.06.19;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.26.23.12.59;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.23.01.06.02;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.23.00.34.29;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.22.22.11.03;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.22.19.56.07;	author kevinb;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2002.07.22.19.20.21;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.18.19.26.14;	author msnyder;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.16.00.22.45;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.15.23.33.09;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.15.20.06.12;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.15.18.55.04;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.13.00.29.37;	author kevinb;	state Exp;
branches;
next	;

1.76.4.1
date	2012.01.06.04.43.03;	author brobecke;	state Exp;
branches;
next	;

1.54.2.1
date	2008.03.21.20.09.04;	author brobecke;	state Exp;
branches;
next	;

1.15.6.1
date	2004.09.16.17.00.52;	author drow;	state Exp;
branches;
next	;

1.14.8.1
date	2003.11.11.23.50.37;	author carlton;	state Exp;
branches;
next	;

1.14.10.1
date	2003.12.14.20.27.04;	author drow;	state Exp;
branches;
next	;

1.8.2.1
date	2002.07.22.21.46.55;	author kseitz;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.08.09.18.34.23;	author kseitz;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2002.08.30.22.52.42;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.90
log
@Fix syntax error in aix-thread.c:sync_threadlists

This patch fixes a small typo after the BUILD_THREAD -> ptid_build
conversion.

gdb/ChangeLog:

        * aix-thread.c (sync_threadlists): Add missing ')' in call
        to ptid_build.
@
text
@/* Low level interface for debugging AIX 4.3+ pthreads.

   Copyright (C) 1999-2013 Free Software Foundation, Inc.
   Written by Nick Duffek <nsd@@redhat.com>.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */


/* This module uses the libpthdebug.a library provided by AIX 4.3+ for
   debugging pthread applications.

   Some name prefix conventions:
     pthdb_	provided by libpthdebug.a
     pdc_	callbacks that this module provides to libpthdebug.a
     pd_	variables or functions interfacing with libpthdebug.a

   libpthdebug peculiarities:

     - pthdb_ptid_pthread() is prototyped in <sys/pthdebug.h>, but
       it's not documented, and after several calls it stops working
       and causes other libpthdebug functions to fail.

     - pthdb_tid_pthread() doesn't always work after
       pthdb_session_update(), but it does work after cycling through
       all threads using pthdb_pthread().

     */

#include "defs.h"
#include "gdb_assert.h"
#include "gdbthread.h"
#include "target.h"
#include "inferior.h"
#include "regcache.h"
#include "gdbcmd.h"
#include "ppc-tdep.h"
#include "gdb_string.h"
#include "observer.h"

#include <procinfo.h>
#include <sys/types.h>
#include <sys/ptrace.h>
#include <sys/reg.h>
#include <sched.h>
#include <sys/pthdebug.h>

#if !HAVE_DECL_GETTHRDS
extern int getthrds (pid_t, struct thrdsinfo64 *, int, tid_t *, int);
#endif

/* Whether to emit debugging output.  */
static int debug_aix_thread;

/* In AIX 5.1, functions use pthdb_tid_t instead of tid_t.  */
#ifndef PTHDB_VERSION_3
#define pthdb_tid_t	tid_t
#endif

/* Return whether to treat PID as a debuggable thread id.  */

#define PD_TID(ptid)	(pd_active && ptid_get_tid (ptid) != 0)

/* pthdb_user_t value that we pass to pthdb functions.  0 causes
   PTHDB_BAD_USER errors, so use 1.  */

#define PD_USER	1

/* Success and failure values returned by pthdb callbacks.  */

#define PDC_SUCCESS	PTHDB_SUCCESS
#define PDC_FAILURE	PTHDB_CALLBACK

/* Private data attached to each element in GDB's thread list.  */

struct private_thread_info {
  pthdb_pthread_t pdtid;	 /* thread's libpthdebug id */
  pthdb_tid_t tid;			/* kernel thread id */
};

/* Information about a thread of which libpthdebug is aware.  */

struct pd_thread {
  pthdb_pthread_t pdtid;
  pthread_t pthid;
  pthdb_tid_t tid;
};

/* This module's target-specific operations, active while pd_able is true.  */

static struct target_ops aix_thread_ops;

/* Address of the function that libpthread will call when libpthdebug
   is ready to be initialized.  */

static CORE_ADDR pd_brk_addr;

/* Whether the current application is debuggable by pthdb.  */

static int pd_able = 0;

/* Whether a threaded application is being debugged.  */

static int pd_active = 0;

/* Whether the current architecture is 64-bit.  
   Only valid when pd_able is true.  */

static int arch64;

/* Forward declarations for pthdb callbacks.  */

static int pdc_symbol_addrs (pthdb_user_t, pthdb_symbol_t *, int);
static int pdc_read_data (pthdb_user_t, void *, pthdb_addr_t, size_t);
static int pdc_write_data (pthdb_user_t, void *, pthdb_addr_t, size_t);
static int pdc_read_regs (pthdb_user_t user, pthdb_tid_t tid,
			  unsigned long long flags, 
			  pthdb_context_t *context);
static int pdc_write_regs (pthdb_user_t user, pthdb_tid_t tid,
			   unsigned long long flags, 
			   pthdb_context_t *context);
static int pdc_alloc (pthdb_user_t, size_t, void **);
static int pdc_realloc (pthdb_user_t, void *, size_t, void **);
static int pdc_dealloc (pthdb_user_t, void *);

/* pthdb callbacks.  */

static pthdb_callbacks_t pd_callbacks = {
  pdc_symbol_addrs,
  pdc_read_data,
  pdc_write_data,
  pdc_read_regs,
  pdc_write_regs,
  pdc_alloc,
  pdc_realloc,
  pdc_dealloc,
  NULL
};

/* Current pthdb session.  */

static pthdb_session_t pd_session;

/* Return a printable representation of pthdebug function return
   STATUS.  */

static char *
pd_status2str (int status)
{
  switch (status)
    {
    case PTHDB_SUCCESS:		return "SUCCESS";
    case PTHDB_NOSYS:		return "NOSYS";
    case PTHDB_NOTSUP:		return "NOTSUP";
    case PTHDB_BAD_VERSION:	return "BAD_VERSION";
    case PTHDB_BAD_USER:	return "BAD_USER";
    case PTHDB_BAD_SESSION:	return "BAD_SESSION";
    case PTHDB_BAD_MODE:	return "BAD_MODE";
    case PTHDB_BAD_FLAGS:	return "BAD_FLAGS";
    case PTHDB_BAD_CALLBACK:	return "BAD_CALLBACK";
    case PTHDB_BAD_POINTER:	return "BAD_POINTER";
    case PTHDB_BAD_CMD:		return "BAD_CMD";
    case PTHDB_BAD_PTHREAD:	return "BAD_PTHREAD";
    case PTHDB_BAD_ATTR:	return "BAD_ATTR";
    case PTHDB_BAD_MUTEX:	return "BAD_MUTEX";
    case PTHDB_BAD_MUTEXATTR:	return "BAD_MUTEXATTR";
    case PTHDB_BAD_COND:	return "BAD_COND";
    case PTHDB_BAD_CONDATTR:	return "BAD_CONDATTR";
    case PTHDB_BAD_RWLOCK:	return "BAD_RWLOCK";
    case PTHDB_BAD_RWLOCKATTR:	return "BAD_RWLOCKATTR";
    case PTHDB_BAD_KEY:		return "BAD_KEY";
    case PTHDB_BAD_PTID:	return "BAD_PTID";
    case PTHDB_BAD_TID:		return "BAD_TID";
    case PTHDB_CALLBACK:	return "CALLBACK";
    case PTHDB_CONTEXT:		return "CONTEXT";
    case PTHDB_HELD:		return "HELD";
    case PTHDB_NOT_HELD:	return "NOT_HELD";
    case PTHDB_MEMORY:		return "MEMORY";
    case PTHDB_NOT_PTHREADED:	return "NOT_PTHREADED";
    case PTHDB_SYMBOL:		return "SYMBOL";
    case PTHDB_NOT_AVAIL:	return "NOT_AVAIL";
    case PTHDB_INTERNAL:	return "INTERNAL";
    default:			return "UNKNOWN";
    }
}

/* A call to ptrace(REQ, ID, ...) just returned RET.  Check for
   exceptional conditions and either return nonlocally or else return
   1 for success and 0 for failure.  */

static int
ptrace_check (int req, int id, int ret)
{
  if (ret == 0 && !errno)
    return 1;

  /* According to ptrace(2), ptrace may fail with EPERM if "the
     Identifier parameter corresponds to a kernel thread which is
     stopped in kernel mode and whose computational state cannot be
     read or written."  This happens quite often with register reads.  */

  switch (req)
    {
    case PTT_READ_GPRS:
    case PTT_READ_FPRS:
    case PTT_READ_SPRS:
      if (ret == -1 && errno == EPERM)
	{
	  if (debug_aix_thread)
	    fprintf_unfiltered (gdb_stdlog, 
				"ptrace (%d, %d) = %d (errno = %d)\n",
				req, id, ret, errno);
	  return ret == -1 ? 0 : 1;
	}
      break;
    }
  error (_("aix-thread: ptrace (%d, %d) returned %d (errno = %d %s)"),
	 req, id, ret, errno, safe_strerror (errno));
  return 0;  /* Not reached.  */
}

/* Call ptracex (REQ, ID, ADDR, DATA, BUF) or
   ptrace64 (REQ, ID, ADDR, DATA, BUF) if HAVE_PTRACE64.
   Return success.  */

#ifdef HAVE_PTRACE64
# define ptracex(request, pid, addr, data, buf) \
	 ptrace64 (request, pid, addr, data, buf)
#endif

static int
ptrace64aix (int req, int id, long long addr, int data, int *buf)
{
  errno = 0;
  return ptrace_check (req, id, ptracex (req, id, addr, data, buf));
}

/* Call ptrace (REQ, ID, ADDR, DATA, BUF) or
   ptrace64 (REQ, ID, ADDR, DATA, BUF) if HAVE_PTRACE64.
   Return success.  */

#ifdef HAVE_PTRACE64
# define ptrace(request, pid, addr, data, buf) \
	 ptrace64 (request, pid, addr, data, buf)
# define addr_ptr long long
#else
# define addr_ptr int *
#endif

static int
ptrace32 (int req, int id, addr_ptr addr, int data, int *buf)
{
  errno = 0;
  return ptrace_check (req, id, 
		       ptrace (req, id, addr, data, buf));
}

/* If *PIDP is a composite process/thread id, convert it to a
   process id.  */

static void
pid_to_prc (ptid_t *ptidp)
{
  ptid_t ptid;

  ptid = *ptidp;
  if (PD_TID (ptid))
    *ptidp = pid_to_ptid (ptid_get_pid (ptid));
}

/* pthdb callback: for <i> from 0 to COUNT, set SYMBOLS[<i>].addr to
   the address of SYMBOLS[<i>].name.  */

static int
pdc_symbol_addrs (pthdb_user_t user, pthdb_symbol_t *symbols, int count)
{
  struct minimal_symbol *ms;
  int i;
  char *name;

  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog,
      "pdc_symbol_addrs (user = %ld, symbols = 0x%lx, count = %d)\n",
      user, (long) symbols, count);

  for (i = 0; i < count; i++)
    {
      name = symbols[i].name;
      if (debug_aix_thread)
	fprintf_unfiltered (gdb_stdlog, 
			    "  symbols[%d].name = \"%s\"\n", i, name);

      if (!*name)
	symbols[i].addr = 0;
      else
	{
	  if (!(ms = lookup_minimal_symbol (name, NULL, NULL)))
	    {
	      if (debug_aix_thread)
		fprintf_unfiltered (gdb_stdlog, " returning PDC_FAILURE\n");
	      return PDC_FAILURE;
	    }
	  symbols[i].addr = SYMBOL_VALUE_ADDRESS (ms);
	}
      if (debug_aix_thread)
	fprintf_unfiltered (gdb_stdlog, "  symbols[%d].addr = %s\n",
			    i, hex_string (symbols[i].addr));
    }
  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog, " returning PDC_SUCCESS\n");
  return PDC_SUCCESS;
}

/* Read registers call back function should be able to read the
   context information of a debuggee kernel thread from an active
   process or from a core file.  The information should be formatted
   in context64 form for both 32-bit and 64-bit process.  
   If successful return 0, else non-zero is returned.  */

static int
pdc_read_regs (pthdb_user_t user, 
	       pthdb_tid_t tid,
	       unsigned long long flags,
	       pthdb_context_t *context)
{
  /* This function doesn't appear to be used, so we could probably
   just return 0 here.  HOWEVER, if it is not defined, the OS will
   complain and several thread debug functions will fail.  In case
   this is needed, I have implemented what I think it should do,
   however this code is untested.  */

  uint64_t gprs64[ppc_num_gprs];
  uint32_t gprs32[ppc_num_gprs];
  double fprs[ppc_num_fprs];
  struct ptxsprs sprs64;
  struct ptsprs sprs32;
  
  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog, "pdc_read_regs tid=%d flags=%s\n",
                        (int) tid, hex_string (flags));

  /* General-purpose registers.  */
  if (flags & PTHDB_FLAG_GPRS)
    {
      if (arch64)
	{
	  if (!ptrace64aix (PTT_READ_GPRS, tid, 
			    (unsigned long) gprs64, 0, NULL))
	    memset (gprs64, 0, sizeof (gprs64));
	  memcpy (context->gpr, gprs64, sizeof(gprs64));
	}
      else
	{
	  if (!ptrace32 (PTT_READ_GPRS, tid, gprs32, 0, NULL))
	    memset (gprs32, 0, sizeof (gprs32));
	  memcpy (context->gpr, gprs32, sizeof(gprs32));
	}
    }

  /* Floating-point registers.  */
  if (flags & PTHDB_FLAG_FPRS)
    {
      if (!ptrace32 (PTT_READ_FPRS, tid, (addr_ptr) fprs, 0, NULL))
	memset (fprs, 0, sizeof (fprs));
      memcpy (context->fpr, fprs, sizeof(fprs));
    }

  /* Special-purpose registers.  */
  if (flags & PTHDB_FLAG_SPRS)
    {
      if (arch64)
	{
	  if (!ptrace64aix (PTT_READ_SPRS, tid, 
			    (unsigned long) &sprs64, 0, NULL))
	    memset (&sprs64, 0, sizeof (sprs64));
      	  memcpy (&context->msr, &sprs64, sizeof(sprs64));
	}
      else
	{
	  if (!ptrace32 (PTT_READ_SPRS, tid, (addr_ptr) &sprs32, 0, NULL))
	    memset (&sprs32, 0, sizeof (sprs32));
      	  memcpy (&context->msr, &sprs32, sizeof(sprs32));
	}
    }  
  return 0;
}

/* Write register function should be able to write requested context
   information to specified debuggee's kernel thread id.
   If successful return 0, else non-zero is returned.  */

static int
pdc_write_regs (pthdb_user_t user,
		pthdb_tid_t tid,
		unsigned long long flags,
		pthdb_context_t *context)
{ 
  /* This function doesn't appear to be used, so we could probably
     just return 0 here.  HOWEVER, if it is not defined, the OS will
     complain and several thread debug functions will fail.  In case
     this is needed, I have implemented what I think it should do,
     however this code is untested.  */

  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog, "pdc_write_regs tid=%d flags=%s\n",
                        (int) tid, hex_string (flags));

  /* General-purpose registers.  */
  if (flags & PTHDB_FLAG_GPRS)
    {
      if (arch64)
	ptrace64aix (PTT_WRITE_GPRS, tid, 
		     (unsigned long) context->gpr, 0, NULL);
      else
	ptrace32 (PTT_WRITE_GPRS, tid, (addr_ptr) context->gpr, 0, NULL);
    }

 /* Floating-point registers.  */
  if (flags & PTHDB_FLAG_FPRS)
    {
      ptrace32 (PTT_WRITE_FPRS, tid, (addr_ptr) context->fpr, 0, NULL);
    }

  /* Special-purpose registers.  */
  if (flags & PTHDB_FLAG_SPRS)
    {
      if (arch64)
	{
	  ptrace64aix (PTT_WRITE_SPRS, tid, 
		       (unsigned long) &context->msr, 0, NULL);
	}
      else
	{
	  ptrace32 (PTT_WRITE_SPRS, tid, (addr_ptr) &context->msr, 0, NULL);
	}
    }
  return 0;
}

/* pthdb callback: read LEN bytes from process ADDR into BUF.  */

static int
pdc_read_data (pthdb_user_t user, void *buf, 
	       pthdb_addr_t addr, size_t len)
{
  int status, ret;

  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog,
      "pdc_read_data (user = %ld, buf = 0x%lx, addr = %s, len = %ld)\n",
      user, (long) buf, hex_string (addr), len);

  status = target_read_memory (addr, buf, len);
  ret = status == 0 ? PDC_SUCCESS : PDC_FAILURE;

  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog, "  status=%d, returning %s\n",
			status, pd_status2str (ret));
  return ret;
}

/* pthdb callback: write LEN bytes from BUF to process ADDR.  */

static int
pdc_write_data (pthdb_user_t user, void *buf, 
		pthdb_addr_t addr, size_t len)
{
  int status, ret;

  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog,
      "pdc_write_data (user = %ld, buf = 0x%lx, addr = %s, len = %ld)\n",
      user, (long) buf, hex_string (addr), len);

  status = target_write_memory (addr, buf, len);
  ret = status == 0 ? PDC_SUCCESS : PDC_FAILURE;

  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog, "  status=%d, returning %s\n", status,
			pd_status2str (ret));
  return ret;
}

/* pthdb callback: allocate a LEN-byte buffer and store a pointer to it
   in BUFP.  */

static int
pdc_alloc (pthdb_user_t user, size_t len, void **bufp)
{
  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog,
                        "pdc_alloc (user = %ld, len = %ld, bufp = 0x%lx)\n",
			user, len, (long) bufp);
  *bufp = xmalloc (len);
  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog, 
			"  malloc returned 0x%lx\n", (long) *bufp);

  /* Note: xmalloc() can't return 0; therefore PDC_FAILURE will never
     be returned.  */

  return *bufp ? PDC_SUCCESS : PDC_FAILURE;
}

/* pthdb callback: reallocate BUF, which was allocated by the alloc or
   realloc callback, so that it contains LEN bytes, and store a
   pointer to the result in BUFP.  */

static int
pdc_realloc (pthdb_user_t user, void *buf, size_t len, void **bufp)
{
  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog,
      "pdc_realloc (user = %ld, buf = 0x%lx, len = %ld, bufp = 0x%lx)\n",
      user, (long) buf, len, (long) bufp);
  *bufp = xrealloc (buf, len);
  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog, 
			"  realloc returned 0x%lx\n", (long) *bufp);
  return *bufp ? PDC_SUCCESS : PDC_FAILURE;
}

/* pthdb callback: free BUF, which was allocated by the alloc or
   realloc callback.  */

static int
pdc_dealloc (pthdb_user_t user, void *buf)
{
  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog, 
			"pdc_free (user = %ld, buf = 0x%lx)\n", user,
                        (long) buf);
  xfree (buf);
  return PDC_SUCCESS;
}

/* Return a printable representation of pthread STATE.  */

static char *
state2str (pthdb_state_t state)
{
  switch (state)
    {
    case PST_IDLE:
      /* i18n: Like "Thread-Id %d, [state] idle" */
      return _("idle");      /* being created */
    case PST_RUN:
      /* i18n: Like "Thread-Id %d, [state] running" */
      return _("running");   /* running */
    case PST_SLEEP:
      /* i18n: Like "Thread-Id %d, [state] sleeping" */
      return _("sleeping");  /* awaiting an event */
    case PST_READY:
      /* i18n: Like "Thread-Id %d, [state] ready" */
      return _("ready");     /* runnable */
    case PST_TERM:
      /* i18n: Like "Thread-Id %d, [state] finished" */
      return _("finished");  /* awaiting a join/detach */
    default:
      /* i18n: Like "Thread-Id %d, [state] unknown" */
      return _("unknown");
    }
}

/* qsort() comparison function for sorting pd_thread structs by pthid.  */

static int
pcmp (const void *p1v, const void *p2v)
{
  struct pd_thread *p1 = (struct pd_thread *) p1v;
  struct pd_thread *p2 = (struct pd_thread *) p2v;
  return p1->pthid < p2->pthid ? -1 : p1->pthid > p2->pthid;
}

/* iterate_over_threads() callback for counting GDB threads.

   Do not count the main thread (whose tid is zero).  This matches
   the list of threads provided by the pthreaddebug library, which
   does not include that main thread either, and thus allows us
   to compare the two lists.  */

static int
giter_count (struct thread_info *thread, void *countp)
{
  if (PD_TID (thread->ptid))
    (*(int *) countp)++;
  return 0;
}

/* iterate_over_threads() callback for accumulating GDB thread pids.

   Do not include the main thread (whose tid is zero).  This matches
   the list of threads provided by the pthreaddebug library, which
   does not include that main thread either, and thus allows us
   to compare the two lists.  */

static int
giter_accum (struct thread_info *thread, void *bufp)
{
  if (PD_TID (thread->ptid))
    {
      **(struct thread_info ***) bufp = thread;
      (*(struct thread_info ***) bufp)++;
    }
  return 0;
}

/* ptid comparison function */

static int
ptid_cmp (ptid_t ptid1, ptid_t ptid2)
{
  int pid1, pid2;

  if (ptid_get_pid (ptid1) < ptid_get_pid (ptid2))
    return -1;
  else if (ptid_get_pid (ptid1) > ptid_get_pid (ptid2))
    return 1;
  else if (ptid_get_tid (ptid1) < ptid_get_tid (ptid2))
    return -1;
  else if (ptid_get_tid (ptid1) > ptid_get_tid (ptid2))
    return 1;
  else if (ptid_get_lwp (ptid1) < ptid_get_lwp (ptid2))
    return -1;
  else if (ptid_get_lwp (ptid1) > ptid_get_lwp (ptid2))
    return 1;
  else
    return 0;
}

/* qsort() comparison function for sorting thread_info structs by pid.  */

static int
gcmp (const void *t1v, const void *t2v)
{
  struct thread_info *t1 = *(struct thread_info **) t1v;
  struct thread_info *t2 = *(struct thread_info **) t2v;
  return ptid_cmp (t1->ptid, t2->ptid);
}

/* Search through the list of all kernel threads for the thread
   that has stopped on a SIGTRAP signal, and return its TID.
   Return 0 if none found.  */

static pthdb_tid_t
get_signaled_thread (void)
{
  struct thrdsinfo64 thrinf;
  tid_t ktid = 0;
  int result = 0;

  while (1)
  {
    if (getthrds (ptid_get_pid (inferior_ptid), &thrinf, 
          	  sizeof (thrinf), &ktid, 1) != 1)
      break;

    if (thrinf.ti_cursig == SIGTRAP)
      return thrinf.ti_tid;
  }

  /* Didn't find any thread stopped on a SIGTRAP signal.  */
  return 0;
}

/* Synchronize GDB's thread list with libpthdebug's.

   There are some benefits of doing this every time the inferior stops:

     - allows users to run thread-specific commands without needing to
       run "info threads" first

     - helps pthdb_tid_pthread() work properly (see "libpthdebug
       peculiarities" at the top of this module)

     - simplifies the demands placed on libpthdebug, which seems to
       have difficulty with certain call patterns */

static void
sync_threadlists (void)
{
  int cmd, status, infpid;
  int pcount, psize, pi, gcount, gi;
  struct pd_thread *pbuf;
  struct thread_info **gbuf, **g, *thread;
  pthdb_pthread_t pdtid;
  pthread_t pthid;
  pthdb_tid_t tid;

  /* Accumulate an array of libpthdebug threads sorted by pthread id.  */

  pcount = 0;
  psize = 1;
  pbuf = (struct pd_thread *) xmalloc (psize * sizeof *pbuf);

  for (cmd = PTHDB_LIST_FIRST;; cmd = PTHDB_LIST_NEXT)
    {
      status = pthdb_pthread (pd_session, &pdtid, cmd);
      if (status != PTHDB_SUCCESS || pdtid == PTHDB_INVALID_PTHREAD)
	break;

      status = pthdb_pthread_ptid (pd_session, pdtid, &pthid);
      if (status != PTHDB_SUCCESS || pthid == PTHDB_INVALID_PTID)
	continue;

      if (pcount == psize)
	{
	  psize *= 2;
	  pbuf = (struct pd_thread *) xrealloc (pbuf, 
						psize * sizeof *pbuf);
	}
      pbuf[pcount].pdtid = pdtid;
      pbuf[pcount].pthid = pthid;
      pcount++;
    }

  for (pi = 0; pi < pcount; pi++)
    {
      status = pthdb_pthread_tid (pd_session, pbuf[pi].pdtid, &tid);
      if (status != PTHDB_SUCCESS)
	tid = PTHDB_INVALID_TID;
      pbuf[pi].tid = tid;
    }

  qsort (pbuf, pcount, sizeof *pbuf, pcmp);

  /* Accumulate an array of GDB threads sorted by pid.  */

  gcount = 0;
  iterate_over_threads (giter_count, &gcount);
  g = gbuf = (struct thread_info **) xmalloc (gcount * sizeof *gbuf);
  iterate_over_threads (giter_accum, &g);
  qsort (gbuf, gcount, sizeof *gbuf, gcmp);

  /* Apply differences between the two arrays to GDB's thread list.  */

  infpid = ptid_get_pid (inferior_ptid);
  for (pi = gi = 0; pi < pcount || gi < gcount;)
    {
      if (pi == pcount)
	{
	  delete_thread (gbuf[gi]->ptid);
	  gi++;
	}
      else if (gi == gcount)
	{
	  thread = add_thread (ptid_build (infpid, 0, pbuf[pi].pthid));
	  thread->private = xmalloc (sizeof (struct private_thread_info));
	  thread->private->pdtid = pbuf[pi].pdtid;
	  thread->private->tid = pbuf[pi].tid;
	  pi++;
	}
      else
	{
	  ptid_t pptid, gptid;
	  int cmp_result;

	  pptid = ptid_build (infpid, 0, pbuf[pi].pthid);
	  gptid = gbuf[gi]->ptid;
	  pdtid = pbuf[pi].pdtid;
	  tid = pbuf[pi].tid;

	  cmp_result = ptid_cmp (pptid, gptid);

	  if (cmp_result == 0)
	    {
	      gbuf[gi]->private->pdtid = pdtid;
	      gbuf[gi]->private->tid = tid;
	      pi++;
	      gi++;
	    }
	  else if (cmp_result > 0)
	    {
	      delete_thread (gptid);
	      gi++;
	    }
	  else
	    {
	      thread = add_thread (pptid);
	      thread->private = xmalloc (sizeof (struct private_thread_info));
	      thread->private->pdtid = pdtid;
	      thread->private->tid = tid;
	      pi++;
	    }
	}
    }

  xfree (pbuf);
  xfree (gbuf);
}

/* Iterate_over_threads() callback for locating a thread, using
   the TID of its associated kernel thread.  */

static int
iter_tid (struct thread_info *thread, void *tidp)
{
  const pthdb_tid_t tid = *(pthdb_tid_t *)tidp;

  return (thread->private->tid == tid);
}

/* Synchronize libpthdebug's state with the inferior and with GDB,
   generate a composite process/thread <pid> for the current thread,
   set inferior_ptid to <pid> if SET_INFPID, and return <pid>.  */

static ptid_t
pd_update (int set_infpid)
{
  int status;
  ptid_t ptid;
  pthdb_tid_t tid;
  struct thread_info *thread = NULL;

  if (!pd_active)
    return inferior_ptid;

  status = pthdb_session_update (pd_session);
  if (status != PTHDB_SUCCESS)
    return inferior_ptid;

  sync_threadlists ();

  /* Define "current thread" as one that just received a trap signal.  */

  tid = get_signaled_thread ();
  if (tid != 0)
    thread = iterate_over_threads (iter_tid, &tid);
  if (!thread)
    ptid = inferior_ptid;
  else
    {
      ptid = thread->ptid;
      if (set_infpid)
	inferior_ptid = ptid;
    }
  return ptid;
}

/* Try to start debugging threads in the current process.
   If successful and SET_INFPID, set inferior_ptid to reflect the
   current thread.  */

static ptid_t
pd_activate (int set_infpid)
{
  int status;
		
  status = pthdb_session_init (PD_USER, arch64 ? PEM_64BIT : PEM_32BIT,
			       PTHDB_FLAG_REGS, &pd_callbacks, 
			       &pd_session);
  if (status != PTHDB_SUCCESS)
    {
      return inferior_ptid;
    }
  pd_active = 1;
  return pd_update (set_infpid);
}

/* Undo the effects of pd_activate().  */

static void
pd_deactivate (void)
{
  if (!pd_active)
    return;
  pthdb_session_destroy (pd_session);
  
  pid_to_prc (&inferior_ptid);
  pd_active = 0;
}

/* An object file has just been loaded.  Check whether the current
   application is pthreaded, and if so, prepare for thread debugging.  */

static void
pd_enable (void)
{
  int status;
  char *stub_name;
  struct minimal_symbol *ms;

  /* Don't initialize twice.  */
  if (pd_able)
    return;

  /* Check application word size.  */
  arch64 = register_size (target_gdbarch (), 0) == 8;

  /* Check whether the application is pthreaded.  */
  stub_name = NULL;
  status = pthdb_session_pthreaded (PD_USER, PTHDB_FLAG_REGS,
				    &pd_callbacks, &stub_name);
  if ((status != PTHDB_SUCCESS
       && status != PTHDB_NOT_PTHREADED) || !stub_name)
    return;

  /* Set a breakpoint on the returned stub function.  */
  if (!(ms = lookup_minimal_symbol (stub_name, NULL, NULL)))
    return;
  pd_brk_addr = SYMBOL_VALUE_ADDRESS (ms);
  if (!create_thread_event_breakpoint (target_gdbarch (), pd_brk_addr))
    return;

  /* Prepare for thread debugging.  */
  push_target (&aix_thread_ops);
  pd_able = 1;

  /* If we're debugging a core file or an attached inferior, the
     pthread library may already have been initialized, so try to
     activate thread debugging.  */
  pd_activate (1);
}

/* Undo the effects of pd_enable().  */

static void
pd_disable (void)
{
  if (!pd_able)
    return;
  if (pd_active)
    pd_deactivate ();
  pd_able = 0;
  unpush_target (&aix_thread_ops);
}

/* new_objfile observer callback.

   If OBJFILE is non-null, check whether a threaded application is
   being debugged, and if so, prepare for thread debugging.

   If OBJFILE is null, stop debugging threads.  */

static void
new_objfile (struct objfile *objfile)
{
  if (objfile)
    pd_enable ();
  else
    pd_disable ();
}

/* Attach to process specified by ARGS.  */

static void
aix_thread_attach (struct target_ops *ops, char *args, int from_tty)
{
  struct target_ops *beneath = find_target_beneath (ops);
  
  beneath->to_attach (beneath, args, from_tty);
  pd_activate (1);
}

/* Detach from the process attached to by aix_thread_attach().  */

static void
aix_thread_detach (struct target_ops *ops, char *args, int from_tty)
{
  struct target_ops *beneath = find_target_beneath (ops);

  pd_disable ();
  beneath->to_detach (beneath, args, from_tty);
}

/* Tell the inferior process to continue running thread PID if != -1
   and all threads otherwise.  */

static void
aix_thread_resume (struct target_ops *ops,
                   ptid_t ptid, int step, enum gdb_signal sig)
{
  struct thread_info *thread;
  pthdb_tid_t tid[2];

  if (!PD_TID (ptid))
    {
      struct cleanup *cleanup = save_inferior_ptid ();
      struct target_ops *beneath = find_target_beneath (ops);
      
      inferior_ptid = pid_to_ptid (ptid_get_pid (inferior_ptid));
      beneath->to_resume (beneath, ptid, step, sig);
      do_cleanups (cleanup);
    }
  else
    {
      thread = find_thread_ptid (ptid);
      if (!thread)
	error (_("aix-thread resume: unknown pthread %ld"),
	       ptid_get_lwp (ptid));

      tid[0] = thread->private->tid;
      if (tid[0] == PTHDB_INVALID_TID)
	error (_("aix-thread resume: no tid for pthread %ld"),
	       ptid_get_lwp (ptid));
      tid[1] = 0;

      if (arch64)
	ptrace64aix (PTT_CONTINUE, tid[0], (long long) 1,
		     gdb_signal_to_host (sig), (void *) tid);
      else
	ptrace32 (PTT_CONTINUE, tid[0], (addr_ptr) 1,
		  gdb_signal_to_host (sig), (void *) tid);
    }
}

/* Wait for thread/process ID if != -1 or for any thread otherwise.
   If an error occurs, return -1, else return the pid of the stopped
   thread.  */

static ptid_t
aix_thread_wait (struct target_ops *ops,
		 ptid_t ptid, struct target_waitstatus *status, int options)
{
  struct cleanup *cleanup = save_inferior_ptid ();
  struct target_ops *beneath = find_target_beneath (ops);

  pid_to_prc (&ptid);

  inferior_ptid = pid_to_ptid (ptid_get_pid (inferior_ptid));
  ptid = beneath->to_wait (beneath, ptid, status, options);
  do_cleanups (cleanup);

  if (ptid_get_pid (ptid) == -1)
    return pid_to_ptid (-1);

  /* Check whether libpthdebug might be ready to be initialized.  */
  if (!pd_active && status->kind == TARGET_WAITKIND_STOPPED
      && status->value.sig == GDB_SIGNAL_TRAP)
    {
      struct regcache *regcache = get_thread_regcache (ptid);
      struct gdbarch *gdbarch = get_regcache_arch (regcache);

      if (regcache_read_pc (regcache)
	  - gdbarch_decr_pc_after_break (gdbarch) == pd_brk_addr)
	return pd_activate (0);
    }

  return pd_update (0);
}

/* Record that the 64-bit general-purpose registers contain VALS.  */

static void
supply_gprs64 (struct regcache *regcache, uint64_t *vals)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  int regno;

  for (regno = 0; regno < ppc_num_gprs; regno++)
    regcache_raw_supply (regcache, tdep->ppc_gp0_regnum + regno,
			 (char *) (vals + regno));
}

/* Record that 32-bit register REGNO contains VAL.  */

static void
supply_reg32 (struct regcache *regcache, int regno, uint32_t val)
{
  regcache_raw_supply (regcache, regno, (char *) &val);
}

/* Record that the floating-point registers contain VALS.  */

static void
supply_fprs (struct regcache *regcache, double *vals)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int regno;

  /* This function should never be called on architectures without
     floating-point registers.  */
  gdb_assert (ppc_floating_point_unit_p (gdbarch));

  for (regno = tdep->ppc_fp0_regnum;
       regno < tdep->ppc_fp0_regnum + ppc_num_fprs;
       regno++)
    regcache_raw_supply (regcache, regno,
			 (char *) (vals + regno - tdep->ppc_fp0_regnum));
}

/* Predicate to test whether given register number is a "special" register.  */
static int
special_register_p (struct gdbarch *gdbarch, int regno)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  return regno == gdbarch_pc_regnum (gdbarch)
      || regno == tdep->ppc_ps_regnum
      || regno == tdep->ppc_cr_regnum
      || regno == tdep->ppc_lr_regnum
      || regno == tdep->ppc_ctr_regnum
      || regno == tdep->ppc_xer_regnum
      || (tdep->ppc_fpscr_regnum >= 0 && regno == tdep->ppc_fpscr_regnum)
      || (tdep->ppc_mq_regnum >= 0 && regno == tdep->ppc_mq_regnum);
}


/* Record that the special registers contain the specified 64-bit and
   32-bit values.  */

static void
supply_sprs64 (struct regcache *regcache,
	       uint64_t iar, uint64_t msr, uint32_t cr,
	       uint64_t lr, uint64_t ctr, uint32_t xer,
	       uint32_t fpscr)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  regcache_raw_supply (regcache, gdbarch_pc_regnum (gdbarch),
		       (char *) &iar);
  regcache_raw_supply (regcache, tdep->ppc_ps_regnum, (char *) &msr);
  regcache_raw_supply (regcache, tdep->ppc_cr_regnum, (char *) &cr);
  regcache_raw_supply (regcache, tdep->ppc_lr_regnum, (char *) &lr);
  regcache_raw_supply (regcache, tdep->ppc_ctr_regnum, (char *) &ctr);
  regcache_raw_supply (regcache, tdep->ppc_xer_regnum, (char *) &xer);
  if (tdep->ppc_fpscr_regnum >= 0)
    regcache_raw_supply (regcache, tdep->ppc_fpscr_regnum,
			 (char *) &fpscr);
}

/* Record that the special registers contain the specified 32-bit
   values.  */

static void
supply_sprs32 (struct regcache *regcache,
	       uint32_t iar, uint32_t msr, uint32_t cr,
	       uint32_t lr, uint32_t ctr, uint32_t xer,
	       uint32_t fpscr)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  regcache_raw_supply (regcache, gdbarch_pc_regnum (gdbarch),
		       (char *) &iar);
  regcache_raw_supply (regcache, tdep->ppc_ps_regnum, (char *) &msr);
  regcache_raw_supply (regcache, tdep->ppc_cr_regnum, (char *) &cr);
  regcache_raw_supply (regcache, tdep->ppc_lr_regnum, (char *) &lr);
  regcache_raw_supply (regcache, tdep->ppc_ctr_regnum, (char *) &ctr);
  regcache_raw_supply (regcache, tdep->ppc_xer_regnum, (char *) &xer);
  if (tdep->ppc_fpscr_regnum >= 0)
    regcache_raw_supply (regcache, tdep->ppc_fpscr_regnum,
			 (char *) &fpscr);
}

/* Fetch all registers from pthread PDTID, which doesn't have a kernel
   thread.

   There's no way to query a single register from a non-kernel
   pthread, so there's no need for a single-register version of this
   function.  */

static void
fetch_regs_user_thread (struct regcache *regcache, pthdb_pthread_t pdtid)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int status, i;
  pthdb_context_t ctx;

  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog, 
			"fetch_regs_user_thread %lx\n", (long) pdtid);
  status = pthdb_pthread_context (pd_session, pdtid, &ctx);
  if (status != PTHDB_SUCCESS)
    error (_("aix-thread: fetch_registers: pthdb_pthread_context returned %s"),
           pd_status2str (status));

  /* General-purpose registers.  */

  if (arch64)
    supply_gprs64 (regcache, ctx.gpr);
  else
    for (i = 0; i < ppc_num_gprs; i++)
      supply_reg32 (regcache, tdep->ppc_gp0_regnum + i, ctx.gpr[i]);

  /* Floating-point registers.  */

  if (ppc_floating_point_unit_p (gdbarch))
    supply_fprs (regcache, ctx.fpr);

  /* Special registers.  */

  if (arch64)
    supply_sprs64 (regcache, ctx.iar, ctx.msr, ctx.cr, ctx.lr, ctx.ctr,
			     ctx.xer, ctx.fpscr);
  else
    supply_sprs32 (regcache, ctx.iar, ctx.msr, ctx.cr, ctx.lr, ctx.ctr,
			     ctx.xer, ctx.fpscr);
}

/* Fetch register REGNO if != -1 or all registers otherwise from
   kernel thread TID.

   AIX provides a way to query all of a kernel thread's GPRs, FPRs, or
   SPRs, but there's no way to query individual registers within those
   groups.  Therefore, if REGNO != -1, this function fetches an entire
   group.

   Unfortunately, kernel thread register queries often fail with
   EPERM, indicating that the thread is in kernel space.  This breaks
   backtraces of threads other than the current one.  To make that
   breakage obvious without throwing an error to top level (which is
   bad e.g. during "info threads" output), zero registers that can't
   be retrieved.  */

static void
fetch_regs_kernel_thread (struct regcache *regcache, int regno,
			  pthdb_tid_t tid)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  uint64_t gprs64[ppc_num_gprs];
  uint32_t gprs32[ppc_num_gprs];
  double fprs[ppc_num_fprs];
  struct ptxsprs sprs64;
  struct ptsprs sprs32;
  int i;

  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog,
	"fetch_regs_kernel_thread tid=%lx regno=%d arch64=%d\n",
	(long) tid, regno, arch64);

  /* General-purpose registers.  */
  if (regno == -1
      || (tdep->ppc_gp0_regnum <= regno
          && regno < tdep->ppc_gp0_regnum + ppc_num_gprs))
    {
      if (arch64)
	{
	  if (!ptrace64aix (PTT_READ_GPRS, tid, 
			    (unsigned long) gprs64, 0, NULL))
	    memset (gprs64, 0, sizeof (gprs64));
	  supply_gprs64 (regcache, gprs64);
	}
      else
	{
	  if (!ptrace32 (PTT_READ_GPRS, tid, (addr_ptr) gprs32, 0, NULL))
	    memset (gprs32, 0, sizeof (gprs32));
	  for (i = 0; i < ppc_num_gprs; i++)
	    supply_reg32 (regcache, tdep->ppc_gp0_regnum + i, gprs32[i]);
	}
    }

  /* Floating-point registers.  */

  if (ppc_floating_point_unit_p (gdbarch)
      && (regno == -1
          || (regno >= tdep->ppc_fp0_regnum
              && regno < tdep->ppc_fp0_regnum + ppc_num_fprs)))
    {
      if (!ptrace32 (PTT_READ_FPRS, tid, (addr_ptr) fprs, 0, NULL))
	memset (fprs, 0, sizeof (fprs));
      supply_fprs (regcache, fprs);
    }

  /* Special-purpose registers.  */

  if (regno == -1 || special_register_p (gdbarch, regno))
    {
      if (arch64)
	{
	  if (!ptrace64aix (PTT_READ_SPRS, tid, 
			    (unsigned long) &sprs64, 0, NULL))
	    memset (&sprs64, 0, sizeof (sprs64));
	  supply_sprs64 (regcache, sprs64.pt_iar, sprs64.pt_msr,
			 sprs64.pt_cr, sprs64.pt_lr, sprs64.pt_ctr,
			 sprs64.pt_xer, sprs64.pt_fpscr);
	}
      else
	{
	  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

	  if (!ptrace32 (PTT_READ_SPRS, tid, (addr_ptr) &sprs32, 0, NULL))
	    memset (&sprs32, 0, sizeof (sprs32));
	  supply_sprs32 (regcache, sprs32.pt_iar, sprs32.pt_msr, sprs32.pt_cr,
			 sprs32.pt_lr, sprs32.pt_ctr, sprs32.pt_xer,
			 sprs32.pt_fpscr);

	  if (tdep->ppc_mq_regnum >= 0)
	    regcache_raw_supply (regcache, tdep->ppc_mq_regnum,
				 (char *) &sprs32.pt_mq);
	}
    }
}

/* Fetch register REGNO if != -1 or all registers otherwise in the
   thread/process specified by inferior_ptid.  */

static void
aix_thread_fetch_registers (struct target_ops *ops,
                            struct regcache *regcache, int regno)
{
  struct thread_info *thread;
  pthdb_tid_t tid;
  struct target_ops *beneath = find_target_beneath (ops);

  if (!PD_TID (inferior_ptid))
    beneath->to_fetch_registers (beneath, regcache, regno);
  else
    {
      thread = find_thread_ptid (inferior_ptid);
      tid = thread->private->tid;

      if (tid == PTHDB_INVALID_TID)
	fetch_regs_user_thread (regcache, thread->private->pdtid);
      else
	fetch_regs_kernel_thread (regcache, regno, tid);
    }
}

/* Store the gp registers into an array of uint32_t or uint64_t.  */

static void
fill_gprs64 (const struct regcache *regcache, uint64_t *vals)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  int regno;

  for (regno = 0; regno < ppc_num_gprs; regno++)
    if (REG_VALID == regcache_register_status (regcache,
					       tdep->ppc_gp0_regnum + regno))
      regcache_raw_collect (regcache, tdep->ppc_gp0_regnum + regno,
			    vals + regno);
}

static void 
fill_gprs32 (const struct regcache *regcache, uint32_t *vals)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  int regno;

  for (regno = 0; regno < ppc_num_gprs; regno++)
    if (REG_VALID == regcache_register_status (regcache,
					       tdep->ppc_gp0_regnum + regno))
      regcache_raw_collect (regcache, tdep->ppc_gp0_regnum + regno,
			    vals + regno);
}

/* Store the floating point registers into a double array.  */
static void
fill_fprs (const struct regcache *regcache, double *vals)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int regno;

  /* This function should never be called on architectures without
     floating-point registers.  */
  gdb_assert (ppc_floating_point_unit_p (gdbarch));

  for (regno = tdep->ppc_fp0_regnum;
       regno < tdep->ppc_fp0_regnum + ppc_num_fprs;
       regno++)
    if (REG_VALID == regcache_register_status (regcache, regno))
      regcache_raw_collect (regcache, regno,
			    vals + regno - tdep->ppc_fp0_regnum);
}

/* Store the special registers into the specified 64-bit and 32-bit
   locations.  */

static void
fill_sprs64 (const struct regcache *regcache,
	     uint64_t *iar, uint64_t *msr, uint32_t *cr,
	     uint64_t *lr, uint64_t *ctr, uint32_t *xer,
	     uint32_t *fpscr)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* Verify that the size of the size of the IAR buffer is the
     same as the raw size of the PC (in the register cache).  If
     they're not, then either GDB has been built incorrectly, or
     there's some other kind of internal error.  To be really safe,
     we should check all of the sizes.   */
  gdb_assert (sizeof (*iar) == register_size
				 (gdbarch, gdbarch_pc_regnum (gdbarch)));

  if (REG_VALID == regcache_register_status (regcache,
					     gdbarch_pc_regnum (gdbarch)))
    regcache_raw_collect (regcache, gdbarch_pc_regnum (gdbarch), iar);
  if (REG_VALID == regcache_register_status (regcache, tdep->ppc_ps_regnum))
    regcache_raw_collect (regcache, tdep->ppc_ps_regnum, msr);
  if (REG_VALID == regcache_register_status (regcache, tdep->ppc_cr_regnum))
    regcache_raw_collect (regcache, tdep->ppc_cr_regnum, cr);
  if (REG_VALID == regcache_register_status (regcache, tdep->ppc_lr_regnum))
    regcache_raw_collect (regcache, tdep->ppc_lr_regnum, lr);
  if (REG_VALID == regcache_register_status (regcache, tdep->ppc_ctr_regnum))
    regcache_raw_collect (regcache, tdep->ppc_ctr_regnum, ctr);
  if (REG_VALID == regcache_register_status (regcache, tdep->ppc_xer_regnum))
    regcache_raw_collect (regcache, tdep->ppc_xer_regnum, xer);
  if (tdep->ppc_fpscr_regnum >= 0
      && REG_VALID == regcache_register_status (regcache,
						tdep->ppc_fpscr_regnum))
    regcache_raw_collect (regcache, tdep->ppc_fpscr_regnum, fpscr);
}

static void
fill_sprs32 (const struct regcache *regcache,
	     uint32_t *iar, uint32_t *msr, uint32_t *cr,
	     uint32_t *lr, uint32_t *ctr, uint32_t *xer,
	     uint32_t *fpscr)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* Verify that the size of the size of the IAR buffer is the
     same as the raw size of the PC (in the register cache).  If
     they're not, then either GDB has been built incorrectly, or
     there's some other kind of internal error.  To be really safe,
     we should check all of the sizes.  */
  gdb_assert (sizeof (*iar) == register_size (gdbarch,
					      gdbarch_pc_regnum (gdbarch)));

  if (REG_VALID == regcache_register_status (regcache,
					     gdbarch_pc_regnum (gdbarch)))
    regcache_raw_collect (regcache, gdbarch_pc_regnum (gdbarch), iar);
  if (REG_VALID == regcache_register_status (regcache, tdep->ppc_ps_regnum))
    regcache_raw_collect (regcache, tdep->ppc_ps_regnum, msr);
  if (REG_VALID == regcache_register_status (regcache, tdep->ppc_cr_regnum))
    regcache_raw_collect (regcache, tdep->ppc_cr_regnum, cr);
  if (REG_VALID == regcache_register_status (regcache, tdep->ppc_lr_regnum))
    regcache_raw_collect (regcache, tdep->ppc_lr_regnum, lr);
  if (REG_VALID == regcache_register_status (regcache, tdep->ppc_ctr_regnum))
    regcache_raw_collect (regcache, tdep->ppc_ctr_regnum, ctr);
  if (REG_VALID == regcache_register_status (regcache, tdep->ppc_xer_regnum))
    regcache_raw_collect (regcache, tdep->ppc_xer_regnum, xer);
  if (tdep->ppc_fpscr_regnum >= 0
      && REG_VALID == regcache_register_status (regcache, tdep->ppc_fpscr_regnum))
    regcache_raw_collect (regcache, tdep->ppc_fpscr_regnum, fpscr);
}

/* Store all registers into pthread PDTID, which doesn't have a kernel
   thread.

   It's possible to store a single register into a non-kernel pthread,
   but I doubt it's worth the effort.  */

static void
store_regs_user_thread (const struct regcache *regcache, pthdb_pthread_t pdtid)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int status, i;
  pthdb_context_t ctx;
  uint32_t int32;
  uint64_t int64;
  double   dbl;

  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog, 
			"store_regs_user_thread %lx\n", (long) pdtid);

  /* Retrieve the thread's current context for its non-register
     values.  */
  status = pthdb_pthread_context (pd_session, pdtid, &ctx);
  if (status != PTHDB_SUCCESS)
    error (_("aix-thread: store_registers: pthdb_pthread_context returned %s"),
           pd_status2str (status));

  /* Collect general-purpose register values from the regcache.  */

  for (i = 0; i < ppc_num_gprs; i++)
    if (REG_VALID == regcache_register_status (regcache,
					       tdep->ppc_gp0_regnum + i))
      {
	if (arch64)
	  {
	    regcache_raw_collect (regcache, tdep->ppc_gp0_regnum + i,
				  (void *) &int64);
	    ctx.gpr[i] = int64;
	  }
	else
	  {
	    regcache_raw_collect (regcache, tdep->ppc_gp0_regnum + i,
				  (void *) &int32);
	    ctx.gpr[i] = int32;
	  }
      }

  /* Collect floating-point register values from the regcache.  */
  if (ppc_floating_point_unit_p (gdbarch))
    fill_fprs (regcache, ctx.fpr);

  /* Special registers (always kept in ctx as 64 bits).  */
  if (arch64)
    {
      fill_sprs64 (regcache, &ctx.iar, &ctx.msr, &ctx.cr, &ctx.lr, &ctx.ctr,
			     &ctx.xer, &ctx.fpscr);
    }
  else
    {
      /* Problem: ctx.iar etc. are 64 bits, but raw_registers are 32.
	 Solution: use 32-bit temp variables.  */
      uint32_t tmp_iar, tmp_msr, tmp_cr, tmp_lr, tmp_ctr, tmp_xer,
	       tmp_fpscr;

      fill_sprs32 (regcache, &tmp_iar, &tmp_msr, &tmp_cr, &tmp_lr, &tmp_ctr,
			     &tmp_xer, &tmp_fpscr);
      if (REG_VALID == regcache_register_status (regcache,
						 gdbarch_pc_regnum (gdbarch)))
	ctx.iar = tmp_iar;
      if (REG_VALID == regcache_register_status (regcache, tdep->ppc_ps_regnum))
	ctx.msr = tmp_msr;
      if (REG_VALID == regcache_register_status (regcache, tdep->ppc_cr_regnum))
	ctx.cr  = tmp_cr;
      if (REG_VALID == regcache_register_status (regcache, tdep->ppc_lr_regnum))
	ctx.lr  = tmp_lr;
      if (REG_VALID == regcache_register_status (regcache,
						 tdep->ppc_ctr_regnum))
	ctx.ctr = tmp_ctr;
      if (REG_VALID == regcache_register_status (regcache,
						 tdep->ppc_xer_regnum))
	ctx.xer = tmp_xer;
      if (REG_VALID == regcache_register_status (regcache,
						 tdep->ppc_xer_regnum))
	ctx.fpscr = tmp_fpscr;
    }

  status = pthdb_pthread_setcontext (pd_session, pdtid, &ctx);
  if (status != PTHDB_SUCCESS)
    error (_("aix-thread: store_registers: "
	     "pthdb_pthread_setcontext returned %s"),
           pd_status2str (status));
}

/* Store register REGNO if != -1 or all registers otherwise into
   kernel thread TID.

   AIX provides a way to set all of a kernel thread's GPRs, FPRs, or
   SPRs, but there's no way to set individual registers within those
   groups.  Therefore, if REGNO != -1, this function stores an entire
   group.  */

static void
store_regs_kernel_thread (const struct regcache *regcache, int regno,
			  pthdb_tid_t tid)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  uint64_t gprs64[ppc_num_gprs];
  uint32_t gprs32[ppc_num_gprs];
  double fprs[ppc_num_fprs];
  struct ptxsprs sprs64;
  struct ptsprs  sprs32;
  int i;

  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog, 
			"store_regs_kernel_thread tid=%lx regno=%d\n",
                        (long) tid, regno);

  /* General-purpose registers.  */
  if (regno == -1
      || (tdep->ppc_gp0_regnum <= regno
          && regno < tdep->ppc_gp0_regnum + ppc_num_fprs))
    {
      if (arch64)
	{
	  /* Pre-fetch: some regs may not be in the cache.  */
	  ptrace64aix (PTT_READ_GPRS, tid, (unsigned long) gprs64, 0, NULL);
	  fill_gprs64 (regcache, gprs64);
	  ptrace64aix (PTT_WRITE_GPRS, tid, (unsigned long) gprs64, 0, NULL);
	}
      else
	{
	  /* Pre-fetch: some regs may not be in the cache.  */
	  ptrace32 (PTT_READ_GPRS, tid, (addr_ptr) gprs32, 0, NULL);
	  fill_gprs32 (regcache, gprs32);
	  ptrace32 (PTT_WRITE_GPRS, tid, (addr_ptr) gprs32, 0, NULL);
	}
    }

  /* Floating-point registers.  */

  if (ppc_floating_point_unit_p (gdbarch)
      && (regno == -1
          || (regno >= tdep->ppc_fp0_regnum
              && regno < tdep->ppc_fp0_regnum + ppc_num_fprs)))
    {
      /* Pre-fetch: some regs may not be in the cache.  */
      ptrace32 (PTT_READ_FPRS, tid, (addr_ptr) fprs, 0, NULL);
      fill_fprs (regcache, fprs);
      ptrace32 (PTT_WRITE_FPRS, tid, (addr_ptr) fprs, 0, NULL);
    }

  /* Special-purpose registers.  */

  if (regno == -1 || special_register_p (gdbarch, regno))
    {
      if (arch64)
	{
	  /* Pre-fetch: some registers won't be in the cache.  */
	  ptrace64aix (PTT_READ_SPRS, tid, 
		       (unsigned long) &sprs64, 0, NULL);
	  fill_sprs64 (regcache, &sprs64.pt_iar, &sprs64.pt_msr,
		       &sprs64.pt_cr, &sprs64.pt_lr, &sprs64.pt_ctr,
		       &sprs64.pt_xer, &sprs64.pt_fpscr);
	  ptrace64aix (PTT_WRITE_SPRS, tid, 
		       (unsigned long) &sprs64, 0, NULL);
	}
      else
	{
	  /* The contents of "struct ptspr" were declared as "unsigned
	     long" up to AIX 5.2, but are "unsigned int" since 5.3.
	     Use temporaries to work around this problem.  Also, add an
	     assert here to make sure we fail if the system header files
	     use "unsigned long", and the size of that type is not what
	     the headers expect.  */
	  uint32_t tmp_iar, tmp_msr, tmp_cr, tmp_lr, tmp_ctr, tmp_xer,
		   tmp_fpscr;

	  gdb_assert (sizeof (sprs32.pt_iar) == 4);

	  /* Pre-fetch: some registers won't be in the cache.  */
	  ptrace32 (PTT_READ_SPRS, tid, (addr_ptr) &sprs32, 0, NULL);

	  fill_sprs32 (regcache, &tmp_iar, &tmp_msr, &tmp_cr, &tmp_lr,
		       &tmp_ctr, &tmp_xer, &tmp_fpscr);

	  sprs32.pt_iar = tmp_iar;
	  sprs32.pt_msr = tmp_msr;
	  sprs32.pt_cr = tmp_cr;
	  sprs32.pt_lr = tmp_lr;
	  sprs32.pt_ctr = tmp_ctr;
	  sprs32.pt_xer = tmp_xer;
	  sprs32.pt_fpscr = tmp_fpscr;

	  if (tdep->ppc_mq_regnum >= 0)
	    if (REG_VALID == regcache_register_status (regcache,
						       tdep->ppc_mq_regnum))
	      regcache_raw_collect (regcache, tdep->ppc_mq_regnum,
				    &sprs32.pt_mq);

	  ptrace32 (PTT_WRITE_SPRS, tid, (addr_ptr) &sprs32, 0, NULL);
	}
    }
}

/* Store gdb's current view of the register set into the
   thread/process specified by inferior_ptid.  */

static void
aix_thread_store_registers (struct target_ops *ops,
                            struct regcache *regcache, int regno)
{
  struct thread_info *thread;
  pthdb_tid_t tid;
  struct target_ops *beneath = find_target_beneath (ops);

  if (!PD_TID (inferior_ptid))
    beneath->to_store_registers (beneath, regcache, regno);
  else
    {
      thread = find_thread_ptid (inferior_ptid);
      tid = thread->private->tid;

      if (tid == PTHDB_INVALID_TID)
	store_regs_user_thread (regcache, thread->private->pdtid);
      else
	store_regs_kernel_thread (regcache, regno, tid);
    }
}

/* Attempt a transfer all LEN bytes starting at OFFSET between the
   inferior's OBJECT:ANNEX space and GDB's READBUF/WRITEBUF buffer.
   Return the number of bytes actually transferred.  */

static LONGEST
aix_thread_xfer_partial (struct target_ops *ops, enum target_object object,
			 const char *annex, gdb_byte *readbuf,
			 const gdb_byte *writebuf,
			 ULONGEST offset, LONGEST len)
{
  struct cleanup *old_chain = save_inferior_ptid ();
  LONGEST xfer;
  struct target_ops *beneath = find_target_beneath (ops);

  inferior_ptid = pid_to_ptid (ptid_get_pid (inferior_ptid));
  xfer = beneath->to_xfer_partial (beneath, object, annex,
				   readbuf, writebuf, offset, len);

  do_cleanups (old_chain);
  return xfer;
}

/* Clean up after the inferior exits.  */

static void
aix_thread_mourn_inferior (struct target_ops *ops)
{
  struct target_ops *beneath = find_target_beneath (ops);

  pd_deactivate ();
  beneath->to_mourn_inferior (beneath);
}

/* Return whether thread PID is still valid.  */

static int
aix_thread_thread_alive (struct target_ops *ops, ptid_t ptid)
{
  struct target_ops *beneath = find_target_beneath (ops);

  if (!PD_TID (ptid))
    return beneath->to_thread_alive (beneath, ptid);

  /* We update the thread list every time the child stops, so all
     valid threads should be in the thread list.  */
  return in_thread_list (ptid);
}

/* Return a printable representation of composite PID for use in
   "info threads" output.  */

static char *
aix_thread_pid_to_str (struct target_ops *ops, ptid_t ptid)
{
  static char *ret = NULL;
  struct target_ops *beneath = find_target_beneath (ops);

  if (!PD_TID (ptid))
    return beneath->to_pid_to_str (beneath, ptid);

  /* Free previous return value; a new one will be allocated by
     xstrprintf().  */
  xfree (ret);

  ret = xstrprintf (_("Thread %ld"), ptid_get_tid (ptid));
  return ret;
}

/* Return a printable representation of extra information about
   THREAD, for use in "info threads" output.  */

static char *
aix_thread_extra_thread_info (struct thread_info *thread)
{
  struct ui_file *buf;
  int status;
  pthdb_pthread_t pdtid;
  pthdb_tid_t tid;
  pthdb_state_t state;
  pthdb_suspendstate_t suspendstate;
  pthdb_detachstate_t detachstate;
  int cancelpend;
  static char *ret = NULL;

  if (!PD_TID (thread->ptid))
    return NULL;

  buf = mem_fileopen ();

  pdtid = thread->private->pdtid;
  tid = thread->private->tid;

  if (tid != PTHDB_INVALID_TID)
    /* i18n: Like "thread-identifier %d, [state] running, suspended" */
    fprintf_unfiltered (buf, _("tid %d"), (int)tid);

  status = pthdb_pthread_state (pd_session, pdtid, &state);
  if (status != PTHDB_SUCCESS)
    state = PST_NOTSUP;
  fprintf_unfiltered (buf, ", %s", state2str (state));

  status = pthdb_pthread_suspendstate (pd_session, pdtid, 
				       &suspendstate);
  if (status == PTHDB_SUCCESS && suspendstate == PSS_SUSPENDED)
    /* i18n: Like "Thread-Id %d, [state] running, suspended" */
    fprintf_unfiltered (buf, _(", suspended"));

  status = pthdb_pthread_detachstate (pd_session, pdtid, 
				      &detachstate);
  if (status == PTHDB_SUCCESS && detachstate == PDS_DETACHED)
    /* i18n: Like "Thread-Id %d, [state] running, detached" */
    fprintf_unfiltered (buf, _(", detached"));

  pthdb_pthread_cancelpend (pd_session, pdtid, &cancelpend);
  if (status == PTHDB_SUCCESS && cancelpend)
    /* i18n: Like "Thread-Id %d, [state] running, cancel pending" */
    fprintf_unfiltered (buf, _(", cancel pending"));

  ui_file_write (buf, "", 1);

  xfree (ret);			/* Free old buffer.  */

  ret = ui_file_xstrdup (buf, NULL);
  ui_file_delete (buf);

  return ret;
}

static ptid_t
aix_thread_get_ada_task_ptid (long lwp, long thread)
{
  return ptid_build (ptid_get_pid (inferior_ptid), 0, thread);
}

/* Initialize target aix_thread_ops.  */

static void
init_aix_thread_ops (void)
{
  aix_thread_ops.to_shortname = "aix-threads";
  aix_thread_ops.to_longname = _("AIX pthread support");
  aix_thread_ops.to_doc = _("AIX pthread support");

  aix_thread_ops.to_attach = aix_thread_attach;
  aix_thread_ops.to_detach = aix_thread_detach;
  aix_thread_ops.to_resume = aix_thread_resume;
  aix_thread_ops.to_wait = aix_thread_wait;
  aix_thread_ops.to_fetch_registers = aix_thread_fetch_registers;
  aix_thread_ops.to_store_registers = aix_thread_store_registers;
  aix_thread_ops.to_xfer_partial = aix_thread_xfer_partial;
  /* No need for aix_thread_ops.to_create_inferior, because we activate thread
     debugging when the inferior reaches pd_brk_addr.  */
  aix_thread_ops.to_mourn_inferior = aix_thread_mourn_inferior;
  aix_thread_ops.to_thread_alive = aix_thread_thread_alive;
  aix_thread_ops.to_pid_to_str = aix_thread_pid_to_str;
  aix_thread_ops.to_extra_thread_info = aix_thread_extra_thread_info;
  aix_thread_ops.to_get_ada_task_ptid = aix_thread_get_ada_task_ptid;
  aix_thread_ops.to_stratum = thread_stratum;
  aix_thread_ops.to_magic = OPS_MAGIC;
}

/* Module startup initialization function, automagically called by
   init.c.  */

void _initialize_aix_thread (void);

void
_initialize_aix_thread (void)
{
  init_aix_thread_ops ();
  complete_target_initialization (&aix_thread_ops);

  /* Notice when object files get loaded and unloaded.  */
  observer_attach_new_objfile (new_objfile);

  add_setshow_boolean_cmd ("aix-thread", class_maintenance, &debug_aix_thread,
			   _("Set debugging of AIX thread module."),
			   _("Show debugging of AIX thread module."),
			   _("Enables debugging output (used to debug GDB)."),
			   NULL, NULL,
			   /* FIXME: i18n: Debugging of AIX thread
			      module is \"%d\".  */
			   &setdebuglist, &showdebuglist);
}
@


1.89
log
@Remove unnecessary cast in aix-thread.c:ptrace32.

We're casting "addr" into "addr_ptr", but this variable is actually
a parameter with that very same type...

gdb/ChangeLog:

        * aix-thread.c (ptrace32): Remove cast to addr_ptr.
@
text
@d759 1
a759 1
	  thread = add_thread (ptid_build (infpid, 0, pbuf[pi].pthid);
@


1.88
log
@	* aarch64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* aix-thread.c (BUILD_THREAD, BUILD_LWP): Remove.
	Replace BUILD_THREAD with ptid_build.
	Replace BUILD_LWP with ptid_build.
	Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* alphabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* amd64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* amd64bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* arm-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* armnbsd-nat.c: Replace PIDGET with ptid_get_pid.
	* auxv.c: Likewise.
	* breakpoint.c: Likewise.
	* common/ptid.c (ptid_is_pid): Condense check for
	null_ptid and minus_one_ptid.
	(ptid_lwp_p): New function.
	(ptid_tid_p): New function.
	* common/ptid.h: Update comments for accessors.
	(ptid_lwp_p): New prototype.
	(ptid_tid_p): New prototype.
	* defs.h (PIDGET, TIDGET, MERGEPID): Do not define.
	* gcore.c: Replace PIDGET with ptid_get_pid.
	* gdbthread.h: Likewise.
	* gnu-nat.c: Likewise.
	* hppa-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* hppabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* hppanbsd-nat.c: Likewise.
	* i386-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* i386bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* ia64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	* infcmd.c: Likewise.
	* inferior.h: Likewise.
	* inflow.c: Likewise.
	* infrun.c: Likewise.
	* linux-fork.c: Likewise.
	* linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace GET_PID with ptid_get_pid.
	Replace is_lwp with ptid_lwp_p.
	Replace GET_LWP with ptid_get_lwp.
	Replace BUILD_LWP with ptid_build.
@
text
@d267 1
a267 1
		       ptrace (req, id, (addr_ptr) addr, data, buf));
@


1.87
log
@2013-08-07  Raunaq Bathija  <raunaq12@@in.ibm.com>
	    Ulrich Weigand  <uweigand@@de.ibm.com>

	* aixthread.c: Call ptrace64 instead of ptracex if defined.
	Call ptrace64 instead of ptrace if defined.
	Add macro addr_ptr to take care of ptrace address argument.
	(pdc_read_regs): Likewise.
	(pdc_write_regs): Likewise.
	(aix_thread_resume): Likewise.
	(fetch_regs_kernel_thread): Likewise.
	(store_regs_kernel_thread): Likewise.
@
text
@a75 6
/* Build a thread ptid.  */
#define BUILD_THREAD(TID, PID) ptid_build (PID, 0, TID)

/* Build and lwp ptid.  */
#define BUILD_LWP(LWP, PID) MERGEPID (PID, LWP)

d280 1
a280 1
    *ptidp = pid_to_ptid (PIDGET (ptid));
d666 1
a666 1
    if (getthrds (PIDGET (inferior_ptid), &thrinf, 
d749 1
a749 1
  infpid = PIDGET (inferior_ptid);
d759 1
a759 1
	  thread = add_thread (BUILD_THREAD (pbuf[pi].pthid, infpid));
d770 1
a770 1
	  pptid = BUILD_THREAD (pbuf[pi].pthid, infpid);
d993 1
a993 1
      inferior_ptid = pid_to_ptid (PIDGET (inferior_ptid));
d1002 1
a1002 1
	       TIDGET (ptid));
d1007 1
a1007 1
	       TIDGET (ptid));
d1032 1
a1032 1
  inferior_ptid = pid_to_ptid (PIDGET (inferior_ptid));
d1036 1
a1036 1
  if (PIDGET (ptid) == -1)
d1695 1
a1695 1
  inferior_ptid = pid_to_ptid (PIDGET (inferior_ptid));
@


1.86
log
@more add_target removals

This removes a few more erroneous calls to add_target.  These calls
end up installing the target in a user-visible way; but these targets
are all auto-activated and, I think, should never be explicitly
requested.

I have no way to test these.

	* aix-thread.c (_initialize_aix_thread): Use
	complete_target_initialization.
	* bsd-uthread.c (_initialize_bsd_uthread): Use
	complete_target_initialization.
	* dec-thread.c (_initialize_dec_thread): Use
	complete_target_initialization.
	* ravenscar-thread.c (_initialize_ravenscar): Use
	complete_target_initialization.
	* sol-thread.c (_initialize_sol_thread): Use
	complete_target_initialization.
	* spu-multiarch.c (_initialize_spu_multiarch): Use
	complete_target_initialization.
@
text
@d240 8
a247 1
/* Call ptracex (REQ, ID, ADDR, DATA, BUF).  Return success.  */
d256 11
a266 1
/* Call ptrace (REQ, ID, ADDR, DATA, BUF).  Return success.  */
d269 1
a269 1
ptrace32 (int req, int id, int *addr, int data, int *buf)
d273 1
a273 1
		       ptrace (req, id, (int *) addr, data, buf));
d381 1
a381 1
      if (!ptrace32 (PTT_READ_FPRS, tid, (void *) fprs, 0, NULL))
d398 1
a398 1
	  if (!ptrace32 (PTT_READ_SPRS, tid, (int *) &sprs32, 0, NULL))
d433 1
a433 1
	ptrace32 (PTT_WRITE_GPRS, tid, (int *) context->gpr, 0, NULL);
d439 1
a439 1
      ptrace32 (PTT_WRITE_FPRS, tid, (int *) context->fpr, 0, NULL);
d452 1
a452 1
	  ptrace32 (PTT_WRITE_SPRS, tid, (void *) &context->msr, 0, NULL);
d1017 1
a1017 1
	ptrace64aix (PTT_CONTINUE, tid[0], 1, 
d1020 1
a1020 1
	ptrace32 (PTT_CONTINUE, tid[0], (int *) 1,
d1259 1
a1259 1
	  if (!ptrace32 (PTT_READ_GPRS, tid, gprs32, 0, NULL))
d1273 1
a1273 1
      if (!ptrace32 (PTT_READ_FPRS, tid, (void *) fprs, 0, NULL))
d1295 1
a1295 1
	  if (!ptrace32 (PTT_READ_SPRS, tid, (int *) &sprs32, 0, NULL))
d1590 1
a1590 1
	  ptrace32 (PTT_READ_GPRS, tid, gprs32, 0, NULL);
d1592 1
a1592 1
	  ptrace32 (PTT_WRITE_GPRS, tid, gprs32, 0, NULL);
d1604 1
a1604 1
      ptrace32 (PTT_READ_FPRS, tid, (void *) fprs, 0, NULL);
d1606 1
a1606 1
      ptrace32 (PTT_WRITE_FPRS, tid, (void *) fprs, 0, NULL);
d1638 1
a1638 1
	  ptrace32 (PTT_READ_SPRS, tid, (int *) &sprs32, 0, NULL);
d1657 1
a1657 1
	  ptrace32 (PTT_WRITE_SPRS, tid, (int *) &sprs32, 0, NULL);
@


1.85
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1840 1
a1840 1
  add_target (&aix_thread_ops);
@


1.84
log
@aix-thread: Fix getthrds declaration and call.

gdb/ChangeLog:

        * aix-thread.c (getthrds): Fix type of 4th parameter.
        (get_signaled_thread): Change type of variable ktid to tid_t.
@
text
@d3 1
a3 2
   Copyright (C) 1999-2000, 2002, 2007-2012 Free Software Foundation,
   Inc.
@


1.83
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d62 1
a62 1
extern int getthrds (pid_t, struct thrdsinfo64 *, int, pthdb_tid_t *, int);
d651 1
a651 1
  pthdb_tid_t ktid = 0;
@


1.82
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d890 1
a890 1
  arch64 = register_size (target_gdbarch, 0) == 8;
d904 1
a904 1
  if (!create_thread_event_breakpoint (target_gdbarch, pd_brk_addr))
@


1.81
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d1031 1
a1031 1
      && status->value.sig == TARGET_SIGNAL_TRAP)
@


1.80
log
@Minor cleanup in aix-thread.c:supply_fprs.

This is a minor cleanup that makes supply_fprs more consistent with
how fill_fprs was written.

gdb/ChangeLog:

        * aix-thread.c (supply_fprs): Make more consistent with fill_fprs.
@
text
@d973 1
a973 1
                   ptid_t ptid, int step, enum target_signal sig)
d1002 1
a1002 1
		     target_signal_to_host (sig), (void *) tid);
d1005 1
a1005 1
		  target_signal_to_host (sig), (void *) tid);
@


1.79
log
@Fix buffer overflow in aix-thread.c:fill_fprs

gdb/
2012-03-08  Chris January  <chris.january@@allinea.com>

	* aix-thread.c (fill_sprs): Store the floating point registers
	at the correct offsets into vals.
@
text
@d1078 5
a1082 3
  for (regno = 0; regno < ppc_num_fprs; regno++)
    regcache_raw_supply (regcache, regno + tdep->ppc_fp0_regnum,
			 (char *) (vals + regno));
@


1.78
log
@Add missing prototypes for build in ppx-aix.

gdb/ChangeLog:
2012-03-12  Chris January  <chris.january@@allinea.com>

        * aix-thread.c (_initialize_aix_thread): Add prototype.
        * rs6000-nat.c (_initialize_rs6000_nat): Ditto.
        * xcoffsolib.c (_initialize_xcoffsolib): Ditto.
@
text
@d1359 2
a1360 1
      regcache_raw_collect (regcache, regno, vals + regno);
@


1.77
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1832 2
@


1.76
log
@Add 'getthrds' declaration check in configure for AIX

On newer versions of AIX (6.x and later), this function is actually
declared in procinfo.h, thus causing a compilation warning when we
re-declare it ourselves. This patch adds a configure check for that
function allowing us to declare the function only if the declaration
isn't already present in one of procinfo system header.

gdb/ChangeLog:

        PR gdb/12116:
        * configure.ac: Add getthrds declaration check.
        * configure, config.in: Regenerate.
        * aix-thread.c (getthrds): Declare only if not already declared
        in procinfo.h.  More declaration out of get_signaled_thread to
        global scope.
@
text
@d3 2
a4 2
   Copyright (C) 1999, 2000, 2002, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.76.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 2
   Copyright (C) 1999-2000, 2002, 2007-2012 Free Software Foundation,
   Inc.
@


1.75
log
@2011-01-31  Yao Qi  <yao@@codesourcery.com>

	* arm-linux-nat.c: Update calls to regcache_register_status
	instead of regcache_valid_p.
	* aix-thread.c: Likewise.
	* i386gnu-nat.c: Likewise.
@
text
@d61 4
a653 4
  /* getthrds(3) isn't prototyped in any AIX 4.3.3 #include file.  */
  extern int getthrds (pid_t, struct thrdsinfo64 *, 
		       int, pthdb_tid_t *, int);

@


1.74
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d1324 2
a1325 1
    if (regcache_valid_p (regcache, tdep->ppc_gp0_regnum + regno))
d1337 2
a1338 1
    if (regcache_valid_p (regcache, tdep->ppc_gp0_regnum + regno))
d1358 1
a1358 1
    if (regcache_valid_p (regcache, regno))
d1382 2
a1383 1
  if (regcache_valid_p (regcache, gdbarch_pc_regnum (gdbarch)))
d1385 1
a1385 1
  if (regcache_valid_p (regcache, tdep->ppc_ps_regnum))
d1387 1
a1387 1
  if (regcache_valid_p (regcache, tdep->ppc_cr_regnum))
d1389 1
a1389 1
  if (regcache_valid_p (regcache, tdep->ppc_lr_regnum))
d1391 1
a1391 1
  if (regcache_valid_p (regcache, tdep->ppc_ctr_regnum))
d1393 1
a1393 1
  if (regcache_valid_p (regcache, tdep->ppc_xer_regnum))
d1396 2
a1397 1
      && regcache_valid_p (regcache, tdep->ppc_fpscr_regnum))
d1418 2
a1419 1
  if (regcache_valid_p (regcache, gdbarch_pc_regnum (gdbarch)))
d1421 1
a1421 1
  if (regcache_valid_p (regcache, tdep->ppc_ps_regnum))
d1423 1
a1423 1
  if (regcache_valid_p (regcache, tdep->ppc_cr_regnum))
d1425 1
a1425 1
  if (regcache_valid_p (regcache, tdep->ppc_lr_regnum))
d1427 1
a1427 1
  if (regcache_valid_p (regcache, tdep->ppc_ctr_regnum))
d1429 1
a1429 1
  if (regcache_valid_p (regcache, tdep->ppc_xer_regnum))
d1432 1
a1432 1
      && regcache_valid_p (regcache, tdep->ppc_fpscr_regnum))
d1467 2
a1468 1
    if (regcache_valid_p (regcache, tdep->ppc_gp0_regnum + i))
d1503 2
a1504 1
      if (regcache_valid_p (regcache, gdbarch_pc_regnum (gdbarch)))
d1506 1
a1506 1
      if (regcache_valid_p (regcache, tdep->ppc_ps_regnum))
d1508 1
a1508 1
      if (regcache_valid_p (regcache, tdep->ppc_cr_regnum))
d1510 1
a1510 1
      if (regcache_valid_p (regcache, tdep->ppc_lr_regnum))
d1512 2
a1513 1
      if (regcache_valid_p (regcache, tdep->ppc_ctr_regnum))
d1515 2
a1516 1
      if (regcache_valid_p (regcache, tdep->ppc_xer_regnum))
d1518 2
a1519 1
      if (regcache_valid_p (regcache, tdep->ppc_xer_regnum))
d1633 2
a1634 1
	    if (regcache_valid_p (regcache, tdep->ppc_mq_regnum))
@


1.73
log
@run copyright.sh for 2011.
@
text
@d387 1
a387 1
   information to specified debuggee's kernel thread id. 
d842 1
a842 1
/* Try to start debugging threads in the current process. 
d1515 2
a1516 1
    error (_("aix-thread: store_registers: pthdb_pthread_setcontext returned %s"),
d1664 2
a1665 1
			 const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
d1831 7
a1837 5
			    _("Set debugging of AIX thread module."),
			    _("Show debugging of AIX thread module."),
			    _("Enables debugging output (used to debug GDB)."),
			    NULL, NULL, /* FIXME: i18n: Debugging of AIX thread module is \"%d\".  */
			    &setdebuglist, &showdebuglist);
@


1.72
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2002, 2007, 2008, 2009, 2010
@


1.71
log
@	ARI fix: OP eol rule.
	* ada-exp.y (block_lookup): Avoid operator at end of line.
	* aix-thread.c (pd_enable): Idem.
	* alpha-tdep.c (alpha_next_pc): Idem.
	* arm-tdep.c (arm_skip_prologue, arm_scan_prologue): Idem.
	(condition_true, coff_sym_is_thumb): Idem.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2002, 2007, 2008, 2009
@


1.70
log
@	* ui-file.h (ui_file_xstrdup): Mention that the length argument
	may be NULL.
	* ui-file.c (ui_file_xstrdup): Don't dereference LENGTH if it is
	NULL.
	* aix-thread.c (aix_thread_extra_thread_info): Pass NULL as length
	parameter to ui_file_xstrdup.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* infrun.c (print_target_wait_results): Ditto.
	* language.c (add_language): Ditto.
	* linespec.c (cplusplus_error): Ditto.
	* remote.c (escape_buffer): Ditto.
	* typeprint.c (type_to_string): Ditto.
	* utils.c (error_stream): Ditto.
	* varobj.c (value_get_print_value): Ditto.
	* xtensa-tdep.c (xtensa_verify_config): Replace `dummy' local with
	`length' local.  Pass it to ui_file_xstrdup, and avoid an strlen
	call.
	* gdbarch.sh (verify_gdbarch): Ditto.
	* gdbarch.c: Regenerate.
	* cli/cli-setshow.c (do_setshow_command): Pass NULL as length
	parameter to ui_file_xstrdup.
	* python/python-frame.c (frapy_str): Ditto.
	* python/python-type.c (typy_str): Use the length local instead of
	calling strlen.
	* python/python-value.c (valpy_str): Pass NULL as length parameter
	to ui_file_xstrdup.
@
text
@d896 2
a897 2
  if ((status != PTHDB_SUCCESS && 
       status != PTHDB_NOT_PTHREADED) || !stub_name)
@


1.69
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@a1736 1
  long length;
d1777 1
a1777 1
  ret = ui_file_xstrdup (buf, &length);
@


1.68
log
@	* ada-tasks.c (read_known_tasks_array): Use target_gdbarch instead
	of current_gdbarch.
	* aix-thread.c (pd_enable): Likewise.
	* amd64-linux-nat.c (ps_get_thread_area): Likewise.
	* bsd-uthread.c (bsd_uthread_activate): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* linux-thread-db.c (enable_thread_event): Likewise.
	* monitor.c (monitor_write_memory, monitor_read_memory): Likewise.
	* nto-procfs.c (procfs_open): Likewise.
	* procfs.c (invalidate_cache, procfs_insert_watchpoint,
	info_proc_mappings, info_mappings_callback): Likewise.
	* record.c (record_open): Likewise.
	* rs6000-nat.c (ARCH64): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	(darwin_bfd_open): Likewise.
	* memattr.c (mem_info_command): Likewise.

	* windows-nat.c (win32_resume): Use current regcache architecture
	instead of current_gdbarch.

	* dbug-rom.c (dbug_regname): Remove check against number of
	registers in current_gdbarch.
	* solib-pa64.c (read_dynamic_info): Remove unused variable.
@
text
@d904 1
a904 1
  if (!create_thread_event_breakpoint (pd_brk_addr))
@


1.67
log
@gdb:
	Global renaming of find_thread_pid to find_thread_ptid.
	* gdbthread.h (find_thread_ptid): Renamed from find_thread_pid.
	* thread.c (find_thread_ptid): Renamed from find_thread_pid.
	All callers updated.
gdbserver:
	Global renaming of find_thread_pid to find_thread_ptid.
	* server.h (find_thread_ptid): Renamed from find_thread_pid.
	* inferiors.c (find_thread_ptid): Renamed from find_thread_pid.
	All callers updated.
@
text
@d890 1
a890 1
  arch64 = register_size (current_gdbarch, 0) == 8;
@


1.66
log
@	* aix-thread.c (init_aix_thread_ops): Whitespace.
@
text
@d989 1
a989 1
      thread = find_thread_pid (ptid);
d1305 1
a1305 1
      thread = find_thread_pid (inferior_ptid);
d1646 1
a1646 1
      thread = find_thread_pid (inferior_ptid);
@


1.65
log
@        * aix-thread.c (aix_thread_wait): Add options parameter.  Use it
        to call the to_wait method in the target_beneath.
@
text
@d1795 3
a1797 3
  aix_thread_ops.to_shortname          = "aix-threads";
  aix_thread_ops.to_longname           = _("AIX pthread support");
  aix_thread_ops.to_doc                = _("AIX pthread support");
d1799 7
a1805 7
  aix_thread_ops.to_attach             = aix_thread_attach;
  aix_thread_ops.to_detach             = aix_thread_detach;
  aix_thread_ops.to_resume             = aix_thread_resume;
  aix_thread_ops.to_wait               = aix_thread_wait;
  aix_thread_ops.to_fetch_registers    = aix_thread_fetch_registers;
  aix_thread_ops.to_store_registers    = aix_thread_store_registers;
  aix_thread_ops.to_xfer_partial       = aix_thread_xfer_partial;
d1808 7
a1814 7
  aix_thread_ops.to_mourn_inferior     = aix_thread_mourn_inferior;
  aix_thread_ops.to_thread_alive       = aix_thread_thread_alive;
  aix_thread_ops.to_pid_to_str         = aix_thread_pid_to_str;
  aix_thread_ops.to_extra_thread_info  = aix_thread_extra_thread_info;
  aix_thread_ops.to_get_ada_task_ptid  = aix_thread_get_ada_task_ptid;
  aix_thread_ops.to_stratum            = thread_stratum;
  aix_thread_ops.to_magic              = OPS_MAGIC;
@


1.64
log
@        * aix-thread.c (giter_count): Do not count the main thread.
        (giter_accum): Do not include the main thread.
@
text
@d1015 1
a1015 1
		 ptid_t ptid, struct target_waitstatus *status)
d1023 1
a1023 1
  ptid = beneath->to_wait (beneath, ptid, status);
@


1.63
log
@        * aix-thread.c (aix_thread_thread_alive, aix_thread_pid_to_str):
        Use the ops parameter to get to the target beneath, rather than
        using the current_target global.  Using the current_target global
        was an unintended accident.
@
text
@d573 6
a578 1
/* iterate_over_threads() callback for counting GDB threads.  */
d583 2
a584 1
  (*(int *) countp)++;
d588 6
a593 1
/* iterate_over_threads() callback for accumulating GDB thread pids.  */
d598 5
a602 2
  **(struct thread_info ***) bufp = thread;
  (*(struct thread_info ***) bufp)++;
@


1.62
log
@        Modernize the aix-thread later by getting rid of the base_target
        global.  This brings back to life the AIX port which was otherwise
        crashing all the time.

        * aix-thread.c (base_target): Delete.
        (pd_enable): Do not set base_target.
        (aix_thread_attach): Use find_target_beneath instead of base_target.
        (aix_thread_detach, aix_thread_resume, aix_thread_wait)
        (aix_thread_fetch_registers, aix_thread_store_registers),
        (aix_thread_xfer_partial, aix_thread_mourn_inferior)
        (aix_thread_thread_alive, aix_thread_pid_to_str): Likewise.
        (aix_thread_kill): Delete. Does not seem necessary.
        (init_aix_thread_ops): Do not set aix_thread_ops.to_kill.
@
text
@d1679 1
a1679 1
  struct target_ops *beneath = find_target_beneath (&current_target);
d1696 1
a1696 1
  struct target_ops *beneath = find_target_beneath (&current_target);
@


1.61
log
@        Fix a build failure on AIX introduced after a change in the profile
        of some of the "methods" in the target_ops structure.
        * aix-thread.c: Add missing target_ops parameter throughout.

        Implement Ada task switching on AIX.
        * aix-thread.c (aix_thread_get_ada_task_ptid): New function.
        (init_aix_thread_ops): Set aix_thread_ops.to_get_ada_task_ptid.
@
text
@a107 6
/* Copy of the target over which ops is pushed.  This is more
   convenient than a pointer to deprecated_child_ops or core_ops,
   because they lack current_target's default callbacks.  */

static struct target_ops base_target;

a893 1
  base_target = current_target;
d937 3
a939 1
  base_target.to_attach (&base_target, args, from_tty);
d948 2
d951 1
a951 1
  base_target.to_detach (&base_target, args, from_tty);
d967 2
d970 1
a970 1
      base_target.to_resume (ops, ptid, step, sig);
d1004 1
d1009 1
a1009 1
  ptid = base_target.to_wait (&base_target, ptid, status);
d1285 1
d1288 1
a1288 1
    base_target.to_fetch_registers (ops, regcache, regno);
d1626 1
d1629 1
a1629 1
    base_target.to_store_registers (ops, regcache, regno);
d1653 1
d1656 2
a1657 2
  xfer = base_target.to_xfer_partial (ops, object, annex,
				      readbuf, writebuf, offset, len);
a1662 12
/* Kill and forget about the inferior process.  */

static void
aix_thread_kill (void)
{
  struct cleanup *cleanup = save_inferior_ptid ();

  inferior_ptid = pid_to_ptid (PIDGET (inferior_ptid));
  base_target.to_kill ();
  do_cleanups (cleanup);
}

d1668 2
d1671 1
a1671 1
  base_target.to_mourn_inferior (&base_target);
d1679 2
d1682 1
a1682 1
    return base_target.to_thread_alive (ops, ptid);
d1696 1
d1699 1
a1699 1
    return base_target.to_pid_to_str (&base_target, ptid);
a1793 1
  aix_thread_ops.to_kill               = aix_thread_kill;
@


1.60
log
@	* linux-nat.c (linux_nat_wait): Adjust.
	(linux_nat_pid_to_str): Adjust.  Remove call to thread_db_init.
	* linux-nat.h (thread_db_init): Delete declaration.
	* linux-thread-db.c (target_beneath): Delete.
	(thread_db_init): Delete.
	(thread_db_detach): Use find_target_beneath.
	(thread_db_wait): Adjust interface.  Use find_target_beneath.
	(thread_db_mourn_inferior): Use find_target_beneath.
	(thread_db_can_async_p, thread_db_is_async_p, thread_db_async)
	(thread_db_async_mask): Delete.
	(thread_db_pid_to_str): Adjust interface.  Use
	find_target_beneath.
	(thread_db_get_thread_local_address): Adjust interface.  Use
	find_target_beneath.
	(init_thread_db_ops): Delete references to delete functions.
	* target.c (update_current_target): Don't inherit or default
	to_wait.  Don't inherit to_pid_to_str and
	to_get_thread_local_address.
	(target_translate_tls_address): Look for a pushed target that
	implements to_get_thread_local_address, and use it instead of
	checking for target_get_thread_local_address_p.
	(target_wait, target_pid_to_str): Reimplement as functions.
	(dummy_pid_to_str): New.
	(init_dummy_target): Register it.
	(debug_to_wait): Delete.
	* target.h (struct target_ops): Make to_wait, to_pid_to_str and
	to_get_thread_local_address accept a pointer to struct target_ops.
	(target_wait): Delete macro, and declare as function.
	(target_pid_to_str): Likewise.
	(target_get_thread_local_address)
	(target_get_thread_local_address_p): Delete.
	(noprocess): Add NORETURN and ATTR_NORETURN tags.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	(inf_ptrace_pid_to_str): New.
	(inf_ptrace_target): Use inf_ptrace_pid_to_str.
	* aix-thread.c (aix_thread_wait, aix_thread_pid_to_str): Adjust.
	* bsd-kvm.c (bsd_kvm_pid_to_str): Adjust.
	* bsd-uthread.c (bsd_uthread_wait, bsd_uthread_pid_to_str):
	Adjust.
	* corelow.c (core_pid_to_str): Adjust.
	* darwin-nat.c (darwin_wait, darwin_pid_to_str): Adjust.
	* dec-thread.c (dec_thread_wait, dec_thread_pid_to_str): Adjust.
	* gnu-nat.c (gnu_wait, gnu_pid_to_str): Adjust.
	* go32-nat.c (go32_wait, go32_pid_to_str): Adjust.
	* hpux-thread.c (hpux_thread_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait, inf_ttrace_pid_to_str): Adjust.
	* monitor.c (monitor_wait, monitor_pid_to_str): Adjust.
	* nto-procfs.c (procfs_wait, procfs_pid_to_str): Adjust.
	* procfs.c (procfs_pid_to_str): Adjust.
	* remote-m32r-sdi.c (m32r_wait, m32r_pid_to_str): Adjust.
	* remote-mips.c (mips_wait): Adjust.
	* remote-sim.c (gdbsim_wait, gdbsim_pid_to_str): Adjust.
	* remote.c (remote_wait, remote_pid_to_str)
	(remote_get_thread_local_address): Adjust.
	* rs6000-nat.c (rs6000_wait): Adjust.
	* sol-thread.c (procfs_pid_to_str): Adjust declaration.
	(sol_thread_wait, solaris_pid_to_str): Adjust.
	* spu-linux-nat.c (spu_child_wait): Adjust.
	* windows-nat.c (windows_wait, windows_pid_to_str): Adjust.
@
text
@d961 2
a962 1
aix_thread_resume (ptid_t ptid, int step, enum target_signal sig)
d971 1
a971 1
      base_target.to_resume (ptid, step, sig);
d1280 2
a1281 1
aix_thread_fetch_registers (struct regcache *regcache, int regno)
d1287 1
a1287 1
    base_target.to_fetch_registers (regcache, regno);
d1620 2
a1621 1
aix_thread_store_registers (struct regcache *regcache, int regno)
d1627 1
a1627 1
    base_target.to_store_registers (regcache, regno);
d1684 1
a1684 1
aix_thread_thread_alive (ptid_t ptid)
d1687 1
a1687 1
    return base_target.to_thread_alive (ptid);
d1774 6
d1803 1
@


1.59
log
@        Updated copyright notices for most files.
@
text
@d1000 2
a1001 1
aix_thread_wait (ptid_t ptid, struct target_waitstatus *status)
d1008 1
a1008 1
  ptid = base_target.to_wait (ptid, status);
d1695 1
a1695 1
aix_thread_pid_to_str (ptid_t ptid)
d1700 1
a1700 1
    return base_target.to_pid_to_str (ptid);
@


1.58
log
@	Kill pthread_ops_hack

	* target.h (struct target_ops): Make to_attach, to_detach,
	to_create_inferior and to_mourn_inferior accept a pointer
    	to struct target_ops.
	(target_attach, target_create_inferior, target_create_inferior):
	Convert from macros to function.  Find the right target to
	invoke a method of.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.
	* corefile.c (core_file_command): Pass target to to_detach.
	* corelow.c (core_detach): Add 'ops' parameter.
	* fork-child.c (fork_inferior): Return the pid.  Allow
	init_trace_fun to be NULL.
	* inf-ptrace (ptrace_ops_hack): Remove.
	(inf_ptrace_him): Remove, moving all logic into....
	(inf_ptrace_create_inferior): ... here.  Push the target
	passed as parameter.
	(inf_ptrace_mourn_inferior, inf_ptrace_attach, inf_ptrace_detach):
	Push/pop target passed as parameter, no ptrace_ops_hack.
	(inf_ptrace_target): Don't remember result.
	* inferior.h (fork_inferior): Adjust prototype.
	* linux-nat.c (linux_nat_create_inferior, linux_nat_attach)
	(linux_nat_detach, linux_nat_mourn_inferior): New parameter ops.
	Pass it to linux_ops target.
	* linux-thread-db.c (thread_db_detach, thread_db_mourn_inferior):
	New parameter ops. Pass it to the target beneath.
	* remote.c (remote_mourn, extended_remote_mourn, remote_detach)
	(extended_remote_create_inferior): New parameter ops. Pass it
	further.
	* target.c (debug_to_attach, debug_to_detach)
	(debug_to_mourn_inferior): New parameter ops.
	(target_create_inferior): New.
	(update_current_target): Do not inherit to_attach, to_detach,
	to_create_inferiour, to_mourn_inferior.  Do not default
	to_detach and to_mourn_inferior.
	(target_detach): Find the right target to use.
	(target_mourn_inferior): New.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.  Pass the found target when calling its method.
	(init_dummy_target): Provide fallback definition of to_detach.
	(target_attach): New.
	(debug_to_attach, debug_to_detach, debug_to_create_inferior)
	(debug_to_mourn_inferiour): New parameter ops.
        * aix-thread.c: Adjust.
        * bsd-uthread.c: Adjust.
        * gnu-nat.c: Adjust.
        * go32-nat.c: Adjust.
        * hpux-thread.c: Adjust.
        * inf-ttrace.c: Ajust.
        * monitor.c: Adjust.
        * nto-procfs.c: Adjust.
        * procfs.c: Adjust.
        * remote-m32r-sdi.c: Adjust.
        * remote-mips.c: Adjust.
        * remote-sim.c: Adjust.
        * rs6000-nat.c: Adjust.
        * sol-thread.c: Adjust.
        * win32-nat.c: Adjust.
	* dec-thread.c: Adjust.
@
text
@d3 2
a4 1
   Copyright (C) 1999, 2000, 2002, 2007, 2008 Free Software Foundation, Inc.
@


1.57
log
@	* inferior.h (read_pc_pid, write_pc_pid): Remove.
	* regcache.h (regcache_read_pc, regcache_write_pc): Add prototypes.

	* regcache.c (read_pc_pid): Remove, replace by ...
	(regcache_read_pc): ... this function.
	(write_pc_pid): Remove, replace by ...
	(regcache_write_pc): ... this function.
	(read_pc, write_pc): Update.

	* infrun.c (displaced_step_prepare): Replace read_pc_pid and
	write_pc_pid by regcache_read_pc and regcache_write_pc.
	(displaced_step_fixup): Likewise.
	(resume): Likewise.  Use regcache arch instead of current_gdbarch.
	(prepare_to_proceed): Likewise.
	(proceed): Likewise.
	(adjust_pc_after_break): Likewise.
	(handle_inferior_event): Likewise.

	* linux-nat.c (cancel_breakpoint): Likewise.
	* linux-thread-db.c (check_event): Likewise.
	* aix-thread.c (aix_thread_wait): Likewise.
	* tracepoint.c (trace_dump_command): Likewise.
@
text
@d941 1
a941 1
aix_thread_attach (char *args, int from_tty)
d943 1
a943 1
  base_target.to_attach (args, from_tty);
d950 1
a950 1
aix_thread_detach (char *args, int from_tty)
d953 1
a953 1
  base_target.to_detach (args, from_tty);
d1670 1
a1670 1
aix_thread_mourn_inferior (void)
d1673 1
a1673 1
  base_target.to_mourn_inferior ();
@


1.56
log
@        * aix-thread.c (pdc_read_regs): Fix compiler warning.
        (pdc_write_regs, aix_thread_resume, fetch_regs_kernel_thread)
        (store_regs_kernel_thread): Likewise.
@
text
@d1013 10
a1022 5
  if (!pd_active && status->kind == TARGET_WAITKIND_STOPPED &&
      status->value.sig == TARGET_SIGNAL_TRAP
      && read_pc_pid (ptid)
	 - gdbarch_decr_pc_after_break (current_gdbarch) == pd_brk_addr)
    return pd_activate (0);
@


1.55
log
@        * aix-thread.c (pdc_read_regs): Minor reformatting.
@
text
@d366 1
a366 1
      if (!ptrace32 (PTT_READ_FPRS, tid, (int *) fprs, 0, NULL))
d437 1
a437 1
	  ptrace32 (PTT_WRITE_SPRS, tid, (int *) &context->msr, 0, NULL);
d987 1
a987 1
		     target_signal_to_host (sig), (int *) tid);
d990 1
a990 1
		  target_signal_to_host (sig), (int *) tid);
d1233 1
a1233 1
      if (!ptrace32 (PTT_READ_FPRS, tid, (int *) fprs, 0, NULL))
d1550 1
a1550 1
      ptrace32 (PTT_READ_FPRS, tid, (int *) fprs, 0, NULL);
d1552 1
a1552 1
      ptrace32 (PTT_WRITE_FPRS, tid, (int *) fprs, 0, NULL);
@


1.54
log
@	Updated copyright notices for most files.
@
text
@d368 1
a368 1
      	  memcpy (context->fpr, fprs, sizeof(fprs));
@


1.54.2.1
log
@        * aix-thread.c (pdc_read_regs): Fix compiler warning.
        (pdc_write_regs, aix_thread_resume, fetch_regs_kernel_thread)
        (store_regs_kernel_thread): Likewise.
@
text
@d366 1
a366 1
      if (!ptrace32 (PTT_READ_FPRS, tid, (void *) fprs, 0, NULL))
d437 1
a437 1
	  ptrace32 (PTT_WRITE_SPRS, tid, (void *) &context->msr, 0, NULL);
d987 1
a987 1
		     target_signal_to_host (sig), (void *) tid);
d990 1
a990 1
		  target_signal_to_host (sig), (void *) tid);
d1233 1
a1233 1
      if (!ptrace32 (PTT_READ_FPRS, tid, (void *) fprs, 0, NULL))
d1550 1
a1550 1
      ptrace32 (PTT_READ_FPRS, tid, (void *) fprs, 0, NULL);
d1552 1
a1552 1
      ptrace32 (PTT_WRITE_FPRS, tid, (void *) fprs, 0, NULL);
@


1.53
log
@2007-11-07  Markus Deuling  <deuling@@de.ibm.com>

	* shnbsd-tdep.c (shnbsd_supply_gregset, shnbsd_collect_gregset): Use
	get_regcache_arch to get at the current architecture by regcache.
	* xstormy16-tdep.c (xstormy16_frame_prev_register): Use get_frame_arch
	to get at the current architecture by frame_info.
	* fbsd-nat.c (fbsd_make_corefile_notes): Use get_regcache_arch to get
	at the current architecture by regcache.
	* gnu-v3-abi.c (gnuv3_skip_trampoline): Use get_frame_arch to get at
	the current architecture by frame_info.
	(build_gdb_vtable_type): Replace current_gdbarch by gdbarch.
	* aix-thread.c (special_register_p): Add gdbarch as parameter.
	(fetch_regs_kernel_thread, store_regs_kernel_thread): Add gdbarch to
	caller of special_register_p.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2002, 2007 Free Software Foundation, Inc.
@


1.52
log
@2007-10-08  Markus Deuling  <deuling@@de.ibm.com>

	* aix-thread.c (supply_gprs64, supply_fprs, supply_sprs64)
	(supply_sprs32, fetch_regs_user_thread, fetch_regs_kernel_thread)
	(fill_gprs64, fill_gprs32, fill_fprs, fill_sprs64, fill_sprs32)
	(store_regs_user_thread, store_regs_kernel_thread): Use
	get_regcache_arch or get_frame_arch to get at the current architecture
	by regcache or by frame, respectively.
@
text
@d1063 1
a1063 1
special_register_p (int regno)
d1065 1
a1065 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1067 1
a1067 1
  return regno == gdbarch_pc_regnum (current_gdbarch)
d1240 1
a1240 1
  if (regno == -1 || special_register_p (regno))
d1557 1
a1557 1
  if (regno == -1 || special_register_p (regno))
@


1.51
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d1027 1
a1027 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1048 2
a1049 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1054 1
a1054 1
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));
d1087 2
a1088 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1090 1
a1090 1
  regcache_raw_supply (regcache, gdbarch_pc_regnum (current_gdbarch),
d1111 2
a1112 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1114 1
a1114 1
  regcache_raw_supply (regcache, gdbarch_pc_regnum (current_gdbarch),
d1136 2
a1137 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1159 1
a1159 1
  if (ppc_floating_point_unit_p (current_gdbarch))
d1191 2
a1192 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1228 1
a1228 1
  if (ppc_floating_point_unit_p (current_gdbarch)
d1253 1
a1253 1
	  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1296 1
a1296 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1308 1
a1308 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1321 2
a1322 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1327 1
a1327 1
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));
d1345 2
a1346 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1354 1
a1354 2
				 (current_gdbarch,
				  gdbarch_pc_regnum (current_gdbarch)));
d1356 2
a1357 2
  if (regcache_valid_p (regcache, gdbarch_pc_regnum (current_gdbarch)))
    regcache_raw_collect (regcache, gdbarch_pc_regnum (current_gdbarch), iar);
d1379 2
a1380 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1387 2
a1388 3
  gdb_assert (sizeof (*iar) == register_size (current_gdbarch,
					      gdbarch_pc_regnum
					      (current_gdbarch)));
d1390 2
a1391 2
  if (regcache_valid_p (regcache, gdbarch_pc_regnum (current_gdbarch)))
    regcache_raw_collect (regcache, gdbarch_pc_regnum (current_gdbarch), iar);
d1416 2
a1417 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1455 1
a1455 1
  if (ppc_floating_point_unit_p (current_gdbarch))
d1473 1
a1473 1
      if (regcache_valid_p (regcache, gdbarch_pc_regnum (current_gdbarch)))
d1507 2
a1508 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1544 1
a1544 1
  if (ppc_floating_point_unit_p (current_gdbarch)
@


1.50
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.49
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (DECR_PC_AFTER_BREAK): Replace by
	gdbarch_decr_pc_after_break.
	* tracepoint.c (trace_dump_command): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* linux-thread-db.c (check_event): Likewise.
	* linux-nat.c (cancel_breakpoints_callback): Likewise.
	* infrun.c (adjust_pc_after_break, normal_stop): Likewise.
	* frame.h: Likewise (comment).
	* dummy-frame.c (deprecated_pc_in_call_dummy): Likewise.
	* aix-thread.c (aix_thread_wait): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1068 1
a1068 1
  return regno == PC_REGNUM
d1090 2
a1091 1
  regcache_raw_supply (regcache, PC_REGNUM, (char *) &iar);
d1113 2
a1114 1
  regcache_raw_supply (regcache, PC_REGNUM, (char *) &iar);
d1348 3
a1350 1
  gdb_assert (sizeof (*iar) == register_size (current_gdbarch, PC_REGNUM));
d1352 2
a1353 2
  if (regcache_valid_p (regcache, PC_REGNUM))
    regcache_raw_collect (regcache, PC_REGNUM, iar);
d1382 3
a1384 1
  gdb_assert (sizeof (*iar) == register_size (current_gdbarch, PC_REGNUM));
d1386 2
a1387 2
  if (regcache_valid_p (regcache, PC_REGNUM))
    regcache_raw_collect (regcache, PC_REGNUM, iar);
d1468 1
a1468 1
      if (regcache_valid_p (regcache, PC_REGNUM))
@


1.48
log
@doc/ChangeLog:

	* observer.texi (GDB Observers): New observer "new_objfile".

ChangeLog:

	* observer.sh: Add "struct objfile" forward declaration.
	* target.h (deprecated_target_new_objfile_hook): Remove.
	* symfile.c (deprecated_target_new_objfile_hook): Remove.
	(clear_symtab_users): Call observer_notify_new_objfile.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	* rs6000-nat.c: Include "observer.h".
	(vmap_ldinfo): Call observer_notify_new_objfile.
	(xcoff_relocate_core): Likewise.
	* remote.c (remote_new_objfile_chain): Remove.
	(remote_new_objfile): Do not call remote_new_objfile_chain.
	(_initialize_remote): Use observer_attach_new_objfile.
	* tui/tui-hooks.c (tui_target_new_objfile_chain): Remove.
	(tui_new_objfile_hook): Do not call tui_target_new_objfile_chain.
	(_initialize_tui_hooks): Use observer_attach_new_objfile.
	* aix-thread.c: Include "observer.h".
	(target_new_objfile_chain): Remove.
	(new_objfile): Do not call target_new_objfile_chain.
	(_initialize_aix_thread): Use observer_attach_new_objfile.
	* hpux-thread.c: Include "observer.h"
	(target_new_objfile_chain): Remove.
	(hpux_thread_new_objfile): Make static.  Do not call
	target_new_objfile_chain.
	(_initialize_hpux_thread): Use observer_attach_new_objfile.
	* linux-thread-db.c: Include "observer.h".
	(target_new_objfile_chain): Remove.
	(thread_db_new_objfile): Do not call target_new_objfile_chain.
	(_initialize_thread_db): Use observer_attach_new_objfile.
	* sol-thread.c: Include "observer.h".
	(target_new_objfile_chain): Remove.
	(sol_thread_new_objfile): Make static.  Do not call
	target_new_objfile_chain.
	(_initialize_sol_thread): Use observer_attach_new_objfile.
	* Makefile.in (aix-thread.o, hpux-thread.o, linux-thread-db.o,
	rs6000-nat.o, sol-thread.o, tui-hooks.o): Add dependency on
	$(observer_h).
@
text
@d1016 3
a1018 2
      status->value.sig == TARGET_SIGNAL_TRAP &&
      read_pc_pid (ptid) - DECR_PC_AFTER_BREAK == pd_brk_addr)
@


1.47
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d53 1
a132 5
/* Saved pointer to previous owner of
   deprecated_target_new_objfile_hook.  */

static void (*target_new_objfile_chain)(struct objfile *);

d924 1
a924 1
/* deprecated_target_new_objfile_hook callback.
a937 3

  if (target_new_objfile_chain)
    target_new_objfile_chain (objfile);
d1788 1
a1788 2
  target_new_objfile_chain = deprecated_target_new_objfile_hook;
  deprecated_target_new_objfile_hook = new_objfile;
@


1.46
log
@	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs,
	supply_sprs64, supply_sprs32): Add REGCACHE parameter, use it
	instead of current_regcache.
	(fetch_regs_user_thread, fetch_regs_kernel_thread): Add
	REGCACHE parameter, pass it to supply_ routines.
	(aix_thread_fetch_registers): Pass current_regcache to
	fetch_regs_user_thread and fetch_regs_kernel_thread.

	(fill_gprs64, fill_gprs32, fill_fprs, fill_sprs64, fill_sprs32):
	Add REGCACHE parameter, use it instead of current_regcache.
	Call regcache_valid_p instead of register_cached.
	(store_regs_user_thread, store_regs_kernel_thread): Likewise.
	Also, pass REGCACHE to fill_ routines.
	(aix_thread_store_registers): Pass current_regcache to
	store_regs_user_thread and store_regs_kernel_thread.
@
text
@d1273 1
a1273 1
aix_thread_fetch_registers (int regno)
d1279 1
a1279 1
    base_target.to_fetch_registers (regno);
d1286 1
a1286 1
	fetch_regs_user_thread (current_regcache, thread->private->pdtid);
d1288 1
a1288 1
	fetch_regs_kernel_thread (current_regcache, regno, tid);
d1605 1
a1605 1
aix_thread_store_registers (int regno)
d1611 1
a1611 1
    base_target.to_store_registers (regno);
d1618 1
a1618 1
	store_regs_user_thread (current_regcache, thread->private->pdtid);
d1620 1
a1620 1
	store_regs_kernel_thread (current_regcache, regno, tid);
@


1.45
log
@	* aix-thread.c (aix_thread_xfer_memory): Replace by ...
	(aix_thread_xfer_partial): ... this.
	(init_aix_thread_ops): Install to_xfer_partial instead
	of deprecated_xfer_memory target method.

	* config/powerpc/aix.mh (NATDEPFILES): Remove infptrace.o
	and inftarg.o, add inf-ptrace.o.
	* config/rs6000/nm-rs6000.h (FETCH_INFERIOR_REGISTERS,
	CHILD_XFER_MEMORY, KERNEL_U_SIZE, kernel_u_size): Remove.
	* rs6000-nat.c: Include "inf-ptrace.h" and "gdb_stdint.h".
	(fetch_inferior_registers): Rename to ...
	(rs6000_fetch_inferior_registers): ... this.  Make static.
	(store_inferior_registers): Rename to ...
	(rs6000_store_inferior_registers): ... this.  Make static.
	(read_word, child_xfer_memory): Remove.
	(rs6000_xfer_partial): New function.
	(kernel_u_size): Remove.
	(_initialize_core_rs6000): Add inf_ptrace-based target.
	* Makefile.in (rs6000-nat.o): Update dependencies.
@
text
@d1033 1
a1033 1
supply_gprs64 (uint64_t *vals)
d1039 1
a1039 1
    regcache_raw_supply (current_regcache, tdep->ppc_gp0_regnum + regno,
d1046 1
a1046 1
supply_reg32 (int regno, uint32_t val)
d1048 1
a1048 1
  regcache_raw_supply (current_regcache, regno, (char *) &val);
d1054 1
a1054 1
supply_fprs (double *vals)
d1064 1
a1064 1
    regcache_raw_supply (current_regcache, regno + tdep->ppc_fp0_regnum,
d1089 2
a1090 1
supply_sprs64 (uint64_t iar, uint64_t msr, uint32_t cr,
d1096 6
a1101 6
  regcache_raw_supply (current_regcache, PC_REGNUM, (char *) &iar);
  regcache_raw_supply (current_regcache, tdep->ppc_ps_regnum, (char *) &msr);
  regcache_raw_supply (current_regcache, tdep->ppc_cr_regnum, (char *) &cr);
  regcache_raw_supply (current_regcache, tdep->ppc_lr_regnum, (char *) &lr);
  regcache_raw_supply (current_regcache, tdep->ppc_ctr_regnum, (char *) &ctr);
  regcache_raw_supply (current_regcache, tdep->ppc_xer_regnum, (char *) &xer);
d1103 1
a1103 1
    regcache_raw_supply (current_regcache, tdep->ppc_fpscr_regnum,
d1111 2
a1112 1
supply_sprs32 (uint32_t iar, uint32_t msr, uint32_t cr,
d1118 6
a1123 6
  regcache_raw_supply (current_regcache, PC_REGNUM, (char *) &iar);
  regcache_raw_supply (current_regcache, tdep->ppc_ps_regnum, (char *) &msr);
  regcache_raw_supply (current_regcache, tdep->ppc_cr_regnum, (char *) &cr);
  regcache_raw_supply (current_regcache, tdep->ppc_lr_regnum, (char *) &lr);
  regcache_raw_supply (current_regcache, tdep->ppc_ctr_regnum, (char *) &ctr);
  regcache_raw_supply (current_regcache, tdep->ppc_xer_regnum, (char *) &xer);
d1125 1
a1125 1
    regcache_raw_supply (current_regcache, tdep->ppc_fpscr_regnum,
d1137 1
a1137 1
fetch_regs_user_thread (pthdb_pthread_t pdtid)
d1154 1
a1154 1
    supply_gprs64 (ctx.gpr);
d1157 1
a1157 1
      supply_reg32 (tdep->ppc_gp0_regnum + i, ctx.gpr[i]);
d1162 1
a1162 1
    supply_fprs (ctx.fpr);
d1167 2
a1168 2
    supply_sprs64 (ctx.iar, ctx.msr, ctx.cr, ctx.lr, ctx.ctr, ctx.xer,
                   ctx.fpscr);
d1170 2
a1171 2
    supply_sprs32 (ctx.iar, ctx.msr, ctx.cr, ctx.lr, ctx.ctr, ctx.xer,
                   ctx.fpscr);
d1190 2
a1191 1
fetch_regs_kernel_thread (int regno, pthdb_tid_t tid)
d1216 1
a1216 1
	  supply_gprs64 (gprs64);
d1223 1
a1223 1
	    supply_reg32 (tdep->ppc_gp0_regnum + i, gprs32[i]);
d1236 1
a1236 1
      supply_fprs (fprs);
d1248 3
a1250 3
	  supply_sprs64 (sprs64.pt_iar, sprs64.pt_msr, sprs64.pt_cr,
			 sprs64.pt_lr, sprs64.pt_ctr, sprs64.pt_xer,
			 sprs64.pt_fpscr);
d1258 1
a1258 1
	  supply_sprs32 (sprs32.pt_iar, sprs32.pt_msr, sprs32.pt_cr,
d1263 1
a1263 1
	    regcache_raw_supply (current_regcache, tdep->ppc_mq_regnum,
d1286 1
a1286 1
	fetch_regs_user_thread (thread->private->pdtid);
d1288 1
a1288 1
	fetch_regs_kernel_thread (regno, tid);
d1295 1
a1295 1
fill_gprs64 (uint64_t *vals)
d1301 2
a1302 2
    if (register_cached (tdep->ppc_gp0_regnum + regno))
      regcache_raw_collect (current_regcache, tdep->ppc_gp0_regnum + regno,
d1307 1
a1307 1
fill_gprs32 (uint32_t *vals)
d1313 2
a1314 2
    if (register_cached (tdep->ppc_gp0_regnum + regno))
      regcache_raw_collect (current_regcache, tdep->ppc_gp0_regnum + regno,
d1320 1
a1320 1
fill_fprs (double *vals)
d1332 2
a1333 2
    if (register_cached (regno))
      regcache_raw_collect (current_regcache, regno, vals + regno);
d1340 2
a1341 1
fill_sprs64 (uint64_t *iar, uint64_t *msr, uint32_t *cr,
d1354 12
a1365 12
  if (register_cached (PC_REGNUM))
    regcache_raw_collect (current_regcache, PC_REGNUM, iar);
  if (register_cached (tdep->ppc_ps_regnum))
    regcache_raw_collect (current_regcache, tdep->ppc_ps_regnum, msr);
  if (register_cached (tdep->ppc_cr_regnum))
    regcache_raw_collect (current_regcache, tdep->ppc_cr_regnum, cr);
  if (register_cached (tdep->ppc_lr_regnum))
    regcache_raw_collect (current_regcache, tdep->ppc_lr_regnum, lr);
  if (register_cached (tdep->ppc_ctr_regnum))
    regcache_raw_collect (current_regcache, tdep->ppc_ctr_regnum, ctr);
  if (register_cached (tdep->ppc_xer_regnum))
    regcache_raw_collect (current_regcache, tdep->ppc_xer_regnum, xer);
d1367 2
a1368 2
      && register_cached (tdep->ppc_fpscr_regnum))
    regcache_raw_collect (current_regcache, tdep->ppc_fpscr_regnum, fpscr);
d1372 2
a1373 1
fill_sprs32 (uint32_t *iar, uint32_t *msr, uint32_t *cr,
d1386 12
a1397 12
  if (register_cached (PC_REGNUM))
    regcache_raw_collect (current_regcache, PC_REGNUM, iar);
  if (register_cached (tdep->ppc_ps_regnum))
    regcache_raw_collect (current_regcache, tdep->ppc_ps_regnum, msr);
  if (register_cached (tdep->ppc_cr_regnum))
    regcache_raw_collect (current_regcache, tdep->ppc_cr_regnum, cr);
  if (register_cached (tdep->ppc_lr_regnum))
    regcache_raw_collect (current_regcache, tdep->ppc_lr_regnum, lr);
  if (register_cached (tdep->ppc_ctr_regnum))
    regcache_raw_collect (current_regcache, tdep->ppc_ctr_regnum, ctr);
  if (register_cached (tdep->ppc_xer_regnum))
    regcache_raw_collect (current_regcache, tdep->ppc_xer_regnum, xer);
d1399 2
a1400 2
      && register_cached (tdep->ppc_fpscr_regnum))
    regcache_raw_collect (current_regcache, tdep->ppc_fpscr_regnum, fpscr);
d1410 1
a1410 1
store_regs_user_thread (pthdb_pthread_t pdtid)
d1433 1
a1433 1
    if (register_cached (tdep->ppc_gp0_regnum + i))
d1437 1
a1437 1
	    regcache_raw_collect (current_regcache, tdep->ppc_gp0_regnum + i,
d1443 1
a1443 1
	    regcache_raw_collect (current_regcache, tdep->ppc_gp0_regnum + i,
d1451 1
a1451 1
    fill_fprs (ctx.fpr);
d1456 2
a1457 2
      fill_sprs64 (&ctx.iar, &ctx.msr, &ctx.cr, &ctx.lr, &ctx.ctr, &ctx.xer,
                   &ctx.fpscr);
d1466 3
a1468 3
      fill_sprs32 (&tmp_iar, &tmp_msr, &tmp_cr, &tmp_lr, &tmp_ctr, &tmp_xer,
                   &tmp_fpscr);
      if (register_cached (PC_REGNUM))
d1470 1
a1470 1
      if (register_cached (tdep->ppc_ps_regnum))
d1472 1
a1472 1
      if (register_cached (tdep->ppc_cr_regnum))
d1474 1
a1474 1
      if (register_cached (tdep->ppc_lr_regnum))
d1476 1
a1476 1
      if (register_cached (tdep->ppc_ctr_regnum))
d1478 1
a1478 1
      if (register_cached (tdep->ppc_xer_regnum))
d1480 1
a1480 1
      if (register_cached (tdep->ppc_xer_regnum))
d1499 2
a1500 1
store_regs_kernel_thread (int regno, pthdb_tid_t tid)
d1524 1
a1524 1
	  fill_gprs64 (gprs64);
d1531 1
a1531 1
	  fill_gprs32 (gprs32);
d1545 1
a1545 1
      fill_fprs (fprs);
d1558 3
a1560 3
	  fill_sprs64 (&sprs64.pt_iar, &sprs64.pt_msr, &sprs64.pt_cr,
		       &sprs64.pt_lr,  &sprs64.pt_ctr, &sprs64.pt_xer,
		       &sprs64.pt_fpscr);
d1580 2
a1581 2
	  fill_sprs32 (&tmp_iar, &tmp_msr, &tmp_cr, &tmp_lr, &tmp_ctr,
		       &tmp_xer, &tmp_fpscr);
d1592 2
a1593 2
	    if (register_cached (tdep->ppc_mq_regnum))
	      regcache_raw_collect (current_regcache, tdep->ppc_mq_regnum,
d1618 1
a1618 1
	store_regs_user_thread (thread->private->pdtid);
d1620 1
a1620 1
	store_regs_kernel_thread (regno, tid);
@


1.44
log
@	* aix-thread.c (fill_sprs32): Change argument types to "uint32_t *".
	Remove obsolete part of comment.
	(store_regs_user_thread): Use uint32_t temporaries when calling
	fill_sprs32.
	(store_regs_kernel_thread): Likewise.  Add assertion to verify
	correct size of struct ptsprs members.
	(aix_thread_xfer_memory): Fix type of myaddr.
	(aix_thread_extra_thread_info): Fix compiler warning.
	* rs6000-nat.c (rs6000_ptrace64): Change type of buf to "void *".
	(fetch_register, store_register): Adapt callers.
@
text
@d1618 8
a1625 7
/* Transfer LEN bytes of memory from GDB address MYADDR to target
   address MEMADDR if WRITE and vice versa otherwise.  */

static int
aix_thread_xfer_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len, int write,
		      struct mem_attrib *attrib,
		      struct target_ops *target)
d1627 2
a1628 2
  int n;
  struct cleanup *cleanup = save_inferior_ptid ();
d1631 2
a1632 3
  n = base_target.deprecated_xfer_memory (memaddr, myaddr, len, 
					  write, attrib, &base_target);
  do_cleanups (cleanup);
d1634 2
a1635 1
  return n;
d1767 1
a1767 1
  aix_thread_ops.deprecated_xfer_memory = aix_thread_xfer_memory;
@


1.43
log
@Copyright updates for 2007.
@
text
@d1368 3
a1370 3
fill_sprs32 (unsigned long *iar, unsigned long *msr, unsigned long *cr,
	     unsigned long *lr,  unsigned long *ctr, unsigned long *xer,
	     unsigned long *fpscr)
d1378 1
a1378 6
     we should check all of the sizes. 

     If this assert() fails, the most likely reason is that GDB was
     built incorrectly.  In order to make use of many of the header
     files in /usr/include/sys, GDB needs to be configured so that
     sizeof (long) == 4).  */
d1457 3
a1459 5
	 Solution: use 32-bit temp variables.  (The assert() in fill_sprs32()
	 will fail if the size of an unsigned long is incorrect.  If this
	 happens, GDB needs to be reconfigured so that longs are 32-bits.)  */
      unsigned long tmp_iar, tmp_msr, tmp_cr, tmp_lr, tmp_ctr, tmp_xer,
                    tmp_fpscr;
d1560 11
d1574 10
a1583 3
	  fill_sprs32 (&sprs32.pt_iar, &sprs32.pt_msr, &sprs32.pt_cr,
		       &sprs32.pt_lr,  &sprs32.pt_ctr, &sprs32.pt_xer,
		       &sprs32.pt_fpscr);
d1622 1
a1622 1
aix_thread_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
d1717 1
a1717 1
    fprintf_unfiltered (buf, _("tid %d"), tid);
@


1.42
log
@        * aix-thread.c (_initialize_aix_thread): Use add_setshow_boolean_cmd
        instead of add_setshow_zinteger_cmd to defined the aix-thread
        boolean setting.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
@


1.41
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d1780 1
a1780 1
  add_setshow_zinteger_cmd ("aix-thread", no_class, (char *) &debug_aix_thread,
@


1.40
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* command.h (fprint_setshow_ftype): Delete.
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* complaints.c, cris-tdep.c, dwarf2read.c, frame.c: Update.
	* hppa-tdep.c, infcall.c, m32r-rom.c, maint.c: Update.
	* mips-tdep.c, nto-tdep.c, observer.c, remote-rdi.c: Update
	* remote.c, target.c, cli/cli-logging.c: Update.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2002 Free Software Foundation, Inc.
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.39
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_setshow functions, replace "PRINT:" comment prefix
	with "FIXME: i18n:".
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* cris-tdep.c, dwarf2read.c, frame.c, hppa-tdep.c: Update.
	* infcall.c, m32r-rom.c, maint.c, mips-tdep.c: Update.
	* nto-tdep.c, observer.c, remote-rdi.c, remote.c: Update.
	* target.c, cli/cli-logging.c: Update.
@
text
@d1784 2
a1785 2
			    NULL, /* FIXME: i18n: Debugging of AIX thread module is \"%d\".  */
			    NULL, NULL, &setdebuglist, &showdebuglist);
@


1.38
log
@2005-01-05  Baurjan Ismagulov  <ibr@@ata.cs.hun.edu.tr>

	Committed by Andrew Cagney.
	* ada-valprint.c, aix-thread.c, alpha-nat.c: I18n markup.
	* alphabsd-nat.c, alphanbsd-tdep.c, amd64-linux-nat.c: I18n markup.
	* amd64-tdep.c,	amd64bsd-nat.c, amd64fbsd-nat.c: I18n markup.
	* arch-utils.c, arm-linux-nat.c, arm-tdep.c: I18n markup.
	* armnbsd-nat.c, armnbsd-tdep.c, auxv.c, avr-tdep.c: I18n markup.
	* aix-thread.c (_initialize_aix_thread): Get rid of the
	deprecated_add_show_from_set call.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* command.h (add_setshow_enum_cmd): Add arguments for returning
	new list elements.
	* cli/cli-decode.c (add_setshow_enum_cmd): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Modify calls to
	add_setshow_enum_cmd.
@
text
@d1784 1
a1784 1
			    _("Debugging of AIX thread module is \"%d\"."),
@


1.37
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@d243 1
a243 1
  error ("aix-thread: ptrace (%d, %d) returned %d (errno = %d %s)",
d553 18
a570 6
    case PST_IDLE:	return "idle";		/* being created */
    case PST_RUN:	return "running";	/* running */
    case PST_SLEEP:	return "sleeping";	/* awaiting an event */
    case PST_READY:	return "ready";		/* runnable */
    case PST_TERM:	return "finished";	/* awaiting a join/detach */
    default:		return "unknown";
d985 1
a985 1
	error ("aix-thread resume: unknown pthread %ld", 
d990 1
a990 1
	error ("aix-thread resume: no tid for pthread %ld", 
d1146 1
a1146 1
    error ("aix-thread: fetch_registers: pthdb_pthread_context returned %s",
d1427 1
a1427 1
    error ("aix-thread: store_registers: pthdb_pthread_context returned %s",
d1488 1
a1488 1
    error ("aix-thread: store_registers: pthdb_pthread_setcontext returned %s",
d1675 1
a1675 1
  ret = xstrprintf ("Thread %ld", ptid_get_tid (ptid));
d1705 2
a1706 1
    fprintf_unfiltered (buf, "tid %d", tid);
d1716 2
a1717 1
    fprintf_unfiltered (buf, ", suspended");
d1722 2
a1723 1
    fprintf_unfiltered (buf, ", detached");
d1727 2
a1728 1
    fprintf_unfiltered (buf, ", cancel pending");
d1746 2
a1747 2
  aix_thread_ops.to_longname           = "AIX pthread support";
  aix_thread_ops.to_doc                = "AIX pthread support";
d1780 6
a1785 7
  deprecated_add_show_from_set
    (add_set_cmd ("aix-thread", no_class, var_zinteger,
		  (char *) &debug_aix_thread, 
		  "Set debugging of AIX thread module.\n"
		  "Enables printf debugging output.\n",
		  &setdebuglist),
     &showdebuglist);
@


1.36
log
@2004-10-05  Andrew Cagney  <cagney@@gnu.org>

	* target.h (deprecated_child_ops): Rename child_ops.
	* wince.c: Update copyright.  Rename child_ops.
	* win32-nat.c: Rename child_ops.
	* target.c: Rename child_ops.
	* rs6000-nat.c: Rename child_ops.
	* linux-nat.c: Rename child_ops.
	* infttrace.c: Rename child_ops.
	* inftarg.c: Rename child_ops.
	* infptrace.c: Rename child_ops.
	* hppah-nat.c: Update copyright.  Rename child_ops.
	* hpux-thread.c: Update copyright.  Rename child_ops.
@
text
@d1607 2
a1608 2
  n = base_target.to_xfer_memory (memaddr, myaddr, len, 
				  write, attrib, &base_target);
d1739 1
a1739 1
  aix_thread_ops.to_xfer_memory        = aix_thread_xfer_memory;
@


1.35
log
@* language.c (local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string, use C format, and move to
utils.c
(local_hex_string_custom): Rename to hex_string_custom and change
interface.  Now uses C format.  Move to utils.c
(local_octal_format_custom): Remove.
(local_decimal_format_custom): Remove.
(unknown_language_defn): Remove language-specific number
formatting entries.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* language.h (struct language_format_info): Delete declaration.
(struct language_defn): Remove language_format_info fields
la_binary_format, la_octal_format, la_decimal_format, la_hex_format.
(local_binary_format): Remove macro.
(local_binary_format_prefix): Remove macro.
(local_binary_format_specifier): Remove macro.
(local_binary_format_suffix): Remove macro.
(local_octal_format): Remove macro.
(local_octal_format_prefix): Remove macro.
(local_octal_format_specifier): Remove macro.
(local_octal_format_suffix): Remove macro.
(local_decimal_format): Remove macro.
(local_decimal_format_prefix): Remove macro.
(local_decimal_format_specifier): Remove macro.
(local_decimal_format_suffix): Remove macro.
(local_hex_format): Remove macro.
(local_hex_format_prefix): Remove macro.
(local_hex_format_specifier): Remove macro.
(local_hex_format_suffix): Remove macro.
(local_decimal_format_custom): Remove.
(local_octal_format_custom): Remove.
(local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string and move to defs.h.
(local_hex_string_custom): Rename to hex_string_custom, change
interface, and move to defs.h.
* utils.c: (int_string): New function.
(hex_string): New function (from language.c).
(hex_string_custom): New function (from language.c).
(octal2str): New function.
(decimal2str): Add width parameter.
(paddr_u): Use new decimal2str interface.
(paddr_d): Ditto.
* defs.h (hex_string): Declare.
(hex_string_custom): Declare.
(int_string): Declare.
* printcmd.c (print_scalar_formatted): Remove localized binary
formatting.
* valprint.c (print_longest): Use int_string.
(print_floating): Use C hex format.
(print_hex_chars): Ditto.
(print_binary_chars): Remove language-specific formatting.
(print_octal_chars): Use C octal format.
(print_decimal_chars): Delocalize format.
(print_decimal): Remove.
* ada-lang.c (ada_language_defn): Remove language-specific number
formatting entries.
* p-lang.c (pascal_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.
* memattr.c (mem_info_command): Use renamed hex_string_custom with
new interface.
* pa64solib.c (pa64_sharedlibrary_info_command): Ditto.
* ui-out.c (ui_out_field_core_addr): Ditto.
* breakpoint.c (breakpoint_adjustment_warning): Ditto.
* exec.c (print_section_info): Ditto.
* i387-tdep.c (print_i387_status_word): Ditto.
(print_i387_control_word): Ditto.
(i387_print_float_info): Ditto.
* maint.c (maint_print_section_info): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* somsolib.c (som_sharedlibrary_info_command): Ditto.
* symtab.c (print_msymbol_info): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* solib-frv.c (lm_base): Ditto.
(frv_current_sos): Ditto.
(enable_break2): Ditto.
(enable_break): Ditto.
* dbxread.c (read_dbx_symtab): Use renamed hex_string.
(process_one_symbol): Ditto.
* infcmd.c (program_info): Ditto.
* mdebugread.c (parse_partial_symbols): Ditto.
* symfile.c (add_symbol_file_command): Ditto.
* cli/cli-cmds.c (edit_command): Ditto.
(list_command): Ditto.
* infcall.c (call_function_by_hand): Ditto.
* remote-vx.c (vx_run_files_info): Ditto.
(vx_wait): Ditto.
(vx_attach): Ditto.
(vx_detach): Ditto.
(vx_kill): Ditto.
* aix-thread.c (pdc_symbol_addrs): Ditto.
(pdc_read_regs): Ditto.
(pdc_write_regs): Ditto.
(pdc_read_data): Ditto.
(pdc_write_data): Ditto.
* d10v-tdep.c (display_trace): Ditto.
* rs6000-nat.c (find_toc_address): Ditto.
* aix-thread.c: Don't include language.h.
* buildsym.c: Ditto.
* dbxread.c: Ditto.
* mdebugread.c: Ditto.
* rs6000-nat.c: Ditto.
* buildsym.c (make_blockvector): Use renamed hex_string.
@
text
@d108 2
a109 2
/* Copy of the target over which ops is pushed.  
   This is more convenient than a pointer to child_ops or core_ops,
@


1.34
log
@        * aix-thread.c (get_signaled_thread): New function.
        (iter_trap): Delete, no longer used.
        (iter_tid): New function.
        (pd_update): Find the thread that received the SIGTRAP signal
        by first locating the kernel thread, and then finding its
        associated thread.
@
text
@a50 1
#include "language.h"		/* for local_hex_string() */
d316 1
a316 1
			    i, local_hex_string (symbols[i].addr));
d349 1
a349 1
                        (int) tid, local_hex_string (flags));
d415 1
a415 1
                        (int) tid, local_hex_string (flags));
d460 1
a460 1
      user, (long) buf, local_hex_string (addr), len);
d482 1
a482 1
      user, (long) buf, local_hex_string (addr), len);
@


1.33
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d625 29
d780 2
a781 2
/* Iterate_over_threads() callback for locating a thread whose kernel
   thread just received a trap signal.  */
d784 1
a784 1
iter_trap (struct thread_info *thread, void *unused)
d786 1
a786 6
  struct thrdsinfo64 thrinf;
  pthdb_tid_t tid;

  /* getthrds(3) isn't prototyped in any AIX 4.3.3 #include file.  */
  extern int getthrds (pid_t, struct thrdsinfo64 *, 
		       int, pthdb_tid_t *, int);
d788 1
a788 9
  tid = thread->private->tid;
  if (tid == PTHDB_INVALID_TID)
    return 0;

  if (getthrds (PIDGET (inferior_ptid), &thrinf, 
		sizeof (thrinf), &tid, 1) != 1)
    return 0;

  return thrinf.ti_cursig == SIGTRAP;
d800 2
a801 1
  struct thread_info *thread;
d814 3
a816 1
  thread = iterate_over_threads (iter_trap, NULL);
@


1.32
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d857 1
a857 1
  arch64 = DEPRECATED_REGISTER_RAW_SIZE (0) == 8;
d1318 1
a1318 1
  gdb_assert (sizeof (*iar) == DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM));
d1354 1
a1354 1
  gdb_assert (sizeof (*iar) == DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM));
@


1.31
log
@2004-07-23  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_collect instead of regcache_collect.
	* regcache.h (regcache_collect): Delete declaration.
	* regcache.c (regcache_colect): Delete function.
	* win32-nat.c (do_child_store_inferior_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_fill_reg): Update.
	* rs6000-nat.c (store_register): Update.
	* remote.c (store_register_using_P, remote_store_registers): Update.
	* ppcnbsd-tdep.c (ppcnbsd_fill_reg): Update.
	* ppc-linux-nat.c (store_altivec_register, store_spe_register)
	(fill_vrregset, store_spe_registers, fill_gregset)
	(fill_gregset): Update.
	* nto-procfs.c (procfs_store_registers): Update.
	* mipsnbsd-tdep.c (mipsnbsd_fill_reg): Update.
	* mips-linux-tdep.c (fill_gregset, mips64_fill_gregset): Update.
	* m68klinux-nat.c (store_register, fill_gregset): Update.
	* m68k-tdep.c (fill_gregset): Update.
	* infptrace.c (store_register): Update.
	* i386-nto-tdep.c (i386nto_regset_fill): Update.
	* i386-linux-nat.c (store_register, fill_gregset): Update.
	* hppa-linux-nat.c (fill_gregset): Update.
	* go32-nat.c (store_register): Update.
	* armnbsd-nat.c (store_register, store_regs, store_fp_register)
	(store_fp_regs): Update.
	* arm-linux-nat.c (store_nwfpe_single, store_nwfpe_double)
	(store_nwfpe_extended, store_fpregister, store_fpregs)
	(store_register, store_regs, fill_gregset, fill_fpregset): Update.
	* alpha-tdep.c (alpha_fill_int_regs, alpha_fill_fp_regs): Update.
	* aix-thread.c (fill_gprs64, fill_fprs, fill_sprs64, fill_sprs32)
	(store_regs_user_thread, store_regs_kernel_thread): Update.
@
text
@d1746 7
a1752 6
  add_show_from_set (add_set_cmd ("aix-thread", no_class, var_zinteger,
				  (char *) &debug_aix_thread, 
				  "Set debugging of AIX thread module.\n"
                                  "Enables printf debugging output.\n",
				  &setdebuglist),
		                  &showdebuglist);
@


1.30
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d1269 2
a1270 1
      regcache_collect (tdep->ppc_gp0_regnum + regno, vals + regno);
d1281 2
a1282 1
      regcache_collect (tdep->ppc_gp0_regnum + regno, vals + regno);
d1300 1
a1300 1
      regcache_collect (regno, vals + regno);
d1321 1
a1321 1
    regcache_collect (PC_REGNUM, iar);
d1323 1
a1323 1
    regcache_collect (tdep->ppc_ps_regnum, msr);
d1325 1
a1325 1
    regcache_collect (tdep->ppc_cr_regnum, cr);
d1327 1
a1327 1
    regcache_collect (tdep->ppc_lr_regnum, lr);
d1329 1
a1329 1
    regcache_collect (tdep->ppc_ctr_regnum, ctr);
d1331 1
a1331 1
    regcache_collect (tdep->ppc_xer_regnum, xer);
d1334 1
a1334 1
    regcache_collect (tdep->ppc_fpscr_regnum, fpscr);
d1357 1
a1357 1
    regcache_collect (PC_REGNUM, iar);
d1359 1
a1359 1
    regcache_collect (tdep->ppc_ps_regnum, msr);
d1361 1
a1361 1
    regcache_collect (tdep->ppc_cr_regnum, cr);
d1363 1
a1363 1
    regcache_collect (tdep->ppc_lr_regnum, lr);
d1365 1
a1365 1
    regcache_collect (tdep->ppc_ctr_regnum, ctr);
d1367 1
a1367 1
    regcache_collect (tdep->ppc_xer_regnum, xer);
d1370 1
a1370 1
    regcache_collect (tdep->ppc_fpscr_regnum, fpscr);
d1407 2
a1408 1
	    regcache_collect (tdep->ppc_gp0_regnum + i, (void *) &int64);
d1413 2
a1414 1
	    regcache_collect (tdep->ppc_gp0_regnum + i, (void *) &int32);
d1546 2
a1547 1
	      regcache_collect (tdep->ppc_mq_regnum, &sprs32.pt_mq);
@


1.29
log
@2004-06-26  Andrew Cagney  <cagney@@gnu.org>

	* xcoffsolib.c (xcoff_solib_address): Replace xasprintf with
	xstrprintf.
	* varobj.c (varobj_gen_name, create_child, c_name_of_child)
	(c_value_of_variable): Ditto.
	* utils.c (internal_vproblem): Ditto.
	* solib-aix5.c (build_so_list_from_mapfile): Ditto.
	* remote.c (add_packet_config_cmd): Ditto.
	* remote-rdp.c (rdp_set_command_line): Ditto.
	* regcache.c (regcache_dump): Ditto.
	* frv-tdep.c (new_variant, new_variant): Ditto.
	* fbsd-proc.c (child_pid_to_exec_file): Ditto.
	(fbsd_find_memory_regions): Ditto.
	* breakpoint.c (create_thread_event_breakpoint)
	(create_breakpoints): Ditto.
	* aix-thread.c (aix_thread_pid_to_str): Ditto.
	* ada-lang.c (is_package_name): Ditto.  Also delete xmalloc call.

Index: doc/ChangeLog
2004-06-26  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Coding): Replace xasprintf with xstrprintf.
@
text
@d1009 2
a1010 1
    supply_register (tdep->ppc_gp0_regnum + regno, (char *) (vals + regno));
d1018 1
a1018 1
  supply_register (regno, (char *) &val);
d1034 2
a1035 1
    supply_register (regno + tdep->ppc_fp0_regnum, (char *) (vals + regno));
d1065 6
a1070 6
  supply_register (PC_REGNUM,     (char *) &iar);
  supply_register (tdep->ppc_ps_regnum, (char *) &msr);
  supply_register (tdep->ppc_cr_regnum, (char *) &cr);
  supply_register (tdep->ppc_lr_regnum, (char *) &lr);
  supply_register (tdep->ppc_ctr_regnum, (char *) &ctr);
  supply_register (tdep->ppc_xer_regnum, (char *) &xer);
d1072 2
a1073 1
    supply_register (tdep->ppc_fpscr_regnum, (char *) &fpscr);
d1086 6
a1091 6
  supply_register (PC_REGNUM,     (char *) &iar);
  supply_register (tdep->ppc_ps_regnum, (char *) &msr);
  supply_register (tdep->ppc_cr_regnum, (char *) &cr);
  supply_register (tdep->ppc_lr_regnum, (char *) &lr);
  supply_register (tdep->ppc_ctr_regnum, (char *) &ctr);
  supply_register (tdep->ppc_xer_regnum, (char *) &xer);
d1093 2
a1094 1
    supply_register (tdep->ppc_fpscr_regnum, (char *) &fpscr);
d1230 2
a1231 1
	    supply_register (tdep->ppc_mq_regnum, (char *) &sprs32.pt_mq);
@


1.28
log
@        * aix-thread.c: s/ppc_floating_point_p/ppc_floating_point_unit_p/.
        Fixes a link link failure.
@
text
@d1632 1
a1632 1
     xasprintf().  */
d1635 1
a1635 1
  xasprintf (&ret, "Thread %ld", ptid_get_tid (ptid));
@


1.27
log
@        * aix-thread.c (store_regs_kernel_thread): Fix a little obvious
        error that was causing the build to fail.
@
text
@d1030 1
a1030 1
  gdb_assert (ppc_floating_point_p (current_gdbarch));
d1125 1
a1125 1
  if (ppc_floating_point_p (current_gdbarch))
d1287 1
a1287 1
  gdb_assert (ppc_floating_point_p (current_gdbarch));
d1411 1
a1411 1
  if (ppc_floating_point_p (current_gdbarch))
@


1.26
log
@        * aix-thread.c: #include "gdb_string.h". Needed for memset and memcopy.
        * Makefile.in (aix-thread.o): Add dependency on gdb_string.h.
@
text
@a1470 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.25
log
@* aix-thread.c (pdc_read_regs, supply_gprs64, supply_fprs)
(fetch_regs_user_thread, fetch_regs_kernel_thread)
(store_regs_user_thread, store_regs_kernel_thread): Use
ppc_num_gprs and ppc_num_fprs instead of '32' and '31'.
* ppc-linux-nat.c (fill_gregset): Same.
* ppc-linux-tdep.c (ppc_linux_supply_gregset)
(ppc_linux_sigtramp_cache): Same.
* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_fill_reg)
(ppcnbsd_sigtramp_cache_init): Same.
* rs6000-nat.c (fetch_core_registers): Same.
* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
(rs6000_frame_cache): Same.
@
text
@d53 1
@


1.24
log
@* aix-thread.c (supply_gprs64, fetch_regs_user_thread)
(store_regs_user_thread): Use tdep->ppc_gp0_regnum, instead
of assuming that the gprs are numbered starting with zero.
* ppc-linux-nat.c (fill_gregset): Same.
* ppc-linux-tdep.c (ppc_linux_supply_gregset): Same.
* ppcnbsd-nat.c (getregs_supplies): Same.
* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_fill_reg): Same.
* rs6000-nat.c (fetch_core_registers): Same.
* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset): Same.
@
text
@d341 3
a343 3
  uint64_t gprs64[32];
  uint32_t gprs32[32];
  double fprs[32];
d1007 1
a1007 1
  for (regno = 0; regno < 32; regno++)
d1031 1
a1031 1
  for (regno = 0; regno < 32; regno++)
d1119 1
a1119 1
    for (i = 0; i < 32; i++)
d1156 3
a1158 3
  uint64_t gprs64[32];
  uint32_t gprs32[32];
  double fprs[32];
d1184 1
a1184 1
	  for (i = 0; i < 32; i++)
d1394 1
a1394 1
  for (i = 0; i < 32; i++)
d1464 3
a1466 3
  uint64_t gprs64[32];
  uint32_t gprs32[32];
  double fprs[32];
@


1.23
log
@* ppc-tdep.h (struct gdbarch_tdep): Change definition of
ppc_fp0_regnum and ppc_fpscr_regnum: if they are -1, then this
processor variant lacks those registers.
(ppc_floating_point_unit_p): Change description to make it clear
that this returns info about the ISA, not the ABI.
* rs6000-tdep.c (ppc_floating_point_unit_p): Decide whether to
return true or false by checking tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum.  The original code replicated the BFD
arch/mach switching done in rs6000_gdbarch_init; it's better to
keep that logic there, and just check the results here.
(rs6000_gdbarch_init): On the E500, set tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum to -1 to indicate that we have no
floating-point registers.
(ppc_supply_fpregset, ppc_collect_fpregset)
(rs6000_push_dummy_call, rs6000_extract_return_value)
(rs6000_store_return_value): Assert that we have floating-point
registers.
(rs6000_dwarf2_stab_reg_to_regnum): Add FIXME.
(rs6000_frame_cache): Don't note the locations at which
floating-point registers were saved if we have no fprs.
* aix-thread.c (supply_fprs, fill_fprs): Assert that we have FP
registers.
(fetch_regs_user_thread, fetch_regs_kernel_thread)
(store_regs_user_thread, store_regs_kernel_thread): Only call
supply_fprs / fill_fprs if we actually have floating-point
registers.
(special_register_p): Check ppc_fpscr_regnum before matching
against it.
(supply_sprs64, supply_sprs32, fill_sprs64, fill_sprs32): Don't
supply / collect fpscr if we don't have it.
* ppc-bdm.c: #include "gdb_assert.h".
(bdm_ppc_fetch_registers, bdm_ppc_store_registers): Assert that we
have floating-point registers, since I can't test this code on
FP-free systems to adapt it.
* ppc-linux-nat.c (ppc_register_u_addr): Don't match against the
fpscr and floating point register numbers if they don't exist.
(fetch_register): Assert that we have floating-point registers
before we reach the code that handles them.
(store_register): Same.  And use tdep instead of calling
gdbarch_tdep again.
(fill_fpregset): Don't try to collect FP registers and fpscr if we
don't have them.
(ppc_linux_sigtramp_cache): Don't record the saved locations of
fprs and fpscr if we don't have them.
(ppc_linux_supply_fpregset): Don't supply fp regs and fpscr if we
don't have them.
* ppcnbsd-nat.c: #include "gdb_assert.h".
(getfpregs_supplies): Assert that we have floating-point registers.
* ppcnbsd-tdep.c (ppcnbsd_supply_fpreg, ppcnbsd_fill_fpreg): Same.
* ppcobsd-tdep.c: #include "gdb_assert.h".
(ppcobsd_supply_gregset, ppcobsd_collect_gregset): Assert that we
have floating-point registers.
* rs6000-nat.c (regmap): Don't match against the fpscr and
floating point register numbers if they don't exist.
(fetch_inferior_registers, store_inferior_registers,
fetch_core_registers): Only fetch / store / supply the
floating-point registers and the fpscr if we have them.
* Makefile.in (ppc-bdm.o, ppc-linux-nat.o, ppcnbsd-nat.o)
(ppcobsd-tdep.o): Update dependencies.
@
text
@d1004 1
d1008 1
a1008 1
    supply_register (regno, (char *) (vals + regno));
d1102 1
d1120 1
a1120 1
      supply_reg32 (i, ctx.gpr[i]);
d1185 1
a1185 1
	    supply_reg32 (i, gprs32[i]);
d1374 1
d1395 1
a1395 1
    if (register_cached (i))
d1399 1
a1399 1
	    regcache_collect (i, (void *) &int64);
d1404 1
a1404 1
	    regcache_collect (i, (void *) &int32);
a1426 1
      struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.22
log
@Back out change.  The NetBSD changes need Jason Thorpe's approval, but
he hasn't reviewed it yet.
@
text
@d1026 4
d1046 1
a1046 1
      || regno == tdep->ppc_fpscr_regnum
d1067 2
a1068 1
  supply_register (tdep->ppc_fpscr_regnum, (char *) &fpscr);
d1087 2
a1088 1
  supply_register (tdep->ppc_fpscr_regnum, (char *) &fpscr);
d1122 2
a1123 1
  supply_fprs (ctx.fpr);
d1189 4
a1192 3
  if (regno == -1
      || (regno >= tdep->ppc_fp0_regnum
          && regno < tdep->ppc_fp0_regnum + ppc_num_fprs))
d1282 4
d1322 2
a1323 1
  if (register_cached (tdep->ppc_fpscr_regnum))
d1358 2
a1359 1
  if (register_cached (tdep->ppc_fpscr_regnum))
d1407 2
a1408 1
  fill_fprs (ctx.fpr);
d1498 4
a1501 3
  if (regno == -1
      || (regno >= tdep->ppc_fp0_regnum
          && regno < tdep->ppc_fp0_regnum + ppc_num_fprs))
@


1.21
log
@* ppc-tdep.h (struct gdbarch_tdep): Change definition of
ppc_fp0_regnum and ppc_fpscr_regnum: if they are -1, then this
processor variant lacks those registers.
(ppc_floating_point_unit_p): Change description to make it clear
that this returns info about the ISA, not the ABI.
* rs6000-tdep.c (ppc_floating_point_unit_p): Decide whether to
return true or false by checking tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum.  The original code replicated the BFD
arch/mach switching done in rs6000_gdbarch_init; it's better to
keep that logic there, and just check the results here.
(rs6000_gdbarch_init): On the E500, set tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum to -1 to indicate that we have no
floating-point registers.
(ppc_supply_fpregset, ppc_collect_fpregset)
(rs6000_push_dummy_call, rs6000_extract_return_value)
(rs6000_store_return_value): Assert that we have floating-point
registers.
(rs6000_dwarf2_stab_reg_to_regnum): Add FIXME.
(rs6000_frame_cache): Don't note the locations at which
floating-point registers were saved if we have no fprs.
* aix-thread.c (supply_fprs, fill_fprs): Assert that we have FP
registers.
(fetch_regs_user_thread, fetch_regs_kernel_thread)
(store_regs_user_thread, store_regs_kernel_thread): Only call
supply_fprs / fill_fprs if we actually have floating-point
registers.
(special_register_p): Check ppc_fpscr_regnum before matching
against it.
(supply_sprs64, supply_sprs32, fill_sprs64, fill_sprs32): Don't
supply / collect fpscr if we don't have it.
* ppc-bdm.c: #include "gdb_assert.h".
(bdm_ppc_fetch_registers, bdm_ppc_store_registers): Assert that we
have floating-point registers, since I can't test this code on
FP-free systems to adapt it.
* ppc-linux-nat.c (ppc_register_u_addr): Don't match against the
fpscr and floating point register numbers if they don't exist.
(fetch_register): Assert that we have floating-point registers
before we reach the code that handles them.
(store_register): Same.  And use tdep instead of calling
gdbarch_tdep again.
(fill_fpregset): Don't try to collect FP registers and fpscr if we
don't have them.
(ppc_linux_sigtramp_cache): Don't record the saved locations of
fprs and fpscr if we don't have them.
(ppc_linux_supply_fpregset): Don't supply fp regs and fpscr if we
don't have them.
* ppcnbsd-nat.c: #include "gdb_assert.h".
(getfpregs_supplies): Assert that we have floating-point registers.
* ppcnbsd-tdep.c (ppcnbsd_supply_fpreg, ppcnbsd_fill_fpreg): Same.
* ppcobsd-tdep.c: #include "gdb_assert.h".
(ppcobsd_supply_gregset, ppcobsd_collect_gregset): Assert that we
have floating-point registers.
* rs6000-nat.c (regmap): Don't match against the fpscr and
floating point register numbers if they don't exist.
(fetch_inferior_registers, store_inferior_registers,
fetch_core_registers): Only fetch / store / supply the
floating-point registers and the fpscr if we have them.
* Makefile.in (ppc-bdm.o, ppc-linux-nat.o, ppcnbsd-nat.o)
(ppcobsd-tdep.o): Update dependencies.
@
text
@a1025 4
  /* This function should never be called on architectures without
     floating-point registers.  */
  gdb_assert (ppc_floating_point_p (current_gdbarch));

d1042 1
a1042 1
      || (tdep->ppc_fpscr_regnum >= 0 && regno == tdep->ppc_fpscr_regnum)
d1063 1
a1063 2
  if (tdep->ppc_fpscr_regnum >= 0)
    supply_register (tdep->ppc_fpscr_regnum, (char *) &fpscr);
d1082 1
a1082 2
  if (tdep->ppc_fpscr_regnum >= 0)
    supply_register (tdep->ppc_fpscr_regnum, (char *) &fpscr);
d1116 1
a1116 2
  if (ppc_floating_point_p (current_gdbarch))
    supply_fprs (ctx.fpr);
d1182 3
a1184 4
  if (ppc_floating_point_unit_p (current_gdbarch)
      && (regno == -1
          || (regno >= tdep->ppc_fp0_regnum
              && regno < tdep->ppc_fp0_regnum + ppc_num_fprs)))
a1273 4
  /* This function should never be called on architectures without
     floating-point registers.  */
  gdb_assert (ppc_floating_point_p (current_gdbarch));

d1310 1
a1310 2
  if (tdep->ppc_fpscr_regnum >= 0
      && register_cached (tdep->ppc_fpscr_regnum))
d1345 1
a1345 2
  if (tdep->ppc_fpscr_regnum >= 0
      && register_cached (tdep->ppc_fpscr_regnum))
d1393 1
a1393 2
  if (ppc_floating_point_p (current_gdbarch))
    fill_fprs (ctx.fpr);
d1483 3
a1485 4
  if (ppc_floating_point_unit_p (current_gdbarch)
      && (regno == -1
          || (regno >= tdep->ppc_fp0_regnum
              && regno < tdep->ppc_fp0_regnum + ppc_num_fprs)))
@


1.20
log
@* aix-thread.c (fetch_regs_kernel_thread, fill_gprs64,
fill_gprs32, store_regs_kernel_thread): Use tdep->ppc_gp0_regnum
to recognize gpr regnums, instead of assuming that
tdep->ppc_fp0_regnum marks the end of the general-purpose
registers.
@
text
@d1026 4
d1046 1
a1046 1
      || regno == tdep->ppc_fpscr_regnum
d1067 2
a1068 1
  supply_register (tdep->ppc_fpscr_regnum, (char *) &fpscr);
d1087 2
a1088 1
  supply_register (tdep->ppc_fpscr_regnum, (char *) &fpscr);
d1122 2
a1123 1
  supply_fprs (ctx.fpr);
d1189 4
a1192 3
  if (regno == -1
      || (regno >= tdep->ppc_fp0_regnum
          && regno < tdep->ppc_fp0_regnum + ppc_num_fprs))
d1282 4
d1322 2
a1323 1
  if (register_cached (tdep->ppc_fpscr_regnum))
d1358 2
a1359 1
  if (register_cached (tdep->ppc_fpscr_regnum))
d1407 2
a1408 1
  fill_fprs (ctx.fpr);
d1498 4
a1501 3
  if (regno == -1
      || (regno >= tdep->ppc_fp0_regnum
          && regno < tdep->ppc_fp0_regnum + ppc_num_fprs))
@


1.19
log
@* config/rs6000/tm-rs6000.h (FP0_REGNUM): Document that this
should no longer be used in code specific to the RS6000 and its
derivatives.
* ppc-tdep.h (struct gdbarch_tdep): Add 'ppc_fp0_regnum' member.
* rs6000-tdep.c (rs6000_gdbarch_init): Initialize
tdep->ppc_fp0_regnum.
(ppc_supply_fpregset, ppc_collect_fpregset)
(rs6000_push_dummy_call, rs6000_extract_return_value)
(rs6000_dwarf2_stab_reg_to_regnum, rs6000_store_return_value)
(rs6000_frame_cache): Use tdep->ppc_fp0_regnum instead of
FP0_REGNUM.
* aix-thread.c (supply_fprs, fetch_regs_kernel_thread)
(fill_gprs64, fill_gprs32, fill_fprs, store_regs_kernel_thread):
Same.
* ppc-bdm.c (bdm_ppc_fetch_registers, bdm_ppc_fetch_registers,
bdm_ppc_store_registers): Same.
* ppc-linux-nat.c (ppc_register_u_addr, fetch_register)
(store_register, fill_fpregset): Same.
* ppc-linux-tdep.c (ppc_linux_sigtramp_cache)
(ppc_linux_supply_fpregset): Same.
* ppcnbsd-nat.c (getfpregs_supplies): Same.
* ppcnbsd-tdep.c (ppcnbsd_supply_fpreg, ppcnbsd_fill_fpreg):
Same.
* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
ppc64_sysv_abi_return_value): Same.
* rs6000-nat.c (regmap, fetch_inferior_registers)
(store_inferior_registers, fetch_core_registers): Same.
@
text
@d1160 3
a1162 1
  if (regno == -1 || regno < tdep->ppc_fp0_regnum)
d1251 3
a1253 3
  for (regno = 0; regno < tdep->ppc_fp0_regnum; regno++)
    if (register_cached (regno))
      regcache_collect (regno, vals + regno);
d1262 3
a1264 3
  for (regno = 0; regno < tdep->ppc_fp0_regnum; regno++)
    if (register_cached (regno))
      regcache_collect (regno, vals + regno);
d1461 3
a1463 1
  if (regno == -1 || regno < tdep->ppc_fp0_regnum)
@


1.18
log
@* config/rs6000/tm-rs6000.h (FPLAST_REGNUM): Delete #definition.
* ppc-tdep.h (ppc_num_fprs): New enum constant.
* aix-thread.c (fetch_regs_kernel_thread, fill_fprs,
store_regs_kernel_thread): Use FP0_REGNUM + ppc_num_fprs, not
FPLAST_REGNUM.
* ppc-bdm.c (bdm_ppc_fetch_registers, bdm_ppc_store_registers):
Same.
* ppc-linux-nat.c (ppc_register_u_addr): Same.
* rs6000-nat.c (regmap, fetch_inferior_registers)
(store_inferior_registers): Same.
@
text
@d1023 1
d1027 1
a1027 1
    supply_register (regno + FP0_REGNUM, (char *) (vals + regno));
d1146 1
d1160 1
a1160 1
  if (regno == -1 || regno < FP0_REGNUM)
d1181 2
a1182 2
      || (regno >= FP0_REGNUM
          && regno < FP0_REGNUM + ppc_num_fprs))
d1246 1
d1249 1
a1249 1
  for (regno = 0; regno < FP0_REGNUM; regno++)
d1257 1
d1260 1
a1260 1
  for (regno = 0; regno < FP0_REGNUM; regno++)
d1269 1
d1272 3
a1274 1
  for (regno = FP0_REGNUM; regno < FP0_REGNUM + ppc_num_fprs; regno++)
d1444 1
d1459 1
a1459 1
  if (regno == -1 || regno < FP0_REGNUM)
d1480 2
a1481 2
      || (regno >= FP0_REGNUM
          && regno < FP0_REGNUM + ppc_num_fprs))
@


1.17
log
@* aix-thread.c (fill_fprs): Fix off-by-one error comparing regno
with FPLAST_REGNUM.
@
text
@d1178 3
a1180 1
  if (regno == -1 || (regno >= FP0_REGNUM && regno <= FPLAST_REGNUM))
d1267 1
a1267 1
  for (regno = FP0_REGNUM; regno <= FPLAST_REGNUM; regno++)
d1471 3
a1473 1
  if (regno == -1 || (regno >= FP0_REGNUM && regno <= FPLAST_REGNUM))
@


1.16
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d1265 1
a1265 1
  for (regno = FP0_REGNUM; regno < FPLAST_REGNUM; regno++)
@


1.15
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d132 2
a133 1
/* Saved pointer to previous owner of target_new_objfile_hook.  */
d897 1
a897 1
/* target_new_objfile_hook callback.
d1699 2
a1700 2
  target_new_objfile_chain = target_new_objfile_hook;
  target_new_objfile_hook = new_objfile;
@


1.15.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d51 1
a52 1
#include "gdb_string.h"
d132 1
a132 2
/* Saved pointer to previous owner of
   deprecated_target_new_objfile_hook.  */
d315 1
a315 1
			    i, hex_string (symbols[i].addr));
d340 3
a342 3
  uint64_t gprs64[ppc_num_gprs];
  uint32_t gprs32[ppc_num_gprs];
  double fprs[ppc_num_fprs];
d348 1
a348 1
                        (int) tid, hex_string (flags));
d414 1
a414 1
                        (int) tid, hex_string (flags));
d459 1
a459 1
      user, (long) buf, hex_string (addr), len);
d481 1
a481 1
      user, (long) buf, hex_string (addr), len);
a622 29
/* Search through the list of all kernel threads for the thread
   that has stopped on a SIGTRAP signal, and return its TID.
   Return 0 if none found.  */

static pthdb_tid_t
get_signaled_thread (void)
{
  struct thrdsinfo64 thrinf;
  pthdb_tid_t ktid = 0;
  int result = 0;

  /* getthrds(3) isn't prototyped in any AIX 4.3.3 #include file.  */
  extern int getthrds (pid_t, struct thrdsinfo64 *, 
		       int, pthdb_tid_t *, int);

  while (1)
  {
    if (getthrds (PIDGET (inferior_ptid), &thrinf, 
          	  sizeof (thrinf), &ktid, 1) != 1)
      break;

    if (thrinf.ti_cursig == SIGTRAP)
      return thrinf.ti_tid;
  }

  /* Didn't find any thread stopped on a SIGTRAP signal.  */
  return 0;
}

d749 2
a750 2
/* Iterate_over_threads() callback for locating a thread, using
   the TID of its associated kernel thread.  */
d753 1
a753 1
iter_tid (struct thread_info *thread, void *tidp)
d755 6
a760 1
  const pthdb_tid_t tid = *(pthdb_tid_t *)tidp;
d762 9
a770 1
  return (thread->private->tid == tid);
d782 1
a782 2
  pthdb_tid_t tid;
  struct thread_info *thread = NULL;
d795 1
a795 3
  tid = get_signaled_thread ();
  if (tid != 0)
    thread = iterate_over_threads (iter_tid, &tid);
d855 1
a855 1
  arch64 = register_size (current_gdbarch, 0) == 8;
d896 1
a896 1
/* deprecated_target_new_objfile_hook callback.
a1002 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1005 2
a1006 3
  for (regno = 0; regno < ppc_num_gprs; regno++)
    regcache_raw_supply (current_regcache, tdep->ppc_gp0_regnum + regno,
			 (char *) (vals + regno));
d1014 1
a1014 1
  regcache_raw_supply (current_regcache, regno, (char *) &val);
a1021 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1024 2
a1025 7
  /* This function should never be called on architectures without
     floating-point registers.  */
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));

  for (regno = 0; regno < ppc_num_fprs; regno++)
    regcache_raw_supply (current_regcache, regno + tdep->ppc_fp0_regnum,
			 (char *) (vals + regno));
d1040 1
a1040 1
      || (tdep->ppc_fpscr_regnum >= 0 && regno == tdep->ppc_fpscr_regnum)
d1055 7
a1061 9
  regcache_raw_supply (current_regcache, PC_REGNUM, (char *) &iar);
  regcache_raw_supply (current_regcache, tdep->ppc_ps_regnum, (char *) &msr);
  regcache_raw_supply (current_regcache, tdep->ppc_cr_regnum, (char *) &cr);
  regcache_raw_supply (current_regcache, tdep->ppc_lr_regnum, (char *) &lr);
  regcache_raw_supply (current_regcache, tdep->ppc_ctr_regnum, (char *) &ctr);
  regcache_raw_supply (current_regcache, tdep->ppc_xer_regnum, (char *) &xer);
  if (tdep->ppc_fpscr_regnum >= 0)
    regcache_raw_supply (current_regcache, tdep->ppc_fpscr_regnum,
			 (char *) &fpscr);
d1074 7
a1080 9
  regcache_raw_supply (current_regcache, PC_REGNUM, (char *) &iar);
  regcache_raw_supply (current_regcache, tdep->ppc_ps_regnum, (char *) &msr);
  regcache_raw_supply (current_regcache, tdep->ppc_cr_regnum, (char *) &cr);
  regcache_raw_supply (current_regcache, tdep->ppc_lr_regnum, (char *) &lr);
  regcache_raw_supply (current_regcache, tdep->ppc_ctr_regnum, (char *) &ctr);
  regcache_raw_supply (current_regcache, tdep->ppc_xer_regnum, (char *) &xer);
  if (tdep->ppc_fpscr_regnum >= 0)
    regcache_raw_supply (current_regcache, tdep->ppc_fpscr_regnum,
			 (char *) &fpscr);
a1092 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1109 2
a1110 2
    for (i = 0; i < ppc_num_gprs; i++)
      supply_reg32 (tdep->ppc_gp0_regnum + i, ctx.gpr[i]);
d1114 1
a1114 2
  if (ppc_floating_point_unit_p (current_gdbarch))
    supply_fprs (ctx.fpr);
d1144 3
a1146 4
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  uint64_t gprs64[ppc_num_gprs];
  uint32_t gprs32[ppc_num_gprs];
  double fprs[ppc_num_fprs];
d1157 1
a1157 3
  if (regno == -1
      || (tdep->ppc_gp0_regnum <= regno
          && regno < tdep->ppc_gp0_regnum + ppc_num_gprs))
d1170 2
a1171 2
	  for (i = 0; i < ppc_num_gprs; i++)
	    supply_reg32 (tdep->ppc_gp0_regnum + i, gprs32[i]);
d1177 1
a1177 4
  if (ppc_floating_point_unit_p (current_gdbarch)
      && (regno == -1
          || (regno >= tdep->ppc_fp0_regnum
              && regno < tdep->ppc_fp0_regnum + ppc_num_fprs)))
d1208 1
a1208 2
	    regcache_raw_supply (current_regcache, tdep->ppc_mq_regnum,
				 (char *) &sprs32.pt_mq);
a1240 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1243 3
a1245 4
  for (regno = 0; regno < ppc_num_gprs; regno++)
    if (register_cached (tdep->ppc_gp0_regnum + regno))
      regcache_raw_collect (current_regcache, tdep->ppc_gp0_regnum + regno,
			    vals + regno);
a1250 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1253 3
a1255 4
  for (regno = 0; regno < ppc_num_gprs; regno++)
    if (register_cached (tdep->ppc_gp0_regnum + regno))
      regcache_raw_collect (current_regcache, tdep->ppc_gp0_regnum + regno,
			    vals + regno);
a1261 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1264 1
a1264 7
  /* This function should never be called on architectures without
     floating-point registers.  */
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));

  for (regno = tdep->ppc_fp0_regnum;
       regno < tdep->ppc_fp0_regnum + ppc_num_fprs;
       regno++)
d1266 1
a1266 1
      regcache_raw_collect (current_regcache, regno, vals + regno);
d1284 1
a1284 1
  gdb_assert (sizeof (*iar) == register_size (current_gdbarch, PC_REGNUM));
d1287 1
a1287 1
    regcache_raw_collect (current_regcache, PC_REGNUM, iar);
d1289 1
a1289 1
    regcache_raw_collect (current_regcache, tdep->ppc_ps_regnum, msr);
d1291 1
a1291 1
    regcache_raw_collect (current_regcache, tdep->ppc_cr_regnum, cr);
d1293 1
a1293 1
    regcache_raw_collect (current_regcache, tdep->ppc_lr_regnum, lr);
d1295 1
a1295 1
    regcache_raw_collect (current_regcache, tdep->ppc_ctr_regnum, ctr);
d1297 3
a1299 4
    regcache_raw_collect (current_regcache, tdep->ppc_xer_regnum, xer);
  if (tdep->ppc_fpscr_regnum >= 0
      && register_cached (tdep->ppc_fpscr_regnum))
    regcache_raw_collect (current_regcache, tdep->ppc_fpscr_regnum, fpscr);
d1319 1
a1319 1
  gdb_assert (sizeof (*iar) == register_size (current_gdbarch, PC_REGNUM));
d1322 1
a1322 1
    regcache_raw_collect (current_regcache, PC_REGNUM, iar);
d1324 1
a1324 1
    regcache_raw_collect (current_regcache, tdep->ppc_ps_regnum, msr);
d1326 1
a1326 1
    regcache_raw_collect (current_regcache, tdep->ppc_cr_regnum, cr);
d1328 1
a1328 1
    regcache_raw_collect (current_regcache, tdep->ppc_lr_regnum, lr);
d1330 1
a1330 1
    regcache_raw_collect (current_regcache, tdep->ppc_ctr_regnum, ctr);
d1332 3
a1334 4
    regcache_raw_collect (current_regcache, tdep->ppc_xer_regnum, xer);
  if (tdep->ppc_fpscr_regnum >= 0
      && register_cached (tdep->ppc_fpscr_regnum))
    regcache_raw_collect (current_regcache, tdep->ppc_fpscr_regnum, fpscr);
a1345 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1365 2
a1366 2
  for (i = 0; i < ppc_num_gprs; i++)
    if (register_cached (tdep->ppc_gp0_regnum + i))
d1370 1
a1370 2
	    regcache_raw_collect (current_regcache, tdep->ppc_gp0_regnum + i,
				  (void *) &int64);
d1375 1
a1375 2
	    regcache_raw_collect (current_regcache, tdep->ppc_gp0_regnum + i,
				  (void *) &int32);
d1381 1
a1381 2
  if (ppc_floating_point_unit_p (current_gdbarch))
    fill_fprs (ctx.fpr);
d1397 1
d1434 3
a1436 4
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  uint64_t gprs64[ppc_num_gprs];
  uint32_t gprs32[ppc_num_gprs];
  double fprs[ppc_num_fprs];
d1440 1
d1448 1
a1448 3
  if (regno == -1
      || (tdep->ppc_gp0_regnum <= regno
          && regno < tdep->ppc_gp0_regnum + ppc_num_fprs))
d1468 1
a1468 4
  if (ppc_floating_point_unit_p (current_gdbarch)
      && (regno == -1
          || (regno >= tdep->ppc_fp0_regnum
              && regno < tdep->ppc_fp0_regnum + ppc_num_fprs)))
d1502 1
a1502 2
	      regcache_raw_collect (current_regcache, tdep->ppc_mq_regnum,
				    &sprs32.pt_mq);
d1597 1
a1597 1
     xstrprintf().  */
d1600 1
a1600 1
  ret = xstrprintf ("Thread %ld", ptid_get_tid (ptid));
d1698 2
a1699 2
  target_new_objfile_chain = deprecated_target_new_objfile_hook;
  deprecated_target_new_objfile_hook = new_objfile;
d1701 6
a1706 7
  deprecated_add_show_from_set
    (add_set_cmd ("aix-thread", no_class, var_zinteger,
		  (char *) &debug_aix_thread, 
		  "Set debugging of AIX thread module.\n"
		  "Enables printf debugging output.\n",
		  &setdebuglist),
     &showdebuglist);
@


1.14
log
@	* aix-thread.c (aix_thread_detach): Disable thread debugging on
	detach to allow reinitialization.
@
text
@d855 1
a855 1
  arch64 = REGISTER_RAW_SIZE (0) == 8;
d1284 1
a1284 1
  gdb_assert (sizeof (*iar) == REGISTER_RAW_SIZE (PC_REGNUM));
d1319 1
a1319 1
  gdb_assert (sizeof (*iar) == REGISTER_RAW_SIZE (PC_REGNUM));
@


1.14.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d855 1
a855 1
  arch64 = DEPRECATED_REGISTER_RAW_SIZE (0) == 8;
d1284 1
a1284 1
  gdb_assert (sizeof (*iar) == DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM));
d1319 1
a1319 1
  gdb_assert (sizeof (*iar) == DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM));
@


1.14.8.1
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d855 1
a855 1
  arch64 = DEPRECATED_REGISTER_RAW_SIZE (0) == 8;
d1284 1
a1284 1
  gdb_assert (sizeof (*iar) == DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM));
d1319 1
a1319 1
  gdb_assert (sizeof (*iar) == DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM));
@


1.13
log
@Delete disabled code.
@
text
@d929 1
a929 1
  pd_deactivate ();
@


1.12
log
@	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fetch_regs_user_thread, fetch_regs_kernel_thread, fill_sprs64)
	(fill_sprs32, store_regs_user_thread, store_regs_kernel_thread):
	Add support for the fpscr register.
	* rs6000-nat.c (regmap, fetch_inferior_registers)
	(store_inferior_registers, fetch_core_registers): Likewise.
@
text
@a53 5
#if 0
#include "coff/internal.h"	/* for libcoff.h */
#include "bfd/libcoff.h"	/* for xcoff_data */
#endif

a57 3
#if 0
#include <pthread.h>
#endif
@


1.11
log
@	* aix-thread.c (language.h): Include.
	(ptrace_check, pdc_symbol_addrs, pdc_read_regs, pdc_write_regs)
	(pdc_read_data, pdc_write_data, pdc_alloc, pdc_realloc, pdc_dealloc):
	Print newlines at end of debug messages.
	(pdc_symbol_addrs, pdc_read_regs, pdc_write_regs, pdc_read_data)
	(pdc_write_data): Use local_hex_string() instead of %llx formats.
@
text
@d1048 1
d1058 2
a1059 1
	       uint64_t lr, uint64_t ctr, uint32_t xer)
d1069 1
d1077 2
a1078 1
	       uint32_t lr, uint32_t ctr, uint32_t xer)
d1088 1
d1127 2
a1128 1
    supply_sprs64 (ctx.iar, ctx.msr, ctx.cr, ctx.lr, ctx.ctr, ctx.xer);
d1130 2
a1131 1
    supply_sprs32 (ctx.iar, ctx.msr, ctx.cr, ctx.lr, ctx.ctr, ctx.xer);
d1202 2
a1203 1
			 sprs64.pt_lr, sprs64.pt_ctr, sprs64.pt_xer);
d1212 2
a1213 1
			 sprs32.pt_lr, sprs32.pt_ctr, sprs32.pt_xer);
d1282 2
a1283 1
	     uint64_t *lr, uint64_t *ctr, uint32_t *xer)
d1306 2
d1312 2
a1313 1
	     unsigned long *lr,  unsigned long *ctr, unsigned long *xer)
d1341 2
d1394 2
a1395 1
      fill_sprs64 (&ctx.iar, &ctx.msr, &ctx.cr, &ctx.lr, &ctx.ctr, &ctx.xer);
d1403 2
a1404 1
      unsigned long tmp_iar, tmp_msr, tmp_cr, tmp_lr, tmp_ctr, tmp_xer;
d1407 2
a1408 1
      fill_sprs32 (&tmp_iar, &tmp_msr, &tmp_cr, &tmp_lr, &tmp_ctr, &tmp_xer);
d1421 2
d1494 2
a1495 1
		       &sprs64.pt_lr,  &sprs64.pt_ctr, &sprs64.pt_xer);
d1505 2
a1506 1
		       &sprs32.pt_lr,  &sprs32.pt_ctr, &sprs32.pt_xer);
@


1.10
log
@Don't rely on FIRST_UISA_SP_REGNUM or LAST_UISA_REGNUM.
@
text
@d51 2
a67 1
#include "ppc-tdep.h"
d244 1
a244 1
				"ptrace (%d, %d) = %d (errno = %d)",
d299 1
a299 1
      "pdc_symbol_addrs (user = %ld, symbols = 0x%lx, count = %d)",
d307 1
a307 1
			    "  symbols[%d].name = \"%s\"", i, name);
d316 1
a316 1
		fprintf_unfiltered (gdb_stdlog, " returning PDC_FAILURE");
d322 2
a323 2
	fprintf_unfiltered (gdb_stdlog, "  symbols[%d].addr = 0x%llx",
			    i, symbols[i].addr);
d326 1
a326 1
    fprintf_unfiltered (gdb_stdlog, " returning PDC_SUCCESS");
d355 2
a356 2
    fprintf_unfiltered (gdb_stdlog, "pdc_read_regs tid=%d flags=%llx\n",
                        (int) tid, flags);
d421 2
a422 2
    fprintf_unfiltered (gdb_stdlog, "pdc_write_regs tid=%d flags=%llx\n",
                        (int) tid, flags);
d466 2
a467 2
      "pdc_read_data (user = %ld, buf = 0x%lx, addr = 0x%llx, len = %ld)",
      user, (long) buf, addr, len);
d473 1
a473 1
    fprintf_unfiltered (gdb_stdlog, "  status=%d, returning %s",
d488 2
a489 2
      "pdc_write_data (user = %ld, buf = 0x%lx, addr = 0x%llx, len = %ld)",
      user, (long) buf, addr, len);
d495 1
a495 1
    fprintf_unfiltered (gdb_stdlog, "  status=%d, returning %s", status,
d508 1
a508 1
                        "pdc_alloc (user = %ld, len = %ld, bufp = 0x%lx)",
d513 1
a513 1
			"  malloc returned 0x%lx", (long) *bufp);
d530 1
a530 1
      "pdc_realloc (user = %ld, buf = 0x%lx, len = %ld, bufp = 0x%lx)",
d535 1
a535 1
			"  realloc returned 0x%lx", (long) *bufp);
d547 1
a547 1
			"pdc_free (user = %ld, buf = 0x%lx)", user,
@


1.9
log
@	* aix-thread.c (ops): Rename to aix_thread_ops.
	(base_ops): Rename to base_target.
	(ops_attach): Rename to aix_thread_attach.
	(ops_detach): Rename to aix_thread_detach.
	(ops_resume): Rename to aix_thread_detach.
	(ops_wait):   Rename to aix_thread_wait.
	(ops_kill):   Rename to aix_thread_kill.
	(init_ops):   Rename to init_aix_thread_ops.
	(ops_fetch_register): Rename to aix_thread_fetch_register.
	(ops_store_register): Rename to aix_thread_store_register.
	(ops_mourn_inferior): Rename to aix_thread_mourn_inferior.
	(ops_thread_alive):   Rename to aix_thread_thread_alive.
	(ops_extra_thread_info: Rename to aix_thread_extra_thread_info.
	(ops_pid_to_str):  Rename to aix_thread_pid_to_str.
	(ops_xfer_memory): Rename to aix_thread_xfer_memory.
	(fetch_regs_lib):  Rename to fetch_regs_user_thread.
	(fetch_regs_kern): Rename to fetch_regs_kernel_thread.
	(store_regs_lib):  Rename to store_regs_user_thread.
	(store_regs_kern): Rename to store_regs_kernel_thread.
@
text
@d66 1
d1035 16
d1058 1
a1058 1
  int regno = FIRST_UISA_SP_REGNUM;
d1060 6
a1065 6
  supply_register (regno,     (char *) &iar);
  supply_register (regno + 1, (char *) &msr);
  supply_register (regno + 2, (char *) &cr);
  supply_register (regno + 3, (char *) &lr);
  supply_register (regno + 4, (char *) &ctr);
  supply_register (regno + 5, (char *) &xer);
d1075 1
a1075 1
  int regno = FIRST_UISA_SP_REGNUM;
d1077 6
a1082 6
  supply_register (regno,     (char *) &iar);
  supply_register (regno + 1, (char *) &msr);
  supply_register (regno + 2, (char *) &cr);
  supply_register (regno + 3, (char *) &lr);
  supply_register (regno + 4, (char *) &ctr);
  supply_register (regno + 5, (char *) &xer);
d1186 1
a1186 2
  if (regno == -1 || 
      (regno > FPLAST_REGNUM && regno <= LAST_UISA_SP_REGNUM))
d1198 2
d1205 2
a1206 2
	  if (REGISTER_RAW_SIZE (LAST_UISA_SP_REGNUM))
	    supply_register (LAST_UISA_SP_REGNUM, (char *) &sprs32.pt_mq);
d1274 1
a1274 1
  int regno = FIRST_UISA_SP_REGNUM;
d1276 19
a1294 14
  gdb_assert (sizeof (*iar) == REGISTER_RAW_SIZE (regno));

  if (register_cached (regno))
    regcache_collect (regno,     iar);
  if (register_cached (regno + 1))
    regcache_collect (regno + 1, msr);
  if (register_cached (regno + 2))
    regcache_collect (regno + 2, cr);
  if (register_cached (regno + 3))
    regcache_collect (regno + 3, lr);
  if (register_cached (regno + 4))
    regcache_collect (regno + 4, ctr);
  if (register_cached (regno + 5))
    regcache_collect (regno + 5, xer);
d1301 7
a1307 1
  int regno = FIRST_UISA_SP_REGNUM;
d1309 1
a1309 1
  /* If this assert() fails, the most likely reason is that GDB was
d1313 1
a1313 1
  gdb_assert (sizeof (*iar) == REGISTER_RAW_SIZE (regno));
d1315 12
a1326 12
  if (register_cached (regno))
    regcache_collect (regno,     iar);
  if (register_cached (regno + 1))
    regcache_collect (regno + 1, msr);
  if (register_cached (regno + 2))
    regcache_collect (regno + 2, cr);
  if (register_cached (regno + 3))
    regcache_collect (regno + 3, lr);
  if (register_cached (regno + 4))
    regcache_collect (regno + 4, ctr);
  if (register_cached (regno + 5))
    regcache_collect (regno + 5, xer);
d1387 1
d1390 1
a1390 1
      if (register_cached (FIRST_UISA_SP_REGNUM))
d1392 1
a1392 1
      if (register_cached (FIRST_UISA_SP_REGNUM + 1))
d1394 1
a1394 1
      if (register_cached (FIRST_UISA_SP_REGNUM + 2))
d1396 1
a1396 1
      if (register_cached (FIRST_UISA_SP_REGNUM + 3))
d1398 1
a1398 1
      if (register_cached (FIRST_UISA_SP_REGNUM + 4))
d1400 1
a1400 1
      if (register_cached (FIRST_UISA_SP_REGNUM + 5))
d1427 1
d1465 1
a1465 2
  if (regno == -1 || 
      (regno > FPLAST_REGNUM && regno <= LAST_UISA_SP_REGNUM))
d1485 3
a1487 3
	  if (REGISTER_RAW_SIZE (LAST_UISA_SP_REGNUM))
	    if (register_cached (LAST_UISA_SP_REGNUM))
	      regcache_collect (LAST_UISA_SP_REGNUM, &sprs32.pt_mq);
@


1.8
log
@	* aix-thread.c (ops_prepare_to_store): Eliminate.
	(init_ops): Don't initialize ops.prepare_to_store.
	(store_regs_kern): Pre-fetch register buffers from child,
	because some registers may not be in the cache.  Copy
	regs from register cache only if they are cached.
	(store_regs_lib): Copy regs from register cache only
	if they are cached.
	(fill_sprs32, (fill_sprs64, fill_fprs, fill_gprs32,
	fill_gprs64): Ditto.
@
text
@d112 1
a112 1
static struct target_ops ops;
d118 1
a118 1
static struct target_ops base_ops;
d269 1
a269 1
		       ptrace (req, id, (int *)addr, data, buf));
d354 1
a354 1
                        (int)tid, flags);
d420 1
a420 1
                        (int)tid, flags);
d427 1
a427 1
		     (unsigned long)context->gpr, 0, NULL);
d429 1
a429 1
	ptrace32 (PTT_WRITE_GPRS, tid, (int *)context->gpr, 0, NULL);
d435 1
a435 1
      ptrace32 (PTT_WRITE_FPRS, tid, (int *)context->fpr, 0, NULL);
d448 1
a448 1
	  ptrace32 (PTT_WRITE_SPRS, tid, (int *)&context->msr, 0, NULL);
d879 2
a880 2
  base_ops = current_target;
  push_target (&ops);
d899 1
a899 1
  unpush_target (&ops);
d924 1
a924 1
ops_attach (char *args, int from_tty)
d926 1
a926 1
  base_ops.to_attach (args, from_tty);
d930 1
a930 1
/* Detach from the process attached to by ops_attach().  */
d933 1
a933 1
ops_detach (char *args, int from_tty)
d936 1
a936 1
  base_ops.to_detach (args, from_tty);
d943 1
a943 1
ops_resume (ptid_t ptid, int step, enum target_signal sig)
d952 1
a952 1
      base_ops.to_resume (ptid, step, sig);
d970 1
a970 1
		     target_signal_to_host (sig), (int *)tid);
d973 1
a973 1
		  target_signal_to_host (sig), (int *)tid);
d982 1
a982 1
ops_wait (ptid_t ptid, struct target_waitstatus *status)
d989 1
a989 1
  ptid = base_ops.to_wait (ptid, status);
d1076 1
a1076 1
fetch_regs_lib (pthdb_pthread_t pdtid)
d1082 2
a1083 1
    fprintf_unfiltered (gdb_stdlog, "fetch_regs_lib %lx\n", (long)pdtid);
d1125 1
a1125 1
fetch_regs_kern (int regno, pthdb_tid_t tid)
d1136 2
a1137 2
			"fetch_regs_kern tid=%lx regno=%d arch64=%d\n",
			(long)tid, regno, arch64);
d1197 1
a1197 1
ops_fetch_registers (int regno)
d1203 1
a1203 1
    base_ops.to_fetch_registers (regno);
d1210 1
a1210 1
	fetch_regs_lib (thread->private->pdtid);
d1212 1
a1212 1
	fetch_regs_kern (regno, tid);
d1307 1
a1307 1
store_regs_lib (pthdb_pthread_t pdtid)
d1317 1
a1317 1
			"store_regs_lib %lx\n", (long)pdtid);
d1389 1
a1389 1
store_regs_kern (int regno, pthdb_tid_t tid)
d1399 3
a1401 2
    fprintf_unfiltered (gdb_stdlog, "store_regs_kern tid=%lx regno=%d\n",
                        (long)tid, regno);
d1468 1
a1468 1
ops_store_registers (int regno)
d1474 1
a1474 1
    base_ops.to_store_registers (regno);
d1481 1
a1481 1
	store_regs_lib (thread->private->pdtid);
d1483 1
a1483 1
	store_regs_kern (regno, tid);
d1491 3
a1493 3
ops_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
                 struct mem_attrib *attrib,
		 struct target_ops *target)
d1499 2
a1500 2
  n = base_ops.to_xfer_memory (memaddr, myaddr, len, 
			       write, attrib, &base_ops);
d1509 1
a1509 1
ops_kill (void)
d1514 1
a1514 1
  base_ops.to_kill ();
d1521 1
a1521 1
ops_mourn_inferior (void)
d1524 1
a1524 1
  base_ops.to_mourn_inferior ();
d1530 1
a1530 1
ops_thread_alive (ptid_t ptid)
d1533 1
a1533 1
    return base_ops.to_thread_alive (ptid);
d1544 1
a1544 1
ops_pid_to_str (ptid_t ptid)
d1549 1
a1549 1
    return base_ops.to_pid_to_str (ptid);
d1563 1
a1563 1
ops_extra_thread_info (struct thread_info *thread)
d1616 1
a1616 1
/* Initialize target ops.  */
d1619 1
a1619 1
init_ops (void)
d1621 12
a1632 12
  ops.to_shortname          = "aix-threads";
  ops.to_longname           = "AIX pthread support";
  ops.to_doc                = "AIX pthread support";

  ops.to_attach             = ops_attach;
  ops.to_detach             = ops_detach;
  ops.to_resume             = ops_resume;
  ops.to_wait               = ops_wait;
  ops.to_fetch_registers    = ops_fetch_registers;
  ops.to_store_registers    = ops_store_registers;
  ops.to_xfer_memory        = ops_xfer_memory;
  /* No need for ops.to_create_inferior, because we activate thread
d1634 7
a1640 7
  ops.to_kill               = ops_kill;
  ops.to_mourn_inferior     = ops_mourn_inferior;
  ops.to_thread_alive       = ops_thread_alive;
  ops.to_pid_to_str         = ops_pid_to_str;
  ops.to_extra_thread_info  = ops_extra_thread_info;
  ops.to_stratum            = thread_stratum;
  ops.to_magic              = OPS_MAGIC;
d1649 2
a1650 2
  init_ops ();
  add_target (&ops);
@


1.8.2.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1223 2
a1224 1
    regcache_collect (regno, vals + regno);
d1233 2
a1234 1
    regcache_collect (regno, vals + regno);
d1244 2
a1245 1
    regcache_collect (regno, vals + regno);
d1259 12
a1270 6
  regcache_collect (regno,     iar);
  regcache_collect (regno + 1, msr);
  regcache_collect (regno + 2, cr);
  regcache_collect (regno + 3, lr);
  regcache_collect (regno + 4, ctr);
  regcache_collect (regno + 5, xer);
d1285 12
a1296 6
  regcache_collect (regno,     iar);
  regcache_collect (regno + 1, msr);
  regcache_collect (regno + 2, cr);
  regcache_collect (regno + 3, lr);
  regcache_collect (regno + 4, ctr);
  regcache_collect (regno + 5, xer);
d1328 13
a1340 12
    {
      if (arch64)
	{
	  regcache_collect (i, (void *) &int64);
	  ctx.gpr[i] = int64;
	}
      else
	{
	  regcache_collect (i, (void *) &int32);
	  ctx.gpr[i] = int32;
	}
    }
d1359 12
a1370 6
      ctx.iar = tmp_iar;
      ctx.msr = tmp_msr;
      ctx.cr  = tmp_cr;
      ctx.lr  = tmp_lr;
      ctx.ctr = tmp_ctr;
      ctx.xer = tmp_xer;
d1406 2
d1413 2
d1424 2
d1437 1
a1437 1
	  /* Must read first, not all of it's in the cache.  */
d1447 1
a1447 1
	  /* Must read first, not all of it's in the cache.  */
d1454 2
a1455 1
	    regcache_collect (LAST_UISA_SP_REGNUM, &sprs32.pt_mq);
a1484 16
/* Prepare to copy the register cache to the child:
   The register cache must be fully fetched and up to date.  */

static void
ops_prepare_to_store (void)
{
  int regno;

  if (!PD_TID (inferior_ptid))
    base_ops.to_prepare_to_store ();
  else
    for (regno = 0; regno < NUM_REGS; regno++)
      if (!register_cached (regno))
	target_fetch_registers (regno);
}

a1628 1
  ops.to_prepare_to_store   = ops_prepare_to_store;
@


1.8.2.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d51 5
a55 2
#include "language.h"		/* for local_hex_string() */
#include "ppc-tdep.h"
d61 3
d112 1
a112 1
static struct target_ops aix_thread_ops;
d118 1
a118 1
static struct target_ops base_target;
d242 1
a242 1
				"ptrace (%d, %d) = %d (errno = %d)\n",
d269 1
a269 1
		       ptrace (req, id, (int *) addr, data, buf));
d297 1
a297 1
      "pdc_symbol_addrs (user = %ld, symbols = 0x%lx, count = %d)\n",
d305 1
a305 1
			    "  symbols[%d].name = \"%s\"\n", i, name);
d314 1
a314 1
		fprintf_unfiltered (gdb_stdlog, " returning PDC_FAILURE\n");
d320 2
a321 2
	fprintf_unfiltered (gdb_stdlog, "  symbols[%d].addr = %s\n",
			    i, local_hex_string (symbols[i].addr));
d324 1
a324 1
    fprintf_unfiltered (gdb_stdlog, " returning PDC_SUCCESS\n");
d353 2
a354 2
    fprintf_unfiltered (gdb_stdlog, "pdc_read_regs tid=%d flags=%s\n",
                        (int) tid, local_hex_string (flags));
d419 2
a420 2
    fprintf_unfiltered (gdb_stdlog, "pdc_write_regs tid=%d flags=%s\n",
                        (int) tid, local_hex_string (flags));
d427 1
a427 1
		     (unsigned long) context->gpr, 0, NULL);
d429 1
a429 1
	ptrace32 (PTT_WRITE_GPRS, tid, (int *) context->gpr, 0, NULL);
d435 1
a435 1
      ptrace32 (PTT_WRITE_FPRS, tid, (int *) context->fpr, 0, NULL);
d448 1
a448 1
	  ptrace32 (PTT_WRITE_SPRS, tid, (int *) &context->msr, 0, NULL);
d464 2
a465 2
      "pdc_read_data (user = %ld, buf = 0x%lx, addr = %s, len = %ld)\n",
      user, (long) buf, local_hex_string (addr), len);
d471 1
a471 1
    fprintf_unfiltered (gdb_stdlog, "  status=%d, returning %s\n",
d486 2
a487 2
      "pdc_write_data (user = %ld, buf = 0x%lx, addr = %s, len = %ld)\n",
      user, (long) buf, local_hex_string (addr), len);
d493 1
a493 1
    fprintf_unfiltered (gdb_stdlog, "  status=%d, returning %s\n", status,
d506 1
a506 1
                        "pdc_alloc (user = %ld, len = %ld, bufp = 0x%lx)\n",
d511 1
a511 1
			"  malloc returned 0x%lx\n", (long) *bufp);
d528 1
a528 1
      "pdc_realloc (user = %ld, buf = 0x%lx, len = %ld, bufp = 0x%lx)\n",
d533 1
a533 1
			"  realloc returned 0x%lx\n", (long) *bufp);
d545 1
a545 1
			"pdc_free (user = %ld, buf = 0x%lx)\n", user,
d879 2
a880 2
  base_target = current_target;
  push_target (&aix_thread_ops);
d899 1
a899 1
  unpush_target (&aix_thread_ops);
d924 1
a924 1
aix_thread_attach (char *args, int from_tty)
d926 1
a926 1
  base_target.to_attach (args, from_tty);
d930 1
a930 1
/* Detach from the process attached to by aix_thread_attach().  */
d933 1
a933 1
aix_thread_detach (char *args, int from_tty)
d936 1
a936 1
  base_target.to_detach (args, from_tty);
d943 1
a943 1
aix_thread_resume (ptid_t ptid, int step, enum target_signal sig)
d952 1
a952 1
      base_target.to_resume (ptid, step, sig);
d970 1
a970 1
		     target_signal_to_host (sig), (int *) tid);
d973 1
a973 1
		  target_signal_to_host (sig), (int *) tid);
d982 1
a982 1
aix_thread_wait (ptid_t ptid, struct target_waitstatus *status)
d989 1
a989 1
  ptid = base_target.to_wait (ptid, status);
a1033 17
/* Predicate to test whether given register number is a "special" register.  */
static int
special_register_p (int regno)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  return regno == PC_REGNUM
      || regno == tdep->ppc_ps_regnum
      || regno == tdep->ppc_cr_regnum
      || regno == tdep->ppc_lr_regnum
      || regno == tdep->ppc_ctr_regnum
      || regno == tdep->ppc_xer_regnum
      || regno == tdep->ppc_fpscr_regnum
      || (tdep->ppc_mq_regnum >= 0 && regno == tdep->ppc_mq_regnum);
}


d1039 1
a1039 2
	       uint64_t lr, uint64_t ctr, uint32_t xer,
	       uint32_t fpscr)
d1041 1
a1041 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1043 6
a1048 7
  supply_register (PC_REGNUM,     (char *) &iar);
  supply_register (tdep->ppc_ps_regnum, (char *) &msr);
  supply_register (tdep->ppc_cr_regnum, (char *) &cr);
  supply_register (tdep->ppc_lr_regnum, (char *) &lr);
  supply_register (tdep->ppc_ctr_regnum, (char *) &ctr);
  supply_register (tdep->ppc_xer_regnum, (char *) &xer);
  supply_register (tdep->ppc_fpscr_regnum, (char *) &fpscr);
d1056 1
a1056 2
	       uint32_t lr, uint32_t ctr, uint32_t xer,
	       uint32_t fpscr)
d1058 1
a1058 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1060 6
a1065 7
  supply_register (PC_REGNUM,     (char *) &iar);
  supply_register (tdep->ppc_ps_regnum, (char *) &msr);
  supply_register (tdep->ppc_cr_regnum, (char *) &cr);
  supply_register (tdep->ppc_lr_regnum, (char *) &lr);
  supply_register (tdep->ppc_ctr_regnum, (char *) &ctr);
  supply_register (tdep->ppc_xer_regnum, (char *) &xer);
  supply_register (tdep->ppc_fpscr_regnum, (char *) &fpscr);
d1076 1
a1076 1
fetch_regs_user_thread (pthdb_pthread_t pdtid)
d1082 1
a1082 2
    fprintf_unfiltered (gdb_stdlog, 
			"fetch_regs_user_thread %lx\n", (long) pdtid);
d1103 1
a1103 2
    supply_sprs64 (ctx.iar, ctx.msr, ctx.cr, ctx.lr, ctx.ctr, ctx.xer,
                   ctx.fpscr);
d1105 1
a1105 2
    supply_sprs32 (ctx.iar, ctx.msr, ctx.cr, ctx.lr, ctx.ctr, ctx.xer,
                   ctx.fpscr);
d1124 1
a1124 1
fetch_regs_kernel_thread (int regno, pthdb_tid_t tid)
d1135 2
a1136 2
	"fetch_regs_kernel_thread tid=%lx regno=%d arch64=%d\n",
	(long) tid, regno, arch64);
d1168 2
a1169 1
  if (regno == -1 || special_register_p (regno))
d1177 1
a1177 2
			 sprs64.pt_lr, sprs64.pt_ctr, sprs64.pt_xer,
			 sprs64.pt_fpscr);
a1180 2
	  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

d1184 1
a1184 2
			 sprs32.pt_lr, sprs32.pt_ctr, sprs32.pt_xer,
			 sprs32.pt_fpscr);
d1186 2
a1187 2
	  if (tdep->ppc_mq_regnum >= 0)
	    supply_register (tdep->ppc_mq_regnum, (char *) &sprs32.pt_mq);
d1196 1
a1196 1
aix_thread_fetch_registers (int regno)
d1202 1
a1202 1
    base_target.to_fetch_registers (regno);
d1209 1
a1209 1
	fetch_regs_user_thread (thread->private->pdtid);
d1211 1
a1211 1
	fetch_regs_kernel_thread (regno, tid);
d1223 1
a1223 2
    if (register_cached (regno))
      regcache_collect (regno, vals + regno);
d1232 1
a1232 2
    if (register_cached (regno))
      regcache_collect (regno, vals + regno);
d1242 1
a1242 2
    if (register_cached (regno))
      regcache_collect (regno, vals + regno);
d1250 1
a1250 2
	     uint64_t *lr, uint64_t *ctr, uint32_t *xer,
	     uint32_t *fpscr)
d1252 3
a1254 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1256 6
a1261 21
  /* Verify that the size of the size of the IAR buffer is the
     same as the raw size of the PC (in the register cache).  If
     they're not, then either GDB has been built incorrectly, or
     there's some other kind of internal error.  To be really safe,
     we should check all of the sizes.   */
  gdb_assert (sizeof (*iar) == REGISTER_RAW_SIZE (PC_REGNUM));

  if (register_cached (PC_REGNUM))
    regcache_collect (PC_REGNUM, iar);
  if (register_cached (tdep->ppc_ps_regnum))
    regcache_collect (tdep->ppc_ps_regnum, msr);
  if (register_cached (tdep->ppc_cr_regnum))
    regcache_collect (tdep->ppc_cr_regnum, cr);
  if (register_cached (tdep->ppc_lr_regnum))
    regcache_collect (tdep->ppc_lr_regnum, lr);
  if (register_cached (tdep->ppc_ctr_regnum))
    regcache_collect (tdep->ppc_ctr_regnum, ctr);
  if (register_cached (tdep->ppc_xer_regnum))
    regcache_collect (tdep->ppc_xer_regnum, xer);
  if (register_cached (tdep->ppc_fpscr_regnum))
    regcache_collect (tdep->ppc_fpscr_regnum, fpscr);
d1266 1
a1266 2
	     unsigned long *lr,  unsigned long *ctr, unsigned long *xer,
	     unsigned long *fpscr)
d1268 1
a1268 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1270 1
a1270 7
  /* Verify that the size of the size of the IAR buffer is the
     same as the raw size of the PC (in the register cache).  If
     they're not, then either GDB has been built incorrectly, or
     there's some other kind of internal error.  To be really safe,
     we should check all of the sizes. 

     If this assert() fails, the most likely reason is that GDB was
d1274 1
a1274 1
  gdb_assert (sizeof (*iar) == REGISTER_RAW_SIZE (PC_REGNUM));
d1276 6
a1281 14
  if (register_cached (PC_REGNUM))
    regcache_collect (PC_REGNUM, iar);
  if (register_cached (tdep->ppc_ps_regnum))
    regcache_collect (tdep->ppc_ps_regnum, msr);
  if (register_cached (tdep->ppc_cr_regnum))
    regcache_collect (tdep->ppc_cr_regnum, cr);
  if (register_cached (tdep->ppc_lr_regnum))
    regcache_collect (tdep->ppc_lr_regnum, lr);
  if (register_cached (tdep->ppc_ctr_regnum))
    regcache_collect (tdep->ppc_ctr_regnum, ctr);
  if (register_cached (tdep->ppc_xer_regnum))
    regcache_collect (tdep->ppc_xer_regnum, xer);
  if (register_cached (tdep->ppc_fpscr_regnum))
    regcache_collect (tdep->ppc_fpscr_regnum, fpscr);
d1291 1
a1291 1
store_regs_user_thread (pthdb_pthread_t pdtid)
d1301 1
a1301 1
			"store_regs_user_thread %lx\n", (long) pdtid);
d1313 12
a1324 13
    if (register_cached (i))
      {
	if (arch64)
	  {
	    regcache_collect (i, (void *) &int64);
	    ctx.gpr[i] = int64;
	  }
	else
	  {
	    regcache_collect (i, (void *) &int32);
	    ctx.gpr[i] = int32;
	  }
      }
d1332 1
a1332 2
      fill_sprs64 (&ctx.iar, &ctx.msr, &ctx.cr, &ctx.lr, &ctx.ctr, &ctx.xer,
                   &ctx.fpscr);
d1340 9
a1348 20
      unsigned long tmp_iar, tmp_msr, tmp_cr, tmp_lr, tmp_ctr, tmp_xer,
                    tmp_fpscr;
      struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

      fill_sprs32 (&tmp_iar, &tmp_msr, &tmp_cr, &tmp_lr, &tmp_ctr, &tmp_xer,
                   &tmp_fpscr);
      if (register_cached (PC_REGNUM))
	ctx.iar = tmp_iar;
      if (register_cached (tdep->ppc_ps_regnum))
	ctx.msr = tmp_msr;
      if (register_cached (tdep->ppc_cr_regnum))
	ctx.cr  = tmp_cr;
      if (register_cached (tdep->ppc_lr_regnum))
	ctx.lr  = tmp_lr;
      if (register_cached (tdep->ppc_ctr_regnum))
	ctx.ctr = tmp_ctr;
      if (register_cached (tdep->ppc_xer_regnum))
	ctx.xer = tmp_xer;
      if (register_cached (tdep->ppc_xer_regnum))
	ctx.fpscr = tmp_fpscr;
d1366 1
a1366 1
store_regs_kernel_thread (int regno, pthdb_tid_t tid)
a1373 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1376 2
a1377 3
    fprintf_unfiltered (gdb_stdlog, 
			"store_regs_kernel_thread tid=%lx regno=%d\n",
                        (long) tid, regno);
a1383 2
	  /* Pre-fetch: some regs may not be in the cache.  */
	  ptrace64aix (PTT_READ_GPRS, tid, (unsigned long) gprs64, 0, NULL);
a1388 2
	  /* Pre-fetch: some regs may not be in the cache.  */
	  ptrace32 (PTT_READ_GPRS, tid, gprs32, 0, NULL);
a1397 2
      /* Pre-fetch: some regs may not be in the cache.  */
      ptrace32 (PTT_READ_FPRS, tid, (int *) fprs, 0, NULL);
d1404 2
a1405 1
  if (regno == -1 || special_register_p (regno))
d1409 1
a1409 1
	  /* Pre-fetch: some registers won't be in the cache.  */
d1413 1
a1413 2
		       &sprs64.pt_lr,  &sprs64.pt_ctr, &sprs64.pt_xer,
		       &sprs64.pt_fpscr);
d1419 1
a1419 1
	  /* Pre-fetch: some registers won't be in the cache.  */
d1423 1
a1423 2
		       &sprs32.pt_lr,  &sprs32.pt_ctr, &sprs32.pt_xer,
		       &sprs32.pt_fpscr);
d1425 2
a1426 3
	  if (tdep->ppc_mq_regnum >= 0)
	    if (register_cached (tdep->ppc_mq_regnum))
	      regcache_collect (tdep->ppc_mq_regnum, &sprs32.pt_mq);
d1437 1
a1437 1
aix_thread_store_registers (int regno)
d1443 1
a1443 1
    base_target.to_store_registers (regno);
d1450 1
a1450 1
	store_regs_user_thread (thread->private->pdtid);
d1452 1
a1452 1
	store_regs_kernel_thread (regno, tid);
d1456 16
d1476 3
a1478 3
aix_thread_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		      struct mem_attrib *attrib,
		      struct target_ops *target)
d1484 2
a1485 2
  n = base_target.to_xfer_memory (memaddr, myaddr, len, 
				  write, attrib, &base_target);
d1494 1
a1494 1
aix_thread_kill (void)
d1499 1
a1499 1
  base_target.to_kill ();
d1506 1
a1506 1
aix_thread_mourn_inferior (void)
d1509 1
a1509 1
  base_target.to_mourn_inferior ();
d1515 1
a1515 1
aix_thread_thread_alive (ptid_t ptid)
d1518 1
a1518 1
    return base_target.to_thread_alive (ptid);
d1529 1
a1529 1
aix_thread_pid_to_str (ptid_t ptid)
d1534 1
a1534 1
    return base_target.to_pid_to_str (ptid);
d1548 1
a1548 1
aix_thread_extra_thread_info (struct thread_info *thread)
d1601 1
a1601 1
/* Initialize target aix_thread_ops.  */
d1604 1
a1604 1
init_aix_thread_ops (void)
d1606 13
a1618 12
  aix_thread_ops.to_shortname          = "aix-threads";
  aix_thread_ops.to_longname           = "AIX pthread support";
  aix_thread_ops.to_doc                = "AIX pthread support";

  aix_thread_ops.to_attach             = aix_thread_attach;
  aix_thread_ops.to_detach             = aix_thread_detach;
  aix_thread_ops.to_resume             = aix_thread_resume;
  aix_thread_ops.to_wait               = aix_thread_wait;
  aix_thread_ops.to_fetch_registers    = aix_thread_fetch_registers;
  aix_thread_ops.to_store_registers    = aix_thread_store_registers;
  aix_thread_ops.to_xfer_memory        = aix_thread_xfer_memory;
  /* No need for aix_thread_ops.to_create_inferior, because we activate thread
d1620 7
a1626 7
  aix_thread_ops.to_kill               = aix_thread_kill;
  aix_thread_ops.to_mourn_inferior     = aix_thread_mourn_inferior;
  aix_thread_ops.to_thread_alive       = aix_thread_thread_alive;
  aix_thread_ops.to_pid_to_str         = aix_thread_pid_to_str;
  aix_thread_ops.to_extra_thread_info  = aix_thread_extra_thread_info;
  aix_thread_ops.to_stratum            = thread_stratum;
  aix_thread_ops.to_magic              = OPS_MAGIC;
d1635 2
a1636 2
  init_aix_thread_ops ();
  add_target (&aix_thread_ops);
@


1.8.2.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d929 1
a929 1
  pd_disable ();
@


1.7
log
@	* aix-thread.c (gdb_assert.h): Include.
	(fill_sprs64, fill_sprs32): Add selected asserts to make sure that
	register sizes (from register cache) match size of buffer holding
	register data.
	(fill_sprs32): Change parameter types to match those in the ptrace()
	buffer.
	(store_regs_lib): Likewise, but for 32-bit temporary variables.
	(ops_prepare_to_store): Rename loop variable ``i'' to ``regno''.

	* aix-thread.c (supply_sprs64): Cosmetic change.
	(supply_sprs32): Cosmetic change.
	(fill_gprs64, fill_gprs32, fill_fprs, fill_sprs32): New funcs.
	(fill_sprs64): Use regcache_collect instead of read_register.
	(store_regs_lib): Use regcache_collect instead of
	read_register.  Use fill_sprs32 instead of fill_sprs64,
	if debugging a 32-bit architecture.
	(store_regs_kern): Use fill_gprs64 etc. to pull the values
	out of the register cache, instead of passing a pointer into
	the register cache directly to ptrace.  Use regcache_collect
	insteaad of read_register.
	(ops_prepare_to_store): Use target_read_registers instead
	of read_register_bytes.
@
text
@d1223 2
a1224 1
    regcache_collect (regno, vals + regno);
d1233 2
a1234 1
    regcache_collect (regno, vals + regno);
d1244 2
a1245 1
    regcache_collect (regno, vals + regno);
d1259 12
a1270 6
  regcache_collect (regno,     iar);
  regcache_collect (regno + 1, msr);
  regcache_collect (regno + 2, cr);
  regcache_collect (regno + 3, lr);
  regcache_collect (regno + 4, ctr);
  regcache_collect (regno + 5, xer);
d1285 12
a1296 6
  regcache_collect (regno,     iar);
  regcache_collect (regno + 1, msr);
  regcache_collect (regno + 2, cr);
  regcache_collect (regno + 3, lr);
  regcache_collect (regno + 4, ctr);
  regcache_collect (regno + 5, xer);
d1328 13
a1340 12
    {
      if (arch64)
	{
	  regcache_collect (i, (void *) &int64);
	  ctx.gpr[i] = int64;
	}
      else
	{
	  regcache_collect (i, (void *) &int32);
	  ctx.gpr[i] = int32;
	}
    }
d1359 12
a1370 6
      ctx.iar = tmp_iar;
      ctx.msr = tmp_msr;
      ctx.cr  = tmp_cr;
      ctx.lr  = tmp_lr;
      ctx.ctr = tmp_ctr;
      ctx.xer = tmp_xer;
d1406 2
d1413 2
d1424 2
d1437 1
a1437 1
	  /* Must read first, not all of it's in the cache.  */
d1447 1
a1447 1
	  /* Must read first, not all of it's in the cache.  */
d1454 2
a1455 1
	    regcache_collect (LAST_UISA_SP_REGNUM, &sprs32.pt_mq);
a1484 16
/* Prepare to copy the register cache to the child:
   The register cache must be fully fetched and up to date.  */

static void
ops_prepare_to_store (void)
{
  int regno;

  if (!PD_TID (inferior_ptid))
    base_ops.to_prepare_to_store ();
  else
    for (regno = 0; regno < NUM_REGS; regno++)
      if (!register_cached (regno))
	target_fetch_registers (regno);
}

a1628 1
  ops.to_prepare_to_store   = ops_prepare_to_store;
@


1.6
log
@2002-07-17  Michael Snyder  <msnyder@@redhat.com>

	* aix-thread.c: Shorten some long lines.
	Bring comments into line with code spec.
@
text
@d45 1
d1042 2
a1043 1
  supply_register (regno, (char *) &iar);
d1059 2
a1060 1
  supply_register (regno, (char *) &iar);
d1215 30
d1253 29
a1281 6
  *iar = read_register (regno);
  *msr = read_register (regno + 1);
  *cr = read_register (regno + 2);
  *lr = read_register (regno + 3);
  *ctr = read_register (regno + 4);
  *xer = read_register (regno + 5);
d1295 3
d1310 1
a1310 1
  /* General-purpose registers.  */
d1313 12
a1324 1
    ctx.gpr[i] = read_register (i);
d1326 2
a1327 1
  /* Floating-point registers.  */
d1329 21
a1349 6
  for (i = 0; i < 32; i++)
    ctx.fpr[i] = *(double *) &registers[REGISTER_BYTE (FP0_REGNUM + i)];

  /* Special registers.  */

  fill_sprs64 (&ctx.iar, &ctx.msr, &ctx.cr, &ctx.lr, &ctx.ctr, &ctx.xer);
d1368 3
d1372 2
a1373 2
  struct ptsprs sprs32;
  char *regp;
a1381 1
      regp = &registers[REGISTER_BYTE (0)];
d1383 4
a1386 1
	ptrace64aix (PTT_WRITE_GPRS, tid, (unsigned long) regp, 0, NULL);
d1388 4
a1391 1
	ptrace32 (PTT_WRITE_GPRS, tid, (int *) regp, 0, NULL);
d1398 2
a1399 2
      regp = &registers[REGISTER_BYTE (FP0_REGNUM)];
      ptrace32 (PTT_WRITE_FPRS, tid, (int *) regp, 0, NULL);
d1409 1
d1413 1
a1413 1
		       &sprs64.pt_lr, &sprs64.pt_ctr, &sprs64.pt_xer);
d1419 1
d1422 2
a1423 7
	  regno = FIRST_UISA_SP_REGNUM;
	  sprs32.pt_iar = read_register (regno);
	  sprs32.pt_msr = read_register (regno + 1);
	  sprs32.pt_cr = read_register (regno + 2);
	  sprs32.pt_lr = read_register (regno + 3);
	  sprs32.pt_ctr = read_register (regno + 4);
	  sprs32.pt_xer = read_register (regno + 5);
d1426 1
a1426 1
	    sprs32.pt_mq = read_register (LAST_UISA_SP_REGNUM);
d1456 2
a1457 1
/* Prepare to modify the registers array.  */
d1462 2
d1467 3
a1469 1
    read_register_bytes (0, NULL, REGISTER_BYTES);
@


1.5
log
@	* aix-thread.c (ptrace_check): Use safe_strerror() instead of
	strerror().
	(pdc_realloc): Use xrealloc() instead of realloc().
@
text
@d34 7
a40 7
     - pthdb_ptid_pthread() is prototyped in <sys/pthdebug.h>, but it's not
       documented, and after several calls it stops working and causes other
       libpthdebug functions to fail.

     - pthdb_tid_pthread() doesn't always work after pthdb_session_update(),
       but it does work after cycling through all threads using
       pthdb_pthread().
d66 1
a66 1
/* Whether to emit debugging output. */
d69 1
a69 1
/* in AIX 5.1, functions use pthdb_tid_t instead of tid_t */
d74 1
a74 1
/* Return whether to treat PID as a debuggable thread id. */
d85 1
a85 1
   PTHDB_BAD_USER errors, so use 1. */
d89 1
a89 1
/* Success and failure values returned by pthdb callbacks. */
d94 1
a94 1
/* Private data attached to each element in GDB's thread list. */
d97 1
a97 1
  pthdb_pthread_t pdtid;	/* thread's libpthdebug id */
d101 1
a101 1
/* Information about a thread of which libpthdebug is aware. */
d109 1
a109 1
/* This module's target-specific operations, active while pd_able is true. */
d113 3
a115 3
/* Copy of the target over which ops is pushed.  This is
   more convenient than a pointer to child_ops or core_ops, because
   they lack current_target's default callbacks. */
d119 2
a120 2
/* Address of the function that libpthread will call when libpthdebug is
   ready to be initialized. */
d124 1
a124 1
/* Whether the current application is debuggable by pthdb. */
d128 1
a128 1
/* Whether a threaded application is being debugged. */
d132 2
a133 2
/* Whether the current architecture is 64-bit.  Only valid when pd_able is
   true. */
d137 1
a137 1
/* Saved pointer to previous owner of target_new_objfile_hook. */
d141 1
a141 1
/* Forward declarations for pthdb callbacks. */
d147 2
a148 1
			  unsigned long long flags, pthdb_context_t *context);
d150 2
a151 1
			   unsigned long long flags, pthdb_context_t *context);
d156 1
a156 1
/* pthdb callbacks. */
d170 1
a170 1
/* Current pthdb session. */
d174 2
a175 1
/* Return a printable representation of pthdebug function return STATUS. */
d217 3
a219 3
/* A call to ptrace(REQ, ID, ...) just returned RET.  Check for exceptional
   conditions and either return nonlocally or else return 1 for success and 0
   for failure. */
d227 4
a230 4
  /* According to ptrace(2), ptrace may fail with EPERM if "the Identifier
     parameter corresponds to a kernel thread which is stopped in kernel mode
     and whose computational state cannot be read or written."  This happens
     quite often with register reads. */
d240 2
a241 1
	    fprintf_unfiltered (gdb_stdlog, "ptrace (%d, %d) = %d (errno = %d)",
d249 1
a249 1
  return 0;  /* not reached.  */
d252 1
a252 1
/* Call ptracex(REQ, ID, ADDR, DATA, BUF).  Return success. */
d261 1
a261 1
/* Call ptrace(REQ, ID, ADDR, DATA, BUF).  Return success. */
d267 2
a268 1
  return ptrace_check (req, id, ptrace (req, id, (int *)addr, data, buf));
d271 2
a272 1
/* If *PIDP is a composite process/thread id, convert it to a process id. */
d284 2
a285 2
/* pthdb callback: for <i> from 0 to COUNT, set SYMBOLS[<i>].addr to the
   address of SYMBOLS[<i>].name. */
d303 2
a304 1
	fprintf_unfiltered (gdb_stdlog, "  symbols[%d].name = \"%s\"", i, name);
d327 6
a332 5
/* Read registers call back function should be able to read the context */
/* information of a debuggee kernel thread from an active process or from */
/* a core file. The information should be formatted in context64 form for */
/* both 32-bit and 64-bit process. If successful return 0, else non-zero */
/* is returned. */
d339 6
a344 5
  /* this function doesn't appear to be used, so we could probably just */
  /* return 0 here.  HOWEVER, if it is not defined, the OS will complain */
  /* and several thread debug functions will fail. In case this is needed, */
  /* I have implemented what I think it should do, however this code is */
  /* untested. */
d355 1
a355 1
  /* General-purpose registers. */
d360 2
a361 1
	  if (!ptrace64aix (PTT_READ_GPRS, tid, (unsigned long) gprs64, 0, NULL))
d373 1
a373 1
  /* Floating-point registers. */
d381 1
a381 1
  /* Special-purpose registers. */
d386 2
a387 1
	  if (!ptrace64aix (PTT_READ_SPRS, tid, (unsigned long) &sprs64, 0, NULL))
d401 4
a404 3
/* Write register function should be able to write requested context */
/* information to specified debuggee's kernel thread id. If successful */
/* return 0, else non-zero is returned. */
d411 5
a415 5
  /* this function doesn't appear to be used, so we could probably just */
  /* return 0 here.  HOWEVER, if it is not defined, the OS will complain */
  /* and several thread debug functions will fail. In case this is needed, */
  /* I have implemented what I think it should do, however this code is */
  /* untested. */
d421 1
a421 1
  /* General-purpose registers. */
d425 2
a426 1
	ptrace64aix (PTT_WRITE_GPRS, tid, (unsigned long)context->gpr, 0, NULL);
d431 1
a431 1
 /* Floating-point registers. */
d437 1
a437 1
  /* Special-purpose registers. */
d442 2
a443 1
	  ptrace64aix (PTT_WRITE_SPRS, tid, (unsigned long) &context->msr, 0, NULL);
d453 1
a453 1
/* pthdb callback: read LEN bytes from process ADDR into BUF. */
d456 2
a457 1
pdc_read_data (pthdb_user_t user, void *buf, pthdb_addr_t addr, size_t len)
d470 2
a471 2
    fprintf_unfiltered (gdb_stdlog, "  status=%d, returning %s", status,
			pd_status2str (ret));
d475 1
a475 1
/* pthdb callback: write LEN bytes from BUF to process ADDR. */
d478 2
a479 1
pdc_write_data (pthdb_user_t user, void *buf, pthdb_addr_t addr, size_t len)
d497 2
a498 2
/* pthdb callback: allocate a LEN-byte buffer and store a pointer to it in
   BUFP. */
d509 6
a514 3
    fprintf_unfiltered (gdb_stdlog, "  malloc returned 0x%lx", (long) *bufp);
  /* Note: xmalloc() can't return 0; therefore PDC_FAILURE will never be
     returned.  */
d518 3
a520 3
/* pthdb callback: reallocate BUF, which was allocated by the alloc or realloc
   callback, so that it contains LEN bytes, and store a pointer to the result
   in BUFP. */
d531 2
a532 1
    fprintf_unfiltered (gdb_stdlog, "  realloc returned 0x%lx", (long) *bufp);
d536 2
a537 2
/* pthdb callback: free BUF, which was allocated by the alloc or realloc
   callback. */
d543 2
a544 1
    fprintf_unfiltered (gdb_stdlog, "pdc_free (user = %ld, buf = 0x%lx)", user,
d550 1
a550 1
/* Return a printable representation of pthread STATE. */
d566 1
a566 1
/* qsort() comparison function for sorting pd_thread structs by pthid. */
d576 1
a576 1
/* iterate_over_threads() callback for counting GDB threads. */
d585 1
a585 1
/* iterate_over_threads() callback for accumulating GDB thread pids. */
d596 1
d618 1
a618 1
/* qsort() comparison function for sorting thread_info structs by pid. */
d632 2
a633 2
     - allows users to run thread-specific commands without needing to run
       "info threads" first
d638 2
a639 2
     - simplifies the demands placed on libpthdebug, which seems to have
       difficulty with certain call patterns */
d652 1
a652 1
  /* Accumulate an array of libpthdebug threads sorted by pthread id. */
d671 2
a672 1
	  pbuf = (struct pd_thread *) xrealloc (pbuf, psize * sizeof *pbuf);
d689 1
a689 1
  /* Accumulate an array of GDB threads sorted by pid. */
d697 1
a697 1
  /* Apply differences between the two arrays to GDB's thread list. */
d754 2
a755 2
/* iterate_over_threads() callback for locating a thread whose kernel thread
   just received a trap signal. */
d763 3
a765 2
  /* getthrds(3) isn't prototyped in any AIX 4.3.3 #include file. */
  extern int getthrds (pid_t, struct thrdsinfo64 *, int, pthdb_tid_t *, int);
d771 2
a772 1
  if (getthrds (PIDGET (inferior_ptid), &thrinf, sizeof (thrinf), &tid, 1) != 1)
d778 3
a780 3
/* Synchronize libpthdebug's state with the inferior and with GDB, generate a
   composite process/thread <pid> for the current thread, set inferior_ptid to
   <pid> if SET_INFPID, and return <pid>. */
d798 1
a798 1
  /* Define "current thread" as one that just received a trap signal. */
d812 3
a814 2
/* Try to start debugging threads in the current process.  If successful and
   SET_INFPID, set inferior_ptid to reflect the current thread. */
d822 2
a823 1
			       PTHDB_FLAG_REGS, &pd_callbacks, &pd_session);
d832 1
a832 1
/* Undo the effects of pd_activate(). */
d845 2
a846 2
/* An object file has just been loaded.  Check whether the current application
   is pthreaded, and if so, prepare for thread debugging. */
d855 1
a855 1
  /* Don't initialize twice. */
d859 1
a859 1
  /* Check application word size. */
d862 1
a862 1
  /* Check whether the application is pthreaded. */
d864 4
a867 3
  status = pthdb_session_pthreaded (PD_USER, PTHDB_FLAG_REGS, &pd_callbacks,
				    &stub_name);
  if ((status != PTHDB_SUCCESS && status != PTHDB_NOT_PTHREADED) || !stub_name)
d870 1
a870 1
  /* Set a breakpoint on the returned stub function. */
d877 1
a877 1
  /* Prepare for thread debugging. */
d882 3
a884 3
  /* If we're debugging a core file or an attached inferior, the pthread
     library may already have been initialized, so try to activate thread
     debugging. */
d888 1
a888 1
/* Undo the effects of pd_enable(). */
d903 2
a904 2
   If OBJFILE is non-null, check whether a threaded application is being
   debugged, and if so, prepare for thread debugging.
d906 1
a906 1
   If OBJFILE is null, stop debugging threads. */
d920 1
a920 1
/* Attach to process specified by ARGS. */
d929 1
a929 1
/* Detach from the process attached to by ops_attach(). */
d939 1
a939 1
   and all threads otherwise. */
d958 2
a959 1
	error ("aix-thread resume: unknown pthread %ld", TIDGET (ptid));
d963 2
a964 1
	error ("aix-thread resume: no tid for pthread %ld", TIDGET (ptid));
d968 2
a969 1
	ptrace64aix (PTT_CONTINUE, tid[0], 1, target_signal_to_host (sig), (int *)tid);
d976 3
a978 2
/* Wait for thread/process ID if != -1 or for any thread otherwise.  If an
   error occurs, return -1, else return the pid of the stopped thread. */
d994 1
a994 1
  /* Check whether libpthdebug might be ready to be initialized. */
d1003 1
a1003 1
/* Record that the 64-bit general-purpose registers contain VALS. */
d1014 1
a1014 1
/* Record that 32-bit register REGNO contains VAL. */
d1022 1
a1022 1
/* Record that the floating-point registers contain VALS. */
d1033 2
a1034 2
/* Record that the special registers contain the specified 64-bit and 32-bit
   values. */
d1049 2
a1050 1
/* Record that the special registers contain the specified 32-bit values. */
d1068 3
a1070 2
   There's no way to query a single register from a non-kernel pthread,
   so there's no need for a single-register version of this function. */
d1085 1
a1085 1
  /* General-purpose registers. */
d1093 1
a1093 1
  /* Floating-point registers. */
d1097 1
a1097 1
  /* Special registers. */
d1105 2
a1106 2
/* Fetch register REGNO if != -1 or all registers otherwise from kernel thread
   TID.
d1108 11
a1118 9
   AIX provides a way to query all of a kernel thread's GPRs, FPRs, or SPRs,
   but there's no way to query individual registers within those groups.
   Therefore, if REGNO != -1, this function fetches an entire group.

   Unfortunately, kernel thread register queries often fail with EPERM,
   indicating that the thread is in kernel space.  This breaks backtraces of
   threads other than the current one.  To make that breakage obvious without
   throwing an error to top level (which is bad e.g. during "info threads"
   output), zero registers that can't be retrieved. */
d1135 1
a1135 1
  /* General-purpose registers. */
d1140 2
a1141 1
	  if (!ptrace64aix (PTT_READ_GPRS, tid, (unsigned long) gprs64, 0, NULL))
d1154 1
a1154 1
  /* Floating-point registers. */
d1163 1
a1163 1
  /* Special-purpose registers. */
d1165 2
a1166 1
  if (regno == -1 || (regno > FPLAST_REGNUM && regno <= LAST_UISA_SP_REGNUM))
d1170 2
a1171 1
	  if (!ptrace64aix (PTT_READ_SPRS, tid, (unsigned long) &sprs64, 0, NULL))
d1190 1
a1190 1
   thread/process specified by inferior_ptid. */
d1213 1
a1213 1
   locations. */
d1231 2
a1232 2
   It's possible to store a single register into a non-kernel pthread, but I
   doubt it's worth the effort. */
d1241 2
a1242 1
    fprintf_unfiltered (gdb_stdlog, "store_regs_lib %lx\n", (long)pdtid);
d1244 2
a1245 1
  /* Retrieve the thread's current context for its non-register values. */
d1251 1
a1251 1
  /* General-purpose registers. */
d1256 1
a1256 1
  /* Floating-point registers. */
d1261 1
a1261 1
  /* Special registers. */
d1271 2
a1272 2
/* Store register REGNO if != -1 or all registers otherwise into kernel
   thread TID.
d1274 4
a1277 3
   AIX provides a way to set all of a kernel thread's GPRs, FPRs, or SPRs, but
   there's no way to set individual registers within those groups.  Therefore,
   if REGNO != -1, this function stores an entire group. */
d1290 1
a1290 1
  /* General-purpose registers. */
d1300 1
a1300 1
  /* Floating-point registers. */
d1308 1
a1308 1
  /* Special-purpose registers. */
d1310 2
a1311 1
  if (regno == -1 || (regno > FPLAST_REGNUM && regno <= LAST_UISA_SP_REGNUM))
d1315 2
a1316 1
	  ptrace64aix (PTT_READ_SPRS, tid, (unsigned long) &sprs64, 0, NULL);
d1319 2
a1320 1
	  ptrace64aix (PTT_WRITE_SPRS, tid, (unsigned long) &sprs64, 0, NULL);
d1342 2
a1343 2
/* Store gdb's current view of the register set into the thread/process
   specified by inferior_ptid. */
d1365 1
a1365 1
/* Prepare to modify the registers array. */
d1376 2
a1377 2
/* Transfer LEN bytes of memory from GDB address MYADDR to target address
   MEMADDR if WRITE and vice versa otherwise. */
d1388 2
a1389 1
  n = base_ops.to_xfer_memory (memaddr, myaddr, len, write, attrib, &base_ops);
d1395 1
a1395 1
/* Kill and forget about the inferior process. */
d1407 1
a1407 1
/* Clean up after the inferior exits. */
d1416 1
a1416 1
/* Return whether thread PID is still valid. */
d1424 2
a1425 2
  /* We update the thread list every time the child stops, so all valid
     threads should be in the thread list. */
d1429 2
a1430 2
/* Return a printable representation of composite PID for use in "info
   threads" output. */
d1448 2
a1449 2
/* Return a printable representation of extra information about THREAD, for
   use in "info threads" output. */
d1481 2
a1482 1
  status = pthdb_pthread_suspendstate (pd_session, pdtid, &suspendstate);
d1486 2
a1487 1
  status = pthdb_pthread_detachstate (pd_session, pdtid, &detachstate);
d1505 1
a1505 1
/* Initialize target ops. */
d1522 2
a1523 2
  /* No need for ops.to_create_inferior, because we activate thread debugging
     when the inferior reaches pd_brk_addr. */
d1534 1
a1534 1
   init.c. */
d1542 1
a1542 1
  /* Notice when object files get loaded and unloaded. */
@


1.4
log
@	* aix-thread.c (PD_ERROR, CALL_BASE): Delete.
	(ops_resume, ops_wait, fetch_regs_lib, store_regs_lib)
	(ops_xfer_memory, ops_kill): Don't use PD_ERROR or CALL_BASE
	macros.
@
text
@d244 1
a244 1
	 req, id, ret, errno, strerror (errno));
d510 1
a510 1
  *bufp = realloc (buf, len);
@


1.3
log
@	* aix-thread.c (ptrace_check): Eliminate goto.
	(sync_threadlists): Eliminate gotos.  Also, fix array overrun
	problem.
@
text
@a83 6
/* Call error() with a message indicating that libpthdebug FUNC failed with
   STATUS. */

#define PD_ERROR(func, status) \
  error ("aix-thread: %s returned %s", func, pd_status2str (status))

a93 11
/* Convert composite process/thread inferior_ptid to a process id, evaluate
   base_ops function CALL, and then restore inferior_ptid. */

#define CALL_BASE(call)					\
  do {							\
    struct cleanup *cleanup = save_inferior_ptid ();	\
    inferior_ptid = pid_to_ptid (PIDGET (inferior_ptid)); \
    call;						\
    do_cleanups (cleanup);				\
  } while (0)

d920 6
a925 1
    CALL_BASE (base_ops.to_resume (ptid, step, sig));
d951 2
d954 5
a958 1
  CALL_BASE (ptid = base_ops.to_wait (ptid, status));
d1048 2
a1049 1
    PD_ERROR ("fetch_registers: pthdb_pthread_context", status);
d1207 2
a1208 1
    PD_ERROR ("store_registers: pthdb_pthread_context", status);
d1226 2
a1227 1
    PD_ERROR ("store_registers: pthdb_pthread_setcontext", status);
d1340 5
a1345 2
  CALL_BASE (n = base_ops.to_xfer_memory (memaddr, myaddr, len, write,
					  attrib, &base_ops));
d1354 5
a1358 1
  CALL_BASE (base_ops.to_kill ());
@


1.2
log
@	* aix-thread.c (gdbcmd.h): Include.
	(DEBUG, DBG, DBG2, dbg): Eliminate.
	(debug_aix_thread): New static global.
	(ptrace_check, pdc_symbol_addrs, pdc_read_regs, pdc_write_regs)
	(pdc_read_data, pdc_write_data, pdc_alloc, pdc_realloc, pdc_dealloc)
	(fetch_regs_lib, store_regs_lib, store_regs_kern): Rewrite
	invocations to DBG and DBG2 macros to test against
	``debug_aix_thread'' and call fprintf_unfiltered().
	(_initialize_aix_thread): Add new command "set debug aix-thread".
@
text
@d252 6
a257 1
	goto strange;
d262 1
a262 6

 strange:
  if (debug_aix_thread)
    fprintf_unfiltered (gdb_stdlog, "ptrace (%d, %d) = %d (errno = %d)",
			req, id, ret, errno);
  return ret == -1 ? 0 : 1;
a645 1
  ptid_t pptid, gptid;
a695 5
      pptid = BUILD_THREAD (pbuf[pi].pthid, infpid);
      gptid = gbuf[gi]->ptid;
      pdtid = pbuf[pi].pdtid;
      tid = pbuf[pi].tid;

a696 5
	goto del;
      if (gi == gcount)
	goto add;

      if (ptid_equal (pptid, gptid))
d698 1
a698 3
	  gbuf[gi]->private->pdtid = pdtid;
	  gbuf[gi]->private->tid = tid;
	  pi++;
d701 1
a701 1
      else if (ptid_cmp (pptid, gptid) > 0)
d703 5
a707 3
	del:
	  delete_thread (gptid);
	  gi++;
d711 30
a740 6
	add:
	  thread = add_thread (pptid);
	  thread->private = xmalloc (sizeof (struct private_thread_info));
	  thread->private->pdtid = pdtid;
	  thread->private->tid = tid;
	  pi++;
a741 1

@


1.1
log
@	From Nicholas Duffek (with minor changes by Martin Hunt,
	Louis Hamilton, and Kevin Buettner):
	* aix-thread.c: New file.
@
text
@d49 1
d67 1
a67 16

#define DEBUG 0

/* Default debugging output file, overridden by envvar UWTHR_DEBUG. */

#define DEBUG_FILE "/dev/tty"

/* #if DEBUG, write string S to the debugging output channel. */

#if !DEBUG
# define DBG(fmt_and_args)
# define DBG2(fmt_and_args)
#else
# define DBG(fmt_and_args) dbg fmt_and_args
# define DBG2(fmt_and_args) dbg fmt_and_args
#endif
a188 34
#if DEBUG
/* DBG() helper: if printf-style FMT is non-null, format it with args and
   display the result on the debugging output channel. */

static void
dbg (char *fmt, ...)
{
  static int fd = -1, len;
  va_list args;
  char buf[1024];
  char *path;

  if (!fmt)
    return;

  if (fd < 0)
    {
      path = getenv ("UWTHR_DEBUG");
      if (!path)
	path = DEBUG_FILE;
      if ((fd = open (path, O_WRONLY | O_CREAT | O_TRUNC, 0664)) < 0)
	error ("can't open %s\n", path);
    }

  va_start (args, fmt);
  vsprintf (buf, fmt, args);
  va_end (args);

  len = strlen (buf);
  buf[len] = '\n';
  (void)write (fd, buf, len + 1);
}
#endif   /* DEBUG */

d259 3
a261 1
  DBG2(("ptrace (%d, %d) = %d (errno = %d)", req, id, ret, errno));
d305 4
a308 2
  DBG2(("pdc_symbol_addrs (user = %ld, symbols = 0x%x, count = %d)",
	user, symbols, count));
d313 2
a314 1
      DBG2(("  symbols[%d].name = \"%s\"", i, name));
d322 2
a323 1
	      DBG2((" returning PDC_FAILURE"));
d328 3
a330 1
      DBG2(("  symbols[%d].addr = 0x%llx", i, symbols[i].addr));
d332 2
a333 1
  DBG2((" returning PDC_SUCCESS"));
d359 3
a361 1
  DBG2(("pdc_read_regs tid=%d flags=%llx\n", (int)tid, flags));
d422 3
a424 1
  DBG2(("pdc_write_regs tid=%d flags=%llx\n", (int)tid, flags));
d463 4
a466 2
  DBG2(("pdc_read_data (user = %ld, buf = 0x%x, addr = 0x%llx, len = %d)",
	user, buf, addr, len));
d471 3
a473 1
  DBG2(("  status=%d, returning %s", status, pd_status2str (ret)));
d484 4
a487 2
  DBG2(("pdc_write_data (user = %ld, buf = 0x%x, addr = 0x%llx, len = %d)",
	user, buf, addr, len));
d492 3
a494 1
  DBG2(("  status=%d, returning %s", status, pd_status2str (ret)));
d504 4
a507 1
  DBG2(("pdc_alloc (user = %ld, len = %d, bufp = 0x%x)", user, len, bufp));
d509 2
a510 1
  DBG2(("  malloc returned 0x%x", *bufp));
d523 4
a526 2
  DBG2(("pdc_realloc (user = %ld, buf = 0x%x, len = %d, bufp = 0x%x)",
	user, buf, len, bufp));
d528 2
a529 1
  DBG2(("  realloc returned 0x%x", *bufp));
d539 3
a541 1
  DBG2(("pdc_free (user = %ld, buf = 0x%x)", user, buf));
d1038 2
a1039 1
  DBG2 (("fetch_regs_lib %lx\n", (long)pdtid));
d1087 4
a1090 1
  DBG2 (("fetch_regs_kern tid=%lx regno=%d arch64=%d\n", (long)tid, regno, arch64));
d1194 2
a1195 1
  DBG2 (("store_regs_lib %lx\n", (long)pdtid));
d1235 3
a1237 1
  DBG2 (("store_regs_kern tid=%lx regno=%d\n", (long)tid, regno));
d1481 7
@

