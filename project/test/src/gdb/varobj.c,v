head	1.216;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.206
	gdb_7_6-2013-04-26-release:1.206
	gdb_7_6-branch:1.206.0.2
	gdb_7_6-2013-03-12-branchpoint:1.206
	gdb_7_5_1-2012-11-29-release:1.196.2.1
	gdb_7_5-2012-08-17-release:1.196.2.1
	gdb_7_5-branch:1.196.0.2
	gdb_7_5-2012-07-18-branchpoint:1.196
	gdb_7_4_1-2012-04-26-release:1.182.2.1
	gdb_7_4-2012-01-24-release:1.182.2.1
	gdb_7_4-branch:1.182.0.2
	gdb_7_4-2011-12-13-branchpoint:1.182
	gdb_7_3_1-2011-09-04-release:1.176.2.2
	gdb_7_3-2011-07-26-release:1.176.2.1
	gdb_7_3-branch:1.176.0.2
	gdb_7_3-2011-04-01-branchpoint:1.176
	gdb_7_2-2010-09-02-release:1.158
	gdb_7_2-branch:1.158.0.2
	gdb_7_2-2010-07-07-branchpoint:1.158
	gdb_7_1-2010-03-18-release:1.154.2.2
	gdb_7_1-branch:1.154.0.2
	gdb_7_1-2010-02-18-branchpoint:1.154
	gdb_7_0_1-2009-12-22-release:1.148.2.1
	gdb_7_0-2009-10-06-release:1.148.2.1
	gdb_7_0-branch:1.148.0.2
	gdb_7_0-2009-09-16-branchpoint:1.148
	arc-sim-20090309:1.103
	msnyder-checkpoint-072509-branch:1.143.0.2
	msnyder-checkpoint-072509-branchpoint:1.143
	arc-insight_6_8-branch:1.103.0.6
	arc-insight_6_8-branchpoint:1.103
	insight_6_8-branch:1.103.0.4
	insight_6_8-branchpoint:1.103
	reverse-20081226-branch:1.120.0.4
	reverse-20081226-branchpoint:1.120
	multiprocess-20081120-branch:1.120.0.2
	multiprocess-20081120-branchpoint:1.120
	reverse-20080930-branch:1.117.0.2
	reverse-20080930-branchpoint:1.117
	reverse-20080717-branch:1.115.0.2
	reverse-20080717-branchpoint:1.115
	msnyder-reverse-20080609-branch:1.114.0.2
	msnyder-reverse-20080609-branchpoint:1.114
	drow-reverse-20070409-branch:1.88.0.2
	drow-reverse-20070409-branchpoint:1.88
	gdb_6_8-2008-03-27-release:1.103
	gdb_6_8-branch:1.103.0.2
	gdb_6_8-2008-02-26-branchpoint:1.103
	gdb_6_7_1-2007-10-29-release:1.95
	gdb_6_7-2007-10-10-release:1.95
	gdb_6_7-branch:1.95.0.2
	gdb_6_7-2007-09-07-branchpoint:1.95
	insight_6_6-20070208-release:1.60.6.1
	gdb_6_6-2006-12-18-release:1.60.6.1
	gdb_6_6-branch:1.60.0.6
	gdb_6_6-2006-11-15-branchpoint:1.60
	insight_6_5-20061003-release:1.60
	gdb-csl-symbian-6_4_50_20060226-12:1.58.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.55
	nickrob-async-20060828-mergepoint:1.60
	gdb-csl-symbian-6_4_50_20060226-11:1.58.2.1
	gdb-csl-sourcerygxx-4_1-17:1.58.2.3
	gdb-csl-20060226-branch-local-2:1.58.2.3
	gdb-csl-sourcerygxx-4_1-14:1.58.2.3
	gdb-csl-sourcerygxx-4_1-13:1.58.2.3
	gdb-csl-sourcerygxx-4_1-12:1.58.2.3
	gdb-csl-sourcerygxx-3_4_4-21:1.58.2.3
	gdb_6_5-20060621-release:1.60
	gdb-csl-sourcerygxx-4_1-9:1.58.2.3
	gdb-csl-sourcerygxx-4_1-8:1.58.2.3
	gdb-csl-sourcerygxx-4_1-7:1.58.2.3
	gdb-csl-arm-2006q1-6:1.58.2.3
	gdb-csl-sourcerygxx-4_1-6:1.58.2.3
	gdb-csl-symbian-6_4_50_20060226-10:1.58.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.58.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.58.2.1
	gdb-csl-coldfire-4_1-11:1.58.2.3
	gdb-csl-sourcerygxx-3_4_4-19:1.58.2.3
	gdb-csl-coldfire-4_1-10:1.58.2.3
	gdb_6_5-branch:1.60.0.4
	gdb_6_5-2006-05-14-branchpoint:1.60
	gdb-csl-sourcerygxx-4_1-5:1.58.2.3
	nickrob-async-20060513-branch:1.60.0.2
	nickrob-async-20060513-branchpoint:1.60
	gdb-csl-sourcerygxx-4_1-4:1.58.2.3
	msnyder-reverse-20060502-branch:1.59.0.6
	msnyder-reverse-20060502-branchpoint:1.59
	gdb-csl-morpho-4_1-4:1.58.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.58.2.1
	readline_5_1-import-branch:1.59.0.4
	readline_5_1-import-branchpoint:1.59
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.58.2.1
	gdb-csl-symbian-20060226-branch:1.58.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.58.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.58.2.1
	msnyder-reverse-20060331-branch:1.59.0.2
	msnyder-reverse-20060331-branchpoint:1.59
	gdb-csl-available-20060303-branch:1.58.0.4
	gdb-csl-available-20060303-branchpoint:1.58
	gdb-csl-20060226-branch:1.58.0.2
	gdb-csl-20060226-branchpoint:1.58
	gdb_6_4-20051202-release:1.55
	msnyder-fork-checkpoint-branch:1.55.0.8
	msnyder-fork-checkpoint-branchpoint:1.55
	gdb-csl-gxxpro-6_3-branch:1.55.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.55
	gdb_6_4-branch:1.55.0.4
	gdb_6_4-2005-11-01-branchpoint:1.55
	gdb-csl-arm-20051020-branch:1.55.0.2
	gdb-csl-arm-20051020-branchpoint:1.55
	msnyder-tracepoint-checkpoint-branch:1.54.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.54
	gdb-csl-arm-20050325-2005-q1b:1.53
	gdb-csl-arm-20050325-2005-q1a:1.53
	csl-arm-20050325-branch:1.53.0.2
	csl-arm-20050325-branchpoint:1.53
	gdb-post-i18n-errorwarning-20050211:1.48
	gdb-pre-i18n-errorwarning-20050211:1.47
	gdb_6_3-20041109-release:1.42
	gdb_6_3-branch:1.42.0.2
	gdb_6_3-20041019-branchpoint:1.42
	drow_intercu-merge-20040921:1.42
	drow_intercu-merge-20040915:1.42
	jimb-gdb_6_2-e500-branch:1.41.0.6
	jimb-gdb_6_2-e500-branchpoint:1.41
	gdb_6_2-20040730-release:1.41
	gdb_6_2-branch:1.41.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.41
	gdb_6_1_1-20040616-release:1.40
	gdb_6_1-2004-04-05-release:1.40
	drow_intercu-merge-20040402:1.40
	drow_intercu-merge-20040327:1.40
	ezannoni_pie-20040323-branch:1.40.0.16
	ezannoni_pie-20040323-branchpoint:1.40
	cagney_tramp-20040321-mergepoint:1.40
	cagney_tramp-20040309-branch:1.40.0.14
	cagney_tramp-20040309-branchpoint:1.40
	gdb_6_1-branch:1.40.0.12
	gdb_6_1-2004-03-01-gmt-branchpoint:1.40
	drow_intercu-20040221-branch:1.40.0.10
	drow_intercu-20040221-branchpoint:1.40
	cagney_bfdfile-20040213-branch:1.40.0.8
	cagney_bfdfile-20040213-branchpoint:1.40
	drow-cplus-merge-20040208:1.40
	carlton_dictionary-20040126-merge:1.40
	cagney_bigcore-20040122-branch:1.40.0.6
	cagney_bigcore-20040122-branchpoint:1.40
	drow-cplus-merge-20040113:1.40
	drow-cplus-merge-20031224:1.40
	drow-cplus-merge-20031220:1.40
	carlton_dictionary-20031215-merge:1.40
	drow-cplus-merge-20031214:1.40
	carlton-dictionary-20031111-merge:1.40
	gdb_6_0-2003-10-04-release:1.39
	kettenis_sparc-20030918-branch:1.40.0.4
	kettenis_sparc-20030918-branchpoint:1.40
	carlton_dictionary-20030917-merge:1.40
	ezannoni_pie-20030916-branchpoint:1.40
	ezannoni_pie-20030916-branch:1.40.0.2
	cagney_x86i386-20030821-branch:1.39.0.4
	cagney_x86i386-20030821-branchpoint:1.39
	carlton_dictionary-20030805-merge:1.39
	carlton_dictionary-20030627-merge:1.39
	gdb_6_0-branch:1.39.0.2
	gdb_6_0-2003-06-23-branchpoint:1.39
	jimb-ppc64-linux-20030613-branch:1.38.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.38
	cagney_convert-20030606-branch:1.38.0.30
	cagney_convert-20030606-branchpoint:1.38
	cagney_writestrings-20030508-branch:1.38.0.28
	cagney_writestrings-20030508-branchpoint:1.38
	jimb-ppc64-linux-20030528-branch:1.38.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.38
	carlton_dictionary-20030523-merge:1.38
	cagney_fileio-20030521-branch:1.38.0.24
	cagney_fileio-20030521-branchpoint:1.38
	kettenis_i386newframe-20030517-mergepoint:1.38
	jimb-ppc64-linux-20030509-branch:1.38.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.38
	kettenis_i386newframe-20030504-mergepoint:1.38
	carlton_dictionary-20030430-merge:1.38
	kettenis_i386newframe-20030419-branch:1.38.0.20
	kettenis_i386newframe-20030419-branchpoint:1.38
	carlton_dictionary-20030416-merge:1.38
	cagney_frameaddr-20030409-mergepoint:1.38
	kettenis_i386newframe-20030406-branch:1.38.0.18
	kettenis_i386newframe-20030406-branchpoint:1.38
	cagney_frameaddr-20030403-branchpoint:1.38
	cagney_frameaddr-20030403-branch:1.38.0.16
	cagney_framebase-20030330-mergepoint:1.38
	cagney_framebase-20030326-branch:1.38.0.14
	cagney_framebase-20030326-branchpoint:1.38
	cagney_lazyid-20030317-branch:1.38.0.12
	cagney_lazyid-20030317-branchpoint:1.38
	kettenis-i386newframe-20030316-mergepoint:1.38
	offbyone-20030313-branch:1.38.0.10
	offbyone-20030313-branchpoint:1.38
	kettenis-i386newframe-20030308-branch:1.38.0.8
	kettenis-i386newframe-20030308-branchpoint:1.38
	carlton_dictionary-20030305-merge:1.38
	cagney_offbyone-20030303-branch:1.38.0.6
	cagney_offbyone-20030303-branchpoint:1.38
	carlton_dictionary-20030207-merge:1.38
	interps-20030203-mergepoint:1.38
	interps-20030202-branch:1.38.0.4
	interps-20030202-branchpoint:1.38
	cagney-unwind-20030108-branch:1.38.0.2
	cagney-unwind-20030108-branchpoint:1.38
	carlton_dictionary-20021223-merge:1.38
	gdb_5_3-2002-12-12-release:1.31
	carlton_dictionary-20021115-merge:1.34
	kseitz_interps-20021105-merge:1.33
	kseitz_interps-20021103-merge:1.33
	drow-cplus-merge-20021020:1.32
	drow-cplus-merge-20021025:1.33
	carlton_dictionary-20021025-merge:1.33
	carlton_dictionary-20021011-merge:1.32
	drow-cplus-branch:1.32.0.2
	drow-cplus-branchpoint:1.32
	kseitz_interps-20020930-merge:1.32
	carlton_dictionary-20020927-merge:1.32
	carlton_dictionary-branch:1.31.0.8
	carlton_dictionary-20020920-branchpoint:1.31
	gdb_5_3-branch:1.31.0.6
	gdb_5_3-2002-09-04-branchpoint:1.31
	kseitz_interps-20020829-merge:1.31
	cagney_sysregs-20020825-branch:1.31.0.4
	cagney_sysregs-20020825-branchpoint:1.31
	readline_4_3-import-branch:1.31.0.2
	readline_4_3-import-branchpoint:1.31
	gdb_5_2_1-2002-07-23-release:1.26
	kseitz_interps-20020528-branch:1.28.0.6
	kseitz_interps-20020528-branchpoint:1.28
	cagney_regbuf-20020515-branch:1.28.0.4
	cagney_regbuf-20020515-branchpoint:1.28
	jimb-macro-020506-branch:1.28.0.2
	jimb-macro-020506-branchpoint:1.28
	gdb_5_2-2002-04-29-release:1.26
	gdb_5_2-branch:1.26.0.2
	gdb_5_2-2002-03-03-branchpoint:1.26
	gdb_5_1_1-2002-01-24-release:1.19
	gdb_5_1_0_1-2002-01-03-release:1.19
	cygnus_cvs_20020108_pre:1.25
	gdb_5_1_0_1-2002-01-03-branchpoint:1.19
	gdb_5_1_0_1-2002-01-03-branch:1.19.0.8
	gdb_5_1-2001-11-21-release:1.19
	gdb_s390-2001-09-26-branch:1.19.0.6
	gdb_s390-2001-09-26-branchpoint:1.19
	gdb_5_1-2001-07-29-branch:1.19.0.4
	gdb_5_1-2001-07-29-branchpoint:1.19
	dberlin-typesystem-branch:1.19.0.2
	dberlin-typesystem-branchpoint:1.19
	gdb-post-ptid_t-2001-05-03:1.17
	gdb-pre-ptid_t-2001-05-03:1.17
	insight-precleanup-2001-01-01:1.14
	gdb-post-protoization-2000-07-29:1.7
	gdb-pre-protoization-2000-07-29:1.6
	gdb-premipsmulti-2000-06-06-branch:1.6.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.6
	gdb-post-params-removal-2000-06-04:1.6
	gdb-pre-params-removal-2000-06-04:1.5
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.4
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.3
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.216
date	2013.10.17.13.28.37;	author qiyao;	state Exp;
branches;
next	1.215;

1.215
date	2013.10.14.08.16.45;	author qiyao;	state Exp;
branches;
next	1.214;

1.214
date	2013.10.04.07.16.44;	author qiyao;	state Exp;
branches;
next	1.213;

1.213
date	2013.10.01.13.52.14;	author qiyao;	state Exp;
branches;
next	1.212;

1.212
date	2013.10.01.13.40.27;	author qiyao;	state Exp;
branches;
next	1.211;

1.211
date	2013.10.01.13.28.59;	author qiyao;	state Exp;
branches;
next	1.210;

1.210
date	2013.08.29.04.58.26;	author qiyao;	state Exp;
branches;
next	1.209;

1.209
date	2013.05.30.17.11.38;	author tromey;	state Exp;
branches;
next	1.208;

1.208
date	2013.05.20.20.29.44;	author tromey;	state Exp;
branches;
next	1.207;

1.207
date	2013.04.09.23.30.50;	author brobecke;	state Exp;
branches;
next	1.206;

1.206
date	2013.03.12.17.39.44;	author kseitz;	state Exp;
branches;
next	1.205;

1.205
date	2013.03.07.19.24.32;	author palves;	state Exp;
branches;
next	1.204;

1.204
date	2013.01.31.18.37.38;	author aristovski;	state Exp;
branches;
next	1.203;

1.203
date	2013.01.01.06.41.29;	author brobecke;	state Exp;
branches;
next	1.202;

1.202
date	2012.12.12.16.47.28;	author pkoning;	state Exp;
branches;
next	1.201;

1.201
date	2012.12.03.19.59.14;	author tromey;	state Exp;
branches;
next	1.200;

1.200
date	2012.08.06.18.44.44;	author tromey;	state Exp;
branches;
next	1.199;

1.199
date	2012.08.02.09.36.40;	author qiyao;	state Exp;
branches;
next	1.198;

1.198
date	2012.07.30.12.10.22;	author aburgess;	state Exp;
branches;
next	1.197;

1.197
date	2012.07.19.15.38.16;	author tromey;	state Exp;
branches;
next	1.196;

1.196
date	2012.06.27.18.08.40;	author tromey;	state Exp;
branches
	1.196.2.1;
next	1.195;

1.195
date	2012.04.14.12.18.50;	author xgsa;	state Exp;
branches;
next	1.194;

1.194
date	2012.03.28.21.31.29;	author brobecke;	state Exp;
branches;
next	1.193;

1.193
date	2012.03.28.21.31.18;	author brobecke;	state Exp;
branches;
next	1.192;

1.192
date	2012.03.28.21.31.05;	author brobecke;	state Exp;
branches;
next	1.191;

1.191
date	2012.03.01.21.14.00;	author palves;	state Exp;
branches;
next	1.190;

1.190
date	2012.03.01.01.59.22;	author brobecke;	state Exp;
branches;
next	1.189;

1.189
date	2012.02.07.04.48.23;	author devans;	state Exp;
branches;
next	1.188;

1.188
date	2012.01.12.22.51.10;	author kseitz;	state Exp;
branches;
next	1.187;

1.187
date	2012.01.09.22.31.39;	author devans;	state Exp;
branches;
next	1.186;

1.186
date	2012.01.09.20.27.49;	author kseitz;	state Exp;
branches;
next	1.185;

1.185
date	2012.01.04.08.27.58;	author brobecke;	state Exp;
branches;
next	1.184;

1.184
date	2011.12.28.07.05.20;	author brobecke;	state Exp;
branches;
next	1.183;

1.183
date	2011.12.22.19.51.10;	author tromey;	state Exp;
branches;
next	1.182;

1.182
date	2011.08.26.12.32.59;	author marckhouzam;	state Exp;
branches
	1.182.2.1;
next	1.181;

1.181
date	2011.07.28.10.36.40;	author pmuldoon;	state Exp;
branches;
next	1.180;

1.180
date	2011.07.18.09.21.43;	author jcd;	state Exp;
branches;
next	1.179;

1.179
date	2011.06.30.19.29.55;	author tromey;	state Exp;
branches;
next	1.178;

1.178
date	2011.06.24.19.47.37;	author tromey;	state Exp;
branches;
next	1.177;

1.177
date	2011.04.29.12.45.45;	author pmuldoon;	state Exp;
branches;
next	1.176;

1.176
date	2011.03.31.19.59.25;	author tromey;	state Exp;
branches
	1.176.2.1;
next	1.175;

1.175
date	2011.03.31.16.20.46;	author tromey;	state Exp;
branches;
next	1.174;

1.174
date	2011.03.15.15.52.09;	author muller;	state Exp;
branches;
next	1.173;

1.173
date	2011.03.14.16.55.04;	author muller;	state Exp;
branches;
next	1.172;

1.172
date	2011.03.05.22.02.47;	author msnyder;	state Exp;
branches;
next	1.171;

1.171
date	2011.02.26.02.07.09;	author msnyder;	state Exp;
branches;
next	1.170;

1.170
date	2011.01.12.01.23.29;	author msnyder;	state Exp;
branches;
next	1.169;

1.169
date	2011.01.06.09.30.35;	author brobecke;	state Exp;
branches;
next	1.168;

1.168
date	2011.01.05.22.22.53;	author msnyder;	state Exp;
branches;
next	1.167;

1.167
date	2011.01.01.15.33.19;	author brobecke;	state Exp;
branches;
next	1.166;

1.166
date	2010.11.25.13.10.05;	author palves;	state Exp;
branches;
next	1.165;

1.165
date	2010.11.12.20.49.41;	author tromey;	state Exp;
branches;
next	1.164;

1.164
date	2010.11.11.14.11.52;	author pmuldoon;	state Exp;
branches;
next	1.163;

1.163
date	2010.10.17.08.43.46;	author jkratoch;	state Exp;
branches;
next	1.162;

1.162
date	2010.10.15.18.54.13;	author tromey;	state Exp;
branches;
next	1.161;

1.161
date	2010.10.13.13.24.39;	author jkratoch;	state Exp;
branches;
next	1.160;

1.160
date	2010.08.19.07.34.27;	author jkratoch;	state Exp;
branches;
next	1.159;

1.159
date	2010.08.06.14.17.56;	author jkratoch;	state Exp;
branches;
next	1.158;

1.158
date	2010.05.17.18.48.52;	author msnyder;	state Exp;
branches;
next	1.157;

1.157
date	2010.05.07.00.01.31;	author msnyder;	state Exp;
branches;
next	1.156;

1.156
date	2010.03.03.18.32.44;	author tromey;	state Exp;
branches;
next	1.155;

1.155
date	2010.02.23.17.01.54;	author palves;	state Exp;
branches;
next	1.154;

1.154
date	2010.01.20.06.36.38;	author jkratoch;	state Exp;
branches
	1.154.2.1;
next	1.153;

1.153
date	2010.01.14.08.03.36;	author pmuldoon;	state Exp;
branches;
next	1.152;

1.152
date	2010.01.01.07.31.44;	author brobecke;	state Exp;
branches;
next	1.151;

1.151
date	2009.12.14.06.19.13;	author hilfingr;	state Exp;
branches;
next	1.150;

1.150
date	2009.11.12.19.47.25;	author drow;	state Exp;
branches;
next	1.149;

1.149
date	2009.09.19.16.02.36;	author brobecke;	state Exp;
branches;
next	1.148;

1.148
date	2009.09.15.18.51.24;	author tromey;	state Exp;
branches
	1.148.2.1;
next	1.147;

1.147
date	2009.08.27.06.33.25;	author jkratoch;	state Exp;
branches;
next	1.146;

1.146
date	2009.08.14.00.32.32;	author palves;	state Exp;
branches;
next	1.145;

1.145
date	2009.08.13.18.39.20;	author tromey;	state Exp;
branches;
next	1.144;

1.144
date	2009.07.30.13.12.54;	author jkratoch;	state Exp;
branches;
next	1.143;

1.143
date	2009.07.10.10.35.16;	author pmuldoon;	state Exp;
branches;
next	1.142;

1.142
date	2009.07.07.09.26.13;	author jkratoch;	state Exp;
branches;
next	1.141;

1.141
date	2009.07.07.08.51.31;	author vprus;	state Exp;
branches;
next	1.140;

1.140
date	2009.07.07.08.47.10;	author vprus;	state Exp;
branches;
next	1.139;

1.139
date	2009.07.02.17.04.22;	author uweigand;	state Exp;
branches;
next	1.138;

1.138
date	2009.07.02.12.57.14;	author uweigand;	state Exp;
branches;
next	1.137;

1.137
date	2009.06.30.09.24.47;	author vprus;	state Exp;
branches;
next	1.136;

1.136
date	2009.06.29.13.24.41;	author uweigand;	state Exp;
branches;
next	1.135;

1.135
date	2009.06.17.18.49.36;	author uweigand;	state Exp;
branches;
next	1.134;

1.134
date	2009.06.10.23.39.45;	author palves;	state Exp;
branches;
next	1.133;

1.133
date	2009.06.05.19.43.01;	author tromey;	state Exp;
branches;
next	1.132;

1.132
date	2009.06.04.21.56.22;	author jkratoch;	state Exp;
branches;
next	1.131;

1.131
date	2009.05.28.01.09.19;	author tromey;	state Exp;
branches;
next	1.130;

1.130
date	2009.05.23.16.17.18;	author jkratoch;	state Exp;
branches;
next	1.129;

1.129
date	2009.05.23.15.34.36;	author jkratoch;	state Exp;
branches;
next	1.128;

1.128
date	2009.05.17.07.13.18;	author vprus;	state Exp;
branches;
next	1.127;

1.127
date	2009.04.22.17.50.54;	author jkratoch;	state Exp;
branches;
next	1.126;

1.126
date	2009.04.10.16.00.49;	author jkratoch;	state Exp;
branches;
next	1.125;

1.125
date	2009.04.10.15.57.54;	author jkratoch;	state Exp;
branches;
next	1.124;

1.124
date	2009.03.09.22.35.44;	author jkratoch;	state Exp;
branches;
next	1.123;

1.123
date	2009.02.05.17.28.21;	author palves;	state Exp;
branches;
next	1.122;

1.122
date	2009.01.08.16.32.30;	author tromey;	state Exp;
branches;
next	1.121;

1.121
date	2009.01.03.05.57.54;	author brobecke;	state Exp;
branches;
next	1.120;

1.120
date	2008.10.28.17.19.57;	author tromey;	state Exp;
branches;
next	1.119;

1.119
date	2008.10.08.12.49.13;	author jkratoch;	state Exp;
branches;
next	1.118;

1.118
date	2008.10.02.22.06.07;	author jkratoch;	state Exp;
branches;
next	1.117;

1.117
date	2008.09.13.23.37.05;	author tromey;	state Exp;
branches;
next	1.116;

1.116
date	2008.09.11.14.22.33;	author uweigand;	state Exp;
branches;
next	1.115;

1.115
date	2008.07.11.11.07.39;	author palves;	state Exp;
branches;
next	1.114;

1.114
date	2008.05.28.12.06.36;	author vprus;	state Exp;
branches;
next	1.113;

1.113
date	2008.05.28.06.49.56;	author vprus;	state Exp;
branches;
next	1.112;

1.112
date	2008.05.06.21.34.59;	author brobecke;	state Exp;
branches;
next	1.111;

1.111
date	2008.04.19.16.38.25;	author vprus;	state Exp;
branches;
next	1.110;

1.110
date	2008.04.13.09.33.48;	author vprus;	state Exp;
branches;
next	1.109;

1.109
date	2008.04.09.13.29.51;	author marckhouzam;	state Exp;
branches;
next	1.108;

1.108
date	2008.03.26.14.51.28;	author vprus;	state Exp;
branches;
next	1.107;

1.107
date	2008.03.26.14.11.18;	author vprus;	state Exp;
branches;
next	1.106;

1.106
date	2008.03.24.17.33.30;	author vprus;	state Exp;
branches;
next	1.105;

1.105
date	2008.03.23.09.53.52;	author vprus;	state Exp;
branches;
next	1.104;

1.104
date	2008.03.23.08.59.19;	author vprus;	state Exp;
branches;
next	1.103;

1.103
date	2008.02.04.07.49.04;	author vprus;	state Exp;
branches;
next	1.102;

1.102
date	2008.02.04.06.14.20;	author vprus;	state Exp;
branches;
next	1.101;

1.101
date	2008.01.30.07.17.31;	author vprus;	state Exp;
branches;
next	1.100;

1.100
date	2008.01.29.19.18.18;	author drow;	state Exp;
branches;
next	1.99;

1.99
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.98;

1.98
date	2007.11.20.19.54.39;	author nickrob;	state Exp;
branches;
next	1.97;

1.97
date	2007.11.07.20.06.29;	author vprus;	state Exp;
branches;
next	1.96;

1.96
date	2007.09.27.18.04.12;	author vprus;	state Exp;
branches;
next	1.95;

1.95
date	2007.08.31.19.01.17;	author vprus;	state Exp;
branches
	1.95.2.1;
next	1.94;

1.94
date	2007.08.31.18.52.04;	author vprus;	state Exp;
branches;
next	1.93;

1.93
date	2007.08.23.18.08.46;	author brobecke;	state Exp;
branches;
next	1.92;

1.92
date	2007.08.17.23.17.30;	author msnyder;	state Exp;
branches;
next	1.91;

1.91
date	2007.08.14.18.26.46;	author msnyder;	state Exp;
branches;
next	1.90;

1.90
date	2007.08.08.21.46.37;	author msnyder;	state Exp;
branches;
next	1.89;

1.89
date	2007.04.14.09.51.29;	author vprus;	state Exp;
branches;
next	1.88;

1.88
date	2007.04.01.15.44.54;	author vprus;	state Exp;
branches;
next	1.87;

1.87
date	2007.02.27.23.27.47;	author nickrob;	state Exp;
branches;
next	1.86;

1.86
date	2007.02.27.22.00.39;	author nickrob;	state Exp;
branches;
next	1.85;

1.85
date	2007.02.27.19.46.04;	author drow;	state Exp;
branches;
next	1.84;

1.84
date	2007.02.13.08.15.49;	author denis;	state Exp;
branches;
next	1.83;

1.83
date	2007.02.08.17.39.48;	author drow;	state Exp;
branches;
next	1.82;

1.82
date	2007.01.24.19.54.13;	author vprus;	state Exp;
branches;
next	1.81;

1.81
date	2007.01.24.11.08.47;	author vprus;	state Exp;
branches;
next	1.80;

1.80
date	2007.01.24.10.49.29;	author vprus;	state Exp;
branches;
next	1.79;

1.79
date	2007.01.16.02.12.49;	author vprus;	state Exp;
branches;
next	1.78;

1.78
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.77;

1.77
date	2007.01.08.23.11.47;	author drow;	state Exp;
branches;
next	1.76;

1.76
date	2007.01.05.21.58.48;	author nickrob;	state Exp;
branches;
next	1.75;

1.75
date	2007.01.05.21.52.33;	author nickrob;	state Exp;
branches;
next	1.74;

1.74
date	2007.01.04.23.04.26;	author nickrob;	state Exp;
branches;
next	1.73;

1.73
date	2007.01.04.21.59.10;	author drow;	state Exp;
branches;
next	1.72;

1.72
date	2007.01.04.21.55.04;	author drow;	state Exp;
branches;
next	1.71;

1.71
date	2007.01.04.19.27.50;	author vprus;	state Exp;
branches;
next	1.70;

1.70
date	2007.01.04.19.16.52;	author vprus;	state Exp;
branches;
next	1.69;

1.69
date	2007.01.04.19.06.15;	author vprus;	state Exp;
branches;
next	1.68;

1.68
date	2007.01.03.19.01.25;	author drow;	state Exp;
branches;
next	1.67;

1.67
date	2007.01.03.18.05.44;	author drow;	state Exp;
branches;
next	1.66;

1.66
date	2007.01.01.12.01.04;	author nickrob;	state Exp;
branches;
next	1.65;

1.65
date	2006.12.08.22.06.04;	author nickrob;	state Exp;
branches;
next	1.64;

1.64
date	2006.12.08.12.44.08;	author vprus;	state Exp;
branches;
next	1.63;

1.63
date	2006.12.06.09.01.50;	author vprus;	state Exp;
branches;
next	1.62;

1.62
date	2006.11.29.06.41.13;	author vprus;	state Exp;
branches;
next	1.61;

1.61
date	2006.11.28.17.23.09;	author vprus;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.03.22.59.38;	author jimb;	state Exp;
branches
	1.60.6.1;
next	1.59;

1.59
date	2006.03.27.00.15.22;	author nickrob;	state Exp;
branches;
next	1.58;

1.58
date	2006.02.14.19.05.40;	author aoliva;	state Exp;
branches
	1.58.2.1
	1.58.4.1;
next	1.57;

1.57
date	2006.02.14.18.45.14;	author aoliva;	state Exp;
branches;
next	1.56;

1.56
date	2005.12.17.22.34.03;	author eliz;	state Exp;
branches;
next	1.55;

1.55
date	2005.07.15.04.12.19;	author drow;	state Exp;
branches;
next	1.54;

1.54
date	2005.04.26.05.03.37;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.20.20.30.35;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2005.02.28.17.00.49;	author drow;	state Exp;
branches;
next	1.51;

1.51
date	2005.02.24.13.51.35;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2005.02.20.01.19.24;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2005.02.18.18.58.56;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2005.02.11.04.06.09;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2005.02.07.00.09.55;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2005.02.02.22.34.36;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2005.02.02.00.20.07;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2005.01.14.18.17.18;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2004.11.12.21.45.08;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2004.07.26.14.53.06;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.28.23.59.28;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2003.09.03.20.46.02;	author drow;	state Exp;
branches
	1.40.10.1
	1.40.16.1;
next	1.39;

1.39
date	2003.06.19.20.40.40;	author drow;	state Exp;
branches;
next	1.38;

1.38
date	2002.12.04.00.05.54;	author cagney;	state Exp;
branches
	1.38.28.1;
next	1.37;

1.37
date	2002.11.29.19.15.15;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.24.23.05.03;	author muller;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.24.14.16.38;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2002.11.05.22.31.00;	author jjohnstn;	state Exp;
branches;
next	1.33;

1.33
date	2002.10.23.23.54.33;	author jjohnstn;	state Exp;
branches;
next	1.32;

1.32
date	2002.09.24.18.50.34;	author kseitz;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2002.08.02.20.51.21;	author cagney;	state Exp;
branches
	1.31.8.1;
next	1.30;

1.30
date	2002.07.03.20.23.04;	author hunt;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.15.18.45.31;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.05.01.15.13;	author cagney;	state Exp;
branches
	1.28.4.1
	1.28.6.1;
next	1.27;

1.27
date	2002.04.05.22.04.42;	author jimb;	state Exp;
branches;
next	1.26;

1.26
date	2002.01.13.20.17.55;	author kseitz;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.20.18.08.14;	author kseitz;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.19.19.44.04;	author kseitz;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.01.02.37.56;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.01.02.22.21;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2001.10.10.17.01.52;	author kseitz;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.17.18.56.49;	author kseitz;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.10.16.57.01;	author fnasser;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.05.10.16.44.56;	author fnasser;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.27.20.36.24;	author jtc;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.26.19.47.19;	author jeffh;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.19.05.45.16;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.15.01.01.51;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.29.14.41.34;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.10.01.19.47;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.06.23.12.29;	author fnasser;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.13.20.42.55;	author fnasser;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.13.20.31.38;	author fnasser;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.16.00.49.37;	author fnasser;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.28.01.12.33;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.22.09.02.23;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.30.20.15.35;	author fnasser;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.13.21.51.45;	author jingham;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.03.04.14.36;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.196.2.1
date	2012.08.16.17.08.42;	author tromey;	state Exp;
branches;
next	;

1.182.2.1
date	2012.01.06.04.54.34;	author brobecke;	state Exp;
branches;
next	;

1.176.2.1
date	2011.04.29.12.50.38;	author pmuldoon;	state Exp;
branches;
next	1.176.2.2;

1.176.2.2
date	2011.08.26.12.30.40;	author marckhouzam;	state Exp;
branches;
next	;

1.154.2.1
date	2010.02.23.16.59.29;	author palves;	state Exp;
branches;
next	1.154.2.2;

1.154.2.2
date	2010.03.03.18.33.04;	author tromey;	state Exp;
branches;
next	;

1.148.2.1
date	2009.09.19.16.06.19;	author brobecke;	state Exp;
branches;
next	;

1.95.2.1
date	2007.11.08.08.31.53;	author vprus;	state Exp;
branches;
next	;

1.60.6.1
date	2006.12.08.13.10.38;	author vprus;	state Exp;
branches;
next	;

1.58.2.1
date	2006.04.03.00.47.41;	author drow;	state Exp;
branches;
next	1.58.2.2;

1.58.2.2
date	2006.05.03.01.51.29;	author pbrook;	state Exp;
branches;
next	1.58.2.3;

1.58.2.3
date	2006.05.03.16.30.56;	author pbrook;	state Exp;
branches;
next	;

1.58.4.1
date	2006.04.02.21.52.40;	author drow;	state Exp;
branches;
next	;

1.40.10.1
date	2004.09.16.17.01.27;	author drow;	state Exp;
branches;
next	;

1.40.16.1
date	2004.03.24.04.10.01;	author ezannoni;	state Exp;
branches;
next	;

1.38.28.1
date	2003.06.03.20.54.41;	author cagney;	state Exp;
branches;
next	;

1.32.2.1
date	2002.10.26.17.12.09;	author drow;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2003.12.14.20.27.33;	author drow;	state Exp;
branches;
next	;

1.31.8.1
date	2002.09.27.20.03.09;	author carlton;	state Exp;
branches;
next	1.31.8.2;

1.31.8.2
date	2002.10.25.23.49.55;	author carlton;	state Exp;
branches;
next	1.31.8.3;

1.31.8.3
date	2002.11.15.19.19.00;	author carlton;	state Exp;
branches;
next	1.31.8.4;

1.31.8.4
date	2002.12.23.19.38.49;	author carlton;	state Exp;
branches;
next	1.31.8.5;

1.31.8.5
date	2003.06.27.21.50.13;	author carlton;	state Exp;
branches;
next	1.31.8.6;

1.31.8.6
date	2003.09.17.21.28.36;	author carlton;	state Exp;
branches;
next	;

1.28.4.1
date	2002.06.21.16.19.34;	author cagney;	state Exp;
branches;
next	;

1.28.6.1
date	2002.06.20.01.33.20;	author kseitz;	state Exp;
branches;
next	1.28.6.2;

1.28.6.2
date	2002.07.22.21.47.04;	author kseitz;	state Exp;
branches;
next	1.28.6.3;

1.28.6.3
date	2002.08.09.18.34.28;	author kseitz;	state Exp;
branches;
next	1.28.6.4;

1.28.6.4
date	2002.10.01.00.46.15;	author kseitz;	state Exp;
branches;
next	1.28.6.5;

1.28.6.5
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.19.2.1
date	2001.07.06.19.17.04;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.03.04.14.36;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.216
log
@gdb/

	* Makefile.in (SFILES): Add c-varobj.c and jv-varobj.c.
	(COMMON_OBS): Add c-varobj.o and jv-varobj.o.
	* ada-varobj.c: Include "varobj.h".
	(ada_number_of_children): New.  Moved from varobj.c.
	(ada_name_of_variable, ada_name_of_child): Likewise.
	(ada_path_expr_of_child, ada_value_of_child): Likewise.
	(ada_type_of_child, ada_value_of_variable): Likewise.
	(ada_value_is_changeable_p, ada_value_has_mutated): Likewise.
	(ada_varobj_ops): New.
	* c-varobj.c, jv-varobj.c: New file.  Moved from varobj.c.
	* gdbtypes.c (get_target_type): New.  Moved from varobj.c.
	* gdbtypes.h (get_target_type): Declare.
	* varobj.c: Remove the inclusion of "ada-varobj.h" and
	"ada-lang.h".
	(ANONYMOUS_STRUCT_NAME): Move it to c-varobj.c.
	(ANONYMOUS_UNION_NAME): Likewise.
	(get_type, get_value_type, get_target_type): Remove declarations.
	(value_get_print_value, varobj_value_get_print_value): Likewise.
	(c_number_of_children, c_name_of_variable): Likewise.
	(c_name_of_child, c_path_expr_of_child): Likewise.
	(c_value_of_child, c_type_of_child): Likewise.
	(c_value_of_variable, cplus_number_of_children): Likewise.
	(cplus_class_num_children, cplus_name_of_variable): Likewise.
	(cplus_name_of_child, cplus_path_expr_of_child): Likewise.
	(cplus_value_of_child, cplus_type_of_child): Likewise.
	(cplus_value_of_variable, java_number_of_children): Likewise.
	(java_name_of_variable, java_name_of_child): Likewise.
	(java_path_expr_of_child, java_value_of_child): Likewise.
	(java_type_of_child, java_value_of_variable): Likewise.
	(ada_number_of_children, ada_name_of_variable): Likewise.
	(ada_name_of_child, ada_path_expr_of_child): Likewise.
	(ada_value_of_child, ada_type_of_child): Likewise.
	(ada_value_of_variable, ada_value_is_changeable_p): Likewise.
	(ada_value_has_mutated): Likewise.
	(struct language_specific): Move it to varobj.h.
	(CPLUS_FAKE_CHILD): Move it to varobj.h.
	(restrict_range): Rename it varobj_restrict_range.  Make it extern.
	Callers update.
	(get_path_expr_parent): Rename it to varobj_get_path_expr_parent.
	Make it extern.
	(is_anonymous_child): Move it to c-varobj.c and rename to
	varobj_is_anonymous_child.  Caller update.
	(get_type): Move it to c-varobj.c.
	(get_value_type): Rename it varobj_get_value_type.  Make it
	extern.
	(get_target_type): Move it gdbtypes.c.
	(varobj_formatted_print_options): New function.
	(value_get_print_value): Rename it to
	varobj_value_get_print_value and make it extern.
	(varobj_value_is_changeable_p): Make it extern.
	(adjust_value_for_child_access): Move it to c-varobj.c.
	(default_value_is_changeable_p): Rename it to
	varobj_default_value_is_changeable_p.  Make it extern.
	(c_number_of_children, c_name_of_variable): Move it to c-varobj.c
	(c_name_of_child, c_path_expr_of_child): Likewise.
	(c_value_of_child, c_type_of_child): Likewise.
	(c_value_of_variable, cplus_number_of_children): Likewise.
	(cplus_class_num_children, cplus_name_of_variable): Likewise.
	(cplus_name_of_child, cplus_path_expr_of_child): Likewise.
	(cplus_value_of_child, cplus_type_of_child): Likewise.
	(cplus_value_of_variable): Likewise.
	(java_number_of_children, java_name_of_variable): Move it to jv-varobj.c.
	(java_name_of_child, java_path_expr_of_child): Likewise.
	(java_value_of_child, java_type_of_child): Likewise.
	(java_value_of_variable): Likewise.
	(ada_number_of_children, ada_name_of_variable): Move it to ada-varobj.c.
	(ada_name_of_child, ada_path_expr_of_child): Likewise.
	(ada_value_of_child, ada_type_of_child): Likewise.
	(ada_value_of_variable, ada_value_is_changeable_p): Likewise.
	(ada_value_has_mutated): Likewise.
	* varobj.h (CPLUS_FAKE_CHILD): New macro, moved from varobj.c.
	(struct lang_varobj_ops): New.  Renamed by 'struct language_specific'.
	(c_varobj_ops, cplus_varobj_ops): Declare.
	(java_varobj_ops, ada_varobj_ops): Declare.
	(varobj_default_value_is_changeable_p): Declare.
	(varobj_value_is_changeable_p): Declare.
	(varobj_get_value_type, varobj_is_anonymous_child): Declare.
	(varobj_get_path_expr_parent): Declare.
	(varobj_value_get_print_value): Declare.
	(varobj_formatted_print_options): Declare.
	(varobj_restrict_range): Declare.
@
text
@/* Implementation of the GDB variable objects API.

   Copyright (C) 1999-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "exceptions.h"
#include "value.h"
#include "expression.h"
#include "frame.h"
#include "language.h"
#include "gdbcmd.h"
#include "block.h"
#include "valprint.h"

#include "gdb_assert.h"
#include "gdb_string.h"
#include "gdb_regex.h"

#include "varobj.h"
#include "vec.h"
#include "gdbthread.h"
#include "inferior.h"

#if HAVE_PYTHON
#include "python/python.h"
#include "python/python-internal.h"
#else
typedef int PyObject;
#endif

/* Non-zero if we want to see trace of varobj level stuff.  */

unsigned int varobjdebug = 0;
static void
show_varobjdebug (struct ui_file *file, int from_tty,
		  struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Varobj debugging is %s.\n"), value);
}

/* String representations of gdb's format codes.  */
char *varobj_format_string[] =
  { "natural", "binary", "decimal", "hexadecimal", "octal" };

/* String representations of gdb's known languages.  */
char *varobj_language_string[] = { "C", "C++", "Java" };

/* True if we want to allow Python-based pretty-printing.  */
static int pretty_printing = 0;

void
varobj_enable_pretty_printing (void)
{
  pretty_printing = 1;
}

/* Data structures */

/* Every root variable has one of these structures saved in its
   varobj.  Members which must be free'd are noted.  */
struct varobj_root
{

  /* Alloc'd expression for this parent.  */
  struct expression *exp;

  /* Block for which this expression is valid.  */
  const struct block *valid_block;

  /* The frame for this expression.  This field is set iff valid_block is
     not NULL.  */
  struct frame_id frame;

  /* The thread ID that this varobj_root belong to.  This field
     is only valid if valid_block is not NULL.
     When not 0, indicates which thread 'frame' belongs to.
     When 0, indicates that the thread list was empty when the varobj_root
     was created.  */
  int thread_id;

  /* If 1, the -var-update always recomputes the value in the
     current thread and frame.  Otherwise, variable object is
     always updated in the specific scope/thread/frame.  */
  int floating;

  /* Flag that indicates validity: set to 0 when this varobj_root refers 
     to symbols that do not exist anymore.  */
  int is_valid;

  /* Language-related operations for this variable and its
     children.  */
  const struct lang_varobj_ops *lang;

  /* The varobj for this root node.  */
  struct varobj *rootvar;

  /* Next root variable */
  struct varobj_root *next;
};

/* Dynamic part of varobj.  */

struct varobj_dynamic
{
  /* Whether the children of this varobj were requested.  This field is
     used to decide if dynamic varobj should recompute their children.
     In the event that the frontend never asked for the children, we
     can avoid that.  */
  int children_requested;

  /* The pretty-printer constructor.  If NULL, then the default
     pretty-printer will be looked up.  If None, then no
     pretty-printer will be installed.  */
  PyObject *constructor;

  /* The pretty-printer that has been constructed.  If NULL, then a
     new printer object is needed, and one will be constructed.  */
  PyObject *pretty_printer;

  /* The iterator returned by the printer's 'children' method, or NULL
     if not available.  */
  PyObject *child_iter;

  /* We request one extra item from the iterator, so that we can
     report to the caller whether there are more items than we have
     already reported.  However, we don't want to install this value
     when we read it, because that will mess up future updates.  So,
     we stash it here instead.  */
  PyObject *saved_item;
};

struct cpstack
{
  char *name;
  struct cpstack *next;
};

/* A list of varobjs */

struct vlist
{
  struct varobj *var;
  struct vlist *next;
};

/* Private function prototypes */

/* Helper functions for the above subcommands.  */

static int delete_variable (struct cpstack **, struct varobj *, int);

static void delete_variable_1 (struct cpstack **, int *,
			       struct varobj *, int, int);

static int install_variable (struct varobj *);

static void uninstall_variable (struct varobj *);

static struct varobj *create_child (struct varobj *, int, char *);

static struct varobj *
create_child_with_value (struct varobj *parent, int index, char *name,
			 struct value *value);

/* Utility routines */

static struct varobj *new_variable (void);

static struct varobj *new_root_variable (void);

static void free_variable (struct varobj *var);

static struct cleanup *make_cleanup_free_variable (struct varobj *var);

static enum varobj_display_formats variable_default_display (struct varobj *);

static void cppush (struct cpstack **pstack, char *name);

static char *cppop (struct cpstack **pstack);

static int update_type_if_necessary (struct varobj *var,
				     struct value *new_value);

static int install_new_value (struct varobj *var, struct value *value, 
			      int initial);

/* Language-specific routines.  */

static enum varobj_languages variable_language (struct varobj *var);

static int number_of_children (struct varobj *);

static char *name_of_variable (struct varobj *);

static char *name_of_child (struct varobj *, int);

static struct value *value_of_root (struct varobj **var_handle, int *);

static struct value *value_of_child (struct varobj *parent, int index);

static char *my_value_of_variable (struct varobj *var,
				   enum varobj_display_formats format);

static int is_root_p (struct varobj *var);

#if HAVE_PYTHON

static struct varobj *varobj_add_child (struct varobj *var,
					char *name,
					struct value *value);

#endif /* HAVE_PYTHON */

/* Array of known source language routines.  */
static const struct lang_varobj_ops *languages[vlang_end] = {
  &c_varobj_ops,
  &cplus_varobj_ops,
  &java_varobj_ops,
  &ada_varobj_ops,
};

/* Private data */

/* Mappings of varobj_display_formats enums to gdb's format codes.  */
static int format_code[] = { 0, 't', 'd', 'x', 'o' };

/* Header of the list of root variable objects.  */
static struct varobj_root *rootlist;

/* Prime number indicating the number of buckets in the hash table.  */
/* A prime large enough to avoid too many colisions.  */
#define VAROBJ_TABLE_SIZE 227

/* Pointer to the varobj hash table (built at run time).  */
static struct vlist **varobj_table;



/* API Implementation */
static int
is_root_p (struct varobj *var)
{
  return (var->root->rootvar == var);
}

#ifdef HAVE_PYTHON
/* Helper function to install a Python environment suitable for
   use during operations on VAR.  */
static struct cleanup *
varobj_ensure_python_env (struct varobj *var)
{
  return ensure_python_env (var->root->exp->gdbarch,
			    var->root->exp->language_defn);
}
#endif

/* Creates a varobj (not its children).  */

/* Return the full FRAME which corresponds to the given CORE_ADDR
   or NULL if no FRAME on the chain corresponds to CORE_ADDR.  */

static struct frame_info *
find_frame_addr_in_frame_chain (CORE_ADDR frame_addr)
{
  struct frame_info *frame = NULL;

  if (frame_addr == (CORE_ADDR) 0)
    return NULL;

  for (frame = get_current_frame ();
       frame != NULL;
       frame = get_prev_frame (frame))
    {
      /* The CORE_ADDR we get as argument was parsed from a string GDB
	 output as $fp.  This output got truncated to gdbarch_addr_bit.
	 Truncate the frame base address in the same manner before
	 comparing it against our argument.  */
      CORE_ADDR frame_base = get_frame_base_address (frame);
      int addr_bit = gdbarch_addr_bit (get_frame_arch (frame));

      if (addr_bit < (sizeof (CORE_ADDR) * HOST_CHAR_BIT))
	frame_base &= ((CORE_ADDR) 1 << addr_bit) - 1;

      if (frame_base == frame_addr)
	return frame;
    }

  return NULL;
}

struct varobj *
varobj_create (char *objname,
	       char *expression, CORE_ADDR frame, enum varobj_type type)
{
  struct varobj *var;
  struct cleanup *old_chain;

  /* Fill out a varobj structure for the (root) variable being constructed.  */
  var = new_root_variable ();
  old_chain = make_cleanup_free_variable (var);

  if (expression != NULL)
    {
      struct frame_info *fi;
      struct frame_id old_id = null_frame_id;
      struct block *block;
      const char *p;
      enum varobj_languages lang;
      struct value *value = NULL;
      volatile struct gdb_exception except;
      CORE_ADDR pc;

      /* Parse and evaluate the expression, filling in as much of the
         variable's data as possible.  */

      if (has_stack_frames ())
	{
	  /* Allow creator to specify context of variable.  */
	  if ((type == USE_CURRENT_FRAME) || (type == USE_SELECTED_FRAME))
	    fi = get_selected_frame (NULL);
	  else
	    /* FIXME: cagney/2002-11-23: This code should be doing a
	       lookup using the frame ID and not just the frame's
	       ``address''.  This, of course, means an interface
	       change.  However, with out that interface change ISAs,
	       such as the ia64 with its two stacks, won't work.
	       Similar goes for the case where there is a frameless
	       function.  */
	    fi = find_frame_addr_in_frame_chain (frame);
	}
      else
	fi = NULL;

      /* frame = -2 means always use selected frame.  */
      if (type == USE_SELECTED_FRAME)
	var->root->floating = 1;

      pc = 0;
      block = NULL;
      if (fi != NULL)
	{
	  block = get_frame_block (fi, 0);
	  pc = get_frame_pc (fi);
	}

      p = expression;
      innermost_block = NULL;
      /* Wrap the call to parse expression, so we can 
         return a sensible error.  */
      TRY_CATCH (except, RETURN_MASK_ERROR)
	{
	  var->root->exp = parse_exp_1 (&p, pc, block, 0);
	}

      if (except.reason < 0)
	{
	  do_cleanups (old_chain);
	  return NULL;
	}

      /* Don't allow variables to be created for types.  */
      if (var->root->exp->elts[0].opcode == OP_TYPE
	  || var->root->exp->elts[0].opcode == OP_TYPEOF
	  || var->root->exp->elts[0].opcode == OP_DECLTYPE)
	{
	  do_cleanups (old_chain);
	  fprintf_unfiltered (gdb_stderr, "Attempt to use a type name"
			      " as an expression.\n");
	  return NULL;
	}

      var->format = variable_default_display (var);
      var->root->valid_block = innermost_block;
      var->name = xstrdup (expression);
      /* For a root var, the name and the expr are the same.  */
      var->path_expr = xstrdup (expression);

      /* When the frame is different from the current frame, 
         we must select the appropriate frame before parsing
         the expression, otherwise the value will not be current.
         Since select_frame is so benign, just call it for all cases.  */
      if (innermost_block)
	{
	  /* User could specify explicit FRAME-ADDR which was not found but
	     EXPRESSION is frame specific and we would not be able to evaluate
	     it correctly next time.  With VALID_BLOCK set we must also set
	     FRAME and THREAD_ID.  */
	  if (fi == NULL)
	    error (_("Failed to find the specified frame"));

	  var->root->frame = get_frame_id (fi);
	  var->root->thread_id = pid_to_thread_id (inferior_ptid);
	  old_id = get_frame_id (get_selected_frame (NULL));
	  select_frame (fi);	 
	}

      /* We definitely need to catch errors here.
         If evaluate_expression succeeds we got the value we wanted.
         But if it fails, we still go on with a call to evaluate_type().  */
      TRY_CATCH (except, RETURN_MASK_ERROR)
	{
	  value = evaluate_expression (var->root->exp);
	}

      if (except.reason < 0)
	{
	  /* Error getting the value.  Try to at least get the
	     right type.  */
	  struct value *type_only_value = evaluate_type (var->root->exp);

	  var->type = value_type (type_only_value);
	}
	else
	  {
	    int real_type_found = 0;

	    var->type = value_actual_type (value, 0, &real_type_found);
	    if (real_type_found)
	      value = value_cast (var->type, value);
	  }

      /* Set language info */
      lang = variable_language (var);
      var->root->lang = languages[lang];

      install_new_value (var, value, 1 /* Initial assignment */);

      /* Set ourselves as our root.  */
      var->root->rootvar = var;

      /* Reset the selected frame.  */
      if (frame_id_p (old_id))
	select_frame (frame_find_by_id (old_id));
    }

  /* If the variable object name is null, that means this
     is a temporary variable, so don't install it.  */

  if ((var != NULL) && (objname != NULL))
    {
      var->obj_name = xstrdup (objname);

      /* If a varobj name is duplicated, the install will fail so
         we must cleanup.  */
      if (!install_variable (var))
	{
	  do_cleanups (old_chain);
	  return NULL;
	}
    }

  discard_cleanups (old_chain);
  return var;
}

/* Generates an unique name that can be used for a varobj.  */

char *
varobj_gen_name (void)
{
  static int id = 0;
  char *obj_name;

  /* Generate a name for this object.  */
  id++;
  obj_name = xstrprintf ("var%d", id);

  return obj_name;
}

/* Given an OBJNAME, returns the pointer to the corresponding varobj.  Call
   error if OBJNAME cannot be found.  */

struct varobj *
varobj_get_handle (char *objname)
{
  struct vlist *cv;
  const char *chp;
  unsigned int index = 0;
  unsigned int i = 1;

  for (chp = objname; *chp; chp++)
    {
      index = (index + (i++ * (unsigned int) *chp)) % VAROBJ_TABLE_SIZE;
    }

  cv = *(varobj_table + index);
  while ((cv != NULL) && (strcmp (cv->var->obj_name, objname) != 0))
    cv = cv->next;

  if (cv == NULL)
    error (_("Variable object not found"));

  return cv->var;
}

/* Given the handle, return the name of the object.  */

char *
varobj_get_objname (struct varobj *var)
{
  return var->obj_name;
}

/* Given the handle, return the expression represented by the object.  */

char *
varobj_get_expression (struct varobj *var)
{
  return name_of_variable (var);
}

/* Deletes a varobj and all its children if only_children == 0,
   otherwise deletes only the children; returns a malloc'ed list of
   all the (malloc'ed) names of the variables that have been deleted
   (NULL terminated).  */

int
varobj_delete (struct varobj *var, char ***dellist, int only_children)
{
  int delcount;
  int mycount;
  struct cpstack *result = NULL;
  char **cp;

  /* Initialize a stack for temporary results.  */
  cppush (&result, NULL);

  if (only_children)
    /* Delete only the variable children.  */
    delcount = delete_variable (&result, var, 1 /* only the children */ );
  else
    /* Delete the variable and all its children.  */
    delcount = delete_variable (&result, var, 0 /* parent+children */ );

  /* We may have been asked to return a list of what has been deleted.  */
  if (dellist != NULL)
    {
      *dellist = xmalloc ((delcount + 1) * sizeof (char *));

      cp = *dellist;
      mycount = delcount;
      *cp = cppop (&result);
      while ((*cp != NULL) && (mycount > 0))
	{
	  mycount--;
	  cp++;
	  *cp = cppop (&result);
	}

      if (mycount || (*cp != NULL))
	warning (_("varobj_delete: assertion failed - mycount(=%d) <> 0"),
		 mycount);
    }

  return delcount;
}

#if HAVE_PYTHON

/* Convenience function for varobj_set_visualizer.  Instantiate a
   pretty-printer for a given value.  */
static PyObject *
instantiate_pretty_printer (PyObject *constructor, struct value *value)
{
  PyObject *val_obj = NULL; 
  PyObject *printer;

  val_obj = value_to_value_object (value);
  if (! val_obj)
    return NULL;

  printer = PyObject_CallFunctionObjArgs (constructor, val_obj, NULL);
  Py_DECREF (val_obj);
  return printer;
}

#endif

/* Set/Get variable object display format.  */

enum varobj_display_formats
varobj_set_display_format (struct varobj *var,
			   enum varobj_display_formats format)
{
  switch (format)
    {
    case FORMAT_NATURAL:
    case FORMAT_BINARY:
    case FORMAT_DECIMAL:
    case FORMAT_HEXADECIMAL:
    case FORMAT_OCTAL:
      var->format = format;
      break;

    default:
      var->format = variable_default_display (var);
    }

  if (varobj_value_is_changeable_p (var) 
      && var->value && !value_lazy (var->value))
    {
      xfree (var->print_value);
      var->print_value = varobj_value_get_print_value (var->value,
						       var->format, var);
    }

  return var->format;
}

enum varobj_display_formats
varobj_get_display_format (struct varobj *var)
{
  return var->format;
}

char *
varobj_get_display_hint (struct varobj *var)
{
  char *result = NULL;

#if HAVE_PYTHON
  struct cleanup *back_to;

  if (!gdb_python_initialized)
    return NULL;

  back_to = varobj_ensure_python_env (var);

  if (var->dynamic->pretty_printer != NULL)
    result = gdbpy_get_display_hint (var->dynamic->pretty_printer);

  do_cleanups (back_to);
#endif

  return result;
}

/* Return true if the varobj has items after TO, false otherwise.  */

int
varobj_has_more (struct varobj *var, int to)
{
  if (VEC_length (varobj_p, var->children) > to)
    return 1;
  return ((to == -1 || VEC_length (varobj_p, var->children) == to)
	  && (var->dynamic->saved_item != NULL));
}

/* If the variable object is bound to a specific thread, that
   is its evaluation can always be done in context of a frame
   inside that thread, returns GDB id of the thread -- which
   is always positive.  Otherwise, returns -1.  */
int
varobj_get_thread_id (struct varobj *var)
{
  if (var->root->valid_block && var->root->thread_id > 0)
    return var->root->thread_id;
  else
    return -1;
}

void
varobj_set_frozen (struct varobj *var, int frozen)
{
  /* When a variable is unfrozen, we don't fetch its value.
     The 'not_fetched' flag remains set, so next -var-update
     won't complain.

     We don't fetch the value, because for structures the client
     should do -var-update anyway.  It would be bad to have different
     client-size logic for structure and other types.  */
  var->frozen = frozen;
}

int
varobj_get_frozen (struct varobj *var)
{
  return var->frozen;
}

/* A helper function that restricts a range to what is actually
   available in a VEC.  This follows the usual rules for the meaning
   of FROM and TO -- if either is negative, the entire range is
   used.  */

void
varobj_restrict_range (VEC (varobj_p) *children, int *from, int *to)
{
  if (*from < 0 || *to < 0)
    {
      *from = 0;
      *to = VEC_length (varobj_p, children);
    }
  else
    {
      if (*from > VEC_length (varobj_p, children))
	*from = VEC_length (varobj_p, children);
      if (*to > VEC_length (varobj_p, children))
	*to = VEC_length (varobj_p, children);
      if (*from > *to)
	*from = *to;
    }
}

#if HAVE_PYTHON

/* A helper for update_dynamic_varobj_children that installs a new
   child when needed.  */

static void
install_dynamic_child (struct varobj *var,
		       VEC (varobj_p) **changed,
		       VEC (varobj_p) **type_changed,
		       VEC (varobj_p) **new,
		       VEC (varobj_p) **unchanged,
		       int *cchanged,
		       int index,
		       char *name,
		       struct value *value)
{
  if (VEC_length (varobj_p, var->children) < index + 1)
    {
      /* There's no child yet.  */
      struct varobj *child = varobj_add_child (var, name, value);

      if (new)
	{
	  VEC_safe_push (varobj_p, *new, child);
	  *cchanged = 1;
	}
    }
  else
    {
      varobj_p existing = VEC_index (varobj_p, var->children, index);
      int type_updated = update_type_if_necessary (existing, value);

      if (type_updated)
	{
	  if (type_changed)
	    VEC_safe_push (varobj_p, *type_changed, existing);
	}
      if (install_new_value (existing, value, 0))
	{
	  if (!type_updated && changed)
	    VEC_safe_push (varobj_p, *changed, existing);
	}
      else if (!type_updated && unchanged)
	VEC_safe_push (varobj_p, *unchanged, existing);
    }
}

static int
dynamic_varobj_has_child_method (struct varobj *var)
{
  struct cleanup *back_to;
  PyObject *printer = var->dynamic->pretty_printer;
  int result;

  if (!gdb_python_initialized)
    return 0;

  back_to = varobj_ensure_python_env (var);
  result = PyObject_HasAttr (printer, gdbpy_children_cst);
  do_cleanups (back_to);
  return result;
}

#endif

static int
update_dynamic_varobj_children (struct varobj *var,
				VEC (varobj_p) **changed,
				VEC (varobj_p) **type_changed,
				VEC (varobj_p) **new,
				VEC (varobj_p) **unchanged,
				int *cchanged,
				int update_children,
				int from,
				int to)
{
#if HAVE_PYTHON
  struct cleanup *back_to;
  PyObject *children;
  int i;
  PyObject *printer = var->dynamic->pretty_printer;

  if (!gdb_python_initialized)
    return 0;

  back_to = varobj_ensure_python_env (var);

  *cchanged = 0;
  if (!PyObject_HasAttr (printer, gdbpy_children_cst))
    {
      do_cleanups (back_to);
      return 0;
    }

  if (update_children || var->dynamic->child_iter == NULL)
    {
      children = PyObject_CallMethodObjArgs (printer, gdbpy_children_cst,
					     NULL);

      if (!children)
	{
	  gdbpy_print_stack ();
	  error (_("Null value returned for children"));
	}

      make_cleanup_py_decref (children);

      Py_XDECREF (var->dynamic->child_iter);
      var->dynamic->child_iter = PyObject_GetIter (children);
      if (var->dynamic->child_iter == NULL)
	{
	  gdbpy_print_stack ();
	  error (_("Could not get children iterator"));
	}

      Py_XDECREF (var->dynamic->saved_item);
      var->dynamic->saved_item = NULL;

      i = 0;
    }
  else
    i = VEC_length (varobj_p, var->children);

  /* We ask for one extra child, so that MI can report whether there
     are more children.  */
  for (; to < 0 || i < to + 1; ++i)
    {
      PyObject *item;
      int force_done = 0;

      /* See if there was a leftover from last time.  */
      if (var->dynamic->saved_item)
	{
	  item = var->dynamic->saved_item;
	  var->dynamic->saved_item = NULL;
	}
      else
	item = PyIter_Next (var->dynamic->child_iter);

      if (!item)
	{
	  /* Normal end of iteration.  */
	  if (!PyErr_Occurred ())
	    break;

	  /* If we got a memory error, just use the text as the
	     item.  */
	  if (PyErr_ExceptionMatches (gdbpy_gdb_memory_error))
	    {
	      PyObject *type, *value, *trace;
	      char *name_str, *value_str;

	      PyErr_Fetch (&type, &value, &trace);
	      value_str = gdbpy_exception_to_string (type, value);
	      Py_XDECREF (type);
	      Py_XDECREF (value);
	      Py_XDECREF (trace);
	      if (!value_str)
		{
		  gdbpy_print_stack ();
		  break;
		}

	      name_str = xstrprintf ("<error at %d>", i);
	      item = Py_BuildValue ("(ss)", name_str, value_str);
	      xfree (name_str);
	      xfree (value_str);
	      if (!item)
		{
		  gdbpy_print_stack ();
		  break;
		}

	      force_done = 1;
	    }
	  else
	    {
	      /* Any other kind of error.  */
	      gdbpy_print_stack ();
	      break;
	    }
	}

      /* We don't want to push the extra child on any report list.  */
      if (to < 0 || i < to)
	{
	  PyObject *py_v;
	  const char *name;
	  struct value *v;
	  struct cleanup *inner;
	  int can_mention = from < 0 || i >= from;

	  inner = make_cleanup_py_decref (item);

	  if (!PyArg_ParseTuple (item, "sO", &name, &py_v))
	    {
	      gdbpy_print_stack ();
	      error (_("Invalid item from the child list"));
	    }

	  v = convert_value_from_python (py_v);
	  if (v == NULL)
	    gdbpy_print_stack ();
	  install_dynamic_child (var, can_mention ? changed : NULL,
				 can_mention ? type_changed : NULL,
				 can_mention ? new : NULL,
				 can_mention ? unchanged : NULL,
				 can_mention ? cchanged : NULL, i,
				 xstrdup (name), v);
	  do_cleanups (inner);
	}
      else
	{
	  Py_XDECREF (var->dynamic->saved_item);
	  var->dynamic->saved_item = item;

	  /* We want to truncate the child list just before this
	     element.  */
	  break;
	}

      if (force_done)
	break;
    }

  if (i < VEC_length (varobj_p, var->children))
    {
      int j;

      *cchanged = 1;
      for (j = i; j < VEC_length (varobj_p, var->children); ++j)
	varobj_delete (VEC_index (varobj_p, var->children, j), NULL, 0);
      VEC_truncate (varobj_p, var->children, i);
    }

  /* If there are fewer children than requested, note that the list of
     children changed.  */
  if (to >= 0 && VEC_length (varobj_p, var->children) < to)
    *cchanged = 1;

  var->num_children = VEC_length (varobj_p, var->children);
 
  do_cleanups (back_to);

  return 1;
#else
  gdb_assert_not_reached ("should never be called if Python is not enabled");
#endif
}

int
varobj_get_num_children (struct varobj *var)
{
  if (var->num_children == -1)
    {
      if (var->dynamic->pretty_printer != NULL)
	{
	  int dummy;

	  /* If we have a dynamic varobj, don't report -1 children.
	     So, try to fetch some children first.  */
	  update_dynamic_varobj_children (var, NULL, NULL, NULL, NULL, &dummy,
					  0, 0, 0);
	}
      else
	var->num_children = number_of_children (var);
    }

  return var->num_children >= 0 ? var->num_children : 0;
}

/* Creates a list of the immediate children of a variable object;
   the return code is the number of such children or -1 on error.  */

VEC (varobj_p)*
varobj_list_children (struct varobj *var, int *from, int *to)
{
  char *name;
  int i, children_changed;

  var->dynamic->children_requested = 1;

  if (var->dynamic->pretty_printer != NULL)
    {
      /* This, in theory, can result in the number of children changing without
	 frontend noticing.  But well, calling -var-list-children on the same
	 varobj twice is not something a sane frontend would do.  */
      update_dynamic_varobj_children (var, NULL, NULL, NULL, NULL,
				      &children_changed, 0, 0, *to);
      varobj_restrict_range (var->children, from, to);
      return var->children;
    }

  if (var->num_children == -1)
    var->num_children = number_of_children (var);

  /* If that failed, give up.  */
  if (var->num_children == -1)
    return var->children;

  /* If we're called when the list of children is not yet initialized,
     allocate enough elements in it.  */
  while (VEC_length (varobj_p, var->children) < var->num_children)
    VEC_safe_push (varobj_p, var->children, NULL);

  for (i = 0; i < var->num_children; i++)
    {
      varobj_p existing = VEC_index (varobj_p, var->children, i);

      if (existing == NULL)
	{
	  /* Either it's the first call to varobj_list_children for
	     this variable object, and the child was never created,
	     or it was explicitly deleted by the client.  */
	  name = name_of_child (var, i);
	  existing = create_child (var, i, name);
	  VEC_replace (varobj_p, var->children, i, existing);
	}
    }

  varobj_restrict_range (var->children, from, to);
  return var->children;
}

#if HAVE_PYTHON

static struct varobj *
varobj_add_child (struct varobj *var, char *name, struct value *value)
{
  varobj_p v = create_child_with_value (var, 
					VEC_length (varobj_p, var->children), 
					name, value);

  VEC_safe_push (varobj_p, var->children, v);
  return v;
}

#endif /* HAVE_PYTHON */

/* Obtain the type of an object Variable as a string similar to the one gdb
   prints on the console.  */

char *
varobj_get_type (struct varobj *var)
{
  /* For the "fake" variables, do not return a type.  (It's type is
     NULL, too.)
     Do not return a type for invalid variables as well.  */
  if (CPLUS_FAKE_CHILD (var) || !var->root->is_valid)
    return NULL;

  return type_to_string (var->type);
}

/* Obtain the type of an object variable.  */

struct type *
varobj_get_gdb_type (struct varobj *var)
{
  return var->type;
}

/* Is VAR a path expression parent, i.e., can it be used to construct
   a valid path expression?  */

static int
is_path_expr_parent (struct varobj *var)
{
  struct type *type;

  /* "Fake" children are not path_expr parents.  */
  if (CPLUS_FAKE_CHILD (var))
    return 0;

  type = varobj_get_value_type (var);

  /* Anonymous unions and structs are also not path_expr parents.  */
  return !((TYPE_CODE (type) == TYPE_CODE_STRUCT
	    || TYPE_CODE (type) == TYPE_CODE_UNION)
	   && TYPE_NAME (type) == NULL);
}

/* Return the path expression parent for VAR.  */

struct varobj *
varobj_get_path_expr_parent (struct varobj *var)
{
  struct varobj *parent = var;

  while (!is_root_p (parent) && !is_path_expr_parent (parent))
    parent = parent->parent;

  return parent;
}

/* Return a pointer to the full rooted expression of varobj VAR.
   If it has not been computed yet, compute it.  */
char *
varobj_get_path_expr (struct varobj *var)
{
  if (var->path_expr != NULL)
    return var->path_expr;
  else 
    {
      /* For root varobjs, we initialize path_expr
	 when creating varobj, so here it should be
	 child varobj.  */
      gdb_assert (!is_root_p (var));
      return (*var->root->lang->path_expr_of_child) (var);
    }
}

enum varobj_languages
varobj_get_language (struct varobj *var)
{
  return variable_language (var);
}

int
varobj_get_attributes (struct varobj *var)
{
  int attributes = 0;

  if (varobj_editable_p (var))
    /* FIXME: define masks for attributes.  */
    attributes |= 0x00000001;	/* Editable */

  return attributes;
}

int
varobj_pretty_printed_p (struct varobj *var)
{
  return var->dynamic->pretty_printer != NULL;
}

char *
varobj_get_formatted_value (struct varobj *var,
			    enum varobj_display_formats format)
{
  return my_value_of_variable (var, format);
}

char *
varobj_get_value (struct varobj *var)
{
  return my_value_of_variable (var, var->format);
}

/* Set the value of an object variable (if it is editable) to the
   value of the given expression.  */
/* Note: Invokes functions that can call error().  */

int
varobj_set_value (struct varobj *var, char *expression)
{
  struct value *val = NULL; /* Initialize to keep gcc happy.  */
  /* The argument "expression" contains the variable's new value.
     We need to first construct a legal expression for this -- ugh!  */
  /* Does this cover all the bases?  */
  struct expression *exp;
  struct value *value = NULL; /* Initialize to keep gcc happy.  */
  int saved_input_radix = input_radix;
  const char *s = expression;
  volatile struct gdb_exception except;

  gdb_assert (varobj_editable_p (var));

  input_radix = 10;		/* ALWAYS reset to decimal temporarily.  */
  exp = parse_exp_1 (&s, 0, 0, 0);
  TRY_CATCH (except, RETURN_MASK_ERROR)
    {
      value = evaluate_expression (exp);
    }

  if (except.reason < 0)
    {
      /* We cannot proceed without a valid expression.  */
      xfree (exp);
      return 0;
    }

  /* All types that are editable must also be changeable.  */
  gdb_assert (varobj_value_is_changeable_p (var));

  /* The value of a changeable variable object must not be lazy.  */
  gdb_assert (!value_lazy (var->value));

  /* Need to coerce the input.  We want to check if the
     value of the variable object will be different
     after assignment, and the first thing value_assign
     does is coerce the input.
     For example, if we are assigning an array to a pointer variable we
     should compare the pointer with the array's address, not with the
     array's content.  */
  value = coerce_array (value);

  /* The new value may be lazy.  value_assign, or
     rather value_contents, will take care of this.  */
  TRY_CATCH (except, RETURN_MASK_ERROR)
    {
      val = value_assign (var->value, value);
    }

  if (except.reason < 0)
    return 0;

  /* If the value has changed, record it, so that next -var-update can
     report this change.  If a variable had a value of '1', we've set it
     to '333' and then set again to '1', when -var-update will report this
     variable as changed -- because the first assignment has set the
     'updated' flag.  There's no need to optimize that, because return value
     of -var-update should be considered an approximation.  */
  var->updated = install_new_value (var, val, 0 /* Compare values.  */);
  input_radix = saved_input_radix;
  return 1;
}

#if HAVE_PYTHON

/* A helper function to install a constructor function and visualizer
   in a varobj_dynamic.  */

static void
install_visualizer (struct varobj_dynamic *var, PyObject *constructor,
		    PyObject *visualizer)
{
  Py_XDECREF (var->constructor);
  var->constructor = constructor;

  Py_XDECREF (var->pretty_printer);
  var->pretty_printer = visualizer;

  Py_XDECREF (var->child_iter);
  var->child_iter = NULL;
}

/* Install the default visualizer for VAR.  */

static void
install_default_visualizer (struct varobj *var)
{
  /* Do not install a visualizer on a CPLUS_FAKE_CHILD.  */
  if (CPLUS_FAKE_CHILD (var))
    return;

  if (pretty_printing)
    {
      PyObject *pretty_printer = NULL;

      if (var->value)
	{
	  pretty_printer = gdbpy_get_varobj_pretty_printer (var->value);
	  if (! pretty_printer)
	    {
	      gdbpy_print_stack ();
	      error (_("Cannot instantiate printer for default visualizer"));
	    }
	}
      
      if (pretty_printer == Py_None)
	{
	  Py_DECREF (pretty_printer);
	  pretty_printer = NULL;
	}
  
      install_visualizer (var->dynamic, NULL, pretty_printer);
    }
}

/* Instantiate and install a visualizer for VAR using CONSTRUCTOR to
   make a new object.  */

static void
construct_visualizer (struct varobj *var, PyObject *constructor)
{
  PyObject *pretty_printer;

  /* Do not install a visualizer on a CPLUS_FAKE_CHILD.  */
  if (CPLUS_FAKE_CHILD (var))
    return;

  Py_INCREF (constructor);
  if (constructor == Py_None)
    pretty_printer = NULL;
  else
    {
      pretty_printer = instantiate_pretty_printer (constructor, var->value);
      if (! pretty_printer)
	{
	  gdbpy_print_stack ();
	  Py_DECREF (constructor);
	  constructor = Py_None;
	  Py_INCREF (constructor);
	}

      if (pretty_printer == Py_None)
	{
	  Py_DECREF (pretty_printer);
	  pretty_printer = NULL;
	}
    }

  install_visualizer (var->dynamic, constructor, pretty_printer);
}

#endif /* HAVE_PYTHON */

/* A helper function for install_new_value.  This creates and installs
   a visualizer for VAR, if appropriate.  */

static void
install_new_value_visualizer (struct varobj *var)
{
#if HAVE_PYTHON
  /* If the constructor is None, then we want the raw value.  If VAR
     does not have a value, just skip this.  */
  if (!gdb_python_initialized)
    return;

  if (var->dynamic->constructor != Py_None && var->value != NULL)
    {
      struct cleanup *cleanup;

      cleanup = varobj_ensure_python_env (var);

      if (var->dynamic->constructor == NULL)
	install_default_visualizer (var);
      else
	construct_visualizer (var, var->dynamic->constructor);

      do_cleanups (cleanup);
    }
#else
  /* Do nothing.  */
#endif
}

/* When using RTTI to determine variable type it may be changed in runtime when
   the variable value is changed.  This function checks whether type of varobj
   VAR will change when a new value NEW_VALUE is assigned and if it is so
   updates the type of VAR.  */

static int
update_type_if_necessary (struct varobj *var, struct value *new_value)
{
  if (new_value)
    {
      struct value_print_options opts;

      get_user_print_options (&opts);
      if (opts.objectprint)
	{
	  struct type *new_type;
	  char *curr_type_str, *new_type_str;

	  new_type = value_actual_type (new_value, 0, 0);
	  new_type_str = type_to_string (new_type);
	  curr_type_str = varobj_get_type (var);
	  if (strcmp (curr_type_str, new_type_str) != 0)
	    {
	      var->type = new_type;

	      /* This information may be not valid for a new type.  */
	      varobj_delete (var, NULL, 1);
	      VEC_free (varobj_p, var->children);
	      var->num_children = -1;
	      return 1;
	    }
	}
    }

  return 0;
}

/* Assign a new value to a variable object.  If INITIAL is non-zero,
   this is the first assignement after the variable object was just
   created, or changed type.  In that case, just assign the value 
   and return 0.
   Otherwise, assign the new value, and return 1 if the value is
   different from the current one, 0 otherwise.  The comparison is
   done on textual representation of value.  Therefore, some types
   need not be compared.  E.g.  for structures the reported value is
   always "{...}", so no comparison is necessary here.  If the old
   value was NULL and new one is not, or vice versa, we always return 1.

   The VALUE parameter should not be released -- the function will
   take care of releasing it when needed.  */
static int
install_new_value (struct varobj *var, struct value *value, int initial)
{ 
  int changeable;
  int need_to_fetch;
  int changed = 0;
  int intentionally_not_fetched = 0;
  char *print_value = NULL;

  /* We need to know the varobj's type to decide if the value should
     be fetched or not.  C++ fake children (public/protected/private)
     don't have a type.  */
  gdb_assert (var->type || CPLUS_FAKE_CHILD (var));
  changeable = varobj_value_is_changeable_p (var);

  /* If the type has custom visualizer, we consider it to be always
     changeable.  FIXME: need to make sure this behaviour will not
     mess up read-sensitive values.  */
  if (var->dynamic->pretty_printer != NULL)
    changeable = 1;

  need_to_fetch = changeable;

  /* We are not interested in the address of references, and given
     that in C++ a reference is not rebindable, it cannot
     meaningfully change.  So, get hold of the real value.  */
  if (value)
    value = coerce_ref (value);

  if (var->type && TYPE_CODE (var->type) == TYPE_CODE_UNION)
    /* For unions, we need to fetch the value implicitly because
       of implementation of union member fetch.  When gdb
       creates a value for a field and the value of the enclosing
       structure is not lazy,  it immediately copies the necessary
       bytes from the enclosing values.  If the enclosing value is
       lazy, the call to value_fetch_lazy on the field will read
       the data from memory.  For unions, that means we'll read the
       same memory more than once, which is not desirable.  So
       fetch now.  */
    need_to_fetch = 1;

  /* The new value might be lazy.  If the type is changeable,
     that is we'll be comparing values of this type, fetch the
     value now.  Otherwise, on the next update the old value
     will be lazy, which means we've lost that old value.  */
  if (need_to_fetch && value && value_lazy (value))
    {
      struct varobj *parent = var->parent;
      int frozen = var->frozen;

      for (; !frozen && parent; parent = parent->parent)
	frozen |= parent->frozen;

      if (frozen && initial)
	{
	  /* For variables that are frozen, or are children of frozen
	     variables, we don't do fetch on initial assignment.
	     For non-initial assignemnt we do the fetch, since it means we're
	     explicitly asked to compare the new value with the old one.  */
	  intentionally_not_fetched = 1;
	}
      else
	{
	  volatile struct gdb_exception except;

	  TRY_CATCH (except, RETURN_MASK_ERROR)
	    {
	      value_fetch_lazy (value);
	    }

	  if (except.reason < 0)
	    {
	      /* Set the value to NULL, so that for the next -var-update,
		 we don't try to compare the new value with this value,
		 that we couldn't even read.  */
	      value = NULL;
	    }
	}
    }

  /* Get a reference now, before possibly passing it to any Python
     code that might release it.  */
  if (value != NULL)
    value_incref (value);

  /* Below, we'll be comparing string rendering of old and new
     values.  Don't get string rendering if the value is
     lazy -- if it is, the code above has decided that the value
     should not be fetched.  */
  if (value != NULL && !value_lazy (value)
      && var->dynamic->pretty_printer == NULL)
    print_value = varobj_value_get_print_value (value, var->format, var);

  /* If the type is changeable, compare the old and the new values.
     If this is the initial assignment, we don't have any old value
     to compare with.  */
  if (!initial && changeable)
    {
      /* If the value of the varobj was changed by -var-set-value,
	 then the value in the varobj and in the target is the same.
	 However, that value is different from the value that the
	 varobj had after the previous -var-update.  So need to the
	 varobj as changed.  */
      if (var->updated)
	{
	  changed = 1;
	}
      else if (var->dynamic->pretty_printer == NULL)
	{
	  /* Try to compare the values.  That requires that both
	     values are non-lazy.  */
	  if (var->not_fetched && value_lazy (var->value))
	    {
	      /* This is a frozen varobj and the value was never read.
		 Presumably, UI shows some "never read" indicator.
		 Now that we've fetched the real value, we need to report
		 this varobj as changed so that UI can show the real
		 value.  */
	      changed = 1;
	    }
          else  if (var->value == NULL && value == NULL)
	    /* Equal.  */
	    ;
	  else if (var->value == NULL || value == NULL)
	    {
	      changed = 1;
	    }
	  else
	    {
	      gdb_assert (!value_lazy (var->value));
	      gdb_assert (!value_lazy (value));

	      gdb_assert (var->print_value != NULL && print_value != NULL);
	      if (strcmp (var->print_value, print_value) != 0)
		changed = 1;
	    }
	}
    }

  if (!initial && !changeable)
    {
      /* For values that are not changeable, we don't compare the values.
	 However, we want to notice if a value was not NULL and now is NULL,
	 or vise versa, so that we report when top-level varobjs come in scope
	 and leave the scope.  */
      changed = (var->value != NULL) != (value != NULL);
    }

  /* We must always keep the new value, since children depend on it.  */
  if (var->value != NULL && var->value != value)
    value_free (var->value);
  var->value = value;
  if (value && value_lazy (value) && intentionally_not_fetched)
    var->not_fetched = 1;
  else
    var->not_fetched = 0;
  var->updated = 0;

  install_new_value_visualizer (var);

  /* If we installed a pretty-printer, re-compare the printed version
     to see if the variable changed.  */
  if (var->dynamic->pretty_printer != NULL)
    {
      xfree (print_value);
      print_value = varobj_value_get_print_value (var->value, var->format,
						  var);
      if ((var->print_value == NULL && print_value != NULL)
	  || (var->print_value != NULL && print_value == NULL)
	  || (var->print_value != NULL && print_value != NULL
	      && strcmp (var->print_value, print_value) != 0))
	changed = 1;
    }
  if (var->print_value)
    xfree (var->print_value);
  var->print_value = print_value;

  gdb_assert (!var->value || value_type (var->value));

  return changed;
}

/* Return the requested range for a varobj.  VAR is the varobj.  FROM
   and TO are out parameters; *FROM and *TO will be set to the
   selected sub-range of VAR.  If no range was selected using
   -var-set-update-range, then both will be -1.  */
void
varobj_get_child_range (struct varobj *var, int *from, int *to)
{
  *from = var->from;
  *to = var->to;
}

/* Set the selected sub-range of children of VAR to start at index
   FROM and end at index TO.  If either FROM or TO is less than zero,
   this is interpreted as a request for all children.  */
void
varobj_set_child_range (struct varobj *var, int from, int to)
{
  var->from = from;
  var->to = to;
}

void 
varobj_set_visualizer (struct varobj *var, const char *visualizer)
{
#if HAVE_PYTHON
  PyObject *mainmod, *globals, *constructor;
  struct cleanup *back_to;

  if (!gdb_python_initialized)
    return;

  back_to = varobj_ensure_python_env (var);

  mainmod = PyImport_AddModule ("__main__");
  globals = PyModule_GetDict (mainmod);
  Py_INCREF (globals);
  make_cleanup_py_decref (globals);

  constructor = PyRun_String (visualizer, Py_eval_input, globals, globals);

  if (! constructor)
    {
      gdbpy_print_stack ();
      error (_("Could not evaluate visualizer expression: %s"), visualizer);
    }

  construct_visualizer (var, constructor);
  Py_XDECREF (constructor);

  /* If there are any children now, wipe them.  */
  varobj_delete (var, NULL, 1 /* children only */);
  var->num_children = -1;

  do_cleanups (back_to);
#else
  error (_("Python support required"));
#endif
}

/* If NEW_VALUE is the new value of the given varobj (var), return
   non-zero if var has mutated.  In other words, if the type of
   the new value is different from the type of the varobj's old
   value.

   NEW_VALUE may be NULL, if the varobj is now out of scope.  */

static int
varobj_value_has_mutated (struct varobj *var, struct value *new_value,
			  struct type *new_type)
{
  /* If we haven't previously computed the number of children in var,
     it does not matter from the front-end's perspective whether
     the type has mutated or not.  For all intents and purposes,
     it has not mutated.  */
  if (var->num_children < 0)
    return 0;

  if (var->root->lang->value_has_mutated)
    return var->root->lang->value_has_mutated (var, new_value, new_type);
  else
    return 0;
}

/* Update the values for a variable and its children.  This is a
   two-pronged attack.  First, re-parse the value for the root's
   expression to see if it's changed.  Then go all the way
   through its children, reconstructing them and noting if they've
   changed.

   The EXPLICIT parameter specifies if this call is result
   of MI request to update this specific variable, or 
   result of implicit -var-update *.  For implicit request, we don't
   update frozen variables.

   NOTE: This function may delete the caller's varobj.  If it
   returns TYPE_CHANGED, then it has done this and VARP will be modified
   to point to the new varobj.  */

VEC(varobj_update_result) *
varobj_update (struct varobj **varp, int explicit)
{
  int type_changed = 0;
  int i;
  struct value *new;
  VEC (varobj_update_result) *stack = NULL;
  VEC (varobj_update_result) *result = NULL;

  /* Frozen means frozen -- we don't check for any change in
     this varobj, including its going out of scope, or
     changing type.  One use case for frozen varobjs is
     retaining previously evaluated expressions, and we don't
     want them to be reevaluated at all.  */
  if (!explicit && (*varp)->frozen)
    return result;

  if (!(*varp)->root->is_valid)
    {
      varobj_update_result r = {0};

      r.varobj = *varp;
      r.status = VAROBJ_INVALID;
      VEC_safe_push (varobj_update_result, result, &r);
      return result;
    }

  if ((*varp)->root->rootvar == *varp)
    {
      varobj_update_result r = {0};

      r.varobj = *varp;
      r.status = VAROBJ_IN_SCOPE;

      /* Update the root variable.  value_of_root can return NULL
	 if the variable is no longer around, i.e. we stepped out of
	 the frame in which a local existed.  We are letting the 
	 value_of_root variable dispose of the varobj if the type
	 has changed.  */
      new = value_of_root (varp, &type_changed);
      if (update_type_if_necessary(*varp, new))
	  type_changed = 1;
      r.varobj = *varp;
      r.type_changed = type_changed;
      if (install_new_value ((*varp), new, type_changed))
	r.changed = 1;
      
      if (new == NULL)
	r.status = VAROBJ_NOT_IN_SCOPE;
      r.value_installed = 1;

      if (r.status == VAROBJ_NOT_IN_SCOPE)
	{
	  if (r.type_changed || r.changed)
	    VEC_safe_push (varobj_update_result, result, &r);
	  return result;
	}
            
      VEC_safe_push (varobj_update_result, stack, &r);
    }
  else
    {
      varobj_update_result r = {0};

      r.varobj = *varp;
      VEC_safe_push (varobj_update_result, stack, &r);
    }

  /* Walk through the children, reconstructing them all.  */
  while (!VEC_empty (varobj_update_result, stack))
    {
      varobj_update_result r = *(VEC_last (varobj_update_result, stack));
      struct varobj *v = r.varobj;

      VEC_pop (varobj_update_result, stack);

      /* Update this variable, unless it's a root, which is already
	 updated.  */
      if (!r.value_installed)
	{
	  struct type *new_type;

	  new = value_of_child (v->parent, v->index);
	  if (update_type_if_necessary(v, new))
	    r.type_changed = 1;
	  if (new)
	    new_type = value_type (new);
	  else
	    new_type = v->root->lang->type_of_child (v->parent, v->index);

	  if (varobj_value_has_mutated (v, new, new_type))
	    {
	      /* The children are no longer valid; delete them now.
	         Report the fact that its type changed as well.  */
	      varobj_delete (v, NULL, 1 /* only_children */);
	      v->num_children = -1;
	      v->to = -1;
	      v->from = -1;
	      v->type = new_type;
	      r.type_changed = 1;
	    }

	  if (install_new_value (v, new, r.type_changed))
	    {
	      r.changed = 1;
	      v->updated = 0;
	    }
	}

      /* We probably should not get children of a varobj that has a
	 pretty-printer, but for which -var-list-children was never
	 invoked.  */
      if (v->dynamic->pretty_printer != NULL)
	{
	  VEC (varobj_p) *changed = 0, *type_changed = 0, *unchanged = 0;
	  VEC (varobj_p) *new = 0;
	  int i, children_changed = 0;

	  if (v->frozen)
	    continue;

	  if (!v->dynamic->children_requested)
	    {
	      int dummy;

	      /* If we initially did not have potential children, but
		 now we do, consider the varobj as changed.
		 Otherwise, if children were never requested, consider
		 it as unchanged -- presumably, such varobj is not yet
		 expanded in the UI, so we need not bother getting
		 it.  */
	      if (!varobj_has_more (v, 0))
		{
		  update_dynamic_varobj_children (v, NULL, NULL, NULL, NULL,
						  &dummy, 0, 0, 0);
		  if (varobj_has_more (v, 0))
		    r.changed = 1;
		}

	      if (r.changed)
		VEC_safe_push (varobj_update_result, result, &r);

	      continue;
	    }

	  /* If update_dynamic_varobj_children returns 0, then we have
	     a non-conforming pretty-printer, so we skip it.  */
	  if (update_dynamic_varobj_children (v, &changed, &type_changed, &new,
					      &unchanged, &children_changed, 1,
					      v->from, v->to))
	    {
	      if (children_changed || new)
		{
		  r.children_changed = 1;
		  r.new = new;
		}
	      /* Push in reverse order so that the first child is
		 popped from the work stack first, and so will be
		 added to result first.  This does not affect
		 correctness, just "nicer".  */
	      for (i = VEC_length (varobj_p, type_changed) - 1; i >= 0; --i)
		{
		  varobj_p tmp = VEC_index (varobj_p, type_changed, i);
		  varobj_update_result r = {0};

		  /* Type may change only if value was changed.  */
		  r.varobj = tmp;
		  r.changed = 1;
		  r.type_changed = 1;
		  r.value_installed = 1;
		  VEC_safe_push (varobj_update_result, stack, &r);
		}
	      for (i = VEC_length (varobj_p, changed) - 1; i >= 0; --i)
		{
		  varobj_p tmp = VEC_index (varobj_p, changed, i);
		  varobj_update_result r = {0};

		  r.varobj = tmp;
		  r.changed = 1;
		  r.value_installed = 1;
		  VEC_safe_push (varobj_update_result, stack, &r);
		}
	      for (i = VEC_length (varobj_p, unchanged) - 1; i >= 0; --i)
	      	{
		  varobj_p tmp = VEC_index (varobj_p, unchanged, i);

	      	  if (!tmp->frozen)
	      	    {
	      	      varobj_update_result r = {0};

		      r.varobj = tmp;
	      	      r.value_installed = 1;
	      	      VEC_safe_push (varobj_update_result, stack, &r);
	      	    }
	      	}
	      if (r.changed || r.children_changed)
		VEC_safe_push (varobj_update_result, result, &r);

	      /* Free CHANGED, TYPE_CHANGED and UNCHANGED, but not NEW,
		 because NEW has been put into the result vector.  */
	      VEC_free (varobj_p, changed);
	      VEC_free (varobj_p, type_changed);
	      VEC_free (varobj_p, unchanged);

	      continue;
	    }
	}

      /* Push any children.  Use reverse order so that the first
	 child is popped from the work stack first, and so
	 will be added to result first.  This does not
	 affect correctness, just "nicer".  */
      for (i = VEC_length (varobj_p, v->children)-1; i >= 0; --i)
	{
	  varobj_p c = VEC_index (varobj_p, v->children, i);

	  /* Child may be NULL if explicitly deleted by -var-delete.  */
	  if (c != NULL && !c->frozen)
	    {
	      varobj_update_result r = {0};

	      r.varobj = c;
	      VEC_safe_push (varobj_update_result, stack, &r);
	    }
	}

      if (r.changed || r.type_changed)
	VEC_safe_push (varobj_update_result, result, &r);
    }

  VEC_free (varobj_update_result, stack);

  return result;
}


/* Helper functions */

/*
 * Variable object construction/destruction
 */

static int
delete_variable (struct cpstack **resultp, struct varobj *var,
		 int only_children_p)
{
  int delcount = 0;

  delete_variable_1 (resultp, &delcount, var,
		     only_children_p, 1 /* remove_from_parent_p */ );

  return delcount;
}

/* Delete the variable object VAR and its children.  */
/* IMPORTANT NOTE: If we delete a variable which is a child
   and the parent is not removed we dump core.  It must be always
   initially called with remove_from_parent_p set.  */
static void
delete_variable_1 (struct cpstack **resultp, int *delcountp,
		   struct varobj *var, int only_children_p,
		   int remove_from_parent_p)
{
  int i;

  /* Delete any children of this variable, too.  */
  for (i = 0; i < VEC_length (varobj_p, var->children); ++i)
    {   
      varobj_p child = VEC_index (varobj_p, var->children, i);

      if (!child)
	continue;
      if (!remove_from_parent_p)
	child->parent = NULL;
      delete_variable_1 (resultp, delcountp, child, 0, only_children_p);
    }
  VEC_free (varobj_p, var->children);

  /* if we were called to delete only the children we are done here.  */
  if (only_children_p)
    return;

  /* Otherwise, add it to the list of deleted ones and proceed to do so.  */
  /* If the name is null, this is a temporary variable, that has not
     yet been installed, don't report it, it belongs to the caller...  */
  if (var->obj_name != NULL)
    {
      cppush (resultp, xstrdup (var->obj_name));
      *delcountp = *delcountp + 1;
    }

  /* If this variable has a parent, remove it from its parent's list.  */
  /* OPTIMIZATION: if the parent of this variable is also being deleted, 
     (as indicated by remove_from_parent_p) we don't bother doing an
     expensive list search to find the element to remove when we are
     discarding the list afterwards.  */
  if ((remove_from_parent_p) && (var->parent != NULL))
    {
      VEC_replace (varobj_p, var->parent->children, var->index, NULL);
    }

  if (var->obj_name != NULL)
    uninstall_variable (var);

  /* Free memory associated with this variable.  */
  free_variable (var);
}

/* Install the given variable VAR with the object name VAR->OBJ_NAME.  */
static int
install_variable (struct varobj *var)
{
  struct vlist *cv;
  struct vlist *newvl;
  const char *chp;
  unsigned int index = 0;
  unsigned int i = 1;

  for (chp = var->obj_name; *chp; chp++)
    {
      index = (index + (i++ * (unsigned int) *chp)) % VAROBJ_TABLE_SIZE;
    }

  cv = *(varobj_table + index);
  while ((cv != NULL) && (strcmp (cv->var->obj_name, var->obj_name) != 0))
    cv = cv->next;

  if (cv != NULL)
    error (_("Duplicate variable object name"));

  /* Add varobj to hash table.  */
  newvl = xmalloc (sizeof (struct vlist));
  newvl->next = *(varobj_table + index);
  newvl->var = var;
  *(varobj_table + index) = newvl;

  /* If root, add varobj to root list.  */
  if (is_root_p (var))
    {
      /* Add to list of root variables.  */
      if (rootlist == NULL)
	var->root->next = NULL;
      else
	var->root->next = rootlist;
      rootlist = var->root;
    }

  return 1;			/* OK */
}

/* Unistall the object VAR.  */
static void
uninstall_variable (struct varobj *var)
{
  struct vlist *cv;
  struct vlist *prev;
  struct varobj_root *cr;
  struct varobj_root *prer;
  const char *chp;
  unsigned int index = 0;
  unsigned int i = 1;

  /* Remove varobj from hash table.  */
  for (chp = var->obj_name; *chp; chp++)
    {
      index = (index + (i++ * (unsigned int) *chp)) % VAROBJ_TABLE_SIZE;
    }

  cv = *(varobj_table + index);
  prev = NULL;
  while ((cv != NULL) && (strcmp (cv->var->obj_name, var->obj_name) != 0))
    {
      prev = cv;
      cv = cv->next;
    }

  if (varobjdebug)
    fprintf_unfiltered (gdb_stdlog, "Deleting %s\n", var->obj_name);

  if (cv == NULL)
    {
      warning
	("Assertion failed: Could not find variable object \"%s\" to delete",
	 var->obj_name);
      return;
    }

  if (prev == NULL)
    *(varobj_table + index) = cv->next;
  else
    prev->next = cv->next;

  xfree (cv);

  /* If root, remove varobj from root list.  */
  if (is_root_p (var))
    {
      /* Remove from list of root variables.  */
      if (rootlist == var->root)
	rootlist = var->root->next;
      else
	{
	  prer = NULL;
	  cr = rootlist;
	  while ((cr != NULL) && (cr->rootvar != var))
	    {
	      prer = cr;
	      cr = cr->next;
	    }
	  if (cr == NULL)
	    {
	      warning (_("Assertion failed: Could not find "
		         "varobj \"%s\" in root list"),
		       var->obj_name);
	      return;
	    }
	  if (prer == NULL)
	    rootlist = NULL;
	  else
	    prer->next = cr->next;
	}
    }

}

/* Create and install a child of the parent of the given name.  */
static struct varobj *
create_child (struct varobj *parent, int index, char *name)
{
  return create_child_with_value (parent, index, name, 
				  value_of_child (parent, index));
}

static struct varobj *
create_child_with_value (struct varobj *parent, int index, char *name,
			 struct value *value)
{
  struct varobj *child;
  char *childs_name;

  child = new_variable ();

  /* NAME is allocated by caller.  */
  child->name = name;
  child->index = index;
  child->parent = parent;
  child->root = parent->root;

  if (varobj_is_anonymous_child (child))
    childs_name = xstrprintf ("%s.%d_anonymous", parent->obj_name, index);
  else
    childs_name = xstrprintf ("%s.%s", parent->obj_name, name);
  child->obj_name = childs_name;

  install_variable (child);

  /* Compute the type of the child.  Must do this before
     calling install_new_value.  */
  if (value != NULL)
    /* If the child had no evaluation errors, var->value
       will be non-NULL and contain a valid type.  */
    child->type = value_actual_type (value, 0, NULL);
  else
    /* Otherwise, we must compute the type.  */
    child->type = (*child->root->lang->type_of_child) (child->parent, 
						       child->index);
  install_new_value (child, value, 1);

  return child;
}


/*
 * Miscellaneous utility functions.
 */

/* Allocate memory and initialize a new variable.  */
static struct varobj *
new_variable (void)
{
  struct varobj *var;

  var = (struct varobj *) xmalloc (sizeof (struct varobj));
  var->name = NULL;
  var->path_expr = NULL;
  var->obj_name = NULL;
  var->index = -1;
  var->type = NULL;
  var->value = NULL;
  var->num_children = -1;
  var->parent = NULL;
  var->children = NULL;
  var->format = 0;
  var->root = NULL;
  var->updated = 0;
  var->print_value = NULL;
  var->frozen = 0;
  var->not_fetched = 0;
  var->dynamic
    = (struct varobj_dynamic *) xmalloc (sizeof (struct varobj_dynamic));
  var->dynamic->children_requested = 0;
  var->from = -1;
  var->to = -1;
  var->dynamic->constructor = 0;
  var->dynamic->pretty_printer = 0;
  var->dynamic->child_iter = 0;
  var->dynamic->saved_item = 0;

  return var;
}

/* Allocate memory and initialize a new root variable.  */
static struct varobj *
new_root_variable (void)
{
  struct varobj *var = new_variable ();

  var->root = (struct varobj_root *) xmalloc (sizeof (struct varobj_root));
  var->root->lang = NULL;
  var->root->exp = NULL;
  var->root->valid_block = NULL;
  var->root->frame = null_frame_id;
  var->root->floating = 0;
  var->root->rootvar = NULL;
  var->root->is_valid = 1;

  return var;
}

/* Free any allocated memory associated with VAR.  */
static void
free_variable (struct varobj *var)
{
#if HAVE_PYTHON
  if (var->dynamic->pretty_printer != NULL)
    {
      struct cleanup *cleanup = varobj_ensure_python_env (var);

      Py_XDECREF (var->dynamic->constructor);
      Py_XDECREF (var->dynamic->pretty_printer);
      Py_XDECREF (var->dynamic->child_iter);
      Py_XDECREF (var->dynamic->saved_item);
      do_cleanups (cleanup);
    }
#endif

  value_free (var->value);

  /* Free the expression if this is a root variable.  */
  if (is_root_p (var))
    {
      xfree (var->root->exp);
      xfree (var->root);
    }

  xfree (var->name);
  xfree (var->obj_name);
  xfree (var->print_value);
  xfree (var->path_expr);
  xfree (var->dynamic);
  xfree (var);
}

static void
do_free_variable_cleanup (void *var)
{
  free_variable (var);
}

static struct cleanup *
make_cleanup_free_variable (struct varobj *var)
{
  return make_cleanup (do_free_variable_cleanup, var);
}

/* Return the type of the value that's stored in VAR,
   or that would have being stored there if the
   value were accessible.

   This differs from VAR->type in that VAR->type is always
   the true type of the expession in the source language.
   The return value of this function is the type we're
   actually storing in varobj, and using for displaying
   the values and for comparing previous and new values.

   For example, top-level references are always stripped.  */
struct type *
varobj_get_value_type (struct varobj *var)
{
  struct type *type;

  if (var->value)
    type = value_type (var->value);
  else
    type = var->type;

  type = check_typedef (type);

  if (TYPE_CODE (type) == TYPE_CODE_REF)
    type = get_target_type (type);

  type = check_typedef (type);

  return type;
}

/* What is the default display for this variable? We assume that
   everything is "natural".  Any exceptions?  */
static enum varobj_display_formats
variable_default_display (struct varobj *var)
{
  return FORMAT_NATURAL;
}

/* FIXME: The following should be generic for any pointer.  */
static void
cppush (struct cpstack **pstack, char *name)
{
  struct cpstack *s;

  s = (struct cpstack *) xmalloc (sizeof (struct cpstack));
  s->name = name;
  s->next = *pstack;
  *pstack = s;
}

/* FIXME: The following should be generic for any pointer.  */
static char *
cppop (struct cpstack **pstack)
{
  struct cpstack *s;
  char *v;

  if ((*pstack)->name == NULL && (*pstack)->next == NULL)
    return NULL;

  s = *pstack;
  v = s->name;
  *pstack = (*pstack)->next;
  xfree (s);

  return v;
}

/*
 * Language-dependencies
 */

/* Common entry points */

/* Get the language of variable VAR.  */
static enum varobj_languages
variable_language (struct varobj *var)
{
  enum varobj_languages lang;

  switch (var->root->exp->language_defn->la_language)
    {
    default:
    case language_c:
      lang = vlang_c;
      break;
    case language_cplus:
      lang = vlang_cplus;
      break;
    case language_java:
      lang = vlang_java;
      break;
    case language_ada:
      lang = vlang_ada;
      break;
    }

  return lang;
}

/* Return the number of children for a given variable.
   The result of this function is defined by the language
   implementation.  The number of children returned by this function
   is the number of children that the user will see in the variable
   display.  */
static int
number_of_children (struct varobj *var)
{
  return (*var->root->lang->number_of_children) (var);
}

/* What is the expression for the root varobj VAR? Returns a malloc'd
   string.  */
static char *
name_of_variable (struct varobj *var)
{
  return (*var->root->lang->name_of_variable) (var);
}

/* What is the name of the INDEX'th child of VAR? Returns a malloc'd
   string.  */
static char *
name_of_child (struct varobj *var, int index)
{
  return (*var->root->lang->name_of_child) (var, index);
}

/* If frame associated with VAR can be found, switch
   to it and return 1.  Otherwise, return 0.  */

static int
check_scope (struct varobj *var)
{
  struct frame_info *fi;
  int scope;

  fi = frame_find_by_id (var->root->frame);
  scope = fi != NULL;

  if (fi)
    {
      CORE_ADDR pc = get_frame_pc (fi);

      if (pc <  BLOCK_START (var->root->valid_block) ||
	  pc >= BLOCK_END (var->root->valid_block))
	scope = 0;
      else
	select_frame (fi);
    }
  return scope;
}

/* Helper function to value_of_root.  */

static struct value *
value_of_root_1 (struct varobj **var_handle)
{
  struct value *new_val = NULL;
  struct varobj *var = *var_handle;
  int within_scope = 0;
  struct cleanup *back_to;
								 
  /*  Only root variables can be updated...  */
  if (!is_root_p (var))
    /* Not a root var.  */
    return NULL;

  back_to = make_cleanup_restore_current_thread ();

  /* Determine whether the variable is still around.  */
  if (var->root->valid_block == NULL || var->root->floating)
    within_scope = 1;
  else if (var->root->thread_id == 0)
    {
      /* The program was single-threaded when the variable object was
	 created.  Technically, it's possible that the program became
	 multi-threaded since then, but we don't support such
	 scenario yet.  */
      within_scope = check_scope (var);	  
    }
  else
    {
      ptid_t ptid = thread_id_to_pid (var->root->thread_id);
      if (in_thread_list (ptid))
	{
	  switch_to_thread (ptid);
	  within_scope = check_scope (var);
	}
    }

  if (within_scope)
    {
      volatile struct gdb_exception except;

      /* We need to catch errors here, because if evaluate
         expression fails we want to just return NULL.  */
      TRY_CATCH (except, RETURN_MASK_ERROR)
	{
	  new_val = evaluate_expression (var->root->exp);
	}
    }

  do_cleanups (back_to);

  return new_val;
}

/* What is the ``struct value *'' of the root variable VAR?
   For floating variable object, evaluation can get us a value
   of different type from what is stored in varobj already.  In
   that case:
   - *type_changed will be set to 1
   - old varobj will be freed, and new one will be
   created, with the same name.
   - *var_handle will be set to the new varobj 
   Otherwise, *type_changed will be set to 0.  */
static struct value *
value_of_root (struct varobj **var_handle, int *type_changed)
{
  struct varobj *var;

  if (var_handle == NULL)
    return NULL;

  var = *var_handle;

  /* This should really be an exception, since this should
     only get called with a root variable.  */

  if (!is_root_p (var))
    return NULL;

  if (var->root->floating)
    {
      struct varobj *tmp_var;
      char *old_type, *new_type;

      tmp_var = varobj_create (NULL, var->name, (CORE_ADDR) 0,
			       USE_SELECTED_FRAME);
      if (tmp_var == NULL)
	{
	  return NULL;
	}
      old_type = varobj_get_type (var);
      new_type = varobj_get_type (tmp_var);
      if (strcmp (old_type, new_type) == 0)
	{
	  /* The expression presently stored inside var->root->exp
	     remembers the locations of local variables relatively to
	     the frame where the expression was created (in DWARF location
	     button, for example).  Naturally, those locations are not
	     correct in other frames, so update the expression.  */

         struct expression *tmp_exp = var->root->exp;

         var->root->exp = tmp_var->root->exp;
         tmp_var->root->exp = tmp_exp;

	  varobj_delete (tmp_var, NULL, 0);
	  *type_changed = 0;
	}
      else
	{
	  tmp_var->obj_name = xstrdup (var->obj_name);
	  tmp_var->from = var->from;
	  tmp_var->to = var->to;
	  varobj_delete (var, NULL, 0);

	  install_variable (tmp_var);
	  *var_handle = tmp_var;
	  var = *var_handle;
	  *type_changed = 1;
	}
      xfree (old_type);
      xfree (new_type);
    }
  else
    {
      *type_changed = 0;
    }

  {
    struct value *value;

    value = value_of_root_1 (var_handle);
    if (var->value == NULL || value == NULL)
      {
	/* For root varobj-s, a NULL value indicates a scoping issue.
	   So, nothing to do in terms of checking for mutations.  */
      }
    else if (varobj_value_has_mutated (var, value, value_type (value)))
      {
	/* The type has mutated, so the children are no longer valid.
	   Just delete them, and tell our caller that the type has
	   changed.  */
	varobj_delete (var, NULL, 1 /* only_children */);
	var->num_children = -1;
	var->to = -1;
	var->from = -1;
	*type_changed = 1;
      }
    return value;
  }
}

/* What is the ``struct value *'' for the INDEX'th child of PARENT?  */
static struct value *
value_of_child (struct varobj *parent, int index)
{
  struct value *value;

  value = (*parent->root->lang->value_of_child) (parent, index);

  return value;
}

/* GDB already has a command called "value_of_variable".  Sigh.  */
static char *
my_value_of_variable (struct varobj *var, enum varobj_display_formats format)
{
  if (var->root->is_valid)
    {
      if (var->dynamic->pretty_printer != NULL)
	return varobj_value_get_print_value (var->value, var->format, var);
      return (*var->root->lang->value_of_variable) (var, format);
    }
  else
    return NULL;
}

void
varobj_formatted_print_options (struct value_print_options *opts,
				enum varobj_display_formats format)
{
  get_formatted_print_options (opts, format_code[(int) format]);
  opts->deref_ref = 0;
  opts->raw = 1;
}

char *
varobj_value_get_print_value (struct value *value,
			      enum varobj_display_formats format,
			      struct varobj *var)
{
  struct ui_file *stb;
  struct cleanup *old_chain;
  char *thevalue = NULL;
  struct value_print_options opts;
  struct type *type = NULL;
  long len = 0;
  char *encoding = NULL;
  struct gdbarch *gdbarch = NULL;
  /* Initialize it just to avoid a GCC false warning.  */
  CORE_ADDR str_addr = 0;
  int string_print = 0;

  if (value == NULL)
    return NULL;

  stb = mem_fileopen ();
  old_chain = make_cleanup_ui_file_delete (stb);

  gdbarch = get_type_arch (value_type (value));
#if HAVE_PYTHON
  if (gdb_python_initialized)
    {
      PyObject *value_formatter =  var->dynamic->pretty_printer;

      varobj_ensure_python_env (var);

      if (value_formatter)
	{
	  /* First check to see if we have any children at all.  If so,
	     we simply return {...}.  */
	  if (dynamic_varobj_has_child_method (var))
	    {
	      do_cleanups (old_chain);
	      return xstrdup ("{...}");
	    }

	  if (PyObject_HasAttr (value_formatter, gdbpy_to_string_cst))
	    {
	      struct value *replacement;
	      PyObject *output = NULL;

	      output = apply_varobj_pretty_printer (value_formatter,
						    &replacement,
						    stb);

	      /* If we have string like output ...  */
	      if (output)
		{
		  make_cleanup_py_decref (output);

		  /* If this is a lazy string, extract it.  For lazy
		     strings we always print as a string, so set
		     string_print.  */
		  if (gdbpy_is_lazy_string (output))
		    {
		      gdbpy_extract_lazy_string (output, &str_addr, &type,
						 &len, &encoding);
		      make_cleanup (free_current_contents, &encoding);
		      string_print = 1;
		    }
		  else
		    {
		      /* If it is a regular (non-lazy) string, extract
			 it and copy the contents into THEVALUE.  If the
			 hint says to print it as a string, set
			 string_print.  Otherwise just return the extracted
			 string as a value.  */

		      char *s = python_string_to_target_string (output);

		      if (s)
			{
			  char *hint;

			  hint = gdbpy_get_display_hint (value_formatter);
			  if (hint)
			    {
			      if (!strcmp (hint, "string"))
				string_print = 1;
			      xfree (hint);
			    }

			  len = strlen (s);
			  thevalue = xmemdup (s, len + 1, len + 1);
			  type = builtin_type (gdbarch)->builtin_char;
			  xfree (s);

			  if (!string_print)
			    {
			      do_cleanups (old_chain);
			      return thevalue;
			    }

			  make_cleanup (xfree, thevalue);
			}
		      else
			gdbpy_print_stack ();
		    }
		}
	      /* If the printer returned a replacement value, set VALUE
		 to REPLACEMENT.  If there is not a replacement value,
		 just use the value passed to this function.  */
	      if (replacement)
		value = replacement;
	    }
	}
    }
#endif

  varobj_formatted_print_options (&opts, format);

  /* If the THEVALUE has contents, it is a regular string.  */
  if (thevalue)
    LA_PRINT_STRING (stb, type, (gdb_byte *) thevalue, len, encoding, 0, &opts);
  else if (string_print)
    /* Otherwise, if string_print is set, and it is not a regular
       string, it is a lazy string.  */
    val_print_string (type, encoding, str_addr, len, stb, &opts);
  else
    /* All other cases.  */
    common_val_print (value, stb, 0, &opts, current_language);

  thevalue = ui_file_xstrdup (stb, NULL);

  do_cleanups (old_chain);
  return thevalue;
}

int
varobj_editable_p (struct varobj *var)
{
  struct type *type;

  if (!(var->root->is_valid && var->value && VALUE_LVAL (var->value)))
    return 0;

  type = varobj_get_value_type (var);

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
    case TYPE_CODE_ARRAY:
    case TYPE_CODE_FUNC:
    case TYPE_CODE_METHOD:
      return 0;
      break;

    default:
      return 1;
      break;
    }
}

/* Call VAR's value_is_changeable_p language-specific callback.  */

int
varobj_value_is_changeable_p (struct varobj *var)
{
  return var->root->lang->value_is_changeable_p (var);
}

/* Return 1 if that varobj is floating, that is is always evaluated in the
   selected frame, and not bound to thread/frame.  Such variable objects
   are created using '@@' as frame specifier to -var-create.  */
int
varobj_floating_p (struct varobj *var)
{
  return var->root->floating;
}

/* Implement the "value_is_changeable_p" varobj callback for most
   languages.  */

int
varobj_default_value_is_changeable_p (struct varobj *var)
{
  int r;
  struct type *type;

  if (CPLUS_FAKE_CHILD (var))
    return 0;

  type = varobj_get_value_type (var);

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
    case TYPE_CODE_ARRAY:
      r = 0;
      break;

    default:
      r = 1;
    }

  return r;
}

/* Iterate all the existing _root_ VAROBJs and call the FUNC callback for them
   with an arbitrary caller supplied DATA pointer.  */

void
all_root_varobjs (void (*func) (struct varobj *var, void *data), void *data)
{
  struct varobj_root *var_root, *var_root_next;

  /* Iterate "safely" - handle if the callee deletes its passed VAROBJ.  */

  for (var_root = rootlist; var_root != NULL; var_root = var_root_next)
    {
      var_root_next = var_root->next;

      (*func) (var_root->rootvar, data);
    }
}

extern void _initialize_varobj (void);
void
_initialize_varobj (void)
{
  int sizeof_table = sizeof (struct vlist *) * VAROBJ_TABLE_SIZE;

  varobj_table = xmalloc (sizeof_table);
  memset (varobj_table, 0, sizeof_table);

  add_setshow_zuinteger_cmd ("debugvarobj", class_maintenance,
			     &varobjdebug,
			     _("Set varobj debugging."),
			     _("Show varobj debugging."),
			     _("When non-zero, varobj debugging is enabled."),
			     NULL, show_varobjdebug,
			     &setlist, &showlist);
}

/* Invalidate varobj VAR if it is tied to locals and re-create it if it is
   defined on globals.  It is a helper for varobj_invalidate.

   This function is called after changing the symbol file, in this case the
   pointers to "struct type" stored by the varobj are no longer valid.  All
   varobj must be either re-evaluated, or marked as invalid here.  */

static void
varobj_invalidate_iter (struct varobj *var, void *unused)
{
  /* global and floating var must be re-evaluated.  */
  if (var->root->floating || var->root->valid_block == NULL)
    {
      struct varobj *tmp_var;

      /* Try to create a varobj with same expression.  If we succeed
	 replace the old varobj, otherwise invalidate it.  */
      tmp_var = varobj_create (NULL, var->name, (CORE_ADDR) 0,
			       USE_CURRENT_FRAME);
      if (tmp_var != NULL) 
	{ 
	  tmp_var->obj_name = xstrdup (var->obj_name);
	  varobj_delete (var, NULL, 0);
	  install_variable (tmp_var);
	}
      else
	var->root->is_valid = 0;
    }
  else /* locals must be invalidated.  */
    var->root->is_valid = 0;
}

/* Invalidate the varobjs that are tied to locals and re-create the ones that
   are defined on globals.
   Invalidated varobjs will be always printed in_scope="invalid".  */

void 
varobj_invalidate (void)
{
  all_root_varobjs (varobj_invalidate_iter, NULL);
}
@


1.215
log
@gdb/

	* varobj.c (struct varobj): Move most of the fields to
	varobj.h.
	(struct varobj_dynamic): New struct.
	(varobj_get_display_hint) [HAVE_PYTHON]: Adjust.
	(varobj_has_more): Likewise.
	(dynamic_varobj_has_child_method): Likewise.
	(update_dynamic_varobj_children): Likewise.
	(varobj_get_num_children): Likewise.
	(varobj_list_children, varobj_pretty_printed_p): Likewise.
	(install_new_value_visualizer): Likewise.
	(install_new_value_visualizer, install_new_value): Likewise.
	(varobj_update, new_variable, free_variable): Likewise.
	(my_value_of_variable, value_get_print_value): Likewise.
	(install_visualizer): Change the type of parameter 'var' to
	'struct varobjd_dynamic *'.  Callers update.
	* varobj.h (struct varobj): Moved from varobj.c.
	(struct varobj) <dynamic>: New field.
@
text
@a35 2
#include "ada-varobj.h"
#include "ada-lang.h"
a43 4
/* The names of varobjs representing anonymous structs or unions.  */
#define ANONYMOUS_STRUCT_NAME _("<anonymous struct>")
#define ANONYMOUS_UNION_NAME _("<anonymous union>")

d103 3
a105 2
  /* Language info for this variable and its children.  */
  struct language_specific *lang;
a187 6
static struct type *get_type (struct varobj *var);

static struct type *get_value_type (struct varobj *var);

static struct type *get_target_type (struct type *);

a216 6
static char *value_get_print_value (struct value *value,
				    enum varobj_display_formats format,
				    struct varobj *var);

static int varobj_value_is_changeable_p (struct varobj *var);

a226 130
static int default_value_is_changeable_p (struct varobj *var);

/* C implementation */

static int c_number_of_children (struct varobj *var);

static char *c_name_of_variable (struct varobj *parent);

static char *c_name_of_child (struct varobj *parent, int index);

static char *c_path_expr_of_child (struct varobj *child);

static struct value *c_value_of_child (struct varobj *parent, int index);

static struct type *c_type_of_child (struct varobj *parent, int index);

static char *c_value_of_variable (struct varobj *var,
				  enum varobj_display_formats format);

/* C++ implementation */

static int cplus_number_of_children (struct varobj *var);

static void cplus_class_num_children (struct type *type, int children[3]);

static char *cplus_name_of_variable (struct varobj *parent);

static char *cplus_name_of_child (struct varobj *parent, int index);

static char *cplus_path_expr_of_child (struct varobj *child);

static struct value *cplus_value_of_child (struct varobj *parent, int index);

static struct type *cplus_type_of_child (struct varobj *parent, int index);

static char *cplus_value_of_variable (struct varobj *var,
				      enum varobj_display_formats format);

/* Java implementation */

static int java_number_of_children (struct varobj *var);

static char *java_name_of_variable (struct varobj *parent);

static char *java_name_of_child (struct varobj *parent, int index);

static char *java_path_expr_of_child (struct varobj *child);

static struct value *java_value_of_child (struct varobj *parent, int index);

static struct type *java_type_of_child (struct varobj *parent, int index);

static char *java_value_of_variable (struct varobj *var,
				     enum varobj_display_formats format);

/* Ada implementation */

static int ada_number_of_children (struct varobj *var);

static char *ada_name_of_variable (struct varobj *parent);

static char *ada_name_of_child (struct varobj *parent, int index);

static char *ada_path_expr_of_child (struct varobj *child);

static struct value *ada_value_of_child (struct varobj *parent, int index);

static struct type *ada_type_of_child (struct varobj *parent, int index);

static char *ada_value_of_variable (struct varobj *var,
				    enum varobj_display_formats format);

static int ada_value_is_changeable_p (struct varobj *var);

static int ada_value_has_mutated (struct varobj *var, struct value *new_val,
				  struct type *new_type);

/* The language specific vector */

struct language_specific
{
  /* The number of children of PARENT.  */
  int (*number_of_children) (struct varobj * parent);

  /* The name (expression) of a root varobj.  */
  char *(*name_of_variable) (struct varobj * parent);

  /* The name of the INDEX'th child of PARENT.  */
  char *(*name_of_child) (struct varobj * parent, int index);

  /* Returns the rooted expression of CHILD, which is a variable
     obtain that has some parent.  */
  char *(*path_expr_of_child) (struct varobj * child);

  /* The ``struct value *'' of the INDEX'th child of PARENT.  */
  struct value *(*value_of_child) (struct varobj * parent, int index);

  /* The type of the INDEX'th child of PARENT.  */
  struct type *(*type_of_child) (struct varobj * parent, int index);

  /* The current value of VAR.  */
  char *(*value_of_variable) (struct varobj * var,
			      enum varobj_display_formats format);

  /* Return non-zero if changes in value of VAR must be detected and
     reported by -var-update.  Return zero if -var-update should never
     report changes of such values.  This makes sense for structures
     (since the changes in children values will be reported separately),
     or for artifical objects (like 'public' pseudo-field in C++).

     Return value of 0 means that gdb need not call value_fetch_lazy
     for the value of this variable object.  */
  int (*value_is_changeable_p) (struct varobj *var);

  /* Return nonzero if the type of VAR has mutated.

     VAR's value is still the varobj's previous value, while NEW_VALUE
     is VAR's new value and NEW_TYPE is the var's new type.  NEW_VALUE
     may be NULL indicating that there is no value available (the varobj
     may be out of scope, of may be the child of a null pointer, for
     instance).  NEW_TYPE, on the other hand, must never be NULL.

     This function should also be able to assume that var's number of
     children is set (not < 0).

     Languages where types do not mutate can set this to NULL.  */
  int (*value_has_mutated) (struct varobj *var, struct value *new_value,
			    struct type *new_type);
};

d228 5
a232 53
static struct language_specific languages[vlang_end] = {
  /* C */
  {
   c_number_of_children,
   c_name_of_variable,
   c_name_of_child,
   c_path_expr_of_child,
   c_value_of_child,
   c_type_of_child,
   c_value_of_variable,
   default_value_is_changeable_p,
   NULL /* value_has_mutated */}
  ,
  /* C++ */
  {
   cplus_number_of_children,
   cplus_name_of_variable,
   cplus_name_of_child,
   cplus_path_expr_of_child,
   cplus_value_of_child,
   cplus_type_of_child,
   cplus_value_of_variable,
   default_value_is_changeable_p,
   NULL /* value_has_mutated */}
  ,
  /* Java */
  {
   java_number_of_children,
   java_name_of_variable,
   java_name_of_child,
   java_path_expr_of_child,
   java_value_of_child,
   java_type_of_child,
   java_value_of_variable,
   default_value_is_changeable_p,
   NULL /* value_has_mutated */},
  /* Ada */
  {
   ada_number_of_children,
   ada_name_of_variable,
   ada_name_of_child,
   ada_path_expr_of_child,
   ada_value_of_child,
   ada_type_of_child,
   ada_value_of_variable,
   ada_value_is_changeable_p,
   ada_value_has_mutated}
};

/* A little convenience enum for dealing with C++/Java.  */
enum vsections
{
  v_public = 0, v_private, v_protected
a249 3
/* Is the variable X one of our "fake" children?  */
#define CPLUS_FAKE_CHILD(x) \
((x) != NULL && (x)->type == NULL && (x)->value == NULL)
d437 1
a437 1
      var->root->lang = &languages[lang];
d617 2
a618 1
      var->print_value = value_get_print_value (var->value, var->format, var);
d700 2
a701 2
static void
restrict_range (VEC (varobj_p) *children, int *from, int *to)
d1008 1
a1008 1
      restrict_range (var->children, from, to);
d1039 1
a1039 1
  restrict_range (var->children, from, to);
d1093 1
a1093 1
  type = get_value_type (var);
d1103 2
a1104 2
static struct varobj *
get_path_expr_parent (struct varobj *var)
d1498 1
a1498 1
    print_value = value_get_print_value (value, var->format, var);
d1572 2
a1573 1
      print_value = value_get_print_value (var->value, var->format, var);
a2119 14
/* Does CHILD represent a child with no name?  This happens when
   the child is an anonmous struct or union and it has no field name
   in its parent variable.

   This has already been determined by *_describe_child. The easiest
   thing to do is to compare the child's name with ANONYMOUS_*_NAME.  */

static int
is_anonymous_child (struct varobj *child)
{
  return (strcmp (child->name, ANONYMOUS_STRUCT_NAME) == 0
	  || strcmp (child->name, ANONYMOUS_UNION_NAME) == 0);
}

d2135 1
a2135 1
  if (is_anonymous_child (child))
a2261 17
/* This returns the type of the variable.  It also skips past typedefs
   to return the real type of the variable.

   NOTE: TYPE_TARGET_TYPE should NOT be used anywhere in this file
   except within get_target_type and get_type.  */
static struct type *
get_type (struct varobj *var)
{
  struct type *type;

  type = var->type;
  if (type != NULL)
    type = check_typedef (type);

  return type;
}

d2273 2
a2274 2
static struct type *
get_value_type (struct varobj *var)
a2292 18
/* This returns the target type (or NULL) of TYPE, also skipping
   past typedefs, just like get_type ().

   NOTE: TYPE_TARGET_TYPE should NOT be used anywhere in this file
   except within get_target_type and get_type.  */
static struct type *
get_target_type (struct type *type)
{
  if (type != NULL)
    {
      type = TYPE_TARGET_TYPE (type);
      if (type != NULL)
	type = check_typedef (type);
    }

  return type;
}

d2586 1
a2586 1
	return value_get_print_value (var->value, var->format, var);
d2593 13
a2605 3
static char *
value_get_print_value (struct value *value, enum varobj_display_formats format,
		       struct varobj *var)
d2716 1
a2716 3
  get_formatted_print_options (&opts, format_code[(int) format]);
  opts.deref_ref = 0;
  opts.raw = 1;
d2743 1
a2743 1
  type = get_value_type (var);
d2763 1
a2763 1
static int
a2777 84
/* Given the value and the type of a variable object,
   adjust the value and type to those necessary
   for getting children of the variable object.
   This includes dereferencing top-level references
   to all types and dereferencing pointers to
   structures.

   If LOOKUP_ACTUAL_TYPE is set the enclosing type of the
   value will be fetched and if it differs from static type
   the value will be casted to it.

   Both TYPE and *TYPE should be non-null.  VALUE
   can be null if we want to only translate type.
   *VALUE can be null as well -- if the parent
   value is not known.

   If WAS_PTR is not NULL, set *WAS_PTR to 0 or 1
   depending on whether pointer was dereferenced
   in this function.  */
static void
adjust_value_for_child_access (struct value **value,
				  struct type **type,
				  int *was_ptr,
				  int lookup_actual_type)
{
  gdb_assert (type && *type);

  if (was_ptr)
    *was_ptr = 0;

  *type = check_typedef (*type);
  
  /* The type of value stored in varobj, that is passed
     to us, is already supposed to be
     reference-stripped.  */

  gdb_assert (TYPE_CODE (*type) != TYPE_CODE_REF);

  /* Pointers to structures are treated just like
     structures when accessing children.  Don't
     dererences pointers to other types.  */
  if (TYPE_CODE (*type) == TYPE_CODE_PTR)
    {
      struct type *target_type = get_target_type (*type);
      if (TYPE_CODE (target_type) == TYPE_CODE_STRUCT
	  || TYPE_CODE (target_type) == TYPE_CODE_UNION)
	{
	  if (value && *value)
	    {
	      volatile struct gdb_exception except;

	      TRY_CATCH (except, RETURN_MASK_ERROR)
		{
		  *value = value_ind (*value);
		}

	      if (except.reason < 0)
		*value = NULL;
	    }
	  *type = target_type;
	  if (was_ptr)
	    *was_ptr = 1;
	}
    }

  /* The 'get_target_type' function calls check_typedef on
     result, so we can immediately check type code.  No
     need to call check_typedef here.  */

  /* Access a real type of the value (if necessary and possible).  */
  if (value && *value && lookup_actual_type)
    {
      struct type *enclosing_type;
      int real_type_found = 0;

      enclosing_type = value_actual_type (*value, 1, &real_type_found);
      if (real_type_found)
        {
          *type = enclosing_type;
          *value = value_cast (enclosing_type, *value);
        }
    }
}

d2781 2
a2782 2
static int
default_value_is_changeable_p (struct varobj *var)
d2790 1
a2790 1
  type = get_value_type (var);
a2806 919
/* C */

static int
c_number_of_children (struct varobj *var)
{
  struct type *type = get_value_type (var);
  int children = 0;
  struct type *target;

  adjust_value_for_child_access (NULL, &type, NULL, 0);
  target = get_target_type (type);

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_ARRAY:
      if (TYPE_LENGTH (type) > 0 && TYPE_LENGTH (target) > 0
	  && !TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED (type))
	children = TYPE_LENGTH (type) / TYPE_LENGTH (target);
      else
	/* If we don't know how many elements there are, don't display
	   any.  */
	children = 0;
      break;

    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      children = TYPE_NFIELDS (type);
      break;

    case TYPE_CODE_PTR:
      /* The type here is a pointer to non-struct.  Typically, pointers
	 have one child, except for function ptrs, which have no children,
	 and except for void*, as we don't know what to show.

         We can show char* so we allow it to be dereferenced.  If you decide
         to test for it, please mind that a little magic is necessary to
         properly identify it: char* has TYPE_CODE == TYPE_CODE_INT and 
         TYPE_NAME == "char".  */
      if (TYPE_CODE (target) == TYPE_CODE_FUNC
	  || TYPE_CODE (target) == TYPE_CODE_VOID)
	children = 0;
      else
	children = 1;
      break;

    default:
      /* Other types have no children.  */
      break;
    }

  return children;
}

static char *
c_name_of_variable (struct varobj *parent)
{
  return xstrdup (parent->name);
}

/* Return the value of element TYPE_INDEX of a structure
   value VALUE.  VALUE's type should be a structure,
   or union, or a typedef to struct/union.

   Returns NULL if getting the value fails.  Never throws.  */
static struct value *
value_struct_element_index (struct value *value, int type_index)
{
  struct value *result = NULL;
  volatile struct gdb_exception e;
  struct type *type = value_type (value);

  type = check_typedef (type);

  gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT
	      || TYPE_CODE (type) == TYPE_CODE_UNION);

  TRY_CATCH (e, RETURN_MASK_ERROR)
    {
      if (field_is_static (&TYPE_FIELD (type, type_index)))
	result = value_static_field (type, type_index);
      else
	result = value_primitive_field (value, 0, type_index, type);
    }
  if (e.reason < 0)
    {
      return NULL;
    }
  else
    {
      return result;
    }
}

/* Obtain the information about child INDEX of the variable
   object PARENT.
   If CNAME is not null, sets *CNAME to the name of the child relative
   to the parent.
   If CVALUE is not null, sets *CVALUE to the value of the child.
   If CTYPE is not null, sets *CTYPE to the type of the child.

   If any of CNAME, CVALUE, or CTYPE is not null, but the corresponding
   information cannot be determined, set *CNAME, *CVALUE, or *CTYPE
   to NULL.  */
static void 
c_describe_child (struct varobj *parent, int index,
		  char **cname, struct value **cvalue, struct type **ctype,
		  char **cfull_expression)
{
  struct value *value = parent->value;
  struct type *type = get_value_type (parent);
  char *parent_expression = NULL;
  int was_ptr;
  volatile struct gdb_exception except;

  if (cname)
    *cname = NULL;
  if (cvalue)
    *cvalue = NULL;
  if (ctype)
    *ctype = NULL;
  if (cfull_expression)
    {
      *cfull_expression = NULL;
      parent_expression = varobj_get_path_expr (get_path_expr_parent (parent));
    }
  adjust_value_for_child_access (&value, &type, &was_ptr, 0);
      
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_ARRAY:
      if (cname)
	*cname
	  = xstrdup (int_string (index 
				 + TYPE_LOW_BOUND (TYPE_INDEX_TYPE (type)),
				 10, 1, 0, 0));

      if (cvalue && value)
	{
	  int real_index = index + TYPE_LOW_BOUND (TYPE_INDEX_TYPE (type));

	  TRY_CATCH (except, RETURN_MASK_ERROR)
	    {
	      *cvalue = value_subscript (value, real_index);
	    }
	}

      if (ctype)
	*ctype = get_target_type (type);

      if (cfull_expression)
	*cfull_expression = 
	  xstrprintf ("(%s)[%s]", parent_expression, 
		      int_string (index
				  + TYPE_LOW_BOUND (TYPE_INDEX_TYPE (type)),
				  10, 1, 0, 0));


      break;

    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      {
	const char *field_name;

	/* If the type is anonymous and the field has no name,
	   set an appropriate name.  */
	field_name = TYPE_FIELD_NAME (type, index);
	if (field_name == NULL || *field_name == '\0')
	  {
	    if (cname)
	      {
		if (TYPE_CODE (TYPE_FIELD_TYPE (type, index))
		    == TYPE_CODE_STRUCT)
		  *cname = xstrdup (ANONYMOUS_STRUCT_NAME);
		else
		  *cname = xstrdup (ANONYMOUS_UNION_NAME);
	      }

	    if (cfull_expression)
	      *cfull_expression = xstrdup ("");
	  }
	else
	  {
	    if (cname)
	      *cname = xstrdup (field_name);

	    if (cfull_expression)
	      {
		char *join = was_ptr ? "->" : ".";

		*cfull_expression = xstrprintf ("(%s)%s%s", parent_expression,
						join, field_name);
	      }
	  }

	if (cvalue && value)
	  {
	    /* For C, varobj index is the same as type index.  */
	    *cvalue = value_struct_element_index (value, index);
	  }

	if (ctype)
	  *ctype = TYPE_FIELD_TYPE (type, index);
      }
      break;

    case TYPE_CODE_PTR:
      if (cname)
	*cname = xstrprintf ("*%s", parent->name);

      if (cvalue && value)
	{
	  TRY_CATCH (except, RETURN_MASK_ERROR)
	    {
	      *cvalue = value_ind (value);
	    }

	  if (except.reason < 0)
	    *cvalue = NULL;
	}

      /* Don't use get_target_type because it calls
	 check_typedef and here, we want to show the true
	 declared type of the variable.  */
      if (ctype)
	*ctype = TYPE_TARGET_TYPE (type);

      if (cfull_expression)
	*cfull_expression = xstrprintf ("*(%s)", parent_expression);
      
      break;

    default:
      /* This should not happen.  */
      if (cname)
	*cname = xstrdup ("???");
      if (cfull_expression)
	*cfull_expression = xstrdup ("???");
      /* Don't set value and type, we don't know then.  */
    }
}

static char *
c_name_of_child (struct varobj *parent, int index)
{
  char *name;

  c_describe_child (parent, index, &name, NULL, NULL, NULL);
  return name;
}

static char *
c_path_expr_of_child (struct varobj *child)
{
  c_describe_child (child->parent, child->index, NULL, NULL, NULL, 
		    &child->path_expr);
  return child->path_expr;
}

static struct value *
c_value_of_child (struct varobj *parent, int index)
{
  struct value *value = NULL;

  c_describe_child (parent, index, NULL, &value, NULL, NULL);
  return value;
}

static struct type *
c_type_of_child (struct varobj *parent, int index)
{
  struct type *type = NULL;

  c_describe_child (parent, index, NULL, NULL, &type, NULL);
  return type;
}

static char *
c_value_of_variable (struct varobj *var, enum varobj_display_formats format)
{
  /* BOGUS: if val_print sees a struct/class, or a reference to one,
     it will print out its children instead of "{...}".  So we need to
     catch that case explicitly.  */
  struct type *type = get_type (var);

  /* Strip top-level references.  */
  while (TYPE_CODE (type) == TYPE_CODE_REF)
    type = check_typedef (TYPE_TARGET_TYPE (type));

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      return xstrdup ("{...}");
      /* break; */

    case TYPE_CODE_ARRAY:
      {
	char *number;

	number = xstrprintf ("[%d]", var->num_children);
	return (number);
      }
      /* break; */

    default:
      {
	if (var->value == NULL)
	  {
	    /* This can happen if we attempt to get the value of a struct
	       member when the parent is an invalid pointer.  This is an
	       error condition, so we should tell the caller.  */
	    return NULL;
	  }
	else
	  {
	    if (var->not_fetched && value_lazy (var->value))
	      /* Frozen variable and no value yet.  We don't
		 implicitly fetch the value.  MI response will
		 use empty string for the value, which is OK.  */
	      return NULL;

	    gdb_assert (varobj_value_is_changeable_p (var));
	    gdb_assert (!value_lazy (var->value));
	    
	    /* If the specified format is the current one,
	       we can reuse print_value.  */
	    if (format == var->format)
	      return xstrdup (var->print_value);
	    else
	      return value_get_print_value (var->value, format, var);
	  }
      }
    }
}


/* C++ */

static int
cplus_number_of_children (struct varobj *var)
{
  struct value *value = NULL;
  struct type *type;
  int children, dont_know;
  int lookup_actual_type = 0;
  struct value_print_options opts;

  dont_know = 1;
  children = 0;

  get_user_print_options (&opts);

  if (!CPLUS_FAKE_CHILD (var))
    {
      type = get_value_type (var);

      /* It is necessary to access a real type (via RTTI).  */
      if (opts.objectprint)
        {
          value = var->value;
          lookup_actual_type = (TYPE_CODE (var->type) == TYPE_CODE_REF
				|| TYPE_CODE (var->type) == TYPE_CODE_PTR);
        }
      adjust_value_for_child_access (&value, &type, NULL, lookup_actual_type);

      if (((TYPE_CODE (type)) == TYPE_CODE_STRUCT) ||
	  ((TYPE_CODE (type)) == TYPE_CODE_UNION))
	{
	  int kids[3];

	  cplus_class_num_children (type, kids);
	  if (kids[v_public] != 0)
	    children++;
	  if (kids[v_private] != 0)
	    children++;
	  if (kids[v_protected] != 0)
	    children++;

	  /* Add any baseclasses.  */
	  children += TYPE_N_BASECLASSES (type);
	  dont_know = 0;

	  /* FIXME: save children in var.  */
	}
    }
  else
    {
      int kids[3];

      type = get_value_type (var->parent);

      /* It is necessary to access a real type (via RTTI).  */
      if (opts.objectprint)
        {
	  struct varobj *parent = var->parent;

	  value = parent->value;
	  lookup_actual_type = (TYPE_CODE (parent->type) == TYPE_CODE_REF
				|| TYPE_CODE (parent->type) == TYPE_CODE_PTR);
        }
      adjust_value_for_child_access (&value, &type, NULL, lookup_actual_type);

      cplus_class_num_children (type, kids);
      if (strcmp (var->name, "public") == 0)
	children = kids[v_public];
      else if (strcmp (var->name, "private") == 0)
	children = kids[v_private];
      else
	children = kids[v_protected];
      dont_know = 0;
    }

  if (dont_know)
    children = c_number_of_children (var);

  return children;
}

/* Compute # of public, private, and protected variables in this class.
   That means we need to descend into all baseclasses and find out
   how many are there, too.  */
static void
cplus_class_num_children (struct type *type, int children[3])
{
  int i, vptr_fieldno;
  struct type *basetype = NULL;

  children[v_public] = 0;
  children[v_private] = 0;
  children[v_protected] = 0;

  vptr_fieldno = get_vptr_fieldno (type, &basetype);
  for (i = TYPE_N_BASECLASSES (type); i < TYPE_NFIELDS (type); i++)
    {
      /* If we have a virtual table pointer, omit it.  Even if virtual
	 table pointers are not specifically marked in the debug info,
	 they should be artificial.  */
      if ((type == basetype && i == vptr_fieldno)
	  || TYPE_FIELD_ARTIFICIAL (type, i))
	continue;

      if (TYPE_FIELD_PROTECTED (type, i))
	children[v_protected]++;
      else if (TYPE_FIELD_PRIVATE (type, i))
	children[v_private]++;
      else
	children[v_public]++;
    }
}

static char *
cplus_name_of_variable (struct varobj *parent)
{
  return c_name_of_variable (parent);
}

enum accessibility { private_field, protected_field, public_field };

/* Check if field INDEX of TYPE has the specified accessibility.
   Return 0 if so and 1 otherwise.  */
static int 
match_accessibility (struct type *type, int index, enum accessibility acc)
{
  if (acc == private_field && TYPE_FIELD_PRIVATE (type, index))
    return 1;
  else if (acc == protected_field && TYPE_FIELD_PROTECTED (type, index))
    return 1;
  else if (acc == public_field && !TYPE_FIELD_PRIVATE (type, index)
	   && !TYPE_FIELD_PROTECTED (type, index))
    return 1;
  else
    return 0;
}

static void
cplus_describe_child (struct varobj *parent, int index,
		      char **cname, struct value **cvalue, struct type **ctype,
		      char **cfull_expression)
{
  struct value *value;
  struct type *type;
  int was_ptr;
  int lookup_actual_type = 0;
  char *parent_expression = NULL;
  struct varobj *var;
  struct value_print_options opts;

  if (cname)
    *cname = NULL;
  if (cvalue)
    *cvalue = NULL;
  if (ctype)
    *ctype = NULL;
  if (cfull_expression)
    *cfull_expression = NULL;

  get_user_print_options (&opts);

  var = (CPLUS_FAKE_CHILD (parent)) ? parent->parent : parent;
  if (opts.objectprint)
    lookup_actual_type = (TYPE_CODE (var->type) == TYPE_CODE_REF
			  || TYPE_CODE (var->type) == TYPE_CODE_PTR);
  value = var->value;
  type = get_value_type (var);
  if (cfull_expression)
    parent_expression = varobj_get_path_expr (get_path_expr_parent (var));

  adjust_value_for_child_access (&value, &type, &was_ptr, lookup_actual_type);

  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      || TYPE_CODE (type) == TYPE_CODE_UNION)
    {
      char *join = was_ptr ? "->" : ".";

      if (CPLUS_FAKE_CHILD (parent))
	{
	  /* The fields of the class type are ordered as they
	     appear in the class.  We are given an index for a
	     particular access control type ("public","protected",
	     or "private").  We must skip over fields that don't
	     have the access control we are looking for to properly
	     find the indexed field.  */
	  int type_index = TYPE_N_BASECLASSES (type);
	  enum accessibility acc = public_field;
	  int vptr_fieldno;
	  struct type *basetype = NULL;
	  const char *field_name;

	  vptr_fieldno = get_vptr_fieldno (type, &basetype);
	  if (strcmp (parent->name, "private") == 0)
	    acc = private_field;
	  else if (strcmp (parent->name, "protected") == 0)
	    acc = protected_field;

	  while (index >= 0)
	    {
	      if ((type == basetype && type_index == vptr_fieldno)
		  || TYPE_FIELD_ARTIFICIAL (type, type_index))
		; /* ignore vptr */
	      else if (match_accessibility (type, type_index, acc))
		    --index;
		  ++type_index;
	    }
	  --type_index;

	  /* If the type is anonymous and the field has no name,
	     set an appopriate name.  */
	  field_name = TYPE_FIELD_NAME (type, type_index);
	  if (field_name == NULL || *field_name == '\0')
	    {
	      if (cname)
		{
		  if (TYPE_CODE (TYPE_FIELD_TYPE (type, type_index))
		      == TYPE_CODE_STRUCT)
		    *cname = xstrdup (ANONYMOUS_STRUCT_NAME);
		  else if (TYPE_CODE (TYPE_FIELD_TYPE (type, type_index))
			   == TYPE_CODE_UNION)
		    *cname = xstrdup (ANONYMOUS_UNION_NAME);
		}

	      if (cfull_expression)
		*cfull_expression = xstrdup ("");
	    }
	  else
	    {
	      if (cname)
		*cname = xstrdup (TYPE_FIELD_NAME (type, type_index));

	      if (cfull_expression)
		*cfull_expression
		  = xstrprintf ("((%s)%s%s)", parent_expression, join,
				field_name);
	    }

	  if (cvalue && value)
	    *cvalue = value_struct_element_index (value, type_index);

	  if (ctype)
	    *ctype = TYPE_FIELD_TYPE (type, type_index);
	}
      else if (index < TYPE_N_BASECLASSES (type))
	{
	  /* This is a baseclass.  */
	  if (cname)
	    *cname = xstrdup (TYPE_FIELD_NAME (type, index));

	  if (cvalue && value)
	    *cvalue = value_cast (TYPE_FIELD_TYPE (type, index), value);

	  if (ctype)
	    {
	      *ctype = TYPE_FIELD_TYPE (type, index);
	    }

	  if (cfull_expression)
	    {
	      char *ptr = was_ptr ? "*" : "";

	      /* Cast the parent to the base' type.  Note that in gdb,
		 expression like 
		         (Base1)d
		 will create an lvalue, for all appearences, so we don't
		 need to use more fancy:
		         *(Base1*)(&d)
		 construct.

		 When we are in the scope of the base class or of one
		 of its children, the type field name will be interpreted
		 as a constructor, if it exists.  Therefore, we must
		 indicate that the name is a class name by using the
		 'class' keyword.  See PR mi/11912  */
	      *cfull_expression = xstrprintf ("(%s(class %s%s) %s)", 
					      ptr, 
					      TYPE_FIELD_NAME (type, index),
					      ptr,
					      parent_expression);
	    }
	}
      else
	{
	  char *access = NULL;
	  int children[3];

	  cplus_class_num_children (type, children);

	  /* Everything beyond the baseclasses can
	     only be "public", "private", or "protected"

	     The special "fake" children are always output by varobj in
	     this order.  So if INDEX == 2, it MUST be "protected".  */
	  index -= TYPE_N_BASECLASSES (type);
	  switch (index)
	    {
	    case 0:
	      if (children[v_public] > 0)
	 	access = "public";
	      else if (children[v_private] > 0)
	 	access = "private";
	      else 
	 	access = "protected";
	      break;
	    case 1:
	      if (children[v_public] > 0)
		{
		  if (children[v_private] > 0)
		    access = "private";
		  else
		    access = "protected";
		}
	      else if (children[v_private] > 0)
	 	access = "protected";
	      break;
	    case 2:
	      /* Must be protected.  */
	      access = "protected";
	      break;
	    default:
	      /* error!  */
	      break;
	    }

	  gdb_assert (access);
	  if (cname)
	    *cname = xstrdup (access);

	  /* Value and type and full expression are null here.  */
	}
    }
  else
    {
      c_describe_child (parent, index, cname, cvalue, ctype, cfull_expression);
    }  
}

static char *
cplus_name_of_child (struct varobj *parent, int index)
{
  char *name = NULL;

  cplus_describe_child (parent, index, &name, NULL, NULL, NULL);
  return name;
}

static char *
cplus_path_expr_of_child (struct varobj *child)
{
  cplus_describe_child (child->parent, child->index, NULL, NULL, NULL, 
			&child->path_expr);
  return child->path_expr;
}

static struct value *
cplus_value_of_child (struct varobj *parent, int index)
{
  struct value *value = NULL;

  cplus_describe_child (parent, index, NULL, &value, NULL, NULL);
  return value;
}

static struct type *
cplus_type_of_child (struct varobj *parent, int index)
{
  struct type *type = NULL;

  cplus_describe_child (parent, index, NULL, NULL, &type, NULL);
  return type;
}

static char *
cplus_value_of_variable (struct varobj *var, 
			 enum varobj_display_formats format)
{

  /* If we have one of our special types, don't print out
     any value.  */
  if (CPLUS_FAKE_CHILD (var))
    return xstrdup ("");

  return c_value_of_variable (var, format);
}

/* Java */

static int
java_number_of_children (struct varobj *var)
{
  return cplus_number_of_children (var);
}

static char *
java_name_of_variable (struct varobj *parent)
{
  char *p, *name;

  name = cplus_name_of_variable (parent);
  /* If  the name has "-" in it, it is because we
     needed to escape periods in the name...  */
  p = name;

  while (*p != '\000')
    {
      if (*p == '-')
	*p = '.';
      p++;
    }

  return name;
}

static char *
java_name_of_child (struct varobj *parent, int index)
{
  char *name, *p;

  name = cplus_name_of_child (parent, index);
  /* Escape any periods in the name...  */
  p = name;

  while (*p != '\000')
    {
      if (*p == '.')
	*p = '-';
      p++;
    }

  return name;
}

static char *
java_path_expr_of_child (struct varobj *child)
{
  return NULL;
}

static struct value *
java_value_of_child (struct varobj *parent, int index)
{
  return cplus_value_of_child (parent, index);
}

static struct type *
java_type_of_child (struct varobj *parent, int index)
{
  return cplus_type_of_child (parent, index);
}

static char *
java_value_of_variable (struct varobj *var, enum varobj_display_formats format)
{
  return cplus_value_of_variable (var, format);
}

/* Ada specific callbacks for VAROBJs.  */

static int
ada_number_of_children (struct varobj *var)
{
  return ada_varobj_get_number_of_children (var->value, var->type);
}

static char *
ada_name_of_variable (struct varobj *parent)
{
  return c_name_of_variable (parent);
}

static char *
ada_name_of_child (struct varobj *parent, int index)
{
  return ada_varobj_get_name_of_child (parent->value, parent->type,
				       parent->name, index);
}

static char*
ada_path_expr_of_child (struct varobj *child)
{
  struct varobj *parent = child->parent;
  const char *parent_path_expr = varobj_get_path_expr (parent);

  return ada_varobj_get_path_expr_of_child (parent->value,
					    parent->type,
					    parent->name,
					    parent_path_expr,
					    child->index);
}

static struct value *
ada_value_of_child (struct varobj *parent, int index)
{
  return ada_varobj_get_value_of_child (parent->value, parent->type,
					parent->name, index);
}

static struct type *
ada_type_of_child (struct varobj *parent, int index)
{
  return ada_varobj_get_type_of_child (parent->value, parent->type,
				       index);
}

static char *
ada_value_of_variable (struct varobj *var, enum varobj_display_formats format)
{
  struct value_print_options opts;

  get_formatted_print_options (&opts, format_code[(int) format]);
  opts.deref_ref = 0;
  opts.raw = 1;

  return ada_varobj_get_value_of_variable (var->value, var->type, &opts);
}

/* Implement the "value_is_changeable_p" routine for Ada.  */

static int
ada_value_is_changeable_p (struct varobj *var)
{
  struct type *type = var->value ? value_type (var->value) : var->type;

  if (ada_is_array_descriptor_type (type)
      && TYPE_CODE (type) == TYPE_CODE_TYPEDEF)
    {
      /* This is in reality a pointer to an unconstrained array.
	 its value is changeable.  */
      return 1;
    }

  if (ada_is_string_type (type))
    {
      /* We display the contents of the string in the array's
	 "value" field.  The contents can change, so consider
	 that the array is changeable.  */
      return 1;
    }

  return default_value_is_changeable_p (var);
}

/* Implement the "value_has_mutated" routine for Ada.  */

static int
ada_value_has_mutated (struct varobj *var, struct value *new_val,
		       struct type *new_type)
{
  int i;
  int from = -1;
  int to = -1;

  /* If the number of fields have changed, then for sure the type
     has mutated.  */
  if (ada_varobj_get_number_of_children (new_val, new_type)
      != var->num_children)
    return 1;

  /* If the number of fields have remained the same, then we need
     to check the name of each field.  If they remain the same,
     then chances are the type hasn't mutated.  This is technically
     an incomplete test, as the child's type might have changed
     despite the fact that the name remains the same.  But we'll
     handle this situation by saying that the child has mutated,
     not this value.

     If only part (or none!) of the children have been fetched,
     then only check the ones we fetched.  It does not matter
     to the frontend whether a child that it has not fetched yet
     has mutated or not. So just assume it hasn't.  */

  restrict_range (var->children, &from, &to);
  for (i = from; i < to; i++)
    if (strcmp (ada_varobj_get_name_of_child (new_val, new_type,
					      var->name, i),
		VEC_index (varobj_p, var->children, i)->name) != 0)
      return 1;

  return 0;
}

@


1.214
log
@Fix FIXME: xstrdup should not be here

Hi,

This FIXME goes into my eyes, when I am about to modify something here,

  /* Name is allocated by name_of_child.  */
  /* FIXME: xstrdup should not be here.  */

This FIXME was introduced in the python pretty-pretter patches.

  Python pretty-printing [6/6]
  https://sourceware.org/ml/gdb-patches/2009-05/msg00467.html

create_child_with_value is called in two paths,

 1. varobj_list_children -> create_child -> create_child_with_value,
 2. install_dynamic_child -> install_dynamic_child -> varobj_add_child
    -> create_child_with_value

In path #1, 'name' is allocated by name_of_child, as the original
comment said, we don't have to duplicate NAME in
create_child_with_value.  In path #2, 'name' is got from
PyArg_ParseTuple, and we have to duplicate NAME.

This patch removes the call to xstrdup in create_child_with_value
and call xstrudp in update_dynamic_varobj_children (path #2).

gdb:

2013-10-04  Yao Qi  <yao@@codesourcery.com>

	* varobj.c (create_child_with_value): Remove 'const' from the
	type of parameter 'name'.
	(varobj_add_child): Likewise.
	(install_dynamic_child): Remove 'const' from the type of
	parameter 'name'.
	(varobj_add_child): Likewise.
	(create_child_with_value): Likewise.  Update comments.  Don't
	duplicate 'name'.
	(update_dynamic_varobj_children): Duplicate 'name'
	and pass it to install_dynamic_child.
@
text
@d119 3
a121 4
/* Every variable in the system has a structure of this type defined
   for it.  This structure holds all information necessary to manipulate
   a particular object variable.  Members which must be freed are noted.  */
struct varobj
a122 38

  /* Alloc'd name of the variable for this object.  If this variable is a
     child, then this name will be the child's source name.
     (bar, not foo.bar).  */
  /* NOTE: This is the "expression".  */
  char *name;

  /* Alloc'd expression for this child.  Can be used to create a
     root variable corresponding to this child.  */
  char *path_expr;

  /* The alloc'd name for this variable's object.  This is here for
     convenience when constructing this object's children.  */
  char *obj_name;

  /* Index of this variable in its parent or -1.  */
  int index;

  /* The type of this variable.  This can be NULL
     for artifial variable objects -- currently, the "accessibility" 
     variable objects in C++.  */
  struct type *type;

  /* The value of this expression or subexpression.  A NULL value
     indicates there was an error getting this value.
     Invariant: if varobj_value_is_changeable_p (this) is non-zero, 
     the value is either NULL, or not lazy.  */
  struct value *value;

  /* The number of (immediate) children this variable has.  */
  int num_children;

  /* If this object is a child, this points to its immediate parent.  */
  struct varobj *parent;

  /* Children of this object.  */
  VEC (varobj_p) *children;

a128 29
  /* Description of the root variable.  Points to root variable for
     children.  */
  struct varobj_root *root;

  /* The format of the output for this object.  */
  enum varobj_display_formats format;

  /* Was this variable updated via a varobj_set_value operation.  */
  int updated;

  /* Last print value.  */
  char *print_value;

  /* Is this variable frozen.  Frozen variables are never implicitly
     updated by -var-update * 
     or -var-update <direct-or-indirect-parent>.  */
  int frozen;

  /* Is the value of this variable intentionally not fetched?  It is
     not fetched if either the variable is frozen, or any parents is
     frozen.  */
  int not_fetched;

  /* Sub-range of children which the MI consumer has requested.  If
     FROM < 0 or TO < 0, means that all children have been
     requested.  */
  int from;
  int to;

d840 2
a841 2
  if (var->pretty_printer)
    result = gdbpy_get_display_hint (var->pretty_printer);
d857 1
a857 1
	  && var->saved_item != NULL);
d967 1
a967 1
  PyObject *printer = var->pretty_printer;
d996 1
a996 1
  PyObject *printer = var->pretty_printer;
d1010 1
a1010 1
  if (update_children || !var->child_iter)
d1023 3
a1025 3
      Py_XDECREF (var->child_iter);
      var->child_iter = PyObject_GetIter (children);
      if (!var->child_iter)
d1031 2
a1032 2
      Py_XDECREF (var->saved_item);
      var->saved_item = NULL;
d1047 1
a1047 1
      if (var->saved_item)
d1049 2
a1050 2
	  item = var->saved_item;
	  var->saved_item = NULL;
d1053 1
a1053 1
	item = PyIter_Next (var->child_iter);
d1129 2
a1130 2
	  Py_XDECREF (var->saved_item);
	  var->saved_item = item;
d1171 1
a1171 1
      if (var->pretty_printer)
d1196 1
a1196 1
  var->children_requested = 1;
d1198 1
a1198 1
  if (var->pretty_printer)
d1349 1
a1349 1
  return var->pretty_printer != NULL;
d1437 1
a1437 1
   in a varobj.  */
d1440 1
a1440 1
install_visualizer (struct varobj *var, PyObject *constructor,
d1482 1
a1482 1
      install_visualizer (var, NULL, pretty_printer);
d1519 1
a1519 1
  install_visualizer (var, constructor, pretty_printer);
d1536 1
a1536 1
  if (var->constructor != Py_None && var->value)
d1542 1
a1542 1
      if (!var->constructor)
d1545 1
a1545 1
	construct_visualizer (var, var->constructor);
d1622 1
a1622 1
  if (var->pretty_printer)
d1693 2
a1694 1
  if (value && !value_lazy (value) && !var->pretty_printer)
d1711 1
a1711 1
      else if (! var->pretty_printer)
d1766 1
a1766 1
  if (var->pretty_printer)
d1995 1
a1995 1
      if (v->pretty_printer)
d2004 1
a2004 1
	  if (!v->children_requested)
d2395 3
a2397 1
  var->children_requested = 0;
d2400 4
a2403 4
  var->constructor = 0;
  var->pretty_printer = 0;
  var->child_iter = 0;
  var->saved_item = 0;
d2431 1
a2431 1
  if (var->pretty_printer)
d2434 5
a2438 4
      Py_XDECREF (var->constructor);
      Py_XDECREF (var->pretty_printer);
      Py_XDECREF (var->child_iter);
      Py_XDECREF (var->saved_item);
d2456 1
d2830 1
a2830 1
      if (var->pretty_printer)
d2864 1
a2864 1
      PyObject *value_formatter = var->pretty_printer;
@


1.213
log
@gdb/

	* varobj.c (c_value_of_root): Remove declaration.
	(cplus_value_of_root, java_value_of_root): Likewise.
	(ada_value_of_root): Likewise.
	(struct language_specific) <value_of_root>: Remove.
	(languages): Update initialization.
	(check_scope): Move earlier.
	(c_value_of_root): Move earlier and rename to ...
	(value_of_root_1): ... this.
	(value_of_root): Caller update.
	(cplus_value_of_root, java_value_of_root): Remove.
	(ada_value_of_root): Remove.
@
text
@d248 1
a248 1
create_child_with_value (struct varobj *parent, int index, const char *name,
d307 1
a307 1
					const char *name,
d997 1
a997 1
		       const char *name,
d1191 2
a1192 1
				 can_mention ? cchanged : NULL, i, name, v);
d1311 1
a1311 1
varobj_add_child (struct varobj *var, const char *name, struct value *value)
d2398 1
a2398 1
create_child_with_value (struct varobj *parent, int index, const char *name,
d2406 2
a2407 3
  /* Name is allocated by name_of_child.  */
  /* FIXME: xstrdup should not be here.  */
  child->name = xstrdup (name);
@


1.212
log
@gdb/

	* varobj.c (varobj_format_string): Remove "unknown".
	(languages): Remove the first element.
	* varobj.h (enum varobj_languages): Remove vlang_c.
@
text
@a323 2
static struct value *c_value_of_root (struct varobj **var_handle);

a342 2
static struct value *cplus_value_of_root (struct varobj **var_handle);

a359 2
static struct value *java_value_of_root (struct varobj **var_handle);

a376 2
static struct value *ada_value_of_root (struct varobj **var_handle);

a405 3
  /* The ``struct value *'' of the root variable ROOT.  */
  struct value *(*value_of_root) (struct varobj ** root_handle);

a449 1
   c_value_of_root,
a461 1
   cplus_value_of_root,
a473 1
   java_value_of_root,
a484 1
   ada_value_of_root,
d2698 80
d2855 1
a2855 1
    value = (*var->root->lang->value_of_root) (var_handle);
a3449 77
/* If frame associated with VAR can be found, switch
   to it and return 1.  Otherwise, return 0.  */
static int
check_scope (struct varobj *var)
{
  struct frame_info *fi;
  int scope;

  fi = frame_find_by_id (var->root->frame);
  scope = fi != NULL;

  if (fi)
    {
      CORE_ADDR pc = get_frame_pc (fi);

      if (pc <  BLOCK_START (var->root->valid_block) ||
	  pc >= BLOCK_END (var->root->valid_block))
	scope = 0;
      else
	select_frame (fi);
    }
  return scope;
}

static struct value *
c_value_of_root (struct varobj **var_handle)
{
  struct value *new_val = NULL;
  struct varobj *var = *var_handle;
  int within_scope = 0;
  struct cleanup *back_to;
								 
  /*  Only root variables can be updated...  */
  if (!is_root_p (var))
    /* Not a root var.  */
    return NULL;

  back_to = make_cleanup_restore_current_thread ();

  /* Determine whether the variable is still around.  */
  if (var->root->valid_block == NULL || var->root->floating)
    within_scope = 1;
  else if (var->root->thread_id == 0)
    {
      /* The program was single-threaded when the variable object was
	 created.  Technically, it's possible that the program became
	 multi-threaded since then, but we don't support such
	 scenario yet.  */
      within_scope = check_scope (var);	  
    }
  else
    {
      ptid_t ptid = thread_id_to_pid (var->root->thread_id);
      if (in_thread_list (ptid))
	{
	  switch_to_thread (ptid);
	  within_scope = check_scope (var);
	}
    }

  if (within_scope)
    {
      volatile struct gdb_exception except;

      /* We need to catch errors here, because if evaluate
         expression fails we want to just return NULL.  */
      TRY_CATCH (except, RETURN_MASK_ERROR)
	{
	  new_val = evaluate_expression (var->root->exp);
	}
    }

  do_cleanups (back_to);

  return new_val;
}

a3883 6
cplus_value_of_root (struct varobj **var_handle)
{
  return c_value_of_root (var_handle);
}

static struct value *
a3967 6
java_value_of_root (struct varobj **var_handle)
{
  return cplus_value_of_root (var_handle);
}

static struct value *
a4019 6
ada_value_of_root (struct varobj **var_handle)
{
  return c_value_of_root (var_handle);
}

static struct value *
@


1.211
log
@gdb/

	* varobj.c (struct language_specific) <language>: Remove.
	(languages): Update the initialization.
@
text
@d65 1
a65 1
char *varobj_language_string[] = { "unknown", "C", "C++", "Java" };
a454 13
  /* Unknown (try treating as C).  */
  {
   c_number_of_children,
   c_name_of_variable,
   c_name_of_child,
   c_path_expr_of_child,
   c_value_of_root,
   c_value_of_child,
   c_type_of_child,
   c_value_of_variable,
   default_value_is_changeable_p,
   NULL /* value_has_mutated */}
  ,
@


1.210
log
@gdb/

	* varobj.c (install_dynamic_child): Remove trailing space.
	Add one blank line after variable declaration.
@
text
@a400 4

  /* The language of this variable.  */
  enum varobj_languages language;

a456 1
   vlang_unknown,
a469 1
   vlang_c,
a482 1
   vlang_cplus,
a495 1
   vlang_java,
a507 1
   vlang_ada,
@


1.209
log
@fix varobj.c

c_value_of_root is missing a call to do_cleanups at one return.
This fixes the problem by removing that return and letting control
fall through.

	* varobj.c (c_value_of_root): Call do_cleanups along all
	return paths.
@
text
@d1048 1
a1048 1
  else 
d1051 1
a1052 1
      int type_updated = update_type_if_necessary (existing, value);
@


1.208
log
@	* mi/mi-main.c: Include python-internal.h.
	(mi_cmd_list_features): Check gdb_python_initialized.
	* python/py-inferior.c (python_on_normal_stop, python_on_resume)
	(python_inferior_exit, python_new_objfile, add_thread_object)
	(delete_thread_object, py_free_inferior): Check
	gdb_python_initialized.
	* python/py-prettyprint.c (apply_val_pretty_printer): Check
	gdb_python_initialized.
	* python/py-type.c (save_objfile_types): Check
	gdb_python_initialized.
	* python/python-internal.h (gdb_python_initialized): Declare.
	* python/python.c (ensure_python_env): Throw exception if
	Python not initialized.
	(before_prompt_hook, source_python_script_for_objfile)
	(start_type_printers, apply_type_printers,
	free_type_printers): Check gdb_python_initialized.
	* varobj.c (varobj_get_display_hint)
	(dynamic_varobj_has_child_method, update_dynamic_varobj_children)
	(install_new_value_visualizer, varobj_set_visualizer)
	(value_get_print_value): Check gdb_python_initialized.
@
text
@a3476 2

      return new_val;
d3481 1
a3481 1
  return NULL;
@


1.207
log
@Fix build failure in varobj.c:update_dynamic_varobj_children...

... when !HAVE_PYTHON.

gdb/ChangeLog:

        * varobj.c (update_dynamic_varobj_children) [!HAVE_PYTHON]:
        Use gdb_assert_not_reached instead of invalid boolean expression.
@
text
@d938 6
a943 1
  struct cleanup *back_to = varobj_ensure_python_env (var);
d1075 3
d1103 3
d1637 3
d1916 3
d2882 3
a2884 2
  {
    PyObject *value_formatter = var->pretty_printer;
d2886 1
a2886 1
    varobj_ensure_python_env (var);
d2888 9
a2896 9
    if (value_formatter)
      {
	/* First check to see if we have any children at all.  If so,
	   we simply return {...}.  */
	if (dynamic_varobj_has_child_method (var))
	  {
	    do_cleanups (old_chain);
	    return xstrdup ("{...}");
	  }
d2898 4
a2901 4
	if (PyObject_HasAttr (value_formatter, gdbpy_to_string_cst))
	  {
	    struct value *replacement;
	    PyObject *output = NULL;
d2903 3
a2905 3
	    output = apply_varobj_pretty_printer (value_formatter,
						  &replacement,
						  stb);
d2907 4
a2910 4
	    /* If we have string like output ...  */
	    if (output)
	      {
		make_cleanup_py_decref (output);
d2912 57
a2968 57
		/* If this is a lazy string, extract it.  For lazy
		   strings we always print as a string, so set
		   string_print.  */
		if (gdbpy_is_lazy_string (output))
		  {
		    gdbpy_extract_lazy_string (output, &str_addr, &type,
					       &len, &encoding);
		    make_cleanup (free_current_contents, &encoding);
		    string_print = 1;
		  }
		else
		  {
		    /* If it is a regular (non-lazy) string, extract
		       it and copy the contents into THEVALUE.  If the
		       hint says to print it as a string, set
		       string_print.  Otherwise just return the extracted
		       string as a value.  */

		    char *s = python_string_to_target_string (output);

		    if (s)
		      {
			char *hint;

			hint = gdbpy_get_display_hint (value_formatter);
			if (hint)
			  {
			    if (!strcmp (hint, "string"))
			      string_print = 1;
			    xfree (hint);
			  }

			len = strlen (s);
			thevalue = xmemdup (s, len + 1, len + 1);
			type = builtin_type (gdbarch)->builtin_char;
			xfree (s);

			if (!string_print)
			  {
			    do_cleanups (old_chain);
			    return thevalue;
			  }

			make_cleanup (xfree, thevalue);
		      }
		    else
		      gdbpy_print_stack ();
		  }
	      }
	    /* If the printer returned a replacement value, set VALUE
	       to REPLACEMENT.  If there is not a replacement value,
	       just use the value passed to this function.  */
	    if (replacement)
	      value = replacement;
	  }
      }
  }
@


1.206
log
@	* ada-lang.c (ada_read_renaming_var_value): Pass const
	pointer to expression string to parse_exp_1.
	(create_excep_cond_exprs): Likewise.
	* ax-gdb.c (agent_eval_command_one): Likewise.
	(maint_agent_printf_command): Likewise.
	Constify much of the string handling/parsing.
	* breakpoint.c (set_breakpoint_condition): Pass const
	pointer to expression string to parse_exp_1.
	(update_watchpoint): Likewise.
	(parse_cmd_to_aexpr): Constify string handling.
	Pass const pointer to parse_exp_1.
	(init_breakpoint_sal): Pass const pointer to parse_exp_1.
	(find_condition_and_thread): Likewise.
	Make TOK const.
	(watch_command_1): Make "arg" const.
	Constify string handling.
	Copy the expression string instead of changing the input
	string.
	(update_breakpoint_location): Pass const pointer to
	parse_exp_1.
	* eval.c (parse_and_eval_address): Make "exp" const.
	(parse_to_comma_and_eval): Make "expp" const.
	(parse_and_eval): Make "exp" const.
	* expression.h (parse_expression): Make argument const.
	(parse_exp_1): Make first argument const.
	* findcmd.c (parse_find_args): Treat "args" as const.
	* linespec.c (parse_linespec): Pass const pointer to
	linespec_expression_to_pc.
	(linespec_expression_to_pc): Make "exp_ptr" const.
	* parse.c (parse_exp_1): Make "stringptr" const.
	Make a copy of the expression to pass to parse_exp_in_context until
	this whole interface can be constified.
	(parse_expression): Make "string" const.
	* printcmd.c (ui_printf): Treat "arg" as const.
	Handle const strings.
	* tracepoint.c (validate_actionline): Pass const pointer to
	all calls to parse_exp_1.
	(encode_actions_1): Likewise.
	* value.h (parse_to_comma_and_eval): Make argument const.
	(parse_and_eval_address): Likewise.
	(parse_and_eval): Likewise.
	* varobj.c (varobj_create): Pass const pointer to parse_exp_1.
	(varobj_set_value): Likewise.
	* cli/cli-cmds.c (disassemble_command): Treat "arg" as const and
	constify string handling.
	Pass const pointers to parse_and_eval_address and
	parse_to_comman_and_eval.
	* cli/cli-utils.c (skip_to_space): Rename to ...
	(skip_to_space_const): ... this. Handle const strings.
	* cli/cli-utils.h (skip_to_space): Turn into macro which invokes
	skip_to_space_const.
	(skip_to_space_const): Declare.
	* common/format.c (parse_format_string): Make "arg" const.
	Handle const strings.
	* common/format.h (parse_format_string): Make "arg" const.
	* gdbserver/ax.c (ax_printf): Make "format" const.
	* python/python.c (gdbpy_parse_and_eval): Do not make a copy
	of the expression string.
@
text
@d1255 1
a1255 1
  gdb_assert (0 && "should never be called if Python is not enabled");
@


1.205
log
@Fix -Wpointer-sign around strings/encoding conversions.

Trimmed for brevity:

$ make WERROR_CFLAGS="-Wpointer-sign -Werror" c-lang.o expprint.o utils.o valprint.o varobj.o -k 2>&1 1>/dev/null
../../src/gdb/c-lang.c: In function parse_one_string:
../../src/gdb/c-lang.c:540:8: error: pointer targets in passing argument 3 of convert_between_encodings differ in signedness [-Werror=pointer-sign]
In file included from ../../src/gdb/c-lang.c:30:0:
../../src/gdb/charset.h:64:6: note: expected const gdb_byte * but argument is of type char *

../../src/gdb/expprint.c: In function print_subexp_standard:
../../src/gdb/expprint.c:205:2: error: pointer targets in passing argument 3 of current_language->la_printstr differ in signedness [-Werror=pointer-sign]
../../src/gdb/expprint.c:205:2: note: expected const gdb_byte * but argument is of type char *

cc1: all warnings being treated as errors
make: *** [expprint.o] Error 1
../../src/gdb/utils.c: In function host_char_to_target:
../../src/gdb/utils.c:1474:9: error: pointer targets in passing argument 3 of convert_between_encodings differ in signedness [-Werror=pointer-sign]

../../src/gdb/varobj.c: In function value_get_print_value:
../../src/gdb/varobj.c:2934:8: error: pointer targets in return differ in signedness [-Werror=pointer-sign]
../../src/gdb/varobj.c:2968:12: error: pointer targets in assignment differ in signedness [-Werror=pointer-sign]
../../src/gdb/varobj.c:2971:3: error: pointer targets in return differ in signedness [-Werror=pointer-sign]
cc1: all warnings being treated as errors
make: *** [varobj.o] Error 1

As with the previous patch, the encoding conversion code works with
gdb_byte arrays as the generic buffers that hold strings of any
encoding/width.  This patch adds casts where appropriate.

gdb/
2013-03-07  Pedro Alves  <palves@@redhat.com>

	* c-lang.c (parse_one_string): Cast argument to gdb_byte *.
	* expprint.c (print_subexp_standard): Likewise.
	* utils.c (host_char_to_target): Likewise.
	* valprint.c (generic_emit_char, generic_printstr): Likewise.
	* varobj.c (value_get_print_value): Change type of local to char*.
	Cast it gdb_byte * in call to language printer.
@
text
@d623 1
a623 1
      char *p;
d1472 1
a1472 1
  char *s = expression;
@


1.204
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

	* charset.c (intermediate_encoding): Remove unused i.
	* completer.c (signal_completer): Remove unused i.
	* continuations.c (discard_my_continuations_1): Remove unused
	continuation_ptr.
	* corelow.c (core_close): Remove unuseD name.
	(get_core_siginfo): Remove unused pid.
	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Remove unused
	i, cps.
	* dwarf2loc.c (dwarf2_compile_expr_to_ax): Remove unused base_offset.
	(loclist_describe_location): Remove unused first.
	* event-top.c (command_line_handler): Remove unused got_eof.
	* exec.c (exec_close_1): Remove unused need_symtab_cleanup.
	(resize_section_table): Remove unused old_value.
	* gdb_bfd.c (gdb_bfd_map_section): Remove unused header.
	* gnu-v3-abi.c (compute_vtable_size): Remove unused addr.
	* i386-tdep.c (i386_process_record): Remove unused rex.
	* infcmd.c (get_return_value): Remove unused uiout.
	* jv-lang.c (type_from_class): Remove unused is_array.
	* jv-valprint.c (java_val_print): Remove unused i.
	* linux-nat.c (linux_nat_stop_lwp): Remove unused ptid.
	* linux-thread-db.c (thread_db_find_new_threads_2): Remove unuseD pid.
	* m2-typeprint.c (m2_print_type): Remove unused code.
	* macroexp.c (get_character_constant): Remove unused body_start.
	(macro_stringify): Remove unused result.
	* objc-lang.c (find_methods): Remove unused gdbarch.
	* objfiles.c (filter_overlapping_sections): Remove unused abfd1, abfd2.
	* regcache.c (regcache_cooked_read): Remove unused gdbarch.
	* stack.c (print_frame_args): Remove unused summary.
	* thread.c (thread_apply_command): Remove unused p.
	* valarith.c (value_x_unop): Remove unused mangle_ptr.
	* valops.c (search_struct_method): Remove unused skip.
	* valprint.c (generic_val_print): Remove unused byte_order.
	* varobj.c (varobj_update): Remove unused changed.
	* cli/cli-cmds.c (complete_command): Remove unused next_item.
	(alias_command): Remove unused c.
	* mi/mi-cmd-catch.c (mi_catch_load_unload): Remove unused c.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Remove unused
	format.
	(mi_cmd_data_write_memory): Remove unused word_format.
	(mi_cmd_data_write_memory_bytes): Remove unused r.
	* python/py-gdb-readline.c (gdbpy_readline_wrapper): Remove unused
	p_start, p_end.
	* python/python.c (_initialize_python): Remove unused cmd_name, cmd.
	* tui/tui-disasm.c (tui_set_disassem_content): Remove unused
	line_width.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00766.html
@
text
@d2847 1
a2847 1
  gdb_byte *thevalue = NULL;
d2959 1
a2959 1
    LA_PRINT_STRING (stb, type, thevalue, len, encoding, 0, &opts);
@


1.203
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a1971 1
  int changed = 0;
@


1.202
log
@Add support for Python 3.
* NEWS: Mention Python 3 support.
* varobj.c (value_get_print_value): Use
python_string_to_target_string.
* python/py-block.c: Use PyVarObject_HEAD_INIT in initialization
of type objects.
* python/py-breakpoint.c: Ditto.
* python/py-cmd.c:  Ditto.
* python/py-event.c: Ditto.
* python/py-event.h: Ditto.
* python/py-evtregistry.c: Ditto.
* python/py-finishbreakpoint.c: Ditto.
* python/py-frame.c: Ditto.
* python/py-function.c: Ditto.
* python/py-infthread.c: Ditto.
* python/py-lazy-string.c: Ditto.
* python/py-progspace.c: Ditto.
* /python/py-symbol.c: Ditto.
* python/py-evts.c:  (gdbpy_initialize_py_events): Add module
initialization for Python 3.
* python/py-inferior.c: Use PyVarObject_HEAD_INIT in initialization
of type objects.
(infpy_read_memory): Return memoryview object if Python 3.
(infpy_write_memory): Use "s*" operand parsing code for Python 3.
(infpy_search_memory): Ditto.
(get_buffer): New function for Python 3.
* python/py-objfile.c: Use PyVarObject_HEAD_INIT in initialization
of type objects.
(objfpy_dealloc): Use Py_TYPE to call tp_free.
* python/py-param.c: Use PyVarObject_HEAD_INIT in initialization
of type objects.
(get_attr): Use PyUnicode_CompareWithASCIIString if Python 3.
(set_attr): Ditto.
* python/py-prettyprint.c (print_string_repr): use PyBytes methods
instead of PyString methods if Python 3.
(print_children): Skip push_dummy_python_frame call if Python 3.
* python/py-symtab.c: Use PyVarObject_HEAD_INIT in initialization
of type objects.
(salpy_dealloc): Use Py_TYPE to call tp_free.
* python/py-type.c: Use PyVarObject_HEAD_INIT in initialization
of type objects.
(field_dealloc): Use Py_TYPE to call tp_free.
(typy_dealloc): Ditto.
(type_object_as_number): Adjust struct initializations for
differences in layout for Python 2 vs. Python 3.
* python/py-utils.c (python_string_to_unicode): Omit non-Unicode
string case for Python 3.
(unicode_to_encoded_python_string): Shorten code (no functional
change).
(python_string_to_target_python_string): Comment that in Python 3
returned value is a Python "bytes" type.
(gdbpy_is_string): Omit non-Unicode string check in Python 3.
(gdb_py_object_from_longest): Omit non-long integer case in Python
3.
(gdb_py_object_from_ulongest): Ditto.
* python/py-value.c: Use PyVarObject_HEAD_INIT in initialization
of type objects.
(valpy_dealloc): Use Py_TYPE to call tp_free.
(valpy_int): Omit function if Python 3.
(convert_value_from_python): Use "%S" format (Python object as a
string) if Python 3.
(value_object_as_number): Adjust struct initializations for
differences in layout for Python 2 vs. Python 3.
* python/python-config.py: Adjust syntax for Python 3
compatibility.
Include "sys.abiflags" string as part of python library name, if
that attribute exists (Python 3).
* python/python-internal.h (IS_PY3): Define if Python 3.
(Py_TPFLAGS_HAVE_ITER, Py_TPFLAGS_CHECKTYPES): Define with
placeholder value if Python 3.
(PyInt_Check, PyInt_FromLong, PyInt_AsLong, PyString_FromString,
PyString_Decode, PyString_FromFormat, PyString_Check): Define as
analogous Python 3 API function if Python 3.
(PyVarObject_HEAD_INIT): Define if not already defined.
(Py_TYPE): Ditto.
* python/python.c (eval_python_command): Omit Py_FlushLine call if
Python 3.
Check return values of all Python API calls for error.
Supply dummy "python" and "python-interactive" commands if Python
initialization failed.
(_initialize_python): Convert argc to wchar_t** if Python 3.
Add module initialization for Python 3.
(finish_python_initialization): Pass wchar_t * argument to
PySys_SetPath if Python 3.
* python/lib/gdb/__init__.py: Define "reload" if Python 3.
(_GdbFile): New class for common output file behavior.
(GdbOutFile): Subclass from _GdbFile.
(GdbOutputErrorFile): Ditto.
(auto_load_packages): Adjust syntax for Python 3 compatibility.
* python/lib/gdb/printing.py: Define basestr and int if Python 3.
* python/lib/gdb/prompt.py: Use sorted() function rather than
sort() method.
* python/lib/gdb/command/explore.py: Define raw_input if Python 3.
Adjust syntax for Python 3 compatibility.
* python/lib/gdb/command/pretty_printers.py: Use sorted() function
rather than sort() method.
Adjust syntax for Python 3 compatibility.
* python/lib/gdb/command/type_printers.py: Ditto.
* doc/gdb.texinfo (Inferior.read_memory): Mention that the return
value is a memoryview object if Python 3.
@
text
@d3 1
a3 1
   Copyright (C) 1999-2012 Free Software Foundation, Inc.
@


1.201
log
@	* ada-exp.y (write_object_renaming, write_var_or_type)
	(write_ambiguous_var, write_var_from_sym): Make blocks const.
	* ada-lang.c (replace_operator_with_call)
	(find_old_style_renaming_symbol): Make blocks const.
	* ada-lang.h (ada_find_renaming_symbol): Update.
	(struct ada_symbol_info) <block>: Now const.
	* breakpoint.c (watch_command_1): Update.
	* breakpoint.h (struct watchpoint) <exp_valid_block,
	cond_exp_valid_block>: Now const.
	* c-exp.y (classify_inner_name, classify_name): Make block
	argument const.
	* expprint.c (print_subexp_standard) <OP_VAR_VALUE>: Make 'b'
	const.
	* expression.h (innermost_block, parse_exp_1): Update.
	(union exp_element) <block>: Now const.
	* gdbtypes.c (lookup_template_type, lookup_enum, lookup_union)
	(lookup_struct): Make block argument const.
	* gdbtypes.h (lookup_template_type): Update.
	* go-exp.y (classify_name, classify_packaged_name)
	(package_name_p): Make block argument const.
	* objc-lang.c (lookup_struct_typedef): Make block argument const.
	* objc-lang.h (lookup_struct_typedef): Update.
	* parse.c (parse_exp_in_context, parse_exp_1)
	(write_exp_elt_block): Make block arguments const.
	(expression_context_block, innermost_block): Now const.
	* parser-defs.h (write_exp_elt_block): Update.
	(expression_context_block, innermost_block, block_found): Now
	const.
	* printcmd.c (struct display) <block>: Now const.
	* symtab.h (lookup_struct, lookup_union, lookup_enum): Update.
	* valops.c (address_of_variable): Make block argument const.
	* value.h (value_of_variable): Update.
	* varobj.c (struct varobj_root) <valid_block>: Now const.
@
text
@d2913 1
a2913 2
		    PyObject *py_str
		      = python_string_to_target_python_string (output);
d2915 1
a2915 1
		    if (py_str)
a2916 1
			char *s = PyString_AsString (py_str);
d2927 1
a2927 1
			len = PyString_Size (py_str);
d2930 1
a2930 1
			Py_DECREF (py_str);
@


1.200
log
@	PR python/14386:
	* varobj.c (update_dynamic_varobj_children): Don't call
	PyIter_Check.
gdb/testsuite
	* gdb.python/py-mi.exp: Add test for printer whose children
	are a list.
	* gdb.python/py-prettyprint.c (struct children_as_list): New.
	(main): New variable children_as_list.
	* gdb.python/py-prettyprint.py (class pp_children_as_list):
	New.
	(register_pretty_printers): Register new printer.
@
text
@d87 1
a87 1
  struct block *valid_block;
@


1.199
log
@gdb/
	* dwarf2loc.c (entry_values_debug): Add 'unsigned'.
	(_initialize_dwarf2loc): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* dwarf2loc.h: Update the declaration of 'entry_values_debug'.
	* dwarf2read.c (dwarf2_die_debug): Add 'unsigned'.
	(_initialize_dwarf2_read): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* darwin-nat.c (dwarwin_debug_flag): Add 'unsigned'.
	(_initialize_darwin_inferior): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* frame.c (frame_debug): Add 'unsigned'.
	(_intialize_frame): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* frame.h: Update the declaration of 'frame_debug'.
	* gdbtypes.c (overload_debug): Add 'unsigned'.
	(_initialize_gdbtypes): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* inferior.h: Update declaration of 'debug_infrun'.
	* infrun.c (debug_infrun): Add 'unsigned'.
	(_initialize_infrun): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* jit.c (jit_debug): Add 'unsigned'.
	(_initialize_jit): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* linux-nat.c (debug_linux_nat): Add 'unsigned'.
	(_initialize_linux_nat): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* linux-thread-db.c (libthread_db_debug): Add 'unsigned'.
	(_initialize_thread_db): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* machoread.c (mach_o_debug_level): Add 'unsigned'.
	(_initialize_machoread): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* mi/mi-cmd-var.c: Update the declaration of 'varobjdebug'.
	* microblaze-tdep.c (microblaze_debug_flag): Add 'unsigned'.
	(_initialize_microblaze_tdep): Call add_setshow_zuinteger_cmd
	intead of add_setshow_zinteger_cmd.
	* mips-tdep.c (mips_debug): Add 'unsigned'.
	(_initialize_mips_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* monitor.c (monitor_debug): Add 'unsigned'.
	(_initialize_remote_monitors): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* observer.c (observer_debug): Add 'unsigned'.
	(_initialize_observer): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* parse.c (expressiondebug): Add 'unsigned'.
	(_initialize_parse): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.c (record_debug): Add 'unsigned'.
	(_initialize_record): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.h: Update the declaration of 'record_debug'.
	* stap-probe.c (stap_expression_debug): Add 'unsigned'.
	(_initialize_stap_probe): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* serial.c (global_serial_debug_p): Add 'unsigned'.
	(_initialize_serial): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-dsbt.c (solib_dsbt_debug): Add 'unsigned'.
	(_initialize_dsbt_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-frv.c (solib_frv_debug): Add 'unsigned'.
	(_initialize_frv_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* target.c (targetdebug): Add 'unsigned'.
	(initialize_targets): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* valops.c (overload_debug): Add 'unsigned'.
	* varobj.c (varobjdebug): Add 'unsigned'.
	(_initialize_varobj): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* xtensa-tdep.c (xtensa_debug_level): Add 'unsigned'.
	(_initialize_xtensa_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.

	* arch-utils.h: Remove the declaration of 'gdbarch_debug'.
	* gdbarch.sh (gdbarch_debug): Add 'unsigned'.
	(extern void _initialize_gdbarch): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* gdbarch.c, gdbarch.h: Re-generated.
@
text
@a1116 3
      if (!PyIter_Check (children))
	error (_("Returned value is not iterable"));

@


1.198
log
@http://sourceware.org/ml/gdb-patches/2012-07/msg00551.html

Re-evaluate floating variables as part of variable invalidate to remove
references to type structures that might have been freed.
@
text
@d52 1
a52 1
int varobjdebug = 0;
d4179 7
a4185 7
  add_setshow_zinteger_cmd ("debugvarobj", class_maintenance,
			    &varobjdebug,
			    _("Set varobj debugging."),
			    _("Show varobj debugging."),
			    _("When non-zero, varobj debugging is enabled."),
			    NULL, show_varobjdebug,
			    &setlist, &showlist);
@


1.197
log
@	PR exp/13206:
	* ax-gdb.c (gen_expr) <OP_TYPEOF, OP_DECLTYPE>: New cases.
	* breakpoint.c (watchpoint_exp_is_const) <OP_TYPEOF,
	OP_DECLTYPE>: New cases.
	* c-exp.y (TYPEOF, DECLTYPE): New tokens.
	(type_exp): Add new productions.
	(ident_tokens): Add __typeof__, typeof, __typeof, __decltype,
	and decltype.
	* eval.c (evaluate_subexp_standard) <OP_TYPEOF, OP_DECLTYPE>:
	New case.
	* expprint.c (dump_subexp_body_standard) <OP_TYPEOF,
	OP_DECLTYPE>: New case.
	* parse.c (operator_length_standard) <OP_TYPEOF, OP_DECLTYPE>:
	New case.
	* std-operator.def (OP_TYPEOF, OP_DECLTYPE): New constants.
	* varobj.c (varobj_create): Handle OP_TYPEOF, OP_DECLTYPE.
gdb/testsuite
	* gdb.cp/casts.exp: Add tests for typeof and decltype.
	* gdb.cp/casts.cc (decltype): New function.
	(main): Use it.
@
text
@d4189 5
a4193 1
   defined on globals.  It is a helper for varobj_invalidate.  */
d4198 2
a4199 7
  /* Floating varobjs are reparsed on each stop, so we don't care if the
     presently parsed expression refers to something that's gone.  */
  if (var->root->floating)
    return;

  /* global var must be re-evaluated.  */     
  if (var->root->valid_block == NULL)
@


1.196
log
@	PR macros/7961:
	* varobj.c (varobj_create): Update.
	(varobj_set_value): Update.
	* tracepoint.c (validate_actionline): Update.
	(encode_actions_1): Update.
	* parse.c (parse_exp_1): Add 'pc' argument.
	(parse_exp_in_context): Add 'pc' argument.  Change how
	expression_context_pc is set.
	(parse_expression): Update.
	(parse_field_expression): Update.
	* expression.h (parse_exp_1): Update.
	* eval.c (parse_to_comma_and_eval): Update.
	* breakpoint.c (set_breakpoint_condition): Update.
	(update_watchpoint): Update.
	(init_breakpoint_sal): Update
	(find_condition_and_thread): Update.
	(watch_command_1): Update.
	(update_breakpoint_locations): Update.
	* ada-lang.c (ada_read_renaming_var_value): Update.
	(create_excep_cond_exprs): Update.
testsuite
	* gdb.base/macscp1.c (macscp_expr): Add breakpoint comment.
	* gdb.base/macscp.exp (maybe_kfail): Add test for macro scope.
@
text
@d678 3
a680 1
      if (var->root->exp->elts[0].opcode == OP_TYPE)
@


1.196.2.1
log
@	PR python/14386:
	* varobj.c (update_dynamic_varobj_children): Don't call
	PyIter_Check.
gdb/testsuite
	* gdb.python/py-mi.exp: Add test for printer whose children
	are a list.
	* gdb.python/py-prettyprint.c (struct children_as_list): New.
	(main): New variable children_as_list.
	* gdb.python/py-prettyprint.py (class pp_children_as_list):
	New.
	(register_pretty_printers): Register new printer.
@
text
@d1115 3
@


1.195
log
@gdb/doc/ChangeLog:

2012-04-14  Anton Gorenkov <xgsa@@yandex.ru>

	PR mi/13393
	* gdb.texinfo (Print Settings): Extend the description for "set print
	object".
	(GDB/MI Variable Objects): Extend the description for -var-create and
	-var-list-children.


gdb/testsuite/ChangeLog:

2012-04-14  Anton Gorenkov <xgsa@@yandex.ru>

	PR mi/13393
	* gdb.mi/mi-var-rtti.cc: New file.
	* gdb.mi/mi-var-rtti.exp: New file.
	* lib/mi-support.exp (mi_varobj_update_with_child_type_change): New
	function.
	(mi_varobj_update_with_type_change): updated to avoid code duplication.


gdb/ChangeLog:

2012-04-14  Anton Gorenkov <xgsa@@yandex.ru>

	PR mi/13393
	* value.c (value_actual_type): New function.
	* value.h (value_actual_type): New declaration.
	* varobj.c (update_type_if_necessary): New function.
	(varobj_create): Call value_actual_type instead of
	value_type.
	(install_dynamic_child): distinct changed and type changed MI variable
	objects.
	(update_dynamic_varobj_children): Updated for install_dynamic_child
	change.  All callers updated.
	(varobj_update): Support for MI variable object type change if
	the value changed and RTTI is used to determine the type.
	(create_child_with_value): Call value_actual_type instead of
	value_type.
	(adjust_value_for_child_access): Extended with a new parameter which
	specify whether the given value should be casted to enclosing type.
	All callers updated.
@
text
@d627 1
d654 1
d657 4
a660 1
	block = get_frame_block (fi, 0);
d668 1
a668 1
	  var->root->exp = parse_exp_1 (&p, block, 0);
d1479 1
a1479 1
  exp = parse_exp_1 (&s, 0, 0);
@


1.194
log
@New varobj language callback: value_is_changeable_p.

This patch introduces a new language-specific callback for varobj
objects, allowing us to move the language-specific bits of the
varobj_value_is_changeable_p routine to language-specific functions.
This is more elegant than testing for the varobj's language...

gdb/ChangeLog:

        * varobj.c (default_value_is_changeable_p): New function,
        extracted from varobj_value_is_changeable_p.  Add declaration.
        (ada_value_is_changeable_p): New function, extracted from
        varobj_value_is_changeable_p.  Add declaration.
        (struct language_specific): New field "value_is_changeable_p".
        (languages): Add entries for new field.
        (varobj_create): Set language before calling install_new_value.
        (varobj_value_is_changeable_p): Reimplement to call the varobj's
        "value_is_changeable_p" language callback.
@
text
@d273 3
d722 8
a729 2
      else 
	var->type = value_type (value);
d1017 1
d1040 6
d1048 1
a1048 1
	  if (changed)
d1051 1
a1051 1
      else if (unchanged)
d1074 1
d1210 1
d1266 1
a1266 1
	  update_dynamic_varobj_children (var, NULL, NULL, NULL, &dummy,
d1292 2
a1293 2
      update_dynamic_varobj_children (var, NULL, NULL, NULL, &children_changed,
				      0, 0, *to);
d1640 37
d2006 2
a2008 1

d2049 2
d2080 2
a2081 1
	  VEC (varobj_p) *changed = 0, *new = 0, *unchanged = 0;
d2099 1
a2099 1
		  update_dynamic_varobj_children (v, NULL, NULL, NULL,
d2113 2
a2114 2
	  if (update_dynamic_varobj_children (v, &changed, &new, &unchanged,
					      &children_changed, 1,
d2126 12
d2164 2
a2165 2
	      /* Free CHANGED and UNCHANGED, but not NEW, because NEW
		 has been put into the result vector.  */
d2167 1
d2442 1
a2442 1
    child->type = value_type (value);
d3023 4
d3038 2
a3039 1
				  int *was_ptr)
d3084 14
d3138 1
a3138 1
  adjust_value_for_child_access (NULL, &type, NULL);
d3254 1
a3254 1
  adjust_value_for_child_access (&value, &type, &was_ptr);
d3550 1
d3553 2
d3559 2
d3564 9
a3572 1
      adjust_value_for_child_access (NULL, &type, NULL);
d3599 11
a3609 1
      adjust_value_for_child_access (NULL, &type, NULL);
d3691 1
d3693 2
d3705 10
a3714 16
  if (CPLUS_FAKE_CHILD (parent))
    {
      value = parent->parent->value;
      type = get_value_type (parent->parent);
      if (cfull_expression)
	parent_expression
	  = varobj_get_path_expr (get_path_expr_parent (parent->parent));
    }
  else
    {
      value = parent->value;
      type = get_value_type (parent);
      if (cfull_expression)
	parent_expression
	  = varobj_get_path_expr (get_path_expr_parent (parent));
    }
d3716 1
a3716 1
  adjust_value_for_child_access (&value, &type, &was_ptr);
@


1.193
log
@Varobj support for Ada.

This patch adds varobj support for Ada variables.  Most of the code
is implemented in a separate Ada-specific file called ada-varobj.c.
The only bits in varobj.c are the functions used as the hooks in
the language-specific varobj's vector.

gdb/ChangeLog:

        * ada-varobj.h, ada-varobj.c: New files.
        * Makefile.in (SFILES): Add ada-varobj.c.
        (HFILES_NO_SRCDIR): Add ada-varobj.h.
        (COMMON_OBS): Add ada-varobj.o.
@
text
@d309 2
d389 2
d428 10
d467 1
d481 1
d495 1
d509 1
d522 1
a721 2
      install_new_value (var, value, 1 /* Initial assignment */);

d726 2
d2927 1
a2927 6
/* Return non-zero if changes in value of VAR
   must be detected and reported by -var-update.
   Return zero is -var-update should never report
   changes of such values.  This makes sense for structures
   (since the changes in children values will be reported separately),
   or for artifical objects (like 'public' pseudo-field in C++).
a2928 2
   Return value of 0 means that gdb need not call value_fetch_lazy
   for the value of this variable object.  */
d2932 1
a2932 44
  int r;
  struct type *type;

  if (CPLUS_FAKE_CHILD (var))
    return 0;

  /* FIXME: This, and the check above, show that this routine
     should be language-specific.  */
  if (variable_language (var) == vlang_ada)
    {
      struct type *type = var->value ? value_type (var->value) : var->type;

      if (ada_is_array_descriptor_type (type)
	  && TYPE_CODE (type) == TYPE_CODE_TYPEDEF)
	{
	  /* This is in reality a pointer to an unconstrained array.
	     its value is changeable.  */
	  return 1;
	}

      if (ada_is_string_type (type))
	{
	  /* We display the contents of the string in the array's
	     "value" field.  The contents can change, so consider
	     that the array is changeable.  */
	  return 1;
	}
    }

  type = get_value_type (var);

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
    case TYPE_CODE_ARRAY:
      r = 0;
      break;

    default:
      r = 1;
    }

  return r;
d3009 29
d3039 1
d3969 26
@


1.192
log
@framework for varobj type mutation

This patch introduces the framework necessary to support type mutations.
The only language that currently provides a language-specific hook for
that feature is Ada, but the hook remain unimplemented for now. The
actual implementation is tied to the rest of the varobj code for Ada,
and thus will be provided then.

gdb/ChangeLog:

        * varobj.c (ada_value_has_mutated): Add declaration.  New function.
        (struct language_specific): New field "value_has_mutated".
        (languages): Set field "value_has_mutated" in each entry of array.
        (varobj_value_has_mutated): New function.
        (varobj_udpdate): Add handling of type mutation.
        (value_of_root): Add handling of type mutation.
        (ada_value_has_mutated): New function.
@
text
@d36 2
d2926 23
d3909 1
a3909 1
  return c_number_of_children (var);
d3921 2
a3922 1
  return c_name_of_child (parent, index);
d3928 8
a3935 1
  return c_path_expr_of_child (child);
d3947 2
a3948 1
  return c_value_of_child (parent, index);
d3954 2
a3955 1
  return c_type_of_child (parent, index);
d3961 7
a3967 1
  return c_value_of_variable (var, format);
d3976 30
a4005 1
  /* Unimplemented for now.  */
@


1.191
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* amd64-linux-tdep.c (amd64_linux_record_signal): Make static.
	* breakpoint.c (create_exception_master_breakpoint, trace_command)
	(ftrace_command, strace_command): Make static.
	* d-lang.c (_initialize_d_language): Declare.
	* dwarf2expr.c (_initialize_dwarf2expr): Declare.
	* dwarf2loc.c (_initialize_dwarf2loc):
	* dwarf2read.c (process_psymtab_comp_unit): Make static.
	* exec.c (exec_get_section_table): Make static.
	* i386-linux-tdep.c (i386_linux_record_signal): Make static.
	* infcmd.c (ensure_valid_thread, ensure_not_tfind_mode): Make static.
	* inferior.c (remove_inferior_command, add_inferior_command)
	(clone_inferior_command): Make static.
	* linux-nat.c (linux_nat_thread_address_space)
	(linux_nat_core_of_thread): Make static.
	* linux-tdep.c (_initialize_linux_tdep): Declare.
	* objc-lang.c (_initialize_objc_lang): Declare.
	* opencl-lang.c (builtin_opencl_type, opencl_language_arch_info):
	Make static.
	(_initialize_opencl_language): Declare.
	* record.c (_initialize_record): Declare.
	* remote.c (demand_private_info, remote_get_tib_address)
	(remote_supports_cond_tracepoints)
	(remote_supports_fast_tracepoints, remote_get_tracepoint_status):
	Make static.
	* skip.c (_initialize_step_skip): Declare.
	* symtab.c (skip_prologue_using_lineinfo): Make static.
	* tracepoint.c (delete_trace_state_variable)
	(trace_variable_command, delete_trace_variable_command)
	(get_uploaded_tsv, find_matching_tracepoint_location)
	(find_matching_tsv, create_tsv_from_upload, get_traceframe_info):
	Make static.
	* value.c (pack_unsigned_long): Make static.
	* varobj.c (varobj_ensure_python_env): Make static.
	* windows-tdep.c (_initialize_windows_tdep): Declare.
	* xml-syscall.c (make_cleanup_free_syscalls_info): Make static.
@
text
@d385 3
d421 15
d450 2
a451 1
   c_value_of_variable}
d463 2
a464 1
   c_value_of_variable}
d476 2
a477 1
   cplus_value_of_variable}
d489 2
a490 1
   java_value_of_variable},
d501 2
a502 1
   ada_value_of_variable}
d1850 24
d1968 3
a1970 1
	{	  
d1972 18
a1989 1
	  if (install_new_value (v, new, 0 /* type not changed */))
d2696 22
a2717 1
  return (*var->root->lang->value_of_root) (var_handle);
d3929 10
@


1.190
log
@remove dead code in varobj.c:c_value_of_variable

gdb/ChangeLog:

        * varobj.c (c_value_of_variable): Remove dead code.
@
text
@d518 1
a518 1
struct cleanup *
@


1.189
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@a3290 5
  /* If we have a custom formatter, return whatever string it has
     produced.  */
  if (var->pretty_printer && var->print_value)
    return xstrdup (var->print_value);
  
@


1.188
log
@	PR mi/10586
	* varobj.c (ANONYMOUS_STRUCT_NAME): Define.
	(ANONYMOUS_UNION_NAME): Define.
	(is_path_expr_parent): New function.
	(get_path_expr_parent): New function.
	(is_anonymous_child): New function.
	(create_child_with_value): If the child is anonymous and without
	a name, assign an object name to it.
	(c_describe_child): Use get_path_expr_parent to determine
	the parent expression.
	If there field represents an anonymous struct or union and
	has no name, set an appropriate display name and expression.
	(cplus_describe_child): Likewise.
@
text
@d3089 1
a3089 1
	char *field_name;
d3518 1
a3518 1
	  char *field_name;
@


1.187
log
@	* gdbtypes.c (safe_parse_type): Initialize type to keep gcc happy.
	* varobj.c (varobj_set_value): Initialize val,value to keep gcc happy.
@
text
@d44 4
d1305 33
d2240 14
d2269 5
a2273 1
  childs_name = xstrprintf ("%s.%s", parent->obj_name, name);
d2275 1
d3050 1
a3050 1
      parent_expression = varobj_get_path_expr (parent);
d3088 16
a3103 2
      if (cname)
	*cname = xstrdup (TYPE_FIELD_NAME (type, index));
d3105 7
a3111 5
      if (cvalue && value)
	{
	  /* For C, varobj index is the same as type index.  */
	  *cvalue = value_struct_element_index (value, index);
	}
d3113 3
a3115 2
      if (ctype)
	*ctype = TYPE_FIELD_TYPE (type, index);
d3117 4
a3120 3
      if (cfull_expression)
	{
	  char *join = was_ptr ? "->" : ".";
d3122 5
a3126 3
	  *cfull_expression = xstrprintf ("(%s)%s%s", parent_expression, join,
					  TYPE_FIELD_NAME (type, index));
	}
d3128 3
d3487 2
a3488 1
	parent_expression = varobj_get_path_expr (parent->parent);
d3495 2
a3496 1
	parent_expression = varobj_get_path_expr (parent);
d3518 1
d3537 28
a3564 2
	  if (cname)
	    *cname = xstrdup (TYPE_FIELD_NAME (type, type_index));
a3570 6

	  if (cfull_expression)
	    *cfull_expression
	      = xstrprintf ("((%s)%s%s)", parent_expression,
			    join, 
			    TYPE_FIELD_NAME (type, type_index));
@


1.186
log
@	* Makefile.in (SFILES): Remove wrapper.c.
	(HFILES_NO_SRCDIR): Remove wrapper.h.
	(COMMON_OBS): Remove wrapper.o.
	* cli/cli-interp.c: Don't inlude wrapper.h.
	* corelow.c: Likewise.
	(core_open): Replace gdb_target_find_new_threads with
	TRY_CATCH around target_find_new_threads.
	* eval.c (fetch_subexp_value): Likewise for value_fetch_lazy.
	* gdbtypes.c (safe_parse_type): Likewise for parse_and_eval_type.
	* varobj.c (varobj_create): Likewise for parse_exp_1 and
	evaluate_expression.
	(varobj_set_value): Likewise for evaluate_expression and
	value_assign.
	(install_new_variable): Likewise for value_fetch_lazy.
	(adjust_value_for_child_access): Likewise for value_ind.
	(c_describe_child): Likewise for value_subscript and
	value_ind.
	(c_value_of_root): Likewise for evaluate_expression.
	* wrapper.c: Remove.
	* wrapper.h: Remove.
@
text
@d1362 1
a1362 2
  struct value *val;

d1367 1
a1367 1
  struct value *value;
@


1.185
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a23 1
#include "wrapper.h"
d575 1
d610 6
a615 1
      if (!gdb_parse_exp_1 (&p, block, 0, &var->root->exp))
d658 6
a663 1
      if (!gdb_evaluate_expression (var->root->exp, &value))
d1371 1
d1377 6
a1382 1
  if (!gdb_evaluate_expression (exp, &value))
d1404 8
a1411 5
  /* The new value may be lazy.  gdb_value_assign, or 
     rather value_contents, will take care of this.
     If fetching of the new value will fail, gdb_value_assign
     with catch the exception.  */
  if (!gdb_value_assign (var->value, value, &val))
d1413 1
a1413 1
     
d1616 1
a1616 1
      else if (!gdb_value_fetch_lazy (value))
d1618 14
a1631 4
	  /* Set the value to NULL, so that for the next -var-update,
	     we don't try to compare the new value with this value,
	     that we couldn't even read.  */
	  value = NULL;
d2852 1
a2852 1
	      int success = gdb_value_ind (*value, value);
d2854 6
a2859 1
	      if (!success)
d2984 1
d3012 4
a3015 1
	  gdb_value_subscript (value, real_index, cvalue);
d3061 4
a3064 1
	  int success = gdb_value_ind (value, cvalue);
d3066 1
a3066 1
	  if (!success)
d3170 2
d3174 5
a3178 1
      gdb_evaluate_expression (var->root->exp, &new_val);
@


1.184
log
@varobj.c:varobj_update minor reformatting

gdb/ChangeLog:

        * varobj.c (varobj_update): Minor reformatting, putting the function
        name at the start of the next line.
@
text
@d3 1
a3 2
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011 Free Software Foundation, Inc.
@


1.183
log
@	PR python/12533:
	* value.h (release_value_or_incref): Declare.
	* value.c (struct value) <released>: New field.
	(free_all_values, release_value, value_release_to_mark): Update
	'released'.
	(release_value_or_incref): New function.
	* python/py-value.c (valpy_new): Use release_value_or_incref.
	(value_to_value_object): Likewise.
	* varobj.c (install_new_value): Move value_incref earlier.
@
text
@d1778 2
a1779 1
VEC(varobj_update_result) *varobj_update (struct varobj **varp, int explicit)
@


1.182
log
@2011-08-26  Marc Khouzam  <marc.khouzam@@ericsson.com>

	PR mi/11912
	* varobj.c (cplus_describe_child): Add the keyword
	'class' to the output of the method when dealing
	with a cast to a base class.

2011-08-26  Marc Khouzam  <marc.khouzam@@ericsson.com>

	PR mi/11912
	* gdb.mi/mi-inheritance-syntax-error.cc: New file.
	* gdb.mi/mi-inheritance-syntax-error.exp: New file.
	* gdb.mi/mi-var-cp.cc: Updated for new 'class'
	keyword in output of -var-info-path-expression.
@
text
@d1607 4
a1677 2
  if (value != NULL)
    value_incref (value);
@


1.182.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 1999-2012 Free Software Foundation, Inc.
@


1.181
log
@2011-07-28  Phil Muldoon  <pmuldoon@@redhat.com>

	* varobj.c (value_get_print_value): Move hint check later into the
	function.  Comment function.  Free thevalue before reusing it.

2011-07-28  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.python/py-mi.exp: Test printers returning string hint, and
	also not returning a value.
	* gdb.python/py-prettyprint.c: Add testcase for above.
	* gdb.python/py-prettyprint.py: Add test printer for above.
@
text
@d3446 8
a3453 2
		 construct.  */
	      *cfull_expression = xstrprintf ("(%s(%s%s) %s)", 
@


1.180
log
@gdb/

	* varobj.h (varobj_languages): Add vlang_ada definition to the list
	of supported languages.
	* varobj.c: Add top definitions and basic implementation of the
	following callbacks: ada_number_of_children, ada_name_of_variable,
	ada_name_of_child, ada_path_expr_of_child, ada_value_of_root,
	ada_value_of_child, ada_type_of_child, ada_value_of_variable.
	(languages): Register Ada-specific callbacks.
	(variable_language): Add the Ada case in the language setter switch.
@
text
@a2612 1
	    char *hint;
a2615 8
	    hint = gdbpy_get_display_hint (value_formatter);
	    if (hint)
	      {
		if (!strcmp (hint, "string"))
		  string_print = 1;
		xfree (hint);
	      }

d2619 2
d2625 3
d2637 6
d2649 9
d2676 3
d2689 2
d2694 2
d2698 1
d2700 1
@


1.179
log
@	* varobj.c (varobj_create): Call do_cleanups on early exit path.
	* valops.c (find_overload_match): Call do_cleanups on early exit
	path.
	* solib.c (solib_find): Call do_cleanups on early exit path.
@
text
@d364 19
d466 12
a477 1
   java_value_of_variable}
d2435 3
d3621 50
@


1.178
log
@	* varobj.c (update_dynamic_varobj_children): Make 'name' const.
	* symtab.h (lookup_struct, lookup_union, lookup_enum): Update.
	* python/python.c (gdbpy_parameter): Make 'arg' const.
	(execute_gdb_command): Likewise.
	(gdbpy_decode_line): Likewise.  Copy it.
	(gdbpy_parse_and_eval): Make 'expr_string' const.  Copy it.
	(gdbpy_write): Make 'arg' const.
	* python/py-type.c (typy_lookup_typename): Make 'type_name'
	const.
	(gdbpy_lookup_type): Likewise.
	* python/py-prettyprint.c (print_children): Make 'name' const.
	* python/py-param.c (parmpy_init): Make 'name' const.  Copy it.
	* python/py-inferior.c (infpy_write_memory): Make 'buf_len' a
	Py_ssize_t.
	* python/py-function.c (fnpy_init): Make 'name' const.
	* python/py-cmd.c (cmdpy_init): Make 'name' const.  Copy it.
	(gdbpy_string_to_argv): Make 'input' const.
	* python/py-breakpoint.c (bppy_init): Make 'spec' const.  Copy
	it.
	* gdbtypes.h (lookup_typename): Update.
	* gdbtypes.c (lookup_typename): Make 'name' const.
	(lookup_struct): Likewise.
	(lookup_union): Likewise.
	(lookup_enum): Likewise.
@
text
@d583 1
@


1.177
log
@2011-04-29  Phil Muldoon  <pmuldoon@@redhat.com>

	PR mi/12531

	* varobj.c (install_default_visualizer): Do not install a
	visualizer if the varobj is CPLUS_FAKE_CHILD.
	(construct_visualizer): Likewise.

2011-04-29  Phil Muldoon  <pmuldoon@@redhat.com>

	PR mi/12531

	* gdb.python/py-mi.exp: Add CPLUS_FAKE_CHILD tests and a C++
	compile target.
	* gdb.python/py-prettyprint.exp: Add C++ object for
	CPLUS_FAKE_CHILD test.
@
text
@d1088 1
a1088 1
	  char *name;
@


1.176
log
@gdb
	* varobj.c (update_dynamic_varobj_children): Properly handle
	errors from iterator.
gdb/testsuite
	* gdb.python/py-prettyprint.py (exception_flag): New global.
	(NoStringContainerPrinter._iterator.next): Check it.
	* gdb.python/py-prettyprint.c (main): New variable nstype2.
	* gdb.python/py-mi.exp: Set exception_flag and do more tests.
@
text
@d1400 4
d1436 4
@


1.176.2.1
log
@2011-04-29  Phil Muldoon  <pmuldoon@@redhat.com>

	PR mi/12531

	* varobj.c (install_default_visualizer): Do not install a
	visualizer if the varobj is CPLUS_FAKE_CHILD.
	(construct_visualizer): Likewise.

2011-04-29  Phil Muldoon  <pmuldoon@@redhat.com>

	PR mi/12531

	* gdb.python/py-mi.exp: Add CPLUS_FAKE_CHILD tests and a C++
	compile target.
	* gdb.python/py-prettyprint.exp: Add C++ object for
	CPLUS_FAKE_CHILD test.
@
text
@a1399 4
  /* Do not install a visualizer on a CPLUS_FAKE_CHILD.  */
  if (CPLUS_FAKE_CHILD (var))
    return;

a1431 4
  /* Do not install a visualizer on a CPLUS_FAKE_CHILD.  */
  if (CPLUS_FAKE_CHILD (var))
    return;

@


1.176.2.2
log
@2011-08-26  Marc Khouzam  <marc.khouzam@@ericsson.com>

	PR mi/11912
	* varobj.c (cplus_describe_child): Add the keyword
	'class' to the output of the method when dealing
	with a cast to a base class.

2011-08-26  Marc Khouzam  <marc.khouzam@@ericsson.com>

	PR mi/11912
	* gdb.mi/mi-inheritance-syntax-error.cc: New file.
	* gdb.mi/mi-inheritance-syntax-error.exp: New file.
	* gdb.mi/mi-var-cp.cc: Updated for new 'class'
	keyword in output of -var-info-path-expression.
@
text
@d3392 2
a3393 8
		 construct.

		 When we are in the scope of the base class or of one
		 of its children, the type field name will be interpreted
		 as a constructor, if it exists.  Therefore, we must
		 indicate that the name is a class name by using the
		 'class' keyword.  See PR mi/11912  */
	      *cfull_expression = xstrprintf ("(%s(class %s%s) %s)", 
@


1.175
log
@	* varobj.c (instantiate_pretty_printer): Remove duplicate
	'return'.
@
text
@d1029 1
d1041 42
a1082 1
	break;
d1096 4
a1099 1
	    error (_("Invalid item from the child list"));
d1119 3
@


1.174
log
@	Fix formatting of function declarations returning a pointer in
	previous commit.
	* varobj.c (varobj_add_child): Ditto.
	* hppa-tdep.h (hppa_init_objfile_priv_data): Ditto.
	* inferior.h (get_displaced_step_closure_by_addr): Ditto.
@
text
@a787 1
  return NULL;
@


1.173
log
@	Fix ARI warning about function names in first column.
	Put prototype declaration on same line as return type.
	* objc-exp.y: Ditto.
	* p-exp.y: Ditto.
	* python/py-stopevent.h: Ditto.
	For long function names, split parameters to allow function name
	on same line as return type.
	* solib-pa64.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	For long function declaration, use single line.
	* hppa-tdep.h: Ditto.
	* inferior.h: Ditto.
@
text
@d299 3
a301 3
static struct varobj * varobj_add_child (struct varobj *var,
					 const char *name,
					 struct value *value);
@


1.172
log
@2011-03-05  Michael Snyder  <msnyder@@vmware.com>

	* dwarf2expr.c (execute_stack_op): Delete superfluous semicolon.
	* mdebugread.c (parse_symbol): Ditto.
	* parse.c (parse_exp_in_context): Ditto.
	* source.c (add_path): Ditto.
	* utils.c (gnu_debuglink_crc32): Ditto.
	* varobj.c (variable_language): Ditto.
@
text
@d299 3
a301 2
static struct varobj *
varobj_add_child (struct varobj *var, const char *name, struct value *value);
@


1.171
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d2361 1
a2361 1
  return (*var->root->lang->number_of_children) (var);;
@


1.170
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* ui-file.c: Comment cleanup, mostly periods and spaces.
	* ui-file.h: Ditto.
	* ui-out.c: Ditto.
	* ui-out.h: Ditto.
	* utils.c: Ditto.
	* v850-tdep.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* value.h: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vax-tdep.c: Ditto.
	* vec.c: Ditto.
	* vec.h: Ditto.
	* version.h: Ditto.
	* windows-nat.c: Ditto.
	* windows-tdep.c: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xml-support.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* xtensa-tdep.c: Ditto.
	* xtensa-tdep.h: Ditto.
@
text
@d1306 1
a1306 1
     should compare the pointer with the the array's address, not with the
@


1.169
log
@Remove trailing new-line at end of error string

gdb/ChangeLog:

	* linespec.c (decode_compound, find_method): Remove trailing \n
	at end of error string.
	* solib-irix.c (irix_current_sos): Likewise.
	* varobj.c (uninstall_variable): Likewise.
@
text
@d56 1
a56 1
/* String representations of gdb's format codes */
d60 1
a60 1
/* String representations of gdb's known languages */
d75 1
a75 1
   varobj. Members which must be free'd are noted. */
d79 1
a79 1
  /* Alloc'd expression for this parent. */
d82 1
a82 1
  /* Block for which this expression is valid */
d90 1
a90 1
     is only valid if valid_block is not NULL.  
d98 1
a98 1
     always updated in the specific scope/thread/frame  */
d105 1
a105 1
  /* Language info for this variable and its children */
d108 1
a108 1
  /* The varobj for this root node. */
d116 2
a117 2
   for it. This structure holds all information necessary to manipulate
   a particular object variable. Members which must be freed are noted. */
d121 1
a121 1
  /* Alloc'd name of the variable for this object.. If this variable is a
d123 2
a124 2
     (bar, not foo.bar) */
  /* NOTE: This is the "expression" */
d131 2
a132 2
  /* The alloc'd name for this variable's object. This is here for
     convenience when constructing this object's children. */
d135 1
a135 1
  /* Index of this variable in its parent or -1 */
d149 1
a149 1
  /* The number of (immediate) children this variable has */
d152 1
a152 1
  /* If this object is a child, this points to its immediate parent. */
d164 2
a165 1
  /* Description of the root variable. Points to root variable for children. */
d168 1
a168 1
  /* The format of the output for this object */
d171 1
a171 1
  /* Was this variable updated via a varobj_set_value operation */
d230 1
a230 1
/* Helper functions for the above subcommands. */
d272 1
a272 1
/* Language-specific routines. */
d368 1
a368 1
  /* The language of this variable */
d371 1
a371 1
  /* The number of children of PARENT. */
d374 1
a374 1
  /* The name (expression) of a root varobj. */
d377 1
a377 1
  /* The name of the INDEX'th child of PARENT. */
d384 1
a384 1
  /* The ``struct value *'' of the root variable ROOT. */
d387 1
a387 1
  /* The ``struct value *'' of the INDEX'th child of PARENT. */
d390 1
a390 1
  /* The type of the INDEX'th child of PARENT. */
d393 1
a393 1
  /* The current value of VAR. */
d398 1
a398 1
/* Array of known source language routines. */
d400 1
a400 1
  /* Unknown (try treating as C */
d449 1
a449 1
/* A little convenience enum for dealing with C++/Java */
d457 1
a457 1
/* Mappings of varobj_display_formats enums to gdb's format codes */
d460 1
a460 1
/* Header of the list of root variable objects */
d463 2
a464 2
/* Prime number indicating the number of buckets in the hash table */
/* A prime large enough to avoid too many colisions */
d467 1
a467 1
/* Pointer to the varobj hash table (built at run time) */
d470 1
a470 1
/* Is the variable X one of our "fake" children? */
d493 1
a493 1
/* Creates a varobj (not its children) */
d534 1
a534 1
  /* Fill out a varobj structure for the (root) variable being constructed. */
d552 1
a552 1
	  /* Allow creator to specify context of variable */
d568 1
a568 1
      /* frame = -2 means always use selected frame */
d579 1
a579 1
         return a sensible error. */
d585 1
a585 1
      /* Don't allow variables to be created for types. */
d603 1
a603 1
         Since select_frame is so benign, just call it for all cases. */
d621 1
a621 1
         But if it fails, we still go on with a call to evaluate_type()  */
d639 1
a639 1
      /* Set ourselves as our root */
d642 1
a642 1
      /* Reset the selected frame */
d648 1
a648 1
     is a temporary variable, so don't install it. */
d655 1
a655 1
         we must clenup */
d667 1
a667 1
/* Generates an unique name that can be used for a varobj */
d675 1
a675 1
  /* generate a name for this object */
d708 1
a708 1
/* Given the handle, return the name of the object */
d716 1
a716 1
/* Given the handle, return the expression represented by the object */
d727 1
a727 1
   (NULL terminated) */
d737 1
a737 1
  /* Initialize a stack for temporary results */
d741 1
a741 1
    /* Delete only the variable children */
d744 1
a744 1
    /* Delete the variable and all its children */
d747 1
a747 1
  /* We may have been asked to return a list of what has been deleted */
d792 1
a792 1
/* Set/Get variable object display format */
d859 1
a859 1
   is always positive.  Otherwise, returns -1. */
d1123 1
a1123 1
   the return code is the number of such children or -1 on error */
d1191 1
a1191 1
   prints on the console */
d1196 1
a1196 1
  /* For the "fake" variables, do not return a type. (It's type is
d1242 1
a1242 1
    /* FIXME: define masks for attributes */
d1268 2
a1269 2
   value of the given expression */
/* Note: Invokes functions that can call error() */
d1277 2
a1278 2
     We need to first construct a legal expression for this -- ugh! */
  /* Does this cover all the bases? */
d1286 1
a1286 1
  input_radix = 10;		/* ALWAYS reset to decimal temporarily */
d1290 1
a1290 1
      /* We cannot proceed without a valid expression. */
d1323 1
a1323 1
  var->updated = install_new_value (var, val, 0 /* Compare values. */);
d1441 6
a1446 6
   Otherwise, assign the new value, and return 1 if the value is different
   from the current one, 0 otherwise. The comparison is done on textual
   representation of value. Therefore, some types need not be compared. E.g.
   for structures the reported value is always "{...}", so no comparison is
   necessary here. If the old value was NULL and new one is not, or vice versa,
   we always return 1.
d1461 1
a1461 1
     don't have a type. */
d1466 1
a1466 1
     changeable. FIXME: need to make sure this behaviour will not
d1536 1
a1536 1
	 varobj had after the previous -var-update. So need to the
d1556 1
a1556 1
	    /* Equal. */
d1682 1
a1682 1
   result of implicit -var-update *. For implicit request, we don't
d1685 1
a1685 1
   NOTE: This function may delete the caller's varobj. If it
d1723 1
a1723 1
      /* Update the root variable. value_of_root can return NULL
d1725 1
a1725 1
	 the frame in which a local existed. We are letting the 
d1778 1
a1778 1
	 invoked.    */
d1907 1
a1907 1
/* Delete the variable object VAR and its children */
d1910 1
a1910 1
   initially called with remove_from_parent_p set */
d1918 1
a1918 1
  /* Delete any children of this variable, too. */
d1931 1
a1931 1
  /* if we were called to delete only the children we are done here */
d1935 1
a1935 1
  /* Otherwise, add it to the list of deleted ones and proceed to do so */
d1937 1
a1937 1
     yet been installed, don't report it, it belongs to the caller... */
d1944 1
a1944 1
  /* If this variable has a parent, remove it from its parent's list */
d1948 1
a1948 1
     discarding the list afterwards */
d1957 1
a1957 1
  /* Free memory associated with this variable */
d1961 1
a1961 1
/* Install the given variable VAR with the object name VAR->OBJ_NAME. */
d1983 1
a1983 1
  /* Add varobj to hash table */
d1989 1
a1989 1
  /* If root, add varobj to root list */
d1992 1
a1992 1
      /* Add to list of root variables */
d2003 1
a2003 1
/* Unistall the object VAR. */
d2015 1
a2015 1
  /* Remove varobj from hash table */
d2047 1
a2047 1
  /* If root, remove varobj from root list */
d2050 1
a2050 1
      /* Remove from list of root variables */
d2078 1
a2078 1
/* Create and install a child of the parent of the given name */
d2095 1
a2095 1
  /* name is allocated by name_of_child */
d2109 1
a2109 1
       will be non-NULL and contain a valid type. */
d2112 1
a2112 1
    /* Otherwise, we must compute the type. */
d2125 1
a2125 1
/* Allocate memory and initialize a new variable */
d2158 1
a2158 1
/* Allocate memory and initialize a new root variable */
d2176 1
a2176 1
/* Free any allocated memory associated with VAR. */
d2194 1
a2194 1
  /* Free the expression if this is a root variable. */
d2220 1
a2220 1
/* This returns the type of the variable. It also skips past typedefs
d2224 1
a2224 1
   except within get_target_type and get_type. */
d2239 1
a2239 1
   value were accessible.  
d2272 1
a2272 1
   except within get_target_type and get_type. */
d2287 1
a2287 1
   everything is "natural". Any exceptions? */
d2294 1
a2294 1
/* FIXME: The following should be generic for any pointer */
d2306 1
a2306 1
/* FIXME: The following should be generic for any pointer */
d2330 1
a2330 1
/* Get the language of variable VAR. */
d2355 1
a2355 1
   implementation. The number of children returned by this function
d2357 1
a2357 1
   display. */
d2365 1
a2365 1
   string. */
d2373 1
a2373 1
   string. */
d2400 1
a2400 1
     only get called with a root variable. */
d2457 1
a2457 1
/* What is the ``struct value *'' for the INDEX'th child of PARENT? */
d2468 1
a2468 1
/* GDB already has a command called "value_of_variable". Sigh. */
d2672 1
a2672 1
   structures.  
d2674 1
a2674 1
   Both TYPE and *TYPE should be non-null. VALUE
d2677 1
a2677 1
   value is not known.  
d2756 1
a2756 1
      /* The type here is a pointer to non-struct. Typically, pointers
d2763 1
a2763 1
         TYPE_NAME == "char" */
d2772 1
a2772 1
      /* Other types have no children */
d2787 1
a2787 1
   or union, or a typedef to struct/union.  
d2820 1
a2820 1
   object PARENT.  
d2929 1
a2929 1
      /* This should not happen */
d2934 1
a2934 1
      /* Don't set value and type, we don't know then. */
d2987 1
a2987 1
  /*  Only root variables can be updated... */
d2989 1
a2989 1
    /* Not a root var */
d2994 1
a2994 1
  /* Determine whether the variable is still around. */
d3059 1
a3059 1
  /* Strip top-level references. */
d3084 2
a3085 2
	       member when the parent is an invalid pointer. This is an
	       error condition, so we should tell the caller. */
d3100 1
a3100 1
	       we can reuse print_value */
d3140 1
a3140 1
	  /* Add any baseclasses */
d3144 1
a3144 1
	  /* FIXME: save children in var */
d3172 1
a3172 1
   how many are there, too. */
d3274 1
a3274 1
	     find the indexed field. */
d3330 1
a3330 1
	      /* Cast the parent to the base' type. Note that in gdb,
d3355 1
a3355 1
	     this order. So if INDEX == 2, it MUST be "protected". */
d3379 1
a3379 1
	      /* Must be protected */
d3383 1
a3383 1
	      /* error! */
d3447 1
a3447 1
     any value. */
d3469 1
a3469 1
     needed to escape periods in the name... */
d3488 1
a3488 1
  /* Escape any periods in the name... */
@


1.168
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d2063 2
a2064 2
	      warning ("Assertion failed: Could not find "
		       "varobj \"%s\" in root list",
@


1.167
log
@run copyright.sh for 2011.
@
text
@d724 3
a726 2
   otherwise deletes only the children; returns a malloc'ed list of all the 
   (malloc'ed) names of the variables that have been deleted (NULL terminated) */
d1459 2
a1460 2
     be fetched or not.  C++ fake children (public/protected/private) don't have
     a type. */
d1532 5
a1536 4
      /* If the value of the varobj was changed by -var-set-value, then the 
	 value in the varobj and in the target is the same.  However, that value
	 is different from the value that the varobj had after the previous
	 -var-update. So need to the varobj as changed.  */
d2063 3
a2065 3
	      warning
		("Assertion failed: Could not find varobj \"%s\" in root list",
		 var->obj_name);
d2163 1
a2163 1
  var->root = (struct varobj_root *) xmalloc (sizeof (struct varobj_root));;
d2363 2
a2364 1
/* What is the expression for the root varobj VAR? Returns a malloc'd string. */
d2371 2
a2372 1
/* What is the name of the INDEX'th child of VAR? Returns a malloc'd string. */
d2855 4
a2858 3
	*cname = xstrdup (int_string (index 
				      + TYPE_LOW_BOUND (TYPE_INDEX_TYPE (type)),
				      10, 1, 0, 0));
d3306 4
a3309 3
	    *cfull_expression = xstrprintf ("((%s)%s%s)", parent_expression,
					    join, 
					    TYPE_FIELD_NAME (type, type_index));
d3558 5
a3562 6
			    &varobjdebug, _("\
Set varobj debugging."), _("\
Show varobj debugging."), _("\
When non-zero, varobj debugging is enabled."),
			    NULL,
			    show_varobjdebug,
@


1.166
log
@	* breakpoint.h: No longer include python.h or python-internal.h.
	(struct breakpoint_object): Forward declare.
	* defs.h (PyObject) [!HAVE_PYTHON]: Don't define.
	* varobj.c (PyObject) [!HAVE_PYTHON]: Define.
	* python/py-breakpoint.c (build_bp_list): Cast py_bp_object to
	PyObject pointer.
	(gdbpy_breakpoint_created): Remove casts around py_bp_object
	accesses.
@
text
@d4 1
a4 1
   2009, 2010 Free Software Foundation, Inc.
@


1.165
log
@gdb
	* varobj.c (value_get_print_value): Rearrange.  Pass stream to
	apply_varobj_pretty_printer.
	* c-lang.c: Include exceptions.h.
	(c_get_string): Throw MEMORY_ERROR when appropriate.
	* python/py-prettyprint.c (enum string_repr_result): New.
	(print_stack_unless_memory_error): New function.
	(print_string_repr): Change return type.  Use
	print_stack_unless_memory_error.
	(print_children): Use print_stack_unless_memory_error.
	(apply_val_pretty_printer): Update.  Don't print children if
	string representation threw an exception.
	(apply_varobj_pretty_printer): Add 'stream' argument.  Use
	print_stack_unless_memory_error.
	* python/python.c (gdbpy_gdb_error, gdbpy_gdb_memory_error): New
	globals.
	(_initialize_python): Initialize them.
	* python/python-internal.h (GDB_PY_HANDLE_EXCEPTION): Use
	gdbpy_convert_exception.
	(GDB_PY_SET_HANDLE_EXCEPTION): Likewise.
	(gdbpy_gdb_error, gdbpy_gdb_memory_error): Declare.
	(gdbpy_convert_exception): Declare.
	(apply_varobj_pretty_printer): Update.
	* python/py-utils.c (gdbpy_convert_exception): New function.
gdb/doc
	* gdb.texinfo (Basic Python): Update.  Add xref.
	(Exception Handling): Document new exception classes.
	(Types In Python): Update.
	(Frames In Python): Update.
gdb/testsuite
	* gdb.python/py-prettyprint.c (main): Add new 'ns2' local.
	* gdb.python/py-prettyprint.exp (run_lang_tests): Add test for
	MemoryError.
	* gdb.python/python.exp (gdb_py_test_multiple): Update exception
	type.
	* gdb.python/py-value.exp (test_value_in_inferior): Add test for
	MemoryError.
	(test_subscript_regression): Update exception type.
@
text
@d42 2
@


1.164
log
@2010-11-11  Phil Muldoon  <pmuldoon@@redhat.com>

	* python/py-breakpoint.c (BPPY_REQUIRE_VALID): Check if bp is
	NULL.
	(BPPY_SET_REQUIRE_VALID): Ditto.
	(bpnum_is_valid): Delete function.
	(bppy_get_visibility): New function.
	(bppy_new): Parse for, and validate internal keyword.  Pass
	internal keyword to breakpoint or watchpoint functions.
	(build_bp_list): New function.
	(gdbpy_breakpoints): Rewrite.  Use build_bp_list and
	iterate_over_breakpoints.
	(gdbpy_breakpoint_created): Rewrite.  Do not store breakpoints in a
	look-aside vector.
	(gdbpy_breakpoint_deleted): Rewrite, defer breakpoint management
	to internal breakpoint chain.

	* breakpoint.c (set_breakpoint_number): New function.
	(breakpoint_1): Check if breakpoint number is more than zero.
	(set_raw_breakpoint_without_location): Set py_bp_object to NULL.
	(create_breakpoint_sal): Take a new parameter called internal.
	Call set_breakpoint_number with internal parameter.  Do not
	mention internal breakpoints.  All callers updated.
	(create_breakpoint): Ditto.
	(create_breakpoints_sal): Ditto.
	(watch_command_1): Ditto.
	(watch_command_wrapper): Take a new parameter called internal.
	All callers updated.
	(rwatch_command_wrapper): Ditto.
	(awatch_command_wrapper): Ditto.
	(save_breakpoints): Update breakpoint save condition check.
	(iterate_over_breakpoints): New function.
	* breakpoint.h: Add conditional python includes.  Add py_bp_object
	and comment to struct breakpoint.  Update all callers.
	* defs.h: Add PyObject definition for GDB builds without Python.

2010-11-11  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.texinfo (Breakpoints In Python): Document "internal"
	parameter, and visible attribute.


2010-11-11  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.python/py-breakpoint.exp: Add internal watchpoint and
	breakpoint tests.
@
text
@d2480 1
a2480 1
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
d2494 3
d2509 4
a2512 1
	  return xstrdup ("{...}");
d2529 2
a2530 1
						  &replacement);
a2574 3
  stb = mem_fileopen ();
  make_cleanup_ui_file_delete (stb);

@


1.163
log
@gdb/
	Fix GCC false warning.
	* varobj.c (value_get_print_value) <str_addr>: Initialize it.
@
text
@a41 2
#else
typedef int PyObject;
@


1.162
log
@	PR python/11948:
	* varobj.c (value_get_print_value): Use val_print_string to print
	lazy strings.
	* python/py-prettyprint.c (print_string_repr): Use
	val_print_string to print lazy strings.  Fix cleanup logic.
	(print_children): Likewise.
	* python/python-internal.h (gdbpy_extract_lazy_string): Update.
	* python/py-lazy-string.c (gdbpy_extract_lazy_string): Rewrite.
	Change return type to 'void', add 'addr' argument.
	* value.h (val_print_string): Update.
	* valprint.c (val_print_string): Add 'encoding' argument.
	* printcmd.c (print_formatted): Update.
	* p-valprint.c (pascal_val_print): Update.
	* m2-valprint.c (print_unpacked_pointer): Update.
	(m2_print_array_contents): Likewise.
	* jv-valprint.c (java_value_print): Update.
	* f-valprint.c (f_val_print): Update.
	* c-valprint.c (c_val_print): Update.
	* auxv.c (fprint_target_auxv): Update.
@
text
@d2489 2
a2490 1
  CORE_ADDR str_addr;
@


1.161
log
@gdb/
	* python/py-breakpoint.c (bppy_set_condition): New comment.
	* python/py-cmd.c (cmdpy_function): Call also gdbpy_print_stack for
	failed PyUnicode_Decode.
	(cmdpy_completer): Skip element for failed
	python_string_to_host_string.
	(cmdpy_init): Return -1 on failed python_string_to_host_string.
	* python/py-frame.c (frapy_read_var): Extend the function comment.
	* python/py-function.c (fnpy_init): Return -1 on failed
	python_string_to_host_string.
	* python/py-inferior.c (infpy_read_memory, infpy_write_memory): Extend
	the function comment.
	(infpy_search_memory): Extend the function comment.  Remove the
	PyErr_SetString call on already set error state.
	* python/py-param.c (set_parameter_value): Extend the function
	comment.  Return -1 on failed python_string_to_host_string, twice.
	(set_attr): Extend the function comment.
	(compute_enum_values): Extend the function comment.  New variable
	back_to.  Protect self->enumeration by BACK_TO cleanups.  Return 0 on
	failed python_string_to_host_string.
	(get_doc_string): Call gdbpy_print_stack on failed
	python_string_to_host_string.
	(parmpy_init): Extend the function comment.
	* python/py-prettyprint.c (pretty_print_one_value): Likewise.
	(gdbpy_get_display_hint, print_children): Call gdbpy_print_stack on
	failed python_string_to_host_string.
	* python/py-value.c (valpy_new, valpy_getitem, valpy_call)
	(valpy_binop, valpy_richcompare): Extend the function comment.
	* python/python.c
	(struct python_env) <error_type, error_value, error_traceback>: New
	fields.
	(restore_python_env): Handle PyErr_Occurred.  Call PyErr_Restore.
	(ensure_python_env): Call PyErr_Fetch.
	* varobj.c (update_dynamic_varobj_children): Call gdbpy_print_stack on
	failed convert_value_from_python.
	(value_get_print_value): Call gdbpy_print_stack on failed
	python_string_to_target_python_string.

gdb/testsuite/
	* gdb.python/py-error.exp: New file.
	* gdb.python/py-error.py: New file.
@
text
@d2482 1
a2482 1
  struct cleanup *old_chain;
d2489 2
a2497 1
    struct cleanup *back_to = varobj_ensure_python_env (var);
d2500 2
a2512 1
	    int string_print = 0;
d2527 2
d2531 3
a2533 2
		    thevalue = gdbpy_extract_lazy_string (output, &type,
							  &len, &encoding);
d2549 8
a2560 7
		Py_DECREF (output);
	      }
	    if (thevalue && !string_print)
	      {
		do_cleanups (back_to);
		xfree (encoding);
		return thevalue;
a2565 1
    do_cleanups (back_to);
d2570 1
a2570 1
  old_chain = make_cleanup_ui_file_delete (stb);
d2576 3
a2578 5
    {
      make_cleanup (xfree, thevalue);
      make_cleanup (xfree, encoding);
      LA_PRINT_STRING (stb, type, thevalue, len, encoding, 0, &opts);
    }
@


1.160
log
@gdb/
	* varobj.c (varobj_create): Replace variable old_fi with old_id,
	initialize it by null_frame_id, wrap its usage by get_frame_id,
	frame_id_p and frame_find_by_id.
@
text
@d1055 2
d2545 2
@


1.159
log
@gdb/
	Code cleanup.
	* varobj.c (varobj_create): Move variables fi, old_fi and block to
	a more inner block.
@
text
@d540 1
a540 1
      struct frame_info *old_fi = NULL;
d614 1
a614 1
	  old_fi = get_selected_frame (NULL);
d642 2
a643 2
      if (old_fi != NULL)
	select_frame (old_fi);
@


1.158
log
@2010-05-17  Michael Snyder  <msnyder@@vmware.com>

	* valarith.c: White space.
	* valops.c: White space.
	* valprint.c: White space.
	* value.c: White space.
	* varobj.c: White space.
	* xcoffread.c: White space.
	* xml-support.c: White space.
	* xml-tdesc.c: White space.
@
text
@a530 3
  struct frame_info *fi;
  struct frame_info *old_fi = NULL;
  struct block *block;
d539 3
@


1.157
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* ui-out.c (ui_out_field_int): Delete unused variable.
	(ui_out_field_fmt_int): Delete unused variable.
	* varobj.c (varobj_list_children): Delete unused variable.
	(varobj_set_value): Delete unused variable.
	(install_new_value_visualizer): Delete unused variable.
	(varobj_set_visualizer): Delete unused variable.
	(varobj_update): Delete unused variable.
	(varobj_editable_p): Delete unused variable.
	(c_value_of_root): Delete unused variable.
	(cplus_describe_child): Delete unused variable.
@
text
@d515 1
d626 1
d929 1
d939 1
d1075 1
d1179 1
d1495 1
d1704 1
d1714 1
d1746 1
d1825 1
d1834 1
d1838 1
d1863 1
d1868 1
d1917 1
d2158 1
d2224 1
a2225 1

d2420 1
d2533 1
d2537 1
d2694 2
a2695 1
	      int success = gdb_value_ind (*value, value);	  
d2778 1
a2779 1
  struct type *type = value_type (value);
d2846 1
d2880 1
d2894 1
d2924 1
d2951 1
d3014 1
a3015 1

d3023 1
d3055 1
d3248 1
d3310 1
d3329 1
d3385 1
d3408 1
d3417 1
d3423 2
a3424 1
cplus_value_of_variable (struct varobj *var, enum varobj_display_formats format)
@


1.156
log
@	PR mi/11098:
	* varobj.c (install_new_value): Handle case where new print_value
	is NULL.
@
text
@a1118 1
  struct varobj *child;
a1264 2
  int offset = 0;
  int error = 0;
a1272 1
  int i;
a1411 1
      PyObject *pretty_printer = NULL;
d1631 2
a1632 2
  PyObject *mainmod, *globals, *pretty_printer, *constructor;
  struct cleanup *back_to, *value;
a1681 4
  int vleft;
  struct varobj *v;
  struct varobj **cv;
  struct varobj **templist = NULL;
a1684 1
  struct frame_info *fi;
a2563 1
  struct value *value;
a2939 1
  struct frame_info *fi;
a3184 1
  char *name = NULL;
@


1.155
log
@2010-02-23  Harald Koenig  <H.Koenig@@science-computing.de>

	* varobj.c (varobj_update): Avoid non-constants in initializers.
@
text
@d1596 4
a1599 1
      if (!var->print_value || strcmp (var->print_value, print_value) != 0)
@


1.154
log
@gdb/
	* varobj.c (varobj_add_child, install_dynamic_child): Wrap into #if
	HAVE_PYTHON.
	(instantiate_pretty_printer): Move HAVE_PYTHON outside of the function.
@
text
@d1703 2
a1704 1
      varobj_update_result r = {*varp};
d1712 2
a1713 1
      varobj_update_result r = {*varp};
d1743 2
a1744 1
      varobj_update_result r = {*varp};
d1821 2
a1822 1
		  varobj_update_result r = {tmp};
d1832 2
a1833 1
	      	      varobj_update_result r = {tmp};
d1860 2
a1861 1
	      varobj_update_result r = {c};
@


1.154.2.1
log
@2010-02-23  Harald Koenig  <H.Koenig@@science-computing.de>

	* varobj.c (varobj_update): Avoid non-constants in initializers.
@
text
@d1703 1
a1703 2
      varobj_update_result r = {0};
      r.varobj = *varp;
d1711 1
a1711 2
      varobj_update_result r = {0};
      r.varobj = *varp;
d1741 1
a1741 2
      varobj_update_result r = {0};
      r.varobj = *varp;
d1818 1
a1818 2
		  varobj_update_result r = {0};
		  r.varobj = tmp;
d1828 1
a1828 2
	      	      varobj_update_result r = {0};
		      r.varobj = tmp;
d1855 1
a1855 2
	      varobj_update_result r = {0};
	      r.varobj = c;
@


1.154.2.2
log
@	PR mi/11098:
	* varobj.c (install_new_value): Handle case where new print_value
	is NULL.
@
text
@d1596 1
a1596 4
      if ((var->print_value == NULL && print_value != NULL)
	  || (var->print_value != NULL && print_value == NULL)
	  || (var->print_value != NULL && print_value != NULL
	      && strcmp (var->print_value, print_value) != 0))
@


1.153
log
@2010-01-13  Phil Muldoon  <pmuldoon@@redhat.com>

	PR python/10705

	* python/python-internal.h: Add lazy_string_object_type
	definition.
	(create_lazy_string_object, gdbpy_initialize_lazy_string)
	(gdbpy_is_lazystring, gdbpy_extract_lazy_string): Define.
	* python/py-value.c (valpy_lazy_string): New function.
	(convert_value_from_python): Add lazy string conversion.
	* python/py-prettyprint.c (pretty_print_one_value): Check if
	return is also a lazy string.
	(print_string_repr): Add lazy string printing branch.
	(print_children): Likewise.
	* python/py-lazy-string.c: New file. Implement lazy strings.
	* python/python.c (_initialize_python): Call
	gdbpy_initialize_lazy_string.
	* varobj.c (value_get_print_value): Add lazy string printing
	branch.  Account for encoding.
	* c-lang.c (c_printstr): Account for new encoding argument.  If
	encoding is NULL, find encoding suited for type, otherwise use
	user encoding.
	* language.h (language_defn): Add encoding argument.
	(LA_PRINT_STRING): Likewise.
	* language.c (unk_lang_printstr): Update to reflect new encoding
	argument to language_defn.
	* ada-lang.h (ada_printstr): Likewise.
	* c-lang.h (c_printstr): Likewise.
	* p-lang.h (pascal_printstr);
	* f-lang.c (f_printstr): Likewise.
	* m2-lang.c (m2_printstr): Likewise.
	* objc-lang.c (objc_printstr): Likewise.
	* p-lang.c (pascal_printstr): Likewise.
	* scm-lang.c (scm_printstr): Likewise.
	* c-valprint.c (c_val_print): Update LA_PRINT_STRING call for
	encoding argument.
	* ada-valprint.c (ada_printstr): Likewise.
	* f-valprint.c (f_val_print): Likewise
	* m2-valprint.c (m2_val_print): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	* expprint.c (print_subexp_standard): Likewise.
	* valprint.c (val_print_string): Likewise.
	* Makefile.in (SUBDIR_PYTHON_OBS): Add py-lazy-string.
	(SUBDIR_PYTHON_SRCS): Likewise.
	(py-lazy-string.o): New rule.

2010-01-13  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.texinfo (Values From Inferior): Document lazy_string value
	method.
	(Python API): Add Lazy strings menu item.
	(Lazy Strings In Python): New node.

2010-01-13  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.python/py-value.exp (test_lazy_strings): Add lazy string test.
	* gdb.python/py-prettyprint.py (pp_ls): New printer.
	* gdb.python/py-prettyprint.exp (run_lang_tests): Add lazy string
	test.
	* gdb.python/py-prettyprint.c: Define lazystring test structure.
	* gdb.python/py-mi.exp: Add lazy string test.
@
text
@d296 2
d301 2
d766 2
a772 1
#if HAVE_PYTHON
a782 1
#endif
d786 2
d908 2
a945 2
#if HAVE_PYTHON

d1167 2
d1179 2
@


1.152
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d2456 4
a2459 1
  int len = 0;
d2464 1
d2496 7
a2502 3
		PyObject *py_str
		  = python_string_to_target_python_string (output);
		if (py_str)
d2504 10
a2513 4
		    char *s = PyString_AsString (py_str);
		    len = PyString_Size (py_str);
		    thevalue = xmemdup (s, len + 1, len + 1);
		    Py_DECREF (py_str);
d2520 1
a2538 1
      struct gdbarch *gdbarch = get_type_arch (value_type (value));
d2540 2
a2541 2
      LA_PRINT_STRING (stb, builtin_type (gdbarch)->builtin_char,
		       thevalue, len, 0, &opts);
@


1.151
log
@* dwarf2read.c (struct attribute): Increase sizes of unsnd and snd
fields to allow larger integer sizes.
(read_subrange_type): Increase size of bound values.
Add logic to determine signedness based on base-type size, signedness.
(read_attribute_value): Change format for bad byte size in message.
(read_8_bytes): Increase size of result type.
(dump_die_shallow): Change format for value.
(dwarf2_get_attr_constant_value): Increase size of return type.
Correct comment.
* gdbtypes.c (create_range_type): Change API to increase size of
bounds. struct field -> union field.
Always take signedness from base type.
(check_typedef): Use new API for TYPE_LOW_BOUND, TYPE_HIGH_BOUND.
(recursive_dump_type, copy_type_recursive): Adjust to new
representation of range types.
* gdbtypes.h (fields_or_bounds): New union containing struct field and
new struct range_bounds, used for range types.
(TYPE_RANGE_DATA): New macro to access range_bounds member.
(TYPE_LOW_BOUND, TYPE_HIGH_BOUND): Represent with new TYPE_RANGE_DATA.
(TYPE_LOW_BOUND_UNDEFINED, TYPE_HIGH_BOUND_UNDEFINED): New macros,
taking over the job of TYPE_FIELD_ARTIFICIAL for range bounds.
(SET_TYPE_LOW_BOUND, SET_TYPE_HIGH_BOUND, SET_TYPE_LOW_BOUND_DEFINED)
(SET_TYPE_HIGH_BOUND_DEFINED): New macros.
(TYPE_FIELDS, TYPE_BASECLASS, TYPE_BASECLASS_NAME, TYPE_FIELD)
(TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED)
(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED, TYPE_ARRAY_UPPER_BOUND_VALUE)
(TYPE_ARRAY_LOWER_BOUND_VALUE):	Adjust to new representation.
(create_range_type): Adjust API.
* ada-lang.c (ada_modulus): Use new extended bound values.
(discrete_type_low_bound): Rename to...
(ada_discrete_type_low_bound): ... and make external.
(discrete_type_high_bound): Rename to...
(ada_discrete_type_high_bound): ... and make external.
(ada_value_slice_from_ptr, ada_array_bound_from_type)
(ada_evaluate_subexp, to_fixed_range_type):
Use ada_discrete_type_low_bound, ada_discrete_type_high_bound.
* ada-typeprint.c (print_range): Use ada_discrete_type_low_bound,
ada_discrete_type_high_bound.  Don't look at field count, which
is no longer meaningful.  Print bounds whenever argument is a range
or enumeration.
* ada-lang.h (ada_discrete_type_low_bound,ada_discrete_type_high_bound):
Declare.
* varobj.c (c_describe_child): Adjust to render larger values.
* mdebugread.c (parse_type): Use proper abstractions for range types:
TYPE_RANGE_DATA, SET_TYPE_LOW_BOUND_DEFINED,
SET_TYPE_HIGH_BOUND_DEFINED.
* p-typeprint.c (pascal_type_print_varspec_prefix): Use larger format
for bounds.
@
text
@d4 1
a4 1
   2009 Free Software Foundation, Inc.
@


1.150
log
@2009-11-12  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Paul Brook  <paul@@codesourcery.com>

	* c-typeprint.c (c_type_print_base): Skip artificial fields.
	Use get_vptr_fieldno to skip the vtable pointer.
	* dwarf2read.c (dwarf2_add_field): Set FIELD_ARTIFICIAL on artificial
	fields.
	(dwarf2_add_member_fn): Complain about virtual member functions
	without DW_AT_vtable_elem_location and force TYPE_CPLUS_DYNAMIC.
	* gdbtypes.c (get_vptr_fieldno): Update comment.
	* gdbtypes.h (struct cplus_struct_type): Add is_dynamic.
	(TYPE_CPLUS_DYNAMIC): New macro.
	* gnu-v3-abi.c (gnuv3_dynamic_class): New.
	(gnuv3_get_vtable): Rewrite to use gnuv3_dynamic_class.  Move higher.
	(gnuv3_rtti_type, gnuv3_get_virtual_fn, gnuv3_baseclass_offset): Use
	gnuv3_get_vtable.
	* varobj.c (cplus_class_num_children, cplus_describe_child): Skip
	artificial fields.  Use get_vptr_fieldno to skip the vtable pointer.
@
text
@d2796 3
a2798 2
	*cname = xstrprintf ("%d", index
			     + TYPE_LOW_BOUND (TYPE_INDEX_TYPE (type)));
d2810 5
a2814 3
	*cfull_expression = xstrprintf ("(%s)[%d]", parent_expression, 
					index
					+ TYPE_LOW_BOUND (TYPE_INDEX_TYPE (type)));
@


1.149
log
@        * varobj.c (varobj_update): Initialize children_changed.
@
text
@d3106 2
a3107 1
  int i;
d3113 1
d3116 5
a3120 2
      /* If we have a virtual table pointer, omit it. */
      if (TYPE_VPTR_BASETYPE (type) == type && TYPE_VPTR_FIELDNO (type) == i)
d3207 4
d3218 2
a3219 2
	      if (TYPE_VPTR_BASETYPE (type) == type
		  && type_index == TYPE_VPTR_FIELDNO (type))
@


1.148
log
@gdb
	* varobj.h (varobj_update_result_t) <new>: New field.
	(varobj_get_child_range, varobj_set_child_range): Declare.
	(varobj_list_children): Update.
	(varobj_enable_pretty_printing, varobj_has_more)
	(varobj_pretty_printed_p): Declare.
	* varobj.c (pretty_printing): New global.
	(varobj_enable_pretty_printing): New function.
	(struct varobj_root) <from, to, constructor, child_iter,
	saved_item>: New fields.
	(varobj_create): Don't call install_default_visualizer.
	(instantiate_pretty_printer): Don't use value_copy.
	(varobj_has_more): New function.
	(restrict_range): New function.
	(install_dynamic_child): Likewise.
	(dynamic_varobj_has_child_method): Likewise.
	(update_dynamic_varobj_children): Remove 'new_and_unchanged'
	argument; add 'new', 'unchanged', 'from', and 'to' arguments.
	Rewrite.
	(varobj_get_num_children): Call update_dynamic_varobj_children.
	(varobj_list_children): Add 'from' and 'to' arguments.  Ignore
	result of update_dynamic_varobj_children.  Don't call
	install_default_visualizer.  Restrict result range.
	(varobj_add_child): Don't call install_default_visualizer.
	(varobj_pretty_printed_p): New function.
	(install_visualizer): Rewrite.  Move earlier in file.
	(install_default_visualizer): Likewise.
	(construct_visualizer): New function.
	(install_new_value_visualizer): Likewise.
	(install_new_value): Don't call release_value.  Special case
	pretty-printed objects.  Use value_incref.  Rearrange "changed"
	logic.
	(varobj_get_child_range): New function.
	(varobj_set_child_range): Likewise.
	(varobj_set_visualizer): Rewrite.
	(varobj_update): Rewrite pretty-printing logic.
	(new_variable): Initialize new fields.
	(free_variable): Destroy new fields.
	(value_of_root): Copy 'from' and 'to'.
	(my_value_of_variable): Handle pretty-printers.
	(value_get_print_value): Rework pretty-printing logic.
	(cplus_describe_child): Don't use release_value.
	* mi/mi-cmds.h (mi_cmd_enable_pretty_printing)
	(mi_cmd_var_set_update_range): Declare.
	* mi/mi-cmds.c (mi_cmds): Add enable-pretty-printing and
	var-set-update-range.
	* mi/mi-cmd-var.c (print_varobj): Update.  Emit "dynamic"
	attribute.
	(mi_cmd_var_create): Emit "has_more" attribute.
	(mi_cmd_var_set_format): Plug memory leak.
	(mi_print_value_p): Replace 'type' argument with 'var'.  Handle
	pretty-printed varobjs.
	(mi_cmd_var_list_children): Accept 'from' and 'to' arguments.
	Emit "has_more" attribute.
	(mi_cmd_var_evaluate_expression): Plug memory leak.
	(mi_cmd_var_assign): Likewise.
	(varobj_update_one): Likewise.  Emit "dynamic", "has_more", and
	"new_children" attributes.
	(mi_cmd_enable_pretty_printing): New function.
	(mi_cmd_var_set_update_range): Likewise.
gdb/doc
	* gdb.texinfo (GDB/MI Variable Objects): Document
	-enable-pretty-printing, -var-set-update-range, dynamic varobjs.
	Expand -var-update documentation.
gdb/testsuite
	* lib/mi-support.exp (mi_create_varobj): Update.
	(mi_create_floating_varobj): Likewise.
	(mi_create_dynamic_varobj): New proc.
	(mi_varobj_update): Update.
	(mi_varobj_update_with_type_change): Likewise.
	(mi_varobj_update_kv_helper): New proc.
	(mi_varobj_update_dynamic_helper): Rewrite.
	(mi_varobj_update_dynamic): New proc.
	(mi_list_varobj_children): Update.
	(mi_list_varobj_children_range): Add 'from' and 'to' arguments.
	* gdb.python/python-prettyprint.py (pp_outer): New class.
	(pp_nullstr): Likewise.
	(lookup_function): Register new printers.
	* gdb.python/python-prettyprint.c (struct substruct): New type.
	(struct outerstruct): Likewise.
	(substruct_test): New function.
	(struct nullstr): New type.
	(string_1, string_2): New globals.
	(main): Add new tests.
	* gdb.python/python-mi.exp: Added regression tests.
	* gdb.mi/mi2-var-display.exp: Update.
	* gdb.mi/mi2-var-cmd.exp: Update.
	* gdb.mi/mi2-var-child.exp: Update.
	* gdb.mi/mi2-var-block.exp: Update.
	* gdb.mi/mi-var-invalidate.exp: Update.
	* gdb.mi/mi-var-display.exp: Update.
	* gdb.mi/mi-var-cmd.exp: Update.
	* gdb.mi/mi-var-child.exp: Update.
	* gdb.mi/mi-var-block.exp: Update.
	* gdb.mi/mi-break.exp: Update.
	* gdb.mi/gdb701.exp: Update.
@
text
@d1761 1
a1761 1
	  int i, children_changed;
@


1.148.2.1
log
@        * varobj.c (varobj_update): Initialize children_changed.
@
text
@d1761 1
a1761 1
	  int i, children_changed = 0;
@


1.147
log
@gdb/
	* varobj.c (varobj_create): Error if the specified frame was not found
	and it is needed.

gdb/testsuite/
	* gdb.mi/mi2-var-cmd.exp (create variable with invalid FRAME-ADDR): New.
@
text
@d32 1
d63 9
d186 11
d200 11
a270 2
static void install_default_visualizer (struct varobj *var);

a655 1
  install_default_visualizer (var);
a769 1
  volatile struct gdb_exception except;
a770 5
  TRY_CATCH (except, RETURN_MASK_ALL)
    {
      value = value_copy (value);
    }
  GDB_PY_HANDLE_EXCEPTION (except);
a771 1

d835 11
d878 77
d958 6
a963 3
				VEC (varobj_p) **new_and_unchanged,
				int *cchanged)

a965 3
  /* FIXME: we *might* want to provide this functionality as
     a standalone function, so that other interested parties
     than varobj code can benefit for this.  */
a967 1
  PyObject *iterator;
a968 1
  int children_changed = 0;
d980 12
a991 2
  children = PyObject_CallMethodObjArgs (printer, gdbpy_children_cst,
					 NULL);
d993 2
a994 5
  if (!children)
    {
      gdbpy_print_stack ();
      error (_("Null value returned for children"));
    }
d996 7
a1002 1
  make_cleanup_py_decref (children);
d1004 2
a1005 2
  if (!PyIter_Check (children))
    error (_("Returned value is not iterable"));
d1007 1
a1007 5
  iterator = PyObject_GetIter (children);
  if (!iterator)
    {
      gdbpy_print_stack ();
      error (_("Could not get children iterator"));
d1009 2
a1010 1
  make_cleanup_py_decref (iterator);
d1012 3
a1014 1
  for (i = 0; ; ++i)
d1016 11
a1026 6
      PyObject *item = PyIter_Next (iterator);
      PyObject *py_v;
      struct value *v;
      char *name;
      struct cleanup *inner;
      
a1028 8
      inner = make_cleanup_py_decref (item);

      if (!PyArg_ParseTuple (item, "sO", &name, &py_v))
	error (_("Invalid item from the child list"));
      
      v = convert_value_from_python (py_v);

      /* TODO: This assume the name of the i-th child never changes.  */
d1030 2
a1031 2
      /* Now see what to do here.  */
      if (VEC_length (varobj_p, var->children) < i + 1)
d1033 17
a1049 5
	  /* There's no child yet.  */
	  struct varobj *child = varobj_add_child (var, name, v);
	  if (new_and_unchanged)
	    VEC_safe_push (varobj_p, *new_and_unchanged, child);
	  children_changed = 1;
d1051 1
a1051 1
      else 
d1053 6
a1058 11
	  varobj_p existing = VEC_index (varobj_p, var->children, i);
	  if (install_new_value (existing, v, 0) && changed)
	    {
	      if (changed)
		VEC_safe_push (varobj_p, *changed, existing);
	    }
	  else
	    {
	      if (new_and_unchanged)
		VEC_safe_push (varobj_p, *new_and_unchanged, existing);
	    }
a1059 2

      do_cleanups (inner);
d1064 5
a1068 4
      int i;
      children_changed = 1;
      for (i = 0; i < VEC_length (varobj_p, var->children); ++i)
	varobj_delete (VEC_index (varobj_p, var->children, i), NULL, 0);
d1070 6
a1075 1
  VEC_truncate (varobj_p, var->children, i);
a1079 1
  *cchanged = children_changed;
d1091 10
a1100 3
      int changed;
      if (!var->pretty_printer
	  || !update_dynamic_varobj_children (var, NULL, NULL, &changed))
d1104 1
a1104 1
  return var->num_children;
d1111 1
a1111 1
varobj_list_children (struct varobj *var)
d1119 2
a1120 1
  if (var->pretty_printer
d1124 5
a1128 2
      && update_dynamic_varobj_children (var, NULL, NULL, &children_changed))
    return var->children;
a1153 1
	  install_default_visualizer (existing);
d1157 1
a1167 1
  install_default_visualizer (v);
d1229 6
d1312 110
d1462 1
a1462 4
    {
      value = coerce_ref (value);
      release_value (value);
    }
d1509 1
a1509 1
  if (value && !value_lazy (value))
d1525 1
a1525 1
      else 
d1570 2
a1571 3
  if (var->print_value)
    xfree (var->print_value);
  var->print_value = print_value;
d1578 15
d1598 6
a1603 2
static void
install_visualizer (struct varobj *var, PyObject *visualizer)
d1605 2
a1606 19
#if HAVE_PYTHON
  /* If there are any children now, wipe them.  */
  varobj_delete (var, NULL, 1 /* children only */);
  var->num_children = -1;

  Py_XDECREF (var->pretty_printer);
  var->pretty_printer = visualizer;

  install_new_value (var, var->value, 1);

  /* If we removed the visualizer, and the user ever requested the
     object's children, then we must compute the list of children.
     Note that we needn't do this when installing a visualizer,
     because updating will recompute dynamic children.  */
  if (!visualizer && var->children_requested)
    varobj_list_children (var);
#else
  error (_("Python support required"));
#endif
d1609 5
a1613 2
static void
install_default_visualizer (struct varobj *var)
d1615 2
a1616 27
#if HAVE_PYTHON
  struct cleanup *cleanup;
  PyObject *pretty_printer = NULL;

  cleanup = varobj_ensure_python_env (var);

  if (var->value)
    {
      pretty_printer = gdbpy_get_varobj_pretty_printer (var->value);
      if (! pretty_printer)
	{
	  gdbpy_print_stack ();
	  error (_("Cannot instantiate printer for default visualizer"));
	}
    }
      
  if (pretty_printer == Py_None)
    {
      Py_DECREF (pretty_printer);
      pretty_printer = NULL;
    }
  
  install_visualizer (var, pretty_printer);
  do_cleanups (cleanup);
#else
  /* No error is right as this function is inserted just as a hook.  */
#endif
a1633 11
  
  /* Do not instantiate NoneType. */
  if (constructor == Py_None)
    {
      pretty_printer = Py_None;
      Py_INCREF (pretty_printer);
    }
  else
    pretty_printer = instantiate_pretty_printer (constructor, var->value);

  Py_XDECREF (constructor);
d1635 1
a1635 1
  if (! pretty_printer)
d1641 2
a1642 5
  if (pretty_printer == Py_None)
    {
      Py_DECREF (pretty_printer);
      pretty_printer = NULL;
    }
d1644 3
a1646 1
  install_visualizer (var, pretty_printer);
d1757 1
a1757 2
	 invoked.  Presumably, such varobj is not yet expanded in the
	 UI, so we need not bother getting it.  */
d1760 1
a1760 1
	  VEC (varobj_p) *changed = 0, *new_and_unchanged = 0;
d1762 3
a1764 1
	  varobj_p tmp;
d1767 19
a1785 1
	    continue;
d1787 2
a1788 2
	  if (v->frozen)
	    continue;
d1792 3
a1794 2
	  if (update_dynamic_varobj_children (v, &changed, &new_and_unchanged,
					      &children_changed))
d1796 1
a1796 3
	      if (children_changed)
		r.children_changed = 1;
	      for (i = 0; VEC_iterate (varobj_p, changed, i, tmp); ++i)
d1798 2
a1799 4
		  varobj_update_result r = {tmp};
		  r.changed = 1;
		  r.value_installed = 1;
		  VEC_safe_push (varobj_update_result, stack, &r);
d1801 5
a1805 3
	      for (i = 0;
		   VEC_iterate (varobj_p, new_and_unchanged, i, tmp);
		   ++i)
d1807 1
d1809 1
d1813 10
d1825 6
d2118 3
d2122 2
d2153 4
a2156 1
      Py_DECREF (var->pretty_printer);
d2403 2
d2439 5
a2443 1
    return (*var->root->lang->value_of_variable) (var, format);
d2466 1
a2466 2
    if (value_formatter && PyObject_HasAttr (value_formatter,
					     gdbpy_to_string_cst))
d2468 4
a2471 4
	char *hint;
	struct value *replacement;
	int string_print = 0;
	PyObject *output = NULL;
d2473 1
a2473 2
	hint = gdbpy_get_display_hint (value_formatter);
	if (hint)
d2475 12
a2486 4
	    if (!strcmp (hint, "string"))
	      string_print = 1;
	    xfree (hint);
	  }
d2488 14
a2501 11
	output = apply_varobj_pretty_printer (value_formatter,
					      &replacement);
 	if (output)
  	  {
 	    PyObject *py_str = python_string_to_target_python_string (output);
 	    if (py_str)
 	      {
 		char *s = PyString_AsString (py_str);
 		len = PyString_Size (py_str);
		thevalue = xmemdup (s, len + 1, len + 1);
 		Py_DECREF (py_str);
d2503 7
a2509 1
 	    Py_DECREF (output);
a2510 7
	if (thevalue && !string_print)
	  {
	    do_cleanups (back_to);
	    return thevalue;
	  }
	if (replacement)
	  value = replacement;
d3239 1
a3239 4
	    {
	      *cvalue = value_cast (TYPE_FIELD_TYPE (type, index), value);
	      release_value (*cvalue);
	    }
@


1.146
log
@	* ui-file.h (ui_file_xstrdup): Mention that the length argument
	may be NULL.
	* ui-file.c (ui_file_xstrdup): Don't dereference LENGTH if it is
	NULL.
	* aix-thread.c (aix_thread_extra_thread_info): Pass NULL as length
	parameter to ui_file_xstrdup.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* infrun.c (print_target_wait_results): Ditto.
	* language.c (add_language): Ditto.
	* linespec.c (cplusplus_error): Ditto.
	* remote.c (escape_buffer): Ditto.
	* typeprint.c (type_to_string): Ditto.
	* utils.c (error_stream): Ditto.
	* varobj.c (value_get_print_value): Ditto.
	* xtensa-tdep.c (xtensa_verify_config): Replace `dummy' local with
	`length' local.  Pass it to ui_file_xstrdup, and avoid an strlen
	call.
	* gdbarch.sh (verify_gdbarch): Ditto.
	* gdbarch.c: Regenerate.
	* cli/cli-setshow.c (do_setshow_command): Pass NULL as length
	parameter to ui_file_xstrdup.
	* python/python-frame.c (frapy_str): Ditto.
	* python/python-type.c (typy_str): Use the length local instead of
	calling strlen.
	* python/python-value.c (valpy_str): Pass NULL as length parameter
	to ui_file_xstrdup.
@
text
@d568 1
a568 1
      if (innermost_block && fi != NULL)
d570 7
@


1.145
log
@	* varobj.c (update_dynamic_varobj_children): Don't use
	value_copy.
	* value.h: (preserve_one_value): Declare.
	(value_prepend_to_list, value_remove_from_list): Remove.
	* value.c (preserve_one_value): No longer static.
	(preserve_values): Call preserve_python_values.
	(value_prepend_to_list): Remove.
	(value_remove_from_list): Remove.
	* python/python.h (values_in_python): Don't declare.
	(preserve_python_values): Declare.
	* python/python-value.c (values_in_python): Change type.  Move
	lower.  Now static.
	(struct value_object): Add struct tag.
	<next, prev>: New fields.
	(valpy_dealloc): Update.
	(note_value): New function.
	(valpy_new): Use value_incref, note_value.
	(preserve_python_values): New function.
	(valpy_positive): Don't use value_copy.
	(value_to_value_object): Use value_incref, note_value.
	(convert_value_from_python): Update comment.
@
text
@a2177 1
  long dummy;
d2249 1
a2249 1
  thevalue = ui_file_xstrdup (stb, &dummy);
@


1.144
log
@gdb/
	Replace public function varobj_list by all_root_varobjs iterator.
	* mi/mi-cmd-var.c (struct mi_cmd_var_update, mi_cmd_var_update_iter):
	New.
	(mi_cmd_var_update): Replace the varobj_list call by all_root_varobjs.
	Remove the variables rootlist, cr.  New variable data.
	* varobj.c (rootcount, varobj_list): Remove.
	(install_variable, uninstall_variable): Remove the rootcount updates.
	(all_root_varobjs): New function.
	(varobj_invalidate): Use the all_root_varobjs call.  Move the code to...
	(varobj_invalidate_iter): ... a new function.
	* varobj.h (varobj_list): Remove the prototype.
	(all_root_varobjs): New prototype.
@
text
@d902 1
a902 10
      if (PyObject_TypeCheck (py_v, &value_object_type))
	{
	  /* If we just call convert_value_from_python for this type,
	     we won't know who owns the result.  For this one case we
	     need to copy the resulting value.  */
	  v = value_object_to_value (py_v);
	  v = value_copy (v);
	}
      else
	v = convert_value_from_python (py_v);
@


1.143
log
@2009-07-10 Phil Muldoon  <pmuldoon@@redhat.com>

	* python/python-internal.h (apply_varobj_pretty_printer): Update
	definition.
	(python_string_to_target_python_string): Add definition.
	* python/python-utils.c (unicode_to_encoded_python_string)
	(unicode_to_target_python_string)
	(python_string_to_target_python_string): New Functions.
	* python/python-prettyprint.c (pretty_print_one_value): Likewise.
	(print_string_repr): Refactor to logic to account for PyObject
	returned strings.
	(apply_varobj_pretty_printer): Likewise.
	* python/python-value.c (valpy_string): Parse length keyword. Use
	length keyword in LA_GET_STRING.
	* varobj.c (value_get_print_value): Refactor logic to account for
	PyObject returned strings.
	* c-lang.c (c_get_string): If the length parameter is specified,
	use that. Return value in characters. Update comments.
	* language.h: Update c_get_string prototype comments.

2009-07-10  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.texinfo (Values From Inferior): Add length parameter
	description.

2009-07-10 Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.python/python-prettyprint.c: Add counted null string
	structure.
	* gdb.python/python-prettyprint.exp: Print null string. Test for
	embedded nulls.
	* gdb.python/python-prettyprint.py (pp_ns): New Function.
	* gdb.python/python-value.exp (test_value_in_inferior): Add
	variable length string fetch tests.
	* gdb.python/python-value.c (main): Add strings for string fetch tests.
@
text
@a426 1
static int rootcount = 0;	/* number of root varobjs in the list */
a1170 31
/* Returns a malloc'ed list with all root variable objects */
int
varobj_list (struct varobj ***varlist)
{
  struct varobj **cv;
  struct varobj_root *croot;
  int mycount = rootcount;

  /* Alloc (rootcount + 1) entries for the result */
  *varlist = xmalloc ((rootcount + 1) * sizeof (struct varobj *));

  cv = *varlist;
  croot = rootlist;
  while ((croot != NULL) && (mycount > 0))
    {
      *cv = croot->rootvar;
      mycount--;
      cv++;
      croot = croot->next;
    }
  /* Mark the end of the list */
  *cv = NULL;

  if (mycount || (croot != NULL))
    warning
      ("varobj_list: assertion failed - wrong tally of root vars (%d:%d)",
       rootcount, mycount);

  return rootcount;
}

a1716 1
      rootcount++;
a1792 1
      rootcount--;
d3175 18
d3213 33
d3253 1
a3253 37
  struct varobj **all_rootvarobj;
  struct varobj **varp;

  if (varobj_list (&all_rootvarobj) > 0)
    {
      for (varp = all_rootvarobj; *varp != NULL; varp++)
	{
	  /* Floating varobjs are reparsed on each stop, so we don't care if
	     the presently parsed expression refers to something that's gone.
	     */
	  if ((*varp)->root->floating)
	    continue;

	  /* global var must be re-evaluated.  */     
	  if ((*varp)->root->valid_block == NULL)
	    {
	      struct varobj *tmp_var;

	      /* Try to create a varobj with same expression.  If we succeed
		 replace the old varobj, otherwise invalidate it.  */
	      tmp_var = varobj_create (NULL, (*varp)->name, (CORE_ADDR) 0,
				       USE_CURRENT_FRAME);
	      if (tmp_var != NULL) 
		{ 
		  tmp_var->obj_name = xstrdup ((*varp)->obj_name);
		  varobj_delete (*varp, NULL, 0);
		  install_variable (tmp_var);
		}
	      else
		(*varp)->root->is_valid = 0;
	    }
	  else /* locals must be invalidated.  */
	    (*varp)->root->is_valid = 0;
	}
    }
  xfree (all_rootvarobj);
  return;
@


1.142
log
@gdb/
	* mi/mi-cmd-var.c (mi_cmd_var_update): Replace a while loop by for loop.
	* varobj.c (varobj_invalidate): Replace a while loop by for loop.
@
text
@d2224 1
a2224 1
  char *thevalue = NULL;
d2226 1
d2242 1
d2252 14
a2265 2
	thevalue = apply_varobj_pretty_printer (value_formatter,
						&replacement);
d2289 1
a2289 2
		       (gdb_byte *) thevalue, strlen (thevalue),
		       0, &opts);
@


1.141
log
@	Fix hang in floating varobjs.

	* varob.c (varobj_invalidate): Advance to next
	element when processing floating varobj.
@
text
@d3228 1
a3228 2
      varp = all_rootvarobj;
      while (*varp != NULL)
d3233 1
a3233 2
	  if ((*varp)->root->floating) {
	    varp++;
a3234 1
	  }
a3255 2

	  varp++;
@


1.140
log
@	* varobj.c: Remove unnecessary include.
@
text
@d3234 2
a3235 1
	  if ((*varp)->root->floating)
d3237 1
@


1.139
log
@	* python/python-internal.h (struct language_defn): Declare.
	(python_gdbarch, python_language): Likewise.
	(ensure_python_env): Add prototype.
	(make_cleanup_py_restore_gil): Remove prototype.

	* python/python.c: Include "arch-utils.h", "value.h" and "language.h".
	(python_gdbarch, python_language): New global variables.
	(struct python_env): New data type.
	(ensure_python_env, restore_python_env): New functions.
	(eval_python_from_control_command): Call ensure_python_env to
	install current architecture and language.
	(python_command, gdbpy_new_objfile): Likewise.
	* python/python-cmd.c: Include "arch-utils.h" and "language.h".
	(cmdpy_destroyer, cmdpy_function, cmdpy_completer): Call
	ensure_python_env.
	* python/python-type.c (clean_up_objfile_types): Likewise.
	* python/python-objfile.c: Include "language.h".
	(clean_up_objfile): Call ensure_python_env.
	* python/python-prettyprint.c (apply_val_pretty_printer): Likewise.
	(apply_varobj_pretty_printer): Do not call PyGILState_Ensure.
	* varobj.c (varobj_ensure_python_env): New helper function.
	(varobj_get_display_hint, update_dynamic_varobj_children,
	install_default_visualizer, varobj_set_visualizer, free_variable,
	value_get_print_value): Call it.
	(value_get_print_value): Add varobj argument instead of pretty
	printer argument.  Update all callers.

	* python/python-utils.c (py_gil_restore, make_cleanup_py_restore_gil):
	Remove.

	* value.h (internal_function_fn): Add GDBARCH and LANGUAGE argument.
	(call_internal_function): Likewise.
	* value.c (call_internal_function): Likewise.  Pass to handler.
	* eval.c (evaluate_subexp_standard): Update call.
	* python/python-function.c: Include "language.h".
	(fnpy_call): Add GDBARCH and LANGAUAGE arguments and call
	make_cleanup_python_env.

	* python/python-value.c (builtin_type_pyint, builtin_type_pyfloat,
	builtin_type_pylong, builtin_type_pybool, builtin_type_pychar,
	valpy_str): Use python_gdbarch and python_language instead of
	current_gdbarch and current_language.
	* python/python-type.c (typy_lookup_typename): Likewise.
@
text
@a36 1
#include "typeprint.h"
@


1.138
log
@	* gdbtypes.c (make_pointer_type, make_reference_type,
	smash_to_memberptr_type, lookup_array_range_type, check_stub_method):
	Use type architecture instead of current_gdbarch.

	* gdbtypes.h (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH paramter.
	* gdbtypes.c (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH parameter.   Use it instead of current_gdbarch.
	* c-typeprint.c (c_type_print_modifier): Update call.
	* parse.c (push_type_address_space): Likewise.

	* findvar.c (extract_typed_address, store_typed_address): Use type
	architecture instead of current_gdbarch.

	* value.c (value_as_address, unpack_field_as_long): Use type architecture
	instead of current_gdbarch.

	* doublest.c (floatformat_from_length): Add GDBARCH argument.  Use it
	instead of current_gdbarch.
	(floatformat_from_type): Pass type architecture.

	* infcall.c (find_function_addr): Use type architecture instead
	of current_gdbarch.

	* valarith.c (value_bitstring_subscript, value_x_binop, value_neg,
	value_bit_index): Use type architecture instead of current_gdbarch.
	* valops.c (value_cast, value_slice): Likewise.

	* value.h (modify_field): Add TYPE argument.
	* value.c (modify_field): Add TYPE argument.  Use type architecture
	instead of current_gdbarch.
	(set_internalvar_component): Likewise.
	* eval.c (evaluate_struct_tuple): Update call.
	* valops.c (value_assign): Likewise.
	* ada-lang.c (modify_general_field): Likewise.  Add TYPE argument.
	(make_array_descriptor): Update calls.
	(move_bits): Add BITS_BIG_ENDIAN_P argument.  Use it instead of
	current_gdbarch.
	(ada_value_assign, value_assign_to_component): Update calls.
	(decode_packed_array, ada_value_primitive_packed_val, ada_value_assign,
	value_assign_to_component): Use type arch instead of current_gdbarch.

	* printcmd.c (float_type_from_length): Remove GDBARCH argument,
	use type architecture instead.
	(print_scalar_formatted, printf_command): Update calls.  Use type
	architecture instead of current_gdbarch.
	* valprint.c (val_print_type_code_int): Use type architecture
	instead of current_gdbarch.
	* varobj.c (value_get_print_value): Likewise.
	* python/python-prettyprint.c (print_string_repr): Add GDBARCH
	argument.  Use it instead of current_gdbarch.
	(apply_val_pretty_printer): Update call.

	* ada-valprint.c (ada_val_print_1): Use type architecture instead
	of current_gdbarch.
	* c-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(c_val_print): Update calls passing type architecture.
	* f-valprint.c (f_val_print): Use type architecture instead of
	current_gdbarch.
	* jv-valprint (java_value_print): Likewise.
	* m2-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(print_unpacked_pointer): Update calls passing type architecture.
	* scm-valprint.c (scm_scmval_print): Use type architecture instead of
	current_gdbarch.

	* gnu-v3-abi.c (get_class_arch): Remove.
	(gnuv3_rtti_type): Use get_type_arch instead of get_class_arch.  Remove
	special-case check for Java classes.
	(gnuv3_virtual_fn_field, gnuv3_baseclass_offset, gnuv3_print_method_ptr,
	gnuv3_method_ptr_size, gnuv3_make_method_ptr, gnuv3_method_ptr_to_value):
	Use get_type_arch instead of get_class_arch.
@
text
@d261 1
a261 1
				    PyObject *value_formatter);
d449 11
d779 1
a779 2
      var->print_value = value_get_print_value (var->value, var->format,
						var->pretty_printer);
d797 2
a798 1
  PyGILState_STATE state = PyGILState_Ensure ();
d801 2
a802 1
  PyGILState_Release (state);
a856 1
  PyGILState_STATE state;
d858 1
a858 2
  state = PyGILState_Ensure ();
  back_to = make_cleanup_py_restore_gil (&state);
d1295 1
a1295 2
    print_value = value_get_print_value (value, var->format, 
					 var->pretty_printer);
a1397 1
  PyGILState_STATE state;
d1400 1
a1400 2
  state = PyGILState_Ensure ();
  cleanup = make_cleanup_py_restore_gil (&state);
a1430 2
  PyGILState_STATE state;

d1432 1
a1432 2
  state = PyGILState_Ensure ();
  back_to = make_cleanup_py_restore_gil (&state);
d1928 9
a1945 8
#if HAVE_PYTHON
  {
    PyGILState_STATE state = PyGILState_Ensure ();
    Py_XDECREF (var->pretty_printer);
    PyGILState_Release (state);
  }
#endif

d2220 1
a2220 1
		       PyObject *value_formatter)
d2233 3
a2235 1
    PyGILState_STATE state = PyGILState_Ensure ();
d2255 1
a2255 1
	    PyGILState_Release (state);
d2261 1
a2261 1
    PyGILState_Release (state);
d2784 1
a2784 2
	      return value_get_print_value (var->value, format, 
					    var->pretty_printer);
@


1.137
log
@	* varobj.c (varobj_get_type): Use type_to_string.
@
text
@d2266 1
d2268 1
a2268 1
      LA_PRINT_STRING (stb, builtin_type (current_gdbarch)->builtin_char,
@


1.136
log
@	* value.h (value_subscript, value_subscripted_rvalue,
	value_bitstring_subscript, value_ptradd): Use LONGEST instead
	of value as type of the index argument.
	(value_ptrsub): Remove.
	* valarith.c (value_subscript, value_subscripted_rvalue,
	value_bitstring_subscript, value_ptradd): Use LONGEST instead
	of value as type of the index argument.
	(value_ptrsub): Remove.

	* wrapper.h (gdb_value_subscript): Use LONGEST instead of
	value as type of the index argument.
	* wrapper.c (gdb_value_subscript): Likewise.

	Update calls to gdb_value_subscript, value_subscript,
	value_subscripted_rvalue, value_bitstring_subscript and
	value_ptradd to use LONGEST instead of value as index
	argument type.  Use value_ptradd instead of value_ptrsub.
	* ada-lang.c (ada_value_subscript, ada_value_ptr_subscript,
	ada_tag_name_2): Update.
	* ada-tasks.c (read_atcb): Update.
	* eval.c (evaluate_subexp_standard): Update.
	* valarith.c (value_subscript): Update.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Update.
	* gnu-v3-abi.c (gnuv3_get_virtual_fn, gnuv3_baseclass_offset,
	gnuv3_method_ptr_to_value): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* m2-lang.c (evaluate_subexp_modula2): Update.
	* python/python-value.c (valpy_getitem, valpy_binop): Update.
	* wrapper.c (gdb_value_subscript): Update.
	* varobj.c (c_describe_child): Update.
@
text
@d37 1
a1033 6
  struct value *val;
  struct cleanup *old_chain;
  struct ui_file *stb;
  char *thetype;
  long length;

d1040 1
a1040 11
  stb = mem_fileopen ();
  old_chain = make_cleanup_ui_file_delete (stb);

  /* To print the type, we simply create a zero ``struct value *'' and
     cast it to our type. We then typeprint this variable. */
  val = value_zero (var->type, not_lval);
  type_print (value_type (val), "", stb, -1);

  thetype = ui_file_xstrdup (stb, &length);
  do_cleanups (old_chain);
  return thetype;
@


1.135
log
@ChangeLog:

	* printcmd.c (print_scalar_formatted): Always truncate
	unsigned data types.

	* cli-dump.c (struct callback_data): Change type of load_offset
	to CORE_ADDR.
	(restore_binary_file): Update type casts.
	(restore_command): Parse load_offset as address, not long.

	* utils.c (string_to_core_addr): Do not sign-extend value.
	* varobj.c (find_frame_addr_in_frame_chain): Truncate frame_base
	before comparing against requested frame address.

testsuite/ChangeLog:

	* gdb.base/dump.exp: Handle SPU like 64-bit platforms.
@
text
@d2559 1
a2559 3
	  struct value *indval = 
	    value_from_longest (builtin_type_int32, (LONGEST) real_index);
	  gdb_value_subscript (value, indval, cvalue);
@


1.134
log
@	* varobj.c (varobj_create): Properly restore the selected frame.
@
text
@d465 10
a474 1
      if (get_frame_base_address (frame) == frame_addr)
@


1.133
log
@	* varobj.c (update_dynamic_varobj_children): Wrap error text in
	_().
	(install_visualizer): Likewise.
	(varobj_set_visualizer): Likewise.
@
text
@d580 1
a580 1
      if (fi != NULL)
@


1.132
log
@gdb/
	* varobj.c (varobj_update): Fix out of scope varobjs to not to change.
@
text
@d853 1
a853 1
      error ("Null value returned for children");
d859 1
a859 1
    error ("Returned value is not iterable");
d865 1
a865 1
      error ("Could not get children iterator");
d882 1
a882 1
	error ("Invalid item from the child list");
d1386 1
a1386 1
  error ("Python support required");
d1457 1
a1457 1
      error ("Could not evaluate visualizer expression: %s", visualizer);
d1470 1
a1470 1
  error ("Python support required");
@


1.131
log
@gdb

2009-05-27  Vladimir Prus  <vladimir@@codesourcery.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* mi/mi-main.c (mi_cmd_list_features): List "python" feature.
	* varobj.h (varobj_set_visualizer): Declare.
	(varobj_get_display_hint): Likewise.
	(varobj_update_result_t) <children_changed, value_installed>: New
	fields.
	* mi/mi-cmds.c (mi_cmds): Add var-set-visualizer.
	* mi/mi-cmds.h (mi_cmd_var_set_visualizer,
	mi_cmd_var_set_child_range): Declare.
	* mi/mi-cmd-var.c (mi_cmd_var_set_visualizer): New function.
	(mi_cmd_var_list_children): Emit display hint.
	(varobj_update_one): Emit display hint.  Handle dynamic children.
	* python/python.c (GdbMethods): Add "default_visualizer".
	* python/python-internal.h (apply_varobj_pretty_printer,
	gdbpy_get_varobj_pretty_printer, gdbpy_get_display_hint):
	Declare.
	(gdbpy_default_visualizer): Likewise.
	* varobj.c: Include python.h, python-internal.h.
	(PyObject): New typedef.
	(struct varobj) <children_requested, pretty_printer>: New fields.
	(varobj_create): Call install_default_visualizer.
	(instantiate_pretty_printer): New function.
	(varobj_set_display_format): Update.
	(varobj_get_display_hint): New function.
	(update_dynamic_varobj_children): New function.
	(varobj_get_num_children): Handle dynamic children.
	(varobj_list_children): Likewise.
	(install_new_value): Likewise.
	(varobj_add_child): New function.
	(install_visualizer): Likewise.
	(install_default_visualizer): Likewise.
	(varobj_set_visualizer): Likewise.
	(varobj_update): Handle dynamic children.
	(create_child): Use create_child_with_value.
	(create_child_with_value): New function.
	(value_get_print_value): Call pretty printer.  Add value_formatter
	argument.
	(c_value_of_variable): Update.
	(varobj_invalidate): Always free all_rootvarobj.
	* python/python-prettyprint.c (apply_varobj_pretty_printer): New
	function.
	(gdbpy_get_varobj_pretty_printer): Likewise.
	(gdbpy_default_visualizer): Likewise.

gdb/doc

2009-05-27  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (GDB/MI Miscellaneous Commands): Document "python"
	feature.
	(GDB/MI Variable Objects): Document -var-set-visualizer.

gdb/testsuite

2009-05-27  Tom Tromey  <tromey@@redhat.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* lib/mi-support.exp (mi_varobj_update_dynamic): New proc.
	(mi_child_regexp): Likewise.
	(mi_list_varobj_children_range): Likewise.
	(mi_get_features): Likewise.
	(mi_list_varobj_children): Rewrite.
	* gdb.python/python-mi.exp: New file.
@
text
@d1542 2
a1543 1
	  VEC_safe_push (varobj_update_result, result, &r);
@


1.130
log
@gdb/
	Replace the savestring calls by xstrdup calls where possible.
	* breakpoint.c (condition_command, set_raw_breakpoint)
	(create_catchpoint, update_breakpoint_locations): Replace the
	savestring calls by xstrdup calls where possible.
	* buildsym.c (start_subfile, patch_subfile_names, record_debugformat)
	(record_producer): Likewise.
	* coffread.c (coff_start_symtab, complete_symtab): Likewise.
	* corefile.c (set_gnutarget): Likewise.
	* dbxread.c (add_new_header_file): Likewise.
	* demangle.c (set_demangling_command, set_demangling_style): Likewise.
	* event-top.c (push_prompt, pop_prompt, command_line_handler)
	(set_async_prompt): Likewise.
	* infcmd.c (set_inferior_io_terminal, attach_command_post_wait):
	Likewise.
	* language.c (set_language_command, _initialize_language): Likewise.
	* linespec.c (decode_line_2): Likewise.
	* rs6000-nat.c (add_vmap): Likewise.
	* top.c (set_prompt, init_history, init_main): Likewise.
	* tracepoint.c (stringify_collection_list): Likewise.
	* varobj.c (varobj_create): Remove variable expr_len.  Replace the
	savestring calls by xstrdup calls where possible.
	(value_of_root, c_name_of_variable, c_describe_child): Replace the
	savestring calls by xstrdup calls where possible.
	* xcoffread.c (complete_symtab): Likewise.
	* cli/cli-script.c (build_command_line, define_command): Likewise.
	* cli/cli-setshow.c (do_setshow_command): Likewise.
@
text
@d38 7
d148 6
d175 4
d210 4
d239 2
d259 2
a260 1
				    enum varobj_display_formats format);
d266 3
d600 1
d707 27
d758 2
a759 1
      var->print_value = value_get_print_value (var->value, var->format);
d771 15
d818 124
d947 6
a952 1
    var->num_children = number_of_children (var);
d965 10
a974 1
  int i;
d1000 1
d1007 11
d1227 7
d1285 1
d1291 2
a1292 1
      print_value = value_get_print_value (value, var->format);
d1366 108
d1499 1
a1499 1
  VEC (varobj_p) *stack = NULL;
d1538 1
a1538 3

      if (r.type_changed || r.changed)
	VEC_safe_push (varobj_update_result, result, &r);
d1541 11
a1551 1
	return result;
a1553 2
  VEC_safe_push (varobj_p, stack, *varp);

d1555 1
a1555 1
  while (!VEC_empty (varobj_p, stack))
d1557 60
a1616 1
      v = VEC_pop (varobj_p, stack);
a1626 9
	    VEC_safe_push (varobj_p, stack, c);
	}

      /* Update this variable, unless it's a root, which is already
	 updated.  */
      if (v->root->rootvar != v)
	{	  
	  new = value_of_child (v->parent, v->index);
	  if (install_new_value (v, new, 0 /* type not changed */))
d1628 2
a1629 5
	      /* Note that it's changed */
	      varobj_update_result r = {v};
	      r.changed = 1;
	      VEC_safe_push (varobj_update_result, result, &r);
	      v->updated = 0;
d1632 3
d1637 2
a1638 1
  VEC_free (varobj_p, stack);
d1837 8
a1846 1
  struct value *value;
d1851 2
a1852 1
  child->name = name;
a1853 1
  value = value_of_child (parent, index);
d1902 2
d1938 8
d2219 2
a2220 1
value_get_print_value (struct value *value, enum varobj_display_formats format)
d2225 1
a2225 1
  char *thevalue;
d2231 32
d2268 10
a2277 1
  common_val_print (value, stb, 0, &opts, current_language);
d2368 1
a2368 1
   depending on whether pointer was deferenced
d2734 5
d2783 2
a2784 1
	      return value_get_print_value (var->value, format);
@


1.129
log
@gdb/
	Remove already unreachable code.
	* varobj.c (varobj_get_handle): Fix comment when error is called.
	All callers updated.
@
text
@a463 1
      int expr_len;
d514 1
a514 2
      expr_len = strlen (expression);
      var->name = savestring (expression, expr_len);
d516 1
a516 1
      var->path_expr = savestring (expression, expr_len);
d562 1
a562 1
      var->obj_name = savestring (objname, strlen (objname));
d1766 1
a1766 2
	  tmp_var->obj_name =
	    savestring (var->obj_name, strlen (var->obj_name));
d2015 1
a2015 1
  return savestring (parent->name, strlen (parent->name));
d2114 1
a2114 4
	{
	  char *string = TYPE_FIELD_NAME (type, index);
	  *cname = savestring (string, strlen (string));
	}
@


1.128
log
@	Always report varobj as changed when in_scope attribute changes.

	* varobj.c (install_new_value): If non-NULL-ness of value
	changed, return 1.
@
text
@d594 2
a595 2
/* Given an "objname", returns the pointer to the corresponding varobj
   or NULL if not found */
@


1.127
log
@gdb/
	* varobj.c (free_variable): Replace free_current_contents by xfree.
@
text
@d985 6
a990 3
   Otherwise, assign the value and if type_changeable returns non-zero,
   find if the new value is different from the current value.
   Return 1 if so, and 0 if the values are equal.  
d1111 9
@


1.126
log
@gdb/
	* varobj.c (varobj_invalidate): Fix formatting text width.
@
text
@d1520 1
a1520 1
      free_current_contents (&var->root->exp);
@


1.125
log
@gdb/
	* varobj.c (varobj_invalidate): Fix indentation.
@
text
@d2767 2
a2768 1
	     the presently parsed expression refers to something that's gone.  */
d2777 4
a2780 3
	      /* Try to create a varobj with same expression.  If we succeed replace
		 the old varobj, otherwise invalidate it.  */
	      tmp_var = varobj_create (NULL, (*varp)->name, (CORE_ADDR) 0, USE_CURRENT_FRAME);
@


1.124
log
@	* varobj.c (free_variable): Call value_free.
@
text
@d2754 1
d2762 8
a2769 8
  {
    varp = all_rootvarobj;
    while (*varp != NULL)
      {
	/* Floating varobjs are reparsed on each stop, so we don't care if
	   the presently parsed expression refers to something that's gone.  */
	if ((*varp)->root->floating)
	  continue;
d2771 4
a2774 4
        /* global var must be re-evaluated.  */     
        if ((*varp)->root->valid_block == NULL)
        {
          struct varobj *tmp_var;
d2776 14
a2789 14
          /* Try to create a varobj with same expression.  If we succeed replace
             the old varobj, otherwise invalidate it.  */
          tmp_var = varobj_create (NULL, (*varp)->name, (CORE_ADDR) 0, USE_CURRENT_FRAME);
          if (tmp_var != NULL) 
            { 
	      tmp_var->obj_name = xstrdup ((*varp)->obj_name);
              varobj_delete (*varp, NULL, 0);
              install_variable (tmp_var);
            }
          else
              (*varp)->root->is_valid = 0;
        }
        else /* locals must be invalidated.  */
          (*varp)->root->is_valid = 0;
d2791 3
a2793 3
        varp++;
      }
  }
@


1.123
log
@	* frame.c (has_stack_frames): Make public.
	(get_prev_frame): Don't allow a NULL this_frame anymore.
	* frame.h (has_stack_frames): Declare.
	* varobj.c (find_frame_addr_in_frame_chain): Don't ever pass NULL
	to get_prev_frame, instead start at get_current_frame.
	(varobj_create): Check has_stack_frames before getting any frame;
	eliminate one usage of deprecated_safe_get_selected_frame.
@
text
@d1515 2
@


1.122
log
@	PR breakpoints/9350:
	* varobj.c (varobj_invalidate): Unconditionally free
	all_rootvarobj.
	* symfile.c (syms_from_objfile): Free local_addr when returning
	normally.
	* exec.c (exec_file_attach): Do cleanups before returning.
	(exec_file_command): Likewise.
	* corefile.c (reopen_exec_file): Do cleanups before returning.
	* breakpoint.c (insert_breakpoint_locations): Do cleanups before
	returning.
	(do_vec_free): New function.
	(update_global_location_list): Make a cleanup for old_locations.
	Do cleanups before returning.  Remove unused variable 'e'.
	(find_condition_and_thread): Free result of parsing the
	expression.
	(print_it_typical): Do cleanups before returning.
	(breakpoint_re_set_one): Always free sals.sals.
@
text
@d434 3
a436 1
  while (1)
a437 3
      frame = get_prev_frame (frame);
      if (frame == NULL)
	return NULL;
d441 2
d466 2
a467 2
      /* Parse and evaluate the expression, filling in as much
         of the variable's data as possible */
d469 15
a483 3
      /* Allow creator to specify context of variable */
      if ((type == USE_CURRENT_FRAME) || (type == USE_SELECTED_FRAME))
	fi = deprecated_safe_get_selected_frame ();
d485 1
a485 7
	/* FIXME: cagney/2002-11-23: This code should be doing a
	   lookup using the frame ID and not just the frame's
	   ``address''.  This, of course, means an interface change.
	   However, with out that interface change ISAs, such as the
	   ia64 with its two stacks, won't work.  Similar goes for the
	   case where there is a frameless function.  */
	fi = find_frame_addr_in_frame_chain (frame);
@


1.121
log
@        Updated copyright notices for most files.
@
text
@a2782 1
    xfree (all_rootvarobj);
d2784 1
@


1.120
log
@gdb
	* varobj.c (value_get_print_value): Include valprint.h.
	(value_get_print_value): Use get_formatted_print_options.
	* value.h (struct value_print_options): Declare.
	(value_print, val_print, common_val_print, val_print_string):
	Update.
	* value.c: Include valprint.h.
	(show_values): Use get_user_print_options.
	(show_convenience): Likewise.
	* valprint.h (prettyprint_arrays, prettyprint_structs): Don't
	declare.
	(struct value_print_options): New type.
	(vtblprint, unionprint, addressprint, objectprint, print_max,
	inspect_it, repeat_count_threshold, output_format,
	stop_print_at_null): Don't declare.
	(user_print_options, get_user_print_options,
	get_raw_print_options, get_formatted_print_options): Declare.
	(print_array_indexes_p): Don't declare.
	(maybe_print_array_index, val_print_array_elements): Update.
	* valprint.c (print_max): Remove.
	(user_print_options): New global.
	(get_user_print_options, get_raw_print_options,
	get_formatted_print_options): New functions.
	(print_array_indexes, repeat_count_threshold, stop_print_at_null,
	prettyprint_structs, prettyprint_arrays, unionprint,
	addressprint): Remove.
	(val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(common_val_print): Likewise.
	(print_array_indexes_p): Remove.
	(maybe_print_array_index): Remove format, pretty arguments; add
	options.  Update.
	(val_print_array_elements): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(val_print_string): Add options argument.  Update.
	(_initialize_valprint): Use user_print_options.
	(output_format): Remove.
	(set_output_radix_1): Use user_print_options.
	* typeprint.c: Include valprint.h.
	(objectprint): Don't declare.
	(whatis_exp): Use get_user_print_options.
	* tui/tui-regs.c: Include valprint.h.
	(tui_register_format): Use get_formatted_print_options.
	* tracepoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(trace_mention): Use get_user_print_options.
	(tracepoints_info): Likewise.
	* stack.c (print_frame_args): Use get_raw_print_options.
	(print_frame_info): Use get_user_print_options.
	(print_frame): Likewise.
	* sh64-tdep.c: Include valprint.h
	(sh64_do_register): Use get_formatted_print_options.
	* scm-valprint.c (scm_inferior_print): Remove format, deref_ref,
	pretty arguments; add options.
	(scm_scmlist_print): Likewise.  Update.
	(scm_scmval_print): Likewise.
	(scm_val_print): Likewise.
	(scm_value_print): Remove format, pretty arguments; add options.
	Update.
	* scm-lang.h (scm_value_print, scm_val_print, scm_scmval_print):
	Update.
	* scm-lang.c (scm_printstr): Add options argument.
	* python/python-value.c: Include valprint.h.
	(valpy_str): Use get_user_print_options.
	* printcmd.c: Include valprint.h.
	(addressprint): Don't declare.
	(inspect_it): Remove.
	(print_formatted): Remove format option; add options.  Update.
	(print_scalar_formatted): Likewise.
	(print_address_demangle): Use get_user_print_options.
	(do_examine): Use get_formatted_print_options.
	(print_command_1): Likewise.
	(output_command): Use get_formatted_print_options.
	(do_one_display): Likewise.
	(print_variable_value): Use get_user_print_options.
	* p-valprint.c (pascal_val_print): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(pascal_value_print): Remove format, pretty arguments; add
	options.  Update.
	(vtblprint, objectprint): Don't declare.
	(pascal_static_field_print): Remove.
	(pascal_object_print_value_fields): Remove format, pretty
	arguments; add options.  Update.
	(pascal_object_print_static_field): Likewise.
	(_initialize_pascal_valprint): Use user_print_options.  Update.
	* p-lang.h (pascal_val_print, pascal_value_print,
	pascal_printstr, pascal_object_print_value_fields): Update.
	(vtblprint, static_field_print): Don't declare.
	* p-lang.c (pascal_printstr): Add options argument.  Update.
	* objc-lang.c (objc_printstr): Add options argument.  Update.
	* mt-tdep.c: Include valprint.h.
	(mt_registers_info): Use get_raw_print_options.
	* mips-tdep.c: Include valprint.h.
	(mips_print_fp_register): Use get_formatted_print_options.
	(mips_print_register): Likewise.
	* mi/mi-main.c: Include valprint.h.
	(get_register): Use get_user_print_options.
	(mi_cmd_data_evaluate_expression): Likewise.
	(mi_cmd_data_read_memory): Use get_formatted_print_options.
	* mi/mi-cmd-stack.c: Include valprint.h.
	(list_args_or_locals): Use get_raw_print_options.
	* m2-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(m2_print_long_set): Remove format, pretty arguments.
	(m2_print_unbounded_array): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(print_unpacked_pointer): Remove format argument; add options.
	Now static.  Update.
	(print_variable_at_address): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(m2_print_array_contents): Likewise.
	(m2_val_print): Likewise.
	* m2-lang.h (m2_val_print): Update.
	* m2-lang.c (m2_printstr): Add options argument. Update.
	* language.h (struct value_print_options): Declare.
	(struct language_defn) <la_printstr>: Add options argument.
	<la_val_print>: Remove format, deref_ref, pretty argument; add
	options.
	<la_value_print>: Remove format, pretty arguments; add options.
	<la_print_array_index>: Likewise.
	(LA_VAL_PRINT, LA_VALUE_PRINT, LA_PRINT_STRING,
	LA_PRINT_ARRAY_INDEX): Update.
	(default_print_array_index): Update.
	* language.c (default_print_array_index): Remove format, pretty
	arguments; add options.  Update.
	(unk_lang_printstr): Add options argument.
	(unk_lang_val_print): Remove format, deref_ref, pretty arguments;
	add options.
	(unk_lang_value_print): Remove format, pretty arguments; add
	options.
	* jv-valprint.c (java_value_print): Remove format, pretty
	arguments; add options.  Update.
	(java_print_value_fields): Likewise.
	(java_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	* jv-lang.h (java_val_print, java_value_print): Declare.
	* infcmd.c: Include valprint.h.
	(print_return_value): Use get_raw_print_options.
	(default_print_registers_info): Use get_user_print_options,
	get_formatted_print_options.
	(registers_info): Use get_formatted_print_options.
	* gdbtypes.h (struct value_print_options): Declare.
	(print_scalar_formatted): Update.
	* f-valprint.c (f77_print_array_1): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(f77_print_array): Likewise.
	(f_val_print): Likewise.
	* f-lang.h (f_val_print): Update.
	* f-lang.c (f_printstr): Add options argument.  Update.
	(c_value_print): Update declaration.
	* expprint.c: Include valprint.h.
	(print_subexp_standard): Use get_raw_print_options,
	get_user_print_options.
	* eval.c: Include valprint.h.
	(objectprint): Don't declare.
	(evaluate_subexp_standard): Use get_user_print_options.
	* cp-valprint.c (vtblprint, objectprint, static_field_print):
	Remove.
	(cp_print_value_fields): Remove format, pretty arguments; add
	options.  Update.
	(cp_print_value): Likewise.
	(cp_print_static_field): Likewise.
	(_initialize_cp_valprint): Use user_print_options.  Update.
	* c-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(c_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(c_value_print): Add options argument.  Update.
	* c-lang.h (c_val_print, c_value_print, c_printstr): Update.
	(vtblprint, static_field_print): Don't declare.
	(cp_print_value_fields): Update.
	* c-lang.c (c_printstr): Add options argument.  Update.
	* breakpoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(watchpoint_value_print): Use get_user_print_options.
	(print_one_breakpoint_location): Likewise.
	(breakpoint_1, print_it_catch_fork, print_it_catch_vfork, mention,
	print_exception_catchpoint): Likewise.
	* auxv.c (fprint_target_auxv): Don't declare addressprint.  Use
	get_user_print_options.
	* ada-valprint.c (struct ada_val_print_args): Remove format,
	deref_ref, and pretty; add options.
	(print_optional_low_bound): Add options argument.
	(val_print_packed_array_elements): Remove format and pretty
	arguments; add options.  Update.
	(printstr): Add options argument.  Update.
	(ada_printstr): Likewise.
	(ada_val_print): Remove format, deref_ref, pretty arguments; add
	options argument.  Update.
	(ada_val_print_stub): Update.
	(ada_val_print_array): Remove format, deref_ref, pretty arguments;
	add options.  Update.
	(ada_val_print_1): Likewise.
	(print_variant_part): Likewise.
	(ada_value_print): Remove format, pretty arguments; add options.
	Update.
	(print_record): Likewise.
	(print_field_values): Likewise.
	* ada-lang.h (ada_val_print, ada_value_print, ada_printstr):
	Update.
	* ada-lang.c (ada_print_array_index): Add options argument; remove
	format and pretty arguments.
	(print_one_exception): Use get_user_print_options.
gdb/testsuite
	* gdb.base/exprs.exp (test_expr): Add enum formatting tests.
@
text
@d3 2
a4 2
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
   Free Software Foundation, Inc.
@


1.119
log
@	Convert static_kind into loc_kind enum.
	* gdbtypes.h (enum field_loc_kind): New.
	(union field_location): New field dwarf_block.
	(struct field): Rename static_kind as loc_kind.
	(FIELD_STATIC_KIND): Rename to ...
	(FIELD_LOC_KIND): ... here.
	(TYPE_FIELD_STATIC_KIND): Rename to ...
	(TYPE_FIELD_LOC_KIND): ... here and use there now new FIELD_LOC_KIND.
	(TYPE_FIELD_STATIC_HAS_ADDR): Remove.
	(TYPE_FIELD_STATIC): Remove.
	(TYPE_FIELD_BITPOS): Reformat.
	(SET_FIELD_BITPOS): New.
	(FIELD_PHYSADDR): Rename to ...
	(FIELD_STATIC_PHYSADDR): ... here.
	(TYPE_FIELD_STATIC_PHYSADDR): Follow the FIELD_PHYSADDR rename.
	(SET_FIELD_PHYSADDR): Use new FIELD_LOC_KIND.
	(FIELD_PHYSNAME): Rename to ...
	(FIELD_STATIC_PHYSNAME): ... here.
	(TYPE_FIELD_STATIC_PHYSNAME): Follow the FIELD_PHYSNAME rename.
	(SET_FIELD_PHYSNAME): Use new FIELD_LOC_KIND.
	(FIELD_DWARF_BLOCK, TYPE_FIELD_DWARF_BLOCK, SET_FIELD_DWARF_BLOCK): New.
	(field_is_static): New declaration.
	* gdbtypes.c (field_is_static): New function.
	(copy_type_recursive): Update throughout.
	* amd64-tdep.c, c-typeprint.c, coffread.c, cp-valprint.c, dwarf2read.c,
	eval.c, jv-typeprint.c, jv-valprint.c, mdebugread.c, p-typeprint.c,
	p-valprint.c, valops.c, value.c, varobj.c: Update throughout.
@
text
@d28 1
d1795 1
d1803 3
a1805 2
  common_val_print (value, stb, format_code[(int) format], 1, 0, 0,
		    current_language);
@


1.118
log
@gdb/
	Replace TYPE_ARRAY_{UPPER,LOWER}_BOUND_TYPE by a bit if {un,}defined.
	* c-typeprint.c (c_type_print_varspec_suffix), m2-typeprint.c
	(m2_array), p-typeprint.c (pascal_type_print_varspec_prefix),
	valops.c (value_cast), varobj.c (c_number_of_children): Replace
	TYPE_ARRAY_UPPER_BOUND_TYPE compared to BOUND_CANNOT_BE_DETERMINED by
	TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
	* parse.c (follow_types): Use TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
	* f-valprint.c (f77_get_dynamic_upperbound): Replace with ...
	(f77_get_upperbound): ... this function handling now only
	TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
	(f77_get_dynamic_lowerbound): Replace with ...
	(f77_get_lowerbound): ... this function handling now only
	TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED.
	(f77_get_dynamic_length_of_aggregate, f77_create_arrayprint_offset_tbl):
	Update their callers.
	* eval.c (evaluate_subexp_standard): Update their callers.
	* f-lang.h (f77_get_dynamic_upperbound, f77_get_upperbound)
	(f77_get_dynamic_lowerbound, f77_get_lowerbound): Update their
	prototypes.
	(BOUND_FETCH_OK, BOUND_FETCH_ERROR): Remove.
	* f-typeprint.c (f_type_print_varspec_suffix, f_type_print_base): Remove
	the lower_bound_was_default variable.  Update the
	f77_get_dynamic_upperbound, f77_get_upperbound and
	TYPE_ARRAY_UPPER_BOUND_TYPE calls.
	* gdbtypes.c (print_bound_type): Remove the function.
	(recursive_dump_type): Remove its calls printing UPPER_BOUND_TYPE and
	LOWER_BOUND_TYPE.
	* gdbtypes.h (enum array_bound_type): Remove.
	(struct main_type): Remove the fields upper_bound_type and
	lower_bound_type.  Comment the new overload of the field artificial.
	(TYPE_ARRAY_UPPER_BOUND_TYPE): Replace by ...
	(TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED): ... this macro.
	(TYPE_ARRAY_LOWER_BOUND_TYPE): Replace by ...
	(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED): ... this macro.

gdb/testsuite/
	* gdb.base/maint.exp (maint print type): Remove printing
	UPPER_BOUND_TYPE and LOWER_BOUND_TYPE.
@
text
@d2016 1
a2016 1
      if (TYPE_FIELD_STATIC (type, type_index))
@


1.117
log
@	* varobj.c (varobj_set_display_format): Use xfree.
	* tracepoint.c (stringify_collection_list): Use xfree.
	* remote-fileio.c (remote_fileio_reset): Use xfree.
	* mipsread.c (read_alphacoff_dynamic_symtab): Use xfree.
	* dfp.c (decimal_from_floating): Use xfree, xstrprintf.  Don't use
	asprintf.
	* cp-support.c (mangled_name_to_comp): Use xfree.
@
text
@d1954 1
a1954 1
	  && TYPE_ARRAY_UPPER_BOUND_TYPE (type) != BOUND_CANNOT_BE_DETERMINED)
@


1.116
log
@	* ada-lang.c (ada_coerce_to_simple_array_type): Use builtin_type_int32
	instead of builtin_type_int as default unspecified integral type.
	(ada_index_type, ada_array_bound_from_type, ada_variant_discrim_type,
	assign_component, to_fixed_range_type): Likewise.
	* ada-typeprint.c (print_range, print_range_bound,
	print_range_type_named): Likewise.
	* ada-valprint.c (print_optional_low_bound, ada_val_print_1): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Likewise.
	* gnu-v3-abi.c (gnuv3_get_virtual_fn, gnuv3_baseclass_offset,
	build_gdb_vtable_type): Likewise.
	* jv-lang.c (java_array_type): Likewise.
	* m2-typeprint.c (m2_print_bounds, m2_is_long_set_of_type): Likewise.
	* m2-valprint.c (m2_print_long_set): Likewise.
	* parse.c (follow_types): Likewise.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* valops.c (value_one, value_array, value_string,
	value_bitstring): Likewise.
	* value.c (allocate_repeat_value, value_from_string): Likewise.
	* varobj.c (c_describe_child): Likewise.
	* mt-tdep.c (mt_register_type): Likewise.
	* sh-tdep.c (sh_sh4_build_float_register_type): Likewise.
	* sh64-tdep.c (sh64_build_float_register_type): Likewise.
@
text
@d696 1
a696 1
      free (var->print_value);
@


1.115
log
@	Exited threads.

	* thread.c (enum thread_state): New.
	(thread_state main_thread_running): Delete, in favor of...
	(thread_state main_thread_state): ... this.  Update throughout.
	(clear_thread_inferior_resources): New, split from free_thread.
	(free_thread): Call clear_thread_inferior_resources.
	(init_thread_list): Set main thread to stopped state.
	(add_thread_silent): Take care of PTID reuses.
	(delete_thread): If deleting inferior_ptid or a thread with
	refcount > 0, mark it as exited, but still keep it in the list.
	Only notify of thread exits, if we haven't done so yet.
	(iterate_over_threads): Make it safe to delete threads while
	iterating over them.
	(do_captured_list_thread_ids): Don't account for exited threads.
	(thread_alive): Check for the THREAD_EXITED state, and don't set
	ptid to -1 on exited threads.
	(set_running): Update to account for extra possible states.
	(is_thread_state): New.
	(is_stopped, is_exited): New.
	(is_running): Implement in terms of is_thread_state.
	(any_running): Update.
	(print_thread_info): Update.  Account for exited threads.  Don't
	warn about missed frame restoring here, its done in the cleanup.
	(switch_to_thread): Don't read from a thread that has gone.
	(restore_current_thread): In non-stop mode, do a full context
	switch.
	(restore_selected_frame): Add a frame_level argument.  Rewrite.
	(struct current_thread_cleanup): Add selected_frame_level and
	was_stopped members.
	(do_restore_current_thread_cleanup): Check if thread was stopped
	and still is, and if the target has registers, stack and memory
	before restoring the selected frame.  Don't delete the cleanup
	argument here.
	(restore_current_thread_cleanup_dtor): New.
	(make_cleanup_restore_current_thread): Remove all arguments.
	Rewrite.
	(thread_apply_all_command): Update.  Prune threads.
	(thread_apply_command): Update.
	(thread_command): Account for currently selected exited thread.
	(do_captured_thread_select): Check for a running thread.  Prune
	threads.
	(_initialize_thread): Make "info threads", "thread", "thread
	apply", and "thread apply all" appliable without a selected thread.
	* gdbthread.h (struct thread_info): Replace running_ by state_.
	Add refcount.
	(is_exited, is_stopped): Declare.
	(make_cleanup_restore_current_thread): Remove all arguments.
	* infrun.c: Include "event-top.h".
	(fetch_inferior_event): In non-stop mode, restore selected thread
	and frame after handling the event and running breakpoint
	commands.  Display GDB prompt if needed.
	(normal_stop): In non-stop mode, don't print thread switching
	notice.
	* cli/cli-decode.c (set_cmd_no_selected_thread_ok)
	(get_cmd_no_selected_thread_ok): New.
	* cli/cli-decode.h (CMD_NO_SELECTED_THREAD_OK): New.
	(set_cmd_no_selected_thread_ok, get_cmd_no_selected_thread_ok):
	Declare.
	* cli/cli-cmds.c: Set "pwd", "help", "info", "show" as
	no-selected-thread ok.
	* top.c (execute_command): Check for non no-selected-thread-ok
	commands.
	* linux-nat.c (struct saved_ptids, threads_to_delete)
	(record_dead_thread, prune_lwps): Delete.
	(exit_lwp): Unconditionally delete thread.
	(linux_nat_resume): Remove prune_lwps call.
	* infcmd.c (proceed_thread_callback): Check if !is_stopped instead
	of is_running.  Adjust to make_cleanup_restore_current_thread
	interface change.
	* mi/mi-main.c (mi_cmd_execute): Only allow a few commands if the
	selected thread has exited.
	* inf-loop.c (inferior_event_handler): Don't display the prompt
	here.
	* varobj.c (c_value_of_root): Update.
	* defs.h (make_cleanup_dtor): Declare.
	* utils.c (make_cleanup_dtor): New.

	* Makefile.in (infrun.o): Depend on $(event_top_h).
@
text
@d2075 1
a2075 1
	    value_from_longest (builtin_type_int, (LONGEST) real_index);
@


1.114
log
@	Refactor varobj_update interface.
        * varobj.c (varobj_update): Report changes as vector.  Also
        return not just a list of varobj, but a list of special structures
        that tell what exactly has changed.
        * varobj.h (enum varobj_update_error): Rename to
        varobj_scope_status.
        (struct varobj_update_result_t): New.
        (varobj_update): Adjust prototype.
        * mi/mi-cmd-var.c: Adjust for changes.
@
text
@d2201 1
a2201 2
  back_to = make_cleanup_restore_current_thread (
    inferior_ptid, get_frame_id (deprecated_safe_get_selected_frame ()));
@


1.113
log
@	* varobj.c (varobj_update): Fix comment typo.
	Fix indentation.
@
text
@a1122 3
   Return value: 
    < 0 for error values, see varobj.h.
    Otherwise it is the number of children + parent changed.
d1133 1
a1133 3
int
varobj_update (struct varobj **varp, struct varobj ***changelist,
	       int explicit)
d1144 1
a1144 1
  VEC (varobj_p) *result = NULL;
a1146 3
  /* sanity check: have we been passed a pointer?  */
  gdb_assert (changelist);

d1153 1
a1153 1
    return 0;
d1156 6
a1161 1
    return INVALID;
d1165 3
d1174 3
a1176 6
      
      /* If this is a floating varobj, and its type has changed,
	 then note that it's changed.  */
      if (type_changed)
	VEC_safe_push (varobj_p, result, *varp);
      
d1178 1
a1178 6
	{
	  /* If type_changed is 1, install_new_value will never return
	     non-zero, so we'll never report the same variable twice.  */
	  gdb_assert (!type_changed);
	  VEC_safe_push (varobj_p, result, *varp);
	}
d1181 7
a1187 6
	{
	  /* This means the varobj itself is out of scope.
	     Report it.  */
	  VEC_free (varobj_p, result);
	  return NOT_IN_SCOPE;
	}
d1217 3
a1219 1
	      VEC_safe_push (varobj_p, result, v);
a1224 13
  /* Alloc (changed + 1) list entries.  */
  changed = VEC_length (varobj_p, result);
  *changelist = xmalloc ((changed + 1) * sizeof (struct varobj *));
  cv = *changelist;

  for (i = 0; i < changed; ++i)
    {
      *cv = VEC_index (varobj_p, result, i);
      gdb_assert (*cv != NULL);
      ++cv;
    }
  *cv = 0;

d1226 1
a1226 6
  VEC_free (varobj_p, result);

  if (type_changed)
    return TYPE_CHANGED;
  else
    return changed;
@


1.112
log
@        * valprint.c (val_print): Add new language parameter and use it
        instead of using the current_language. Update calls to val_print
        throughout.
        (common_val_print): Add new langauge parameter and pass it to
        val_print.
        * value.h (struct language_defn): Add opaque declaration.
        (val_print, common_val_print): Update declarations.
        * stack.c (print_frame_args): Update call to common_val_print
        using the appropriate language.
        * mi/mi-cmd-stack.c (list_args_or_locals): Likewise.
        * c-valprint, f-valprint.c, m2-valprint.c, mt-tdep.c, infcmd.c,
        mi/mi-main.c, jv-valprint.c, ada-valprint.c, varobj.c, p-valprint.c,
        scm-valprint.c, cp-valprint.c, sh64-tdep.c, printcmd.c:
        #include "language.h" if necessary.
        Update calls to val_print and common_val_print.
        * Makefile.in (mt-tdep.o, sh64-tdep.o, mi-cmds.o, mi-main.o):
        Update dependencies.
@
text
@d1176 1
a1176 1
	 them note that it's changed.  */
d1180 8
a1187 8
        if (install_new_value ((*varp), new, type_changed))
	  {
	    /* If type_changed is 1, install_new_value will never return
	       non-zero, so we'll never report the same variable twice.  */
	    gdb_assert (!type_changed);
	    VEC_safe_push (varobj_p, result, *varp);
	  }

@


1.111
log
@	* varobj.c (varobj_invalidate): Don't touch floating
	varobjs.
@
text
@d1824 2
a1825 1
  common_val_print (value, stb, format_code[(int) format], 1, 0, 0);
@


1.110
log
@	Fix @@-varobjs.
        * varobj.c (value_of_root): Update the expression for
        floating varobjs.
        * mi/mi-cmd-var.c (varobj_update_one): If type has changed,
        report that.
@
text
@d2776 5
@


1.109
log
@gdb/ChangeLog
2008-04-09  Marc Khouzam  <marc.khouzam@@ericsson.com>

        * mi/mi-cmd-var.c: Include "mi-getopt.h".
        (mi_parse_format): New.  Factored out from mi_cmd_var_set_format.
        (mi_cmd_var_set_format): Use new mi_parse_format.
        (mi_cmd_var_evaluate_expression): Support for -f option to specify
        format.
        * Makefile.in (mi-cmd-var.o): Update dependencies.

        * varobj.h (varobj_get_formatted_value): Declare.
        * varobj.c (my_value_of_variable): Added format parameter.
        (cplus_value_of_variable): Likewise.
        (java_value_of_variable): Likewise.
        (c_value_of_variable): Likewise.  Evaluate expression based
        on format parameter.
        (struct language_specific): Add format parameter to function member
        *value_of_variable.
        (varobj_get_formatted_value): New.
        (varobj_get_value): Added format parameter to method call.

gdb/doc/ChangeLog
2008-04-09  Marc Khouzam  <marc.khouzam@@ericsson.com>

        * gdb.texinfo (GDB/MI Variable Objects): Add anchor to
        -var-set-format.  Add -f option to -var-evaluate-expression.

gdb/testsuite/ChangeLog
2008-04-09  Marc Khouzam  <marc.khouzam@@ericsson.com>

        * gdb.mi/mi2-var-display.exp: Added tests for the new -f
        option of -var-evaluate-expression.
        * gdb.mi/mi2-var-display.exp: Likewise.
@
text
@d1754 10
@


1.108
log
@	* varobj.h (varobj_floating_p): Declare.
	* varobj.c (varobj_floating_p): New.
	* mi/mi-cmd-var.c (mi_cmd_var_update): When passed
	'@@' as the name, update all floating varobjs.
@
text
@d231 2
a232 1
static char *my_value_of_variable (struct varobj *var);
d257 2
a258 1
static char *c_value_of_variable (struct varobj *var);
d278 2
a279 1
static char *cplus_value_of_variable (struct varobj *var);
d297 2
a298 1
static char *java_value_of_variable (struct varobj *var);
d331 2
a332 1
  char *(*value_of_variable) (struct varobj * var);
d866 7
d875 1
a875 1
  return my_value_of_variable (var);
d1792 1
a1792 1
my_value_of_variable (struct varobj *var)
d1795 1
a1795 1
    return (*var->root->lang->value_of_variable) (var);
d2268 1
a2268 1
c_value_of_variable (struct varobj *var)
d2313 7
a2319 1
	    return xstrdup (var->print_value);
d2645 1
a2645 1
cplus_value_of_variable (struct varobj *var)
d2653 1
a2653 1
  return c_value_of_variable (var);
d2728 1
a2728 1
java_value_of_variable (struct varobj *var)
d2730 1
a2730 1
  return cplus_value_of_variable (var);
@


1.107
log
@	* varobj.c (struct varobj_root): Rename use_selected_frame to
	floating, and clarify the meaning.
	(varobj_create, varobj_update,  new_root_variable): Adjust.
	(value_of_root): Don't use type_changed as in variable,
	adjust comment.
	(c_value_of_root): Adjust.
@
text
@d1871 9
@


1.106
log
@        * varobj.c  (struct varobj_root): New component thread_id.
        (varobj_get_thread_id, check_scope): New functions.
        (c_value_of_root): Use check_scope.  Switch to the
	proper thread if necessary.

        * varobj.h (varobj_get_thread_id): New extern.

        * mi/mi-cmd-var.c (print_varobj): Add thread-id field.
@
text
@d78 4
a81 3
  /* If 1, "update" always recomputes the frame & valid block
     using the currently selected frame. */
  int use_selected_frame;
d476 1
a476 1
	var->root->use_selected_frame = 1;
a1160 1
      type_changed = 1;
d1163 1
a1163 1
      /* If this is a "use_selected_frame" varobj, and its type has changed,
d1507 1
a1507 1
  var->root->use_selected_frame = 0;
d1702 9
a1710 10
/* What is the ``struct value *'' of the root variable VAR? 
   TYPE_CHANGED controls what to do if the type of a
   use_selected_frame = 1 variable changes.  On input,
   TYPE_CHANGED = 1 means discard the old varobj, and replace
   it with this one.  TYPE_CHANGED = 0 means leave it around.
   NB: In both cases, var_handle will point to the new varobj,
   so if you use TYPE_CHANGED = 0, you will have to stash the
   old varobj pointer away somewhere before calling this.
   On return, TYPE_CHANGED will be 1 if the type has changed, and 
   0 otherwise. */
d1727 1
a1727 1
  if (var->root->use_selected_frame)
d1747 4
a1750 10
	  if (*type_changed)
	    {
	      tmp_var->obj_name =
		savestring (var->obj_name, strlen (var->obj_name));
	      varobj_delete (var, NULL, 0);
	    }
	  else
	    {
	      tmp_var->obj_name = varobj_gen_name ();
	    }
d2196 1
a2196 1
  if (var->root->valid_block == NULL || var->root->use_selected_frame)
@


1.105
log
@	* thread.c (make_cleanup_restore_current_thread): Make it
	globally visible.
	* gdbthread.h (make_cleanup_restore_current_thread): Declare.
	* varobj.c (varobj_update): Don't save/restore frame.
	(c_value_of_root): Save/restore thread and frame here,
	using make_cleanup_restore_current_thread.
	* Makefile.in: Update dependecies.
@
text
@d71 7
d513 1
d515 1
a515 1
	  select_frame (fi);
d703 13
d2162 23
d2191 1
a2191 1
  int within_scope;
d2205 8
d2215 6
a2220 12
      fi = frame_find_by_id (var->root->frame);
      within_scope = fi != NULL;
      /* FIXME: select_frame could fail */
      if (fi)
	{
	  CORE_ADDR pc = get_frame_pc (fi);
	  if (pc <  BLOCK_START (var->root->valid_block) ||
	      pc >= BLOCK_END (var->root->valid_block))
	    within_scope = 0;
	  else
	    select_frame (fi);
	}	  
@


1.104
log
@        * varobj.c (struct varobj_root): Clarify
        comment on the frame field.
        (varobj_create): Don't set frame if we have no
        block.
@
text
@d34 2
a1115 1
  struct frame_id old_fid;
a1133 4
      /* Save the selected stack frame, since we will need to change it
	 in order to evaluate expressions.  */
      old_fid = get_frame_id (deprecated_safe_get_selected_frame ());
      
a1140 5

      /* Restore selected frame.  */
      fi = frame_find_by_id (old_fid);
      if (fi)
	select_frame (fi);
d2148 2
a2149 1

d2155 2
d2185 2
@


1.103
log
@	* varobj.c (c_value_of_variable): Use xstrdup.
@
text
@d65 2
a66 1
  /* The frame for this expression */
d501 1
a501 1
      if (fi != NULL)
@


1.102
log
@	Update stored rendition of varobj value when format changes.
	* varobj.c (varobj_set_display_format): Recomputed
        print_value.
        (c_value_of_variable): Return print_value.
@
text
@d2255 1
a2255 1
	    return strdup (var->print_value);
@


1.101
log
@	Use vector for varobj_list_children interface.
        * gdb/varobj.c (varobj_list_children): Return vector
        of varobjs.
        * gdb/varobj.h (varobj_list_children): Adjust
        prototype.
        (varobj_p): Declare.  Declare vector thereof.
        * mi/mi-cmd-var.c (mi_cmd_var_list_children): Adjust
        for varobj_list_children change.
	* Makefile.in (varobj_h): Update dependencies.
@
text
@d676 7
d2255 1
a2255 1
	    return value_get_print_value (var->value, var->format);
@


1.100
log
@2008-01-29  Aleksandar Ristovski  <aristovski@@qnx.com>

	* varobj (adjust_value_for_child_access): Added checking for
	returned value from gdb_value_ind.
	(c_describe_child): Likewise.
	(cplus_describe_child): Fixed a typo.
@
text
@a85 4
typedef struct varobj *varobj_p;

DEF_VEC_P (varobj_p);

d717 2
a718 2
int
varobj_list_children (struct varobj *var, struct varobj ***childlist)
a723 6
  /* sanity check: have we been passed a pointer? */
  if (childlist == NULL)
    return -1;

  *childlist = NULL;

d729 1
a729 1
    return -1;
a735 3
  /* List of children */
  *childlist = xmalloc ((var->num_children + 1) * sizeof (struct varobj *));

d738 1
a738 6
      varobj_p existing;

      /* Mark as the end in case we bail out */
      *((*childlist) + i) = NULL;

      existing = VEC_index (varobj_p, var->children, i);
a748 2

      *((*childlist) + i) = existing;
d751 1
a751 4
  /* End of list is marked by a NULL pointer */
  *((*childlist) + i) = NULL;

  return var->num_children;
@


1.99
log
@	Updated copyright notices for most files.
@
text
@d1923 5
a1927 1
	    gdb_value_ind (*value, value);	  
d2121 5
a2125 1
	gdb_value_ind (value, cvalue);
d2426 1
a2426 1
      || TYPE_CODE (type) == TYPE_CODE_STRUCT)
@


1.98
log
@(c_variable_editable, cplus_variable_editable)
(java_variable_editable, variable_editable): Delete.
(varobj_editable_p): Replace above functions with one language
independent function.  Check for an lvalue.
(varobj_get_attributes, varobj_set_value): Use varobj_editable_p.
(struct language_specific): Delete variable_editable field.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.97
log
@	Fix crash when a variable object being deleted
	has any of its children deleted previously.

	* varobj.c (delete_variable_1): Don't recurse
	into deleted children.
@
text
@a223 2
static int variable_editable (struct varobj *var);

a248 2
static int c_variable_editable (struct varobj *var);

a268 2
static int cplus_variable_editable (struct varobj *var);

a286 2
static int java_variable_editable (struct varobj *var);

a318 3
  /* Is VAR editable? */
  int (*variable_editable) (struct varobj * var);

a334 1
   c_variable_editable,
a346 1
   c_variable_editable,
a358 1
   cplus_variable_editable,
a370 1
   java_variable_editable,
d511 1
a511 1
      /* We definitively need to catch errors here.
d844 1
a844 1
  if (var->root->is_valid && variable_editable (var))
d874 4
d879 3
a881 1
  if (var->value != NULL && variable_editable (var))
d883 4
a886 2
      char *s = expression;
      int i;
d888 21
a908 30
      input_radix = 10;		/* ALWAYS reset to decimal temporarily */
      exp = parse_exp_1 (&s, 0, 0);
      if (!gdb_evaluate_expression (exp, &value))
	{
	  /* We cannot proceed without a valid expression. */
	  xfree (exp);
	  return 0;
	}

      /* All types that are editable must also be changeable.  */
      gdb_assert (varobj_value_is_changeable_p (var));

      /* The value of a changeable variable object must not be lazy.  */
      gdb_assert (!value_lazy (var->value));

      /* Need to coerce the input.  We want to check if the
	 value of the variable object will be different
	 after assignment, and the first thing value_assign
	 does is coerce the input.
	 For example, if we are assigning an array to a pointer variable we
	 should compare the pointer with the the array's address, not with the
	 array's content.  */
      value = coerce_array (value);

      /* The new value may be lazy.  gdb_value_assign, or 
	 rather value_contents, will take care of this.
	 If fetching of the new value will fail, gdb_value_assign
	 with catch the exception.  */
      if (!gdb_value_assign (var->value, value, &val))
	return 0;
d910 9
a918 12
      /* If the value has changed, record it, so that next -var-update can
	 report this change.  If a variable had a value of '1', we've set it
	 to '333' and then set again to '1', when -var-update will report this
	 variable as changed -- because the first assignment has set the
	 'updated' flag.  There's no need to optimize that, because return value
	 of -var-update should be considered an approximation.  */
      var->updated = install_new_value (var, val, 0 /* Compare values. */);
      input_radix = saved_input_radix;
      return 1;
    }

  return 0;
a1786 8
/* Is this variable editable? Use the variable's type to make
   this determination. */
static int
variable_editable (struct varobj *var)
{
  return (*var->root->lang->variable_editable) (var);
}

d1818 27
a2216 19
static int
c_variable_editable (struct varobj *var)
{
  switch (TYPE_CODE (get_value_type (var)))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
    case TYPE_CODE_ARRAY:
    case TYPE_CODE_FUNC:
    case TYPE_CODE_METHOD:
      return 0;
      break;

    default:
      return 1;
      break;
    }
}

a2587 9
static int
cplus_variable_editable (struct varobj *var)
{
  if (CPLUS_FAKE_CHILD (var))
    return 0;

  return c_variable_editable (var);
}

a2670 6
static int
java_variable_editable (struct varobj *var)
{
  return cplus_variable_editable (var);
}

@


1.96
log
@	* varobj.c (install_new_value): Don't
	call value_get_print_value when a value is
	lazy.  Update the print_value member in a
	single place.
@
text
@d1295 2
@


1.95
log
@	* varobj.c (struct varobj): Fix comment
	for the type member not to lie when it can be
	NULL.
@
text
@d988 1
d1046 7
d1056 1
a1056 3
  if (initial && changeable)
    var->print_value = value_get_print_value (value, var->format);
  else if (changeable)
a1063 2
	  xfree (var->print_value);
	  var->print_value = value_get_print_value (value, var->format);
a1083 2
	      xfree (var->print_value);
	      var->print_value = value_get_print_value (value, var->format);
a1087 1
	      char *print_value;
a1089 1
	      print_value = value_get_print_value (value, var->format);
d1093 1
a1093 7
		{
		  xfree (var->print_value);
		  var->print_value = print_value;
		  changed = 1;
		}
	      else
		xfree (print_value);
d1102 3
@


1.95.2.1
log
@	Fix crash when a variable object being deleted
 	has any of its children deleted previously.

	* varobj.c (delete_variable_1): Don't recurse
	into deleted children.
@
text
@a1297 2
      if (!child)
	continue;
@


1.94
log
@	Implement -var-info-path-expression.

	* mi/mi-cmds.h (mi_cmd_var_info_path_expression):
	Declare.
	* mi/mi-cmds.c (mi_cmds): Register var-info-path-expression.
	* mi/mi-cmd-var.c (mi_cmd_var_info_path_expression): New.
	* varobj.c (struct varobj): New field 'path_expr'.
	(c_path_expr_of_child, cplus_path_expr_of_child)
	(java_path_expr_of_child): New.
	(struct language_specific): New field path_expr_of_child.
	(varobj_create): Initialize the path_expr field.
	(varobj_get_path_expr): New.
	(new_variable): Initialize the path_expr field.
	(free_variable): Free the path_expr field.
	(adjust_value_for_children_access): New parameter
	WAS_TYPE.
	(c_number_of_children): Adjust.
	(c_describe_child): New parameter CFULL_EXPRESSION.
	Compute full expression.
	(c_value_of_child, c_type_of_child): Adjust.
	(cplus_number_of_children): Adjust.
	(cplus_describe_child): New parameter CFULL_EXPRESSION.
	Compute full expression.
	(cplus_name_of_child, cplus_value_of_child)
	(cplus_type_of_child): Adjust.
	* varobj.h (varobj_get_path_expr): Declare.
@
text
@d113 3
a115 1
  /* The type of this variable. This may NEVER be NULL. */
@


1.93
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d102 4
d241 2
d263 2
d283 2
d312 4
d340 1
d353 1
d366 1
d379 1
d463 1
d508 4
a511 1
      var->name = savestring (expression, strlen (expression));
d829 17
d1499 1
d1548 1
d1889 5
a1893 1
   value is not known.  */
d1896 2
a1897 1
				  struct type **type)
d1901 3
d1924 2
d1942 1
a1942 1
  adjust_value_for_child_access (NULL, &type);
d2038 2
a2039 1
		  char **cname, struct value **cvalue, struct type **ctype)
d2043 2
d2052 6
a2057 2

  adjust_value_for_child_access (&value, &type);
d2077 6
d2102 7
d2123 3
d2133 2
d2143 1
a2143 1
  c_describe_child (parent, index, &name, NULL, NULL);
d2147 8
d2203 1
a2203 1
  c_describe_child (parent, index, NULL, &value, NULL);
d2212 1
a2212 1
  c_describe_child (parent, index, NULL, NULL, &type);
d2302 1
a2302 1
      adjust_value_for_child_access (NULL, &type);
d2329 1
a2329 1
      adjust_value_for_child_access (NULL, &type);
d2400 2
a2401 1
		      char **cname, struct value **cvalue, struct type **ctype)
d2406 2
d2415 2
a2416 1

d2422 2
d2429 2
d2433 1
a2433 1
  adjust_value_for_child_access (&value, &type);
d2438 1
d2473 5
d2488 1
d2495 17
d2559 1
a2559 1
	  /* Value and type are null here.  */
d2564 1
a2564 1
      c_describe_child (parent, index, cname, cvalue, ctype);
d2572 1
a2572 1
  cplus_describe_child (parent, index, &name, NULL, NULL);
d2576 8
d2594 1
a2594 1
  cplus_describe_child (parent, index, NULL, &value, NULL);
d2602 1
a2602 1
  cplus_describe_child (parent, index, NULL, NULL, &type);
d2674 6
@


1.92
log
@2007-08-17  Michael Snyder  <msnyder@@access-company.com>

	* varobj.c (value_of_root): Memory leak.
@
text
@d8 1
a8 1
   the Free Software Foundation; either version 2 of the License, or
d17 1
a17 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.91
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* varobj.c (cplus_describe_child): Guard against null.
	Use "NULL" instead of "0" to initialize pointers.
@
text
@d1744 2
@


1.90
log
@2007-08-08  Michael Snyder  <msnyder@@access-company.com>

	* varobj.c (value_of_root): Move alloc after return to avoid leak.
@
text
@d2318 1
a2318 1
  char *name = 0;
d2399 1
a2399 1
	  char *access = 0;
d2438 2
a2439 1
	  
@


1.89
log
@        * varobj.h (varobj_set_frozen): New
        (varobj_get_frozen): New.
        (varobj_update): New parameter explicit.
        * varobj.c (struct varobj): New fields frozen
        and not_fetched.
        (varobj_set_frozen, varobj_get_frozen): New.
        (install_new_value): Don't fetch values for
        frozen variable object, or children thereof.  Allow
        a frozen variable object to have non-fetched value.
        (varobj_update): Allow updating child variables.
        Don't traverse frozen children.
        (new_variable): Initialize the frozen field.
        (c_value_of_variable): Return NULL for frozen
        variable without any value yet.
        * mi/mi-cmd-var.c (varobj_update_one): New parameter
        'explicit'.
        (mi_cmd_var_create): Output the 'frozen' field,
        as soon as testsuite is adjusted to expect that field.
        (mi_cmd_var_set_frozen): New.
        (mi_cmd_var_update): Pass the 'explicit' parameter to
        varobj_update_one.
        * mi/mi-cmds.c (mi_cmds): Register '-var-set-frozen'.
        * mi/mi-cmds.h (mi_cmd_var_set_frozen): Declare.
@
text
@d1713 1
a1713 1
      old_type = varobj_get_type (var);
d1720 1
@


1.88
log
@        * varobj.c (varobj_create): Keep varobj value
        NULL when evaluating the type.
@
text
@d140 10
d682 20
d948 1
d984 14
a997 1
      if (!gdb_value_fetch_lazy (value))
d1027 10
a1036 3
	  
	  /* Quick comparison of NULL values.  */
	  if (var->value == NULL && value == NULL)
d1066 1
a1066 1
  if (var->value != NULL)
d1069 4
d1089 4
a1092 1
   Only root variables can be updated... 
d1099 2
a1100 1
varobj_update (struct varobj **varp, struct varobj ***changelist)
d1103 1
a1103 1
  int type_changed;
d1118 7
a1124 2
  if (!is_root_p (*varp))
    error (_("Only root variables can be updated"));
d1129 13
a1141 16
  /* Save the selected stack frame, since we will need to change it
     in order to evaluate expressions.  */
  old_fid = get_frame_id (deprecated_safe_get_selected_frame ());

  /* Update the root variable. value_of_root can return NULL
     if the variable is no longer around, i.e. we stepped out of
     the frame in which a local existed. We are letting the 
     value_of_root variable dispose of the varobj if the type
     has changed.  */
  type_changed = 1;
  new = value_of_root (varp, &type_changed);

  /* Restore selected frame.  */
  fi = frame_find_by_id (old_fid);
  if (fi)
    select_frame (fi);
d1143 17
a1159 4
  /* If this is a "use_selected_frame" varobj, and its type has changed,
     them note that it's changed.  */
  if (type_changed)
    VEC_safe_push (varobj_p, result, *varp);
d1161 7
a1167 14
  if (install_new_value ((*varp), new, type_changed))
    {
      /* If type_changed is 1, install_new_value will never return
	 non-zero, so we'll never report the same variable twice.  */
      gdb_assert (!type_changed);
      VEC_safe_push (varobj_p, result, *varp);
    }

  if (new == NULL)
    {
      /* This means the varobj itself is out of scope.
	 Report it.  */
      VEC_free (varobj_p, result);
      return NOT_IN_SCOPE;
d1185 1
a1185 1
	  if (c != NULL)
d1191 1
a1191 1
      if (v != *varp)
d1473 2
d2188 6
@


1.87
log
@(varobj_update): Free temporary vectors.
@
text
@d436 1
a436 1
      struct value *value;
d498 8
a505 3
	/* Error getting the value.  Try to at least get the
	   right type.  */
	value = evaluate_type (var->root->exp);
a506 1
      var->type = value_type (value);
@


1.86
log
@(varobj_update): Remove unused local.  Use gdb_assert
to check changelist is non-NULL.  Call error if the frontend tries
to update a non-root variable.
@
text
@d1145 3
@


1.85
log
@	* frame.c (deprecated_selected_frame): Rename to...
	(selected_frame): ...this.  Make static.
	(get_selected_frame, select_frame): Update.
	* frame.h (deprected_select_frame): Delete.
	(deprecated_safe_get_selected_frame): Update comments.

	* breakpoint.c, cli/cli-cmds.c, f-valprint.c, infcmd.c, inflow.c,
	infrun.c, stack.c, tui/tui-disasm.c, tui/tui-source.c,
	tui/tui-winsource.c, valops.c, varobj.c, findvar.c, macroscope.c,
	parse.c, regcache.h, sh64-tdep.c, tui/tui-hooks.c, tui/tui-win.c,
	tui/tui.c: Replace references to deprecated_selected_frame.
@
text
@a1039 1
  int error = 0;
d1053 1
a1053 2
  if (changelist == NULL)
    return WRONG_PARAM;
a1054 1
  /*  Only root variables can be updated...  */
d1056 1
a1056 2
    /* Not a root var.  */
    return WRONG_PARAM;
@


1.84
log
@2007-02-13  Denis Pilat  <denis.pilat@@st.com>

	* varobj.h (enum varobj_update_error): New enum.
	* varobj.c (struct varobj_root): Add is_valid member.
	(varobj_get_type): Check for invalid varobj.
	(varobj_get_attributes): Likewise.
	(variable_editable):Likewise.
	(varobj_update): Likewise.  Use varobj_update_error.
	(new_root_variable): Set root varobj as valid by default.
	(varobj_invalidate): New function.
	* symfile.c (clear_symtab_users): Use varobj_invalidate.
	* mi/mi-cmd-var.c (varobj_update_one): Change return type to void.
	Use varobj_update_error.
@
text
@d443 1
a443 1
	fi = deprecated_selected_frame;
d490 1
a490 1
	  old_fi = deprecated_selected_frame;
d1067 1
a1067 1
  old_fid = get_frame_id (deprecated_selected_frame);
@


1.83
log
@	* varobj.c (install_new_value): Only call value_get_print_value
	if changeable.
@
text
@d74 4
d749 3
a751 2
     NULL, too.) */
  if (CPLUS_FAKE_CHILD (var))
d786 1
a786 1
  if (variable_editable (var))
d1026 3
a1028 4
   Return value:
    -1 if there was an error updating the varobj
    -2 if the type changed
    Otherwise it is the number of children + parent changed
d1033 2
a1034 2
   returns -2, then it has done this and VARP will be modified
   to point to the new varobj. */
d1053 1
a1053 1
  /* sanity check: have we been passed a pointer? */
d1055 1
a1055 1
    return -1;
d1057 1
a1057 1
  /*  Only root variables can be updated... */
d1059 5
a1063 2
    /* Not a root var */
    return -1;
d1066 1
a1066 1
     in order to evaluate expressions. */
d1073 1
a1073 1
     has changed. */
d1077 1
a1077 1
  /* Restore selected frame */
d1083 1
a1083 1
     them note that it's changed. */
d1100 1
a1100 1
      return -1;
d1105 1
a1105 1
  /* Walk through the children, reconstructing them all. */
d1136 1
a1136 1
  /* Alloc (changed + 1) list entries */
d1150 1
a1150 1
    return -2;
d1419 1
d1703 4
a1706 1
  return (*var->root->lang->value_of_variable) (var);
d2518 41
@


1.82
log
@        * varobj.c (c_value_of_root, c_value_of_child)
        (cplus_describe_child): Don't call release_value.
@
text
@d956 1
a956 1
  if (initial)
@


1.81
log
@        Refactor getting children name, value and type access
        for varobjs in C++.
        * varobj.c (get_type_deref): Remove.
        (adjust_value_for_child_access): New.
        (c_number_of_children): Use the above.
        (c_describe_child): Likewise.
        (enum accessibility): New.
        (match_accessibility): New function.
        (cplus_describe_child): New function.
        (cplus_name_of_child, cplus_value_of_child)
        (cplus_type_of_child): Reimplement in terms
        of cplus_describe_child.
        (cplus_number_of_children): Use
        adjust_value_for_child_access.
@
text
@d2023 2
a2024 7
         expression fails we just want to make val->error = 1 and
         go on */
      if (gdb_evaluate_expression (var->root->exp, &new_val))
	{
	  release_value (new_val);
	}

a2035 2
  if (value != NULL)
    release_value (value);
a2299 1
	      release_value (*cvalue);
@


1.80
log
@        Fix computation of the 'editable' attribute and
        value changeability for for references.
        * varobj.c (get_value_type): New function.
        (c_variable_editable): Use get_value_type.
        (varobj_value_is_changeable): Likewise.
@
text
@a180 2
static struct type *get_type_deref (struct varobj *var);

a1492 20
/* This returns the type of the variable, dereferencing references, pointers
   and references to pointers, too. */
static struct type *
get_type_deref (struct varobj *var)
{
  struct type *type;

  type = get_type (var);

  if (type)
    {
      if (TYPE_CODE (type) == TYPE_CODE_REF)
	type = get_target_type (type);
      if (TYPE_CODE (type) == TYPE_CODE_PTR)
	type = get_target_type (type);
    }

  return type;
}

d1754 45
d1803 2
a1804 1
  struct type *type;
a1805 1
  int children;
d1807 1
a1807 1
  type = get_type (var);
a1808 1
  children = 0;
d1828 4
a1831 4
      /* This is where things get complicated. All pointers have one child.
         Except, of course, for struct and union ptr, which we automagically
         dereference for the user, and function ptrs which have no children.
         We also don't dereference void* as we don't know what to show.
d1836 5
a1840 16

      switch (TYPE_CODE (target))
	{
	case TYPE_CODE_STRUCT:
	case TYPE_CODE_UNION:
	  children = TYPE_NFIELDS (target);
	  break;

	case TYPE_CODE_FUNC:
	case TYPE_CODE_VOID:
	  children = 0;
	  break;

	default:
	  children = 1;
	}
d1906 1
a1906 1
  struct type *type = get_type (parent);
d1915 1
a1915 13
  /* Pointers to structures are treated just like
     structures when accessing children.  */
  if (TYPE_CODE (type) == TYPE_CODE_PTR)
    {
      struct type *target_type = get_target_type (type);
      if (TYPE_CODE (target_type) == TYPE_CODE_STRUCT
	  || TYPE_CODE (target_type) == TYPE_CODE_UNION)
	{
	  if (value)
	    gdb_value_ind (value, &value);	  
	  type = target_type;
	}
    }
d1963 3
d1967 1
a1967 1
	*ctype = get_target_type (type);
d2134 2
a2135 1
      type = get_type_deref (var);
d2161 2
a2162 1
      type = get_type_deref (var->parent);
d2213 21
a2233 2
static char *
cplus_name_of_child (struct varobj *parent, int index)
d2235 2
a2236 1
  char *name;
d2239 8
d2249 2
a2250 2
      /* Looking for children of public, private, or protected. */
      type = get_type_deref (parent->parent);
d2253 6
a2258 1
    type = get_type_deref (parent);
d2260 2
a2261 2
  name = NULL;
  switch (TYPE_CODE (type))
a2262 2
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
d2272 1
d2274 5
d2280 4
a2283 6
	      while (index >= 0)
		{
	  	  if (TYPE_VPTR_BASETYPE (type) == type
	      	      && type_index == TYPE_VPTR_FIELDNO (type))
		    ; /* ignore vptr */
		  else if (TYPE_FIELD_PRIVATE (type, type_index))
a2285 2
		}
	      --type_index;
d2287 18
a2304 1
	  else if (strcmp (parent->name, "protected") == 0)
d2306 2
a2307 10
	      while (index >= 0)
		{
	  	  if (TYPE_VPTR_BASETYPE (type) == type
	      	      && type_index == TYPE_VPTR_FIELDNO (type))
		    ; /* ignore vptr */
		  else if (TYPE_FIELD_PROTECTED (type, type_index))
		    --index;
		  ++type_index;
		}
	      --type_index;
d2309 2
a2310 1
	  else
d2312 1
a2312 11
	      while (index >= 0)
		{
	  	  if (TYPE_VPTR_BASETYPE (type) == type
	      	      && type_index == TYPE_VPTR_FIELDNO (type))
		    ; /* ignore vptr */
		  else if (!TYPE_FIELD_PRIVATE (type, type_index) &&
		      !TYPE_FIELD_PROTECTED (type, type_index))
		    --index;
		  ++type_index;
		}
	      --type_index;
a2313 2

	  name = TYPE_FIELD_NAME (type, type_index);
a2314 3
      else if (index < TYPE_N_BASECLASSES (type))
	/* We are looking up the name of a base class */
	name = TYPE_FIELD_NAME (type, index);
d2317 1
d2319 1
a2319 1
	  cplus_class_num_children(type, children);
d2331 1
a2331 1
	 	name = "public";
d2333 1
a2333 1
	 	name = "private";
d2335 1
a2335 1
	 	name = "protected";
d2341 1
a2341 1
		    name = "private";
d2343 1
a2343 1
		    name = "protected";
d2346 1
a2346 1
	 	name = "protected";
d2350 1
a2350 1
	      name = "protected";
d2356 5
a2361 4
      break;

    default:
      break;
a2362 3

  if (name == NULL)
    return c_name_of_child (parent, index);
d2365 3
a2367 3
      if (name != NULL)
	name = savestring (name, strlen (name));
    }
d2369 5
d2386 2
a2387 69
  struct type *type;
  struct value *value;

  if (CPLUS_FAKE_CHILD (parent))
    type = get_type_deref (parent->parent);
  else
    type = get_type_deref (parent);

  value = NULL;

  if (((TYPE_CODE (type)) == TYPE_CODE_STRUCT) ||
      ((TYPE_CODE (type)) == TYPE_CODE_UNION))
    {
      if (CPLUS_FAKE_CHILD (parent))
	{
	  char *name;
	  struct value *temp = parent->parent->value;

	  if (temp == NULL)
	    return NULL;

	  name = name_of_child (parent, index);
	  gdb_value_struct_elt (NULL, &value, &temp, NULL, name, NULL,
				"cplus_structure");
	  if (value != NULL)
	    release_value (value);

	  xfree (name);
	}
      else if (index >= TYPE_N_BASECLASSES (type))
	{
	  /* public, private, or protected */
	  return NULL;
	}
      else
	{
	  /* Baseclass */
	  if (parent->value != NULL)
	    {
	      struct value *temp = NULL;

	      /* No special processing for references is needed --
		 value_cast below handles references.  */
	      if (TYPE_CODE (value_type (parent->value)) == TYPE_CODE_PTR)
		{
		  if (!gdb_value_ind (parent->value, &temp))
		    return NULL;
		}
	      else
		temp = parent->value;

	      if (temp != NULL)
		{
		  value = value_cast (TYPE_FIELD_TYPE (type, index), temp);
		  release_value (value);
		}
	      else
		{
		  /* We failed to evaluate the parent's value, so don't even
		     bother trying to evaluate this child. */
		  return NULL;
		}
	    }
	}
    }

  if (value == NULL)
    return c_value_of_child (parent, index);

d2394 2
a2395 37
  struct type *type, *t;

  if (CPLUS_FAKE_CHILD (parent))
    {
      /* Looking for the type of a child of public, private, or protected. */
      t = get_type_deref (parent->parent);
    }
  else
    t = get_type_deref (parent);

  type = NULL;
  switch (TYPE_CODE (t))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      if (CPLUS_FAKE_CHILD (parent))
	{
	  char *name = cplus_name_of_child (parent, index);
	  type = lookup_struct_elt_type (t, name, 0);
	  xfree (name);
	}
      else if (index < TYPE_N_BASECLASSES (t))
	type = TYPE_FIELD_TYPE (t, index);
      else
	{
	  /* special */
	  return NULL;
	}
      break;

    default:
      break;
    }

  if (type == NULL)
    return c_type_of_child (parent, index);

@


1.79
log
@Fix 'selected frame' varobjs.
        * varobj.c (struct varobj): Remove the error field.
        (varobj_set_value): Don't check var->error.
        (install_new_value): Don't set var->error.
        (varobj_update): Always pass the new value
        of the root via install_new_value.
        (create_child): Don't set error field.
        (new_variable): Likewise.
        (c_value_of_root): Always reevaluate the value
        of selected frame varobjs in the selected frame.
        Don't call reinit_frame_cache.
@
text
@d179 2
d1464 31
d1759 1
a1759 1
  type = get_type (var);
d2056 1
a2056 1
  switch (TYPE_CODE (get_type (var)))
@


1.78
log
@Copyright updates for 2007.
@
text
@d110 2
a111 1
  /* The value of this expression or subexpression.  This may be NULL. 
a115 3
  /* Did an error occur evaluating the expression or getting its value? */
  int error;

d812 1
a812 1
  if (var->value != NULL && variable_editable (var) && !var->error)
a909 1
  var->error = 0;
a945 1
	  var->error = 1;
a950 2
      else
	var->error = 0;
a1074 6
  if (new == NULL)
    {
      (*varp)->error = 1;
      return -1;
    }

d1088 8
a1368 3
  if ((!CPLUS_FAKE_CHILD (child) && child->value == NULL) || parent->error)
    child->error = 1;

a1388 1
  var->error = 0;
d1967 1
a1967 1
  if (var->root->valid_block == NULL)
a1970 1
      reinit_frame_cache ();
a1991 1
	  var->error = 0;
a1993 2
      else
	var->error = 1;
@


1.77
log
@	* varobj.c (install_new_value): Always update print_value.
	(value_get_print_value): Immediately return NULL for missing
	values.

	* gdb.mi/mi-var-cmd.exp: Expect lpcharacter to update when
	lcharacter or linteger change.  Correct duplicated test name.
	* gdb.mi/mi2-var-cmd.exp: Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
@


1.76
log
@(c_value_of_root): Don't select frame if variable
object is out of scope.
@
text
@d969 1
a969 1
	 -var-update. So need to the varobj as changed.  */	 
d971 5
a975 1
	changed = 1;
d986 5
a990 1
	    changed = 1;
d998 1
d1699 2
a1700 2
  struct ui_file *stb = mem_fileopen ();
  struct cleanup *old_chain = make_cleanup_ui_file_delete (stb);
d1702 7
a1708 1
	    
d1711 1
@


1.75
log
@(struct varobj): New member print_value.
(install_new_value): Compare last printed value with current one
instead of contents.
(new_variable): Initialize var->print_value to NULL.
(free_variable): Free var->print_value.
(value_get_print_value): New function derived from
c_value_of_variable.
(c_value_of_variable): Use value_get_print_value.
@
text
@d1973 2
a1974 1
	  select_frame (fi);
@


1.74
log
@(get_type_deref): Fix variable objects for references to
pointers.
@
text
@d135 3
d212 3
d962 3
a964 1
  if (!initial && changeable)
d985 1
d988 10
a997 3
	      
	      if (!value_contents_equal (var->value, value))
		changed = 1;
d1001 1
a1001 1
    
d1007 1
a1007 1
  
a1011 1
  
d1394 1
d1428 1
d1686 14
a2071 5
	    long dummy;
	    struct ui_file *stb = mem_fileopen ();
	    struct cleanup *old_chain = make_cleanup_ui_file_delete (stb);
	    char *thevalue;

d2074 2
a2075 6
	    common_val_print (var->value, stb,
			      format_code[(int) var->format], 1, 0, 0);
	    thevalue = ui_file_xstrdup (stb, &dummy);
	    do_cleanups (old_chain);
	return thevalue;
      }
@


1.73
log
@	* Makefile.in (eval.o): Update dependencies.
	* eval.c: Include "ui-out.h" and "exceptions.h".
	(evaluate_subexp_standard): Use TRY_CATCH around value_of_variable.
	Use value_zero if an error occurs when avoiding side effects.
	* varobj.c (c_value_of_root): Initialize new_val.

	* gdb.mi/mi-var-cmd.exp: Add tests for unreadable varobjs.
@
text
@d1444 2
a1445 1
/* This returns the type of the variable, dereferencing pointers, too. */
d1453 7
a1459 3
  if (type != NULL && (TYPE_CODE (type) == TYPE_CODE_PTR
		       || TYPE_CODE (type) == TYPE_CODE_REF))
    type = get_target_type (type);
d1734 1
a1734 1
      /* This is where things get compilcated. All pointers have one child.
d1736 1
a1736 1
         dereference for the user and function ptrs, which have no children.
@


1.72
log
@	* varobj.c (varobj_list_children): Stop if the number of children is
	unknown.
	(c_number_of_children): Report no children for zero sized arrays.

	* lib/mi-support.exp (mi_runto_helper): Expect two prompts
	when continuing.
@
text
@d1911 1
a1911 1
  struct value *new_val;
@


1.71
log
@        Simplify access to variours properties of child
        variable objects in C.
        * varobj.c (value_struct_element_index): New function.
        (c_describe_child): New function.
        (c_name_of_child, c_value_of_child)
        (c_type_of_child): Rewrite to use c_describe_child.
@
text
@d688 4
d1718 3
a1720 1
	children = -1;
@


1.70
log
@        gdb/
        * varobj.c: Include "vec.h".
        (varobj_p): New typedef, declare vector of those.
        (struct varobj): Use vector for the 'children' member.
        (child_exists): Remove.
        (save_child_in_parent): Remove.
        (remove_child_from_parent): Remove.
        (struct varobj_child): Remove.
        (struct vstack): Remove.
        (vpush, vpop): Remove.
        (varobj_list_children): Adjust to work work vector.
        (varobj_update): Likewise. Use vectors for
        working stack and result.
        (delete_variable_1): Likewise.
        * Makefile.in (varobj.o): Update dependencies.
@
text
@d1763 47
a1809 2
static char *
c_name_of_child (struct varobj *parent, int index)
d1811 2
a1812 4
  struct type *type;
  struct type *target;
  char *name;
  char *string;
d1814 6
a1819 2
  type = get_type (parent);
  target = get_target_type (type);
d1821 14
d1838 15
a1852 2
      name = xstrprintf ("%d", index
			 + TYPE_LOW_BOUND (TYPE_INDEX_TYPE (type)));
d1857 15
a1871 2
      string = TYPE_FIELD_NAME (type, index);
      name = savestring (string, strlen (string));
d1875 9
a1883 12
      switch (TYPE_CODE (target))
	{
	case TYPE_CODE_STRUCT:
	case TYPE_CODE_UNION:
	  string = TYPE_FIELD_NAME (target, index);
	  name = savestring (string, strlen (string));
	  break;

	default:
	  name = xstrprintf ("*%s", parent->name);
	  break;
	}
d1888 3
a1890 1
      name = xstrdup ("???");
d1892 1
d1894 5
d1957 2
a1958 56
  struct value *value;
  struct value *temp;
  struct value *indval;
  struct type *type, *target;
  char *name;
  int real_index;

  type = get_type (parent);
  target = get_target_type (type);
  name = name_of_child (parent, index);
  temp = parent->value;
  value = NULL;

  if (temp != NULL)
    {
      switch (TYPE_CODE (type))
	{
	case TYPE_CODE_ARRAY:
	  real_index = index + TYPE_LOW_BOUND (TYPE_INDEX_TYPE (type));
#if 0
	  /* This breaks if the array lives in a (vector) register. */
	  value = value_slice (temp, real_index, 1);
	  temp = value_coerce_array (value);
	  gdb_value_ind (temp, &value);
#else
	  indval = value_from_longest (builtin_type_int, (LONGEST) real_index);
	  gdb_value_subscript (temp, indval, &value);
#endif
	  break;

	case TYPE_CODE_STRUCT:
	case TYPE_CODE_UNION:
	  gdb_value_struct_elt (NULL, &value, &temp, NULL, name, NULL,
				"vstructure");
	  break;

	case TYPE_CODE_PTR:
	  switch (TYPE_CODE (target))
	    {
	    case TYPE_CODE_STRUCT:
	    case TYPE_CODE_UNION:
	      gdb_value_struct_elt (NULL, &value, &temp, NULL, name, NULL,
				    "vstructure");
	      break;

	    default:
	      gdb_value_ind (temp, &value);
	      break;
	    }
	  break;

	default:
	  break;
	}
    }

a1961 1
  xfree (name);
d1968 2
a1969 37
  struct type *type;
  char *name = name_of_child (parent, index);

  switch (TYPE_CODE (parent->type))
    {
    case TYPE_CODE_ARRAY:
      type = get_target_type (parent->type);
      break;

    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      type = lookup_struct_elt_type (parent->type, name, 0);
      break;

    case TYPE_CODE_PTR:
      switch (TYPE_CODE (get_target_type (parent->type)))
	{
	case TYPE_CODE_STRUCT:
	case TYPE_CODE_UNION:
	  type = lookup_struct_elt_type (parent->type, name, 0);
	  break;

	default:
	  type = get_target_type (parent->type);
	  break;
	}
      break;

    default:
      /* This should not happen as only the above types have children */
      warning (_("Child of parent whose type does not allow children"));
      /* FIXME: Can we still go on? */
      type = NULL;
      break;
    }

  xfree (name);
@


1.69
log
@        Port from Apple's version.
        gdb/
        * varobj.c (type_changeable): Rename to...
        (varobj_value_is_changeable_p): ...this. Adjust all callers.
        (is_root_p): New function. Use it everywhere.
@
text
@d35 1
d84 4
d124 2
a125 2
  /* A list of this object's children */
  struct varobj_child *children;
a136 23
/* Every variable keeps a linked list of its children, described
   by the following structure. */
/* FIXME: Deprecated.  All should use vlist instead */

struct varobj_child
{

  /* Pointer to the child's data */
  struct varobj *child;

  /* Pointer to the next child */
  struct varobj_child *next;
};

/* A stack of varobjs */
/* FIXME: Deprecated.  All should use vlist instead */

struct vstack
{
  struct varobj *var;
  struct vstack *next;
};

a163 2
static struct varobj *child_exists (struct varobj *, char *);

a165 4
static void save_child_in_parent (struct varobj *, struct varobj *);

static void remove_child_from_parent (struct varobj *, struct varobj *);

a183 4
static void vpush (struct vstack **pstack, struct varobj *var);

static struct varobj *vpop (struct vstack **pstack);

d688 5
d698 2
d703 11
a713 5
      /* check if child exists, if not create */
      name = name_of_child (var, i);
      child = child_exists (var, name);
      if (child == NULL)
	child = create_child (var, i, name);
d715 1
a715 1
      *((*childlist) + i) = child;
d1022 2
a1023 2
  struct vstack *stack = NULL;
  struct vstack *result = NULL;
a1058 3
  /* Initialize a stack for temporary results */
  vpush (&result, NULL);

d1062 1
a1062 4
    {
      vpush (&result, *varp);
      changed++;
    }
d1069 1
a1069 2
      vpush (&result, (*varp));
      changed++;
d1072 1
a1072 10
  /* Initialize a stack */
  vpush (&stack, NULL);

  /* Push the root's children */
  if ((*varp)->children != NULL)
    {
      struct varobj_child *c;
      for (c = (*varp)->children; c != NULL; c = c->next)
	vpush (&stack, c->child);
    }
d1075 1
a1075 2
  v = vpop (&stack);
  while (v != NULL)
d1077 1
a1077 7
      /* Push any children */
      if (v->children != NULL)
	{
	  struct varobj_child *c;
	  for (c = v->children; c != NULL; c = c->next)
	    vpush (&stack, c->child);
	}
d1079 23
a1101 8
      /* Update this variable */
      new = value_of_child (v->parent, v->index);
      if (install_new_value (v, new, 0 /* type not changed */))
 	{
	  /* Note that it's changed */
	  vpush (&result, v);
	  v->updated = 0;
	  changed++;
a1102 3

      /* Get next child */
      v = vpop (&stack);
d1106 1
a1106 2
  /* FIXME: add a cleanup for the allocated list(s)
     because one day the select_frame called below can longjump */
d1108 1
a1108 19
  if (changed > 1)
    {
      templist = xmalloc ((changed + 1) * sizeof (struct varobj *));
      cv = templist;
    }
  else
    cv = *changelist;

  /* Copy from result stack to list */
  vleft = changed;
  *cv = vpop (&result);
  while ((*cv != NULL) && (vleft > 0))
    {
      vleft--;
      cv++;
      *cv = vpop (&result);
    }
  if (vleft)
    warning (_("varobj_update: assertion failed - vleft <> 0"));
d1110 1
a1110 1
  if (changed > 1)
d1112 3
a1114 4
      /* Now we revert the order. */
      for (i = 0; i < changed; i++)
	*(*changelist + i) = *(templist + changed - 1 - i);
      *(*changelist + changed) = NULL;
d1116 1
d1152 1
a1152 2
  struct varobj_child *vc;
  struct varobj_child *next;
d1155 3
a1157 2
  for (vc = var->children; vc != NULL; vc = next)
    {
d1159 2
a1160 4
	vc->child->parent = NULL;
      delete_variable_1 (resultp, delcountp, vc->child, 0, only_children_p);
      next = vc->next;
      xfree (vc);
d1162 1
d1184 1
a1184 1
      remove_child_from_parent (var->parent, var);
a1312 16
/* Does a child with the name NAME exist in VAR? If so, return its data.
   If not, return NULL. */
static struct varobj *
child_exists (struct varobj *var, char *name)
{
  struct varobj_child *vc;

  for (vc = var->children; vc != NULL; vc = vc->next)
    {
      if (strcmp (vc->child->name, name) == 0)
	return vc->child;
    }

  return NULL;
}

a1332 3
  /* Save a pointer to this child in the parent */
  save_child_in_parent (parent, child);

a1349 40

/* FIXME: This should be a generic add to list */
/* Save CHILD in the PARENT's data. */
static void
save_child_in_parent (struct varobj *parent, struct varobj *child)
{
  struct varobj_child *vc;

  /* Insert the child at the top */
  vc = parent->children;
  parent->children =
    (struct varobj_child *) xmalloc (sizeof (struct varobj_child));

  parent->children->next = vc;
  parent->children->child = child;
}

/* FIXME: This should be a generic remove from list */
/* Remove the CHILD from the PARENT's list of children. */
static void
remove_child_from_parent (struct varobj *parent, struct varobj *child)
{
  struct varobj_child *vc, *prev;

  /* Find the child in the parent's list */
  prev = NULL;
  for (vc = parent->children; vc != NULL;)
    {
      if (vc->child == child)
	break;
      prev = vc;
      vc = vc->next;
    }

  if (prev == NULL)
    parent->children = vc->next;
  else
    prev->next = vc->next;

}
a1482 30
vpush (struct vstack **pstack, struct varobj *var)
{
  struct vstack *s;

  s = (struct vstack *) xmalloc (sizeof (struct vstack));
  s->var = var;
  s->next = *pstack;
  *pstack = s;
}

/* FIXME: The following should be generic for any pointer */
static struct varobj *
vpop (struct vstack **pstack)
{
  struct vstack *s;
  struct varobj *v;

  if ((*pstack)->var == NULL && (*pstack)->next == NULL)
    return NULL;

  s = *pstack;
  v = s->var;
  *pstack = (*pstack)->next;
  xfree (s);

  return v;
}

/* FIXME: The following should be generic for any pointer */
static void
@


1.68
log
@	Warning fixes.
	* ada-lang.c (find_struct_field): Initialize *byte_offset_p.
	* breakpoint.c (do_enable_breakpoint): Ignore both mem_cnt and i.
	* c-typeprint.c (c_type_print_varspec_suffix): Don't test length
	greater than or equal to zero.
	* m2-typeprint.c (m2_array): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	* gdbtypes.c (copy_type_recursive): Correct == typo.
	* i386-tdep.c (i386_skip_prologue): Remove stray semicolon.
	* linux-nat.c (linux_nat_info_proc_cmd): Don't compare a pointer
	greater than zero.
	* macroscope.c (sal_macro_scope): Don't name a local variable "main".
	(default_macro_scope): Remove unused variable.
	* prologue-value.h (pv_area_find_reg): Don't name an argument
	"register".
	* remote-fileio.c (remote_fio_func_map): Add missing braces.
	* remote.c (sigint_remote_twice_token, sigint_remote_token): Change
	type.
	(cleanup_sigint_signal_handler): Remove casts.
	* valprint.c (val_print): Use a volatile local for the modified
	argument.
	* varobj.c (languages): Remove extra array dimension.
	(varobj_create): Correct access to languages array.
	* mi/mi-cmd-break.c (mi_cmd_break_insert, mi_cmd_break_watch): Add
	missing braces.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Likewise.
	* mi/mi-cmd-env.c (mi_cmd_env_path, mi_cmd_env_dir): Likewise.
	* mi/mi-getopt.c (mi_valid_noargs): Likewise.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	(mi_cmd_data_write_memory): Likewise.
	* signals/signals.c (target_signal_to_string): Cast to int before
	comparing.
	* tui/tui-layout.c (init_and_make_win): Take and return a void *.
	Update all callers.
@
text
@d106 2
a107 2
     Invariant: if type_changeable (this) is non-zero, the value is either
     NULL, or not lazy.  */
d237 3
a239 1
static int type_changeable (struct varobj *var);
d409 5
d834 1
a834 1
      gdb_assert (type_changeable (var));
d922 1
a922 1
  changeable = type_changeable (var);
d1047 1
a1047 1
  if ((*varp)->root->rootvar != *varp)
d1269 1
a1269 1
  if (var->root->rootvar == var)
d1328 1
a1328 1
  if (var->root->rootvar == var)
d1505 1
a1505 1
  if (var->root->rootvar == var)
d1723 1
a1723 1
  if (var->root->rootvar != var)
d1805 1
a1805 1
type_changeable (struct varobj *var)
d1954 1
a1954 1
  if (var->root->rootvar != var)
d2168 1
a2168 1
	    gdb_assert (type_changeable (var));
@


1.67
log
@	* NEWS: Mention pointer to member improvements.
	* Makefile.in (gnu-v3-abi.o): Delete special rule.
	(eval.o, gnu-v3-abi.o, ia64-tdep.o): Update.
	* ada-valprint.c (ada_print_scalar): Update for new type codes.
	* c-typeprint.c (c_print_type): Update for new type codes.
	(c_type_print_varspec_prefix, c_type_print_varspec_suffix)
	(c_type_print_base): Likewise.
	(c_type_print_args): Rewrite.
	* c-valprint.c (c_val_print): Update for new type codes.  Remove
	support for references to members.  Treat methods like functions.
	* cp-abi.c (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New.
	* cp-abi.h (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New prototypes.
	(struct cp_abi_ops): Add corresponding members.
	* cp-valprint.c (cp_print_class_method): Delete.
	(cp_find_class_member): New function.
	(cp_print_class_member): Use it.  Simplify support for bogus
	member pointers.
	* dwarf2read.c (quirk_gcc_member_function_pointer): Use
	lookup_methodptr_type.
	(read_tag_ptr_to_member_type): Likewise, and lookup_memberptr_type.
	* eval.c (evaluate_subexp_standard): Implement EVAL_SKIP for
	OP_SCOPE.  Update call to value_aggregate_elt.  Rewrite member
	pointer support.
	(evaluate_subexp_for_address): Handle OP_SCOPE explicitly.  Handle
	references returned by user defined operators.
	* f-typeprint.c (f_print_type, f_type_print_varspec_prefix)
	(f_type_print_varspec_suffix): Remove support for member pointers.
	* gdbtypes.c (lookup_memberptr_type): Renamed from lookup_member_type
	and adjusted.
	(smash_to_memberptr_type): Likewise, from smash_to_member_type.
	(lookup_methodptr_type): New.
	(rank_one_type): Adjust for TYPE_CODE_MEMBERPTR.
	(recursive_dump_type): Update for new types.
	* gdbtypes.h (enum type_code): Replace TYPE_CODE_MEMBER with
	TYPE_CODE_MEMBERPTR and TYPE_CODE_METHODPTR.
	(lookup_memberptr_type, lookup_methodptr_type)
	(smash_to_memberptr_type): New prototypes.
	(smash_to_method_type): Formatting fix.
	(lookup_member_type, smash_to_member_type): Delete prototypes.
	* gnu-v3-abi.c (gnuv3_get_vtable, gnuv3_get_virtual_fn): New.
	Do not rely on debug information for the vptr or the method's
	enclosing type.  Handle function descriptors for IA64.
	(gnuv3_virtual_fn_field): Rewrite using the new functions.
	(gnuv3_find_method_in, gnuv3_print_method_ptr)
	(gnuv3_method_ptr_size, gnuv3_make_method_ptr)
	(gnuv3_method_ptr_to_value): New.
	(init_gnuv3_ops): Set new members of gnu_v3_abi_ops.
	* hpread.c (hpread_type_lookup): Update for new types.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-typeprint.c (m2_print_type): Remove explicit support
	for member pointers.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix)
	(pascal_type_print_varspec_suffix, pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_object_print_class_method, pascal_object_print_class_member):
	Delete.
	* p-lang.h (pascal_object_print_class_method)
	(pascal_object_print_class_member): Delete prototypes.
	* stabsread.c (read_type): Update for new types.
	* typeprint.c (print_type_scalar): Likewise.
	* valops.c (value_struct_elt_for_reference, value_namespace_elt)
	(value_maybe_namespace_elt, value_aggregate_elt): Add want_address
	argument.  Construct a pointer to member if the address of a
	function or data member is requested.
	(value_cast_pointers): Don't modify the input value.
	(value_cast): Adjust pointer to member handling for new types.
	Allow null pointer to member constants.  Don't modify the input
	value.
	(value_ind): Remove pointer to member check.  Handle function
	descriptors for function pointers.
	(value_struct_elt, value_find_oload_method_list, check_field):
	Remove pointer to member checks.
	* value.c (unpack_long): Allow pointers to data members.
	(value_from_longest): Allow member pointers.
	* value.h (value_aggregate_elt): Add want_address.
	* varobj.c (c_variable_editable): Remove check for members.
	* gdbarch.sh: Add vtable_function_descriptors and vbit_in_delta.
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): Handle descriptors
	in virtual tables.
	(ia64_gdbarch_init): Call set_gdbarch_vtable_function_descriptors.
	* c-lang.h (cp_print_class_method): Delete prototype.
	* arm-tdep.c (arm_gdbarch_init): Call set_gdbarch_vbit_in_delta.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	* gdbarch.c, gdbarch.h: Regenerated.

	* gdb.cp/classes.exp (test_pointers_to_class_members): Update expected
	output.  Test the types of members and member pointers.
	* gdb.cp/inherit.exp (test_print_mi_member_types): Remove KFAILs for
	gdb/2092.
	* gdb.cp/member-ptr.exp: Search for a comment instead of a
	statement.  Enable for GCC.  Update expected output for some tests
	and add new tests.  Remove obsolete GCC KFAILs.  Allow GCC's class
	layout.
	* gdb.cp/member-ptr.cc (Padding, Padding::vspacer, Base, Base::get_x)
	(Base::vget_base, Left, Left::vget, Right, Right::vget, Diamond)
	(Diamond::vget_base): New.
	(main): Add new tests.
	* gdb.cp/printmethod.exp: Update expected output for member functions.
	* gdb.cp/virtfunc.exp (test_virtual_calls): Add a KFAIL for
	print pEe->D::vg().
@
text
@d329 1
a329 2
static struct language_specific
  languages[vlang_end][sizeof (struct language_specific)] = {
d520 1
a520 1
      var->root->lang = languages[lang];
@


1.66
log
@Include block.h.
(c_value_of_root): Check scope within nested statements.
@
text
@a2108 1
    case TYPE_CODE_MEMBER:
@


1.65
log
@(varobj_update): Ensure frame is restored when
variable object is out of scope.
@
text
@d29 1
d1962 8
a1969 2
      if (within_scope)
	select_frame (fi);
@


1.64
log
@2006-12-08  Vladimir Prus  <vladimir@@codesourcery.com>

        * varobj.c (varobj_create): Don't call release_value.
        (varobj_set_value): Likewise.
        (install_new_value): Call coerce_ref and release_value
        on the value. Add asserts.
@
text
@d1055 6
a1155 5
  /* Restore selected frame */
  fi = frame_find_by_id (old_fid);
  if (fi)
    select_frame (fi);

@


1.63
log
@2006-12-06  Vladimir Prus  <vladimir@@codesourcery.com>

        * varobj.c (cplus_value_of_child): When accessing
        base suboject, don't specially process references.
@
text
@a514 2
      release_value (value);

a515 1

d847 1
a847 3

      release_value (val);
      
d899 4
a902 1
   Return 1 if so, and 0 if the values are equal.  */
d918 9
d995 2
@


1.62
log
@2006-11-29  Vladimir Prus  <vladimir@@codesourcery.com>

        * varobj.c (varobj_set_value): Don't compare the old
        and the new value here.  Don't assign new value here.
        Instead, call install_new_value.
@
text
@d2431 3
a2433 2
	      if (TYPE_CODE (value_type (parent->value)) == TYPE_CODE_PTR
		  || TYPE_CODE (value_type (parent->value)) == TYPE_CODE_REF)
@


1.61
log
@2006-11-28  Vladimir Prus  <vladimir@@codesourcery.com>

        Fetch varobj values from memory in a single place,
        and only fetch the values that are really needed.
        * varobj.c (struct varobj): Clarify comment.
        (my_value_equal): Remove.
        (install_new_value): New function.
        (type_of_child): Remove.
        (varobj_create): Use install_new_value.
        (varobj_set_value): Use value_contents_equal, not
        my_value_equal.
        (varobj_update): Use install_new_value.
        (create_child): Likewise. Inline type_of_child here.
        (value_of_child): Don't fetch the value.
        (c_value_of_root): Likewise.
        (c_value_of_variable): Likewise.
        (type_changeable): Improve comments.
@
text
@a843 3
      if (!value_contents_equal (var->value, value))
        var->updated = 1;

d850 1
a850 1
      value_free (var->value);
d852 8
a859 1
      var->value = val;
@


1.60
log
@gdb/ChangeLog:
2006-05-03  Vladimir Prus  <ghost@@cs.msu.su>

       * varobj.c (c_value_of_variable): Ignore top-level references.
       (Committed by Jim Blandy.)
@
text
@d104 3
a106 1
  /* The value of this expression or subexpression.  This may be NULL. */
a206 2
static int my_value_equal (struct value *, struct value *, int *);

d215 3
a231 2
static struct type *type_of_child (struct varobj *var);

d449 1
d510 8
a517 9
      if (gdb_evaluate_expression (var->root->exp, &var->value))
	{
	  /* no error */
	  release_value (var->value);
	  if (value_lazy (var->value))
	    gdb_value_fetch_lazy (var->value);
	}
      else
	var->value = evaluate_type (var->root->exp);
d519 1
a519 1
      var->type = value_type (var->value);
d829 16
a844 1
      if (!my_value_equal (var->value, value, &error))
d846 5
d894 95
d1058 2
a1059 5
  /* If values are not equal, note that it's changed.
     There a couple of exceptions here, though.
     We don't want some types to be reported as "changed". */
  else if (type_changeable (*varp) &&
	   ((*varp)->updated || !my_value_equal ((*varp)->value, new, &error)))
d1061 4
a1064 2
      vpush (&result, *varp);
      (*varp)->updated = 0;
a1065 2
      /* Its value is going to be updated to NEW.  */
      (*varp)->error = error;
a1067 5
  /* We must always keep around the new value for this root
     variable expression, or we lose the updated children! */
  value_free ((*varp)->value);
  (*varp)->value = new;

d1093 2
a1094 3
      if (type_changeable (v) && 
          (v->updated || !my_value_equal (v->value, new, &error)))
	{
a1099 7
      /* Its value is going to be updated to NEW.  */
      v->error = error;

      /* We must always keep new values, since children depend on it. */
      if (v->value != NULL)
	value_free (v->value);
      v->value = new;
d1360 1
d1367 1
a1367 3
  child->value = value_of_child (parent, index);
  if ((!CPLUS_FAKE_CHILD (child) && child->value == NULL) || parent->error)
    child->error = 1;
d1377 14
a1390 2
  /* Note the type of this child */
  child->type = type_of_child (child);
a1564 36
/* This function is similar to GDB's value_contents_equal, except that
   this one is "safe"; it never longjmps.  It determines if the VAL1's
   value is the same as VAL2.  If for some reason the value of VAR2
   can't be established, *ERROR2 is set to non-zero.  */

static int
my_value_equal (struct value *val1, struct value *volatile val2, int *error2)
{
  volatile struct gdb_exception except;

  /* As a special case, if both are null, we say they're equal.  */
  if (val1 == NULL && val2 == NULL)
    return 1;
  else if (val1 == NULL || val2 == NULL)
    return 0;

  /* The contents of VAL1 are supposed to be known.  */
  gdb_assert (!value_lazy (val1));

  /* Make sure we also know the contents of VAL2.  */
  val2 = coerce_array (val2);
  TRY_CATCH (except, RETURN_MASK_ERROR)
    {
      if (value_lazy (val2))
	value_fetch_lazy (val2);
    }
  if (except.reason < 0)
    {
      *error2 = 1;
      return 0;
    }
  gdb_assert (!value_lazy (val2));

  return value_contents_equal (val1, val2);
}

a1755 10
  /* If we're being lazy, fetch the real value of the variable. */
  if (value != NULL && value_lazy (value))
    {
      /* If we fail to fetch the value of the child, return
         NULL so that callers notice that we're leaving an
         error message. */
      if (!gdb_value_fetch_lazy (value))
	value = NULL;
    }

a1758 14
/* What is the type of VAR? */
static struct type *
type_of_child (struct varobj *var)
{

  /* If the child had no evaluation errors, var->value
     will be non-NULL and contain a valid type. */
  if (var->value != NULL)
    return value_type (var->value);

  /* Otherwise, we must compute the type. */
  return (*var->root->lang->type_of_child) (var->parent, var->index);
}

d1774 9
a1782 3
/* Is VAR something that can change? Depending on language,
   some variable's values never change. For example,
   struct and unions never change values. */
d1958 2
a1959 13
	  if (value_lazy (new_val))
	    {
	      /* We need to catch errors because if
	         value_fetch_lazy fails we still want to continue
	         (after making val->error = 1) */
	      /* FIXME: Shouldn't be using value_contents()?  The
	         comment on value_fetch_lazy() says it is only called
	         from the macro... */
	      if (!gdb_value_fetch_lazy (new_val))
		var->error = 1;
	      else
		var->error = 0;
	    }
a1963 1
      release_value (new_val);
d2142 2
a2143 2
	    if (value_lazy (var->value))
	      gdb_value_fetch_lazy (var->value);
@


1.60.6.1
log
@2006-12-08  Vladimir Prus  <vladimir@@codesourcery.com>

        * varobj.c (cplus_value_of_child): When accessing
        base suboject, don't specially process references.
@
text
@d2382 2
a2383 3
	      /* No special processing for references is needed --
		 value_cast below handles references.  */
	      if (TYPE_CODE (value_type (parent->value)) == TYPE_CODE_PTR)
@


1.59
log
@(c_name_of_child, c_value_of_child): Allow non-zero
offsets for languages like Fortran.
@
text
@d2057 8
a2064 2
  /* BOGUS: if val_print sees a struct/class, it will print out its
     children instead of "{...}" */
d2066 1
a2066 1
  switch (TYPE_CODE (get_type (var)))
@


1.58
log
@Update copyright notice
@
text
@d820 1
a820 3
      if (!gdb_parse_exp_1 (&s, 0, 0, &exp))
	/* We cannot proceed without a well-formed expression. */
	return 0;
d1834 2
a1835 1
      name = xstrprintf ("%d", index);
d1933 1
d1946 1
d1949 1
a1949 1
	  value = value_slice (temp, index, 1);
d1953 1
a1953 1
	  indval = value_from_longest (builtin_type_int, (LONGEST) index);
@


1.58.2.1
log
@Merge XML and VFP support to this branch.
@
text
@d501 1
a501 1
	  old_fi = get_selected_frame (NULL);
@


1.58.2.2
log
@2006-05-03  Paul Brook  <paul@@codesourcery.com>

	* gdb/dwarf2read.c (field_info): Add baseclasses.
	(dwarf2_add_field): Check base classes.
	(dwarf2_attach_fields_to_type): Ditto.

	* gdb/gnu-v3-abi.c (gnuv3_rtti_type): Check for NULL base_type.
	(gnuv3_virtual_fn_field): Handle missing base.
	(gnuv3_baseclass_offset): Handle missing vptr.
	* gdb/varobj.c (cplus_class_num_children): Call fill_in_vptr_fieldno.
	(cplus_name_of_child): Ditto.
	* gdb/eval.c (evaluate_subexp_standard): Ditto.
	* gdb/dwarf2read.c (read_structure_type): Search for vtable pointer
	by name in objects built by ARM compiler.

	* gdb/dwarf2read.c (dwarf2_add_member_fn): Calculate virtual function
	offset for classes without DW_AT_containing_type.
@
text
@a2171 1
  fill_in_vptr_fieldno (type);
a2220 1
	  fill_in_vptr_fieldno (type);
@


1.58.2.3
log
@2006-05-03  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/c-valprint.c: Handle class member typedefs.

	* gdb/symtab.c (skip_prologue_using_sal): Treat two consecutive lines
	at the same address as a prolouge marker.
	* gdb/arm-tdep.c (arm_skip_prologue): Use skip_prologue_using_sal.

	* gdb/dwarf2expr.c (execute_stack_op): Check for bogus DW_OP_reg.

	* gdb/dwarf2read.c (read_structure_type): Use tag name for C++/Java
	classes.

	* Makefile.in (eval.o): Update dependencies.
	* eval.c: Include "ui-out.h" and "exceptions.h".
	(evaluate_subexp_standard): Use TRY_CATCH around value_of_variable.
	Use value_zero if an error occurs when avoiding side effects.
	* varobj.c (varobj_create): Call release_value after evaluate_type.
	(c_value_of_root): Initialize new_val.  Don't release_value a NULL
	value.

	* gdb/c-typeprint.c (cp_type_print_method_args): Don't print type
	details.

	* gdb/dwarf2read.c (dwarf2_debug_line_missing_file_complaint): New
	function.
	(dwarf_decode_lines): Check for line info without a file.
@
text
@d516 1
a516 4
	{
	  var->value = evaluate_type (var->root->exp);
	  release_value (var->value);
	}
d1871 1
a1871 1
  struct value *new_val = NULL;
a1914 2

	  release_value (new_val);
d1919 1
@


1.58.4.1
log
@Add a Debian patch that prevents some bogus "No selected frame" errors.
This needs to go to mainline separately.
@
text
@d501 1
a501 1
	  old_fi = get_selected_frame (NULL);
@


1.57
log
@* doublest.h (DOUBLEST): Use long double only if we can scan
it in.  Undefine HAVE_LONG_DOUBLE otherwise.
(DOUBLEST_FORMAT): New.
* c-exp.y (parse_number): Use it.
* jv-exp.y (parse_number): Likewise.
* objc-exp.y (parse_number): Likewise.
* p-exp.y (parse_number): Likewise.
* varobj.c (free_variable): Silence type-punning warnings.
* tui/tui-data.h (struct tui_list): Change type of list member.
* tui/tui-data.c: Remove no-longer-needed type casts.
(source_windows): Silence type-punning warnings.
* tui/tui-stack.c, tui/tui-win.c, tui/tui-winsource.c: Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
@


1.56
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d1377 1
a1377 1
      free_current_contents ((char **) &var->root->exp);
@


1.55
log
@2005-07-15  Nick Roberts  <nickrob@@snap.net.nz>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* mi/mi-cmds.h (mi_no_values, mi_simple_values, mi_all_values): New
	declarations.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_locals): Use string
	constants instead of literals for MI command options.
	* mi/mi-cmd-var.c (mi_no_values, mi_simple_values, mi_all_values):
	New variables.
	(mi_parse_values_option, mi_print_value_p): New functions.
	(mi_cmd_var_list_children): Use mi_parse_values_option and
	mi_print_value_p.
	(mi_cmd_var_update): Support a PRINT_VALUES option.  Update calls
	to varobj_update_one.
	(varobj_update_one): Take a print_values argument.  Call
	mi_print_value_p.
	* varobj.c (varobj_get_gdb_type): New function.
	* varobj.h (varobj_get_gdb_type): New prototype.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005
d18 2
a19 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.54
log
@2005-04-26  Andrew Cagney  <cagney@@gnu.org>

	Rename 'struct exception' to 'struct gdb_exception'.
	* wrapper.c: Update.
	* varobj.c: Update.
	* tui/tui-interp.c: Update.
	* remote.c: Update.
	* mi/mi-main.c: Update.
	* mi/mi-interp.c: Update.
	* linux-thread-db.c: Update.
	* interps.h: Update.
	* interps.c: Update.
	* exceptions.h: Update.
	* exceptions.c: Update.
	* dwarf2loc.c: Update.
	* cli/cli-interp.c: Update.
	* cli/cli-script.c: Update.
	* breakpoint.c: Update.
@
text
@d3 2
a4 1
   Copyright 1999, 2000, 2001, 2005 Free Software Foundation, Inc.
d764 8
@


1.53
log
@* dwarf2loc.c (dwarf_expr_tls_address): Mark addr as volatile.
* varobj.c (my_value_equal): Mark val2 as volatile.
@
text
@d1455 1
a1455 1
  volatile struct exception except;
@


1.52
log
@	* dwarf2loc.c (loclist_read_variable): Set optimized_out
	instead of reporting an error.
	* valprint.c (value_check_printable): New function.
	(common_val_print): New function.  Use value_check_printable.
	(value_print): Use value_check_printable.
	* value.h (common_val_print): Add prototype.

	* c-valprint.c (c_val_print): Use common_val_print.
	* cp-valprint.c (cp_print_value_fields): Likewise.
	(cp_print_hpacc_virtual_table_entries): Likewise.
	* f-valprint.c (f_val_print): Likewise.
	* jv-valprint.c (java_value_print, java_print_value_fields):
	Likewise.
	* scm-valprint.c (scm_value_print): Likewise.
	* stack.c (print_frame_args): Likewise.
	* varobj.c (c_value_of_variable): Likewise.
	* p-valprint.c (pascal_val_print, pascal_value_print): Likewise.
	(pascal_object_print_value_fields): Likewise.  Update call to
	pascal_object_print_static_field.
	(pascal_object_print_static_field): Remove TYPE argument.  Use
	common_val_print.
@
text
@d1453 1
a1453 1
my_value_equal (struct value *val1, struct value *val2, int *error2)
@


1.51
log
@2005-02-24  Andrew Cagney  <cagney@@gnu.org>

	Add show_VARIABLE functions, update add_setshow call.
	* varobj.c (_initialize_varobj, show_varobjdebug): Add and update.
	* valprint.c (_initialize_valprint, show_print_max)
	(show_stop_print_at_null, show_repeat_count_threshold)
	(show_prettyprint_structs, show_unionprint)
	(show_prettyprint_arrays, show_addressprint, show_input_radix)
	(show_output_radix): Ditto.
	* valops.c (_initialize_valops, show_overload_resolution): Ditto.
	* utils.c (initialize_utils, show_chars_per_line)
	(show_lines_per_page, show_demangle, show_pagination_enabled)
	(show_sevenbit_strings, show_asm_demangle): Ditto
	* tui/tui-win.c (_initialize_tui_win, show_tui_border_kind)
	(show_tui_border_mode, show_tui_active_border_mode): Ditto.
	* top.c (init_main, show_new_async_prompt)
	(show_async_command_editing_p, show_write_history_p)
	(show_history_size, show_history_filename, show_caution)
	(show_annotation_level, init_main): Ditto.
	* target.c (initialize_targets, show_targetdebug)
	(show_trust_readonly): Ditto.
	* symfile.c (_initialize_symfile, show_symbol_reloading)
	(show_ext_args, show_download_write_size)
	(show_debug_file_directory): Ditto.
	* source.c (_initialize_source, show_lines_to_list): Ditto.
	* solib.c (_initialize_solib, show_auto_solib_add)
	(show_solib_search_path): Ditto.
	* p-valprint.c (_initialize_pascal_valprint)
	(show_pascal_static_field_print): Ditto.
	* printcmd.c (_initialize_printcmd, show_max_symbolic_offset)
	(show_print_symbol_filename): Add and update.
	* parse.c (_initialize_parse, show_expressiondebug): Dito.
	* observer.c (_initialize_observer, show_observer_debug): Dito.
	* maint.c (_initialize_maint_cmds, show_watchdog)
	(show_maintenance_profile_p): Dito.
	* linux-nat.c (_initialize_linux_nat, show_debug_linux_nat): Dito.
	* infrun.c (_initialize_infrun, show_debug_infrun)
	(show_stop_on_solib_events, show_follow_fork_mode_string)
	(show_scheduler_mode, show_step_stop_if_no_debug): Ditto.
	* infcall.c (_initialize_infcall, show_coerce_float_to_double_p)
	(show_unwind_on_signal_p): Ditto.
	* gdbtypes.c (build_gdbtypes, show_opaque_type_resolution)
	(_initialize_gdbtypes, show_overload_debug): Ditto.
	* gdb-events.c, gdb-events.sh (_initialize_gdb_events)
	(show_gdb_events_debug): Ditto.
	* gdbarch.c, gdbarch.sh (show_gdbarch_debug)
	(_initialize_gdbarch): Ditto.
	* frame.c (_initialize_frame, show_backtrace_past_main)
	(show_backtrace_past_entry, show_backtrace_limit)
	(show_frame_debug): Ditto.
	* exec.c (_initialize_exec, show_write_files): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read)
	(show_dwarf2_max_cache_age): Ditto.
	* demangle.c (_initialize_demangler)
	(show_demangling_style_names): Ditto.
	* dcache.c (_initialize_dcache, show_dcache_enabled_p): Ditto.
	* cp-valprint.c (show_static_field_print)
	(_initialize_cp_valprint, show_vtblprint, show_objectprint): Ditto.
	* corefile.c (_initialize_core, show_gnutarget_string): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging)
	(show_logging_overwrite, show_logging_redirect)
	(show_logging_filename): Ditto.
	* cli/cli-cmds.c (show_info_verbose, show_history_expansion_p)
	(init_cli_cmds, show_baud_rate, show_remote_debug)
	(show_remote_timeout, show_max_user_call_depth): Ditto.
	* charset.c (show_host_charset_name, show_target_charset_name)
	(initialize_charset): Ditto.
	* breakpoint.c (show_can_use_hw_watchpoints)
	(show_pending_break_support, _initialize_breakpoint): Ditto.
@
text
@d2083 2
a2084 4
	    val_print (value_type (var->value),
		       value_contents_raw (var->value), 0,
		       VALUE_ADDRESS (var->value), stb,
		       format_code[(int) var->format], 1, 0, 0);
@


1.50
log
@* value.h (value_contents_equal): New prototype.
* value.c (value_contents_equal): New function.
* varobj.c: Include "exceptions.h" and "gdb_assert.h".  Don't
include <math.h>.
(varobj_set_value): Initialize error to zero.
(varobj_update): Rename error2 to error and initialize it to zero.
Slightly change the wording of some comments.
(my_value_equal): Reimplement using TRY_CATCH and
value_contents_equal.
@
text
@d37 6
d2554 1
a2554 1
			    NULL, /* FIXME: i18n: */
@


1.49
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_zinteger_cmd through out.  Re-sync gdbarch.sh
	and gdbarch.c.
	* breakpoint.c, frame.c, gdb-events.sh, gdbarch.sh: Update.
	* gdbtypes.c, infrun.c, linux-nat.c, maint.c, monitor.c: Update.
	* pa64solib.c, parse.c, remote-mips.c, ser-go32.c: Update.
	* serial.c, solib-frv.c, somsolib.c, target.c, top.c: Update.
	* varobj.c, cli/cli-cmds.c: Update.
	* gdbarch.c, gdb-events.c: Regenerate.
@
text
@d21 1
d28 2
a30 1
#include <math.h>
a788 1
  int error;
d790 1
d880 1
a883 1
  int error2;
d933 1
a933 1
	   ((*varp)->updated || !my_value_equal ((*varp)->value, new, &error2)))
d938 2
a939 3
      /* error2 replaces var->error since this new value
         WILL replace the old one. */
      (*varp)->error = error2;
d973 1
a973 1
          (v->updated || !my_value_equal (v->value, new, &error2)))
d980 2
a981 3
      /* error2 replaces v->error since this new value
         WILL replace the old one. */
      v->error = error2;
d1441 5
a1445 3
/* This function is similar to gdb's value_equal, except that this
   one is "safe" -- it NEVER longjmps. It determines if the VAR's
   value is the same as VAL2. */
d1449 1
a1449 1
  int r, err1, err2;
d1451 1
a1451 3
  *error2 = 0;
  /* Special case: NULL values. If both are null, say
     they're equal. */
d1457 2
a1458 9
  /* This is bogus, but unfortunately necessary. We must know
     exactly what caused an error -- reading val1 or val2 --  so
     that we can really determine if we think that something has changed. */
  err1 = 0;
  err2 = 0;
  /* We do need to catch errors here because the whole purpose
     is to test if value_equal() has errored */
  if (!gdb_value_equal (val1, val1, &r))
    err1 = 1;
d1460 8
a1467 7
  if (!gdb_value_equal (val2, val2, &r))
    *error2 = err2 = 1;

  if (err1 != err2)
    return 0;

  if (!gdb_value_equal (val1, val2, &r))
d1469 2
a1470 17
      /* An error occurred, this could have happened if
         either val1 or val2 errored. ERR1 and ERR2 tell
         us which of these it is. If both errored, then
         we assume nothing has changed. If one of them is
         valid, though, then something has changed. */
      if (err1 == err2)
	{
	  /* both the old and new values caused errors, so
	     we say the value did not change */
	  /* This is indeterminate, though. Perhaps we should
	     be safe and say, yes, it changed anyway?? */
	  return 1;
	}
      else
	{
	  return 0;
	}
d1472 1
d1474 1
a1474 1
  return r;
@


1.48
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d2562 8
a2569 3
  deprecated_add_show_from_set (add_set_cmd ("debugvarobj", class_maintenance, var_zinteger, (char *) &varobjdebug, "Set varobj debugging.\n\
When non-zero, varobj debugging is enabled.", &setlist),
		     &showlist);
@


1.47
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d579 1
a579 1
    error ("Variable object not found");
d638 1
a638 1
	warning ("varobj_delete: assertion failed - mycount(=%d) <> 0",
d1014 1
a1014 1
    warning ("varobj_update: assertion failed - vleft <> 0");
d1126 1
a1126 1
    error ("Duplicate variable object name");
d2028 1
a2028 1
      warning ("Child of parent whose type does not allow children");
@


1.46
log
@2005-02-02  Andrew Cagney  <cagney@@gnu.org>

	* value.h (value_lazy): Declare.
	* varobj.c, value.c, valops.c, valarith.c, printcmd.c: Update.
	* cp-valprint.c, breakpoint.c, ada-lang.c: Update.
@
text
@d1912 3
a1914 3
	      /* FIXME: Shouldn't be using VALUE_CONTENTS?  The
	         comment on value_fetch_lazy() says it is only
	         called from the macro... */
@


1.45
log
@2005-02-01  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents_all_raw)
	(value_contents_raw): New functions.
	* value.h (VALUE_CONTENTS_ALL_RAW, VALUE_CONTENTS_RAW): Delete.
	(value_contents_raw, value_contents_all_raw): Declare functions.
	(VALUE_CONTENTS, VALUE_CONTENTS_ALL): Update.
	* std-regs.c, valarith.c, valops.c, eval.c: Update.
	* tracepoint.c, findvar.c: Update.
@
text
@d503 1
a503 1
	  if (VALUE_LAZY (var->value))
d1689 1
a1689 1
  if (value != NULL && VALUE_LAZY (value))
d1907 1
a1907 1
	  if (VALUE_LAZY (new_val))
d2095 1
a2095 1
	    if (VALUE_LAZY (var->value))
@


1.44
log
@Index: ChangeLog
2005-01-14  Andrew Cagney  <cagney@@gnu.org>

	* varobj.c (varobj_create): Add missing \n.

Index: testsuite/ChangeLog
2005-01-14  Andrew Cagney  <cagney@@gnu.org>

	* gdb.mi/mi-var-cmd.exp: Adjust "create int" test to match output.
	* gdb.mi/mi2-var-cmd.exp: Ditto.
@
text
@d2098 1
a2098 1
		       VALUE_CONTENTS_RAW (var->value), 0,
@


1.43
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_TYPE, VALUE_NEXT, VALUE_OFFSET, VALUE_BITSIZE)
	(VALUE_BITPOS): Delete.
	(value_type, value_offset, value_bitsize, value_bitpos): Declare.
	* value.c (value_type, value_offset, value_bitpos)
	(value_bitsize): New functions.  Update references.
	* arm-tdep.c, gnu-v3-abi.c, hpacc-abi.c, gnu-v2-abi.c: Update.
	* f-valprint.c, cp-valprint.c, c-valprint.c: Update.
	* ada-valprint.c, typeprint.c, scm-valprint.c, scm-exp.c: Update.
	* p-valprint.c, jv-valprint.c, jv-lang.c, varobj.c: Update.
	* objc-lang.c, ada-lang.c, std-regs.c, stack.c: Update.
	* infcall.c, linespec.c, printcmd.c, valarith.c: Update.
	* valops.c, eval.c, findvar.c, breakpoint.c: Update.
	* tracepoint.c, ax-gdb.c, mi/mi-main.c, cli/cli-dump.c:
	* rs6000-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d476 2
a477 2
	  fprintf_unfiltered (gdb_stderr,
			      "Attempt to use a type name as an expression.");
@


1.42
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d508 1
a508 1
      var->type = VALUE_TYPE (var->value);
d747 1
a747 1
  type_print (VALUE_TYPE (val), "", stb, -1);
d1708 1
a1708 1
    return VALUE_TYPE (var->value);
d2096 1
a2096 1
	    val_print (VALUE_TYPE (var->value),
d2381 2
a2382 2
	      if (TYPE_CODE (VALUE_TYPE (parent->value)) == TYPE_CODE_PTR
		  || TYPE_CODE (VALUE_TYPE (parent->value)) == TYPE_CODE_REF)
@


1.41
log
@2004-06-26  Andrew Cagney  <cagney@@gnu.org>

	* xcoffsolib.c (xcoff_solib_address): Replace xasprintf with
	xstrprintf.
	* varobj.c (varobj_gen_name, create_child, c_name_of_child)
	(c_value_of_variable): Ditto.
	* utils.c (internal_vproblem): Ditto.
	* solib-aix5.c (build_so_list_from_mapfile): Ditto.
	* remote.c (add_packet_config_cmd): Ditto.
	* remote-rdp.c (rdp_set_command_line): Ditto.
	* regcache.c (regcache_dump): Ditto.
	* frv-tdep.c (new_variant, new_variant): Ditto.
	* fbsd-proc.c (child_pid_to_exec_file): Ditto.
	(fbsd_find_memory_regions): Ditto.
	* breakpoint.c (create_thread_event_breakpoint)
	(create_breakpoints): Ditto.
	* aix-thread.c (aix_thread_pid_to_str): Ditto.
	* ada-lang.c (is_package_name): Ditto.  Also delete xmalloc call.

Index: doc/ChangeLog
2004-06-26  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Coding): Replace xasprintf with xstrprintf.
@
text
@d2561 1
a2561 1
  add_show_from_set (add_set_cmd ("debugvarobj", class_maintenance, var_zinteger, (char *) &varobjdebug, "Set varobj debugging.\n\
@


1.40
log
@	* arm-tdep.c: Include frame-unwind.h, frame-base.h, and
	trad-frame.h.
	(arm_get_cache): Delete macro.
	(struct arm_prologue_cache): Update comments.  Make saved_regs into
	a trad_frame_saved_reg pointer.  Remove unwound_pc; rename unwound_sp
	to prev_sp.
	(thumb_scan_prologue): Update for cache changes.  Don't call
	DEPRECATED_PC_IN_CALL_DUMMY.
	(arm_scan_prologue): Update for cache changes.  Take NEXT_FRAME
	argument and use it in desperation search for our prologue.  Do not
	search past the specified PC.
	(arm_make_prologue_cache): Simplify.

	(arm_prologue_this_id, arm_prologue_prev_register)
	(arm_prologue_unwind, arm_prologue_unwind_sniffer)
	(arm_normal_frame_base, arm_normal_base, arm_make_sigtramp_cache)
	(arm_sigtramp_this_id, arm_sigtramp_prev_register)
	(arm_sigtramp_unwind, arm_sigtramp_unwind_sniffer)
	(arm_unwind_dummy_id, arm_unwind_pc, arm_unwind_sp): New.

	(arm_frame_chain_valid, arm_find_callers_reg)
	(arm_frame_saved_pc, arm_read_fp, arm_frame_init_saved_regs)
	(arm_pop_frame): Delete obsolete methods.
	(arm_minimal_frame_chain, arm_minimal_frame_info): Delete.

	(arm_gdbarch_init): Update for new frame methods.  Register prologue
	and sigtramp unwinders.  Set the default frame base method.

	* Makefile.in (arm-tdep.o): Update dependencies.
	* varobj.c (find_frame_addr_in_frame_chain): Call
	get_frame_base_address.
	* std-regs.c (value_of_builtin_frame_fp_reg): Likewise.
@
text
@d552 1
a552 1
  xasprintf (&obj_name, "var%d", id);
d1257 1
a1257 1
  xasprintf (&childs_name, "%s.%s", parent->obj_name, name);
d1840 1
a1840 1
      xasprintf (&name, "%d", index);
d1859 1
a1859 1
	  xasprintf (&name, "*%s", parent->name);
d2073 1
a2073 1
	xasprintf (&number, "[%d]", var->num_children);
@


1.40.10.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d552 1
a552 1
  obj_name = xstrprintf ("var%d", id);
d1257 1
a1257 1
  childs_name = xstrprintf ("%s.%s", parent->obj_name, name);
d1840 1
a1840 1
      name = xstrprintf ("%d", index);
d1859 1
a1859 1
	  name = xstrprintf ("*%s", parent->name);
d2073 1
a2073 1
	number = xstrprintf ("[%d]", var->num_children);
d2561 1
a2561 1
  deprecated_add_show_from_set (add_set_cmd ("debugvarobj", class_maintenance, var_zinteger, (char *) &varobjdebug, "Set varobj debugging.\n\
@


1.40.16.1
log
@2004-03-23  Elena Zannoni  <ezannoni@@redhat.com>

       * solib-svr4.c (svr4_solib_create_inferior_hook): Disable
       breakpoints at startup.
       (elf_locate_base): Find out where the entry point for the program
       is, using the auxv vector, if possible. Compute the address of
       .dynamic using it.
       (svr4_current_sos): Don't ignore the first entry if we have PIE,
       it's our main program. Delete code that was skipping over the
       solib entry for main executable.
       * solist.h (struct so_list): Add fields main and main_relocated.
        (add_to_target_sections): Export.
       * solib.c (symbol_add_stub): Handle main executable in shared
       library list. Ignore it if it has been relocated already. Add it
       as the main symbol file, otherwise.
       * infrun.c (handle_inferior_event): Re-enable startup breakpoints.

       * solib-svr4.c (elf_locate_base, first_link_map_member)
       svr4_current_sos, enable_break): Add debugging output.
       * solist.h (debug_solib): Export.
       * solib.c (debug_solib): New variable to enable debugging output.
       (symbol_add_stub, update_solib_list, update_solib_list)
       (add_to_target_sections): Add debugging output.
       (_initialize_solib): Add new comand to enable printing of
       debugging output.
       (add_to_target_sections): New function. Factored out from
       update_solib_list.
       (update_solib_list): Call add_to_target_sections.

       * varobj.h (varobj_refresh): New prototype.
       * varobj.c (varobj_refresh): New function.
       * symfile.c (reread_symbols): Make sure that we recompute the
       entry point for the program.
       (symbol_file_clear): Clear the solibs as well, if we change symbol
       files.
       (clear_symtab_users): Refresh the varobjs that depend on the symtabs
       we are clearing.
       * objfiles.c (entry_point_address): Rewrite, to fetch entry point
       from auxv vector, if possible.
       Add include of elf/common.h.
       * breakpoint.h (enum bptype): Add bp type bp_startup_disabled.
       (re_enable_breakpoints_at_startup)
       (disable_breakpoints_at_startup): Add prototypes
       * breakpoint.c (re_enable_breakpoints_at_startup)
       (disable_breakpoints_at_startup): New functions.
       (describe_other_breakpoints, delete_breakpoint)
       (breakpoint_re_set_one): Handle new bp type.
       * auxv.h (target_auxv_parse, target_auxv_search): Update.
       * auxv.c (target_auxv_parse, target_auxv_search)
       (fprint_target_auxv): Use ULONGEST instead of CORE_ADDR for
       variable. Change variable name to at_type.
@
text
@a856 56
void
varobj_refresh (void)
{
  struct varobj *var;
  struct varobj_root *croot;
  int mycount = rootcount;
  char * name;
                                                                                
  croot = rootlist;
  while ((croot != NULL) && (mycount > 0))
    {
      var = croot->rootvar;
                                                                                
      /* Get rid of the memory for the old expression.  This also
         leaves var->root->exp == NULL, which is ok for the parsing
         below.  */
      free_current_contents ((char **) &var->root->exp);
                                                                                
      value_free (var->value);
      var->type = NULL;

      name = xstrdup (var->name);

      /* Reparse the expression.  Wrap the call to parse expression,
         so we can return a sensible error. */
      if (!gdb_parse_exp_1 (&name, var->root->valid_block, 0, &var->root->exp))
        {
          return;
        }
                                                                                
      /* We definitively need to catch errors here.
         If evaluate_expression succeeds we got the value we wanted.
         But if it fails, we still go on with a call to evaluate_type()  */
      if (gdb_evaluate_expression (var->root->exp, &var->value))
        {
          /* no error */
          release_value (var->value);
          if (VALUE_LAZY (var->value))
            gdb_value_fetch_lazy (var->value);
        }
      else
        var->value = evaluate_type (var->root->exp);
                                                                                
      var->type = VALUE_TYPE (var->value);
                                                                                
      mycount--;
      croot = croot->next;
    }
                                                                                
  if (mycount || (croot != NULL))
    warning
      ("varobj_refresh: assertion failed - wrong tally of root vars (%d:%d)",
       rootcount, mycount);
}
                                                                                

@


1.39
log
@	* varobj.c (get_type, get_target_type): Use check_typedef.
@
text
@d415 1
a415 1
      if (get_frame_base (frame) == frame_addr)
@


1.38
log
@2002-12-03  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (get_frame_id): Convert to a function.
	(null_frame_id, frame_id_p): Declare.
	(frame_id_eq, frame_id_inner): Declare.
	(frame_id_build): New function.
	* frame.c (get_frame_id): Update.  Use null_frame_id.
	(frame_find_by_id): Rewrite using frame_id_p, frame_id_eq and
	frame_id_inner.
	(null_frame_id, frame_id_p): Define.
	(frame_id_eq, frame_id_inner): Define.
	(frame_id_build): New function.
	* varobj.c (varobj_create): Update.
	(varobj_update): Update.
	* valops.c (value_assign): Update.
	(new_root_variable): Update.
	* infrun.c (save_inferior_status): Update.
	* breakpoint.c (watch_command_1): Update.
@
text
@d1382 2
a1383 3
/* This returns the type of the variable. This skips past typedefs
   and returns the real type of the variable. It also dereferences
   pointers and references.
d1393 2
a1394 2
  while (type != NULL && TYPE_CODE (type) == TYPE_CODE_TYPEDEF)
    type = TYPE_TARGET_TYPE (type);
d1425 2
a1426 2
      while (type != NULL && TYPE_CODE (type) == TYPE_CODE_TYPEDEF)
	type = TYPE_TARGET_TYPE (type);
@


1.38.28.1
log
@Snap const char * mess.
@
text
@d436 1
a436 1
      const char *p;
d798 1
a798 1
      const char *s = expression;
@


1.37
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d490 1
a490 1
	  get_frame_id (fi, &var->root->frame);
d901 1
a901 1
  get_frame_id (deprecated_selected_frame, &old_fid);
d1347 1
a1347 2
  var->root->frame.base = 0;
  var->root->frame.pc = 0;
@


1.36
log
@2002-11-24  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* varobj.c (find_frame_addr_in_frame_chain):
	Use get_frame_base instead of FRAME_FP,
	obvious fix.
@
text
@d444 1
a444 1
	fi = selected_frame;
d491 1
a491 1
	  old_fi = selected_frame;
d901 1
a901 1
  get_frame_id (selected_frame, &old_fid);
@


1.35
log
@2002-11-23  Andrew Cagney  <ac131313@@redhat.com>

	* blockframe.c (find_frame_addr_in_frame_chain): Move function
	from here ...
	* varobj.c (find_frame_addr_in_frame_chain): ... to here.
	(varobj_create): Note that frame ID should be used.
	* frame.h (find_frame_addr_in_frame_chain): Delete declaration.
@
text
@d415 1
a415 1
      if (FRAME_FP (frame) == frame_addr)
@


1.34
log
@
2002-11-05  Jeff Johnston  <jjohnstn@@redhat.com>

        * varobj.c (child_exists, cplus_number_of_children): Change
        STREQ macro references to strcmp.
        (cplus_name_of_child): Change code to handle the fact that
        fields are not necessarily contiguous with regards to their
        access control. This is a fix for PR gdb/792.
@
text
@d399 21
d446 6
@


1.33
log
@
2002-10-23  Jeff Johnston  <jjohnstn@@redhat.com>

        * NEWS: add recent mi fixes.
        * varobj.c (struct varobj): Add new "updated" flag.
        (new_variable): Default "updated" flag to 0.
        (varobj_set_value): Set "updated" flag to 1 if value
        changes.
        (varobj_update): Check varobj "updated" flag before
        comparing old and refreshed values.  Fix for
        PR gdb/702.
@
text
@d1206 1
a1206 1
      if (STREQ (vc->child->name, name))
d2126 1
a2126 1
      if (STREQ (var->name, "public"))
d2128 1
a2128 1
      else if (STREQ (var->name, "private"))
a2178 1
  int children[3];
a2192 2
      cplus_class_num_children (type, children);

d2195 47
a2241 15
	  int i;

	  /* Skip over vptr, if it exists. */
	  if (TYPE_VPTR_BASETYPE (type) == type
	      && index >= TYPE_VPTR_FIELDNO (type))
	    index++;

	  /* FIXME: This assumes that type orders
	     inherited, public, private, protected */
	  i = index + TYPE_N_BASECLASSES (type);
	  if (STREQ (parent->name, "private")
	      || STREQ (parent->name, "protected"))
	    i += children[v_public];
	  if (STREQ (parent->name, "protected"))
	    i += children[v_private];
d2243 1
a2243 1
	  name = TYPE_FIELD_NAME (type, i);
d2246 1
d2250 3
d2254 4
a2257 1
	     only be "public", "private", or "protected" */
d2262 7
a2268 5
	      if (children[v_public] != 0)
		{
		  name = "public";
		  break;
		}
d2270 1
a2270 1
	      if (children[v_private] != 0)
d2272 4
a2275 2
		  name = "private";
		  break;
d2277 3
d2281 3
a2283 5
	      if (children[v_protected] != 0)
		{
		  name = "protected";
		  break;
		}
@


1.32
log
@        * varobj.c (c_type_of_child): Use get_target_type instead
        of TYPE_TARGET_TYPE.
@
text
@d114 3
d759 1
d785 2
d902 2
a903 2
  else if (type_changeable (*varp)
	   && !my_value_equal ((*varp)->value, new, &error2))
d906 1
d943 2
a944 1
      if (type_changeable (v) && !my_value_equal (v->value, new, &error2))
d948 1
d1306 1
@


1.32.2.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a113 3

  /* Was this variable updated via a varobj_set_value operation */
  int updated;
a755 1
  int error;
a780 2
      if (!my_value_equal (var->value, value, &error))
        var->updated = 1;
d896 2
a897 2
  else if (type_changeable (*varp) &&
	   ((*varp)->updated || !my_value_equal ((*varp)->value, new, &error2)))
a899 1
      (*varp)->updated = 0;
d936 1
a936 2
      if (type_changeable (v) && 
          (v->updated || !my_value_equal (v->value, new, &error2)))
a939 1
	  v->updated = 0;
a1296 1
  var->updated = 0;
@


1.32.2.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a398 21
/* Return the full FRAME which corresponds to the given CORE_ADDR
   or NULL if no FRAME on the chain corresponds to CORE_ADDR.  */

static struct frame_info *
find_frame_addr_in_frame_chain (CORE_ADDR frame_addr)
{
  struct frame_info *frame = NULL;

  if (frame_addr == (CORE_ADDR) 0)
    return NULL;

  while (1)
    {
      frame = get_prev_frame (frame);
      if (frame == NULL)
	return NULL;
      if (get_frame_base_address (frame) == frame_addr)
	return frame;
    }
}

d423 1
a423 1
	fi = deprecated_selected_frame;
a424 6
	/* FIXME: cagney/2002-11-23: This code should be doing a
	   lookup using the frame ID and not just the frame's
	   ``address''.  This, of course, means an interface change.
	   However, with out that interface change ISAs, such as the
	   ia64 with its two stacks, won't work.  Similar goes for the
	   case where there is a frameless function.  */
d463 2
a464 2
	  var->root->frame = get_frame_id (fi);
	  old_fi = deprecated_selected_frame;
d874 1
a874 1
  old_fid = get_frame_id (deprecated_selected_frame);
d1206 1
a1206 1
      if (strcmp (vc->child->name, name) == 0)
d1320 2
a1321 1
  var->root->frame = null_frame_id;
d1356 3
a1358 2
/* This returns the type of the variable. It also skips past typedefs
   to return the real type of the variable.
d1368 2
a1369 2
  if (type != NULL)
    type = check_typedef (type);
d1400 2
a1401 2
      if (type != NULL)
	type = check_typedef (type);
d2126 1
a2126 1
      if (strcmp (var->name, "public") == 0)
d2128 1
a2128 1
      else if (strcmp (var->name, "private") == 0)
d2179 1
d2194 2
d2198 15
a2212 47
	  /* The fields of the class type are ordered as they
	     appear in the class.  We are given an index for a
	     particular access control type ("public","protected",
	     or "private").  We must skip over fields that don't
	     have the access control we are looking for to properly
	     find the indexed field. */
	  int type_index = TYPE_N_BASECLASSES (type);
	  if (strcmp (parent->name, "private") == 0)
	    {
	      while (index >= 0)
		{
	  	  if (TYPE_VPTR_BASETYPE (type) == type
	      	      && type_index == TYPE_VPTR_FIELDNO (type))
		    ; /* ignore vptr */
		  else if (TYPE_FIELD_PRIVATE (type, type_index))
		    --index;
		  ++type_index;
		}
	      --type_index;
	    }
	  else if (strcmp (parent->name, "protected") == 0)
	    {
	      while (index >= 0)
		{
	  	  if (TYPE_VPTR_BASETYPE (type) == type
	      	      && type_index == TYPE_VPTR_FIELDNO (type))
		    ; /* ignore vptr */
		  else if (TYPE_FIELD_PROTECTED (type, type_index))
		    --index;
		  ++type_index;
		}
	      --type_index;
	    }
	  else
	    {
	      while (index >= 0)
		{
	  	  if (TYPE_VPTR_BASETYPE (type) == type
	      	      && type_index == TYPE_VPTR_FIELDNO (type))
		    ; /* ignore vptr */
		  else if (!TYPE_FIELD_PRIVATE (type, type_index) &&
		      !TYPE_FIELD_PROTECTED (type, type_index))
		    --index;
		  ++type_index;
		}
	      --type_index;
	    }
d2214 1
a2214 1
	  name = TYPE_FIELD_NAME (type, type_index);
a2216 1
	/* We are looking up the name of a base class */
a2219 3
	  int children[3];
	  cplus_class_num_children(type, children);

d2221 1
a2221 4
	     only be "public", "private", or "protected"

	     The special "fake" children are always output by varobj in
	     this order. So if INDEX == 2, it MUST be "protected". */
d2226 5
a2230 7
	      if (children[v_public] > 0)
	 	name = "public";
	      else if (children[v_private] > 0)
	 	name = "private";
	      else 
	 	name = "protected";
	      break;
d2232 1
a2232 1
	      if (children[v_public] > 0)
d2234 2
a2235 4
		  if (children[v_private] > 0)
		    name = "private";
		  else
		    name = "protected";
a2236 3
	      else if (children[v_private] > 0)
	 	name = "protected";
	      break;
d2238 5
a2242 3
	      /* Must be protected */
	      name = "protected";
	      break;
@


1.31
log
@Fri Aug  2 15:53:50 2002  Andrew Cagney  <cagney@@redhat.com>

* gdbarch.sh: Include "gdb_string.h".
* gdbarch.c: Regenerate.

* regcache.c: Include "gdb_string.h".
* ax-general.c: Ditto.
* varobj.c: Ditto.
* std-regs.c: Ditto.
* fbsd-proc.c: Ditto.
* thread.c: Ditto.

* Makefile.in (regcache.o): Update dependencies.
(thread.o, gdbarch.o): Ditto.
(ax-general.o, gdbarch.o): Ditto.
(varobj.o, std-regs.o): Ditto.
(fbsd-proc.o): Specify dependencies.
@
text
@d1348 4
a1351 1
   pointers and references. */
d1380 4
a1383 1
   past typedefs, just like get_type (). */
d1968 1
a1968 1
      type = TYPE_TARGET_TYPE (parent->type);
d1977 1
a1977 1
      switch (TYPE_CODE (TYPE_TARGET_TYPE (parent->type)))
d1985 1
a1985 1
	  type = TYPE_TARGET_TYPE (parent->type);
@


1.31.8.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d1348 1
a1348 4
   pointers and references.

   NOTE: TYPE_TARGET_TYPE should NOT be used anywhere in this file
   except within get_target_type and get_type. */
d1377 1
a1377 4
   past typedefs, just like get_type ().

   NOTE: TYPE_TARGET_TYPE should NOT be used anywhere in this file
   except within get_target_type and get_type. */
d1962 1
a1962 1
      type = get_target_type (parent->type);
d1971 1
a1971 1
      switch (TYPE_CODE (get_target_type (parent->type)))
d1979 1
a1979 1
	  type = get_target_type (parent->type);
@


1.31.8.2
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@a113 3

  /* Was this variable updated via a varobj_set_value operation */
  int updated;
a755 1
  int error;
a780 2
      if (!my_value_equal (var->value, value, &error))
        var->updated = 1;
d896 2
a897 2
  else if (type_changeable (*varp) &&
	   ((*varp)->updated || !my_value_equal ((*varp)->value, new, &error2)))
a899 1
      (*varp)->updated = 0;
d936 1
a936 2
      if (type_changeable (v) && 
          (v->updated || !my_value_equal (v->value, new, &error2)))
a939 1
	  v->updated = 0;
a1296 1
  var->updated = 0;
@


1.31.8.3
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d1206 1
a1206 1
      if (strcmp (vc->child->name, name) == 0)
d2126 1
a2126 1
      if (strcmp (var->name, "public") == 0)
d2128 1
a2128 1
      else if (strcmp (var->name, "private") == 0)
d2179 1
d2194 2
d2198 15
a2212 47
	  /* The fields of the class type are ordered as they
	     appear in the class.  We are given an index for a
	     particular access control type ("public","protected",
	     or "private").  We must skip over fields that don't
	     have the access control we are looking for to properly
	     find the indexed field. */
	  int type_index = TYPE_N_BASECLASSES (type);
	  if (strcmp (parent->name, "private") == 0)
	    {
	      while (index >= 0)
		{
	  	  if (TYPE_VPTR_BASETYPE (type) == type
	      	      && type_index == TYPE_VPTR_FIELDNO (type))
		    ; /* ignore vptr */
		  else if (TYPE_FIELD_PRIVATE (type, type_index))
		    --index;
		  ++type_index;
		}
	      --type_index;
	    }
	  else if (strcmp (parent->name, "protected") == 0)
	    {
	      while (index >= 0)
		{
	  	  if (TYPE_VPTR_BASETYPE (type) == type
	      	      && type_index == TYPE_VPTR_FIELDNO (type))
		    ; /* ignore vptr */
		  else if (TYPE_FIELD_PROTECTED (type, type_index))
		    --index;
		  ++type_index;
		}
	      --type_index;
	    }
	  else
	    {
	      while (index >= 0)
		{
	  	  if (TYPE_VPTR_BASETYPE (type) == type
	      	      && type_index == TYPE_VPTR_FIELDNO (type))
		    ; /* ignore vptr */
		  else if (!TYPE_FIELD_PRIVATE (type, type_index) &&
		      !TYPE_FIELD_PROTECTED (type, type_index))
		    --index;
		  ++type_index;
		}
	      --type_index;
	    }
d2214 1
a2214 1
	  name = TYPE_FIELD_NAME (type, type_index);
a2216 1
	/* We are looking up the name of a base class */
a2219 3
	  int children[3];
	  cplus_class_num_children(type, children);

d2221 1
a2221 4
	     only be "public", "private", or "protected"

	     The special "fake" children are always output by varobj in
	     this order. So if INDEX == 2, it MUST be "protected". */
d2226 5
a2230 7
	      if (children[v_public] > 0)
	 	name = "public";
	      else if (children[v_private] > 0)
	 	name = "private";
	      else 
	 	name = "protected";
	      break;
d2232 1
a2232 1
	      if (children[v_public] > 0)
d2234 2
a2235 4
		  if (children[v_private] > 0)
		    name = "private";
		  else
		    name = "protected";
a2236 3
	      else if (children[v_private] > 0)
	 	name = "protected";
	      break;
d2238 5
a2242 3
	      /* Must be protected */
	      name = "protected";
	      break;
@


1.31.8.4
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a398 21
/* Return the full FRAME which corresponds to the given CORE_ADDR
   or NULL if no FRAME on the chain corresponds to CORE_ADDR.  */

static struct frame_info *
find_frame_addr_in_frame_chain (CORE_ADDR frame_addr)
{
  struct frame_info *frame = NULL;

  if (frame_addr == (CORE_ADDR) 0)
    return NULL;

  while (1)
    {
      frame = get_prev_frame (frame);
      if (frame == NULL)
	return NULL;
      if (get_frame_base (frame) == frame_addr)
	return frame;
    }
}

d423 1
a423 1
	fi = deprecated_selected_frame;
a424 6
	/* FIXME: cagney/2002-11-23: This code should be doing a
	   lookup using the frame ID and not just the frame's
	   ``address''.  This, of course, means an interface change.
	   However, with out that interface change ISAs, such as the
	   ia64 with its two stacks, won't work.  Similar goes for the
	   case where there is a frameless function.  */
d463 2
a464 2
	  var->root->frame = get_frame_id (fi);
	  old_fi = deprecated_selected_frame;
d874 1
a874 1
  old_fid = get_frame_id (deprecated_selected_frame);
d1320 2
a1321 1
  var->root->frame = null_frame_id;
@


1.31.8.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d1382 3
a1384 2
/* This returns the type of the variable. It also skips past typedefs
   to return the real type of the variable.
d1394 2
a1395 2
  if (type != NULL)
    type = check_typedef (type);
d1426 2
a1427 2
      if (type != NULL)
	type = check_typedef (type);
@


1.31.8.6
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d415 1
a415 1
      if (get_frame_base_address (frame) == frame_addr)
@


1.30
log
@2002-07-03  Martin M. Hunt  <hunt@@redhat.com>


        * varobj.c (struct varobj_root): Change frame from CORE_ADDR to
        struct frame_id.
        (varobj_create): Store frame_id for root.
        (varobj_gen_name): Use xasprintf.
        (varobj_update): Save and restore frame using get_frame_id() and
        frame_find_by_id().
        (create_child): Use xasprintf.
        (new_root_variable): Initialize frame_id.
        (c_name_of_child): Use xasprintf. Call find_frame_by_id().
        (c_value_of_variable): Use xasprintf. Move mem_fileopen call
        to prevent memory leak.
@
text
@d26 1
@


1.29
log
@* defs.h (auto_boolean): Declare enum.
* command.h (cmd_auto_boolean): Delete enum.
* mips-tdep.c (mask_address_var): Update.
(mips_mask_address_p): Update.
(show_mask_address): Update.
* remote.c (struct packet_config): Update.
(update_packet_config): Update.
(show_packet_config_cmd): Update.
(packet_ok): Update.
(add_packet_config_cmd): Update.
(_initialize_remote):
* command.h: Update.
* cli/cli-setshow.c (parse_auto_binary_operation): Update.
(do_setshow_command): Update.
* cli/cli-decode.c (add_set_auto_boolean_cmd): Update.
* cli/cli-decode.h: Update.
@
text
@d55 1
a55 1
  CORE_ADDR frame;
d459 1
a459 1
	  var->root->frame = FRAME_FP (fi);
d517 1
a517 1
  char obj_name[31];
d521 1
a521 1
  sprintf (obj_name, "var%d", id);
d523 1
a523 1
  return xstrdup (obj_name);
d853 2
a854 1
  struct frame_info *old_fi;
d867 1
a867 1
  old_fi = selected_frame;
d987 3
a989 1
  select_frame (old_fi);
d1220 1
a1220 4
  childs_name =
    (char *) xmalloc ((strlen (parent->obj_name) + strlen (name) + 2) *
		      sizeof (char));
  sprintf (childs_name, "%s.%s", parent->obj_name, name);
d1309 2
a1310 1
  var->root->frame = (CORE_ADDR) -1;
d1798 1
a1798 8
      {
	/* We never get here unless parent->num_children is greater than 0... */
	int len = 1;
	while ((int) pow ((double) 10, (double) len) < index)
	  len++;
	name = (char *) xmalloc (1 + len * sizeof (char));
	sprintf (name, "%d", index);
      }
d1817 1
a1817 3
	  name =
	    (char *) xmalloc ((strlen (parent->name) + 2) * sizeof (char));
	  sprintf (name, "*%s", parent->name);
d1850 1
a1850 4


      fi = find_frame_addr_in_frame_chain (var->root->frame);

a2017 2
  struct type *type;

d2020 2
a2021 2
  type = get_type (var);
  switch (TYPE_CODE (type))
d2030 3
a2032 3
	char number[18];
	sprintf (number, "[%d]", var->num_children);
	return xstrdup (number);
a2037 5
	long dummy;
	struct ui_file *stb = mem_fileopen ();
	struct cleanup *old_chain = make_cleanup_ui_file_delete (stb);
	char *thevalue;

d2047 5
a2059 2
	  }

d2062 1
a2062 1
      /* break; */
@


1.28
log
@* frame.h (select_frame): Delete level parameter.
* stack.c (select_frame): Update.  Use frame_relative_level to
obtain the frame's level.
(select_and_print_frame): Update call.
(select_frame_command): Ditto.
(up_silently_base): Ditto.
(down_silently_base): Ditto.
* ocd.c (ocd_start_remote): Ditto.
* remote-rdp.c (remote_rdp_open): Ditto.
* remote-mips.c (mips_initialize): Ditto.
(common_open): Ditto.
* remote-e7000.c (e7000_start_remote): Ditto.
* m3-nat.c (select_thread): Ditto.
* hppa-tdep.c (child_get_current_exception_event): Ditto.
(child_get_current_exception_event): Ditto.
* varobj.c (varobj_create): Ditto.
(varobj_update): Ditto.
(c_value_of_root): Ditto.
* tracepoint.c (finish_tfind_command): Ditto.
* corelow.c (core_open): Ditto.
* arch-utils.c (generic_prepare_to_proceed): Ditto.
* thread.c (info_threads_command): Ditto.
(switch_to_thread): Ditto.
* infrun.c (normal_stop): Ditto.
(restore_selected_frame): Ditto.
(restore_inferior_status): Ditto.
* breakpoint.c (insert_breakpoints): Ditto.
(watchpoint_check): Ditto.
(bpstat_stop_status): Ditto.
(do_enable_breakpoint): Ditto.
* blockframe.c (flush_cached_frames): Ditto.
(reinit_frame_cache): Ditto.
@
text
@d1213 1
a1213 1
  if ((!CPLUS_FAKE_CHILD(child) && child->value == NULL) || parent->error)
d1648 2
a1649 2
	 NULL so that callers notice that we're leaving an
	 error message. */
d1932 2
a1933 1
	  gdb_value_struct_elt (NULL, &value, &temp, NULL, name, NULL, "vstructure");
d1941 2
a1942 1
	      gdb_value_struct_elt (NULL, &value, &temp, NULL, name, NULL, "vstructure");
d2067 4
a2070 3
	    val_print (VALUE_TYPE (var->value), VALUE_CONTENTS_RAW (var->value), 0,
		       VALUE_ADDRESS (var->value),
		       stb, format_code[(int) var->format], 1, 0, 0);
d2206 2
a2207 1
	  if (STREQ (parent->name, "private") || STREQ (parent->name, "protected"))
@


1.28.4.1
log
@Merge with trunk.
@
text
@d1213 1
a1213 1
  if ((!CPLUS_FAKE_CHILD (child) && child->value == NULL) || parent->error)
d1648 2
a1649 2
         NULL so that callers notice that we're leaving an
         error message. */
d1932 1
a1932 2
	  gdb_value_struct_elt (NULL, &value, &temp, NULL, name, NULL,
				"vstructure");
d1940 1
a1940 2
	      gdb_value_struct_elt (NULL, &value, &temp, NULL, name, NULL,
				    "vstructure");
d2065 3
a2067 4
	    val_print (VALUE_TYPE (var->value),
		       VALUE_CONTENTS_RAW (var->value), 0,
		       VALUE_ADDRESS (var->value), stb,
		       format_code[(int) var->format], 1, 0, 0);
d2203 1
a2203 2
	  if (STREQ (parent->name, "private")
	      || STREQ (parent->name, "protected"))
@


1.28.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d1213 1
a1213 1
  if ((!CPLUS_FAKE_CHILD (child) && child->value == NULL) || parent->error)
d1648 2
a1649 2
         NULL so that callers notice that we're leaving an
         error message. */
d1932 1
a1932 2
	  gdb_value_struct_elt (NULL, &value, &temp, NULL, name, NULL,
				"vstructure");
d1940 1
a1940 2
	      gdb_value_struct_elt (NULL, &value, &temp, NULL, name, NULL,
				    "vstructure");
d2065 3
a2067 4
	    val_print (VALUE_TYPE (var->value),
		       VALUE_CONTENTS_RAW (var->value), 0,
		       VALUE_ADDRESS (var->value), stb,
		       format_code[(int) var->format], 1, 0, 0);
d2203 1
a2203 2
	  if (STREQ (parent->name, "private")
	      || STREQ (parent->name, "protected"))
@


1.28.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d55 1
a55 1
  struct frame_id frame;
d459 1
a459 1
	  get_frame_id (fi, &var->root->frame);
d517 1
a517 1
  char *obj_name;
d521 1
a521 1
  xasprintf (&obj_name, "var%d", id);
d523 1
a523 1
  return obj_name;
d853 1
a853 2
  struct frame_id old_fid;
  struct frame_info *fi;
d866 1
a866 1
  get_frame_id (selected_frame, &old_fid);
d986 1
a986 3
  fi = frame_find_by_id (old_fid);
  if (fi)
    select_frame (fi);
d1217 4
a1220 1
  xasprintf (&childs_name, "%s.%s", parent->obj_name, name);
d1309 1
a1309 2
  var->root->frame.base = 0;
  var->root->frame.pc = 0;
d1797 8
a1804 1
      xasprintf (&name, "%d", index);
d1823 3
a1825 1
	  xasprintf (&name, "*%s", parent->name);
d1858 4
a1861 1
      fi = frame_find_by_id (var->root->frame);
d2029 2
d2033 2
a2034 2

  switch (TYPE_CODE (get_type (var)))
d2043 3
a2045 3
	char *number;
	xasprintf (&number, "[%d]", var->num_children);
	return (number);
d2051 5
a2064 5
	    long dummy;
	    struct ui_file *stb = mem_fileopen ();
	    struct cleanup *old_chain = make_cleanup_ui_file_delete (stb);
	    char *thevalue;

d2073 2
d2077 1
a2077 1
      }
@


1.28.6.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a25 1
#include "gdb_string.h"
@


1.28.6.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d1348 1
a1348 4
   pointers and references.

   NOTE: TYPE_TARGET_TYPE should NOT be used anywhere in this file
   except within get_target_type and get_type. */
d1377 1
a1377 4
   past typedefs, just like get_type ().

   NOTE: TYPE_TARGET_TYPE should NOT be used anywhere in this file
   except within get_target_type and get_type. */
d1962 1
a1962 1
      type = get_target_type (parent->type);
d1971 1
a1971 1
      switch (TYPE_CODE (get_target_type (parent->type)))
d1979 1
a1979 1
	  type = get_target_type (parent->type);
@


1.28.6.5
log
@merge from mainline
@
text
@a113 3

  /* Was this variable updated via a varobj_set_value operation */
  int updated;
a755 1
  int error;
a780 2
      if (!my_value_equal (var->value, value, &error))
        var->updated = 1;
d896 2
a897 2
  else if (type_changeable (*varp) &&
	   ((*varp)->updated || !my_value_equal ((*varp)->value, new, &error2)))
a899 1
      (*varp)->updated = 0;
d936 1
a936 2
      if (type_changeable (v) && 
          (v->updated || !my_value_equal (v->value, new, &error2)))
a939 1
	  v->updated = 0;
a1296 1
  var->updated = 0;
@


1.27
log
@gdb/ChangeLog:
* stack.c (get_selected_block): Add new argument `addr_in_block',
used to return the exact code address we used to select the block,
not just the block.
* blockframe.c (get_frame_block, get_current_block): Same.
* frame.h (get_frame_block, get_current_block,
get_selected_block): Update declarations.
* linespec.c, stack.c, blockframe.c, breakpoint.c, findvar.c,
linespec.c, varobj.c, printcmd.c, symtab.c: Callers changed.

gdb/mi/ChangeLog:
* mi-cmd-stack.c (list_args_or_locals): Pass new arg to
get_frame_block.  (See entry in gdb/ChangeLog.)
@
text
@d461 1
a461 1
	  select_frame (fi, -1);
d488 1
a488 1
	select_frame (old_fi, -1);
d986 1
a986 1
  select_frame (old_fi, -1);
d1865 1
a1865 1
	select_frame (fi, -1);
@


1.26
log
@        * varobj.c (varobj_set_value): Make sure that there were no
        errors evaluating the object before attempting to set its
        value.
        value_cast now properly adjusts VALUE_ADDRESS for baseclasses,
        so this offset adjustment is no longer necessary.
        (create_child): Don't set the error flag if the child is
        a CPLUS_FAKE_CHILD.
        (value_of_child): If value_fetch_lazy fails, return NULL
        so that callers will be notified that an error occurred.
        (c_value_of_variable): Delay check of variable's validity
        until later. We actually want all structs and unions to have
        the value "{...}".
        Do not return "???" for variables which could not be evaluated.
        This error condition must be returned to the caller so that it
        can get the error condition from gdb.
        (cplus_name_of_child): Adjust index for vptr before figuring
        out the name of the child.
        (cplus_value_of_child): If a child's (real) parent is not valid,
        don't even bother trying to give a value for it. Just return
        an error. Change all instances in this function.
        (cplus_type_of_child): If our parent is one of the "fake"
        parents, we need to get at the type of the real parent, and
        derive the child's true type using this information.
@
text
@d429 1
a429 1
	block = get_frame_block (fi);
@


1.25
log
@	* varobj.c (c_value_of_child): Release memory for "name" when
	finshed using it.
	(c_type_of_child): Likewise.
	(cplus_value_of_child): Isolate the use of name_of_child to
	one case that needs it.
	Release memory for "name" when finished using it.
@
text
@d764 1
a764 1
  if (variable_editable (var) && !var->error)
a767 1
      struct value *temp;
d780 1
a780 28
      /* If our parent is "public", "private", or "protected", we could
         be asking to modify the value of a baseclass. If so, we need to
         adjust our address by the offset of our baseclass in the subclass,
         since VALUE_ADDRESS (var->value) points at the start of the subclass.
         For some reason, value_cast doesn't take care of this properly. */
      temp = var->value;
      if (var->parent != NULL && CPLUS_FAKE_CHILD (var->parent))
	{
	  struct varobj *super, *sub;
	  struct type *type;
	  super = var->parent->parent;
	  sub = super->parent;
	  if (sub != NULL)
	    {
	      /* Yes, it is a baseclass */
	      type = get_type_deref (sub);

	      if (super->index < TYPE_N_BASECLASSES (type))
		{
		  temp = value_copy (var->value);
		  for (i = 0; i < super->index; i++)
		    offset += TYPE_LENGTH (TYPE_FIELD_TYPE (type, i));
		}
	    }
	}

      VALUE_ADDRESS (temp) += offset;
      if (!gdb_value_assign (temp, value, &val))
a781 1
      VALUE_ADDRESS (val) -= offset;
d1213 1
a1213 1
  if (child->value == NULL || parent->error)
d1646 7
a1652 1
    gdb_value_fetch_lazy (value);
a2027 10
  struct value *val;

  if (var->value != NULL)
    val = var->value;
  else
    {
      /* This can happen if we attempt to get the value of a struct
         member when the parent is an invalid pointer. */
      return xstrdup ("???");
    }
d2054 18
a2071 7
	if (VALUE_LAZY (val))
	  gdb_value_fetch_lazy (val);
	val_print (VALUE_TYPE (val), VALUE_CONTENTS_RAW (val), 0,
		   VALUE_ADDRESS (val),
		   stb, format_code[(int) var->format], 1, 0, 0);
	thevalue = ui_file_xstrdup (stb, &dummy);
	do_cleanups (old_chain);
d2193 7
d2202 2
a2203 3
	  int i = index + TYPE_N_BASECLASSES (type);
	  if (STREQ (parent->name, "private")
	      || STREQ (parent->name, "protected"))
d2286 3
d2307 1
a2307 1
	      struct value *temp;
d2318 11
a2328 2
	      value = value_cast (TYPE_FIELD_TYPE (type, index), temp);
	      release_value (value);
d2344 8
a2351 1
  t = get_type_deref (parent);
d2357 1
a2357 1
      if (index >= TYPE_N_BASECLASSES (t))
d2359 3
a2361 2
	  /* special */
	  return NULL;
d2363 2
d2367 2
a2368 2
	  /* Baseclass */
	  type = TYPE_FIELD_TYPE (t, index);
@


1.24
log
@	* varobj.c (c_value_of_child): Use the wrapper function,
	gdb_value_struct_elt.
	(cplus_value_of_child): Likewise.
@
text
@d1980 1
d2023 1
a2285 1
  char *name;
a2292 1
  name = name_of_child (parent, index);
d2299 1
d2302 1
d2307 2
@


1.23
log
@s/value_ptr/struct value */
@
text
@d1955 1
a1955 1
	  value = value_struct_elt (&temp, NULL, name, NULL, "vstructure");
d1963 1
a1963 2
	      value =
		value_struct_elt (&temp, NULL, name, NULL, "vstructure");
d2300 5
a2304 3
	  value = value_struct_elt (&temp, NULL, name,
				    NULL, "cplus_structure");
	  release_value (value);
@


1.22
log
@Re-indent.
@
text
@d94 1
a94 1
  value_ptr value;
d191 1
a191 1
static int my_value_equal (value_ptr, value_ptr, int *);
d211 1
a211 1
static value_ptr value_of_root (struct varobj **var_handle, int *);
d213 1
a213 1
static value_ptr value_of_child (struct varobj *parent, int index);
d231 1
a231 1
static value_ptr c_value_of_root (struct varobj **var_handle);
d233 1
a233 1
static value_ptr c_value_of_child (struct varobj *parent, int index);
d251 1
a251 1
static value_ptr cplus_value_of_root (struct varobj **var_handle);
d253 1
a253 1
static value_ptr cplus_value_of_child (struct varobj *parent, int index);
d269 1
a269 1
static value_ptr java_value_of_root (struct varobj **var_handle);
d271 1
a271 1
static value_ptr java_value_of_child (struct varobj *parent, int index);
d296 2
a297 2
  /* The value_ptr of the root variable ROOT. */
  value_ptr (*value_of_root) (struct varobj ** root_handle);
d299 2
a300 2
  /* The value_ptr of the INDEX'th child of PARENT. */
  value_ptr (*value_of_child) (struct varobj * parent, int index);
d699 1
a699 1
  value_ptr val;
d713 1
a713 1
  /* To print the type, we simply create a zero value_ptr and
d754 1
a754 1
  value_ptr val;
d761 1
a761 1
  value_ptr value;
d768 1
a768 1
      value_ptr temp;
d879 1
a879 1
  value_ptr new;
d1430 1
a1430 1
my_value_equal (value_ptr val1, value_ptr val2, int *error2)
d1596 1
a1596 1
/* What is the value_ptr of the root variable VAR? 
d1606 1
a1606 1
static value_ptr
d1665 2
a1666 2
/* What is the value_ptr for the INDEX'th child of PARENT? */
static value_ptr
d1669 1
a1669 1
  value_ptr value;
d1861 1
a1861 1
static value_ptr
d1864 1
a1864 1
  value_ptr new_val;
d1922 1
a1922 1
static value_ptr
d1925 3
a1927 1
  value_ptr value, temp, indval;
d2050 1
a2050 1
  value_ptr val;
d2274 1
a2274 1
static value_ptr
d2280 1
a2280 1
static value_ptr
d2284 1
a2284 1
  value_ptr value;
d2300 1
a2300 1
	  value_ptr temp = parent->parent->value;
d2315 1
a2315 1
	      value_ptr temp;
d2439 1
a2439 1
static value_ptr
d2445 1
a2445 1
static value_ptr
@


1.21
log
@	* varobj.c (cplus_value_of_child): Deal with a failure
	to dereference a pointer object.
@
text
@d36 1
a36 1
{"natural", "binary", "decimal", "hexadecimal", "octal"};
d39 1
a39 2
char *varobj_language_string[] =
{"unknown", "C", "C++", "Java"};
d46 1
a46 1
  {
d48 2
a49 2
    /* Alloc'd expression for this parent. */
    struct expression *exp;
d51 2
a52 2
    /* Block for which this expression is valid */
    struct block *valid_block;
d54 2
a55 2
    /* The frame for this expression */
    CORE_ADDR frame;
d57 3
a59 3
    /* If 1, "update" always recomputes the frame & valid block
       using the currently selected frame. */
    int use_selected_frame;
d61 2
a62 2
    /* Language info for this variable and its children */
    struct language_specific *lang;
d64 2
a65 2
    /* The varobj for this root node. */
    struct varobj *rootvar;
d67 3
a69 3
    /* Next root variable */
    struct varobj_root *next;
  };
d75 1
a75 1
  {
d77 5
a81 5
    /* Alloc'd name of the variable for this object.. If this variable is a
       child, then this name will be the child's source name.
       (bar, not foo.bar) */
    /* NOTE: This is the "expression" */
    char *name;
d83 3
a85 3
    /* The alloc'd name for this variable's object. This is here for
       convenience when constructing this object's children. */
    char *obj_name;
d87 2
a88 2
    /* Index of this variable in its parent or -1 */
    int index;
d90 2
a91 2
    /* The type of this variable. This may NEVER be NULL. */
    struct type *type;
d93 2
a94 2
    /* The value of this expression or subexpression.  This may be NULL. */
    value_ptr value;
d96 2
a97 2
    /* Did an error occur evaluating the expression or getting its value? */
    int error;
d99 2
a100 2
    /* The number of (immediate) children this variable has */
    int num_children;
d102 2
a103 2
    /* If this object is a child, this points to its immediate parent. */
    struct varobj *parent;
d105 2
a106 2
    /* A list of this object's children */
    struct varobj_child *children;
d108 2
a109 2
    /* Description of the root variable. Points to root variable for children. */
    struct varobj_root *root;
d111 3
a113 3
    /* The format of the output for this object */
    enum varobj_display_formats format;
  };
d120 1
a120 1
  {
d122 2
a123 2
    /* Pointer to the child's data */
    struct varobj *child;
d125 3
a127 3
    /* Pointer to the next child */
    struct varobj_child *next;
  };
d133 4
a136 4
  {
    struct varobj *var;
    struct vstack *next;
  };
d139 4
a142 4
  {
    char *name;
    struct cpstack *next;
  };
d147 4
a150 4
  {
    struct varobj *var;
    struct vlist *next;
  };
d282 1
a282 1
  {
d284 2
a285 2
    /* The language of this variable */
    enum varobj_languages language;
d287 2
a288 2
    /* The number of children of PARENT. */
    int (*number_of_children) (struct varobj * parent);
d290 2
a291 2
    /* The name (expression) of a root varobj. */
    char *(*name_of_variable) (struct varobj * parent);
d293 2
a294 2
    /* The name of the INDEX'th child of PARENT. */
    char *(*name_of_child) (struct varobj * parent, int index);
d296 2
a297 2
    /* The value_ptr of the root variable ROOT. */
      value_ptr (*value_of_root) (struct varobj ** root_handle);
d299 2
a300 2
    /* The value_ptr of the INDEX'th child of PARENT. */
      value_ptr (*value_of_child) (struct varobj * parent, int index);
d302 2
a303 2
    /* The type of the INDEX'th child of PARENT. */
    struct type *(*type_of_child) (struct varobj * parent, int index);
d305 2
a306 2
    /* Is VAR editable? */
    int (*variable_editable) (struct varobj * var);
d308 3
a310 3
    /* The current value of VAR. */
    char *(*value_of_variable) (struct varobj * var);
  };
d314 1
a314 2
  languages[vlang_end][sizeof (struct language_specific)] =
{
d317 9
a325 10
    vlang_unknown,
      c_number_of_children,
      c_name_of_variable,
      c_name_of_child,
      c_value_of_root,
      c_value_of_child,
      c_type_of_child,
      c_variable_editable,
      c_value_of_variable
  }
d329 9
a337 10
    vlang_c,
      c_number_of_children,
      c_name_of_variable,
      c_name_of_child,
      c_value_of_root,
      c_value_of_child,
      c_type_of_child,
      c_variable_editable,
      c_value_of_variable
  }
d341 9
a349 10
    vlang_cplus,
      cplus_number_of_children,
      cplus_name_of_variable,
      cplus_name_of_child,
      cplus_value_of_root,
      cplus_value_of_child,
      cplus_type_of_child,
      cplus_variable_editable,
      cplus_value_of_variable
  }
d353 9
a361 10
    vlang_java,
      java_number_of_children,
      java_name_of_variable,
      java_name_of_child,
      java_value_of_root,
      java_value_of_child,
      java_type_of_child,
      java_variable_editable,
      java_value_of_variable
  }
d366 3
a368 3
  {
    v_public = 0, v_private, v_protected
  };
d373 1
a373 2
static int format_code[] =
{0, 't', 'd', 'x', 'o'};
d397 1
a397 2
	       char *expression, CORE_ADDR frame,
	       enum varobj_type type)
d418 1
a418 2
      if ((type == USE_CURRENT_FRAME)
	  || (type == USE_SELECTED_FRAME))
d445 1
a445 1
			    "Attempt to use a type name as an expression.");
d606 2
a607 1
	warning ("varobj_delete: assertion failed - mycount(=%d) <> 0", mycount);
d799 3
a801 3
	        {
	          temp = value_copy (var->value);
	          for (i = 0; i < super->index; i++)
d803 1
a803 1
	        }
d845 3
a847 2
    warning ("varobj_list: assertion failed - wrong tally of root vars (%d:%d)",
	     rootcount, mycount);
d923 2
a924 1
  else if (type_changeable (*varp) && !my_value_equal ((*varp)->value, new, &error2))
d1009 2
a1010 2
      for (i=0; i < changed; i++)
        *(*changelist + i) = *(templist + changed -1 - i);
d1047 3
a1049 2
delete_variable_1 (struct cpstack **resultp, int *delcountp, struct varobj *var,
		   int only_children_p, int remove_from_parent_p)
d1082 1
a1082 2
  if ((remove_from_parent_p) &&
      (var->parent != NULL))
d1086 1
a1086 1
  
d1168 3
a1170 1
      warning ("Assertion failed: Could not find variable object \"%s\" to delete", var->obj_name);
d1198 3
a1200 1
	      warning ("Assertion failed: Could not find varobj \"%s\" in root list", var->obj_name);
d1246 3
a1248 2
  childs_name = (char *) xmalloc ((strlen (parent->obj_name) + strlen (name) + 2)
				  * sizeof (char));
d1634 1
a1634 1
      if (strcmp(old_type, new_type) == 0)
d1643 1
a1643 1
	      tmp_var->obj_name = 
d1649 1
a1649 1
	      tmp_var->obj_name = varobj_gen_name ();  
d1725 5
a1729 5
      case TYPE_CODE_STRUCT:
      case TYPE_CODE_UNION:
      case TYPE_CODE_ARRAY:
	r = 0;
	break;
d1731 2
a1732 2
      default:
	r = 1;
d1754 1
a1754 1
	&& TYPE_ARRAY_UPPER_BOUND_TYPE (type) != BOUND_CANNOT_BE_DETERMINED)
d1846 2
a1847 1
	  name = (char *) xmalloc ((strlen (parent->name) + 2) * sizeof (char));
d1874 1
a1874 1
  
d1881 2
a1882 2
      
      
d1884 1
a1884 1
      
d1890 1
a1890 1
  
d1894 2
a1895 2
	 expression fails we just want to make val->error = 1 and
	 go on */
d1901 2
a1902 2
		 value_fetch_lazy fails we still want to continue
		 (after making val->error = 1) */
d1904 2
a1905 2
		 comment on value_fetch_lazy() says it is only
		 called from the macro... */
d1914 1
a1914 1
      
d1941 1
a1941 1
          /* This breaks if the array lives in a (vector) register. */
d1961 2
a1962 1
	      value = value_struct_elt (&temp, NULL, name, NULL, "vstructure");
d2114 1
a2114 1
          ((TYPE_CODE (type)) == TYPE_CODE_UNION))
d2170 1
a2170 2
      if (TYPE_VPTR_BASETYPE (type) == type
	  && TYPE_VPTR_FIELDNO (type) == i)
d2215 2
a2216 1
	  if (STREQ (parent->name, "private") || STREQ (parent->name, "protected"))
d2476 1
a2476 4
  add_show_from_set (
		add_set_cmd ("debugvarobj", class_maintenance, var_zinteger,
			     (char *) &varobjdebug,
			     "Set varobj debugging.\n\
d2478 1
a2478 1
		      &showlist);
@


1.20
log
@	* varobj.c (varobj_update): Change first parameter to
	pointer to struct varobj*. This function can delete
	varobjs, so we need to give callers the new varobj
	when this happens.
	(value_of_root): Update "var", too, if "var_handle"
	changes.
	* varobj.h (varobj_update): Likewise.
@
text
@d2316 4
a2319 1
		gdb_value_ind (parent->value, &temp);
@


1.19
log
@2001-05-10  Fernando Nasser  <fnasser@@redhat.com>

	* varobj.c (c_number_of_children): Fix memory leak. Delete unwanted old
	variables, not just unregister them.
@
text
@d869 5
a873 1
   Only root variables can be updated... */
d876 1
a876 1
varobj_update (struct varobj *var, struct varobj ***changelist)
d896 1
a896 1
  if (var->root->rootvar != var)
d910 1
a910 1
  new = value_of_root (&var, &type_changed);
d913 1
a913 1
      var->error = 1;
d924 1
a924 1
      vpush (&result, var);
d930 1
a930 1
  else if (type_changeable (var) && !my_value_equal (var->value, new, &error2))
d932 1
a932 1
      vpush (&result, var);
d936 1
a936 1
      var->error = error2;
d941 2
a942 2
  value_free (var->value);
  var->value = new;
d948 1
a948 1
  if (var->children != NULL)
d951 1
a951 1
      for (c = var->children; c != NULL; c = c->next)
d1654 1
@


1.19.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@a1404 1
#if TYPEFIX
a1412 4
#else
  return NULL;
#endif

d1749 2
a1750 1
      if (TYPE_LENGTH (type) > 0 && TYPE_LENGTH (target) > 0)
a1924 1
  /* TYPEFIX */
d1985 1
a1985 1
      type = ARRAY_ELEMENT_TYPE (parent->type);
d1994 1
a1994 1
      switch (TYPE_CODE (POINTER_TARGET_TYPE (parent->type)))
d2002 1
a2002 1
	  type = POINTER_TARGET_TYPE (parent->type);
@


1.18
log
@2001-05-10  Fernando Nasser  <fnasser@@redhat.com>

	* varobj.c (c_number_of_children): Check for target type of void*,
	not the target type name.  Allow dereferencing char*.
@
text
@d1642 1
a1642 1
	      uninstall_variable (var);
@


1.17
log
@* arch-utils.c (#include "gdbthread.h"): Removed.
(#include "symfile.h"): Removed.
(XMALLOC): Removed unused macro.
* breakpoint.c (tbreak_command): Removed local declaration.
(awatch_command, do_enable_breakpoint, set_breakpoint_count):
Remove duplicate declarations.
(bpstat_should_step, bpstat_have_active_hw_watchpoints)
(remove_solib_event_breakpoints): Fix indentation botch.
* c-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* ch-exp.c (ch_terminal_match_float_literal, parse_expr)
(parse_primval, parse_untyped_expr, parse_opt_untyped_expr):
Removed duplicate declarations.
* ch-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* corefile.c (#include "frame.h"): Removed
(#include "symfile.h"): Removed.
(#include "language.h"): Removed.
* dbxread.c (#include "command.h"): Removed.
* environ.c (#include "gdbcore.h"): Removed.
* event-loop.c (#include "top.h"): Removed.
* f-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
(#include "typeprint.h"): Removed.
(#include "frame.h"): Removed.
* gdbtypes.h (print_type_scalar): Removed declaration.
* infcmd.c (#include "completer.h"): Removed.
* language.c (#include "frame.h"): Removed.
* m2-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
* m2-valprint.c (#include "valprint.h"): Removed.
* p-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* p-valprint.c (#include "typeprint.h"): Removed.
* parse.c (#include "linespec.h"): Removed.
* regcache.c (#include "frame.h"): Removed.
* remote.c (#include "frame.h"): Removed.
(getpkt_sane): Make static.
* source.c (#include "completer.h"): Removed.
* stack.c (#include "symfile.h"): Removed.
(#include "objfiles.h"): Removed.
* symfile.c (#include "completer.h"): Removed.
* tracepoint.c (#include "completer.h"): Removed.
* values.c (#include "frame.h"): Removed.
* varobj.c (#include "valprint.h"): Removed.
* wrapper.c (#include "frame.h"): Removed.

* memattr.c (create_mem_region): Removed unused variable.
* remote-nrom.c: Removed spurious semicolon after init_nrom_ops.
-------------------------------------------------------------------
@
text
@d1764 7
a1770 1
         dereference for the user and function ptrs, which have no children. */
d1779 1
d1784 1
a1784 7
	  /* Don't dereference char* or void*. */
	  if (TYPE_NAME (target) != NULL
	      && (STREQ (TYPE_NAME (target), "char")
		  || STREQ (TYPE_NAME (target), "void")))
	    children = 0;
	  else
	    children = 1;
@


1.16
log
@2001-01-24  Jeff Holcomb  <jeffh@@redhat.com>

        * remote-udi.c (udi_open): Change strdup to xstrdup.
        * thread.c (thread_apply_all_command): Change strdup to xstrdup.
        Update copyright message.
        * varobj.c (delete_variable_1): Likewise.

        * gdb_string.h: Remove declaration of strdup.  Update copyright
        message.
        * config/xm-mpw.h: Likewise.
        * config/i386/xm-i386mach.h: Likewise.
        * config/m68k/xm-apollo68b.h: Likewise.
        * config/m68k/xm-hp300bsd.h: Likewise.
        * config/rs6000/xm-rs6000.h: Likewise.
        * config/vax/xm-vaxult.h: Remove declaration of strdup.
        * config/vax/xm-vaxult2.h: Likewise.
@
text
@a22 1
#include "valprint.h"
@


1.15
log
@Replace FREEIF() with xfree().
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
d1075 1
a1075 1
      cppush (resultp, strdup (var->obj_name));
@


1.14
log
@Replace free() with xfree().
@
text
@a393 5
#if defined(FREEIF)
#undef FREEIF
#endif
#define FREEIF(x) if (x != NULL) free((char *) (x))

d786 1
a786 1
	  FREEIF (exp);
d1351 1
a1351 1
      FREEIF (var->root);
d1354 3
a1356 3
  FREEIF (var->name);
  FREEIF (var->obj_name);
  FREEIF (var);
@


1.13
log
@Fix -Wuninitialized warnings.
@
text
@d1068 1
a1068 1
      free (vc);
d1185 1
a1185 1
  free (cv);
d1510 1
a1510 1
  free (s);
d1540 1
a1540 1
  free (s);
@


1.12
log
@Protoization.
@
text
@d414 2
a415 1
  struct frame_info *fi, *old_fi;
d887 1
a887 1
  struct varobj **templist;
@


1.11
log
@2000-11-06  Fernando Nasser  <fnasser@@totem.toronto.redhat.com>

        * wrapper.c (gdb_value_assign): New function.  Longjump-free
        version of value_assign.
        (wrap_value_assign): New function. Wrapper for value_assign.
        * wrapper.h: Add declaration for the above.
        * varobj.c (varobj_set_value): Use gdb_value_assign, not
        value_assign which can longjump.  Do not change varobj value if
        assign fails.
@
text
@d1219 1
a1219 3
child_exists (var, name)
     struct varobj *var;	/* Parent */
     char *name;		/* name of child */
d2157 1
a2157 3
cplus_class_num_children (type, children)
     struct type *type;
     int children[3];
@


1.10
log
@2000-10-13  Fernando Nasser  <fnasser@@totem.to.cygnus.com>

	* varobj.c (type_changeable): Arrays are not changeable.
	Trying to check for updates was causing an error if the array lived
	in a register as gdb value_equal() cannot handle that case yet.
@
text
@d821 2
a822 1
      val = value_assign (temp, value);
@


1.9
log
@2000-10-13  Fernando Nasser  <fnasser@@totem.to.cygnus.com>

	* varobj.c (varobj_update): Prevent uninitialized error code to be
	returned on type_changed.  Also, prevent value_equal() to be called
	for the types we do not want to test for updates.
@
text
@d1729 1
@


1.8
log
@2000-09-15  Fernando Nasser  <fnasser@@totem.to.cygnus.com>

	* varobj.c (varobj_set_value): Call wrapped version of
	parse_exp_1() to avoid longjumps.
@
text
@d920 3
a922 1
  if (type_changed || !my_value_equal (var->value, new, &error2))
d924 13
a936 9
      /* Note that it's changed   There a couple of exceptions here,
         though. We don't want some types to be reported as 
	 "changed". The exception to this is if this is a 
	 "use_selected_frame" varobj, and its type has changed. */
      if (type_changed || type_changeable (var))
	{
	  vpush (&result, var);
	  changed++;
	}
a937 3
  /* error2 replaces var->error since this new value
     WILL replace the old one. */
  var->error = error2;
@


1.7
log
@Protoization.
@
text
@d784 3
a786 2
      /* FIXME: Callee may longjump */
      exp = parse_exp_1 (&s, 0, 0);
@


1.6
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d1033 2
a1034 4
delete_variable (resultp, var, only_children_p)
     struct cpstack **resultp;
     struct varobj *var;
     int only_children_p;
d1049 2
a1050 7
delete_variable_1 (resultp, delcountp, var,
		   only_children_p, remove_from_parent_p)
     struct cpstack **resultp;
     int *delcountp;
     struct varobj *var;
     int only_children_p;
     int remove_from_parent_p;
d1098 1
a1098 2
install_variable (var)
     struct varobj *var;
d1141 1
a1141 2
uninstall_variable (var)
     struct varobj *var;
d1231 1
a1231 4
create_child (parent, index, name)
     struct varobj *parent;
     int index;
     char *name;
d1264 1
a1264 3
save_child_in_parent (parent, child)
     struct varobj *parent;
     struct varobj *child;
d1280 1
a1280 3
remove_child_from_parent (parent, child)
     struct varobj *parent;
     struct varobj *child;
d1346 1
a1346 2
free_variable (var)
     struct varobj *var;
d1376 1
a1376 2
get_type (var)
     struct varobj *var;
d1389 1
a1389 2
get_type_deref (var)
     struct varobj *var;
d1405 1
a1405 2
get_target_type (type)
     struct type *type;
d1420 1
a1420 2
variable_default_display (var)
     struct varobj *var;
d1429 1
a1429 4
my_value_equal (val1, val2, error2)
     value_ptr val1;
     value_ptr val2;
     int *error2;
d1483 1
a1483 3
vpush (pstack, var)
     struct vstack **pstack;
     struct varobj *var;
d1495 1
a1495 2
vpop (pstack)
     struct vstack **pstack;
d1513 1
a1513 3
cppush (pstack, name)
     struct cpstack **pstack;
     char *name;
d1525 1
a1525 2
cppop (pstack)
     struct cpstack **pstack;
d1549 1
a1549 2
variable_language (var)
     struct varobj *var;
d1576 1
a1576 2
number_of_children (var)
     struct varobj *var;
d1583 1
a1583 2
name_of_variable (var)
     struct varobj *var;
d1590 1
a1590 3
name_of_child (var, index)
     struct varobj *var;
     int index;
d1606 1
a1606 3
value_of_root (var_handle, type_changed)
     struct varobj ** var_handle;
     int *type_changed;
d1665 1
a1665 3
value_of_child (parent, index)
     struct varobj *parent;
     int index;
d1680 1
a1680 2
type_of_child (var)
     struct varobj *var;
d1695 1
a1695 2
variable_editable (var)
     struct varobj *var;
d1702 1
a1702 2
my_value_of_variable (var)
     struct varobj *var;
d1711 1
a1711 2
type_changeable (var)
     struct varobj *var;
d1737 1
a1737 2
c_number_of_children (var)
     struct varobj *var;
d1797 1
a1797 2
c_name_of_variable (parent)
     struct varobj *parent;
d1803 1
a1803 3
c_name_of_child (parent, index)
     struct varobj *parent;
     int index;
d1857 1
a1857 2
c_value_of_root (var_handle)
     struct varobj **var_handle;
d1918 1
a1918 3
c_value_of_child (parent, index)
     struct varobj *parent;
     int index;
d1977 1
a1977 3
c_type_of_child (parent, index)
     struct varobj *parent;
     int index;
d2019 1
a2019 2
c_variable_editable (var)
     struct varobj *var;
d2039 1
a2039 2
c_value_of_variable (var)
     struct varobj *var;
d2095 1
a2095 2
cplus_number_of_children (var)
     struct varobj *var;
d2180 1
a2180 2
cplus_name_of_variable (parent)
     struct varobj *parent;
d2186 1
a2186 3
cplus_name_of_child (parent, index)
     struct varobj *parent;
     int index;
d2269 1
a2269 2
cplus_value_of_root (var_handle)
     struct varobj **var_handle;
d2275 1
a2275 3
cplus_value_of_child (parent, index)
     struct varobj *parent;
     int index;
d2330 1
a2330 3
cplus_type_of_child (parent, index)
     struct varobj *parent;
     int index;
d2363 1
a2363 2
cplus_variable_editable (var)
     struct varobj *var;
d2372 1
a2372 2
cplus_value_of_variable (var)
     struct varobj *var;
d2386 1
a2386 2
java_number_of_children (var)
     struct varobj *var;
d2392 1
a2392 2
java_name_of_variable (parent)
     struct varobj *parent;
d2412 1
a2412 3
java_name_of_child (parent, index)
     struct varobj *parent;
     int index;
d2431 1
a2431 2
java_value_of_root (var_handle)
     struct varobj **var_handle;
d2437 1
a2437 3
java_value_of_child (parent, index)
     struct varobj *parent;
     int index;
d2443 1
a2443 3
java_type_of_child (parent, index)
     struct varobj *parent;
     int index;
d2449 1
a2449 2
java_variable_editable (var)
     struct varobj *var;
d2455 1
a2455 2
java_value_of_variable (var)
     struct varobj *var;
@


1.5
log
@PARAMS removal.
@
text
@d290 1
a290 1
    int (*number_of_children) PARAMS ((struct varobj * parent));
d293 1
a293 1
    char *(*name_of_variable) PARAMS ((struct varobj * parent));
d296 1
a296 1
    char *(*name_of_child) PARAMS ((struct varobj * parent, int index));
d299 1
a299 1
      value_ptr (*value_of_root) PARAMS ((struct varobj ** root_handle));
d302 1
a302 1
      value_ptr (*value_of_child) PARAMS ((struct varobj * parent, int index));
d305 1
a305 1
    struct type *(*type_of_child) PARAMS ((struct varobj * parent, int index));
d308 1
a308 1
    int (*variable_editable) PARAMS ((struct varobj * var));
d311 1
a311 1
    char *(*value_of_variable) PARAMS ((struct varobj * var));
@


1.4
log
@Purge (almost) make_cleanup_func.
@
text
@d158 1
a158 1
static int delete_variable PARAMS ((struct cpstack **, struct varobj *, int));
d160 2
a161 2
static void delete_variable_1 PARAMS ((struct cpstack **, int *,
				       struct varobj *, int, int));
d163 1
a163 1
static int install_variable PARAMS ((struct varobj *));
d165 1
a165 1
static void uninstall_variable PARAMS ((struct varobj *));
d167 1
a167 1
static struct varobj *child_exists PARAMS ((struct varobj *, char *));
d169 1
a169 1
static struct varobj *create_child PARAMS ((struct varobj *, int, char *));
d171 1
a171 1
static void save_child_in_parent PARAMS ((struct varobj *, struct varobj *));
d173 1
a173 1
static void remove_child_from_parent PARAMS ((struct varobj *, struct varobj *));
d177 1
a177 1
static struct varobj *new_variable PARAMS ((void));
d179 1
a179 1
static struct varobj *new_root_variable PARAMS ((void));
d181 1
a181 1
static void free_variable PARAMS ((struct varobj * var));
d185 1
a185 1
static struct type *get_type PARAMS ((struct varobj * var));
d187 1
a187 1
static struct type *get_type_deref PARAMS ((struct varobj * var));
d189 1
a189 1
static struct type *get_target_type PARAMS ((struct type *));
d191 1
a191 1
static enum varobj_display_formats variable_default_display PARAMS ((struct varobj *));
d193 1
a193 1
static int my_value_equal PARAMS ((value_ptr, value_ptr, int *));
d195 1
a195 1
static void vpush PARAMS ((struct vstack ** pstack, struct varobj * var));
d197 1
a197 1
static struct varobj *vpop PARAMS ((struct vstack ** pstack));
d199 1
a199 1
static void cppush PARAMS ((struct cpstack ** pstack, char *name));
d201 1
a201 1
static char *cppop PARAMS ((struct cpstack ** pstack));
d205 1
a205 1
static enum varobj_languages variable_language PARAMS ((struct varobj * var));
d207 1
a207 1
static int number_of_children PARAMS ((struct varobj *));
d209 1
a209 1
static char *name_of_variable PARAMS ((struct varobj *));
d211 1
a211 1
static char *name_of_child PARAMS ((struct varobj *, int));
d213 1
a213 2
static value_ptr value_of_root PARAMS ((struct varobj ** var_handle,
					int *));
d215 1
a215 1
static value_ptr value_of_child PARAMS ((struct varobj * parent, int index));
d217 1
a217 1
static struct type *type_of_child PARAMS ((struct varobj * var));
d219 1
a219 1
static int variable_editable PARAMS ((struct varobj * var));
d221 1
a221 1
static char *my_value_of_variable PARAMS ((struct varobj * var));
d223 1
a223 1
static int type_changeable PARAMS ((struct varobj * var));
d227 1
a227 1
static int c_number_of_children PARAMS ((struct varobj * var));
d229 1
a229 1
static char *c_name_of_variable PARAMS ((struct varobj * parent));
d231 1
a231 1
static char *c_name_of_child PARAMS ((struct varobj * parent, int index));
d233 1
a233 1
static value_ptr c_value_of_root PARAMS ((struct varobj ** var_handle));
d235 1
a235 1
static value_ptr c_value_of_child PARAMS ((struct varobj * parent, int index));
d237 1
a237 1
static struct type *c_type_of_child PARAMS ((struct varobj * parent, int index));
d239 1
a239 1
static int c_variable_editable PARAMS ((struct varobj * var));
d241 1
a241 1
static char *c_value_of_variable PARAMS ((struct varobj * var));
d245 1
a245 1
static int cplus_number_of_children PARAMS ((struct varobj * var));
d247 1
a247 1
static void cplus_class_num_children PARAMS ((struct type * type, int children[3]));
d249 1
a249 1
static char *cplus_name_of_variable PARAMS ((struct varobj * parent));
d251 1
a251 1
static char *cplus_name_of_child PARAMS ((struct varobj * parent, int index));
d253 1
a253 1
static value_ptr cplus_value_of_root PARAMS ((struct varobj ** var_handle));
d255 1
a255 1
static value_ptr cplus_value_of_child PARAMS ((struct varobj * parent, int index));
d257 1
a257 1
static struct type *cplus_type_of_child PARAMS ((struct varobj * parent, int index));
d259 1
a259 1
static int cplus_variable_editable PARAMS ((struct varobj * var));
d261 1
a261 1
static char *cplus_value_of_variable PARAMS ((struct varobj * var));
d265 1
a265 1
static int java_number_of_children PARAMS ((struct varobj * var));
d267 1
a267 1
static char *java_name_of_variable PARAMS ((struct varobj * parent));
d269 1
a269 1
static char *java_name_of_child PARAMS ((struct varobj * parent, int index));
d271 1
a271 1
static value_ptr java_value_of_root PARAMS ((struct varobj ** var_handle));
d273 1
a273 1
static value_ptr java_value_of_child PARAMS ((struct varobj * parent, int index));
d275 1
a275 1
static struct type *java_type_of_child PARAMS ((struct varobj * parent, int index));
d277 1
a277 1
static int java_variable_editable PARAMS ((struct varobj * var));
d279 1
a279 1
static char *java_value_of_variable PARAMS ((struct varobj * var));
@


1.3
log
@2000-03-30  Fernando Nasser  <fnasser@@cygnus.com>

	* wrapper.c (gdb_value_subscript, wrap_value_subscript): New functions.
	Safe version of value_subscript.
	* varobj.c (): Use gdb_value_subscript() to get an array element value.
@
text
@d183 2
d421 1
a421 1
  old_chain = make_cleanup ((make_cleanup_func) free_variable, var);
d1376 12
@


1.2
log
@2000-03-13  James Ingham  <jingham@@leda.cygnus.com>

	Add support for a variable object that tries to evaluate itself in
	the currently selected frame, rather than in a fixed frame.

	* wrapper.c,h (gdb_parse_exp_1): Added a wrapper for
 	gdb_parse_exp_1.
	* varobj.h: Added USE_CURRENT_FRAME to varobj_type & changed def'n
	of varobj_create.
	* varobj.c (varobj_list): Return type indicates whether the
	variable's type has changed (for current frame variables).
	(varobj_update): Handle the case where the variable's type has
	changed.
	(delete_variable_1): Allow for deletion of variables that have not
	been installed yet.
	(new_root_variable): Initialize use_selected_frame variable.
	(value_of_root): This is where most of the work to handle "current
	frame" variables was added.  Most of the complexity involves
	handling the case where the type of the variable has changed.
	(varobj_create): Add a "type" argument, to tell if the
	variable is one of these "current frame" variables.  Also protect
	call to parse_exp_1 from long jumping.

	* mi-var-block.exp: The error report from varobj_create changed
	since I am now trapping parse_exp_1 errors.  Change the tests to
	match the new error message.
	* mi-var-child.exp: Ditto.
	* mi-var-cmd.exp: Ditto.

	* lib/gdb.exp: Fix the gdbtk_start routine to correctly find all
	the library directories.

	* gdbtk-varobj.c (variable_create): Pass the correct
	"how_specified" flag to the varobj_create routine.
@
text
@d1957 1
a1957 1
  value_ptr value, temp;
d1972 2
d1977 4
@


1.1
log
@Initial revision
@
text
@d59 4
d211 2
a212 1
static value_ptr value_of_root PARAMS ((struct varobj * var));
d232 1
a232 1
static value_ptr c_value_of_root PARAMS ((struct varobj * var));
d252 1
a252 1
static value_ptr cplus_value_of_root PARAMS ((struct varobj * var));
d270 1
a270 1
static value_ptr java_value_of_root PARAMS ((struct varobj * var));
d298 1
a298 1
      value_ptr (*value_of_root) PARAMS ((struct varobj * root));
d409 2
a410 1
	       char *expression, CORE_ADDR frame)
d430 2
a431 1
      if (frame == (CORE_ADDR) -1)
d436 4
d446 6
a451 2
      /* Callee may longjump */
      var->root->exp = parse_exp_1 (&p, block, 0);
d504 4
a507 1
  if (var != NULL)
d866 4
d877 1
d904 5
a908 2
     the frame in which a local existed. */
  new = value_of_root (var);
d910 4
a913 1
    return -1;
d918 1
a918 1
  if (!my_value_equal (var->value, new, &error2))
d921 4
a924 2
         though. We don't want some types to be reported as "changed". */
      if (type_changeable (var))
d1018 4
a1021 1
  return changed;
d1076 3
a1078 3
  if (var->obj_name == NULL)
    warning ("Assertion failed: NULL var->obj_name unexpectdly found");
  else
d1094 3
a1096 2

  uninstall_variable (var);
d1353 1
d1617 10
a1626 1
/* What is the value_ptr of the root variable VAR? */
d1628 3
a1630 2
value_of_root (var)
     struct varobj *var;
d1632 53
a1684 1
  return (*var->root->lang->value_of_root) (var);
d1891 2
a1892 2
c_value_of_root (var)
     struct varobj *var;
d1895 1
d1899 6
d1911 2
d1914 1
d1920 1
a1920 1

d1923 3
a1925 2
      /* We need to catch errors here, because if evaluate expression fails
         we just want to make val->error = 1 and go on */
d1930 6
a1935 4
	      /* We need to catch errors because if value_fetch_lazy fails we
	         still want to continue (after making val->error = 1) */
	      /* FIXME: Shouldn't be using VALUE_CONTENTS?  The comment on
	         value_fetch_lazy() says it is only called from the macro... */
d1944 1
a1944 1

d2308 2
a2309 2
cplus_value_of_root (var)
     struct varobj *var;
d2311 1
a2311 1
  return c_value_of_root (var);
d2481 2
a2482 2
java_value_of_root (var)
     struct varobj *var;
d2484 1
a2484 1
  return cplus_value_of_root (var);
@


1.1.1.1
log
@import gdb-2000-02-02 snapshot
@
text
@@
