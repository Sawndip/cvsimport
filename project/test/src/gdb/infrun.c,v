head	1.595;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.576.2.1
	gdb_7_6-2013-04-26-release:1.576
	gdb_7_6-branch:1.576.0.2
	gdb_7_6-2013-03-12-branchpoint:1.576
	gdb_7_5_1-2012-11-29-release:1.549.2.1
	gdb_7_5-2012-08-17-release:1.549
	gdb_7_5-branch:1.549.0.2
	gdb_7_5-2012-07-18-branchpoint:1.549
	gdb_7_4_1-2012-04-26-release:1.515.2.1
	gdb_7_4-2012-01-24-release:1.515.2.1
	gdb_7_4-branch:1.515.0.2
	gdb_7_4-2011-12-13-branchpoint:1.515
	gdb_7_3_1-2011-09-04-release:1.472.2.2
	gdb_7_3-2011-07-26-release:1.472.2.2
	gdb_7_3-branch:1.472.0.2
	gdb_7_3-2011-04-01-branchpoint:1.472
	gdb_7_2-2010-09-02-release:1.445.2.1
	gdb_7_2-branch:1.445.0.2
	gdb_7_2-2010-07-07-branchpoint:1.445
	gdb_7_1-2010-03-18-release:1.429.2.1
	gdb_7_1-branch:1.429.0.2
	gdb_7_1-2010-02-18-branchpoint:1.429
	gdb_7_0_1-2009-12-22-release:1.409.2.1
	gdb_7_0-2009-10-06-release:1.409.2.1
	gdb_7_0-branch:1.409.0.2
	gdb_7_0-2009-09-16-branchpoint:1.409
	arc-sim-20090309:1.266
	msnyder-checkpoint-072509-branch:1.402.0.2
	msnyder-checkpoint-072509-branchpoint:1.402
	arc-insight_6_8-branch:1.266.0.6
	arc-insight_6_8-branchpoint:1.266
	insight_6_8-branch:1.266.0.4
	insight_6_8-branchpoint:1.266
	reverse-20081226-branch:1.347.0.2
	reverse-20081226-branchpoint:1.347
	multiprocess-20081120-branch:1.339.0.2
	multiprocess-20081120-branchpoint:1.339
	reverse-20080930-branch:1.322.0.2
	reverse-20080930-branchpoint:1.322
	reverse-20080717-branch:1.300.0.2
	reverse-20080717-branchpoint:1.300
	msnyder-reverse-20080609-branch:1.278.0.2
	msnyder-reverse-20080609-branchpoint:1.278
	drow-reverse-20070409-branch:1.225.0.2
	drow-reverse-20070409-branchpoint:1.225
	gdb_6_8-2008-03-27-release:1.266
	gdb_6_8-branch:1.266.0.2
	gdb_6_8-2008-02-26-branchpoint:1.266
	gdb_6_7_1-2007-10-29-release:1.245
	gdb_6_7-2007-10-10-release:1.245
	gdb_6_7-branch:1.245.0.2
	gdb_6_7-2007-09-07-branchpoint:1.245
	insight_6_6-20070208-release:1.216
	gdb_6_6-2006-12-18-release:1.216
	gdb_6_6-branch:1.216.0.2
	gdb_6_6-2006-11-15-branchpoint:1.216
	insight_6_5-20061003-release:1.210.8.1
	gdb-csl-symbian-6_4_50_20060226-12:1.209.2.1.2.2
	gdb-csl-sourcerygxx-3_4_4-25:1.207
	nickrob-async-20060828-mergepoint:1.214
	gdb-csl-symbian-6_4_50_20060226-11:1.209.2.1.2.1
	gdb-csl-sourcerygxx-4_1-17:1.209.2.1
	gdb-csl-20060226-branch-local-2:1.209.2.1
	gdb-csl-sourcerygxx-4_1-14:1.209.2.1
	gdb-csl-sourcerygxx-4_1-13:1.209.2.1
	gdb-csl-sourcerygxx-4_1-12:1.209.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.209.2.1
	gdb_6_5-20060621-release:1.210.8.1
	gdb-csl-sourcerygxx-4_1-9:1.209.2.1
	gdb-csl-sourcerygxx-4_1-8:1.209.2.1
	gdb-csl-sourcerygxx-4_1-7:1.209.2.1
	gdb-csl-arm-2006q1-6:1.209.2.1
	gdb-csl-sourcerygxx-4_1-6:1.209.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.209.2.1.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.209.2.1.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.209.2.1.2.1
	gdb-csl-coldfire-4_1-11:1.209.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.209.2.1
	gdb-csl-coldfire-4_1-10:1.209.2.1
	gdb_6_5-branch:1.210.0.8
	gdb_6_5-2006-05-14-branchpoint:1.210
	gdb-csl-sourcerygxx-4_1-5:1.209.2.1
	nickrob-async-20060513-branch:1.210.0.6
	nickrob-async-20060513-branchpoint:1.210
	gdb-csl-sourcerygxx-4_1-4:1.209.2.1
	msnyder-reverse-20060502-branch:1.210.0.4
	msnyder-reverse-20060502-branchpoint:1.210
	gdb-csl-morpho-4_1-4:1.209.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.209.2.1
	readline_5_1-import-branch:1.210.0.2
	readline_5_1-import-branchpoint:1.210
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.209.2.1
	gdb-csl-symbian-20060226-branch:1.209.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.209.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.209.2.1
	msnyder-reverse-20060331-branch:1.209.0.6
	msnyder-reverse-20060331-branchpoint:1.209
	gdb-csl-available-20060303-branch:1.209.0.4
	gdb-csl-available-20060303-branchpoint:1.209
	gdb-csl-20060226-branch:1.209.0.2
	gdb-csl-20060226-branchpoint:1.209
	gdb_6_4-20051202-release:1.205.4.1
	msnyder-fork-checkpoint-branch:1.207.0.4
	msnyder-fork-checkpoint-branchpoint:1.207
	gdb-csl-gxxpro-6_3-branch:1.207.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.207
	gdb_6_4-branch:1.205.0.4
	gdb_6_4-2005-11-01-branchpoint:1.205
	gdb-csl-arm-20051020-branch:1.205.0.2
	gdb-csl-arm-20051020-branchpoint:1.205
	msnyder-tracepoint-checkpoint-branch:1.202.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.202
	gdb-csl-arm-20050325-2005-q1b:1.199
	gdb-csl-arm-20050325-2005-q1a:1.199
	csl-arm-20050325-branch:1.199.0.2
	csl-arm-20050325-branchpoint:1.199
	gdb-post-i18n-errorwarning-20050211:1.190
	gdb-pre-i18n-errorwarning-20050211:1.189
	gdb_6_3-20041109-release:1.178
	gdb_6_3-branch:1.178.0.2
	gdb_6_3-20041019-branchpoint:1.178
	drow_intercu-merge-20040921:1.177
	drow_intercu-merge-20040915:1.177
	jimb-gdb_6_2-e500-branch:1.168.2.1.0.4
	jimb-gdb_6_2-e500-branchpoint:1.168.2.1
	gdb_6_2-20040730-release:1.168.2.1
	gdb_6_2-branch:1.168.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.168
	gdb_6_1_1-20040616-release:1.137
	gdb_6_1-2004-04-05-release:1.137
	drow_intercu-merge-20040402:1.143
	drow_intercu-merge-20040327:1.142
	ezannoni_pie-20040323-branch:1.142.0.2
	ezannoni_pie-20040323-branchpoint:1.142
	cagney_tramp-20040321-mergepoint:1.141
	cagney_tramp-20040309-branch:1.139.0.2
	cagney_tramp-20040309-branchpoint:1.139
	gdb_6_1-branch:1.137.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.137
	drow_intercu-20040221-branch:1.137.0.2
	drow_intercu-20040221-branchpoint:1.137
	cagney_bfdfile-20040213-branch:1.135.0.2
	cagney_bfdfile-20040213-branchpoint:1.135
	drow-cplus-merge-20040208:1.135
	carlton_dictionary-20040126-merge:1.131
	cagney_bigcore-20040122-branch:1.131.0.2
	cagney_bigcore-20040122-branchpoint:1.131
	drow-cplus-merge-20040113:1.126
	drow-cplus-merge-20031224:1.122
	drow-cplus-merge-20031220:1.122
	carlton_dictionary-20031215-merge:1.122
	drow-cplus-merge-20031214:1.122
	carlton-dictionary-20031111-merge:1.118
	gdb_6_0-2003-10-04-release:1.110
	kettenis_sparc-20030918-branch:1.113.0.4
	kettenis_sparc-20030918-branchpoint:1.113
	carlton_dictionary-20030917-merge:1.113
	ezannoni_pie-20030916-branchpoint:1.113
	ezannoni_pie-20030916-branch:1.113.0.2
	cagney_x86i386-20030821-branch:1.110.0.4
	cagney_x86i386-20030821-branchpoint:1.110
	carlton_dictionary-20030805-merge:1.110
	carlton_dictionary-20030627-merge:1.110
	gdb_6_0-branch:1.110.0.2
	gdb_6_0-2003-06-23-branchpoint:1.110
	jimb-ppc64-linux-20030613-branch:1.109.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.109
	cagney_convert-20030606-branch:1.109.0.10
	cagney_convert-20030606-branchpoint:1.109
	cagney_writestrings-20030508-branch:1.109.0.8
	cagney_writestrings-20030508-branchpoint:1.109
	jimb-ppc64-linux-20030528-branch:1.109.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.109
	carlton_dictionary-20030523-merge:1.109
	cagney_fileio-20030521-branch:1.109.0.4
	cagney_fileio-20030521-branchpoint:1.109
	kettenis_i386newframe-20030517-mergepoint:1.109
	jimb-ppc64-linux-20030509-branch:1.109.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.109
	kettenis_i386newframe-20030504-mergepoint:1.107
	carlton_dictionary-20030430-merge:1.107
	kettenis_i386newframe-20030419-branch:1.107.0.2
	kettenis_i386newframe-20030419-branchpoint:1.107
	carlton_dictionary-20030416-merge:1.107
	cagney_frameaddr-20030409-mergepoint:1.105
	kettenis_i386newframe-20030406-branch:1.102.0.4
	kettenis_i386newframe-20030406-branchpoint:1.102
	cagney_frameaddr-20030403-branchpoint:1.102
	cagney_frameaddr-20030403-branch:1.102.0.2
	cagney_framebase-20030330-mergepoint:1.101
	cagney_framebase-20030326-branch:1.100.0.2
	cagney_framebase-20030326-branchpoint:1.100
	cagney_lazyid-20030317-branch:1.97.0.8
	cagney_lazyid-20030317-branchpoint:1.97
	kettenis-i386newframe-20030316-mergepoint:1.97
	offbyone-20030313-branch:1.97.0.6
	offbyone-20030313-branchpoint:1.97
	kettenis-i386newframe-20030308-branch:1.97.0.4
	kettenis-i386newframe-20030308-branchpoint:1.97
	carlton_dictionary-20030305-merge:1.97
	cagney_offbyone-20030303-branch:1.97.0.2
	cagney_offbyone-20030303-branchpoint:1.97
	carlton_dictionary-20030207-merge:1.96
	interps-20030203-mergepoint:1.96
	interps-20030202-branch:1.96.0.2
	interps-20030202-branchpoint:1.96
	cagney-unwind-20030108-branch:1.93.0.2
	cagney-unwind-20030108-branchpoint:1.93
	carlton_dictionary-20021223-merge:1.92
	gdb_5_3-2002-12-12-release:1.70.6.1
	carlton_dictionary-20021115-merge:1.74
	kseitz_interps-20021105-merge:1.74
	kseitz_interps-20021103-merge:1.74
	drow-cplus-merge-20021020:1.73
	drow-cplus-merge-20021025:1.74
	carlton_dictionary-20021025-merge:1.74
	carlton_dictionary-20021011-merge:1.73
	drow-cplus-branch:1.72.0.2
	drow-cplus-branchpoint:1.72
	kseitz_interps-20020930-merge:1.71
	carlton_dictionary-20020927-merge:1.71
	carlton_dictionary-branch:1.71.0.2
	carlton_dictionary-20020920-branchpoint:1.71
	gdb_5_3-branch:1.70.0.6
	gdb_5_3-2002-09-04-branchpoint:1.70
	kseitz_interps-20020829-merge:1.70
	cagney_sysregs-20020825-branch:1.70.0.4
	cagney_sysregs-20020825-branchpoint:1.70
	readline_4_3-import-branch:1.70.0.2
	readline_4_3-import-branchpoint:1.70
	gdb_5_2_1-2002-07-23-release:1.54
	kseitz_interps-20020528-branch:1.58.0.6
	kseitz_interps-20020528-branchpoint:1.58
	cagney_regbuf-20020515-branch:1.58.0.4
	cagney_regbuf-20020515-branchpoint:1.58
	jimb-macro-020506-branch:1.58.0.2
	jimb-macro-020506-branchpoint:1.58
	gdb_5_2-2002-04-29-release:1.54
	gdb_5_2-branch:1.54.0.2
	gdb_5_2-2002-03-03-branchpoint:1.54
	gdb_5_1_1-2002-01-24-release:1.45
	gdb_5_1_0_1-2002-01-03-release:1.45
	cygnus_cvs_20020108_pre:1.49
	gdb_5_1_0_1-2002-01-03-branchpoint:1.45
	gdb_5_1_0_1-2002-01-03-branch:1.45.0.6
	gdb_5_1-2001-11-21-release:1.45
	gdb_s390-2001-09-26-branch:1.45.0.4
	gdb_s390-2001-09-26-branchpoint:1.45
	gdb_5_1-2001-07-29-branch:1.45.0.2
	gdb_5_1-2001-07-29-branchpoint:1.45
	dberlin-typesystem-branch:1.42.0.2
	dberlin-typesystem-branchpoint:1.42
	gdb-post-ptid_t-2001-05-03:1.31
	gdb-pre-ptid_t-2001-05-03:1.30
	insight-precleanup-2001-01-01:1.23
	gdb-post-protoization-2000-07-29:1.17
	gdb-pre-protoization-2000-07-29:1.16
	gdb-premipsmulti-2000-06-06-branch:1.14.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.14
	gdb-post-params-removal-2000-06-04:1.14
	gdb-pre-params-removal-2000-06-04:1.14
	gdb-post-params-removal-2000-05-28:1.14
	gdb-pre-params-removal-2000-05-28:1.14
	gdb_5_0-2000-05-19-release:1.6.2.2
	gdb_4_18_2-2000-05-18-release:1.6.2.2
	gdb_4_95_1-2000-05-11-snapshot:1.6.2.2
	gdb_4_95_0-2000-04-27-snapshot:1.6.2.2
	gdb_5_0-2000-04-10-branch:1.6.0.2
	gdb_5_0-2000-04-10-branchpoint:1.6
	repo-unification-2000-02-06:1.1.1.27
	insight-2000-02-04:1.1.1.27
	gdb-2000-02-04:1.1.1.27
	gdb-2000-02-02:1.1.1.26
	gdb-2000-02-01:1.1.1.25
	gdb-2000-01-31:1.1.1.25
	gdb-2000-01-26:1.1.1.25
	gdb-2000-01-24:1.1.1.25
	gdb-2000-01-17:1.1.1.25
	gdb-2000-01-10:1.1.1.24
	gdb-2000-01-05:1.1.1.24
	gdb-1999-12-21:1.1.1.23
	gdb-1999-12-13:1.1.1.23
	gdb-1999-12-07:1.1.1.22
	gdb-1999-12-06:1.1.1.22
	gdb-1999-11-16:1.1.1.21
	gdb-1999-11-08:1.1.1.21
	gdb-1999-11-01:1.1.1.20
	gdb-1999-10-25:1.1.1.20
	gdb-1999-10-18:1.1.1.20
	gdb-1999-10-11:1.1.1.19
	gdb-1999-10-04:1.1.1.19
	gdb-1999-09-28:1.1.1.18
	gdb-1999-09-21:1.1.1.17
	gdb-1999-09-13:1.1.1.16
	gdb-1999-09-08:1.1.1.16
	gdb-1999-08-30:1.1.1.15
	gdb-1999-08-23:1.1.1.14
	gdb-1999-08-16:1.1.1.13
	gdb-1999-08-09:1.1.1.12
	gdb-1999-08-02:1.1.1.11
	gdb-1999-07-26:1.1.1.10
	gdb-1999-07-19:1.1.1.10
	gdb-1999-07-12:1.1.1.9
	gdb-post-reformat-19990707:1.1.1.9
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.9
	gdb-pre-reformat-19990707:1.1.1.8
	gdb-1999-07-07:1.1.1.8
	gdb-1999-07-05:1.1.1.8
	gdb-1999-06-28:1.1.1.7
	gdb-1999-06-21:1.1.1.7
	gdb-1999-06-14:1.1.1.7
	gdb-1999-06-07:1.1.1.6
	gdb-1999-06-01:1.1.1.6
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.6
	gdb-1999-05-19:1.1.1.5
	gdb-1999-05-10:1.1.1.4
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.595
date	2013.10.18.14.28.33;	author palves;	state Exp;
branches;
next	1.594;

1.594
date	2013.10.07.05.34.10;	author sergiodj;	state Exp;
branches;
next	1.593;

1.593
date	2013.09.30.11.50.11;	author luisgpm;	state Exp;
branches;
next	1.592;

1.592
date	2013.09.18.13.02.42;	author mmetzger;	state Exp;
branches;
next	1.591;

1.591
date	2013.09.17.18.26.39;	author palves;	state Exp;
branches;
next	1.590;

1.590
date	2013.09.03.17.22.45;	author luisgpm;	state Exp;
branches;
next	1.589;

1.589
date	2013.06.28.17.19.39;	author palves;	state Exp;
branches;
next	1.588;

1.588
date	2013.06.28.17.06.14;	author palves;	state Exp;
branches;
next	1.587;

1.587
date	2013.06.27.19.17.26;	author palves;	state Exp;
branches;
next	1.586;

1.586
date	2013.06.26.21.38.23;	author palves;	state Exp;
branches;
next	1.585;

1.585
date	2013.06.26.21.37.53;	author palves;	state Exp;
branches;
next	1.584;

1.584
date	2013.06.18.19.57.48;	author tromey;	state Exp;
branches;
next	1.583;

1.583
date	2013.06.04.13.17.06;	author gary;	state Exp;
branches;
next	1.582;

1.582
date	2013.05.30.17.37.50;	author tromey;	state Exp;
branches;
next	1.581;

1.581
date	2013.05.23.17.15.34;	author palves;	state Exp;
branches;
next	1.580;

1.580
date	2013.05.23.17.12.50;	author palves;	state Exp;
branches;
next	1.579;

1.579
date	2013.05.06.14.15.49;	author brobecke;	state Exp;
branches;
next	1.578;

1.578
date	2013.04.22.09.34.27;	author qiyao;	state Exp;
branches;
next	1.577;

1.577
date	2013.03.13.18.34.53;	author palves;	state Exp;
branches;
next	1.576;

1.576
date	2013.03.11.08.45.54;	author mmetzger;	state Exp;
branches
	1.576.2.1;
next	1.575;

1.575
date	2013.03.11.08.42.55;	author mmetzger;	state Exp;
branches;
next	1.574;

1.574
date	2013.01.31.19.18.58;	author aristovski;	state Exp;
branches;
next	1.573;

1.573
date	2013.01.18.03.03.42;	author qiyao;	state Exp;
branches;
next	1.572;

1.572
date	2013.01.16.17.31.38;	author tromey;	state Exp;
branches;
next	1.571;

1.571
date	2013.01.01.06.32.45;	author brobecke;	state Exp;
branches;
next	1.570;

1.570
date	2012.12.24.19.40.04;	author jkratoch;	state Exp;
branches;
next	1.569;

1.569
date	2012.11.30.14.35.50;	author qiyao;	state Exp;
branches;
next	1.568;

1.568
date	2012.11.30.07.24.48;	author qiyao;	state Exp;
branches;
next	1.567;

1.567
date	2012.11.20.03.10.24;	author qiyao;	state Exp;
branches;
next	1.566;

1.566
date	2012.11.19.06.56.52;	author qiyao;	state Exp;
branches;
next	1.565;

1.565
date	2012.11.09.12.20.22;	author palves;	state Exp;
branches;
next	1.564;

1.564
date	2012.11.05.18.56.45;	author palves;	state Exp;
branches;
next	1.563;

1.563
date	2012.11.02.18.13.35;	author palves;	state Exp;
branches;
next	1.562;

1.562
date	2012.10.26.18.48.43;	author palves;	state Exp;
branches;
next	1.561;

1.561
date	2012.10.26.18.47.33;	author palves;	state Exp;
branches;
next	1.560;

1.560
date	2012.10.26.16.47.17;	author palves;	state Exp;
branches;
next	1.559;

1.559
date	2012.09.17.07.26.55;	author siddhesh;	state Exp;
branches;
next	1.558;

1.558
date	2012.09.17.07.09.34;	author jkratoch;	state Exp;
branches;
next	1.557;

1.557
date	2012.08.23.16.59.12;	author palves;	state Exp;
branches;
next	1.556;

1.556
date	2012.08.16.23.54.50;	author brobecke;	state Exp;
branches;
next	1.555;

1.555
date	2012.08.15.01.59.42;	author vapier;	state Exp;
branches;
next	1.554;

1.554
date	2012.08.10.05.03.11;	author vapier;	state Exp;
branches;
next	1.553;

1.553
date	2012.08.02.09.36.39;	author qiyao;	state Exp;
branches;
next	1.552;

1.552
date	2012.07.20.17.27.28;	author palves;	state Exp;
branches;
next	1.551;

1.551
date	2012.07.18.18.04.39;	author palves;	state Exp;
branches;
next	1.550;

1.550
date	2012.07.18.16.12.16;	author sergiodj;	state Exp;
branches;
next	1.549;

1.549
date	2012.07.01.10.37.04;	author qiyao;	state Exp;
branches
	1.549.2.1;
next	1.548;

1.548
date	2012.06.28.16.34.02;	author palves;	state Exp;
branches;
next	1.547;

1.547
date	2012.06.18.17.28.37;	author jkratoch;	state Exp;
branches;
next	1.546;

1.546
date	2012.06.15.08.50.29;	author macro;	state Exp;
branches;
next	1.545;

1.545
date	2012.06.14.21.15.19;	author macro;	state Exp;
branches;
next	1.544;

1.544
date	2012.06.13.18.15.05;	author jkratoch;	state Exp;
branches;
next	1.543;

1.543
date	2012.06.12.18.30.26;	author palves;	state Exp;
branches;
next	1.542;

1.542
date	2012.06.11.15.15.04;	author tromey;	state Exp;
branches;
next	1.541;

1.541
date	2012.06.06.19.27.23;	author palves;	state Exp;
branches;
next	1.540;

1.540
date	2012.06.06.18.40.06;	author palves;	state Exp;
branches;
next	1.539;

1.539
date	2012.06.06.18.10.15;	author palves;	state Exp;
branches;
next	1.538;

1.538
date	2012.05.28.20.43.26;	author palves;	state Exp;
branches;
next	1.537;

1.537
date	2012.05.24.16.51.34;	author palves;	state Exp;
branches;
next	1.536;

1.536
date	2012.05.24.16.39.09;	author palves;	state Exp;
branches;
next	1.535;

1.535
date	2012.05.10.19.50.07;	author tromey;	state Exp;
branches;
next	1.534;

1.534
date	2012.05.03.14.59.40;	author palves;	state Exp;
branches;
next	1.533;

1.533
date	2012.04.27.20.48.57;	author sergiodj;	state Exp;
branches;
next	1.532;

1.532
date	2012.04.27.20.38.38;	author sergiodj;	state Exp;
branches;
next	1.531;

1.531
date	2012.04.26.16.56.16;	author macro;	state Exp;
branches;
next	1.530;

1.530
date	2012.04.13.20.46.42;	author luisgpm;	state Exp;
branches;
next	1.529;

1.529
date	2012.04.11.16.58.57;	author jkratoch;	state Exp;
branches;
next	1.528;

1.528
date	2012.03.07.19.25.36;	author palves;	state Exp;
branches;
next	1.527;

1.527
date	2012.03.01.21.11.21;	author palves;	state Exp;
branches;
next	1.526;

1.526
date	2012.02.29.14.52.44;	author jkratoch;	state Exp;
branches;
next	1.525;

1.525
date	2012.02.27.21.36.47;	author macro;	state Exp;
branches;
next	1.524;

1.524
date	2012.02.16.21.07.20;	author tromey;	state Exp;
branches;
next	1.523;

1.523
date	2012.02.02.20.19.15;	author devans;	state Exp;
branches;
next	1.522;

1.522
date	2012.01.28.18.08.18;	author jkratoch;	state Exp;
branches;
next	1.521;

1.521
date	2012.01.24.21.39.15;	author tromey;	state Exp;
branches;
next	1.520;

1.520
date	2012.01.24.21.32.56;	author tromey;	state Exp;
branches;
next	1.519;

1.519
date	2012.01.24.21.31.24;	author tromey;	state Exp;
branches;
next	1.518;

1.518
date	2012.01.06.03.34.46;	author sergiodj;	state Exp;
branches;
next	1.517;

1.517
date	2012.01.05.13.11.30;	author palves;	state Exp;
branches;
next	1.516;

1.516
date	2012.01.04.08.17.04;	author brobecke;	state Exp;
branches;
next	1.515;

1.515
date	2011.11.22.21.25.17;	author tromey;	state Exp;
branches
	1.515.2.1;
next	1.514;

1.514
date	2011.11.07.16.30.19;	author brobecke;	state Exp;
branches;
next	1.513;

1.513
date	2011.11.01.14.51.21;	author jlebar;	state Exp;
branches;
next	1.512;

1.512
date	2011.10.28.18.29.59;	author palves;	state Exp;
branches;
next	1.511;

1.511
date	2011.10.24.14.09.20;	author palves;	state Exp;
branches;
next	1.510;

1.510
date	2011.10.24.14.01.12;	author palves;	state Exp;
branches;
next	1.509;

1.509
date	2011.10.12.15.43.49;	author gary;	state Exp;
branches;
next	1.508;

1.508
date	2011.10.07.12.06.46;	author uweigand;	state Exp;
branches;
next	1.507;

1.507
date	2011.09.22.02.58.31;	author qiyao;	state Exp;
branches;
next	1.506;

1.506
date	2011.09.17.13.29.31;	author qiyao;	state Exp;
branches;
next	1.505;

1.505
date	2011.09.14.12.26.29;	author palves;	state Exp;
branches;
next	1.504;

1.504
date	2011.09.07.14.24.48;	author qiyao;	state Exp;
branches;
next	1.503;

1.503
date	2011.09.05.15.46.34;	author palves;	state Exp;
branches;
next	1.502;

1.502
date	2011.09.05.14.53.13;	author palves;	state Exp;
branches;
next	1.501;

1.501
date	2011.09.02.16.56.29;	author palves;	state Exp;
branches;
next	1.500;

1.500
date	2011.09.02.12.18.27;	author palves;	state Exp;
branches;
next	1.499;

1.499
date	2011.08.26.21.45.22;	author jkratoch;	state Exp;
branches;
next	1.498;

1.498
date	2011.08.04.19.10.12;	author palves;	state Exp;
branches;
next	1.497;

1.497
date	2011.07.21.23.46.09;	author kcy;	state Exp;
branches;
next	1.496;

1.496
date	2011.07.19.12.24.34;	author gary;	state Exp;
branches;
next	1.495;

1.495
date	2011.07.14.15.00.19;	author jkratoch;	state Exp;
branches;
next	1.494;

1.494
date	2011.06.23.15.08.01;	author qiyao;	state Exp;
branches;
next	1.493;

1.493
date	2011.06.22.10.09.22;	author qiyao;	state Exp;
branches;
next	1.492;

1.492
date	2011.06.06.12.47.07;	author palves;	state Exp;
branches;
next	1.491;

1.491
date	2011.06.03.15.32.44;	author tromey;	state Exp;
branches;
next	1.490;

1.490
date	2011.05.30.18.04.32;	author palves;	state Exp;
branches;
next	1.489;

1.489
date	2011.05.27.18.26.19;	author palves;	state Exp;
branches;
next	1.488;

1.488
date	2011.05.26.18.23.31;	author palves;	state Exp;
branches;
next	1.487;

1.487
date	2011.05.26.18.11.32;	author palves;	state Exp;
branches;
next	1.486;

1.486
date	2011.05.26.15.32.37;	author palves;	state Exp;
branches;
next	1.485;

1.485
date	2011.05.26.14.59.17;	author palves;	state Exp;
branches;
next	1.484;

1.484
date	2011.05.23.15.18.36;	author palves;	state Exp;
branches;
next	1.483;

1.483
date	2011.05.20.18.38.16;	author palves;	state Exp;
branches;
next	1.482;

1.482
date	2011.05.20.16.43.46;	author palves;	state Exp;
branches;
next	1.481;

1.481
date	2011.05.20.16.31.31;	author palves;	state Exp;
branches;
next	1.480;

1.480
date	2011.05.18.16.20.27;	author palves;	state Exp;
branches;
next	1.479;

1.479
date	2011.05.17.11.43.07;	author palves;	state Exp;
branches;
next	1.478;

1.478
date	2011.05.09.14.25.37;	author palves;	state Exp;
branches;
next	1.477;

1.477
date	2011.04.28.15.52.59;	author uweigand;	state Exp;
branches;
next	1.476;

1.476
date	2011.04.27.17.08.41;	author uweigand;	state Exp;
branches;
next	1.475;

1.475
date	2011.04.27.13.29.13;	author uweigand;	state Exp;
branches;
next	1.474;

1.474
date	2011.04.20.17.01.09;	author palves;	state Exp;
branches;
next	1.473;

1.473
date	2011.04.19.18.04.07;	author tromey;	state Exp;
branches;
next	1.472;

1.472
date	2011.03.07.16.03.00;	author tromey;	state Exp;
branches
	1.472.2.1;
next	1.471;

1.471
date	2011.03.01.01.00.31;	author msnyder;	state Exp;
branches;
next	1.470;

1.470
date	2011.02.16.14.54.42;	author qiyao;	state Exp;
branches;
next	1.469;

1.469
date	2011.02.14.11.22.29;	author palves;	state Exp;
branches;
next	1.468;

1.468
date	2011.02.11.15.07.50;	author palves;	state Exp;
branches;
next	1.467;

1.467
date	2011.01.09.03.08.56;	author msnyder;	state Exp;
branches;
next	1.466;

1.466
date	2011.01.07.17.35.27;	author msnyder;	state Exp;
branches;
next	1.465;

1.465
date	2011.01.06.14.58.58;	author brobecke;	state Exp;
branches;
next	1.464;

1.464
date	2011.01.05.22.22.49;	author msnyder;	state Exp;
branches;
next	1.463;

1.463
date	2011.01.01.15.33.08;	author brobecke;	state Exp;
branches;
next	1.462;

1.462
date	2010.12.15.21.19.50;	author tromey;	state Exp;
branches;
next	1.461;

1.461
date	2010.12.09.16.09.52;	author tromey;	state Exp;
branches;
next	1.460;

1.460
date	2010.11.28.04.33.46;	author jkratoch;	state Exp;
branches;
next	1.459;

1.459
date	2010.11.28.04.31.24;	author jkratoch;	state Exp;
branches;
next	1.458;

1.458
date	2010.11.26.03.39.10;	author jkratoch;	state Exp;
branches;
next	1.457;

1.457
date	2010.11.24.19.08.30;	author jkratoch;	state Exp;
branches;
next	1.456;

1.456
date	2010.11.24.19.05.46;	author jkratoch;	state Exp;
branches;
next	1.455;

1.455
date	2010.11.07.22.25.16;	author jkratoch;	state Exp;
branches;
next	1.454;

1.454
date	2010.11.02.01.37.31;	author jkratoch;	state Exp;
branches;
next	1.453;

1.453
date	2010.10.17.18.24.47;	author jkratoch;	state Exp;
branches;
next	1.452;

1.452
date	2010.10.17.17.45.16;	author jkratoch;	state Exp;
branches;
next	1.451;

1.451
date	2010.09.24.18.35.27;	author jkratoch;	state Exp;
branches;
next	1.450;

1.450
date	2010.09.06.14.22.07;	author palves;	state Exp;
branches;
next	1.449;

1.449
date	2010.09.06.13.10.27;	author qiyao;	state Exp;
branches;
next	1.448;

1.448
date	2010.09.04.14.27.46;	author jkratoch;	state Exp;
branches;
next	1.447;

1.447
date	2010.08.31.19.31.00;	author msnyder;	state Exp;
branches;
next	1.446;

1.446
date	2010.07.19.07.55.43;	author teawater;	state Exp;
branches;
next	1.445;

1.445
date	2010.07.01.15.36.15;	author palves;	state Exp;
branches
	1.445.2.1;
next	1.444;

1.444
date	2010.06.24.15.17.30;	author jkratoch;	state Exp;
branches;
next	1.443;

1.443
date	2010.06.23.12.46.35;	author uweigand;	state Exp;
branches;
next	1.442;

1.442
date	2010.06.12.00.05.21;	author shebs;	state Exp;
branches;
next	1.441;

1.441
date	2010.05.17.10.40.06;	author palves;	state Exp;
branches;
next	1.440;

1.440
date	2010.05.17.05.30.59;	author brobecke;	state Exp;
branches;
next	1.439;

1.439
date	2010.05.14.21.25.51;	author msnyder;	state Exp;
branches;
next	1.438;

1.438
date	2010.05.06.19.14.08;	author msnyder;	state Exp;
branches;
next	1.437;

1.437
date	2010.05.01.15.56.52;	author palves;	state Exp;
branches;
next	1.436;

1.436
date	2010.04.26.12.01.40;	author muller;	state Exp;
branches;
next	1.435;

1.435
date	2010.03.25.20.48.53;	author tromey;	state Exp;
branches;
next	1.434;

1.434
date	2010.03.14.17.35.21;	author palves;	state Exp;
branches;
next	1.433;

1.433
date	2010.02.24.20.49.50;	author palves;	state Exp;
branches;
next	1.432;

1.432
date	2010.02.24.20.47.22;	author palves;	state Exp;
branches;
next	1.431;

1.431
date	2010.02.24.17.01.57;	author palves;	state Exp;
branches;
next	1.430;

1.430
date	2010.02.24.01.06.27;	author palves;	state Exp;
branches;
next	1.429;

1.429
date	2010.02.08.19.50.04;	author uweigand;	state Exp;
branches
	1.429.2.1;
next	1.428;

1.428
date	2010.01.29.15.40.21;	author drow;	state Exp;
branches;
next	1.427;

1.427
date	2010.01.19.09.39.11;	author brobecke;	state Exp;
branches;
next	1.426;

1.426
date	2010.01.09.04.36.00;	author brobecke;	state Exp;
branches;
next	1.425;

1.425
date	2010.01.08.22.52.03;	author jkratoch;	state Exp;
branches;
next	1.424;

1.424
date	2010.01.08.16.54.14;	author vprus;	state Exp;
branches;
next	1.423;

1.423
date	2010.01.05.20.55.18;	author msnyder;	state Exp;
branches;
next	1.422;

1.422
date	2010.01.01.07.31.36;	author brobecke;	state Exp;
branches;
next	1.421;

1.421
date	2009.11.20.13.08.16;	author palves;	state Exp;
branches;
next	1.420;

1.420
date	2009.11.17.09.41.33;	author jkratoch;	state Exp;
branches;
next	1.419;

1.419
date	2009.11.15.20.10.34;	author palves;	state Exp;
branches;
next	1.418;

1.418
date	2009.11.15.20.08.03;	author palves;	state Exp;
branches;
next	1.417;

1.417
date	2009.11.13.22.00.24;	author drow;	state Exp;
branches;
next	1.416;

1.416
date	2009.10.28.16.33.01;	author palves;	state Exp;
branches;
next	1.415;

1.415
date	2009.10.22.23.10.52;	author msnyder;	state Exp;
branches;
next	1.414;

1.414
date	2009.10.20.19.46.22;	author msnyder;	state Exp;
branches;
next	1.413;

1.413
date	2009.10.19.09.51.41;	author palves;	state Exp;
branches;
next	1.412;

1.412
date	2009.10.09.01.57.12;	author palves;	state Exp;
branches;
next	1.411;

1.411
date	2009.10.02.16.51.04;	author palves;	state Exp;
branches;
next	1.410;

1.410
date	2009.09.29.00.53.04;	author uweigand;	state Exp;
branches;
next	1.409;

1.409
date	2009.09.15.03.30.06;	author sergiodj;	state Exp;
branches
	1.409.2.1;
next	1.408;

1.408
date	2009.09.13.16.28.28;	author brobecke;	state Exp;
branches;
next	1.407;

1.407
date	2009.08.21.18.54.44;	author devans;	state Exp;
branches;
next	1.406;

1.406
date	2009.08.20.18.02.47;	author devans;	state Exp;
branches;
next	1.405;

1.405
date	2009.08.14.00.32.32;	author palves;	state Exp;
branches;
next	1.404;

1.404
date	2009.07.30.23.01.27;	author jules;	state Exp;
branches;
next	1.403;

1.403
date	2009.07.28.17.43.58;	author drow;	state Exp;
branches;
next	1.402;

1.402
date	2009.07.20.15.05.12;	author uweigand;	state Exp;
branches;
next	1.401;

1.401
date	2009.07.18.23.35.31;	author msnyder;	state Exp;
branches;
next	1.400;

1.400
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.399;

1.399
date	2009.07.02.17.12.25;	author uweigand;	state Exp;
branches;
next	1.398;

1.398
date	2009.07.02.12.11.19;	author uweigand;	state Exp;
branches;
next	1.397;

1.397
date	2009.06.29.18.27.23;	author palves;	state Exp;
branches;
next	1.396;

1.396
date	2009.06.28.00.20.22;	author drow;	state Exp;
branches;
next	1.395;

1.395
date	2009.06.28.00.05.14;	author drow;	state Exp;
branches;
next	1.394;

1.394
date	2009.06.27.18.34.58;	author msnyder;	state Exp;
branches;
next	1.393;

1.393
date	2009.06.24.16.45.49;	author uweigand;	state Exp;
branches;
next	1.392;

1.392
date	2009.06.18.23.55.57;	author msnyder;	state Exp;
branches;
next	1.391;

1.391
date	2009.06.18.23.41.27;	author msnyder;	state Exp;
branches;
next	1.390;

1.390
date	2009.06.17.18.43.24;	author uweigand;	state Exp;
branches;
next	1.389;

1.389
date	2009.06.17.18.33.28;	author uweigand;	state Exp;
branches;
next	1.388;

1.388
date	2009.06.17.18.32.39;	author uweigand;	state Exp;
branches;
next	1.387;

1.387
date	2009.06.11.11.57.46;	author palves;	state Exp;
branches;
next	1.386;

1.386
date	2009.06.10.17.26.36;	author palves;	state Exp;
branches;
next	1.385;

1.385
date	2009.06.07.16.46.48;	author palves;	state Exp;
branches;
next	1.384;

1.384
date	2009.06.03.18.50.36;	author palves;	state Exp;
branches;
next	1.383;

1.383
date	2009.06.03.18.16.44;	author uweigand;	state Exp;
branches;
next	1.382;

1.382
date	2009.05.30.00.19.12;	author devans;	state Exp;
branches;
next	1.381;

1.381
date	2009.05.28.17.19.56;	author palves;	state Exp;
branches;
next	1.380;

1.380
date	2009.05.27.19.44.50;	author palves;	state Exp;
branches;
next	1.379;

1.379
date	2009.05.24.21.06.53;	author devans;	state Exp;
branches;
next	1.378;

1.378
date	2009.05.24.20.55.33;	author devans;	state Exp;
branches;
next	1.377;

1.377
date	2009.05.24.18.00.08;	author palves;	state Exp;
branches;
next	1.376;

1.376
date	2009.05.21.15.48.41;	author palves;	state Exp;
branches;
next	1.375;

1.375
date	2009.05.17.19.20.32;	author palves;	state Exp;
branches;
next	1.374;

1.374
date	2009.05.17.16.46.20;	author palves;	state Exp;
branches;
next	1.373;

1.373
date	2009.05.17.16.31.21;	author palves;	state Exp;
branches;
next	1.372;

1.372
date	2009.05.11.11.13.08;	author muller;	state Exp;
branches;
next	1.371;

1.371
date	2009.05.05.13.24.48;	author uweigand;	state Exp;
branches;
next	1.370;

1.370
date	2009.04.30.03.09.59;	author teawater;	state Exp;
branches;
next	1.369;

1.369
date	2009.04.20.21.11.06;	author daney;	state Exp;
branches;
next	1.368;

1.368
date	2009.04.14.00.59.47;	author daney;	state Exp;
branches;
next	1.367;

1.367
date	2009.03.25.21.53.10;	author palves;	state Exp;
branches;
next	1.366;

1.366
date	2009.03.25.21.42.34;	author palves;	state Exp;
branches;
next	1.365;

1.365
date	2009.03.22.18.06.07;	author palves;	state Exp;
branches;
next	1.364;

1.364
date	2009.03.22.17.59.59;	author palves;	state Exp;
branches;
next	1.363;

1.363
date	2009.03.22.17.57.11;	author palves;	state Exp;
branches;
next	1.362;

1.362
date	2009.03.17.04.49.47;	author palves;	state Exp;
branches;
next	1.361;

1.361
date	2009.03.01.23.18.36;	author devans;	state Exp;
branches;
next	1.360;

1.360
date	2009.02.25.02.14.22;	author teawater;	state Exp;
branches;
next	1.359;

1.359
date	2009.02.21.16.14.48;	author palves;	state Exp;
branches;
next	1.358;

1.358
date	2009.02.14.15.24.43;	author vprus;	state Exp;
branches;
next	1.357;

1.357
date	2009.02.06.22.59.00;	author palves;	state Exp;
branches;
next	1.356;

1.356
date	2009.02.01.23.31.03;	author devans;	state Exp;
branches;
next	1.355;

1.355
date	2009.01.24.19.17.24;	author palves;	state Exp;
branches;
next	1.354;

1.354
date	2009.01.23.15.47.03;	author palves;	state Exp;
branches;
next	1.353;

1.353
date	2009.01.19.19.05.00;	author devans;	state Exp;
branches;
next	1.352;

1.352
date	2009.01.18.17.42.16;	author palves;	state Exp;
branches;
next	1.351;

1.351
date	2009.01.15.22.07.19;	author devans;	state Exp;
branches;
next	1.350;

1.350
date	2009.01.07.21.42.49;	author palves;	state Exp;
branches;
next	1.349;

1.349
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.348;

1.348
date	2008.12.31.01.34.09;	author palves;	state Exp;
branches;
next	1.347;

1.347
date	2008.12.12.14.20.48;	author palves;	state Exp;
branches
	1.347.2.1;
next	1.346;

1.346
date	2008.12.11.19.19.12;	author palves;	state Exp;
branches;
next	1.345;

1.345
date	2008.12.02.19.20.23;	author devans;	state Exp;
branches;
next	1.344;

1.344
date	2008.12.02.09.52.31;	author devans;	state Exp;
branches;
next	1.343;

1.343
date	2008.12.02.04.42.45;	author devans;	state Exp;
branches;
next	1.342;

1.342
date	2008.11.22.04.41.45;	author brobecke;	state Exp;
branches;
next	1.341;

1.341
date	2008.11.20.17.06.05;	author palves;	state Exp;
branches;
next	1.340;

1.340
date	2008.11.20.13.23.26;	author palves;	state Exp;
branches;
next	1.339;

1.339
date	2008.11.20.00.35.23;	author devans;	state Exp;
branches
	1.339.2.1;
next	1.338;

1.338
date	2008.11.17.18.50.22;	author uweigand;	state Exp;
branches;
next	1.337;

1.337
date	2008.11.16.18.01.46;	author brobecke;	state Exp;
branches;
next	1.336;

1.336
date	2008.11.05.20.23.07;	author palves;	state Exp;
branches;
next	1.335;

1.335
date	2008.10.31.19.41.37;	author palves;	state Exp;
branches;
next	1.334;

1.334
date	2008.10.27.04.53.05;	author msnyder;	state Exp;
branches;
next	1.333;

1.333
date	2008.10.25.16.03.14;	author brobecke;	state Exp;
branches;
next	1.332;

1.332
date	2008.10.24.02.31.41;	author teawater;	state Exp;
branches;
next	1.331;

1.331
date	2008.10.23.23.11.21;	author palves;	state Exp;
branches;
next	1.330;

1.330
date	2008.10.20.02.56.39;	author teawater;	state Exp;
branches;
next	1.329;

1.329
date	2008.10.18.03.24.34;	author palves;	state Exp;
branches;
next	1.328;

1.328
date	2008.10.17.19.43.47;	author msnyder;	state Exp;
branches;
next	1.327;

1.327
date	2008.10.15.19.15.33;	author palves;	state Exp;
branches;
next	1.326;

1.326
date	2008.10.14.23.39.29;	author palves;	state Exp;
branches;
next	1.325;

1.325
date	2008.10.05.19.52.11;	author msnyder;	state Exp;
branches;
next	1.324;

1.324
date	2008.10.03.16.36.10;	author ppluzhnikov;	state Exp;
branches;
next	1.323;

1.323
date	2008.10.02.15.48.06;	author drow;	state Exp;
branches;
next	1.322;

1.322
date	2008.09.22.15.26.53;	author palves;	state Exp;
branches
	1.322.2.1;
next	1.321;

1.321
date	2008.09.22.15.25.54;	author palves;	state Exp;
branches;
next	1.320;

1.320
date	2008.09.22.15.20.08;	author palves;	state Exp;
branches;
next	1.319;

1.319
date	2008.09.17.21.48.49;	author jkratoch;	state Exp;
branches;
next	1.318;

1.318
date	2008.09.11.14.21.49;	author uweigand;	state Exp;
branches;
next	1.317;

1.317
date	2008.09.09.18.58.20;	author palves;	state Exp;
branches;
next	1.316;

1.316
date	2008.09.08.22.10.20;	author palves;	state Exp;
branches;
next	1.315;

1.315
date	2008.09.08.22.03.00;	author palves;	state Exp;
branches;
next	1.314;

1.314
date	2008.09.08.21.55.16;	author palves;	state Exp;
branches;
next	1.313;

1.313
date	2008.09.08.21.52.25;	author palves;	state Exp;
branches;
next	1.312;

1.312
date	2008.09.08.21.51.18;	author palves;	state Exp;
branches;
next	1.311;

1.311
date	2008.09.08.21.48.52;	author palves;	state Exp;
branches;
next	1.310;

1.310
date	2008.09.08.21.46.21;	author palves;	state Exp;
branches;
next	1.309;

1.309
date	2008.09.08.21.43.00;	author palves;	state Exp;
branches;
next	1.308;

1.308
date	2008.09.08.21.40.39;	author palves;	state Exp;
branches;
next	1.307;

1.307
date	2008.08.26.17.40.25;	author uweigand;	state Exp;
branches;
next	1.306;

1.306
date	2008.08.22.14.47.13;	author uweigand;	state Exp;
branches;
next	1.305;

1.305
date	2008.08.22.14.06.29;	author palves;	state Exp;
branches;
next	1.304;

1.304
date	2008.08.19.13.57.28;	author vprus;	state Exp;
branches;
next	1.303;

1.303
date	2008.08.18.22.35.17;	author palves;	state Exp;
branches;
next	1.302;

1.302
date	2008.08.16.01.04.16;	author palves;	state Exp;
branches;
next	1.301;

1.301
date	2008.07.22.02.10.14;	author shebs;	state Exp;
branches;
next	1.300;

1.300
date	2008.07.15.23.29.24;	author drow;	state Exp;
branches
	1.300.2.1;
next	1.299;

1.299
date	2008.07.15.18.58.32;	author drow;	state Exp;
branches;
next	1.298;

1.298
date	2008.07.15.17.25.21;	author luisgpm;	state Exp;
branches;
next	1.297;

1.297
date	2008.07.12.18.39.10;	author palves;	state Exp;
branches;
next	1.296;

1.296
date	2008.07.12.13.42.54;	author vprus;	state Exp;
branches;
next	1.295;

1.295
date	2008.07.12.12.41.56;	author vprus;	state Exp;
branches;
next	1.294;

1.294
date	2008.07.11.17.46.40;	author palves;	state Exp;
branches;
next	1.293;

1.293
date	2008.07.11.11.07.38;	author palves;	state Exp;
branches;
next	1.292;

1.292
date	2008.07.09.22.42.42;	author palves;	state Exp;
branches;
next	1.291;

1.291
date	2008.07.09.22.36.51;	author palves;	state Exp;
branches;
next	1.290;

1.290
date	2008.07.09.22.33.16;	author palves;	state Exp;
branches;
next	1.289;

1.289
date	2008.07.09.22.30.46;	author palves;	state Exp;
branches;
next	1.288;

1.288
date	2008.07.09.22.27.13;	author palves;	state Exp;
branches;
next	1.287;

1.287
date	2008.07.09.22.23.05;	author palves;	state Exp;
branches;
next	1.286;

1.286
date	2008.07.09.22.16.14;	author palves;	state Exp;
branches;
next	1.285;

1.285
date	2008.07.08.10.31.16;	author palves;	state Exp;
branches;
next	1.284;

1.284
date	2008.06.28.09.42.15;	author vprus;	state Exp;
branches;
next	1.283;

1.283
date	2008.06.27.11.54.21;	author palves;	state Exp;
branches;
next	1.282;

1.282
date	2008.06.24.19.30.18;	author msnyder;	state Exp;
branches;
next	1.281;

1.281
date	2008.06.13.20.19.19;	author vprus;	state Exp;
branches;
next	1.280;

1.280
date	2008.06.10.10.23.53;	author vprus;	state Exp;
branches;
next	1.279;

1.279
date	2008.06.10.09.32.05;	author vprus;	state Exp;
branches;
next	1.278;

1.278
date	2008.06.06.00.33.52;	author nickrob;	state Exp;
branches
	1.278.2.1;
next	1.277;

1.277
date	2008.05.04.19.38.59;	author palves;	state Exp;
branches;
next	1.276;

1.276
date	2008.05.04.14.12.34;	author uweigand;	state Exp;
branches;
next	1.275;

1.275
date	2008.05.03.23.18.23;	author uweigand;	state Exp;
branches;
next	1.274;

1.274
date	2008.05.02.16.49.54;	author palves;	state Exp;
branches;
next	1.273;

1.273
date	2008.05.02.13.58.38;	author ams;	state Exp;
branches;
next	1.272;

1.272
date	2008.05.01.18.50.14;	author drow;	state Exp;
branches;
next	1.271;

1.271
date	2008.04.25.14.50.10;	author palves;	state Exp;
branches;
next	1.270;

1.270
date	2008.04.24.11.13.44;	author vprus;	state Exp;
branches;
next	1.269;

1.269
date	2008.04.24.10.21.44;	author vprus;	state Exp;
branches;
next	1.268;

1.268
date	2008.04.15.14.32.12;	author aristovski;	state Exp;
branches;
next	1.267;

1.267
date	2008.03.15.14.55.21;	author vprus;	state Exp;
branches;
next	1.266;

1.266
date	2008.01.29.22.47.19;	author drow;	state Exp;
branches;
next	1.265;

1.265
date	2008.01.29.21.11.24;	author brobecke;	state Exp;
branches;
next	1.264;

1.264
date	2008.01.23.11.26.28;	author vprus;	state Exp;
branches;
next	1.263;

1.263
date	2008.01.21.16.34.00;	author vprus;	state Exp;
branches;
next	1.262;

1.262
date	2008.01.01.22.53.11;	author drow;	state Exp;
branches;
next	1.261;

1.261
date	2007.12.23.05.34.38;	author brobecke;	state Exp;
branches;
next	1.260;

1.260
date	2007.12.19.05.16.35;	author brobecke;	state Exp;
branches;
next	1.259;

1.259
date	2007.12.16.19.14.23;	author vprus;	state Exp;
branches;
next	1.258;

1.258
date	2007.12.07.00.44.27;	author drow;	state Exp;
branches;
next	1.257;

1.257
date	2007.12.06.13.47.56;	author vprus;	state Exp;
branches;
next	1.256;

1.256
date	2007.12.06.12.57.51;	author vprus;	state Exp;
branches;
next	1.255;

1.255
date	2007.11.30.10.03.16;	author vprus;	state Exp;
branches;
next	1.254;

1.254
date	2007.11.30.10.00.26;	author vprus;	state Exp;
branches;
next	1.253;

1.253
date	2007.11.29.07.48.21;	author vprus;	state Exp;
branches;
next	1.252;

1.252
date	2007.11.28.12.49.55;	author vprus;	state Exp;
branches;
next	1.251;

1.251
date	2007.11.20.08.18.47;	author vprus;	state Exp;
branches;
next	1.250;

1.250
date	2007.11.02.14.47.28;	author uweigand;	state Exp;
branches;
next	1.249;

1.249
date	2007.10.01.00.17.58;	author drow;	state Exp;
branches;
next	1.248;

1.248
date	2007.09.22.19.33.31;	author vprus;	state Exp;
branches;
next	1.247;

1.247
date	2007.09.17.19.44.20;	author brobecke;	state Exp;
branches;
next	1.246;

1.246
date	2007.09.10.18.49.26;	author uweigand;	state Exp;
branches;
next	1.245;

1.245
date	2007.08.23.18.08.35;	author brobecke;	state Exp;
branches;
next	1.244;

1.244
date	2007.07.02.21.29.27;	author drow;	state Exp;
branches;
next	1.243;

1.243
date	2007.06.22.12.47.48;	author uweigand;	state Exp;
branches;
next	1.242;

1.242
date	2007.06.22.12.38.04;	author uweigand;	state Exp;
branches;
next	1.241;

1.241
date	2007.06.18.18.23.08;	author uweigand;	state Exp;
branches;
next	1.240;

1.240
date	2007.06.16.17.16.25;	author uweigand;	state Exp;
branches;
next	1.239;

1.239
date	2007.06.15.22.41.13;	author uweigand;	state Exp;
branches;
next	1.238;

1.238
date	2007.06.15.22.39.52;	author uweigand;	state Exp;
branches;
next	1.237;

1.237
date	2007.06.15.22.37.34;	author uweigand;	state Exp;
branches;
next	1.236;

1.236
date	2007.06.09.14.20.24;	author uweigand;	state Exp;
branches;
next	1.235;

1.235
date	2007.06.09.14.15.52;	author uweigand;	state Exp;
branches;
next	1.234;

1.234
date	2007.06.09.13.55.51;	author uweigand;	state Exp;
branches;
next	1.233;

1.233
date	2007.06.09.13.49.20;	author uweigand;	state Exp;
branches;
next	1.232;

1.232
date	2007.06.06.15.38.56;	author uweigand;	state Exp;
branches;
next	1.231;

1.231
date	2007.06.06.15.15.34;	author uweigand;	state Exp;
branches;
next	1.230;

1.230
date	2007.05.23.11.39.17;	author drow;	state Exp;
branches;
next	1.229;

1.229
date	2007.05.07.18.20.18;	author uweigand;	state Exp;
branches;
next	1.228;

1.228
date	2007.04.14.18.10.54;	author uweigand;	state Exp;
branches;
next	1.227;

1.227
date	2007.04.13.13.29.42;	author drow;	state Exp;
branches;
next	1.226;

1.226
date	2007.04.12.14.52.19;	author uweigand;	state Exp;
branches;
next	1.225;

1.225
date	2007.03.29.07.35.39;	author denis;	state Exp;
branches
	1.225.2.1;
next	1.224;

1.224
date	2007.03.28.18.56.06;	author uweigand;	state Exp;
branches;
next	1.223;

1.223
date	2007.03.09.16.20.42;	author uweigand;	state Exp;
branches;
next	1.222;

1.222
date	2007.02.28.17.35.00;	author drow;	state Exp;
branches;
next	1.221;

1.221
date	2007.02.27.19.46.04;	author drow;	state Exp;
branches;
next	1.220;

1.220
date	2007.02.22.15.14.12;	author uweigand;	state Exp;
branches;
next	1.219;

1.219
date	2007.01.10.20.10.23;	author drow;	state Exp;
branches;
next	1.218;

1.218
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.217;

1.217
date	2006.12.30.15.56.00;	author drow;	state Exp;
branches;
next	1.216;

1.216
date	2006.10.18.16.56.13;	author drow;	state Exp;
branches;
next	1.215;

1.215
date	2006.09.10.16.21.03;	author drow;	state Exp;
branches;
next	1.214;

1.214
date	2006.08.19.03.19.00;	author drow;	state Exp;
branches;
next	1.213;

1.213
date	2006.07.22.14.48.03;	author kettenis;	state Exp;
branches;
next	1.212;

1.212
date	2006.07.12.20.43.52;	author drow;	state Exp;
branches;
next	1.211;

1.211
date	2006.06.16.01.12.58;	author drow;	state Exp;
branches;
next	1.210;

1.210
date	2006.03.30.16.37.13;	author drow;	state Exp;
branches
	1.210.4.1
	1.210.6.1
	1.210.8.1;
next	1.209;

1.209
date	2006.01.04.19.34.58;	author msnyder;	state Exp;
branches
	1.209.2.1
	1.209.4.1
	1.209.6.1;
next	1.208;

1.208
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.207;

1.207
date	2005.11.07.15.27.07;	author ams;	state Exp;
branches
	1.207.4.1;
next	1.206;

1.206
date	2005.11.04.11.49.10;	author ams;	state Exp;
branches;
next	1.205;

1.205
date	2005.09.29.20.41.27;	author schwab;	state Exp;
branches
	1.205.4.1;
next	1.204;

1.204
date	2005.09.28.16.17.06;	author drow;	state Exp;
branches;
next	1.203;

1.203
date	2005.08.01.03.32.32;	author drow;	state Exp;
branches;
next	1.202;

1.202
date	2005.05.29.03.13.17;	author bobbybrasko;	state Exp;
branches
	1.202.2.1;
next	1.201;

1.201
date	2005.05.12.20.21.17;	author kettenis;	state Exp;
branches;
next	1.200;

1.200
date	2005.05.02.23.56.36;	author bje;	state Exp;
branches;
next	1.199;

1.199
date	2005.02.24.13.51.32;	author cagney;	state Exp;
branches;
next	1.198;

1.198
date	2005.02.21.07.15.47;	author cagney;	state Exp;
branches;
next	1.197;

1.197
date	2005.02.21.04.31.58;	author cagney;	state Exp;
branches;
next	1.196;

1.196
date	2005.02.18.18.58.56;	author cagney;	state Exp;
branches;
next	1.195;

1.195
date	2005.02.18.15.25.25;	author cagney;	state Exp;
branches;
next	1.194;

1.194
date	2005.02.15.15.49.11;	author cagney;	state Exp;
branches;
next	1.193;

1.193
date	2005.02.14.18.10.08;	author cagney;	state Exp;
branches;
next	1.192;

1.192
date	2005.02.12.00.39.19;	author cagney;	state Exp;
branches;
next	1.191;

1.191
date	2005.02.11.18.13.50;	author cagney;	state Exp;
branches;
next	1.190;

1.190
date	2005.02.11.04.05.55;	author cagney;	state Exp;
branches;
next	1.189;

1.189
date	2005.01.24.22.00.56;	author cagney;	state Exp;
branches;
next	1.188;

1.188
date	2005.01.19.16.09.46;	author cagney;	state Exp;
branches;
next	1.187;

1.187
date	2005.01.14.00.51.43;	author msnyder;	state Exp;
branches;
next	1.186;

1.186
date	2005.01.12.18.31.31;	author cagney;	state Exp;
branches;
next	1.185;

1.185
date	2004.12.24.22.54.02;	author kettenis;	state Exp;
branches;
next	1.184;

1.184
date	2004.12.03.23.59.53;	author tausq;	state Exp;
branches;
next	1.183;

1.183
date	2004.11.23.21.05.23;	author tausq;	state Exp;
branches;
next	1.182;

1.182
date	2004.11.08.17.25.23;	author tausq;	state Exp;
branches;
next	1.181;

1.181
date	2004.10.31.17.38.15;	author cagney;	state Exp;
branches;
next	1.180;

1.180
date	2004.10.31.16.14.00;	author cagney;	state Exp;
branches;
next	1.179;

1.179
date	2004.10.29.20.23.08;	author cagney;	state Exp;
branches;
next	1.178;

1.178
date	2004.09.27.17.58.08;	author cagney;	state Exp;
branches;
next	1.177;

1.177
date	2004.09.13.18.26.28;	author cagney;	state Exp;
branches;
next	1.176;

1.176
date	2004.08.30.16.59.43;	author cagney;	state Exp;
branches;
next	1.175;

1.175
date	2004.08.25.15.18.05;	author cagney;	state Exp;
branches;
next	1.174;

1.174
date	2004.08.25.14.47.07;	author cagney;	state Exp;
branches;
next	1.173;

1.173
date	2004.08.03.00.57.26;	author cagney;	state Exp;
branches;
next	1.172;

1.172
date	2004.07.26.14.53.01;	author cagney;	state Exp;
branches;
next	1.171;

1.171
date	2004.07.23.19.37.21;	author cagney;	state Exp;
branches;
next	1.170;

1.170
date	2004.07.21.14.23.36;	author cagney;	state Exp;
branches;
next	1.169;

1.169
date	2004.07.16.19.41.48;	author cagney;	state Exp;
branches;
next	1.168;

1.168
date	2004.06.22.19.46.40;	author jjohnstn;	state Exp;
branches
	1.168.2.1;
next	1.167;

1.167
date	2004.06.18.21.36.15;	author cagney;	state Exp;
branches;
next	1.166;

1.166
date	2004.06.11.23.39.51;	author tausq;	state Exp;
branches;
next	1.165;

1.165
date	2004.06.07.02.19.07;	author tausq;	state Exp;
branches;
next	1.164;

1.164
date	2004.06.04.21.28.15;	author jjohnstn;	state Exp;
branches;
next	1.163;

1.163
date	2004.05.14.18.45.42;	author cagney;	state Exp;
branches;
next	1.162;

1.162
date	2004.05.14.15.49.00;	author cagney;	state Exp;
branches;
next	1.161;

1.161
date	2004.05.13.19.34.00;	author cagney;	state Exp;
branches;
next	1.160;

1.160
date	2004.05.13.18.42.29;	author cagney;	state Exp;
branches;
next	1.159;

1.159
date	2004.05.13.16.39.11;	author uweigand;	state Exp;
branches;
next	1.158;

1.158
date	2004.05.12.22.19.02;	author cagney;	state Exp;
branches;
next	1.157;

1.157
date	2004.05.12.18.08.38;	author cagney;	state Exp;
branches;
next	1.156;

1.156
date	2004.05.11.23.30.31;	author cagney;	state Exp;
branches;
next	1.155;

1.155
date	2004.05.11.16.57.04;	author cagney;	state Exp;
branches;
next	1.154;

1.154
date	2004.05.10.23.27.49;	author cagney;	state Exp;
branches;
next	1.153;

1.153
date	2004.05.10.18.36.06;	author cagney;	state Exp;
branches;
next	1.152;

1.152
date	2004.05.08.22.26.09;	author cagney;	state Exp;
branches;
next	1.151;

1.151
date	2004.05.01.14.15.19;	author cagney;	state Exp;
branches;
next	1.150;

1.150
date	2004.04.29.22.36.24;	author cagney;	state Exp;
branches;
next	1.149;

1.149
date	2004.04.28.16.36.25;	author cagney;	state Exp;
branches;
next	1.148;

1.148
date	2004.04.26.09.02.41;	author orjanf;	state Exp;
branches;
next	1.147;

1.147
date	2004.04.21.23.52.20;	author cagney;	state Exp;
branches;
next	1.146;

1.146
date	2004.04.15.14.29.20;	author cagney;	state Exp;
branches;
next	1.145;

1.145
date	2004.04.02.22.38.43;	author cagney;	state Exp;
branches;
next	1.144;

1.144
date	2004.04.02.20.35.09;	author cagney;	state Exp;
branches;
next	1.143;

1.143
date	2004.03.31.19.40.28;	author cagney;	state Exp;
branches;
next	1.142;

1.142
date	2004.03.23.14.47.56;	author cagney;	state Exp;
branches
	1.142.2.1;
next	1.141;

1.141
date	2004.03.21.22.53.49;	author cagney;	state Exp;
branches;
next	1.140;

1.140
date	2004.03.15.17.12.50;	author cagney;	state Exp;
branches;
next	1.139;

1.139
date	2004.03.09.16.40.08;	author drow;	state Exp;
branches
	1.139.2.1;
next	1.138;

1.138
date	2004.03.06.00.10.06;	author cagney;	state Exp;
branches;
next	1.137;

1.137
date	2004.02.16.20.49.51;	author drow;	state Exp;
branches
	1.137.2.1;
next	1.136;

1.136
date	2004.02.15.15.22.06;	author cagney;	state Exp;
branches;
next	1.135;

1.135
date	2004.02.05.19.56.33;	author kettenis;	state Exp;
branches;
next	1.134;

1.134
date	2004.02.01.18.05.09;	author drow;	state Exp;
branches;
next	1.133;

1.133
date	2004.01.31.19.59.06;	author drow;	state Exp;
branches;
next	1.132;

1.132
date	2004.01.31.19.18.13;	author drow;	state Exp;
branches;
next	1.131;

1.131
date	2004.01.21.16.32.07;	author pbrook;	state Exp;
branches;
next	1.130;

1.130
date	2004.01.19.17.28.52;	author kevinb;	state Exp;
branches;
next	1.129;

1.129
date	2004.01.19.01.20.11;	author cagney;	state Exp;
branches;
next	1.128;

1.128
date	2004.01.17.21.56.12;	author drow;	state Exp;
branches;
next	1.127;

1.127
date	2004.01.13.21.31.43;	author drow;	state Exp;
branches;
next	1.126;

1.126
date	2004.01.03.15.22.21;	author brobecke;	state Exp;
branches;
next	1.125;

1.125
date	2004.01.03.15.17.09;	author brobecke;	state Exp;
branches;
next	1.124;

1.124
date	2004.01.03.13.02.00;	author brobecke;	state Exp;
branches;
next	1.123;

1.123
date	2004.01.03.11.51.22;	author brobecke;	state Exp;
branches;
next	1.122;

1.122
date	2003.11.25.16.01.36;	author cagney;	state Exp;
branches;
next	1.121;

1.121
date	2003.11.23.23.13.00;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2003.11.22.16.01.03;	author cagney;	state Exp;
branches;
next	1.119;

1.119
date	2003.11.14.21.22.42;	author kettenis;	state Exp;
branches;
next	1.118;

1.118
date	2003.11.09.12.07.16;	author kettenis;	state Exp;
branches;
next	1.117;

1.117
date	2003.10.24.17.37.03;	author cagney;	state Exp;
branches;
next	1.116;

1.116
date	2003.10.16.18.24.13;	author cagney;	state Exp;
branches;
next	1.115;

1.115
date	2003.10.02.20.28.29;	author cagney;	state Exp;
branches;
next	1.114;

1.114
date	2003.09.21.01.26.44;	author cagney;	state Exp;
branches;
next	1.113;

1.113
date	2003.09.14.16.32.13;	author cagney;	state Exp;
branches
	1.113.4.1;
next	1.112;

1.112
date	2003.09.08.20.13.48;	author drow;	state Exp;
branches;
next	1.111;

1.111
date	2003.09.07.15.15.01;	author drow;	state Exp;
branches;
next	1.110;

1.110
date	2003.06.19.15.04.57;	author drow;	state Exp;
branches;
next	1.109;

1.109
date	2003.05.07.18.35.57;	author jjohnstn;	state Exp;
branches
	1.109.8.1;
next	1.108;

1.108
date	2003.05.05.00.27.07;	author cagney;	state Exp;
branches;
next	1.107;

1.107
date	2003.04.12.17.48.54;	author cagney;	state Exp;
branches
	1.107.2.1;
next	1.106;

1.106
date	2003.04.11.18.15.38;	author cagney;	state Exp;
branches;
next	1.105;

1.105
date	2003.04.08.21.56.10;	author cagney;	state Exp;
branches;
next	1.104;

1.104
date	2003.04.08.19.21.14;	author ezannoni;	state Exp;
branches;
next	1.103;

1.103
date	2003.04.08.18.52.03;	author ezannoni;	state Exp;
branches;
next	1.102;

1.102
date	2003.04.01.14.38.49;	author cagney;	state Exp;
branches
	1.102.2.1;
next	1.101;

1.101
date	2003.03.29.23.29.47;	author cagney;	state Exp;
branches;
next	1.100;

1.100
date	2003.03.26.03.39.43;	author fedor;	state Exp;
branches
	1.100.2.1;
next	1.99;

1.99
date	2003.03.20.22.52.53;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2003.03.18.19.06.54;	author brobecke;	state Exp;
branches;
next	1.97;

1.97
date	2003.02.24.21.56.49;	author kewarken;	state Exp;
branches;
next	1.96;

1.96
date	2003.01.31.15.22.57;	author fedor;	state Exp;
branches;
next	1.95;

1.95
date	2003.01.19.17.39.16;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2003.01.14.00.07.43;	author ezannoni;	state Exp;
branches;
next	1.93;

1.93
date	2003.01.09.18.03.36;	author cagney;	state Exp;
branches
	1.93.2.1;
next	1.92;

1.92
date	2002.12.18.18.03.42;	author cagney;	state Exp;
branches;
next	1.91;

1.91
date	2002.12.15.20.38.52;	author drow;	state Exp;
branches;
next	1.90;

1.90
date	2002.12.15.20.15.56;	author drow;	state Exp;
branches;
next	1.89;

1.89
date	2002.12.15.20.08.02;	author drow;	state Exp;
branches;
next	1.88;

1.88
date	2002.12.13.21.57.40;	author cagney;	state Exp;
branches;
next	1.87;

1.87
date	2002.12.12.22.41.21;	author drow;	state Exp;
branches;
next	1.86;

1.86
date	2002.12.11.22.34.47;	author cagney;	state Exp;
branches;
next	1.85;

1.85
date	2002.12.11.02.04.44;	author drow;	state Exp;
branches;
next	1.84;

1.84
date	2002.12.11.02.02.03;	author drow;	state Exp;
branches;
next	1.83;

1.83
date	2002.12.11.01.25.19;	author drow;	state Exp;
branches;
next	1.82;

1.82
date	2002.12.06.07.35.55;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2002.12.04.00.05.53;	author cagney;	state Exp;
branches;
next	1.80;

1.80
date	2002.12.01.19.07.15;	author cagney;	state Exp;
branches;
next	1.79;

1.79
date	2002.11.29.19.15.14;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2002.11.24.19.48.12;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2002.11.16.19.23.52;	author drow;	state Exp;
branches;
next	1.76;

1.76
date	2002.11.16.19.22.58;	author drow;	state Exp;
branches;
next	1.75;

1.75
date	2002.11.16.19.21.43;	author drow;	state Exp;
branches;
next	1.74;

1.74
date	2002.10.24.21.02.53;	author ezannoni;	state Exp;
branches;
next	1.73;

1.73
date	2002.10.10.07.41.37;	author markom;	state Exp;
branches;
next	1.72;

1.72
date	2002.10.02.23.28.54;	author cagney;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2002.09.18.22.44.31;	author cagney;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2002.08.23.21.55.36;	author brobecke;	state Exp;
branches
	1.70.6.1;
next	1.69;

1.69
date	2002.08.23.20.49.38;	author graces;	state Exp;
branches;
next	1.68;

1.68
date	2002.08.20.23.01.29;	author msnyder;	state Exp;
branches;
next	1.67;

1.67
date	2002.08.17.06.12.52;	author brobecke;	state Exp;
branches;
next	1.66;

1.66
date	2002.08.17.00.16.54;	author brobecke;	state Exp;
branches;
next	1.65;

1.65
date	2002.08.16.17.56.17;	author brobecke;	state Exp;
branches;
next	1.64;

1.64
date	2002.07.24.14.38.55;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2002.07.18.17.53.49;	author brobecke;	state Exp;
branches;
next	1.62;

1.62
date	2002.07.18.17.51.27;	author brobecke;	state Exp;
branches;
next	1.61;

1.61
date	2002.06.25.18.38.57;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.22.22.04.33;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2002.06.10.23.25.50;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2002.05.05.01.15.13;	author cagney;	state Exp;
branches
	1.58.4.1
	1.58.6.1;
next	1.57;

1.57
date	2002.04.24.16.28.15;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2002.03.18.02.26.31;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2002.03.17.19.53.38;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2002.02.24.22.31.19;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2002.02.18.13.35.30;	author rearnsha;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.05.04.37.21;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2002.02.02.03.42.58;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2002.01.17.22.15.17;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2001.11.01.16.17.08;	author fnf;	state Exp;
branches;
next	1.48;

1.48
date	2001.10.31.23.21.33;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2001.10.21.17.19.37;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2001.08.15.15.29.56;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2001.07.16.14.46.34;	author ezannoni;	state Exp;
branches;
next	1.44;

1.44
date	2001.07.14.18.59.07;	author ciceron;	state Exp;
branches;
next	1.43;

1.43
date	2001.07.11.16.46.57;	author kseitz;	state Exp;
branches;
next	1.42;

1.42
date	2001.07.06.03.53.11;	author cagney;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2001.06.28.21.48.41;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.28.21.34.03;	author msnyder;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.26.00.26.42;	author msnyder;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.18.17.57.38;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.15.22.44.20;	author msnyder;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.13.22.56.16;	author msnyder;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.02.00.36.20;	author msnyder;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.01.23.23.19;	author msnyder;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.15.00.03.36;	author kevinb;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.06.22.22.03;	author kevinb;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.04.04.15.25;	author kevinb;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.06.17.53.39;	author dsmith;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.22.23.58.37;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.20.18.16.10;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.06.08.21.08;	author kevinb;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.27.00.43.25;	author fnasser;	state Exp;
branches;
next	1.23;

1.23
date	2000.12.15.01.01.47;	author kevinb;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.10.19.27.45;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.06.22.44.34;	author fnasser;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.30.15.32.51;	author taylor;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.27.15.02.42;	author davea;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.02.00.08.05;	author davea;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.08.01.52.44;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.08.00.52.56;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.22.09.02.23;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.16.03.03.13;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.04.17.32.49;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.03.20.16.05;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.02.08.59.35;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.02.08.57.21;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.20.11.00.34;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.13.10.22.22;	author eliz;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.05.02.26.37;	author nsd;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.03.28.22.30.19;	author msnyder;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.29.07.17.15;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.23.00.25.42;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.45;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.576.2.1
date	2013.08.30.15.58.55;	author tromey;	state Exp;
branches;
next	;

1.549.2.1
date	2012.09.17.07.14.55;	author jkratoch;	state Exp;
branches;
next	;

1.515.2.1
date	2012.01.06.04.43.17;	author brobecke;	state Exp;
branches;
next	;

1.472.2.1
date	2011.04.20.17.04.32;	author palves;	state Exp;
branches;
next	1.472.2.2;

1.472.2.2
date	2011.06.03.15.32.13;	author tromey;	state Exp;
branches;
next	;

1.445.2.1
date	2010.08.31.19.31.23;	author msnyder;	state Exp;
branches;
next	1.445.2.2;

1.445.2.2
date	2010.09.08.12.25.18;	author qiyao;	state Exp;
branches;
next	1.445.2.3;

1.445.2.3
date	2011.02.11.15.04.48;	author palves;	state Exp;
branches;
next	;

1.429.2.1
date	2010.02.24.21.43.03;	author palves;	state Exp;
branches;
next	;

1.409.2.1
date	2009.09.29.12.09.19;	author uweigand;	state Exp;
branches;
next	;

1.347.2.1
date	2008.12.26.21.09.13;	author msnyder;	state Exp;
branches;
next	1.347.2.2;

1.347.2.2
date	2008.12.27.20.28.12;	author msnyder;	state Exp;
branches;
next	1.347.2.3;

1.347.2.3
date	2008.12.30.05.42.04;	author teawater;	state Exp;
branches;
next	;

1.339.2.1
date	2008.11.21.02.31.57;	author shebs;	state Exp;
branches;
next	1.339.2.2;

1.339.2.2
date	2008.11.25.20.45.08;	author palves;	state Exp;
branches;
next	1.339.2.3;

1.339.2.3
date	2008.12.16.22.44.22;	author palves;	state Exp;
branches;
next	1.339.2.4;

1.339.2.4
date	2008.12.16.22.54.36;	author palves;	state Exp;
branches;
next	;

1.322.2.1
date	2008.09.30.23.46.23;	author msnyder;	state Exp;
branches;
next	1.322.2.2;

1.322.2.2
date	2008.09.30.23.50.51;	author msnyder;	state Exp;
branches;
next	1.322.2.3;

1.322.2.3
date	2008.10.05.19.54.20;	author msnyder;	state Exp;
branches;
next	1.322.2.4;

1.322.2.4
date	2008.10.05.22.20.49;	author msnyder;	state Exp;
branches;
next	1.322.2.5;

1.322.2.5
date	2008.10.06.23.06.30;	author msnyder;	state Exp;
branches;
next	1.322.2.6;

1.322.2.6
date	2008.10.06.23.14.15;	author msnyder;	state Exp;
branches;
next	1.322.2.7;

1.322.2.7
date	2008.10.06.23.24.00;	author msnyder;	state Exp;
branches;
next	1.322.2.8;

1.322.2.8
date	2008.10.06.23.48.51;	author msnyder;	state Exp;
branches;
next	1.322.2.9;

1.322.2.9
date	2008.10.07.08.33.15;	author teawater;	state Exp;
branches;
next	1.322.2.10;

1.322.2.10
date	2008.10.07.19.01.04;	author msnyder;	state Exp;
branches;
next	1.322.2.11;

1.322.2.11
date	2008.10.08.00.26.28;	author msnyder;	state Exp;
branches;
next	1.322.2.12;

1.322.2.12
date	2008.10.09.17.45.01;	author msnyder;	state Exp;
branches;
next	1.322.2.13;

1.322.2.13
date	2008.10.20.02.45.29;	author teawater;	state Exp;
branches;
next	1.322.2.14;

1.322.2.14
date	2008.10.23.23.24.45;	author msnyder;	state Exp;
branches;
next	1.322.2.15;

1.322.2.15
date	2008.10.27.04.50.17;	author msnyder;	state Exp;
branches;
next	;

1.300.2.1
date	2008.07.18.04.23.49;	author msnyder;	state Exp;
branches;
next	1.300.2.2;

1.300.2.2
date	2008.07.20.14.30.11;	author teawater;	state Exp;
branches;
next	1.300.2.3;

1.300.2.3
date	2008.07.24.08.58.37;	author teawater;	state Exp;
branches;
next	1.300.2.4;

1.300.2.4
date	2008.07.30.03.43.29;	author teawater;	state Exp;
branches;
next	1.300.2.5;

1.300.2.5
date	2008.09.05.03.37.10;	author msnyder;	state Exp;
branches;
next	1.300.2.6;

1.300.2.6
date	2008.09.17.18.17.24;	author msnyder;	state Exp;
branches;
next	1.300.2.7;

1.300.2.7
date	2008.10.05.19.56.20;	author msnyder;	state Exp;
branches;
next	1.300.2.8;

1.300.2.8
date	2008.10.05.20.00.36;	author msnyder;	state Exp;
branches;
next	1.300.2.9;

1.300.2.9
date	2008.10.06.17.23.31;	author msnyder;	state Exp;
branches;
next	1.300.2.10;

1.300.2.10
date	2008.10.06.23.02.39;	author msnyder;	state Exp;
branches;
next	1.300.2.11;

1.300.2.11
date	2008.10.06.23.13.59;	author msnyder;	state Exp;
branches;
next	1.300.2.12;

1.300.2.12
date	2008.10.06.23.24.21;	author msnyder;	state Exp;
branches;
next	1.300.2.13;

1.300.2.13
date	2008.10.06.23.48.31;	author msnyder;	state Exp;
branches;
next	1.300.2.14;

1.300.2.14
date	2008.10.07.01.18.15;	author msnyder;	state Exp;
branches;
next	1.300.2.15;

1.300.2.15
date	2008.10.07.07.37.37;	author teawater;	state Exp;
branches;
next	1.300.2.16;

1.300.2.16
date	2008.10.07.19.01.26;	author msnyder;	state Exp;
branches;
next	1.300.2.17;

1.300.2.17
date	2008.10.08.00.26.49;	author msnyder;	state Exp;
branches;
next	1.300.2.18;

1.300.2.18
date	2008.10.08.21.28.58;	author msnyder;	state Exp;
branches;
next	;

1.278.2.1
date	2008.06.10.02.11.17;	author msnyder;	state Exp;
branches;
next	;

1.225.2.1
date	2008.06.10.00.13.15;	author msnyder;	state Exp;
branches;
next	;

1.210.4.1
date	2006.05.03.00.36.00;	author msnyder;	state Exp;
branches;
next	;

1.210.6.1
date	2006.05.12.07.40.22;	author nickrob;	state Exp;
branches;
next	1.210.6.2;

1.210.6.2
date	2006.08.28.07.48.48;	author nickrob;	state Exp;
branches;
next	1.210.6.3;

1.210.6.3
date	2006.09.02.09.42.51;	author nickrob;	state Exp;
branches;
next	;

1.210.8.1
date	2006.06.16.01.14.50;	author drow;	state Exp;
branches;
next	;

1.209.2.1
date	2006.04.03.00.47.39;	author drow;	state Exp;
branches
	1.209.2.1.2.1;
next	;

1.209.2.1.2.1
date	2006.04.12.18.11.39;	author drow;	state Exp;
branches;
next	1.209.2.1.2.2;

1.209.2.1.2.2
date	2006.09.21.20.43.50;	author drow;	state Exp;
branches;
next	;

1.209.4.1
date	2006.04.02.21.52.39;	author drow;	state Exp;
branches;
next	;

1.209.6.1
date	2006.03.31.21.00.13;	author msnyder;	state Exp;
branches;
next	1.209.6.2;

1.209.6.2
date	2006.03.31.21.05.37;	author msnyder;	state Exp;
branches;
next	;

1.207.4.1
date	2005.11.22.00.42.28;	author msnyder;	state Exp;
branches;
next	1.207.4.2;

1.207.4.2
date	2005.11.26.04.27.17;	author msnyder;	state Exp;
branches;
next	;

1.205.4.1
date	2005.11.14.15.35.16;	author ams;	state Exp;
branches;
next	;

1.202.2.1
date	2005.05.30.22.33.44;	author msnyder;	state Exp;
branches;
next	;

1.168.2.1
date	2004.07.16.19.42.57;	author cagney;	state Exp;
branches;
next	;

1.142.2.1
date	2004.03.24.04.10.01;	author ezannoni;	state Exp;
branches;
next	;

1.139.2.1
date	2004.03.16.18.27.12;	author cagney;	state Exp;
branches;
next	;

1.137.2.1
date	2004.03.27.17.37.50;	author drow;	state Exp;
branches;
next	1.137.2.2;

1.137.2.2
date	2004.04.02.16.47.47;	author drow;	state Exp;
branches;
next	1.137.2.3;

1.137.2.3
date	2004.09.16.17.01.09;	author drow;	state Exp;
branches;
next	;

1.113.4.1
date	2003.10.15.19.55.47;	author kettenis;	state Exp;
branches;
next	;

1.109.8.1
date	2003.06.03.20.54.38;	author cagney;	state Exp;
branches;
next	;

1.107.2.1
date	2003.05.18.09.44.13;	author kettenis;	state Exp;
branches;
next	;

1.102.2.1
date	2003.04.10.21.33.49;	author cagney;	state Exp;
branches;
next	;

1.100.2.1
date	2003.03.30.16.35.21;	author cagney;	state Exp;
branches;
next	;

1.93.2.1
date	2003.01.20.00.38.14;	author cagney;	state Exp;
branches;
next	;

1.72.2.1
date	2002.10.26.17.12.08;	author drow;	state Exp;
branches;
next	1.72.2.2;

1.72.2.2
date	2003.12.14.20.27.19;	author drow;	state Exp;
branches;
next	1.72.2.3;

1.72.2.3
date	2004.01.13.16.11.57;	author drow;	state Exp;
branches;
next	1.72.2.4;

1.72.2.4
date	2004.02.09.19.43.41;	author drow;	state Exp;
branches;
next	;

1.71.2.1
date	2002.10.11.22.22.55;	author carlton;	state Exp;
branches;
next	1.71.2.2;

1.71.2.2
date	2002.10.25.23.49.54;	author carlton;	state Exp;
branches;
next	1.71.2.3;

1.71.2.3
date	2002.12.23.19.38.31;	author carlton;	state Exp;
branches;
next	1.71.2.4;

1.71.2.4
date	2003.02.07.19.17.50;	author carlton;	state Exp;
branches;
next	1.71.2.5;

1.71.2.5
date	2003.03.06.00.56.29;	author carlton;	state Exp;
branches;
next	1.71.2.6;

1.71.2.6
date	2003.04.16.19.56.53;	author carlton;	state Exp;
branches;
next	1.71.2.7;

1.71.2.7
date	2003.05.23.18.40.40;	author carlton;	state Exp;
branches;
next	1.71.2.8;

1.71.2.8
date	2003.06.27.21.50.03;	author carlton;	state Exp;
branches;
next	1.71.2.9;

1.71.2.9
date	2003.09.17.21.28.22;	author carlton;	state Exp;
branches;
next	1.71.2.10;

1.71.2.10
date	2003.11.11.23.50.47;	author carlton;	state Exp;
branches;
next	1.71.2.11;

1.71.2.11
date	2003.12.16.00.00.37;	author carlton;	state Exp;
branches;
next	1.71.2.12;

1.71.2.12
date	2004.01.26.19.11.27;	author carlton;	state Exp;
branches;
next	;

1.70.6.1
date	2002.09.18.22.44.33;	author cagney;	state Exp;
branches;
next	;

1.58.4.1
date	2002.05.16.00.54.56;	author cagney;	state Exp;
branches;
next	1.58.4.2;

1.58.4.2
date	2002.05.16.19.08.00;	author cagney;	state Exp;
branches;
next	1.58.4.3;

1.58.4.3
date	2002.05.17.15.06.30;	author cagney;	state Exp;
branches;
next	1.58.4.4;

1.58.4.4
date	2002.06.15.16.42.52;	author cagney;	state Exp;
branches;
next	1.58.4.5;

1.58.4.5
date	2002.06.21.16.19.26;	author cagney;	state Exp;
branches;
next	1.58.4.6;

1.58.4.6
date	2002.06.21.19.35.25;	author cagney;	state Exp;
branches;
next	1.58.4.7;

1.58.4.7
date	2002.06.25.20.02.41;	author cagney;	state Exp;
branches;
next	;

1.58.6.1
date	2002.06.20.01.32.37;	author kseitz;	state Exp;
branches;
next	1.58.6.2;

1.58.6.2
date	2002.07.22.21.46.59;	author kseitz;	state Exp;
branches;
next	1.58.6.3;

1.58.6.3
date	2002.08.09.18.34.25;	author kseitz;	state Exp;
branches;
next	1.58.6.4;

1.58.6.4
date	2002.08.09.19.46.14;	author kseitz;	state Exp;
branches;
next	1.58.6.5;

1.58.6.5
date	2002.08.28.16.55.55;	author kseitz;	state Exp;
branches;
next	1.58.6.6;

1.58.6.6
date	2002.08.30.22.52.44;	author kseitz;	state Exp;
branches;
next	1.58.6.7;

1.58.6.7
date	2002.10.01.00.46.09;	author kseitz;	state Exp;
branches;
next	1.58.6.8;

1.58.6.8
date	2002.11.04.00.17.31;	author ezannoni;	state Exp;
branches;
next	;

1.42.2.1
date	2001.07.06.19.17.01;	author dberlin;	state Exp;
branches;
next	;

1.6.2.1
date	2000.04.13.10.24.28;	author eliz;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.04.20.11.00.29;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.33;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.42.38;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.05.11.13.29.11;	author shebs;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.05.19.19.52.30;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.05.25.18.02.20;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.06.14.18.07.44;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.07.05.17.53.17;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.07.07.20.07.16;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.07.19.23.27.59;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.08.02.23.45.39;	author jsm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.08.09.21.33.34;	author jsm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.08.16.19.52.58;	author jsm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.08.23.22.35.14;	author jsm;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.08.31.01.05.15;	author jsm;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	99.09.08.23.59.17;	author shebs;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	99.09.22.03.24.40;	author jsm;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	99.09.28.21.52.15;	author jsm;	state Exp;
branches;
next	1.1.1.19;

1.1.1.19
date	99.10.05.23.08.23;	author jsm;	state Exp;
branches;
next	1.1.1.20;

1.1.1.20
date	99.10.19.02.46.37;	author jsm;	state Exp;
branches;
next	1.1.1.21;

1.1.1.21
date	99.11.09.01.23.04;	author jsm;	state Exp;
branches;
next	1.1.1.22;

1.1.1.22
date	99.12.07.03.56.02;	author jsm;	state Exp;
branches;
next	1.1.1.23;

1.1.1.23
date	99.12.14.01.05.32;	author jsm;	state Exp;
branches;
next	1.1.1.24;

1.1.1.24
date	2000.01.06.03.06.36;	author jsm;	state Exp;
branches;
next	1.1.1.25;

1.1.1.25
date	2000.01.18.00.54.10;	author jsm;	state Exp;
branches;
next	1.1.1.26;

1.1.1.26
date	2000.02.03.04.14.28;	author jsm;	state Exp;
branches;
next	1.1.1.27;

1.1.1.27
date	2000.02.05.07.29.43;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.595
log
@[gdb/16062] stepi sometimes doesn't make progress

I noticed something odd while doing "stepi" over a fork syscall:

 ...
 (gdb) set disassemble-next-line on
 ...
 (gdb) si
 0x000000323d4ba7c2      131       pid = ARCH_FORK ();
    0x000000323d4ba7a4 <__libc_fork+132>:        64 4c 8b 04 25 10 00 00 00      mov    %fs:0x10,%r8
    0x000000323d4ba7ad <__libc_fork+141>:        31 d2   xor    %edx,%edx
    0x000000323d4ba7af <__libc_fork+143>:        4d 8d 90 d0 02 00 00    lea    0x2d0(%r8),%r10
    0x000000323d4ba7b6 <__libc_fork+150>:        31 f6   xor    %esi,%esi
    0x000000323d4ba7b8 <__libc_fork+152>:        bf 11 00 20 01  mov    $0x1200011,%edi
    0x000000323d4ba7bd <__libc_fork+157>:        b8 38 00 00 00  mov    $0x38,%eax
 => 0x000000323d4ba7c2 <__libc_fork+162>:        0f 05   syscall
    0x000000323d4ba7c4 <__libc_fork+164>:        48 3d 00 f0 ff ff       cmp    $0xfffffffffffff000,%rax
    0x000000323d4ba7ca <__libc_fork+170>:        0f 87 2b 01 00 00       ja     0x323d4ba8fb <__libc_fork+475>
 (gdb) si
 0x000000323d4ba7c4      131       pid = ARCH_FORK ();
    0x000000323d4ba7a4 <__libc_fork+132>:        64 4c 8b 04 25 10 00 00 00      mov    %fs:0x10,%r8
    0x000000323d4ba7ad <__libc_fork+141>:        31 d2   xor    %edx,%edx
    0x000000323d4ba7af <__libc_fork+143>:        4d 8d 90 d0 02 00 00    lea    0x2d0(%r8),%r10
    0x000000323d4ba7b6 <__libc_fork+150>:        31 f6   xor    %esi,%esi
    0x000000323d4ba7b8 <__libc_fork+152>:        bf 11 00 20 01  mov    $0x1200011,%edi
    0x000000323d4ba7bd <__libc_fork+157>:        b8 38 00 00 00  mov    $0x38,%eax
    0x000000323d4ba7c2 <__libc_fork+162>:        0f 05   syscall
 => 0x000000323d4ba7c4 <__libc_fork+164>:        48 3d 00 f0 ff ff       cmp    $0xfffffffffffff000,%rax
    0x000000323d4ba7ca <__libc_fork+170>:        0f 87 2b 01 00 00       ja     0x323d4ba8fb <__libc_fork+475>
 (gdb) si
 0x000000323d4ba7c4      131       pid = ARCH_FORK ();
    0x000000323d4ba7a4 <__libc_fork+132>:        64 4c 8b 04 25 10 00 00 00      mov    %fs:0x10,%r8
    0x000000323d4ba7ad <__libc_fork+141>:        31 d2   xor    %edx,%edx
    0x000000323d4ba7af <__libc_fork+143>:        4d 8d 90 d0 02 00 00    lea    0x2d0(%r8),%r10
    0x000000323d4ba7b6 <__libc_fork+150>:        31 f6   xor    %esi,%esi
    0x000000323d4ba7b8 <__libc_fork+152>:        bf 11 00 20 01  mov    $0x1200011,%edi
    0x000000323d4ba7bd <__libc_fork+157>:        b8 38 00 00 00  mov    $0x38,%eax
    0x000000323d4ba7c2 <__libc_fork+162>:        0f 05   syscall
 => 0x000000323d4ba7c4 <__libc_fork+164>:        48 3d 00 f0 ff ff       cmp    $0xfffffffffffff000,%rax
    0x000000323d4ba7ca <__libc_fork+170>:        0f 87 2b 01 00 00       ja     0x323d4ba8fb <__libc_fork+475>
 (gdb) si
 0x000000323d4ba7ca      131       pid = ARCH_FORK ();
    0x000000323d4ba7a4 <__libc_fork+132>:        64 4c 8b 04 25 10 00 00 00      mov    %fs:0x10,%r8
    0x000000323d4ba7ad <__libc_fork+141>:        31 d2   xor    %edx,%edx
    0x000000323d4ba7af <__libc_fork+143>:        4d 8d 90 d0 02 00 00    lea    0x2d0(%r8),%r10
    0x000000323d4ba7b6 <__libc_fork+150>:        31 f6   xor    %esi,%esi
    0x000000323d4ba7b8 <__libc_fork+152>:        bf 11 00 20 01  mov    $0x1200011,%edi
    0x000000323d4ba7bd <__libc_fork+157>:        b8 38 00 00 00  mov    $0x38,%eax
    0x000000323d4ba7c2 <__libc_fork+162>:        0f 05   syscall
    0x000000323d4ba7c4 <__libc_fork+164>:        48 3d 00 f0 ff ff       cmp    $0xfffffffffffff000,%rax
 => 0x000000323d4ba7ca <__libc_fork+170>:        0f 87 2b 01 00 00       ja     0x323d4ba8fb <__libc_fork+475>

Notice how the third "si" didn't actually make progress.

Turning on infrun and lin-lwp debug, we see:

 (gdb)
 infrun: clear_proceed_status_thread (process 5252)
 infrun: proceed (addr=0xffffffffffffffff, signal=144, step=1)
 infrun: resume (step=1, signal=0), trap_expected=0, current thread [process 5252] at 0x323d4ba7c4
 LLR: Preparing to step process 5252, 0, inferior_ptid process 5252
 RC: Not resuming sibling process 5252 (not stopped)
 LLR: PTRACE_SINGLESTEP process 5252, 0 (resume event thread)
 sigchld
 infrun: wait_for_inferior ()
 linux_nat_wait: [process -1], []
 LLW: enter
 LNW: waitpid(-1, ...) returned 5252, No child processes
 LLW: waitpid 5252 received Child exited (stopped)
 LLW: Candidate event Child exited (stopped) in process 5252.
 SEL: Select single-step process 5252
 LLW: exit
 infrun: target_wait (-1, status) =
 infrun:   5252 [process 5252],
 infrun:   status->kind = stopped, signal = SIGCHLD
 infrun: infwait_normal_state
 infrun: TARGET_WAITKIND_STOPPED
 infrun: stop_pc = 0x323d4ba7c4
 infrun: random signal 20
 infrun: stepi/nexti
 infrun: stop_stepping

So the inferior got a SIGCHLD (because the fork child exited while
we're doing 'si'), and since that signal is set to "nostop noprint
pass" (by default), it's considered a random signal, so it should not
cause a stop.  But, it resulted in an immediate a stop_stepping call
anyway.  So the single-step never really finished.

This is a regression caused by:

 [[PATCH] Do not respawn signals, take 2.]
 https://sourceware.org/ml/gdb-patches/2012-06/msg00702.html

Specifically, caused by this change (as mentioned in the "the lost
step issue first" part of that mail):

 diff --git a/gdb/infrun.c b/gdb/infrun.c
 index 53db335..3e8dbc8 100644
 --- a/gdb/infrun.c
 +++ b/gdb/infrun.c
 @@@@ -4363,10 +4363,8 @@@@ process_event_stop_test:
  	 (leaving the inferior at the step-resume-breakpoint without
  	 actually executing it).  Either way continue until the
  	 breakpoint is really hit.  */
 -      keep_going (ecs);
 -      return;
      }
 -
 +  else
    /* Handle cases caused by hitting a breakpoint.  */
    {


That made GDB fall through to the

>   /* In all-stop mode, if we're currently stepping but have stopped in
>   some other thread, we need to switch back to the stepped thread.  */
>  if (!non_stop)

part.  However, if we don't have a stepped thread to get back to,
we'll now also fall through to all the "stepping" tests.  For line
stepping, that'll turn out okay, as we'll just end up realizing the
thread is still in the stepping range, and needs to be re-stepped.
However, for stepi/nexti, we'll reach:

  if (ecs->event_thread->control.step_range_end == 1)
    {
      /* It is stepi or nexti.  We always want to stop stepping after
         one instruction.  */
      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog, "infrun: stepi/nexti\n");
      ecs->event_thread->control.stop_step = 1;
      print_end_stepping_range_reason ();
      stop_stepping (ecs);
      return;
    }

and stop, even though the thread actually made no progress.  The fix
is to restore the keep_going call, but put it after the "switch back
to the stepped thread" code, and before the stepping tests.

Tested on x86_64 Fedora 17, native and gdbserver.  New test included.

gdb/
2013-10-18  Pedro Alves  <palves@@redhat.com>

	PR gdb/16062
	* infrun.c (handle_inferior_event): Keep going if we got a random
	signal we should not stop for, instead of falling through to the
	step tests.

gdb/testsuite/
2013-10-18  Pedro Alves  <palves@@redhat.com>

	PR gdb/16062
	* gdb.threads/stepi-random-signal.c: New file.
	* gdb.threads/stepi-random-signal.exp: New file.
@
text
@/* Target-struct-independent code to start (run) and stop an inferior
   process.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdb_string.h"
#include <ctype.h>
#include "symtab.h"
#include "frame.h"
#include "inferior.h"
#include "exceptions.h"
#include "breakpoint.h"
#include "gdb_wait.h"
#include "gdbcore.h"
#include "gdbcmd.h"
#include "cli/cli-script.h"
#include "target.h"
#include "gdbthread.h"
#include "annotate.h"
#include "symfile.h"
#include "top.h"
#include <signal.h>
#include "inf-loop.h"
#include "regcache.h"
#include "value.h"
#include "observer.h"
#include "language.h"
#include "solib.h"
#include "main.h"
#include "dictionary.h"
#include "block.h"
#include "gdb_assert.h"
#include "mi/mi-common.h"
#include "event-top.h"
#include "record.h"
#include "record-full.h"
#include "inline-frame.h"
#include "jit.h"
#include "tracepoint.h"
#include "continuations.h"
#include "interps.h"
#include "skip.h"
#include "probe.h"
#include "objfiles.h"
#include "completer.h"
#include "target-descriptions.h"

/* Prototypes for local functions */

static void signals_info (char *, int);

static void handle_command (char *, int);

static void sig_print_info (enum gdb_signal);

static void sig_print_header (void);

static void resume_cleanups (void *);

static int hook_stop_stub (void *);

static int restore_selected_frame (void *);

static int follow_fork (void);

static void set_schedlock_func (char *args, int from_tty,
				struct cmd_list_element *c);

static int currently_stepping (struct thread_info *tp);

static int currently_stepping_or_nexting_callback (struct thread_info *tp,
						   void *data);

static void xdb_handle_command (char *args, int from_tty);

static int prepare_to_proceed (int);

static void print_exited_reason (int exitstatus);

static void print_signal_exited_reason (enum gdb_signal siggnal);

static void print_no_history_reason (void);

static void print_signal_received_reason (enum gdb_signal siggnal);

static void print_end_stepping_range_reason (void);

void _initialize_infrun (void);

void nullify_last_target_wait_ptid (void);

static void insert_hp_step_resume_breakpoint_at_frame (struct frame_info *);

static void insert_step_resume_breakpoint_at_caller (struct frame_info *);

static void insert_longjmp_resume_breakpoint (struct gdbarch *, CORE_ADDR);

/* When set, stop the 'step' command if we enter a function which has
   no line number information.  The normal behavior is that we step
   over such function.  */
int step_stop_if_no_debug = 0;
static void
show_step_stop_if_no_debug (struct ui_file *file, int from_tty,
			    struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Mode of the step operation is %s.\n"), value);
}

/* In asynchronous mode, but simulating synchronous execution.  */

int sync_execution = 0;

/* wait_for_inferior and normal_stop use this to notify the user
   when the inferior stopped in a different thread than it had been
   running in.  */

static ptid_t previous_inferior_ptid;

/* If set (default for legacy reasons), when following a fork, GDB
   will detach from one of the fork branches, child or parent.
   Exactly which branch is detached depends on 'set follow-fork-mode'
   setting.  */

static int detach_fork = 1;

int debug_displaced = 0;
static void
show_debug_displaced (struct ui_file *file, int from_tty,
		      struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Displace stepping debugging is %s.\n"), value);
}

unsigned int debug_infrun = 0;
static void
show_debug_infrun (struct ui_file *file, int from_tty,
		   struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Inferior debugging is %s.\n"), value);
}


/* Support for disabling address space randomization.  */

int disable_randomization = 1;

static void
show_disable_randomization (struct ui_file *file, int from_tty,
			    struct cmd_list_element *c, const char *value)
{
  if (target_supports_disable_randomization ())
    fprintf_filtered (file,
		      _("Disabling randomization of debuggee's "
			"virtual address space is %s.\n"),
		      value);
  else
    fputs_filtered (_("Disabling randomization of debuggee's "
		      "virtual address space is unsupported on\n"
		      "this platform.\n"), file);
}

static void
set_disable_randomization (char *args, int from_tty,
			   struct cmd_list_element *c)
{
  if (!target_supports_disable_randomization ())
    error (_("Disabling randomization of debuggee's "
	     "virtual address space is unsupported on\n"
	     "this platform."));
}

/* User interface for non-stop mode.  */

int non_stop = 0;
static int non_stop_1 = 0;

static void
set_non_stop (char *args, int from_tty,
	      struct cmd_list_element *c)
{
  if (target_has_execution)
    {
      non_stop_1 = non_stop;
      error (_("Cannot change this setting while the inferior is running."));
    }

  non_stop = non_stop_1;
}

static void
show_non_stop (struct ui_file *file, int from_tty,
	       struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file,
		    _("Controlling the inferior in non-stop mode is %s.\n"),
		    value);
}

/* "Observer mode" is somewhat like a more extreme version of
   non-stop, in which all GDB operations that might affect the
   target's execution have been disabled.  */

int observer_mode = 0;
static int observer_mode_1 = 0;

static void
set_observer_mode (char *args, int from_tty,
		   struct cmd_list_element *c)
{
  if (target_has_execution)
    {
      observer_mode_1 = observer_mode;
      error (_("Cannot change this setting while the inferior is running."));
    }

  observer_mode = observer_mode_1;

  may_write_registers = !observer_mode;
  may_write_memory = !observer_mode;
  may_insert_breakpoints = !observer_mode;
  may_insert_tracepoints = !observer_mode;
  /* We can insert fast tracepoints in or out of observer mode,
     but enable them if we're going into this mode.  */
  if (observer_mode)
    may_insert_fast_tracepoints = 1;
  may_stop = !observer_mode;
  update_target_permissions ();

  /* Going *into* observer mode we must force non-stop, then
     going out we leave it that way.  */
  if (observer_mode)
    {
      target_async_permitted = 1;
      pagination_enabled = 0;
      non_stop = non_stop_1 = 1;
    }

  if (from_tty)
    printf_filtered (_("Observer mode is now %s.\n"),
		     (observer_mode ? "on" : "off"));
}

static void
show_observer_mode (struct ui_file *file, int from_tty,
		    struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Observer mode is %s.\n"), value);
}

/* This updates the value of observer mode based on changes in
   permissions.  Note that we are deliberately ignoring the values of
   may-write-registers and may-write-memory, since the user may have
   reason to enable these during a session, for instance to turn on a
   debugging-related global.  */

void
update_observer_mode (void)
{
  int newval;

  newval = (!may_insert_breakpoints
	    && !may_insert_tracepoints
	    && may_insert_fast_tracepoints
	    && !may_stop
	    && non_stop);

  /* Let the user know if things change.  */
  if (newval != observer_mode)
    printf_filtered (_("Observer mode is now %s.\n"),
		     (newval ? "on" : "off"));

  observer_mode = observer_mode_1 = newval;
}

/* Tables of how to react to signals; the user sets them.  */

static unsigned char *signal_stop;
static unsigned char *signal_print;
static unsigned char *signal_program;

/* Table of signals that are registered with "catch signal".  A
   non-zero entry indicates that the signal is caught by some "catch
   signal" command.  This has size GDB_SIGNAL_LAST, to accommodate all
   signals.  */
static unsigned char *signal_catch;

/* Table of signals that the target may silently handle.
   This is automatically determined from the flags above,
   and simply cached here.  */
static unsigned char *signal_pass;

#define SET_SIGS(nsigs,sigs,flags) \
  do { \
    int signum = (nsigs); \
    while (signum-- > 0) \
      if ((sigs)[signum]) \
	(flags)[signum] = 1; \
  } while (0)

#define UNSET_SIGS(nsigs,sigs,flags) \
  do { \
    int signum = (nsigs); \
    while (signum-- > 0) \
      if ((sigs)[signum]) \
	(flags)[signum] = 0; \
  } while (0)

/* Update the target's copy of SIGNAL_PROGRAM.  The sole purpose of
   this function is to avoid exporting `signal_program'.  */

void
update_signals_program_target (void)
{
  target_program_signals ((int) GDB_SIGNAL_LAST, signal_program);
}

/* Value to pass to target_resume() to cause all threads to resume.  */

#define RESUME_ALL minus_one_ptid

/* Command list pointer for the "stop" placeholder.  */

static struct cmd_list_element *stop_command;

/* Function inferior was in as of last step command.  */

static struct symbol *step_start_function;

/* Nonzero if we want to give control to the user when we're notified
   of shared library events by the dynamic linker.  */
int stop_on_solib_events;

/* Enable or disable optional shared library event breakpoints
   as appropriate when the above flag is changed.  */

static void
set_stop_on_solib_events (char *args, int from_tty, struct cmd_list_element *c)
{
  update_solib_breakpoints ();
}

static void
show_stop_on_solib_events (struct ui_file *file, int from_tty,
			   struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Stopping for shared library events is %s.\n"),
		    value);
}

/* Nonzero means expecting a trace trap
   and should stop the inferior and return silently when it happens.  */

int stop_after_trap;

/* Save register contents here when executing a "finish" command or are
   about to pop a stack dummy frame, if-and-only-if proceed_to_finish is set.
   Thus this contains the return value from the called function (assuming
   values are returned in a register).  */

struct regcache *stop_registers;

/* Nonzero after stop if current stack frame should be printed.  */

static int stop_print_frame;

/* This is a cached copy of the pid/waitstatus of the last event
   returned by target_wait()/deprecated_target_wait_hook().  This
   information is returned by get_last_target_status().  */
static ptid_t target_last_wait_ptid;
static struct target_waitstatus target_last_waitstatus;

static void context_switch (ptid_t ptid);

void init_thread_stepping_state (struct thread_info *tss);

static void init_infwait_state (void);

static const char follow_fork_mode_child[] = "child";
static const char follow_fork_mode_parent[] = "parent";

static const char *const follow_fork_mode_kind_names[] = {
  follow_fork_mode_child,
  follow_fork_mode_parent,
  NULL
};

static const char *follow_fork_mode_string = follow_fork_mode_parent;
static void
show_follow_fork_mode_string (struct ui_file *file, int from_tty,
			      struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file,
		    _("Debugger response to a program "
		      "call of fork or vfork is \"%s\".\n"),
		    value);
}


/* Tell the target to follow the fork we're stopped at.  Returns true
   if the inferior should be resumed; false, if the target for some
   reason decided it's best not to resume.  */

static int
follow_fork (void)
{
  int follow_child = (follow_fork_mode_string == follow_fork_mode_child);
  int should_resume = 1;
  struct thread_info *tp;

  /* Copy user stepping state to the new inferior thread.  FIXME: the
     followed fork child thread should have a copy of most of the
     parent thread structure's run control related fields, not just these.
     Initialized to avoid "may be used uninitialized" warnings from gcc.  */
  struct breakpoint *step_resume_breakpoint = NULL;
  struct breakpoint *exception_resume_breakpoint = NULL;
  CORE_ADDR step_range_start = 0;
  CORE_ADDR step_range_end = 0;
  struct frame_id step_frame_id = { 0 };

  if (!non_stop)
    {
      ptid_t wait_ptid;
      struct target_waitstatus wait_status;

      /* Get the last target status returned by target_wait().  */
      get_last_target_status (&wait_ptid, &wait_status);

      /* If not stopped at a fork event, then there's nothing else to
	 do.  */
      if (wait_status.kind != TARGET_WAITKIND_FORKED
	  && wait_status.kind != TARGET_WAITKIND_VFORKED)
	return 1;

      /* Check if we switched over from WAIT_PTID, since the event was
	 reported.  */
      if (!ptid_equal (wait_ptid, minus_one_ptid)
	  && !ptid_equal (inferior_ptid, wait_ptid))
	{
	  /* We did.  Switch back to WAIT_PTID thread, to tell the
	     target to follow it (in either direction).  We'll
	     afterwards refuse to resume, and inform the user what
	     happened.  */
	  switch_to_thread (wait_ptid);
	  should_resume = 0;
	}
    }

  tp = inferior_thread ();

  /* If there were any forks/vforks that were caught and are now to be
     followed, then do so now.  */
  switch (tp->pending_follow.kind)
    {
    case TARGET_WAITKIND_FORKED:
    case TARGET_WAITKIND_VFORKED:
      {
	ptid_t parent, child;

	/* If the user did a next/step, etc, over a fork call,
	   preserve the stepping state in the fork child.  */
	if (follow_child && should_resume)
	  {
	    step_resume_breakpoint = clone_momentary_breakpoint
					 (tp->control.step_resume_breakpoint);
	    step_range_start = tp->control.step_range_start;
	    step_range_end = tp->control.step_range_end;
	    step_frame_id = tp->control.step_frame_id;
	    exception_resume_breakpoint
	      = clone_momentary_breakpoint (tp->control.exception_resume_breakpoint);

	    /* For now, delete the parent's sr breakpoint, otherwise,
	       parent/child sr breakpoints are considered duplicates,
	       and the child version will not be installed.  Remove
	       this when the breakpoints module becomes aware of
	       inferiors and address spaces.  */
	    delete_step_resume_breakpoint (tp);
	    tp->control.step_range_start = 0;
	    tp->control.step_range_end = 0;
	    tp->control.step_frame_id = null_frame_id;
	    delete_exception_resume_breakpoint (tp);
	  }

	parent = inferior_ptid;
	child = tp->pending_follow.value.related_pid;

	/* Tell the target to do whatever is necessary to follow
	   either parent or child.  */
	if (target_follow_fork (follow_child, detach_fork))
	  {
	    /* Target refused to follow, or there's some other reason
	       we shouldn't resume.  */
	    should_resume = 0;
	  }
	else
	  {
	    /* This pending follow fork event is now handled, one way
	       or another.  The previous selected thread may be gone
	       from the lists by now, but if it is still around, need
	       to clear the pending follow request.  */
	    tp = find_thread_ptid (parent);
	    if (tp)
	      tp->pending_follow.kind = TARGET_WAITKIND_SPURIOUS;

	    /* This makes sure we don't try to apply the "Switched
	       over from WAIT_PID" logic above.  */
	    nullify_last_target_wait_ptid ();

	    /* If we followed the child, switch to it...  */
	    if (follow_child)
	      {
		switch_to_thread (child);

		/* ... and preserve the stepping state, in case the
		   user was stepping over the fork call.  */
		if (should_resume)
		  {
		    tp = inferior_thread ();
		    tp->control.step_resume_breakpoint
		      = step_resume_breakpoint;
		    tp->control.step_range_start = step_range_start;
		    tp->control.step_range_end = step_range_end;
		    tp->control.step_frame_id = step_frame_id;
		    tp->control.exception_resume_breakpoint
		      = exception_resume_breakpoint;
		  }
		else
		  {
		    /* If we get here, it was because we're trying to
		       resume from a fork catchpoint, but, the user
		       has switched threads away from the thread that
		       forked.  In that case, the resume command
		       issued is most likely not applicable to the
		       child, so just warn, and refuse to resume.  */
		    warning (_("Not resuming: switched threads "
			       "before following fork child.\n"));
		  }

		/* Reset breakpoints in the child as appropriate.  */
		follow_inferior_reset_breakpoints ();
	      }
	    else
	      switch_to_thread (parent);
	  }
      }
      break;
    case TARGET_WAITKIND_SPURIOUS:
      /* Nothing to follow.  */
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      "Unexpected pending_follow.kind %d\n",
		      tp->pending_follow.kind);
      break;
    }

  return should_resume;
}

void
follow_inferior_reset_breakpoints (void)
{
  struct thread_info *tp = inferior_thread ();

  /* Was there a step_resume breakpoint?  (There was if the user
     did a "next" at the fork() call.)  If so, explicitly reset its
     thread number.

     step_resumes are a form of bp that are made to be per-thread.
     Since we created the step_resume bp when the parent process
     was being debugged, and now are switching to the child process,
     from the breakpoint package's viewpoint, that's a switch of
     "threads".  We must update the bp's notion of which thread
     it is for, or it'll be ignored when it triggers.  */

  if (tp->control.step_resume_breakpoint)
    breakpoint_re_set_thread (tp->control.step_resume_breakpoint);

  if (tp->control.exception_resume_breakpoint)
    breakpoint_re_set_thread (tp->control.exception_resume_breakpoint);

  /* Reinsert all breakpoints in the child.  The user may have set
     breakpoints after catching the fork, in which case those
     were never set in the child, but only in the parent.  This makes
     sure the inserted breakpoints match the breakpoint list.  */

  breakpoint_re_set ();
  insert_breakpoints ();
}

/* The child has exited or execed: resume threads of the parent the
   user wanted to be executing.  */

static int
proceed_after_vfork_done (struct thread_info *thread,
			  void *arg)
{
  int pid = * (int *) arg;

  if (ptid_get_pid (thread->ptid) == pid
      && is_running (thread->ptid)
      && !is_executing (thread->ptid)
      && !thread->stop_requested
      && thread->suspend.stop_signal == GDB_SIGNAL_0)
    {
      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog,
			    "infrun: resuming vfork parent thread %s\n",
			    target_pid_to_str (thread->ptid));

      switch_to_thread (thread->ptid);
      clear_proceed_status ();
      proceed ((CORE_ADDR) -1, GDB_SIGNAL_DEFAULT, 0);
    }

  return 0;
}

/* Called whenever we notice an exec or exit event, to handle
   detaching or resuming a vfork parent.  */

static void
handle_vfork_child_exec_or_exit (int exec)
{
  struct inferior *inf = current_inferior ();

  if (inf->vfork_parent)
    {
      int resume_parent = -1;

      /* This exec or exit marks the end of the shared memory region
	 between the parent and the child.  If the user wanted to
	 detach from the parent, now is the time.  */

      if (inf->vfork_parent->pending_detach)
	{
	  struct thread_info *tp;
	  struct cleanup *old_chain;
	  struct program_space *pspace;
	  struct address_space *aspace;

	  /* follow-fork child, detach-on-fork on.  */

	  inf->vfork_parent->pending_detach = 0;

	  if (!exec)
	    {
	      /* If we're handling a child exit, then inferior_ptid
		 points at the inferior's pid, not to a thread.  */
	      old_chain = save_inferior_ptid ();
	      save_current_program_space ();
	      save_current_inferior ();
	    }
	  else
	    old_chain = save_current_space_and_thread ();

	  /* We're letting loose of the parent.  */
	  tp = any_live_thread_of_process (inf->vfork_parent->pid);
	  switch_to_thread (tp->ptid);

	  /* We're about to detach from the parent, which implicitly
	     removes breakpoints from its address space.  There's a
	     catch here: we want to reuse the spaces for the child,
	     but, parent/child are still sharing the pspace at this
	     point, although the exec in reality makes the kernel give
	     the child a fresh set of new pages.  The problem here is
	     that the breakpoints module being unaware of this, would
	     likely chose the child process to write to the parent
	     address space.  Swapping the child temporarily away from
	     the spaces has the desired effect.  Yes, this is "sort
	     of" a hack.  */

	  pspace = inf->pspace;
	  aspace = inf->aspace;
	  inf->aspace = NULL;
	  inf->pspace = NULL;

	  if (debug_infrun || info_verbose)
	    {
	      target_terminal_ours ();

	      if (exec)
		fprintf_filtered (gdb_stdlog,
				  "Detaching vfork parent process "
				  "%d after child exec.\n",
				  inf->vfork_parent->pid);
	      else
		fprintf_filtered (gdb_stdlog,
				  "Detaching vfork parent process "
				  "%d after child exit.\n",
				  inf->vfork_parent->pid);
	    }

	  target_detach (NULL, 0);

	  /* Put it back.  */
	  inf->pspace = pspace;
	  inf->aspace = aspace;

	  do_cleanups (old_chain);
	}
      else if (exec)
	{
	  /* We're staying attached to the parent, so, really give the
	     child a new address space.  */
	  inf->pspace = add_program_space (maybe_new_address_space ());
	  inf->aspace = inf->pspace->aspace;
	  inf->removable = 1;
	  set_current_program_space (inf->pspace);

	  resume_parent = inf->vfork_parent->pid;

	  /* Break the bonds.  */
	  inf->vfork_parent->vfork_child = NULL;
	}
      else
	{
	  struct cleanup *old_chain;
	  struct program_space *pspace;

	  /* If this is a vfork child exiting, then the pspace and
	     aspaces were shared with the parent.  Since we're
	     reporting the process exit, we'll be mourning all that is
	     found in the address space, and switching to null_ptid,
	     preparing to start a new inferior.  But, since we don't
	     want to clobber the parent's address/program spaces, we
	     go ahead and create a new one for this exiting
	     inferior.  */

	  /* Switch to null_ptid, so that clone_program_space doesn't want
	     to read the selected frame of a dead process.  */
	  old_chain = save_inferior_ptid ();
	  inferior_ptid = null_ptid;

	  /* This inferior is dead, so avoid giving the breakpoints
	     module the option to write through to it (cloning a
	     program space resets breakpoints).  */
	  inf->aspace = NULL;
	  inf->pspace = NULL;
	  pspace = add_program_space (maybe_new_address_space ());
	  set_current_program_space (pspace);
	  inf->removable = 1;
	  inf->symfile_flags = SYMFILE_NO_READ;
	  clone_program_space (pspace, inf->vfork_parent->pspace);
	  inf->pspace = pspace;
	  inf->aspace = pspace->aspace;

	  /* Put back inferior_ptid.  We'll continue mourning this
	     inferior.  */
	  do_cleanups (old_chain);

	  resume_parent = inf->vfork_parent->pid;
	  /* Break the bonds.  */
	  inf->vfork_parent->vfork_child = NULL;
	}

      inf->vfork_parent = NULL;

      gdb_assert (current_program_space == inf->pspace);

      if (non_stop && resume_parent != -1)
	{
	  /* If the user wanted the parent to be running, let it go
	     free now.  */
	  struct cleanup *old_chain = make_cleanup_restore_current_thread ();

	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog,
				"infrun: resuming vfork parent process %d\n",
				resume_parent);

	  iterate_over_threads (proceed_after_vfork_done, &resume_parent);

	  do_cleanups (old_chain);
	}
    }
}

/* Enum strings for "set|show follow-exec-mode".  */

static const char follow_exec_mode_new[] = "new";
static const char follow_exec_mode_same[] = "same";
static const char *const follow_exec_mode_names[] =
{
  follow_exec_mode_new,
  follow_exec_mode_same,
  NULL,
};

static const char *follow_exec_mode_string = follow_exec_mode_same;
static void
show_follow_exec_mode_string (struct ui_file *file, int from_tty,
			      struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Follow exec mode is \"%s\".\n"),  value);
}

/* EXECD_PATHNAME is assumed to be non-NULL.  */

static void
follow_exec (ptid_t pid, char *execd_pathname)
{
  struct thread_info *th = inferior_thread ();
  struct inferior *inf = current_inferior ();

  /* This is an exec event that we actually wish to pay attention to.
     Refresh our symbol table to the newly exec'd program, remove any
     momentary bp's, etc.

     If there are breakpoints, they aren't really inserted now,
     since the exec() transformed our inferior into a fresh set
     of instructions.

     We want to preserve symbolic breakpoints on the list, since
     we have hopes that they can be reset after the new a.out's
     symbol table is read.

     However, any "raw" breakpoints must be removed from the list
     (e.g., the solib bp's), since their address is probably invalid
     now.

     And, we DON'T want to call delete_breakpoints() here, since
     that may write the bp's "shadow contents" (the instruction
     value that was overwritten witha TRAP instruction).  Since
     we now have a new a.out, those shadow contents aren't valid.  */

  mark_breakpoints_out ();

  update_breakpoints_after_exec ();

  /* If there was one, it's gone now.  We cannot truly step-to-next
     statement through an exec().  */
  th->control.step_resume_breakpoint = NULL;
  th->control.exception_resume_breakpoint = NULL;
  th->control.step_range_start = 0;
  th->control.step_range_end = 0;

  /* The target reports the exec event to the main thread, even if
     some other thread does the exec, and even if the main thread was
     already stopped --- if debugging in non-stop mode, it's possible
     the user had the main thread held stopped in the previous image
     --- release it now.  This is the same behavior as step-over-exec
     with scheduler-locking on in all-stop mode.  */
  th->stop_requested = 0;

  /* What is this a.out's name?  */
  printf_unfiltered (_("%s is executing new program: %s\n"),
		     target_pid_to_str (inferior_ptid),
		     execd_pathname);

  /* We've followed the inferior through an exec.  Therefore, the
     inferior has essentially been killed & reborn.  */

  gdb_flush (gdb_stdout);

  breakpoint_init_inferior (inf_execd);

  if (gdb_sysroot && *gdb_sysroot)
    {
      char *name = alloca (strlen (gdb_sysroot)
			    + strlen (execd_pathname)
			    + 1);

      strcpy (name, gdb_sysroot);
      strcat (name, execd_pathname);
      execd_pathname = name;
    }

  /* Reset the shared library package.  This ensures that we get a
     shlib event when the child reaches "_start", at which point the
     dld will have had a chance to initialize the child.  */
  /* Also, loading a symbol file below may trigger symbol lookups, and
     we don't want those to be satisfied by the libraries of the
     previous incarnation of this process.  */
  no_shared_libraries (NULL, 0);

  if (follow_exec_mode_string == follow_exec_mode_new)
    {
      struct program_space *pspace;

      /* The user wants to keep the old inferior and program spaces
	 around.  Create a new fresh one, and switch to it.  */

      inf = add_inferior (current_inferior ()->pid);
      pspace = add_program_space (maybe_new_address_space ());
      inf->pspace = pspace;
      inf->aspace = pspace->aspace;

      exit_inferior_num_silent (current_inferior ()->num);

      set_current_inferior (inf);
      set_current_program_space (pspace);
    }
  else
    {
      /* The old description may no longer be fit for the new image.
	 E.g, a 64-bit process exec'ed a 32-bit process.  Clear the
	 old description; we'll read a new one below.  No need to do
	 this on "follow-exec-mode new", as the old inferior stays
	 around (its description is later cleared/refetched on
	 restart).  */
      target_clear_description ();
    }

  gdb_assert (current_program_space == inf->pspace);

  /* That a.out is now the one to use.  */
  exec_file_attach (execd_pathname, 0);

  /* SYMFILE_DEFER_BP_RESET is used as the proper displacement for PIE
     (Position Independent Executable) main symbol file will get applied by
     solib_create_inferior_hook below.  breakpoint_re_set would fail to insert
     the breakpoints with the zero displacement.  */

  symbol_file_add (execd_pathname,
		   (inf->symfile_flags
		    | SYMFILE_MAINLINE | SYMFILE_DEFER_BP_RESET),
		   NULL, 0);

  if ((inf->symfile_flags & SYMFILE_NO_READ) == 0)
    set_initial_language ();

  /* If the target can specify a description, read it.  Must do this
     after flipping to the new executable (because the target supplied
     description must be compatible with the executable's
     architecture, and the old executable may e.g., be 32-bit, while
     the new one 64-bit), and before anything involving memory or
     registers.  */
  target_find_description ();

  solib_create_inferior_hook (0);

  jit_inferior_created_hook ();

  breakpoint_re_set ();

  /* Reinsert all breakpoints.  (Those which were symbolic have
     been reset to the proper address in the new a.out, thanks
     to symbol_file_command...).  */
  insert_breakpoints ();

  /* The next resume of this inferior should bring it to the shlib
     startup breakpoints.  (If the user had also set bp's on
     "main" from the old (parent) process, then they'll auto-
     matically get reset there in the new process.).  */
}

/* Non-zero if we just simulating a single-step.  This is needed
   because we cannot remove the breakpoints in the inferior process
   until after the `wait' in `wait_for_inferior'.  */
static int singlestep_breakpoints_inserted_p = 0;

/* The thread we inserted single-step breakpoints for.  */
static ptid_t singlestep_ptid;

/* PC when we started this single-step.  */
static CORE_ADDR singlestep_pc;

/* If another thread hit the singlestep breakpoint, we save the original
   thread here so that we can resume single-stepping it later.  */
static ptid_t saved_singlestep_ptid;
static int stepping_past_singlestep_breakpoint;

/* If not equal to null_ptid, this means that after stepping over breakpoint
   is finished, we need to switch to deferred_step_ptid, and step it.

   The use case is when one thread has hit a breakpoint, and then the user 
   has switched to another thread and issued 'step'.  We need to step over
   breakpoint in the thread which hit the breakpoint, but then continue
   stepping the thread user has selected.  */
static ptid_t deferred_step_ptid;

/* Displaced stepping.  */

/* In non-stop debugging mode, we must take special care to manage
   breakpoints properly; in particular, the traditional strategy for
   stepping a thread past a breakpoint it has hit is unsuitable.
   'Displaced stepping' is a tactic for stepping one thread past a
   breakpoint it has hit while ensuring that other threads running
   concurrently will hit the breakpoint as they should.

   The traditional way to step a thread T off a breakpoint in a
   multi-threaded program in all-stop mode is as follows:

   a0) Initially, all threads are stopped, and breakpoints are not
       inserted.
   a1) We single-step T, leaving breakpoints uninserted.
   a2) We insert breakpoints, and resume all threads.

   In non-stop debugging, however, this strategy is unsuitable: we
   don't want to have to stop all threads in the system in order to
   continue or step T past a breakpoint.  Instead, we use displaced
   stepping:

   n0) Initially, T is stopped, other threads are running, and
       breakpoints are inserted.
   n1) We copy the instruction "under" the breakpoint to a separate
       location, outside the main code stream, making any adjustments
       to the instruction, register, and memory state as directed by
       T's architecture.
   n2) We single-step T over the instruction at its new location.
   n3) We adjust the resulting register and memory state as directed
       by T's architecture.  This includes resetting T's PC to point
       back into the main instruction stream.
   n4) We resume T.

   This approach depends on the following gdbarch methods:

   - gdbarch_max_insn_length and gdbarch_displaced_step_location
     indicate where to copy the instruction, and how much space must
     be reserved there.  We use these in step n1.

   - gdbarch_displaced_step_copy_insn copies a instruction to a new
     address, and makes any necessary adjustments to the instruction,
     register contents, and memory.  We use this in step n1.

   - gdbarch_displaced_step_fixup adjusts registers and memory after
     we have successfuly single-stepped the instruction, to yield the
     same effect the instruction would have had if we had executed it
     at its original address.  We use this in step n3.

   - gdbarch_displaced_step_free_closure provides cleanup.

   The gdbarch_displaced_step_copy_insn and
   gdbarch_displaced_step_fixup functions must be written so that
   copying an instruction with gdbarch_displaced_step_copy_insn,
   single-stepping across the copied instruction, and then applying
   gdbarch_displaced_insn_fixup should have the same effects on the
   thread's memory and registers as stepping the instruction in place
   would have.  Exactly which responsibilities fall to the copy and
   which fall to the fixup is up to the author of those functions.

   See the comments in gdbarch.sh for details.

   Note that displaced stepping and software single-step cannot
   currently be used in combination, although with some care I think
   they could be made to.  Software single-step works by placing
   breakpoints on all possible subsequent instructions; if the
   displaced instruction is a PC-relative jump, those breakpoints
   could fall in very strange places --- on pages that aren't
   executable, or at addresses that are not proper instruction
   boundaries.  (We do generally let other threads run while we wait
   to hit the software single-step breakpoint, and they might
   encounter such a corrupted instruction.)  One way to work around
   this would be to have gdbarch_displaced_step_copy_insn fully
   simulate the effect of PC-relative instructions (and return NULL)
   on architectures that use software single-stepping.

   In non-stop mode, we can have independent and simultaneous step
   requests, so more than one thread may need to simultaneously step
   over a breakpoint.  The current implementation assumes there is
   only one scratch space per process.  In this case, we have to
   serialize access to the scratch space.  If thread A wants to step
   over a breakpoint, but we are currently waiting for some other
   thread to complete a displaced step, we leave thread A stopped and
   place it in the displaced_step_request_queue.  Whenever a displaced
   step finishes, we pick the next thread in the queue and start a new
   displaced step operation on it.  See displaced_step_prepare and
   displaced_step_fixup for details.  */

struct displaced_step_request
{
  ptid_t ptid;
  struct displaced_step_request *next;
};

/* Per-inferior displaced stepping state.  */
struct displaced_step_inferior_state
{
  /* Pointer to next in linked list.  */
  struct displaced_step_inferior_state *next;

  /* The process this displaced step state refers to.  */
  int pid;

  /* A queue of pending displaced stepping requests.  One entry per
     thread that needs to do a displaced step.  */
  struct displaced_step_request *step_request_queue;

  /* If this is not null_ptid, this is the thread carrying out a
     displaced single-step in process PID.  This thread's state will
     require fixing up once it has completed its step.  */
  ptid_t step_ptid;

  /* The architecture the thread had when we stepped it.  */
  struct gdbarch *step_gdbarch;

  /* The closure provided gdbarch_displaced_step_copy_insn, to be used
     for post-step cleanup.  */
  struct displaced_step_closure *step_closure;

  /* The address of the original instruction, and the copy we
     made.  */
  CORE_ADDR step_original, step_copy;

  /* Saved contents of copy area.  */
  gdb_byte *step_saved_copy;
};

/* The list of states of processes involved in displaced stepping
   presently.  */
static struct displaced_step_inferior_state *displaced_step_inferior_states;

/* Get the displaced stepping state of process PID.  */

static struct displaced_step_inferior_state *
get_displaced_stepping_state (int pid)
{
  struct displaced_step_inferior_state *state;

  for (state = displaced_step_inferior_states;
       state != NULL;
       state = state->next)
    if (state->pid == pid)
      return state;

  return NULL;
}

/* Add a new displaced stepping state for process PID to the displaced
   stepping state list, or return a pointer to an already existing
   entry, if it already exists.  Never returns NULL.  */

static struct displaced_step_inferior_state *
add_displaced_stepping_state (int pid)
{
  struct displaced_step_inferior_state *state;

  for (state = displaced_step_inferior_states;
       state != NULL;
       state = state->next)
    if (state->pid == pid)
      return state;

  state = xcalloc (1, sizeof (*state));
  state->pid = pid;
  state->next = displaced_step_inferior_states;
  displaced_step_inferior_states = state;

  return state;
}

/* If inferior is in displaced stepping, and ADDR equals to starting address
   of copy area, return corresponding displaced_step_closure.  Otherwise,
   return NULL.  */

struct displaced_step_closure*
get_displaced_step_closure_by_addr (CORE_ADDR addr)
{
  struct displaced_step_inferior_state *displaced
    = get_displaced_stepping_state (ptid_get_pid (inferior_ptid));

  /* If checking the mode of displaced instruction in copy area.  */
  if (displaced && !ptid_equal (displaced->step_ptid, null_ptid)
     && (displaced->step_copy == addr))
    return displaced->step_closure;

  return NULL;
}

/* Remove the displaced stepping state of process PID.  */

static void
remove_displaced_stepping_state (int pid)
{
  struct displaced_step_inferior_state *it, **prev_next_p;

  gdb_assert (pid != 0);

  it = displaced_step_inferior_states;
  prev_next_p = &displaced_step_inferior_states;
  while (it)
    {
      if (it->pid == pid)
	{
	  *prev_next_p = it->next;
	  xfree (it);
	  return;
	}

      prev_next_p = &it->next;
      it = *prev_next_p;
    }
}

static void
infrun_inferior_exit (struct inferior *inf)
{
  remove_displaced_stepping_state (inf->pid);
}

/* If ON, and the architecture supports it, GDB will use displaced
   stepping to step over breakpoints.  If OFF, or if the architecture
   doesn't support it, GDB will instead use the traditional
   hold-and-step approach.  If AUTO (which is the default), GDB will
   decide which technique to use to step over breakpoints depending on
   which of all-stop or non-stop mode is active --- displaced stepping
   in non-stop mode; hold-and-step in all-stop mode.  */

static enum auto_boolean can_use_displaced_stepping = AUTO_BOOLEAN_AUTO;

static void
show_can_use_displaced_stepping (struct ui_file *file, int from_tty,
				 struct cmd_list_element *c,
				 const char *value)
{
  if (can_use_displaced_stepping == AUTO_BOOLEAN_AUTO)
    fprintf_filtered (file,
		      _("Debugger's willingness to use displaced stepping "
			"to step over breakpoints is %s (currently %s).\n"),
		      value, non_stop ? "on" : "off");
  else
    fprintf_filtered (file,
		      _("Debugger's willingness to use displaced stepping "
			"to step over breakpoints is %s.\n"), value);
}

/* Return non-zero if displaced stepping can/should be used to step
   over breakpoints.  */

static int
use_displaced_stepping (struct gdbarch *gdbarch)
{
  return (((can_use_displaced_stepping == AUTO_BOOLEAN_AUTO && non_stop)
	   || can_use_displaced_stepping == AUTO_BOOLEAN_TRUE)
	  && gdbarch_displaced_step_copy_insn_p (gdbarch)
	  && !RECORD_IS_USED);
}

/* Clean out any stray displaced stepping state.  */
static void
displaced_step_clear (struct displaced_step_inferior_state *displaced)
{
  /* Indicate that there is no cleanup pending.  */
  displaced->step_ptid = null_ptid;

  if (displaced->step_closure)
    {
      gdbarch_displaced_step_free_closure (displaced->step_gdbarch,
                                           displaced->step_closure);
      displaced->step_closure = NULL;
    }
}

static void
displaced_step_clear_cleanup (void *arg)
{
  struct displaced_step_inferior_state *state = arg;

  displaced_step_clear (state);
}

/* Dump LEN bytes at BUF in hex to FILE, followed by a newline.  */
void
displaced_step_dump_bytes (struct ui_file *file,
                           const gdb_byte *buf,
                           size_t len)
{
  int i;

  for (i = 0; i < len; i++)
    fprintf_unfiltered (file, "%02x ", buf[i]);
  fputs_unfiltered ("\n", file);
}

/* Prepare to single-step, using displaced stepping.

   Note that we cannot use displaced stepping when we have a signal to
   deliver.  If we have a signal to deliver and an instruction to step
   over, then after the step, there will be no indication from the
   target whether the thread entered a signal handler or ignored the
   signal and stepped over the instruction successfully --- both cases
   result in a simple SIGTRAP.  In the first case we mustn't do a
   fixup, and in the second case we must --- but we can't tell which.
   Comments in the code for 'random signals' in handle_inferior_event
   explain how we handle this case instead.

   Returns 1 if preparing was successful -- this thread is going to be
   stepped now; or 0 if displaced stepping this thread got queued.  */
static int
displaced_step_prepare (ptid_t ptid)
{
  struct cleanup *old_cleanups, *ignore_cleanups;
  struct thread_info *tp = find_thread_ptid (ptid);
  struct regcache *regcache = get_thread_regcache (ptid);
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  CORE_ADDR original, copy;
  ULONGEST len;
  struct displaced_step_closure *closure;
  struct displaced_step_inferior_state *displaced;
  int status;

  /* We should never reach this function if the architecture does not
     support displaced stepping.  */
  gdb_assert (gdbarch_displaced_step_copy_insn_p (gdbarch));

  /* Disable range stepping while executing in the scratch pad.  We
     want a single-step even if executing the displaced instruction in
     the scratch buffer lands within the stepping range (e.g., a
     jump/branch).  */
  tp->control.may_range_step = 0;

  /* We have to displaced step one thread at a time, as we only have
     access to a single scratch space per inferior.  */

  displaced = add_displaced_stepping_state (ptid_get_pid (ptid));

  if (!ptid_equal (displaced->step_ptid, null_ptid))
    {
      /* Already waiting for a displaced step to finish.  Defer this
	 request and place in queue.  */
      struct displaced_step_request *req, *new_req;

      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog,
			    "displaced: defering step of %s\n",
			    target_pid_to_str (ptid));

      new_req = xmalloc (sizeof (*new_req));
      new_req->ptid = ptid;
      new_req->next = NULL;

      if (displaced->step_request_queue)
	{
	  for (req = displaced->step_request_queue;
	       req && req->next;
	       req = req->next)
	    ;
	  req->next = new_req;
	}
      else
	displaced->step_request_queue = new_req;

      return 0;
    }
  else
    {
      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog,
			    "displaced: stepping %s now\n",
			    target_pid_to_str (ptid));
    }

  displaced_step_clear (displaced);

  old_cleanups = save_inferior_ptid ();
  inferior_ptid = ptid;

  original = regcache_read_pc (regcache);

  copy = gdbarch_displaced_step_location (gdbarch);
  len = gdbarch_max_insn_length (gdbarch);

  /* Save the original contents of the copy area.  */
  displaced->step_saved_copy = xmalloc (len);
  ignore_cleanups = make_cleanup (free_current_contents,
				  &displaced->step_saved_copy);
  status = target_read_memory (copy, displaced->step_saved_copy, len);
  if (status != 0)
    throw_error (MEMORY_ERROR,
		 _("Error accessing memory address %s (%s) for "
		   "displaced-stepping scratch space."),
		 paddress (gdbarch, copy), safe_strerror (status));
  if (debug_displaced)
    {
      fprintf_unfiltered (gdb_stdlog, "displaced: saved %s: ",
			  paddress (gdbarch, copy));
      displaced_step_dump_bytes (gdb_stdlog,
				 displaced->step_saved_copy,
				 len);
    };

  closure = gdbarch_displaced_step_copy_insn (gdbarch,
					      original, copy, regcache);

  /* We don't support the fully-simulated case at present.  */
  gdb_assert (closure);

  /* Save the information we need to fix things up if the step
     succeeds.  */
  displaced->step_ptid = ptid;
  displaced->step_gdbarch = gdbarch;
  displaced->step_closure = closure;
  displaced->step_original = original;
  displaced->step_copy = copy;

  make_cleanup (displaced_step_clear_cleanup, displaced);

  /* Resume execution at the copy.  */
  regcache_write_pc (regcache, copy);

  discard_cleanups (ignore_cleanups);

  do_cleanups (old_cleanups);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: displaced pc to %s\n",
			paddress (gdbarch, copy));

  return 1;
}

static void
write_memory_ptid (ptid_t ptid, CORE_ADDR memaddr,
		   const gdb_byte *myaddr, int len)
{
  struct cleanup *ptid_cleanup = save_inferior_ptid ();

  inferior_ptid = ptid;
  write_memory (memaddr, myaddr, len);
  do_cleanups (ptid_cleanup);
}

/* Restore the contents of the copy area for thread PTID.  */

static void
displaced_step_restore (struct displaced_step_inferior_state *displaced,
			ptid_t ptid)
{
  ULONGEST len = gdbarch_max_insn_length (displaced->step_gdbarch);

  write_memory_ptid (ptid, displaced->step_copy,
		     displaced->step_saved_copy, len);
  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: restored %s %s\n",
			target_pid_to_str (ptid),
			paddress (displaced->step_gdbarch,
				  displaced->step_copy));
}

static void
displaced_step_fixup (ptid_t event_ptid, enum gdb_signal signal)
{
  struct cleanup *old_cleanups;
  struct displaced_step_inferior_state *displaced
    = get_displaced_stepping_state (ptid_get_pid (event_ptid));

  /* Was any thread of this process doing a displaced step?  */
  if (displaced == NULL)
    return;

  /* Was this event for the pid we displaced?  */
  if (ptid_equal (displaced->step_ptid, null_ptid)
      || ! ptid_equal (displaced->step_ptid, event_ptid))
    return;

  old_cleanups = make_cleanup (displaced_step_clear_cleanup, displaced);

  displaced_step_restore (displaced, displaced->step_ptid);

  /* Did the instruction complete successfully?  */
  if (signal == GDB_SIGNAL_TRAP)
    {
      /* Fix up the resulting state.  */
      gdbarch_displaced_step_fixup (displaced->step_gdbarch,
                                    displaced->step_closure,
                                    displaced->step_original,
                                    displaced->step_copy,
                                    get_thread_regcache (displaced->step_ptid));
    }
  else
    {
      /* Since the instruction didn't complete, all we can do is
         relocate the PC.  */
      struct regcache *regcache = get_thread_regcache (event_ptid);
      CORE_ADDR pc = regcache_read_pc (regcache);

      pc = displaced->step_original + (pc - displaced->step_copy);
      regcache_write_pc (regcache, pc);
    }

  do_cleanups (old_cleanups);

  displaced->step_ptid = null_ptid;

  /* Are there any pending displaced stepping requests?  If so, run
     one now.  Leave the state object around, since we're likely to
     need it again soon.  */
  while (displaced->step_request_queue)
    {
      struct displaced_step_request *head;
      ptid_t ptid;
      struct regcache *regcache;
      struct gdbarch *gdbarch;
      CORE_ADDR actual_pc;
      struct address_space *aspace;

      head = displaced->step_request_queue;
      ptid = head->ptid;
      displaced->step_request_queue = head->next;
      xfree (head);

      context_switch (ptid);

      regcache = get_thread_regcache (ptid);
      actual_pc = regcache_read_pc (regcache);
      aspace = get_regcache_aspace (regcache);

      if (breakpoint_here_p (aspace, actual_pc))
	{
	  if (debug_displaced)
	    fprintf_unfiltered (gdb_stdlog,
				"displaced: stepping queued %s now\n",
				target_pid_to_str (ptid));

	  displaced_step_prepare (ptid);

	  gdbarch = get_regcache_arch (regcache);

	  if (debug_displaced)
	    {
	      CORE_ADDR actual_pc = regcache_read_pc (regcache);
	      gdb_byte buf[4];

	      fprintf_unfiltered (gdb_stdlog, "displaced: run %s: ",
				  paddress (gdbarch, actual_pc));
	      read_memory (actual_pc, buf, sizeof (buf));
	      displaced_step_dump_bytes (gdb_stdlog, buf, sizeof (buf));
	    }

	  if (gdbarch_displaced_step_hw_singlestep (gdbarch,
						    displaced->step_closure))
	    target_resume (ptid, 1, GDB_SIGNAL_0);
	  else
	    target_resume (ptid, 0, GDB_SIGNAL_0);

	  /* Done, we're stepping a thread.  */
	  break;
	}
      else
	{
	  int step;
	  struct thread_info *tp = inferior_thread ();

	  /* The breakpoint we were sitting under has since been
	     removed.  */
	  tp->control.trap_expected = 0;

	  /* Go back to what we were trying to do.  */
	  step = currently_stepping (tp);

	  if (debug_displaced)
	    fprintf_unfiltered (gdb_stdlog,
				"displaced: breakpoint is gone: %s, step(%d)\n",
				target_pid_to_str (tp->ptid), step);

	  target_resume (ptid, step, GDB_SIGNAL_0);
	  tp->suspend.stop_signal = GDB_SIGNAL_0;

	  /* This request was discarded.  See if there's any other
	     thread waiting for its turn.  */
	}
    }
}

/* Update global variables holding ptids to hold NEW_PTID if they were
   holding OLD_PTID.  */
static void
infrun_thread_ptid_changed (ptid_t old_ptid, ptid_t new_ptid)
{
  struct displaced_step_request *it;
  struct displaced_step_inferior_state *displaced;

  if (ptid_equal (inferior_ptid, old_ptid))
    inferior_ptid = new_ptid;

  if (ptid_equal (singlestep_ptid, old_ptid))
    singlestep_ptid = new_ptid;

  if (ptid_equal (deferred_step_ptid, old_ptid))
    deferred_step_ptid = new_ptid;

  for (displaced = displaced_step_inferior_states;
       displaced;
       displaced = displaced->next)
    {
      if (ptid_equal (displaced->step_ptid, old_ptid))
	displaced->step_ptid = new_ptid;

      for (it = displaced->step_request_queue; it; it = it->next)
	if (ptid_equal (it->ptid, old_ptid))
	  it->ptid = new_ptid;
    }
}


/* Resuming.  */

/* Things to clean up if we QUIT out of resume ().  */
static void
resume_cleanups (void *ignore)
{
  normal_stop ();
}

static const char schedlock_off[] = "off";
static const char schedlock_on[] = "on";
static const char schedlock_step[] = "step";
static const char *const scheduler_enums[] = {
  schedlock_off,
  schedlock_on,
  schedlock_step,
  NULL
};
static const char *scheduler_mode = schedlock_off;
static void
show_scheduler_mode (struct ui_file *file, int from_tty,
		     struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file,
		    _("Mode for locking scheduler "
		      "during execution is \"%s\".\n"),
		    value);
}

static void
set_schedlock_func (char *args, int from_tty, struct cmd_list_element *c)
{
  if (!target_can_lock_scheduler)
    {
      scheduler_mode = schedlock_off;
      error (_("Target '%s' cannot support this command."), target_shortname);
    }
}

/* True if execution commands resume all threads of all processes by
   default; otherwise, resume only threads of the current inferior
   process.  */
int sched_multi = 0;

/* Try to setup for software single stepping over the specified location.
   Return 1 if target_resume() should use hardware single step.

   GDBARCH the current gdbarch.
   PC the location to step over.  */

static int
maybe_software_singlestep (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  int hw_step = 1;

  if (execution_direction == EXEC_FORWARD
      && gdbarch_software_single_step_p (gdbarch)
      && gdbarch_software_single_step (gdbarch, get_current_frame ()))
    {
      hw_step = 0;
      /* Do not pull these breakpoints until after a `wait' in
	 `wait_for_inferior'.  */
      singlestep_breakpoints_inserted_p = 1;
      singlestep_ptid = inferior_ptid;
      singlestep_pc = pc;
    }
  return hw_step;
}

/* Return a ptid representing the set of threads that we will proceed,
   in the perspective of the user/frontend.  We may actually resume
   fewer threads at first, e.g., if a thread is stopped at a
   breakpoint that needs stepping-off, but that should not be visible
   to the user/frontend, and neither should the frontend/user be
   allowed to proceed any of the threads that happen to be stopped for
   internal run control handling, if a previous command wanted them
   resumed.  */

ptid_t
user_visible_resume_ptid (int step)
{
  /* By default, resume all threads of all processes.  */
  ptid_t resume_ptid = RESUME_ALL;

  /* Maybe resume only all threads of the current process.  */
  if (!sched_multi && target_supports_multi_process ())
    {
      resume_ptid = pid_to_ptid (ptid_get_pid (inferior_ptid));
    }

  /* Maybe resume a single thread after all.  */
  if (non_stop)
    {
      /* With non-stop mode on, threads are always handled
	 individually.  */
      resume_ptid = inferior_ptid;
    }
  else if ((scheduler_mode == schedlock_on)
	   || (scheduler_mode == schedlock_step
	       && (step || singlestep_breakpoints_inserted_p)))
    {
      /* User-settable 'scheduler' mode requires solo thread resume.  */
      resume_ptid = inferior_ptid;
    }

  return resume_ptid;
}

/* Resume the inferior, but allow a QUIT.  This is useful if the user
   wants to interrupt some lengthy single-stepping operation
   (for child processes, the SIGINT goes to the inferior, and so
   we get a SIGINT random_signal, but for remote debugging and perhaps
   other targets, that's not true).

   STEP nonzero if we should step (zero to continue instead).
   SIG is the signal to give the inferior (zero for none).  */
void
resume (int step, enum gdb_signal sig)
{
  int should_resume = 1;
  struct cleanup *old_cleanups = make_cleanup (resume_cleanups, 0);
  struct regcache *regcache = get_current_regcache ();
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct thread_info *tp = inferior_thread ();
  CORE_ADDR pc = regcache_read_pc (regcache);
  struct address_space *aspace = get_regcache_aspace (regcache);

  QUIT;

  if (current_inferior ()->waiting_for_vfork_done)
    {
      /* Don't try to single-step a vfork parent that is waiting for
	 the child to get out of the shared memory region (by exec'ing
	 or exiting).  This is particularly important on software
	 single-step archs, as the child process would trip on the
	 software single step breakpoint inserted for the parent
	 process.  Since the parent will not actually execute any
	 instruction until the child is out of the shared region (such
	 are vfork's semantics), it is safe to simply continue it.
	 Eventually, we'll see a TARGET_WAITKIND_VFORK_DONE event for
	 the parent, and tell it to `keep_going', which automatically
	 re-sets it stepping.  */
      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog,
			    "infrun: resume : clear step\n");
      step = 0;
    }

  if (debug_infrun)
    fprintf_unfiltered (gdb_stdlog,
                        "infrun: resume (step=%d, signal=%d), "
			"trap_expected=%d, current thread [%s] at %s\n",
 			step, sig, tp->control.trap_expected,
			target_pid_to_str (inferior_ptid),
			paddress (gdbarch, pc));

  /* Normally, by the time we reach `resume', the breakpoints are either
     removed or inserted, as appropriate.  The exception is if we're sitting
     at a permanent breakpoint; we need to step over it, but permanent
     breakpoints can't be removed.  So we have to test for it here.  */
  if (breakpoint_here_p (aspace, pc) == permanent_breakpoint_here)
    {
      if (gdbarch_skip_permanent_breakpoint_p (gdbarch))
	gdbarch_skip_permanent_breakpoint (gdbarch, regcache);
      else
	error (_("\
The program is stopped at a permanent breakpoint, but GDB does not know\n\
how to step past a permanent breakpoint on this architecture.  Try using\n\
a command like `return' or `jump' to continue execution."));
    }

  /* If we have a breakpoint to step over, make sure to do a single
     step only.  Same if we have software watchpoints.  */
  if (tp->control.trap_expected || bpstat_should_step ())
    tp->control.may_range_step = 0;

  /* If enabled, step over breakpoints by executing a copy of the
     instruction at a different address.

     We can't use displaced stepping when we have a signal to deliver;
     the comments for displaced_step_prepare explain why.  The
     comments in the handle_inferior event for dealing with 'random
     signals' explain what we do instead.

     We can't use displaced stepping when we are waiting for vfork_done
     event, displaced stepping breaks the vfork child similarly as single
     step software breakpoint.  */
  if (use_displaced_stepping (gdbarch)
      && (tp->control.trap_expected
	  || (step && gdbarch_software_single_step_p (gdbarch)))
      && sig == GDB_SIGNAL_0
      && !current_inferior ()->waiting_for_vfork_done)
    {
      struct displaced_step_inferior_state *displaced;

      if (!displaced_step_prepare (inferior_ptid))
	{
	  /* Got placed in displaced stepping queue.  Will be resumed
	     later when all the currently queued displaced stepping
	     requests finish.  The thread is not executing at this point,
	     and the call to set_executing will be made later.  But we
	     need to call set_running here, since from frontend point of view,
	     the thread is running.  */
	  set_running (inferior_ptid, 1);
	  discard_cleanups (old_cleanups);
	  return;
	}

      /* Update pc to reflect the new address from which we will execute
	 instructions due to displaced stepping.  */
      pc = regcache_read_pc (get_thread_regcache (inferior_ptid));

      displaced = get_displaced_stepping_state (ptid_get_pid (inferior_ptid));
      step = gdbarch_displaced_step_hw_singlestep (gdbarch,
						   displaced->step_closure);
    }

  /* Do we need to do it the hard way, w/temp breakpoints?  */
  else if (step)
    step = maybe_software_singlestep (gdbarch, pc);

  /* Currently, our software single-step implementation leads to different
     results than hardware single-stepping in one situation: when stepping
     into delivering a signal which has an associated signal handler,
     hardware single-step will stop at the first instruction of the handler,
     while software single-step will simply skip execution of the handler.

     For now, this difference in behavior is accepted since there is no
     easy way to actually implement single-stepping into a signal handler
     without kernel support.

     However, there is one scenario where this difference leads to follow-on
     problems: if we're stepping off a breakpoint by removing all breakpoints
     and then single-stepping.  In this case, the software single-step
     behavior means that even if there is a *breakpoint* in the signal
     handler, GDB still would not stop.

     Fortunately, we can at least fix this particular issue.  We detect
     here the case where we are about to deliver a signal while software
     single-stepping with breakpoints removed.  In this situation, we
     revert the decisions to remove all breakpoints and insert single-
     step breakpoints, and instead we install a step-resume breakpoint
     at the current address, deliver the signal without stepping, and
     once we arrive back at the step-resume breakpoint, actually step
     over the breakpoint we originally wanted to step over.  */
  if (singlestep_breakpoints_inserted_p
      && tp->control.trap_expected && sig != GDB_SIGNAL_0)
    {
      /* If we have nested signals or a pending signal is delivered
	 immediately after a handler returns, might might already have
	 a step-resume breakpoint set on the earlier handler.  We cannot
	 set another step-resume breakpoint; just continue on until the
	 original breakpoint is hit.  */
      if (tp->control.step_resume_breakpoint == NULL)
	{
	  insert_hp_step_resume_breakpoint_at_frame (get_current_frame ());
	  tp->step_after_step_resume_breakpoint = 1;
	}

      remove_single_step_breakpoints ();
      singlestep_breakpoints_inserted_p = 0;

      insert_breakpoints ();
      tp->control.trap_expected = 0;
    }

  if (should_resume)
    {
      ptid_t resume_ptid;

      /* If STEP is set, it's a request to use hardware stepping
	 facilities.  But in that case, we should never
	 use singlestep breakpoint.  */
      gdb_assert (!(singlestep_breakpoints_inserted_p && step));

      /* Decide the set of threads to ask the target to resume.  Start
	 by assuming everything will be resumed, than narrow the set
	 by applying increasingly restricting conditions.  */
      resume_ptid = user_visible_resume_ptid (step);

      /* Maybe resume a single thread after all.  */
      if (singlestep_breakpoints_inserted_p
	  && stepping_past_singlestep_breakpoint)
	{
	  /* The situation here is as follows.  In thread T1 we wanted to
	     single-step.  Lacking hardware single-stepping we've
	     set breakpoint at the PC of the next instruction -- call it
	     P.  After resuming, we've hit that breakpoint in thread T2.
	     Now we've removed original breakpoint, inserted breakpoint
	     at P+1, and try to step to advance T2 past breakpoint.
	     We need to step only T2, as if T1 is allowed to freely run,
	     it can run past P, and if other threads are allowed to run,
	     they can hit breakpoint at P+1, and nested hits of single-step
	     breakpoints is not something we'd want -- that's complicated
	     to support, and has no value.  */
	  resume_ptid = inferior_ptid;
	}
      else if ((step || singlestep_breakpoints_inserted_p)
	       && tp->control.trap_expected)
	{
	  /* We're allowing a thread to run past a breakpoint it has
	     hit, by single-stepping the thread with the breakpoint
	     removed.  In which case, we need to single-step only this
	     thread, and keep others stopped, as they can miss this
	     breakpoint if allowed to run.

	     The current code actually removes all breakpoints when
	     doing this, not just the one being stepped over, so if we
	     let other threads run, we can actually miss any
	     breakpoint, not just the one at PC.  */
	  resume_ptid = inferior_ptid;
	}

      if (gdbarch_cannot_step_breakpoint (gdbarch))
	{
	  /* Most targets can step a breakpoint instruction, thus
	     executing it normally.  But if this one cannot, just
	     continue and we will hit it anyway.  */
	  if (step && breakpoint_inserted_here_p (aspace, pc))
	    step = 0;
	}

      if (debug_displaced
          && use_displaced_stepping (gdbarch)
          && tp->control.trap_expected)
        {
	  struct regcache *resume_regcache = get_thread_regcache (resume_ptid);
	  struct gdbarch *resume_gdbarch = get_regcache_arch (resume_regcache);
          CORE_ADDR actual_pc = regcache_read_pc (resume_regcache);
          gdb_byte buf[4];

          fprintf_unfiltered (gdb_stdlog, "displaced: run %s: ",
                              paddress (resume_gdbarch, actual_pc));
          read_memory (actual_pc, buf, sizeof (buf));
          displaced_step_dump_bytes (gdb_stdlog, buf, sizeof (buf));
        }

      if (tp->control.may_range_step)
	{
	  /* If we're resuming a thread with the PC out of the step
	     range, then we're doing some nested/finer run control
	     operation, like stepping the thread out of the dynamic
	     linker or the displaced stepping scratch pad.  We
	     shouldn't have allowed a range step then.  */
	  gdb_assert (pc_in_thread_step_range (pc, tp));
	}

      /* Install inferior's terminal modes.  */
      target_terminal_inferior ();

      /* Avoid confusing the next resume, if the next stop/resume
	 happens to apply to another thread.  */
      tp->suspend.stop_signal = GDB_SIGNAL_0;

      /* Advise target which signals may be handled silently.  If we have
	 removed breakpoints because we are stepping over one (which can
	 happen only if we are not using displaced stepping), we need to
	 receive all signals to avoid accidentally skipping a breakpoint
	 during execution of a signal handler.  */
      if ((step || singlestep_breakpoints_inserted_p)
	  && tp->control.trap_expected
	  && !use_displaced_stepping (gdbarch))
	target_pass_signals (0, NULL);
      else
	target_pass_signals ((int) GDB_SIGNAL_LAST, signal_pass);

      target_resume (resume_ptid, step, sig);
    }

  discard_cleanups (old_cleanups);
}

/* Proceeding.  */

/* Clear out all variables saying what to do when inferior is continued.
   First do this, then set the ones you want, then call `proceed'.  */

static void
clear_proceed_status_thread (struct thread_info *tp)
{
  if (debug_infrun)
    fprintf_unfiltered (gdb_stdlog,
			"infrun: clear_proceed_status_thread (%s)\n",
			target_pid_to_str (tp->ptid));

  tp->control.trap_expected = 0;
  tp->control.step_range_start = 0;
  tp->control.step_range_end = 0;
  tp->control.may_range_step = 0;
  tp->control.step_frame_id = null_frame_id;
  tp->control.step_stack_frame_id = null_frame_id;
  tp->control.step_over_calls = STEP_OVER_UNDEBUGGABLE;
  tp->stop_requested = 0;

  tp->control.stop_step = 0;

  tp->control.proceed_to_finish = 0;

  /* Discard any remaining commands or status from previous stop.  */
  bpstat_clear (&tp->control.stop_bpstat);
}

static int
clear_proceed_status_callback (struct thread_info *tp, void *data)
{
  if (is_exited (tp->ptid))
    return 0;

  clear_proceed_status_thread (tp);
  return 0;
}

void
clear_proceed_status (void)
{
  if (!non_stop)
    {
      /* In all-stop mode, delete the per-thread status of all
	 threads, even if inferior_ptid is null_ptid, there may be
	 threads on the list.  E.g., we may be launching a new
	 process, while selecting the executable.  */
      iterate_over_threads (clear_proceed_status_callback, NULL);
    }

  if (!ptid_equal (inferior_ptid, null_ptid))
    {
      struct inferior *inferior;

      if (non_stop)
	{
	  /* If in non-stop mode, only delete the per-thread status of
	     the current thread.  */
	  clear_proceed_status_thread (inferior_thread ());
	}

      inferior = current_inferior ();
      inferior->control.stop_soon = NO_STOP_QUIETLY;
    }

  stop_after_trap = 0;

  observer_notify_about_to_proceed ();

  if (stop_registers)
    {
      regcache_xfree (stop_registers);
      stop_registers = NULL;
    }
}

/* Check the current thread against the thread that reported the most recent
   event.  If a step-over is required return TRUE and set the current thread
   to the old thread.  Otherwise return FALSE.

   This should be suitable for any targets that support threads.  */

static int
prepare_to_proceed (int step)
{
  ptid_t wait_ptid;
  struct target_waitstatus wait_status;
  int schedlock_enabled;

  /* With non-stop mode on, threads are always handled individually.  */
  gdb_assert (! non_stop);

  /* Get the last target status returned by target_wait().  */
  get_last_target_status (&wait_ptid, &wait_status);

  /* Make sure we were stopped at a breakpoint.  */
  if (wait_status.kind != TARGET_WAITKIND_STOPPED
      || (wait_status.value.sig != GDB_SIGNAL_TRAP
	  && wait_status.value.sig != GDB_SIGNAL_ILL
	  && wait_status.value.sig != GDB_SIGNAL_SEGV
	  && wait_status.value.sig != GDB_SIGNAL_EMT))
    {
      return 0;
    }

  schedlock_enabled = (scheduler_mode == schedlock_on
		       || (scheduler_mode == schedlock_step
			   && step));

  /* Don't switch over to WAIT_PTID if scheduler locking is on.  */
  if (schedlock_enabled)
    return 0;

  /* Don't switch over if we're about to resume some other process
     other than WAIT_PTID's, and schedule-multiple is off.  */
  if (!sched_multi
      && ptid_get_pid (wait_ptid) != ptid_get_pid (inferior_ptid))
    return 0;

  /* Switched over from WAIT_PID.  */
  if (!ptid_equal (wait_ptid, minus_one_ptid)
      && !ptid_equal (inferior_ptid, wait_ptid))
    {
      struct regcache *regcache = get_thread_regcache (wait_ptid);

      if (breakpoint_here_p (get_regcache_aspace (regcache),
			     regcache_read_pc (regcache)))
	{
	  /* If stepping, remember current thread to switch back to.  */
	  if (step)
	    deferred_step_ptid = inferior_ptid;

	  /* Switch back to WAIT_PID thread.  */
	  switch_to_thread (wait_ptid);

	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog,
				"infrun: prepare_to_proceed (step=%d), "
				"switched to [%s]\n",
				step, target_pid_to_str (inferior_ptid));

	  /* We return 1 to indicate that there is a breakpoint here,
	     so we need to step over it before continuing to avoid
	     hitting it straight away.  */
	  return 1;
	}
    }

  return 0;
}

/* Basic routine for continuing the program in various fashions.

   ADDR is the address to resume at, or -1 for resume where stopped.
   SIGGNAL is the signal to give it, or 0 for none,
   or -1 for act according to how it stopped.
   STEP is nonzero if should trap after one instruction.
   -1 means return after that and print nothing.
   You should probably set various step_... variables
   before calling here, if you are stepping.

   You should call clear_proceed_status before calling proceed.  */

void
proceed (CORE_ADDR addr, enum gdb_signal siggnal, int step)
{
  struct regcache *regcache;
  struct gdbarch *gdbarch;
  struct thread_info *tp;
  CORE_ADDR pc;
  struct address_space *aspace;
  /* GDB may force the inferior to step due to various reasons.  */
  int force_step = 0;

  /* If we're stopped at a fork/vfork, follow the branch set by the
     "set follow-fork-mode" command; otherwise, we'll just proceed
     resuming the current thread.  */
  if (!follow_fork ())
    {
      /* The target for some reason decided not to resume.  */
      normal_stop ();
      if (target_can_async_p ())
	inferior_event_handler (INF_EXEC_COMPLETE, NULL);
      return;
    }

  /* We'll update this if & when we switch to a new thread.  */
  previous_inferior_ptid = inferior_ptid;

  regcache = get_current_regcache ();
  gdbarch = get_regcache_arch (regcache);
  aspace = get_regcache_aspace (regcache);
  pc = regcache_read_pc (regcache);

  if (step > 0)
    step_start_function = find_pc_function (pc);
  if (step < 0)
    stop_after_trap = 1;

  if (addr == (CORE_ADDR) -1)
    {
      if (pc == stop_pc && breakpoint_here_p (aspace, pc)
	  && execution_direction != EXEC_REVERSE)
	/* There is a breakpoint at the address we will resume at,
	   step one instruction before inserting breakpoints so that
	   we do not stop right away (and report a second hit at this
	   breakpoint).

	   Note, we don't do this in reverse, because we won't
	   actually be executing the breakpoint insn anyway.
	   We'll be (un-)executing the previous instruction.  */

	force_step = 1;
      else if (gdbarch_single_step_through_delay_p (gdbarch)
	       && gdbarch_single_step_through_delay (gdbarch,
						     get_current_frame ()))
	/* We stepped onto an instruction that needs to be stepped
	   again before re-inserting the breakpoint, do so.  */
	force_step = 1;
    }
  else
    {
      regcache_write_pc (regcache, addr);
    }

  if (debug_infrun)
    fprintf_unfiltered (gdb_stdlog,
			"infrun: proceed (addr=%s, signal=%d, step=%d)\n",
			paddress (gdbarch, addr), siggnal, step);

  if (non_stop)
    /* In non-stop, each thread is handled individually.  The context
       must already be set to the right thread here.  */
    ;
  else
    {
      /* In a multi-threaded task we may select another thread and
	 then continue or step.

	 But if the old thread was stopped at a breakpoint, it will
	 immediately cause another breakpoint stop without any
	 execution (i.e. it will report a breakpoint hit incorrectly).
	 So we must step over it first.

	 prepare_to_proceed checks the current thread against the
	 thread that reported the most recent event.  If a step-over
	 is required it returns TRUE and sets the current thread to
	 the old thread.  */
      if (prepare_to_proceed (step))
	force_step = 1;
    }

  /* prepare_to_proceed may change the current thread.  */
  tp = inferior_thread ();

  if (force_step)
    {
      tp->control.trap_expected = 1;
      /* If displaced stepping is enabled, we can step over the
	 breakpoint without hitting it, so leave all breakpoints
	 inserted.  Otherwise we need to disable all breakpoints, step
	 one instruction, and then re-add them when that step is
	 finished.  */
      if (!use_displaced_stepping (gdbarch))
	remove_breakpoints ();
    }

  /* We can insert breakpoints if we're not trying to step over one,
     or if we are stepping over one but we're using displaced stepping
     to do so.  */
  if (! tp->control.trap_expected || use_displaced_stepping (gdbarch))
    insert_breakpoints ();

  if (!non_stop)
    {
      /* Pass the last stop signal to the thread we're resuming,
	 irrespective of whether the current thread is the thread that
	 got the last event or not.  This was historically GDB's
	 behaviour before keeping a stop_signal per thread.  */

      struct thread_info *last_thread;
      ptid_t last_ptid;
      struct target_waitstatus last_status;

      get_last_target_status (&last_ptid, &last_status);
      if (!ptid_equal (inferior_ptid, last_ptid)
	  && !ptid_equal (last_ptid, null_ptid)
	  && !ptid_equal (last_ptid, minus_one_ptid))
	{
	  last_thread = find_thread_ptid (last_ptid);
	  if (last_thread)
	    {
	      tp->suspend.stop_signal = last_thread->suspend.stop_signal;
	      last_thread->suspend.stop_signal = GDB_SIGNAL_0;
	    }
	}
    }

  if (siggnal != GDB_SIGNAL_DEFAULT)
    tp->suspend.stop_signal = siggnal;
  /* If this signal should not be seen by program,
     give it zero.  Used for debugging signals.  */
  else if (!signal_program[tp->suspend.stop_signal])
    tp->suspend.stop_signal = GDB_SIGNAL_0;

  annotate_starting ();

  /* Make sure that output from GDB appears before output from the
     inferior.  */
  gdb_flush (gdb_stdout);

  /* Refresh prev_pc value just prior to resuming.  This used to be
     done in stop_stepping, however, setting prev_pc there did not handle
     scenarios such as inferior function calls or returning from
     a function via the return command.  In those cases, the prev_pc
     value was not set properly for subsequent commands.  The prev_pc value 
     is used to initialize the starting line number in the ecs.  With an 
     invalid value, the gdb next command ends up stopping at the position
     represented by the next line table entry past our start position.
     On platforms that generate one line table entry per line, this
     is not a problem.  However, on the ia64, the compiler generates
     extraneous line table entries that do not increase the line number.
     When we issue the gdb next command on the ia64 after an inferior call
     or a return command, we often end up a few instructions forward, still 
     within the original line we started.

     An attempt was made to refresh the prev_pc at the same time the
     execution_control_state is initialized (for instance, just before
     waiting for an inferior event).  But this approach did not work
     because of platforms that use ptrace, where the pc register cannot
     be read unless the inferior is stopped.  At that point, we are not
     guaranteed the inferior is stopped and so the regcache_read_pc() call
     can fail.  Setting the prev_pc value here ensures the value is updated
     correctly when the inferior is stopped.  */
  tp->prev_pc = regcache_read_pc (get_current_regcache ());

  /* Fill in with reasonable starting values.  */
  init_thread_stepping_state (tp);

  /* Reset to normal state.  */
  init_infwait_state ();

  /* Resume inferior.  */
  resume (force_step || step || bpstat_should_step (),
	  tp->suspend.stop_signal);

  /* Wait for it to stop (if not standalone)
     and in any case decode why it stopped, and act accordingly.  */
  /* Do this only if we are not using the event loop, or if the target
     does not support asynchronous execution.  */
  if (!target_can_async_p ())
    {
      wait_for_inferior ();
      normal_stop ();
    }
}


/* Start remote-debugging of a machine over a serial link.  */

void
start_remote (int from_tty)
{
  struct inferior *inferior;

  inferior = current_inferior ();
  inferior->control.stop_soon = STOP_QUIETLY_REMOTE;

  /* Always go on waiting for the target, regardless of the mode.  */
  /* FIXME: cagney/1999-09-23: At present it isn't possible to
     indicate to wait_for_inferior that a target should timeout if
     nothing is returned (instead of just blocking).  Because of this,
     targets expecting an immediate response need to, internally, set
     things up so that the target_wait() is forced to eventually
     timeout.  */
  /* FIXME: cagney/1999-09-24: It isn't possible for target_open() to
     differentiate to its caller what the state of the target is after
     the initial open has been performed.  Here we're assuming that
     the target has stopped.  It should be possible to eventually have
     target_open() return to the caller an indication that the target
     is currently running and GDB state should be set to the same as
     for an async run.  */
  wait_for_inferior ();

  /* Now that the inferior has stopped, do any bookkeeping like
     loading shared libraries.  We want to do this before normal_stop,
     so that the displayed frame is up to date.  */
  post_create_inferior (&current_target, from_tty);

  normal_stop ();
}

/* Initialize static vars when a new inferior begins.  */

void
init_wait_for_inferior (void)
{
  /* These are meaningless until the first time through wait_for_inferior.  */

  breakpoint_init_inferior (inf_starting);

  clear_proceed_status ();

  stepping_past_singlestep_breakpoint = 0;
  deferred_step_ptid = null_ptid;

  target_last_wait_ptid = minus_one_ptid;

  previous_inferior_ptid = inferior_ptid;
  init_infwait_state ();

  /* Discard any skipped inlined frames.  */
  clear_inline_frame_state (minus_one_ptid);
}


/* This enum encodes possible reasons for doing a target_wait, so that
   wfi can call target_wait in one place.  (Ultimately the call will be
   moved out of the infinite loop entirely.) */

enum infwait_states
{
  infwait_normal_state,
  infwait_thread_hop_state,
  infwait_step_watch_state,
  infwait_nonstep_watch_state
};

/* The PTID we'll do a target_wait on.*/
ptid_t waiton_ptid;

/* Current inferior wait state.  */
static enum infwait_states infwait_state;

/* Data to be passed around while handling an event.  This data is
   discarded between events.  */
struct execution_control_state
{
  ptid_t ptid;
  /* The thread that got the event, if this was a thread event; NULL
     otherwise.  */
  struct thread_info *event_thread;

  struct target_waitstatus ws;
  int random_signal;
  int stop_func_filled_in;
  CORE_ADDR stop_func_start;
  CORE_ADDR stop_func_end;
  const char *stop_func_name;
  int wait_some_more;
};

static void handle_inferior_event (struct execution_control_state *ecs);

static void handle_step_into_function (struct gdbarch *gdbarch,
				       struct execution_control_state *ecs);
static void handle_step_into_function_backward (struct gdbarch *gdbarch,
						struct execution_control_state *ecs);
static void check_exception_resume (struct execution_control_state *,
				    struct frame_info *);

static void stop_stepping (struct execution_control_state *ecs);
static void prepare_to_wait (struct execution_control_state *ecs);
static void keep_going (struct execution_control_state *ecs);

/* Callback for iterate over threads.  If the thread is stopped, but
   the user/frontend doesn't know about that yet, go through
   normal_stop, as if the thread had just stopped now.  ARG points at
   a ptid.  If PTID is MINUS_ONE_PTID, applies to all threads.  If
   ptid_is_pid(PTID) is true, applies to all threads of the process
   pointed at by PTID.  Otherwise, apply only to the thread pointed by
   PTID.  */

static int
infrun_thread_stop_requested_callback (struct thread_info *info, void *arg)
{
  ptid_t ptid = * (ptid_t *) arg;

  if ((ptid_equal (info->ptid, ptid)
       || ptid_equal (minus_one_ptid, ptid)
       || (ptid_is_pid (ptid)
	   && ptid_get_pid (ptid) == ptid_get_pid (info->ptid)))
      && is_running (info->ptid)
      && !is_executing (info->ptid))
    {
      struct cleanup *old_chain;
      struct execution_control_state ecss;
      struct execution_control_state *ecs = &ecss;

      memset (ecs, 0, sizeof (*ecs));

      old_chain = make_cleanup_restore_current_thread ();

      /* Go through handle_inferior_event/normal_stop, so we always
	 have consistent output as if the stop event had been
	 reported.  */
      ecs->ptid = info->ptid;
      ecs->event_thread = find_thread_ptid (info->ptid);
      ecs->ws.kind = TARGET_WAITKIND_STOPPED;
      ecs->ws.value.sig = GDB_SIGNAL_0;

      handle_inferior_event (ecs);

      if (!ecs->wait_some_more)
	{
	  struct thread_info *tp;

	  normal_stop ();

	  /* Finish off the continuations.  */
	  tp = inferior_thread ();
	  do_all_intermediate_continuations_thread (tp, 1);
	  do_all_continuations_thread (tp, 1);
	}

      do_cleanups (old_chain);
    }

  return 0;
}

/* This function is attached as a "thread_stop_requested" observer.
   Cleanup local state that assumed the PTID was to be resumed, and
   report the stop to the frontend.  */

static void
infrun_thread_stop_requested (ptid_t ptid)
{
  struct displaced_step_inferior_state *displaced;

  /* PTID was requested to stop.  Remove it from the displaced
     stepping queue, so we don't try to resume it automatically.  */

  for (displaced = displaced_step_inferior_states;
       displaced;
       displaced = displaced->next)
    {
      struct displaced_step_request *it, **prev_next_p;

      it = displaced->step_request_queue;
      prev_next_p = &displaced->step_request_queue;
      while (it)
	{
	  if (ptid_match (it->ptid, ptid))
	    {
	      *prev_next_p = it->next;
	      it->next = NULL;
	      xfree (it);
	    }
	  else
	    {
	      prev_next_p = &it->next;
	    }

	  it = *prev_next_p;
	}
    }

  iterate_over_threads (infrun_thread_stop_requested_callback, &ptid);
}

static void
infrun_thread_thread_exit (struct thread_info *tp, int silent)
{
  if (ptid_equal (target_last_wait_ptid, tp->ptid))
    nullify_last_target_wait_ptid ();
}

/* Callback for iterate_over_threads.  */

static int
delete_step_resume_breakpoint_callback (struct thread_info *info, void *data)
{
  if (is_exited (info->ptid))
    return 0;

  delete_step_resume_breakpoint (info);
  delete_exception_resume_breakpoint (info);
  return 0;
}

/* In all-stop, delete the step resume breakpoint of any thread that
   had one.  In non-stop, delete the step resume breakpoint of the
   thread that just stopped.  */

static void
delete_step_thread_step_resume_breakpoint (void)
{
  if (!target_has_execution
      || ptid_equal (inferior_ptid, null_ptid))
    /* If the inferior has exited, we have already deleted the step
       resume breakpoints out of GDB's lists.  */
    return;

  if (non_stop)
    {
      /* If in non-stop mode, only delete the step-resume or
	 longjmp-resume breakpoint of the thread that just stopped
	 stepping.  */
      struct thread_info *tp = inferior_thread ();

      delete_step_resume_breakpoint (tp);
      delete_exception_resume_breakpoint (tp);
    }
  else
    /* In all-stop mode, delete all step-resume and longjmp-resume
       breakpoints of any thread that had them.  */
    iterate_over_threads (delete_step_resume_breakpoint_callback, NULL);
}

/* A cleanup wrapper.  */

static void
delete_step_thread_step_resume_breakpoint_cleanup (void *arg)
{
  delete_step_thread_step_resume_breakpoint ();
}

/* Pretty print the results of target_wait, for debugging purposes.  */

static void
print_target_wait_results (ptid_t waiton_ptid, ptid_t result_ptid,
			   const struct target_waitstatus *ws)
{
  char *status_string = target_waitstatus_to_string (ws);
  struct ui_file *tmp_stream = mem_fileopen ();
  char *text;

  /* The text is split over several lines because it was getting too long.
     Call fprintf_unfiltered (gdb_stdlog) once so that the text is still
     output as a unit; we want only one timestamp printed if debug_timestamp
     is set.  */

  fprintf_unfiltered (tmp_stream,
		      "infrun: target_wait (%d", ptid_get_pid (waiton_ptid));
  if (ptid_get_pid (waiton_ptid) != -1)
    fprintf_unfiltered (tmp_stream,
			" [%s]", target_pid_to_str (waiton_ptid));
  fprintf_unfiltered (tmp_stream, ", status) =\n");
  fprintf_unfiltered (tmp_stream,
		      "infrun:   %d [%s],\n",
		      ptid_get_pid (result_ptid),
		      target_pid_to_str (result_ptid));
  fprintf_unfiltered (tmp_stream,
		      "infrun:   %s\n",
		      status_string);

  text = ui_file_xstrdup (tmp_stream, NULL);

  /* This uses %s in part to handle %'s in the text, but also to avoid
     a gcc error: the format attribute requires a string literal.  */
  fprintf_unfiltered (gdb_stdlog, "%s", text);

  xfree (status_string);
  xfree (text);
  ui_file_delete (tmp_stream);
}

/* Prepare and stabilize the inferior for detaching it.  E.g.,
   detaching while a thread is displaced stepping is a recipe for
   crashing it, as nothing would readjust the PC out of the scratch
   pad.  */

void
prepare_for_detach (void)
{
  struct inferior *inf = current_inferior ();
  ptid_t pid_ptid = pid_to_ptid (inf->pid);
  struct cleanup *old_chain_1;
  struct displaced_step_inferior_state *displaced;

  displaced = get_displaced_stepping_state (inf->pid);

  /* Is any thread of this process displaced stepping?  If not,
     there's nothing else to do.  */
  if (displaced == NULL || ptid_equal (displaced->step_ptid, null_ptid))
    return;

  if (debug_infrun)
    fprintf_unfiltered (gdb_stdlog,
			"displaced-stepping in-process while detaching");

  old_chain_1 = make_cleanup_restore_integer (&inf->detaching);
  inf->detaching = 1;

  while (!ptid_equal (displaced->step_ptid, null_ptid))
    {
      struct cleanup *old_chain_2;
      struct execution_control_state ecss;
      struct execution_control_state *ecs;

      ecs = &ecss;
      memset (ecs, 0, sizeof (*ecs));

      overlay_cache_invalid = 1;

      if (deprecated_target_wait_hook)
	ecs->ptid = deprecated_target_wait_hook (pid_ptid, &ecs->ws, 0);
      else
	ecs->ptid = target_wait (pid_ptid, &ecs->ws, 0);

      if (debug_infrun)
	print_target_wait_results (pid_ptid, ecs->ptid, &ecs->ws);

      /* If an error happens while handling the event, propagate GDB's
	 knowledge of the executing state to the frontend/user running
	 state.  */
      old_chain_2 = make_cleanup (finish_thread_state_cleanup,
				  &minus_one_ptid);

      /* Now figure out what to do with the result of the result.  */
      handle_inferior_event (ecs);

      /* No error, don't finish the state yet.  */
      discard_cleanups (old_chain_2);

      /* Breakpoints and watchpoints are not installed on the target
	 at this point, and signals are passed directly to the
	 inferior, so this must mean the process is gone.  */
      if (!ecs->wait_some_more)
	{
	  discard_cleanups (old_chain_1);
	  error (_("Program exited while detaching"));
	}
    }

  discard_cleanups (old_chain_1);
}

/* Wait for control to return from inferior to debugger.

   If inferior gets a signal, we may decide to start it up again
   instead of returning.  That is why there is a loop in this function.
   When this function actually returns it means the inferior
   should be left stopped and GDB should read more commands.  */

void
wait_for_inferior (void)
{
  struct cleanup *old_cleanups;

  if (debug_infrun)
    fprintf_unfiltered
      (gdb_stdlog, "infrun: wait_for_inferior ()\n");

  old_cleanups =
    make_cleanup (delete_step_thread_step_resume_breakpoint_cleanup, NULL);

  while (1)
    {
      struct execution_control_state ecss;
      struct execution_control_state *ecs = &ecss;
      struct cleanup *old_chain;

      memset (ecs, 0, sizeof (*ecs));

      overlay_cache_invalid = 1;

      if (deprecated_target_wait_hook)
	ecs->ptid = deprecated_target_wait_hook (waiton_ptid, &ecs->ws, 0);
      else
	ecs->ptid = target_wait (waiton_ptid, &ecs->ws, 0);

      if (debug_infrun)
	print_target_wait_results (waiton_ptid, ecs->ptid, &ecs->ws);

      /* If an error happens while handling the event, propagate GDB's
	 knowledge of the executing state to the frontend/user running
	 state.  */
      old_chain = make_cleanup (finish_thread_state_cleanup, &minus_one_ptid);

      /* Now figure out what to do with the result of the result.  */
      handle_inferior_event (ecs);

      /* No error, don't finish the state yet.  */
      discard_cleanups (old_chain);

      if (!ecs->wait_some_more)
	break;
    }

  do_cleanups (old_cleanups);
}

/* Asynchronous version of wait_for_inferior.  It is called by the
   event loop whenever a change of state is detected on the file
   descriptor corresponding to the target.  It can be called more than
   once to complete a single execution command.  In such cases we need
   to keep the state in a global variable ECSS.  If it is the last time
   that this function is called for a single execution command, then
   report to the user that the inferior has stopped, and do the
   necessary cleanups.  */

void
fetch_inferior_event (void *client_data)
{
  struct execution_control_state ecss;
  struct execution_control_state *ecs = &ecss;
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
  struct cleanup *ts_old_chain;
  int was_sync = sync_execution;
  int cmd_done = 0;

  memset (ecs, 0, sizeof (*ecs));

  /* We're handling a live event, so make sure we're doing live
     debugging.  If we're looking at traceframes while the target is
     running, we're going to need to get back to that mode after
     handling the event.  */
  if (non_stop)
    {
      make_cleanup_restore_current_traceframe ();
      set_current_traceframe (-1);
    }

  if (non_stop)
    /* In non-stop mode, the user/frontend should not notice a thread
       switch due to internal events.  Make sure we reverse to the
       user selected thread and frame after handling the event and
       running any breakpoint commands.  */
    make_cleanup_restore_current_thread ();

  overlay_cache_invalid = 1;

  make_cleanup_restore_integer (&execution_direction);
  execution_direction = target_execution_direction ();

  if (deprecated_target_wait_hook)
    ecs->ptid =
      deprecated_target_wait_hook (waiton_ptid, &ecs->ws, TARGET_WNOHANG);
  else
    ecs->ptid = target_wait (waiton_ptid, &ecs->ws, TARGET_WNOHANG);

  if (debug_infrun)
    print_target_wait_results (waiton_ptid, ecs->ptid, &ecs->ws);

  /* If an error happens while handling the event, propagate GDB's
     knowledge of the executing state to the frontend/user running
     state.  */
  if (!non_stop)
    ts_old_chain = make_cleanup (finish_thread_state_cleanup, &minus_one_ptid);
  else
    ts_old_chain = make_cleanup (finish_thread_state_cleanup, &ecs->ptid);

  /* Get executed before make_cleanup_restore_current_thread above to apply
     still for the thread which has thrown the exception.  */
  make_bpstat_clear_actions_cleanup ();

  /* Now figure out what to do with the result of the result.  */
  handle_inferior_event (ecs);

  if (!ecs->wait_some_more)
    {
      struct inferior *inf = find_inferior_pid (ptid_get_pid (ecs->ptid));

      delete_step_thread_step_resume_breakpoint ();

      /* We may not find an inferior if this was a process exit.  */
      if (inf == NULL || inf->control.stop_soon == NO_STOP_QUIETLY)
	normal_stop ();

      if (target_has_execution
	  && ecs->ws.kind != TARGET_WAITKIND_NO_RESUMED
	  && ecs->ws.kind != TARGET_WAITKIND_EXITED
	  && ecs->ws.kind != TARGET_WAITKIND_SIGNALLED
	  && ecs->event_thread->step_multi
	  && ecs->event_thread->control.stop_step)
	inferior_event_handler (INF_EXEC_CONTINUE, NULL);
      else
	{
	  inferior_event_handler (INF_EXEC_COMPLETE, NULL);
	  cmd_done = 1;
	}
    }

  /* No error, don't finish the thread states yet.  */
  discard_cleanups (ts_old_chain);

  /* Revert thread and frame.  */
  do_cleanups (old_chain);

  /* If the inferior was in sync execution mode, and now isn't,
     restore the prompt (a synchronous execution command has finished,
     and we're ready for input).  */
  if (interpreter_async && was_sync && !sync_execution)
    display_gdb_prompt (0);

  if (cmd_done
      && !was_sync
      && exec_done_display_p
      && (ptid_equal (inferior_ptid, null_ptid)
	  || !is_running (inferior_ptid)))
    printf_unfiltered (_("completed.\n"));
}

/* Record the frame and location we're currently stepping through.  */
void
set_step_info (struct frame_info *frame, struct symtab_and_line sal)
{
  struct thread_info *tp = inferior_thread ();

  tp->control.step_frame_id = get_frame_id (frame);
  tp->control.step_stack_frame_id = get_stack_frame_id (frame);

  tp->current_symtab = sal.symtab;
  tp->current_line = sal.line;
}

/* Clear context switchable stepping state.  */

void
init_thread_stepping_state (struct thread_info *tss)
{
  tss->stepping_over_breakpoint = 0;
  tss->step_after_step_resume_breakpoint = 0;
}

/* Return the cached copy of the last pid/waitstatus returned by
   target_wait()/deprecated_target_wait_hook().  The data is actually
   cached by handle_inferior_event(), which gets called immediately
   after target_wait()/deprecated_target_wait_hook().  */

void
get_last_target_status (ptid_t *ptidp, struct target_waitstatus *status)
{
  *ptidp = target_last_wait_ptid;
  *status = target_last_waitstatus;
}

void
nullify_last_target_wait_ptid (void)
{
  target_last_wait_ptid = minus_one_ptid;
}

/* Switch thread contexts.  */

static void
context_switch (ptid_t ptid)
{
  if (debug_infrun && !ptid_equal (ptid, inferior_ptid))
    {
      fprintf_unfiltered (gdb_stdlog, "infrun: Switching context from %s ",
			  target_pid_to_str (inferior_ptid));
      fprintf_unfiltered (gdb_stdlog, "to %s\n",
			  target_pid_to_str (ptid));
    }

  switch_to_thread (ptid);
}

static void
adjust_pc_after_break (struct execution_control_state *ecs)
{
  struct regcache *regcache;
  struct gdbarch *gdbarch;
  struct address_space *aspace;
  CORE_ADDR breakpoint_pc;

  /* If we've hit a breakpoint, we'll normally be stopped with SIGTRAP.  If
     we aren't, just return.

     We assume that waitkinds other than TARGET_WAITKIND_STOPPED are not
     affected by gdbarch_decr_pc_after_break.  Other waitkinds which are
     implemented by software breakpoints should be handled through the normal
     breakpoint layer.

     NOTE drow/2004-01-31: On some targets, breakpoints may generate
     different signals (SIGILL or SIGEMT for instance), but it is less
     clear where the PC is pointing afterwards.  It may not match
     gdbarch_decr_pc_after_break.  I don't know any specific target that
     generates these signals at breakpoints (the code has been in GDB since at
     least 1992) so I can not guess how to handle them here.

     In earlier versions of GDB, a target with 
     gdbarch_have_nonsteppable_watchpoint would have the PC after hitting a
     watchpoint affected by gdbarch_decr_pc_after_break.  I haven't found any
     target with both of these set in GDB history, and it seems unlikely to be
     correct, so gdbarch_have_nonsteppable_watchpoint is not checked here.  */

  if (ecs->ws.kind != TARGET_WAITKIND_STOPPED)
    return;

  if (ecs->ws.value.sig != GDB_SIGNAL_TRAP)
    return;

  /* In reverse execution, when a breakpoint is hit, the instruction
     under it has already been de-executed.  The reported PC always
     points at the breakpoint address, so adjusting it further would
     be wrong.  E.g., consider this case on a decr_pc_after_break == 1
     architecture:

       B1         0x08000000 :   INSN1
       B2         0x08000001 :   INSN2
		  0x08000002 :   INSN3
	    PC -> 0x08000003 :   INSN4

     Say you're stopped at 0x08000003 as above.  Reverse continuing
     from that point should hit B2 as below.  Reading the PC when the
     SIGTRAP is reported should read 0x08000001 and INSN2 should have
     been de-executed already.

       B1         0x08000000 :   INSN1
       B2   PC -> 0x08000001 :   INSN2
		  0x08000002 :   INSN3
		  0x08000003 :   INSN4

     We can't apply the same logic as for forward execution, because
     we would wrongly adjust the PC to 0x08000000, since there's a
     breakpoint at PC - 1.  We'd then report a hit on B1, although
     INSN1 hadn't been de-executed yet.  Doing nothing is the correct
     behaviour.  */
  if (execution_direction == EXEC_REVERSE)
    return;

  /* If this target does not decrement the PC after breakpoints, then
     we have nothing to do.  */
  regcache = get_thread_regcache (ecs->ptid);
  gdbarch = get_regcache_arch (regcache);
  if (gdbarch_decr_pc_after_break (gdbarch) == 0)
    return;

  aspace = get_regcache_aspace (regcache);

  /* Find the location where (if we've hit a breakpoint) the
     breakpoint would be.  */
  breakpoint_pc = regcache_read_pc (regcache)
		  - gdbarch_decr_pc_after_break (gdbarch);

  /* Check whether there actually is a software breakpoint inserted at
     that location.

     If in non-stop mode, a race condition is possible where we've
     removed a breakpoint, but stop events for that breakpoint were
     already queued and arrive later.  To suppress those spurious
     SIGTRAPs, we keep a list of such breakpoint locations for a bit,
     and retire them after a number of stop events are reported.  */
  if (software_breakpoint_inserted_here_p (aspace, breakpoint_pc)
      || (non_stop && moribund_breakpoint_here_p (aspace, breakpoint_pc)))
    {
      struct cleanup *old_cleanups = make_cleanup (null_cleanup, NULL);

      if (RECORD_IS_USED)
	record_full_gdb_operation_disable_set ();

      /* When using hardware single-step, a SIGTRAP is reported for both
	 a completed single-step and a software breakpoint.  Need to
	 differentiate between the two, as the latter needs adjusting
	 but the former does not.

	 The SIGTRAP can be due to a completed hardware single-step only if 
	  - we didn't insert software single-step breakpoints
	  - the thread to be examined is still the current thread
	  - this thread is currently being stepped

	 If any of these events did not occur, we must have stopped due
	 to hitting a software breakpoint, and have to back up to the
	 breakpoint address.

	 As a special case, we could have hardware single-stepped a
	 software breakpoint.  In this case (prev_pc == breakpoint_pc),
	 we also need to back up to the breakpoint address.  */

      if (singlestep_breakpoints_inserted_p
	  || !ptid_equal (ecs->ptid, inferior_ptid)
	  || !currently_stepping (ecs->event_thread)
	  || ecs->event_thread->prev_pc == breakpoint_pc)
	regcache_write_pc (regcache, breakpoint_pc);

      do_cleanups (old_cleanups);
    }
}

static void
init_infwait_state (void)
{
  waiton_ptid = pid_to_ptid (-1);
  infwait_state = infwait_normal_state;
}

static int
stepped_in_from (struct frame_info *frame, struct frame_id step_frame_id)
{
  for (frame = get_prev_frame (frame);
       frame != NULL;
       frame = get_prev_frame (frame))
    {
      if (frame_id_eq (get_frame_id (frame), step_frame_id))
	return 1;
      if (get_frame_type (frame) != INLINE_FRAME)
	break;
    }

  return 0;
}

/* Auxiliary function that handles syscall entry/return events.
   It returns 1 if the inferior should keep going (and GDB
   should ignore the event), or 0 if the event deserves to be
   processed.  */

static int
handle_syscall_event (struct execution_control_state *ecs)
{
  struct regcache *regcache;
  int syscall_number;

  if (!ptid_equal (ecs->ptid, inferior_ptid))
    context_switch (ecs->ptid);

  regcache = get_thread_regcache (ecs->ptid);
  syscall_number = ecs->ws.value.syscall_number;
  stop_pc = regcache_read_pc (regcache);

  if (catch_syscall_enabled () > 0
      && catching_syscall_number (syscall_number) > 0)
    {
      enum bpstat_signal_value sval;

      if (debug_infrun)
        fprintf_unfiltered (gdb_stdlog, "infrun: syscall number = '%d'\n",
                            syscall_number);

      ecs->event_thread->control.stop_bpstat
	= bpstat_stop_status (get_regcache_aspace (regcache),
			      stop_pc, ecs->ptid, &ecs->ws);

      sval = bpstat_explains_signal (ecs->event_thread->control.stop_bpstat,
				     GDB_SIGNAL_TRAP);
      ecs->random_signal = sval == BPSTAT_SIGNAL_NO;

      if (!ecs->random_signal)
	{
	  /* Catchpoint hit.  */
	  ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_TRAP;
	  return 0;
	}
    }

  /* If no catchpoint triggered for this, then keep going.  */
  ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;
  keep_going (ecs);
  return 1;
}

/* Clear the supplied execution_control_state's stop_func_* fields.  */

static void
clear_stop_func (struct execution_control_state *ecs)
{
  ecs->stop_func_filled_in = 0;
  ecs->stop_func_start = 0;
  ecs->stop_func_end = 0;
  ecs->stop_func_name = NULL;
}

/* Lazily fill in the execution_control_state's stop_func_* fields.  */

static void
fill_in_stop_func (struct gdbarch *gdbarch,
		   struct execution_control_state *ecs)
{
  if (!ecs->stop_func_filled_in)
    {
      /* Don't care about return value; stop_func_start and stop_func_name
	 will both be 0 if it doesn't work.  */
      find_pc_partial_function (stop_pc, &ecs->stop_func_name,
				&ecs->stop_func_start, &ecs->stop_func_end);
      ecs->stop_func_start
	+= gdbarch_deprecated_function_start_offset (gdbarch);

      ecs->stop_func_filled_in = 1;
    }
}

/* Given an execution control state that has been freshly filled in
   by an event from the inferior, figure out what it means and take
   appropriate action.  */

static void
handle_inferior_event (struct execution_control_state *ecs)
{
  struct frame_info *frame;
  struct gdbarch *gdbarch;
  int stopped_by_watchpoint;
  int stepped_after_stopped_by_watchpoint = 0;
  struct symtab_and_line stop_pc_sal;
  enum stop_kind stop_soon;

  if (ecs->ws.kind == TARGET_WAITKIND_IGNORE)
    {
      /* We had an event in the inferior, but we are not interested in
	 handling it at this level.  The lower layers have already
	 done what needs to be done, if anything.

	 One of the possible circumstances for this is when the
	 inferior produces output for the console.  The inferior has
	 not stopped, and we are ignoring the event.  Another possible
	 circumstance is any event which the lower level knows will be
	 reported multiple times without an intervening resume.  */
      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_IGNORE\n");
      prepare_to_wait (ecs);
      return;
    }

  if (ecs->ws.kind == TARGET_WAITKIND_NO_RESUMED
      && target_can_async_p () && !sync_execution)
    {
      /* There were no unwaited-for children left in the target, but,
	 we're not synchronously waiting for events either.  Just
	 ignore.  Otherwise, if we were running a synchronous
	 execution command, we need to cancel it and give the user
	 back the terminal.  */
      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog,
			    "infrun: TARGET_WAITKIND_NO_RESUMED (ignoring)\n");
      prepare_to_wait (ecs);
      return;
    }

  if (ecs->ws.kind != TARGET_WAITKIND_EXITED
      && ecs->ws.kind != TARGET_WAITKIND_SIGNALLED
      && ecs->ws.kind != TARGET_WAITKIND_NO_RESUMED)
    {
      struct inferior *inf = find_inferior_pid (ptid_get_pid (ecs->ptid));

      gdb_assert (inf);
      stop_soon = inf->control.stop_soon;
    }
  else
    stop_soon = NO_STOP_QUIETLY;

  /* Cache the last pid/waitstatus.  */
  target_last_wait_ptid = ecs->ptid;
  target_last_waitstatus = ecs->ws;

  /* Always clear state belonging to the previous time we stopped.  */
  stop_stack_dummy = STOP_NONE;

  if (ecs->ws.kind == TARGET_WAITKIND_NO_RESUMED)
    {
      /* No unwaited-for children left.  IOW, all resumed children
	 have exited.  */
      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_NO_RESUMED\n");

      stop_print_frame = 0;
      stop_stepping (ecs);
      return;
    }

  if (ecs->ws.kind != TARGET_WAITKIND_EXITED
      && ecs->ws.kind != TARGET_WAITKIND_SIGNALLED)
    {
      ecs->event_thread = find_thread_ptid (ecs->ptid);
      /* If it's a new thread, add it to the thread database.  */
      if (ecs->event_thread == NULL)
	ecs->event_thread = add_thread (ecs->ptid);

      /* Disable range stepping.  If the next step request could use a
	 range, this will be end up re-enabled then.  */
      ecs->event_thread->control.may_range_step = 0;
    }

  /* Dependent on valid ECS->EVENT_THREAD.  */
  adjust_pc_after_break (ecs);

  /* Dependent on the current PC value modified by adjust_pc_after_break.  */
  reinit_frame_cache ();

  breakpoint_retire_moribund ();

  /* First, distinguish signals caused by the debugger from signals
     that have to do with the program's own actions.  Note that
     breakpoint insns may cause SIGTRAP or SIGILL or SIGEMT, depending
     on the operating system version.  Here we detect when a SIGILL or
     SIGEMT is really a breakpoint and change it to SIGTRAP.  We do
     something similar for SIGSEGV, since a SIGSEGV will be generated
     when we're trying to execute a breakpoint instruction on a
     non-executable stack.  This happens for call dummy breakpoints
     for architectures like SPARC that place call dummies on the
     stack.  */
  if (ecs->ws.kind == TARGET_WAITKIND_STOPPED
      && (ecs->ws.value.sig == GDB_SIGNAL_ILL
	  || ecs->ws.value.sig == GDB_SIGNAL_SEGV
	  || ecs->ws.value.sig == GDB_SIGNAL_EMT))
    {
      struct regcache *regcache = get_thread_regcache (ecs->ptid);

      if (breakpoint_inserted_here_p (get_regcache_aspace (regcache),
				      regcache_read_pc (regcache)))
	{
	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog,
				"infrun: Treating signal as SIGTRAP\n");
	  ecs->ws.value.sig = GDB_SIGNAL_TRAP;
	}
    }

  /* Mark the non-executing threads accordingly.  In all-stop, all
     threads of all processes are stopped when we get any event
     reported.  In non-stop mode, only the event thread stops.  If
     we're handling a process exit in non-stop mode, there's nothing
     to do, as threads of the dead process are gone, and threads of
     any other process were left running.  */
  if (!non_stop)
    set_executing (minus_one_ptid, 0);
  else if (ecs->ws.kind != TARGET_WAITKIND_SIGNALLED
	   && ecs->ws.kind != TARGET_WAITKIND_EXITED)
    set_executing (ecs->ptid, 0);

  switch (infwait_state)
    {
    case infwait_thread_hop_state:
      if (debug_infrun)
        fprintf_unfiltered (gdb_stdlog, "infrun: infwait_thread_hop_state\n");
      break;

    case infwait_normal_state:
      if (debug_infrun)
        fprintf_unfiltered (gdb_stdlog, "infrun: infwait_normal_state\n");
      break;

    case infwait_step_watch_state:
      if (debug_infrun)
        fprintf_unfiltered (gdb_stdlog,
			    "infrun: infwait_step_watch_state\n");

      stepped_after_stopped_by_watchpoint = 1;
      break;

    case infwait_nonstep_watch_state:
      if (debug_infrun)
        fprintf_unfiltered (gdb_stdlog,
			    "infrun: infwait_nonstep_watch_state\n");
      insert_breakpoints ();

      /* FIXME-maybe: is this cleaner than setting a flag?  Does it
         handle things like signals arriving and other things happening
         in combination correctly?  */
      stepped_after_stopped_by_watchpoint = 1;
      break;

    default:
      internal_error (__FILE__, __LINE__, _("bad switch"));
    }

  infwait_state = infwait_normal_state;
  waiton_ptid = pid_to_ptid (-1);

  switch (ecs->ws.kind)
    {
    case TARGET_WAITKIND_LOADED:
      if (debug_infrun)
        fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_LOADED\n");
      /* Ignore gracefully during startup of the inferior, as it might
         be the shell which has just loaded some objects, otherwise
         add the symbols for the newly loaded objects.  Also ignore at
         the beginning of an attach or remote session; we will query
         the full list of libraries once the connection is
         established.  */
      if (stop_soon == NO_STOP_QUIETLY)
	{
	  struct regcache *regcache;
	  enum bpstat_signal_value sval;

	  if (!ptid_equal (ecs->ptid, inferior_ptid))
	    context_switch (ecs->ptid);
	  regcache = get_thread_regcache (ecs->ptid);

	  handle_solib_event ();

	  ecs->event_thread->control.stop_bpstat
	    = bpstat_stop_status (get_regcache_aspace (regcache),
				  stop_pc, ecs->ptid, &ecs->ws);

	  sval
	    = bpstat_explains_signal (ecs->event_thread->control.stop_bpstat,
				      GDB_SIGNAL_TRAP);
	  ecs->random_signal = sval == BPSTAT_SIGNAL_NO;

	  if (!ecs->random_signal)
	    {
	      /* A catchpoint triggered.  */
	      ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_TRAP;
	      goto process_event_stop_test;
	    }

	  /* If requested, stop when the dynamic linker notifies
	     gdb of events.  This allows the user to get control
	     and place breakpoints in initializer routines for
	     dynamically loaded objects (among other things).  */
	  ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;
	  if (stop_on_solib_events)
	    {
	      /* Make sure we print "Stopped due to solib-event" in
		 normal_stop.  */
	      stop_print_frame = 1;

	      stop_stepping (ecs);
	      return;
	    }
	}

      /* If we are skipping through a shell, or through shared library
	 loading that we aren't interested in, resume the program.  If
	 we're running the program normally, also resume.  But stop if
	 we're attaching or setting up a remote connection.  */
      if (stop_soon == STOP_QUIETLY || stop_soon == NO_STOP_QUIETLY)
	{
	  if (!ptid_equal (ecs->ptid, inferior_ptid))
	    context_switch (ecs->ptid);

	  /* Loading of shared libraries might have changed breakpoint
	     addresses.  Make sure new breakpoints are inserted.  */
	  if (stop_soon == NO_STOP_QUIETLY
	      && !breakpoints_always_inserted_mode ())
	    insert_breakpoints ();
	  resume (0, GDB_SIGNAL_0);
	  prepare_to_wait (ecs);
	  return;
	}

      break;

    case TARGET_WAITKIND_SPURIOUS:
      if (debug_infrun)
        fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_SPURIOUS\n");
      if (!ptid_equal (ecs->ptid, inferior_ptid))
	context_switch (ecs->ptid);
      resume (0, GDB_SIGNAL_0);
      prepare_to_wait (ecs);
      return;

    case TARGET_WAITKIND_EXITED:
    case TARGET_WAITKIND_SIGNALLED:
      if (debug_infrun)
	{
	  if (ecs->ws.kind == TARGET_WAITKIND_EXITED)
	    fprintf_unfiltered (gdb_stdlog,
				"infrun: TARGET_WAITKIND_EXITED\n");
	  else
	    fprintf_unfiltered (gdb_stdlog,
				"infrun: TARGET_WAITKIND_SIGNALLED\n");
	}

      inferior_ptid = ecs->ptid;
      set_current_inferior (find_inferior_pid (ptid_get_pid (ecs->ptid)));
      set_current_program_space (current_inferior ()->pspace);
      handle_vfork_child_exec_or_exit (0);
      target_terminal_ours ();	/* Must do this before mourn anyway.  */

      /* Clearing any previous state of convenience variables.  */
      clear_exit_convenience_vars ();

      if (ecs->ws.kind == TARGET_WAITKIND_EXITED)
	{
	  /* Record the exit code in the convenience variable $_exitcode, so
	     that the user can inspect this again later.  */
	  set_internalvar_integer (lookup_internalvar ("_exitcode"),
				   (LONGEST) ecs->ws.value.integer);

	  /* Also record this in the inferior itself.  */
	  current_inferior ()->has_exit_code = 1;
	  current_inferior ()->exit_code = (LONGEST) ecs->ws.value.integer;

	  print_exited_reason (ecs->ws.value.integer);
	}
      else
	{
	  struct regcache *regcache = get_thread_regcache (ecs->ptid);
	  struct gdbarch *gdbarch = get_regcache_arch (regcache);

	  if (gdbarch_gdb_signal_to_target_p (gdbarch))
	    {
	      /* Set the value of the internal variable $_exitsignal,
		 which holds the signal uncaught by the inferior.  */
	      set_internalvar_integer (lookup_internalvar ("_exitsignal"),
				       gdbarch_gdb_signal_to_target (gdbarch,
							  ecs->ws.value.sig));
	    }
	  else
	    {
	      /* We don't have access to the target's method used for
		 converting between signal numbers (GDB's internal
		 representation <-> target's representation).
		 Therefore, we cannot do a good job at displaying this
		 information to the user.  It's better to just warn
		 her about it (if infrun debugging is enabled), and
		 give up.  */
	      if (debug_infrun)
		fprintf_filtered (gdb_stdlog, _("\
Cannot fill $_exitsignal with the correct signal number.\n"));
	    }

	  print_signal_exited_reason (ecs->ws.value.sig);
	}

      gdb_flush (gdb_stdout);
      target_mourn_inferior ();
      singlestep_breakpoints_inserted_p = 0;
      cancel_single_step_breakpoints ();
      stop_print_frame = 0;
      stop_stepping (ecs);
      return;

      /* The following are the only cases in which we keep going;
         the above cases end in a continue or goto.  */
    case TARGET_WAITKIND_FORKED:
    case TARGET_WAITKIND_VFORKED:
      if (debug_infrun)
	{
	  if (ecs->ws.kind == TARGET_WAITKIND_FORKED)
	    fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_FORKED\n");
	  else
	    fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_VFORKED\n");
	}

      /* Check whether the inferior is displaced stepping.  */
      {
	struct regcache *regcache = get_thread_regcache (ecs->ptid);
	struct gdbarch *gdbarch = get_regcache_arch (regcache);
	struct displaced_step_inferior_state *displaced
	  = get_displaced_stepping_state (ptid_get_pid (ecs->ptid));

	/* If checking displaced stepping is supported, and thread
	   ecs->ptid is displaced stepping.  */
	if (displaced && ptid_equal (displaced->step_ptid, ecs->ptid))
	  {
	    struct inferior *parent_inf
	      = find_inferior_pid (ptid_get_pid (ecs->ptid));
	    struct regcache *child_regcache;
	    CORE_ADDR parent_pc;

	    /* GDB has got TARGET_WAITKIND_FORKED or TARGET_WAITKIND_VFORKED,
	       indicating that the displaced stepping of syscall instruction
	       has been done.  Perform cleanup for parent process here.  Note
	       that this operation also cleans up the child process for vfork,
	       because their pages are shared.  */
	    displaced_step_fixup (ecs->ptid, GDB_SIGNAL_TRAP);

	    if (ecs->ws.kind == TARGET_WAITKIND_FORKED)
	      {
		/* Restore scratch pad for child process.  */
		displaced_step_restore (displaced, ecs->ws.value.related_pid);
	      }

	    /* Since the vfork/fork syscall instruction was executed in the scratchpad,
	       the child's PC is also within the scratchpad.  Set the child's PC
	       to the parent's PC value, which has already been fixed up.
	       FIXME: we use the parent's aspace here, although we're touching
	       the child, because the child hasn't been added to the inferior
	       list yet at this point.  */

	    child_regcache
	      = get_thread_arch_aspace_regcache (ecs->ws.value.related_pid,
						 gdbarch,
						 parent_inf->aspace);
	    /* Read PC value of parent process.  */
	    parent_pc = regcache_read_pc (regcache);

	    if (debug_displaced)
	      fprintf_unfiltered (gdb_stdlog,
				  "displaced: write child pc from %s to %s\n",
				  paddress (gdbarch,
					    regcache_read_pc (child_regcache)),
				  paddress (gdbarch, parent_pc));

	    regcache_write_pc (child_regcache, parent_pc);
	  }
      }

      if (!ptid_equal (ecs->ptid, inferior_ptid))
	context_switch (ecs->ptid);

      /* Immediately detach breakpoints from the child before there's
	 any chance of letting the user delete breakpoints from the
	 breakpoint lists.  If we don't do this early, it's easy to
	 leave left over traps in the child, vis: "break foo; catch
	 fork; c; <fork>; del; c; <child calls foo>".  We only follow
	 the fork on the last `continue', and by that time the
	 breakpoint at "foo" is long gone from the breakpoint table.
	 If we vforked, then we don't need to unpatch here, since both
	 parent and child are sharing the same memory pages; we'll
	 need to unpatch at follow/detach time instead to be certain
	 that new breakpoints added between catchpoint hit time and
	 vfork follow are detached.  */
      if (ecs->ws.kind != TARGET_WAITKIND_VFORKED)
	{
	  /* This won't actually modify the breakpoint list, but will
	     physically remove the breakpoints from the child.  */
	  detach_breakpoints (ecs->ws.value.related_pid);
	}

      if (singlestep_breakpoints_inserted_p)
	{
	  /* Pull the single step breakpoints out of the target.  */
	  remove_single_step_breakpoints ();
	  singlestep_breakpoints_inserted_p = 0;
	}

      /* In case the event is caught by a catchpoint, remember that
	 the event is to be followed at the next resume of the thread,
	 and not immediately.  */
      ecs->event_thread->pending_follow = ecs->ws;

      stop_pc = regcache_read_pc (get_thread_regcache (ecs->ptid));

      ecs->event_thread->control.stop_bpstat
	= bpstat_stop_status (get_regcache_aspace (get_current_regcache ()),
			      stop_pc, ecs->ptid, &ecs->ws);

      /* Note that we're interested in knowing the bpstat actually
	 causes a stop, not just if it may explain the signal.
	 Software watchpoints, for example, always appear in the
	 bpstat.  */
      ecs->random_signal
	= !bpstat_causes_stop (ecs->event_thread->control.stop_bpstat);

      /* If no catchpoint triggered for this, then keep going.  */
      if (ecs->random_signal)
	{
	  ptid_t parent;
	  ptid_t child;
	  int should_resume;
	  int follow_child
	    = (follow_fork_mode_string == follow_fork_mode_child);

	  ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;

	  should_resume = follow_fork ();

	  parent = ecs->ptid;
	  child = ecs->ws.value.related_pid;

	  /* In non-stop mode, also resume the other branch.  */
	  if (non_stop && !detach_fork)
	    {
	      if (follow_child)
		switch_to_thread (parent);
	      else
		switch_to_thread (child);

	      ecs->event_thread = inferior_thread ();
	      ecs->ptid = inferior_ptid;
	      keep_going (ecs);
	    }

	  if (follow_child)
	    switch_to_thread (child);
	  else
	    switch_to_thread (parent);

	  ecs->event_thread = inferior_thread ();
	  ecs->ptid = inferior_ptid;

	  if (should_resume)
	    keep_going (ecs);
	  else
	    stop_stepping (ecs);
	  return;
	}
      ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_TRAP;
      goto process_event_stop_test;

    case TARGET_WAITKIND_VFORK_DONE:
      /* Done with the shared memory region.  Re-insert breakpoints in
	 the parent, and keep going.  */

      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog,
			    "infrun: TARGET_WAITKIND_VFORK_DONE\n");

      if (!ptid_equal (ecs->ptid, inferior_ptid))
	context_switch (ecs->ptid);

      current_inferior ()->waiting_for_vfork_done = 0;
      current_inferior ()->pspace->breakpoints_not_allowed = 0;
      /* This also takes care of reinserting breakpoints in the
	 previously locked inferior.  */
      keep_going (ecs);
      return;

    case TARGET_WAITKIND_EXECD:
      if (debug_infrun)
        fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_EXECD\n");

      if (!ptid_equal (ecs->ptid, inferior_ptid))
	context_switch (ecs->ptid);

      singlestep_breakpoints_inserted_p = 0;
      cancel_single_step_breakpoints ();

      stop_pc = regcache_read_pc (get_thread_regcache (ecs->ptid));

      /* Do whatever is necessary to the parent branch of the vfork.  */
      handle_vfork_child_exec_or_exit (1);

      /* This causes the eventpoints and symbol table to be reset.
         Must do this now, before trying to determine whether to
         stop.  */
      follow_exec (inferior_ptid, ecs->ws.value.execd_pathname);

      ecs->event_thread->control.stop_bpstat
	= bpstat_stop_status (get_regcache_aspace (get_current_regcache ()),
			      stop_pc, ecs->ptid, &ecs->ws);
      ecs->random_signal
	= (bpstat_explains_signal (ecs->event_thread->control.stop_bpstat,
				   GDB_SIGNAL_TRAP)
	   == BPSTAT_SIGNAL_NO);

      /* Note that this may be referenced from inside
	 bpstat_stop_status above, through inferior_has_execd.  */
      xfree (ecs->ws.value.execd_pathname);
      ecs->ws.value.execd_pathname = NULL;

      /* If no catchpoint triggered for this, then keep going.  */
      if (ecs->random_signal)
	{
	  ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;
	  keep_going (ecs);
	  return;
	}
      ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_TRAP;
      goto process_event_stop_test;

      /* Be careful not to try to gather much state about a thread
         that's in a syscall.  It's frequently a losing proposition.  */
    case TARGET_WAITKIND_SYSCALL_ENTRY:
      if (debug_infrun)
        fprintf_unfiltered (gdb_stdlog,
			    "infrun: TARGET_WAITKIND_SYSCALL_ENTRY\n");
      /* Getting the current syscall number.  */
      if (handle_syscall_event (ecs) != 0)
        return;
      goto process_event_stop_test;

      /* Before examining the threads further, step this thread to
         get it entirely out of the syscall.  (We get notice of the
         event when the thread is just on the verge of exiting a
         syscall.  Stepping one instruction seems to get it back
         into user code.)  */
    case TARGET_WAITKIND_SYSCALL_RETURN:
      if (debug_infrun)
        fprintf_unfiltered (gdb_stdlog,
			    "infrun: TARGET_WAITKIND_SYSCALL_RETURN\n");
      if (handle_syscall_event (ecs) != 0)
        return;
      goto process_event_stop_test;

    case TARGET_WAITKIND_STOPPED:
      if (debug_infrun)
        fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_STOPPED\n");
      ecs->event_thread->suspend.stop_signal = ecs->ws.value.sig;
      break;

    case TARGET_WAITKIND_NO_HISTORY:
      if (debug_infrun)
        fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_NO_HISTORY\n");
      /* Reverse execution: target ran out of history info.  */

      /* Pull the single step breakpoints out of the target.  */
      if (singlestep_breakpoints_inserted_p)
	{
	  if (!ptid_equal (ecs->ptid, inferior_ptid))
	    context_switch (ecs->ptid);
	  remove_single_step_breakpoints ();
	  singlestep_breakpoints_inserted_p = 0;
	}
      stop_pc = regcache_read_pc (get_thread_regcache (ecs->ptid));
      print_no_history_reason ();
      stop_stepping (ecs);
      return;
    }

  if (ecs->ws.kind == TARGET_WAITKIND_STOPPED)
    {
      /* Do we need to clean up the state of a thread that has
	 completed a displaced single-step?  (Doing so usually affects
	 the PC, so do it here, before we set stop_pc.)  */
      displaced_step_fixup (ecs->ptid,
			    ecs->event_thread->suspend.stop_signal);

      /* If we either finished a single-step or hit a breakpoint, but
	 the user wanted this thread to be stopped, pretend we got a
	 SIG0 (generic unsignaled stop).  */

      if (ecs->event_thread->stop_requested
	  && ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP)
	ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;
    }

  stop_pc = regcache_read_pc (get_thread_regcache (ecs->ptid));

  if (debug_infrun)
    {
      struct regcache *regcache = get_thread_regcache (ecs->ptid);
      struct gdbarch *gdbarch = get_regcache_arch (regcache);
      struct cleanup *old_chain = save_inferior_ptid ();

      inferior_ptid = ecs->ptid;

      fprintf_unfiltered (gdb_stdlog, "infrun: stop_pc = %s\n",
                          paddress (gdbarch, stop_pc));
      if (target_stopped_by_watchpoint ())
	{
          CORE_ADDR addr;

	  fprintf_unfiltered (gdb_stdlog, "infrun: stopped by watchpoint\n");

          if (target_stopped_data_address (&current_target, &addr))
            fprintf_unfiltered (gdb_stdlog,
                                "infrun: stopped data address = %s\n",
                                paddress (gdbarch, addr));
          else
            fprintf_unfiltered (gdb_stdlog,
                                "infrun: (no data address available)\n");
	}

      do_cleanups (old_chain);
    }

  if (stepping_past_singlestep_breakpoint)
    {
      gdb_assert (singlestep_breakpoints_inserted_p);
      gdb_assert (ptid_equal (singlestep_ptid, ecs->ptid));
      gdb_assert (!ptid_equal (singlestep_ptid, saved_singlestep_ptid));

      stepping_past_singlestep_breakpoint = 0;

      /* We've either finished single-stepping past the single-step
         breakpoint, or stopped for some other reason.  It would be nice if
         we could tell, but we can't reliably.  */
      if (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP)
	{
	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog,
				"infrun: stepping_past_"
				"singlestep_breakpoint\n");
	  /* Pull the single step breakpoints out of the target.  */
	  if (!ptid_equal (ecs->ptid, inferior_ptid))
	    context_switch (ecs->ptid);
	  remove_single_step_breakpoints ();
	  singlestep_breakpoints_inserted_p = 0;

	  ecs->random_signal = 0;
	  ecs->event_thread->control.trap_expected = 0;

	  context_switch (saved_singlestep_ptid);
	  if (deprecated_context_hook)
	    deprecated_context_hook (pid_to_thread_id (saved_singlestep_ptid));

	  resume (1, GDB_SIGNAL_0);
	  prepare_to_wait (ecs);
	  return;
	}
    }

  if (!ptid_equal (deferred_step_ptid, null_ptid))
    {
      /* In non-stop mode, there's never a deferred_step_ptid set.  */
      gdb_assert (!non_stop);

      /* If we stopped for some other reason than single-stepping, ignore
	 the fact that we were supposed to switch back.  */
      if (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP)
	{
	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog,
				"infrun: handling deferred step\n");

	  /* Pull the single step breakpoints out of the target.  */
	  if (singlestep_breakpoints_inserted_p)
	    {
	      if (!ptid_equal (ecs->ptid, inferior_ptid))
		context_switch (ecs->ptid);
	      remove_single_step_breakpoints ();
	      singlestep_breakpoints_inserted_p = 0;
	    }

	  ecs->event_thread->control.trap_expected = 0;

	  context_switch (deferred_step_ptid);
	  deferred_step_ptid = null_ptid;
	  /* Suppress spurious "Switching to ..." message.  */
	  previous_inferior_ptid = inferior_ptid;

	  resume (1, GDB_SIGNAL_0);
	  prepare_to_wait (ecs);
	  return;
	}

      deferred_step_ptid = null_ptid;
    }

  /* See if a thread hit a thread-specific breakpoint that was meant for
     another thread.  If so, then step that thread past the breakpoint,
     and continue it.  */

  if (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP)
    {
      int thread_hop_needed = 0;
      struct address_space *aspace = 
	get_regcache_aspace (get_thread_regcache (ecs->ptid));

      /* Check if a regular breakpoint has been hit before checking
         for a potential single step breakpoint.  Otherwise, GDB will
         not see this breakpoint hit when stepping onto breakpoints.  */
      if (regular_breakpoint_inserted_here_p (aspace, stop_pc))
	{
	  ecs->random_signal = 0;
	  if (!breakpoint_thread_match (aspace, stop_pc, ecs->ptid))
	    thread_hop_needed = 1;
	}
      else if (singlestep_breakpoints_inserted_p)
	{
	  /* We have not context switched yet, so this should be true
	     no matter which thread hit the singlestep breakpoint.  */
	  gdb_assert (ptid_equal (inferior_ptid, singlestep_ptid));
	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog, "infrun: software single step "
				"trap for %s\n",
				target_pid_to_str (ecs->ptid));

	  ecs->random_signal = 0;
	  /* The call to in_thread_list is necessary because PTIDs sometimes
	     change when we go from single-threaded to multi-threaded.  If
	     the singlestep_ptid is still in the list, assume that it is
	     really different from ecs->ptid.  */
	  if (!ptid_equal (singlestep_ptid, ecs->ptid)
	      && in_thread_list (singlestep_ptid))
	    {
	      /* If the PC of the thread we were trying to single-step
		 has changed, discard this event (which we were going
		 to ignore anyway), and pretend we saw that thread
		 trap.  This prevents us continuously moving the
		 single-step breakpoint forward, one instruction at a
		 time.  If the PC has changed, then the thread we were
		 trying to single-step has trapped or been signalled,
		 but the event has not been reported to GDB yet.

		 There might be some cases where this loses signal
		 information, if a signal has arrived at exactly the
		 same time that the PC changed, but this is the best
		 we can do with the information available.  Perhaps we
		 should arrange to report all events for all threads
		 when they stop, or to re-poll the remote looking for
		 this particular thread (i.e. temporarily enable
		 schedlock).  */

	     CORE_ADDR new_singlestep_pc
	       = regcache_read_pc (get_thread_regcache (singlestep_ptid));

	     if (new_singlestep_pc != singlestep_pc)
	       {
		 enum gdb_signal stop_signal;

		 if (debug_infrun)
		   fprintf_unfiltered (gdb_stdlog, "infrun: unexpected thread,"
				       " but expected thread advanced also\n");

		 /* The current context still belongs to
		    singlestep_ptid.  Don't swap here, since that's
		    the context we want to use.  Just fudge our
		    state and continue.  */
                 stop_signal = ecs->event_thread->suspend.stop_signal;
                 ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;
                 ecs->ptid = singlestep_ptid;
                 ecs->event_thread = find_thread_ptid (ecs->ptid);
                 ecs->event_thread->suspend.stop_signal = stop_signal;
                 stop_pc = new_singlestep_pc;
               }
             else
	       {
		 if (debug_infrun)
		   fprintf_unfiltered (gdb_stdlog,
				       "infrun: unexpected thread\n");

		 thread_hop_needed = 1;
		 stepping_past_singlestep_breakpoint = 1;
		 saved_singlestep_ptid = singlestep_ptid;
	       }
	    }
	}

      if (thread_hop_needed)
	{
	  struct regcache *thread_regcache;
	  int remove_status = 0;

	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog, "infrun: thread_hop_needed\n");

	  /* Switch context before touching inferior memory, the
	     previous thread may have exited.  */
	  if (!ptid_equal (inferior_ptid, ecs->ptid))
	    context_switch (ecs->ptid);

	  /* Saw a breakpoint, but it was hit by the wrong thread.
	     Just continue.  */

	  if (singlestep_breakpoints_inserted_p)
	    {
	      /* Pull the single step breakpoints out of the target.  */
	      remove_single_step_breakpoints ();
	      singlestep_breakpoints_inserted_p = 0;
	    }

	  /* If the arch can displace step, don't remove the
	     breakpoints.  */
	  thread_regcache = get_thread_regcache (ecs->ptid);
	  if (!use_displaced_stepping (get_regcache_arch (thread_regcache)))
	    remove_status = remove_breakpoints ();

	  /* Did we fail to remove breakpoints?  If so, try
	     to set the PC past the bp.  (There's at least
	     one situation in which we can fail to remove
	     the bp's: On HP-UX's that use ttrace, we can't
	     change the address space of a vforking child
	     process until the child exits (well, okay, not
	     then either :-) or execs.  */
	  if (remove_status != 0)
	    error (_("Cannot step over breakpoint hit in wrong thread"));
	  else
	    {			/* Single step */
	      if (!non_stop)
		{
		  /* Only need to require the next event from this
		     thread in all-stop mode.  */
		  waiton_ptid = ecs->ptid;
		  infwait_state = infwait_thread_hop_state;
		}

	      ecs->event_thread->stepping_over_breakpoint = 1;
	      keep_going (ecs);
	      return;
	    }
	}
      else if (singlestep_breakpoints_inserted_p)
	{
	  ecs->random_signal = 0;
	}
    }
  else
    ecs->random_signal = 1;

  /* See if something interesting happened to the non-current thread.  If
     so, then switch to that thread.  */
  if (!ptid_equal (ecs->ptid, inferior_ptid))
    {
      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog, "infrun: context switch\n");

      context_switch (ecs->ptid);

      if (deprecated_context_hook)
	deprecated_context_hook (pid_to_thread_id (ecs->ptid));
    }

  /* At this point, get hold of the now-current thread's frame.  */
  frame = get_current_frame ();
  gdbarch = get_frame_arch (frame);

  if (singlestep_breakpoints_inserted_p)
    {
      /* Pull the single step breakpoints out of the target.  */
      remove_single_step_breakpoints ();
      singlestep_breakpoints_inserted_p = 0;
    }

  if (stepped_after_stopped_by_watchpoint)
    stopped_by_watchpoint = 0;
  else
    stopped_by_watchpoint = watchpoints_triggered (&ecs->ws);

  /* If necessary, step over this watchpoint.  We'll be back to display
     it in a moment.  */
  if (stopped_by_watchpoint
      && (target_have_steppable_watchpoint
	  || gdbarch_have_nonsteppable_watchpoint (gdbarch)))
    {
      /* At this point, we are stopped at an instruction which has
         attempted to write to a piece of memory under control of
         a watchpoint.  The instruction hasn't actually executed
         yet.  If we were to evaluate the watchpoint expression
         now, we would get the old value, and therefore no change
         would seem to have occurred.

         In order to make watchpoints work `right', we really need
         to complete the memory write, and then evaluate the
         watchpoint expression.  We do this by single-stepping the
	 target.

	 It may not be necessary to disable the watchpoint to stop over
	 it.  For example, the PA can (with some kernel cooperation)
	 single step over a watchpoint without disabling the watchpoint.

	 It is far more common to need to disable a watchpoint to step
	 the inferior over it.  If we have non-steppable watchpoints,
	 we must disable the current watchpoint; it's simplest to
	 disable all watchpoints and breakpoints.  */
      int hw_step = 1;

      if (!target_have_steppable_watchpoint)
	{
	  remove_breakpoints ();
	  /* See comment in resume why we need to stop bypassing signals
	     while breakpoints have been removed.  */
	  target_pass_signals (0, NULL);
	}
	/* Single step */
      hw_step = maybe_software_singlestep (gdbarch, stop_pc);
      target_resume (ecs->ptid, hw_step, GDB_SIGNAL_0);
      waiton_ptid = ecs->ptid;
      if (target_have_steppable_watchpoint)
	infwait_state = infwait_step_watch_state;
      else
	infwait_state = infwait_nonstep_watch_state;
      prepare_to_wait (ecs);
      return;
    }

  clear_stop_func (ecs);
  ecs->event_thread->stepping_over_breakpoint = 0;
  bpstat_clear (&ecs->event_thread->control.stop_bpstat);
  ecs->event_thread->control.stop_step = 0;
  stop_print_frame = 1;
  ecs->random_signal = 0;
  stopped_by_random_signal = 0;

  /* Hide inlined functions starting here, unless we just performed stepi or
     nexti.  After stepi and nexti, always show the innermost frame (not any
     inline function call sites).  */
  if (ecs->event_thread->control.step_range_end != 1)
    {
      struct address_space *aspace = 
	get_regcache_aspace (get_thread_regcache (ecs->ptid));

      /* skip_inline_frames is expensive, so we avoid it if we can
	 determine that the address is one where functions cannot have
	 been inlined.  This improves performance with inferiors that
	 load a lot of shared libraries, because the solib event
	 breakpoint is defined as the address of a function (i.e. not
	 inline).  Note that we have to check the previous PC as well
	 as the current one to catch cases when we have just
	 single-stepped off a breakpoint prior to reinstating it.
	 Note that we're assuming that the code we single-step to is
	 not inline, but that's not definitive: there's nothing
	 preventing the event breakpoint function from containing
	 inlined code, and the single-step ending up there.  If the
	 user had set a breakpoint on that inlined code, the missing
	 skip_inline_frames call would break things.  Fortunately
	 that's an extremely unlikely scenario.  */
      if (!pc_at_non_inline_function (aspace, stop_pc, &ecs->ws)
	  && !(ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP
	       && ecs->event_thread->control.trap_expected
	       && pc_at_non_inline_function (aspace,
					     ecs->event_thread->prev_pc,
					     &ecs->ws)))
	{
	  skip_inline_frames (ecs->ptid);

	  /* Re-fetch current thread's frame in case that invalidated
	     the frame cache.  */
	  frame = get_current_frame ();
	  gdbarch = get_frame_arch (frame);
	}
    }

  if (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP
      && ecs->event_thread->control.trap_expected
      && gdbarch_single_step_through_delay_p (gdbarch)
      && currently_stepping (ecs->event_thread))
    {
      /* We're trying to step off a breakpoint.  Turns out that we're
	 also on an instruction that needs to be stepped multiple
	 times before it's been fully executing.  E.g., architectures
	 with a delay slot.  It needs to be stepped twice, once for
	 the instruction and once for the delay slot.  */
      int step_through_delay
	= gdbarch_single_step_through_delay (gdbarch, frame);

      if (debug_infrun && step_through_delay)
	fprintf_unfiltered (gdb_stdlog, "infrun: step through delay\n");
      if (ecs->event_thread->control.step_range_end == 0
	  && step_through_delay)
	{
	  /* The user issued a continue when stopped at a breakpoint.
	     Set up for another trap and get out of here.  */
         ecs->event_thread->stepping_over_breakpoint = 1;
         keep_going (ecs);
         return;
	}
      else if (step_through_delay)
	{
	  /* The user issued a step when stopped at a breakpoint.
	     Maybe we should stop, maybe we should not - the delay
	     slot *might* correspond to a line of source.  In any
	     case, don't decide that here, just set 
	     ecs->stepping_over_breakpoint, making sure we 
	     single-step again before breakpoints are re-inserted.  */
	  ecs->event_thread->stepping_over_breakpoint = 1;
	}
    }

  /* Look at the cause of the stop, and decide what to do.
     The alternatives are:
     1) stop_stepping and return; to really stop and return to the debugger,
     2) keep_going and return to start up again
     (set ecs->event_thread->stepping_over_breakpoint to 1 to single step once)
     3) set ecs->random_signal to 1, and the decision between 1 and 2
     will be made according to the signal handling tables.  */

  if (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP
      && stop_after_trap)
    {
      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog, "infrun: stopped\n");
      stop_print_frame = 0;
      stop_stepping (ecs);
      return;
    }

  /* This is originated from start_remote(), start_inferior() and
     shared libraries hook functions.  */
  if (stop_soon == STOP_QUIETLY || stop_soon == STOP_QUIETLY_REMOTE)
    {
      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog, "infrun: quietly stopped\n");
      stop_stepping (ecs);
      return;
    }

  /* This originates from attach_command().  We need to overwrite
     the stop_signal here, because some kernels don't ignore a
     SIGSTOP in a subsequent ptrace(PTRACE_CONT,SIGSTOP) call.
     See more comments in inferior.h.  On the other hand, if we
     get a non-SIGSTOP, report it to the user - assume the backend
     will handle the SIGSTOP if it should show up later.

     Also consider that the attach is complete when we see a
     SIGTRAP.  Some systems (e.g. Windows), and stubs supporting
     target extended-remote report it instead of a SIGSTOP
     (e.g. gdbserver).  We already rely on SIGTRAP being our
     signal, so this is no exception.

     Also consider that the attach is complete when we see a
     GDB_SIGNAL_0.  In non-stop mode, GDB will explicitly tell
     the target to stop all threads of the inferior, in case the
     low level attach operation doesn't stop them implicitly.  If
     they weren't stopped implicitly, then the stub will report a
     GDB_SIGNAL_0, meaning: stopped for no particular reason
     other than GDB's request.  */
  if (stop_soon == STOP_QUIETLY_NO_SIGSTOP
      && (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_STOP
	  || ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP
	  || ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_0))
    {
      stop_stepping (ecs);
      ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;
      return;
    }

  /* See if there is a breakpoint/watchpoint/catchpoint/etc. that
     handles this event.  */
  ecs->event_thread->control.stop_bpstat
    = bpstat_stop_status (get_regcache_aspace (get_current_regcache ()),
			  stop_pc, ecs->ptid, &ecs->ws);

  /* Following in case break condition called a
     function.  */
  stop_print_frame = 1;

  /* This is where we handle "moribund" watchpoints.  Unlike
     software breakpoints traps, hardware watchpoint traps are
     always distinguishable from random traps.  If no high-level
     watchpoint is associated with the reported stop data address
     anymore, then the bpstat does not explain the signal ---
     simply make sure to ignore it if `stopped_by_watchpoint' is
     set.  */

  if (debug_infrun
      && ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP
      && (bpstat_explains_signal (ecs->event_thread->control.stop_bpstat,
				  GDB_SIGNAL_TRAP)
	  == BPSTAT_SIGNAL_NO)
      && stopped_by_watchpoint)
    fprintf_unfiltered (gdb_stdlog,
			"infrun: no user watchpoint explains "
			"watchpoint SIGTRAP, ignoring\n");

  /* NOTE: cagney/2003-03-29: These two checks for a random signal
     at one stage in the past included checks for an inferior
     function call's call dummy's return breakpoint.  The original
     comment, that went with the test, read:

     ``End of a stack dummy.  Some systems (e.g. Sony news) give
     another signal besides SIGTRAP, so check here as well as
     above.''

     If someone ever tries to get call dummys on a
     non-executable stack to work (where the target would stop
     with something like a SIGSEGV), then those tests might need
     to be re-instated.  Given, however, that the tests were only
     enabled when momentary breakpoints were not being used, I
     suspect that it won't be the case.

     NOTE: kettenis/2004-02-05: Indeed such checks don't seem to
     be necessary for call dummies on a non-executable stack on
     SPARC.  */

  if (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP)
    ecs->random_signal
      = !((bpstat_explains_signal (ecs->event_thread->control.stop_bpstat,
				   GDB_SIGNAL_TRAP)
	   != BPSTAT_SIGNAL_NO)
	  || stopped_by_watchpoint
	  || ecs->event_thread->control.trap_expected
	  || (ecs->event_thread->control.step_range_end
	      && (ecs->event_thread->control.step_resume_breakpoint
		  == NULL)));
  else
    {
      enum bpstat_signal_value sval;

      sval = bpstat_explains_signal (ecs->event_thread->control.stop_bpstat,
				     ecs->event_thread->suspend.stop_signal);
      ecs->random_signal = (sval == BPSTAT_SIGNAL_NO);

      if (sval == BPSTAT_SIGNAL_HIDE)
	ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_TRAP;
    }

process_event_stop_test:

  /* Re-fetch current thread's frame in case we did a
     "goto process_event_stop_test" above.  */
  frame = get_current_frame ();
  gdbarch = get_frame_arch (frame);

  /* For the program's own signals, act according to
     the signal handling tables.  */

  if (ecs->random_signal)
    {
      /* Signal not for debugging purposes.  */
      int printed = 0;
      struct inferior *inf = find_inferior_pid (ptid_get_pid (ecs->ptid));

      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog, "infrun: random signal %d\n",
			     ecs->event_thread->suspend.stop_signal);

      stopped_by_random_signal = 1;

      if (signal_print[ecs->event_thread->suspend.stop_signal])
	{
	  printed = 1;
	  target_terminal_ours_for_output ();
	  print_signal_received_reason
				     (ecs->event_thread->suspend.stop_signal);
	}
      /* Always stop on signals if we're either just gaining control
	 of the program, or the user explicitly requested this thread
	 to remain stopped.  */
      if (stop_soon != NO_STOP_QUIETLY
	  || ecs->event_thread->stop_requested
	  || (!inf->detaching
	      && signal_stop_state (ecs->event_thread->suspend.stop_signal)))
	{
	  stop_stepping (ecs);
	  return;
	}
      /* If not going to stop, give terminal back
         if we took it away.  */
      else if (printed)
	target_terminal_inferior ();

      /* Clear the signal if it should not be passed.  */
      if (signal_program[ecs->event_thread->suspend.stop_signal] == 0)
	ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;

      if (ecs->event_thread->prev_pc == stop_pc
	  && ecs->event_thread->control.trap_expected
	  && ecs->event_thread->control.step_resume_breakpoint == NULL)
	{
	  /* We were just starting a new sequence, attempting to
	     single-step off of a breakpoint and expecting a SIGTRAP.
	     Instead this signal arrives.  This signal will take us out
	     of the stepping range so GDB needs to remember to, when
	     the signal handler returns, resume stepping off that
	     breakpoint.  */
	  /* To simplify things, "continue" is forced to use the same
	     code paths as single-step - set a breakpoint at the
	     signal return address and then, once hit, step off that
	     breakpoint.  */
          if (debug_infrun)
            fprintf_unfiltered (gdb_stdlog,
                                "infrun: signal arrived while stepping over "
                                "breakpoint\n");

	  insert_hp_step_resume_breakpoint_at_frame (frame);
	  ecs->event_thread->step_after_step_resume_breakpoint = 1;
	  /* Reset trap_expected to ensure breakpoints are re-inserted.  */
	  ecs->event_thread->control.trap_expected = 0;
	  keep_going (ecs);
	  return;
	}

      if (ecs->event_thread->control.step_range_end != 0
	  && ecs->event_thread->suspend.stop_signal != GDB_SIGNAL_0
	  && pc_in_thread_step_range (stop_pc, ecs->event_thread)
	  && frame_id_eq (get_stack_frame_id (frame),
			  ecs->event_thread->control.step_stack_frame_id)
	  && ecs->event_thread->control.step_resume_breakpoint == NULL)
	{
	  /* The inferior is about to take a signal that will take it
	     out of the single step range.  Set a breakpoint at the
	     current PC (which is presumably where the signal handler
	     will eventually return) and then allow the inferior to
	     run free.

	     Note that this is only needed for a signal delivered
	     while in the single-step range.  Nested signals aren't a
	     problem as they eventually all return.  */
          if (debug_infrun)
            fprintf_unfiltered (gdb_stdlog,
                                "infrun: signal may take us out of "
                                "single-step range\n");

	  insert_hp_step_resume_breakpoint_at_frame (frame);
	  /* Reset trap_expected to ensure breakpoints are re-inserted.  */
	  ecs->event_thread->control.trap_expected = 0;
	  keep_going (ecs);
	  return;
	}

      /* Note: step_resume_breakpoint may be non-NULL.  This occures
	 when either there's a nested signal, or when there's a
	 pending signal enabled just as the signal handler returns
	 (leaving the inferior at the step-resume-breakpoint without
	 actually executing it).  Either way continue until the
	 breakpoint is really hit.  */
    }
  else
    {
      /* Handle cases caused by hitting a breakpoint.  */

      CORE_ADDR jmp_buf_pc;
      struct bpstat_what what;

      what = bpstat_what (ecs->event_thread->control.stop_bpstat);

      if (what.call_dummy)
	{
	  stop_stack_dummy = what.call_dummy;
	}

      /* If we hit an internal event that triggers symbol changes, the
	 current frame will be invalidated within bpstat_what (e.g.,
	 if we hit an internal solib event).  Re-fetch it.  */
      frame = get_current_frame ();
      gdbarch = get_frame_arch (frame);

      switch (what.main_action)
	{
	case BPSTAT_WHAT_SET_LONGJMP_RESUME:
	  /* If we hit the breakpoint at longjmp while stepping, we
	     install a momentary breakpoint at the target of the
	     jmp_buf.  */

	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog,
				"infrun: BPSTAT_WHAT_SET_LONGJMP_RESUME\n");

	  ecs->event_thread->stepping_over_breakpoint = 1;

	  if (what.is_longjmp)
	    {
	      struct value *arg_value;

	      /* If we set the longjmp breakpoint via a SystemTap
		 probe, then use it to extract the arguments.  The
		 destination PC is the third argument to the
		 probe.  */
	      arg_value = probe_safe_evaluate_at_pc (frame, 2);
	      if (arg_value)
		jmp_buf_pc = value_as_address (arg_value);
	      else if (!gdbarch_get_longjmp_target_p (gdbarch)
		       || !gdbarch_get_longjmp_target (gdbarch,
						       frame, &jmp_buf_pc))
		{
		  if (debug_infrun)
		    fprintf_unfiltered (gdb_stdlog,
					"infrun: BPSTAT_WHAT_SET_LONGJMP_RESUME "
					"(!gdbarch_get_longjmp_target)\n");
		  keep_going (ecs);
		  return;
		}

	      /* Insert a breakpoint at resume address.  */
	      insert_longjmp_resume_breakpoint (gdbarch, jmp_buf_pc);
	    }
	  else
	    check_exception_resume (ecs, frame);
	  keep_going (ecs);
	  return;

	case BPSTAT_WHAT_CLEAR_LONGJMP_RESUME:
	  {
	    struct frame_info *init_frame;

	    /* There are several cases to consider.

	       1. The initiating frame no longer exists.  In this case
	       we must stop, because the exception or longjmp has gone
	       too far.

	       2. The initiating frame exists, and is the same as the
	       current frame.  We stop, because the exception or
	       longjmp has been caught.

	       3. The initiating frame exists and is different from
	       the current frame.  This means the exception or longjmp
	       has been caught beneath the initiating frame, so keep
	       going.

	       4. longjmp breakpoint has been placed just to protect
	       against stale dummy frames and user is not interested
	       in stopping around longjmps.  */

	    if (debug_infrun)
	      fprintf_unfiltered (gdb_stdlog,
				  "infrun: BPSTAT_WHAT_CLEAR_LONGJMP_RESUME\n");

	    gdb_assert (ecs->event_thread->control.exception_resume_breakpoint
			!= NULL);
	    delete_exception_resume_breakpoint (ecs->event_thread);

	    if (what.is_longjmp)
	      {
		check_longjmp_breakpoint_for_call_dummy (ecs->event_thread->num);

		if (!frame_id_p (ecs->event_thread->initiating_frame))
		  {
		    /* Case 4.  */
		    keep_going (ecs);
		    return;
		  }
	      }

	    init_frame = frame_find_by_id (ecs->event_thread->initiating_frame);

	    if (init_frame)
	      {
		struct frame_id current_id
		  = get_frame_id (get_current_frame ());
		if (frame_id_eq (current_id,
				 ecs->event_thread->initiating_frame))
		  {
		    /* Case 2.  Fall through.  */
		  }
		else
		  {
		    /* Case 3.  */
		    keep_going (ecs);
		    return;
		  }
	      }

	    /* For Cases 1 and 2, remove the step-resume breakpoint,
	       if it exists.  */
	    delete_step_resume_breakpoint (ecs->event_thread);

	    ecs->event_thread->control.stop_step = 1;
	    print_end_stepping_range_reason ();
	    stop_stepping (ecs);
	  }
	  return;

	case BPSTAT_WHAT_SINGLE:
	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_SINGLE\n");
	  ecs->event_thread->stepping_over_breakpoint = 1;
	  /* Still need to check other stuff, at least the case where
	     we are stepping and step out of the right range.  */
	  break;

	case BPSTAT_WHAT_STEP_RESUME:
	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_STEP_RESUME\n");

	  delete_step_resume_breakpoint (ecs->event_thread);
	  if (ecs->event_thread->control.proceed_to_finish
	      && execution_direction == EXEC_REVERSE)
	    {
	      struct thread_info *tp = ecs->event_thread;

	      /* We are finishing a function in reverse, and just hit
		 the step-resume breakpoint at the start address of
		 the function, and we're almost there -- just need to
		 back up by one more single-step, which should take us
		 back to the function call.  */
	      tp->control.step_range_start = tp->control.step_range_end = 1;
	      keep_going (ecs);
	      return;
	    }
	  fill_in_stop_func (gdbarch, ecs);
	  if (stop_pc == ecs->stop_func_start
	      && execution_direction == EXEC_REVERSE)
	    {
	      /* We are stepping over a function call in reverse, and
		 just hit the step-resume breakpoint at the start
		 address of the function.  Go back to single-stepping,
		 which should take us back to the function call.  */
	      ecs->event_thread->stepping_over_breakpoint = 1;
	      keep_going (ecs);
	      return;
	    }
	  break;

	case BPSTAT_WHAT_STOP_NOISY:
	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_STOP_NOISY\n");
	  stop_print_frame = 1;

	  /* We are about to nuke the step_resume_breakpointt via the
	     cleanup chain, so no need to worry about it here.  */

	  stop_stepping (ecs);
	  return;

	case BPSTAT_WHAT_STOP_SILENT:
	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_STOP_SILENT\n");
	  stop_print_frame = 0;

	  /* We are about to nuke the step_resume_breakpoin via the
	     cleanup chain, so no need to worry about it here.  */

	  stop_stepping (ecs);
	  return;

	case BPSTAT_WHAT_HP_STEP_RESUME:
	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_HP_STEP_RESUME\n");

	  delete_step_resume_breakpoint (ecs->event_thread);
	  if (ecs->event_thread->step_after_step_resume_breakpoint)
	    {
	      /* Back when the step-resume breakpoint was inserted, we
		 were trying to single-step off a breakpoint.  Go back
		 to doing that.  */
	      ecs->event_thread->step_after_step_resume_breakpoint = 0;
	      ecs->event_thread->stepping_over_breakpoint = 1;
	      keep_going (ecs);
	      return;
	    }
	  break;

	case BPSTAT_WHAT_KEEP_CHECKING:
	  break;
	}
    }

  /* We come here if we hit a breakpoint but should not
     stop for it.  Possibly we also were stepping
     and should stop for that.  So fall through and
     test for stepping.  But, if not stepping,
     do not stop.  */

  /* In all-stop mode, if we're currently stepping but have stopped in
     some other thread, we need to switch back to the stepped thread.  */
  if (!non_stop)
    {
      struct thread_info *tp;

      tp = iterate_over_threads (currently_stepping_or_nexting_callback,
				 ecs->event_thread);
      if (tp)
	{
	  /* However, if the current thread is blocked on some internal
	     breakpoint, and we simply need to step over that breakpoint
	     to get it going again, do that first.  */
	  if ((ecs->event_thread->control.trap_expected
	       && ecs->event_thread->suspend.stop_signal != GDB_SIGNAL_TRAP)
	      || ecs->event_thread->stepping_over_breakpoint)
	    {
	      keep_going (ecs);
	      return;
	    }

	  /* If the stepping thread exited, then don't try to switch
	     back and resume it, which could fail in several different
	     ways depending on the target.  Instead, just keep going.

	     We can find a stepping dead thread in the thread list in
	     two cases:

	     - The target supports thread exit events, and when the
	     target tries to delete the thread from the thread list,
	     inferior_ptid pointed at the exiting thread.  In such
	     case, calling delete_thread does not really remove the
	     thread from the list; instead, the thread is left listed,
	     with 'exited' state.

	     - The target's debug interface does not support thread
	     exit events, and so we have no idea whatsoever if the
	     previously stepping thread is still alive.  For that
	     reason, we need to synchronously query the target
	     now.  */
	  if (is_exited (tp->ptid)
	      || !target_thread_alive (tp->ptid))
	    {
	      if (debug_infrun)
		fprintf_unfiltered (gdb_stdlog,
				    "infrun: not switching back to "
				    "stepped thread, it has vanished\n");

	      delete_thread (tp->ptid);
	      keep_going (ecs);
	      return;
	    }

	  /* Otherwise, we no longer expect a trap in the current thread.
	     Clear the trap_expected flag before switching back -- this is
	     what keep_going would do as well, if we called it.  */
	  ecs->event_thread->control.trap_expected = 0;

	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog,
				"infrun: switching back to stepped thread\n");

	  ecs->event_thread = tp;
	  ecs->ptid = tp->ptid;
	  context_switch (ecs->ptid);
	  keep_going (ecs);
	  return;
	}
    }

  if (ecs->random_signal)
    {
      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog,
			     "infrun: random signal, keep going\n");

      /* Signal not stepping related.  */
      keep_going (ecs);
      return;
    }

  if (ecs->event_thread->control.step_resume_breakpoint)
    {
      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog,
			     "infrun: step-resume breakpoint is inserted\n");

      /* Having a step-resume breakpoint overrides anything
         else having to do with stepping commands until
         that breakpoint is reached.  */
      keep_going (ecs);
      return;
    }

  if (ecs->event_thread->control.step_range_end == 0)
    {
      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog, "infrun: no stepping, continue\n");
      /* Likewise if we aren't even stepping.  */
      keep_going (ecs);
      return;
    }

  /* Re-fetch current thread's frame in case the code above caused
     the frame cache to be re-initialized, making our FRAME variable
     a dangling pointer.  */
  frame = get_current_frame ();
  gdbarch = get_frame_arch (frame);
  fill_in_stop_func (gdbarch, ecs);

  /* If stepping through a line, keep going if still within it.

     Note that step_range_end is the address of the first instruction
     beyond the step range, and NOT the address of the last instruction
     within it!

     Note also that during reverse execution, we may be stepping
     through a function epilogue and therefore must detect when
     the current-frame changes in the middle of a line.  */

  if (pc_in_thread_step_range (stop_pc, ecs->event_thread)
      && (execution_direction != EXEC_REVERSE
	  || frame_id_eq (get_frame_id (frame),
			  ecs->event_thread->control.step_frame_id)))
    {
      if (debug_infrun)
	fprintf_unfiltered
	  (gdb_stdlog, "infrun: stepping inside range [%s-%s]\n",
	   paddress (gdbarch, ecs->event_thread->control.step_range_start),
	   paddress (gdbarch, ecs->event_thread->control.step_range_end));

      /* Tentatively re-enable range stepping; `resume' disables it if
	 necessary (e.g., if we're stepping over a breakpoint or we
	 have software watchpoints).  */
      ecs->event_thread->control.may_range_step = 1;

      /* When stepping backward, stop at beginning of line range
	 (unless it's the function entry point, in which case
	 keep going back to the call point).  */
      if (stop_pc == ecs->event_thread->control.step_range_start
	  && stop_pc != ecs->stop_func_start
	  && execution_direction == EXEC_REVERSE)
	{
	  ecs->event_thread->control.stop_step = 1;
	  print_end_stepping_range_reason ();
	  stop_stepping (ecs);
	}
      else
	keep_going (ecs);

      return;
    }

  /* We stepped out of the stepping range.  */

  /* If we are stepping at the source level and entered the runtime
     loader dynamic symbol resolution code...

     EXEC_FORWARD: we keep on single stepping until we exit the run
     time loader code and reach the callee's address.

     EXEC_REVERSE: we've already executed the callee (backward), and
     the runtime loader code is handled just like any other
     undebuggable function call.  Now we need only keep stepping
     backward through the trampoline code, and that's handled further
     down, so there is nothing for us to do here.  */

  if (execution_direction != EXEC_REVERSE
      && ecs->event_thread->control.step_over_calls == STEP_OVER_UNDEBUGGABLE
      && in_solib_dynsym_resolve_code (stop_pc))
    {
      CORE_ADDR pc_after_resolver =
	gdbarch_skip_solib_resolver (gdbarch, stop_pc);

      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog,
			     "infrun: stepped into dynsym resolve code\n");

      if (pc_after_resolver)
	{
	  /* Set up a step-resume breakpoint at the address
	     indicated by SKIP_SOLIB_RESOLVER.  */
	  struct symtab_and_line sr_sal;

	  init_sal (&sr_sal);
	  sr_sal.pc = pc_after_resolver;
	  sr_sal.pspace = get_frame_program_space (frame);

	  insert_step_resume_breakpoint_at_sal (gdbarch,
						sr_sal, null_frame_id);
	}

      keep_going (ecs);
      return;
    }

  if (ecs->event_thread->control.step_range_end != 1
      && (ecs->event_thread->control.step_over_calls == STEP_OVER_UNDEBUGGABLE
	  || ecs->event_thread->control.step_over_calls == STEP_OVER_ALL)
      && get_frame_type (frame) == SIGTRAMP_FRAME)
    {
      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog,
			     "infrun: stepped into signal trampoline\n");
      /* The inferior, while doing a "step" or "next", has ended up in
         a signal trampoline (either by a signal being delivered or by
         the signal handler returning).  Just single-step until the
         inferior leaves the trampoline (either by calling the handler
         or returning).  */
      keep_going (ecs);
      return;
    }

  /* If we're in the return path from a shared library trampoline,
     we want to proceed through the trampoline when stepping.  */
  /* macro/2012-04-25: This needs to come before the subroutine
     call check below as on some targets return trampolines look
     like subroutine calls (MIPS16 return thunks).  */
  if (gdbarch_in_solib_return_trampoline (gdbarch,
					  stop_pc, ecs->stop_func_name)
      && ecs->event_thread->control.step_over_calls != STEP_OVER_NONE)
    {
      /* Determine where this trampoline returns.  */
      CORE_ADDR real_stop_pc;

      real_stop_pc = gdbarch_skip_trampoline_code (gdbarch, frame, stop_pc);

      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog,
			     "infrun: stepped into solib return tramp\n");

      /* Only proceed through if we know where it's going.  */
      if (real_stop_pc)
	{
	  /* And put the step-breakpoint there and go until there.  */
	  struct symtab_and_line sr_sal;

	  init_sal (&sr_sal);	/* initialize to zeroes */
	  sr_sal.pc = real_stop_pc;
	  sr_sal.section = find_pc_overlay (sr_sal.pc);
	  sr_sal.pspace = get_frame_program_space (frame);

	  /* Do not specify what the fp should be when we stop since
	     on some machines the prologue is where the new fp value
	     is established.  */
	  insert_step_resume_breakpoint_at_sal (gdbarch,
						sr_sal, null_frame_id);

	  /* Restart without fiddling with the step ranges or
	     other state.  */
	  keep_going (ecs);
	  return;
	}
    }

  /* Check for subroutine calls.  The check for the current frame
     equalling the step ID is not necessary - the check of the
     previous frame's ID is sufficient - but it is a common case and
     cheaper than checking the previous frame's ID.

     NOTE: frame_id_eq will never report two invalid frame IDs as
     being equal, so to get into this block, both the current and
     previous frame must have valid frame IDs.  */
  /* The outer_frame_id check is a heuristic to detect stepping
     through startup code.  If we step over an instruction which
     sets the stack pointer from an invalid value to a valid value,
     we may detect that as a subroutine call from the mythical
     "outermost" function.  This could be fixed by marking
     outermost frames as !stack_p,code_p,special_p.  Then the
     initial outermost frame, before sp was valid, would
     have code_addr == &_start.  See the comment in frame_id_eq
     for more.  */
  if (!frame_id_eq (get_stack_frame_id (frame),
		    ecs->event_thread->control.step_stack_frame_id)
      && (frame_id_eq (frame_unwind_caller_id (get_current_frame ()),
		       ecs->event_thread->control.step_stack_frame_id)
	  && (!frame_id_eq (ecs->event_thread->control.step_stack_frame_id,
			    outer_frame_id)
	      || step_start_function != find_pc_function (stop_pc))))
    {
      CORE_ADDR real_stop_pc;

      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog, "infrun: stepped into subroutine\n");

      if ((ecs->event_thread->control.step_over_calls == STEP_OVER_NONE)
	  || ((ecs->event_thread->control.step_range_end == 1)
	      && in_prologue (gdbarch, ecs->event_thread->prev_pc,
			      ecs->stop_func_start)))
	{
	  /* I presume that step_over_calls is only 0 when we're
	     supposed to be stepping at the assembly language level
	     ("stepi").  Just stop.  */
	  /* Also, maybe we just did a "nexti" inside a prolog, so we
	     thought it was a subroutine call but it was not.  Stop as
	     well.  FENN */
	  /* And this works the same backward as frontward.  MVS */
	  ecs->event_thread->control.stop_step = 1;
	  print_end_stepping_range_reason ();
	  stop_stepping (ecs);
	  return;
	}

      /* Reverse stepping through solib trampolines.  */

      if (execution_direction == EXEC_REVERSE
	  && ecs->event_thread->control.step_over_calls != STEP_OVER_NONE
	  && (gdbarch_skip_trampoline_code (gdbarch, frame, stop_pc)
	      || (ecs->stop_func_start == 0
		  && in_solib_dynsym_resolve_code (stop_pc))))
	{
	  /* Any solib trampoline code can be handled in reverse
	     by simply continuing to single-step.  We have already
	     executed the solib function (backwards), and a few 
	     steps will take us back through the trampoline to the
	     caller.  */
	  keep_going (ecs);
	  return;
	}

      if (ecs->event_thread->control.step_over_calls == STEP_OVER_ALL)
	{
	  /* We're doing a "next".

	     Normal (forward) execution: set a breakpoint at the
	     callee's return address (the address at which the caller
	     will resume).

	     Reverse (backward) execution.  set the step-resume
	     breakpoint at the start of the function that we just
	     stepped into (backwards), and continue to there.  When we
	     get there, we'll need to single-step back to the caller.  */

	  if (execution_direction == EXEC_REVERSE)
	    {
	      /* If we're already at the start of the function, we've either
		 just stepped backward into a single instruction function,
		 or stepped back out of a signal handler to the first instruction
		 of the function.  Just keep going, which will single-step back
		 to the caller.  */
	      if (ecs->stop_func_start != stop_pc && ecs->stop_func_start != 0)
		{
		  struct symtab_and_line sr_sal;

		  /* Normal function call return (static or dynamic).  */
		  init_sal (&sr_sal);
		  sr_sal.pc = ecs->stop_func_start;
		  sr_sal.pspace = get_frame_program_space (frame);
		  insert_step_resume_breakpoint_at_sal (gdbarch,
							sr_sal, null_frame_id);
		}
	    }
	  else
	    insert_step_resume_breakpoint_at_caller (frame);

	  keep_going (ecs);
	  return;
	}

      /* If we are in a function call trampoline (a stub between the
         calling routine and the real function), locate the real
         function.  That's what tells us (a) whether we want to step
         into it at all, and (b) what prologue we want to run to the
         end of, if we do step into it.  */
      real_stop_pc = skip_language_trampoline (frame, stop_pc);
      if (real_stop_pc == 0)
	real_stop_pc = gdbarch_skip_trampoline_code (gdbarch, frame, stop_pc);
      if (real_stop_pc != 0)
	ecs->stop_func_start = real_stop_pc;

      if (real_stop_pc != 0 && in_solib_dynsym_resolve_code (real_stop_pc))
	{
	  struct symtab_and_line sr_sal;

	  init_sal (&sr_sal);
	  sr_sal.pc = ecs->stop_func_start;
	  sr_sal.pspace = get_frame_program_space (frame);

	  insert_step_resume_breakpoint_at_sal (gdbarch,
						sr_sal, null_frame_id);
	  keep_going (ecs);
	  return;
	}

      /* If we have line number information for the function we are
	 thinking of stepping into and the function isn't on the skip
	 list, step into it.

         If there are several symtabs at that PC (e.g. with include
         files), just want to know whether *any* of them have line
         numbers.  find_pc_line handles this.  */
      {
	struct symtab_and_line tmp_sal;

	tmp_sal = find_pc_line (ecs->stop_func_start, 0);
	if (tmp_sal.line != 0
	    && !function_name_is_marked_for_skip (ecs->stop_func_name,
						  &tmp_sal))
	  {
	    if (execution_direction == EXEC_REVERSE)
	      handle_step_into_function_backward (gdbarch, ecs);
	    else
	      handle_step_into_function (gdbarch, ecs);
	    return;
	  }
      }

      /* If we have no line number and the step-stop-if-no-debug is
         set, we stop the step so that the user has a chance to switch
         in assembly mode.  */
      if (ecs->event_thread->control.step_over_calls == STEP_OVER_UNDEBUGGABLE
	  && step_stop_if_no_debug)
	{
	  ecs->event_thread->control.stop_step = 1;
	  print_end_stepping_range_reason ();
	  stop_stepping (ecs);
	  return;
	}

      if (execution_direction == EXEC_REVERSE)
	{
	  /* If we're already at the start of the function, we've either just
	     stepped backward into a single instruction function without line
	     number info, or stepped back out of a signal handler to the first
	     instruction of the function without line number info.  Just keep
	     going, which will single-step back to the caller.  */
	  if (ecs->stop_func_start != stop_pc)
	    {
	      /* Set a breakpoint at callee's start address.
		 From there we can step once and be back in the caller.  */
	      struct symtab_and_line sr_sal;

	      init_sal (&sr_sal);
	      sr_sal.pc = ecs->stop_func_start;
	      sr_sal.pspace = get_frame_program_space (frame);
	      insert_step_resume_breakpoint_at_sal (gdbarch,
						    sr_sal, null_frame_id);
	    }
	}
      else
	/* Set a breakpoint at callee's return address (the address
	   at which the caller will resume).  */
	insert_step_resume_breakpoint_at_caller (frame);

      keep_going (ecs);
      return;
    }

  /* Reverse stepping through solib trampolines.  */

  if (execution_direction == EXEC_REVERSE
      && ecs->event_thread->control.step_over_calls != STEP_OVER_NONE)
    {
      if (gdbarch_skip_trampoline_code (gdbarch, frame, stop_pc)
	  || (ecs->stop_func_start == 0
	      && in_solib_dynsym_resolve_code (stop_pc)))
	{
	  /* Any solib trampoline code can be handled in reverse
	     by simply continuing to single-step.  We have already
	     executed the solib function (backwards), and a few 
	     steps will take us back through the trampoline to the
	     caller.  */
	  keep_going (ecs);
	  return;
	}
      else if (in_solib_dynsym_resolve_code (stop_pc))
	{
	  /* Stepped backward into the solib dynsym resolver.
	     Set a breakpoint at its start and continue, then
	     one more step will take us out.  */
	  struct symtab_and_line sr_sal;

	  init_sal (&sr_sal);
	  sr_sal.pc = ecs->stop_func_start;
	  sr_sal.pspace = get_frame_program_space (frame);
	  insert_step_resume_breakpoint_at_sal (gdbarch, 
						sr_sal, null_frame_id);
	  keep_going (ecs);
	  return;
	}
    }

  stop_pc_sal = find_pc_line (stop_pc, 0);

  /* NOTE: tausq/2004-05-24: This if block used to be done before all
     the trampoline processing logic, however, there are some trampolines 
     that have no names, so we should do trampoline handling first.  */
  if (ecs->event_thread->control.step_over_calls == STEP_OVER_UNDEBUGGABLE
      && ecs->stop_func_name == NULL
      && stop_pc_sal.line == 0)
    {
      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog,
			     "infrun: stepped into undebuggable function\n");

      /* The inferior just stepped into, or returned to, an
         undebuggable function (where there is no debugging information
         and no line number corresponding to the address where the
         inferior stopped).  Since we want to skip this kind of code,
         we keep going until the inferior returns from this
         function - unless the user has asked us not to (via
         set step-mode) or we no longer know how to get back
         to the call site.  */
      if (step_stop_if_no_debug
	  || !frame_id_p (frame_unwind_caller_id (frame)))
	{
	  /* If we have no line number and the step-stop-if-no-debug
	     is set, we stop the step so that the user has a chance to
	     switch in assembly mode.  */
	  ecs->event_thread->control.stop_step = 1;
	  print_end_stepping_range_reason ();
	  stop_stepping (ecs);
	  return;
	}
      else
	{
	  /* Set a breakpoint at callee's return address (the address
	     at which the caller will resume).  */
	  insert_step_resume_breakpoint_at_caller (frame);
	  keep_going (ecs);
	  return;
	}
    }

  if (ecs->event_thread->control.step_range_end == 1)
    {
      /* It is stepi or nexti.  We always want to stop stepping after
         one instruction.  */
      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog, "infrun: stepi/nexti\n");
      ecs->event_thread->control.stop_step = 1;
      print_end_stepping_range_reason ();
      stop_stepping (ecs);
      return;
    }

  if (stop_pc_sal.line == 0)
    {
      /* We have no line number information.  That means to stop
         stepping (does this always happen right after one instruction,
         when we do "s" in a function with no line numbers,
         or can this happen as a result of a return or longjmp?).  */
      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog, "infrun: no line number info\n");
      ecs->event_thread->control.stop_step = 1;
      print_end_stepping_range_reason ();
      stop_stepping (ecs);
      return;
    }

  /* Look for "calls" to inlined functions, part one.  If the inline
     frame machinery detected some skipped call sites, we have entered
     a new inline function.  */

  if (frame_id_eq (get_frame_id (get_current_frame ()),
		   ecs->event_thread->control.step_frame_id)
      && inline_skipped_frames (ecs->ptid))
    {
      struct symtab_and_line call_sal;

      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog,
			    "infrun: stepped into inlined function\n");

      find_frame_sal (get_current_frame (), &call_sal);

      if (ecs->event_thread->control.step_over_calls != STEP_OVER_ALL)
	{
	  /* For "step", we're going to stop.  But if the call site
	     for this inlined function is on the same source line as
	     we were previously stepping, go down into the function
	     first.  Otherwise stop at the call site.  */

	  if (call_sal.line == ecs->event_thread->current_line
	      && call_sal.symtab == ecs->event_thread->current_symtab)
	    step_into_inline_frame (ecs->ptid);

	  ecs->event_thread->control.stop_step = 1;
	  print_end_stepping_range_reason ();
	  stop_stepping (ecs);
	  return;
	}
      else
	{
	  /* For "next", we should stop at the call site if it is on a
	     different source line.  Otherwise continue through the
	     inlined function.  */
	  if (call_sal.line == ecs->event_thread->current_line
	      && call_sal.symtab == ecs->event_thread->current_symtab)
	    keep_going (ecs);
	  else
	    {
	      ecs->event_thread->control.stop_step = 1;
	      print_end_stepping_range_reason ();
	      stop_stepping (ecs);
	    }
	  return;
	}
    }

  /* Look for "calls" to inlined functions, part two.  If we are still
     in the same real function we were stepping through, but we have
     to go further up to find the exact frame ID, we are stepping
     through a more inlined call beyond its call site.  */

  if (get_frame_type (get_current_frame ()) == INLINE_FRAME
      && !frame_id_eq (get_frame_id (get_current_frame ()),
		       ecs->event_thread->control.step_frame_id)
      && stepped_in_from (get_current_frame (),
			  ecs->event_thread->control.step_frame_id))
    {
      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog,
			    "infrun: stepping through inlined function\n");

      if (ecs->event_thread->control.step_over_calls == STEP_OVER_ALL)
	keep_going (ecs);
      else
	{
	  ecs->event_thread->control.stop_step = 1;
	  print_end_stepping_range_reason ();
	  stop_stepping (ecs);
	}
      return;
    }

  if ((stop_pc == stop_pc_sal.pc)
      && (ecs->event_thread->current_line != stop_pc_sal.line
 	  || ecs->event_thread->current_symtab != stop_pc_sal.symtab))
    {
      /* We are at the start of a different line.  So stop.  Note that
         we don't stop if we step into the middle of a different line.
         That is said to make things like for (;;) statements work
         better.  */
      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog,
			     "infrun: stepped to a different line\n");
      ecs->event_thread->control.stop_step = 1;
      print_end_stepping_range_reason ();
      stop_stepping (ecs);
      return;
    }

  /* We aren't done stepping.

     Optimize by setting the stepping range to the line.
     (We might not be in the original line, but if we entered a
     new line in mid-statement, we continue stepping.  This makes
     things like for(;;) statements work better.)  */

  ecs->event_thread->control.step_range_start = stop_pc_sal.pc;
  ecs->event_thread->control.step_range_end = stop_pc_sal.end;
  ecs->event_thread->control.may_range_step = 1;
  set_step_info (frame, stop_pc_sal);

  if (debug_infrun)
     fprintf_unfiltered (gdb_stdlog, "infrun: keep going\n");
  keep_going (ecs);
}

/* Is thread TP in the middle of single-stepping?  */

static int
currently_stepping (struct thread_info *tp)
{
  return ((tp->control.step_range_end
	   && tp->control.step_resume_breakpoint == NULL)
	  || tp->control.trap_expected
	  || bpstat_should_step ());
}

/* Returns true if any thread *but* the one passed in "data" is in the
   middle of stepping or of handling a "next".  */

static int
currently_stepping_or_nexting_callback (struct thread_info *tp, void *data)
{
  if (tp == data)
    return 0;

  return (tp->control.step_range_end
 	  || tp->control.trap_expected);
}

/* Inferior has stepped into a subroutine call with source code that
   we should not step over.  Do step to the first line of code in
   it.  */

static void
handle_step_into_function (struct gdbarch *gdbarch,
			   struct execution_control_state *ecs)
{
  struct symtab *s;
  struct symtab_and_line stop_func_sal, sr_sal;

  fill_in_stop_func (gdbarch, ecs);

  s = find_pc_symtab (stop_pc);
  if (s && s->language != language_asm)
    ecs->stop_func_start = gdbarch_skip_prologue (gdbarch,
						  ecs->stop_func_start);

  stop_func_sal = find_pc_line (ecs->stop_func_start, 0);
  /* Use the step_resume_break to step until the end of the prologue,
     even if that involves jumps (as it seems to on the vax under
     4.2).  */
  /* If the prologue ends in the middle of a source line, continue to
     the end of that source line (if it is still within the function).
     Otherwise, just go to end of prologue.  */
  if (stop_func_sal.end
      && stop_func_sal.pc != ecs->stop_func_start
      && stop_func_sal.end < ecs->stop_func_end)
    ecs->stop_func_start = stop_func_sal.end;

  /* Architectures which require breakpoint adjustment might not be able
     to place a breakpoint at the computed address.  If so, the test
     ``ecs->stop_func_start == stop_pc'' will never succeed.  Adjust
     ecs->stop_func_start to an address at which a breakpoint may be
     legitimately placed.

     Note:  kevinb/2004-01-19:  On FR-V, if this adjustment is not
     made, GDB will enter an infinite loop when stepping through
     optimized code consisting of VLIW instructions which contain
     subinstructions corresponding to different source lines.  On
     FR-V, it's not permitted to place a breakpoint on any but the
     first subinstruction of a VLIW instruction.  When a breakpoint is
     set, GDB will adjust the breakpoint address to the beginning of
     the VLIW instruction.  Thus, we need to make the corresponding
     adjustment here when computing the stop address.  */

  if (gdbarch_adjust_breakpoint_address_p (gdbarch))
    {
      ecs->stop_func_start
	= gdbarch_adjust_breakpoint_address (gdbarch,
					     ecs->stop_func_start);
    }

  if (ecs->stop_func_start == stop_pc)
    {
      /* We are already there: stop now.  */
      ecs->event_thread->control.stop_step = 1;
      print_end_stepping_range_reason ();
      stop_stepping (ecs);
      return;
    }
  else
    {
      /* Put the step-breakpoint there and go until there.  */
      init_sal (&sr_sal);	/* initialize to zeroes */
      sr_sal.pc = ecs->stop_func_start;
      sr_sal.section = find_pc_overlay (ecs->stop_func_start);
      sr_sal.pspace = get_frame_program_space (get_current_frame ());

      /* Do not specify what the fp should be when we stop since on
         some machines the prologue is where the new fp value is
         established.  */
      insert_step_resume_breakpoint_at_sal (gdbarch, sr_sal, null_frame_id);

      /* And make sure stepping stops right away then.  */
      ecs->event_thread->control.step_range_end
        = ecs->event_thread->control.step_range_start;
    }
  keep_going (ecs);
}

/* Inferior has stepped backward into a subroutine call with source
   code that we should not step over.  Do step to the beginning of the
   last line of code in it.  */

static void
handle_step_into_function_backward (struct gdbarch *gdbarch,
				    struct execution_control_state *ecs)
{
  struct symtab *s;
  struct symtab_and_line stop_func_sal;

  fill_in_stop_func (gdbarch, ecs);

  s = find_pc_symtab (stop_pc);
  if (s && s->language != language_asm)
    ecs->stop_func_start = gdbarch_skip_prologue (gdbarch,
						  ecs->stop_func_start);

  stop_func_sal = find_pc_line (stop_pc, 0);

  /* OK, we're just going to keep stepping here.  */
  if (stop_func_sal.pc == stop_pc)
    {
      /* We're there already.  Just stop stepping now.  */
      ecs->event_thread->control.stop_step = 1;
      print_end_stepping_range_reason ();
      stop_stepping (ecs);
    }
  else
    {
      /* Else just reset the step range and keep going.
	 No step-resume breakpoint, they don't work for
	 epilogues, which can have multiple entry paths.  */
      ecs->event_thread->control.step_range_start = stop_func_sal.pc;
      ecs->event_thread->control.step_range_end = stop_func_sal.end;
      keep_going (ecs);
    }
  return;
}

/* Insert a "step-resume breakpoint" at SR_SAL with frame ID SR_ID.
   This is used to both functions and to skip over code.  */

static void
insert_step_resume_breakpoint_at_sal_1 (struct gdbarch *gdbarch,
					struct symtab_and_line sr_sal,
					struct frame_id sr_id,
					enum bptype sr_type)
{
  /* There should never be more than one step-resume or longjmp-resume
     breakpoint per thread, so we should never be setting a new
     step_resume_breakpoint when one is already active.  */
  gdb_assert (inferior_thread ()->control.step_resume_breakpoint == NULL);
  gdb_assert (sr_type == bp_step_resume || sr_type == bp_hp_step_resume);

  if (debug_infrun)
    fprintf_unfiltered (gdb_stdlog,
			"infrun: inserting step-resume breakpoint at %s\n",
			paddress (gdbarch, sr_sal.pc));

  inferior_thread ()->control.step_resume_breakpoint
    = set_momentary_breakpoint (gdbarch, sr_sal, sr_id, sr_type);
}

void
insert_step_resume_breakpoint_at_sal (struct gdbarch *gdbarch,
				      struct symtab_and_line sr_sal,
				      struct frame_id sr_id)
{
  insert_step_resume_breakpoint_at_sal_1 (gdbarch,
					  sr_sal, sr_id,
					  bp_step_resume);
}

/* Insert a "high-priority step-resume breakpoint" at RETURN_FRAME.pc.
   This is used to skip a potential signal handler.

   This is called with the interrupted function's frame.  The signal
   handler, when it returns, will resume the interrupted function at
   RETURN_FRAME.pc.  */

static void
insert_hp_step_resume_breakpoint_at_frame (struct frame_info *return_frame)
{
  struct symtab_and_line sr_sal;
  struct gdbarch *gdbarch;

  gdb_assert (return_frame != NULL);
  init_sal (&sr_sal);		/* initialize to zeros */

  gdbarch = get_frame_arch (return_frame);
  sr_sal.pc = gdbarch_addr_bits_remove (gdbarch, get_frame_pc (return_frame));
  sr_sal.section = find_pc_overlay (sr_sal.pc);
  sr_sal.pspace = get_frame_program_space (return_frame);

  insert_step_resume_breakpoint_at_sal_1 (gdbarch, sr_sal,
					  get_stack_frame_id (return_frame),
					  bp_hp_step_resume);
}

/* Insert a "step-resume breakpoint" at the previous frame's PC.  This
   is used to skip a function after stepping into it (for "next" or if
   the called function has no debugging information).

   The current function has almost always been reached by single
   stepping a call or return instruction.  NEXT_FRAME belongs to the
   current function, and the breakpoint will be set at the caller's
   resume address.

   This is a separate function rather than reusing
   insert_hp_step_resume_breakpoint_at_frame in order to avoid
   get_prev_frame, which may stop prematurely (see the implementation
   of frame_unwind_caller_id for an example).  */

static void
insert_step_resume_breakpoint_at_caller (struct frame_info *next_frame)
{
  struct symtab_and_line sr_sal;
  struct gdbarch *gdbarch;

  /* We shouldn't have gotten here if we don't know where the call site
     is.  */
  gdb_assert (frame_id_p (frame_unwind_caller_id (next_frame)));

  init_sal (&sr_sal);		/* initialize to zeros */

  gdbarch = frame_unwind_caller_arch (next_frame);
  sr_sal.pc = gdbarch_addr_bits_remove (gdbarch,
					frame_unwind_caller_pc (next_frame));
  sr_sal.section = find_pc_overlay (sr_sal.pc);
  sr_sal.pspace = frame_unwind_program_space (next_frame);

  insert_step_resume_breakpoint_at_sal (gdbarch, sr_sal,
					frame_unwind_caller_id (next_frame));
}

/* Insert a "longjmp-resume" breakpoint at PC.  This is used to set a
   new breakpoint at the target of a jmp_buf.  The handling of
   longjmp-resume uses the same mechanisms used for handling
   "step-resume" breakpoints.  */

static void
insert_longjmp_resume_breakpoint (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  /* There should never be more than one longjmp-resume breakpoint per
     thread, so we should never be setting a new
     longjmp_resume_breakpoint when one is already active.  */
  gdb_assert (inferior_thread ()->control.exception_resume_breakpoint == NULL);

  if (debug_infrun)
    fprintf_unfiltered (gdb_stdlog,
			"infrun: inserting longjmp-resume breakpoint at %s\n",
			paddress (gdbarch, pc));

  inferior_thread ()->control.exception_resume_breakpoint =
    set_momentary_breakpoint_at_pc (gdbarch, pc, bp_longjmp_resume);
}

/* Insert an exception resume breakpoint.  TP is the thread throwing
   the exception.  The block B is the block of the unwinder debug hook
   function.  FRAME is the frame corresponding to the call to this
   function.  SYM is the symbol of the function argument holding the
   target PC of the exception.  */

static void
insert_exception_resume_breakpoint (struct thread_info *tp,
				    struct block *b,
				    struct frame_info *frame,
				    struct symbol *sym)
{
  volatile struct gdb_exception e;

  /* We want to ignore errors here.  */
  TRY_CATCH (e, RETURN_MASK_ERROR)
    {
      struct symbol *vsym;
      struct value *value;
      CORE_ADDR handler;
      struct breakpoint *bp;

      vsym = lookup_symbol (SYMBOL_LINKAGE_NAME (sym), b, VAR_DOMAIN, NULL);
      value = read_var_value (vsym, frame);
      /* If the value was optimized out, revert to the old behavior.  */
      if (! value_optimized_out (value))
	{
	  handler = value_as_address (value);

	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog,
				"infrun: exception resume at %lx\n",
				(unsigned long) handler);

	  bp = set_momentary_breakpoint_at_pc (get_frame_arch (frame),
					       handler, bp_exception_resume);

	  /* set_momentary_breakpoint_at_pc invalidates FRAME.  */
	  frame = NULL;

	  bp->thread = tp->num;
	  inferior_thread ()->control.exception_resume_breakpoint = bp;
	}
    }
}

/* A helper for check_exception_resume that sets an
   exception-breakpoint based on a SystemTap probe.  */

static void
insert_exception_resume_from_probe (struct thread_info *tp,
				    const struct probe *probe,
				    struct frame_info *frame)
{
  struct value *arg_value;
  CORE_ADDR handler;
  struct breakpoint *bp;

  arg_value = probe_safe_evaluate_at_pc (frame, 1);
  if (!arg_value)
    return;

  handler = value_as_address (arg_value);

  if (debug_infrun)
    fprintf_unfiltered (gdb_stdlog,
			"infrun: exception resume at %s\n",
			paddress (get_objfile_arch (probe->objfile),
				  handler));

  bp = set_momentary_breakpoint_at_pc (get_frame_arch (frame),
				       handler, bp_exception_resume);
  bp->thread = tp->num;
  inferior_thread ()->control.exception_resume_breakpoint = bp;
}

/* This is called when an exception has been intercepted.  Check to
   see whether the exception's destination is of interest, and if so,
   set an exception resume breakpoint there.  */

static void
check_exception_resume (struct execution_control_state *ecs,
			struct frame_info *frame)
{
  volatile struct gdb_exception e;
  const struct probe *probe;
  struct symbol *func;

  /* First see if this exception unwinding breakpoint was set via a
     SystemTap probe point.  If so, the probe has two arguments: the
     CFA and the HANDLER.  We ignore the CFA, extract the handler, and
     set a breakpoint there.  */
  probe = find_probe_by_pc (get_frame_pc (frame));
  if (probe)
    {
      insert_exception_resume_from_probe (ecs->event_thread, probe, frame);
      return;
    }

  func = get_frame_function (frame);
  if (!func)
    return;

  TRY_CATCH (e, RETURN_MASK_ERROR)
    {
      struct block *b;
      struct block_iterator iter;
      struct symbol *sym;
      int argno = 0;

      /* The exception breakpoint is a thread-specific breakpoint on
	 the unwinder's debug hook, declared as:
	 
	 void _Unwind_DebugHook (void *cfa, void *handler);
	 
	 The CFA argument indicates the frame to which control is
	 about to be transferred.  HANDLER is the destination PC.
	 
	 We ignore the CFA and set a temporary breakpoint at HANDLER.
	 This is not extremely efficient but it avoids issues in gdb
	 with computing the DWARF CFA, and it also works even in weird
	 cases such as throwing an exception from inside a signal
	 handler.  */

      b = SYMBOL_BLOCK_VALUE (func);
      ALL_BLOCK_SYMBOLS (b, iter, sym)
	{
	  if (!SYMBOL_IS_ARGUMENT (sym))
	    continue;

	  if (argno == 0)
	    ++argno;
	  else
	    {
	      insert_exception_resume_breakpoint (ecs->event_thread,
						  b, frame, sym);
	      break;
	    }
	}
    }
}

static void
stop_stepping (struct execution_control_state *ecs)
{
  if (debug_infrun)
    fprintf_unfiltered (gdb_stdlog, "infrun: stop_stepping\n");

  /* Let callers know we don't want to wait for the inferior anymore.  */
  ecs->wait_some_more = 0;
}

/* This function handles various cases where we need to continue
   waiting for the inferior.  */
/* (Used to be the keep_going: label in the old wait_for_inferior).  */

static void
keep_going (struct execution_control_state *ecs)
{
  /* Make sure normal_stop is called if we get a QUIT handled before
     reaching resume.  */
  struct cleanup *old_cleanups = make_cleanup (resume_cleanups, 0);

  /* Save the pc before execution, to compare with pc after stop.  */
  ecs->event_thread->prev_pc
    = regcache_read_pc (get_thread_regcache (ecs->ptid));

  /* If we did not do break;, it means we should keep running the
     inferior and not return to debugger.  */

  if (ecs->event_thread->control.trap_expected
      && ecs->event_thread->suspend.stop_signal != GDB_SIGNAL_TRAP)
    {
      /* We took a signal (which we are supposed to pass through to
	 the inferior, else we'd not get here) and we haven't yet
	 gotten our trap.  Simply continue.  */

      discard_cleanups (old_cleanups);
      resume (currently_stepping (ecs->event_thread),
	      ecs->event_thread->suspend.stop_signal);
    }
  else
    {
      /* Either the trap was not expected, but we are continuing
         anyway (the user asked that this signal be passed to the
         child)
         -- or --
         The signal was SIGTRAP, e.g. it was our signal, but we
         decided we should resume from it.

         We're going to run this baby now!  

	 Note that insert_breakpoints won't try to re-insert
	 already inserted breakpoints.  Therefore, we don't
	 care if breakpoints were already inserted, or not.  */
      
      if (ecs->event_thread->stepping_over_breakpoint)
	{
	  struct regcache *thread_regcache = get_thread_regcache (ecs->ptid);

	  if (!use_displaced_stepping (get_regcache_arch (thread_regcache)))
	    /* Since we can't do a displaced step, we have to remove
	       the breakpoint while we step it.  To keep things
	       simple, we remove them all.  */
	    remove_breakpoints ();
	}
      else
	{
	  volatile struct gdb_exception e;

	  /* Stop stepping when inserting breakpoints
	     has failed.  */
	  TRY_CATCH (e, RETURN_MASK_ERROR)
	    {
	      insert_breakpoints ();
	    }
	  if (e.reason < 0)
	    {
	      exception_print (gdb_stderr, e);
	      stop_stepping (ecs);
	      return;
	    }
	}

      ecs->event_thread->control.trap_expected
	= ecs->event_thread->stepping_over_breakpoint;

      /* Do not deliver SIGNAL_TRAP (except when the user explicitly
         specifies that such a signal should be delivered to the
         target program).

         Typically, this would occure when a user is debugging a
         target monitor on a simulator: the target monitor sets a
         breakpoint; the simulator encounters this break-point and
         halts the simulation handing control to GDB; GDB, noteing
         that the break-point isn't valid, returns control back to the
         simulator; the simulator then delivers the hardware
         equivalent of a SIGNAL_TRAP to the program being debugged.  */

      if (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP
	  && !signal_program[ecs->event_thread->suspend.stop_signal])
	ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;

      discard_cleanups (old_cleanups);
      resume (currently_stepping (ecs->event_thread),
	      ecs->event_thread->suspend.stop_signal);
    }

  prepare_to_wait (ecs);
}

/* This function normally comes after a resume, before
   handle_inferior_event exits.  It takes care of any last bits of
   housekeeping, and sets the all-important wait_some_more flag.  */

static void
prepare_to_wait (struct execution_control_state *ecs)
{
  if (debug_infrun)
    fprintf_unfiltered (gdb_stdlog, "infrun: prepare_to_wait\n");

  /* This is the old end of the while loop.  Let everybody know we
     want to wait for the inferior some more and get called again
     soon.  */
  ecs->wait_some_more = 1;
}

/* Several print_*_reason functions to print why the inferior has stopped.
   We always print something when the inferior exits, or receives a signal.
   The rest of the cases are dealt with later on in normal_stop and
   print_it_typical.  Ideally there should be a call to one of these
   print_*_reason functions functions from handle_inferior_event each time
   stop_stepping is called.  */

/* Print why the inferior has stopped.  
   We are done with a step/next/si/ni command, print why the inferior has
   stopped.  For now print nothing.  Print a message only if not in the middle
   of doing a "step n" operation for n > 1.  */

static void
print_end_stepping_range_reason (void)
{
  if ((!inferior_thread ()->step_multi
       || !inferior_thread ()->control.stop_step)
      && ui_out_is_mi_like_p (current_uiout))
    ui_out_field_string (current_uiout, "reason",
                         async_reason_lookup (EXEC_ASYNC_END_STEPPING_RANGE));
}

/* The inferior was terminated by a signal, print why it stopped.  */

static void
print_signal_exited_reason (enum gdb_signal siggnal)
{
  struct ui_out *uiout = current_uiout;

  annotate_signalled ();
  if (ui_out_is_mi_like_p (uiout))
    ui_out_field_string
      (uiout, "reason", async_reason_lookup (EXEC_ASYNC_EXITED_SIGNALLED));
  ui_out_text (uiout, "\nProgram terminated with signal ");
  annotate_signal_name ();
  ui_out_field_string (uiout, "signal-name",
		       gdb_signal_to_name (siggnal));
  annotate_signal_name_end ();
  ui_out_text (uiout, ", ");
  annotate_signal_string ();
  ui_out_field_string (uiout, "signal-meaning",
		       gdb_signal_to_string (siggnal));
  annotate_signal_string_end ();
  ui_out_text (uiout, ".\n");
  ui_out_text (uiout, "The program no longer exists.\n");
}

/* The inferior program is finished, print why it stopped.  */

static void
print_exited_reason (int exitstatus)
{
  struct inferior *inf = current_inferior ();
  const char *pidstr = target_pid_to_str (pid_to_ptid (inf->pid));
  struct ui_out *uiout = current_uiout;

  annotate_exited (exitstatus);
  if (exitstatus)
    {
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string (uiout, "reason", 
			     async_reason_lookup (EXEC_ASYNC_EXITED));
      ui_out_text (uiout, "[Inferior ");
      ui_out_text (uiout, plongest (inf->num));
      ui_out_text (uiout, " (");
      ui_out_text (uiout, pidstr);
      ui_out_text (uiout, ") exited with code ");
      ui_out_field_fmt (uiout, "exit-code", "0%o", (unsigned int) exitstatus);
      ui_out_text (uiout, "]\n");
    }
  else
    {
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason", async_reason_lookup (EXEC_ASYNC_EXITED_NORMALLY));
      ui_out_text (uiout, "[Inferior ");
      ui_out_text (uiout, plongest (inf->num));
      ui_out_text (uiout, " (");
      ui_out_text (uiout, pidstr);
      ui_out_text (uiout, ") exited normally]\n");
    }
  /* Support the --return-child-result option.  */
  return_child_result_value = exitstatus;
}

/* Signal received, print why the inferior has stopped.  The signal table
   tells us to print about it.  */

static void
print_signal_received_reason (enum gdb_signal siggnal)
{
  struct ui_out *uiout = current_uiout;

  annotate_signal ();

  if (siggnal == GDB_SIGNAL_0 && !ui_out_is_mi_like_p (uiout))
    {
      struct thread_info *t = inferior_thread ();

      ui_out_text (uiout, "\n[");
      ui_out_field_string (uiout, "thread-name",
			   target_pid_to_str (t->ptid));
      ui_out_field_fmt (uiout, "thread-id", "] #%d", t->num);
      ui_out_text (uiout, " stopped");
    }
  else
    {
      ui_out_text (uiout, "\nProgram received signal ");
      annotate_signal_name ();
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason", async_reason_lookup (EXEC_ASYNC_SIGNAL_RECEIVED));
      ui_out_field_string (uiout, "signal-name",
			   gdb_signal_to_name (siggnal));
      annotate_signal_name_end ();
      ui_out_text (uiout, ", ");
      annotate_signal_string ();
      ui_out_field_string (uiout, "signal-meaning",
			   gdb_signal_to_string (siggnal));
      annotate_signal_string_end ();
    }
  ui_out_text (uiout, ".\n");
}

/* Reverse execution: target ran out of history info, print why the inferior
   has stopped.  */

static void
print_no_history_reason (void)
{
  ui_out_text (current_uiout, "\nNo more reverse-execution history.\n");
}

/* Here to return control to GDB when the inferior stops for real.
   Print appropriate messages, remove breakpoints, give terminal our modes.

   STOP_PRINT_FRAME nonzero means print the executing frame
   (pc, function, args, file, line number and line text).
   BREAKPOINTS_FAILED nonzero means stop was due to error
   attempting to insert breakpoints.  */

void
normal_stop (void)
{
  struct target_waitstatus last;
  ptid_t last_ptid;
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);

  get_last_target_status (&last_ptid, &last);

  /* If an exception is thrown from this point on, make sure to
     propagate GDB's knowledge of the executing state to the
     frontend/user running state.  A QUIT is an easy exception to see
     here, so do this before any filtered output.  */
  if (!non_stop)
    make_cleanup (finish_thread_state_cleanup, &minus_one_ptid);
  else if (last.kind != TARGET_WAITKIND_SIGNALLED
	   && last.kind != TARGET_WAITKIND_EXITED
	   && last.kind != TARGET_WAITKIND_NO_RESUMED)
    make_cleanup (finish_thread_state_cleanup, &inferior_ptid);

  /* In non-stop mode, we don't want GDB to switch threads behind the
     user's back, to avoid races where the user is typing a command to
     apply to thread x, but GDB switches to thread y before the user
     finishes entering the command.  */

  /* As with the notification of thread events, we want to delay
     notifying the user that we've switched thread context until
     the inferior actually stops.

     There's no point in saying anything if the inferior has exited.
     Note that SIGNALLED here means "exited with a signal", not
     "received a signal".  */
  if (!non_stop
      && !ptid_equal (previous_inferior_ptid, inferior_ptid)
      && target_has_execution
      && last.kind != TARGET_WAITKIND_SIGNALLED
      && last.kind != TARGET_WAITKIND_EXITED
      && last.kind != TARGET_WAITKIND_NO_RESUMED)
    {
      target_terminal_ours_for_output ();
      printf_filtered (_("[Switching to %s]\n"),
		       target_pid_to_str (inferior_ptid));
      annotate_thread_changed ();
      previous_inferior_ptid = inferior_ptid;
    }

  if (last.kind == TARGET_WAITKIND_NO_RESUMED)
    {
      gdb_assert (sync_execution || !target_can_async_p ());

      target_terminal_ours_for_output ();
      printf_filtered (_("No unwaited-for children left.\n"));
    }

  if (!breakpoints_always_inserted_mode () && target_has_execution)
    {
      if (remove_breakpoints ())
	{
	  target_terminal_ours_for_output ();
	  printf_filtered (_("Cannot remove breakpoints because "
			     "program is no longer writable.\nFurther "
			     "execution is probably impossible.\n"));
	}
    }

  /* If an auto-display called a function and that got a signal,
     delete that auto-display to avoid an infinite recursion.  */

  if (stopped_by_random_signal)
    disable_current_display ();

  /* Don't print a message if in the middle of doing a "step n"
     operation for n > 1 */
  if (target_has_execution
      && last.kind != TARGET_WAITKIND_SIGNALLED
      && last.kind != TARGET_WAITKIND_EXITED
      && inferior_thread ()->step_multi
      && inferior_thread ()->control.stop_step)
    goto done;

  target_terminal_ours ();
  async_enable_stdin ();

  /* Set the current source location.  This will also happen if we
     display the frame below, but the current SAL will be incorrect
     during a user hook-stop function.  */
  if (has_stack_frames () && !stop_stack_dummy)
    set_current_sal_from_frame (get_current_frame (), 1);

  /* Let the user/frontend see the threads as stopped.  */
  do_cleanups (old_chain);

  /* Look up the hook_stop and run it (CLI internally handles problem
     of stop_command's pre-hook not existing).  */
  if (stop_command)
    catch_errors (hook_stop_stub, stop_command,
		  "Error while running hook_stop:\n", RETURN_MASK_ALL);

  if (!has_stack_frames ())
    goto done;

  if (last.kind == TARGET_WAITKIND_SIGNALLED
      || last.kind == TARGET_WAITKIND_EXITED)
    goto done;

  /* Select innermost stack frame - i.e., current frame is frame 0,
     and current location is based on that.
     Don't do this on return from a stack dummy routine,
     or if the program has exited.  */

  if (!stop_stack_dummy)
    {
      select_frame (get_current_frame ());

      /* Print current location without a level number, if
         we have changed functions or hit a breakpoint.
         Print source line if we have one.
         bpstat_print() contains the logic deciding in detail
         what to print, based on the event(s) that just occurred.  */

      /* If --batch-silent is enabled then there's no need to print the current
	 source location, and to try risks causing an error message about
	 missing source files.  */
      if (stop_print_frame && !batch_silent)
	{
	  int bpstat_ret;
	  int source_flag;
	  int do_frame_printing = 1;
	  struct thread_info *tp = inferior_thread ();

	  bpstat_ret = bpstat_print (tp->control.stop_bpstat, last.kind);
	  switch (bpstat_ret)
	    {
	    case PRINT_UNKNOWN:
	      /* FIXME: cagney/2002-12-01: Given that a frame ID does
	         (or should) carry around the function and does (or
	         should) use that when doing a frame comparison.  */
	      if (tp->control.stop_step
		  && frame_id_eq (tp->control.step_frame_id,
				  get_frame_id (get_current_frame ()))
		  && step_start_function == find_pc_function (stop_pc))
		source_flag = SRC_LINE;		/* Finished step, just
						   print source line.  */
	      else
		source_flag = SRC_AND_LOC;	/* Print location and
						   source line.  */
	      break;
	    case PRINT_SRC_AND_LOC:
	      source_flag = SRC_AND_LOC;	/* Print location and
						   source line.  */
	      break;
	    case PRINT_SRC_ONLY:
	      source_flag = SRC_LINE;
	      break;
	    case PRINT_NOTHING:
	      source_flag = SRC_LINE;	/* something bogus */
	      do_frame_printing = 0;
	      break;
	    default:
	      internal_error (__FILE__, __LINE__, _("Unknown value."));
	    }

	  /* The behavior of this routine with respect to the source
	     flag is:
	     SRC_LINE: Print only source line
	     LOCATION: Print only location
	     SRC_AND_LOC: Print location and source line.  */
	  if (do_frame_printing)
	    print_stack_frame (get_selected_frame (NULL), 0, source_flag, 1);

	  /* Display the auto-display expressions.  */
	  do_displays ();
	}
    }

  /* Save the function value return registers, if we care.
     We might be about to restore their previous contents.  */
  if (inferior_thread ()->control.proceed_to_finish
      && execution_direction != EXEC_REVERSE)
    {
      /* This should not be necessary.  */
      if (stop_registers)
	regcache_xfree (stop_registers);

      /* NB: The copy goes through to the target picking up the value of
	 all the registers.  */
      stop_registers = regcache_dup (get_current_regcache ());
    }

  if (stop_stack_dummy == STOP_STACK_DUMMY)
    {
      /* Pop the empty frame that contains the stack dummy.
	 This also restores inferior state prior to the call
	 (struct infcall_suspend_state).  */
      struct frame_info *frame = get_current_frame ();

      gdb_assert (get_frame_type (frame) == DUMMY_FRAME);
      frame_pop (frame);
      /* frame_pop() calls reinit_frame_cache as the last thing it
	 does which means there's currently no selected frame.  We
	 don't need to re-establish a selected frame if the dummy call
	 returns normally, that will be done by
	 restore_infcall_control_state.  However, we do have to handle
	 the case where the dummy call is returning after being
	 stopped (e.g. the dummy call previously hit a breakpoint).
	 We can't know which case we have so just always re-establish
	 a selected frame here.  */
      select_frame (get_current_frame ());
    }

done:
  annotate_stopped ();

  /* Suppress the stop observer if we're in the middle of:

     - a step n (n > 1), as there still more steps to be done.

     - a "finish" command, as the observer will be called in
       finish_command_continuation, so it can include the inferior
       function's return value.

     - calling an inferior function, as we pretend we inferior didn't
       run at all.  The return value of the call is handled by the
       expression evaluator, through call_function_by_hand.  */

  if (!target_has_execution
      || last.kind == TARGET_WAITKIND_SIGNALLED
      || last.kind == TARGET_WAITKIND_EXITED
      || last.kind == TARGET_WAITKIND_NO_RESUMED
      || (!(inferior_thread ()->step_multi
	    && inferior_thread ()->control.stop_step)
	  && !(inferior_thread ()->control.stop_bpstat
	       && inferior_thread ()->control.proceed_to_finish)
	  && !inferior_thread ()->control.in_infcall))
    {
      if (!ptid_equal (inferior_ptid, null_ptid))
	observer_notify_normal_stop (inferior_thread ()->control.stop_bpstat,
				     stop_print_frame);
      else
	observer_notify_normal_stop (NULL, stop_print_frame);
    }

  if (target_has_execution)
    {
      if (last.kind != TARGET_WAITKIND_SIGNALLED
	  && last.kind != TARGET_WAITKIND_EXITED)
	/* Delete the breakpoint we stopped at, if it wants to be deleted.
	   Delete any breakpoint that is to be deleted at the next stop.  */
	breakpoint_auto_delete (inferior_thread ()->control.stop_bpstat);
    }

  /* Try to get rid of automatically added inferiors that are no
     longer needed.  Keeping those around slows down things linearly.
     Note that this never removes the current inferior.  */
  prune_inferiors ();
}

static int
hook_stop_stub (void *cmd)
{
  execute_cmd_pre_hook ((struct cmd_list_element *) cmd);
  return (0);
}

int
signal_stop_state (int signo)
{
  return signal_stop[signo];
}

int
signal_print_state (int signo)
{
  return signal_print[signo];
}

int
signal_pass_state (int signo)
{
  return signal_program[signo];
}

static void
signal_cache_update (int signo)
{
  if (signo == -1)
    {
      for (signo = 0; signo < (int) GDB_SIGNAL_LAST; signo++)
	signal_cache_update (signo);

      return;
    }

  signal_pass[signo] = (signal_stop[signo] == 0
			&& signal_print[signo] == 0
			&& signal_program[signo] == 1
			&& signal_catch[signo] == 0);
}

int
signal_stop_update (int signo, int state)
{
  int ret = signal_stop[signo];

  signal_stop[signo] = state;
  signal_cache_update (signo);
  return ret;
}

int
signal_print_update (int signo, int state)
{
  int ret = signal_print[signo];

  signal_print[signo] = state;
  signal_cache_update (signo);
  return ret;
}

int
signal_pass_update (int signo, int state)
{
  int ret = signal_program[signo];

  signal_program[signo] = state;
  signal_cache_update (signo);
  return ret;
}

/* Update the global 'signal_catch' from INFO and notify the
   target.  */

void
signal_catch_update (const unsigned int *info)
{
  int i;

  for (i = 0; i < GDB_SIGNAL_LAST; ++i)
    signal_catch[i] = info[i] > 0;
  signal_cache_update (-1);
  target_pass_signals ((int) GDB_SIGNAL_LAST, signal_pass);
}

static void
sig_print_header (void)
{
  printf_filtered (_("Signal        Stop\tPrint\tPass "
		     "to program\tDescription\n"));
}

static void
sig_print_info (enum gdb_signal oursig)
{
  const char *name = gdb_signal_to_name (oursig);
  int name_padding = 13 - strlen (name);

  if (name_padding <= 0)
    name_padding = 0;

  printf_filtered ("%s", name);
  printf_filtered ("%*.*s ", name_padding, name_padding, "                 ");
  printf_filtered ("%s\t", signal_stop[oursig] ? "Yes" : "No");
  printf_filtered ("%s\t", signal_print[oursig] ? "Yes" : "No");
  printf_filtered ("%s\t\t", signal_program[oursig] ? "Yes" : "No");
  printf_filtered ("%s\n", gdb_signal_to_string (oursig));
}

/* Specify how various signals in the inferior should be handled.  */

static void
handle_command (char *args, int from_tty)
{
  char **argv;
  int digits, wordlen;
  int sigfirst, signum, siglast;
  enum gdb_signal oursig;
  int allsigs;
  int nsigs;
  unsigned char *sigs;
  struct cleanup *old_chain;

  if (args == NULL)
    {
      error_no_arg (_("signal to handle"));
    }

  /* Allocate and zero an array of flags for which signals to handle.  */

  nsigs = (int) GDB_SIGNAL_LAST;
  sigs = (unsigned char *) alloca (nsigs);
  memset (sigs, 0, nsigs);

  /* Break the command line up into args.  */

  argv = gdb_buildargv (args);
  old_chain = make_cleanup_freeargv (argv);

  /* Walk through the args, looking for signal oursigs, signal names, and
     actions.  Signal numbers and signal names may be interspersed with
     actions, with the actions being performed for all signals cumulatively
     specified.  Signal ranges can be specified as <LOW>-<HIGH>.  */

  while (*argv != NULL)
    {
      wordlen = strlen (*argv);
      for (digits = 0; isdigit ((*argv)[digits]); digits++)
	{;
	}
      allsigs = 0;
      sigfirst = siglast = -1;

      if (wordlen >= 1 && !strncmp (*argv, "all", wordlen))
	{
	  /* Apply action to all signals except those used by the
	     debugger.  Silently skip those.  */
	  allsigs = 1;
	  sigfirst = 0;
	  siglast = nsigs - 1;
	}
      else if (wordlen >= 1 && !strncmp (*argv, "stop", wordlen))
	{
	  SET_SIGS (nsigs, sigs, signal_stop);
	  SET_SIGS (nsigs, sigs, signal_print);
	}
      else if (wordlen >= 1 && !strncmp (*argv, "ignore", wordlen))
	{
	  UNSET_SIGS (nsigs, sigs, signal_program);
	}
      else if (wordlen >= 2 && !strncmp (*argv, "print", wordlen))
	{
	  SET_SIGS (nsigs, sigs, signal_print);
	}
      else if (wordlen >= 2 && !strncmp (*argv, "pass", wordlen))
	{
	  SET_SIGS (nsigs, sigs, signal_program);
	}
      else if (wordlen >= 3 && !strncmp (*argv, "nostop", wordlen))
	{
	  UNSET_SIGS (nsigs, sigs, signal_stop);
	}
      else if (wordlen >= 3 && !strncmp (*argv, "noignore", wordlen))
	{
	  SET_SIGS (nsigs, sigs, signal_program);
	}
      else if (wordlen >= 4 && !strncmp (*argv, "noprint", wordlen))
	{
	  UNSET_SIGS (nsigs, sigs, signal_print);
	  UNSET_SIGS (nsigs, sigs, signal_stop);
	}
      else if (wordlen >= 4 && !strncmp (*argv, "nopass", wordlen))
	{
	  UNSET_SIGS (nsigs, sigs, signal_program);
	}
      else if (digits > 0)
	{
	  /* It is numeric.  The numeric signal refers to our own
	     internal signal numbering from target.h, not to host/target
	     signal  number.  This is a feature; users really should be
	     using symbolic names anyway, and the common ones like
	     SIGHUP, SIGINT, SIGALRM, etc. will work right anyway.  */

	  sigfirst = siglast = (int)
	    gdb_signal_from_command (atoi (*argv));
	  if ((*argv)[digits] == '-')
	    {
	      siglast = (int)
		gdb_signal_from_command (atoi ((*argv) + digits + 1));
	    }
	  if (sigfirst > siglast)
	    {
	      /* Bet he didn't figure we'd think of this case...  */
	      signum = sigfirst;
	      sigfirst = siglast;
	      siglast = signum;
	    }
	}
      else
	{
	  oursig = gdb_signal_from_name (*argv);
	  if (oursig != GDB_SIGNAL_UNKNOWN)
	    {
	      sigfirst = siglast = (int) oursig;
	    }
	  else
	    {
	      /* Not a number and not a recognized flag word => complain.  */
	      error (_("Unrecognized or ambiguous flag word: \"%s\"."), *argv);
	    }
	}

      /* If any signal numbers or symbol names were found, set flags for
         which signals to apply actions to.  */

      for (signum = sigfirst; signum >= 0 && signum <= siglast; signum++)
	{
	  switch ((enum gdb_signal) signum)
	    {
	    case GDB_SIGNAL_TRAP:
	    case GDB_SIGNAL_INT:
	      if (!allsigs && !sigs[signum])
		{
		  if (query (_("%s is used by the debugger.\n\
Are you sure you want to change it? "),
			     gdb_signal_to_name ((enum gdb_signal) signum)))
		    {
		      sigs[signum] = 1;
		    }
		  else
		    {
		      printf_unfiltered (_("Not confirmed, unchanged.\n"));
		      gdb_flush (gdb_stdout);
		    }
		}
	      break;
	    case GDB_SIGNAL_0:
	    case GDB_SIGNAL_DEFAULT:
	    case GDB_SIGNAL_UNKNOWN:
	      /* Make sure that "all" doesn't print these.  */
	      break;
	    default:
	      sigs[signum] = 1;
	      break;
	    }
	}

      argv++;
    }

  for (signum = 0; signum < nsigs; signum++)
    if (sigs[signum])
      {
	signal_cache_update (-1);
	target_pass_signals ((int) GDB_SIGNAL_LAST, signal_pass);
	target_program_signals ((int) GDB_SIGNAL_LAST, signal_program);

	if (from_tty)
	  {
	    /* Show the results.  */
	    sig_print_header ();
	    for (; signum < nsigs; signum++)
	      if (sigs[signum])
		sig_print_info (signum);
	  }

	break;
      }

  do_cleanups (old_chain);
}

/* Complete the "handle" command.  */

static VEC (char_ptr) *
handle_completer (struct cmd_list_element *ignore,
		  const char *text, const char *word)
{
  VEC (char_ptr) *vec_signals, *vec_keywords, *return_val;
  static const char * const keywords[] =
    {
      "all",
      "stop",
      "ignore",
      "print",
      "pass",
      "nostop",
      "noignore",
      "noprint",
      "nopass",
      NULL,
    };

  vec_signals = signal_completer (ignore, text, word);
  vec_keywords = complete_on_enum (keywords, word, word);

  return_val = VEC_merge (char_ptr, vec_signals, vec_keywords);
  VEC_free (char_ptr, vec_signals);
  VEC_free (char_ptr, vec_keywords);
  return return_val;
}

static void
xdb_handle_command (char *args, int from_tty)
{
  char **argv;
  struct cleanup *old_chain;

  if (args == NULL)
    error_no_arg (_("xdb command"));

  /* Break the command line up into args.  */

  argv = gdb_buildargv (args);
  old_chain = make_cleanup_freeargv (argv);
  if (argv[1] != (char *) NULL)
    {
      char *argBuf;
      int bufLen;

      bufLen = strlen (argv[0]) + 20;
      argBuf = (char *) xmalloc (bufLen);
      if (argBuf)
	{
	  int validFlag = 1;
	  enum gdb_signal oursig;

	  oursig = gdb_signal_from_name (argv[0]);
	  memset (argBuf, 0, bufLen);
	  if (strcmp (argv[1], "Q") == 0)
	    sprintf (argBuf, "%s %s", argv[0], "noprint");
	  else
	    {
	      if (strcmp (argv[1], "s") == 0)
		{
		  if (!signal_stop[oursig])
		    sprintf (argBuf, "%s %s", argv[0], "stop");
		  else
		    sprintf (argBuf, "%s %s", argv[0], "nostop");
		}
	      else if (strcmp (argv[1], "i") == 0)
		{
		  if (!signal_program[oursig])
		    sprintf (argBuf, "%s %s", argv[0], "pass");
		  else
		    sprintf (argBuf, "%s %s", argv[0], "nopass");
		}
	      else if (strcmp (argv[1], "r") == 0)
		{
		  if (!signal_print[oursig])
		    sprintf (argBuf, "%s %s", argv[0], "print");
		  else
		    sprintf (argBuf, "%s %s", argv[0], "noprint");
		}
	      else
		validFlag = 0;
	    }
	  if (validFlag)
	    handle_command (argBuf, from_tty);
	  else
	    printf_filtered (_("Invalid signal handling flag.\n"));
	  if (argBuf)
	    xfree (argBuf);
	}
    }
  do_cleanups (old_chain);
}

enum gdb_signal
gdb_signal_from_command (int num)
{
  if (num >= 1 && num <= 15)
    return (enum gdb_signal) num;
  error (_("Only signals 1-15 are valid as numeric signals.\n\
Use \"info signals\" for a list of symbolic signals."));
}

/* Print current contents of the tables set by the handle command.
   It is possible we should just be printing signals actually used
   by the current target (but for things to work right when switching
   targets, all signals should be in the signal tables).  */

static void
signals_info (char *signum_exp, int from_tty)
{
  enum gdb_signal oursig;

  sig_print_header ();

  if (signum_exp)
    {
      /* First see if this is a symbol name.  */
      oursig = gdb_signal_from_name (signum_exp);
      if (oursig == GDB_SIGNAL_UNKNOWN)
	{
	  /* No, try numeric.  */
	  oursig =
	    gdb_signal_from_command (parse_and_eval_long (signum_exp));
	}
      sig_print_info (oursig);
      return;
    }

  printf_filtered ("\n");
  /* These ugly casts brought to you by the native VAX compiler.  */
  for (oursig = GDB_SIGNAL_FIRST;
       (int) oursig < (int) GDB_SIGNAL_LAST;
       oursig = (enum gdb_signal) ((int) oursig + 1))
    {
      QUIT;

      if (oursig != GDB_SIGNAL_UNKNOWN
	  && oursig != GDB_SIGNAL_DEFAULT && oursig != GDB_SIGNAL_0)
	sig_print_info (oursig);
    }

  printf_filtered (_("\nUse the \"handle\" command "
		     "to change these tables.\n"));
}

/* Check if it makes sense to read $_siginfo from the current thread
   at this point.  If not, throw an error.  */

static void
validate_siginfo_access (void)
{
  /* No current inferior, no siginfo.  */
  if (ptid_equal (inferior_ptid, null_ptid))
    error (_("No thread selected."));

  /* Don't try to read from a dead thread.  */
  if (is_exited (inferior_ptid))
    error (_("The current thread has terminated"));

  /* ... or from a spinning thread.  */
  if (is_running (inferior_ptid))
    error (_("Selected thread is running."));
}

/* The $_siginfo convenience variable is a bit special.  We don't know
   for sure the type of the value until we actually have a chance to
   fetch the data.  The type can change depending on gdbarch, so it is
   also dependent on which thread you have selected.

     1. making $_siginfo be an internalvar that creates a new value on
     access.

     2. making the value of $_siginfo be an lval_computed value.  */

/* This function implements the lval_computed support for reading a
   $_siginfo value.  */

static void
siginfo_value_read (struct value *v)
{
  LONGEST transferred;

  validate_siginfo_access ();

  transferred =
    target_read (&current_target, TARGET_OBJECT_SIGNAL_INFO,
		 NULL,
		 value_contents_all_raw (v),
		 value_offset (v),
		 TYPE_LENGTH (value_type (v)));

  if (transferred != TYPE_LENGTH (value_type (v)))
    error (_("Unable to read siginfo"));
}

/* This function implements the lval_computed support for writing a
   $_siginfo value.  */

static void
siginfo_value_write (struct value *v, struct value *fromval)
{
  LONGEST transferred;

  validate_siginfo_access ();

  transferred = target_write (&current_target,
			      TARGET_OBJECT_SIGNAL_INFO,
			      NULL,
			      value_contents_all_raw (fromval),
			      value_offset (v),
			      TYPE_LENGTH (value_type (fromval)));

  if (transferred != TYPE_LENGTH (value_type (fromval)))
    error (_("Unable to write siginfo"));
}

static const struct lval_funcs siginfo_value_funcs =
  {
    siginfo_value_read,
    siginfo_value_write
  };

/* Return a new value with the correct type for the siginfo object of
   the current thread using architecture GDBARCH.  Return a void value
   if there's no object available.  */

static struct value *
siginfo_make_value (struct gdbarch *gdbarch, struct internalvar *var,
		    void *ignore)
{
  if (target_has_stack
      && !ptid_equal (inferior_ptid, null_ptid)
      && gdbarch_get_siginfo_type_p (gdbarch))
    {
      struct type *type = gdbarch_get_siginfo_type (gdbarch);

      return allocate_computed_value (type, &siginfo_value_funcs, NULL);
    }

  return allocate_value (builtin_type (gdbarch)->builtin_void);
}


/* infcall_suspend_state contains state about the program itself like its
   registers and any signal it received when it last stopped.
   This state must be restored regardless of how the inferior function call
   ends (either successfully, or after it hits a breakpoint or signal)
   if the program is to properly continue where it left off.  */

struct infcall_suspend_state
{
  struct thread_suspend_state thread_suspend;
#if 0 /* Currently unused and empty structures are not valid C.  */
  struct inferior_suspend_state inferior_suspend;
#endif

  /* Other fields:  */
  CORE_ADDR stop_pc;
  struct regcache *registers;

  /* Format of SIGINFO_DATA or NULL if it is not present.  */
  struct gdbarch *siginfo_gdbarch;

  /* The inferior format depends on SIGINFO_GDBARCH and it has a length of
     TYPE_LENGTH (gdbarch_get_siginfo_type ()).  For different gdbarch the
     content would be invalid.  */
  gdb_byte *siginfo_data;
};

struct infcall_suspend_state *
save_infcall_suspend_state (void)
{
  struct infcall_suspend_state *inf_state;
  struct thread_info *tp = inferior_thread ();
#if 0
  struct inferior *inf = current_inferior ();
#endif
  struct regcache *regcache = get_current_regcache ();
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  gdb_byte *siginfo_data = NULL;

  if (gdbarch_get_siginfo_type_p (gdbarch))
    {
      struct type *type = gdbarch_get_siginfo_type (gdbarch);
      size_t len = TYPE_LENGTH (type);
      struct cleanup *back_to;

      siginfo_data = xmalloc (len);
      back_to = make_cleanup (xfree, siginfo_data);

      if (target_read (&current_target, TARGET_OBJECT_SIGNAL_INFO, NULL,
		       siginfo_data, 0, len) == len)
	discard_cleanups (back_to);
      else
	{
	  /* Errors ignored.  */
	  do_cleanups (back_to);
	  siginfo_data = NULL;
	}
    }

  inf_state = XZALLOC (struct infcall_suspend_state);

  if (siginfo_data)
    {
      inf_state->siginfo_gdbarch = gdbarch;
      inf_state->siginfo_data = siginfo_data;
    }

  inf_state->thread_suspend = tp->suspend;
#if 0 /* Currently unused and empty structures are not valid C.  */
  inf_state->inferior_suspend = inf->suspend;
#endif

  /* run_inferior_call will not use the signal due to its `proceed' call with
     GDB_SIGNAL_0 anyway.  */
  tp->suspend.stop_signal = GDB_SIGNAL_0;

  inf_state->stop_pc = stop_pc;

  inf_state->registers = regcache_dup (regcache);

  return inf_state;
}

/* Restore inferior session state to INF_STATE.  */

void
restore_infcall_suspend_state (struct infcall_suspend_state *inf_state)
{
  struct thread_info *tp = inferior_thread ();
#if 0
  struct inferior *inf = current_inferior ();
#endif
  struct regcache *regcache = get_current_regcache ();
  struct gdbarch *gdbarch = get_regcache_arch (regcache);

  tp->suspend = inf_state->thread_suspend;
#if 0 /* Currently unused and empty structures are not valid C.  */
  inf->suspend = inf_state->inferior_suspend;
#endif

  stop_pc = inf_state->stop_pc;

  if (inf_state->siginfo_gdbarch == gdbarch)
    {
      struct type *type = gdbarch_get_siginfo_type (gdbarch);

      /* Errors ignored.  */
      target_write (&current_target, TARGET_OBJECT_SIGNAL_INFO, NULL,
		    inf_state->siginfo_data, 0, TYPE_LENGTH (type));
    }

  /* The inferior can be gone if the user types "print exit(0)"
     (and perhaps other times).  */
  if (target_has_execution)
    /* NB: The register write goes through to the target.  */
    regcache_cpy (regcache, inf_state->registers);

  discard_infcall_suspend_state (inf_state);
}

static void
do_restore_infcall_suspend_state_cleanup (void *state)
{
  restore_infcall_suspend_state (state);
}

struct cleanup *
make_cleanup_restore_infcall_suspend_state
  (struct infcall_suspend_state *inf_state)
{
  return make_cleanup (do_restore_infcall_suspend_state_cleanup, inf_state);
}

void
discard_infcall_suspend_state (struct infcall_suspend_state *inf_state)
{
  regcache_xfree (inf_state->registers);
  xfree (inf_state->siginfo_data);
  xfree (inf_state);
}

struct regcache *
get_infcall_suspend_state_regcache (struct infcall_suspend_state *inf_state)
{
  return inf_state->registers;
}

/* infcall_control_state contains state regarding gdb's control of the
   inferior itself like stepping control.  It also contains session state like
   the user's currently selected frame.  */

struct infcall_control_state
{
  struct thread_control_state thread_control;
  struct inferior_control_state inferior_control;

  /* Other fields:  */
  enum stop_stack_kind stop_stack_dummy;
  int stopped_by_random_signal;
  int stop_after_trap;

  /* ID if the selected frame when the inferior function call was made.  */
  struct frame_id selected_frame_id;
};

/* Save all of the information associated with the inferior<==>gdb
   connection.  */

struct infcall_control_state *
save_infcall_control_state (void)
{
  struct infcall_control_state *inf_status = xmalloc (sizeof (*inf_status));
  struct thread_info *tp = inferior_thread ();
  struct inferior *inf = current_inferior ();

  inf_status->thread_control = tp->control;
  inf_status->inferior_control = inf->control;

  tp->control.step_resume_breakpoint = NULL;
  tp->control.exception_resume_breakpoint = NULL;

  /* Save original bpstat chain to INF_STATUS; replace it in TP with copy of
     chain.  If caller's caller is walking the chain, they'll be happier if we
     hand them back the original chain when restore_infcall_control_state is
     called.  */
  tp->control.stop_bpstat = bpstat_copy (tp->control.stop_bpstat);

  /* Other fields:  */
  inf_status->stop_stack_dummy = stop_stack_dummy;
  inf_status->stopped_by_random_signal = stopped_by_random_signal;
  inf_status->stop_after_trap = stop_after_trap;

  inf_status->selected_frame_id = get_frame_id (get_selected_frame (NULL));

  return inf_status;
}

static int
restore_selected_frame (void *args)
{
  struct frame_id *fid = (struct frame_id *) args;
  struct frame_info *frame;

  frame = frame_find_by_id (*fid);

  /* If inf_status->selected_frame_id is NULL, there was no previously
     selected frame.  */
  if (frame == NULL)
    {
      warning (_("Unable to restore previously selected frame."));
      return 0;
    }

  select_frame (frame);

  return (1);
}

/* Restore inferior session state to INF_STATUS.  */

void
restore_infcall_control_state (struct infcall_control_state *inf_status)
{
  struct thread_info *tp = inferior_thread ();
  struct inferior *inf = current_inferior ();

  if (tp->control.step_resume_breakpoint)
    tp->control.step_resume_breakpoint->disposition = disp_del_at_next_stop;

  if (tp->control.exception_resume_breakpoint)
    tp->control.exception_resume_breakpoint->disposition
      = disp_del_at_next_stop;

  /* Handle the bpstat_copy of the chain.  */
  bpstat_clear (&tp->control.stop_bpstat);

  tp->control = inf_status->thread_control;
  inf->control = inf_status->inferior_control;

  /* Other fields:  */
  stop_stack_dummy = inf_status->stop_stack_dummy;
  stopped_by_random_signal = inf_status->stopped_by_random_signal;
  stop_after_trap = inf_status->stop_after_trap;

  if (target_has_stack)
    {
      /* The point of catch_errors is that if the stack is clobbered,
         walking the stack might encounter a garbage pointer and
         error() trying to dereference it.  */
      if (catch_errors
	  (restore_selected_frame, &inf_status->selected_frame_id,
	   "Unable to restore previously selected frame:\n",
	   RETURN_MASK_ERROR) == 0)
	/* Error in restoring the selected frame.  Select the innermost
	   frame.  */
	select_frame (get_current_frame ());
    }

  xfree (inf_status);
}

static void
do_restore_infcall_control_state_cleanup (void *sts)
{
  restore_infcall_control_state (sts);
}

struct cleanup *
make_cleanup_restore_infcall_control_state
  (struct infcall_control_state *inf_status)
{
  return make_cleanup (do_restore_infcall_control_state_cleanup, inf_status);
}

void
discard_infcall_control_state (struct infcall_control_state *inf_status)
{
  if (inf_status->thread_control.step_resume_breakpoint)
    inf_status->thread_control.step_resume_breakpoint->disposition
      = disp_del_at_next_stop;

  if (inf_status->thread_control.exception_resume_breakpoint)
    inf_status->thread_control.exception_resume_breakpoint->disposition
      = disp_del_at_next_stop;

  /* See save_infcall_control_state for info on stop_bpstat.  */
  bpstat_clear (&inf_status->thread_control.stop_bpstat);

  xfree (inf_status);
}

int
ptid_match (ptid_t ptid, ptid_t filter)
{
  if (ptid_equal (filter, minus_one_ptid))
    return 1;
  if (ptid_is_pid (filter)
      && ptid_get_pid (ptid) == ptid_get_pid (filter))
    return 1;
  else if (ptid_equal (ptid, filter))
    return 1;

  return 0;
}

/* restore_inferior_ptid() will be used by the cleanup machinery
   to restore the inferior_ptid value saved in a call to
   save_inferior_ptid().  */

static void
restore_inferior_ptid (void *arg)
{
  ptid_t *saved_ptid_ptr = arg;

  inferior_ptid = *saved_ptid_ptr;
  xfree (arg);
}

/* Save the value of inferior_ptid so that it may be restored by a
   later call to do_cleanups().  Returns the struct cleanup pointer
   needed for later doing the cleanup.  */

struct cleanup *
save_inferior_ptid (void)
{
  ptid_t *saved_ptid_ptr;

  saved_ptid_ptr = xmalloc (sizeof (ptid_t));
  *saved_ptid_ptr = inferior_ptid;
  return make_cleanup (restore_inferior_ptid, saved_ptid_ptr);
}

/* See inferior.h.  */

void
clear_exit_convenience_vars (void)
{
  clear_internalvar (lookup_internalvar ("_exitsignal"));
  clear_internalvar (lookup_internalvar ("_exitcode"));
}


/* User interface for reverse debugging:
   Set exec-direction / show exec-direction commands
   (returns error unless target implements to_set_exec_direction method).  */

int execution_direction = EXEC_FORWARD;
static const char exec_forward[] = "forward";
static const char exec_reverse[] = "reverse";
static const char *exec_direction = exec_forward;
static const char *const exec_direction_names[] = {
  exec_forward,
  exec_reverse,
  NULL
};

static void
set_exec_direction_func (char *args, int from_tty,
			 struct cmd_list_element *cmd)
{
  if (target_can_execute_reverse)
    {
      if (!strcmp (exec_direction, exec_forward))
	execution_direction = EXEC_FORWARD;
      else if (!strcmp (exec_direction, exec_reverse))
	execution_direction = EXEC_REVERSE;
    }
  else
    {
      exec_direction = exec_forward;
      error (_("Target does not support this operation."));
    }
}

static void
show_exec_direction_func (struct ui_file *out, int from_tty,
			  struct cmd_list_element *cmd, const char *value)
{
  switch (execution_direction) {
  case EXEC_FORWARD:
    fprintf_filtered (out, _("Forward.\n"));
    break;
  case EXEC_REVERSE:
    fprintf_filtered (out, _("Reverse.\n"));
    break;
  default:
    internal_error (__FILE__, __LINE__,
		    _("bogus execution_direction value: %d"),
		    (int) execution_direction);
  }
}

static void
show_schedule_multiple (struct ui_file *file, int from_tty,
			struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Resuming the execution of threads "
			    "of all processes is %s.\n"), value);
}

/* Implementation of `siginfo' variable.  */

static const struct internalvar_funcs siginfo_funcs =
{
  siginfo_make_value,
  NULL,
  NULL
};

void
_initialize_infrun (void)
{
  int i;
  int numsigs;
  struct cmd_list_element *c;

  add_info ("signals", signals_info, _("\
What debugger does when program gets various signals.\n\
Specify a signal as argument to print info on that signal only."));
  add_info_alias ("handle", "signals", 0);

  c = add_com ("handle", class_run, handle_command, _("\
Specify how to handle signals.\n\
Usage: handle SIGNAL [ACTIONS]\n\
Args are signals and actions to apply to those signals.\n\
If no actions are specified, the current settings for the specified signals\n\
will be displayed instead.\n\
\n\
Symbolic signals (e.g. SIGSEGV) are recommended but numeric signals\n\
from 1-15 are allowed for compatibility with old versions of GDB.\n\
Numeric ranges may be specified with the form LOW-HIGH (e.g. 1-5).\n\
The special arg \"all\" is recognized to mean all signals except those\n\
used by the debugger, typically SIGTRAP and SIGINT.\n\
\n\
Recognized actions include \"stop\", \"nostop\", \"print\", \"noprint\",\n\
\"pass\", \"nopass\", \"ignore\", or \"noignore\".\n\
Stop means reenter debugger if this signal happens (implies print).\n\
Print means print a message if this signal happens.\n\
Pass means let program see this signal; otherwise program doesn't know.\n\
Ignore is a synonym for nopass and noignore is a synonym for pass.\n\
Pass and Stop may be combined.\n\
\n\
Multiple signals may be specified.  Signal numbers and signal names\n\
may be interspersed with actions, with the actions being performed for\n\
all signals cumulatively specified."));
  set_cmd_completer (c, handle_completer);

  if (xdb_commands)
    {
      add_com ("lz", class_info, signals_info, _("\
What debugger does when program gets various signals.\n\
Specify a signal as argument to print info on that signal only."));
      add_com ("z", class_run, xdb_handle_command, _("\
Specify how to handle a signal.\n\
Args are signals and actions to apply to those signals.\n\
Symbolic signals (e.g. SIGSEGV) are recommended but numeric signals\n\
from 1-15 are allowed for compatibility with old versions of GDB.\n\
Numeric ranges may be specified with the form LOW-HIGH (e.g. 1-5).\n\
The special arg \"all\" is recognized to mean all signals except those\n\
used by the debugger, typically SIGTRAP and SIGINT.\n\
Recognized actions include \"s\" (toggles between stop and nostop),\n\
\"r\" (toggles between print and noprint), \"i\" (toggles between pass and \
nopass), \"Q\" (noprint)\n\
Stop means reenter debugger if this signal happens (implies print).\n\
Print means print a message if this signal happens.\n\
Pass means let program see this signal; otherwise program doesn't know.\n\
Ignore is a synonym for nopass and noignore is a synonym for pass.\n\
Pass and Stop may be combined."));
    }

  if (!dbx_commands)
    stop_command = add_cmd ("stop", class_obscure,
			    not_just_help_class_command, _("\
There is no `stop' command, but you can set a hook on `stop'.\n\
This allows you to set a list of commands to be run each time execution\n\
of the program stops."), &cmdlist);

  add_setshow_zuinteger_cmd ("infrun", class_maintenance, &debug_infrun, _("\
Set inferior debugging."), _("\
Show inferior debugging."), _("\
When non-zero, inferior specific debugging is enabled."),
			     NULL,
			     show_debug_infrun,
			     &setdebuglist, &showdebuglist);

  add_setshow_boolean_cmd ("displaced", class_maintenance,
			   &debug_displaced, _("\
Set displaced stepping debugging."), _("\
Show displaced stepping debugging."), _("\
When non-zero, displaced stepping specific debugging is enabled."),
			    NULL,
			    show_debug_displaced,
			    &setdebuglist, &showdebuglist);

  add_setshow_boolean_cmd ("non-stop", no_class,
			   &non_stop_1, _("\
Set whether gdb controls the inferior in non-stop mode."), _("\
Show whether gdb controls the inferior in non-stop mode."), _("\
When debugging a multi-threaded program and this setting is\n\
off (the default, also called all-stop mode), when one thread stops\n\
(for a breakpoint, watchpoint, exception, or similar events), GDB stops\n\
all other threads in the program while you interact with the thread of\n\
interest.  When you continue or step a thread, you can allow the other\n\
threads to run, or have them remain stopped, but while you inspect any\n\
thread's state, all threads stop.\n\
\n\
In non-stop mode, when one thread stops, other threads can continue\n\
to run freely.  You'll be able to step each thread independently,\n\
leave it stopped or free to run as needed."),
			   set_non_stop,
			   show_non_stop,
			   &setlist,
			   &showlist);

  numsigs = (int) GDB_SIGNAL_LAST;
  signal_stop = (unsigned char *) xmalloc (sizeof (signal_stop[0]) * numsigs);
  signal_print = (unsigned char *)
    xmalloc (sizeof (signal_print[0]) * numsigs);
  signal_program = (unsigned char *)
    xmalloc (sizeof (signal_program[0]) * numsigs);
  signal_catch = (unsigned char *)
    xmalloc (sizeof (signal_catch[0]) * numsigs);
  signal_pass = (unsigned char *)
    xmalloc (sizeof (signal_program[0]) * numsigs);
  for (i = 0; i < numsigs; i++)
    {
      signal_stop[i] = 1;
      signal_print[i] = 1;
      signal_program[i] = 1;
      signal_catch[i] = 0;
    }

  /* Signals caused by debugger's own actions
     should not be given to the program afterwards.  */
  signal_program[GDB_SIGNAL_TRAP] = 0;
  signal_program[GDB_SIGNAL_INT] = 0;

  /* Signals that are not errors should not normally enter the debugger.  */
  signal_stop[GDB_SIGNAL_ALRM] = 0;
  signal_print[GDB_SIGNAL_ALRM] = 0;
  signal_stop[GDB_SIGNAL_VTALRM] = 0;
  signal_print[GDB_SIGNAL_VTALRM] = 0;
  signal_stop[GDB_SIGNAL_PROF] = 0;
  signal_print[GDB_SIGNAL_PROF] = 0;
  signal_stop[GDB_SIGNAL_CHLD] = 0;
  signal_print[GDB_SIGNAL_CHLD] = 0;
  signal_stop[GDB_SIGNAL_IO] = 0;
  signal_print[GDB_SIGNAL_IO] = 0;
  signal_stop[GDB_SIGNAL_POLL] = 0;
  signal_print[GDB_SIGNAL_POLL] = 0;
  signal_stop[GDB_SIGNAL_URG] = 0;
  signal_print[GDB_SIGNAL_URG] = 0;
  signal_stop[GDB_SIGNAL_WINCH] = 0;
  signal_print[GDB_SIGNAL_WINCH] = 0;
  signal_stop[GDB_SIGNAL_PRIO] = 0;
  signal_print[GDB_SIGNAL_PRIO] = 0;

  /* These signals are used internally by user-level thread
     implementations.  (See signal(5) on Solaris.)  Like the above
     signals, a healthy program receives and handles them as part of
     its normal operation.  */
  signal_stop[GDB_SIGNAL_LWP] = 0;
  signal_print[GDB_SIGNAL_LWP] = 0;
  signal_stop[GDB_SIGNAL_WAITING] = 0;
  signal_print[GDB_SIGNAL_WAITING] = 0;
  signal_stop[GDB_SIGNAL_CANCEL] = 0;
  signal_print[GDB_SIGNAL_CANCEL] = 0;

  /* Update cached state.  */
  signal_cache_update (-1);

  add_setshow_zinteger_cmd ("stop-on-solib-events", class_support,
			    &stop_on_solib_events, _("\
Set stopping for shared library events."), _("\
Show stopping for shared library events."), _("\
If nonzero, gdb will give control to the user when the dynamic linker\n\
notifies gdb of shared library events.  The most common event of interest\n\
to the user would be loading/unloading of a new library."),
			    set_stop_on_solib_events,
			    show_stop_on_solib_events,
			    &setlist, &showlist);

  add_setshow_enum_cmd ("follow-fork-mode", class_run,
			follow_fork_mode_kind_names,
			&follow_fork_mode_string, _("\
Set debugger response to a program call of fork or vfork."), _("\
Show debugger response to a program call of fork or vfork."), _("\
A fork or vfork creates a new process.  follow-fork-mode can be:\n\
  parent  - the original process is debugged after a fork\n\
  child   - the new process is debugged after a fork\n\
The unfollowed process will continue to run.\n\
By default, the debugger will follow the parent process."),
			NULL,
			show_follow_fork_mode_string,
			&setlist, &showlist);

  add_setshow_enum_cmd ("follow-exec-mode", class_run,
			follow_exec_mode_names,
			&follow_exec_mode_string, _("\
Set debugger response to a program call of exec."), _("\
Show debugger response to a program call of exec."), _("\
An exec call replaces the program image of a process.\n\
\n\
follow-exec-mode can be:\n\
\n\
  new - the debugger creates a new inferior and rebinds the process\n\
to this new inferior.  The program the process was running before\n\
the exec call can be restarted afterwards by restarting the original\n\
inferior.\n\
\n\
  same - the debugger keeps the process bound to the same inferior.\n\
The new executable image replaces the previous executable loaded in\n\
the inferior.  Restarting the inferior after the exec call restarts\n\
the executable the process was running after the exec call.\n\
\n\
By default, the debugger will use the same inferior."),
			NULL,
			show_follow_exec_mode_string,
			&setlist, &showlist);

  add_setshow_enum_cmd ("scheduler-locking", class_run, 
			scheduler_enums, &scheduler_mode, _("\
Set mode for locking scheduler during execution."), _("\
Show mode for locking scheduler during execution."), _("\
off  == no locking (threads may preempt at any time)\n\
on   == full locking (no thread except the current thread may run)\n\
step == scheduler locked during every single-step operation.\n\
	In this mode, no other thread may run during a step command.\n\
	Other threads may run while stepping over a function call ('next')."), 
			set_schedlock_func,	/* traps on target vector */
			show_scheduler_mode,
			&setlist, &showlist);

  add_setshow_boolean_cmd ("schedule-multiple", class_run, &sched_multi, _("\
Set mode for resuming threads of all processes."), _("\
Show mode for resuming threads of all processes."), _("\
When on, execution commands (such as 'continue' or 'next') resume all\n\
threads of all processes.  When off (which is the default), execution\n\
commands only resume the threads of the current process.  The set of\n\
threads that are resumed is further refined by the scheduler-locking\n\
mode (see help set scheduler-locking)."),
			   NULL,
			   show_schedule_multiple,
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("step-mode", class_run, &step_stop_if_no_debug, _("\
Set mode of the step operation."), _("\
Show mode of the step operation."), _("\
When set, doing a step over a function without debug line information\n\
will stop at the first instruction of that function. Otherwise, the\n\
function is skipped and the step command stops at a different source line."),
			   NULL,
			   show_step_stop_if_no_debug,
			   &setlist, &showlist);

  add_setshow_auto_boolean_cmd ("displaced-stepping", class_run,
				&can_use_displaced_stepping, _("\
Set debugger's willingness to use displaced stepping."), _("\
Show debugger's willingness to use displaced stepping."), _("\
If on, gdb will use displaced stepping to step over breakpoints if it is\n\
supported by the target architecture.  If off, gdb will not use displaced\n\
stepping to step over breakpoints, even if such is supported by the target\n\
architecture.  If auto (which is the default), gdb will use displaced stepping\n\
if the target architecture supports it and non-stop mode is active, but will not\n\
use it in all-stop mode (see help set non-stop)."),
				NULL,
				show_can_use_displaced_stepping,
				&setlist, &showlist);

  add_setshow_enum_cmd ("exec-direction", class_run, exec_direction_names,
			&exec_direction, _("Set direction of execution.\n\
Options are 'forward' or 'reverse'."),
			_("Show direction of execution (forward/reverse)."),
			_("Tells gdb whether to execute forward or backward."),
			set_exec_direction_func, show_exec_direction_func,
			&setlist, &showlist);

  /* Set/show detach-on-fork: user-settable mode.  */

  add_setshow_boolean_cmd ("detach-on-fork", class_run, &detach_fork, _("\
Set whether gdb will detach the child of a fork."), _("\
Show whether gdb will detach the child of a fork."), _("\
Tells gdb whether to detach the child of a fork."),
			   NULL, NULL, &setlist, &showlist);

  /* Set/show disable address space randomization mode.  */

  add_setshow_boolean_cmd ("disable-randomization", class_support,
			   &disable_randomization, _("\
Set disabling of debuggee's virtual address space randomization."), _("\
Show disabling of debuggee's virtual address space randomization."), _("\
When this mode is on (which is the default), randomization of the virtual\n\
address space is disabled.  Standalone programs run with the randomization\n\
enabled by default on some platforms."),
			   &set_disable_randomization,
			   &show_disable_randomization,
			   &setlist, &showlist);

  /* ptid initializations */
  inferior_ptid = null_ptid;
  target_last_wait_ptid = minus_one_ptid;

  observer_attach_thread_ptid_changed (infrun_thread_ptid_changed);
  observer_attach_thread_stop_requested (infrun_thread_stop_requested);
  observer_attach_thread_exit (infrun_thread_thread_exit);
  observer_attach_inferior_exit (infrun_inferior_exit);

  /* Explicitly create without lookup, since that tries to create a
     value with a void typed value, and when we get here, gdbarch
     isn't initialized yet.  At this point, we're quite sure there
     isn't another convenience variable of the same name.  */
  create_internalvar_type_lazy ("_siginfo", &siginfo_funcs, NULL);

  add_setshow_boolean_cmd ("observer", no_class,
			   &observer_mode_1, _("\
Set whether gdb controls the inferior in observer mode."), _("\
Show whether gdb controls the inferior in observer mode."), _("\
In observer mode, GDB can get data from the inferior, but not\n\
affect its execution.  Registers and memory may not be changed,\n\
breakpoints may not be set, and the program cannot be interrupted\n\
or signalled."),
			   set_observer_mode,
			   show_observer_mode,
			   &setlist,
			   &showlist);
}
@


1.594
log
@This patch  adds a new convenience variable called "$_exitsignal", which
will hold the signal number when the inferior terminates due to the
uncaught signal.

I've made modifications on infrun.c:handle_inferior_event such that
$_exitcode gets cleared when the inferior signalled, and vice-versa.
This assumption was made because the variables are mutually
exclusive, i.e., when the inferior terminates because of an uncaught
signal it is not possible for it to return.  I have also made modifications
such that when a corefile is loaded, $_exitsignal gets set to the uncaught
signal that "killed" the inferior, and $_exitcode is cleared.

The patch also adds a NEWS entry, documentation bits, and a testcase.  The
documentation entry explains how to use $_exitsignal and $_exitcode in a
GDB script, by making use of the new $_isvoid convenience function.

gdb/
2013-10-06  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* NEWS: Mention new convenience variable $_exitsignal.
	* corelow.c (core_open): Reset exit convenience variables.  Set
	$_exitsignal to the uncaught signal which generated the corefile.
	* infrun.c (handle_inferior_event): Reset exit convenience
	variables.  Set $_exitsignal for TARGET_WAITKIND_SIGNALLED.
	(clear_exit_convenience_vars): New function.
	* inferior.h (clear_exit_convenience_vars): New prototype.

gdb/testsuite/
2013-10-06  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* gdb.base/corefile.exp: Test whether $_exitsignal is set and
	$_exitcode is void when opening a corefile.
	* gdb.base/exitsignal.exp: New file.
	* gdb.base/segv.c: Likewise.
	* gdb.base/normal.c: Likewise.

gdb/doc/
2013-10-06  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* gdb.texinfo (Convenience Variables): Document $_exitsignal.
	Update entry for $_exitcode.
@
text
@d4718 11
@


1.593
log
@	* aarch64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* aix-thread.c (BUILD_THREAD, BUILD_LWP): Remove.
	Replace BUILD_THREAD with ptid_build.
	Replace BUILD_LWP with ptid_build.
	Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* alphabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* amd64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* amd64bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* arm-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* armnbsd-nat.c: Replace PIDGET with ptid_get_pid.
	* auxv.c: Likewise.
	* breakpoint.c: Likewise.
	* common/ptid.c (ptid_is_pid): Condense check for
	null_ptid and minus_one_ptid.
	(ptid_lwp_p): New function.
	(ptid_tid_p): New function.
	* common/ptid.h: Update comments for accessors.
	(ptid_lwp_p): New prototype.
	(ptid_tid_p): New prototype.
	* defs.h (PIDGET, TIDGET, MERGEPID): Do not define.
	* gcore.c: Replace PIDGET with ptid_get_pid.
	* gdbthread.h: Likewise.
	* gnu-nat.c: Likewise.
	* hppa-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* hppabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* hppanbsd-nat.c: Likewise.
	* i386-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* i386bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* ia64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	* infcmd.c: Likewise.
	* inferior.h: Likewise.
	* inflow.c: Likewise.
	* infrun.c: Likewise.
	* linux-fork.c: Likewise.
	* linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace GET_PID with ptid_get_pid.
	Replace is_lwp with ptid_lwp_p.
	Replace GET_LWP with ptid_get_lwp.
	Replace BUILD_LWP with ptid_build.
@
text
@d3429 3
d3446 28
a3473 1
	print_signal_exited_reason (ecs->ws.value.sig);
d7094 9
@


1.592
log
@When reverse-stepping, only insert a resume breakpoint at ecs->stop_func_start
if the function start is known.  Otherwise, keep single-stepping.
@
text
@d2610 2
a2611 2
		      "infrun: target_wait (%d", PIDGET (waiton_ptid));
  if (PIDGET (waiton_ptid) != -1)
d2617 2
a2618 1
		      PIDGET (result_ptid), target_pid_to_str (result_ptid));
@


1.591
log
@PR gdb/15911: "info threads" changes the default source and line (for "break", "list")

"info threads" changes the default source for "break" and "list", to
whatever the location of the first/bottom thread in the thread list
is...

 (gdb) b start
 (gdb) c
 ...
 (gdb) list
 *lists "start"*
 (gdb) b 23
 Breakpoint 3 at 0x400614: file test.c, line 23.
 (gdb) info threads
   Id   Target Id         Frame
 * 2    Thread 0x7ffff7fcb700 (LWP 1760) "test" start (arg=0x0) at test.c:23
   1    Thread 0x7ffff7fcc740 (LWP 1748) "test" 0x000000323dc08e60 in pthread_join (threadid=140737353922304, thread_return=0x0) at pthread_join.c:93
 (gdb) b 23
 Breakpoint 4 at 0x323dc08d90: file pthread_join.c, line 23.
                                    ^^^^^^^^^^^^^^^
 (gdb) list
 93          lll_wait_tid (pd->tid);
 94
 95
 96        /* Restore cancellation mode.  */
 97        CANCEL_RESET (oldtype);
 98
 99        /* Remove the handler.  */
 100       pthread_cleanup_pop (0);
 101
 102

The issue is that print_stack_frame always sets the current sal to the
frame's sal.  print_frame_info (which print_stack_frame calls to do
most of the work) also sets the last displayed sal, but only if
print_what isn't LOCATION.  Now the call in question, from within
thread.c:print_thread_info, does pass in LOCATION as print_what, but
print_stack_frame doesn't have the same check print_frame_info has.
We could consider adding it, but setting these globals depending on
print_what isn't very clean, IMO.  What we have is two logically
distinct operations mixed in the same function(s):

  #1 - print frame, in the format specified by {print_what,
    print_level and print_args}.

  #2 - We're displaying a frame to the user, and I want the default
    sal to point here, because the program stopped here, or the user
    did some context-changing command (up, down, etc.).

So I added a new parameter to print_stack_frame & friends for point
#2, and went through all calls in the tree adjusting as necessary.

Tested on x86_64 Fedora 17.

gdb/
2013-09-17  Pedro Alves  <palves@@redhat.com>

	PR gdb/15911
	* ada-tasks.c (task_command_1): Adjust call to print_stack_frame.
	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd):
	* corelow.c (core_open):
	* frame.h (print_stack_frame, print_frame_info): New
	'set_current_sal' parameter.
	* infcmd.c (finish_command, kill_command): Adjust call to
	print_stack_frame.
	* inferior.c (inferior_command): Likewise.
	* infrun.c (normal_stop): Likewise.
	* linux-fork.c (linux_fork_context): Likewise.
	* record-full.c (record_full_goto_entry, record_full_restore):
	Likewise.
	* remote-mips.c (common_open): Likewise.
	* stack.c (print_stack_frame): New 'set_current_sal' parameter.
	Use it.
	(print_frame_info): New 'set_current_sal' parameter.  Set the last
	displayed sal depending on the new paremeter instead of looking at
	print_what.
	(backtrace_command_1, select_and_print_frame, frame_command)
	(current_frame_command, up_command, down_command): Adjust call to
	print_stack_frame.
	* thread.c (print_thread_info, restore_selected_frame)
	(do_captured_thread_select): Adjust call to print_stack_frame.
	* tracepoint.c (tfind_1): Likewise.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_frame): Likewise.
	* mi/mi-interp.c (mi_on_normal_stop): Likewise.
	* mi/mi-main.c (mi_cmd_exec_return, mi_cmd_trace_find): Likewise.

	gdb/testsuite/
	* gdb.threads/info-threads-cur-sal-2.c: New file.
	* gdb.threads/info-threads-cur-sal.c: New file.
	* gdb.threads/info-threads-cur-sal.exp: New file.
@
text
@d4946 1
a4946 1
	      if (ecs->stop_func_start != stop_pc)
@


1.590
log
@	* inf-child.c (inf_child_follow_fork) New parameter
	detach_fork.
	* inf-ptrace.c (inf_ptrace_follow_fork): Likewise.
	* inf-ttrace.c (inf_ttrace_follow_fork): Likewise.
	* inferior.h (detach_fork): Remove.
	* infrun.c (detach_fork): Adjust comment and make it
	static.
	(follow_fork): Pass detach_fork parameter to
	target_follow_fork.
	* linux-nat.c (linux_child_follow_fork): New parameter
	detach_fork.
	* target.c (target_follow_fork): New parameter detach_fork.
	Pass detach_fork as parameter and print its value.
	* target.h (struct target_ops) <to_follow_fork>: New int
	parameter.
	(target_follow_fork): New parameter detach_fork.
@
text
@d6105 1
a6105 1
	    print_stack_frame (get_selected_frame (NULL), 0, source_flag);
@


1.589
log
@Move pagination_enabled declaration to a proper place.

Declare it close to other related declarations in utils.h, and remove
local extern declaration hack.

gdb/
2013-06-28  Pedro Alves  <palves@@redhat.com>

	* infrun.c (set_observer_mode): Don't declare pagination_enabled
	here.
	* utils.h (pagination_enabled): Declare.
@
text
@d135 6
a140 2
/* Default behavior is to detach newly forked processes (legacy).  */
int detach_fork = 1;
d504 1
a504 1
	if (target_follow_fork (follow_child))
@


1.588
log
@infrun.c: Move non_stop_1 etc., higher up in file.

The "non_stop_1" global is out of place, mixed with the observer bits.
This moves all the non-stop user-interface-related bits together.

gdb/
2013-06-28  Pedro Alves  <palves@@redhat.com>

	* infrun.c (non_stop, non_stop_1, set_non_stop, show_non_stop):
	Move higher up in file.
@
text
@a221 2
  extern int pagination_enabled;

@


1.587
log
@Move comment on the 'stepping over resolver' mechanism to the internals manual.

This whole comment is now a bit out of place.  I looked into moving it
to handle_inferior_event, close to where in_solib_dynsym_resolve_code
is used, but then there are 3 such places.  I then looked at
fragmenting it, pushing bits closer to the definitions of
in_solib_dynsym_resolve_code and gdbarch_skip_solib_resolver, but then
we'd lose the main advantage which is the overview.  In the end, I
realized this can fit nicely as internals manual material.

This could possibly be a subsection of a new "run control", or "source
stepping" or "stepping" or some such a bit more general section, but
we can do that when we have more related content...  Even the "single
stepping" section is presently empty...

gdb/doc/
2013-06-27  Pedro Alves  <palves@@redhat.com>

	* gdbint.texinfo (Algorithms) <Stepping over runtime loader
	dynamic symbol resolution code>: New section, based on infrun.c
	comment.

gdb/
2013-06-27  Pedro Alves  <palves@@redhat.com>

	* infrun.c: Remove comment describing the 'stepping over runtime
	loader dynamic symbol resolution code' mechanism; moved to
	gdbint.texinfo.
@
text
@d184 27
a214 2
static int non_stop_1 = 0;

a7112 26
/* User interface for non-stop mode.  */

int non_stop = 0;

static void
set_non_stop (char *args, int from_tty,
	      struct cmd_list_element *c)
{
  if (target_has_execution)
    {
      non_stop_1 = non_stop;
      error (_("Cannot change this setting while the inferior is running."));
    }

  non_stop = non_stop_1;
}

static void
show_non_stop (struct ui_file *file, int from_tty,
	       struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file,
		    _("Controlling the inferior in non-stop mode is %s.\n"),
		    value);
}

@


1.586
log
@Garbage collect SOLIB_IN_DYNAMIC_LINKER.

This hasn't been used for years.

gdb/
2013-06-26  Pedro Alves  <palves@@redhat.com>

	* infrun.c (SOLIB_IN_DYNAMIC_LINKER): Delete macro and describing
	comment.
@
text
@a183 40

/* If the program uses ELF-style shared libraries, then calls to
   functions in shared libraries go through stubs, which live in a
   table called the PLT (Procedure Linkage Table).  The first time the
   function is called, the stub sends control to the dynamic linker,
   which looks up the function's real address, patches the stub so
   that future calls will go directly to the function, and then passes
   control to the function.

   If we are stepping at the source level, we don't want to see any of
   this --- we just want to skip over the stub and the dynamic linker.
   The simple approach is to single-step until control leaves the
   dynamic linker.

   However, on some systems (e.g., Red Hat's 5.2 distribution) the
   dynamic linker calls functions in the shared C library, so you
   can't tell from the PC alone whether the dynamic linker is still
   running.  In this case, we use a step-resume breakpoint to get us
   past the dynamic linker, as if we were using "next" to step over a
   function call.

   in_solib_dynsym_resolve_code() says whether we're in the dynamic
   linker code or not.  Normally, this means we single-step.  However,
   if gdbarch_skip_solib_resolver then returns non-zero, then its
   value is an address where we can place a step-resume breakpoint to
   get past the linker's symbol resolution function.

   The in_dynsym_resolve_code hook of the target_so_ops vector can
   generally be implemented in a pretty portable way, by comparing the
   PC against the address ranges of the dynamic linker's sections.

   The gdbarch_skip_solib_resolver implementation is generally going
   to be system-specific, since it depends on internal details of the
   dynamic linker.  It's usually not too hard to figure out where to
   put a breakpoint, but it certainly isn't portable.
   gdbarch_skip_solib_resolver should do plenty of sanity checking.
   If it can't figure things out, returning zero and getting the
   (possibly confusing) stepping behavior is better than signaling an
   error, which will obscure the change in the inferior's state.  */

@


1.585
log
@Update comments on stepping over resolver code.

This updates the comments on the step-over-resolver mechanism a bit,
adjusting it to refer to the gdbarch hooks instead of the old macros;
to mention the in_dynsym_resolve_code hook of the target_so_ops
vector; and to American English spelling (signalling->signaling).

gdb/
2013-06-26  Pedro Alves  <palves@@redhat.com>

	* infrun.c: Update comments on stepping over runtime loader
	dynamic symbol resolution code.
@
text
@a223 12
/* This function returns TRUE if pc is the address of an instruction
   that lies within the dynamic linker (such as the event hook, or the
   dld itself).

   This function must be used only when a dynamic linker event has
   been caught, and the inferior is being stepped out of the hook, or
   undefined results are guaranteed.  */

#ifndef SOLIB_IN_DYNAMIC_LINKER
#define SOLIB_IN_DYNAMIC_LINKER(pid,pc) 0
#endif

@


1.584
log
@Fix PR cli/15603

This fixes PR cli/15603.

The bug here is that when a software watchpoint is being used, gdb
will stop responding to C-c.  This is a regression caused by the
"catch signal" patch.

The problem is that software watchpoints always end up on the bpstat
list.  However, this makes bpstat_explains_signal return
BPSTAT_SIGNAL_HIDE, causing infrun to think that the signal is not a
"random signal".

The fix is to change bpstat_explains_signal to handle this better.  I
chose to do it in a "clean API" way, by passing the signal value to
bpstat_explains_signal and then adding an explains_signal method for
watchpoints, which handles the specifics.

Built and regtested on x86-64 Fedora 18.
New test case included.

	* break-catch-sig.c (signal_catchpoint_explains_signal): Add 'sig'
	argument.
	* breakpoint.c (bpstat_explains_signal): Add 'sig' argument.
	Special case signals other than GDB_SIGNAL_TRAP.
	(explains_signal_watchpoint): New function.
	(base_breakpoint_explains_signal): Add 'sig' argument.
	(initialize_breakpoint_ops): Set 'explains_signal' method for
	watchpoints.
	* breakpoint.h (struct breakpoint_ops) <explains_signal>: Add
	signal argument.
	(bpstat_explains_signal): Likewise.
	* infrun.c (handle_syscall_event, handle_inferior_event): Update.

	* gdb.base/random-signal.c: New file.
	* gdb.base/random-signal.exp: New file.
@
text
@d207 16
a222 16
   if SKIP_SOLIB_RESOLVER then returns non-zero, then its value is an
   address where we can place a step-resume breakpoint to get past the
   linker's symbol resolution function.

   in_solib_dynsym_resolve_code() can generally be implemented in a
   pretty portable way, by comparing the PC against the address ranges
   of the dynamic linker's sections.

   SKIP_SOLIB_RESOLVER is generally going to be system-specific, since
   it depends on internal details of the dynamic linker.  It's usually
   not too hard to figure out where to put a breakpoint, but it
   certainly isn't portable.  SKIP_SOLIB_RESOLVER should do plenty of
   sanity checking.  If it can't figure things out, returning zero and
   getting the (possibly confusing) stepping behavior is better than
   signalling an error, which will obscure the change in the
   inferior's state.  */
@


1.583
log
@2013-06-04  Gary Benson  <gbenson@@redhat.com>

	* breakpoint.h (handle_solib_event): Moved function declaration
	to solib.h.
	* breakpoint.c (handle_solib_event): Moved function to solib.c.
	(bpstat_stop_status): Pass new argument to handle_solib_event.
	* solib.h (update_solib_breakpoints): New function declaration.
	(handle_solib_event): Moved function declaration from
	breakpoint.h.
	* solib.c (update_solib_breakpoints): New function.
	(handle_solib_event): Moved function from breakpoint.c.
	Updated to call solib_ops->handle_event if not NULL.
	* solist.h (target_so_ops): New fields "update_breakpoints" and
	"handle_event".
	* infrun.c (set_stop_on_solib_events): New function.
	(_initialize_infrun): Use the above for "set
	stop-on-solib-events".
	(handle_inferior_event): Pass new argument to handle_solib_event.
	* solib-svr4.c (probe.h): New include.
	(svr4_free_library_list): New forward declaration.
	(probe_action): New enum.
	(probe_info): New struct.
	(probe_info): New static variable.
	(NUM_PROBES): New definition.
	(svr4_info): New fields "using_xfer", "probes_table" and
	"solib_list".
	(free_probes_table): New function.
	(free_solib_list): New function.
	(svr4_pspace_data_cleanup): Free probes table and solib list.
	(svr4_copy_library_list): New function.
	(svr4_current_sos_via_xfer_libraries): New parameter "annex".
	(svr4_read_so_list): New parameter "prev_lm".
	(svr4_current_sos_direct): Renamed from "svr4_current_sos".
	(svr4_current_sos): New function.
	(probe_and_action): New struct.
	(hash_probe_and_action): New function.
	(equal_probe_and_action): Likewise.
	(register_solib_event_probe): Likewise.
	(solib_event_probe_at): Likewise.
	(solib_event_probe_action): Likewise.
	(solist_update_full): Likewise.
	(solist_update_incremental): Likewise.
	(disable_probes_interface_cleanup): Likewise.
	(svr4_handle_solib_event): Likewise.
	(svr4_update_solib_event_breakpoint): Likewise.
	(svr4_update_solib_event_breakpoints): Likewise.
	(svr4_create_solib_event_breakpoints): Likewise.
	(enable_break): Free probes table before creating breakpoints.
	Use svr4_create_solib_event_breakpoints to create breakpoints.
	(svr4_solib_create_inferior_hook): Free the solib list.
	(_initialize_svr4_solib): Initialise
	svr4_so_ops.handle_solib_event and svr4_so_ops.update_breakpoints.
@
text
@d3127 2
a3128 1
      sval = bpstat_explains_signal (ecs->event_thread->control.stop_bpstat);
d3378 2
a3379 1
	    = bpstat_explains_signal (ecs->event_thread->control.stop_bpstat);
d3678 2
a3679 1
	= (bpstat_explains_signal (ecs->event_thread->control.stop_bpstat)
d4254 2
a4255 1
      && (bpstat_explains_signal (ecs->event_thread->control.stop_bpstat)
d4284 2
a4285 1
      = !((bpstat_explains_signal (ecs->event_thread->control.stop_bpstat)
d4296 2
a4297 1
      sval = bpstat_explains_signal (ecs->event_thread->control.stop_bpstat);
@


1.582
log
@some fixes to infrun.c

This fixes some of the problems in infrun.c that the checker reported.
I filed the remaining problems as bugs.

This patch is purely stylistic.

	* infrun.c (adjust_pc_after_break): Introduce an outer null
	cleanup.
@
text
@d373 10
d7346 1
a7346 1
			    NULL,
@


1.581
log
@range stepping: gdb

This patch teaches GDB to take advantage of target-assisted range
stepping.  It adds a new 'r ADDR1,ADDR2' action to vCont (vCont;r),
meaning, "step once, and keep stepping as long as the thread is in the
[ADDR1,ADDR2) range".

Rationale:

When user issues the "step" command on the following line of source,

   a = b + c + d * e - a;

GDB single-steps every single instruction until the program reaches a
new different line.  E.g., on x86_64, that line compiles to:

   0x08048434 <+65>:    mov    0x1c(%esp),%eax
   0x08048438 <+69>:    mov    0x30(%esp),%edx
   0x0804843c <+73>:    add    %eax,%edx
   0x0804843e <+75>:    mov    0x18(%esp),%eax
   0x08048442 <+79>:    imul   0x2c(%esp),%eax
   0x08048447 <+84>:    add    %edx,%eax
   0x08048449 <+86>:    sub    0x34(%esp),%eax
   0x0804844d <+90>:    mov    %eax,0x34(%esp)
   0x08048451 <+94>:    mov    0x1c(%esp),%eax

and the following is the RSP traffic between GDB and GDBserver:

 --> vCont;s:p2e13.2e13;c
 <-- T0505:68efffbf;04:30efffbf;08:3c840408;thread:p2e13.2e13;core:1;
 --> vCont;s:p2e13.2e13;c
 <-- T0505:68efffbf;04:30efffbf;08:3e840408;thread:p2e13.2e13;core:2;
 --> vCont;s:p2e13.2e13;c
 <-- T0505:68efffbf;04:30efffbf;08:42840408;thread:p2e13.2e13;core:2;
 --> vCont;s:p2e13.2e13;c
 <-- T0505:68efffbf;04:30efffbf;08:47840408;thread:p2e13.2e13;core:0;
 --> vCont;s:p2e13.2e13;c
 <-- T0505:68efffbf;04:30efffbf;08:49840408;thread:p2e13.2e13;core:0;
 --> vCont;s:p2e13.2e13;c
 <-- T0505:68efffbf;04:30efffbf;08:4d840408;thread:p2e13.2e13;core:0;
 --> vCont;s:p2e13.2e13;c
 <-- T0505:68efffbf;04:30efffbf;08:51840408;thread:p2e13.2e13;core:0;

IOW, a lot of roundtrips between GDB and GDBserver.

If we add a new command to the RSP, meaning "keep stepping and don't
report a stop until the program goes out of the [0x08048434,
0x08048451) address range", then the RSP traffic can be reduced down
to:

 --> vCont;r8048434,8048451:p2db0.2db0;c
 <-- T0505:68efffbf;04:30efffbf;08:51840408;thread:p2db0.2db0;core:1;

As number of packets is reduced dramatically, the performance of
stepping source lines is much improved.

In case something is wrong with range stepping on the stub side, the
debug info or even gdb, this adds a "set/show range-stepping" command
to be able to turn range stepping off.

gdb/
2013-05-23  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdbthread.h (struct thread_control_state) <may_range_step>: New
	field.
	* infcmd.c (step_once, until_next_command): Enable range stepping.
	* infrun.c (displaced_step_prepare): Disable range stepping.
	(resume): Disable range stepping if stepping over a breakpoint or
	we have software watchpoints.  If range stepping is enabled,
	assert the thread is in the stepping range.
	(clear_proceed_status_thread): Clear may_range_step.
	(handle_inferior_event): Disable range stepping as soon as we know
	the thread that hit the event.  Re-enable it whenever we're going
	to step with a step range.
	* remote.c (struct vCont_action_support) <r>: New field.
	(use_range_stepping): New global.
	(remote_vcont_probe): Handle 'r' action.
	(append_resumption): Append an 'r' action if the thread may range
	step.
	(show_range_stepping): New function.
	(set_range_stepping): New function.
	(_initialize_remote): Call add_setshow_boolean_cmd to register the
	'set range-stepping' and 'show range-stepping' commands.
	* NEWS: Mention range stepping, the new vCont;r action, and the
	new "set/show range-stepping" commands.

gdb/doc/
2013-05-23  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdb.texinfo (Packets): Document 'vCont;r'.
	(Continuing and Stepping): Document target-assisted range
	stepping, and the 'set range-stepping' and 'show range-stepping'
	commands.
@
text
@d3030 1
a3030 1
      struct cleanup *old_cleanups = NULL;
d3033 1
a3033 1
	old_cleanups = record_full_gdb_operation_disable_set ();
d3059 1
a3059 2
      if (RECORD_IS_USED)
	do_cleanups (old_cleanups);
@


1.580
log
@Factor out in-stepping-range checks.

This adds a function for doing within-thread's-stepping-range checks,
and converts a couple spots to use it.  Following patches will add
more uses.

gdb/
2013-05-23  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdbthread.h (pc_in_thread_step_range): New declaration.
	* thread.c (pc_in_thread_step_range): New function.
	* infrun.c (handle_inferior_event): Use it.
@
text
@d1314 1
d1327 6
d1788 5
d1954 10
d2005 1
d3249 4
d4747 5
d5268 1
@


1.579
log
@Reimplement shared library support on ppc-aix...

... using the target_so_ops framework.

gdb/ChangeLog:

        * target.h (TARGET_OBJECT_AIX_LIBRARIES): New target_object enum.
        * features/library-list-aix.dtd: New file.
        * solib-aix.h, solib-aix.c: New file.
        * rs6000-aix-tdep.c: #include "solib.h" and "solib-aix.h".
        (rs6000_find_toc_address_hook): Delete.
        (rs6000_push_dummy_call): Rewrite code setting the TOC value.
        (rs6000_aix_init_osabi): Register solib_aix_so_ops.
        * rs6000-nat.c: Remove "xcoffsolib.h" include.  Include
        "xml-utils.h".
        (map_vmap, vmap_exec, vmap_ldinfo, add_vmap, objfile_symbol_add)
        (vmap_symtab, fixup_breakpoints): Delete.
        (rs6000_xfer_shared_libraries): New function.
        (rs6000_xfer_partial): Add TARGET_OBJECT_AIX_LIBRARIES handling.
        (vmap_secs, bss_data_overlap, vmap_add_symbols): Delete.
        (xcoff_relocate_symtab, xcoff_relocate_core): Delete.
        (rs6000_ptrace_ldinfo, rs6000_core_ldinfo)
        (rs6000_xfer_shared_library): New function.
        (find_toc_address): Delete.
        (_initialize_rs6000_nat): Do not set rs6000_find_toc_address_hook.
        * rs6000-tdep.h (rs6000_find_toc_address_hook): Remove.
        * xcoffread.c (record_minimal_symbol): Reloate symbol address
        before creating minimal symbol.  Adjust function description
        accordingly.
        (scan_xcoff_symtab): Replace call to
        prim_record_minimal_symbol_and_info by call to
        record_minimal_symbol.
        (xcoff_symfile_offsets): Reimplement mostly as a wrapper
        around default_symfile_offsets.
        * configure.tgt: Add solib-aix.o to gdb_target_obs for
        powerpc-aix targets.
        * config/rs6000/nm-rs6000.h: Delete.
        * config/powerpc/aix.mh (NAT_FILE): Delete.
        (NATDEPFILES): Remove xcoffsolib.o.
        * Makefile.in (XMLFILES): Add library-list-aix.dtd.
        (ALL_TARGET_OBS): Add solib-aix.o.
        (HFILES_NO_SRCDIR): Remove xcoffsolib.h and
        config/rs6000/nm-rs6000.h.  Add solib-aix.h.
        (ALLDEPFILES): Add solib-aix.c.  Remove xcoffsolib.c.
        * xcoffsolib.h, xcoffsolib.c: Delete.

        * solib.c (reload_shared_libraries): Remove reference to
        SOLIB_CREATE_INFERIOR_HOOK.
        * breakpoint.c (handle_solib_event): Remove reference to SOLIB_ADD.
        (disable_breakpoints_in_shlibs): Remove reference to PC_SOLIB.
        (momentary_bkpt_re_set): Replace SOLIB_ADD by solib_add in
        comment.
        * corelow.c (deprecated_core_resize_section_table): Delete.
        * exec.c: Remove include of xcoffsolib.h".
        (map_vmap, vmap): Delete.
        (exec_close_1): Remove references to vmap.
        (exec_file_attach): Remove vmap handling code, and reference
        to DEPRECATED_IBM6000_TARGET.
        (bfdsec_to_vmap): Delete.
        (exec_files_info): Remove block of code handling VMAP.
        * infcmd.c (post_create_inferior): Remove reference to
        SOLIB_CREATE_INFERIOR_HOOK and SOLIB_ADD.
        * infrun.c (follow_exec): Remove reference to
        SOLIB_CREATE_INFERIOR_HOOK.
        * stack.c (print_frame): Remove reference to PC_SOLIB.
        * solib-dsbt.c (dsbt_current_sos): Adjust comment.
        (dsbt_relocate_main_executable): Likewise.
        * solib-frv.c (frv_current_sos): Likewise.

gdb/doc/ChangeLog:

        * gdbint.texinfo (Algorithms): Remove entries documenting
        DEPRECATED_IBM6000_TARGET, SOLIB_ADD, and
        SOLIB_CREATE_INFERIOR_HOOK.
@
text
@d4340 1
a4340 2
	  && (ecs->event_thread->control.step_range_start <= stop_pc
	      && stop_pc < ecs->event_thread->control.step_range_end)
d4709 1
a4709 2
  if (stop_pc >= ecs->event_thread->control.step_range_start
      && stop_pc < ecs->event_thread->control.step_range_end
@


1.578
log
@gdb/

	* infrun.c: Fix typo in comment.
@
text
@a960 3
#ifdef SOLIB_CREATE_INFERIOR_HOOK
  SOLIB_CREATE_INFERIOR_HOOK (PIDGET (inferior_ptid));
#else
a961 1
#endif
@


1.577
log
@Constify strings in tracepoint.c, lookup_cmd and the completers.

This is sort of a continuation of Keith's parse_exp_1 constification
patch.  It started out by undoing these bits:

  @@@@ -754,9 +754,12 @@@@ validate_actionline (char **line, struct
   	  tmp_p = p;
   	  for (loc = t->base.loc; loc; loc = loc->next)
   	    {
  -	      p = tmp_p;
  -	      exp = parse_exp_1 (&p, loc->address,
  +	      const char *q;
  +
  +	      q = tmp_p;
  +	      exp = parse_exp_1 (&q, loc->address,
   				 block_for_pc (loc->address), 1);
  +	      p = (char *) q;

and progressively making more things const upwards, fixing fallout,
rinse repeat, until GDB built again (--enable-targets=all).

That ended up constifying lookup_cmd/add_cmd and (lots of) friends,
and the completers.

I didn't try to constify the command hooks themselves, because I know
upfront there are commands that write to the command string argument,
and I think I managed to stop at a nice non-hacky split point already.

I think the only non-really-super-obvious changes are
tracepoint.c:validate_actionline, and tracepoint.c:trace_dump_actions.

The rest is just mostly about 'char *' => 'const char *', 'char **'=>
'const char **', and the occasional (e.g., deprecated_cmd_warning)
case of 'char **'=> 'const char *', where/when I noticed that nothing
actually cares about the pointer to pointer output.

Tested on x86_64 Fedora 17, native and gdbserver.

gdb/
2013-03-13  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (struct add_partial_datum) <text, text0, word>: Make
	fields const.
	(ada_make_symbol_completion_list): Make "text0" parameter const.
	* ax-gdb.c (agent_eval_command_one): Make "exp" parameter const.
	* breakpoint.c (condition_completer): Make "text" and "word"
	parameters const.  Adjust.
	(check_tracepoint_command): Adjust to validate_actionline
	prototype change.
	(catch_syscall_completer): Make "text" and "word" parameters
	const.
	* cli/cli-cmds.c (show_user): Make "comname" local const.
	(valid_command_p): Make "command" parameter const.
	(alias_command): Make "alias_prefix" and "command_prefix" locals
	const.
	* cli/cli-decode.c (add_cmd): Make "name" parameter const.
	(add_alias_cmd): Make "name" and "oldname" parameters const.
	Adjust.  No longer make copy of OLDNAME.
	(add_prefix_cmd, add_abbrev_prefix_cmd, add_set_or_show_cmd)
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_unlimited_cmd, add_setshow_zuinteger_cmd)
	(delete_cmd, add_info, add_info_alias, add_com, add_com_alias):
	Make "name" parameter const.
	(help_cmd): Rename "command" parameter to "arg".  New const local
	"command".
	(find_cmd): Make "command" parameter const.
	(lookup_cmd_1): Make "text" parameter pointer to const.  Adjust to
	deprecated_cmd_warning prototype change.
	(undef_cmd_error): Make "cmdtype" parameter const.
	(lookup_cmd): Make "line" parameter const.
	(deprecated_cmd_warning): Change type of "text" parameter to
	pointer to const char, from pointer to pointer to char.  Adjust.
	(lookup_cmd_composition): Make "text" parameter const.
	(complete_on_cmdlist, complete_on_enum): Make "text" and "word"
	parameters const.
	* cli/cli-decode.h (struct cmd_list_element) <name>: Make field
	const.
	* cli/cli-script.c (validate_comname): Make "tem" local const.
	(define_command): New const local "tem_c".  Use it in calls to
	lookup_cmd.
	(document_command): Make "tem" and "comfull" locals const.
	(show_user_1): Make "prefix" and "name" parameters const.
	* cli-script.h (show_user_1): Make "prefix" and "name" parameters
	const.
	* command.h (add_cmd, add_alias_cmd, add_prefix_cmd)
	(add_abbrev_prefix_cmd, completer_ftype, lookup_cmd, lookup_cmd_1)
	(deprecated_cmd_warning, lookup_cmd_composition, add_com)
	(add_com_alias, add_info, add_info_alias, complete_on_cmdlist)
	(complete_on_enum, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_cmd, add_setshow_zuinteger_unlimited_cmd):
	Change prototypes, constifying strings.
	* completer.c (noop_completer, filename_completer): Make "text"
	and "prefix" parameters const.
	(location_completer, expression_completer)
	(complete_line_internal): Make "text" and "prefix" parameters
	const and adjust.
	(command_completer, signal_completer): Make "text" and "prefix"
	parameters const.
	* completer.h (noop_completer, filename_completer)
	(expression_completer, location_completer, command_completer)
	(signal_completer): Change prototypes.
	* corefile.c (complete_set_gnutarget): Make "text" and "word"
	parameters const.
	* cp-abi.c (cp_abi_completer): Likewise.
	* expression.h (parse_expression_for_completion): Change
	prototype.
	* f-lang.c (f_make_symbol_completion_list): Make "text" and "word"
	parameters const.
	* infcmd.c (_initialize_infcmd): Make "cmd_name" local const.
	* infrun.c (handle_completer): Make "text" and "word" parameters
	const.
	* interps.c (interpreter_completer): Make "text" and "word"
	parameters const.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Make "text" and "word"
	parameters const.
	* parse.c (parse_exp_1): Move const hack to parse_exp_in_context.
	(parse_exp_in_context): Rename to ...
	(parse_exp_in_context_1): ... this.
	(parse_exp_in_context): Reimplement, with const hack from
	parse_exp_1.
	(parse_expression_for_completion): Make "string" parameter const.
	* printcmd.c (decode_format): Make "string_ptr" parameter pointer
	to pointer to const char.  Adjust.
	(print_command_1): Make "exp" parameter const.
	(output_command): Rename to ...
	(output_command_const): ... this.  Make "exp" parameter const.
	(output_command): Reimplement.
	(x_command): Adjust.
	(display_command): Rename "exp" parameter to "arg".  New "exp"
	local, const version of "arg".
	* python/py-auto-load.c (gdbpy_initialize_auto_load): Make
	"cmd_name" local const.
	* python/py-cmd.c (cmdpy_destroyer): Cast const away in xfree
	call.
	(cmdpy_completer): Make "text" and "word" parameters const.
	(gdbpy_parse_command_name): Make "prefix_text2" local const.
	* python/py-param.c (add_setshow_generic): Make "tmp_name" local
	const.
	* remote.c (_initialize_remote): Make "cmd_name" local const.
	* symtab.c (language_search_unquoted_string): Make "text" and "p"
	parameters const.  Adjust.
	(completion_list_add_fields): Make "sym_text", "text" and "word"
	parameters const.
	(struct add_name_data) <sym_text, text, word>: Make fields const.
	(default_make_symbol_completion_list_break_on): Make "text" and
	"word" parameters const.  Adjust locals.
	(default_make_symbol_completion_list)
	(make_symbol_completion_list, make_symbol_completion_type)
	(make_symbol_completion_list_fn): Make "text" and "word"
	parameters const.
	(make_file_symbol_completion_list): Make "text", "word" and
	"srcfile" parameters const.  Adjust locals.
	(add_filename_to_list): Make "text" and "word" parameters const.
	(struct add_partial_filename_data) <text, word>: Make fields
	const.
	(make_source_files_completion_list): Make "text" and "word"
	parameters const.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_type enum type_code)
	(make_symbol_completion_list_fn make_file_symbol_completion_list)
	(make_source_files_completion_list): Change prototype.
	* top.c (execute_command): Adjust to pass pointer to pointer to
	const char to lookup_cmd, and to deprecated_cmd_warning prototype
	change.
	(set_verbose): Make "cmdname" local const.
	* tracepoint.c (decode_agent_options): Make "exp" parameter const,
	and adjust.
	(validate_actionline): Make "line" parameter a pointer to const
	char, and adjust.
	(encode_actions_1): Make "action_exp" local const, and adjust.
	(encode_actions): Adjust.
	(replace_comma): Delete.
	(trace_dump_actions): Make "action_exp" and "next_comma" locals
	const, and adjust.  Don't frob the action string while splitting
	it at commas.  Instead, make a copy of each split substring in
	turn.
	(trace_dump_command): Adjust to validate_actionline prototype
	change.
	* tracepoint.h (decode_agent_options, decode_agent_options)
	(encode_actions, validate_actionline): Change prototypes.
	* valprint.h (output_command): Delete declaration.
	(output_command_const): Declare.
	* value.c (function_destroyer): Cast const away in xfree call.
@
text
@d809 1
a809 1
/* Enum strings for "set|show displaced-stepping".  */
@


1.576
log
@Rename record_ prefixes in record-full.h into record_full_.

gdb/
	* record-full.h, record-full.c (record_memory_query): Rename
	to ...
	(record_full_memory_query): ...this. Update all users.
	(record_arch_list_add_reg): Rename to ...
	(record_full_arch_list_add_reg): ...this. Update all users.
	(record_arch_list_add_mem): Rename to ...
	(record_full_arch_list_add_mem): ...this. Update all users.
	(record_arch_list_add_end): Rename to ...
	(record_full_arch_list_add_end): ...this. Update all users.
	(record_gdb_operation_disable_set): Rename to ...
	(record_full_gdb_operation_disable_set): ...this.
	Update all users.
@
text
@d6474 1
a6474 1
		  char *text, char *word)
@


1.576.2.1
log
@This fixes PR cli/15603.

The bug here is that when a software watchpoint is being used, gdb
will stop responding to C-c.  This is a regression caused by the
"catch signal" patch.

The problem is that software watchpoints always end up on the bpstat
list.  However, this makes bpstat_explains_signal return
BPSTAT_SIGNAL_HIDE, causing infrun to think that the signal is not a
"random signal".

The fix is to change bpstat_explains_signal to handle this better.  I
chose to do it in a "clean API" way, by passing the signal value to
bpstat_explains_signal and then adding an explains_signal method for
watchpoints, which handles the specifics.

Built and regtested on x86-64 Fedora 18.
New test case included.

	* break-catch-sig.c (signal_catchpoint_explains_signal): Add 'sig'
	argument.
	* breakpoint.c (bpstat_explains_signal): Add 'sig' argument.
	Special case signals other than GDB_SIGNAL_TRAP.
	(explains_signal_watchpoint): New function.
	(base_breakpoint_explains_signal): Add 'sig' argument.
	(initialize_breakpoint_ops): Set 'explains_signal' method for
	watchpoints.
	* breakpoint.h (struct breakpoint_ops) <explains_signal>: Add
	signal argument.
	(bpstat_explains_signal): Likewise.
	* infrun.c (handle_syscall_event, handle_inferior_event): Update.

	* gdb.base/random-signal.c: New file.
	* gdb.base/random-signal.exp: New file.
@
text
@d3099 1
a3099 2
      sval = bpstat_explains_signal (ecs->event_thread->control.stop_bpstat,
				     GDB_SIGNAL_TRAP);
d3345 1
a3345 2
	    = bpstat_explains_signal (ecs->event_thread->control.stop_bpstat,
				      GDB_SIGNAL_TRAP);
d3644 1
a3644 2
	= (bpstat_explains_signal (ecs->event_thread->control.stop_bpstat,
				   GDB_SIGNAL_TRAP)
d4219 1
a4219 2
      && (bpstat_explains_signal (ecs->event_thread->control.stop_bpstat,
				  GDB_SIGNAL_TRAP)
d4248 1
a4248 2
      = !((bpstat_explains_signal (ecs->event_thread->control.stop_bpstat,
				   GDB_SIGNAL_TRAP)
d4259 1
a4259 2
      sval = bpstat_explains_signal (ecs->event_thread->control.stop_bpstat,
				     ecs->event_thread->suspend.stop_signal);
@


1.575
log
@Split record.h into record.h and record-full.h.
Split record.c into record.c and record-full.c.

The split leaves the command part in record.c and moves the target part into
record-full.c.

gdb/
	* record.h: Split into this and ...
	* record-full.h: ... this.
	* record.c: Split into this and ...
	* record-full.c: ... this.
	* target.h (target_ops): Add new fields to_info_record,
	to_save_record, to_delete_record, to_record_is_replaying,
	to_goto_record_begin, to_goto_record_end, to_goto_record.
	(target_info_record): New.
	(target_save_record): New.
	(target_supports_delete_record): New.
	(target_delete_record): New.
	(target_record_is_replaying): New.
	(target_goto_record_begin): New.
	(target_goto_record_end): New.
	(target_goto_record): New.
	* target.c (target_info_record): New.
	(target_save_record): New.
	(target_supports_delete_record): New.
	(target_delete_record): New.
	(target_record_is_replaying): New.
	(target_goto_record_begin): New.
	(target_goto_record_end): New.
	(target_goto_record): New.
	* record.h: Declare struct cmd_list_element.
	(record_cmdlist): New declaration.
	(set_record_cmdlist): New declaration.
	(show_record_cmdlist): New declaration.
	(info_record_cmdlist): New declaration.
	(cmd_record_goto): New declaration.
	* record.c: Remove unnecessary includes.
	Include inferior.h.
	(cmd_record_goto): Remove declaration.
	(record_cmdlist): Now extern. Initialize.
	(set_record_cmdlist): Now extern. Initialize.
	(show_record_cmdlist): Now extern. Initialize.
	(info_record_cmdlist): Now extern. Initialize.
	(find_record_target): New.
	(require_record_target): New.
	(cmd_record_start): Update.
	(cmd_record_delete): Remove target-specific code.
	Call target_delete_record.
	(cmd_record_stop): Unpush any record target.
	(set_record_insn_max_num): Move to record-full.c
	(set_record_command): Add comment.
	(show_record_command): Add comment.
	(info_record_command): Update comment.
	Remove target-specific code.
	Call the record target's to_info_record.
	(cmd_record_start): New.
	(cmd_record_goto): Now extern.
	Remove target-specific code.
	Call target_goto_begin,  target_goto_end, or target_goto.
	(_initialize_record): Move record target ops initialization to
	record-full.c.
	Change "record" command help text.
	Move "record restore", "record set", and "record show" commands to
	record-full.c.
	* Makefile.in (SFILES): Add record-full.c.
	(HFILES_NO_SRCDIR): Add record-full.h.
	(COMMON_OBS): Add record-full.o.
	* amd64-linux-tdep.c: Include record-full.h instead of record.h.
	* arm-tdep.c: Include record-full.h.
	* i386-linux-tdep.c: Include record-full.h instead of record.h.
	* i386-tdep.c: Include record-full.h.
	* infrun.c: Include record-full.h.
	* linux-record.c: Include record-full.h.
	* moxie-tdep.c: Include record-full.h.
	* record-full.c: Include record-full.h.
	Change module comment.
	(set_record_full_cmdlist): New.
	(show_record_full_cmdlist): New.
	(record_full_cmdlist): New.
	(record_goto_insn): New declaration.
	(record_save): New declaration.
	(record_check_insn_num): Change query string.
	(record_info): New.
	(record_delete): New.
	(record_is_replaying): New.
	(record_goto_entry): New.
	(record_goto_begin): New.
	(record_goto_end): New.
	(record_goto): New.
	(init_record_ops): Update.
	(init_record_core_ops): Update.
	(cmd_record_save): Rename to record_save. Remove target and arg checks.
	(cmd_record_start): New.
	(set_record_insn_max_num): Moved from record.c
	(set_record_full_command): New.
	(show_record_full_command): New.
	(_initialize_record_full): New.
@
text
@d3014 1
a3014 1
	old_cleanups = record_gdb_operation_disable_set ();
@


1.574
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

	* infrun.c (handle_syscall_event): Remove unused gdbarch.
	(save_infcall_suspend_state): Ifdef out unused inf.
	(restore_infcall_suspend_state): Ifdef out unused inf.
	* jit.c (jit_register_code): Remove unused i, b, inf_data.
	(jit_frame_sniffer): Remove unused inf_data.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00773.html
@
text
@d52 1
@


1.573
log
@gdb/
	* infrun.c (proceed): Rename local variable 'oneproc' to
	'force_step'.
@
text
@a3075 1
  struct gdbarch *gdbarch;
a3081 1
  gdbarch = get_regcache_arch (regcache);
d6746 1
d6748 1
d6803 1
d6805 1
@


1.572
log
@2013-01-03  Pedro Alves  <palves@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	PR cli/7221:
	* NEWS: Add "catch signal".
	* breakpoint.c (base_breakpoint_ops): No longer static.
	(bpstat_explains_signal): New function.
	(init_catchpoint): No longer static.
	(base_breakpoint_explains_signal): New function.
	(base_breakpoint_ops): Initialize new field.
	* breakpoint.h (enum bpstat_signal_value): New.
	(struct breakpoint_ops) <explains_signal>: New field.
	(bpstat_explains_signal): Remove macro, declare as function.
	(base_breakpoint_ops, init_catchpoint): Declare.
	* break-catch-sig.c: New file.
	* inferior.h (signal_catch_update): Declare.
	* infrun.c (signal_catch): New global.
	(handle_syscall_event): Update for change to
	bpstat_explains_signal.
	(handle_inferior_event): Likewise.  Always handle random signals
	via bpstats.
	(signal_cache_update): Check signal_catch.
	(signal_catch_update): New function.
	(_initialize_infrun): Initialize signal_catch.
	* Makefile.in (SFILES): Add break-catch-sig.c.
	(COMMON_OBS): Add break-catch-sig.o.
gdb/doc
	* gdb.texinfo (Set Catchpoints): Document "catch signal".
	(Signals): Likewise.
gdb/testsuite
	* gdb.base/catch-signal.c: New file.
	* gdb.base/catch-signal.exp: New file.
@
text
@d2142 2
a2143 1
  int oneproc = 0;
d2183 1
a2183 1
	oneproc = 1;
d2189 1
a2189 1
	oneproc = 1;
d2220 1
a2220 1
	oneproc = 1;
d2226 1
a2226 1
  if (oneproc)
d2314 2
a2315 1
  resume (oneproc || step || bpstat_should_step (), tp->suspend.stop_signal);
@


1.571
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d321 6
d3088 2
d3097 3
a3099 2
      ecs->random_signal
	= !bpstat_explains_signal (ecs->event_thread->control.stop_bpstat);
d3331 1
d3342 4
a3345 2
	  ecs->random_signal
	    = !bpstat_explains_signal (ecs->event_thread->control.stop_bpstat);
d3643 2
a3644 1
	= !bpstat_explains_signal (ecs->event_thread->control.stop_bpstat);
d4149 12
a4160 2
      || stop_soon == STOP_QUIETLY || stop_soon == STOP_QUIETLY_NO_SIGSTOP
      || stop_soon == STOP_QUIETLY_REMOTE)
d4162 5
a4166 9
      if (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP
	  && stop_after_trap)
	{
          if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog, "infrun: stopped\n");
	  stop_print_frame = 0;
	  stop_stepping (ecs);
	  return;
	}
d4168 29
a4196 9
      /* This is originated from start_remote(), start_inferior() and
         shared libraries hook functions.  */
      if (stop_soon == STOP_QUIETLY || stop_soon == STOP_QUIETLY_REMOTE)
	{
          if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog, "infrun: quietly stopped\n");
	  stop_stepping (ecs);
	  return;
	}
d4198 5
a4202 29
      /* This originates from attach_command().  We need to overwrite
	 the stop_signal here, because some kernels don't ignore a
	 SIGSTOP in a subsequent ptrace(PTRACE_CONT,SIGSTOP) call.
	 See more comments in inferior.h.  On the other hand, if we
	 get a non-SIGSTOP, report it to the user - assume the backend
	 will handle the SIGSTOP if it should show up later.

	 Also consider that the attach is complete when we see a
	 SIGTRAP.  Some systems (e.g. Windows), and stubs supporting
	 target extended-remote report it instead of a SIGSTOP
	 (e.g. gdbserver).  We already rely on SIGTRAP being our
	 signal, so this is no exception.

	 Also consider that the attach is complete when we see a
	 GDB_SIGNAL_0.  In non-stop mode, GDB will explicitly tell
	 the target to stop all threads of the inferior, in case the
	 low level attach operation doesn't stop them implicitly.  If
	 they weren't stopped implicitly, then the stub will report a
	 GDB_SIGNAL_0, meaning: stopped for no particular reason
	 other than GDB's request.  */
      if (stop_soon == STOP_QUIETLY_NO_SIGSTOP
	  && (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_STOP
	      || ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP
	      || ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_0))
	{
	  stop_stepping (ecs);
	  ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;
	  return;
	}
d4204 3
a4206 5
      /* See if there is a breakpoint/watchpoint/catchpoint/etc. that
	 handles this event.  */
      ecs->event_thread->control.stop_bpstat
	= bpstat_stop_status (get_regcache_aspace (get_current_regcache ()),
			      stop_pc, ecs->ptid, &ecs->ws);
d4208 16
a4223 19
      /* Following in case break condition called a
	 function.  */
      stop_print_frame = 1;

      /* This is where we handle "moribund" watchpoints.  Unlike
	 software breakpoints traps, hardware watchpoint traps are
	 always distinguishable from random traps.  If no high-level
	 watchpoint is associated with the reported stop data address
	 anymore, then the bpstat does not explain the signal ---
	 simply make sure to ignore it if `stopped_by_watchpoint' is
	 set.  */

      if (debug_infrun
	  && ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP
	  && !bpstat_explains_signal (ecs->event_thread->control.stop_bpstat)
	  && stopped_by_watchpoint)
	fprintf_unfiltered (gdb_stdlog,
			    "infrun: no user watchpoint explains "
			    "watchpoint SIGTRAP, ignoring\n");
d4225 19
a4243 19
      /* NOTE: cagney/2003-03-29: These two checks for a random signal
         at one stage in the past included checks for an inferior
         function call's call dummy's return breakpoint.  The original
         comment, that went with the test, read:

         ``End of a stack dummy.  Some systems (e.g. Sony news) give
         another signal besides SIGTRAP, so check here as well as
         above.''

         If someone ever tries to get call dummys on a
         non-executable stack to work (where the target would stop
         with something like a SIGSEGV), then those tests might need
         to be re-instated.  Given, however, that the tests were only
         enabled when momentary breakpoints were not being used, I
         suspect that it won't be the case.

         NOTE: kettenis/2004-02-05: Indeed such checks don't seem to
         be necessary for call dummies on a non-executable stack on
         SPARC.  */
d4245 12
a4256 16
      if (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP)
	ecs->random_signal
	  = !(bpstat_explains_signal (ecs->event_thread->control.stop_bpstat)
	      || stopped_by_watchpoint
	      || ecs->event_thread->control.trap_expected
	      || (ecs->event_thread->control.step_range_end
		  && (ecs->event_thread->control.step_resume_breakpoint
		      == NULL)));
      else
	{
	  ecs->random_signal = !bpstat_explains_signal
				     (ecs->event_thread->control.stop_bpstat);
	  if (!ecs->random_signal)
	    ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_TRAP;
	}
    }
d4258 2
a4259 3
  /* When we reach this point, we've pretty much decided
     that the reason for stopping must've been a random
     (unexpected) signal.  */
d4261 3
a4263 2
  else
    ecs->random_signal = 1;
d6214 2
a6215 1
			&& signal_program[signo] == 1);
d6248 14
d7247 2
d7256 1
@


1.570
log
@gdb/
	* breakpoint.c (breakpoint_re_set): Remove the skip_re_set call.
	* infrun.c (handle_inferior_event): Rename the called function to
	function_name_is_marked_for_skip, pass it TMP_SAL.
	* skip.c (struct skiplist_entry): Update function_name comment.  Remove
	fields pc, gdbarch and pending.
	(skip_function_pc): Rename this forward declaration to ...
	(skip_function): ... here.
	(skip_file_command): Remove variable pending and its use, remove
	initialization of E fields pending and gdbarch.  Do not use SYMTAB
	filename, use the specified one.
	(skip_function_command): Remove variable func_pc, do not set it.
	Update the caller of skip_function.  Replace decode_line_1 call by
	a lookup_symbol call.  Remove variables orig_arg, decode_exception and
	sals.  Update the caller of skip_function.
	(skip_info): Remove variable address_width and its use.  Do not print
	address (PC).  Renumber column 5 to 4.
	(skip_function_pc): Rename to ...
	(skip_function): ... here and remove its parameters pc, arch and
	pending.  Update the function comment and no longer use those
	parameters.
	(function_pc_is_marked_for_skip): Rename to ...
	(function_name_is_marked_for_skip): ... here, update function comment
	just to a skip.h reference, replace pc parameter by function_name and
	function_sal.  No longer use E field pending and pc.  Remove variables
	searched_for_sal, sal and filename.  Call compare_filenames_for_search
	instead of just strcmp.
	(skip_re_set): Remove the function.
	* skip.h (struct symtab_and_line): New declaration.
	(function_pc_is_marked_for_skip): Rename to ...
	(function_name_is_marked_for_skip): ... here, replace pc parameter by
	function_name and function_sal, update the function comment.

gdb/testsuite/
	* gdb.base/skip-solib.exp (info skip with pending file): Update the
	expected output.
	(info skip with pending file): Remove.
	(ignoring function in solib, info skip for function multiply): Update
	the expected output.
	* gdb.base/skip.ex (skip (main), skip function baz, info skip)
	(info skip (delete 1), info skip after disabling all)
	(info skip after enabling all, info skip after disabling 4 2-3)
	(info skip after enabling 2-3, info skip 2-3)
	(info skip after deleting 2 3): Update the expected output.
	* gdb.linespec/base/two/thefile.cc (n): New variable v, split the
	statement to its initialization and return.
	* gdb.linespec/skip-two.exp: New file.
@
text
@d4 1
a4 1
   Copyright (C) 1986-2012 Free Software Foundation, Inc.
@


1.569
log
@gdb/
2012-11-30  Yao Qi  <yao@@codesourcery.com>

	* infrun.c (error_is_running, ensure_not_running): Move them
	to ...
	* infcmd.c (error_is_running, ensure_not_running): ... here.
	Make them 'static'.
	* inferior.h: Remove declarations of error_is_running and
	ensure_not_running.
@
text
@d4979 2
a4980 1
	    && !function_pc_is_marked_for_skip (ecs->stop_func_start))
@


1.568
log
@gdb/
2012-11-30  Yao Qi  <yao@@codesourcery.com>

	* infrun.c: Make the declaration of 'init_infwait_state'
	static.
	(init_infwait_state): Make it 'static'.
@
text
@a3042 14
void
error_is_running (void)
{
  error (_("Cannot execute this command while "
	   "the selected thread is running."));
}

void
ensure_not_running (void)
{
  if (is_running (inferior_ptid))
    error_is_running ();
}

@


1.567
log
@gdb/
2012-11-20  Yao Qi  <yao@@codesourcery.com>

	* infrun.c (handle_inferior_event): Pass 'saved_singlestep_ptid'
	to deprecated_context_hook.
@
text
@d400 1
a400 1
void init_infwait_state (void);
d3036 1
a3036 1
void
@


1.566
log
@gdb/
2012-11-19  Yao Qi  <yao@@codesourcery.com>

	* infrun.c (infwait_state): Add static.
@
text
@d3786 1
a3786 1
	    deprecated_context_hook (pid_to_thread_id (ecs->ptid));
@


1.565
log
@2012-11-09  Pedro Alves  <palves@@redhat.com>

	PR gdb/14306

	* infrun.c: Include target-descriptions.h.
	(follow_exec): Fetch new target description.

gdb/testsuite/
2012-11-09  Pedro Alves  <palves@@redhat.com>

	PR gdb/14306

	* gdb.multi/multi-arch-exec.c: New file.
	* gdb.multi/multi-arch-exec.exp: New file.
@
text
@d2395 1
a2395 1
enum infwait_states infwait_state;
@


1.564
log
@gdb/
2012-11-05  Pedro Alves  <palves@@redhat.com>

	* inferior.c (exit_inferior_1): Clear 'vfork_parent' in the vfork
	child.  Clear 'pending_detach'.
	* infrun.c (handle_vfork_child_exec_or_exit): Clear
	'pending_detach' in the vfork parent.

gdb/testsuite/
2012-11-05  Pedro Alves  <palves@@redhat.com>

	* gdb.base/foll-vfork.exp (vfork_relations_in_info_inferiors): New
	procedure.
	(do_vfork_and_follow_child_tests_exec)
	(do_vfork_and_follow_child_tests_exit): Call it.
@
text
@d61 1
d917 10
d946 8
@


1.563
log
@gdb/
2012-11-02  Pedro Alves  <palves@@redhat.com>

	PR gdb/14766

	* infrun.c (handle_inferior_event)
	<TARGET_WAITKIND_EXITED/TARGET_WAITKIND_SIGNALLED>: Switch to
	null_ptid before handling a vfork child exec or exit.  Switch to
	the event ptid afterwards.

gdb/testsuite/
2012-11-02  Pedro Alves  <palves@@redhat.com>

	PR gdb/14766

	* gdb.base/foll-vfork.exp (vfork_child_follow_to_exit): Remove
	setup_kfail.
	(tcatch_vfork_then_child_follow_exit): No longer expect "Couldn't
	get registers".
@
text
@d666 2
@


1.562
log
@2012-10-26  Pedro Alves  <palves@@redhat.com>

	* infrun.c (handle_inferior_event) <TARGET_WAITKIND_SIGNALLED>:
	Remove comment.
@
text
@d666 10
a675 1
	  old_chain = make_cleanup_restore_current_thread ();
@


1.561
log
@2012-10-26  Pedro Alves  <palves@@redhat.com>

	* infrun.c (handle_inferior_event) <TARGET_WAITKIND_SIGNALLED>:
	Remove comment.
@
text
@d3373 1
d3375 9
a3383 1
        fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_EXITED\n");
a3388 1
      print_exited_reason (ecs->ws.value.integer);
d3390 15
a3404 8
      /* Record the exit code in the convenience variable $_exitcode, so
         that the user can inspect this again later.  */
      set_internalvar_integer (lookup_internalvar ("_exitcode"),
			       (LONGEST) ecs->ws.value.integer);

      /* Also record this in the inferior itself.  */
      current_inferior ()->has_exit_code = 1;
      current_inferior ()->exit_code = (LONGEST) ecs->ws.value.integer;
a3413 18
    case TARGET_WAITKIND_SIGNALLED:
      if (debug_infrun)
        fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_SIGNALLED\n");
      inferior_ptid = ecs->ptid;
      set_current_inferior (find_inferior_pid (ptid_get_pid (ecs->ptid)));
      set_current_program_space (current_inferior ()->pspace);
      handle_vfork_child_exec_or_exit (0);
      stop_print_frame = 0;
      target_terminal_ours ();	/* Must do this before mourn anyway.  */

      target_mourn_inferior ();

      print_signal_exited_reason (ecs->ws.value.sig);
      singlestep_breakpoints_inserted_p = 0;
      cancel_single_step_breakpoints ();
      stop_stepping (ecs);
      return;

@


1.560
log
@2012-10-26  Pedro Alves  <palves@@redhat.com>

	* infrun.c (handle_inferior_event): Print TARGET_WAITKIND_VFORKED
	as "TARGET_WAITKIND_VFORKED", not "TARGET_WAITKIND_FORKED".
@
text
@a3408 5
      /* Note: By definition of TARGET_WAITKIND_SIGNALLED, we shouldn't
         reach here unless the inferior is dead.  However, for years
         target_kill() was called here, which hints that fatal signals aren't
         really fatal on some systems.  If that's true, then some changes
         may be needed.  */
@


1.559
log
@	* infrun.c (restore_infcall_suspend_state): Eliminate single-use
	variable LEN.
@
text
@d3427 6
a3432 1
        fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_FORKED\n");
@


1.558
log
@gdb/
	PR 14548
	* infrun.c (handle_inferior_event): Do not reverse-continue back to the
	function start if we are already at function start.  Both for
	reverse-next and for reverse-step into function without line number
	info.

gdb/testsuite/
	PR 14548
	* gdb.reverse/singlejmp-reverse-nodebug.S: New file.
	* gdb.reverse/singlejmp-reverse-nodebug.c: New file.
	* gdb.reverse/singlejmp-reverse.S: New file.
	* gdb.reverse/singlejmp-reverse.c: New file.
	* gdb.reverse/singlejmp-reverse.exp: New file.
@
text
@a6779 1
      size_t len = TYPE_LENGTH (type);
d6783 1
a6783 1
		    inf_state->siginfo_data, 0, len);
@


1.557
log
@2012-08-23  Pedro Alves  <palves@@redhat.com>

	gdb/
	* infrun.c (_initialize_infrun) <handle command help text>:
	Mention that multiple signals are supported.

	gdb/testsuite/
	* gdb.base/help.exp: Adjust to "handle" help text change.
@
text
@d4905 8
a4912 1
	      struct symtab_and_line sr_sal;
d4914 7
a4920 6
	      /* Normal function call return (static or dynamic).  */
	      init_sal (&sr_sal);
	      sr_sal.pc = ecs->stop_func_start;
	      sr_sal.pspace = get_frame_program_space (frame);
	      insert_step_resume_breakpoint_at_sal (gdbarch,
						    sr_sal, null_frame_id);
d4990 10
a4999 3
	  /* Set a breakpoint at callee's start address.
	     From there we can step once and be back in the caller.  */
	  struct symtab_and_line sr_sal;
d5001 6
a5006 5
	  init_sal (&sr_sal);
	  sr_sal.pc = ecs->stop_func_start;
	  sr_sal.pspace = get_frame_program_space (frame);
	  insert_step_resume_breakpoint_at_sal (gdbarch,
						sr_sal, null_frame_id);
@


1.556
log
@Change detach_breakpoints to take a ptid instead of a pid

Before this change, detach_breakpoints would take a pid, and then
set inferior_ptid to a ptid that it constructs using pid_to_ptid (pid).
Unfortunately, this ptid is not necessarily valid.  Consider for
instance the case of ia64-hpux, where ttrace refuses a register-read
operation if the LWP is not provided.

This problems shows up when GDB is trying to handle fork events.
Assuming GDB is configured to follow the parent, GDB will try to
detach from the child. But before doing so, it needs to remove
all breakpoints inside that child.  On ia64, this involves reading
inferior (the child's) memory. And on ia64-hpux, reading memory
requires us to read the bsp and bspstore registers, in order to
determine where that memory is relative to the value of those
registers, and thus to determine which ttrace operation to use in
order to fetch that memory (see ia64_hpux_xfer_memory).

This patch therefore changes detach_breakpoints to take a ptid instead
of a pid, and then updates all callers.

One of the consequences of this patch is that it trips an assert
on GNU/Linux targets.  But this assert appears to have not actual
purpose, and is thus removed.

gdb/ChangeLog:

        * breakpoint.h (detach_breakpoints): pid parameter is now a ptid.
        * breakpoint.c (detach_breakpoints): Change pid parameter into
        a ptid.  Adjust code accordingly.
        * infrun.c (handle_inferior_event): Delete variable child_pid.
        Update call to detach_breakpoints to pass the child ptid for
        fork events.
        * linux-nat.c (linux_nat_iterate_watchpoint_lwps): Remove
        assert that inferior_ptid's lwp is zero.
        (linux_handle_extended_wait): Update call to detach_breakpoints.
        * inf-ttrace.c (inf_ttrace_follow_fork): Update call to
        detach_breakpoints.
@
text
@d7099 1
a7099 1
Specify how to handle a signal.\n\
d7102 1
a7102 1
If no actions are specified, the current settings for the specified signal\n\
d7117 5
a7121 1
Pass and Stop may be combined."));
@


1.555
log
@gdb: improve usage strings

This adds Usage strings to a bunch of commands, tweaks the grammar in a
few, and improves the help text for the handle command.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@a3499 2
	  int child_pid = ptid_get_pid (ecs->ws.value.related_pid);

d3502 1
a3502 1
	  detach_breakpoints (child_pid);
@


1.554
log
@gdb: add completion handler for "handle" and "signal"

The command line completion has spoiled me.  Thus the lack of completion with
the "handle" command annoys me.  Patch!

This does a few things:
 - adds a VEC_merge helper
 - adds a generic signal completer
 - adds a completion handler for the "handle" command
 - sets the completion handler for the "signal" command

URL: http://sourceware.org/bugzilla/show_bug.cgi?id=10436
Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d7102 1
d7104 3
d7112 1
d7121 1
@


1.553
log
@gdb/
	* dwarf2loc.c (entry_values_debug): Add 'unsigned'.
	(_initialize_dwarf2loc): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* dwarf2loc.h: Update the declaration of 'entry_values_debug'.
	* dwarf2read.c (dwarf2_die_debug): Add 'unsigned'.
	(_initialize_dwarf2_read): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* darwin-nat.c (dwarwin_debug_flag): Add 'unsigned'.
	(_initialize_darwin_inferior): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* frame.c (frame_debug): Add 'unsigned'.
	(_intialize_frame): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* frame.h: Update the declaration of 'frame_debug'.
	* gdbtypes.c (overload_debug): Add 'unsigned'.
	(_initialize_gdbtypes): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* inferior.h: Update declaration of 'debug_infrun'.
	* infrun.c (debug_infrun): Add 'unsigned'.
	(_initialize_infrun): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* jit.c (jit_debug): Add 'unsigned'.
	(_initialize_jit): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* linux-nat.c (debug_linux_nat): Add 'unsigned'.
	(_initialize_linux_nat): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* linux-thread-db.c (libthread_db_debug): Add 'unsigned'.
	(_initialize_thread_db): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* machoread.c (mach_o_debug_level): Add 'unsigned'.
	(_initialize_machoread): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* mi/mi-cmd-var.c: Update the declaration of 'varobjdebug'.
	* microblaze-tdep.c (microblaze_debug_flag): Add 'unsigned'.
	(_initialize_microblaze_tdep): Call add_setshow_zuinteger_cmd
	intead of add_setshow_zinteger_cmd.
	* mips-tdep.c (mips_debug): Add 'unsigned'.
	(_initialize_mips_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* monitor.c (monitor_debug): Add 'unsigned'.
	(_initialize_remote_monitors): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* observer.c (observer_debug): Add 'unsigned'.
	(_initialize_observer): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* parse.c (expressiondebug): Add 'unsigned'.
	(_initialize_parse): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.c (record_debug): Add 'unsigned'.
	(_initialize_record): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.h: Update the declaration of 'record_debug'.
	* stap-probe.c (stap_expression_debug): Add 'unsigned'.
	(_initialize_stap_probe): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* serial.c (global_serial_debug_p): Add 'unsigned'.
	(_initialize_serial): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-dsbt.c (solib_dsbt_debug): Add 'unsigned'.
	(_initialize_dsbt_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-frv.c (solib_frv_debug): Add 'unsigned'.
	(_initialize_frv_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* target.c (targetdebug): Add 'unsigned'.
	(initialize_targets): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* valops.c (overload_debug): Add 'unsigned'.
	* varobj.c (varobjdebug): Add 'unsigned'.
	(_initialize_varobj): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* xtensa-tdep.c (xtensa_debug_level): Add 'unsigned'.
	(_initialize_xtensa_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.

	* arch-utils.h: Remove the declaration of 'gdbarch_debug'.
	* gdbarch.sh (gdbarch_debug): Add 'unsigned'.
	(extern void _initialize_gdbarch): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* gdbarch.c, gdbarch.h: Re-generated.
@
text
@d60 1
d6420 30
d7093 1
d7100 1
a7100 1
  add_com ("handle", class_run, handle_command, _("\
d7115 1
@


1.552
log
@2012-07-20  Pedro Alves  <palves@@redhat.com>

	PR threads/11692
	PR gdb/12203

	gdb/
	* infrun.c (handle_inferior_event) <new thread>: Don't special
	case minus_one_ptid.
	<TARGET_WAITKIND_SPURIOUS>: Ditto.
	* linux-thread-db.c (thread_get_info_callback): Don't return early
	if the thread is zombie.
	(thread_from_lwp): Change return type to void.  Rewrite stale
	comment.
	(attach_thread): Don't return early if the thread is zombie,
	instead set its "dying" flag.
	(thread_db_wait): Don't return TARGET_WAITKIND_SPURIOUS anymore.
	(find_new_threads_callback): Don't return early if the thread is
	zombie.

	gdb/testsuite/
	* gdb.threads/create-fail.c: New file.
	* gdb.threads/create-fail.exp: New file.
@
text
@d143 1
a143 1
int debug_infrun = 0;
d7113 1
a7113 1
  add_setshow_zinteger_cmd ("infrun", class_maintenance, &debug_infrun, _("\
d7117 3
a7119 3
			    NULL,
			    show_debug_infrun,
			    &setdebuglist, &showdebuglist);
@


1.551
log
@2012-07-18  Pedro Alves  <palves@@redhat.com>

	* infrun.c (handle_inferior_event) <TARGET_WAITKIND_NO_HISTORY>:
	Pull the single step breakpoints out of the target.
@
text
@d3197 1
a3197 2
      && ecs->ws.kind != TARGET_WAITKIND_SIGNALLED
      && !ptid_equal (ecs->ptid, minus_one_ptid))
d3365 1
a3365 2
      if (!ptid_equal (ecs->ptid, inferior_ptid)
	  && !ptid_equal (ecs->ptid, minus_one_ptid))
@


1.550
log
@2012-07-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* elfread.c (elf_get_probe_argument_count): Remove `objfile' argument.
	(elf_compile_to_ax): Likewise.
	* infrun.c (insert_exception_resume_from_probe): Likewise.
	(check_exception_resume): Remove `objfile' variable.
	* probe.c (find_probe_by_pc): Remove `objfile' argument.
	(struct probe_and_objfile, probe_and_objfile_s): Delete.
	(collect_probes): Adjust return value to `VEC (probe_p) *'.
	(compare_entries): Rename to...
	(compare_probes): ...this.  Adjust function to work with
	`struct probe *'.  Rename variables `ea' and `eb' to `pa' and `pb'
	respectively.
	(gen_ui_out_table_header_info): Adjust `probes' argument to be
	`VEC (probe_p) *'.
	(print_ui_out_info): Adjust argument to be `struct probe *'.
	(info_probes_for_ops): Adjust internal computations to use
	`VEC (probe_p) *'.
	(probe_safe_evaluate_at_pc): Refactor to not pass `objfile' anymore.
	* probe.h (struct probe_ops) <get_probe_argument_count, compile_to_ax,
	gen_info_probes_table_values>: Remove `objfile' argument.
	(struct probe) <objfile>: New field.
	(find_probe_by_pc): Remove `objfile' argument.
	* stap-probe.c (stap_parse_probe_arguments): Likewise.
	(stap_get_probe_argument_count): Likewise.
	(stap_get_arg): Likewise.
	(stap_evaluate_probe_argument): Likewise.
	(stap_compile_to_ax): Likewise.
	(compile_probe_arg): Refactor not to pass `objfile' anymore.
	(handle_stap_probe): Fill `objfile' field from `struct probe'.
	(stap_gen_info_probes_table_header): Remove `objfile' argument.
	* symfile.h (struct sym_probe_fns) <sym_evaluate_probe_argument,
	sym_compile_to_ax>: Likewise.
@
text
@d3672 9
@


1.549
log
@gdb:
	* breakpoint.c: Removed always_inserted_auto, always_inserted_on,
	always_inserted_off, and always_inserted_enums.
	Change always_inserted_mode's type to 'enum auto_boolean'.
	(show_always_inserted_mode, breakpoint_always_inserted_mode): Update
	callers.
	(_initialize_breakpoint): Call add_setshow_auto_boolean_cmd instead
	of add_setshow_enum_cmd.
	* infrun.c: Remove can_use_displaced_stepping_auto,
	can_use_displaced_stepping_on, can_use_displaced_stepping_off, and
	can_use_displaced_stepping_enum.
	Change can_use_displaced_stepping's type to 'enum auto_boolean'.
	(show_can_use_displaced_stepping, use_displaced_stepping): Update callers.
	(_initialize_infrun): Call add_setshow_auto_boolean_cmd instead of
	add_setshow_enum_cmd.
@
text
@a5520 1
				    struct objfile *objfile,
d5536 1
a5536 1
			paddress (get_objfile_arch (objfile),
a5553 1
  struct objfile *objfile;
d5561 1
a5561 1
  probe = find_probe_by_pc (get_frame_pc (frame), &objfile);
d5564 1
a5564 2
      insert_exception_resume_from_probe (ecs->event_thread, probe,
					  objfile, frame);
@


1.549.2.1
log
@gdb/
	PR 14548
	* infrun.c (handle_inferior_event): Do not reverse-continue back to the
	function start if we are already at function start.  Both for
	reverse-next and for reverse-step into function without line number
	info.

gdb/testsuite/
	PR 14548
	* gdb.reverse/singlejmp-reverse-nodebug.S: New file.
	* gdb.reverse/singlejmp-reverse-nodebug.c: New file.
	* gdb.reverse/singlejmp-reverse.S: New file.
	* gdb.reverse/singlejmp-reverse.c: New file.
	* gdb.reverse/singlejmp-reverse.exp: New file.
@
text
@d4899 1
a4899 8
	      /* If we're already at the start of the function, we've either
		 just stepped backward into a single instruction function,
		 or stepped back out of a signal handler to the first instruction
		 of the function.  Just keep going, which will single-step back
		 to the caller.  */
	      if (ecs->stop_func_start != stop_pc)
		{
		  struct symtab_and_line sr_sal;
d4901 6
a4906 7
		  /* Normal function call return (static or dynamic).  */
		  init_sal (&sr_sal);
		  sr_sal.pc = ecs->stop_func_start;
		  sr_sal.pspace = get_frame_program_space (frame);
		  insert_step_resume_breakpoint_at_sal (gdbarch,
							sr_sal, null_frame_id);
		}
d4976 3
a4978 10
	  /* If we're already at the start of the function, we've either just
	     stepped backward into a single instruction function without line
	     number info, or stepped back out of a signal handler to the first
	     instruction of the function without line number info.  Just keep
	     going, which will single-step back to the caller.  */
	  if (ecs->stop_func_start != stop_pc)
	    {
	      /* Set a breakpoint at callee's start address.
		 From there we can step once and be back in the caller.  */
	      struct symtab_and_line sr_sal;
d4980 5
a4984 6
	      init_sal (&sr_sal);
	      sr_sal.pc = ecs->stop_func_start;
	      sr_sal.pspace = get_frame_program_space (frame);
	      insert_step_resume_breakpoint_at_sal (gdbarch,
						    sr_sal, null_frame_id);
	    }
@


1.548
log
@gdb/
2012-06-28  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdbthread.h (ALL_THREADS): New macro.
	(thread_list): Declare.
	* infrun.c (handle_inferior_event) <spurious signal>: Don't keep
	going, but instead fall through to the stepping handling.
	* linux-nat.c (resume_lwp): New parameter 'signo'.  Resume with
	the passed in signal.  Adjust debug output.
	(resume_callback): Rename to ...
	(linux_nat_resume_callback): ... this.  Pass the thread's last
	stop signal, if in "pass" state.
	(linux_nat_resume): Adjust to rename.
	(stop_wait_callback): New assertion.  Don't respawn signals;
	instead let the LWP remain with SIGNALLED set.
	(linux_nat_wait_1): Remove flushing of pending SIGSTOPs.
	* remote.c (append_pending_thread_resumptions): New.
	(remote_vcont_resume): Call it.
	* target.h (target_resume): Extend comment.

gdb/testsuite/
2012-06-28  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdb.threads/siginfo-threads.exp: New file.
	* gdb.threads/siginfo-threads.c: New file.
	* gdb.threads/sigstep-threads.exp: New file.
	* gdb.threads/sigstep-threads.c: New file.
@
text
@a1187 13
/* Enum strings for "set|show displaced-stepping".  */

static const char can_use_displaced_stepping_auto[] = "auto";
static const char can_use_displaced_stepping_on[] = "on";
static const char can_use_displaced_stepping_off[] = "off";
static const char *const can_use_displaced_stepping_enum[] =
{
  can_use_displaced_stepping_auto,
  can_use_displaced_stepping_on,
  can_use_displaced_stepping_off,
  NULL,
};

d1196 1
a1196 2
static const char *can_use_displaced_stepping =
  can_use_displaced_stepping_auto;
d1203 1
a1203 1
  if (can_use_displaced_stepping == can_use_displaced_stepping_auto)
d1220 2
a1221 3
  return (((can_use_displaced_stepping == can_use_displaced_stepping_auto
	    && non_stop)
	   || can_use_displaced_stepping == can_use_displaced_stepping_on)
d7284 2
a7285 3
  add_setshow_enum_cmd ("displaced-stepping", class_run,
			can_use_displaced_stepping_enum,
			&can_use_displaced_stepping, _("\
d7294 3
a7296 3
			NULL,
			show_can_use_displaced_stepping,
			&setlist, &showlist);
@


1.547
log
@gdb/
	Remove stale dummy frames.
	* breakpoint.c: Include dummy-frame.h.
	(longjmp_breakpoint_ops): New variable.
	(update_breakpoints_after_exec, breakpoint_init_inferior): Delete also
	bp_longjmp_call_dummy.
	(bpstat_what, bptype_string, print_one_breakpoint_location)
	(init_bp_location): Support bp_longjmp_call_dummy.
	(set_longjmp_breakpoint): Use longjmp_breakpoint_ops.  Comment why.
	(set_longjmp_breakpoint_for_call_dummy)
	(check_longjmp_breakpoint_for_call_dummy, longjmp_bkpt_dtor): New
	functions.
	(initialize_breakpoint_ops): Initialize longjmp_breakpoint_ops.
	* breakpoint.h (enum bptype): New item bp_longjmp_call_dummy.  Delete
	FIXME comment and extend the other comment for bp_call_dummy.
	(set_longjmp_breakpoint_for_call_dummy)
	(check_longjmp_breakpoint_for_call_dummy): New declarations.
	* dummy-frame.c: Include gdbthread.h.
	(pop_dummy_frame_bpt): New function.
	(pop_dummy_frame): Call pop_dummy_frame_bpt.
	(dummy_frame_discard): New function.
	(cleanup_dummy_frames): Update the comment about longjmps.
	* dummy-frame.h (dummy_frame_discard): New declaration.
	* gdbthread.h (struct thread_info): Extend initiating_frame comment.
	* infcall.c (call_function_by_hand): New variable longjmp_b.  Call
	set_longjmp_breakpoint_for_call_dummy.  Chain its breakpoints with BPT.
	* infrun.c (handle_inferior_event) <BPSTAT_WHAT_CLEAR_LONGJMP_RESUME>:
	Add case 4 comment.  Call check_longjmp_breakpoint_for_call_dummy and
	keep_going if IS_LONGJMP and there is no other reason to stop.

gdb/testsuite/
	Remove stale dummy frames.
	* gdb.base/call-signal-resume.exp (maintenance print dummy-frames)
	(maintenance info breakpoints): New tests.
	* gdb.base/stale-infcall.c: New file.
	* gdb.base/stale-infcall.exp: New file.
@
text
@a4365 2
      keep_going (ecs);
      return;
d4367 3
d4371 15
a4385 4
  /* Handle cases caused by hitting a breakpoint.  */
  {
    CORE_ADDR jmp_buf_pc;
    struct bpstat_what what;
d4387 6
a4392 1
    what = bpstat_what (ecs->event_thread->control.stop_bpstat);
d4394 5
a4398 4
    if (what.call_dummy)
      {
	stop_stack_dummy = what.call_dummy;
      }
d4400 3
a4402 5
    /* If we hit an internal event that triggers symbol changes, the
       current frame will be invalidated within bpstat_what (e.g., if
       we hit an internal solib event).  Re-fetch it.  */
    frame = get_current_frame ();
    gdbarch = get_frame_arch (frame);
d4404 18
a4421 10
    switch (what.main_action)
      {
      case BPSTAT_WHAT_SET_LONGJMP_RESUME:
	/* If we hit the breakpoint at longjmp while stepping, we
	   install a momentary breakpoint at the target of the
	   jmp_buf.  */

	if (debug_infrun)
	  fprintf_unfiltered (gdb_stdlog,
			      "infrun: BPSTAT_WHAT_SET_LONGJMP_RESUME\n");
d4423 7
a4429 1
	ecs->event_thread->stepping_over_breakpoint = 1;
d4431 1
a4431 1
	if (what.is_longjmp)
d4433 7
a4439 1
	    struct value *arg_value;
d4441 3
a4443 17
	    /* If we set the longjmp breakpoint via a SystemTap probe,
	       then use it to extract the arguments.  The destination
	       PC is the third argument to the probe.  */
	    arg_value = probe_safe_evaluate_at_pc (frame, 2);
	    if (arg_value)
	      jmp_buf_pc = value_as_address (arg_value);
	    else if (!gdbarch_get_longjmp_target_p (gdbarch)
		     || !gdbarch_get_longjmp_target (gdbarch,
						     frame, &jmp_buf_pc))
	      {
		if (debug_infrun)
		  fprintf_unfiltered (gdb_stdlog,
				      "infrun: BPSTAT_WHAT_SET_LONGJMP_RESUME "
				      "(!gdbarch_get_longjmp_target)\n");
		keep_going (ecs);
		return;
	      }
d4445 4
a4448 7
	    /* Insert a breakpoint at resume address.  */
	    insert_longjmp_resume_breakpoint (gdbarch, jmp_buf_pc);
	  }
	else
	  check_exception_resume (ecs, frame);
	keep_going (ecs);
	return;
d4450 3
a4452 3
      case BPSTAT_WHAT_CLEAR_LONGJMP_RESUME:
	{
	  struct frame_info *init_frame;
d4454 3
a4456 1
	  /* There are several cases to consider.
d4458 3
a4460 3
	     1. The initiating frame no longer exists.  In this case
	     we must stop, because the exception or longjmp has gone
	     too far.
d4462 3
a4464 3
	     2. The initiating frame exists, and is the same as the
	     current frame.  We stop, because the exception or longjmp
	     has been caught.
d4466 7
a4472 4
	     3. The initiating frame exists and is different from the
	     current frame.  This means the exception or longjmp has
	     been caught beneath the initiating frame, so keep
	     going.
d4474 1
a4474 3
	     4. longjmp breakpoint has been placed just to protect
	     against stale dummy frames and user is not interested in
	     stopping around longjmps.  */
d4476 28
d4505 5
a4509 2
	    fprintf_unfiltered (gdb_stdlog,
				"infrun: BPSTAT_WHAT_CLEAR_LONGJMP_RESUME\n");
d4511 3
a4513 3
	  gdb_assert (ecs->event_thread->control.exception_resume_breakpoint
		      != NULL);
	  delete_exception_resume_breakpoint (ecs->event_thread);
d4515 3
a4517 1
	  if (what.is_longjmp)
d4519 1
a4519 1
	      check_longjmp_breakpoint_for_call_dummy (ecs->event_thread->num);
d4521 8
a4528 6
	      if (!frame_id_p (ecs->event_thread->initiating_frame))
		{
		  /* Case 4.  */
		  keep_going (ecs);
		  return;
		}
d4530 3
a4532 4

	  init_frame = frame_find_by_id (ecs->event_thread->initiating_frame);

	  if (init_frame)
d4534 7
a4540 13
	      struct frame_id current_id
		= get_frame_id (get_current_frame ());
	      if (frame_id_eq (current_id,
			       ecs->event_thread->initiating_frame))
		{
		  /* Case 2.  Fall through.  */
		}
	      else
		{
		  /* Case 3.  */
		  keep_going (ecs);
		  return;
		}
d4542 1
d4544 7
a4550 3
	  /* For Cases 1 and 2, remove the step-resume breakpoint,
	     if it exists.  */
	  delete_step_resume_breakpoint (ecs->event_thread);
a4551 2
	  ecs->event_thread->control.stop_step = 1;
	  print_end_stepping_range_reason ();
d4553 1
a4553 2
	}
	return;
d4555 4
a4558 7
      case BPSTAT_WHAT_SINGLE:
        if (debug_infrun)
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_SINGLE\n");
	ecs->event_thread->stepping_over_breakpoint = 1;
	/* Still need to check other stuff, at least the case
	   where we are stepping and step out of the right range.  */
	break;
d4560 2
a4561 9
      case BPSTAT_WHAT_STEP_RESUME:
        if (debug_infrun)
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_STEP_RESUME\n");

	delete_step_resume_breakpoint (ecs->event_thread);
	if (ecs->event_thread->control.proceed_to_finish
	    && execution_direction == EXEC_REVERSE)
	  {
	    struct thread_info *tp = ecs->event_thread;
d4563 2
a4564 22
	    /* We are finishing a function in reverse, and just hit
	       the step-resume breakpoint at the start address of the
	       function, and we're almost there -- just need to back
	       up by one more single-step, which should take us back
	       to the function call.  */
	    tp->control.step_range_start = tp->control.step_range_end = 1;
	    keep_going (ecs);
	    return;
	  }
	fill_in_stop_func (gdbarch, ecs);
	if (stop_pc == ecs->stop_func_start
	    && execution_direction == EXEC_REVERSE)
	  {
	    /* We are stepping over a function call in reverse, and
	       just hit the step-resume breakpoint at the start
	       address of the function.  Go back to single-stepping,
	       which should take us back to the function call.  */
	    ecs->event_thread->stepping_over_breakpoint = 1;
	    keep_going (ecs);
	    return;
	  }
	break;
d4566 3
a4568 25
      case BPSTAT_WHAT_STOP_NOISY:
        if (debug_infrun)
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_STOP_NOISY\n");
	stop_print_frame = 1;

	/* We are about to nuke the step_resume_breakpointt via the
	   cleanup chain, so no need to worry about it here.  */

	stop_stepping (ecs);
	return;

      case BPSTAT_WHAT_STOP_SILENT:
        if (debug_infrun)
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_STOP_SILENT\n");
	stop_print_frame = 0;

	/* We are about to nuke the step_resume_breakpoin via the
	   cleanup chain, so no need to worry about it here.  */

	stop_stepping (ecs);
	return;

      case BPSTAT_WHAT_HP_STEP_RESUME:
        if (debug_infrun)
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_HP_STEP_RESUME\n");
d4570 12
a4581 12
	delete_step_resume_breakpoint (ecs->event_thread);
	if (ecs->event_thread->step_after_step_resume_breakpoint)
	  {
	    /* Back when the step-resume breakpoint was inserted, we
	       were trying to single-step off a breakpoint.  Go back
	       to doing that.  */
	    ecs->event_thread->step_after_step_resume_breakpoint = 0;
	    ecs->event_thread->stepping_over_breakpoint = 1;
	    keep_going (ecs);
	    return;
	  }
	break;
d4583 4
a4586 4
      case BPSTAT_WHAT_KEEP_CHECKING:
	break;
      }
  }
@


1.546
log
@	* infrun.c (handle_inferior_event): Correct indentation.
@
text
@d4448 5
a4452 1
	     going.  */
a4457 2
	  init_frame = frame_find_by_id (ecs->event_thread->initiating_frame);

d4462 14
@


1.545
log
@	PR backtrace/13866
	* infrun.c (handle_inferior_event): Re-fetch frame and gdbarch
	after hiding inline functions.
@
text
@d4072 4
a4075 4
          && !(ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP
               && ecs->event_thread->control.trap_expected
               && pc_at_non_inline_function (aspace,
                                             ecs->event_thread->prev_pc,
@


1.544
log
@gdb/
	PR build/14003
	* inferior.h (struct inferior_suspend_state): Comment out.
	(struct inferior): Comment out the field suspend.
	* infrun.c (struct infcall_suspend_state): Comment out the field
	inferior_suspend.
	(save_infcall_suspend_state, restore_infcall_suspend_state): Comment
	out its assignment.
@
text
@d4077 8
a4084 1
	skip_inline_frames (ecs->ptid);
@


1.543
log
@2012-06-12  Pedro Alves  <palves@@redhat.com>

	* infrun.c (infrun_thread_stop_requested_callback): Don't switch
	threads here.
	(prepare_for_detach): No longer context switch here in non-stop
	mode.
	(fetch_inferior_event): Ditto.
	(handle_inferior_event) <STOP_QUIETLY || NO_STOP_QUIETLY>: Switch
	to the event thread before removing breakpoints.  Switch to the
	event thread before inserting breakpoints and resuming.
	(handle_inferior_event) <TARGET_WAITKIND_SPURIOUS>: Switch to the
	event thread before resuming.
	(handle_inferior_event) <stepping_past_singlestep_breakpoint>:
	Switch to the event thread before removing breakpoints.
@
text
@d6632 1
d6634 1
d6688 1
d6690 1
d6714 1
d6716 1
@


1.542
log
@	* infrun.c (handle_inferior_event)
	<BPSTAT_WHAT_SET_LONGJMP_RESUME>: Don't delete the step-resume
	breakpoint.
	<BPSTAT_WHAT_CLEAR_LONGJMP_RESUME>: Remove longjmp logic; use
	exception logic in all cases.  Update comments.
	(insert_longjmp_resume_breakpoint): Set the exception resume
	breakpoint.
testsuite
	* gdb.base/longjmp.c (hidden_longjmp): Move expected catch
	location...
	(main): ...here.
@
text
@a2439 2
      switch_to_thread (info->ptid);

a2655 8
      /* In non-stop mode, each thread is handled individually.
	 Switch early, so the global state is set correctly for this
	 thread.  */
      if (non_stop
	  && ecs->ws.kind != TARGET_WAITKIND_EXITED
	  && ecs->ws.kind != TARGET_WAITKIND_SIGNALLED)
	context_switch (ecs->ptid);

a2781 10
  if (non_stop
      && ecs->ws.kind != TARGET_WAITKIND_IGNORE
      && ecs->ws.kind != TARGET_WAITKIND_NO_RESUMED
      && ecs->ws.kind != TARGET_WAITKIND_EXITED
      && ecs->ws.kind != TARGET_WAITKIND_SIGNALLED)
    /* In non-stop mode, each thread is handled individually.  Switch
       early, so the global state is set correctly for this
       thread.  */
    context_switch (ecs->ptid);

d3363 3
d3381 3
d3758 2
d3792 2
@


1.541
log
@2012-06-06  Pedro Alves  <palves@@redhat.com>

	* infrun.c (handle_inferior_event): Remove calls to
	reinit_frame_cache that follow a context_switch call.
@
text
@a4425 4
	    /* We're going to replace the current step-resume breakpoint
	       with a longjmp-resume breakpoint.  */
	    delete_step_resume_breakpoint (ecs->event_thread);

d4435 21
a4455 3
        if (debug_infrun)
	  fprintf_unfiltered (gdb_stdlog,
			      "infrun: BPSTAT_WHAT_CLEAR_LONGJMP_RESUME\n");
d4457 1
a4457 9
	if (what.is_longjmp)
	  {
	    gdb_assert (ecs->event_thread->control.step_resume_breakpoint
			!= NULL);
	    delete_step_resume_breakpoint (ecs->event_thread);
	  }
	else
	  {
	    /* There are several cases to consider.
d4459 3
a4461 2
	       1. The initiating frame no longer exists.  In this case
	       we must stop, because the exception has gone too far.
d4463 20
a4482 35
	       2. The initiating frame exists, and is the same as the
	       current frame.  We stop, because the exception has been
	       caught.

	       3. The initiating frame exists and is different from
	       the current frame.  This means the exception has been
	       caught beneath the initiating frame, so keep going.  */
	    struct frame_info *init_frame
	      = frame_find_by_id (ecs->event_thread->initiating_frame);

	    gdb_assert (ecs->event_thread->control.exception_resume_breakpoint
			!= NULL);
	    delete_exception_resume_breakpoint (ecs->event_thread);

	    if (init_frame)
	      {
		struct frame_id current_id
		  = get_frame_id (get_current_frame ());
		if (frame_id_eq (current_id,
				 ecs->event_thread->initiating_frame))
		  {
		    /* Case 2.  Fall through.  */
		  }
		else
		  {
		    /* Case 3.  */
		    keep_going (ecs);
		    return;
		  }
	      }

	    /* For Cases 1 and 2, remove the step-resume breakpoint,
	       if it exists.  */
	    delete_step_resume_breakpoint (ecs->event_thread);
	  }
d4484 4
a4487 3
	ecs->event_thread->control.stop_step = 1;
	print_end_stepping_range_reason ();
	stop_stepping (ecs);
d5457 2
a5458 2
  /* There should never be more than one step-resume or longjmp-resume
     breakpoint per thread, so we should never be setting a new
d5460 1
a5460 1
  gdb_assert (inferior_thread ()->control.step_resume_breakpoint == NULL);
d5467 1
a5467 1
  inferior_thread ()->control.step_resume_breakpoint =
@


1.540
log
@2012-06-06  Pedro Alves  <palves@@redhat.com>

	* infrun.c (handle_inferior_event) <deferred_step_ptid>: Use
	context_switch and remove stale comment.
@
text
@d3514 1
a3514 4
	{
	  context_switch (ecs->ptid);
	  reinit_frame_cache ();
	}
d3631 1
a3631 4
	{
	  context_switch (ecs->ptid);
	  reinit_frame_cache ();
	}
@


1.539
log
@gdb/
2012-06-06  Pedro Alves  <palves@@redhat.com>

	* infrun.c (struct execution_control_state): Remove
	`new_thread_event' field.
	(handle_inferior_event): Simplify new threads handling; don't
	resume the inferior if we find a new thread.

gdb/testsuite/
2012-06-06  Pedro Alves  <palves@@redhat.com>

	* gdb.threads/clone-new-thread-event.c: New file.
	* gdb.threads/clone-new-thread-event.exp: New file.
@
text
@d3816 1
a3816 3
	  /* Note: We do not call context_switch at this point, as the
	     context is already set up for stepping the original thread.  */
	  switch_to_thread (deferred_step_ptid);
@


1.538
log
@2012-05-28  Pedro Alves  <palves@@redhat.com>

	* infrun.c (wait_for_inferior): Move ecss and ecs locals to the
	block that uses them.  Clear ecss before handling each event.
@
text
@a2395 1
  int new_thread_event;
a3230 6
  /* If it's a new process, add it to the thread database.  */

  ecs->new_thread_event = (!ptid_equal (ecs->ptid, inferior_ptid)
			   && !ptid_equal (ecs->ptid, minus_one_ptid)
			   && !in_thread_list (ecs->ptid));

d3232 8
a3239 4
      && ecs->ws.kind != TARGET_WAITKIND_SIGNALLED && ecs->new_thread_event)
    add_thread (ecs->ptid);

  ecs->event_thread = find_thread_ptid (ecs->ptid);
a3712 24
  if (ecs->new_thread_event)
    {
      if (non_stop)
	/* Non-stop assumes that the target handles adding new threads
	   to the thread list.  */
	internal_error (__FILE__, __LINE__,
			"targets should add new threads to the thread "
			"list themselves in non-stop mode.");

      /* We may want to consider not doing a resume here in order to
	 give the user a chance to play with the new thread.  It might
	 be good to make that a user-settable option.  */

      /* At this point, all threads are stopped (happens automatically
	 in either the OS or the native code).  Therefore we need to
	 continue all threads in order to make progress.  */

      if (!ptid_equal (ecs->ptid, inferior_ptid))
	context_switch (ecs->ptid);
      target_resume (RESUME_ALL, 0, GDB_SIGNAL_0);
      prepare_to_wait (ecs);
      return;
    }

@


1.537
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@a2696 2
  struct execution_control_state ecss;
  struct execution_control_state *ecs;
a2704 3
  ecs = &ecss;
  memset (ecs, 0, sizeof (*ecs));

d2707 2
d2711 2
@


1.536
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d346 1
a346 1
  target_program_signals ((int) TARGET_SIGNAL_LAST, signal_program);
d625 1
a625 1
      && thread->suspend.stop_signal == TARGET_SIGNAL_0)
d634 1
a634 1
      proceed ((CORE_ADDR) -1, TARGET_SIGNAL_DEFAULT, 0);
d1456 1
a1456 1
  if (signal == TARGET_SIGNAL_TRAP)
d1527 1
a1527 1
	    target_resume (ptid, 1, TARGET_SIGNAL_0);
d1529 1
a1529 1
	    target_resume (ptid, 0, TARGET_SIGNAL_0);
d1551 2
a1552 2
	  target_resume (ptid, step, TARGET_SIGNAL_0);
	  tp->suspend.stop_signal = TARGET_SIGNAL_0;
d1776 1
a1776 1
      && sig == TARGET_SIGNAL_0
d1832 1
a1832 1
      && tp->control.trap_expected && sig != TARGET_SIGNAL_0)
d1928 1
a1928 1
      tp->suspend.stop_signal = TARGET_SIGNAL_0;
d1940 1
a1940 1
	target_pass_signals ((int) TARGET_SIGNAL_LAST, signal_pass);
d2046 4
a2049 4
      || (wait_status.value.sig != TARGET_SIGNAL_TRAP
	  && wait_status.value.sig != TARGET_SIGNAL_ILL
	  && wait_status.value.sig != TARGET_SIGNAL_SEGV
	  && wait_status.value.sig != TARGET_SIGNAL_EMT))
d2241 1
a2241 1
	      last_thread->suspend.stop_signal = TARGET_SIGNAL_0;
d2246 1
a2246 1
  if (siggnal != TARGET_SIGNAL_DEFAULT)
d2251 1
a2251 1
    tp->suspend.stop_signal = TARGET_SIGNAL_0;
d2449 1
a2449 1
      ecs->ws.value.sig = TARGET_SIGNAL_0;
d2951 1
a2951 1
  if (ecs->ws.value.sig != TARGET_SIGNAL_TRAP)
d3115 1
a3115 1
	  ecs->event_thread->suspend.stop_signal = TARGET_SIGNAL_TRAP;
d3121 1
a3121 1
  ecs->event_thread->suspend.stop_signal = TARGET_SIGNAL_0;
d3264 3
a3266 3
      && (ecs->ws.value.sig == TARGET_SIGNAL_ILL
	  || ecs->ws.value.sig == TARGET_SIGNAL_SEGV
	  || ecs->ws.value.sig == TARGET_SIGNAL_EMT))
d3276 1
a3276 1
	  ecs->ws.value.sig = TARGET_SIGNAL_TRAP;
d3361 1
a3361 1
	      ecs->event_thread->suspend.stop_signal = TARGET_SIGNAL_TRAP;
d3369 1
a3369 1
	  ecs->event_thread->suspend.stop_signal = TARGET_SIGNAL_0;
d3392 1
a3392 1
	  resume (0, TARGET_SIGNAL_0);
d3402 1
a3402 1
      resume (0, TARGET_SIGNAL_0);
d3484 1
a3484 1
	    displaced_step_fixup (ecs->ptid, TARGET_SIGNAL_TRAP);
d3578 1
a3578 1
	  ecs->event_thread->suspend.stop_signal = TARGET_SIGNAL_0;
d3612 1
a3612 1
      ecs->event_thread->suspend.stop_signal = TARGET_SIGNAL_TRAP;
d3670 1
a3670 1
	  ecs->event_thread->suspend.stop_signal = TARGET_SIGNAL_0;
d3674 1
a3674 1
      ecs->event_thread->suspend.stop_signal = TARGET_SIGNAL_TRAP;
d3736 1
a3736 1
      target_resume (RESUME_ALL, 0, TARGET_SIGNAL_0);
d3754 2
a3755 2
	  && ecs->event_thread->suspend.stop_signal == TARGET_SIGNAL_TRAP)
	ecs->event_thread->suspend.stop_signal = TARGET_SIGNAL_0;
d3799 1
a3799 1
      if (ecs->event_thread->suspend.stop_signal == TARGET_SIGNAL_TRAP)
d3816 1
a3816 1
	  resume (1, TARGET_SIGNAL_0);
d3829 1
a3829 1
      if (ecs->event_thread->suspend.stop_signal == TARGET_SIGNAL_TRAP)
d3851 1
a3851 1
	  resume (1, TARGET_SIGNAL_0);
d3863 1
a3863 1
  if (ecs->event_thread->suspend.stop_signal == TARGET_SIGNAL_TRAP)
d3930 1
a3930 1
                 ecs->event_thread->suspend.stop_signal = TARGET_SIGNAL_0;
d4076 1
a4076 1
      target_resume (ecs->ptid, hw_step, TARGET_SIGNAL_0);
d4118 1
a4118 1
          && !(ecs->event_thread->suspend.stop_signal == TARGET_SIGNAL_TRAP
d4126 1
a4126 1
  if (ecs->event_thread->suspend.stop_signal == TARGET_SIGNAL_TRAP
d4170 1
a4170 1
  if (ecs->event_thread->suspend.stop_signal == TARGET_SIGNAL_TRAP
d4174 1
a4174 1
      if (ecs->event_thread->suspend.stop_signal == TARGET_SIGNAL_TRAP
d4208 1
a4208 1
	 TARGET_SIGNAL_0.  In non-stop mode, GDB will explicitly tell
d4212 1
a4212 1
	 TARGET_SIGNAL_0, meaning: stopped for no particular reason
d4215 3
a4217 3
	  && (ecs->event_thread->suspend.stop_signal == TARGET_SIGNAL_STOP
	      || ecs->event_thread->suspend.stop_signal == TARGET_SIGNAL_TRAP
	      || ecs->event_thread->suspend.stop_signal == TARGET_SIGNAL_0))
d4220 1
a4220 1
	  ecs->event_thread->suspend.stop_signal = TARGET_SIGNAL_0;
d4243 1
a4243 1
	  && ecs->event_thread->suspend.stop_signal == TARGET_SIGNAL_TRAP
d4270 1
a4270 1
      if (ecs->event_thread->suspend.stop_signal == TARGET_SIGNAL_TRAP)
d4283 1
a4283 1
	    ecs->event_thread->suspend.stop_signal = TARGET_SIGNAL_TRAP;
d4341 1
a4341 1
	ecs->event_thread->suspend.stop_signal = TARGET_SIGNAL_0;
d4371 1
a4371 1
	  && ecs->event_thread->suspend.stop_signal != TARGET_SIGNAL_0
d4638 1
a4638 1
	       && ecs->event_thread->suspend.stop_signal != TARGET_SIGNAL_TRAP)
d5688 1
a5688 1
      && ecs->event_thread->suspend.stop_signal != TARGET_SIGNAL_TRAP)
d5756 1
a5756 1
      if (ecs->event_thread->suspend.stop_signal == TARGET_SIGNAL_TRAP
d5758 1
a5758 1
	ecs->event_thread->suspend.stop_signal = TARGET_SIGNAL_0;
d5879 1
a5879 1
  if (siggnal == TARGET_SIGNAL_0 && !ui_out_is_mi_like_p (uiout))
d6212 1
a6212 1
      for (signo = 0; signo < (int) TARGET_SIGNAL_LAST; signo++)
d6298 1
a6298 1
  nsigs = (int) TARGET_SIGNAL_LAST;
d6389 1
a6389 1
	  if (oursig != TARGET_SIGNAL_UNKNOWN)
d6407 2
a6408 2
	    case TARGET_SIGNAL_TRAP:
	    case TARGET_SIGNAL_INT:
d6424 3
a6426 3
	    case TARGET_SIGNAL_0:
	    case TARGET_SIGNAL_DEFAULT:
	    case TARGET_SIGNAL_UNKNOWN:
d6442 2
a6443 2
	target_pass_signals ((int) TARGET_SIGNAL_LAST, signal_pass);
	target_program_signals ((int) TARGET_SIGNAL_LAST, signal_program);
d6551 1
a6551 1
      if (oursig == TARGET_SIGNAL_UNKNOWN)
d6563 2
a6564 2
  for (oursig = TARGET_SIGNAL_FIRST;
       (int) oursig < (int) TARGET_SIGNAL_LAST;
d6569 2
a6570 2
      if (oursig != TARGET_SIGNAL_UNKNOWN
	  && oursig != TARGET_SIGNAL_DEFAULT && oursig != TARGET_SIGNAL_0)
d6742 2
a6743 2
     TARGET_SIGNAL_0 anyway.  */
  tp->suspend.stop_signal = TARGET_SIGNAL_0;
d7185 1
a7185 1
  numsigs = (int) TARGET_SIGNAL_LAST;
d7202 2
a7203 2
  signal_program[TARGET_SIGNAL_TRAP] = 0;
  signal_program[TARGET_SIGNAL_INT] = 0;
d7206 18
a7223 18
  signal_stop[TARGET_SIGNAL_ALRM] = 0;
  signal_print[TARGET_SIGNAL_ALRM] = 0;
  signal_stop[TARGET_SIGNAL_VTALRM] = 0;
  signal_print[TARGET_SIGNAL_VTALRM] = 0;
  signal_stop[TARGET_SIGNAL_PROF] = 0;
  signal_print[TARGET_SIGNAL_PROF] = 0;
  signal_stop[TARGET_SIGNAL_CHLD] = 0;
  signal_print[TARGET_SIGNAL_CHLD] = 0;
  signal_stop[TARGET_SIGNAL_IO] = 0;
  signal_print[TARGET_SIGNAL_IO] = 0;
  signal_stop[TARGET_SIGNAL_POLL] = 0;
  signal_print[TARGET_SIGNAL_POLL] = 0;
  signal_stop[TARGET_SIGNAL_URG] = 0;
  signal_print[TARGET_SIGNAL_URG] = 0;
  signal_stop[TARGET_SIGNAL_WINCH] = 0;
  signal_print[TARGET_SIGNAL_WINCH] = 0;
  signal_stop[TARGET_SIGNAL_PRIO] = 0;
  signal_print[TARGET_SIGNAL_PRIO] = 0;
d7229 6
a7234 6
  signal_stop[TARGET_SIGNAL_LWP] = 0;
  signal_print[TARGET_SIGNAL_LWP] = 0;
  signal_stop[TARGET_SIGNAL_WAITING] = 0;
  signal_print[TARGET_SIGNAL_WAITING] = 0;
  signal_stop[TARGET_SIGNAL_CANCEL] = 0;
  signal_print[TARGET_SIGNAL_CANCEL] = 0;
@


1.535
log
@	* tracepoint.c (scope_info): Update.
	* symtab.c (lookup_block_symbol, iterate_over_symbols)
	(find_pc_sect_symtab, search_symbols)
	(default_make_symbol_completion_list_break_on)
	(make_file_symbol_completion_list): Update.
	* symmisc.c (dump_symtab_1): Update.
	* stack.c (print_frame_args, iterate_over_block_locals)
	(print_frame_labels, iterate_over_block_arg_vars): Update.
	* python/py-block.c (block_object) <dict>: Remove.
	<block>: New field.
	<iter>: Change type.
	(blpy_iter): Update.
	(blpy_block_syms_iternext): Update.
	* psymtab.c (map_block): Use block iterators.
	* objfiles.c (objfile_relocate1): Use ALL_DICT_SYMBOLS.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* mdebugread.c (parse_symbol, mylookup_symbol): Update.
	* infrun.c (check_exception_resume): Update.
	* cp-support.c (make_symbol_overload_list_block): Update.
	* coffread.c (patch_opaque_types): Update.
	* buildsym.c (finish_block, end_symtab): Use ALL_DICT_SYMBOLS.
	* block.h (struct block_iterator): New.
	(block_iterator_first, block_iterator_next, block_iter_name_first)
	(block_iter_name_next, block_iter_match_first)
	(block_iter_match_next): Declare.
	(ALL_BLOCK_SYMBOLS): Redefine.
	* block.c (block_iterator_first, block_iterator_next)
	(block_iter_name_first, block_iter_name_next)
	(block_iter_match_first, block_iter_match_next): New functions.
	* ada-lang.c (ada_add_block_symbols)
	(ada_make_symbol_completion_list): Use block iterator.
@
text
@d67 1
a67 1
static void sig_print_info (enum target_signal);
d93 1
a93 1
static void print_signal_exited_reason (enum target_signal siggnal);
d97 1
a97 1
static void print_signal_received_reason (enum target_signal siggnal);
d1436 1
a1436 1
displaced_step_fixup (ptid_t event_ptid, enum target_signal signal)
d1708 1
a1708 1
resume (int step, enum target_signal sig)
d2113 1
a2113 1
proceed (CORE_ADDR addr, enum target_signal siggnal, int step)
d3919 1
a3919 1
		 enum target_signal stop_signal;
d5809 1
a5809 1
print_signal_exited_reason (enum target_signal siggnal)
d5820 1
a5820 1
		       target_signal_to_name (siggnal));
d5825 1
a5825 1
		       target_signal_to_string (siggnal));
d5873 1
a5873 1
print_signal_received_reason (enum target_signal siggnal)
d5897 1
a5897 1
			   target_signal_to_name (siggnal));
d5902 1
a5902 1
			   target_signal_to_string (siggnal));
d6261 1
a6261 1
sig_print_info (enum target_signal oursig)
d6263 1
a6263 1
  const char *name = target_signal_to_name (oursig);
d6274 1
a6274 1
  printf_filtered ("%s\n", target_signal_to_string (oursig));
d6285 1
a6285 1
  enum target_signal oursig;
d6372 1
a6372 1
	    target_signal_from_command (atoi (*argv));
d6376 1
a6376 1
		target_signal_from_command (atoi ((*argv) + digits + 1));
d6388 1
a6388 1
	  oursig = target_signal_from_name (*argv);
d6405 1
a6405 1
	  switch ((enum target_signal) signum)
d6413 1
a6413 1
			     target_signal_to_name ((enum target_signal) signum)))
d6483 1
a6483 1
	  enum target_signal oursig;
d6485 1
a6485 1
	  oursig = target_signal_from_name (argv[0]);
d6526 2
a6527 2
enum target_signal
target_signal_from_command (int num)
d6530 1
a6530 1
    return (enum target_signal) num;
d6543 1
a6543 1
  enum target_signal oursig;
d6550 1
a6550 1
      oursig = target_signal_from_name (signum_exp);
d6555 1
a6555 1
	    target_signal_from_command (parse_and_eval_long (signum_exp));
d6565 1
a6565 1
       oursig = (enum target_signal) ((int) oursig + 1))
@


1.534
log
@2012-05-03  Pedro Alves  <pedro@@codesourcery.com>

	* infrun.c (displaced_step_fixup): Add "displaced:" prefix to
	debug log.
@
text
@d5623 1
a5623 1
      struct dict_iterator iter;
@


1.533
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	* breakpoint.c (struct breakpoint_objfile_data)
	<longjmp_searched>,<longjmp_probes>,<exception_searched>,
	<exception_probes>: New fields.
	(free_breakpoint_probes): New function.
	(create_longjmp_master_breakpoint): Prefer SystemTap probe over
	`_Unwind_DebugHook'.
	(create_exception_master_breakpoint): Likewise.
	(_initialize_breakpoint): Registering cleanup for SystemTap probes.
	* infrun.c: Including necessary header files for handling SystemTap
	probes.
	(handle_inferior_event): Handling longjmp breakpoint and exceptions
	via SystemTap probes.
	(check_exception_resume): Remove `func' argument.  Handle exception
	unwinding breakpoint set via a SystemTap probe.
	(insert_exception_resume_from_probe): New function.
@
text
@d1548 1
a1548 1
				"breakpoint is gone %s: step(%d)\n",
@


1.532
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	* ax-gdb.c (gen_expr): Clean up code to handle internal variables
	and to compile agent expressions.
	* infrun.c (siginfo_make_value): New argument `ignore'.
	(siginfo_funcs): New struct.
	(_initialize_infrun): New argument when calling
	`create_internalvar_type_lazy'.
	* thread.c (thread_id_make_value): New argument `ignore'.
	(thread_funcs): New struct.
	(_initialize_thread): New argument when calling
	`create_internalvar_type_lazy'.
	* tracepoint.c (sdata_make_value): New argument `ignore'.
	(sdata_funcs): New struct.
	(_initialize_tracepoint): New argument when calling
	`create_internalvar_type_lazy'.
	* value.c (make_value): New struct.
	(create_internalvar_type_lazy): New argument `data'.
	(compile_internalvar_to_ax): New function.
	(value_of_internalvar): Properly handling `make_value' case.
	(clear_internalvar): Likewise.
	(show_convenience): Adding `TRY_CATCH' block.
	* value.h (internalvar_make_value): Delete, replace by...
	(struct internalvar_funcs): ... this.
	(create_internalvar_type_lazy) <fun>: Delete argument.
	(create_internalvar_type_lazy) <funcs>, <data>: New arguments.
	(compile_internalvar_to_ax): New function.
	* windows-tdep.c (tlb_make_value): New argument `ignore'.
	(tlb_funcs): New struct.
	(_initialize_windows_tdep): New argument when calling
	`create_internalvar_type_lazy'.
@
text
@d58 2
d2407 1
a2407 1
				    struct frame_info *, struct symbol *);
d4442 11
a4452 3
	    if (!gdbarch_get_longjmp_target_p (gdbarch)
		|| !gdbarch_get_longjmp_target (gdbarch,
						frame, &jmp_buf_pc))
d4470 1
a4470 6
	  {
	    struct symbol *func = get_frame_function (frame);

	    if (func)
	      check_exception_resume (ecs, frame, func);
	  }
d5560 31
d5597 1
a5597 1
			struct frame_info *frame, struct symbol *func)
d5600 19
@


1.531
log
@	gdb/
	* infrun.c (handle_inferior_event): Move the check for return
	trampolines ahead of the check for function trampolines.
	* mips-tdep.h (MIPS_S2_REGNUM, MIPS_GP_REGNUM): New macros.
	* mips-tdep.c (mips_str_mips16_call_stub): New variable.
	(mips_str_mips16_ret_stub): Likewise.
	(mips_str_call_fp_stub): Likewise.
	(mips_str_call_stub): Likewise.
	(mips_str_fn_stub): Likewise.
	(mips_str_pic): Likewise.
	(mips_in_frame_stub): New function.
	(mips_unwind_pc): Return the return address rather than the PC
	if the PC of an intermediate frame is inside a call thunk.
	(mips_is_stub_suffix): New function.
	(mips_is_stub_mode): Likewise.
	(mips_get_mips16_fn_stub_pc): Likewise.
	(mips_skip_mips16_trampoline_code): Update to handle all the
	currently generated stub types.  Don't recurse into __fn_stub
	thunks.  Remove heuristics to handle stubs beyond etext/_etext.
	Use cooked register accesses.
	(mips_in_return_stub): Reintroduce function.
	(mips_skip_trampoline_code): Traverse trampolines recursively.
	(mips_gdbarch_init): Handle MIPS16 return trampolines.

	gdb/testsuite/
	* gdb.arch/mips16-thunks-inmain.c: New file.
	* gdb.arch/mips16-thunks-main.c: New file.
	* gdb.arch/mips16-thunks-sin.c: New file.
	* gdb.arch/mips16-thunks-sinfrob.c: New file.
	* gdb.arch/mips16-thunks-sinfrob16.c: New file.
	* gdb.arch/mips16-thunks-sinmain.c: New file.
	* gdb.arch/mips16-thunks-sinmips16.c: New file.
	* gdb.arch/mips16-thunks.exp: New file.
@
text
@d6605 2
a6606 1
siginfo_make_value (struct gdbarch *gdbarch, struct internalvar *var)
d7028 9
d7325 1
a7325 1
  create_internalvar_type_lazy ("_siginfo", siginfo_make_value);
@


1.530
log
@2012-04-13  Luis Machado  <lgustavo@@codesourcery.com>

	* infrun.c (resume): Update PC address to the real PC after
	preparing to do displaced stepping.
@
text
@d4817 42
a5068 39
  /* If we're in the return path from a shared library trampoline,
     we want to proceed through the trampoline when stepping.  */
  if (gdbarch_in_solib_return_trampoline (gdbarch,
					  stop_pc, ecs->stop_func_name)
      && ecs->event_thread->control.step_over_calls != STEP_OVER_NONE)
    {
      /* Determine where this trampoline returns.  */
      CORE_ADDR real_stop_pc;

      real_stop_pc = gdbarch_skip_trampoline_code (gdbarch, frame, stop_pc);

      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog,
			     "infrun: stepped into solib return tramp\n");

      /* Only proceed through if we know where it's going.  */
      if (real_stop_pc)
	{
	  /* And put the step-breakpoint there and go until there.  */
	  struct symtab_and_line sr_sal;

	  init_sal (&sr_sal);	/* initialize to zeroes */
	  sr_sal.pc = real_stop_pc;
	  sr_sal.section = find_pc_overlay (sr_sal.pc);
	  sr_sal.pspace = get_frame_program_space (frame);

	  /* Do not specify what the fp should be when we stop since
	     on some machines the prologue is where the new fp value
	     is established.  */
	  insert_step_resume_breakpoint_at_sal (gdbarch,
						sr_sal, null_frame_id);

	  /* Restart without fiddling with the step ranges or
	     other state.  */
	  keep_going (ecs);
	  return;
	}
    }

@


1.529
log
@gdb/
	Provide more specific displaced-stepping memory error message.
	* infrun.c (displaced_step_prepare): New variable status.  Call
	target_read_memory instead of read_memory, provide more specific
	error message.
@
text
@d1792 4
@


1.528
log
@2012-03-07  Pedro Alves  <palves@@redhat.com>

	gdb/doc/
	* gdb.texinfo (General Query Packets): Document new
	QProgramSignals packet.
	* gdb.texinfo (Remote configuration): Mention
	"program-signals-packet".

	gdb/gdbserver/
	* linux-low.c (get_detach_signal): New.
	(linux_detach_one_lwp): Get rid of a pending SIGSTOP with SIGCONT.
	Pass on pending signals to PTRACE_DETACH.  Check the result of the
	ptrace call.
	* server.c (program_signals, program_signals_p): New.
	(handle_general_set): Handle QProgramSignals.
	* server.h (program_signals, program_signals_p): Declare.

	gdb/
	* NEWS: Mention QProgramSignals.
	* inferior.h (update_signals_program_target): Declare.
	* infrun.c: (update_signals_program_target): New.
	(handle_command): Update the target of the new program signals
	array changes.
	* remote.c (PACKET_QProgramSignals): New enum.
	(last_program_signals_packet): New global.
	(remote_program_signals): New.
	(remote_start_remote): Update the target with the program signals
	list.
	(remote_protocol_features): Add entry for QPassSignals.
	(remote_open_1): Free anc clear last_program_signals_packet.
	(init_remote_ops): Install remote_program_signals.
	* target.c (update_current_target): Adjust.
	(target_program_signals): New.
	* target.h (struct target_ops) <to_program_signals>: New field.
	(target_program_signals): Declare.
@
text
@d1299 1
d1360 6
a1365 1
  read_memory (copy, displaced->step_saved_copy, len);
@


1.527
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* common/signals.c (default_target_signal_to_host)
	(default_target_signal_from_host): Move ...
	* arch-utils.c: ... here.
	* arch-utils.h (default_target_signal_to_host)
	(default_target_signal_from_host): Declare.

	* common/signals.c (target_signal_from_command): Move ...
	* infrun.c: ... here.
	* inferior.h (target_signal_from_command): Declare.
	* target.h (target_signal_from_command)
	(default_target_signal_from_host, default_target_signal_to_host):
	Delete declarations.

	* common/signals.c (_initialize_signals): Delete.
@
text
@d338 9
d6375 1
@


1.526
log
@gdb/
	* arm-linux-tdep.c (arm_linux_copy_svc): Reset stale FRAME.
	* breakpoint.c (until_break_command): Likewise.
	* elfread.c (elf_gnu_ifunc_resolver_stop): Likewise.
	* infcall.c (call_function_by_hand): Likewise.
	* infcmd.c (finish_forward): Likewise.
	* infrun.c (insert_exception_resume_breakpoint): Likewise.
@
text
@d6448 9
@


1.525
log
@	* infrun.c (handle_inferior_event): Don't proceed through
	shared library trampolines if stepping at the machine
	instruction level.
@
text
@d5523 4
@


1.524
log
@	* symfile.c (symbol_file_add_main_1): Use inferior's
	symfile_flags.
	* solib.c (solib_read_symbols): Use inferior's symfile_flags.
	* linux-nat.c (linux_child_follow_fork): Set symfile_flags on
	inferior.
	* infrun.c (handle_vfork_child_exec_or_exit): Set symfile_flags on
	inferior.
	(follow_exec): Use inferior's symfile_flags.
	* inferior.h (struct inferior) <symfile_flags>: New field.
@
text
@d5011 2
a5012 1
					  stop_pc, ecs->stop_func_name))
@


1.523
log
@	* blockframe.c (find_pc_partial_function_gnu_ifunc): Change type of
	"name" parameter to const char ** from char **.  All callers updated.
	(find_pc_partial_function): Ditto.
	(cache_pc_function_name): Change type to const char * from char *.
	* symtab.h ((find_pc_partial_function_gnu_ifunc): Update.
	(find_pc_partial_function): Update.
	* alpha-tdep.h (struct gdbarch_tdep, member pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	All uses updated.
	* arch-utils.c (generic_in_solib_return_trampoline): Change
	type of "name" parameter to const char * from char *.
	* arch-utils.h (generic_in_solib_return_trampoline): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* gdbarch.sh (in_solib_return_trampoline): Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Update.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Update.
	* m32r-linux-tdep.c (m32r_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* skip.c (skip_function_pc): Ditto.
	* sparc-sol2-tdep.c (sparc_sol2_pc_in_sigtramp): Ditto.
	* sparc-tdep.h (sparc_sol2_pc_in_sigtramp): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_pc_in_sigtramp): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_pc_in_sigtramp): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_pc_in_sigtramp): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_pc_in_sigtramp): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_pc_in_sigtramp): Ditto.
	* nbsd-tdep.c (nbsd_pc_in_sigtramp): Similary for "func_name".
	* nbsd-tdep.h (nbsd_pc_in_sigtramp): Update.
@
text
@d742 1
d904 3
a906 1
  symbol_file_add (execd_pathname, SYMFILE_MAINLINE | SYMFILE_DEFER_BP_RESET,
d909 2
a910 1
  set_initial_language ();
@


1.522
log
@gdb/
	Code cleanup: Make 1440 bytes of data segment read-only.
	* arch-utils.c (endian_enum): Make it const char *const [].
	* arm-tdep.c (fp_model_strings, arm_abi_strings, arm_mode_strings):
	Likewise.
	* breakpoint.c (always_inserted_enums): Likewise.
	* cli/cli-cmds.c (script_ext_enums): Likewise.
	* cli/cli-decode.c (add_setshow_enum_cmd, complete_on_enum): Make the
	enumlist parameter const char *const *.
	* cli/cli-decode.h (struct cmd_list_element): Make the enums field
	const char *const *.
	* command.h (complete_on_enum, add_setshow_enum_cmd): Make the enumlist
	parameter const char *const *.
	* cris-tdep.c (cris_modes): Make it const char *const [].
	* filesystem.c (target_file_system_kinds): Likewise.
	* i386-tdep.c (valid_flavors, valid_conventions): Likewise.
	* infrun.c (follow_fork_mode_kind_names, follow_exec_mode_names)
	(can_use_displaced_stepping_enum, scheduler_enums)
	(exec_direction_names): Likewise.
	* language.c (_initialize_language): Make the type_or_range_names and
	case_sensitive_names variables const char *const [].
	* mips-tdep.c (mips_abi_strings): Make it const char *const [].
	* python/python.c (python_excp_enums): Likewise.
	* remote.c (interrupt_sequence_modes): Likewise.
	* rs6000-tdep.c (powerpc_vector_strings): Likewise.
	* serial.c (logbase_enums): Likewise.
	* sh-tdep.c (sh_cc_enum): Likewise.
	* stack.c (print_frame_arguments_choices, print_entry_values_choices):
	Likewise.
	* symtab.c (multiple_symbols_modes): Likewise.
	* tui/tui-win.c (tui_border_kind_enums, tui_border_mode_enums):
	Likewise.
	* utils.c (internal_problem_modes): Likewise.
@
text
@d2370 1
a2370 1
  char *stop_func_name;
@


1.521
log
@	PR symtab/12406:
	* solib.c (update_solib_list): Update the program space's
	added_solibs and deleted_solibs fields.
	* progspace.h (struct program_space) <added_solibs,
	deleted_solibs>: New fields.
	(clear_program_space_solib_cache): Declare.
	* progspace.c (release_program_space): Call
	clear_program_space_solib_cache.
	(clear_program_space_solib_cache): New function.
	* infrun.c (handle_inferior_event) <TARGET_WAITKIND_LOADED>: Call
	bpstat_stop_status.  Use handle_solib_event.
	* breakpoint.c: Include gdb_regex.h.
	(print_solib_event): New function.
	(bpstat_print): Use print_solib_event.
	(bpstat_stop_status): Add special case for bp_shlib_event.
	(handle_solib_event): New function.
	(bpstat_what): Use handle_solib_event.
	(struct solib_catchpoint): New.
	(dtor_catch_solib, insert_catch_solib, remove_catch_solib)
	(breakpoint_hit_catch_solib, check_status_catch_solib)
	(print_it_catch_solib, print_one_catch_solib)
	(print_mention_catch_solib, print_recreate_catch_solib): New
	functions.
	(catch_solib_breakpoint_ops): New global.
	(catch_load_or_unload, catch_load_command_1)
	(catch_unload_command_1): New functions.
	(internal_bkpt_check_status): Add special case for
	bp_shlib_event.
	(internal_bkpt_print_it): Use print_solib_event.
	(initialize_breakpoint_ops): Initialize
	catch_solib_breakpoint_ops.
	(_initialize_breakpoint): Register "catch load" and "catch
	unload".
	* breakpoint.h (handle_solib_event): Declare.
	* NEWS: Add entry for "catch load" and "catch unload".
gdb/doc
	* gdb.texinfo (Set Catchpoints): Document "catch load" and "catch
	unload".
	(Files): Mention new catch commands.
	(GDB/MI Async Records): Likewise.
gdb/testsuite
	* lib/mi-support.exp (mi_expect_stop): Add special case for
	solib-event.
	* gdb.base/catch-load-so.c: New file.
	* gdb.base/catch-load.exp: New file.
	* gdb.base/catch-load.c: New file.
	* gdb.base/break-interp.exp (reach_1): Update regexp.
@
text
@d392 1
a392 1
static const char *follow_fork_mode_kind_names[] = {
d781 1
a781 1
static const char *follow_exec_mode_names[] =
d1178 1
a1178 1
static const char *can_use_displaced_stepping_enum[] =
d1582 1
a1582 1
static const char *scheduler_enums[] = {
d6910 1
a6910 1
static const char *exec_direction_names[] = {
@


1.520
log
@2012-01-24  Pedro Alves  <pedro@@codesourcery.com>

	* breakpoint.c (breakpoint_hit_catch_fork)
	(breakpoint_hit_catch_vfork, breakpoint_hit_catch_syscall)
	(breakpoint_hit_catch_exec): Make use of the `ws' argument.
	* infrun.c (inferior_has_forked, inferior_has_vforked)
	(inferior_has_execd, inferior_has_called_syscall): Delete.
	(handle_syscall_event): Get syscall_number from the execution
	control state's wait status.
	(wait_for_inferior): Don't clear syscall_number.
@
text
@d3319 20
a3338 17
	  /* Check for any newly added shared libraries if we're
	     supposed to be adding them automatically.  Switch
	     terminal for any messages produced by
	     breakpoint_re_set.  */
	  target_terminal_ours_for_output ();
	  /* NOTE: cagney/2003-11-25: Make certain that the target
	     stack's section table is kept up-to-date.  Architectures,
	     (e.g., PPC64), use the section table to perform
	     operations such as address => section name and hence
	     require the table to contain all sections (including
	     those found in shared libraries).  */
#ifdef SOLIB_ADD
	  SOLIB_ADD (NULL, 0, &current_target, auto_solib_add);
#else
	  solib_add (NULL, 0, &current_target, auto_solib_add);
#endif
	  target_terminal_inferior ();
d3344 1
a3353 3

	  /* NOTE drow/2007-05-11: This might be a good place to check
	     for "catch load".  */
@


1.519
log
@2012-01-24  Pedro Alves  <palves@@redhat.com>

	* breakpoint.c (bpstat_check_location, bpstat_stop_status,
	pc_at_non_inline_function): Add `ws' parameter, and pass it down.
	(breakpoint_hit_catch_fork, breakpoint_hit_catch_vfork)
	(breakpoint_hit_catch_syscall, breakpoint_hit_catch_exec): Add
	`ws' parameter.
	(breakpoint_hit_ranged_breakpoint): Add `ws' parameter.  Return
	false for events other than TARGET_SIGNAL_TRAP.
	(breakpoint_hit_watchpoint, base_breakpoint_breakpoint_hit):
	Add `ws' parameter.
	(bkpt_breakpoint_hit): Add `ws' parameter.  Return false for
	events other than TARGET_SIGNAL_TRAP.
	(tracepoint_breakpoint_hit): Add `ws' parameter.
	* breakpoint.h (struct breakpoint_ops) <breakpoint_hit>: Add `ws'
	parameter.
	(bpstat_stop_status): Same.
	(pc_at_non_inline_function): Same.
	* infrun.c (handle_syscall_event, handle_inferior_event): Adjust
	to pass the current event's waitstatus to bpstat_stop_status
	and pc_at_non_inline_function.
@
text
@a2703 4
      if (ecs->ws.kind == TARGET_WAITKIND_SYSCALL_ENTRY
          || ecs->ws.kind == TARGET_WAITKIND_SYSCALL_RETURN)
        ecs->ws.value.syscall_number = UNKNOWN_SYSCALL;

d3071 1
a3071 1
  syscall_number = gdbarch_get_syscall_number (gdbarch, ecs->ptid);
a3073 2
  target_last_waitstatus.value.syscall_number = syscall_number;

a6859 73
inferior_has_forked (ptid_t pid, ptid_t *child_pid)
{
  struct target_waitstatus last;
  ptid_t last_ptid;

  get_last_target_status (&last_ptid, &last);

  if (last.kind != TARGET_WAITKIND_FORKED)
    return 0;

  if (!ptid_equal (last_ptid, pid))
    return 0;

  *child_pid = last.value.related_pid;
  return 1;
}

int
inferior_has_vforked (ptid_t pid, ptid_t *child_pid)
{
  struct target_waitstatus last;
  ptid_t last_ptid;

  get_last_target_status (&last_ptid, &last);

  if (last.kind != TARGET_WAITKIND_VFORKED)
    return 0;

  if (!ptid_equal (last_ptid, pid))
    return 0;

  *child_pid = last.value.related_pid;
  return 1;
}

int
inferior_has_execd (ptid_t pid, char **execd_pathname)
{
  struct target_waitstatus last;
  ptid_t last_ptid;

  get_last_target_status (&last_ptid, &last);

  if (last.kind != TARGET_WAITKIND_EXECD)
    return 0;

  if (!ptid_equal (last_ptid, pid))
    return 0;

  *execd_pathname = xstrdup (last.value.execd_pathname);
  return 1;
}

int
inferior_has_called_syscall (ptid_t pid, int *syscall_number)
{
  struct target_waitstatus last;
  ptid_t last_ptid;

  get_last_target_status (&last_ptid, &last);

  if (last.kind != TARGET_WAITKIND_SYSCALL_ENTRY &&
      last.kind != TARGET_WAITKIND_SYSCALL_RETURN)
    return 0;

  if (!ptid_equal (last_ptid, pid))
    return 0;

  *syscall_number = last.value.syscall_number;
  return 1;
}

int
@


1.518
log
@2012-01-06  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* ada-lang.c (ada_exception_name_addr): Add `volatile' keyword
	before `struct gdb_exception'.
	* breakpoint.c (update_global_location_list_nothrow)
	(update_breakpoint_locations, enable_breakpoint_disp): Likewise.
	* cp-abi.c (value_rtti_type): Likewise.
	* cp-support.c (cp_validate_operator): Likewise.
	* infrun.c (insert_exception_resume_breakpoint)
	(check_exception_resume, keep_going): Likewise.
	* mi-interp.c (mi_breakpoint_created)
	(mi_breakpoint_modified): Likewise.
	* rs6000-aix-tdep.c (rs6000_convert_from_func_ptr_addr): Likewise.
	* solib-ia64-hpux.c (ia64_hpux_at_dld_breakpoint_p)
	(ia64_hpux_handle_dld_breakpoint_1): Likewise.
@
text
@d3089 1
a3089 1
			      stop_pc, ecs->ptid);
d3540 1
a3540 1
			      stop_pc, ecs->ptid);
d3638 1
a3638 1
			      stop_pc, ecs->ptid);
d4097 1
a4097 1
      if (!pc_at_non_inline_function (aspace, stop_pc)
d4101 2
a4102 1
                                             ecs->event_thread->prev_pc)))
d4204 2
a4205 1
      /* See if there is a breakpoint at the current PC.  */
d4208 1
a4208 1
			      stop_pc, ecs->ptid);
@


1.517
log
@2012-01-05  Khoo Yit Phang  <khooyp@@cs.umd.edu>

	* infrun.c (normal_stop): Don't skip calling the normal_stop
	observers if the thread was doing a multi-step, but stopped for
	some reason other than stepping.

gdb/testsuite/
2012-01-05  Pedro Alves  <alves.ped@@gmail.com>

	* gdb.mi/mi-stepn.c, gdb.mi/mi-stepn.exp: New files.
	* gdb.python/py-events.c (first): Add bits for new "step N" test.
	* gdb.python/py-events.exp: Test that "step N" tripping on a
	breakpoint emits a breakpoint event.
@
text
@d5497 1
a5497 1
  struct gdb_exception e;
d5535 1
a5535 1
  struct gdb_exception e;
d5642 1
a5642 1
	  struct gdb_exception e;
@


1.516
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d6071 2
a6072 1
      || (!inferior_thread ()->step_multi
@


1.515
log
@gdb
	PR mi/8444:
	* mi/mi-common.h (EXEC_ASYNC_SOLIB_EVENT, EXEC_ASYNC_FORK)
	(EXEC_ASYNC_VFORK, EXEC_ASYNC_SYSCALL_ENTRY)
	(EXEC_ASYNC_SYSCALL_RETURN, EXEC_ASYNC_EXEC): New constants.
	* mi/mi-common.c (async_reason_string_lookup): Add new reasons.
	* breakpoint.c (print_it_catch_fork, print_it_catch_vfork)
	(print_it_catch_syscall, print_it_catch_exec)
	(internal_bkpt_print_it): Use ui_out.  Emit stop reason.
	(bpstat_print): Add 'kind' argument.  Handle
	TARGET_WAITKIND_LOADED.
	* infrun.c (normal_stop): Update for bpstat_print change.  Don't
	handle TARGET_WAITKIND_LOADED here.
	* breakpoint.h (bpstat_print): Update.
gdb/testsuite
	* lib/mi-support.exp (mi_run_cmd_full): Rename from mi_run_cmd.
	Add "use_mi_command" argument.
	(mi_run_cmd, mi_run_with_cli): New procs.
	* gdb.mi/solib-lib.c: New file.
	* gdb.mi/solib-main.c: New file.
	* gdb.mi/mi-solib.exp: New file.
gdb/doc
	* gdb.texinfo (GDB/MI Async Records): Document new *stopped
	reasons.
@
text
@d4 1
a4 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.515.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d4 3
a6 1
   Copyright (C) 1986-2012 Free Software Foundation, Inc.
@


1.514
log
@Minor reformatting in infrun.c:handle_inferior_event

gdb/ChangeLog:

        * infrun.c (handle_inferior_event): Minor reformatting.
@
text
@d5974 1
a5974 1
	  bpstat_ret = bpstat_print (tp->control.stop_bpstat);
a5977 12
	      /* If we had hit a shared library event breakpoint,
		 bpstat_print would print out this message.  If we hit
		 an OS-level shared library event, do the same
		 thing.  */
	      if (last.kind == TARGET_WAITKIND_LOADED)
		{
		  printf_filtered (_("Stopped due to shared library event\n"));
		  source_flag = SRC_LINE;	/* something bogus */
		  do_frame_printing = 0;
		  break;
		}

@


1.513
log
@2011-10-06  Justin Lebar  <justin.lebar@@gmail.com>

	* Makefile.in: (SFILES): Add skip.c.
	(HFILES_NO_SRCDIR): Add skip.h.
	(COMMON_OBS): Add skip.o.
	* skip.h, skip.c: New.
	* breakpoint.h (set_default_breakpoint): Remove.
	(get_sal_arch): Declare.
	* breakpoint.c: Remove default_breakpoint_valid,
	default_breakpoint_address, default_breakpoint_symtab,
	default_breakpoint_line, default_breakpoint_pspace variables.
	(get_sal_arch): Make public.
	(set_default_breakpoint): Remove.
	(parse_breakpoint_sals, create_breakpoint, clear_command,
	decode_line_spec_1): Remove uses of default_breakpoint variables;
	replaced with function calls into stack.c.
	* cli/cli-cmds.h: Add cmd_list_element *skiplist.
	* cli/cli-cmds.c: Add skiplist.
	(init_cmd_lists): Initialize skiplist.
	(init_cli_cmds): Fix comment (classes of commands appear in
	alphabetical order).
	* infrun.c (handle_inferior_event): Add check that we don't step into
	a function whose pc is marked for skip.
	* stack.c: Declare last_displayed_sal_valid, last_displayed_pspace,
	last_displayed_addr, last_displayed_symtab, last_displayed_line
	variables.
	(set_last_displayed_sal): New static function.
	(print_frame_info): Switch call to set_default_breakpoint to call to
	set_last_displayed_sal.
	(clear_last_displayed_sal, last_displayed_sal_is_valid,
	get_last_displayed_pspace, get_last_displayed_addr,
	get_last_displayed_symtab, get_last_displayed_line,
	get_last_displayed_sal): New public functions.
	* stack.h (clear_last_displayed_sal, last_displayed_sal_is_valid,
	get_last_displayed_pspace, get_last_displayed_addr,
	get_last_displayed_symtab, get_last_displayed_line,
	get_last_displayed_sal): Declare.

2011-10-06  Justin Lebar <justin.lebar@@gmail.com>

	Add tests for skip command.
	* testsuite/gdb.base/skip-solib-lib.c: New
	* testsuite/gdb.base/skip-solib-main.c: New
	* testsuite/gdb.base/skip-solib.exp: New
	* testsuite/gdb.base/skip.c: New
	* testsuite/gdb.base/skip.exp: New
	* testsuite/gdb.base/skip1.c: New
	* testsuite/gdb.base/Makefile.in: Adding new files.
@
text
@d4931 2
a4932 2
	if (tmp_sal.line != 0 &&
	    !function_pc_is_marked_for_skip (ecs->stop_func_start))
@


1.512
log
@2011-10-28  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* linux-nat.c (linux_nat_filter_event): Remove `options'
	parameter, and dead code that used it.  If we're handling a
	PTRACE_EVENT_EXEC event, and the thread group leader is no longer
	in our lwp list, re-add it.
	(check_zombie_leaders): New.
	(linux_nat_wait_1): Remove `options' and `pid' locals.  Always
	wait for children with WNOHANG, and always wait for all children.
	Don't check for no resumed children upfront.  Simplify wait loop.
	Check for zombie thread group leaders after handling all wait
	statuses.  Return TARGET_WAITKIND_NO_RESUMED if there no
	unwaited-for children left.
	* infrun.c (fetch_inferior_event): Handle TARGET_WAITKIND_NO_RESUMED.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_RESUMED.
	(normal_stop): Handle TARGET_WAITKIND_NO_RESUMED.
	* target.h (enum target_waitkind) <TARGET_WAITKIND_NO_RESUMED>: New.

	gdb/testsuite/
	* gdb.threads/no-unwaited-for-left.c: New.
	* gdb.threads/no-unwaited-for-left.exp: New.
	* gdb.threads/non-ldr-exc-1.c: New.
	* gdb.threads/non-ldr-exc-1.exp: New.
	* gdb.threads/non-ldr-exc-2.c: New.
	* gdb.threads/non-ldr-exc-2.exp: New.
	* gdb.threads/non-ldr-exc-3.c: New.
	* gdb.threads/non-ldr-exc-3.exp: New.
	* gdb.threads/non-ldr-exc-4.c: New.
	* gdb.threads/non-ldr-exc-4.exp: New.
@
text
@d59 1
d4921 2
a4922 1
         thinking of stepping into, step into it.
d4931 2
a4932 1
	if (tmp_sal.line != 0)
@


1.511
log
@2011-10-24  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* infrun.c (handle_inferior_event): Don't assume inferior_ptid is
	already set when marking the event thread as not executing in
	non-stop mode.
@
text
@d2776 1
d2810 1
d3169 15
d3185 2
a3186 1
      && ecs->ws.kind != TARGET_WAITKIND_SIGNALLED)
d3203 12
d5857 2
a5858 1
	   && last.kind != TARGET_WAITKIND_EXITED)
d5877 2
a5878 1
      && last.kind != TARGET_WAITKIND_EXITED)
d5887 8
d6081 1
@


1.510
log
@2011-10-24  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* infrun.c (handle_inferior_event): Add debug output for
	TARGET_WAITKIND_NO_HISTORY.
@
text
@d3242 1
a3242 1
    set_executing (inferior_ptid, 0);
@


1.509
log
@2011-10-12  Gary Benson  <gbenson@@redhat.com>

	* breakpoint.h (pc_at_non_inline_function): Declare.
	* breakpoint.c (is_non_inline_function,
	pc_at_non_inline_function): New functions.
	* infrun.c (handle_inferior_event): Don't call skip_inline_frames
	if the stop is at a location where functions cannot be inlined.
@
text
@d3659 2
@


1.508
log
@	* inferior.h (disable_randomization): Declare.
	* infrun.c (disable_randomization): New global variable.
	(show_disable_randomization): New function.
	(set_disable_randomization): Likewise.
	(_initialize_infrun): Install set/show disable-randomization
	commands.
	* linux-nat.c (disable_randomization): Remove.
	(show_disable_randomization): Likewise.
	(set_disable_randomization): Likewise.
	(_initialize_linux_nat): No longer install set/show
	disable-randomization commands here.
	(linux_nat_supports_disable_randomization): New function.
	(linux_nat_add_target): Install it.
	* remote.c (PACKET_QDisableRandomization): New enum value.
	(remote_protocol_packets): Support QDisableRandomization.
	(_initialize_remote): Likewise.
	(remote_supports_disable_randomization): New function.
	(init_remote_ops): Install it.
	(extended_remote_supports_disable_randomization): New function.
	(init_extended_remote_ops): Install it.
	(extended_remote_disable_randomization): New function.
	(extended_remote_create_inferior_1): Call it.
	* target.h (struct target_ops): Add to_supports_disable_randomization.
	(target_supports_disable_randomization): Add prototype.
	* target.c (target_supports_disable_randomization): New function.
	(find_default_supports_disable_randomization): Likewise.
	(init_dummy_target): Install it.

doc/
	* gdb.texinfo (Starting your Program): "set disable-randomization"
	is no longer Linux-specific.
	(Remote Configuration): Document "set remote
	disable-randomization-packet".
	(General Query Packets): Document "QDisableRandomization" packet
	and add it to "qSupported" list.

gdbserver/
	* configure.ac: Check support for personality routine.
	* configure: Regenerate.
	* config.in: Likewise.
	* linux-low.c: Include <sys/personality.h>.
	Define ADDR_NO_RANDOMIZE if necessary.
	(linux_create_inferior): Disable address space randomization when
	forking inferior, if requested.
	(linux_supports_disable_randomization): New function.
	(linux_target_ops): Install it.
	* server.h (disable_randomization): Declare.
	* server.c (disable_randomization): New global variable.
	(handle_general_set): Handle QDisableRandomization.
	(handle_query): Likewise for qSupported.
	(main): Support --disable-randomization and --no-disable-randomization
	command line arguments.
	* target.h (struct target_ops): Add supports_disable_randomization.
	(target_supports_disable_randomization): New macro.
@
text
@d4047 26
a4072 1
    skip_inline_frames (ecs->ptid);
@


1.507
log
@gdb/
	* infrun.c (context_switch): Print debug message when switching to
	a different thread.
@
text
@d150 31
d7266 13
@


1.506
log
@	gdb/
	* infrun.c (displaced_step_fixup): Move some code ...
	(displaced_step_restore): ... here.  New function.
	(handle_inferior_event): Cleanup displaced stepping state for both
	child and parent when get forked or vforked event.
	* regcache.c (get_thread_arch_aspace_regcache): New function.
	get_thread_arch_regcache (): Call it.
@
text
@d2855 1
a2855 1
  if (debug_infrun)
@


1.505
log
@2011-09-14  Pedro Alves  <pedro@@codesourcery.com>

	* infrun.c (prepare_for_detach, wait_for_inferior)
	(fetch_inferior_event): Don't flush the register cache.
	* remote.c (struct stop_reply) <regcache>: Add comment.
@
text
@d1367 17
d1402 1
a1402 11
  /* Restore the contents of the copy area.  */
  {
    ULONGEST len = gdbarch_max_insn_length (displaced->step_gdbarch);

    write_memory_ptid (displaced->step_ptid, displaced->step_copy,
		       displaced->step_saved_copy, len);
    if (debug_displaced)
      fprintf_unfiltered (gdb_stdlog, "displaced: restored %s\n",
                          paddress (displaced->step_gdbarch,
				    displaced->step_copy));
  }
d3383 54
@


1.504
log
@	gdb/
	* gdbthread.h (struct thread_info): Remove fields
	`stepping_through_solib_after_catch' and
	`stepping_through_solib_catchpoints'.
	* infrun.c (init_thread_stepping_state): Update.
	(process_event_stop_test, currently_stepping): Update.
	(currently_stepping_or_nexting_callback): Update.
@
text
@a2582 8
      /* We have to invalidate the registers BEFORE calling
	 target_wait because they can be loaded from the target while
	 in target_wait.  This makes remote debugging a bit more
	 efficient for those targets that provide critical registers
	 as part of their normal status mechanism.  */

      registers_changed ();

a2651 6
      /* We have to invalidate the registers BEFORE calling target_wait
	 because they can be loaded from the target while in target_wait.
	 This makes remote debugging a bit more efficient for those
	 targets that provide critical registers as part of their normal
	 status mechanism.  */

a2652 1
      registers_changed ();
a2721 6
  /* We have to invalidate the registers BEFORE calling target_wait
     because they can be loaded from the target while in target_wait.
     This makes remote debugging a bit more efficient for those
     targets that provide critical registers as part of their normal
     status mechanism.  */

a2723 12
  /* But don't do it if the current thread is already stopped (hence
     this is either a delayed event that will result in
     TARGET_WAITKIND_IGNORE, or it's an event for another thread (and
     we always clear the register and frame caches when the user
     switches threads anyway).  If we didn't do this, a spurious
     delayed event in all-stop mode would make the user lose the
     selected frame.  */
  if (non_stop
      || (!ptid_equal (inferior_ptid, null_ptid)
	  && is_executing (inferior_ptid)))
    registers_changed ();

@


1.503
log
@2011-09-05  Pedro Alves  <pedro@@codesourcery.com>

	PR cli/13110

	* infrun.c (fetch_inferior_event): Check if there's a selected
	thread before checking if the selected thread is executing.
@
text
@a2855 2
  tss->stepping_through_solib_after_catch = 0;
  tss->stepping_through_solib_catchpoints = NULL;
a4553 31
  /* Are we stepping to get the inferior out of the dynamic linker's
     hook (and possibly the dld itself) after catching a shlib
     event?  */
  if (ecs->event_thread->stepping_through_solib_after_catch)
    {
#if defined(SOLIB_ADD)
      /* Have we reached our destination?  If not, keep going.  */
      if (SOLIB_IN_DYNAMIC_LINKER (PIDGET (ecs->ptid), stop_pc))
	{
          if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog,
				"infrun: stepping in dynamic linker\n");
	  ecs->event_thread->stepping_over_breakpoint = 1;
	  keep_going (ecs);
	  return;
	}
#endif
      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog, "infrun: step past dynamic linker\n");
      /* Else, stop and report the catchpoint(s) whose triggering
         caused us to begin stepping.  */
      ecs->event_thread->stepping_through_solib_after_catch = 0;
      bpstat_clear (&ecs->event_thread->control.stop_bpstat);
      ecs->event_thread->control.stop_bpstat
	= bpstat_copy (ecs->event_thread->stepping_through_solib_catchpoints);
      bpstat_clear (&ecs->event_thread->stepping_through_solib_catchpoints);
      stop_print_frame = 1;
      stop_stepping (ecs);
      return;
    }

a5112 1
	  || tp->stepping_through_solib_after_catch
d5126 1
a5126 2
 	  || tp->control.trap_expected
 	  || tp->stepping_through_solib_after_catch);
@


1.502
log
@2011-09-05  Pedro Alves  <pedro@@codesourcery.com>

	* inf-loop.c (execute_command): Don't check if the current thread
	if running before synchronously waiting for command completion.
	* infrun.c (fetch_inferior_event): Handle "set exec-done-display"
	here.
	(normal_stop): Call async_enable_stdin here.
	* inf-loop.c (inferior_event_handler): Don't call
	async_enable_stdin, nor handle "set exec-done-display" here.
@
text
@d2752 3
a2754 1
  if (non_stop || is_executing (inferior_ptid))
@


1.501
log
@2011-09-02  Pedro Alves  <pedro@@codesourcery.com>

	* top.c: Include interps.h.
	(execute_command): If the target can async, but the interpreter is
	in sync mode, synchronously wait for the command to finish before
	returning.
	(execute_command_to_string): Force the interpreter to sync mode.
	* infrun.c: Include interps.h.
	(fetch_inferior_event): Don't restore the prompt yet if the
	interpreter is in sync mode.
	* interps.c (interpreter_async): New global.
	* interps.h (interpreter_async): Declare.
	* inf-loop.c: Include interps.h.
	(inferior_event_handler): Don't print the language change or run
	breakpoint commands yet if the interpreter in is sync mode.
	* main.c (captured_command_loop): Flip the interpreter to async
	mode.
	* cli/cli-script.c: Include interps.h.
	(execute_user_command, while_command, if_command): Force the
	interpreter to sync mode.
	* python/python.c: Include interps.h.
	(python_command, execute_gdb_command): Force the interpreter to
	sync mode.
@
text
@d2716 1
d2808 4
a2811 1
	inferior_event_handler (INF_EXEC_COMPLETE, NULL);
d2821 2
a2822 1
     restore the prompt.  */
d2825 7
d5829 1
@


1.500
log
@2011-09-02  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* value.c (show_convenience): Catch errors thrown while printing
	each internal variable.
	* infrun.c (validate_siginfo_access): New function.
	(siginfo_value_read, siginfo_value_write): Call it.
@
text
@d58 1
d2818 1
a2818 1
  if (was_sync && !sync_execution)
@


1.499
log
@gdb/
	* breakpoint.c (bpstat_do_actions): New variable cleanup_if_error, call
	make_bpstat_clear_actions_cleanup and discard_cleanups for it.
	* defs.h (make_bpstat_clear_actions_cleanup): New declaration.
	* exceptions.c (throw_exception): Remove the bpstat_clear_actions call.
	* inf-loop.c (inferior_event_handler): New variable cleanup_if_error,
	call make_bpstat_clear_actions_cleanup and discard_cleanups for it.
	Call bpstat_clear_actions for failed fetch_inferior_event_wrapper.
	* infrun.c (fetch_inferior_event): Call
	make_bpstat_clear_actions_cleanup.
	* top.c (execute_command): New variable cleanup_if_error, call
	make_bpstat_clear_actions_cleanup and discard_cleanups for it.
	* utils.c (do_bpstat_clear_actions_cleanup)
	(make_bpstat_clear_actions_cleanup): New functions.

gdb/testsuite/
	* gdb.base/commands.exp (error_clears_commands_left): New function.
	(): Call it.
@
text
@d6387 19
d6424 2
d6445 2
@


1.498
log
@2011-08-04  Pedro Alves  <pedro@@codesourcery.com>

	* ui-out.h (uiout): Rename to ...
	(current_uiout): ... this.
	* ui-out.c (uiout): Rename to ...
	(current_uiout): ... this.
	* ada-lang.c (print_it_exception, print_one_exception)
	(print_mention_exception): Adjust.
	* breakpoint.c (watchpoint_check): Adjust.
	(print_breakpoint_location, print_one_breakpoint, breakpoint_1)
	(default_collect_info, watchpoints_info, print_one_catch_fork)
	(print_one_catch_vfork, print_one_catch_syscall)
	(print_one_catch_exec, mention, print_it_ranged_breakpoint)
	(print_one_ranged_breakpoint, print_mention_ranged_breakpoint)
	(print_it_watchpoint, print_mention_watchpoint)
	(print_it_masked_watchpoint, print_mention_masked_watchpoint)
	(print_it_exception_catchpoint, print_one_exception_catchpoint)
	(print_mention_exception_catchpoint, say_where, bkpt_print_it)
	(bkpt_print_mention, momentary_bkpt_print_it)
	(tracepoint_print_mention, update_static_tracepoint)
	(tracepoints_info, save_breakpoints): Adjust.
	* cli-out.c (field_separator): Adjust.
	* cp-abi.c (list_cp_abis, show_cp_abi_cmd): Adjust.
	* exceptions.c (catch_exceptions_with_msg, catch_errors): Adjust.
	* frame.c (get_current_frame): Adjust.
	* infcmd.c (run_command_1, print_return_value): Adjust.
	* inferior.c (inferior_command, info_inferiors_command): Adjust.
	* infrun.c (print_end_stepping_range_reason): Adjust.
	(print_signal_exited_reason, print_exited_reason): Adjust.
	(print_signal_received_reason, print_no_history_reason): Adjust.
	* interps.c (interp_set): Adjust.
	* osdata.c (info_osdata_command): Adjust.
	* progspace.c (maintenance_info_program_spaces_command): Adjust.
	* remote-fileio.c (remote_fileio_request): Adjust.
	* remote.c (show_remote_cmd): Adjust.
	* solib.c (info_sharedlibrary_command): Adjust.
	* source.c (print_source_lines_base): Adjust.
	* stack.c (print_stack_frame): Adjust.
	(do_gdb_disassembly, print_frame_info, print_frame): Adjust.
	* symfile-mem.c (add_vsyscall_page): Adjust.
	* symfile.c (load_progress, generic_load)
	(print_transfer_performance): Adjust.
	* thread.c (info_threads_command, restore_selected_frame)
	(thread_command): Adjust.
	* top.c (make_cleanup_restore_ui_file): Adjust.
	* tracepoint.c (tvariables_info_1, trace_status_mi, tfind_1)
	(print_one_static_tracepoint_marker): Adjust.
	* cli/cli-cmds.c (print_disassembly): Adjust.
	* cli/cli-decode.c (print_doc_line): Adjust.
	* cli/cli-interp.c (safe_execute_command): Adjust.
	* cli/cli-logging.c (set_logging_redirect, pop_output_files)
	(handle_redirections): Adjust.
	* cli/cli-script.c (show_user_1): Adjust.
	* cli/cli-setshow.c (do_setshow_command, cmd_show_list): Adjust.
	* mi/mi-cmd-break.c (breakpoint_notify): Adjust.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Adjust.
	* mi/mi-cmd-env.c (mi_cmd_env_pwd, mi_cmd_env_path)
	(mi_cmd_env_dir): Adjust.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(print_partial_file_name, mi_cmd_file_list_exec_source_files): Adjust.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_depth, mi_cmd_stack_list_args)
	(list_args_or_locals): Adjust.
	* mi/mi-cmd-var.c (print_varobj, mi_cmd_var_create)
	(mi_cmd_var_delete, mi_cmd_var_set_format, mi_cmd_var_set_frozen)
	(mi_cmd_var_show_format, mi_cmd_var_info_num_children)
	(mi_cmd_var_list_children, mi_cmd_var_info_type)
	(mi_cmd_var_info_path_expression, mi_cmd_var_info_expression)
	(mi_cmd_var_show_attributes, mi_cmd_var_evaluate_expression)
	(mi_cmd_var_assign, mi_cmd_var_update, varobj_update_one): Adjust.
	* mi/mi-interp.c (mi_on_normal_stop): Adjust.
	* mi/mi-main.c (mi_cmd_gdb_exit, mi_cmd_thread_select)
	(mi_cmd_thread_list_ids, mi_cmd_thread_info, print_one_inferior)
	(list_available_thread_groups, mi_cmd_list_thread_groups)
	(mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers)
	(mi_cmd_data_list_register_values, get_register)
	(mi_cmd_data_evaluate_expression, mi_cmd_data_read_memory)
	(mi_cmd_data_read_memory_bytes, mi_cmd_list_features)
	(mi_cmd_list_target_features, mi_cmd_add_inferior)
	(mi_execute_command, mi_load_progress): Adjust.
	* mi/mi-symbol-cmds.c (mi_cmd_symbol_list_lines): Adjust.
	* python/py-auto-load.c (print_script, info_auto_load_scripts):
	Adjust.
	* python/py-breakpoint.c (bppy_get_commands): Adjust.
	* tui/tui-interp.c (tui_command_loop): Adjust.
	* tui/tui-io.c (tui_setup_io, tui_initialize_io): Adjust.
@
text
@d2782 4
@


1.497
log
@2011-07-22  Kwok Cheung Yeung  <kcy@@codesourcery.com>

gdb/
	* defs.h: Add guard against inclusion in gdbserver.
	(struct ptid, ptid_t): Move to common/ptid.h.
	(xfree, xzalloc, xasprintf, xvasprintf, xstrprintf, xstrvprintf,
	xsnprintf, internal_error): Move to common/common-utils.h.
	(nomem): Delete.
	* gdb_assert.h: Move into common/ sub-directory.
	* gdb_locale.h: Ditto.
	* gdb_dirent.h: Ditto.
	* inferior.h (minus_one_ptid, null_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal, ptid_is_pid):
	Move into common/ptid.h.
	* xml-support.c (xml_escape_text): Move into common/xml-utils.c.
	(gdb_xml_create_parser_and_cleanup_1, xml_fetch_context_from_file):
	Change nomem to malloc_failure.
	* xml-support.h (xml_escape_text): Move into common/xml-utils.h.
	* utils.c (nomem): Rename to malloc_failure.
	(xmalloc, xzalloc, xrealloc, xcalloc, xfree, xstrprintf, xasprintf,
	xvasprintf, xstrvprintf, xsnprintf): Move to common/common-utils.c.
	(gdb_buildargv): Change nomem to malloc_failure.
	* infrun.c (null_ptid, minus_one_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal,
	ptid_is_pid): Move into common/ptid.c.
	(initialize_infrun): Delete initialization of null_ptid and
	minus_one_ptid.
	* linux-nat.c (linux_nat_xfer_osdata): Defer to
	linux_common_xfer_osdata.
	* Makefile.in (SFILES): Add common/common-utils.c, common/xml-utils.c,
	common/ptid.c and common/buffer.c.
	(HFILES_NO_SRCDIR): Add common/common-utils.h, common/xml-utils.h,
	common/ptid.h, common/buffer.h and common/linux-osdata.h.
	(COMMON_OBS): Add xml-utils.o, common-utils.o, buffer.o and ptid.o.
	(common-utils.o, xml-utils.o, ptid.o, buffer.o, linux-osdata.o): New
	rules.
	* common/gdb_assert.h: New.
	* common/gdb_dirent.h: New.
	* common/gdb_locale.h: New.
	* common/buffer.c: New.
	* common/buffer.h: New.
	* common/ptid.c: New.
	* common/ptid.h: New.
	* common/xml-utils.c: New.
	* common/xml-utils.h: New.
	* common/common-utils.c: New.
	* common/common-utils.h: New.
	* common/linux-osdata.c: New.
	* common/linux-osdata.h: New.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Add linux-osdata.o.
	* config/arm/linux.mh (NATDEPFILES): Ditto.
	* config/i386/linux.mh (NATDEPFILES): Ditto.
	* config/i386/linux64.mh (NATDEPFILES): Ditto.
	* config/ia64/linux.mh (NATDEPFILES): Ditto.
	* config/m32r/linux.mh (NATDEPFILES): Ditto.
	* config/m68k/linux.mh (NATDEPFILES): Ditto.
	* config/mips/linux.mh (NATDEPFILES): Ditto.
	* config/pa/linux.mh (NATDEPFILES): Ditto.
	* config/powerpc/linux.mh (NATDEPFILES): Ditto.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Ditto.
	* config/s390/s390.mh (NATDEPFILES): Ditto.
	* config/sparc/linux.mh (NATDEPFILES): Ditto.
	* config/sparc/linux64.mh (NATDEPFILES): Ditto.
	* config/xtensa/linux.mh (NATDEPFILES): Ditto.

gdbserver/
	* linux-low.c (compare_ints, unique, list_threads, show_process,
	linux_core_of_thread): Delete.
	(linux_target_ops): Change linux_core_of_thread to
	linux_common_core_of_thread.
	(linux_qxfer_osdata): Defer to linux_common_xfer_osdata.
	* utils.c (malloc_failure): Change type of argument.
	(xmalloc, xrealloc, xcalloc, xsnprintf): Delete.
	* Makefile.in (SFILES): Add common/common-utils.c, common/xml-utils.c,
	common/linux-osdata.c, common/ptid.c and common/buffer.c.
	(OBS): Add xml-utils.o, common-utils.o, ptid.o and buffer.o.
	(IPA_OBJS): Add common-utils-ipa.o.
	(ptid_h, linux_osdata_h): New macros.
	(server_h): Add common/common-utils.h, common/xml-utils.h,
	common/buffer.h, common/gdb_assert.h, common/gdb_locale.h and
	common/ptid.h.
	(common-utils-ipa.o, common-utils.o, xml-utils.o, linux-osdata.o,
	ptid.o, buffer.o): New rules.
	(linux-low.o): Add common/linux-osdata.h as a dependency.
	* configure.srv (srv_tgtobj): Add linux-osdata.o to Linux targets.
	* configure.ac: Add AC_HEADER_DIRENT check.
	* config.in: Regenerate.
	* configure: Regenerate.
	* remote-utils.c (xml_escape_text): Delete.
	(buffer_grow, buffer_free, buffer_init, buffer_finish,
	buffer_xml_printf): Move to common/buffer.c.
	* server.c (main): Remove call to initialize_inferiors.
	* server.h (struct ptid, ptid_t, minus_one_ptid, null_ptid,
	ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp, ptid_get_tid,
	ptid_equal, ptid_is_pid, initialize_inferiors, xml_escape_text,
	internal_error, gdb_assert, gdb_assert_fail): Delete.
	(struct buffer, buffer_grow, buffer_free, buffer_init, buffer_finish,
	buffer_xml_printf, buffer_grow_str, buffer_grow_str0): Move to
	common/buffer.h.
	* inferiors.c (null_ptid, minus_one_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal, ptid_is_pid,
	initialize_inferiors): Delete.
@
text
@d5617 2
a5618 2
      && ui_out_is_mi_like_p (uiout))
    ui_out_field_string (uiout, "reason",
d5627 2
d5654 1
d5691 2
d5730 1
a5730 1
  ui_out_text (uiout, "\nNo more reverse-execution history.\n");
@


1.496
log
@gdb/
	* infrun.c (struct execution_control_state): New member
	stop_func_filled_in.
	(clear_stop_func, fill_in_stop_func): New functions.
	(handle_inferior_event): Call clear_stop_func rather than
	manipulating the execution control state directly.
	Call fill_in_stop_func lazily as required rather than
	directly calling find_pc_partial_function in all cases.
@
text
@a6805 71
/* Oft used ptids */
ptid_t null_ptid;
ptid_t minus_one_ptid;

/* Create a ptid given the necessary PID, LWP, and TID components.  */

ptid_t
ptid_build (int pid, long lwp, long tid)
{
  ptid_t ptid;

  ptid.pid = pid;
  ptid.lwp = lwp;
  ptid.tid = tid;
  return ptid;
}

/* Create a ptid from just a pid.  */

ptid_t
pid_to_ptid (int pid)
{
  return ptid_build (pid, 0, 0);
}

/* Fetch the pid (process id) component from a ptid.  */

int
ptid_get_pid (ptid_t ptid)
{
  return ptid.pid;
}

/* Fetch the lwp (lightweight process) component from a ptid.  */

long
ptid_get_lwp (ptid_t ptid)
{
  return ptid.lwp;
}

/* Fetch the tid (thread id) component from a ptid.  */

long
ptid_get_tid (ptid_t ptid)
{
  return ptid.tid;
}

/* ptid_equal() is used to test equality of two ptids.  */

int
ptid_equal (ptid_t ptid1, ptid_t ptid2)
{
  return (ptid1.pid == ptid2.pid && ptid1.lwp == ptid2.lwp
	  && ptid1.tid == ptid2.tid);
}

/* Returns true if PTID represents a process.  */

int
ptid_is_pid (ptid_t ptid)
{
  if (ptid_equal (minus_one_ptid, ptid))
    return 0;
  if (ptid_equal (null_ptid, ptid))
    return 0;

  return (ptid_get_lwp (ptid) == 0 && ptid_get_tid (ptid) == 0);
}

a7194 2
  null_ptid = ptid_build (0, 0, 0);
  minus_one_ptid = ptid_build (-1, 0, 0);
@


1.495
log
@gdb/
	Code cleanup - constify struct lval_funcs.
	* dwarf2loc.c (pieced_value_funcs): Make it const.
	* infrun.c (siginfo_value_funcs): Likewise.
	* opencl-lang.c (opencl_value_funcs): Likewise.
	* valops.c (value_assign, value_ind): Make the funcs variable const.
	* value.c (struct value): Make location.computed.funcs target const.
	Rearrange the comments.
	(allocate_computed_value): Make the funcs parameter target const.
	(value_computed_funcs): Return the funcs target const.
	(value_free, value_copy, set_value_component_location): Make the funcs
	variable const.
	* value.h (allocate_computed_value): Make the funcs parameter target
	const.
	(value_computed_funcs): Return the funcs target const.
	* windows-tdep.c (tlb_value_funcs): Make it const.
@
text
@d2329 1
d3084 30
d3959 1
a3959 9
  ecs->stop_func_start = 0;
  ecs->stop_func_end = 0;
  ecs->stop_func_name = 0;
  /* Don't care about return value; stop_func_start and stop_func_name
     will both be 0 if it doesn't work.  */
  find_pc_partial_function (stop_pc, &ecs->stop_func_name,
			    &ecs->stop_func_start, &ecs->stop_func_end);
  ecs->stop_func_start
    += gdbarch_deprecated_function_start_offset (gdbarch);
d4403 1
d4595 1
d5156 2
d5237 2
@


1.494
log
@2011-06-23  Yao Qi  <yao@@codesourcery.com>

	* infrun.c (start_remote): Move call init_wait_for_inferior to ...
	* remote.c (remote_start_remote): ... here.
	* monitor.c (monitor_open): ... here.
@
text
@d6397 1
a6397 1
static struct lval_funcs siginfo_value_funcs =
@


1.493
log
@	gdb/
	* infrun.c (handle_inferior_event): Remove write-only local variable
	`sw_single_step_trap_p'.
@
text
@a2248 1
  init_wait_for_inferior ();
@


1.492
log
@2011-06-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* infcall.c (run_inferior_call): Don't mask async.  Instead force
	a synchronous wait, if the target can async.

	* target.h (struct target_ops): Delete to_async_mask.
	(target_async_mask): Delete.
	* target.c (update_current_target): Delete references to to_async_mask.
	* linux-nat.c (linux_nat_async_mask_value): Delete.
	(linux_nat_is_async_p, linux_nat_can_async_p): Remove references
	to linux_nat_async_mask_value.
	(linux_nat_async_mask): Delete.
	(linux_nat_async, linux_nat_close): Remove references to
	linux_nat_async_mask_value.
	* record.c (record_async_mask_value): Delete.
	(record_async): Remove references to record_async_mask_value.
	(record_async_mask): Delete.
	(record_can_async_p, record_is_async_p): Remove references to
	record_async_mask_value.
	(init_record_ops, init_record_core_ops): Remove references to
	record_async_mask.
	* remote.c (remote_async_mask_value): Delete.
	(init_remote_ops): Remove reference to remote_async_mask.
	(remote_can_async_p, remote_is_async_p): Remove references to
	remote_async_mask_value.
	(remote_async): Remove references to remote_async_mask_value.
	(remote_async_mask): Delete.

	* infrun.c (fetch_inferior_event): Don't claim registers changed
	if the current thread is already not executing.
@
text
@a3092 1
  int sw_single_step_trap_p = 0;
a3846 1
	  sw_single_step_trap_p = 1;
@


1.491
log
@gdb
	* python/py-inferior.c (python_inferior_exit): Use inferior's exit
	code fields.
	* python/py-exitedevent.c (create_exited_event_object): Change
	type of 'exit_code'.  Optionally add exit_code attribute.
	(emit_exited_event): Change type of 'exit_code'.
	* python/py-event.h (emit_exited_event): Update.
	* mi/mi-interp.c (mi_inferior_exit): Print exit code.
	* infrun.c (handle_inferior_event): Set exit code fields on
	inferior.
	* inferior.h (struct inferior) <has_exit_code, exit_code>: New
	fields.
	* inferior.c (exit_inferior_1): Initialize new fields.
gdb/doc
	* gdb.texinfo (GDB/MI Async Records): Document 'exit-code' field.
	(Events In Python): Note that exit_code is optional.
@
text
@d2742 10
a2751 1
  registers_changed ();
@


1.490
log
@2011-05-30  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* continuations.h (continuation_ftype): Add `err' parameter.
	Document parameters.
	(do_all_continuations, do_all_continuations_thread)
	(do_all_intermediate_continuations)
	(do_all_intermediate_continuations_thread)
	(do_all_inferior_continuations): Add `err' parameter.
	* continuations.c (do_my_continuations_1, do_my_continuations)
	(do_all_inferior_continuations, do_all_continuations_ptid)
	(do_all_continuations_thread_callback)
	(do_all_continuations_thread, do_all_continuations)
	(do_all_intermediate_continuations_thread_callback)
	(do_all_intermediate_continuations_thread)
	(do_all_intermediate_continuations): Add `err' parameter, and pass
	it down all the way to the continuations proper.
	* inf-loop.c (inferior_event_handler): If fetching an inferior
	event throws an error, don't pop the target, and still call the
	continuations, but with `err' set.  Adjust all other continuation
	calls.
	* breakpoint.c (until_break_command_continuation): Add `err'
	parameter.
	* infcmd.c (step_1_continuation): Add `err' parameter.  Don't
	issue another step if `err' is set.
	(struct until_next_continuation_args): New.
	(until_next_continuation): Add `err' parameter.  Adjust.
	(until_next_command): Adjust.
	(struct finish_command_continuation_args): Add `thread' field.
	(finish_command_continuation): Add `err' parameter.  Handle it.
	(finish_forward): Adjust.
	(attach_command_continuation): Add `err' parameter.  Handle it.
	* infrun.c (infrun_thread_stop_requested_callback): Adjust to
	cancel the continuations.
	* interps.c (interp_set): Adjust to cancel the continuations.
	* thread.c (clear_thread_inferior_resources): Adjust to cancel the
	continuations rather than discarding.
	(free_thread): Don't clear thread inferior resources here.
	(delete_thread_1): Do it here instead.  And do it before removing
	the thread from the threads list.  Tag the thread as exited before
	clearing thread inferior resources.
@
text
@d3311 5
@


1.489
log
@2011-05-27  Pedro Alves  <pedro@@codesourcery.com>

	* defs.h (struct continuation, continuation_ftype)
	(continuation_free_arg_ftype, add_continuation)
	(do_all_continuations, do_all_continuations_thread)
	(discard_all_continuations, discard_all_continuations_thread)
	(add_intermediate_continuation, do_all_intermediate_continuations)
	(do_all_intermediate_continuations_thread)
	(discard_all_intermediate_continuations)
	(discard_all_intermediate_continuations_thread)
	(add_inferior_continuation, do_all_inferior_continuations)
	(discard_all_inferior_continuations): Move to ...
	* continuations.h: ... this new file.
	* breakpoint.c, continuations.c, event-top.c, inf-loop.c,
	infcmd.c, inferior.c, infrun.c, interps.c: Include
	continuations.h.
@
text
@d2396 1
a2396 3
	  /* Finish off the continuations.  The continations
	     themselves are responsible for realising the thread
	     didn't finish what it was supposed to do.  */
d2398 2
a2399 2
	  do_all_intermediate_continuations_thread (tp);
	  do_all_continuations_thread (tp);
@


1.488
log
@2011-05-26  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* inferior.h (enum exec_direction_kind): Delete EXEC_ERROR.
	* infrun.c (show_exec_direction_func): Don't handle EXEC_ERROR.
	Internal error on invalid values.
	* reverse.c: Don't handle EXEC_ERROR.
	* mi/mi-main.c: Don't handle EXEC_ERROR.
@
text
@d57 1
@


1.487
log
@2011-05-26  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* record.c: Include event-loop.h, inf-loop.h.
	(record_beneath_to_async): New global.
	(tmp_to_async): New global.
	(record_async_inferior_event_token): New global.
	(record_open_1): Don't error out if async is enabled.
	(record_open): Handle to_async.  Create an async event source in
	the event loop.
	(record_close): Delete the async event source.
	(record_resumed): New global.
	(record_execution_dir): New global.
	(record_resume, record_core_resume): Set them.  Register the
	target on the event loop.
	(record_wait): Rename to ...
	(record_wait_1): ... this.  Add more debug output.  Handle
	TARGET_WNOHANG, and the target beneath returning
	TARGET_WAITKIND_IGNORE.
	(record_wait): Reimplement on top of record_wait_1.
	(record_async_mask_value): New global.
	(record_async, record_async_mask, record_can_async_p)
	(record_is_async_p, record_execution_direction): New functions.
	(init_record_ops, init_record_core_ops): Install new methods.
	* infrun.c (fetch_inferior_event): Temporarily switch the global
	execution direction to the direction the target was going.
	(execution_direction): Change type to int.
	* target.c (default_execution_direction): New function.
	(update_current_target): Inherit and de_fault
	to_execution_direction.
	* target.h (struct target_ops) <to_execution_direction>: New
	field.
	(target_execution_direction): New macro.
	* inferior.h (execution_direction): Change type to int.
@
text
@a6922 1
  case EXEC_ERROR:
d6924 3
a6926 4
    fprintf_filtered (out, _("Forward (target `%s' does not "
			     "support exec-direction).\n"),
		      target_shortname);
    break;
@


1.486
log
@2011-05-26  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* infcmd.c (finish_backward): Set a step-resume breakpoint at the
	function's entry point instead of a manually managed momentary
	breakpoint, and only ever issue one proceed call.
	* infrun.c (handle_inferior_event) <BPSTAT_WHAT_STEP_RESUME>: If
	doing a reverse-finish, switch to stepi mode, to do another step.
	(insert_step_resume_breakpoint_at_sal): Make public.
	(normal_stop): No need to save function value return registers if
	going reverse.
	* inferior.h (insert_step_resume_breakpoint_at_sal): Declare.

	gdb/testsuite/
	* gdb.reverse/finish-reverse-bkpt.exp: New test.
@
text
@d2745 3
d6884 1
a6884 1
enum exec_direction_kind execution_direction = EXEC_FORWARD;
@


1.485
log
@2011-05-26  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* breakpoint.h (enum bptype) <bp_hp_step_resume>: New.
	(enum bpstat_what_main_action): Move BPSTAT_WHAT_STEP_RESUME
	before BPSTAT_WHAT_STOP_SILENT.  Add BPSTAT_WHAT_HP_STEP_RESUME
	at the end.
	* breakpoint.c (update_breakpoints_after_exec): Also delete hp
	step-resume breakpoints.
	(print_it_typical): Handle bp_hp_step_resume.
	(bpstat_what): Ditto.
	(bptype_string): Ditto.
	(print_one_breakpoint_location): Ditto.
	(allocate_bp_location): Ditto.
	(mention): Ditto.
	(breakpoint_re_set_one): Ditto.
	* infrun.c (handle_inferior_event): Adjust.  Split
	BPSTAT_WHAT_STEP_RESUME handling in BPSTAT_WHAT_STEP_RESUME and
	BPSTAT_WHAT_HP_STEP_RESUME.
	(insert_step_resume_breakpoint_at_sal): Rename to ...
	(insert_step_resume_breakpoint_at_sal_1): ... this.  Add bptype
	parameter.  Handle it.
	(insert_step_resume_breakpoint_at_sal): Reimplement on top of
	insert_step_resume_breakpoint_at_sal_1.
	(insert_step_resume_breakpoint_at_frame): Rename to ...
	(insert_hp_step_resume_breakpoint_at_frame): ... this.  Adjust to
	set a high-priority step-resume breakpoint.
	(insert_step_resume_breakpoint_at_frame): Adjust comment.
	(insert_step_resume_breakpoint_at_caller): Ditto.

	gdb/testsuite/
	* gdb.reverse/next-reverse-bkpt-over-sr.exp: New test.
@
text
@a105 4
static void insert_step_resume_breakpoint_at_sal (struct gdbarch *,
						  struct symtab_and_line ,
						  struct frame_id);

d4353 14
d5248 1
a5248 1
static void
d5872 2
a5873 1
  if (inferior_thread ()->control.proceed_to_finish)
@


1.484
log
@2011-05-23  Pedro Alves  <pedro@@codesourcery.com>

	* infrun.c (user_visible_resume_ptid): Fix typos in describing
	comment.
@
text
@d102 1
a102 1
static void insert_step_resume_breakpoint_at_frame (struct frame_info *);
d1781 1
a1781 1
	  insert_step_resume_breakpoint_at_frame (get_current_frame ());
d4176 1
a4176 1
	  insert_step_resume_breakpoint_at_frame (frame);
d4206 1
a4206 1
	  insert_step_resume_breakpoint_at_frame (frame);
d4352 18
d4392 1
a4392 1
      case BPSTAT_WHAT_STEP_RESUME:
d4394 1
a4394 1
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_STEP_RESUME\n");
a4406 11
	if (stop_pc == ecs->stop_func_start
	    && execution_direction == EXEC_REVERSE)
	  {
	    /* We are stepping over a function call in reverse, and
	       just hit the step-resume breakpoint at the start
	       address of the function.  Go back to single-stepping,
	       which should take us back to the function call.  */
	    ecs->event_thread->stepping_over_breakpoint = 1;
	    keep_going (ecs);
	    return;
	  }
d5218 4
a5221 3
insert_step_resume_breakpoint_at_sal (struct gdbarch *gdbarch,
				      struct symtab_and_line sr_sal,
				      struct frame_id sr_id)
d5227 1
d5235 11
a5245 1
    = set_momentary_breakpoint (gdbarch, sr_sal, sr_id, bp_step_resume);
d5248 2
a5249 2
/* Insert a "step-resume breakpoint" at RETURN_FRAME.pc.  This is used
   to skip a potential signal handler.
d5256 1
a5256 1
insert_step_resume_breakpoint_at_frame (struct frame_info *return_frame)
d5269 3
a5271 2
  insert_step_resume_breakpoint_at_sal (gdbarch, sr_sal,
					get_stack_frame_id (return_frame));
d5274 3
a5276 4
/* Similar to insert_step_resume_breakpoint_at_frame, except
   but a breakpoint at the previous frame's PC.  This is used to
   skip a function after stepping into it (for "next" or if the called
   function has no debugging information).
d5284 1
a5284 1
   insert_step_resume_breakpoint_at_frame in order to avoid
@


1.483
log
@2011-05-20  Pedro Alves  <pedro@@codesourcery.com>

	* infrun.c (proceed): Set previous_inferior_ptid here.
	(init_wait_for_inferior): Initialize previous_inferior_ptid from
	inferior_ptid, not null_ptid.
	(wait_for_inferior): Don't initialize previous_inferior_ptid here.
	(fetch_inferior_event): Nor here.
@
text
@d1607 3
a1609 3
   breakpoint that needs stepping-off, but that should be visible to
   the user/frontend, and neither should the frontend/user be allowed
   to proceed any of the threads that happen to be stopped at for
@


1.482
log
@2011-05-20  Pedro Alves  <pedro@@codesourcery.com>

	* infrun.c (proceed): Switch the inferior event loop to
	INF_EXEC_COMPLETE if the target refused to resume from a
	vfork/fork.
@
text
@d2074 3
d2296 1
a2296 1
  previous_inferior_ptid = null_ptid;
a2659 3
  /* We'll update this if & when we switch to a new thread.  */
  previous_inferior_ptid = inferior_ptid;

a2722 3
  /* We'll update this if & when we switch to a new thread.  */
  previous_inferior_ptid = inferior_ptid;

@


1.481
log
@2011-05-20  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* infcmd.c: Include "inf-loop.h".
	(step_once): When stepping into an inline subroutine, pretend the
	target has run.  If the target can async, switch the inferior
	event loop to INF_EXEC_COMPLETE.
	* inferior.h (user_visible_resume_ptid): Declare.
	* infrun.c (user_visible_resume_ptid): New function, factored out
	from `resume'.
	(resume): Use it.
	* mi/mi-main.c (mi_execute_async_cli_command): Remove assertion
	that the current thread is running.  Merge async and sync
	branches.
@
text
@d2069 2
@


1.480
log
@2011-05-18  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* infrun.c (resume): Mention which is the current thread, and its
	current PC in debug output.
	(prepare_to_proceed): Mention the thread switching in debug
	output.
@
text
@d1604 39
d1804 1
a1804 9

      /* By default, resume all threads of all processes.  */
      resume_ptid = RESUME_ALL;

      /* Maybe resume only all threads of the current process.  */
      if (!sched_multi && target_supports_multi_process ())
	{
	  resume_ptid = pid_to_ptid (ptid_get_pid (inferior_ptid));
	}
a1837 13
      else if (non_stop)
	{
	  /* With non-stop mode on, threads are always handled
	     individually.  */
	  resume_ptid = inferior_ptid;
	}
      else if ((scheduler_mode == schedlock_on)
	       || (scheduler_mode == schedlock_step
		   && (step || singlestep_breakpoints_inserted_p)))
	{
	  /* User-settable 'scheduler' mode requires solo thread resume.  */
	  resume_ptid = inferior_ptid;
	}
@


1.479
log
@2011-05-17  Tomas Martinec  <fyzmat@@gmail.com>

	gdb/
	* infrun.c (handle_inferior_event) <handling deferred step>: Clear
	trap_expected.
@
text
@d1647 4
a1650 2
			"trap_expected=%d\n",
 			step, sig, tp->control.trap_expected);
d2006 6
@


1.478
log
@2011-05-09  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.h (wait_for_inferior): Remove `thread_exec_as_sigtrap'
	parameter.
	* infrun.c (proceed, start_remote): Adjust.
	(wait_for_inferior): Remove `thread_exec_as_sigtrap' parameter,
	and adjust to not handle it.
	* solib-irix.c (irix_solib_create_inferior_hook): Adjust.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Adjust.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Adjust.
	* windows-nat.c (do_initial_windows_stuff): Adjust.
	* infcmd.c (attach_command): Adjust.
	(notice_new_inferior): Adjust.
@
text
@d3649 2
@


1.477
log
@	gdb/
	* infrun.c (proceed): Revert previous change.
	(resume): Instead, handle the case of signal delivery while stepping
	off a breakpoint location here, and only if software single-stepping
	is used.  Handle nested signals.

	gdb/testsuite/
	* gdb.base/signest.exp: New file.
	* gdb.base/signest.c: Likewise.
@
text
@d2208 1
a2208 1
      wait_for_inferior (0);
d2239 1
a2239 1
  wait_for_inferior (0);
a2606 5
   If TREAT_EXEC_AS_SIGTRAP is non-zero, then handle EXEC signals
   as if they were SIGTRAP signals.  This can be useful during
   the startup sequence on some targets such as HP/UX, where
   we receive an EXEC event instead of the expected SIGTRAP.

d2613 1
a2613 1
wait_for_inferior (int treat_exec_as_sigtrap)
d2621 1
a2621 2
      (gdb_stdlog, "infrun: wait_for_inferior (treat_exec_as_sigtrap=%d)\n",
       treat_exec_as_sigtrap);
a2652 7
      if (treat_exec_as_sigtrap && ecs->ws.kind == TARGET_WAITKIND_EXECD)
        {
          xfree (ecs->ws.value.execd_pathname);
          ecs->ws.kind = TARGET_WAITKIND_STOPPED;
          ecs->ws.value.sig = TARGET_SIGNAL_TRAP;
        }

@


1.476
log
@ChangeLog:

	* infrun.c (proceed): Do not single-step into signal delivery
	when stepping off a breakpoint location.
	(insert_step_resume_breakpoint_at_frame): Move prototype earlier.
	(insert_step_resume_breakpoint_at_caller): Likewise.
	(insert_step_resume_breakpoint_at_sal): Likewise.
	(insert_longjmp_resume_breakpoint): Likewise.

testsuite/ChangeLog:

	* gdb.base/annota1.exp: Accept breakpoints-invalid annotation
	while delivering signal.
@
text
@d1706 45
d2112 18
a2198 36
  /* Stepping over a breakpoint while at the same time delivering a signal
     has a problem: we cannot use displaced stepping, but we also cannot
     use software single-stepping, because we do not know where execution
     will continue if a signal handler is installed.

     On the other hand, if there is a signal handler we'd have to step
     over it anyway.  So what we do instead is to install a step-resume
     handler at the current address right away, deliver the signal without
     stepping, and once we arrive back at the step-resume breakpoint, step
     once more over the original breakpoint we wanted to step over.  */
  if (oneproc && tp->suspend.stop_signal != TARGET_SIGNAL_0
      && execution_direction != EXEC_REVERSE)
    {
      insert_step_resume_breakpoint_at_frame (get_current_frame ());
      tp->step_after_step_resume_breakpoint = 1;
      oneproc = 0;
    }

  if (oneproc)
    {
      tp->control.trap_expected = 1;
      /* If displaced stepping is enabled, we can step over the
	 breakpoint without hitting it, so leave all breakpoints
	 inserted.  Otherwise we need to disable all breakpoints, step
	 one instruction, and then re-add them when that step is
	 finished.  */
      if (!use_displaced_stepping (gdbarch))
	remove_breakpoints ();
    }

  /* We can insert breakpoints if we're not trying to step over one,
     or if we are stepping over one but we're using displaced stepping
     to do so.  */
  if (! tp->control.trap_expected || use_displaced_stepping (gdbarch))
    insert_breakpoints ();

@


1.475
log
@	* target.h (struct target_ops): Remove to_notice_signals;
	add to_pass_signals.
	(target_notice_signals): Remove.
	(target_pass_signals): Add prototype.
	* target.c (update_current_target): Remove to_notice_signals;
	mention to_pass_signals.
	(target_pass_signals): New function.
	(debug_to_notice_signals): Remove.
	(setup_target_debug): Do not install debug_to_notice_signals.

	* infrun.c (signal_pass): New global.
	(resume): Call target_pass_signals.
	(handle_inferior_event): Report all signals while stepping over
	non-steppable watchpoint.  Reset trap_expected to ensure breakpoints
	are re-inserted when stepping over a signal handler.
	(signal_cache_update): New function.
	(signal_stop_update): Call it.
	(signal_print_update): Likewise.
	(signal_pass_update): Likewise.
	(handle_command): Call signal_cache_update and target_pass_signals
	instead of target_notice_signals.
	(_initialize_infrun): Initialize signal_pass.

	* linux-nat.c (pass_mask): New global.
	(linux_nat_pass_signals): New function.
	(linux_nat_create_inferior): Report all signals initially.
	(linux_nat_attach): Likewise.
	(linux_nat_resume): Use pass_mask to decide whether to directly
	handle an inferior signal.
	(linux_nat_wait_1): Likewise.
	(linux_nat_add_target): Install to_pass_signals callback.

	* nto-procfs.c (notice_signals): Remove.
	(procfs_resume): Do not call notice_signals.
	(procfs_notice_signals): Remove.
	(procfs_pass_signals): New function.
	(init_procfs_ops): Install to_pass_signals callback instead of
	to_notice_signals callback.
	(_initialize_procfs): Report all signals initially.

	* procfs.c (procfs_notice_signals): Remove.
	(procfs_pass_signals): New function.
	(procfs_target): Install to_pass_signals callback instead of
	to_notice_signals callback.
	(register_gdb_signals): Remove.
	(procfs_debug_inferior): Report all signals initially.
	(procfs_init_inferior): Remove redundant register_gdb_signals call.

	* remote.c (remote_pass_signals): Add numsigs and pass_signals
	parameters; use them instead of calling signal_..._state routines.
	(remote_notice_signals): Remove.
	(remote_start_remote): Report all signals initially.
	(remote_resume): Do not call remote_pass_signals.
	(_initialize_remote): Install to_pass_signals callback instead of
	to_notice_signals callback.
@
text
@d102 10
a2066 18
  if (oneproc)
    {
      tp->control.trap_expected = 1;
      /* If displaced stepping is enabled, we can step over the
	 breakpoint without hitting it, so leave all breakpoints
	 inserted.  Otherwise we need to disable all breakpoints, step
	 one instruction, and then re-add them when that step is
	 finished.  */
      if (!use_displaced_stepping (gdbarch))
	remove_breakpoints ();
    }

  /* We can insert breakpoints if we're not trying to step over one,
     or if we are stepping over one but we're using displaced stepping
     to do so.  */
  if (! tp->control.trap_expected || use_displaced_stepping (gdbarch))
    insert_breakpoints ();

d2136 36
a2287 6
static void insert_step_resume_breakpoint_at_frame (struct frame_info *);
static void insert_step_resume_breakpoint_at_caller (struct frame_info *);
static void insert_step_resume_breakpoint_at_sal (struct gdbarch *,
						  struct symtab_and_line ,
						  struct frame_id);
static void insert_longjmp_resume_breakpoint (struct gdbarch *, CORE_ADDR);
@


1.474
log
@2011-04-20  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* regcache.c (get_thread_arch_regcache): If creating a regcache for
	null_ptid, assume and allow a NULL address space, instead of
	asking the target for the ptid's address space.
	* infrun.c (ptid_is_pid): Remove assertion.

	gdb/testsuite/
	* gdb.base/maint.exp: Test that "maint print registers" works
	without a running program.
@
text
@d279 5
d1795 12
d3838 6
a3843 1
	remove_breakpoints ();
d4115 2
d4144 2
d5882 16
d5904 1
d5914 1
d5924 1
d6116 2
a6117 1
	target_notice_signals (inferior_ptid);
d6969 2
d7014 3
@


1.473
log
@gdb
	* windows-tdep.c (windows_xfer_shared_library):
	* windows-nat.c (get_module_name, windows_make_so):
	* v850-tdep.c (v850_handle_pushm):
	* utils.c (null_cleanup, gdb_realpath):
	* ui-out.c (get_next_header):
	* tracepoint.c (clear_traceframe_info):
	* symtab.c (lookup_symtab):
	* serial.h (struct serial_ops):
	* mipsread.c (read_alphacoff_dynamic_symtab):
	* infcmd.c (print_return_value):
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address):
	* f-exp.y (parse_number):
	* exceptions.c (catch_exceptions):
	* dummy-frame.c (dummy_frame_this_id):
	* defs.h (struct cleanup):
	* breakpoint.c (disable_breakpoints_in_unloaded_shlib):
	* arm-tdep.c (arm_push_dummy_call):
	* amd64-tdep.h (amd64_collect_xsave):
	* amd64-tdep.c (amd64_collect_xsave):
	* alpha-tdep.c (alpha_heuristic_frame_unwind_cache):
	* README (typing): Remove duplicate words.
	* cli/cli-decode.c (lookup_cmd_composition): Add comma.
	* infrun.c (siginfo_value_read): Fix typo.
	* solib-frv.c (frv_fdpic_find_global_pointer): Likewise.
	* top.c (source_line_number): Add comma.
gdb/doc
	* gdbint.texinfo (Register Information Functions): Remove
	duplicate "the".
	* gdb.texinfo (Emacs): Remove duplicate "to".
	(GDB/MI Variable Objects): Remove duplicate "the".
	(General Query Packets): Likewise.
gdb/testsuite
	* gdb.mi/mi-nsmoribund.exp:
	* gdb.hp/gdb.objdbg/objdbg01.exp:
	* gdb.base/structs.exp (test_struct_returns):
	* gdb.base/call-sc.exp (test_scalar_returns):
	* gdb.base/bigcore.exp: Remove duplicate words.
gdb/gdbserver
	* win32-low.c (handle_load_dll): Remove duplicate "the".
@
text
@a6698 5
  /* Since both parameters have the same type, prevent easy mistakes
     from happening.  */
  gdb_assert (!ptid_equal (ptid, minus_one_ptid)
	      && !ptid_equal (ptid, null_ptid));

@


1.472
log
@gdb
	* infrun.c (print_exited_reason): Include inferior id and pid in
	message.
gdb/testsuite
	* lib/opencl.exp (skip_opencl_tests): Update for exit message
	change.
	* lib/mi-support.exp (mi_gdb_test): Update for exit message
	change.
	* lib/gdb.exp (gdb_test_multiple): Update comment.  Update for
	exit message change.
	(skip_altivec_tests): Update for exit message change.
	(skip_vsx_tests): Likewise.
	(gdb_continue_to_end): Likewise.  Add 'command' argument.
	* lib/cell.exp (skip_cell_tests): Update for exit message change.
	* gdb.threads/tls.exp: Update for exit message change.
	* gdb.threads/thread-unwindonsignal.exp: Use
	gdb_continue_to_end.
	* gdb.threads/step.exp (step_it): Update for exit message change.
	(continue_all): Likewise.
	* gdb.threads/print-threads.exp (test_all_threads): Update for
	exit message change.
	* gdb.threads/interrupted-hand-call.exp: Use
	gdb_continue_to_end.
	* gdb.threads/execl.exp: Use gdb_continue_to_end.
	* gdb.python/py-prettyprint.exp (run_lang_tests): Use
	gdb_continue_to_end.
	* gdb.hp/gdb.objdbg/objdbg02.exp: Use gdb_continue_to_end.
	* gdb.hp/gdb.objdbg/objdbg01.exp: Use gdb_continue_to_end.
	* gdb.hp/gdb.defects/solib-d.exp: Update for exit message change.
	* gdb.cp/method.exp: Update for exit message change.
	* gdb.cp/mb-templates.exp: Update for exit message change.
	* gdb.cp/mb-inline.exp: Use gdb_continue_to_end.
	* gdb.cp/annota3.exp: Update for exit message change.
	* gdb.cp/annota2.exp: Update for exit message change.
	* gdb.cell/fork.exp: Use gdb_continue_to_end.
	* gdb.base/term.exp: Update for exit message change.
	* gdb.base/step-test.exp (test_i): Update for exit message change.
	* gdb.base/sigstep.exp (advance): Update for exit message change.
	(advancei): Likewise.
	* gdb.base/siginfo.exp: Update for exit message change.
	* gdb.base/shlib-call.exp: Use gdb_continue_to_end.
	* gdb.base/reread.exp: Use gdb_continue_to_end.
	* gdb.base/langs.exp: Use gdb_continue_to_end.
	* gdb.base/interrupt.exp: Update for exit message change.
	* gdb.base/gdb1555.exp: Update for exit message change.
	* gdb.base/exe-lock.exp: Use gdb_continue_to_end.
	* gdb.base/ending-run.exp: Update for exit message change.
	* gdb.base/chng-syms.exp: Update for exit message change.
	* gdb.base/checkpoint.exp: Update for exit message change.
	* gdb.base/catch-syscall.exp (check_for_program_end): Use
	gdb_continue_to_end.
	(test_catch_syscall_with_wrong_args): Likewise.
	* gdb.base/call-signal-resume.exp: Use gdb_continue_to_end.
	* gdb.base/break-interp.exp (test_ld): Update for exit message
	change.
	* gdb.base/bang.exp: Update for exit message change.
	* gdb.base/attach.exp (do_attach_tests): Use gdb_continue_to_end.
	(do_call_attach_tests): Likewise.
	* gdb.base/a2-run.exp: Update for exit message change.
	* gdb.arch/ppc-dfp.exp: Update for exit message change.
	* gdb.ada/tasks.exp: Use gdb_continue_to_end.
	* gdb.ada/catch_ex.exp: Use gdb_continue_to_end.
@
text
@d6199 1
a6199 1
   fetch the data.  The type can change depending on gdbarch, so it it
@


1.472.2.1
log
@2011-04-20  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* regcache.c (get_thread_arch_regcache): If creating a regcache for
	null_ptid, assume and allow a NULL address space, instead of
	asking the target for the ptid's address space.
	* infrun.c (ptid_is_pid): Remove assertion.

	gdb/testsuite/
	* gdb.base/maint.exp: Test that "maint print registers" works
	without a running program.
@
text
@d6699 5
@


1.472.2.2
log
@gdb
	* python/py-inferior.c (python_inferior_exit): Use inferior's exit
	code fields.
	* python/py-exitedevent.c (create_exited_event_object): Change
	type of 'exit_code'.  Optionally add exit_code attribute.
	(emit_exited_event): Change type of 'exit_code'.
	* python/py-event.h (emit_exited_event): Update.
	* mi/mi-interp.c (mi_inferior_exit): Print exit code.
	* infrun.c (handle_inferior_event): Set exit code fields on
	inferior.
	* inferior.h (struct inferior) <has_exit_code, exit_code>: New
	fields.
	* inferior.c (exit_inferior_1): Initialize new fields.
gdb/doc
	* gdb.texinfo (GDB/MI Async Records): Document 'exit-code' field.
	(Events In Python): Note that exit_code is optional.
@
text
@a3234 5

      /* Also record this in the inferior itself.  */
      current_inferior ()->has_exit_code = 1;
      current_inferior ()->exit_code = (LONGEST) ecs->ws.value.integer;

@


1.471
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (handle_inferior_event): Remove unused function call.
@
text
@d5490 3
d5499 5
a5503 1
      ui_out_text (uiout, "\nProgram exited with code ");
d5505 1
a5505 1
      ui_out_text (uiout, ".\n");
d5512 5
a5516 1
      ui_out_text (uiout, "\nProgram exited normally.\n");
@


1.470
log
@2011-02-16  Yao Qi  <yao@@qiyaows>

	* infrun.c (get_displaced_step_closure_by_addr): New.
	* inferior.h: Declare it.
	* arm-tdep.c: (arm_pc_is_thumb): Call
	get_displaced_step_closure_by_addr.  Adjust MEMADDR if it
	returns non-NULL.
@
text
@a4682 1
	tmp_sal.pspace = get_frame_program_space (frame);
@


1.469
log
@	gdb/
	* target.c (target_read_live_memory): New function.
	(memory_xfer_live_readonly_partial): New.
	(memory_xfer_partial): If reading from a traceframe, fallback to
	reading unavailable read-only memory from read-only regions of
	live target memory.
	* tracepoint.c (disconnect_tracing): Adjust.
	(set_current_traceframe): New, factored out from
	set_traceframe_number.
	(set_traceframe_number): Reimplement to only change the traceframe
	number on the GDB side.
	(do_restore_current_traceframe_cleanup): Adjust.
	(make_cleanup_restore_traceframe_number): New.
	(cur_traceframe_number): New global.
	(tfile_open): Set cur_traceframe_number to no traceframe.
	(set_tfile_traceframe): New function.
	(tfile_trace_find): If looking up a traceframe using any method
	other than by number, make sure the current tfile traceframe
	matches gdb's current traceframe.  Update the current tfile
	traceframe if the lookup succeeded.
	(tfile_fetch_registers, tfile_xfer_partial)
	(tfile_get_trace_state_variable_value): Make sure the remote
	traceframe matches gdb's current traceframe.
	* remote.c (remote_traceframe_number): New global.
	(remote_open_1): Set it to -1.
	(set_remote_traceframe): New function.
	(remote_fetch_registers, remote_store_registers)
	(remote_xfer_memory, remote_xfer_partial)
	(remote_get_trace_state_variable_value): Make sure the remote
	traceframe matches gdb's current traceframe.
	(remote_trace_find): If looking up a traceframe using any method
	other than by number, make sure the current remote traceframe
	matches gdb's current traceframe.  Update the current remote
	traceframe if the lookup succeeded.
	* infrun.c (fetch_inferior_event): Adjust.
	* tracepoint.h (set_current_traceframe): Declare.
	(get_traceframe_number, set_traceframe_number): Add describing
	comments.
@
text
@d1081 18
@


1.468
log
@	* infrun.c (proceed): Move switching out and in of tfind mode from
	here ...
	(fetch_inferior_event): ... to here.
@
text
@d2634 1
a2634 1
      set_traceframe_number (-1);
@


1.467
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* h8300-tdep.c: Comment cleanup, mostly periods and spaces.
	* hppa-hpux-tdep.c: Ditto.
	* hppa-linux-nat.c: Ditto.
	* hppa-linux-tdep.c: Ditto.
	* hppanbsd-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* hppa-tdep.h: Ditto.
	* hpux-thread.c: Ditto.
	* i386-cygwin-tdep.c: Ditto.
	* i386-darwin-nat.c: Ditto.
	* i386gnu-nat.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* i386-linux-tdep.c: Ditto.
	* i386-nat.c: Ditto.
	* i386-nat.h: Ditto.
	* i386nbsd-tdep.c: Ditto.
	* i386-sol2-nat.c: Ditto.
	* i386-stub.c: Ditto.
	* i386-tdep.c: Ditto.
	* i386-tdep.h: Ditto.
	* i387-tdep.c: Ditto.
	* ia64-linux-nat.c: Ditto.
	* ia64-linux-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* infcall.c: Ditto.
	* infcall.h: Ditto.
	* infcmd.c: Ditto.
	* inferior.c: Ditto.
	* inferior.h: Ditto.
	* infloop.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* interps.c: Ditto.
	* interps.h: Ditto.
	* iq2000-tdep.c: Ditto.
	* irix5-nat.c: Ditto.
	* jit.c: Ditto.
	* jit.h: Ditto.
	* jv-exp.y: Ditto.
	* jv-lang.c: Ditto.
	* jv-lang.h: Ditto.
	* jv-typeprint.c: Ditto.
	* jv-valprint.c: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* linespec.c: Ditto.
	* linux-fork.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-thread-db.c: Ditto.
	* lm32-tdep.c: Ditto.
@
text
@a1996 10
  /* We're handling a live event, so make sure we're doing live
     debugging.  If we're looking at traceframes while the target is
     running, we're going to need to get back to that mode after
     handling the event.  */
  if (non_stop)
    {
      make_cleanup_restore_current_traceframe ();
      set_traceframe_number (-1);
    }

d2627 10
@


1.466
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ax-gdb.c: Adjust some long output strings.
	* breakpoint.c: Ditto.
	* charset.c: Ditto.
	* cp-abi.c: Ditto.
	* infcall.c: Ditto.
	* infrun.c: Ditto.
	* linux-nat.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
@
text
@d113 1
a113 1
/* In asynchronous mode, but simulating synchronous execution. */
d295 1
a295 1
/* Value to pass to target_resume() to cause all threads to resume */
d476 1
a476 1
	    /* If we followed the child, switch to it... */
d609 1
a609 1
	  /* follow-fork child, detach-on-fork on */
d704 1
a704 1
	     inferior. */
d753 1
a753 1
/* EXECD_PATHNAME is assumed to be non-NULL. */
d780 1
a780 1
     we now have a new a.out, those shadow contents aren't valid. */
d787 1
a787 1
     statement through an exec(). */
d801 1
a801 1
  /* What is this a.out's name? */
d807 1
a807 1
     inferior has essentially been killed & reborn. */
d852 1
a852 1
  /* That a.out is now the one to use. */
d877 1
a877 1
     to symbol_file_command...) */
d883 1
a883 1
     matically get reset there in the new process.) */
d906 1
a906 1
   has switched to another thread and issued 'step'. We need to step over
d1563 1
a1563 1
	 `wait_for_inferior' */
d1737 1
a1737 1
	  /* User-settable 'scheduler' mode requires solo thread resume. */
d1859 1
a1859 1
   This should be suitable for any targets that support threads. */
d1916 1
a1916 1
	     hitting it straight away. */
d2024 1
a2024 1
	 the old thread. */
d2125 1
a2125 1
     does not support asynchronous execution. */
d2145 1
a2145 1
  /* Always go on waiting for the target, regardless of the mode. */
d2151 1
a2151 1
     timeout. */
d2158 1
a2158 1
     for an async run. */
d2397 1
a2397 1
/* A cleanup wrapper. */
d2486 1
a2486 1
	 as part of their normal status mechanism. */
d2572 1
a2572 1
	 status mechanism. */
d2614 1
a2614 1
/* Asynchronous version of wait_for_inferior. It is called by the
d2616 3
a2618 3
   descriptor corresponding to the target. It can be called more than
   once to complete a single execution command. In such cases we need
   to keep the state in a global variable ECSS. If it is the last time
d2621 1
a2621 1
   necessary cleanups. */
d2648 1
a2648 1
     status mechanism. */
d3024 1
a3024 1
  /* Cache the last pid/waitstatus. */
d3031 1
a3031 1
  /* If it's a new process, add it to the thread database */
d3210 1
a3210 1
      target_terminal_ours ();	/* Must do this before mourn anyway */
d3233 1
a3233 1
      target_terminal_ours ();	/* Must do this before mourn anyway */
d3239 1
a3239 1
         may be needed. */
d3249 1
a3249 1
         the above cases end in a continue or goto. */
d3284 1
a3284 1
	  /* Pull the single step breakpoints out of the target. */
d3421 1
a3421 1
      /* Getting the current syscall number */
d3604 1
a3604 1
         for a potential single step breakpoint. Otherwise, GDB will
d3697 1
a3697 1
	     Just continue. */
d3701 1
a3701 1
	      /* Pull the single step breakpoints out of the target. */
d3718 1
a3718 1
	     then either :-) or execs. */
d3764 1
a3764 1
      /* Pull the single step breakpoints out of the target. */
d3845 1
a3845 1
	 times before it's been fully executing. E.g., architectures
d4000 1
a4000 1
     (unexpected) signal. */
d4382 1
a4382 1
      /* Have we reached our destination?  If not, keep going. */
d4396 1
a4396 1
         caused us to begin stepping. */
d4760 1
a4760 1
	  /* And put the step-breakpoint there and go until there. */
d5310 1
a5310 1
/* (Used to be the keep_going: label in the old wait_for_inferior) */
d5393 1
a5393 1
         equivalent of a SIGNAL_TRAP to the program being debugged. */
d5495 1
a5495 1
   tells us to print about it. */
d5645 1
a5645 1
     or if the program has exited. */
d5655 1
a5655 1
         what to print, based on the event(s) that just occurred. */
d5690 2
a5691 2
		source_flag = SRC_LINE;		/* finished step, just
						   print source line */
d5693 2
a5694 2
		source_flag = SRC_AND_LOC;	/* print location and
						   source line */
d5697 2
a5698 2
	      source_flag = SRC_AND_LOC;	/* print location and
						   source line */
d5715 1
a5715 1
	     SRC_AND_LOC: Print location and source line */
d5898 1
a5898 1
  /* Allocate and zero an array of flags for which signals to handle. */
d5904 1
a5904 1
  /* Break the command line up into args. */
d5912 1
a5912 1
     specified.  Signal ranges can be specified as <LOW>-<HIGH>. */
d5926 1
a5926 1
	     debugger.  Silently skip those. */
d5982 1
a5982 1
	      /* Bet he didn't figure we'd think of this case... */
d6003 1
a6003 1
         which signals to apply actions to. */
d6069 1
a6069 1
  /* Break the command line up into args. */
d6518 1
a6518 1
  /* See save_infcall_control_state for info on stop_bpstat. */
@


1.465
log
@Do not stop on SIGPRIO signals by default

This signal does not indicate an error condition, so the default
behavior when receiving this signal should be to resume execution
silently.

gdb/ChangeLog:

        Do not stop on SIGPRIO signals by default
        * infrun.c (_initialize_infrun): Unset signal_stop and
        signal_print for TARGET_SIGNAL_PRIO.
@
text
@d1626 4
a1629 5
	error (_("The program is stopped at a permanent "
		 "breakpoint, but GDB does not know\n"
		 "how to step past a permanent breakpoint "
		 "on this architecture.  Try using\na command "
		 "like `return' or `jump' to continue execution."));
@


1.464
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d6930 2
@


1.463
log
@run copyright.sh for 2011.
@
text
@d360 3
a362 2
  fprintf_filtered (file, _("\
Debugger response to a program call of fork or vfork is \"%s\".\n"),
d502 2
a503 2
		    warning (_("\
Not resuming: switched threads before following fork child.\n"));
d640 2
a641 1
				  "Detaching vfork parent process %d after child exec.\n",
d645 2
a646 1
				  "Detaching vfork parent process %d after child exit.\n",
d723 2
a724 1
	    fprintf_unfiltered (gdb_stdlog, "infrun: resuming vfork parent process %d\n",
d1142 3
a1144 3
    fprintf_filtered (file, _("\
Debugger's willingness to use displaced stepping to step over \
breakpoints is %s (currently %s).\n"),
d1147 3
a1149 3
    fprintf_filtered (file, _("\
Debugger's willingness to use displaced stepping to step over \
breakpoints is %s.\n"), value);
d1326 2
a1327 1
write_memory_ptid (ptid_t ptid, CORE_ADDR memaddr, const gdb_byte *myaddr, int len)
d1458 2
a1459 1
	    fprintf_unfiltered (gdb_stdlog, "breakpoint is gone %s: step(%d)\n",
d1525 3
a1527 2
  fprintf_filtered (file, _("\
Mode for locking scheduler during execution is \"%s\".\n"),
d1626 5
a1630 4
	error (_("\
The program is stopped at a permanent breakpoint, but GDB does not know\n\
how to step past a permanent breakpoint on this architecture.  Try using\n\
a command like `return' or `jump' to continue execution."));
d2236 1
a2236 1
static void insert_step_resume_breakpoint_at_frame (struct frame_info *step_frame);
d2238 3
a2240 3
static void insert_step_resume_breakpoint_at_sal (struct gdbarch *gdbarch,
						  struct symtab_and_line sr_sal,
						  struct frame_id sr_id);
d2502 2
a2503 1
      old_chain_2 = make_cleanup (finish_thread_state_cleanup, &minus_one_ptid);
d2906 2
a2907 2
  error (_("\
Cannot execute this command while the selected thread is running."));
d3314 2
a3315 1
	  int follow_child = (follow_fork_mode_string == follow_fork_mode_child);
d3359 2
a3360 1
	fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_VFORK_DONE\n");
d3420 2
a3421 1
        fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_SYSCALL_ENTRY\n");
d3434 2
a3435 1
        fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_SYSCALL_RETURN\n");
d3459 3
a3461 2
	internal_error (__FILE__, __LINE__, "\
targets should add new threads to the thread list themselves in non-stop mode.");
d3539 3
a3541 1
	    fprintf_unfiltered (gdb_stdlog, "infrun: stepping_past_singlestep_breakpoint\n");
d3958 3
a3960 2
	fprintf_unfiltered (gdb_stdlog, "\
infrun: no user watchpoint explains watchpoint SIGTRAP, ignoring\n");
d4155 3
a4157 2
		  fprintf_unfiltered (gdb_stdlog, "\
infrun: BPSTAT_WHAT_SET_LONGJMP_RESUME (!gdbarch_get_longjmp_target)\n");
d4351 3
a4353 2
		fprintf_unfiltered (gdb_stdlog, "\
infrun: not switching back to stepped thread, it has vanished\n");
d4387 2
a4388 1
	    fprintf_unfiltered (gdb_stdlog, "infrun: stepping in dynamic linker\n");
d4497 2
a4498 1
	 fprintf_unfiltered (gdb_stdlog, "infrun: stepped into dynsym resolve code\n");
d4524 2
a4525 1
	 fprintf_unfiltered (gdb_stdlog, "infrun: stepped into signal trampoline\n");
d4755 2
a4756 1
	 fprintf_unfiltered (gdb_stdlog, "infrun: stepped into solib return tramp\n");
d4792 2
a4793 1
	 fprintf_unfiltered (gdb_stdlog, "infrun: stepped into undebuggable function\n");
d4935 2
a4936 1
	 fprintf_unfiltered (gdb_stdlog, "infrun: stepped to a different line\n");
d5598 3
a5600 3
	  printf_filtered (_("\
Cannot remove breakpoints because program is no longer writable.\n\
Further execution is probably impossible.\n"));
d5691 2
a5692 1
		source_flag = SRC_LINE;	/* finished step, just print source line */
d5694 2
a5695 1
		source_flag = SRC_AND_LOC;	/* print location and source line */
d5698 2
a5699 1
	      source_flag = SRC_AND_LOC;	/* print location and source line */
d5747 9
a5755 8
      /* frame_pop() calls reinit_frame_cache as the last thing it does
	 which means there's currently no selected frame.  We don't need
	 to re-establish a selected frame if the dummy call returns normally,
	 that will be done by restore_infcall_control_state.  However, we do have
	 to handle the case where the dummy call is returning after being
	 stopped (e.g. the dummy call previously hit a breakpoint).  We
	 can't know which case we have so just always re-establish a
	 selected frame here.  */
d5859 2
a5860 2
  printf_filtered (_("\
Signal        Stop\tPrint\tPass to program\tDescription\n"));
d6015 2
a6016 1
Are you sure you want to change it? "), target_signal_to_name ((enum target_signal) signum)))
d6166 2
a6167 1
  printf_filtered (_("\nUse the \"handle\" command to change these tables.\n"));
d6761 2
a6762 2
    fprintf_filtered (out, 
		      _("Forward (target `%s' does not support exec-direction).\n"),
d6798 2
a6799 2
  fprintf_filtered (file, _("\
Resuming the execution of threads of all processes is %s.\n"), value);
d6866 2
a6867 1
  add_setshow_boolean_cmd ("displaced", class_maintenance, &debug_displaced, _("\
@


1.462
log
@gdb
	* infrun.c (save_infcall_control_state): Handle the
	exception-resume breakpoint.
	(restore_infcall_control_state): Likewise.
	(discard_infcall_control_state): Likewise.
gdb/testsuite
2010-12-15  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* gdb.cp/nextoverthrow.cc (dummy): Return int 0.
	(NextOverThrowDerivates) <resumebpt>: New.
	(resumebpt_test): New.
	(main): Call resumebpt_test.
	* gdb.cp/nextoverthrow.exp: New block for test of "resumebpt".
@
text
@d6 1
a6 1
   2008, 2009, 2010 Free Software Foundation, Inc.
@


1.461
log
@gdb
	PR c++/9593:
	* thread.c (clear_thread_inferior_resources): Call
	delete_longjmp_breakpoint.
	* infrun.c (handle_inferior_event): Handle exception breakpoints.
	(handle_inferior_event): Likewise.
	(insert_exception_resume_breakpoint): New function.
	(check_exception_resume): Likewise.
	* inferior.h (delete_longjmp_breakpoint_cleanup): Declare.
	* infcmd.c (delete_longjmp_breakpoint_cleanup): No longer static.
	(step_1): Set thread's initiating frame.
	(until_next_continuation): New function.
	(until_next_command): Support exception breakpoints.
	(finish_command_continuation): Delete longjmp breakpoint.
	(finish_forward): Support exception breakpoints.
	* gdbthread.h (struct thread_info) <initiating_frame>: New field.
	* breakpoint.h (enum bptype) <bp_exception, bp_exception_resume,
	bp_exception_master>: New constants.
	(struct bpstat_what) <is_longjmp>: New field.
	(set_longjmp_breakpoint): Update.
	* breakpoint.c (create_exception_master_breakpoint): New function.
	(update_breakpoints_after_exec): Handle bp_exception_master.  Call
	create_exception_master_breakpoint.
	(print_it_typical): Handle bp_exception_master, bp_exception.
	(bpstat_stop_status): Handle bp_exception_master.
	(bpstat_what): Handle bp_exception_master, bp_exception,
	bp_exception_resume.
	(bptype_string): Likewise.
	(print_one_breakpoint_location): Likewise.
	(allocate_bp_location): Likewise.
	(set_longjmp_breakpoint): Handle exception breakpoints.  Change
	interface.
	(delete_longjmp_breakpoint): Handle exception breakpoints.
	(mention): Likewise.
	(struct until_break_command_continuation_args) <thread_num>: New
	field.
	(until_break_command_continuation): Call
	delete_longjmp_breakpoint.
	(until_break_command): Support exception breakpoints.
	(delete_command): Likewise.
	(breakpoint_re_set_one): Likewise.
	(breakpoint_re_set): Likewise.
gdb/testuite
	* gdb.java/jnpe.java: New file.
	* gdb.java/jnpe.exp: New file.
	* gdb.cp/nextoverthrow.exp: New file.
	* gdb.cp/nextoverthrow.cc: New file.
@
text
@d6382 1
d6432 4
d6484 4
@


1.460
log
@gdb/
	Fix step_resume_breakpoint unsaved during an infcall.
	* gdbthread.h (struct thread_control_state): Move here field
	step_resume_breakpoint ...
	(struct thread_info): ... from here.
	* infrun.c (save_infcall_control_state): Reset
	control.step_resume_breakpoint to NULL.
	(restore_infcall_control_state, discard_infcall_control_state): Delete
	control.step_resume_breakpoint.
	* arm-linux-tdep.c, infrun.c, thread.c: Update all the references to
	the moved field.

gdb/testsuite/
	Fix step_resume_breakpoint unsaved during an infcall.
	* gdb.base/step-resume-infcall.exp: New file.
	* gdb.base/step-resume-infcall.c: New file.
@
text
@d48 2
d382 1
d435 2
d447 1
d490 2
d545 3
d785 1
d2234 2
d2357 1
d2382 1
d4131 1
a4131 2
	if (!gdbarch_get_longjmp_target_p (gdbarch)
	    || !gdbarch_get_longjmp_target (gdbarch, frame, &jmp_buf_pc))
d4133 6
a4138 2
	    if (debug_infrun)
	      fprintf_unfiltered (gdb_stdlog, "\
d4140 3
a4142 3
	    keep_going (ecs);
	    return;
	  }
d4144 3
a4146 3
	/* We're going to replace the current step-resume breakpoint
	   with a longjmp-resume breakpoint.  */
	delete_step_resume_breakpoint (ecs->event_thread);
d4148 6
a4153 2
	/* Insert a breakpoint at resume address.  */
	insert_longjmp_resume_breakpoint (gdbarch, jmp_buf_pc);
d4155 3
d4166 48
a4213 3
	gdb_assert (ecs->event_thread->control.step_resume_breakpoint
		    != NULL);
	delete_step_resume_breakpoint (ecs->event_thread);
d5183 91
@


1.459
log
@gdb/
	Rename and move inferior_thread_state and inferior_status.
	* gdbthread.h (struct thread_control_state): New struct, move fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step and stop_bpstat here from struct thread_info.
	(struct thread_suspend_state): New struct, move field stop_signal here
	from struct thread_info.
	(struct thread_info): Move the fields above from this struct.
	* inferior.h: Move the inferior_thread_state and inferior_status
	declarations comment to their definitions at infrun.c.
	(struct inferior_control_state): New struct, move field stop_soon from
	struct inferior here.
	(struct inferior_suspend_state): New empty struct.
	(struct inferior): New fields control and suspend.  Move out field
	stop_soon.
	* infrun.c (struct inferior_thread_state): Rename to ...
	(infcall_suspend_state): ... here.  Replace field stop_signal by
	fields thread_suspend and inferior_suspend.
	(save_inferior_thread_state): Rename to ...
	(save_infcall_suspend_state): ... here.  New variable inf.  Update the
	code for new fields.
	(restore_inferior_thread_state): Rename to ...
	(restore_infcall_suspend_state): ... here.  New variable inf.  Update
	the code for new fields.
	(do_restore_inferior_thread_state_cleanup): Rename to ...
	(do_restore_infcall_suspend_state_cleanup): ... here.
	(make_cleanup_restore_inferior_thread_state): Rename to ...
	(make_cleanup_restore_infcall_suspend_state): ... here.
	(discard_inferior_thread_state): Rename to ...
	(discard_infcall_suspend_state): ... here.
	(get_inferior_thread_state_regcache): Rename to ...
	(get_infcall_suspend_state_regcache): ... here.
	(struct inferior_status): Rename to ...
	(struct infcall_control_state): ... here.  Replace fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step, stop_bpstat and stop_soon by fields thread_control and
	inferior_control.
	(save_inferior_status): Rename to ...
	(save_infcall_control_state): ... here.  Update the code for new
	fields.
	(restore_inferior_status): Rename to ...
	(restore_infcall_control_state): ... here.  Update the code for new
	fields.
	(do_restore_inferior_status_cleanup): Rename to ...
	(do_restore_infcall_control_state_cleanup): ... here.
	(make_cleanup_restore_inferior_status): Rename to ...
	(make_cleanup_restore_infcall_control_state): ... here.
	(discard_inferior_status): Rename to ...
	(discard_infcall_control_state): ... here.
	* alpha-tdep.c, breakpoint.c, dummy-frame.c, dummy-frame.h,
	exceptions.c, fbsd-nat.c, gdbthread.h, infcall.c, infcmd.c,
	inferior.c, inferior.h, infrun.c, linux-nat.c, mi/mi-interp.c,
	mips-tdep.c, procfs.c, solib-irix.c, solib-osf.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, thread.c, windows-nat.c: Update all the
	references to the moved fields and renamed functions.
@
text
@d427 2
a428 2
	    step_resume_breakpoint
	      = clone_momentary_breakpoint (tp->step_resume_breakpoint);
d479 2
a480 1
		    tp->step_resume_breakpoint = step_resume_breakpoint;
d534 2
a535 2
  if (tp->step_resume_breakpoint)
    breakpoint_re_set_thread (tp->step_resume_breakpoint);
d773 1
a773 1
  th->step_resume_breakpoint = NULL;
d3955 2
a3956 1
		  && ecs->event_thread->step_resume_breakpoint == NULL));
d4024 1
a4024 1
	  && ecs->event_thread->step_resume_breakpoint == NULL)
d4053 1
a4053 1
	  && ecs->event_thread->step_resume_breakpoint == NULL)
d4140 2
a4141 1
	gdb_assert (ecs->event_thread->step_resume_breakpoint != NULL);
d4317 1
a4317 1
  if (ecs->event_thread->step_resume_breakpoint)
d4868 5
a4872 4
  return ((tp->control.step_range_end && tp->step_resume_breakpoint == NULL)
 	  || tp->control.trap_expected
 	  || tp->stepping_through_solib_after_catch
 	  || bpstat_should_step ());
d5017 1
a5017 1
  gdb_assert (inferior_thread ()->step_resume_breakpoint == NULL);
d5024 1
a5024 1
  inferior_thread ()->step_resume_breakpoint
d5101 1
a5101 1
  gdb_assert (inferior_thread ()->step_resume_breakpoint == NULL);
d5108 1
a5108 1
  inferior_thread ()->step_resume_breakpoint =
d6219 2
d6266 3
d6313 4
d6319 1
@


1.458
log
@gdb/
	* infcall.c (struct inferior_thread_state) <siginfo_gdbarch>: Fix up
	the comment.
	(save_inferior_thread_state): Reset tp->stop_signal.
@
text
@d429 3
a431 3
	    step_range_start = tp->step_range_start;
	    step_range_end = tp->step_range_end;
	    step_frame_id = tp->step_frame_id;
d439 3
a441 3
	    tp->step_range_start = 0;
	    tp->step_range_end = 0;
	    tp->step_frame_id = null_frame_id;
d480 3
a482 3
		    tp->step_range_start = step_range_start;
		    tp->step_range_end = step_range_end;
		    tp->step_frame_id = step_frame_id;
d558 1
a558 1
      && thread->stop_signal == TARGET_SIGNAL_0)
d773 2
a774 2
  th->step_range_start = 0;
  th->step_range_end = 0;
d1434 1
a1434 1
	  tp->trap_expected = 0;
d1444 1
a1444 1
	  tp->stop_signal = TARGET_SIGNAL_0;
d1595 1
a1595 1
 			step, sig, tp->trap_expected);
d1624 1
a1624 1
      && (tp->trap_expected
d1693 1
a1693 1
	       && tp->trap_expected)
d1732 1
a1732 1
          && tp->trap_expected)
d1750 1
a1750 1
      tp->stop_signal = TARGET_SIGNAL_0;
d1771 6
a1776 6
  tp->trap_expected = 0;
  tp->step_range_start = 0;
  tp->step_range_end = 0;
  tp->step_frame_id = null_frame_id;
  tp->step_stack_frame_id = null_frame_id;
  tp->step_over_calls = STEP_OVER_UNDEBUGGABLE;
d1779 1
a1779 1
  tp->stop_step = 0;
d1781 1
a1781 1
  tp->proceed_to_finish = 0;
d1784 1
a1784 1
  bpstat_clear (&tp->stop_bpstat);
d1821 1
a1821 1
      inferior->stop_soon = NO_STOP_QUIETLY;
d2014 1
a2014 1
      tp->trap_expected = 1;
d2027 1
a2027 1
  if (! tp->trap_expected || use_displaced_stepping (gdbarch))
d2049 2
a2050 2
	      tp->stop_signal = last_thread->stop_signal;
	      last_thread->stop_signal = TARGET_SIGNAL_0;
d2056 1
a2056 1
    tp->stop_signal = siggnal;
d2059 2
a2060 2
  else if (!signal_program[tp->stop_signal])
    tp->stop_signal = TARGET_SIGNAL_0;
d2100 1
a2100 1
  resume (oneproc || step || bpstat_should_step (), tp->stop_signal);
d2123 1
a2123 1
  inferior->stop_soon = STOP_QUIETLY_REMOTE;
d2664 1
a2664 1
      if (inf == NULL || inf->stop_soon == NO_STOP_QUIETLY)
d2671 1
a2671 1
	  && ecs->event_thread->stop_step)
d2695 2
a2696 2
  tp->step_frame_id = get_frame_id (frame);
  tp->step_stack_frame_id = get_stack_frame_id (frame);
d2936 1
a2936 1
      ecs->event_thread->stop_bpstat
d2939 2
a2940 1
      ecs->random_signal = !bpstat_explains_signal (ecs->event_thread->stop_bpstat);
d2945 1
a2945 1
	  ecs->event_thread->stop_signal = TARGET_SIGNAL_TRAP;
d2951 1
a2951 1
  ecs->event_thread->stop_signal = TARGET_SIGNAL_0;
d2994 1
a2994 1
      stop_soon = inf->stop_soon;
d3271 1
a3271 1
      ecs->event_thread->stop_bpstat
d3279 2
a3280 1
      ecs->random_signal = !bpstat_causes_stop (ecs->event_thread->stop_bpstat);
d3290 1
a3290 1
	  ecs->event_thread->stop_signal = TARGET_SIGNAL_0;
d3324 1
a3324 1
      ecs->event_thread->stop_signal = TARGET_SIGNAL_TRAP;
d3367 1
a3367 1
      ecs->event_thread->stop_bpstat
d3370 2
a3371 1
      ecs->random_signal = !bpstat_explains_signal (ecs->event_thread->stop_bpstat);
d3381 1
a3381 1
	  ecs->event_thread->stop_signal = TARGET_SIGNAL_0;
d3385 1
a3385 1
      ecs->event_thread->stop_signal = TARGET_SIGNAL_TRAP;
d3413 1
a3413 1
      ecs->event_thread->stop_signal = ecs->ws.value.sig;
d3452 2
a3453 1
      displaced_step_fixup (ecs->ptid, ecs->event_thread->stop_signal);
d3460 2
a3461 2
	  && ecs->event_thread->stop_signal == TARGET_SIGNAL_TRAP)
	ecs->event_thread->stop_signal = TARGET_SIGNAL_0;
d3505 1
a3505 1
      if (ecs->event_thread->stop_signal == TARGET_SIGNAL_TRAP)
d3514 1
a3514 1
	  ecs->event_thread->trap_expected = 0;
d3533 1
a3533 1
      if (ecs->event_thread->stop_signal == TARGET_SIGNAL_TRAP)
d3565 1
a3565 1
  if (ecs->event_thread->stop_signal == TARGET_SIGNAL_TRAP)
d3631 2
a3632 2
                 stop_signal = ecs->event_thread->stop_signal;
                 ecs->event_thread->stop_signal = TARGET_SIGNAL_0;
d3635 1
a3635 1
                 ecs->event_thread->stop_signal = stop_signal;
d3794 2
a3795 2
  bpstat_clear (&ecs->event_thread->stop_bpstat);
  ecs->event_thread->stop_step = 0;
d3803 1
a3803 1
  if (ecs->event_thread->step_range_end != 1)
d3806 2
a3807 2
  if (ecs->event_thread->stop_signal == TARGET_SIGNAL_TRAP
      && ecs->event_thread->trap_expected
d3821 2
a3822 1
      if (ecs->event_thread->step_range_end == 0 && step_through_delay)
d3850 1
a3850 1
  if (ecs->event_thread->stop_signal == TARGET_SIGNAL_TRAP
d3854 2
a3855 1
      if (ecs->event_thread->stop_signal == TARGET_SIGNAL_TRAP && stop_after_trap)
d3895 3
a3897 3
	  && (ecs->event_thread->stop_signal == TARGET_SIGNAL_STOP
	      || ecs->event_thread->stop_signal == TARGET_SIGNAL_TRAP
	      || ecs->event_thread->stop_signal == TARGET_SIGNAL_0))
d3900 1
a3900 1
	  ecs->event_thread->stop_signal = TARGET_SIGNAL_0;
d3905 1
a3905 1
      ecs->event_thread->stop_bpstat
d3922 2
a3923 2
	  && ecs->event_thread->stop_signal == TARGET_SIGNAL_TRAP
	  && !bpstat_explains_signal (ecs->event_thread->stop_bpstat)
d3948 1
a3948 1
      if (ecs->event_thread->stop_signal == TARGET_SIGNAL_TRAP)
d3950 1
a3950 1
	  = !(bpstat_explains_signal (ecs->event_thread->stop_bpstat)
d3952 2
a3953 2
	      || ecs->event_thread->trap_expected
	      || (ecs->event_thread->step_range_end
d3957 2
a3958 1
	  ecs->random_signal = !bpstat_explains_signal (ecs->event_thread->stop_bpstat);
d3960 1
a3960 1
	    ecs->event_thread->stop_signal = TARGET_SIGNAL_TRAP;
d3989 1
a3989 1
			     ecs->event_thread->stop_signal);
d3993 1
a3993 1
      if (signal_print[ecs->event_thread->stop_signal])
d3997 2
a3998 1
	  print_signal_received_reason (ecs->event_thread->stop_signal);
d4006 1
a4006 1
	      && signal_stop_state (ecs->event_thread->stop_signal)))
d4017 2
a4018 2
      if (signal_program[ecs->event_thread->stop_signal] == 0)
	ecs->event_thread->stop_signal = TARGET_SIGNAL_0;
d4021 1
a4021 1
	  && ecs->event_thread->trap_expected
d4045 4
a4048 4
      if (ecs->event_thread->step_range_end != 0
	  && ecs->event_thread->stop_signal != TARGET_SIGNAL_0
	  && (ecs->event_thread->step_range_start <= stop_pc
	      && stop_pc < ecs->event_thread->step_range_end)
d4050 1
a4050 1
			  ecs->event_thread->step_stack_frame_id)
d4087 1
a4087 1
    what = bpstat_what (ecs->event_thread->stop_bpstat);
d4141 1
a4141 1
	ecs->event_thread->stop_step = 1;
d4228 2
a4229 2
	  if ((ecs->event_thread->trap_expected
	       && ecs->event_thread->stop_signal != TARGET_SIGNAL_TRAP)
d4270 1
a4270 1
	  ecs->event_thread->trap_expected = 0;
d4305 2
a4306 2
      bpstat_clear (&ecs->event_thread->stop_bpstat);
      ecs->event_thread->stop_bpstat
d4327 1
a4327 1
  if (ecs->event_thread->step_range_end == 0)
d4352 2
a4353 2
  if (stop_pc >= ecs->event_thread->step_range_start
      && stop_pc < ecs->event_thread->step_range_end
d4356 1
a4356 1
			  ecs->event_thread->step_frame_id)))
d4361 2
a4362 2
	   paddress (gdbarch, ecs->event_thread->step_range_start),
	   paddress (gdbarch, ecs->event_thread->step_range_end));
d4367 1
a4367 1
      if (stop_pc == ecs->event_thread->step_range_start
d4371 1
a4371 1
	  ecs->event_thread->stop_step = 1;
d4396 1
a4396 1
      && ecs->event_thread->step_over_calls == STEP_OVER_UNDEBUGGABLE
d4423 3
a4425 3
  if (ecs->event_thread->step_range_end != 1
      && (ecs->event_thread->step_over_calls == STEP_OVER_UNDEBUGGABLE
	  || ecs->event_thread->step_over_calls == STEP_OVER_ALL)
d4457 1
a4457 1
		    ecs->event_thread->step_stack_frame_id)
d4459 2
a4460 2
		       ecs->event_thread->step_stack_frame_id)
	  && (!frame_id_eq (ecs->event_thread->step_stack_frame_id,
d4469 2
a4470 2
      if ((ecs->event_thread->step_over_calls == STEP_OVER_NONE)
	  || ((ecs->event_thread->step_range_end == 1)
d4481 1
a4481 1
	  ecs->event_thread->stop_step = 1;
d4490 1
a4490 1
	  && ecs->event_thread->step_over_calls != STEP_OVER_NONE
d4504 1
a4504 1
      if (ecs->event_thread->step_over_calls == STEP_OVER_ALL)
d4584 1
a4584 1
      if (ecs->event_thread->step_over_calls == STEP_OVER_UNDEBUGGABLE
d4587 1
a4587 1
	  ecs->event_thread->stop_step = 1;
d4617 1
a4617 1
      && ecs->event_thread->step_over_calls != STEP_OVER_NONE)
d4690 1
a4690 1
  if (ecs->event_thread->step_over_calls == STEP_OVER_UNDEBUGGABLE
d4711 1
a4711 1
	  ecs->event_thread->stop_step = 1;
d4726 1
a4726 1
  if (ecs->event_thread->step_range_end == 1)
d4732 1
a4732 1
      ecs->event_thread->stop_step = 1;
d4746 1
a4746 1
      ecs->event_thread->stop_step = 1;
d4757 1
a4757 1
		   ecs->event_thread->step_frame_id)
d4768 1
a4768 1
      if (ecs->event_thread->step_over_calls != STEP_OVER_ALL)
d4779 1
a4779 1
	  ecs->event_thread->stop_step = 1;
d4794 1
a4794 1
	      ecs->event_thread->stop_step = 1;
d4809 1
a4809 1
		       ecs->event_thread->step_frame_id)
d4811 1
a4811 1
			  ecs->event_thread->step_frame_id))
d4817 1
a4817 1
      if (ecs->event_thread->step_over_calls == STEP_OVER_ALL)
d4821 1
a4821 1
	  ecs->event_thread->stop_step = 1;
d4838 1
a4838 1
      ecs->event_thread->stop_step = 1;
d4851 2
a4852 2
  ecs->event_thread->step_range_start = stop_pc_sal.pc;
  ecs->event_thread->step_range_end = stop_pc_sal.end;
d4865 2
a4866 2
  return ((tp->step_range_end && tp->step_resume_breakpoint == NULL)
 	  || tp->trap_expected
d4880 2
a4881 2
  return (tp->step_range_end
 	  || tp->trap_expected
d4939 1
a4939 1
      ecs->event_thread->stop_step = 1;
d4958 2
a4959 1
      ecs->event_thread->step_range_end = ecs->event_thread->step_range_start;
d4986 1
a4986 1
      ecs->event_thread->stop_step = 1;
d4995 2
a4996 2
      ecs->event_thread->step_range_start = stop_func_sal.pc;
      ecs->event_thread->step_range_end = stop_func_sal.end;
d5136 2
a5137 2
  if (ecs->event_thread->trap_expected
      && ecs->event_thread->stop_signal != TARGET_SIGNAL_TRAP)
d5145 1
a5145 1
	      ecs->event_thread->stop_signal);
d5190 2
a5191 1
      ecs->event_thread->trap_expected = ecs->event_thread->stepping_over_breakpoint;
d5205 3
a5207 3
      if (ecs->event_thread->stop_signal == TARGET_SIGNAL_TRAP
	  && !signal_program[ecs->event_thread->stop_signal])
	ecs->event_thread->stop_signal = TARGET_SIGNAL_0;
d5211 1
a5211 1
	      ecs->event_thread->stop_signal);
d5248 2
a5249 1
  if ((!inferior_thread ()->step_multi || !inferior_thread ()->stop_step)
d5425 1
a5425 1
      && inferior_thread ()->stop_step)
d5477 1
a5477 1
	  bpstat_ret = bpstat_print (tp->stop_bpstat);
d5496 2
a5497 2
	      if (tp->stop_step
		  && frame_id_eq (tp->step_frame_id,
d5533 1
a5533 1
  if (inferior_thread ()->proceed_to_finish)
d5548 1
a5548 1
	 (struct inferior_thread_state).  */
d5556 1
a5556 1
	 that will be done by restore_inferior_status.  However, we do have
d5583 3
a5585 3
	  && !(inferior_thread ()->stop_bpstat
	       && inferior_thread ()->proceed_to_finish)
	  && !inferior_thread ()->in_infcall))
d5588 1
a5588 1
	observer_notify_normal_stop (inferior_thread ()->stop_bpstat,
d5600 1
a5600 1
	breakpoint_auto_delete (inferior_thread ()->stop_bpstat);
d6047 5
a6051 7
/* Inferior thread state.
   These are details related to the inferior itself, and don't include
   things like what frame the user had selected or what gdb was doing
   with the target at the time.
   For inferior function calls these are things we want to restore
   regardless of whether the function call successfully completes
   or the dummy frame has to be manually popped.  */
d6053 1
a6053 1
struct inferior_thread_state
d6055 4
a6058 1
  enum target_signal stop_signal;
d6071 2
a6072 2
struct inferior_thread_state *
save_inferior_thread_state (void)
d6074 1
a6074 1
  struct inferior_thread_state *inf_state;
d6076 1
d6101 1
a6101 1
  inf_state = XZALLOC (struct inferior_thread_state);
d6109 3
a6111 1
  inf_state->stop_signal = tp->stop_signal;
d6114 1
a6114 1
  tp->stop_signal = TARGET_SIGNAL_0;
d6126 1
a6126 1
restore_inferior_thread_state (struct inferior_thread_state *inf_state)
d6129 1
d6133 3
a6135 1
  tp->stop_signal = inf_state->stop_signal;
d6154 1
a6154 1
  discard_inferior_thread_state (inf_state);
d6158 1
a6158 1
do_restore_inferior_thread_state_cleanup (void *state)
d6160 1
a6160 1
  restore_inferior_thread_state (state);
d6164 2
a6165 1
make_cleanup_restore_inferior_thread_state (struct inferior_thread_state *inf_state)
d6167 1
a6167 1
  return make_cleanup (do_restore_inferior_thread_state_cleanup, inf_state);
d6171 1
a6171 1
discard_inferior_thread_state (struct inferior_thread_state *inf_state)
d6179 1
a6179 1
get_inferior_thread_state_regcache (struct inferior_thread_state *inf_state)
d6184 3
a6186 19
/* Session related state for inferior function calls.
   These are the additional bits of state that need to be restored
   when an inferior function call successfully completes.

   Keep the fields in order as present in their original structures.  */

struct inferior_status
{
  /* Direct copies of the struct thread_info fields:  */
  CORE_ADDR step_range_start;
  CORE_ADDR step_range_end;
  struct frame_id step_frame_id;
  struct frame_id step_stack_frame_id;
  int trap_expected;
  int proceed_to_finish;
  int in_infcall;
  enum step_over_calls_kind step_over_calls;
  int stop_step;
  bpstat stop_bpstat;
d6188 4
a6191 2
  /* Direct copies of the struct inferior fields:  */
  int stop_soon;
d6205 2
a6206 2
struct inferior_status *
save_inferior_status (void)
d6208 1
a6208 1
  struct inferior_status *inf_status = XMALLOC (struct inferior_status);
d6212 6
a6217 14
  /* Direct copies of the struct thread_info fields:  */
  inf_status->step_range_start = tp->step_range_start;
  inf_status->step_range_end = tp->step_range_end;
  inf_status->step_frame_id = tp->step_frame_id;
  inf_status->step_stack_frame_id = tp->step_stack_frame_id;
  inf_status->trap_expected = tp->trap_expected;
  inf_status->proceed_to_finish = tp->proceed_to_finish;
  inf_status->in_infcall = tp->in_infcall;
  inf_status->step_over_calls = tp->step_over_calls;
  inf_status->stop_step = tp->stop_step;

  /* Save original bpstat chain here; replace it with copy of chain.
     If caller's caller is walking the chain, they'll be happier if we
     hand them back the original chain when restore_inferior_status is
d6219 1
a6219 5
  inf_status->stop_bpstat = tp->stop_bpstat;
  tp->stop_bpstat = bpstat_copy (tp->stop_bpstat);

  /* Direct copies of the struct inferior fields:  */
  inf_status->stop_soon = inf->stop_soon;
d6255 1
a6255 1
restore_inferior_status (struct inferior_status *inf_status)
a6259 11
  /* Direct copies of the struct thread_info fields:  */
  tp->step_range_start = inf_status->step_range_start;
  tp->step_range_end = inf_status->step_range_end;
  tp->step_frame_id = inf_status->step_frame_id;
  tp->step_stack_frame_id = inf_status->step_stack_frame_id;
  tp->trap_expected = inf_status->trap_expected;
  tp->proceed_to_finish = inf_status->proceed_to_finish;
  tp->in_infcall = inf_status->in_infcall;
  tp->step_over_calls = inf_status->step_over_calls;
  tp->stop_step = inf_status->stop_step;

d6261 1
a6261 3
  bpstat_clear (&tp->stop_bpstat);
  tp->stop_bpstat = inf_status->stop_bpstat;
  inf_status->stop_bpstat = NULL;
d6263 2
a6264 2
  /* Direct copies of the struct inferior fields:  */
  inf->stop_soon = inf_status->stop_soon;
d6289 1
a6289 1
do_restore_inferior_status_cleanup (void *sts)
d6291 1
a6291 1
  restore_inferior_status (sts);
d6295 2
a6296 1
make_cleanup_restore_inferior_status (struct inferior_status *inf_status)
d6298 1
a6298 1
  return make_cleanup (do_restore_inferior_status_cleanup, inf_status);
d6302 1
a6302 1
discard_inferior_status (struct inferior_status *inf_status)
d6304 2
a6305 2
  /* See save_inferior_status for info on stop_bpstat. */
  bpstat_clear (&inf_status->stop_bpstat);
@


1.457
log
@gdb/
	Code cleanup.
	* infrun.c (struct inferior_status) <stepping_over_breakpoint>
	(save_inferior_status) <stepping_over_breakpoint>
	(restore_inferior_status) <stepping_over_breakpoint>: Rename to
	trap_expected.
	(struct inferior_status) <step_resume_break_address>: Remove.
@
text
@d6050 1
a6050 1
  /* Format of SIGINFO or NULL if it is not present.  */
d6097 4
@


1.456
log
@gdb/
	* infrun.c (struct inferior_status, save_inferior_status)
	(restore_inferior_status): Group and reorder the fields, comment their
	groups.
@
text
@d6174 1
a6174 1
  int stepping_over_breakpoint;
a6186 1
  CORE_ADDR step_resume_break_address;
d6208 1
a6208 1
  inf_status->stepping_over_breakpoint = tp->trap_expected;
d6268 1
a6268 1
  tp->trap_expected = inf_status->stepping_over_breakpoint;
@


1.455
log
@gdb/
	* infrun.c (restore_inferior_thread_state): Use
	discard_inferior_thread_state to free the data.
	(discard_inferior_thread_state): xfree also siginfo_data.
@
text
@d6163 3
a6165 1
   when an inferior function call successfully completes.  */
d6169 1
a6169 5
  bpstat stop_bpstat;
  int stop_step;
  enum stop_stack_kind stop_stack_dummy;
  int stopped_by_random_signal;
  int stepping_over_breakpoint;
d6174 3
d6178 9
a6188 1
  int stop_soon;
a6191 3

  int proceed_to_finish;
  int in_infcall;
d6204 1
a6204 4
  inf_status->stop_step = tp->stop_step;
  inf_status->stop_stack_dummy = stop_stack_dummy;
  inf_status->stopped_by_random_signal = stopped_by_random_signal;
  inf_status->stepping_over_breakpoint = tp->trap_expected;
d6209 3
d6213 2
a6214 2
  inf_status->stop_after_trap = stop_after_trap;
  inf_status->stop_soon = inf->stop_soon;
d6221 8
a6228 2
  inf_status->proceed_to_finish = tp->proceed_to_finish;
  inf_status->in_infcall = tp->in_infcall;
d6264 1
a6264 4
  tp->stop_step = inf_status->stop_step;
  stop_stack_dummy = inf_status->stop_stack_dummy;
  stopped_by_random_signal = inf_status->stopped_by_random_signal;
  tp->trap_expected = inf_status->stepping_over_breakpoint;
d6269 3
d6273 3
a6275 2
  stop_after_trap = inf_status->stop_after_trap;
  inf->stop_soon = inf_status->stop_soon;
d6279 8
a6286 2
  tp->proceed_to_finish = inf_status->proceed_to_finish;
  tp->in_infcall = inf_status->in_infcall;
@


1.454
log
@gdb/
	Revert:
	2010-10-17  Jan Kratochvil  <jan.kratochvil@@redhat.com>
		    Pedro Alves  <pedro@@codesourcery.com>
	* gdbthread.h (currently_stepping): New declaration.
	* infrun.c (currently_stepping): Remove the forward declaration.
	(currently_stepping): Make it global.
	* linux-nat.c (resume_callback) <lp->stopped && lp->status == 0>: New
	variables tp and step, initialized them.  Pass STEP to to_resume.
	Print also possibly "PTRACE_SINGLESTEP" if STEP.  Initialize LP->STEP.
	* remote.c (currently_stepping_callback): New.
	(remote_vcont_resume)
	<ptid_equal (ptid, minus_one_ptid) || ptid_is_pid (ptid)>:
	New variable tp.  Call currently_stepping_callback and step such
	thread.

gdb/testsuite/
	Revert:
	2010-10-17  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	* gdb.threads/sigstep-threads.exp: New file.
	* gdb.threads/sigstep-threads.c: New file.
@
text
@d6131 2
a6132 3
  regcache_xfree (inf_state->registers);
  xfree (inf_state->siginfo_data);
  xfree (inf_state);
d6151 1
@


1.453
log
@gdb/
	* gdbthread.h (currently_stepping): New declaration.
	* infrun.c (currently_stepping): Remove the forward declaration.
	(currently_stepping): Make it global.
	* linux-nat.c (resume_callback) <lp->stopped && lp->status == 0>: New
	variables tp and step, initialized them.  Pass STEP to to_resume.
	Print also possibly "PTRACE_SINGLESTEP" if STEP.  Initialize LP->STEP.
	* remote.c (currently_stepping_callback): New.
	(remote_vcont_resume)
	<ptid_equal (ptid, minus_one_ptid) || ptid_is_pid (ptid)>:
	New variable tp.  Call currently_stepping_callback and step such
	thread.

gdb/testsuite/
	* gdb.threads/sigstep-threads.exp: New file.
	* gdb.threads/sigstep-threads.c: New file.
@
text
@d77 2
d4854 1
a4854 1
int
@


1.452
log
@gdb/
	* infrun.c (follow_exec): Replace symbol_file_add_main by
	symbol_file_add with SYMFILE_DEFER_BP_RESET, set_initial_language and
	breakpoint_re_set.
	* m32r-rom.c (m32r_load, m32r_upload_command): Use parameter 0 for
	clear_symtab_users.
	* objfiles.c (free_all_objfiles): Likewise.
	* remote-m32r-sdi.c (m32r_load): Likewise.
	* solib-som.c (som_solib_create_inferior_hook): Likewise.
	* symfile.c (new_symfile_objfile): New comment for add_flags.  Call
	clear_symtab_users with ADD_FLAGS.
	(reread_symbols): Use parameter 0 for clear_symtab_users.
	(clear_symtab_users): New parameter add_flags.  Do not call
	breakpoint_re_set if SYMFILE_DEFER_BP_RESET.
	(clear_symtab_users_cleanup): Use parameter 0 for clear_symtab_users.
	* symtab.h (clear_symtab_users): New parameter add_flags.

gdb/testsuite/
	* gdb.base/pie-execl.exp: New file.
	* gdb.base/pie-execl.c: New file.
@
text
@a76 2
static int currently_stepping (struct thread_info *tp);

d4852 1
a4852 1
static int
@


1.451
log
@gdb/
	Fix lost siginfo_t for inferior calls.
	* infrun.c
	(struct inferior_thread_state) <siginfo_gdbarch, siginfo_data>: New.
	(save_inferior_thread_state): New variables regcache, gdbarch and
	siginfo_data.  Initialize SIGINFO_DATA if gdbarch_get_siginfo_type_p.
	Move INF_STATE allocation later, pre-clear it.  Initialize REGISTERS
	using REGCACHE.
	(restore_inferior_thread_state): New variables regcache and gdbarch.
	Restore SIGINFO_DATA for matching GDBARCH.  Restore REGISTERS using
	REGCACHE.  Free also SIGINFO_DATA.

gdb/testsuite/
	Fix lost siginfo_t for inferior calls.
	* gdb.base/siginfo-infcall.exp: New file.
	* gdb.base/siginfo-infcall.c: New file.
@
text
@d838 9
a846 2
  /* Load the main file's symbols.  */
  symbol_file_add_main (execd_pathname, 0);
d856 2
@


1.450
log
@	* infrun.c (resume): Extend comment on ignoring single-step
	requests on vfork parents waiting for a vfork-done.
@
text
@d6040 8
d6053 1
a6053 1
  struct inferior_thread_state *inf_state = XMALLOC (struct inferior_thread_state);
d6055 31
d6090 1
a6090 1
  inf_state->registers = regcache_dup (get_current_regcache ());
d6101 2
d6107 10
d6121 1
a6121 1
    regcache_cpy (get_current_regcache (), inf_state->registers);
d6123 1
@


1.449
log
@2010-09-06  Yao Qi  <yao@@codesourcery.com>

	* infrunc(resume): When inferior is waiting_for_vfork_done,
	clear step and don't use displaced stepping.
@
text
@a1562 5
  /* Don't consider single-stepping when the inferior is 
     waiting_for_vfork_done, either software or hardware step.  In
     software step, child process will hit the software single step
     breakpoint inserted in parent process.  In hardware step, GDB
     can resumes inferior, and wait for vfork_done event.  */
d1565 11
@


1.448
log
@gdb/
	Code cleanup - split print_stop_reason.
	* infrun.c (enum inferior_stop_reason): Remove.
	(print_stop_reason): Remove by splitting into ...
	(print_exited_reason, print_signal_exited_reason)
	(print_no_history_reason, print_signal_received_reason)
	(print_end_stepping_range_reason): ... these new functions.  Update
	the preceding comment.
	(handle_inferior_event): Change the calls to print_exited_reason,
	print_signal_exited_reason, print_no_history_reason,
	print_signal_received_reason, print_end_stepping_range_reason.
	(handle_step_into_function, handle_step_into_function_backward):
	Change the calls to print_end_stepping_range_reason.
@
text
@d1563 13
d1603 5
a1607 1
     signals' explain what we do instead.  */
d1611 2
a1612 1
      && sig == TARGET_SIGNAL_0)
@


1.447
log
@2010-08-31  Michael Snyder  <msnyder@@msnyder-server.eng.vmware.com>

	* infrun.c (set_exec_direction_func): Error out if target does not
	support reverse execution.
@
text
@d86 10
a2151 16
/* Why did the inferior stop? Used to print the appropriate messages
   to the interface from within handle_inferior_event(). */
enum inferior_stop_reason
{
  /* Step, next, nexti, stepi finished. */
  END_STEPPING_RANGE,
  /* Inferior terminated by signal. */
  SIGNAL_EXITED,
  /* Inferior exited. */
  EXITED,
  /* Inferior received signal, and user asked to be notified. */
  SIGNAL_RECEIVED,
  /* Reverse execution -- target ran out of history info.  */
  NO_HISTORY
};

a2191 2
static void print_stop_reason (enum inferior_stop_reason stop_reason,
			       int stop_info);
d3152 1
a3152 1
      print_stop_reason (EXITED, ecs->ws.value.integer);
d3183 1
a3183 1
      print_stop_reason (SIGNAL_EXITED, ecs->ws.value.sig);
d3383 1
a3383 1
      print_stop_reason (NO_HISTORY, 0);
d3957 1
a3957 1
	  print_stop_reason (SIGNAL_RECEIVED, ecs->event_thread->stop_signal);
d4101 1
a4101 1
	print_stop_reason (END_STEPPING_RANGE, 0);
d4331 1
a4331 1
	  print_stop_reason (END_STEPPING_RANGE, 0);
d4441 1
a4441 1
	  print_stop_reason (END_STEPPING_RANGE, 0);
d4547 1
a4547 1
	  print_stop_reason (END_STEPPING_RANGE, 0);
d4671 1
a4671 1
	  print_stop_reason (END_STEPPING_RANGE, 0);
d4692 1
a4692 1
      print_stop_reason (END_STEPPING_RANGE, 0);
d4706 1
a4706 1
      print_stop_reason (END_STEPPING_RANGE, 0);
d4739 1
a4739 1
	  print_stop_reason (END_STEPPING_RANGE, 0);
d4754 1
a4754 1
	      print_stop_reason (END_STEPPING_RANGE, 0);
d4781 1
a4781 1
	  print_stop_reason (END_STEPPING_RANGE, 0);
d4798 1
a4798 1
      print_stop_reason (END_STEPPING_RANGE, 0);
d4899 1
a4899 1
      print_stop_reason (END_STEPPING_RANGE, 0);
d4945 1
a4945 1
      print_stop_reason (END_STEPPING_RANGE, 0);
d5190 61
a5250 25
/* Print why the inferior has stopped. We always print something when
   the inferior exits, or receives a signal. The rest of the cases are
   dealt with later on in normal_stop() and print_it_typical().  Ideally
   there should be a call to this function from handle_inferior_event()
   each time stop_stepping() is called.*/
static void
print_stop_reason (enum inferior_stop_reason stop_reason, int stop_info)
{
  switch (stop_reason)
    {
    case END_STEPPING_RANGE:
      /* We are done with a step/next/si/ni command. */
      /* For now print nothing. */
      /* Print a message only if not in the middle of doing a "step n"
         operation for n > 1 */
      if (!inferior_thread ()->step_multi
	  || !inferior_thread ()->stop_step)
	if (ui_out_is_mi_like_p (uiout))
	  ui_out_field_string
	    (uiout, "reason",
	     async_reason_lookup (EXEC_ASYNC_END_STEPPING_RANGE));
      break;
    case SIGNAL_EXITED:
      /* The inferior was terminated by a signal. */
      annotate_signalled ();
d5253 28
a5280 3
	  (uiout, "reason",
	   async_reason_lookup (EXEC_ASYNC_EXITED_SIGNALLED));
      ui_out_text (uiout, "\nProgram terminated with signal ");
d5282 3
d5286 1
a5286 1
			   target_signal_to_name (stop_info));
d5291 1
a5291 1
			   target_signal_to_string (stop_info));
a5292 68
      ui_out_text (uiout, ".\n");
      ui_out_text (uiout, "The program no longer exists.\n");
      break;
    case EXITED:
      /* The inferior program is finished. */
      annotate_exited (stop_info);
      if (stop_info)
	{
	  if (ui_out_is_mi_like_p (uiout))
	    ui_out_field_string (uiout, "reason", 
				 async_reason_lookup (EXEC_ASYNC_EXITED));
	  ui_out_text (uiout, "\nProgram exited with code ");
	  ui_out_field_fmt (uiout, "exit-code", "0%o",
			    (unsigned int) stop_info);
	  ui_out_text (uiout, ".\n");
	}
      else
	{
	  if (ui_out_is_mi_like_p (uiout))
	    ui_out_field_string
	      (uiout, "reason",
	       async_reason_lookup (EXEC_ASYNC_EXITED_NORMALLY));
	  ui_out_text (uiout, "\nProgram exited normally.\n");
	}
      /* Support the --return-child-result option.  */
      return_child_result_value = stop_info;
      break;
    case SIGNAL_RECEIVED:
      /* Signal received.  The signal table tells us to print about
	 it. */
      annotate_signal ();

      if (stop_info == TARGET_SIGNAL_0 && !ui_out_is_mi_like_p (uiout))
	{
	  struct thread_info *t = inferior_thread ();

	  ui_out_text (uiout, "\n[");
	  ui_out_field_string (uiout, "thread-name",
			       target_pid_to_str (t->ptid));
	  ui_out_field_fmt (uiout, "thread-id", "] #%d", t->num);
	  ui_out_text (uiout, " stopped");
	}
      else
	{
	  ui_out_text (uiout, "\nProgram received signal ");
	  annotate_signal_name ();
	  if (ui_out_is_mi_like_p (uiout))
	    ui_out_field_string
	      (uiout, "reason", async_reason_lookup (EXEC_ASYNC_SIGNAL_RECEIVED));
	  ui_out_field_string (uiout, "signal-name",
			       target_signal_to_name (stop_info));
	  annotate_signal_name_end ();
	  ui_out_text (uiout, ", ");
	  annotate_signal_string ();
	  ui_out_field_string (uiout, "signal-meaning",
			       target_signal_to_string (stop_info));
	  annotate_signal_string_end ();
	}
      ui_out_text (uiout, ".\n");
      break;
    case NO_HISTORY:
      /* Reverse execution: target ran out of history info.  */
      ui_out_text (uiout, "\nNo more reverse-execution history.\n");
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      _("print_stop_reason: unrecognized enum value"));
      break;
d5294 10
a5304 1

@


1.446
log
@2010-07-19  Hui Zhu  <teawater@@gmail.com>

	* breakpoint.c (single_step_breakpoints_inserted): New
	function.
	* breakpoint.h (single_step_breakpoints_inserted): Extern.
	* infrun.c (maybe_software_singlestep): Add check code.
	* record.c (record_resume): Add code for software single step.
	(record_wait): Ditto.
@
text
@d6440 5
@


1.445
log
@	* breakpoint.c (update_watchpoint, _initialize_breakpoint): Remove
	unnecessary space in string.
	* filesystem.c (_initialize_filesystem): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* infcmd.c (step_once): Ditto.
	* infrun.c (_initialize_infrun): Ditto.
	* linux-nat.c (linux_child_follow_fork): Ditto.
	* maint.c (maintenance_deprecate): Ditto.
	* memattr.c (_initialize_mem): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* monitor.c (monitor_open): Ditto.
	* procfs.c (procfs_xfer_memory): Ditto.
	* reverse.c (bookmarks_info): Ditto.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Ditto.
	* stack.c (_initialize_stack): Ditto.
	* tracepoint.c (_initialize_tracepoint): Ditto.
	* xtensa-tdep.c (xtensa_supply_gregset,
	xtensa_regset_from_core_section): Ditto.
@
text
@d1518 2
a1519 1
  if (gdbarch_software_single_step_p (gdbarch)
@


1.445.2.1
log
@2010-08-31  Michael Snyder  <msnyder@@msnyder-server.eng.vmware.com>

	* infrun.c (set_exec_direction_func): Error out if target does not
	support reverse execution.
@
text
@a6438 5
  else
    {
      exec_direction = exec_forward;
      error (_("Target does not support this operation."));
    }
@


1.445.2.2
log
@2010-09-08  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	* infrunc(resume): When inferior is waiting_for_vfork_done,
	clear step and don't use displaced stepping.
	Extend comment on ignoring single-step requests on vfork
	parents waiting for a vfork-done.
@
text
@a1551 19
  /* Don't try to single-step a vfork parent that is waiting for
     the child to get out of the shared memory region (by exec'ing
     or exiting).  This is particularly important on software
     single-step archs, as the child process would trip on the
     software single step breakpoint inserted for the parent
     process.  Since the parent will not actually execute any
     instruction until the child is out of the shared region (such
     are vfork's semantics), it is safe to simply continue it.
     Eventually, we'll see a TARGET_WAITKIND_VFORK_DONE event for
     the parent, and tell it to `keep_going', which automatically
     re-sets it stepping.  */
  if (current_inferior ()->waiting_for_vfork_done)
    {
      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog,
			    "infrun: resume : clear step\n");
      step = 0;
    }

d1579 1
a1579 5
     signals' explain what we do instead.

     We can't use displaced stepping when we are waiting for vfork_done
     event, displaced stepping breaks the vfork child similarly as single
     step software breakpoint.  */
d1583 1
a1583 2
      && sig == TARGET_SIGNAL_0
      && !current_inferior ()->waiting_for_vfork_done)
@


1.445.2.3
log
@	* infrun.c (proceed): Move switching out and in of tfind mode from
	here ...
	(fetch_inferior_event): ... to here.
@
text
@d1957 10
a2609 10
  /* We're handling a live event, so make sure we're doing live
     debugging.  If we're looking at traceframes while the target is
     running, we're going to need to get back to that mode after
     handling the event.  */
  if (non_stop)
    {
      make_cleanup_restore_current_traceframe ();
      set_traceframe_number (-1);
    }

@


1.444
log
@gdb/
	Fix PR 9436.
	* breakpoint.c (handle_jit_event): New function.
	(bpstat_what): Remove enum class, kc, ss, sn, sgl, slr, clr, sr, shl,
	jit, err, table and bs_class.  New variables shlib_event, jit_event,
	this_action and bptype.  Change bs_class assignments to this_action
	assignments.  new unhandled bptype internal error.  Move here
	shlib_event and jit_event handling from handle_inferior_event.
	* breakpoint.h (enum bpstat_what_main_action): Extend the comment.
	Reorder items.  Remove BPSTAT_WHAT_CHECK_SHLIBS and
	BPSTAT_WHAT_CHECK_JIT.
	* inferior.h (debug_infrun, stop_on_solib_events): New declarations.
	* infrun.c (debug_infrun, stop_on_solib_events): Remove static.
	(handle_inferior_event): Reinitialize frame and gdbarch after
	bpstat_what call.  Move BPSTAT_WHAT_CHECK_SHLIBS and
	BPSTAT_WHAT_CHECK_JIT handling to bpstat_what.  Reinitialize even
	gdbarch when frame gets reinitialized.

gdb/testsuite/
	Test PR 9436.
	* gdb.base/nostdlib.exp, gdb.base/nostdlib.c: New.
@
text
@d6534 1
a6534 1
Recognized actions include \"s\" (toggles between stop and nostop), \n\
d6668 1
a6668 1
  new - the debugger creates a new inferior and rebinds the process \n\
@


1.443
log
@ChangeLog:

	* infrun.c (handle_inferior_event): Handle presence of single-step
	breakpoints for TARGET_WAITKIND_FORKED and TARGET_WAITKIND_VFORKED.
	Cancel single-step breakpoints for TARGET_WAITKIND_EXITED,
	TARGET_WAITKIND_SIGNALED, and TARGET_WAITKIND_EXECD.
	* breakpoint.c (detach_single_step_breakpoints): New function.
	(detach_breakpoints): Call it.
	(cancel_single_step_breakpoints): New function.
	* breakpoint.h (cancel_single_step_breakpoints): Add prototype.

	* spu-tdep.c (spu_memory_remove_breakpoint): New function.
	(spu_gdbarch_init): Install it.

testsuite/ChangeLog:

	* gdb.cell/fork.exp: New file.
	* gdb.cell/fork.c: Likewise.
	* gdb.cell/fork-spu.c: Likewise.
@
text
@d122 1
a122 1
static int debug_infrun = 0;
d297 1
a297 1
static int stop_on_solib_events;
d4060 6
a4169 60
      case BPSTAT_WHAT_CHECK_SHLIBS:
	{
          if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_CHECK_SHLIBS\n");

	  /* Check for any newly added shared libraries if we're
	     supposed to be adding them automatically.  Switch
	     terminal for any messages produced by
	     breakpoint_re_set.  */
	  target_terminal_ours_for_output ();
	  /* NOTE: cagney/2003-11-25: Make certain that the target
	     stack's section table is kept up-to-date.  Architectures,
	     (e.g., PPC64), use the section table to perform
	     operations such as address => section name and hence
	     require the table to contain all sections (including
	     those found in shared libraries).  */
#ifdef SOLIB_ADD
	  SOLIB_ADD (NULL, 0, &current_target, auto_solib_add);
#else
	  solib_add (NULL, 0, &current_target, auto_solib_add);
#endif
	  target_terminal_inferior ();

	  /* If requested, stop when the dynamic linker notifies
	     gdb of events.  This allows the user to get control
	     and place breakpoints in initializer routines for
	     dynamically loaded objects (among other things).  */
	  if (stop_on_solib_events || stop_stack_dummy)
	    {
	      stop_stepping (ecs);
	      return;
	    }
	  else
	    {
	      /* We want to step over this breakpoint, then keep going.  */
	      ecs->event_thread->stepping_over_breakpoint = 1;
	      break;
	    }
	}
	break;

      case BPSTAT_WHAT_CHECK_JIT:
        if (debug_infrun)
          fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_CHECK_JIT\n");

        /* Switch terminal for any messages produced by breakpoint_re_set.  */
        target_terminal_ours_for_output ();

        jit_event_handler (gdbarch);

        target_terminal_inferior ();

        /* We want to step over this breakpoint, then keep going.  */
        ecs->event_thread->stepping_over_breakpoint = 1;

        break;

      case BPSTAT_WHAT_LAST:
	/* Not a real code, but listed here to shut up gcc -Wall.  */

d4306 1
@


1.442
log
@2010-06-11  Stan Shebs  <stan@@codesourcery.com>

	Add per-operation permission flags.

	* target.h (struct target_ops): New method to_set_permissions.
	(target_set_permissions): New macro.
	(target_insert_breakpoint): Change macro to function.
	(target_remove_breakpoint): Ditto.
	(target_stop): Ditto.
	(may_write_registers): Declare.
	(may_write_memory): Declare.
	(may_insert_breakpoints): Declare.
	(may_insert_tracepoints): Declare.
	(may_insert_fast_tracepoints): Declare.
	(may_stop): Declare.
	* target.c (may_write_registers, may_write_registers_1): New globals.
	(may_write_memory, may_write_memory_1): New globals.
	(may_insert_breakpoints, may_insert_breakpoints_1): New globals.
	(may_insert_tracepoints, may_insert_tracepoints_1): New globals.
	(may_insert_fast_tracepoints, may_insert_fast_tracepoints_1): New
	globals.
	(may_stop, may_stop_1): New global.
	(target_xfer_partial): Test for write permission.
	(target_store_registers): Ditto.
	(target_insert_breakpoint): New function.
	(target_remove_breakpoint): New function.
	(target_stop): New function.
	(_initialize_targets): Add new set/show variables.
	(set_write_memory_permission): New function.
	(update_target_permissions): New function.
	(set_target_permissions): New function.
	(update_current_target): Default to_set_permissions.
	(_initialize_targets): Use new globals and setter function.
	* tracepoint.c (start_tracing): Test for permission.
	* inferior.h (update_observer_mode): Declare.
	* infrun.c (non_stop_1): Define earlier.
	(observer_mode, observer_mode_1): New globals.
	(set_observer_mode, show_observer_mode): New functions.
	(update_observer_mode): New function.
	(_initialize_infrun): Define "set observer" command.
	* remote.c (PACKET_QAllow): New optional packet.
	(remote_protocol_features): Add QAllow.
	(remote_set_permissions): New function.
	(remote_start_remote): Call it.
	(init_remote_ops): Add it to target vector.
	(_initialize_remote): Add config command for QAllow.

	* gdb.texinfo (Observer Mode): New section.
	(General Query Packets): Document QAllow.

	* gdb.base/permissions.exp: New file.
@
text
@d3168 1
d3192 1
d3230 7
d3326 3
@


1.441
log
@Revert previous change that inadvertently added reset_schedlock, and
revert changes done on top on that.
@
text
@d181 79
a6504 1
static int non_stop_1 = 0;
d6806 13
@


1.440
log
@Add reset_schedlock declaration in target.h.

This patches improves a couple of previous patches:
  - one that introduces reset_schedlock, but failed to add a declarationl;
  - one that was checked in to avoid a compilation failure due to that
    missing declaration.
It also improves the declaration itself to better conform to our coding
practices.  Same for the comments.

2010-05-17  Joel Brobecker  <brobecker@@adacore.com>

        * target.h (reset_schedlock): Add declaration.
        * infrun.c (reset_schedlock): Add missing void in function profile.
        * target.c (target_mourn_inferior): Delete local declaration of
        reset_schedlock.  Style-fix in comment.
@
text
@a1422 13
/* If SCHEDULER_MODE is on, then set it back to off.  Warn the user
   about the change.  */
 
void
reset_schedlock (void)
{
  if (scheduler_mode == schedlock_on)
    {
      warning ("Resetting scheduler-lock mode to 'off'");
      scheduler_mode = schedlock_off;
    }
}

@


1.439
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* infcall.c: White space.
	* inf-child.c: White space.
	* infcmd.c: White space.
	* inferior.c: White space.
	* inf-loop.c: White space.
	* inflow.c: White space.
	* inline-frame.c: White space.
	* interps.c: White space.
@
text
@d1423 2
a1424 1
/* reset_schedlock -- public */
d1427 1
a1427 1
reset_schedlock ()
@


1.438
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* linespec.c (decode_compound): Delete unused variable.
	* dictionary.c (iterator_next_hashed): Delete unused variable.
	* infcall.c (call_function_by_hand): Delete unused variable.
	* infcmd.c (step_1): Delete unused variable.
	(registers_info): Delete unused variable.
	(attach_command): Delete unused variable.
	* infrun.c (follow_exec): Delete unused variable.
	(handle_step_into_function_backwards): Delete unused variable.
	(_initialize_infrun): Delete unused variable.
	* stack.c (parse_frame_specification_1): Delete unused variable.
	(frame_info): Delete unused variable.
	(backtrace_command_1): Delete unused variable.
	(catch_info): Delete unused variable.
@
text
@d712 1
d1214 1
d1241 1
d1266 1
d1423 12
d2009 1
a2010 1

d2271 1
d2744 1
d2898 1
d3370 1
d3709 1
d4161 1
d4350 1
d4489 1
d4538 1
d4577 1
d4595 1
d5104 1
d5114 1
d5482 1
d5570 1
d5579 1
d5588 1
d5872 1
d5971 1
d6368 1
@


1.437
log
@	* infrun.c (prepare_for_detach): In non-stop, context switch to
	the thread that got the event before handling the event.
@
text
@a652 1
  struct target_ops *tgt;
a727 1
      struct inferior *new_inf;
d4885 1
a4885 1
  struct symtab_and_line stop_func_sal, sr_sal;
a6438 1
  struct cmd_list_element *c;
@


1.436
log
@	PR breakpoints/11531.
	* config/i386/nm-i386sol2.h (CANNOT_STEP_HW_WATCHPOINTS): Remove
	macro definition and related comment.
	* infrun.c (CANNOT_STEP_HW_WATCHPOINTS): Remove macro.
	(resume): Remove code and comment related to this macro.

doc ChangeLog entry:
	* gdbint.texinfo (CANNOT_STEP_HW_WATCHPOINTS): Remove explanation
	of macro deleted from GDB code.
@
text
@d2371 8
@


1.435
log
@	PR gdb/11327, PR gdb/11328, PR breakpoints/11368:
	* infrun.c (handle_inferior_event): Change initialization of
	stop_stack_dummy.
	(handle_inferior_event): Change assignment to stop_stack_dummy.
	(normal_stop): Update use of stop_stack_dummy.
	(struct inferior_status) <stop_stack_dummy>: Change type.
	* inferior.h (stop_stack_dummy): Update.
	* infcmd.c (stop_stack_dummy): Change type.
	* infcall.c (cleanup_delete_std_terminate_breakpoint): New
	function.
	(call_function_by_hand): Call set_std_terminate_breakpoint.
	Rewrite std::terminate handling.
	* breakpoint.h (enum bptype) <bp_std_terminate,
	bp_std_terminate_master>: New.
	(enum stop_stack_kind): New.
	(struct bpstat_what) <call_dummy>: Change type.
	(set_std_terminate_breakpoint, delete_std_terminate_breakpoint):
	Declare.
	* breakpoint.c (create_std_terminate_master_breakpoint): New
	function.
	(update_breakpoints_after_exec): Handle bp_std_terminate_master.
	Call create_std_terminate_master_breakpoint.
	(print_it_typical): Handle new breakpoint kinds.
	(bpstat_stop_status): Handle bp_std_terminate_master.
	(bpstat_what): Correctly set call_dummy field.  Handle
	bp_std_terminate_master and bp_std_terminate.
	(print_one_breakpoint_location): Update.
	(allocate_bp_location): Update.
	(set_std_terminate_breakpoint): New function.
	(delete_std_terminate_breakpoint): Likewise.
	(create_thread_event_breakpoint): Update.
	(delete_command): Update.
	(breakpoint_re_set_one): Update.
	(breakpoint_re_set): Call create_std_terminate_master_breakpoint.
@
text
@a181 10
/* Convert the #defines into values.  This is temporary until wfi control
   flow is completely sorted out.  */

#ifndef CANNOT_STEP_HW_WATCHPOINTS
#define CANNOT_STEP_HW_WATCHPOINTS 0
#else
#undef  CANNOT_STEP_HW_WATCHPOINTS
#define CANNOT_STEP_HW_WATCHPOINTS 1
#endif

a1476 12
  /* Some targets (e.g. Solaris x86) have a kernel bug when stepping
     over an instruction that causes a page fault without triggering
     a hardware watchpoint. The kernel properly notices that it shouldn't
     stop, because the hardware watchpoint is not triggered, but it forgets
     the step request and continues the program normally.
     Work around the problem by removing hardware watchpoints if a step is
     requested, GDB will check for a hardware watchpoint trigger after the
     step anyway.  */
  if (CANNOT_STEP_HW_WATCHPOINTS && step)
    remove_hw_watchpoints ();


@


1.434
log
@	* infrun.c (ptid_match): Don't assert that PTID is not a pid ptid.
@
text
@d2907 1
a2907 1
  stop_stack_dummy = 0;
d3973 1
a3973 1
	stop_stack_dummy = 1;
d5463 1
a5463 1
  if (stop_stack_dummy)
d6041 1
a6041 1
  int stop_stack_dummy;
@


1.433
log
@	PR gdb/11321

	* inferior.h (prepare_for_detach): Declare.
	(struct inferior) <detaching>: New field.
	* infrun.c (prepare_for_detach): New.
	(handle_inferior_event) <random signal>: Don't stop if detaching.
	* target.c (target_detach): Call prepare_for_detach.
@
text
@d6328 1
a6328 2
	      && !ptid_equal (ptid, null_ptid)
	      && !ptid_is_pid (ptid));
@


1.432
log
@	Per-process displaced stepping queue.

	* infrun.c (displaced_step_ptid, displaced_step_request_queue)
	(displaced_step_gdbarch, displaced_step_closure,
	(displaced_step_original, displaced_step_copy): Move globals to
	this...
	(struct displaced_step_inferior_state): ... new structure.
	(displaced_step_inferior_states): New global.
	(get_displaced_stepping_state, add_displaced_stepping_state)
	(remove_displaced_stepping_state, infrun_inferior_exit): New
	functions.
	(displaced_step_clear): Add displaced_step_inferior_state
	parameter, and adjust to handle it.
	(displaced_step_clear_cleanup): Parameter is now a
	displaced_step_inferior_state.  Adjust.
	(displaced_step_prepare): Adjust.
	(displaced_step_fixup, displaced_step_fixup)
	(infrun_thread_ptid_changed, resume): Adjust.
	(init_wait_for_inferior): Don't call displaced_step_clear.
	(infrun_thread_stop_requested): Rewrite.
	(_initialize_infrun): Install infrun_inferior_exit as
	inferior_exit observer.
@
text
@d2334 78
d3868 1
d3887 2
a3888 1
	  || signal_stop_state (ecs->event_thread->stop_signal))
@


1.431
log
@	* inferior.h (ptid_match): Declare.
	* infrun.c (ptid_match): New.
	* remote.c (queued_stop_reply): Rewrite and use ptid_match.
	(handle_notification): Add debug output.
	* linux-nat.c (ptid_match): Delete.
@
text
@a894 5
/* If this is not null_ptid, this is the thread carrying out a
   displaced single-step.  This thread's state will require fixing up
   once it has completed its step.  */
static ptid_t displaced_step_ptid;

d901 36
a936 2
/* A queue of pending displaced stepping requests.  */
struct displaced_step_request *displaced_step_request_queue;
d938 1
a938 2
/* The architecture the thread had when we stepped it.  */
static struct gdbarch *displaced_step_gdbarch;
d940 10
a949 3
/* The closure provided gdbarch_displaced_step_copy_insn, to be used
   for post-step cleanup.  */
static struct displaced_step_closure *displaced_step_closure;
d951 2
a952 2
/* The address of the original instruction, and the copy we made.  */
static CORE_ADDR displaced_step_original, displaced_step_copy;
d954 53
a1006 2
/* Saved contents of copy area.  */
static gdb_byte *displaced_step_saved_copy;
d1063 1
a1063 1
displaced_step_clear (void)
d1066 1
a1066 1
  displaced_step_ptid = null_ptid;
d1068 1
a1068 1
  if (displaced_step_closure)
d1070 3
a1072 3
      gdbarch_displaced_step_free_closure (displaced_step_gdbarch,
                                           displaced_step_closure);
      displaced_step_closure = NULL;
d1077 1
a1077 1
displaced_step_clear_cleanup (void *ignore)
d1079 3
a1081 1
  displaced_step_clear ();
d1120 1
d1126 4
a1129 2
  /* For the first cut, we're displaced stepping one thread at a
     time.  */
d1131 1
a1131 1
  if (!ptid_equal (displaced_step_ptid, null_ptid))
d1146 1
a1146 1
      if (displaced_step_request_queue)
d1148 1
a1148 1
	  for (req = displaced_step_request_queue;
d1155 1
a1155 1
	displaced_step_request_queue = new_req;
d1167 1
a1167 1
  displaced_step_clear ();
d1178 1
a1178 1
  displaced_step_saved_copy = xmalloc (len);
d1180 2
a1181 2
				  &displaced_step_saved_copy);
  read_memory (copy, displaced_step_saved_copy, len);
d1186 3
a1188 1
      displaced_step_dump_bytes (gdb_stdlog, displaced_step_saved_copy, len);
d1199 5
a1203 5
  displaced_step_ptid = ptid;
  displaced_step_gdbarch = gdbarch;
  displaced_step_closure = closure;
  displaced_step_original = original;
  displaced_step_copy = copy;
d1205 1
a1205 1
  make_cleanup (displaced_step_clear_cleanup, 0);
d1234 6
d1242 2
a1243 2
  if (ptid_equal (displaced_step_ptid, null_ptid)
      || ! ptid_equal (displaced_step_ptid, event_ptid))
d1246 1
a1246 1
  old_cleanups = make_cleanup (displaced_step_clear_cleanup, 0);
d1250 3
a1252 3
    ULONGEST len = gdbarch_max_insn_length (displaced_step_gdbarch);
    write_memory_ptid (displaced_step_ptid, displaced_step_copy,
		       displaced_step_saved_copy, len);
d1255 2
a1256 2
                          paddress (displaced_step_gdbarch,
				    displaced_step_copy));
d1263 5
a1267 5
      gdbarch_displaced_step_fixup (displaced_step_gdbarch,
                                    displaced_step_closure,
                                    displaced_step_original,
                                    displaced_step_copy,
                                    get_thread_regcache (displaced_step_ptid));
d1275 1
a1275 1
      pc = displaced_step_original + (pc - displaced_step_copy);
d1281 1
a1281 1
  displaced_step_ptid = null_ptid;
d1284 3
a1286 2
     one now.  */
  while (displaced_step_request_queue)
d1295 1
a1295 1
      head = displaced_step_request_queue;
d1297 1
a1297 1
      displaced_step_request_queue = head->next;
d1328 2
a1329 2
	  if (gdbarch_displaced_step_hw_singlestep
		(gdbarch, displaced_step_closure))
d1368 1
a1375 3
  if (ptid_equal (displaced_step_ptid, old_ptid))
    displaced_step_ptid = new_ptid;

d1379 11
a1389 3
  for (it = displaced_step_request_queue; it; it = it->next)
    if (ptid_equal (it->ptid, old_ptid))
      it->ptid = new_ptid;
d1526 2
d1541 3
a1543 2
      step = gdbarch_displaced_step_hw_singlestep
	       (gdbarch, displaced_step_closure);
a2064 2
  displaced_step_clear ();

d2208 1
a2208 1
  struct displaced_step_request *it, *next, *prev = NULL;
d2212 4
a2215 1
  for (it = displaced_step_request_queue; it; it = next)
d2217 1
a2217 1
      next = it->next;
d2219 3
a2221 4
      if (ptid_equal (it->ptid, ptid)
	  || ptid_equal (minus_one_ptid, ptid)
	  || (ptid_is_pid (ptid)
	      && ptid_get_pid (ptid) == ptid_get_pid (it->ptid)))
d2223 6
a2228 2
	  if (displaced_step_request_queue == it)
	    displaced_step_request_queue = it->next;
d2230 3
a2232 1
	    prev->next = it->next;
d2234 1
a2234 1
	  xfree (it);
a2235 2
      else
	prev = it;
a6630 1
  displaced_step_ptid = null_ptid;
d6635 1
@


1.430
log
@	* tracepoint.h (set_traceframe_number)
	(cleanup_restore_current_traceframe): Declare.
	* tracepoint.c (set_traceframe_number): New.
	(struct current_traceframe_cleanup): New.
	(do_restore_current_traceframe_cleanup)
	(restore_current_traceframe_cleanup_dtor)
	(make_cleanup_restore_current_traceframe): New.
	* infrun.c: Include tracepoint.h.
	(fetch_inferior_event): Switch out and in of tfind mode.
@
text
@d6129 20
@


1.429
log
@	* infrun.c (handle_inferior_event): Do not look up regcache
	for exited processes.
@
text
@d54 1
d1765 10
@


1.429.2.1
log
@	* tracepoint.h (set_traceframe_number)
	(cleanup_restore_current_traceframe): Declare.
	* tracepoint.c (set_traceframe_number): New.
	(struct current_traceframe_cleanup): New.
	(do_restore_current_traceframe_cleanup)
	(restore_current_traceframe_cleanup_dtor)
	(make_cleanup_restore_current_traceframe): New.
	* infrun.c: Include tracepoint.h.
	(fetch_inferior_event): Switch out and in of tfind mode.
@
text
@a53 1
#include "tracepoint.h"
a1763 10
  /* We're handling a live event, so make sure we're doing live
     debugging.  If we're looking at traceframes while the target is
     running, we're going to need to get back to that mode after
     handling the event.  */
  if (non_stop)
    {
      make_cleanup_restore_current_traceframe ();
      set_traceframe_number (-1);
    }

@


1.428
log
@	* infrun.c (prepare_to_proceed): Handle other signals which might
	match a breakpoint.
	(handle_inferior_event): Move the check for unusual breakpoint
	signals earlier.

	gdbserver/
	* linux-low.c (get_stop_pc): Check for SIGTRAP.
	(linux_wait_for_event_1): Handle SIGILL and SIGSEGV as possible
	breakpoints.
@
text
@a2666 1
  struct regcache *regcache;
a2736 1
  regcache = get_thread_regcache (ecs->ptid);
d2740 1
a2740 3
	  || ecs->ws.value.sig == TARGET_SIGNAL_EMT)
      && breakpoint_inserted_here_p (get_regcache_aspace (regcache),
				     regcache_read_pc (regcache)))
d2742 10
a2751 4
      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog,
			    "infrun: Treating signal as SIGTRAP\n");
      ecs->ws.value.sig = TARGET_SIGNAL_TRAP;
@


1.427
log
@Delete unused or undefined functions.

        * breakpoint.c (ep_parse_optional_filename): Delete.
        * dcache.c (dcache_write_line): Remove declaration.
        * infrun.c (build_infrun): Remove declaration.
        * tracepoint.c (tracepoint_save_command): Remove declaration.
        * linux-nat.c (init_lwp_list): Delete. No longer used.
        * event-loop.c (check_async_signal_handlers): Delete declaration.
        * infrun.c (init_execution_control_state): Delete.
        (proceed): Update comment to avoid mentioning
        init_execution_control_state.
        * target.c (kill_or_be_killed, nosupport_runtime): Delete.
        * ada-lang.c (ada_to_static_fixed_value): Delete.
        * scm-lang.c (evaluate_subexp_scm): Delete declaration.
        * cp-namespace.c (cp_copy_usings): Delete.
        * xml-syscall.c (xml_number_of_syscalls): Delete.
        * progspace.c (find_program_space_by_num): Delete.
        * inflow.c (handle_sigio): Delete declaration.
        * hppa-tdep.c (hppa_alignof): Delete.
        * mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset)
        (mipsnbsd_core_osabi_sniffer): Delete.
@
text
@d1643 4
a1646 1
      || wait_status.value.sig != TARGET_SIGNAL_TRAP)
d2667 1
d2728 24
a3530 14
  /* First, distinguish signals caused by the debugger from signals
     that have to do with the program's own actions.  Note that
     breakpoint insns may cause SIGTRAP or SIGILL or SIGEMT, depending
     on the operating system version.  Here we detect when a SIGILL or
     SIGEMT is really a breakpoint and change it to SIGTRAP.  We do
     something similar for SIGSEGV, since a SIGSEGV will be generated
     when we're trying to execute a breakpoint instruction on a
     non-executable stack.  This happens for call dummy breakpoints
     for architectures like SPARC that place call dummies on the
     stack.

     If we're doing a displaced step past a breakpoint, then the
     breakpoint is always inserted at the original instruction;
     non-standard signals can't be explained by the breakpoint.  */
a3531 6
      || (! ecs->event_thread->trap_expected
          && breakpoint_inserted_here_p (get_regcache_aspace (get_current_regcache ()),
					 stop_pc)
	  && (ecs->event_thread->stop_signal == TARGET_SIGNAL_ILL
	      || ecs->event_thread->stop_signal == TARGET_SIGNAL_SEGV
	      || ecs->event_thread->stop_signal == TARGET_SIGNAL_EMT))
@


1.426
log
@GDB crash while stepping into function.

        * infrun.c (handle_inferior_event): Refetch the current frame
        after handling what.main_action, in case that pointer became
        dangling.
@
text
@a70 2
static void build_infrun (void);

d1857 8
a1864 7
     An attempt was made to have init_execution_control_state () refresh
     the prev_pc value before calculating the line number.  This approach
     did not work because on platforms that use ptrace, the pc register
     cannot be read unless the inferior is stopped.  At that point, we
     are not guaranteed the inferior is stopped and so the regcache_read_pc ()
     call can fail.  Setting the prev_pc value here ensures the value is 
     updated correctly when the inferior is stopped.  */
a2000 2
static void init_execution_control_state (struct execution_control_state *ecs);

a2402 9
/* Prepare an execution control state for looping through a
   wait_for_inferior-type loop.  */

static void
init_execution_control_state (struct execution_control_state *ecs)
{
  ecs->random_signal = 0;
}

@


1.425
log
@gdb/
	Add from_tty to solib_create_inferior_hook.
	* infcmd.c (post_create_inferior): Move solib_add after
	solib_create_inferior_hook.  Pass from_tty to
	solib_create_inferior_hook.  Call solib_add and SOLIB_ADD with
	0 from_tty and comment why.
	* infrun.c (follow_exec): Pass from_tty solib_create_inferior_hook as 0.
	* linux-nat.c (linux_child_follow_fork): Likewise.
	* nto-procfs.c (procfs_post_attach, procfs_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): New parameter
	from_tty.
	* solib-frv.c (frv_solib_create_inferior_hook): Likewise.
	* solib-irix.c (irix_solib_create_inferior_hook): Likewise.
	* solib-null.c (null_solib_create_inferior_hook): Likewise.
	* solib-osf.c (osf_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-som.c (som_solib_create_inferior_hook): Likewise.
	* solib-spu.c (spu_solib_create_inferior_hook): New parameter from_tty.
	Pass it to svr4_so_ops.solib_create_inferior_hook.
	* solib-sunos.c (sunos_solib_create_inferior_hook): New parameter
	from_tty.
	* solib-svr4.c (enable_break): New parameter from_tty.  Pass it to
	solib_add.
	(svr4_solib_create_inferior_hook): New parameter from_tty.  Pass it to
	enable_break.
	* solib-target.c (solib_target_solib_create_inferior_hook): New
	parameter from_tty.
	* solib.c (solib_create_inferior_hook): New parameter from_tty.  Pass
	it to ops->solib_create_inferior_hook.
	(reload_shared_libraries): Pass from_tty to solib_create_inferior_hook.
	Move solib_add after solib_create_inferior_hook, call it now with
	from_tty as 0.  New comment there.
	* solib.h (solib_create_inferior_hook): New parameter from_tty.
	* solist.h (struct target_so_ops <solib_create_inferior_hook>):
	Likewise.
@
text
@d4069 5
@


1.424
log
@	Fix multiexec race.
	* infrun.c (handle_inferior_event): Use get_thread_regcache
	with events ptid, not get_current_regcache.
@
text
@d767 1
a767 1
  solib_create_inferior_hook ();
@


1.423
log
@2010-01-05  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (handle_inferior_event): Fix typo in comment.
@
text
@d3235 2
a3236 1
      struct address_space *aspace = get_regcache_aspace (get_current_regcache ());
@


1.422
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d4179 1
a4179 1
     have code_addr == &_start.  See the commend in frame_id_eq
@


1.421
log
@	* infrun.c (handle_inferior_event): Hardware hatchpoint traps are
	never random signals.
	* breakpoint.c (update_global_location_list): Always delete
	immediately delete hardware watchpoint locations and other
	locations whose target address isn't meaningful.  Update comment
	explaining the hazard of moribund locations.
@
text
@d6 1
a6 1
   2008, 2009 Free Software Foundation, Inc.
@


1.420
log
@gdb/
	Fix wrong debug output with `set debug infrun 1'.
	* gdb/infrun.c (handle_inferior_event <debug_infrun>): New variable
	old_chain.  Temporarily switch INFERIOR_PTID.
	* target.h (target_stopped_by_watchpoint): Extend the comment.
	(target_stopped_data_address): New comment.
@
text
@d3596 15
d3634 1
@


1.419
log
@	* infrun.c (handle_inferior_event): When handling a fork or vfork
	event, check if the bpstat causes a stop, instead of if it
	explains the signal.
	* breakpoint.c (bpstat_causes_stop): New.
	* breakpoint.h (bpstat_causes_stop): Declare.
@
text
@d3138 3
d3157 2
@


1.418
log
@	* breakpoint.c (should_be_inserted): Don't insert breakpoints if
	the pspace doesn't allow breakpoints.
	(insert_breakpoint_locations): Remove waiting_for_vfork_done
	special case.  Expect watchpoints that shouldn't be inserted, to
	not be inserted.
	* progspace.h (struct program_space) <breakpoints_not_allowed>:
	New field.
	* infrun.c (handle_inferior_event): Clear it.
	* linux-nat.c (linux_child_follow_fork): Set it.
@
text
@d2949 5
a2953 1
      ecs->random_signal = !bpstat_explains_signal (ecs->event_thread->stop_bpstat);
@


1.417
log
@2009-11-13  Pedro Alves  <pedro@@codesourcery.com>

	* infrun.c (handle_inferior_event): Set stop_print_frame on
	TARGET_WAITKIND_LOADED events, if stopping on solib-events.
@
text
@d3007 1
@


1.416
log
@	* infrun.c (keep_going): Wrap with resume_cleanups.
@
text
@d2824 4
@


1.415
log
@2009-10-22  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (keep_going): If insert_breakpoints fails,
	print the reason.
@
text
@d4815 4
d4832 2
d4896 1
@


1.414
log
@2009-10-20  Michael Snyder  <msnyder@@msnyder-server.eng.vmware.com>

	* infrun.c (handle_inferior_event): Add pspace field to sal
	for reverse execution cases.
@
text
@d4866 1
@


1.413
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d4264 1
d4332 1
@


1.412
log
@	* linux-nat.c (linux_nat_wait_1): Bail out, if TARGET_WNOHANG and
	we found no event while waiting for a specific LWP.
	* infrun.c (handle_inferior_event): Handle TARGET_WAITKIND_IGNORE
	before anything else.
@
text
@d112 3
d467 192
d666 1
d688 3
d708 3
a710 1
  printf_unfiltered (_("Executing new program: %s\n"), execd_pathname);
a728 3
  /* That a.out is now the one to use. */
  exec_file_attach (execd_pathname, 0);

d737 24
d1194 1
d1205 1
d1207 1
a1207 1
      if (breakpoint_here_p (actual_pc))
d1372 1
d1398 1
a1398 1
  if (breakpoint_here_p (pc) == permanent_breakpoint_here)
d1515 1
a1515 1
	  if (step && breakpoint_inserted_here_p (pc))
d1589 9
d1604 2
a1605 2
	  /* If in non-stop mode, only delete the per-thread status
	     of the current thread.  */
d1608 1
a1608 7
      else
	{
	  /* In all-stop mode, delete the per-thread status of
	     *all* threads.  */
	  iterate_over_threads (clear_proceed_status_callback, NULL);
	}
  
d1670 2
a1671 1
      if (breakpoint_here_p (regcache_read_pc (regcache)))
d1709 1
d1724 1
d1734 1
a1734 1
      if (pc == stop_pc && breakpoint_here_p (pc) 
d2465 1
d2531 2
d2546 2
a2547 2
  if (software_breakpoint_inserted_here_p (breakpoint_pc)
      || (non_stop && moribund_breakpoint_here_p (breakpoint_pc)))
d2648 3
a2650 1
      ecs->event_thread->stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);
d2861 3
d2882 3
d2941 3
a2943 1
      ecs->event_thread->stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);
d2950 2
d2953 1
d2959 21
d2992 16
d3020 3
d3028 3
a3030 1
      ecs->event_thread->stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);
d3221 1
d3226 1
a3226 1
      if (regular_breakpoint_inserted_here_p (stop_pc))
d3229 1
a3229 1
	  if (!breakpoint_thread_match (stop_pc, ecs->ptid))
d3516 2
a3517 1
          && breakpoint_inserted_here_p (stop_pc)
d3574 4
a3577 2
      ecs->event_thread->stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);
      
d4108 1
d4219 3
a4221 2
		  insert_step_resume_breakpoint_at_sal (gdbarch,
							sr_sal, null_frame_id);
d4246 1
d4293 1
d4359 1
d4639 1
d4731 1
d4768 1
d5272 5
d6348 24
d6430 8
@


1.411
log
@	* linux-nat.c (TRAP_IS_SYSCALL, TRAP_REMOVE_SYSCALL_FLAG): Delete.
	(SYSCALL_SIGTRAP): New.
	(status_to_str): Adjust.
	(get_pending_status): Pending events in lp->waitstatus don't map
	to any signal.  Simplify.
	(linux_handle_syscall_trap): New.
	(linux_handle_extended_wait): When handling PTRACE_EVENT_CLONE
	events, use linux_ops->to_resume instead of direct ptrace with
	PTRACE_CONT.  Remove all TRAP_IS_SYSCALL handling.
	(wait_lwp): Handle syscall traps with linux_handle_syscall_trap,
	and clear the sysgood bit.
	(status_callback): Make it clearer and add comments.
	(cancel_breakpoints_callback): Ignore if LP has waitstatus set.
	(linux_nat_filter_event): Handle syscall traps with
	linux_handle_syscall_trap, and clear the sysgood bit.  Move the
	check for storing siginfo to after handling extended statuses and
	syscall traps.  Store status in the lwp object.
	(linux_wait_1): Don't swap the pending status out of the lwp
	object until after deciding we found an lwp with an interesting
	event.  Requeue a new pending signal if we find one while getting
	rid or a pending SIGSTOP we sent ourselves.  Don't clear the
	sysgood bit here.

	* infrun.c (deal_with_syscall_event): Rename to ...
	(handle_syscall_event): ... this.  Always context switch and set
	stop_pc, even if not catching the syscall.  If not catching the
	syscall, always resume with keep_going.
	(handle_inferior_event): Adjust.
@
text
@d2446 17
d2464 1
a2464 2
      && ecs->ws.kind != TARGET_WAITKIND_SIGNALLED
      && ecs->ws.kind != TARGET_WAITKIND_IGNORE)
d2498 1
a2498 3
  if (ecs->ws.kind != TARGET_WAITKIND_IGNORE)
    {
      breakpoint_retire_moribund ();
d2500 11
a2510 12
      /* Mark the non-executing threads accordingly.  In all-stop, all
	 threads of all processes are stopped when we get any event
	 reported.  In non-stop mode, only the event thread stops.  If
	 we're handling a process exit in non-stop mode, there's
	 nothing to do, as threads of the dead process are gone, and
	 threads of any other process were left running.  */
      if (!non_stop)
	set_executing (minus_one_ptid, 0);
      else if (ecs->ws.kind != TARGET_WAITKIND_SIGNALLED
	       && ecs->ws.kind != TARGET_WAITKIND_EXITED)
	set_executing (inferior_ptid, 0);
    }
a2792 15

      /* We had an event in the inferior, but we are not interested
         in handling it at this level. The lower layers have already
         done what needs to be done, if anything.

         One of the possible circumstances for this is when the
         inferior produces output for the console. The inferior has
         not stopped, and we are ignoring the event.  Another possible
         circumstance is any event which the lower level knows will be
         reported multiple times without an intervening resume.  */
    case TARGET_WAITKIND_IGNORE:
      if (debug_infrun)
        fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_IGNORE\n");
      prepare_to_wait (ecs);
      return;
@


1.410
log
@	* gdbarch.sh (displaced_step_hw_singlestep): New callback.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c (default_displaced_step_hw_singlestep): New function.
	* arch-utils.h (default_displaced_step_hw_singlestep): Add prototype.

	* ppc-linux-tdep.c (ppc_displaced_step_hw_singlestep): New function.
	(rs6000_gdbarch_init): Install it.

	* infrun.c (displaced_step_fixup): Use new callback to determine
	whether to "step" or "continue" displaced copy.
	(resume): Likewise.  Do not call maybe_software_singlestep
	for displaced stepping.
	(maybe_software_singlestep): Do not handle displaced stepping.
@
text
@d2389 1
d2391 1
a2391 1
deal_with_syscall_event (struct execution_control_state *ecs)
d2393 12
a2404 4
  struct regcache *regcache = get_thread_regcache (ecs->ptid);
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  int syscall_number = gdbarch_get_syscall_number (gdbarch,
                                                   ecs->ptid);
a2412 9
      ecs->event_thread->stop_signal = TARGET_SIGNAL_TRAP;

      if (!ptid_equal (ecs->ptid, inferior_ptid))
        {
          context_switch (ecs->ptid);
          reinit_frame_cache ();
        }

      stop_pc = regcache_read_pc (get_thread_regcache (ecs->ptid));
a2414 1

d2417 6
a2422 14
      /* If no catchpoint triggered for this, then keep going.  */
      if (ecs->random_signal)
        {
          ecs->event_thread->stop_signal = TARGET_SIGNAL_0;
          keep_going (ecs);
          return 1;
        }
      return 0;
    }
  else
    {
      resume (0, TARGET_SIGNAL_0);
      prepare_to_wait (ecs);
      return 1;
d2424 5
d2752 1
a2752 1
      if (deal_with_syscall_event (ecs) != 0)
a2754 1
      break;
d2764 1
a2764 1
      if (deal_with_syscall_event (ecs) != 0)
a2766 1
      break;
@


1.409
log
@Implementing catch syscall.

* amd64-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(amd64_linux_get_syscall_number): New function.
(amd64_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* breakpoint.c: New include: xml-syscall.h.
(set_raw_breakpoint_without_location): Setting the parameters
for the catch syscall feature.
(insert_catch_syscall): New.
(remove_catch_syscall): New.
(breakpoint_hit_catch_syscall): New.
(print_it_catch_syscall): New.
(print_one_catch_syscall): New.
(print_mention_catch_syscall): New.
(catch_syscall_breakpoint_ops): New.
(syscall_catchpoint_p): New.
(create_catchpoint_without_mention): New.
(create_catchpoint): Modified in order to use
create_catchpoint_without_mention.
(create_syscall_event_catchpoint): New.
(clean_up_filters): New.
(catch_syscall_split_args): New.
(catch_syscall_command_1): New.
(delete_breakpoint): Add cleanup for catch syscall.
(is_syscall_catchpoint_enabled): New.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
(catch_syscall_completer): New completer function.
(add_catch_command): Add the completer function for catchpoints.
* breakpoint.h (syscalls_to_be_caught): New vector.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
* gdbarch.c: Regenerated.
* gdbarch.h: Regenerated.
* gdbarch.sh: Add syscall catchpoint functions and structures.
(get_syscall_number): New.
(UNKNOWN_SYSCALL): New definition.
* i386-linux-nat.c (i386_linux_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* i386-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(i386_linux_get_syscall_number): New.
(i386_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* inf-child.c (inf_child_set_syscall_catchpoint): New.
(inf_child_target): Assign default values to target_ops.
* inf-ptrace.c (inf_ptrace_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* inferior.h (struct inferior): Included new variables
any_syscall_count, syscalls_counts and total_syscalls_count,
used to keep track of requested syscall catchpoints.
* infrun.c (resume): Add syscall catchpoint.
(deal_with_syscall_event): New.
(handle_inferior_event): Add syscall entry/return events.
(inferior_has_called_syscall): New.
* linux-nat.c: Define some helpful variables to track wether we have
support for the needed ptrace option.
(linux_test_for_tracesysgood): New.
(linux_supports_tracesysgood): New.
(linux_enable_tracesysgood): New.
(linux_enable_event_reporting): Save the current used ptrace
options.
(linux_child_post_attach): Calling linux_enable_tracesysgood.
(linux_child_post_startup_inferior): Likewise.
(linux_child_set_syscall_catchpoint): New function.
(linux_handle_extended_wait): Handle the case which the inferior stops
because it has called or returned from a syscall.
(linux_target_install_ops): Install the necessary functions to handle
syscall catchpoints.
* linux-nat.h (struct lwp_info): Include syscall_state into the
structure, which indicates if we are in a syscall entry or return.
* ppc-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall filename for the arch.
(ppc_linux_get_syscall_number): New.
(ppc_linux_init_abi): Register the correct functions for syscall
catchpoint; setting the correct name for the XML syscall file.
* target.c (update_current_target): Update/copy functions related to
syscall catchpoint.
(target_waitstatus_to_string): Add syscall catchpoint entry/return
events.
* target.h (struct target_waitstatus): Add syscall number.
(struct syscall): New struct to hold information about syscalls
in the system.
(struct target_ops): Add ops for syscall catchpoint.
(inferior_has_called_syscall): New.
(target_set_syscall_catchpoint): New.
* xml-support.c (xml_fetch_content_from_file): New function,
transferred from xml-tdesc.c.
* xml-support.h (xml_fetch_content_from_file): New.
* xml-tdesc.c (fetch_xml_from_file): Function removed;
transferred to xml-support.c.
(file_read_description_xml): Updated to use the new
xml_fetch_content_from_file function.
* syscalls/gdb-syscalls.dtd: New definition file for syscall's XML
support.
* syscalls/amd64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use amd64 architecture.
* syscalls/i386-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use i386 architecture.
* syscalls/ppc-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC architecture.
* syscalls/ppc64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC64 architecture.
* xml-syscall.c: New file containing functions for manipulating
syscall's XML files.
* xml-syscall.h: New file, exporting the functions above mentioned.
* Makefile.in: Support for relocatable GDB datadir and XML
syscall.
* NEWS: Added information about the catch syscall feature.
* doc/gdb.texinfo (Set Catchpoints): Documentation about the new
feature.
* testsuite/Makefile.in: Inclusion of catch-syscall object.
* testsuite/gdb.base/catch-syscall.c: New file.
* testsuite/gdb.base/catch-syscall.exp: New file.
@
text
@d1005 4
a1008 1
	  if (gdbarch_software_single_step_p (gdbarch))
a1009 2
	  else
	    target_resume (ptid, 1, TARGET_SIGNAL_0);
d1118 2
a1119 1
  if (gdbarch_software_single_step_p (gdbarch))
d1121 6
a1126 11
      if (use_displaced_stepping (gdbarch))
        hw_step = 0;
      else if (gdbarch_software_single_step (gdbarch, get_current_frame ()))
	{
	  hw_step = 0;
	  /* Do not pull these breakpoints until after a `wait' in
	     `wait_for_inferior' */
	  singlestep_breakpoints_inserted_p = 1;
	  singlestep_ptid = inferior_ptid;
	  singlestep_pc = pc;
	}
d1208 3
d1214 1
a1214 1
  if (step)
@


1.409.2.1
log
@	* gdbarch.sh (displaced_step_hw_singlestep): New callback.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c (default_displaced_step_hw_singlestep): New function.
	* arch-utils.h (default_displaced_step_hw_singlestep): Add prototype.

	* ppc-linux-tdep.c (ppc_displaced_step_hw_singlestep): New function.
	(rs6000_gdbarch_init): Install it.

	* infrun.c (displaced_step_fixup): Use new callback to determine
	whether to "step" or "continue" displaced copy.
	(resume): Likewise.  Do not call maybe_software_singlestep
	for displaced stepping.
	(maybe_software_singlestep): Do not handle displaced stepping.
@
text
@d1005 3
a1007 2
	  if (gdbarch_displaced_step_hw_singlestep
		(gdbarch, displaced_step_closure))
a1008 2
	  else
	    target_resume (ptid, 0, TARGET_SIGNAL_0);
d1117 1
a1117 2
  if (gdbarch_software_single_step_p (gdbarch)
      && gdbarch_software_single_step (gdbarch, get_current_frame ()))
d1119 11
a1129 6
      hw_step = 0;
      /* Do not pull these breakpoints until after a `wait' in
	 `wait_for_inferior' */
      singlestep_breakpoints_inserted_p = 1;
      singlestep_ptid = inferior_ptid;
      singlestep_pc = pc;
a1210 3

      step = gdbarch_displaced_step_hw_singlestep
	       (gdbarch, displaced_step_closure);
d1214 1
a1214 1
  else if (step)
@


1.408
log
@        gdb/
        * frame.c (get_frame_id): Default to outer_frame_id if the this_id
        method does not supply an ID.  Assert that the result is not
        null_frame_id.
        (outer_frame_id): New.
        (frame_id_p): Accept outer_frame_id.
        (frame_id_eq): Allow outer_frame_id to be equal to itself.
        (frame_find_by_id): Revert previous local workarounds.
        (get_prev_frame_1): Adjust end-of-stack check to test outer_frame_id.
        * frame.h (null_frame_id, frame_id_p): Update comments.
        (outer_frame_id): Declare.
        * infrun.c (handle_inferior_event): Do not treat all steps from the
        outermost frame as subroutine calls.

        * libunwind-frame.c (libunwind_frame_this_id): Do not clear THIS_ID.
        * hppa-tdep.c (hppa_stub_frame_this_id): Likewise.
        * ia64-tdep.c (ia64_frame_this_id): Likewise.
        (ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id):
        Use outer_frame_id instead of null_frame_id.
        * amd64obsd-tdep.c (amd64obsd_trapframe_cache): Use outer_frame_id.
        * i386obsd-tdep.c (i386obsd_trapframe_cache): Likewise.
        * inline-frame.c (inline_frame_this_id): Refuse outer_frame_id.
        * thread.c (restore_selected_frame): Update comment and remove
        frame_id_p check.

        gdb/doc/
        * gdbint.texinfo (Unwinding the Frame ID): Reference outer_frame_id.
@
text
@d2045 4
d2385 50
d2755 5
a2759 3
      resume (0, TARGET_SIGNAL_0);
      prepare_to_wait (ecs);
      return;
d2769 4
a2772 3
      target_resume (ecs->ptid, 1, TARGET_SIGNAL_0);
      prepare_to_wait (ecs);
      return;
d5686 19
@


1.407
log
@	* jit.c (jit_read_descriptor): New arg gdbarch, all callers updated.
	(jit_read_code_entry, jit_register_code): Ditto.
	(jit_event_handler): Ditto.
	(jit_inferior_init): Renamed from previous jit_inferior_created_hook.
	(jit_inferior_created_hook, jit_breakpoint_re_set): New functions.
	(jit_inferior_created_observer): Renamed from
	jit_inferior_created_hook1, all callers updated.
	* jit.h (jit_breakpoint_re_set): Declare.
	(jit_event_handler): Update prototype.
	* breakpoint.c (breakpoint_re_set): Call jit_breakpoint_re_set instead
	of jit_inferior_created_hook.
@
text
@d3799 9
d3810 5
a3814 2
      && frame_id_eq (frame_unwind_caller_id (frame),
		      ecs->event_thread->step_stack_frame_id))
@


1.406
log
@	Add interface for JIT code generation.
	* NEWS: Announce JIT interface.
	* Makefile.in (SFILES): Add jit.c.
	(HFILES_NO_SRCDIR): Add jit.h.
	(COMMON_OBS): Add jit.o.
	* jit.c: New file.
	* jit.h: New file.
	* breakpoint.h (enum bptype): Add bp_jit_event to enum.
	* breakpoint.c:
	(update_breakpoints_after_exec): Delete jit breakpoints after exec.
	(bpstat_what): Update event table for bp_jit_event.
	(print_it_typical): Added case for bp_jit_event.
	(print_one_breakpoint_location): Added case for bp_jit_event.
	(allocate_bp_location): Added case for bp_jit_event.
	(mention): Added case for bp_jit_event.
	(delete_command): Added case for bp_jit_event.
	(breakpoint_re_set_one): Added case for bp_jit_event.
	(breakpoint_re_set): Added call to jit_inferior_created_hook.
	(create_jit_event_breakpoint): New.
	* infrun.c (handle_inferior_event): Add handler for jit event.
	(follow_exec): Add call to jit_inferior_created_hook.
	* doc/gdb.texinfo: Add chapter on JIT interface.
@
text
@d3553 1
a3553 1
        jit_event_handler ();
@


1.405
log
@	* ui-file.h (ui_file_xstrdup): Mention that the length argument
	may be NULL.
	* ui-file.c (ui_file_xstrdup): Don't dereference LENGTH if it is
	NULL.
	* aix-thread.c (aix_thread_extra_thread_info): Pass NULL as length
	parameter to ui_file_xstrdup.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* infrun.c (print_target_wait_results): Ditto.
	* language.c (add_language): Ditto.
	* linespec.c (cplusplus_error): Ditto.
	* remote.c (escape_buffer): Ditto.
	* typeprint.c (type_to_string): Ditto.
	* utils.c (error_stream): Ditto.
	* varobj.c (value_get_print_value): Ditto.
	* xtensa-tdep.c (xtensa_verify_config): Replace `dummy' local with
	`length' local.  Pass it to ui_file_xstrdup, and avoid an strlen
	call.
	* gdbarch.sh (verify_gdbarch): Ditto.
	* gdbarch.c: Regenerate.
	* cli/cli-setshow.c (do_setshow_command): Pass NULL as length
	parameter to ui_file_xstrdup.
	* python/python-frame.c (frapy_str): Ditto.
	* python/python-type.c (typy_str): Use the length local instead of
	calling strlen.
	* python/python-value.c (valpy_str): Pass NULL as length parameter
	to ui_file_xstrdup.
@
text
@d53 1
d548 2
d3546 16
@


1.404
log
@	* infrun.c (displaced_step_fixup): If this is a software
	single-stepping arch, don't tell the target to single-step.
	(maybe_software_singlestep): Return 0 if we're using displaced
	stepping.
	(resume): If this is a software single-stepping arch, and
	displaced-stepping is enabled, use it for all single-step
	requests.
@
text
@a1945 1
  long len;
d1965 1
a1965 1
  text = ui_file_xstrdup (tmp_stream, &len);
@


1.403
log
@	* infrun.c (handle_inferior_event): Clear trap_expected after
	stepping past a single-step breakpoint.
@
text
@d967 1
d989 2
d993 1
a993 1
	      struct gdbarch *gdbarch = get_regcache_arch (regcache);
d1002 4
a1005 1
	  target_resume (ptid, 1, TARGET_SIGNAL_0);
d1114 1
a1114 2
  if (gdbarch_software_single_step_p (gdbarch)
      && gdbarch_software_single_step (gdbarch, get_current_frame ()))
d1116 11
a1126 6
      hw_step = 0;
      /* Do not pull these breakpoints until after a `wait' in
	 `wait_for_inferior' */
      singlestep_breakpoints_inserted_p = 1;
      singlestep_ptid = inferior_ptid;
      singlestep_pc = pc;
d1192 2
a1193 1
      && tp->trap_expected
@


1.402
log
@	* infrun.c (wait_for_inferior): Invalidate registers and overlay
	cache every time before calling target_wait.
	(handle_inferior_event): Make static. Always reset waiton_ptid.
	Never call registers_changed.
	(prepare_to_wait): Do not invaliate registers or overlay cache
	(moved to wait_for_inferior).  Do not reset waiton_ptid (moved
	to handle_inferior_event).
	(fetch_inferior_event): Remove check for always-true condition.
@
text
@d2816 1
@


1.401
log
@2009-07-18  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (handle_inferior_event): Remove an execution_direction
	check in the "check for subroutine calls" test, and add some
	additional handling for reverse-stepping through shared libraries.
@
text
@d1759 1
a1759 1
void handle_inferior_event (struct execution_control_state *ecs);
a1995 2
  overlay_cache_invalid = 1;

a1998 8
  /* We have to invalidate the registers BEFORE calling target_wait
     because they can be loaded from the target while in target_wait.
     This makes remote debugging a bit more efficient for those
     targets that provide critical registers as part of their normal
     status mechanism. */

  registers_changed ();

d2003 9
d2065 2
a2066 8
  overlay_cache_invalid = 1;

  /* We can only rely on wait_for_more being correct before handling
     the event in all-stop, but previous_inferior_ptid isn't used in
     non-stop.  */
  if (!ecs->wait_some_more)
    /* We'll update this if & when we switch to a new thread.  */
    previous_inferior_ptid = inferior_ptid;
d2081 1
d2372 1
a2372 1
void
a2440 2
      /* Cancel the waiton_ptid. */
      waiton_ptid = pid_to_ptid (-1);
d2471 1
d2473 1
a2999 1
	      registers_changed ();
a3073 1
      registers_changed ();
a4510 3
  if (infwait_state == infwait_normal_state)
    {
      overlay_cache_invalid = 1;
a4511 9
      /* We have to invalidate the registers BEFORE calling
         target_wait because they can be loaded from the target while
         in target_wait.  This makes remote debugging a bit more
         efficient for those targets that provide critical registers
         as part of their normal status mechanism. */

      registers_changed ();
      waiton_ptid = pid_to_ptid (-1);
    }
@


1.400
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d3779 2
a3780 3
      && (frame_id_eq (frame_unwind_caller_id (frame),
		       ecs->event_thread->step_stack_frame_id)
	  || execution_direction == EXEC_REVERSE))
d3808 1
d3926 32
@


1.399
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@d869 2
a870 2
      fprintf_unfiltered (gdb_stdlog, "displaced: saved 0x%s: ",
			  paddr_nz (copy));
d898 2
a899 2
    fprintf_unfiltered (gdb_stdlog, "displaced: displaced pc to 0x%s\n",
			paddr_nz (copy));
d931 3
a933 2
      fprintf_unfiltered (gdb_stdlog, "displaced: restored 0x%s\n",
                          paddr_nz (displaced_step_copy));
d966 1
d976 2
a977 1
      actual_pc = regcache_read_pc (get_thread_regcache (ptid));
d990 1
d993 2
a994 2
	      fprintf_unfiltered (gdb_stdlog, "displaced: run 0x%s: ",
				  paddr_nz (actual_pc));
d1285 1
d1289 2
a1290 2
          fprintf_unfiltered (gdb_stdlog, "displaced: run 0x%s: ",
                              paddr_nz (actual_pc));
d1515 2
a1516 2
			"infrun: proceed (addr=0x%s, signal=%d, step=%d)\n",
			paddr_nz (addr), siggnal, step);
d2782 5
a2786 2
      fprintf_unfiltered (gdb_stdlog, "infrun: stop_pc = 0x%s\n",
                          paddr_nz (stop_pc));
d2794 2
a2795 2
                                "infrun: stopped data address = 0x%s\n",
                                paddr_nz (addr));
d3691 4
a3694 3
	fprintf_unfiltered (gdb_stdlog, "infrun: stepping inside range [0x%s-0x%s]\n",
			    paddr_nz (ecs->event_thread->step_range_start),
			    paddr_nz (ecs->event_thread->step_range_end));
d4291 2
a4292 2
			"infrun: inserting step-resume breakpoint at 0x%s\n",
			paddr_nz (sr_sal.pc));
d4373 2
a4374 2
			"infrun: inserting longjmp-resume breakpoint at 0x%s\n",
			paddr_nz (pc));
@


1.398
log
@	* gdbtypes.h (struct builtin_type): Add internal_fn member.
	* gdbtypes.c (gdbtypes_post_init): Initialize it.
	* value.c (internal_fn_type): Remove.
	(_initialize_values): Do not initialize it.

	* value.c (struct internalvar): Add enum internalvar_kind type and
	kind member.  Restructure union internalvar_data type.  Remove type,
	canonical, and make_value members.
	(init_if_undefined_command): Update for data structure changes.
	(create_internalvar): Likewise.
	(create_internalvar_type_lazy): Likewise.
	(get_internalvar_integer): Likewise.
	(get_internalvar_function): Likewise.
	(set_internalvar_component): Likewise.
	(set_internalvar): Likewise.
	(set_internalvar_integer): Likewise.
	(set_internalvar_function): Likewise.
	(clear_internalvar): Likewise.
	(add_internal_function): Likewise.
	(preserve_one_internalvar): New function.
	(preserve_values): Call it.

	* value.h (value_of_internalvar): Add GDBARCH parameter.
	(internalvar_make_value): Likewise.
	* value.c (value_of_internalvar): Add GDBARCH parameter.  Pass it to
	make_value callback.  Use it to generate per-architecture result value
	types for internal variables with no pre-defined type.  Update for data
	structure changes.
	(show_convenience): Pass architecture to value_of_internalvar.
	* eval.c (evaluate_subexp_standard): Likewise.
	* infrun.c (siginfo_make_value): Add GDBARCH parameter.  Use it
	instead of current frame architecture.  Return per-architecture type.

	* value.h (set_internalvar_string): Add prototype.
	* value.c (set_internalvar_string): New function.
	* tracepoint.c (set_traceframe_context): Use it.
@
text
@d1762 2
a1763 1
static void insert_step_resume_breakpoint_at_sal (struct symtab_and_line sr_sal,
d1765 1
a1765 1
static void insert_longjmp_resume_breakpoint (CORE_ADDR);
d3415 1
a3415 1
	insert_longjmp_resume_breakpoint (jmp_buf_pc);
d3736 2
a3737 1
	  insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
d3833 2
a3834 1
	      insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
d3860 2
a3861 1
	  insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
d3905 2
a3906 1
	  insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
d3942 2
a3943 1
	  insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
d4221 1
a4221 1
      insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
d4271 2
a4272 1
insert_step_resume_breakpoint_at_sal (struct symtab_and_line sr_sal,
d4286 1
a4286 1
    = set_momentary_breakpoint (sr_sal, sr_id, bp_step_resume);
a4298 1
  struct gdbarch *gdbarch = get_frame_arch (return_frame);
d4300 1
d4305 1
d4309 2
a4310 1
  insert_step_resume_breakpoint_at_sal (sr_sal, get_stack_frame_id (return_frame));
a4330 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d4332 1
d4340 1
d4345 1
a4345 1
  insert_step_resume_breakpoint_at_sal (sr_sal,
d4355 1
a4355 1
insert_longjmp_resume_breakpoint (CORE_ADDR pc)
d4368 1
a4368 1
    set_momentary_breakpoint_at_pc (pc, bp_longjmp_resume);
@


1.397
log
@	* infrun.c (handle_inferior_event): Context switch to the new
	thread when resuming for a new_thread_event.
@
text
@d5266 2
a5267 2
   the current thread.  Return a void value if there's no object
   available.  */
d5270 1
a5270 1
siginfo_make_value (struct internalvar *var)
a5271 3
  struct type *type;
  struct gdbarch *gdbarch;

d5273 2
a5274 1
      && !ptid_equal (inferior_ptid, null_ptid))
d5276 2
a5277 8
      gdbarch = get_frame_arch (get_current_frame ());

      if (gdbarch_get_siginfo_type_p (gdbarch))
	{
	  type = gdbarch_get_siginfo_type (gdbarch);

	  return allocate_computed_value (type, &siginfo_value_funcs, NULL);
	}
d5280 1
a5280 1
  return allocate_value (builtin_type_void);
@


1.396
log
@	gdb/
	* NEWS: Document inlined function support.
	* Makefile.in (SFILES): Add inline-frame.c.
	(COMMON_OBS): Add inline-frame.o.
	* block.c (contained_in): Rewrite to use lexical nesting.
	(block_linkage_function): Skip inlined function blocks.
	(block_inlined_p): New.
	* block.h (struct block): Update comment.
	(block_inlined_p): New prototype.
	* blockframe.c (get_frame_block): Handle inlined functions.
	(get_frame_function): Do not use block_linkage_function.
	(block_innermost_frame): Use get_frame_block and contained_in.
	* breakpoint.c (watchpoint_check): Remove extra reinit_frame_cache.
	Skip over inlined functions.  Simplify epilogue check.
	(bpstat_check_breakpoint_conditions): Use get_stack_frame_id.
	Update comments.
	(set_momentary_breakpoint): Only accept non-inlined frames.
	(watch_command_1): Use frame_unwind_caller_pc and
	frame_unwind_caller_id instead of get_prev_frame.
	(until_break_command): Likewise.  Use get_stack_frame_id.
	* buildsym.c (end_symtab): Set SYMBOL_SYMTAB for block functions.
	* dwarf2loc.c (dwarf_expr_frame_base): Use block_linkage_function.
	* dwarf2read.c (process_die): Handle DW_TAG_inlined_subroutine.
	(read_func_scope, new_symbol): Likewise.  Handle arguments specially
	for inlined functions without call site information.
	(inherit_abstract_dies): Allow tag mismatch for inlined subroutines.
	(die_specification): Treat DW_AT_abstract_origin as a specification.
	(read_type_die): Handle DW_TAG_inlined_subroutine.
	* frame-unwind.c (frame_unwind_init): Add inline_frame_unwind.
	* frame.c (fprint_frame_id): Print inline depth.
	(fprint_frame_type): Handle INLINE_FRAME and SENTINEL_FRAME.
	(skip_inlined_frames, get_stack_frame_id): New.
	(frame_unwind_caller_id): Use skip_inlined_frames.
	(frame_id_inlined_p): New.
	(frame_id_eq): Make the logic match the comments.  Add inline_depth
	check.
	(frame_id_inner): Handle inlined functions.
	(frame_unwind_pc): New function, copied from frame_unwind_caller_pc.
	(frame_unwind_caller_pc): Use skip_inlined_frames and frame_unwind_pc.
	(get_prev_frame_1): Check for inline frames.  Split out frame
	allocation to get_prev_frame_raw.
	(get_prev_frame_raw): New function.
	(get_prev_frame): Handle inline frames.
	(get_frame_pc): Use frame_unwind_pc.
	(get_frame_address_in_block): Skip inlined frames on both sides.
	(pc_notcurrent): Delete.
	(find_frame_sal): Rewrite to handle inline call sites.  Use
	get_frame_address_in_block.
	(deprecated_update_frame_pc_hack): Make static.
	* frame.h: Update comments.
	(struct frame_id): Add inline_depth.
	(enum frame_type): Add INLINE_FRAME.
	(frame_id_inlined_p, get_stack_frame_id): New prototypes.
	* gdbthread.h (struct thread_info): Add step_stack_frame_id field.
	* infcmd.c (set_step_frame): New function.
	(step_once): Use set_step_frame.  Handle inlined functions.
	(until_next_command): Use set_step_frame.
	(finish_backward), finish_forward): Use get_stack_frame_id.
	(finish_command): Support inlined functions.
	* inferior.h (set_step_info): New prototype.
	* infrun.c (RESUME_ALL): Use minus_one_ptid.
	(clear_proceed_status): Clear step_stack_frame_id.
	(init_wait_for_inferior): Call clear_inline_frame_state.
	(init_execution_control_state): Make static.
	(set_step_info): New function.
	(init_thread_stepping_state): Do not set the symtab or line here.
	(stepped_in_from): New function.
	(handle_inferior_event): Handle inlined functions.  Use set_step_info.
	(insert_step_resume_breakpoint_at_frame): Use get_stack_frame_id.
	(struct inferior_status): Add step_stack_frame_id.
	(save_inferior_status, restore_inferior_status): Save and restore
	step_stack_frame_id.
	* inline-frame.c, inline-frame.h: New files.
	* minsyms.c (prim_record_minimal_symbol_and_info): Use XCALLOC.
	* regcache.c (regcache_write_pc): Call reinit_frame_cache.
	* s390-tdep.c (s390_prologue_frame_unwind_cache): Handle INLINE_FRAME.
	* stack.c (frame_show_address): New.
	(print_frame_info, print_frame): Use it.
	(find_frame_funname): Use get_frame_function.  Handle inlined blocks.
	(frame_info): Mark inlined functions.
	(backtrace_command_1): Use get_current_user_frame.
	(print_frame_local_vars, print_frame_label_vars): Update comments.
	(return_command): Refuse inlined functions.
	* symtab.c (lookup_symbol_aux_local): Stop at inlined function
	boundaries.
	(find_function_start_sal): Avoid inlined functions.
	(completion_list_add_fields): New function.
	(default_make_symbol_completion_list): Use it.  Use block_static_block
	and block_global_block.  Check for inlined functions.
	(skip_prologue_using_sal): Avoid line number comparison across
	inlining.
	* symtab.h (struct symbol): Add is_inlined.
	(SYMBOL_INLINED): New.
	* target.c (target_resume): Call clear_inline_frame_state.
	* valops.c (value_of_variable): Check block_inlined_p.

	gdb/doc/
	* gdb.texinfo (Debugging Optimized Code): New chapter.
	(Compiling for Debugging): Reference it.  Move some
	text to the new section.

	gdb/testsuite/
	* gdb.base/break.exp: Add an XFAIL for gcc/36748.
	* gdb.cp/annota2.exp: Accept frames-invalid in more places.
	* gdb.opt/Makefile.in (EXECUTABLES): Update.
	* gdb.opt/clobbered-registers-O2.exp: Update to GPL v3.
	* gdb.opt/inline-bt.c, gdb.opt/inline-bt.exp,
	gdb.opt/inline-cmds.c, gdb.opt/inline-cmds.exp,
	gdb.opt/inline-locals.c, gdb.opt/inline-locals.exp,
	gdb.opt/inline-markers.c: New files.
	* lib/gdb.exp (skip_inline_frame_tests): New function.
	(skip_inline_var_tests): New function.
@
text
@d2749 2
@


1.395
log
@	* frame.c (frame_unwind_id): Renamed to ...
	(frame_unwind_caller_id): ... this.  All callers updated.
	(frame_pc_unwind): Renamed to ...
	(frame_unwind_caller_pc): ... this.  All callers updated.
	* frame.h: Document frame_unwind_caller_WHAT functions.
	(frame_unwind_id): Renamed to ...
	(frame_unwind_caller_id): ... this.
	(frame_pc_unwind): Renamed to ...
	(frame_unwind_caller_pc): ... this.
	* hppa-tdep.c (hppa_find_unwind_entry_in_block): Correct comment.
	* stack.c (parse_frame_specification_1): Do not rely on
	frame_unwind_id.
@
text
@d52 1
d213 1
a213 1
#define RESUME_ALL (pid_to_ptid (-1))
d1320 1
d1694 3
d1752 1
a1752 1
void init_execution_control_state (struct execution_control_state *ecs);
d2145 13
d2161 1
a2161 1
void
a2171 2
  struct symtab_and_line sal;

a2175 4

  sal = find_pc_line (tss->prev_pc, 0);
  tss->current_line = sal.line;
  tss->current_symtab = sal.symtab;
d2352 16
d3096 6
d3339 2
a3340 2
	  && frame_id_eq (get_frame_id (frame),
			  ecs->event_thread->step_frame_id)
d3764 2
a3765 2
  if (!frame_id_eq (get_frame_id (frame),
		    ecs->event_thread->step_frame_id)
d3767 1
a3767 1
		       ecs->event_thread->step_frame_id)
d4011 76
d4112 1
a4112 3
  ecs->event_thread->step_frame_id = get_frame_id (frame);
  ecs->event_thread->current_line = stop_pc_sal.line;
  ecs->event_thread->current_symtab = stop_pc_sal.symtab;
d4299 1
a4299 1
  insert_step_resume_breakpoint_at_sal (sr_sal, get_frame_id (return_frame));
d5377 1
d5407 1
d5461 1
@


1.394
log
@2009-06-27  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (handle_inferior_event): Improve handling of
	reverse-stepping into and over shared library functions.
@
text
@d3732 1
a3732 1
      && (frame_id_eq (frame_unwind_id (frame),
d3931 1
a3931 1
	  || !frame_id_p (frame_unwind_id (frame)))
d4207 1
a4207 1
   of frame_unwind_id for an example).  */
d4217 1
a4217 1
  gdb_assert (frame_id_p (frame_unwind_id (next_frame)));
d4221 2
a4222 1
  sr_sal.pc = gdbarch_addr_bits_remove (gdbarch, frame_pc_unwind (next_frame));
d4225 2
a4226 1
  insert_step_resume_breakpoint_at_sal (sr_sal, frame_unwind_id (next_frame));
@


1.393
log
@	* eval.c (evaluate_subexp_standard): Use expression architecture
	instead of current_gdbarch.

	* infrun.c (handle_inferior_event): Avoid unncessary reference
	to current_gdbarch and get_current_frame ().
@
text
@d3642 1
a3642 1
	  || frame_id_eq (get_frame_id (get_current_frame ()),
d3670 13
a3682 4
     loader dynamic symbol resolution code, we keep on single stepping
     until we exit the run time loader code and reach the callee's
     address.  */
  if (ecs->event_thread->step_over_calls == STEP_OVER_UNDEBUGGABLE
d3752 1
d3759 16
d3792 4
a3795 27
	      if (ecs->stop_func_start == 0 
		  && in_solib_dynsym_resolve_code (stop_pc))
		{
		  /* Stepped into runtime loader dynamic symbol
		     resolution code.  Since we're in reverse, 
		     we have already backed up through the runtime
		     loader and the dynamic function.  This is just
		     the trampoline (jump table).

		     Just keep stepping, we'll soon be home.
		  */
		  keep_going (ecs);
		  return;
		}
	      if (gdbarch_skip_trampoline_code (gdbarch, frame, stop_pc))
		{
		  /* We are in a function call trampoline.
		     Keep stepping backward to get to the caller.  */
		  ecs->event_thread->stepping_over_breakpoint = 1;
		}
	      else
		{
		  /* Normal function call return (static or dynamic).  */
		  init_sal (&sr_sal);
		  sr_sal.pc = ecs->stop_func_start;
		  insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
		}
@


1.392
log
@2009-06-14  Hui Zhu  <teawater@@gmail.com>
	    Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (handle_inferior_event): Reverse-next through
          trampoline.
@
text
@d3780 1
a3780 3
	      if (gdbarch_skip_trampoline_code(current_gdbarch,
					       get_current_frame (),
					       stop_pc))
@


1.391
log
@2009-06-18  Hui Zhu  <teawater@@gmail.com>
	    Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (handle_inferior_event): Improve reverse stepping
	through function epilogue.
@
text
@d3780 15
a3794 4
	      /* Normal (staticly linked) function call return.  */
	      init_sal (&sr_sal);
	      sr_sal.pc = ecs->stop_func_start;
	      insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
@


1.390
log
@	* dummy-frame.c (deprecated_pc_in_call_dummy): Add GDBARCH parameter,
	use it instead of current_gdbarch.
	* frame.h (deprecated_pc_in_call_dummy): Add GDBARCH parameter.
	* arm-tdep.c (arm_skip_prologue): Pass architecture to
	deprecated_pc_in_call_dummy.

	* symtab.c (skip_prologue_using_sal): Add GDBARCH parameter.
	Use it instead of current_gdbarch.
	* symtab.h (skip_prologue_using_sal): Add GDBARCH parameter.
	* breakpoint.c (expand_line_sal_maybe): Pass architecture to
	skip_prologue_using_sal.
	* arm-tdep.c (skip_prologue_using_sal): Likewise.
	* lm32-tdep.c (lm32_skip_prologue): Likewise.
	* m32-tdep.c (m32c_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* moxie-tdep.c (moxie_skip_prologue): Likewise.
	* mt-tdep.c (mt_frame_unwind_cache): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* frv-tdep.c (frv_analyze_prologue): Add GDBARCH parameter, pass
	it to skip_prologue_using_sal.  Update call sites ...
	(frv_skip_prologue, frv_frame_unwind_cache): ... here.

	* mn10300-tdep.c (struct mn10300_prologue): Add GDBARCH member.
	(check_for_saved): Use it instead of current_gdbarch.
	(mn10300_analyze_prologue): Set it.

	* value.c (using_struct_return): Add GDBARCH parameter.  Use it
	instead of current_gdbarch.
	* value.h (using_struct_return): Add GDBARCH parameter.
	* eval.c (evaluate_subexp_standard): Pass architecture to
	using_struct_return.
	* infcall.c (call_function_by_hand): Likewise.
	* stack.c (return_command): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.

	* symtab.c (in_prologue): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.
	* symtab.h (in_prologue): Add GDBARCH parameter.
	* infrun.c (handle_inferior_event): Pass architecture to in_prologue.

	* eval.c (evaluate_subexp_standard): Use expression architecture
	instead of current_gdbarch.

	* c-lang.c (evaluate_subexp_c): Use expression architecture and
	language instead of current_gdbarch and current_language.

	* printcmd.c (do_one_display): Use expression architecture instead
	of current_gdbarch.

	* infcmd.c (print_return_value): Use architecture of stop_regcache
	instead of current_gdbarch.
	(print_vector_info, print_float_info): Remove GDBARCH argument,
	use frame architecture instead.
	(vector_info, float_info): Update calls.

	* objc-lang.c (objc_skip_trampoline): Use frame architecture
	instead of current_gdbarch.

	* parse.c (write_dollar_variable): Use parse architecture instead
	of current_gdbarch.

	* source.c (line_info): Use objfile architecture instead of
	current_gdbarch.

	* symtab.c (find_function_start_sal): Use gdbarch instead of
	current_gdbarch.
	(print_msymbol_info): Use objfile architecture instead of
	current_gdbarch.

	* valops.c (value_assign): Use frame architecture instead of
	current_gdbarch.
@
text
@d3633 6
a3638 1
     within it! */
d3640 4
a3643 1
      && stop_pc < ecs->event_thread->step_range_end)
@


1.389
log
@	* infrun.c (cleanup_displaced_step_closure): Remove.
	(displaced_step_clear_cleanup): Move to before displaced_step_prepare.
	(displaced_step_prepare): Use displaced_step_clear_cleanup instead
	of cleanup_displaced_step_closure.
	(handle_inferior_event, keep_going): Use thread architecture instead
	of current_gdbarch.
@
text
@d3726 1
a3726 1
	      && in_prologue (ecs->event_thread->prev_pc,
@


1.388
log
@ChangeLog:

	* infrun.c (handle_inferior_event): Use current frame architecture
	or thread architecture instead of current_gdbarch.  Pass to
	handle_step_into_function and handle_step_into_function_backward.
	(handle_step_into_function): Add GDBARCH parameter.  Use it instead
	of current_gdbarch.
	(handle_step_into_function_backward): Likewise.
	(insert_step_resume_breakpoint_at_frame): Use frame architecture
	instead of current_gdbarch.
	(insert_step_resume_breakpoint_at_caller): Likewise.

testsuite/ChangeLog:

	* gdb.base/annota1.exp: Allow multiple occurrences of the
	frames-invalid annotation.
	* gdb.cp/annota2.exp: Likewise.
@
text
@d766 1
a766 1
cleanup_displaced_step_closure (void *ptr)
d768 1
a768 3
  struct displaced_step_closure *closure = ptr;

  gdbarch_displaced_step_free_closure (current_gdbarch, closure);
d879 9
a887 1
  make_cleanup (cleanup_displaced_step_closure, closure);
a899 7
  /* Save the information we need to fix things up if the step
     succeeds.  */
  displaced_step_ptid = ptid;
  displaced_step_gdbarch = gdbarch;
  displaced_step_closure = closure;
  displaced_step_original = original;
  displaced_step_copy = copy;
a903 6
displaced_step_clear_cleanup (void *ignore)
{
  displaced_step_clear ();
}

static void
d2919 1
d2942 2
a2943 1
	  if (!use_displaced_stepping (current_gdbarch))
d4279 2
a4280 1
	  if (! use_displaced_stepping (current_gdbarch))
@


1.387
log
@gdb/
	* infrun.c (sched_multi): New global.
	(resume): If sched_multi is set, resume only threads of the
	current inferior.
	(prepare_to_proceed): Don't switch over to wait_ptid if we're
	resuming a different inferior, and sched_multi is off.
	(show_schedule_multiple): New.
	(_initialize_infrun): Register new "set schedule-multiple" command.
	* inferior.h (sched_multi): Declare.
	* NEWS: Mention new "schedule-multiple" setting.
gdb/doc/
	* gdb.texinfo (All-Stop): Document new 'set schedule-multiple'
	command.
@
text
@d1758 4
a1761 2
static void handle_step_into_function (struct execution_control_state *ecs);
static void handle_step_into_function_backward (struct execution_control_state *ecs);
d2354 2
d2998 4
d3018 1
a3018 1
	  || gdbarch_have_nonsteppable_watchpoint (current_gdbarch)))
d3045 1
a3045 1
      hw_step = maybe_software_singlestep (current_gdbarch, stop_pc);
d3065 1
a3065 1
    += gdbarch_deprecated_function_start_offset (current_gdbarch);
d3075 1
a3075 1
      && gdbarch_single_step_through_delay_p (current_gdbarch)
d3084 1
a3084 2
	= gdbarch_single_step_through_delay (current_gdbarch,
					     get_current_frame ());
d3236 6
d3300 1
a3300 1
	  insert_step_resume_breakpoint_at_frame (get_current_frame ());
d3310 1
a3310 1
	  && frame_id_eq (get_frame_id (get_current_frame ()),
d3328 1
a3328 1
	  insert_step_resume_breakpoint_at_frame (get_current_frame ());
d3368 2
a3369 3
	if (!gdbarch_get_longjmp_target_p (current_gdbarch)
	    || !gdbarch_get_longjmp_target (current_gdbarch,
					    get_current_frame (), &jmp_buf_pc))
d3674 1
a3674 1
	gdbarch_skip_solib_resolver (current_gdbarch, stop_pc);
d3697 1
a3697 1
      && get_frame_type (get_current_frame ()) == SIGTRAMP_FRAME)
d3718 1
a3718 1
  if (!frame_id_eq (get_frame_id (get_current_frame ()),
d3720 1
a3720 1
      && (frame_id_eq (frame_unwind_id (get_current_frame ()),
d3783 1
a3783 1
	    insert_step_resume_breakpoint_at_caller (get_current_frame ());
d3794 1
a3794 1
      real_stop_pc = skip_language_trampoline (get_current_frame (), stop_pc);
d3796 1
a3796 2
	real_stop_pc = gdbarch_skip_trampoline_code
			 (current_gdbarch, get_current_frame (), stop_pc);
d3824 1
a3824 1
	      handle_step_into_function_backward (ecs);
d3826 1
a3826 1
	      handle_step_into_function (ecs);
d3855 1
a3855 1
	insert_step_resume_breakpoint_at_caller (get_current_frame ());
d3863 1
a3863 1
  if (gdbarch_in_solib_return_trampoline (current_gdbarch,
d3868 1
a3868 2
      real_stop_pc = gdbarch_skip_trampoline_code
		       (current_gdbarch, get_current_frame (), stop_pc);
d3916 1
a3916 1
	  || !frame_id_p (frame_unwind_id (get_current_frame ())))
d3930 1
a3930 1
	  insert_step_resume_breakpoint_at_caller (get_current_frame ());
d3987 1
a3987 1
  ecs->event_thread->step_frame_id = get_frame_id (get_current_frame ());
d4026 2
a4027 1
handle_step_into_function (struct execution_control_state *ecs)
d4034 1
a4034 1
    ecs->stop_func_start = gdbarch_skip_prologue (current_gdbarch, 
d4065 1
a4065 1
  if (gdbarch_adjust_breakpoint_address_p (current_gdbarch))
d4068 1
a4068 1
	= gdbarch_adjust_breakpoint_address (current_gdbarch,
d4103 2
a4104 1
handle_step_into_function_backward (struct execution_control_state *ecs)
d4111 1
a4111 1
    ecs->stop_func_start = gdbarch_skip_prologue (current_gdbarch, 
d4167 1
d4173 1
a4173 2
  sr_sal.pc = gdbarch_addr_bits_remove
		(current_gdbarch, get_frame_pc (return_frame));
d4197 1
d4206 1
a4206 2
  sr_sal.pc = gdbarch_addr_bits_remove
		(current_gdbarch, frame_pc_unwind (next_frame));
@


1.386
log
@	* infrun.c (handle_inferior_event): Update comment around trying
	to revert back to a stepping thread that has exited.
@
text
@d1094 5
a1208 2
      resume_ptid = RESUME_ALL;	/* Default */

d1214 14
d1244 2
a1245 3

      if ((step || singlestep_breakpoints_inserted_p)
	  && tp->trap_expected)
d1259 1
a1259 2

      if (non_stop)
d1412 10
d1424 1
a1424 3
      && !ptid_equal (inferior_ptid, wait_ptid)
      /* Don't single step WAIT_PID if scheduler locking is on.  */
      && !schedlock_enabled)
d5593 7
d5779 12
@


1.385
log
@	* target.h (struct target_ops): Make to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	methods instead of variables.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1)
	(target_has_registers_1, target_has_execution_1): Declare
	functions.
	(target_has_all_memory): Rewrite to call target_has_all_memory_1.
	(target_has_memory): Rewrite to call target_has_memory_1.
	(target_has_stack): Rewrite to call target_has_all_stack_1.
	(target_has_registers): Rewrite to call target_has_registers_1.
	(target_has_execution): Rewrite to call target_has_execution_1.
	(default_child_has_all_memory, default_child_has_memory)
	(default_child_has_stack, default_child_has_registers)
	(default_child_has_execution): Declare.
	(target_mark_running, target_mark_exited): Delete declarations.
	* target.c (default_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution): New.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1,
	target_has_registers_1, target_has_execution_1): New.
	(add_target): Default the to_has_all_memory, to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	callbacks to return 0.
	(update_current_target): Do not inherit to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers or to_has_execution.
	(target_mark_running, target_mark_exited): Delete.
	(memory_xfer_partial): Adjust.
	(target_read_memory, target_write_memory, target_search_memory):
	Dispatch to the the top-most target, not the flattened
	current_target.
	(target_info): Adjust.
	(init_dummy_target): Install return_zero as callback for
	to_has_all_memory, to_has_memory, to_has_stack, to_has_registers,
	to_has_execution.
	(set_maintenance_target_async_permitted): Use have_live_inferiors
	instead of target_has_execution.
	* target-memory.c (target_write_memory_blocks): Dispatch memory
	writes to the the top-most target, not the flattened
	current_target.

	* breakpoint.c (insert_breakpoints): Don't check for
	target_has_execution here.
	(update_global_location_list): Check if there are live inferiors
	to debug instead of target_has_execution.
	* infcmd.c (kill_command, detach_command): Check if there are
	inferiors instead of target_has_execution.
	* inferior.h (have_live_inferiors): Declare.
	* inferior.c (have_live_inferiors): New.
	* infrun.c (normal_stop): Don't check for target_has_execution to
	finish the thread states.
	* thread.c (is_thread_state, is_stopped, is_exited, is_running)
	(any_running, is_executing): Remove checks for
	target_has_execution.
	* top.c (kill_or_detach): Don't try to kill core inferiors.
	(quit_target): Don't check for target_has_execution.

	* corelow.c (core_has_memory, core_has_stack, core_has_registers):
	New.
	(init_core_ops): Install core_has_memory, core_has_stack and
	core_has_registers.
	* exec.c (exec_has_memory): New.
	(init_exec_ops): Install exec_has_memory.
	* remote.c (remote_add_inferior): Don't call target_mark_running.
	(remote_start_remote): Don't call target_mark_exited or call
	target_mark_running.
	(remote_open_1): Use have_inferiors instead of
	target_has_execution.  Don't use target_mark_exited.
	(init_remote_ops): Install deafult_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution.
	* bsd-kvm.c (bsd_kvm_return_one): New.
	(bsd_kvm_add_target): Register bsd_kvm_return_one as
	to_has_memory, to_has_stack and to_has_registers callbacks.
	* remote-m32r-sdi.c (m32r_return_one): New.
	(init_m32r_ops): Register it.
	* inf-child.c (inf_child_target): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.
	* gnu-nat.c (init_gnu_ops): Likewise.
	* go32-nat.c (init_go32_ops): Likewise.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* monitor.c (init_base_monitor_ops): Likewise.
	* nto-procfs.c (init_procfs_ops): Likewise.
	* remote-mips.c (_initialize_remote_mips): Likewise.
	* windows-nat.c (init_windows_ops): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Don't use
	target_mark_running or target_mark_exited.
	(gdbsim_mourn_inferior): Don't call target_mark_exited.
	(init_gdbsim_ops): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.

	* linux-nat.c (linux_nat_xfer_partial): If reading memory, and
	there's no inferior selected, defer to a lower stratum.
@
text
@d3499 19
a3517 3
	  /* If the stepping thread exited, then don't try reverting
	     back to it, just keep going.  We need to query the target
	     in case it doesn't support thread exit events.  */
@


1.384
log
@	* target.c: Include "exec.h".
	(update_current_target): Don't inherit to_sections or
	to_sections_end.
	(target_get_section_table): New.
	(target_section_by_addr): Fetch the section table from the passed
	in target.
	(memory_xfer_partial): Handle unmapped overlay sections before
	anything else.  Get the overlay mapped address here.  Adjust to
	use section_table_xfer_memory_partial.
	(get_target_memory): Request a TARGET_OBJECT_RAW_MEMORY object
	instead of TARGET_OBJECT_MEMORY.
	(target_resize_to_sections): Delete.
	(remove_target_sections): Adjust to remove target sections from
	`current_target_sections', and use resize_section_table.
	* target.h (struct target_ops) <to_sections, to_sections_end>:
	Remove fields.
	<to_get_section_table>: New method.
	(xfer_memory, print_section_info): Delete declarations.
	(struct target_section_table): New type.
	(target_get_section_table): Declare.
	(target_resize_to_sections): Delete declaration.
	(remove_target_sections): Delete declaration.
	* bfd-target.c (target_bfd_xfer_partial): Get the section table
	from to_data.
	(target_bfd_get_section_table): New.
	(target_bfd_xclose): Adjust.
	(target_bfd_reopen): Store the section table in the to_data field.
	* corelow.c (core_data): New.
	(core_close): Adjust to release core_data and its sections.
	(core_open): Allocate core_data, and build its target sections
	table.
	(deprecated_core_resize_section_table): New.
	(core_files_info): Pass core_data to print_section_info.
	(core_xfer_partial): Adjust to use
	section_table_xfer_memory_partial for TARGET_OBJECT_MEMORY xfers.
	(init_core_ops): Do not install a deprecated_xfer_memory callback
	anymore.
	* solib.c (update_solib_list): Add the shared library sections
	to the current target sections table.
	* exec.c (current_target_sections_1): New global.
	(current_target_sections): New global.
	(exec_close_1): New function, refactored from exec_close.  Remove
	the exec_bfd's sections from the current target sections table.
	Adjust to not use to_sections.
	(exec_close): Remove all target sections.  Call exec_close_1.
	(exec_file_clear): Use exec_close_1 instead of unpushing the
	target.
	(exec_file_attach): Likewise.  Adjust to not use to_sections.  Add
	exec_bfd's sections to the current target sections table.  Don't
	push the exec_ops target here.
	(resize_section_table): New.
	(add_target_sections): New.
	(remove_target_sections): Moved here.
	(section_table_xfer_memory): Adjust to implement the xfer_partial
	interface, and rename to...
	(section_table_xfer_memory_partial): ... this, replacing the
	current function of that same name.
	(exec_get_section_table): New.
	(exec_xfer_partial): New.
	(xfer_memory): Delete.
	(print_section_info): Replace the target_ops parameter by a
	target_section_table parameter.
	(exec_files_info, set_section_command, exec_set_section_address):
	Adjust to use the current sections table.
	(init_exec_ops): Do not register a deprecated_xfer_memory
	callback.  Register to_xfer_partial and to_get_section_table
	callbacks.
	* infrun.c (handle_inferior_event): Update comments around
	solib_add.
	* rs6000-nat.c (xcoff_relocate_core): Adjust to use
	deprecated_core_resize_section_table.
	* exec.h (resize_section_table): Declare.
	(section_table_xfer_memory_partial): Add const char * argument.
	(remove_target_sections): Declare here.
	(add_target_sections): Declare.
	(print_section_info): Declare here.
	* gdbcore.h (deprecated_core_resize_section_table): Declare.
@
text
@d4440 5
a4444 8
  if (target_has_execution)
    {
      if (!non_stop)
	make_cleanup (finish_thread_state_cleanup, &minus_one_ptid);
      else if (last.kind != TARGET_WAITKIND_SIGNALLED
	       && last.kind != TARGET_WAITKIND_EXITED)
	make_cleanup (finish_thread_state_cleanup, &inferior_ptid);
    }
@


1.383
log
@	* value.h (struct internalvar): Remove.
	(get_internalvar_integer): Add prototype.
	(set_internalvar_integer): Add prototype.
	(clear_internalvar): Add prototype.

	* value.c (struct internalvar): Move here.  Add type member.  Remove
	endian member.  Add union_internalvar member instead of value member.
	(init_if_undefined_command): Use intvar->type.
	(create_internalvar): Do not initialize value/endian, but type.
	(create_internalvar_type_lazy): Call create_internalvar.
	(value_of_internalvar): Handle host-side internalvar contents.
	(set_internalvar_component): Likewise.
	(set_internalvar): Likewise.
	(get_internalvar_integer): New function.
	(clear_internalvar): Likewise.
	(set_internalvar_integer): Likewise.
	(preserve_values): Handle host-side internalvar contents.

	* breakpoint.c (set_breakpoint_count, set_tracepoint_count): Call
	set_internalvar_integer instead of set_internalvar.
	* findcmd.c (find_command): Likewise.
	* infrun.c (handle_inferior_event): Likewise.
	* source.c (forward_search_command, reverse_search_command): Likewise.
	* tracepoint.c (set_traceframe_num, set_tracepoint_num,
	set_traceframe_context): Likewise.

	* printcmd.c (x_command): Call clear_internalvar instead of
	set_internalvar.
	* tracepoint.c (set_traceframe_context): Likewise.

	* breakpoint.c (get_number_trailer): Call get_internalvar_integer
	instead of value_of_internalvar.
	* linespec.c (decode_dollar): Likewise.

	* expprint.c (dump_subexp_body_standard): Use internalvar_name
	instead of accessing internalvar private elements.
	* valops.c (value_assign): Copy from original source instead of
	accessing internalvar private elements.
@
text
@a2450 9
	  /* NOTE: cagney/2003-11-25: Pass current_target and not
	     exec_ops to SOLIB_ADD.  This is because current GDB is
	     only tooled to propagate section_table changes out from
	     the "current_target" (see target_resize_to_sections), and
	     not up from the exec stratum.  This, of course, isn't
	     right.  "infrun.c" should only interact with the
	     exec/process stratum, instead relying on the target stack
	     to propagate relevant changes (stop, section table
	     changed, ...) up to other layers.  */
a3439 9
	  /* NOTE: cagney/2003-11-25: Pass current_target and not
	     exec_ops to SOLIB_ADD.  This is because current GDB is
	     only tooled to propagate section_table changes out from
	     the "current_target" (see target_resize_to_sections), and
	     not up from the exec stratum.  This, of course, isn't
	     right.  "infrun.c" should only interact with the
	     exec/process stratum, instead relying on the target stack
	     to propagate relevant changes (stop, section table
	     changed, ...) up to other layers.  */
@


1.382
log
@	* infrun.c (prepare_to_proceed): Document.  Assert !non_stop.
	If scheduler-locking is enabled, we're not going to be singlestepping
	any other previously stopped thread.

	* gdb.threads/hand-call-in-threads.exp: New file.
	* gdb.threads/hand-call-in-threads.c: New file.
@
text
@d2515 2
a2516 3
      set_internalvar (lookup_internalvar ("_exitcode"),
		       value_from_longest (builtin_type_int32,
					   (LONGEST) ecs->ws.value.integer));
@


1.381
log
@gdb/
2009-05-28  Pedro Alves  <pedro@@codesourcery.com>

	* infrun.c (handle_inferior_event): When thread hoping, switch
	inferior_ptid to the event thread before removing breakpoints from
	the target.  If not stopping, also try to revert back to a thread
	that was doing a "next".  Check if that thread still exists before
	resuming.
	(currently_stepping_thread): Delete and merge with ...
	(currently_stepping): ... this.
	(currently_stepping_callback): Rename to ...
	(currently_stepping_or_nexting_callback): ... this, and also
	return true if the thread was stepping over a call (has a
	step-resume breakpoint).

gdb/testsuite/
2009-05-28  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.threads/threxit-hop-specific.c: New.
	* gdb.threads/threxit-hop-specific.exp: New.
	* gdb.threads/thread-execl.c: New.
	* gdb.threads/thread-execl.exp: New.
@
text
@d1367 5
a1371 1
/* This should be suitable for any targets that support threads. */
d1378 4
d1393 4
d1399 3
a1401 1
      && !ptid_equal (inferior_ptid, wait_ptid))
@


1.380
log
@gdb/
	* infrun.c (follow_exec): Clear the stop_requested flag.
	* linux-nat.c (linux_handle_extended_wait) <PTRACE_EVENT_EXEC>:
	Add debug output.

gdb/testsuite/
	* gdb.mi/nsthrexec.c, gdb.mi/mi-nsthrexec.exp: New.
@
text
@d78 2
a79 1
static int currently_stepping_callback (struct thread_info *tp, void *data);
d2900 5
a2930 3
	      if (!ptid_equal (inferior_ptid, ecs->ptid))
		context_switch (ecs->ptid);

d3489 1
a3489 1
      tp = iterate_over_threads (currently_stepping_callback,
d3504 15
d3952 1
a3952 1
/* Are we in the middle of stepping?  */
d3955 1
a3955 1
currently_stepping_thread (struct thread_info *tp)
d3957 4
a3960 3
  return (tp->step_range_end && tp->step_resume_breakpoint == NULL)
	 || tp->trap_expected
	 || tp->stepping_through_solib_after_catch;
d3963 3
d3967 1
a3967 1
currently_stepping_callback (struct thread_info *tp, void *data)
d3969 2
a3970 4
  /* Return true if any thread *but* the one passed in "data" is
     in the middle of stepping.  */
  return tp != data && currently_stepping_thread (tp);
}
d3972 3
a3974 4
static int
currently_stepping (struct thread_info *tp)
{
  return currently_stepping_thread (tp) || bpstat_should_step ();
@


1.379
log
@gdb:
	Global renaming of find_thread_pid to find_thread_ptid.
	* gdbthread.h (find_thread_ptid): Renamed from find_thread_pid.
	* thread.c (find_thread_ptid): Renamed from find_thread_pid.
	All callers updated.
gdbserver:
	Global renaming of find_thread_pid to find_thread_ptid.
	* server.h (find_thread_ptid): Renamed from find_thread_pid.
	* inferiors.c (find_thread_ptid): Renamed from find_thread_pid.
	All callers updated.
@
text
@d497 8
@


1.378
log
@	* infrun.c (follow_fork): Initialize new step_* locals
	to avoid "may be used uninitialized" warnings.
@
text
@d377 1
a377 1
	    tp = find_thread_pid (parent);
d1531 1
a1531 1
	  last_thread = find_thread_pid (last_ptid);
d1760 1
a1760 1
      ecs->event_thread = find_thread_pid (info->ptid);
d2340 1
a2340 1
  ecs->event_thread = find_thread_pid (ecs->ptid);
d2867 1
a2867 1
                 ecs->event_thread = find_thread_pid (ecs->ptid);
@


1.377
log
@gdb/
	* gdbthread.h (struct thread_info): New `pending_follow' field.
	* thread.c (new_thread): New function.
	(add_thread_silent): Use it.
	* breakpoint.c (internal_breakpoint_number): New global, moved
	from inside...
	(create_internal_breakpoint): ... this.
	(clone_momentary_breakpoint): New.
	* breakpoint.h (clone_momentary_breakpoint): Declare.
	* infrun.c (nullify_last_target_wait_ptid): Move declaration
	higher.
	(pending_follow): Delete.
	(follow_fork): Handle pending follow fork event here.  Moved the
	preserving of thread stepping state here.
	(resume): Don't handle pending follow fork events here.  Only
	install the inferior's terminal modes if we're about to resume it.
	(proceed): Handle possible pending follow fork events here.
	(init_wait_for_inferior): No need to clear pending_follow anymore,
	it's gone.
	(handle_inferior_event): Adjust to per-thread `pending_follow'.
	Call `follow_fork' to handle following the fork.  If the
	follow-fork is cancelled, stop stepping.
	* linux-nat.c (linux_child_follow_fork): Adjust to per-thread
	`pending_follow' events.  Remove code that handled preserving the
	thread stepping state.
	* inf-ptrace.c (inf_ptrace_follow_fork): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork): Ditto.

gdb/testsuite/
	* gdb.threads/fork-thread-pending.c: New.
	* gdb.threads/fork-thread-pending.exp: New.
@
text
@d293 6
a298 6
     parent thread structure's run control related fields, not just
     these.  */
  struct breakpoint *step_resume_breakpoint;
  CORE_ADDR step_range_start;
  CORE_ADDR step_range_end;
  struct frame_id step_frame_id;
@


1.376
log
@	* target.h (TARGET_WNOHANG): New.
	* target.c (target_wait): Add `options' argument.  Adjust.
	(struct target_ops) <to_wait>: Add `options' argument.
	(target_wait): Add `options' argument.
	* infrun.c (wait_for_inferior): Pass 0 as options to
	target_wait (blocking wait).
	(fetch_inferior_event): Pass TARGET_WNOHANG as options to
	target_wait.
	* fork-child.c (startup_inferior): Pass 0 as options to
	target_wait (blocking wait).
	* linux-nat.c (linux_nat_create_inferior): Remove async masking.
	(linux_nat_wait_1): Add `target_options' argument.  Use it instead
	of checking on target_can_async_p.
	(linux_nat_wait): Add `target_options' argument.  Adjust.
	* remote.c (remote_wait_ns): Add `options' argument.  Adjust to
	check on TARGET_WNOWAIT instead of checking on remote_is_async_p.
	(remote_wait_as): Add `options' argument.  Adjust to check on
	TARGET_WNOWAIT instead of checking on remote_is_async_p.  If doing
	a blocking wait, keep waiting until an interesting event comes
	out.
	(remote_wait): Add `options' argument.  Don't loop here if the
	target is in async mode, and a blocking wait has been requested.

	* top.c (deprecated_target_wait_hook): Add `options' argument.
	* linux-thread-db.c (thread_db_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ptrace.c (inf_ptrace_wait): Add `options' argument.
	* record.c (record_beneath_to_wait): Add `options' argument.
	(record_wait): Add `options' argument, and pass it down to the
	layer beneath.
	* bsd-uthread.c (bsd_uthread_wait): Add `options' argument.
	* darwin-nat.c (darwin_wait): Likewise.
	* defs.h (deprecated_target_wait_hook): Likewise.
	* gnu-nat.c (gnu_wait): Add `options' argument.
	* go32-nat.c (go32_wait): Likewise.
	* hpux-thread.c (hpux_thread_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ttrace.c (inf_ttrace_wait): Add `options' argument.
	* monitor.c (monitor_wait): Likewise.
	* nto-procfs.c (procfs_wait): Likewise.
	* remote-mips.c (mips_wait): Add `options' argument.
	* remote-sim.c (gdbsim_wait): Likewise.
	* rs6000-nat.c (rs6000_wait): Add `options' argument.
	* sol-thread.c (sol_thread_wait): Add `options' argument, and pass
	it down to the layer beneath.
	* spu-linux-nat.c (spu_child_wait): Add `options' argument.
	* windows-nat.c (windows_wait): Likewise.
	* tui/tui-hooks.c (tui_target_wait_hook): Likewise.  Adjust.
@
text
@d86 2
a259 15
/* This is used to remember when a fork or vfork event was caught by a
   catchpoint, and thus the event is to be followed at the next resume
   of the inferior, and not immediately.  */
static struct
{
  enum target_waitkind kind;
  struct
  {
    ptid_t parent_pid;
    ptid_t child_pid;
  }
  fork_event;
}
pending_follow;

d280 4
d288 141
d430 1
a430 1
  return target_follow_fork (follow_child);
a1121 2

  /* Note that these must be reset if we follow a fork below.  */
a1190 25
  /* If there were any forks/vforks/execs that were caught and are
     now to be followed, then do so.  */
  switch (pending_follow.kind)
    {
    case TARGET_WAITKIND_FORKED:
    case TARGET_WAITKIND_VFORKED:
      pending_follow.kind = TARGET_WAITKIND_SPURIOUS;
      if (follow_fork ())
	should_resume = 0;

      /* Following a child fork will change our notion of current
	 thread.  */
      tp = inferior_thread ();
      regcache = get_current_regcache ();
      gdbarch = get_regcache_arch (regcache);
      pc = regcache_read_pc (regcache);
      break;

    default:
      break;
    }

  /* Install inferior's terminal modes.  */
  target_terminal_inferior ();

d1272 3
d1416 2
a1417 2
  struct regcache *regcache = get_current_regcache ();
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
d1419 1
a1419 1
  CORE_ADDR pc = regcache_read_pc (regcache);
d1422 14
a1641 3
  /* The first resume is not following a fork/vfork/exec. */
  pending_follow.kind = TARGET_WAITKIND_SPURIOUS;	/* I.e., none. */

a1819 2
void nullify_last_target_wait_ptid (void);

a2526 4
      pending_follow.kind = ecs->ws.kind;

      pending_follow.fork_event.parent_pid = ecs->ptid;
      pending_follow.fork_event.child_pid = ecs->ws.value.related_pid;
d2555 5
d2569 2
d2572 10
a2581 1
	  keep_going (ecs);
@


1.375
log
@gdb/
2009-05-17  Pedro Alves  <pedro@@codesourcery.com>

	* infrun.c (handle_inferior_event): When handling a
	TARGET_WAITKIND_FORKED, detach breakpoints from the fork child
	immediatelly.
	* linux-nat.c (linux_child_follow_fork): Only detach breakpoint
	from the child if vforking.
	* inf-ptrace.c (inf_ptrace_follow_fork): No need to detach
	breakpoints from the child here.

gdb/testsuite/
2009-05-17  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.base/foll-fork.c: Include stdlib.h.  Add markers for
	`gdb_get_line_number'.  Call `callee' in both parent and child.
	* gdb.base/foll-fork.exp (catch_fork_child_follow): Use
	`gdb_get_line_number' instead of hardcoding line numbers.
	(catch_fork_unpatch_child): New procedure to test detaching
	breakpoints from child fork.
	(tcatch_fork_parent_follow): Use `gdb_get_line_number' instead of
	hardcoding line numbers.
	(do_fork_tests): Run `catch_fork_unpatch_child'.
@
text
@d1845 1
a1845 1
	ecs->ptid = deprecated_target_wait_hook (waiton_ptid, &ecs->ws);
d1847 1
a1847 1
	ecs->ptid = target_wait (waiton_ptid, &ecs->ws);
d1923 1
a1923 1
      deprecated_target_wait_hook (waiton_ptid, &ecs->ws);
d1925 1
a1925 1
    ecs->ptid = target_wait (waiton_ptid, &ecs->ws);
@


1.374
log
@	* infrun.c (pending_follow): Remove mention of exec events.
@
text
@d2421 21
@


1.373
log
@	* infrun.c (pending_follow): Remove execd_pathname member.
	(resume): No longer handle TARGET_WAITKIND_EXECD pending follow.
	(handle_inferior_event): When handling a TARGET_WAITKIND_EXECD
	event, don't copy `execd_pathname' to pending_follow, use the
	event copy instead.  Release `execd_pathname' once done with
	handling the event.
@
text
@d258 3
a260 4
/* This is used to remember when a fork, vfork or exec event
   was caught by a catchpoint, and thus the event is to be
   followed at the next resume of the inferior, and not
   immediately. */
@


1.372
log
@	Unify target macros.

	* target.h (STOPPED_BY_WATCHPOINT): Delete, replaced by ...
	(target_stoppped_by_watchpoint): New macro.
	(HAVE_STEPPABLE_WATCHPOINT): Delete, replaced by ...
	(target_have_steppable_watchpoint): New macro.
	(HAVE_CONTINUABLE_WATCHPOINT): Delete, replace by ...
	(target_have_continuable_watchpoint): New macro.
	(TARGET_CAN_USE_HARDWARE_WATCHPOINT):Delete, replaced by ...
	(target_can_use_hardware_watchpoint): New macro.
	(TARGET_REGION_OK_FOR_HW_WATCHPOINT):Delete, replaced by ...
	(target_region_ok_for_hw_watchpoint): New macro.

	* breakpoint.c (update_watchpoint): Use new macros.
	(bpstat_alloc): Likewise.
	(create_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(can_use_hardware_watchpoint): Likewise.
	(do_enable_breakpoint): Likewise.
	* infrun.c (handle_inferior_event): Adapt to new macros.
	* mips-tdep.c (mips_gdbarch_init): Update comments.
	* procfs.c (procfs_set_watchpoint): Update comment.
	(procfs_insert_watchpoint): Adapt to new macros.
	* remote-m32r-sdi.c (m32r_stop):
	* remote-mips.c (mips_remove_breakpoint):
	* target.c (debug_to_region_ok_for_hw_watchpoint): Update to new macros.
	(debug_to_stopped_by_watchpoint): Likewise.
@
text
@a270 1
  char *execd_pathname;
a1079 5
    case TARGET_WAITKIND_EXECD:
      /* follow_exec is called as soon as the exec event is seen. */
      pending_follow.kind = TARGET_WAITKIND_SPURIOUS;
      break;

a2440 3
      pending_follow.execd_pathname =
	savestring (ecs->ws.value.execd_pathname,
		    strlen (ecs->ws.value.execd_pathname));
d2453 1
a2453 2
      follow_exec (inferior_ptid, pending_follow.execd_pathname);
      xfree (pending_follow.execd_pathname);
d2458 5
@


1.371
log
@	* inferior.h (read_pc, write_pc): Remove.
	* regcache.c (read_pc, write_pc): Remove.

	* infrun.c (displaced_step_fixup): Use regcache_read_pc instead
	of read_pc.
	(handle_inferior_event): Use regcache_read_pc instead of read_pc
	when determining value of stop_pc.  Replace subsequent uses of
	read_pc by inspecting already-retrieved stop_pc value.
	(keep_going): Use regcache_read_pc instead of read_pc.

	* breakpoint.c (watchpoint_check): Use current frame architecture
	and PC instead of current_gdbarch and read_pc ().
	* tracepoint.c (set_traceframe_context): Replace PC argument
	with FRAME argument.
	(trace_start_command, finish_tfind_command): Update calls.
	(finish_tfind_command): Compare frame IDs to identify transitions
	between frames.
	(trace_find_pc_command): Use regcache_read_pc instead of read_pc.
	* rs6000-nat.c (exec_one_dummy_insn): Pass in regcache instead
	of gdbarch.  Use regcache_read_pc and regcache_write_pc instead
	of read_pc and write_pc.
	(store_register): Make regcache argument non-const.  Update call
	to exec_one_dummy_insn.

	* thread.c (switch_to_thread): Use regcache_read_pc instead of read_pc.
	* infcmd.c (post_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (enable_break, svr4_relocate_main_executable): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Likewise.
	* record.c (record_wait): Likewise.
	* procfs.c (procfs_wait): Likewise.
	* remote-mips.c (common_open, mips_wait): Likewise.
	* remote-m32r-sdi.c (m32r_resume): Likewise.

	* symfile.c (generic_load): Use regcache_write_pc instead of write_pc.
	* monitor.c (monitor_create_inferior, monitor_load): Likewise.
	* m32r-rom.c (m32r_load, m32r_upload_command): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior, m32r_load): Likewise.
	* remote-mips.c (mips_create_inferior, mips_load): Likewise.

	* solib-darwin.c: Include "regcache.h".
	* solib-pa64.c: Include "regcache.h".
	* solib-svr4.c: Include "regcache.h.".

	* symfile.c: Do not mention read_pc or write_pc in comments.
	* dink32-rom.c: Likewise.
	* m32r-rom.c: Likewise.
	* mips-tdep.c: Likewise.
@
text
@d2571 1
a2571 1
      if (STOPPED_BY_WATCHPOINT (&ecs->ws))
d2827 1
a2827 1
      && (HAVE_STEPPABLE_WATCHPOINT
d2852 1
a2852 1
      if (!HAVE_STEPPABLE_WATCHPOINT)
d2859 1
a2859 1
      if (HAVE_STEPPABLE_WATCHPOINT)
@


1.370
log
@* infrun.c (use_displaced_stepping): Return false if process
record and replay target is used.
(proceed): Call function "record_not_record_set" if pocess
record and replay target is used.
@
text
@d841 1
a841 1
      actual_pc = read_pc ();
d2428 1
a2428 1
      stop_pc = read_pc ();
d2457 1
a2457 1
      stop_pc = read_pc ();
d2507 1
a2507 1
      stop_pc = read_pc ();
d2855 1
a2855 1
      hw_step = maybe_software_singlestep (current_gdbarch, read_pc ());
d3086 1
a3086 1
      if (ecs->event_thread->prev_pc == read_pc ()
d4035 2
a4036 1
  ecs->event_thread->prev_pc = read_pc ();		/* Might have been DECR_AFTER_BREAK */
@


1.369
log
@2009-04-20  David Daney  <ddaney@@caviumnetworks.com>

	* NEWS: Mention MIPS/Linux hardware watchpoint support.

2009-04-20  David Daney  <ddaney@@caviumnetworks.com>

	* mips-linux-nat.c (command.h, gdbcmd.h, gdb_assert.h): New #includes.
	(maint_show_dr, super_close): New variables.
	(super_fetch_registers, super_store_registers): Make static.
	(PTRACE_GET_WATCH_REGS, PTRACE_SET_WATCH_REGS, W_BIT, R_BIT, I_BIT)
	(W_MASK, R_MASK, I_MASK, IRW_MASK, MAX_DEBUG_REGISTER): Define.
	(pt_watch_style): Define new enum.
	(mips32_watch_regs, mips64_watch_regs, pt_watch_regs, mips_watchpoint):
	Define new structs.
	(watch_readback_valid, watch_readback, current_watches,	watch_mirror):
	New variables.
	(get_irw_mask, get_reg_mask, get_num_valid, get_watchlo)
	(set_watchlo, get_watchhi, set_watchhi, mips_show_dr)
	(mips_linux_read_watch_registers, mips_linux_can_use_hw_breakpoint)
	(mips_linux_stopped_by_watchpoint, mips_linux_stopped_data_address)
	(type_to_irw, fill_mask, try_one_watch)
	(mips_linux_region_ok_for_hw_watchpoint, write_watchpoint_regs)
	(mips_linux_new_thread, populate_regs_from_watches)
	(mips_linux_insert_watchpoint, mips_linux_remove_watchpoint)
	(mips_linux_close): New functions.
	(_initialize_mips_linux_nat): Register watchpoint functions with
	the target_ops.  Add show-debug-regs maintenance command.

2009-04-20  David Daney  <ddaney@@caviumnetworks.com>

	* infrun.c (handle_inferior_event): Move gegisters_changed call down.
@
text
@d51 1
d607 2
a608 1
	  && gdbarch_displaced_step_copy_insn_p (gdbarch));
d2135 4
d2162 3
@


1.368
log
@2009-04-13  David Daney  <ddaney@@caviumnetworks.com>

	* infrun.c (maybe_software_singlestep): New function.
	(resume): Call maybe_software_singlestep.
	(handle_inferior_event): Same.
@
text
@a2844 1
      registers_changed ();
d2848 1
@


1.367
log
@gdb/
	* infrun.c (infrun_thread_thread_exit): New.
	(_initialize_infrun): Attach it to the thread_exit observer.
	* thread.c (delete_thread_1): Always call the observer, passing it
	the silent flag.
	* mi/mi-interp.c (mi_thread_exit): Add "silent" parameter.  If
	SILENT, return immediately.

gdb/doc/
	* observer.texi (thread_exit): Add "silent" parameter.
@
text
@d953 23
d1057 3
a1059 14
  if (step && gdbarch_software_single_step_p (gdbarch))
    {
      /* Do it the hard way, w/temp breakpoints */
      if (gdbarch_software_single_step (gdbarch, get_current_frame ()))
        {
          /* ...and don't ask hardware to do it.  */
          step = 0;
          /* and do not pull these breakpoints until after a `wait' in
          `wait_for_inferior' */
          singlestep_breakpoints_inserted_p = 1;
          singlestep_ptid = inferior_ptid;
          singlestep_pc = pc;
        }
    }
d2841 2
a2842 1
	 
d2846 3
a2848 1
      target_resume (ecs->ptid, 1, TARGET_SIGNAL_0);	/* Single step */
@


1.366
log
@	* infrun.c (normal_stop): Use has_stack_frames instead of
	target_has_stack.
	* mi/mi-main.c (mi_execute_command): Avoid calling inferior_thread
	when there is no thread selected.
	(mi_cmd_execute): Don't special case commands that can run without
	a valid selected thread.
	* top.c (execute_command): Don't special case commands that can
	run without a valid selected thread.  Use has_stack_frames.
	* infcmd.c (ensure_valid_thread): New.
	(continue_1, step_1, jump_command, signal_command): Use it.
	(detach_command): Error out if there's no selected thread/inferior.
	* thread.c (print_thread_info): Allow having no thread selected.
	(switch_to_thread): Don't read the PC if there is no current thread.
	(do_restore_current_thread_cleanup): Don't record the current
	frame if there is no current thread.
	(make_cleanup_restore_current_thread): Don't read frame info if
	there is no selected thread.
	(_initialize_thread): Don't mark commands as
	"no_selected_thread_ok".
	* frame.c (get_current_frame): Error out if there is no valid
	selected thread.
	(has_stack_frames): Return false if there is no valid
	selected thread.
	* cli/cli-cmds.c (init_cli_cmds): Don't mark commands as
	"no_selected_thread_ok".
	* cli/cli-decode.c (set_cmd_no_selected_thread_ok)
	(get_cmd_no_selected_thread_ok): Delete.
	* cli/cli-decode.h (CMD_NO_SELECTED_THREAD_OK): Delete.
	(set_cmd_no_selected_thread_ok, get_cmd_no_selected_thread_ok):
	Delete declaration.
	* stack.c (get_selected_block): Use has_stack_frames.
@
text
@d1694 9
d5587 1
@


1.365
log
@gdb/

	* mi/mi-interp.c (mi_interpreter_init): Attach mi_about_to_proceed
	to the about_to_proceed observer notification.
	(mi_about_to_proceed): New.
	(mi_on_resume): Only output ^running and the prompt here if the
	target was proceeded.
	* breakpoint.c (breakpoint_proceeded): New static.
	(breakpoint_about_to_proceed): New.
	(_initialize_breakpoints): Attach breakpoint_about_to_proceed to
	the about_to_proceed observer notification.
	* inferior.h (breakpoint_proceeded): Delete declaration.
	* infrun.c (clear_proceed_status): Don't set breakpoint_proceeded.
	Notify the about_to_proceed observers.
	(struct inferior_status): Delete breakpoint_proceeded member.
	(save_inferior_status): Don't save it.
	(restore_inferior_status): Don't restore it.
	* mi-main.h (mi_proceeded): Declare.
	* mi/mi-main.c (mi_cmd_execute): Clear mi_proceeded before running
	a command.

gdb/doc/

	* observer.texi (about_to_proceed): New.
@
text
@d4305 1
a4305 1
  if (target_has_stack && !stop_stack_dummy)
d4317 1
a4317 1
  if (!target_has_stack)
@


1.364
log
@	* gdbthread.h (struct thread_info): Add in_infcall member.
	* infcall.c (run_inferior_call): Save, set and restore in_infcall.
	Remove reverences to suppress_resume_observer.  Refresh
	`call_thread' after returning from `proceed'.
	* infcmd.c (suppress_resume_observer): Delete.
	* inferior.h (suppress_resume_observer): Delete declaration.
	* mi/mi-interp.c (mi_on_resume): Suppress output while calling an
	inferior function.
	* thread.c (set_running): Remove references to
	suppress_resume_observer.
	* infrun.c (struct inferior_status): Add in_infcall member.
	(save_inferior_status): Save it.
	(restore_inferior_status): Restore it.
@
text
@d1233 2
a1234 1
  breakpoint_proceeded = 1;	/* We're about to proceed... */
a5010 1
  int breakpoint_proceeded;
a5040 1
  inf_status->breakpoint_proceeded = breakpoint_proceeded;
a5090 1
  breakpoint_proceeded = inf_status->breakpoint_proceeded;
@


1.363
log
@	* infcall.c (run_inferior_call): Remove references to
	suppress_stop_observer.
	* infcmd.c (suppress_stop_observer): Delete.
	(finish_command_continuation): Remove NOTE.  Don't clear
	suppress_stop_observer anymore.
	(finish_command_continuation_free_arg): Likewise.
	(finish_forward): Remove references to suppress_stop_observer.
	Call normal_stop observer if we haven't already.
	* inferior.h (suppress_stop_observer): Delete.
	* infrun.c (normal_stop): When deciding to suppress the
	normal_stop observer, check for proceed_to_finish instead of
	suppress_stop_observer.
@
text
@d4454 2
a4455 1
	       && inferior_thread ()->proceed_to_finish)))
d5012 1
d5043 1
d5094 1
@


1.362
log
@	* infrun.c (normal_stop): Don't overwrite old_chain.
@
text
@d4436 19
a4454 5
  if (!suppress_stop_observer
      && !(target_has_execution
	   && last.kind != TARGET_WAITKIND_SIGNALLED
	   && last.kind != TARGET_WAITKIND_EXITED
	   && inferior_thread ()->step_multi))
@


1.361
log
@	Include thread ID in target_wait debugging output.
	* infrun.c (print_target_wait_results): New function.
	(wait_for_inferior,fetch_inferior_event): Call it.
@
text
@d4242 1
a4242 1
	old_chain = make_cleanup (finish_thread_state_cleanup, &minus_one_ptid);
d4245 1
a4245 1
	old_chain = make_cleanup (finish_thread_state_cleanup, &inferior_ptid);
@


1.360
log
@2009-02-25  Hui Zhu  <teawater@@gmail.com>

	* cli/cli-script.c (define_command): Add _() to query.
	* gnu-nat.c (inf_validate_task_sc): Ditto.
	* infcmd.c (kill_if_already_running): Ditto.
	(jump_command): Ditto.
	(attach_command): Ditto.
	* inflow.c (kill_command): Ditto.
	* infrun.c (handle_command): Ditto.
	* maint.c (maintenance_dump_me): Ditto.
	* memattr.c (mem_delete_command): Ditto.
	* monitor.c (monitor_interrupt_query): Ditto.
	* nto-procfs.c (interrupt_query): Ditto.
	* printcmd.c (undisplay_command): Ditto.
	* remote-mips.c (mips_kill): Ditto.
	* remote.c (interrupt_query): Ditto.
	* solib-irix.c (irix_open_symbol_file_object): Ditto.
	* solib-osf.c (osf_open_symbol_file_object): Ditto.
	* solib-pa64.c (pa64_open_symbol_file_object): Ditto.
	* solib-som.c (som_open_symbol_file_object): Ditto.
	* solib-svr4.c (open_symbol_file_object): Ditto.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Ditto.
	* target.c (kill_or_be_killed): Ditto.
	* tracepoint.c (delete_trace_command): Ditto.
	* top.c (quit_confirm): Add _() to s that will be used
	in query.
@
text
@d1740 40
d1833 1
a1833 8
	{
	  char *status_string = target_waitstatus_to_string (&ecs->ws);
	  fprintf_unfiltered (gdb_stdlog,
			      "infrun: target_wait (%d, status) = %d, %s\n",
			      PIDGET (waiton_ptid), PIDGET (ecs->ptid),
			      status_string);
	  xfree (status_string);
	}
d1911 1
a1911 8
    {
      char *status_string = target_waitstatus_to_string (&ecs->ws);
      fprintf_unfiltered (gdb_stdlog,
			  "infrun: target_wait (%d, status) = %d, %s\n",
			  PIDGET (waiton_ptid), PIDGET (ecs->ptid),
			  status_string);
      xfree (status_string);
    }
@


1.359
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d4640 2
a4641 2
		  if (query ("%s is used by the debugger.\n\
Are you sure you want to change it? ", target_signal_to_name ((enum target_signal) signum)))
@


1.358
log
@        Include frame information for *stopped due to CLI commands.

        * ada-tasks.c (ada_normal_stop_observer): Adjust prototype.
        * infcmd.c (finish_command_continuation): Pass '1' for
        'print_frame' parameter to the observer.
        * infrun.c (normal_stop): Don't print mi-specific information
        here. Pass 'stop_print_frame' to the 'print_frame' parameter
        of the observer.
        * mi/mi-interp.c (mi_on_normal_stop): Adjust prototype.
        If we need to print frame, and current uiout is not the MI one,
        print frame again.
@
text
@d1663 1
a1663 1
void
d4851 1
a4851 1
struct value *
@


1.357
log
@2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* target.h (enum target_object): Add new TARGET_OBJECT_SIGNAL_INFO.
	* infrun.c (siginfo_value_read, siginfo_value_write): New.
	(siginfo_value_funcs): New.
	(siginfo_make_value): New.
	(_initialize_infrun): Create the $_siginfo convenience variable.
	* gdbtypes.h (append_composite_type_field_aligned): Declare.
	* gdbtypes.c (append_composite_type_field): Rename to...
	(append_composite_type_field_aligned): ... this.  Add ALIGNMENT
	argument.  Handle it.
	(append_composite_type_field): Rewrite on top of
	append_composite_type_field_aligned.
	* value.h (internalvar_make_value): New typedef.
	(struct internalvar) <make_value>: New field.
	(create_internalvar_type_lazy): Declare.
	* value.c (create_internalvar): Clear make_value.
	(create_internalvar_type_lazy): New.
	(value_of_internalvar): If make_value is set use it.
	(preserve_values): Skip internal variables that don't have a
	value.
	* gdbarch.sh (get_siginfo_type): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.h, linux-tdep.c: New.
	* amd64-linux-tdep.c: Include "linux-tdep.h".
	(amd64_linux_init_abi): Register linux_get_siginfo_type and
	linux_get_siginfo_mapper.
	* i386-linux-tdep.c: Include "linux-tdep.h".
	(i386_linux_init_abi): Register linux_get_siginfo_type and
	linux_get_siginfo_mapper.
	* arm-linux-tdep.c: Include "linux-tdep.h".
	(i386_linux_init_abi): Register linux_get_siginfo_type and
	linux_get_siginfo_mapper.

	* linux-nat.c (linux_xfer_siginfo): New.
	(linux_nat_xfer_partial): Handle TARGET_OBJECT_SIGNAL_INFO.
	* remote.c (PACKET_qXfer_siginfo_read)
	(PACKET_qXfer_siginfo_write): New.
	(feature remote_protocol_features): Add "qXfer:siginfo:read" and
	"qXfer:siginfo:write" features.
	(remote_xfer_partial): Handle TARGET_OBJECT_SIGNAL_INFO.
	(_initialize_remote): Add "set/show remote read-siginfo-object"
	and "set/show remote write-siginfo-object" commands.

	* Makefile.in (ALL_TARGET_OBS): Add linux-tdep.o.
	(HFILES_NO_SRCDIR): Add linux-tdep.h.
	(ALLDEPFILES): Add linux-tdep.c.

	* configure.tgt (arm*-*-linux* | arm*-*-uclinux*)
	(i[34567]86-*-linux*, x86_64-*-linux*): Add linux-tdep.o to
	gdb_target_obs.

2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/gdbserver/
	* server.c (handle_query): Report qXfer:siginfo:read and
	qXfer:siginfo:write as supported and handle them.
	* target.h (struct target_ops) <qxfer_siginfo>: New field.
	* linux-low.c (linux_xfer_siginfo): New.
	(linux_target_ops): Set it.

2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Signals): Document $_siginfo.
	(Convenience Variables): Mention $_siginfo.
	(Remote Configuration): Document qXfer:siginfo:read,
	qXfer:siginfo:write packets, and the read-siginfo-object,
	write-siginfo-object commands.

2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/siginfo-obj.c, gdb.base/siginfo-obj.exp: New.
@
text
@a4362 16
	  if (ui_out_is_mi_like_p (uiout))
	    {

	      ui_out_field_int (uiout, "thread-id",
				pid_to_thread_id (inferior_ptid));
	      if (non_stop)
		{
		  struct cleanup *back_to = make_cleanup_ui_out_list_begin_end 
		    (uiout, "stopped-threads");
		  ui_out_field_int (uiout, NULL,
				    pid_to_thread_id (inferior_ptid));		  		  
		  do_cleanups (back_to);
		}
	      else
		ui_out_field_string (uiout, "stopped-threads", "all");
	    }
d4417 2
a4418 1
	observer_notify_normal_stop (inferior_thread ()->stop_bpstat);
d4420 1
a4420 1
	observer_notify_normal_stop (NULL);
@


1.356
log
@	* target.h (target_waitstatus_to_string): Declare.
	* target.c (target_waitstatus_to_string): New function.  Copied from
	debug_to_wait.  Add missing entries for TARGET_WAITKIND_SYSCALL_ENTRY,
	TARGET_WAITKIND_SYSCALL_RETURN, TARGET_WAITKIND_IGNORE,
	TARGET_WAITKIND_NO_HISTORY.
	(debug_to_wait): Call it.
	* infrun.c (wait_for_inferior): If debug_infrun, print result of
	target_wait.
	(fetch_inferior_event): Ditto.
@
text
@d4807 81
d5551 6
@


1.355
log
@	* infrun.c (normal_stop): Don't call
	deprecated_update_frame_pc_hack.
	* frame.c (deprecated_update_frame_pc_hack)
	(deprecated_update_frame_base_hack): Delete, and ...
	(create_new_frame): ... inline here.
	* frame.h (deprecated_update_frame_pc_hack)
	(deprecated_update_frame_base_hack): Delete declarations.
@
text
@d1792 10
d1877 10
@


1.354
log
@2009-01-23  Pedro Alves  <pedro@@codesourcery.com>

	PR gdb/9664:
	* infrun.c (normal_stop): Tag threads as stopped, and run the
	hook-stop before printing the stack frame.

2009-01-23  Pedro Alves  <pedro@@codesourcery.com>

	PR gdb/9664:
	* gdb.base/hook-stop-frame.c, gdb.base/hook-stop-frame.exp: New.
@
text
@a4226 11
  /* NOTE drow/2004-01-17: Is this still necessary?  */
  /* Make sure that the current_frame's pc is correct.  This
     is a correction for setting up the frame info before doing
     gdbarch_decr_pc_after_break */
  if (target_has_execution)
    /* FIXME: cagney/2002-12-06: Has the PC changed?  Thanks to
       gdbarch_decr_pc_after_break, the program counter can change.  Ask the
       frame code to check for this and sort out any resultant mess.
       gdbarch_decr_pc_after_break needs to just go away.  */
    deprecated_update_frame_pc_hack (get_current_frame (), read_pc ());

@


1.353
log
@	* dummy-frame.c (dummy_frame): Replace regcache member with
	caller_state.
	(dummy_frame_push): Replace caller_regcache arg with caller_state.
	All callers updated.
	(remove_dummy_frame,pop_dummy_frame,lookup_dummy_frame): New fns.
	(dummy_frame_pop): Rewrite.  Verify requested frame is in the
	dummy frame stack.  Restore program state.
	(cleanup_dummy_frames): Rewrite.
	(dummy_frame_sniffer): Update.  Make static.
	* dummy-frame.h (regcache,frame_info): Delete forward decls.
	(inferior_thread_state): New forward decl.
	(dummy_frame_push): Update prototype.
	* frame.c (frame_pop): dummy_frame_pop now does all the work for
	DUMMY_FRAMEs.
	* infcall.c (breakpoint_auto_delete_contents): Delete.
	(get_function_name,run_inferior_call): New fns.
	(call_function_by_hand): Simplify by moving some code to
	get_function_name, run_inferior_call.  Inferior function call wrapped
	in TRY_CATCH so there's less need for cleanups and all exits from
	proceed are handled similarily.  Detect program exit.
	Detect program stopping in a different thread.
	Make error messages more consistent.
	* inferior.h (inferior_thread_state): Declare (opaque type).
	(save_inferior_thread_state,restore_inferior_thread_state,
	make_cleanup_restore_inferior_thread_state,
	discard_inferior_thread_state, get_inferior_thread_state_regcache):
	Declare.
	(save_inferior_status): Update prototype.
	* infrun.c: (normal_stop): When stopped for the completion of an
	inferior function call, verify the expected stack frame kind.
	(inferior_thread_state): New struct.
	(save_inferior_thread_state,restore_inferior_thread_state,
	do_restore_inferior_thread_state_cleanup,
	make_cleanup_restore_inferior_thread_state,
	discard_inferior_thread_state,
	get_inferior_thread_state_regcache): New functions.
	(inferior_status): Move stop_signal, stop_pc, registers to
	inferior_thread_state.  Remove restore_stack_info.
	(save_inferior_status): Remove arg restore_stack_info.
	All callers updated.  Remove saving of state now saved by
	save_inferior_thread_state.
	(restore_inferior_status): Remove restoration of state now done by
	restore_inferior_thread_state.
	(discard_inferior_status): Remove freeing of registers, now done by
	discard_inferior_thread_state.

	* gdb.base/break.exp: Update expected gdb output.
	* gdb.base/sepdebug.exp: Ditto.
	* gdb.mi/mi-syn-frame.exp: Ditto.
	* gdb.mi/mi2-syn-frame.exp: Ditto.

	* gdb.base/call-signal-resume.exp: New file.
	* gdb.base/call-signals.c: New file.
	* gdb.base/unwindonsignal.exp: New file.
	* gdb.base/unwindonsignal.c: New file.
	* gdb.threads/interrupted-hand-call.exp: New file.
	* gdb.threads/interrupted-hand-call.c: New file.
	* gdb.threads/thread-unwindonsignal.exp: New file.
@
text
@d4272 9
a4436 10

  /* Tell the frontend about the new thread states.  */
  do_cleanups (old_chain);

  /* Look up the hook_stop and run it (CLI internally handles problem
     of stop_command's pre-hook not existing).  */
  if (stop_command)
    catch_errors (hook_stop_stub, stop_command,
		  "Error while running hook_stop:\n", RETURN_MASK_ALL);

@


1.352
log
@	PR gdb/9747:
	* gdbthread.h (finish_thread_state, finish_thread_state_cleanup):
	Declare.
	* thread.c (finish_thread_state, finish_thread_state_cleanup): New.
	* infrun.c (wait_for_inferior, fetch_inferior_event): If an error
	is thrown while handling an event, finish the thread state.
	(normal_stop): Use finish_thread_state cleanup.
	* infcmd.c (run_command_1): If an error is thrown while starting
	the inferior, finish the thread state.
@
text
@a47 1

d4389 14
a4402 8
      /* Pop the empty frame that contains the stack dummy.  POP_FRAME
         ends with a setting of the current frame, so we can use that
         next. */
      frame_pop (get_current_frame ());
      /* Set stop_pc to what it was before we called the function.
         Can't rely on restore_inferior_status because that only gets
         called if we don't stop in the called function.  */
      stop_pc = read_pc ();
d4800 9
a4808 1
struct inferior_status
d4812 67
d4892 1
a4892 6
  /* These are here because if call_function_by_hand has written some
     registers and then decides to call error(), we better not have changed
     any registers.  */
  struct regcache *registers;

  /* A frame unique identifier.  */
a4895 1
  int restore_stack_info;
d4900 1
a4900 2
   connection.  INF_STATUS is a pointer to a "struct inferior_status"
   (defined in inferior.h).  */
d4903 1
a4903 1
save_inferior_status (int restore_stack_info)
a4908 2
  inf_status->stop_signal = tp->stop_signal;
  inf_status->stop_pc = stop_pc;
a4925 1
  inf_status->restore_stack_info = restore_stack_info;
d4928 1
a4928 1
  inf_status->registers = regcache_dup (get_current_regcache ());
a4929 1
  inf_status->selected_frame_id = get_frame_id (get_selected_frame (NULL));
d4954 2
a4961 2
  tp->stop_signal = inf_status->stop_signal;
  stop_pc = inf_status->stop_pc;
d4974 1
d4978 1
a4978 15
  /* The inferior can be gone if the user types "print exit(0)"
     (and perhaps other times).  */
  if (target_has_execution)
    /* NB: The register write goes through to the target.  */
    regcache_cpy (get_current_regcache (), inf_status->registers);
  regcache_xfree (inf_status->registers);

  /* FIXME: If we are being called after stopping in a function which
     is called from gdb, we should not be trying to restore the
     selected frame; it just prints a spurious error message (The
     message is useful, however, in detecting bugs in gdb (like if gdb
     clobbers the stack)).  In fact, should we be restoring the
     inferior status at all in that case?  .  */

  if (target_has_stack && inf_status->restore_stack_info)
a4989 1

a5011 1
  regcache_xfree (inf_status->registers);
d5014 1
a5014 1

@


1.351
log
@	* target.h (target_signal_to_string): Make return type const char *.
	(target_signal_to_name): Ditto.
	(target_signal_from_name): Make arg const char *.
	* thread-db.c (thread_db_err_str): Make return type const char *.
	* utils.c (perror_with_name): Make arg const char *.
	* infrun.c (sig_print_info): Update.

	* signals/signals.c (signals): Make array and struct members const.
	(target_signal_to_string): Make return type const char *.
	(target_signal_to_name): Ditto.
	(target_signal_from_name): Make arg const char *.

	* gdbserver/gdbreplay.c (perror_with_name): Make arg const char *.
	* gdbserver/server.h (target_signal_to_name): Make return type
	const char *.
@
text
@d1786 2
d1800 5
d1808 3
d1833 1
d1877 8
d1908 3
d4186 1
d4190 13
d4422 1
d4424 2
a4425 12
      /* Mark the stopped threads accordingly.  In all-stop, all
	 threads of all processes are stopped when we get any event
	 reported.  In non-stop mode, only the event thread stops.  If
	 we're handling a process exit in non-stop mode, there's
	 nothing to do, as threads of the dead process are gone, and
	 threads of any other process were left running.  */
      if (!non_stop)
	set_running (minus_one_ptid, 0);
      else if (last.kind != TARGET_WAITKIND_SIGNALLED
	       && last.kind != TARGET_WAITKIND_EXITED)
	set_running (inferior_ptid, 0);
    }
@


1.350
log
@gdb/
2009-01-07  Pedro Alves  <pedro@@codesourcery.com>

	Delete ONE_PROCESS_WRITETEXT leftovers.

	* breakpoint.c (insert_bp_location): Delete process_warning
	argument.  Adjust.
	(insert_breakpoint_locations): Adjust.
	(reattach_breakpoints): Adjust.
	* infrun.c (normal_stop): Drop "It might be running in another
	process" notice.

gdb/doc/
2009-01-07  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Error in Breakpoints): Delete mention of "The same
	program may be running in another process" errors.
	* gdbint.texinfo (Native Conditionals): Delete
	ONE_PROCESS_WRITETEXT description.
@
text
@d4467 1
a4467 1
  char *name = target_signal_to_name (oursig);
@


1.349
log
@        Updated copyright notices for most files.
@
text
@a4209 1
It might be running in another process.\n\
@


1.348
log
@2008-12-31  Pedro Alves  <pedro@@codesourcery.com>

	PR gdb/8812:
	* infrun.c (handle_command): Don't print a header or notify the
	target about signal changes if we didn't change any signal.

2008-12-31  Pedro Alves  <pedro@@codesourcery.com>

	PR gdb/8812:
	* gdb.base/signal.exp: Change kfail to fail, and update PR number.
@
text
@d6 1
a6 1
   2008 Free Software Foundation, Inc.
@


1.347
log
@	* infrun.c (handle_inferior_event): Correctly tag non-executing
	threads in multi-process.
	(normal_stop): Correctly tag stopped threads in multi-process.
@
text
@d4642 13
a4654 1
  target_notice_signals (inferior_ptid);
d4656 2
a4657 12
  if (from_tty)
    {
      /* Show the results.  */
      sig_print_header ();
      for (signum = 0; signum < nsigs; signum++)
	{
	  if (sigs[signum])
	    {
	      sig_print_info (signum);
	    }
	}
    }
@


1.347.2.1
log
@2008-12-26  Michael Snyder  <msnyder@@vmware.com>

	* Marker: adding teawater patches to branch.
@
text
@a52 2
#include "record.h"

d607 1
a607 2
	  && gdbarch_displaced_step_copy_insn_p (gdbarch)
	  && !RECORD_IS_USED);
a1311 6
   /* When GDB resume the inferior, process record target doesn't need to
      record the memory and register store operation of GDB. So set
      record_not_record to 1. */
  if (RECORD_IS_USED)
    record_not_record_set ();

@


1.347.2.2
log
@2008-12-26  Michael Snyder  <msnyder@@vmware.com>

	* record.h: Don't export record_not_record.
	* infrun.c (proceed): Don't call record_not_record_set.
	* record.h (record_not_record): Rename to in_record_wait.
	(record_not_record_set): Rename to in_record_wait_set.
	(record_not_record_cleanup): Rename to in_record_wait_cleanup.
	(record_store_registers): Check in_record_wait flag.
	(record_xfer_partial): Ditto.
@
text
@d1315 6
@


1.347.2.3
log
@Change "RECORD_IS_USED" to "TARGET_IS_PROCESS_RECORD".
@
text
@d610 1
a610 1
	  && !TARGET_IS_PROCESS_RECORD);
@


1.346
log
@	* infrun.c (handle_inferior_event): On a TARGET_WAITKIND_EXITED or
	TARGET_WAITKIND_SIGNALLED, switch inferior_ptid to the event ptid.
	* linux_thread_db.c (thread_db_wait): On a TARGET_WAITKIND_EXITED
	or TARGET_WAITKIND_SIGNALLED, return the ptid the beneath target
	returned.
	* inf-ptrace.c (inf_ptrace_wait): Return inferior_ptid instead of
	minus_one_ptid if the inferior disappeared.
	* rs6000-nat.c (rs6000_wait): Likewise.
	* spu-linux-nat.c (spu_child_wait): Likewise.
@
text
@d2144 11
a2154 7
      /* Mark the non-executing threads accordingly.  */
      if (!non_stop
 	  || ecs->ws.kind == TARGET_WAITKIND_EXITED
 	  || ecs->ws.kind == TARGET_WAITKIND_SIGNALLED)
 	set_executing (pid_to_ptid (-1), 0);
      else
 	set_executing (ecs->ptid, 0);
d4379 2
a4380 3
  if (target_has_execution
      && last.kind != TARGET_WAITKIND_SIGNALLED
      && last.kind != TARGET_WAITKIND_EXITED)
d4382 12
a4393 4
      /* Delete the breakpoint we stopped at, if it wants to be deleted.
	 Delete any breakpoint that is to be deleted at the next stop.  */
      breakpoint_auto_delete (inferior_thread ()->stop_bpstat);

d4395 3
a4397 2
	set_running (pid_to_ptid (-1), 0);
      else
@


1.345
log
@	* infrun.c (handle_inferior_event): Remove redundant resetting of
	stepping_past_singlestep_breakpoint.
@
text
@d2274 1
d2293 1
@


1.344
log
@	* infrun.c (handle_inferior_event): Delete unused local tp.
@
text
@a2512 2
  stepping_past_singlestep_breakpoint = 0;

@


1.343
log
@* infrun.c (proceed): Delete unused local stop_signal.
@
text
@a2523 2
	  struct thread_info *tp;

@


1.342
log
@        Remove the unused BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK.

        * breakpoint.h (enum bpstat_what_main_action): Remove
        BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK.
        * breakpoint.c (bpstat_what): Delete catch_shlib_event from enum class.
        Remove the BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK column from
        variable table.
        * infrun.c (wait_for_inferior): Remove handling of
        BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK.
@
text
@a1305 1
  enum target_signal stop_signal;
@


1.341
log
@	* infrun.c (resume): If following a fork, also reset regcache,
	gdbarch and pc.
@
text
@a3163 1
      case BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK:
@


1.340
log
@	* infrun.c (resume): If following a fork, reread the current
	thread.  Avoid dereferencing a possibly dangling pointer.
@
text
@d968 2
d974 1
d1063 3
@


1.339
log
@	* inferior.h (proceed_to_finish): Delete, unused.
	(stop_registers): Tweak comment.
	* infrun.c (stop_registers): Tweak comment.
@
text
@d1056 4
a1154 2
      target_resume (resume_ptid, step, sig);

d1158 2
@


1.339.2.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@a274 3
int detach_fork = 1;		/* Default behavior is to detach
				   newly forked processes (legacy).  */

@


1.339.2.2
log
@2008-11-25  Pedro Alves  <pedro@@codesourcery.com>

	2008-11-25  Pedro Alves  <pedro@@codesourcery.com>

	* linux-fork.c (detach_fork): Delete declaration.
	(_initialize_linux_fork): Move "set detach-on-fork"
	command to ...
	* infrun.c (_initialize_infrun): ... here.
	* inferior.h (detach_fork): Declare.

	2008-11-10  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (read_ptid): If we don't know about any inferior yet,
	use the pid of magic_null_ptid.
	(remote_start_remote): Don't set inferior_ptid to magic_null_ptid
	here.

	2008-10-14  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (remote_start_remote): Mask async mode while collecting
	the initial event, use notice_new_inferior.

	2008-10-12  Pedro Alves  <pedro@@codesourcery.com>

	* infcmd.c (attach_command_post_wait): Set the inferior exec here.
	(attach_command): Don't set the inferior exec here.
	(notice_new_inferior): New.
	* inferior.h (notice_new_inferior): Declare.
	* remote.c (notice_new_inferiors): Add `stopping' argument.  Add
	the inferior before adding the threads.  Call notice_new_inferior.
	(record_currthread): Adjust.
	(remote_threads_info): Add the inferior before adding the thread.
	Call notice_new_inferior.

	2008-10-09  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (notice_new_inferiors): If there's only one exec, set
	it in the new inferior.
	(set_thread): If setting the thread failed, assume the thread has
	terminated.

	2008-09-17  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (delete_inferior_1): Free the inferior after freeing
	its threads.

	2008-09-16  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.h (discard_all_inferiors): Declare.
	* inferior.c (delete_inferior): Rename to...
	(delete_inferior_1): ...this.  Add 'silent' argument.  If this
	inferior is has pid not zero, delete its threads.
	(delete_inferior): New, as wrapper around delete_inferior_1.
	(delete_inferior_by_pid_1): Reimplement.
	(discard_all_inferiors): New.

	2008-09-15  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (extended_remote_attach_1): Don't set target_attach_no_wait.

	2008-09-15  Pedro Alves  <pedro@@codesourcery.com>

	* frame.c (get_current_frame, has_stack_frames): Check for
	null_ptid.
	* top.c (execute_command): Likewise.

	2008-08-29  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (have_real_inferiors): New.
	* inferior.h (have_real_inferiors): Declare.
	* remote.c (extended_remote_mourn_1): Use it.
	* top.c (quit_target): Use it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (parse_stop_reply): Handle Y;exec.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* infcmd.c (struct exec_file_attach_wrapper_args): New.
	(exec_file_attach_wrapper): New.
	(attach_command_post_wait): If there's a sysroot, prepend it to
	the target reported exec file path.  Continue attaching to the
	inferior event if attaching to the exec file fails.

	* remote.c (remote_pid_to_exec_file): Rebustify.  Expect
	"QExecFile:PID;" in the reply.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (record_currthread): If setting the current thread to
	minus_one_ptid, don't pass that to the stub.
	(remote_parse_stop_reply): Handle 'Y' stop reply.
	(remote_wait_as): Likewise.  If remote process exited, invalidate
	the current thread.
	(remote_detach_pid): New.
	(remote_follow_fork): New.
	(init_remote_ops): Register it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (remote_pid_to_exec_file): New.
	(init_remote_ops): Register it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* infcmd.c (kill_if_already_running): If target supports
	multi-process, allow multi-runs.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (extended_remote_create_inferior_1): Don't clear the
	thread list.
@
text
@a5309 6
  add_setshow_boolean_cmd ("detach-on-fork", class_run, &detach_fork, _("\
Set whether gdb will detach the child of a fork."), _("\
Show whether gdb will detach the child of a fork."), _("\
Tells gdb whether to detach the child of a fork."),
			   NULL, NULL, &setlist, &showlist);

@


1.339.2.3
log
@	Merge from head:
	2008-12-07  Pedro Alves  <pedro@@codesourcery.com>

	(handle_inferior_event): On a TARGET_WAITKIND_EXITED or
	TARGET_WAITKIND_SIGNALLED, switch inferior_ptid to the event ptid.
	* linux_thread_db.c (thread_db_wait): On a TARGET_WAITKIND_EXITED
	or TARGET_WAITKIND_SIGNALLED, return the ptid the beneath target
	returned.
	* inf-ptrace.c (inf_ptrace_wait): Return inferior_ptid instead of
	minus_one_ptid if the inferior disappeared.
	* rs6000-nat.c (rs6000_wait): Likewise.
	* spu-linux-nat.c (spu_child_wait): Likewise.
C
@
text
@a2267 1
      inferior_ptid = ecs->ptid;
a2285 1
      inferior_ptid = ecs->ptid;
@


1.339.2.4
log
@	Merge from head:
	2008-12-12  Pedro Alves  <pedro@@codesourcery.com>

	* infrun.c (handle_inferior_event): Correctly tag non-executing
	threads in multi-process.
	(normal_stop): Correctly tag stopped threads in multi-process.
@
text
@d2138 7
a2144 11
      /* Mark the non-executing threads accordingly.  In all-stop, all
	 threads of all processes are stopped when we get any event
	 reported.  In non-stop mode, only the event thread stops.  If
	 we're handling a process exit in non-stop mode, there's
	 nothing to do, as threads of the dead process are gone, and
	 threads of any other process were left running.  */
      if (!non_stop)
	set_executing (minus_one_ptid, 0);
      else if (ecs->ws.kind != TARGET_WAITKIND_SIGNALLED
	       && ecs->ws.kind != TARGET_WAITKIND_EXITED)
	set_executing (inferior_ptid, 0);
d4374 7
a4381 14
  if (target_has_execution)
    {
      if (last.kind != TARGET_WAITKIND_SIGNALLED
	  && last.kind != TARGET_WAITKIND_EXITED)
	/* Delete the breakpoint we stopped at, if it wants to be deleted.
	   Delete any breakpoint that is to be deleted at the next stop.  */
	breakpoint_auto_delete (inferior_thread ()->stop_bpstat);

      /* Mark the stopped threads accordingly.  In all-stop, all
	 threads of all processes are stopped when we get any event
	 reported.  In non-stop mode, only the event thread stops.  If
	 we're handling a process exit in non-stop mode, there's
	 nothing to do, as threads of the dead process are gone, and
	 threads of any other process were left running.  */
d4383 2
a4384 3
	set_running (minus_one_ptid, 0);
      else if (last.kind != TARGET_WAITKIND_SIGNALLED
	       && last.kind != TARGET_WAITKIND_EXITED)
@


1.338
log
@	PR gdb/2250
	* infrun.c (clear_proceed_status_thread): New function.
	(clear_proceed_status_callback): New function.
	(clear_proceed_status): In all-stop mode, clear per-thread
	proceed status of *all* threads, not only the current.
	(handle_inferior_event): In all-stop mode, if we're stepping
	one thread, but got some inferior event in another thread
	that does not cause GDB to break to the user interface,
	ensure the interrupted stepping operation continues in the
	original thread.
	(currently_stepping): Move thread-related tests to ...
	(currently_stepping_thread): ... this new function.
	(currently_stepping_callback): New function.
@
text
@d235 2
a236 2
/* Save register contents here when about to pop a stack dummy frame,
   if-and-only-if proceed_to_finish is set.
@


1.337
log
@        Remove support for catch load and catch unload commands.

        * breakpoint.h (enum bptype): Remove bp_catch_load and bp_catch_unload.
        (struct breakpoint): Remove fields dll_pathname and
        triggered_dll_pathname.
        (bpstat_get_triggered_catchpoints, ep_is_shlib_catchpoint): Delete.
        * breakpoint.c (ep_is_catchpoint): Remove handling of
        bp_catch_load and bp_catch_unload.
        (print_it_typical, bpstat_check_location, bpstat_what)
        (print_one_breakpoint_location, print_one_breakpoint_location)
        (user_settable_breakpoint, allocate_bp_location)
        (set_raw_breakpoint_without_location, mention, delete_breakpoint,
        (breakpoint_re_set_one, disable_command, enable_command): Likewise.
        (ep_is_shlib_catchpoint, bpstat_get_triggered_catchpoints)
        (catch_load_command_1, catch_unload_command_1): Delete.
        (_initialize_breakpoint): Remove the "catch load" and "catch unload"
        command creation.
        * infrun.c (handle_inferior_event): Remove the handling of
        load/unload catchpoint events.
@
text
@d78 2
d1166 33
a1203 1
      struct thread_info *tp;
d1206 13
a1218 17
      tp = inferior_thread ();

      tp->trap_expected = 0;
      tp->step_range_start = 0;
      tp->step_range_end = 0;
      tp->step_frame_id = null_frame_id;
      tp->step_over_calls = STEP_OVER_UNDEBUGGABLE;
      tp->stop_requested = 0;

      tp->stop_step = 0;

      tp->proceed_to_finish = 0;

      /* Discard any remaining commands or status from previous
	 stop.  */
      bpstat_clear (&tp->stop_bpstat);

d3218 37
d3674 16
d3692 1
a3692 4
  return (((tp->step_range_end && tp->step_resume_breakpoint == NULL)
	   || tp->trap_expected)
	  || tp->stepping_through_solib_after_catch
	  || bpstat_should_step ());
@


1.336
log
@	* defs.h (add_inferior_continuation)
	(do_all_inferior_continuations)
	(discard_all_inferior_continuations): Declare.
	* utils.c (add_inferior_continuation)
	(do_all_inferior_continuations)
	(discard_all_inferior_continuations): New.
	* inferior.h (struct inferior) <continuations>: New field.
	* inferior.c (free_inferior): Discard all the inferior
	continuations.
	* inf-loop.c (inferior_event_handler): Do all current inferior
	continuations.
	* infcmd.c (attach_command): Register an inferior continuation
	instead of a thread continuation.
	* infrun.c (handle_inferior_event): If stop_soon is
	STOP_QUIETLY_NO_SIGSTOP, also expect a TARGET_SIGNAL_0.
@
text
@a3164 37

	  /* If we stopped due to an explicit catchpoint, then the
	     (see above) call to SOLIB_ADD pulled in any symbols
	     from a newly-loaded library, if appropriate.

	     We do want the inferior to stop, but not where it is
	     now, which is in the dynamic linker callback.  Rather,
	     we would like it stop in the user's program, just after
	     the call that caused this catchpoint to trigger.  That
	     gives the user a more useful vantage from which to
	     examine their program's state. */
	  else if (what.main_action
		   == BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK)
	    {
	      /* ??rehrauer: If I could figure out how to get the
	         right return PC from here, we could just set a temp
	         breakpoint and resume.  I'm not sure we can without
	         cracking open the dld's shared libraries and sniffing
	         their unwind tables and text/data ranges, and that's
	         not a terribly portable notion.

	         Until that time, we must step the inferior out of the
	         dld callback, and also out of the dld itself (and any
	         code or stubs in libdld.sl, such as "shl_load" and
	         friends) until we reach non-dld code.  At that point,
	         we can stop stepping. */
	      bpstat_get_triggered_catchpoints (ecs->event_thread->stop_bpstat,
						&ecs->
						event_thread->
						stepping_through_solib_catchpoints);
	      ecs->event_thread->stepping_through_solib_after_catch = 1;

	      /* Be sure to lift all breakpoints, so the inferior does
	         actually step past this point... */
	      ecs->event_thread->stepping_over_breakpoint = 1;
	      break;
	    }
@


1.335
log
@	* inferior.h (write_inferior_status_register): Delete.
	* infrun.c (write_inferior_status_register): Delete.
@
text
@d2837 9
a2845 1
	 signal, so this is no exception.  */
d2848 2
a2849 1
	      || ecs->event_thread->stop_signal == TARGET_SIGNAL_TRAP))
@


1.334
log
@2008-10-26  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (handle_inferior_event): Handle dynamic symbol
	resolution in reverse.
@
text
@a4726 10
void
write_inferior_status_register (struct inferior_status *inf_status, int regno,
				LONGEST val)
{
  int size = register_size (current_gdbarch, regno);
  void *buf = alloca (size);
  store_signed_integer (buf, size, val);
  regcache_raw_write (inf_status->registers, regno, buf);
}

@


1.333
log
@        * infrun.c: Minor comment reformatting.
@
text
@d3396 16
@


1.332
log
@2008-10-24  Hui Zhu  <teawater@@gmail.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	* infrun.c (can_use_displaced_stepping): Change type to
	const char pointer.
	(can_use_displaced_stepping_auto): New string.
	(can_use_displaced_stepping_on): New string.
	(can_use_displaced_stepping_off): New string.
	(can_use_displaced_stepping_enum): New array.
	(show_can_use_displaced_stepping): In auto mode, also show
	the current effect of the option.
	(use_displaced_stepping): Return non-zero if displaced
	stepping is auto, and can be used with GDBARCH, and in
	non-stop mode.  Return non-zero if displaced stepping is on,
	and can be used with GDBARCH.  Return zero otherwise.
	(_initialize_infrun): Make the "set displaced-stepping"
	command an enum command.  Change its class to class_run.
	Place it in the top level set list.  Extend help to describe
	the auto mode.

2008-10-24  Hui Zhu  <teawater@@gmail.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (displaced-stepping): Describe the auto mode
	setting, and say it's the default.  This is now a mainstream
	setting instead of a maintenance setting.
@
text
@d3391 1
a3391 2
	     get there, we'll need to single-step back to the
	     caller.  */
@


1.331
log
@gdb/
2008-10-23  Pedro Alves  <pedro@@codesourcery.com>

	* defs.h: Mention ptid_is_pid.
	* inferior.h (ptid_is_pid): Declare.
	* gdbthread.h (struct thread_info) <stop_requested>: New field.
	(set_stop_requested): Declare.
	* infcmd.c (interrupt_target_1): Call set_stop_requested.
	* infrun.c (clear_proceed_status): Clear stop_requested.
	(infrun_thread_stop_requested_callback,
	infrun_thread_stop_requested): New.
	(handle_inferior_event): If a TARGET_SIGNAL_TRAP is reported on a
	thread that had an explicit stop request, pretend we got a
	TARGET_SIGNAL_0.  Always stop if the thread had an explicit stop
	request.
	(print_stop_reason): In the SIGNAL_RECEIVED case, if we're not
	outputting to MI, and we got a TARGET_SIGNAL_0, print "# Stopped",
	instead of mentioning signal 0.
	(ptid_is_pid): New.
	* thread.c (set_stop_requested): New.

	* linux-nat.c (queued_waitpid): Rename to ...
	(queued_waitpid_1): ... this.  Add `peek' argument.  Handle it.
	(queued_waitpid): New, as wrapper to queued_waitpid_1.
	(push_waitpid): Push the SIGTRAP to the local event queue, to the
	kernel's.
	(send_sigint_callback): Delete.
	(linux_nat_stop_lwp): New.
	(linux_nat_stop): Use it.

gdb/doc/
2008-10-23  Pedro Alves  <pedro@@codesourcery.com>

	* observer.texi (thread_stop_requested): New.

gdb/testsuite/
2008-10-23  Pedro Alves  <pedro@@codesourcery.com>

	* lib/mi-support.exp (mi_expect_interrupt): Expect signal 0
	instead of SIGINT.
@
text
@d556 24
a579 4
/* When this is non-zero, we are allowed to use displaced stepping, if
   the architecture supports it.  When this is zero, we use
   traditional the hold-and-step approach.  */
int can_use_displaced_stepping = 1;
d585 9
a593 3
  fprintf_filtered (file, _("\
Debugger's willingness to use displaced stepping to step over "
"breakpoints is %s.\n"), value);
d596 3
a598 2
/* Return non-zero if displaced stepping is enabled, and can be used
   with GDBARCH.  */
d602 3
a604 1
  return (can_use_displaced_stepping
d5273 3
a5275 2
  add_setshow_boolean_cmd ("can-use-displaced-stepping", class_maintenance,
			   &can_use_displaced_stepping, _("\
d5278 9
a5286 6
If zero, gdb will not use displaced stepping to step over\n\
breakpoints, even if such is supported by the target."),
			   NULL,
			   show_can_use_displaced_stepping,
			   &maintenance_set_cmdlist,
			   &maintenance_show_cmdlist);
@


1.330
log
@2008-10-19  Hui Zhu  <teawater@@gmail.com>

	* infrun.c (handle_inferior_event): Set "stop_pc" when
	TARGET_WAITKIND_NO_HISTORY.
@
text
@d1150 1
d1532 94
a2376 3
  /* Do we need to clean up the state of a thread that has completed a
     displaced single-step?  (Doing so usually affects the PC, so do
     it here, before we set stop_pc.)  */
d2378 14
a2391 1
    displaced_step_fixup (ecs->ptid, ecs->event_thread->stop_signal);
d2887 3
a2889 2
      /* Always stop on signals if we're just gaining control of the
	 program.  */
d2891 1
d4001 2
a4002 2
      /* Signal received. The signal table tells us to print about
         it. */
d4004 27
a4030 13
      ui_out_text (uiout, "\nProgram received signal ");
      annotate_signal_name ();
      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_string
	  (uiout, "reason", async_reason_lookup (EXEC_ASYNC_SIGNAL_RECEIVED));
      ui_out_field_string (uiout, "signal-name",
			   target_signal_to_name (stop_info));
      annotate_signal_name_end ();
      ui_out_text (uiout, ", ");
      annotate_signal_string ();
      ui_out_field_string (uiout, "signal-meaning",
			   target_signal_to_string (stop_info));
      annotate_signal_string_end ();
d4941 13
d5271 1
@


1.329
log
@	* infrun.c (adjust_pc_after_break): Do nothing if executing in
	reverse.
@
text
@d2240 1
@


1.328
log
@2008-10-17  Michael Snyder  <msnyder@@vmware.com>
	Target interface for reverse debugging.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(struct target_ops): New method to_can_execute_reverse.
	(target_can_execute_reverse): New macro.
	* target.c (update_current_target): Inherit to_can_execute_reverse.

	Remote interface for reverse debugging.
	* remote.c (remote_can_execute_reverse): New target method.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait_as): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(remote_vcont_resume): Jump out if attempting reverse execution.

	Event handling interface for reverse debugging.
	* infrun.c (execution_direction): New state variable.
	(enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.
	(step_into_function): Rename to handle_step_into_function.
	(handle_step_into_function_backward): New function.
	(set_exec_direction_func, show_exec_direction_func): New funcs.
	(proceed): No need to singlestep over a breakpoint
	when resuming in reverse.

	* inferior.h (enum exec_direction_kind): New enum.
	(execution_direction): Export new execution state variable.

	* breakpoint.c (make_breakpoint_silent): New function.
	* breakpoint.h (make_breakpoint_silent): Export.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.

	User interface for reverse execution.
	* Makefile.in (reverse.c): New file.
	* reverse.c: New file.  User interface for reverse execution.
@
text
@d1829 29
@


1.327
log
@gdb/
*	breakpoint.c (breakpoint_init_inferior): Clean up the moribund
	locations list.
	(moribund_breakpoint_here_p): Record the moribund
	location in the moribund_locations vector.
	* breakpoint.h (moribund_breakpoint_here_p): Declare.
	(displaced_step_fixup): Check if the breakpoint the thread was
	trying to step over has been removed since having been placed in
	the displaced stepping queue.
	(adjust_pc_after_break): In non-stop mode, check for a moribund
	breakpoint at the stop pc.
	(handle_inferior_event): Don't retire moribund breakpoints on
	TARGET_WAITKIND_IGNORE.

gdb/testsuite/
	* gdb.mi/mi-nsmoribund.exp, gdb.mi/nsmoribund.c: New test.
@
text
@d1245 2
a1246 1
      if (pc == stop_pc && breakpoint_here_p (pc))
d1250 6
a1255 1
	   breakpoint).  */
d1484 3
a1486 1
  SIGNAL_RECEIVED
d1517 2
a1518 1
static void step_into_function (struct execution_control_state *ecs);
d2209 6
d2935 11
d3111 1
a3111 1
	 fprintf_unfiltered (gdb_stdlog, "infrun: stepping inside range [0x%s-0x%s]\n",
d3114 15
a3128 1
      keep_going (ecs);
d3188 3
a3190 2
      && frame_id_eq (frame_unwind_id (get_current_frame ()),
		      ecs->event_thread->step_frame_id))
d3216 22
a3237 4
	  /* We're doing a "next", set a breakpoint at callee's return
	     address (the address at which the caller will
	     resume).  */
	  insert_step_resume_breakpoint_at_caller (get_current_frame ());
d3277 4
a3280 1
	    step_into_function (ecs);
d3297 14
a3310 3
      /* Set a breakpoint at callee's return address (the address at
         which the caller will resume).  */
      insert_step_resume_breakpoint_at_caller (get_current_frame ());
d3462 3
a3464 2
/* Subroutine call with source code we should not step over.  Do step
   to the first line of code in it.  */
d3467 1
a3467 1
step_into_function (struct execution_control_state *ecs)
d3474 2
a3475 2
    ecs->stop_func_start = gdbarch_skip_prologue
			     (current_gdbarch, ecs->stop_func_start);
d3538 37
d3882 4
d4817 49
d5091 8
@


1.326
log
@	* infrun.c (displaced_step_prepare): Switch thread temporarily
	while we're here.
	(displaced_step_fixup): Make sure target_resume sees ptid as
	inferior_ptid.  Add debug output.
@
text
@d792 2
d796 1
a796 1
  if (displaced_step_request_queue)
d800 1
d807 1
a807 4
      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog,
			    "displaced: stepping queued %s now\n",
			    target_pid_to_str (ptid));
d809 1
a809 3
      displaced_step_ptid = null_ptid;
      displaced_step_prepare (ptid);
      context_switch (ptid);
d811 1
a811 1
      if (debug_displaced)
d813 16
a828 3
	  struct regcache *resume_regcache = get_thread_regcache (ptid);
	  CORE_ADDR actual_pc = regcache_read_pc (resume_regcache);
	  gdb_byte buf[4];
d830 4
a833 4
	  fprintf_unfiltered (gdb_stdlog, "displaced: run 0x%s: ",
			      paddr_nz (actual_pc));
	  read_memory (actual_pc, buf, sizeof (buf));
	  displaced_step_dump_bytes (gdb_stdlog, buf, sizeof (buf));
d835 15
d851 6
a856 1
      target_resume (ptid, 1, TARGET_SIGNAL_0);
d1832 10
a1841 3
  /* Check whether there actually is a software breakpoint inserted
     at that location.  */
  if (software_breakpoint_inserted_here_p (breakpoint_pc))
a1913 2
  breakpoint_retire_moribund ();

d1941 2
@


1.325
log
@2008-10-05  Michael Snyder  <msnyder@@promb-2s-dhcp59.eng.vmware.com>

	* infrun.c (handle_inferior_event): Fix typo in comment.
@
text
@d632 1
a632 1
  struct cleanup *old_cleanups;
d684 3
d694 2
a695 2
  old_cleanups = make_cleanup (free_current_contents,
                               &displaced_step_saved_copy);
d705 1
a705 1
                                              original, copy, regcache);
d715 3
a717 1
  discard_cleanups (old_cleanups);
d721 1
a721 1
                        paddr_nz (copy));
a808 1

d811 14
@


1.324
log
@2008-10-03  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* utils.c, defs.h (gdb_buildargv): New fn. Wrap buildargv
	and check for out-of-memory condition.
	* exec.c (exec_file_command): Call it.
	* infrun.c (handle_command, xdb_handle_command): Likewise.
	* interps.c (interpreter_exec_cmd): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* procfs.c (info_proc_cmd): Likewise.
	* remote-mips.c (common_open): Likewise.
	* remote-sim.c (gdbsim_kill, gdbsim_create_inferior)
	(gdbsim_open): Likewise.
	* remote.c (extended_remote_run, remote_put_command)
	(remote_get_command, remote_delete_command): Likewise.
	* ser-mingw.c (pipe_windows_open): Likesise.
	* source.c (add_path, show_substitute_path_command)
	(unset_substitute_path_command, set_substitute_path_command):
	Likewise.
	* stack.c (backtrace_command): Likewise.
	* symfile.c (symbol_file_command, generic_load)
	(add_symbol_file_command): Likesise.
	* symmisc.c (maintenance_print_symbols, maintenance_print_psymbols)
	(maintenance_print_msymbols): Likewise.
@
text
@d2628 1
a2628 1
         If someone ever tries to get get call dummys on a
@


1.323
log
@	* mips-linux-tdep.c (mips_linux_in_dynsym_resolve_code): Update
	comments.
	(mips_linux_skip_resolver): Also use glibc_skip_solib_resolver.
	(mips_linux_init_abi): Do not override skip_trampoline_code.
	* configure.tgt (mips*-*-linux*): Add glibc-tdep.o.
	* mips-tdep.c (mips32_scan_prologue): Stop scanning at branches.
	(mips_stub_frame_sniffer): Use the stub frame sniffer for PIC stubs.
	(mips_skip_mips16_trampoline_code): Rename from
	mips_skip_trampoline_code.
	(mips_skip_pic_trampoline_code, mips_skip_trampoline_code): New.
	* infrun.c (handle_inferior_event): Do not pass zero to
	in_solib_dynsym_resolve_code.
@
text
@d4073 1
a4073 5
  argv = buildargv (args);
  if (argv == NULL)
    {
      nomem (0);
    }
d4230 3
d4235 1
a4235 5
  argv = buildargv (args);
  if (argv == NULL)
    {
      nomem (0);
    }
@


1.322
log
@	* infrun.c (follow_exec): Don't do a generic mourn.  Instead
	inline the required bits.
	* breakpoint.h (enum inf_context): Add inf_execd.
@
text
@d3139 1
a3139 1
      if (in_solib_dynsym_resolve_code (ecs->stop_func_start))
@


1.322.2.1
log
@2008-09-30  Michael Snyder  <msnyder@@vmware.com>
	Event handling interface for reverse debugging.
	* infrun.c (enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.
@
text
@d1196 1
a1196 2
      if (pc == stop_pc && breakpoint_here_p (pc) 
	  && target_get_execution_direction () != EXEC_REVERSE)
d1200 1
a1200 6
	   breakpoint).

	   Note, we don't do this in reverse, because we won't
	   actually be executing the breakpoint insn anyway.
	   We'll be (un-)executing the previous instruction.  */

d1429 1
a1429 3
  SIGNAL_RECEIVED,
  /* Reverse execution -- target ran out of history info.  */
  NO_HISTORY
a2143 6
    case TARGET_WAITKIND_NO_HISTORY:
      /* Reverse execution: target ran out of history info.  */
      print_stop_reason (NO_HISTORY, 0);
      stop_stepping (ecs);
      return;

a2863 11
	if (stop_pc == ecs->stop_func_start &&
	    target_get_execution_direction () == EXEC_REVERSE)
	  {
	    /* We are stepping over a function call in reverse, and
	       just hit the step-resume breakpoint at the start
	       address of the function.  Go back to single-stepping,
	       which should take us back to the function call.  */
	    ecs->event_thread->stepping_over_breakpoint = 1;
	    keep_going (ecs);
	    return;
	  }
d3029 1
a3029 1
	fprintf_unfiltered (gdb_stdlog, "infrun: stepping inside range [0x%s-0x%s]\n",
d3032 1
a3032 16

      /* When stepping backward, stop at beginning of line range
	 (unles it's the function entry point, in which case
	 keep going back to the call point).  */
      if (stop_pc == ecs->event_thread->step_range_start &&
	  stop_pc != ecs->stop_func_start &&
	  target_get_execution_direction () == EXEC_REVERSE)
	{
	  ecs->event_thread->stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	}
      else
	{
	  keep_going (ecs);
	}
d3119 4
a3122 25
	  /* We're doing a "next".

	     Normal (forward) execution: set a breakpoint at the
	     callee's return address (the address at which the caller
	     will resume).

	     Reverse (backward) execution.  set the step-resume
	     breakpoint at the start of the function that we just
	     stepped into (backwards), and continue to there.  When we
	     get there, we'll need to single-step back to the
	     caller.  */

	  if (target_get_execution_direction () == EXEC_REVERSE)
	    {
	      /* FIXME: I'm not sure if we've handled the frame for
		 recursion.  */

	      struct symtab_and_line sr_sal;
	      init_sal (&sr_sal);
	      sr_sal.pc = ecs->stop_func_start;
	      insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
	    }
	  else
	    insert_step_resume_breakpoint_at_caller (get_current_frame ());

d3179 3
a3181 16
      if (target_get_execution_direction () == EXEC_REVERSE)
	{
	  /* Set a breakpoint at callee's start address.
	     From there we can step once and be back in the caller.  */
	  /* FIXME: I'm not sure we've handled the frame for recursion.  */
	  struct symtab_and_line sr_sal;
	  init_sal (&sr_sal);
	  sr_sal.pc = ecs->stop_func_start;
	  insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
	}
      else
	{
	  /* Set a breakpoint at callee's return address (the address
	     at which the caller will resume).  */
	  insert_step_resume_breakpoint_at_caller (get_current_frame ());
	}
a3346 22
  if (target_get_execution_direction () == EXEC_REVERSE)
    {
      stop_func_sal = find_pc_line (stop_pc, 0);

      /* OK, we're just gonna keep stepping here.  */
      if (stop_func_sal.pc == stop_pc)
	{
	  /* We're there already.  Just stop stepping now.  */
	  ecs->event_thread->stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}
      /* Else just reset the step range and keep going.
	 No step-resume breakpoint, they don't work for
	 epilogues, which can have multiple entry paths.  */
      ecs->event_thread->step_range_start = stop_func_sal.pc;
      ecs->event_thread->step_range_end   = stop_func_sal.end;
      keep_going (ecs);
      return;
    }
  /* else... */
a3714 4
    case NO_HISTORY:
      /* Reverse execution: target ran out of history info.  */
      ui_out_text (uiout, "\nNo more reverse-execution history.\n");
      break;
@


1.322.2.2
log
@Take out 'FIXME' comments
@
text
@d3173 3
d3244 1
@


1.322.2.3
log
@2008-10-05  Michael Snyder  <msnyder@@promb-2s-dhcp59.eng.vmware.com>

	* infrun.c (handle_inferior_event): Fix typo in comment.
@
text
@d2642 1
a2642 1
         If someone ever tries to get call dummys on a
@


1.322.2.4
log
@2008-10-05  Hui Zhu  <teawater@@gmail.com>

	* infcmd.c (kill_if_already_running): If record target is used,
	output special query.
	* infrun.c (use_displaced_stepping): Return false if record/replay.
	(proceed): Do not record state changes made by gdb in 'proceed'.
@
text
@a52 2
#include "record.h"

d576 1
a576 2
	  && gdbarch_displaced_step_copy_insn_p (gdbarch)
	  && !RECORD_IS_USED);
a1193 6
  /* When GDB resumes the inferior, record target doesn't need to
     record the memory and register store operation of GDB.  So set
     record_not_record to 1.  */
  if (RECORD_IS_USED)
    record_not_record_set ();

@


1.322.2.5
log
@2008-10-06  Michael Snyder  <msnyder@@vmware.com>

        * infrun.c (handle_inferior_event): Formatting, spelling fix.

	* infrun.c (handle_inferior_event): Add special case for
	"next" in reverse.
@
text
@d2887 2
a2888 2
	if (stop_pc == ecs->stop_func_start
	    && target_get_execution_direction () == EXEC_REVERSE)
d3068 1
a3068 1
	 (unless it's the function entry point, in which case
d3070 3
a3072 3
      if (stop_pc == ecs->event_thread->step_range_start
	  && stop_pc != ecs->stop_func_start
	  && target_get_execution_direction () == EXEC_REVERSE)
d3141 2
a3142 3
      && (frame_id_eq (frame_unwind_id (get_current_frame ()),
		       ecs->event_thread->step_frame_id)
	  || target_get_execution_direction () == EXEC_REVERSE))
@


1.322.2.6
log
@2008-10-06  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (handle_inferior_event, step_into_function): Formatting.
@
text
@d3079 3
a3081 2
	keep_going (ecs);

d3257 5
a3261 4
	/* Set a breakpoint at callee's return address (the address
	   at which the caller will resume).  */
	insert_step_resume_breakpoint_at_caller (get_current_frame ());

d3444 1
a3444 1
      ecs->event_thread->step_range_end = stop_func_sal.end;
@


1.322.2.7
log
@2008-10-06  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (handle_inferior_event): Comment rewording.
@
text
@d3429 1
a3429 1
      /* OK, we're just going to keep stepping here.  */
@


1.322.2.8
log
@2008-10-06  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (step_into_function): Rename to stepped_into_function.
	Split into two versions (normal (forward), and reverse).
	(handle_inferior_event): Call stepped_into_function or
	stepped_into_function_backward, depending on exec_direction.
@
text
@d1477 1
a1477 2
static void stepped_into_function (struct execution_control_state *ecs);
static void stepped_into_function_backward (struct execution_control_state *ecs);
d3229 1
a3229 7
	    /* Find start of appropriate source line (either first or
	       last line in callee, depending on execution
	       direction).  */	      
	    if (target_get_execution_direction () == EXEC_REVERSE)
	      stepped_into_function_backward (ecs);
	    else
	      stepped_into_function (ecs);
d3411 2
a3412 3
/* Inferior has stepped into a subroutine call with source code that
   we should not step over.  Do step to the first line of code in
   it.  */
d3415 1
a3415 1
stepped_into_function (struct execution_control_state *ecs)
d3422 2
a3423 2
    ecs->stop_func_start = gdbarch_skip_prologue (current_gdbarch, 
						  ecs->stop_func_start);
d3425 22
a3507 37
/* Inferior has stepped backward into a subroutine call with source
   code that we should not step over.  Do step to the beginning of the
   last line of code in it.  */

static void
stepped_into_function_backward (struct execution_control_state *ecs)
{
  struct symtab *s;
  struct symtab_and_line stop_func_sal, sr_sal;

  s = find_pc_symtab (stop_pc);
  if (s && s->language != language_asm)
    ecs->stop_func_start = gdbarch_skip_prologue (current_gdbarch, 
						  ecs->stop_func_start);

  stop_func_sal = find_pc_line (stop_pc, 0);

  /* OK, we're just going to keep stepping here.  */
  if (stop_func_sal.pc == stop_pc)
    {
      /* We're there already.  Just stop stepping now.  */
      ecs->event_thread->stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
    }
  else
    {
      /* Else just reset the step range and keep going.
	 No step-resume breakpoint, they don't work for
	 epilogues, which can have multiple entry paths.  */
      ecs->event_thread->step_range_start = stop_func_sal.pc;
      ecs->event_thread->step_range_end = stop_func_sal.end;
      keep_going (ecs);
    }
  return;
}

@


1.322.2.9
log
@2008-10-07  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c, infrun.c, linux-record.c, linux-record.h,
	record.c, record.h: Change name from
	"record and reverse target" to
	"process record and replay target".
@
text
@d1197 3
a1199 3
   /* When GDB resume the inferior, process record target doesn't need to
      record the memory and register store operation of GDB. So set
      record_not_record to 1. */
@


1.322.2.10
log
@2008-10-07  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (stepped_into_function): Rename handle_step_into_function.
	(stepped_into_function_backward):
	Rename handle_step_into_function_backward.
@
text
@d1477 2
a1478 2
static void handle_step_into_function (struct execution_control_state *ecs);
static void handle_step_into_function_backward (struct execution_control_state *ecs);
d3230 3
d3234 1
a3234 1
	      handle_step_into_function_backward (ecs);
d3236 1
a3236 1
	      handle_step_into_function (ecs);
d3423 1
a3423 1
handle_step_into_function (struct execution_control_state *ecs)
d3499 1
a3499 1
handle_step_into_function_backward (struct execution_control_state *ecs)
@


1.322.2.11
log
@2008-10-07  Michael Snyder  <msnyder@@vmware.com>

	* target.h (to_set_exec_direction, to_get_exec_direction): Remove.
	(to_can_execute_reverse): New method.
	(enum exec_direction_kind): Move to inferior.h.
	* target.c (update_current_target): Inherit to_can_execute_reverse.
	Remove to_set_exec_direction, to_get_exec_direction.
	* inferior.h (enum exec_direction_kind): Move from target.h.

	* infrun.c (set_exec_direction_func): Move here from reverse.c.
	(show_exec_direction_func): Ditto.
	(proceed): Consult global execution_direction instead of
	target method.
	(handle_inferior_event): Ditto.

	* reverse.c (set_exec_direction_func): Move to infrun.c
	(show_exec_direction_func): Ditto.
	(exec_direction_default): Set infrun global variable.
	(exec_reverse_once): Consult infrun global direction variable.

	* infcmd.c (step_1): Consult infrun global direction variable.
	(step_once): Ditto.
	(until_next_command): Ditto.
	(finish_command): Ditto.

	* record.h (record_exec_direction): Delete.
	(RECORD_IS_REPLAY): Consult infrun global direction variable.

	* record.c: (record_wait_cleanups): Use infrun state variable.
	(record_wait): Ditto.
	(record_get_exec_direction, record_set_exec_direction): Remove.
	(record_can_execute_reverse): New target method.

	* remote.c (remote_resume): Use infrun state variable.
	(remote_get_exec_direction, remote_set_exec_direction): Remove.
	(remote_can_execute_reverse): New target method.
@
text
@d1206 1
a1206 1
	  && execution_direction != EXEC_REVERSE)
d2889 1
a2889 1
	    && execution_direction == EXEC_REVERSE)
d3073 1
a3073 1
	  && execution_direction == EXEC_REVERSE)
d3143 1
a3143 1
	  || execution_direction == EXEC_REVERSE))
d3181 1
a3181 1
	  if (execution_direction == EXEC_REVERSE)
d3230 1
a3230 1
	    if (execution_direction == EXEC_REVERSE)
d3250 1
a3250 1
      if (execution_direction == EXEC_REVERSE)
a4774 49
/* User interface for reverse debugging:
   Set exec-direction / show exec-direction commands
   (returns error unless target implements to_set_exec_direction method).  */

enum exec_direction_kind execution_direction = EXEC_FORWARD;
static const char exec_forward[] = "forward";
static const char exec_reverse[] = "reverse";
static const char *exec_direction = exec_forward;
static const char *exec_direction_names[] = {
  exec_forward,
  exec_reverse,
  NULL
};

static void
set_exec_direction_func (char *args, int from_tty,
			 struct cmd_list_element *cmd)
{
  if (target_can_execute_reverse)
    {
      if (!strcmp (exec_direction, exec_forward))
	execution_direction = EXEC_FORWARD;
      else if (!strcmp (exec_direction, exec_reverse))
	execution_direction = EXEC_REVERSE;
    }
}

static void
show_exec_direction_func (struct ui_file *out, int from_tty,
			  struct cmd_list_element *cmd, const char *value)
{
  switch (execution_direction) {
  case EXEC_FORWARD:
    fprintf_filtered (out, _("Forward.\n"));
    break;
  case EXEC_REVERSE:
    fprintf_filtered (out, _("Reverse.\n"));
    break;
  case EXEC_ERROR:
  default:
    fprintf_filtered (out, 
		      _("Forward (target `%s' does not support exec-direction).\n"),
		      target_shortname);
    break;
  }
}

/* User interface for non-stop mode.  */

a4999 8
  add_setshow_enum_cmd ("exec-direction", class_run, exec_direction_names,
			&exec_direction, _("Set direction of execution.\n\
Options are 'forward' or 'reverse'."),
			_("Show direction of execution (forward/reverse)."),
			_("Tells gdb whether to execute forward or backward."),
			set_exec_direction_func, show_exec_direction_func,
			&setlist, &showlist);

@


1.322.2.12
log
@2008-10-09  Michael Snyder  <msnyder@@vmware.com>

	* infcmd.c (finish_forward): New function, abstracted from
	finish_command.
	(finish_command): Abstract out finish_forward for symmetry.
	* infrun.c (use_displaced_stepping): Add comment.
@
text
@a573 1
/* Disable when using the process record/replay target.  */
@


1.322.2.13
log
@2008-10-19  Hui Zhu  <teawater@@gmail.com>

	* infrun.c (handle_inferior_event): Set "stop_pc" when
	TARGET_WAITKIND_NO_HISTORY.
@
text
@a2164 1
      stop_pc = read_pc ();
@


1.322.2.14
log
@2008-10-18  Pedro Alves  <pedro@@codesourcery.com>

	* infrun.c (adjust_pc_after_break): Do nothing if executing in
	reverse.
@
text
@a1789 29
  /* In reverse execution, when a breakpoint is hit, the instruction
     under it has already been de-executed.  The reported PC always
     points at the breakpoint address, so adjusting it further would
     be wrong.  E.g., consider this case on a decr_pc_after_break == 1
     architecture:

       B1         0x08000000 :   INSN1
       B2         0x08000001 :   INSN2
		  0x08000002 :   INSN3
	    PC -> 0x08000003 :   INSN4

     Say you're stopped at 0x08000003 as above.  Reverse continuing
     from that point should hit B2 as below.  Reading the PC when the
     SIGTRAP is reported should read 0x08000001 and INSN2 should have
     been de-executed already.

       B1         0x08000000 :   INSN1
       B2   PC -> 0x08000001 :   INSN2
		  0x08000002 :   INSN3
		  0x08000003 :   INSN4

     We can't apply the same logic as for forward execution, because
     we would wrongly adjust the PC to 0x08000000, since there's a
     breakpoint at PC - 1.  We'd then report a hit on B1, although
     INSN1 hadn't been de-executed yet.  Doing nothing is the correct
     behaviour.  */
  if (execution_direction == EXEC_REVERSE)
    return;

@


1.322.2.15
log
@2008-10-24  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (handle_inferior_event): Handle dynamic symbol
	resolution in reverse.
@
text
@a3214 16

	      if (ecs->stop_func_start == 0 
		  && in_solib_dynsym_resolve_code (stop_pc))
		{
		  /* Stepped into runtime loader dynamic symbol
		     resolution code.  Since we're in reverse, 
		     we have already backed up through the runtime
		     loader and the dynamic function.  This is just
		     the trampoline (jump table).

		     Just keep stepping, we'll soon be home.
		  */
		  keep_going (ecs);
		  return;
		}
	      /* Normal (staticly linked) function call return.  */
@


1.321
log
@	* infrun.c (handle_inferior_event): In the follow exec case,
	context-switch before doing anything else.
@
text
@a333 1
  ptid_t saved_pid = pid;
d372 2
a373 3
  generic_mourn_inferior ();
  /* Because mourn_inferior resets inferior_ptid. */
  inferior_ptid = saved_pid;
@


1.320
log
@	Make the stop_soon global be per-inferior instead.

	* infcmd.c (attach_command_post_wait): Adjust.
	(attach_command): Likewise.

	* inferior.h (stop_soon): Delete.
	(struct inferior): Add stop_soon member.

	* infrun.c (stop_soon): Delete.
	(clear_proceed_status, start_remote)
	(fetch_inferior_event, handle_inferior_event): Adjust.
	(signal_stop_state): Don't check stop_soon here.  Check in callers
	instead.
	(save_inferior_status, restore_inferior_status): Adjust.

	* linux-nat.c (linux_nat_resume, linux_nat_wait): Always pass
	signals to common code if starting up the inferior.

	* inferior.h (struct inferior_info): Added stop_soon member.
	* inferior.c (add_inferior) Clear stop_soon.

	* mips-tdep.c (heuristic_proc_start): Adjust.
	* nto-procfs.c (procfs_create_inferior): Adjust.
	* solib-irix.c (irix_solib_create_inferior_hook): Adjust.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Adjust.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Adjust.

	* win32-nat.c (do_initial_win32_stuff): Adjust.

	* alpha-tdep.c (alpha_heuristic_proc_start): Adjust.
@
text
@a2091 20
      /* This causes the eventpoints and symbol table to be reset.  Must
         do this now, before trying to determine whether to stop. */
      follow_exec (inferior_ptid, pending_follow.execd_pathname);
      xfree (pending_follow.execd_pathname);

      stop_pc = regcache_read_pc (get_thread_regcache (ecs->ptid));

      {
	/* The breakpoints module may need to touch the inferior's
	   memory.  Switch to the (stopped) event ptid
	   momentarily.  */
	ptid_t saved_inferior_ptid = inferior_ptid;
	inferior_ptid = ecs->ptid;

	ecs->event_thread->stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);

	ecs->random_signal = !bpstat_explains_signal (ecs->event_thread->stop_bpstat);
	inferior_ptid = saved_inferior_ptid;
      }

d2098 11
@


1.319
log
@	Fix a crash on uninitialized ECS->EVENT_THREAD for a newly found thread.
	* infrun.c (wait_for_inferior): Move this ECS->EVENT_THREAD
	initialization ...
	(fetch_inferior_event): ... and this ECS->EVENT_THREAD initialization
	...
	(handle_inferior_event): ... here after the add_thread call together
	with the local adjust_pc_after_break and reinit_frame_cache calls.
@
text
@a232 7
/* Nonzero means expecting a trap and caller will handle it themselves.
   It is used after attach, due to attaching to a process;
   when running in the shell before the child program has been exec'd;
   and when running some kinds of remote stuff (FIXME?).  */

enum stop_kind stop_soon;

d1093 4
a1096 1
      struct thread_info *tp = inferior_thread ();
d1111 3
a1116 1
  stop_soon = NO_STOP_QUIETLY;
d1352 1
d1354 3
a1356 1
  stop_soon = STOP_QUIETLY_REMOTE;
d1652 2
d1656 2
a1657 1
      if (stop_soon == NO_STOP_QUIETLY)
d1847 12
d2692 4
a2695 1
      if (signal_stop_state (ecs->event_thread->stop_signal))
d3994 1
a3994 3
  /* Always stop on signals if we're just gaining control of the
     program.  */
  return signal_stop[signo] || stop_soon != NO_STOP_QUIETLY;
d4396 1
d4409 1
a4409 1
  inf_status->stop_soon = stop_soon;
d4451 1
d4464 1
a4464 1
  stop_soon = inf_status->stop_soon;
@


1.318
log
@	* defs.h (struct gdbarch): Add forward declaration.
	(set_next_address): Add GDBARCH argument.
	* printcmd.c (set_next_address): Use it to find pointer type.
	* breakpoint.c (breakpoint_1): Update call.
	* source.c (line_info): Likewise.
	* findcmd.c (find_command): Use current_gdbarch to find pointer type.

	* breakpoint.c (set_breakpoint_count): Use platform-neutral
	types for internal variable values.
	* infrun.c (handle_inferior_event): Likewise.
	* source.c (forward_search_command, reverse_search_command): Likewise.
	* tracepoint.c (set_tracepoint_count, set_traceframe_num,
	set_tracepoint_num, set_traceframe_context): Likewise.
@
text
@a1570 2
      ecs->event_thread = find_thread_pid (ecs->ptid);

a1645 2
  ecs->event_thread = find_thread_pid (ecs->ptid);

a1852 4
  adjust_pc_after_break (ecs);

  reinit_frame_cache ();

d1863 8
@


1.317
log
@gdb/
	* infrun.c (normal_stop): Run hook-stop last.

gdb/testsuite/
	* gdb.base/hook-stop-continue.c: New.
	* gdb.base/hook-stop-continue.exp: New.
@
text
@d2009 1
a2009 1
		       value_from_longest (builtin_type_int,
@


1.316
log
@	* inferior.h (context_switch_to): Delete.
	* infrun.c (context_switch): Don't save and load infrun state.
	(context_switch_to): Delete.

	* infcmd.c (proceed_thread_callback): Replace context_switch_to
	calls by switch_to_thread calls.

	* gdbthread.h (save_infrun_state, load_infrun_state): Delete.
	* thread.c (main_thread_state, main_thread_executing): Delete.
	(inferior_thread): Delete references to them.
	(add_thread_silent): Fix case where we're adding a thread with the
	same ptid as an exited thread.  Remove references to
	context-switching.
	(load_infrun_state, save_infrun_state): Delete.
	(thread_alive, is_thread_state, any_running, is_executing)
	(set_executing): Remove the special handling for targets that
	don't register any thread.
	(restore_current_thread, thread_apply_all_command)
	(do_captured_thread_select): Unconditionally call
	switch_to_thread.

	* mi/mi-main.c (mi_cmd_execute): Check for exited threads.
	Call switch_to_thread instead of context_switch_to.
@
text
@a3801 6
  /* Look up the hook_stop and run it (CLI internally handles problem
     of stop_command's pre-hook not existing).  */
  if (stop_command)
    catch_errors (hook_stop_stub, stop_command,
		  "Error while running hook_stop:\n", RETURN_MASK_ALL);

d3803 1
a3803 4
    {

      goto done;
    }
d3956 7
@


1.315
log
@	* infrun.c (context_switch): Don't context-switch the continuations.
@
text
@d1723 1
a1723 1
/* Switch thread contexts, maintaining "infrun state". */
a1727 6
  /* Caution: it may happen that the new thread (or the old one!)
     is not in the thread list.  In this case we must not attempt
     to "switch context", or we run the risk that our context may
     be lost.  This may happen as a result of the target module
     mishandling thread creation.  */

a1735 9
  if (in_thread_list (inferior_ptid) && in_thread_list (ptid))
    {				/* Perform infrun state context switch: */
      /* Save infrun state for the old thread.  */
      save_infrun_state (inferior_ptid);

      /* Load infrun state for the new thread.  */
      load_infrun_state (ptid);
    }

a1738 14
/* Context switch to thread PTID.  */
ptid_t
context_switch_to (ptid_t ptid)
{
  ptid_t current_ptid = inferior_ptid;

  /* Context switch to the new thread.	*/
  if (!ptid_equal (ptid, inferior_ptid))
    {
      context_switch (ptid);
    }
  return current_ptid;
}

@


1.314
log
@	Remove the global stop_step in favour of a per-thread
	stop_step.

	* inferior.h (stop_step): Delete.

	* gdbthread.h (struct thread_info): Add comments to stop_step.
	(save_infrun_state, load_infrun_state): Remove stop_step argument.
	* thread.c (load_infrun_state, save_infrun_state): Remove
	stop_step argument, and references to it.

	* infrun.c (clear_proceed_status): Clear stop_step.
	(fetch_inferior_event): Adjust.
	(context_switch): Don't context-switch stop_step.
	(handle_inferior_event): Adjust.
	(normal_stop): Adjust.
	(save_inferior_status, restore_inferior_status): Adjust.

	* infcmd.c (stop_step): Delete.
	(step_1, step_1_continuation, step_once, until_next_command):
	Adjust.
@
text
@d1745 1
a1745 2
      save_infrun_state (inferior_ptid,
			 cmd_continuation, intermediate_continuation);
d1748 1
a1748 2
      load_infrun_state (ptid,
			 &cmd_continuation, &intermediate_continuation);
@


1.313
log
@	Remove the global step_multi in favour of a per-thread
	step_multi.

	* inferior.h (step_multi): Delete.
	* gdbthread.h (struct thread_info): Add comments around
	step_multi.
	(save_infrun_state, load_infrun_state): Remove step_multi
	parameter.
	* thread.c (load_infrun_state, save_infrun_state): Remove
	step_multi argument, and references to it.
	* infcmd.c (step_multi): Delete.
	(step_1): Adjust.
	(step_1_continuation, until_next_command): Adjust.
	* infrun.c (fetch_inferior_event): Adjust.
	(context_switch): Don't context-switch step_multi.
	(print_stop_reason, normal_stop): Adjust.
@
text
@d1108 2
d1664 1
a1664 1
	  && stop_step)
d1746 1
a1746 2
			 cmd_continuation, intermediate_continuation,
			 stop_step);
d1750 1
a1750 2
			 &cmd_continuation, &intermediate_continuation,
			 &stop_step);
d2527 1
a2527 1
  stop_step = 0;
d2837 1
a2837 1
	stop_step = 1;
d3134 1
a3134 1
	  stop_step = 1;
d3196 1
a3196 1
	  stop_step = 1;
d3270 1
a3270 1
	  stop_step = 1;
d3291 1
a3291 1
      stop_step = 1;
d3305 1
a3305 1
      stop_step = 1;
d3321 1
a3321 1
      stop_step = 1;
d3408 1
a3408 1
      stop_step = 1;
d3668 2
a3669 1
      if (!inferior_thread ()->step_multi || !stop_step)
d3822 1
a3822 1
      && stop_step)
d3893 1
a3893 1
	      if (stop_step
d4415 1
a4415 1
  inf_status->stop_step = stop_step;
d4469 1
a4469 1
  stop_step = inf_status->stop_step;
@


1.312
log
@	Remove the global stop_signal in favour of a per-thread
	stop_signal.

	* inferior.h (stop_signal): Delete.
	* gdbthread.h (save_infrun_state, load_infrun_state): Remove
	stop_signal argument.
	* thread.c (load_infrun_state, save_infrun_state): Remove
	stop_signal argument.  Don't reference it.

	* infcmd.c (stop_signal): Delete.
	(program_info): Adjust.
	* infrun.c (resume): Clear stop_signal.
	(proceed): Adjust.  Pass the last stop_signal to the thread we're
	resuming.
	(context_switch): Don't context-switch stop_signal.
	(handle_inferior_event, keep_going): Adjust.
	(save_inferior_status, restore_inferior_status): Adjust.

	* fbsd-nat.c: Include "gdbthread.h".
	(find_signalled_thread, find_stop_signal): New.
	(fbsd_make_corefile_notes): Use it.
	* fork-child.c (startup_inferior): Adjust.

	* linux-nat.c (get_pending_status): Adjust.
	(linux_nat_do_thread_registers): Adjust.
	(find_signalled_thread, find_stop_signal): New.
	(linux_nat_do_thread_registers): Add stop_signal parameter.
	(struct linux_nat_corefile_thread_data): Add stop_signal member.
	(linux_nat_corefile_thread_callback): Pass stop_signal.
	(linux_nat_do_registers): Delete.
	(linux_nat_make_corefile_notes): Use find_stop_signal.  Assume
	there's always a thread.

	* procfs.c (find_signalled_thread, find_stop_signal): New.
	(find_stop_signal): New.
	(procfs_do_thread_registers): Add stop_signal parameter.
	(struct procfs_corefile_thread_data): Add stop_signal member.
	(procfs_corefile_thread_callback): Pass args->stop_signal.
	(procfs_make_note_section): Find the last stop_signal.

	* solib-irix.c: Include gdbthread.h.
	(irix_solib_create_inferior_hook): Adjust.
	* solib-osf.c: Include gdbthread.h.
	(osf_solib_create_inferior_hook): Adjust.
	* solib-sunos.c: Include gdbthread.h.
	(sunos_solib_create_inferior_hook): Adjust.
	* solib-svr4.c: Include gdbthread.h.
	(svr4_solib_create_inferior_hook): Adjust.

	* win32-nat.c (do_initial_win32_stuff): Adjust.
@
text
@d1658 5
a1662 1
      if (step_multi && stop_step)
d1745 1
a1745 2
			 stop_step,
			 step_multi);
d1750 1
a1750 2
			 &stop_step,
			 &step_multi);
d3668 1
a3668 1
      if (!step_multi || !stop_step)
d3817 5
a3821 1
  if (step_multi && stop_step)
d3971 5
a3975 1
  if (!suppress_stop_observer && !step_multi)
@


1.311
log
@	* gdbthread.h (struct thread_info): Add comments around
	proceed_to_finish.
	(save_infrun_state, load_infrun_state): Remove proceed_to_finish
	argument.
	* thread.c (load_infrun_state, save_infrun_state): Delete
	proceed_to_finish argument and references to it.

	* infcall.c (call_function_by_hand): Adjust.
	* infcmd.c (finish_command): Adjust.
	* infrun.c (proceed_to_finish): Delete.
	(clear_proceed_status): Adjust.
	(context_switch): Don't context-switch proceed_to_finish.
	(normal_stop, save_inferior_status, restore_inferior_status):
	Adjust.
@
text
@d1081 4
d1189 1
d1264 25
d1290 1
a1290 1
    stop_signal = siggnal;
d1293 2
a1294 2
  else if (!signal_program[stop_signal])
    stop_signal = TARGET_SIGNAL_0;
d1333 1
a1333 1
  resume (oneproc || step || bpstat_should_step (), stop_signal);
a1387 3
  /* Don't confuse first call to proceed(). */
  stop_signal = TARGET_SIGNAL_0;

d1742 1
a1742 2
			 step_multi,
			 stop_signal);
d1748 1
a1748 2
			 &step_multi,
			 &stop_signal);
a2050 1
      stop_signal = ecs->ws.value.sig;
d2060 1
a2060 1
      print_stop_reason (SIGNAL_EXITED, stop_signal);
a2070 1
      stop_signal = TARGET_SIGNAL_TRAP;
d2091 1
a2091 1
	  stop_signal = TARGET_SIGNAL_0;
d2095 1
a2100 2
      stop_signal = TARGET_SIGNAL_TRAP;

d2134 1
a2134 1
	  stop_signal = TARGET_SIGNAL_0;
d2138 1
d2165 1
a2165 1
      stop_signal = ecs->ws.value.sig;
d2208 2
a2209 1
  displaced_step_fixup (ecs->ptid, stop_signal);
d2243 1
a2243 1
      if (stop_signal == TARGET_SIGNAL_TRAP)
d2272 1
a2272 1
      if (stop_signal == TARGET_SIGNAL_TRAP)
d2306 1
a2306 1
  if (stop_signal == TARGET_SIGNAL_TRAP)
d2360 2
d2370 2
d2374 1
d2530 1
a2530 1
  if (stop_signal == TARGET_SIGNAL_TRAP
d2587 1
a2587 1
  if (stop_signal == TARGET_SIGNAL_TRAP
d2590 3
a2592 3
	  && (stop_signal == TARGET_SIGNAL_ILL
	      || stop_signal == TARGET_SIGNAL_SEGV
	      || stop_signal == TARGET_SIGNAL_EMT))
d2596 1
a2596 1
      if (stop_signal == TARGET_SIGNAL_TRAP && stop_after_trap)
d2628 2
a2629 2
	  && (stop_signal == TARGET_SIGNAL_STOP
	      || stop_signal == TARGET_SIGNAL_TRAP))
d2632 1
a2632 1
	  stop_signal = TARGET_SIGNAL_0;
d2663 1
a2663 1
      if (stop_signal == TARGET_SIGNAL_TRAP)
d2673 1
a2673 1
	    stop_signal = TARGET_SIGNAL_TRAP;
d2694 2
a2695 1
	 fprintf_unfiltered (gdb_stdlog, "infrun: random signal %d\n", stop_signal);
d2699 1
a2699 1
      if (signal_print[stop_signal])
d2703 1
a2703 1
	  print_stop_reason (SIGNAL_RECEIVED, stop_signal);
d2705 1
a2705 1
      if (signal_stop_state (stop_signal))
d2716 2
a2717 2
      if (signal_program[stop_signal] == 0)
	stop_signal = TARGET_SIGNAL_0;
d2745 1
a2745 1
	  && stop_signal != TARGET_SIGNAL_0
d3550 2
a3551 1
  if (ecs->event_thread->trap_expected && stop_signal != TARGET_SIGNAL_TRAP)
d3556 2
a3557 1
      resume (currently_stepping (ecs->event_thread), stop_signal);
d3612 3
a3614 3
      if (stop_signal == TARGET_SIGNAL_TRAP && !signal_program[stop_signal])
	stop_signal = TARGET_SIGNAL_0;

d3616 2
a3617 1
      resume (currently_stepping (ecs->event_thread), stop_signal);
d4402 1
a4402 1
  inf_status->stop_signal = stop_signal;
d4456 1
a4456 1
  stop_signal = inf_status->stop_signal;
@


1.310
log
@	* inferior.h (stop_bpstat): Delete.

	* breakpoint.h (bpstat_do_actions): Remove bpstat* argument.

	* breakpoint.c (bpstat_do_actions): Rename to ...
	(bpstat_do_actions_1): ... this.  Make static.  Change return type
	to int.  Return true if a breakpoint proceeded.
	(bpstat_do_actions): New, as wrapper around bpstat_do_actions_1.
	(delete_breakpoint): Don't reference the global stop_bpstat; it's
	gone.

	* gdbthread.h (struct thread_info): Add stop_bpstat.
	(save_infrun_state, load_infrun_state): Remove stop_bpstat
	argument.
	* thread.c (load_infrun_state, save_infrun_state): Remove
	stop_bpstat argument, and the code referencing it.

	* infcall.c: Include "gdbthread.h".
	(call_function_by_hand): Adjust.
	* exceptions.c: Include "gdbthread.h".
	(throw_exception): Adjust.
	* infcmd.c (stop_bpstat): Delete.
	(continue_command): In all-stop, set the ignore count on the
	thread that reported the stop.  In non-stop, set it on the current
	thread.
	(finish_command_continuation): Adjust.
	(program_info): Adjust.
	* infrun.c (clear_proceed_status): Adjust.
	(context_switch): Don't context-switch stop_bpstat.
	(handle_inferior_event): Adjust.
	(normal_stop): Adjust.
	(save_inferior_status, restore_inferior_status): Adjust.

	* inf-loop.c (inferior_event_handler): Remove parameter to
	bpstat_do_actions call.
	* top.c (command_loop): Remove parameter to bpstat_do_actions
	call.  Call it unconditionally.
	* event-top.c (command_handler): Ditto.
	* python/python.c (execute_gdb_command): Ditto.
@
text
@a239 5
/* Nonzero if proceed is being used for a "finish" command or a similar
   situation when stop_registers should be saved.  */

int proceed_to_finish;

d1103 3
a1112 1
  proceed_to_finish = 0;
a1713 1
			 proceed_to_finish,
a1720 1
			 &proceed_to_finish,
d3805 4
d3906 1
a3906 1
  if (proceed_to_finish)
d4389 1
a4389 1
  inf_status->proceed_to_finish = proceed_to_finish;
d4438 1
a4438 1
  proceed_to_finish = inf_status->proceed_to_finish;
@


1.309
log
@	* inferior.h (step_over_calls): Delete.

	* gdbthread.h (save_infrun_state, load_infrun_state): Remove
	step_over_calls argument.
	* thread.c (save_infrun_state, load_infrun_state): Remove
	step_over_calls argument.  Adjust.

	* infcmd.c (step_over_calls): Delete.
	(step_1): Adjust.
	* infrun.c (clear_proceed_status): Adjust.
	(context_switch): Don't context-switch step_over_calls.
	(handle_inferior_event, save_inferior_status)
	(restore_inferior_status): Adjust.
@
text
@d1108 3
a1122 3

  /* Discard any remaining commands or status from previous stop.  */
  bpstat_clear (&stop_bpstat);
d1720 1
a1720 2
			 stop_signal,
			 stop_bpstat);
d1728 1
a1728 2
			 &stop_signal,
			 &stop_bpstat);
d2066 1
a2066 1
      stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);
d2068 1
a2068 1
      ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
d2102 1
a2102 1
	stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);
d2104 1
a2104 1
	ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
d2500 1
a2500 1
  bpstat_clear (&stop_bpstat);
d2613 1
a2613 1
      stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);
d2641 1
a2641 1
	  = !(bpstat_explains_signal (stop_bpstat)
d2647 1
a2647 1
	  ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
d2761 1
a2761 1
    what = bpstat_what (stop_bpstat);
d2930 1
a2930 1
	      bpstat_get_triggered_catchpoints (stop_bpstat,
d2985 3
a2987 2
      bpstat_clear (&stop_bpstat);
      stop_bpstat = bpstat_copy (ecs->event_thread->stepping_through_solib_catchpoints);
d3833 1
d3835 1
a3835 1
	  bpstat_ret = bpstat_print (stop_bpstat);
d3855 1
a3855 1
		  && frame_id_eq (inferior_thread ()->step_frame_id,
d3934 6
a3939 5
    observer_notify_normal_stop (stop_bpstat);
  /* Delete the breakpoint we stopped at, if it wants to be deleted.
     Delete any breakpoint that is to be deleted at the next stop.  */
  breakpoint_auto_delete (stop_bpstat);

d3944 4
d4386 2
a4387 2
  inf_status->stop_bpstat = stop_bpstat;
  stop_bpstat = bpstat_copy (stop_bpstat);
d4436 2
a4437 2
  bpstat_clear (&stop_bpstat);
  stop_bpstat = inf_status->stop_bpstat;
@


1.308
log
@	Remove context switching in favour of accessing thread_info fields
	directly.

	* infrun.c (stepping_over_breakpoint, step_resume_breakpoint):
	Delete.
	(struct thread_stepping_state): Delete.
	(gtss, tss): Delete.
	(follow_inferior_reset_breakpoints, follow_exec)
	(resume, clear_proceed_status): Adjust.
	(prev_pc): Delete.
	(proceed, start_remote, init_wait_for_inferior): Adjust.
	(struct execution_control_state): Add event_thread member.
	(delete_step_resume_breakpoint_callback)
	(delete_step_thread_step_resume_breakpoint)
	(delete_step_thread_step_resume_breakpoint_cleanup)
	(delete_step_thread_step_resume_breakpoint): New.
	(wait_for_inferior, init_execution_control_state): Use
	delete_step_thread_step_resume_breakpoint_cleanup.
	(wait_for_inferior): Set the event_thread.
	(fetch_inferior_event): Ditto.  Delete the step-resume breakpoint
	with delete_step_thread_step_resume_breakpoint.
	(init_thread_stepping_state): Change parameter type to
	thread_info.  Adjust.
	(context_switch): Don't context switch prev_pc,
	stepping_over_breakpoint, step_resume_breakpoint,
	step_range_start, step_range_end, step_frame_id,
	tss->stepping_over_breakpoint,
	tss->stepping_through_solib_after_catch,
	tss->stepping_through_solib_catchpoints, tss->current_line, or
	tss->current_symtab.
	(adjust_pc_after_break, handle_inferior_event)
	(currently_stepping, step_into_function)
	(insert_step_resume_breakpoint_at_sal)
	(insert_longjmp_resume_breakpoint, keep_going): Adjust.
	(clear_stepping_state): New.
	(normal_stop): Adjust.
	(save_inferior_status, restore_inferior_status): Adjust.

	* gdbthread.h (struct thread_info): Comments describing the
	members moved here.  Add step_after_step_resume_breakpoint.
	(delete_step_resume_breakpoint): Add thread_info argument.
	(save_infrun_state, load_infrun_state): Remove prev_pc,
	trap_expected, step_resume_breakpoint, step_range_start,
	step_range_end, step_frame_id, another_trap,
	stepping_through_solib_after_catch,
	stepping_through_solib_catchpoints, current_line and
	current_symtab function arguments.
	(inferior_thread): Declare.

	* thread.c (inferior_thread): New.
	(delete_step_resume_breakpoint): Add a thread_info parameter and
	rewrite.
	(load_infrun_state, save_infrun_state): Remove prev_pc,
	trap_expected, step_resume_breakpoint, step_range_start,
	step_range_end, step_frame_id, stepping_over_breakpoint,
	stepping_through_solib_after_catch,
	stepping_through_solib_catchpoints, current_line and
	current_symtab args.  Remove code referencing them.

	* infcmd.c (step_range_start, step_range_end, step_frame_id):
	Delete.
	(step_1, step_once, until_next_command): Adjust.

	* inferior.h (step_range_start, step_range_end, step_frame_id):
	Delete.

	* linux-nat.c (linux_child_follow_fork): If following the child,
	move the step state to it.  Adjust.
	* inf-ptrace.c (inf_ptrace_follow_fork): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork): Ditto.
@
text
@d1107 1
a1109 1
  step_over_calls = STEP_OVER_UNDEBUGGABLE;
a1717 1
			 step_over_calls,
a1726 1
			 &step_over_calls,
d3039 1
a3039 1
  if (step_over_calls == STEP_OVER_UNDEBUGGABLE
d3064 2
a3065 2
      && (step_over_calls == STEP_OVER_UNDEBUGGABLE
	  || step_over_calls == STEP_OVER_ALL)
d3097 1
a3097 1
      if ((step_over_calls == STEP_OVER_NONE)
d3114 1
a3114 1
      if (step_over_calls == STEP_OVER_ALL)
d3167 2
a3168 1
      if (step_over_calls == STEP_OVER_UNDEBUGGABLE && step_stop_if_no_debug)
d3223 1
a3223 1
  if (step_over_calls == STEP_OVER_UNDEBUGGABLE
d4374 1
a4374 1
  inf_status->step_over_calls = step_over_calls;
d4428 1
a4428 1
  step_over_calls = inf_status->step_over_calls;
@


1.307
log
@	* dummy-frame.h (dummy_frame_pop): Add prototype.
	* dummy-frame.c: Include "observer.h".
	(dummy_frame_push): Do not check for stale frames.
	(dummy_frame_pop): New function.
	(cleanup_dummy_frames): New function.
	(_initialize_dummy_frame): Install it as inferior_created observer.

	* frame.h (struct frame_id): Update comments.
	(frame_id_inner): Remove prototype.
	* frame.c (frame_id_inner): Make static.  Add comments.
	(frame_find_by_id): Update frame_id_inner safety net check to avoid
	false positives for targets using non-contiguous stack ranges.
	(get_prev_frame_1): Update frame_id_inner safety net check.
	(frame_pop): Call dummy_frame_pop when popping a dummy frame.

	* stack.c (return_command): Directly pop the selected frame.
	* infrun.c (handle_inferior_event): Remove dead code.
	* i386-tdep.c (i386_push_dummy_call): Update comment.
@
text
@d76 1
a76 3
struct thread_stepping_state;

static int currently_stepping (struct thread_stepping_state *tss);
a216 25
/* Nonzero if we are presently stepping over a breakpoint.

   If we hit a breakpoint or watchpoint, and then continue,
   we need to single step the current thread with breakpoints
   disabled, to avoid hitting the same breakpoint or
   watchpoint again.  And we should step just a single
   thread and keep other threads stopped, so that 
   other threads don't miss breakpoints while they are removed.

   So, this variable simultaneously means that we need to single
   step the current thread, keep other threads stopped, and that
   breakpoints should be removed while we step.

   This variable is set either:
   - in proceed, when we resume inferior on user's explicit request
   - in keep_going, if handle_inferior_event decides we need to
   step over breakpoint.  

   The variable is cleared in clear_proceed_status, called every
   time before we call proceed.  The proceed calls wait_for_inferior,
   which calls handle_inferior_event in a loop, and until 
   wait_for_inferior exits, this variable is changed only by keep_going.  */

static int stepping_over_breakpoint;

a255 3
/* Step-resume or longjmp-resume breakpoint.  */
static struct breakpoint *step_resume_breakpoint = NULL;

a261 16
/* Context-switchable data.  */
struct thread_stepping_state
{
  /* Should we step over breakpoint next time keep_going
     is called?  */
  int stepping_over_breakpoint;
  int current_line;
  struct symtab *current_symtab;
  int step_after_step_resume_breakpoint;
  int stepping_through_solib_after_catch;
  bpstat stepping_through_solib_catchpoints;
};

struct thread_stepping_state gtss;
struct thread_stepping_state *tss = &gtss;

d264 1
a264 1
void init_thread_stepping_state (struct thread_stepping_state *tss);
d316 2
d329 2
a330 2
  if (step_resume_breakpoint)
    breakpoint_re_set_thread (step_resume_breakpoint);
d348 1
d374 3
a376 3
  step_resume_breakpoint = NULL;
  step_range_start = 0;
  step_range_end = 0;
d904 1
d911 2
a912 2
                        "stepping_over_breakpoint=%d\n",
			step, sig, stepping_over_breakpoint);
d949 1
a949 1
      && stepping_over_breakpoint
d1033 1
a1033 1
	  && stepping_over_breakpoint)
d1073 1
a1073 1
          && stepping_over_breakpoint)
d1099 10
a1108 4
  stepping_over_breakpoint = 0;
  step_range_start = 0;
  step_range_end = 0;
  step_frame_id = null_frame_id;
a1167 5
/* Record the pc of the program the last time it stopped.  This is
   just used internally by wait_for_inferior, but need to be preserved
   over calls to it and cleared when the inferior is started.  */
static CORE_ADDR prev_pc;

d1185 1
d1241 3
d1246 1
a1246 1
      stepping_over_breakpoint = 1;
d1259 1
a1259 1
  if (! stepping_over_breakpoint || use_displaced_stepping (gdbarch))
d1297 1
a1297 1
  prev_pc = regcache_read_pc (get_current_regcache ());
d1300 1
a1300 1
  init_thread_stepping_state (tss);
a1326 1
  stepping_over_breakpoint = 0;
a1357 1
  prev_pc = 0;
a1373 1
  init_thread_stepping_state (tss);
d1418 4
d1448 47
d1519 2
a1520 2
  old_cleanups = make_cleanup (delete_step_resume_breakpoint,
			       &step_resume_breakpoint);
d1545 2
d1560 1
d1622 2
d1629 1
a1629 1
      delete_step_resume_breakpoint (&step_resume_breakpoint);
d1661 1
a1661 1
init_thread_stepping_state (struct thread_stepping_state *tss)
d1670 1
a1670 1
  sal = find_pc_line (prev_pc, 0);
d1715 1
a1715 8
      save_infrun_state (inferior_ptid, prev_pc,
			 stepping_over_breakpoint, step_resume_breakpoint,
			 step_range_start,
			 step_range_end, &step_frame_id,
			 tss->stepping_over_breakpoint,
			 tss->stepping_through_solib_after_catch,
			 tss->stepping_through_solib_catchpoints,
			 tss->current_line, tss->current_symtab,
d1725 1
a1725 8
      load_infrun_state (ptid, &prev_pc,
			 &stepping_over_breakpoint, &step_resume_breakpoint,
			 &step_range_start,
			 &step_range_end, &step_frame_id,
			 &tss->stepping_over_breakpoint,
			 &tss->stepping_through_solib_after_catch,
			 &tss->stepping_through_solib_catchpoints,
			 &tss->current_line, &tss->current_symtab,
d1822 2
a1823 2
	  || !currently_stepping (tss)
	  || prev_pc == breakpoint_pc)
d2259 2
d2354 1
d2414 1
a2414 1
	      tss->stepping_over_breakpoint = 1;
d2503 1
a2503 1
  tss->stepping_over_breakpoint = 0;
d2511 1
a2511 1
      && stepping_over_breakpoint
d2513 1
a2513 1
      && currently_stepping (tss))
d2525 1
a2525 1
      if (step_range_end == 0 && step_through_delay)
d2529 1
a2529 1
         tss->stepping_over_breakpoint = 1;
d2541 1
a2541 1
	  tss->stepping_over_breakpoint = 1;
d2549 1
a2549 1
     (set tss->stepping_over_breakpoint to 1 to single step once)
d2568 1
a2568 1
      || (! stepping_over_breakpoint
d2646 3
a2648 2
	      || stepping_over_breakpoint
	      || (step_range_end && step_resume_breakpoint == NULL));
d2698 3
a2700 3
      if (prev_pc == read_pc ()
	  && stepping_over_breakpoint
	  && step_resume_breakpoint == NULL)
d2718 1
a2718 1
	  tss->step_after_step_resume_breakpoint = 1;
d2723 1
a2723 1
      if (step_range_end != 0
d2725 2
a2726 1
	  && stop_pc >= step_range_start && stop_pc < step_range_end
d2728 2
a2729 2
			  step_frame_id)
	  && step_resume_breakpoint == NULL)
d2783 1
a2783 1
	tss->stepping_over_breakpoint = 1;
d2798 1
a2798 2
	if (step_resume_breakpoint != NULL)
	  delete_step_resume_breakpoint (&step_resume_breakpoint);
d2811 2
a2812 2
	gdb_assert (step_resume_breakpoint != NULL);
	delete_step_resume_breakpoint (&step_resume_breakpoint);
d2822 1
a2822 1
	tss->stepping_over_breakpoint = 1;
a2849 17
	/* This proably demands a more elegant solution, but, yeah
	   right...

	   This function's use of the simple variable
	   step_resume_breakpoint doesn't seem to accomodate
	   simultaneously active step-resume bp's, although the
	   breakpoint list certainly can.

	   If we reach here and step_resume_breakpoint is already
	   NULL, then apparently we have multiple active
	   step-resume bp's.  We'll just delete the breakpoint we
	   stopped at, and carry on.  

	   Correction: what the code currently does is delete a
	   step-resume bp, but it makes no effort to ensure that
	   the one deleted is the one currently stopped at.  MVS  */

d2853 2
a2854 7
	if (step_resume_breakpoint == NULL)
	  {
	    step_resume_breakpoint =
	      bpstat_find_step_resume_breakpoint (stop_bpstat);
	  }
	delete_step_resume_breakpoint (&step_resume_breakpoint);
	if (tss->step_after_step_resume_breakpoint)
d2859 2
a2860 2
	    tss->step_after_step_resume_breakpoint = 0;
	    tss->stepping_over_breakpoint = 1;
d2935 2
a2936 1
						&tss->
d2938 1
a2938 1
	      tss->stepping_through_solib_after_catch = 1;
d2942 1
a2942 1
	      tss->stepping_over_breakpoint = 1;
d2948 1
a2948 1
	      tss->stepping_over_breakpoint = 1;
d2971 1
a2971 1
  if (tss->stepping_through_solib_after_catch)
d2979 1
a2979 1
	  tss->stepping_over_breakpoint = 1;
d2988 1
a2988 1
      tss->stepping_through_solib_after_catch = 0;
d2990 2
a2991 2
      stop_bpstat = bpstat_copy (tss->stepping_through_solib_catchpoints);
      bpstat_clear (&tss->stepping_through_solib_catchpoints);
d2997 1
a2997 1
  if (step_resume_breakpoint)
d3010 1
a3010 1
  if (step_range_end == 0)
d3024 2
a3025 1
  if (stop_pc >= step_range_start && stop_pc < step_range_end)
d3029 2
a3030 2
			    paddr_nz (step_range_start),
			    paddr_nz (step_range_end));
d3065 1
a3065 1
  if (step_range_end != 1
d3089 4
a3092 2
  if (!frame_id_eq (get_frame_id (get_current_frame ()), step_frame_id)
      && frame_id_eq (frame_unwind_id (get_current_frame ()), step_frame_id))
d3100 3
a3102 2
	  || ((step_range_end == 1)
	      && in_prologue (prev_pc, ecs->stop_func_start)))
d3260 1
a3260 1
  if (step_range_end == 1)
d3287 2
a3288 2
      && (tss->current_line != stop_pc_sal.line
	  || tss->current_symtab != stop_pc_sal.symtab))
d3309 5
a3313 5
  step_range_start = stop_pc_sal.pc;
  step_range_end = stop_pc_sal.end;
  step_frame_id = get_frame_id (get_current_frame ());
  tss->current_line = stop_pc_sal.line;
  tss->current_symtab = stop_pc_sal.symtab;
d3323 1
a3323 1
currently_stepping (struct thread_stepping_state *tss)
d3325 3
a3327 3
  return (((step_range_end && step_resume_breakpoint == NULL)
	   || stepping_over_breakpoint)
	  || tss->stepping_through_solib_after_catch
d3401 1
a3401 1
      step_range_end = step_range_start;
d3416 1
a3416 1
  gdb_assert (step_resume_breakpoint == NULL);
d3423 2
a3424 2
  step_resume_breakpoint = set_momentary_breakpoint (sr_sal, sr_id,
						     bp_step_resume);
d3493 1
a3493 1
  gdb_assert (step_resume_breakpoint == NULL);
d3500 1
a3500 1
  step_resume_breakpoint =
d3522 1
a3522 1
  prev_pc = read_pc ();		/* Might have been DECR_AFTER_BREAK */
d3527 1
a3527 1
  if (stepping_over_breakpoint && stop_signal != TARGET_SIGNAL_TRAP)
d3530 3
a3532 3
         the inferior, else we'd have done a break above) and we
         haven't yet gotten our trap.  Simply continue.  */
      resume (currently_stepping (tss), stop_signal);
d3549 1
a3549 1
      if (tss->stepping_over_breakpoint)
d3573 1
a3573 1
      stepping_over_breakpoint = tss->stepping_over_breakpoint;
d3591 1
a3591 1
      resume (currently_stepping (tss), stop_signal);
d3856 1
a3856 1
		  && frame_id_eq (step_frame_id,
d4364 1
d4371 4
a4374 4
  inf_status->stepping_over_breakpoint = stepping_over_breakpoint;
  inf_status->step_range_start = step_range_start;
  inf_status->step_range_end = step_range_end;
  inf_status->step_frame_id = step_frame_id;
d4418 2
d4425 4
a4428 4
  stepping_over_breakpoint = inf_status->stepping_over_breakpoint;
  step_range_start = inf_status->step_range_start;
  step_range_end = inf_status->step_range_end;
  step_frame_id = inf_status->step_frame_id;
@


1.306
log
@	* infrun.c (adjust_pc_after_break): Do not call get_thread_regcache
	if the thread has already exited.
@
text
@a3325 27
  /* In the case where we just stepped out of a function into the
     middle of a line of the caller, continue stepping, but
     step_frame_id must be modified to current frame */
#if 0
  /* NOTE: cagney/2003-10-16: I think this frame ID inner test is too
     generous.  It will trigger on things like a step into a frameless
     stackless leaf function.  I think the logic should instead look
     at the unwound frame ID has that should give a more robust
     indication of what happened.  */
  if (step - ID == current - ID)
    still stepping in same function;
  else if (step - ID == unwind (current - ID))
    stepped into a function;
  else
    stepped out of a function;
  /* Of course this assumes that the frame ID unwind code is robust
     and we're willing to introduce frame unwind logic into this
     function.  Fortunately, those days are nearly upon us.  */
#endif
  {
    struct frame_info *frame = get_current_frame ();
    struct frame_id current_frame = get_frame_id (frame);
    if (!(frame_id_inner (get_frame_arch (frame), current_frame,
			  step_frame_id)))
      step_frame_id = current_frame;
  }

@


1.305
log
@	* infrun.c (proceed): Move back setting previous_inferior_ptid
	from here ...
	(wait_for_inferior): ... to here.
	(fetch_inferior_event): ... and here.
@
text
@d1753 2
a1754 2
  struct regcache *regcache = get_thread_regcache (ecs->ptid);
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
a1756 5
  /* If this target does not decrement the PC after breakpoints, then
     we have nothing to do.  */
  if (gdbarch_decr_pc_after_break (gdbarch) == 0)
    return;

d1784 7
@


1.304
log
@	* infrun.c (resume): If the thread is placed to the deferred step
        queue, mark it as running.
@
text
@a1338 3
  /* We'll update this if & when we switch to a new thread. */
  previous_inferior_ptid = inferior_ptid;

d1516 3
d1571 7
@


1.303
log
@2008-08-18  Pedro Alves  <pedro@@codesourcery.com>

	gdb/doc/
	* observer.texi (thread_ptid_changed): New.

	gdb/
	* gdbthread.h (thread_change_ptid): Declare.
	* infrun.c (infrun_thread_ptid_changed): New.
	(_initialize_infrun): Attach infrun_thread_ptid_changed to the
	thread_ptid_changed observer.
	* regcache.c (regcache_thread_ptid_changed): New.
	(_initialize_regcache): Attach regcache_thread_ptid_changed to the
	thread_ptid_changed observer.
	* thread.c (thread_change_ptid): New.
@
text
@d998 5
a1002 1
	     requests finish.  */
@


1.302
log
@	* infrun.c (fetch_inferior_event): Only call normal_stop if not
	stopping quietly.
@
text
@d868 24
d4882 2
@


1.301
log
@	Scrub remnants of IN_SOLIB_DYNSYM_RESOLVE_CODE.
	* gdbarch.sh: Adjust comment to refer to
	in_solib_dynsym_resolve_code().
	* gdbarch.h, gdbarch.c: Update.
	* solib-osf.c: Ditto.
	* infrun.c: Ditto.
	(handle_inferior_event): Use in_solib_dynsym_resolve_code
	unconditionally.
	* config/mips/nm-irix5.h: Remove undef of
	IN_SOLIB_DYNSYM_RESOLVE_CODE.

	* gdbint.texinfo: Refer to target_so_ops.in_dynsym_resolve_code
	instead of IN_SOLIB_DYNSYM_RESOLVE_CODE.
@
text
@d1580 3
a1582 1
      normal_stop ();
@


1.300
log
@Revert frame_unwind_caller_pc / frame_unwind_caller_id.
@
text
@d143 1
a143 1
   IN_SOLIB_DYNSYM_RESOLVE_CODE says whether we're in the dynamic
d149 1
a149 1
   IN_SOLIB_DYNSYM_RESOLVE_CODE can generally be implemented in a
d3017 1
a3017 6
#ifdef IN_SOLIB_DYNSYM_RESOLVE_CODE
      && IN_SOLIB_DYNSYM_RESOLVE_CODE (stop_pc)
#else
      && in_solib_dynsym_resolve_code (stop_pc)
#endif
      )
d3110 1
a3110 7
      if (
#ifdef IN_SOLIB_DYNSYM_RESOLVE_CODE
	  IN_SOLIB_DYNSYM_RESOLVE_CODE (ecs->stop_func_start)
#else
	  in_solib_dynsym_resolve_code (ecs->stop_func_start)
#endif
)
@


1.300.2.1
log
@2008-07-17  Michael Snyder  <msnyder@@specifix.com>
	2006-05-02  Michael Snyder  <msnyder@@redhat.com>

	* Target interface for reverse execution.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(enum exec_direction_kind): New enum.
	(struct target_ops): New methods to_set_execdir, to_get_execdir.
	* target.c (target_get_execdir): New generic method.
	(target_set_execdir): Ditto.
	* remote.c (remote_get_execdir, remote_set_execdir): New methods.
	(remote_vcont_resume): Jump out if attempting reverse execution.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(_initialize_remote): Add new methods to remote target vector.

	* breakpoint.h (breakpoint_silence): Export.
	* breakpoint.c (breakpoint_silence): New function.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.
	* infrun.c (enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.

	2006-03-31  Michael Snyder  <msnyder@@redhat.com>
	User interface for reverse execution.
	* Makefile.in (reverse.c): New file.
	* reverse.c: New file.  User interface for reverse execution.

	2007-04-18  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c (finish_backwards): Correct check for whether to back
	up after finishing.

	* arm-tdep.c (arm_scan_epilogue): New.
	(arm_make_prologue_cache): Use it.
	(arm_epilogue_unwind_sniffer): New.
	(arm_gdbarch_init): Register it.
@
text
@d1419 1
a1419 3
  SIGNAL_RECEIVED,
  /* Reverse execution -- target ran out of history info.  */
  NO_HISTORY
a2112 6
    case TARGET_WAITKIND_NO_HISTORY:
      /* Reverse execution: target ran out of history info.  */
      print_stop_reason (NO_HISTORY, 0);
      stop_stepping (ecs);
      return;

a2840 11
	if (stop_pc == ecs->stop_func_start &&
	    target_get_execution_direction () == EXEC_REVERSE)
	  {
	    /* We are stepping over a function call in reverse, and
	       just hit the step-resume breakpoint at the start
	       address of the function.  Go back to single-stepping,
	       which should take us back to the function call.  */
	    tss->stepping_over_breakpoint = 1;
	    keep_going (ecs);
	    return;
	  }
d3006 1
a3006 16

      /* When stepping backward, stop at beginning of line range
	 (unles it's the function entry point, in which case
	 keep going back to the call point).  */
      if (stop_pc == step_range_start &&
	  stop_pc != ecs->stop_func_start &&
	  target_get_execution_direction () == EXEC_REVERSE)
	{
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	}
      else
	{
	  keep_going (ecs);
	}
d3095 4
a3098 25
	  /* We're doing a "next".

	     Normal (forward) execution: set a breakpoint at the
	     callee's return address (the address at which the caller
	     will resume).

	     Reverse (backward) execution.  set the step-resume
	     breakpoint at the start of the function that we just
	     stepped into (backwards), and continue to there.  When we
	     get there, we'll need to single-step back to the
	     caller.  */

	  if (target_get_execution_direction () == EXEC_REVERSE)
	    {
	      /* FIXME: I'm not sure if we've handled the frame for
		 recursion.  */

	      struct symtab_and_line sr_sal;
	      init_sal (&sr_sal);
	      sr_sal.pc = ecs->stop_func_start;
	      insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
	    }
	  else
	    insert_step_resume_breakpoint_at_caller (get_current_frame ());

d3160 3
a3162 16
      if (target_get_execution_direction () == EXEC_REVERSE)
	{
	  /* Set a breakpoint at callee's start address.
	     From there we can step once and be back in the caller.  */
	  /* FIXME: I'm not sure we've handled the frame for recursion.  */
	  struct symtab_and_line sr_sal;
	  init_sal (&sr_sal);
	  sr_sal.pc = ecs->stop_func_start;
	  insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
	}
      else
	{
	  /* Set a breakpoint at callee's return address (the address
	     at which the caller will resume).  */
	  insert_step_resume_breakpoint_at_caller (get_current_frame ());
	}
a3354 22
  if (target_get_execution_direction () == EXEC_REVERSE)
    {
      stop_func_sal = find_pc_line (stop_pc, 0);

      /* OK, we're just gonna keep stepping here.  */
      if (stop_func_sal.pc == stop_pc)
	{
	  /* We're there already.  Just stop stepping now.  */
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}
      /* Else just reset the step range and keep going.
	 No step-resume breakpoint, they don't work for
	 epilogues, which can have multiple entry paths.  */
      step_range_start = stop_func_sal.pc;
      step_range_end   = stop_func_sal.end;
      keep_going (ecs);
      return;
    }
  /* else... */
a3718 4
    case NO_HISTORY:
      /* Reverse execution: target ran out of history info.  */
      ui_out_text (uiout, "\nNo more reverse-execution history.\n");
      break;
@


1.300.2.2
log
@Add record target to GDB.
@
text
@a52 8
#include "record.h"

/* When the record function want inferior step before call function
   "keep_going", "reverse_resume_need_step" will be set to 1. It will be set
   back to 0 in the begin of function "handle_inferior_event" because it just
   be accessed by the sub-functions of "handle_inferior_event". */
static int reverse_resume_need_step = 0;

d589 1
a589 1
ptid_t displaced_step_ptid;
d608 1
a608 1
CORE_ADDR displaced_step_original, displaced_step_copy;
d633 1
a633 2
	  && gdbarch_displaced_step_copy_insn_p (gdbarch)
	  && !RECORD_IS_REPLAY);
a1205 3
  if (RECORD_IS_USED)
    record_not_record_set ();

a1821 3
  /* Reset reverse_resume_need_step to 0. */
  reverse_resume_need_step = 0;

d2611 1
a2611 3
	      || (step_range_end && step_resume_breakpoint == NULL)
	      || (target_get_execution_direction () == EXEC_REVERSE)
	      || RECORD_IS_USED);
d3141 1
a3141 2
	  if (target_get_execution_direction () == EXEC_REVERSE
	      || RECORD_IS_USED)
d3143 7
a3149 1
	      reverse_resume_need_step = 1;
a3224 4
      else if (RECORD_IS_USED)
	{
	  reverse_resume_need_step = 1;
	}
a3281 7
      if (target_get_execution_direction () == EXEC_REVERSE || RECORD_IS_USED)
	{
	  reverse_resume_need_step = 1;
	  keep_going (ecs);
	  return;
	}

a3330 10

      if ((step_over_calls == STEP_OVER_ALL
	   && target_get_execution_direction () == EXEC_REVERSE)
	  || RECORD_IS_USED)
	{
	  reverse_resume_need_step = 1;
	  keep_going (ecs);
	  return;
	}

d3337 1
a3337 36
  if (target_get_execution_direction () == EXEC_REVERSE
      && frame_id_eq (get_frame_id (get_current_frame ()),
		      step_prev_frame_id))
    {
      if (debug_infrun)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "infrun: return to the prev function\n");
	}
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }

  if (!frame_id_eq (get_frame_id (get_current_frame ()), step_frame_id)
      && (target_get_execution_direction () == EXEC_REVERSE
	  || RECORD_IS_USED))
    {
      if ((stop_pc != stop_pc_sal.pc
	   && target_get_execution_direction () == EXEC_REVERSE)
	  || (step_over_calls == STEP_OVER_ALL && RECORD_IS_USED))
	{
	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog,
				"infrun: maybe stepped into subroutine\n");
	  reverse_resume_need_step = 1;
	  keep_going (ecs);
	  return;
	}
    }

  if (((stop_pc == stop_pc_sal.pc
	&& target_get_execution_direction () != EXEC_REVERSE)
       || (stop_pc >= stop_pc_sal.pc && stop_pc < stop_pc_sal.end
	   && target_get_execution_direction () == EXEC_REVERSE))
d3406 1
a3406 2
	  || bpstat_should_step ()
	  || reverse_resume_need_step);
@


1.300.2.3
log
@Add a element "to_support_record_wait" to target_ops.
Optimize infrun.c.
@
text
@a596 2
/* Record.c(record_message) use it to confirm if the next step is displaced
   step. */
a615 2
/* Record.c(record_message) use them to get the original PC and set it back.
   Because record_message need to record the original PC. */
a636 2
/* When GDB is working in record replay mode, it doesn't need use desplaced
   step. */
a1214 3
  /* When GDB resume the inferior, record target doesn't need to record the
     memory and register store operation of GDB. So set record_not_record to
     1. */
a2621 6
      /* When execution direction is reverse or record target is used, maybe
         GDB will set next resume to step. Then the next step will be set to
         random signal. It will make GDB stop the stop the inferior. So When
         execution direction is reverse or record target is used, not set the 
         random signal. */

d3158 2
a3159 1
	  if (target_get_execution_direction () == EXEC_REVERSE)
d3161 1
a3161 21
	      if (ecs->stop_func_start == 0)
	        {
		  reverse_resume_need_step = 1;
	        }
	      else
	        {
	          struct symtab_and_line sr_sal;
	          init_sal (&sr_sal);
	          sr_sal.pc = ecs->stop_func_start;
	          insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
		}
	    }
	  /* If record target is recording and real running target doesn't
             support record wait, Record target need execute single instruction
             for each step to call funtion "record_message" for each
             instruction. So set "reverse_resume_need_step" to execute single
             step. */
	  else if (RECORD_IS_USED && !RECORD_IS_REPLAY
                   && !RECORD_TARGET_SUPPORT_RECORD_WAIT)
	    {
              reverse_resume_need_step = 1;
d3232 4
a3235 11
	  if (ecs->stop_func_start == 0)
	    {
	      reverse_resume_need_step = 1;
	    }
	  else
	    {
	      struct symtab_and_line sr_sal;
	      init_sal (&sr_sal);
	      sr_sal.pc = ecs->stop_func_start;
	      insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
	    }
d3237 1
a3237 7
      /* If record target is recording and real running target doesn't
         support record wait, Record target need execute single instruction
         for each step to call funtion "record_message" for each
         instruction. So set "reverse_resume_need_step" to execute single
         step. */
      else if (RECORD_IS_USED && !RECORD_IS_REPLAY
	       && !RECORD_TARGET_SUPPORT_RECORD_WAIT)
d3298 1
a3298 7
      /* If record target is recording and real running target doesn't
         support record wait, Record target need execute single instruction
         for each step to call funtion "record_message" for each
         instruction. So set "reverse_resume_need_step" to execute single
         step. */
      if (RECORD_IS_USED && !RECORD_IS_REPLAY
	  && !RECORD_TARGET_SUPPORT_RECORD_WAIT)
d3355 3
a3357 27
      if (target_get_execution_direction () == EXEC_REVERSE)
	{
	  /* Set a breakpoint at callee's start address.
	     From there we can step once and be back in the caller.  */
	  /* FIXME: I'm not sure we've handled the frame for recursion.  */
	  if (ecs->stop_func_start == 0)
	    {
	      reverse_resume_need_step = 1;
	    }
	  else
	    {
	      struct symtab_and_line sr_sal;
	      init_sal (&sr_sal);
	      sr_sal.pc = ecs->stop_func_start;
	      insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
	    }
	  keep_going (ecs);
	  return;
	}

      /* If record target is recording and real running target doesn't
         support record wait, Record target need execute single instruction
         for each step to call funtion "record_message" for each
         instruction. So set "reverse_resume_need_step" to execute single
         step. */
      if (RECORD_IS_USED && !RECORD_IS_REPLAY
	  && !RECORD_TARGET_SUPPORT_RECORD_WAIT)
d3389 3
a3391 3
      if (stop_pc != stop_pc_sal.pc
	   && target_get_execution_direction () == EXEC_REVERSE
	   && step_over_calls == STEP_OVER_ALL)
d3396 1
a3396 11
	  if (ecs->stop_func_start == 0)
	    {
	      reverse_resume_need_step = 1;
	    }
	  else
	    {
	      struct symtab_and_line sr_sal;
	      init_sal (&sr_sal);
	      sr_sal.pc = ecs->stop_func_start;
	      insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
	    }
d3400 1
a3400 1
    } 
@


1.300.2.4
log
@Change record.c (record_list_release_next) just release "record_list".
Add record instructions limit.
Add a cleanup for displaced stepping in function "record_message_cleanups".
@
text
@d815 1
a815 1
void
@


1.300.2.5
log
@2008-09-04  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (handle_inferior_event): Revert one change, in the
	context of comment "We are at the start of a different line".
	This code finds the start of the line while stepping.
@
text
@d3488 1
a3488 1
#if 0
d3507 1
a3507 17
#else
  if ((stop_pc == stop_pc_sal.pc)
      && (tss->current_line != stop_pc_sal.line
	  || tss->current_symtab != stop_pc_sal.symtab))
    {
      /* We are at the start of a different line.  So stop.  Note that
         we don't stop if we step into the middle of a different line.
         That is said to make things like for (;;) statements work
         better.  */
      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog, "infrun: stepped to a different line\n");
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }
#endif
@


1.300.2.6
log
@2008-09-15  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (proceed): No need to singlestep over a breakpoint
	when resuming in reverse.
@
text
@d1229 1
a1229 2
      if (pc == stop_pc && breakpoint_here_p (pc) 
	  && target_get_execution_direction () != EXEC_REVERSE)
d1233 1
a1233 6
	   breakpoint).

	   Note, we don't do this in reverse, because we won't
	   actually be executing the breakpoint insn anyway.
	   We'll be (un-)executing the previous instruction.  */

@


1.300.2.7
log
@2008-10-05  Michael Snyder  <msnyder@@promb-2s-dhcp59.eng.vmware.com>

	* infrun.c (handle_inferior_event): Fix typo in comment.
@
text
@d2626 1
a2626 1
         If someone ever tries to get call dummys on a
@


1.300.2.8
log
@2008-10-05  Michael Snyder  <msnyder@@promb-2s-dhcp59.eng.vmware.com>

	* infrun.c (handle_inferior_event): Fix typo in comment.
@
text
@d2639 1
a2639 1
         random signal. It will make GDB stop the inferior. So When
@


1.300.2.9
log
@2008-10-05  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (use_displaced_stepping): Disallow displaced
	stepping if using record/replay target.
@
text
@d648 1
a648 1
	  && !RECORD_IS_USED);
@


1.300.2.10
log
@2008-10-06  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (handle_inferior_event): Formatting, spelling fix.
@
text
@d2887 2
a2888 2
	if (stop_pc == ecs->stop_func_start
	    && target_get_execution_direction () == EXEC_REVERSE)
d3065 1
a3065 1
	 (unless it's the function entry point, in which case
d3067 3
a3069 3
      if (stop_pc == step_range_start
	  && stop_pc != ecs->stop_func_start
	  && target_get_execution_direction () == EXEC_REVERSE)
@


1.300.2.11
log
@2008-10-06  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (handle_inferior_event, step_into_function): Formatting.
@
text
@d3076 3
a3078 2
	keep_going (ecs);

d3291 3
a3293 1
	reverse_resume_need_step = 1;
d3295 5
a3299 4
	/* Set a breakpoint at callee's return address (the address
	   at which the caller will resume).  */
	insert_step_resume_breakpoint_at_caller (get_current_frame ());

d3618 1
a3618 1
      step_range_end = stop_func_sal.end;
@


1.300.2.12
log
@2008-10-06  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (handle_inferior_event): Comment rewording.
@
text
@d3601 1
a3601 1
      /* OK, we're just going to keep stepping here.  */
@


1.300.2.13
log
@2008-10-06  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (step_into_function): Rename to stepped_into_function.
	Split into two versions (normal (forward), and reverse).
	(handle_inferior_event): Call stepped_into_function or
	stepped_into_function_backward, depending on exec_direction.
@
text
@d1475 1
a1475 2
static void stepped_into_function (struct execution_control_state *ecs);
static void stepped_into_function_backward (struct execution_control_state *ecs);
d3250 1
a3250 7
	    /* Find start of appropriate source line (either first or
	       last line in callee, depending on execution
	       direction).  */
	    if (target_get_execution_direction () == EXEC_REVERSE)
	      stepped_into_function_backward (ecs);
	    else
	      stepped_into_function (ecs);
d3583 5
a3587 6
/* Inferior has stepped into a subroutine call with source code that
   we should not step over.  Do step to the first line of code in
   it.  */
  
  static void
stepped_into_function (struct execution_control_state *ecs)
d3594 6
a3599 2
    ecs->stop_func_start = gdbarch_skip_prologue (current_gdbarch, 
						  ecs->stop_func_start);
d3601 18
a3679 37
/* Inferior has stepped backward into a subroutine call with source
   code that we should not step over.  Do step to the beginning of the
   last line of code in it.  */

static void
stepped_into_function_backward (struct execution_control_state *ecs)
{
  struct symtab *s;
  struct symtab_and_line stop_func_sal, sr_sal;

  s = find_pc_symtab (stop_pc);
  if (s && s->language != language_asm)
    ecs->stop_func_start = gdbarch_skip_prologue (current_gdbarch, 
						  ecs->stop_func_start);

  stop_func_sal = find_pc_line (stop_pc, 0);

  /* OK, we're just going to keep stepping here.  */
  if (stop_func_sal.pc == stop_pc)
    {
      /* We're there already.  Just stop stepping now.  */
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
    }
  else
    {
      /* Else just reset the step range and keep going.
	 No step-resume breakpoint, they don't work for
	 epilogues, which can have multiple entry paths.  */
      step_range_start = stop_func_sal.pc;
      step_range_end = stop_func_sal.end;
      keep_going (ecs);
    }
  return;
}

@


1.300.2.14
log
@2008-10-06  Michael Snyder  <msnyder@@vmware.com>

	* record.c (displaced_step_fixup): Remove.
	(record_message_cleanups): Remove displaced step handling.
	(record_message): Remove displaced step handling.
	* infrun.c (displaced_step_ptid): Back to being static.
	(displaced_step_original, displaced_step_copy): Ditto.
@
text
@d597 3
a599 1
static ptid_t displaced_step_ptid;
d618 3
a620 1
static CORE_ADDR displaced_step_original, displaced_step_copy;
@


1.300.2.15
log
@2008-10-07  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c, inflow.c, infrun.c, linux-record.c,
	linux-record.h, record.c, record.h: Change name from
	"record and reverse target" to
	"process record and replay target".
@
text
@d1217 3
a1219 3
  /* When GDB resume the inferior, process record target doesn't need to
     record the memory and register store operation of GDB. So set
     record_not_record to 1. */
d2634 5
a2638 5
       /* When execution direction is reverse or process record target is used,
          maybe GDB will set next resume to step. Then the next step will be
          set to random signal. It will make GDB stop the stop the inferior. So
          When execution direction is reverse or record target is used, not set
          the random signal. */
d3189 5
a3193 5
	  /* If process record target is recording and real running target
	     doesn't support record wait, Record target need execute single
	     instruction for each step to call funtion "record_message" for
	     each instruction. So set "reverse_resume_need_step" to execute
	     single step. */
d3286 3
a3288 3
      /* If process record target is recording and real running target doesn't
         support record wait, process record target need execute single
	 instruction for each step to call funtion "record_message" for each
d3350 3
a3352 3
      /* If process record target is recording and real running target doesn't
         support record wait, process record target need execute single
         instruction for each step to call funtion "record_message" for each
d3433 3
a3435 3
      /* If process record target is recording and real running target doesn't
         support record wait, process record target need execute single
	 instruction for each step to call funtion "record_message" for each
@


1.300.2.16
log
@2008-10-07  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (stepped_into_function): Rename handle_step_into_function.
	(stepped_into_function_backward):
	Rename handle_step_into_function_backward.
@
text
@d1471 2
a1472 2
static void handle_step_into_function (struct execution_control_state *ecs);
static void handle_step_into_function_backward (struct execution_control_state *ecs);
d3247 3
d3251 1
a3251 1
	      handle_step_into_function_backward (ecs);
d3253 1
a3253 1
	      handle_step_into_function (ecs);
d3591 1
a3591 1
handle_step_into_function (struct execution_control_state *ecs)
d3667 1
a3667 1
handle_step_into_function_backward (struct execution_control_state *ecs)
@


1.300.2.17
log
@2008-10-07  Michael Snyder  <msnyder@@vmware.com>

	* target.h (to_set_exec_direction, to_get_exec_direction): Remove.
	(to_can_execute_reverse): New method.
	(enum exec_direction_kind): Move to inferior.h.
	* target.c (update_current_target): Inherit to_can_execute_reverse.
	Remove to_set_exec_direction, to_get_exec_direction.
	* inferior.h (enum exec_direction_kind): Move from target.h.

	* infrun.c (set_exec_direction_func): Move here from reverse.c.
	(show_exec_direction_func): Ditto.
	(proceed): Consult global execution_direction instead of
	target method.
	(handle_inferior_event): Ditto.

	* reverse.c (set_exec_direction_func): Move to infrun.c
	(show_exec_direction_func): Ditto.
	(exec_direction_default): Set infrun global variable.
	(exec_reverse_once): Consult infrun global direction variable.

	* infcmd.c (step_1): Consult infrun global direction variable.
	(step_once): Ditto.
	(until_next_command): Ditto.
	(finish_command): Ditto.

	* record.h (record_exec_direction): Delete.
	(RECORD_IS_REPLAY): Consult infrun global direction variable.

	* record.c: (record_wait_cleanups): Use infrun state variable.
	(record_wait): Ditto.
	(record_get_exec_direction, record_set_exec_direction): Remove.
	(record_can_execute_reverse): New target method.

	* remote.c (remote_resume): Use infrun state variable.
	(remote_get_exec_direction, remote_set_exec_direction): Remove.
	(remote_can_execute_reverse): New target method.
@
text
@d1226 1
a1226 1
	  && execution_direction != EXEC_REVERSE)
d2645 1
a2645 1
	      || (execution_direction == EXEC_REVERSE)
d2885 1
a2885 1
	    && execution_direction == EXEC_REVERSE)
d3066 1
a3066 1
	  && execution_direction == EXEC_REVERSE)
d3175 1
a3175 1
	  if (execution_direction == EXEC_REVERSE)
d3247 1
a3247 1
	    if (execution_direction == EXEC_REVERSE)
d3266 1
a3266 1
      if (execution_direction == EXEC_REVERSE)
d3410 1
a3410 1
      if (execution_direction == EXEC_REVERSE)
d3449 1
a3449 1
  if (execution_direction == EXEC_REVERSE
d3465 1
a3465 1
      && (execution_direction == EXEC_REVERSE
d3469 1
a3469 1
	   && execution_direction == EXEC_REVERSE
d3492 1
a3492 1
	&& execution_direction != EXEC_REVERSE)
d3494 1
a3494 1
	   && execution_direction == EXEC_REVERSE))
a4919 49
/* User interface for reverse debugging:
   Set exec-direction / show exec-direction commands
   (returns error unless target implements to_set_exec_direction method).  */

enum exec_direction_kind execution_direction = EXEC_FORWARD;
static const char exec_forward[] = "forward";
static const char exec_reverse[] = "reverse";
static const char *exec_direction = exec_forward;
static const char *exec_direction_names[] = {
  exec_forward,
  exec_reverse,
  NULL
};

static void
set_exec_direction_func (char *args, int from_tty,
			 struct cmd_list_element *cmd)
{
  if (target_can_execute_reverse)
    {
      if (!strcmp (exec_direction, exec_forward))
	execution_direction = EXEC_FORWARD;
      else if (!strcmp (exec_direction, exec_reverse))
	execution_direction = EXEC_REVERSE;
    }
}

static void
show_exec_direction_func (struct ui_file *out, int from_tty,
			  struct cmd_list_element *cmd, const char *value)
{
  switch (execution_direction) {
  case EXEC_FORWARD:
    fprintf_filtered (out, _("Forward.\n"));
    break;
  case EXEC_REVERSE:
    fprintf_filtered (out, _("Reverse.\n"));
    break;
  case EXEC_ERROR:
  default:
    fprintf_filtered (out, 
		      _("Forward (target `%s' does not support exec-direction).\n"),
		      target_shortname);
    break;
  }
}

/* User interface for non-stop mode.  */

a5144 8
  add_setshow_enum_cmd ("exec-direction", class_run, exec_direction_names,
			&exec_direction, _("Set direction of execution.\n\
Options are 'forward' or 'reverse'."),
			_("Show direction of execution (forward/reverse)."),
			_("Tells gdb whether to execute forward or backward."),
			set_exec_direction_func, show_exec_direction_func,
			&setlist, &showlist);

@


1.300.2.18
log
@2008-10-08  Michael Snyder  <msnyder@@vmware.com>

	* infrun.c (handle_inferior_event): Typo in comment.
@
text
@d2636 1
a2636 1
          set to random signal. It will make GDB stop the inferior. So
@


1.299
log
@	* frame.c (frame_unwind_id): Renamed to ...
	(frame_unwind_caller_id): ... this.  All callers updated.
	(frame_pc_unwind): Renamed to ...
	(frame_unwind_caller_pc): ... this.  All callers updated.
	* frame.h: Document frame_unwind_caller_WHAT functions.
	(frame_unwind_id): Renamed to ...
	(frame_unwind_caller_id): ... this.
	(frame_pc_unwind): Renamed to ...
	(frame_unwind_caller_pc): ... this.
	* hppa-tdep.c (hppa_find_unwind_entry_in_block): Correct comment.
	* stack.c (parse_frame_specification_1): Do not rely on
	frame_unwind_id.
@
text
@d3070 1
a3070 2
      && frame_id_eq (frame_unwind_caller_id (get_current_frame ()),
		      step_frame_id))
d3223 1
a3223 1
	  || !frame_id_p (frame_unwind_caller_id (get_current_frame ())))
d3472 1
a3472 1
   of frame_unwind_caller_id for an example).  */
d3481 1
a3481 1
  gdb_assert (frame_id_p (frame_unwind_caller_id (next_frame)));
d3486 1
a3486 1
		(current_gdbarch, frame_unwind_caller_pc (next_frame));
d3489 1
a3489 2
  insert_step_resume_breakpoint_at_sal (sr_sal,
					frame_unwind_caller_id (next_frame));
@


1.298
log
@	* infrun.c (handle_inferior_event): Tag threads as stopped
	before inserting breakpoints.
@
text
@d3070 2
a3071 1
      && frame_id_eq (frame_unwind_id (get_current_frame ()), step_frame_id))
d3224 1
a3224 1
	  || !frame_id_p (frame_unwind_id (get_current_frame ())))
d3473 1
a3473 1
   of frame_unwind_id for an example).  */
d3482 1
a3482 1
  gdb_assert (frame_id_p (frame_unwind_id (next_frame)));
d3487 1
a3487 1
		(current_gdbarch, frame_pc_unwind (next_frame));
d3490 2
a3491 1
  insert_step_resume_breakpoint_at_sal (sr_sal, frame_unwind_id (next_frame));
@


1.297
log
@2008-07-12  Pedro Alves  <pedro@@codesourcery.com>

	* infrun.c (struct thread_stepping_state): Delete sal member.
	(init_thread_stepping_state): Add local sal.  Use it instead of
	tss->sal.
	(handle_inferior_event): New local stop_pc_sal.  Use it instead of
	tss->sal.
	(step_into_function): Add local stop_func_sal.  Use it instead of
	tss->sal.
@
text
@d1831 23
a1892 23
  reinit_frame_cache ();

  /* If it's a new process, add it to the thread database */

  ecs->new_thread_event = (!ptid_equal (ecs->ptid, inferior_ptid)
			   && !ptid_equal (ecs->ptid, minus_one_ptid)
			   && !in_thread_list (ecs->ptid));

  if (ecs->ws.kind != TARGET_WAITKIND_EXITED
      && ecs->ws.kind != TARGET_WAITKIND_SIGNALLED && ecs->new_thread_event)
    add_thread (ecs->ptid);

  if (ecs->ws.kind != TARGET_WAITKIND_IGNORE)
    {
      /* Mark the non-executing threads accordingly.  */
      if (!non_stop
 	  || ecs->ws.kind == TARGET_WAITKIND_EXITED
 	  || ecs->ws.kind == TARGET_WAITKIND_SIGNALLED)
 	set_executing (pid_to_ptid (-1), 0);
      else
 	set_executing (ecs->ptid, 0);
    }

@


1.296
log
@	* infrun.c (resume): Discard cleanups on early exit path.
@
text
@a297 1
  struct symtab_and_line sal;
d1610 2
d1616 4
a1619 3
  tss->sal = find_pc_line (prev_pc, 0);
  tss->current_line = tss->sal.line;
  tss->current_symtab = tss->sal.symtab;
d1818 1
d3202 1
a3202 1
  tss->sal = find_pc_line (stop_pc, 0);
d3209 1
a3209 1
      && tss->sal.line == 0)
d3255 1
a3255 1
  if (tss->sal.line == 0)
d3269 3
a3271 3
  if ((stop_pc == tss->sal.pc)
      && (tss->current_line != tss->sal.line
	  || tss->current_symtab != tss->sal.symtab))
d3292 2
a3293 2
  step_range_start = tss->sal.pc;
  step_range_end = tss->sal.end;
d3295 2
a3296 2
  tss->current_line = tss->sal.line;
  tss->current_symtab = tss->sal.symtab;
d3348 1
a3348 1
  struct symtab_and_line sr_sal;
d3355 1
a3355 1
  tss->sal = find_pc_line (ecs->stop_func_start, 0);
d3362 4
a3365 4
  if (tss->sal.end
      && tss->sal.pc != ecs->stop_func_start
      && tss->sal.end < ecs->stop_func_end)
    ecs->stop_func_start = tss->sal.end;
@


1.295
log
@        * infrun.c (normal_stop): For MI, report which threads
	were stopped.
@
text
@d972 7
a978 4
	/* Got placed in displaced stepping queue.  Will be resumed
	   later when all the currently queued displaced stepping
	   requests finish.  */
	return;
@


1.294
log
@	* infrun.c (handle_inferior_event): Also ignore a
	TARGET_SIGNAL_TRAP on a STOP_QUIETLY_NO_SIGSTOP.
@
text
@d3882 15
a3896 2
	    ui_out_field_int (uiout, "thread-id",
			      pid_to_thread_id (inferior_ptid));
@


1.293
log
@	Exited threads.

	* thread.c (enum thread_state): New.
	(thread_state main_thread_running): Delete, in favor of...
	(thread_state main_thread_state): ... this.  Update throughout.
	(clear_thread_inferior_resources): New, split from free_thread.
	(free_thread): Call clear_thread_inferior_resources.
	(init_thread_list): Set main thread to stopped state.
	(add_thread_silent): Take care of PTID reuses.
	(delete_thread): If deleting inferior_ptid or a thread with
	refcount > 0, mark it as exited, but still keep it in the list.
	Only notify of thread exits, if we haven't done so yet.
	(iterate_over_threads): Make it safe to delete threads while
	iterating over them.
	(do_captured_list_thread_ids): Don't account for exited threads.
	(thread_alive): Check for the THREAD_EXITED state, and don't set
	ptid to -1 on exited threads.
	(set_running): Update to account for extra possible states.
	(is_thread_state): New.
	(is_stopped, is_exited): New.
	(is_running): Implement in terms of is_thread_state.
	(any_running): Update.
	(print_thread_info): Update.  Account for exited threads.  Don't
	warn about missed frame restoring here, its done in the cleanup.
	(switch_to_thread): Don't read from a thread that has gone.
	(restore_current_thread): In non-stop mode, do a full context
	switch.
	(restore_selected_frame): Add a frame_level argument.  Rewrite.
	(struct current_thread_cleanup): Add selected_frame_level and
	was_stopped members.
	(do_restore_current_thread_cleanup): Check if thread was stopped
	and still is, and if the target has registers, stack and memory
	before restoring the selected frame.  Don't delete the cleanup
	argument here.
	(restore_current_thread_cleanup_dtor): New.
	(make_cleanup_restore_current_thread): Remove all arguments.
	Rewrite.
	(thread_apply_all_command): Update.  Prune threads.
	(thread_apply_command): Update.
	(thread_command): Account for currently selected exited thread.
	(do_captured_thread_select): Check for a running thread.  Prune
	threads.
	(_initialize_thread): Make "info threads", "thread", "thread
	apply", and "thread apply all" appliable without a selected thread.
	* gdbthread.h (struct thread_info): Replace running_ by state_.
	Add refcount.
	(is_exited, is_stopped): Declare.
	(make_cleanup_restore_current_thread): Remove all arguments.
	* infrun.c: Include "event-top.h".
	(fetch_inferior_event): In non-stop mode, restore selected thread
	and frame after handling the event and running breakpoint
	commands.  Display GDB prompt if needed.
	(normal_stop): In non-stop mode, don't print thread switching
	notice.
	* cli/cli-decode.c (set_cmd_no_selected_thread_ok)
	(get_cmd_no_selected_thread_ok): New.
	* cli/cli-decode.h (CMD_NO_SELECTED_THREAD_OK): New.
	(set_cmd_no_selected_thread_ok, get_cmd_no_selected_thread_ok):
	Declare.
	* cli/cli-cmds.c: Set "pwd", "help", "info", "show" as
	no-selected-thread ok.
	* top.c (execute_command): Check for non no-selected-thread-ok
	commands.
	* linux-nat.c (struct saved_ptids, threads_to_delete)
	(record_dead_thread, prune_lwps): Delete.
	(exit_lwp): Unconditionally delete thread.
	(linux_nat_resume): Remove prune_lwps call.
	* infcmd.c (proceed_thread_callback): Check if !is_stopped instead
	of is_running.  Adjust to make_cleanup_restore_current_thread
	interface change.
	* mi/mi-main.c (mi_cmd_execute): Only allow a few commands if the
	selected thread has exited.
	* inf-loop.c (inferior_event_handler): Don't display the prompt
	here.
	* varobj.c (c_value_of_root): Update.
	* defs.h (make_cleanup_dtor): Declare.
	* utils.c (make_cleanup_dtor): New.

	* Makefile.in (infrun.o): Depend on $(event_top_h).
@
text
@d2546 3
a2548 3
         the stop_signal here, because some kernels don't ignore a
         SIGSTOP in a subsequent ptrace(PTRACE_CONT,SIGSTOP) call.
         See more comments in inferior.h.  On the other hand, if we
d2550 7
a2556 1
	 will handle the SIGSTOP if it should show up later.  */
d2558 2
a2559 1
	  && stop_signal == TARGET_SIGNAL_STOP)
@


1.292
log
@	Non-stop inferior control.

	* infrun.c (resume): In non-stop mode, always resume just one
	thread.
	(proceed): Don't call prepare_to_proceed in non-stop mode.
	(fetch_inferior_event): In non-stop mode, switch context before
	handling the event.
	(error_is_running, ensure_not_running): New.
	(handle_inferior_event): In non-stop mode: Mark only the event
	thread as stopped.  Require that the target module manages adding
	threads to the thread list.  Assert that there isn't a
	deferred_step_ptid set.  Don't switch to infwait_thread_hop_state.
	(normal_stop): Only mark not-running if inferior hasn't exited.
	In non-stop mode, only mark the event thread.

	* thread.c:Include "cli/cli-decode.h".
	(print_thread_info): Don't read from a running thread.
	Output "(running)" if thread is running.
	(switch_to_thread): Don't read stop_pc if thread is executing.
	(do_restore_current_thread_cleanup): Don't write to a running
	thread.
	(thread_apply_all_command): Don't read from a running thread.  In
	non-stop mode, do a full context-switch instead of just switching
	threads.
	(thread_apply_command): In non-stop mode, do a full context-switch
	instead of just switching threads.
	(do_captured_thread_select): Likewise.  Inform user if selected
	thread is running.
	(_initialize_thread): Mark "info threads" and "thread" and
	async_ok.

	* inf-loop.c (inferior_event_handler): In non-stop mode, don't
	unregister the target from the event loop.

	* infcmd.c (continue_command, step_1, jump_command)
	(signal_command): Ensure the selected thread isn't running.
	(interrupt_target_command): In non-stop mode, interrupt only the
	selected thread.

	* inferior.h (error_is_running, ensure_not_running): Declare.

	* target.h (struct target_ops): Add ptid argument to the to_stop
	member.
	(target_stop): Add ptid_t argument.

	* target.c (update_current_target): Add ptid argument to to_stop's
	type.
	(debug_to_stop): Add ptid_t argument.
	(debug_to_rcmd): Set to_stop_ptid.

	* remote.c (remote_stop): Add ptid_t argument.
	(async_remote_interrupt): Add inferior_ptid to target_stop.
	* inf-ptrace.c (inf_ptrace_stop): Add ptid argument.

	* Makefile.in (thread.o): Depend on $(cli_decode_h).
@
text
@d51 1
d1534 2
d1541 7
d1584 8
d3730 5
d3742 2
a3743 1
  if (!ptid_equal (previous_inferior_ptid, inferior_ptid)
@


1.291
log
@	Don't rely on ecs->wait_for_more.

	* infrun.c (proceed): Clear the stepping state, set
	previous_inferior_ptid and clear infwait state.
	(wait_for_inferior): Don't clear the stepping state, set
	previous_inferior_ptid, or clear the infwait state here.
	(fetch_inferior_event): Don't clear the stepping state, set
	previous_inferior_ptid, or clear the infwait state here.  Don't
	condition on wait_for_more.
@
text
@d1059 9
a1067 3
      if ((scheduler_mode == schedlock_on)
	  || (scheduler_mode == schedlock_step
	      && (step || singlestep_breakpoints_inserted_p)))
d1228 8
a1235 2
  /* In a multi-threaded task we may select another thread
     and then continue or step.
d1237 12
a1248 10
     But if the old thread was stopped at a breakpoint, it
     will immediately cause another breakpoint stop without
     any execution (i.e. it will report a breakpoint hit
     incorrectly).  So we must step over it first.

     prepare_to_proceed checks the current thread against the thread
     that reported the most recent event.  If a step-over is required
     it returns TRUE and sets the current thread to the old thread. */
  if (prepare_to_proceed (step))
    oneproc = 1;
d1552 9
d1771 14
a1857 2
  /* Mark all threads as not-executing.  In non-stop, this should be
     adjusted to only mark ecs->ptid.  */
d1859 9
a1867 1
    set_executing (pid_to_ptid (-1), 0);
a2104 7
  /* We may want to consider not doing a resume here in order to give
     the user a chance to play with the new thread.  It might be good
     to make that a user-settable option.  */

  /* At this point, all threads are stopped (happens automatically in
     either the OS or the native code).  Therefore we need to continue
     all threads in order to make progress.  */
d2107 14
d2187 3
d2338 7
a2344 2
	      waiton_ptid = ecs->ptid;
	      infwait_state = infwait_thread_hop_state;
d3899 10
a3908 1
  set_running (pid_to_ptid (-1), 0);
@


1.290
log
@	Refactor infrun a bit.

	* infrun.c (currently_stepping): Take a struct
	thread_stepping_state instead of an execution_control_state.
	(struct thread_stepping_state): New, split from
	execution_control_state.
	(gtss, tss): New globals.
	(proceed): Clear the stepping state, set previous_inferior_ptid
	and clear infwait state.
	(init_wait_for_inferior): Clear the stepping state,
	previous_inferior_ptid and infwait state.
	(waiton_ptid, infwait_state): New, split from
	execution_control_state.
	(struct execution_control_state): Members that persist through
	events moved out to either struct thred_stepping_state or made
	global.  Deleted unneeded wp, saved_inferior_ptid, tmpstatus.
	(wait_for_inferior, fetch_inferior_event): Use local
	execution_control_state.  Update to execution_control_state split.
	(init_execution_control_state): Adjust.
	(init_thread_stepping_state): New, extracted from
	init_execution_control_state.
	(context_switch): Take a ptid instead of an
	execution_control_state.
	(context_switch_to): Adjust.
	(adjust_pc_after_break): Adjust.
	(init_infwait_state): New.
	(handle_inferior_event): Adjust.
@
text
@d1291 9
a1471 9
    /* Fill in with reasonable starting values.  */
  init_thread_stepping_state (tss);

    /* Reset to normal state.  */
  init_infwait_state ();

  /* We'll update this if & when we switch to a new thread. */
  previous_inferior_ptid = inferior_ptid;

d1522 1
a1522 4
  if (!ecs->wait_some_more)
    {
      /* Fill in with reasonable starting values.  */
      init_thread_stepping_state (tcs);
d1524 5
a1528 1
      init_infwait_state ();
d1530 1
a1530 13
      /* We'll update this if & when we switch to a new thread. */
      previous_inferior_ptid = inferior_ptid;

      overlay_cache_invalid = 1;

      /* We have to invalidate the registers BEFORE calling target_wait
         because they can be loaded from the target while in target_wait.
         This makes remote debugging a bit more efficient for those
         targets that provide critical registers as part of their normal
         status mechanism. */

      registers_changed ();
    }
@


1.289
log
@	Per-thread commands.

	* gdbthread.h: Remove unneeded forward declarations.
	Include "inferior.h".
	(struct thread_info): Add continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi and stop_signal members.
	(save_infrun_state): Add continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi, stop_signal and stop_bpstat parameters.
	(load_infrun_state): Add continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi, stop_signal and stop_bpstat parameters.

	* thread.c (load_infrun_state): In non-stop mode, load
	continuations, intermediate_continuations, proceed_to_finish,
	step_over_calls, stop_step, step_multi and stop_signal.
	(save_infrun_state): Store continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi, stop_signal and stop_bpstat.
	(save_infrun_state): Store continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi, stop_signal and stop_bpstat.
	(free_thread): Clear The thread's stop_bpstat.

	* inferior.h (context_switch_to): Declare.

	* infrun.c (ecss): New global.
	(context_switch): Context switch continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi, stop_signal and stop_bpstat.
	(wait_for_inferior): Use global ecss.
	(async_ecss, async_ecs): Delete.
	(fetch_inferior_event): Use global ecss.
	(context_switch_to): New.

	* top.c (execute_command): In non-stop, only check if the current
	thread is running, in all-stop, check if there's any thread
	running.

	* breakpoint.c (bpstat_remove_breakpoint): New.
	(bpstat_remove_breakpoint_callback): New.
	(delete_breakpoint): Clear the stop_bpstats of all threads.

	* mi/mi-main.c (mi_cmd_execute): In non-stop, only check if the
	current thread is running, in all-stop, check if there's any
	thread running.

	* Makefile.in (gdbthread_h): Depend on $(inferior_h).
@
text
@d75 1
a75 1
struct execution_control_state;
d77 1
a77 1
static int currently_stepping (struct execution_control_state *ecs);
d291 22
a312 1
struct execution_control_state ecss;
d1362 4
d1396 5
a1400 3
/* This structure contains what used to be local variables in
   wait_for_inferior.  Probably many of them can return to being
   locals in handle_inferior_event.  */
d1402 2
d1406 1
a1407 4
  struct target_waitstatus *wp;
  /* Should we step over breakpoint next time keep_going 
     is called?  */
  int stepping_over_breakpoint;
a1411 8
  struct symtab_and_line sal;
  int current_line;
  struct symtab *current_symtab;
  ptid_t ptid;
  ptid_t saved_inferior_ptid;
  int step_after_step_resume_breakpoint;
  int stepping_through_solib_after_catch;
  bpstat stepping_through_solib_catchpoints;
a1412 3
  struct target_waitstatus tmpstatus;
  enum infwait_states infwait_state;
  ptid_t waiton_ptid;
d1449 1
d1461 4
d1466 2
a1467 2
  /* Fill in with reasonable starting values.  */
  init_execution_control_state (ecs);
d1485 1
a1485 1
	ecs->ptid = deprecated_target_wait_hook (ecs->waiton_ptid, ecs->wp);
d1487 1
a1487 1
	ecs->ptid = target_wait (ecs->waiton_ptid, ecs->wp);
d1517 1
d1520 2
d1525 3
a1527 1
      init_execution_control_state (ecs);
d1545 1
a1545 1
      deprecated_target_wait_hook (ecs->waiton_ptid, ecs->wp);
d1547 1
a1547 1
    ecs->ptid = target_wait (ecs->waiton_ptid, ecs->wp);
a1569 1
  ecs->stepping_over_breakpoint = 0;
d1571 14
a1584 9
  ecs->step_after_step_resume_breakpoint = 0;
  ecs->stepping_through_solib_after_catch = 0;
  ecs->stepping_through_solib_catchpoints = NULL;
  ecs->sal = find_pc_line (prev_pc, 0);
  ecs->current_line = ecs->sal.line;
  ecs->current_symtab = ecs->sal.symtab;
  ecs->infwait_state = infwait_normal_state;
  ecs->waiton_ptid = pid_to_ptid (-1);
  ecs->wp = &(ecs->ws);
d1608 1
a1608 1
context_switch (struct execution_control_state *ecs)
d1621 1
a1621 1
			  target_pid_to_str (ecs->ptid));
d1624 1
a1624 1
  if (in_thread_list (inferior_ptid) && in_thread_list (ecs->ptid))
d1631 4
a1634 4
			 ecs->stepping_over_breakpoint,
			 ecs->stepping_through_solib_after_catch,
			 ecs->stepping_through_solib_catchpoints,
			 ecs->current_line, ecs->current_symtab,
d1644 1
a1644 1
      load_infrun_state (ecs->ptid, &prev_pc,
d1648 4
a1651 4
			 &ecs->stepping_over_breakpoint,
			 &ecs->stepping_through_solib_after_catch,
			 &ecs->stepping_through_solib_catchpoints,
			 &ecs->current_line, &ecs->current_symtab,
d1661 1
a1661 1
  switch_to_thread (ecs->ptid);
d1673 1
a1673 2
      ecss.ptid = ptid;
      context_switch (&ecss);
d1746 1
a1746 1
	  || !currently_stepping (ecs)
d1752 7
d1774 1
a1774 1
  target_last_waitstatus = *ecs->wp;
d1781 1
a1781 1
  switch (ecs->infwait_state)
d1787 1
a1787 1
      ecs->waiton_ptid = pid_to_ptid (-1);
d1818 1
a1818 1
  ecs->infwait_state = infwait_normal_state;
d1967 1
a1967 1
	  context_switch (ecs);
a2000 2
      ecs->saved_inferior_ptid = inferior_ptid;
      inferior_ptid = ecs->ptid;
d2002 8
a2009 1
      stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);
d2011 3
a2013 2
      ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
      inferior_ptid = ecs->saved_inferior_ptid;
d2017 1
a2017 1
	  context_switch (ecs);
d2134 1
a2134 2
	  ecs->ptid = saved_singlestep_ptid;
	  context_switch (ecs);
d2294 4
a2297 4
		context_switch (ecs);
	      ecs->waiton_ptid = ecs->ptid;
	      ecs->wp = &(ecs->ws);
	      ecs->stepping_over_breakpoint = 1;
d2299 1
a2299 1
	      ecs->infwait_state = infwait_thread_hop_state;
d2321 1
a2321 1
      context_switch (ecs);
d2370 1
a2370 1
      ecs->waiton_ptid = ecs->ptid;
d2372 1
a2372 1
	ecs->infwait_state = infwait_step_watch_state;
d2374 1
a2374 1
	ecs->infwait_state = infwait_nonstep_watch_state;
d2388 1
a2388 1
  ecs->stepping_over_breakpoint = 0;
d2398 1
a2398 1
      && currently_stepping (ecs))
d2414 1
a2414 1
         ecs->stepping_over_breakpoint = 1;
d2426 1
a2426 1
	  ecs->stepping_over_breakpoint = 1;
d2432 3
a2434 3
     1) break; to really stop and return to the debugger,
     2) drop through to start up again
     (set ecs->stepping_over_breakpoint to 1 to single step once)
d2595 1
a2595 1
	  ecs->step_after_step_resume_breakpoint = 1;
d2659 1
a2659 1
	ecs->stepping_over_breakpoint = 1;
d2699 1
a2699 1
	ecs->stepping_over_breakpoint = 1;
d2753 1
a2753 1
	if (ecs->step_after_step_resume_breakpoint)
d2758 2
a2759 2
	    ecs->step_after_step_resume_breakpoint = 0;
	    ecs->stepping_over_breakpoint = 1;
d2834 1
a2834 1
						&ecs->
d2836 1
a2836 1
	      ecs->stepping_through_solib_after_catch = 1;
d2840 1
a2840 1
	      ecs->stepping_over_breakpoint = 1;
d2846 1
a2846 1
	      ecs->stepping_over_breakpoint = 1;
d2869 1
a2869 1
  if (ecs->stepping_through_solib_after_catch)
d2877 1
a2877 1
	  ecs->stepping_over_breakpoint = 1;
d2886 1
a2886 1
      ecs->stepping_through_solib_after_catch = 0;
d2888 2
a2889 2
      stop_bpstat = bpstat_copy (ecs->stepping_through_solib_catchpoints);
      bpstat_clear (&ecs->stepping_through_solib_catchpoints);
d3124 1
a3124 1
  ecs->sal = find_pc_line (stop_pc, 0);
d3131 1
a3131 1
      && ecs->sal.line == 0)
d3177 1
a3177 1
  if (ecs->sal.line == 0)
d3191 3
a3193 3
  if ((stop_pc == ecs->sal.pc)
      && (ecs->current_line != ecs->sal.line
	  || ecs->current_symtab != ecs->sal.symtab))
d3214 2
a3215 2
  step_range_start = ecs->sal.pc;
  step_range_end = ecs->sal.end;
d3217 2
a3218 2
  ecs->current_line = ecs->sal.line;
  ecs->current_symtab = ecs->sal.symtab;
d3255 1
a3255 1
currently_stepping (struct execution_control_state *ecs)
d3259 1
a3259 1
	  || ecs->stepping_through_solib_after_catch
d3277 1
a3277 1
  ecs->sal = find_pc_line (ecs->stop_func_start, 0);
d3284 4
a3287 4
  if (ecs->sal.end
      && ecs->sal.pc != ecs->stop_func_start
      && ecs->sal.end < ecs->stop_func_end)
    ecs->stop_func_start = ecs->sal.end;
d3464 1
a3464 1
      resume (currently_stepping (ecs), stop_signal);
d3481 1
a3481 1
      if (ecs->stepping_over_breakpoint)
d3505 1
a3505 1
      stepping_over_breakpoint = ecs->stepping_over_breakpoint;
d3523 1
a3523 1
      resume (currently_stepping (ecs), stop_signal);
d3538 1
a3538 1
  if (ecs->infwait_state == infwait_normal_state)
d3549 1
a3549 2
      ecs->waiton_ptid = pid_to_ptid (-1);
      ecs->wp = &(ecs->ws);
@


1.288
log
@	Add non_stop global.

	* inferior.h (non_stop): Declare.
	* infrun.c (non_stop, non_stop_1): New.
	(set_non_stop, show_non_stop): New.
	(_initialize_infrun): Add "set/show non-stop" command.
@
text
@d291 2
a1433 1
  struct execution_control_state ecss;
a1443 2
  /* wfi still stays in a loop, so it's OK just to take the address of
     a local to get the ecs pointer.  */
d1489 4
a1492 7
   to keep the state in a global variable ASYNC_ECSS. If it is the
   last time that this function is called for a single execution
   command, then report to the user that the inferior has stopped, and
   do the necessary cleanups. */

struct execution_control_state async_ecss;
struct execution_control_state *async_ecs;
d1497 1
a1497 3
  static struct cleanup *old_cleanups;

  async_ecs = &async_ecss;
d1499 1
a1499 1
  if (!async_ecs->wait_some_more)
d1502 1
a1502 1
      init_execution_control_state (async_ecs);
d1519 2
a1520 2
    async_ecs->ptid =
      deprecated_target_wait_hook (async_ecs->waiton_ptid, async_ecs->wp);
d1522 1
a1522 1
    async_ecs->ptid = target_wait (async_ecs->waiton_ptid, async_ecs->wp);
d1525 1
a1525 1
  handle_inferior_event (async_ecs);
d1527 1
a1527 1
  if (!async_ecs->wait_some_more)
d1605 8
a1612 1
			 ecs->current_line, ecs->current_symtab);
d1622 8
a1629 1
			 &ecs->current_line, &ecs->current_symtab);
d1635 15
@


1.287
log
@	Adjust fork/vfork/exec to pass ptids around.

	* target.h (struct target_waitstatus): Store related_pid as a ptid.
	(inferior_has_forked, inferior_has_vforked, inferior_has_execd):
	Take a ptid_t.
	* breakpoint.h (struct breakpoint): Change forked_inferior_pid
	type to ptid.
	* breakpoint.c (print_it_typical, bpstat_check_location)
	(print_one_breakpoint_location, set_raw_breakpoint_without_location)
	(create_fork_vfork_event_catchpoint): Adjust.
	* infrun.c (fork_event): Change parent_pid and child_pid types to
	ptid.
	(follow_exec, inferior_has_forked, inferior_has_vforked)
	(inferior_has_execd): Take a ptid_t and don't trim it.
	* linux-thread-db.c (thread_db_wait): Don't trim the returned ptid.
	* linux-nat.c (linux_child_follow_fork): Adjust.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait): Adjust.
	* win32-nat.c (get_win32_debug_event): Don't set related_pid.
@
text
@d4468 26
d4567 20
@


1.286
log
@	Add "executing" property to threads.

	* inferior.h (target_executing): Delete.
	* gdbthread.h (struct thread_info): Add executing_ field.
	(set_executing, is_executing): New.
	* thread.c (main_thread_executing): New.
	(init_thread_list): Clear it and also main_thread_running.
	(is_running): Return false if target has no execution.
	(any_running, is_executing, set_executing): New.

	* top.c: Include "gdbthread.h".
	(target_executing): Delete.
	(execute_command): Replace target_executing check by any_running.
	* event-top.c: Include "gdbthread.h".
	(display_gdb_prompt, command_handler): Replace target_executing by
	is_running.
	* inf-loop.c: Include "gdbthread.h".  Don't mark as not executing
	here.  Replace target_executing by is_running.
	* infrun.c (handle_inferior_event): Mark all threads as
	not-executing.
	* linux-nat.c (linux_nat_resume): Don't mark thread as executing
	here.
	* stack.c (get_selected_block): Return null if inferior is
	executing.
	* target.c (target_resume): Mark resumed ptid as executing.
	* breakpoint.c (until_break_command): Replace target_executing
	check by is_executing.
	* remote.c (remote_async_resume): Don't mark inferior as executing
	here.
	* mi/mi-interp.c (mi_cmd_interpreter_exec): Replace target_executing
	by any_running.

	* mi/mi-main.c (mi_cmd_exec_interrupt, mi_cmd_execute)
	(mi_execute_async_cli_command): Replace target_executing by
	is_running.

	* frame.c (get_current_frame): Error out if the current thread is
	executing.
	(has_stack_frames): New.
	(get_selected_frame, deprecated_safe_get_selected_frame): Check
	has_stack_frames.

	* Makefile.in (event-top.o, frame.o, inf-loop.o, top.o): Depend on
	$(gdbthread_h).
@
text
@d300 2
a301 2
    int parent_pid;
    int child_pid;
d365 1
a365 1
follow_exec (int pid, char *execd_pathname)
d367 1
a367 1
  int saved_pid = pid;
d407 1
a407 1
  inferior_ptid = pid_to_ptid (saved_pid);
d1904 1
a1904 1
      pending_follow.fork_event.parent_pid = PIDGET (ecs->ptid);
d1939 1
a1939 1
      follow_exec (PIDGET (inferior_ptid), pending_follow.execd_pathname);
d4330 1
a4330 1
inferior_has_forked (int pid, int *child_pid)
d4340 1
a4340 1
  if (ptid_get_pid (last_ptid) != pid)
d4348 1
a4348 1
inferior_has_vforked (int pid, int *child_pid)
d4358 1
a4358 1
  if (ptid_get_pid (last_ptid) != pid)
d4366 1
a4366 1
inferior_has_execd (int pid, char **execd_pathname)
d4376 1
a4376 1
  if (ptid_get_pid (last_ptid) != pid)
@


1.285
log
@	* infrun.c (follow_exec): Reset shared libraries before adding the
	main exec file.
@
text
@d1774 5
@


1.284
log
@        * breakpoint.c (moribund_locations): New.
        (bpstat_stop_status): Process moribund locations.
        (update_global_location_list): Add removed
        locations to moribund_locations.
        (breakpoint_retire_moribund): New.
        * breakpoint.h (struct bp_location): New field
        events_till_retirement.
        (breakpoint_retire_moribund): Declare.
        * thread.c (thread_count): New.
        * infrun.c (handle_inferior_event): Call
        breakpoint_retire_moribund.
        * gdbthread.h (thread_count): Declare.
@
text
@d422 9
a430 1
  /* And also is where symbols can be found. */
a432 4
  /* Reset the shared library package.  This ensures that we get
     a shlib event when the child reaches "_start", at which point
     the dld will have had a chance to initialize the child. */
  no_shared_libraries (NULL, 0);
@


1.283
log
@	* infrun.c (start_remote): Don't clear thread list here.
	* monitor.c (monitor_open): Include "gdbthread.h".  Clear thread
	list here.
	* remote.c (record_currthread): Upgrade the main thread and its
	entry in the thread list if this is the first time we hear about
	threads.
	(remote_thread_alive): Consider magic_null_ptid or a ptid without
	a tid member always alive.
	(remote_find_new_threads): Don't update the main thread here.
	(remote_start_remote): Clear thread list here.  Always add the
	main thread.
	(extended_remote_attach_1): Add the main thread here.
	(extended_remote_mourn_1): Re-add the main thread here.
	(extended_remote_create_inferior_1): Add a main thread.

	* Makefile.in (monitor.o): Depend on $(gdbthread_h).
@
text
@d1708 2
@


1.282
log
@2008-06-24  Michael Snyder  <msnyder@@specifix.com>

	* infrun.c (_initialize_infrun): White space and typo fix.
@
text
@a1283 1
  init_thread_list ();
@


1.281
log
@	Don't suppress *running when doing finish.
        * infcall.c (call_function_by_hand): Set both
        suppress_resume_observer and suppress_stop_observer.
        * infcmd.c (suppress_run_stop_observers): Split into...
        (suppress_resume_observer, suppress_stop_observer): ...those.
        (finish_command_continuation): Clear suppress_stop_observer.
        (finish_command): Set suppress_stop_observer.
        * inferior.h (suppress_run_stop_observers): Split into...
        (suppress_resume_observer, suppress_stop_observer): ...those.
        * infrun.c (normal_stop): Check for suppress_stop_observer.
        * thread.c (set_running): Check for suppress_resume_observer.
@
text
@d4627 1
a4627 1
			    &can_use_displaced_stepping, _("\
d4630 1
a4630 1
If zero, gdb will not use to use displaced stepping to step over\n\
d4632 3
a4634 3
			    NULL,
			    show_can_use_displaced_stepping,
			    &maintenance_set_cmdlist,
a4636 1

@


1.280
log
@	Implement *running.
        * Makefile.in: Update dependencies.
        * gdbthread.h (struct thread_info): New field
        running_.
        (set_running, is_running): New.
        * thread.c (set_running, is_running): New.
        * inferior.h (suppress_normal_stop_observer): Rename to...
        (suppress_run_stop_observers): ..this.
        * infcmd.c (suppress_normal_stop_observer): Rename to...
        (suppress_run_stop_observers): ..this.
        (finish_command_continuation, finish_command): Adjust.
        * infcall.c (call_function_by_hand): Adjust.
        * infrun.c (normal_stop): Call set_running.
        * target.c (target_resume): New.  Call set_running.
        * target.h (target_resume): Convert from macro to
        a function.

        * mi/mi-interp.c (mi_on_resume): New.
        (mi_interpreter_init): Register mi_on_resume.
@
text
@d3775 1
a3775 1
  if (!suppress_run_stop_observers && !step_multi)
@


1.279
log
@	Suppress normal stop observer when it's problematic.
        * inferior.h (suppress_normal_stop_observer): New.
        * infcall.c (call_function_by_hand): Disable stop events when
        doing function calls.
        * infmcd.c (suppress_normal_stop_observer): New.
        (finish_command_continuation): Call normal_stop observer
        explicitly.
        (finish_command): Disable stop events inside proceed.
        * infrun.c (normal_stop): Don't call normal stop observer if
        suppressed of if multi-step is in progress.
@
text
@d3775 1
a3775 1
  if (!suppress_normal_stop_observer && !step_multi)
d3780 1
@


1.278
log
@* annotate.c (annotate_thread_changed): New function.
* thread.c (thread_command) : Use it.
* infrun.c (normal_stop): Use it.
@
text
@d3775 2
a3776 1
  observer_notify_normal_stop (stop_bpstat);
@


1.278.2.1
log
@Reverse execution branch

2008-06-09  Michael Snyder  <msnyder@@specifix.com>
	2006-05-02  Michael Snyder  <msnyder@@redhat.com>

	* Target interface for reverse execution.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(enum exec_direction_kind): New enum.
	(struct target_ops): New methods to_set_execdir, to_get_execdir.
	* target.c (target_get_execdir): New generic method.
	(target_set_execdir): Ditto.
	* remote.c (remote_get_execdir, remote_set_execdir): New methods.
	(remote_vcont_resume): Jump out if attempting reverse execution.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(_initialize_remote): Add new methods to remote target vector.

	* breakpoint.h (breakpoint_silence): Export.
	* breakpoint.c (breakpoint_silence): New function.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.
	* infrun.c (enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.

	2006-03-31  Michael Snyder  <msnyder@@redhat.com>
	User interface for reverse execution.
	* Makefile.in (reverse.c): New file.
	* reverse.c: New file.  User interface for reverse execution.
@
text
@d1363 1
a1363 3
  SIGNAL_RECEIVED,
  /* Reverse execution -- target ran out of history info.  */
  NO_HISTORY
a1982 6
    case TARGET_WAITKIND_NO_HISTORY:
      /* Reverse execution: target ran out of history info.  */
      print_stop_reason (NO_HISTORY, 0);
      stop_stepping (ecs);
      return;

a2689 11
	if (stop_pc == ecs->stop_func_start &&
	    target_get_execution_direction () == EXEC_REVERSE)
	  {
	    /* We are stepping over a function call in reverse, and
	       just hit the step-resume breakpoint at the start
	       address of the function.  Go back to single-stepping,
	       which should take us back to the function call.  */
	    ecs->stepping_over_breakpoint = 1;
	    keep_going (ecs);
	    return;
	  }
d2855 1
a2855 16

      /* When stepping backward, stop at beginning of line range
	 (unles it's the function entry point, in which case
	 keep going back to the call point).  */
      if (stop_pc == step_range_start &&
	  stop_pc != ecs->stop_func_start &&
	  target_get_execution_direction () == EXEC_REVERSE)
	{
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	}
      else
	{
	  keep_going (ecs);
	}
d2944 4
a2947 25
	  /* We're doing a "next".

	     Normal (forward) execution: set a breakpoint at the
	     callee's return address (the address at which the caller
	     will resume).

	     Reverse (backward) execution.  set the step-resume
	     breakpoint at the start of the function that we just
	     stepped into (backwards), and continue to there.  When we
	     get there, we'll need to single-step back to the
	     caller.  */

	  if (target_get_execution_direction () == EXEC_REVERSE)
	    {
	      /* FIXME: I'm not sure if we've handled the frame for
		 recursion.  */

	      struct symtab_and_line sr_sal;
	      init_sal (&sr_sal);
	      sr_sal.pc = ecs->stop_func_start;
	      insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
	    }
	  else
	    insert_step_resume_breakpoint_at_caller (get_current_frame ());

d3009 3
a3011 16
      if (target_get_execution_direction () == EXEC_REVERSE)
	{
	  /* Set a breakpoint at callee's start address.
	     From there we can step once and be back in the caller.  */
	  /* FIXME: I'm not sure we've handled the frame for recursion.  */
	  struct symtab_and_line sr_sal;
	  init_sal (&sr_sal);
	  sr_sal.pc = ecs->stop_func_start;
	  insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
	}
      else
	{
	  /* Set a breakpoint at callee's return address (the address
	     at which the caller will resume).  */
	  insert_step_resume_breakpoint_at_caller (get_current_frame ());
	}
a3203 22
  if (target_get_execution_direction () == EXEC_REVERSE)
    {
      ecs->sal = find_pc_line (stop_pc, 0);

      /* OK, we're just gonna keep stepping here.  */
      if (ecs->sal.pc == stop_pc)
	{
	  /* We're there already.  Just stop stepping now.  */
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}
      /* Else just reset the step range and keep going.
	 No step-resume breakpoint, they don't work for
	 epilogues, which can have multiple entry paths.  */
      step_range_start = ecs->sal.pc;
      step_range_end   = ecs->sal.end;
      keep_going (ecs);
      return;
    }
  /* else... */
a3568 4
    case NO_HISTORY:
      /* Reverse execution: target ran out of history info.  */
      ui_out_text (uiout, "\nNo more reverse-execution history.\n");
      break;
@


1.277
log
@gdb/
	* breakpoint.c (update_breakpoints_after_exec): Delete bp_longjmp
	and bp_longjmp_resume breakpoints.
	(breakpoint_address_is_meaningful): Claim bp_longjmp_resume as
	meaningful.
	(create_longjmp_breakpoint): Don't create bp_longjmp_resume
	breakpoints.  Create bp_longjmp breakpoints as momentary
	breakpoints.
	(enable_longjmp_breakpoint): Delete.
	(set_longjmp_breakpoint): New.
	(disable_longjmp_breakpoint): Delete.
	(delete_longjmp_breakpoint): New.
	(set_longjmp_resume_breakpoint): Delete.
	(set_momentary_breakpoint_at_pc): New.
	(breakpoint_re_set_one): Don't delete bp_longjmp and
	bp_longjmp_resume breakpoints.
	(breakpoint_re_set): Don't create longjmp and longjmp-resume
	breakpoints.

	* infrun.c (step_resume_breakpoint): Add comment.
	(struct execution_control_state): Delete handling_longjmp member.
	(init_execution_control_state). Don't clear handling_longjmp.
	(context_switch): Don't context switch handling_longjmp.
	(handle_inferior_event): If handling a bp_longjmp breakpoint,
	create a bp_longjmp_resume breakpoint, and set it as current
	step_resume_breakpoint, then step over the longjmp breakpoint.  If
	handling a bp_longjmp_resume breakpoint, don't delete the longjmp
	breakpoint, delete the longjmp-resume breakpoint, and stop
	stepping.
	(currently_stepping): Remove handling_longjmp from expression.
	(insert_step_resume_breakpoint_at_sal): Update comment.
	(insert_longjmp_resume_breakpoint): New.

	* breakpoint.h (set_momentary_breakpoint_at_pc): Declare.
	(enable_longjmp_breakpoint, disable_longjmp_breakpoint): Delete
	declarations.
	(set_longjmp_breakpoint, delete_longjmp_breakpoint): Declare.
	(set_longjmp_resume_breakpoint): Delete declaration.

	* gdbthread.h (save_infrun_state): Remove handling_longjmp
	parameter.
	(load_infrun_state): Delete *handling_longjmp parameter.
	* thread.c (save_infrun_state): Remove handling_longjmp parameter.
	Update body.
	(load_infrun_state): Delete *handling_longjmp parameter.  Update
	body.

	* infcmd.c (disable_longjmp_breakpoint_cleanup): Delete.
	(delete_longjmp_breakpoint_cleanup): New.
	(step_1): Call set_longjmp_breakpoint instead of
	enable_longjmp_breakpoint.  Use delete_longjmp_breakpoint_cleanup
	instead of disable_longjmp_breakpoint_cleanup when making cleanup.
	(step_1_continuation): Pass thread id in the continuation args to
	step_once.
	(step_once): Add thread parameter.  Pass thread id the the
	continuation.

gdb/testsuite/
	* gdb.cp/annota2.exp: Adjust to breakpoints invalidations at
	different times.
@
text
@d3608 1
@


1.276
log
@	* inferior.h (read_pc_pid, write_pc_pid): Remove.
	* regcache.h (regcache_read_pc, regcache_write_pc): Add prototypes.

	* regcache.c (read_pc_pid): Remove, replace by ...
	(regcache_read_pc): ... this function.
	(write_pc_pid): Remove, replace by ...
	(regcache_write_pc): ... this function.
	(read_pc, write_pc): Update.

	* infrun.c (displaced_step_prepare): Replace read_pc_pid and
	write_pc_pid by regcache_read_pc and regcache_write_pc.
	(displaced_step_fixup): Likewise.
	(resume): Likewise.  Use regcache arch instead of current_gdbarch.
	(prepare_to_proceed): Likewise.
	(proceed): Likewise.
	(adjust_pc_after_break): Likewise.
	(handle_inferior_event): Likewise.

	* linux-nat.c (cancel_breakpoint): Likewise.
	* linux-thread-db.c (check_event): Likewise.
	* aix-thread.c (aix_thread_wait): Likewise.
	* tracepoint.c (trace_dump_command): Likewise.
@
text
@d282 1
a1383 1
  int handling_longjmp;		/* FIXME */
d1405 2
a1550 1
  ecs->handling_longjmp = 0;	/* FIXME */
d1605 1
a1605 1
			 ecs->handling_longjmp, ecs->stepping_over_breakpoint,
d1615 1
a1615 1
			 &ecs->handling_longjmp, &ecs->stepping_over_breakpoint,
d2578 10
a2587 6
	/* If we hit the breakpoint at longjmp, disable it for the
	   duration of this command.  Then, install a temporary
	   breakpoint at the target of the jmp_buf. */
        if (debug_infrun)
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_SET_LONGJMP_RESUME\n");
	disable_longjmp_breakpoint ();
d2592 3
d2599 2
a2600 2
	/* Need to blow away step-resume breakpoint, as it
	   interferes with us */
d2602 4
a2605 3
	  {
	    delete_step_resume_breakpoint (&step_resume_breakpoint);
	  }
a2606 2
	set_longjmp_resume_breakpoint (jmp_buf_pc, null_frame_id);
	ecs->handling_longjmp = 1;	/* FIXME */
d2612 10
a2621 4
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_CLEAR_LONGJMP_RESUME\n");
	disable_longjmp_breakpoint ();
	ecs->handling_longjmp = 0;	/* FIXME */
	break;
d3184 2
a3185 3
  return ((!ecs->handling_longjmp
	   && ((step_range_end && step_resume_breakpoint == NULL)
	       || stepping_over_breakpoint))
d3272 2
a3273 2
  /* There should never be more than one step-resume breakpoint per
     thread, so we should never be setting a new
d3341 22
@


1.275
log
@	* infrun.c (handle_inferior_event): Do not insert breakpoints at
	TARGET_WAITKIND_LOADED events during startup (i.e. in the shell).
@
text
@d713 1
a713 1
  original = read_pc_pid (ptid);
d739 1
a739 1
  write_pc_pid (copy, ptid);
d808 2
a809 1
      CORE_ADDR pc = read_pc_pid (event_ptid);
d811 1
a811 1
      write_pc_pid (pc, event_ptid);
d893 3
a895 1
  CORE_ADDR pc = read_pc ();
d922 2
a923 3
      if (gdbarch_skip_permanent_breakpoint_p (current_gdbarch))
	gdbarch_skip_permanent_breakpoint (current_gdbarch,
					   get_current_regcache ());
d938 1
a938 1
  if (use_displaced_stepping (current_gdbarch)
d949 1
a949 1
  if (step && gdbarch_software_single_step_p (current_gdbarch))
d952 1
a952 1
      if (gdbarch_software_single_step (current_gdbarch, get_current_frame ()))
d1039 1
a1039 1
      if (gdbarch_cannot_step_breakpoint (current_gdbarch))
d1049 1
a1049 1
          && use_displaced_stepping (current_gdbarch)
d1052 2
a1053 1
          CORE_ADDR actual_pc = read_pc_pid (resume_ptid);
d1116 1
a1116 2
      && !ptid_equal (inferior_ptid, wait_ptid)
      && breakpoint_here_p (read_pc_pid (wait_ptid)))
d1118 3
a1120 2
      /* If stepping, remember current thread to switch back to.  */
      if (step)
d1122 3
a1124 2
	  deferred_step_ptid = inferior_ptid;
	}
d1126 2
a1127 2
      /* Switch back to WAIT_PID thread.  */
      switch_to_thread (wait_ptid);
d1129 5
a1133 4
      /* We return 1 to indicate that there is a breakpoint here,
	 so we need to step over it before continuing to avoid
	 hitting it straight away. */
      return 1;
d1159 3
d1165 1
a1165 1
    step_start_function = find_pc_function (read_pc ());
d1171 1
a1171 1
      if (read_pc () == stop_pc && breakpoint_here_p (read_pc ()))
d1177 3
a1179 3
      else if (gdbarch_single_step_through_delay_p (current_gdbarch)
              && gdbarch_single_step_through_delay (current_gdbarch,
                                                    get_current_frame ()))
d1186 1
a1186 1
      write_pc (addr);
d1216 1
a1216 1
      if (!use_displaced_stepping (current_gdbarch))
d1223 1
a1223 1
  if (! stepping_over_breakpoint || use_displaced_stepping (current_gdbarch))
d1258 1
a1258 1
     are not guaranteed the inferior is stopped and so the read_pc ()
d1261 1
a1261 1
  prev_pc = read_pc ();
d1626 2
d1632 1
a1632 1
  if (gdbarch_decr_pc_after_break (current_gdbarch) == 0)
d1664 2
a1665 2
  breakpoint_pc = read_pc_pid (ecs->ptid) - gdbarch_decr_pc_after_break
					    (current_gdbarch);
d1693 1
a1693 1
	write_pc_pid (breakpoint_pc, ecs->ptid);
d1931 1
a1931 1
      stop_pc = read_pc_pid (ecs->ptid);
d2017 1
a2017 1
  stop_pc = read_pc_pid (ecs->ptid);
d2156 5
a2160 1
             if (read_pc_pid (singlestep_ptid) != singlestep_pc)
d2171 1
a2171 1
                 stop_pc = read_pc_pid (ecs->ptid);
@


1.274
log
@	Implement displaced stepping.

	gdb/
	* gdbarch.sh (max_insn_length): New 'variable'.
	(displaced_step_copy, displaced_step_fixup)
	(displaced_step_free_closure, displaced_step_location): New
	functions.
	(struct displaced_step_closure): Add forward declaration.
	* gdbarch.c, gdbarch.h: Regenerated.

	* arch-utils.c: #include "objfiles.h".
	(simple_displaced_step_copy_insn)
	(simple_displaced_step_free_closure)
	(displaced_step_at_entry_point): New functions.
	* arch-utils.h (simple_displaced_step_copy_insn)
	(simple_displaced_step_free_closure)
	(displaced_step_at_entry_point): New prototypes.

	* i386-tdep.c (I386_MAX_INSN_LEN): Rename to...
	(I386_MAX_MATCHED_INSN_LEN): ... this.
	(i386_absolute_jmp_p, i386_absolute_call_p)
	(i386_ret_p, i386_call_p, i386_breakpoint_p, i386_syscall_p)
	(i386_displaced_step_fixup): New functions.
	(struct i386_insn, i386_match_insn): Update.
	(i386_gdbarch_init): Set gdbarch_max_insn_length.
	* i386-tdep.h (I386_MAX_INSN_LEN): New.
	(i386_displaced_step_fixup): New prototype.
	* i386-linux-tdep.c (i386_linux_init_abi): Include "arch-utils.h".
	Register gdbarch_displaced_step_copy,
	gdbarch_displaced_step_fixup, gdbarch_displaced_step_free_closure,
	and gdbarch_displaced_step_location functions.

	* infrun.c (debug_displaced): New variable.
	(show_debug_displaced): New function.
	(struct displaced_step_request): New struct.
	(displaced_step_request_queue, displaced_step_ptid)
	(displaced_step_gdbarch, displaced_step_closure)
	(displaced_step_original, displaced_step_copy)
	(displaced_step_saved_copy, can_use_displaced_stepping): New
	variables.
	(show_can_use_displaced_stepping, use_displaced_stepping)
	(displaced_step_clear, cleanup_displaced_step_closure)
	(displaced_step_dump_bytes, displaced_step_prepare)
	(displaced_step_clear_cleanup, write_memory_ptid)
	(displaced_step_fixup): New functions.
	(resume): Call displaced_step_prepare.
	(proceed): Call read_pc once, and remember the value.  If using
	displaced stepping, don't remove breakpoints.
	(handle_inferior_event): Call displaced_step_fixup.  Add some
	debugging output.  When we try to step over a breakpoint, but get
	a signal to deliver to the thread instead, ensure the step-resume
	breakpoint is actually inserted.  If a thread hop is needed, and
	displaced stepping is enabled, don't remove breakpoints.
	(init_wait_for_inferior): Call displaced_step_clear.
	(_initialize_infrun): Add "set debug displaced" command.  Add
	"maint set can-use-displaced-stepping" command.  Clear
	displaced_step_ptid.
	* inferior.h (debug_displaced): Declare variable.
	(displaced_step_dump_bytes): Declare function.

	* Makefile.in (arch-utils.o, i386-linux-tdep.o): Update
	dependencies.

	gdb/testsuite/
	* gdb.asm/asmsrc1.s: Add scratch space.

	gdb/doc/
	* gdb.texinfo (Debugging Output): Document "set/show debug
	displaced".
	(Maintenance Commands): Document "maint set/show
	can-use-displaced-stepping".
@
text
@d1820 2
a1821 1
	  if (!breakpoints_always_inserted_mode ())
@


1.273
log
@2008-05-02  Andrew Stubbs  <andrew.stubbs@@st.com>

	* main.h (batch_silent): Declare.
	* event-top.c: Include main.h.
	(gdb_setup_readline): Remove extern batch_silent declaration.
	* infrun.c (normal_stop): Don't print source location when running in
	--batch-silent mode.
	* Makefile.in (event-top.o): Add main.h dependency.
@
text
@d106 8
d470 371
d892 1
d896 4
a899 5
    fprintf_unfiltered (gdb_stdlog, "infrun: resume (step=%d, signal=%d)\n",
			step, sig);

  /* FIXME: calling breakpoint_here_p (read_pc ()) three times! */

d917 1
a917 1
  if (breakpoint_here_p (read_pc ()) == permanent_breakpoint_here)
d929 18
d958 1
a958 1
          singlestep_pc = read_pc ();
d1042 1
a1042 1
	  if (step && breakpoint_inserted_here_p (read_pc ()))
d1045 14
d1065 1
a1201 2
      /* We will get a trace trap after one instruction.
	 Continue it automatically and insert breakpoints then.  */
d1203 7
a1209 6
      /* FIXME: if breakpoints are always inserted, we'll trap
       if trying to single-step over breakpoint.  Disable
      all breakpoints.  In future, we'd need to invent some
      smart way of stepping over breakpoint instruction without
      hitting breakpoint.  */
      remove_breakpoints ();
d1211 5
a1215 1
  else
d1326 2
d1329 1
d2001 5
d2009 17
a2025 1
    fprintf_unfiltered (gdb_stdlog, "infrun: stop_pc = 0x%s\n", paddr_nz (stop_pc));
d2173 1
a2173 1
	  int remove_status;
d2188 5
a2192 1
	  remove_status = remove_breakpoints ();
a2255 3
      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog, "infrun: STOPPED_BY_WATCHPOINT\n");

d2358 1
a2358 1
     stack.  */
d2360 3
d2364 2
a2365 1
      || (breakpoint_inserted_here_p (stop_pc)
d2492 1
a2492 1
	     Intead this signal arrives.  This signal will take us out
d2500 4
d2527 5
d3361 5
a3365 1
	  remove_breakpoints ();
d4471 8
d4574 12
d4591 1
@


1.272
log
@2008-05-01  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	Based on work by Jan Kratochvil <jan.kratochvil@@redhat.com> and Jeff
 	Johnston <jjohnstn@@redhat.com>.

	* NEWS: Mention attach to stopped process fix.
	* infcmd.c (detach_command, disconnect_command): Discard the thread
	list.
	* infrun.c (handle_inferior_event): Do not ignore non-SIGSTOP while
	attaching.  Use signal_stop_state.
	(signal_stop_state): Check stop_soon.
	* linux-nat.c (kill_lwp): Declare earlier.
	(pid_is_stopped, linux_nat_post_attach_wait): New.
	(lin_lwp_attach_lwp): Use linux_nat_post_attach_wait.  Update
	comments.
	(linux_nat_attach): Use linux_nat_post_attach_wait.
	(detach_callback, linux_nat_detach): Improve handling for signalled
	processes.
	(linux_nat_pid_to_str): Always print out the LWP ID if it differs
	from the process ID.
	* Makefile.in (infcmd.o): Update.

2008-05-01  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb.threads/attach-into-signal.c, gdb.threads/attach-into-signal.exp,
	gdb.threads/attach-stopped.c, gdb.threads/attach-stopped.exp,
	gdb.threads/attachstop-mt.c, gdb.threads/attachstop-mt.exp: New.
@
text
@d3174 4
a3177 1
      if (stop_print_frame)
@


1.271
log
@	* breakpoint.h (enum bpstat_what_main_action): Delete
	BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE.

	* breakpoint.c (clrs): Delete.
	(bpstat_what): Update table.

	* infrun.c (handle_inferior_event): Remove
	BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE handling.
@
text
@d1949 6
a1954 3
         SIGSTOP in a subsequent ptrace(PTRACE_SONT,SOGSTOP) call.
         See more comments in inferior.h.  */
      if (stop_soon == STOP_QUIETLY_NO_SIGSTOP)
d1957 1
a1957 2
	  if (stop_signal == TARGET_SIGNAL_STOP)
	    stop_signal = TARGET_SIGNAL_0;
d2028 1
a2028 1
      if (signal_stop[stop_signal])
d3281 3
a3283 1
  return signal_stop[signo];
@


1.270
log
@	exec_cleanup murder.
	* breakpoint.c (until_break_command_continuation): Add
	the 'error' parameter.  Directly delete the breakoint as
	opposed to running cleanups.
	(until_break_command): Install continuation only
	after starting the target.  Don't use exec cleanups,
	use ordinary cleanups.  Discard cleanups is successfully
	started the target in async mode.
	(make_cleanup_delete_breakpoint): Remove.
	* breakpoint.h (make_cleanup_delete_breakpoint): Remove
	declaration.
	* defs.h (do_exec_cleanups, make_exec_cleanup): Remove
	declarations.
	(struct continations): Add the 'error' parameter to the
	continuation_hook field.
	(add_continuation, do_all_continuations)
	(add_intermediate_continuation)
	(do_all_intermediate_continuations): Add the 'error' parameter.
	* exceptions.c (throw_exception): Don't call do_exec_cleanups.
	* inf-loop.c (inferior_event_handler): Instead of calling
	discard_all_continuations, use do_all_continuations with 1 as
	'error' parameter.  Pass 0 as 'error' parameter in existing uses
	of discard_all_continuations.
	* infcmd.c (step_1): Do not use exec cleanup.  For async case, discard
	cleanups.
	(step_once): Install continuation only after resuming the target.
	(step_1_continuation): Disable longjmp breakpoint on error.
	(finish_command_continuation): Add the error parameter.  Delete
	the finish breakpoint directly, do not use cleanups.
	(finish_command): Do not use exec_cleanups. Always setup
	continuation.  For sync case, immediately run them.
	(attach_command_continuation): Add the error parameter.
	* infrun.c (fetch_inferior_event): Do not use exec cleanups to
	remove step_resume_breakpoint -- adjust delete it directly.
	* interps.c (interp_set): Adjust call to do_all_continations.
	* mi/mi-interp.c (mi_interpreter_exec_continuation): Do not
	do exec cleanups.
	* mi/mi-main.c (mi_cmd_target_select): Do not do exec
	cleanups.
	(mi_cmd_execute): Do not use exec_cleanup.
	(mi_execute_async_cli_command): Simplify the string concatenation
	logic.  Do no use exec cleanup.
	(mi_exec_async_cli_cmd_continuation): New parameter error.
	Free last_async_command.
	* top.c (command_line_handler_continuation): New parameter error.
	* utils.c (exec_cleanup_chain, make_exec_cleanup)
	(do_exec_cleanups): Remove.
	(add_continuation, do_all_continations)
	(add_intermediate_continuation)
	(do_all_intermediate_continuations): New parameter error.
@
text
@a2133 1
      case BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE:
d2138 1
a2138 3
	if (what.main_action == BPSTAT_WHAT_CLEAR_LONGJMP_RESUME)
	  break;
	/* else fallthrough */
@


1.269
log
@	* breakpoint.h (bp_location_p): New typedef.
	Register a vector of bp_location_p.
	* breakpoint.c (always_inserted_mode)
	(show_always_inserted_mode): New.
	(unlink_locations_from_global_list): Remove.
	(update_global_location_list)
	(update_global_location_list_nothrow): New.
	(update_watchpoint): Don't free locations.
	(should_insert_location): New.
	(insert_bp_location): Use should_insert_location.
	(insert_breakpoint_locations): Copied from
	insert_breakpoints.
	(insert_breakpoint): Use insert_breakpoint_locations.
	(bpstat_stop_status): Call update_global_location_list
	when disabling breakpoint.
	(allocate_bp_location): Don't add to bp_location_chain.
	(set_raw_breakpoint)
	(create_longjmp_breakpoint, enable_longjmp_breakpoint)
	(disable_longjmp_breakpoint, create_overlay_event_breakpoint)
	(enable_overlay_breakpoints, disable_overlay_breakpoints)
	(set_longjmp_resume_breakpoint)
	(enable_watchpoints_after_interactive_call_stop)
	(disable_watchpoints_before_interactive_call_start)
	(create_internal_breakpoint)
	(create_fork_vfork_event_catchpoint)
	(create_exec_event_catchpoint, set_momentary_breakpoint)
	(create_breakpoints, break_command_1, watch_command_1)
	(create_exception_catchpoint)
	(handle_gnu_v3_exceptions)
	(disable_breakpoint, breakpoint_re_set_one)
	(create_thread_event_breakpoint, create_solib_event_breakpoint)
	(create_ada_exception_breakpoint): : Don't call check_duplicates.
	Call update_global_location_list.
	(delete_breakpoint): Don't remove locations and don't
	try to reinsert them. Call update_global_location_list.
	(update_breakpoint_locations): Likewise.
	(restore_always_inserted_mode): New.
	(update_breakpoints_after_exec): Temporary disable
	always inserted mode.
	* Makefile.in: Update dependencies.

	* infrun.c (proceed): Remove breakpoints while stepping
	over breakpoint.
	(handle_inferior_event): Don't remove or insert
	breakpoints.
	* linux-fork.c (checkpoint_command): Remove breakpoints
	before fork and insert after.
	(linux_fork_context): Remove breakpoints before switch
	and insert after.
	* target.c (target_disconnect, target_detach): Remove
	breakpoints from target.
@
text
@a1075 3
      old_cleanups = make_exec_cleanup (delete_step_resume_breakpoint,
					&step_resume_breakpoint);

d1104 2
a1105 4
      /* Do only the cleanups that have been added by this
         function. Let the continuations for the commands do the rest,
         if there are any. */
      do_exec_cleanups (old_cleanups);
@


1.268
log
@PR gdb/2424
	* infrun.c (normal_stop) Move breakpoint_auto_delete further down
	to allow printing to 'see' real reason of stop. This fixes PR 2424.
	* breakpoint.c (bpdisp_texst): New function. The function takes over
	the role of bpstats static array in print_one_breakpoint_location.
	(print_it_typical): Print "Temporary breakpoint" instead
	of just "Breakpoint" when breakpoint is, well, temporary. For mi-like
	protocols, print disp field.
	(print_one_breakpoint_location): Removed bpdisps static definition.
	Call new bpstat_text function to get value for 'disp' field.
	(mention): Print "Temporary breakpoint" instead of just "Breakpoint".
@
text
@d617 1
a617 2
	  && breakpoint_here_p (read_pc ())
	  && !breakpoint_inserted_here_p (read_pc ()))
d619 10
a628 10
	  /* We're stepping, have breakpoint at PC, and it's 
	     not inserted.  Most likely, proceed has noticed that
	     we have breakpoint and tries to single-step over it,
	     so that it's not hit.  In which case, we need to
	     single-step only this thread, and keep others stopped,
	     as they can miss this breakpoint if allowed to run.  

	     The current code either has all breakpoints inserted, 
	     or all removed, so if we let other threads run,
	     we can actually miss any breakpoint, not the one at PC.  */
d789 11
a799 3
    /* We will get a trace trap after one instruction.
       Continue it automatically and insert breakpoints then.  */
    stepping_over_breakpoint = 1;
a1357 4
	  /* Remove breakpoints, SOLIB_ADD might adjust
	     breakpoint addresses via breakpoint_re_set.  */
	  remove_breakpoints ();

a1396 3

	  /* Reinsert breakpoints and continue.  */
	  insert_breakpoints ();
d1405 4
d2046 1
a2046 2
	  && breakpoint_here_p (read_pc ())
	  && !breakpoint_inserted_here_p (read_pc ())
a2221 4
	  /* Remove breakpoints, we eventually want to step over the
	     shlib event breakpoint, and SOLIB_ADD might adjust
	     breakpoint addresses via breakpoint_re_set.  */
	  remove_breakpoints ();
d3122 1
a3122 1
  if (target_has_execution)
@


1.267
log
@	Remove ignoring leading exec events code.
        * fork-child.c (startup_inferior): Do not set
        inferior_ignoring_leading_exec_events.
        * inf-child.c (inf_child_reported_exec_events_per_exec_call): Remove.
        (inf_child_target): Do not set to_reported_exec_events_per_exec_call.
        * infrun.c (inferior_ignoring_leading_exec_events): Remove.
        (handle_inferior_event): Remove code for ignoring leading exec
        events.
        * target.c (update_current_target): Do not inherit, or default,
        to_reported_exec_events_per_exec_call.
        (debug_to_reported_exec_events_per_exec_call): Remove.
        (setup_target_debug): Do not set to_reported_exec_events_per_exec_call.
        * target.h (target_reported_exec_events_per_exec_call): Remove.
        (struct target): Remove the to_reported_exec_events_per_exec_call
        field.
@
text
@a3134 5
  /* Delete the breakpoint we stopped at, if it wants to be deleted.
     Delete any breakpoint that is to be deleted at the next stop.  */

  breakpoint_auto_delete (stop_bpstat);

d3273 3
@


1.266
log
@	* Makefile.in (symfile.o): Update.
	* NEWS: Mention exec tracing support.
	* inf-ttrace.c (inf_ttrace_wait): Return TARGET_WAITKIND_EXECD for
	exec events.
	* infcmd.c (kill_if_already_running, detach_command)
	(disconnect_command): Replace SOLIB_RESTART with no_shared_libraries.
	* infrun.c (MAY_FOLLOW_EXEC, may_follow_exec): Delete.
	(follow_exec): Do not check may_follow_exec.  Do not mourn and push
	targets.  Apply the sysroot path to the loaded executable.  Use
	no_shared_libraries.
	* linux-nat.c (linux_child_follow_fork): Print fork following
	messages if verbose.
	(kill_wait_callback): Kill again before waiting a second time.
	* symfile.c (symbol_file_clear): Replace SOLIB_RESTART with
	no_shared_libraries.

	* gdb.base/foll-exec.exp: Update header.  Skip on remote targets.
	Run on GNU/Linux.
	(do_exec_tests): Check for systems which do not support catchpoints.
	Do not match START.
	* gdb.base/foll-fork.exp: Update header.  Skip on remote targets.
	Run on GNU/Linux.  Enable verbose output.
	(check_fork_catchpoints): New.
	(explicit_fork_child_follow, catch_fork_child_follow)
	(tcatch_fork_parent_follow): Update expected messages.
	(do_fork_tests): Use check_fork_catchpoints.
	* gdb.base/foll-vfork.exp: Update header.  Skip on remote targets.
	Run on GNU/Linux.  Enable verbose output.
	(check_vfork_catchpoints): New.
	(vfork_parent_follow_to_bp, tcatch_vfork_then_child_follow): Update
	expected messages.
	(do_vfork_and_exec_tests): Use check_fork_catchpoints.
@
text
@a84 2
int inferior_ignoring_leading_exec_events = 0;

a1493 17
      /* NOTE drow/2002-12-05: This code should be pushed down into the
         target_wait function.  Until then following vfork on HP/UX 10.20
         is probably broken by this.  Of course, it's broken anyway.  */
      /* Is this a target which reports multiple exec events per actual
         call to exec()?  (HP-UX using ptrace does, for example.)  If so,
         ignore all but the last one.  Just resume the exec'r, and wait
         for the next exec event. */
      if (inferior_ignoring_leading_exec_events)
	{
	  inferior_ignoring_leading_exec_events--;
	  target_resume (ecs->ptid, 0, TARGET_SIGNAL_0);
	  prepare_to_wait (ecs);
	  return;
	}
      inferior_ignoring_leading_exec_events =
	target_reported_exec_events_per_exec_call () - 1;

@


1.265
log
@        * infrun.c (wait_for_inferior): Add treat_exec_as_sigtrap parameter
        and use it.
        (proceed, start_remote): Update call to wait_for_inferior.
        * inferior.h (wait_for_inferior): Update declaration.
        * fork-child.c, infcmd.c, solib-irix.c, solib-osf.c, solib-sunos.c,
        solib-svr4.c, win32-nat.c: Update calls to wait_for_inferior.
        * inf-ttrace.c (inf_ttrace_wait): Report TTEVT_EXEC events as
        TARGET_WAITKIND_EXECD instead of TARGET_WAITKIND_STOPPED.
@
text
@a107 9
/* This is true for configurations that may follow through execl() and
   similar functions.  At present this is only true for HP-UX native.  */

#ifndef MAY_FOLLOW_EXEC
#define MAY_FOLLOW_EXEC (0)
#endif

static int may_follow_exec = MAY_FOLLOW_EXEC;

a362 3
  if (!may_follow_exec)
    return;

a396 6
  /* First collect the run target in effect.  */
  tgt = find_run_target ();
  /* If we can't find one, things are in a very strange state...  */
  if (tgt == NULL)
    error (_("Could find run target to save before following exec"));

d398 2
a399 1
  target_mourn_inferior ();
d401 10
a410 2
  /* Because mourn_inferior resets inferior_ptid. */
  push_target (tgt);
d421 1
a421 3
#if defined(SOLIB_RESTART)
  SOLIB_RESTART ();
#endif
@


1.264
log
@        Inform about new thread in a single place.

        * thread.c (add_thread_silent): Renamed
        from add_thread.
        (print_thread_events): New variable definition.
        (show_print_thread_events): New function.
        (_initialize_thread): Add "set print thread-events" and
        "show print thread-events" commands.
        (add_thread): Announce new thread.
        * gdbthread.h (add_thread_silent): Declare.
        (print_thread_events): New variable declaration.
        * inf-ttrace.c (inf_ttrace_wait): Don't
        inform about new thread, as add_thread is always
        called too, and will take care of that.
        * infrun.c (handle_inferior_event): Likewise.
        * procfs.c (procfs_wait): Likewise.
        * remote.c (remote_currthread): Likewise.
        * sol-thread.c (sol_thread_wait): Likewise.
        * win32-nat.c (get_win32_debug_event): Likewise.
        * linux-thread-db.c (attach_thread): Likewise.
        Remove the verbose parameter.
        (check_event): Make detach_thread be verbose
        only if print_thread_events is set.
        * linux-nat.c (lin_lwp_attach_lwp): Don't inform
        about new thread.  This is called only from
        linux-thread-db.c:attach_thread, which will take care.
        Remove the verbose parameter.
        * linux-nat.h (lin_lwp_attach_lwp): Adjust prototype.
@
text
@d855 1
a855 1
      wait_for_inferior ();
d885 1
a885 1
  wait_for_inferior ();
d992 6
d1004 1
a1004 1
wait_for_inferior (void)
d1011 3
a1013 1
    fprintf_unfiltered (gdb_stdlog, "infrun: wait_for_inferior\n");
d1045 7
@


1.263
log
@	* infrun.c (handle_inferior_event): If
	we failed to remove breakpoints, error,
	don't try to increment PC by hand.
@
text
@d1334 1
a1334 7
    {
      add_thread (ecs->ptid);

      ui_out_text (uiout, "[New ");
      ui_out_text (uiout, target_pid_to_str (ecs->ptid));
      ui_out_text (uiout, "]\n");
    }
@


1.262
log
@	Updated copyright notices for most files.
@
text
@d1780 1
a1780 18
	    {
	      /* FIXME!  This is obviously non-portable! */
	      write_pc_pid (stop_pc + 4, ecs->ptid);
	      /* We need to restart all the threads now,
	       * unles we're running in scheduler-locked mode. 
	       * Use currently_stepping to determine whether to 
	       * step or continue.
	       */
	      /* FIXME MVS: is there any reason not to call resume()? */
	      if (scheduler_mode == schedlock_on)
		target_resume (ecs->ptid,
			       currently_stepping (ecs), TARGET_SIGNAL_0);
	      else
		target_resume (RESUME_ALL,
			       currently_stepping (ecs), TARGET_SIGNAL_0);
	      prepare_to_wait (ecs);
	      return;
	    }
@


1.261
log
@        * infrun.c (handle_inferior_event): Remove code that made us
        stop when stepping into the last line of the current function.
@
text
@d5 2
a6 2
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
   Free Software Foundation, Inc.
@


1.260
log
@        * infrun.c (handle_inferior_event): Fix spelling in comment.
@
text
@a2704 14
  if (ecs->stop_func_end && ecs->sal.end >= ecs->stop_func_end)
    {
      /* If this is the last line of the function, don't keep stepping
         (it would probably step us out of the function).
         This is particularly necessary for a one-line function,
         in which after skipping the prologue we better stop even though
         we will be in mid-line.  */
      if (debug_infrun)
	 fprintf_unfiltered (gdb_stdlog, "infrun: stepped to a different function\n");
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }
@


1.259
log
@	* target.h (target_pid_or_tid_to_str): Remove.
	* infrun.c (handle_inferior_event):
        Use target_pid_to_str instead of
	target_pid_or_tid_to_str.
	(normal_stop): Likewise.
@
text
@d1910 1
a1910 1
      /* We're trying to step of a breakpoint.  Turns out that we're
@


1.258
log
@	* infrun.c (init_wait_for_inferior): Reset target_last_wait_ptid.
	(handle_inferior_event): Clear stop_stack_dummy earlier.
@
text
@d1338 1
a1338 1
      ui_out_text (uiout, target_pid_or_tid_to_str (ecs->ptid));
d3160 1
a3160 1
		       target_pid_or_tid_to_str (inferior_ptid));
@


1.257
log
@	Localize infrun use of remove_breakpoints.
	* infrun.c (handle_inferior_event): Remove
	calls to remove_breakpoints, except where needed to
	communicate change of breakpoint locations to inferior.
	(keep_going): If steppping over breakpoint, remove
	breakpoints.
@
text
@d915 2
d1280 3
a1900 1
  stop_stack_dummy = 0;
@


1.256
log
@	Clarify infrun variable naming.
	* infrun.c (trap_expected): Rename
	to stepping_over_breakpoint.  Document.
	(stepping_past_breakpoint): Remove.
	(stepping_past_breakpoint_ptdi): Renamed
	to deferred_step_ptid.
	(struct execution_control_state): Rename
	the another_trap field to stepping_over_breakpoint.
	(struct inferior_status): Rename the trap_expected
	field to stepping_over_breakpoint.
	(clear_proceed_status, proceed)
	(init_execution_control_state, context_switch)
	(handle_inferior_event, currently_stepping)
	(keep_going, save_inferior_status)
	(restore_inferior_status, prepare_to_proceed): Adjust.
	* gdbthread.h (struct thread_info): Rename the
	trap_expected field to stepping_over_breakpoint.
	* thread.c (load_infrun_state, save_infrun_state):
	Adjust.
@
text
@a2148 1
	remove_breakpoints ();
a2172 1
	remove_breakpoints ();
a2181 1
	remove_breakpoints ();
a2241 1
	    remove_breakpoints ();
d2961 5
a2965 1
      if (!ecs->stepping_over_breakpoint)
@


1.255
log
@	* infrun.c (handle_inferior_event): Don't
        ignore beakpoints if trap_expected is set.
@
text
@d221 1
a221 1
/* Nonzero if we are expecting a trace trap and should proceed from it.  */
d223 22
a244 1
static int trap_expected;
d466 8
a473 4
/* Similarly, if we are stepping another thread past a breakpoint,
   save the original thread here so that we can resume stepping it later.  */
static ptid_t stepping_past_breakpoint_ptid;
static int stepping_past_breakpoint;
d675 1
a675 1
  trap_expected = 0;
d721 1
a721 2
	  stepping_past_breakpoint = 1;
	  stepping_past_breakpoint_ptid = inferior_ptid;
d805 1
a805 1
    trap_expected = 1;
d869 1
a869 1
  trap_expected = 0;
d914 1
a914 1
  stepping_past_breakpoint = 0;
d951 3
a953 1
  int another_trap;
d1114 1
a1114 1
  ecs->another_trap = 0;
d1169 1
a1169 1
			 trap_expected, step_resume_breakpoint,
d1172 1
a1172 1
			 ecs->handling_longjmp, ecs->another_trap,
d1179 1
a1179 1
			 &trap_expected, &step_resume_breakpoint,
d1182 1
a1182 1
			 &ecs->handling_longjmp, &ecs->another_trap,
d1639 1
a1639 1
  if (stepping_past_breakpoint)
a1640 2
      stepping_past_breakpoint = 0;

d1647 1
a1647 1
				"infrun: stepping_past_breakpoint\n");
d1658 2
a1659 1
	  switch_to_thread (stepping_past_breakpoint_ptid);
d1667 2
d1799 1
a1799 1
	      ecs->another_trap = 1;
d1893 1
a1893 1
  ecs->another_trap = 0;
d1902 1
a1902 1
      && trap_expected
d1920 1
a1920 1
         ecs->another_trap = 1;
d1929 4
a1932 4
	     case, don't decide that here, just set ecs->another_trap,
	     making sure we single-step again before breakpoints are
	     re-inserted.  */
	  ecs->another_trap = 1;
d1940 1
a1940 1
     (set ecs->another_trap to 1 to single step once)
d2024 1
a2024 1
	      || trap_expected
d2185 1
a2185 1
	ecs->another_trap = 1;
d2246 1
a2246 1
	    ecs->another_trap = 1;
d2331 1
a2331 1
	      ecs->another_trap = 1;
d2337 1
a2337 1
	      ecs->another_trap = 1;
d2368 1
a2368 1
	  ecs->another_trap = 1;
d2764 1
a2764 1
	       || trap_expected))
d2943 1
a2943 1
  if (trap_expected && stop_signal != TARGET_SIGNAL_TRAP)
d2965 1
a2965 1
      if (!ecs->another_trap)
d2981 1
a2981 1
      trap_expected = ecs->another_trap;
d3699 1
a3699 1
  int trap_expected;
d3745 1
a3745 1
  inf_status->trap_expected = trap_expected;
d3797 1
a3797 1
  trap_expected = inf_status->trap_expected;
@


1.254
log
@	Make insert_breakpoints return void.
	* breakpoint.h (insert_breakpoints): Change
	return type to void.
	* breakpoint.c (insert_breakpoints): Change
	return type to void.  Rename local return_val
	variable to error.
	* infrun.c (keep_going): Instead of checking
	return value from insert_breakpoints, catch exception.
@
text
@d1967 6
a1972 17
      /* Don't even think about breakpoints if just proceeded over a
         breakpoint.  */
      if (stop_signal == TARGET_SIGNAL_TRAP && trap_expected)
	{
          if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog, "infrun: trap expected\n");
	  bpstat_clear (&stop_bpstat);
	}
      else
	{
	  /* See if there is a breakpoint at the current PC.  */
	  stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);

	  /* Following in case break condition called a
	     function.  */
	  stop_print_frame = 1;
	}
@


1.253
log
@	Stop infrun from tracking breakpoint insertion status.

	The checks of breakpoints_inserted before calling
	remove_breakpoints are removed, as remove_breakpoint
	won't touch uninserted breakpoints. In a number of places,
	we're interested if a breakpoint is inserted at particular
	PC, and we now use breakpoint_inserted_here_p.  In a few
	places, insert_breakpoints can be called unconditionally,
	since it won't try to insert already inserted breakpoint.

	* breakpoint.h (regular_breakpoint_inserted_here_p): New
	declaration.
	* breakpoint.c (regular_breakpoint_inserted_here_p): New.
	(breakpoint_inserted_here_p): Use
	regular_breakpoint_inserted_here_p.
	* infrun.c (breakpoints_inserted): Remove.
	(resume): Don't check for breakpoints_inserted before
	remove_hw_watchpoints. Use breakpoint_inserted_here_p.
	(proceed, init_wait_for_inferior): Don't set breakpoints_inserted.
	(handle_inferior_event): Don't use breakpoints_inserted.
	Use breakpoints_meant_to_be_inserted and
	breakpoints_inserted_here_p.
	(insert_step_resume_breakpoint_at_sal, keep_going): Use
	breakpoints_meant_to_be_inserted. Don't set breakpoints_inserted.
	(normal_stop): Don't check for breakpoints_inserted.  Don't
	set breakpoints_inserted.
	(keep_going): Don't check for breakpoints_inserted.
	(insert_step_resume_breakpoint_at_sal): Don't insert
	breakpoints
@
text
@d2951 1
d2954 5
a2958 1
	  if (insert_breakpoints () != 0)
@


1.252
log
@	* infrun.c (resume): Set right thread even if
	stepping over breakpoint using software single step.
@
text
@a216 4
/* Nonzero if breakpoints are now inserted in the inferior.  */

static int breakpoints_inserted;

d518 1
a518 1
  if (CANNOT_STEP_HW_WATCHPOINTS && step && breakpoints_inserted)
d634 1
a634 1
	  if (step && breakpoints_inserted && breakpoint_here_p (read_pc ()))
d783 1
a783 6
    {
      insert_breakpoints ();
      /* If we get here there was no call to error() in 
         insert breakpoints -- so they were inserted.  */
      breakpoints_inserted = 1;
    }
a878 1
  breakpoints_inserted = 0;
a1323 2
	  int breakpoints_were_inserted;

d1326 1
a1326 4
	  breakpoints_were_inserted = breakpoints_inserted;
	  if (breakpoints_inserted)
	    remove_breakpoints ();
	  breakpoints_inserted = 0;
d1369 1
a1369 5
	  if (breakpoints_were_inserted)
	    {
	      insert_breakpoints ();
	      breakpoints_inserted = 1;
	    }
d1655 1
a1655 1
      if (breakpoints_inserted && breakpoint_here_p (stop_pc))
a1767 1
	      breakpoints_inserted = 0;
d1929 1
a1929 1
      || (breakpoints_inserted
a2059 1
	  && !breakpoints_inserted
d2061 1
a2133 1
	breakpoints_inserted = 0;
a2158 1
	breakpoints_inserted = 0;
d2168 1
a2168 3
	if (breakpoints_inserted)
	  remove_breakpoints ();
	breakpoints_inserted = 0;
a2229 1
	    breakpoints_inserted = 0;
d2244 1
a2244 3
	  if (breakpoints_inserted)
	    remove_breakpoints ();
	  breakpoints_inserted = 0;
a2846 2
  if (breakpoints_inserted)
    insert_breakpoints ();
d2943 1
a2943 1
         We're going to run this baby now!  */
d2945 5
a2949 1
      if (!breakpoints_inserted && !ecs->another_trap)
a2957 1
	  breakpoints_inserted = 1;
d3150 1
a3150 1
  if (target_has_execution && breakpoints_inserted)
a3160 1
  breakpoints_inserted = 0;
@


1.251
log
@	* infrun.c (resume): Clarify logic that
	decides if a single thread must be resumed. Add
	comments.
@
text
@d608 2
a609 1
      if (step && breakpoint_here_p (read_pc ())
@


1.250
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* frame.c (frame_id_inner): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(frame_find_by_id, get_prev_frame_1): Use get_frame_arch to get at the
	current architecture by frame_info.
	* frame.h (frame_id_inner): Add gdbarch parameter.
	* stack.c (return_command): Use get_frame_arch to get at the current
	architecture by frame_info. Update call of frame_id_inner.
	* infrun.c (handle_inferior_event): Likewise.
	* dummy-frame.c (dummy_frame_push):  Use get_regcache_arch to get at the
	current architecture by regcache. Update call of frame_id_inner.
@
text
@d586 4
a589 8
      if ((step || singlestep_breakpoints_inserted_p)
	  && (stepping_past_singlestep_breakpoint
	      || (!breakpoints_inserted && breakpoint_here_p (read_pc ()))))
	{
	  /* Stepping past a breakpoint without inserting breakpoints.
	     Make sure only the current thread gets to step, so that
	     other threads don't sneak past breakpoints while they are
	     not inserted. */
d591 30
@


1.249
log
@2007-09-16  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Jeff Johnston  <jjohnstn@@redhat.com>

	* breakpoint.c (watchpoints_triggered): New.
	(bpstat_stop_status): Remove STOPPED_BY_WATCHPOINT argument.
	Check watchpoint_triggered instead.  Combine handling for software
	and hardware watchpoints.  Do not use target_stopped_data_address
	here.  Always check a watchpoint if its scope breakpoint triggers.
	Do not stop for thread or overlay events.  Improve check for
	triggered watchpoints without a value change.
	(watch_command_1): Insert the scope breakpoint first.  Link the
	scope breakpoint to the watchpoint.
	* breakpoint.h (enum watchpoint_triggered): New.
	(struct breakpoint): Add watchpoint_triggered.
	(bpstat_stop_status): Update prototype.
	(watchpoints_triggered): Declare.
	* infrun.c (enum infwait_status): Add infwait_step_watch_state.
	(stepped_after_stopped_by_watchpoint): Delete.
	(handle_inferior_event): Make stepped_after_stopped_by_watchpoint
	local.  Handle infwait_step_watch_state.  Update calls to
	bpstat_stop_status.  Use watchpoints_triggered to check
	watchpoints.
	* remote.c (stepped_after_stopped_by_watchpoint): Remove extern.
	(remote_stopped_data_address): Do not check it.

	* gdb.texinfo (Setting Watchpoints): Adjust warning text about
	multi-threaded watchpoints.
	* gdbint.texinfo (Watchpoints): Describe how watchpoints are
	checked.  Describe sticky notification.  Expand description
	of steppable and continuable watchpoints.
	(Watchpoints and Threads): New subsection.

	* gdb.threads/watchthreads.c (thread_function): Sleep between
	iterations.
	* gdb.threads/watchthreads.exp: Allow two watchpoints to trigger
	at once for S/390.  Generate matching fails and passes.
@
text
@d2729 4
a2732 2
    struct frame_id current_frame = get_frame_id (get_current_frame ());
    if (!(frame_id_inner (current_frame, step_frame_id)))
@


1.248
log
@	* breakpoint.c (do_restore_lang_radix_cleanup): Remove.
	(resolve_pending_breakpoint): Remove.
	(re_enable_breakpoints_in_shlibs): Remove.
	(unlink_locations_from_global_list): New.
	(update_breakpoint_locations): New.
	(breakpoint_re_set_one): Don't bail out on pending breakpoints.
	Use parse_condition and update_breakpoint_location to
	reset breakpoint.  Ignore 'symbol not found' error from
	decode_line_1.
	(breakpoint_re_set): Don't emit newline before the
	reason why breakpoint is not reset.
	(do_enable_breakpoint): Don't specially process pending
	breakpoints.
	(free_bp_location): New.
	(break_command_1): For pending breakpoints, initialize
	all fields of a sal with zeroes.
	* breakpoint.h (re_enable_breakpoints_in_shlibs): Remove.
	* infcmd.c (post_create_inferior): Don't call
	re_enable_breakpoints_in_shlibs.
	* infrun.c (handle_inferior_event): Likewise.
	* solib-irix.c (irix_solib_create_inferior_hook): Likewise.
	* solib-osf.c (osf_solib_create_inferior_hook): Likewise.
	* win32-nat.c (get_win32_debug_event): Likewise.
@
text
@d884 1
a1223 2
int stepped_after_stopped_by_watchpoint;

a1226 4
  /* NOTE: bje/2005-05-02: If you're looking at this code and thinking
     that the variable stepped_after_stopped_by_watchpoint isn't used,
     then you're wrong!  See remote.c:remote_stopped_data_address.  */

d1228 2
a1229 1
  int stopped_by_watchpoint = -1;	/* Mark as unknown.  */
d1249 8
a1256 1
      stepped_after_stopped_by_watchpoint = 0;
d1441 1
a1441 1
      stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid, 0);
d1489 1
a1489 1
      stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid, 0);
d1802 10
a1811 4
  /* It may not be necessary to disable the watchpoint to stop over
     it.  For example, the PA can (with some kernel cooperation)
     single step over a watchpoint without disabling the watchpoint.  */
  if (HAVE_STEPPABLE_WATCHPOINT && STOPPED_BY_WATCHPOINT (ecs->ws))
a1814 4
      resume (1, 0);
      prepare_to_wait (ecs);
      return;
    }
a1815 6
  /* It is far more common to need to disable a watchpoint to step
     the inferior over it.  FIXME.  What else might a debug
     register or page protection watchpoint scheme need here?  */
  if (gdbarch_have_nonsteppable_watchpoint (current_gdbarch)
      && STOPPED_BY_WATCHPOINT (ecs->ws))
    {
d1825 2
a1826 7
         watchpoint expression.  The following code does that by
         removing the watchpoint (actually, all watchpoints and
         breakpoints), single-stepping the target, re-inserting
         watchpoints, and then falling through to let normal
         single-step processing handle proceed.  Since this
         includes evaluating watchpoints, things will come to a
         stop in the correct manner.  */
d1828 11
a1838 3
      if (debug_infrun)
	fprintf_unfiltered (gdb_stdlog, "infrun: STOPPED_BY_WATCHPOINT\n");
      remove_breakpoints ();
a1840 1

d1842 4
a1845 2
      ecs->wp = &(ecs->ws);
      ecs->infwait_state = infwait_nonstep_watch_state;
a1849 4
  /* It may be possible to simply continue after a watchpoint.  */
  if (HAVE_CONTINUABLE_WATCHPOINT)
    stopped_by_watchpoint = STOPPED_BY_WATCHPOINT (ecs->ws);

d1971 1
a1971 2
	  stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid,
					    stopped_by_watchpoint);
@


1.247
log
@        * infrun.c (insert_step_resume_breakpoint_at_frame): Add assertion
        that return_frame is not null.
@
text
@a1339 4
	  /* Try to reenable shared library breakpoints, additional
	     code segments in shared libraries might be mapped in now. */
	  re_enable_breakpoints_in_shlibs ();

a2274 4
	  /* Try to reenable shared library breakpoints, additional
	     code segments in shared libraries might be mapped in now. */
	  re_enable_breakpoints_in_shlibs ();

@


1.246
log
@	* infrun.c (stepping_past_breakpoint): New global variable.
	(stepping_past_breakpoint_ptid): Likewise.
	(prepare_to_proceed): Add STEP parameter.  Do not check for Ctrl-C.
	Only switch threads if we need to single-step over a breakpoint hit
	in the previously selected thread.  If stepping, remember previous
	thread to switch back to in STEPPING_PAST_BREAKPOINT[_PTID].  Call
	switch_to_thread instead of copying its contents.
	(proceed): Pass STEP to prepare_to_proceed.  Always set ONEPROC if
	prepare_to_proceed returns true.
	(init_wait_for_inferior): Reset STEPPING_PAST_BREAKPOINT.
	(context_switch): Call switch_to_thread.
	(handle_inferior_event): Switch back to previous thread if requested
	in STEPPING_PAST_BREAKPOINT[_PTID] by prepare_to_proceed.
	* gdbthread.h (switch_to_thread): Add prototype.
	* thread.c (switch_to_thread): Make global.
@
text
@d2871 1
@


1.245
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d81 1
a81 1
static int prepare_to_proceed (void);
d448 5
d650 1
a650 1
prepare_to_proceed (void)
d658 1
a658 2
  /* Make sure we were stopped either at a breakpoint, or because
     of a Ctrl-C.  */
d660 1
a660 2
      || (wait_status.value.sig != TARGET_SIGNAL_TRAP
	  && wait_status.value.sig != TARGET_SIGNAL_INT))
d665 1
d667 2
a668 1
      && !ptid_equal (inferior_ptid, wait_ptid))
d670 2
a671 4
      /* Switched over from WAIT_PID.  */
      CORE_ADDR wait_pc = read_pc_pid (wait_ptid);

      if (wait_pc != read_pc ())
d673 3
a675 2
	  /* Switch back to WAIT_PID thread.  */
	  inferior_ptid = wait_ptid;
d677 2
a678 6
	  /* FIXME: This stuff came from switch_to_thread() in
	     thread.c (which should probably be a public function).  */
	  reinit_frame_cache ();
	  registers_changed ();
	  stop_pc = wait_pc;
	}
d681 3
a683 4
         so we need to step over it before continuing to avoid
         hitting it straight away. */
      if (breakpoint_here_p (wait_pc))
	return 1;
a686 1

d752 1
a752 1
  if (prepare_to_proceed () && breakpoint_here_p (read_pc ()))
d873 1
d1143 2
a1144 2
  inferior_ptid = ecs->ptid;
  reinit_frame_cache ();
d1606 31
@


1.244
log
@	* infrun.c (inferior_ignoring_startup_exec_events): Delete.
	(start_remote): Use STOP_QUIETLY_REMOTE.
	(handle_inferior_event): Do not condition TARGET_WAITKIND_LOADED
	support on a SOLIB_ADD definition.  Update breakpoints_inserted.
	Update to match shared library event breakpoint support.  Only
	resume if appropriate.  Handle STOP_QUIETLY_REMOTE.
	(normal_stop): Handle TARGET_WAITKIND_LOADED.
	* fork-child.c (startup_inferior): Do not set
	inferior_ignoring_startup_exec_events
	* inferior.h (inferior_ignoring_startup_exec_events): Delete
	declaration.
	(enum stop_kind): Improve documentation.  Add STOP_QUIETLY_REMOTE.

	* config/gdbserver.exp (gdb_reconnect): New.
	* gdb.base/so-disc-shr.c, gdb.base/solib-disc.c,
	gdb.base/solib-disc.exp: New files.
	* lib/gdb.exp (gdb_test_multiple): Allow tests to match "Ending
	remote debugging".
	(gdb_compile): Add shlib_load flag.
	* lib/gdbserver-support.exp (gdbserver_run): Save the protocol and
	port.
	(gdbserver_reconnect): New.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.243
log
@	* infrun.c (adjust_pc_after_break): Do not assume software single-step
	is always active if SOFTWARE_SINGLE_STEP_P is true.
	(resume): Use gdbarch_software_single_step[_p] instead of
	SOFTWARE_SINGLE_STEP[_P].
	(handle_inferior_event): Do not check for SOFTWARE_SINGLE_STEP_P.

	* gdbarch.sh (software_single_step): Remove target macro.
	* gdbarch.h, gdbarch.c: Regenerate.
@
text
@a86 1
int inferior_ignoring_startup_exec_events = 0;
d830 1
a830 1
  stop_soon = STOP_QUIETLY;
d1299 6
a1304 4
      /* Ignore gracefully during startup of the inferior, as it
         might be the shell which has just loaded some objects,
         otherwise add the symbols for the newly loaded objects.  */
#ifdef SOLIB_ADD
d1307 2
d1311 1
d1314 1
d1336 1
d1338 3
d1343 17
d1361 16
a1376 2
	  if (breakpoints_inserted)
	    insert_breakpoints ();
d1378 2
a1379 4
#endif
      resume (0, TARGET_SIGNAL_0);
      prepare_to_wait (ecs);
      return;
d1903 2
a1904 1
      || stop_soon == STOP_QUIETLY || stop_soon == STOP_QUIETLY_NO_SIGSTOP)
d1917 1
a1917 1
      if (stop_soon == STOP_QUIETLY)
d3202 12
@


1.242
log
@	* infrun.c (clear_proceed_status): Clean up stop_registers.
	(normal_stop): Allocate regcache for stop_registers.
	(struct inferior_status): Remove stop_registers member.
	(save_inferior_status): Do not save stop_registers.
	(restore_inferior_status): Do not restore stop_registers.
	(discard_inferior_status): Do not discard stop_registers.
	(build_infrun): Remove.
	(_initialize_infrun): Do not swap stop_registers.
@
text
@d540 1
a540 1
  if (SOFTWARE_SINGLE_STEP_P () && step)
d543 1
a543 1
      if (SOFTWARE_SINGLE_STEP (get_current_frame ()))
d1193 26
a1218 15
  if (SOFTWARE_SINGLE_STEP_P ())
    {
      /* When using software single-step, a SIGTRAP can only indicate
         an inserted breakpoint.  This actually makes things
         easier.  */
      if (singlestep_breakpoints_inserted_p)
	/* When software single stepping, the instruction at [prev_pc]
	   is never a breakpoint, but the instruction following
	   [prev_pc] (in program execution order) always is.  Assume
	   that following instruction was reached and hence a software
	   breakpoint was hit.  */
	write_pc_pid (breakpoint_pc, ecs->ptid);
      else if (software_breakpoint_inserted_here_p (breakpoint_pc))
	/* The inferior was free running (i.e., no single-step
	   breakpoints inserted) and it hit a software breakpoint.  */
a1220 30
  else
    {
      /* When using hardware single-step, a SIGTRAP is reported for
         both a completed single-step and a software breakpoint.  Need
         to differentiate between the two as the latter needs
         adjusting but the former does not.

         When the thread to be examined does not match the current thread
         context we can't use currently_stepping, so assume no
         single-stepping in this case.  */
      if (ptid_equal (ecs->ptid, inferior_ptid) && currently_stepping (ecs))
	{
	  if (prev_pc == breakpoint_pc
	      && software_breakpoint_inserted_here_p (breakpoint_pc))
	    /* Hardware single-stepped a software breakpoint (as
	       occures when the inferior is resumed with PC pointing
	       at not-yet-hit software breakpoint).  Since the
	       breakpoint really is executed, the inferior needs to be
	       backed up to the breakpoint address.  */
	    write_pc_pid (breakpoint_pc, ecs->ptid);
	}
      else
	{
	  if (software_breakpoint_inserted_here_p (breakpoint_pc))
	    /* The inferior was free running (i.e., no hardware
	       single-step and no possibility of a false SIGTRAP) and
	       hit a software breakpoint.  */
	    write_pc_pid (breakpoint_pc, ecs->ptid);
	}
    }
d1363 1
a1363 1
      singlestep_breakpoints_inserted_p = 0;	/* SOFTWARE_SINGLE_STEP_P() */
d1383 1
a1383 1
      singlestep_breakpoints_inserted_p = 0;	/* SOFTWARE_SINGLE_STEP_P() */
d1539 1
a1539 2
      gdb_assert (SOFTWARE_SINGLE_STEP_P ()
		  && singlestep_breakpoints_inserted_p);
d1588 1
a1588 1
      else if (SOFTWARE_SINGLE_STEP_P () && singlestep_breakpoints_inserted_p)
d1659 1
a1659 1
	  if (SOFTWARE_SINGLE_STEP_P () && singlestep_breakpoints_inserted_p)
d1708 1
a1708 1
      else if (SOFTWARE_SINGLE_STEP_P () && singlestep_breakpoints_inserted_p)
d1730 1
a1730 1
  if (SOFTWARE_SINGLE_STEP_P () && singlestep_breakpoints_inserted_p)
@


1.241
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (DEPRECATED_FUNCTION_START_OFFSET): Replace by
	gdbarch_deprecated_function_start_offset.
	* symtab.c (find_function_start_sal)skip_prologue_using_sal): Likewise.
	* linespec.c (minsym_found): Likewise.
	* infrun.c (handle_inferior_event): Likewise.
	* infcall.c (find_function_addr): Likewise.
	* cli/cli-cmds.c (disassemble_command): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d635 6
d3227 9
a3235 3
    /* NB: The copy goes through to the target picking up the value of
       all the registers.  */
    regcache_cpy (stop_registers, get_current_regcache ());
a3633 1
  struct regcache *stop_registers;
a3688 2
  inf_status->stop_registers = regcache_dup_no_passthrough (stop_registers);

a3735 4
  /* FIXME: Is the restore of stop_registers always needed. */
  regcache_xfree (stop_registers);
  stop_registers = inf_status->stop_registers;

a3785 1
  regcache_xfree (inf_status->stop_registers);
a3927 6
static void
build_infrun (void)
{
  stop_registers = regcache_xmalloc (current_gdbarch);
}

a3934 3
  DEPRECATED_REGISTER_GDBARCH_SWAP (stop_registers);
  deprecated_register_gdbarch_swap (NULL, 0, build_infrun);

@


1.240
log
@	* regcache.c (struct regcache): Add ptid_t member.
	(regcache_xmalloc): Initialize it.
	(regcache_cpy_no_passthrough): Do not refer to current_regcache.
	(regcache_dup): Likewise.
	(regcache_dup_no_passthrough): Likewise.
	(current_regcache): Make static.
	(registers_ptid): Remove variable.
	(get_thread_regcache): New function.
	(get_current_regcache): New function.
	(registers_changed): Implement by freeing current regcache.
	(regcache_raw_read): Do not refer to current_regcache.  Set
	inferior_ptid to regcache->ptid while calling target routines.
	(regcache_raw_write): Likewise.
	(regcache_raw_supply): Do not refer to current_regcache.
	(read_pc_pid): Use thread regcache.  Do not modify inferior_ptid.
	(write_pc_pid): Likewise.
	(build_regcache): Remove.
	(_initialize_regcache): Do not call DEPRECATED_REGISTER_GDBARCH_SWAP
	or deprecated_register_gdbarch_swap.  Do not initialize
	registers_ptid.
	* regcache.h (get_current_regcache): Add prototype.
	(get_thread_regcache): Likewise.
	(current_regcache): Remove declaration.

	* corelow.c (core_open): Replace current_regcache by
	get_current_regcache ().
	* frame.c (frame_pop): Likewise.
	(put_frame_register): Likewise.
	(get_current_frame, create_new_frame): Likewise.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Likewise.
	* stack.c (return_command): Likewise.
	* infcall.c (call_function_by_hand): Likewise.
	* infrun.c (resume): Likewise.
	(save_inferior_status, restore_inferior_status): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	(fork_save_infrun_state): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* i386fbsd-nat.c (i386fbsd_resume): Likewise.
	* monitor.c (monitor_wait): Likewise.
	* remote.c (remote_wait): Likewise.
	* remote-mips.c (mips_wait): Likewise.

	* bsd-kvm.c (bsd_kvm_open): Likewise
	(bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Likewise.
	* fbsd-nat.c (fbsd_make_corefile_notes): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint): Likewise.
	(ia64_linux_stopped_data_address): Likewise.

	* frv-tdep.c (frv_fdpic_loadmap_addresses): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* mep-tdep.c (current_me_module, current_options): Likewise.
	* mips-tdep.c (deprecated_mips_set_processor_regs_hack): Likewise.

	* linux-nat.c (linux_nat_do_thread_registers): Use thread
	regcache instead of current_regcache.  Call target_fetch_registers.
	(linux_nat_corefile_thread_callback): Update call site.
	(linux_nat_do_registers): Likewise.
	* procfs.c (procfs_do_thread_registers): Use thread regcache instead
	of current_regcache.
	(procfs_make_note_section): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
@
text
@d1810 2
a1811 1
  ecs->stop_func_start += DEPRECATED_FUNCTION_START_OFFSET;
@


1.239
log
@	* gdbarch.sh (get_longjmp_target): Add FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* infrun.c (handle_inferior_event): Pass current frame to
	gdbarch_get_longjmp_target.

	* alpha-tdep.c (alpha_get_longjmp_target): Add FRAME argument.
	Read registers from FRAME instead of using read_register.
	Use get_frame_arch instead of current_gdbarch.
	* arm-tdep.c (arm_get_longjmp_target): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target): Likewise.
	(mips64_linux_get_longjmp_target): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Likewise.
@
text
@d531 2
a532 1
	gdbarch_skip_permanent_breakpoint (current_gdbarch, current_regcache);
d3222 1
a3222 1
    regcache_cpy (stop_registers, current_regcache);
d3679 1
a3679 1
  inf_status->registers = regcache_dup (current_regcache);
d3734 1
a3734 1
    regcache_cpy (current_regcache, inf_status->registers);
@


1.238
log
@	* gdbarch.sh (skip_trampoline_code): Add FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c (generic_skip_trampoline_code): Add FRAME argument.
	* arch-utils.h (generic_skip_trampoline_code): Likewise.
	* infrun.c (handle_inferior_event): Pass current frame to
	gdbarch_skip_trampoline_code and skip_language_trampoline.

	* language.c (unk_lang_trampoline): Add FRAME argument.
	(skip_language_trampoline): Add FRAME argument.  Pass it to
	skip_trampoline callback.
	* language.h: Add forward declaration of struct frame_info.
	(struct language_defn): Add FRAME argument to skip_trampoline.
	(skip_language_trampoline): Add FRAME argument.
	* cp-abi.c (cplus_skip_trampoline): Add FRAME argument.  Pass it
	to skip_trampoline callback.
	* cp-abi.h: Add forward declaration of struct frame_info.
	(cplus_skip_trampoline): Add FRAME argument.
	(struct cp_abi_ops): Add FRAME argument to skip_trampoline callback.
	* gnu-v3-abi.c (gnuv3_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.
	* objc-lang.c (objc_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.

	* minsyms.c (find_solib_trampoline_target): Add FRAME argument.
	* symtab.h (find_solib_trampoline_target): Likewise.
	* obsd-tdep.c (obsd_skip_solib_resolver): Pass current frame to
	find_solib_trampoline_target.

	* arm-tdep.c (arm_skip_stub): Add FRAME argument.  Read registers
	from FRAME instead of calling read_register.

	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code): Add FRAME
	argument.  Read registers from FRAME instead of using read_register.
	* hppa-tdep.c (hppa_skip_trampoline_code): Likewise.
	* hppa-tdep.h (hppa_skip_trampoline_code): Add FRAME argument.

	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Add FRAME
	argument.

	* m32c-tdep.c (m32c_skip_trampoline_code): Add FRAME argument.

	* mips-tdep.c (mips_skip_trampoline_code): Add FRAME argument.  Read
	registers from FRAME instead of using read_signed_register.

	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Add FRAME
	argument.
	(ppc64_standard_linkage_target): Likewise.  Read registers from FRAME
	instead of using read_register.
	(ppc64_skip_trampoline_code): Add FRAME argument.  Pass it to
	ppc64_standard_linkage_target.
	* rs6000-tdep.c (rs6000_skip_trampoline_code): Add FRAME argument.
	Pass it to find_solib_trampoline_target.  Read registers from FRAME
	instead of using read_register.

	* xstormy16-tdep.c (xstormy16_skip_trampoline_code): Add FRAME
	argument.
@
text
@d2080 2
a2081 1
	    || !gdbarch_get_longjmp_target (current_gdbarch, &jmp_buf_pc))
@


1.237
log
@	* gdbarch.sh (software_single_step): Replace REGCACHE argument by
	FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* infrun.c (resume): Pass current frame to SOFTWARE_SINGLE_STEP.

	* alpha-tdep.c (alpha_next_pc): Add FRAME argument.  Retrieve
	registers from FRAME instead of using read_register.
	(alpha_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to alpha_next_pc.  Use get_frame_pc instead of read_pc.
	* alpha-tdep.h (alpha_software_single_step): Replace REGCACHE
	argument by FRAME.

	* arm-tdep.c (shifted_reg_val): Add FRAME argument.  Read registers
	from FRAME instead of using read_register.
	(thumb_get_next_pc): Likewise.
	(arm_get_next_pc): Likewise.
	(arm_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to arm_get_next_pc.  Use get_frame_pc instead of read_register.
	* arm-tdep.h (arm_software_single_step): Replace REGCACHE
	argument by FRAME.

	* cris-tdep.c (find_step_target): Add FRAME argument.  Read registers
	from FRAME instead of using read_register.
	(cris_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to find_step_target.

	* mips-tdep.c (mips32_next_pc): Add FRAME argument.  Read registers
	from FRAME instead of using read_register / read_signed_register.
	(extended_mips16_next_pc): Likewise.
	(mips16_next_pc): Likewise.
	(mips_next_pc): Likewise.
	(mips_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to mips_next_pc.  Use get_frame_pc instead of read_pc.
	* mips-tdep.h (mips_software_single_step): Replace REGCACHE
	argument by FRAME.

	* rs6000-tdep.c (branch_dest): Add FRAME argument.  Use it instead
	of current frame.  Read registers from FRAME.
	(deal_with_atomic_sequence): Add FRAME argument.  Pass it to
	branch_dest.  Use get_frame_pc instead of read_pc.
	(rs6000_software_single_step): Likewise.
	(bl_to_blrl_insn_p): Do not call branch_dest.
	* rs6000-tdep.h (rs6000_software_single_step): Replace REGCACHE
	argument by FRAME.

	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Add FRAME argument.
	Read registers from FRAME instead of current regcache.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Likewise.
	* sparcnbsd-tdep.c (sparcnbsd_step_trap): Likewise.
	* sparc-tdep.c (sparc_address_from_register): Remove.
	(sparc_analyze_control_transfer): Pass FRAME argument instead of
	GDBARCH.  Pass FRAME to step_trap callback.
	(sparc_step_trap): Add FRAME argument.
	(space_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to sparc_analyze_control_transfer.  Read registers from FRAME instead
	of calling sparc_address_from_register.
	* sparc-tdep.h (struct gdbarch_tdep): Add FRAME argument to
	step_trap callback.
	(sparc_address_from_register): Remove prototype.
	(sparc_software_single_step): Replace REGCACHE argument by FRAME.
	(sparcnbsd_step_trap): Add FRAME argument.

	* spu-tdep.c (spu_software_single_step): Replace REGCACHE argument
	by FRAME.  Read registers from FRAME instead of REGCACHE.
@
text
@d2459 1
a2459 1
      real_stop_pc = skip_language_trampoline (stop_pc);
d2461 2
a2462 1
	real_stop_pc = gdbarch_skip_trampoline_code (current_gdbarch, stop_pc);
d2524 3
a2526 2
      CORE_ADDR real_stop_pc = gdbarch_skip_trampoline_code
				 (current_gdbarch, stop_pc);
@


1.236
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SKIP_TRAMPOLINE_CODE): Replace by
	gdbarch_skip_trampoline_code.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise (comment).
	* objc-lang.c (objc_skip_trampoline)
	(objc_submethod_helper_data): Likewise.
	* m32c-lang.c (m32c_skip_trampoline_code): Likewise (comment).
	* infrun.c (handle_inferior_event): Likewise.
	* gnu-v3-abi.c (gnuv3_skip_trampoline): Likewise.
	* gdbarch.sh (IN_SOLIB_RETURN_TRAMPOLINE): Replace by
	gdbarch_in_solib_return_trampoline.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise (comment).
	* infrun.c (handle_inferior_event): Likewise.
	* hppa-tdep.c (hppa_stub_unwind_sniffer): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d542 1
a542 1
      if (SOFTWARE_SINGLE_STEP (current_regcache))
@


1.235
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SKIP_PROLOGUE): Replace by gdbarch_skip_prologue.
	* symtab.c (find_function_start_sal, in_prologue): Likewise.
	* linespec.c (minsym_found): Likewise.
	* infrun.c (step_into_function): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d2461 1
a2461 1
	real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
d2519 2
a2520 1
  if (IN_SOLIB_RETURN_TRAMPOLINE (stop_pc, ecs->stop_func_name))
d2523 2
a2524 1
      CORE_ADDR real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
@


1.234
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (DECR_PC_AFTER_BREAK): Replace by
	gdbarch_decr_pc_after_break.
	* tracepoint.c (trace_dump_command): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* linux-thread-db.c (check_event): Likewise.
	* linux-nat.c (cancel_breakpoints_callback): Likewise.
	* infrun.c (adjust_pc_after_break, normal_stop): Likewise.
	* frame.h: Likewise (comment).
	* dummy-frame.c (deprecated_pc_in_call_dummy): Likewise.
	* aix-thread.c (aix_thread_wait): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d2712 2
a2713 1
    ecs->stop_func_start = SKIP_PROLOGUE (ecs->stop_func_start);
@


1.233
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (ADDR_BITS_REMOVE): Replace by gdbarch_addr_bits_remove.
	* value.c (value_as_address): Likewise (comment).
	* remote-mips.c (common_breakpoint): Likewise.
	* regcache.c (read_pc_pid): Likewise.
	* printcmd.c (do_one_display): Likewise.
	* monitor.c (monitor_write_memory, monitor_read_memory)
	(monitor_insert_breakpoint): Likewise.
	* mips-tdep.c (heuristic_proc_start): Likewise.
	* infrun.c (insert_step_resume_breakpoint_at_frame)
	(insert_step_resume_breakpoint_at_caller): Likewise.
	* buildsym.c (record_line): Likewise.
	* arm-tdep.c (arm_scan_prologue, thumb_get_next_pc)
	(arm_get_next_pc): Likewise.
	* armnbsd-nat.c (arm_supply_gregset, fetch_register, store_register)
	(store_regs): Likewise.
	* arm-linux-tdep.c (arm_linux_supply_gregset): Likewise.
	* arm-linux-nat.c (fetch_register, fetch_regs): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1151 1
a1151 1
  if (DECR_PC_AFTER_BREAK == 0)
d1158 3
a1160 3
     affected by DECR_PC_AFTER_BREAK.  Other waitkinds which are implemented
     by software breakpoints should be handled through the normal breakpoint
     layer.
d1165 3
a1167 3
     DECR_PC_AFTER_BREAK.  I don't know any specific target that generates
     these signals at breakpoints (the code has been in GDB since at least
     1992) so I can not guess how to handle them here.
d1171 3
a1173 3
     watchpoint affected by DECR_PC_AFTER_BREAK.  I haven't found any target
     with both of these set in GDB history, and it seems unlikely to be correct,
     so gdbarch_have_nonsteppable_watchpoint is not checked here.  */
d1183 2
a1184 1
  breakpoint_pc = read_pc_pid (ecs->ptid) - DECR_PC_AFTER_BREAK;
d3087 1
a3087 1
     DECR_PC_AFTER_BREAK */
d3090 1
a3090 1
       DECR_PC_AFTER_BREAK, the program counter can change.  Ask the
d3092 1
a3092 1
       DECR_PC_AFTER_BREAK needs to just go away.  */
@


1.232
log
@2007-06-06  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (HAVE_NONSTEPPABLE_WATCHPOINT): Replace by
	gdbarch_have_nonsteppable_watchpoint.
	* infrun.c (handle_inferior_event, adjust_pc_after_break): Likewise.
	* gdbarch.sh (CANNOT_STEP_BREAKPOINT): Replace by
	gdbarch_cannot_step_breakpoint.
	* infrun.c (resume): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d2811 2
a2812 1
  sr_sal.pc = ADDR_BITS_REMOVE (get_frame_pc (return_frame));
d2844 2
a2845 1
  sr_sal.pc = ADDR_BITS_REMOVE (frame_pc_unwind (next_frame));
@


1.231
log
@	* gdbarch.sh (GET_LONGJMP_TARGET): Replace by gdbarch_get_longjmp_target.
	* infrun.c (handle_inferior_event): Likewise.
	* gdbarch.sh (GET_LONGJMP_TARGET_P): Replace by
	gdbarch_get_longjmp_target_p.
	* breakpoint.c (breakpoint_re_set): Likewise.
	* infrun.c (handle_inferior_event): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d603 1
a603 1
      if (CANNOT_STEP_BREAKPOINT)
d1169 5
a1173 5
     In earlier versions of GDB, a target with HAVE_NONSTEPPABLE_WATCHPOINTS
     would have the PC after hitting a watchpoint affected by
     DECR_PC_AFTER_BREAK.  I haven't found any target with both of these set
     in GDB history, and it seems unlikely to be correct, so
     HAVE_NONSTEPPABLE_WATCHPOINTS is not checked here.  */
d1764 2
a1765 1
  if (HAVE_NONSTEPPABLE_WATCHPOINT && STOPPED_BY_WATCHPOINT (ecs->ws))
@


1.230
log
@	* breakpoint.h (enum bpstat_what_main_action): Remove
	BPSTAT_WHAT_THROUGH_SIGTRAMP.
	* infrun.c (process_event_stop_test): Do not check for it.
@
text
@d2077 2
a2078 1
	if (!GET_LONGJMP_TARGET_P () || !GET_LONGJMP_TARGET (&jmp_buf_pc))
@


1.229
log
@	* gdbarch.sh: Add skip_permanent_breakpoint callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* infrun.c (SKIP_PERMANENT_BREAKPOINT): Remove default definition.
	(resume): Call gdbarch_skip_permanent_breakpoint instead of
	SKIP_PERMANENT_BREAKPOINT.  Inline default case.

	* hppa-hpux-tdep.c (hppa_skip_permanent_breakpoint): Make static.
	Add REGCACHE argument.  Use it instead of read/write_register.
	(hppa_hpux_init_abi): Install hppa_skip_permanent_breakpoint.

	* config/pa/tm-hppah.h: Delete file.
	* config/pa/hppa64.mt (DEPRECATED_TM_FILE): Set to tm-hppa.h.
	* config/pa/hppahpux.mt (DEPRECATED_TM_FILE): Likewise.
@
text
@a2180 9
      case BPSTAT_WHAT_THROUGH_SIGTRAMP:
        if (debug_infrun)
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_THROUGH_SIGTRAMP\n");
	/* If were waiting for a trap, hitting the step_resume_break
	   doesn't count as getting it.  */
	if (trap_expected)
	  ecs->another_trap = 1;
	break;

@


1.228
log
@	* gdbarch.sh (software_single_step): Remove "insert_breakpoints_p" and
	"sig" arguments, add "regcache" argument.
	* gdbarch.c, gdbarch.h: Regenerate.

	* infrun.c (resume): Update SOFTWARE_SINGLE_STEP call arguments.
	(handle_inferior_event): Call remove_single_step_breakpoints directly
	instead of calling SOFTWARE_SINGLE_STEP to remove breakpoints.

	* alpha-tdep.c (alpha_software_single_step): Update argument list.
	Remove handling of !insert_breakpoints_p case.
	* arm-tdep.c (arm_software_single_step): Likewise.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* spu-tdep.c (spu_software_single_step): Likewise.

	* alpha-tdep.h (alpha_software_single_step): Update prototype.
	* mips-tdep.h (mips_software_single_step): Likewise.
	* rs6000-tdep.h (rs6000_software_single_step): Likewise.
	* sparc-tdep.h (sparc_software_single_step): Likewise.
@
text
@a178 17
/* We can't step off a permanent breakpoint in the ordinary way, because we
   can't remove it.  Instead, we have to advance the PC to the next
   instruction.  This macro should expand to a pointer to a function that
   does that, or zero if we have no such function.  If we don't have a
   definition for it, we have to report an error.  */
#ifndef SKIP_PERMANENT_BREAKPOINT
#define SKIP_PERMANENT_BREAKPOINT (default_skip_permanent_breakpoint)
static void
default_skip_permanent_breakpoint (void)
{
  error (_("\
The program is stopped at a permanent breakpoint, but GDB does not know\n\
how to step past a permanent breakpoint on this architecture.  Try using\n\
a command like `return' or `jump' to continue execution."));
}
#endif

d529 9
a537 1
    SKIP_PERMANENT_BREAKPOINT ();
@


1.227
log
@	* infrun.c: Doc fixes.
	(handle_inferior_event): Clarify debug message.
	(insert_step_resume_breakpoint_at_sal): Print a debug message.
@
text
@d551 1
a551 1
      if (SOFTWARE_SINGLE_STEP (sig, 1 /*insert-breakpoints */ ))
d1574 1
a1574 1
	  (void) SOFTWARE_SINGLE_STEP (0, 0);
d1683 1
a1683 1
	      (void) SOFTWARE_SINGLE_STEP (0, 0);
d1754 1
a1754 1
      (void) SOFTWARE_SINGLE_STEP (0, 0);
@


1.226
log
@2007-04-12  Luis Machado  <luisgpm@@br.ibm.com>

	* gdbarch.sh (software_single_step): Change the return type
	from void to int and reformatted some comments to <= 80
	columns.
	* gdbarch.c, gdbarch.h: Regenerated.
	* alpha-tdep.c (alpha_software_single_step): Likewise.
	* alpha-tdep.h (alpha_software_single_step): Likewise.
	* arm-tdep.c (arm_software_single_step): Likewise.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* mips-tdep.h (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* rs6000-tdep.h (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* sparc-tdep.h (sparc_software_single_step): Likewise.
	* spu-tdep.c (spu_software_single_step): Likewise.
	* infrun.c (resume): Check the return value from SOFTWARE_SINGLE_STEP
	and act accordingly.
@
text
@d2025 1
d2342 2
a2343 1
	 fprintf_unfiltered (gdb_stdlog, "infrun: step-resume breakpoint\n");
d2790 1
a2790 1
/* Insert a "step resume breakpoint" at SR_SAL with frame ID SR_ID.
d2801 6
d2813 1
a2813 1
/* Insert a "step resume breakpoint" at RETURN_FRAME.pc.  This is used
@


1.225
log
@2007-03-29  Denis Pilat  <denis.pilat@@st.com>

	* stack.c (print_stack_frame): Always use LOC_AND_ADDRESS in MI output.
	* infrun.c (normal_stop): Remove MI specific frame printing treatment.
@
text
@d551 10
a560 8
      SOFTWARE_SINGLE_STEP (sig, 1 /*insert-breakpoints */ );
      /* ...and don't ask hardware to do it.  */
      step = 0;
      /* and do not pull these breakpoints until after a `wait' in
         `wait_for_inferior' */
      singlestep_breakpoints_inserted_p = 1;
      singlestep_ptid = inferior_ptid;
      singlestep_pc = read_pc ();
d1383 1
a1383 1
      singlestep_breakpoints_inserted_p = 0;	/*SOFTWARE_SINGLE_STEP_P() */
d1403 1
a1403 1
      singlestep_breakpoints_inserted_p = 0;	/*SOFTWARE_SINGLE_STEP_P() */
d1574 1
a1574 1
	  SOFTWARE_SINGLE_STEP (0, 0);
d1683 1
a1683 1
	      SOFTWARE_SINGLE_STEP (0, 0);
d1754 1
a1754 1
      SOFTWARE_SINGLE_STEP (0, 0);
@


1.225.2.1
log
@Daniel Jacobowitz' update to Michael Snyder's reverse debugging patches
@
text
@d902 1
a902 3
  SIGNAL_RECEIVED,
  /* Reverse execution -- target ran out of history info.  */
  NO_HISTORY
a1519 6
    case TARGET_WAITKIND_NO_HISTORY:
      /* Reverse execution: target ran out of history info.  */
      print_stop_reason (NO_HISTORY, 0);
      stop_stepping (ecs);
      return;

a2184 11
	if (stop_pc == ecs->stop_func_start &&
	    target_get_execution_direction () == EXEC_REVERSE)
	  {
	    /* We are stepping over a function call in reverse, and
	       just hit the step-resume breakpoint at the start
	       address of the function.  Go back to single-stepping,
	       which should take us back to the function call.  */
	    ecs->another_trap = 1;
	    keep_going (ecs);
	    return;
	  }
d2368 1
a2368 16

      /* When stepping backward, stop at beginning of line range
	 (unles it's the function entry point, in which case
	 keep going back to the call point).  */
      if (stop_pc == step_range_start &&
	  stop_pc != ecs->stop_func_start &&
	  target_get_execution_direction () == EXEC_REVERSE)
	{
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	}
      else
	{
	  keep_going (ecs);
	}
d2457 4
a2460 25
	  /* We're doing a "next".

	     Normal (forward) execution: set a breakpoint at the
	     callee's return address (the address at which the caller
	     will resume).

	     Reverse (backward) execution.  set the step-resume
	     breakpoint at the start of the function that we just
	     stepped into (backwards), and continue to there.  When we
	     get there, we'll need to single-step back to the
	     caller.  */

	  if (target_get_execution_direction () == EXEC_REVERSE)
	    {
	      /* FIXME: I'm not sure if we've handled the frame for
		 recursion.  */

	      struct symtab_and_line sr_sal;
	      init_sal (&sr_sal);
	      sr_sal.pc = ecs->stop_func_start;
	      insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
	    }
	  else
	    insert_step_resume_breakpoint_at_caller (get_current_frame ());

d2521 3
a2523 16
      if (target_get_execution_direction () == EXEC_REVERSE)
	{
	  /* Set a breakpoint at callee's start address.
	     From there we can step once and be back in the caller.  */
	  /* FIXME: I'm not sure we've handled the frame for recursion.  */
	  struct symtab_and_line sr_sal;
	  init_sal (&sr_sal);
	  sr_sal.pc = ecs->stop_func_start;
	  insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
	}
      else
	{
	  /* Set a breakpoint at callee's return address (the address
	     at which the caller will resume).  */
	  insert_step_resume_breakpoint_at_caller (get_current_frame ());
	}
d2652 11
a2662 32
      if (target_get_execution_direction () != EXEC_REVERSE)
	{
	  /* If this is the last line of the function, don't keep
	     stepping (it would probably step us out of the function).
	     This is particularly necessary for a one-line function,
	     in which after skipping the prologue we better stop even
	     though we will be in mid-line.  */
	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog,
				"infrun: stepped to a different function\n");
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}
      else
	{
	  /* If we stepped backward into the last line of a function,
	     then we've presumably stepped thru a return.  We want to
	     keep stepping backward until we reach the beginning of
	     the new line.  */
	  step_range_start = ecs->sal.pc;
	  step_range_end = ecs->sal.end;
	  step_frame_id = get_frame_id (get_current_frame ());
	  ecs->current_line = ecs->sal.line;
	  ecs->current_symtab = ecs->sal.symtab;
	  /* Adjust for prologue, in case of a one-line function.  */
	  if (in_prologue (step_range_start, ecs->stop_func_start))
	    step_range_start = SKIP_PROLOGUE (step_range_start);
	  keep_going (ecs);
	  return;
	}
a2724 22
  if (target_get_execution_direction () == EXEC_REVERSE)
    {
      ecs->sal = find_pc_line (stop_pc, 0);

      /* OK, we're just gonna keep stepping here.  */
      if (ecs->sal.pc == stop_pc)
	{
	  /* We're there already.  Just stop stepping now.  */
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}
      /* Else just reset the step range and keep going.
	 No step-resume breakpoint, they don't work for
	 epilogues, which can have multiple entry paths.  */
      step_range_start = ecs->sal.pc;
      step_range_end   = ecs->sal.end;
      keep_going (ecs);
      return;
    }
  /* else... */
a3044 4
    case NO_HISTORY:
      /* Reverse execution: target ran out of history info.  */
      ui_out_text (uiout, "\nNo more reverse-execution history.\n");
      break;
a3677 1
  current_target.to_doing_call (1);
a3725 2
  current_target.to_doing_call (0);

a3772 1
  warning (_("Discarding inferior status"));
@


1.224
log
@	* arch-utils.c (legacy_pc_in_sigtramp): Remove.
	* arch-utils.h (legacy_pc_in_sigtramp): Remove.

	* config/ia64/linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/ia64/tm-linux.h: Remove file.
	* ia64-tdep.h (struct gdbarch_tdep): Add pc_in_sigtramp callback.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Use it instead of
	legacy_pc_in_sigtramp.
	(ia64_gdbarch_init): Initialize tdep->pc_in_sigtramp.
	* ia64-linux-tdep.c (ia64_linux_pc_in_sigtramp): Make static.
	Remove func_name argument.
	(ia64_linux_init_abi): Install it as tdep->pc_in_sigtramp.

	* infrun.c (HAVE_STEPPABLE_WATCHPOINT): Do not redefine.
	* target.c (update_current_target): Add to_have_steppable_watchpoint.
	* target.h (struct target_ops):  Add to_have_steppable_watchpoint.
	(HAVE_STEPPABLE_WATCHPOINT): Define.

	* config/ia64/linux.mh (NATDEPFILES): Remove core-aout.o.
	* config/ia64/nm-linux.h (KERNEL_U_ADDR, U_REGS_OFFSET,
	CANNOT_FETCH_REGISTER, CANNOT_STORE_REGISTER,
	TARGET_CAN_USE_HARDWARE_WATCHPOINT, HAVE_STEPPABLE_WATCHPOINT,
	STOPPED_BY_WATCHPOINT, target_stopped_data_address,
	target_insert_watchpoint, target_remove_watchpoint): Remove.
	(FETCH_INFERIOR_REGISTERS): Define.
	* ia64-linux-nat.c (ia64_register_addr): Make static.
	(ia64_cannot_fetch_register, ia64_cannot_store_register): Likewise.
	(ia64_linux_insert_watchpoint): Make static.  Remove ptid_p argument.
	(ia64_linux_remove_watchpoint): Likewise.  Add type argument.
	(ia64_linux_stopped_data_address): Make static.  Add target_ops.
	(ia64_linux_stopped_by_watchpoint): Make static.
	(ia64_linux_can_use_hw_breakpoint): New function.
	(ia64_linux_fetch_register, ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register, ia64_linux_store_registers): Likewise.
	(_initialize_ia64_linux_nat): Install register and watchpoint ops.
@
text
@a3195 4
	  /* For mi, have the same behavior every time we stop:
	     print everything but the source line. */
	  if (ui_out_is_mi_like_p (uiout))
	    source_flag = LOC_AND_ADDRESS;
@


1.223
log
@	* infrun.c (breakpoints_failed): Remove unnecessary variable.
	(handle_inferior_event): Remove unnecessary braces.
	* breakpoint.c (bpstat_what): Remove wrong comment.
@
text
@a199 7
#ifndef HAVE_STEPPABLE_WATCHPOINT
#define HAVE_STEPPABLE_WATCHPOINT 0
#else
#undef  HAVE_STEPPABLE_WATCHPOINT
#define HAVE_STEPPABLE_WATCHPOINT 1
#endif

@


1.222
log
@	* frame.c (frame_pop, frame_observer_target_changed): Call
	reinit_frame_cache.
	(flush_cached_frames): Rename to reinit_frame_cache and delete
	old implementation.
	* frame.h (flush_cached_frames): Delete prototype and update comment.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Call
	reinit_frame_cache instead of flush_cached_frames.  Do not call
	select_frame after reinit_frame_cache.
	* corelow.c (core_open): Likewise.
	* gdbarch.sh (deprecated_current_gdbarch_select_hack): Likewise.
	* infrun.c (prepare_to_proceed, context_switch)
	(handle_inferior_event): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* ocd.c (ocd_start_remote): Likewise.
	* remote-e7000.c (e7000_start_remote): Likewise.
	* remote-mips.c (device): Likewise.
	* thread.c (switch_to_thread): Likewise.
	* tracepoint.c (finish_tfind_command): Likewise.
	* gdbarch.c: Regenerated.
@
text
@a290 4
/* Nonzero if program stopped due to error trying to insert breakpoints.  */

static int breakpoints_failed;

a1828 1
  breakpoints_failed = 0;
d2124 1
a2124 3
	  {
	    remove_breakpoints ();
	  }
d2905 3
a2907 2
	  breakpoints_failed = insert_breakpoints ();
	  if (breakpoints_failed)
@


1.221
log
@	* frame.c (deprecated_selected_frame): Rename to...
	(selected_frame): ...this.  Make static.
	(get_selected_frame, select_frame): Update.
	* frame.h (deprected_select_frame): Delete.
	(deprecated_safe_get_selected_frame): Update comments.

	* breakpoint.c, cli/cli-cmds.c, f-valprint.c, infcmd.c, inflow.c,
	infrun.c, stack.c, tui/tui-disasm.c, tui/tui-source.c,
	tui/tui-winsource.c, valops.c, varobj.c, findvar.c, macroscope.c,
	parse.c, regcache.h, sh64-tdep.c, tui/tui-hooks.c, tui/tui-win.c,
	tui/tui.c: Replace references to deprecated_selected_frame.
@
text
@d689 1
a689 1
	  flush_cached_frames ();
a691 1
	  select_frame (get_current_frame ());
d1159 1
a1159 1
  flush_cached_frames ();
d1306 1
a1306 1
  flush_cached_frames ();
d1431 1
a1431 1
	  flush_cached_frames ();
d1492 1
a1492 1
	  flush_cached_frames ();
@


1.220
log
@	* infrun.c (inferior_stop_reason, print_stop_reason): Remove
	BREAKPOINT_HIT and STOP_UNKNOWN.
@
text
@d3176 1
a3176 1
      if (stop_print_frame && deprecated_selected_frame)
d3695 1
a3695 1
  inf_status->selected_frame_id = get_frame_id (deprecated_selected_frame);
@


1.219
log
@	* infrun.c (singlestep_pc): New variable.
	(resume): Set singlestep_pc.
	(context_switch): Add a debugging message.  Flush the frame cache.
	(handle_inferior_event): Add debugging messages.  Handle thread
	hops when a software single step has completed.  Let context_switch
	handle flushing the frame cache.
@
text
@a906 2
  /* We don't know why. */
  STOP_UNKNOWN,
a908 2
  /* Found breakpoint. */
  BREAKPOINT_HIT,
a2984 4
    case STOP_UNKNOWN:
      /* We don't deal with these cases from handle_inferior_event()
         yet. */
      break;
a2995 4
    case BREAKPOINT_HIT:
      /* We found a breakpoint. */
      /* For now print nothing. */
      break;
@


1.218
log
@Copyright updates for 2007.
@
text
@d472 3
d569 1
d1133 8
d1164 1
d1625 8
d1641 40
a1680 3
	      thread_hop_needed = 1;
	      stepping_past_singlestep_breakpoint = 1;
	      saved_singlestep_ptid = singlestep_ptid;
a1762 2

      flush_cached_frames ();
@


1.217
log
@	* infrun.c (handle_inferior_event): Don't call
	ENSURE_VFORKING_PARENT_REMAINS_STOPPED.
	* target.h (ENSURE_VFORKING_PARENT_REMAINS_STOPPED): Delete.
	(RESUME_EXECD_VFORKING_CHILD_TO_GET_PARENT_VFORK): Delete.
@
text
@d4 2
a5 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006
@


1.216
log
@	* inferior.h (start_remote): Update prototype.
	* infrun.c (start_remote): Take FROM_TTY.  Call
	post_create_inferior.
	* monitor.c (monitor_open): Update call to start_remote.
	* remote-sds.c (sds_start_remote, sds_open): Likewise.
	* remote.c (remote_start_remote): Likewise.
	(remote_start_remote_dummy): Removed.
	(remote_open): Update call to remote_start_remote.  Do not call
	post_create_inferior here.
@
text
@a1456 3
	  if (pending_follow.kind == TARGET_WAITKIND_VFORKED)
	    ENSURE_VFORKING_PARENT_REMAINS_STOPPED (pending_follow.fork_event.
						    parent_pid);
@


1.215
log
@	PR threads/2149
	* infrun.c (handle_inferior_event): Context switch after fork
	and exec events.
@
text
@d5 3
a7 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free
   Software Foundation, Inc.
d836 1
a836 1
start_remote (void)
d858 6
@


1.214
log
@	* infrun.c (handle_inferior_event): Check the current frame ID
	before unwinding to the previous frame.
@
text
@d1414 6
d1478 6
@


1.213
log
@* infrun.c (handle_inferior_event): Typo.
@
text
@d2371 4
a2374 1
  /* Check for subroutine calls.
d2379 2
a2380 1
  if (frame_id_eq (frame_unwind_id (get_current_frame ()), step_frame_id))
@


1.212
log
@	* infrun.c (handle_inferior_event): Fixed typos in printf.
@
text
@d1431 1
a1431 1
        fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_EXECED\n");
@


1.211
log
@	* infrun.c (insert_step_resume_breakpoint_at_caller): New function,
	based on insert_step_resume_breakpoint_at_frame.
	(handle_inferior_event): Update comments.  Use
	insert_step_resume_breakpoint_at_caller.
	(insert_step_resume_breakpoint_at_frame): Revise comments.
@
text
@d2025 1
a2025 1
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTATE_WHAT_SET_LONGJMP_RESUME\n");
d2050 1
a2050 1
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTATE_WHAT_CLEAR_LONGJMP_RESUME\n");
d2061 1
a2061 1
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTATE_WHAT_SINGLE\n");
d2074 1
a2074 1
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTATE_WHAT_STOP_NOISY\n");
d2085 1
a2085 1
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTATE_WHAT_STOP_SILENT\n");
d2113 1
a2113 1
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTATE_WHAT_STEP_RESUME\n");
d2137 1
a2137 1
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTATE_WHAT_THROUGH_SIGTRAMP\n");
d2148 1
a2148 1
	    fprintf_unfiltered (gdb_stdlog, "infrun: BPSTATE_WHAT_CHECK_SHLIBS\n");
@


1.210
log
@	* frame.h (set_current_sal_from_frame): New prototype.
	* stack.c (set_current_sal_from_frame): Make global.
	* infrun.c (normal_stop): Call set_current_sal_from_frame.
@
text
@d946 1
d2371 5
a2377 1
      /* It's a subroutine call.  */
d2404 1
a2404 1
	  insert_step_resume_breakpoint_at_frame (get_prev_frame (get_current_frame ()));
d2467 1
a2467 1
      insert_step_resume_breakpoint_at_frame (get_prev_frame (get_current_frame ()));
d2521 5
a2525 2
         function.  */
      if (step_stop_if_no_debug)
d2539 1
a2539 1
	  insert_step_resume_breakpoint_at_frame (get_prev_frame (get_current_frame ()));
d2746 1
a2746 1
				      
d2748 5
a2752 12
   to skip a function (next, skip-no-debug) or signal.  It's assumed
   that the function/signal handler being skipped eventually returns
   to the breakpoint inserted at RETURN_FRAME.pc.

   For the skip-function case, the function may have been reached by
   either single stepping a call / return / signal-return instruction,
   or by hitting a breakpoint.  In all cases, the RETURN_FRAME belongs
   to the skip-function's caller.

   For the signals case, this is called with the interrupted
   function's frame.  The signal handler, when it returns, will resume
   the interrupted function at RETURN_FRAME.pc.  */
d2767 32
@


1.210.8.1
log
@	* infrun.c (insert_step_resume_breakpoint_at_caller): New function,
	based on insert_step_resume_breakpoint_at_frame.
	(handle_inferior_event): Update comments.  Use
	insert_step_resume_breakpoint_at_caller.
	(insert_step_resume_breakpoint_at_frame): Revise comments.
@
text
@a945 1
static void insert_step_resume_breakpoint_at_caller (struct frame_info *);
a2369 5
  /* Check for subroutine calls.

     NOTE: frame_id_eq will never report two invalid frame IDs as
     being equal, so to get into this block, both the current and
     previous frame must have valid frame IDs.  */
d2372 1
d2399 1
a2399 1
	  insert_step_resume_breakpoint_at_caller (get_current_frame ());
d2462 1
a2462 1
      insert_step_resume_breakpoint_at_caller (get_current_frame ());
d2516 2
a2517 5
         function - unless the user has asked us not to (via
         set step-mode) or we no longer know how to get back
         to the call site.  */
      if (step_stop_if_no_debug
	  || !frame_id_p (frame_unwind_id (get_current_frame ())))
d2531 1
a2531 1
	  insert_step_resume_breakpoint_at_caller (get_current_frame ());
d2738 1
a2738 1

d2740 12
a2751 5
   to skip a potential signal handler.

   This is called with the interrupted function's frame.  The signal
   handler, when it returns, will resume the interrupted function at
   RETURN_FRAME.pc.  */
a2765 32
/* Similar to insert_step_resume_breakpoint_at_frame, except
   but a breakpoint at the previous frame's PC.  This is used to
   skip a function after stepping into it (for "next" or if the called
   function has no debugging information).

   The current function has almost always been reached by single
   stepping a call or return instruction.  NEXT_FRAME belongs to the
   current function, and the breakpoint will be set at the caller's
   resume address.

   This is a separate function rather than reusing
   insert_step_resume_breakpoint_at_frame in order to avoid
   get_prev_frame, which may stop prematurely (see the implementation
   of frame_unwind_id for an example).  */

static void
insert_step_resume_breakpoint_at_caller (struct frame_info *next_frame)
{
  struct symtab_and_line sr_sal;

  /* We shouldn't have gotten here if we don't know where the call site
     is.  */
  gdb_assert (frame_id_p (frame_unwind_id (next_frame)));

  init_sal (&sr_sal);		/* initialize to zeros */

  sr_sal.pc = ADDR_BITS_REMOVE (frame_pc_unwind (next_frame));
  sr_sal.section = find_pc_overlay (sr_sal.pc);

  insert_step_resume_breakpoint_at_sal (sr_sal, frame_unwind_id (next_frame));
}

@


1.210.6.1
log
@2006-05-13    Changes based on Apple GDB (CVS repository 5th Sept 2005)

	* async-nat-inferior.c, async-nat-inferior.h,
	* async-nat-sigthread.c, async-nat-sigthread.h: New files

	* linux-nat.c: Include async-nat-inferior.h.
	(linux_nat_wait): Add extra argument.  If target_can_async_p
	do something completely different.

	* interps.h (interp_set, interp_set_quiet): New externs.

	* interps.c (interp_set): Make asynchronous.
	(interp_set_quiet): Don't make static.
	(current_interp_command_loop): Call functions with new arguments.

	* target.h (target_wait): Add extra argument.
	(gdb_override_async, gdb_set_async_override) New externs.
	(target_can_async_p): Make conditional on gdb_override_async.

	* target.c (gdb_override_async): New variable.
	(gdb_set_async_override, do_restore_target_async_mask):
	New functions.
	(debug_to_wait): Add extra argument.

	* linux-thread-db.c (thread_db_wait): Add extra argument.

	* wrapper.h (safe_execute_command): Declare structure.

	* top.c (*deprecated_target_wait_hook): Add extra argument.
	(read_command_file): Make asynchronous.

	* remote.c (remote_wait, remote_async_wait): Add extra argument.

	* infrun.c: Include event-top.h
	(wait_for_inferior, fetch_inferior_event): Add extra argument to
	target_wait.
	(proceed): Set target_executing = 0.
	(handle_inferior_event): Call async_disable_stdin if async.

	* inf-ptrace.c: Include inf-loop.h, async-nat-inferior.h.
	(inf_ptrace_him): Create a signal thread.
	(inf_ptrace_wait): Add extra argument to target_wait.

	* inf-loop.c (inferior_event_handler, complete_execution):
	Changes for asynchronous operation (copied verbatim).

	* inf-child.c: Include async-nat-inferior.h.
	(inf_child_target): Use methods async_terminal_inferior
	and async_terminal_ours.

	* i386-linux-nat.c: Include inf-loop.h, async-nat-inferior.h.
	(i386_linux_resume): Call gdb_process_events and then
	async methods.

	* exec.c: Include event-loop.h, async-nat-inferior.h.
	(async_file_handler, standard_async, standard_is_async_p)
	(standard_can_async_p): New functions.
	(init_exec_ops): Initialise above methods.

	* event-top.h (cli_command_loop): Make argument void*.

	* event-top.c (display_gdb_prompt, async_enable_stdin)
	(async_disable_stdin, handle_sigint, async_request_quit)
	(gdb_setup_readline, _initialize_event_loop):
	Changes for asynchronous operation (copied verbatim).
	(cli_command_loop): Make argument void*.

	* event-loop.h (gdb_client_data): Move typedef to defs.h.
	(gdb_create_event): Declare.
	(event_handler_func): Move typedef from event-loop.c.

	* event-loop.c (use_poll): Set to 0.
	(gdb_queue_event, gdb_create_event): New functions.
	(async_queue_event): Don't make static.
	(create_file_event): Use gdb_create_event.
	(gdb_event): Change component from int to void*.
	(process_event, handle_file_event, handle_timer_event):
	Change according to gdb_event.
	(event_handler_func): Move typedef to event-loop.c.

	* defs.h: (gdb_mi_run_status, event_loop_p): New externs.
	(gdb_client_data): Move typedef from event-loop.h.
	(*deprecated_command_loop_hook): Make argument void*.
	(*deprecated_target_wait_hook): Add argument.

	* cli-out.h (cli_quoted_out_new): Declare.

	* cli-out.c (cli_quoted_out_new): New function.
	Include mi/mi-console.h.

	* cli/cli-interp.c: Include inferior.h, mi/mi-console.h.
	(safe_execute_command): Make static.
	(cli_interpreter_resume, cli_interpreter_exec):
	Make asynchronous.
	(cli_quoted_interpreter_resume): New function.
	(_initialize_cli_interp): Add li_command_loop to procs.
	Initialize the console-quoted interpreter.

	* tui/tui-hooks.c (tui_target_wait_hook): Add extra argument.

	* mi/mi-main.h (mi_dont_register_continuation)
	(current_command_token,  mi_interp, mi_interpreter_exec_continuation)
	(mi_continuation_arg): New externs.
	(mi_setup_continuation_arg): Declare.

	* mi/mi-main.c: Include wrapper.h.
	(struct mi_continuation_arg): New structure.
	(mi_interpreter_exec_continuation): Move to mi-interp.c.
	(mi_execute_async_cli_command)
	(mi_exec_async_cli_cmd_continuation): Make asynchronous.
	(mi_setup_continuation_arg): New function.

	* mi/mi-interp.c (mi_interpreter_exec_continuation):
	Move from mi-main.c
	(mi_cmd_interpreter_exec): Switch interpreters.  Make
	asynchronous.
	(mi1_command_loop, mi2_command_loop, mi3_command_loop):
	Make argument void*.

	* Makefile.in (async_nat_inferior_h, async_nat_sigthread_h):
	New variables.
	(gdb$(EXEEXT), $(TUI)$(EXEEXT)): Link with libpthread.
	(async-nat-inferior.o, async-nat-sigthread.o): New rules.
	(COMMON_OBS): Add above object files.
	(exec.o, i386-linux-nat.o, inf-ptrace.o, linux-nat.o):
	Update dependencies.

2006-05-13  Nick Roberts  <nickrob@@snap.net.nz>

	* main.c: (event_loop_p): Re-instate variable.
	(captured_main): Re-instate async/noasync option.
	(print_gdb_help): Describe option again.

	* exec.c(init_exec_ops): Only initialise async methods with async
	option.

	* inf-ptrace.c (inf_ptrace_him): Only reate a signal thread with
	async option.

	* README.async, TODO.async, PROBLEMS.async: New files.
@
text
@a43 1
#include "event-top.h"
d103 1
a103 1
int sync_execution = 1;
a827 2
      /* Why doesn't normal_stop set target_executing to 0?  */
      target_executing = 0;
d996 1
a996 2
	ecs->ptid =
	  deprecated_target_wait_hook (ecs->waiton_ptid, ecs->wp, NULL);
d998 1
a998 1
	ecs->ptid = target_wait (ecs->waiton_ptid, ecs->wp, NULL);
d1052 1
a1052 1
      deprecated_target_wait_hook (async_ecs->waiton_ptid, async_ecs->wp, client_data);
d1054 1
a1054 2
    async_ecs->ptid =
      target_wait (async_ecs->waiton_ptid, async_ecs->wp, client_data);
d2146 1
a2146 4
	  int was_sync_execution = 0;
	  int solib_changed = 0;

	  if (debug_infrun)
a2158 4
	  /*  Also, the error handlers for breakpoint_re_set may have
	      run async_enable_stdin, which is not appropriate in this
	      case.  Run it again just in case...  */
	  was_sync_execution = sync_execution;
a2179 2
	  if (was_sync_execution && !sync_execution)
	    async_disable_stdin();
@


1.210.6.2
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a948 1
static void insert_step_resume_breakpoint_at_caller (struct frame_info *);
d1435 1
a1435 1
        fprintf_unfiltered (gdb_stdlog, "infrun: TARGET_WAITKIND_EXECD\n");
d2029 1
a2029 1
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_SET_LONGJMP_RESUME\n");
d2054 1
a2054 1
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_CLEAR_LONGJMP_RESUME\n");
d2065 1
a2065 1
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_SINGLE\n");
d2078 1
a2078 1
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_STOP_NOISY\n");
d2089 1
a2089 1
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_STOP_SILENT\n");
d2117 1
a2117 1
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_STEP_RESUME\n");
d2141 1
a2141 1
	  fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_THROUGH_SIGTRAMP\n");
d2155 1
a2155 1
	    fprintf_unfiltered (gdb_stdlog, "infrun: BPSTAT_WHAT_CHECK_SHLIBS\n");
d2384 1
a2384 10
  /* Check for subroutine calls.  The check for the current frame
     equalling the step ID is not necessary - the check of the
     previous frame's ID is sufficient - but it is a common case and
     cheaper than checking the previous frame's ID.

     NOTE: frame_id_eq will never report two invalid frame IDs as
     being equal, so to get into this block, both the current and
     previous frame must have valid frame IDs.  */
  if (!frame_id_eq (get_frame_id (get_current_frame ()), step_frame_id)
      && frame_id_eq (frame_unwind_id (get_current_frame ()), step_frame_id))
d2386 1
d2413 1
a2413 1
	  insert_step_resume_breakpoint_at_caller (get_current_frame ());
d2476 1
a2476 1
      insert_step_resume_breakpoint_at_caller (get_current_frame ());
d2530 2
a2531 5
         function - unless the user has asked us not to (via
         set step-mode) or we no longer know how to get back
         to the call site.  */
      if (step_stop_if_no_debug
	  || !frame_id_p (frame_unwind_id (get_current_frame ())))
d2545 1
a2545 1
	  insert_step_resume_breakpoint_at_caller (get_current_frame ());
d2752 1
a2752 1

d2754 12
a2765 5
   to skip a potential signal handler.

   This is called with the interrupted function's frame.  The signal
   handler, when it returns, will resume the interrupted function at
   RETURN_FRAME.pc.  */
a2779 32
/* Similar to insert_step_resume_breakpoint_at_frame, except
   but a breakpoint at the previous frame's PC.  This is used to
   skip a function after stepping into it (for "next" or if the called
   function has no debugging information).

   The current function has almost always been reached by single
   stepping a call or return instruction.  NEXT_FRAME belongs to the
   current function, and the breakpoint will be set at the caller's
   resume address.

   This is a separate function rather than reusing
   insert_step_resume_breakpoint_at_frame in order to avoid
   get_prev_frame, which may stop prematurely (see the implementation
   of frame_unwind_id for an example).  */

static void
insert_step_resume_breakpoint_at_caller (struct frame_info *next_frame)
{
  struct symtab_and_line sr_sal;

  /* We shouldn't have gotten here if we don't know where the call site
     is.  */
  gdb_assert (frame_id_p (frame_unwind_id (next_frame)));

  init_sal (&sr_sal);		/* initialize to zeros */

  sr_sal.pc = ADDR_BITS_REMOVE (frame_pc_unwind (next_frame));
  sr_sal.section = find_pc_overlay (sr_sal.pc);

  insert_step_resume_breakpoint_at_sal (sr_sal, frame_unwind_id (next_frame));
}

@


1.210.6.3
log
@(handle_inferior_event): Take terminal.
@
text
@a1695 7
      if (ui_out_is_mi_like_p (uiout))
	{
	  target_terminal_ours_for_output ();
	  printf_filtered ("[Switching to %s]\n",
			   target_pid_or_tid_to_str (inferior_ptid));
	}

@


1.210.4.1
log
@2006-05-02  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.h (breakpoint_silence): Export.
	* breakpoint.c (breakpoint_silence): New function.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.
	* infrun.c (enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.
@
text
@d5 2
a6 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006
   Free Software Foundation, Inc.
d908 1
a908 3
  SIGNAL_RECEIVED,
  /* Reverse execution -- target ran out of history info.  */
  NO_HISTORY
a1506 6
    case TARGET_WAITKIND_NO_HISTORY:
      /* Reverse execution: target ran out of history info.  */
      print_stop_reason (NO_HISTORY, 0);
      stop_stepping (ecs);
      return;

a2131 11
	if (stop_pc == ecs->stop_func_start
	    && target_get_execdir () == EXEC_REVERSE)
	  {
	    /* We are stepping over a function call in reverse, and
	       just hit the step-resume breakpoint at the start
	       address of the function.  Go back to single-stepping,
	       which should take us back to the function call.  */
	    ecs->another_trap = 1;
	    keep_going (ecs);
	    return;
	  }
d2315 1
a2315 16

      /* When stepping backward, stop at beginning of line range
	 (unles it's the function entry point, in which case 
	 keep going back to the call point).  */
      if (stop_pc == step_range_start
	  && stop_pc != ecs->stop_func_start
	  && target_get_execdir () == EXEC_REVERSE)
	{
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	}
      else
	{
	  keep_going (ecs);
	}
d2396 4
a2399 53
	  /* We're doing a "next".

	     Normal (forward) execution: set a breakpoint at the
	     callee's return address (the address at which the caller
	     will resume).

	     Reverse (backward) execution.  Set the step-resume
	     breakpoint at the start of the function that we just
	     stepped into (backwards), and continue to there.  When we
	     get there, we'll need to single-step back to the
	     caller.  */

	  if (target_get_execdir () == EXEC_REVERSE)
	    {
	      /* FIXME: I'm not sure if we've handled the frame for
		 recursion.  */

	      struct symtab_and_line sr_sal;
	    mrhappy:
	      init_sal (&sr_sal);
	      sr_sal.pc = ecs->stop_func_start;
#if 0
	      insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
#else
	      /* Let's try to find the right frame id.  
	         First try curr_frame.  */
#if 0
	      insert_step_resume_breakpoint_at_sal (sr_sal, frame_unwind_id
						    (get_current_frame ()));
#else
#if 0
	      /* Fails to stop.  Try prev_frame.  */
	      insert_step_resume_breakpoint_at_sal (sr_sal, frame_unwind_id
						    (get_prev_frame
						    (get_current_frame ())));
#else
#if 0
	      /* One last try -- try step_frame_id.  */
	      insert_step_resume_breakpoint_at_sal (sr_sal, step_frame_id);
#else
	      /* Ok, really the last try.  */
	      insert_step_resume_breakpoint_at_sal (sr_sal, get_frame_id
						    (get_current_frame ()));
#endif
#endif
#endif
#endif
	    }
	  else
	    {
	      insert_step_resume_breakpoint_at_frame
		(get_prev_frame (get_current_frame ()));
	    }
d2460 3
a2462 17
      if (target_get_execdir () == EXEC_REVERSE)
	{
	  /* Set a breakpoint at callee's start address.
	     From there we can step once and be back in the caller.  */
	  /* FIXME: I'm not sure we've handled the frame for recursion.  */
	  struct symtab_and_line sr_sal;
	  init_sal (&sr_sal);
	  sr_sal.pc = ecs->stop_func_start;
	  insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
	}
      else
	{
	  /* Set a breakpoint at callee's return address (the address
	     at which the caller will resume).  */
	  insert_step_resume_breakpoint_at_frame
	    (get_prev_frame (get_current_frame ()));
	}
d2588 11
a2598 37
      if (target_get_execdir () != EXEC_REVERSE)
	{
	  /* If this is the last line of the function, don't keep
	     stepping (it would probably step us out of the function).
	     This is particularly necessary for a one-line function,
	     in which after skipping the prologue we better stop even
	     though we will be in mid-line.  */
	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog, 
				"infrun: stepped to a different function\n");
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}
      else
	{
	  /* If we stepped backward into the last line of a function,
	     then we've presumably stepped thru a return.  We want to
	     keep stepping backward until we reach the beginning of
	     the new line.  */

	  /* KLUDGE have we missed detecting a reverse-next?  */
	  if (step_over_calls == STEP_OVER_ALL)
	    goto mrhappy;	/* AHHHH!  FIXME!  */

	  step_range_start = ecs->sal.pc;
	  step_range_end = ecs->sal.end;
	  step_frame_id = get_frame_id (get_current_frame ());
	  ecs->current_line = ecs->sal.line;
	  ecs->current_symtab = ecs->sal.symtab;
	  /* Adjust for prologue, in case of a one-line function.  */
	  if (in_prologue (step_range_start, ecs->stop_func_start))
	    step_range_start = SKIP_PROLOGUE (step_range_start);
	  keep_going (ecs);
	  return;
	}
a2660 22
  if (target_get_execdir () == EXEC_REVERSE)
    {
      ecs->sal = find_pc_line (stop_pc, 0);

      /* OK, we're just gonna keep stepping here.  */
      if (ecs->sal.pc == stop_pc)
	{
	  /* We're there already.  Just stop stepping now.  */
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}
      /* Else just reset the step range and keep going.
	 No step-resume breakpoint, they don't work for
	 epilogues, which can have multiple entry paths.  */
      step_range_start = ecs->sal.pc;
      step_range_end   = ecs->sal.end;
      keep_going (ecs);
      return;
    }
  /* else... */
a2962 4
    case NO_HISTORY:
      /* Reverse execution: target ran out of history info.  */
      ui_out_text (uiout, _("\nNo more reverse-execution history.\n"));
      break;
@


1.209
log
@2006-01-04  Michael Snyder  <msnyder@@redhat.com>

	Checkpoint/Restart for Linux.
	* linux-nat.c: Add support for debugging multiple forks.
	Add #include for linux-fork.h (interface spec).
	(super_mourn_inferior): New function pointer.
	(child_mourn_inferior): New function / target method.
	(linux_target): Claim to_mourn_inferior method pointer.
	(child_follow_fork): Call interface to linux-fork, conditionally
	add new fork processes to list of debugged processes.
	(kill_inferior): Use interface to linux-fork to kill
	multiple processes.

	* linux-fork.h: New file.
	* linux-fork.c: New file.  Support for debugging multiple forks
	of the same program.  Support for checkpoint and restart commands.

	* infrun.c (nullify_last_target_wait_ptid): New function.

	* Makefile.in: Add linux-fork.
	* config/*/linux.mh: Add linux-fork.
	* NEWS: Mention new functionality.
@
text
@d3047 6
@


1.209.2.1
log
@Merge XML and VFP support to this branch.
@
text
@d3593 1
a3593 1
  inf_status->selected_frame_id = get_frame_id (get_selected_frame (NULL));
@


1.209.2.1.2.1
log
@Add experimental support for SymbianOS-related protocol features.
@
text
@a879 2

  target_last_wait_ptid = minus_one_ptid;
d945 1
a945 1
static void insert_step_resume_breakpoint_at_frame (struct frame_info *, int);
d1317 1
a1319 2
	  int breakpoints_were_inserted;

a1321 1
	  breakpoints_were_inserted = breakpoints_inserted;
a1323 1
	  breakpoints_inserted = 0;
a1344 1
#ifdef SOLIB_ADD
a1345 3
#else
	  solib_add (NULL, 0, &current_target, auto_solib_add);
#endif
a1347 17
	  /* Try to reenable shared library breakpoints, additional
	     code segments in shared libraries might be mapped in now. */
	  re_enable_breakpoints_in_shlibs ();

	  /* If requested, stop when the dynamic linker notifies
	     gdb of events.  This allows the user to get control
	     and place breakpoints in initializer routines for
	     dynamically loaded objects (among other things).  */
	  if (stop_on_solib_events || stop_stack_dummy)
	    {
	      stop_stepping (ecs);
	      return;
	    }

	  /* NOTE drow/2006-03-14: This might be a good place to check
	     for "catch load".  */

d1349 2
a1350 5
	  if (breakpoints_were_inserted)
	    {
	      insert_breakpoints ();
	      breakpoints_inserted = 1;
	    }
d1352 4
a1355 15

      /* NOTE drow/2006-03-28: For the reason described before the
	 previous if statement, GDB used to automatically resume
	 here.  But that's only true if a shell is running; if
	 we've just attached to a process, then that's a whole
	 different case - it might have been stopped at a load
	 event.  */
      if (inferior_ignoring_startup_exec_events || stop_soon == NO_STOP_QUIETLY)
	{
	  resume (0, TARGET_SIGNAL_0);
	  prepare_to_wait (ecs);
	  return;
	}
      else
	break;
d1968 1
a1968 1
	  insert_step_resume_breakpoint_at_frame (get_current_frame (), 0);
d1990 1
a1990 1
	  insert_step_resume_breakpoint_at_frame (get_current_frame (), 0);
d2399 1
a2399 1
	  insert_step_resume_breakpoint_at_frame (get_current_frame (), 1);
d2462 1
a2462 1
      insert_step_resume_breakpoint_at_frame (get_current_frame (), 1);
d2531 1
a2531 1
	  insert_step_resume_breakpoint_at_frame (get_current_frame (), 1);
d2744 4
a2747 4
   If USE_PREVIOUS is zero, RETURN_FRAME belongs to the function being
   skipped.  The function may have been reached by either single
   stepping a call / return / signal-return instruction, or by hitting
   a breakpoint.
d2754 1
a2754 2
insert_step_resume_breakpoint_at_frame (struct frame_info *return_frame,
					int use_previous)
a2759 10
  if (use_previous)
    {
      struct frame_info *caller_frame;
      caller_frame = get_prev_frame (return_frame);
      if (caller_frame == NULL)
	error (_("Could not step out of the function at 0x%lx - unwinding failed"),
	       (long) get_frame_pc (return_frame));
      return_frame = caller_frame;
    }

@


1.209.2.1.2.2
log
@        * infrun.c (handle_inferior_event): Always clear stop_stack_dummy.
        Don't check it for load events.
@
text
@a1258 3
  /* Always clear state belonging to the previous time we stopped.  */
  stop_stack_dummy = 0;

d1365 1
a1365 1
	  if (stop_on_solib_events)
d1802 1
@


1.209.4.1
log
@Add a Debian patch that prevents some bogus "No selected frame" errors.
This needs to go to mainline separately.
@
text
@d3593 1
a3593 1
  inf_status->selected_frame_id = get_frame_id (get_selected_frame (NULL));
@


1.209.6.1
log
@2006-03-31  Michael Snyder  <msnyder@@redhat.com>

	Execution interface for reverse execution.
	* breakpoint.c (breakpoint_silence): New function.
	* breakpoint.h (breakpoint_silence): Export.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.
	* infrun.c (enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.
@
text
@d908 1
a908 3
  SIGNAL_RECEIVED,
  /* Reverse execution -- target ran out of history info.  */
  NO_HISTORY
a1506 6
    case TARGET_WAITKIND_NO_HISTORY:
      /* Reverse execution: target ran out of history info.  */
      print_stop_reason (NO_HISTORY, 0);
      stop_stepping (ecs);
      return;

a2131 11
	if (stop_pc == ecs->stop_func_start &&
	    target_get_execution_direction () == EXEC_REVERSE)
	  {
	    /* We are stepping over a function call in reverse, and
	       just hit the step-resume breakpoint at the start
	       address of the function.  Go back to single-stepping,
	       which should take us back to the function call.  */
	    ecs->another_trap = 1;
	    keep_going (ecs);
	    return;
	  }
d2315 1
a2315 16

      /* When stepping backward, stop at beginning of line range
	 (unles it's the function entry point, in which case 
	 keep going back to the call point).  */
      if (stop_pc == step_range_start &&
	  stop_pc != ecs->stop_func_start &&
	  target_get_execution_direction () == EXEC_REVERSE)
	{
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	}
      else
	{
	  keep_going (ecs);
	}
d2396 4
a2399 28
	  /* We're doing a "next".

	     Normal (forward) execution: set a breakpoint at the
	     callee's return address (the address at which the caller
	     will resume).

	     Reverse (backward) execution.  set the step-resume
	     breakpoint at the start of the function that we just
	     stepped into (backwards), and continue to there.  When we
	     get there, we'll need to single-step back to the
	     caller.  */

	  /* FIXME EXEC_ERROR */
	  if (target_get_execution_direction () == EXEC_FORWARD)
	    {
	      insert_step_resume_breakpoint_at_frame
		(get_prev_frame (get_current_frame ()));
	    }
	  else
	    {
	      /* FIXME: I'm not sure if we've handled the frame for
		 recursion.  */

	      struct symtab_and_line sr_sal;
	      init_sal (&sr_sal);
	      sr_sal.pc = ecs->stop_func_start;
	      insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
	    }
d2460 3
a2462 18
      /* FIXME EXEC_ERROR */
      if (target_get_execution_direction () == EXEC_FORWARD)
	{
	  /* Set a breakpoint at callee's return address (the address
	     at which the caller will resume).  */
	  insert_step_resume_breakpoint_at_frame
	    (get_prev_frame (get_current_frame ()));
	}
      else
	{
	  /* Set a breakpoint at callee's start address.
	     From there we can step once and be back in the caller.  */
	  /* FIXME: I'm not sure we've handled the frame for recursion.  */
	  struct symtab_and_line sr_sal;
	  init_sal (&sr_sal);
	  sr_sal.pc = ecs->stop_func_start;
	  insert_step_resume_breakpoint_at_sal (sr_sal, null_frame_id);
	}
d2588 11
a2598 33
      /* FIXME EXEC_ERROR */
      if (target_get_execution_direction () == EXEC_FORWARD)
	{
	  /* If this is the last line of the function, don't keep
	     stepping (it would probably step us out of the function).
	     This is particularly necessary for a one-line function,
	     in which after skipping the prologue we better stop even
	     though we will be in mid-line.  */
	  if (debug_infrun)
	    fprintf_unfiltered (gdb_stdlog, 
				"infrun: stepped to a different function\n");
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}
      else
	{
	  /* If we stepped backward into the last line of a function,
	     then we've presumably stepped thru a return.  We want to
	     keep stepping backward until we reach the beginning of
	     the new line.  */
	  step_range_start = ecs->sal.pc;
	  step_range_end = ecs->sal.end;
	  step_frame_id = get_frame_id (get_current_frame ());
	  ecs->current_line = ecs->sal.line;
	  ecs->current_symtab = ecs->sal.symtab;
	  /* Adjust for prologue, in case of a one-line function.  */
	  if (in_prologue (step_range_start, ecs->stop_func_start))
	    step_range_start = SKIP_PROLOGUE (step_range_start);
	  keep_going (ecs);
	  return;
	}
a2660 22
  if (target_get_execution_direction () == EXEC_REVERSE)
    {
      ecs->sal = find_pc_line (stop_pc, 0);

      /* OK, we're just gonna keep stepping here.  */
      if (ecs->sal.pc == stop_pc)
	{
	  /* We're there already.  Just stop stepping now.  */
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}
      /* Else just reset the step range and keep going.
	 No step-resume breakpoint, they don't work for
	 epilogues, which can have multiple entry paths.  */
      step_range_start = ecs->sal.pc;
      step_range_end   = ecs->sal.end;
      keep_going (ecs);
      return;
    }
  /* else... */
a2962 4
    case NO_HISTORY:
      /* Reverse execution: target ran out of history info.  */
      ui_out_text (uiout, "\nNo more reverse-execution history.\n");
      break;
@


1.209.6.2
log
@2006-03-31  Michael Snyder  <msnyder@@redhat.com>

	* infrun.c: Make sure to check for EXEC_REVERSE not EXEC_FORWARD,
	since targets that don't implement execdir will return EXEC_ERROR.
@
text
@d2442 7
a2448 1
	  if (target_get_execution_direction () == EXEC_REVERSE)
a2457 5
	  else
	    {
	      insert_step_resume_breakpoint_at_frame
		(get_prev_frame (get_current_frame ()));
	    }
d2518 9
a2526 1
      if (target_get_execution_direction () == EXEC_REVERSE)
a2535 7
      else
	{
	  /* Set a breakpoint at callee's return address (the address
	     at which the caller will resume).  */
	  insert_step_resume_breakpoint_at_frame
	    (get_prev_frame (get_current_frame ()));
	}
d2661 2
a2662 1
      if (target_get_execution_direction () != EXEC_REVERSE)
@


1.208
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d1105 6
@


1.207
log
@2005-11-07  Andrew Stubbs  <andrew.stubbs@@st.com>

	* main.h (return_child_result, return_child_result_value): Declare.
	* infrun.c: Include main.h.
	(print_stop_reason): Remove declaration of return_child_result_value.
	* top.c: Include main.h.
	(quit_force): Remove declarations of return_child_result_value and
	return_child_result.
	* Makefile.in (top.o, infrun.o): Add main.h to dependencies.
@
text
@d4 1
a4 1
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.207.4.1
log
@2005-11-21  Michael Snyder  <msnyder@@redhat.com>

	* linux-nat.c: Add crude checkpoint/restart using forks.

	(child_follow_fork): Put a conditional around PTRACE_DETACH.
	FIXME needs to be done in the parent branch too.
	(__initialize_linux_nat): Call checkpoint_init.
	(struct fork_info): Analog of thread_info.
	(fork_load_infrun_state, fork_save_infrun_state):
	Save and restore necessary info for fork context switch.
	(add_fork, free_fork, delete_fork, find_fork_id, init_fork_list,
	find_fork_ptid, iterate_over_forks, valid_fork_id, pid_to_fork_id,
	fork_id_to_ptid, in_fork_list): Analogs to thread_list methods.
	(info_forks_command): Implement "info forks" (info checkpoints).
	(delete_checkpoint): Implement "delete-checkpoint" command.
	(checkpoint_command): Implement "checkpoint" command.
	(restart_command): Implement "restart" command.
	(checkpoint_init): Initialization for checkpoint sub-module.

	* infrun.c (set_last_target_status): Supporting function
	for checkpoint/restart based on forks (linux).
@
text
@a1104 7
void
set_last_target_status (ptid_t ptid, struct target_waitstatus status)
{
  target_last_wait_ptid = ptid;
  target_last_waitstatus = status;
}

@


1.207.4.2
log
@2005-11-25  Michael Snyder  <msnyder@@redhat.com>

	* infrun.c (set_last_target_status): Remove, replace with following.
	(nullify_last_target_wait_ptid): New function.  Now we don't need
	to save this bit of state in linux-nat.

	* linux-nat.c (struct fork_info): Get rid of last_target_ptid,
	last_target_waitstatus, and inferior status.
	(fork_load_infrun_state): Forget about infrun status and target
	wait ptid.  Call nullify_last_target_wait_ptid instead.
	(fork_save_infrun_state): Forget about infrun status and target
	wait ptid.
	(free_fork): Forget about infrun status.
	(detach_fork_command): Output cleanup.

	* linux-nat.c (child_follow_fork): Add verbose messages when
	detaching from parent or child (to match HPUX tests in testsuite).
@
text
@d1106 1
a1106 1
nullify_last_target_wait_ptid (void)
d1108 2
a1109 1
  target_last_wait_ptid = minus_one_ptid;
@


1.206
log
@2005-11-04  Andrew Stubbs  <andrew.stubbs@@st.com>

	* infrun.c (print_stop_reason): Set return_child_result_value on exit.
	* main.c (return_child_result): New variable.
	(return_child_result_value): Likewise.
	(captured_main): Add option --return-child-result.
	Replace call to target_detach and exit (in batch mode) with quit_force.
	(print_gdb_help): Add option --return-child-result.
	* top.c (quit_force): Return child result if appropriate.

docs/
	* gdb.texinfo (Choosing modes): Add --return-child-result.
@
text
@d49 1
d2935 2
a2936 5
      {
	/* Support the --return-child-result option.  */
	extern int return_child_result_value;
	return_child_result_value = stop_info;
      }
@


1.205
log
@	PR threads/2015
	* infrun.c (adjust_pc_after_break): Don't use the state from a
	non-matching thread context.
@
text
@d2934 5
@


1.205.4.1
log
@2005-11-14  Andrew Stubbs  <andrew.stubbs@@st.com>

	* infrun.c: Include main.h.
	(print_stop_reason): Set return_child_result_value on exit.
	* main.c (return_child_result): New variable.
	(return_child_result_value): Likewise.
	(captured_main): Add option --return-child-result.
	Replace call to target_detach and exit (in batch mode) with quit_force.
	(print_gdb_help): Add option --return-child-result.
	* top.c: Include main.h.
	(quit_force): Return child result if appropriate.
	* main.h (return_child_result, return_child_result_value): Declare.
	* Makefile.in (top.o, infrun.o): Add main.h to dependencies.

doc/
	* gdb.texinfo (Choosing modes): Add --return-child-result.
@
text
@a48 1
#include "main.h"
a2933 2
      /* Support the --return-child-result option.  */
      return_child_result_value = stop_info;
@


1.204
log
@	* infrun.c (init_execution_control_state): Initialize
	ecs->another_trap.
@
text
@d1203 6
a1208 2
         adjusting but the former does not.  */
      if (currently_stepping (ecs))
@


1.203
log
@	Suggested by Vladimir Prus <ghost@@cs.msu.su>:
	* infrun.c (handle_inferior_event): Check for line information in
	undebuggable functions.
@
text
@d1078 1
a1078 1
  /* ecs->another_trap? */
@


1.202
log
@This is a cleanup change. It is the beggining of allowing GDB/MI to be
better understood (internally).
@
text
@d2488 2
d2494 2
a2495 1
      && ecs->stop_func_name == NULL)
d2501 2
a2502 2
         undebuggable function (where there is no symbol, not even a
         minimal symbol, corresponding to the address where the
a2537 2
  ecs->sal = find_pc_line (stop_pc, 0);

@


1.202.2.1
log
@2005-05-30  Michael Snyder  <msnyder@@redhat.com>

	Add support for writing tracepoint/checkpoint data to a file.

	* breakpoint.c (bpstat_stop_status): Add hook for interpreting
	breakpoints as tracepoints, enabling gdb to handle them directly
	by a "default" fallback method (writing data to a file).

	* tracepoint.c (default_tracepoint_method): New user-settable
	mode variable -- tells gdb to use a "default" (fallback) method
	for collecting tracepoint data.
	(trace_start_command, trace_stop_command, trace_status_command):
	Add "default" mode.

	(tracepoint_event_p, default_do_tracepoints_command): New
	functions, entry points into default tracepoint collection method.

	(checkpoint_open, checkpoint_close): Open / close checkpoint file.
	(checkpoint_command): Drop a checkpoint into checkpoint file.

	(emit_checkpoint_method1, emit_checkpoint_method2,
	emit_checkpoint_method3, emit_checkpoint_method4): Experimental
	methods for writing checkpoint/tracepoint data to a file.

	(checkpoint_emit_memrange, checkpoint_emit_gregs,
	checkpoint_emit_stack, checkpoint_emit_id, etc.):
	Support functions for writing checkpoint/tracepoint data.

	(get_tracepoint_by_address): New function.
	(validate_actionline): Add "$stack" pseudo-object for collection.
	(tracepoint_top_of_stack, tracepoint_size_of_stack):
	New user-settable variables.
	(encode_actions): Interpret "$stack" pseudo-object, collect stack.

	* tracepoint.h (default_trace_method, tracepoint_event_p):
	Exported interface for default tracepoint method.
@
text
@d2065 1
a2065 1
	/* We are about to nuke the step_resume_breakpoint via the
@


1.201
log
@* solib.h (CLEAR_SOLIB, SOLIB_ADD)
(SOLIB_CREATE_INFERIOR_HOOK, SOLIB_REMOVE_INFERIOR_HOOK)
(SOLIB_IN_DYNAMIC_LINKER, SOLIB_RESTART)
(DISABLE_UNSETTABLE_BREAK, PC_SOLIB)
(IN_SOLIB_DYNSYM_RESOLVE_CODE): Remove defines and orphaned
comments.
* breakpoint.c: Include "solib.h".
(insert_bp_location) [!DISABLE_UNSETTABLE_BREAK]: Call
solib_address.
(remove_solib_event_breakpoints, create_solib_event_breakpoint)
(disable_breakpoints_in_shlibs)
(disable_breakpoints_in_unloaded_shlib)
(re_enable_breakpoints_in_shlibs): Compile if SOLIB_ADD isn't
defined. If PC_SOLIB isn't defined, call solib_address.
(_initialize_breakpoint): Unconditionally install observer.
* corelow.c: Include "solib.h".
[SOLIB_ADD] (solib_add_stub): Remove prototype.
(core_close) [!CLEAR_SOLIB]: Call clear_solib.
(solib_add_stub) [!SOLIB_ADD] Call solib_add.
(core_open): Unconditionally call solib_add_stub.
* fork-child.c: Include "solib.h".
(fork_inferior) [!SOLIB_CREATE_INFERIOR_HOOK]: Call
solib_create_inferior_hook.
* infcmd.c: Include "solib.h".
(attach_command) [!SOLIB_ADD]: Call shlib_rescan.  Unconditionally
call re_enable_breakpoints_in_shlibs.
* infrun.c: Include "solib.h".
(SOLIB_IN_SYNSYM_RESOLVE_CODE): Don't define if not already
defined.
(stop_on_solib_events, show_stop_on_solib_events): Include
unconditionally.
(follow_exec) [!SOLIB_CREATE_INFERIOR_HOOK]: Call
solib_create_inferior_hook.
(handle_inferior_event) [!SOLIB_ADD]: Call shlib_add.
[!IN_SOLIB_DYNSYM_RESOLVE_CODE]: Call in_solib_dynsym_resolve_code.
(_initialize_infrun): Unconditionally add "stop_on_solib-events"
command.
* remote.c: Include "solib.h".
(remote_open_1): Unconditionally call no_shared_libraries.
[!SOLIB_CREATE_INFERIOR_HOOK] Call solib_create_inferior_hook.
* stack.c: Include "solib.h".
(print_frame) [!PC_SOLIB] Call shlib_for_pc.
* xcoffsolib.c (no_shared_libraries): Remove function.
* Makefile.in (SFILES): Add solib.c.
(ALLDEPFILES): Remove solib.c.
(COMMON_OBS): Add solib.o.
(breakpoint.o, corelow.o, fork-chiled.o, infcmd.o, infrun.o)
(remote.o, stack.o): Update dependencies.
@
text
@d51 1
d2880 3
a2882 1
	  ui_out_field_string (uiout, "reason", "end-stepping-range");
d2892 3
a2894 1
	ui_out_field_string (uiout, "reason", "exited-signalled");
d2914 2
a2915 1
	    ui_out_field_string (uiout, "reason", "exited");
d2924 3
a2926 1
	    ui_out_field_string (uiout, "reason", "exited-normally");
d2937 2
a2938 1
	ui_out_field_string (uiout, "reason", "signal-received");
@


1.200
log
@	* infrun.c (handle_inferior_event): Update the comment about users
	of stepped_after_stopped_by_watchpoint.
@
text
@d48 2
a164 4
#ifndef IN_SOLIB_DYNSYM_RESOLVE_CODE
#define IN_SOLIB_DYNSYM_RESOLVE_CODE(pc) 0
#endif

a253 1
#ifdef SOLIB_ADD
a263 1
#endif
d447 2
a2132 1
#ifdef SOLIB_ADD
d2163 1
d2165 3
a2225 1
#endif
d2314 6
a2319 1
      && IN_SOLIB_DYNSYM_RESOLVE_CODE (stop_pc))
d2403 7
a2409 1
      if (IN_SOLIB_DYNSYM_RESOLVE_CODE (ecs->stop_func_start))
a3932 1
#ifdef SOLIB_ADD
a3942 1
#endif
@


1.199
log
@2005-02-24  Andrew Cagney  <cagney@@gnu.org>

	Add show_VARIABLE functions, update add_setshow call.
	* varobj.c (_initialize_varobj, show_varobjdebug): Add and update.
	* valprint.c (_initialize_valprint, show_print_max)
	(show_stop_print_at_null, show_repeat_count_threshold)
	(show_prettyprint_structs, show_unionprint)
	(show_prettyprint_arrays, show_addressprint, show_input_radix)
	(show_output_radix): Ditto.
	* valops.c (_initialize_valops, show_overload_resolution): Ditto.
	* utils.c (initialize_utils, show_chars_per_line)
	(show_lines_per_page, show_demangle, show_pagination_enabled)
	(show_sevenbit_strings, show_asm_demangle): Ditto
	* tui/tui-win.c (_initialize_tui_win, show_tui_border_kind)
	(show_tui_border_mode, show_tui_active_border_mode): Ditto.
	* top.c (init_main, show_new_async_prompt)
	(show_async_command_editing_p, show_write_history_p)
	(show_history_size, show_history_filename, show_caution)
	(show_annotation_level, init_main): Ditto.
	* target.c (initialize_targets, show_targetdebug)
	(show_trust_readonly): Ditto.
	* symfile.c (_initialize_symfile, show_symbol_reloading)
	(show_ext_args, show_download_write_size)
	(show_debug_file_directory): Ditto.
	* source.c (_initialize_source, show_lines_to_list): Ditto.
	* solib.c (_initialize_solib, show_auto_solib_add)
	(show_solib_search_path): Ditto.
	* p-valprint.c (_initialize_pascal_valprint)
	(show_pascal_static_field_print): Ditto.
	* printcmd.c (_initialize_printcmd, show_max_symbolic_offset)
	(show_print_symbol_filename): Add and update.
	* parse.c (_initialize_parse, show_expressiondebug): Dito.
	* observer.c (_initialize_observer, show_observer_debug): Dito.
	* maint.c (_initialize_maint_cmds, show_watchdog)
	(show_maintenance_profile_p): Dito.
	* linux-nat.c (_initialize_linux_nat, show_debug_linux_nat): Dito.
	* infrun.c (_initialize_infrun, show_debug_infrun)
	(show_stop_on_solib_events, show_follow_fork_mode_string)
	(show_scheduler_mode, show_step_stop_if_no_debug): Ditto.
	* infcall.c (_initialize_infcall, show_coerce_float_to_double_p)
	(show_unwind_on_signal_p): Ditto.
	* gdbtypes.c (build_gdbtypes, show_opaque_type_resolution)
	(_initialize_gdbtypes, show_overload_debug): Ditto.
	* gdb-events.c, gdb-events.sh (_initialize_gdb_events)
	(show_gdb_events_debug): Ditto.
	* gdbarch.c, gdbarch.sh (show_gdbarch_debug)
	(_initialize_gdbarch): Ditto.
	* frame.c (_initialize_frame, show_backtrace_past_main)
	(show_backtrace_past_entry, show_backtrace_limit)
	(show_frame_debug): Ditto.
	* exec.c (_initialize_exec, show_write_files): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read)
	(show_dwarf2_max_cache_age): Ditto.
	* demangle.c (_initialize_demangler)
	(show_demangling_style_names): Ditto.
	* dcache.c (_initialize_dcache, show_dcache_enabled_p): Ditto.
	* cp-valprint.c (show_static_field_print)
	(_initialize_cp_valprint, show_vtblprint, show_objectprint): Ditto.
	* corefile.c (_initialize_core, show_gnutarget_string): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging)
	(show_logging_overwrite, show_logging_redirect)
	(show_logging_filename): Ditto.
	* cli/cli-cmds.c (show_info_verbose, show_history_expansion_p)
	(init_cli_cmds, show_baud_rate, show_remote_debug)
	(show_remote_timeout, show_max_user_call_depth): Ditto.
	* charset.c (show_host_charset_name, show_target_charset_name)
	(initialize_charset): Ditto.
	* breakpoint.c (show_can_use_hw_watchpoints)
	(show_pending_break_support, _initialize_breakpoint): Ditto.
@
text
@d1236 4
a1239 5
  /* NOTE: cagney/2003-03-28: If you're looking at this code and
     thinking that the variable stepped_after_stopped_by_watchpoint
     isn't used, then you're wrong!  The macro STOPPED_BY_WATCHPOINT,
     defined in the file "config/pa/nm-hppah.h", accesses the variable
     indirectly.  Mutter something rude about the HP merge.  */
@


1.198
log
@2005-02-21  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_set_enum_cmd): Delete function.
	(deprecated_add_show_from_set): Delete function.
	* command.h (add_set_enum_cmd): Delete declaration.
	(deprecated_add_show_from_set): Delete declaration.
	* cli/cli-decode.h (add_set_enum_cmd): Delete declaration.
	(deprecated_add_show_from_set): Delete declaration.
	* arm-tdep.c (_initialize_arm_tdep): Update comment.
	* kod.c (kod_set_os): Simplify.
	* infrun.c (set_schedlock_func): Simplify.
	* cli/cli-dump.c (add_dump_command): Update comment.
@
text
@d90 6
d117 6
d260 7
d336 8
a487 1
static const char *scheduler_mode = schedlock_off;
d494 9
d3873 1
a3873 1
			    NULL, /* FIXME: i18n: */
d3932 1
a3932 1
			    NULL, /* FIXME: i18n: */
d3947 1
a3947 1
			NULL, /* FIXME: i18n: */
d3960 1
a3960 1
			NULL, /* FIXME: i18n: */
d3970 1
a3970 1
			   NULL, /* FIXME: i18n: */
@


1.197
log
@2005-02-20  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_enum_cmd through out.
	* arch-utils.c, charset.c, demangle.c, i386-tdep.c: Update.
	* infrun.c, mips-tdep.c, osabi.c, serial.c, tui/tui-win.c: Update.
@
text
@d472 5
a476 15
  /* NOTE: cagney/2002-03-17: The deprecated_add_show_from_set()
     function clones the set command passed as a parameter.  The clone
     operation will include (BUG?) any ``set'' command callback, if
     present.  Commands like ``info set'' call all the ``show''
     command callbacks.  Unfortunately, for ``show'' commands cloned
     from ``set'', this includes callbacks belonging to ``set''
     commands.  Making this worse, this only occures if
     deprecated_add_show_from_set() is called after add_cmd_sfunc()
     (BUG?).  */
  if (cmd_type (c) == set_cmd)
    if (!target_can_lock_scheduler)
      {
	scheduler_mode = schedlock_off;
	error (_("Target '%s' cannot support this command."), target_shortname);
      }
@


1.196
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_zinteger_cmd through out.  Re-sync gdbarch.sh
	and gdbarch.c.
	* breakpoint.c, frame.c, gdb-events.sh, gdbarch.sh: Update.
	* gdbtypes.c, infrun.c, linux-nat.c, maint.c, monitor.c: Update.
	* pa64solib.c, parse.c, remote-mips.c, ser-go32.c: Update.
	* serial.c, solib-frv.c, somsolib.c, target.c, top.c: Update.
	* varobj.c, cli/cli-cmds.c: Update.
	* gdbarch.c, gdb-events.c: Regenerate.
@
text
@d3911 5
a3915 5
  c = add_set_enum_cmd ("follow-fork-mode",
			class_run,
			follow_fork_mode_kind_names, &follow_fork_mode_string,
			"Set debugger response to a program call of fork \
or vfork.\n\
d3920 4
a3923 2
By default, the debugger will follow the parent process.", &setlist);
  deprecated_add_show_from_set (c, &showlist);
d3925 4
a3928 4
  c = add_set_enum_cmd ("scheduler-locking", class_run, 
			scheduler_enums,	/* array of string names */
			&scheduler_mode,	/* current mode  */
			"Set mode for locking scheduler during execution.\n\
d3933 4
a3936 5
	Other threads may run while stepping over a function call ('next').", 
			&setlist);

  set_cmd_sfunc (c, set_schedlock_func);	/* traps on target vector */
  deprecated_add_show_from_set (c, &showlist);
@


1.195
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_boolean_command through out.  Delete #ifdef 0'ed
	code adding set/show boolean commands.
	* cp-valprint.c, dcache.c, exec.c, gdbtypes.c, infrun.c: Update.
	* monitor.c, p-valprint.c, pa64solib.c, printcmd.c: Update.
	* proc-api.c, remote-mips.c, remote.c, solib.c: Update.
	* somsolib.c, symfile.c, top.c, utils.c, valops.c: Update.
	* valprint.c, win32-nat.c, wince.c, xcoffsolib.c: Update.
	* cli/cli-cmds.c: Update.
@
text
@d3843 7
a3849 3
  add_set_cmd ("infrun", class_maintenance, var_zinteger,
	       &debug_infrun, "Set inferior debugging.\n\
When non-zero, inferior specific debugging is enabled.", &setdebuglist);
d3899 4
a3902 4
  deprecated_add_show_from_set
    (add_set_cmd ("stop-on-solib-events", class_support, var_zinteger,
		  (char *) &stop_on_solib_events,
		  "Set stopping for shared library events.\n\
d3905 4
a3908 3
to the user would be loading/unloading of a new library.\n", 
		  &setlist), 
     &showlist);
@


1.194
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d3932 9
a3940 7
  c = add_set_cmd ("step-mode", class_run,
		   var_boolean, (char *) &step_stop_if_no_debug,
		   "Set mode of the step operation. When set, doing a step over a\n\
function without debug line information will stop at the first\n\
instruction of that function. Otherwise, the function is skipped and\n\
the step command stops at a different source line.", &setlist);
  deprecated_add_show_from_set (c, &showlist);
@


1.193
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d3793 3
a3795 3
  add_info ("signals", signals_info,
	    "What debugger does when program gets various signals.\n\
Specify a signal as argument to print info on that signal only.");
d3798 2
a3799 2
  add_com ("handle", class_run, handle_command,
	   concat ("Specify how to handle a signal.\n\
d3805 2
a3806 1
used by the debugger, typically SIGTRAP and SIGINT.\n", "Recognized actions include \"stop\", \"nostop\", \"print\", \"noprint\",\n\
d3812 1
a3812 1
Pass and Stop may be combined.", NULL));
d3815 5
a3819 5
      add_com ("lz", class_info, signals_info,
	       "What debugger does when program gets various signals.\n\
Specify a signal as argument to print info on that signal only.");
      add_com ("z", class_run, xdb_handle_command,
	       concat ("Specify how to handle a signal.\n\
d3825 2
a3826 1
used by the debugger, typically SIGTRAP and SIGINT.\n", "Recognized actions include \"s\" (toggles between stop and nostop), \n\
d3833 1
a3833 1
Pass and Stop may be combined.", NULL));
@


1.192
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d3835 3
a3837 3
    stop_command =
      add_cmd ("stop", class_obscure, not_just_help_class_command, 
	       "There is no `stop' command, but you can set a hook on `stop'.\n\
d3839 1
a3839 1
of the program stops.", &cmdlist);
@


1.191
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d393 1
a393 1
  printf_unfiltered ("Executing new program: %s\n", execd_pathname);
d2942 1
a2942 1
      printf_filtered ("[Switching to %s]\n",
d2963 4
a2966 4
	  printf_filtered ("Cannot remove breakpoints because ");
	  printf_filtered ("program is no longer writable.\n");
	  printf_filtered ("It might be running in another process.\n");
	  printf_filtered ("Further execution is probably impossible.\n");
d3148 2
a3149 2
  printf_filtered ("\
Signal        Stop\tPrint\tPass to program\tDescription\n");
d3314 1
a3314 1
		      printf_unfiltered ("Not confirmed, unchanged.\n");
d3410 1
a3410 1
	    printf_filtered ("Invalid signal handling flag.\n");
d3456 1
a3456 1
  printf_filtered ("\nUse the \"handle\" command to change these tables.\n");
@


1.190
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d1253 1
a1253 1
      internal_error (__FILE__, __LINE__, "bad switch");
d2907 1
a2907 1
		      "print_stop_reason: unrecognized enum value");
d3048 1
a3048 1
	      internal_error (__FILE__, __LINE__, "Unknown value.");
d3185 1
a3185 1
      error_no_arg ("signal to handle");
@


1.189
log
@Index: ChangeLog
2005-01-24  Andrew Cagney  <cagney@@gnu.org>

	* infrun.c (handle_inferior_event): Handle back-to-back and nested
	signals where the step_resume_breakpoint may have already been
	inserted.

Index: testsuite/ChangeLog
2005-01-24  Andrew Cagney  <cagney@@gnu.org>

	* gdb.base/sigrepeat.exp, gdb.base/sigrepeat.c: New test.
@
text
@d177 1
a177 1
  error ("\
d180 1
a180 1
a command like `return' or `jump' to continue execution.");
d402 1
a402 1
    error ("Could find run target to save before following exec");
d485 1
a485 1
	error ("Target '%s' cannot support this command.", target_shortname);
d3292 1
a3292 1
	      error ("Unrecognized or ambiguous flag word: \"%s\".", *argv);
d3551 1
a3551 1
      warning ("Unable to restore previously selected frame.\n");
@


1.188
log
@2005-01-19  Andrew Cagney  <cagney@@gnu.org>

	* infrun.c: (resume, proceed, wait_for_inferior)
	(handle_inferior_event, stop_stepping)
	(prepare_to_wait): Write debug output to gdb_stdlog.
@
text
@d1936 2
d1939 7
a1945 5
      else if (step_range_end != 0
	       && stop_signal != TARGET_SIGNAL_0
	       && stop_pc >= step_range_start && stop_pc < step_range_end
	       && frame_id_eq (get_frame_id (get_current_frame ()),
			       step_frame_id))
d1957 2
d1960 7
@


1.187
log
@2005-01-13  Michael Snyder  <msnyder@@redhat.com>

	* infrun.c: Whitespace tweaks.
@
text
@d506 2
a507 1
    printf_unfiltered ("infrun: resume (step=%d, signal=%d)\n", step, sig);
d725 3
a727 2
    printf_unfiltered ("infrun: proceed (addr=0x%s, signal=%d, step=%d)\n",
		       paddr_nz (addr), siggnal, step);
d943 1
a943 1
    printf_unfiltered ("infrun: wait_for_inferior\n");
d1229 1
a1229 1
        printf_unfiltered ("infrun: infwait_thread_hop_state\n");
d1236 1
a1236 1
        printf_unfiltered ("infrun: infwait_normal_state\n");
d1242 2
a1243 1
        printf_unfiltered ("infrun: infwait_nonstep_watch_state\n");
d1279 1
a1279 1
        printf_unfiltered ("infrun: TARGET_WAITKIND_LOADED\n");
d1325 1
a1325 1
        printf_unfiltered ("infrun: TARGET_WAITKIND_SPURIOUS\n");
d1332 1
a1332 1
        printf_unfiltered ("infrun: TARGET_WAITKIND_EXITED\n");
d1350 1
a1350 1
        printf_unfiltered ("infrun: TARGET_WAITKIND_SIGNALLED\n");
d1372 1
a1372 1
        printf_unfiltered ("infrun: TARGET_WAITKIND_FORKED\n");
d1396 1
a1396 1
        printf_unfiltered ("infrun: TARGET_WAITKIND_EXECED\n");
d1450 1
a1450 1
        printf_unfiltered ("infrun: TARGET_WAITKIND_SYSCALL_ENTRY\n");
d1462 1
a1462 1
        printf_unfiltered ("infrun: TARGET_WAITKIND_SYSCALL_RETURN\n");
d1469 1
a1469 1
        printf_unfiltered ("infrun: TARGET_WAITKIND_STOPPED\n");
d1484 1
a1484 1
        printf_unfiltered ("infrun: TARGET_WAITKIND_IGNORE\n");
d1506 1
a1506 1
    printf_unfiltered ("infrun: stop_pc = 0x%s\n", paddr_nz (stop_pc));
d1523 1
a1523 1
	    printf_unfiltered ("infrun: stepping_past_singlestep_breakpoint\n");
d1581 1
a1581 1
	    printf_unfiltered ("infrun: thread_hop_needed\n");
d1649 1
a1649 1
	printf_unfiltered ("infrun: context switch\n");
d1672 1
a1672 1
	printf_unfiltered ("infrun: STOPPED_BY_WATCHPOINT\n");
d1701 1
a1701 1
	printf_unfiltered ("infrun: STOPPED_BY_WATCHPOINT\n");
d1748 1
a1748 1
	printf_unfiltered ("infrun: step through delay\n");
d1798 1
a1798 1
	    printf_unfiltered ("infrun: stopped\n");
d1809 1
a1809 1
	    printf_unfiltered ("infrun: quietly stopped\n");
d1831 1
a1831 1
	    printf_unfiltered ("infrun: trap expected\n");
d1895 1
a1895 1
	 printf_unfiltered ("infrun: random signal %d\n", stop_signal);
d1977 1
a1977 1
	  printf_unfiltered ("infrun: BPSTATE_WHAT_SET_LONGJMP_RESUME\n");
d2002 1
a2002 1
	  printf_unfiltered ("infrun: BPSTATE_WHAT_CLEAR_LONGJMP_RESUME\n");
d2013 1
a2013 1
	  printf_unfiltered ("infrun: BPSTATE_WHAT_SINGLE\n");
d2026 1
a2026 1
	  printf_unfiltered ("infrun: BPSTATE_WHAT_STOP_NOISY\n");
d2037 1
a2037 1
	  printf_unfiltered ("infrun: BPSTATE_WHAT_STOP_SILENT\n");
d2065 1
a2065 1
	  printf_unfiltered ("infrun: BPSTATE_WHAT_STEP_RESUME\n");
d2089 1
a2089 1
	  printf_unfiltered ("infrun: BPSTATE_WHAT_THROUGH_SIGTRAMP\n");
d2101 1
a2101 1
	    printf_unfiltered ("infrun: BPSTATE_WHAT_CHECK_SHLIBS\n");
d2215 1
a2215 1
	    printf_unfiltered ("infrun: stepping in dynamic linker\n");
d2222 1
a2222 1
	 printf_unfiltered ("infrun: step past dynamic linker\n");
d2237 1
a2237 1
	 printf_unfiltered ("infrun: step-resume breakpoint\n");
d2249 1
a2249 1
	 printf_unfiltered ("infrun: no stepping, continue\n");
d2263 1
a2263 1
	 printf_unfiltered ("infrun: stepping inside range [0x%s-0x%s]\n",
d2283 1
a2283 1
	 printf_unfiltered ("infrun: stepped into dynsym resolve code\n");
d2306 1
a2306 1
	 printf_unfiltered ("infrun: stepped into signal trampoline\n");
d2322 1
a2322 1
	 printf_unfiltered ("infrun: stepped into subroutine\n");
d2415 1
a2415 1
	 printf_unfiltered ("infrun: stepped into solib return tramp\n");
d2446 1
a2446 1
	 printf_unfiltered ("infrun: stepped into undebuggable function\n");
d2479 1
a2479 1
	 printf_unfiltered ("infrun: stepi/nexti\n");
d2495 1
a2495 1
	 printf_unfiltered ("infrun: no line number info\n");
d2511 1
a2511 1
	 printf_unfiltered ("infrun: stepped to a different line\n");
d2533 1
a2533 1
	 printf_unfiltered ("infrun: stepped to a different function\n");
d2571 1
a2571 1
     printf_unfiltered ("infrun: keep going\n");
d2709 1
a2709 1
    printf_unfiltered ("infrun: stop_stepping\n");
d2789 1
a2789 1
    printf_unfiltered ("infrun: prepare_to_wait\n");
@


1.186
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d2202 3
a2204 3
  /* Are we stepping to get the inferior out of the dynamic
     linker's hook (and possibly the dld itself) after catching
     a shlib event? */
d3820 2
a3821 1
      add_cmd ("stop", class_obscure, not_just_help_class_command, "There is no `stop' command, but you can set a hook on `stop'.\n\
d3826 1
a3826 1
		  &debug_infrun, "Set inferior debugging.\n\
d3883 3
a3885 1
to the user would be loading/unloading of a new library.\n", &setlist), &showlist);
d3900 2
a3901 1
  c = add_set_enum_cmd ("scheduler-locking", class_run, scheduler_enums,	/* array of string names */
d3908 2
a3909 1
	Other threads may run while stepping over a function call ('next').", &setlist);
@


1.185
log
@* target.h (TARGET_DISABLE_HW_WATCHPOINTS)
(TARGET_ENABLE_HW_WATCHPOINTS): Remove macros.
* infrun.c (struct execution_control_state): Remove
enable_hw_watchpoints_after_wait member.
(number_of_threads_in_syscalls): Remove variable.
(init_wait_for_inferior): Don't initialize
number_of_threads_in_syscalls.
(init_execution_control_state): Don't initialize
ECS->enable_hw_watchpoints_after_wait.
(handle_inferior_event): Never invoke TARGET_ENABLE_HW_WATCHPOINTS
or TARGET_DISABLE_HW_WATCHPOINTS.
@
text
@d31 1
@


1.184
log
@2004-12-03  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (instruction_nullified): Delete.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-tdep.c (hppa_target_read_pc): Adjust pc if instruction is
	nullified.
	(hppa_unwind_pc): Likewise.
	(hppa_instruction_nullified): Delete.
	(hppa_gdbarch_init): Don't set instruction_nullified method.
	* infrun.c (infwait_states): Remove infwait_nullified_state.
	(handle_inferior_event): Remove handling of infwait_nullified_state.
	Remove handling of nullified instructions.


testsuite/

	* gdb.arch/pa-nullify.exp: New file.
	* gdb.arch/pa-nullify.s: New file.
@
text
@a282 8
/* On some platforms (e.g., HP-UX), hardware watchpoints have bad
   interactions with an inferior that is running a kernel function
   (aka, a system call or "syscall").  wait_for_inferior therefore
   may have a need to know when the inferior is in a syscall.  This
   is a count of the number of inferior threads which are known to
   currently be running in a syscall. */
static int number_of_threads_in_syscalls;

a848 3
  /* See wait_for_inferior's handling of SYSCALL_ENTRY/RETURN events. */
  number_of_threads_in_syscalls = 0;

a904 1
  int enable_hw_watchpoints_after_wait;
a1056 1
  ecs->enable_hw_watchpoints_after_wait = 0;
a1228 8
      /* See comments where a TARGET_WAITKIND_SYSCALL_RETURN event
         is serviced in this loop, below. */
      if (ecs->enable_hw_watchpoints_after_wait)
	{
	  TARGET_ENABLE_HW_WATCHPOINTS (PIDGET (inferior_ptid));
	  ecs->enable_hw_watchpoints_after_wait = 0;
	}
      stepped_after_stopped_by_watchpoint = 0;
a1233 7
      /* See comments where a TARGET_WAITKIND_SYSCALL_RETURN event
         is serviced in this loop, below. */
      if (ecs->enable_hw_watchpoints_after_wait)
	{
	  TARGET_ENABLE_HW_WATCHPOINTS (PIDGET (inferior_ptid));
	  ecs->enable_hw_watchpoints_after_wait = 0;
	}
d1442 2
a1443 17
      /* These syscall events are returned on HP-UX, as part of its
         implementation of page-protection-based "hardware" watchpoints.
         HP-UX has unfortunate interactions between page-protections and
         some system calls.  Our solution is to disable hardware watches
         when a system call is entered, and reenable them when the syscall
         completes.  The downside of this is that we may miss the precise
         point at which a watched piece of memory is modified.  "Oh well."

         Note that we may have multiple threads running, which may each
         enter syscalls at roughly the same time.  Since we don't have a
         good notion currently of whether a watched piece of memory is
         thread-private, we'd best not have any page-protections active
         when any thread is in a syscall.  Thus, we only want to reenable
         hardware watches when no threads are in a syscall.

         Also, be careful not to try to gather much state about a thread
         that's in a syscall.  It's frequently a losing proposition. */
a1446 5
      number_of_threads_in_syscalls++;
      if (number_of_threads_in_syscalls == 1)
	{
	  TARGET_DISABLE_HW_WATCHPOINTS (PIDGET (inferior_ptid));
	}
d1455 1
a1455 10
         into user code.)

         Note that although the logical place to reenable h/w watches
         is here, we cannot.  We cannot reenable them before stepping
         the thread (this causes the next wait on the thread to hang).

         Nor can we enable them after stepping until we've done a wait.
         Thus, we simply set the flag ecs->enable_hw_watchpoints_after_wait
         here, which will be serviced immediately after the target
         is waited on. */
a1459 7

      if (number_of_threads_in_syscalls > 0)
	{
	  number_of_threads_in_syscalls--;
	  ecs->enable_hw_watchpoints_after_wait =
	    (number_of_threads_in_syscalls == 0);
	}
@


1.183
log
@2004-11-23  Randolph Chung  <tausq@@debian.org>

	* arch-utils.c (generic_instruction_nullified): New.
	* arch-utils.h (generic_instruction_nullified): New.
	* gdbarch.sh (instruction_nullified): New method.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* infrun.c (INSTRUCTION_NULLIFIED): Delete.
	(handle_inferior_event): Replace INSTRUCTION_NULLIFIED with calls to
	new gdbarch method.
	* config/pa/tm-hppa.h (INSTRUCTION_NULLIFIED): Delete definition.
	* hppa-tdep.c (hppa_instruction_nullified): Remove prototype and make
	static.  Rewrite to work directly off the passed regcache.
	(hppa_gdbarch_init): Set instruction_nullified method.
@
text
@a872 1
  infwait_nullified_state,
a1264 6
    case infwait_nullified_state:
      if (debug_infrun)
        printf_unfiltered ("infrun: infwait_nullified_state\n");
      stepped_after_stopped_by_watchpoint = 0;
      break;

a1725 24
  /* If PC is pointing at a nullified instruction, then step beyond
     it before deciding what to do.  This is required when we are stepping
     through a function where the last instruction is a branch with a
     nullified instruction in the delay slot that belongs to the next
     line (which may be in a different function altogether).  */

  if (gdbarch_instruction_nullified (current_gdbarch, current_regcache))
    {
      if (debug_infrun)
	printf_unfiltered ("infrun: instruction nullified\n");
      registers_changed ();
      target_resume (ecs->ptid, 1, TARGET_SIGNAL_0);

      /* We may have received a signal that we want to pass to
         the inferior; therefore, we must not clobber the waitstatus
         in WS. */

      ecs->infwait_state = infwait_nullified_state;
      ecs->waiton_ptid = ecs->ptid;
      ecs->wp = &(ecs->tmpstatus);
      prepare_to_wait (ecs);
      return;
    }

@


1.182
log
@2004-11-08  Randolph Chung  <tausq@@debian.org>

	* infrun.c (debug_infrun): New variable.
	(resume, proceed, wait_for_inferior): Annotate with debug messages.
	(handle_inferior_event, keep_going): Likewise.
	(_initialize_infrun): Register "set debug infrun" command.
@
text
@a165 10
/* On some systems, the PC may be left pointing at an instruction that  won't
   actually be executed.  This is usually indicated by a bit in the PSW.  If
   we find ourselves in such a state, then we step the target beyond the
   nullified instruction before returning control to the user so as to avoid
   confusion. */

#ifndef INSTRUCTION_NULLIFIED
#define INSTRUCTION_NULLIFIED 0
#endif

d1734 4
a1737 2
     it so that the user won't be confused when GDB appears to be ready
     to execute it. */
d1739 1
a1739 2
  /*      if (INSTRUCTION_NULLIFIED && currently_stepping (ecs)) */
  if (INSTRUCTION_NULLIFIED)
d1742 1
a1742 1
	printf_unfiltered ("infrun: INSTRUCTION_NULLIFIED\n");
@


1.181
log
@2004-10-31  Orjan Friberg <organ.friberg@@axis.com>
	    Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (single_step_through_delay): Add.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/mips/tm-mips.h (STEP_SKIPS_DELAY_P, STEP_SKIPS_DELAY)
	(mips_step_skips_delay): Delete.
	* mips-tdep.c (mips_single_step_through_delay): Replace
	mips_step_skips_delay.
	(mips_gdbarch_init): Set single_step_through_delay.
	(mips_dump_tdep): Do not print STEP_SKIPS_DELAY.
@
text
@d109 2
d522 3
d740 4
d962 3
d1249 2
d1264 2
d1277 2
d1283 2
d1319 2
d1365 2
d1372 2
d1390 2
d1412 2
d1436 2
d1505 2
d1531 2
d1545 2
d1560 2
d1582 3
d1599 2
d1657 3
d1725 3
d1750 2
d1771 2
d1800 2
d1847 2
d1897 2
d1908 2
d1929 5
a1933 1
	bpstat_clear (&stop_bpstat);
d1994 3
d2076 2
d2101 2
d2112 2
d2125 2
d2136 2
d2164 3
d2188 2
d2200 2
d2314 2
d2321 2
d2336 3
d2348 2
d2362 4
d2382 3
d2405 2
d2421 3
d2514 3
d2545 3
d2578 2
d2594 2
d2610 2
d2632 2
d2670 2
d2808 3
d2888 2
d3927 4
@


1.180
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.c (mips_ignore_helper): Delete.
	* config/mips/tm-mips.h (DEPRECATED_IGNORE_HELPER_CALL): Delete.
	* infrun.c (handle_inferior_event): Delete #ifdef
	DEPRECATED_IGNORE_HELPER_CALL code.
@
text
@a716 5
      /* If there is a breakpoint at the address we will resume at,
         step one instruction before inserting breakpoints
         so that we do not stop right away (and report a second
         hit at this breakpoint).  */

d718 4
d723 5
a727 11

#ifndef STEP_SKIPS_DELAY
#define STEP_SKIPS_DELAY(pc) (0)
#define STEP_SKIPS_DELAY_P (0)
#endif
      /* Check breakpoint_here_p first, because breakpoint_here_p is fast
         (it just checks internal GDB data structures) and STEP_SKIPS_DELAY
         is slow (it needs to read memory from the target).  */
      if (STEP_SKIPS_DELAY_P
	  && breakpoint_here_p (read_pc () + 4)
	  && STEP_SKIPS_DELAY (read_pc ()))
d1777 33
@


1.179
log
@2004-10-29  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (get_selected_frame): Add message parameter.
	* frame.c (get_selected_frame): Add and use message parameter.
	* stack.c (current_frame_command, return_command, locals_info)
	(catch_info, args_info, up_silently_base, down_silently_base): Use
	get_selected_frame with an explicit message.
	* thread.c, stack.c, sh-tdep.c, sh64-tdep.c: Update.
	* remote-rdp.c, remote-mips.c, remote-e7000.c: Update.
	* ocd.c, mi/mi-main.c, mi/mi-cmd-stack.c: Update.
	* infrun.c, inflow.c, infcmd.c, frame.c: Update.
	* findvar.c, eval.c, corelow.c, bsd-kvm.c: Update.
	* breakpoint.c: Update.
@
text
@a2305 21
#ifdef DEPRECATED_IGNORE_HELPER_CALL
      /* On MIPS16, a function that returns a floating point value may
         call a library helper function to copy the return value to a
         floating point register.  The DEPRECATED_IGNORE_HELPER_CALL
         macro returns non-zero if we should ignore (i.e. step over)
         this function call.  */
      /* FIXME: cagney/2004-07-21: These custom ``ignore frame when
         stepping'' function attributes (SIGTRAMP_FRAME,
         DEPRECATED_IGNORE_HELPER_CALL, SKIP_TRAMPOLINE_CODE,
         skip_language_trampoline frame, et.al.) need to be replaced
         with generic attributes bound to the frame's function.  */
      if (DEPRECATED_IGNORE_HELPER_CALL (stop_pc))
	{
	  /* We're doing a "next", set a breakpoint at callee's return
	     address (the address at which the caller will
	     resume).  */
	  insert_step_resume_breakpoint_at_frame (get_prev_frame (get_current_frame ()));
	  keep_going (ecs);
	  return;
	}
#endif
@


1.178
log
@2004-09-27  Andrew Cagney  <cagney@@gnu.org>

	* infrun.c (check_for_old_step_resume_breakpoint): Delete.
	(insert_step_resume_breakpoint): Delete.
	(insert_step_resume_breakpoint_at_frame): New function.
	(insert_step_resume_breakpoint_at_sal): New function.
	(handle_inferior_event, step_into_function)
	(insert_step_resume_breakpoint): Simplify by using same.
@
text
@d3017 1
a3017 1
	    print_stack_frame (get_selected_frame (), 0, source_flag);
@


1.177
log
@2004-09-13  Andrew Cagney  <cagney@@gnu.org>

	Eliminate event_loop_p, always has the value 1.
	* defs.h (event_loop_p): Delete macro.
	* breakpoint.c (until_break_command): Simplify.
	* utils.c (prompt_for_continue): Simplify.
	* tracepoint.c (read_actions): Simplify.
	* top.c (throw_exception, execute_command, gdb_readline_wrapper)
	(gdb_rl_operate_and_get_next, command_line_input, get_prompt)
	(set_prompt, init_main): Simplify.
	(init_signals, disconnect): Delete, unused.
	* remote.c (remote_async_resume)
	(extended_remote_async_create_inferior): Simplify.
	* mi/mi-interp.c (mi_input): Delete, unused.
	(mi_interpreter_resume, mi_command_loop): Simplify.
	* interps.c (current_interp_command_loop): Simplify.
	* infrun.c (proceed): Simplify.
	* infcmd.c (run_command, continue_command, step_1, jump_command)
	(until_command, advance_command, finish_command)
	(interrupt_target_command): Simplify.
	* event-top.c (gdb_setup_readline, gdb_disable_readline): Simplify.
@
text
@d938 3
a940 3
static void insert_step_resume_breakpoint (struct frame_info *step_frame,
					   struct execution_control_state
					   *ecs);
a1083 12
/* Call this function before setting step_resume_breakpoint, as a
   sanity check.  There should never be more than one step-resume
   breakpoint per thread, so we should never be setting a new
   step_resume_breakpoint when one is already active.  */
static void
check_for_old_step_resume_breakpoint (void)
{
  if (step_resume_breakpoint)
    warning
      ("GDB bug: infrun.c (wait_for_inferior): dropping old step_resume breakpoint");
}

d1938 1
a1938 1
	  insert_step_resume_breakpoint (get_current_frame (), ecs);
d1956 1
a1956 1
	  insert_step_resume_breakpoint (get_current_frame (), ecs);
d2264 1
a2264 5
	  check_for_old_step_resume_breakpoint ();
	  step_resume_breakpoint =
	    set_momentary_breakpoint (sr_sal, null_frame_id, bp_step_resume);
	  if (breakpoints_inserted)
	    insert_breakpoints ();
d2322 1
a2322 2
	  insert_step_resume_breakpoint (get_prev_frame
					 (get_current_frame ()), ecs);
d2332 1
a2332 2
	  insert_step_resume_breakpoint (get_prev_frame
					 (get_current_frame ()), ecs);
d2354 1
a2354 6
	  check_for_old_step_resume_breakpoint ();
	  step_resume_breakpoint =
	    set_momentary_breakpoint (sr_sal, null_frame_id, bp_step_resume);
	  if (breakpoints_inserted)
	    insert_breakpoints ();

d2389 1
a2389 2
      insert_step_resume_breakpoint (get_prev_frame (get_current_frame ()),
				     ecs);
d2410 5
a2414 8
	  /* Do not specify what the fp should be when we stop
	     since on some machines the prologue
	     is where the new fp value is established.  */
	  check_for_old_step_resume_breakpoint ();
	  step_resume_breakpoint =
	    set_momentary_breakpoint (sr_sal, null_frame_id, bp_step_resume);
	  if (breakpoints_inserted)
	    insert_breakpoints ();
d2449 1
a2449 2
	  insert_step_resume_breakpoint (get_prev_frame
					 (get_current_frame ()), ecs);
d2620 1
d2624 1
a2624 5
      check_for_old_step_resume_breakpoint ();
      step_resume_breakpoint =
	set_momentary_breakpoint (sr_sal, null_frame_id, bp_step_resume);
      if (breakpoints_inserted)
	insert_breakpoints ();
d2632 17
d2664 1
a2664 2
insert_step_resume_breakpoint (struct frame_info *return_frame,
			       struct execution_control_state *ecs)
d2673 1
a2673 8
  check_for_old_step_resume_breakpoint ();

  step_resume_breakpoint
    = set_momentary_breakpoint (sr_sal, get_frame_id (return_frame),
				bp_step_resume);

  if (breakpoints_inserted)
    insert_breakpoints ();
@


1.176
log
@2004-08-30  Andrew Cagney  <cagney@@gnu.org>

	Fix PR breakpoints/1757.
	* infrun.c (struct execution_control_state): Replace
	remove_breakpoints_on_following_step with
	step_after_step_resume_breakpoint.
	(init_execution_control_state): Update.
	(handle_inferior_event): For signals, when stepping off a
	breakpoint, set step_after_step_resume_breakpoint.  When
	BPSTAT_WHAT_STEP_RESUME, do a single-step off the breakpoint.
	(keep_going): Delete code handling
	remove_breakpoints_on_following_step.

Index: testsuite/ChangeLog
2004-08-30  Andrew Cagney  <cagney@@gnu.org>

	* gdb.base/sigstep.exp (breakpoint_over_handler): Remove kfail
	gdb/1757.
@
text
@d812 1
a812 1
  if (!event_loop_p || !target_can_async_p ())
@


1.175
log
@2004-08-25  Andrew Cagney  <cagney@@gnu.org>

	* infrun.c (struct execution_control_state): Delete field
	"stepping_through_sigtramp".
	(init_execution_control_state): Do not set same.
	(context_switch): Do not pass same to save_infrun_state and
	load_infrun_state.
	* gdbthread.h (struct thread_info): Delete field
	stepping_through_sigtramp.
	(save_infrun_state, load_infrun_state): Delete parameter
	stepping_through_sigtramp.
	* thread.c (load_infrun_state, save_infrun_state): Update.
@
text
@a916 1
  int remove_breakpoints_on_following_step;
d922 1
d1071 1
a1071 1
  ecs->remove_breakpoints_on_following_step = 0;
d1935 23
a1957 4
      if (step_range_end != 0
	  && stop_signal != TARGET_SIGNAL_0
	  && stop_pc >= step_range_start && stop_pc < step_range_end
	  && frame_id_eq (get_frame_id (get_current_frame ()), step_frame_id))
d2076 12
d2734 1
a2734 1
         We're going to run this baby now!
d2736 1
a2736 12
         Insert breakpoints now, unless we are trying to one-proceed
         past a breakpoint.  */
      /* If we've just finished a special step resume and we don't
         want to hit a breakpoint, pull em out.  */
      if (step_resume_breakpoint == NULL
	  && ecs->remove_breakpoints_on_following_step)
	{
	  ecs->remove_breakpoints_on_following_step = 0;
	  remove_breakpoints ();
	  breakpoints_inserted = 0;
	}
      else if (!breakpoints_inserted && !ecs->another_trap)
@


1.174
log
@2004-08-25  Andrew Cagney  <cagney@@gnu.org>

	* infrun.c: Re-indent.  Move expression operators to the beginning
	of the line.  Remove long disabled #if 0 code.
@
text
@a925 1
  int stepping_through_sigtramp;
a1075 1
  ecs->stepping_through_sigtramp = 0;
a1128 1
			 ecs->stepping_through_sigtramp,
a1138 1
			 &ecs->stepping_through_sigtramp,
@


1.173
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d583 3
a585 3
      if ((step || singlestep_breakpoints_inserted_p) &&
	  (stepping_past_singlestep_breakpoint
	   || (!breakpoints_inserted && breakpoint_here_p (read_pc ()))))
d595 3
a597 3
      if ((scheduler_mode == schedlock_on) ||
	  (scheduler_mode == schedlock_step &&
	   (step || singlestep_breakpoints_inserted_p)))
d652 2
a653 2
      || (wait_status.value.sig != TARGET_SIGNAL_TRAP &&
          wait_status.value.sig != TARGET_SIGNAL_INT))
d677 5
a681 5
	/* We return 1 to indicate that there is a breakpoint here,
	   so we need to step over it before continuing to avoid
	   hitting it straight away. */
	if (breakpoint_here_p (wait_pc))
	   return 1;
d685 1
a685 1
  
d764 1
a764 1
	 insert breakpoints -- so they were inserted.  */
d802 1
a802 1
     updated correctly when the inferior is stopped.  */  
d940 2
a941 1
					   struct execution_control_state *ecs);
d1165 1
a1165 1
     
d1172 1
a1172 1
     
d1192 2
a1193 2
	 an inserted breakpoint.  This actually makes things
	 easier.  */
d1209 3
a1211 3
	 both a completed single-step and a software breakpoint.  Need
	 to differentiate between the two as the latter needs
	 adjusting but the former does not.  */
d1249 1
a1249 1
  int stopped_by_watchpoint = -1;  /* Mark as unknown.  */
a1316 25

#if 0
      /* NOTE: This block is ONLY meant to be invoked in case of a
         "thread creation event"!  If it is invoked for any other
         sort of event (such as a new thread landing on a breakpoint),
         the event will be discarded, which is almost certainly
         a bad thing!

         To avoid this, the low-level module (eg. target_wait)
         should call in_thread_list and add_thread, so that the
         new thread is known by the time we get here.  */

      /* We may want to consider not doing a resume here in order
         to give the user a chance to play with the new thread.
         It might be good to make that a user-settable option.  */

      /* At this point, all threads are stopped (happens
         automatically in either the OS or the native code).
         Therefore we need to continue all threads in order to
         make progress.  */

      target_resume (RESUME_ALL, 0, TARGET_SIGNAL_0);
      prepare_to_wait (ecs);
      return;
#endif
d1339 5
a1343 5
             stack's section table is kept up-to-date.  Architectures,
             (e.g., PPC64), use the section table to perform
             operations such as address => section name and hence
             require the table to contain all sections (including
             those found in shared libraries).  */
d1345 8
a1352 8
             exec_ops to SOLIB_ADD.  This is because current GDB is
             only tooled to propagate section_table changes out from
             the "current_target" (see target_resize_to_sections), and
             not up from the exec stratum.  This, of course, isn't
             right.  "infrun.c" should only interact with the
             exec/process stratum, instead relying on the target stack
             to propagate relevant changes (stop, section table
             changed, ...) up to other layers.  */
d1432 2
a1433 2
	 target_wait function.  Until then following vfork on HP/UX 10.20
	 is probably broken by this.  Of course, it's broken anyway.  */
d1538 6
a1543 6
	 
	 One of the possible circumstances for this is when the
	 inferior produces output for the console. The inferior has
	 not stopped, and we are ignoring the event.  Another possible
	 circumstance is any event which the lower level knows will be
	 reported multiple times without an intervening resume.  */
d1567 2
a1568 1
      gdb_assert (SOFTWARE_SINGLE_STEP_P () && singlestep_breakpoints_inserted_p);
d1575 2
a1576 2
	 breakpoint, or stopped for some other reason.  It would be nice if
	 we could tell, but we can't reliably.  */
d1578 1
a1578 1
        {
d1632 2
a1633 2
	    {
	      int remove_status;
d1635 2
a1636 2
	      /* Saw a breakpoint, but it was hit by the wrong thread.
	         Just continue. */
d1638 6
a1643 6
	      if (SOFTWARE_SINGLE_STEP_P () && singlestep_breakpoints_inserted_p)
		{
		  /* Pull the single step breakpoints out of the target. */
		  SOFTWARE_SINGLE_STEP (0, 0);
		  singlestep_breakpoints_inserted_p = 0;
		}
d1645 21
a1665 27
	      remove_status = remove_breakpoints ();
	      /* Did we fail to remove breakpoints?  If so, try
	         to set the PC past the bp.  (There's at least
	         one situation in which we can fail to remove
	         the bp's: On HP-UX's that use ttrace, we can't
	         change the address space of a vforking child
	         process until the child exits (well, okay, not
	         then either :-) or execs. */
	      if (remove_status != 0)
		{
		  /* FIXME!  This is obviously non-portable! */
		  write_pc_pid (stop_pc + 4, ecs->ptid);
		  /* We need to restart all the threads now,
		   * unles we're running in scheduler-locked mode. 
		   * Use currently_stepping to determine whether to 
		   * step or continue.
		   */
		  /* FIXME MVS: is there any reason not to call resume()? */
		  if (scheduler_mode == schedlock_on)
		    target_resume (ecs->ptid,
				   currently_stepping (ecs), TARGET_SIGNAL_0);
		  else
		    target_resume (RESUME_ALL,
				   currently_stepping (ecs), TARGET_SIGNAL_0);
		  prepare_to_wait (ecs);
		  return;
		}
d1667 19
a1685 13
		{		/* Single step */
		  breakpoints_inserted = 0;
		  if (!ptid_equal (inferior_ptid, ecs->ptid))
		    context_switch (ecs);
		  ecs->waiton_ptid = ecs->ptid;
		  ecs->wp = &(ecs->ws);
		  ecs->another_trap = 1;

		  ecs->infwait_state = infwait_thread_hop_state;
		  keep_going (ecs);
		  registers_changed ();
		  return;
		}
d1688 4
a1691 4
        {
          sw_single_step_trap_p = 1;
          ecs->random_signal = 0;
        }
d1820 5
a1824 6
      || (breakpoints_inserted &&
	  (stop_signal == TARGET_SIGNAL_ILL
	   || stop_signal == TARGET_SIGNAL_SEGV
	   || stop_signal == TARGET_SIGNAL_EMT))
      || stop_soon == STOP_QUIETLY
      || stop_soon == STOP_QUIETLY_NO_SIGSTOP)
d1860 1
a1860 1
	  stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid, 
d1869 7
a1875 7
	 at one stage in the past included checks for an inferior
	 function call's call dummy's return breakpoint.  The original
	 comment, that went with the test, read:

	 ``End of a stack dummy.  Some systems (e.g. Sony news) give
	 another signal besides SIGTRAP, so check here as well as
	 above.''
d1884 3
a1886 3
	 NOTE: kettenis/2004-02-05: Indeed such checks don't seem to
	 be necessary for call dummies on a non-executable stack on
	 SPARC.  */
d1993 1
a1993 7
#if 0
	/* FIXME - Need to implement nested temporary breakpoints */
	if (step_over_calls > 0)
	  set_longjmp_resume_breakpoint (jmp_buf_pc, get_current_frame ());
	else
#endif /* 0 */
	  set_longjmp_resume_breakpoint (jmp_buf_pc, null_frame_id);
a2001 11
#if 0
	/* FIXME - Need to implement nested temporary breakpoints */
	if (step_over_calls
	    && (frame_id_inner (get_frame_id (get_current_frame ()),
				step_frame_id)))
	  {
	    ecs->another_trap = 1;
	    keep_going (ecs);
	    return;
	  }
#endif /* 0 */
d2087 5
a2091 5
             stack's section table is kept up-to-date.  Architectures,
             (e.g., PPC64), use the section table to perform
             operations such as address => section name and hence
             require the table to contain all sections (including
             those found in shared libraries).  */
d2093 8
a2100 8
             exec_ops to SOLIB_ADD.  This is because current GDB is
             only tooled to propagate section_table changes out from
             the "current_target" (see target_resize_to_sections), and
             not up from the exec stratum.  This, of course, isn't
             right.  "infrun.c" should only interact with the
             exec/process stratum, instead relying on the target stack
             to propagate relevant changes (stop, section table
             changed, ...) up to other layers.  */
d2128 2
a2129 2
	  else if (what.main_action ==
		   BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK)
d2266 4
a2269 4
	 a signal trampoline (either by a signal being delivered or by
	 the signal handler returning).  Just single-step until the
	 inferior leaves the trampoline (either by calling the handler
	 or returning).  */
d2274 1
a2274 2
  if (frame_id_eq (frame_unwind_id (get_current_frame ()),
                   step_frame_id))
d2278 1
a2278 1
	
d2294 1
a2294 1
	
d2297 4
a2300 4
	 call a library helper function to copy the return value to a
	 floating point register.  The DEPRECATED_IGNORE_HELPER_CALL
	 macro returns non-zero if we should ignore (i.e. step over)
	 this function call.  */
d2302 4
a2305 4
	 stepping'' function attributes (SIGTRAMP_FRAME,
	 DEPRECATED_IGNORE_HELPER_CALL, SKIP_TRAMPOLINE_CODE,
	 skip_language_trampoline frame, et.al.) need to be replaced
	 with generic attributes bound to the frame's function.  */
d2311 2
a2312 2
	  insert_step_resume_breakpoint (get_prev_frame (get_current_frame ()),
					 ecs);
d2322 2
a2323 2
	  insert_step_resume_breakpoint (get_prev_frame (get_current_frame ()),
					 ecs);
d2329 4
a2332 4
	 calling routine and the real function), locate the real
	 function.  That's what tells us (a) whether we want to step
	 into it at all, and (b) what prologue we want to run to the
	 end of, if we do step into it.  */
d2338 1
a2338 1
      
d2351 2
a2352 2
          keep_going (ecs);
          return;
d2356 1
a2356 1
	 thinking of stepping into, step into it.
d2358 3
a2360 3
	 If there are several symtabs at that PC (e.g. with include
	 files), just want to know whether *any* of them have line
	 numbers.  find_pc_line handles this.  */
d2363 1
a2363 1
	
d2373 2
a2374 2
	 set, we stop the step so that the user has a chance to switch
	 in assembly mode.  */
d2384 3
a2386 2
	 which the caller will resume).  */
      insert_step_resume_breakpoint (get_prev_frame (get_current_frame ()), ecs);
d2449 2
a2450 2
	  insert_step_resume_breakpoint (get_prev_frame (get_current_frame ()),
					 ecs);
d2528 9
a2536 9
     if (step-ID == current-ID)
       still stepping in same function;
     else if (step-ID == unwind (current-ID))
       stepped into a function;
     else
       stepped out of a function;
     /* Of course this assumes that the frame ID unwind code is robust
        and we're willing to introduce frame unwind logic into this
        function.  Fortunately, those days are nearly upon us.  */
d2589 1
a2589 1
     
d2599 1
a2599 1
     
d2604 1
a2604 1
	                                     ecs->stop_func_start);
d2986 2
a2987 2
		 (or should) carry around the function and does (or
		 should) use that when doing a frame comparison.  */
@


1.172
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d3494 1
a3494 1
  int size = DEPRECATED_REGISTER_RAW_SIZE (regno);
@


1.171
log
@2004-07-23  Andrew Cagney  <cagney@@gnu.org>

	* infrun.c (handle_inferior_event): Separate the STEP_OVER_ALL and
	DEPRECATED_IGNORE_HELPER_CALL cases, only #ifdef the latter.
@
text
@d487 9
a495 8
  /* NOTE: cagney/2002-03-17: The add_show_from_set() function clones
     the set command passed as a parameter.  The clone operation will
     include (BUG?) any ``set'' command callback, if present.
     Commands like ``info set'' call all the ``show'' command
     callbacks.  Unfortunately, for ``show'' commands cloned from
     ``set'', this includes callbacks belonging to ``set'' commands.
     Making this worse, this only occures if add_show_from_set() is
     called after add_cmd_sfunc() (BUG?).  */
d3888 1
a3888 1
  add_show_from_set
d3907 1
a3907 1
  add_show_from_set (c, &showlist);
d3919 1
a3919 1
  add_show_from_set (c, &showlist);
d3927 1
a3927 1
  add_show_from_set (c, &showlist);
@


1.170
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	* config/mips/tm-mips.h (DEPRECATED_IGNORE_HELPER_CALL): Deprecate.
	* mips-tdep.c (mips_dump_tdep, mips_ignore_helper): Update.
	* infrun.c (DEPRECATED_IGNORE_HELPER_CALL): Delete macro.
	(handle_inferior_event): Wrap call to deprecated
	IGNORE_HELPER_CALL in #ifdef.
	* config/mips/tm-nbsd.h: Update.
@
text
@d2347 1
a2347 2
      if (step_over_calls == STEP_OVER_ALL
	  || DEPRECATED_IGNORE_HELPER_CALL (stop_pc))
d2358 10
@


1.169
log
@2004-07-16  Andrew Cagney  <cagney@@gnu.org>

	* infrun.c (insert_step_resume_breakpoint): Delete gdb_assert
	calls, no longer applicable.  Update comments and rename parameter
	"step_frame" to "return_frame".
@
text
@a163 8
/* On MIPS16, a function that returns a floating point value may call
   a library helper function to copy the return value to a floating point
   register.  The IGNORE_HELPER_CALL macro returns non-zero if we
   should ignore (i.e. step over) this function call.  */
#ifndef IGNORE_HELPER_CALL
#define IGNORE_HELPER_CALL(pc)	0
#endif

d2336 13
a2348 1
      if (step_over_calls == STEP_OVER_ALL || IGNORE_HELPER_CALL (stop_pc))
d2358 2
a2359 1
      
@


1.168
log
@
2004-06-22  Jeff Johnston  <jjohnstn@@redhat.com>

        * infrun.c (handle_inferior_event): Initialize stopped_by_watchpoint
        to -1.
        * breakpoint.c (bpstat_stop_status): Move check for ignoring
        untriggered watchpoints to a separate if clause.  Update function
        comment regarding STOPPED_BY_WATCHPOINT argument.
@
text
@d2662 13
a2674 4
/* The inferior, as a result of a function call (has left) or signal
   (about to leave) the single-step range.  Set a momentary breakpoint
   within the step range where the inferior is expected to later
   return.  */
d2677 1
a2677 1
insert_step_resume_breakpoint (struct frame_info *step_frame,
a2681 10
  /* This is only used within the step-resume range/frame.  */
  gdb_assert (frame_id_eq (step_frame_id, get_frame_id (step_frame)));
  gdb_assert (step_range_end != 0);
  /* Remember, if the call instruction is the last in the step range,
     the breakpoint will land just beyond that.  Hence ``<=
     step_range_end''.  Also, ignore check when "nexti".  */
  gdb_assert (step_range_start == step_range_end
	      || (get_frame_pc (step_frame) >= step_range_start
		  && get_frame_pc (step_frame) <= step_range_end));

d2684 1
a2684 1
  sr_sal.pc = ADDR_BITS_REMOVE (get_frame_pc (step_frame));
d2690 1
a2690 1
    = set_momentary_breakpoint (sr_sal, get_frame_id (step_frame),
@


1.168.2.1
log
@2004-07-16  Andrew Cagney  <cagney@@gnu.org>

	* infrun.c (insert_step_resume_breakpoint): Delete gdb_assert
	calls, no longer applicable.  Update comments and rename parameter
	"step_frame" to "return_frame".
@
text
@d2662 4
a2665 13
/* Insert a "step resume breakpoint" at RETURN_FRAME.pc.  This is used
   to skip a function (next, skip-no-debug) or signal.  It's assumed
   that the function/signal handler being skipped eventually returns
   to the breakpoint inserted at RETURN_FRAME.pc.

   For the skip-function case, the function may have been reached by
   either single stepping a call / return / signal-return instruction,
   or by hitting a breakpoint.  In all cases, the RETURN_FRAME belongs
   to the skip-function's caller.

   For the signals case, this is called with the interrupted
   function's frame.  The signal handler, when it returns, will resume
   the interrupted function at RETURN_FRAME.pc.  */
d2668 1
a2668 1
insert_step_resume_breakpoint (struct frame_info *return_frame,
d2673 10
d2685 1
a2685 1
  sr_sal.pc = ADDR_BITS_REMOVE (get_frame_pc (return_frame));
d2691 1
a2691 1
    = set_momentary_breakpoint (sr_sal, get_frame_id (return_frame),
@


1.167
log
@2004-06-18  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_FUNCTION_START_OFFSET): Deprecated.
	* gdbarch.h, gdbarch.c: Re-generate.
	* ada-lang.c (ada_finish_decode_line_1): Update.
	* infrun.c (handle_inferior_event): Update.
	* infcall.c (find_function_addr): Update.
	* linespec.c (minsym_found): Update.
	* symtab.c (find_function_start_sal, skip_prologue_using_sal):
	Update.
	* blockframe.c (legacy_frameless_look_for_prologue): Update.
	* cli/cli-cmds.c (disassemble_command): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.

Index: doc/ChangeLog
2004-06-18  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	FUNCTION_START_OFFSET.
@
text
@d1255 1
a1255 1
  int stopped_by_watchpoint = 0;
@


1.166
log
@2004-06-11  Randolph Chung  <tausq@@debian.org>

	* infrun.c (handle_inferior_event): Handle the case when a trampoline
	ends up in the runtime resolver, and if the trampoline has no name.
	Rearrange the code so that all the trampoline processing happens before
	other step-out-of-range handling.
@
text
@d1820 1
a1820 1
  ecs->stop_func_start += FUNCTION_START_OFFSET;
@


1.165
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* infrun.c (trap_expected_after_continue): Remove HP_OS_BUG workaround.
	(proceed, init_wait_for_inferior, handle_inferior_event): Likewise.
@
text
@a2321 30
  if (step_over_calls == STEP_OVER_UNDEBUGGABLE
      && ecs->stop_func_name == NULL)
    {
      /* The inferior just stepped into, or returned to, an
         undebuggable function (where there is no symbol, not even a
         minimal symbol, corresponding to the address where the
         inferior stopped).  Since we want to skip this kind of code,
         we keep going until the inferior returns from this
         function.  */
      if (step_stop_if_no_debug)
	{
	  /* If we have no line number and the step-stop-if-no-debug
	     is set, we stop the step so that the user has a chance to
	     switch in assembly mode.  */
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}
      else
	{
	  /* Set a breakpoint at callee's return address (the address
	     at which the caller will resume).  */
	  insert_step_resume_breakpoint (get_prev_frame (get_current_frame ()),
					 ecs);
	  keep_going (ecs);
	  return;
	}
    }

d2366 16
a2416 14
  /* We've wandered out of the step range.  */

  ecs->sal = find_pc_line (stop_pc, 0);

  if (step_range_end == 1)
    {
      /* It is stepi or nexti.  We always want to stop stepping after
         one instruction.  */
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }

d2449 45
@


1.164
log
@
2004-06-04  Jeff Johnston  <jjohnstn@@redhat.com>

        * infrun.c (handle_inferior_event): Don't treat an invalid ptid
        as a new thread event.
        * thread_db.c (thread_get_info_callback): If the thread is a
        zombie, return TD_THR_ZOMBIE.
        * (thread_from_lwp): If thread_get_info_callback returns
        TD_THR_ZOMBIE, check if the thread is still on the thread list
        and return a -1 ptid if not found.
        (thread_db_wait): If thread_from_lwp returns a -1 ptid, then
        change the status to TARGET_WAITKIND_SPURIOUS.
@
text
@a264 8
#ifdef HP_OS_BUG
/* Nonzero if the next time we try to continue the inferior, it will
   step one instruction and generate a spurious trace trap.
   This is used to compensate for a bug in HP-UX.  */

static int trap_expected_after_continue;
#endif

a762 12
#ifdef HP_OS_BUG
  if (trap_expected_after_continue)
    {
      /* If (step == 0), a trap will be automatically generated after
         the first instruction is executed.  Force step one
         instruction to clear this condition.  This should not occur
         if step is nonzero, but it is harmless in that case.  */
      oneproc = 1;
      trap_expected_after_continue = 0;
    }
#endif /* HP_OS_BUG */

a862 3
#ifdef HP_OS_BUG
  trap_expected_after_continue = 0;
#endif
a1999 3
#ifdef HP_OS_BUG
	trap_expected_after_continue = 1;
#endif
@


1.163
log
@2004-05-14  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (handle_inferior_event): Simplify
	STEP_OVER_UNDEBUGGABLE.
@
text
@d1335 1
@


1.162
log
@2004-05-14  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (handle_step_into_function): Delete function.
	(handle_inferior_event): Inline calls to
	handle_step_into_function.
@
text
@d2356 1
a2356 8
      /* NOTE: cagney/2004-05-12: This test is performed after the
	 sigtramp test as often sigtramps, while recognized by GDB,
	 have no symbol information.  */
      CORE_ADDR real_stop_pc;
	
      if ((step_over_calls == STEP_OVER_NONE)
	  || ((step_range_end == 1)
	      && in_prologue (prev_pc, ecs->stop_func_start)))
d2358 3
a2360 6
	  /* I presume that step_over_calls is only 0 when we're
	     supposed to be stepping at the assembly language level
	     ("stepi").  Just stop.  */
	  /* Also, maybe we just did a "nexti" inside a prolog, so we
	     thought it was a subroutine call but it was not.  Stop as
	     well.  FENN */
d2366 1
a2366 2
	
      if (step_over_calls == STEP_OVER_ALL || IGNORE_HELPER_CALL (stop_pc))
d2368 2
a2369 3
	  /* We're doing a "next", set a breakpoint at callee's return
	     address (the address at which the caller will
	     resume).  */
a2374 45
      
      /* If we are in a function call trampoline (a stub between the
	 calling routine and the real function), locate the real
	 function.  That's what tells us (a) whether we want to step
	 into it at all, and (b) what prologue we want to run to the
	 end of, if we do step into it.  */
      real_stop_pc = skip_language_trampoline (stop_pc);
      if (real_stop_pc == 0)
	real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
      if (real_stop_pc != 0)
	ecs->stop_func_start = real_stop_pc;
      
      /* If we have line number information for the function we are
	 thinking of stepping into, step into it.

	 If there are several symtabs at that PC (e.g. with include
	 files), just want to know whether *any* of them have line
	 numbers.  find_pc_line handles this.  */
      {
	struct symtab_and_line tmp_sal;
	
	tmp_sal = find_pc_line (ecs->stop_func_start, 0);
	if (tmp_sal.line != 0)
	  {
	    step_into_function (ecs);
	    return;
	  }
      }
      
      /* If we have no line number and the step-stop-if-no-debug is
	 set, we stop the step so that the user has a chance to switch
	 in assembly mode.  */
      if (step_over_calls == STEP_OVER_UNDEBUGGABLE && step_stop_if_no_debug)
	{
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}
      
      /* Set a breakpoint at callee's return address (the address at
	 which the caller will resume).  */
      insert_step_resume_breakpoint (get_prev_frame (get_current_frame ()), ecs);
      keep_going (ecs);
      return;
@


1.161
log
@2004-05-13  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (handle_inferior_event): Check for
	STEP_OVER_UNDEBUGGABLE after signal trampolines and function
	calls.  Update comments.
@
text
@a965 1
static void handle_step_into_function (struct execution_control_state *ecs);
a1176 80
/* Handle the inferior event in the cases when we just stepped
   into a function.  */

static void
handle_step_into_function (struct execution_control_state *ecs)
{
  CORE_ADDR real_stop_pc;

  if ((step_over_calls == STEP_OVER_NONE)
      || ((step_range_end == 1)
          && in_prologue (prev_pc, ecs->stop_func_start)))
    {
      /* I presume that step_over_calls is only 0 when we're
         supposed to be stepping at the assembly language level
         ("stepi").  Just stop.  */
      /* Also, maybe we just did a "nexti" inside a prolog,
         so we thought it was a subroutine call but it was not.
         Stop as well.  FENN */
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }

  if (step_over_calls == STEP_OVER_ALL || IGNORE_HELPER_CALL (stop_pc))
    {
      /* We're doing a "next", set a breakpoint at callee's return
	 address (the address at which the caller will resume).  */
      insert_step_resume_breakpoint (get_prev_frame (get_current_frame ()),
				     ecs);
      keep_going (ecs);
      return;
    }

  /* If we are in a function call trampoline (a stub between
     the calling routine and the real function), locate the real
     function.  That's what tells us (a) whether we want to step
     into it at all, and (b) what prologue we want to run to
     the end of, if we do step into it.  */
  real_stop_pc = skip_language_trampoline (stop_pc);
  if (real_stop_pc == 0)
    real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
  if (real_stop_pc != 0)
    ecs->stop_func_start = real_stop_pc;

  /* If we have line number information for the function we
     are thinking of stepping into, step into it.

     If there are several symtabs at that PC (e.g. with include
     files), just want to know whether *any* of them have line
     numbers.  find_pc_line handles this.  */
  {
    struct symtab_and_line tmp_sal;

    tmp_sal = find_pc_line (ecs->stop_func_start, 0);
    if (tmp_sal.line != 0)
      {
        step_into_function (ecs);
        return;
      }
  }

  /* If we have no line number and the step-stop-if-no-debug
     is set, we stop the step so that the user has a chance to
     switch in assembly mode.  */
  if (step_over_calls == STEP_OVER_UNDEBUGGABLE && step_stop_if_no_debug)
    {
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }

  /* Set a breakpoint at callee's return address (the address at which
     the caller will resume).  */
  insert_step_resume_breakpoint (get_prev_frame (get_current_frame ()), ecs);
  keep_going (ecs);
  return;
}

d2359 72
a2430 1
      handle_step_into_function (ecs);
d2438 72
a2509 1
      handle_step_into_function (ecs);
@


1.160
log
@2004-05-13  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (handle_inferior_event): Use frame_unwind_id.

Index: infrun.c
===================================================================
RCS file: /cvs/src/src/gdb/infrun.c,v
retrieving revision 1.159
diff -p -u -r1.159 infrun.c
--- infrun.c	13 May 2004 16:39:11 -0000	1.159
+++ infrun.c	13 May 2004 18:37:09 -0000
@@@@ -2437,7 +2437,7 @@@@ process_event_stop_test:
       return;
     }

-  if (frame_id_eq (get_frame_id (get_prev_frame (get_current_frame ())),
+  if (frame_id_eq (frame_unwind_id (get_current_frame ()),
                    step_frame_id))
     {
       /* It's a subroutine call.  */
@
text
@a2413 12
  if (step_over_calls == STEP_OVER_UNDEBUGGABLE
      && ecs->stop_func_name == NULL)
    {
      /* There is no symbol, not even a minimal symbol, corresponding
         to the address where we just stopped.  So we just stepped
         inside undebuggable code.  Since we want to step over this
         kind of code, we keep going until the inferior returns from
         the current function.  */
      handle_step_into_function (ecs);
      return;
    }

d2425 16
@


1.159
log
@	* breakpoint.c (bpstat_stop_status): Add new argument
	STOPPED_BY_WATCHPOINT.  Use it instead of testing
	target_stopped_data_address agaist 0 to check whether
	or not we stopped due to a hardware watchpoint.
	* breakpoint.h (bpstat_stop_status): Adapt prototype.
	* infrun.c (handle_inferior_event): Call bpstat_stop_status
	with new argument.
@
text
@d2440 1
a2440 1
  if (frame_id_eq (get_frame_id (get_prev_frame (get_current_frame ())),
@


1.158
log
@2004-05-12  Andrew Cagney  <cagney@@redhat.com>

	* thread.c (load_infrun_state): Delete step_sp.
	* infrun.c (context_switch): Ditto.
	* inferior.h (step_sp): Ditto.
	* infcmd.c (step_sp, step_1, step_once, until_next_command): Ditto.
	* gdbthread.h (struct thread_info, save_infrun_state)
	(restore_infrun_state): Ditto.
@
text
@d1359 1
d1549 1
a1549 1
      stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);
d1598 1
a1598 1
      stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);
d1914 1
a1914 1
    STOPPED_BY_WATCHPOINT (ecs->ws);
d1994 2
a1995 1
	  stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);
@


1.157
log
@2004-05-12  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (adjust_pc_after_break): Rewrite decr logic,
	eliminate reference to step_sp.
	(struct execution_control_state, init_execution_control_state)
	(handle_inferior_event, keep_going): Delete update_step_sp and
	step_sp.
	* infcmd.c (step_sp): Note that variable is unused.
@
text
@d1162 1
a1162 1
			 ecs->current_line, ecs->current_symtab, step_sp);
d1173 1
a1173 1
			 &ecs->current_line, &ecs->current_symtab, &step_sp);
@


1.156
log
@2004-05-11  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (step_over_function): Delete function.
	(handle_step_into_function): Use insert_step_resume_breakpoint.
	(insert_step_resume_breakpoint): Fix assertion.
@
text
@a952 1
  int update_step_sp;
a1103 1
  ecs->update_step_sp = 0;
d1261 1
a1261 1
  CORE_ADDR stop_pc;
d1295 47
a1341 34
  /* Find the location where (if we've hit a breakpoint) the breakpoint would
     be.  */
  stop_pc = read_pc_pid (ecs->ptid) - DECR_PC_AFTER_BREAK;

  /* If we're software-single-stepping, then assume this is a breakpoint.
     NOTE drow/2004-01-17: This doesn't check that the PC matches, or that
     we're even in the right thread.  The software-single-step code needs
     some modernization.

     If we're not software-single-stepping, then we first check that there
     is an enabled software breakpoint at this address.  If there is, and
     we weren't using hardware-single-step, then we've hit the breakpoint.

     If we were using hardware-single-step, we check prev_pc; if we just
     stepped over an inserted software breakpoint, then we should decrement
     the PC and eventually report hitting the breakpoint.  The prev_pc check
     prevents us from decrementing the PC if we just stepped over a jump
     instruction and landed on the instruction after a breakpoint.

     The last bit checks that we didn't hit a breakpoint in a signal handler
     without an intervening stop in sigtramp, which is detected by a new
     stack pointer value below any usual function calling stack adjustments.

     NOTE drow/2004-01-17: I'm not sure that this is necessary.  The check
     predates checking for software single step at the same time.  Also,
     if we've moved into a signal handler we should have seen the
     signal.  */

  if ((SOFTWARE_SINGLE_STEP_P () && singlestep_breakpoints_inserted_p)
      || (software_breakpoint_inserted_here_p (stop_pc)
	  && !(currently_stepping (ecs)
	       && prev_pc != stop_pc
	       && !(step_range_end && INNER_THAN (read_sp (), (step_sp - 16))))))
    write_pc_pid (stop_pc, ecs->ptid);
a2423 5
  /* We can't update step_sp every time through the loop, because
     reading the stack pointer would slow down stepping too much.
     But we can update it every time we leave the step range.  */
  ecs->update_step_sp = 1;

a2711 4

  if (ecs->update_step_sp)
    step_sp = read_sp ();
  ecs->update_step_sp = 0;
@


1.155
log
@2004-05-11  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (handle_inferior_event): Simplify code handling
	step-into or return-from a signal trampoline.

Index: testsuite/ChangeLog
2004-05-11  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/sigstep.exp (advancei): Update KFAILs.  gdb/1613 is
	fixed but revealed gdb/1639.
@
text
@a970 1
static void step_over_function (struct execution_control_state *ecs);
d1206 4
a1209 2
      /* We're doing a "next".  */
      step_over_function (ecs);
d1253 3
a1255 1
  step_over_function (ecs);
d2668 6
a2673 2
  gdb_assert (get_frame_pc (step_frame) >= step_range_start
	      && get_frame_pc (step_frame) < step_range_end);
a2684 77

  if (breakpoints_inserted)
    insert_breakpoints ();
}

/* We've just entered a callee, and we wish to resume until it returns
   to the caller.  Setting a step_resume breakpoint on the return
   address will catch a return from the callee.
     
   However, if the callee is recursing, we want to be careful not to
   catch returns of those recursive calls, but only of THIS instance
   of the caller.

   To do this, we set the step_resume bp's frame to our current
   caller's frame (obtained by doing a frame ID unwind).  */

static void
step_over_function (struct execution_control_state *ecs)
{
  struct symtab_and_line sr_sal;
  struct frame_id sr_id;

  init_sal (&sr_sal);		/* initialize to zeros */

  /* NOTE: cagney/2003-04-06:

     At this point the equality get_frame_pc() == get_frame_func()
     should hold.  This may make it possible for this code to tell the
     frame where it's function is, instead of the reverse.  This would
     avoid the need to search for the frame's function, which can get
     very messy when there is no debug info available (look at the
     heuristic find pc start code found in targets like the MIPS).  */

  /* NOTE: cagney/2003-04-06:

     The intent of DEPRECATED_SAVED_PC_AFTER_CALL was to:

     - provide a very light weight equivalent to frame_unwind_pc()
     (nee FRAME_SAVED_PC) that avoids the prologue analyzer

     - avoid handling the case where the PC hasn't been saved in the
     prologue analyzer

     Unfortunately, not five lines further down, is a call to
     get_frame_id() and that is guarenteed to trigger the prologue
     analyzer.
     
     The `correct fix' is for the prologe analyzer to handle the case
     where the prologue is incomplete (PC in prologue) and,
     consequently, the return pc has not yet been saved.  It should be
     noted that the prologue analyzer needs to handle this case
     anyway: frameless leaf functions that don't save the return PC;
     single stepping through a prologue.

     The d10v handles all this by bailing out of the prologue analsis
     when it reaches the current instruction.  */

  if (DEPRECATED_SAVED_PC_AFTER_CALL_P ())
    sr_sal.pc = ADDR_BITS_REMOVE (DEPRECATED_SAVED_PC_AFTER_CALL (get_current_frame ()));
  else
    sr_sal.pc = ADDR_BITS_REMOVE (frame_pc_unwind (get_current_frame ()));
  sr_sal.section = find_pc_overlay (sr_sal.pc);

  check_for_old_step_resume_breakpoint ();

  /* NOTE: cagney/2004-03-31: Code using the current value of
     "step_frame_id", instead of unwinding that frame ID, removed.  On
     s390 GNU/Linux, after taking a signal, the program is directly
     resumed at the signal handler and, consequently, the PC would
     point at at the first instruction of that signal handler but
     STEP_FRAME_ID would [incorrectly] at the interrupted code when it
     should point at the signal trampoline.  By always and locally
     doing a frame ID unwind, it's possible to assert that the code is
     always using the correct ID.  */
  sr_id = frame_unwind_id (get_current_frame ());

  step_resume_breakpoint = set_momentary_breakpoint (sr_sal, sr_id, bp_step_resume);
@


1.154
log
@2004-05-10  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (through_sigtramp_breakpoint): Delete variable.
	(context_switch): Do not switch through_sigtramp_breakpoint.
	* gdbthread.h (save_infrun_state, load_infrun_state)
	(struct thread_info): Delete through_sigtramp_breakpoint parameter
	and structure member.
	* thread.c (load_infrun_state, save_infrun_state): Update.
@
text
@d2415 4
a2418 4
  /* Did we just step into a singal trampoline (either by stepping out
     of a handler, or by taking a signal)?  */
  if (get_frame_type (get_current_frame ()) == SIGTRAMP_FRAME
      && !frame_id_eq (get_frame_id (get_current_frame ()), step_frame_id))
d2420 5
a2424 64
      {
	struct frame_id current_frame = get_frame_id (get_current_frame ());

	if (frame_id_inner (current_frame, step_frame_id))
	  {
	    /* We have just taken a signal; go until we are back to
	       the point where we took it and one more.  */

	    /* This code is needed at least in the following case:
	       The user types "next" and then a signal arrives (before
	       the "next" is done).  */

	    /* Note that if we are stopped at a breakpoint, then we need
	       the step_resume breakpoint to override any breakpoints at
	       the same location, so that we will still step over the
	       breakpoint even though the signal happened.  */
	    struct symtab_and_line sr_sal;

	    init_sal (&sr_sal);
	    sr_sal.symtab = NULL;
	    sr_sal.line = 0;
	    sr_sal.pc = prev_pc;
	    /* We could probably be setting the frame to
	       step_frame_id; I don't think anyone thought to try it.  */
	    check_for_old_step_resume_breakpoint ();
	    step_resume_breakpoint =
	      set_momentary_breakpoint (sr_sal, null_frame_id, bp_step_resume);
	    if (breakpoints_inserted)
	      insert_breakpoints ();
	  }
	else
	  {
	    /* We just stepped out of a signal handler and into
	       its calling trampoline.

	       Normally, we'd call step_over_function from
	       here, but for some reason GDB can't unwind the
	       stack correctly to find the real PC for the point
	       user code where the signal trampoline will return
	       -- FRAME_SAVED_PC fails, at least on HP-UX 10.20.
	       But signal trampolines are pretty small stubs of
	       code, anyway, so it's OK instead to just
	       single-step out.  Note: assuming such trampolines
	       don't exhibit recursion on any platform... */
	    find_pc_partial_function (stop_pc, &ecs->stop_func_name,
				      &ecs->stop_func_start,
				      &ecs->stop_func_end);
	    /* Readjust stepping range */
	    step_range_start = ecs->stop_func_start;
	    step_range_end = ecs->stop_func_end;
	    ecs->stepping_through_sigtramp = 1;
	  }
      }


      /* If this is stepi or nexti, make sure that the stepping range
         gets us past that instruction.  */
      if (step_range_end == 1)
	/* FIXME: Does this run afoul of the code below which, if
	   we step into the middle of a line, resets the stepping
	   range?  */
	step_range_end = (step_range_start = prev_pc) + 1;

      ecs->remove_breakpoints_on_following_step = 1;
@


1.153
log
@2004-05-10  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (check_sigtramp2): Delete function.
	(handle_inferior_event): When single stepping, and taking a
	signal, set a breakpoint at the signal return address.  Delete
	redundant calls to check_sigtramp2.
	(insert_step_resume_breakpoint): New function.
	(through_sigtramp_breakpoint, handle_inferior_event)
	(follow_exec, wait_for_inferior, fetch_inferior_event)
	(currently_stepping, keep_going): Delete most uses of
	through_sigtramp_breakpoint, not that it should be deleted.
	(delete_breakpoint_current_contents): Delete function.

Index: testsuite/ChangeLog
2004-05-10  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/signals.exp (signal_tests_1): Simplify "continue to
	func1" and "next to 2nd alarm", kernel bug avoided.
@
text
@a305 3
/* NOTE: cagney/2004-05-08: This variable needs to be garbage
   collected, it isn't used.  */
static struct breakpoint *through_sigtramp_breakpoint = NULL;
d1159 1
a1159 1
			 through_sigtramp_breakpoint, step_range_start,
d1170 1
a1170 1
			 &through_sigtramp_breakpoint, &step_range_start,
@


1.152
log
@2004-05-08  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (resume): Delete call to DO_DEFERRED_STORES.
	* target.c (target_detach, target_disconnect): Ditto.

2004-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	description of DO_DEFERRED_STORES.
@
text
@a62 2
static void delete_breakpoint_current_contents (void *);

d306 2
a425 3
  /* If there was one, it's gone now. */
  through_sigtramp_breakpoint = NULL;

a904 11

static void
delete_breakpoint_current_contents (void *arg)
{
  struct breakpoint **breakpointp = (struct breakpoint **) arg;
  if (*breakpointp != NULL)
    {
      delete_breakpoint (*breakpointp);
      *breakpointp = NULL;
    }
}
a972 1
static void check_sigtramp2 (struct execution_control_state *ecs);
d975 2
a997 2
  make_cleanup (delete_breakpoint_current_contents,
		&through_sigtramp_breakpoint);
a1057 2
      make_exec_cleanup (delete_breakpoint_current_contents,
			 &through_sigtramp_breakpoint);
d1975 3
a1977 9
      /* Don't even think about breakpoints
         if just proceeded over a breakpoint.

         However, if we are trying to proceed over a breakpoint
         and end up in sigtramp, then through_sigtramp_breakpoint
         will be set and we should check whether we've hit the
         step breakpoint.  */
      if (stop_signal == TARGET_SIGNAL_TRAP && trap_expected
	  && through_sigtramp_breakpoint == NULL)
d2060 16
a2075 33
      /* I'm not sure whether this needs to be check_sigtramp2 or
         whether it could/should be keep_going.

         This used to jump to step_over_function if we are stepping,
         which is wrong.

         Suppose the user does a `next' over a function call, and while
         that call is in progress, the inferior receives a signal for
         which GDB does not stop (i.e., signal_stop[SIG] is false).  In
         that case, when we reach this point, there is already a
         step-resume breakpoint established, right where it should be:
         immediately after the function call the user is "next"-ing
         over.  If we call step_over_function now, two bad things
         happen:

         - we'll create a new breakpoint, at wherever the current
         frame's return address happens to be.  That could be
         anywhere, depending on what function call happens to be on
         the top of the stack at that point.  Point is, it's probably
         not where we need it.

         - the existing step-resume breakpoint (which is at the correct
         address) will get orphaned: step_resume_breakpoint will point
         to the new breakpoint, and the old step-resume breakpoint
         will never be cleaned up.

         The old behavior was meant to help HP-UX single-step out of
         sigtramps.  It would place the new breakpoint at prev_pc, which
         was certainly wrong.  I don't know the details there, so fixing
         this probably breaks that.  As with anything else, it's up to
         the HP-UX maintainer to furnish a fix that doesn't break other
         platforms.  --JimB, 20 May 1999 */
      check_sigtramp2 (ecs);
a2115 7
	/* Not sure whether we need to blow this away too, but probably
	   it is like the step-resume breakpoint.  */
	if (through_sigtramp_breakpoint != NULL)
	  {
	    delete_breakpoint (through_sigtramp_breakpoint);
	    through_sigtramp_breakpoint = NULL;
	  }
d2163 2
a2164 3
	/* We are about to nuke the step_resume_breakpoint and
	   through_sigtramp_breakpoint via the cleanup chain, so
	   no need to worry about it here.  */
d2172 2
a2173 3
	/* We are about to nuke the step_resume_breakpoint and
	   through_sigtramp_breakpoint via the cleanup chain, so
	   no need to worry about it here.  */
a2204 4
	if (through_sigtramp_breakpoint)
	  delete_breakpoint (through_sigtramp_breakpoint);
	through_sigtramp_breakpoint = NULL;

a2347 3
      /* I'm not sure whether this needs to be check_sigtramp2 or
         whether it could/should be keep_going.  */
      check_sigtramp2 (ecs);
a2354 3
      /* I'm not sure whether this needs to be check_sigtramp2 or
         whether it could/should be keep_going.  */
      check_sigtramp2 (ecs);
a2365 3
      /* We might be doing a BPSTAT_WHAT_SINGLE and getting a signal.
         So definately need to check for sigtramp here.  */
      check_sigtramp2 (ecs);
d2629 1
a2629 2
  return ((through_sigtramp_breakpoint == NULL
	   && !ecs->handling_longjmp
a2635 36
static void
check_sigtramp2 (struct execution_control_state *ecs)
{
  char *name;
  struct symtab_and_line sr_sal;

  /* Check that what has happened here is that we have just stepped
     the inferior with a signal (because it is a signal which
     shouldn't make us stop), thus stepping into sigtramp.  */

  if (!trap_expected)
    return;
  if (get_frame_type (get_current_frame ()) != SIGTRAMP_FRAME)
    return;

  /* So we need to set a step_resume_break_address breakpoint and
     continue until we hit it, and then step.  FIXME: This should be
     more enduring than a step_resume breakpoint; we should know that
     we will later need to keep going rather than re-hitting the
     breakpoint here (see the testsuite, gdb.base/signals.exp where it
     says "exceedingly difficult").  */

  init_sal (&sr_sal);	/* initialize to zeroes */
  sr_sal.pc = prev_pc;
  sr_sal.section = find_pc_overlay (sr_sal.pc);
  /* We perhaps could set the frame if we kept track of what the frame
     corresponding to prev_pc was.  But we don't, so don't.  */
  through_sigtramp_breakpoint =
    set_momentary_breakpoint (sr_sal, null_frame_id, bp_through_sigtramp);
  if (breakpoints_inserted)
    insert_breakpoints ();

  ecs->remove_breakpoints_on_following_step = 1;
  ecs->another_trap = 1;
}

d2713 32
a2868 1
	  && through_sigtramp_breakpoint == NULL
d2875 1
a2875 2
      else if (!breakpoints_inserted &&
	       (through_sigtramp_breakpoint != NULL || !ecs->another_trap))
@


1.151
log
@2004-05-01  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (check_sigtramp2): Delete check for
	DEPRECATED_PC_IN_SIGTRAMP and INNER_THAN.
@
text
@a574 5
  /* Handle any optimized stores to the inferior NOW...  */
#ifdef DO_DEFERRED_STORES
  DO_DEFERRED_STORES;
#endif

@


1.150
log
@2004-04-29  Joel Brobecker  <brobecker@@gnat.com>

	Committed by Andrew Cagney.
        * infrun.c (handle_inferior_event): Rely on frame IDs to detect
        function calls.
@
text
@a2717 8
  /* Long term, this function can be eliminated, replaced by the code:
     get_frame_type(current_frame()) == SIGTRAMP_FRAME (for new
     architectures this is very cheap).  */
  find_pc_partial_function (prev_pc, &name, NULL, NULL);
  if (DEPRECATED_PC_IN_SIGTRAMP (prev_pc, name))
    return;
  if (!INNER_THAN (read_sp (), step_sp))
    return;
@


1.149
log
@2004-04-28  Andrew Cagney  <cagney@@redhat.com>

	* stack.c (print_stack_frame_stub): Delete declaration.
	(struct print_stack_frame_args, print_stack_frame)
	(print_frame_info, print_frame): Replace "source" with print what.
	Replace "print" with "print_level".  Replace "args" with
	"print_args".
	* frame.h (show_and_print_stack_frame, print_stack_frame)
	(print_frame_info): Update declarations.
	* stack.c (select_and_print_frame, frame_command)
	(current_frame_command, up_command, down_command): Update calls -
	use get_selected_frame, pass "enum print_what" for source, do not
	call frame_relative_level.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames): Ditto.
	* remote-rdp.c (remote_rdp_open): Ditto.
	* remote-mips.c (common_open): Ditto.
	* remote-e7000.c (e7000_start_remote): Ditto.
	* ocd.c (ocd_start_remote): Ditto.
	* mi/mi-main.c (mi_cmd_exec_return): Ditto.
	* infrun.c (normal_stop): Ditto.
	* inflow.c (kill_command): Ditto.
	* infcmd.c (finish_command): Ditto.
	* corelow.c (core_open): Ditto.
	* tracepoint.c (finish_tfind_command): Ditto.
	* thread.c (info_threads_command, info_threads_command)
	(restore_current_thread, do_captured_thread_select): Ditto.
	* ada-tasks.c (task_command): Ditto.
@
text
@d2468 12
d2558 2
a2559 5
  if (((stop_pc == ecs->stop_func_start	/* Quick test */
	|| in_prologue (stop_pc, ecs->stop_func_start))
       && !IN_SOLIB_RETURN_TRAMPOLINE (stop_pc, ecs->stop_func_name))
      || IN_SOLIB_CALL_TRAMPOLINE (stop_pc, ecs->stop_func_name)
      || ecs->stop_func_name == 0)
@


1.148
log
@2004-04-26  Orjan Friberg <orjanf@@axis.com>

	From Paul Koning <pkoning@@equallogic.com>:
	* breakpoint.c (free_valchain): New function.
	(insert_bp_location, delete_breakpoint): Use free_valchain.
	(remove_breakpoint): Do not remove the valchain.
	(bpstat_stop_status): If not stopped by watchpoint, skip
	watchpoints when generating stop status list.
	* infrun.c (handle_inferior_event): Make
	stepped_after_stopped_by_watchpoint a global variable.
	* remote.c (remote_stopped_data_address): Return watch data
	address rather than zero if stepped_after_stopped_by_watchpoint is
	set.
@
text
@d3251 1
a3251 1
	    print_stack_frame (deprecated_selected_frame, -1, source_flag);
@


1.147
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d1359 2
a1368 1
  int stepped_after_stopped_by_watchpoint;
@


1.146
log
@2004-04-15  Andrew Cagney  <cagney@@redhat.com>

	* observer.c (normal_stop_subject, observer_notify_normal_stop)
	(observer_normal_stop_notification_stub)
	(observer_attach_normal_stop, observer_detach_normal_stop):
	Delete, replaced by #include "observer.inc".
	* infrun.c (normal_stop): Pass "stop_bpstat" to
	observer_notify_normal_stop.
	* Makefile.in (observer_inc): Define.
	(observer.o): Update dependencies.
	(observer.h, observer.inc): New rules.
	* observer.h: Delete file.
	* observer.sh: New file.

Index: doc/ChangeLog
2004-04-08  Andrew Cagney  <cagney@@redhat.com>

	* observer.texi (GDB Observers): Rework, provide generic observer
	definitions and then a list of observable events.
@
text
@d319 2
a320 2
   returned by target_wait()/target_wait_hook().  This information is
   returned by get_last_target_status(). */
d1041 2
a1042 2
      if (target_wait_hook)
	ecs->ptid = target_wait_hook (ecs->waiton_ptid, ecs->wp);
d1098 1
a1098 1
  if (target_wait_hook)
d1100 1
a1100 1
      target_wait_hook (async_ecs->waiton_ptid, async_ecs->wp);
d1157 3
a1159 3
   target_wait()/target_wait_hook().  The data is actually cached by
   handle_inferior_event(), which gets called immediately after
   target_wait()/target_wait_hook().  */
d1729 2
a1730 2
	  if (context_hook)
	    context_hook (pid_to_thread_id (ecs->ptid));
d1844 2
a1845 2
      if (context_hook)
	context_hook (pid_to_thread_id (ecs->ptid));
@


1.145
log
@2004-04-02  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (pc_in_sigtramp): Delete function.
	(check_sigtramp2): Inline call to pc_in_sigtramp, use
	get_frame_type.
@
text
@d3279 1
a3279 1
  observer_notify_normal_stop ();
@


1.144
log
@2004-04-02  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (handle_step_into_function): Delete code conditional on
	legacy_frame_p.
	(handle_inferior_event, step_over_function): Ditto.
@
text
@a1205 33
/* Wrapper for DEPRECATED_PC_IN_SIGTRAMP that takes care of the need
   to find the function's name.

   In a classic example of "left hand VS right hand", "infrun.c" was
   trying to improve GDB's performance by caching the result of calls
   to calls to find_pc_partial_funtion, while at the same time
   find_pc_partial_function was also trying to ramp up performance by
   caching its most recent return value.  The below makes the the
   function find_pc_partial_function solely responsibile for
   performance issues (the local cache that relied on a global
   variable - arrrggg - deleted).

   Using the testsuite and gcov, it was found that dropping the local
   "infrun.c" cache and instead relying on find_pc_partial_function
   increased the number of calls to 12000 (from 10000), but the number
   of times find_pc_partial_function's cache missed (this is what
   matters) was only increased by only 4 (to 3569).  (A quick back of
   envelope caculation suggests that the extra 2000 function calls
   @@1000 extra instructions per call make the 1 MIP VAX testsuite run
   take two extra seconds, oops :-)

   Long term, this function can be eliminated, replaced by the code:
   get_frame_type(current_frame()) == SIGTRAMP_FRAME (for new
   architectures this is very cheap).  */

static int
pc_in_sigtramp (CORE_ADDR pc)
{
  char *name;
  find_pc_partial_function (pc, &name, NULL, NULL);
  return DEPRECATED_PC_IN_SIGTRAMP (pc, name);
}

d2697 6
a2702 27
  if (trap_expected
      && pc_in_sigtramp (stop_pc)
      && !pc_in_sigtramp (prev_pc)
      && INNER_THAN (read_sp (), step_sp))
    {
      /* What has happened here is that we have just stepped the
         inferior with a signal (because it is a signal which
         shouldn't make us stop), thus stepping into sigtramp.

         So we need to set a step_resume_break_address breakpoint and
         continue until we hit it, and then step.  FIXME: This should
         be more enduring than a step_resume breakpoint; we should
         know that we will later need to keep going rather than
         re-hitting the breakpoint here (see the testsuite,
         gdb.base/signals.exp where it says "exceedingly difficult").  */

      struct symtab_and_line sr_sal;

      init_sal (&sr_sal);	/* initialize to zeroes */
      sr_sal.pc = prev_pc;
      sr_sal.section = find_pc_overlay (sr_sal.pc);
      /* We perhaps could set the frame if we kept track of what the
         frame corresponding to prev_pc was.  But we don't, so don't.  */
      through_sigtramp_breakpoint =
	set_momentary_breakpoint (sr_sal, null_frame_id, bp_through_sigtramp);
      if (breakpoints_inserted)
	insert_breakpoints ();
d2704 32
a2735 3
      ecs->remove_breakpoints_on_following_step = 1;
      ecs->another_trap = 1;
    }
@


1.143
log
@2004-03-31  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (frame_unwind_id): Declare.
	* frame.c (frame_unwind_id): New function.
	(get_prev_frame_1): New function.
	(frame_debug_got_null_frame): New function.
	(get_prev_frame): Use frame_debug_got_null_frame.  Move unwind
	code proper to prev_frame, update description.
	* infrun.c (step_over_function): Use frame_unwind_id.
@
text
@a1265 19

      if (legacy_frame_p (current_gdbarch)
	  && pc_in_sigtramp (stop_pc)
          && frame_id_inner (step_frame_id,
                             frame_id_build (read_sp (), 0)))
	/* NOTE: cagney/2004-03-15: This is only needed for legacy
	   systems.  On non-legacy systems step_over_function doesn't
	   use STEP_FRAME_ID and hence the below update "hack" isn't
	   needed.  */
        /* We stepped out of a signal handler, and into its calling
           trampoline.  This is misdetected as a subroutine call, but
           stepping over the signal trampoline isn't such a bad idea.
           In order to do that, we have to ignore the value in
           step_frame_id, since that doesn't represent the frame
           that'll reach when we return from the signal trampoline.
           Otherwise we'll probably continue to the end of the
           program.  */
        step_frame_id = null_frame_id;

d2507 2
a2508 10
  /* NOTE: cagney/2004-03-16: Replaced (except for legacy) a check for
     "pc_in_sigtramp(stop_pc) != pc_in_sigtramp(step_pc)" with
     frame_type == SIGTRAMP && !frame_id_eq.  The latter is far more
     robust as it will correctly handle nested signal trampolines.  */
  if (legacy_frame_p (current_gdbarch)
      ? (pc_in_sigtramp (stop_pc)
	 && !pc_in_sigtramp (prev_pc)
	 && INNER_THAN (read_sp (), step_sp))
      : (get_frame_type (get_current_frame ()) == SIGTRAMP_FRAME
	 && !frame_id_eq (get_frame_id (get_current_frame ()), step_frame_id)))
d2900 10
a2909 36
  /* NOTE: cagney/2004-03-15: Code using the current value of
     "step_frame_id", instead of unwinding that frame ID, removed (at
     least for non-legacy platforms).  On s390 GNU/Linux, after taking
     a signal, the program is directly resumed at the signal handler
     and, consequently, the PC would point at at the first instruction
     of that signal handler but STEP_FRAME_ID would [incorrectly] at
     the interrupted code when it should point at the signal
     trampoline.  By always and locally doing a frame ID unwind, it's
     possible to assert that the code is always using the correct
     ID.  */
  if (legacy_frame_p (current_gdbarch))
    {
      if (frame_id_p (step_frame_id)
	  && !IN_SOLIB_DYNSYM_RESOLVE_CODE (sr_sal.pc))
	/* NOTE: cagney/2004-02-27: Use the global state's idea of the
	   stepping frame ID.  I suspect this is done as it is lighter
	   weight than a call to get_prev_frame.  */
	/* NOTE: cagney/2004-03-15: See comment above about how this
	   is also broken.  */
	sr_id = step_frame_id;
      else
	/* NOTE: cagney/2004-03-15: This is the way it was 'cos this
	   is the way it always was.  It should be using the unwound
	   (or caller's) ID, and not this (or the callee's) ID.  It
	   appeared to work because: legacy architectures used the
	   wrong end of the frame for the ID.stack (inner-most rather
	   than outer-most) so that the callee's id.stack (un
	   adjusted) matched the caller's id.stack giving the
	   "correct" id; more often than not
	   !IN_SOLIB_DYNSYM_RESOLVE_CODE and hence the code above (it
	   was originally later in the function) fixed the ID by using
	   global state.  */
	sr_id = get_frame_id (get_current_frame ());
    }
  else
    sr_id = frame_unwind_id (get_current_frame ());
@


1.142
log
@2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PC_IN_SIGTRAMP): Change to a function with
	predicate, deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-linux-tdep.c (alpha_linux_init_abi): Update.
	* alpha-osf1-tdep.c (alpha_osf1_init_abi): Update.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Update.
	* alphafbsd-tdep.c (alphafbsd_init_abi): Update.
	* alphanbsd-tdep.c (alphanbsd_init_abi): Update.
	* amd64-linux-tdep.c (amd64_linux_init_abi): Update.
	* amd64-tdep.c (amd64_sigtramp_frame_sniffer): Update.
	* amd64nbsd-tdep.c (amd64nbsd_init_abi): Update.
	* amd64obsd-tdep.c (amd64obsd_init_abi): Update.
	* arm-tdep.c (arm_sigtramp_unwind_sniffer): Update.
	* blockframe.c (find_pc_partial_function): Update.
	* breakpoint.c (bpstat_what): Update.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Update.
	* frv-linux-tdep.c (frv_linux_init_abi): Update.
	* frv-tdep.c (frv_sigtramp_frame_sniffer): Update.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* i386-nto-tdep.c (i386nto_init_abi): Update.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Update.
	* i386-tdep.c (i386_sigtramp_frame_sniffer)
	(i386_svr4_init_abi, i386_go32_init_abi, i386_gdbarch_init): Update.
	* i386bsd-tdep.c (i386bsd_init_abi): Update.
	* i386nbsd-tdep.c (i386nbsd_init_abi): Update.
	* i386obsd-tdep.c (i386obsd_init_abi): Update.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Update.
	* infrun.c (pc_in_sigtramp): Update.
	* m68k-tdep.c (m68k_sigtramp_frame_sniffer): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mipsnbsd-tdep.c (mipsnbsd_init_abi): Update.
	* ppc-linux-tdep.c: Update comment.
	* ppcnbsd-tdep.c (ppcnbsd_init_abi): Update.
	* shnbsd-tdep.c (shnbsd_init_abi): Update.
	* sparc-linux-tdep.c (sparc32_linux_init_abi): Update.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_init_abi): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Update.
	* sparc64obsd-tdep.c (sparc64obsd_init_abi): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_init_abi): Update.
	* sparcobsd-tdep.c (sparc32obsd_init_abi): Update.

Index: doc/ChangeLog
2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	references to PC_IN_SIGTRAMP.
@
text
@d2962 1
a2962 1
    sr_id = get_frame_id (get_prev_frame (get_current_frame ()));
@


1.142.2.1
log
@2004-03-23  Elena Zannoni  <ezannoni@@redhat.com>

       * solib-svr4.c (svr4_solib_create_inferior_hook): Disable
       breakpoints at startup.
       (elf_locate_base): Find out where the entry point for the program
       is, using the auxv vector, if possible. Compute the address of
       .dynamic using it.
       (svr4_current_sos): Don't ignore the first entry if we have PIE,
       it's our main program. Delete code that was skipping over the
       solib entry for main executable.
       * solist.h (struct so_list): Add fields main and main_relocated.
        (add_to_target_sections): Export.
       * solib.c (symbol_add_stub): Handle main executable in shared
       library list. Ignore it if it has been relocated already. Add it
       as the main symbol file, otherwise.
       * infrun.c (handle_inferior_event): Re-enable startup breakpoints.

       * solib-svr4.c (elf_locate_base, first_link_map_member)
       svr4_current_sos, enable_break): Add debugging output.
       * solist.h (debug_solib): Export.
       * solib.c (debug_solib): New variable to enable debugging output.
       (symbol_add_stub, update_solib_list, update_solib_list)
       (add_to_target_sections): Add debugging output.
       (_initialize_solib): Add new comand to enable printing of
       debugging output.
       (add_to_target_sections): New function. Factored out from
       update_solib_list.
       (update_solib_list): Call add_to_target_sections.

       * varobj.h (varobj_refresh): New prototype.
       * varobj.c (varobj_refresh): New function.
       * symfile.c (reread_symbols): Make sure that we recompute the
       entry point for the program.
       (symbol_file_clear): Clear the solibs as well, if we change symbol
       files.
       (clear_symtab_users): Refresh the varobjs that depend on the symtabs
       we are clearing.
       * objfiles.c (entry_point_address): Rewrite, to fetch entry point
       from auxv vector, if possible.
       Add include of elf/common.h.
       * breakpoint.h (enum bptype): Add bp type bp_startup_disabled.
       (re_enable_breakpoints_at_startup)
       (disable_breakpoints_at_startup): Add prototypes
       * breakpoint.c (re_enable_breakpoints_at_startup)
       (disable_breakpoints_at_startup): New functions.
       (describe_other_breakpoints, delete_breakpoint)
       (breakpoint_re_set_one): Handle new bp type.
       * auxv.h (target_auxv_parse, target_auxv_search): Update.
       * auxv.c (target_auxv_parse, target_auxv_search)
       (fprint_target_auxv): Use ULONGEST instead of CORE_ADDR for
       variable. Change variable name to at_type.
@
text
@a2357 5
	  /* For PIE executables, we dont really know where the
	     breakpoints are going to be until we start up the
	     inferior.  */
          re_enable_breakpoints_at_startup ();

@


1.141
log
@2004-03-21  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (handle_inferior_event): For non legacy frames, use the
	frame ID and frame type to identify a signal trampoline.  Update
	comments.
@
text
@d1206 2
a1207 2
/* Wrapper for PC_IN_SIGTRAMP that takes care of the need to find the
   function's name.
d1236 1
a1236 1
  return PC_IN_SIGTRAMP (pc, name);
@


1.140
log
@Index: ChangeLog
2004-03-15  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (handle_step_into_function, step_over_function): Only
	update and use STEP_FRAME_ID when the system is using legacy
	frames.  Update comments.
@
text
@d2524 12
a2535 4
  /* Did we just take a signal?  */
  if (pc_in_sigtramp (stop_pc)
      && !pc_in_sigtramp (prev_pc)
      && INNER_THAN (read_sp (), step_sp))
a2536 11
      /* We've just taken a signal; go until we are back to
         the point where we took it and one more.  */

      /* Note: The test above succeeds not only when we stepped
         into a signal handler, but also when we step past the last
         statement of a signal handler and end up in the return stub
         of the signal handler trampoline.  To distinguish between
         these two cases, check that the frame is INNER_THAN the
         previous one below. pai/1997-09-11 */


@


1.139
log
@	* infrun.c (handle_inferior_event): Remove short-circuit code for
	events in a different thread.
@
text
@d1267 2
a1268 1
      if (pc_in_sigtramp (stop_pc)
d1271 12
a1282 8
        /* We stepped out of a signal handler, and into its
           calling trampoline.  This is misdetected as a
           subroutine call, but stepping over the signal
           trampoline isn't such a bad idea.  In order to do that,
           we have to ignore the value in step_frame_id, since
           that doesn't represent the frame that'll reach when we
           return from the signal trampoline.  Otherwise we'll
           probably continue to the end of the program.  */
d2876 1
a2876 1
   of the call.
d2879 1
a2879 2
   caller's frame (step_frame_id, which is set by the "next" or
   "until" command, before execution begins).  */
d2930 34
a2963 18
  if (frame_id_p (step_frame_id)
      && !IN_SOLIB_DYNSYM_RESOLVE_CODE (sr_sal.pc))
    /* NOTE: cagney/2004-02-27: Use the global state's idea of the
       stepping frame ID.  I suspect this is done as it is lighter
       weight than a call to get_prev_frame.  */
    sr_id = step_frame_id;
  else if (legacy_frame_p (current_gdbarch))
    /* NOTE: cagney/2004-02-27: This is the way it was 'cos this is
       the way it always was.  It should be using the unwound (or
       caller's) ID, and not this (or the callee's) ID.  It appeared
       to work because: legacy architectures used the wrong end of the
       frame for the ID.stack (inner-most rather than outer-most) so
       that the callee's id.stack (un adjusted) matched the caller's
       id.stack giving the "correct" id; more often than not
       !IN_SOLIB_DYNSYM_RESOLVE_CODE and hence the code above (it was
       originally later in the function) fixed the ID by using global
       state.  */
    sr_id = get_frame_id (get_current_frame ());
@


1.139.2.1
log
@2004-03-16  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (handle_inferior_event): For non legacy frames, use the
	frame ID and frame type to identify a signal trampoline.  Update
	comments.
@
text
@d1267 1
a1267 2
      if (legacy_frame_p (current_gdbarch)
	  && pc_in_sigtramp (stop_pc)
d1270 8
a1277 12
	/* NOTE: cagney/2004-03-15: This is only needed for legacy
	   systems.  On non-legacy systems step_over_function doesn't
	   use STEP_FRAME_ID and hence the below update "hack" isn't
	   needed.  */
        /* We stepped out of a signal handler, and into its calling
           trampoline.  This is misdetected as a subroutine call, but
           stepping over the signal trampoline isn't such a bad idea.
           In order to do that, we have to ignore the value in
           step_frame_id, since that doesn't represent the frame
           that'll reach when we return from the signal trampoline.
           Otherwise we'll probably continue to the end of the
           program.  */
d2519 4
a2522 12
  /* Did we just step into a singal trampoline (either by stepping out
     of a handler, or by taking a signal)?  */
  /* NOTE: cagney/2004-03-16: Replaced (except for legacy) a check for
     "pc_in_sigtramp(stop_pc) != pc_in_sigtramp(step_pc)" with
     frame_type == SIGTRAMP && !frame_id_eq.  The latter is far more
     robust as it will correctly handle nested signal trampolines.  */
  if (legacy_frame_p (current_gdbarch)
      ? (pc_in_sigtramp (stop_pc)
	 && !pc_in_sigtramp (prev_pc)
	 && INNER_THAN (read_sp (), step_sp))
      : (get_frame_type (get_current_frame ()) == SIGTRAMP_FRAME
	 && !frame_id_eq (get_frame_id (get_current_frame ()), step_frame_id)))
d2524 11
d2871 1
a2871 1
   of the caller.
d2874 2
a2875 1
   caller's frame (obtained by doing a frame ID unwind).  */
d2926 18
a2943 34
  /* NOTE: cagney/2004-03-15: Code using the current value of
     "step_frame_id", instead of unwinding that frame ID, removed (at
     least for non-legacy platforms).  On s390 GNU/Linux, after taking
     a signal, the program is directly resumed at the signal handler
     and, consequently, the PC would point at at the first instruction
     of that signal handler but STEP_FRAME_ID would [incorrectly] at
     the interrupted code when it should point at the signal
     trampoline.  By always and locally doing a frame ID unwind, it's
     possible to assert that the code is always using the correct
     ID.  */
  if (legacy_frame_p (current_gdbarch))
    {
      if (frame_id_p (step_frame_id)
	  && !IN_SOLIB_DYNSYM_RESOLVE_CODE (sr_sal.pc))
	/* NOTE: cagney/2004-02-27: Use the global state's idea of the
	   stepping frame ID.  I suspect this is done as it is lighter
	   weight than a call to get_prev_frame.  */
	/* NOTE: cagney/2004-03-15: See comment above about how this
	   is also broken.  */
	sr_id = step_frame_id;
      else
	/* NOTE: cagney/2004-03-15: This is the way it was 'cos this
	   is the way it always was.  It should be using the unwound
	   (or caller's) ID, and not this (or the callee's) ID.  It
	   appeared to work because: legacy architectures used the
	   wrong end of the frame for the ID.stack (inner-most rather
	   than outer-most) so that the callee's id.stack (un
	   adjusted) matched the caller's id.stack giving the
	   "correct" id; more often than not
	   !IN_SOLIB_DYNSYM_RESOLVE_CODE and hence the code above (it
	   was originally later in the function) fixed the ID by using
	   global state.  */
	sr_id = get_frame_id (get_current_frame ());
    }
@


1.138
log
@2004-03-05  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (step_over_function): When non-legacy code, and no
	step_frame_id, use the unwinder to get the caller's frame ID.
@
text
@d1886 2
a1887 8
     so, then switch to that thread, and eventually give control back to
     the user.

     Note that if there's any kind of pending follow (i.e., of a fork,
     vfork or exec), we don't want to do this now.  Rather, we'll let
     the next resume handle it. */
  if (!ptid_equal (ecs->ptid, inferior_ptid) &&
      (pending_follow.kind == TARGET_WAITKIND_SPURIOUS))
a1888 46
      int printed = 0;

      /* If it's a random signal for a non-current thread, notify user
         if he's expressed an interest. */
      if (ecs->random_signal && signal_print[stop_signal])
	{
/* ??rehrauer: I don't understand the rationale for this code.  If the
   inferior will stop as a result of this signal, then the act of handling
   the stop ought to print a message that's couches the stoppage in user
   terms, e.g., "Stopped for breakpoint/watchpoint".  If the inferior
   won't stop as a result of the signal -- i.e., if the signal is merely
   a side-effect of something GDB's doing "under the covers" for the
   user, such as stepping threads over a breakpoint they shouldn't stop
   for -- then the message seems to be a serious annoyance at best.

   For now, remove the message altogether. */
#if 0
	  printed = 1;
	  target_terminal_ours_for_output ();
	  printf_filtered ("\nProgram received signal %s, %s.\n",
			   target_signal_to_name (stop_signal),
			   target_signal_to_string (stop_signal));
	  gdb_flush (gdb_stdout);
#endif
	}

      /* If it's not SIGTRAP and not a signal we want to stop for, then
         continue the thread. */

      if (stop_signal != TARGET_SIGNAL_TRAP && !signal_stop[stop_signal])
	{
	  if (printed)
	    target_terminal_inferior ();

	  /* Clear the signal if it should not be passed.  */
	  if (signal_program[stop_signal] == 0)
	    stop_signal = TARGET_SIGNAL_0;

	  target_resume (ecs->ptid, 0, stop_signal);
	  prepare_to_wait (ecs);
	  return;
	}

      /* It's a SIGTRAP or a signal we're interested in.  Switch threads,
         and fall into the rest of wait_for_inferior().  */

@


1.137
log
@	* Makefile.in (infrun.o): Add $(gdb_assert_h).
	* infrun.c: Include "gdb_assert.h".
	(singlestep_ptid, saved_singlestep_ptid)
	(stepping_past_singlestep_breakpoint): New variables.
	(resume): Set singlestep_ptid.  Check for singlestep thread
	hop.
	(init_wait_for_inferior): Clear stepping_past_singlestep_breakpoint.
	(handle_inferior_event): Handle singlestep thread hop.
@
text
@d2933 1
a2976 3
  step_resume_breakpoint =
    set_momentary_breakpoint (sr_sal, get_frame_id (get_current_frame ()),
			      bp_step_resume);
d2980 20
a2999 1
    step_resume_breakpoint->frame_id = step_frame_id;
@


1.137.2.1
log
@Merge mainline to intercu branch.
@
text
@d1206 2
a1207 2
/* Wrapper for DEPRECATED_PC_IN_SIGTRAMP that takes care of the need
   to find the function's name.
d1236 1
a1236 1
  return DEPRECATED_PC_IN_SIGTRAMP (pc, name);
d1267 1
a1267 2
      if (legacy_frame_p (current_gdbarch)
	  && pc_in_sigtramp (stop_pc)
d1270 8
a1277 12
	/* NOTE: cagney/2004-03-15: This is only needed for legacy
	   systems.  On non-legacy systems step_over_function doesn't
	   use STEP_FRAME_ID and hence the below update "hack" isn't
	   needed.  */
        /* We stepped out of a signal handler, and into its calling
           trampoline.  This is misdetected as a subroutine call, but
           stepping over the signal trampoline isn't such a bad idea.
           In order to do that, we have to ignore the value in
           step_frame_id, since that doesn't represent the frame
           that'll reach when we return from the signal trampoline.
           Otherwise we'll probably continue to the end of the
           program.  */
d1886 8
a1893 2
     so, then switch to that thread.  */
  if (!ptid_equal (ecs->ptid, inferior_ptid))
d1895 46
d2571 4
a2574 12
  /* Did we just step into a singal trampoline (either by stepping out
     of a handler, or by taking a signal)?  */
  /* NOTE: cagney/2004-03-16: Replaced (except for legacy) a check for
     "pc_in_sigtramp(stop_pc) != pc_in_sigtramp(step_pc)" with
     frame_type == SIGTRAMP && !frame_id_eq.  The latter is far more
     robust as it will correctly handle nested signal trampolines.  */
  if (legacy_frame_p (current_gdbarch)
      ? (pc_in_sigtramp (stop_pc)
	 && !pc_in_sigtramp (prev_pc)
	 && INNER_THAN (read_sp (), step_sp))
      : (get_frame_type (get_current_frame ()) == SIGTRAMP_FRAME
	 && !frame_id_eq (get_frame_id (get_current_frame ()), step_frame_id)))
d2576 11
d2923 1
a2923 1
   of the caller.
d2926 2
a2927 1
   caller's frame (obtained by doing a frame ID unwind).  */
a2932 1
  struct frame_id sr_id;
d2976 7
a2982 39

  /* NOTE: cagney/2004-03-15: Code using the current value of
     "step_frame_id", instead of unwinding that frame ID, removed (at
     least for non-legacy platforms).  On s390 GNU/Linux, after taking
     a signal, the program is directly resumed at the signal handler
     and, consequently, the PC would point at at the first instruction
     of that signal handler but STEP_FRAME_ID would [incorrectly] at
     the interrupted code when it should point at the signal
     trampoline.  By always and locally doing a frame ID unwind, it's
     possible to assert that the code is always using the correct
     ID.  */
  if (legacy_frame_p (current_gdbarch))
    {
      if (frame_id_p (step_frame_id)
	  && !IN_SOLIB_DYNSYM_RESOLVE_CODE (sr_sal.pc))
	/* NOTE: cagney/2004-02-27: Use the global state's idea of the
	   stepping frame ID.  I suspect this is done as it is lighter
	   weight than a call to get_prev_frame.  */
	/* NOTE: cagney/2004-03-15: See comment above about how this
	   is also broken.  */
	sr_id = step_frame_id;
      else
	/* NOTE: cagney/2004-03-15: This is the way it was 'cos this
	   is the way it always was.  It should be using the unwound
	   (or caller's) ID, and not this (or the callee's) ID.  It
	   appeared to work because: legacy architectures used the
	   wrong end of the frame for the ID.stack (inner-most rather
	   than outer-most) so that the callee's id.stack (un
	   adjusted) matched the caller's id.stack giving the
	   "correct" id; more often than not
	   !IN_SOLIB_DYNSYM_RESOLVE_CODE and hence the code above (it
	   was originally later in the function) fixed the ID by using
	   global state.  */
	sr_id = get_frame_id (get_current_frame ());
    }
  else
    sr_id = get_frame_id (get_prev_frame (get_current_frame ()));

  step_resume_breakpoint = set_momentary_breakpoint (sr_sal, sr_id, bp_step_resume);
@


1.137.2.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d2962 1
a2962 1
    sr_id = frame_unwind_id (get_current_frame ());
@


1.137.2.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d63 2
d166 8
d267 8
d308 1
d319 2
a320 2
   returned by target_wait()/deprecated_target_wait_hook().  This
   information is returned by get_last_target_status().  */
d426 3
d509 8
a516 9
  /* NOTE: cagney/2002-03-17: The deprecated_add_show_from_set()
     function clones the set command passed as a parameter.  The clone
     operation will include (BUG?) any ``set'' command callback, if
     present.  Commands like ``info set'' call all the ``show''
     command callbacks.  Unfortunately, for ``show'' commands cloned
     from ``set'', this includes callbacks belonging to ``set''
     commands.  Making this worse, this only occures if
     deprecated_add_show_from_set() is called after add_cmd_sfunc()
     (BUG?).  */
d575 5
d609 3
a611 3
      if ((step || singlestep_breakpoints_inserted_p)
	  && (stepping_past_singlestep_breakpoint
	      || (!breakpoints_inserted && breakpoint_here_p (read_pc ()))))
d621 3
a623 3
      if ((scheduler_mode == schedlock_on)
	  || (scheduler_mode == schedlock_step
	      && (step || singlestep_breakpoints_inserted_p)))
d678 2
a679 2
      || (wait_status.value.sig != TARGET_SIGNAL_TRAP
	  && wait_status.value.sig != TARGET_SIGNAL_INT))
d703 5
a707 5
      /* We return 1 to indicate that there is a breakpoint here,
         so we need to step over it before continuing to avoid
         hitting it straight away. */
      if (breakpoint_here_p (wait_pc))
	return 1;
d711 1
a711 1

d782 12
d802 1
a802 1
         insert breakpoints -- so they were inserted.  */
d840 1
a840 1
     updated correctly when the inferior is stopped.  */
d850 1
a850 1
  if (!target_can_async_p ())
d894 3
d913 11
d969 1
d975 1
a975 1
  int step_after_step_resume_breakpoint;
d979 1
d989 1
d992 1
d994 1
a994 3
static void insert_step_resume_breakpoint (struct frame_info *step_frame,
					   struct execution_control_state
					   *ecs);
d1016 2
d1041 2
a1042 2
      if (deprecated_target_wait_hook)
	ecs->ptid = deprecated_target_wait_hook (ecs->waiton_ptid, ecs->wp);
d1078 2
d1098 1
a1098 1
  if (deprecated_target_wait_hook)
d1100 1
a1100 1
      deprecated_target_wait_hook (async_ecs->waiton_ptid, async_ecs->wp);
d1129 1
a1129 1
  ecs->step_after_step_resume_breakpoint = 0;
d1131 1
d1135 1
d1157 3
a1159 3
   target_wait()/deprecated_target_wait_hook().  The data is actually
   cached by handle_inferior_event(), which gets called immediately
   after target_wait()/deprecated_target_wait_hook().  */
d1184 1
a1184 1
			 step_range_start,
d1189 2
a1190 1
			 ecs->current_line, ecs->current_symtab);
d1195 1
a1195 1
			 &step_range_start,
d1200 2
a1201 1
			 &ecs->current_line, &ecs->current_symtab);
d1206 128
d1337 1
a1337 1
  CORE_ADDR breakpoint_pc;
d1351 1
a1351 1

d1358 1
a1358 1

d1371 34
a1404 47
  /* Find the location where (if we've hit a breakpoint) the
     breakpoint would be.  */
  breakpoint_pc = read_pc_pid (ecs->ptid) - DECR_PC_AFTER_BREAK;

  if (SOFTWARE_SINGLE_STEP_P ())
    {
      /* When using software single-step, a SIGTRAP can only indicate
         an inserted breakpoint.  This actually makes things
         easier.  */
      if (singlestep_breakpoints_inserted_p)
	/* When software single stepping, the instruction at [prev_pc]
	   is never a breakpoint, but the instruction following
	   [prev_pc] (in program execution order) always is.  Assume
	   that following instruction was reached and hence a software
	   breakpoint was hit.  */
	write_pc_pid (breakpoint_pc, ecs->ptid);
      else if (software_breakpoint_inserted_here_p (breakpoint_pc))
	/* The inferior was free running (i.e., no single-step
	   breakpoints inserted) and it hit a software breakpoint.  */
	write_pc_pid (breakpoint_pc, ecs->ptid);
    }
  else
    {
      /* When using hardware single-step, a SIGTRAP is reported for
         both a completed single-step and a software breakpoint.  Need
         to differentiate between the two as the latter needs
         adjusting but the former does not.  */
      if (currently_stepping (ecs))
	{
	  if (prev_pc == breakpoint_pc
	      && software_breakpoint_inserted_here_p (breakpoint_pc))
	    /* Hardware single-stepped a software breakpoint (as
	       occures when the inferior is resumed with PC pointing
	       at not-yet-hit software breakpoint).  Since the
	       breakpoint really is executed, the inferior needs to be
	       backed up to the breakpoint address.  */
	    write_pc_pid (breakpoint_pc, ecs->ptid);
	}
      else
	{
	  if (software_breakpoint_inserted_here_p (breakpoint_pc))
	    /* The inferior was free running (i.e., no hardware
	       single-step and no possibility of a false SIGTRAP) and
	       hit a software breakpoint.  */
	    write_pc_pid (breakpoint_pc, ecs->ptid);
	}
    }
a1410 2
int stepped_after_stopped_by_watchpoint;

d1419 1
a1420 1
  int stopped_by_watchpoint = -1;	/* Mark as unknown.  */
a1476 1
			   && !ptid_equal (ecs->ptid, minus_one_ptid)
d1487 25
d1534 5
a1538 5
	     stack's section table is kept up-to-date.  Architectures,
	     (e.g., PPC64), use the section table to perform
	     operations such as address => section name and hence
	     require the table to contain all sections (including
	     those found in shared libraries).  */
d1540 8
a1547 8
	     exec_ops to SOLIB_ADD.  This is because current GDB is
	     only tooled to propagate section_table changes out from
	     the "current_target" (see target_resize_to_sections), and
	     not up from the exec stratum.  This, of course, isn't
	     right.  "infrun.c" should only interact with the
	     exec/process stratum, instead relying on the target stack
	     to propagate relevant changes (stop, section table
	     changed, ...) up to other layers.  */
d1610 1
a1610 1
      stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid, 0);
d1627 2
a1628 2
         target_wait function.  Until then following vfork on HP/UX 10.20
         is probably broken by this.  Of course, it's broken anyway.  */
d1659 1
a1659 1
      stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid, 0);
d1733 6
a1738 6

         One of the possible circumstances for this is when the
         inferior produces output for the console. The inferior has
         not stopped, and we are ignoring the event.  Another possible
         circumstance is any event which the lower level knows will be
         reported multiple times without an intervening resume.  */
d1762 1
a1762 2
      gdb_assert (SOFTWARE_SINGLE_STEP_P ()
		  && singlestep_breakpoints_inserted_p);
d1769 2
a1770 2
         breakpoint, or stopped for some other reason.  It would be nice if
         we could tell, but we can't reliably.  */
d1772 1
a1772 1
	{
d1781 2
a1782 2
	  if (deprecated_context_hook)
	    deprecated_context_hook (pid_to_thread_id (ecs->ptid));
d1826 2
a1827 2
	{
	  int remove_status;
d1829 2
a1830 2
	  /* Saw a breakpoint, but it was hit by the wrong thread.
	     Just continue. */
d1832 6
a1837 6
	  if (SOFTWARE_SINGLE_STEP_P () && singlestep_breakpoints_inserted_p)
	    {
	      /* Pull the single step breakpoints out of the target. */
	      SOFTWARE_SINGLE_STEP (0, 0);
	      singlestep_breakpoints_inserted_p = 0;
	    }
d1839 27
a1865 21
	  remove_status = remove_breakpoints ();
	  /* Did we fail to remove breakpoints?  If so, try
	     to set the PC past the bp.  (There's at least
	     one situation in which we can fail to remove
	     the bp's: On HP-UX's that use ttrace, we can't
	     change the address space of a vforking child
	     process until the child exits (well, okay, not
	     then either :-) or execs. */
	  if (remove_status != 0)
	    {
	      /* FIXME!  This is obviously non-portable! */
	      write_pc_pid (stop_pc + 4, ecs->ptid);
	      /* We need to restart all the threads now,
	       * unles we're running in scheduler-locked mode. 
	       * Use currently_stepping to determine whether to 
	       * step or continue.
	       */
	      /* FIXME MVS: is there any reason not to call resume()? */
	      if (scheduler_mode == schedlock_on)
		target_resume (ecs->ptid,
			       currently_stepping (ecs), TARGET_SIGNAL_0);
d1867 13
a1879 19
		target_resume (RESUME_ALL,
			       currently_stepping (ecs), TARGET_SIGNAL_0);
	      prepare_to_wait (ecs);
	      return;
	    }
	  else
	    {			/* Single step */
	      breakpoints_inserted = 0;
	      if (!ptid_equal (inferior_ptid, ecs->ptid))
		context_switch (ecs);
	      ecs->waiton_ptid = ecs->ptid;
	      ecs->wp = &(ecs->ws);
	      ecs->another_trap = 1;

	      ecs->infwait_state = infwait_thread_hop_state;
	      keep_going (ecs);
	      registers_changed ();
	      return;
	    }
d1882 4
a1885 4
	{
	  sw_single_step_trap_p = 1;
	  ecs->random_signal = 0;
	}
d1896 2
a1897 2
      if (deprecated_context_hook)
	deprecated_context_hook (pid_to_thread_id (ecs->ptid));
d1975 1
a1975 1
    stopped_by_watchpoint = STOPPED_BY_WATCHPOINT (ecs->ws);
d1984 1
a1984 1
  ecs->stop_func_start += DEPRECATED_FUNCTION_START_OFFSET;
d2014 6
a2019 5
      || (breakpoints_inserted
	  && (stop_signal == TARGET_SIGNAL_ILL
	      || stop_signal == TARGET_SIGNAL_SEGV
	      || stop_signal == TARGET_SIGNAL_EMT))
      || stop_soon == STOP_QUIETLY || stop_soon == STOP_QUIETLY_NO_SIGSTOP)
d2048 9
a2056 3
      /* Don't even think about breakpoints if just proceeded over a
         breakpoint.  */
      if (stop_signal == TARGET_SIGNAL_TRAP && trap_expected)
d2061 1
a2061 2
	  stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid,
					    stopped_by_watchpoint);
d2069 7
a2075 7
         at one stage in the past included checks for an inferior
         function call's call dummy's return breakpoint.  The original
         comment, that went with the test, read:

         ``End of a stack dummy.  Some systems (e.g. Sony news) give
         another signal besides SIGTRAP, so check here as well as
         above.''
d2084 3
a2086 3
         NOTE: kettenis/2004-02-05: Indeed such checks don't seem to
         be necessary for call dummies on a non-executable stack on
         SPARC.  */
d2139 33
a2171 35
      if (prev_pc == read_pc ()
	  && !breakpoints_inserted
	  && breakpoint_here_p (read_pc ())
	  && step_resume_breakpoint == NULL)
	{
	  /* We were just starting a new sequence, attempting to
	     single-step off of a breakpoint and expecting a SIGTRAP.
	     Intead this signal arrives.  This signal will take us out
	     of the stepping range so GDB needs to remember to, when
	     the signal handler returns, resume stepping off that
	     breakpoint.  */
	  /* To simplify things, "continue" is forced to use the same
	     code paths as single-step - set a breakpoint at the
	     signal return address and then, once hit, step off that
	     breakpoint.  */
	  insert_step_resume_breakpoint (get_current_frame (), ecs);
	  ecs->step_after_step_resume_breakpoint = 1;
	}
      else if (step_range_end != 0
	       && stop_signal != TARGET_SIGNAL_0
	       && stop_pc >= step_range_start && stop_pc < step_range_end
	       && frame_id_eq (get_frame_id (get_current_frame ()),
			       step_frame_id))
	{
	  /* The inferior is about to take a signal that will take it
	     out of the single step range.  Set a breakpoint at the
	     current PC (which is presumably where the signal handler
	     will eventually return) and then allow the inferior to
	     run free.

	     Note that this is only needed for a signal delivered
	     while in the single-step range.  Nested signals aren't a
	     problem as they eventually all return.  */
	  insert_step_resume_breakpoint (get_current_frame (), ecs);
	}
d2186 3
d2212 7
d2220 7
a2226 1
	set_longjmp_resume_breakpoint (jmp_buf_pc, null_frame_id);
d2235 11
d2266 3
a2268 2
	/* We are about to nuke the step_resume_breakpointt via the
	   cleanup chain, so no need to worry about it here.  */
d2276 3
a2278 2
	/* We are about to nuke the step_resume_breakpoin via the
	   cleanup chain, so no need to worry about it here.  */
a2306 12
	if (ecs->step_after_step_resume_breakpoint)
	  {
	    /* Back when the step-resume breakpoint was inserted, we
	       were trying to single-step off a breakpoint.  Go back
	       to doing that.  */
	    ecs->step_after_step_resume_breakpoint = 0;
	    remove_breakpoints ();
	    breakpoints_inserted = 0;
	    ecs->another_trap = 1;
	    keep_going (ecs);
	    return;
	  }
d2310 4
d2337 5
a2341 5
	     stack's section table is kept up-to-date.  Architectures,
	     (e.g., PPC64), use the section table to perform
	     operations such as address => section name and hence
	     require the table to contain all sections (including
	     those found in shared libraries).  */
d2343 8
a2350 8
	     exec_ops to SOLIB_ADD.  This is because current GDB is
	     only tooled to propagate section_table changes out from
	     the "current_target" (see target_resize_to_sections), and
	     not up from the exec stratum.  This, of course, isn't
	     right.  "infrun.c" should only interact with the
	     exec/process stratum, instead relying on the target stack
	     to propagate relevant changes (stop, section table
	     changed, ...) up to other layers.  */
d2378 2
a2379 2
	  else if (what.main_action
		   == BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK)
d2457 3
d2467 3
d2481 3
d2519 17
a2535 15
  if (step_range_end != 1
      && (step_over_calls == STEP_OVER_UNDEBUGGABLE
	  || step_over_calls == STEP_OVER_ALL)
      && get_frame_type (get_current_frame ()) == SIGTRAMP_FRAME)
    {
      /* The inferior, while doing a "step" or "next", has ended up in
         a signal trampoline (either by a signal being delivered or by
         the signal handler returning).  Just single-step until the
         inferior leaves the trampoline (either by calling the handler
         or returning).  */
      keep_going (ecs);
      return;
    }

  if (frame_id_eq (frame_unwind_id (get_current_frame ()), step_frame_id))
d2537 2
a2538 2
      /* It's a subroutine call.  */
      CORE_ADDR real_stop_pc;
d2540 4
a2543 15
      if ((step_over_calls == STEP_OVER_NONE)
	  || ((step_range_end == 1)
	      && in_prologue (prev_pc, ecs->stop_func_start)))
	{
	  /* I presume that step_over_calls is only 0 when we're
	     supposed to be stepping at the assembly language level
	     ("stepi").  Just stop.  */
	  /* Also, maybe we just did a "nexti" inside a prolog, so we
	     thought it was a subroutine call but it was not.  Stop as
	     well.  FENN */
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}
d2545 26
a2570 32
#ifdef DEPRECATED_IGNORE_HELPER_CALL
      /* On MIPS16, a function that returns a floating point value may
         call a library helper function to copy the return value to a
         floating point register.  The DEPRECATED_IGNORE_HELPER_CALL
         macro returns non-zero if we should ignore (i.e. step over)
         this function call.  */
      /* FIXME: cagney/2004-07-21: These custom ``ignore frame when
         stepping'' function attributes (SIGTRAMP_FRAME,
         DEPRECATED_IGNORE_HELPER_CALL, SKIP_TRAMPOLINE_CODE,
         skip_language_trampoline frame, et.al.) need to be replaced
         with generic attributes bound to the frame's function.  */
      if (DEPRECATED_IGNORE_HELPER_CALL (stop_pc))
	{
	  /* We're doing a "next", set a breakpoint at callee's return
	     address (the address at which the caller will
	     resume).  */
	  insert_step_resume_breakpoint (get_prev_frame
					 (get_current_frame ()), ecs);
	  keep_going (ecs);
	  return;
	}
#endif
      if (step_over_calls == STEP_OVER_ALL)
	{
	  /* We're doing a "next", set a breakpoint at callee's return
	     address (the address at which the caller will
	     resume).  */
	  insert_step_resume_breakpoint (get_prev_frame
					 (get_current_frame ()), ecs);
	  keep_going (ecs);
	  return;
	}
d2572 18
a2589 10
      /* If we are in a function call trampoline (a stub between the
         calling routine and the real function), locate the real
         function.  That's what tells us (a) whether we want to step
         into it at all, and (b) what prologue we want to run to the
         end of, if we do step into it.  */
      real_stop_pc = skip_language_trampoline (stop_pc);
      if (real_stop_pc == 0)
	real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
      if (real_stop_pc != 0)
	ecs->stop_func_start = real_stop_pc;
a2590 5
      if (IN_SOLIB_DYNSYM_RESOLVE_CODE (ecs->stop_func_start))
	{
	  struct symtab_and_line sr_sal;
	  init_sal (&sr_sal);
	  sr_sal.pc = ecs->stop_func_start;
d2592 7
a2598 5
	  check_for_old_step_resume_breakpoint ();
	  step_resume_breakpoint =
	    set_momentary_breakpoint (sr_sal, null_frame_id, bp_step_resume);
	  if (breakpoints_inserted)
	    insert_breakpoints ();
d2600 4
a2603 3
	  keep_going (ecs);
	  return;
	}
d2605 10
a2614 2
      /* If we have line number information for the function we are
         thinking of stepping into, step into it.
d2616 1
a2616 5
         If there are several symtabs at that PC (e.g. with include
         files), just want to know whether *any* of them have line
         numbers.  find_pc_line handles this.  */
      {
	struct symtab_and_line tmp_sal;
d2618 1
a2618 7
	tmp_sal = find_pc_line (ecs->stop_func_start, 0);
	if (tmp_sal.line != 0)
	  {
	    step_into_function (ecs);
	    return;
	  }
      }
d2620 7
a2626 16
      /* If we have no line number and the step-stop-if-no-debug is
         set, we stop the step so that the user has a chance to switch
         in assembly mode.  */
      if (step_over_calls == STEP_OVER_UNDEBUGGABLE && step_stop_if_no_debug)
	{
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}

      /* Set a breakpoint at callee's return address (the address at
         which the caller will resume).  */
      insert_step_resume_breakpoint (get_prev_frame (get_current_frame ()),
				     ecs);
      keep_going (ecs);
a2661 45
  /* NOTE: tausq/2004-05-24: This if block used to be done before all
     the trampoline processing logic, however, there are some trampolines 
     that have no names, so we should do trampoline handling first.  */
  if (step_over_calls == STEP_OVER_UNDEBUGGABLE
      && ecs->stop_func_name == NULL)
    {
      /* The inferior just stepped into, or returned to, an
         undebuggable function (where there is no symbol, not even a
         minimal symbol, corresponding to the address where the
         inferior stopped).  Since we want to skip this kind of code,
         we keep going until the inferior returns from this
         function.  */
      if (step_stop_if_no_debug)
	{
	  /* If we have no line number and the step-stop-if-no-debug
	     is set, we stop the step so that the user has a chance to
	     switch in assembly mode.  */
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}
      else
	{
	  /* Set a breakpoint at callee's return address (the address
	     at which the caller will resume).  */
	  insert_step_resume_breakpoint (get_prev_frame
					 (get_current_frame ()), ecs);
	  keep_going (ecs);
	  return;
	}
    }

  if (step_range_end == 1)
    {
      /* It is stepi or nexti.  We always want to stop stepping after
         one instruction.  */
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }

  ecs->sal = find_pc_line (stop_pc, 0);

d2722 9
a2730 9
  if (step - ID == current - ID)
    still stepping in same function;
  else if (step - ID == unwind (current - ID))
    stepped into a function;
  else
    stepped out of a function;
  /* Of course this assumes that the frame ID unwind code is robust
     and we're willing to introduce frame unwind logic into this
     function.  Fortunately, those days are nearly upon us.  */
d2746 2
a2747 1
  return ((!ecs->handling_longjmp
d2754 36
d2820 1
a2820 1

d2830 1
a2830 1

d2835 1
a2835 1
					     ecs->stop_func_start);
d2867 10
a2876 13
/* Insert a "step resume breakpoint" at RETURN_FRAME.pc.  This is used
   to skip a function (next, skip-no-debug) or signal.  It's assumed
   that the function/signal handler being skipped eventually returns
   to the breakpoint inserted at RETURN_FRAME.pc.

   For the skip-function case, the function may have been reached by
   either single stepping a call / return / signal-return instruction,
   or by hitting a breakpoint.  In all cases, the RETURN_FRAME belongs
   to the skip-function's caller.

   For the signals case, this is called with the interrupted
   function's frame.  The signal handler, when it returns, will resume
   the interrupted function at RETURN_FRAME.pc.  */
d2879 1
a2879 2
insert_step_resume_breakpoint (struct frame_info *return_frame,
			       struct execution_control_state *ecs)
d2882 1
d2886 37
a2922 1
  sr_sal.pc = ADDR_BITS_REMOVE (get_frame_pc (return_frame));
d2927 38
a2964 3
  step_resume_breakpoint
    = set_momentary_breakpoint (sr_sal, get_frame_id (return_frame),
				bp_step_resume);
d2987 4
d3010 1
a3010 1
         We're going to run this baby now!  */
d3012 14
a3025 1
      if (!breakpoints_inserted && !ecs->another_trap)
d3291 2
a3292 2
	         (or should) carry around the function and does (or
	         should) use that when doing a frame comparison.  */
d3328 1
a3328 1
	    print_stack_frame (get_selected_frame (), 0, source_flag);
d3357 1
a3357 1
  observer_notify_normal_stop (stop_bpstat);
d3758 1
a3758 1
  int size = register_size (current_gdbarch, regno);
d4152 1
a4152 1
  deprecated_add_show_from_set
d4171 1
a4171 1
  deprecated_add_show_from_set (c, &showlist);
d4183 1
a4183 1
  deprecated_add_show_from_set (c, &showlist);
d4191 1
a4191 1
  deprecated_add_show_from_set (c, &showlist);
@


1.136
log
@2004-02-15  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_register_gdbarch_swap): Rename
	register_gdbarch_swap.
	(DEPRECATED_REGISTER_GDBARCH_SWAP): Rename REGISTER_GDBARCH_SWAP.
	* f-lang.c (_initialize_f_language): Update, use
	DEPRECATED_REGISTER_GDBARCH_SWAP.
	* remote.c (_initialize_remote): Ditto.
	* regcache.c (_initialize_regcache): Ditto.
	* parse.c (_initialize_parse): Ditto.
	* infrun.c (_initialize_infrun): Ditto.
	* mi/mi-main.c (_initialize_mi_main): Ditto.
	* gdbtypes.c (_initialize_gdbtypes): Ditto.
@
text
@d47 1
d478 8
d572 1
d610 2
a611 1
	  !breakpoints_inserted && breakpoint_here_p (read_pc ()))
d910 2
d1755 32
d1793 2
d1802 19
d1827 7
a1874 1
	    }
@


1.135
log
@* infrun.c (handle_inferior_event): Allow for breakpoint
instructions to generate a SIGSEGV in addition to SIGTRAP, SIGILL
and SIGEMT.  Update comments.
* NEWS (Revised SPARC target): Mention support for non-executable
stack.
@
text
@d4000 2
a4001 2
  register_gdbarch_swap (&stop_registers, sizeof (stop_registers), NULL);
  register_gdbarch_swap (NULL, 0, build_infrun);
@


1.134
log
@	* breakpoint.c (bpstat_stop_status): Take a ptid_t argument,
	and check the specified thread for each breakpoint.
	* breakpoint.h (bpstat_stop_status): Update prototype.
	* infrun.c (handle_inferior_event): Update calls to
	bpstat_stop_status.
@
text
@d1978 9
a1986 5
     that have to do with the program's own actions.
     Note that breakpoint insns may cause SIGTRAP or SIGILL
     or SIGEMT, depending on the operating system version.
     Here we detect when a SIGILL or SIGEMT is really a breakpoint
     and change it to SIGTRAP.  */
d1991 1
d2054 2
a2055 2
         with something like a SIGSEG), then those tests might need to
         be re-instated.  Given, however, that the tests were only
d2057 5
a2061 1
         suspect that it won't be the case.  */
@


1.133
log
@	* breakpoint.c (bpstat_stop_status): Remove not_a_sw_breakpoint
	argument, and change first argument to a CORE_ADDR.
	* breakpoint.h (bpstat_stop_status): Update prototype.
	* infrun.c (adjust_pc_after_break): Add a new comment.
	(handle_inferior_event): Update calls to bpstat_stop_status.
@
text
@d1592 1
a1592 1
      stop_bpstat = bpstat_stop_status (stop_pc);
d1641 1
a1641 1
      stop_bpstat = bpstat_stop_status (stop_pc);
d2031 1
a2031 1
	  stop_bpstat = bpstat_stop_status (stop_pc);
@


1.132
log
@	* breakpoint.c (software_breakpoint_inserted_here_p): New function.
	(bpstat_stop_status): Don't decrement PC.
	* breakpoint.h (software_breakpoint_inserted_here_p): Add
	prototype.
	* infrun.c (adjust_pc_after_break): New function.
	(handle_inferior_event): Call it, early.  Remove later references
	to DECR_PC_AFTER_BREAK.
	(normal_stop): Add commentary.
@
text
@d1328 5
d1592 1
a1592 7
      /* Assume that catchpoints are not really software breakpoints.  If
	 some future target implements them using software breakpoints then
	 that target is responsible for fudging DECR_PC_AFTER_BREAK.  Thus
	 we pass 1 for the NOT_A_SW_BREAKPOINT argument, so that
	 bpstat_stop_status will not decrement the PC.  */

      stop_bpstat = bpstat_stop_status (&stop_pc, 1);
d1641 1
a1641 7
      /* Assume that catchpoints are not really software breakpoints.  If
	 some future target implements them using software breakpoints then
	 that target is responsible for fudging DECR_PC_AFTER_BREAK.  Thus
	 we pass 1 for the NOT_A_SW_BREAKPOINT argument, so that
	 bpstat_stop_status will not decrement the PC.  */

      stop_bpstat = bpstat_stop_status (&stop_pc, 1);
d2031 1
a2032 22
	  /* The second argument of bpstat_stop_status is meant to help
	     distinguish between a breakpoint trap and a singlestep trap.
	     This is only important on targets where DECR_PC_AFTER_BREAK
	     is non-zero.  The prev_pc test is meant to distinguish between
	     singlestepping a trap instruction, and singlestepping thru a
	     jump to the instruction following a trap instruction.

             Therefore, pass TRUE if our reason for stopping is
             something other than hitting a breakpoint.  We do this by
             checking that either: we detected earlier a software single
             step trap or, 1) stepping is going on and 2) we didn't hit
             a breakpoint in a signal handler without an intervening stop
             in sigtramp, which is detected by a new stack pointer value
             below any usual function calling stack adjustments.  */
	  stop_bpstat =
            bpstat_stop_status
              (&stop_pc,
               sw_single_step_trap_p
               || (currently_stepping (ecs)
                   && prev_pc != stop_pc - DECR_PC_AFTER_BREAK
                   && !(step_range_end
                        && INNER_THAN (read_sp (), (step_sp - 16)))));
@


1.131
log
@	* infrun.c (handle_inferior_event): Check stop_stack_dummy if handling
	BPSTAT_WHAT_CHECK_SHLIBS.
@
text
@d1316 68
d1403 2
d1758 1
a1758 2
      if (breakpoints_inserted
          && breakpoint_here_p (stop_pc - DECR_PC_AFTER_BREAK))
d1761 1
a1761 2
	  if (!breakpoint_thread_match (stop_pc - DECR_PC_AFTER_BREAK,
					ecs->ptid))
a1766 2
	      if (DECR_PC_AFTER_BREAK)
		write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK, ecs->ptid);
d1779 1
a1779 1
		  write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK + 4, ecs->ptid);
a1812 11
          /* Readjust the stop_pc as it is off by DECR_PC_AFTER_BREAK
             compared to the value it would have if the system stepping
             capability was used. This allows the rest of the code in
             this function to use this address without having to worry
             whether software single step is in use or not.  */
          if (DECR_PC_AFTER_BREAK)
            {
              stop_pc -= DECR_PC_AFTER_BREAK;
              write_pc_pid (stop_pc, ecs->ptid);
            }

a1943 3
      if (DECR_PC_AFTER_BREAK)
	write_pc (stop_pc - DECR_PC_AFTER_BREAK);

d3176 1
@


1.130
log
@	* infrun.c (step_into_function): Account for possible breakpoint
	adjustment when computing ``stop_func_start''.
@
text
@d2304 1
a2304 1
	  if (stop_on_solib_events)
@


1.129
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* remote-sds.c (tohex): Delete unused function.  Update copyright.
	* xstormy16-tdep.c (xstormy16_register_virtual_size): Ditto.
	* v850-tdep.c (v850_register_virtual_size): Ditto.
	* target.c (normal_target_post_startup_inferior): Ditto.
	* source.c (ambiguous_line_spec): Ditto.
	* remote.c (adapt_remote_get_threadinfo): Ditto.
	* mi/mi-out.c (out_field_fmt): Ditto.
	* mi/mi-interp.c (mi_interp_read_one_line_hook): Ditto.
	(output_control_change_notification): Ditto.
	* m68k-tdep.c (m68k_register_byte): Ditto.
	(m68k_remote_breakpoint_from_pc): Ditto.
	* ui-out.c (init_ui_out_state): Delete unused declaration.
	* stabsread.c (search_value): Ditto.
	* mi/mi-cmd-env.c (env_cli_command): Ditto.
	* maint.c (print_section_table): Ditto.
	* infrun.c (set_follow_fork_mode_command): Ditto.
@
text
@d2760 23
@


1.128
log
@	* breakpoint.c (must_shift_inst_regs): Delete.
	(bpstat_stop_status): Delete references to DECR_PC_AFTER_HW_BREAK
	and SHIFT_INST_REGS.
	* infcmd.c (step_1, step_1_continuation): Delete references to
	SHIFT_INST_REGS.
	* infrun.c (keep_going): Likewise.
	* target.h (DECR_PC_AFTER_HW_BREAK): Don't define.
	* config/i386/nm-i386.h (DECR_PC_AFTER_HW_BREAK): Likewise.
@
text
@d5 2
a6 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
a62 3

static void set_follow_fork_mode_command (char *arg, int from_tty,
					  struct cmd_list_element *c);
@


1.127
log
@	* infrun.c (follow_fork_mode_ask): Remove.
	(follow_fork_mode_kind_names): Remove follow_fork_mode_ask.
	(follow_fork): Simplify and remove internal error for
	follow_fork_mode_ask.
	(_initialize_infrun): Update "set follow-fork-mode" help text.
@
text
@a2945 11
#ifdef SHIFT_INST_REGS
      /* I'm not sure when this following segment applies.  I do know,
         now, that we shouldn't rewrite the regs when we were stopped
         by a random signal from the inferior process.  */
      /* FIXME: Shouldn't this be based on the valid bit of the SXIP?
         (this is only used on the 88k).  */

      if (!bpstat_explains_signal (stop_bpstat)
	  && (stop_signal != TARGET_SIGNAL_CHLD) && !stopped_by_random_signal)
	SHIFT_INST_REGS ();
#endif /* SHIFT_INST_REGS */
@


1.126
log
@        * infrun.c (handle_step_into_function): New function.
        (handle_inferior_event): Extract out some code into the new
        function above.
@
text
@d5 1
a5 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
a342 1
static const char follow_fork_mode_ask[] = "ask";
a346 1
  follow_fork_mode_ask,
d358 1
a358 10
  const char *follow_mode = follow_fork_mode_string;
  int follow_child = (follow_mode == follow_fork_mode_child);

  /* Or, did the user not know, and want us to ask? */
  if (follow_fork_mode_string == follow_fork_mode_ask)
    {
      internal_error (__FILE__, __LINE__,
		      "follow_inferior_fork: \"ask\" mode not implemented");
      /* follow_mode = follow_fork_mode_...; */
    }
a4066 18
/* ??rehrauer:  The "both" option is broken, by what may be a 10.20
   kernel problem.  It's also not terribly useful without a GUI to
   help the user drive two debuggers.  So for now, I'm disabling
   the "both" option.  */
/*                      "Set debugger response to a program call of fork \
   or vfork.\n\
   A fork or vfork creates a new process.  follow-fork-mode can be:\n\
   parent  - the original process is debugged after a fork\n\
   child   - the new process is debugged after a fork\n\
   both    - both the parent and child are debugged after a fork\n\
   ask     - the debugger will ask for one of the above choices\n\
   For \"both\", another copy of the debugger will be started to follow\n\
   the new child process.  The original debugger will continue to follow\n\
   the original parent process.  To distinguish their prompts, the\n\
   debugger copy's prompt will be changed.\n\
   For \"parent\" or \"child\", the unfollowed process will run free.\n\
   By default, the debugger will follow the parent process.",
 */
d4072 1
a4072 2
  ask     - the debugger will ask for one of the above choices\n\
For \"parent\" or \"child\", the unfollowed process will run free.\n\
@


1.125
log
@        * infrun.c (handle_inferior_event): Move the declaration of
        real_stop_pc inside the if blocks where it is used.
@
text
@d990 1
d1240 89
d2571 1
a2571 81
      CORE_ADDR real_stop_pc;

      if ((step_over_calls == STEP_OVER_NONE)
	  || ((step_range_end == 1)
	      && in_prologue (prev_pc, ecs->stop_func_start)))
	{
	  /* I presume that step_over_calls is only 0 when we're
	     supposed to be stepping at the assembly language level
	     ("stepi").  Just stop.  */
	  /* Also, maybe we just did a "nexti" inside a prolog,
	     so we thought it was a subroutine call but it was not.
	     Stop as well.  FENN */
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}

      if (step_over_calls == STEP_OVER_ALL || IGNORE_HELPER_CALL (stop_pc))
	{
	  /* We're doing a "next".  */

	  if (pc_in_sigtramp (stop_pc)
	      && frame_id_inner (step_frame_id,
				 frame_id_build (read_sp (), 0)))
	    /* We stepped out of a signal handler, and into its
	       calling trampoline.  This is misdetected as a
	       subroutine call, but stepping over the signal
	       trampoline isn't such a bad idea.  In order to do that,
	       we have to ignore the value in step_frame_id, since
	       that doesn't represent the frame that'll reach when we
	       return from the signal trampoline.  Otherwise we'll
	       probably continue to the end of the program.  */
	    step_frame_id = null_frame_id;

	  step_over_function (ecs);
	  keep_going (ecs);
	  return;
	}

      /* If we are in a function call trampoline (a stub between
         the calling routine and the real function), locate the real
         function.  That's what tells us (a) whether we want to step
         into it at all, and (b) what prologue we want to run to
         the end of, if we do step into it.  */
      real_stop_pc = skip_language_trampoline (stop_pc);
      if (real_stop_pc == 0)
	real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
      if (real_stop_pc != 0)
	ecs->stop_func_start = real_stop_pc;

      /* If we have line number information for the function we
         are thinking of stepping into, step into it.

         If there are several symtabs at that PC (e.g. with include
         files), just want to know whether *any* of them have line
         numbers.  find_pc_line handles this.  */
      {
	struct symtab_and_line tmp_sal;

	tmp_sal = find_pc_line (ecs->stop_func_start, 0);
	if (tmp_sal.line != 0)
	  {
	    step_into_function (ecs);
	    return;
	  }
      }

      /* If we have no line number and the step-stop-if-no-debug
         is set, we stop the step so that the user has a chance to
         switch in assembly mode.  */
      if (step_over_calls == STEP_OVER_UNDEBUGGABLE && step_stop_if_no_debug)
	{
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}

      step_over_function (ecs);
      keep_going (ecs);
a2572 1

@


1.124
log
@        * infrun.c: Backout the previous change.
@
text
@a1246 1
  CORE_ADDR real_stop_pc;
d2481 1
d2585 1
a2585 1
      real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
@


1.123
log
@        * infrun.c (handle_step_into_function): New function.
        (handle_inferior_event): Extract out some code into the new
        function above.
@
text
@a989 2
static void handle_step_into_function (struct execution_control_state *ecs,
                                       CORE_ADDR real_stop_pc);
a1238 88
/* Handle the inferior event in the cases when we just stepped
   into a function.  */

static void
handle_step_into_function (struct execution_control_state *ecs,
                           CORE_ADDR real_stop_pc)
{
  if ((step_over_calls == STEP_OVER_NONE)
      || ((step_range_end == 1)
          && in_prologue (prev_pc, ecs->stop_func_start)))
    {
      /* I presume that step_over_calls is only 0 when we're
         supposed to be stepping at the assembly language level
         ("stepi").  Just stop.  */
      /* Also, maybe we just did a "nexti" inside a prolog,
         so we thought it was a subroutine call but it was not.
         Stop as well.  FENN */
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }

  if (step_over_calls == STEP_OVER_ALL || IGNORE_HELPER_CALL (stop_pc))
    {
      /* We're doing a "next".  */

      if (pc_in_sigtramp (stop_pc)
          && frame_id_inner (step_frame_id,
                             frame_id_build (read_sp (), 0)))
        /* We stepped out of a signal handler, and into its
           calling trampoline.  This is misdetected as a
           subroutine call, but stepping over the signal
           trampoline isn't such a bad idea.  In order to do that,
           we have to ignore the value in step_frame_id, since
           that doesn't represent the frame that'll reach when we
           return from the signal trampoline.  Otherwise we'll
           probably continue to the end of the program.  */
        step_frame_id = null_frame_id;

      step_over_function (ecs);
      keep_going (ecs);
      return;
    }

  /* If we are in a function call trampoline (a stub between
     the calling routine and the real function), locate the real
     function.  That's what tells us (a) whether we want to step
     into it at all, and (b) what prologue we want to run to
     the end of, if we do step into it.  */
  real_stop_pc = skip_language_trampoline (stop_pc);
  if (real_stop_pc == 0)
    real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
  if (real_stop_pc != 0)
    ecs->stop_func_start = real_stop_pc;

  /* If we have line number information for the function we
     are thinking of stepping into, step into it.

     If there are several symtabs at that PC (e.g. with include
     files), just want to know whether *any* of them have line
     numbers.  find_pc_line handles this.  */
  {
    struct symtab_and_line tmp_sal;

    tmp_sal = find_pc_line (ecs->stop_func_start, 0);
    if (tmp_sal.line != 0)
      {
        step_into_function (ecs);
        return;
      }
  }

  /* If we have no line number and the step-stop-if-no-debug
     is set, we stop the step so that the user has a chance to
     switch in assembly mode.  */
  if (step_over_calls == STEP_OVER_UNDEBUGGABLE && step_stop_if_no_debug)
    {
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }

  step_over_function (ecs);
  keep_going (ecs);
  return;
}
d2482 80
a2561 1
      handle_step_into_function (ecs, real_stop_pc);
d2563 1
@


1.122
log
@2003-11-25  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c: Don't include "exec.h".
	(handle_inferior_event): Pass current_target, instead of exec_ops,
	to SOLIB_ADD.  Add comments.
	* Makefile.in (infrun.o): Update dependencies.
@
text
@d990 2
d1241 88
d2572 1
a2572 80

      if ((step_over_calls == STEP_OVER_NONE)
	  || ((step_range_end == 1)
	      && in_prologue (prev_pc, ecs->stop_func_start)))
	{
	  /* I presume that step_over_calls is only 0 when we're
	     supposed to be stepping at the assembly language level
	     ("stepi").  Just stop.  */
	  /* Also, maybe we just did a "nexti" inside a prolog,
	     so we thought it was a subroutine call but it was not.
	     Stop as well.  FENN */
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}

      if (step_over_calls == STEP_OVER_ALL || IGNORE_HELPER_CALL (stop_pc))
	{
	  /* We're doing a "next".  */

	  if (pc_in_sigtramp (stop_pc)
	      && frame_id_inner (step_frame_id,
				 frame_id_build (read_sp (), 0)))
	    /* We stepped out of a signal handler, and into its
	       calling trampoline.  This is misdetected as a
	       subroutine call, but stepping over the signal
	       trampoline isn't such a bad idea.  In order to do that,
	       we have to ignore the value in step_frame_id, since
	       that doesn't represent the frame that'll reach when we
	       return from the signal trampoline.  Otherwise we'll
	       probably continue to the end of the program.  */
	    step_frame_id = null_frame_id;

	  step_over_function (ecs);
	  keep_going (ecs);
	  return;
	}

      /* If we are in a function call trampoline (a stub between
         the calling routine and the real function), locate the real
         function.  That's what tells us (a) whether we want to step
         into it at all, and (b) what prologue we want to run to
         the end of, if we do step into it.  */
      real_stop_pc = skip_language_trampoline (stop_pc);
      if (real_stop_pc == 0)
	real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
      if (real_stop_pc != 0)
	ecs->stop_func_start = real_stop_pc;

      /* If we have line number information for the function we
         are thinking of stepping into, step into it.

         If there are several symtabs at that PC (e.g. with include
         files), just want to know whether *any* of them have line
         numbers.  find_pc_line handles this.  */
      {
	struct symtab_and_line tmp_sal;

	tmp_sal = find_pc_line (ecs->stop_func_start, 0);
	if (tmp_sal.line != 0)
	  {
	    step_into_function (ecs);
	    return;
	  }
      }

      /* If we have no line number and the step-stop-if-no-debug
         is set, we stop the step so that the user has a chance to
         switch in assembly mode.  */
      if (step_over_calls == STEP_OVER_UNDEBUGGABLE && step_stop_if_no_debug)
	{
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}

      step_over_function (ecs);
      keep_going (ecs);
a2573 1

@


1.121
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (infrun.o): Update dependencies.
	* infrun.c: Include "exec.h".
	(handle_inferior_event): Pass exec_ops to SOLIB_ADD.
@
text
@a46 1
#include "exec.h"
d1365 16
a1380 1
	  SOLIB_ADD (NULL, 0, &exec_ops, auto_solib_add);
d2203 16
a2218 1
	  SOLIB_ADD (NULL, 0, &exec_ops, auto_solib_add);
@


1.120
log
@2003-11-22  Andrew Cagney  <cagney@@redhat.com>

	* config/powerpc/tm-linux.h (PROLOGUE_FIRSTLINE_OVERLAP): Delete
	#if 0'ed macro.
	* infrun.c (step_into_function): Delete #ifdef
	PROLOGUE_FIRSTLINE_OVERLAP code.
	* symtab.c (find_function_start_sal): Ditto.
@
text
@d47 1
d1366 1
a1366 1
	  SOLIB_ADD (NULL, 0, NULL, auto_solib_add);
d2189 1
a2189 1
	  SOLIB_ADD (NULL, 0, NULL, auto_solib_add);
@


1.119
log
@* gdbarch.sh (skip_solib_resolver): Change into a multi-arch
function.
* gdbarch.c, gdbarch.h: Regenerate.
* infrun.c (handle_inferior_event): Call
gdbarch_skip_solib_resolver instead of SKIP_SOLIB_RESOLVER.
* arch-utils.c (generic_in_solib_call_trampoline): Adjust function
definition.
* arch-utils.h (generic_in_solib_call_trampoline): Adjust function
prototype.
@
text
@a2729 4
#ifdef PROLOGUE_FIRSTLINE_OVERLAP
  /* no, don't either.  It skips any code that's legitimately on the
     first line.  */
#else
a2733 1
#endif
@


1.118
log
@From David S. Miller  <davem@@redhat.com>:
* gdbarch.sh (SKIP_SOLIB_RESOLVER): New method.
* gdbarch.c, gdbarch.h: Regenerated.
* arch-utils.c (generic_skip_solib_resolver): New function.
* arch-utils.h (generic_skip_solib_resolver): New prototype.
* infrun.c (SKIP_SOLIB_RESOLVER): Don't define.
@
text
@d2334 2
a2335 1
      CORE_ADDR pc_after_resolver = SKIP_SOLIB_RESOLVER (stop_pc);
@


1.117
log
@Index: mi/ChangeLog
2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* tui-out.c: Fix "fortunatly"[sic].

Index: doc/ChangeLog
2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* annotate.texinfo: Fix "fortunatly"[sic].

2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* osabi.c (gdbarch_init_osabi): Fix typos, and "fortunatly"[sic].
	* PROBLEMS, arch-utils.c, cli-out.c, command.h: Ditto.
	* complaints.c, cris-tdep.c, disasm.c, dwarf2-frame.c: Ditto.
	* frame.c, frame.h, infcall.c, infcmd.c, infrun.c: Ditto.
	* kod.c, mips-tdep.c, regcache.c, regcache.h, remote.c: Ditto.
@
text
@a155 4
#ifndef SKIP_SOLIB_RESOLVER
#define SKIP_SOLIB_RESOLVER(pc) 0
#endif

@


1.116
log
@2003-10-16  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (handle_inferior_event): Add comment about
	"frame_id_inner" being too weak.
@
text
@d522 1
a522 1
     callbacks.  Unfortunatly, for ``show'' commands cloned from
d2653 1
a2653 1
        function.  Fortunatly, those days are nearly upon us.  */
d2810 1
a2810 1
     Unfortunatly, not five lines further down, is a call to
@


1.115
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d2639 16
@


1.114
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d3625 1
a3625 1
  int size = REGISTER_RAW_SIZE (regno);
@


1.113
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@a497 1
/* ARGSUSED */
@


1.113.4.1
log
@* infrun.c (handle_inferior_event): Allow for breakpoint
instructions to generate a SIGSEGV in addition to SIGTRAP, SIGILL
and SIGEMT.  Update comments.
@
text
@d1848 5
a1852 9
     that have to do with the program's own actions.  Note that
     breakpoint insns may cause SIGTRAP or SIGILL or SIGEMT, depending
     on the operating system version.  Here we detect when a SIGILL or
     SIGEMT is really a breakpoint and change it to SIGTRAP.  We do
     something similar for SIGSEGV, since a SIGSEGV will be generated
     when we're trying to execute a breakpoint instruction on a
     non-executable stack.  This happens for call dummy breakpoints
     for architectures like SPARC that place call dummies on the
     stack.  */
d1857 1
a1857 2
	   || stop_signal == TARGET_SIGNAL_EMT
	   || stop_signal == TARGET_SIGNAL_SEGV))
d1940 2
a1941 2
         with something like a SIGSEGV), then those tests might need
         to be re-instated.  Given, however, that the tests were only
d1943 1
a1943 5
         suspect that it won't be the case.

	 NOTE: kettenis/2003-10-15: Indeed such checks don't seem to
	 be necessary for call dummies on a non-executable stack on
	 SPARC.  */
@


1.112
log
@	* infrun.c (normal_stop): Don't print a message if the inferior
	has exited.
@
text
@d3918 2
a3919 2
  register int i;
  register int numsigs;
@


1.111
log
@	From Nick Kelsey <nickk@@ubicom.com>:
	* infrun.c (handle_inferior_event): Check IN_SOLIB_RETURN_TRAMPOLINE
	when the stop PC is at the beginning of a function also.
@
text
@d3057 5
d3066 3
a3068 2
     (Note that there's no point in saying anything if the inferior
     has exited!) */
d3070 3
a3072 1
      && target_has_execution)
@


1.110
log
@	* arch-utils.c (default_prepare_to_proceed): Remove.
	(generic_prepare_to_proceed): Remove.
	* arch-utils.h (default_prepare_to_proceed): Remove prototype.
	(generic_prepare_to_proceed): Remove prototype.
	* gdbarch.sh (PREPARE_TO_PROCEED): Remove.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-tdep.c (hppa_prepare_to_proceed): Remove dangling prototype.
	* hppah-nat.c (hppa_switched_threads): Remove.
	* infrun.c (prepare_to_proceed): New static function, copied from
	generic_prepare_to_proceed.  Remove select_it argument.
	(proceed): Call prepare_to_proceed.
	* infttrace.c (old_gdb_pid, reported_pid, reported_bpt): Remove
	variables.
	(ptrace_wait): Don't set the removed variables.
	(hppa_switched_threads): Remove.
	* lin-lwp.c (lin_lwp_prepare_to_proceed): Remove.
	* config/nm-linux.h (PREPARE_TO_PROCEED): Don't define.
	(lin_lwp_prepare_to_proceed): Remove prototype.
	* config/i386/nm-x86-64linux.h (PREPARE_TO_PROCEED): Don't undefine.
	* config/pa/nm-hppah.h (PREPARE_TO_PROCEED): Don't define.
@
text
@d2449 3
a2451 3
  if (stop_pc == ecs->stop_func_start	/* Quick test */
      || (in_prologue (stop_pc, ecs->stop_func_start) &&
	  !IN_SOLIB_RETURN_TRAMPOLINE (stop_pc, ecs->stop_func_name))
@


1.109
log
@
2003-05-07  Jeff Johnston  <jjohnstn@@redhat.com>

        * infrun.c (prev_pc): Move declaration ahead of proceed().
        (proceed): Refresh prev_pc value before resuming.
        (stop_stepping): Remove code to refresh prev_pc.
@
text
@d82 2
d672 49
a775 1
#ifdef PREPARE_TO_PROCEED
d784 1
a784 1
     PREPARE_TO_PROCEED checks the current thread against the thread
d787 2
a788 6
  if (PREPARE_TO_PROCEED (1) && breakpoint_here_p (read_pc ()))
    {
      oneproc = 1;
    }

#endif /* PREPARE_TO_PROCEED */
@


1.109.8.1
log
@Snap const char * mess.
@
text
@d50 1
a50 1
static void signals_info (const char *, int);
d52 1
a52 1
static void handle_command (const char *, int);
d73 1
a73 1
static void set_schedlock_func (const char *args, int from_tty,
d80 1
a80 1
static void xdb_handle_command (const char *args, int from_tty);
d515 1
a515 1
set_schedlock_func (const char *args, int from_tty, struct cmd_list_element *c)
d927 1
a927 1
  const char *stop_func_name;
d1193 1
a1193 1
  const char *name;
d3250 1
a3250 1
handle_command (const char *args, int from_tty)
d3430 1
a3430 1
xdb_handle_command (const char *args, int from_tty)
d3502 1
a3502 1
signals_info (const char *signum_exp, int from_tty)
@


1.108
log
@2003-05-04  Andrew Cagney  <cagney@@redhat.com>

	* gdbthread.h (save_infrun_state): Drop prev_func_name parameter.
	(load_infrun_state): Ditto.
	(struct thread_info): Drop "prev_func_name" field.
	* thread.c (load_infrun_state): Update.
	(save_infrun_state): Update.
	* infrun.c (prev_func_name): Delete variable.
	(init_wait_for_inferior): Do not clear prev_func_name.
	(stop_stepping, keep_going, context_switch): Do not swap
	prev_func_name.
	(handle_inferior_event, check_sigtramp2): Use pc_in_sigtramp
	instead of PC_IN_SIGTRAMP.
@
text
@d670 6
d781 24
a817 5

/* Record the pc of the program the last time it stopped.  This is
   just used internally by wait_for_inferior, but need to be preserved
   over calls to it and cleared when the inferior is started.  */
static CORE_ADDR prev_pc;
a2784 8
  if (target_has_execution)
    {
      /* Assuming the inferior still exists, set these up for next
         time, just like we did above if we didn't break out of the
         loop.  */
      prev_pc = read_pc ();
    }

@


1.107
log
@2003-04-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbthread.h (save_infrun_state): Delete parameter
	"prev_func_start".
	(struct thread_info): Delete field "prev_func_start".
	(load_infrun_state): Ditto.
	* thread.c (load_infrun_state, save_infrun_state): Update.
	* infrun.c (prev_func_start): Delete variable.
	(context_switch, init_wait_for_inferior): Update.
	(stop_stepping, keep_going): Update.
@
text
@d789 3
a791 4
/* Record the pc and sp of the program the last time it stopped.
   These are just used internally by wait_for_inferior, but need
   to be preserved over calls to it and cleared when the inferior
   is started.  */
a792 1
static char *prev_func_name;
a829 1
  prev_func_name = NULL;
d1116 1
a1116 1
      save_infrun_state (inferior_ptid, prev_pc, prev_func_name,
d1127 1
a1127 1
      load_infrun_state (ecs->ptid, &prev_pc, &prev_func_name,
d1140 33
d2295 2
a2296 2
  if (PC_IN_SIGTRAMP (stop_pc, ecs->stop_func_name)
      && !PC_IN_SIGTRAMP (prev_pc, prev_func_name)
d2406 1
a2406 1
	  if (PC_IN_SIGTRAMP (stop_pc, ecs->stop_func_name)
d2595 2
a2596 2
      && PC_IN_SIGTRAMP (stop_pc, ecs->stop_func_name)
      && !PC_IN_SIGTRAMP (prev_pc, prev_func_name)
a2765 1
      prev_func_name = ecs->stop_func_name;
a2780 1
  prev_func_name = ecs->stop_func_name;
@


1.107.2.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@a669 6

/* Record the pc of the program the last time it stopped.  This is
   just used internally by wait_for_inferior, but need to be preserved
   over calls to it and cleared when the inferior is started.  */
static CORE_ADDR prev_pc;

a774 24
  /* Refresh prev_pc value just prior to resuming.  This used to be
     done in stop_stepping, however, setting prev_pc there did not handle
     scenarios such as inferior function calls or returning from
     a function via the return command.  In those cases, the prev_pc
     value was not set properly for subsequent commands.  The prev_pc value 
     is used to initialize the starting line number in the ecs.  With an 
     invalid value, the gdb next command ends up stopping at the position
     represented by the next line table entry past our start position.
     On platforms that generate one line table entry per line, this
     is not a problem.  However, on the ia64, the compiler generates
     extraneous line table entries that do not increase the line number.
     When we issue the gdb next command on the ia64 after an inferior call
     or a return command, we often end up a few instructions forward, still 
     within the original line we started.

     An attempt was made to have init_execution_control_state () refresh
     the prev_pc value before calculating the line number.  This approach
     did not work because on platforms that use ptrace, the pc register
     cannot be read unless the inferior is stopped.  At that point, we
     are not guaranteed the inferior is stopped and so the read_pc ()
     call can fail.  Setting the prev_pc value here ensures the value is 
     updated correctly when the inferior is stopped.  */  
  prev_pc = read_pc ();

d788 7
d832 1
d1119 1
a1119 1
      save_infrun_state (inferior_ptid, prev_pc,
d1130 1
a1130 1
      load_infrun_state (ecs->ptid, &prev_pc,
a1142 33
/* Wrapper for PC_IN_SIGTRAMP that takes care of the need to find the
   function's name.

   In a classic example of "left hand VS right hand", "infrun.c" was
   trying to improve GDB's performance by caching the result of calls
   to calls to find_pc_partial_funtion, while at the same time
   find_pc_partial_function was also trying to ramp up performance by
   caching its most recent return value.  The below makes the the
   function find_pc_partial_function solely responsibile for
   performance issues (the local cache that relied on a global
   variable - arrrggg - deleted).

   Using the testsuite and gcov, it was found that dropping the local
   "infrun.c" cache and instead relying on find_pc_partial_function
   increased the number of calls to 12000 (from 10000), but the number
   of times find_pc_partial_function's cache missed (this is what
   matters) was only increased by only 4 (to 3569).  (A quick back of
   envelope caculation suggests that the extra 2000 function calls
   @@1000 extra instructions per call make the 1 MIP VAX testsuite run
   take two extra seconds, oops :-)

   Long term, this function can be eliminated, replaced by the code:
   get_frame_type(current_frame()) == SIGTRAMP_FRAME (for new
   architectures this is very cheap).  */

static int
pc_in_sigtramp (CORE_ADDR pc)
{
  char *name;
  find_pc_partial_function (pc, &name, NULL, NULL);
  return PC_IN_SIGTRAMP (pc, name);
}

d2265 2
a2266 2
  if (pc_in_sigtramp (stop_pc)
      && !pc_in_sigtramp (prev_pc)
d2376 1
a2376 1
	  if (pc_in_sigtramp (stop_pc)
d2565 2
a2566 2
      && pc_in_sigtramp (stop_pc)
      && !pc_in_sigtramp (prev_pc)
d2730 9
d2752 1
@


1.106
log
@2003-04-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_SAVED_PC_AFTER_CALL): Deprecate
	SAVED_PC_AFTER_CALL.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_saved_pc_after_call): Update declaration.
	* i386ly-tdep.c (i386lynx_init_abi): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	* infrun.c (step_over_function): Update.
	* i386-linux-tdep.c (skip_hurd_resolver): Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	* arm-linux-tdep.c (skip_hurd_resolver): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	* x86-64-tdep.h (x86_64_linux_saved_pc_after_call): Update
	declaration.
@
text
@a793 1
static CORE_ADDR prev_func_start;
a831 1
  prev_func_start = 0;
d1119 1
a1119 2
      save_infrun_state (inferior_ptid, prev_pc,
			 prev_func_start, prev_func_name,
d1130 1
a1130 2
      load_infrun_state (ecs->ptid, &prev_pc,
			 &prev_func_start, &prev_func_name,
a2735 1
      prev_func_start = ecs->stop_func_start;
a2751 5
  prev_func_start = ecs->stop_func_start;	/* Ok, since if DECR_PC_AFTER
						   BREAK is defined, the
						   original pc would not have
						   been at the start of a
						   function. */
@


1.105
log
@2003-04-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (SAVED_PC_AFTER_CALL): Add a predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* d10v-tdep.c (d10v_saved_pc_after_call): Delete function.
	(d10v_gdbarch_init): Do not set saved_pc_after_call.
	* infrun.c (step_over_function): Call SAVED_PC_AFTER_CALL_P
	conditionally, use frame_pc_unwind as an alternative.  Add
	comments.
	* arch-utils.c (init_frame_pc_default): Only call
	SAVED_PC_AFTER_CALL when available.
@
text
@d2688 1
a2688 1
  /* NOTE: cagney/2003-04-06: Deprecate SAVED_PC_AFTER_CALL?
d2690 1
a2690 1
     The intent of SAVED_PC_AFTER_CALL was to:
d2712 2
a2713 2
  if (SAVED_PC_AFTER_CALL_P ())
    sr_sal.pc = ADDR_BITS_REMOVE (SAVED_PC_AFTER_CALL (get_current_frame ()));
@


1.104
log
@2003-04-08  Elena Zannoni  <ezannoni@@redhat.com>

        * infrun.c (stop_soon): Rename from stop_soon_quietly.
	(struct inferior_status): Rename stop_soon_quietly field to stop_soon.
	(clear_proceed_status): Rename stop_soon_quietly to stop_soon.
	(start_remote): Ditto.
	(handle_inferior_event): Ditto.
	(save_inferior_status): Ditto.
	(restore_inferior_status): Ditto.
	* infcmd.c (attach_command): Ditto.
	* fork-child.c (startup_inferior): Ditto.
        * inferior.h (stop_soon): Rename from stop_soon_quietly.
	* alpha-tdep.c (heuristic_proc_start): Ditto.
	* mips-tdep.c (heuristic_proc_start): Ditto.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Ditto.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Ditto.
	* solib-osf.c (osf_solib_create_inferior_hook): Ditto.
	* solib-irix.c (irix_solib_create_inferior_hook): Ditto.
	* remote-vx.c (vx_create_inferior): Ditto.
@
text
@d2678 38
a2715 1
  sr_sal.pc = ADDR_BITS_REMOVE (SAVED_PC_AFTER_CALL (get_current_frame ()));
@


1.103
log
@2003-04-08  Elena Zannoni  <ezannoni@@redhat.com>

	* infrun.c (stop_soon_quietly): Make it an enum, to better
	override the default behavior of handle_inferior_event.
	(clear_proceed_status): Update uses of stop_soon_quietly to
	reflect that it is now an enum.
	(start_remote): Ditto.
	(handle_inferior_event): Change logic a bit if stop_soon_quietly
	is set to handle the new GNU/Linux kernel behavior for
	attach/sigstop.  Update uses of stop_soon_quietly.
	* inferior.h (enum stop_kind): New enum.
	* infcmd.c (attach_command): Use STOP_QUIETLY_NO_SIGSTOP.
	Reset normal handle_inferior_event behavior, afterwards.
	* fork-child.c (startup_inferior): Update.
	* alpha-tdep.c (heuristic_proc_start): Update.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Update.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Update.
	* solib-osf.c (osf_solib_create_inferior_hook): Update.
	* solib-irix.c (irix_solib_create_inferior_hook): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* mips-tdep.c (heuristic_proc_start): Update.
@
text
@d289 1
a289 1
enum stop_kind stop_soon_quietly;
d662 1
a662 1
  stop_soon_quietly = NO_STOP_QUIETLY;
d805 1
a805 1
  stop_soon_quietly = STOP_QUIETLY;
d1261 1
a1261 1
      if (stop_soon_quietly == NO_STOP_QUIETLY)
d1761 2
a1762 2
      || stop_soon_quietly == STOP_QUIETLY
      || stop_soon_quietly == STOP_QUIETLY_NO_SIGSTOP)
d1773 1
a1773 1
      if (stop_soon_quietly == STOP_QUIETLY)
d1783 1
a1783 1
      if (stop_soon_quietly == STOP_QUIETLY_NO_SIGSTOP)
d3480 1
a3480 1
  int stop_soon_quietly;
d3526 1
a3526 1
  inf_status->stop_soon_quietly = stop_soon_quietly;
d3580 1
a3580 1
  stop_soon_quietly = inf_status->stop_soon_quietly;
@


1.102
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_BREAKPOINT_OFFSET): Default to zero.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sp64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* config/pa/tm-hppa64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* inferior.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET): Delete.
	* infcmd.c (run_stack_dummy): Simplify assuming
	CALL_DUMMY_BREAKPOINT_OFFSET_P.
	* infrun.c (handle_inferior_event): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set
	call_dummy_breakpoint_offset or call_dummy_breakpoint_offset_p.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@d289 1
a289 1
int stop_soon_quietly;
d662 1
a662 1
  stop_soon_quietly = 0;
d805 1
a805 1
  stop_soon_quietly = 1;
d1261 1
a1261 1
      if (!stop_soon_quietly)
d1760 3
a1762 1
	   || stop_signal == TARGET_SIGNAL_EMT)) || stop_soon_quietly)
d1770 4
a1773 1
      if (stop_soon_quietly)
d1776 12
@


1.102.2.1
log
@Merge with mainline.
@
text
@d289 1
a289 1
enum stop_kind stop_soon;
d662 1
a662 1
  stop_soon = NO_STOP_QUIETLY;
d805 1
a805 1
  stop_soon = STOP_QUIETLY;
d1261 1
a1261 1
      if (stop_soon == NO_STOP_QUIETLY)
d1760 1
a1760 3
	   || stop_signal == TARGET_SIGNAL_EMT))
      || stop_soon == STOP_QUIETLY
      || stop_soon == STOP_QUIETLY_NO_SIGSTOP)
d1768 1
a1768 4

      /* This is originated from start_remote(), start_inferior() and
         shared libraries hook functions.  */
      if (stop_soon == STOP_QUIETLY)
a1773 12
      /* This originates from attach_command().  We need to overwrite
         the stop_signal here, because some kernels don't ignore a
         SIGSTOP in a subsequent ptrace(PTRACE_SONT,SOGSTOP) call.
         See more comments in inferior.h.  */
      if (stop_soon == STOP_QUIETLY_NO_SIGSTOP)
	{
	  stop_stepping (ecs);
	  if (stop_signal == TARGET_SIGNAL_STOP)
	    stop_signal = TARGET_SIGNAL_0;
	  return;
	}

d2661 1
a2661 38

  /* NOTE: cagney/2003-04-06:

     At this point the equality get_frame_pc() == get_frame_func()
     should hold.  This may make it possible for this code to tell the
     frame where it's function is, instead of the reverse.  This would
     avoid the need to search for the frame's function, which can get
     very messy when there is no debug info available (look at the
     heuristic find pc start code found in targets like the MIPS).  */

  /* NOTE: cagney/2003-04-06: Deprecate SAVED_PC_AFTER_CALL?

     The intent of SAVED_PC_AFTER_CALL was to:

     - provide a very light weight equivalent to frame_unwind_pc()
     (nee FRAME_SAVED_PC) that avoids the prologue analyzer

     - avoid handling the case where the PC hasn't been saved in the
     prologue analyzer

     Unfortunatly, not five lines further down, is a call to
     get_frame_id() and that is guarenteed to trigger the prologue
     analyzer.
     
     The `correct fix' is for the prologe analyzer to handle the case
     where the prologue is incomplete (PC in prologue) and,
     consequently, the return pc has not yet been saved.  It should be
     noted that the prologue analyzer needs to handle this case
     anyway: frameless leaf functions that don't save the return PC;
     single stepping through a prologue.

     The d10v handles all this by bailing out of the prologue analsis
     when it reaches the current instruction.  */

  if (SAVED_PC_AFTER_CALL_P ())
    sr_sal.pc = ADDR_BITS_REMOVE (SAVED_PC_AFTER_CALL (get_current_frame ()));
  else
    sr_sal.pc = ADDR_BITS_REMOVE (frame_pc_unwind (get_current_frame ()));
d3463 1
a3463 1
  int stop_soon;
d3509 1
a3509 1
  inf_status->stop_soon = stop_soon;
d3563 1
a3563 1
  stop_soon = inf_status->stop_soon;
@


1.101
log
@2003-03-29  Andrew Cagney  <cagney@@redhat.com>

	* infttrace.h: New file.
	* hpread.c: Include "gdb_assert.h" and "somsolib.h".
	(hpread_get_textlow): Detect an uninitialized dn_bufp.
	(hpread_read_doc_function_type): Detect an initialized type1.
	(hpread_quick_traverse): Initialize mod_name_string.
	* somsolib.h: Add #ifdef SOMSOLIB_H wrapper.
	(som_solib_get_solib_by_pc): Declare.
	(so_lib_thread_start_addr): Declare.
	(no_shared_libraries): Declare.
	* somread.c (init_import_symbols): Make static.  Add forward
	declaration.
	* config/pa/nm-hppah.h: Include "infttrace.h" for
	parent_attach_all.
	(hppa_insert_hw_watchpoint): Declare.
	(hppa_can_use_hw_watchpoint, hppa_remove_hw_watchpoint): Declare.
	* hppah-nat.c: Include "gdb_string.h".
	(parent_attach_all): Delete extern declaration, moved to
	"infttrace.h".
	(hppa_can_use_hw_watchpoint): Change type of "type" parameter to
	int.
	(hppa_remove_hw_watchpoint, hppa_insert_hw_watchpoint): Ditto.
	* Makefile.in (infttrace_h): Define.
	(hpread.o): Update dependencies.
	(hppah-nat.o, hppa-hpux-tdep.o, hppa-tdep.o): Ditto.
	* hppa-hpux-tdep.c: Include "gdb_string.h".
	* hppa-tdep.c (hppa_frame_saved_pc): Initialize "old_pc".
	* infrun.c (handle_inferior_event): Always initialize
	stepped_after_stopped_by_watchpoint.  Add default and remove
	fallthrough in switch statement.
	* infttrace.c (hppa_can_use_hw_watchpoint): Change type of "type"
	parameter to int.
	(hppa_remove_hw_watchpoint): Ditto.
@
text
@d1815 16
a1834 3
	      || (!CALL_DUMMY_BREAKPOINT_OFFSET_P
		  && DEPRECATED_PC_IN_CALL_DUMMY (stop_pc, read_sp (),
				       get_frame_base (get_current_frame ())))
a1835 1

d1838 1
a1838 9
	  ecs->random_signal = !(bpstat_explains_signal (stop_bpstat)
				 /* End of a stack dummy.  Some systems (e.g. Sony
				    news) give another signal besides SIGTRAP, so
				    check here as well as above.  */
				 || (!CALL_DUMMY_BREAKPOINT_OFFSET_P
				     && DEPRECATED_PC_IN_CALL_DUMMY (stop_pc, read_sp (),
							  get_frame_base
							  (get_current_frame
							   ()))));
a2177 25
    }

  if (!CALL_DUMMY_BREAKPOINT_OFFSET_P)
    {
      /* This is the old way of detecting the end of the stack dummy.
         An architecture which defines CALL_DUMMY_BREAKPOINT_OFFSET gets
         handled above.  As soon as we can test it on all of them, all
         architectures should define it.  */

      /* If this is the breakpoint at the end of a stack dummy,
         just stop silently, unless the user was doing an si/ni, in which
         case she'd better know what she's doing.  */

      if (CALL_DUMMY_HAS_COMPLETED (stop_pc, read_sp (),
				    get_frame_base (get_current_frame ()))
	  && !step_range_end)
	{
	  stop_print_frame = 0;
	  stop_stack_dummy = 1;
#ifdef HP_OS_BUG
	  trap_expected_after_continue = 1;
#endif
	  stop_stepping (ecs);
	  return;
	}
@


1.100
log
@* Makefile.in (infrun.o): Add $(language_h)
* infrun.c (handle_inferior_event): Use skip_language_trampoline
for language specific trampolines.
* language.h (struct language_defn): Add skip_trampoline.
(skip_language_trampoline): Declare.
* language.c (unk_lang_trampoline, skip_language_trampoline):
New functions.
(unknown_language_defn, auto_language_defn, local_language_defn):
Add ukn_lang_trampoline.
* ada-lang.c (ada_language_defn): Add NULL for language
specific skip_trampoline.
* c-lang.c, f-lang.c, jv-lang.c, m2-lang.c, p-lang.c,
scm-lang.c: Likewise.
* objc-lang.c (objc_skip_trampoline): New function.
(objc_language_defn): Add objc_skip_trampoline.
@
text
@d1156 5
d1173 9
a1181 1
      /* Fall thru to the normal_state case. */
d1195 1
d1206 3
@


1.100.2.1
log
@Merge with mainline.
@
text
@a1155 5
  /* NOTE: cagney/2003-03-28: If you're looking at this code and
     thinking that the variable stepped_after_stopped_by_watchpoint
     isn't used, then you're wrong!  The macro STOPPED_BY_WATCHPOINT,
     defined in the file "config/pa/nm-hppah.h", accesses the variable
     indirectly.  Mutter something rude about the HP merge.  */
d1168 1
a1168 9
      /* See comments where a TARGET_WAITKIND_SYSCALL_RETURN event
         is serviced in this loop, below. */
      if (ecs->enable_hw_watchpoints_after_wait)
	{
	  TARGET_ENABLE_HW_WATCHPOINTS (PIDGET (inferior_ptid));
	  ecs->enable_hw_watchpoints_after_wait = 0;
	}
      stepped_after_stopped_by_watchpoint = 0;
      break;
a1181 1
      stepped_after_stopped_by_watchpoint = 0;
a1191 3

    default:
      internal_error (__FILE__, __LINE__, "bad switch");
@


1.99
log
@2003-03-20  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (DYNAMIC_TRAMPOLINE_NEXTPC): Delete macro.
	(handle_inferior_event): Remove code calling
	DYNAMIC_TRAMPOLINE_NEXTPC.
@
text
@d46 1
d2390 3
a2392 1
      real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
@


1.98
log
@        * infrun.c (observer.h): Add #include.
        (normal_stop): Add call to observer_notify_normal_stop.
        * Makefile.in (infrun.o): Add dependency on observer.h.
@
text
@a109 15
/* Dynamic function trampolines are similar to solib trampolines in that they
   are between the caller and the callee.  The difference is that when you
   enter a dynamic trampoline, you can't determine the callee's address.  Some
   (usually complex) code needs to run in the dynamic trampoline to figure out
   the callee's address.  This macro is usually called twice.  First, when we
   enter the trampoline (looks like a normal function call at that point).  It
   should return the PC of a point within the trampoline where the callee's
   address is known.  Second, when we hit the breakpoint, this routine returns
   the callee's address.  At that point, things proceed as per a step resume
   breakpoint.  */

#ifndef DYNAMIC_TRAMPOLINE_NEXTPC
#define DYNAMIC_TRAMPOLINE_NEXTPC(pc) 0
#endif

a2391 19
      else
	{
	  real_stop_pc = DYNAMIC_TRAMPOLINE_NEXTPC (stop_pc);
	  if (real_stop_pc)
	    {
	      struct symtab_and_line xxx;
	      /* Why isn't this s_a_l called "sr_sal", like all of the
	         other s_a_l's where this code is duplicated?  */
	      init_sal (&xxx);	/* initialize to zeroes */
	      xxx.pc = real_stop_pc;
	      xxx.section = find_pc_overlay (xxx.pc);
	      check_for_old_step_resume_breakpoint ();
	      step_resume_breakpoint =
		set_momentary_breakpoint (xxx, null_frame_id, bp_step_resume);
	      insert_breakpoints ();
	      keep_going (ecs);
	      return;
	    }
	}
@


1.97
log
@add HAVE_CONTINUABLE_WATCHPOINT to target_ops
@
text
@d45 1
d3117 1
@


1.96
log
@* infrun.c (handle_inferior_event): Rename 'tmp' to real_stop_pc.
Remove duplicate/shadowing variable of same name.
@
text
@a228 7
#ifndef HAVE_CONTINUABLE_WATCHPOINT
#define HAVE_CONTINUABLE_WATCHPOINT 0
#else
#undef  HAVE_CONTINUABLE_WATCHPOINT
#define HAVE_CONTINUABLE_WATCHPOINT 1
#endif

@


1.95
log
@2003-01-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame-unwind.h (frame_unwind_pop_ftype): Declare.
	(struct frame_unwind): Add field pop.
	* frame.h (frame_pop): Declare.
	* frame.c (frame_saved_regs_pop): New function.
	(trad_frame_unwinder): Add frame_saved_regs_pop.
	(frame_pop): New function.
	* dummy-frame.c (dummy_frame_pop): New function.
	(discard_innermost_dummy): New function.
	(generic_pop_dummy_frame): Use discard_innermost_dummy.
	(dummy_frame_unwind): Add dummy_frame_pop.
	* infrun.c (normal_stop): Call frame_pop instead of POP_FRAME.
	* valops.c (hand_function_call): Ditto.
	* stack.c (return_command): Ditto.
@
text
@d1175 1
a1175 1
  CORE_ADDR tmp;
d2410 3
a2412 3
      tmp = SKIP_TRAMPOLINE_CODE (stop_pc);
      if (tmp != 0)
	ecs->stop_func_start = tmp;
d2415 2
a2416 2
	  tmp = DYNAMIC_TRAMPOLINE_NEXTPC (stop_pc);
	  if (tmp)
d2422 1
a2422 1
	      xxx.pc = tmp;
a2484 2
      CORE_ADDR tmp;

d2486 1
a2486 1
      tmp = SKIP_TRAMPOLINE_CODE (stop_pc);
d2489 1
a2489 1
      if (tmp)
d2495 1
a2495 1
	  sr_sal.pc = tmp;
@


1.94
log
@2003-01-13  Elena Zannoni  <ezannoni@@redhat.com>

	* stack.c (print_frame_info, print_stack_frame_base_stub,
	print_stack_frame_base, show_and_print_stack_frame_stub,
	show_and_print_stack_frame, print_only_stack_frame_stub,
	print_only_stack_frame): Delete functions.
	(print_stack_frame_stub): Call print_frame_info instead of
	print_frame_info_base.
	(print_frame_info_base): Rename to print_frame_info.
	(backtrace_command_1): Call print_frame_info, instead of
	print_frame_info_base.
	(current_frame_command): Call print_stack_frame, instead of
	print_only_stack_frame.
	(frame_command): Call print_stack_frame, instead of
	show_and_print_stack_frame.
	(up_command): Ditto.
	(down_command): Ditto.
	* frame.h (print_only_stack_frame): Delete prototype.
	* infrun.c (normal_stop): Call print_stack_frame, instead of
	show_and_print_stack_frame.
	* thread.c (info_threads_command): Call print_stack_frame, instead
	of print_only_stack_frame.

2003-01-13  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-main.c (mi_cmd_exec_return): Use print_stack_frame instead of
	show_and_print_stack_frame.
@
text
@d3112 4
a3115 4
      /* Pop the empty frame that contains the stack dummy.
         POP_FRAME ends with a setting of the current frame, so we
         can use that next. */
      POP_FRAME;
@


1.93
log
@2003-01-09  Andrew Cagney  <ac131313@@redhat.com>

	* infrun.c (follow_fork): Use ISO C definition.
	* expprint.c (print_subexp): Use xfree instead of free.
	* charset.c: Include "gdb_string.h" instead of <string.h>.
	(register_iconv_charsets): Use ISO C definition.
	(host_charset, target_charset): Ditto.
	* Makefile.in (charset.o): Update dependencies.
	(mi-cmd-env.o): Update dependencies.

Index: mi/ChangeLog
2003-01-09  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Include "gdb_string.h" instead of <string.h>.
	Move all includes to after "defs.h".
@
text
@d5 1
a5 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software
d3096 1
a3096 1
	    show_and_print_stack_frame (deprecated_selected_frame, -1, source_flag);
@


1.93.2.1
log
@Merge branch with mainline:
POP_FRAME_P;
frame-unwind.h.
@
text
@d5 1
a5 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
d3096 1
a3096 1
	    print_stack_frame (deprecated_selected_frame, -1, source_flag);
d3112 4
a3115 4
      /* Pop the empty frame that contains the stack dummy.  POP_FRAME
         ends with a setting of the current frame, so we can use that
         next. */
      frame_pop (get_current_frame ());
@


1.92
log
@2002-12-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (deprecated_update_current_frame_pc_hack): Replace
	deprecated_update_current_frame_pc_hack.
	(deprecated_update_frame_base_hack): New function.
	* frame.h (deprecated_update_frame_pc_hack): Replace
	(deprecated_update_frame_base_hack): Declare.
	* infrun.c (normal_stop): Update.
@
text
@d69 1
a69 1
static int follow_fork ();
d380 1
a380 1
follow_fork ()
@


1.91
log
@	* infrun.c (handle_inferior_event): Rearrange code to resume if
	no catchpoint triggers for an event.
@
text
@d2988 1
a2988 1
    deprecated_update_current_frame_pc_hack (read_pc ());
@


1.90
log
@	* infrun.c (handle_inferior_event): Merge TARGET_WAITKIND_FORKED
	and TARGET_WAITKIND_VFORKED cases.
@
text
@d1347 8
d1403 8
a1848 2
  /* If a fork, vfork or exec event was seen, then there are two
     possible responses we can make:
a1849 13
     1. If a catchpoint triggers for the event (ecs->random_signal == 0),
     then we must stop now and issue a prompt.  We will resume
     the inferior when the user tells us to.
     2. If no catchpoint triggers for the event (ecs->random_signal == 1),
     then we must resume the inferior now and keep checking.

     In either case, we must take appropriate steps to "follow" the
     the fork/vfork/exec when the inferior is resumed.  For example,
     if follow-fork-mode is "child", then we must detach from the
     parent inferior and follow the new child inferior.

     In either case, setting pending_follow causes the next resume()
     to take the appropriate following action. */
a1850 31
  if (ecs->ws.kind == TARGET_WAITKIND_FORKED)
    {
      if (ecs->random_signal)	/* I.e., no catchpoint triggered for this. */
	{
	  trap_expected = 1;
	  stop_signal = TARGET_SIGNAL_0;
	  keep_going (ecs);
	  return;
	}
    }
  else if (ecs->ws.kind == TARGET_WAITKIND_VFORKED)
    {
      if (ecs->random_signal)	/* I.e., no catchpoint triggered for this. */
	{
	  stop_signal = TARGET_SIGNAL_0;
	  keep_going (ecs);
	  return;
	}
    }
  else if (ecs->ws.kind == TARGET_WAITKIND_EXECD)
    {
      pending_follow.kind = ecs->ws.kind;
      if (ecs->random_signal)	/* I.e., no catchpoint triggered for this. */
	{
	  trap_expected = 1;
	  stop_signal = TARGET_SIGNAL_0;
	  keep_going (ecs);
	  return;
	}
    }

@


1.89
log
@	* infrun.c (handle_inferior_event): Assume that catchpoints
	are not affected by DECR_PC_AFTER_BREAK.
@
text
@d1329 1
a1334 51

      stop_pc = read_pc_pid (ecs->ptid);
      ecs->saved_inferior_ptid = inferior_ptid;
      inferior_ptid = ecs->ptid;

      /* Assume that catchpoints are not really software breakpoints.  If
	 some future target implements them using software breakpoints then
	 that target is responsible for fudging DECR_PC_AFTER_BREAK.  Thus
	 we pass 1 for the NOT_A_SW_BREAKPOINT argument, so that
	 bpstat_stop_status will not decrement the PC.  */

      stop_bpstat = bpstat_stop_status (&stop_pc, 1);

      ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
      inferior_ptid = ecs->saved_inferior_ptid;
      goto process_event_stop_test;

      /* If this a platform which doesn't allow a debugger to touch a
         vfork'd inferior until after it exec's, then we'd best keep
         our fingers entirely off the inferior, other than continuing
         it.  This has the unfortunate side-effect that catchpoints
         of vforks will be ignored.  But since the platform doesn't
         allow the inferior be touched at vfork time, there's really
         little choice. */
    case TARGET_WAITKIND_VFORKED:
      stop_signal = TARGET_SIGNAL_TRAP;
      pending_follow.kind = ecs->ws.kind;

      /* Is this a vfork of the parent?  If so, then give any
         vfork catchpoints a chance to trigger now.  (It's
         dangerous to do so if the child canot be touched until
         it execs, and the child has not yet exec'd.  We probably
         should warn the user to that effect when the catchpoint
         triggers...) */
      if (ptid_equal (ecs->ptid, inferior_ptid))
	{
	  pending_follow.fork_event.parent_pid = PIDGET (ecs->ptid);
	  pending_follow.fork_event.child_pid = ecs->ws.value.related_pid;
	}

      /* If we've seen the child's vfork event but cannot really touch
         the child until it execs, then we must continue the child now.
         Else, give any vfork catchpoints a chance to trigger now. */
      else
	{
	  pending_follow.fork_event.child_pid = PIDGET (ecs->ptid);
	  pending_follow.fork_event.parent_pid = ecs->ws.value.related_pid;
	  target_post_startup_inferior (pid_to_ptid
					(pending_follow.fork_event.
					 child_pid));
	}
@


1.88
log
@2002-12-13  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (deprecated_update_current_frame_pc_hack): New
	function.
	* frame.h (deprecated_update_current_frame_pc_hack): Declare.
	* infrun.c (normal_stop): Use said function instead of directly
	modifying the frame's PC.
@
text
@d1338 9
a1346 11
      /* The second argument of bpstat_stop_status is meant to help
         distinguish between a breakpoint trap and a singlestep trap.
         This is only important on targets where DECR_PC_AFTER_BREAK
         is non-zero.  The prev_pc test is meant to distinguish between
         singlestepping a trap instruction, and singlestepping thru a
         jump to the instruction following a trap instruction. */

      stop_bpstat = bpstat_stop_status (&stop_pc,
					currently_stepping (ecs) &&
					prev_pc !=
					stop_pc - DECR_PC_AFTER_BREAK);
d1387 9
a1395 11
      /* The second argument of bpstat_stop_status is meant to help
         distinguish between a breakpoint trap and a singlestep trap.
         This is only important on targets where DECR_PC_AFTER_BREAK
         is non-zero.  The prev_pc test is meant to distinguish between
         singlestepping a trap instruction, and singlestepping thru a
         jump to the instruction following a trap instruction. */

      stop_bpstat = bpstat_stop_status (&stop_pc,
					currently_stepping (ecs) &&
					prev_pc !=
					stop_pc - DECR_PC_AFTER_BREAK);
d1434 9
a1442 11
      /* The second argument of bpstat_stop_status is meant to help
         distinguish between a breakpoint trap and a singlestep trap.
         This is only important on targets where DECR_PC_AFTER_BREAK
         is non-zero.  The prev_pc test is meant to distinguish between
         singlestepping a trap instruction, and singlestepping thru a
         jump to the instruction following a trap instruction. */

      stop_bpstat = bpstat_stop_status (&stop_pc,
					currently_stepping (ecs) &&
					prev_pc !=
					stop_pc - DECR_PC_AFTER_BREAK);
@


1.87
log
@	* infrun.c (pending_follow): Remove saw_parent_fork, saw_child_fork,
	and saw_child_exec.
	(follow_fork, init_wait_for_inferior, handle_inferior_event): Remove
	references to saw_parent_fork, saw_child_fork, and saw_child_exec.
	(stop_stepping): Remove outdated check for child vfork events.
@
text
@d3069 6
a3074 2
  if (target_has_execution && get_current_frame ())
    (get_current_frame ())->pc = read_pc ();
@


1.86
log
@2002-12-06  Andrew Cagney  <ac131313@@redhat.com>

	* breakpoint.h (struct breakpoint): Replace frame with frame_id.
	(set_momentary_breaokpoint): Replace `struct frame_info' parameter
	with `struct frame_id'.
	(set_longjmp_resume_breakpoint): Ditto.
	* infrun.c (handle_inferior_event): Update.
	* breakpoint.c (watch_command_1, until_break_command): Update.
	* infrun.c (handle_inferior_event, check_sigtramp2): Update.
	(handle_inferior_event, step_over_function): Update.
	* breakpoint.c (bpstat_stop_status, print_one_breakpoint): Update.
	(set_raw_breakpoint, set_longjmp_resume_breakpoint): Update.
	(set_momentary_breakpoint, deprecated_frame_in_dummy): Update.
	* infcmd.c (finish_command, run_stack_dummy): Update.
@
text
@a357 1
    int saw_parent_fork;
a358 2
    int saw_child_fork;
    int saw_child_exec;
a392 3
  pending_follow.fork_event.saw_parent_fork = 0;
  pending_follow.fork_event.saw_child_fork = 0;

a866 3
  pending_follow.fork_event.saw_parent_fork = 0;
  pending_follow.fork_event.saw_child_fork = 0;
  pending_follow.fork_event.saw_child_exec = 0;
a1331 1
      pending_follow.fork_event.saw_child_fork = 1;
a1371 1
	  pending_follow.fork_event.saw_parent_fork = 1;
a1380 1
	  pending_follow.fork_event.saw_child_fork = 1;
a2810 24
      /* Are we stopping for a vfork event?  We only stop when we see
         the child's event.  However, we may not yet have seen the
         parent's event.  And, inferior_ptid is still set to the
         parent's pid, until we resume again and follow either the
         parent or child.

         To ensure that we can really touch inferior_ptid (aka, the
         parent process) -- which calls to functions like read_pc
         implicitly do -- wait on the parent if necessary. */
      if ((pending_follow.kind == TARGET_WAITKIND_VFORKED)
	  && !pending_follow.fork_event.saw_parent_fork)
	{
	  ptid_t parent_ptid;

	  do
	    {
	      if (target_wait_hook)
		parent_ptid = target_wait_hook (pid_to_ptid (-1), &(ecs->ws));
	      else
		parent_ptid = target_wait (pid_to_ptid (-1), &(ecs->ws));
	    }
	  while (!ptid_equal (parent_ptid, inferior_ptid));
	}

@


1.85
log
@	* config/pa/nm-hppah.h (CHILD_POST_FOLLOW_VFORK): Change to
	CHILD_FOLLOW_FORK.
	* hppah-nat.c (saved_vfork_pid): Add.
	(child_post_follow_vfork): Remove.
	(child_follow_fork): New function.
	(child_wait): Call detach_breakpoints after receiving the child vfork.
	Call child_resume directly instead of going through resume ().
	Make sure we have the exec before reporting the vfork.
	* inferior.h (follow_inferior_reset_breakpoints): Add prototype.
	* infrun.c (follow_fork, follow_vfork, follow_inferior_fork): Remove.
	(follow_fork): New function.  Call target_follow_fork.
	(follow_inferior_reset_breakpoints): New function broken out from
	old follow_inferior_fork.
	(resume): Remove hack to follow exec after vfork.
	* inftarg.c (child_post_follow_vfork): Remove.
	(child_follow_fork): New function.
	(init_child_ops): Replace to_post_follow_vfork with to_follow_fork.
	* target.c (cleanup_target): Replace to_post_follow_vfork with
	to_follow_fork.
	(update_current_target): Likewise.
	(setup_target_debug): Likewise.
	(debug_to_post_follow_vfork): Remove.
	(debug_to_follow_fork): New function.
	* target.h (struct target_ops): Replace to_post_folow_vfork with
	to_follow_fork.
	(child_post_follow_vfork): Remove prototype.
	(child_follow_fork): Add prototype.
	(target_post_follow_vfork): Remove macro.
	(target_follow_fork): Add macro.

testsuite/
	* gdb.base/foll-vfork.exp: Re-enable test on HP/UX.
@
text
@d2066 1
a2066 1
	  set_longjmp_resume_breakpoint (jmp_buf_pc, NULL);
d2359 1
a2359 1
	    set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
d2415 1
a2415 1
	      set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
d2524 1
a2524 1
		set_momentary_breakpoint (xxx, NULL, bp_step_resume);
d2602 1
a2602 1
	    set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
d2716 1
a2716 1
	set_momentary_breakpoint (sr_sal, NULL, bp_through_sigtramp);
d2774 1
a2774 1
	set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
d2807 2
a2808 1
    set_momentary_breakpoint (sr_sal, get_current_frame (), bp_step_resume);
d2812 1
a2812 3
    /* FIXME: cagney/2002-12-01: Someone should modify the breakpoint
       code so that it uses a frame ID, instead of a frame address.  */
    step_resume_breakpoint->frame = step_frame_id.base;
@


1.84
log
@	* hppah-nat.c (saved_child_execd_pathname, saved_vfork_state): New.
	(child_post_follow_vfork): Cancel pending exec event if we follow
	the parent.
	(child_wait): Only return TARGET_WAITKIND_VFORKED when all necessary
	events have been processed.  Return a fake TARGET_WAITKIND_EXECD
	event at the following wait call if necessary.
	* infrun.c (follow_vfork): Don't follow_exec here.
	(handle_inferior_event): Add comment to TARGET_WAITKIND_EXECD
	case about HP/UX 10.20.  Remove code pushed down to
	hppah-nat.c:child_wait.
	* infttrace.c (child_resume): Use TT_PROC_CONTINUE if
	vfork_in_flight is set.
@
text
@d69 1
a69 6
static void follow_inferior_fork (int parent_pid, int child_pid,
				  int has_forked, int has_vforked);

static void follow_fork (int parent_pid, int child_pid);

static void follow_vfork (int parent_pid, int child_pid);
d382 2
a383 3
static void
follow_inferior_fork (int parent_pid, int child_pid, int has_forked,
		      int has_vforked)
a384 4
  int followed_parent = 0;
  int followed_child = 0;

  /* Which process did the user want us to follow? */
d386 1
a395 114
  /* If we're to be following the parent, then detach from child_pid.
     We're already following the parent, so need do nothing explicit
     for it. */
  if (follow_mode == follow_fork_mode_parent)
    {
      followed_parent = 1;

      /* We're already attached to the parent, by default. */

      /* Before detaching from the child, remove all breakpoints from
         it.  (This won't actually modify the breakpoint list, but will
         physically remove the breakpoints from the child.) */
      detach_breakpoints (child_pid);
#ifdef SOLIB_REMOVE_INFERIOR_HOOK
      SOLIB_REMOVE_INFERIOR_HOOK (child_pid);
#endif

      /* Detach from the child. */
      dont_repeat ();

      target_require_detach (child_pid, "", 1);
    }

  /* If we're to be following the child, then attach to it, detach
     from inferior_ptid, and set inferior_ptid to child_pid. */
  else if (follow_mode == follow_fork_mode_child)
    {
      char child_pid_spelling[100];	/* Arbitrary length. */

      followed_child = 1;

      /* Before detaching from the parent, detach all breakpoints from
         the child.  Note that this only works if we're following vforks
	 right away; if we've exec'd then the breakpoints are already detached
	 and the shadow contents are out of date.  */
      detach_breakpoints (child_pid);

      /* Before detaching from the parent, remove all breakpoints from it. */
      remove_breakpoints ();

      /* Also reset the solib inferior hook from the parent. */
#ifdef SOLIB_REMOVE_INFERIOR_HOOK
      SOLIB_REMOVE_INFERIOR_HOOK (PIDGET (inferior_ptid));
#endif

      /* Detach from the parent. */
      dont_repeat ();
      target_detach (NULL, 1);

      /* Attach to the child. */
      inferior_ptid = pid_to_ptid (child_pid);
      sprintf (child_pid_spelling, "%d", child_pid);
      dont_repeat ();

      target_require_attach (child_pid_spelling, 1);

      /* Was there a step_resume breakpoint?  (There was if the user
         did a "next" at the fork() call.)  If so, explicitly reset its
         thread number.

         step_resumes are a form of bp that are made to be per-thread.
         Since we created the step_resume bp when the parent process
         was being debugged, and now are switching to the child process,
         from the breakpoint package's viewpoint, that's a switch of
         "threads".  We must update the bp's notion of which thread
         it is for, or it'll be ignored when it triggers... */
      /* As above, if we're following vforks at exec time then resetting the
	 step resume breakpoint is probably wrong.  */
      if (step_resume_breakpoint)
	breakpoint_re_set_thread (step_resume_breakpoint);

      /* Reinsert all breakpoints in the child.  (The user may've set
         breakpoints after catching the fork, in which case those
         actually didn't get set in the child, but only in the parent.) */
      breakpoint_re_set ();
      insert_breakpoints ();
    }

  /* The parent and child of a vfork share the same address space.
     Also, on some targets the order in which vfork and exec events
     are received for parent in child requires some delicate handling
     of the events.

     For instance, on ptrace-based HPUX we receive the child's vfork
     event first, at which time the parent has been suspended by the
     OS and is essentially untouchable until the child's exit or second
     exec event arrives.  At that time, the parent's vfork event is
     delivered to us, and that's when we see and decide how to follow
     the vfork.  But to get to that point, we must continue the child
     until it execs or exits.  To do that smoothly, all breakpoints
     must be removed from the child, in case there are any set between
     the vfork() and exec() calls.  But removing them from the child
     also removes them from the parent, due to the shared-address-space
     nature of a vfork'd parent and child.  On HPUX, therefore, we must
     take care to restore the bp's to the parent before we continue it.
     Else, it's likely that we may not stop in the expected place.  (The
     worst scenario is when the user tries to step over a vfork() call;
     the step-resume bp must be restored for the step to properly stop
     in the parent after the call completes!)

     Sequence of events, as reported to gdb from HPUX:

     Parent        Child           Action for gdb to take
     -------------------------------------------------------
     1                VFORK               Continue child
     2                EXEC
     3                EXEC or EXIT
     4  VFORK */
  if (has_vforked)
    {
      target_post_follow_vfork (parent_pid,
				followed_parent, child_pid, followed_child);
    }

d398 2
d402 2
a403 2
static void
follow_fork (int parent_pid, int child_pid)
d405 18
a422 2
  follow_inferior_fork (parent_pid, child_pid, 1, 0);
}
d424 2
a425 8

/* Forward declaration. */
static void follow_exec (int, char *);

static void
follow_vfork (int parent_pid, int child_pid)
{
  follow_inferior_fork (parent_pid, child_pid, 0, 1);
d614 1
a614 1
     now to be followed, then do so. */
d617 2
a618 1
    case (TARGET_WAITKIND_FORKED):
d620 2
a621 2
      follow_fork (PIDGET (inferior_ptid),
		   pending_follow.fork_event.child_pid);
d624 2
a625 21
    case (TARGET_WAITKIND_VFORKED):
      {
	int saw_child_exec = pending_follow.fork_event.saw_child_exec;

	pending_follow.kind = TARGET_WAITKIND_SPURIOUS;
	follow_vfork (PIDGET (inferior_ptid),
		      pending_follow.fork_event.child_pid);

	/* Did we follow the child, but not yet see the child's exec event?
	   If so, then it actually ought to be waiting for us; we respond to
	   parent vfork events.  We don't actually want to resume the child
	   in this situation; we want to just get its exec event. */
	if (!saw_child_exec &&
	    (PIDGET (inferior_ptid) == pending_follow.fork_event.child_pid))
	  should_resume = 0;
      }
      break;

    case (TARGET_WAITKIND_EXECD):
      /* If we saw a vfork event but couldn't follow it until we saw
         an exec, then now might be the time! */
a626 1
      /* follow_exec is called as soon as the exec event is seen. */
@


1.83
log
@	* hppah-nat.c (child_wait): Return TARGET_WAITKIND_IGNORE
	for the parent's fork event.
	* infrun.c (handle_inferior_event): Only expect one fork event.
	Call prepare_to_wait for TARGET_WAITKIND_IGNORE.  Update comment.
	* target.h: Update comment for TARGET_WAITKIND_IGNORE.
@
text
@a536 10

  /* Did we follow the child?  Had it exec'd before we saw the parent vfork? */
  if (pending_follow.fork_event.saw_child_exec
      && (PIDGET (inferior_ptid) == child_pid))
    {
      pending_follow.fork_event.saw_child_exec = 0;
      pending_follow.kind = TARGET_WAITKIND_SPURIOUS;
      follow_exec (PIDGET (inferior_ptid), pending_follow.execd_pathname);
      xfree (pending_follow.execd_pathname);
    }
d1548 3
a1570 30

      /* Did inferior_ptid exec, or did a (possibly not-yet-followed)
         child of a vfork exec?

         ??rehrauer: This is unabashedly an HP-UX specific thing.  On
         HP-UX, events associated with a vforking inferior come in
         threes: a vfork event for the child (always first), followed
         a vfork event for the parent and an exec event for the child.
         The latter two can come in either order.

         If we get the parent vfork event first, life's good: We follow
         either the parent or child, and then the child's exec event is
         a "don't care".

         But if we get the child's exec event first, then we delay
         responding to it until we handle the parent's vfork.  Because,
         otherwise we can't satisfy a "catch vfork". */
      if (pending_follow.kind == TARGET_WAITKIND_VFORKED)
	{
	  pending_follow.fork_event.saw_child_exec = 1;

	  /* On some targets, the child must be resumed before
	     the parent vfork event is delivered.  A single-step
	     suffices. */
	  if (RESUME_EXECD_VFORKING_CHILD_TO_GET_PARENT_VFORK ())
	    target_resume (ecs->ptid, 1, TARGET_SIGNAL_0);
	  /* We expect the parent vfork event to be available now. */
	  prepare_to_wait (ecs);
	  return;
	}
@


1.82
log
@2002-12-05  Andrew Cagney  <ac131313@@redhat.com>

	* gdbthread.h: Include "frame.h".
	(struct thread_info): Replace step_frame_address with
	step_frame_id.
	* inferior.h: Include "frame.h".
	(step_frame_id): Replace external variable step_frame_address.
	* gdbthread.h (save_infrun_state): Replace step_frame_address
	parameter with step_frame_id parameter.
	(load_infrun_state): Ditto.
	* Makefile.in (gdbthread_h, inferior_h): Add $(frame_h).
	* infcmd.c (step_frame_id, step_1, step_once): Update.
	* thread.c (load_infrun_state, save_infrun_state): Update.
	* infrun.c (clear_proceed_status, save_inferior_status): Update.
	(handle_inferior_event, step_over_function): Update.
	(normal_stop, context_switch, restore_inferior_status): Update.
	(struct inferior_status): Replace step_frame_address with
	step_frame_id.
@
text
@d1481 3
a1483 18
      /* Ignore fork events reported for the parent; we're only
         interested in reacting to forks of the child.  Note that
         we expect the child's fork event to be available if we
         waited for it now. */
      if (ptid_equal (inferior_ptid, ecs->ptid))
	{
	  pending_follow.fork_event.saw_parent_fork = 1;
	  pending_follow.fork_event.parent_pid = PIDGET (ecs->ptid);
	  pending_follow.fork_event.child_pid = ecs->ws.value.related_pid;
	  prepare_to_wait (ecs);
	  return;
	}
      else
	{
	  pending_follow.fork_event.saw_child_fork = 1;
	  pending_follow.fork_event.child_pid = PIDGET (ecs->ptid);
	  pending_follow.fork_event.parent_pid = ecs->ws.value.related_pid;
	}
d1691 7
a1697 5
         done what needs to be done, if anything. This case can
         occur only when the target is async or extended-async. One
         of the circumstamces for this to happen is when the
         inferior produces output for the console. The inferior has
         not stopped, and we are ignoring the event. */
d1699 1
a1699 1
      ecs->wait_some_more = 1;
@


1.81
log
@2002-12-03  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (get_frame_id): Convert to a function.
	(null_frame_id, frame_id_p): Declare.
	(frame_id_eq, frame_id_inner): Declare.
	(frame_id_build): New function.
	* frame.c (get_frame_id): Update.  Use null_frame_id.
	(frame_find_by_id): Rewrite using frame_id_p, frame_id_eq and
	frame_id_inner.
	(null_frame_id, frame_id_p): Define.
	(frame_id_eq, frame_id_inner): Define.
	(frame_id_build): New function.
	* varobj.c (varobj_create): Update.
	(varobj_update): Update.
	* valops.c (value_assign): Update.
	(new_root_variable): Update.
	* infrun.c (save_inferior_status): Update.
	* breakpoint.c (watch_command_1): Update.
@
text
@d825 1
a825 1
  step_frame_address = 0;
d1294 1
a1294 1
			 step_range_end, step_frame_address,
d1306 1
a1306 1
			 &step_range_end, &step_frame_address,
d2258 2
a2259 2
	    && (INNER_THAN (get_frame_base (get_current_frame ()),
			    step_frame_address)))
d2570 1
a2570 1
	CORE_ADDR current_frame = get_frame_base (get_current_frame ());
d2572 1
a2572 1
	if (INNER_THAN (current_frame, step_frame_address))
d2592 1
a2592 2
	       step_frame_address; I don't think anyone thought to
	       try it.  */
d2666 2
a2667 1
	      && INNER_THAN (step_frame_address, read_sp ()))
d2671 6
a2676 7
	       trampoline isn't such a bad idea.  In order to do
	       that, we have to ignore the value in
	       step_frame_address, since that doesn't represent the
	       frame that'll reach when we return from the signal
	       trampoline.  Otherwise we'll probably continue to the
	       end of the program.  */
	    step_frame_address = 0;
d2840 1
a2840 1
  step_frame_address = get_frame_base (get_current_frame ());
d2844 3
a2846 3
  /* In the case where we just stepped out of a function into the middle
     of a line of the caller, continue stepping, but step_frame_address
     must be modified to current frame */
d2848 3
a2850 3
    CORE_ADDR current_frame = get_frame_base (get_current_frame ());
    if (!(INNER_THAN (current_frame, step_frame_address)))
      step_frame_address = current_frame;
d2973 1
a2973 1
   caller's frame (step_frame_address, which is set by the "next" or
d2989 5
a2993 2
  if (step_frame_address && !IN_SOLIB_DYNSYM_RESOLVE_CODE (sr_sal.pc))
    step_resume_breakpoint->frame = step_frame_address;
d3357 3
d3361 2
a3362 1
		  && step_frame_address == get_frame_base (get_current_frame ())
d3800 1
a3800 1
  CORE_ADDR step_frame_address;
d3847 1
a3847 1
  inf_status->step_frame_address = step_frame_address;
d3877 2
a3878 2
  /* If inf_status->selected_frame_address is NULL, there was no
     previously selected frame.  */
d3901 1
a3901 1
  step_frame_address = inf_status->step_frame_address;
@


1.80
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d3859 1
a3859 1
  get_frame_id (deprecated_selected_frame, &inf_status->selected_frame_id);
@


1.79
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d2055 1
a2055 1
		  && PC_IN_CALL_DUMMY (stop_pc, read_sp (),
d2066 1
a2066 1
				     && PC_IN_CALL_DUMMY (stop_pc, read_sp (),
@


1.78
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@d3345 1
a3345 1
      if (stop_print_frame && selected_frame)
d3389 1
a3389 1
	    show_and_print_stack_frame (selected_frame, -1, source_flag);
d3859 1
a3859 1
  get_frame_id (selected_frame, &inf_status->selected_frame_id);
@


1.77
log
@	* config/pa/nm-hppah.h (CHILD_POST_FOLLOW_INFERIOR_BY_CLONE): Don't
	define.
	(struct target_waitstatus): Add opaque definition.
	* corelow.c (init_core_ops): Don't set to_clone_and_follow_inferior.
	* exec.c (init_exec_ops): Likewise.
	* fork-child.c (clone_and_follow_inferior): Remove.
	* hppah-nat.c (child_post_follow_inferior_by_clone): Remove.
	* inferior.h (clone_and_follow_inferior): Remove prototype.
	* infrun.c (follow_fork_mode_both): Remove.
	(follow_fork_mode_kind_names): Remove commented out "both".
	(follow_inferior_fork): Remove follow_fork_mode_both support.
	* inftarg.c (child_clone_and_follow_inferior): Remove.
	(child_post_follow_inferior_by_clone): Remove.
	(init_child_ops): Don't set to_clone_and_follow_inferior
	or to_post_follow_inferior_by_clone.
	* target.c (default_clone_and_follow_inferior): Remove.
	(cleanup_target): Don't set to_clone_and_follow_inferior
	or to_post_follow_inferior_by_clone.
	(find_default_clone_and_follow_inferior): Remove.
	(init_dummy_target): Don't set to_clone_and_follow_inferior.
	(debug_to_clone_and_follow_inferior): Remove.
	(debug_to_post_follow_inferior_by_clone): Remove.
	(setup_target_debug): Don't set to_clone_and_follow_inferior
	or to_post_follow_inferior_by_clone.
	* target.h (struct target_ops): Remove to_clone_and_follow_inferior
	and to_post_follow_inferior_by_clone.
	(child_clone_and_follow_inferior): Remove prototype.
	(child_post_follow_inferior_by_clone): Remove prototype.
	(target_clone_and_follow_inferior): Remove macro.
	(target_post_follow_inferior_by_clone): Remove macro.
	(find_default_clone_and_follow_inferior): Remove prototype.
@
text
@d2056 1
a2056 1
				       FRAME_FP (get_current_frame ())))
d2067 1
a2067 1
							  FRAME_FP
d2258 1
a2258 1
	    && (INNER_THAN (FRAME_FP (get_current_frame ()),
d2469 1
a2469 1
				    FRAME_FP (get_current_frame ()))
d2570 1
a2570 1
	CORE_ADDR current_frame = FRAME_FP (get_current_frame ());
d2841 1
a2841 1
  step_frame_address = FRAME_FP (get_current_frame ());
d2849 1
a2849 1
    CORE_ADDR current_frame = FRAME_FP (get_current_frame ());
d3356 1
a3356 1
		  && step_frame_address == FRAME_FP (get_current_frame ())
@


1.76
log
@	* breakpoint.c (bpstat_stop_status): Call inferior_has_forked,
	inferior_has_vforked, and inferior_has_execd instead of
	target_has_forked, target_has_vforked, and target_has_execd.
	* config/pa/nm-hppah.h (CHILD_HAS_FORKED, CHILD_HAS_VFORKED)
	(CHILD_HAS_EXECD, CHILD_HAS_SYSCALL_EVENT): Don't define.
	(CHILD_WAIT): Define.
	(child_wait): Add prototype.
	* hppah-nat.c (hpux_has_forked): Rename from child_has_forked.
	Add prototype.
	(hpux_has_vforked): Likewise, from child_has_vforked.
	(hpux_has_execd): Likewise, from child_has_execd.
	(hpux_has_syscall_event): Likewise, from child_has_syscall_event.
	(not_same_real_pid, child_wait): New, copied from inftarg.c.
	Call hpux_has_forked, hpux_has_vforked, hpux_has_execd,
	and hpux_has_syscall_event instead of the target hooks.
	* infrun.c (inferior_has_forked, inferior_has_vforked)
	(inferior_has_execd): New functions.
	* inftarg.c (not_same_real_pid): Remove.
	(child_wait): Remove references to not_same_real_pid,
	target_has_forked, target_has_vforked, target_has_execd,
	and target_has_syscall_event.
	(child_has_forked, child_has_vforked, child_has_execd)
	(child_has_syscall_event): Remove.
	(init_child_ops): Remove references to child_has_forked,
	child_has_vforked, child_has_execd, and child_has_syscall_event.
	* infttrace.c (hpux_has_forked): Rename from child_has_forked.
	(hpux_has_vforked): Likewise, from child_has_vforked.
	(hpux_has_execd): Likewise, from child_has_execd.
	(hpux_has_syscall_event): Likewise, from child_has_syscall_event.
	* target.c (cleanup_target): Remove references to
	to_has_forked, to_has_vforked, to_has_execd, and
	to_has_syscall_event.
	(update_current_target): Likewise.
	(setup_target_debug): Likewise.
	(debug_to_has_forked): Remove.
	(debug_to_has_vforked): Remove.
	(debug_to_has_execd): Remove.
	(debug_to_has_syscall_event): Remove.
	* target.h (struct target_ops): Remove to_has_forked.
	to_has_vforked, to_has_execd, and to_has_syscall_event.
	(child_has_forked, child_has_vforked, child_has_execd)
	(child_has_syscall_event): Remove prototypes.
	(inferior_has_forked, inferior_has_vforked, inferior_has_execd): Add
	prototypes.
	(target_has_forked, target_has_vforked, target_has_execd)
	(target_has_syscall_event): Remove macros.
@
text
@a373 1
static const char follow_fork_mode_both[] = "both";
a378 5
  /* ??rehrauer: The "both" option is broken, by what may be a 10.20
     kernel problem.  It's also not terribly useful without a GUI to
     help the user drive two debuggers.  So for now, I'm disabling the
     "both" option. */
  /* follow_fork_mode_both, */
a480 18
    }

  /* If we're to be following both parent and child, then fork ourselves,
     and attach the debugger clone to the child. */
  else if (follow_mode == follow_fork_mode_both)
    {
      char pid_suffix[100];	/* Arbitrary length. */

      /* Clone ourselves to follow the child.  This is the end of our
         involvement with child_pid; our clone will take it from here... */
      dont_repeat ();
      target_clone_and_follow_inferior (child_pid, &followed_child);
      followed_parent = !followed_child;

      /* We continue to follow the parent.  To help distinguish the two
         debuggers, though, both we and our clone will reset our prompts. */
      sprintf (pid_suffix, "[%d] ", PIDGET (inferior_ptid));
      set_prompt (strcat (get_prompt (), pid_suffix));
@


1.75
log
@	* hppah-nat.c (child_can_follow_vfork_prior_to_exec): Remove.
	* inftarg.c (child_can_follow_vfork_prior_to_exec): Remove.
	(init_child_ops): Don't initialize to_can_follow_vfork_prior_to_exec.
	* infttrace.c (child_can_follow_vfork_prior_to_exec): Remove.
	* target.c (cleanup_target): Remove reference to
	to_can_follow_vfork_prior_to_exec.
	(update_current_target): Likewise.
	(debug_to_can_follow_vfork_prior_to_exec): Remove.
	(setup_target_debug): Remove reference to
	to_can_follow_vfork_prior_to_exec.
	* target.h (struct target_ops): Remove
	to_can_follow_vfork_prior_to_exec.
	(child_can_follow_vfork_prior_to_exec): Remove prototype.
	(target_can_follow_vfork_prior_to_exec): Remove definition.
	* config/pa/nm-hppah.h (CHILD_CAN_FOLLOW_VFORK_PRIOR_TO_EXEC): Don't
	define.
	* infrun.c (follow_vfork_when_exec): Remove.
	(follow_inferior_fork): Remove references to follow_vfork_when_exec.
	(follow_exec): Likewise.
	(handle_inferior_event): Likewise.
	(keep_going): Likewise.
@
text
@d3986 54
@


1.74
log
@2002-10-24  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (INIT_SAL): Delete macro.
	(init_sal): Export.
	* symtab.c (init_sal): New function.

	* ada-lang.c (ada_finish_decode_line_1): Change INIT_SAL macro
	to init_sal function call.
	(find_sal_from_funcs_and_line): Ditto.
	(all_sals_for_line): Ditto.
	* breakpoint.c (create_internal_breakpoint): Ditto.
	(create_fork_vfork_event_catchpoint): Ditto.
	(create_exec_event_catchpoint): Ditto.
	(parse_breakpoint_sals): Ditto.
	(watch_command_1): Ditto.
	(handle_gnu_4_16_catch_command): Ditto.
	(clear_command): Ditto.
	* hppa-tdep.c (child_enable_exception_callback): Ditto.
	* infcmd.c (run_stack_dummy): Ditto.
	* infrun.c (process_event_stop_test): Ditto.
	(check_sigtramp2): Ditto.
	(step_over_function): Ditto.
	* linespec.c (decode_line_2): Ditto.
	(decode_line_1): Ditto.
	* source.c (line_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
@
text
@a372 15
/* Some platforms don't allow us to do anything meaningful with a
   vforked child until it has exec'd.  Vforked processes on such
   platforms can only be followed after they've exec'd.

   When this is set to 0, a vfork can be immediately followed,
   and an exec can be followed merely as an exec.  When this is
   set to 1, a vfork event has been seen, but cannot be followed
   until the exec is seen.

   (In the latter case, inferior_ptid is still the parent of the
   vfork, and pending_follow.fork_event.child_pid is the child.  The
   appropriate process is followed, according to the setting of
   follow-fork-mode.) */
static int follow_vfork_when_exec;

d423 1
a423 3
      if (!has_vforked || !follow_vfork_when_exec)
	{
	  detach_breakpoints (child_pid);
d425 1
a425 1
	  SOLIB_REMOVE_INFERIOR_HOOK (child_pid);
a426 1
	}
d443 4
a446 9
         the child.  But only if we're forking, or if we follow vforks
         as soon as they happen.  (If we're following vforks only when
         the child has exec'd, then it's very wrong to try to write
         back the "shadow contents" of inserted breakpoints now -- they
         belong to the child's pre-exec'd a.out.) */
      if (!has_vforked || !follow_vfork_when_exec)
	{
	  detach_breakpoints (child_pid);
	}
d477 3
a479 1
      if (step_resume_breakpoint && (!has_vforked || !follow_vfork_when_exec))
d485 2
a486 5
      if (!has_vforked || !follow_vfork_when_exec)
	{
	  breakpoint_re_set ();
	  insert_breakpoints ();
	}
a583 17
  /* Did this exec() follow a vfork()?  If so, we must follow the
     vfork now too.  Do it before following the exec. */
  if (follow_vfork_when_exec &&
      (pending_follow.kind == TARGET_WAITKIND_VFORKED))
    {
      pending_follow.kind = TARGET_WAITKIND_SPURIOUS;
      follow_vfork (PIDGET (inferior_ptid),
		    pending_follow.fork_event.child_pid);
      follow_vfork_when_exec = 0;
      saved_pid = PIDGET (inferior_ptid);

      /* Did we follow the parent?  If so, we're done.  If we followed
         the child then we must also follow its exec(). */
      if (PIDGET (inferior_ptid) == pending_follow.fork_event.parent_pid)
	return;
    }

a1576 7
	  follow_vfork_when_exec = !target_can_follow_vfork_prior_to_exec ();
	  if (follow_vfork_when_exec)
	    {
	      target_resume (ecs->ptid, 0, TARGET_SIGNAL_0);
	      prepare_to_wait (ecs);
	      return;
	    }
a3068 10
  /* ??rehrauer: ttrace on HP-UX theoretically allows one to debug a
     vforked child between its creation and subsequent exit or call to
     exec().  However, I had big problems in this rather creaky exec
     engine, getting that to work.  The fundamental problem is that
     I'm trying to debug two processes via an engine that only
     understands a single process with possibly multiple threads.

     Hence, this spot is known to have problems when
     target_can_follow_vfork_prior_to_exec returns 1. */

@


1.73
log
@Convert #ifdef HAVE_NONSTEPPABLE_WATCHPOINT into C
@
text
@d2606 1
a2606 1
	  INIT_SAL (&sr_sal);
d2659 1
a2659 1
	    INIT_SAL (&sr_sal);
d2772 1
a2772 1
	      INIT_SAL (&xxx);	/* initialize to zeroes */
d2847 1
a2847 1
	  INIT_SAL (&sr_sal);	/* initialize to zeroes */
d2963 1
a2963 1
      INIT_SAL (&sr_sal);	/* initialize to zeroes */
d3019 1
a3019 1
      INIT_SAL (&sr_sal);	/* initialize to zeroes */
d3054 1
a3054 1
  INIT_SAL (&sr_sal);		/* initialize to zeros */
@


1.72
log
@2002-10-02  Andrew Cagney  <ac131313@@redhat.com>

	* infrun.c (resume): Convert #ifdef CANNOT_STEP_BREAKPOINT into C.
	* gdbarch.sh (CANNOT_STEP_BREAKPOINT): Add.
	* gdbarch.h, gdbarch.c: Re-generate.
@
text
@a233 7
#ifndef HAVE_NONSTEPPABLE_WATCHPOINT
#define HAVE_NONSTEPPABLE_WATCHPOINT 0
#else
#undef  HAVE_NONSTEPPABLE_WATCHPOINT
#define HAVE_NONSTEPPABLE_WATCHPOINT 1
#endif

@


1.72.2.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d234 7
d2613 1
a2613 1
	  init_sal (&sr_sal);
d2666 1
a2666 1
	    init_sal (&sr_sal);
d2779 1
a2779 1
	      init_sal (&xxx);	/* initialize to zeroes */
d2854 1
a2854 1
	  init_sal (&sr_sal);	/* initialize to zeroes */
d2970 1
a2970 1
      init_sal (&sr_sal);	/* initialize to zeroes */
d3026 1
a3026 1
      init_sal (&sr_sal);	/* initialize to zeroes */
d3061 1
a3061 1
  init_sal (&sr_sal);		/* initialize to zeros */
@


1.72.2.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d5 1
a5 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
a44 2
#include "observer.h"
#include "language.h"
d69 6
a74 1
static int follow_fork (void);
a84 2
static int prepare_to_proceed (void);

d114 15
d172 4
d234 7
d314 1
a314 1
enum stop_kind stop_soon;
d363 1
d365 2
d373 15
d389 1
d395 5
d408 3
a410 2
static int
follow_fork (void)
d412 4
a416 1
  int follow_child = (follow_mode == follow_fork_mode_child);
d426 143
a568 1
  return target_follow_fork (follow_child);
d571 2
a572 2
void
follow_inferior_reset_breakpoints (void)
d574 2
a575 10
  /* Was there a step_resume breakpoint?  (There was if the user
     did a "next" at the fork() call.)  If so, explicitly reset its
     thread number.

     step_resumes are a form of bp that are made to be per-thread.
     Since we created the step_resume bp when the parent process
     was being debugged, and now are switching to the child process,
     from the breakpoint package's viewpoint, that's a switch of
     "threads".  We must update the bp's notion of which thread
     it is for, or it'll be ignored when it triggers.  */
a576 2
  if (step_resume_breakpoint)
    breakpoint_re_set_thread (step_resume_breakpoint);
d578 7
a584 4
  /* Reinsert all breakpoints in the child.  The user may have set
     breakpoints after catching the fork, in which case those
     were never set in the child, but only in the parent.  This makes
     sure the inserted breakpoints match the breakpoint list.  */
d586 9
a594 2
  breakpoint_re_set ();
  insert_breakpoints ();
d608 17
d708 1
d733 1
a733 1
     callbacks.  Unfortunately, for ``show'' commands cloned from
d800 1
a800 1
     now to be followed, then do so.  */
d803 1
a803 2
    case TARGET_WAITKIND_FORKED:
    case TARGET_WAITKIND_VFORKED:
d805 20
a824 2
      if (follow_fork ())
	should_resume = 0;
d827 4
a830 1
    case TARGET_WAITKIND_EXECD:
a831 1
      pending_follow.kind = TARGET_WAITKIND_SPURIOUS;
d890 1
a890 1
  step_frame_id = null_frame_id;
d893 1
a893 1
  stop_soon = NO_STOP_QUIETLY;
a900 55
/* This should be suitable for any targets that support threads. */

static int
prepare_to_proceed (void)
{
  ptid_t wait_ptid;
  struct target_waitstatus wait_status;

  /* Get the last target status returned by target_wait().  */
  get_last_target_status (&wait_ptid, &wait_status);

  /* Make sure we were stopped either at a breakpoint, or because
     of a Ctrl-C.  */
  if (wait_status.kind != TARGET_WAITKIND_STOPPED
      || (wait_status.value.sig != TARGET_SIGNAL_TRAP &&
          wait_status.value.sig != TARGET_SIGNAL_INT))
    {
      return 0;
    }

  if (!ptid_equal (wait_ptid, minus_one_ptid)
      && !ptid_equal (inferior_ptid, wait_ptid))
    {
      /* Switched over from WAIT_PID.  */
      CORE_ADDR wait_pc = read_pc_pid (wait_ptid);

      if (wait_pc != read_pc ())
	{
	  /* Switch back to WAIT_PID thread.  */
	  inferior_ptid = wait_ptid;

	  /* FIXME: This stuff came from switch_to_thread() in
	     thread.c (which should probably be a public function).  */
	  flush_cached_frames ();
	  registers_changed ();
	  stop_pc = wait_pc;
	  select_frame (get_current_frame ());
	}

	/* We return 1 to indicate that there is a breakpoint here,
	   so we need to step over it before continuing to avoid
	   hitting it straight away. */
	if (breakpoint_here_p (wait_pc))
	   return 1;
    }

  return 0;
  
}

/* Record the pc of the program the last time it stopped.  This is
   just used internally by wait_for_inferior, but need to be preserved
   over calls to it and cleared when the inferior is started.  */
static CORE_ADDR prev_pc;

d950 1
d959 1
a959 1
     prepare_to_proceed checks the current thread against the thread
d962 6
a967 2
  if (prepare_to_proceed () && breakpoint_here_p (read_pc ()))
    oneproc = 1;
a1005 24
  /* Refresh prev_pc value just prior to resuming.  This used to be
     done in stop_stepping, however, setting prev_pc there did not handle
     scenarios such as inferior function calls or returning from
     a function via the return command.  In those cases, the prev_pc
     value was not set properly for subsequent commands.  The prev_pc value 
     is used to initialize the starting line number in the ecs.  With an 
     invalid value, the gdb next command ends up stopping at the position
     represented by the next line table entry past our start position.
     On platforms that generate one line table entry per line, this
     is not a problem.  However, on the ia64, the compiler generates
     extraneous line table entries that do not increase the line number.
     When we issue the gdb next command on the ia64 after an inferior call
     or a return command, we often end up a few instructions forward, still 
     within the original line we started.

     An attempt was made to have init_execution_control_state () refresh
     the prev_pc value before calculating the line number.  This approach
     did not work because on platforms that use ptrace, the pc register
     cannot be read unless the inferior is stopped.  At that point, we
     are not guaranteed the inferior is stopped and so the read_pc ()
     call can fail.  Setting the prev_pc value here ensures the value is 
     updated correctly when the inferior is stopped.  */  
  prev_pc = read_pc ();

d1019 8
d1036 1
a1036 1
  stop_soon = STOP_QUIETLY;
d1064 2
d1078 3
d1356 1
d1359 1
a1359 1
			 step_range_end, &step_frame_id,
d1368 1
d1371 1
a1371 1
			 &step_range_end, &step_frame_id,
a1380 33
/* Wrapper for PC_IN_SIGTRAMP that takes care of the need to find the
   function's name.

   In a classic example of "left hand VS right hand", "infrun.c" was
   trying to improve GDB's performance by caching the result of calls
   to calls to find_pc_partial_funtion, while at the same time
   find_pc_partial_function was also trying to ramp up performance by
   caching its most recent return value.  The below makes the the
   function find_pc_partial_function solely responsibile for
   performance issues (the local cache that relied on a global
   variable - arrrggg - deleted).

   Using the testsuite and gcov, it was found that dropping the local
   "infrun.c" cache and instead relying on find_pc_partial_function
   increased the number of calls to 12000 (from 10000), but the number
   of times find_pc_partial_function's cache missed (this is what
   matters) was only increased by only 4 (to 3569).  (A quick back of
   envelope caculation suggests that the extra 2000 function calls
   @@1000 extra instructions per call make the 1 MIP VAX testsuite run
   take two extra seconds, oops :-)

   Long term, this function can be eliminated, replaced by the code:
   get_frame_type(current_frame()) == SIGTRAMP_FRAME (for new
   architectures this is very cheap).  */

static int
pc_in_sigtramp (CORE_ADDR pc)
{
  char *name;
  find_pc_partial_function (pc, &name, NULL, NULL);
  return PC_IN_SIGTRAMP (pc, name);
}

d1389 1
a1389 6
  CORE_ADDR real_stop_pc;
  /* NOTE: cagney/2003-03-28: If you're looking at this code and
     thinking that the variable stepped_after_stopped_by_watchpoint
     isn't used, then you're wrong!  The macro STOPPED_BY_WATCHPOINT,
     defined in the file "config/pa/nm-hppah.h", accesses the variable
     indirectly.  Mutter something rude about the HP merge.  */
d1402 1
a1402 9
      /* See comments where a TARGET_WAITKIND_SYSCALL_RETURN event
         is serviced in this loop, below. */
      if (ecs->enable_hw_watchpoints_after_wait)
	{
	  TARGET_ENABLE_HW_WATCHPOINTS (PIDGET (inferior_ptid));
	  ecs->enable_hw_watchpoints_after_wait = 0;
	}
      stepped_after_stopped_by_watchpoint = 0;
      break;
a1415 1
      stepped_after_stopped_by_watchpoint = 0;
a1425 3

    default:
      internal_error (__FILE__, __LINE__, "bad switch");
d1478 1
a1478 1
      if (stop_soon == NO_STOP_QUIETLY)
d1490 1
a1490 16
	  /* NOTE: cagney/2003-11-25: Make certain that the target
             stack's section table is kept up-to-date.  Architectures,
             (e.g., PPC64), use the section table to perform
             operations such as address => section name and hence
             require the table to contain all sections (including
             those found in shared libraries).  */
	  /* NOTE: cagney/2003-11-25: Pass current_target and not
             exec_ops to SOLIB_ADD.  This is because current GDB is
             only tooled to propagate section_table changes out from
             the "current_target" (see target_resize_to_sections), and
             not up from the exec stratum.  This, of course, isn't
             right.  "infrun.c" should only interact with the
             exec/process stratum, instead relying on the target stack
             to propagate relevant changes (stop, section table
             changed, ...) up to other layers.  */
	  SOLIB_ADD (NULL, 0, &current_target, auto_solib_add);
a1542 1
    case TARGET_WAITKIND_VFORKED:
d1546 18
a1563 2
      pending_follow.fork_event.parent_pid = PIDGET (ecs->ptid);
      pending_follow.fork_event.child_pid = ecs->ws.value.related_pid;
d1565 17
a1581 1
      stop_pc = read_pc ();
d1583 10
a1592 5
      /* Assume that catchpoints are not really software breakpoints.  If
	 some future target implements them using software breakpoints then
	 that target is responsible for fudging DECR_PC_AFTER_BREAK.  Thus
	 we pass 1 for the NOT_A_SW_BREAKPOINT argument, so that
	 bpstat_stop_status will not decrement the PC.  */
d1594 32
a1625 1
      stop_bpstat = bpstat_stop_status (&stop_pc, 1);
d1627 12
a1639 8

      /* If no catchpoint triggered for this, then keep going.  */
      if (ecs->random_signal)
	{
	  stop_signal = TARGET_SIGNAL_0;
	  keep_going (ecs);
	  return;
	}
a1644 3
      /* NOTE drow/2002-12-05: This code should be pushed down into the
	 target_wait function.  Until then following vfork on HP/UX 10.20
	 is probably broken by this.  Of course, it's broken anyway.  */
d1666 30
d1704 11
a1714 9

      /* Assume that catchpoints are not really software breakpoints.  If
	 some future target implements them using software breakpoints then
	 that target is responsible for fudging DECR_PC_AFTER_BREAK.  Thus
	 we pass 1 for the NOT_A_SW_BREAKPOINT argument, so that
	 bpstat_stop_status will not decrement the PC.  */

      stop_bpstat = bpstat_stop_status (&stop_pc, 1);

a1716 8

      /* If no catchpoint triggered for this, then keep going.  */
      if (ecs->random_signal)
	{
	  stop_signal = TARGET_SIGNAL_0;
	  keep_going (ecs);
	  return;
	}
d1778 5
a1782 7
         done what needs to be done, if anything.
	 
	 One of the possible circumstances for this is when the
	 inferior produces output for the console. The inferior has
	 not stopped, and we are ignoring the event.  Another possible
	 circumstance is any event which the lower level knows will be
	 reported multiple times without an intervening resume.  */
d1784 1
a1784 1
      prepare_to_wait (ecs);
d2067 1
a2067 3
	   || stop_signal == TARGET_SIGNAL_EMT))
      || stop_soon == STOP_QUIETLY
      || stop_soon == STOP_QUIETLY_NO_SIGSTOP)
d2075 1
a2075 14

      /* This is originated from start_remote(), start_inferior() and
         shared libraries hook functions.  */
      if (stop_soon == STOP_QUIETLY)
	{
	  stop_stepping (ecs);
	  return;
	}

      /* This originates from attach_command().  We need to overwrite
         the stop_signal here, because some kernels don't ignore a
         SIGSTOP in a subsequent ptrace(PTRACE_SONT,SOGSTOP) call.
         See more comments in inferior.h.  */
      if (stop_soon == STOP_QUIETLY_NO_SIGSTOP)
a2077 2
	  if (stop_signal == TARGET_SIGNAL_STOP)
	    stop_signal = TARGET_SIGNAL_0;
a2121 16
      /* NOTE: cagney/2003-03-29: These two checks for a random signal
	 at one stage in the past included checks for an inferior
	 function call's call dummy's return breakpoint.  The original
	 comment, that went with the test, read:

	 ``End of a stack dummy.  Some systems (e.g. Sony news) give
	 another signal besides SIGTRAP, so check here as well as
	 above.''

         If someone ever tries to get get call dummys on a
         non-executable stack to work (where the target would stop
         with something like a SIGSEG), then those tests might need to
         be re-instated.  Given, however, that the tests were only
         enabled when momentary breakpoints were not being used, I
         suspect that it won't be the case.  */

d2126 3
d2130 1
d2133 9
a2141 1
	  ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
d2153 13
d2167 2
d2170 31
d2318 1
a2318 1
	  set_longjmp_resume_breakpoint (jmp_buf_pc, null_frame_id);
d2330 2
a2331 2
	    && (frame_id_inner (get_frame_id (get_current_frame ()),
				step_frame_id)))
d2428 1
a2428 16
	  /* NOTE: cagney/2003-11-25: Make certain that the target
             stack's section table is kept up-to-date.  Architectures,
             (e.g., PPC64), use the section table to perform
             operations such as address => section name and hence
             require the table to contain all sections (including
             those found in shared libraries).  */
	  /* NOTE: cagney/2003-11-25: Pass current_target and not
             exec_ops to SOLIB_ADD.  This is because current GDB is
             only tooled to propagate section_table changes out from
             the "current_target" (see target_resize_to_sections), and
             not up from the exec stratum.  This, of course, isn't
             right.  "infrun.c" should only interact with the
             exec/process stratum, instead relying on the target stack
             to propagate relevant changes (stop, section table
             changed, ...) up to other layers.  */
	  SOLIB_ADD (NULL, 0, &current_target, auto_solib_add);
d2529 25
d2599 1
a2599 2
      CORE_ADDR pc_after_resolver =
	gdbarch_skip_solib_resolver (current_gdbarch, stop_pc);
d2611 1
a2611 1
	    set_momentary_breakpoint (sr_sal, null_frame_id, bp_step_resume);
d2626 2
a2627 2
  if (pc_in_sigtramp (stop_pc)
      && !pc_in_sigtramp (prev_pc)
d2642 1
a2642 1
	struct frame_id current_frame = get_frame_id (get_current_frame ());
d2644 1
a2644 1
	if (frame_id_inner (current_frame, step_frame_id))
d2664 2
a2665 1
	       step_frame_id; I don't think anyone thought to try it.  */
d2668 1
a2668 1
	      set_momentary_breakpoint (sr_sal, null_frame_id, bp_step_resume);
d2710 3
a2712 3
  if (((stop_pc == ecs->stop_func_start	/* Quick test */
	|| in_prologue (stop_pc, ecs->stop_func_start))
       && !IN_SOLIB_RETURN_TRAMPOLINE (stop_pc, ecs->stop_func_name))
d2738 2
a2739 3
	  if (pc_in_sigtramp (stop_pc)
	      && frame_id_inner (step_frame_id,
				 frame_id_build (read_sp (), 0)))
d2743 7
a2749 6
	       trampoline isn't such a bad idea.  In order to do that,
	       we have to ignore the value in step_frame_id, since
	       that doesn't represent the frame that'll reach when we
	       return from the signal trampoline.  Otherwise we'll
	       probably continue to the end of the program.  */
	    step_frame_id = null_frame_id;
d2761 22
a2782 5
      real_stop_pc = skip_language_trampoline (stop_pc);
      if (real_stop_pc == 0)
	real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
      if (real_stop_pc != 0)
	ecs->stop_func_start = real_stop_pc;
d2836 2
d2839 1
a2839 1
      real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
d2842 1
a2842 1
      if (real_stop_pc)
d2848 1
a2848 1
	  sr_sal.pc = real_stop_pc;
d2855 1
a2855 1
	    set_momentary_breakpoint (sr_sal, null_frame_id, bp_step_resume);
d2913 1
a2913 1
  step_frame_id = get_frame_id (get_current_frame ());
d2917 3
a2919 19
  /* In the case where we just stepped out of a function into the
     middle of a line of the caller, continue stepping, but
     step_frame_id must be modified to current frame */
#if 0
  /* NOTE: cagney/2003-10-16: I think this frame ID inner test is too
     generous.  It will trigger on things like a step into a frameless
     stackless leaf function.  I think the logic should instead look
     at the unwound frame ID has that should give a more robust
     indication of what happened.  */
     if (step-ID == current-ID)
       still stepping in same function;
     else if (step-ID == unwind (current-ID))
       stepped into a function;
     else
       stepped out of a function;
     /* Of course this assumes that the frame ID unwind code is robust
        and we're willing to introduce frame unwind logic into this
        function.  Fortunately, those days are nearly upon us.  */
#endif
d2921 3
a2923 3
    struct frame_id current_frame = get_frame_id (get_current_frame ());
    if (!(frame_id_inner (current_frame, step_frame_id)))
      step_frame_id = current_frame;
d2946 2
a2947 2
      && pc_in_sigtramp (stop_pc)
      && !pc_in_sigtramp (prev_pc)
d2969 1
a2969 1
	set_momentary_breakpoint (sr_sal, null_frame_id, bp_through_sigtramp);
d2998 4
d3006 1
d3027 1
a3027 1
	set_momentary_breakpoint (sr_sal, null_frame_id, bp_step_resume);
d3046 1
a3046 1
   caller's frame (step_frame_id, which is set by the "next" or
d3055 1
a3055 38

  /* NOTE: cagney/2003-04-06:

     At this point the equality get_frame_pc() == get_frame_func()
     should hold.  This may make it possible for this code to tell the
     frame where it's function is, instead of the reverse.  This would
     avoid the need to search for the frame's function, which can get
     very messy when there is no debug info available (look at the
     heuristic find pc start code found in targets like the MIPS).  */

  /* NOTE: cagney/2003-04-06:

     The intent of DEPRECATED_SAVED_PC_AFTER_CALL was to:

     - provide a very light weight equivalent to frame_unwind_pc()
     (nee FRAME_SAVED_PC) that avoids the prologue analyzer

     - avoid handling the case where the PC hasn't been saved in the
     prologue analyzer

     Unfortunately, not five lines further down, is a call to
     get_frame_id() and that is guarenteed to trigger the prologue
     analyzer.
     
     The `correct fix' is for the prologe analyzer to handle the case
     where the prologue is incomplete (PC in prologue) and,
     consequently, the return pc has not yet been saved.  It should be
     noted that the prologue analyzer needs to handle this case
     anyway: frameless leaf functions that don't save the return PC;
     single stepping through a prologue.

     The d10v handles all this by bailing out of the prologue analsis
     when it reaches the current instruction.  */

  if (DEPRECATED_SAVED_PC_AFTER_CALL_P ())
    sr_sal.pc = ADDR_BITS_REMOVE (DEPRECATED_SAVED_PC_AFTER_CALL (get_current_frame ()));
  else
    sr_sal.pc = ADDR_BITS_REMOVE (frame_pc_unwind (get_current_frame ()));
d3060 1
a3060 2
    set_momentary_breakpoint (sr_sal, get_frame_id (get_current_frame ()),
			      bp_step_resume);
d3062 2
a3063 3
  if (frame_id_p (step_frame_id)
      && !IN_SOLIB_DYNSYM_RESOLVE_CODE (sr_sal.pc))
    step_resume_breakpoint->frame_id = step_frame_id;
d3072 34
d3117 10
d3129 6
a3347 5
  struct target_waitstatus last;
  ptid_t last_ptid;

  get_last_target_status (&last_ptid, &last);

d3352 2
a3353 3
     There's no point in saying anything if the inferior has exited.
     Note that SIGNALLED here means "exited with a signal", not
     "received a signal".  */
d3355 1
a3355 3
      && target_has_execution
      && last.kind != TARGET_WAITKIND_SIGNALLED
      && last.kind != TARGET_WAITKIND_EXITED)
d3366 2
a3367 6
  if (target_has_execution)
    /* FIXME: cagney/2002-12-06: Has the PC changed?  Thanks to
       DECR_PC_AFTER_BREAK, the program counter can change.  Ask the
       frame code to check for this and sort out any resultant mess.
       DECR_PC_AFTER_BREAK needs to just go away.  */
    deprecated_update_frame_pc_hack (get_current_frame (), read_pc ());
d3427 1
a3427 1
      if (stop_print_frame && deprecated_selected_frame)
a3436 3
	      /* FIXME: cagney/2002-12-01: Given that a frame ID does
		 (or should) carry around the function and does (or
		 should) use that when doing a frame comparison.  */
d3438 1
a3438 2
		  && frame_id_eq (step_frame_id,
				  get_frame_id (get_current_frame ()))
d3471 1
a3471 1
	    print_stack_frame (deprecated_selected_frame, -1, source_flag);
d3487 4
a3490 4
      /* Pop the empty frame that contains the stack dummy.  POP_FRAME
         ends with a setting of the current frame, so we can use that
         next. */
      frame_pop (get_current_frame ());
a3499 1
  observer_notify_normal_stop ();
d3876 1
a3876 1
  struct frame_id step_frame_id;
d3880 1
a3880 1
  int stop_soon;
d3900 1
a3900 1
  int size = DEPRECATED_REGISTER_RAW_SIZE (regno);
d3923 1
a3923 1
  inf_status->step_frame_id = step_frame_id;
d3926 1
a3926 1
  inf_status->stop_soon = stop_soon;
d3941 1
a3941 1
  inf_status->selected_frame_id = get_frame_id (deprecated_selected_frame);
d3953 2
a3954 2
  /* If inf_status->selected_frame_id is NULL, there was no previously
     selected frame.  */
d3977 1
a3977 1
  step_frame_id = inf_status->step_frame_id;
d3980 1
a3980 1
  stop_soon = inf_status->stop_soon;
a4043 54
int
inferior_has_forked (int pid, int *child_pid)
{
  struct target_waitstatus last;
  ptid_t last_ptid;

  get_last_target_status (&last_ptid, &last);

  if (last.kind != TARGET_WAITKIND_FORKED)
    return 0;

  if (ptid_get_pid (last_ptid) != pid)
    return 0;

  *child_pid = last.value.related_pid;
  return 1;
}

int
inferior_has_vforked (int pid, int *child_pid)
{
  struct target_waitstatus last;
  ptid_t last_ptid;

  get_last_target_status (&last_ptid, &last);

  if (last.kind != TARGET_WAITKIND_VFORKED)
    return 0;

  if (ptid_get_pid (last_ptid) != pid)
    return 0;

  *child_pid = last.value.related_pid;
  return 1;
}

int
inferior_has_execd (int pid, char **execd_pathname)
{
  struct target_waitstatus last;
  ptid_t last_ptid;

  get_last_target_status (&last_ptid, &last);

  if (last.kind != TARGET_WAITKIND_EXECD)
    return 0;

  if (ptid_get_pid (last_ptid) != pid)
    return 0;

  *execd_pathname = xstrdup (last.value.execd_pathname);
  return 1;
}

d4138 2
a4139 2
  int i;
  int numsigs;
@


1.72.2.3
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@a989 1
static void handle_step_into_function (struct execution_control_state *ecs);
a1238 89
/* Handle the inferior event in the cases when we just stepped
   into a function.  */

static void
handle_step_into_function (struct execution_control_state *ecs)
{
  CORE_ADDR real_stop_pc;

  if ((step_over_calls == STEP_OVER_NONE)
      || ((step_range_end == 1)
          && in_prologue (prev_pc, ecs->stop_func_start)))
    {
      /* I presume that step_over_calls is only 0 when we're
         supposed to be stepping at the assembly language level
         ("stepi").  Just stop.  */
      /* Also, maybe we just did a "nexti" inside a prolog,
         so we thought it was a subroutine call but it was not.
         Stop as well.  FENN */
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }

  if (step_over_calls == STEP_OVER_ALL || IGNORE_HELPER_CALL (stop_pc))
    {
      /* We're doing a "next".  */

      if (pc_in_sigtramp (stop_pc)
          && frame_id_inner (step_frame_id,
                             frame_id_build (read_sp (), 0)))
        /* We stepped out of a signal handler, and into its
           calling trampoline.  This is misdetected as a
           subroutine call, but stepping over the signal
           trampoline isn't such a bad idea.  In order to do that,
           we have to ignore the value in step_frame_id, since
           that doesn't represent the frame that'll reach when we
           return from the signal trampoline.  Otherwise we'll
           probably continue to the end of the program.  */
        step_frame_id = null_frame_id;

      step_over_function (ecs);
      keep_going (ecs);
      return;
    }

  /* If we are in a function call trampoline (a stub between
     the calling routine and the real function), locate the real
     function.  That's what tells us (a) whether we want to step
     into it at all, and (b) what prologue we want to run to
     the end of, if we do step into it.  */
  real_stop_pc = skip_language_trampoline (stop_pc);
  if (real_stop_pc == 0)
    real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
  if (real_stop_pc != 0)
    ecs->stop_func_start = real_stop_pc;

  /* If we have line number information for the function we
     are thinking of stepping into, step into it.

     If there are several symtabs at that PC (e.g. with include
     files), just want to know whether *any* of them have line
     numbers.  find_pc_line handles this.  */
  {
    struct symtab_and_line tmp_sal;

    tmp_sal = find_pc_line (ecs->stop_func_start, 0);
    if (tmp_sal.line != 0)
      {
        step_into_function (ecs);
        return;
      }
  }

  /* If we have no line number and the step-stop-if-no-debug
     is set, we stop the step so that the user has a chance to
     switch in assembly mode.  */
  if (step_over_calls == STEP_OVER_UNDEBUGGABLE && step_stop_if_no_debug)
    {
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }

  step_over_function (ecs);
  keep_going (ecs);
  return;
}
d1247 1
d2482 80
a2561 1
      handle_step_into_function (ecs);
d2563 1
d2585 1
a2585 1
      CORE_ADDR real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
@


1.72.2.4
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d5 2
a6 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free
   Software Foundation, Inc.
d64 3
d343 1
d348 1
d360 10
a369 1
  int follow_child = (follow_fork_mode_string == follow_fork_mode_child);
a1329 73
static void
adjust_pc_after_break (struct execution_control_state *ecs)
{
  CORE_ADDR stop_pc;

  /* If this target does not decrement the PC after breakpoints, then
     we have nothing to do.  */
  if (DECR_PC_AFTER_BREAK == 0)
    return;

  /* If we've hit a breakpoint, we'll normally be stopped with SIGTRAP.  If
     we aren't, just return.

     We assume that waitkinds other than TARGET_WAITKIND_STOPPED are not
     affected by DECR_PC_AFTER_BREAK.  Other waitkinds which are implemented
     by software breakpoints should be handled through the normal breakpoint
     layer.
     
     NOTE drow/2004-01-31: On some targets, breakpoints may generate
     different signals (SIGILL or SIGEMT for instance), but it is less
     clear where the PC is pointing afterwards.  It may not match
     DECR_PC_AFTER_BREAK.  I don't know any specific target that generates
     these signals at breakpoints (the code has been in GDB since at least
     1992) so I can not guess how to handle them here.
     
     In earlier versions of GDB, a target with HAVE_NONSTEPPABLE_WATCHPOINTS
     would have the PC after hitting a watchpoint affected by
     DECR_PC_AFTER_BREAK.  I haven't found any target with both of these set
     in GDB history, and it seems unlikely to be correct, so
     HAVE_NONSTEPPABLE_WATCHPOINTS is not checked here.  */

  if (ecs->ws.kind != TARGET_WAITKIND_STOPPED)
    return;

  if (ecs->ws.value.sig != TARGET_SIGNAL_TRAP)
    return;

  /* Find the location where (if we've hit a breakpoint) the breakpoint would
     be.  */
  stop_pc = read_pc_pid (ecs->ptid) - DECR_PC_AFTER_BREAK;

  /* If we're software-single-stepping, then assume this is a breakpoint.
     NOTE drow/2004-01-17: This doesn't check that the PC matches, or that
     we're even in the right thread.  The software-single-step code needs
     some modernization.

     If we're not software-single-stepping, then we first check that there
     is an enabled software breakpoint at this address.  If there is, and
     we weren't using hardware-single-step, then we've hit the breakpoint.

     If we were using hardware-single-step, we check prev_pc; if we just
     stepped over an inserted software breakpoint, then we should decrement
     the PC and eventually report hitting the breakpoint.  The prev_pc check
     prevents us from decrementing the PC if we just stepped over a jump
     instruction and landed on the instruction after a breakpoint.

     The last bit checks that we didn't hit a breakpoint in a signal handler
     without an intervening stop in sigtramp, which is detected by a new
     stack pointer value below any usual function calling stack adjustments.

     NOTE drow/2004-01-17: I'm not sure that this is necessary.  The check
     predates checking for software single step at the same time.  Also,
     if we've moved into a signal handler we should have seen the
     signal.  */

  if ((SOFTWARE_SINGLE_STEP_P () && singlestep_breakpoints_inserted_p)
      || (software_breakpoint_inserted_here_p (stop_pc)
	  && !(currently_stepping (ecs)
	       && prev_pc != stop_pc
	       && !(step_range_end && INNER_THAN (read_sp (), (step_sp - 16))))))
    write_pc_pid (stop_pc, ecs->ptid);
}

a1348 2
  adjust_pc_after_break (ecs);

d1531 7
a1537 1
      stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);
d1586 7
a1592 1
      stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);
d1702 2
a1703 1
      if (breakpoints_inserted && breakpoint_here_p (stop_pc))
d1706 2
a1707 1
	  if (!breakpoint_thread_match (stop_pc, ecs->ptid))
d1713 2
d1727 1
a1727 1
		  write_pc_pid (stop_pc + 4, ecs->ptid);
d1761 11
d1903 3
d1947 5
a1951 9
     that have to do with the program's own actions.  Note that
     breakpoint insns may cause SIGTRAP or SIGILL or SIGEMT, depending
     on the operating system version.  Here we detect when a SIGILL or
     SIGEMT is really a breakpoint and change it to SIGTRAP.  We do
     something similar for SIGSEGV, since a SIGSEGV will be generated
     when we're trying to execute a breakpoint instruction on a
     non-executable stack.  This happens for call dummy breakpoints
     for architectures like SPARC that place call dummies on the
     stack.  */
a1955 1
	   || stop_signal == TARGET_SIGNAL_SEGV
a1999 1
	  stop_bpstat = bpstat_stop_status (stop_pc, ecs->ptid);
d2001 22
d2039 2
a2040 2
         with something like a SIGSEGV), then those tests might need
         to be re-instated.  Given, however, that the tests were only
d2042 1
a2042 5
         suspect that it won't be the case.

	 NOTE: kettenis/2004-02-05: Indeed such checks don't seem to
	 be necessary for call dummies on a non-executable stack on
	 SPARC.  */
d2318 1
a2318 1
	  if (stop_on_solib_events || stop_stack_dummy)
a2773 23
  /* Architectures which require breakpoint adjustment might not be able
     to place a breakpoint at the computed address.  If so, the test
     ``ecs->stop_func_start == stop_pc'' will never succeed.  Adjust
     ecs->stop_func_start to an address at which a breakpoint may be
     legitimately placed.
     
     Note:  kevinb/2004-01-19:  On FR-V, if this adjustment is not
     made, GDB will enter an infinite loop when stepping through
     optimized code consisting of VLIW instructions which contain
     subinstructions corresponding to different source lines.  On
     FR-V, it's not permitted to place a breakpoint on any but the
     first subinstruction of a VLIW instruction.  When a breakpoint is
     set, GDB will adjust the breakpoint address to the beginning of
     the VLIW instruction.  Thus, we need to make the corresponding
     adjustment here when computing the stop address.  */
     
  if (gdbarch_adjust_breakpoint_address_p (current_gdbarch))
    {
      ecs->stop_func_start
	= gdbarch_adjust_breakpoint_address (current_gdbarch,
	                                     ecs->stop_func_start);
    }

d2957 11
a3125 1
  /* NOTE drow/2004-01-17: Is this still necessary?  */
d4078 18
d4101 2
a4102 1
The unfollowed process will continue to run.\n\
@


1.71
log
@2002-09-18  Andrew Cagney  <ac131313@@redhat.com>

	* infrun.c (signal_stop_update): Convert definition to ISO C.
	(signal_print_update): Ditto.
	(signal_pass_update): Ditto.
	* inflow.c (terminal_save_ours): Ditto.
@
text
@d873 8
a880 7
#ifdef CANNOT_STEP_BREAKPOINT
      /* Most targets can step a breakpoint instruction, thus executing it
         normally.  But if this one cannot, just continue and we will hit
         it anyway.  */
      if (step && breakpoints_inserted && breakpoint_here_p (read_pc ()))
	step = 0;
#endif
@


1.71.2.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d234 7
d873 7
a879 8
      if (CANNOT_STEP_BREAKPOINT)
	{
	  /* Most targets can step a breakpoint instruction, thus
	     executing it normally.  But if this one cannot, just
	     continue and we will hit it anyway.  */
	  if (step && breakpoints_inserted && breakpoint_here_p (read_pc ()))
	    step = 0;
	}
@


1.71.2.2
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d2606 1
a2606 1
	  init_sal (&sr_sal);
d2659 1
a2659 1
	    init_sal (&sr_sal);
d2772 1
a2772 1
	      init_sal (&xxx);	/* initialize to zeroes */
d2847 1
a2847 1
	  init_sal (&sr_sal);	/* initialize to zeroes */
d2963 1
a2963 1
      init_sal (&sr_sal);	/* initialize to zeroes */
d3019 1
a3019 1
      init_sal (&sr_sal);	/* initialize to zeroes */
d3054 1
a3054 1
  init_sal (&sr_sal);		/* initialize to zeros */
@


1.71.2.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d69 6
a74 1
static int follow_fork ();
d363 1
d365 2
d373 15
d389 1
d395 5
d408 3
a410 2
static int
follow_fork ()
d412 4
a416 1
  int follow_child = (follow_mode == follow_fork_mode_child);
d426 143
a568 1
  return target_follow_fork (follow_child);
d571 2
a572 2
void
follow_inferior_reset_breakpoints (void)
d574 2
a575 10
  /* Was there a step_resume breakpoint?  (There was if the user
     did a "next" at the fork() call.)  If so, explicitly reset its
     thread number.

     step_resumes are a form of bp that are made to be per-thread.
     Since we created the step_resume bp when the parent process
     was being debugged, and now are switching to the child process,
     from the breakpoint package's viewpoint, that's a switch of
     "threads".  We must update the bp's notion of which thread
     it is for, or it'll be ignored when it triggers.  */
a576 2
  if (step_resume_breakpoint)
    breakpoint_re_set_thread (step_resume_breakpoint);
d578 2
a579 4
  /* Reinsert all breakpoints in the child.  The user may have set
     breakpoints after catching the fork, in which case those
     were never set in the child, but only in the parent.  This makes
     sure the inserted breakpoints match the breakpoint list.  */
d581 14
a594 2
  breakpoint_re_set ();
  insert_breakpoints ();
d608 17
d800 1
a800 1
     now to be followed, then do so.  */
d803 1
a803 2
    case TARGET_WAITKIND_FORKED:
    case TARGET_WAITKIND_VFORKED:
d805 20
a824 2
      if (follow_fork ())
	should_resume = 0;
d827 4
a830 1
    case TARGET_WAITKIND_EXECD:
a831 1
      pending_follow.kind = TARGET_WAITKIND_SPURIOUS;
d890 1
a890 1
  step_frame_id = null_frame_id;
d1078 3
d1359 1
a1359 1
			 step_range_end, &step_frame_id,
d1371 1
a1371 1
			 &step_range_end, &step_frame_id,
a1542 1
    case TARGET_WAITKIND_VFORKED:
d1546 18
a1563 2
      pending_follow.fork_event.parent_pid = PIDGET (ecs->ptid);
      pending_follow.fork_event.child_pid = ecs->ws.value.related_pid;
d1565 17
a1581 1
      stop_pc = read_pc ();
d1583 10
a1592 5
      /* Assume that catchpoints are not really software breakpoints.  If
	 some future target implements them using software breakpoints then
	 that target is responsible for fudging DECR_PC_AFTER_BREAK.  Thus
	 we pass 1 for the NOT_A_SW_BREAKPOINT argument, so that
	 bpstat_stop_status will not decrement the PC.  */
d1594 32
a1625 1
      stop_bpstat = bpstat_stop_status (&stop_pc, 1);
d1627 12
a1639 8

      /* If no catchpoint triggered for this, then keep going.  */
      if (ecs->random_signal)
	{
	  stop_signal = TARGET_SIGNAL_0;
	  keep_going (ecs);
	  return;
	}
a1644 3
      /* NOTE drow/2002-12-05: This code should be pushed down into the
	 target_wait function.  Until then following vfork on HP/UX 10.20
	 is probably broken by this.  Of course, it's broken anyway.  */
d1666 30
d1704 11
a1714 9

      /* Assume that catchpoints are not really software breakpoints.  If
	 some future target implements them using software breakpoints then
	 that target is responsible for fudging DECR_PC_AFTER_BREAK.  Thus
	 we pass 1 for the NOT_A_SW_BREAKPOINT argument, so that
	 bpstat_stop_status will not decrement the PC.  */

      stop_bpstat = bpstat_stop_status (&stop_pc, 1);

a1716 8

      /* If no catchpoint triggered for this, then keep going.  */
      if (ecs->random_signal)
	{
	  stop_signal = TARGET_SIGNAL_0;
	  keep_going (ecs);
	  return;
	}
d1778 5
a1782 7
         done what needs to be done, if anything.
	 
	 One of the possible circumstances for this is when the
	 inferior produces output for the console. The inferior has
	 not stopped, and we are ignoring the event.  Another possible
	 circumstance is any event which the lower level knows will be
	 reported multiple times without an intervening resume.  */
d1784 1
a1784 1
      prepare_to_wait (ecs);
d2127 2
a2128 2
		  && DEPRECATED_PC_IN_CALL_DUMMY (stop_pc, read_sp (),
				       get_frame_base (get_current_frame ())))
d2138 2
a2139 2
				     && DEPRECATED_PC_IN_CALL_DUMMY (stop_pc, read_sp (),
							  get_frame_base
d2153 13
d2167 2
d2170 31
d2318 1
a2318 1
	  set_longjmp_resume_breakpoint (jmp_buf_pc, null_frame_id);
d2330 2
a2331 2
	    && (frame_id_inner (get_frame_id (get_current_frame ()),
				step_frame_id)))
d2541 1
a2541 1
				    get_frame_base (get_current_frame ()))
d2611 1
a2611 1
	    set_momentary_breakpoint (sr_sal, null_frame_id, bp_step_resume);
d2642 1
a2642 1
	struct frame_id current_frame = get_frame_id (get_current_frame ());
d2644 1
a2644 1
	if (frame_id_inner (current_frame, step_frame_id))
d2664 2
a2665 1
	       step_frame_id; I don't think anyone thought to try it.  */
d2668 1
a2668 1
	      set_momentary_breakpoint (sr_sal, null_frame_id, bp_step_resume);
d2739 1
a2739 2
	      && frame_id_inner (step_frame_id,
				 frame_id_build (read_sp (), 0)))
d2743 7
a2749 6
	       trampoline isn't such a bad idea.  In order to do that,
	       we have to ignore the value in step_frame_id, since
	       that doesn't represent the frame that'll reach when we
	       return from the signal trampoline.  Otherwise we'll
	       probably continue to the end of the program.  */
	    step_frame_id = null_frame_id;
d2777 1
a2777 1
		set_momentary_breakpoint (xxx, null_frame_id, bp_step_resume);
d2855 1
a2855 1
	    set_momentary_breakpoint (sr_sal, null_frame_id, bp_step_resume);
d2913 1
a2913 1
  step_frame_id = get_frame_id (get_current_frame ());
d2917 3
a2919 3
  /* In the case where we just stepped out of a function into the
     middle of a line of the caller, continue stepping, but
     step_frame_id must be modified to current frame */
d2921 3
a2923 3
    struct frame_id current_frame = get_frame_id (get_current_frame ());
    if (!(frame_id_inner (current_frame, step_frame_id)))
      step_frame_id = current_frame;
d2969 1
a2969 1
	set_momentary_breakpoint (sr_sal, null_frame_id, bp_through_sigtramp);
d3027 1
a3027 1
	set_momentary_breakpoint (sr_sal, null_frame_id, bp_step_resume);
d3046 1
a3046 1
   caller's frame (step_frame_id, which is set by the "next" or
d3060 1
a3060 2
    set_momentary_breakpoint (sr_sal, get_frame_id (get_current_frame ()),
			      bp_step_resume);
d3062 2
a3063 3
  if (frame_id_p (step_frame_id)
      && !IN_SOLIB_DYNSYM_RESOLVE_CODE (sr_sal.pc))
    step_resume_breakpoint->frame_id = step_frame_id;
d3074 24
d3117 10
d3366 2
a3367 6
  if (target_has_execution)
    /* FIXME: cagney/2002-12-06: Has the PC changed?  Thanks to
       DECR_PC_AFTER_BREAK, the program counter can change.  Ask the
       frame code to check for this and sort out any resultant mess.
       DECR_PC_AFTER_BREAK needs to just go away.  */
    deprecated_update_frame_pc_hack (get_current_frame (), read_pc ());
d3427 1
a3427 1
      if (stop_print_frame && deprecated_selected_frame)
a3436 3
	      /* FIXME: cagney/2002-12-01: Given that a frame ID does
		 (or should) carry around the function and does (or
		 should) use that when doing a frame comparison.  */
d3438 1
a3438 2
		  && frame_id_eq (step_frame_id,
				  get_frame_id (get_current_frame ()))
d3471 1
a3471 1
	    show_and_print_stack_frame (deprecated_selected_frame, -1, source_flag);
d3876 1
a3876 1
  struct frame_id step_frame_id;
d3923 1
a3923 1
  inf_status->step_frame_id = step_frame_id;
d3941 1
a3941 1
  inf_status->selected_frame_id = get_frame_id (deprecated_selected_frame);
d3953 2
a3954 2
  /* If inf_status->selected_frame_id is NULL, there was no previously
     selected frame.  */
d3977 1
a3977 1
  step_frame_id = inf_status->step_frame_id;
a4041 54
}

int
inferior_has_forked (int pid, int *child_pid)
{
  struct target_waitstatus last;
  ptid_t last_ptid;

  get_last_target_status (&last_ptid, &last);

  if (last.kind != TARGET_WAITKIND_FORKED)
    return 0;

  if (ptid_get_pid (last_ptid) != pid)
    return 0;

  *child_pid = last.value.related_pid;
  return 1;
}

int
inferior_has_vforked (int pid, int *child_pid)
{
  struct target_waitstatus last;
  ptid_t last_ptid;

  get_last_target_status (&last_ptid, &last);

  if (last.kind != TARGET_WAITKIND_VFORKED)
    return 0;

  if (ptid_get_pid (last_ptid) != pid)
    return 0;

  *child_pid = last.value.related_pid;
  return 1;
}

int
inferior_has_execd (int pid, char **execd_pathname)
{
  struct target_waitstatus last;
  ptid_t last_ptid;

  get_last_target_status (&last_ptid, &last);

  if (last.kind != TARGET_WAITKIND_EXECD)
    return 0;

  if (ptid_get_pid (last_ptid) != pid)
    return 0;

  *execd_pathname = xstrdup (last.value.execd_pathname);
  return 1;
@


1.71.2.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d5 1
a5 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
d69 1
a69 1
static int follow_fork (void);
d380 1
a380 1
follow_fork (void)
d1175 1
a1175 1
  CORE_ADDR real_stop_pc;
d2410 3
a2412 3
      real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
      if (real_stop_pc != 0)
	ecs->stop_func_start = real_stop_pc;
d2415 2
a2416 2
	  real_stop_pc = DYNAMIC_TRAMPOLINE_NEXTPC (stop_pc);
	  if (real_stop_pc)
d2422 1
a2422 1
	      xxx.pc = real_stop_pc;
d2485 2
d2488 1
a2488 1
      real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
d2491 1
a2491 1
      if (real_stop_pc)
d2497 1
a2497 1
	  sr_sal.pc = real_stop_pc;
d3096 1
a3096 1
	    print_stack_frame (deprecated_selected_frame, -1, source_flag);
d3112 4
a3115 4
      /* Pop the empty frame that contains the stack dummy.  POP_FRAME
         ends with a setting of the current frame, so we can use that
         next. */
      frame_pop (get_current_frame ());
@


1.71.2.5
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d229 7
@


1.71.2.6
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a44 2
#include "observer.h"
#include "language.h"
d109 15
d302 1
a302 1
enum stop_kind stop_soon;
d675 1
a675 1
  stop_soon = NO_STOP_QUIETLY;
d807 1
d818 1
a818 1
  stop_soon = STOP_QUIETLY;
d846 1
d1134 2
a1135 1
      save_infrun_state (inferior_ptid, prev_pc, prev_func_name,
d1146 2
a1147 1
      load_infrun_state (ecs->ptid, &prev_pc, &prev_func_name,
a1168 5
  /* NOTE: cagney/2003-03-28: If you're looking at this code and
     thinking that the variable stepped_after_stopped_by_watchpoint
     isn't used, then you're wrong!  The macro STOPPED_BY_WATCHPOINT,
     defined in the file "config/pa/nm-hppah.h", accesses the variable
     indirectly.  Mutter something rude about the HP merge.  */
d1181 1
a1181 9
      /* See comments where a TARGET_WAITKIND_SYSCALL_RETURN event
         is serviced in this loop, below. */
      if (ecs->enable_hw_watchpoints_after_wait)
	{
	  TARGET_ENABLE_HW_WATCHPOINTS (PIDGET (inferior_ptid));
	  ecs->enable_hw_watchpoints_after_wait = 0;
	}
      stepped_after_stopped_by_watchpoint = 0;
      break;
a1194 1
      stepped_after_stopped_by_watchpoint = 0;
a1204 3

    default:
      internal_error (__FILE__, __LINE__, "bad switch");
d1257 1
a1257 1
      if (stop_soon == NO_STOP_QUIETLY)
d1756 1
a1756 3
	   || stop_signal == TARGET_SIGNAL_EMT))
      || stop_soon == STOP_QUIETLY
      || stop_soon == STOP_QUIETLY_NO_SIGSTOP)
d1764 1
a1764 4

      /* This is originated from start_remote(), start_inferior() and
         shared libraries hook functions.  */
      if (stop_soon == STOP_QUIETLY)
a1769 12
      /* This originates from attach_command().  We need to overwrite
         the stop_signal here, because some kernels don't ignore a
         SIGSTOP in a subsequent ptrace(PTRACE_SONT,SOGSTOP) call.
         See more comments in inferior.h.  */
      if (stop_soon == STOP_QUIETLY_NO_SIGSTOP)
	{
	  stop_stepping (ecs);
	  if (stop_signal == TARGET_SIGNAL_STOP)
	    stop_signal = TARGET_SIGNAL_0;
	  return;
	}

a1810 16
      /* NOTE: cagney/2003-03-29: These two checks for a random signal
	 at one stage in the past included checks for an inferior
	 function call's call dummy's return breakpoint.  The original
	 comment, that went with the test, read:

	 ``End of a stack dummy.  Some systems (e.g. Sony news) give
	 another signal besides SIGTRAP, so check here as well as
	 above.''

         If someone ever tries to get get call dummys on a
         non-executable stack to work (where the target would stop
         with something like a SIGSEG), then those tests might need to
         be re-instated.  Given, however, that the tests were only
         enabled when momentary breakpoints were not being used, I
         suspect that it won't be the case.  */

d1815 3
d1819 1
d1822 9
a1830 1
	  ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
d2172 25
d2403 1
a2403 3
      real_stop_pc = skip_language_trampoline (stop_pc);
      if (real_stop_pc == 0)
	real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
d2406 19
d2695 1
a2695 38

  /* NOTE: cagney/2003-04-06:

     At this point the equality get_frame_pc() == get_frame_func()
     should hold.  This may make it possible for this code to tell the
     frame where it's function is, instead of the reverse.  This would
     avoid the need to search for the frame's function, which can get
     very messy when there is no debug info available (look at the
     heuristic find pc start code found in targets like the MIPS).  */

  /* NOTE: cagney/2003-04-06:

     The intent of DEPRECATED_SAVED_PC_AFTER_CALL was to:

     - provide a very light weight equivalent to frame_unwind_pc()
     (nee FRAME_SAVED_PC) that avoids the prologue analyzer

     - avoid handling the case where the PC hasn't been saved in the
     prologue analyzer

     Unfortunatly, not five lines further down, is a call to
     get_frame_id() and that is guarenteed to trigger the prologue
     analyzer.
     
     The `correct fix' is for the prologe analyzer to handle the case
     where the prologue is incomplete (PC in prologue) and,
     consequently, the return pc has not yet been saved.  It should be
     noted that the prologue analyzer needs to handle this case
     anyway: frameless leaf functions that don't save the return PC;
     single stepping through a prologue.

     The d10v handles all this by bailing out of the prologue analsis
     when it reaches the current instruction.  */

  if (DEPRECATED_SAVED_PC_AFTER_CALL_P ())
    sr_sal.pc = ADDR_BITS_REMOVE (DEPRECATED_SAVED_PC_AFTER_CALL (get_current_frame ()));
  else
    sr_sal.pc = ADDR_BITS_REMOVE (frame_pc_unwind (get_current_frame ()));
d2720 1
d2737 5
a3115 1
  observer_notify_normal_stop ();
d3496 1
a3496 1
  int stop_soon;
d3542 1
a3542 1
  inf_status->stop_soon = stop_soon;
d3596 1
a3596 1
  stop_soon = inf_status->stop_soon;
@


1.71.2.7
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@a669 6

/* Record the pc of the program the last time it stopped.  This is
   just used internally by wait_for_inferior, but need to be preserved
   over calls to it and cleared when the inferior is started.  */
static CORE_ADDR prev_pc;

a774 24
  /* Refresh prev_pc value just prior to resuming.  This used to be
     done in stop_stepping, however, setting prev_pc there did not handle
     scenarios such as inferior function calls or returning from
     a function via the return command.  In those cases, the prev_pc
     value was not set properly for subsequent commands.  The prev_pc value 
     is used to initialize the starting line number in the ecs.  With an 
     invalid value, the gdb next command ends up stopping at the position
     represented by the next line table entry past our start position.
     On platforms that generate one line table entry per line, this
     is not a problem.  However, on the ia64, the compiler generates
     extraneous line table entries that do not increase the line number.
     When we issue the gdb next command on the ia64 after an inferior call
     or a return command, we often end up a few instructions forward, still 
     within the original line we started.

     An attempt was made to have init_execution_control_state () refresh
     the prev_pc value before calculating the line number.  This approach
     did not work because on platforms that use ptrace, the pc register
     cannot be read unless the inferior is stopped.  At that point, we
     are not guaranteed the inferior is stopped and so the read_pc ()
     call can fail.  Setting the prev_pc value here ensures the value is 
     updated correctly when the inferior is stopped.  */  
  prev_pc = read_pc ();

d788 7
d832 1
d1119 1
a1119 1
      save_infrun_state (inferior_ptid, prev_pc,
d1130 1
a1130 1
      load_infrun_state (ecs->ptid, &prev_pc,
a1142 33
/* Wrapper for PC_IN_SIGTRAMP that takes care of the need to find the
   function's name.

   In a classic example of "left hand VS right hand", "infrun.c" was
   trying to improve GDB's performance by caching the result of calls
   to calls to find_pc_partial_funtion, while at the same time
   find_pc_partial_function was also trying to ramp up performance by
   caching its most recent return value.  The below makes the the
   function find_pc_partial_function solely responsibile for
   performance issues (the local cache that relied on a global
   variable - arrrggg - deleted).

   Using the testsuite and gcov, it was found that dropping the local
   "infrun.c" cache and instead relying on find_pc_partial_function
   increased the number of calls to 12000 (from 10000), but the number
   of times find_pc_partial_function's cache missed (this is what
   matters) was only increased by only 4 (to 3569).  (A quick back of
   envelope caculation suggests that the extra 2000 function calls
   @@1000 extra instructions per call make the 1 MIP VAX testsuite run
   take two extra seconds, oops :-)

   Long term, this function can be eliminated, replaced by the code:
   get_frame_type(current_frame()) == SIGTRAMP_FRAME (for new
   architectures this is very cheap).  */

static int
pc_in_sigtramp (CORE_ADDR pc)
{
  char *name;
  find_pc_partial_function (pc, &name, NULL, NULL);
  return PC_IN_SIGTRAMP (pc, name);
}

d2265 2
a2266 2
  if (pc_in_sigtramp (stop_pc)
      && !pc_in_sigtramp (prev_pc)
d2376 1
a2376 1
	  if (pc_in_sigtramp (stop_pc)
d2565 2
a2566 2
      && pc_in_sigtramp (stop_pc)
      && !pc_in_sigtramp (prev_pc)
d2730 9
d2752 1
@


1.71.2.8
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a81 2
static int prepare_to_proceed (void);

a669 49
/* This should be suitable for any targets that support threads. */

static int
prepare_to_proceed (void)
{
  ptid_t wait_ptid;
  struct target_waitstatus wait_status;

  /* Get the last target status returned by target_wait().  */
  get_last_target_status (&wait_ptid, &wait_status);

  /* Make sure we were stopped either at a breakpoint, or because
     of a Ctrl-C.  */
  if (wait_status.kind != TARGET_WAITKIND_STOPPED
      || (wait_status.value.sig != TARGET_SIGNAL_TRAP &&
          wait_status.value.sig != TARGET_SIGNAL_INT))
    {
      return 0;
    }

  if (!ptid_equal (wait_ptid, minus_one_ptid)
      && !ptid_equal (inferior_ptid, wait_ptid))
    {
      /* Switched over from WAIT_PID.  */
      CORE_ADDR wait_pc = read_pc_pid (wait_ptid);

      if (wait_pc != read_pc ())
	{
	  /* Switch back to WAIT_PID thread.  */
	  inferior_ptid = wait_ptid;

	  /* FIXME: This stuff came from switch_to_thread() in
	     thread.c (which should probably be a public function).  */
	  flush_cached_frames ();
	  registers_changed ();
	  stop_pc = wait_pc;
	  select_frame (get_current_frame ());
	}

	/* We return 1 to indicate that there is a breakpoint here,
	   so we need to step over it before continuing to avoid
	   hitting it straight away. */
	if (breakpoint_here_p (wait_pc))
	   return 1;
    }

  return 0;
  
}
d725 1
d734 1
a734 1
     prepare_to_proceed checks the current thread against the thread
d737 6
a742 2
  if (prepare_to_proceed () && breakpoint_here_p (read_pc ()))
    oneproc = 1;
@


1.71.2.9
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d2449 3
a2451 3
  if (((stop_pc == ecs->stop_func_start	/* Quick test */
	|| in_prologue (stop_pc, ecs->stop_func_start))
       && !IN_SOLIB_RETURN_TRAMPOLINE (stop_pc, ecs->stop_func_name))
a3056 5
  struct target_waitstatus last;
  ptid_t last_ptid;

  get_last_target_status (&last_ptid, &last);

d3061 2
a3062 3
     There's no point in saying anything if the inferior has exited.
     Note that SIGNALLED here means "exited with a signal", not
     "received a signal".  */
d3064 1
a3064 3
      && target_has_execution
      && last.kind != TARGET_WAITKIND_SIGNALLED
      && last.kind != TARGET_WAITKIND_EXITED)
d3910 2
a3911 2
  int i;
  int numsigs;
@


1.71.2.10
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d156 4
d498 1
d523 1
a523 1
     callbacks.  Unfortunately, for ``show'' commands cloned from
a2639 16
#if 0
  /* NOTE: cagney/2003-10-16: I think this frame ID inner test is too
     generous.  It will trigger on things like a step into a frameless
     stackless leaf function.  I think the logic should instead look
     at the unwound frame ID has that should give a more robust
     indication of what happened.  */
     if (step-ID == current-ID)
       still stepping in same function;
     else if (step-ID == unwind (current-ID))
       stepped into a function;
     else
       stepped out of a function;
     /* Of course this assumes that the frame ID unwind code is robust
        and we're willing to introduce frame unwind logic into this
        function.  Fortunately, those days are nearly upon us.  */
#endif
d2795 1
a2795 1
     Unfortunately, not five lines further down, is a call to
d3626 1
a3626 1
  int size = DEPRECATED_REGISTER_RAW_SIZE (regno);
@


1.71.2.11
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1365 1
a1365 16
	  /* NOTE: cagney/2003-11-25: Make certain that the target
             stack's section table is kept up-to-date.  Architectures,
             (e.g., PPC64), use the section table to perform
             operations such as address => section name and hence
             require the table to contain all sections (including
             those found in shared libraries).  */
	  /* NOTE: cagney/2003-11-25: Pass current_target and not
             exec_ops to SOLIB_ADD.  This is because current GDB is
             only tooled to propagate section_table changes out from
             the "current_target" (see target_resize_to_sections), and
             not up from the exec stratum.  This, of course, isn't
             right.  "infrun.c" should only interact with the
             exec/process stratum, instead relying on the target stack
             to propagate relevant changes (stop, section table
             changed, ...) up to other layers.  */
	  SOLIB_ADD (NULL, 0, &current_target, auto_solib_add);
d2188 1
a2188 16
	  /* NOTE: cagney/2003-11-25: Make certain that the target
             stack's section table is kept up-to-date.  Architectures,
             (e.g., PPC64), use the section table to perform
             operations such as address => section name and hence
             require the table to contain all sections (including
             those found in shared libraries).  */
	  /* NOTE: cagney/2003-11-25: Pass current_target and not
             exec_ops to SOLIB_ADD.  This is because current GDB is
             only tooled to propagate section_table changes out from
             the "current_target" (see target_resize_to_sections), and
             not up from the exec stratum.  This, of course, isn't
             right.  "infrun.c" should only interact with the
             exec/process stratum, instead relying on the target stack
             to propagate relevant changes (stop, section table
             changed, ...) up to other layers.  */
	  SOLIB_ADD (NULL, 0, &current_target, auto_solib_add);
d2334 1
a2334 2
      CORE_ADDR pc_after_resolver =
	gdbarch_skip_solib_resolver (current_gdbarch, stop_pc);
d2729 4
d2737 1
@


1.71.2.12
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d5 2
a6 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free
   Software Foundation, Inc.
d64 3
d343 1
d348 1
d360 10
a369 1
  int follow_child = (follow_fork_mode_string == follow_fork_mode_child);
a989 1
static void handle_step_into_function (struct execution_control_state *ecs);
a1238 89
/* Handle the inferior event in the cases when we just stepped
   into a function.  */

static void
handle_step_into_function (struct execution_control_state *ecs)
{
  CORE_ADDR real_stop_pc;

  if ((step_over_calls == STEP_OVER_NONE)
      || ((step_range_end == 1)
          && in_prologue (prev_pc, ecs->stop_func_start)))
    {
      /* I presume that step_over_calls is only 0 when we're
         supposed to be stepping at the assembly language level
         ("stepi").  Just stop.  */
      /* Also, maybe we just did a "nexti" inside a prolog,
         so we thought it was a subroutine call but it was not.
         Stop as well.  FENN */
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }

  if (step_over_calls == STEP_OVER_ALL || IGNORE_HELPER_CALL (stop_pc))
    {
      /* We're doing a "next".  */

      if (pc_in_sigtramp (stop_pc)
          && frame_id_inner (step_frame_id,
                             frame_id_build (read_sp (), 0)))
        /* We stepped out of a signal handler, and into its
           calling trampoline.  This is misdetected as a
           subroutine call, but stepping over the signal
           trampoline isn't such a bad idea.  In order to do that,
           we have to ignore the value in step_frame_id, since
           that doesn't represent the frame that'll reach when we
           return from the signal trampoline.  Otherwise we'll
           probably continue to the end of the program.  */
        step_frame_id = null_frame_id;

      step_over_function (ecs);
      keep_going (ecs);
      return;
    }

  /* If we are in a function call trampoline (a stub between
     the calling routine and the real function), locate the real
     function.  That's what tells us (a) whether we want to step
     into it at all, and (b) what prologue we want to run to
     the end of, if we do step into it.  */
  real_stop_pc = skip_language_trampoline (stop_pc);
  if (real_stop_pc == 0)
    real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
  if (real_stop_pc != 0)
    ecs->stop_func_start = real_stop_pc;

  /* If we have line number information for the function we
     are thinking of stepping into, step into it.

     If there are several symtabs at that PC (e.g. with include
     files), just want to know whether *any* of them have line
     numbers.  find_pc_line handles this.  */
  {
    struct symtab_and_line tmp_sal;

    tmp_sal = find_pc_line (ecs->stop_func_start, 0);
    if (tmp_sal.line != 0)
      {
        step_into_function (ecs);
        return;
      }
  }

  /* If we have no line number and the step-stop-if-no-debug
     is set, we stop the step so that the user has a chance to
     switch in assembly mode.  */
  if (step_over_calls == STEP_OVER_UNDEBUGGABLE && step_stop_if_no_debug)
    {
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }

  step_over_function (ecs);
  keep_going (ecs);
  return;
}
d1247 1
d2229 1
a2229 1
	  if (stop_on_solib_events || stop_stack_dummy)
d2482 80
a2561 1
      handle_step_into_function (ecs);
d2563 1
d2585 1
a2585 1
      CORE_ADDR real_stop_pc = SKIP_TRAMPOLINE_CODE (stop_pc);
a2764 23
  /* Architectures which require breakpoint adjustment might not be able
     to place a breakpoint at the computed address.  If so, the test
     ``ecs->stop_func_start == stop_pc'' will never succeed.  Adjust
     ecs->stop_func_start to an address at which a breakpoint may be
     legitimately placed.
     
     Note:  kevinb/2004-01-19:  On FR-V, if this adjustment is not
     made, GDB will enter an infinite loop when stepping through
     optimized code consisting of VLIW instructions which contain
     subinstructions corresponding to different source lines.  On
     FR-V, it's not permitted to place a breakpoint on any but the
     first subinstruction of a VLIW instruction.  When a breakpoint is
     set, GDB will adjust the breakpoint address to the beginning of
     the VLIW instruction.  Thus, we need to make the corresponding
     adjustment here when computing the stop address.  */
     
  if (gdbarch_adjust_breakpoint_address_p (current_gdbarch))
    {
      ecs->stop_func_start
	= gdbarch_adjust_breakpoint_address (current_gdbarch,
	                                     ecs->stop_func_start);
    }

d2948 11
d4069 18
d4092 2
a4093 1
The unfollowed process will continue to run.\n\
@


1.70
log
@        * infrun.c (handle_inferior_event): Move a comment outside of a
        function call, in order to avoid indent reformatting this part
        of the code in an unreadable way.
@
text
@d3534 1
a3534 3
signal_stop_update (signo, state)
     int signo;
     int state;
d3542 1
a3542 3
signal_print_update (signo, state)
     int signo;
     int state;
d3550 1
a3550 3
signal_pass_update (signo, state)
     int signo;
     int state;
@


1.70.6.1
log
@2002-09-18  Andrew Cagney  <ac131313@@redhat.com>

	* infrun.c (signal_stop_update): Convert definition to ISO C.
	(signal_print_update): Ditto.
	(signal_pass_update): Ditto.
	* inflow.c (terminal_save_ours): Ditto.
@
text
@d3534 3
a3536 1
signal_stop_update (int signo, int state)
d3544 3
a3546 1
signal_print_update (int signo, int state)
d3554 3
a3556 1
signal_pass_update (int signo, int state)
@


1.69
log
@	* infrun.c (normal_stop, proceed): Remove call to print_sys_errmsg
	when breakpoints fail. Move general breakpoint error messages to
	insert_breakpoints.
	* breakpoint.c (insert_breakpoints): Change warnings when
	breakpoints are nto inserted to specify the type. Remove call to
	memory_error when hardware breakpoints can't be inserted. Remove
	multiple calls to warning so all messages are sent to the user at
	once.
	(delete_breakpoints): Make insert error messsages more explicit.
@
text
@d2106 1
a2106 1
	     jump to the instruction following a trap instruction. */
d2108 7
a2117 7
               /* Pass TRUE if our reason for stopping is something other
                  than hitting a breakpoint.  We do this by checking that
                  either we detected earlier a software single step trap or
                  1) stepping is going on and 2) we didn't hit a breakpoint
                  in a signal handler without an intervening stop in
                  sigtramp, which is detected by a new stack pointer value
                  below any usual function calling stack adjustments.  */
@


1.68
log
@2002-08-20  Michael Snyder  <msnyder@@redhat.com>

        * gdbarch.sh (IN_SOLIB_RETURN_TRAMPOLINE): Add.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c, arch-utils.h (generic_in_solib_return_trampoline):
	Add.
        * infrun.c (IN_SOLIB_RETURN_TRAMPOLINE): Delete default definition.
@
text
@d993 3
a995 10
      int temp = insert_breakpoints ();
      if (temp)
	{
	  print_sys_errmsg ("insert_breakpoints", temp);
	  error ("Cannot insert breakpoints.\n\
The same program may be running in another process,\n\
or you may have requested too many hardware\n\
breakpoints and/or watchpoints.\n");
	}

a3373 10

  if (breakpoints_failed)
    {
      target_terminal_ours_for_output ();
      print_sys_errmsg ("While inserting breakpoints", breakpoints_failed);
      printf_filtered ("Stopped; cannot insert breakpoints.\n\
The same program may be running in another process,\n\
or you may have requested too many hardware breakpoints\n\
and/or watchpoints.\n");
    }
@


1.67
log
@        * alpha-osf1-tdep.c (alpha_osf1_init_abi): Unfortunately,
        procfs appears to be broken when debugging on multi-processor
        machines. So enable software single stepping in order to avoid
        using the procfs interface to do next/step operations, using
        internal breakpoints instead.

        * infrun.c (handle_inferior_event): Readjust the stop_pc by
        DECR_PC_AFTER_BREAK when hitting a single step breakpoint, to
        make this pc address equal to the value it would have if the
        system stepping capability was used. Also set a new flag used
        to ensure that we don't readjust the PC one more time later.

        * breakpoint.c (bpstat_stop_status): Do not adjust the PC
        address by DECR_PC_AFTER_BREAK when software single step is
        in use for this architecture, as this has already been taken
        care of in handle_inferior_event().
@
text
@a175 7
/* In some shared library schemes, the return path from a shared library
   call may need to go through a trampoline too.  */

#ifndef IN_SOLIB_RETURN_TRAMPOLINE
#define IN_SOLIB_RETURN_TRAMPOLINE(pc,name)	0
#endif

@


1.66
log
@        * infrun.c (handle_inferior_event): Minor reformatting, to make
        a rather long condition expression easier to read.
@
text
@d1411 1
d1892 12
d2127 1
d2132 5
a2136 4
               (currently_stepping (ecs)
                && prev_pc != stop_pc - DECR_PC_AFTER_BREAK
                && !(step_range_end
                     && INNER_THAN (read_sp (), (step_sp - 16)))));
@


1.65
log
@        * infrun.c (handle_inferior_event): When receiving a SIGTRAP
        signal, check whether we hit a breakpoint before checking for a
        single step breakpoint. Otherwise, GDB fails to notice that a
        breakpoint has been hit when stepping onto a breakpoint.
@
text
@d2109 13
a2121 14
	  stop_bpstat = bpstat_stop_status (&stop_pc,
					    /* Pass TRUE if our reason for stopping is something other
					       than hitting a breakpoint.  We do this by checking that
					       1) stepping is going on and 2) we didn't hit a breakpoint
					       in a signal handler without an intervening stop in
					       sigtramp, which is detected by a new stack pointer value
					       below any usual function calling stack adjustments.  */
					    (currently_stepping (ecs)
					     && prev_pc !=
					     stop_pc - DECR_PC_AFTER_BREAK
					     && !(step_range_end
						  && INNER_THAN (read_sp (),
								 (step_sp -
								  16)))));
@


1.64
log
@2002-07-24  Andrew Cagney  <cagney@@redhat.com>
* regcache.h (regcache_raw_read, regcache_raw_write): Replace
regcache_read and regcache_write.
(regcache_raw_read_as_address): Replace regcache_read_as_address.
* regcache.c: Update.
* sh-tdep.c (sh64_push_arguments): Update comment.
(sh_pseudo_register_read): Update.
(sh_pseudo_register_write): Update.
(sh4_register_read): Update.
(sh4_register_write): Update.
(sh64_pseudo_register_read): Update.
(sh64_pseudo_register_write): Update.
(sh64_register_read): Update.
(sh64_register_write): Update.
* i386-tdep.c (i386_extract_return_value): Update.
(i386_extract_struct_value_address): Update.
(i386_extract_return_value): Update.
* blockframe.c (generic_read_register_dummy): Update.
(generic_call_dummy_register_unwind): Update
* infrun.c (write_inferior_status_register): Update.
@
text
@d1829 5
a1833 4
      if (SOFTWARE_SINGLE_STEP_P () && singlestep_breakpoints_inserted_p)
	ecs->random_signal = 0;
      else if (breakpoints_inserted
	       && breakpoint_here_p (stop_pc - DECR_PC_AFTER_BREAK))
d1889 4
@


1.63
log
@        * infrun.c: Re-indent using gdb_indent.sh.
@
text
@d3920 1
a3920 1
  regcache_write (inf_status->registers, regno, buf);
@


1.62
log
@        * infrun.c (handle_inferior_event): Remove unneeded extra brace.
        Leave the indentation temporarily untouched, to minimize the diffs.
@
text
@d63 1
a63 1
					  struct cmd_list_element * c);
d77 1
a77 1
				struct cmd_list_element * c);
d218 1
a218 1
#ifndef SKIP_PERMANENT_BREAKPOINT 
d229 1
a229 1
   
d372 3
d376 5
a380 11
    enum target_waitkind kind;
    struct
      {
	int parent_pid;
	int saw_parent_fork;
	int child_pid;
	int saw_child_fork;
	int saw_child_exec;
      }
    fork_event;
    char *execd_pathname;
d382 3
d407 1
a407 2
static const char *follow_fork_mode_kind_names[] =
{
d514 1
a514 2
      if (step_resume_breakpoint &&
	  (!has_vforked || !follow_vfork_when_exec))
d578 1
a578 3
				followed_parent,
				child_pid,
				followed_child);
d629 1
a629 1
                    pending_follow.fork_event.child_pid);
d685 1
a685 1
  			/* Because mourn_inferior resets inferior_ptid. */
d733 1
a733 2
static const char *scheduler_enums[] =
{
d755 1
a755 2
	error ("Target '%s' cannot support this command.",
	       target_shortname);
d788 1
a788 1
     
d820 1
a820 1
                   pending_follow.fork_event.child_pid);
d829 1
a829 1
	              pending_follow.fork_event.child_pid);
d859 1
a859 1
      resume_ptid = RESUME_ALL;		/* Default */
d873 1
a873 1
	  (scheduler_mode == schedlock_step && 
d877 1
a877 1
	    resume_ptid = inferior_ptid;
d882 2
a883 2
	 normally.  But if this one cannot, just continue and we will hit
	 it anyway.  */
d1154 26
a1179 26
  {
    struct target_waitstatus ws;
    struct target_waitstatus *wp;
    int another_trap;
    int random_signal;
    CORE_ADDR stop_func_start;
    CORE_ADDR stop_func_end;
    char *stop_func_name;
    struct symtab_and_line sal;
    int remove_breakpoints_on_following_step;
    int current_line;
    struct symtab *current_symtab;
    int handling_longjmp;	/* FIXME */
    ptid_t ptid;
    ptid_t saved_inferior_ptid;
    int update_step_sp;
    int stepping_through_solib_after_catch;
    bpstat stepping_through_solib_catchpoints;
    int enable_hw_watchpoints_after_wait;
    int stepping_through_sigtramp;
    int new_thread_event;
    struct target_waitstatus tmpstatus;
    enum infwait_states infwait_state;
    ptid_t waiton_ptid;
    int wait_some_more;
  };
d1181 1
a1181 1
void init_execution_control_state (struct execution_control_state * ecs);
d1183 1
a1183 1
void handle_inferior_event (struct execution_control_state * ecs);
d1191 2
a1192 1
static void print_stop_reason (enum inferior_stop_reason stop_reason, int stop_info);
d1269 1
a1269 1
      old_cleanups = make_exec_cleanup (delete_step_resume_breakpoint, 
d1292 2
a1293 1
    async_ecs->ptid = target_wait_hook (async_ecs->waiton_ptid, async_ecs->wp);
d1303 2
a1304 2
	 function. Let the continuations for the commands do the rest,
	 if there are any. */
d1345 2
a1346 1
    warning ("GDB bug: infrun.c (wait_for_inferior): dropping old step_resume breakpoint");
d1355 1
a1355 1
get_last_target_status(ptid_t *ptidp, struct target_waitstatus *status)
d1373 1
a1373 1
    { /* Perform infrun state context switch: */
d1375 2
a1376 2
      save_infrun_state (inferior_ptid, prev_pc, 
			 prev_func_start, prev_func_name, 
d1378 2
a1379 2
			 through_sigtramp_breakpoint, step_range_start, 
			 step_range_end, step_frame_address, 
d1384 1
a1384 2
			 ecs->current_line, ecs->current_symtab, 
			 step_sp);
d1387 2
a1388 2
      load_infrun_state (ecs->ptid, &prev_pc, 
			 &prev_func_start, &prev_func_name, 
d1390 2
a1391 2
			 &through_sigtramp_breakpoint, &step_range_start, 
			 &step_range_end, &step_frame_address, 
d1395 2
a1396 3
			 &ecs->stepping_through_sigtramp, 
			 &ecs->current_line, &ecs->current_symtab,
			 &step_sp);
d1416 17
a1432 17
    switch (ecs->infwait_state)
      {
      case infwait_thread_hop_state:
	/* Cancel the waiton_ptid. */
	ecs->waiton_ptid = pid_to_ptid (-1);
	/* Fall thru to the normal_state case. */

      case infwait_normal_state:
	/* See comments where a TARGET_WAITKIND_SYSCALL_RETURN event
	   is serviced in this loop, below. */
	if (ecs->enable_hw_watchpoints_after_wait)
	  {
	    TARGET_ENABLE_HW_WATCHPOINTS (PIDGET (inferior_ptid));
	    ecs->enable_hw_watchpoints_after_wait = 0;
	  }
	stepped_after_stopped_by_watchpoint = 0;
	break;
d1434 2
a1435 2
      case infwait_nullified_state:
	break;
d1437 2
a1438 2
      case infwait_nonstep_watch_state:
	insert_breakpoints ();
d1440 7
a1446 7
	/* FIXME-maybe: is this cleaner than setting a flag?  Does it
	   handle things like signals arriving and other things happening
	   in combination correctly?  */
	stepped_after_stopped_by_watchpoint = 1;
	break;
      }
    ecs->infwait_state = infwait_normal_state;
d1448 1
a1448 1
    flush_cached_frames ();
d1450 1
a1450 1
    /* If it's a new process, add it to the thread database */
d1452 2
a1453 2
    ecs->new_thread_event = (! ptid_equal (ecs->ptid, inferior_ptid) 
                             && ! in_thread_list (ecs->ptid));
d1455 4
a1458 5
    if (ecs->ws.kind != TARGET_WAITKIND_EXITED
	&& ecs->ws.kind != TARGET_WAITKIND_SIGNALLED
	&& ecs->new_thread_event)
      {
	add_thread (ecs->ptid);
d1460 3
a1462 3
	ui_out_text (uiout, "[New ");
	ui_out_text (uiout, target_pid_or_tid_to_str (ecs->ptid));
	ui_out_text (uiout, "]\n");
d1465 18
a1482 18
	/* NOTE: This block is ONLY meant to be invoked in case of a
	   "thread creation event"!  If it is invoked for any other
	   sort of event (such as a new thread landing on a breakpoint),
	   the event will be discarded, which is almost certainly
	   a bad thing!

	   To avoid this, the low-level module (eg. target_wait)
	   should call in_thread_list and add_thread, so that the
	   new thread is known by the time we get here.  */

	/* We may want to consider not doing a resume here in order
	   to give the user a chance to play with the new thread.
	   It might be good to make that a user-settable option.  */

	/* At this point, all threads are stopped (happens
	   automatically in either the OS or the native code).
	   Therefore we need to continue all threads in order to
	   make progress.  */
d1484 3
a1486 3
	target_resume (RESUME_ALL, 0, TARGET_SIGNAL_0);
	prepare_to_wait (ecs);
	return;
d1488 1
a1488 1
      }
d1490 6
a1495 6
    switch (ecs->ws.kind)
      {
      case TARGET_WAITKIND_LOADED:
	/* Ignore gracefully during startup of the inferior, as it
	   might be the shell which has just loaded some objects,
	   otherwise add the symbols for the newly loaded objects.  */
d1497 6
a1502 6
	if (!stop_soon_quietly)
	  {
	    /* Remove breakpoints, SOLIB_ADD might adjust
	       breakpoint addresses via breakpoint_re_set.  */
	    if (breakpoints_inserted)
	      remove_breakpoints ();
d1504 7
a1510 7
	    /* Check for any newly added shared libraries if we're
	       supposed to be adding them automatically.  Switch
	       terminal for any messages produced by
	       breakpoint_re_set.  */
	    target_terminal_ours_for_output ();
	    SOLIB_ADD (NULL, 0, NULL, auto_solib_add);
	    target_terminal_inferior ();
d1512 4
a1515 4
	    /* Reinsert breakpoints and continue.  */
	    if (breakpoints_inserted)
	      insert_breakpoints ();
	  }
d1517 3
a1519 3
	resume (0, TARGET_SIGNAL_0);
	prepare_to_wait (ecs);
	return;
d1521 4
a1524 4
      case TARGET_WAITKIND_SPURIOUS:
	resume (0, TARGET_SIGNAL_0);
	prepare_to_wait (ecs);
	return;
d1526 15
a1540 15
      case TARGET_WAITKIND_EXITED:
	target_terminal_ours ();	/* Must do this before mourn anyway */
	print_stop_reason (EXITED, ecs->ws.value.integer);

	/* Record the exit code in the convenience variable $_exitcode, so
	   that the user can inspect this again later.  */
	set_internalvar (lookup_internalvar ("_exitcode"),
			 value_from_longest (builtin_type_int,
					  (LONGEST) ecs->ws.value.integer));
	gdb_flush (gdb_stdout);
	target_mourn_inferior ();
	singlestep_breakpoints_inserted_p = 0;	/*SOFTWARE_SINGLE_STEP_P() */
	stop_print_frame = 0;
	stop_stepping (ecs);
	return;
d1542 11
a1552 4
      case TARGET_WAITKIND_SIGNALLED:
	stop_print_frame = 0;
	stop_signal = ecs->ws.value.sig;
	target_terminal_ours ();	/* Must do this before mourn anyway */
d1554 4
a1557 6
	/* Note: By definition of TARGET_WAITKIND_SIGNALLED, we shouldn't
	   reach here unless the inferior is dead.  However, for years
	   target_kill() was called here, which hints that fatal signals aren't
	   really fatal on some systems.  If that's true, then some changes
	   may be needed. */
	target_mourn_inferior ();
d1559 24
a1582 4
	print_stop_reason (SIGNAL_EXITED, stop_signal);
	singlestep_breakpoints_inserted_p = 0;	/*SOFTWARE_SINGLE_STEP_P() */
	stop_stepping (ecs);
	return;
d1584 41
a1624 24
	/* The following are the only cases in which we keep going;
	   the above cases end in a continue or goto. */
      case TARGET_WAITKIND_FORKED:
	stop_signal = TARGET_SIGNAL_TRAP;
	pending_follow.kind = ecs->ws.kind;

	/* Ignore fork events reported for the parent; we're only
	   interested in reacting to forks of the child.  Note that
	   we expect the child's fork event to be available if we
	   waited for it now. */
	if (ptid_equal (inferior_ptid, ecs->ptid))
	  {
	    pending_follow.fork_event.saw_parent_fork = 1;
	    pending_follow.fork_event.parent_pid = PIDGET (ecs->ptid);
	    pending_follow.fork_event.child_pid = ecs->ws.value.related_pid;
	    prepare_to_wait (ecs);
	    return;
	  }
	else
	  {
	    pending_follow.fork_event.saw_child_fork = 1;
	    pending_follow.fork_event.child_pid = PIDGET (ecs->ptid);
	    pending_follow.fork_event.parent_pid = ecs->ws.value.related_pid;
	  }
d1626 19
a1644 41
	stop_pc = read_pc_pid (ecs->ptid);
	ecs->saved_inferior_ptid = inferior_ptid;
	inferior_ptid = ecs->ptid;
	/* The second argument of bpstat_stop_status is meant to help
	   distinguish between a breakpoint trap and a singlestep trap.
	   This is only important on targets where DECR_PC_AFTER_BREAK
	   is non-zero.  The prev_pc test is meant to distinguish between
	   singlestepping a trap instruction, and singlestepping thru a
	   jump to the instruction following a trap instruction. */
	   
	stop_bpstat = bpstat_stop_status (&stop_pc, 
					  currently_stepping (ecs) &&
					  prev_pc != 
					  stop_pc - DECR_PC_AFTER_BREAK);
	ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
	inferior_ptid = ecs->saved_inferior_ptid;
	goto process_event_stop_test;

	/* If this a platform which doesn't allow a debugger to touch a
	   vfork'd inferior until after it exec's, then we'd best keep
	   our fingers entirely off the inferior, other than continuing
	   it.  This has the unfortunate side-effect that catchpoints
	   of vforks will be ignored.  But since the platform doesn't
	   allow the inferior be touched at vfork time, there's really
	   little choice. */
      case TARGET_WAITKIND_VFORKED:
	stop_signal = TARGET_SIGNAL_TRAP;
	pending_follow.kind = ecs->ws.kind;

	/* Is this a vfork of the parent?  If so, then give any
	   vfork catchpoints a chance to trigger now.  (It's
	   dangerous to do so if the child canot be touched until
	   it execs, and the child has not yet exec'd.  We probably
	   should warn the user to that effect when the catchpoint
	   triggers...) */
	if (ptid_equal (ecs->ptid, inferior_ptid))
	  {
	    pending_follow.fork_event.saw_parent_fork = 1;
	    pending_follow.fork_event.parent_pid = PIDGET (ecs->ptid);
	    pending_follow.fork_event.child_pid = ecs->ws.value.related_pid;
	  }
d1646 34
a1679 18
	/* If we've seen the child's vfork event but cannot really touch
	   the child until it execs, then we must continue the child now.
	   Else, give any vfork catchpoints a chance to trigger now. */
	else
	  {
	    pending_follow.fork_event.saw_child_fork = 1;
	    pending_follow.fork_event.child_pid = PIDGET (ecs->ptid);
	    pending_follow.fork_event.parent_pid = ecs->ws.value.related_pid;
	    target_post_startup_inferior (
	      pid_to_ptid (pending_follow.fork_event.child_pid));
	    follow_vfork_when_exec = !target_can_follow_vfork_prior_to_exec ();
	    if (follow_vfork_when_exec)
	      {
		target_resume (ecs->ptid, 0, TARGET_SIGNAL_0);
		prepare_to_wait (ecs);
		return;
	      }
	  }
d1681 23
a1703 33
	stop_pc = read_pc ();
	/* The second argument of bpstat_stop_status is meant to help
	   distinguish between a breakpoint trap and a singlestep trap.
	   This is only important on targets where DECR_PC_AFTER_BREAK
	   is non-zero.  The prev_pc test is meant to distinguish between
	   singlestepping a trap instruction, and singlestepping thru a
	   jump to the instruction following a trap instruction. */
	   
	stop_bpstat = bpstat_stop_status (&stop_pc, 
					  currently_stepping (ecs) &&
					  prev_pc !=
					  stop_pc - DECR_PC_AFTER_BREAK);
	ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
	goto process_event_stop_test;

      case TARGET_WAITKIND_EXECD:
	stop_signal = TARGET_SIGNAL_TRAP;

	/* Is this a target which reports multiple exec events per actual
	   call to exec()?  (HP-UX using ptrace does, for example.)  If so,
	   ignore all but the last one.  Just resume the exec'r, and wait
	   for the next exec event. */
	if (inferior_ignoring_leading_exec_events)
	  {
	    inferior_ignoring_leading_exec_events--;
	    if (pending_follow.kind == TARGET_WAITKIND_VFORKED)
	      ENSURE_VFORKING_PARENT_REMAINS_STOPPED (pending_follow.fork_event.parent_pid);
	    target_resume (ecs->ptid, 0, TARGET_SIGNAL_0);
	    prepare_to_wait (ecs);
	    return;
	  }
	inferior_ignoring_leading_exec_events =
	  target_reported_exec_events_per_exec_call () - 1;
d1705 9
a1713 23
	pending_follow.execd_pathname =
	  savestring (ecs->ws.value.execd_pathname,
		      strlen (ecs->ws.value.execd_pathname));

	/* Did inferior_ptid exec, or did a (possibly not-yet-followed)
	   child of a vfork exec?

	   ??rehrauer: This is unabashedly an HP-UX specific thing.  On
	   HP-UX, events associated with a vforking inferior come in
	   threes: a vfork event for the child (always first), followed
	   a vfork event for the parent and an exec event for the child.
	   The latter two can come in either order.

	   If we get the parent vfork event first, life's good: We follow
	   either the parent or child, and then the child's exec event is
	   a "don't care".

	   But if we get the child's exec event first, then we delay
	   responding to it until we handle the parent's vfork.  Because,
	   otherwise we can't satisfy a "catch vfork". */
	if (pending_follow.kind == TARGET_WAITKIND_VFORKED)
	  {
	    pending_follow.fork_event.saw_child_exec = 1;
d1715 4
a1718 9
	    /* On some targets, the child must be resumed before
	       the parent vfork event is delivered.  A single-step
	       suffices. */
	    if (RESUME_EXECD_VFORKING_CHILD_TO_GET_PARENT_VFORK ())
	      target_resume (ecs->ptid, 1, TARGET_SIGNAL_0);
	    /* We expect the parent vfork event to be available now. */
	    prepare_to_wait (ecs);
	    return;
	  }
d1720 44
a1763 49
	/* This causes the eventpoints and symbol table to be reset.  Must
	   do this now, before trying to determine whether to stop. */
	follow_exec (PIDGET (inferior_ptid), pending_follow.execd_pathname);
	xfree (pending_follow.execd_pathname);

	stop_pc = read_pc_pid (ecs->ptid);
	ecs->saved_inferior_ptid = inferior_ptid;
	inferior_ptid = ecs->ptid;
	/* The second argument of bpstat_stop_status is meant to help
	   distinguish between a breakpoint trap and a singlestep trap.
	   This is only important on targets where DECR_PC_AFTER_BREAK
	   is non-zero.  The prev_pc test is meant to distinguish between
	   singlestepping a trap instruction, and singlestepping thru a
	   jump to the instruction following a trap instruction. */
	   
	stop_bpstat = bpstat_stop_status (&stop_pc, 
					  currently_stepping (ecs) &&
					  prev_pc !=
					  stop_pc - DECR_PC_AFTER_BREAK);
	ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
	inferior_ptid = ecs->saved_inferior_ptid;
	goto process_event_stop_test;

	/* These syscall events are returned on HP-UX, as part of its
	   implementation of page-protection-based "hardware" watchpoints.
	   HP-UX has unfortunate interactions between page-protections and
	   some system calls.  Our solution is to disable hardware watches
	   when a system call is entered, and reenable them when the syscall
	   completes.  The downside of this is that we may miss the precise
	   point at which a watched piece of memory is modified.  "Oh well."

	   Note that we may have multiple threads running, which may each
	   enter syscalls at roughly the same time.  Since we don't have a
	   good notion currently of whether a watched piece of memory is
	   thread-private, we'd best not have any page-protections active
	   when any thread is in a syscall.  Thus, we only want to reenable
	   hardware watches when no threads are in a syscall.

	   Also, be careful not to try to gather much state about a thread
	   that's in a syscall.  It's frequently a losing proposition. */
      case TARGET_WAITKIND_SYSCALL_ENTRY:
	number_of_threads_in_syscalls++;
	if (number_of_threads_in_syscalls == 1)
	  {
	    TARGET_DISABLE_HW_WATCHPOINTS (PIDGET (inferior_ptid));
	  }
	resume (0, TARGET_SIGNAL_0);
	prepare_to_wait (ecs);
	return;
d1765 16
a1780 16
	/* Before examining the threads further, step this thread to
	   get it entirely out of the syscall.  (We get notice of the
	   event when the thread is just on the verge of exiting a
	   syscall.  Stepping one instruction seems to get it back
	   into user code.)

	   Note that although the logical place to reenable h/w watches
	   is here, we cannot.  We cannot reenable them before stepping
	   the thread (this causes the next wait on the thread to hang).

	   Nor can we enable them after stepping until we've done a wait.
	   Thus, we simply set the flag ecs->enable_hw_watchpoints_after_wait
	   here, which will be serviced immediately after the target
	   is waited on. */
      case TARGET_WAITKIND_SYSCALL_RETURN:
	target_resume (ecs->ptid, 1, TARGET_SIGNAL_0);
d1782 8
a1789 8
	if (number_of_threads_in_syscalls > 0)
	  {
	    number_of_threads_in_syscalls--;
	    ecs->enable_hw_watchpoints_after_wait =
	      (number_of_threads_in_syscalls == 0);
	  }
	prepare_to_wait (ecs);
	return;
d1791 3
a1793 3
      case TARGET_WAITKIND_STOPPED:
	stop_signal = ecs->ws.value.sig;
	break;
d1795 11
a1805 11
	/* We had an event in the inferior, but we are not interested
	   in handling it at this level. The lower layers have already
	   done what needs to be done, if anything. This case can
	   occur only when the target is async or extended-async. One
	   of the circumstamces for this to happen is when the
	   inferior produces output for the console. The inferior has
	   not stopped, and we are ignoring the event. */
      case TARGET_WAITKIND_IGNORE:
	ecs->wait_some_more = 1;
	return;
      }
d1807 13
a1819 13
    /* We may want to consider not doing a resume here in order to give
       the user a chance to play with the new thread.  It might be good
       to make that a user-settable option.  */

    /* At this point, all threads are stopped (happens automatically in
       either the OS or the native code).  Therefore we need to continue
       all threads in order to make progress.  */
    if (ecs->new_thread_event)
      {
	target_resume (RESUME_ALL, 0, TARGET_SIGNAL_0);
	prepare_to_wait (ecs);
	return;
      }
d1821 1
a1821 1
    stop_pc = read_pc_pid (ecs->ptid);
d1823 11
a1833 7
    /* See if a thread hit a thread-specific breakpoint that was meant for
       another thread.  If so, then step that thread past the breakpoint,
       and continue it.  */

    if (stop_signal == TARGET_SIGNAL_TRAP)
      {
	if (SOFTWARE_SINGLE_STEP_P () && singlestep_breakpoints_inserted_p)
d1835 4
a1838 63
	else if (breakpoints_inserted
		 && breakpoint_here_p (stop_pc - DECR_PC_AFTER_BREAK))
	  {
	    ecs->random_signal = 0;
	    if (!breakpoint_thread_match (stop_pc - DECR_PC_AFTER_BREAK,
					  ecs->ptid))
	      {
		int remove_status;

		/* Saw a breakpoint, but it was hit by the wrong thread.
		   Just continue. */
		if (DECR_PC_AFTER_BREAK)
		  write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK, ecs->ptid);

		remove_status = remove_breakpoints ();
		/* Did we fail to remove breakpoints?  If so, try
		   to set the PC past the bp.  (There's at least
		   one situation in which we can fail to remove
		   the bp's: On HP-UX's that use ttrace, we can't
		   change the address space of a vforking child
		   process until the child exits (well, okay, not
		   then either :-) or execs. */
		if (remove_status != 0)
		  {
		    /* FIXME!  This is obviously non-portable! */
		    write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK + 4, 
				  ecs->ptid);
		    /* We need to restart all the threads now,
		     * unles we're running in scheduler-locked mode. 
		     * Use currently_stepping to determine whether to 
		     * step or continue.
		     */
		    /* FIXME MVS: is there any reason not to call resume()? */
		    if (scheduler_mode == schedlock_on)
		      target_resume (ecs->ptid, 
				     currently_stepping (ecs), 
				     TARGET_SIGNAL_0);
		    else
		      target_resume (RESUME_ALL, 
				     currently_stepping (ecs), 
				     TARGET_SIGNAL_0);
		    prepare_to_wait (ecs);
		    return;
		  }
		else
		  {		/* Single step */
		    breakpoints_inserted = 0;
		    if (!ptid_equal (inferior_ptid, ecs->ptid))
		      context_switch (ecs);
		    ecs->waiton_ptid = ecs->ptid;
		    ecs->wp = &(ecs->ws);
		    ecs->another_trap = 1;

		    ecs->infwait_state = infwait_thread_hop_state;
		    keep_going (ecs);
		    registers_changed ();
		    return;
		  }
	      }
	  }
      }
    else
      ecs->random_signal = 1;
d1840 51
a1890 11
    /* See if something interesting happened to the non-current thread.  If
       so, then switch to that thread, and eventually give control back to
       the user.

       Note that if there's any kind of pending follow (i.e., of a fork,
       vfork or exec), we don't want to do this now.  Rather, we'll let
       the next resume handle it. */
    if (! ptid_equal (ecs->ptid, inferior_ptid) &&
	(pending_follow.kind == TARGET_WAITKIND_SPURIOUS))
      {
	int printed = 0;
d1892 16
a1907 5
	/* If it's a random signal for a non-current thread, notify user
	   if he's expressed an interest. */
	if (ecs->random_signal
	    && signal_print[stop_signal])
	  {
d1919 6
a1924 6
	    printed = 1;
	    target_terminal_ours_for_output ();
	    printf_filtered ("\nProgram received signal %s, %s.\n",
			     target_signal_to_name (stop_signal),
			     target_signal_to_string (stop_signal));
	    gdb_flush (gdb_stdout);
d1926 89
a2014 1
	  }
d2016 2
a2017 2
	/* If it's not SIGTRAP and not a signal we want to stop for, then
	   continue the thread. */
d2019 3
a2021 5
	if (stop_signal != TARGET_SIGNAL_TRAP
	    && !signal_stop[stop_signal])
	  {
	    if (printed)
	      target_terminal_inferior ();
d2023 6
a2028 3
	    /* Clear the signal if it should not be passed.  */
	    if (signal_program[stop_signal] == 0)
	      stop_signal = TARGET_SIGNAL_0;
d2030 20
a2049 4
	    target_resume (ecs->ptid, 0, stop_signal);
	    prepare_to_wait (ecs);
	    return;
	  }
d2051 31
a2081 2
	/* It's a SIGTRAP or a signal we're interested in.  Switch threads,
	   and fall into the rest of wait_for_inferior().  */
d2083 2
a2084 1
	context_switch (ecs);
d2086 10
a2095 2
	if (context_hook)
	  context_hook (pid_to_thread_id (ecs->ptid));
d2097 25
a2121 2
	flush_cached_frames ();
      }
d2123 8
a2130 6
    if (SOFTWARE_SINGLE_STEP_P () && singlestep_breakpoints_inserted_p)
      {
	/* Pull the single step breakpoints out of the target. */
	SOFTWARE_SINGLE_STEP (0, 0);
	singlestep_breakpoints_inserted_p = 0;
      }
d2132 15
a2146 3
    /* If PC is pointing at a nullified instruction, then step beyond
       it so that the user won't be confused when GDB appears to be ready
       to execute it. */
d2148 3
a2150 5
    /*      if (INSTRUCTION_NULLIFIED && currently_stepping (ecs)) */
    if (INSTRUCTION_NULLIFIED)
      {
	registers_changed ();
	target_resume (ecs->ptid, 1, TARGET_SIGNAL_0);
d2152 49
a2200 10
	/* We may have received a signal that we want to pass to
	   the inferior; therefore, we must not clobber the waitstatus
	   in WS. */

	ecs->infwait_state = infwait_nullified_state;
	ecs->waiton_ptid = ecs->ptid;
	ecs->wp = &(ecs->tmpstatus);
	prepare_to_wait (ecs);
	return;
      }
d2202 2
a2203 9
    /* It may not be necessary to disable the watchpoint to stop over
       it.  For example, the PA can (with some kernel cooperation)
       single step over a watchpoint without disabling the watchpoint.  */
    if (HAVE_STEPPABLE_WATCHPOINT && STOPPED_BY_WATCHPOINT (ecs->ws))
      {
	resume (1, 0);
	prepare_to_wait (ecs);
	return;
      }
d2205 4
a2208 21
    /* It is far more common to need to disable a watchpoint to step
       the inferior over it.  FIXME.  What else might a debug
       register or page protection watchpoint scheme need here?  */
    if (HAVE_NONSTEPPABLE_WATCHPOINT && STOPPED_BY_WATCHPOINT (ecs->ws))
      {
	/* At this point, we are stopped at an instruction which has
	   attempted to write to a piece of memory under control of
	   a watchpoint.  The instruction hasn't actually executed
	   yet.  If we were to evaluate the watchpoint expression
	   now, we would get the old value, and therefore no change
	   would seem to have occurred.

	   In order to make watchpoints work `right', we really need
	   to complete the memory write, and then evaluate the
	   watchpoint expression.  The following code does that by
	   removing the watchpoint (actually, all watchpoints and
	   breakpoints), single-stepping the target, re-inserting
	   watchpoints, and then falling through to let normal
	   single-step processing handle proceed.  Since this
	   includes evaluating watchpoints, things will come to a
	   stop in the correct manner.  */
d2210 1
a2210 2
	if (DECR_PC_AFTER_BREAK)
	  write_pc (stop_pc - DECR_PC_AFTER_BREAK);
d2212 15
a2226 3
	remove_breakpoints ();
	registers_changed ();
	target_resume (ecs->ptid, 1, TARGET_SIGNAL_0);	/* Single step */
d2228 3
a2230 6
	ecs->waiton_ptid = ecs->ptid;
	ecs->wp = &(ecs->ws);
	ecs->infwait_state = infwait_nonstep_watch_state;
	prepare_to_wait (ecs);
	return;
      }
d2232 2
a2233 54
    /* It may be possible to simply continue after a watchpoint.  */
    if (HAVE_CONTINUABLE_WATCHPOINT)
      STOPPED_BY_WATCHPOINT (ecs->ws);

    ecs->stop_func_start = 0;
    ecs->stop_func_end = 0;
    ecs->stop_func_name = 0;
    /* Don't care about return value; stop_func_start and stop_func_name
       will both be 0 if it doesn't work.  */
    find_pc_partial_function (stop_pc, &ecs->stop_func_name,
			      &ecs->stop_func_start, &ecs->stop_func_end);
    ecs->stop_func_start += FUNCTION_START_OFFSET;
    ecs->another_trap = 0;
    bpstat_clear (&stop_bpstat);
    stop_step = 0;
    stop_stack_dummy = 0;
    stop_print_frame = 1;
    ecs->random_signal = 0;
    stopped_by_random_signal = 0;
    breakpoints_failed = 0;

    /* Look at the cause of the stop, and decide what to do.
       The alternatives are:
       1) break; to really stop and return to the debugger,
       2) drop through to start up again
       (set ecs->another_trap to 1 to single step once)
       3) set ecs->random_signal to 1, and the decision between 1 and 2
       will be made according to the signal handling tables.  */

    /* First, distinguish signals caused by the debugger from signals
       that have to do with the program's own actions.
       Note that breakpoint insns may cause SIGTRAP or SIGILL
       or SIGEMT, depending on the operating system version.
       Here we detect when a SIGILL or SIGEMT is really a breakpoint
       and change it to SIGTRAP.  */

    if (stop_signal == TARGET_SIGNAL_TRAP
	|| (breakpoints_inserted &&
	    (stop_signal == TARGET_SIGNAL_ILL
	     || stop_signal == TARGET_SIGNAL_EMT
	    ))
	|| stop_soon_quietly)
      {
	if (stop_signal == TARGET_SIGNAL_TRAP && stop_after_trap)
	  {
	    stop_print_frame = 0;
	    stop_stepping (ecs);
	    return;
	  }
	if (stop_soon_quietly)
	  {
	    stop_stepping (ecs);
	    return;
	  }
d2235 2
a2236 2
	/* Don't even think about breakpoints
	   if just proceeded over a breakpoint.
d2238 30
a2267 10
	   However, if we are trying to proceed over a breakpoint
	   and end up in sigtramp, then through_sigtramp_breakpoint
	   will be set and we should check whether we've hit the
	   step breakpoint.  */
	if (stop_signal == TARGET_SIGNAL_TRAP && trap_expected
	    && through_sigtramp_breakpoint == NULL)
	  bpstat_clear (&stop_bpstat);
	else
	  {
	    /* See if there is a breakpoint at the current PC.  */
d2269 4
a2272 24
	    /* The second argument of bpstat_stop_status is meant to help
	       distinguish between a breakpoint trap and a singlestep trap.
	       This is only important on targets where DECR_PC_AFTER_BREAK
	       is non-zero.  The prev_pc test is meant to distinguish between
	       singlestepping a trap instruction, and singlestepping thru a
	       jump to the instruction following a trap instruction. */

	    stop_bpstat = bpstat_stop_status
	      (&stop_pc,
	    /* Pass TRUE if our reason for stopping is something other
	       than hitting a breakpoint.  We do this by checking that
	       1) stepping is going on and 2) we didn't hit a breakpoint
	       in a signal handler without an intervening stop in
	       sigtramp, which is detected by a new stack pointer value
	       below any usual function calling stack adjustments.  */
		(currently_stepping (ecs)
		 && prev_pc != stop_pc - DECR_PC_AFTER_BREAK
		 && !(step_range_end
		      && INNER_THAN (read_sp (), (step_sp - 16))))
	      );
	    /* Following in case break condition called a
	       function.  */
	    stop_print_frame = 1;
	  }
d2274 1
a2274 8
	if (stop_signal == TARGET_SIGNAL_TRAP)
	  ecs->random_signal
	    = !(bpstat_explains_signal (stop_bpstat)
		|| trap_expected
		|| (!CALL_DUMMY_BREAKPOINT_OFFSET_P
		    && PC_IN_CALL_DUMMY (stop_pc, read_sp (),
					 FRAME_FP (get_current_frame ())))
		|| (step_range_end && step_resume_breakpoint == NULL));
d2276 6
a2281 14
	else
	  {
	    ecs->random_signal
	      = !(bpstat_explains_signal (stop_bpstat)
	    /* End of a stack dummy.  Some systems (e.g. Sony
	       news) give another signal besides SIGTRAP, so
	       check here as well as above.  */
		  || (!CALL_DUMMY_BREAKPOINT_OFFSET_P
		      && PC_IN_CALL_DUMMY (stop_pc, read_sp (),
					   FRAME_FP (get_current_frame ())))
	      );
	    if (!ecs->random_signal)
	      stop_signal = TARGET_SIGNAL_TRAP;
	  }
d2284 1
a2284 24
    /* When we reach this point, we've pretty much decided
       that the reason for stopping must've been a random
       (unexpected) signal. */

    else
      ecs->random_signal = 1;
    /* If a fork, vfork or exec event was seen, then there are two
       possible responses we can make:

       1. If a catchpoint triggers for the event (ecs->random_signal == 0),
       then we must stop now and issue a prompt.  We will resume
       the inferior when the user tells us to.
       2. If no catchpoint triggers for the event (ecs->random_signal == 1),
       then we must resume the inferior now and keep checking.

       In either case, we must take appropriate steps to "follow" the
       the fork/vfork/exec when the inferior is resumed.  For example,
       if follow-fork-mode is "child", then we must detach from the
       parent inferior and follow the new child inferior.

       In either case, setting pending_follow causes the next resume()
       to take the appropriate following action. */
  process_event_stop_test:
    if (ecs->ws.kind == TARGET_WAITKIND_FORKED)
d2286 8
a2293 1
	if (ecs->random_signal)	/* I.e., no catchpoint triggered for this. */
a2294 2
	    trap_expected = 1;
	    stop_signal = TARGET_SIGNAL_0;
d2298 4
a2301 4
      }
    else if (ecs->ws.kind == TARGET_WAITKIND_VFORKED)
      {
	if (ecs->random_signal)	/* I.e., no catchpoint triggered for this. */
d2303 1
a2303 3
	    stop_signal = TARGET_SIGNAL_0;	
	    keep_going (ecs);
	    return;
d2305 3
a2307 5
      }
    else if (ecs->ws.kind == TARGET_WAITKIND_EXECD)
      {
	pending_follow.kind = ecs->ws.kind;
	if (ecs->random_signal)	/* I.e., no catchpoint triggered for this. */
d2309 2
a2310 4
	    trap_expected = 1;
	    stop_signal = TARGET_SIGNAL_0;
	    keep_going (ecs);
	    return;
a2311 1
      }
d2313 10
a2322 2
    /* For the program's own signals, act according to
       the signal handling tables.  */
d2324 9
a2332 8
    if (ecs->random_signal)
      {
	/* Signal not for debugging purposes.  */
	int printed = 0;

	stopped_by_random_signal = 1;

	if (signal_print[stop_signal])
d2334 3
a2336 3
	    printed = 1;
	    target_terminal_ours_for_output ();
	    print_stop_reason (SIGNAL_RECEIVED, stop_signal);
d2338 9
a2346 1
	if (signal_stop[stop_signal])
d2348 1
a2348 2
	    stop_stepping (ecs);
	    return;
d2350 12
a2361 4
	/* If not going to stop, give terminal back
	   if we took it away.  */
	else if (printed)
	  target_terminal_inferior ();
d2363 2
a2364 3
	/* Clear the signal if it should not be passed.  */
	if (signal_program[stop_signal] == 0)
	  stop_signal = TARGET_SIGNAL_0;
d2366 2
a2367 2
	/* I'm not sure whether this needs to be check_sigtramp2 or
	   whether it could/should be keep_going.
d2369 3
a2371 2
	   This used to jump to step_over_function if we are stepping,
	   which is wrong.
d2373 1
a2373 28
	   Suppose the user does a `next' over a function call, and while
	   that call is in progress, the inferior receives a signal for
	   which GDB does not stop (i.e., signal_stop[SIG] is false).  In
	   that case, when we reach this point, there is already a
	   step-resume breakpoint established, right where it should be:
	   immediately after the function call the user is "next"-ing
	   over.  If we call step_over_function now, two bad things
	   happen:

	   - we'll create a new breakpoint, at wherever the current
	     frame's return address happens to be.  That could be
	     anywhere, depending on what function call happens to be on
	     the top of the stack at that point.  Point is, it's probably
	     not where we need it.

           - the existing step-resume breakpoint (which is at the correct
	     address) will get orphaned: step_resume_breakpoint will point
	     to the new breakpoint, and the old step-resume breakpoint
	     will never be cleaned up.

           The old behavior was meant to help HP-UX single-step out of
           sigtramps.  It would place the new breakpoint at prev_pc, which
           was certainly wrong.  I don't know the details there, so fixing
           this probably breaks that.  As with anything else, it's up to
           the HP-UX maintainer to furnish a fix that doesn't break other
           platforms.  --JimB, 20 May 1999 */
	check_sigtramp2 (ecs);
	keep_going (ecs);
a2374 1
      }
d2376 25
a2400 4
    /* Handle cases caused by hitting a breakpoint.  */
    {
      CORE_ADDR jmp_buf_pc;
      struct bpstat_what what;
d2402 10
a2411 1
      what = bpstat_what (stop_bpstat);
d2413 3
a2415 1
      if (what.call_dummy)
d2417 14
a2430 5
	  stop_stack_dummy = 1;
#ifdef HP_OS_BUG
	  trap_expected_after_continue = 1;
#endif
	}
d2432 9
a2440 11
      switch (what.main_action)
	{
	case BPSTAT_WHAT_SET_LONGJMP_RESUME:
	  /* If we hit the breakpoint at longjmp, disable it for the
	     duration of this command.  Then, install a temporary
	     breakpoint at the target of the jmp_buf. */
	  disable_longjmp_breakpoint ();
	  remove_breakpoints ();
	  breakpoints_inserted = 0;
	  if (!GET_LONGJMP_TARGET_P ()
	      || !GET_LONGJMP_TARGET (&jmp_buf_pc))
d2442 1
a2442 1
	      keep_going (ecs);
d2446 12
a2457 3
	  /* Need to blow away step-resume breakpoint, as it
	     interferes with us */
	  if (step_resume_breakpoint != NULL)
d2459 21
a2479 1
	      delete_step_resume_breakpoint (&step_resume_breakpoint);
a2480 13
	  /* Not sure whether we need to blow this away too, but probably
	     it is like the step-resume breakpoint.  */
	  if (through_sigtramp_breakpoint != NULL)
	    {
	      delete_breakpoint (through_sigtramp_breakpoint);
	      through_sigtramp_breakpoint = NULL;
	    }

#if 0
	  /* FIXME - Need to implement nested temporary breakpoints */
	  if (step_over_calls > 0)
	    set_longjmp_resume_breakpoint (jmp_buf_pc,
					   get_current_frame ());
a2481 15
#endif /* 0 */
	    set_longjmp_resume_breakpoint (jmp_buf_pc, NULL);
	  ecs->handling_longjmp = 1;	/* FIXME */
	  keep_going (ecs);
	  return;

	case BPSTAT_WHAT_CLEAR_LONGJMP_RESUME:
	case BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE:
	  remove_breakpoints ();
	  breakpoints_inserted = 0;
#if 0
	  /* FIXME - Need to implement nested temporary breakpoints */
	  if (step_over_calls
	      && (INNER_THAN (FRAME_FP (get_current_frame ()),
			      step_frame_address)))
d2483 1
d2485 1
a2485 2
	      keep_going (ecs);
	      return;
d2487 3
a2489 17
#endif /* 0 */
	  disable_longjmp_breakpoint ();
	  ecs->handling_longjmp = 0;	/* FIXME */
	  if (what.main_action == BPSTAT_WHAT_CLEAR_LONGJMP_RESUME)
	    break;
	  /* else fallthrough */

	case BPSTAT_WHAT_SINGLE:
	  if (breakpoints_inserted)
	    {
	      remove_breakpoints ();
	    }
	  breakpoints_inserted = 0;
	  ecs->another_trap = 1;
	  /* Still need to check other stuff, at least the case
	     where we are stepping and step out of the right range.  */
	  break;
d2491 2
a2492 2
	case BPSTAT_WHAT_STOP_NOISY:
	  stop_print_frame = 1;
d2494 4
a2497 3
	  /* We are about to nuke the step_resume_breakpoint and
	     through_sigtramp_breakpoint via the cleanup chain, so
	     no need to worry about it here.  */
d2499 17
a2515 1
	  stop_stepping (ecs);
d2517 12
d2530 15
a2544 1
	case BPSTAT_WHAT_STOP_SILENT:
d2546 4
a2549 5

	  /* We are about to nuke the step_resume_breakpoint and
	     through_sigtramp_breakpoint via the cleanup chain, so
	     no need to worry about it here.  */

d2552 2
d2555 11
a2565 17
	case BPSTAT_WHAT_STEP_RESUME:
	  /* This proably demands a more elegant solution, but, yeah
	     right...

	     This function's use of the simple variable
	     step_resume_breakpoint doesn't seem to accomodate
	     simultaneously active step-resume bp's, although the
	     breakpoint list certainly can.

	     If we reach here and step_resume_breakpoint is already
	     NULL, then apparently we have multiple active
	     step-resume bp's.  We'll just delete the breakpoint we
	     stopped at, and carry on.  

	     Correction: what the code currently does is delete a
	     step-resume bp, but it makes no effort to ensure that
	     the one deleted is the one currently stopped at.  MVS  */
d2567 9
a2575 7
	  if (step_resume_breakpoint == NULL)
	    {
	      step_resume_breakpoint =
		bpstat_find_step_resume_breakpoint (stop_bpstat);
	    }
	  delete_step_resume_breakpoint (&step_resume_breakpoint);
	  break;
d2577 1
a2577 4
	case BPSTAT_WHAT_THROUGH_SIGTRAMP:
	  if (through_sigtramp_breakpoint)
	    delete_breakpoint (through_sigtramp_breakpoint);
	  through_sigtramp_breakpoint = NULL;
d2579 11
a2589 5
	  /* If were waiting for a trap, hitting the step_resume_break
	     doesn't count as getting it.  */
	  if (trap_expected)
	    ecs->another_trap = 1;
	  break;
d2591 1
a2591 10
	case BPSTAT_WHAT_CHECK_SHLIBS:
	case BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK:
#ifdef SOLIB_ADD
	  {
	    /* Remove breakpoints, we eventually want to step over the
	       shlib event breakpoint, and SOLIB_ADD might adjust
	       breakpoint addresses via breakpoint_re_set.  */
	    if (breakpoints_inserted)
	      remove_breakpoints ();
	    breakpoints_inserted = 0;
d2593 8
a2600 7
	    /* Check for any newly added shared libraries if we're
	       supposed to be adding them automatically.  Switch
	       terminal for any messages produced by
	       breakpoint_re_set.  */
	    target_terminal_ours_for_output ();
	    SOLIB_ADD (NULL, 0, NULL, auto_solib_add);
	    target_terminal_inferior ();
d2602 14
a2615 56
	    /* Try to reenable shared library breakpoints, additional
	       code segments in shared libraries might be mapped in now. */
	    re_enable_breakpoints_in_shlibs ();

	    /* If requested, stop when the dynamic linker notifies
	       gdb of events.  This allows the user to get control
	       and place breakpoints in initializer routines for
	       dynamically loaded objects (among other things).  */
	    if (stop_on_solib_events)
	      {
		stop_stepping (ecs);
		return;
	      }

	    /* If we stopped due to an explicit catchpoint, then the
	       (see above) call to SOLIB_ADD pulled in any symbols
	       from a newly-loaded library, if appropriate.

	       We do want the inferior to stop, but not where it is
	       now, which is in the dynamic linker callback.  Rather,
	       we would like it stop in the user's program, just after
	       the call that caused this catchpoint to trigger.  That
	       gives the user a more useful vantage from which to
	       examine their program's state. */
	    else if (what.main_action == BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK)
	      {
		/* ??rehrauer: If I could figure out how to get the
		   right return PC from here, we could just set a temp
		   breakpoint and resume.  I'm not sure we can without
		   cracking open the dld's shared libraries and sniffing
		   their unwind tables and text/data ranges, and that's
		   not a terribly portable notion.

		   Until that time, we must step the inferior out of the
		   dld callback, and also out of the dld itself (and any
		   code or stubs in libdld.sl, such as "shl_load" and
		   friends) until we reach non-dld code.  At that point,
		   we can stop stepping. */
		bpstat_get_triggered_catchpoints (stop_bpstat,
				  &ecs->stepping_through_solib_catchpoints);
		ecs->stepping_through_solib_after_catch = 1;

		/* Be sure to lift all breakpoints, so the inferior does
		   actually step past this point... */
		ecs->another_trap = 1;
		break;
	      }
	    else
	      {
		/* We want to step over this breakpoint, then keep going.  */
		ecs->another_trap = 1;
		break;
	      }
	  }
#endif
	  break;
d2617 2
a2618 6
	case BPSTAT_WHAT_LAST:
	  /* Not a real code, but listed here to shut up gcc -Wall.  */

	case BPSTAT_WHAT_KEEP_CHECKING:
	  break;
	}
d2621 4
a2624 55
    /* We come here if we hit a breakpoint but should not
       stop for it.  Possibly we also were stepping
       and should stop for that.  So fall through and
       test for stepping.  But, if not stepping,
       do not stop.  */

    /* Are we stepping to get the inferior out of the dynamic
       linker's hook (and possibly the dld itself) after catching
       a shlib event? */
    if (ecs->stepping_through_solib_after_catch)
      {
#if defined(SOLIB_ADD)
	/* Have we reached our destination?  If not, keep going. */
	if (SOLIB_IN_DYNAMIC_LINKER (PIDGET (ecs->ptid), stop_pc))
	  {
	    ecs->another_trap = 1;
	    keep_going (ecs);
	    return;
	  }
#endif
	/* Else, stop and report the catchpoint(s) whose triggering
	   caused us to begin stepping. */
	ecs->stepping_through_solib_after_catch = 0;
	bpstat_clear (&stop_bpstat);
	stop_bpstat = bpstat_copy (ecs->stepping_through_solib_catchpoints);
	bpstat_clear (&ecs->stepping_through_solib_catchpoints);
	stop_print_frame = 1;
	stop_stepping (ecs);
	return;
      }

    if (!CALL_DUMMY_BREAKPOINT_OFFSET_P)
      {
	/* This is the old way of detecting the end of the stack dummy.
	   An architecture which defines CALL_DUMMY_BREAKPOINT_OFFSET gets
	   handled above.  As soon as we can test it on all of them, all
	   architectures should define it.  */

	/* If this is the breakpoint at the end of a stack dummy,
	   just stop silently, unless the user was doing an si/ni, in which
	   case she'd better know what she's doing.  */

	if (CALL_DUMMY_HAS_COMPLETED (stop_pc, read_sp (),
				      FRAME_FP (get_current_frame ()))
	    && !step_range_end)
	  {
	    stop_print_frame = 0;
	    stop_stack_dummy = 1;
#ifdef HP_OS_BUG
	    trap_expected_after_continue = 1;
#endif
	    stop_stepping (ecs);
	    return;
	  }
      }
d2626 7
a2632 23
    if (step_resume_breakpoint)
      {
	/* Having a step-resume breakpoint overrides anything
	   else having to do with stepping commands until
	   that breakpoint is reached.  */
	/* I'm not sure whether this needs to be check_sigtramp2 or
	   whether it could/should be keep_going.  */
	check_sigtramp2 (ecs);
	keep_going (ecs);
	return;
      }
    
    if (step_range_end == 0)
      {
	/* Likewise if we aren't even stepping.  */
	/* I'm not sure whether this needs to be check_sigtramp2 or
	   whether it could/should be keep_going.  */
	check_sigtramp2 (ecs);
	keep_going (ecs);
	return;
      }

    /* If stepping through a line, keep going if still within it.
d2634 6
a2639 12
       Note that step_range_end is the address of the first instruction
       beyond the step range, and NOT the address of the last instruction
       within it! */
    if (stop_pc >= step_range_start
	&& stop_pc < step_range_end)
      {
	/* We might be doing a BPSTAT_WHAT_SINGLE and getting a signal.
	   So definately need to check for sigtramp here.  */
	check_sigtramp2 (ecs);
	keep_going (ecs);
	return;
      }
a2640 1
    /* We stepped out of the stepping range.  */
a2641 5
    /* If we are stepping at the source level and entered the runtime
       loader dynamic symbol resolution code, we keep on single stepping
       until we exit the run time loader code and reach the callee's
       address.  */
    if (step_over_calls == STEP_OVER_UNDEBUGGABLE && IN_SOLIB_DYNSYM_RESOLVE_CODE (stop_pc))
d2643 1
a2643 1
	CORE_ADDR pc_after_resolver = SKIP_SOLIB_RESOLVER (stop_pc);
d2645 1
a2645 1
	if (pc_after_resolver)
d2647 11
a2657 2
	    /* Set up a step-resume breakpoint at the address
	       indicated by SKIP_SOLIB_RESOLVER.  */
d2659 1
d2661 6
a2666 2
	    sr_sal.pc = pc_after_resolver;

d2673 4
d2678 17
a2694 2
	keep_going (ecs);
	return;
a2696 12
    /* We can't update step_sp every time through the loop, because
       reading the stack pointer would slow down stepping too much.
       But we can update it every time we leave the step range.  */
    ecs->update_step_sp = 1;

    /* Did we just take a signal?  */
    if (PC_IN_SIGTRAMP (stop_pc, ecs->stop_func_name)
	&& !PC_IN_SIGTRAMP (prev_pc, prev_func_name)
	&& INNER_THAN (read_sp (), step_sp))
      {
	/* We've just taken a signal; go until we are back to
	   the point where we took it and one more.  */
d2698 12
a2709 6
	/* Note: The test above succeeds not only when we stepped
	   into a signal handler, but also when we step past the last
	   statement of a signal handler and end up in the return stub
	   of the signal handler trampoline.  To distinguish between
	   these two cases, check that the frame is INNER_THAN the
	   previous one below. pai/1997-09-11 */
d2711 23
d2735 1
d2737 14
a2750 1
	  CORE_ADDR current_frame = FRAME_FP (get_current_frame ());
d2752 17
a2768 1
	  if (INNER_THAN (current_frame, step_frame_address))
d2770 6
a2775 20
	      /* We have just taken a signal; go until we are back to
	         the point where we took it and one more.  */

	      /* This code is needed at least in the following case:
	         The user types "next" and then a signal arrives (before
	         the "next" is done).  */

	      /* Note that if we are stopped at a breakpoint, then we need
	         the step_resume breakpoint to override any breakpoints at
	         the same location, so that we will still step over the
	         breakpoint even though the signal happened.  */
	      struct symtab_and_line sr_sal;

	      INIT_SAL (&sr_sal);
	      sr_sal.symtab = NULL;
	      sr_sal.line = 0;
	      sr_sal.pc = prev_pc;
	      /* We could probably be setting the frame to
	         step_frame_address; I don't think anyone thought to
	         try it.  */
d2778 4
a2781 25
		set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
	      if (breakpoints_inserted)
		insert_breakpoints ();
	    }
	  else
	    {
	      /* We just stepped out of a signal handler and into
	         its calling trampoline.

	         Normally, we'd call step_over_function from
	         here, but for some reason GDB can't unwind the
	         stack correctly to find the real PC for the point
	         user code where the signal trampoline will return
	         -- FRAME_SAVED_PC fails, at least on HP-UX 10.20.
	         But signal trampolines are pretty small stubs of
	         code, anyway, so it's OK instead to just
	         single-step out.  Note: assuming such trampolines
	         don't exhibit recursion on any platform... */
	      find_pc_partial_function (stop_pc, &ecs->stop_func_name,
					&ecs->stop_func_start,
					&ecs->stop_func_end);
	      /* Readjust stepping range */
	      step_range_start = ecs->stop_func_start;
	      step_range_end = ecs->stop_func_end;
	      ecs->stepping_through_sigtramp = 1;
d2785 2
d2788 3
a2790 18
	/* If this is stepi or nexti, make sure that the stepping range
	   gets us past that instruction.  */
	if (step_range_end == 1)
	  /* FIXME: Does this run afoul of the code below which, if
	     we step into the middle of a line, resets the stepping
	     range?  */
	  step_range_end = (step_range_start = prev_pc) + 1;

	ecs->remove_breakpoints_on_following_step = 1;
	keep_going (ecs);
	return;
      }

    if (stop_pc == ecs->stop_func_start		/* Quick test */
	|| (in_prologue (stop_pc, ecs->stop_func_start) &&
	    !IN_SOLIB_RETURN_TRAMPOLINE (stop_pc, ecs->stop_func_name))
	|| IN_SOLIB_CALL_TRAMPOLINE (stop_pc, ecs->stop_func_name)
	|| ecs->stop_func_name == 0)
d2792 1
a2792 1
	/* It's a subroutine call.  */
d2794 2
a2795 3
	if ((step_over_calls == STEP_OVER_NONE)
	    || ((step_range_end == 1)
	        && in_prologue (prev_pc, ecs->stop_func_start)))
d2797 1
a2797 9
	    /* I presume that step_over_calls is only 0 when we're
	       supposed to be stepping at the assembly language level
	       ("stepi").  Just stop.  */
	    /* Also, maybe we just did a "nexti" inside a prolog,
               so we thought it was a subroutine call but it was not.
               Stop as well.  FENN */
	    stop_step = 1;
	    print_stop_reason (END_STEPPING_RANGE, 0);
	    stop_stepping (ecs);
d2800 1
d2802 4
a2805 56
	if (step_over_calls == STEP_OVER_ALL || IGNORE_HELPER_CALL (stop_pc))
	  {
	    /* We're doing a "next".  */

	    if (PC_IN_SIGTRAMP (stop_pc, ecs->stop_func_name)
		&& INNER_THAN (step_frame_address, read_sp()))
	      /* We stepped out of a signal handler, and into its
                 calling trampoline.  This is misdetected as a
                 subroutine call, but stepping over the signal
                 trampoline isn't such a bad idea.  In order to do
                 that, we have to ignore the value in
                 step_frame_address, since that doesn't represent the
                 frame that'll reach when we return from the signal
                 trampoline.  Otherwise we'll probably continue to the
                 end of the program.  */
	      step_frame_address = 0;

	    step_over_function (ecs);
	    keep_going (ecs);
	    return;
	  }

	/* If we are in a function call trampoline (a stub between
	   the calling routine and the real function), locate the real
	   function.  That's what tells us (a) whether we want to step
	   into it at all, and (b) what prologue we want to run to
	   the end of, if we do step into it.  */
	tmp = SKIP_TRAMPOLINE_CODE (stop_pc);
	if (tmp != 0)
	  ecs->stop_func_start = tmp;
	else
	  {
	    tmp = DYNAMIC_TRAMPOLINE_NEXTPC (stop_pc);
	    if (tmp)
	      {
		struct symtab_and_line xxx;
		/* Why isn't this s_a_l called "sr_sal", like all of the
		   other s_a_l's where this code is duplicated?  */
		INIT_SAL (&xxx);	/* initialize to zeroes */
		xxx.pc = tmp;
		xxx.section = find_pc_overlay (xxx.pc);
		check_for_old_step_resume_breakpoint ();
		step_resume_breakpoint =
		  set_momentary_breakpoint (xxx, NULL, bp_step_resume);
		insert_breakpoints ();
		keep_going (ecs);
		return;
	      }
	  }

	/* If we have line number information for the function we
	   are thinking of stepping into, step into it.

	   If there are several symtabs at that PC (e.g. with include
	   files), just want to know whether *any* of them have line
	   numbers.  find_pc_line handles this.  */
d2807 4
a2810 8
	  struct symtab_and_line tmp_sal;

	  tmp_sal = find_pc_line (ecs->stop_func_start, 0);
	  if (tmp_sal.line != 0)
	    {
	      step_into_function (ecs);	
	      return;
	    }
d2813 3
a2815 10
	/* If we have no line number and the step-stop-if-no-debug
	   is set, we stop the step so that the user has a chance to
	   switch in assembly mode.  */
	if (step_over_calls == STEP_OVER_UNDEBUGGABLE && step_stop_if_no_debug)
	  {
	    stop_step = 1;
	    print_stop_reason (END_STEPPING_RANGE, 0);
	    stop_stepping (ecs);
	    return;
	  }
d2817 1
a2817 3
	step_over_function (ecs);
	keep_going (ecs);
	return;
d2819 1
a2819 1
      }
d2821 1
a2821 1
    /* We've wandered out of the step range.  */
d2823 9
a2831 1
    ecs->sal = find_pc_line (stop_pc, 0);
d2833 5
a2837 9
    if (step_range_end == 1)
      {
	/* It is stepi or nexti.  We always want to stop stepping after
	   one instruction.  */
	stop_step = 1;
	print_stop_reason (END_STEPPING_RANGE, 0);
	stop_stepping (ecs);
	return;
      }
d2839 2
a2840 5
    /* If we're in the return path from a shared library trampoline,
       we want to proceed through the trampoline when stepping.  */
    if (IN_SOLIB_RETURN_TRAMPOLINE (stop_pc, ecs->stop_func_name))
      {
	CORE_ADDR tmp;
d2842 5
a2846 2
	/* Determine where this trampoline returns.  */
	tmp = SKIP_TRAMPOLINE_CODE (stop_pc);
d2848 11
a2858 5
	/* Only proceed through if we know where it's going.  */
	if (tmp)
	  {
	    /* And put the step-breakpoint there and go until there. */
	    struct symtab_and_line sr_sal;
d2860 6
a2865 11
	    INIT_SAL (&sr_sal);	/* initialize to zeroes */
	    sr_sal.pc = tmp;
	    sr_sal.section = find_pc_overlay (sr_sal.pc);
	    /* Do not specify what the fp should be when we stop
	       since on some machines the prologue
	       is where the new fp value is established.  */
	    check_for_old_step_resume_breakpoint ();
	    step_resume_breakpoint =
	      set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
	    if (breakpoints_inserted)
	      insert_breakpoints ();
d2867 11
a2877 6
	    /* Restart without fiddling with the step ranges or
	       other state.  */
	    keep_going (ecs);
	    return;
	  }
      }
d2879 13
a2891 11
    if (ecs->sal.line == 0)
      {
	/* We have no line number information.  That means to stop
	   stepping (does this always happen right after one instruction,
	   when we do "s" in a function with no line numbers,
	   or can this happen as a result of a return or longjmp?).  */
	stop_step = 1;
	print_stop_reason (END_STEPPING_RANGE, 0);
	stop_stepping (ecs);
	return;
      }
d2893 1
a2893 12
    if ((stop_pc == ecs->sal.pc)
	&& (ecs->current_line != ecs->sal.line || ecs->current_symtab != ecs->sal.symtab))
      {
	/* We are at the start of a different line.  So stop.  Note that
	   we don't stop if we step into the middle of a different line.
	   That is said to make things like for (;;) statements work
	   better.  */
	stop_step = 1;
	print_stop_reason (END_STEPPING_RANGE, 0);
	stop_stepping (ecs);
	return;
      }
d2895 22
a2916 1
    /* We aren't done stepping.
d2918 8
a2925 4
       Optimize by setting the stepping range to the line.
       (We might not be in the original line, but if we entered a
       new line in mid-statement, we continue stepping.  This makes
       things like for(;;) statements work better.)  */
d2927 1
a2927 28
    if (ecs->stop_func_end && ecs->sal.end >= ecs->stop_func_end)
      {
	/* If this is the last line of the function, don't keep stepping
	   (it would probably step us out of the function).
	   This is particularly necessary for a one-line function,
	   in which after skipping the prologue we better stop even though
	   we will be in mid-line.  */
	stop_step = 1;
	print_stop_reason (END_STEPPING_RANGE, 0);
	stop_stepping (ecs);
	return;
      }
    step_range_start = ecs->sal.pc;
    step_range_end = ecs->sal.end;
    step_frame_address = FRAME_FP (get_current_frame ());
    ecs->current_line = ecs->sal.line;
    ecs->current_symtab = ecs->sal.symtab;

    /* In the case where we just stepped out of a function into the middle
       of a line of the caller, continue stepping, but step_frame_address
       must be modified to current frame */
    {
      CORE_ADDR current_frame = FRAME_FP (get_current_frame ());
      if (!(INNER_THAN (current_frame, step_frame_address)))
	step_frame_address = current_frame;
    }

    keep_going (ecs);
d2952 2
a2953 2
	 inferior with a signal (because it is a signal which
	 shouldn't make us stop), thus stepping into sigtramp.
d2955 6
a2960 6
	 So we need to set a step_resume_break_address breakpoint and
	 continue until we hit it, and then step.  FIXME: This should
	 be more enduring than a step_resume breakpoint; we should
	 know that we will later need to keep going rather than
	 re-hitting the breakpoint here (see the testsuite,
	 gdb.base/signals.exp where it says "exceedingly difficult").  */
d2968 1
a2968 1
	 frame corresponding to prev_pc was.  But we don't, so don't.  */
d3013 1
a3013 1
	print_stop_reason (END_STEPPING_RANGE, 0);
d3024 2
a3025 2
	 some machines the prologue is where the new fp value is
	 established.  */
d3055 1
a3055 1
  INIT_SAL (&sr_sal);	/* initialize to zeros */
d3096 1
a3096 1
	  while (! ptid_equal (parent_ptid, inferior_ptid));
d3129 1
a3129 1
  prev_pc = read_pc ();	/* Might have been DECR_AFTER_BREAK */
d3147 2
a3148 2
	 the inferior, else we'd have done a break above) and we
	 haven't yet gotten our trap.  Simply continue.  */
d3154 5
a3158 5
	 anyway (the user asked that this signal be passed to the
	 child)
	 -- or --
	 The signal was SIGTRAP, e.g. it was our signal, but we
	 decided we should resume from it.
d3160 1
a3160 1
	 We're going to run this baby now!
d3162 2
a3163 2
	 Insert breakpoints now, unless we are trying to one-proceed
	 past a breakpoint.  */
d3165 1
a3165 1
	 want to hit a breakpoint, pull em out.  */
d3189 2
a3190 2
	 specifies that such a signal should be delivered to the
	 target program).
d3192 7
a3198 7
	 Typically, this would occure when a user is debugging a
	 target monitor on a simulator: the target monitor sets a
	 breakpoint; the simulator encounters this break-point and
	 halts the simulation handing control to GDB; GDB, noteing
	 that the break-point isn't valid, returns control back to the
	 simulator; the simulator then delivers the hardware
	 equivalent of a SIGNAL_TRAP to the program being debugged. */
d3200 1
a3200 2
      if (stop_signal == TARGET_SIGNAL_TRAP
	  && !signal_program[stop_signal])
d3205 2
a3206 2
	 now, that we shouldn't rewrite the regs when we were stopped
	 by a random signal from the inferior process.  */
d3208 1
a3208 1
	 (this is only used on the 88k).  */
d3211 1
a3211 2
	  && (stop_signal != TARGET_SIGNAL_CHLD)
	  && !stopped_by_random_signal)
d3218 1
a3218 1
    prepare_to_wait (ecs);
d3233 4
a3236 4
	 target_wait because they can be loaded from the target while
	 in target_wait.  This makes remote debugging a bit more
	 efficient for those targets that provide critical registers
	 as part of their normal status mechanism. */
d3266 1
a3266 1
	 operation for n > 1 */
d3282 2
a3283 1
      ui_out_field_string (uiout, "signal-name", target_signal_to_name (stop_info));
d3287 2
a3288 1
      ui_out_field_string (uiout, "signal-meaning", target_signal_to_string (stop_info));
d3301 2
a3302 1
	  ui_out_field_fmt (uiout, "exit-code", "0%o", (unsigned int) stop_info);
d3320 2
a3321 1
      ui_out_field_string (uiout, "signal-name", target_signal_to_name (stop_info));
d3325 2
a3326 1
      ui_out_field_string (uiout, "signal-meaning", target_signal_to_string (stop_info));
d3355 1
a3355 1
  if (! ptid_equal (previous_inferior_ptid, inferior_ptid)
d3438 1
a3438 2
      if (stop_print_frame
	  && selected_frame)
d3451 1
a3451 1
		source_flag = SRC_LINE;   /* finished step, just print source line */
d3453 1
a3453 1
		source_flag = SRC_AND_LOC;    /* print location and source line */
d3456 1
a3456 1
	      source_flag = SRC_AND_LOC;    /* print location and source line */
d3462 1
a3462 1
	      source_flag = SRC_LINE; /* something bogus */
d3466 1
a3466 2
	      internal_error (__FILE__, __LINE__,
			      "Unknown value.");
d3469 1
a3469 1
             print everything but the source line. */
d3475 1
a3475 1
	                      pid_to_thread_id (inferior_ptid));
d3538 2
a3539 1
int signal_stop_update (signo, state)
d3548 2
a3549 1
int signal_print_update (signo, state)
d3558 2
a3559 1
int signal_pass_update (signo, state)
d3585 1
a3585 2
  printf_filtered ("%*.*s ", name_padding, name_padding,
		   "                 ");
d3731 1
a3731 3
Are you sure you want to change it? ",
			     target_signal_to_name
			     ((enum target_signal) signum)))
d3875 1
a3875 2
	  && oursig != TARGET_SIGNAL_DEFAULT
	  && oursig != TARGET_SIGNAL_0)
d3965 1
a3965 1
  struct frame_id *fid =  (struct frame_id *) args;
d4026 4
a4029 3
      if (catch_errors (restore_selected_frame, &inf_status->selected_frame_id,
			"Unable to restore previously selected frame:\n",
			RETURN_MASK_ERROR) == 0)
d4066 1
a4066 1
   
d4116 1
a4116 1
          && ptid1.tid == ptid2.tid);
d4144 1
a4145 1

d4174 1
a4174 2
used by the debugger, typically SIGTRAP and SIGINT.\n",
		   "Recognized actions include \"stop\", \"nostop\", \"print\", \"noprint\",\n\
d4193 1
a4193 2
used by the debugger, typically SIGTRAP and SIGINT.\n",
		       "Recognized actions include \"s\" (toggles between stop and nostop), \n\
d4204 2
a4205 2
    stop_command = add_cmd ("stop", class_obscure, not_just_help_class_command,
			    "There is no `stop' command, but you can set a hook on `stop'.\n\
d4210 1
a4210 2
  signal_stop = (unsigned char *)
    xmalloc (sizeof (signal_stop[0]) * numsigs);
d4263 1
a4263 3
to the user would be loading/unloading of a new library.\n",
		  &setlist),
     &showlist);
d4268 1
a4268 2
			follow_fork_mode_kind_names,
			&follow_fork_mode_string,
d4294 1
a4294 2
By default, the debugger will follow the parent process.",
			&setlist);
d4297 1
a4297 2
  c = add_set_enum_cmd ("scheduler-locking", class_run,
			scheduler_enums,	/* array of string names */
d4304 1
a4304 2
	Other threads may run while stepping over a function call ('next').",
			&setlist);
d4310 2
a4311 2
		   var_boolean, (char*) &step_stop_if_no_debug,
"Set mode of the step operation. When set, doing a step over a\n\
d4314 1
a4314 2
the step command stops at a different source line.",
			&setlist);
@


1.61
log
@* infrun.c (stop_registers): Change variable's type to ``struct
regcache'''.
(xmalloc_inferior_status): Delete function.
(free_inferior_status): Delete function.
(normal_stop): Use regcache_cpy.
(struct inferior_status): Change type of fields ``stop_registers''
and ``registers'' to ``struct regcache''.
(write_inferior_status_register): Use regcache_write.
(save_inferior_status): Instead of calling
xmalloc_inferior_status, allocate the inf_status buffer directly.
Use regcache_dup_no_passthrough and regcache_dup to save the
buffers.
(restore_inferior_status): Use regcache_xfree and regcache_cpy.
Replace the stop_registers regcache instead of overriding it.  Use
regcache_xfree.  Instead of calling free_inferior_status, xfree
the buffer directly.
(discard_inferior_status): Use regcache_xfree.  Instead of calling
free_inferior_status, xfree the buffer directly.
(build_infrun): Use regcache_xmalloc.
(_initialize_infrun): Delete redundant call to build_infrun.
* Makefile.in (infcmd.o): Add $(regcache_h).
* infcmd.c: Include "regcache.h".
(run_stack_dummy): Use deprecated_grub_regcache_for_registers to
obtain the address of `stop_registers' register buffer.
(print_return_value): Ditto.
* inferior.h (struct regcache): Add opaque declaration.
(stop_registers): Change variable's declared type to ``struct
regcache''.
@
text
@a1420 2
  /* Keep this extra brace for now, minimizes diffs.  */
  {
a2936 2

  } /* extra brace, to preserve old indentation */
@


1.60
log
@* infrun.c (_initialize_infrun): Delete unnecessary call to
build_infrun.
@
text
@a64 4
static struct inferior_status *xmalloc_inferior_status (void);

static void free_inferior_status (struct inferior_status *);

d340 1
a340 1
char *stop_registers;
d3504 3
a3506 1
    read_register_bytes (0, stop_registers, REGISTER_BYTES);
d3911 1
a3911 1
  char *stop_registers;
d3916 1
a3916 1
  char *registers;
a3925 18
static struct inferior_status *
xmalloc_inferior_status (void)
{
  struct inferior_status *inf_status;
  inf_status = xmalloc (sizeof (struct inferior_status));
  inf_status->stop_registers = xmalloc (REGISTER_BYTES);
  inf_status->registers = xmalloc (REGISTER_BYTES);
  return inf_status;
}

static void
free_inferior_status (struct inferior_status *inf_status)
{
  xfree (inf_status->registers);
  xfree (inf_status->stop_registers);
  xfree (inf_status);
}

d3933 1
a3933 1
  memcpy (&inf_status->registers[REGISTER_BYTE (regno)], buf, size);
d3943 1
a3943 1
  struct inferior_status *inf_status = xmalloc_inferior_status ();
d3967 1
a3967 1
  memcpy (inf_status->stop_registers, stop_registers, REGISTER_BYTES);
d3969 1
a3969 1
  read_register_bytes (0, inf_status->registers, REGISTER_BYTES);
d4016 3
a4018 2
  /* FIXME: Is the restore of stop_registers always needed */
  memcpy (stop_registers, inf_status->stop_registers, REGISTER_BYTES);
d4023 3
a4025 1
    write_register_bytes (0, inf_status->registers, REGISTER_BYTES);
d4048 1
a4048 1
  free_inferior_status (inf_status);
d4068 3
a4070 1
  free_inferior_status (inf_status);
d4161 1
a4161 1
  stop_registers = xmalloc (REGISTER_BYTES);
@


1.59
log
@* infrun.c (struct inferior_status): Replace fields
selected_frame_address and selected_level with field
selected_frame_id.
(save_inferior_status): Update.  Use get_frame_id.
(struct restore_selected_frame_args): Delete.
(restore_selected_frame): Update.  Use frame_find_by_id.
(restore_inferior_status): Update.

* breakpoint.h (struct breakpoint): Change type of
watchpoint_frame to frame_id.
* breakpoint.c (insert_breakpoints): Use frame_find_by_id.  Remove
call to get_current_frame.
(do_enable_breakpoint): Use frame_find_by_id.  Remove call to
get_current_frame.
(watchpoint_check): Use frame_find_by_id.

* frame.h (record_selected_frame): Delete declaration.
* stack.c (record_selected_frame): Delete function.

* frame.h (struct frame_id): Define.
(get_frame_id): Declare.
(frame_find_by_id): Declare.
* frame.c (frame_find_by_id): New function.
(get_frame_id): New function.
@
text
@a4185 2
  build_infrun ();

@


1.58
log
@* frame.h (select_frame): Delete level parameter.
* stack.c (select_frame): Update.  Use frame_relative_level to
obtain the frame's level.
(select_and_print_frame): Update call.
(select_frame_command): Ditto.
(up_silently_base): Ditto.
(down_silently_base): Ditto.
* ocd.c (ocd_start_remote): Ditto.
* remote-rdp.c (remote_rdp_open): Ditto.
* remote-mips.c (mips_initialize): Ditto.
(common_open): Ditto.
* remote-e7000.c (e7000_start_remote): Ditto.
* m3-nat.c (select_thread): Ditto.
* hppa-tdep.c (child_get_current_exception_event): Ditto.
(child_get_current_exception_event): Ditto.
* varobj.c (varobj_create): Ditto.
(varobj_update): Ditto.
(c_value_of_root): Ditto.
* tracepoint.c (finish_tfind_command): Ditto.
* corelow.c (core_open): Ditto.
* arch-utils.c (generic_prepare_to_proceed): Ditto.
* thread.c (info_threads_command): Ditto.
(switch_to_thread): Ditto.
* infrun.c (normal_stop): Ditto.
(restore_selected_frame): Ditto.
(restore_inferior_status): Ditto.
* breakpoint.c (insert_breakpoints): Ditto.
(watchpoint_check): Ditto.
(bpstat_stop_status): Ditto.
(do_enable_breakpoint): Ditto.
* blockframe.c (flush_cached_frames): Ditto.
(reinit_frame_cache): Ditto.
@
text
@a3912 1
  CORE_ADDR selected_frame_address;
d3920 3
a3922 1
  int selected_level;
d3991 1
a3991 2
  record_selected_frame (&(inf_status->selected_frame_address),
			 &(inf_status->selected_level));
a3994 6
struct restore_selected_frame_args
{
  CORE_ADDR frame_address;
  int level;
};

d3998 1
a3998 2
  struct restore_selected_frame_args *fr =
  (struct restore_selected_frame_args *) args;
a3999 1
  int level = fr->level;
d4001 1
a4001 1
  frame = find_relative_frame (get_current_frame (), &level);
d4005 1
a4005 9
  if (frame == NULL ||
  /*  FRAME_FP (frame) != fr->frame_address || */
  /* elz: deleted this check as a quick fix to the problem that
     for function called by hand gdb creates no internal frame
     structure and the real stack and gdb's idea of stack are
     different if nested calls by hands are made.

     mvs: this worries me.  */
      level != 0)
a4052 3
      struct restore_selected_frame_args fr;
      fr.level = inf_status->selected_level;
      fr.frame_address = inf_status->selected_frame_address;
d4054 3
a4056 3
         walking the stack might encounter a garbage pointer and error()
         trying to dereference it.  */
      if (catch_errors (restore_selected_frame, &fr,
a4060 2


@


1.58.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d3913 1
d3921 1
a3921 3
  /* A frame unique identifier.  */
  struct frame_id selected_frame_id;

d3990 2
a3991 1
  get_frame_id (selected_frame, &inf_status->selected_frame_id);
d3995 6
d4004 2
a4005 1
  struct frame_id *fid =  (struct frame_id *) args;
d4007 1
d4009 1
a4009 1
  frame = frame_find_by_id (*fid);
d4013 9
a4021 1
  if (frame == NULL)
d4069 3
d4073 3
a4075 3
         walking the stack might encounter a garbage pointer and
         error() trying to dereference it.  */
      if (catch_errors (restore_selected_frame, &inf_status->selected_frame_id,
d4080 2
@


1.58.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d63 5
a67 1
					  struct cmd_list_element *c);
d81 1
a81 1
				struct cmd_list_element *c);
d222 1
a222 1
#ifndef SKIP_PERMANENT_BREAKPOINT
d233 1
a233 1

d344 1
a344 1
struct regcache *stop_registers;
a375 3
{
  enum target_waitkind kind;
  struct
d377 11
a387 5
    int parent_pid;
    int saw_parent_fork;
    int child_pid;
    int saw_child_fork;
    int saw_child_exec;
a388 3
  fork_event;
  char *execd_pathname;
}
d411 2
a412 1
static const char *follow_fork_mode_kind_names[] = {
d519 2
a520 1
      if (step_resume_breakpoint && (!has_vforked || !follow_vfork_when_exec))
d584 3
a586 1
				followed_parent, child_pid, followed_child);
d637 1
a637 1
		    pending_follow.fork_event.child_pid);
d693 1
a693 1
  /* Because mourn_inferior resets inferior_ptid. */
d741 2
a742 1
static const char *scheduler_enums[] = {
d764 2
a765 1
	error ("Target '%s' cannot support this command.", target_shortname);
d798 1
a798 1

d830 1
a830 1
		   pending_follow.fork_event.child_pid);
d839 1
a839 1
		      pending_follow.fork_event.child_pid);
d869 1
a869 1
      resume_ptid = RESUME_ALL;	/* Default */
d883 1
a883 1
	  (scheduler_mode == schedlock_step &&
d887 1
a887 1
	  resume_ptid = inferior_ptid;
d892 2
a893 2
         normally.  But if this one cannot, just continue and we will hit
         it anyway.  */
d1164 26
a1189 26
{
  struct target_waitstatus ws;
  struct target_waitstatus *wp;
  int another_trap;
  int random_signal;
  CORE_ADDR stop_func_start;
  CORE_ADDR stop_func_end;
  char *stop_func_name;
  struct symtab_and_line sal;
  int remove_breakpoints_on_following_step;
  int current_line;
  struct symtab *current_symtab;
  int handling_longjmp;		/* FIXME */
  ptid_t ptid;
  ptid_t saved_inferior_ptid;
  int update_step_sp;
  int stepping_through_solib_after_catch;
  bpstat stepping_through_solib_catchpoints;
  int enable_hw_watchpoints_after_wait;
  int stepping_through_sigtramp;
  int new_thread_event;
  struct target_waitstatus tmpstatus;
  enum infwait_states infwait_state;
  ptid_t waiton_ptid;
  int wait_some_more;
};
d1191 1
a1191 1
void init_execution_control_state (struct execution_control_state *ecs);
d1193 1
a1193 1
void handle_inferior_event (struct execution_control_state *ecs);
d1201 1
a1201 2
static void print_stop_reason (enum inferior_stop_reason stop_reason,
			       int stop_info);
d1278 1
a1278 1
      old_cleanups = make_exec_cleanup (delete_step_resume_breakpoint,
d1301 1
a1301 2
    async_ecs->ptid =
      target_wait_hook (async_ecs->waiton_ptid, async_ecs->wp);
d1311 2
a1312 2
         function. Let the continuations for the commands do the rest,
         if there are any. */
d1353 1
a1353 2
    warning
      ("GDB bug: infrun.c (wait_for_inferior): dropping old step_resume breakpoint");
d1362 1
a1362 1
get_last_target_status (ptid_t *ptidp, struct target_waitstatus *status)
d1380 1
a1380 1
    {				/* Perform infrun state context switch: */
d1382 2
a1383 2
      save_infrun_state (inferior_ptid, prev_pc,
			 prev_func_start, prev_func_name,
d1385 2
a1386 2
			 through_sigtramp_breakpoint, step_range_start,
			 step_range_end, step_frame_address,
d1391 2
a1392 1
			 ecs->current_line, ecs->current_symtab, step_sp);
d1395 2
a1396 2
      load_infrun_state (ecs->ptid, &prev_pc,
			 &prev_func_start, &prev_func_name,
d1398 2
a1399 2
			 &through_sigtramp_breakpoint, &step_range_start,
			 &step_range_end, &step_frame_address,
d1403 3
a1405 2
			 &ecs->stepping_through_sigtramp,
			 &ecs->current_line, &ecs->current_symtab, &step_sp);
d1425 19
a1443 6
  switch (ecs->infwait_state)
    {
    case infwait_thread_hop_state:
      /* Cancel the waiton_ptid. */
      ecs->waiton_ptid = pid_to_ptid (-1);
      /* Fall thru to the normal_state case. */
d1445 2
a1446 10
    case infwait_normal_state:
      /* See comments where a TARGET_WAITKIND_SYSCALL_RETURN event
         is serviced in this loop, below. */
      if (ecs->enable_hw_watchpoints_after_wait)
	{
	  TARGET_ENABLE_HW_WATCHPOINTS (PIDGET (inferior_ptid));
	  ecs->enable_hw_watchpoints_after_wait = 0;
	}
      stepped_after_stopped_by_watchpoint = 0;
      break;
d1448 2
a1449 2
    case infwait_nullified_state:
      break;
d1451 7
a1457 10
    case infwait_nonstep_watch_state:
      insert_breakpoints ();

      /* FIXME-maybe: is this cleaner than setting a flag?  Does it
         handle things like signals arriving and other things happening
         in combination correctly?  */
      stepped_after_stopped_by_watchpoint = 1;
      break;
    }
  ecs->infwait_state = infwait_normal_state;
d1459 1
a1459 1
  flush_cached_frames ();
d1461 1
a1461 1
  /* If it's a new process, add it to the thread database */
d1463 2
a1464 2
  ecs->new_thread_event = (!ptid_equal (ecs->ptid, inferior_ptid)
			   && !in_thread_list (ecs->ptid));
d1466 5
a1470 4
  if (ecs->ws.kind != TARGET_WAITKIND_EXITED
      && ecs->ws.kind != TARGET_WAITKIND_SIGNALLED && ecs->new_thread_event)
    {
      add_thread (ecs->ptid);
d1472 3
a1474 3
      ui_out_text (uiout, "[New ");
      ui_out_text (uiout, target_pid_or_tid_to_str (ecs->ptid));
      ui_out_text (uiout, "]\n");
d1477 18
a1494 18
      /* NOTE: This block is ONLY meant to be invoked in case of a
         "thread creation event"!  If it is invoked for any other
         sort of event (such as a new thread landing on a breakpoint),
         the event will be discarded, which is almost certainly
         a bad thing!

         To avoid this, the low-level module (eg. target_wait)
         should call in_thread_list and add_thread, so that the
         new thread is known by the time we get here.  */

      /* We may want to consider not doing a resume here in order
         to give the user a chance to play with the new thread.
         It might be good to make that a user-settable option.  */

      /* At this point, all threads are stopped (happens
         automatically in either the OS or the native code).
         Therefore we need to continue all threads in order to
         make progress.  */
d1496 3
a1498 3
      target_resume (RESUME_ALL, 0, TARGET_SIGNAL_0);
      prepare_to_wait (ecs);
      return;
d1500 1
a1500 1
    }
d1502 6
a1507 6
  switch (ecs->ws.kind)
    {
    case TARGET_WAITKIND_LOADED:
      /* Ignore gracefully during startup of the inferior, as it
         might be the shell which has just loaded some objects,
         otherwise add the symbols for the newly loaded objects.  */
d1509 6
a1514 6
      if (!stop_soon_quietly)
	{
	  /* Remove breakpoints, SOLIB_ADD might adjust
	     breakpoint addresses via breakpoint_re_set.  */
	  if (breakpoints_inserted)
	    remove_breakpoints ();
d1516 7
a1522 7
	  /* Check for any newly added shared libraries if we're
	     supposed to be adding them automatically.  Switch
	     terminal for any messages produced by
	     breakpoint_re_set.  */
	  target_terminal_ours_for_output ();
	  SOLIB_ADD (NULL, 0, NULL, auto_solib_add);
	  target_terminal_inferior ();
d1524 4
a1527 4
	  /* Reinsert breakpoints and continue.  */
	  if (breakpoints_inserted)
	    insert_breakpoints ();
	}
d1529 8
a1536 3
      resume (0, TARGET_SIGNAL_0);
      prepare_to_wait (ecs);
      return;
d1538 15
a1552 4
    case TARGET_WAITKIND_SPURIOUS:
      resume (0, TARGET_SIGNAL_0);
      prepare_to_wait (ecs);
      return;
d1554 4
a1557 15
    case TARGET_WAITKIND_EXITED:
      target_terminal_ours ();	/* Must do this before mourn anyway */
      print_stop_reason (EXITED, ecs->ws.value.integer);

      /* Record the exit code in the convenience variable $_exitcode, so
         that the user can inspect this again later.  */
      set_internalvar (lookup_internalvar ("_exitcode"),
		       value_from_longest (builtin_type_int,
					   (LONGEST) ecs->ws.value.integer));
      gdb_flush (gdb_stdout);
      target_mourn_inferior ();
      singlestep_breakpoints_inserted_p = 0;	/*SOFTWARE_SINGLE_STEP_P() */
      stop_print_frame = 0;
      stop_stepping (ecs);
      return;
d1559 6
a1564 11
    case TARGET_WAITKIND_SIGNALLED:
      stop_print_frame = 0;
      stop_signal = ecs->ws.value.sig;
      target_terminal_ours ();	/* Must do this before mourn anyway */

      /* Note: By definition of TARGET_WAITKIND_SIGNALLED, we shouldn't
         reach here unless the inferior is dead.  However, for years
         target_kill() was called here, which hints that fatal signals aren't
         really fatal on some systems.  If that's true, then some changes
         may be needed. */
      target_mourn_inferior ();
d1566 4
a1569 4
      print_stop_reason (SIGNAL_EXITED, stop_signal);
      singlestep_breakpoints_inserted_p = 0;	/*SOFTWARE_SINGLE_STEP_P() */
      stop_stepping (ecs);
      return;
d1571 24
a1594 24
      /* The following are the only cases in which we keep going;
         the above cases end in a continue or goto. */
    case TARGET_WAITKIND_FORKED:
      stop_signal = TARGET_SIGNAL_TRAP;
      pending_follow.kind = ecs->ws.kind;

      /* Ignore fork events reported for the parent; we're only
         interested in reacting to forks of the child.  Note that
         we expect the child's fork event to be available if we
         waited for it now. */
      if (ptid_equal (inferior_ptid, ecs->ptid))
	{
	  pending_follow.fork_event.saw_parent_fork = 1;
	  pending_follow.fork_event.parent_pid = PIDGET (ecs->ptid);
	  pending_follow.fork_event.child_pid = ecs->ws.value.related_pid;
	  prepare_to_wait (ecs);
	  return;
	}
      else
	{
	  pending_follow.fork_event.saw_child_fork = 1;
	  pending_follow.fork_event.child_pid = PIDGET (ecs->ptid);
	  pending_follow.fork_event.parent_pid = ecs->ws.value.related_pid;
	}
d1596 41
a1636 41
      stop_pc = read_pc_pid (ecs->ptid);
      ecs->saved_inferior_ptid = inferior_ptid;
      inferior_ptid = ecs->ptid;
      /* The second argument of bpstat_stop_status is meant to help
         distinguish between a breakpoint trap and a singlestep trap.
         This is only important on targets where DECR_PC_AFTER_BREAK
         is non-zero.  The prev_pc test is meant to distinguish between
         singlestepping a trap instruction, and singlestepping thru a
         jump to the instruction following a trap instruction. */

      stop_bpstat = bpstat_stop_status (&stop_pc,
					currently_stepping (ecs) &&
					prev_pc !=
					stop_pc - DECR_PC_AFTER_BREAK);
      ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
      inferior_ptid = ecs->saved_inferior_ptid;
      goto process_event_stop_test;

      /* If this a platform which doesn't allow a debugger to touch a
         vfork'd inferior until after it exec's, then we'd best keep
         our fingers entirely off the inferior, other than continuing
         it.  This has the unfortunate side-effect that catchpoints
         of vforks will be ignored.  But since the platform doesn't
         allow the inferior be touched at vfork time, there's really
         little choice. */
    case TARGET_WAITKIND_VFORKED:
      stop_signal = TARGET_SIGNAL_TRAP;
      pending_follow.kind = ecs->ws.kind;

      /* Is this a vfork of the parent?  If so, then give any
         vfork catchpoints a chance to trigger now.  (It's
         dangerous to do so if the child canot be touched until
         it execs, and the child has not yet exec'd.  We probably
         should warn the user to that effect when the catchpoint
         triggers...) */
      if (ptid_equal (ecs->ptid, inferior_ptid))
	{
	  pending_follow.fork_event.saw_parent_fork = 1;
	  pending_follow.fork_event.parent_pid = PIDGET (ecs->ptid);
	  pending_follow.fork_event.child_pid = ecs->ws.value.related_pid;
	}
d1638 18
a1655 19
      /* If we've seen the child's vfork event but cannot really touch
         the child until it execs, then we must continue the child now.
         Else, give any vfork catchpoints a chance to trigger now. */
      else
	{
	  pending_follow.fork_event.saw_child_fork = 1;
	  pending_follow.fork_event.child_pid = PIDGET (ecs->ptid);
	  pending_follow.fork_event.parent_pid = ecs->ws.value.related_pid;
	  target_post_startup_inferior (pid_to_ptid
					(pending_follow.fork_event.
					 child_pid));
	  follow_vfork_when_exec = !target_can_follow_vfork_prior_to_exec ();
	  if (follow_vfork_when_exec)
	    {
	      target_resume (ecs->ptid, 0, TARGET_SIGNAL_0);
	      prepare_to_wait (ecs);
	      return;
	    }
	}
d1657 33
a1689 34
      stop_pc = read_pc ();
      /* The second argument of bpstat_stop_status is meant to help
         distinguish between a breakpoint trap and a singlestep trap.
         This is only important on targets where DECR_PC_AFTER_BREAK
         is non-zero.  The prev_pc test is meant to distinguish between
         singlestepping a trap instruction, and singlestepping thru a
         jump to the instruction following a trap instruction. */

      stop_bpstat = bpstat_stop_status (&stop_pc,
					currently_stepping (ecs) &&
					prev_pc !=
					stop_pc - DECR_PC_AFTER_BREAK);
      ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
      goto process_event_stop_test;

    case TARGET_WAITKIND_EXECD:
      stop_signal = TARGET_SIGNAL_TRAP;

      /* Is this a target which reports multiple exec events per actual
         call to exec()?  (HP-UX using ptrace does, for example.)  If so,
         ignore all but the last one.  Just resume the exec'r, and wait
         for the next exec event. */
      if (inferior_ignoring_leading_exec_events)
	{
	  inferior_ignoring_leading_exec_events--;
	  if (pending_follow.kind == TARGET_WAITKIND_VFORKED)
	    ENSURE_VFORKING_PARENT_REMAINS_STOPPED (pending_follow.fork_event.
						    parent_pid);
	  target_resume (ecs->ptid, 0, TARGET_SIGNAL_0);
	  prepare_to_wait (ecs);
	  return;
	}
      inferior_ignoring_leading_exec_events =
	target_reported_exec_events_per_exec_call () - 1;
d1691 23
a1713 23
      pending_follow.execd_pathname =
	savestring (ecs->ws.value.execd_pathname,
		    strlen (ecs->ws.value.execd_pathname));

      /* Did inferior_ptid exec, or did a (possibly not-yet-followed)
         child of a vfork exec?

         ??rehrauer: This is unabashedly an HP-UX specific thing.  On
         HP-UX, events associated with a vforking inferior come in
         threes: a vfork event for the child (always first), followed
         a vfork event for the parent and an exec event for the child.
         The latter two can come in either order.

         If we get the parent vfork event first, life's good: We follow
         either the parent or child, and then the child's exec event is
         a "don't care".

         But if we get the child's exec event first, then we delay
         responding to it until we handle the parent's vfork.  Because,
         otherwise we can't satisfy a "catch vfork". */
      if (pending_follow.kind == TARGET_WAITKIND_VFORKED)
	{
	  pending_follow.fork_event.saw_child_exec = 1;
d1715 9
a1723 9
	  /* On some targets, the child must be resumed before
	     the parent vfork event is delivered.  A single-step
	     suffices. */
	  if (RESUME_EXECD_VFORKING_CHILD_TO_GET_PARENT_VFORK ())
	    target_resume (ecs->ptid, 1, TARGET_SIGNAL_0);
	  /* We expect the parent vfork event to be available now. */
	  prepare_to_wait (ecs);
	  return;
	}
d1725 49
a1773 4
      /* This causes the eventpoints and symbol table to be reset.  Must
         do this now, before trying to determine whether to stop. */
      follow_exec (PIDGET (inferior_ptid), pending_follow.execd_pathname);
      xfree (pending_follow.execd_pathname);
d1775 16
a1790 44
      stop_pc = read_pc_pid (ecs->ptid);
      ecs->saved_inferior_ptid = inferior_ptid;
      inferior_ptid = ecs->ptid;
      /* The second argument of bpstat_stop_status is meant to help
         distinguish between a breakpoint trap and a singlestep trap.
         This is only important on targets where DECR_PC_AFTER_BREAK
         is non-zero.  The prev_pc test is meant to distinguish between
         singlestepping a trap instruction, and singlestepping thru a
         jump to the instruction following a trap instruction. */

      stop_bpstat = bpstat_stop_status (&stop_pc,
					currently_stepping (ecs) &&
					prev_pc !=
					stop_pc - DECR_PC_AFTER_BREAK);
      ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
      inferior_ptid = ecs->saved_inferior_ptid;
      goto process_event_stop_test;

      /* These syscall events are returned on HP-UX, as part of its
         implementation of page-protection-based "hardware" watchpoints.
         HP-UX has unfortunate interactions between page-protections and
         some system calls.  Our solution is to disable hardware watches
         when a system call is entered, and reenable them when the syscall
         completes.  The downside of this is that we may miss the precise
         point at which a watched piece of memory is modified.  "Oh well."

         Note that we may have multiple threads running, which may each
         enter syscalls at roughly the same time.  Since we don't have a
         good notion currently of whether a watched piece of memory is
         thread-private, we'd best not have any page-protections active
         when any thread is in a syscall.  Thus, we only want to reenable
         hardware watches when no threads are in a syscall.

         Also, be careful not to try to gather much state about a thread
         that's in a syscall.  It's frequently a losing proposition. */
    case TARGET_WAITKIND_SYSCALL_ENTRY:
      number_of_threads_in_syscalls++;
      if (number_of_threads_in_syscalls == 1)
	{
	  TARGET_DISABLE_HW_WATCHPOINTS (PIDGET (inferior_ptid));
	}
      resume (0, TARGET_SIGNAL_0);
      prepare_to_wait (ecs);
      return;
d1792 8
a1799 16
      /* Before examining the threads further, step this thread to
         get it entirely out of the syscall.  (We get notice of the
         event when the thread is just on the verge of exiting a
         syscall.  Stepping one instruction seems to get it back
         into user code.)

         Note that although the logical place to reenable h/w watches
         is here, we cannot.  We cannot reenable them before stepping
         the thread (this causes the next wait on the thread to hang).

         Nor can we enable them after stepping until we've done a wait.
         Thus, we simply set the flag ecs->enable_hw_watchpoints_after_wait
         here, which will be serviced immediately after the target
         is waited on. */
    case TARGET_WAITKIND_SYSCALL_RETURN:
      target_resume (ecs->ptid, 1, TARGET_SIGNAL_0);
d1801 3
a1803 8
      if (number_of_threads_in_syscalls > 0)
	{
	  number_of_threads_in_syscalls--;
	  ecs->enable_hw_watchpoints_after_wait =
	    (number_of_threads_in_syscalls == 0);
	}
      prepare_to_wait (ecs);
      return;
d1805 11
a1815 3
    case TARGET_WAITKIND_STOPPED:
      stop_signal = ecs->ws.value.sig;
      break;
d1817 13
a1829 11
      /* We had an event in the inferior, but we are not interested
         in handling it at this level. The lower layers have already
         done what needs to be done, if anything. This case can
         occur only when the target is async or extended-async. One
         of the circumstamces for this to happen is when the
         inferior produces output for the console. The inferior has
         not stopped, and we are ignoring the event. */
    case TARGET_WAITKIND_IGNORE:
      ecs->wait_some_more = 1;
      return;
    }
d1831 1
a1831 13
  /* We may want to consider not doing a resume here in order to give
     the user a chance to play with the new thread.  It might be good
     to make that a user-settable option.  */

  /* At this point, all threads are stopped (happens automatically in
     either the OS or the native code).  Therefore we need to continue
     all threads in order to make progress.  */
  if (ecs->new_thread_event)
    {
      target_resume (RESUME_ALL, 0, TARGET_SIGNAL_0);
      prepare_to_wait (ecs);
      return;
    }
d1833 3
a1835 1
  stop_pc = read_pc_pid (ecs->ptid);
d1837 3
a1839 11
  /* See if a thread hit a thread-specific breakpoint that was meant for
     another thread.  If so, then step that thread past the breakpoint,
     and continue it.  */

  if (stop_signal == TARGET_SIGNAL_TRAP)
    {
      if (SOFTWARE_SINGLE_STEP_P () && singlestep_breakpoints_inserted_p)
	ecs->random_signal = 0;
      else if (breakpoints_inserted
	       && breakpoint_here_p (stop_pc - DECR_PC_AFTER_BREAK))
	{
d1841 63
a1903 4
	  if (!breakpoint_thread_match (stop_pc - DECR_PC_AFTER_BREAK,
					ecs->ptid))
	    {
	      int remove_status;
d1905 11
a1915 51
	      /* Saw a breakpoint, but it was hit by the wrong thread.
	         Just continue. */
	      if (DECR_PC_AFTER_BREAK)
		write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK, ecs->ptid);

	      remove_status = remove_breakpoints ();
	      /* Did we fail to remove breakpoints?  If so, try
	         to set the PC past the bp.  (There's at least
	         one situation in which we can fail to remove
	         the bp's: On HP-UX's that use ttrace, we can't
	         change the address space of a vforking child
	         process until the child exits (well, okay, not
	         then either :-) or execs. */
	      if (remove_status != 0)
		{
		  /* FIXME!  This is obviously non-portable! */
		  write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK + 4, ecs->ptid);
		  /* We need to restart all the threads now,
		   * unles we're running in scheduler-locked mode. 
		   * Use currently_stepping to determine whether to 
		   * step or continue.
		   */
		  /* FIXME MVS: is there any reason not to call resume()? */
		  if (scheduler_mode == schedlock_on)
		    target_resume (ecs->ptid,
				   currently_stepping (ecs), TARGET_SIGNAL_0);
		  else
		    target_resume (RESUME_ALL,
				   currently_stepping (ecs), TARGET_SIGNAL_0);
		  prepare_to_wait (ecs);
		  return;
		}
	      else
		{		/* Single step */
		  breakpoints_inserted = 0;
		  if (!ptid_equal (inferior_ptid, ecs->ptid))
		    context_switch (ecs);
		  ecs->waiton_ptid = ecs->ptid;
		  ecs->wp = &(ecs->ws);
		  ecs->another_trap = 1;

		  ecs->infwait_state = infwait_thread_hop_state;
		  keep_going (ecs);
		  registers_changed ();
		  return;
		}
	    }
	}
    }
  else
    ecs->random_signal = 1;
d1917 5
a1921 16
  /* See if something interesting happened to the non-current thread.  If
     so, then switch to that thread, and eventually give control back to
     the user.

     Note that if there's any kind of pending follow (i.e., of a fork,
     vfork or exec), we don't want to do this now.  Rather, we'll let
     the next resume handle it. */
  if (!ptid_equal (ecs->ptid, inferior_ptid) &&
      (pending_follow.kind == TARGET_WAITKIND_SPURIOUS))
    {
      int printed = 0;

      /* If it's a random signal for a non-current thread, notify user
         if he's expressed an interest. */
      if (ecs->random_signal && signal_print[stop_signal])
	{
d1933 6
a1938 6
	  printed = 1;
	  target_terminal_ours_for_output ();
	  printf_filtered ("\nProgram received signal %s, %s.\n",
			   target_signal_to_name (stop_signal),
			   target_signal_to_string (stop_signal));
	  gdb_flush (gdb_stdout);
d1940 14
a1953 1
	}
d1955 4
a1958 2
      /* If it's not SIGTRAP and not a signal we want to stop for, then
         continue the thread. */
d1960 2
a1961 4
      if (stop_signal != TARGET_SIGNAL_TRAP && !signal_stop[stop_signal])
	{
	  if (printed)
	    target_terminal_inferior ();
d1963 1
a1963 3
	  /* Clear the signal if it should not be passed.  */
	  if (signal_program[stop_signal] == 0)
	    stop_signal = TARGET_SIGNAL_0;
d1965 2
a1966 4
	  target_resume (ecs->ptid, 0, stop_signal);
	  prepare_to_wait (ecs);
	  return;
	}
d1968 2
a1969 2
      /* It's a SIGTRAP or a signal we're interested in.  Switch threads,
         and fall into the rest of wait_for_inferior().  */
d1971 6
a1976 1
      context_switch (ecs);
d1978 3
a1980 2
      if (context_hook)
	context_hook (pid_to_thread_id (ecs->ptid));
d1982 5
a1986 2
      flush_cached_frames ();
    }
d1988 10
a1997 6
  if (SOFTWARE_SINGLE_STEP_P () && singlestep_breakpoints_inserted_p)
    {
      /* Pull the single step breakpoints out of the target. */
      SOFTWARE_SINGLE_STEP (0, 0);
      singlestep_breakpoints_inserted_p = 0;
    }
d1999 9
a2007 3
  /* If PC is pointing at a nullified instruction, then step beyond
     it so that the user won't be confused when GDB appears to be ready
     to execute it. */
d2009 21
a2029 5
  /*      if (INSTRUCTION_NULLIFIED && currently_stepping (ecs)) */
  if (INSTRUCTION_NULLIFIED)
    {
      registers_changed ();
      target_resume (ecs->ptid, 1, TARGET_SIGNAL_0);
d2031 2
a2032 10
      /* We may have received a signal that we want to pass to
         the inferior; therefore, we must not clobber the waitstatus
         in WS. */

      ecs->infwait_state = infwait_nullified_state;
      ecs->waiton_ptid = ecs->ptid;
      ecs->wp = &(ecs->tmpstatus);
      prepare_to_wait (ecs);
      return;
    }
d2034 3
a2036 9
  /* It may not be necessary to disable the watchpoint to stop over
     it.  For example, the PA can (with some kernel cooperation)
     single step over a watchpoint without disabling the watchpoint.  */
  if (HAVE_STEPPABLE_WATCHPOINT && STOPPED_BY_WATCHPOINT (ecs->ws))
    {
      resume (1, 0);
      prepare_to_wait (ecs);
      return;
    }
d2038 6
a2043 21
  /* It is far more common to need to disable a watchpoint to step
     the inferior over it.  FIXME.  What else might a debug
     register or page protection watchpoint scheme need here?  */
  if (HAVE_NONSTEPPABLE_WATCHPOINT && STOPPED_BY_WATCHPOINT (ecs->ws))
    {
      /* At this point, we are stopped at an instruction which has
         attempted to write to a piece of memory under control of
         a watchpoint.  The instruction hasn't actually executed
         yet.  If we were to evaluate the watchpoint expression
         now, we would get the old value, and therefore no change
         would seem to have occurred.

         In order to make watchpoints work `right', we really need
         to complete the memory write, and then evaluate the
         watchpoint expression.  The following code does that by
         removing the watchpoint (actually, all watchpoints and
         breakpoints), single-stepping the target, re-inserting
         watchpoints, and then falling through to let normal
         single-step processing handle proceed.  Since this
         includes evaluating watchpoints, things will come to a
         stop in the correct manner.  */
d2045 54
a2098 2
      if (DECR_PC_AFTER_BREAK)
	write_pc (stop_pc - DECR_PC_AFTER_BREAK);
d2100 2
a2101 3
      remove_breakpoints ();
      registers_changed ();
      target_resume (ecs->ptid, 1, TARGET_SIGNAL_0);	/* Single step */
d2103 10
a2112 6
      ecs->waiton_ptid = ecs->ptid;
      ecs->wp = &(ecs->ws);
      ecs->infwait_state = infwait_nonstep_watch_state;
      prepare_to_wait (ecs);
      return;
    }
d2114 24
a2137 20
  /* It may be possible to simply continue after a watchpoint.  */
  if (HAVE_CONTINUABLE_WATCHPOINT)
    STOPPED_BY_WATCHPOINT (ecs->ws);

  ecs->stop_func_start = 0;
  ecs->stop_func_end = 0;
  ecs->stop_func_name = 0;
  /* Don't care about return value; stop_func_start and stop_func_name
     will both be 0 if it doesn't work.  */
  find_pc_partial_function (stop_pc, &ecs->stop_func_name,
			    &ecs->stop_func_start, &ecs->stop_func_end);
  ecs->stop_func_start += FUNCTION_START_OFFSET;
  ecs->another_trap = 0;
  bpstat_clear (&stop_bpstat);
  stop_step = 0;
  stop_stack_dummy = 0;
  stop_print_frame = 1;
  ecs->random_signal = 0;
  stopped_by_random_signal = 0;
  breakpoints_failed = 0;
d2139 8
a2146 31
  /* Look at the cause of the stop, and decide what to do.
     The alternatives are:
     1) break; to really stop and return to the debugger,
     2) drop through to start up again
     (set ecs->another_trap to 1 to single step once)
     3) set ecs->random_signal to 1, and the decision between 1 and 2
     will be made according to the signal handling tables.  */

  /* First, distinguish signals caused by the debugger from signals
     that have to do with the program's own actions.
     Note that breakpoint insns may cause SIGTRAP or SIGILL
     or SIGEMT, depending on the operating system version.
     Here we detect when a SIGILL or SIGEMT is really a breakpoint
     and change it to SIGTRAP.  */

  if (stop_signal == TARGET_SIGNAL_TRAP
      || (breakpoints_inserted &&
	  (stop_signal == TARGET_SIGNAL_ILL
	   || stop_signal == TARGET_SIGNAL_EMT)) || stop_soon_quietly)
    {
      if (stop_signal == TARGET_SIGNAL_TRAP && stop_after_trap)
	{
	  stop_print_frame = 0;
	  stop_stepping (ecs);
	  return;
	}
      if (stop_soon_quietly)
	{
	  stop_stepping (ecs);
	  return;
	}
d2148 15
a2162 2
      /* Don't even think about breakpoints
         if just proceeded over a breakpoint.
d2164 53
a2216 10
         However, if we are trying to proceed over a breakpoint
         and end up in sigtramp, then through_sigtramp_breakpoint
         will be set and we should check whether we've hit the
         step breakpoint.  */
      if (stop_signal == TARGET_SIGNAL_TRAP && trap_expected
	  && through_sigtramp_breakpoint == NULL)
	bpstat_clear (&stop_bpstat);
      else
	{
	  /* See if there is a breakpoint at the current PC.  */
d2218 2
a2219 25
	  /* The second argument of bpstat_stop_status is meant to help
	     distinguish between a breakpoint trap and a singlestep trap.
	     This is only important on targets where DECR_PC_AFTER_BREAK
	     is non-zero.  The prev_pc test is meant to distinguish between
	     singlestepping a trap instruction, and singlestepping thru a
	     jump to the instruction following a trap instruction. */

	  stop_bpstat = bpstat_stop_status (&stop_pc,
					    /* Pass TRUE if our reason for stopping is something other
					       than hitting a breakpoint.  We do this by checking that
					       1) stepping is going on and 2) we didn't hit a breakpoint
					       in a signal handler without an intervening stop in
					       sigtramp, which is detected by a new stack pointer value
					       below any usual function calling stack adjustments.  */
					    (currently_stepping (ecs)
					     && prev_pc !=
					     stop_pc - DECR_PC_AFTER_BREAK
					     && !(step_range_end
						  && INNER_THAN (read_sp (),
								 (step_sp -
								  16)))));
	  /* Following in case break condition called a
	     function.  */
	  stop_print_frame = 1;
	}
d2221 4
a2224 8
      if (stop_signal == TARGET_SIGNAL_TRAP)
	ecs->random_signal
	  = !(bpstat_explains_signal (stop_bpstat)
	      || trap_expected
	      || (!CALL_DUMMY_BREAKPOINT_OFFSET_P
		  && PC_IN_CALL_DUMMY (stop_pc, read_sp (),
				       FRAME_FP (get_current_frame ())))
	      || (step_range_end && step_resume_breakpoint == NULL));
d2226 1
a2226 15
      else
	{
	  ecs->random_signal = !(bpstat_explains_signal (stop_bpstat)
				 /* End of a stack dummy.  Some systems (e.g. Sony
				    news) give another signal besides SIGTRAP, so
				    check here as well as above.  */
				 || (!CALL_DUMMY_BREAKPOINT_OFFSET_P
				     && PC_IN_CALL_DUMMY (stop_pc, read_sp (),
							  FRAME_FP
							  (get_current_frame
							   ()))));
	  if (!ecs->random_signal)
	    stop_signal = TARGET_SIGNAL_TRAP;
	}
    }
d2228 15
a2242 3
  /* When we reach this point, we've pretty much decided
     that the reason for stopping must've been a random
     (unexpected) signal. */
d2244 2
a2245 24
  else
    ecs->random_signal = 1;
  /* If a fork, vfork or exec event was seen, then there are two
     possible responses we can make:

     1. If a catchpoint triggers for the event (ecs->random_signal == 0),
     then we must stop now and issue a prompt.  We will resume
     the inferior when the user tells us to.
     2. If no catchpoint triggers for the event (ecs->random_signal == 1),
     then we must resume the inferior now and keep checking.

     In either case, we must take appropriate steps to "follow" the
     the fork/vfork/exec when the inferior is resumed.  For example,
     if follow-fork-mode is "child", then we must detach from the
     parent inferior and follow the new child inferior.

     In either case, setting pending_follow causes the next resume()
     to take the appropriate following action. */
process_event_stop_test:
  if (ecs->ws.kind == TARGET_WAITKIND_FORKED)
    {
      if (ecs->random_signal)	/* I.e., no catchpoint triggered for this. */
	{
	  trap_expected = 1;
d2247 39
a2285 5
	  keep_going (ecs);
	  return;
	}
    }
  else if (ecs->ws.kind == TARGET_WAITKIND_VFORKED)
d2287 6
a2292 1
      if (ecs->random_signal)	/* I.e., no catchpoint triggered for this. */
d2294 4
a2297 3
	  stop_signal = TARGET_SIGNAL_0;
	  keep_going (ecs);
	  return;
d2299 2
a2300 5
    }
  else if (ecs->ws.kind == TARGET_WAITKIND_EXECD)
    {
      pending_follow.kind = ecs->ws.kind;
      if (ecs->random_signal)	/* I.e., no catchpoint triggered for this. */
d2302 37
a2338 2
	  trap_expected = 1;
	  stop_signal = TARGET_SIGNAL_0;
a2340 2
	}
    }
d2342 31
a2372 2
  /* For the program's own signals, act according to
     the signal handling tables.  */
d2374 2
a2375 4
  if (ecs->random_signal)
    {
      /* Signal not for debugging purposes.  */
      int printed = 0;
d2377 3
a2379 1
      stopped_by_random_signal = 1;
a2380 8
      if (signal_print[stop_signal])
	{
	  printed = 1;
	  target_terminal_ours_for_output ();
	  print_stop_reason (SIGNAL_RECEIVED, stop_signal);
	}
      if (signal_stop[stop_signal])
	{
a2382 5
	}
      /* If not going to stop, give terminal back
         if we took it away.  */
      else if (printed)
	target_terminal_inferior ();
d2384 2
a2385 3
      /* Clear the signal if it should not be passed.  */
      if (signal_program[stop_signal] == 0)
	stop_signal = TARGET_SIGNAL_0;
d2387 3
a2389 2
      /* I'm not sure whether this needs to be check_sigtramp2 or
         whether it could/should be keep_going.
d2391 2
a2392 2
         This used to jump to step_over_function if we are stepping,
         which is wrong.
d2394 17
a2410 30
         Suppose the user does a `next' over a function call, and while
         that call is in progress, the inferior receives a signal for
         which GDB does not stop (i.e., signal_stop[SIG] is false).  In
         that case, when we reach this point, there is already a
         step-resume breakpoint established, right where it should be:
         immediately after the function call the user is "next"-ing
         over.  If we call step_over_function now, two bad things
         happen:

         - we'll create a new breakpoint, at wherever the current
         frame's return address happens to be.  That could be
         anywhere, depending on what function call happens to be on
         the top of the stack at that point.  Point is, it's probably
         not where we need it.

         - the existing step-resume breakpoint (which is at the correct
         address) will get orphaned: step_resume_breakpoint will point
         to the new breakpoint, and the old step-resume breakpoint
         will never be cleaned up.

         The old behavior was meant to help HP-UX single-step out of
         sigtramps.  It would place the new breakpoint at prev_pc, which
         was certainly wrong.  I don't know the details there, so fixing
         this probably breaks that.  As with anything else, it's up to
         the HP-UX maintainer to furnish a fix that doesn't break other
         platforms.  --JimB, 20 May 1999 */
      check_sigtramp2 (ecs);
      keep_going (ecs);
      return;
    }
d2412 7
a2418 4
  /* Handle cases caused by hitting a breakpoint.  */
  {
    CORE_ADDR jmp_buf_pc;
    struct bpstat_what what;
d2420 4
a2423 1
    what = bpstat_what (stop_bpstat);
d2425 5
a2429 7
    if (what.call_dummy)
      {
	stop_stack_dummy = 1;
#ifdef HP_OS_BUG
	trap_expected_after_continue = 1;
#endif
      }
d2431 3
a2433 10
    switch (what.main_action)
      {
      case BPSTAT_WHAT_SET_LONGJMP_RESUME:
	/* If we hit the breakpoint at longjmp, disable it for the
	   duration of this command.  Then, install a temporary
	   breakpoint at the target of the jmp_buf. */
	disable_longjmp_breakpoint ();
	remove_breakpoints ();
	breakpoints_inserted = 0;
	if (!GET_LONGJMP_TARGET_P () || !GET_LONGJMP_TARGET (&jmp_buf_pc))
d2435 68
a2502 2
	    keep_going (ecs);
	    return;
d2504 2
d2507 2
a2508 13
	/* Need to blow away step-resume breakpoint, as it
	   interferes with us */
	if (step_resume_breakpoint != NULL)
	  {
	    delete_step_resume_breakpoint (&step_resume_breakpoint);
	  }
	/* Not sure whether we need to blow this away too, but probably
	   it is like the step-resume breakpoint.  */
	if (through_sigtramp_breakpoint != NULL)
	  {
	    delete_breakpoint (through_sigtramp_breakpoint);
	    through_sigtramp_breakpoint = NULL;
	  }
d2510 4
a2513 10
#if 0
	/* FIXME - Need to implement nested temporary breakpoints */
	if (step_over_calls > 0)
	  set_longjmp_resume_breakpoint (jmp_buf_pc, get_current_frame ());
	else
#endif /* 0 */
	  set_longjmp_resume_breakpoint (jmp_buf_pc, NULL);
	ecs->handling_longjmp = 1;	/* FIXME */
	keep_going (ecs);
	return;
d2515 14
a2528 9
      case BPSTAT_WHAT_CLEAR_LONGJMP_RESUME:
      case BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE:
	remove_breakpoints ();
	breakpoints_inserted = 0;
#if 0
	/* FIXME - Need to implement nested temporary breakpoints */
	if (step_over_calls
	    && (INNER_THAN (FRAME_FP (get_current_frame ()),
			    step_frame_address)))
d2534 11
a2544 6
#endif /* 0 */
	disable_longjmp_breakpoint ();
	ecs->handling_longjmp = 0;	/* FIXME */
	if (what.main_action == BPSTAT_WHAT_CLEAR_LONGJMP_RESUME)
	  break;
	/* else fallthrough */
d2546 14
a2559 2
      case BPSTAT_WHAT_SINGLE:
	if (breakpoints_inserted)
d2561 7
a2567 1
	    remove_breakpoints ();
d2569 1
a2569 5
	breakpoints_inserted = 0;
	ecs->another_trap = 1;
	/* Still need to check other stuff, at least the case
	   where we are stepping and step out of the right range.  */
	break;
d2571 21
a2591 2
      case BPSTAT_WHAT_STOP_NOISY:
	stop_print_frame = 1;
d2593 1
a2593 3
	/* We are about to nuke the step_resume_breakpoint and
	   through_sigtramp_breakpoint via the cleanup chain, so
	   no need to worry about it here.  */
d2595 10
a2604 1
	stop_stepping (ecs);
d2606 1
d2608 1
a2608 2
      case BPSTAT_WHAT_STOP_SILENT:
	stop_print_frame = 0;
d2610 7
a2616 3
	/* We are about to nuke the step_resume_breakpoint and
	   through_sigtramp_breakpoint via the cleanup chain, so
	   no need to worry about it here.  */
d2618 7
a2624 2
	stop_stepping (ecs);
	return;
d2626 1
a2626 20
      case BPSTAT_WHAT_STEP_RESUME:
	/* This proably demands a more elegant solution, but, yeah
	   right...

	   This function's use of the simple variable
	   step_resume_breakpoint doesn't seem to accomodate
	   simultaneously active step-resume bp's, although the
	   breakpoint list certainly can.

	   If we reach here and step_resume_breakpoint is already
	   NULL, then apparently we have multiple active
	   step-resume bp's.  We'll just delete the breakpoint we
	   stopped at, and carry on.  

	   Correction: what the code currently does is delete a
	   step-resume bp, but it makes no effort to ensure that
	   the one deleted is the one currently stopped at.  MVS  */

	if (step_resume_breakpoint == NULL)
	  {
d2628 3
a2630 1
	      bpstat_find_step_resume_breakpoint (stop_bpstat);
a2631 2
	delete_step_resume_breakpoint (&step_resume_breakpoint);
	break;
d2633 16
a2648 10
      case BPSTAT_WHAT_THROUGH_SIGTRAMP:
	if (through_sigtramp_breakpoint)
	  delete_breakpoint (through_sigtramp_breakpoint);
	through_sigtramp_breakpoint = NULL;

	/* If were waiting for a trap, hitting the step_resume_break
	   doesn't count as getting it.  */
	if (trap_expected)
	  ecs->another_trap = 1;
	break;
d2650 6
a2655 10
      case BPSTAT_WHAT_CHECK_SHLIBS:
      case BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK:
#ifdef SOLIB_ADD
	{
	  /* Remove breakpoints, we eventually want to step over the
	     shlib event breakpoint, and SOLIB_ADD might adjust
	     breakpoint addresses via breakpoint_re_set.  */
	  if (breakpoints_inserted)
	    remove_breakpoints ();
	  breakpoints_inserted = 0;
a2656 7
	  /* Check for any newly added shared libraries if we're
	     supposed to be adding them automatically.  Switch
	     terminal for any messages produced by
	     breakpoint_re_set.  */
	  target_terminal_ours_for_output ();
	  SOLIB_ADD (NULL, 0, NULL, auto_solib_add);
	  target_terminal_inferior ();
d2658 2
a2659 13
	  /* Try to reenable shared library breakpoints, additional
	     code segments in shared libraries might be mapped in now. */
	  re_enable_breakpoints_in_shlibs ();

	  /* If requested, stop when the dynamic linker notifies
	     gdb of events.  This allows the user to get control
	     and place breakpoints in initializer routines for
	     dynamically loaded objects (among other things).  */
	  if (stop_on_solib_events)
	    {
	      stop_stepping (ecs);
	      return;
	    }
d2661 1
a2661 12
	  /* If we stopped due to an explicit catchpoint, then the
	     (see above) call to SOLIB_ADD pulled in any symbols
	     from a newly-loaded library, if appropriate.

	     We do want the inferior to stop, but not where it is
	     now, which is in the dynamic linker callback.  Rather,
	     we would like it stop in the user's program, just after
	     the call that caused this catchpoint to trigger.  That
	     gives the user a more useful vantage from which to
	     examine their program's state. */
	  else if (what.main_action ==
		   BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK)
d2663 2
a2664 16
	      /* ??rehrauer: If I could figure out how to get the
	         right return PC from here, we could just set a temp
	         breakpoint and resume.  I'm not sure we can without
	         cracking open the dld's shared libraries and sniffing
	         their unwind tables and text/data ranges, and that's
	         not a terribly portable notion.

	         Until that time, we must step the inferior out of the
	         dld callback, and also out of the dld itself (and any
	         code or stubs in libdld.sl, such as "shl_load" and
	         friends) until we reach non-dld code.  At that point,
	         we can stop stepping. */
	      bpstat_get_triggered_catchpoints (stop_bpstat,
						&ecs->
						stepping_through_solib_catchpoints);
	      ecs->stepping_through_solib_after_catch = 1;
d2666 22
a2687 4
	      /* Be sure to lift all breakpoints, so the inferior does
	         actually step past this point... */
	      ecs->another_trap = 1;
	      break;
d2691 19
a2709 3
	      /* We want to step over this breakpoint, then keep going.  */
	      ecs->another_trap = 1;
	      break;
a2711 2
#endif
	break;
a2712 2
      case BPSTAT_WHAT_LAST:
	/* Not a real code, but listed here to shut up gcc -Wall.  */
d2714 11
a2724 2
      case BPSTAT_WHAT_KEEP_CHECKING:
	break;
a2725 1
  }
d2727 7
a2733 30
  /* We come here if we hit a breakpoint but should not
     stop for it.  Possibly we also were stepping
     and should stop for that.  So fall through and
     test for stepping.  But, if not stepping,
     do not stop.  */

  /* Are we stepping to get the inferior out of the dynamic
     linker's hook (and possibly the dld itself) after catching
     a shlib event? */
  if (ecs->stepping_through_solib_after_catch)
    {
#if defined(SOLIB_ADD)
      /* Have we reached our destination?  If not, keep going. */
      if (SOLIB_IN_DYNAMIC_LINKER (PIDGET (ecs->ptid), stop_pc))
	{
	  ecs->another_trap = 1;
	  keep_going (ecs);
	  return;
	}
#endif
      /* Else, stop and report the catchpoint(s) whose triggering
         caused us to begin stepping. */
      ecs->stepping_through_solib_after_catch = 0;
      bpstat_clear (&stop_bpstat);
      stop_bpstat = bpstat_copy (ecs->stepping_through_solib_catchpoints);
      bpstat_clear (&ecs->stepping_through_solib_catchpoints);
      stop_print_frame = 1;
      stop_stepping (ecs);
      return;
    }
d2735 15
a2749 24
  if (!CALL_DUMMY_BREAKPOINT_OFFSET_P)
    {
      /* This is the old way of detecting the end of the stack dummy.
         An architecture which defines CALL_DUMMY_BREAKPOINT_OFFSET gets
         handled above.  As soon as we can test it on all of them, all
         architectures should define it.  */

      /* If this is the breakpoint at the end of a stack dummy,
         just stop silently, unless the user was doing an si/ni, in which
         case she'd better know what she's doing.  */

      if (CALL_DUMMY_HAS_COMPLETED (stop_pc, read_sp (),
				    FRAME_FP (get_current_frame ()))
	  && !step_range_end)
	{
	  stop_print_frame = 0;
	  stop_stack_dummy = 1;
#ifdef HP_OS_BUG
	  trap_expected_after_continue = 1;
#endif
	  stop_stepping (ecs);
	  return;
	}
    }
d2751 3
a2753 11
  if (step_resume_breakpoint)
    {
      /* Having a step-resume breakpoint overrides anything
         else having to do with stepping commands until
         that breakpoint is reached.  */
      /* I'm not sure whether this needs to be check_sigtramp2 or
         whether it could/should be keep_going.  */
      check_sigtramp2 (ecs);
      keep_going (ecs);
      return;
    }
d2755 12
a2766 9
  if (step_range_end == 0)
    {
      /* Likewise if we aren't even stepping.  */
      /* I'm not sure whether this needs to be check_sigtramp2 or
         whether it could/should be keep_going.  */
      check_sigtramp2 (ecs);
      keep_going (ecs);
      return;
    }
d2768 4
a2771 1
  /* If stepping through a line, keep going if still within it.
d2773 27
a2799 11
     Note that step_range_end is the address of the first instruction
     beyond the step range, and NOT the address of the last instruction
     within it! */
  if (stop_pc >= step_range_start && stop_pc < step_range_end)
    {
      /* We might be doing a BPSTAT_WHAT_SINGLE and getting a signal.
         So definately need to check for sigtramp here.  */
      check_sigtramp2 (ecs);
      keep_going (ecs);
      return;
    }
d2801 2
a2802 1
  /* We stepped out of the stepping range.  */
d2804 5
a2808 8
  /* If we are stepping at the source level and entered the runtime
     loader dynamic symbol resolution code, we keep on single stepping
     until we exit the run time loader code and reach the callee's
     address.  */
  if (step_over_calls == STEP_OVER_UNDEBUGGABLE
      && IN_SOLIB_DYNSYM_RESOLVE_CODE (stop_pc))
    {
      CORE_ADDR pc_after_resolver = SKIP_SOLIB_RESOLVER (stop_pc);
d2810 6
a2815 13
      if (pc_after_resolver)
	{
	  /* Set up a step-resume breakpoint at the address
	     indicated by SKIP_SOLIB_RESOLVER.  */
	  struct symtab_and_line sr_sal;
	  INIT_SAL (&sr_sal);
	  sr_sal.pc = pc_after_resolver;

	  check_for_old_step_resume_breakpoint ();
	  step_resume_breakpoint =
	    set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
	  if (breakpoints_inserted)
	    insert_breakpoints ();
d2818 14
a2831 3
      keep_going (ecs);
      return;
    }
d2833 1
a2833 4
  /* We can't update step_sp every time through the loop, because
     reading the stack pointer would slow down stepping too much.
     But we can update it every time we leave the step range.  */
  ecs->update_step_sp = 1;
d2835 1
a2835 7
  /* Did we just take a signal?  */
  if (PC_IN_SIGTRAMP (stop_pc, ecs->stop_func_name)
      && !PC_IN_SIGTRAMP (prev_pc, prev_func_name)
      && INNER_THAN (read_sp (), step_sp))
    {
      /* We've just taken a signal; go until we are back to
         the point where we took it and one more.  */
d2837 1
a2837 6
      /* Note: The test above succeeds not only when we stepped
         into a signal handler, but also when we step past the last
         statement of a signal handler and end up in the return stub
         of the signal handler trampoline.  To distinguish between
         these two cases, check that the frame is INNER_THAN the
         previous one below. pai/1997-09-11 */
d2839 9
d2849 3
d2853 4
a2856 1
	CORE_ADDR current_frame = FRAME_FP (get_current_frame ());
d2858 2
a2859 1
	if (INNER_THAN (current_frame, step_frame_address))
d2861 1
a2861 11
	    /* We have just taken a signal; go until we are back to
	       the point where we took it and one more.  */

	    /* This code is needed at least in the following case:
	       The user types "next" and then a signal arrives (before
	       the "next" is done).  */

	    /* Note that if we are stopped at a breakpoint, then we need
	       the step_resume breakpoint to override any breakpoints at
	       the same location, so that we will still step over the
	       breakpoint even though the signal happened.  */
d2864 6
a2869 7
	    INIT_SAL (&sr_sal);
	    sr_sal.symtab = NULL;
	    sr_sal.line = 0;
	    sr_sal.pc = prev_pc;
	    /* We could probably be setting the frame to
	       step_frame_address; I don't think anyone thought to
	       try it.  */
a2874 5
	  }
	else
	  {
	    /* We just stepped out of a signal handler and into
	       its calling trampoline.
d2876 4
a2879 16
	       Normally, we'd call step_over_function from
	       here, but for some reason GDB can't unwind the
	       stack correctly to find the real PC for the point
	       user code where the signal trampoline will return
	       -- FRAME_SAVED_PC fails, at least on HP-UX 10.20.
	       But signal trampolines are pretty small stubs of
	       code, anyway, so it's OK instead to just
	       single-step out.  Note: assuming such trampolines
	       don't exhibit recursion on any platform... */
	    find_pc_partial_function (stop_pc, &ecs->stop_func_name,
				      &ecs->stop_func_start,
				      &ecs->stop_func_end);
	    /* Readjust stepping range */
	    step_range_start = ecs->stop_func_start;
	    step_range_end = ecs->stop_func_end;
	    ecs->stepping_through_sigtramp = 1;
d2883 11
d2895 12
a2906 40
      /* If this is stepi or nexti, make sure that the stepping range
         gets us past that instruction.  */
      if (step_range_end == 1)
	/* FIXME: Does this run afoul of the code below which, if
	   we step into the middle of a line, resets the stepping
	   range?  */
	step_range_end = (step_range_start = prev_pc) + 1;

      ecs->remove_breakpoints_on_following_step = 1;
      keep_going (ecs);
      return;
    }

  if (stop_pc == ecs->stop_func_start	/* Quick test */
      || (in_prologue (stop_pc, ecs->stop_func_start) &&
	  !IN_SOLIB_RETURN_TRAMPOLINE (stop_pc, ecs->stop_func_name))
      || IN_SOLIB_CALL_TRAMPOLINE (stop_pc, ecs->stop_func_name)
      || ecs->stop_func_name == 0)
    {
      /* It's a subroutine call.  */

      if ((step_over_calls == STEP_OVER_NONE)
	  || ((step_range_end == 1)
	      && in_prologue (prev_pc, ecs->stop_func_start)))
	{
	  /* I presume that step_over_calls is only 0 when we're
	     supposed to be stepping at the assembly language level
	     ("stepi").  Just stop.  */
	  /* Also, maybe we just did a "nexti" inside a prolog,
	     so we thought it was a subroutine call but it was not.
	     Stop as well.  FENN */
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}

      if (step_over_calls == STEP_OVER_ALL || IGNORE_HELPER_CALL (stop_pc))
	{
	  /* We're doing a "next".  */
d2908 1
a2908 12
	  if (PC_IN_SIGTRAMP (stop_pc, ecs->stop_func_name)
	      && INNER_THAN (step_frame_address, read_sp ()))
	    /* We stepped out of a signal handler, and into its
	       calling trampoline.  This is misdetected as a
	       subroutine call, but stepping over the signal
	       trampoline isn't such a bad idea.  In order to do
	       that, we have to ignore the value in
	       step_frame_address, since that doesn't represent the
	       frame that'll reach when we return from the signal
	       trampoline.  Otherwise we'll probably continue to the
	       end of the program.  */
	    step_frame_address = 0;
d2910 4
a2913 4
	  step_over_function (ecs);
	  keep_going (ecs);
	  return;
	}
d2915 1
a2915 34
      /* If we are in a function call trampoline (a stub between
         the calling routine and the real function), locate the real
         function.  That's what tells us (a) whether we want to step
         into it at all, and (b) what prologue we want to run to
         the end of, if we do step into it.  */
      tmp = SKIP_TRAMPOLINE_CODE (stop_pc);
      if (tmp != 0)
	ecs->stop_func_start = tmp;
      else
	{
	  tmp = DYNAMIC_TRAMPOLINE_NEXTPC (stop_pc);
	  if (tmp)
	    {
	      struct symtab_and_line xxx;
	      /* Why isn't this s_a_l called "sr_sal", like all of the
	         other s_a_l's where this code is duplicated?  */
	      INIT_SAL (&xxx);	/* initialize to zeroes */
	      xxx.pc = tmp;
	      xxx.section = find_pc_overlay (xxx.pc);
	      check_for_old_step_resume_breakpoint ();
	      step_resume_breakpoint =
		set_momentary_breakpoint (xxx, NULL, bp_step_resume);
	      insert_breakpoints ();
	      keep_going (ecs);
	      return;
	    }
	}

      /* If we have line number information for the function we
         are thinking of stepping into, step into it.

         If there are several symtabs at that PC (e.g. with include
         files), just want to know whether *any* of them have line
         numbers.  find_pc_line handles this.  */
d2917 9
a2925 8
	struct symtab_and_line tmp_sal;

	tmp_sal = find_pc_line (ecs->stop_func_start, 0);
	if (tmp_sal.line != 0)
	  {
	    step_into_function (ecs);
	    return;
	  }
d2927 5
d2933 3
a2935 22
      /* If we have no line number and the step-stop-if-no-debug
         is set, we stop the step so that the user has a chance to
         switch in assembly mode.  */
      if (step_over_calls == STEP_OVER_UNDEBUGGABLE && step_stop_if_no_debug)
	{
	  stop_step = 1;
	  print_stop_reason (END_STEPPING_RANGE, 0);
	  stop_stepping (ecs);
	  return;
	}

      step_over_function (ecs);
      keep_going (ecs);
      return;

    }

  /* We've wandered out of the step range.  */

  ecs->sal = find_pc_line (stop_pc, 0);

  if (step_range_end == 1)
d2937 3
a2939 6
      /* It is stepi or nexti.  We always want to stop stepping after
         one instruction.  */
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
d2942 1
a2942 8
  /* If we're in the return path from a shared library trampoline,
     we want to proceed through the trampoline when stepping.  */
  if (IN_SOLIB_RETURN_TRAMPOLINE (stop_pc, ecs->stop_func_name))
    {
      CORE_ADDR tmp;

      /* Determine where this trampoline returns.  */
      tmp = SKIP_TRAMPOLINE_CODE (stop_pc);
d2944 1
a2944 86
      /* Only proceed through if we know where it's going.  */
      if (tmp)
	{
	  /* And put the step-breakpoint there and go until there. */
	  struct symtab_and_line sr_sal;

	  INIT_SAL (&sr_sal);	/* initialize to zeroes */
	  sr_sal.pc = tmp;
	  sr_sal.section = find_pc_overlay (sr_sal.pc);
	  /* Do not specify what the fp should be when we stop
	     since on some machines the prologue
	     is where the new fp value is established.  */
	  check_for_old_step_resume_breakpoint ();
	  step_resume_breakpoint =
	    set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
	  if (breakpoints_inserted)
	    insert_breakpoints ();

	  /* Restart without fiddling with the step ranges or
	     other state.  */
	  keep_going (ecs);
	  return;
	}
    }

  if (ecs->sal.line == 0)
    {
      /* We have no line number information.  That means to stop
         stepping (does this always happen right after one instruction,
         when we do "s" in a function with no line numbers,
         or can this happen as a result of a return or longjmp?).  */
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }

  if ((stop_pc == ecs->sal.pc)
      && (ecs->current_line != ecs->sal.line
	  || ecs->current_symtab != ecs->sal.symtab))
    {
      /* We are at the start of a different line.  So stop.  Note that
         we don't stop if we step into the middle of a different line.
         That is said to make things like for (;;) statements work
         better.  */
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }

  /* We aren't done stepping.

     Optimize by setting the stepping range to the line.
     (We might not be in the original line, but if we entered a
     new line in mid-statement, we continue stepping.  This makes
     things like for(;;) statements work better.)  */

  if (ecs->stop_func_end && ecs->sal.end >= ecs->stop_func_end)
    {
      /* If this is the last line of the function, don't keep stepping
         (it would probably step us out of the function).
         This is particularly necessary for a one-line function,
         in which after skipping the prologue we better stop even though
         we will be in mid-line.  */
      stop_step = 1;
      print_stop_reason (END_STEPPING_RANGE, 0);
      stop_stepping (ecs);
      return;
    }
  step_range_start = ecs->sal.pc;
  step_range_end = ecs->sal.end;
  step_frame_address = FRAME_FP (get_current_frame ());
  ecs->current_line = ecs->sal.line;
  ecs->current_symtab = ecs->sal.symtab;

  /* In the case where we just stepped out of a function into the middle
     of a line of the caller, continue stepping, but step_frame_address
     must be modified to current frame */
  {
    CORE_ADDR current_frame = FRAME_FP (get_current_frame ());
    if (!(INNER_THAN (current_frame, step_frame_address)))
      step_frame_address = current_frame;
  }

  keep_going (ecs);
d2969 2
a2970 2
         inferior with a signal (because it is a signal which
         shouldn't make us stop), thus stepping into sigtramp.
d2972 6
a2977 6
         So we need to set a step_resume_break_address breakpoint and
         continue until we hit it, and then step.  FIXME: This should
         be more enduring than a step_resume breakpoint; we should
         know that we will later need to keep going rather than
         re-hitting the breakpoint here (see the testsuite,
         gdb.base/signals.exp where it says "exceedingly difficult").  */
d2985 1
a2985 1
         frame corresponding to prev_pc was.  But we don't, so don't.  */
d3030 1
a3030 1
      print_stop_reason (END_STEPPING_RANGE, 0);
d3041 2
a3042 2
         some machines the prologue is where the new fp value is
         established.  */
d3072 1
a3072 1
  INIT_SAL (&sr_sal);		/* initialize to zeros */
d3113 1
a3113 1
	  while (!ptid_equal (parent_ptid, inferior_ptid));
d3146 1
a3146 1
  prev_pc = read_pc ();		/* Might have been DECR_AFTER_BREAK */
d3164 2
a3165 2
         the inferior, else we'd have done a break above) and we
         haven't yet gotten our trap.  Simply continue.  */
d3171 5
a3175 5
         anyway (the user asked that this signal be passed to the
         child)
         -- or --
         The signal was SIGTRAP, e.g. it was our signal, but we
         decided we should resume from it.
d3177 1
a3177 1
         We're going to run this baby now!
d3179 2
a3180 2
         Insert breakpoints now, unless we are trying to one-proceed
         past a breakpoint.  */
d3182 1
a3182 1
         want to hit a breakpoint, pull em out.  */
d3206 2
a3207 2
         specifies that such a signal should be delivered to the
         target program).
d3209 7
a3215 7
         Typically, this would occure when a user is debugging a
         target monitor on a simulator: the target monitor sets a
         breakpoint; the simulator encounters this break-point and
         halts the simulation handing control to GDB; GDB, noteing
         that the break-point isn't valid, returns control back to the
         simulator; the simulator then delivers the hardware
         equivalent of a SIGNAL_TRAP to the program being debugged. */
d3217 2
a3218 1
      if (stop_signal == TARGET_SIGNAL_TRAP && !signal_program[stop_signal])
d3223 2
a3224 2
         now, that we shouldn't rewrite the regs when we were stopped
         by a random signal from the inferior process.  */
d3226 1
a3226 1
         (this is only used on the 88k).  */
d3229 2
a3230 1
	  && (stop_signal != TARGET_SIGNAL_CHLD) && !stopped_by_random_signal)
d3237 1
a3237 1
  prepare_to_wait (ecs);
d3252 4
a3255 4
         target_wait because they can be loaded from the target while
         in target_wait.  This makes remote debugging a bit more
         efficient for those targets that provide critical registers
         as part of their normal status mechanism. */
d3285 1
a3285 1
         operation for n > 1 */
d3301 1
a3301 2
      ui_out_field_string (uiout, "signal-name",
			   target_signal_to_name (stop_info));
d3305 1
a3305 2
      ui_out_field_string (uiout, "signal-meaning",
			   target_signal_to_string (stop_info));
d3318 1
a3318 2
	  ui_out_field_fmt (uiout, "exit-code", "0%o",
			    (unsigned int) stop_info);
d3336 1
a3336 2
      ui_out_field_string (uiout, "signal-name",
			   target_signal_to_name (stop_info));
d3340 1
a3340 2
      ui_out_field_string (uiout, "signal-meaning",
			   target_signal_to_string (stop_info));
d3369 1
a3369 1
  if (!ptid_equal (previous_inferior_ptid, inferior_ptid)
d3452 2
a3453 1
      if (stop_print_frame && selected_frame)
d3466 1
a3466 1
		source_flag = SRC_LINE;	/* finished step, just print source line */
d3468 1
a3468 1
		source_flag = SRC_AND_LOC;	/* print location and source line */
d3471 1
a3471 1
	      source_flag = SRC_AND_LOC;	/* print location and source line */
d3477 1
a3477 1
	      source_flag = SRC_LINE;	/* something bogus */
d3481 2
a3482 1
	      internal_error (__FILE__, __LINE__, "Unknown value.");
d3485 1
a3485 1
	     print everything but the source line. */
d3491 1
a3491 1
			      pid_to_thread_id (inferior_ptid));
d3508 1
a3508 3
    /* NB: The copy goes through to the target picking up the value of
       all the registers.  */
    regcache_cpy (stop_registers, current_regcache);
d3552 1
a3552 2
int
signal_stop_update (signo, state)
d3561 1
a3561 2
int
signal_print_update (signo, state)
d3570 1
a3570 2
int
signal_pass_update (signo, state)
d3596 2
a3597 1
  printf_filtered ("%*.*s ", name_padding, name_padding, "                 ");
d3743 3
a3745 1
Are you sure you want to change it? ", target_signal_to_name ((enum target_signal) signum)))
d3889 2
a3890 1
	  && oursig != TARGET_SIGNAL_DEFAULT && oursig != TARGET_SIGNAL_0)
d3913 1
a3913 1
  struct regcache *stop_registers;
d3918 1
a3918 1
  struct regcache *registers;
d3928 18
d3953 1
a3953 1
  regcache_write (inf_status->registers, regno, buf);
d3963 1
a3963 1
  struct inferior_status *inf_status = XMALLOC (struct inferior_status);
d3987 1
a3987 1
  inf_status->stop_registers = regcache_dup_no_passthrough (stop_registers);
d3989 1
a3989 1
  inf_status->registers = regcache_dup (current_regcache);
d3998 1
a3998 1
  struct frame_id *fid = (struct frame_id *) args;
d4036 2
a4037 3
  /* FIXME: Is the restore of stop_registers always needed. */
  regcache_xfree (stop_registers);
  stop_registers = inf_status->stop_registers;
d4042 1
a4042 3
    /* NB: The register write goes through to the target.  */
    regcache_cpy (current_regcache, inf_status->registers);
  regcache_xfree (inf_status->registers);
d4056 3
a4058 4
      if (catch_errors
	  (restore_selected_frame, &inf_status->selected_frame_id,
	   "Unable to restore previously selected frame:\n",
	   RETURN_MASK_ERROR) == 0)
d4065 1
a4065 1
  xfree (inf_status);
d4085 1
a4085 3
  regcache_xfree (inf_status->registers);
  regcache_xfree (inf_status->stop_registers);
  xfree (inf_status);
d4093 1
a4093 1

d4143 1
a4143 1
	  && ptid1.tid == ptid2.tid);
d4171 1
a4172 1

d4176 1
a4176 1
  stop_registers = regcache_xmalloc (current_gdbarch);
d4186 2
d4203 2
a4204 1
used by the debugger, typically SIGTRAP and SIGINT.\n", "Recognized actions include \"stop\", \"nostop\", \"print\", \"noprint\",\n\
d4223 2
a4224 1
used by the debugger, typically SIGTRAP and SIGINT.\n", "Recognized actions include \"s\" (toggles between stop and nostop), \n\
d4235 2
a4236 2
    stop_command =
      add_cmd ("stop", class_obscure, not_just_help_class_command, "There is no `stop' command, but you can set a hook on `stop'.\n\
d4241 2
a4242 1
  signal_stop = (unsigned char *) xmalloc (sizeof (signal_stop[0]) * numsigs);
d4295 3
a4297 1
to the user would be loading/unloading of a new library.\n", &setlist), &showlist);
d4302 2
a4303 1
			follow_fork_mode_kind_names, &follow_fork_mode_string,
d4329 2
a4330 1
By default, the debugger will follow the parent process.", &setlist);
d4333 2
a4334 1
  c = add_set_enum_cmd ("scheduler-locking", class_run, scheduler_enums,	/* array of string names */
d4341 2
a4342 1
	Other threads may run while stepping over a function call ('next').", &setlist);
d4348 2
a4349 2
		   var_boolean, (char *) &step_stop_if_no_debug,
		   "Set mode of the step operation. When set, doing a step over a\n\
d4352 2
a4353 1
the step command stops at a different source line.", &setlist);
@


1.58.6.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d3920 1
a3920 1
  regcache_raw_write (inf_status->registers, regno, buf);
@


1.58.6.4
log
@        * infrun.c (handle_inferior_event): Add context_changed_event.
        * gdb-events.sh (context_hook): Removed comment.
        (context_changed): Add new event.
        * gdb-events.c: Regenerate.
        * gdb-events.h: Regenerate.
@
text
@a1949 1
      context_changed_event (pid_to_thread_id (ecs->ptid));
@


1.58.6.5
log
@        * thread.c (do_captured_thread_select): Add context-changed
        notification.
        * infrun.c (handle_inferior_event): Remove context-changed
        notification. The stop result already has this information.

        * thread.c (do_captured_list_thread_ids): Use ui_out_list_begin/end
        instead of ui_out_tuple_begin/end.
@
text
@d1950 1
@


1.58.6.6
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d176 7
d1000 10
a1009 3
      insert_breakpoints ();
      /* If we get here there was no call to error() in 
	 insert breakpoints -- so they were inserted.  */
a1410 1
  int sw_single_step_trap_p = 0;
d1829 4
a1832 5
      /* Check if a regular breakpoint has been hit before checking
         for a potential single step breakpoint. Otherwise, GDB will
         not see this breakpoint hit when stepping onto breakpoints.  */
      if (breakpoints_inserted
          && breakpoint_here_p (stop_pc - DECR_PC_AFTER_BREAK))
a1887 16
      else if (SOFTWARE_SINGLE_STEP_P () && singlestep_breakpoints_inserted_p)
        {
          /* Readjust the stop_pc as it is off by DECR_PC_AFTER_BREAK
             compared to the value it would have if the system stepping
             capability was used. This allows the rest of the code in
             this function to use this address without having to worry
             whether software single step is in use or not.  */
          if (DECR_PC_AFTER_BREAK)
            {
              stop_pc -= DECR_PC_AFTER_BREAK;
              write_pc_pid (stop_pc, ecs->ptid);
            }

          sw_single_step_trap_p = 1;
          ecs->random_signal = 0;
        }
d2102 1
a2102 1
	     jump to the instruction following a trap instruction.
d2104 14
a2117 15
             Therefore, pass TRUE if our reason for stopping is
             something other than hitting a breakpoint.  We do this by
             checking that either: we detected earlier a software single
             step trap or, 1) stepping is going on and 2) we didn't hit
             a breakpoint in a signal handler without an intervening stop
             in sigtramp, which is detected by a new stack pointer value
             below any usual function calling stack adjustments.  */
	  stop_bpstat =
            bpstat_stop_status
              (&stop_pc,
               sw_single_step_trap_p
               || (currently_stepping (ecs)
                   && prev_pc != stop_pc - DECR_PC_AFTER_BREAK
                   && !(step_range_end
                        && INNER_THAN (read_sp (), (step_sp - 16)))));
d3369 10
@


1.58.6.7
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d3534 3
a3536 1
signal_stop_update (int signo, int state)
d3544 3
a3546 1
signal_print_update (int signo, int state)
d3554 3
a3556 1
signal_pass_update (int signo, int state)
@


1.58.6.8
log
@merge from mainline
@
text
@d234 7
d873 7
a879 8
      if (CANNOT_STEP_BREAKPOINT)
	{
	  /* Most targets can step a breakpoint instruction, thus
	     executing it normally.  But if this one cannot, just
	     continue and we will hit it anyway.  */
	  if (step && breakpoints_inserted && breakpoint_here_p (read_pc ()))
	    step = 0;
	}
d2612 1
a2612 1
	  init_sal (&sr_sal);
d2665 1
a2665 1
	    init_sal (&sr_sal);
d2778 1
a2778 1
	      init_sal (&xxx);	/* initialize to zeroes */
d2853 1
a2853 1
	  init_sal (&sr_sal);	/* initialize to zeroes */
d2969 1
a2969 1
      init_sal (&sr_sal);	/* initialize to zeroes */
d3025 1
a3025 1
      init_sal (&sr_sal);	/* initialize to zeroes */
d3060 1
a3060 1
  init_sal (&sr_sal);		/* initialize to zeros */
@


1.58.4.1
log
@regbuf
@
text
@a44 1
#include "regbuf.h"
d65 4
d344 1
a344 1
struct regbuf *stop_registers;
d3508 1
a3508 1
    regcache_save (stop_registers);
d3914 1
a3914 1
  struct regbuf *stop_registers;
d3919 1
a3919 1
  struct regbuf *registers;
d3927 18
d3952 1
a3952 1
  regbuf_write (inf_status->registers, regno, buf);
d3962 1
a3962 1
  struct inferior_status *inf_status = XMALLOC (struct inferior_status);
d3986 3
a3988 3
  inf_status->stop_registers = regbuf_dup (stop_registers);
  inf_status->registers = regbuf_xmalloc (current_gdbarch);
  regcache_save (inf_status->registers);
d4052 2
a4053 3
  /* FIXME: Is the restore of stop_registers always needed?  */
  regbuf_xfree (stop_registers);
  stop_registers = inf_status->stop_registers;
d4058 1
a4058 2
    regcache_restore (inf_status->registers);
  regbuf_xfree (inf_status->registers);
d4086 1
a4086 1
  xfree (inf_status);
d4106 1
a4106 3
  regbuf_xfree (inf_status->registers);
  regbuf_xfree (inf_status->stop_registers);
  xfree (inf_status);
d4197 1
a4197 1
  stop_registers = regbuf_xmalloc (current_gdbarch);
d4206 2
@


1.58.4.2
log
@regbuf->regcache
@
text
@d45 1
d341 1
a341 1
struct regcache *stop_registers;
d3911 1
a3911 1
  struct regcache *stop_registers;
d3916 1
a3916 1
  struct regcache *registers;
d3931 1
a3931 1
  regcache_write (inf_status->registers, regno, buf);
d3965 2
a3966 2
  inf_status->stop_registers = regcache_dup (stop_registers);
  inf_status->registers = regcache_xmalloc (current_gdbarch);
d4032 1
a4032 1
  regcache_xfree (stop_registers);
d4039 1
a4039 1
  regcache_xfree (inf_status->registers);
d4087 2
a4088 2
  regcache_xfree (inf_status->registers);
  regcache_xfree (inf_status->stop_registers);
d4180 1
a4180 1
  stop_registers = regcache_xmalloc (current_gdbarch);
@


1.58.4.3
log
@introduce regcache_move.
Fix cases where normal vs no_passthroug copies didn't reflect the old code.
@
text
@d3964 3
a3966 3
  inf_status->stop_registers = regcache_dup_no_passthrough (stop_registers);

  inf_status->registers = regcache_dup (current_regcache);
d4030 1
a4030 1
  /* FIXME: Is the restore of stop_registers always needed. */
@


1.58.4.4
log
@merge from trunk
@
text
@d3917 1
a3917 3
  /* A frame unique identifier.  */
  struct frame_id selected_frame_id;

d3968 2
a3969 1
  get_frame_id (selected_frame, &inf_status->selected_frame_id);
d3973 6
d3982 2
a3983 1
  struct frame_id *fid =  (struct frame_id *) args;
d3985 1
d3987 1
a3987 1
  frame = frame_find_by_id (*fid);
d3991 9
a3999 1
  if (frame == NULL)
d4049 3
d4053 3
a4055 3
         walking the stack might encounter a garbage pointer and
         error() trying to dereference it.  */
      if (catch_errors (restore_selected_frame, &inf_status->selected_frame_id,
d4060 2
@


1.58.4.5
log
@Merge with trunk.
@
text
@d3909 1
a3915 3

  /* A frame unique identifier.  */
  struct frame_id selected_frame_id;
@


1.58.4.6
log
@(more) Merge with trunk.
@
text
@d3919 3
@


1.58.4.7
log
@merge with trunk
@
text
@d3504 1
a3504 3
    /* NB: The copy goes through to the target picking up the value of
       all the registers.  */
    regcache_cpy (stop_registers, current_regcache);
d4021 1
a4021 2
    /* NB: The register write goes through to the target.  */
    regcache_cpy (current_regcache, inf_status->registers);
@


1.57
log
@* arch-utils.h: Update copyright.

* gdbarch.sh (PC_IN_SIGTRAMP): Add.
* gdbarch.h, gdbarch.c: Re-generate.

* inferior.h (IN_SIGTRAMP): Delete definition.
* arch-utils.c (legacy_pc_in_sigtramp): New function.
* arch-utils.h (legacy_pc_in_sigtramp): Declare.

* mips-tdep.c (mips_init_extra_frame_info): Use PC_IN_SIGTRAMP.
(mips_dump_tdep): Do not print value of IN_SIGTRAMP.
* hppa-tdep.c (pc_in_interrupt_handler):  Use PC_IN_SIGTRAMP.
(find_proc_framesize): Ditto.
* alpha-tdep.c (alpha_osf_skip_sigtramp_frame): Ditto.
(alpha_init_extra_frame_info): Ditto.
* infrun.c (handle_inferior_event): Ditto.
(handle_inferior_event): Ditto.
(check_sigtramp2): Ditto.
* blockframe.c (create_new_frame): Ditto.
(get_prev_frame): Ditto.
* ppc-linux-tdep.c: Update comments.
* i386-linux-tdep.c: Update comments.
* breakpoint.c (bpstat_what): Update comment.

* gdbint.texinfo (Target Architecture Definition): Replace
IN_SIGTRAMP with PC_IN_SIGTRAMP.
@
text
@d3444 1
a3444 1
      select_frame (get_current_frame (), 0);
d3520 1
a3520 1
      select_frame (get_current_frame (), 0);
d4027 1
a4027 1
  select_frame (frame, fr->level);
d4082 1
a4082 1
	select_frame (get_current_frame (), 0);
@


1.56
log
@* cli/cli-decode.c (cmd_type): New function.
* command.h (cmd_type): Declare.
* infrun.c (set_schedlock_func): Call function cmd_type.
* kod.c (kod_set_os): Call cmd_type.
* cris-tdep.c (cris_version_update): Use function cmd_type.
(cris_mode_update, cris_abi_update): Ditto.
@
text
@d2643 2
a2644 2
    if (IN_SIGTRAMP (stop_pc, ecs->stop_func_name)
	&& !IN_SIGTRAMP (prev_pc, prev_func_name)
d2755 1
a2755 1
	    if (IN_SIGTRAMP (stop_pc, ecs->stop_func_name)
d2964 2
a2965 2
      && IN_SIGTRAMP (stop_pc, ecs->stop_func_name)
      && !IN_SIGTRAMP (prev_pc, prev_func_name)
@


1.55
log
@* command.h: (execute_cmd_post_hook): Declare.
(execute_cmd_pre_hook): Declare.
* cli/cli-script.c (clear_hook_in_cleanup): New function.
(execute_cmd_post_hook, execute_cmd_pre_hook): New
functions. Execute pre/post hook while ensuring that afterwords
hook_in is cleared.
* top.c (execute_command): Use execute_cmd_post_hook, and
execute_cmd_pre_hook to execute pre/post commands.
* infrun.c (normal_stop): Pass stop_command and not pre_hook to
hook_stop_stub.
(hook_stop_stub): Call execute_cmd_pre_hook.
@
text
@d752 9
a760 1
  if (c->type == set_cmd)
@


1.54
log
@s/Linux/.../
Fix PR gdb/378.
@
text
@d3417 5
a3421 7
  /* Look up the hook_stop and run it if it exists.  */

  if (stop_command && stop_command->hook_pre)
    {
      catch_errors (hook_stop_stub, stop_command->hook_pre,
		    "Error while running hook_stop:\n", RETURN_MASK_ALL);
    }
d3522 1
a3522 1
  execute_user_command ((struct cmd_list_element *) cmd, 0);
@


1.53
log
@* gdbarch.sh (GET_LONGJMP_TARGET): Add rule.
* gdbarch.c gdbarch.h: Regenerate.
* breakpoint.c (create_longjmp_breakpoint): Always compile this
function.
(breakpoint_reset): Test GET_LONGJMP_TARGET_P().
* infrun.c (GET_LONGJMP_TARGET): Delete default definition.
(handle_inferior_event): Test GET_LONGJMP_TARGET_P().

* arm-tdep.h (struct gdbarch_tdep): Add jb_pc and jb_elt_size fields.
* arm-tdep.c (arm_get_longjmp_target): New function.
(arm_gdbarch_init): Initialize jb_pc to -1.  If ABI handler changes
this to a positive value register arm_get_longjmp_target as the
longjmp handler.
* arm-linux-tdep.c (arm_get_longjmp_target): Delete.
(arm_linux_init_abi): Set up longjmp description in tdep.
* armnbsd-nat.c (get_longjmp_target): Delete.
* armnbsd-tdep.c (arm_netbsd_init_abi_common): Set up longjmp
description in tdep.
* config/arm/tm-nbsd.h (JB_ELEMENT_SIZE, JB_PC): Delete.
(get_longjmp_target): Delete declaration.
(GET_LONGJMP_TARGET): Delete.
* config/arm/tm-linux.h (arm_get_longjmp_target): Delete declaration.
(GET_LONGJMP_TARGET): Delete.
@
text
@d1 2
a2 1
/* Target-struct-independent code to start (run) and stop an inferior process.
d146 6
a151 6
   However, on some systems (e.g., Red Hat Linux 5.2) the dynamic
   linker calls functions in the shared C library, so you can't tell
   from the PC alone whether the dynamic linker is still running.  In
   this case, we use a step-resume breakpoint to get us past the
   dynamic linker, as if we were using "next" to step over a function
   call.
@


1.52
log
@* cli/cli-decode.c (do_cfunc, set_cmd_cfunc): New functions.
(do_sfunc, set_cmd_sfunc): New functions.

* command.h (struct cmd_list_element): Add field func.
* cli/cli-decode.h (struct cmd_list_element): Ditto.
* command.h (set_cmd_sfunc, set_cmd_cfunc): Declare.
* cli/cli-decode.h: Ditto.

* cli/cli-decode.c (help_cmd): Test for func not cfunc/sfunc.
(help_all, help_cmd_list): Ditto.
(find_cmd, complete_on_cmdlist): Ditto.
* top.c (execute_command): Ditto.

* cli/cli-setshow.c (do_setshow_command): Call func instead of
function.sfunc.

* infcmd.c (notice_args_read): Fix function signature.

* cli/cli-cmds.c (init_cli_cmds): Use set_cmd_sfunc.
* cli/cli-decode.c (add_set_cmd): Ditto.
* utils.c (initialize_utils): Ditto.
* maint.c (_initialize_maint_cmds): Ditto.
* infrun.c (_initialize_infrun): Ditto.
* demangle.c (_initialize_demangler): Ditto.
* remote.c (add_packet_config_cmd): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* cris-tdep.c (_initialize_cris_tdep): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* kod.c (_initialize_kod): Ditto.
* valprint.c (_initialize_valprint): Ditto.
* top.c (init_main): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
* arm-tdep.c (_initialize_arm_tdep): Ditto.
* arch-utils.c (initialize_current_architecture): Ditto.
(_initialize_gdbarch_utils): Ditto.
* alpha-tdep.c (_initialize_alpha_tdep): Ditto.

* cli/cli-decode.c (add_cmd): Use set_cmd_cfunc.
* wince.c (_initialize_inftarg): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* language.c (_initialize_language): Ditto.
* arc-tdep.c (_initialize_arc_tdep): Ditto.
@
text
@a116 9
/* GET_LONGJMP_TARGET returns the PC at which longjmp() will resume the
   program.  It needs to examine the jmp_buf argument and extract the PC
   from it.  The return value is non-zero on success, zero otherwise. */

#ifndef GET_LONGJMP_TARGET
#define GET_LONGJMP_TARGET(PC_ADDR) 0
#endif


d2300 2
a2301 1
	  if (!GET_LONGJMP_TARGET (&jmp_buf_pc))
@


1.51
log
@* utils.c (error_begin): Make static.
* defs.h (error_begin): Delete declaration.

* linespec.c (cplusplus_error): Replace cplusplus_hint.
(decode_line_1): Use cplusplus_error instead of error_begin,
cplusplus_hint and return_to_top_level.
* coffread.c (coff_symfile_read): Use error instead of error_begin
and return_to_top_level.
* infrun.c (default_skip_permanent_breakpoint): Ditto.
@
text
@a4352 1
/*  c->function.sfunc = ; */
d4366 1
a4366 1
  c->function.sfunc = set_schedlock_func;	/* traps on target vector */
@


1.50
log
@Remove else clause to #if UI_OUT.
@
text
@d235 1
a235 2
  error_begin ();
  fprintf_filtered (gdb_stderr, "\
d238 1
a238 2
a command like `return' or `jump' to continue execution.\n");
  return_to_top_level (RETURN_ERROR);
@


1.49
log
@Approved by kev@@cygnus.com
ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* coff-solib.c (coff_solib_add): Add new readsyms arg.
	* irix5-nat.c (solib_add): Ditto.
	* osfsolib.c (solib_add): Ditto.
	* pa64solib.c (pa64_solib_add): Ditto.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* solib.c (solib_add): Ditto.
	* somsolib.c (som_solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* coff-solib.h (coff_solib_add): Add new readsyms arg to prototype.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* pa64solib.h (pa64_solib_add): Ditto.
	* solib.h (solib_add): Ditto.
	* somsolib.h (som_solib_add): Ditto.
	* config/i386/tm-cygwin.h (child_solib_add): Ditto.

	* coff-solib.c (coff_solib_add):  If readsyms is zero don't read
	symbols but do any other needed work for shared libs.
	* irix5-nat.c: Ditto.
	* osfsolib.c (solib_add): Ditto.
	* solib.c (solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* irix5-nat.c (sharedlibrary_command): Pass 1 as readsyms to
	solib_add to force reading of shared library symbols.
	* osfsolib.c (sharedlibrary_command;): Ditto.
	* pa64solib.c (pa64_solib_sharedlibrary_command): Ditto.
	* solib.c (sharedlibrary_command): Ditto.
	* somsolib.c (som_solib_sharedlibrary_command): Ditto.
	* xcoffsolib.c (sharedlibrary_command): Ditto.

	* coff-solib.c (coff_solib_create_inferior_hook): Call solib_add
	unconditionally with auto_solib_add.
	* irix5-nat.c (solib_create_inferior_hook): Ditto.
	* osfsolib.c (solib_create_inferior_hook): Ditto.
	* solib.c (solib_create_inferior_hook): Ditto.
	* solib-osf.c (osf_solib_create_inferior_hook): Ditto.
	* solib-svr4.c (enable_break): Ditto.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Ditto.

	* corelow.c (solib_add_stub): Add auto_solib_add to args passed
	via SOLIB_ADD.
	* sol-thread.c (sol_thread_attach): Ditto.
	* config/rs6000/nm-rs6000.h (SOLIB_ADD): Ditto.

	* infcmd.c (attach_command): Remove auto_solib_add decl.
	Call SOLIB_ADD directly with auto_solib_add.
	* infrun.c (handle_inferior_event): Ditto.

	* coff-solib.h (SOLIB_ADD): Add readsyms arg.
	* pa64solib.h (SOLIB_ADD): Ditto.
	* solib.h (SOLIB_ADD): Ditto.
	* somsolib.h (SOLIB_ADD): Ditto.
	* config/i386/tm-cygwin.h (SOLIB_ADD): Ditto.

	* fork-child.c (clone_and_follow_inferior): Remove unused
	auto_solib_add decl.

	* pa64solib.c (pa64_solib_add): Call add_to_solist with readsyms.
	(read_dld_descriptor): Ditto.
	(pa64_solib_add): Call read_dld_descriptor with	readsyms.
	(pa64_solib_in_dynamic_linker): Ditto.

	* corelow.c (symfile.h): Need this for auto_solib_add declaration.
	* sol-thread.c (symfile.h): Ditto.

Approved by eliz@@is.elta.co.il
doc/ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* gdbint.texinfo (SOLIB_ADD): Document additional new
	"readsyms" arg.
@
text
@d2 4
a5 2
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
a1473 1
#ifdef UI_OUT
a1476 3
#else
	printf_filtered ("[New %s]\n", target_pid_or_tid_to_str (ecs->ptid));
#endif
a3284 1
#ifdef UI_OUT
a3289 1
#endif
a3296 1
#ifdef UI_OUT
a3309 15
#else
      annotate_signalled ();
      printf_filtered ("\nProgram terminated with signal ");
      annotate_signal_name ();
      printf_filtered ("%s", target_signal_to_name (stop_info));
      annotate_signal_name_end ();
      printf_filtered (", ");
      annotate_signal_string ();
      printf_filtered ("%s", target_signal_to_string (stop_info));
      annotate_signal_string_end ();
      printf_filtered (".\n");

      printf_filtered ("The program no longer exists.\n");
      gdb_flush (gdb_stdout);
#endif
a3312 1
#ifdef UI_OUT
a3327 8
#else
      annotate_exited (stop_info);
      if (stop_info)
	printf_filtered ("\nProgram exited with code 0%o.\n",
			 (unsigned int) stop_info);
      else
	printf_filtered ("\nProgram exited normally.\n");
#endif
a3331 1
#ifdef UI_OUT
a3343 13
#else
      annotate_signal ();
      printf_filtered ("\nProgram received signal ");
      annotate_signal_name ();
      printf_filtered ("%s", target_signal_to_name (stop_info));
      annotate_signal_name_end ();
      printf_filtered (", ");
      annotate_signal_string ();
      printf_filtered ("%s", target_signal_to_string (stop_info));
      annotate_signal_string_end ();
      printf_filtered (".\n");
      gdb_flush (gdb_stdout);      
#endif
a3486 1
#ifdef UI_OUT
a3490 1
#endif
a3491 1
#ifdef UI_OUT
a3494 1
#endif
@


1.48
log
@	* arch-utils.c (generic_in_solib_call_trampoline): New function.
	* arch-utils.h (generic_in_solib_call_trampoline): Extern declaration.
	* gdbarch.c: Regenerated from gdbarch.sh.
	* gdbarch.h: Ditto.
	* gdbarch.sh (function_list): Add `IN_SOLIB_CALL_TRAMPOLINE' definition.
	* infrun.c (IN_SOLIB_CALL_TRAMPOLINE): Remove macro.
@
text
@d1521 6
a1526 9
	       supposed to be adding them automatically.  */
	    if (auto_solib_add)
	      {
		/* Switch terminal for any messages produced by
		   breakpoint_re_set.  */
		target_terminal_ours_for_output ();
		SOLIB_ADD (NULL, 0, NULL);
		target_terminal_inferior ();
	      }
d2446 6
a2451 9
	       supposed to be adding them automatically.  */
	    if (auto_solib_add)
	      {
		/* Switch terminal for any messages produced by
		   breakpoint_re_set.  */
		target_terminal_ours_for_output ();
		SOLIB_ADD (NULL, 0, NULL);
		target_terminal_inferior ();
	      }
@


1.47
log
@Add explicit #include of "value.h".
@
text
@a185 8
/* For SVR4 shared libraries, each call goes through a small piece of
   trampoline code in the ".plt" section.  IN_SOLIB_CALL_TRAMPOLINE evaluates
   to nonzero if we are current stopped in one of these. */

#ifndef IN_SOLIB_CALL_TRAMPOLINE
#define IN_SOLIB_CALL_TRAMPOLINE(pc,name)	0
#endif

@


1.46
log
@        * arch-utils.c (generic_skip_trampoline_code): New function.
        * arch-utils.h (generic_skip_trampoline_code): Declare external.
        * gdbarch.c: Regeberated from gdbarch.sh.
        * gdbarch.h: Ditto.
        * gdbarch.sh (SKIP_TRAMPOLINE_CODE): Multi-arch.
        * infrun.c: Remove default setting of SKIP_TRAMPOLINE_CODE macro.
@
text
@d41 1
@


1.45
log
@2001-07-16  Elena Zannoni  <ezannoni@@redhat.com>

        * top.c (is_complete_command, init_cmd_lists, init_cli_cmds,
        execute_user_command, do_setshow_command, get_prompt, init_proc,
        serial_log_command): Remove extern declarations.  Include
        cli/cli-cmds.h, cli/cli-script.h, cli/cli-setshow.h, serial.h.
        * gdbcmd.h (execute_user_command): Remove declaration, it's already
        in cli/cli-script.h.
        * command.h (do_setshow_command): Remove declaration, it's already
        in cli/cli-setshow.h.
        * infrun.c: Include "cli/cli-script.h" for execute_user_command.
        * Makefile.in (infrun.o): Update dependencies.
        (top.o): Ditto.
        * cli/cli-setshow.h: Add comment for do_setshow_command.
@
text
@a122 8
/* Some machines have trampoline code that sits between function callers
   and the actual functions themselves.  If this machine doesn't have
   such things, disable their processing.  */

#ifndef SKIP_TRAMPOLINE_CODE
#define	SKIP_TRAMPOLINE_CODE(pc)	0
#endif

@


1.44
log
@	* utils.c (query): Remove tui hacks; tui must use the query_hook.
	* top.c (command_loop): Remove tui insert_mode hacks; don't call
	tuiCleanUp because this must be made with atexit by tui.
	* symfile.c (symbol_file_command): Remove call to TUIDO
	* stack.c (show_and_print_stack_frame_stub): Remove tui check;
	not necessary when using the selected frame hooks.
	(print_stack_frame_stub): Likewise.
	(print_frame_info_base): Likewise.
	(print_frame_info): Likewise.
	(up_silently_command): Likewise.
	(down_silently_command): Likewise.
	(show_stack_frame): Likewise for TUIDO.
	(select_frame): Likewise.
	(select_and_print_frame): Likewise.
	(stack_publish_stopped_with_no_frame): Remove.
	(select_and_maybe_print_frame): Remove.
	* main.c (captured_main): Remove tui_fileopen and tuiInit; tui
	must use the initialize ui hook.
	* infrun.c (normal_stop): Remove call to TUIDO; tui must use the
	selected frame hooks.
	* event-top.c (command_handler): Remove tui insert_mode hack.
	* defs.h: Remove TUIDO; Only include tui.h.
	* breakpoint.c (mention): Remove calls to TUIDO.
	(delete_breakpoint): Remove tui hacks; tui must install
	the breakpoint hooks.
@
text
@d32 1
@


1.43
log
@	* infrun.c (print_stop_reason): Add missing uiout field
	"reason" for SIGNAL_RECEIVED case.
@
text
@a3592 3

  TUIDO (((TuiOpaqueFuncPtr) tui_vCheckDataValues, selected_frame));

@


1.42
log
@Replace:
  if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
with:
  if (ui_out_is_mi_like_p (uiout))
@
text
@d3385 2
@


1.42.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d722 1
a722 1
  symbol_file_command (execd_pathname, 0);
@


1.41
log
@From Fernando Nasser:
* infrun.c (handle_inferior_event): Handle "nexti" inside function
prologues.
@
text
@d3311 1
a3311 1
	if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d3323 1
a3323 1
      if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d3357 1
a3357 1
	  if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d3365 1
a3365 1
	  if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d3551 1
a3551 1
	  if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
d3556 1
a3556 1
	  if (interpreter_p && strncmp (interpreter_p, "mi", 2) == 0)
@


1.40
log
@2001-06-28  Michael Snyder  <msnyder@@redhat.com>

	* infrun.c (handle_inferior_event): Replace prev_pc test in all
	calls to bpstat_stop_status (removed in 1999-09-24).  This test
	helps distinguish stepping over a breakpoint trap from stepping
	thru a jump to the instruction after a breakpoint trap.
	(handle_inferior_event): Don't bother writing the PC if
	DECR_PC_AFTER_BREAK is zero (optimization).
	* breakpoint.c (bpstat_stop_status): Add comment explaining the
	purpose and usage of the "not_a_breakpoint" argument in computing
	the breakpoint address.
@
text
@d2758 3
a2760 1
	if (step_over_calls == STEP_OVER_NONE)
d2765 3
@


1.39
log
@2001-06-25  Michael Snyder  <msnyder@@redhat.com>

	* infrun.c: Eliminate the "thread_step_needed" state variable,
	and replace it with a relatively simple test in resume.
	(resume): Replace thread_step_needed logic with a test for
	stepping, breakpoint_here_p and breakpoints_inserted.
	Move CANNOT_STEP_BREAKPOINT logic to after thread_step logic.
	(proceed): Discard thread_step_needed logic.
	(wait_for_inferior, fetch_inferior_event, handle_inferior_event):
	Discard thread_step_needed logic.
@
text
@d1620 11
a1630 1
	stop_bpstat = bpstat_stop_status (&stop_pc, currently_stepping (ecs));
d1679 11
a1689 1
	stop_bpstat = bpstat_stop_status (&stop_pc, currently_stepping (ecs));
d1754 11
a1764 1
	stop_bpstat = bpstat_stop_status (&stop_pc, currently_stepping (ecs));
d1873 2
a1874 1
		write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK, ecs->ptid);
d1886 3
a1888 1
		    write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK + 4, ecs->ptid);
d2052 2
a2053 1
	write_pc (stop_pc - DECR_PC_AFTER_BREAK);
d2134 8
d2151 1
@


1.38
log
@Recognize -i=mi0, -i=mi1 and -i=mi.
@
text
@a112 25
/* resume and wait_for_inferior use this to ensure that when
   stepping over a hit breakpoint in a threaded application
   only the thread that hit the breakpoint is stepped and the
   other threads don't continue.  This prevents having another
   thread run past the breakpoint while it is temporarily
   removed.

   This is not thread-specific, so it isn't saved as part of
   the infrun state.

   Versions of gdb which don't use the "step == this thread steps
   and others continue" model but instead use the "step == this
   thread steps and others wait" shouldn't do this.  */

static int thread_step_needed = 0;

/* This is true if thread_step_needed should actually be used.  At
   present this is only true for HP-UX native.  */

#ifndef USE_THREAD_STEP_NEEDED
#define USE_THREAD_STEP_NEEDED (0)
#endif

static int use_thread_step_needed = USE_THREAD_STEP_NEEDED;

d799 2
a800 7
#ifdef CANNOT_STEP_BREAKPOINT
  /* Most targets can step a breakpoint instruction, thus executing it
     normally.  But if this one cannot, just continue and we will hit
     it anyway.  */
  if (step && breakpoints_inserted && breakpoint_here_p (read_pc ()))
    step = 0;
#endif
d883 4
a886 1
      if (use_thread_step_needed && thread_step_needed)
d888 4
a891 4
	  /* We stopped on a BPT instruction;
	     don't continue other threads and
	     just step this thread. */
	  thread_step_needed = 0;
d893 1
a893 18
	  if (!breakpoint_here_p (read_pc ()))
	    {
	      /* Breakpoint deleted: ok to do regular resume
	         where all the threads either step or continue. */
	      resume_ptid = RESUME_ALL;
	    }
	  else
	    {
	      if (!step)
		{
		  warning ("Internal error, changing continue to step.");
		  remove_breakpoints ();
		  breakpoints_inserted = 0;
		  trap_expected = 1;
		  step = 1;
		}
	      resume_ptid = inferior_ptid;
	    }
d895 4
a898 1
      else
d900 1
a900 3
	  /* Vanilla resume. */
	  if ((scheduler_mode == schedlock_on) ||
	      (scheduler_mode == schedlock_step && step != 0))
a901 2
	  else
	    resume_ptid = RESUME_ALL;
d903 8
a984 10

      /* New address; we don't need to single-step a thread
         over a breakpoint we just hit, 'cause we aren't
         continuing from there.

         It's not worth worrying about the case where a user
         asks for a "jump" at the current PC--if they get the
         hiccup of re-hiting a hit breakpoint, what else do
         they expect? */
      thread_step_needed = 0;
a1001 1
      thread_step_needed = 1;
a1241 2
  thread_step_needed = 0;

a1299 2
      thread_step_needed = 0;

a1448 5
	/* Since we've done a wait, we have a new event.  Don't
	   carry over any expectations about needing to step over a
	   breakpoint. */
	thread_step_needed = 0;

a1879 1
		    thread_step_needed = 1;
a1881 7
		    /* keep_stepping will call resume, and the
		       combination of "thread_step_needed" and
		       "ecs->another_trap" will cause resume to
		       solo-step the thread.  The subsequent trap
		       event will be handled like any other singlestep
		       event. */

a1887 8
	    else
	      {
		/* This breakpoint matches--either it is the right
		   thread or it's a generic breakpoint for all threads.
		   Remember that we'll need to step just _this_ thread
		   on any following user continuation! */
		thread_step_needed = 1;
	      }
a2342 1
	      thread_step_needed = 1;
@


1.37
log
@2001-06-15  Michael Snyder  <msnyder@@redhat.com>

	* infrun.c (context_switch): New function.  Abstract the operation
	of saving and restoring infrun's state when switching threads.
	(handle_inferior_event): Normalize the handling of the 'thread hop'
	event (when the wrong thread hits a thread-specific breakpoint,
	and we need to solo-step that thread past the breakpoint).
	Call keep_going, instead of target_resume.  Handle the subsequent
	singlestep-trap as a normal event instead of just resuming.
@
text
@d3337 1
a3337 1
	if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d3349 1
a3349 1
      if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d3383 1
a3383 1
	  if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d3391 1
a3391 1
	  if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d3577 1
a3577 1
	  if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
d3582 1
a3582 1
	  if (interpreter_p && strcmp (interpreter_p, "mi") == 0)
@


1.36
log
@2001-06-13  Michael Snyder  <msnyder@@redhat.com>

        * gdbthread.h (struct thread_info): Add new fields:
        current_line, current_symtab, step_sp, for saved infrun state.
        * thread.c (save_infrun_state, load_infrun_state): Save and
        restore current_line, current_symtab, and step_sp.
        (add_thread): Rather than adding assignments to initialize
	the new fields, just use memset (tp, 0, sizeof (*tp).
	This way future new fields will not be overlooked.
        * infrun.c (handle_inferior_event): Save and restore save_sp,
        current_line, and current_symtab when switching threads.
@
text
@a808 2


d1434 43
d1495 5
a1515 19
      case infwait_thread_hop_state:
	insert_breakpoints ();

	/* We need to restart all the threads now,
	 * unless we're running in scheduler-locked mode. 
	 * Use currently_stepping to determine whether to 
	 * step or continue.
	 */

	if (scheduler_mode == schedlock_on)
	  target_resume (ecs->ptid, 
			 currently_stepping (ecs), TARGET_SIGNAL_0);
	else
	  target_resume (RESUME_ALL, 
			 currently_stepping (ecs), TARGET_SIGNAL_0);
	ecs->infwait_state = infwait_normal_state;
	prepare_to_wait (ecs);
	return;

d1918 1
d1932 3
a1934 4
		    target_resume (ecs->ptid, 1, TARGET_SIGNAL_0);
		    /* FIXME: What if a signal arrives instead of the
		       single-step happening?  */

d1937 10
d1948 2
a1949 1
		    prepare_to_wait (ecs);
d2024 1
a2024 38
	/* Caution: it may happen that the new thread (or the old one!)
	   is not in the thread list.  In this case we must not attempt
	   to "switch context", or we run the risk that our context may
	   be lost.  This may happen as a result of the target module
	   mishandling thread creation.  */

	if (in_thread_list (inferior_ptid) && in_thread_list (ecs->ptid))
	  { /* Perform infrun state context switch: */
	    /* Save infrun state for the old thread.  */
	    save_infrun_state (inferior_ptid, prev_pc,
			       prev_func_start, prev_func_name,
			       trap_expected, step_resume_breakpoint,
			       through_sigtramp_breakpoint,
			       step_range_start, step_range_end,
			       step_frame_address, ecs->handling_longjmp,
			       ecs->another_trap,
			       ecs->stepping_through_solib_after_catch,
			       ecs->stepping_through_solib_catchpoints,
			       ecs->stepping_through_sigtramp,
			       ecs->current_line, ecs->current_symtab, 
			       step_sp);

	    /* Load infrun state for the new thread.  */
	    load_infrun_state (ecs->ptid, &prev_pc,
			       &prev_func_start, &prev_func_name,
			       &trap_expected, &step_resume_breakpoint,
			       &through_sigtramp_breakpoint,
			       &step_range_start, &step_range_end,
			       &step_frame_address, &ecs->handling_longjmp,
			       &ecs->another_trap,
			       &ecs->stepping_through_solib_after_catch,
			       &ecs->stepping_through_solib_catchpoints,
			       &ecs->stepping_through_sigtramp, 
			       &ecs->current_line, &ecs->current_symtab,
			       &step_sp);
	  }

	inferior_ptid = ecs->ptid;
@


1.35
log
@2001-06-01  Michael Snyder  <msnyder@@redhat.com>

	* thread.c (delete_step_resume_breakpoint): New function.
	Maintain internal consistency of the thread list while deleting
	a step_resume_breakpoint.
	* gdbthread.h (delete_step_resume_breakpoint): Export.
	* breakpoint.c (bpstat_find_step_resume_breakpoint):
	Make thread-aware: don't return a step_resume_breakpoint
	for the wrong thread.
	* infrun.c (wait_for_inferior): Call delete_step_resume_breakpoint
	instead of delete_breakpoint_current_contents.
	(fetch_inferior_event): Ditto.
	(handle_inferior_event): Call delete_step_resume_breakpoint
	instead of delete_breakpoint.
@
text
@d2004 3
a2006 1
			       ecs->stepping_through_sigtramp);
d2018 3
a2020 1
			       &ecs->stepping_through_sigtramp);
@


1.34
log
@2001-06-01  Michael Snyder  <msnyder@@redhat.com>

	* infrun.c (handle_inferior_event): After singlestepping over a
	thread-specific breakpoint, use currently_stepping() to decide
	whether to step or continue.
@
text
@d1280 1
a1280 1
  old_cleanups = make_cleanup (delete_breakpoint_current_contents,
d1344 1
a1344 1
      old_cleanups = make_exec_cleanup (delete_breakpoint_current_contents,
d2365 1
a2365 2
	      delete_breakpoint (step_resume_breakpoint);
	      step_resume_breakpoint = NULL;
d2463 1
a2463 2
	  delete_breakpoint (step_resume_breakpoint);
	  step_resume_breakpoint = NULL;
@


1.33
log
@Redefine ptid_t to be a struct rather than an int.
@
text
@d1475 2
a1476 1
	 * FIXME: shouldn't we look at currently_stepping ()?
d1478 1
d1480 2
a1481 1
	  target_resume (ecs->ptid, 0, TARGET_SIGNAL_0);
d1483 2
a1484 1
	  target_resume (RESUME_ALL, 0, TARGET_SIGNAL_0);
d1886 15
a1913 11

		/* We need to restart all the threads now,
		 * unles we're running in scheduler-locked mode. 
		 * FIXME: shouldn't we look at currently_stepping ()?
		 */
		if (scheduler_mode == schedlock_on)
		  target_resume (ecs->ptid, 0, TARGET_SIGNAL_0);
		else
		  target_resume (RESUME_ALL, 0, TARGET_SIGNAL_0);
		prepare_to_wait (ecs);
		return;
@


1.32
log
@Consolidate save_inferior_ptid/restore_inferior_ptid implementation to
one source file.
@
text
@d4195 61
a4255 1
/* Helper function for save_inferior_ptid */
d4463 6
@


1.31
log
@Phase 1 of the ptid_t changes.
@
text
@d4195 24
@


1.30
log
@2001-04-06  David Smith  <dsmith@@redhat.com>

	* arch-utils.c (default_prepare_to_proceed)
	(generic_prepare_to_proceed): Added new functions.
	* arch-utils.h: New function declarations for
	default_prepare_to_proceed() and generic_prepare_to_proceed().
	* gdbarch.sh: Added PREPARE_TO_PROCEED.
	* gdbarch.c: Regenerated.
	* gdbarch.h: Regenerated.
	* inferior.h: Added get_last_target_status() declaration.
	* infrun.c (get_last_target_status): Added new function.
	(handle_inferior_event): Saves last pid and waitstatus, which will
	get returned by get_last_target_status().

	* hppa-tdep.c (prepare_to_proceed):  Added comment stating that
	prepare_to_proceed() is potentially redundant since
	default_prepare_to_proceed() has been added.
	* linux-thread.c (prepare_to_proceed): Ditto.
	* lin-lwp.c (prepare_to_proceed): Ditto.
	* m3-nat.c (prepare_to_proceed): Ditto.
@
text
@d102 1
a102 1
static int previous_inferior_pid;
d335 3
d415 1
a415 1
static int target_last_wait_pid = -1;
d447 1
a447 1
   (In the latter case, inferior_pid is still the parent of the
d519 1
a519 1
     from inferior_pid, and set inferior_pid to child_pid. */
d542 1
a542 1
      SOLIB_REMOVE_INFERIOR_HOOK (inferior_pid);
d550 1
a550 1
      inferior_pid = child_pid;
d594 1
a594 1
      sprintf (pid_suffix, "[%d] ", inferior_pid);
d656 2
a657 1
  if (pending_follow.fork_event.saw_child_exec && (inferior_pid == child_pid))
d661 1
a661 1
      follow_exec (inferior_pid, pending_follow.execd_pathname);
d683 2
a684 1
      follow_vfork (inferior_pid, pending_follow.fork_event.child_pid);
d686 1
a686 1
      saved_pid = inferior_pid;
d690 1
a690 1
      if (inferior_pid == pending_follow.fork_event.parent_pid)
d739 2
a740 1
  inferior_pid = saved_pid;	/* Because mourn_inferior resets inferior_pid. */
d756 1
a756 1
  SOLIB_CREATE_INFERIOR_HOOK (inferior_pid);
d875 2
a876 1
      follow_fork (inferior_pid, pending_follow.fork_event.child_pid);
d884 2
a885 1
	follow_vfork (inferior_pid, pending_follow.fork_event.child_pid);
d892 1
a892 1
	    (inferior_pid == pending_follow.fork_event.child_pid))
d913 1
a913 1
      int resume_pid;
d926 1
a926 1
	      resume_pid = -1;
d938 1
a938 1
	      resume_pid = inferior_pid;
d946 1
a946 1
	    resume_pid = inferior_pid;
d948 1
a948 1
	    resume_pid = -1;
d950 1
a950 1
      target_resume (resume_pid, step, sig);
d1241 2
a1242 2
    int pid;
    int saved_inferior_pid;
d1251 1
a1251 1
    int waiton_pid;
d1295 1
a1295 1
  previous_inferior_pid = inferior_pid;
d1310 1
a1310 1
	ecs->pid = target_wait_hook (ecs->waiton_pid, ecs->wp);
d1312 1
a1312 1
	ecs->pid = target_wait (ecs->waiton_pid, ecs->wp);
d1355 1
a1355 1
      previous_inferior_pid = inferior_pid;
d1369 1
a1369 1
    async_ecs->pid = target_wait_hook (async_ecs->waiton_pid, async_ecs->wp);
d1371 1
a1371 1
    async_ecs->pid = target_wait (async_ecs->waiton_pid, async_ecs->wp);
d1409 1
a1409 1
  ecs->waiton_pid = -1;
d1430 1
a1430 1
get_last_target_status(int *pid, struct target_waitstatus *status)
d1432 1
a1432 1
  *pid = target_last_wait_pid;
d1447 1
a1447 1
  target_last_wait_pid = ecs->pid;
d1464 1
a1464 1
	    TARGET_ENABLE_HW_WATCHPOINTS (inferior_pid);
d1478 1
a1478 1
	  target_resume (ecs->pid, 0, TARGET_SIGNAL_0);
d1480 1
a1480 1
	  target_resume (-1, 0, TARGET_SIGNAL_0);
d1503 2
a1504 1
    ecs->new_thread_event = ((ecs->pid != inferior_pid) && !in_thread_list (ecs->pid));
d1510 1
a1510 1
	add_thread (ecs->pid);
d1514 1
a1514 1
	ui_out_text (uiout, target_pid_or_tid_to_str (ecs->pid));
d1517 1
a1517 1
	printf_filtered ("[New %s]\n", target_pid_or_tid_to_str (ecs->pid));
d1540 1
a1540 1
	target_resume (-1, 0, TARGET_SIGNAL_0);
d1628 1
a1628 1
	if (inferior_pid == ecs->pid)
d1631 1
a1631 1
	    pending_follow.fork_event.parent_pid = ecs->pid;
d1639 1
a1639 1
	    pending_follow.fork_event.child_pid = ecs->pid;
d1643 3
a1645 3
	stop_pc = read_pc_pid (ecs->pid);
	ecs->saved_inferior_pid = inferior_pid;
	inferior_pid = ecs->pid;
d1648 1
a1648 1
	inferior_pid = ecs->saved_inferior_pid;
d1668 1
a1668 1
	if (ecs->pid == inferior_pid)
d1671 1
a1671 1
	    pending_follow.fork_event.parent_pid = ecs->pid;
d1681 1
a1681 1
	    pending_follow.fork_event.child_pid = ecs->pid;
d1683 2
a1684 1
	    target_post_startup_inferior (pending_follow.fork_event.child_pid);
d1688 1
a1688 1
		target_resume (ecs->pid, 0, TARGET_SIGNAL_0);
d1711 1
a1711 1
	    target_resume (ecs->pid, 0, TARGET_SIGNAL_0);
d1722 1
a1722 1
	/* Did inferior_pid exec, or did a (possibly not-yet-followed)
d1746 1
a1746 1
	      target_resume (ecs->pid, 1, TARGET_SIGNAL_0);
d1754 1
a1754 1
	follow_exec (inferior_pid, pending_follow.execd_pathname);
d1757 3
a1759 3
	stop_pc = read_pc_pid (ecs->pid);
	ecs->saved_inferior_pid = inferior_pid;
	inferior_pid = ecs->pid;
d1762 1
a1762 1
	inferior_pid = ecs->saved_inferior_pid;
d1786 1
a1786 1
	    TARGET_DISABLE_HW_WATCHPOINTS (inferior_pid);
d1807 1
a1807 1
	target_resume (ecs->pid, 1, TARGET_SIGNAL_0);
d1843 1
a1843 1
	target_resume (-1, 0, TARGET_SIGNAL_0);
d1848 1
a1848 1
    stop_pc = read_pc_pid (ecs->pid);
d1863 1
a1863 1
					  ecs->pid))
d1869 1
a1869 1
		write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK, ecs->pid);
d1881 1
a1881 1
		    write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK + 4, ecs->pid);
d1885 1
a1885 1
		    target_resume (ecs->pid, 1, TARGET_SIGNAL_0);
d1889 1
a1889 1
		    ecs->waiton_pid = ecs->pid;
d1901 1
a1901 1
		  target_resume (ecs->pid, 0, TARGET_SIGNAL_0);
d1903 1
a1903 1
		  target_resume (-1, 0, TARGET_SIGNAL_0);
d1927 1
a1927 1
    if ((ecs->pid != inferior_pid) &&
d1970 1
a1970 1
	    target_resume (ecs->pid, 0, stop_signal);
d1984 1
a1984 1
	if (in_thread_list (inferior_pid) && in_thread_list (ecs->pid))
d1987 1
a1987 1
	    save_infrun_state (inferior_pid, prev_pc,
d1999 1
a1999 1
	    load_infrun_state (ecs->pid, &prev_pc,
d2011 1
a2011 1
	inferior_pid = ecs->pid;
d2014 1
a2014 1
	  context_hook (pid_to_thread_id (ecs->pid));
d2034 1
a2034 1
	target_resume (ecs->pid, 1, TARGET_SIGNAL_0);
d2041 1
a2041 1
	ecs->waiton_pid = ecs->pid;
d2083 1
a2083 1
	target_resume (ecs->pid, 1, TARGET_SIGNAL_0);	/* Single step */
d2085 1
a2085 1
	ecs->waiton_pid = ecs->pid;
d2571 1
a2571 1
	if (SOLIB_IN_DYNAMIC_LINKER (ecs->pid, stop_pc))
d3132 1
a3132 1
         parent's event.  And, inferior_pid is still set to the
d3136 1
a3136 1
         To ensure that we can really touch inferior_pid (aka, the
d3142 1
a3142 1
	  int parent_pid;
d3147 1
a3147 1
		parent_pid = target_wait_hook (-1, &(ecs->ws));
d3149 1
a3149 1
		parent_pid = target_wait (-1, &(ecs->ws));
d3151 1
a3151 1
	  while (parent_pid != inferior_pid);
d3296 1
a3296 1
      ecs->waiton_pid = -1;
d3446 1
a3446 1
  if ((previous_inferior_pid != inferior_pid)
d3451 2
a3452 2
		       target_pid_or_tid_to_str (inferior_pid));
      previous_inferior_pid = inferior_pid;
d3572 2
a3573 1
	    ui_out_field_int (uiout, "thread-id", pid_to_thread_id (inferior_pid));
d3856 1
a3856 1
  target_notice_signals (inferior_pid);
@


1.29
log
@-Wuninitialized fixes.
@
text
@d409 6
d1416 12
d1437 4
@


1.28
log
@Change SOFTWARE_SINGLE_STEP_P into SOFTWARE_SINGLE_STEP_P().
@
text
@d3524 1
@


1.27
log
@Update/correct copyright notices.
@
text
@d841 1
a841 1
  if (SOFTWARE_SINGLE_STEP_P && step)
d1565 1
a1565 1
	singlestep_breakpoints_inserted_p = 0;	/*SOFTWARE_SINGLE_STEP_P */
d1583 1
a1583 1
	singlestep_breakpoints_inserted_p = 0;	/*SOFTWARE_SINGLE_STEP_P */
d1824 1
a1824 1
	if (SOFTWARE_SINGLE_STEP_P && singlestep_breakpoints_inserted_p)
d1987 1
a1987 1
    if (SOFTWARE_SINGLE_STEP_P && singlestep_breakpoints_inserted_p)
@


1.26
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1986-1989, 1991-2000, 2001 Free Software Foundation, Inc.
@


1.25
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d38 1
@


1.24
log
@2001-01-26  Fernando Nasser  <fnasser@@redhat.com>

        Fix double parsing of filenames passed as command line arguments
        to GDB (causes weird handling of escape characters).
        Also, remove dependencies on the CLI from libgdb.
        * call-cmds.h: Remove declaration of exec_file_command().
        * gdbcore.h: Remove declaration of exec_file_command().
        Add declarations for exec_open() and exec_file_clear().
        * symfile.h: Add declarations for symbol_file_add_main() and
        symbol_file_clear().
        * exec.c (exec_open): New function. Implements to_open for exec
        targets.
        (exec_file_clear): New function. Makes GDB forget about a previously
        specified executable file.
        (exec_file_attach): Move parsing of arguments from here ...
        (exec_file_command): ... to here.
        (init_exec_ops): Use exec_open(), not exec_file_command() to
        implement to_open for exec targets.
        * symfile.c (symbol_file_add_main): New function. Call symbol_file_add()        with default values.  Used when the file name has already been parsed.
        (symbol_file_clear): New function. Makes GDB forget about previously
        read symbols.
        (symbol_file_command): Call the above function instead of inline code.
        * main.c: Include "symfile.h" and "gdbcore.h" instead of the deprecated
        "call-cmds.h".
        (captured_main): Call exec_file_attach() and symbol_file_add_main()
        instead of exec_file_command() and symbol_file_command().
        (captured_main): Add comment.
        * corefile.c: Include "symfile.h".
        (core_file_command): Call symbol_file_add_main() instead of
        symbol_file_command().
        (reopen_exec_file): Call exec_open() instead of exec_file_command().
        * infcmd.c: Include "symfile.h".
        (attach_command): Call symbol_file_add_main() instead of
        symbol_file_command().
        * infrun.c: Remove comment about the inclusion of "symfile.h",
        not any longer appropriate.
        (follow_exec): Call symbol_file_add_main() instead of
        symbol_file_command().
        * remote-es.c: Include "symfile.h".
        (es1800_load): Call symbol_file_add_main() instead of
        symbol_file_command().
        * remote-vx.c: Remove comment about the inclusion of "symfile.h",
        not any longer appropriate.
        (vx-wait): Call symbol_file_add_main() instead of
        symbol_file_command().
        * solib-svr4.c (open_symbol_file_object): Call symbol_file_add_main()
        instead of symbol_file_command().
        * v850ice.c (ice_file): Call exec_open(), exec_file_attach() and
        symbol_file_add_main() instead of exec_file_command() and
        symbol_file_command().
        * Makefile.in: Update dependencies.
@
text
@d2 1
a2 1
   Copyright 1986-1989, 1991-2000 Free Software Foundation, Inc.
d476 2
a477 1
      internal_error ("follow_inferior_fork: \"ask\" mode not implemented");
d3388 2
a3389 1
      internal_error ("print_stop_reason: unrecognized enum value");
d3525 2
a3526 1
	      internal_error ("Unknown value.");
@


1.23
log
@Replace free() with xfree().
@
text
@d34 1
a34 1
#include "symfile.h"		/* for overlay functions */
d653 2
d732 1
a732 1
  symbol_file_command (execd_pathname, 0);
@


1.22
log
@* inferior.h (step_over_calls_kind): New enum to clarify values in
step_over_calls.
* infcmd.c (step_over_calls): Change definition.
(step_1): Use new enum values in relation to step_over_calls.
(step_once): Ditto.
(until_next_command): Ditto.
* infrun.c (clear_proceed_status): Ditto.
(handle_inferior_event): Ditto.
* inferior.h (step_stop_if_no_debug): New variable.
* infrun.c (step_stop_if_no_debug): Declare.
(handle_inferior_event): Stop the step command if we entered a function without
line info.
(_initialize_infrun): New command 'set step-mode' to control the step command.
* infcmd.c (step_once): Switch to stepi mode if there is no line info
(and switching is enabled).
@
text
@d649 1
a649 1
      free (pending_follow.execd_pathname);
d1718 1
a1718 1
	free (pending_follow.execd_pathname);
d3894 1
a3894 1
	    free (argBuf);
d3985 3
a3987 3
  free (inf_status->registers);
  free (inf_status->stop_registers);
  free (inf_status);
@


1.21
log
@2000-11-06  Fernando Nasser  <fnasser@@cygnus.com>

        From  Steven Johnson  <sbjohnson@@ozemail.com.au>:

        This set of changes add "hookpost-" as an expansion on the original
        hooking of commands to GDB. A Hook may now be run "AFTER" execution of
        a command as well as before.

        * command.h (struct cmd_list_element): Changed elements hook and hookee
        to hook_pre and hookee_pre respectively. Added hook_post and hookee_post
        for the post hook command operation. Added hook_in so that an executing
        hook can be flagged to prevent recursion.
        * command.c (add_cmd): Changed initilization of cmd_list_element to
        reflect above changes.
        (delete_cmd): Remove both pre and post hooks.
        (help_cmd): Notify that the command has pre and/or post hooks.
        * infrun.c (normal_stop): Change references to hook_pre from hook.
        * top.c (execute_command): Run both pre and post hooks.
        (define_command): Allow definition of both pre and post hooks.
        The definition of pre-hooks is done as before, with the "hook-"
        prefix for backward compatibility.
@
text
@d87 5
d948 1
a948 1
  step_over_calls = -1;
d2620 1
a2620 1
    if (step_over_calls < 0 && IN_SOLIB_DYNSYM_RESOLVE_CODE (stop_pc))
d2741 1
a2741 1
	if (step_over_calls == 0)
d2752 1
a2752 1
	if (step_over_calls > 0 || IGNORE_HELPER_CALL (stop_pc))
d2818 12
d3954 1
a3954 1
  int step_over_calls;
d4328 9
@


1.20
log
@	* eval.c (parse_and_eval_long): New function.
	* value.h: Declare it.

	* breakpoint.c (breakpoints_info, maintenance_info_breakpoints):
	Call parse_and_eval_long, not parse_and_eval_address.
	* command.c (do_setshow_command): Ditto.
	* infcmd.c (step_1, signal_command, continue_command): Ditto.
	* infrun.c (signals_info): Ditto.
	* stack.c (set_backtrace_limit_command, backtrace_command_1,
	up_silently_base, down_silently_base): Ditto.
	* tracepoints.c (tracepoints_info, trace_find_command,
 	trace_find_tracepoint_command): Ditto.
	* valprint.c (set_radix): Ditto.
	* values.c (show_values): Ditto.
@
text
@d3449 1
a3449 1
  if (stop_command && stop_command->hook)
d3451 1
a3451 1
      catch_errors (hook_stop_stub, stop_command->hook,
@


1.19
log
@
Corrected spelling errors in comments.
gdbarch.{c,sh} removed a word from a comment.
@
text
@d3902 1
a3902 1
	    target_signal_from_command (parse_and_eval_address (signum_exp));
@


1.18
log
@Corrected spelling in comment:  unles -> unless.
@
text
@d1111 1
a1111 1
     indicate th wait_for_inferior that a target should timeout if
@


1.17
log
@Protoization.
@
text
@d1434 1
a1434 1
	 * unles we're running in scheduler-locked mode. 
@


1.16
log
@Botch in previous change.  Was comparing against "ask" instead of
follow_fork_mode_ask.
@
text
@d1312 1
a1312 2
fetch_inferior_event (client_data)
     void *client_data;
@


1.15
log
@Change signature of function add_set_enum_cmd() so that it uses
constant character pointers.  Update everything.
As a consequence fix infrun's follow-fork plugging a small memory leak.
@
text
@d469 1
a469 1
  if (follow_fork_mode_string == "ask")
@


1.14
log
@Purge (almost) make_cleanup_func.
@
text
@d437 6
a442 1
static char *follow_fork_mode_kind_names[] =
d444 1
d449 4
a452 2
  /* "parent", "child", "both", "ask" */
  "parent", "child", "ask", NULL
d455 1
a455 1
static char *follow_fork_mode_string = NULL;
d466 1
a466 2
  char *follow_mode =
    savestring (follow_fork_mode_string, strlen (follow_fork_mode_string));
d469 1
a469 1
  if (STREQ (follow_fork_mode_string, "ask"))
d471 2
a472 5
      char requested_mode[100];

      free (follow_mode);
      error ("\"ask\" mode NYI");
      follow_mode = savestring (requested_mode, strlen (requested_mode));
d478 1
a478 1
  if (STREQ (follow_mode, "parent"))
d503 1
a503 1
  else if (STREQ (follow_mode, "child"))
d565 1
a565 1
  else if (STREQ (follow_mode, "both"))
a620 2

  free (follow_mode);
d762 5
a766 5
static char schedlock_off[] = "off";
static char schedlock_on[] = "on";
static char schedlock_step[] = "step";
static char *scheduler_mode = schedlock_off;
static char *scheduler_enums[] =
a4137 14
static void
set_follow_fork_mode_command (char *arg, int from_tty,
			      struct cmd_list_element *c)
{
  if (!STREQ (arg, "parent") &&
      !STREQ (arg, "child") &&
      !STREQ (arg, "both") &&
      !STREQ (arg, "ask"))
    error ("follow-fork-mode must be one of \"parent\", \"child\", \"both\" or \"ask\".");

  if (follow_fork_mode_string != NULL)
    free (follow_fork_mode_string);
  follow_fork_mode_string = savestring (arg, strlen (arg));
}
a4298 2

  set_follow_fork_mode_command ("parent", 0, NULL);
@


1.13
log
@Fix signature of add_set_enum_cmd.  Change VAR parameter to char**.
Cleanup signature of add_set_cmd.  Change VAR parameter to void*.
@
text
@d49 1
a49 1
static void resume_cleanups (int);
d755 1
a755 1
resume_cleanups (int arg)
d799 1
a799 2
  struct cleanup *old_cleanups = make_cleanup ((make_cleanup_func)
					       resume_cleanups, 0);
d4114 12
@


1.12
log
@* infrun.c (handle_inferior_event): Add missing call to keep_going
and missing return when handling an ordinary signal from the
inferior.
@
text
@d4270 1
a4270 1
			(char *) &follow_fork_mode_string,
d4305 1
a4305 1
			(char *) &scheduler_mode,	/* current mode  */
@


1.11
log
@* infrun.c (handle_inferior_event): When doing a "next", and
stepping out of a signal handler into its calling trampoline
ignore the value of step_frame_address.
(step_over_function): Only modify step_resume_breakpoint->frame if
the value of step_frame_address is non-zero.
@
text
@d2277 2
@


1.10
log
@revert 1.9.  Not approved.
@
text
@d2748 14
d3062 1
a3062 1
  if (!IN_SOLIB_DYNSYM_RESOLVE_CODE (sr_sal.pc))
@


1.9
log
@re-do how gdbarch provides non-multi arch defaults so that non-
multi-arch gdbservers can continue to compile.
@
text
@a2276 2
	keep_going (ecs);
	return;
@


1.8
log
@Append NULL to enum based commands follow-fork and scheduler-locking.
@
text
@d2277 2
@


1.7
log
@	* infrun.c (proceed, normal_stop): Change the error message about
	failure to insert breakpoints/watchpoints so that it makes sense
	even if ptrace is not used or no other processes can be active.
@
text
@d439 7
a445 7
/* ??rehrauer:  The "both" option is broken, by what may be a 10.20
   kernel problem.  It's also not terribly useful without a GUI to
   help the user drive two debuggers.  So for now, I'm disabling
   the "both" option.
   "parent", "child", "both", "ask" };
 */
  "parent", "child", "ask"};
d765 6
a770 1
{schedlock_off, schedlock_on, schedlock_step};
@


1.6
log
@	* infrun.c (handle_inferior_event): Call target_mourn_inferior
	instead of kill_target.
@
text
@d1047 1
a1047 1
	  print_sys_errmsg ("ptrace", temp);
d1049 3
a1051 1
The same program may be running in another process.");
d3388 1
a3388 1
      print_sys_errmsg ("ptrace", breakpoints_failed);
d3390 3
a3392 1
The same program may be running in another process.\n");
@


1.6.2.1
log
@	* infrun.c (proceed, normal_stop): Change the error message about
	failure to insert breakpoints/watchpoints so that it makes sense
	even if ptrace is not used or no other processes can be active.
@
text
@d1047 1
a1047 1
	  print_sys_errmsg ("insert_breakpoints", temp);
d1049 1
a1049 3
The same program may be running in another process,\n\
or you may have requested too many hardware\n\
breakpoints and/or watchpoints.\n");
d3386 1
a3386 1
      print_sys_errmsg ("While inserting breakpoints", breakpoints_failed);
d3388 1
a3388 3
The same program may be running in another process,\n\
or you may have requested too many hardware breakpoints\n\
and/or watchpoints.\n");
@


1.6.2.2
log
@Append NULL to enum based commands follow-fork and scheduler-locking.
@
text
@d439 7
a445 7
  /* ??rehrauer: The "both" option is broken, by what may be a 10.20
     kernel problem.  It's also not terribly useful without a GUI to
     help the user drive two debuggers.  So for now, I'm disabling the
     "both" option. */
  /* "parent", "child", "both", "ask" */
  "parent", "child", "ask", NULL
};
d765 1
a765 6
{
  schedlock_off,
  schedlock_on,
  schedlock_step,
  NULL
};
@


1.5
log
@2000-03-28  Peter Schauer  <pes@@regent.e-technik.tu-muenchen.de>

        breakpoint.c, breakpoint.h (remove_hw_watchpoints):  New function.
        infrun.c (resume):  Remove hardware watchpoints before stepping
        when CANNOT_STEP_HW_WATCHPOINTS is nonzero.
@
text
@d1558 6
a1563 6
	/* This looks pretty bogus to me.  Doesn't TARGET_WAITKIND_SIGNALLED
	   mean it is already dead?  This has been here since GDB 2.8, so
	   perhaps it means rms didn't understand unix waitstatuses?
	   For the moment I'm just kludging around this in remote.c
	   rather than trying to change it here --kingdon, 5 Dec 1994.  */
	target_kill ();		/* kill mourns as well */
@


1.4
log
@Add more checks for no stack frame.
@
text
@d299 7
d805 12
@


1.3
log
@Add mi/ and testsuite/gdb.mi/ subdirectories.
Add --enable-gdbmi option to configury.
Add mi rules to Makefile.in
Add mi conditional output to event-top.c infrun.c main.c top.c.
Add -i=mi option.
@
text
@d3432 2
a3433 1
      if (stop_print_frame)
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d3226 7
d3242 2
d3276 2
d3284 2
d3461 6
d3468 4
@


1.1
log
@Initial revision
@
text
@d2 1
a2 2
   Copyright 1986, 87, 88, 89, 91, 92, 93, 94, 95, 96, 97, 1998
   Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d28 1
a28 1
#include "wait.h"
d35 1
a35 1

d37 1
d41 16
a56 1
static void signals_info PARAMS ((char *, int));
d58 1
a58 1
static void handle_command PARAMS ((char *, int));
d60 1
a60 1
static void sig_print_info PARAMS ((enum target_signal));
d62 1
a62 1
static void sig_print_header PARAMS ((void));
d64 1
a64 1
static void resume_cleanups PARAMS ((int));
d66 2
a67 1
static int hook_stop_stub PARAMS ((PTR));
d69 14
a82 1
static void delete_breakpoint_current_contents PARAMS ((PTR));
d87 4
a90 1
#ifdef HPUXHPPA
d93 9
a101 2
   running in. */
static int switched_from_inferior_pid;
d104 2
d118 2
a119 1
   thread steps and others wait" shouldn't do this. */
d122 8
a129 1
void _initialize_infrun PARAMS ((void));
d163 38
a200 4
/* On SVR4 based systems, determining the callee's address is exceedingly
   difficult and depends on the implementation of the run time loader.
   If we are stepping at the source level, we single step until we exit
   the run time loader code and reach the callee's address.  */
d206 4
d255 44
d374 1
a374 1
char stop_registers[REGISTER_BYTES];
d436 2
a437 2
  "parent", "child", "both", "ask" };
  */
a442 1
#if defined(HPUXHPPA)
d444 2
a445 5
follow_inferior_fork (parent_pid, child_pid, has_forked, has_vforked)
     int parent_pid;
     int child_pid;
     int has_forked;
     int has_vforked;
a448 1
  int ima_clone = 0;
d452 1
a452 1
  savestring (follow_fork_mode_string, strlen (follow_fork_mode_string));
d479 1
d481 1
d513 1
d515 1
d559 1
a559 1
       involvement with child_pid; our clone will take it from here... */
d594 6
a599 6
           Parent        Child           Action for gdb to take
         -------------------------------------------------------
        1                VFORK               Continue child
        2                EXEC
        3                EXEC or EXIT
        4  VFORK */
d615 1
a615 3
follow_fork (parent_pid, child_pid)
     int parent_pid;
     int child_pid;
d622 1
a622 1
static void follow_exec PARAMS ((int, char *));
d625 1
a625 3
follow_vfork (parent_pid, child_pid)
     int parent_pid;
     int child_pid;
a637 1
#endif /* HPUXHPPA */
d640 1
a640 3
follow_exec (pid, execd_pathname)
     int pid;
     char *execd_pathname;
a641 1
#ifdef HPUXHPPA
d643 4
a646 1
  extern struct target_ops child_ops;
d700 7
d710 1
a710 1
  push_target (&child_ops);
d721 1
d723 2
d726 1
a736 1
#endif
d748 1
a748 2
resume_cleanups (arg)
     int arg;
d761 1
a761 4
set_schedlock_func (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
d773 2
d784 1
a784 3
resume (step, sig)
     int step;
     enum target_signal sig;
d799 7
d809 1
a809 1
      SOFTWARE_SINGLE_STEP (sig, 1 /*insert-breakpoints*/ );
a821 1
#ifdef HPUXHPPA
d839 3
a841 3
             If so, then it actually ought to be waiting for us; we respond to
             parent vfork events.  We don't actually want to resume the child
             in this situation; we want to just get its exec event. */
d850 1
a850 1
           an exec, then now might be the time! */
a857 1
#endif /* HPUXHPPA */
d864 3
a866 2
#ifdef HPUXHPPA
      if (thread_step_needed)
d876 2
a877 2
		 where all the threads either step or continue. */
	      target_resume (-1, step, sig);
d889 1
a889 2

	      target_resume (inferior_pid, step, sig);
a892 1
#endif /* HPUXHPPA */
a894 1

d897 1
a897 1
	    target_resume (inferior_pid, step, sig);
d899 1
a899 1
	    target_resume (-1, step, sig);
d901 1
d912 1
a912 1
clear_proceed_status ()
d932 1
a932 1
     or -1 for act according to how it stopped.
d934 3
a936 3
     -1 means return after that and print nothing.
     You should probably set various step_... variables
     before calling here, if you are stepping.
d941 1
a941 4
proceed (addr, siggnal, step)
     CORE_ADDR addr;
     enum target_signal siggnal;
     int step;
d950 1
a950 1
  if (addr == (CORE_ADDR) - 1)
d953 2
a954 2
	 step one instruction before inserting breakpoints
	 so that we do not stop right away (and report a second
d965 2
a966 2
	 (it just checks internal GDB data structures) and STEP_SKIPS_DELAY
	 is slow (it needs to read memory from the target).  */
d977 2
a978 2
	 over a breakpoint we just hit, 'cause we aren't
	 continuing from there.
d980 4
a983 4
	 It's not worth worrying about the case where a user
	 asks for a "jump" at the current PC--if they get the
	 hiccup of re-hiting a hit breakpoint, what else do
	 they expect? */
d999 1
a999 1
  if (PREPARE_TO_PROCEED () && breakpoint_here_p (read_pc ()))
d1011 3
a1013 3
	 the first instruction is executed.  Force step one
	 instruction to clear this condition.  This should not occur
	 if step is nonzero, but it is harmless in that case.  */
d1054 7
a1060 3

  wait_for_inferior ();
  normal_stop ();
d1075 1
a1075 1
start_remote ()
d1081 15
d1103 1
a1103 1
init_wait_for_inferior ()
d1132 1
a1132 2
delete_breakpoint_current_contents (arg)
     PTR arg;
d1142 74
d1223 1
a1223 1
wait_for_inferior ()
d1226 2
a1227 27
  struct target_waitstatus w;
  int another_trap;
  int random_signal = 0;
  CORE_ADDR stop_func_start;
  CORE_ADDR stop_func_end;
  char *stop_func_name;
#if 0
  CORE_ADDR prologue_pc = 0;
#endif
  CORE_ADDR tmp;
  struct symtab_and_line sal;
  int remove_breakpoints_on_following_step = 0;
  int current_line;
  struct symtab *current_symtab;
  int handling_longjmp = 0;	/* FIXME */
  int pid;
  int saved_inferior_pid;
  int update_step_sp = 0;
  int stepping_through_solib_after_catch = 0;
  bpstat stepping_through_solib_catchpoints = NULL;
  int enable_hw_watchpoints_after_wait = 0;
  int stepping_through_sigtramp = 0;
  int new_thread_event;

#ifdef HAVE_NONSTEPPABLE_WATCHPOINT
  int stepped_after_stopped_by_watchpoint;
#endif
d1233 8
a1240 13
  sal = find_pc_line (prev_pc, 0);
  current_line = sal.line;
  current_symtab = sal.symtab;

  /* Are we stepping?  */
#define CURRENTLY_STEPPING() \
  ((through_sigtramp_breakpoint == NULL \
    && !handling_longjmp \
    && ((step_range_end && step_resume_breakpoint == NULL) \
	|| trap_expected)) \
   || stepping_through_solib_after_catch \
   || bpstat_should_step ())
  ;
a1242 1
#ifdef HPUXHPPA
d1244 11
a1254 2
  switched_from_inferior_pid = inferior_pid;
#endif
d1258 48
a1305 1
      extern int overlay_cache_invalid;	/* declared in symfile.h */
d1309 5
a1313 4
      /* We have to invalidate the registers BEFORE calling target_wait because
	 they can be loaded from the target while in target_wait.  This makes
	 remote debugging a bit more efficient for those targets that provide
	 critical registers as part of their normal status mechanism. */
d1316 1
d1318 17
a1334 2
      if (target_wait_hook)
	pid = target_wait_hook (-1, &w);
d1336 6
a1341 1
	pid = target_wait (-1, &w);
d1343 34
a1376 4
      /* Since we've done a wait, we have a new event.  Don't carry
         over any expectations about needing to step over a
         breakpoint. */
      thread_step_needed = 0;
d1378 5
a1382 7
      /* See comments where a TARGET_WAITKIND_SYSCALL_RETURN event is
         serviced in this loop, below. */
      if (enable_hw_watchpoints_after_wait)
	{
	  TARGET_ENABLE_HW_WATCHPOINTS (inferior_pid);
	  enable_hw_watchpoints_after_wait = 0;
	}
d1384 19
d1404 2
a1405 3
#ifdef HAVE_NONSTEPPABLE_WATCHPOINT
      stepped_after_stopped_by_watchpoint = 0;
#endif
d1407 11
a1417 1
      /* Gross.
d1419 2
a1420 4
       We goto this label from elsewhere in wait_for_inferior when we want
       to continue the main loop without calling "wait" and trashing the
       waitstatus contained in W.  */
    have_waited:
d1422 2
a1423 1
      flush_cached_frames ();
d1425 7
a1431 1
      /* If it's a new process, add it to the thread database */
d1433 1
a1433 1
      new_thread_event = ((pid != inferior_pid) && !in_thread_list (pid));
d1435 1
a1435 5
      if (w.kind != TARGET_WAITKIND_EXITED
	  && w.kind != TARGET_WAITKIND_SIGNALLED
	  && new_thread_event)
	{
	  add_thread (pid);
d1437 1
d1439 5
a1443 3
#ifdef HPUXHPPA
	  fprintf_unfiltered (gdb_stderr, "[New %s]\n",
			      target_pid_or_tid_to_str (pid));
d1445 4
d1450 1
a1450 1
	  printf_filtered ("[New %s]\n", target_pid_to_str (pid));
d1454 18
a1471 18
	  /* NOTE: This block is ONLY meant to be invoked in case of a
	     "thread creation event"!  If it is invoked for any other
	     sort of event (such as a new thread landing on a breakpoint),
	     the event will be discarded, which is almost certainly
	     a bad thing!
	
	     To avoid this, the low-level module (eg. target_wait)
	     should call in_thread_list and add_thread, so that the
	     new thread is known by the time we get here.  */

	  /* We may want to consider not doing a resume here in order
	     to give the user a chance to play with the new thread.
	     It might be good to make that a user-settable option.  */

	  /* At this point, all threads are stopped (happens
	     automatically in either the OS or the native code).
	     Therefore we need to continue all threads in order to
	     make progress.  */
d1473 3
a1475 2
	  target_resume (-1, 0, TARGET_SIGNAL_0);
	  continue;
d1477 1
a1477 1
	}
d1479 6
a1484 6
      switch (w.kind)
	{
	case TARGET_WAITKIND_LOADED:
	  /* Ignore gracefully during startup of the inferior, as it
	     might be the shell which has just loaded some objects,
	     otherwise add the symbols for the newly loaded objects.  */
d1486 64
a1549 3
	  if (!stop_soon_quietly)
	    {
	      extern int auto_solib_add;
d1551 24
a1574 4
	      /* Remove breakpoints, SOLIB_ADD might adjust
		 breakpoint addresses via breakpoint_re_set.  */
	      if (breakpoints_inserted)
		remove_breakpoints ();
d1576 31
a1606 10
	      /* Check for any newly added shared libraries if we're
		 supposed to be adding them automatically.  */
	      if (auto_solib_add)
		{
		  /* Switch terminal for any messages produced by
		     breakpoint_re_set.  */
		  target_terminal_ours_for_output ();
		  SOLIB_ADD (NULL, 0, NULL);
		  target_terminal_inferior ();
		}
d1608 17
a1624 7
	      /* Reinsert breakpoints and continue.  */
	      if (breakpoints_inserted)
		insert_breakpoints ();
	    }
#endif
	  resume (0, TARGET_SIGNAL_0);
	  continue;
d1626 23
a1648 12
	case TARGET_WAITKIND_SPURIOUS:
	  resume (0, TARGET_SIGNAL_0);
	  continue;

	case TARGET_WAITKIND_EXITED:
	  target_terminal_ours ();	/* Must do this before mourn anyway */
	  annotate_exited (w.value.integer);
	  if (w.value.integer)
	    printf_filtered ("\nProgram exited with code 0%o.\n",
			     (unsigned int) w.value.integer);
	  else
	    printf_filtered ("\nProgram exited normally.\n");
d1650 23
a1672 10
	  /* Record the exit code in the convenience variable $_exitcode, so
	     that the user can inspect this again later.  */
	  set_internalvar (lookup_internalvar ("_exitcode"),
			   value_from_longest (builtin_type_int,
					       (LONGEST) w.value.integer));
	  gdb_flush (gdb_stdout);
	  target_mourn_inferior ();
	  singlestep_breakpoints_inserted_p = 0;	/*SOFTWARE_SINGLE_STEP_P*/
	  stop_print_frame = 0;
	  goto stop_stepping;
d1674 9
a1682 108
	case TARGET_WAITKIND_SIGNALLED:
	  stop_print_frame = 0;
	  stop_signal = w.value.sig;
	  target_terminal_ours ();	/* Must do this before mourn anyway */
	  annotate_signalled ();

	  /* This looks pretty bogus to me.  Doesn't TARGET_WAITKIND_SIGNALLED
	     mean it is already dead?  This has been here since GDB 2.8, so
	     perhaps it means rms didn't understand unix waitstatuses?
	     For the moment I'm just kludging around this in remote.c
	     rather than trying to change it here --kingdon, 5 Dec 1994.  */
	  target_kill ();	/* kill mourns as well */

	  printf_filtered ("\nProgram terminated with signal ");
	  annotate_signal_name ();
	  printf_filtered ("%s", target_signal_to_name (stop_signal));
	  annotate_signal_name_end ();
	  printf_filtered (", ");
	  annotate_signal_string ();
	  printf_filtered ("%s", target_signal_to_string (stop_signal));
	  annotate_signal_string_end ();
	  printf_filtered (".\n");

	  printf_filtered ("The program no longer exists.\n");
	  gdb_flush (gdb_stdout);
	  singlestep_breakpoints_inserted_p = 0;	/*SOFTWARE_SINGLE_STEP_P*/
	  goto stop_stepping;

	  /* The following are the only cases in which we keep going;
           the above cases end in a continue or goto. */
	case TARGET_WAITKIND_FORKED:
	  stop_signal = TARGET_SIGNAL_TRAP;
	  pending_follow.kind = w.kind;

	  /* Ignore fork events reported for the parent; we're only
             interested in reacting to forks of the child.  Note that
             we expect the child's fork event to be available if we
             waited for it now. */
	  if (inferior_pid == pid)
	    {
	      pending_follow.fork_event.saw_parent_fork = 1;
	      pending_follow.fork_event.parent_pid = pid;
	      pending_follow.fork_event.child_pid = w.value.related_pid;
	      continue;
	    }
	  else
	    {
	      pending_follow.fork_event.saw_child_fork = 1;
	      pending_follow.fork_event.child_pid = pid;
	      pending_follow.fork_event.parent_pid = w.value.related_pid;
	    }

	  stop_pc = read_pc_pid (pid);
	  saved_inferior_pid = inferior_pid;
	  inferior_pid = pid;
	  stop_bpstat = bpstat_stop_status
	    (&stop_pc,
#if DECR_PC_AFTER_BREAK
	     (prev_pc != stop_pc - DECR_PC_AFTER_BREAK
	      && CURRENTLY_STEPPING ())
#else /* DECR_PC_AFTER_BREAK zero */
	     0
#endif /* DECR_PC_AFTER_BREAK zero */
	    );
	  random_signal = !bpstat_explains_signal (stop_bpstat);
	  inferior_pid = saved_inferior_pid;
	  goto process_event_stop_test;

	  /* If this a platform which doesn't allow a debugger to touch a
           vfork'd inferior until after it exec's, then we'd best keep
           our fingers entirely off the inferior, other than continuing
           it.  This has the unfortunate side-effect that catchpoints
           of vforks will be ignored.  But since the platform doesn't
           allow the inferior be touched at vfork time, there's really
           little choice. */
	case TARGET_WAITKIND_VFORKED:
	  stop_signal = TARGET_SIGNAL_TRAP;
	  pending_follow.kind = w.kind;

	  /* Is this a vfork of the parent?  If so, then give any
             vfork catchpoints a chance to trigger now.  (It's
             dangerous to do so if the child canot be touched until
             it execs, and the child has not yet exec'd.  We probably
             should warn the user to that effect when the catchpoint
             triggers...) */
	  if (pid == inferior_pid)
	    {
	      pending_follow.fork_event.saw_parent_fork = 1;
	      pending_follow.fork_event.parent_pid = pid;
	      pending_follow.fork_event.child_pid = w.value.related_pid;
	    }

	  /* If we've seen the child's vfork event but cannot really touch
             the child until it execs, then we must continue the child now.
             Else, give any vfork catchpoints a chance to trigger now. */
	  else
	    {
	      pending_follow.fork_event.saw_child_fork = 1;
	      pending_follow.fork_event.child_pid = pid;
	      pending_follow.fork_event.parent_pid = w.value.related_pid;
	      target_post_startup_inferior (pending_follow.fork_event.child_pid);
	      follow_vfork_when_exec = !target_can_follow_vfork_prior_to_exec ();
	      if (follow_vfork_when_exec)
		{
		  target_resume (pid, 0, TARGET_SIGNAL_0);
		  continue;
		}
	    }
d1684 39
a1722 109
	  stop_pc = read_pc ();
	  stop_bpstat = bpstat_stop_status
	    (&stop_pc,
#if DECR_PC_AFTER_BREAK
	     (prev_pc != stop_pc - DECR_PC_AFTER_BREAK
	      && CURRENTLY_STEPPING ())
#else /* DECR_PC_AFTER_BREAK zero */
	     0
#endif /* DECR_PC_AFTER_BREAK zero */
	    );
	  random_signal = !bpstat_explains_signal (stop_bpstat);
	  goto process_event_stop_test;

	case TARGET_WAITKIND_EXECD:
	  stop_signal = TARGET_SIGNAL_TRAP;

	  /* Is this a target which reports multiple exec events per actual
             call to exec()?  (HP-UX using ptrace does, for example.)  If so,
             ignore all but the last one.  Just resume the exec'r, and wait
             for the next exec event. */
	  if (inferior_ignoring_leading_exec_events)
	    {
	      inferior_ignoring_leading_exec_events--;
	      if (pending_follow.kind == TARGET_WAITKIND_VFORKED)
		ENSURE_VFORKING_PARENT_REMAINS_STOPPED (pending_follow.fork_event.parent_pid);
	      target_resume (pid, 0, TARGET_SIGNAL_0);
	      continue;
	    }
	  inferior_ignoring_leading_exec_events =
	    target_reported_exec_events_per_exec_call () - 1;

	  pending_follow.execd_pathname = savestring (w.value.execd_pathname,
					   strlen (w.value.execd_pathname));

	  /* Did inferior_pid exec, or did a (possibly not-yet-followed)
             child of a vfork exec?

             ??rehrauer: This is unabashedly an HP-UX specific thing.  On
             HP-UX, events associated with a vforking inferior come in
             threes: a vfork event for the child (always first), followed
             a vfork event for the parent and an exec event for the child.
             The latter two can come in either order.

             If we get the parent vfork event first, life's good: We follow
             either the parent or child, and then the child's exec event is
             a "don't care".

             But if we get the child's exec event first, then we delay
             responding to it until we handle the parent's vfork.  Because,
             otherwise we can't satisfy a "catch vfork". */
	  if (pending_follow.kind == TARGET_WAITKIND_VFORKED)
	    {
	      pending_follow.fork_event.saw_child_exec = 1;

	      /* On some targets, the child must be resumed before
                 the parent vfork event is delivered.  A single-step
                 suffices. */
	      if (RESUME_EXECD_VFORKING_CHILD_TO_GET_PARENT_VFORK ())
		target_resume (pid, 1, TARGET_SIGNAL_0);
	      /* We expect the parent vfork event to be available now. */
	      continue;
	    }

	  /* This causes the eventpoints and symbol table to be reset.  Must
             do this now, before trying to determine whether to stop. */
	  follow_exec (inferior_pid, pending_follow.execd_pathname);
	  free (pending_follow.execd_pathname);

	  stop_pc = read_pc_pid (pid);
	  saved_inferior_pid = inferior_pid;
	  inferior_pid = pid;
	  stop_bpstat = bpstat_stop_status
	    (&stop_pc,
#if DECR_PC_AFTER_BREAK
	     (prev_pc != stop_pc - DECR_PC_AFTER_BREAK
	      && CURRENTLY_STEPPING ())
#else /* DECR_PC_AFTER_BREAK zero */
	     0
#endif /* DECR_PC_AFTER_BREAK zero */
	    );
	  random_signal = !bpstat_explains_signal (stop_bpstat);
	  inferior_pid = saved_inferior_pid;
	  goto process_event_stop_test;

	  /* These syscall events are returned on HP-UX, as part of its
           implementation of page-protection-based "hardware" watchpoints.
           HP-UX has unfortunate interactions between page-protections and
           some system calls.  Our solution is to disable hardware watches
           when a system call is entered, and reenable them when the syscall
           completes.  The downside of this is that we may miss the precise
           point at which a watched piece of memory is modified.  "Oh well."

           Note that we may have multiple threads running, which may each
           enter syscalls at roughly the same time.  Since we don't have a
           good notion currently of whether a watched piece of memory is
           thread-private, we'd best not have any page-protections active
           when any thread is in a syscall.  Thus, we only want to reenable
           hardware watches when no threads are in a syscall.

           Also, be careful not to try to gather much state about a thread
           that's in a syscall.  It's frequently a losing proposition. */
	case TARGET_WAITKIND_SYSCALL_ENTRY:
	  number_of_threads_in_syscalls++;
	  if (number_of_threads_in_syscalls == 1)
	    {
	      TARGET_DISABLE_HW_WATCHPOINTS (inferior_pid);
	    }
	  resume (0, TARGET_SIGNAL_0);
	  continue;
d1724 1
a1724 1
	  /* Before examining the threads further, step this thread to
d1735 1
a1735 1
	   Thus, we simply set the flag enable_hw_watchpoints_after_wait
d1738 2
a1739 2
	case TARGET_WAITKIND_SYSCALL_RETURN:
	  target_resume (pid, 1, TARGET_SIGNAL_0);
d1741 8
a1748 7
	  if (number_of_threads_in_syscalls > 0)
	    {
	      number_of_threads_in_syscalls--;
	      enable_hw_watchpoints_after_wait =
		(number_of_threads_in_syscalls == 0);
	    }
	  continue;
d1750 15
a1764 4
	case TARGET_WAITKIND_STOPPED:
	  stop_signal = w.value.sig;
	  break;
	}
d1766 13
a1778 12
      /* We may want to consider not doing a resume here in order to give
         the user a chance to play with the new thread.  It might be good
         to make that a user-settable option.  */

      /* At this point, all threads are stopped (happens automatically in
         either the OS or the native code).  Therefore we need to continue
         all threads in order to make progress.  */
      if (new_thread_event)
	{
	  target_resume (-1, 0, TARGET_SIGNAL_0);
	  continue;
	}
d1780 1
a1780 1
      stop_pc = read_pc_pid (pid);
d1782 3
a1784 3
      /* See if a thread hit a thread-specific breakpoint that was meant for
	 another thread.  If so, then step that thread past the breakpoint,
	 and continue it.  */
d1786 12
a1797 12
      if (stop_signal == TARGET_SIGNAL_TRAP)
	{
	  if (SOFTWARE_SINGLE_STEP_P && singlestep_breakpoints_inserted_p)
	    random_signal = 0;
	  else if (breakpoints_inserted
		   && breakpoint_here_p (stop_pc - DECR_PC_AFTER_BREAK))
	    {
	      random_signal = 0;
	      if (!breakpoint_thread_match (stop_pc - DECR_PC_AFTER_BREAK,
					    pid))
		{
		  int remove_status;
d1799 52
a1850 28
		  /* Saw a breakpoint, but it was hit by the wrong thread.
		       Just continue. */
		  write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK, pid);

		  remove_status = remove_breakpoints ();
		  /* Did we fail to remove breakpoints?  If so, try
                       to set the PC past the bp.  (There's at least
                       one situation in which we can fail to remove
                       the bp's: On HP-UX's that use ttrace, we can't
                       change the address space of a vforking child
                       process until the child exits (well, okay, not
                       then either :-) or execs. */
		  if (remove_status != 0)
		    {
		      write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK + 4, pid);
		    }
		  else
		    {		/* Single step */
		      target_resume (pid, 1, TARGET_SIGNAL_0);
		      /* FIXME: What if a signal arrives instead of the
			   single-step happening?  */

		      if (target_wait_hook)
			target_wait_hook (pid, &w);
		      else
			target_wait (pid, &w);
		      insert_breakpoints ();
		    }
d1852 11
a1862 16
		  /* We need to restart all the threads now.  */
		  target_resume (-1, 0, TARGET_SIGNAL_0);
		  continue;
		}
	      else
		{
		  /* This breakpoint matches--either it is the right
		       thread or it's a generic breakpoint for all threads.
		       Remember that we'll need to step just _this_ thread
		       on any following user continuation! */
		  thread_step_needed = 1;
		}
	    }
	}
      else
	random_signal = 1;
d1864 5
a1868 17
      /* See if something interesting happened to the non-current thread.  If
         so, then switch to that thread, and eventually give control back to
	 the user.

         Note that if there's any kind of pending follow (i.e., of a fork,
         vfork or exec), we don't want to do this now.  Rather, we'll let
         the next resume handle it. */
      if ((pid != inferior_pid) &&
	  (pending_follow.kind == TARGET_WAITKIND_SPURIOUS))
	{
	  int printed = 0;

	  /* If it's a random signal for a non-current thread, notify user
	     if he's expressed an interest. */
	  if (random_signal
	      && signal_print[stop_signal])
	    {
d1880 6
a1885 6
	      printed = 1;
	      target_terminal_ours_for_output ();
	      printf_filtered ("\nProgram received signal %s, %s.\n",
			       target_signal_to_name (stop_signal),
			       target_signal_to_string (stop_signal));
	      gdb_flush (gdb_stdout);
d1887 1
a1887 1
	    }
d1889 2
a1890 2
	  /* If it's not SIGTRAP and not a signal we want to stop for, then
	     continue the thread. */
d1892 5
a1896 5
	  if (stop_signal != TARGET_SIGNAL_TRAP
	      && !signal_stop[stop_signal])
	    {
	      if (printed)
		target_terminal_inferior ();
d1898 3
a1900 3
	      /* Clear the signal if it should not be passed.  */
	      if (signal_program[stop_signal] == 0)
		stop_signal = TARGET_SIGNAL_0;
d1902 4
a1905 3
	      target_resume (pid, 0, stop_signal);
	      continue;
	    }
d1907 2
a1908 2
	  /* It's a SIGTRAP or a signal we're interested in.  Switch threads,
	     and fall into the rest of wait_for_inferior().  */
d1910 32
a1941 11
	  /* Save infrun state for the old thread.  */
	  save_infrun_state (inferior_pid, prev_pc,
			     prev_func_start, prev_func_name,
			     trap_expected, step_resume_breakpoint,
			     through_sigtramp_breakpoint,
			     step_range_start, step_range_end,
			     step_frame_address, handling_longjmp,
			     another_trap,
			     stepping_through_solib_after_catch,
			     stepping_through_solib_catchpoints,
			     stepping_through_sigtramp);
d1943 1
a1943 3
#ifdef HPUXHPPA
	  switched_from_inferior_pid = inferior_pid;
#endif
d1945 2
a1946 1
	  inferior_pid = pid;
d1948 2
a1949 11
	  /* Load infrun state for the new thread.  */
	  load_infrun_state (inferior_pid, &prev_pc,
			     &prev_func_start, &prev_func_name,
			     &trap_expected, &step_resume_breakpoint,
			     &through_sigtramp_breakpoint,
			     &step_range_start, &step_range_end,
			     &step_frame_address, &handling_longjmp,
			     &another_trap,
			     &stepping_through_solib_after_catch,
			     &stepping_through_solib_catchpoints,
			     &stepping_through_sigtramp);
d1951 10
a1960 2
	  if (context_hook)
	    context_hook (pid_to_thread_id (pid));
d1962 5
a1966 3
	  printf_filtered ("[Switching to %s]\n", target_pid_to_str (pid));
	  flush_cached_frames ();
	}
d1968 10
a1977 6
      if (SOFTWARE_SINGLE_STEP_P && singlestep_breakpoints_inserted_p)
	{
	  /* Pull the single step breakpoints out of the target. */
	  SOFTWARE_SINGLE_STEP (0, 0);
	  singlestep_breakpoints_inserted_p = 0;
	}
d1979 9
a1987 3
      /* If PC is pointing at a nullified instruction, then step beyond
	 it so that the user won't be confused when GDB appears to be ready
	 to execute it. */
d1989 34
a2022 12
#if 0				/* XXX DEBUG */
      printf ("infrun.c:1607: pc = 0x%x\n", read_pc ());
#endif
      /*      if (INSTRUCTION_NULLIFIED && CURRENTLY_STEPPING ()) */
      if (INSTRUCTION_NULLIFIED)
	{
	  struct target_waitstatus tmpstatus;
#if 0
	  all_registers_info ((char *) 0, 0);
#endif
	  registers_changed ();
	  target_resume (pid, 1, TARGET_SIGNAL_0);
d2024 54
a2077 8
	  /* We may have received a signal that we want to pass to
	     the inferior; therefore, we must not clobber the waitstatus
	     in W.  So we call wait ourselves, then continue the loop
	     at the "have_waited" label.  */
	  if (target_wait_hook)
	    target_wait_hook (pid, &tmpstatus);
	  else
	    target_wait (pid, &tmpstatus);
d2079 2
a2080 2
	  goto have_waited;
	}
d2082 26
a2107 10
#ifdef HAVE_STEPPABLE_WATCHPOINT
      /* It may not be necessary to disable the watchpoint to stop over
	 it.  For example, the PA can (with some kernel cooperation)
	 single step over a watchpoint without disabling the watchpoint.  */
      if (STOPPED_BY_WATCHPOINT (w))
	{
	  resume (1, 0);
	  continue;
	}
#endif
d2109 8
a2116 12
#ifdef HAVE_NONSTEPPABLE_WATCHPOINT
      /* It is far more common to need to disable a watchpoint
	 to step the inferior over it.  FIXME.  What else might
	 a debug register or page protection watchpoint scheme need
	 here?  */
      if (STOPPED_BY_WATCHPOINT (w))
	{
/* At this point, we are stopped at an instruction which has attempted to write
   to a piece of memory under control of a watchpoint.  The instruction hasn't
   actually executed yet.  If we were to evaluate the watchpoint expression
   now, we would get the old value, and therefore no change would seem to have
   occurred.
d2118 15
a2132 7
   In order to make watchpoints work `right', we really need to complete the
   memory write, and then evaluate the watchpoint expression.  The following
   code does that by removing the watchpoint (actually, all watchpoints and
   breakpoints), single-stepping the target, re-inserting watchpoints, and then
   falling through to let normal single-step processing handle proceed.  Since
   this includes evaluating watchpoints, things will come to a stop in the
   correct manner.  */
d2134 53
a2186 1
	  write_pc (stop_pc - DECR_PC_AFTER_BREAK);
d2188 2
a2189 3
	  remove_breakpoints ();
	  registers_changed ();
	  target_resume (pid, 1, TARGET_SIGNAL_0);	/* Single step */
d2191 4
a2194 5
	  if (target_wait_hook)
	    target_wait_hook (pid, &w);
	  else
	    target_wait (pid, &w);
	  insert_breakpoints ();
d2196 1
a2196 7
	  /* FIXME-maybe: is this cleaner than setting a flag?  Does it
	     handle things like signals arriving and other things happening
	     in combination correctly?  */
	  stepped_after_stopped_by_watchpoint = 1;
	  goto have_waited;
	}
#endif
d2198 19
a2216 36
#ifdef HAVE_CONTINUABLE_WATCHPOINT
      /* It may be possible to simply continue after a watchpoint.  */
      STOPPED_BY_WATCHPOINT (w);
#endif

      stop_func_start = 0;
      stop_func_end = 0;
      stop_func_name = 0;
      /* Don't care about return value; stop_func_start and stop_func_name
	 will both be 0 if it doesn't work.  */
      find_pc_partial_function (stop_pc, &stop_func_name, &stop_func_start,
				&stop_func_end);
      stop_func_start += FUNCTION_START_OFFSET;
      another_trap = 0;
      bpstat_clear (&stop_bpstat);
      stop_step = 0;
      stop_stack_dummy = 0;
      stop_print_frame = 1;
      random_signal = 0;
      stopped_by_random_signal = 0;
      breakpoints_failed = 0;

      /* Look at the cause of the stop, and decide what to do.
	 The alternatives are:
	 1) break; to really stop and return to the debugger,
	 2) drop through to start up again
	 (set another_trap to 1 to single step once)
	 3) set random_signal to 1, and the decision between 1 and 2
	 will be made according to the signal handling tables.  */

      /* First, distinguish signals caused by the debugger from signals
	 that have to do with the program's own actions.
	 Note that breakpoint insns may cause SIGTRAP or SIGILL
	 or SIGEMT, depending on the operating system version.
	 Here we detect when a SIGILL or SIGEMT is really a breakpoint
	 and change it to SIGTRAP.  */
d2218 2
a2219 14
      if (stop_signal == TARGET_SIGNAL_TRAP
	  || (breakpoints_inserted &&
	      (stop_signal == TARGET_SIGNAL_ILL
	       || stop_signal == TARGET_SIGNAL_EMT
	      ))
	  || stop_soon_quietly)
	{
	  if (stop_signal == TARGET_SIGNAL_TRAP && stop_after_trap)
	    {
	      stop_print_frame = 0;
	      break;
	    }
	  if (stop_soon_quietly)
	    break;
d2221 2
a2222 2
	  /* Don't even think about breakpoints
	     if just proceeded over a breakpoint.
d2224 33
a2256 33
	     However, if we are trying to proceed over a breakpoint
	     and end up in sigtramp, then through_sigtramp_breakpoint
	     will be set and we should check whether we've hit the
	     step breakpoint.  */
	  if (stop_signal == TARGET_SIGNAL_TRAP && trap_expected
	      && through_sigtramp_breakpoint == NULL)
	    bpstat_clear (&stop_bpstat);
	  else
	    {
	      /* See if there is a breakpoint at the current PC.  */
	      stop_bpstat = bpstat_stop_status
		(&stop_pc,
		 (DECR_PC_AFTER_BREAK ?
	      /* Notice the case of stepping through a jump
		    that lands just after a breakpoint.
		    Don't confuse that with hitting the breakpoint.
		    What we check for is that 1) stepping is going on
		    and 2) the pc before the last insn does not match
		    the address of the breakpoint before the current pc
		    and 3) we didn't hit a breakpoint in a signal handler
		    without an intervening stop in sigtramp, which is
		    detected by a new stack pointer value below
		    any usual function calling stack adjustments.  */
		  (CURRENTLY_STEPPING ()
		   && prev_pc != stop_pc - DECR_PC_AFTER_BREAK
		   && !(step_range_end
			&& INNER_THAN (read_sp (), (step_sp - 16)))) :
		  0)
		);
	      /* Following in case break condition called a
		 function.  */
	      stop_print_frame = 1;
	    }
d2258 1
a2258 9
	  if (stop_signal == TARGET_SIGNAL_TRAP)
	    random_signal
	      = !(bpstat_explains_signal (stop_bpstat)
		  || trap_expected
#ifndef CALL_DUMMY_BREAKPOINT_OFFSET
		  || PC_IN_CALL_DUMMY (stop_pc, read_sp (),
				       FRAME_FP (get_current_frame ()))
#endif /* No CALL_DUMMY_BREAKPOINT_OFFSET.  */
		  || (step_range_end && step_resume_breakpoint == NULL));
d2260 6
a2265 15
	  else
	    {
	      random_signal
		= !(bpstat_explains_signal (stop_bpstat)
	      /* End of a stack dummy.  Some systems (e.g. Sony
		       news) give another signal besides SIGTRAP,
		       so check here as well as above.  */
#ifndef CALL_DUMMY_BREAKPOINT_OFFSET
		    || PC_IN_CALL_DUMMY (stop_pc, read_sp (),
					 FRAME_FP (get_current_frame ()))
#endif /* No CALL_DUMMY_BREAKPOINT_OFFSET.  */
		);
	      if (!random_signal)
		stop_signal = TARGET_SIGNAL_TRAP;
	    }
d2268 1
a2268 24
      /* When we reach this point, we've pretty much decided
         that the reason for stopping must've been a random
         (unexpected) signal. */

      else
	random_signal = 1;
      /* If a fork, vfork or exec event was seen, then there are two
         possible responses we can make:

         1. If a catchpoint triggers for the event (random_signal == 0),
            then we must stop now and issue a prompt.  We will resume
            the inferior when the user tells us to.
         2. If no catchpoint triggers for the event (random_signal == 1),
            then we must resume the inferior now and keep checking.

         In either case, we must take appropriate steps to "follow" the
         the fork/vfork/exec when the inferior is resumed.  For example,
         if follow-fork-mode is "child", then we must detach from the
         parent inferior and follow the new child inferior.

         In either case, setting pending_follow causes the next resume()
         to take the appropriate following action. */
    process_event_stop_test:
      if (w.kind == TARGET_WAITKIND_FORKED)
d2270 8
a2277 1
	  if (random_signal)	/* I.e., no catchpoint triggered for this. */
d2279 2
a2280 3
	      trap_expected = 1;
	      stop_signal = TARGET_SIGNAL_0;
	      goto keep_going;
d2282 4
a2285 4
	}
      else if (w.kind == TARGET_WAITKIND_VFORKED)
	{
	  if (random_signal)	/* I.e., no catchpoint triggered for this. */
d2287 2
a2288 2
	      stop_signal = TARGET_SIGNAL_0;
	      goto keep_going;
d2290 3
a2292 5
	}
      else if (w.kind == TARGET_WAITKIND_EXECD)
	{
	  pending_follow.kind = w.kind;
	  if (random_signal)	/* I.e., no catchpoint triggered for this. */
d2294 2
a2295 3
	      trap_expected = 1;
	      stop_signal = TARGET_SIGNAL_0;
	      goto keep_going;
a2296 1
	}
d2298 11
a2308 2
      /* For the program's own signals, act according to
	 the signal handling tables.  */
d2310 20
a2329 4
      if (random_signal)
	{
	  /* Signal not for debugging purposes.  */
	  int printed = 0;
d2331 2
a2332 3
	  stopped_by_random_signal = 1;

	  if (signal_print[stop_signal])
d2334 2
a2335 13
	      printed = 1;
	      target_terminal_ours_for_output ();
	      annotate_signal ();
	      printf_filtered ("\nProgram received signal ");
	      annotate_signal_name ();
	      printf_filtered ("%s", target_signal_to_name (stop_signal));
	      annotate_signal_name_end ();
	      printf_filtered (", ");
	      annotate_signal_string ();
	      printf_filtered ("%s", target_signal_to_string (stop_signal));
	      annotate_signal_string_end ();
	      printf_filtered (".\n");
	      gdb_flush (gdb_stdout);
d2337 5
a2341 6
	  if (signal_stop[stop_signal])
	    break;
	  /* If not going to stop, give terminal back
	     if we took it away.  */
	  else if (printed)
	    target_terminal_inferior ();
d2343 2
a2344 3
	  /* Clear the signal if it should not be passed.  */
	  if (signal_program[stop_signal] == 0)
	    stop_signal = TARGET_SIGNAL_0;
d2346 3
a2348 2
	  /* If we're in the middle of a "next" command, let the code for
             stepping over a function handle this. pai/1997-09-10
d2350 2
a2351 2
             A previous comment here suggested it was possible to change
             this to jump to keep_going in all cases. */
d2353 2
a2354 5
	  if (step_over_calls > 0)
	    goto step_over_function;
	  else
	    goto check_sigtramp2;
	}
d2356 24
a2379 4
      /* Handle cases caused by hitting a breakpoint.  */
      {
	CORE_ADDR jmp_buf_pc;
	struct bpstat_what what;
d2381 8
a2388 1
	what = bpstat_what (stop_bpstat);
d2390 10
a2399 7
	if (what.call_dummy)
	  {
	    stop_stack_dummy = 1;
#ifdef HP_OS_BUG
	    trap_expected_after_continue = 1;
#endif
	  }
d2401 3
a2403 1
	switch (what.main_action)
d2405 5
a2409 6
	  case BPSTAT_WHAT_SET_LONGJMP_RESUME:
	    /* If we hit the breakpoint at longjmp, disable it for the
	       duration of this command.  Then, install a temporary
	       breakpoint at the target of the jmp_buf. */
	    disable_longjmp_breakpoint ();
	    remove_breakpoints ();
a2410 2
	    if (!GET_LONGJMP_TARGET (&jmp_buf_pc))
	      goto keep_going;
d2412 3
a2414 3
	    /* Need to blow away step-resume breakpoint, as it
	       interferes with us */
	    if (step_resume_breakpoint != NULL)
d2416 5
a2420 9
		delete_breakpoint (step_resume_breakpoint);
		step_resume_breakpoint = NULL;
	      }
	    /* Not sure whether we need to blow this away too, but probably
	       it is like the step-resume breakpoint.  */
	    if (through_sigtramp_breakpoint != NULL)
	      {
		delete_breakpoint (through_sigtramp_breakpoint);
		through_sigtramp_breakpoint = NULL;
d2423 9
a2431 20
#if 0
	    /* FIXME - Need to implement nested temporary breakpoints */
	    if (step_over_calls > 0)
	      set_longjmp_resume_breakpoint (jmp_buf_pc,
					     get_current_frame ());
	    else
#endif /* 0 */
	      set_longjmp_resume_breakpoint (jmp_buf_pc, NULL);
	    handling_longjmp = 1;	/* FIXME */
	    goto keep_going;

	  case BPSTAT_WHAT_CLEAR_LONGJMP_RESUME:
	  case BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE:
	    remove_breakpoints ();
	    breakpoints_inserted = 0;
#if 0
	    /* FIXME - Need to implement nested temporary breakpoints */
	    if (step_over_calls
		&& (INNER_THAN (FRAME_FP (get_current_frame ()),
				step_frame_address)))
d2433 2
a2434 2
		another_trap = 1;
		goto keep_going;
a2435 6
#endif /* 0 */
	    disable_longjmp_breakpoint ();
	    handling_longjmp = 0;	/* FIXME */
	    if (what.main_action == BPSTAT_WHAT_CLEAR_LONGJMP_RESUME)
	      break;
	    /* else fallthrough */
d2437 11
a2447 2
	  case BPSTAT_WHAT_SINGLE:
	    if (breakpoints_inserted)
d2449 20
a2468 2
		thread_step_needed = 1;
		remove_breakpoints ();
d2470 1
a2470 38
	    breakpoints_inserted = 0;
	    another_trap = 1;
	    /* Still need to check other stuff, at least the case
	       where we are stepping and step out of the right range.  */
	    break;

	  case BPSTAT_WHAT_STOP_NOISY:
	    stop_print_frame = 1;

	    /* We are about to nuke the step_resume_breakpoint and
	       through_sigtramp_breakpoint via the cleanup chain, so
	       no need to worry about it here.  */

	    goto stop_stepping;

	  case BPSTAT_WHAT_STOP_SILENT:
	    stop_print_frame = 0;

	    /* We are about to nuke the step_resume_breakpoint and
	       through_sigtramp_breakpoint via the cleanup chain, so
	       no need to worry about it here.  */

	    goto stop_stepping;

	  case BPSTAT_WHAT_STEP_RESUME:
	    /* This proably demands a more elegant solution, but, yeah
               right...

               This function's use of the simple variable
               step_resume_breakpoint doesn't seem to accomodate
               simultaneously active step-resume bp's, although the
               breakpoint list certainly can.

               If we reach here and step_resume_breakpoint is already
               NULL, then apparently we have multiple active
               step-resume bp's.  We'll just delete the breakpoint we
               stopped at, and carry on.  */
	    if (step_resume_breakpoint == NULL)
d2472 3
a2474 2
		step_resume_breakpoint =
		  bpstat_find_step_resume_breakpoint (stop_bpstat);
d2476 1
a2476 93
	    delete_breakpoint (step_resume_breakpoint);
	    step_resume_breakpoint = NULL;
	    break;

	  case BPSTAT_WHAT_THROUGH_SIGTRAMP:
	    if (through_sigtramp_breakpoint)
	      delete_breakpoint (through_sigtramp_breakpoint);
	    through_sigtramp_breakpoint = NULL;

	    /* If were waiting for a trap, hitting the step_resume_break
	       doesn't count as getting it.  */
	    if (trap_expected)
	      another_trap = 1;
	    break;

	  case BPSTAT_WHAT_CHECK_SHLIBS:
	  case BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK:
#ifdef SOLIB_ADD
	    {
	      extern int auto_solib_add;

	      /* Remove breakpoints, we eventually want to step over the
		 shlib event breakpoint, and SOLIB_ADD might adjust
		 breakpoint addresses via breakpoint_re_set.  */
	      if (breakpoints_inserted)
		remove_breakpoints ();
	      breakpoints_inserted = 0;

	      /* Check for any newly added shared libraries if we're
		 supposed to be adding them automatically.  */
	      if (auto_solib_add)
		{
		  /* Switch terminal for any messages produced by
		     breakpoint_re_set.  */
		  target_terminal_ours_for_output ();
		  SOLIB_ADD (NULL, 0, NULL);
		  target_terminal_inferior ();
		}

	      /* Try to reenable shared library breakpoints, additional
		 code segments in shared libraries might be mapped in now. */
	      re_enable_breakpoints_in_shlibs ();

	      /* If requested, stop when the dynamic linker notifies
		 gdb of events.  This allows the user to get control
		 and place breakpoints in initializer routines for
		 dynamically loaded objects (among other things).  */
	      if (stop_on_solib_events)
		{
		  stop_print_frame = 0;
		  goto stop_stepping;
		}

	      /* If we stopped due to an explicit catchpoint, then the
                 (see above) call to SOLIB_ADD pulled in any symbols
                 from a newly-loaded library, if appropriate.

                 We do want the inferior to stop, but not where it is
                 now, which is in the dynamic linker callback.  Rather,
                 we would like it stop in the user's program, just after
                 the call that caused this catchpoint to trigger.  That
                 gives the user a more useful vantage from which to
                 examine their program's state. */
	      else if (what.main_action == BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK)
		{
		  /* ??rehrauer: If I could figure out how to get the
                     right return PC from here, we could just set a temp
                     breakpoint and resume.  I'm not sure we can without
                     cracking open the dld's shared libraries and sniffing
                     their unwind tables and text/data ranges, and that's
                     not a terribly portable notion.

                     Until that time, we must step the inferior out of the
                     dld callback, and also out of the dld itself (and any
                     code or stubs in libdld.sl, such as "shl_load" and
                     friends) until we reach non-dld code.  At that point,
                     we can stop stepping. */
		  bpstat_get_triggered_catchpoints (stop_bpstat,
				       &stepping_through_solib_catchpoints);
		  stepping_through_solib_after_catch = 1;

		  /* Be sure to lift all breakpoints, so the inferior does
                     actually step past this point... */
		  another_trap = 1;
		  break;
		}
	      else
		{
		  /* We want to step over this breakpoint, then keep going.  */
		  another_trap = 1;
		  break;
		}
	    }
d2478 1
a2478 1
	    break;
d2480 2
a2481 2
	  case BPSTAT_WHAT_LAST:
	    /* Not a real code, but listed here to shut up gcc -Wall.  */
d2483 4
a2486 4
	  case BPSTAT_WHAT_KEEP_CHECKING:
	    break;
	  }
      }
d2488 11
a2498 11
      /* We come here if we hit a breakpoint but should not
	 stop for it.  Possibly we also were stepping
	 and should stop for that.  So fall through and
	 test for stepping.  But, if not stepping,
	 do not stop.  */

      /* Are we stepping to get the inferior out of the dynamic
         linker's hook (and possibly the dld itself) after catching
         a shlib event? */
      if (stepping_through_solib_after_catch)
	{
d2500 7
a2506 6
	  /* Have we reached our destination?  If not, keep going. */
	  if (SOLIB_IN_DYNAMIC_LINKER (pid, stop_pc))
	    {
	      another_trap = 1;
	      goto keep_going;
	    }
d2508 10
a2517 9
	  /* Else, stop and report the catchpoint(s) whose triggering
             caused us to begin stepping. */
	  stepping_through_solib_after_catch = 0;
	  bpstat_clear (&stop_bpstat);
	  stop_bpstat = bpstat_copy (stepping_through_solib_catchpoints);
	  bpstat_clear (&stepping_through_solib_catchpoints);
	  stop_print_frame = 1;
	  goto stop_stepping;
	}
d2519 17
a2535 16
#ifndef CALL_DUMMY_BREAKPOINT_OFFSET
      /* This is the old way of detecting the end of the stack dummy.
	 An architecture which defines CALL_DUMMY_BREAKPOINT_OFFSET gets
	 handled above.  As soon as we can test it on all of them, all
	 architectures should define it.  */

      /* If this is the breakpoint at the end of a stack dummy,
	 just stop silently, unless the user was doing an si/ni, in which
	 case she'd better know what she's doing.  */

      if (CALL_DUMMY_HAS_COMPLETED (stop_pc, read_sp (),
				    FRAME_FP (get_current_frame ()))
	  && !step_range_end)
	{
	  stop_print_frame = 0;
	  stop_stack_dummy = 1;
d2537 1
a2537 1
	  trap_expected_after_continue = 1;
d2539 4
a2542 3
	  break;
	}
#endif /* No CALL_DUMMY_BREAKPOINT_OFFSET.  */
d2544 2
a2545 1
      if (step_resume_breakpoint)
d2551 7
a2557 3
	goto check_sigtramp2;

      if (step_range_end == 0)
d2561 4
a2564 1
	goto check_sigtramp2;
d2566 63
a2628 1
      /* If stepping through a line, keep going if still within it.
a2629 8
         Note that step_range_end is the address of the first instruction
         beyond the step range, and NOT the address of the last instruction
         within it! */
      if (stop_pc >= step_range_start
	  && stop_pc < step_range_end
#if 0
/* I haven't a clue what might trigger this clause, and it seems wrong
   anyway, so I've disabled it until someone complains.  -Stu 10/24/95 */
a2630 10
      /* The step range might include the start of the
	     function, so if we are at the start of the
	     step range and either the stack or frame pointers
	     just changed, we've stepped outside */
	  && !(stop_pc == step_range_start
	       && FRAME_FP (get_current_frame ())
	       && (INNER_THAN (read_sp (), step_sp)
		   || FRAME_FP (get_current_frame ()) != step_frame_address))
#endif
	)
d2632 52
a2683 3
	  /* We might be doing a BPSTAT_WHAT_SINGLE and getting a signal.
	     So definately need to check for sigtramp here.  */
	  goto check_sigtramp2;
a2685 1
      /* We stepped out of the stepping range.  */
d2687 7
a2693 6
      /* If we are stepping at the source level and entered the runtime
         loader dynamic symbol resolution code, we keep on single stepping
	 until we exit the run time loader code and reach the callee's
	 address.  */
      if (step_over_calls < 0 && IN_SOLIB_DYNSYM_RESOLVE_CODE (stop_pc))
	goto keep_going;
d2695 4
a2698 4
      /* We can't update step_sp every time through the loop, because
	 reading the stack pointer would slow down stepping too much.
	 But we can update it every time we leave the step range.  */
      update_step_sp = 1;
d2700 7
a2706 7
      /* Did we just take a signal?  */
      if (IN_SIGTRAMP (stop_pc, stop_func_name)
	  && !IN_SIGTRAMP (prev_pc, prev_func_name)
	  && INNER_THAN (read_sp (), step_sp))
	{
	  /* We've just taken a signal; go until we are back to
	     the point where we took it and one more.  */
d2708 10
a2717 6
	  /* Note: The test above succeeds not only when we stepped
             into a signal handler, but also when we step past the last
             statement of a signal handler and end up in the return stub
             of the signal handler trampoline.  To distinguish between
             these two cases, check that the frame is INNER_THAN the
             previous one below. pai/1997-09-11 */
d2719 7
d2727 9
d2737 2
a2738 3
	    CORE_ADDR current_frame = FRAME_FP (get_current_frame ());

	    if (INNER_THAN (current_frame, step_frame_address))
d2740 7
a2746 20
		/* We have just taken a signal; go until we are back to
                   the point where we took it and one more.  */

		/* This code is needed at least in the following case:
                   The user types "next" and then a signal arrives (before
                   the "next" is done).  */

		/* Note that if we are stopped at a breakpoint, then we need
                   the step_resume breakpoint to override any breakpoints at
                   the same location, so that we will still step over the
                   breakpoint even though the signal happened.  */
		struct symtab_and_line sr_sal;

		INIT_SAL (&sr_sal);
		sr_sal.symtab = NULL;
		sr_sal.line = 0;
		sr_sal.pc = prev_pc;
		/* We could probably be setting the frame to
                   step_frame_address; I don't think anyone thought to
                   try it.  */
d2748 4
a2751 25
		  set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
		if (breakpoints_inserted)
		  insert_breakpoints ();
	      }
	    else
	      {
		/* We just stepped out of a signal handler and into
                   its calling trampoline.

                   Normally, we'd jump to step_over_function from
                   here, but for some reason GDB can't unwind the
                   stack correctly to find the real PC for the point
                   user code where the signal trampoline will return
                   -- FRAME_SAVED_PC fails, at least on HP-UX 10.20.
                   But signal trampolines are pretty small stubs of
                   code, anyway, so it's OK instead to just
                   single-step out.  Note: assuming such trampolines
                   don't exhibit recursion on any platform... */
		find_pc_partial_function (stop_pc, &stop_func_name,
					  &stop_func_start,
					  &stop_func_end);
		/* Readjust stepping range */
		step_range_start = stop_func_start;
		step_range_end = stop_func_end;
		stepping_through_sigtramp = 1;
d2755 2
d2758 3
a2760 97
	  /* If this is stepi or nexti, make sure that the stepping range
	     gets us past that instruction.  */
	  if (step_range_end == 1)
	    /* FIXME: Does this run afoul of the code below which, if
	       we step into the middle of a line, resets the stepping
	       range?  */
	    step_range_end = (step_range_start = prev_pc) + 1;

	  remove_breakpoints_on_following_step = 1;
	  goto keep_going;
	}

#if 0
      /* I disabled this test because it was too complicated and slow.
	 The SKIP_PROLOGUE was especially slow, because it caused
	 unnecessary prologue examination on various architectures.
	 The code in the #else clause has been tested on the Sparc,
	 Mips, PA, and Power architectures, so it's pretty likely to
	 be correct.  -Stu 10/24/95 */

      /* See if we left the step range due to a subroutine call that
	 we should proceed to the end of.  */

      if (stop_func_start)
	{
	  struct symtab *s;

	  /* Do this after the IN_SIGTRAMP check; it might give
	     an error.  */
	  prologue_pc = stop_func_start;

	  /* Don't skip the prologue if this is assembly source */
	  s = find_pc_symtab (stop_pc);
	  if (s && s->language != language_asm)
	    SKIP_PROLOGUE (prologue_pc);
	}

      if (!(INNER_THAN (step_sp, read_sp ()))	/* don't mistake (sig)return
						   as a call */
	  && (			/* Might be a non-recursive call.  If the symbols are missing
		 enough that stop_func_start == prev_func_start even though
		 they are really two functions, we will treat some calls as
		 jumps.  */
	       stop_func_start != prev_func_start

      /* Might be a recursive call if either we have a prologue
		 or the call instruction itself saves the PC on the stack.  */
	       || prologue_pc != stop_func_start
	       || read_sp () != step_sp)
	  && (			/* PC is completely out of bounds of any known objfiles.  Treat
		 like a subroutine call. */
	       !stop_func_start

      /* If we do a call, we will be at the start of a function...  */
	       || stop_pc == stop_func_start

      /* ...except on the Alpha with -O (and also Irix 5 and
		 perhaps others), in which we might call the address
		 after the load of gp.  Since prologues don't contain
		 calls, we can't return to within one, and we don't
		 jump back into them, so this check is OK.  */

	       || stop_pc < prologue_pc

      /* ...and if it is a leaf function, the prologue might
 		 consist of gp loading only, so the call transfers to
 		 the first instruction after the prologue.  */
	       || (stop_pc == prologue_pc

      /* Distinguish this from the case where we jump back
		     to the first instruction after the prologue,
		     within a function.  */
		   && stop_func_start != prev_func_start)

      /* If we end up in certain places, it means we did a subroutine
		 call.  I'm not completely sure this is necessary now that we
		 have the above checks with stop_func_start (and now that
		 find_pc_partial_function is pickier).  */
	       || IN_SOLIB_CALL_TRAMPOLINE (stop_pc, stop_func_name)

      /* If none of the above apply, it is a jump within a function,
		 or a return from a subroutine.  The other case is longjmp,
		 which can no longer happen here as long as the
		 handling_longjmp stuff is working.  */
	  ))
#else
      /* This test is a much more streamlined, (but hopefully correct)
	   replacement for the code above.  It's been tested on the Sparc,
	   Mips, PA, and Power architectures with good results.  */

      if (stop_pc == stop_func_start	/* Quick test */
	  || (in_prologue (stop_pc, stop_func_start) &&
	      !IN_SOLIB_RETURN_TRAMPOLINE (stop_pc, stop_func_name))
	  || IN_SOLIB_CALL_TRAMPOLINE (stop_pc, stop_func_name)
	  || stop_func_name == 0)
#endif

d2762 1
a2762 1
	  /* It's a subroutine call.  */
d2764 2
a2765 1
	  if (step_over_calls == 0)
d2767 2
a2768 5
	      /* I presume that step_over_calls is only 0 when we're
		 supposed to be stepping at the assembly language level
		 ("stepi").  Just stop.  */
	      stop_step = 1;
	      break;
d2770 6
d2777 1
a2777 3
	  if (step_over_calls > 0 || IGNORE_HELPER_CALL (stop_pc))
	    /* We're doing a "next".  */
	    goto step_over_function;
d2779 1
a2779 25
	  /* If we are in a function call trampoline (a stub between
	     the calling routine and the real function), locate the real
	     function.  That's what tells us (a) whether we want to step
	     into it at all, and (b) what prologue we want to run to
	     the end of, if we do step into it.  */
	  tmp = SKIP_TRAMPOLINE_CODE (stop_pc);
	  if (tmp != 0)
	    stop_func_start = tmp;
	  else
	    {
	      tmp = DYNAMIC_TRAMPOLINE_NEXTPC (stop_pc);
	      if (tmp)
		{
		  struct symtab_and_line xxx;
		  /* Why isn't this s_a_l called "sr_sal", like all of the
		     other s_a_l's where this code is duplicated?  */
		  INIT_SAL (&xxx);	/* initialize to zeroes */
		  xxx.pc = tmp;
		  xxx.section = find_pc_overlay (xxx.pc);
		  step_resume_breakpoint =
		    set_momentary_breakpoint (xxx, NULL, bp_step_resume);
		  insert_breakpoints ();
		  goto keep_going;
		}
	    }
d2781 9
a2789 2
	  /* If we have line number information for the function we
	     are thinking of stepping into, step into it.
d2791 5
a2795 5
	     If there are several symtabs at that PC (e.g. with include
	     files), just want to know whether *any* of them have line
	     numbers.  find_pc_line handles this.  */
	  {
	    struct symtab_and_line tmp_sal;
d2797 2
a2798 4
	    tmp_sal = find_pc_line (stop_func_start, 0);
	    if (tmp_sal.line != 0)
	      goto step_into_function;
	  }
d2800 2
a2801 2
	step_over_function:
	  /* A subroutine call has happened.  */
d2803 1
a2803 1
	    /* Set a special breakpoint after the return */
d2806 7
a2812 11
	    INIT_SAL (&sr_sal);
	    sr_sal.symtab = NULL;
	    sr_sal.line = 0;

	    /* If we came here after encountering a signal in the middle of
               a "next", use the stashed-away previous frame pc */
	    sr_sal.pc
	      = stopped_by_random_signal
	      ? prev_pc
	      : ADDR_BITS_REMOVE (SAVED_PC_AFTER_CALL (get_current_frame ()));

d2814 1
a2814 32
	      set_momentary_breakpoint (sr_sal,
					stopped_by_random_signal ?
					NULL : get_current_frame (),
					bp_step_resume);

	    /* We've just entered a callee, and we wish to resume until
               it returns to the caller.  Setting a step_resume bp on
               the return PC will catch a return from the callee.

               However, if the callee is recursing, we want to be
               careful not to catch returns of those recursive calls,
               but of THIS instance of the call.

               To do this, we set the step_resume bp's frame to our
               current caller's frame (step_frame_address, which is
               set by the "next" or "until" command, before execution
               begins).

               But ... don't do it if we're single-stepping out of a
               sigtramp, because the reason we're single-stepping is
               precisely because unwinding is a problem (HP-UX 10.20,
               e.g.) and the frame address is likely to be incorrect.
               No danger of sigtramp recursion.  */

	    if (stepping_through_sigtramp)
	      {
		step_resume_breakpoint->frame = (CORE_ADDR) NULL;
		stepping_through_sigtramp = 0;
	      }
	    else if (!IN_SOLIB_DYNSYM_RESOLVE_CODE (sr_sal.pc))
	      step_resume_breakpoint->frame = step_frame_address;

d2817 5
d2823 1
a2823 1
	  goto keep_going;
d2825 11
a2835 24
	step_into_function:
	  /* Subroutine call with source code we should not step over.
	     Do step to the first line of code in it.  */
	  {
	    struct symtab *s;

	    s = find_pc_symtab (stop_pc);
	    if (s && s->language != language_asm)
	      SKIP_PROLOGUE (stop_func_start);
	  }
	  sal = find_pc_line (stop_func_start, 0);
	  /* Use the step_resume_break to step until
	     the end of the prologue, even if that involves jumps
	     (as it seems to on the vax under 4.2).  */
	  /* If the prologue ends in the middle of a source line,
	     continue to the end of that source line (if it is still
	     within the function).  Otherwise, just go to end of prologue.  */
#ifdef PROLOGUE_FIRSTLINE_OVERLAP
	  /* no, don't either.  It skips any code that's
	     legitimately on the first line.  */
#else
	  if (sal.end && sal.pc != stop_func_start && sal.end < stop_func_end)
	    stop_func_start = sal.end;
#endif
d2837 12
a2848 10
	  if (stop_func_start == stop_pc)
	    {
	      /* We are already there: stop now.  */
	      stop_step = 1;
	      break;
	    }
	  else
	    /* Put the step-breakpoint there and go until there. */
	    {
	      struct symtab_and_line sr_sal;
d2850 1
a2850 10
	      INIT_SAL (&sr_sal);	/* initialize to zeroes */
	      sr_sal.pc = stop_func_start;
	      sr_sal.section = find_pc_overlay (stop_func_start);
	      /* Do not specify what the fp should be when we stop
		 since on some machines the prologue
		 is where the new fp value is established.  */
	      step_resume_breakpoint =
		set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
	      if (breakpoints_inserted)
		insert_breakpoints ();
d2852 4
a2855 5
	      /* And make sure stepping stops right away then.  */
	      step_range_end = step_range_start;
	    }
	  goto keep_going;
	}
d2857 26
a2882 1
      /* We've wandered out of the step range.  */
d2884 1
a2884 1
      sal = find_pc_line (stop_pc, 0);
d2886 2
a2887 13
      if (step_range_end == 1)
	{
	  /* It is stepi or nexti.  We always want to stop stepping after
	     one instruction.  */
	  stop_step = 1;
	  break;
	}

      /* If we're in the return path from a shared library trampoline,
	 we want to proceed through the trampoline when stepping.  */
      if (IN_SOLIB_RETURN_TRAMPOLINE (stop_pc, stop_func_name))
	{
	  CORE_ADDR tmp;
d2889 1
a2889 2
	  /* Determine where this trampoline returns.  */
	  tmp = SKIP_TRAMPOLINE_CODE (stop_pc);
d2891 10
a2900 5
	  /* Only proceed through if we know where it's going.  */
	  if (tmp)
	    {
	      /* And put the step-breakpoint there and go until there. */
	      struct symtab_and_line sr_sal;
d2902 30
a2931 10
	      INIT_SAL (&sr_sal);	/* initialize to zeroes */
	      sr_sal.pc = tmp;
	      sr_sal.section = find_pc_overlay (sr_sal.pc);
	      /* Do not specify what the fp should be when we stop
		 since on some machines the prologue
		 is where the new fp value is established.  */
	      step_resume_breakpoint =
		set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
	      if (breakpoints_inserted)
		insert_breakpoints ();
d2933 4
a2936 5
	      /* Restart without fiddling with the step ranges or
		 other state.  */
	      goto keep_going;
	    }
	}
d2938 2
a2939 9
      if (sal.line == 0)
	{
	  /* We have no line number information.  That means to stop
	     stepping (does this always happen right after one instruction,
	     when we do "s" in a function with no line numbers,
	     or can this happen as a result of a return or longjmp?).  */
	  stop_step = 1;
	  break;
	}
d2941 5
a2945 10
      if ((stop_pc == sal.pc)
	  && (current_line != sal.line || current_symtab != sal.symtab))
	{
	  /* We are at the start of a different line.  So stop.  Note that
	     we don't stop if we step into the middle of a different line.
	     That is said to make things like for (;;) statements work
	     better.  */
	  stop_step = 1;
	  break;
	}
d2947 20
a2966 1
      /* We aren't done stepping.
d2968 22
a2989 29
	 Optimize by setting the stepping range to the line.
	 (We might not be in the original line, but if we entered a
	 new line in mid-statement, we continue stepping.  This makes
	 things like for(;;) statements work better.)  */

      if (stop_func_end && sal.end >= stop_func_end)
	{
	  /* If this is the last line of the function, don't keep stepping
	     (it would probably step us out of the function).
	     This is particularly necessary for a one-line function,
	     in which after skipping the prologue we better stop even though
	     we will be in mid-line.  */
	  stop_step = 1;
	  break;
	}
      step_range_start = sal.pc;
      step_range_end = sal.end;
      step_frame_address = FRAME_FP (get_current_frame ());
      current_line = sal.line;
      current_symtab = sal.symtab;

      /* In the case where we just stepped out of a function into the middle
         of a line of the caller, continue stepping, but step_frame_address
         must be modified to current frame */
      {
	CORE_ADDR current_frame = FRAME_FP (get_current_frame ());
	if (!(INNER_THAN (current_frame, step_frame_address)))
	  step_frame_address = current_frame;
      }
d2991 5
d2997 11
a3007 30
      goto keep_going;

    check_sigtramp2:
      if (trap_expected
	  && IN_SIGTRAMP (stop_pc, stop_func_name)
	  && !IN_SIGTRAMP (prev_pc, prev_func_name)
	  && INNER_THAN (read_sp (), step_sp))
	{
	  /* What has happened here is that we have just stepped the inferior
	     with a signal (because it is a signal which shouldn't make
	     us stop), thus stepping into sigtramp.

	     So we need to set a step_resume_break_address breakpoint
	     and continue until we hit it, and then step.  FIXME: This should
	     be more enduring than a step_resume breakpoint; we should know
	     that we will later need to keep going rather than re-hitting
	     the breakpoint here (see testsuite/gdb.t06/signals.exp where
	     it says "exceedingly difficult").  */
	  struct symtab_and_line sr_sal;

	  INIT_SAL (&sr_sal);	/* initialize to zeroes */
	  sr_sal.pc = prev_pc;
	  sr_sal.section = find_pc_overlay (sr_sal.pc);
	  /* We perhaps could set the frame if we kept track of what
	     the frame corresponding to prev_pc was.  But we don't,
	     so don't.  */
	  through_sigtramp_breakpoint =
	    set_momentary_breakpoint (sr_sal, NULL, bp_through_sigtramp);
	  if (breakpoints_inserted)
	    insert_breakpoints ();
d3009 4
a3012 74
	  remove_breakpoints_on_following_step = 1;
	  another_trap = 1;
	}

    keep_going:
      /* Come to this label when you need to resume the inferior.
	 It's really much cleaner to do a goto than a maze of if-else
	 conditions.  */

      /* ??rehrauer: ttrace on HP-UX theoretically allows one to debug
         a vforked child beetween its creation and subsequent exit or
         call to exec().  However, I had big problems in this rather
         creaky exec engine, getting that to work.  The fundamental
         problem is that I'm trying to debug two processes via an
         engine that only understands a single process with possibly
         multiple threads.

         Hence, this spot is known to have problems when
         target_can_follow_vfork_prior_to_exec returns 1. */

      /* Save the pc before execution, to compare with pc after stop.  */
      prev_pc = read_pc ();	/* Might have been DECR_AFTER_BREAK */
      prev_func_start = stop_func_start;	/* Ok, since if DECR_PC_AFTER
					  BREAK is defined, the
					  original pc would not have
					  been at the start of a
					  function. */
      prev_func_name = stop_func_name;

      if (update_step_sp)
	step_sp = read_sp ();
      update_step_sp = 0;

      /* If we did not do break;, it means we should keep
	 running the inferior and not return to debugger.  */

      if (trap_expected && stop_signal != TARGET_SIGNAL_TRAP)
	{
	  /* We took a signal (which we are supposed to pass through to
	     the inferior, else we'd have done a break above) and we
	     haven't yet gotten our trap.  Simply continue.  */
	  resume (CURRENTLY_STEPPING (), stop_signal);
	}
      else
	{
	  /* Either the trap was not expected, but we are continuing
	     anyway (the user asked that this signal be passed to the
	     child)
	       -- or --
	     The signal was SIGTRAP, e.g. it was our signal, but we
	     decided we should resume from it.

	     We're going to run this baby now!

	     Insert breakpoints now, unless we are trying
	     to one-proceed past a breakpoint.  */
	  /* If we've just finished a special step resume and we don't
	     want to hit a breakpoint, pull em out.  */
	  if (step_resume_breakpoint == NULL
	      && through_sigtramp_breakpoint == NULL
	      && remove_breakpoints_on_following_step)
	    {
	      remove_breakpoints_on_following_step = 0;
	      remove_breakpoints ();
	      breakpoints_inserted = 0;
	    }
	  else if (!breakpoints_inserted &&
		   (through_sigtramp_breakpoint != NULL || !another_trap))
	    {
	      breakpoints_failed = insert_breakpoints ();
	      if (breakpoints_failed)
		break;
	      breakpoints_inserted = 1;
	    }
d3014 3
a3016 1
	  trap_expected = another_trap;
d3018 3
a3020 12
          /* Do not deliver SIGNAL_TRAP (except when the user
	     explicitly specifies that such a signal should be
	     delivered to the target program).

	     Typically, this would occure when a user is debugging a
	     target monitor on a simulator: the target monitor sets a
	     breakpoint; the simulator encounters this break-point and
	     halts the simulation handing control to GDB; GDB, noteing
	     that the break-point isn't valid, returns control back to
	     the simulator; the simulator then delivers the hardware
	     equivalent of a SIGNAL_TRAP to the program being
	     debugged. */
d3022 2
a3023 3
	  if (stop_signal == TARGET_SIGNAL_TRAP
	      && !signal_program[stop_signal])
	    stop_signal = TARGET_SIGNAL_0;
d3025 3
a3027 12
#ifdef SHIFT_INST_REGS
	  /* I'm not sure when this following segment applies.  I do know,
	     now, that we shouldn't rewrite the regs when we were stopped
	     by a random signal from the inferior process.  */
	  /* FIXME: Shouldn't this be based on the valid bit of the SXIP?
	     (this is only used on the 88k).  */

	  if (!bpstat_explains_signal (stop_bpstat)
	      && (stop_signal != TARGET_SIGNAL_CHLD)
	      && !stopped_by_random_signal)
	    SHIFT_INST_REGS ();
#endif /* SHIFT_INST_REGS */
d3029 3
a3031 5
	  resume (CURRENTLY_STEPPING (), stop_signal);
	}
    }

stop_stepping:
d3036 3
a3038 2
         parent's event.  And, inferior_pid is still set to the parent's
         pid, until we resume again and follow either the parent or child.
d3051 1
a3051 1
		parent_pid = target_wait_hook (-1, &w);
d3053 1
a3053 1
		parent_pid = target_wait (-1, &w);
a3057 1

d3059 2
a3060 2
	 time, just like we did above if we didn't break out of the
	 loop.  */
d3062 2
a3063 2
      prev_func_start = stop_func_start;
      prev_func_name = stop_func_name;
d3065 3
a3067 1
  do_cleanups (old_cleanups);
d3070 6
a3075 9
/* This function returns TRUE if ep is an internal breakpoint
   set to catch generic shared library (aka dynamically-linked
   library) events.  (This is *NOT* the same as a catchpoint for a
   shlib event.  The latter is something a user can set; this is
   something gdb sets for its own use, and isn't ever shown to a
   user.) */
static int
is_internal_shlib_eventpoint (ep)
     struct breakpoint *ep;
d3077 25
a3101 4
  return
    (ep->type == bp_shlib_event)
    ;
}
d3103 8
a3110 10
/* This function returns TRUE if bs indicates that the inferior
   stopped due to a shared library (aka dynamically-linked library)
   event. */
static int
stopped_for_internal_shlib_event (bs)
     bpstat bs;
{
  /* Note that multiple eventpoints may've caused the stop.  Any
     that are associated with shlib events will be accepted. */
  for (; bs != NULL; bs = bs->next)
d3112 65
a3176 3
      if ((bs->breakpoint_at != NULL)
	  && is_internal_shlib_eventpoint (bs->breakpoint_at))
	return 1;
d3179 1
a3179 2
  /* If we get here, then no candidate was found. */
  return 0;
d3182 16
a3197 3
/* This function returns TRUE if bs indicates that the inferior
   stopped due to a shared library (aka dynamically-linked library)
   event caught by a catchpoint.
d3199 9
a3207 1
   If TRUE, cp_p is set to point to the catchpoint.
d3209 7
a3215 5
   Else, the value of cp_p is undefined. */
static int
stopped_for_shlib_catchpoint (bs, cp_p)
     bpstat bs;
     struct breakpoint **cp_p;
d3217 39
a3255 3
  /* Note that multiple eventpoints may've caused the stop.  Any
     that are associated with shlib events will be accepted. */
  *cp_p = NULL;
d3257 15
a3271 4
  for (; bs != NULL; bs = bs->next)
    {
      if ((bs->breakpoint_at != NULL)
	  && ep_is_shlib_catchpoint (bs->breakpoint_at))
d3273 1
a3273 2
	  *cp_p = bs->breakpoint_at;
	  return 1;
d3275 40
a3315 3

  /* If we get here, then no candidate was found. */
  return 0;
d3328 1
a3328 1
normal_stop ()
a3329 2

#ifdef HPUXHPPA
d3336 2
a3337 2
  if ((switched_from_inferior_pid != inferior_pid) &&
      target_has_execution)
d3340 1
a3340 1
      printf_filtered ("[Switched to %s]\n",
d3342 1
a3342 1
      switched_from_inferior_pid = inferior_pid;
a3343 1
#endif
a3389 8
  /* Did we stop because the user set the stop_on_solib_events
     variable?  (If so, we report this as a generic, "Stopped due
     to shlib event" message.) */
  if (stopped_for_internal_shlib_event (stop_bpstat))
    {
      printf_filtered ("Stopped due to shared library event\n");
    }

d3414 4
a3417 4
	 we have changed functions or hit a breakpoint.
	 Print source line if we have one.
	 bpstat_print() contains the logic deciding in detail
	 what to print, based on the event(s) that just occurred. */
d3423 1
d3426 22
a3447 17
	  /* bpstat_print() returned one of:
             -1: Didn't print anything
              0: Printed preliminary "Breakpoint n, " message, desires
                 location tacked on
              1: Printed something, don't tack on location */

	  if (bpstat_ret == -1)
	    if (stop_step
		&& step_frame_address == FRAME_FP (get_current_frame ())
		&& step_start_function == find_pc_function (stop_pc))
	      source_flag = -1;	/* finished step, just print source line */
	    else
	      source_flag = 1;	/* print location and source line */
	  else if (bpstat_ret == 0)	/* hit bpt, desire location */
	    source_flag = 1;	/* print location and source line */
	  else			/* bpstat_ret == 1, hit bpt, do not desire location */
	    source_flag = -1;	/* just print source line */
d3451 5
a3455 4
	     -1: Print only source line
	     0: Print only location
	     1: Print location and source line */
	  show_and_print_stack_frame (selected_frame, -1, source_flag);
d3471 1
a3471 1
	 can use that next. */
d3474 2
a3475 2
	 Can't rely on restore_inferior_status because that only gets
	 called if we don't stop in the called function.  */
d3488 1
a3488 2
hook_stop_stub (cmd)
     PTR cmd;
d3494 19
a3512 2
int 
signal_stop_state (signo)
d3514 1
d3516 3
a3518 1
  return signal_stop[signo];
d3521 1
a3521 2
int 
signal_print_state (signo)
d3523 1
d3525 3
a3527 1
  return signal_print[signo];
d3530 1
a3530 2
int 
signal_pass_state (signo)
d3532 1
d3534 3
a3536 1
  return signal_program[signo];
d3540 1
a3540 1
sig_print_header ()
d3547 1
a3547 2
sig_print_info (oursig)
     enum target_signal oursig;
d3551 1
d3567 1
a3567 3
handle_command (args, from_tty)
     char *args;
     int from_tty;
d3596 1
a3596 1
  old_chain = make_cleanup ((make_cleanup_func) freeargv, (char *) argv);
d3692 1
a3692 1
	 which signals to apply actions to. */
d3749 1
a3749 3
xdb_handle_command (args, from_tty)
     char *args;
     int from_tty;
d3761 1
a3761 1
  old_chain = make_cleanup ((make_cleanup_func) freeargv, (char *) argv);
d3821 1
a3821 3
signals_info (signum_exp, from_tty)
     char *signum_exp;
     int from_tty;
d3857 58
d3919 2
a3920 4
void
save_inferior_status (inf_status, restore_stack_info)
     struct inferior_status *inf_status;
     int restore_stack_info;
d3922 2
d3938 2
a3939 1
     hand them back the original chain when restore_i_s is called.  */
d3952 1
a3952 1
  return;
a3960 7
static int restore_selected_frame PARAMS ((PTR));

/* Restore the selected frame.  args is really a struct
   restore_selected_frame_args * (declared as char * for catch_errors)
   telling us what frame to restore.  Returns 1 for success, or 0 for
   failure.  An error message will have been printed on error.  */

d3962 1
a3962 2
restore_selected_frame (args)
     PTR args;
d3976 3
a3978 3
	 for function called by hand gdb creates no internal frame
	 structure and the real stack and gdb's idea of stack are
	 different if nested calls by hands are made.
d3980 1
a3980 1
	 mvs: this worries me.  */
d3993 1
a3993 2
restore_inferior_status (inf_status)
     struct inferior_status *inf_status;
d4012 1
a4019 3
  /* The inferior can be gone if the user types "print exit(0)"
     (and perhaps other times).  */

d4033 2
a4034 2
	 walking the stack might encounter a garbage pointer and error()
	 trying to dereference it.  */
d4045 2
a4047 1

d4049 7
d4057 3
a4059 5
void
set_follow_fork_mode_command (arg, from_tty, c)
     char *arg;
     int from_tty;
     struct cmd_list_element *c;
d4072 5
a4076 1

d4079 1
a4079 1
_initialize_infrun ()
d4085 5
d4176 11
d4207 14
a4220 14
/*			"Set debugger response to a program call of fork \
or vfork.\n\
A fork or vfork creates a new process.  follow-fork-mode can be:\n\
  parent  - the original process is debugged after a fork\n\
  child   - the new process is debugged after a fork\n\
  both    - both the parent and child are debugged after a fork\n\
  ask     - the debugger will ask for one of the above choices\n\
For \"both\", another copy of the debugger will be started to follow\n\
the new child process.  The original debugger will continue to follow\n\
the original parent process.  To distinguish their prompts, the\n\
debugger copy's prompt will be changed.\n\
For \"parent\" or \"child\", the unfollowed process will run free.\n\
By default, the debugger will follow the parent process.",
*/
d4230 1
a4230 1
/*  c->function.sfunc = ;*/
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d2 2
a3 1
   Copyright 1986-1989, 1991-1999 Free Software Foundation, Inc.
a34 1
#include "top.h"
a53 2
static void set_follow_fork_mode_command PARAMS ((char *arg, int from_tty, struct cmd_list_element *c));

d57 1
a61 16

/* This will be true for configurations that may actually report an
   inferior pid different from the original.  At present this is only
   true for HP-UX native.  */

#ifndef MAY_SWITCH_FROM_INFERIOR_PID
#define MAY_SWITCH_FROM_INFERIOR_PID (0)
#endif

static int may_switch_from_inferior_pid = MAY_SWITCH_FROM_INFERIOR_PID;

/* This is true for configurations that may follow through execl() and
   similar functions.  At present this is only true for HP-UX native.  */

#ifndef MAY_FOLLOW_EXEC
#define MAY_FOLLOW_EXEC (0)
a63 2
static int may_follow_exec = MAY_FOLLOW_EXEC;

a78 9
/* This is true if thread_step_needed should actually be used.  At
   present this is only true for HP-UX native.  */

#ifndef USE_THREAD_STEP_NEEDED
#define USE_THREAD_STEP_NEEDED (0)
#endif

static int use_thread_step_needed = USE_THREAD_STEP_NEEDED;

a166 24
/* Convert the #defines into values.  This is temporary until wfi control
   flow is completely sorted out.  */

#ifndef HAVE_STEPPABLE_WATCHPOINT
#define HAVE_STEPPABLE_WATCHPOINT 0
#else
#undef  HAVE_STEPPABLE_WATCHPOINT
#define HAVE_STEPPABLE_WATCHPOINT 1
#endif

#ifndef HAVE_NONSTEPPABLE_WATCHPOINT
#define HAVE_NONSTEPPABLE_WATCHPOINT 0
#else
#undef  HAVE_NONSTEPPABLE_WATCHPOINT
#define HAVE_NONSTEPPABLE_WATCHPOINT 1
#endif

#ifndef HAVE_CONTINUABLE_WATCHPOINT
#define HAVE_CONTINUABLE_WATCHPOINT 0
#else
#undef  HAVE_CONTINUABLE_WATCHPOINT
#define HAVE_CONTINUABLE_WATCHPOINT 1
#endif

d242 1
a242 1
char *stop_registers;
d311 1
a351 1
#ifdef SOLIB_REMOVE_INFERIOR_HOOK
a352 1
#endif
a383 1
#ifdef SOLIB_REMOVE_INFERIOR_HOOK
a384 1
#endif
d511 1
d518 1
d520 1
a520 4
  struct target_ops *tgt;

  if (!may_follow_exec)
    return;
a573 7

  /* First collect the run target in effect.  */
  tgt = find_run_target ();
  /* If we can't find one, things are in a very strange state...  */
  if (tgt == NULL)
    error ("Could find run target to save before following exec");

d576 2
a577 2
  inferior_pid = saved_pid;   /* Because mourn_inferior resets inferior_pid. */
  push_target (tgt);
a587 1
#if defined(SOLIB_RESTART)
a588 2
#endif
#ifdef SOLIB_CREATE_INFERIOR_HOOK
a589 1
#endif
d600 1
d683 1
d720 1
d727 2
a728 1
      if (use_thread_step_needed && thread_step_needed)
d756 1
d1007 3
d1024 2
d1027 1
d1048 1
d1050 2
a1051 2
  if (may_switch_from_inferior_pid)
    switched_from_inferior_pid = inferior_pid;
d1055 2
d1084 2
d1087 1
d1108 8
a1115 1
	  printf_filtered ("[New %s]\n", target_pid_or_tid_to_str (pid));
d1151 2
d1258 6
a1263 4
	     (DECR_PC_AFTER_BREAK ? 
	      (prev_pc != stop_pc - DECR_PC_AFTER_BREAK
	       && CURRENTLY_STEPPING ())
	      : 0)
d1313 7
a1319 5
	     (DECR_PC_AFTER_BREAK ? 
	      (prev_pc != stop_pc - DECR_PC_AFTER_BREAK
	       && CURRENTLY_STEPPING ())
	      : 0)
	     );
d1383 7
a1389 5
	     (DECR_PC_AFTER_BREAK ? 
	      (prev_pc != stop_pc - DECR_PC_AFTER_BREAK
	       && CURRENTLY_STEPPING ())
	      : 0)
	     );
d1511 2
a1512 8
		    /* We need to restart all the threads now,
		     * unles we're running in scheduler-locked mode. 
		     * FIXME: shouldn't we look at CURRENTLY_STEPPING ()?
		     */
		    if (scheduler_mode == schedlock_on)
		      target_resume (pid, 0, TARGET_SIGNAL_0);
		    else
		      target_resume (-1, 0, TARGET_SIGNAL_0);
d1597 3
a1599 2
	  if (may_switch_from_inferior_pid)
	    switched_from_inferior_pid = inferior_pid;
d1633 3
d1640 3
a1642 1

d1658 1
d1662 1
a1662 1
      if (HAVE_STEPPABLE_WATCHPOINT && STOPPED_BY_WATCHPOINT (w))
d1667 1
d1669 20
a1688 21
      /* It is far more common to need to disable a watchpoint to step
	 the inferior over it.  FIXME.  What else might a debug
	 register or page protection watchpoint scheme need here?  */
      if (HAVE_NONSTEPPABLE_WATCHPOINT && STOPPED_BY_WATCHPOINT (w))
	{
	  /* At this point, we are stopped at an instruction which has
	     attempted to write to a piece of memory under control of
	     a watchpoint.  The instruction hasn't actually executed
	     yet.  If we were to evaluate the watchpoint expression
	     now, we would get the old value, and therefore no change
	     would seem to have occurred.

	     In order to make watchpoints work `right', we really need
	     to complete the memory write, and then evaluate the
	     watchpoint expression.  The following code does that by
	     removing the watchpoint (actually, all watchpoints and
	     breakpoints), single-stepping the target, re-inserting
	     watchpoints, and then falling through to let normal
	     single-step processing handle proceed.  Since this
	     includes evaluating watchpoints, things will come to a
	     stop in the correct manner.  */
d1708 1
d1710 1
d1712 2
a1713 2
      if (HAVE_CONTINUABLE_WATCHPOINT)
	STOPPED_BY_WATCHPOINT (w);
d1803 4
a1806 3
		  || (!CALL_DUMMY_BREAKPOINT_OFFSET_P
		      && PC_IN_CALL_DUMMY (stop_pc, read_sp (),
					   FRAME_FP (get_current_frame ())))
d1813 7
a1819 6
		    /* End of a stack dummy.  Some systems (e.g. Sony
		       news) give another signal besides SIGTRAP, so
		       check here as well as above.  */
		    || (!CALL_DUMMY_BREAKPOINT_OFFSET_P
			&& PC_IN_CALL_DUMMY (stop_pc, read_sp (),
					     FRAME_FP (get_current_frame ())))
d2066 2
d2180 13
a2192 1
      if (!CALL_DUMMY_BREAKPOINT_OFFSET_P)
d2194 2
a2195 15
	  /* This is the old way of detecting the end of the stack dummy.
	     An architecture which defines CALL_DUMMY_BREAKPOINT_OFFSET gets
	     handled above.  As soon as we can test it on all of them, all
	     architectures should define it.  */
	  
	  /* If this is the breakpoint at the end of a stack dummy,
	     just stop silently, unless the user was doing an si/ni, in which
	     case she'd better know what she's doing.  */
	  
	  if (CALL_DUMMY_HAS_COMPLETED (stop_pc, read_sp (),
					FRAME_FP (get_current_frame ()))
	      && !step_range_end)
	    {
	      stop_print_frame = 0;
	      stop_stack_dummy = 1;
d2197 1
a2197 1
	      trap_expected_after_continue = 1;
d2199 1
a2199 2
	      break;
	    }
d2201 2
a2202 1
      
d2210 1
a2210 1
      
d2216 1
a2216 1
      
d2218 1
a2218 1
	 
d2223 15
a2237 1
	  && stop_pc < step_range_end)
d2341 78
d2424 2
d2856 1
d2944 2
d2952 2
a2953 3
  if (may_switch_from_inferior_pid
      && (switched_from_inferior_pid != inferior_pid)
      && target_has_execution)
d2960 1
d3193 1
a3193 1
  old_chain = make_cleanup_freeargv (argv);
d3360 1
a3360 1
  old_chain = make_cleanup_freeargv (argv);
a3457 66
struct inferior_status
{
  enum target_signal stop_signal;
  CORE_ADDR stop_pc;
  bpstat stop_bpstat;
  int stop_step;
  int stop_stack_dummy;
  int stopped_by_random_signal;
  int trap_expected;
  CORE_ADDR step_range_start;
  CORE_ADDR step_range_end;
  CORE_ADDR step_frame_address;
  int step_over_calls;
  CORE_ADDR step_resume_break_address;
  int stop_after_trap;
  int stop_soon_quietly;
  CORE_ADDR selected_frame_address;
  char *stop_registers;

  /* These are here because if call_function_by_hand has written some
     registers and then decides to call error(), we better not have changed
     any registers.  */
  char *registers;

  int selected_level;
  int breakpoint_proceeded;
  int restore_stack_info;
  int proceed_to_finish;
};


static struct inferior_status *xmalloc_inferior_status PARAMS ((void));
static struct inferior_status *
xmalloc_inferior_status ()
{
  struct inferior_status *inf_status;
  inf_status = xmalloc (sizeof (struct inferior_status));
  inf_status->stop_registers = xmalloc (REGISTER_BYTES);
  inf_status->registers = xmalloc (REGISTER_BYTES);
  return inf_status;
}

static void free_inferior_status PARAMS ((struct inferior_status *));
static void
free_inferior_status (inf_status)
     struct inferior_status *inf_status;
{
  free (inf_status->registers);
  free (inf_status->stop_registers);
  free (inf_status);
}

void
write_inferior_status_register (inf_status, regno, val)
     struct inferior_status *inf_status;
     int regno;
     LONGEST val;
{
  int size = REGISTER_RAW_SIZE(regno);
  void *buf = alloca (size);
  store_signed_integer (buf, size, val);
  memcpy (&inf_status->registers[REGISTER_BYTE (regno)], buf, size);
}



d3462 3
a3464 2
struct inferior_status *
save_inferior_status (restore_stack_info)
a3466 2
  struct inferior_status *inf_status = xmalloc_inferior_status ();

d3481 1
a3481 2
     hand them back the original chain when restore_inferior_status is
     called.  */
d3487 1
a3487 1
  
d3494 1
a3494 1
  return inf_status;
d3505 5
a3562 1
  /* FIXME: Is the restore of stop_registers always needed */
d3570 3
d3598 2
a3600 2
  free_inferior_status (inf_status);
}
a3602 9
discard_inferior_status (inf_status)
     struct inferior_status *inf_status;
{
  /* See save_inferior_status for info on stop_bpstat. */
  bpstat_clear (&inf_status->stop_bpstat);
  free_inferior_status (inf_status);
}

static void
a3617 2


a3618 6
static void build_infrun PARAMS ((void));
static void
build_infrun ()
{
  stop_registers = xmalloc (REGISTER_BYTES);
}
a3626 2

  build_infrun ();
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@a1058 11
/* This enum encodes possible reasons for doing a target_wait, so that
   wfi can call target_wait in one place.  (Ultimately the call will be
   moved out of the infinite loop entirely.) */

enum wfi_states {
  wfi_normal_state,
  wfi_thread_hop_state,
  wfi_nullified_state,
  wfi_nonstep_watch_state
};

a1083 4
  struct target_waitstatus tmpstatus;
  enum wfi_states wfi_state;
  int waiton_pid;
  struct target_waitstatus *wp;
a1107 2
  wfi_state = wfi_normal_state;

d1110 1
a1110 3
      if (wfi_state == wfi_normal_state)
	{
	  overlay_cache_invalid = 1;
d1112 4
a1115 5
	  /* We have to invalidate the registers BEFORE calling
	     target_wait because they can be loaded from the target
	     while in target_wait.  This makes remote debugging a bit
	     more efficient for those targets that provide critical
	     registers as part of their normal status mechanism. */
d1117 1
a1117 4
	  registers_changed ();
	  waiton_pid = -1;
	  wp = &w;
	}
d1120 1
a1120 1
	pid = target_wait_hook (waiton_pid, wp);
d1122 1
a1122 1
	pid = target_wait (waiton_pid, wp);
d1124 8
a1131 1
      switch (wfi_state)
d1133 3
a1135 15
	case wfi_normal_state:
	  /* Since we've done a wait, we have a new event.  Don't
	     carry over any expectations about needing to step over a
	     breakpoint. */
	  thread_step_needed = 0;

	  /* See comments where a TARGET_WAITKIND_SYSCALL_RETURN event
	     is serviced in this loop, below. */
	  if (enable_hw_watchpoints_after_wait)
	    {
	      TARGET_ENABLE_HW_WATCHPOINTS (inferior_pid);
	      enable_hw_watchpoints_after_wait = 0;
	    }
	  stepped_after_stopped_by_watchpoint = 0;
	  break;
d1137 1
a1137 13
	case wfi_thread_hop_state:
	  insert_breakpoints ();

	  /* We need to restart all the threads now,
	   * unles we're running in scheduler-locked mode. 
	   * FIXME: shouldn't we look at CURRENTLY_STEPPING ()?
	   */
	  if (scheduler_mode == schedlock_on)
	    target_resume (pid, 0, TARGET_SIGNAL_0);
	  else
	    target_resume (-1, 0, TARGET_SIGNAL_0);
	  wfi_state = wfi_normal_state;
	  continue;
d1139 1
a1139 5
	case wfi_nullified_state:
	  break;

	case wfi_nonstep_watch_state:
	  insert_breakpoints ();
d1141 4
a1144 7
	  /* FIXME-maybe: is this cleaner than setting a flag?  Does it
	     handle things like signals arriving and other things happening
	     in combination correctly?  */
	  stepped_after_stopped_by_watchpoint = 1;
	  break;
	}
      wfi_state = wfi_normal_state;
d1539 5
a1543 4
		      waiton_pid = pid;
		      wp = &w;
		      wfi_state = wfi_thread_hop_state;
		      continue;
d1554 1
a1554 1
		    continue;
d1676 2
d1683 6
a1688 1
	     in W. */
d1690 1
a1690 4
	  wfi_state = wfi_nullified_state;
	  waiton_pid = pid;
	  wp = &tmpstatus;
	  continue;
d1730 11
a1740 4
	  waiton_pid = pid;
	  wp = &w;
	  wfi_state = wfi_nonstep_watch_state;
	  continue;
d2480 1
a2480 1
	      stop_func_start = SKIP_PROLOGUE (stop_func_start);
@


1.1.1.4
log
@import gdb-1999-05-10
@
text
@d1053 6
d1063 5
a1067 5
enum infwait_states {
  infwait_normal_state,
  infwait_thread_hop_state,
  infwait_nullified_state,
  infwait_nonstep_watch_state
d1070 5
a1074 7
/* This structure contains what used to be local variables in
   wait_for_inferior.  Probably many of them can return to being
   locals in handle_inferior_event.  */

struct execution_control_state {
  struct target_waitstatus ws;
  struct target_waitstatus *wp;
d1076 1
a1076 1
  int random_signal;
d1080 1
d1082 1
a1082 1
  int remove_breakpoints_on_following_step;
d1085 1
a1085 1
  int handling_longjmp;	/* FIXME */
d1088 5
a1092 5
  int update_step_sp;
  int stepping_through_solib_after_catch;
  bpstat stepping_through_solib_catchpoints;
  int enable_hw_watchpoints_after_wait;
  int stepping_through_sigtramp;
d1094 1
d1096 1
a1096 1
  enum infwait_states infwait_state;
d1098 1
a1098 19
  int wait_some_more;
};

void init_execution_control_state PARAMS ((struct execution_control_state *ecs));

void handle_inferior_event PARAMS ((struct execution_control_state *ecs));

/* Wait for control to return from inferior to debugger.
   If inferior gets a signal, we may decide to start it up again
   instead of returning.  That is why there is a loop in this function.
   When this function actually returns it means the inferior
   should be left stopped and GDB should read more commands.  */

void
wait_for_inferior ()
{
  struct cleanup *old_cleanups;
  struct execution_control_state ecss;
  struct execution_control_state *ecs;
d1104 13
a1116 8

  /* wfi still stays in a loop, so it's OK just to take the address of
     a local to get the ecs pointer.  */
  ecs = &ecss;

  /* Fill in with reasonable starting values.  */
  init_execution_control_state (ecs);

d1123 1
a1123 9
  overlay_cache_invalid = 1;

  /* We have to invalidate the registers BEFORE calling target_wait
     because they can be loaded from the target while in target_wait.
     This makes remote debugging a bit more efficient for those
     targets that provide critical registers as part of their normal
     status mechanism. */

  registers_changed ();
d1127 3
a1129 4
      if (target_wait_hook)
	ecs->pid = target_wait_hook (ecs->waiton_pid, ecs->wp);
      else
	ecs->pid = target_wait (ecs->waiton_pid, ecs->wp);
d1131 5
a1135 2
      /* Now figure out what to do with the result of the result.  */
      handle_inferior_event (ecs);
d1137 4
a1140 5
      if (!ecs->wait_some_more)
	break;
    }
  do_cleanups (old_cleanups);
}
d1142 4
a1145 33
/* Prepare an execution control state for looping through a
   wait_for_inferior-type loop.  */

void
init_execution_control_state (ecs)
     struct execution_control_state *ecs;
{
  ecs->random_signal = 0;
  ecs->remove_breakpoints_on_following_step = 0;
  ecs->handling_longjmp = 0;	/* FIXME */
  ecs->update_step_sp = 0;
  ecs->stepping_through_solib_after_catch = 0;
  ecs->stepping_through_solib_catchpoints = NULL;
  ecs->enable_hw_watchpoints_after_wait = 0;
  ecs->stepping_through_sigtramp = 0;
  ecs->sal = find_pc_line (prev_pc, 0);
  ecs->current_line = ecs->sal.line;
  ecs->current_symtab = ecs->sal.symtab;
  ecs->infwait_state = infwait_normal_state;
  ecs->waiton_pid = -1;
  ecs->wp = &(ecs->ws);
}

/* Given an execution control state that has been freshly filled in
   by an event from the inferior, figure out what it means and take
   appropriate action.  */

void
handle_inferior_event (ecs)
     struct execution_control_state *ecs;
{
  CORE_ADDR tmp;
  int stepped_after_stopped_by_watchpoint;
d1147 1
a1147 3
  /* Keep this extra brace for now, minimizes diffs.  */
  {
      switch (ecs->infwait_state)
d1149 1
a1149 1
	case infwait_normal_state:
d1157 1
a1157 1
	  if (ecs->enable_hw_watchpoints_after_wait)
d1160 1
a1160 1
	      ecs->enable_hw_watchpoints_after_wait = 0;
d1165 1
a1165 1
	case infwait_thread_hop_state:
d1170 1
a1170 1
	   * FIXME: shouldn't we look at currently_stepping ()?
d1173 1
a1173 1
	    target_resume (ecs->pid, 0, TARGET_SIGNAL_0);
d1176 2
a1177 2
	  ecs->infwait_state = infwait_normal_state;
	  goto wfi_continue;
d1179 1
a1179 1
	case infwait_nullified_state:
d1182 1
a1182 1
	case infwait_nonstep_watch_state:
d1191 1
a1191 1
      ecs->infwait_state = infwait_normal_state;
d1197 1
a1197 1
      ecs->new_thread_event = ((ecs->pid != inferior_pid) && !in_thread_list (ecs->pid));
d1199 3
a1201 3
      if (ecs->ws.kind != TARGET_WAITKIND_EXITED
	  && ecs->ws.kind != TARGET_WAITKIND_SIGNALLED
	  && ecs->new_thread_event)
d1203 1
a1203 1
	  add_thread (ecs->pid);
d1205 1
a1205 1
	  printf_filtered ("[New %s]\n", target_pid_or_tid_to_str (ecs->pid));
d1228 1
a1228 1
	  goto wfi_continue;
d1232 1
a1232 1
      switch (ecs->ws.kind)
d1263 1
a1263 1
	  goto wfi_continue;
d1267 1
a1267 1
	  goto wfi_continue;
d1271 2
a1272 2
	  annotate_exited (ecs->ws.value.integer);
	  if (ecs->ws.value.integer)
d1274 1
a1274 1
			     (unsigned int) ecs->ws.value.integer);
d1282 1
a1282 1
					       (LONGEST) ecs->ws.value.integer));
d1291 1
a1291 1
	  stop_signal = ecs->ws.value.sig;
d1321 1
a1321 1
	  pending_follow.kind = ecs->ws.kind;
d1327 1
a1327 1
	  if (inferior_pid == ecs->pid)
d1330 3
a1332 3
	      pending_follow.fork_event.parent_pid = ecs->pid;
	      pending_follow.fork_event.child_pid = ecs->ws.value.related_pid;
	      goto wfi_continue;
d1337 2
a1338 2
	      pending_follow.fork_event.child_pid = ecs->pid;
	      pending_follow.fork_event.parent_pid = ecs->ws.value.related_pid;
d1341 3
a1343 3
	  stop_pc = read_pc_pid (ecs->pid);
	  ecs->saved_inferior_pid = inferior_pid;
	  inferior_pid = ecs->pid;
d1348 1
a1348 1
	       && currently_stepping (ecs))
d1351 2
a1352 2
	  ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
	  inferior_pid = ecs->saved_inferior_pid;
d1364 1
a1364 1
	  pending_follow.kind = ecs->ws.kind;
d1372 1
a1372 1
	  if (ecs->pid == inferior_pid)
d1375 2
a1376 2
	      pending_follow.fork_event.parent_pid = ecs->pid;
	      pending_follow.fork_event.child_pid = ecs->ws.value.related_pid;
d1385 2
a1386 2
	      pending_follow.fork_event.child_pid = ecs->pid;
	      pending_follow.fork_event.parent_pid = ecs->ws.value.related_pid;
d1391 2
a1392 2
		  target_resume (ecs->pid, 0, TARGET_SIGNAL_0);
		  goto wfi_continue;
d1401 1
a1401 1
	       && currently_stepping (ecs))
d1404 1
a1404 1
	  ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
d1419 2
a1420 2
	      target_resume (ecs->pid, 0, TARGET_SIGNAL_0);
	      goto wfi_continue;
d1425 2
a1426 2
	  pending_follow.execd_pathname = savestring (ecs->ws.value.execd_pathname,
					   strlen (ecs->ws.value.execd_pathname));
d1452 1
a1452 1
		target_resume (ecs->pid, 1, TARGET_SIGNAL_0);
d1454 1
a1454 1
	      goto wfi_continue;
d1462 3
a1464 3
	  stop_pc = read_pc_pid (ecs->pid);
	  ecs->saved_inferior_pid = inferior_pid;
	  inferior_pid = ecs->pid;
d1469 1
a1469 1
	       && currently_stepping (ecs))
d1472 2
a1473 2
	  ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
	  inferior_pid = ecs->saved_inferior_pid;
d1500 1
a1500 1
	  goto wfi_continue;
d1513 1
a1513 1
	   Thus, we simply set the flag ecs->enable_hw_watchpoints_after_wait
d1517 1
a1517 1
	  target_resume (ecs->pid, 1, TARGET_SIGNAL_0);
d1522 1
a1522 1
	      ecs->enable_hw_watchpoints_after_wait =
d1525 1
a1525 1
	  goto wfi_continue;
d1528 1
a1528 1
	  stop_signal = ecs->ws.value.sig;
d1539 1
a1539 1
      if (ecs->new_thread_event)
d1542 1
a1542 1
	  goto wfi_continue;
d1545 1
a1545 1
      stop_pc = read_pc_pid (ecs->pid);
d1554 1
a1554 1
	    ecs->random_signal = 0;
d1558 1
a1558 1
	      ecs->random_signal = 0;
d1560 1
a1560 1
					    ecs->pid))
d1566 1
a1566 1
		  write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK, ecs->pid);
d1578 1
a1578 1
		      write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK + 4, ecs->pid);
d1582 1
a1582 1
		      target_resume (ecs->pid, 1, TARGET_SIGNAL_0);
d1586 4
a1589 4
		      ecs->waiton_pid = ecs->pid;
		      ecs->wp = &(ecs->ws);
		      ecs->infwait_state = infwait_thread_hop_state;
		      goto wfi_continue;
d1594 1
a1594 1
		     * FIXME: shouldn't we look at currently_stepping ()?
d1597 1
a1597 1
		      target_resume (ecs->pid, 0, TARGET_SIGNAL_0);
d1600 1
a1600 1
		    goto wfi_continue;
d1613 1
a1613 1
	ecs->random_signal = 1;
d1622 1
a1622 1
      if ((ecs->pid != inferior_pid) &&
d1629 1
a1629 1
	  if (ecs->random_signal
d1665 2
a1666 2
	      target_resume (ecs->pid, 0, stop_signal);
	      goto wfi_continue;
d1678 5
a1682 5
			     step_frame_address, ecs->handling_longjmp,
			     ecs->another_trap,
			     ecs->stepping_through_solib_after_catch,
			     ecs->stepping_through_solib_catchpoints,
			     ecs->stepping_through_sigtramp);
d1687 1
a1687 1
	  inferior_pid = ecs->pid;
d1695 5
a1699 5
			     &step_frame_address, &ecs->handling_longjmp,
			     &ecs->another_trap,
			     &ecs->stepping_through_solib_after_catch,
			     &ecs->stepping_through_solib_catchpoints,
			     &ecs->stepping_through_sigtramp);
d1702 1
a1702 1
	    context_hook (pid_to_thread_id (ecs->pid));
d1704 1
a1704 1
	  printf_filtered ("[Switching to %s]\n", target_pid_to_str (ecs->pid));
d1719 1
a1719 1
      /*      if (INSTRUCTION_NULLIFIED && currently_stepping (ecs)) */
d1723 1
a1723 1
	  target_resume (ecs->pid, 1, TARGET_SIGNAL_0);
d1727 1
a1727 1
	     in WS. */
d1729 4
a1732 4
	  ecs->infwait_state = infwait_nullified_state;
	  ecs->waiton_pid = ecs->pid;
	  ecs->wp = &(ecs->tmpstatus);
	  goto wfi_continue;
d1738 1
a1738 1
      if (HAVE_STEPPABLE_WATCHPOINT && STOPPED_BY_WATCHPOINT (ecs->ws))
d1741 1
a1741 1
	  goto wfi_continue;
d1747 1
a1747 1
      if (HAVE_NONSTEPPABLE_WATCHPOINT && STOPPED_BY_WATCHPOINT (ecs->ws))
d1770 1
a1770 1
	  target_resume (ecs->pid, 1, TARGET_SIGNAL_0);  /* Single step */
d1772 4
a1775 4
	  ecs->waiton_pid = ecs->pid;
	  ecs->wp = &(ecs->ws);
	  ecs->infwait_state = infwait_nonstep_watch_state;
	  goto wfi_continue;
d1780 1
a1780 1
	STOPPED_BY_WATCHPOINT (ecs->ws);
d1782 3
a1784 3
      ecs->stop_func_start = 0;
      ecs->stop_func_end = 0;
      ecs->stop_func_name = 0;
d1787 4
a1790 4
      find_pc_partial_function (stop_pc, &ecs->stop_func_name,
				&ecs->stop_func_start, &ecs->stop_func_end);
      ecs->stop_func_start += FUNCTION_START_OFFSET;
      ecs->another_trap = 0;
d1795 1
a1795 1
      ecs->random_signal = 0;
d1803 2
a1804 2
	 (set ecs->another_trap to 1 to single step once)
	 3) set ecs->random_signal to 1, and the decision between 1 and 2
d1824 1
a1824 1
	      goto wfi_break;
d1827 1
a1827 1
	    goto wfi_break;
d1855 1
a1855 1
		  (currently_stepping (ecs)
d1867 1
a1867 1
	    ecs->random_signal
d1877 1
a1877 1
	      ecs->random_signal
d1886 1
a1886 1
	      if (!ecs->random_signal)
d1896 1
a1896 1
	ecs->random_signal = 1;
d1900 1
a1900 1
         1. If a catchpoint triggers for the event (ecs->random_signal == 0),
d1903 1
a1903 1
         2. If no catchpoint triggers for the event (ecs->random_signal == 1),
d1914 1
a1914 1
      if (ecs->ws.kind == TARGET_WAITKIND_FORKED)
d1916 1
a1916 1
	  if (ecs->random_signal)	/* I.e., no catchpoint triggered for this. */
d1923 1
a1923 1
      else if (ecs->ws.kind == TARGET_WAITKIND_VFORKED)
d1925 1
a1925 1
	  if (ecs->random_signal)	/* I.e., no catchpoint triggered for this. */
d1931 1
a1931 1
      else if (ecs->ws.kind == TARGET_WAITKIND_EXECD)
d1933 2
a1934 2
	  pending_follow.kind = ecs->ws.kind;
	  if (ecs->random_signal)	/* I.e., no catchpoint triggered for this. */
d1945 1
a1945 1
      if (ecs->random_signal)
d1969 1
a1969 1
	    goto wfi_break;
d2041 1
a2041 1
	    ecs->handling_longjmp = 1;	/* FIXME */
d2054 1
a2054 1
		ecs->another_trap = 1;
d2059 1
a2059 1
	    ecs->handling_longjmp = 0;	/* FIXME */
d2071 1
a2071 1
	    ecs->another_trap = 1;
d2124 1
a2124 1
	      ecs->another_trap = 1;
d2188 2
a2189 2
				       &ecs->stepping_through_solib_catchpoints);
		  ecs->stepping_through_solib_after_catch = 1;
d2193 1
a2193 1
		  ecs->another_trap = 1;
d2199 1
a2199 1
		  ecs->another_trap = 1;
d2223 1
a2223 1
      if (ecs->stepping_through_solib_after_catch)
d2227 1
a2227 1
	  if (SOLIB_IN_DYNAMIC_LINKER (ecs->pid, stop_pc))
d2229 1
a2229 1
	      ecs->another_trap = 1;
d2235 1
a2235 1
	  ecs->stepping_through_solib_after_catch = 0;
d2237 2
a2238 2
	  stop_bpstat = bpstat_copy (ecs->stepping_through_solib_catchpoints);
	  bpstat_clear (&ecs->stepping_through_solib_catchpoints);
d2263 1
a2263 1
	      goto wfi_break;
d2306 1
a2306 1
      ecs->update_step_sp = 1;
d2309 1
a2309 1
      if (IN_SIGTRAMP (stop_pc, ecs->stop_func_name)
d2368 3
a2370 3
		find_pc_partial_function (stop_pc, &ecs->stop_func_name,
					  &ecs->stop_func_start,
					  &ecs->stop_func_end);
d2372 3
a2374 3
		step_range_start = ecs->stop_func_start;
		step_range_end = ecs->stop_func_end;
		ecs->stepping_through_sigtramp = 1;
d2387 1
a2387 1
	  ecs->remove_breakpoints_on_following_step = 1;
d2391 5
a2395 5
      if (stop_pc == ecs->stop_func_start	/* Quick test */
	  || (in_prologue (stop_pc, ecs->stop_func_start) &&
	      !IN_SOLIB_RETURN_TRAMPOLINE (stop_pc, ecs->stop_func_name))
	  || IN_SOLIB_CALL_TRAMPOLINE (stop_pc, ecs->stop_func_name)
	  || ecs->stop_func_name == 0)
d2405 1
a2405 1
	      goto wfi_break;
d2419 1
a2419 1
	    ecs->stop_func_start = tmp;
d2447 1
a2447 1
	    tmp_sal = find_pc_line (ecs->stop_func_start, 0);
d2494 1
a2494 1
	    if (ecs->stepping_through_sigtramp)
d2497 1
a2497 1
		ecs->stepping_through_sigtramp = 0;
d2515 1
a2515 1
	      ecs->stop_func_start = SKIP_PROLOGUE (ecs->stop_func_start);
d2517 1
a2517 1
	  ecs->sal = find_pc_line (ecs->stop_func_start, 0);
d2528 2
a2529 2
	  if (ecs->sal.end && ecs->sal.pc != ecs->stop_func_start && ecs->sal.end < ecs->stop_func_end)
	    ecs->stop_func_start = ecs->sal.end;
d2532 1
a2532 1
	  if (ecs->stop_func_start == stop_pc)
d2536 1
a2536 1
	      goto wfi_break;
d2544 2
a2545 2
	      sr_sal.pc = ecs->stop_func_start;
	      sr_sal.section = find_pc_overlay (ecs->stop_func_start);
d2562 1
a2562 1
      ecs->sal = find_pc_line (stop_pc, 0);
d2569 1
a2569 1
	  goto wfi_break;
d2574 1
a2574 1
      if (IN_SOLIB_RETURN_TRAMPOLINE (stop_pc, ecs->stop_func_name))
d2604 1
a2604 1
      if (ecs->sal.line == 0)
d2611 1
a2611 1
	  goto wfi_break;
d2614 2
a2615 2
      if ((stop_pc == ecs->sal.pc)
	  && (ecs->current_line != ecs->sal.line || ecs->current_symtab != ecs->sal.symtab))
d2622 1
a2622 1
	  goto wfi_break;
d2632 1
a2632 1
      if (ecs->stop_func_end && ecs->sal.end >= ecs->stop_func_end)
d2640 1
a2640 1
	  goto wfi_break;
d2642 2
a2643 2
      step_range_start = ecs->sal.pc;
      step_range_end = ecs->sal.end;
d2645 2
a2646 2
      ecs->current_line = ecs->sal.line;
      ecs->current_symtab = ecs->sal.symtab;
d2662 1
a2662 1
	  && IN_SIGTRAMP (stop_pc, ecs->stop_func_name)
d2689 2
a2690 2
	  ecs->remove_breakpoints_on_following_step = 1;
	  ecs->another_trap = 1;
d2711 1
a2711 1
      prev_func_start = ecs->stop_func_start;	/* Ok, since if DECR_PC_AFTER
d2716 1
a2716 1
      prev_func_name = ecs->stop_func_name;
d2718 1
a2718 1
      if (ecs->update_step_sp)
d2720 1
a2720 1
      ecs->update_step_sp = 0;
d2730 1
a2730 1
	  resume (currently_stepping (ecs), stop_signal);
d2749 1
a2749 1
	      && ecs->remove_breakpoints_on_following_step)
d2751 1
a2751 1
	      ecs->remove_breakpoints_on_following_step = 0;
d2756 1
a2756 1
		   (through_sigtramp_breakpoint != NULL || !ecs->another_trap))
d2760 1
a2760 1
		goto wfi_break;
d2764 1
a2764 1
	  trap_expected = ecs->another_trap;
d2796 1
a2796 19
	  resume (currently_stepping (ecs), stop_signal);
	}

      /* Former continues in the main loop goto here.  */
    wfi_continue:
      /* This used to be at the top of the loop.  */
      if (ecs->infwait_state == infwait_normal_state)
	{
	  overlay_cache_invalid = 1;

	  /* We have to invalidate the registers BEFORE calling
	     target_wait because they can be loaded from the target
	     while in target_wait.  This makes remote debugging a bit
	     more efficient for those targets that provide critical
	     registers as part of their normal status mechanism. */

	  registers_changed ();
	  ecs->waiton_pid = -1;
	  ecs->wp = &(ecs->ws);
a2797 5
      /* This is the old end of the while loop.  Let everybody know
	 we want to wait for the inferior some more and get called
	 again soon.  */
      ecs->wait_some_more = 1;
      return;
a2799 3
  /* Former breaks in the main loop goto here.  */
wfi_break:

d2819 1
a2819 1
		parent_pid = target_wait_hook (-1, &(ecs->ws));
d2821 1
a2821 1
		parent_pid = target_wait (-1, &(ecs->ws));
d2830 2
a2831 2
      prev_func_start = ecs->stop_func_start;
      prev_func_name = ecs->stop_func_name;
d2833 1
a2833 16
  /* Let callers know we don't want to wait for the inferior anymore.  */
  ecs->wait_some_more = 0;
}

/* Are we in the middle of stepping?  */

int
currently_stepping (ecs)
     struct execution_control_state *ecs;
{
  return ((through_sigtramp_breakpoint == NULL
	   && !ecs->handling_longjmp
	   && ((step_range_end && step_resume_breakpoint == NULL)
	       || trap_expected))
	  || ecs->stepping_through_solib_after_catch
	  || bpstat_should_step ());
a3759 11

  /* These signals are used internally by user-level thread
     implementations.  (See signal(5) on Solaris.)  Like the above
     signals, a healthy program receives and handles them as part of
     its normal operation.  */
  signal_stop[TARGET_SIGNAL_LWP] = 0;
  signal_print[TARGET_SIGNAL_LWP] = 0;
  signal_stop[TARGET_SIGNAL_WAITING] = 0;
  signal_print[TARGET_SIGNAL_WAITING] = 0;
  signal_stop[TARGET_SIGNAL_CANCEL] = 0;
  signal_print[TARGET_SIGNAL_CANCEL] = 0;
@


1.1.1.5
log
@import gdb-1999-0519
@
text
@d928 1
a928 1
  if (PREPARE_TO_PROCEED (1) && breakpoint_here_p (read_pc ()))
@


1.1.1.6
log
@import gdb-1999-05-25 snapshot
@
text
@a106 26
static void follow_inferior_fork PARAMS ((int parent_pid,
					  int child_pid,
					  int has_forked,
					  int has_vforked));

static void follow_fork PARAMS ((int parent_pid, int child_pid));

static void follow_vfork PARAMS ((int parent_pid, int child_pid));

static void set_schedlock_func PARAMS ((char *args, int from_tty,
					struct cmd_list_element *c));

static int is_internal_shlib_eventpoint PARAMS ((struct breakpoint *ep));

static int stopped_for_internal_shlib_event PARAMS ((bpstat bs));

static int stopped_for_shlib_catchpoint PARAMS ((bpstat bs,
						 struct breakpoint **cp_p));

#if __STDC__
struct execution_control_state;
#endif
static int currently_stepping PARAMS ((struct execution_control_state *ecs));

static void xdb_handle_command PARAMS ((char *args, int from_tty));

d2910 1
a2910 1
static int
@


1.1.1.7
log
@import gdb-1999-06-14 snapshot
@
text
@a3786 3
  register_gdbarch_swap (&stop_registers, sizeof (stop_registers), NULL);
  register_gdbarch_swap (NULL, 0, build_infrun);

@


1.1.1.8
log
@import gdb-1999-07-05 snapshot
@
text
@d35 1
a36 1
#include "event-loop.h"
a55 2
static void complete_execution PARAMS ((void));

a58 3
/* In asynchronous mode, but simulating synchronous execution. */
int sync_execution = 0;

d1009 3
a1011 7
  /* Do this only if we are not using the event loop, or if the target
     does not support asynchronous execution. */
  if (!async_p || !target_has_async)
    {
      wait_for_inferior ();
      normal_stop ();
    }
d1024 1
d1032 2
a1033 18

  /* Go on waiting only in case gdb is not started in async mode, or
     in case the target doesn't support async execution. */
  if (!async_p || !target_has_async)
    {
      wait_for_inferior ();
      normal_stop ();
    }
  else
    {
      /* The 'tar rem' command should always look synchronous,
	 i.e. display the prompt only once it has connected and
	 started the target. */
      sync_execution = 1;
      push_prompt ("", "", "");
      delete_file_handler (input_fd);
      target_executing = 1;
    }
a1181 66
/* Asynchronous version of wait_for_inferior. It is called by the
   event loop whenever a change of state is detected on the file
   descriptor corresponding to the target. It can be called more than
   once to complete a single execution command. In such cases we need
   to keep the state in a global variable ASYNC_ECSS. If it is the
   last time that this function is called for a single execution
   command, then report to the user that the inferior has stopped, and
   do the necessary cleanups. */

struct execution_control_state async_ecss;
struct execution_control_state *async_ecs;

void
fetch_inferior_event ()
{
  static struct cleanup *old_cleanups;

  async_ecs = &async_ecss;  

  if (!async_ecs->wait_some_more)
    {
      old_cleanups = make_exec_cleanup (delete_breakpoint_current_contents,
				   &step_resume_breakpoint);
      make_exec_cleanup (delete_breakpoint_current_contents,
		    &through_sigtramp_breakpoint);

      /* Fill in with reasonable starting values.  */
      init_execution_control_state (async_ecs);

      thread_step_needed = 0;

      /* We'll update this if & when we switch to a new thread. */
      if (may_switch_from_inferior_pid)
	switched_from_inferior_pid = inferior_pid;

      overlay_cache_invalid = 1;

      /* We have to invalidate the registers BEFORE calling target_wait
	 because they can be loaded from the target while in target_wait.
	 This makes remote debugging a bit more efficient for those
	 targets that provide critical registers as part of their normal
	 status mechanism. */

      registers_changed ();
    }

  if (target_wait_hook)
    async_ecs->pid = target_wait_hook (async_ecs->waiton_pid, async_ecs->wp);
  else
    async_ecs->pid = target_wait (async_ecs->waiton_pid, async_ecs->wp);

  /* Now figure out what to do with the result of the result.  */
  handle_inferior_event (async_ecs);

  if (!async_ecs->wait_some_more)
    {
      do_exec_cleanups (old_cleanups);
      normal_stop ();
      /* Is there anything left to do for the command issued to
         complete? */
      do_all_continuations ();
      /* Reset things after target has stopped for the async commands. */
      complete_execution ();
    }
}

a3012 19

/* Reset proper settings after an asynchronous command has finished.
   If the execution command was in synchronous mode, register stdin
   with the event loop, and reset the prompt. */
static void
complete_execution ()
{
extern cleanup_sigint_signal_handler PARAMS ((void));

  if (sync_execution)
    {
      add_file_handler (input_fd, (file_handler_func *) call_readline, 0);
      pop_prompt ();
      sync_execution = 0;
      cleanup_sigint_signal_handler ();
      display_gdb_prompt (0);
    }
  target_executing = 0;
}
@


1.1.1.9
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d54 1
a54 1
static void set_follow_fork_mode_command PARAMS ((char *arg, int from_tty, struct cmd_list_element * c));
d122 1
a122 1
					struct cmd_list_element * c));
d124 1
a124 1
static int is_internal_shlib_eventpoint PARAMS ((struct breakpoint * ep));
d129 1
a129 1
						 struct breakpoint ** cp_p));
d134 1
a134 1
static int currently_stepping PARAMS ((struct execution_control_state * ecs));
d387 2
a388 2
   "parent", "child", "both", "ask" };
 */
d514 1
a514 1
         involvement with child_pid; our clone will take it from here... */
d549 6
a554 6
     Parent        Child           Action for gdb to take
     -------------------------------------------------------
     1                VFORK               Continue child
     2                EXEC
     3                EXEC or EXIT
     4  VFORK */
d670 1
a670 1
  inferior_pid = saved_pid;	/* Because mourn_inferior resets inferior_pid. */
d767 1
a767 1
      SOFTWARE_SINGLE_STEP (sig, 1 /*insert-breakpoints */ );
d797 3
a799 3
	   If so, then it actually ought to be waiting for us; we respond to
	   parent vfork events.  We don't actually want to resume the child
	   in this situation; we want to just get its exec event. */
d808 1
a808 1
         an exec, then now might be the time! */
d832 1
a832 1
	         where all the threads either step or continue. */
d889 1
a889 1
   or -1 for act according to how it stopped.
d891 3
a893 3
   -1 means return after that and print nothing.
   You should probably set various step_... variables
   before calling here, if you are stepping.
d913 2
a914 2
         step one instruction before inserting breakpoints
         so that we do not stop right away (and report a second
d925 2
a926 2
         (it just checks internal GDB data structures) and STEP_SKIPS_DELAY
         is slow (it needs to read memory from the target).  */
d937 2
a938 2
         over a breakpoint we just hit, 'cause we aren't
         continuing from there.
d940 4
a943 4
         It's not worth worrying about the case where a user
         asks for a "jump" at the current PC--if they get the
         hiccup of re-hiting a hit breakpoint, what else do
         they expect? */
d971 3
a973 3
         the first instruction is executed.  Force step one
         instruction to clear this condition.  This should not occur
         if step is nonzero, but it is harmless in that case.  */
d1051 2
a1052 2
         i.e. display the prompt only once it has connected and
         started the target. */
d1107 1
a1107 2
enum infwait_states
{
d1118 26
a1143 27
struct execution_control_state
  {
    struct target_waitstatus ws;
    struct target_waitstatus *wp;
    int another_trap;
    int random_signal;
    CORE_ADDR stop_func_start;
    CORE_ADDR stop_func_end;
    char *stop_func_name;
    struct symtab_and_line sal;
    int remove_breakpoints_on_following_step;
    int current_line;
    struct symtab *current_symtab;
    int handling_longjmp;	/* FIXME */
    int pid;
    int saved_inferior_pid;
    int update_step_sp;
    int stepping_through_solib_after_catch;
    bpstat stepping_through_solib_catchpoints;
    int enable_hw_watchpoints_after_wait;
    int stepping_through_sigtramp;
    int new_thread_event;
    struct target_waitstatus tmpstatus;
    enum infwait_states infwait_state;
    int waiton_pid;
    int wait_some_more;
  };
d1145 1
a1145 1
void init_execution_control_state PARAMS ((struct execution_control_state * ecs));
d1147 1
a1147 1
void handle_inferior_event PARAMS ((struct execution_control_state * ecs));
d1223 1
a1223 1
  async_ecs = &async_ecss;
d1228 1
a1228 1
					&step_resume_breakpoint);
d1230 1
a1230 1
			 &through_sigtramp_breakpoint);
d1244 4
a1247 4
         because they can be loaded from the target while in target_wait.
         This makes remote debugging a bit more efficient for those
         targets that provide critical registers as part of their normal
         status mechanism. */
d1308 17
a1324 17
    switch (ecs->infwait_state)
      {
      case infwait_normal_state:
	/* Since we've done a wait, we have a new event.  Don't
	   carry over any expectations about needing to step over a
	   breakpoint. */
	thread_step_needed = 0;

	/* See comments where a TARGET_WAITKIND_SYSCALL_RETURN event
	   is serviced in this loop, below. */
	if (ecs->enable_hw_watchpoints_after_wait)
	  {
	    TARGET_ENABLE_HW_WATCHPOINTS (inferior_pid);
	    ecs->enable_hw_watchpoints_after_wait = 0;
	  }
	stepped_after_stopped_by_watchpoint = 0;
	break;
d1326 2
a1327 2
      case infwait_thread_hop_state:
	insert_breakpoints ();
d1329 10
a1338 10
	/* We need to restart all the threads now,
	 * unles we're running in scheduler-locked mode. 
	 * FIXME: shouldn't we look at currently_stepping ()?
	 */
	if (scheduler_mode == schedlock_on)
	  target_resume (ecs->pid, 0, TARGET_SIGNAL_0);
	else
	  target_resume (-1, 0, TARGET_SIGNAL_0);
	ecs->infwait_state = infwait_normal_state;
	goto wfi_continue;
d1340 2
a1341 2
      case infwait_nullified_state:
	break;
d1343 2
a1344 2
      case infwait_nonstep_watch_state:
	insert_breakpoints ();
d1346 7
a1352 7
	/* FIXME-maybe: is this cleaner than setting a flag?  Does it
	   handle things like signals arriving and other things happening
	   in combination correctly?  */
	stepped_after_stopped_by_watchpoint = 1;
	break;
      }
    ecs->infwait_state = infwait_normal_state;
d1354 1
a1354 1
    flush_cached_frames ();
d1356 1
a1356 1
    /* If it's a new process, add it to the thread database */
d1358 1
a1358 1
    ecs->new_thread_event = ((ecs->pid != inferior_pid) && !in_thread_list (ecs->pid));
d1360 5
a1364 5
    if (ecs->ws.kind != TARGET_WAITKIND_EXITED
	&& ecs->ws.kind != TARGET_WAITKIND_SIGNALLED
	&& ecs->new_thread_event)
      {
	add_thread (ecs->pid);
d1366 1
a1366 1
	printf_filtered ("[New %s]\n", target_pid_or_tid_to_str (ecs->pid));
d1369 18
a1386 18
	/* NOTE: This block is ONLY meant to be invoked in case of a
	   "thread creation event"!  If it is invoked for any other
	   sort of event (such as a new thread landing on a breakpoint),
	   the event will be discarded, which is almost certainly
	   a bad thing!

	   To avoid this, the low-level module (eg. target_wait)
	   should call in_thread_list and add_thread, so that the
	   new thread is known by the time we get here.  */

	/* We may want to consider not doing a resume here in order
	   to give the user a chance to play with the new thread.
	   It might be good to make that a user-settable option.  */

	/* At this point, all threads are stopped (happens
	   automatically in either the OS or the native code).
	   Therefore we need to continue all threads in order to
	   make progress.  */
d1388 2
a1389 2
	target_resume (-1, 0, TARGET_SIGNAL_0);
	goto wfi_continue;
d1391 1
a1391 1
      }
d1393 6
a1398 6
    switch (ecs->ws.kind)
      {
      case TARGET_WAITKIND_LOADED:
	/* Ignore gracefully during startup of the inferior, as it
	   might be the shell which has just loaded some objects,
	   otherwise add the symbols for the newly loaded objects.  */
d1400 6
a1405 6
	if (!stop_soon_quietly)
	  {
	    /* Remove breakpoints, SOLIB_ADD might adjust
	       breakpoint addresses via breakpoint_re_set.  */
	    if (breakpoints_inserted)
	      remove_breakpoints ();
d1407 10
a1416 10
	    /* Check for any newly added shared libraries if we're
	       supposed to be adding them automatically.  */
	    if (auto_solib_add)
	      {
		/* Switch terminal for any messages produced by
		   breakpoint_re_set.  */
		target_terminal_ours_for_output ();
		SOLIB_ADD (NULL, 0, NULL);
		target_terminal_inferior ();
	      }
d1418 4
a1421 4
	    /* Reinsert breakpoints and continue.  */
	    if (breakpoints_inserted)
	      insert_breakpoints ();
	  }
d1423 2
a1424 2
	resume (0, TARGET_SIGNAL_0);
	goto wfi_continue;
d1426 75
a1500 75
      case TARGET_WAITKIND_SPURIOUS:
	resume (0, TARGET_SIGNAL_0);
	goto wfi_continue;

      case TARGET_WAITKIND_EXITED:
	target_terminal_ours ();	/* Must do this before mourn anyway */
	annotate_exited (ecs->ws.value.integer);
	if (ecs->ws.value.integer)
	  printf_filtered ("\nProgram exited with code 0%o.\n",
			   (unsigned int) ecs->ws.value.integer);
	else
	  printf_filtered ("\nProgram exited normally.\n");

	/* Record the exit code in the convenience variable $_exitcode, so
	   that the user can inspect this again later.  */
	set_internalvar (lookup_internalvar ("_exitcode"),
			 value_from_longest (builtin_type_int,
					  (LONGEST) ecs->ws.value.integer));
	gdb_flush (gdb_stdout);
	target_mourn_inferior ();
	singlestep_breakpoints_inserted_p = 0;	/*SOFTWARE_SINGLE_STEP_P */
	stop_print_frame = 0;
	goto stop_stepping;

      case TARGET_WAITKIND_SIGNALLED:
	stop_print_frame = 0;
	stop_signal = ecs->ws.value.sig;
	target_terminal_ours ();	/* Must do this before mourn anyway */
	annotate_signalled ();

	/* This looks pretty bogus to me.  Doesn't TARGET_WAITKIND_SIGNALLED
	   mean it is already dead?  This has been here since GDB 2.8, so
	   perhaps it means rms didn't understand unix waitstatuses?
	   For the moment I'm just kludging around this in remote.c
	   rather than trying to change it here --kingdon, 5 Dec 1994.  */
	target_kill ();		/* kill mourns as well */

	printf_filtered ("\nProgram terminated with signal ");
	annotate_signal_name ();
	printf_filtered ("%s", target_signal_to_name (stop_signal));
	annotate_signal_name_end ();
	printf_filtered (", ");
	annotate_signal_string ();
	printf_filtered ("%s", target_signal_to_string (stop_signal));
	annotate_signal_string_end ();
	printf_filtered (".\n");

	printf_filtered ("The program no longer exists.\n");
	gdb_flush (gdb_stdout);
	singlestep_breakpoints_inserted_p = 0;	/*SOFTWARE_SINGLE_STEP_P */
	goto stop_stepping;

	/* The following are the only cases in which we keep going;
	   the above cases end in a continue or goto. */
      case TARGET_WAITKIND_FORKED:
	stop_signal = TARGET_SIGNAL_TRAP;
	pending_follow.kind = ecs->ws.kind;

	/* Ignore fork events reported for the parent; we're only
	   interested in reacting to forks of the child.  Note that
	   we expect the child's fork event to be available if we
	   waited for it now. */
	if (inferior_pid == ecs->pid)
	  {
	    pending_follow.fork_event.saw_parent_fork = 1;
	    pending_follow.fork_event.parent_pid = ecs->pid;
	    pending_follow.fork_event.child_pid = ecs->ws.value.related_pid;
	    goto wfi_continue;
	  }
	else
	  {
	    pending_follow.fork_event.saw_child_fork = 1;
	    pending_follow.fork_event.child_pid = ecs->pid;
	    pending_follow.fork_event.parent_pid = ecs->ws.value.related_pid;
	  }
d1502 37
a1538 37
	stop_pc = read_pc_pid (ecs->pid);
	ecs->saved_inferior_pid = inferior_pid;
	inferior_pid = ecs->pid;
	stop_bpstat = bpstat_stop_status
	  (&stop_pc,
	   (DECR_PC_AFTER_BREAK ?
	    (prev_pc != stop_pc - DECR_PC_AFTER_BREAK
	     && currently_stepping (ecs))
	    : 0)
	  );
	ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
	inferior_pid = ecs->saved_inferior_pid;
	goto process_event_stop_test;

	/* If this a platform which doesn't allow a debugger to touch a
	   vfork'd inferior until after it exec's, then we'd best keep
	   our fingers entirely off the inferior, other than continuing
	   it.  This has the unfortunate side-effect that catchpoints
	   of vforks will be ignored.  But since the platform doesn't
	   allow the inferior be touched at vfork time, there's really
	   little choice. */
      case TARGET_WAITKIND_VFORKED:
	stop_signal = TARGET_SIGNAL_TRAP;
	pending_follow.kind = ecs->ws.kind;

	/* Is this a vfork of the parent?  If so, then give any
	   vfork catchpoints a chance to trigger now.  (It's
	   dangerous to do so if the child canot be touched until
	   it execs, and the child has not yet exec'd.  We probably
	   should warn the user to that effect when the catchpoint
	   triggers...) */
	if (ecs->pid == inferior_pid)
	  {
	    pending_follow.fork_event.saw_parent_fork = 1;
	    pending_follow.fork_event.parent_pid = ecs->pid;
	    pending_follow.fork_event.child_pid = ecs->ws.value.related_pid;
	  }
d1540 16
a1555 16
	/* If we've seen the child's vfork event but cannot really touch
	   the child until it execs, then we must continue the child now.
	   Else, give any vfork catchpoints a chance to trigger now. */
	else
	  {
	    pending_follow.fork_event.saw_child_fork = 1;
	    pending_follow.fork_event.child_pid = ecs->pid;
	    pending_follow.fork_event.parent_pid = ecs->ws.value.related_pid;
	    target_post_startup_inferior (pending_follow.fork_event.child_pid);
	    follow_vfork_when_exec = !target_can_follow_vfork_prior_to_exec ();
	    if (follow_vfork_when_exec)
	      {
		target_resume (ecs->pid, 0, TARGET_SIGNAL_0);
		goto wfi_continue;
	      }
	  }
d1557 28
a1584 28
	stop_pc = read_pc ();
	stop_bpstat = bpstat_stop_status
	  (&stop_pc,
	   (DECR_PC_AFTER_BREAK ?
	    (prev_pc != stop_pc - DECR_PC_AFTER_BREAK
	     && currently_stepping (ecs))
	    : 0)
	  );
	ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
	goto process_event_stop_test;

      case TARGET_WAITKIND_EXECD:
	stop_signal = TARGET_SIGNAL_TRAP;

	/* Is this a target which reports multiple exec events per actual
	   call to exec()?  (HP-UX using ptrace does, for example.)  If so,
	   ignore all but the last one.  Just resume the exec'r, and wait
	   for the next exec event. */
	if (inferior_ignoring_leading_exec_events)
	  {
	    inferior_ignoring_leading_exec_events--;
	    if (pending_follow.kind == TARGET_WAITKIND_VFORKED)
	      ENSURE_VFORKING_PARENT_REMAINS_STOPPED (pending_follow.fork_event.parent_pid);
	    target_resume (ecs->pid, 0, TARGET_SIGNAL_0);
	    goto wfi_continue;
	  }
	inferior_ignoring_leading_exec_events =
	  target_reported_exec_events_per_exec_call () - 1;
d1586 2
a1587 2
	pending_follow.execd_pathname = savestring (ecs->ws.value.execd_pathname,
				     strlen (ecs->ws.value.execd_pathname));
d1589 2
a1590 2
	/* Did inferior_pid exec, or did a (possibly not-yet-followed)
	   child of a vfork exec?
d1592 16
a1607 16
	   ??rehrauer: This is unabashedly an HP-UX specific thing.  On
	   HP-UX, events associated with a vforking inferior come in
	   threes: a vfork event for the child (always first), followed
	   a vfork event for the parent and an exec event for the child.
	   The latter two can come in either order.

	   If we get the parent vfork event first, life's good: We follow
	   either the parent or child, and then the child's exec event is
	   a "don't care".

	   But if we get the child's exec event first, then we delay
	   responding to it until we handle the parent's vfork.  Because,
	   otherwise we can't satisfy a "catch vfork". */
	if (pending_follow.kind == TARGET_WAITKIND_VFORKED)
	  {
	    pending_follow.fork_event.saw_child_exec = 1;
d1609 8
a1616 8
	    /* On some targets, the child must be resumed before
	       the parent vfork event is delivered.  A single-step
	       suffices. */
	    if (RESUME_EXECD_VFORKING_CHILD_TO_GET_PARENT_VFORK ())
	      target_resume (ecs->pid, 1, TARGET_SIGNAL_0);
	    /* We expect the parent vfork event to be available now. */
	    goto wfi_continue;
	  }
d1618 44
a1661 44
	/* This causes the eventpoints and symbol table to be reset.  Must
	   do this now, before trying to determine whether to stop. */
	follow_exec (inferior_pid, pending_follow.execd_pathname);
	free (pending_follow.execd_pathname);

	stop_pc = read_pc_pid (ecs->pid);
	ecs->saved_inferior_pid = inferior_pid;
	inferior_pid = ecs->pid;
	stop_bpstat = bpstat_stop_status
	  (&stop_pc,
	   (DECR_PC_AFTER_BREAK ?
	    (prev_pc != stop_pc - DECR_PC_AFTER_BREAK
	     && currently_stepping (ecs))
	    : 0)
	  );
	ecs->random_signal = !bpstat_explains_signal (stop_bpstat);
	inferior_pid = ecs->saved_inferior_pid;
	goto process_event_stop_test;

	/* These syscall events are returned on HP-UX, as part of its
	   implementation of page-protection-based "hardware" watchpoints.
	   HP-UX has unfortunate interactions between page-protections and
	   some system calls.  Our solution is to disable hardware watches
	   when a system call is entered, and reenable them when the syscall
	   completes.  The downside of this is that we may miss the precise
	   point at which a watched piece of memory is modified.  "Oh well."

	   Note that we may have multiple threads running, which may each
	   enter syscalls at roughly the same time.  Since we don't have a
	   good notion currently of whether a watched piece of memory is
	   thread-private, we'd best not have any page-protections active
	   when any thread is in a syscall.  Thus, we only want to reenable
	   hardware watches when no threads are in a syscall.

	   Also, be careful not to try to gather much state about a thread
	   that's in a syscall.  It's frequently a losing proposition. */
      case TARGET_WAITKIND_SYSCALL_ENTRY:
	number_of_threads_in_syscalls++;
	if (number_of_threads_in_syscalls == 1)
	  {
	    TARGET_DISABLE_HW_WATCHPOINTS (inferior_pid);
	  }
	resume (0, TARGET_SIGNAL_0);
	goto wfi_continue;
d1663 1
a1663 1
	/* Before examining the threads further, step this thread to
d1677 2
a1678 2
      case TARGET_WAITKIND_SYSCALL_RETURN:
	target_resume (ecs->pid, 1, TARGET_SIGNAL_0);
d1680 7
a1686 7
	if (number_of_threads_in_syscalls > 0)
	  {
	    number_of_threads_in_syscalls--;
	    ecs->enable_hw_watchpoints_after_wait =
	      (number_of_threads_in_syscalls == 0);
	  }
	goto wfi_continue;
d1688 4
a1691 4
      case TARGET_WAITKIND_STOPPED:
	stop_signal = ecs->ws.value.sig;
	break;
      }
d1693 12
a1704 12
    /* We may want to consider not doing a resume here in order to give
       the user a chance to play with the new thread.  It might be good
       to make that a user-settable option.  */

    /* At this point, all threads are stopped (happens automatically in
       either the OS or the native code).  Therefore we need to continue
       all threads in order to make progress.  */
    if (ecs->new_thread_event)
      {
	target_resume (-1, 0, TARGET_SIGNAL_0);
	goto wfi_continue;
      }
d1706 1
a1706 1
    stop_pc = read_pc_pid (ecs->pid);
d1708 3
a1710 3
    /* See if a thread hit a thread-specific breakpoint that was meant for
       another thread.  If so, then step that thread past the breakpoint,
       and continue it.  */
d1712 3
a1714 7
    if (stop_signal == TARGET_SIGNAL_TRAP)
      {
	if (SOFTWARE_SINGLE_STEP_P && singlestep_breakpoints_inserted_p)
	  ecs->random_signal = 0;
	else if (breakpoints_inserted
		 && breakpoint_here_p (stop_pc - DECR_PC_AFTER_BREAK))
	  {
d1716 36
a1751 4
	    if (!breakpoint_thread_match (stop_pc - DECR_PC_AFTER_BREAK,
					  ecs->pid))
	      {
		int remove_status;
d1753 8
a1760 25
		/* Saw a breakpoint, but it was hit by the wrong thread.
		   Just continue. */
		write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK, ecs->pid);

		remove_status = remove_breakpoints ();
		/* Did we fail to remove breakpoints?  If so, try
		   to set the PC past the bp.  (There's at least
		   one situation in which we can fail to remove
		   the bp's: On HP-UX's that use ttrace, we can't
		   change the address space of a vforking child
		   process until the child exits (well, okay, not
		   then either :-) or execs. */
		if (remove_status != 0)
		  {
		    write_pc_pid (stop_pc - DECR_PC_AFTER_BREAK + 4, ecs->pid);
		  }
		else
		  {		/* Single step */
		    target_resume (ecs->pid, 1, TARGET_SIGNAL_0);
		    /* FIXME: What if a signal arrives instead of the
		       single-step happening?  */

		    ecs->waiton_pid = ecs->pid;
		    ecs->wp = &(ecs->ws);
		    ecs->infwait_state = infwait_thread_hop_state;
d1762 13
a1774 1
		  }
d1776 17
a1792 40
		/* We need to restart all the threads now,
		 * unles we're running in scheduler-locked mode. 
		 * FIXME: shouldn't we look at currently_stepping ()?
		 */
		if (scheduler_mode == schedlock_on)
		  target_resume (ecs->pid, 0, TARGET_SIGNAL_0);
		else
		  target_resume (-1, 0, TARGET_SIGNAL_0);
		goto wfi_continue;
	      }
	    else
	      {
		/* This breakpoint matches--either it is the right
		   thread or it's a generic breakpoint for all threads.
		   Remember that we'll need to step just _this_ thread
		   on any following user continuation! */
		thread_step_needed = 1;
	      }
	  }
      }
    else
      ecs->random_signal = 1;

    /* See if something interesting happened to the non-current thread.  If
       so, then switch to that thread, and eventually give control back to
       the user.

       Note that if there's any kind of pending follow (i.e., of a fork,
       vfork or exec), we don't want to do this now.  Rather, we'll let
       the next resume handle it. */
    if ((ecs->pid != inferior_pid) &&
	(pending_follow.kind == TARGET_WAITKIND_SPURIOUS))
      {
	int printed = 0;

	/* If it's a random signal for a non-current thread, notify user
	   if he's expressed an interest. */
	if (ecs->random_signal
	    && signal_print[stop_signal])
	  {
d1804 6
a1809 6
	    printed = 1;
	    target_terminal_ours_for_output ();
	    printf_filtered ("\nProgram received signal %s, %s.\n",
			     target_signal_to_name (stop_signal),
			     target_signal_to_string (stop_signal));
	    gdb_flush (gdb_stdout);
d1811 1
a1811 1
	  }
d1813 2
a1814 2
	/* If it's not SIGTRAP and not a signal we want to stop for, then
	   continue the thread. */
d1816 5
a1820 5
	if (stop_signal != TARGET_SIGNAL_TRAP
	    && !signal_stop[stop_signal])
	  {
	    if (printed)
	      target_terminal_inferior ();
d1822 3
a1824 3
	    /* Clear the signal if it should not be passed.  */
	    if (signal_program[stop_signal] == 0)
	      stop_signal = TARGET_SIGNAL_0;
d1826 3
a1828 3
	    target_resume (ecs->pid, 0, stop_signal);
	    goto wfi_continue;
	  }
d1830 2
a1831 2
	/* It's a SIGTRAP or a signal we're interested in.  Switch threads,
	   and fall into the rest of wait_for_inferior().  */
d1833 93
a1925 28
	/* Save infrun state for the old thread.  */
	save_infrun_state (inferior_pid, prev_pc,
			   prev_func_start, prev_func_name,
			   trap_expected, step_resume_breakpoint,
			   through_sigtramp_breakpoint,
			   step_range_start, step_range_end,
			   step_frame_address, ecs->handling_longjmp,
			   ecs->another_trap,
			   ecs->stepping_through_solib_after_catch,
			   ecs->stepping_through_solib_catchpoints,
			   ecs->stepping_through_sigtramp);

	if (may_switch_from_inferior_pid)
	  switched_from_inferior_pid = inferior_pid;

	inferior_pid = ecs->pid;

	/* Load infrun state for the new thread.  */
	load_infrun_state (inferior_pid, &prev_pc,
			   &prev_func_start, &prev_func_name,
			   &trap_expected, &step_resume_breakpoint,
			   &through_sigtramp_breakpoint,
			   &step_range_start, &step_range_end,
			   &step_frame_address, &ecs->handling_longjmp,
			   &ecs->another_trap,
			   &ecs->stepping_through_solib_after_catch,
			   &ecs->stepping_through_solib_catchpoints,
			   &ecs->stepping_through_sigtramp);
d1927 1
a1927 2
	if (context_hook)
	  context_hook (pid_to_thread_id (ecs->pid));
d1929 3
a1931 3
	printf_filtered ("[Switching to %s]\n", target_pid_to_str (ecs->pid));
	flush_cached_frames ();
      }
d1933 55
a1987 116
    if (SOFTWARE_SINGLE_STEP_P && singlestep_breakpoints_inserted_p)
      {
	/* Pull the single step breakpoints out of the target. */
	SOFTWARE_SINGLE_STEP (0, 0);
	singlestep_breakpoints_inserted_p = 0;
      }

    /* If PC is pointing at a nullified instruction, then step beyond
       it so that the user won't be confused when GDB appears to be ready
       to execute it. */

    /*      if (INSTRUCTION_NULLIFIED && currently_stepping (ecs)) */
    if (INSTRUCTION_NULLIFIED)
      {
	registers_changed ();
	target_resume (ecs->pid, 1, TARGET_SIGNAL_0);

	/* We may have received a signal that we want to pass to
	   the inferior; therefore, we must not clobber the waitstatus
	   in WS. */

	ecs->infwait_state = infwait_nullified_state;
	ecs->waiton_pid = ecs->pid;
	ecs->wp = &(ecs->tmpstatus);
	goto wfi_continue;
      }

    /* It may not be necessary to disable the watchpoint to stop over
       it.  For example, the PA can (with some kernel cooperation)
       single step over a watchpoint without disabling the watchpoint.  */
    if (HAVE_STEPPABLE_WATCHPOINT && STOPPED_BY_WATCHPOINT (ecs->ws))
      {
	resume (1, 0);
	goto wfi_continue;
      }

    /* It is far more common to need to disable a watchpoint to step
       the inferior over it.  FIXME.  What else might a debug
       register or page protection watchpoint scheme need here?  */
    if (HAVE_NONSTEPPABLE_WATCHPOINT && STOPPED_BY_WATCHPOINT (ecs->ws))
      {
	/* At this point, we are stopped at an instruction which has
	   attempted to write to a piece of memory under control of
	   a watchpoint.  The instruction hasn't actually executed
	   yet.  If we were to evaluate the watchpoint expression
	   now, we would get the old value, and therefore no change
	   would seem to have occurred.

	   In order to make watchpoints work `right', we really need
	   to complete the memory write, and then evaluate the
	   watchpoint expression.  The following code does that by
	   removing the watchpoint (actually, all watchpoints and
	   breakpoints), single-stepping the target, re-inserting
	   watchpoints, and then falling through to let normal
	   single-step processing handle proceed.  Since this
	   includes evaluating watchpoints, things will come to a
	   stop in the correct manner.  */

	write_pc (stop_pc - DECR_PC_AFTER_BREAK);

	remove_breakpoints ();
	registers_changed ();
	target_resume (ecs->pid, 1, TARGET_SIGNAL_0);	/* Single step */

	ecs->waiton_pid = ecs->pid;
	ecs->wp = &(ecs->ws);
	ecs->infwait_state = infwait_nonstep_watch_state;
	goto wfi_continue;
      }

    /* It may be possible to simply continue after a watchpoint.  */
    if (HAVE_CONTINUABLE_WATCHPOINT)
      STOPPED_BY_WATCHPOINT (ecs->ws);

    ecs->stop_func_start = 0;
    ecs->stop_func_end = 0;
    ecs->stop_func_name = 0;
    /* Don't care about return value; stop_func_start and stop_func_name
       will both be 0 if it doesn't work.  */
    find_pc_partial_function (stop_pc, &ecs->stop_func_name,
			      &ecs->stop_func_start, &ecs->stop_func_end);
    ecs->stop_func_start += FUNCTION_START_OFFSET;
    ecs->another_trap = 0;
    bpstat_clear (&stop_bpstat);
    stop_step = 0;
    stop_stack_dummy = 0;
    stop_print_frame = 1;
    ecs->random_signal = 0;
    stopped_by_random_signal = 0;
    breakpoints_failed = 0;

    /* Look at the cause of the stop, and decide what to do.
       The alternatives are:
       1) break; to really stop and return to the debugger,
       2) drop through to start up again
       (set ecs->another_trap to 1 to single step once)
       3) set ecs->random_signal to 1, and the decision between 1 and 2
       will be made according to the signal handling tables.  */

    /* First, distinguish signals caused by the debugger from signals
       that have to do with the program's own actions.
       Note that breakpoint insns may cause SIGTRAP or SIGILL
       or SIGEMT, depending on the operating system version.
       Here we detect when a SIGILL or SIGEMT is really a breakpoint
       and change it to SIGTRAP.  */

    if (stop_signal == TARGET_SIGNAL_TRAP
	|| (breakpoints_inserted &&
	    (stop_signal == TARGET_SIGNAL_ILL
	     || stop_signal == TARGET_SIGNAL_EMT
	    ))
	|| stop_soon_quietly)
      {
	if (stop_signal == TARGET_SIGNAL_TRAP && stop_after_trap)
	  {
	    stop_print_frame = 0;
a1988 3
	  }
	if (stop_soon_quietly)
	  goto wfi_break;
d1990 2
a1991 2
	/* Don't even think about breakpoints
	   if just proceeded over a breakpoint.
d1993 33
a2025 42
	   However, if we are trying to proceed over a breakpoint
	   and end up in sigtramp, then through_sigtramp_breakpoint
	   will be set and we should check whether we've hit the
	   step breakpoint.  */
	if (stop_signal == TARGET_SIGNAL_TRAP && trap_expected
	    && through_sigtramp_breakpoint == NULL)
	  bpstat_clear (&stop_bpstat);
	else
	  {
	    /* See if there is a breakpoint at the current PC.  */
	    stop_bpstat = bpstat_stop_status
	      (&stop_pc,
	       (DECR_PC_AFTER_BREAK ?
	    /* Notice the case of stepping through a jump
	       that lands just after a breakpoint.
	       Don't confuse that with hitting the breakpoint.
	       What we check for is that 1) stepping is going on
	       and 2) the pc before the last insn does not match
	       the address of the breakpoint before the current pc
	       and 3) we didn't hit a breakpoint in a signal handler
	       without an intervening stop in sigtramp, which is
	       detected by a new stack pointer value below
	       any usual function calling stack adjustments.  */
		(currently_stepping (ecs)
		 && prev_pc != stop_pc - DECR_PC_AFTER_BREAK
		 && !(step_range_end
		      && INNER_THAN (read_sp (), (step_sp - 16)))) :
		0)
	      );
	    /* Following in case break condition called a
	       function.  */
	    stop_print_frame = 1;
	  }

	if (stop_signal == TARGET_SIGNAL_TRAP)
	  ecs->random_signal
	    = !(bpstat_explains_signal (stop_bpstat)
		|| trap_expected
		|| (!CALL_DUMMY_BREAKPOINT_OFFSET_P
		    && PC_IN_CALL_DUMMY (stop_pc, read_sp (),
					 FRAME_FP (get_current_frame ())))
		|| (step_range_end && step_resume_breakpoint == NULL));
d2027 1
a2027 2
	else
	  {
d2030 1
a2030 3
	    /* End of a stack dummy.  Some systems (e.g. Sony
	       news) give another signal besides SIGTRAP, so
	       check here as well as above.  */
d2034 1
a2034 5
	      );
	    if (!ecs->random_signal)
	      stop_signal = TARGET_SIGNAL_TRAP;
	  }
      }
d2036 15
a2050 50
    /* When we reach this point, we've pretty much decided
       that the reason for stopping must've been a random
       (unexpected) signal. */

    else
      ecs->random_signal = 1;
    /* If a fork, vfork or exec event was seen, then there are two
       possible responses we can make:

       1. If a catchpoint triggers for the event (ecs->random_signal == 0),
       then we must stop now and issue a prompt.  We will resume
       the inferior when the user tells us to.
       2. If no catchpoint triggers for the event (ecs->random_signal == 1),
       then we must resume the inferior now and keep checking.

       In either case, we must take appropriate steps to "follow" the
       the fork/vfork/exec when the inferior is resumed.  For example,
       if follow-fork-mode is "child", then we must detach from the
       parent inferior and follow the new child inferior.

       In either case, setting pending_follow causes the next resume()
       to take the appropriate following action. */
  process_event_stop_test:
    if (ecs->ws.kind == TARGET_WAITKIND_FORKED)
      {
	if (ecs->random_signal)	/* I.e., no catchpoint triggered for this. */
	  {
	    trap_expected = 1;
	    stop_signal = TARGET_SIGNAL_0;
	    goto keep_going;
	  }
      }
    else if (ecs->ws.kind == TARGET_WAITKIND_VFORKED)
      {
	if (ecs->random_signal)	/* I.e., no catchpoint triggered for this. */
	  {
	    stop_signal = TARGET_SIGNAL_0;
	    goto keep_going;
	  }
      }
    else if (ecs->ws.kind == TARGET_WAITKIND_EXECD)
      {
	pending_follow.kind = ecs->ws.kind;
	if (ecs->random_signal)	/* I.e., no catchpoint triggered for this. */
	  {
	    trap_expected = 1;
	    stop_signal = TARGET_SIGNAL_0;
	    goto keep_going;
	  }
      }
d2052 3
a2054 2
    /* For the program's own signals, act according to
       the signal handling tables.  */
d2056 20
a2075 54
    if (ecs->random_signal)
      {
	/* Signal not for debugging purposes.  */
	int printed = 0;

	stopped_by_random_signal = 1;

	if (signal_print[stop_signal])
	  {
	    printed = 1;
	    target_terminal_ours_for_output ();
	    annotate_signal ();
	    printf_filtered ("\nProgram received signal ");
	    annotate_signal_name ();
	    printf_filtered ("%s", target_signal_to_name (stop_signal));
	    annotate_signal_name_end ();
	    printf_filtered (", ");
	    annotate_signal_string ();
	    printf_filtered ("%s", target_signal_to_string (stop_signal));
	    annotate_signal_string_end ();
	    printf_filtered (".\n");
	    gdb_flush (gdb_stdout);
	  }
	if (signal_stop[stop_signal])
	  goto wfi_break;
	/* If not going to stop, give terminal back
	   if we took it away.  */
	else if (printed)
	  target_terminal_inferior ();

	/* Clear the signal if it should not be passed.  */
	if (signal_program[stop_signal] == 0)
	  stop_signal = TARGET_SIGNAL_0;

	/* If we're in the middle of a "next" command, let the code for
	   stepping over a function handle this. pai/1997-09-10

	   A previous comment here suggested it was possible to change
	   this to jump to keep_going in all cases. */

	if (step_over_calls > 0)
	  goto step_over_function;
	else
	  goto check_sigtramp2;
      }

    /* Handle cases caused by hitting a breakpoint.  */
    {
      CORE_ADDR jmp_buf_pc;
      struct bpstat_what what;

      what = bpstat_what (stop_bpstat);

      if (what.call_dummy)
d2077 6
a2082 4
	  stop_stack_dummy = 1;
#ifdef HP_OS_BUG
	  trap_expected_after_continue = 1;
#endif
d2084 1
a2084 2

      switch (what.main_action)
d2086 1
a2086 20
	case BPSTAT_WHAT_SET_LONGJMP_RESUME:
	  /* If we hit the breakpoint at longjmp, disable it for the
	     duration of this command.  Then, install a temporary
	     breakpoint at the target of the jmp_buf. */
	  disable_longjmp_breakpoint ();
	  remove_breakpoints ();
	  breakpoints_inserted = 0;
	  if (!GET_LONGJMP_TARGET (&jmp_buf_pc))
	    goto keep_going;

	  /* Need to blow away step-resume breakpoint, as it
	     interferes with us */
	  if (step_resume_breakpoint != NULL)
	    {
	      delete_breakpoint (step_resume_breakpoint);
	      step_resume_breakpoint = NULL;
	    }
	  /* Not sure whether we need to blow this away too, but probably
	     it is like the step-resume breakpoint.  */
	  if (through_sigtramp_breakpoint != NULL)
d2088 2
a2089 2
	      delete_breakpoint (through_sigtramp_breakpoint);
	      through_sigtramp_breakpoint = NULL;
d2091 5
a2095 21

#if 0
	  /* FIXME - Need to implement nested temporary breakpoints */
	  if (step_over_calls > 0)
	    set_longjmp_resume_breakpoint (jmp_buf_pc,
					   get_current_frame ());
	  else
#endif /* 0 */
	    set_longjmp_resume_breakpoint (jmp_buf_pc, NULL);
	  ecs->handling_longjmp = 1;	/* FIXME */
	  goto keep_going;

	case BPSTAT_WHAT_CLEAR_LONGJMP_RESUME:
	case BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE:
	  remove_breakpoints ();
	  breakpoints_inserted = 0;
#if 0
	  /* FIXME - Need to implement nested temporary breakpoints */
	  if (step_over_calls
	      && (INNER_THAN (FRAME_FP (get_current_frame ()),
			      step_frame_address)))
d2097 2
a2098 1
	      ecs->another_trap = 1;
d2101 11
a2111 6
#endif /* 0 */
	  disable_longjmp_breakpoint ();
	  ecs->handling_longjmp = 0;	/* FIXME */
	  if (what.main_action == BPSTAT_WHAT_CLEAR_LONGJMP_RESUME)
	    break;
	  /* else fallthrough */
d2113 1
a2113 2
	case BPSTAT_WHAT_SINGLE:
	  if (breakpoints_inserted)
d2115 13
a2127 2
	      thread_step_needed = 1;
	      remove_breakpoints ();
d2129 6
a2134 5
	  breakpoints_inserted = 0;
	  ecs->another_trap = 1;
	  /* Still need to check other stuff, at least the case
	     where we are stepping and step out of the right range.  */
	  break;
d2136 3
a2138 2
	case BPSTAT_WHAT_STOP_NOISY:
	  stop_print_frame = 1;
d2140 2
a2141 3
	  /* We are about to nuke the step_resume_breakpoint and
	     through_sigtramp_breakpoint via the cleanup chain, so
	     no need to worry about it here.  */
d2143 2
a2144 1
	  goto stop_stepping;
d2146 5
a2150 2
	case BPSTAT_WHAT_STOP_SILENT:
	  stop_print_frame = 0;
d2152 4
a2155 3
	  /* We are about to nuke the step_resume_breakpoint and
	     through_sigtramp_breakpoint via the cleanup chain, so
	     no need to worry about it here.  */
d2157 1
a2157 1
	  goto stop_stepping;
d2159 7
a2165 21
	case BPSTAT_WHAT_STEP_RESUME:
	  /* This proably demands a more elegant solution, but, yeah
	     right...

	     This function's use of the simple variable
	     step_resume_breakpoint doesn't seem to accomodate
	     simultaneously active step-resume bp's, although the
	     breakpoint list certainly can.

	     If we reach here and step_resume_breakpoint is already
	     NULL, then apparently we have multiple active
	     step-resume bp's.  We'll just delete the breakpoint we
	     stopped at, and carry on.  */
	  if (step_resume_breakpoint == NULL)
	    {
	      step_resume_breakpoint =
		bpstat_find_step_resume_breakpoint (stop_bpstat);
	    }
	  delete_breakpoint (step_resume_breakpoint);
	  step_resume_breakpoint = NULL;
	  break;
d2167 1
a2167 14
	case BPSTAT_WHAT_THROUGH_SIGTRAMP:
	  if (through_sigtramp_breakpoint)
	    delete_breakpoint (through_sigtramp_breakpoint);
	  through_sigtramp_breakpoint = NULL;

	  /* If were waiting for a trap, hitting the step_resume_break
	     doesn't count as getting it.  */
	  if (trap_expected)
	    ecs->another_trap = 1;
	  break;

	case BPSTAT_WHAT_CHECK_SHLIBS:
	case BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK:
#ifdef SOLIB_ADD
d2169 6
a2174 5
	    /* Remove breakpoints, we eventually want to step over the
	       shlib event breakpoint, and SOLIB_ADD might adjust
	       breakpoint addresses via breakpoint_re_set.  */
	    if (breakpoints_inserted)
	      remove_breakpoints ();
d2176 2
d2179 3
a2181 3
	    /* Check for any newly added shared libraries if we're
	       supposed to be adding them automatically.  */
	    if (auto_solib_add)
d2183 2
a2184 5
		/* Switch terminal for any messages produced by
		   breakpoint_re_set.  */
		target_terminal_ours_for_output ();
		SOLIB_ADD (NULL, 0, NULL);
		target_terminal_inferior ();
d2186 3
a2188 10

	    /* Try to reenable shared library breakpoints, additional
	       code segments in shared libraries might be mapped in now. */
	    re_enable_breakpoints_in_shlibs ();

	    /* If requested, stop when the dynamic linker notifies
	       gdb of events.  This allows the user to get control
	       and place breakpoints in initializer routines for
	       dynamically loaded objects (among other things).  */
	    if (stop_on_solib_events)
d2190 2
a2191 2
		stop_print_frame = 0;
		goto stop_stepping;
d2194 20
a2213 11
	    /* If we stopped due to an explicit catchpoint, then the
	       (see above) call to SOLIB_ADD pulled in any symbols
	       from a newly-loaded library, if appropriate.

	       We do want the inferior to stop, but not where it is
	       now, which is in the dynamic linker callback.  Rather,
	       we would like it stop in the user's program, just after
	       the call that caused this catchpoint to trigger.  That
	       gives the user a more useful vantage from which to
	       examine their program's state. */
	    else if (what.main_action == BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK)
a2214 18
		/* ??rehrauer: If I could figure out how to get the
		   right return PC from here, we could just set a temp
		   breakpoint and resume.  I'm not sure we can without
		   cracking open the dld's shared libraries and sniffing
		   their unwind tables and text/data ranges, and that's
		   not a terribly portable notion.

		   Until that time, we must step the inferior out of the
		   dld callback, and also out of the dld itself (and any
		   code or stubs in libdld.sl, such as "shl_load" and
		   friends) until we reach non-dld code.  At that point,
		   we can stop stepping. */
		bpstat_get_triggered_catchpoints (stop_bpstat,
				  &ecs->stepping_through_solib_catchpoints);
		ecs->stepping_through_solib_after_catch = 1;

		/* Be sure to lift all breakpoints, so the inferior does
		   actually step past this point... */
d2216 1
a2216 1
		break;
d2218 9
a2226 1
	    else
d2228 2
a2229 3
		/* We want to step over this breakpoint, then keep going.  */
		ecs->another_trap = 1;
		break;
d2231 5
a2235 3
	  }
#endif
	  break;
d2237 2
a2238 2
	case BPSTAT_WHAT_LAST:
	  /* Not a real code, but listed here to shut up gcc -Wall.  */
d2240 3
a2242 4
	case BPSTAT_WHAT_KEEP_CHECKING:
	  break;
	}
    }
d2244 1
a2244 28
    /* We come here if we hit a breakpoint but should not
       stop for it.  Possibly we also were stepping
       and should stop for that.  So fall through and
       test for stepping.  But, if not stepping,
       do not stop.  */

    /* Are we stepping to get the inferior out of the dynamic
       linker's hook (and possibly the dld itself) after catching
       a shlib event? */
    if (ecs->stepping_through_solib_after_catch)
      {
#if defined(SOLIB_ADD)
	/* Have we reached our destination?  If not, keep going. */
	if (SOLIB_IN_DYNAMIC_LINKER (ecs->pid, stop_pc))
	  {
	    ecs->another_trap = 1;
	    goto keep_going;
	  }
#endif
	/* Else, stop and report the catchpoint(s) whose triggering
	   caused us to begin stepping. */
	ecs->stepping_through_solib_after_catch = 0;
	bpstat_clear (&stop_bpstat);
	stop_bpstat = bpstat_copy (ecs->stepping_through_solib_catchpoints);
	bpstat_clear (&ecs->stepping_through_solib_catchpoints);
	stop_print_frame = 1;
	goto stop_stepping;
      }
d2246 1
a2246 15
    if (!CALL_DUMMY_BREAKPOINT_OFFSET_P)
      {
	/* This is the old way of detecting the end of the stack dummy.
	   An architecture which defines CALL_DUMMY_BREAKPOINT_OFFSET gets
	   handled above.  As soon as we can test it on all of them, all
	   architectures should define it.  */

	/* If this is the breakpoint at the end of a stack dummy,
	   just stop silently, unless the user was doing an si/ni, in which
	   case she'd better know what she's doing.  */

	if (CALL_DUMMY_HAS_COMPLETED (stop_pc, read_sp (),
				      FRAME_FP (get_current_frame ()))
	    && !step_range_end)
	  {
a2247 7
	    stop_stack_dummy = 1;
#ifdef HP_OS_BUG
	    trap_expected_after_continue = 1;
#endif
	    goto wfi_break;
	  }
      }
d2249 27
a2275 26
    if (step_resume_breakpoint)
      /* Having a step-resume breakpoint overrides anything
         else having to do with stepping commands until
         that breakpoint is reached.  */
      /* I'm not sure whether this needs to be check_sigtramp2 or
         whether it could/should be keep_going.  */
      goto check_sigtramp2;

    if (step_range_end == 0)
      /* Likewise if we aren't even stepping.  */
      /* I'm not sure whether this needs to be check_sigtramp2 or
         whether it could/should be keep_going.  */
      goto check_sigtramp2;

    /* If stepping through a line, keep going if still within it.

       Note that step_range_end is the address of the first instruction
       beyond the step range, and NOT the address of the last instruction
       within it! */
    if (stop_pc >= step_range_start
	&& stop_pc < step_range_end)
      {
	/* We might be doing a BPSTAT_WHAT_SINGLE and getting a signal.
	   So definately need to check for sigtramp here.  */
	goto check_sigtramp2;
      }
d2277 4
a2280 1
    /* We stepped out of the stepping range.  */
d2282 5
a2286 6
    /* If we are stepping at the source level and entered the runtime
       loader dynamic symbol resolution code, we keep on single stepping
       until we exit the run time loader code and reach the callee's
       address.  */
    if (step_over_calls < 0 && IN_SOLIB_DYNSYM_RESOLVE_CODE (stop_pc))
      goto keep_going;
d2288 10
a2297 12
    /* We can't update step_sp every time through the loop, because
       reading the stack pointer would slow down stepping too much.
       But we can update it every time we leave the step range.  */
    ecs->update_step_sp = 1;

    /* Did we just take a signal?  */
    if (IN_SIGTRAMP (stop_pc, ecs->stop_func_name)
	&& !IN_SIGTRAMP (prev_pc, prev_func_name)
	&& INNER_THAN (read_sp (), step_sp))
      {
	/* We've just taken a signal; go until we are back to
	   the point where we took it and one more.  */
d2299 10
a2308 6
	/* Note: The test above succeeds not only when we stepped
	   into a signal handler, but also when we step past the last
	   statement of a signal handler and end up in the return stub
	   of the signal handler trampoline.  To distinguish between
	   these two cases, check that the frame is INNER_THAN the
	   previous one below. pai/1997-09-11 */
d2310 13
d2324 42
a2365 2
	{
	  CORE_ADDR current_frame = FRAME_FP (get_current_frame ());
d2367 2
a2368 4
	  if (INNER_THAN (current_frame, step_frame_address))
	    {
	      /* We have just taken a signal; go until we are back to
	         the point where we took it and one more.  */
d2370 4
a2373 3
	      /* This code is needed at least in the following case:
	         The user types "next" and then a signal arrives (before
	         the "next" is done).  */
d2375 28
a2402 5
	      /* Note that if we are stopped at a breakpoint, then we need
	         the step_resume breakpoint to override any breakpoints at
	         the same location, so that we will still step over the
	         breakpoint even though the signal happened.  */
	      struct symtab_and_line sr_sal;
d2404 14
a2417 13
	      INIT_SAL (&sr_sal);
	      sr_sal.symtab = NULL;
	      sr_sal.line = 0;
	      sr_sal.pc = prev_pc;
	      /* We could probably be setting the frame to
	         step_frame_address; I don't think anyone thought to
	         try it.  */
	      step_resume_breakpoint =
		set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
	      if (breakpoints_inserted)
		insert_breakpoints ();
	    }
	  else
d2419 6
a2424 19
	      /* We just stepped out of a signal handler and into
	         its calling trampoline.

	         Normally, we'd jump to step_over_function from
	         here, but for some reason GDB can't unwind the
	         stack correctly to find the real PC for the point
	         user code where the signal trampoline will return
	         -- FRAME_SAVED_PC fails, at least on HP-UX 10.20.
	         But signal trampolines are pretty small stubs of
	         code, anyway, so it's OK instead to just
	         single-step out.  Note: assuming such trampolines
	         don't exhibit recursion on any platform... */
	      find_pc_partial_function (stop_pc, &ecs->stop_func_name,
					&ecs->stop_func_start,
					&ecs->stop_func_end);
	      /* Readjust stepping range */
	      step_range_start = ecs->stop_func_start;
	      step_range_end = ecs->stop_func_end;
	      ecs->stepping_through_sigtramp = 1;
d2427 27
d2455 1
d2457 19
a2475 7
	/* If this is stepi or nexti, make sure that the stepping range
	   gets us past that instruction.  */
	if (step_range_end == 1)
	  /* FIXME: Does this run afoul of the code below which, if
	     we step into the middle of a line, resets the stepping
	     range?  */
	  step_range_end = (step_range_start = prev_pc) + 1;
d2477 6
a2482 3
	ecs->remove_breakpoints_on_following_step = 1;
	goto keep_going;
      }
a2483 7
    if (stop_pc == ecs->stop_func_start		/* Quick test */
	|| (in_prologue (stop_pc, ecs->stop_func_start) &&
	    !IN_SOLIB_RETURN_TRAMPOLINE (stop_pc, ecs->stop_func_name))
	|| IN_SOLIB_CALL_TRAMPOLINE (stop_pc, ecs->stop_func_name)
	|| ecs->stop_func_name == 0)
      {
	/* It's a subroutine call.  */
a2484 1
	if (step_over_calls == 0)
d2486 1
a2486 6
	    /* I presume that step_over_calls is only 0 when we're
	       supposed to be stepping at the assembly language level
	       ("stepi").  Just stop.  */
	    stop_step = 1;
	    goto wfi_break;
	  }
d2488 1
a2488 16
	if (step_over_calls > 0 || IGNORE_HELPER_CALL (stop_pc))
	  /* We're doing a "next".  */
	  goto step_over_function;

	/* If we are in a function call trampoline (a stub between
	   the calling routine and the real function), locate the real
	   function.  That's what tells us (a) whether we want to step
	   into it at all, and (b) what prologue we want to run to
	   the end of, if we do step into it.  */
	tmp = SKIP_TRAMPOLINE_CODE (stop_pc);
	if (tmp != 0)
	  ecs->stop_func_start = tmp;
	else
	  {
	    tmp = DYNAMIC_TRAMPOLINE_NEXTPC (stop_pc);
	    if (tmp)
d2490 20
a2509 6
		struct symtab_and_line xxx;
		/* Why isn't this s_a_l called "sr_sal", like all of the
		   other s_a_l's where this code is duplicated?  */
		INIT_SAL (&xxx);	/* initialize to zeroes */
		xxx.pc = tmp;
		xxx.section = find_pc_overlay (xxx.pc);
d2511 25
a2535 3
		  set_momentary_breakpoint (xxx, NULL, bp_step_resume);
		insert_breakpoints ();
		goto keep_going;
a2538 2
	/* If we have line number information for the function we
	   are thinking of stepping into, step into it.
d2540 7
a2546 5
	   If there are several symtabs at that PC (e.g. with include
	   files), just want to know whether *any* of them have line
	   numbers.  find_pc_line handles this.  */
	{
	  struct symtab_and_line tmp_sal;
d2548 2
a2549 3
	  tmp_sal = find_pc_line (ecs->stop_func_start, 0);
	  if (tmp_sal.line != 0)
	    goto step_into_function;
d2552 5
a2556 2
      step_over_function:
	/* A subroutine call has happened.  */
d2558 1
a2558 2
	  /* Set a special breakpoint after the return */
	  struct symtab_and_line sr_sal;
d2560 8
a2567 35
	  INIT_SAL (&sr_sal);
	  sr_sal.symtab = NULL;
	  sr_sal.line = 0;

	  /* If we came here after encountering a signal in the middle of
	     a "next", use the stashed-away previous frame pc */
	  sr_sal.pc
	    = stopped_by_random_signal
	    ? prev_pc
	    : ADDR_BITS_REMOVE (SAVED_PC_AFTER_CALL (get_current_frame ()));

	  step_resume_breakpoint =
	    set_momentary_breakpoint (sr_sal,
				      stopped_by_random_signal ?
				      NULL : get_current_frame (),
				      bp_step_resume);

	  /* We've just entered a callee, and we wish to resume until
	     it returns to the caller.  Setting a step_resume bp on
	     the return PC will catch a return from the callee.

	     However, if the callee is recursing, we want to be
	     careful not to catch returns of those recursive calls,
	     but of THIS instance of the call.

	     To do this, we set the step_resume bp's frame to our
	     current caller's frame (step_frame_address, which is
	     set by the "next" or "until" command, before execution
	     begins).

	     But ... don't do it if we're single-stepping out of a
	     sigtramp, because the reason we're single-stepping is
	     precisely because unwinding is a problem (HP-UX 10.20,
	     e.g.) and the frame address is likely to be incorrect.
	     No danger of sigtramp recursion.  */
d2569 13
a2581 1
	  if (ecs->stepping_through_sigtramp)
d2583 14
a2596 2
	      step_resume_breakpoint->frame = (CORE_ADDR) NULL;
	      ecs->stepping_through_sigtramp = 0;
a2597 2
	  else if (!IN_SOLIB_DYNSYM_RESOLVE_CODE (sr_sal.pc))
	    step_resume_breakpoint->frame = step_frame_address;
d2599 2
a2600 4
	  if (breakpoints_inserted)
	    insert_breakpoints ();
	}
	goto keep_going;
d2602 5
a2606 24
      step_into_function:
	/* Subroutine call with source code we should not step over.
	   Do step to the first line of code in it.  */
	{
	  struct symtab *s;

	  s = find_pc_symtab (stop_pc);
	  if (s && s->language != language_asm)
	    ecs->stop_func_start = SKIP_PROLOGUE (ecs->stop_func_start);
	}
	ecs->sal = find_pc_line (ecs->stop_func_start, 0);
	/* Use the step_resume_break to step until
	   the end of the prologue, even if that involves jumps
	   (as it seems to on the vax under 4.2).  */
	/* If the prologue ends in the middle of a source line,
	   continue to the end of that source line (if it is still
	   within the function).  Otherwise, just go to end of prologue.  */
#ifdef PROLOGUE_FIRSTLINE_OVERLAP
	/* no, don't either.  It skips any code that's
	   legitimately on the first line.  */
#else
	if (ecs->sal.end && ecs->sal.pc != ecs->stop_func_start && ecs->sal.end < ecs->stop_func_end)
	  ecs->stop_func_start = ecs->sal.end;
#endif
d2608 3
a2610 5
	if (ecs->stop_func_start == stop_pc)
	  {
	    /* We are already there: stop now.  */
	    stop_step = 1;
	    goto wfi_break;
d2612 3
a2614 2
	else
	  /* Put the step-breakpoint there and go until there. */
d2616 1
d2619 11
a2629 6
	    INIT_SAL (&sr_sal);	/* initialize to zeroes */
	    sr_sal.pc = ecs->stop_func_start;
	    sr_sal.section = find_pc_overlay (ecs->stop_func_start);
	    /* Do not specify what the fp should be when we stop
	       since on some machines the prologue
	       is where the new fp value is established.  */
d2631 32
a2662 1
	      set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
d2665 27
d2693 21
a2713 5
	    /* And make sure stepping stops right away then.  */
	    step_range_end = step_range_start;
	  }
	goto keep_going;
      }
d2715 5
a2719 1
    /* We've wandered out of the step range.  */
d2721 1
a2721 1
    ecs->sal = find_pc_line (stop_pc, 0);
d2723 1
a2723 7
    if (step_range_end == 1)
      {
	/* It is stepi or nexti.  We always want to stop stepping after
	   one instruction.  */
	stop_step = 1;
	goto wfi_break;
      }
d2725 7
a2731 5
    /* If we're in the return path from a shared library trampoline,
       we want to proceed through the trampoline when stepping.  */
    if (IN_SOLIB_RETURN_TRAMPOLINE (stop_pc, ecs->stop_func_name))
      {
	CORE_ADDR tmp;
d2733 5
a2737 2
	/* Determine where this trampoline returns.  */
	tmp = SKIP_TRAMPOLINE_CODE (stop_pc);
d2739 2
a2740 5
	/* Only proceed through if we know where it's going.  */
	if (tmp)
	  {
	    /* And put the step-breakpoint there and go until there. */
	    struct symtab_and_line sr_sal;
d2742 5
a2746 10
	    INIT_SAL (&sr_sal);	/* initialize to zeroes */
	    sr_sal.pc = tmp;
	    sr_sal.section = find_pc_overlay (sr_sal.pc);
	    /* Do not specify what the fp should be when we stop
	       since on some machines the prologue
	       is where the new fp value is established.  */
	    step_resume_breakpoint =
	      set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
	    if (breakpoints_inserted)
	      insert_breakpoints ();
d2748 10
a2757 5
	    /* Restart without fiddling with the step ranges or
	       other state.  */
	    goto keep_going;
	  }
      }
d2759 5
a2763 9
    if (ecs->sal.line == 0)
      {
	/* We have no line number information.  That means to stop
	   stepping (does this always happen right after one instruction,
	   when we do "s" in a function with no line numbers,
	   or can this happen as a result of a return or longjmp?).  */
	stop_step = 1;
	goto wfi_break;
      }
d2765 9
a2773 10
    if ((stop_pc == ecs->sal.pc)
	&& (ecs->current_line != ecs->sal.line || ecs->current_symtab != ecs->sal.symtab))
      {
	/* We are at the start of a different line.  So stop.  Note that
	   we don't stop if we step into the middle of a different line.
	   That is said to make things like for (;;) statements work
	   better.  */
	stop_step = 1;
	goto wfi_break;
      }
d2775 10
a2784 1
    /* We aren't done stepping.
d2786 1
a2786 4
       Optimize by setting the stepping range to the line.
       (We might not be in the original line, but if we entered a
       new line in mid-statement, we continue stepping.  This makes
       things like for(;;) statements work better.)  */
d2788 28
a2815 9
    if (ecs->stop_func_end && ecs->sal.end >= ecs->stop_func_end)
      {
	/* If this is the last line of the function, don't keep stepping
	   (it would probably step us out of the function).
	   This is particularly necessary for a one-line function,
	   in which after skipping the prologue we better stop even though
	   we will be in mid-line.  */
	stop_step = 1;
	goto wfi_break;
a2816 5
    step_range_start = ecs->sal.pc;
    step_range_end = ecs->sal.end;
    step_frame_address = FRAME_FP (get_current_frame ());
    ecs->current_line = ecs->sal.line;
    ecs->current_symtab = ecs->sal.symtab;
a2817 8
    /* In the case where we just stepped out of a function into the middle
       of a line of the caller, continue stepping, but step_frame_address
       must be modified to current frame */
    {
      CORE_ADDR current_frame = FRAME_FP (get_current_frame ());
      if (!(INNER_THAN (current_frame, step_frame_address)))
	step_frame_address = current_frame;
    }
d2819 1
d2821 17
a2837 1
    goto keep_going;
d2839 10
a2848 28
  check_sigtramp2:
    if (trap_expected
	&& IN_SIGTRAMP (stop_pc, ecs->stop_func_name)
	&& !IN_SIGTRAMP (prev_pc, prev_func_name)
	&& INNER_THAN (read_sp (), step_sp))
      {
	/* What has happened here is that we have just stepped the inferior
	   with a signal (because it is a signal which shouldn't make
	   us stop), thus stepping into sigtramp.

	   So we need to set a step_resume_break_address breakpoint
	   and continue until we hit it, and then step.  FIXME: This should
	   be more enduring than a step_resume breakpoint; we should know
	   that we will later need to keep going rather than re-hitting
	   the breakpoint here (see testsuite/gdb.t06/signals.exp where
	   it says "exceedingly difficult").  */
	struct symtab_and_line sr_sal;

	INIT_SAL (&sr_sal);	/* initialize to zeroes */
	sr_sal.pc = prev_pc;
	sr_sal.section = find_pc_overlay (sr_sal.pc);
	/* We perhaps could set the frame if we kept track of what
	   the frame corresponding to prev_pc was.  But we don't,
	   so don't.  */
	through_sigtramp_breakpoint =
	  set_momentary_breakpoint (sr_sal, NULL, bp_through_sigtramp);
	if (breakpoints_inserted)
	  insert_breakpoints ();
d2850 3
a2852 3
	ecs->remove_breakpoints_on_following_step = 1;
	ecs->another_trap = 1;
      }
d2854 24
a2877 28
  keep_going:
    /* Come to this label when you need to resume the inferior.
       It's really much cleaner to do a goto than a maze of if-else
       conditions.  */

    /* ??rehrauer: ttrace on HP-UX theoretically allows one to debug
       a vforked child beetween its creation and subsequent exit or
       call to exec().  However, I had big problems in this rather
       creaky exec engine, getting that to work.  The fundamental
       problem is that I'm trying to debug two processes via an
       engine that only understands a single process with possibly
       multiple threads.

       Hence, this spot is known to have problems when
       target_can_follow_vfork_prior_to_exec returns 1. */

    /* Save the pc before execution, to compare with pc after stop.  */
    prev_pc = read_pc ();	/* Might have been DECR_AFTER_BREAK */
    prev_func_start = ecs->stop_func_start;	/* Ok, since if DECR_PC_AFTER
						   BREAK is defined, the
						   original pc would not have
						   been at the start of a
						   function. */
    prev_func_name = ecs->stop_func_name;

    if (ecs->update_step_sp)
      step_sp = read_sp ();
    ecs->update_step_sp = 0;
d2879 45
a2923 2
    /* If we did not do break;, it means we should keep
       running the inferior and not return to debugger.  */
d2925 1
a2925 38
    if (trap_expected && stop_signal != TARGET_SIGNAL_TRAP)
      {
	/* We took a signal (which we are supposed to pass through to
	   the inferior, else we'd have done a break above) and we
	   haven't yet gotten our trap.  Simply continue.  */
	resume (currently_stepping (ecs), stop_signal);
      }
    else
      {
	/* Either the trap was not expected, but we are continuing
	   anyway (the user asked that this signal be passed to the
	   child)
	   -- or --
	   The signal was SIGTRAP, e.g. it was our signal, but we
	   decided we should resume from it.

	   We're going to run this baby now!

	   Insert breakpoints now, unless we are trying
	   to one-proceed past a breakpoint.  */
	/* If we've just finished a special step resume and we don't
	   want to hit a breakpoint, pull em out.  */
	if (step_resume_breakpoint == NULL
	    && through_sigtramp_breakpoint == NULL
	    && ecs->remove_breakpoints_on_following_step)
	  {
	    ecs->remove_breakpoints_on_following_step = 0;
	    remove_breakpoints ();
	    breakpoints_inserted = 0;
	  }
	else if (!breakpoints_inserted &&
		 (through_sigtramp_breakpoint != NULL || !ecs->another_trap))
	  {
	    breakpoints_failed = insert_breakpoints ();
	    if (breakpoints_failed)
	      goto wfi_break;
	    breakpoints_inserted = 1;
	  }
d2927 12
a2938 1
	trap_expected = ecs->another_trap;
d2940 3
a2942 16
	/* Do not deliver SIGNAL_TRAP (except when the user
	   explicitly specifies that such a signal should be
	   delivered to the target program).

	   Typically, this would occure when a user is debugging a
	   target monitor on a simulator: the target monitor sets a
	   breakpoint; the simulator encounters this break-point and
	   halts the simulation handing control to GDB; GDB, noteing
	   that the break-point isn't valid, returns control back to
	   the simulator; the simulator then delivers the hardware
	   equivalent of a SIGNAL_TRAP to the program being
	   debugged. */

	if (stop_signal == TARGET_SIGNAL_TRAP
	    && !signal_program[stop_signal])
	  stop_signal = TARGET_SIGNAL_0;
d2945 10
a2954 10
	/* I'm not sure when this following segment applies.  I do know,
	   now, that we shouldn't rewrite the regs when we were stopped
	   by a random signal from the inferior process.  */
	/* FIXME: Shouldn't this be based on the valid bit of the SXIP?
	   (this is only used on the 88k).  */

	if (!bpstat_explains_signal (stop_bpstat)
	    && (stop_signal != TARGET_SIGNAL_CHLD)
	    && !stopped_by_random_signal)
	  SHIFT_INST_REGS ();
d2957 2
a2958 2
	resume (currently_stepping (ecs), stop_signal);
      }
d2960 23
a2982 23
    /* Former continues in the main loop goto here.  */
  wfi_continue:
    /* This used to be at the top of the loop.  */
    if (ecs->infwait_state == infwait_normal_state)
      {
	overlay_cache_invalid = 1;

	/* We have to invalidate the registers BEFORE calling
	   target_wait because they can be loaded from the target
	   while in target_wait.  This makes remote debugging a bit
	   more efficient for those targets that provide critical
	   registers as part of their normal status mechanism. */

	registers_changed ();
	ecs->waiton_pid = -1;
	ecs->wp = &(ecs->ws);
      }
    /* This is the old end of the while loop.  Let everybody know
       we want to wait for the inferior some more and get called
       again soon.  */
    ecs->wait_some_more = 1;
    return;
  }
d3014 2
a3015 2
         time, just like we did above if we didn't break out of the
         loop.  */
d3110 1
a3110 1
  extern cleanup_sigint_signal_handler PARAMS ((void));
d3227 4
a3230 4
         we have changed functions or hit a breakpoint.
         Print source line if we have one.
         bpstat_print() contains the logic deciding in detail
         what to print, based on the event(s) that just occurred. */
d3239 4
a3242 4
	     -1: Didn't print anything
	     0: Printed preliminary "Breakpoint n, " message, desires
	     location tacked on
	     1: Printed something, don't tack on location */
d3277 1
a3277 1
         can use that next. */
d3280 2
a3281 2
         Can't rely on restore_inferior_status because that only gets
         called if we don't stop in the called function.  */
d3301 1
a3301 1
int
d3308 1
a3308 1
int
d3315 1
a3315 1
int
d3477 1
a3477 1
         which signals to apply actions to. */
d3704 1
a3704 1
  int size = REGISTER_RAW_SIZE (regno);
d3743 1
a3743 1

d3777 3
a3779 3
     for function called by hand gdb creates no internal frame
     structure and the real stack and gdb's idea of stack are
     different if nested calls by hands are made.
d3781 1
a3781 1
     mvs: this worries me.  */
d3835 2
a3836 2
         walking the stack might encounter a garbage pointer and error()
         trying to dereference it.  */
a3875 1

d3878 1
d4016 14
a4029 14
/*                      "Set debugger response to a program call of fork \
   or vfork.\n\
   A fork or vfork creates a new process.  follow-fork-mode can be:\n\
   parent  - the original process is debugged after a fork\n\
   child   - the new process is debugged after a fork\n\
   both    - both the parent and child are debugged after a fork\n\
   ask     - the debugger will ask for one of the above choices\n\
   For \"both\", another copy of the debugger will be started to follow\n\
   the new child process.  The original debugger will continue to follow\n\
   the original parent process.  To distinguish their prompts, the\n\
   debugger copy's prompt will be changed.\n\
   For \"parent\" or \"child\", the unfollowed process will run free.\n\
   By default, the debugger will follow the parent process.",
 */
d4039 1
a4039 1
/*  c->function.sfunc = ; */
@


1.1.1.10
log
@import gdb-1999-07-19 snapshot
@
text
@a1264 3
      /* Do only the cleanups that have been added by this
	 function. Let the continuations for the commands do the rest,
	 if there are any. */
a3114 1
  target_executing = 0;
d3123 1
@


1.1.1.11
log
@import gdb-1999-08-02 snapshot
@
text
@a1300 10
/* Call this function before setting step_resume_breakpoint, as a
   sanity check.  We should never be setting a new
   step_resume_breakpoint when we have an old one active.  */
static void
check_for_old_step_resume_breakpoint ()
{
  if (step_resume_breakpoint)
    warning ("GDB bug: infrun.c (wait_for_inferior): dropping old step_resume breakpoint");
}

d2146 2
a2147 2
	/* I'm not sure whether this needs to be check_sigtramp2 or
	   whether it could/should be keep_going.
d2149 2
a2150 2
	   This used to jump to step_over_function if we are stepping,
	   which is wrong.
d2152 4
a2155 27
	   Suppose the user does a `next' over a function call, and while
	   that call is in progress, the inferior receives a signal for
	   which GDB does not stop (i.e., signal_stop[SIG] is false).  In
	   that case, when we reach this point, there is already a
	   step-resume breakpoint established, right where it should be:
	   immediately after the function call the user is "next"-ing
	   over.  If we jump to step_over_function now, two bad things
	   happen:

	   - we'll create a new breakpoint, at wherever the current
	     frame's return address happens to be.  That could be
	     anywhere, depending on what function call happens to be on
	     the top of the stack at that point.  Point is, it's probably
	     not where we need it.

           - the existing step-resume breakpoint (which is at the correct
	     address) will get orphaned: step_resume_breakpoint will point
	     to the new breakpoint, and the old step-resume breakpoint
	     will never be cleaned up.

           The old behavior was meant to help HP-UX single-step out of
           sigtramps.  It would place the new breakpoint at prev_pc, which
           was certainly wrong.  I don't know the details there, so fixing
           this probably breaks that.  As with anything else, it's up to
           the HP-UX maintainer to furnish a fix that doesn't break other
           platforms.  --JimB, 20 May 1999 */
	goto check_sigtramp2;
a2515 1
	      check_for_old_step_resume_breakpoint ();
a2597 1
		check_for_old_step_resume_breakpoint ();
d2622 1
a2622 11
	  /* We've just entered a callee, and we wish to resume until it
	     returns to the caller.  Setting a step_resume breakpoint on
	     the return address will catch a return from the callee.

	     However, if the callee is recursing, we want to be careful
	     not to catch returns of those recursive calls, but only of
	     THIS instance of the call.

	     To do this, we set the step_resume bp's frame to our current
	     caller's frame (step_frame_address, which is set by the "next"
	     or "until" command, before execution begins).  */
d2625 10
a2634 4
	  INIT_SAL (&sr_sal);	/* initialize to zeros */
	  sr_sal.pc = 
	    ADDR_BITS_REMOVE (SAVED_PC_AFTER_CALL (get_current_frame ()));
	  sr_sal.section = find_pc_overlay (sr_sal.pc);
a2635 1
	  check_for_old_step_resume_breakpoint ();
d2637 3
a2639 1
	    set_momentary_breakpoint (sr_sal, get_current_frame (),
d2642 25
a2666 1
	  if (!IN_SOLIB_DYNSYM_RESOLVE_CODE (sr_sal.pc))
a2715 1
	    check_for_old_step_resume_breakpoint ();
a2759 1
	    check_for_old_step_resume_breakpoint ();
@


1.1.1.12
log
@import gdb-1999-08-09 snapshot
@
text
@d41 1
a41 1
static void signals_info (char *, int);
d43 1
a43 1
static void handle_command (char *, int);
d45 1
a45 1
static void sig_print_info (enum target_signal);
d47 1
a47 1
static void sig_print_header (void);
d49 1
a49 1
static void resume_cleanups (int);
d51 1
a51 1
static int hook_stop_stub (void *);
d53 1
a53 1
static void delete_breakpoint_current_contents (void *);
d55 1
a55 2
static void set_follow_fork_mode_command (char *arg, int from_tty,
					  struct cmd_list_element * c);
d57 1
a57 31
static void complete_execution (void);

static struct inferior_status *xmalloc_inferior_status (void);

static void free_inferior_status (struct inferior_status *);

static int restore_selected_frame (void *);

static void build_infrun (void);

static void follow_inferior_fork (int parent_pid, int child_pid,
				  int has_forked, int has_vforked);

static void follow_fork (int parent_pid, int child_pid);

static void follow_vfork (int parent_pid, int child_pid);

static void set_schedlock_func (char *args, int from_tty,
				struct cmd_list_element * c);

static int is_internal_shlib_eventpoint (struct breakpoint * ep);

static int stopped_for_internal_shlib_event (bpstat bs);

struct execution_control_state;

static int currently_stepping (struct execution_control_state *ecs);

static void xdb_handle_command (char *args, int from_tty);

void _initialize_infrun (void);
a62 1

d67 1
a67 2
   running in.  */

d101 1
a101 2
   thread steps and others wait" shouldn't do this.  */

d113 28
d396 5
a400 2
follow_inferior_fork (int parent_pid, int child_pid, int has_forked,
		      int has_vforked)
d404 1
d408 1
a408 1
    savestring (follow_fork_mode_string, strlen (follow_fork_mode_string));
d571 3
a573 1
follow_fork (int parent_pid, int child_pid)
d580 1
a580 1
static void follow_exec (int, char *);
d583 3
a585 1
follow_vfork (int parent_pid, int child_pid)
d600 3
a602 1
follow_exec (int pid, char *execd_pathname)
d710 2
a711 1
resume_cleanups (int arg)
d724 4
a727 1
set_schedlock_func (char *args, int from_tty, struct cmd_list_element *c)
d748 3
a750 1
resume (int step, enum target_signal sig)
d870 1
a870 1
clear_proceed_status (void)
d899 4
a902 1
proceed (CORE_ADDR addr, enum target_signal siggnal, int step)
a1033 1

d1035 1
a1035 1
start_remote (void)
d1064 1
a1064 1
init_wait_for_inferior (void)
d1093 2
a1094 1
delete_breakpoint_current_contents (void *arg)
d1148 1
a1148 1
void init_execution_control_state (struct execution_control_state * ecs);
d1150 1
a1150 1
void handle_inferior_event (struct execution_control_state * ecs);
d1159 1
a1159 1
wait_for_inferior (void)
d1222 1
a1222 1
fetch_inferior_event (void)
d1282 2
a1283 1
init_execution_control_state (struct execution_control_state *ecs)
d1305 1
a1305 1
check_for_old_step_resume_breakpoint (void)
d1316 2
a1317 1
handle_inferior_event (struct execution_control_state *ecs)
d1602 2
a1603 3
	pending_follow.execd_pathname =
	  savestring (ecs->ws.value.execd_pathname,
		      strlen (ecs->ws.value.execd_pathname));
d3049 2
a3050 1
currently_stepping (struct execution_control_state *ecs)
d3067 2
a3068 1
is_internal_shlib_eventpoint (struct breakpoint *ep)
a3077 1

d3079 2
a3080 1
stopped_for_internal_shlib_event (bpstat bs)
d3094 30
d3125 1
a3128 1

d3130 1
a3130 1
complete_execution (void)
d3132 1
a3132 1
  extern int cleanup_sigint_signal_handler (void);
d3154 1
a3154 1
normal_stop (void)
d3316 2
a3317 1
hook_stop_stub (void *cmd)
d3324 2
a3325 1
signal_stop_state (int signo)
d3331 2
a3332 1
signal_print_state (int signo)
d3338 2
a3339 1
signal_pass_state (int signo)
d3345 1
a3345 1
sig_print_header (void)
d3352 2
a3353 1
sig_print_info (enum target_signal oursig)
a3356 1

d3372 3
a3374 1
handle_command (char *args, int from_tty)
d3556 3
a3558 1
xdb_handle_command (char *args, int from_tty)
d3630 3
a3632 1
signals_info (char *signum_exp, int from_tty)
d3698 2
d3701 1
a3701 1
xmalloc_inferior_status (void)
d3710 1
d3712 2
a3713 1
free_inferior_status (struct inferior_status *inf_status)
d3721 4
a3724 2
write_inferior_status_register (struct inferior_status *inf_status, int regno,
				LONGEST val)
d3732 2
d3739 2
a3740 1
save_inferior_status (int restore_stack_info)
d3781 2
d3784 2
a3785 1
restore_selected_frame (void *args)
d3816 2
a3817 1
restore_inferior_status (struct inferior_status *inf_status)
d3874 2
a3875 1
discard_inferior_status (struct inferior_status *inf_status)
d3883 4
a3886 2
set_follow_fork_mode_command (char *arg, int from_tty,
			      struct cmd_list_element *c)
d3899 3
d3903 1
a3903 1
build_infrun (void)
d3908 1
d3910 1
a3910 1
_initialize_infrun (void)
@


1.1.1.13
log
@import gdb-1999-08-16 snapshot
@
text
@d3091 1
a3091 1
      add_file_handler (input_fd, call_readline, 0);
@


1.1.1.14
log
@import gdb-1999-08-23 snapshot
@
text
@d1288 2
a1289 3
   sanity check.  There should never be more than one step-resume
   breakpoint per thread, so we should never be setting a new
   step_resume_breakpoint when one is already active.  */
d2292 1
a2292 6
	     stopped at, and carry on.  

	     Correction: what the code currently does is delete a
	     step-resume bp, but it makes no effort to ensure that
	     the one deleted is the one currently stopped at.  MVS  */

@


1.1.1.15
log
@import gdb-1999-08-30 snapshot
@
text
@a1138 4
static void check_sigtramp2 (struct execution_control_state *ecs);
static void stop_stepping (struct execution_control_state *ecs);
static void prepare_to_wait (struct execution_control_state *ecs);

d1340 1
a1340 2
	prepare_to_wait (ecs);
	return;
d1391 1
a1391 2
	prepare_to_wait (ecs);
	return;
d1426 1
a1426 2
	prepare_to_wait (ecs);
	return;
d1430 1
a1430 2
	prepare_to_wait (ecs);
	return;
d1450 1
a1450 2
	stop_stepping (ecs);
	return;
d1478 1
a1478 2
	stop_stepping (ecs);
	return;
d1495 1
a1495 2
	    prepare_to_wait (ecs);
	    return;
d1555 1
a1555 2
		prepare_to_wait (ecs);
		return;
d1583 1
a1583 2
	    prepare_to_wait (ecs);
	    return;
d1618 1
a1618 2
	    prepare_to_wait (ecs);
	    return;
d1664 1
a1664 2
	prepare_to_wait (ecs);
	return;
d1689 1
a1689 2
	prepare_to_wait (ecs);
	return;
d1706 1
a1706 2
	prepare_to_wait (ecs);
	return;
d1753 1
a1753 2
		    prepare_to_wait (ecs);
		    return;
d1764 1
a1764 2
		prepare_to_wait (ecs);
		return;
d1830 1
a1830 2
	    prepare_to_wait (ecs);
	    return;
d1896 1
a1896 2
	prepare_to_wait (ecs);
	return;
d1905 1
a1905 2
	prepare_to_wait (ecs);
	return;
d1939 1
a1939 2
	prepare_to_wait (ecs);
	return;
d1988 1
a1988 2
	    stop_stepping (ecs);
	    return;
d1991 1
a1991 4
	  {
	    stop_stepping (ecs);
	    return;
	  }
d2133 1
a2133 4
	  {
	    stop_stepping (ecs);
	    return;
	  }
d2175 1
a2175 1
	check_sigtramp2 (ecs);
d2270 1
a2270 2
	  stop_stepping (ecs);
	  return;
d2279 1
a2279 2
	  stop_stepping (ecs);
	  return;
d2352 1
a2352 2
		stop_stepping (ecs);
		return;
d2432 1
a2432 2
	stop_stepping (ecs);
	return;
d2455 1
a2455 2
	    stop_stepping (ecs);
	    return;
d2460 7
a2466 10
      {
	/* Having a step-resume breakpoint overrides anything
	   else having to do with stepping commands until
	   that breakpoint is reached.  */
	/* I'm not sure whether this needs to be check_sigtramp2 or
	   whether it could/should be keep_going.  */
	check_sigtramp2 (ecs);
	goto keep_going;
      }
    
d2468 4
a2471 7
      {
	/* Likewise if we aren't even stepping.  */
	/* I'm not sure whether this needs to be check_sigtramp2 or
	   whether it could/should be keep_going.  */
	check_sigtramp2 (ecs);
	goto keep_going;
      }
d2483 1
a2483 2
	check_sigtramp2 (ecs);
	goto keep_going;
d2598 1
a2598 2
	    stop_stepping (ecs);
	    return;
d2709 1
a2709 2
	    stop_stepping (ecs);
	    return;
d2743 1
a2743 2
	stop_stepping (ecs);
	return;
d2786 1
a2786 2
	stop_stepping (ecs);
	return;
d2797 1
a2797 2
	stop_stepping (ecs);
	return;
d2815 1
a2815 2
	stop_stepping (ecs);
	return;
d2832 36
d2935 1
a2935 4
	      {
		stop_stepping (ecs);
		return;
	      }
d2974 21
a2994 1
    prepare_to_wait (ecs);
d2996 1
d2998 2
a2999 6
  } /* extra brace, to preserve old indentation */

  stop_stepping (ecs);
}

/* Are we in the middle of stepping?  */
d3001 1
a3001 50
static int
currently_stepping (struct execution_control_state *ecs)
{
  return ((through_sigtramp_breakpoint == NULL
	   && !ecs->handling_longjmp
	   && ((step_range_end && step_resume_breakpoint == NULL)
	       || trap_expected))
	  || ecs->stepping_through_solib_after_catch
	  || bpstat_should_step ());
}

static void
check_sigtramp2 (struct execution_control_state *ecs)
{
  if (trap_expected
      && IN_SIGTRAMP (stop_pc, ecs->stop_func_name)
      && !IN_SIGTRAMP (prev_pc, prev_func_name)
      && INNER_THAN (read_sp (), step_sp))
    {
      /* What has happened here is that we have just stepped the
	 inferior with a signal (because it is a signal which
	 shouldn't make us stop), thus stepping into sigtramp.

	 So we need to set a step_resume_break_address breakpoint and
	 continue until we hit it, and then step.  FIXME: This should
	 be more enduring than a step_resume breakpoint; we should
	 know that we will later need to keep going rather than
	 re-hitting the breakpoint here (see the testsuite,
	 gdb.base/signals.exp where it says "exceedingly difficult").  */

      struct symtab_and_line sr_sal;

      INIT_SAL (&sr_sal);	/* initialize to zeroes */
      sr_sal.pc = prev_pc;
      sr_sal.section = find_pc_overlay (sr_sal.pc);
      /* We perhaps could set the frame if we kept track of what the
	 frame corresponding to prev_pc was.  But we don't, so don't.  */
      through_sigtramp_breakpoint =
	set_momentary_breakpoint (sr_sal, NULL, bp_through_sigtramp);
      if (breakpoints_inserted)
	insert_breakpoints ();

      ecs->remove_breakpoints_on_following_step = 1;
      ecs->another_trap = 1;
    }
}

static void
stop_stepping (struct execution_control_state *ecs)
{
d3006 2
a3007 3
         parent's event.  And, inferior_pid is still set to the
         parent's pid, until we resume again and follow either the
         parent or child.
a3033 1

d3038 1
a3038 3
/* This function normally comes after a resume, before
   handle_inferior_event exits.  It takes care of any last bits of
   housekeeping, and sets the all-important wait_some_more flag.  */
d3040 2
a3041 2
static void
prepare_to_wait (struct execution_control_state *ecs)
d3043 6
a3048 18
  if (ecs->infwait_state == infwait_normal_state)
    {
      overlay_cache_invalid = 1;

      /* We have to invalidate the registers BEFORE calling
	 target_wait because they can be loaded from the target while
	 in target_wait.  This makes remote debugging a bit more
	 efficient for those targets that provide critical registers
	 as part of their normal status mechanism. */

      registers_changed ();
      ecs->waiton_pid = -1;
      ecs->wp = &(ecs->ws);
    }
  /* This is the old end of the while loop.  Let everybody know we
     want to wait for the inferior some more and get called again
     soon.  */
  ecs->wait_some_more = 1;
a3101 5
    }
  else
    {
      if (exec_done_display_p)
	printf_unfiltered ("completed.\n");
@


1.1.1.16
log
@import gdb-1999-09-08 snapshot
@
text
@d179 4
a182 38
/* If the program uses ELF-style shared libraries, then calls to
   functions in shared libraries go through stubs, which live in a
   table called the PLT (Procedure Linkage Table).  The first time the
   function is called, the stub sends control to the dynamic linker,
   which looks up the function's real address, patches the stub so
   that future calls will go directly to the function, and then passes
   control to the function.

   If we are stepping at the source level, we don't want to see any of
   this --- we just want to skip over the stub and the dynamic linker.
   The simple approach is to single-step until control leaves the
   dynamic linker.

   However, on some systems (e.g., Red Hat Linux 5.2) the dynamic
   linker calls functions in the shared C library, so you can't tell
   from the PC alone whether the dynamic linker is still running.  In
   this case, we use a step-resume breakpoint to get us past the
   dynamic linker, as if we were using "next" to step over a function
   call.

   IN_SOLIB_DYNSYM_RESOLVE_CODE says whether we're in the dynamic
   linker code or not.  Normally, this means we single-step.  However,
   if SKIP_SOLIB_RESOLVER then returns non-zero, then its value is an
   address where we can place a step-resume breakpoint to get past the
   linker's symbol resolution function.

   IN_SOLIB_DYNSYM_RESOLVE_CODE can generally be implemented in a
   pretty portable way, by comparing the PC against the address ranges
   of the dynamic linker's sections.

   SKIP_SOLIB_RESOLVER is generally going to be system-specific, since
   it depends on internal details of the dynamic linker.  It's usually
   not too hard to figure out where to put a breakpoint, but it
   certainly isn't portable.  SKIP_SOLIB_RESOLVER should do plenty of
   sanity checking.  If it can't figure things out, returning zero and
   getting the (possibly confusing) stepping behavior is better than
   signalling an error, which will obscure the change in the
   inferior's state.  */
a187 4
#ifndef SKIP_SOLIB_RESOLVER
#define SKIP_SOLIB_RESOLVER(pc) 0
#endif

a1139 1
static void step_over_function (struct execution_control_state *ecs);
a1141 1
static void keep_going (struct execution_control_state *ecs);
d2111 1
a2111 2
	    keep_going (ecs);
	    return;
d2118 2
a2119 3
	    stop_signal = TARGET_SIGNAL_0;	
	    keep_going (ecs);
	    return;
d2129 1
a2129 2
	    keep_going (ecs);
	    return;
d2185 1
a2185 1
	   over.  If we call step_over_function now, two bad things
d2233 1
a2233 4
	    {
	      keep_going (ecs);
	      return;
	    }
d2259 1
a2259 2
	  keep_going (ecs);
	  return;
d2272 1
a2272 2
	      keep_going (ecs);
	      return;
d2455 1
a2455 2
	    keep_going (ecs);
	    return;
d2502 1
a2502 2
	keep_going (ecs);
	return;
d2511 1
a2511 2
	keep_going (ecs);
	return;
d2525 1
a2525 2
	keep_going (ecs);
	return;
d2535 1
a2535 21
      {
	CORE_ADDR pc_after_resolver = SKIP_SOLIB_RESOLVER (stop_pc);

	if (pc_after_resolver)
	  {
	    /* Set up a step-resume breakpoint at the address
	       indicated by SKIP_SOLIB_RESOLVER.  */
	    struct symtab_and_line sr_sal;
	    INIT_SAL (&sr_sal);
	    sr_sal.pc = pc_after_resolver;

	    check_for_old_step_resume_breakpoint ();
	    step_resume_breakpoint =
	      set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
	    if (breakpoints_inserted)
	      insert_breakpoints ();
	  }

	keep_going (ecs);
	return;
      }
d2594 1
a2594 1
	         Normally, we'd call step_over_function from
d2623 1
a2623 2
	keep_going (ecs);
	return;
d2645 2
a2646 6
	  {
	    /* We're doing a "next".  */
	    step_over_function (ecs);
	    keep_going (ecs);
	    return;
	  }
d2671 1
a2671 2
		keep_going (ecs);
		return;
d2688 34
a2721 3
	step_over_function (ecs);
	keep_going (ecs);
	return;
d2775 1
a2775 2
	keep_going (ecs);
	return;
d2820 1
a2820 2
	    keep_going (ecs);
	    return;
d2880 111
a2990 1
    keep_going (ecs);
d2993 2
a3045 33

/* We've just entered a callee, and we wish to resume until it returns
   to the caller.  Setting a step_resume breakpoint on the return
   address will catch a return from the callee.
     
   However, if the callee is recursing, we want to be careful not to
   catch returns of those recursive calls, but only of THIS instance
   of the call.

   To do this, we set the step_resume bp's frame to our current
   caller's frame (step_frame_address, which is set by the "next" or
   "until" command, before execution begins).  */

static void
step_over_function (struct execution_control_state *ecs)
{
  struct symtab_and_line sr_sal;

  INIT_SAL (&sr_sal);	/* initialize to zeros */
  sr_sal.pc = ADDR_BITS_REMOVE (SAVED_PC_AFTER_CALL (get_current_frame ()));
  sr_sal.section = find_pc_overlay (sr_sal.pc);

  check_for_old_step_resume_breakpoint ();
  step_resume_breakpoint =
    set_momentary_breakpoint (sr_sal, get_current_frame (), bp_step_resume);

  if (!IN_SOLIB_DYNSYM_RESOLVE_CODE (sr_sal.pc))
    step_resume_breakpoint->frame = step_frame_address;

  if (breakpoints_inserted)
    insert_breakpoints ();
}

a3086 112
/* This function handles various cases where we need to continue
   waiting for the inferior.  */
/* (Used to be the keep_going: label in the old wait_for_inferior) */

static void
keep_going (struct execution_control_state *ecs)
{
  /* ??rehrauer: ttrace on HP-UX theoretically allows one to debug a
     vforked child between its creation and subsequent exit or call to
     exec().  However, I had big problems in this rather creaky exec
     engine, getting that to work.  The fundamental problem is that
     I'm trying to debug two processes via an engine that only
     understands a single process with possibly multiple threads.

     Hence, this spot is known to have problems when
     target_can_follow_vfork_prior_to_exec returns 1. */

  /* Save the pc before execution, to compare with pc after stop.  */
  prev_pc = read_pc ();	/* Might have been DECR_AFTER_BREAK */
  prev_func_start = ecs->stop_func_start;	/* Ok, since if DECR_PC_AFTER
						   BREAK is defined, the
						   original pc would not have
						   been at the start of a
						   function. */
  prev_func_name = ecs->stop_func_name;

  if (ecs->update_step_sp)
    step_sp = read_sp ();
  ecs->update_step_sp = 0;

  /* If we did not do break;, it means we should keep running the
     inferior and not return to debugger.  */

  if (trap_expected && stop_signal != TARGET_SIGNAL_TRAP)
    {
      /* We took a signal (which we are supposed to pass through to
	 the inferior, else we'd have done a break above) and we
	 haven't yet gotten our trap.  Simply continue.  */
      resume (currently_stepping (ecs), stop_signal);
    }
  else
    {
      /* Either the trap was not expected, but we are continuing
	 anyway (the user asked that this signal be passed to the
	 child)
	 -- or --
	 The signal was SIGTRAP, e.g. it was our signal, but we
	 decided we should resume from it.

	 We're going to run this baby now!

	 Insert breakpoints now, unless we are trying to one-proceed
	 past a breakpoint.  */
      /* If we've just finished a special step resume and we don't
	 want to hit a breakpoint, pull em out.  */
      if (step_resume_breakpoint == NULL
	  && through_sigtramp_breakpoint == NULL
	  && ecs->remove_breakpoints_on_following_step)
	{
	  ecs->remove_breakpoints_on_following_step = 0;
	  remove_breakpoints ();
	  breakpoints_inserted = 0;
	}
      else if (!breakpoints_inserted &&
	       (through_sigtramp_breakpoint != NULL || !ecs->another_trap))
	{
	  breakpoints_failed = insert_breakpoints ();
	  if (breakpoints_failed)
	    {
	      stop_stepping (ecs);
	      return;
	    }
	  breakpoints_inserted = 1;
	}

      trap_expected = ecs->another_trap;

      /* Do not deliver SIGNAL_TRAP (except when the user explicitly
	 specifies that such a signal should be delivered to the
	 target program).

	 Typically, this would occure when a user is debugging a
	 target monitor on a simulator: the target monitor sets a
	 breakpoint; the simulator encounters this break-point and
	 halts the simulation handing control to GDB; GDB, noteing
	 that the break-point isn't valid, returns control back to the
	 simulator; the simulator then delivers the hardware
	 equivalent of a SIGNAL_TRAP to the program being debugged. */

      if (stop_signal == TARGET_SIGNAL_TRAP
	  && !signal_program[stop_signal])
	stop_signal = TARGET_SIGNAL_0;

#ifdef SHIFT_INST_REGS
      /* I'm not sure when this following segment applies.  I do know,
	 now, that we shouldn't rewrite the regs when we were stopped
	 by a random signal from the inferior process.  */
      /* FIXME: Shouldn't this be based on the valid bit of the SXIP?
	 (this is only used on the 88k).  */

      if (!bpstat_explains_signal (stop_bpstat)
	  && (stop_signal != TARGET_SIGNAL_CHLD)
	  && !stopped_by_random_signal)
	SHIFT_INST_REGS ();
#endif /* SHIFT_INST_REGS */

      resume (currently_stepping (ecs), stop_signal);
    }

    prepare_to_wait (ecs);
}

a3365 27
}

int signal_stop_update (signo, state)
     int signo;
     int state;
{
  int ret = signal_stop[signo];
  signal_stop[signo] = state;
  return ret;
}

int signal_print_update (signo, state)
     int signo;
     int state;
{
  int ret = signal_print[signo];
  signal_print[signo] = state;
  return ret;
}

int signal_pass_update (signo, state)
     int signo;
     int state;
{
  int ret = signal_program[signo];
  signal_program[signo] = state;
  return ret;
@


1.1.1.17
log
@import gdb-1999-09-21
@
text
@a37 2
#include "event-top.h"
#include "remote.h" /* For cleanup_sigint_signal_handler. */
a270 20
/* We can't step off a permanent breakpoint in the ordinary way, because we
   can't remove it.  Instead, we have to advance the PC to the next
   instruction.  This macro should expand to a pointer to a function that
   does that, or zero if we have no such function.  If we don't have a
   definition for it, we have to report an error.  */
#ifndef SKIP_PERMANENT_BREAKPOINT 
#define SKIP_PERMANENT_BREAKPOINT (default_skip_permanent_breakpoint)
static void
default_skip_permanent_breakpoint ()
{
  error_begin ();
  fprintf_filtered (gdb_stderr, "\
The program is stopped at a permanent breakpoint, but GDB does not know\n\
how to step past a permanent breakpoint on this architecture.  Try using\n\
a command like `return' or `jump' to continue execution.\n");
  return_to_top_level (RETURN_ERROR);
}
#endif
   

a768 2


a792 7
  /* Normally, by the time we reach `resume', the breakpoints are either
     removed or inserted, as appropriate.  The exception is if we're sitting
     at a permanent breakpoint; we need to step over it, but permanent
     breakpoints can't be removed.  So we have to test for it here.  */
  if (breakpoint_here_p (read_pc ()) == permanent_breakpoint_here)
    SKIP_PERMANENT_BREAKPOINT ();

a1177 1
static void step_into_function (struct execution_control_state *ecs);
d1253 1
a1253 2
fetch_inferior_event (client_data)
     gdb_client_data client_data;
d2764 1
a2764 4
	    {
	      step_into_function (ecs);	
	      return;
	    }
d2770 54
a2982 57
/* Subroutine call with source code we should not step over.  Do step
   to the first line of code in it.  */

static void
step_into_function (struct execution_control_state *ecs)
{
  struct symtab *s;
  struct symtab_and_line sr_sal;

  s = find_pc_symtab (stop_pc);
  if (s && s->language != language_asm)
    ecs->stop_func_start = SKIP_PROLOGUE (ecs->stop_func_start);

  ecs->sal = find_pc_line (ecs->stop_func_start, 0);
  /* Use the step_resume_break to step until the end of the prologue,
     even if that involves jumps (as it seems to on the vax under
     4.2).  */
  /* If the prologue ends in the middle of a source line, continue to
     the end of that source line (if it is still within the function).
     Otherwise, just go to end of prologue.  */
#ifdef PROLOGUE_FIRSTLINE_OVERLAP
  /* no, don't either.  It skips any code that's legitimately on the
     first line.  */
#else
  if (ecs->sal.end
      && ecs->sal.pc != ecs->stop_func_start
      && ecs->sal.end < ecs->stop_func_end)
    ecs->stop_func_start = ecs->sal.end;
#endif

  if (ecs->stop_func_start == stop_pc)
    {
      /* We are already there: stop now.  */
      stop_step = 1;
      stop_stepping (ecs);
      return;
    }
  else
    {
      /* Put the step-breakpoint there and go until there.  */
      INIT_SAL (&sr_sal);	/* initialize to zeroes */
      sr_sal.pc = ecs->stop_func_start;
      sr_sal.section = find_pc_overlay (ecs->stop_func_start);
      /* Do not specify what the fp should be when we stop since on
	 some machines the prologue is where the new fp value is
	 established.  */
      check_for_old_step_resume_breakpoint ();
      step_resume_breakpoint =
	set_momentary_breakpoint (sr_sal, NULL, bp_step_resume);
      if (breakpoints_inserted)
	insert_breakpoints ();

      /* And make sure stepping stops right away then.  */
      step_range_end = step_range_start;
    }
  keep_going (ecs);
}
d3237 2
d3242 1
a3242 1
      add_file_handler (input_fd, stdin_event_handler, 0);
@


1.1.1.18
log
@import gdb-1999-09-28 snapshot
@
text
@d39 1
d1073 1
a1073 1
  if (!event_loop_p || !target_can_async_p ())
d1099 17
a1115 16
  /* Always go on waiting for the target, regardless of the mode. */
  /* FIXME: cagney/1999-09-23: At present it isn't possible to
     indicate th wait_for_inferior that a target should timeout if
     nothing is returned (instead of just blocking).  Because of this,
     targets expecting an immediate response need to, internally, set
     things up so that the target_wait() is forced to eventually
     timeout. */
  /* FIXME: cagney/1999-09-24: It isn't possible for target_open() to
     differentiate to its caller what the state of the target is after
     the initial open has been performed.  Here we're assuming that
     the target has stopped.  It should be possible to eventually have
     target_open() return to the caller an indication that the target
     is currently running and GDB state should be set to the same as
     for an async run. */
  wait_for_inferior ();
  normal_stop ();
d1591 7
a1597 1
	stop_bpstat = bpstat_stop_status (&stop_pc, currently_stepping (ecs));
d1645 7
a1651 1
	stop_bpstat = bpstat_stop_status (&stop_pc, currently_stepping (ecs));
d1716 7
a1722 1
	stop_bpstat = bpstat_stop_status (&stop_pc, currently_stepping (ecs));
d2108 11
a2118 6
	    /* Pass TRUE if our reason for stopping is something other
	       than hitting a breakpoint.  We do this by checking that
	       1) stepping is going on and 2) we didn't hit a breakpoint
	       in a signal handler without an intervening stop in
	       sigtramp, which is detected by a new stack pointer value
	       below any usual function calling stack adjustments.  */
d2120 1
d2122 2
a2123 1
		      && INNER_THAN (read_sp (), (step_sp - 16))))
a3276 1

d3279 4
a3282 1
      do_exec_error_cleanups (ALL_CLEANUPS);
@


1.1.1.19
log
@import gdb-1999-10-04 snapshot
@
text
@d37 2
a38 1
#include "inf-loop.h"
d59 2
d966 1
a966 1
  if (addr == (CORE_ADDR) -1)
d1284 1
a1284 1
     void *client_data;
d1332 5
a1336 1
      inferior_event_handler (INF_EXEC_COMPLETE, NULL);
d3242 20
@


1.1.1.20
log
@import gdb-1999-10-18 snapshot
@
text
@d76 4
d2430 1
d3200 34
d3308 8
a3348 1
	  int do_frame_printing = 1;
d3351 17
a3367 22
	  switch (bpstat_ret)
	    {
	    case PRINT_UNKNOWN:
	      if (stop_step
		  && step_frame_address == FRAME_FP (get_current_frame ())
		  && step_start_function == find_pc_function (stop_pc))
		source_flag = -1;   /* finished step, just print source line */
	      else
		source_flag = 1;    /* print location and source line */
	      break;
	    case PRINT_SRC_AND_LOC:
	      source_flag = 1;	    /* print location and source line */
	      break;
	    case PRINT_SRC_ONLY:
	      source_flag = -1;
	      break;
	    case PRINT_NOTHING:
	      do_frame_printing = 0;
	      break;
	    default:
	      internal_error ("Unknown value.");
	    }
d3374 1
a3374 2
	  if (do_frame_printing)
	    show_and_print_stack_frame (selected_frame, -1, source_flag);
@


1.1.1.21
log
@import gdb-1999-11-08 snapshot
@
text
@a1162 18
/* Why did the inferior stop? Used to print the appropriate messages
   to the interface from within handle_inferior_event(). */
enum inferior_stop_reason
{
  /* We don't know why. */
  STOP_UNKNOWN,
  /* Step, next, nexti, stepi finished. */
  END_STEPPING_RANGE,
  /* Found breakpoint. */
  BREAKPOINT_HIT,
  /* Inferior terminated by signal. */
  SIGNAL_EXITED,
  /* Inferior exited. */
  EXITED,
  /* Inferior received signal, and user asked to be notified. */
  SIGNAL_RECEIVED
};

a1204 1
static void print_stop_reason (enum inferior_stop_reason stop_reason, int stop_info);
d1502 6
a1507 1
	print_stop_reason (EXITED, ecs->ws.value.integer);
d1525 1
d1534 12
a1545 1
	print_stop_reason (SIGNAL_EXITED, stop_signal);
d2185 11
a2195 1
	    print_stop_reason (SIGNAL_RECEIVED, stop_signal);
a2706 1
	    print_stop_reason (END_STEPPING_RANGE, 0);
a2777 1
	print_stop_reason (END_STEPPING_RANGE, 0);
a2822 1
	print_stop_reason (END_STEPPING_RANGE, 0);
a2834 1
	print_stop_reason (END_STEPPING_RANGE, 0);
a2853 1
	print_stop_reason (END_STEPPING_RANGE, 0);
a2959 1
	print_stop_reason (END_STEPPING_RANGE, 0);
a3193 68
}

/* Print why the inferior has stopped. We always print something when
   the inferior exits, or receives a signal. The rest of the cases are
   dealt with later on in normal_stop() and print_it_typical().  Ideally
   there should be a call to this function from handle_inferior_event()
   each time stop_stepping() is called.*/
static void
print_stop_reason (enum inferior_stop_reason stop_reason, int stop_info)
{
  switch (stop_reason)
    {
    case STOP_UNKNOWN:
      /* We don't deal with these cases from handle_inferior_event()
         yet. */
      break;
    case END_STEPPING_RANGE:
      /* We are done with a step/next/si/ni command. */
      /* For now print nothing. */
      break;
    case BREAKPOINT_HIT:
      /* We found a breakpoint. */
      /* For now print nothing. */
      break;
    case SIGNAL_EXITED:
      /* The inferior was terminated by a signal. */
      annotate_signalled ();
      printf_filtered ("\nProgram terminated with signal ");
      annotate_signal_name ();
      printf_filtered ("%s", target_signal_to_name (stop_info));
      annotate_signal_name_end ();
      printf_filtered (", ");
      annotate_signal_string ();
      printf_filtered ("%s", target_signal_to_string (stop_info));
      annotate_signal_string_end ();
      printf_filtered (".\n");

      printf_filtered ("The program no longer exists.\n");
      gdb_flush (gdb_stdout);
      break;
    case EXITED:
      /* The inferior program is finished. */
      annotate_exited (stop_info);
      if (stop_info)
	printf_filtered ("\nProgram exited with code 0%o.\n",
			 (unsigned int) stop_info);
      else
	printf_filtered ("\nProgram exited normally.\n");
      break;
    case SIGNAL_RECEIVED:
      /* Signal received. The signal table tells us to print about
         it. */
      annotate_signal ();
      printf_filtered ("\nProgram received signal ");
      annotate_signal_name ();
      printf_filtered ("%s", target_signal_to_name (stop_info));
      annotate_signal_name_end ();
      printf_filtered (", ");
      annotate_signal_string ();
      printf_filtered ("%s", target_signal_to_string (stop_info));
      annotate_signal_string_end ();
      printf_filtered (".\n");
      gdb_flush (gdb_stdout);      
      break;
    default:
      internal_error ("print_stop_reason: unrecognized enum value");
      break;
    }
@


1.1.1.22
log
@import gdb-1999-12-06 snapshot
@
text
@d273 1
a273 1
default_skip_permanent_breakpoint (void)
d1344 1
a1344 4
      if (step_multi && stop_step)
	inferior_event_handler (INF_EXEC_CONTINUE, NULL);
      else
	inferior_event_handler (INF_EXEC_COMPLETE, NULL);
a1353 1
  /* ecs->another_trap? */
d1900 12
a1911 32
	/* Caution: it may happen that the new thread (or the old one!)
	   is not in the thread list.  In this case we must not attempt
	   to "switch context", or we run the risk that our context may
	   be lost.  This may happen as a result of the target module
	   mishandling thread creation.  */

	if (in_thread_list (inferior_pid) && in_thread_list (ecs->pid))
	  { /* Perform infrun state context switch: */
	    /* Save infrun state for the old thread.  */
	    save_infrun_state (inferior_pid, prev_pc,
			       prev_func_start, prev_func_name,
			       trap_expected, step_resume_breakpoint,
			       through_sigtramp_breakpoint,
			       step_range_start, step_range_end,
			       step_frame_address, ecs->handling_longjmp,
			       ecs->another_trap,
			       ecs->stepping_through_solib_after_catch,
			       ecs->stepping_through_solib_catchpoints,
			       ecs->stepping_through_sigtramp);

	    /* Load infrun state for the new thread.  */
	    load_infrun_state (ecs->pid, &prev_pc,
			       &prev_func_start, &prev_func_name,
			       &trap_expected, &step_resume_breakpoint,
			       &through_sigtramp_breakpoint,
			       &step_range_start, &step_range_end,
			       &step_frame_address, &ecs->handling_longjmp,
			       &ecs->another_trap,
			       &ecs->stepping_through_solib_after_catch,
			       &ecs->stepping_through_solib_catchpoints,
			       &ecs->stepping_through_sigtramp);
	  }
d1916 12
@


1.1.1.23
log
@import gdb-1999-12-13 snapshot
@
text
@a1757 11

	/* We had an event in the inferior, but we are not interested
	   in handling it at this level. The lower layers have already
	   done what needs to be done, if anything. This case can
	   occur only when the target is async or extended-async. One
	   of the circumstamces for this to happen is when the
	   inferior produces output for the console. The inferior has
	   not stopped, and we are ignoring the event. */
      case TARGET_WAITKIND_IGNORE:
	ecs->wait_some_more = 1;
	return;
@


1.1.1.24
log
@import gdb-2000-01-05 snapshot
@
text
@d95 11
a105 1
static int previous_inferior_pid;
d1253 2
a1254 1
  previous_inferior_pid = inferior_pid;
d1315 2
a1316 1
      previous_inferior_pid = inferior_pid;
d1947 2
d1955 1
d3303 2
a3304 1
  if ((previous_inferior_pid != inferior_pid)
d3308 1
a3308 1
      printf_filtered ("[Switching to %s]\n",
d3310 1
a3310 1
      previous_inferior_pid = inferior_pid;
@


1.1.1.25
log
@import gdb-2000-01-17 snapshot
@
text
@d2 1
a2 1
   Copyright 1986-1989, 1991-2000 Free Software Foundation, Inc.
d3384 1
a3384 1
		source_flag = SRC_LINE;   /* finished step, just print source line */
d3386 1
a3386 1
		source_flag = SRC_AND_LOC;    /* print location and source line */
d3389 1
a3389 1
	      source_flag = SRC_AND_LOC;    /* print location and source line */
d3392 1
a3392 1
	      source_flag = SRC_LINE;
d3403 3
a3405 3
	     SRC_LINE: Print only source line
	     LOCATION: Print only location
	     SRC_AND_LOC: Print location and source line */
@


1.1.1.26
log
@import gdb-2000-02-02 snapshot
@
text
@a1443 5
#ifdef UI_OUT
	ui_out_text (uiout, "[New ");
	ui_out_text (uiout, target_pid_or_tid_to_str (ecs->pid));
	ui_out_text (uiout, "]\n");
#else
a1444 1
#endif
a3225 13
#ifdef UI_OUT
      annotate_signalled ();
      ui_out_text (uiout, "\nProgram terminated with signal ");
      annotate_signal_name ();
      ui_out_field_string (uiout, "signal-name", target_signal_to_name (stop_info));
      annotate_signal_name_end ();
      ui_out_text (uiout, ", ");
      annotate_signal_string ();
      ui_out_field_string (uiout, "signal-meaning", target_signal_to_string (stop_info));
      annotate_signal_string_end ();
      ui_out_text (uiout, ".\n");
      ui_out_text (uiout, "The program no longer exists.\n");
#else
a3238 1
#endif
a3241 13
#ifdef UI_OUT
      annotate_exited (stop_info);
      if (stop_info)
	{
	  ui_out_text (uiout, "\nProgram exited with code ");
	  ui_out_field_fmt (uiout, "exit-code", "0%o", (unsigned int) stop_info);
	  ui_out_text (uiout, ".\n");
	}
      else
	{
	  ui_out_text (uiout, "\nProgram exited normally.\n");
	}
#else
a3247 1
#endif
a3251 12
#ifdef UI_OUT
      annotate_signal ();
      ui_out_text (uiout, "\nProgram received signal ");
      annotate_signal_name ();
      ui_out_field_string (uiout, "signal-name", target_signal_to_name (stop_info));
      annotate_signal_name_end ();
      ui_out_text (uiout, ", ");
      annotate_signal_string ();
      ui_out_field_string (uiout, "signal-meaning", target_signal_to_string (stop_info));
      annotate_signal_string_end ();
      ui_out_text (uiout, ".\n");
#else
a3262 1
#endif
@


1.1.1.27
log
@import gdb-2000-02-04 snapshot
@
text
@a863 2
      int resume_pid;

d875 1
a875 1
	      resume_pid = -1;
d887 2
a888 1
	      resume_pid = inferior_pid;
d894 1
d897 1
a897 1
	    resume_pid = inferior_pid;
d899 1
a899 1
	    resume_pid = -1;
a900 1
      target_resume (resume_pid, step, sig);
@


