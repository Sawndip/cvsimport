head	1.14;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.14
	gdb_7_6-2013-04-26-release:1.14
	gdb_7_6-branch:1.14.0.2
	gdb_7_6-2013-03-12-branchpoint:1.14
	gdb_7_5_1-2012-11-29-release:1.12
	gdb_7_5-2012-08-17-release:1.12
	gdb_7_5-branch:1.12.0.2
	gdb_7_5-2012-07-18-branchpoint:1.12
	gdb_7_4_1-2012-04-26-release:1.11.4.1
	gdb_7_4-2012-01-24-release:1.11.4.1
	gdb_7_4-branch:1.11.0.4
	gdb_7_4-2011-12-13-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.11
	gdb_7_3-2011-07-26-release:1.11
	gdb_7_3-branch:1.11.0.2
	gdb_7_3-2011-04-01-branchpoint:1.11
	gdb_7_2-2010-09-02-release:1.9
	gdb_7_2-branch:1.9.0.4
	gdb_7_2-2010-07-07-branchpoint:1.9
	gdb_7_1-2010-03-18-release:1.9
	gdb_7_1-branch:1.9.0.2
	gdb_7_1-2010-02-18-branchpoint:1.9
	gdb_7_0_1-2009-12-22-release:1.8
	gdb_7_0-2009-10-06-release:1.8
	gdb_7_0-branch:1.8.0.4
	gdb_7_0-2009-09-16-branchpoint:1.8
	arc-sim-20090309:1.6
	msnyder-checkpoint-072509-branch:1.8.0.2
	msnyder-checkpoint-072509-branchpoint:1.8
	arc-insight_6_8-branch:1.6.0.16
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.14
	insight_6_8-branchpoint:1.6
	reverse-20081226-branch:1.6.0.12
	reverse-20081226-branchpoint:1.6
	multiprocess-20081120-branch:1.6.0.10
	multiprocess-20081120-branchpoint:1.6
	reverse-20080930-branch:1.6.0.8
	reverse-20080930-branchpoint:1.6
	reverse-20080717-branch:1.6.0.6
	reverse-20080717-branchpoint:1.6
	msnyder-reverse-20080609-branch:1.6.0.4
	msnyder-reverse-20080609-branchpoint:1.6
	drow-reverse-20070409-branch:1.4.0.2
	drow-reverse-20070409-branchpoint:1.4
	gdb_6_8-2008-03-27-release:1.6
	gdb_6_8-branch:1.6.0.2
	gdb_6_8-2008-02-26-branchpoint:1.6
	gdb_6_7_1-2007-10-29-release:1.5
	gdb_6_7-2007-10-10-release:1.5
	gdb_6_7-branch:1.5.0.2
	gdb_6_7-2007-09-07-branchpoint:1.5
	insight_6_6-20070208-release:1.2
	gdb_6_6-2006-12-18-release:1.2
	gdb_6_6-branch:1.2.0.12
	gdb_6_6-2006-11-15-branchpoint:1.2
	insight_6_5-20061003-release:1.2
	gdb-csl-symbian-6_4_50_20060226-12:1.1.2.1
	nickrob-async-20060828-mergepoint:1.2
	gdb-csl-symbian-6_4_50_20060226-11:1.1.2.1
	gdb-csl-sourcerygxx-4_1-17:1.1.2.1
	gdb-csl-20060226-branch-local-2:1.1.2.1
	gdb-csl-sourcerygxx-4_1-14:1.1.2.1
	gdb-csl-sourcerygxx-4_1-13:1.1.2.1
	gdb-csl-sourcerygxx-4_1-12:1.1.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.1.2.1
	gdb_6_5-20060621-release:1.2
	gdb-csl-sourcerygxx-4_1-9:1.1.2.1
	gdb-csl-sourcerygxx-4_1-8:1.1.2.1
	gdb-csl-sourcerygxx-4_1-7:1.1.2.1
	gdb-csl-arm-2006q1-6:1.1.2.1
	gdb-csl-sourcerygxx-4_1-6:1.1.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.1.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.1.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.1.2.1
	gdb-csl-coldfire-4_1-11:1.1.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.1.2.1
	gdb-csl-coldfire-4_1-10:1.1.2.1
	gdb_6_5-branch:1.2.0.10
	gdb_6_5-2006-05-14-branchpoint:1.2
	gdb-csl-sourcerygxx-4_1-5:1.1.2.1
	nickrob-async-20060513-branch:1.2.0.8
	nickrob-async-20060513-branchpoint:1.2
	gdb-csl-sourcerygxx-4_1-4:1.1.2.1
	msnyder-reverse-20060502-branch:1.2.0.6
	msnyder-reverse-20060502-branchpoint:1.2
	gdb-csl-morpho-4_1-4:1.1.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.1.2.1
	readline_5_1-import-branch:1.2.0.4
	readline_5_1-import-branchpoint:1.2
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.1.2.1
	gdb-csl-symbian-20060226-branch:1.1.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.1.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.1.2.1
	msnyder-reverse-20060331-branch:1.2.0.2
	msnyder-reverse-20060331-branchpoint:1.2
	gdb-csl-20060226-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.14
date	2013.02.12.19.03.54;	author palves;	state Exp;
branches;
next	1.13;

1.13
date	2013.01.01.06.32.49;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2012.01.04.08.17.09;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.10.20.38.50;	author msnyder;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2011.01.01.15.33.13;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.01.07.31.38;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.17.18.39.13;	author uweigand;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.09.17.58.56;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.03.19.01.25;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.28.19.19.16;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.21.02.13.35;	author pbrook;	state dead;
branches
	1.1.2.1;
next	;

1.11.4.1
date	2012.01.06.04.43.26;	author brobecke;	state Exp;
branches;
next	;

1.1.2.1
date	2006.03.21.02.13.35;	author pbrook;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Consistent use of (C) after "Copyright".

While writing the previous patch, I noticed that we're not consistent
with the (C) in the copyright header.  The maintainers manual prefers
having it, though also says it's optional.  We have over 10x more
files with (C) than without in gdb's code, so I spent a few minutes
grepping and fixing.  Funny enough, the testsuite has it backwards.
I'll leave that for another time.

gdb/
2013-02-12  Pedro Alves  <palves@@redhat.com>

	* amd64-darwin-tdep.c: Add (C) after Copyright.
	* cli/cli-cmds.h: Ditto.
	* cli/cli-decode.c: Ditto.
	* cli/cli-decode.h: Ditto.
	* cli/cli-dump.c: Ditto.
	* cli/cli-dump.h: Ditto.
	* cli/cli-interp.c: Ditto.
	* cli/cli-logging.c: Ditto.
	* cli/cli-script.c: Ditto.
	* cli/cli-script.h: Ditto.
	* cli/cli-setshow.c: Ditto.
	* cli/cli-setshow.h: Ditto.
	* cli/cli-utils.c: Ditto.
	* cli/cli-utils.h: Ditto.
	* config/alpha/nm-osf3.h: Ditto.
	* config/djgpp/djconfig.sh: Ditto.
	* config/i386/nm-fbsd.h: Ditto.
	* config/i386/nm-i386gnu.h: Ditto.
	* config/nm-linux.h: Ditto.
	* config/nm-nto.h: Ditto.
	* config/rs6000/nm-rs6000.h: Ditto.
	* config/sparc/nm-sol2.h: Ditto.
	* darwin-nat-info.c: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* gdb-demangle.h: Ditto.
	* i386-darwin-nat.c: Ditto.
	* i386-darwin-tdep.c: Ditto.
	* linux-fork.h: Ditto.
	* m32c-tdep.c: Ditto.
	* microblaze-linux-tdep.c: Ditto.
	* microblaze-rom.c: Ditto.
	* microblaze-tdep.c: Ditto.
	* microblaze-tdep.h: Ditto.
	* mips-linux-tdep.h: Ditto.
	* ppc-ravenscar-thread.c: Ditto.
	* ppc-ravenscar-thread.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* sparc-ravenscar-thread.c: Ditto.
	* sparc-ravenscar-thread.h: Ditto.
	* tilegx-linux-tdep.c: Ditto.
	* unwind_stop_reasons.def: Ditto.
	* windows-nat.h: Ditto.
	* xtensa-linux-tdep.c: Ditto.
	* xtensa-xtregs.c: Ditto.
	* regformats/regdat.sh: Ditto.
	* regformats/regdef.h: Ditto.

gdb/gdbserver/
2013-02-12  Pedro Alves  <palves@@redhat.com>

	* linux-xtensa-low.c: Ditto.
	* xtensa-xtregs.c: Ditto.
@
text
@/* Interface to prologue value handling for GDB.
   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#ifndef PROLOGUE_VALUE_H
#define PROLOGUE_VALUE_H

/* When we analyze a prologue, we're really doing 'abstract
   interpretation' or 'pseudo-evaluation': running the function's code
   in simulation, but using conservative approximations of the values
   it would have when it actually runs.  For example, if our function
   starts with the instruction:

      addi r1, 42     # add 42 to r1

   we don't know exactly what value will be in r1 after executing this
   instruction, but we do know it'll be 42 greater than its original
   value.

   If we then see an instruction like:

      addi r1, 22     # add 22 to r1

   we still don't know what r1's value is, but again, we can say it is
   now 64 greater than its original value.

   If the next instruction were:

      mov r2, r1      # set r2 to r1's value

   then we can say that r2's value is now the original value of r1
   plus 64.

   It's common for prologues to save registers on the stack, so we'll
   need to track the values of stack frame slots, as well as the
   registers.  So after an instruction like this:

      mov (fp+4), r2

   then we'd know that the stack slot four bytes above the frame
   pointer holds the original value of r1 plus 64.

   And so on.

   Of course, this can only go so far before it gets unreasonable.  If
   we wanted to be able to say anything about the value of r1 after
   the instruction:

      xor r1, r3      # exclusive-or r1 and r3, place result in r1

   then things would get pretty complex.  But remember, we're just
   doing a conservative approximation; if exclusive-or instructions
   aren't relevant to prologues, we can just say r1's value is now
   'unknown'.  We can ignore things that are too complex, if that loss
   of information is acceptable for our application.

   So when I say "conservative approximation" here, what I mean is an
   approximation that is either accurate, or marked "unknown", but
   never inaccurate.

   Once you've reached the current PC, or an instruction that you
   don't know how to simulate, you stop.  Now you can examine the
   state of the registers and stack slots you've kept track of.

   - To see how large your stack frame is, just check the value of the
     stack pointer register; if it's the original value of the SP
     minus a constant, then that constant is the stack frame's size.
     If the SP's value has been marked as 'unknown', then that means
     the prologue has done something too complex for us to track, and
     we don't know the frame size.

   - To see where we've saved the previous frame's registers, we just
     search the values we've tracked --- stack slots, usually, but
     registers, too, if you want --- for something equal to the
     register's original value.  If the ABI suggests a standard place
     to save a given register, then we can check there first, but
     really, anything that will get us back the original value will
     probably work.

   Sure, this takes some work.  But prologue analyzers aren't
   quick-and-simple pattern patching to recognize a few fixed prologue
   forms any more; they're big, hairy functions.  Along with inferior
   function calls, prologue analysis accounts for a substantial
   portion of the time needed to stabilize a GDB port.  So I think
   it's worthwhile to look for an approach that will be easier to
   understand and maintain.  In the approach used here:

   - It's easier to see that the analyzer is correct: you just see
     whether the analyzer properly (albiet conservatively) simulates
     the effect of each instruction.

   - It's easier to extend the analyzer: you can add support for new
     instructions, and know that you haven't broken anything that
     wasn't already broken before.

   - It's orthogonal: to gather new information, you don't need to
     complicate the code for each instruction.  As long as your domain
     of conservative values is already detailed enough to tell you
     what you need, then all the existing instruction simulations are
     already gathering the right data for you.

   A 'struct prologue_value' is a conservative approximation of the
   real value the register or stack slot will have.  */

struct prologue_value {

  /* What sort of value is this?  This determines the interpretation
     of subsequent fields.  */
  enum {

    /* We don't know anything about the value.  This is also used for
       values we could have kept track of, when doing so would have
       been too complex and we don't want to bother.  The bottom of
       our lattice.  */
    pvk_unknown,

    /* A known constant.  K is its value.  */
    pvk_constant,

    /* The value that register REG originally had *UPON ENTRY TO THE
       FUNCTION*, plus K.  If K is zero, this means, obviously, just
       the value REG had upon entry to the function.  REG is a GDB
       register number.  Before we start interpreting, we initialize
       every register R to { pvk_register, R, 0 }.  */
    pvk_register,

  } kind;

  /* The meanings of the following fields depend on 'kind'; see the
     comments for the specific 'kind' values.  */
  int reg;
  CORE_ADDR k;
};

typedef struct prologue_value pv_t;


/* Return the unknown prologue value --- { pvk_unknown, ?, ? }.  */
pv_t pv_unknown (void);

/* Return the prologue value representing the constant K.  */
pv_t pv_constant (CORE_ADDR k);

/* Return the prologue value representing the original value of
   register REG, plus the constant K.  */
pv_t pv_register (int reg, CORE_ADDR k);


/* Return conservative approximations of the results of the following
   operations.  */
pv_t pv_add (pv_t a, pv_t b);               /* a + b */
pv_t pv_add_constant (pv_t v, CORE_ADDR k); /* a + k */
pv_t pv_subtract (pv_t a, pv_t b);          /* a - b */
pv_t pv_logical_and (pv_t a, pv_t b);       /* a & b */


/* Return non-zero iff A and B are identical expressions.

   This is not the same as asking if the two values are equal; the
   result of such a comparison would have to be a pv_boolean, and
   asking whether two 'unknown' values were equal would give you
   pv_maybe.  Same for comparing, say, { pvk_register, R1, 0 } and {
   pvk_register, R2, 0}.

   Instead, this function asks whether the two representations are the
   same.  */
int pv_is_identical (pv_t a, pv_t b);


/* Return non-zero if A is known to be a constant.  */
int pv_is_constant (pv_t a);

/* Return non-zero if A is the original value of register number R
   plus some constant, zero otherwise.  */
int pv_is_register (pv_t a, int r);


/* Return non-zero if A is the original value of register R plus the
   constant K.  */
int pv_is_register_k (pv_t a, int r, CORE_ADDR k);

/* A conservative boolean type, including "maybe", when we can't
   figure out whether something is true or not.  */
enum pv_boolean {
  pv_maybe,
  pv_definite_yes,
  pv_definite_no,
};


/* Decide whether a reference to SIZE bytes at ADDR refers exactly to
   an element of an array.  The array starts at ARRAY_ADDR, and has
   ARRAY_LEN values of ELT_SIZE bytes each.  If ADDR definitely does
   refer to an array element, set *I to the index of the referenced
   element in the array, and return pv_definite_yes.  If it definitely
   doesn't, return pv_definite_no.  If we can't tell, return pv_maybe.

   If the reference does touch the array, but doesn't fall exactly on
   an element boundary, or doesn't refer to the whole element, return
   pv_maybe.  */
enum pv_boolean pv_is_array_ref (pv_t addr, CORE_ADDR size,
                                 pv_t array_addr, CORE_ADDR array_len,
                                 CORE_ADDR elt_size,
                                 int *i);


/* A 'struct pv_area' keeps track of values stored in a particular
   region of memory.  */
struct pv_area;

/* Create a new area, tracking stores relative to the original value
   of BASE_REG.  If BASE_REG is SP, then this effectively records the
   contents of the stack frame: the original value of the SP is the
   frame's CFA, or some constant offset from it.

   Stores to constant addresses, unknown addresses, or to addresses
   relative to registers other than BASE_REG will trash this area; see
   pv_area_store_would_trash.

   To check whether a pointer refers to this area, only the low
   ADDR_BIT bits will be compared.  */
struct pv_area *make_pv_area (int base_reg, int addr_bit);

/* Free AREA.  */
void free_pv_area (struct pv_area *area);


/* Register a cleanup to free AREA.  */
struct cleanup *make_cleanup_free_pv_area (struct pv_area *area);


/* Store the SIZE-byte value VALUE at ADDR in AREA.

   If ADDR is not relative to the same base register we used in
   creating AREA, then we can't tell which values here the stored
   value might overlap, and we'll have to mark everything as
   unknown.  */
void pv_area_store (struct pv_area *area,
                    pv_t addr,
                    CORE_ADDR size,
                    pv_t value);

/* Return the SIZE-byte value at ADDR in AREA.  This may return
   pv_unknown ().  */
pv_t pv_area_fetch (struct pv_area *area, pv_t addr, CORE_ADDR size);

/* Return true if storing to address ADDR in AREA would force us to
   mark the contents of the entire area as unknown.  This could happen
   if, say, ADDR is unknown, since we could be storing anywhere.  Or,
   it could happen if ADDR is relative to a different register than
   the other stores base register, since we don't know the relative
   values of the two registers.

   If you've reached such a store, it may be better to simply stop the
   prologue analysis, and return the information you've gathered,
   instead of losing all that information, most of which is probably
   okay.  */
int pv_area_store_would_trash (struct pv_area *area, pv_t addr);


/* Search AREA for the original value of REGISTER.  If we can't find
   it, return zero; if we can find it, return a non-zero value, and if
   OFFSET_P is non-zero, set *OFFSET_P to the register's offset within
   AREA.  GDBARCH is the architecture of which REGISTER is a member.

   In the worst case, this takes time proportional to the number of
   items stored in AREA.  If you plan to gather a lot of information
   about registers saved in AREA, consider calling pv_area_scan
   instead, and collecting all your information in one pass.  */
int pv_area_find_reg (struct pv_area *area,
                      struct gdbarch *gdbarch,
                      int reg,
                      CORE_ADDR *offset_p);


/* For every part of AREA whose value we know, apply FUNC to CLOSURE,
   the value's address, its size, and the value itself.  */
void pv_area_scan (struct pv_area *area,
                   void (*func) (void *closure,
                                 pv_t addr,
                                 CORE_ADDR size,
                                 pv_t value),
                   void *closure);


#endif /* PROLOGUE_VALUE_H */
@


1.13
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d2 1
a2 1
   Copyright 2003-2013 Free Software Foundation, Inc.
@


1.12
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
   Copyright 2003-2005, 2007-2012 Free Software Foundation, Inc.
@


1.11
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* nto-procfs.c: Comment cleanup, mostly periods and spaces.
	* nto-tdep.c: Ditto.
	* nto-tdep.h: Ditto.
	* objc-exp.y: Ditto.
	* objc-lang.c: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* observer.c: Ditto.
	* opencl-lang.c: Ditto.
	* osabi.c: Ditto.
	* parse.c: Ditto.
	* parser-defs.h: Ditto.
	* p-exp.y: Ditto.
	* p-lang.c: Ditto.
	* posix-hdep.c: Ditto.
	* ppcbug-rom.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* ppc-linux-tdep.h: Ditto.
	* ppcnbsd-tdep.c: Ditto.
	* ppcobsd-tdep.c: Ditto.
	* ppcobsd-tdep.h: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* ppc-tdep.h: Ditto.
	* printcmd.c: Ditto.
	* proc-abi.c: Ditto.
	* proc-flags.c: Ditto.
	* procfs.c: Ditto.
	* proc-utils.h: Ditto.
	* progspace.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* ravenscar-sparc-thread.c: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote.c: Ditto.
	* remote-fileio.c: Ditto.
	* remote-fileio.h: Ditto.
	* remote.h: Ditto.
	* remote-m32r-sdi.c: Ditto.
	* remote-mips.c: Ditto.
	* remote-sim.c: Ditto.
	* rs6000-aix-tdep.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
@
text
@d2 1
a2 2
   Copyright 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.11.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright 2003-2005, 2007-2012 Free Software Foundation, Inc.
@


1.10
log
@run copyright.sh for 2011.
@
text
@d18 1
a18 1
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */
@


1.9
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2007, 2008, 2009, 2010
@


1.8
log
@	* prologue-value.c (make_pv_area): Add ADDR_BIT argument.
	Use it instead of address bits of current_gdbarch.
	* prologue-value.c (make_pv_area): Add ADDR_BIT argument.
	* arm-tdep.c (thumb_analyze_prologue): Pass address bits to
	make_pv_area.
	(arm_scan_prologue): Likewise.
	* m32c-tdep.c (m32c_analyze_prologue): Likewise.
	* mep-tdep.c (mep_analyze_prologue): Likewise.
	* mn10300-tdep.c (mn10300_analyze_prologue): Likewise.
	* s390-tdep.c (s390_analyze_prologue): Likewise.
@
text
@d2 2
a3 1
   Copyright 2003, 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.7
log
@        Updated copyright notices for most files.
@
text
@d232 5
a236 2
   pv_area_store_would_trash.  */
struct pv_area *make_pv_area (int base_reg);
@


1.6
log
@	Updated copyright notices for most files.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.5
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.4
log
@Copyright updates for 2007.
@
text
@d8 1
a8 1
   the Free Software Foundation; either version 2 of the License, or
d17 1
a17 6
   along with this program; if not, write to:

        Free Software Foundation, Inc.
        51 Franklin St - Fifth Floor
        Boston, MA 02110-1301
        USA */
@


1.3
log
@	Warning fixes.
	* ada-lang.c (find_struct_field): Initialize *byte_offset_p.
	* breakpoint.c (do_enable_breakpoint): Ignore both mem_cnt and i.
	* c-typeprint.c (c_type_print_varspec_suffix): Don't test length
	greater than or equal to zero.
	* m2-typeprint.c (m2_array): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	* gdbtypes.c (copy_type_recursive): Correct == typo.
	* i386-tdep.c (i386_skip_prologue): Remove stray semicolon.
	* linux-nat.c (linux_nat_info_proc_cmd): Don't compare a pointer
	greater than zero.
	* macroscope.c (sal_macro_scope): Don't name a local variable "main".
	(default_macro_scope): Remove unused variable.
	* prologue-value.h (pv_area_find_reg): Don't name an argument
	"register".
	* remote-fileio.c (remote_fio_func_map): Add missing braces.
	* remote.c (sigint_remote_twice_token, sigint_remote_token): Change
	type.
	(cleanup_sigint_signal_handler): Remove casts.
	* valprint.c (val_print): Use a volatile local for the modified
	argument.
	* varobj.c (languages): Remove extra array dimension.
	(varobj_create): Correct access to languages array.
	* mi/mi-cmd-break.c (mi_cmd_break_insert, mi_cmd_break_watch): Add
	missing braces.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Likewise.
	* mi/mi-cmd-env.c (mi_cmd_env_path, mi_cmd_env_dir): Likewise.
	* mi/mi-getopt.c (mi_valid_noargs): Likewise.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	(mi_cmd_data_write_memory): Likewise.
	* signals/signals.c (target_signal_to_string): Cast to int before
	comparing.
	* tui/tui-layout.c (init_and_make_win): Take and return a void *.
	Update all callers.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005 Free Software Foundation, Inc.
@


1.2
log
@src/gdb/ChangeLog:
2006-03-28  Jim Blandy  <jimb@@codesourcery.com>

	* prologue-value.c, prologue-value.h: New files.
	* Makefile.in (prologue_value_h): New variable.
	(HFILES_NO_SRCDIR): List prologue-value.h.
	(SFILES): List prologue-value.c.
	(COMMON_OBS): List prologue-value.o.
	(prologue-value.o): New rule.

src/gdb/doc/ChangeLog:
2006-03-28  Jim Blandy  <jimb@@codesourcery.com>

	* gdbint.texinfo (Prologue Analysis): New section.
@
text
@d288 1
a288 1
                      int register,
@


1.1
log
@file prologue-value.h was initially added on branch gdb-csl-20060226-branch.
@
text
@d1 302
@


1.1.2.1
log
@2006-03-21  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz <dan@@codesourcery.com>
	Jim Blandy <jimb@@codesourcery.com>

	* gdb/Makefile.in: Add prologue_value.{c,h}
	* gdb/arm-tdep.c: Include prologue-value.h.
	(thumb_skip_prologue): Remove.
	(thumb_analyze_prologue): New function.
	(arm_skip_prologue): Use thumb_analyze_prologue.
	(thumb_scan_prologue): Ditto.
	* gdb/prologue-value.c: New file.
	* gdb/prologue-value.h: New file.
	* gdb/config/arm/embed.mt (TDEPFILES): Add prologue-value.o.
	* gdb/config/arm/linux.mt (TDEPFILES): Add prologue-value.o.
	* gdb/config/arm/nbsd.mt (TDEPFILES): Add prologue-value.o.
	* gdb/config/arm/wince.mt (TDEPFILES): Add prologue-value.o.
	* gdb/testsuite/gdb.arch/thumb-prologue.c: New file.
	* gdb/testsuite/gdb.arch/thumb-prologue.exp: New file.
@
text
@a0 293
/* Interface to prologue value handling for GDB.
   Copyright 2003, 2004, 2005 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to:

        Free Software Foundation, Inc.
        51 Franklin St - Fifth Floor
        Boston, MA 02110-1301
        USA */

#ifndef PROLOGUE_VALUE_H
#define PROLOGUE_VALUE_H

/* When we analyze a prologue, we're really doing 'abstract
   interpretation' or 'pseudo-evaluation': running the function's code
   in simulation, but using conservative approximations of the values
   it would have when it actually runs.  For example, if our function
   starts with the instruction:

      addi r1, 42     # add 42 to r1

   we don't know exactly what value will be in r1 after executing this
   instruction, but we do know it'll be 42 greater than its original
   value.

   If we then see an instruction like:

      addi r1, 22     # add 22 to r1

   we still don't know what r1's value is, but again, we can say it is
   now 64 greater than its original value.

   If the next instruction were:

      mov r2, r1      # set r2 to r1's value

   then we can say that r2's value is now the original value of r1
   plus 64.

   It's common for prologues to save registers on the stack, so we'll
   need to track the values of stack frame slots, as well as the
   registers.  So after an instruction like this:

      mov (fp+4), r2

   Then we'd know that the stack slot four bytes above the frame
   pointer holds the original value of r1 plus 64.

   And so on.

   Of course, this can only go so far before it gets unreasonable.  If
   we wanted to be able to say anything about the value of r1 after
   the instruction:

      xor r1, r3      # exclusive-or r1 and r3, place result in r1

   then things would get pretty complex.  But remember, we're just
   doing a conservative approximation; if exclusive-or instructions
   aren't relevant to prologues, we can just say r1's value is now
   'unknown'.  We can ignore things that are too complex, if that loss
   of information is acceptable for our application.

   So when I say "conservative approximation" here, what I mean is an
   approximation that is either accurate, or marked "unknown", but
   never inaccurate.
   
   Once you've reached the current PC, or an instruction that you
   don't know how to simulate, you stop.  Now you can examine the
   state of the registers and stack slots you've kept track of.

   - To see how large your stack frame is, just check the value of the
     stack pointer register; if it's the original value of the SP
     minus a constant, then that constant is the stack frame's size.
     If the SP's value has been marked as 'unknown', then that means
     the prologue has done something too complex for us to track, and
     we don't know the frame size.

   - To see where we've saved the previous frame's registers, we just
     search the values we've tracked --- stack slots, usually, but
     registers, too, if you want --- for something equal to the
     register's original value.  If the ABI suggests a standard place
     to save a given register, then we can check there first, but
     really, anything that will get us back the original value will
     probably work.

   Sure, this takes some work.  But prologue analyzers aren't
   quick-and-simple pattern patching to recognize a few fixed prologue
   forms any more; they're big, hairy functions.  Along with inferior
   function calls, prologue analysis accounts for a substantial
   portion of the time needed to stabilize a GDB port.  So I think
   it's worthwhile to look for an approach that will be easier to
   understand and maintain.  In the approach used here:

   - It's easier to see that the analyzer is correct: you just see
     whether the analyzer properly (albiet conservatively) simulates
     the effect of each instruction.

   - It's easier to extend the analyzer: you can add support for new
     instructions, and know that you haven't broken anything that
     wasn't already broken before.

   - It's orthogonal: to gather new information, you don't need to
     complicate the code for each instruction.  As long as your domain
     of conservative values is already detailed enough to tell you
     what you need, then all the existing instruction simulations are
     already gathering the right data for you.

   A 'struct prologue_value' is a conservative approximation of the
   real value the register or stack slot will have.  */

struct prologue_value {

  /* What sort of value is this?  This determines the interpretation
     of subsequent fields.  */
  enum {

    /* We don't know anything about the value.  This is also used for
       values we could have kept track of, when doing so would have
       been too complex and we don't want to bother.  The bottom of
       our lattice.  */
    pvk_unknown,

    /* A known constant.  K is its value.  */
    pvk_constant,

    /* The value that register REG originally had *UPON ENTRY TO THE
       FUNCTION*, plus K.  If K is zero, this means, obviously, just
       the value REG had upon entry to the function.  REG is a GDB
       register number.  Before we start interpreting, we initialize
       every register R to { pvk_register, R, 0 }.  */
    pvk_register,

  } kind;

  /* The meanings of the following fields depend on 'kind'; see the
     comments for the specific 'kind' values.  */
  int reg;
  CORE_ADDR k;
};

typedef struct prologue_value pv_t;


/* Return the unknown prologue value --- { pvk_unknown, ?, ? }.  */
pv_t pv_unknown (void);

/* Return the prologue value representing the constant K.  */
pv_t pv_constant (CORE_ADDR k);

/* Return the prologue value representing the original value of
   register REG, plus the constant K.  */
pv_t pv_register (int reg, CORE_ADDR k);


/* Return conservative approximations of the results of the following
   operations.  */
pv_t pv_add (pv_t a, pv_t b);               /* a + b */
pv_t pv_add_constant (pv_t v, CORE_ADDR k); /* a + k */
pv_t pv_subtract (pv_t a, pv_t b);          /* a - b */
pv_t pv_logical_and (pv_t a, pv_t b);       /* a & b */


/* Return non-zero iff A and B are identical expressions.

   This is not the same as asking if the two values are equal; the
   result of such a comparison would have to be a pv_boolean, and
   asking whether two 'unknown' values were equal would give you
   pv_maybe.  Same for comparing, say, { pvk_register, R1, 0 } and {
   pvk_register, R2, 0}.

   Instead, this function asks whether the two representations are the
   same.  */
int pv_is_identical (pv_t a, pv_t b);


/* Return non-zero if A is known to be a constant.  */
int pv_is_constant (pv_t a);

/* Return non-zero if A is the original value of register number R
   plus some constant, zero otherwise.  */
int pv_is_register (pv_t a, int r);


/* Return non-zero if A is the original value of register R plus the
   constant K.  */
int pv_is_register_k (pv_t a, int r, CORE_ADDR k);

/* A conservative boolean type, including "maybe", when we can't
   figure out whether something is true or not.  */
enum pv_boolean {
  pv_maybe,
  pv_definite_yes,
  pv_definite_no,
};


/* Decide whether a reference to SIZE bytes at ADDR refers exactly to
   an element of an array.  The array starts at ARRAY_ADDR, and has
   ARRAY_LEN values of ELT_SIZE bytes each.  If ADDR definitely does
   refer to an array element, set *I to the index of the referenced
   element in the array, and return pv_definite_yes.  If it definitely
   doesn't, return pv_definite_no.  If we can't tell, return pv_maybe.

   If the reference does touch the array, but doesn't fall exactly on
   an element boundary, or doesn't refer to the whole element, return
   pv_maybe.  */
enum pv_boolean pv_is_array_ref (pv_t addr, CORE_ADDR size,
                                 pv_t array_addr, CORE_ADDR array_len, 
                                 CORE_ADDR elt_size,
                                 int *i);


/* A 'struct pv_area' keeps track of values stored in a particular
   region of memory.  */
struct pv_area;

/* Create a new area, tracking stores relative to BASE_REG.  Stores to
   constant addresses, unknown addresses, or to addresses relative to
   registers other than BASE_REG will trash this area; see
   pv_area_store_would_trash.  */
struct pv_area *make_pv_area (int base_reg);

/* Free AREA.  */
void free_pv_area (struct pv_area *area);


/* Register a cleanup to free AREA.  */
struct cleanup *make_cleanup_free_pv_area (struct pv_area *area);


/* Store the SIZE-byte value VALUE at ADDR in AREA.

   If ADDR is not relative to the same base register we used in
   creating AREA, then we can't tell which values here the stored
   value might overlap, and we'll have to mark everything as
   unknown.  */
void pv_area_store (struct pv_area *area,
                    pv_t addr,
                    CORE_ADDR size,
                    pv_t value);

/* Return the SIZE-byte value at ADDR in AREA.  This may return
   pv_unknown ().  */
pv_t pv_area_fetch (struct pv_area *area, pv_t addr, CORE_ADDR size);

/* Return true if storing to address ADDR in AREA would force us to
   mark the contents of the entire area as unknown.  This could happen
   if, say, ADDR is unknown, since we could be storing anywhere.  Or,
   it could happen if ADDR is relative to a different register than
   the other stores base register, since we don't know the relative
   values of the two registers.

   If you've reached such a store, it may be better to simply stop the
   prologue analysis, and return the information you've gathered,
   instead of losing all that information, most of which is probably
   okay.  */
int pv_area_store_would_trash (struct pv_area *area, pv_t addr);


/* Search AREA for the original value of REGISTER.  If we can't find
   it, return zero; if we can find it, return a non-zero value, and if
   OFFSET_P is non-zero, set *OFFSET_P to the register's offset within
   AREA.  GDBARCH is the architecture of which REGISTER is a member.  */
int pv_area_find_reg (struct pv_area *area,
                      struct gdbarch *gdbarch,
                      int register,
                      CORE_ADDR *offset_p);


/* For every part of AREA whose value we know, apply FUNC to CLOSURE,
   the value's address, its size, and the value itself.  */
void pv_area_scan (struct pv_area *area,
                   void (*func) (void *closure,
                                 pv_t addr,
                                 CORE_ADDR size,
                                 pv_t value),
                   void *closure);


#endif /* PROLOGUE_VALUE_H */
@

